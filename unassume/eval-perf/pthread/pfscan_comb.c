/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

typedef unsigned int size_t;
typedef int __ssize_t;
typedef __ssize_t ssize_t;
struct __anonstruct_BM_30 {
   int *bmGs ;
   int bmBc[256] ;
   unsigned char *saved_x ;
   int saved_m ;
   int icase ;
};
typedef struct __anonstruct_BM_30 BM;
typedef long long __quad_t;
typedef unsigned long long __u_quad_t;
typedef __u_quad_t __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long __off_t;
typedef __quad_t __off64_t;
typedef unsigned long __rlim_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_attr_t_14 {
   char __size[36] ;
   long __align ;
};
typedef union __anonunion_pthread_attr_t_14 pthread_attr_t;
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
typedef struct __pthread_internal_slist __pthread_slist_t;
union __anonunion____missing_field_name_16 {
   int __spins ;
   __pthread_slist_t __list ;
};
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_16 __annonCompField1 ;
};
union __anonunion_pthread_mutex_t_15 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_15 pthread_mutex_t;
union __anonunion_pthread_mutexattr_t_17 {
   char __size[4] ;
   long __align ;
};
typedef union __anonunion_pthread_mutexattr_t_17 pthread_mutexattr_t;
struct __anonstruct___data_19 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
union __anonunion_pthread_cond_t_18 {
   struct __anonstruct___data_19 __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_18 pthread_cond_t;
typedef void (*__sighandler_t)(int  );
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
typedef __rlim_t rlim_t;
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
typedef int __rlimit_resource_t;
struct __anonstruct_PQUEUE_63 {
   void **buf ;
   int qsize ;
   int occupied ;
   int nextin ;
   int nextout ;
   int closed ;
   pthread_mutex_t mtx ;
   pthread_cond_t more ;
   pthread_cond_t less ;
};
typedef struct __anonstruct_PQUEUE_63 PQUEUE;
union __anonunion_pthread_condattr_t_12 {
   char __size[4] ;
   long __align ;
};
typedef union __anonunion_pthread_condattr_t_12 pthread_condattr_t;
#pragma merger(0,"/tmp/cil-2xopH8kW.i","")
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
int bm_init(BM *bmp , unsigned char *x , int m , int icase ) ;
int bm_search(BM *bmp , unsigned char *y , size_t n , int (*mfun)(unsigned char *buf ,
                                                                  size_t n , size_t pos ,
                                                                  void *misc ) , void *misc ) ;
void bm_destroy(BM *bmp ) ;
int debug  ;
static void preBmBc(unsigned char *x , int m , int *bmBc ) 
{ int i ;

  {
  i = 0;
  while (i < 256) {
    *(bmBc + i) = m;
    i ++;
  }
  i = 0;
  while (i < m - 1) {
    *(bmBc + *(x + i)) = (m - i) - 1;
    i ++;
  }
  return;
}
}
static void suffixes(unsigned char *x , int m , int *suff ) 
{ int f ;
  int g ;
  int i ;

  {
  f = 0;
  *(suff + (m - 1)) = m;
  g = m - 1;
  i = m - 2;
  while (i >= 0) {
    if (i > g) {
      if (*(suff + (((i + m) - 1) - f)) < i - g) {
        *(suff + i) = *(suff + (((i + m) - 1) - f));
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (i < g) {
        g = i;
      }
      f = i;
      while (1) {
        if (g >= 0) {
          if (! ((int )*(x + g) == (int )*(x + (((g + m) - 1) - f)))) {
            break;
          }
        } else {
          break;
        }
        g --;
      }
      *(suff + i) = f - g;
    }
    i --;
  }
  return;
}
}
static int preBmGs(unsigned char *x , int m , int *bmGs ) 
{ int *suff ;
  int i ;
  int j ;
  void *tmp ;

  {
  tmp = calloc(sizeof(int ), (unsigned int )m);
  suff = (int *)tmp;
  if ((unsigned int )suff == (unsigned int )((void *)0)) {
    return (-1);
  }
  suffixes(x, m, suff);
  i = 0;
  while (i < m) {
    *(bmGs + i) = m;
    i ++;
  }
  j = 0;
  i = m - 1;
  while (i >= -1) {
    if (i == -1) {
      goto _L;
    } else {
      if (*(suff + i) == i + 1) {
        _L: /* CIL Label */ 
        while (j < (m - 1) - i) {
          if (*(bmGs + j) == m) {
            *(bmGs + j) = (m - 1) - i;
          }
          j ++;
        }
      }
    }
    i --;
  }
  i = 0;
  while (i <= m - 2) {
    *(bmGs + ((m - 1) - *(suff + i))) = (m - 1) - i;
    i ++;
  }
  free((void *)suff);
  return (0);
}
}
int bm_init(BM *bmp , unsigned char *x , int m , int icase ) 
{ int i ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  memset((void *)bmp, 0, sizeof(bmp));
  bmp->icase = icase;
  tmp = calloc(sizeof(int ), (unsigned int )m);
  bmp->bmGs = (int *)tmp;
  if ((unsigned int )bmp->bmGs == (unsigned int )((void *)0)) {
    return (-1);
  }
  bmp->saved_m = m;
  tmp___0 = malloc((unsigned int )m);
  bmp->saved_x = (unsigned char *)tmp___0;
  if ((unsigned int )bmp->saved_x == (unsigned int )((void *)0)) {
    return (-2);
  }
  i = 0;
  while (i < m) {
    if (icase) {
      tmp___1 = tolower((int )*(x + i));
      *(bmp->saved_x + i) = (unsigned char )tmp___1;
    } else {
      *(bmp->saved_x + i) = *(x + i);
    }
    i ++;
  }
  tmp___2 = preBmGs(bmp->saved_x, m, bmp->bmGs);
  if (tmp___2 < 0) {
    return (-3);
  }
  preBmBc(bmp->saved_x, m, bmp->bmBc);
  return (0);
}
}
void bm_destroy(BM *bmp ) 
{ 

  {
  if (bmp->bmGs) {
    free((void *)bmp->bmGs);
  }
  if (bmp->saved_x) {
    free((void *)bmp->saved_x);
  }
  return;
}
}
int bm_search(BM *bmp , unsigned char *y , size_t n , int (*mfun)(unsigned char *buf ,
                                                                  size_t n , size_t pos ,
                                                                  void *misc ) , void *misc ) 
{ ssize_t i ;
  ssize_t j ;
  int c ;
  int nm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char c___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  nm = 0;
  j = 0;
  while ((size_t )j <= n - (size_t )bmp->saved_m) {
    i = bmp->saved_m - 1;
    while (1) {
      if (i >= 0) {
        if (bmp->icase) {
          tmp = tolower((int )*(y + (i + j)));
          tmp___0 = tmp;
        } else {
          tmp___0 = (int )*(y + (i + j));
        }
        if (! ((int )*(bmp->saved_x + i) == tmp___0)) {
          break;
        }
      } else {
        break;
      }
      i --;
    }
    if (i < 0) {
      if (mfun) {
        nm ++;
        c = (*mfun)(y, n, (unsigned int )j, misc);
        if (c) {
          if (c < 0) {
            tmp___1 = c;
          } else {
            tmp___1 = nm;
          }
          return (tmp___1);
        }
        j += *(bmp->bmGs + 0);
      } else {
        return (j);
      }
    } else {
      if (bmp->icase) {
        tmp___2 = tolower((int )*(y + (i + j)));
        tmp___3 = tmp___2;
      } else {
        tmp___3 = (int )*(y + (i + j));
      }
      c___0 = (unsigned char )tmp___3;
      if (*(bmp->bmGs + i) < ((bmp->bmBc[c___0] - bmp->saved_m) + 1) + i) {
        tmp___4 = ((bmp->bmBc[c___0] - bmp->saved_m) + 1) + i;
      } else {
        tmp___4 = *(bmp->bmGs + i);
      }
      j += tmp___4;
    }
  }
  if ((unsigned int )mfun == (unsigned int )((void *)0)) {
    tmp___5 = -1;
  } else {
    tmp___5 = nm;
  }
  return (tmp___5);
}
}
#pragma merger(0,"/tmp/cil-bFpgwBOh.i","")
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
extern int putchar(int __c ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s )  __attribute__((__nonnull__(1),
__malloc__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat(3, __fd, __statbuf);
  return (tmp);
}
}
extern int ftw(char const   *__dir , int (*__func)(char const   *__filename , struct stat  const  *__status ,
                                                   int __flag ) , int __descriptors )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits ) ;
extern int close(int __fd ) ;
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __newthread ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg )  __attribute__((__nonnull__(1,3))) ;
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_attr_setscope(pthread_attr_t *__attr ,
                                                               int __scope )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
extern int pthread_cond_wait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex )  __attribute__((__nonnull__(1,2))) ;
int pqueue_init(PQUEUE *qp , int qsize ) ;
int pqueue_put(PQUEUE *qp , void *item ) ;
int pqueue_get(PQUEUE *qp , void **item ) ;
void pqueue_close(PQUEUE *qp ) ;
char version[4] ;
char *argv0  =    (char *)"pfscan";
int max_depth  =    64;
unsigned char *rstr  =    (unsigned char *)((void *)0);
int rlen  =    0;
int debug  =    0;
int verbose  =    0;
int nworkers  =    0;
int aworkers  =    0;
pthread_mutex_t aworker_lock  ;
pthread_cond_t aworker_cv  ;
int line_f  =    0;
int maxlen  =    64;
int ignore_case  =    0;
int n_matches  =    0;
int n_files  =    0;
size_t n_bytes  =    (size_t )0;
pthread_mutex_t matches_lock  ;
PQUEUE pqb  ;
pthread_mutex_t print_lock  ;
BM bmb  ;
void print_version(FILE *fp ) 
{ 

  {
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"[PFScan, version %s - %s %s]\n",
          version, "Feb  1 2008", "15:56:16");
  return;
}
}
int get_char_code(unsigned char **cp , int base ) 
{ int val ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  val = 0;
  len = 0;
  while (1) {
    if (base == 16) {
      tmp___3 = 2;
    } else {
      tmp___3 = 3;
    }
    if (len < tmp___3) {
      if ((int )*(*cp) >= 48) {
        if (base > 10) {
          tmp___4 = 10;
        } else {
          tmp___4 = base;
        }
        if (! ((int )*(*cp) < 48 + tmp___4)) {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (base >= 10) {
          tmp___5 = toupper((int )*(*cp));
          if (tmp___5 >= 65) {
            tmp___6 = toupper((int )*(*cp));
            if (! (tmp___6 < (65 + base) - 10)) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      }
    } else {
      break;
    }
    val *= base;
    if ((int )*(*cp) >= 48) {
      if (base > 10) {
        tmp___2 = 10;
      } else {
        tmp___2 = base;
      }
      if ((int )*(*cp) < 48 + tmp___2) {
        val += (int )*(*cp) - 48;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (base >= 10) {
        tmp___0 = toupper((int )*(*cp));
        if (tmp___0 >= 65) {
          tmp___1 = toupper((int )*(*cp));
          if (tmp___1 < (65 + base) - 10) {
            tmp = toupper((int )*(*cp));
            val += (tmp - 65) + 10;
          }
        }
      }
    }
    (*cp) ++;
    len ++;
  }
  return (val & 255);
}
}
int dehex(unsigned char *str ) 
{ unsigned char *wp ;
  unsigned char *rp ;
  int val ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned char *tmp___1 ;

  {
  wp = str;
  rp = wp;
  while (*rp) {
    while (1) {
      if (*rp) {
        tmp = __ctype_b_loc();
        if (! ((int const   )*(*tmp + (int )*rp) & 8192)) {
          break;
        }
      } else {
        break;
      }
      rp ++;
    }
    if ((int )*rp == 0) {
      break;
    }
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___0 + (int )*rp) & 4096)) {
      return (-1);
    }
    val = get_char_code(& rp, 16);
    tmp___1 = wp;
    wp ++;
    *tmp___1 = (unsigned char )val;
  }
  *wp = (unsigned char )'\000';
  return (wp - str);
}
}
int deslash(unsigned char *str ) 
{ unsigned char *wp ;
  unsigned char *rp ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  int tmp___6 ;
  unsigned char *tmp___7 ;
  int tmp___8 ;
  unsigned char *tmp___9 ;
  int tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;

  {
  wp = str;
  rp = wp;
  while (*rp) {
    if ((int )*rp != 92) {
      tmp = wp;
      wp ++;
      tmp___0 = rp;
      rp ++;
      *tmp = *tmp___0;
    } else {
      rp ++;
      switch ((int )*rp) {
      case 110: 
      tmp___1 = wp;
      wp ++;
      *tmp___1 = (unsigned char)10;
      rp ++;
      break;
      case 114: 
      tmp___2 = wp;
      wp ++;
      *tmp___2 = (unsigned char)13;
      rp ++;
      break;
      case 116: 
      tmp___3 = wp;
      wp ++;
      *tmp___3 = (unsigned char)9;
      rp ++;
      break;
      case 98: 
      tmp___4 = wp;
      wp ++;
      *tmp___4 = (unsigned char)8;
      rp ++;
      break;
      case 120: 
      rp ++;
      tmp___5 = wp;
      wp ++;
      tmp___6 = get_char_code(& rp, 16);
      *tmp___5 = (unsigned char )tmp___6;
      break;
      case 48: 
      tmp___7 = wp;
      wp ++;
      tmp___8 = get_char_code(& rp, 8);
      *tmp___7 = (unsigned char )tmp___8;
      break;
      case 49: 
      case 50: 
      case 51: 
      case 52: 
      case 53: 
      case 54: 
      case 55: 
      case 56: 
      case 57: 
      tmp___9 = wp;
      wp ++;
      tmp___10 = get_char_code(& rp, 10);
      *tmp___9 = (unsigned char )tmp___10;
      break;
      default: 
      tmp___11 = wp;
      wp ++;
      tmp___12 = rp;
      rp ++;
      *tmp___11 = *tmp___12;
      break;
      }
    }
  }
  *wp = (unsigned char )'\000';
  return (wp - str);
}
}
int is_text(unsigned char *cp , int slen ) 
{ unsigned short const   **tmp ;

  {
  while (1) {
    if (slen > 0) {
      tmp = __ctype_b_loc();
      if (! ((int const   )*(*tmp + (int )*cp) & 16384)) {
        if (! ((int )*cp == 0)) {
          if (! ((int )*cp == 9)) {
            if (! ((int )*cp == 10)) {
              if (! ((int )*cp == 13)) {
                break;
              }
            }
          }
        }
      }
    } else {
      break;
    }
    slen --;
    cp ++;
  }
  return (slen == 0);
}
}
size_t print_output(unsigned char *str , size_t slen ) 
{ size_t len ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  len = 0U;
  if ((unsigned int )str == (unsigned int )((void *)0)) {
    printf((char const   * __restrict  )"NULL");
    return (len);
  }
  tmp___0 = is_text(str, (int )slen);
  if (tmp___0) {
    printf((char const   * __restrict  )"TXT : ");
    while (1) {
      if (len < slen) {
        if (! (len < (size_t )maxlen)) {
          break;
        }
      } else {
        break;
      }
      tmp = __ctype_b_loc();
      if ((int const   )*(*tmp + (int )*str) & 16384) {
        putchar((int )*str);
      } else {
        switch ((int )*str) {
        case 0: 
        printf((char const   * __restrict  )"\\0");
        break;
        case 10: 
        if (line_f) {
          return (len);
        }
        printf((char const   * __restrict  )"\\n");
        break;
        case 13: 
        if (line_f) {
          return (len);
        }
        printf((char const   * __restrict  )"\\r");
        break;
        case 9: 
        printf((char const   * __restrict  )"\\t");
        break;
        default: 
        printf((char const   * __restrict  )"\\x%02x", *str);
        }
      }
      len ++;
      str ++;
    }
  } else {
    printf((char const   * __restrict  )"HEX :");
    while (1) {
      if (len < slen) {
        if (! (len < (size_t )maxlen)) {
          break;
        }
      } else {
        break;
      }
      printf((char const   * __restrict  )" %02x", *str);
      len ++;
      str ++;
    }
  }
  return (len);
}
}
int matchfun(unsigned char *buf , size_t len , size_t pos , void *misc ) 
{ char *pathname ;

  {
  pathname = (char *)misc;
  pthread_mutex_lock(& matches_lock);
  n_matches ++;
  pthread_mutex_unlock(& matches_lock);
  if (line_f) {
    while (1) {
      if (pos > 0U) {
        if ((int )*(buf + (pos - 1U)) == 10) {
          break;
        } else {
          if ((int )*(buf + (pos - 1U)) == 13) {
            break;
          }
        }
      } else {
        break;
      }
      pos --;
    }
  }
  pthread_mutex_lock(& print_lock);
  printf((char const   * __restrict  )"%s : %lu : ", pathname, (unsigned long )pos);
  print_output(buf + pos, len - pos);
  putchar('\n');
  pthread_mutex_unlock(& print_lock);
  return (0);
}
}
int scan_file(char *pathname ) 
{ int fd ;
  size_t len ;
  unsigned char *buf ;
  struct stat sb ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int code ;

  {
  fd = open((char const   *)pathname, 0);
  if (fd < 0) {
    if (verbose) {
      pthread_mutex_lock(& print_lock);
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s : ERR : open() failed: %s\n",
              pathname, tmp___0);
      pthread_mutex_unlock(& print_lock);
    }
    return (-1);
  }
  tmp___3 = fstat(fd, & sb);
  if (tmp___3 < 0) {
    if (verbose) {
      pthread_mutex_lock(& print_lock);
      tmp___1 = __errno_location();
      tmp___2 = strerror(*tmp___1);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s : ERR : fstat() failed: %s\n",
              pathname, tmp___2);
      pthread_mutex_unlock(& print_lock);
    }
    close(fd);
    return (-1);
  }
  len = (unsigned int )sb.st_size;
  if (debug > 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"*** Scanning file %s (%u Mbytes)\n",
            pathname, len / 1000000U);
  }
  tmp___4 = mmap((void *)0, len, 1, 16386, fd, 0L);
  buf = (unsigned char *)tmp___4;
  if ((unsigned int )buf == (unsigned int )((void *)-1)) {
    if (verbose) {
      pthread_mutex_lock(& print_lock);
      tmp___5 = __errno_location();
      tmp___6 = strerror(*tmp___5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s : ERR : mmap() failed: %s\n",
              pathname, tmp___6);
      pthread_mutex_unlock(& print_lock);
    }
    close(fd);
    return (-1);
  }
  if (rstr) {
    code = bm_search(& bmb, buf, len, & matchfun, (void *)pathname);
  } else {
    pthread_mutex_lock(& print_lock);
    printf((char const   * __restrict  )"%s : 0 : ", pathname);
    print_output(buf, len);
    putchar('\n');
    pthread_mutex_unlock(& print_lock);
  }
  munmap((void *)((char *)buf), len);
  close(fd);
  return (1);
}
}
int foreach_path(char const   *path , struct stat  const  *sp , int f ) 
{ char *tmp ;

  {
  n_files ++;
  n_bytes = (unsigned int )((unsigned long )n_bytes + (unsigned long )sp->st_size);
  switch (f) {
  case 0: 
  tmp = strdup(path);
  pqueue_put(& pqb, (void *)tmp);
  return (0);
  case 1: 
  return (0);
  case 2: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Can\'t read directory.\n",
          argv0, path);
  return (1);
  case 3: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Can\'t stat object.\n",
          argv0, path);
  return (1);
  default: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Internal error (invalid ftw code)\n",
          argv0, path);
  }
  return (1);
}
}
int do_ftw(char *path ) 
{ int code ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  tmp = ftw((char const   *)path, & foreach_path, max_depth);
  code = tmp;
  if (code < 0) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ftw: %s\n",
            argv0, tmp___1);
    return (1);
  }
  return (code);
}
}
void *worker(void *arg ) 
{ char *path ;
  int tmp ;

  {
  while (1) {
    tmp = pqueue_get(& pqb, (void **)(& path));
    if (! (tmp == 1)) {
      break;
    }
    scan_file(path);
    free((void *)path);
  }
  fflush(stdout);
  pthread_mutex_lock(& aworker_lock);
  aworkers --;
  pthread_mutex_unlock(& aworker_lock);
  pthread_cond_signal(& aworker_cv);
  return ((void *)0);
}
}
void usage(FILE *out ) 
{ 

  {
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"Usage: %s [<options>] <search-string> <pathname> [... <pathname-N>]\n",
          argv0);
  fputs((char const   * __restrict  )"\nThis program implements a multithreaded file scanner.\nMore information may be found at:\n\thttp://www.lysator.liu.se/~pen/pfscan\n\nCommand line options:\n",
        (FILE * __restrict  )out);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-h             Display this information.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-V             Print version.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-v             Be verbose.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-d             Print debugging info.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-i             Ignore case when scanning.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-l             Line oriented output.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-n<workers>    Concurrent worker threads limit.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-L<length>     Max length of bytes to print.\n");
  return;
}
}
int main(int argc , char **argv ) 
{ int i ;
  int j ;
  struct rlimit rlb ;
  char *arg ;
  pthread_t tid ;
  pthread_attr_t pab ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  argv0 = *(argv + 0);
  setlocale(0, "");
  getrlimit(7, & rlb);
  rlb.rlim_cur = rlb.rlim_max;
  setrlimit(7, (struct rlimit  const  *)(& rlb));
  signal(13, (void (*)(int  ))1);
  nworkers = 2;
  pthread_mutex_init(& print_lock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_mutex_init(& aworker_lock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_mutex_init(& matches_lock, (pthread_mutexattr_t const   *)((void *)0));
  i = 1;
  while (1) {
    if (i < argc) {
      if (! ((int )*(*(argv + i) + 0) == 45)) {
        break;
      }
    } else {
      break;
    }
    j = 1;
    while (1) {
      if (j > 0) {
        if (! *(*(argv + i) + j)) {
          break;
        }
      } else {
        break;
      }
      switch ((int )*(*(argv + i) + j)) {
      case 45: 
      i ++;
      goto EndOptions;
      case 86: 
      print_version(stdout);
      break;
      case 100: 
      debug ++;
      break;
      case 105: 
      ignore_case = 1;
      break;
      case 118: 
      verbose ++;
      break;
      case 104: 
      usage(stdout);
      exit(0);
      case 108: 
      line_f ++;
      break;
      case 76: 
      if (*(*(argv + i) + 2)) {
        arg = *(argv + i) + 2;
      } else {
        i ++;
        arg = *(argv + i);
      }
      if (! arg) {
        goto _L;
      } else {
        tmp___0 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%u",
                         & maxlen);
        if (tmp___0 != 1) {
          _L: /* CIL Label */ 
          if (arg) {
            tmp = (char const   *)arg;
          } else {
            tmp = "<null>";
          }
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Invalid length specification: %s\n",
                  *(argv + 0), tmp);
          exit(1);
        }
      }
      j = -2;
      break;
      case 110: 
      if (*(*(argv + i) + 2)) {
        arg = *(argv + i) + 2;
      } else {
        i ++;
        arg = *(argv + i);
      }
      if (! arg) {
        goto _L___0;
      } else {
        tmp___2 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%u",
                         & nworkers);
        if (tmp___2 != 1) {
          _L___0: /* CIL Label */ 
          if (arg) {
            tmp___1 = (char const   *)arg;
          } else {
            tmp___1 = "<null>";
          }
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Invalid workers specification: %s\n",
                  *(argv + 0), tmp___1);
          exit(1);
        }
      }
      j = -2;
      break;
      default: 
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: unknown command line switch: -%c\n",
              *(argv + 0), *(*(argv + i) + j));
      exit(1);
      }
      j ++;
    }
    i ++;
  }
  EndOptions: 
  tmp___3 = i;
  i ++;
  tmp___4 = strdup((char const   *)*(argv + tmp___3));
  rstr = (unsigned char *)tmp___4;
  rlen = deslash(rstr);
  tmp___5 = bm_init(& bmb, rstr, rlen, ignore_case);
  if (tmp___5 < 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Failed search string setup: %s\n",
            *(argv + 0), rstr);
    exit(1);
  }
  max_depth = (int )((rlb.rlim_max - (rlim_t )nworkers) - 16UL);
  if (debug) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"max_depth = %d, nworkers = %d\n",
            max_depth, nworkers);
  }
  pqueue_init(& pqb, nworkers + 8);
  pthread_attr_init(& pab);
  pthread_attr_setscope(& pab, 0);
  aworkers = nworkers;
  j = 0;
  while (j < nworkers) {
    tmp___6 = pthread_create((pthread_t * __restrict  )(& tid), (pthread_attr_t const   * __restrict  )(& pab),
                             & worker, (void * __restrict  )((void *)0));
    if (tmp___6 != 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: pthread_create: failed to create worker thread\n",
              *(argv + 0));
      exit(1);
    }
    j ++;
  }
  while (1) {
    if (i < argc) {
      tmp___7 = i;
      i ++;
      tmp___8 = do_ftw(*(argv + tmp___7));
      if (! (tmp___8 == 0)) {
        break;
      }
    } else {
      break;
    }
  }
  pqueue_close(& pqb);
  if (debug) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Waiting for workers to finish...\n");
  }
  pthread_mutex_lock(& aworker_lock);
  while (aworkers > 0) {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& aworker_cv), (pthread_mutex_t * __restrict  )(& aworker_lock));
  }
  pthread_mutex_unlock(& aworker_lock);
  if (debug) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"n_files = %d, n_matches = %d, n_workers = %d, n_Mbytes = %d\n",
            n_files, n_matches, nworkers, (int )(n_bytes / 1000000U));
  }
  return (n_matches);
}
}
#pragma merger(0,"/tmp/cil-fUHu0UpL.i","")
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t * __restrict  __cond ,
                                                           pthread_condattr_t const   * __restrict  __cond_attr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
void pqueue_destroy(PQUEUE *qp ) ;
int pqueue_init(PQUEUE *qp , int qsize ) 
{ void *tmp ;

  {
  tmp = calloc(sizeof(void *), (unsigned int )qsize);
  qp->buf = (void **)tmp;
  if ((unsigned int )qp->buf == (unsigned int )((void *)0)) {
    return ((int )((void *)0));
  }
  qp->qsize = qsize;
  qp->occupied = 0;
  qp->nextin = 0;
  qp->nextout = 0;
  qp->closed = 0;
  pthread_mutex_init(& qp->mtx, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& qp->more), (pthread_condattr_t const   * __restrict  )((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& qp->less), (pthread_condattr_t const   * __restrict  )((void *)0));
  return (0);
}
}
void pqueue_close(PQUEUE *qp ) 
{ 

  {
  pthread_mutex_lock(& qp->mtx);
  qp->closed = 1;
  pthread_mutex_unlock(& qp->mtx);
  pthread_cond_broadcast(& qp->more);
  return;
}
}
int pqueue_put(PQUEUE *qp , void *item ) 
{ int tmp ;

  {
  pthread_mutex_lock(& qp->mtx);
  if (qp->closed) {
    return (0);
  }
  while (qp->occupied >= qp->qsize) {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& qp->less), (pthread_mutex_t * __restrict  )(& qp->mtx));
  }
  tmp = qp->nextin;
  (qp->nextin) ++;
  *(qp->buf + tmp) = item;
  qp->nextin %= qp->qsize;
  (qp->occupied) ++;
  pthread_mutex_unlock(& qp->mtx);
  pthread_cond_signal(& qp->more);
  return (1);
}
}
int pqueue_get(PQUEUE *qp , void **item ) 
{ int got ;
  int tmp ;

  {
  got = 0;
  pthread_mutex_lock(& qp->mtx);
  while (1) {
    if (qp->occupied <= 0) {
      if (! (! qp->closed)) {
        break;
      }
    } else {
      break;
    }
    pthread_cond_wait((pthread_cond_t * __restrict  )(& qp->more), (pthread_mutex_t * __restrict  )(& qp->mtx));
  }
  if (qp->occupied > 0) {
    tmp = qp->nextout;
    (qp->nextout) ++;
    *item = *(qp->buf + tmp);
    qp->nextout %= qp->qsize;
    (qp->occupied) --;
    got = 1;
    pthread_mutex_unlock(& qp->mtx);
    pthread_cond_signal(& qp->less);
  } else {
    pthread_mutex_unlock(& qp->mtx);
  }
  return (got);
}
}
void pqueue_destroy(PQUEUE *qp ) 
{ 

  {
  pthread_mutex_destroy(& qp->mtx);
  pthread_cond_destroy(& qp->more);
  pthread_cond_destroy(& qp->less);
  free((void *)qp->buf);
  return;
}
}
#pragma merger(0,"/tmp/cil-imHGfsqR.i","")
char version[4]  = {      (char )'1',      (char )'.',      (char )'0',      (char )'\000'};
