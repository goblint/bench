/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

typedef unsigned int size_t;
typedef long long __quad_t;
typedef unsigned long long __u_quad_t;
typedef __u_quad_t __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long __off_t;
typedef __quad_t __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef int __ssize_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
typedef struct __pthread_internal_slist __pthread_slist_t;
union __anonunion____missing_field_name_6 {
   int __spins ;
   __pthread_slist_t __list ;
};
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_6 __annonCompField1 ;
};
union __anonunion_pthread_mutex_t_5 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_5 pthread_mutex_t;
union __anonunion_pthread_mutexattr_t_7 {
   char __size[4] ;
   long __align ;
};
typedef union __anonunion_pthread_mutexattr_t_7 pthread_mutexattr_t;
typedef __ssize_t ssize_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct cache_entry;
typedef struct cache_entry cache_entry;
struct cache_entry {
   char *filename ;
   char *data ;
   ssize_t total ;
   int refs ;
   pthread_mutex_t refs_mutex ;
   cache_entry *next ;
   cache_entry *prev ;
};
typedef unsigned int PRUint32;
typedef unsigned int PRUintn;
typedef int PRIntn;
typedef ssize_t PRSize;
typedef int PRBool;
struct PLHashEntry;
typedef struct PLHashEntry PLHashEntry;
struct PLHashTable;
typedef struct PLHashTable PLHashTable;
typedef PRUint32 PLHashNumber;
struct PLHashAllocOps {
   void *(*allocTable)(void *pool , PRSize size ) ;
   void (*freeTable)(void *pool , void *item ) ;
   PLHashEntry *(*allocEntry)(void *pool , void const   *key ) ;
   void (*freeEntry)(void *pool , PLHashEntry *he , PRUintn flag ) ;
};
typedef struct PLHashAllocOps PLHashAllocOps;
struct PLHashEntry {
   PLHashEntry *next ;
   PLHashNumber keyHash ;
   void const   *key ;
   void *value ;
};
struct PLHashTable {
   PLHashEntry **buckets ;
   PRUint32 nentries ;
   PRUint32 shift ;
   PLHashNumber (*keyHash)(void const   *key ) ;
   PRIntn (*keyCompare)(void const   *v1 , void const   *v2 ) ;
   PRIntn (*valueCompare)(void const   *v1 , void const   *v2 ) ;
   PLHashAllocOps const   *allocOps ;
   void *allocPriv ;
};
struct input_state;
typedef struct input_state input_state;
struct input_state {
   char buf[512] ;
   int used ;
   int valid ;
   int socket ;
};
enum http_version;
typedef enum http_version http_version;
enum http_version {
    HTTP_VERSION_1_0 = 0,
    HTTP_VERSION_1_1 = 1
} ;
struct http_request;
typedef struct http_request http_request;
struct http_request {
   char url[80] ;
   http_version version ;
   int socket ;
   int closed ;
};
typedef unsigned int __socklen_t;
typedef unsigned long pthread_t;
union __anonunion_pthread_attr_t_4 {
   char __size[36] ;
   long __align ;
};
typedef union __anonunion_pthread_attr_t_4 pthread_attr_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
enum http_version;
typedef long long cpu_tick_t;
struct thread_args;
typedef struct thread_args thread_args;
struct thread_args {
   int id ;
   int s ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
typedef long __suseconds_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
typedef unsigned char PRUint8;
#pragma merger(0,"/tmp/cil-oSwcmw7z.i","")
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern struct _IO_FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s )  __attribute__((__nonnull__(1),
__malloc__)) ;
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat(3, __fd, __statbuf);
  return (tmp);
}
}
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
void cache_init(void) ;
cache_entry *cache_get(char *filename ) ;
void cache_entry_addref(cache_entry *entry ) ;
void cache_entry_release(cache_entry *entry ) ;
PLHashTable *PL_NewHashTable(PRUint32 n , PLHashNumber (*keyHash)(void const   *key ) ,
                             PRIntn (*keyCompare)(void const   *v1 , void const   *v2 ) ,
                             PRIntn (*valueCompare)(void const   *v1 , void const   *v2 ) ,
                             PLHashAllocOps const   *allocOps , void *allocPriv ) ;
PLHashEntry *PL_HashTableAdd(PLHashTable *ht , void const   *key , void *value ) ;
PRBool PL_HashTableRemove(PLHashTable *ht , void const   *key ) ;
void *PL_HashTableLookup(PLHashTable *ht , void const   *key ) ;
PLHashNumber PL_HashString(void const   *key ) ;
int PL_CompareStrings(void const   *v1 , void const   *v2 ) ;
int PL_CompareValues(void const   *v1 , void const   *v2 ) ;
void assert_failed(char *file , unsigned int line , char const   *func , char *expr ) ;
pthread_mutex_t g_cache_mutex ;
int g_cache_hits ;
int g_cache_misses ;
static PLHashTable *g_hash  =    (PLHashTable *)((void *)0);
static cache_entry *g_cache  =    (cache_entry *)((void *)0);
static cache_entry *g_cache_tail  =    (cache_entry *)((void *)0);
static ssize_t g_cache_max  =    536870912;
static ssize_t g_cache_cur  =    0;
static cache_entry *cache_new(char *filename ) 
{ cache_entry *result ;
  int fd ;
  int tmp ;
  int ret ;
  struct stat fd_stat ;
  char *data ;
  size_t length ;
  int hdrlen ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  result = (cache_entry *)((void *)0);
  tmp = open((char const   *)filename, 0);
  fd = tmp;
  if (fd >= 0) {
    data = (char *)((void *)0);
    length = (size_t )0;
    hdrlen = 0;
    tmp___0 = fstat(fd, & fd_stat);
    if (tmp___0 < 0) {
      perror("fstat");
      exit(1);
    }
    if (! ((fd_stat.st_mode & 61440U) == 32768U)) {
      return ((cache_entry *)((void *)0));
    }
    length = (unsigned int )fd_stat.st_size;
    tmp___1 = malloc(length + 128U);
    data = (char *)tmp___1;
    if (! ((unsigned int )data != (unsigned int )((void *)0))) {
      assert_failed((char *)"cache.c", 69U, "cache_new", (char *)"data != ((void *)0)");
    }
    hdrlen = snprintf((char * __restrict  )data, 128U, (char const   * __restrict  )"HTTP/1.1 200 OK\r\nContent-Type: %s\r\nContent-Length: %d\r\n\r\n",
                      "text/html", length);
    if (hdrlen < 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"header buffer exceeded\n");
      exit(1);
    } else {
      if (hdrlen >= 128) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"header buffer exceeded\n");
        exit(1);
      }
    }
    ret = read(fd, (void *)(data + hdrlen), length);
    if ((unsigned int )ret != length) {
      perror("read");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"read failed - expected %d, but got %d\n",
              length, ret);
      close(fd);
      return ((cache_entry *)((void *)0));
    }
    tmp___2 = malloc(sizeof(*result));
    result = (cache_entry *)tmp___2;
    if (! ((unsigned int )result != (unsigned int )((void *)0))) {
      assert_failed((char *)"cache.c", 90U, "cache_new", (char *)"result != ((void *)0)");
    }
    result->filename = strdup((char const   *)filename);
    if (! ((unsigned int )result->filename != (unsigned int )((void *)0))) {
      assert_failed((char *)"cache.c", 93U, "cache_new", (char *)"result->filename != ((void *)0)");
    }
    result->data = data;
    result->total = (int )(length + (size_t )hdrlen);
    result->refs = 1;
    pthread_mutex_init(& result->refs_mutex, (pthread_mutexattr_t const   *)((void *)0));
    result->next = (cache_entry *)((void *)0);
    result->prev = (cache_entry *)((void *)0);
    close(fd);
  }
  return (result);
}
}
static void cache_add(cache_entry *entry ) 
{ 

  {
  if (! ((unsigned int )entry != (unsigned int )((void *)0))) {
    assert_failed((char *)"cache.c", 114U, "cache_add", (char *)"entry != ((void *)0)");
  }
  if ((unsigned int )g_cache != (unsigned int )((void *)0)) {
    if (! ((unsigned int )entry->next == (unsigned int )((void *)0))) {
      assert_failed((char *)"cache.c", 118U, "cache_add", (char *)"entry->next == ((void *)0)");
    }
    if (! ((unsigned int )entry->prev == (unsigned int )((void *)0))) {
      assert_failed((char *)"cache.c", 119U, "cache_add", (char *)"entry->prev == ((void *)0)");
    }
    if (! ((unsigned int )g_cache->prev == (unsigned int )((void *)0))) {
      assert_failed((char *)"cache.c", 120U, "cache_add", (char *)"g_cache->prev == ((void *)0)");
    }
    entry->next = g_cache;
    entry->prev = (cache_entry *)((void *)0);
    g_cache->prev = entry;
  }
  if ((unsigned int )g_cache_tail == (unsigned int )((void *)0)) {
    g_cache_tail = entry;
  }
  g_cache = entry;
  g_cache_cur += entry->total;
  PL_HashTableAdd(g_hash, (void const   *)entry->filename, (void *)entry);
  return;
}
}
static void cache_remove(cache_entry *entry ) 
{ 

  {
  if (! ((unsigned int )entry != (unsigned int )((void *)0))) {
    assert_failed((char *)"cache.c", 145U, "cache_remove", (char *)"entry != ((void *)0)");
  }
  if ((unsigned int )g_cache == (unsigned int )entry) {
    g_cache_cur -= entry->total;
  } else {
    if ((unsigned int )entry->prev != (unsigned int )((void *)0)) {
      g_cache_cur -= entry->total;
    }
  }
  if ((unsigned int )g_cache == (unsigned int )entry) {
    if (! ((unsigned int )g_cache->prev == (unsigned int )((void *)0))) {
      assert_failed((char *)"cache.c", 155U, "cache_remove", (char *)"g_cache->prev == ((void *)0)");
    }
    g_cache = g_cache->next;
  }
  if ((unsigned int )g_cache_tail == (unsigned int )entry) {
    if (! ((unsigned int )g_cache_tail->next == (unsigned int )((void *)0))) {
      assert_failed((char *)"cache.c", 161U, "cache_remove", (char *)"g_cache_tail->next == ((void *)0)");
    }
    g_cache_tail = g_cache_tail->prev;
  }
  if ((unsigned int )entry->prev != (unsigned int )((void *)0)) {
    (entry->prev)->next = entry->next;
  }
  if ((unsigned int )entry->next != (unsigned int )((void *)0)) {
    (entry->next)->prev = entry->prev;
  }
  entry->prev = (cache_entry *)((void *)0);
  entry->next = (cache_entry *)((void *)0);
  PL_HashTableRemove(g_hash, (void const   *)entry->filename);
  return;
}
}
static void cache_evict(void) 
{ cache_entry *remove___0 ;

  {
  while (g_cache_cur > g_cache_max) {
    remove___0 = g_cache_tail;
    if (! ((unsigned int )remove___0 != (unsigned int )((void *)0))) {
      assert_failed((char *)"cache.c", 189U, "cache_evict", (char *)"remove != ((void *)0)");
    }
    cache_remove(remove___0);
    cache_entry_release(remove___0);
  }
  return;
}
}
static cache_entry *cache_find(char *filename ) 
{ void *tmp ;

  {
  tmp = PL_HashTableLookup(g_hash, (void const   *)filename);
  return ((cache_entry *)tmp);
}
}
static void cache_use(cache_entry *entry ) 
{ 

  {
  if ((unsigned int )g_cache != (unsigned int )entry) {
    cache_remove(entry);
    cache_add(entry);
  }
  return;
}
}
static void cache_finish_get(cache_entry *entry ) 
{ 

  {
  cache_use(entry);
  cache_entry_addref(entry);
  cache_evict();
  return;
}
}
void cache_init(void) 
{ 

  {
  g_hash = PL_NewHashTable(100U, & PL_HashString, & PL_CompareStrings, & PL_CompareValues,
                           (PLHashAllocOps const   *)((void *)0), (void *)0);
  if (! ((unsigned int )g_hash != (unsigned int )((void *)0))) {
    assert_failed((char *)"cache.c", 230U, "cache_init", (char *)"g_hash != ((void *)0)");
  }
  return;
}
}
cache_entry *cache_get(char *filename ) 
{ cache_entry *result ;

  {
  result = (cache_entry *)((void *)0);
  pthread_mutex_lock(& g_cache_mutex);
  result = cache_find(filename);
  if ((unsigned int )result != (unsigned int )((void *)0)) {
    g_cache_hits ++;
    cache_finish_get(result);
  } else {
    g_cache_misses ++;
  }
  pthread_mutex_unlock(& g_cache_mutex);
  if ((unsigned int )result == (unsigned int )((void *)0)) {
    result = cache_new(filename);
    if ((unsigned int )result != (unsigned int )((void *)0)) {
      pthread_mutex_lock(& g_cache_mutex);
      cache_add(result);
      cache_finish_get(result);
      pthread_mutex_unlock(& g_cache_mutex);
    }
  }
  return (result);
}
}
void cache_entry_addref(cache_entry *entry ) 
{ 

  {
  if ((unsigned int )entry != (unsigned int )((void *)0)) {
    pthread_mutex_lock(& entry->refs_mutex);
    (entry->refs) ++;
    pthread_mutex_unlock(& entry->refs_mutex);
  }
  return;
}
}
void cache_entry_release(cache_entry *entry ) 
{ int refs ;

  {
  refs = 0;
  if ((unsigned int )entry != (unsigned int )((void *)0)) {
    pthread_mutex_lock(& entry->refs_mutex);
    (entry->refs) --;
    refs = entry->refs;
    pthread_mutex_unlock(& entry->refs_mutex);
    if (refs == 0) {
      pthread_mutex_destroy(& entry->refs_mutex);
      free((void *)entry->filename);
      free((void *)entry->data);
      free((void *)entry);
      entry = (cache_entry *)((void *)0);
    }
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-OrJKQtWj.i","")
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
void input_init(input_state *state , int socket___0 ) ;
char *input_get_line(input_state *state ) ;
void http_init(http_request *request , int socket___0 ) ;
int http_parse(http_request *request ) ;
void http_init(http_request *request , int socket___0 ) 
{ 

  {
  request->url[0] = (char)0;
  request->version = 0;
  request->closed = 0;
  request->socket = socket___0;
  return;
}
}
int http_parse(http_request *request ) 
{ int result ;
  int done ;
  input_state state ;
  char *line ;
  char *tmp ;
  char *method ;
  char *url ;
  char *protocol ;
  http_version version ;
  int valid ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  result = 0;
  done = 0;
  input_init(& state, request->socket);
  request->url[0] = (char)0;
  request->version = 0;
  while (! done) {
    tmp = input_get_line(& state);
    line = tmp;
    if ((unsigned int )line == (unsigned int )((void *)0)) {
      request->closed = 1;
      result = 0;
      done = 1;
    } else {
      if ((int )*(line + 0) == 0) {
        result = (int )request->url[0] != 0;
        done = 1;
      } else {
        if ((int )request->url[0] == 0) {
          version = 0;
          valid = 0;
          method = line;
          url = strchr((char const   *)line, ' ');
          if ((unsigned int )url != (unsigned int )((void *)0)) {
            tmp___0 = url;
            url ++;
            *tmp___0 = (char)0;
            protocol = strchr((char const   *)url, ' ');
            if ((unsigned int )protocol != (unsigned int )((void *)0)) {
              tmp___1 = protocol;
              protocol ++;
              *tmp___1 = (char)0;
              tmp___4 = strcmp((char const   *)method, "GET");
              if (tmp___4 == 0) {
                tmp___3 = strcmp((char const   *)protocol, "HTTP/1.1");
                if (tmp___3 == 0) {
                  version = 1;
                  valid = 1;
                } else {
                  tmp___2 = strcmp((char const   *)protocol, "HTTP/1.0");
                  if (tmp___2 == 0) {
                    version = 0;
                    valid = 1;
                  }
                }
              }
            }
          }
          if (valid) {
            url --;
            if (! ((unsigned int )line <= (unsigned int )url)) {
              __assert_fail("line <= url", "http.c", 95U, "http_parse");
            }
            *(url + 0) = (char )'.';
            tmp___5 = strlen((char const   *)url);
            if (! (tmp___5 < sizeof(request->url))) {
              __assert_fail("strlen(url) < sizeof(request->url)", "http.c", 101U,
                            "http_parse");
            }
            strcpy((char * __restrict  )(request->url), (char const   * __restrict  )url);
            if (! ((int )request->url[0] == 46)) {
              __assert_fail("request->url[0] == \'.\'", "http.c", 103U, "http_parse");
            }
            request->version = version;
          } else {
            result = 0;
            done = 1;
          }
        }
      }
    }
  }
  return (result);
}
}
#pragma merger(0,"/tmp/cil-Ms76eN5O.i","")
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
void input_init(input_state *state , int socket___0 ) 
{ 

  {
  if (! ((unsigned int )state != (unsigned int )((void *)0))) {
    __assert_fail("state != ((void *)0)", "input.c", 18U, "input_init");
  }
  state->used = 0;
  state->valid = 0;
  state->socket = socket___0;
  return;
}
}
char *input_get_line(input_state *state ) 
{ char *result ;
  int done ;
  char *start ;
  char *newline ;
  char *empty ;
  int n ;
  ssize_t tmp ;

  {
  result = (char *)((void *)0);
  done = 0;
  while (! done) {
    if (! (0 <= state->used)) {
      __assert_fail("0 <= state->used", "input.c", 38U, "input_get_line");
    }
    if (! (state->used <= state->valid)) {
      __assert_fail("state->used <= state->valid", "input.c", 39U, "input_get_line");
    }
    if (! (state->valid <= 511)) {
      __assert_fail("state->valid <= 511", "input.c", 40U, "input_get_line");
    }
    state->buf[state->valid] = (char)0;
    start = & state->buf[state->used];
    newline = strstr((char const   *)start, "\r\n");
    if ((unsigned int )newline != (unsigned int )((void *)0)) {
      *newline = (char)0;
      result = start;
      done = 1;
      state->used = (newline - state->buf) + 2;
      if (state->used == state->valid) {
        state->used = 0;
        state->valid = 0;
      }
    } else {
      if (state->valid < 511) {
        empty = & state->buf[state->valid];
        tmp = read(state->socket, (void *)empty, (unsigned int )(511 - state->valid));
        n = tmp;
        if (n <= 0) {
          result = (char *)((void *)0);
          done = 1;
        } else {
          state->valid += n;
        }
      } else {
        if (state->used > 0) {
          memmove((void *)(& state->buf[0]), (void const   *)(& state->buf[state->used]),
                  (unsigned int )(state->valid - state->used));
          state->valid -= state->used;
          state->used = 0;
        } else {
          result = (char *)((void *)0);
          done = 1;
        }
      }
    }
  }
  return (result);
}
}
#pragma merger(0,"/tmp/cil-yY6bFgIx.i","")
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __newthread ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg )  __attribute__((__nonnull__(1,3))) ;
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
cpu_tick_t ticks_per_microsecond ;
__inline static long long current_usecs(void) 
{ register cpu_tick_t ret ;

  {
  __asm__  volatile   ("rdtsc": "=A" (ret));
  return (ret / ticks_per_microsecond);
}
}
int g_use_timer  =    1;
int g_spawn_on_demand  =    0;
static int g_use_cache  =    0;
static int g_force_thrashing  =    0;
pthread_mutex_t g_cache_mutex  ;
static int g_conn_open  =    0;
static int g_conn_fail  =    0;
static int g_conn_succeed  =    0;
static int g_conn_active  =    0;
int g_cache_hits  =    0;
int g_cache_misses  =    0;
long long g_bytes_sent  =    0LL;
static unsigned int g_timer_interval  =    5U;
int allow_file(char *file ) 
{ char *p ;
  int allow ;
  char *tmp ;
  char *tmp___0 ;

  {
  p = file;
  allow = 1;
  if ((int )*(file + 0) != 47) {
    allow = 0;
  }
  while (1) {
    if (allow) {
      if (! ((int )*p != 0)) {
        break;
      }
    } else {
      break;
    }
    if (97 <= (int )*p) {
      if (! ((int )*p <= 122)) {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (65 <= (int )*p) {
        if (! ((int )*p <= 90)) {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (48 <= (int )*p) {
          if (! ((int )*p <= 57)) {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          tmp = strchr("/._", (int )*p);
          if (! ((unsigned int )tmp != (unsigned int )((void *)0))) {
            allow = 0;
          }
        }
      }
    }
    p ++;
  }
  if (allow) {
    tmp___0 = strstr((char const   *)file, "/.");
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      allow = 0;
    }
  }
  return (allow);
}
}
char *get_request_filename(http_request *request ) 
{ char *result ;
  int tmp ;
  int tmp___0 ;

  {
  result = (char *)((void *)0);
  tmp___0 = http_parse(request);
  if (tmp___0) {
    if (! request->closed) {
      if (! ((int )request->url[0] == 46)) {
        assert_failed((char *)"knot.c", 131U, "get_request_filename", (char *)"request->url[0] == \'.\'");
      }
      tmp = allow_file(request->url + 1);
      if (tmp) {
        result = request->url;
      }
    }
  }
  return (result);
}
}
int get_request_fd(http_request *request ) 
{ char *filename ;
  char *tmp ;
  int fd ;

  {
  tmp = get_request_filename(request);
  filename = tmp;
  fd = -1;
  if ((unsigned int )filename != (unsigned int )((void *)0)) {
    fd = open((char const   *)filename, 0);
  }
  return (fd);
}
}
int process_client_nocache(http_request *request , int client ) 
{ int fd ;
  int tmp ;
  int success ;
  char buf[8192] ;
  char *pos ;
  int n ;
  int ret ;
  int written ;

  {
  tmp = get_request_fd(request);
  fd = tmp;
  success = 1;
  if (fd >= 0) {
    n = 1;
    written = 0;
    while (n > 0) {
      n = read(fd, (void *)(buf), sizeof(buf));
      if (n < 0) {
        perror("read");
        success = 0;
        break;
      }
      pos = buf;
      while (n > 0) {
        ret = write(client, (void const   *)pos, (unsigned int )n);
        if (ret < 0) {
          perror("write");
          success = 0;
          break;
        } else {
          if (ret == 0) {
            n = 0;
            break;
          } else {
            written += ret;
            pos += ret;
            n -= ret;
          }
        }
      }
    }
    if (g_use_timer) {
      g_bytes_sent += (long long )written;
    }
    close(fd);
  }
  return (success);
}
}
cache_entry *get_request_entry(http_request *request ) 
{ char *filename ;
  char *tmp ;
  cache_entry *tmp___0 ;

  {
  tmp = get_request_filename(request);
  filename = tmp;
  if ((unsigned int )filename == (unsigned int )((void *)0)) {
    return ((cache_entry *)((void *)0));
  }
  tmp___0 = cache_get(filename);
  return (tmp___0);
}
}
int process_client_cache(http_request *request , int client ) 
{ int success ;
  cache_entry *entry ;
  ssize_t written ;
  int n ;
  char *p ;
  char *bigstuff ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  success = 0;
  entry = get_request_entry(request);
  if ((unsigned int )entry != (unsigned int )((void *)0)) {
    written = 0;
    n = 0;
    bigstuff = (char *)((void *)0);
    if (g_force_thrashing) {
      tmp = malloc(734003200U);
      bigstuff = (char *)tmp;
      if (! bigstuff) {
        return (0);
      }
      p = (bigstuff + 734003200) - 3;
      while ((unsigned int )p > (unsigned int )bigstuff) {
        *p = (char)10;
        p -= 4096;
      }
      sched_yield();
      free((void *)bigstuff);
      bigstuff = (char *)((void *)0);
    }
    while (1) {
      n = write(client, (void const   *)(entry->data + written), (unsigned int )(entry->total - written));
      if (n > 0) {
        written += n;
        g_bytes_sent += (long long )n;
      }
      if (n > 0) {
        if (! (written < entry->total)) {
          break;
        }
      } else {
        break;
      }
    }
    if (n < 0) {
      tmp___0 = __errno_location();
      if (*tmp___0 != 32) {
        tmp___1 = __errno_location();
        if (*tmp___1 != 104) {
          perror("warning: write");
        }
      }
    }
    if (g_force_thrashing) {
      if (bigstuff) {
        free((void *)bigstuff);
      }
    }
    success = 1;
  }
  cache_entry_release(entry);
  return (success);
}
}
void process_client(int client ) 
{ http_request request ;
  int done ;
  int numrequests ;
  int success ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;

  {
  done = 0;
  numrequests = 0;
  http_init(& request, client);
  while (! done) {
    if (g_use_cache) {
      tmp = process_client_cache(& request, client);
      tmp___1 = tmp;
    } else {
      tmp___0 = process_client_nocache(& request, client);
      tmp___1 = tmp___0;
    }
    success = tmp___1;
    if (success) {
      g_conn_succeed ++;
    } else {
      g_conn_fail ++;
    }
    numrequests ++;
    if (! success) {
      if (! request.closed) {
        tmp___2 = strlen("HTTP/1.1 404 Not Found\r\nConnection: close\r\n");
        len = (int )tmp___2;
        tmp___3 = write(client, (void const   *)"HTTP/1.1 404 Not Found\r\nConnection: close\r\n",
                        (unsigned int )len);
        if (! (tmp___3 != len)) {
          g_bytes_sent += (long long )len;
        }
      }
    }
    if (! success) {
      done = 1;
    } else {
      if ((int )request.version == 0) {
        done = 1;
      }
    }
  }
  if (numrequests > 1) {
    g_conn_fail --;
  }
  return;
}
}
void *thread_process_client(void *arg ) 
{ int c ;

  {
  c = (int )arg;
  process_client(c);
  g_conn_active --;
  close(c);
  return ((void *)0);
}
}
void accept_loop(int id , int s ) ;
static int attr_init_done  =    0;
static pthread_attr_t attr  ;
static pthread_t thread  ;
void accept_loop(int id , int s ) 
{ struct sockaddr_in caddr ;
  int len ;
  int c ;
  int optval ;
  int tmp ;
  int rv ;
  int tmp___0 ;

  {
  while (1) {
    len = (int )sizeof(caddr);
    c = 0;
    c = accept(s, (struct sockaddr * __restrict  )((struct sockaddr *)(& caddr)),
               (socklen_t * __restrict  )(& len));
    if (c < 0) {
      perror("accept");
      continue;
    }
    g_conn_open ++;
    g_conn_active ++;
    optval = 1;
    tmp = setsockopt(c, 6, 1, (void const   *)(& optval), sizeof(optval));
    if (tmp < 0) {
      perror("setsockopt");
      continue;
    }
    if (g_spawn_on_demand) {
      if (! attr_init_done) {
        pthread_attr_init(& attr);
        rv = pthread_attr_setdetachstate(& attr, 1);
        if (! (rv == 0)) {
          assert_failed((char *)"knot.c", 472U, "accept_loop", (char *)"rv == 0");
        }
        attr_init_done = 1;
      }
      tmp___0 = pthread_create((pthread_t * __restrict  )(& thread), (pthread_attr_t const   * __restrict  )(& attr),
                               & thread_process_client, (void * __restrict  )((void *)c));
      if (tmp___0 < 0) {
        g_conn_fail ++;
        g_conn_active --;
        close(c);
      }
    } else {
      process_client(c);
      close(c);
      g_conn_active --;
    }
  }
}
}
void *thread_main_autospawn(void *arg ) 
{ int s ;

  {
  s = (int )arg;
  accept_loop(-1, s);
  return ((void *)0);
}
}
void *thread_main(void *arg ) ;
void *thread_main(void *arg ) 
{ thread_args *targs ;
  int id ;
  int s ;

  {
  targs = (thread_args *)arg;
  id = targs->id;
  s = targs->s;
  free((void *)targs);
  accept_loop(id, s);
  return ((void *)0);
}
}
int main(int argc , char **argv ) 
{ struct sockaddr_in saddr ;
  int s ;
  int nthreads ;
  int i ;
  int val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  pthread_t thread___0 ;
  int tmp___5 ;
  thread_args *targs ;
  pthread_t thread___1 ;
  void *tmp___6 ;
  int tmp___7 ;
  unsigned long long start ;
  unsigned long long now ;
  long long tmp___8 ;
  long long bytes_sent ;
  int conn_open ;
  int conn_succeed ;
  int conn_fail ;
  int conn_active ;
  int cache_hits ;
  int cache_misses ;
  long long tmp___9 ;

  {
  s = 0;
  nthreads = 0;
  i = 0;
  val = 1;
  if (argc != 3) {
    if (argc != 4) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: %s port threads [root]\n",
              *(argv + 0));
      exit(1);
    }
  }
  if (argc == 4) {
    printf((char const   * __restrict  )"setting root directory to [%s]\n", *(argv + 3));
    tmp = chdir((char const   *)*(argv + 3));
    if (tmp < 0) {
      perror("chdir");
      exit(1);
    }
  }
  pthread_mutex_init(& g_cache_mutex, (pthread_mutexattr_t const   *)((void *)0));
  cache_init();
  tmp___0 = strcmp((char const   *)*(argv + 2), "auto");
  if (tmp___0) {
    nthreads = atoi((char const   *)*(argv + 2));
    if (nthreads <= 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"nthreads should be > 0 or \'auto\'\n");
      exit(1);
    }
  } else {
    g_spawn_on_demand = 1;
  }
  s = socket(2, 1, 0);
  if (s < 0) {
    perror("socket");
    exit(1);
  }
  val = 1;
  tmp___1 = setsockopt(s, 1, 2, (void const   *)(& val), sizeof(val));
  if (tmp___1 < 0) {
    perror("setsockopt");
    exit(1);
  }
  saddr.sin_family = (unsigned short)2;
  tmp___2 = atoi((char const   *)*(argv + 1));
  saddr.sin_port = htons((unsigned short )tmp___2);
  saddr.sin_addr.s_addr = 0U;
  tmp___3 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& saddr)), sizeof(saddr));
  if (tmp___3 < 0) {
    perror("bind");
    exit(1);
  }
  tmp___4 = listen(s, 50000);
  if (tmp___4 < 0) {
    perror("listen");
    exit(1);
  }
  if (g_spawn_on_demand) {
    tmp___5 = pthread_create((pthread_t * __restrict  )(& thread___0), (pthread_attr_t const   * __restrict  )((void *)0),
                             & thread_main_autospawn, (void * __restrict  )((void *)s));
    if (tmp___5 < 0) {
      perror("pthread_create");
    }
  } else {
    printf((char const   * __restrict  )"Spawning %d threads....\n", nthreads);
    i = 0;
    while (i < nthreads) {
      targs = (thread_args *)((void *)0);
      tmp___6 = malloc(sizeof(*targs));
      targs = (thread_args *)tmp___6;
      if (! ((unsigned int )targs != (unsigned int )((void *)0))) {
        assert_failed((char *)"knot.c", 623U, "main", (char *)"targs != ((void *)0)");
      }
      targs->id = i;
      targs->s = s;
      tmp___7 = pthread_create((pthread_t * __restrict  )(& thread___1), (pthread_attr_t const   * __restrict  )((void *)0),
                               & thread_main, (void * __restrict  )((void *)targs));
      if (tmp___7 < 0) {
        perror("pthread_create");
      }
      i ++;
    }
    printf((char const   * __restrict  )"done\n");
  }
  if (g_use_timer) {
    tmp___8 = current_usecs();
    start = (unsigned long long )tmp___8;
    sleep(g_timer_interval);
    while (1) {
      tmp___9 = current_usecs();
      now = (unsigned long long )tmp___9;
      bytes_sent = g_bytes_sent;
      g_bytes_sent = 0LL;
      conn_open = g_conn_open;
      g_conn_open = 0;
      conn_succeed = g_conn_succeed;
      g_conn_succeed = 0;
      conn_fail = g_conn_fail;
      g_conn_fail = 0;
      conn_active = g_conn_active;
      cache_hits = g_cache_hits;
      g_cache_hits = 0;
      cache_misses = g_cache_misses;
      g_cache_misses = 0;
      printf((char const   * __restrict  )"rate: %.3g Mbits/sec   %.0f open/sec   %.0f succ/sec   %.0f fail/sec   active: %d   misses: %d   hitrate: %.1f%%   ",
             (((double )bytes_sent * (double )8) * (double )1000000) / ((double )(now - start) * (double )1048576),
             ((double )conn_open * (double )1000000) / (double )(now - start), ((double )conn_succeed * (double )1000000) / (double )(now - start),
             ((double )conn_fail * (double )1000000) / (double )(now - start), conn_active,
             cache_misses, ((double )100 * (double )cache_hits) / (double )(cache_hits + cache_misses));
      printf((char const   * __restrict  )"\n");
      start = now;
      sleep(g_timer_interval);
    }
  }
  pthread_exit((void *)0);
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#pragma merger(0,"/tmp/cil-Ps5u9k6i.i","")
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
cpu_tick_t real_start_ticks ;
cpu_tick_t virtual_start_ticks ;
void init_cycle_clock(void)  __attribute__((__constructor__)) ;
void ( /* format attribute */  real_debug)(char const   *func , char const   *fmt 
                                           , ...) ;
void ( /* format attribute */  real_toutput)(int tid , char const   *func , char const   *fmt 
                                             , ...) ;
void ( /* format attribute */  output)(char *fmt  , ...) ;
void ( /* format attribute */  warning)(char *fmt  , ...) ;
void ( /* format attribute */  fatal)(char *fmt  , ...) ;
cpu_tick_t ticks_diff ;
cpu_tick_t ticks_rdiff ;
void init_debug(void)  __attribute__((__constructor__)) ;
int conf_no_debug ;
cpu_tick_t ticks_diff  =    (cpu_tick_t )0;
cpu_tick_t ticks_rdiff  =    (cpu_tick_t )0;
static cpu_tick_t vnow_prev  =    (cpu_tick_t )0;
static cpu_tick_t vrnow_prev  =    (cpu_tick_t )0;
void init_debug(void)  __attribute__((__constructor__)) ;
void init_debug(void) 
{ 

  {
  init_cycle_clock();
  vnow_prev = virtual_start_ticks;
  vrnow_prev = real_start_ticks;
  return;
}
}
__inline static void output_aux(int tid , char const   *func , char const   *fmt ,
                                va_list ap ) 
{ char str[200] ;
  int len ;
  int ret ;
  cpu_tick_t rnow ;
  cpu_tick_t vrnow ;
  cpu_tick_t rafter ;

  {
  len = 0;
  __asm__  volatile   ("rdtsc": "=A" (rnow));
  vrnow = rnow - ticks_rdiff;
  if (tid != -12312) {
    ret = snprintf((char * __restrict  )(str + len), (sizeof(str) - 1U) - (unsigned int )len,
                   (char const   * __restrict  )"%5d %12lld us (%+8lld cyc): ", tid,
                   (vrnow - real_start_ticks) / ticks_per_microsecond, vrnow - vrnow_prev);
    if (! (ret > 0)) {
      assert_failed((char *)"../../util/debug.c", 67U, "output_aux", (char *)"ret > 0");
    }
    len += ret;
  }
  if (func) {
    ret = snprintf((char * __restrict  )(str + len), (sizeof(str) - 1U) - (unsigned int )len,
                   (char const   * __restrict  )"%s() - ", func);
    if (! (ret > 0)) {
      assert_failed((char *)"../../util/debug.c", 74U, "output_aux", (char *)"ret > 0");
    }
    len += ret;
  }
  ret = vsnprintf((char * __restrict  )(str + len), (sizeof(str) - 1U) - (unsigned int )len,
                  (char const   * __restrict  )fmt, ap);
  if (! (ret > 0)) {
    assert_failed((char *)"../../util/debug.c", 80U, "output_aux", (char *)"ret > 0");
  }
  len += ret;
  syscall(4L, 2, str, len);
  vrnow_prev = vrnow;
  __asm__  volatile   ("rdtsc": "=A" (rafter));
  ticks_rdiff += rafter - rnow;
  return;
}
}
void ( /* format attribute */  real_toutput)(int tid , char const   *func , char const   *fmt 
                                             , ...) 
{ va_list ap ;

  {
  if (conf_no_debug) {
    return;
  }
  __builtin_va_start(ap, fmt);
  output_aux(tid, func, fmt, ap);
  __builtin_va_end(ap);
  return;
}
}
void ( /* format attribute */  real_debug)(char const   *func , char const   *fmt 
                                           , ...) 
{ va_list ap ;

  {
  if (conf_no_debug) {
    return;
  }
  __builtin_va_start(ap, fmt);
  output_aux(-12312, func, fmt, ap);
  __builtin_va_end(ap);
  return;
}
}
void ( /* format attribute */  output)(char *fmt  , ...) 
{ va_list ap ;

  {
  __builtin_va_start(ap, fmt);
  output_aux(-12312, (char const   *)((void *)0), (char const   *)fmt, ap);
  __builtin_va_end(ap);
  return;
}
}
void ( /* format attribute */  warning)(char *fmt  , ...) 
{ va_list ap ;

  {
  __builtin_va_start(ap, fmt);
  output_aux(-12312, (char const   *)((void *)0), (char const   *)fmt, ap);
  __builtin_va_end(ap);
  return;
}
}
void ( /* format attribute */  fatal)(char *fmt  , ...) 
{ va_list ap ;

  {
  __builtin_va_start(ap, fmt);
  output_aux(-12312, (char const   *)((void *)0), (char const   *)fmt, ap);
  __builtin_va_end(ap);
  abort();
}
}
extern char const   *__progname ;
void assert_failed(char *file , unsigned int line , char const   *func , char *expr ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  if (__progname) {
    tmp = ": ";
  } else {
    tmp = "";
  }
  if (__progname) {
    tmp___0 = __progname;
  } else {
    tmp___0 = "";
  }
  fatal((char *)"%s%s%s:%u: %s:  Assertion `%s\' failed.\n", tmp___0, tmp, file, line,
        func, expr);
  abort();
}
}
#pragma merger(0,"/tmp/cil-jfY5An30.i","")
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
cpu_tick_t ticks_per_second ;
cpu_tick_t ticks_per_millisecond ;
cpu_tick_t ticks_per_nanosecond ;
cpu_tick_t ticks_per_nanosecond  =    (cpu_tick_t )((double )6 * 10e2);
cpu_tick_t ticks_per_microsecond  =    (cpu_tick_t )((double )6 * 10e5);
cpu_tick_t ticks_per_millisecond  =    (cpu_tick_t )((double )6 * 10e8);
cpu_tick_t ticks_per_second  =    (cpu_tick_t )((double )6 * 10e11);
cpu_tick_t real_start_ticks  =    (cpu_tick_t )0;
cpu_tick_t virtual_start_ticks  =    (cpu_tick_t )0;
static long long timing_loop(void) 
{ struct timeval start_tv ;
  struct timeval end_tv ;
  long usec ;
  cpu_tick_t start_ticks ;
  cpu_tick_t end_ticks ;

  {
  while (1) {
    gettimeofday((struct timeval * __restrict  )(& start_tv), (struct timezone * __restrict  )((void *)0));
    usec = start_tv.tv_usec;
    while (1) {
      gettimeofday((struct timeval * __restrict  )(& start_tv), (struct timezone * __restrict  )((void *)0));
      __asm__  volatile   ("rdtsc": "=A" (start_ticks));
      if (! (start_tv.tv_usec == usec)) {
        break;
      }
    }
    while (1) {
      gettimeofday((struct timeval * __restrict  )(& end_tv), (struct timezone * __restrict  )((void *)0));
      __asm__  volatile   ("rdtsc": "=A" (end_ticks));
      if (! (1e6 * (double )((long long )end_tv.tv_sec) + (double )end_tv.tv_usec < (1e6 * (double )((long long )start_tv.tv_sec) + (double )start_tv.tv_usec) + (double )1000)) {
        break;
      }
    }
    if (1e6 * (double )((long long )end_tv.tv_sec) + (double )end_tv.tv_usec == (1e6 * (double )((long long )start_tv.tv_sec) + (double )start_tv.tv_usec) + (double )1000) {
      break;
    }
  }
  return (end_ticks - start_ticks);
}
}
static int init_done  =    0;
void init_cycle_clock(void)  __attribute__((__constructor__)) ;
void init_cycle_clock(void) 
{ int i ;
  long long val ;
  long long tmp ;

  {
  val = 0LL;
  if (init_done) {
    return;
  }
  init_done = 1;
  i = 0;
  while (i < 10) {
    tmp = timing_loop();
    val += tmp;
    i ++;
  }
  val /= 10LL;
  ticks_per_second = (long long )((double )val * 1e3);
  ticks_per_millisecond = (long long )((double )val * 1e0);
  ticks_per_microsecond = (long long )((double )val / 1e3);
  ticks_per_nanosecond = (long long )((double )val / 1e6);
  __asm__  volatile   ("rdtsc": "=A" (real_start_ticks));
  __asm__  volatile   ("rdtsc": "=A" (virtual_start_ticks));
  return;
}
}
#pragma merger(0,"/tmp/cil-rxsNrgMK.i","")
void PL_HashTableDestroy(PLHashTable *ht ) ;
void *PL_HashTableLookupConst(PLHashTable *ht , void const   *key ) ;
int PL_HashTableEnumerateEntries(PLHashTable *ht , PRIntn (*f)(PLHashEntry *he , PRIntn i ,
                                                               void *arg ) , void *arg ) ;
PLHashEntry **PL_HashTableRawLookup(PLHashTable *ht , PLHashNumber keyHash , void const   *key ) ;
PLHashEntry **PL_HashTableRawLookupConst(PLHashTable *ht , PLHashNumber keyHash ,
                                         void const   *key ) ;
PLHashEntry *PL_HashTableRawAdd(PLHashTable *ht , PLHashEntry **hep , PLHashNumber keyHash ,
                                void const   *key , void *value ) ;
void PL_HashTableRawRemove(PLHashTable *ht , PLHashEntry **hep , PLHashEntry *he ) ;
int PL_HashTableDump(PLHashTable *ht , PRIntn (*dump)(PLHashEntry *he , PRIntn i ,
                                                      void *arg ) , FILE *fp ) ;
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
PRIntn PR_CeilingLog2(PRUint32 n ) 
{ PRIntn log2 ;

  {
  log2 = 0;
  if (n & (n - 1U)) {
    log2 ++;
  }
  if (n >> 16) {
    log2 += 16;
    n >>= 16;
  }
  if (n >> 8) {
    log2 += 8;
    n >>= 8;
  }
  if (n >> 4) {
    log2 += 4;
    n >>= 4;
  }
  if (n >> 2) {
    log2 += 2;
    n >>= 2;
  }
  if (n >> 1) {
    log2 ++;
  }
  return (log2);
}
}
static void *DefaultAllocTable(void *pool , PRSize size ) 
{ void *tmp ;

  {
  tmp = malloc((unsigned int )size);
  return (tmp);
}
}
static void DefaultFreeTable(void *pool , void *item ) 
{ 

  {
  free(item);
  return;
}
}
static PLHashEntry *DefaultAllocEntry(void *pool , void const   *key ) 
{ void *tmp ;

  {
  tmp = malloc(sizeof(PLHashEntry ));
  return ((PLHashEntry *)tmp);
}
}
static void DefaultFreeEntry(void *pool , PLHashEntry *he , PRUintn flag ) 
{ 

  {
  if (flag == 1U) {
    free((void *)he);
  }
  return;
}
}
static PLHashAllocOps defaultHashAllocOps  =    {& DefaultAllocTable, & DefaultFreeTable, & DefaultAllocEntry, & DefaultFreeEntry};
PLHashTable *PL_NewHashTable(PRUint32 n ,
                             PLHashNumber (*keyHash)(void const   *key ) , PRIntn (*keyCompare)(void const   *v1 ,
                                                                                                void const   *v2 ) ,
                             PRIntn (*valueCompare)(void const   *v1 , void const   *v2 ) ,
                             PLHashAllocOps const   *allocOps , void *allocPriv ) 
{ PLHashTable *ht ;
  PRSize nb ;
  PRIntn tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  if (n <= (PRUint32 )(1 << 4)) {
    n = 4U;
  } else {
    tmp = PR_CeilingLog2(n);
    n = (unsigned int )tmp;
    if ((int )n < 0) {
      return ((PLHashTable *)0);
    }
  }
  if (! allocOps) {
    allocOps = (PLHashAllocOps const   *)(& defaultHashAllocOps);
  }
  tmp___0 = (*(allocOps->allocTable))(allocPriv, (int )sizeof(*ht));
  ht = (PLHashTable *)tmp___0;
  if (! ht) {
    return ((PLHashTable *)0);
  }
  memset((void *)ht, 0, sizeof(*ht));
  ht->shift = 32U - n;
  n = (unsigned int )(1 << n);
  nb = (int )(n * sizeof(PLHashEntry *));
  tmp___1 = (*(allocOps->allocTable))(allocPriv, nb);
  ht->buckets = (PLHashEntry **)tmp___1;
  if (! ht->buckets) {
    (*(allocOps->freeTable))(allocPriv, (void *)ht);
    return ((PLHashTable *)0);
  }
  memset((void *)ht->buckets, 0, (unsigned int )nb);
  ht->keyHash = keyHash;
  ht->keyCompare = keyCompare;
  ht->valueCompare = valueCompare;
  ht->allocOps = allocOps;
  ht->allocPriv = allocPriv;
  return (ht);
}
}
void PL_HashTableDestroy(PLHashTable *ht ) 
{ PRUint32 i ;
  PRUint32 n ;
  PLHashEntry *he ;
  PLHashEntry *next ;
  PLHashAllocOps const   *allocOps ;
  void *allocPriv ;

  {
  allocOps = ht->allocOps;
  allocPriv = ht->allocPriv;
  n = (unsigned int )(1 << (32U - ht->shift));
  i = 0U;
  while (i < n) {
    he = *(ht->buckets + i);
    while (he) {
      next = he->next;
      (*(allocOps->freeEntry))(allocPriv, he, 1U);
      he = next;
    }
    i ++;
  }
  (*(allocOps->freeTable))(allocPriv, (void *)ht->buckets);
  (*(allocOps->freeTable))(allocPriv, (void *)ht);
  return;
}
}
PLHashEntry **PL_HashTableRawLookup(PLHashTable *ht , PLHashNumber keyHash , void const   *key ) 
{ PLHashEntry *he ;
  PLHashEntry **hep ;
  PLHashEntry **hep0 ;
  PLHashNumber h ;
  PRIntn tmp ;

  {
  h = keyHash * 2654435769U;
  h >>= ht->shift;
  hep0 = ht->buckets + h;
  hep = hep0;
  while (1) {
    he = *hep;
    if (! ((unsigned int )he != (unsigned int )((PLHashEntry *)0))) {
      break;
    }
    if (he->keyHash == keyHash) {
      tmp = (*(ht->keyCompare))(key, he->key);
      if (tmp) {
        if ((unsigned int )hep != (unsigned int )hep0) {
          *hep = he->next;
          he->next = *hep0;
          *hep0 = he;
        }
        return (hep0);
      }
    }
    hep = & he->next;
  }
  return (hep);
}
}
PLHashEntry **PL_HashTableRawLookupConst(PLHashTable *ht , PLHashNumber keyHash ,
                                         void const   *key ) 
{ PLHashEntry *he ;
  PLHashEntry **hep ;
  PLHashNumber h ;
  PRIntn tmp ;

  {
  h = keyHash * 2654435769U;
  h >>= ht->shift;
  hep = ht->buckets + h;
  while (1) {
    he = *hep;
    if (! ((unsigned int )he != (unsigned int )((PLHashEntry *)0))) {
      break;
    }
    if (he->keyHash == keyHash) {
      tmp = (*(ht->keyCompare))(key, he->key);
      if (tmp) {
        break;
      }
    }
    hep = & he->next;
  }
  return (hep);
}
}
PLHashEntry *PL_HashTableRawAdd(PLHashTable *ht , PLHashEntry **hep , PLHashNumber keyHash ,
                                void const   *key , void *value ) 
{ PRUint32 i ;
  PRUint32 n ;
  PLHashEntry *he ;
  PLHashEntry *next ;
  PLHashEntry **oldbuckets ;
  PRSize nb ;
  void *tmp ;

  {
  n = (unsigned int )(1 << (32U - ht->shift));
  if (ht->nentries >= n - (n >> 3)) {
    oldbuckets = ht->buckets;
    nb = (int )((2U * n) * sizeof(PLHashEntry *));
    tmp = (*((ht->allocOps)->allocTable))(ht->allocPriv, nb);
    ht->buckets = (PLHashEntry **)tmp;
    if (! ht->buckets) {
      ht->buckets = oldbuckets;
      return ((PLHashEntry *)0);
    }
    memset((void *)ht->buckets, 0, (unsigned int )nb);
    (ht->shift) --;
    i = 0U;
    while (i < n) {
      he = *(oldbuckets + i);
      while (he) {
        next = he->next;
        hep = PL_HashTableRawLookup(ht, he->keyHash, he->key);
        while (1) {
          break;
        }
        he->next = (PLHashEntry *)0;
        *hep = he;
        he = next;
      }
      i ++;
    }
    (*((ht->allocOps)->freeTable))(ht->allocPriv, (void *)oldbuckets);
    hep = PL_HashTableRawLookup(ht, keyHash, key);
  }
  he = (*((ht->allocOps)->allocEntry))(ht->allocPriv, key);
  if (! he) {
    return ((PLHashEntry *)0);
  }
  he->keyHash = keyHash;
  he->key = key;
  he->value = value;
  he->next = *hep;
  *hep = he;
  (ht->nentries) ++;
  return (he);
}
}
PLHashEntry *PL_HashTableAdd(PLHashTable *ht , void const   *key , void *value ) 
{ PLHashNumber keyHash ;
  PLHashEntry *he ;
  PLHashEntry **hep ;
  PRIntn tmp ;
  PLHashEntry *tmp___0 ;

  {
  keyHash = (*(ht->keyHash))(key);
  hep = PL_HashTableRawLookup(ht, keyHash, key);
  he = *hep;
  if ((unsigned int )he != (unsigned int )((PLHashEntry *)0)) {
    tmp = (*(ht->valueCompare))((void const   *)he->value, (void const   *)value);
    if (tmp) {
      return (he);
    }
    if (he->value) {
      (*((ht->allocOps)->freeEntry))(ht->allocPriv, he, 0U);
    }
    he->value = value;
    return (he);
  }
  tmp___0 = PL_HashTableRawAdd(ht, hep, keyHash, key, value);
  return (tmp___0);
}
}
void PL_HashTableRawRemove(PLHashTable *ht , PLHashEntry **hep , PLHashEntry *he ) 
{ PRUint32 i ;
  PRUint32 n ;
  PLHashEntry *next ;
  PLHashEntry **oldbuckets ;
  PRSize nb ;
  void *tmp ;
  PRUint32 tmp___0 ;

  {
  *hep = he->next;
  (*((ht->allocOps)->freeEntry))(ht->allocPriv, he, 1U);
  n = (unsigned int )(1 << (32U - ht->shift));
  (ht->nentries) --;
  if (n > (PRUint32 )(1 << 4)) {
    tmp___0 = n >> 2;
  } else {
    tmp___0 = 0U;
  }
  if (ht->nentries < tmp___0) {
    oldbuckets = ht->buckets;
    nb = (int )((n * sizeof(PLHashEntry *)) / 2U);
    tmp = (*((ht->allocOps)->allocTable))(ht->allocPriv, nb);
    ht->buckets = (PLHashEntry **)tmp;
    if (! ht->buckets) {
      ht->buckets = oldbuckets;
      return;
    }
    memset((void *)ht->buckets, 0, (unsigned int )nb);
    (ht->shift) ++;
    i = 0U;
    while (i < n) {
      he = *(oldbuckets + i);
      while (he) {
        next = he->next;
        hep = PL_HashTableRawLookup(ht, he->keyHash, he->key);
        while (1) {
          break;
        }
        he->next = (PLHashEntry *)0;
        *hep = he;
        he = next;
      }
      i ++;
    }
    (*((ht->allocOps)->freeTable))(ht->allocPriv, (void *)oldbuckets);
  }
  return;
}
}
PRBool PL_HashTableRemove(PLHashTable *ht , void const   *key ) 
{ PLHashNumber keyHash ;
  PLHashEntry *he ;
  PLHashEntry **hep ;

  {
  keyHash = (*(ht->keyHash))(key);
  hep = PL_HashTableRawLookup(ht, keyHash, key);
  he = *hep;
  if ((unsigned int )he == (unsigned int )((PLHashEntry *)0)) {
    return (0);
  }
  PL_HashTableRawRemove(ht, hep, he);
  return (1);
}
}
void *PL_HashTableLookup(PLHashTable *ht , void const   *key ) 
{ PLHashNumber keyHash ;
  PLHashEntry *he ;
  PLHashEntry **hep ;

  {
  keyHash = (*(ht->keyHash))(key);
  hep = PL_HashTableRawLookup(ht, keyHash, key);
  he = *hep;
  if ((unsigned int )he != (unsigned int )((PLHashEntry *)0)) {
    return (he->value);
  }
  return ((void *)0);
}
}
void *PL_HashTableLookupConst(PLHashTable *ht , void const   *key ) 
{ PLHashNumber keyHash ;
  PLHashEntry *he ;
  PLHashEntry **hep ;

  {
  keyHash = (*(ht->keyHash))(key);
  hep = PL_HashTableRawLookupConst(ht, keyHash, key);
  he = *hep;
  if ((unsigned int )he != (unsigned int )((PLHashEntry *)0)) {
    return (he->value);
  }
  return ((void *)0);
}
}
int PL_HashTableEnumerateEntries(PLHashTable *ht , PRIntn (*f)(PLHashEntry *he , PRIntn i ,
                                                               void *arg ) , void *arg ) 
{ PLHashEntry *he ;
  PLHashEntry **hep ;
  PRUint32 i ;
  PRUint32 nbuckets ;
  int rv ;
  int n ;
  PLHashEntry *todo ;

  {
  n = 0;
  todo = (PLHashEntry *)0;
  nbuckets = (unsigned int )(1 << (32U - ht->shift));
  i = 0U;
  while (i < nbuckets) {
    hep = ht->buckets + i;
    while (1) {
      he = *hep;
      if (! ((unsigned int )he != (unsigned int )((PLHashEntry *)0))) {
        break;
      }
      rv = (*f)(he, n, arg);
      n ++;
      if (rv & 6) {
        *hep = he->next;
        if (rv & 2) {
          he->next = todo;
          todo = he;
        }
      } else {
        hep = & he->next;
      }
      if (rv & 1) {
        goto out;
      }
    }
    i ++;
  }
  out: 
  hep = & todo;
  while (1) {
    he = *hep;
    if (! ((unsigned int )he != (unsigned int )((PLHashEntry *)0))) {
      break;
    }
    PL_HashTableRawRemove(ht, hep, he);
  }
  return (n);
}
}
int PL_HashTableDump(PLHashTable *ht , PRIntn (*dump)(PLHashEntry *he , PRIntn i ,
                                                      void *arg ) , FILE *fp ) 
{ int count ;

  {
  count = PL_HashTableEnumerateEntries(ht, dump, (void *)fp);
  return (count);
}
}
PLHashNumber PL_HashString(void const   *key ) 
{ PLHashNumber h ;
  PRUint8 const   *s ;

  {
  h = 0U;
  s = (PRUint8 const   *)key;
  while (*s) {
    h = ((h >> 28) ^ (h << 4)) ^ (unsigned int )*s;
    s ++;
  }
  return (h);
}
}
int PL_CompareStrings(void const   *v1 , void const   *v2 ) 
{ int tmp ;

  {
  tmp = strcmp((char const   *)v1, (char const   *)v2);
  return (tmp == 0);
}
}
int PL_CompareValues(void const   *v1 , void const   *v2 ) 
{ 

  {
  return ((unsigned int )v1 == (unsigned int )v2);
}
}
#pragma merger(0,"/tmp/cil-14RurMIC.i","")
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                 char ** __restrict  __endptr , int __base )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
int conf_no_init_messages ;
int conf_dump_blocking_graph ;
int conf_dump_timing_info ;
int conf_show_thread_stacks ;
int conf_show_thread_details ;
int conf_no_stacktrace ;
int conf_no_statcollect ;
long conf_new_stack_size ;
int conf_new_stack_kb_log2 ;
void read_config(void)  __attribute__((__constructor__)) ;
int conf_no_init_messages  =    0;
int conf_dump_blocking_graph  =    0;
int conf_dump_timing_info  =    0;
int conf_show_thread_stacks  =    0;
int conf_show_thread_details  =    0;
int conf_no_debug  =    0;
int conf_no_stacktrace  =    0;
int conf_no_statcollect  =    0;
long conf_new_stack_size  =    131072L;
int conf_new_stack_kb_log2  =    7;
__inline static int bool_value(char *str ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned int )str == (unsigned int )((void *)0)) {
    return (0);
  }
  tmp = atoi((char const   *)str);
  if (tmp) {
    return (1);
  }
  tmp___0 = strcasecmp((char const   *)str, "true");
  if (! tmp___0) {
    return (1);
  }
  tmp___1 = strcasecmp((char const   *)str, "yes");
  if (! tmp___1) {
    return (1);
  }
  tmp___2 = strcasecmp((char const   *)str, "y");
  if (! tmp___2) {
    return (1);
  }
  return (0);
}
}
static int read_config_done  =    0;
void read_config(void)  __attribute__((__constructor__)) ;
void read_config(void) 
{ char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char *str ;
  char *p ;
  int mult ;
  long val ;
  unsigned short const   **tmp___15 ;

  {
  if (read_config_done) {
    return;
  }
  read_config_done = 1;
  tmp = getenv("CAPRICCIO_NO_INIT_MESSAGES");
  conf_no_init_messages = bool_value(tmp);
  if (! conf_no_init_messages) {
    if (conf_no_init_messages) {
      tmp___0 = "yes";
    } else {
      tmp___0 = "no";
    }
    output((char *)"%s=%s\n", "CAPRICCIO_NO_INIT_MESSAGES", tmp___0);
  }
  tmp___1 = getenv("CAPRICCIO_NO_DEBUG");
  conf_no_debug = bool_value(tmp___1);
  if (! conf_no_init_messages) {
    if (conf_no_debug) {
      tmp___2 = "yes";
    } else {
      tmp___2 = "no";
    }
    output((char *)"%s=%s\n", "CAPRICCIO_NO_DEBUG", tmp___2);
  }
  tmp___3 = getenv("CAPRICCIO_NO_STACKTRACE");
  conf_no_stacktrace = bool_value(tmp___3);
  if (! conf_no_init_messages) {
    if (conf_no_stacktrace) {
      tmp___4 = "yes";
    } else {
      tmp___4 = "no";
    }
    output((char *)"%s=%s\n", "CAPRICCIO_NO_STACKTRACE", tmp___4);
  }
  tmp___5 = getenv("CAPRICCIO_NO_STATCOLLECT");
  conf_no_statcollect = bool_value(tmp___5);
  if (! conf_no_init_messages) {
    if (conf_no_statcollect) {
      tmp___6 = "yes";
    } else {
      tmp___6 = "no";
    }
    output((char *)"%s=%s\n", "CAPRICCIO_NO_STATCOLLECT", tmp___6);
  }
  tmp___7 = getenv("CAPRICCIO_DUMP_BLOCKING_GRAPH");
  conf_dump_blocking_graph = bool_value(tmp___7);
  if (! conf_no_init_messages) {
    if (conf_dump_blocking_graph) {
      tmp___8 = "yes";
    } else {
      tmp___8 = "no";
    }
    output((char *)"%s=%s\n", "CAPRICCIO_DUMP_BLOCKING_GRAPH", tmp___8);
  }
  tmp___9 = getenv("CAPRICCIO_DUMP_TIMING_INFO");
  conf_dump_timing_info = bool_value(tmp___9);
  if (! conf_no_init_messages) {
    if (conf_dump_timing_info) {
      tmp___10 = "yes";
    } else {
      tmp___10 = "no";
    }
    output((char *)"%s=%s\n", "CAPRICCIO_DUMP_TIMING_INFO", tmp___10);
  }
  tmp___11 = getenv("CAPRICCIO_SHOW_THREAD_DETAILS");
  conf_show_thread_details = bool_value(tmp___11);
  if (! conf_no_init_messages) {
    if (conf_show_thread_details) {
      tmp___12 = "yes";
    } else {
      tmp___12 = "no";
    }
    output((char *)"%s=%s\n", "CAPRICCIO_SHOW_THREAD_DETAILS", tmp___12);
  }
  tmp___13 = getenv("CAPRICCIO_SHOW_THREAD_STACKS");
  conf_show_thread_stacks = bool_value(tmp___13);
  if (! conf_no_init_messages) {
    if (conf_show_thread_stacks) {
      tmp___14 = "yes";
    } else {
      tmp___14 = "no";
    }
    output((char *)"%s=%s\n", "CAPRICCIO_SHOW_THREAD_STACKS", tmp___14);
  }
  str = getenv("CAPRICCIO_DEFAULT_STACK_SIZE");
  if ((unsigned int )str != (unsigned int )((void *)0)) {
    mult = 0;
    val = strtol((char const   * __restrict  )str, (char ** __restrict  )(& p), 0);
    if ((unsigned int )p == (unsigned int )str) {
      fatal((char *)"Bad number format for CAPRICCIO_DEFAULT_STACK_SIZE: \'%s\'\n",
            str);
    }
    while (1) {
      tmp___15 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___15 + (int )*p) & 8192)) {
        break;
      }
      p ++;
    }
    if ((int )*p == 0) {
      mult = 1024;
    } else {
      if ((int )*p == 98) {
        mult = 1;
      } else {
        if ((int )*p == 66) {
          mult = 1;
        } else {
          if ((int )*p == 107) {
            mult = 1024;
          } else {
            if ((int )*p == 75) {
              mult = 1024;
            } else {
              if ((int )*p == 109) {
                mult = 1048576;
              } else {
                if ((int )*p == 77) {
                  mult = 1048576;
                } else {
                  fatal((char *)"Bad units for CAPRICCIO_DEFAULT_STACK_SIZE: \'%s\'\n",
                        str);
                }
              }
            }
          }
        }
      }
    }
    conf_new_stack_size = 1024L;
    conf_new_stack_kb_log2 = 0;
    while (conf_new_stack_size < (long )mult * val) {
      conf_new_stack_kb_log2 ++;
      conf_new_stack_size <<= 1;
    }
  }
  if (! conf_no_init_messages) {
    if (conf_new_stack_size > 1048576L) {
      if (! (conf_new_stack_size & 1048575L)) {
        output((char *)"CAPRICCIO_DEFAULT_STACKSIZE=%ldM\n", (conf_new_stack_size / 1024L) / 1024L);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (conf_new_stack_size > 1024L) {
        if (! (conf_new_stack_size & 1023L)) {
          output((char *)"CAPRICCIO_DEFAULT_STACKSIZE=%ldK\n", conf_new_stack_size / 1024L);
        } else {
          output((char *)"CAPRICCIO_DEFAULT_STACKSIZE=%ldb\n", conf_new_stack_size);
        }
      } else {
        output((char *)"CAPRICCIO_DEFAULT_STACKSIZE=%ldb\n", conf_new_stack_size);
      }
    }
  }
  return;
}
}
