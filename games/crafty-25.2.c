// wget https://craftychess.com/downloads/source/crafty-25.2.zip
// mkdir crafty; cd crafty
// bear -- make unix-gcc

/* Generated by Goblint-CIL v. 2.0.5 */
/* print_CIL_Input is true */

#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds64_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 169 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 185 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 192 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 199 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 204 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 207 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 210 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 215 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 214 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
typedef unsigned long size_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 38 "/usr/include/sched.h"
typedef __pid_t pid_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_cpu_set_t_826868708 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_cpu_set_t_826868708 cpu_set_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/timex.h"
struct timex {
   unsigned int modes ;
   __syscall_slong_t offset ;
   __syscall_slong_t freq ;
   __syscall_slong_t maxerror ;
   __syscall_slong_t esterror ;
   int status ;
   __syscall_slong_t constant ;
   __syscall_slong_t precision ;
   __syscall_slong_t tolerance ;
   struct timeval time ;
   __syscall_slong_t tick ;
   __syscall_slong_t ppsfreq ;
   __syscall_slong_t jitter ;
   int shift ;
   __syscall_slong_t stabil ;
   __syscall_slong_t jitcnt ;
   __syscall_slong_t calcnt ;
   __syscall_slong_t errcnt ;
   __syscall_slong_t stbcnt ;
   int tai ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
struct __anonstruct___value32_817613185 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
union __anonunion___atomic_wide_counter_775245681 {
   unsigned long long __value64 ;
   struct __anonstruct___value32_817613185 __value32 ;
};
#line 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
typedef union __anonunion___atomic_wide_counter_775245681 __atomic_wide_counter;
#line 51 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 51 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 57 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   __atomic_wide_counter __wseq ;
   __atomic_wide_counter __g1_start ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 105 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned int __tss_t;
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned long __thrd_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct___once_flag_826868709 {
   int __data ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __anonstruct___once_flag_826868709 __once_flag;
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_656928968 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_656928968 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlockattr_t_145707745 {
   char __size[8] ;
   long __align ;
};
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlockattr_t_145707745 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int volatile   pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_barrier_t_145707746 {
   char __size[32] ;
   long __align ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_barrier_t_145707746 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_barrierattr_t_951761806 {
   char __size[4] ;
   int __align ;
};
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_barrierattr_t_951761806 pthread_barrierattr_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_764561023 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_764561023 __sigset_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum_34415463 {
    PTHREAD_CREATE_JOINABLEPTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHEDPTHREAD_CREATE_DETACHED = 1
} ;
#line 47
enum __anonenum_303612439 {
    PTHREAD_MUTEX_TIMED_NPPTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NPPTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NPPTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NPPTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMALPTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVEPTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECKPTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_DEFAULT = 0,
    PTHREAD_MUTEX_FAST_NPPTHREAD_MUTEX_FAST_NP = 0
} ;
#line 69
enum __anonenum_931900394 {
    PTHREAD_MUTEX_STALLEDPTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NPPTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUSTPTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NPPTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 81
enum __anonenum_205214487 {
    PTHREAD_PRIO_NONEPTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERITPTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECTPTHREAD_PRIO_PROTECT = 2
} ;
#line 104
enum __anonenum_25043950 {
    PTHREAD_RWLOCK_PREFER_READER_NPPTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NPPTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NPPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NPPTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 124
enum __anonenum_436439511 {
    PTHREAD_INHERIT_SCHEDPTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHEDPTHREAD_EXPLICIT_SCHED = 1
} ;
#line 134
enum __anonenum_998661166 {
    PTHREAD_SCOPE_SYSTEMPTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESSPTHREAD_SCOPE_PROCESS = 1
} ;
#line 144
enum __anonenum_146137331 {
    PTHREAD_PROCESS_PRIVATEPTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHAREDPTHREAD_PROCESS_SHARED = 1
} ;
#line 159 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 168
enum __anonenum_53396917 {
    PTHREAD_CANCEL_ENABLEPTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLEPTHREAD_CANCEL_DISABLE = 1
} ;
#line 175
enum __anonenum_904563783 {
    PTHREAD_CANCEL_DEFERREDPTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUSPTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 538 "/usr/include/pthread.h"
struct __cancel_jmp_buf_tag {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 544 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_530692248 {
   struct __cancel_jmp_buf_tag __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 544 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_530692248  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 557 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 232 "/usr/include/unistd.h"
typedef __gid_t gid_t;
#line 237 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 243 "/usr/include/unistd.h"
typedef __off_t off_t;
#line 250 "/usr/include/unistd.h"
typedef __off64_t off64_t;
#line 255 "/usr/include/unistd.h"
typedef __useconds_t useconds_t;
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235 {
    _PC_LINK_MAX_PC_LINK_MAX = 0,
    _PC_MAX_CANON_PC_MAX_CANON = 1,
    _PC_MAX_INPUT_PC_MAX_INPUT = 2,
    _PC_NAME_MAX_PC_NAME_MAX = 3,
    _PC_PATH_MAX_PC_PATH_MAX = 4,
    _PC_PIPE_BUF_PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED_PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC_PC_NO_TRUNC = 7,
    _PC_VDISABLE_PC_VDISABLE = 8,
    _PC_SYNC_IO_PC_SYNC_IO = 9,
    _PC_ASYNC_IO_PC_ASYNC_IO = 10,
    _PC_PRIO_IO_PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF_PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS_PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE_PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE_PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE_PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN_PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN_PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX_PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS_PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum_315186338 {
    _SC_ARG_MAX_SC_ARG_MAX = 0,
    _SC_CHILD_MAX_SC_CHILD_MAX = 1,
    _SC_CLK_TCK_SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX_SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX_SC_OPEN_MAX = 4,
    _SC_STREAM_MAX_SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX_SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL_SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS_SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS_SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING_SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS_SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO_SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO_SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO_SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC_SC_FSYNC = 15,
    _SC_MAPPED_FILES_SC_MAPPED_FILES = 16,
    _SC_MEMLOCK_SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE_SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION_SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING_SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES_SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS_SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX_SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX_SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX_SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX_SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX_SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX_SC_MQ_PRIO_MAX = 28,
    _SC_VERSION_SC_VERSION = 29,
    _SC_PAGESIZE_SC_PAGESIZE = 30,
    _SC_RTSIG_MAX_SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX_SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX_SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX_SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX_SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX_SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX_SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX_SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX_SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX_SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX_SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX_SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX_SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX_SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX_SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION_SC_2_VERSION = 46,
    _SC_2_C_BIND_SC_2_C_BIND = 47,
    _SC_2_C_DEV_SC_2_C_DEV = 48,
    _SC_2_FORT_DEV_SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN_SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV_SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF_SC_2_LOCALEDEF = 52,
    _SC_PII_SC_PII = 53,
    _SC_PII_XTI_SC_PII_XTI = 54,
    _SC_PII_SOCKET_SC_PII_SOCKET = 55,
    _SC_PII_INTERNET_SC_PII_INTERNET = 56,
    _SC_PII_OSI_SC_PII_OSI = 57,
    _SC_POLL_SC_POLL = 58,
    _SC_SELECT_SC_SELECT = 59,
    _SC_UIO_MAXIOV_SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX_SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM_SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM_SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS_SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS_SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M_SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX_SC_T_IOV_MAX = 66,
    _SC_THREADS_SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS_SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX_SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX_SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX_SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX_SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS_SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX_SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN_SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX_SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR_SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE_SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING_SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT_SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT_SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED_SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF_SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN_SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES_SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES_SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX_SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX_SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION_SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION_SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX_SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT_SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N_SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM_SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM_SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION_SC_2_C_VERSION = 96,
    _SC_2_UPE_SC_2_UPE = 97,
    _SC_XOPEN_XPG2_SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3_SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4_SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT_SC_CHAR_BIT = 101,
    _SC_CHAR_MAX_SC_CHAR_MAX = 102,
    _SC_CHAR_MIN_SC_CHAR_MIN = 103,
    _SC_INT_MAX_SC_INT_MAX = 104,
    _SC_INT_MIN_SC_INT_MIN = 105,
    _SC_LONG_BIT_SC_LONG_BIT = 106,
    _SC_WORD_BIT_SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX_SC_MB_LEN_MAX = 108,
    _SC_NZERO_SC_NZERO = 109,
    _SC_SSIZE_MAX_SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX_SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN_SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX_SC_SHRT_MAX = 113,
    _SC_SHRT_MIN_SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX_SC_UCHAR_MAX = 115,
    _SC_UINT_MAX_SC_UINT_MAX = 116,
    _SC_ULONG_MAX_SC_ULONG_MAX = 117,
    _SC_USHRT_MAX_SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX_SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX_SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX_SC_NL_MSGMAX = 121,
    _SC_NL_NMAX_SC_NL_NMAX = 122,
    _SC_NL_SETMAX_SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX_SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32_SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG_SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64_SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG_SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY_SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME_SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS_SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO_SC_ADVISORY_INFO = 132,
    _SC_BARRIERS_SC_BARRIERS = 133,
    _SC_BASE_SC_BASE = 134,
    _SC_C_LANG_SUPPORT_SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R_SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION_SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME_SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME_SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO_SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC_SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R_SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT_SC_FD_MGMT = 143,
    _SC_FIFO_SC_FIFO = 144,
    _SC_PIPE_SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES_SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING_SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM_SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK_SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS_SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS_SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING_SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS_SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS_SC_SPIN_LOCKS = 154,
    _SC_REGEXP_SC_REGEXP = 155,
    _SC_REGEX_VERSION_SC_REGEX_VERSION = 156,
    _SC_SHELL_SC_SHELL = 157,
    _SC_SIGNALS_SC_SIGNALS = 158,
    _SC_SPAWN_SC_SPAWN = 159,
    _SC_SPORADIC_SERVER_SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER_SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE_SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R_SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS_SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS_SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS_SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R_SC_USER_GROUPS_R = 167,
    _SC_2_PBS_SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING_SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE_SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE_SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK_SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX_SC_SYMLOOP_MAX = 173,
    _SC_STREAMS_SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT_SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32_SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG_SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64_SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG_SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX_SC_HOST_NAME_MAX = 180,
    _SC_TRACE_SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER_SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT_SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG_SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE_SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC_SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE_SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE_SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC_SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE_SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE_SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC_SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE_SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE_SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC_SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE_SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE_SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC_SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE_SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6_SC_IPV6 = 235,
    _SC_RAW_SOCKETS_SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32_SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG_SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64_SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG_SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX_SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX_SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX_SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX_SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX_SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS_SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT_SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT_SC_THREAD_ROBUST_PRIO_PROTECT = 248,
    _SC_MINSIGSTKSZ_SC_MINSIGSTKSZ = 249,
    _SC_SIGSTKSZ_SC_SIGSTKSZ = 250
} ;
#line 539
enum __anonenum_875524036 {
    _CS_PATH_CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS_CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION_CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION_CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS_CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS_CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS_CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS_CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS_CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS_CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS_CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS_CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS_CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS_CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS_CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS_CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS_CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS_CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS_CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS_CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS_CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS_CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS_CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS_CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS_CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS_CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS_CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS_CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS_CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS_CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS_CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS_CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS_CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS_CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS_CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS_CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS_CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS_CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS_CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS_CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS_CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS_CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS_CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS_CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS_CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS_CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS_CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV_CS_V6_ENV = 1148,
    _CS_V7_ENV_CS_V7_ENV = 1149
} ;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino64_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 138 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __suseconds_t suseconds_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int register_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_356711149 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 219 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt64_t blkcnt64_t;
#line 220 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt64_t fsblkcnt64_t;
#line 221 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt64_t fsfilcnt64_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 21 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef short __s16;
#line 24 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 27 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 31 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 25 "/usr/include/linux/posix_types.h"
struct __anonstruct___kernel_fd_set_603278005 {
   unsigned long fds_bits[1024UL / (8UL * sizeof(long ))] ;
};
#line 25 "/usr/include/linux/posix_types.h"
typedef struct __anonstruct___kernel_fd_set_603278005 __kernel_fd_set;
#line 30 "/usr/include/linux/posix_types.h"
typedef void (*__kernel_sighandler_t)(int  );
#line 33 "/usr/include/linux/posix_types.h"
typedef int __kernel_key_t;
#line 34 "/usr/include/linux/posix_types.h"
typedef int __kernel_mqd_t;
#line 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_uid_t;
#line 12 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_gid_t;
#line 15 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned long __kernel_old_dev_t;
#line 15 "/usr/include/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 16 "/usr/include/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 20 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_ino_t;
#line 24 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_mode_t;
#line 28 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 32 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_ipc_pid_t;
#line 36 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid_t;
#line 37 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid_t;
#line 41 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 45 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_daddr_t;
#line 49 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 50 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 72 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 73 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 74 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ptrdiff_t;
#line 79 "/usr/include/asm-generic/posix_types.h"
struct __anonstruct___kernel_fsid_t_998661167 {
   int val[2] ;
};
#line 79 "/usr/include/asm-generic/posix_types.h"
typedef struct __anonstruct___kernel_fsid_t_998661167 __kernel_fsid_t;
#line 87 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 88 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 89 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_old_time_t;
#line 90 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 91 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_time64_t;
#line 92 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 93 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 94 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 95 "/usr/include/asm-generic/posix_types.h"
typedef char *__kernel_caddr_t;
#line 96 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_uid16_t;
#line 97 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_gid16_t;
#line 12 "/usr/include/linux/types.h"
typedef __int128 __attribute__((__aligned__(16)))  __s128;
#line 13 "/usr/include/linux/types.h"
typedef unsigned __int128 __attribute__((__aligned__(16)))  __u128;
#line 31 "/usr/include/linux/types.h"
typedef __u16 __le16;
#line 32 "/usr/include/linux/types.h"
typedef __u16 __be16;
#line 33 "/usr/include/linux/types.h"
typedef __u32 __le32;
#line 34 "/usr/include/linux/types.h"
typedef __u32 __be32;
#line 35 "/usr/include/linux/types.h"
typedef __u64 __le64;
#line 36 "/usr/include/linux/types.h"
typedef __u64 __be64;
#line 38 "/usr/include/linux/types.h"
typedef __u16 __sum16;
#line 39 "/usr/include/linux/types.h"
typedef __u32 __wsum;
#line 54 "/usr/include/linux/types.h"
typedef unsigned int __poll_t;
#line 56 "/usr/include/linux/stat.h"
struct statx_timestamp {
   __s64 tv_sec ;
   __u32 tv_nsec ;
   __s32 __reserved ;
};
#line 99 "/usr/include/linux/stat.h"
struct statx {
   __u32 stx_mask ;
   __u32 stx_blksize ;
   __u64 stx_attributes ;
   __u32 stx_nlink ;
   __u32 stx_uid ;
   __u32 stx_gid ;
   __u16 stx_mode ;
   __u16 __spare0[1] ;
   __u64 stx_ino ;
   __u64 stx_size ;
   __u64 stx_blocks ;
   __u64 stx_attributes_mask ;
   struct statx_timestamp stx_atime ;
   struct statx_timestamp stx_btime ;
   struct statx_timestamp stx_ctime ;
   struct statx_timestamp stx_mtime ;
   __u32 stx_rdev_major ;
   __u32 stx_rdev_minor ;
   __u32 stx_dev_major ;
   __u32 stx_dev_minor ;
   __u64 stx_mnt_id ;
   __u32 stx_dio_mem_align ;
   __u32 stx_dio_offset_align ;
   __u64 stx_subvol ;
   __u32 stx_atomic_write_unit_min ;
   __u32 stx_atomic_write_unit_max ;
   __u32 stx_atomic_write_segments_max ;
   __u32 __spare1[1] ;
   __u64 __spare3[9] ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h"
typedef __int_least8_t int_least8_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h"
typedef __int_least16_t int_least16_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h"
typedef __int_least32_t int_least32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h"
typedef __int_least64_t int_least64_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h"
typedef __uint_least8_t uint_least8_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h"
typedef __uint_least16_t uint_least16_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h"
typedef __uint_least32_t uint_least32_t;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h"
typedef __uint_least64_t uint_least64_t;
#line 47 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 49 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 50 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 51 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 60 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 62 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 63 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 64 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 79 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 90 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 91 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 332 "/usr/include/inttypes.h"
struct __anonstruct_imaxdiv_t_790849867 {
   long quot ;
   long rem ;
};
#line 332 "/usr/include/inttypes.h"
typedef struct __anonstruct_imaxdiv_t_790849867 imaxdiv_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_628077854 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_96872636 {
   int __count ;
   union __anonunion___value_628077854 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_96872636 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   struct _IO_FILE **_prevchain ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 5UL * sizeof(void *)] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_read_function_t(void *__cookie , char *__buf , size_t __nbytes );
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_write_function_t(void *__cookie , char const   *__buf , size_t __nbytes );
#line 45 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_seek_function_t(void *__cookie , __off64_t *__pos , int __w );
#line 48 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_close_function_t(void *__cookie );
#line 55 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
struct _IO_cookie_io_functions_t {
   cookie_read_function_t *read ;
   cookie_write_function_t *write ;
   cookie_seek_function_t *seek ;
   cookie_close_function_t *close ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef struct _IO_cookie_io_functions_t cookie_io_functions_t;
#line 53 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 85 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 90 "/usr/include/stdio.h"
typedef __fpos64_t fpos64_t;
#line 914
struct obstack ;
#line 329 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
typedef int wchar_t;
#line 59 "/usr/include/stdlib.h"
struct __anonstruct_div_t_773697287 {
   int quot ;
   int rem ;
};
#line 59 "/usr/include/stdlib.h"
typedef struct __anonstruct_div_t_773697287 div_t;
#line 67 "/usr/include/stdlib.h"
struct __anonstruct_ldiv_t_790849868 {
   long quot ;
   long rem ;
};
#line 67 "/usr/include/stdlib.h"
typedef struct __anonstruct_ldiv_t_790849868 ldiv_t;
#line 77 "/usr/include/stdlib.h"
struct __anonstruct_lldiv_t_103911545 {
   long long quot ;
   long long rem ;
};
#line 77 "/usr/include/stdlib.h"
typedef struct __anonstruct_lldiv_t_103911545 lldiv_t;
#line 543 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 610 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 948 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 951 "/usr/include/stdlib.h"
typedef int (*comparison_fn_t)(void const   * , void const   * );
#line 955 "/usr/include/stdlib.h"
typedef int (*__compar_d_fn_t)(void const   * , void const   * , void * );
#line 98 "chess.h"
enum __anonenum_squares_419346031 {
    A1A1 = 0,
    B1B1 = 1,
    C1C1 = 2,
    D1D1 = 3,
    E1E1 = 4,
    F1F1 = 5,
    G1G1 = 6,
    H1H1 = 7,
    A2A2 = 8,
    B2B2 = 9,
    C2C2 = 10,
    D2D2 = 11,
    E2E2 = 12,
    F2F2 = 13,
    G2G2 = 14,
    H2H2 = 15,
    A3A3 = 16,
    B3B3 = 17,
    C3C3 = 18,
    D3D3 = 19,
    E3E3 = 20,
    F3F3 = 21,
    G3G3 = 22,
    H3H3 = 23,
    A4A4 = 24,
    B4B4 = 25,
    C4C4 = 26,
    D4D4 = 27,
    E4E4 = 28,
    F4F4 = 29,
    G4G4 = 30,
    H4H4 = 31,
    A5A5 = 32,
    B5B5 = 33,
    C5C5 = 34,
    D5D5 = 35,
    E5E5 = 36,
    F5F5 = 37,
    G5G5 = 38,
    H5H5 = 39,
    A6A6 = 40,
    B6B6 = 41,
    C6C6 = 42,
    D6D6 = 43,
    E6E6 = 44,
    F6F6 = 45,
    G6G6 = 46,
    H6H6 = 47,
    A7A7 = 48,
    B7B7 = 49,
    C7C7 = 50,
    D7D7 = 51,
    E7E7 = 52,
    F7F7 = 53,
    G7G7 = 54,
    H7H7 = 55,
    A8A8 = 56,
    B8B8 = 57,
    C8C8 = 58,
    D8D8 = 59,
    E8E8 = 60,
    F8F8 = 61,
    G8G8 = 62,
    H8H8 = 63,
    BAD_SQUAREBAD_SQUARE = 64
} ;
#line 98 "chess.h"
typedef enum __anonenum_squares_419346031 squares;
#line 109
enum __anonenum_files_935211846 {
    FILEAFILEA = 0,
    FILEBFILEB = 1,
    FILECFILEC = 2,
    FILEDFILED = 3,
    FILEEFILEE = 4,
    FILEFFILEF = 5,
    FILEGFILEG = 6,
    FILEHFILEH = 7
} ;
#line 109 "chess.h"
typedef enum __anonenum_files_935211846 files;
#line 110
enum __anonenum_ranks_197848440 {
    RANK1RANK1 = 0,
    RANK2RANK2 = 1,
    RANK3RANK3 = 2,
    RANK4RANK4 = 3,
    RANK5RANK5 = 4,
    RANK6RANK6 = 5,
    RANK7RANK7 = 6,
    RANK8RANK8 = 7
} ;
#line 110 "chess.h"
typedef enum __anonenum_ranks_197848440 ranks;
#line 111
enum __anonenum_PIECE_513909666 {
    emptyempty = 0,
    occupiedoccupied = 0,
    pawnpawn = 1,
    knightknight = 2,
    bishopbishop = 3,
    rookrook = 4,
    queenqueen = 5,
    kingking = 6
} ;
#line 111 "chess.h"
typedef enum __anonenum_PIECE_513909666 PIECE;
#line 114
enum __anonenum_COLOR_349344306 {
    blackblack = 0,
    whitewhite = 1
} ;
#line 114 "chess.h"
typedef enum __anonenum_COLOR_349344306 COLOR;
#line 115
enum __anonenum_PHASE_980298249 {
    mgmg = 0,
    egeg = 1
} ;
#line 115 "chess.h"
typedef enum __anonenum_PHASE_980298249 PHASE;
#line 116
enum __anonenum_PIECE_V_659254041 {
    empty_vempty_v = 0,
    pawn_vpawn_v = 1,
    knight_vknight_v = 3,
    bishop_vbishop_v = 3,
    rook_vrook_v = 5,
    queen_vqueen_v = 9,
    king_vking_v = 99
} ;
#line 116 "chess.h"
typedef enum __anonenum_PIECE_V_659254041 PIECE_V;
#line 119
enum __anonenum_SEARCH_MODE_256902515 {
    serialserial = 0,
    parallelparallel = 1
} ;
#line 119 "chess.h"
typedef enum __anonenum_SEARCH_MODE_256902515 SEARCH_MODE;
#line 120
enum __anonenum_SEARCH_TYPE_318137626 {
    thinkthink = 1,
    puzzlepuzzle = 2,
    bookbook = 3,
    annotateannotate = 4
} ;
#line 120 "chess.h"
typedef enum __anonenum_SEARCH_TYPE_318137626 SEARCH_TYPE;
#line 121
enum __anonenum_PLAYING_MODE_706656908 {
    normal_modenormal_mode = 0,
    tournament_modetournament_mode = 1
} ;
#line 121 "chess.h"
typedef enum __anonenum_PLAYING_MODE_706656908 PLAYING_MODE;
#line 122 "chess.h"
struct __anonstruct_SEARCH_POSITION_991381576 {
   int8_t castle[2] ;
   uint8_t enpassant_target ;
   uint8_t reversible ;
};
#line 122 "chess.h"
typedef struct __anonstruct_SEARCH_POSITION_991381576 SEARCH_POSITION;
#line 127 "chess.h"
struct __anonstruct_KILLER_1034260629 {
   uint32_t move1 ;
   uint32_t move2 ;
};
#line 127 "chess.h"
typedef struct __anonstruct_KILLER_1034260629 KILLER;
#line 131 "chess.h"
struct __anonstruct_BB_PIECES_549813859 {
   uint64_t pieces[7] ;
};
#line 131 "chess.h"
typedef struct __anonstruct_BB_PIECES_549813859 BB_PIECES;
#line 134 "chess.h"
struct __anonstruct_POSITION_688342418 {
   BB_PIECES color[2] ;
   uint64_t hash_key ;
   uint64_t pawn_hash_key ;
   int material_evaluation ;
   int kingsq[2] ;
   int8_t board[64] ;
   char pieces[2][7] ;
   char total_all_pieces ;
};
#line 134 "chess.h"
typedef struct __anonstruct_POSITION_688342418 POSITION;
#line 144 "chess.h"
struct __anonstruct_HASH_ENTRY_158253733 {
   uint64_t word1 ;
   uint64_t word2 ;
};
#line 144 "chess.h"
typedef struct __anonstruct_HASH_ENTRY_158253733 HASH_ENTRY;
#line 148 "chess.h"
struct __anonstruct_PAWN_HASH_ENTRY_489277528 {
   uint64_t key ;
   int32_t score_mg ;
   int32_t score_eg ;
   unsigned char defects_k[2] ;
   unsigned char defects_m[2] ;
   unsigned char defects_q[2] ;
   unsigned char passed[2] ;
};
#line 148 "chess.h"
typedef struct __anonstruct_PAWN_HASH_ENTRY_489277528 PAWN_HASH_ENTRY;
#line 156 "chess.h"
struct __anonstruct_PXOR_688342419 {
   uint64_t entry[3] ;
};
#line 156 "chess.h"
typedef struct __anonstruct_PXOR_688342419 PXOR;
#line 159 "chess.h"
struct __anonstruct_PATH_1068738709 {
   int path[129] ;
   int pathh ;
   int pathl ;
   int pathd ;
   int pathv ;
};
#line 159 "chess.h"
typedef struct __anonstruct_PATH_1068738709 PATH;
#line 166 "chess.h"
struct __anonstruct_HPATH_ENTRY_160597948 {
   uint64_t path_sig ;
   int hash_pathl ;
   int hash_path_age ;
   int hash_path_moves[129] ;
};
#line 166 "chess.h"
typedef struct __anonstruct_HPATH_ENTRY_160597948 HPATH_ENTRY;
#line 172 "chess.h"
struct __anonstruct_NEXT_MOVE_747876605 {
   int phase ;
   int order ;
   int remaining ;
   unsigned int *last ;
   unsigned int done[10] ;
   unsigned int *exclude ;
};
#line 172 "chess.h"
typedef struct __anonstruct_NEXT_MOVE_747876605 NEXT_MOVE;
#line 188 "chess.h"
struct __anonstruct_ROOT_MOVE_688537541 {
   int move ;
   unsigned int status ;
   int bm_age ;
   PATH path ;
};
#line 188 "chess.h"
typedef struct __anonstruct_ROOT_MOVE_688537541 ROOT_MOVE;
#line 197 "chess.h"
struct __anonstruct_BOOK_POSITION_542568456 {
   uint64_t position ;
   unsigned int status_played ;
   float learn ;
};
#line 197 "chess.h"
typedef struct __anonstruct_BOOK_POSITION_542568456 BOOK_POSITION;
#line 205 "chess.h"
struct __anonstruct_BB_POSITION_71534737 {
   unsigned char position[8] ;
   unsigned char status ;
   unsigned char percent_play ;
};
#line 205 "chess.h"
typedef struct __anonstruct_BB_POSITION_71534737 BB_POSITION;
#line 210 "chess.h"
struct personality_term {
   char *description ;
   int type ;
   int size ;
   void *value ;
};
#line 216 "chess.h"
struct autotune {
   unsigned int min ;
   unsigned int max ;
   unsigned int increment ;
   char description[64] ;
   char command[16] ;
   unsigned int *parameter ;
};
#line 224 "chess.h"
struct tree {
   SEARCH_POSITION status[132] ;
   NEXT_MOVE next_status[129] ;
   KILLER killers[129] ;
   KILLER counter_move[4096] ;
   KILLER move_pair[4096] ;
   POSITION position ;
   uint64_t save_hash_key[132] ;
   uint64_t save_pawn_hash_key[132] ;
   uint64_t rep_list[256] ;
   int curmv[129] ;
   int phase[129] ;
   int hash_move[129] ;
   unsigned int *last[129] ;
   unsigned int move_list[5120] ;
   PATH pv[129] ;
   PAWN_HASH_ENTRY pawn_score ;
   int tropism[2] ;
   int dangerous[2] ;
   uint64_t all_pawns ;
   int score_mg ;
   int score_eg ;
   uint64_t nodes_searched ;
   uint64_t fail_highs ;
   uint64_t fail_high_first_move ;
   uint64_t evaluations ;
   uint64_t egtb_probes ;
   uint64_t egtb_hits ;
   uint64_t extensions_done ;
   uint64_t qchecks_done ;
   uint64_t moves_fpruned ;
   uint64_t moves_mpruned ;
   uint64_t LMR_done[16] ;
   uint64_t null_done[16] ;
   int volatile   lock ;
   int thread_id ;
   int volatile   joinable ;
   int volatile   joined ;
   int volatile   stop ;
   int volatile   nprocs ;
   int alpha ;
   int beta ;
   int volatile   value ;
   int wtm ;
   int depth ;
   int ply ;
   int in_check ;
   int *searched ;
   int cutmove ;
   struct tree * volatile  siblings[4] ;
   struct tree *parent ;
   char root_move_text[16] ;
   char remaining_moves_text[16] ;
};
#line 224 "chess.h"
typedef struct tree TREE;
#line 281 "chess.h"
struct thread {
   TREE *tree ;
   uint64_t blocks ;
   uint64_t max_blocks ;
   unsigned int idle ;
   unsigned int volatile   terminate ;
   char filler[40] ;
};
#line 281 "chess.h"
typedef struct thread THREAD;
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h"
typedef int error_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum_18926444 {
    _ISupper_ISupper = 256,
    _ISlower_ISlower = 512,
    _ISalpha_ISalpha = 1024,
    _ISdigit_ISdigit = 2048,
    _ISxdigit_ISxdigit = 4096,
    _ISspace_ISspace = 8192,
    _ISprint_ISprint = 16384,
    _ISgraph_ISgraph = 32768,
    _ISblank_ISblank = 1,
    _IScntrl_IScntrl = 2,
    _ISpunct_ISpunct = 4,
    _ISalnum_ISalnum = 8
} ;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__bounds_825601465 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigfault_394993644 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_825601465 _bounds ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigsys_634745154 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__sifields_576936292 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_394993644 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_634745154 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_siginfo_t_747601458 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_576936292 _sifields ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_siginfo_t_747601458 siginfo_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum_556971655 {
    SI_ASYNCNLSI_ASYNCNL = -60,
    SI_DETHREADSI_DETHREAD = -7,
    SI_TKILLSI_TKILL = -6,
    SI_SIGIOSI_SIGIO = -5,
    SI_ASYNCIOSI_ASYNCIO = -4,
    SI_MESGQSI_MESGQ = -3,
    SI_TIMERSI_TIMER = -2,
    SI_QUEUESI_QUEUE = -1,
    SI_USERSI_USER = 0,
    SI_KERNELSI_KERNEL = 128
} ;
#line 71
enum __anonenum_640648963 {
    ILL_ILLOPCILL_ILLOPC = 1,
    ILL_ILLOPNILL_ILLOPN = 2,
    ILL_ILLADRILL_ILLADR = 3,
    ILL_ILLTRPILL_ILLTRP = 4,
    ILL_PRVOPCILL_PRVOPC = 5,
    ILL_PRVREGILL_PRVREG = 6,
    ILL_COPROCILL_COPROC = 7,
    ILL_BADSTKILL_BADSTK = 8,
    ILL_BADIADDRILL_BADIADDR = 9
} ;
#line 94
enum __anonenum_457704180 {
    FPE_INTDIVFPE_INTDIV = 1,
    FPE_INTOVFFPE_INTOVF = 2,
    FPE_FLTDIVFPE_FLTDIV = 3,
    FPE_FLTOVFFPE_FLTOVF = 4,
    FPE_FLTUNDFPE_FLTUND = 5,
    FPE_FLTRESFPE_FLTRES = 6,
    FPE_FLTINVFPE_FLTINV = 7,
    FPE_FLTSUBFPE_FLTSUB = 8,
    FPE_FLTUNKFPE_FLTUNK = 14,
    FPE_CONDTRAPFPE_CONDTRAP = 15
} ;
#line 119
enum __anonenum_850350928 {
    SEGV_MAPERRSEGV_MAPERR = 1,
    SEGV_ACCERRSEGV_ACCERR = 2,
    SEGV_BNDERRSEGV_BNDERR = 3,
    SEGV_PKUERRSEGV_PKUERR = 4,
    SEGV_ACCADISEGV_ACCADI = 5,
    SEGV_ADIDERRSEGV_ADIDERR = 6,
    SEGV_ADIPERRSEGV_ADIPERR = 7,
    SEGV_MTEAERRSEGV_MTEAERR = 8,
    SEGV_MTESERRSEGV_MTESERR = 9,
    SEGV_CPERRSEGV_CPERR = 10
} ;
#line 144
enum __anonenum_1036286214 {
    BUS_ADRALNBUS_ADRALN = 1,
    BUS_ADRERRBUS_ADRERR = 2,
    BUS_OBJERRBUS_OBJERR = 3,
    BUS_MCEERR_ARBUS_MCEERR_AR = 4,
    BUS_MCEERR_AOBUS_MCEERR_AO = 5
} ;
#line 161
enum __anonenum_91015150 {
    TRAP_BRKPTTRAP_BRKPT = 1,
    TRAP_TRACETRAP_TRACE = 2,
    TRAP_BRANCHTRAP_BRANCH = 3,
    TRAP_HWBKPTTRAP_HWBKPT = 4,
    TRAP_UNKTRAP_UNK = 5
} ;
#line 178
enum __anonenum_23175539 {
    CLD_EXITEDCLD_EXITED = 1,
    CLD_KILLEDCLD_KILLED = 2,
    CLD_DUMPEDCLD_DUMPED = 3,
    CLD_TRAPPEDCLD_TRAPPED = 4,
    CLD_STOPPEDCLD_STOPPED = 5,
    CLD_CONTINUEDCLD_CONTINUED = 6
} ;
#line 195
enum __anonenum_111643124 {
    POLL_INPOLL_IN = 1,
    POLL_OUTPOLL_OUT = 2,
    POLL_MSGPOLL_MSG = 3,
    POLL_ERRPOLL_ERR = 4,
    POLL_PRIPOLL_PRI = 5,
    POLL_HUPPOLL_HUP = 6
} ;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h"
typedef __sigval_t sigval_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct __anonstruct__sigev_thread_746770901 {
   void (*_function)(__sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
union __anonunion__sigev_un_310426422 {
   int _pad[64UL / sizeof(int ) - 4UL] ;
   __pid_t _tid ;
   struct __anonstruct__sigev_thread_746770901 _sigev_thread ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_310426422 _sigev_un ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
typedef struct sigevent sigevent_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum_852341087 {
    SIGEV_SIGNALSIGEV_SIGNAL = 0,
    SIGEV_NONESIGEV_NONE = 1,
    SIGEV_THREADSIGEV_THREAD = 2,
    SIGEV_THREAD_IDSIGEV_THREAD_ID = 4
} ;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 188 "/usr/include/signal.h"
typedef void (*sighandler_t)(int  );
#line 193 "/usr/include/signal.h"
typedef void (*sig_t)(int  );
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpx_sw_bytes {
   __uint32_t magic1 ;
   __uint32_t extended_size ;
   __uint64_t xstate_bv ;
   __uint32_t xstate_size ;
   __uint32_t __glibc_reserved1[7] ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xmmreg {
   __uint32_t element[4] ;
};
#line 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _fpxreg _st[8] ;
   struct _xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
union __anonunion____missing_field_name_501150464 {
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct sigcontext {
   __uint64_t r8 ;
   __uint64_t r9 ;
   __uint64_t r10 ;
   __uint64_t r11 ;
   __uint64_t r12 ;
   __uint64_t r13 ;
   __uint64_t r14 ;
   __uint64_t r15 ;
   __uint64_t rdi ;
   __uint64_t rsi ;
   __uint64_t rbp ;
   __uint64_t rbx ;
   __uint64_t rdx ;
   __uint64_t rax ;
   __uint64_t rcx ;
   __uint64_t rsp ;
   __uint64_t rip ;
   __uint64_t eflags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   __uint64_t err ;
   __uint64_t trapno ;
   __uint64_t oldmask ;
   __uint64_t cr2 ;
   union __anonunion____missing_field_name_501150464 __annonCompField1 ;
   __uint64_t __reserved1[8] ;
};
#line 177 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xsave_hdr {
   __uint64_t xstate_bv ;
   __uint64_t __glibc_reserved1[2] ;
   __uint64_t __glibc_reserved2[5] ;
};
#line 184 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _ymmh_state {
   __uint32_t ymmh_space[64] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
struct __anonstruct_stack_t_648343364 {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
typedef struct __anonstruct_stack_t_648343364 stack_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 50
enum __anonenum_451154152 {
    REG_R8REG_R8 = 0,
    REG_R9REG_R9 = 1,
    REG_R10REG_R10 = 2,
    REG_R11REG_R11 = 3,
    REG_R12REG_R12 = 4,
    REG_R13REG_R13 = 5,
    REG_R14REG_R14 = 6,
    REG_R15REG_R15 = 7,
    REG_RDIREG_RDI = 8,
    REG_RSIREG_RSI = 9,
    REG_RBPREG_RBP = 10,
    REG_RBXREG_RBX = 11,
    REG_RDXREG_RDX = 12,
    REG_RAXREG_RAX = 13,
    REG_RCXREG_RCX = 14,
    REG_RSPREG_RSP = 15,
    REG_RIPREG_RIP = 16,
    REG_EFLREG_EFL = 17,
    REG_CSGSFSREG_CSGSFS = 18,
    REG_ERRREG_ERR = 19,
    REG_TRAPNOREG_TRAPNO = 20,
    REG_OLDMASKREG_OLDMASK = 21,
    REG_CR2REG_CR2 = 22
} ;
#line 101 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 108 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 113 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 130 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_mcontext_t_5268627 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_mcontext_t_5268627 mcontext_t;
#line 142 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext_t {
   unsigned long uc_flags ;
   struct ucontext_t *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
   unsigned long long __ssp[4] ;
};
#line 142 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct ucontext_t ucontext_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum_57186863 {
    SS_ONSTACKSS_ONSTACK = 1,
    SS_DISABLESS_DISABLE = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h"
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/idtype_t.h"
enum __anonenum_idtype_t_239471009 {
    P_ALLP_ALL = 0,
    P_PIDP_PID = 1,
    P_PGIDP_PGID = 2,
    P_PIDFDP_PIDFD = 3
} ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/idtype_t.h"
typedef enum __anonenum_idtype_t_239471009 idtype_t;
#line 135 "/usr/include/x86_64-linux-gnu/sys/wait.h"
struct rusage ;
#line 32 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 114
enum __itimer_which {
    ITIMER_REALITIMER_REAL = 0,
    ITIMER_VIRTUALITIMER_VIRTUAL = 1,
    ITIMER_PROFITIMER_PROF = 2
} ;
#line 130 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 141 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef enum __itimer_which __itimer_which_t;
#line 156 "utility.c"
union __anonunion_temp_788510206 {
   float fv ;
   int iv ;
};
#line 221 "utility.c"
union __anonunion_temp_788510207 {
   float fv ;
   int iv ;
};
#line 86 "tbprobe.c"
struct pos {
   uint64_t white ;
   uint64_t black ;
   uint64_t kings ;
   uint64_t queens ;
   uint64_t rooks ;
   uint64_t bishops ;
   uint64_t knights ;
   uint64_t pawns ;
   uint8_t rule50 ;
   uint8_t ep ;
   _Bool turn ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock64 {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
enum __pid_type {
    F_OWNER_TIDF_OWNER_TID = 0,
    F_OWNER_PIDF_OWNER_PID = 1,
    F_OWNER_PGRPF_OWNER_PGRP = 2,
    F_OWNER_GIDF_OWNER_GID = 2
} ;
#line 274 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
struct f_owner_ex {
   enum __pid_type type ;
   __pid_t pid ;
};
#line 359 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
struct file_handle {
   unsigned int handle_bytes ;
   int handle_type ;
   unsigned char f_handle[0] ;
};
#line 53 "tbcore.h"
typedef unsigned long long uint64;
#line 54 "tbcore.h"
typedef unsigned int uint32;
#line 55 "tbcore.h"
typedef unsigned char ubyte;
#line 56 "tbcore.h"
typedef unsigned short ushort___0;
#line 58
struct TBHashEntry ;
#line 63 "tbcore.h"
typedef uint32 base_t;
#line 66 "tbcore.h"
struct PairsData {
   char *indextable ;
   ushort___0 *sizetable ;
   ubyte *data ;
   ushort___0 *offset ;
   ubyte *symlen ;
   ubyte *sympat ;
   int blocksize ;
   int idxbits ;
   int min_len ;
   base_t base[1] ;
};
#line 79 "tbcore.h"
struct TBEntry {
   char *data ;
   uint64 key ;
   uint64 mapping ;
   ubyte ready ;
   ubyte num ;
   ubyte symmetric ;
   ubyte has_pawns ;
} __attribute__((__may_alias__)) ;
#line 89 "tbcore.h"
struct TBEntry_piece {
   char *data ;
   uint64 key ;
   uint64 mapping ;
   ubyte ready ;
   ubyte num ;
   ubyte symmetric ;
   ubyte has_pawns ;
   ubyte enc_type ;
   struct PairsData *precomp[2] ;
   int factor[2][6] ;
   ubyte pieces[2][6] ;
   ubyte norm[2][6] ;
};
#line 104 "tbcore.h"
struct __anonstruct_file_955168894 {
   struct PairsData *precomp[2] ;
   int factor[2][6] ;
   ubyte pieces[2][6] ;
   ubyte norm[2][6] ;
};
#line 104 "tbcore.h"
struct TBEntry_pawn {
   char *data ;
   uint64 key ;
   uint64 mapping ;
   ubyte ready ;
   ubyte num ;
   ubyte symmetric ;
   ubyte has_pawns ;
   ubyte pawns[2] ;
   struct __anonstruct_file_955168894 file[4] ;
};
#line 121 "tbcore.h"
struct DTZEntry_piece {
   char *data ;
   uint64 key ;
   uint64 mapping ;
   ubyte ready ;
   ubyte num ;
   ubyte symmetric ;
   ubyte has_pawns ;
   ubyte enc_type ;
   struct PairsData *precomp ;
   int factor[6] ;
   ubyte pieces[6] ;
   ubyte norm[6] ;
   ubyte flags ;
   ushort___0 map_idx[4] ;
   ubyte *map ;
};
#line 139 "tbcore.h"
struct __anonstruct_file_955168895 {
   struct PairsData *precomp ;
   int factor[6] ;
   ubyte pieces[6] ;
   ubyte norm[6] ;
};
#line 139 "tbcore.h"
struct DTZEntry_pawn {
   char *data ;
   uint64 key ;
   uint64 mapping ;
   ubyte ready ;
   ubyte num ;
   ubyte symmetric ;
   ubyte has_pawns ;
   ubyte pawns[2] ;
   struct __anonstruct_file_955168895 file[4] ;
   ubyte flags[4] ;
   ushort___0 map_idx[4][4] ;
   ubyte *map ;
};
#line 159 "tbcore.h"
struct TBHashEntry {
   uint64 key ;
   struct TBEntry *ptr ;
};
#line 164 "tbcore.h"
struct DTZTableEntry {
   uint64 key1 ;
   uint64 key2 ;
   struct TBEntry *entry ;
};
#line 163 "/usr/include/math.h"
typedef float float_t;
#line 164 "/usr/include/math.h"
typedef double double_t;
#line 251
enum __anonenum_913965969 {
    FP_INT_UPWARDFP_INT_UPWARD = 0,
    FP_INT_DOWNWARDFP_INT_DOWNWARD = 1,
    FP_INT_TOWARDZEROFP_INT_TOWARDZERO = 2,
    FP_INT_TONEARESTFROMZEROFP_INT_TONEARESTFROMZERO = 3,
    FP_INT_TONEARESTFP_INT_TONEAREST = 4
} ;
#line 934
enum __anonenum_1037408945 {
    FP_NANFP_NAN = 0,
    FP_INFINITEFP_INFINITE = 1,
    FP_ZEROFP_ZERO = 2,
    FP_SUBNORMALFP_SUBNORMAL = 3,
    FP_NORMALFP_NORMAL = 4
} ;
#line 145 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
typedef long ptrdiff_t;
#line 425 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
struct __anonstruct_max_align_t_896270833 {
   long long __max_align_ll  __attribute__((__aligned__(__alignof__(long long )))) ;
   long double __max_align_ld  __attribute__((__aligned__(__alignof__(long double )))) ;
};
#line 425 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
typedef struct __anonstruct_max_align_t_896270833 max_align_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum_34415463___0 {
    PTHREAD_CREATE_JOINABLE___0PTHREAD_CREATE_JOINABLE___0 = 0,
    PTHREAD_CREATE_DETACHED___0PTHREAD_CREATE_DETACHED___0 = 1
} ;
#line 47
enum __anonenum_508643754 {
    PTHREAD_MUTEX_TIMED_NP___0PTHREAD_MUTEX_TIMED_NP___0 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___0PTHREAD_MUTEX_RECURSIVE_NP___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___0PTHREAD_MUTEX_ERRORCHECK_NP___0 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___0PTHREAD_MUTEX_ADAPTIVE_NP___0 = 3,
    PTHREAD_MUTEX_NORMAL___0PTHREAD_MUTEX_NORMAL___0 = 0,
    PTHREAD_MUTEX_RECURSIVE___0PTHREAD_MUTEX_RECURSIVE___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK___0PTHREAD_MUTEX_ERRORCHECK___0 = 2,
    PTHREAD_MUTEX_DEFAULT___0PTHREAD_MUTEX_DEFAULT___0 = 0
} ;
#line 69
enum __anonenum_931900394___0 {
    PTHREAD_MUTEX_STALLED___0PTHREAD_MUTEX_STALLED___0 = 0,
    PTHREAD_MUTEX_STALLED_NP___0PTHREAD_MUTEX_STALLED_NP___0 = 0,
    PTHREAD_MUTEX_ROBUST___0PTHREAD_MUTEX_ROBUST___0 = 1,
    PTHREAD_MUTEX_ROBUST_NP___0PTHREAD_MUTEX_ROBUST_NP___0 = 1
} ;
#line 81
enum __anonenum_205214487___0 {
    PTHREAD_PRIO_NONE___0PTHREAD_PRIO_NONE___0 = 0,
    PTHREAD_PRIO_INHERIT___0PTHREAD_PRIO_INHERIT___0 = 1,
    PTHREAD_PRIO_PROTECT___0PTHREAD_PRIO_PROTECT___0 = 2
} ;
#line 104
enum __anonenum_25043950___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___0PTHREAD_RWLOCK_PREFER_READER_NP___0 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___0PTHREAD_RWLOCK_PREFER_WRITER_NP___0 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___0PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___0 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___0PTHREAD_RWLOCK_DEFAULT_NP___0 = 0
} ;
#line 124
enum __anonenum_436439511___0 {
    PTHREAD_INHERIT_SCHED___0PTHREAD_INHERIT_SCHED___0 = 0,
    PTHREAD_EXPLICIT_SCHED___0PTHREAD_EXPLICIT_SCHED___0 = 1
} ;
#line 134
enum __anonenum_998661166___0 {
    PTHREAD_SCOPE_SYSTEM___0PTHREAD_SCOPE_SYSTEM___0 = 0,
    PTHREAD_SCOPE_PROCESS___0PTHREAD_SCOPE_PROCESS___0 = 1
} ;
#line 144
enum __anonenum_146137331___0 {
    PTHREAD_PROCESS_PRIVATE___0PTHREAD_PROCESS_PRIVATE___0 = 0,
    PTHREAD_PROCESS_SHARED___0PTHREAD_PROCESS_SHARED___0 = 1
} ;
#line 168
enum __anonenum_53396917___0 {
    PTHREAD_CANCEL_ENABLE___0PTHREAD_CANCEL_ENABLE___0 = 0,
    PTHREAD_CANCEL_DISABLE___0PTHREAD_CANCEL_DISABLE___0 = 1
} ;
#line 175
enum __anonenum_904563783___0 {
    PTHREAD_CANCEL_DEFERRED___0PTHREAD_CANCEL_DEFERRED___0 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___0PTHREAD_CANCEL_ASYNCHRONOUS___0 = 1
} ;
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_frob_return_address(void * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_and_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_or(...) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch(...) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_16(...) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_16(...) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_1(...) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or(...) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   void __sync_synchronize(...) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_or_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_4(...) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_4(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_n(...) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_add_and_fetch(...) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __atomic_signal_fence(int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_nand(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_2(...) ;  */
/* compiler builtin: 
   void __atomic_thread_fence(int  ) ;  */
/* compiler builtin: 
   void __atomic_store_16(...) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_8(...) ;  */
/* compiler builtin: 
   short __builtin_bswap16(short  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_2(...) ;  */
/* compiler builtin: 
   _Bool __atomic_test_and_set(void * , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_8(...) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_16(...) ;  */
/* compiler builtin: 
   void __atomic_clear(_Bool * , int  ) ;  */
/* compiler builtin: 
   void __atomic_store(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_2(...) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch(...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_4(...) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_sub_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_nand_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_16(...) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* compiler builtin: 
   _Bool __atomic_always_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_xor_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_8(...) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_1(...) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_and(...) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   void __atomic_feraiseexcept(int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_4(...) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_1(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_2(...) ;  */
/* compiler builtin: 
   void __sync_lock_release(...) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_8(...) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add(...) ;  */
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_2(...) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_n(...) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_16(...) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_n(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_1(...) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   char *__builtin_strcat(char * , char const   * ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_1(...) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_1(...) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_4(...) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_2(...) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __atomic_store_2(...) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_xor(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_4(...) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange(...) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_1(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_1(...) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_2(...) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   void __atomic_load(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_val_compare_and_swap(...) ;  */
/* compiler builtin: 
   void __atomic_store_4(...) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_16(...) ;  */
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_2(...) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   void __atomic_exchange(...) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_8(...) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_16(...) ;  */
/* compiler builtin: 
   void *__builtin_memchr(void const   * , int  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_2(...) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_2(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_16(...) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_16(...) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_4(...) ;  */
/* compiler builtin: 
   void __atomic_store_n(...) ;  */
/* compiler builtin: 
   void __builtin_trap(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_4(...) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_lock_test_and_set(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_16(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch(...) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_8(...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch(...) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void __atomic_store_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_8(...) ;  */
/* compiler builtin: 
   _Bool __sync_bool_compare_and_swap(...) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __builtin_tgmath(...) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_1(...) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   void __atomic_store_1(...) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_16(...) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_sub(...) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_2(...) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   _Bool __atomic_is_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub(...) ;  */
/* compiler builtin: 
   void *__builtin_extract_return_addr(void * ) ;  */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_4(...) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
#line 86 "/usr/include/x86_64-linux-gnu/bits/sched.h"
extern int ( __attribute__((__leaf__)) clone)(int (*__fn)(void *__arg ) , void *__child_stack ,
                                              int __flags , void *__arg  , ...)  __attribute__((__nothrow__)) ;
#line 90
extern int ( __attribute__((__leaf__)) unshare)(int __flags )  __attribute__((__nothrow__)) ;
#line 93
extern int ( __attribute__((__leaf__)) sched_getcpu)(void)  __attribute__((__nothrow__)) ;
#line 96
extern int ( __attribute__((__leaf__)) getcpu)(unsigned int * , unsigned int * )  __attribute__((__nothrow__)) ;
#line 99
extern int ( __attribute__((__leaf__)) setns)(int __fd , int __nstype )  __attribute__((__nothrow__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern int ( __attribute__((__leaf__)) __sched_cpucount)(size_t __setsize , cpu_set_t const   *__setp )  __attribute__((__nothrow__)) ;
#line 119
extern cpu_set_t *( __attribute__((__warn_unused_result__, __leaf__)) __sched_cpualloc)(size_t __count )  __attribute__((__nothrow__)) ;
#line 120
extern void ( __attribute__((__leaf__)) __sched_cpufree)(cpu_set_t *__set )  __attribute__((__nothrow__)) ;
#line 54 "/usr/include/sched.h"
extern int ( __attribute__((__leaf__)) sched_setparam)(__pid_t __pid , struct sched_param  const  *__param )  __attribute__((__nothrow__)) ;
#line 58
extern int ( __attribute__((__leaf__)) sched_getparam)(__pid_t __pid , struct sched_param *__param )  __attribute__((__nothrow__)) ;
#line 61
extern int ( __attribute__((__leaf__)) sched_setscheduler)(__pid_t __pid , int __policy ,
                                                           struct sched_param  const  *__param )  __attribute__((__nothrow__)) ;
#line 65
extern int ( __attribute__((__leaf__)) sched_getscheduler)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 68
extern int ( __attribute__((__leaf__)) sched_yield)(void)  __attribute__((__nothrow__)) ;
#line 71
extern int ( __attribute__((__leaf__)) sched_get_priority_max)(int __algorithm )  __attribute__((__nothrow__)) ;
#line 74
extern int ( __attribute__((__leaf__)) sched_get_priority_min)(int __algorithm )  __attribute__((__nothrow__)) ;
#line 78
extern int ( __attribute__((__leaf__)) sched_rr_get_interval)(__pid_t __pid , struct timespec *__t )  __attribute__((__nothrow__)) ;
#line 130
extern int ( __attribute__((__leaf__)) sched_setaffinity)(__pid_t __pid , size_t __cpusetsize ,
                                                          cpu_set_t const   *__cpuset )  __attribute__((__nothrow__)) ;
#line 134
extern int ( __attribute__((__leaf__)) sched_getaffinity)(__pid_t __pid , size_t __cpusetsize ,
                                                          cpu_set_t *__cpuset )  __attribute__((__nothrow__)) ;
#line 78 "/usr/include/x86_64-linux-gnu/bits/time.h"
extern int ( __attribute__((__nonnull__(2), __leaf__)) clock_adjtime)(__clockid_t __clock_id ,
                                                                      struct timex *__utx )  __attribute__((__nothrow__)) ;
#line 72 "/usr/include/time.h"
extern clock_t ( __attribute__((__leaf__)) clock)(void)  __attribute__((__nothrow__)) ;
#line 76
extern time_t ( __attribute__((__leaf__)) time)(time_t *__timer )  __attribute__((__nothrow__)) ;
#line 79
extern double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 99
extern size_t ( __attribute__((__nonnull__(1,3,4), __leaf__)) strftime)(char *__s ,
                                                                        size_t __maxsize ,
                                                                        char const   *__format ,
                                                                        struct tm  const  *__tp )  __attribute__((__nothrow__)) ;
#line 107
extern char *( __attribute__((__leaf__)) strptime)(char const   * __restrict  __s ,
                                                   char const   * __restrict  __fmt ,
                                                   struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 116
extern size_t ( __attribute__((__leaf__)) strftime_l)(char *__s , size_t __maxsize ,
                                                      char const   *__format , struct tm  const  *__tp ,
                                                      locale_t __loc )  __attribute__((__nothrow__)) ;
#line 123
extern char *( __attribute__((__leaf__)) strptime_l)(char const   * __restrict  __s ,
                                                     char const   * __restrict  __fmt ,
                                                     struct tm *__tp , locale_t __loc )  __attribute__((__nothrow__)) ;
#line 132
extern struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer )  __attribute__((__nothrow__)) ;
#line 136
extern struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer )  __attribute__((__nothrow__)) ;
#line 154
extern struct tm *( __attribute__((__leaf__)) gmtime_r)(time_t const   *__timer ,
                                                        struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 159
extern struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   *__timer ,
                                                           struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 179
extern char *( __attribute__((__leaf__)) asctime)(struct tm  const  *__tp )  __attribute__((__nothrow__)) ;
#line 183
extern char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer )  __attribute__((__nothrow__)) ;
#line 197
extern char *( __attribute__((__leaf__)) asctime_r)(struct tm  const  *__tp , char *__buf )  __attribute__((__nothrow__)) ;
#line 202
extern char *( __attribute__((__leaf__)) ctime_r)(time_t const   *__timer , char *__buf )  __attribute__((__nothrow__)) ;
#line 217
extern char *__tzname[2] ;
#line 218
extern int __daylight ;
#line 219
extern long __timezone ;
#line 224
extern char *tzname[2] ;
#line 228
extern void ( __attribute__((__leaf__)) tzset)(void)  __attribute__((__nothrow__)) ;
#line 232
extern int daylight ;
#line 233
extern long timezone ;
#line 246
extern time_t ( __attribute__((__leaf__)) timegm)(struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 263
extern time_t ( __attribute__((__leaf__)) timelocal)(struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 271
extern int ( __attribute__((__leaf__)) dysize)(int __year )  __attribute__((__nothrow__,
__const__)) ;
#line 281
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 285
extern int ( __attribute__((__leaf__)) clock_getres)(clockid_t __clock_id , struct timespec *__res )  __attribute__((__nothrow__)) ;
#line 288
extern int ( __attribute__((__nonnull__(2), __leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                      struct timespec *__tp )  __attribute__((__nothrow__)) ;
#line 292
extern int ( __attribute__((__nonnull__(2), __leaf__)) clock_settime)(clockid_t __clock_id ,
                                                                      struct timespec  const  *__tp )  __attribute__((__nothrow__)) ;
#line 323
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec  const  *__req ,
                           struct timespec *__rem ) ;
#line 338
extern int ( __attribute__((__leaf__)) clock_getcpuclockid)(pid_t __pid , clockid_t *__clock_id )  __attribute__((__nothrow__)) ;
#line 343
extern int ( __attribute__((__leaf__)) timer_create)(clockid_t __clock_id , struct sigevent *__evp ,
                                                     timer_t *__timerid )  __attribute__((__nothrow__)) ;
#line 348
extern int ( __attribute__((__leaf__)) timer_delete)(timer_t __timerid )  __attribute__((__nothrow__)) ;
#line 352
extern int ( __attribute__((__leaf__)) timer_settime)(timer_t __timerid , int __flags ,
                                                      struct itimerspec  const  *__value ,
                                                      struct itimerspec *__ovalue )  __attribute__((__nothrow__)) ;
#line 357
extern int ( __attribute__((__leaf__)) timer_gettime)(timer_t __timerid , struct itimerspec *__value )  __attribute__((__nothrow__)) ;
#line 376
extern int ( __attribute__((__leaf__)) timer_getoverrun)(timer_t __timerid )  __attribute__((__nothrow__)) ;
#line 383
extern int ( __attribute__((__nonnull__(1), __leaf__)) timespec_get)(struct timespec *__ts ,
                                                                     int __base )  __attribute__((__nothrow__)) ;
#line 399
extern int ( __attribute__((__leaf__)) timespec_getres)(struct timespec *__ts , int __base )  __attribute__((__nothrow__)) ;
#line 425
extern int getdate_err ;
#line 434
extern struct tm *getdate(char const   *__string ) ;
#line 448
extern int getdate_r(char const   * __restrict  __string , struct tm * __restrict  __resbufp ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h"
extern long ( __attribute__((__leaf__)) __sysconf)(int __name )  __attribute__((__nothrow__)) ;
#line 202 "/usr/include/pthread.h"
extern int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t *__newthread ,
                                                               pthread_attr_t const   *__attr ,
                                                               void *(*__start_routine)(void * ) ,
                                                               void *__arg )  __attribute__((__nothrow__)) ;
#line 211
extern void pthread_exit(void *__retval )  __attribute__((__noreturn__)) ;
#line 219
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 224
extern int ( __attribute__((__leaf__)) pthread_tryjoin_np)(pthread_t __th , void **__thread_return )  __attribute__((__nothrow__)) ;
#line 233
extern int pthread_timedjoin_np(pthread_t __th , void **__thread_return , struct timespec  const  *__abstime ) ;
#line 243
extern int pthread_clockjoin_np(pthread_t __th , void **__thread_return , clockid_t __clockid ,
                                struct timespec  const  *__abstime ) ;
#line 269
extern int ( __attribute__((__leaf__)) pthread_detach)(pthread_t __th )  __attribute__((__nothrow__)) ;
#line 273
extern pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 276
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal___0)(pthread_t __thread1 ,
                                                                                   pthread_t __thread2 )  __attribute__((__nothrow__,
__const__)) ;
#line 285
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr )  __attribute__((__nothrow__)) ;
#line 288
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_destroy)(pthread_attr_t *__attr )  __attribute__((__nothrow__)) ;
#line 292
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getdetachstate)(pthread_attr_t const   *__attr ,
                                                                                      int *__detachstate )  __attribute__((__nothrow__)) ;
#line 297
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                    int __detachstate )  __attribute__((__nothrow__)) ;
#line 303
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getguardsize)(pthread_attr_t const   *__attr ,
                                                                                    size_t *__guardsize )  __attribute__((__nothrow__)) ;
#line 308
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setguardsize)(pthread_attr_t *__attr ,
                                                                                  size_t __guardsize )  __attribute__((__nothrow__)) ;
#line 314
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedparam)(pthread_attr_t const   *__attr ,
                                                                                     struct sched_param *__param )  __attribute__((__nothrow__)) ;
#line 319
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_setschedparam)(pthread_attr_t *__attr ,
                                                                                     struct sched_param  const  *__param )  __attribute__((__nothrow__)) ;
#line 324
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedpolicy)(pthread_attr_t const   *__attr ,
                                                                                      int *__policy )  __attribute__((__nothrow__)) ;
#line 329
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setschedpolicy)(pthread_attr_t *__attr ,
                                                                                    int __policy )  __attribute__((__nothrow__)) ;
#line 333
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getinheritsched)(pthread_attr_t const   *__attr ,
                                                                                       int *__inherit )  __attribute__((__nothrow__)) ;
#line 338
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setinheritsched)(pthread_attr_t *__attr ,
                                                                                     int __inherit )  __attribute__((__nothrow__)) ;
#line 344
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getscope)(pthread_attr_t const   *__attr ,
                                                                                int *__scope )  __attribute__((__nothrow__)) ;
#line 349
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setscope)(pthread_attr_t *__attr ,
                                                                              int __scope )  __attribute__((__nothrow__)) ;
#line 353
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getstackaddr)(pthread_attr_t const   *__attr ,
                                                                                    void **__stackaddr )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 361
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstackaddr)(pthread_attr_t *__attr ,
                                                                                  void *__stackaddr )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 366
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getstacksize)(pthread_attr_t const   *__attr ,
                                                                                    size_t *__stacksize )  __attribute__((__nothrow__)) ;
#line 373
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstacksize)(pthread_attr_t *__attr ,
                                                                                  size_t __stacksize )  __attribute__((__nothrow__)) ;
#line 379
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) pthread_attr_getstack)(pthread_attr_t const   *__attr ,
                                                                                  void **__stackaddr ,
                                                                                  size_t *__stacksize )  __attribute__((__nothrow__)) ;
#line 387
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstack)(pthread_attr_t *__attr ,
                                                                              void *__stackaddr ,
                                                                              size_t __stacksize )  __attribute__((__nothrow__)) ;
#line 394
extern int ( __attribute__((__nonnull__(1,3), __leaf__)) pthread_attr_setaffinity_np)(pthread_attr_t *__attr ,
                                                                                      size_t __cpusetsize ,
                                                                                      cpu_set_t const   *__cpuset )  __attribute__((__nothrow__)) ;
#line 401
extern int ( __attribute__((__nonnull__(1,3), __leaf__)) pthread_attr_getaffinity_np)(pthread_attr_t const   *__attr ,
                                                                                      size_t __cpusetsize ,
                                                                                      cpu_set_t *__cpuset )  __attribute__((__nothrow__)) ;
#line 407
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_getattr_default_np)(pthread_attr_t *__attr )  __attribute__((__nothrow__)) ;
#line 411
extern int pthread_attr_setsigmask_np(pthread_attr_t *__attr , __sigset_t const   *sigmask ) ;
#line 417
extern int pthread_attr_getsigmask_np(pthread_attr_t const   *__attr , __sigset_t *sigmask ) ;
#line 426
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_setattr_default_np)(pthread_attr_t const   *__attr )  __attribute__((__nothrow__)) ;
#line 432
extern int ( __attribute__((__nonnull__(2), __leaf__)) pthread_getattr_np)(pthread_t __th ,
                                                                           pthread_attr_t *__attr )  __attribute__((__nothrow__)) ;
#line 441
extern int ( __attribute__((__nonnull__(3), __leaf__)) pthread_setschedparam)(pthread_t __target_thread ,
                                                                              int __policy ,
                                                                              struct sched_param  const  *__param )  __attribute__((__nothrow__)) ;
#line 446
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) pthread_getschedparam)(pthread_t __target_thread ,
                                                                                int *__policy ,
                                                                                struct sched_param *__param )  __attribute__((__nothrow__)) ;
#line 452
extern int ( __attribute__((__leaf__)) pthread_setschedprio)(pthread_t __target_thread ,
                                                             int __prio )  __attribute__((__nothrow__)) ;
#line 458
extern int ( __attribute__((__nonnull__(2), __leaf__)) pthread_getname_np)(pthread_t __target_thread ,
                                                                           char *__buf ,
                                                                           size_t __buflen )  __attribute__((__nothrow__)) ;
#line 463
extern int ( __attribute__((__nonnull__(2), __leaf__)) pthread_setname_np)(pthread_t __target_thread ,
                                                                           char const   *__name )  __attribute__((__nothrow__)) ;
#line 470
extern int ( __attribute__((__leaf__)) pthread_getconcurrency)(void)  __attribute__((__nothrow__)) ;
#line 473
extern int ( __attribute__((__leaf__)) pthread_setconcurrency)(int __level )  __attribute__((__nothrow__)) ;
#line 477
extern int ( __attribute__((__leaf__)) pthread_yield)(void)  __asm__("sched_yield") __attribute__((__nothrow__,
__deprecated__("pthread_yield is deprecated, use sched_yield instead"))) ;
#line 489
extern int ( __attribute__((__nonnull__(3), __leaf__)) pthread_setaffinity_np)(pthread_t __th ,
                                                                               size_t __cpusetsize ,
                                                                               cpu_set_t const   *__cpuset )  __attribute__((__nothrow__)) ;
#line 494
extern int ( __attribute__((__nonnull__(3), __leaf__)) pthread_getaffinity_np)(pthread_t __th ,
                                                                               size_t __cpusetsize ,
                                                                               cpu_set_t *__cpuset )  __attribute__((__nothrow__)) ;
#line 509
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) )  __attribute__((__goblint_stub__)) ;
#line 521
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 525
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 528
extern int pthread_cancel(pthread_t __th ) ;
#line 533
extern void pthread_testcancel(void) ;
#line 697
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 732
extern void __pthread_register_cancel_defer(__pthread_unwind_buf_t *__buf ) ;
#line 745
extern void __pthread_unregister_cancel_restore(__pthread_unwind_buf_t *__buf ) ;
#line 750
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__,
__noreturn__)) ;
#line 766
extern int __sigsetjmp_cancel(struct __cancel_jmp_buf_tag *__env , int __savemask )  __asm__("__sigsetjmp") __attribute__((__returns_twice__,
__nothrow__)) ;
#line 781
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                           pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nothrow__)) ;
#line 786
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 790
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 794
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 800
extern int ( __attribute__((__nonnull__(1,2))) pthread_mutex_timedlock)(pthread_mutex_t *__mutex ,
                                                                        struct timespec  const  *__abstime )  __attribute__((__nothrow__)) ;
#line 817
extern int ( __attribute__((__nonnull__(1,3))) pthread_mutex_clocklock)(pthread_mutex_t * __restrict  __mutex ,
                                                                        clockid_t __clockid ,
                                                                        struct timespec  const  * __restrict  __abstime )  __attribute__((__nothrow__)) ;
#line 835
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 840
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutex_getprioceiling)(pthread_mutex_t const   *__mutex ,
                                                                                       int *__prioceiling )  __attribute__((__nothrow__)) ;
#line 847
extern int ( __attribute__((__nonnull__(1,3), __leaf__)) pthread_mutex_setprioceiling)(pthread_mutex_t *__mutex ,
                                                                                       int __prioceiling ,
                                                                                       int *__old_ceiling )  __attribute__((__nothrow__)) ;
#line 855
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_consistent)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 859
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_consistent_np)(pthread_mutex_t * )  __asm__("pthread_mutex_consistent") __attribute__((__nothrow__,
__deprecated__("pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent"))) ;
#line 874
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_init)(pthread_mutexattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 878
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 882
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getpshared)(pthread_mutexattr_t const   *__attr ,
                                                                                       int *__pshared )  __attribute__((__nothrow__)) ;
#line 888
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setpshared)(pthread_mutexattr_t *__attr ,
                                                                                     int __pshared )  __attribute__((__nothrow__)) ;
#line 894
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_gettype)(pthread_mutexattr_t const   *__attr ,
                                                                                    int *__kind )  __attribute__((__nothrow__)) ;
#line 901
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                  int __kind )  __attribute__((__nothrow__)) ;
#line 906
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getprotocol)(pthread_mutexattr_t const   *__attr ,
                                                                                        int *__protocol )  __attribute__((__nothrow__)) ;
#line 913
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setprotocol)(pthread_mutexattr_t *__attr ,
                                                                                      int __protocol )  __attribute__((__nothrow__)) ;
#line 918
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getprioceiling)(pthread_mutexattr_t const   *__attr ,
                                                                                           int *__prioceiling )  __attribute__((__nothrow__)) ;
#line 924
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setprioceiling)(pthread_mutexattr_t *__attr ,
                                                                                         int __prioceiling )  __attribute__((__nothrow__)) ;
#line 930
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getrobust)(pthread_mutexattr_t const   *__attr ,
                                                                                      int *__robustness )  __attribute__((__nothrow__)) ;
#line 935
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_getrobust_np)(pthread_mutexattr_t * ,
                                                                                       int * )  __asm__("pthread_mutexattr_getrobust") __attribute__((__nothrow__,
__deprecated__("pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust"))) ;
#line 946
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setrobust)(pthread_mutexattr_t *__attr ,
                                                                                    int __robustness )  __attribute__((__nothrow__)) ;
#line 951
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setrobust_np)(pthread_mutexattr_t * ,
                                                                                       int  )  __asm__("pthread_mutexattr_setrobust") __attribute__((__nothrow__,
__deprecated__("pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust"))) ;
#line 967
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_init)(pthread_rwlock_t *__rwlock ,
                                                                            pthread_rwlockattr_t const   *__attr )  __attribute__((__nothrow__)) ;
#line 972
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_destroy)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 976
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_rdlock)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 980
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_tryrdlock)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 986
extern int ( __attribute__((__nonnull__(1,2))) pthread_rwlock_timedrdlock)(pthread_rwlock_t *__rwlock ,
                                                                           struct timespec  const  *__abstime )  __attribute__((__nothrow__)) ;
#line 1004
extern int ( __attribute__((__nonnull__(1,3))) pthread_rwlock_clockrdlock)(pthread_rwlock_t * __restrict  __rwlock ,
                                                                           clockid_t __clockid ,
                                                                           struct timespec  const  * __restrict  __abstime )  __attribute__((__nothrow__)) ;
#line 1023
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_wrlock)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 1027
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_trywrlock)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 1033
extern int ( __attribute__((__nonnull__(1,2))) pthread_rwlock_timedwrlock)(pthread_rwlock_t *__rwlock ,
                                                                           struct timespec  const  *__abstime )  __attribute__((__nothrow__)) ;
#line 1051
extern int ( __attribute__((__nonnull__(1,3))) pthread_rwlock_clockwrlock)(pthread_rwlock_t * __restrict  __rwlock ,
                                                                           clockid_t __clockid ,
                                                                           struct timespec  const  * __restrict  __abstime )  __attribute__((__nothrow__)) ;
#line 1071
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_unlock)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 1078
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_init)(pthread_rwlockattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1082
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_destroy)(pthread_rwlockattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1086
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_rwlockattr_getpshared)(pthread_rwlockattr_t const   *__attr ,
                                                                                        int *__pshared )  __attribute__((__nothrow__)) ;
#line 1092
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setpshared)(pthread_rwlockattr_t *__attr ,
                                                                                      int __pshared )  __attribute__((__nothrow__)) ;
#line 1097
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_rwlockattr_getkind_np)(pthread_rwlockattr_t const   *__attr ,
                                                                                        int *__pref )  __attribute__((__nothrow__)) ;
#line 1103
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setkind_np)(pthread_rwlockattr_t *__attr ,
                                                                                      int __pref )  __attribute__((__nothrow__)) ;
#line 1112
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t *__cond ,
                                                                          pthread_condattr_t const   *__cond_attr )  __attribute__((__nothrow__)) ;
#line 1117
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 1121
extern int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 1125
extern int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 1133
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t *__cond ,
                                                                  pthread_mutex_t *__mutex ) ;
#line 1145
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t *__cond ,
                                                                         pthread_mutex_t *__mutex ,
                                                                         struct timespec  const  *__abstime ) ;
#line 1171
extern int ( __attribute__((__nonnull__(1,2,4))) pthread_cond_clockwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         __clockid_t __clock_id ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
#line 1194
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_init)(pthread_condattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1198
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_destroy)(pthread_condattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1202
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_condattr_getpshared)(pthread_condattr_t const   *__attr ,
                                                                                      int *__pshared )  __attribute__((__nothrow__)) ;
#line 1208
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_setpshared)(pthread_condattr_t *__attr ,
                                                                                    int __pshared )  __attribute__((__nothrow__)) ;
#line 1213
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_condattr_getclock)(pthread_condattr_t const   *__attr ,
                                                                                    __clockid_t *__clock_id )  __attribute__((__nothrow__)) ;
#line 1219
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_setclock)(pthread_condattr_t *__attr ,
                                                                                  __clockid_t __clock_id )  __attribute__((__nothrow__)) ;
#line 1230
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_spin_init)(pthread_spinlock_t *__lock ,
                                                                          int __pshared )  __attribute__((__nothrow__)) ;
#line 1234
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_spin_destroy)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1238
extern int ( __attribute__((__nonnull__(1))) pthread_spin_lock)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1242
extern int ( __attribute__((__nonnull__(1))) pthread_spin_trylock)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1246
extern int ( __attribute__((__nonnull__(1))) pthread_spin_unlock)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1254
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrier_init)(pthread_barrier_t *__barrier ,
                                                                             pthread_barrierattr_t const   *__attr ,
                                                                             unsigned int __count )  __attribute__((__nothrow__)) ;
#line 1260
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrier_destroy)(pthread_barrier_t *__barrier )  __attribute__((__nothrow__)) ;
#line 1264
extern int ( __attribute__((__nonnull__(1))) pthread_barrier_wait)(pthread_barrier_t *__barrier )  __attribute__((__nothrow__)) ;
#line 1269
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_init)(pthread_barrierattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1273
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_destroy)(pthread_barrierattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1277
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_barrierattr_getpshared)(pthread_barrierattr_t const   *__attr ,
                                                                                         int *__pshared )  __attribute__((__nothrow__)) ;
#line 1283
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_setpshared)(pthread_barrierattr_t *__attr ,
                                                                                       int __pshared )  __attribute__((__nothrow__)) ;
#line 1297
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_key_create)(pthread_key_t *__key ,
                                                                           void (*__destr_function)(void * ) )  __attribute__((__nothrow__)) ;
#line 1302
extern int ( __attribute__((__leaf__)) pthread_key_delete)(pthread_key_t __key )  __attribute__((__nothrow__)) ;
#line 1305
extern void *( __attribute__((__leaf__)) pthread_getspecific)(pthread_key_t __key )  __attribute__((__nothrow__)) ;
#line 1308
extern int ( __attribute__((__leaf__)) pthread_setspecific)(pthread_key_t __key ,
                                                            void const   *__pointer )  __attribute__((__nothrow__,
__access__(__none__,2))) ;
#line 1315
extern int ( __attribute__((__nonnull__(2), __leaf__)) pthread_getcpuclockid)(pthread_t __thread_id ,
                                                                              __clockid_t *__clock_id )  __attribute__((__nothrow__)) ;
#line 1332
extern int ( __attribute__((__leaf__)) pthread_atfork)(void (*__prepare)(void) , void (*__parent)(void) ,
                                                       void (*__child)(void) )  __attribute__((__nothrow__)) ;
#line 1339
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal___0)(pthread_t __thread1 ,
                                                                                   pthread_t __thread2 )  __attribute__((__nothrow__,
__const__)) ;
#line 1339 "/usr/include/pthread.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal___0)(pthread_t __thread1 ,
                                                                                   pthread_t __thread2 ) 
{ 


  {
#line 1342
  return (__thread1 == __thread2);
}
}
#line 287 "/usr/include/unistd.h"
extern int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                               int __type )  __attribute__((__nothrow__)) ;
#line 292
extern int ( __attribute__((__nonnull__(1), __leaf__)) euidaccess)(char const   *__name ,
                                                                   int __type )  __attribute__((__nothrow__)) ;
#line 296
extern int ( __attribute__((__nonnull__(1), __leaf__)) eaccess)(char const   *__name ,
                                                                int __type )  __attribute__((__nothrow__)) ;
#line 300
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) execveat)(int __fd , char const   *__path ,
                                                                   char **__argv ,
                                                                   char **__envp ,
                                                                   int __flags )  __attribute__((__nothrow__)) ;
#line 309
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__)) faccessat)(int __fd ,
                                                                                          char const   *__file ,
                                                                                          int __type ,
                                                                                          int __flag )  __attribute__((__nothrow__)) ;
#line 339
extern __off_t ( __attribute__((__leaf__)) lseek)(int __fd , __off_t __offset , int __whence )  __attribute__((__nothrow__)) ;
#line 350
extern __off64_t ( __attribute__((__leaf__)) lseek64)(int __fd , __off64_t __offset ,
                                                      int __whence )  __attribute__((__nothrow__)) ;
#line 358
extern int close(int __fd ) ;
#line 363
extern void ( __attribute__((__leaf__)) closefrom)(int __lowfd )  __attribute__((__nothrow__)) ;
#line 371
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 378
extern ssize_t ( __attribute__((__warn_unused_result__)) write)(int __fd , void const   *__buf ,
                                                                size_t __n )  __attribute__((__access__(__read_only__,2,3))) ;
#line 389
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread)(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 398
extern ssize_t ( __attribute__((__warn_unused_result__)) pwrite)(int __fd , void const   *__buf ,
                                                                 size_t __n , __off_t __offset )  __attribute__((__access__(__read_only__,2,3))) ;
#line 422
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread64)(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) ;
#line 427
extern ssize_t ( __attribute__((__warn_unused_result__)) pwrite64)(int __fd , void const   *__buf ,
                                                                   size_t __n , __off64_t __offset )  __attribute__((__access__(__read_only__,2,3))) ;
#line 437
extern int ( __attribute__((__warn_unused_result__, __leaf__)) pipe)(int *__pipedes )  __attribute__((__nothrow__)) ;
#line 442
extern int ( __attribute__((__warn_unused_result__, __leaf__)) pipe2)(int *__pipedes ,
                                                                      int __flags )  __attribute__((__nothrow__)) ;
#line 452
extern unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds )  __attribute__((__nothrow__)) ;
#line 464
extern unsigned int sleep(unsigned int __seconds ) ;
#line 472
extern __useconds_t ( __attribute__((__leaf__)) ualarm)(__useconds_t __value , __useconds_t __interval )  __attribute__((__nothrow__)) ;
#line 480
extern int usleep(__useconds_t __useconds ) ;
#line 489
extern int pause(void) ;
#line 493
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                      __uid_t __owner ,
                                                                                      __gid_t __group )  __attribute__((__nothrow__)) ;
#line 498
extern int ( __attribute__((__warn_unused_result__, __leaf__)) fchown)(int __fd ,
                                                                       __uid_t __owner ,
                                                                       __gid_t __group )  __attribute__((__nothrow__)) ;
#line 503
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) lchown)(char const   *__file ,
                                                                                       __uid_t __owner ,
                                                                                       __gid_t __group )  __attribute__((__nothrow__)) ;
#line 511
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__)) fchownat)(int __fd ,
                                                                                         char const   *__file ,
                                                                                         __uid_t __owner ,
                                                                                         __gid_t __group ,
                                                                                         int __flag )  __attribute__((__nothrow__)) ;
#line 517
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) chdir)(char const   *__path )  __attribute__((__nothrow__)) ;
#line 521
extern int ( __attribute__((__warn_unused_result__, __leaf__)) fchdir)(int __fd )  __attribute__((__nothrow__)) ;
#line 531
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 537
extern char *( __attribute__((__leaf__)) get_current_dir_name)(void)  __attribute__((__nothrow__)) ;
#line 545
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__nothrow__,
__deprecated__, __access__(__write_only__,1))) ;
#line 552
extern int ( __attribute__((__warn_unused_result__, __leaf__)) dup)(int __fd )  __attribute__((__nothrow__)) ;
#line 555
extern int ( __attribute__((__leaf__)) dup2)(int __fd , int __fd2 )  __attribute__((__nothrow__)) ;
#line 560
extern int ( __attribute__((__leaf__)) dup3)(int __fd , int __fd2 , int __flags )  __attribute__((__nothrow__)) ;
#line 564
extern char **__environ ;
#line 566
extern char **environ ;
#line 572
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                 char **__argv , char **__envp )  __attribute__((__nothrow__)) ;
#line 578
extern int ( __attribute__((__nonnull__(2), __leaf__)) fexecve)(int __fd , char **__argv ,
                                                                char **__envp )  __attribute__((__nothrow__)) ;
#line 584
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                char **__argv )  __attribute__((__nothrow__)) ;
#line 589
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *__path ,
                                                                 char const   *__arg 
                                                                 , ...)  __attribute__((__nothrow__)) ;
#line 594
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                char const   *__arg 
                                                                , ...)  __attribute__((__nothrow__)) ;
#line 599
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                 char **__argv )  __attribute__((__nothrow__)) ;
#line 605
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                 char const   *__arg 
                                                                 , ...)  __attribute__((__nothrow__)) ;
#line 611
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execvpe)(char const   *__file ,
                                                                  char **__argv ,
                                                                  char **__envp )  __attribute__((__nothrow__)) ;
#line 619
extern int ( __attribute__((__warn_unused_result__, __leaf__)) nice)(int __inc )  __attribute__((__nothrow__)) ;
#line 624
extern void _exit(int __status )  __attribute__((__noreturn__)) ;
#line 633
extern long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                  int __name )  __attribute__((__nothrow__)) ;
#line 637
extern long ( __attribute__((__leaf__)) fpathconf)(int __fd , int __name )  __attribute__((__nothrow__)) ;
#line 640
extern long ( __attribute__((__leaf__)) sysconf)(int __name )  __attribute__((__nothrow__)) ;
#line 644
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len )  __attribute__((__nothrow__)) ;
#line 650
extern __pid_t ( __attribute__((__leaf__)) getpid)(void)  __attribute__((__nothrow__)) ;
#line 653
extern __pid_t ( __attribute__((__leaf__)) getppid)(void)  __attribute__((__nothrow__)) ;
#line 656
extern __pid_t ( __attribute__((__leaf__)) getpgrp)(void)  __attribute__((__nothrow__)) ;
#line 659
extern __pid_t ( __attribute__((__leaf__)) __getpgid)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 661
extern __pid_t ( __attribute__((__leaf__)) getpgid)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 668
extern int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid , __pid_t __pgid )  __attribute__((__nothrow__)) ;
#line 682
extern int ( __attribute__((__leaf__)) setpgrp)(void)  __attribute__((__nothrow__)) ;
#line 689
extern __pid_t ( __attribute__((__leaf__)) setsid)(void)  __attribute__((__nothrow__)) ;
#line 693
extern __pid_t ( __attribute__((__leaf__)) getsid)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 697
extern __uid_t ( __attribute__((__leaf__)) getuid)(void)  __attribute__((__nothrow__)) ;
#line 700
extern __uid_t ( __attribute__((__leaf__)) geteuid)(void)  __attribute__((__nothrow__)) ;
#line 703
extern __gid_t ( __attribute__((__leaf__)) getgid)(void)  __attribute__((__nothrow__)) ;
#line 706
extern __gid_t ( __attribute__((__leaf__)) getegid)(void)  __attribute__((__nothrow__)) ;
#line 711
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 715
extern int ( __attribute__((__leaf__)) group_member)(__gid_t __gid )  __attribute__((__nothrow__)) ;
#line 722
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setuid)(__uid_t __uid )  __attribute__((__nothrow__)) ;
#line 727
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setreuid)(__uid_t __ruid ,
                                                                         __uid_t __euid )  __attribute__((__nothrow__)) ;
#line 732
extern int ( __attribute__((__warn_unused_result__, __leaf__)) seteuid)(__uid_t __uid )  __attribute__((__nothrow__)) ;
#line 739
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setgid)(__gid_t __gid )  __attribute__((__nothrow__)) ;
#line 744
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setregid)(__gid_t __rgid ,
                                                                         __gid_t __egid )  __attribute__((__nothrow__)) ;
#line 749
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setegid)(__gid_t __gid )  __attribute__((__nothrow__)) ;
#line 755
extern int ( __attribute__((__leaf__)) getresuid)(__uid_t *__ruid , __uid_t *__euid ,
                                                  __uid_t *__suid )  __attribute__((__nothrow__)) ;
#line 760
extern int ( __attribute__((__leaf__)) getresgid)(__gid_t *__rgid , __gid_t *__egid ,
                                                  __gid_t *__sgid )  __attribute__((__nothrow__)) ;
#line 765
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setresuid)(__uid_t __ruid ,
                                                                          __uid_t __euid ,
                                                                          __uid_t __suid )  __attribute__((__nothrow__)) ;
#line 770
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setresgid)(__gid_t __rgid ,
                                                                          __gid_t __egid ,
                                                                          __gid_t __sgid )  __attribute__((__nothrow__)) ;
#line 778
extern __pid_t fork(void)  __attribute__((__nothrow__)) ;
#line 786
extern __pid_t ( __attribute__((__leaf__)) vfork)(void)  __attribute__((__nothrow__)) ;
#line 793
extern __pid_t ( __attribute__((__leaf__)) _Fork)(void)  __attribute__((__nothrow__)) ;
#line 799
extern char *( __attribute__((__leaf__)) ttyname)(int __fd )  __attribute__((__nothrow__)) ;
#line 803
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 809
extern int ( __attribute__((__leaf__)) isatty)(int __fd )  __attribute__((__nothrow__)) ;
#line 814
extern int ( __attribute__((__leaf__)) ttyslot)(void)  __attribute__((__nothrow__)) ;
#line 819
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                       char const   *__to )  __attribute__((__nothrow__)) ;
#line 825
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2,4), __leaf__)) linkat)(int __fromfd ,
                                                                                         char const   *__from ,
                                                                                         int __tofd ,
                                                                                         char const   *__to ,
                                                                                         int __flags )  __attribute__((__nothrow__)) ;
#line 832
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                          char const   *__to )  __attribute__((__nothrow__)) ;
#line 838
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   *__path ,
                                                                        char *__buf ,
                                                                        size_t __len )  __attribute__((__nothrow__)) ;
#line 847
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,3), __leaf__)) symlinkat)(char const   *__from ,
                                                                                            int __tofd ,
                                                                                            char const   *__to )  __attribute__((__nothrow__)) ;
#line 851
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                          char const   *__path ,
                                                                          char *__buf ,
                                                                          size_t __len )  __attribute__((__nothrow__)) ;
#line 858
extern int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 862
extern int ( __attribute__((__nonnull__(2), __leaf__)) unlinkat)(int __fd , char const   *__name ,
                                                                 int __flag )  __attribute__((__nothrow__)) ;
#line 867
extern int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path )  __attribute__((__nothrow__)) ;
#line 871
extern __pid_t ( __attribute__((__leaf__)) tcgetpgrp)(int __fd )  __attribute__((__nothrow__)) ;
#line 874
extern int ( __attribute__((__leaf__)) tcsetpgrp)(int __fd , __pid_t __pgrp_id )  __attribute__((__nothrow__)) ;
#line 881
extern char *getlogin(void) ;
#line 889
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) getlogin_r)(char *__buf , size_t __buflen ) ;
#line 895
extern int ( __attribute__((__nonnull__(1), __leaf__)) setlogin)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt)(int ___argc , char **___argv ,
                                                                 char const   *__shortopts )  __attribute__((__nothrow__)) ;
#line 911 "/usr/include/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) gethostname)(char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 919
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) sethostname)(char const   *__name ,
                                                                                            size_t __len )  __attribute__((__nothrow__,
__access__(__read_only__,1,2))) ;
#line 924
extern int ( __attribute__((__warn_unused_result__, __leaf__)) sethostid)(long __id )  __attribute__((__nothrow__)) ;
#line 930
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 933
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) setdomainname)(char const   *__name ,
                                                                                              size_t __len )  __attribute__((__nothrow__,
__access__(__read_only__,1,2))) ;
#line 939
extern int ( __attribute__((__leaf__)) vhangup)(void)  __attribute__((__nothrow__)) ;
#line 942
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) revoke)(char const   *__file )  __attribute__((__nothrow__)) ;
#line 950
extern int ( __attribute__((__nonnull__(1), __leaf__)) profil)(unsigned short *__sample_buffer ,
                                                               size_t __size , size_t __offset ,
                                                               unsigned int __scale )  __attribute__((__nothrow__)) ;
#line 958
extern int ( __attribute__((__leaf__)) acct)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 962
extern char *( __attribute__((__leaf__)) getusershell)(void)  __attribute__((__nothrow__)) ;
#line 963
extern void ( __attribute__((__leaf__)) endusershell)(void)  __attribute__((__nothrow__)) ;
#line 964
extern void ( __attribute__((__leaf__)) setusershell)(void)  __attribute__((__nothrow__)) ;
#line 970
extern int ( __attribute__((__warn_unused_result__, __leaf__)) daemon)(int __nochdir ,
                                                                       int __noclose )  __attribute__((__nothrow__)) ;
#line 977
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) chroot)(char const   *__path )  __attribute__((__nothrow__)) ;
#line 981
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 989
extern int fsync(int __fd ) ;
#line 995
extern int ( __attribute__((__leaf__)) syncfs)(int __fd )  __attribute__((__nothrow__)) ;
#line 1002
extern long gethostid(void) ;
#line 1005
extern void ( __attribute__((__leaf__)) sync)(void)  __attribute__((__nothrow__)) ;
#line 1011
extern int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 1016
extern int ( __attribute__((__leaf__)) getdtablesize)(void)  __attribute__((__nothrow__)) ;
#line 1026
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) truncate)(char const   *__file ,
                                                                                         __off_t __length )  __attribute__((__nothrow__)) ;
#line 1038
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) truncate64)(char const   *__file ,
                                                                                           __off64_t __length )  __attribute__((__nothrow__)) ;
#line 1049
extern int ( __attribute__((__warn_unused_result__, __leaf__)) ftruncate)(int __fd ,
                                                                          __off_t __length )  __attribute__((__nothrow__)) ;
#line 1059
extern int ( __attribute__((__warn_unused_result__, __leaf__)) ftruncate64)(int __fd ,
                                                                            __off64_t __length )  __attribute__((__nothrow__)) ;
#line 1070
extern int ( __attribute__((__warn_unused_result__, __leaf__)) brk)(void *__addr )  __attribute__((__nothrow__)) ;
#line 1076
extern void *( __attribute__((__leaf__)) sbrk)(intptr_t __delta )  __attribute__((__nothrow__)) ;
#line 1091
extern long ( __attribute__((__leaf__)) syscall)(long __sysno  , ...)  __attribute__((__nothrow__)) ;
#line 1114
extern int ( __attribute__((__warn_unused_result__)) lockf)(int __fd , int __cmd ,
                                                            __off_t __len ) ;
#line 1124
extern int ( __attribute__((__warn_unused_result__)) lockf64)(int __fd , int __cmd ,
                                                              __off64_t __len ) ;
#line 1142
extern ssize_t copy_file_range(int __infd , __off64_t *__pinoff , int __outfd , __off64_t *__poutoff ,
                               size_t __length , unsigned int __flags ) ;
#line 1150
extern int fdatasync(int __fildes ) ;
#line 1162
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) crypt)(char const   *__key ,
                                                                  char const   *__salt )  __attribute__((__nothrow__)) ;
#line 1171
extern void ( __attribute__((__nonnull__(1,2), __leaf__)) swab)(void const   * __restrict  __from ,
                                                                void * __restrict  __to ,
                                                                ssize_t __n )  __attribute__((__nothrow__,
__access__(__write_only__,2,3), __access__(__read_only__,1,3))) ;
#line 1201
extern int ( __attribute__((__warn_unused_result__)) getentropy)(void *__buffer ,
                                                                 size_t __length )  __attribute__((__access__(__write_only__,1,2))) ;
#line 1211
extern int ( __attribute__((__leaf__)) close_range)(unsigned int __fd , unsigned int __max_fd ,
                                                    int __flags )  __attribute__((__nothrow__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/unistd-decl.h"
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen )  __attribute__((__access__(__write_only__,2,3))) ;
#line 29
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read") __attribute__((__access__(__write_only__,2,3))) ;
#line 32
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
#line 39
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk)(int __fd , void *__buf ,
                                                                      size_t __nbytes ,
                                                                      __off_t __offset ,
                                                                      size_t __bufsize )  __attribute__((__access__(__write_only__,2,3))) ;
#line 42
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off64_t __offset ,
                                                                        size_t __bufsize )  __attribute__((__access__(__write_only__,2,3))) ;
#line 45
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_alias)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off_t __offset )  __asm__("pread") __attribute__((__access__(__write_only__,2,3))) ;
#line 49
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_alias)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          __off64_t __offset )  __asm__("pread64") __attribute__((__access__(__write_only__,2,3))) ;
#line 53
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk_warn)(int __fd ,
                                                                           void *__buf ,
                                                                           size_t __nbytes ,
                                                                           __off_t __offset ,
                                                                           size_t __bufsize )  __asm__("__pread_chk") __attribute__((__warning__("pread called with bigger length than size of the destination buffer"))) ;
#line 58
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk_warn)(int __fd ,
                                                                             void *__buf ,
                                                                             size_t __nbytes ,
                                                                             __off64_t __offset ,
                                                                             size_t __bufsize )  __asm__("__pread64_chk") __attribute__((__warning__("pread64 called with bigger length than size of the destination buffer"))) ;
#line 67
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) __readlink_chk)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ,
                                                                                                     size_t __buflen )  __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 71
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) __readlink_alias)(char const   * __restrict  __path ,
                                                                                                       char * __restrict  __buf ,
                                                                                                       size_t __len )  __asm__("readlink") __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 75
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) __readlink_chk_warn)(char const   * __restrict  __path ,
                                                                                                          char * __restrict  __buf ,
                                                                                                          size_t __len ,
                                                                                                          size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"),
__nothrow__)) ;
#line 84
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3), __leaf__)) __readlinkat_chk)(int __fd ,
                                                                                                       char const   * __restrict  __path ,
                                                                                                       char * __restrict  __buf ,
                                                                                                       size_t __len ,
                                                                                                       size_t __buflen )  __attribute__((__nothrow__,
__access__(__write_only__,3,4))) ;
#line 88
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3), __leaf__)) __readlinkat_alias)(int __fd ,
                                                                                                         char const   * __restrict  __path ,
                                                                                                         char * __restrict  __buf ,
                                                                                                         size_t __len )  __asm__("readlinkat") __attribute__((__nothrow__,
__access__(__write_only__,3,4))) ;
#line 93
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3), __leaf__)) __readlinkat_chk_warn)(int __fd ,
                                                                                                            char const   * __restrict  __path ,
                                                                                                            char * __restrict  __buf ,
                                                                                                            size_t __len ,
                                                                                                            size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"),
__nothrow__)) ;
#line 102
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __getcwd_chk)(char *__buf ,
                                                                               size_t __size ,
                                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 104
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __getcwd_alias)(char *__buf ,
                                                                                 size_t __size )  __asm__("getcwd") __attribute__((__nothrow__)) ;
#line 106
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __getcwd_chk_warn)(char *__buf ,
                                                                                    size_t __size ,
                                                                                    size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"),
__nothrow__)) ;
#line 113
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getwd_chk)(char *__buf ,
                                                                                              size_t buflen )  __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
#line 115
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getwd_warn)(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"),
__nothrow__)) ;
#line 120
extern size_t ( __attribute__((__leaf__)) __confstr_chk)(int __name , char *__buf ,
                                                         size_t __len , size_t __buflen )  __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 123
extern size_t ( __attribute__((__leaf__)) __confstr_alias)(int __name , char *__buf ,
                                                           size_t __len )  __asm__("confstr") __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 126
extern size_t ( __attribute__((__leaf__)) __confstr_chk_warn)(int __name , char *__buf ,
                                                              size_t __len , size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"),
__nothrow__)) ;
#line 133
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __getgroups_chk)(int __size ,
                                                                                __gid_t *__list ,
                                                                                size_t __listlen )  __attribute__((__nothrow__,
__access__(__write_only__,2,1))) ;
#line 135
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __getgroups_alias)(int __size ,
                                                                                  __gid_t *__list )  __asm__("getgroups") __attribute__((__nothrow__,
__access__(__write_only__,2,1))) ;
#line 137
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __getgroups_chk_warn)(int __size ,
                                                                                     __gid_t *__list ,
                                                                                     size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"),
__nothrow__)) ;
#line 144
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk)(int __fd ,
                                                                        char *__buf ,
                                                                        size_t __buflen ,
                                                                        size_t __nreal )  __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 147
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_alias)(int __fd ,
                                                                          char *__buf ,
                                                                          size_t __buflen )  __asm__("ttyname_r") __attribute__((__nothrow__)) ;
#line 150
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk_warn)(int __fd ,
                                                                             char *__buf ,
                                                                             size_t __buflen ,
                                                                             size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
#line 158
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal )  __attribute__((__access__(__write_only__,1,2))) ;
#line 160
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
#line 162
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
#line 171
extern int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk)(char *__buf ,
                                                                          size_t __buflen ,
                                                                          size_t __nreal )  __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
#line 173
extern int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_alias)(char *__buf ,
                                                                            size_t __buflen )  __asm__("gethostname") __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
#line 176
extern int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk_warn)(char *__buf ,
                                                                               size_t __buflen ,
                                                                               size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
#line 185
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getdomainname_chk)(char *__buf ,
                                                                                                    size_t __buflen ,
                                                                                                    size_t __nreal )  __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
#line 187
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getdomainname_alias)(char *__buf ,
                                                                                                      size_t __buflen )  __asm__("getdomainname") __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
#line 191
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getdomainname_chk_warn)(char *__buf ,
                                                                                                         size_t __buflen ,
                                                                                                         size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
#line 32 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern int ( /* missing proto */  __builtin_dynamic_object_size)() ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  ssize_t tmp___9 ;
  ssize_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  ssize_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 32
  if (0) {
#line 32
    tmp___15 = __builtin_dynamic_object_size(__buf, 0);
#line 32
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 32
      goto _L___3;
    } else {
#line 32
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 32
  if (1) {
#line 32
    goto _L___6;
  } else
#line 32
  if (0) {
#line 32
    if (__nbytes > 0UL) {
      _L___6: /* CIL Label */ 
#line 32
      if (0) {
#line 32
        tmp___17 = __builtin_dynamic_object_size(__buf, 0);
#line 32
        if (__nbytes <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 32
          tmp___3 = __read_alias(__fd, __buf, __nbytes);
#line 32
          tmp___13 = tmp___3;
        } else {
#line 32
          goto _L___7;
        }
      } else {
#line 32
        goto _L___7;
      }
    } else {
#line 32
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 32
    if (1) {
#line 32
      goto _L___1;
    } else
#line 32
    if (0) {
#line 32
      if (__nbytes > 0UL) {
        _L___1: /* CIL Label */ 
#line 32
        if (0) {
#line 32
          tmp___12 = __builtin_dynamic_object_size(__buf, 0);
#line 32
          if (__nbytes <= (unsigned long )tmp___12 / sizeof(char )) {
#line 32
            goto _L___2;
          } else {
#line 32
            tmp___6 = __builtin_dynamic_object_size(__buf, 0);
#line 32
            tmp___7 = __read_chk_warn(__fd, __buf, __nbytes, (size_t )tmp___6);
#line 32
            tmp___10 = tmp___7;
          }
        } else {
#line 32
          goto _L___2;
        }
      } else {
#line 32
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 32
      tmp___8 = __builtin_dynamic_object_size(__buf, 0);
#line 32
      tmp___9 = __read_chk(__fd, __buf, __nbytes, (size_t )tmp___8);
#line 32
      tmp___10 = tmp___9;
    }
#line 32
    tmp___13 = tmp___10;
  }
#line 32
  return (tmp___13);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread)(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  ssize_t tmp___9 ;
  ssize_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  ssize_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 46
  if (0) {
#line 46
    tmp___15 = __builtin_dynamic_object_size(__buf, 0);
#line 46
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 46
      goto _L___3;
    } else {
#line 46
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 46
  if (1) {
#line 46
    goto _L___6;
  } else
#line 46
  if (0) {
#line 46
    if (__nbytes > 0UL) {
      _L___6: /* CIL Label */ 
#line 46
      if (0) {
#line 46
        tmp___17 = __builtin_dynamic_object_size(__buf, 0);
#line 46
        if (__nbytes <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 46
          tmp___3 = __pread_alias(__fd, __buf, __nbytes, __offset);
#line 46
          tmp___13 = tmp___3;
        } else {
#line 46
          goto _L___7;
        }
      } else {
#line 46
        goto _L___7;
      }
    } else {
#line 46
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 46
    if (1) {
#line 46
      goto _L___1;
    } else
#line 46
    if (0) {
#line 46
      if (__nbytes > 0UL) {
        _L___1: /* CIL Label */ 
#line 46
        if (0) {
#line 46
          tmp___12 = __builtin_dynamic_object_size(__buf, 0);
#line 46
          if (__nbytes <= (unsigned long )tmp___12 / sizeof(char )) {
#line 46
            goto _L___2;
          } else {
#line 46
            tmp___6 = __builtin_dynamic_object_size(__buf, 0);
#line 46
            tmp___7 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, (size_t )tmp___6);
#line 46
            tmp___10 = tmp___7;
          }
        } else {
#line 46
          goto _L___2;
        }
      } else {
#line 46
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 46
      tmp___8 = __builtin_dynamic_object_size(__buf, 0);
#line 46
      tmp___9 = __pread_chk(__fd, __buf, __nbytes, __offset, (size_t )tmp___8);
#line 46
      tmp___10 = tmp___9;
    }
#line 46
    tmp___13 = tmp___10;
  }
#line 46
  return (tmp___13);
}
}
#line 65 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread64)(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  ssize_t tmp___9 ;
  ssize_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  ssize_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 72
  if (0) {
#line 72
    tmp___15 = __builtin_dynamic_object_size(__buf, 0);
#line 72
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 72
      goto _L___3;
    } else {
#line 72
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 72
  if (1) {
#line 72
    goto _L___6;
  } else
#line 72
  if (0) {
#line 72
    if (__nbytes > 0UL) {
      _L___6: /* CIL Label */ 
#line 72
      if (0) {
#line 72
        tmp___17 = __builtin_dynamic_object_size(__buf, 0);
#line 72
        if (__nbytes <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 72
          tmp___3 = __pread64_alias(__fd, __buf, __nbytes, __offset);
#line 72
          tmp___13 = tmp___3;
        } else {
#line 72
          goto _L___7;
        }
      } else {
#line 72
        goto _L___7;
      }
    } else {
#line 72
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 72
    if (1) {
#line 72
      goto _L___1;
    } else
#line 72
    if (0) {
#line 72
      if (__nbytes > 0UL) {
        _L___1: /* CIL Label */ 
#line 72
        if (0) {
#line 72
          tmp___12 = __builtin_dynamic_object_size(__buf, 0);
#line 72
          if (__nbytes <= (unsigned long )tmp___12 / sizeof(char )) {
#line 72
            goto _L___2;
          } else {
#line 72
            tmp___6 = __builtin_dynamic_object_size(__buf, 0);
#line 72
            tmp___7 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, (size_t )tmp___6);
#line 72
            tmp___10 = tmp___7;
          }
        } else {
#line 72
          goto _L___2;
        }
      } else {
#line 72
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 72
      tmp___8 = __builtin_dynamic_object_size(__buf, 0);
#line 72
      tmp___9 = __pread64_chk(__fd, __buf, __nbytes, __offset, (size_t )tmp___8);
#line 72
      tmp___10 = tmp___9;
    }
#line 72
    tmp___13 = tmp___10;
  }
#line 72
  return (tmp___13);
}
}
#line 80
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   *__path ,
                                                                        char *__buf ,
                                                                        size_t __len )  __attribute__((__nothrow__)) ;
#line 80 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   *__path ,
                                                                        char *__buf ,
                                                                        size_t __len ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  ssize_t tmp___9 ;
  ssize_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  ssize_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 89
  if (0) {
#line 89
    tmp___15 = __builtin_dynamic_object_size(__buf, 1);
#line 89
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 89
      goto _L___3;
    } else {
#line 89
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 89
  if (1) {
#line 89
    goto _L___6;
  } else
#line 89
  if (0) {
#line 89
    if (__len > 0UL) {
      _L___6: /* CIL Label */ 
#line 89
      if (0) {
#line 89
        tmp___17 = __builtin_dynamic_object_size(__buf, 1);
#line 89
        if (__len <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 89
          tmp___3 = __readlink_alias((char const   * __restrict  )__path, (char * __restrict  )__buf,
                                     __len);
#line 89
          tmp___13 = tmp___3;
        } else {
#line 89
          goto _L___7;
        }
      } else {
#line 89
        goto _L___7;
      }
    } else {
#line 89
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 89
    if (1) {
#line 89
      goto _L___1;
    } else
#line 89
    if (0) {
#line 89
      if (__len > 0UL) {
        _L___1: /* CIL Label */ 
#line 89
        if (0) {
#line 89
          tmp___12 = __builtin_dynamic_object_size(__buf, 1);
#line 89
          if (__len <= (unsigned long )tmp___12 / sizeof(char )) {
#line 89
            goto _L___2;
          } else {
#line 89
            tmp___6 = __builtin_dynamic_object_size(__buf, 1);
#line 89
            tmp___7 = __readlink_chk_warn((char const   * __restrict  )__path, (char * __restrict  )__buf,
                                          __len, (size_t )tmp___6);
#line 89
            tmp___10 = tmp___7;
          }
        } else {
#line 89
          goto _L___2;
        }
      } else {
#line 89
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 89
      tmp___8 = __builtin_dynamic_object_size(__buf, 1);
#line 89
      tmp___9 = __readlink_chk((char const   * __restrict  )__path, (char * __restrict  )__buf,
                               __len, (size_t )tmp___8);
#line 89
      tmp___10 = tmp___9;
    }
#line 89
    tmp___13 = tmp___10;
  }
#line 89
  return (tmp___13);
}
}
#line 96
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                          char const   *__path ,
                                                                          char *__buf ,
                                                                          size_t __len )  __attribute__((__nothrow__)) ;
#line 96 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                          char const   *__path ,
                                                                          char *__buf ,
                                                                          size_t __len ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  ssize_t tmp___9 ;
  ssize_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  ssize_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 104
  if (0) {
#line 104
    tmp___15 = __builtin_dynamic_object_size(__buf, 1);
#line 104
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 104
      goto _L___3;
    } else {
#line 104
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 104
  if (1) {
#line 104
    goto _L___6;
  } else
#line 104
  if (0) {
#line 104
    if (__len > 0UL) {
      _L___6: /* CIL Label */ 
#line 104
      if (0) {
#line 104
        tmp___17 = __builtin_dynamic_object_size(__buf, 1);
#line 104
        if (__len <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 104
          tmp___3 = __readlinkat_alias(__fd, (char const   * __restrict  )__path,
                                       (char * __restrict  )__buf, __len);
#line 104
          tmp___13 = tmp___3;
        } else {
#line 104
          goto _L___7;
        }
      } else {
#line 104
        goto _L___7;
      }
    } else {
#line 104
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 104
    if (1) {
#line 104
      goto _L___1;
    } else
#line 104
    if (0) {
#line 104
      if (__len > 0UL) {
        _L___1: /* CIL Label */ 
#line 104
        if (0) {
#line 104
          tmp___12 = __builtin_dynamic_object_size(__buf, 1);
#line 104
          if (__len <= (unsigned long )tmp___12 / sizeof(char )) {
#line 104
            goto _L___2;
          } else {
#line 104
            tmp___6 = __builtin_dynamic_object_size(__buf, 1);
#line 104
            tmp___7 = __readlinkat_chk_warn(__fd, (char const   * __restrict  )__path,
                                            (char * __restrict  )__buf, __len, (size_t )tmp___6);
#line 104
            tmp___10 = tmp___7;
          }
        } else {
#line 104
          goto _L___2;
        }
      } else {
#line 104
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 104
      tmp___8 = __builtin_dynamic_object_size(__buf, 1);
#line 104
      tmp___9 = __readlinkat_chk(__fd, (char const   * __restrict  )__path, (char * __restrict  )__buf,
                                 __len, (size_t )tmp___8);
#line 104
      tmp___10 = tmp___9;
    }
#line 104
    tmp___13 = tmp___10;
  }
#line 104
  return (tmp___13);
}
}
#line 110
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 110 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 116
  if (0) {
#line 116
    tmp___15 = __builtin_dynamic_object_size(__buf, 1);
#line 116
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 116
      goto _L___3;
    } else {
#line 116
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 116
  if (1) {
#line 116
    goto _L___6;
  } else
#line 116
  if (0) {
#line 116
    if (__size > 0UL) {
      _L___6: /* CIL Label */ 
#line 116
      if (0) {
#line 116
        tmp___17 = __builtin_dynamic_object_size(__buf, 1);
#line 116
        if (__size <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 116
          tmp___3 = __getcwd_alias(__buf, __size);
#line 116
          tmp___13 = tmp___3;
        } else {
#line 116
          goto _L___7;
        }
      } else {
#line 116
        goto _L___7;
      }
    } else {
#line 116
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 116
    if (1) {
#line 116
      goto _L___1;
    } else
#line 116
    if (0) {
#line 116
      if (__size > 0UL) {
        _L___1: /* CIL Label */ 
#line 116
        if (0) {
#line 116
          tmp___12 = __builtin_dynamic_object_size(__buf, 1);
#line 116
          if (__size <= (unsigned long )tmp___12 / sizeof(char )) {
#line 116
            goto _L___2;
          } else {
#line 116
            tmp___6 = __builtin_dynamic_object_size(__buf, 1);
#line 116
            tmp___7 = __getcwd_chk_warn(__buf, __size, (size_t )tmp___6);
#line 116
            tmp___10 = tmp___7;
          }
        } else {
#line 116
          goto _L___2;
        }
      } else {
#line 116
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 116
      tmp___8 = __builtin_dynamic_object_size(__buf, 1);
#line 116
      tmp___9 = __getcwd_chk(__buf, __size, (size_t )tmp___8);
#line 116
      tmp___10 = tmp___9;
    }
#line 116
    tmp___13 = tmp___10;
  }
#line 116
  return (tmp___13);
}
}
#line 122
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__nothrow__,
__deprecated__, __access__(__write_only__,1))) ;
#line 122 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 126
  tmp___1 = __builtin_dynamic_object_size(__buf, 1);
#line 126
  if ((size_t )tmp___1 != 18446744073709551615UL) {
#line 127
    tmp = __builtin_dynamic_object_size(__buf, 1);
#line 127
    tmp___0 = __getwd_chk(__buf, (size_t )tmp);
#line 127
    return ((char __attribute__((__deprecated__))  *)tmp___0);
  }
#line 128
  tmp___2 = __getwd_warn(__buf);
#line 128
  return ((char __attribute__((__deprecated__))  *)tmp___2);
}
}
#line 132
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len )  __attribute__((__nothrow__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 139
  if (0) {
#line 139
    tmp___15 = __builtin_dynamic_object_size(__buf, 1);
#line 139
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 139
      goto _L___3;
    } else {
#line 139
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 139
  if (1) {
#line 139
    goto _L___6;
  } else
#line 139
  if (0) {
#line 139
    if (__len > 0UL) {
      _L___6: /* CIL Label */ 
#line 139
      if (0) {
#line 139
        tmp___17 = __builtin_dynamic_object_size(__buf, 1);
#line 139
        if (__len <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 139
          tmp___3 = __confstr_alias(__name, __buf, __len);
#line 139
          tmp___13 = tmp___3;
        } else {
#line 139
          goto _L___7;
        }
      } else {
#line 139
        goto _L___7;
      }
    } else {
#line 139
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 139
    if (1) {
#line 139
      goto _L___1;
    } else
#line 139
    if (0) {
#line 139
      if (__len > 0UL) {
        _L___1: /* CIL Label */ 
#line 139
        if (0) {
#line 139
          tmp___12 = __builtin_dynamic_object_size(__buf, 1);
#line 139
          if (__len <= (unsigned long )tmp___12 / sizeof(char )) {
#line 139
            goto _L___2;
          } else {
#line 139
            tmp___6 = __builtin_dynamic_object_size(__buf, 1);
#line 139
            tmp___7 = __confstr_chk_warn(__name, __buf, __len, (size_t )tmp___6);
#line 139
            tmp___10 = tmp___7;
          }
        } else {
#line 139
          goto _L___2;
        }
      } else {
#line 139
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 139
      tmp___8 = __builtin_dynamic_object_size(__buf, 1);
#line 139
      tmp___9 = __confstr_chk(__name, __buf, __len, (size_t )tmp___8);
#line 139
      tmp___10 = tmp___9;
    }
#line 139
    tmp___13 = tmp___10;
  }
#line 139
  return (tmp___13);
}
}
#line 145
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 145 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 153
  if (0) {
#line 153
    tmp___15 = __builtin_dynamic_object_size(__list, 1);
#line 153
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 153
      goto _L___3;
    } else {
#line 153
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 153
  if (0) {
#line 153
    goto _L___6;
  } else
#line 153
  if (0) {
#line 153
    if (__size > 0) {
      _L___6: /* CIL Label */ 
#line 153
      if (0) {
#line 153
        tmp___17 = __builtin_dynamic_object_size(__list, 1);
#line 153
        if ((unsigned long )__size <= (unsigned long )tmp___17 / sizeof(__gid_t )) {
          _L___3: /* CIL Label */ 
#line 153
          tmp___3 = __getgroups_alias(__size, __list);
#line 153
          tmp___13 = tmp___3;
        } else {
#line 153
          goto _L___7;
        }
      } else {
#line 153
        goto _L___7;
      }
    } else {
#line 153
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 153
    if (0) {
#line 153
      goto _L___1;
    } else
#line 153
    if (0) {
#line 153
      if (__size > 0) {
        _L___1: /* CIL Label */ 
#line 153
        if (0) {
#line 153
          tmp___12 = __builtin_dynamic_object_size(__list, 1);
#line 153
          if ((unsigned long )__size <= (unsigned long )tmp___12 / sizeof(__gid_t )) {
#line 153
            goto _L___2;
          } else {
#line 153
            tmp___6 = __builtin_dynamic_object_size(__list, 1);
#line 153
            tmp___7 = __getgroups_chk_warn(__size, __list, (size_t )tmp___6);
#line 153
            tmp___10 = tmp___7;
          }
        } else {
#line 153
          goto _L___2;
        }
      } else {
#line 153
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 153
      tmp___8 = __builtin_dynamic_object_size(__list, 1);
#line 153
      tmp___9 = __getgroups_chk(__size, __list, (size_t )tmp___8);
#line 153
      tmp___10 = tmp___9;
    }
#line 153
    tmp___13 = tmp___10;
  }
#line 153
  return (tmp___13);
}
}
#line 159
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 159 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 167
  if (0) {
#line 167
    tmp___15 = __builtin_dynamic_object_size(__buf, 1);
#line 167
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 167
      goto _L___3;
    } else {
#line 167
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 167
  if (1) {
#line 167
    goto _L___6;
  } else
#line 167
  if (0) {
#line 167
    if (__buflen > 0UL) {
      _L___6: /* CIL Label */ 
#line 167
      if (0) {
#line 167
        tmp___17 = __builtin_dynamic_object_size(__buf, 1);
#line 167
        if (__buflen <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 167
          tmp___3 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 167
          tmp___13 = tmp___3;
        } else {
#line 167
          goto _L___7;
        }
      } else {
#line 167
        goto _L___7;
      }
    } else {
#line 167
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 167
    if (1) {
#line 167
      goto _L___1;
    } else
#line 167
    if (0) {
#line 167
      if (__buflen > 0UL) {
        _L___1: /* CIL Label */ 
#line 167
        if (0) {
#line 167
          tmp___12 = __builtin_dynamic_object_size(__buf, 1);
#line 167
          if (__buflen <= (unsigned long )tmp___12 / sizeof(char )) {
#line 167
            goto _L___2;
          } else {
#line 167
            tmp___6 = __builtin_dynamic_object_size(__buf, 1);
#line 167
            tmp___7 = __ttyname_r_chk_warn(__fd, __buf, __buflen, (size_t )tmp___6);
#line 167
            tmp___10 = tmp___7;
          }
        } else {
#line 167
          goto _L___2;
        }
      } else {
#line 167
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 167
      tmp___8 = __builtin_dynamic_object_size(__buf, 1);
#line 167
      tmp___9 = __ttyname_r_chk(__fd, __buf, __buflen, (size_t )tmp___8);
#line 167
      tmp___10 = tmp___9;
    }
#line 167
    tmp___13 = tmp___10;
  }
#line 167
  return (tmp___13);
}
}
#line 174 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) getlogin_r)(char *__buf , size_t __buflen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 180
  if (0) {
#line 180
    tmp___15 = __builtin_dynamic_object_size(__buf, 1);
#line 180
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 180
      goto _L___3;
    } else {
#line 180
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 180
  if (1) {
#line 180
    goto _L___6;
  } else
#line 180
  if (0) {
#line 180
    if (__buflen > 0UL) {
      _L___6: /* CIL Label */ 
#line 180
      if (0) {
#line 180
        tmp___17 = __builtin_dynamic_object_size(__buf, 1);
#line 180
        if (__buflen <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 180
          tmp___3 = __getlogin_r_alias(__buf, __buflen);
#line 180
          tmp___13 = tmp___3;
        } else {
#line 180
          goto _L___7;
        }
      } else {
#line 180
        goto _L___7;
      }
    } else {
#line 180
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 180
    if (1) {
#line 180
      goto _L___1;
    } else
#line 180
    if (0) {
#line 180
      if (__buflen > 0UL) {
        _L___1: /* CIL Label */ 
#line 180
        if (0) {
#line 180
          tmp___12 = __builtin_dynamic_object_size(__buf, 1);
#line 180
          if (__buflen <= (unsigned long )tmp___12 / sizeof(char )) {
#line 180
            goto _L___2;
          } else {
#line 180
            tmp___6 = __builtin_dynamic_object_size(__buf, 1);
#line 180
            tmp___7 = __getlogin_r_chk_warn(__buf, __buflen, (size_t )tmp___6);
#line 180
            tmp___10 = tmp___7;
          }
        } else {
#line 180
          goto _L___2;
        }
      } else {
#line 180
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 180
      tmp___8 = __builtin_dynamic_object_size(__buf, 1);
#line 180
      tmp___9 = __getlogin_r_chk(__buf, __buflen, (size_t )tmp___8);
#line 180
      tmp___10 = tmp___9;
    }
#line 180
    tmp___13 = tmp___10;
  }
#line 180
  return (tmp___13);
}
}
#line 188
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) gethostname)(char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 188 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) gethostname)(char *__buf , size_t __buflen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 195
  if (0) {
#line 195
    tmp___15 = __builtin_dynamic_object_size(__buf, 1);
#line 195
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 195
      goto _L___3;
    } else {
#line 195
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 195
  if (1) {
#line 195
    goto _L___6;
  } else
#line 195
  if (0) {
#line 195
    if (__buflen > 0UL) {
      _L___6: /* CIL Label */ 
#line 195
      if (0) {
#line 195
        tmp___17 = __builtin_dynamic_object_size(__buf, 1);
#line 195
        if (__buflen <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 195
          tmp___3 = __gethostname_alias(__buf, __buflen);
#line 195
          tmp___13 = tmp___3;
        } else {
#line 195
          goto _L___7;
        }
      } else {
#line 195
        goto _L___7;
      }
    } else {
#line 195
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 195
    if (1) {
#line 195
      goto _L___1;
    } else
#line 195
    if (0) {
#line 195
      if (__buflen > 0UL) {
        _L___1: /* CIL Label */ 
#line 195
        if (0) {
#line 195
          tmp___12 = __builtin_dynamic_object_size(__buf, 1);
#line 195
          if (__buflen <= (unsigned long )tmp___12 / sizeof(char )) {
#line 195
            goto _L___2;
          } else {
#line 195
            tmp___6 = __builtin_dynamic_object_size(__buf, 1);
#line 195
            tmp___7 = __gethostname_chk_warn(__buf, __buflen, (size_t )tmp___6);
#line 195
            tmp___10 = tmp___7;
          }
        } else {
#line 195
          goto _L___2;
        }
      } else {
#line 195
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 195
      tmp___8 = __builtin_dynamic_object_size(__buf, 1);
#line 195
      tmp___9 = __gethostname_chk(__buf, __buflen, (size_t )tmp___8);
#line 195
      tmp___10 = tmp___9;
    }
#line 195
    tmp___13 = tmp___10;
  }
#line 195
  return (tmp___13);
}
}
#line 203
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 203 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 210
  if (0) {
#line 210
    tmp___15 = __builtin_dynamic_object_size(__buf, 1);
#line 210
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 210
      goto _L___3;
    } else {
#line 210
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 210
  if (1) {
#line 210
    goto _L___6;
  } else
#line 210
  if (0) {
#line 210
    if (__buflen > 0UL) {
      _L___6: /* CIL Label */ 
#line 210
      if (0) {
#line 210
        tmp___17 = __builtin_dynamic_object_size(__buf, 1);
#line 210
        if (__buflen <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 210
          tmp___3 = __getdomainname_alias(__buf, __buflen);
#line 210
          tmp___13 = tmp___3;
        } else {
#line 210
          goto _L___7;
        }
      } else {
#line 210
        goto _L___7;
      }
    } else {
#line 210
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 210
    if (1) {
#line 210
      goto _L___1;
    } else
#line 210
    if (0) {
#line 210
      if (__buflen > 0UL) {
        _L___1: /* CIL Label */ 
#line 210
        if (0) {
#line 210
          tmp___12 = __builtin_dynamic_object_size(__buf, 1);
#line 210
          if (__buflen <= (unsigned long )tmp___12 / sizeof(char )) {
#line 210
            goto _L___2;
          } else {
#line 210
            tmp___6 = __builtin_dynamic_object_size(__buf, 1);
#line 210
            tmp___7 = __getdomainname_chk_warn(__buf, __buflen, (size_t )tmp___6);
#line 210
            tmp___10 = tmp___7;
          }
        } else {
#line 210
          goto _L___2;
        }
      } else {
#line 210
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 210
      tmp___8 = __builtin_dynamic_object_size(__buf, 1);
#line 210
      tmp___9 = __getdomainname_chk(__buf, __buflen, (size_t )tmp___8);
#line 210
      tmp___10 = tmp___9;
    }
#line 210
    tmp___13 = tmp___10;
  }
#line 210
  return (tmp___13);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h"
extern __pid_t ( __attribute__((__leaf__)) gettid)(void)  __attribute__((__nothrow__)) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short tmp ;

  {
#line 37
  tmp = __builtin_bswap16((short )__bsx);
#line 37
  return ((__uint16_t )tmp);
}
}
#line 48 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int tmp ;

  {
#line 52
  tmp = __builtin_bswap32((int )__bsx);
#line 52
  return ((__uint32_t )tmp);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long tmp ;

  {
#line 73
  tmp = __builtin_bswap64((long )__bsx);
#line 73
  return ((__uint64_t )tmp);
}
}
#line 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 38 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 44 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 127
extern int pselect(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                   fd_set * __restrict  __exceptfds , struct timespec  const  * __restrict  __timeout ,
                   __sigset_t const   * __restrict  __sigmask ) ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/select-decl.h"
extern long __fdelt_chk(long __d ) ;
#line 28
extern long __fdelt_warn(long __d )  __attribute__((__warning__("bit outside of fd_set selected"))) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                               struct stat * __restrict  __buf )  __attribute__((__nothrow__)) ;
#line 210
extern int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd , struct stat *__buf )  __attribute__((__nothrow__)) ;
#line 240
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) stat64)(char const   * __restrict  __file ,
                                                                 struct stat64 * __restrict  __buf )  __attribute__((__nothrow__)) ;
#line 242
extern int ( __attribute__((__nonnull__(2), __leaf__)) fstat64)(int __fd , struct stat64 *__buf )  __attribute__((__nothrow__)) ;
#line 264
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd , char const   * __restrict  __file ,
                                                                  struct stat * __restrict  __buf ,
                                                                  int __flag )  __attribute__((__nothrow__)) ;
#line 291
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat64)(int __fd , char const   * __restrict  __file ,
                                                                    struct stat64 * __restrict  __buf ,
                                                                    int __flag )  __attribute__((__nothrow__)) ;
#line 313
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                struct stat * __restrict  __buf )  __attribute__((__nothrow__)) ;
#line 338
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat64)(char const   * __restrict  __file ,
                                                                  struct stat64 * __restrict  __buf )  __attribute__((__nothrow__)) ;
#line 352
extern int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                              __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 359
extern int ( __attribute__((__nonnull__(1), __leaf__)) lchmod)(char const   *__file ,
                                                               __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 365
extern int ( __attribute__((__leaf__)) fchmod)(int __fd , __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 371
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__)) fchmodat)(int __fd ,
                                                                                         char const   *__file ,
                                                                                         __mode_t __mode ,
                                                                                         int __flag )  __attribute__((__nothrow__)) ;
#line 380
extern __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask )  __attribute__((__nothrow__)) ;
#line 385
extern __mode_t ( __attribute__((__leaf__)) getumask)(void)  __attribute__((__nothrow__)) ;
#line 389
extern int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                              __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 396
extern int ( __attribute__((__nonnull__(2), __leaf__)) mkdirat)(int __fd , char const   *__path ,
                                                                __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 404
extern int ( __attribute__((__nonnull__(1), __leaf__)) mknod)(char const   *__path ,
                                                              __mode_t __mode , __dev_t __dev )  __attribute__((__nothrow__)) ;
#line 411
extern int ( __attribute__((__nonnull__(2), __leaf__)) mknodat)(int __fd , char const   *__path ,
                                                                __mode_t __mode ,
                                                                __dev_t __dev )  __attribute__((__nothrow__)) ;
#line 418
extern int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const   *__path ,
                                                               __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 425
extern int ( __attribute__((__nonnull__(2), __leaf__)) mkfifoat)(int __fd , char const   *__path ,
                                                                 __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 433
extern int ( __attribute__((__nonnull__(2), __leaf__)) utimensat)(int __fd , char const   *__path ,
                                                                  struct timespec  const  *__times ,
                                                                  int __flags )  __attribute__((__nothrow__)) ;
#line 452
extern int ( __attribute__((__leaf__)) futimens)(int __fd , struct timespec  const  *__times )  __attribute__((__nothrow__)) ;
#line 62 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h"
extern int ( __attribute__((__nonnull__(2,5), __leaf__)) statx)(int __dirfd , char const   * __restrict  __path ,
                                                                int __flags , unsigned int __mask ,
                                                                struct statx * __restrict  __buf )  __attribute__((__nothrow__)) ;
#line 351 "/usr/include/inttypes.h"
extern intmax_t ( __attribute__((__leaf__)) imaxabs)(intmax_t __n )  __attribute__((__nothrow__,
__const__)) ;
#line 354
extern imaxdiv_t ( __attribute__((__leaf__)) imaxdiv)(intmax_t __numer , intmax_t __denom )  __attribute__((__nothrow__,
__const__)) ;
#line 358
extern intmax_t ( __attribute__((__leaf__)) strtoimax)(char const   *__nptr , char **__endptr ,
                                                       int __base )  __asm__("__isoc23_strtoimax") __attribute__((__nothrow__)) ;
#line 362
extern uintmax_t ( __attribute__((__leaf__)) strtoumax)(char const   *__nptr , char **__endptr ,
                                                        int __base )  __asm__("__isoc23_strtoumax") __attribute__((__nothrow__)) ;
#line 366
extern intmax_t ( __attribute__((__leaf__)) wcstoimax)(__gwchar_t const   *__nptr ,
                                                       __gwchar_t **__endptr , int __base )  __asm__("__isoc23_wcstoimax") __attribute__((__nothrow__)) ;
#line 371
extern uintmax_t ( __attribute__((__leaf__)) wcstoumax)(__gwchar_t const   *__nptr ,
                                                        __gwchar_t **__endptr , int __base )  __asm__("__isoc23_wcstoumax") __attribute__((__nothrow__)) ;
#line 149 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 150
extern FILE *stdout ;
#line 151
extern FILE *stderr ;
#line 158
extern int ( __attribute__((__leaf__)) remove)(char const   *__filename )  __attribute__((__nothrow__)) ;
#line 160
extern int ( __attribute__((__leaf__)) rename)(char const   *__old , char const   *__new )  __attribute__((__nothrow__)) ;
#line 164
extern int ( __attribute__((__leaf__)) renameat)(int __oldfd , char const   *__old ,
                                                 int __newfd , char const   *__new )  __attribute__((__nothrow__)) ;
#line 176
extern int ( __attribute__((__leaf__)) renameat2)(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ,
                                                  unsigned int __flags )  __attribute__((__nothrow__)) ;
#line 184
extern int ( __attribute__((__nonnull__(1))) fclose)(FILE *__stream ) ;
#line 194
extern FILE *( __attribute__((__warn_unused_result__)) tmpfile)(void)  __attribute__((__malloc__(fclose,1),
__malloc__)) ;
#line 206
extern FILE *( __attribute__((__warn_unused_result__)) tmpfile64)(void)  __attribute__((__malloc__(fclose,1),
__malloc__)) ;
#line 211
extern char *( __attribute__((__warn_unused_result__, __leaf__)) tmpnam)(char * )  __attribute__((__nothrow__)) ;
#line 216
extern char *( __attribute__((__warn_unused_result__, __leaf__)) tmpnam_r)(char *__s )  __attribute__((__nothrow__)) ;
#line 228
extern char *( __attribute__((__warn_unused_result__, __leaf__)) tempnam)(char const   *__dir ,
                                                                          char const   *__pfx )  __attribute__((__nothrow__,
__malloc__(__builtin_free,1), __malloc__)) ;
#line 236
extern int fflush(FILE *__stream ) ;
#line 245
extern int fflush_unlocked(FILE *__stream ) ;
#line 255
extern int fcloseall(void) ;
#line 264
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes )  __attribute__((__malloc__(fclose,1),
__malloc__)) ;
#line 271
extern FILE *( __attribute__((__warn_unused_result__, __nonnull__(3))) freopen)(char const   * __restrict  __filename ,
                                                                                char const   * __restrict  __modes ,
                                                                                FILE * __restrict  __stream ) ;
#line 289
extern FILE *( __attribute__((__warn_unused_result__)) fopen64)(char const   * __restrict  __filename ,
                                                                char const   * __restrict  __modes )  __attribute__((__malloc__(fclose,1),
__malloc__)) ;
#line 292
extern FILE *( __attribute__((__warn_unused_result__, __nonnull__(3))) freopen64)(char const   * __restrict  __filename ,
                                                                                  char const   * __restrict  __modes ,
                                                                                  FILE * __restrict  __stream ) ;
#line 299
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) fdopen)(int __fd ,
                                                                         char const   *__modes )  __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
#line 306
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) fopencookie)(void * __restrict  __magic_cookie ,
                                                                              char const   * __restrict  __modes ,
                                                                              cookie_io_functions_t __io_funcs )  __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
#line 314
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) fmemopen)(void *__s ,
                                                                           size_t __len ,
                                                                           char const   *__modes )  __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
#line 320
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) open_memstream)(char **__bufloc ,
                                                                                 size_t *__sizeloc )  __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
#line 334
extern void ( __attribute__((__nonnull__(1), __leaf__)) setbuf)(FILE * __restrict  __stream ,
                                                                char * __restrict  __buf )  __attribute__((__nothrow__)) ;
#line 339
extern int ( __attribute__((__nonnull__(1), __leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                char * __restrict  __buf ,
                                                                int __modes , size_t __n )  __attribute__((__nothrow__)) ;
#line 345
extern void ( __attribute__((__nonnull__(1), __leaf__)) setbuffer)(FILE * __restrict  __stream ,
                                                                   char * __restrict  __buf ,
                                                                   size_t __size )  __attribute__((__nothrow__)) ;
#line 349
extern void ( __attribute__((__nonnull__(1), __leaf__)) setlinebuf)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 357
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) fprintf)(FILE *__stream , char const   *__fmt  , ...) ;
#line 363
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt 
                                                                                                 , ...) ;
#line 365
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt 
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 372
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) vfprintf)(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 378
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 380
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 385
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt 
                                              , ...)  __attribute__((__nothrow__)) ;
#line 389
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 397
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vasprintf)(char **__ptr ,
                                                                         char const   *__fmt ,
                                                                         __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 400
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) __asprintf)(char **__ptr ,
                                                                          char const   *__fmt 
                                                                          , ...)  __attribute__((__nothrow__)) ;
#line 403
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) asprintf)(char **__ptr ,
                                                                        char const   *__fmt 
                                                                        , ...)  __attribute__((__nothrow__)) ;
#line 410
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vdprintf)(int __fd , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 413
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) dprintf)(int __fd , char const   *__fmt  , ...) ;
#line 422
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) fscanf)(FILE *__stream ,
                                                                             char const   *__format 
                                                                             , ...)  __asm__("__isoc23_fscanf")  ;
#line 428
extern int ( __attribute__((__warn_unused_result__)) scanf)(char const   *__format 
                                                            , ...)  __asm__("__isoc23_scanf")  ;
#line 430
extern int ( __attribute__((__leaf__)) sscanf)(char const   *__s , char const   *__format 
                                               , ...)  __asm__("__isoc23_sscanf") __attribute__((__nothrow__)) ;
#line 490
extern int ( /* format attribute */ __attribute__((__warn_unused_result__, __nonnull__(1))) vfscanf)(FILE *__s ,
                                                                                                     char const   *__format ,
                                                                                                     __gnuc_va_list __arg )  __asm__("__isoc23_vfscanf")  ;
#line 498
extern int ( /* format attribute */ __attribute__((__warn_unused_result__)) vscanf)(char const   *__format ,
                                                                                    __gnuc_va_list __arg )  __asm__("__isoc23_vscanf")  ;
#line 502
extern int ( /* format attribute */ __attribute__((__leaf__)) vsscanf)(char const   *__s ,
                                                                       char const   *__format ,
                                                                       __gnuc_va_list __arg )  __asm__("__isoc23_vsscanf") __attribute__((__nothrow__)) ;
#line 575
extern int ( __attribute__((__nonnull__(1))) fgetc)(FILE *__stream ) ;
#line 576
extern int ( __attribute__((__nonnull__(1))) getc)(FILE *__stream ) ;
#line 582
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 589
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 590
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 600
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 611
extern int ( __attribute__((__nonnull__(2))) fputc)(int __c , FILE *__stream ) ;
#line 612
extern int ( __attribute__((__nonnull__(2))) putc)(int __c , FILE *__stream ) ;
#line 618
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 627
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fputc_unlocked)(int __c ,
                                                                                      FILE *__stream ) ;
#line 635
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) putc_unlocked)(int __c ,
                                                                                     FILE *__stream ) ;
#line 636
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 643
extern int ( __attribute__((__nonnull__(1))) getw)(FILE *__stream ) ;
#line 646
extern int ( __attribute__((__nonnull__(2))) putw)(int __w , FILE *__stream ) ;
#line 654
__inline extern char *( __attribute__((__warn_unused_result__, __nonnull__(3), __gnu_inline__,
__artificial__, __always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 677
__inline extern char *( __attribute__((__warn_unused_result__, __nonnull__(3), __gnu_inline__,
__artificial__, __always_inline__)) fgets_unlocked)(char *__s , int __n , FILE *__stream ) ;
#line 689
extern __ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(4))) __getdelim)(char ** __restrict  __lineptr ,
                                                                                       size_t * __restrict  __n ,
                                                                                       int __delimiter ,
                                                                                       FILE * __restrict  __stream ) ;
#line 692
extern __ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(4))) getdelim)(char ** __restrict  __lineptr ,
                                                                                     size_t * __restrict  __n ,
                                                                                     int __delimiter ,
                                                                                     FILE * __restrict  __stream ) ;
#line 697
__inline extern __ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(3),
__gnu_inline__)) getline)(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 707
extern int ( __attribute__((__nonnull__(2))) fputs)(char const   * __restrict  __s ,
                                                    FILE * __restrict  __stream ) ;
#line 714
extern int puts(char const   *__s ) ;
#line 721
extern int ( __attribute__((__nonnull__(2))) ungetc)(int __c , FILE *__stream ) ;
#line 728
__inline extern size_t ( __attribute__((__warn_unused_result__, __nonnull__(4), __gnu_inline__,
__artificial__, __always_inline__)) fread)(void *__ptr , size_t __size , size_t __n ,
                                           FILE *__stream ) ;
#line 735
extern size_t ( __attribute__((__nonnull__(4))) fwrite)(void const   * __restrict  __ptr ,
                                                        size_t __size , size_t __n ,
                                                        FILE * __restrict  __s ) ;
#line 745
extern int ( __attribute__((__nonnull__(2))) fputs_unlocked)(char const   * __restrict  __s ,
                                                             FILE * __restrict  __stream ) ;
#line 756
__inline extern size_t ( __attribute__((__warn_unused_result__, __nonnull__(4), __gnu_inline__,
__artificial__, __always_inline__)) fread_unlocked)(void *__ptr , size_t __size ,
                                                    size_t __n , FILE *__stream ) ;
#line 759
extern size_t ( __attribute__((__nonnull__(4))) fwrite_unlocked)(void const   * __restrict  __ptr ,
                                                                 size_t __size , size_t __n ,
                                                                 FILE * __restrict  __stream ) ;
#line 769
extern int ( __attribute__((__nonnull__(1))) fseek)(FILE *__stream , long __off ,
                                                    int __whence ) ;
#line 775
extern long ( __attribute__((__warn_unused_result__, __nonnull__(1))) ftell)(FILE *__stream ) ;
#line 780
extern void ( __attribute__((__nonnull__(1))) rewind)(FILE *__stream ) ;
#line 793
extern int ( __attribute__((__nonnull__(1))) fseeko)(FILE *__stream , __off_t __off ,
                                                     int __whence ) ;
#line 799
extern __off_t ( __attribute__((__warn_unused_result__, __nonnull__(1))) ftello)(FILE *__stream ) ;
#line 819
extern int ( __attribute__((__nonnull__(1))) fgetpos)(FILE * __restrict  __stream ,
                                                      fpos_t * __restrict  __pos ) ;
#line 825
extern int ( __attribute__((__nonnull__(1))) fsetpos)(FILE *__stream , fpos_t const   *__pos ) ;
#line 841
extern int ( __attribute__((__nonnull__(1))) fseeko64)(FILE *__stream , __off64_t __off ,
                                                       int __whence ) ;
#line 843
extern __off64_t ( __attribute__((__warn_unused_result__, __nonnull__(1))) ftello64)(FILE *__stream ) ;
#line 844
extern int ( __attribute__((__nonnull__(1))) fgetpos64)(FILE * __restrict  __stream ,
                                                        fpos64_t * __restrict  __pos ) ;
#line 846
extern int ( __attribute__((__nonnull__(1))) fsetpos64)(FILE *__stream , fpos64_t const   *__pos ) ;
#line 850
extern void ( __attribute__((__nonnull__(1), __leaf__)) clearerr)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 852
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) feof)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 854
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) ferror)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 858
extern void ( __attribute__((__nonnull__(1), __leaf__)) clearerr_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 859
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) feof_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 860
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) ferror_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 868
extern void perror(char const   *__s )  __attribute__((__cold__)) ;
#line 873
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) fileno)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 878
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) fileno_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 887
extern int ( __attribute__((__nonnull__(1))) pclose)(FILE *__stream ) ;
#line 893
extern FILE *( __attribute__((__warn_unused_result__)) popen)(char const   *__command ,
                                                              char const   *__modes )  __attribute__((__malloc__(pclose,1),
__malloc__)) ;
#line 901
extern char *( __attribute__((__leaf__)) ctermid)(char *__s )  __attribute__((__nothrow__,
__access__(__write_only__,1))) ;
#line 908
extern char *cuserid(char *__s )  __attribute__((__access__(__write_only__,1))) ;
#line 917
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_printf)(struct obstack *__obstack , char const   *__fmt 
                                                    , ...)  __attribute__((__nothrow__)) ;
#line 920
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack , char const   *__fmt ,
                                                     __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 931
extern void ( __attribute__((__nonnull__(1), __leaf__)) flockfile)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 935
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) ftrylockfile)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 938
extern void ( __attribute__((__nonnull__(1), __leaf__)) funlockfile)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 949
extern int __uflow(FILE * ) ;
#line 950
extern int __overflow(FILE * , int  ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2-decl.h"
extern int ( __attribute__((__leaf__)) __sprintf_chk)(char * __restrict  __s , int __flag ,
                                                      size_t __slen , char const   * __restrict  __format 
                                                      , ...)  __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
#line 29
extern int ( __attribute__((__leaf__)) __vsprintf_chk)(char * __restrict  __s , int __flag ,
                                                       size_t __slen , char const   * __restrict  __format ,
                                                       __gnuc_va_list __ap )  __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
#line 36
extern int ( __attribute__((__leaf__)) __snprintf_chk)(char * __restrict  __s , size_t __n ,
                                                       int __flag , size_t __slen ,
                                                       char const   * __restrict  __format 
                                                       , ...)  __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
#line 40
extern int ( __attribute__((__leaf__)) __vsnprintf_chk)(char * __restrict  __s , size_t __n ,
                                                        int __flag , size_t __slen ,
                                                        char const   * __restrict  __format ,
                                                        __gnuc_va_list __ap )  __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
#line 49
extern int ( __attribute__((__nonnull__(1))) __fprintf_chk)(FILE * __restrict  __stream ,
                                                            int __flag , char const   * __restrict  __format 
                                                            , ...) ;
#line 52
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
#line 53
extern int ( __attribute__((__nonnull__(1))) __vfprintf_chk)(FILE * __restrict  __stream ,
                                                             int __flag , char const   * __restrict  __format ,
                                                             __gnuc_va_list __ap ) ;
#line 56
extern int __vprintf_chk(int __flag , char const   * __restrict  __format , __gnuc_va_list __ap ) ;
#line 60
extern int ( /* format attribute */  __dprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt 
                                                    , ...) ;
#line 62
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
#line 69
extern int ( /* format attribute */ __attribute__((__warn_unused_result__, __leaf__)) __asprintf_chk)(char ** __restrict  __ptr ,
                                                                                                      int __flag ,
                                                                                                      char const   * __restrict  __fmt 
                                                                                                      , ...)  __attribute__((__nothrow__)) ;
#line 72
extern int ( /* format attribute */ __attribute__((__warn_unused_result__, __leaf__)) __vasprintf_chk)(char ** __restrict  __ptr ,
                                                                                                       int __flag ,
                                                                                                       char const   * __restrict  __fmt ,
                                                                                                       __gnuc_va_list __arg )  __attribute__((__nothrow__)) ;
#line 75
extern int ( /* format attribute */ __attribute__((__leaf__)) __obstack_printf_chk)(struct obstack * __restrict  __obstack ,
                                                                                    int __flag ,
                                                                                    char const   * __restrict  __format 
                                                                                    , ...)  __attribute__((__nothrow__)) ;
#line 79
extern int ( /* format attribute */ __attribute__((__leaf__)) __obstack_vprintf_chk)(struct obstack * __restrict  __obstack ,
                                                                                     int __flag ,
                                                                                     char const   * __restrict  __format ,
                                                                                     __gnuc_va_list __args )  __attribute__((__nothrow__)) ;
#line 96
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets") __attribute__((__access__(__write_only__,1,2))) ;
#line 100
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
#line 106
extern char *( __attribute__((__warn_unused_result__, __nonnull__(4))) __fgets_chk)(char * __restrict  __s ,
                                                                                    size_t __size ,
                                                                                    int __n ,
                                                                                    FILE * __restrict  __stream )  __attribute__((__access__(__write_only__,1,3))) ;
#line 110
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
#line 114
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
#line 122
extern size_t ( __attribute__((__warn_unused_result__, __nonnull__(5))) __fread_chk)(void * __restrict  __ptr ,
                                                                                     size_t __ptrlen ,
                                                                                     size_t __size ,
                                                                                     size_t __n ,
                                                                                     FILE * __restrict  __stream ) ;
#line 127
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_alias)(char * __restrict  __s ,
                                                                               int __n ,
                                                                               FILE * __restrict  __stream )  __asm__("fgets_unlocked") __attribute__((__access__(__write_only__,1,2))) ;
#line 131
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk_warn)(char * __restrict  __s ,
                                                                                  size_t __size ,
                                                                                  int __n ,
                                                                                  FILE * __restrict  __stream )  __asm__("__fgets_unlocked_chk") __attribute__((__warning__("fgets_unlocked called with bigger size than length of destination buffer"))) ;
#line 138
extern char *( __attribute__((__warn_unused_result__, __nonnull__(4))) __fgets_unlocked_chk)(char * __restrict  __s ,
                                                                                             size_t __size ,
                                                                                             int __n ,
                                                                                             FILE * __restrict  __stream )  __attribute__((__access__(__write_only__,1,3))) ;
#line 145
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
#line 149
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
#line 157
extern size_t ( __attribute__((__warn_unused_result__, __nonnull__(5))) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                                              size_t __ptrlen ,
                                                                                              size_t __size ,
                                                                                              size_t __n ,
                                                                                              FILE * __restrict  __stream ) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
#line 49
  tmp = getc(stdin);
#line 49
  return (tmp);
}
}
#line 55 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 58
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
#line 58
  if (tmp___3) {
#line 58
    tmp___0 = __uflow(__fp);
#line 58
    tmp___2 = tmp___0;
  } else {
#line 58
    tmp___1 = __fp->_IO_read_ptr;
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 58
  return (tmp___2);
}
}
#line 72 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 75
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
#line 75
  if (tmp___3) {
#line 75
    tmp___0 = __uflow(stdin);
#line 75
    tmp___2 = tmp___0;
  } else {
#line 75
    tmp___1 = stdin->_IO_read_ptr;
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 75
  return (tmp___2);
}
}
#line 81 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
#line 84
  tmp = putc(__c, stdout);
#line 84
  return (tmp);
}
}
#line 90 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fputc_unlocked)(int __c ,
                                                                                      FILE *__stream ) 
{ 
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 93
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
#line 93
  if (tmp___4) {
#line 93
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp___3 = tmp___0;
  } else {
#line 93
    tmp___1 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    tmp___2 = (char )__c;
#line 93
    *tmp___1 = tmp___2;
#line 93
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 93
  return (tmp___3);
}
}
#line 107 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 110
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
#line 110
  if (tmp___4) {
#line 110
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp___3 = tmp___0;
  } else {
#line 110
    tmp___1 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    tmp___2 = (char )__c;
#line 110
    *tmp___1 = tmp___2;
#line 110
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 110
  return (tmp___3);
}
}
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(3),
__gnu_inline__)) getline)(char **__lineptr , size_t *__n , FILE *__stream ) 
{ 
  __ssize_t tmp ;

  {
#line 120
  tmp = __getdelim((char ** __restrict  )__lineptr, (size_t * __restrict  )__n, '\n',
                   (FILE * __restrict  )__stream);
#line 120
  return (tmp);
}
}
#line 127
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) feof_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 0x0010) != 0);
}
}
#line 134
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) ferror_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 134 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 0x0020) != 0);
}
}
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt 
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt 
                                                                                                            , ...) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 30
  tmp = __builtin_dynamic_object_size(__s, 1);
#line 30
  tmp___0 = __builtin___sprintf_chk(__s, 2, (unsigned long )tmp, __fmt, __builtin_va_arg_pack());
#line 30
  return (tmp___0);
}
}
#line 54
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 54 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 58
  tmp = __builtin_dynamic_object_size(__s, 1);
#line 58
  tmp___0 = __builtin___vsprintf_chk(__s, 2, (unsigned long )tmp, __fmt, __ap);
#line 58
  return (tmp___0);
}
}
#line 64
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt 
                                              , ...)  __attribute__((__nothrow__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt 
                                              , ...) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 68
  tmp = __builtin_dynamic_object_size(__s, 1);
#line 68
  tmp___0 = __builtin___snprintf_chk(__s, __n, 2, (unsigned long )tmp, __fmt, __builtin_va_arg_pack());
#line 68
  return (tmp___0);
}
}
#line 92
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 92 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 100
  tmp = __builtin_dynamic_object_size(__s, 1);
#line 100
  tmp___0 = __builtin___vsnprintf_chk(__s, __n, 2, (unsigned long )tmp, __fmt, __ap);
#line 100
  return (tmp___0);
}
}
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) fprintf)(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int tmp ;

  {
#line 111
  tmp = __fprintf_chk((FILE * __restrict  )__stream, 2, (char const   * __restrict  )__fmt,
                      __builtin_va_arg_pack());
#line 111
  return (tmp);
}
}
#line 115 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt 
                                                                                                 , ...) 
{ 
  int tmp ;

  {
#line 118
  tmp = __printf_chk(2, (char const   * __restrict  )__fmt, __builtin_va_arg_pack());
#line 118
  return (tmp);
}
}
#line 151 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 156
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 2, (char const   * __restrict  )__fmt,
                       __ap);
#line 156
  return (tmp);
}
}
#line 162 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) vfprintf)(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 166
  tmp = __vfprintf_chk((FILE * __restrict  )__stream, 2, (char const   * __restrict  )__fmt,
                       __ap);
#line 166
  return (tmp);
}
}
#line 171 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) dprintf)(int __fd , char const   *__fmt  , ...) 
{ 
  int tmp ;

  {
#line 174
  tmp = __dprintf_chk(__fd, 2, (char const   * __restrict  )__fmt, __builtin_va_arg_pack());
#line 174
  return (tmp);
}
}
#line 194 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vdprintf)(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 197
  tmp = __vdprintf_chk(__fd, 2, (char const   * __restrict  )__fmt, __ap);
#line 197
  return (tmp);
}
}
#line 203
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) asprintf)(char **__ptr ,
                                                                        char const   *__fmt 
                                                                        , ...)  __attribute__((__nothrow__)) ;
#line 203 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) asprintf)(char **__ptr ,
                                                                        char const   *__fmt 
                                                                        , ...) 
{ 
  int tmp ;

  {
#line 206
  tmp = __asprintf_chk((char ** __restrict  )__ptr, 2, (char const   * __restrict  )__fmt,
                       __builtin_va_arg_pack());
#line 206
  return (tmp);
}
}
#line 218
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_printf)(struct obstack *__obstack , char const   *__fmt 
                                                    , ...)  __attribute__((__nothrow__)) ;
#line 218 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_printf)(struct obstack *__obstack , char const   *__fmt 
                                                    , ...) 
{ 
  int tmp ;

  {
#line 222
  tmp = __obstack_printf_chk((struct obstack * __restrict  )__obstack, 2, (char const   * __restrict  )__fmt,
                             __builtin_va_arg_pack());
#line 222
  return (tmp);
}
}
#line 271
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vasprintf)(char **__ptr ,
                                                                         char const   *__fmt ,
                                                                         __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 271 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vasprintf)(char **__ptr ,
                                                                         char const   *__fmt ,
                                                                         __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 275
  tmp = __vasprintf_chk((char ** __restrict  )__ptr, 2, (char const   * __restrict  )__fmt,
                        __ap);
#line 275
  return (tmp);
}
}
#line 278
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack , char const   *__fmt ,
                                                     __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 278 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack , char const   *__fmt ,
                                                     __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 282
  tmp = __obstack_vprintf_chk((struct obstack * __restrict  )__obstack, 2, (char const   * __restrict  )__fmt,
                              __ap);
#line 282
  return (tmp);
}
}
#line 303 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __nonnull__(3), __gnu_inline__,
__artificial__, __always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) 
{ 
  size_t __sz ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 311
  tmp = __builtin_dynamic_object_size(__s, 1);
#line 311
  __sz = (size_t )tmp;
#line 312
  if (0) {
#line 312
    if (__sz == 18446744073709551615UL) {
#line 312
      goto _L;
    } else {
#line 312
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 312
  if (0) {
#line 312
    goto _L___2;
  } else
#line 312
  if (0) {
#line 312
    if (__n > 0) {
      _L___2: /* CIL Label */ 
#line 312
      if (0) {
#line 312
        if ((unsigned long )__n <= __sz / sizeof(char )) {
          _L: /* CIL Label */ 
#line 313
          tmp___0 = __fgets_alias((char * __restrict  )__s, __n, (FILE * __restrict  )__stream);
#line 313
          return (tmp___0);
        } else {
#line 312
          goto _L___3;
        }
      } else {
#line 312
        goto _L___3;
      }
    } else {
#line 312
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ ;
  }
#line 315
  if (0) {
#line 315
    goto _L___7;
  } else
#line 315
  if (0) {
#line 315
    if (__n > 0) {
      _L___7: /* CIL Label */ 
#line 315
      if (0) {
#line 315
        if (! ((unsigned long )__n <= __sz / sizeof(char ))) {
#line 316
          tmp___1 = __fgets_chk_warn((char * __restrict  )__s, __sz, __n, (FILE * __restrict  )__stream);
#line 316
          return (tmp___1);
        } else {
#line 315
          goto _L___8;
        }
      } else {
#line 315
        goto _L___8;
      }
    } else {
#line 315
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
    _L___6: /* CIL Label */ 
    _L___5: /* CIL Label */ ;
  }
#line 318
  tmp___2 = __fgets_chk((char * __restrict  )__s, __sz, __n, (FILE * __restrict  )__stream);
#line 318
  return (tmp___2);
}
}
#line 321 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __nonnull__(4), __gnu_inline__,
__artificial__, __always_inline__)) fread)(void *__ptr , size_t __size , size_t __n ,
                                           FILE *__stream ) 
{ 
  size_t __sz ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 329
  tmp = __builtin_dynamic_object_size(__ptr, 0);
#line 329
  __sz = (size_t )tmp;
#line 330
  if (0) {
#line 330
    if (__sz == 18446744073709551615UL) {
#line 330
      goto _L;
    } else {
#line 330
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 330
  if (1) {
#line 330
    goto _L___2;
  } else
#line 330
  if (0) {
#line 330
    if (__n > 0UL) {
      _L___2: /* CIL Label */ 
#line 330
      if (0) {
#line 330
        if (__n <= __sz / __size) {
          _L: /* CIL Label */ 
#line 331
          tmp___0 = __fread_alias((void * __restrict  )__ptr, __size, __n, (FILE * __restrict  )__stream);
#line 331
          return (tmp___0);
        } else {
#line 330
          goto _L___3;
        }
      } else {
#line 330
        goto _L___3;
      }
    } else {
#line 330
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ ;
  }
#line 333
  if (1) {
#line 333
    goto _L___7;
  } else
#line 333
  if (0) {
#line 333
    if (__n > 0UL) {
      _L___7: /* CIL Label */ 
#line 333
      if (0) {
#line 333
        if (! (__n <= __sz / __size)) {
#line 334
          tmp___1 = __fread_chk_warn((void * __restrict  )__ptr, __sz, __size, __n,
                                     (FILE * __restrict  )__stream);
#line 334
          return (tmp___1);
        } else {
#line 333
          goto _L___8;
        }
      } else {
#line 333
        goto _L___8;
      }
    } else {
#line 333
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
    _L___6: /* CIL Label */ 
    _L___5: /* CIL Label */ ;
  }
#line 336
  tmp___2 = __fread_chk((void * __restrict  )__ptr, __sz, __size, __n, (FILE * __restrict  )__stream);
#line 336
  return (tmp___2);
}
}
#line 340 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __nonnull__(3), __gnu_inline__,
__artificial__, __always_inline__)) fgets_unlocked)(char *__s , int __n , FILE *__stream ) 
{ 
  size_t __sz ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 348
  tmp = __builtin_dynamic_object_size(__s, 1);
#line 348
  __sz = (size_t )tmp;
#line 349
  if (0) {
#line 349
    if (__sz == 18446744073709551615UL) {
#line 349
      goto _L;
    } else {
#line 349
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 349
  if (0) {
#line 349
    goto _L___2;
  } else
#line 349
  if (0) {
#line 349
    if (__n > 0) {
      _L___2: /* CIL Label */ 
#line 349
      if (0) {
#line 349
        if ((unsigned long )__n <= __sz / sizeof(char )) {
          _L: /* CIL Label */ 
#line 350
          tmp___0 = __fgets_unlocked_alias((char * __restrict  )__s, __n, (FILE * __restrict  )__stream);
#line 350
          return (tmp___0);
        } else {
#line 349
          goto _L___3;
        }
      } else {
#line 349
        goto _L___3;
      }
    } else {
#line 349
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ ;
  }
#line 352
  if (0) {
#line 352
    goto _L___7;
  } else
#line 352
  if (0) {
#line 352
    if (__n > 0) {
      _L___7: /* CIL Label */ 
#line 352
      if (0) {
#line 352
        if (! ((unsigned long )__n <= __sz / sizeof(char ))) {
#line 353
          tmp___1 = __fgets_unlocked_chk_warn((char * __restrict  )__s, __sz, __n,
                                              (FILE * __restrict  )__stream);
#line 353
          return (tmp___1);
        } else {
#line 352
          goto _L___8;
        }
      } else {
#line 352
        goto _L___8;
      }
    } else {
#line 352
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
    _L___6: /* CIL Label */ 
    _L___5: /* CIL Label */ ;
  }
#line 355
  tmp___2 = __fgets_unlocked_chk((char * __restrict  )__s, __sz, __n, (FILE * __restrict  )__stream);
#line 355
  return (tmp___2);
}
}
#line 361 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __nonnull__(4), __gnu_inline__,
__artificial__, __always_inline__)) fread_unlocked)(void *__ptr , size_t __size ,
                                                    size_t __n , FILE *__stream ) 
{ 
  size_t __sz ;
  int tmp ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 369
  tmp = __builtin_dynamic_object_size(__ptr, 0);
#line 369
  __sz = (size_t )tmp;
#line 370
  if (0) {
#line 370
    if (__sz == 18446744073709551615UL) {
#line 370
      goto _L___2;
    } else {
#line 370
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 370
  if (1) {
#line 370
    goto _L___5;
  } else
#line 370
  if (0) {
#line 370
    if (__n > 0UL) {
      _L___5: /* CIL Label */ 
#line 370
      if (0) {
#line 370
        if (__n <= __sz / __size) {
          _L___2: /* CIL Label */ 
#line 373
          if (0) {
#line 373
            if (0) {
#line 373
              if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 373
                if (__size * __n <= 8UL) {
#line 378
                  __cnt = __size * __n;
#line 379
                  __cptr = (char *)__ptr;
#line 380
                  if (__cnt == 0UL) {
#line 381
                    return ((size_t )0);
                  }
                  {
#line 383
                  while (1) {
                    while_continue: /* CIL Label */ ;
#line 383
                    if (! (__cnt > 0UL)) {
#line 383
                      goto while_break;
                    }
#line 385
                    tmp___0 = fgetc_unlocked(__stream);
#line 385
                    __c = tmp___0;
#line 386
                    if (__c == -1) {
#line 387
                      goto while_break;
                    }
#line 388
                    tmp___1 = __cptr;
#line 388
                    __cptr ++;
#line 388
                    *tmp___1 = (char )__c;
#line 383
                    __cnt --;
                  }
                  while_break: /* CIL Label */ ;
                  }
#line 390
                  return ((size_t )(__cptr - (char *)__ptr) / __size);
                } else {
#line 373
                  goto _L___1;
                }
              } else {
#line 373
                goto _L___1;
              }
            } else {
#line 373
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
            _L___0: /* CIL Label */ 
            _L: /* CIL Label */ ;
          }
#line 393
          tmp___2 = __fread_unlocked_alias((void * __restrict  )__ptr, __size, __n,
                                           (FILE * __restrict  )__stream);
#line 393
          return (tmp___2);
        } else {
#line 370
          goto _L___6;
        }
      } else {
#line 370
        goto _L___6;
      }
    } else {
#line 370
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
    _L___4: /* CIL Label */ 
    _L___3: /* CIL Label */ ;
  }
#line 396
  if (1) {
#line 396
    goto _L___10;
  } else
#line 396
  if (0) {
#line 396
    if (__n > 0UL) {
      _L___10: /* CIL Label */ 
#line 396
      if (0) {
#line 396
        if (! (__n <= __sz / __size)) {
#line 397
          tmp___3 = __fread_unlocked_chk_warn((void * __restrict  )__ptr, __sz, __size,
                                              __n, (FILE * __restrict  )__stream);
#line 397
          return (tmp___3);
        } else {
#line 396
          goto _L___11;
        }
      } else {
#line 396
        goto _L___11;
      }
    } else {
#line 396
      goto _L___11;
    }
  } else {
    _L___11: /* CIL Label */ 
    _L___9: /* CIL Label */ 
    _L___8: /* CIL Label */ ;
  }
#line 399
  tmp___4 = __fread_unlocked_chk((void * __restrict  )__ptr, __sz, __size, __n, (FILE * __restrict  )__stream);
#line 399
  return (tmp___4);
}
}
#line 3 "/home/petter/repositories/goblint/lib/libc/stub/include/assert.h"
extern void __goblint_assert(int expression ) ;
#line 98 "/usr/include/stdlib.h"
extern size_t ( __attribute__((__warn_unused_result__, __leaf__)) __ctype_get_mb_cur_max)(void)  __attribute__((__nothrow__)) ;
#line 102
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 105
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 108
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 113
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 118
extern double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                  char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 124
extern float ( __attribute__((__nonnull__(1), __leaf__)) strtof)(char const   * __restrict  __nptr ,
                                                                 char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 127
extern long double ( __attribute__((__nonnull__(1), __leaf__)) strtold)(char const   * __restrict  __nptr ,
                                                                        char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 141
extern float ( __attribute__((__nonnull__(1), __leaf__)) strtof32)(char const   * __restrict  __nptr ,
                                                                   char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 147
extern double ( __attribute__((__nonnull__(1), __leaf__)) strtof64)(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 153
extern _Float128 ( __attribute__((__nonnull__(1), __leaf__)) strtof128)(char const   * __restrict  __nptr ,
                                                                        char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 159
extern double ( __attribute__((__nonnull__(1), __leaf__)) strtof32x)(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 165
extern long double ( __attribute__((__nonnull__(1), __leaf__)) strtof64x)(char const   * __restrict  __nptr ,
                                                                          char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 177
extern long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base )  __asm__("__isoc23_strtol") __attribute__((__nothrow__)) ;
#line 181
extern unsigned long ( __attribute__((__nonnull__(1), __leaf__)) strtoul)(char const   *__nptr ,
                                                                          char **__endptr ,
                                                                          int __base )  __asm__("__isoc23_strtoul") __attribute__((__nothrow__)) ;
#line 188
extern long long ( __attribute__((__nonnull__(1), __leaf__)) strtoq)(char const   *__nptr ,
                                                                     char **__endptr ,
                                                                     int __base )  __asm__("__isoc23_strtoll") __attribute__((__nothrow__)) ;
#line 193
extern unsigned long long ( __attribute__((__nonnull__(1), __leaf__)) strtouq)(char const   *__nptr ,
                                                                               char **__endptr ,
                                                                               int __base )  __asm__("__isoc23_strtoull") __attribute__((__nothrow__)) ;
#line 201
extern long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base )  __asm__("__isoc23_strtoll") __attribute__((__nothrow__)) ;
#line 206
extern unsigned long long ( __attribute__((__nonnull__(1), __leaf__)) strtoull)(char const   *__nptr ,
                                                                                char **__endptr ,
                                                                                int __base )  __asm__("__isoc23_strtoull") __attribute__((__nothrow__)) ;
#line 278
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromd)(char *__dest , size_t __size ,
                                                                 char const   *__format ,
                                                                 double __f )  __attribute__((__nothrow__)) ;
#line 282
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf)(char *__dest , size_t __size ,
                                                                 char const   *__format ,
                                                                 float __f )  __attribute__((__nothrow__)) ;
#line 286
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfroml)(char *__dest , size_t __size ,
                                                                 char const   *__format ,
                                                                 long double __f )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf32)(char *__dest ,
                                                                   size_t __size ,
                                                                   char const   *__format ,
                                                                   float __f )  __attribute__((__nothrow__)) ;
#line 304
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf64)(char *__dest ,
                                                                   size_t __size ,
                                                                   char const   *__format ,
                                                                   double __f )  __attribute__((__nothrow__)) ;
#line 310
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf128)(char *__dest ,
                                                                    size_t __size ,
                                                                    char const   *__format ,
                                                                    _Float128 __f )  __attribute__((__nothrow__)) ;
#line 316
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf32x)(char *__dest ,
                                                                    size_t __size ,
                                                                    char const   *__format ,
                                                                    double __f )  __attribute__((__nothrow__)) ;
#line 322
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf64x)(char *__dest ,
                                                                    size_t __size ,
                                                                    char const   *__format ,
                                                                    long double __f )  __attribute__((__nothrow__)) ;
#line 340
extern long ( __attribute__((__nonnull__(1,4), __leaf__)) strtol_l)(char const   *__nptr ,
                                                                    char **__endptr ,
                                                                    int __base , locale_t __loc )  __asm__("__isoc23_strtol_l") __attribute__((__nothrow__)) ;
#line 344
extern unsigned long ( __attribute__((__nonnull__(1,4), __leaf__)) strtoul_l)(char const   *__nptr ,
                                                                              char **__endptr ,
                                                                              int __base ,
                                                                              locale_t __loc )  __asm__("__isoc23_strtoul_l") __attribute__((__nothrow__)) ;
#line 350
extern long long ( __attribute__((__nonnull__(1,4), __leaf__)) strtoll_l)(char const   *__nptr ,
                                                                          char **__endptr ,
                                                                          int __base ,
                                                                          locale_t __loc )  __asm__("__isoc23_strtoll_l") __attribute__((__nothrow__)) ;
#line 356
extern unsigned long long ( __attribute__((__nonnull__(1,4), __leaf__)) strtoull_l)(char const   *__nptr ,
                                                                                    char **__endptr ,
                                                                                    int __base ,
                                                                                    locale_t __loc )  __asm__("__isoc23_strtoull_l") __attribute__((__nothrow__)) ;
#line 415
extern double ( __attribute__((__nonnull__(1,3), __leaf__)) strtod_l)(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      locale_t __loc )  __attribute__((__nothrow__)) ;
#line 419
extern float ( __attribute__((__nonnull__(1,3), __leaf__)) strtof_l)(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     locale_t __loc )  __attribute__((__nothrow__)) ;
#line 423
extern long double ( __attribute__((__nonnull__(1,3), __leaf__)) strtold_l)(char const   * __restrict  __nptr ,
                                                                            char ** __restrict  __endptr ,
                                                                            locale_t __loc )  __attribute__((__nothrow__)) ;
#line 436
extern float ( __attribute__((__nonnull__(1,3), __leaf__)) strtof32_l)(char const   * __restrict  __nptr ,
                                                                       char ** __restrict  __endptr ,
                                                                       locale_t __loc )  __attribute__((__nothrow__)) ;
#line 443
extern double ( __attribute__((__nonnull__(1,3), __leaf__)) strtof64_l)(char const   * __restrict  __nptr ,
                                                                        char ** __restrict  __endptr ,
                                                                        locale_t __loc )  __attribute__((__nothrow__)) ;
#line 450
extern _Float128 ( __attribute__((__nonnull__(1,3), __leaf__)) strtof128_l)(char const   * __restrict  __nptr ,
                                                                            char ** __restrict  __endptr ,
                                                                            locale_t __loc )  __attribute__((__nothrow__)) ;
#line 457
extern double ( __attribute__((__nonnull__(1,3), __leaf__)) strtof32x_l)(char const   * __restrict  __nptr ,
                                                                         char ** __restrict  __endptr ,
                                                                         locale_t __loc )  __attribute__((__nothrow__)) ;
#line 464
extern long double ( __attribute__((__nonnull__(1,3), __leaf__)) strtof64x_l)(char const   * __restrict  __nptr ,
                                                                              char ** __restrict  __endptr ,
                                                                              locale_t __loc )  __attribute__((__nothrow__)) ;
#line 480
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 480 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 483
  tmp = strtol(__nptr, (char **)((void *)0), 10);
#line 483
  return ((int )tmp);
}
}
#line 485
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 485 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 488
  tmp = strtol(__nptr, (char **)((void *)0), 10);
#line 488
  return (tmp);
}
}
#line 492
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 492 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
#line 495
  tmp = strtoll(__nptr, (char **)((void *)0), 10);
#line 495
  return (tmp);
}
}
#line 505
extern char *( __attribute__((__warn_unused_result__, __leaf__)) l64a)(long __n )  __attribute__((__nothrow__)) ;
#line 508
extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) a64l)(char const   *__s )  __attribute__((__pure__,
__nothrow__)) ;
#line 521
extern long ( __attribute__((__leaf__)) random)(void)  __attribute__((__nothrow__)) ;
#line 524
extern void ( __attribute__((__leaf__)) srandom)(unsigned int __seed )  __attribute__((__nothrow__)) ;
#line 530
extern char *( __attribute__((__nonnull__(2), __leaf__)) initstate)(unsigned int __seed ,
                                                                    char *__statebuf ,
                                                                    size_t __statelen )  __attribute__((__nothrow__)) ;
#line 535
extern char *( __attribute__((__nonnull__(1), __leaf__)) setstate)(char *__statebuf )  __attribute__((__nothrow__)) ;
#line 554
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) random_r)(struct random_data * __restrict  __buf ,
                                                                   int32_t * __restrict  __result )  __attribute__((__nothrow__)) ;
#line 557
extern int ( __attribute__((__nonnull__(2), __leaf__)) srandom_r)(unsigned int __seed ,
                                                                  struct random_data *__buf )  __attribute__((__nothrow__)) ;
#line 560
extern int ( __attribute__((__nonnull__(2,4), __leaf__)) initstate_r)(unsigned int __seed ,
                                                                      char * __restrict  __statebuf ,
                                                                      size_t __statelen ,
                                                                      struct random_data * __restrict  __buf )  __attribute__((__nothrow__)) ;
#line 565
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) setstate_r)(char * __restrict  __statebuf ,
                                                                     struct random_data * __restrict  __buf )  __attribute__((__nothrow__)) ;
#line 573
extern int ( __attribute__((__leaf__)) rand)(void)  __attribute__((__nothrow__)) ;
#line 575
extern void ( __attribute__((__leaf__)) srand)(unsigned int __seed )  __attribute__((__nothrow__)) ;
#line 579
extern int ( __attribute__((__leaf__)) rand_r)(unsigned int *__seed )  __attribute__((__nothrow__)) ;
#line 587
extern double ( __attribute__((__leaf__)) drand48)(void)  __attribute__((__nothrow__)) ;
#line 588
extern double ( __attribute__((__nonnull__(1), __leaf__)) erand48)(unsigned short *__xsubi )  __attribute__((__nothrow__)) ;
#line 591
extern long ( __attribute__((__leaf__)) lrand48)(void)  __attribute__((__nothrow__)) ;
#line 592
extern long ( __attribute__((__nonnull__(1), __leaf__)) nrand48)(unsigned short *__xsubi )  __attribute__((__nothrow__)) ;
#line 596
extern long ( __attribute__((__leaf__)) mrand48)(void)  __attribute__((__nothrow__)) ;
#line 597
extern long ( __attribute__((__nonnull__(1), __leaf__)) jrand48)(unsigned short *__xsubi )  __attribute__((__nothrow__)) ;
#line 601
extern void ( __attribute__((__leaf__)) srand48)(long __seedval )  __attribute__((__nothrow__)) ;
#line 602
extern unsigned short *( __attribute__((__nonnull__(1), __leaf__)) seed48)(unsigned short *__seed16v )  __attribute__((__nothrow__)) ;
#line 604
extern void ( __attribute__((__nonnull__(1), __leaf__)) lcong48)(unsigned short *__param )  __attribute__((__nothrow__)) ;
#line 621
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) drand48_r)(struct drand48_data * __restrict  __buffer ,
                                                                    double * __restrict  __result )  __attribute__((__nothrow__)) ;
#line 623
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) erand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data * __restrict  __buffer ,
                                                                    double * __restrict  __result )  __attribute__((__nothrow__)) ;
#line 628
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lrand48_r)(struct drand48_data * __restrict  __buffer ,
                                                                    long * __restrict  __result )  __attribute__((__nothrow__)) ;
#line 631
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) nrand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data * __restrict  __buffer ,
                                                                    long * __restrict  __result )  __attribute__((__nothrow__)) ;
#line 637
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) mrand48_r)(struct drand48_data * __restrict  __buffer ,
                                                                    long * __restrict  __result )  __attribute__((__nothrow__)) ;
#line 640
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) jrand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data * __restrict  __buffer ,
                                                                    long * __restrict  __result )  __attribute__((__nothrow__)) ;
#line 646
extern int ( __attribute__((__nonnull__(2), __leaf__)) srand48_r)(long __seedval ,
                                                                  struct drand48_data *__buffer )  __attribute__((__nothrow__)) ;
#line 649
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) seed48_r)(unsigned short *__seed16v ,
                                                                   struct drand48_data *__buffer )  __attribute__((__nothrow__)) ;
#line 652
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lcong48_r)(unsigned short *__param ,
                                                                    struct drand48_data *__buffer )  __attribute__((__nothrow__)) ;
#line 657
extern __uint32_t ( __attribute__((__warn_unused_result__, __leaf__)) arc4random)(void)  __attribute__((__nothrow__)) ;
#line 661
extern void ( __attribute__((__nonnull__(1), __leaf__)) arc4random_buf)(void *__buf ,
                                                                        size_t __size )  __attribute__((__nothrow__)) ;
#line 666
extern __uint32_t ( __attribute__((__warn_unused_result__, __leaf__)) arc4random_uniform)(__uint32_t __upper_bound )  __attribute__((__nothrow__)) ;
#line 672
extern void *( __attribute__((__warn_unused_result__, __leaf__)) malloc)(size_t __size )  __attribute__((__nothrow__,
__malloc__, __alloc_size__(1))) ;
#line 675
extern void *( __attribute__((__warn_unused_result__, __leaf__)) calloc)(size_t __nmemb ,
                                                                         size_t __size )  __attribute__((__nothrow__,
__malloc__, __alloc_size__(1,2))) ;
#line 683
extern void *( __attribute__((__warn_unused_result__, __leaf__)) realloc)(void *__ptr ,
                                                                          size_t __size )  __attribute__((__nothrow__,
__alloc_size__(2))) ;
#line 687
extern void ( __attribute__((__leaf__)) free)(void *__ptr )  __attribute__((__nothrow__)) ;
#line 695
extern void *( __attribute__((__warn_unused_result__, __leaf__)) reallocarray)(void *__ptr ,
                                                                               size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__nothrow__,
__malloc__(__builtin_free,1), __malloc__(reallocarray,1), __alloc_size__(2,3))) ;
#line 32 "/usr/include/alloca.h"
extern void *( __attribute__((__leaf__)) alloca)(size_t __size )  __attribute__((__nothrow__)) ;
#line 712 "/usr/include/stdlib.h"
extern void *( __attribute__((__warn_unused_result__, __leaf__)) valloc)(size_t __size )  __attribute__((__nothrow__,
__malloc__, __alloc_size__(1))) ;
#line 718
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) posix_memalign)(void **__memptr ,
                                                                                               size_t __alignment ,
                                                                                               size_t __size )  __attribute__((__nothrow__)) ;
#line 724
extern void *( __attribute__((__warn_unused_result__, __leaf__)) aligned_alloc)(size_t __alignment ,
                                                                                size_t __size )  __attribute__((__nothrow__,
__malloc__, __alloc_size__(2), __alloc_align__(1))) ;
#line 730
extern void ( __attribute__((__leaf__)) abort)(void)  __attribute__((__nothrow__,
__noreturn__)) ;
#line 734
extern int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) )  __attribute__((__nothrow__)) ;
#line 742
extern int ( __attribute__((__nonnull__(1), __leaf__)) at_quick_exit)(void (*__func)(void) )  __attribute__((__nothrow__)) ;
#line 749
extern int ( __attribute__((__nonnull__(1), __leaf__)) on_exit)(void (*__func)(int __status ,
                                                                               void *__arg ) ,
                                                                void *__arg )  __attribute__((__nothrow__)) ;
#line 756
extern void ( __attribute__((__leaf__)) exit)(int __status )  __attribute__((__nothrow__,
__noreturn__)) ;
#line 762
extern void ( __attribute__((__leaf__)) quick_exit)(int __status )  __attribute__((__nothrow__,
__noreturn__)) ;
#line 768
extern void ( __attribute__((__leaf__)) _Exit)(int __status )  __attribute__((__nothrow__,
__noreturn__)) ;
#line 773
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) getenv)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 778
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) secure_getenv)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 786
extern int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string )  __attribute__((__nothrow__)) ;
#line 792
extern int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                               char const   *__value ,
                                                               int __replace )  __attribute__((__nothrow__)) ;
#line 796
extern int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 803
extern int ( __attribute__((__leaf__)) clearenv)(void)  __attribute__((__nothrow__)) ;
#line 814
extern char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template )  __attribute__((__nothrow__)) ;
#line 827
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemp)(char *__template ) ;
#line 837
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemp64)(char *__template ) ;
#line 849
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemps)(char *__template ,
                                                                               int __suffixlen ) ;
#line 859
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemps64)(char *__template ,
                                                                                 int __suffixlen ) ;
#line 870
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) mkdtemp)(char *__template )  __attribute__((__nothrow__)) ;
#line 881
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemp)(char *__template ,
                                                                               int __flags ) ;
#line 891
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemp64)(char *__template ,
                                                                                 int __flags ) ;
#line 901
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemps)(char *__template ,
                                                                                int __suffixlen ,
                                                                                int __flags ) ;
#line 913
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemps64)(char *__template ,
                                                                                  int __suffixlen ,
                                                                                  int __flags ) ;
#line 923
extern int ( __attribute__((__warn_unused_result__)) system)(char const   *__command ) ;
#line 929
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) canonicalize_file_name)(char const   *__name )  __attribute__((__nothrow__,
__malloc__(__builtin_free,1), __malloc__)) ;
#line 940
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const   *__name , char *__resolved )  __attribute__((__nothrow__)) ;
#line 960
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch___0)(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch___0)(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , int (*__compar)(void const   * , void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 44
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((void *)0);
}
}
#line 970 "/usr/include/stdlib.h"
void ( __attribute__((__nonnull__(1,4))) qsort)(void *ptr , size_t count , size_t size ,
                                                int (*comp)(void const   * , void const   * ) )  __attribute__((__goblint_stub__)) ;
#line 973
extern void ( __attribute__((__nonnull__(1,4))) qsort_r)(void *__base , size_t __nmemb ,
                                                         size_t __size , int (*__compar)(void const   * ,
                                                                                         void const   * ,
                                                                                         void * ) ,
                                                         void *__arg ) ;
#line 980
extern int ( __attribute__((__warn_unused_result__, __leaf__)) abs)(int __x )  __attribute__((__nothrow__,
__const__)) ;
#line 981
extern long ( __attribute__((__warn_unused_result__, __leaf__)) labs)(long __x )  __attribute__((__nothrow__,
__const__)) ;
#line 984
extern long long ( __attribute__((__warn_unused_result__, __leaf__)) llabs)(long long __x )  __attribute__((__nothrow__,
__const__)) ;
#line 992
extern div_t ( __attribute__((__warn_unused_result__, __leaf__)) div)(int __numer ,
                                                                      int __denom )  __attribute__((__nothrow__,
__const__)) ;
#line 994
extern ldiv_t ( __attribute__((__warn_unused_result__, __leaf__)) ldiv)(long __numer ,
                                                                        long __denom )  __attribute__((__nothrow__,
__const__)) ;
#line 998
extern lldiv_t ( __attribute__((__warn_unused_result__, __leaf__)) lldiv)(long long __numer ,
                                                                          long long __denom )  __attribute__((__nothrow__,
__const__)) ;
#line 1012
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) ecvt)(double __value ,
                                                                                         int __ndigit ,
                                                                                         int * __restrict  __decpt ,
                                                                                         int * __restrict  __sign )  __attribute__((__nothrow__)) ;
#line 1018
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) fcvt)(double __value ,
                                                                                         int __ndigit ,
                                                                                         int * __restrict  __decpt ,
                                                                                         int * __restrict  __sign )  __attribute__((__nothrow__)) ;
#line 1024
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3), __leaf__)) gcvt)(double __value ,
                                                                                       int __ndigit ,
                                                                                       char *__buf )  __attribute__((__nothrow__)) ;
#line 1030
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) qecvt)(long double __value ,
                                                                                          int __ndigit ,
                                                                                          int * __restrict  __decpt ,
                                                                                          int * __restrict  __sign )  __attribute__((__nothrow__)) ;
#line 1033
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) qfcvt)(long double __value ,
                                                                                          int __ndigit ,
                                                                                          int * __restrict  __decpt ,
                                                                                          int * __restrict  __sign )  __attribute__((__nothrow__)) ;
#line 1036
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3), __leaf__)) qgcvt)(long double __value ,
                                                                                        int __ndigit ,
                                                                                        char *__buf )  __attribute__((__nothrow__)) ;
#line 1042
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) ecvt_r)(double __value ,
                                                                   int __ndigit ,
                                                                   int * __restrict  __decpt ,
                                                                   int * __restrict  __sign ,
                                                                   char * __restrict  __buf ,
                                                                   size_t __len )  __attribute__((__nothrow__)) ;
#line 1045
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) fcvt_r)(double __value ,
                                                                   int __ndigit ,
                                                                   int * __restrict  __decpt ,
                                                                   int * __restrict  __sign ,
                                                                   char * __restrict  __buf ,
                                                                   size_t __len )  __attribute__((__nothrow__)) ;
#line 1049
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) qecvt_r)(long double __value ,
                                                                    int __ndigit ,
                                                                    int * __restrict  __decpt ,
                                                                    int * __restrict  __sign ,
                                                                    char * __restrict  __buf ,
                                                                    size_t __len )  __attribute__((__nothrow__)) ;
#line 1053
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) qfcvt_r)(long double __value ,
                                                                    int __ndigit ,
                                                                    int * __restrict  __decpt ,
                                                                    int * __restrict  __sign ,
                                                                    char * __restrict  __buf ,
                                                                    size_t __len )  __attribute__((__nothrow__)) ;
#line 1062
extern int ( __attribute__((__leaf__)) mblen)(char const   *__s , size_t __n )  __attribute__((__nothrow__)) ;
#line 1065
extern int ( __attribute__((__leaf__)) mbtowc)(wchar_t * __restrict  __pwc , char const   * __restrict  __s ,
                                               size_t __n )  __attribute__((__nothrow__)) ;
#line 1069
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 1073
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__,
__access__(__read_only__,2))) ;
#line 1077
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__,
__access__(__read_only__,2))) ;
#line 1088
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) rpmatch)(char const   *__response )  __attribute__((__nothrow__)) ;
#line 1099
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,2,3), __leaf__)) getsubopt)(char ** __restrict  __optionp ,
                                                                                              char ** __restrict  __tokens ,
                                                                                              char ** __restrict  __valuep )  __attribute__((__nothrow__)) ;
#line 1110
extern int ( __attribute__((__warn_unused_result__)) posix_openpt)(int __oflag ) ;
#line 1118
extern int ( __attribute__((__leaf__)) grantpt)(int __fd )  __attribute__((__nothrow__)) ;
#line 1122
extern int ( __attribute__((__leaf__)) unlockpt)(int __fd )  __attribute__((__nothrow__)) ;
#line 1127
extern char *( __attribute__((__warn_unused_result__, __leaf__)) ptsname)(int __fd )  __attribute__((__nothrow__)) ;
#line 1134
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 1138
extern int getpt(void) ;
#line 1145
extern int ( __attribute__((__nonnull__(1), __leaf__)) getloadavg)(double *__loadavg ,
                                                                   int __nelem )  __attribute__((__nothrow__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
#line 27
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
#line 27
  return (tmp);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __realpath_chk)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ,
                                                                                 size_t __resolvedlen )  __attribute__((__nothrow__)) ;
#line 26
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __realpath_alias)(char const   * __restrict  __name ,
                                                                                   char * __restrict  __resolved )  __asm__("realpath") __attribute__((__nothrow__)) ;
#line 29
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __realpath_chk_warn)(char const   * __restrict  __name ,
                                                                                      char * __restrict  __resolved ,
                                                                                      size_t __resolvedlen )  __asm__("__realpath_chk") __attribute__((__warning__("second argument of realpath must be either NULL or at least PATH_MAX bytes long buffer"),
__nothrow__)) ;
#line 36
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const   *__name , char *__resolved )  __attribute__((__nothrow__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const   *__name , char *__resolved ) 
{ 
  size_t __sz ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 46
  tmp = __builtin_dynamic_object_size(__resolved, 1);
#line 46
  __sz = (size_t )tmp;
#line 48
  if (__sz == 18446744073709551615UL) {
#line 49
    tmp___0 = __realpath_alias((char const   * __restrict  )__name, (char * __restrict  )__resolved);
#line 49
    return (tmp___0);
  }
#line 55
  tmp___1 = __realpath_chk((char const   * __restrict  )__name, (char * __restrict  )__resolved,
                           __sz);
#line 55
  return (tmp___1);
}
}
#line 59
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                        char *__buf ,
                                                                        size_t __buflen ,
                                                                        size_t __nreal )  __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 62
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                          char *__buf ,
                                                                          size_t __buflen )  __asm__("ptsname_r") __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 65
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                             char *__buf ,
                                                                             size_t __buflen ,
                                                                             size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"),
__nothrow__)) ;
#line 71
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 71 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 79
  if (0) {
#line 79
    tmp___15 = __builtin_dynamic_object_size(__buf, 1);
#line 79
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 79
      goto _L___3;
    } else {
#line 79
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 79
  if (1) {
#line 79
    goto _L___6;
  } else
#line 79
  if (0) {
#line 79
    if (__buflen > 0UL) {
      _L___6: /* CIL Label */ 
#line 79
      if (0) {
#line 79
        tmp___17 = __builtin_dynamic_object_size(__buf, 1);
#line 79
        if (__buflen <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 79
          tmp___3 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 79
          tmp___13 = tmp___3;
        } else {
#line 79
          goto _L___7;
        }
      } else {
#line 79
        goto _L___7;
      }
    } else {
#line 79
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 79
    if (1) {
#line 79
      goto _L___1;
    } else
#line 79
    if (0) {
#line 79
      if (__buflen > 0UL) {
        _L___1: /* CIL Label */ 
#line 79
        if (0) {
#line 79
          tmp___12 = __builtin_dynamic_object_size(__buf, 1);
#line 79
          if (__buflen <= (unsigned long )tmp___12 / sizeof(char )) {
#line 79
            goto _L___2;
          } else {
#line 79
            tmp___6 = __builtin_dynamic_object_size(__buf, 1);
#line 79
            tmp___7 = __ptsname_r_chk_warn(__fd, __buf, __buflen, (size_t )tmp___6);
#line 79
            tmp___10 = tmp___7;
          }
        } else {
#line 79
          goto _L___2;
        }
      } else {
#line 79
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 79
      tmp___8 = __builtin_dynamic_object_size(__buf, 1);
#line 79
      tmp___9 = __ptsname_r_chk(__fd, __buf, __buflen, (size_t )tmp___8);
#line 79
      tmp___10 = tmp___9;
    }
#line 79
    tmp___13 = tmp___10;
  }
#line 79
  return (tmp___13);
}
}
#line 85
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __wctomb_chk)(char *__s ,
                                                                             wchar_t __wchar ,
                                                                             size_t __buflen )  __attribute__((__nothrow__)) ;
#line 87
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __wctomb_alias)(char *__s ,
                                                                               wchar_t __wchar )  __asm__("wctomb") __attribute__((__nothrow__)) ;
#line 90
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 90 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 100
  tmp___1 = __builtin_dynamic_object_size(__s, 1);
#line 100
  if ((size_t )tmp___1 != 18446744073709551615UL) {
#line 100
    tmp___2 = __builtin_dynamic_object_size(__s, 1);
#line 100
    if (16 > tmp___2) {
#line 102
      tmp = __builtin_dynamic_object_size(__s, 1);
#line 102
      tmp___0 = __wctomb_chk(__s, __wchar, (size_t )tmp);
#line 102
      return (tmp___0);
    } else {
#line 100
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 103
  tmp___3 = __wctomb_alias(__s, __wchar);
#line 103
  return (tmp___3);
}
}
#line 107
extern size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t * __restrict  __dst ,
                                                          char const   * __restrict  __src ,
                                                          size_t __len , size_t __dstlen )  __attribute__((__nothrow__,
__access__(__read_only__,2), __access__(__write_only__,1,3))) ;
#line 111
extern size_t ( __attribute__((__leaf__)) __mbstowcs_nulldst)(wchar_t * __restrict  __dst ,
                                                              char const   * __restrict  __src ,
                                                              size_t __len )  __asm__("mbstowcs") __attribute__((__nothrow__,
__access__(__read_only__,2))) ;
#line 116
extern size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t * __restrict  __dst ,
                                                            char const   * __restrict  __src ,
                                                            size_t __len )  __asm__("mbstowcs") __attribute__((__nothrow__,
__access__(__read_only__,2), __access__(__write_only__,1,3))) ;
#line 121
extern size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t * __restrict  __dst ,
                                                               char const   * __restrict  __src ,
                                                               size_t __len , size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"),
__nothrow__)) ;
#line 128
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__,
__access__(__read_only__,2))) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 136
  if (0) {
#line 136
    if ((unsigned long )__dst == (unsigned long )((void *)0)) {
#line 137
      tmp = __mbstowcs_nulldst((wchar_t * __restrict  )__dst, (char const   * __restrict  )__src,
                               __len);
#line 137
      return (tmp);
    } else {
#line 136
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ 
#line 139
    if (0) {
#line 139
      tmp___16 = __builtin_dynamic_object_size(__dst, 1);
#line 139
      if ((unsigned long )tmp___16 == 18446744073709551615UL) {
#line 139
        goto _L___3;
      } else {
#line 139
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 139
    if (1) {
#line 139
      goto _L___6;
    } else
#line 139
    if (0) {
#line 139
      if (__len > 0UL) {
        _L___6: /* CIL Label */ 
#line 139
        if (0) {
#line 139
          tmp___18 = __builtin_dynamic_object_size(__dst, 1);
#line 139
          if (__len <= (unsigned long )tmp___18 / sizeof(wchar_t )) {
            _L___3: /* CIL Label */ 
#line 139
            tmp___4 = __mbstowcs_alias((wchar_t * __restrict  )__dst, (char const   * __restrict  )__src,
                                       __len);
#line 139
            tmp___14 = tmp___4;
          } else {
#line 139
            goto _L___7;
          }
        } else {
#line 139
          goto _L___7;
        }
      } else {
#line 139
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
      _L___5: /* CIL Label */ 
      _L___4: /* CIL Label */ 
#line 139
      if (1) {
#line 139
        goto _L___1;
      } else
#line 139
      if (0) {
#line 139
        if (__len > 0UL) {
          _L___1: /* CIL Label */ 
#line 139
          if (0) {
#line 139
            tmp___13 = __builtin_dynamic_object_size(__dst, 1);
#line 139
            if (__len <= (unsigned long )tmp___13 / sizeof(wchar_t )) {
#line 139
              goto _L___2;
            } else {
#line 139
              tmp___7 = __builtin_dynamic_object_size(__dst, 1);
#line 139
              tmp___8 = __mbstowcs_chk_warn((wchar_t * __restrict  )__dst, (char const   * __restrict  )__src,
                                            __len, (unsigned long )tmp___7 / sizeof(wchar_t ));
#line 139
              tmp___11 = tmp___8;
            }
          } else {
#line 139
            goto _L___2;
          }
        } else {
#line 139
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        _L___0: /* CIL Label */ 
        _L: /* CIL Label */ 
#line 139
        tmp___9 = __builtin_dynamic_object_size(__dst, 1);
#line 139
        tmp___10 = __mbstowcs_chk((wchar_t * __restrict  )__dst, (char const   * __restrict  )__src,
                                  __len, (unsigned long )tmp___9 / sizeof(wchar_t ));
#line 139
        tmp___11 = tmp___10;
      }
#line 139
      tmp___14 = tmp___11;
    }
#line 139
    return (tmp___14);
  }
}
}
#line 143
extern size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char * __restrict  __dst ,
                                                          wchar_t const   * __restrict  __src ,
                                                          size_t __len , size_t __dstlen )  __attribute__((__nothrow__,
__access__(__read_only__,2), __access__(__write_only__,1,3))) ;
#line 147
extern size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char * __restrict  __dst ,
                                                            wchar_t const   * __restrict  __src ,
                                                            size_t __len )  __asm__("wcstombs") __attribute__((__nothrow__,
__access__(__read_only__,2), __access__(__write_only__,1,3))) ;
#line 152
extern size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char * __restrict  __dst ,
                                                               wchar_t const   * __restrict  __src ,
                                                               size_t __len , size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"),
__nothrow__)) ;
#line 158
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__,
__access__(__read_only__,2))) ;
#line 158 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 163
  if (0) {
#line 163
    tmp___15 = __builtin_dynamic_object_size(__dst, 1);
#line 163
    if ((unsigned long )tmp___15 == 18446744073709551615UL) {
#line 163
      goto _L___3;
    } else {
#line 163
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 163
  if (1) {
#line 163
    goto _L___6;
  } else
#line 163
  if (0) {
#line 163
    if (__len > 0UL) {
      _L___6: /* CIL Label */ 
#line 163
      if (0) {
#line 163
        tmp___17 = __builtin_dynamic_object_size(__dst, 1);
#line 163
        if (__len <= (unsigned long )tmp___17 / sizeof(char )) {
          _L___3: /* CIL Label */ 
#line 163
          tmp___3 = __wcstombs_alias((char * __restrict  )__dst, (wchar_t const   * __restrict  )__src,
                                     __len);
#line 163
          tmp___13 = tmp___3;
        } else {
#line 163
          goto _L___7;
        }
      } else {
#line 163
        goto _L___7;
      }
    } else {
#line 163
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
#line 163
    if (1) {
#line 163
      goto _L___1;
    } else
#line 163
    if (0) {
#line 163
      if (__len > 0UL) {
        _L___1: /* CIL Label */ 
#line 163
        if (0) {
#line 163
          tmp___12 = __builtin_dynamic_object_size(__dst, 1);
#line 163
          if (__len <= (unsigned long )tmp___12 / sizeof(char )) {
#line 163
            goto _L___2;
          } else {
#line 163
            tmp___6 = __builtin_dynamic_object_size(__dst, 1);
#line 163
            tmp___7 = __wcstombs_chk_warn((char * __restrict  )__dst, (wchar_t const   * __restrict  )__src,
                                          __len, (size_t )tmp___6);
#line 163
            tmp___10 = tmp___7;
          }
        } else {
#line 163
          goto _L___2;
        }
      } else {
#line 163
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 163
      tmp___8 = __builtin_dynamic_object_size(__dst, 1);
#line 163
      tmp___9 = __wcstombs_chk((char * __restrict  )__dst, (wchar_t const   * __restrict  )__src,
                               __len, (size_t )tmp___8);
#line 163
      tmp___10 = tmp___9;
    }
#line 163
    tmp___13 = tmp___10;
  }
#line 163
  return (tmp___13);
}
}
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 54
extern void *( __attribute__((__nonnull__(1,2), __leaf__)) memccpy)(void * __restrict  __dest ,
                                                                    void const   * __restrict  __src ,
                                                                    int __c , size_t __n )  __attribute__((__nothrow__,
__access__(__write_only__,1,4))) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 64
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                 void const   *__s2 ,
                                                                 size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 80
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) __memcmpeq)(void const   *__s1 ,
                                                                     void const   *__s2 ,
                                                                     size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 107
extern void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                 int __c , size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 120
extern void *( __attribute__((__nonnull__(1), __leaf__)) rawmemchr)(void const   *__s ,
                                                                    int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 133
extern void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                  int __c , size_t __n )  __attribute__((__pure__,
__nothrow__, __access__(__read_only__,1,3))) ;
#line 141
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 144
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 149
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 152
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 156
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                 char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 159
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                  char const   *__s2 ,
                                                                  size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 163
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const   *__s1 ,
                                                                  char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 166
extern size_t ( __attribute__((__nonnull__(2), __leaf__)) strxfrm)(char * __restrict  __dest ,
                                                                   char const   * __restrict  __src ,
                                                                   size_t __n )  __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
#line 175
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) strcoll_l)(char const   *__s1 ,
                                                                      char const   *__s2 ,
                                                                      locale_t __l )  __attribute__((__pure__,
__nothrow__)) ;
#line 179
extern size_t ( __attribute__((__nonnull__(2,4), __leaf__)) strxfrm_l)(char *__dest ,
                                                                       char const   *__src ,
                                                                       size_t __n ,
                                                                       locale_t __l )  __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
#line 187
extern char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__nothrow__,
__malloc__)) ;
#line 195
extern char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                  size_t __n )  __attribute__((__nothrow__,
__malloc__)) ;
#line 246
extern char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                 int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 273
extern char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                  int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 286
extern char *( __attribute__((__nonnull__(1), __leaf__)) strchrnul)(char const   *__s ,
                                                                    int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 293
extern size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                     char const   *__reject )  __attribute__((__pure__,
__nothrow__)) ;
#line 297
extern size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                    char const   *__accept )  __attribute__((__pure__,
__nothrow__)) ;
#line 323
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                    char const   *__accept )  __attribute__((__pure__,
__nothrow__)) ;
#line 350
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                   char const   *__needle )  __attribute__((__pure__,
__nothrow__)) ;
#line 356
extern char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                 char const   * __restrict  __delim )  __attribute__((__nothrow__)) ;
#line 361
extern char *( __attribute__((__nonnull__(2,3), __leaf__)) __strtok_r)(char * __restrict  __s ,
                                                                       char const   * __restrict  __delim ,
                                                                       char ** __restrict  __save_ptr )  __attribute__((__nothrow__)) ;
#line 366
extern char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                     char const   * __restrict  __delim ,
                                                                     char ** __restrict  __save_ptr )  __attribute__((__nothrow__)) ;
#line 380
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strcasestr)(char const   *__haystack ,
                                                                       char const   *__needle )  __attribute__((__pure__,
__nothrow__)) ;
#line 389
extern void *( __attribute__((__nonnull__(1,3), __leaf__)) memmem)(void const   *__haystack ,
                                                                   size_t __haystacklen ,
                                                                   void const   *__needle ,
                                                                   size_t __needlelen )  __attribute__((__pure__,
__nothrow__, __access__(__read_only__,3,4), __access__(__read_only__,1,2))) ;
#line 397
extern void *( __attribute__((__nonnull__(1,2), __leaf__)) __mempcpy)(void * __restrict  __dest ,
                                                                      void const   * __restrict  __src ,
                                                                      size_t __n )  __attribute__((__nothrow__)) ;
#line 400
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mempcpy)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 407
extern size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__,
__nothrow__)) ;
#line 413
extern size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                   size_t __maxlen )  __attribute__((__pure__,
__nothrow__)) ;
#line 419
extern char *( __attribute__((__leaf__)) strerror)(int __errnum )  __attribute__((__nothrow__)) ;
#line 444
extern char *( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__)) strerror_r)(int __errnum ,
                                                                                             char *__buf ,
                                                                                             size_t __buflen )  __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 450
extern char const   *( __attribute__((__leaf__)) strerrordesc_np)(int __err )  __attribute__((__nothrow__)) ;
#line 452
extern char const   *( __attribute__((__leaf__)) strerrorname_np)(int __err )  __attribute__((__nothrow__)) ;
#line 458
extern char *( __attribute__((__leaf__)) strerror_l)(int __errnum , locale_t __l )  __attribute__((__nothrow__)) ;
#line 34 "/usr/include/strings.h"
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) bcmp)(void const   *__s1 ,
                                                               void const   *__s2 ,
                                                               size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 38
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 42
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 68
extern char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 96
extern char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                 int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 104
extern int ( __attribute__((__leaf__)) ffs)(int __i )  __attribute__((__nothrow__,
__const__)) ;
#line 110
extern int ( __attribute__((__leaf__)) ffsl)(long __l )  __attribute__((__nothrow__,
__const__)) ;
#line 111
extern int ( __attribute__((__leaf__)) ffsll)(long long __ll )  __attribute__((__nothrow__,
__const__)) ;
#line 116
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                     char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 120
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                      char const   *__s2 ,
                                                                      size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 128
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) strcasecmp_l)(char const   *__s1 ,
                                                                         char const   *__s2 ,
                                                                         locale_t __loc )  __attribute__((__pure__,
__nothrow__)) ;
#line 133
extern int ( __attribute__((__nonnull__(1,2,4), __leaf__)) strncasecmp_l)(char const   *__s1 ,
                                                                          char const   *__s2 ,
                                                                          size_t __n ,
                                                                          locale_t __loc )  __attribute__((__pure__,
__nothrow__)) ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len ) 
{ 
  int tmp ;

  {
#line 25
  tmp = __builtin_dynamic_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, (unsigned long )tmp);
#line 27
  return;
}
}
#line 29
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len ) 
{ 
  int tmp ;

  {
#line 32
  tmp = __builtin_dynamic_object_size(__dest, 0);
#line 32
  __builtin___memset_chk(__dest, '\000', __len, (unsigned long )tmp);
#line 34
  return;
}
}
#line 466 "/usr/include/string.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 471
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strsep)(char ** __restrict  __stringp ,
                                                                   char const   * __restrict  __delim )  __attribute__((__nothrow__)) ;
#line 478
extern char *( __attribute__((__leaf__)) strsignal)(int __sig )  __attribute__((__nothrow__)) ;
#line 482
extern char const   *( __attribute__((__leaf__)) sigabbrev_np)(int __sig )  __attribute__((__nothrow__)) ;
#line 485
extern char const   *( __attribute__((__leaf__)) sigdescr_np)(int __sig )  __attribute__((__nothrow__)) ;
#line 489
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) __stpcpy)(char * __restrict  __dest ,
                                                                     char const   * __restrict  __src )  __attribute__((__nothrow__)) ;
#line 491
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 496
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) __stpncpy)(char * __restrict  __dest ,
                                                                      char const   * __restrict  __src ,
                                                                      size_t __n )  __attribute__((__nothrow__)) ;
#line 499
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                             size_t __n )  __attribute__((__nothrow__)) ;
#line 506
__inline extern size_t ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strlcpy)(char *__dest , char const   *__src ,
                                             size_t __n )  __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
#line 512
__inline extern size_t ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strlcat)(char *__dest , char const   *__src ,
                                             size_t __n )  __attribute__((__nothrow__,
__access__(__read_write__,1,3))) ;
#line 519
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strverscmp)(char const   *__s1 ,
                                                                     char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 523
extern char *( __attribute__((__nonnull__(1), __leaf__)) strfry)(char *__string )  __attribute__((__nothrow__)) ;
#line 526
extern void *( __attribute__((__nonnull__(1), __leaf__)) memfrob)(void *__s , size_t __n )  __attribute__((__nothrow__,
__access__(__read_write__,1,2))) ;
#line 540
extern char *( __attribute__((__nonnull__(1), __leaf__)) basename)(char const   *__filename )  __attribute__((__nothrow__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 29
  tmp = __builtin_dynamic_object_size(__dest, 0);
#line 29
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, (unsigned long )tmp);
#line 29
  return (tmp___0);
}
}
#line 33
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 36
  tmp = __builtin_dynamic_object_size(__dest, 0);
#line 36
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, (unsigned long )tmp);
#line 36
  return (tmp___0);
}
}
#line 41
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mempcpy)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mempcpy)(void *__dest , void const   *__src ,
                                             size_t __len ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 45
  tmp = __builtin_dynamic_object_size(__dest, 0);
#line 45
  tmp___0 = __builtin___mempcpy_chk(__dest, __src, __len, (unsigned long )tmp);
#line 45
  return (tmp___0);
}
}
#line 56
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 59
  tmp = __builtin_dynamic_object_size(__dest, 0);
#line 59
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, (unsigned long )tmp);
#line 59
  return (tmp___0);
}
}
#line 66
extern void ( __attribute__((__nonnull__(1), __leaf__)) __explicit_bzero_chk)(void *__dest ,
                                                                              size_t __len ,
                                                                              size_t __destlen )  __attribute__((__nothrow__)) ;
#line 69
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 69 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len ) 
{ 
  int tmp ;

  {
#line 72
  tmp = __builtin_dynamic_object_size(__dest, 0);
#line 72
  __explicit_bzero_chk(__dest, __len, (size_t )tmp);
#line 73
  return;
}
}
#line 76
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 76 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 81
  tmp = __builtin_dynamic_object_size(__dest, 1);
#line 81
  tmp___0 = __builtin___strcpy_chk(__dest, __src, (unsigned long )tmp);
#line 81
  return (tmp___0);
}
}
#line 85
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 85 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpcpy)(char *__dest , char const   *__src ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 90
  tmp = __builtin_dynamic_object_size(__dest, 1);
#line 90
  tmp___0 = __builtin___stpcpy_chk(__dest, __src, (unsigned long )tmp);
#line 90
  return (tmp___0);
}
}
#line 95
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 100
  tmp = __builtin_dynamic_object_size(__dest, 1);
#line 100
  tmp___0 = __builtin___strncpy_chk(__dest, __src, __len, (unsigned long )tmp);
#line 100
  return (tmp___0);
}
}
#line 111
extern int ( /* missing proto */  __builtin___stpncpy_chk)() ;
#line 106
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                             size_t __n )  __attribute__((__nothrow__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                             size_t __n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 111
  tmp = __builtin_dynamic_object_size(__dest, 1);
#line 111
  tmp___0 = __builtin___stpncpy_chk(__dest, __src, __n, tmp);
#line 111
  return ((char *)tmp___0);
}
}
#line 135
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 140
  tmp = __builtin_dynamic_object_size(__dest, 1);
#line 140
  tmp___0 = __builtin___strcat_chk(__dest, __src, (unsigned long )tmp);
#line 140
  return (tmp___0);
}
}
#line 144
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 149
  tmp = __builtin_dynamic_object_size(__dest, 1);
#line 149
  tmp___0 = __builtin___strncat_chk(__dest, __src, __len, (unsigned long )tmp);
#line 149
  return (tmp___0);
}
}
#line 154
extern size_t ( __attribute__((__leaf__)) __strlcpy_chk)(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen )  __attribute__((__nothrow__)) ;
#line 156
extern size_t ( __attribute__((__leaf__)) __strlcpy_alias)(char *__dest , char const   *__src ,
                                                           size_t __n )  __asm__("strlcpy") __attribute__((__nothrow__)) ;
#line 160
__inline extern size_t ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strlcpy)(char *__dest , char const   *__src ,
                                             size_t __n )  __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
#line 160 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern size_t ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strlcpy)(char *__dest , char const   *__src ,
                                             size_t __n ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 165
  tmp___1 = __builtin_dynamic_object_size(__dest, 1);
#line 165
  if ((size_t )tmp___1 != 18446744073709551615UL) {
#line 165
    if (1) {
#line 165
      goto _L___0;
    } else {
#line 165
      tmp___3 = __builtin_dynamic_object_size(__dest, 1);
#line 165
      if (__n > (size_t )tmp___3) {
        _L___0: /* CIL Label */ 
#line 168
        tmp = __builtin_dynamic_object_size(__dest, 1);
#line 168
        tmp___0 = __strlcpy_chk(__dest, __src, __n, (size_t )tmp);
#line 168
        return (tmp___0);
      } else {
#line 165
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 169
  tmp___4 = __strlcpy_alias(__dest, __src, __n);
#line 169
  return (tmp___4);
}
}
#line 172
extern size_t ( __attribute__((__leaf__)) __strlcat_chk)(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen )  __attribute__((__nothrow__)) ;
#line 174
extern size_t ( __attribute__((__leaf__)) __strlcat_alias)(char *__dest , char const   *__src ,
                                                           size_t __n )  __asm__("strlcat") __attribute__((__nothrow__)) ;
#line 178
__inline extern size_t ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strlcat)(char *__dest , char const   *__src ,
                                             size_t __n )  __attribute__((__nothrow__,
__access__(__read_write__,1,3))) ;
#line 178 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern size_t ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strlcat)(char *__dest , char const   *__src ,
                                             size_t __n ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 182
  tmp___1 = __builtin_dynamic_object_size(__dest, 1);
#line 182
  if ((size_t )tmp___1 != 18446744073709551615UL) {
#line 182
    if (1) {
#line 182
      goto _L___0;
    } else {
#line 182
      tmp___3 = __builtin_dynamic_object_size(__dest, 1);
#line 182
      if (__n > (size_t )tmp___3) {
        _L___0: /* CIL Label */ 
#line 185
        tmp = __builtin_dynamic_object_size(__dest, 1);
#line 185
        tmp___0 = __strlcat_chk(__dest, __src, __n, (size_t )tmp);
#line 185
        return (tmp___0);
      } else {
#line 182
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 186
  tmp___4 = __strlcat_alias(__dest, __src, __n);
#line 186
  return (tmp___4);
}
}
#line 44 "lock.h"
__inline static void LockX86(int volatile   *lock ) 
{ 
  int dummy ;

  {
#line 46
  __asm__  volatile   ("1:          movl    $1, %0"
                       "\n\t"
                       "            xchgl   (%1), %0"
                       "\n\t"
                       "            testl   %0, %0"
                       "\n\t"
                       "            jz      3f"
                       "\n\t"
                       "2:          pause"
                       "\n\t"
                       "            movl    (%1), %0"
                       "\n\t"
                       "            testl   %0, %0"
                       "\n\t"
                       "            jnz     2b"
                       "\n\t"
                       "            jmp     1b"
                       "\n\t"
                       "3:"
                       "\n\t": "=&q" (dummy): "q" (lock): "cc", "memory");
#line 60
  return;
}
}
#line 61 "lock.h"
__inline static void Pause(void) 
{ 


  {
#line 62
  __asm__  volatile   ("            pause"
                       "\n\t":);
#line 64
  return;
}
}
#line 65 "lock.h"
__inline static void UnlockX86(int volatile   *lock ) 
{ 


  {
#line 66
  __asm__  volatile   ("movl        $0, (%0)": : "q" (lock): "memory");
#line 71
  return;
}
}
#line 327 "chess.h"
void AlignedMalloc(void **pointer , uint64_t alignment , size_t size ) ;
#line 328
void AlignedRemalloc(void **pointer , uint64_t alignment , size_t size ) ;
#line 329
void Analyze(void) ;
#line 330
void Annotate(void) ;
#line 331
void AnnotateHeaderHTML(char *title_text , FILE *annotate_out ) ;
#line 332
void AnnotateFooterHTML(FILE *annotate_out ) ;
#line 333
void AnnotatePositionHTML(TREE *tree , int wtm , FILE *annotate_out ) ;
#line 334
char *AnnotateVtoNAG(int value , int wtm , int html_mode , int latex ) ;
#line 335
void AnnotateHeaderTeX(FILE *annotate_out ) ;
#line 336
void AnnotateFooterTeX(FILE *annotate_out ) ;
#line 337
void AnnotatePositionTeX(TREE *tree , int wtm , FILE *annotate_out ) ;
#line 338
uint64_t atoiKMB(char *input ) ;
#line 339
int Attacks(TREE *tree , int side , int square ) ;
#line 340
uint64_t Attacked(TREE *tree , int side , uint64_t squares___0 ) ;
#line 341
uint64_t AttacksFrom(TREE *tree , int side , int source ) ;
#line 342
uint64_t AttacksTo(TREE *tree , int square ) ;
#line 343
void AutoTune(int nargs___0 , char **args___0 ) ;
#line 344
int Bench(int increase , int autotune ) ;
#line 345
int Book(TREE *tree , int wtm ) ;
#line 346
void BookClusterIn(FILE *file , int positions , BOOK_POSITION *buffer___3 ) ;
#line 347
void BookClusterOut(FILE *file , int positions , BOOK_POSITION *buffer___3 ) ;
#line 348
int BookIn32(unsigned char *ch ) ;
#line 349
float BookIn32f(unsigned char *ch ) ;
#line 350
uint64_t BookIn64(unsigned char *ch ) ;
#line 351
int BookMask(char *flags ) ;
#line 352
unsigned char *BookOut32(int val ) ;
#line 353
unsigned char *BookOut32f(float val ) ;
#line 354
unsigned char *BookOut64(uint64_t val ) ;
#line 355
int BookPonderMove(TREE *tree , int wtm ) ;
#line 356
void Bookup(TREE *tree , int nargs___0 , char **args___0 ) ;
#line 357
void BookSort(BB_POSITION *buffer___3 , int number , int fileno___0 ) ;
#line 358
int BookupCompare(void const   *pos1 , void const   *pos2 ) ;
#line 359
BB_POSITION BookupNextPosition(int files___0 , int init___0 ) ;
#line 360
int CheckInput(void) ;
#line 361
void ClearHashTableScores(void) ;
#line 362
int ComputeDifficulty(int difficulty___0 , int direction___0 ) ;
#line 363
void CopyFromParent(TREE *child ) ;
#line 364
void CopyToParent(TREE *parent , TREE *child , int value ) ;
#line 365
void CraftyExit(int exit_type ) ;
#line 366
void DisplayArray(int *array , int size ) ;
#line 367
void DisplayArrayX2(int *array , int *array2 , int size ) ;
#line 368
void DisplayBitBoard(uint64_t board ) ;
#line 369
void Display2BitBoards(uint64_t board1 , uint64_t board2 ) ;
#line 370
void DisplayChessBoard(FILE *display_file , POSITION pos ) ;
#line 371
char *DisplayEvaluation(int value , int wtm ) ;
#line 372
char *DisplayEvaluationKibitz(int value , int wtm ) ;
#line 373
extern void DisplayFT(int  , int  , int  ) ;
#line 374
char *DisplayHHMM(unsigned int time___0 ) ;
#line 375
char *DisplayHHMMSS(unsigned int time___0 ) ;
#line 376
char *DisplayKMB(uint64_t val , int type ) ;
#line 377
void DisplayFail(TREE *tree , int type , int level , int wtm , int time___0 , int move ,
                 int value , int force___0 ) ;
#line 378
char *DisplayPath(TREE *tree , int wtm , PATH *pv ) ;
#line 379
void DisplayPV(TREE *tree , int level , int wtm , int time___0 , PATH *pv , int force___0 ) ;
#line 380
char *DisplayTime(unsigned int time___0 ) ;
#line 381
char *Display2Times(unsigned int time___0 ) ;
#line 382
char *DisplayTimeKibitz(unsigned int time___0 ) ;
#line 383
void DisplayChessMove(char *title , int move ) ;
#line 384
int Drawn(TREE *tree , int value ) ;
#line 385
extern int DTZtoWDL(int  , int  ) ;
#line 386
void Edit(void) ;
#line 387
int Evaluate(TREE *tree , int ply , int wtm , int alpha , int beta ) ;
#line 388
void EvaluateBishops(TREE *tree , int side ) ;
#line 389
void EvaluateCastling(TREE *tree , int ply , int side ) ;
#line 390
int EvaluateDraws(TREE *tree , int ply , int can_win , int score ) ;
#line 391
int EvaluateHasOpposition(int on_move , int king___0 , int enemy_king ) ;
#line 392
void EvaluateKing(TREE *tree , int ply , int side ) ;
#line 393
int EvaluateKingsFile(TREE *tree , int side , int first , int last ) ;
#line 394
void EvaluateKnights(TREE *tree , int side ) ;
#line 395
void EvaluateMate(TREE *tree , int side ) ;
#line 396
void EvaluateMaterial(TREE *tree , int wtm ) ;
#line 397
void EvaluatePassedPawns(TREE *tree , int side , int wtm ) ;
#line 398
void EvaluatePassedPawnRaces(TREE *tree , int wtm ) ;
#line 399
void EvaluatePawns(TREE *tree , int side ) ;
#line 400
void EvaluateQueens(TREE *tree , int side ) ;
#line 401
void EvaluateRooks(TREE *tree , int side ) ;
#line 402
int EvaluateWinningChances(TREE *tree , int side , int wtm ) ;
#line 403
void EVTest(char *filename ) ;
#line 404
int Exclude(TREE *tree , int ply , int move ) ;
#line 405
int FindBlockID(TREE *which ) ;
#line 406
char *FormatPV(TREE *tree , int wtm , PATH pv ) ;
#line 407
extern int FTbSetCacheSize(void * , unsigned long  ) ;
#line 408
int GameOver(int wtm ) ;
#line 409
unsigned int *GenerateCaptures(TREE *tree , int ply , int side , unsigned int *move ) ;
#line 410
unsigned int *GenerateCheckEvasions(TREE *tree , int ply , int side , unsigned int *move ) ;
#line 411
unsigned int *GenerateChecks(TREE *tree , int side , unsigned int *move ) ;
#line 412
unsigned int *GenerateNoncaptures(TREE *tree , int ply , int side , unsigned int *move ) ;
#line 413
TREE *GetBlock(TREE *parent , int tid ) ;
#line 414
void Initialize(void) ;
#line 415
void InitializeAttackBoards(void) ;
#line 416
void InitializeChessBoard(TREE *tree ) ;
#line 417
int InitializeGetLogID(void) ;
#line 418
void InitializeHashTables(int fault_in ) ;
#line 419
void InitializeKillers(void) ;
#line 420
void InitializeKingSafety(void) ;
#line 421
void InitializeMagic(void) ;
#line 422
uint64_t InitializeMagicBishop(int square , uint64_t occupied___0 ) ;
#line 423
uint64_t InitializeMagicRook(int square , uint64_t occupied___0 ) ;
#line 424
uint64_t InitializeMagicOccupied(int *squares___0 , int numSquares , uint64_t linoccupied ) ;
#line 425
void InitializeMasks(void) ;
#line 426
void InitializePawnMasks(void) ;
#line 427
void InitializeLMP(void) ;
#line 428
void InitializeLMR(void) ;
#line 429
void InitializeSMP(void) ;
#line 430
extern int IInitializeTb(char * ) ;
#line 431
int InputMove(TREE *tree , int ply , int wtm , int silent , int ponder_list , char *text___0 ) ;
#line 432
int InputMoveICS(TREE *tree , int ply , int wtm , int silent , int ponder_list , char *text___0 ) ;
#line 433
extern uint64_t InterposeSquares(int  , int  , int  ) ;
#line 434
void Interrupt(int ply ) ;
#line 435
int InvalidPosition(TREE *tree ) ;
#line 436
int Iterate(int wtm , int search_type , int root_list_done ) ;
#line 437
int Join(int64_t tid ) ;
#line 438
void Kibitz(int level , int wtm , int depth , int time___0 , int value , uint64_t nodes ,
            int ip , int tb_hits , char *pv ) ;
#line 439
void History(TREE *tree , int ply , int depth , int side , int move , int *searched ) ;
#line 440
int KingPawnSquare(int pawn___0 , int king___0 , int queen___0 , int ptm ) ;
#line 441
int LearnAdjust(int value ) ;
#line 442
void LearnBook(void) ;
#line 443
int LearnFunction(int sv , int search_depth___0 , int rating_difference , int trusted_value ) ;
#line 444
void LearnValue(int search_value , int search_depth___0 ) ;
#line 445
void MakeMove(TREE *tree , int ply , int side , int move ) ;
#line 446
void MakeMoveRoot(TREE *tree , int side , int move ) ;
#line 447
int Mated(TREE *tree , int ply , int wtm ) ;
#line 448
int RootMoveEGTB(int wtm ) ;
#line 449
int NextMove(TREE *tree , int ply , int depth , int side , int in_check ) ;
#line 450
int NextRootMove(TREE *tree , TREE *mytree , int side ) ;
#line 451
int NextRootMoveParallel(void) ;
#line 452
void NextSort(TREE *tree , int ply ) ;
#line 453
int Option(TREE *tree ) ;
#line 454
int OptionMatch(char *command , char *input ) ;
#line 455
void OptionPerft(TREE *tree , int ply , int depth , int wtm ) ;
#line 456
void Output(TREE *tree ) ;
#line 457
char *OutputMove(TREE *tree , int ply , int wtm , int move ) ;
#line 458
int ParseTime(char *string ) ;
#line 459
void Pass(void) ;
#line 460
int PinnedOnKing(TREE *tree , int side , int square ) ;
#line 461
int Ponder(int wtm ) ;
#line 462
void Print(int vb , char *fmt  , ...) ;
#line 463
extern int ProbeDTZ(TREE *tree , int ply , int wtm ) ;
#line 464
int HashProbe(TREE *tree , int ply , int depth , int side , int alpha , int beta ,
              int *value ) ;
#line 465
void HashStore(TREE *tree , int ply , int depth , int side , int type , int value ,
               int bestmove ) ;
#line 466
void HashStorePV(TREE *tree , int side , int ply ) ;
#line 467
int Quiesce(TREE *tree , int ply , int wtm , int alpha , int beta , int checks ) ;
#line 468
int QuiesceEvasions(TREE *tree , int ply , int wtm , int alpha , int beta ) ;
#line 469
unsigned int Random32(void) ;
#line 470
uint64_t Random64(void) ;
#line 471
int Read(int wait___0 , char *buffer___3 ) ;
#line 472
int ReadChessMove(TREE *tree , FILE *input , int wtm , int one_move ) ;
#line 473
void ReadClear(void) ;
#line 474
unsigned int ReadClock(void) ;
#line 475
int ReadPGN(FILE *input , int option ) ;
#line 476
int ReadNextMove(TREE *tree , char *text___0 , int ply , int wtm ) ;
#line 477
int ReadParse(char *buffer___3 , char **args___0 , char *delims ) ;
#line 478
int ReadInput(void) ;
#line 479
int Repeat(TREE *tree , int ply ) ;
#line 480
int Repeat3x(TREE *tree ) ;
#line 481
void ResignOrDraw(TREE *tree , int value ) ;
#line 482
void RestoreGame(void) ;
#line 483
void RootMoveList(int wtm ) ;
#line 484
int Search(TREE *tree , int ply , int depth , int wtm , int alpha , int beta , int in_check ,
           int do_null ) ;
#line 485
int SearchMove(TREE *tree , int ply , int depth , int wtm , int alpha , int t_beta ,
               int beta , int extend , int reduce , int check ) ;
#line 486
int SearchMoveList(TREE *tree , int ply , int depth , int wtm , int alpha , int beta ,
                   int *searched , int in_check , int repeat , int mode___0 ) ;
#line 487
extern int SearchNull(TREE * , int  , int  , int  , int  ) ;
#line 488
void Trace(TREE *tree , int ply , int depth , int wtm , int alpha , int beta , char const   *name ,
           int mode___0 , int phase , int order ) ;
#line 489
void SetBoard(TREE *tree , int nargs___0 , char **args___0 , int special ) ;
#line 490
void SetChessBitBoards(TREE *tree ) ;
#line 491
extern void SharedFree(void *address ) ;
#line 492
extern void SortRootMoves(TREE * , int  ) ;
#line 493
int Split(TREE *tree ) ;
#line 494
int StrCnt(char *string , char testchar ) ;
#line 495
int SEE(TREE *tree , int wtm , int move ) ;
#line 496
int SEEO(TREE *tree , int wtm , int move ) ;
#line 497
void Test(char *filename , FILE *unsolved , int screen , int margin ) ;
#line 498
void TestEPD(char *filename , FILE *unsolved , int screen , int margin ) ;
#line 499
void ThreadAffinity(int cpu ) ;
#line 500
void *ThreadInit(void *t ) ;
#line 504
int ThreadSplit(TREE *tree , int ply , int depth , int alpha , int o_alpha , int done ) ;
#line 505
void ThreadStop(TREE *tree ) ;
#line 506
void ThreadTrace(TREE *tree , int depth , int brief ) ;
#line 507
int ThreadWait(int tid , TREE *waiting ) ;
#line 508
extern int Threat(TREE * , int  , int  , int  , int  ) ;
#line 509
void TimeAdjust(int side , int time_used___0 ) ;
#line 510
int TimeCheck(TREE *tree , int busy ) ;
#line 511
void TimeSet(int search_type ) ;
#line 512
void UnmakeMove(TREE *tree , int ply , int side , int move ) ;
#line 513
int ValidMove(TREE *tree , int ply , int wtm , int move ) ;
#line 514
int VerifyMove(TREE *tree , int ply , int wtm , int move ) ;
#line 515
extern void ValidatePosition(TREE * , int  , int  , char * ) ;
#line 516
void WaitForAllThreadsInitialized(void) ;
#line 2 "data.h"
int scale ;
#line 3
char version[8] ;
#line 4
int presult ;
#line 5
PLAYING_MODE mode ;
#line 6
int batch_mode ;
#line 7
int swindle_mode ;
#line 8
int call_flag ;
#line 9
int crafty_rating ;
#line 10
int opponent_rating ;
#line 11
int time_used ;
#line 12
int time_used_opponent ;
#line 13 "data.h"
uint64_t total_moves  ;
#line 14
int allow_cores ;
#line 15
int allow_memory ;
#line 16
int initialized ;
#line 17
int early_exit ;
#line 18 "data.h"
char *AK_list[128]  ;
#line 19 "data.h"
char *GM_list[128]  ;
#line 20 "data.h"
char *IM_list[128]  ;
#line 21 "data.h"
char *B_list[128]  ;
#line 22 "data.h"
char *SP_list[128]  ;
#line 23 "data.h"
char *SP_opening_filename[128]  ;
#line 24 "data.h"
char *SP_personality_filename[128]  ;
#line 25 "data.h"
FILE *input_stream  ;
#line 26 "data.h"
FILE *book_file  ;
#line 27 "data.h"
FILE *books_file  ;
#line 28 "data.h"
FILE *normal_bs_file  ;
#line 29 "data.h"
FILE *computer_bs_file  ;
#line 30 "data.h"
FILE *history_file  ;
#line 31 "data.h"
FILE *log_file  ;
#line 32
int log_id ;
#line 33
int output_format ;
#line 35
int EGTBlimit ;
#line 36
int EGTB_use ;
#line 37
int EGTB_draw ;
#line 38
int EGTB_depth ;
#line 39
int EGTB_setup ;
#line 41 "data.h"
int last_mate_score  ;
#line 42
int last_opponent_move ;
#line 43
int check_depth ;
#line 44
int null_depth ;
#line 45
int null_divisor ;
#line 46
int LMR_rdepth ;
#line 47
int LMR_min ;
#line 48
int LMR_max ;
#line 49
double LMR_db ;
#line 50
double LMR_mb ;
#line 51
double LMR_s ;
#line 52 "data.h"
uint8_t LMR[32][64]  ;
#line 53 "data.h"
int rep_index  ;
#line 54
int pgn_suggested_percent ;
#line 55
char pgn_event[128] ;
#line 56
char pgn_date[128] ;
#line 57
char pgn_round[128] ;
#line 58
char pgn_site[128] ;
#line 59
char pgn_white[128] ;
#line 60
char pgn_white_elo[128] ;
#line 61
char pgn_black[128] ;
#line 62
char pgn_black_elo[128] ;
#line 63
char pgn_result[128] ;
#line 64 "data.h"
char log_filename[256]  ;
#line 65 "data.h"
char history_filename[256]  ;
#line 66 "data.h"
int number_of_solutions  ;
#line 67 "data.h"
int solutions[10]  ;
#line 68 "data.h"
int solution_type  ;
#line 69
int abs_draw_score ;
#line 70
int accept_draws ;
#line 71
int offer_draws ;
#line 72
int dynamic_draw_score ;
#line 73
int adaptive_hash ;
#line 74
size_t adaptive_hash_min ;
#line 75
size_t adaptive_hash_max ;
#line 76
size_t adaptive_hashp_min ;
#line 77
size_t adaptive_hashp_max ;
#line 78
int over ;
#line 79
int xboard ;
#line 80
int xboard_done ;
#line 81
int pong ;
#line 82
char book_path[128] ;
#line 83
char log_path[128] ;
#line 84
char tb_path[128] ;
#line 85
char rc_path[128] ;
#line 86 "data.h"
char cmd_buffer[4096]  ;
#line 87 "data.h"
char *args[512]  ;
#line 88 "data.h"
char buffer[4096]  ;
#line 89
int line_length ;
#line 90 "data.h"
unsigned char convert_buff[8]  ;
#line 91 "data.h"
int nargs  ;
#line 92
int kibitz ;
#line 93
int game_wtm ;
#line 94
int last_search_value ;
#line 95
int FP_margin[16] ;
#line 96
int FP_depth ;
#line 97 "data.h"
int LMP[16]  ;
#line 98
int LMP_depth ;
#line 99
int LMP_base ;
#line 100
double LMP_scale ;
#line 102 "data.h"
int failhi_delta  ;
#line 102 "data.h"
int faillo_delta  ;
#line 103 "data.h"
int ponder_value  ;
#line 104 "data.h"
int move_actually_played  ;
#line 105
int analyze_mode ;
#line 106
int annotate_mode ;
#line 107
int input_status ;
#line 111
int resign ;
#line 112
int resign_counter ;
#line 113
int resign_count ;
#line 114
int draw_counter ;
#line 115
int draw_count ;
#line 116
int draw_offer_pending ;
#line 117
int draw_offered ;
#line 118
char audible_alarm ;
#line 119
char speech ;
#line 120
char ponder_text[512] ;
#line 121
char book_hint[512] ;
#line 122
int post ;
#line 123
int search_depth ;
#line 124
uint64_t search_nodes ;
#line 125
uint64_t temp_search_nodes ;
#line 126
int search_move ;
#line 127
int ponder ;
#line 128 "data.h"
int ponder_move  ;
#line 129
int force ;
#line 130 "data.h"
unsigned int ponder_moves[256]  ;
#line 131 "data.h"
int num_ponder_moves  ;
#line 132
char initial_position[80] ;
#line 133
int predicted ;
#line 134
int trace_level ;
#line 135 "data.h"
int book_move  ;
#line 136
int book_accept_mask ;
#line 137
int book_reject_mask ;
#line 138
int book_random ;
#line 139
float book_weight_freq ;
#line 140
float book_weight_eval ;
#line 141
float book_weight_learn ;
#line 142
int book_search_trigger ;
#line 143
int book_selection_width ;
#line 144
int show_book ;
#line 145
int learn ;
#line 146
int learning ;
#line 147
int learn_value ;
#line 148 "data.h"
int abort_search  ;
#line 149 "data.h"
int iteration  ;
#line 150
int root_wtm ;
#line 151 "data.h"
int last_root_value  ;
#line 152 "data.h"
ROOT_MOVE root_moves[256]  ;
#line 153 "data.h"
int n_root_moves  ;
#line 154 "data.h"
int difficulty  ;
#line 155
int time_limit ;
#line 156 "data.h"
int absolute_time_limit  ;
#line 157 "data.h"
int search_time_limit  ;
#line 158 "data.h"
int burp  ;
#line 159
int quit ;
#line 160 "data.h"
unsigned int opponent_start_time  ;
#line 160 "data.h"
unsigned int opponent_end_time  ;
#line 161 "data.h"
unsigned int program_start_time  ;
#line 161 "data.h"
unsigned int program_end_time  ;
#line 162 "data.h"
unsigned int start_time  ;
#line 162 "data.h"
unsigned int end_time  ;
#line 163 "data.h"
TREE *block[257]  ;
#line 164 "data.h"
THREAD thread[4]  ;
#line 166 "data.h"
int volatile   lock_smp  ;
#line 166 "data.h"
int volatile   lock_io  ;
#line 168 "data.h"
pthread_attr_t attributes  ;
#line 171 "data.h"
unsigned int hardware_processors  ;
#line 172
unsigned int smp_max_threads ;
#line 173
unsigned int smp_split_group ;
#line 174
unsigned int smp_split_at_root ;
#line 175
unsigned int smp_min_split_depth ;
#line 176
unsigned int smp_gratuitous_depth ;
#line 177
unsigned int smp_gratuitous_limit ;
#line 178
int smp_nice ;
#line 179
int smp_affinity ;
#line 180
int smp_affinity_increment ;
#line 181
int smp_numa ;
#line 182
int autotune_params ;
#line 183
struct autotune tune[16] ;
#line 184
extern unsigned int smp_split_nodes ;
#line 185 "data.h"
unsigned int parallel_splits  ;
#line 186 "data.h"
unsigned int parallel_splits_wasted  ;
#line 187 "data.h"
unsigned int parallel_aborts  ;
#line 188 "data.h"
unsigned int parallel_joins  ;
#line 189
unsigned int busy_percent ;
#line 190
uint64_t game_max_blocks ;
#line 191
int volatile   smp_split ;
#line 192
int volatile   smp_threads ;
#line 193
int volatile   initialized_threads ;
#line 194
int crafty_is_white ;
#line 195
unsigned int nodes_between_time_checks ;
#line 196
unsigned int nodes_per_second ;
#line 197
int next_time_check ;
#line 198
int transposition_age ;
#line 199
int thinking ;
#line 200
int pondering ;
#line 201
int puzzling ;
#line 202
int booking ;
#line 203
int display_options ;
#line 204
unsigned int noise_level ;
#line 205
int noise_block ;
#line 206
int tc_moves ;
#line 207
int tc_time ;
#line 208
int tc_time_remaining[2] ;
#line 209
int tc_moves_remaining[2] ;
#line 210
int tc_secondary_moves ;
#line 211
int tc_secondary_time ;
#line 212
int tc_increment ;
#line 213
int tc_sudden_death ;
#line 214
int tc_safety_margin ;
#line 215
int draw_score[2] ;
#line 216 "data.h"
char kibitz_text[4096]  ;
#line 217 "data.h"
int kibitz_depth  ;
#line 218
int move_number ;
#line 219
int moves_out_of_book ;
#line 220
int first_nonbook_factor ;
#line 221
int first_nonbook_span ;
#line 225 "data.h"
int book_learn_eval[10]  ;
#line 226 "data.h"
int book_learn_depth[10]  ;
#line 227 "data.h"
int learn_seekto[64]  ;
#line 228 "data.h"
uint64_t learn_key[64]  ;
#line 229 "data.h"
int learn_nmoves[64]  ;
#line 230 "data.h"
uint64_t book_learn_key  ;
#line 231
int learn_positions_count ;
#line 232 "data.h"
int book_learn_nmoves  ;
#line 233 "data.h"
int book_learn_seekto  ;
#line 234
int usage_level ;
#line 235
size_t hash_table_size ;
#line 236
size_t hash_path_size ;
#line 237
uint64_t hash_mask ;
#line 238
uint64_t mask_clear_entry ;
#line 239
uint64_t hash_path_mask ;
#line 240
size_t pawn_hash_table_size ;
#line 241
uint64_t pawn_hash_mask ;
#line 242 "data.h"
HASH_ENTRY *hash_table  ;
#line 243 "data.h"
HPATH_ENTRY *hash_path  ;
#line 244 "data.h"
PAWN_HASH_ENTRY *pawn_hash_table  ;
#line 245 "data.h"
void *segments[288][2]  ;
#line 246
int nsegments ;
#line 247
int const   pcval[7] ;
#line 248
int const   p_vals[7] ;
#line 249
int const   MVV_LVA[7][7] ;
#line 250
int const   pieces[2][7] ;
#line 251
int const   lower_n ;
#line 252
int const   lower_b ;
#line 253
int const   mobility_score_n[4] ;
#line 254
int const   mobility_score_b[4] ;
#line 255
int const   mobility_score_r[4] ;
#line 256
int const   mob_curve_r[48] ;
#line 257 "data.h"
PATH last_pv  ;
#line 258 "data.h"
int last_value  ;
#line 259
char const   translate[13] ;
#line 260
char const   empty_sqs[9] ;
#line 261
int const   mate[64] ;
#line 262
uint64_t const   magic_rook[64] ;
#line 263
uint64_t const   magic_rook_mask[64] ;
#line 264
unsigned int const   magic_rook_shift[64] ;
#line 265
uint64_t const   mobility_mask_b[4] ;
#line 266
uint64_t const   mobility_mask_r[4] ;
#line 267
int16_t *magic_bishop_mobility_indices[64] ;
#line 268 "data.h"
int16_t magic_bishop_mobility_table[5248]  ;
#line 269
uint64_t *magic_rook_indices[64] ;
#line 270 "data.h"
uint64_t magic_rook_table[102400]  ;
#line 271
int16_t *magic_rook_mobility_indices[64] ;
#line 272 "data.h"
int16_t magic_rook_mobility_table[102400]  ;
#line 273
uint64_t const   magic_bishop[64] ;
#line 274
uint64_t const   magic_bishop_mask[64] ;
#line 275
unsigned int const   magic_bishop_shift[64] ;
#line 276
uint64_t *magic_bishop_indices[64] ;
#line 277 "data.h"
uint64_t magic_bishop_table[5248]  ;
#line 280 "data.h"
int8_t directions[64][64]  ;
#line 281 "data.h"
uint64_t pawn_attacks[2][64]  ;
#line 282 "data.h"
uint64_t knight_attacks[64]  ;
#line 283 "data.h"
uint64_t rook_attacks[64]  ;
#line 284 "data.h"
uint64_t bishop_attacks[64]  ;
#line 285 "data.h"
POSITION display  ;
#line 286 "data.h"
uint64_t king_attacks[64]  ;
#line 287 "data.h"
uint64_t intervening[64][64]  ;
#line 288 "data.h"
int history[1024]  ;
#line 289
uint64_t const   randoms[2][7][64] ;
#line 290
uint64_t const   castle_random[2][2] ;
#line 291
uint64_t const   enpassant_random[65] ;
#line 292 "data.h"
uint64_t clear_mask[65]  ;
#line 293 "data.h"
uint64_t set_mask[65]  ;
#line 294 "data.h"
uint64_t file_mask[8]  ;
#line 295 "data.h"
uint64_t rank_mask[8]  ;
#line 296
uint64_t const   OO[2] ;
#line 297
uint64_t const   OOO[2] ;
#line 298
unsigned long const   mask_efgh ;
#line 298
unsigned long const   mask_fgh ;
#line 298
unsigned long const   mask_abc ;
#line 298
unsigned long const   mask_abcd ;
#line 299
unsigned long const   mask_advance_2_w ;
#line 300
unsigned long const   mask_advance_2_b ;
#line 301
unsigned long const   mask_left_edge ;
#line 302
unsigned long const   mask_right_edge ;
#line 303
unsigned long const   mask_not_edge ;
#line 304
unsigned long const   mask_rook_files ;
#line 305
unsigned long const   dark_squares ;
#line 306
unsigned long const   not_rook_pawns ;
#line 307
extern uint64_t const   not_rook_files ;
#line 308 "data.h"
uint64_t plus1dir[65]  ;
#line 309 "data.h"
uint64_t plus7dir[65]  ;
#line 310 "data.h"
uint64_t plus8dir[65]  ;
#line 311 "data.h"
uint64_t plus9dir[65]  ;
#line 312 "data.h"
uint64_t minus1dir[65]  ;
#line 313 "data.h"
uint64_t minus7dir[65]  ;
#line 314 "data.h"
uint64_t minus8dir[65]  ;
#line 315 "data.h"
uint64_t minus9dir[65]  ;
#line 316 "data.h"
uint64_t mask_eptest[64]  ;
#line 318 "data.h"
unsigned char msb[65536]  ;
#line 319 "data.h"
unsigned char lsb[65536]  ;
#line 321 "data.h"
unsigned char msb_8bit[256]  ;
#line 322 "data.h"
unsigned char lsb_8bit[256]  ;
#line 323 "data.h"
unsigned char pop_cnt_8bit[256]  ;
#line 324 "data.h"
uint64_t mask_pawn_connected[2][64]  ;
#line 325 "data.h"
uint64_t mask_pawn_isolated[64]  ;
#line 326 "data.h"
uint64_t mask_passed[2][64]  ;
#line 327 "data.h"
uint64_t mask_pattacks[2][64]  ;
#line 328 "data.h"
uint64_t pawn_race[2][2][64]  ;
#line 329 "data.h"
BOOK_POSITION book_buffer[8000]  ;
#line 330 "data.h"
BOOK_POSITION book_buffer_char[8000]  ;
#line 331
int const   rankflip[2][8] ;
#line 332
int const   sqflip[2][64] ;
#line 333
int const   rank1[2] ;
#line 334
int const   rank2[2] ;
#line 335
int const   rank3[2] ;
#line 336
int const   rank4[2] ;
#line 337
int const   rank5[2] ;
#line 338
int const   rank6[2] ;
#line 339
int const   rank7[2] ;
#line 340
int const   rank8[2] ;
#line 341
int const   epdir[2] ;
#line 342
int const   csq[2] ;
#line 343
int const   dsq[2] ;
#line 344
int const   esq[2] ;
#line 345
int const   fsq[2] ;
#line 346
int const   gsq[2] ;
#line 347
int const   sign[2] ;
#line 348
char const   square_color[64] ;
#line 349 "data.h"
uint64_t distance_ring[64][8]  ;
#line 350
int const   OOsqs[2][3] ;
#line 351
int const   OOOsqs[2][3] ;
#line 352
int const   OOfrom[2] ;
#line 353
int const   OOto[2] ;
#line 354
int const   OOOto[2] ;
#line 355
int const   epsq[2] ;
#line 356
int const   rook_A[2] ;
#line 357
int const   rook_D[2] ;
#line 358
int const   rook_F[2] ;
#line 359
int const   rook_G[2] ;
#line 360
int const   rook_H[2] ;
#line 361
int const   capleft[2] ;
#line 362
int const   capright[2] ;
#line 363
int const   pawnadv1[2] ;
#line 364
int const   pawnadv2[2] ;
#line 365
int piece_values[2][7] ;
#line 366
struct personality_term personality_packet[256] ;
#line 24 "epdglue.h"
extern int EGCommandParmCount(char *s ) ;
#line 25
extern int EGCommandCheck(char *s ) ;
#line 26
extern int EGCommand(char *s ) ;
#line 27
extern void EGInit(void) ;
#line 28
extern void EGTerm(void) ;
#line 59 "tbprobe.h"
extern _Bool tb_init_impl(char const   *path ) ;
#line 60
extern unsigned int tb_probe_wdl_impl(uint64_t white___0 , uint64_t black___0 , uint64_t kings ,
                                      uint64_t queens , uint64_t rooks , uint64_t bishops ,
                                      uint64_t knights , uint64_t pawns , unsigned int ep ,
                                      _Bool turn , uint64_t hash ) ;
#line 64
extern unsigned int tb_probe_root_impl(uint64_t white___0 , uint64_t black___0 , uint64_t kings ,
                                       uint64_t queens , uint64_t rooks , uint64_t bishops ,
                                       uint64_t knights , uint64_t pawns , unsigned int rule50 ,
                                       unsigned int ep , _Bool turn , unsigned int *results ) ;
#line 153
unsigned int TB_LARGEST ;
#line 167 "tbprobe.h"
__inline static _Bool tb_init(char const   *_path ) 
{ 
  _Bool tmp ;

  {
#line 168
  tmp = tb_init_impl(_path);
#line 168
  return (tmp);
}
}
#line 193 "tbprobe.h"
__inline static unsigned int tb_probe_wdl(uint64_t _white , uint64_t _black , uint64_t _kings ,
                                          uint64_t _queens , uint64_t _rooks , uint64_t _bishops ,
                                          uint64_t _knights , uint64_t _pawns , unsigned int _rule50 ,
                                          unsigned int _castling , unsigned int _ep ,
                                          _Bool _turn , uint64_t _hash ) 
{ 
  unsigned int tmp ;

  {
#line 198
  if (_castling != 0U) {
#line 199
    return (0xFFFFFFFF);
  }
#line 200
  if (_rule50 != 0U) {
#line 201
    return (0xFFFFFFFF);
  }
#line 202
  tmp = tb_probe_wdl_impl(_white, _black, _kings, _queens, _rooks, _bishops, _knights,
                          _pawns, _ep, _turn, _hash);
#line 202
  return (tmp);
}
}
#line 251 "tbprobe.h"
__inline static unsigned int tb_probe_root(uint64_t _white , uint64_t _black , uint64_t _kings ,
                                           uint64_t _queens , uint64_t _rooks , uint64_t _bishops ,
                                           uint64_t _knights , uint64_t _pawns , unsigned int _rule50 ,
                                           unsigned int _castling , unsigned int _ep ,
                                           _Bool _turn , unsigned int *_results ) 
{ 
  unsigned int tmp ;

  {
#line 255
  if (_castling != 0U) {
#line 256
    return (0xFFFFFFFF);
  }
#line 257
  tmp = tb_probe_root_impl(_white, _black, _kings, _queens, _rooks, _bishops, _knights,
                           _pawns, _rule50, _ep, _turn, _results);
#line 257
  return (tmp);
}
}
#line 273
unsigned int tb_pop_count(uint64_t bb ) ;
#line 274
unsigned int tb_lsb(uint64_t bb ) ;
#line 275
uint64_t tb_pop_lsb(uint64_t bb ) ;
#line 276
uint64_t tb_king_attacks(unsigned int sq ) ;
#line 277
uint64_t tb_queen_attacks(unsigned int sq , uint64_t occ ) ;
#line 278
uint64_t tb_rook_attacks(unsigned int sq , uint64_t occ ) ;
#line 279
uint64_t tb_bishop_attacks(unsigned int sq , uint64_t occ ) ;
#line 280
uint64_t tb_knight_attacks(unsigned int sq ) ;
#line 281
uint64_t tb_pawn_attacks(unsigned int sq , _Bool color ) ;
#line 44 "iterate.c"
int Iterate(int wtm , int search_type , int root_list_done ) 
{ 
  TREE *tree ;
  ROOT_MOVE temp_rm ;
  int i ;
  int alpha ;
  int beta ;
  int current_rm ;
  int force_print ;
  int value ;
  int twtm ;
  int correct ;
  int correct_count ;
  int npc ;
  int cpl ;
  int max ;
  unsigned int idle_time ;
  char buff[32] ;
  pthread_t pt ;
  int tmp ;
  long proc ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  uint64_t tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  char *tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int proc___0 ;

  {
#line 45
  tree = (TREE *)block[0];
#line 47
  current_rm = 0;
#line 47
  force_print = 0;
#line 48
  value = 0;
#line 64
  if (wtm) {
#line 64
    draw_score[0] = - abs_draw_score;
  } else {
#line 64
    draw_score[0] = abs_draw_score;
  }
#line 65
  if (wtm) {
#line 65
    draw_score[1] = abs_draw_score;
  } else {
#line 65
    draw_score[1] = - abs_draw_score;
  }
#line 76
  abort_search = 0;
#line 77
  book_move = 0;
#line 78
  program_start_time = ReadClock();
#line 79
  start_time = ReadClock();
#line 80
  root_wtm = wtm;
#line 81
  kibitz_depth = 0;
#line 82
  tree->nodes_searched = (uint64_t )0;
#line 83
  tree->fail_highs = (uint64_t )0;
#line 84
  tree->fail_high_first_move = (uint64_t )0;
#line 85
  parallel_splits = 0U;
#line 86
  parallel_splits_wasted = 0U;
#line 87
  parallel_aborts = 0U;
#line 88
  parallel_joins = 0U;
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! ((unsigned int )i < smp_max_threads)) {
#line 89
      goto while_break;
    }
#line 90
    thread[i].max_blocks = (uint64_t )0;
#line 91
    thread[i].tree = (TREE *)0;
#line 92
    thread[i].idle = 0U;
#line 93
    thread[i].terminate = (unsigned int volatile   )0;
#line 89
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  thread[0].tree = block[0];
#line 96
  correct_count = 0;
#line 97
  burp = 1500;
#line 98
  transposition_age = (transposition_age + 1) & 0x1ff;
#line 99
  next_time_check = (int )nodes_between_time_checks;
#line 100
  tree->evaluations = (uint64_t )0;
#line 101
  tree->egtb_probes = (uint64_t )0;
#line 102
  tree->egtb_hits = (uint64_t )0;
#line 103
  tree->extensions_done = (uint64_t )0;
#line 104
  tree->qchecks_done = (uint64_t )0;
#line 105
  tree->moves_fpruned = (uint64_t )0;
#line 106
  tree->moves_mpruned = (uint64_t )0;
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (! (i < 16)) {
#line 107
      goto while_break___0;
    }
#line 108
    tree->LMR_done[i] = (uint64_t )0;
#line 109
    tree->null_done[i] = (uint64_t )0;
#line 107
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  root_wtm = wtm;
#line 130
  if (! root_list_done) {
#line 131
    RootMoveList(wtm);
  }
#line 132
  if (booking) {
#line 132
    goto _L___10;
  } else {
#line 132
    tmp___33 = Book((TREE *)tree, wtm);
#line 132
    if (tmp___33) {
      _L___11: /* CIL Label */ 
#line 678
      last_root_value = tree->pv[0].pathv;
#line 679
      value = tree->pv[0].pathv;
#line 680
      book_move = 1;
#line 681
      if (analyze_mode) {
#line 682
        Kibitz(4, wtm, 0, 0, 0, (uint64_t )0, 0, 0, kibitz_text);
      }
    } else {
#line 132
      tmp___34 = RootMoveEGTB(wtm);
#line 132
      if (tmp___34) {
#line 132
        goto _L___11;
      } else {
        _L___10: /* CIL Label */ 
        {
#line 133
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 134
          if (abort_search) {
#line 135
            goto while_break___1;
          }
#line 155
          if (n_root_moves == 0) {
#line 156
            program_end_time = ReadClock();
#line 157
            tree->pv[0].pathl = 0;
#line 158
            tree->pv[0].pathd = 0;
#line 159
            tmp = Attacks((TREE *)tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 159
            if (tmp) {
#line 160
              value = -32767;
            } else {
#line 162
              value = draw_score[wtm];
            }
#line 163
            Print(2, "        depth     time       score   variation\n");
#line 164
            Print(2, "                             Mated   (no moves)\n");
#line 165
            tree->nodes_searched = (uint64_t )1;
#line 166
            if (! puzzling) {
#line 167
              last_root_value = value;
            }
#line 168
            return (value);
          }
#line 181
          TimeSet(search_type);
#line 182
          iteration = 1;
#line 183
          noise_block = 0;
#line 184
          force_print = 0;
#line 185
          if (last_pv.pathd > 1) {
#line 186
            iteration = last_pv.pathd + 1;
#line 187
            value = last_root_value;
#line 188
            tree->pv[0] = last_pv;
#line 189
            root_moves[0].path = tree->pv[0];
#line 190
            noise_block = 1;
#line 191
            force_print = 1;
          } else {
#line 193
            difficulty = 100;
          }
#line 194
          Print(2, "        depth     time       score   variation (%d)\n", iteration);
#line 196
          abort_search = 0;
#line 205
          tree->pv[0] = last_pv;
#line 206
          if (iteration > 1) {
#line 207
            if (-32768 > last_value - 16) {
#line 207
              alpha = -32768;
            } else {
#line 207
              alpha = last_value - 16;
            }
#line 208
            if (32768 < last_value + 16) {
#line 208
              beta = 32768;
            } else {
#line 208
              beta = last_value + 16;
            }
          } else {
#line 210
            alpha = -32768;
#line 211
            beta = 32768;
          }
#line 227
          if (smp_max_threads > (unsigned int )(smp_threads + (int volatile   )1)) {
#line 230
            initialized_threads = (int volatile   )1;
#line 231
            Print(32, "starting thread");
#line 232
            proc = (long )(smp_threads + (int volatile   )1);
            {
#line 232
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 232
              if (! (proc < (long )smp_max_threads)) {
#line 232
                goto while_break___2;
              }
#line 233
              Print(32, " %d", proc);
#line 235
              pthread_create((pthread_t * __restrict  )(& pt), (pthread_attr_t const   * __restrict  )(& attributes),
                             & ThreadInit, (void * __restrict  )((void *)proc));
#line 239
              smp_threads += (int volatile   )1;
#line 232
              proc ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 241
            Print(32, " <done>\n");
          }
#line 243
          WaitForAllThreadsInitialized();
#line 244
          ThreadAffinity(0);
#line 246
          if (search_nodes) {
#line 247
            nodes_between_time_checks = (unsigned int )search_nodes;
          }
          {
#line 263
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 263
            if (! (iteration <= 124)) {
#line 263
              goto while_break___3;
            }
#line 264
            twtm = wtm;
#line 265
            i = 1;
            {
#line 265
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 265
              if (! (i < tree->pv[0].pathl)) {
#line 265
                goto while_break___4;
              }
#line 266
              tmp___0 = VerifyMove((TREE *)tree, i, twtm, tree->pv[0].path[i]);
#line 266
              if (! tmp___0) {
#line 267
                Print(2048, "ERROR, not installing bogus pv info at ply=%d\n", i);
#line 268
                Print(2048, "not installing from=%d  to=%d  piece=%d\n", tree->pv[0].path[i] & 63,
                      (tree->pv[0].path[i] >> 6) & 63, (tree->pv[0].path[i] >> 12) & 7);
#line 271
                Print(2048, "pathlen=%d\n", tree->pv[0].pathl);
#line 272
                goto while_break___4;
              }
#line 274
              HashStorePV((TREE *)tree, twtm, i);
#line 275
              MakeMove((TREE *)tree, i, twtm, tree->pv[0].path[i]);
#line 276
              twtm ^= 1;
#line 265
              i ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 278
            i --;
            {
#line 278
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 278
              if (! (i > 0)) {
#line 278
                goto while_break___5;
              }
#line 279
              twtm ^= 1;
#line 280
              UnmakeMove((TREE *)tree, i, twtm, tree->pv[0].path[i]);
#line 278
              i --;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 300
            if (trace_level) {
#line 301
              Print(32, "==================================\n");
#line 302
              Print(32, "=      search iteration %2d       =\n", iteration);
#line 303
              Print(32, "==================================\n");
            }
#line 305
            if (tree->nodes_searched) {
#line 306
              if (smp_max_threads > 1U) {
#line 306
                tmp___1 = smp_max_threads;
              } else {
#line 306
                tmp___1 = 1U;
              }
#line 306
              nodes_between_time_checks = nodes_per_second / (10U * tmp___1);
#line 308
              if (! analyze_mode) {
#line 309
                if (time_limit < 1000) {
#line 310
                  nodes_between_time_checks /= 10U;
                }
#line 311
                if (time_limit < 100) {
#line 312
                  nodes_between_time_checks /= 10U;
                }
              } else
#line 314
              if (nodes_per_second < 1000000U) {
#line 314
                nodes_between_time_checks = nodes_per_second;
              } else {
#line 314
                nodes_between_time_checks = 1000000U;
              }
            }
#line 316
            if (search_nodes) {
#line 317
              nodes_between_time_checks = (unsigned int )(search_nodes - tree->nodes_searched);
            }
#line 318
            if (nodes_between_time_checks < 3000000U) {
#line 318
              nodes_between_time_checks = nodes_between_time_checks;
            } else {
#line 318
              nodes_between_time_checks = 3000000U;
            }
#line 320
            next_time_check = (int )nodes_between_time_checks;
#line 333
            failhi_delta = 16;
#line 334
            faillo_delta = 16;
#line 335
            i = 0;
            {
#line 335
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 335
              if (! (i < n_root_moves)) {
#line 335
                goto while_break___6;
              }
#line 336
              if (i) {
#line 336
                goto _L;
              } else
#line 336
              if (iteration == 1) {
                _L: /* CIL Label */ 
#line 337
                root_moves[i].path.pathv = -32768;
              }
#line 338
              root_moves[i].status &= 4U;
#line 335
              i ++;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 340
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 340
              if (! 1) {
#line 340
                goto while_break___7;
              }
#line 341
              if (smp_max_threads > 1U) {
#line 342
                smp_split = (int volatile   )1;
              }
#line 343
              rep_index --;
#line 344
              tmp___2 = Attacks((TREE *)tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 344
              value = Search((TREE *)tree, 1, iteration, wtm, alpha, beta, tmp___2,
                             0);
#line 345
              rep_index ++;
#line 346
              end_time = ReadClock();
#line 347
              if (abort_search) {
#line 348
                goto while_break___7;
              }
#line 349
              current_rm = 0;
              {
#line 349
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 349
                if (! (current_rm < n_root_moves)) {
#line 349
                  goto while_break___8;
                }
#line 350
                if (tree->pv[0].path[1] == root_moves[current_rm].move) {
#line 351
                  goto while_break___8;
                }
#line 349
                current_rm ++;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 380
              if (value >= beta) {
#line 381
                if (beta + failhi_delta < 32768) {
#line 381
                  beta += failhi_delta;
                } else {
#line 381
                  beta = 32768;
                }
#line 382
                failhi_delta *= 2;
#line 383
                if (failhi_delta > 1000) {
#line 384
                  failhi_delta = 99999;
                }
#line 385
                root_moves[current_rm].status &= 7U;
#line 386
                root_moves[current_rm].bm_age = 4;
#line 387
                if ((root_moves[current_rm].status & 2U) == 0U) {
#line 388
                  difficulty = ComputeDifficulty(difficulty, 1);
                }
#line 389
                root_moves[current_rm].status |= 2U;
#line 390
                DisplayFail((TREE *)tree, 1, 5, wtm, (int )(end_time - start_time),
                            root_moves[current_rm].move, value, force_print);
#line 392
                temp_rm = root_moves[current_rm];
#line 393
                i = current_rm;
                {
#line 393
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 393
                  if (! (i > 0)) {
#line 393
                    goto while_break___9;
                  }
#line 394
                  root_moves[i] = root_moves[i - 1];
#line 393
                  i --;
                }
                while_break___9: /* CIL Label */ ;
                }
#line 395
                root_moves[0] = temp_rm;
              } else
#line 425
              if (value <= alpha) {
#line 426
                if (alpha - faillo_delta > -32768) {
#line 426
                  alpha -= faillo_delta;
                } else {
#line 426
                  alpha = -32768;
                }
#line 427
                faillo_delta *= 2;
#line 428
                if (faillo_delta > 1000) {
#line 429
                  faillo_delta = 99999;
                }
#line 430
                root_moves[current_rm].status &= 7U;
#line 431
                if ((root_moves[current_rm].status & 1U) == 0U) {
#line 432
                  if (100 > difficulty) {
#line 432
                    tmp___3 = 100;
                  } else {
#line 432
                    tmp___3 = difficulty;
                  }
#line 432
                  difficulty = ComputeDifficulty(tmp___3, -1);
                }
#line 433
                root_moves[current_rm].status |= 1U;
#line 434
                DisplayFail((TREE *)tree, 2, 5, wtm, (int )(end_time - start_time),
                            root_moves[current_rm].move, value, force_print);
              } else {
#line 437
                goto while_break___7;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
#line 449
            if (value > alpha) {
#line 449
              if (value < beta) {
#line 450
                last_root_value = value;
              } else {
#line 449
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ ;
            }
#line 451
            correct = solution_type;
#line 452
            i = 0;
            {
#line 452
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 452
              if (! (i < number_of_solutions)) {
#line 452
                goto while_break___10;
              }
#line 453
              if (! solution_type) {
#line 454
                if (solutions[i] == tree->pv[0].path[1]) {
#line 455
                  correct = 1;
                }
              } else
#line 456
              if (solutions[i] == root_moves[current_rm].move) {
#line 457
                correct = 0;
              }
#line 452
              i ++;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 459
            if (correct) {
#line 460
              correct_count ++;
            } else {
#line 462
              correct_count = 0;
            }
#line 472
            i = 0;
            {
#line 472
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 472
              if (! (i < n_root_moves)) {
#line 472
                goto while_break___11;
              }
#line 473
              root_moves[i].status &= 3U;
#line 474
              if (root_moves[i].bm_age) {
#line 475
                (root_moves[i].bm_age) --;
              }
#line 476
              if (root_moves[i].bm_age) {
#line 477
                root_moves[i].status |= 4U;
              }
#line 472
              i ++;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 479
            difficulty = ComputeDifficulty(difficulty, 0);
#line 493
            if (display_options & 64) {
#line 494
              Print(64, "      rmove   score    age  S ! ?\n");
#line 495
              i = 0;
              {
#line 495
              while (1) {
                while_continue___12: /* CIL Label */ ;
#line 495
                if (! (i < n_root_moves)) {
#line 495
                  goto while_break___12;
                }
#line 496
                tmp___4 = OutputMove((TREE *)tree, 1, wtm, root_moves[i].move);
#line 496
                Print(64, " %10s ", tmp___4);
#line 497
                if (root_moves[i].path.pathv > -32768) {
#line 497
                  if (root_moves[i].path.pathv <= 32768) {
#line 499
                    tmp___5 = DisplayEvaluation(root_moves[i].path.pathv, wtm);
#line 499
                    Print(64, "%s", tmp___5);
                  } else {
#line 497
                    goto _L___1;
                  }
                } else {
                  _L___1: /* CIL Label */ 
#line 502
                  Print(64, "  -----");
                }
#line 503
                Print(64, "     %d   %d %d %d\n", root_moves[i].bm_age, (root_moves[i].status & 4U) != 0U,
                      (root_moves[i].status & 2U) != 0U, (root_moves[i].status & 1U) != 0U);
#line 495
                i ++;
              }
              while_break___12: /* CIL Label */ ;
              }
            }
#line 518
            if (end_time - start_time > 10U) {
#line 519
              nodes_per_second = (unsigned int )((tree->nodes_searched * 100UL) / (uint64_t )(end_time - start_time));
            } else {
#line 522
              nodes_per_second = 1000000U;
            }
#line 523
            tree->pv[0] = root_moves[0].path;
#line 524
            if (! abort_search) {
#line 524
              if (value != -32767) {
#line 525
                if (end_time - start_time >= noise_level) {
#line 526
                  DisplayPV((TREE *)tree, 5, wtm, (int )(end_time - start_time), & tree->pv[0],
                            force_print);
#line 528
                  noise_block = 0;
                } else {
#line 530
                  noise_block = 1;
                }
              } else {
#line 524
                goto _L___2;
              }
            } else {
              _L___2: /* CIL Label */ ;
            }
#line 532
            if (-32768 > value - 16) {
#line 532
              alpha = -32768;
            } else {
#line 532
              alpha = value - 16;
            }
#line 533
            if (32768 < value + 16) {
#line 533
              beta = 32768;
            } else {
#line 533
              beta = value + 16;
            }
#line 550
            tmp___6 = TimeCheck((TREE *)tree, 0);
#line 550
            if (tmp___6) {
#line 551
              goto while_break___3;
            }
#line 552
            if (iteration > 3) {
#line 552
              if (value > 32000) {
#line 552
                if (value >= (32768 - iteration) + 3) {
#line 552
                  if (value > last_mate_score) {
#line 554
                    goto while_break___3;
                  } else {
#line 552
                    goto _L___5;
                  }
                } else {
#line 552
                  goto _L___5;
                }
              } else {
#line 552
                goto _L___5;
              }
            } else {
              _L___5: /* CIL Label */ 
              _L___4: /* CIL Label */ 
              _L___3: /* CIL Label */ ;
            }
#line 555
            if (iteration >= search_depth) {
#line 555
              if (search_depth) {
#line 556
                goto while_break___3;
              } else {
#line 555
                goto _L___6;
              }
            } else {
              _L___6: /* CIL Label */ ;
            }
#line 557
            if (abort_search) {
#line 558
              goto while_break___3;
            }
#line 559
            tmp___7 = ReadClock();
#line 559
            end_time = tmp___7 - start_time;
#line 560
            if (correct_count >= early_exit) {
#line 561
              goto while_break___3;
            }
#line 562
            if (search_nodes) {
#line 562
              if (tree->nodes_searched >= search_nodes) {
#line 563
                goto while_break___3;
              } else {
#line 562
                goto _L___7;
              }
            } else {
              _L___7: /* CIL Label */ ;
            }
#line 263
            iteration ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 587
          end_time = ReadClock();
#line 588
          if (end_time > 10U) {
#line 589
            if ((uint64_t )end_time - (uint64_t )start_time > 1UL) {
#line 589
              tmp___8 = (uint64_t )end_time - (uint64_t )start_time;
            } else {
#line 589
              tmp___8 = (uint64_t )1;
            }
#line 589
            nodes_per_second = (unsigned int )((tree->nodes_searched * 100UL) / tmp___8);
          }
#line 592
          if (abort_search != 2) {
#line 592
            if (! puzzling) {
#line 593
              if (noise_block) {
#line 594
                DisplayPV((TREE *)tree, 5, wtm, (int )(end_time - start_time), & tree->pv[0],
                          1);
              }
#line 595
              if (tree->evaluations) {
#line 595
                tree->evaluations = tree->evaluations;
              } else {
#line 595
                tree->evaluations = (uint64_t )1;
              }
#line 596
              (tree->fail_highs) ++;
#line 597
              (tree->fail_high_first_move) ++;
#line 598
              idle_time = 0U;
#line 599
              i = 0;
              {
#line 599
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 599
                if (! ((unsigned int )i < smp_max_threads)) {
#line 599
                  goto while_break___13;
                }
#line 600
                idle_time += thread[i].idle;
#line 599
                i ++;
              }
              while_break___13: /* CIL Label */ ;
              }
#line 601
              if (100U < (100U * idle_time) / (smp_max_threads * (end_time - start_time) + 1U)) {
#line 601
                tmp___9 = 100U;
              } else {
#line 601
                tmp___9 = (100U * idle_time) / (smp_max_threads * (end_time - start_time) + 1U);
              }
#line 601
              busy_percent = 100U - tmp___9;
#line 605
              tmp___10 = DisplayTimeKibitz(end_time - start_time);
#line 605
              Print(8, "        time=%s(%d%%)", tmp___10, busy_percent);
#line 607
              tmp___11 = DisplayKMB(tree->nodes_searched, 0);
#line 607
              Print(8, "  nodes=%lu(%s)", tree->nodes_searched, tmp___11);
#line 609
              Print(8, "  fh1=%d%%", (tree->fail_high_first_move * 100UL) / tree->fail_highs);
#line 611
              Print(8, "  pred=%d", predicted);
#line 612
              tmp___12 = DisplayKMB((uint64_t )nodes_per_second, 0);
#line 612
              Print(8, "  nps=%s\n", tmp___12);
#line 613
              tmp___13 = DisplayKMB(tree->extensions_done, 0);
#line 613
              Print(8, "        chk=%s", tmp___13);
#line 614
              tmp___14 = DisplayKMB(tree->qchecks_done, 0);
#line 614
              Print(8, "  qchk=%s", tmp___14);
#line 615
              tmp___15 = DisplayKMB(tree->moves_fpruned, 0);
#line 615
              Print(8, "  fp=%s", tmp___15);
#line 616
              tmp___16 = DisplayKMB(tree->moves_mpruned, 0);
#line 616
              Print(8, "  mcp=%s", tmp___16);
#line 617
              if (! ((last_pv.path[1] >> 15) & 63)) {
#line 617
                if (((last_pv.path[1] >> 12) & 7) != 1) {
#line 617
                  tmp___17 = (int )tree->status[0].reversible + 1;
                } else {
#line 617
                  goto _L___8;
                }
              } else {
                _L___8: /* CIL Label */ 
#line 617
                tmp___17 = 0;
              }
#line 617
              Print(8, "  50move=%d", tmp___17);
#line 619
              if (tree->egtb_hits) {
#line 620
                tmp___18 = DisplayKMB(tree->egtb_hits, 0);
#line 620
                Print(8, "  egtb=%s", tmp___18);
              }
#line 621
              Print(8, "\n");
#line 622
              Print(8, "        LMReductions:");
#line 623
              npc = 21;
#line 624
              cpl = 75;
#line 625
              i = 1;
              {
#line 625
              while (1) {
                while_continue___14: /* CIL Label */ ;
#line 625
                if (! (i < 16)) {
#line 625
                  goto while_break___14;
                }
#line 626
                if (tree->LMR_done[i]) {
#line 627
                  tmp___19 = DisplayKMB(tree->LMR_done[i], 0);
#line 627
                  sprintf(buff, (char const   *)"%d/%s", i, tmp___19);
#line 628
                  tmp___20 = strlen((char const   *)(buff));
#line 628
                  if ((size_t )npc + tmp___20 > (size_t )cpl) {
#line 629
                    Print(8, "\n            ");
#line 630
                    npc = 12;
                  }
#line 632
                  Print(8, "  %s", buff);
#line 633
                  tmp___21 = strlen((char const   *)(buff));
#line 633
                  npc = (int )((size_t )npc + (tmp___21 + 2UL));
                }
#line 625
                i ++;
              }
              while_break___14: /* CIL Label */ ;
              }
#line 635
              if (npc) {
#line 636
                Print(8, "\n");
              }
#line 637
              npc = 24;
#line 638
              cpl = 75;
#line 639
              if (tree->null_done[null_depth]) {
#line 640
                Print(8, "        null-move (R):");
              }
#line 641
              i = null_depth;
              {
#line 641
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 641
                if (! (i < 16)) {
#line 641
                  goto while_break___15;
                }
#line 642
                if (tree->null_done[i]) {
#line 643
                  tmp___22 = DisplayKMB(tree->null_done[i], 0);
#line 643
                  sprintf(buff, (char const   *)"%d/%s", i, tmp___22);
#line 644
                  tmp___23 = strlen((char const   *)(buff));
#line 644
                  if ((size_t )npc + tmp___23 > (size_t )cpl) {
#line 645
                    Print(8, "\n            ");
#line 646
                    npc = 12;
                  }
#line 648
                  Print(8, "  %s", buff);
#line 649
                  tmp___24 = strlen((char const   *)(buff));
#line 649
                  npc = (int )((size_t )npc + (tmp___24 + 2UL));
                }
#line 641
                i ++;
              }
              while_break___15: /* CIL Label */ ;
              }
#line 651
              if (npc) {
#line 652
                Print(8, "\n");
              }
#line 653
              if (parallel_splits) {
#line 654
                max = 0;
#line 655
                i = 0;
                {
#line 655
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 655
                  if (! ((unsigned int )i < smp_max_threads)) {
#line 655
                    goto while_break___16;
                  }
#line 656
                  tmp___27 = __builtin_popcountll((unsigned long long )thread[i].max_blocks);
#line 656
                  if (max > tmp___27) {
#line 656
                    max = max;
                  } else {
#line 656
                    tmp___26 = __builtin_popcountll((unsigned long long )thread[i].max_blocks);
#line 656
                    max = tmp___26;
                  }
#line 657
                  game_max_blocks |= thread[i].max_blocks;
#line 655
                  i ++;
                }
                while_break___16: /* CIL Label */ ;
                }
#line 659
                tmp___28 = DisplayKMB((uint64_t )parallel_splits, 0);
#line 659
                Print(8, "        splits=%s", tmp___28);
#line 660
                tmp___29 = DisplayKMB((uint64_t )parallel_splits_wasted, 0);
#line 660
                Print(8, "(%s)", tmp___29);
#line 661
                tmp___30 = DisplayKMB((uint64_t )parallel_aborts, 0);
#line 661
                Print(8, "  aborts=%s", tmp___30);
#line 662
                tmp___31 = DisplayKMB((uint64_t )parallel_joins, 0);
#line 662
                Print(8, "  joins=%s", tmp___31);
#line 663
                tmp___32 = __builtin_popcountll((unsigned long long )game_max_blocks);
#line 663
                Print(8, "  data=%d%%(%d%%)\n", (100 * max) / 64, (100 * tmp___32) / 64);
              }
            } else {
#line 592
              goto _L___9;
            }
          } else {
            _L___9: /* CIL Label */ ;
          }
#line 133
          if (! 0) {
#line 133
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 697
  if (smp_nice) {
#line 697
    if (ponder == 0) {
#line 697
      if (smp_threads) {
#line 700
        Print(64, "terminating SMP processes.\n");
#line 701
        proc___0 = 1;
        {
#line 701
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 701
          if (! (proc___0 < 4)) {
#line 701
            goto while_break___17;
          }
#line 702
          thread[proc___0].terminate = (unsigned int volatile   )1;
#line 701
          proc___0 ++;
        }
        while_break___17: /* CIL Label */ ;
        }
        {
#line 703
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 703
          if (! smp_threads) {
#line 703
            goto while_break___18;
          }
        }
        while_break___18: /* CIL Label */ ;
        }
#line 704
        smp_split = (int volatile   )0;
      } else {
#line 697
        goto _L___13;
      }
    } else {
#line 697
      goto _L___13;
    }
  } else {
    _L___13: /* CIL Label */ 
    _L___12: /* CIL Label */ ;
  }
#line 706
  program_end_time = ReadClock();
#line 707
  search_move = 0;
#line 708
  if (quit) {
#line 709
    CraftyExit(0);
  }
#line 710
  return (last_root_value);
}
}
#line 18 "search.c"
int Search(TREE *tree , int ply , int depth , int wtm , int alpha , int beta , int in_check ,
           int do_null ) 
{ 
  int repeat ;
  int value ;
  int pv_node ;
  int n_depth ;
  int searched[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tb_result ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  uint64_t save_hash_key ;
  int R ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 20
  repeat = 0;
#line 20
  value = 0;
#line 20
  pv_node = alpha != beta - 1;
#line 46
  if (tree->thread_id == 0) {
#line 47
    next_time_check --;
#line 47
    if (next_time_check <= 0) {
#line 48
      next_time_check = (int )nodes_between_time_checks;
#line 49
      tmp = TimeCheck(tree, 1);
#line 49
      if (tmp) {
#line 50
        abort_search = 1;
#line 51
        return (0);
      }
#line 53
      tmp___0 = CheckInput();
#line 53
      if (tmp___0) {
#line 54
        Interrupt(ply);
#line 55
        if (abort_search) {
#line 56
          return (0);
        }
      }
    }
  }
#line 60
  if (ply >= 128) {
#line 61
    return (beta);
  }
#line 73
  if (ply > 1) {
#line 74
    repeat = Repeat(tree, ply);
#line 74
    if (repeat) {
#line 75
      if (repeat == 2) {
#line 75
        goto _L;
      } else
#line 75
      if (! in_check) {
        _L: /* CIL Label */ 
#line 76
        value = draw_score[wtm];
#line 77
        if (value < beta) {
          {
#line 78
          while (1) {
            while_continue: /* CIL Label */ ;
#line 78
            tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
#line 78
            tree->pv[ply - 1].pathl = ply;
#line 78
            tree->pv[ply - 1].pathh = repeat;
#line 78
            tree->pv[ply - 1].pathd = iteration;
#line 78
            if (! 0) {
#line 78
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
#line 84
        return (value);
      }
    }
#line 98
    if (alpha > (-32768 + ply) - 1) {
#line 98
      alpha = alpha;
    } else {
#line 98
      alpha = (-32768 + ply) - 1;
    }
#line 99
    if (beta < 32768 - ply) {
#line 99
      beta = beta;
    } else {
#line 99
      beta = 32768 - ply;
    }
#line 100
    if (alpha >= beta) {
#line 101
      return (alpha);
    }
#line 128
    tmp___1 = HashProbe(tree, ply, depth, wtm, alpha, beta, & value);
    {
#line 129
    if (tmp___1 == 1) {
#line 129
      goto case_1;
    }
#line 131
    if (tmp___1 == 2) {
#line 131
      goto case_2;
    }
#line 133
    if (tmp___1 == 0) {
#line 133
      goto case_0;
    }
#line 128
    goto switch_break;
    case_1: /* CIL Label */ 
#line 130
    return (value);
    case_2: /* CIL Label */ 
#line 132
    do_null = 0;
    case_0: /* CIL Label */ 
#line 134
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 177
    if (depth > EGTB_depth) {
#line 177
      if ((int )tree->position.total_all_pieces <= EGTB_use) {
#line 177
        if (! tree->status[ply].castle[1]) {
#line 177
          if (! tree->status[ply].castle[0]) {
#line 177
            if ((int )tree->status[ply].reversible == 0) {
#line 181
              (tree->egtb_probes) ++;
#line 182
              tmp___2 = tb_probe_wdl(tree->position.color[1].pieces[0], tree->position.color[0].pieces[0],
                                     tree->position.color[1].pieces[6] | tree->position.color[0].pieces[6],
                                     tree->position.color[1].pieces[5] | tree->position.color[0].pieces[5],
                                     tree->position.color[1].pieces[4] | tree->position.color[0].pieces[4],
                                     tree->position.color[1].pieces[3] | tree->position.color[0].pieces[3],
                                     tree->position.color[1].pieces[2] | tree->position.color[0].pieces[2],
                                     tree->position.color[1].pieces[1] | tree->position.color[0].pieces[1],
                                     (unsigned int )tree->status[ply].reversible,
                                     0U, (unsigned int )tree->status[ply].enpassant_target,
                                     (_Bool )wtm, tree->position.hash_key);
#line 182
              tb_result = (int )tmp___2;
#line 188
              if ((unsigned int )tb_result != 0xFFFFFFFF) {
#line 189
                (tree->egtb_hits) ++;
                {
#line 191
                if (tb_result == 0) {
#line 191
                  goto case_0___0;
                }
#line 194
                if (tb_result == 1) {
#line 194
                  goto case_1___0;
                }
#line 197
                if (tb_result == 2) {
#line 197
                  goto case_2___0;
                }
#line 200
                if (tb_result == 3) {
#line 200
                  goto case_3;
                }
#line 203
                if (tb_result == 4) {
#line 203
                  goto case_4;
                }
#line 190
                goto switch_break___0;
                case_0___0: /* CIL Label */ 
#line 192
                alpha = -31000;
#line 193
                goto switch_break___0;
                case_1___0: /* CIL Label */ 
#line 195
                alpha = -3;
#line 196
                goto switch_break___0;
                case_2___0: /* CIL Label */ 
#line 198
                alpha = 0;
#line 199
                goto switch_break___0;
                case_3: /* CIL Label */ 
#line 201
                alpha = 3;
#line 202
                goto switch_break___0;
                case_4: /* CIL Label */ 
#line 204
                alpha = 31000;
#line 205
                goto switch_break___0;
                switch_break___0: /* CIL Label */ ;
                }
#line 207
                if (tb_result != 0) {
#line 207
                  if (tb_result != 4) {
#line 208
                    if (wtm) {
#line 208
                      tmp___4 = tree->position.material_evaluation;
                    } else {
#line 208
                      tmp___4 = - tree->position.material_evaluation;
                    }
#line 208
                    if (tmp___4 > 0) {
#line 209
                      alpha ++;
                    } else {
#line 210
                      if (wtm) {
#line 210
                        tmp___3 = tree->position.material_evaluation;
                      } else {
#line 210
                        tmp___3 = - tree->position.material_evaluation;
                      }
#line 210
                      if (tmp___3 < 0) {
#line 211
                        alpha --;
                      }
                    }
                  } else {
#line 207
                    goto _L___0;
                  }
                } else {
                  _L___0: /* CIL Label */ ;
                }
#line 213
                if (alpha < beta) {
                  {
#line 214
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 214
                    tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
#line 214
                    tree->pv[ply - 1].pathl = ply;
#line 214
                    tree->pv[ply - 1].pathh = 4;
#line 214
                    tree->pv[ply - 1].pathd = iteration;
#line 214
                    if (! 0) {
#line 214
                      goto while_break___0;
                    }
                  }
                  while_break___0: /* CIL Label */ ;
                  }
                }
#line 215
                return (alpha);
              }
            } else {
#line 177
              goto _L___4;
            }
          } else {
#line 177
            goto _L___4;
          }
        } else {
#line 177
          goto _L___4;
        }
      } else {
#line 177
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
      _L___3: /* CIL Label */ 
      _L___2: /* CIL Label */ 
      _L___1: /* CIL Label */ ;
    }
#line 259
    tree->last[ply] = tree->last[ply - 1];
#line 260
    if ((int )tree->position.pieces[wtm][0] > 9) {
#line 260
      goto _L___6;
    } else
#line 260
    if (n_root_moves > 17) {
      _L___6: /* CIL Label */ 
#line 260
      goto _L___5;
    } else
#line 260
    if (depth > 3) {
      _L___5: /* CIL Label */ 
#line 260
      n_depth = 1;
    } else {
#line 260
      n_depth = 3;
    }
#line 262
    if (do_null) {
#line 262
      if (! pv_node) {
#line 262
        if (depth > n_depth) {
#line 262
          if (! in_check) {
#line 262
            if (tree->position.pieces[wtm][0]) {
#line 265
              R = null_depth + depth / null_divisor;
#line 267
              tree->curmv[ply] = 0;
#line 273
              tree->status[ply + 1] = tree->status[ply];
#line 274
              tree->status[ply + 1].reversible = (uint8_t )0;
#line 275
              save_hash_key = tree->position.hash_key;
#line 276
              if (tree->status[ply + 1].enpassant_target) {
#line 277
                tree->position.hash_key ^= (unsigned long )enpassant_random[tree->status[ply + 1].enpassant_target];
#line 278
                tree->status[ply + 1].enpassant_target = (uint8_t )0;
              }
#line 280
              if (R < 15) {
#line 280
                tmp___5 = R;
              } else {
#line 280
                tmp___5 = 15;
              }
#line 280
              (tree->null_done[tmp___5]) ++;
#line 281
              if ((depth - R) - 1 > 0) {
#line 282
                tmp___6 = Search(tree, ply + 1, (depth - R) - 1, wtm ^ 1, - beta,
                                 - beta + 1, 0, 0);
#line 282
                value = - tmp___6;
              } else {
#line 286
                tmp___7 = Quiesce(tree, ply + 1, wtm ^ 1, - beta, - beta + 1, 1);
#line 286
                value = - tmp___7;
              }
#line 287
              tree->position.hash_key = save_hash_key;
#line 288
              if (abort_search) {
#line 288
                goto _L___7;
              } else
#line 288
              if (tree->stop) {
                _L___7: /* CIL Label */ 
#line 289
                return (0);
              }
#line 290
              if (value >= beta) {
#line 291
                HashStore(tree, ply, depth, wtm, 2, value, tree->hash_move[ply]);
#line 292
                return (value);
              }
            } else {
#line 262
              goto _L___11;
            }
          } else {
#line 262
            goto _L___11;
          }
        } else {
#line 262
          goto _L___11;
        }
      } else {
#line 262
        goto _L___11;
      }
    } else {
      _L___11: /* CIL Label */ 
      _L___10: /* CIL Label */ 
      _L___9: /* CIL Label */ 
      _L___8: /* CIL Label */ ;
    }
#line 310
    tree->next_status[ply].phase = 2;
#line 311
    if (! tree->hash_move[ply]) {
#line 311
      if (depth >= 6) {
#line 311
        if (do_null) {
#line 311
          if (ply > 1) {
#line 311
            if (pv_node) {
#line 312
              tree->curmv[ply] = 0;
#line 313
              if (depth - 2 > 0) {
#line 314
                value = Search(tree, ply, depth - 2, wtm, alpha, beta, in_check, 1);
              } else {
#line 317
                value = Quiesce(tree, ply, wtm, alpha, beta, 1);
              }
#line 318
              if (abort_search) {
#line 318
                goto _L___12;
              } else
#line 318
              if (tree->stop) {
                _L___12: /* CIL Label */ 
#line 319
                return (0);
              }
#line 320
              if (value > alpha) {
#line 321
                if (value < beta) {
#line 322
                  if (tree->pv[ply - 1].pathl > ply) {
#line 323
                    tree->hash_move[ply] = tree->pv[ply - 1].path[ply];
                  }
                } else {
#line 325
                  tree->hash_move[ply] = tree->curmv[ply];
                }
#line 326
                tree->last[ply] = tree->last[ply - 1];
#line 327
                tree->next_status[ply].phase = 2;
              }
            } else {
#line 311
              goto _L___16;
            }
          } else {
#line 311
            goto _L___16;
          }
        } else {
#line 311
          goto _L___16;
        }
      } else {
#line 311
        goto _L___16;
      }
    } else {
      _L___16: /* CIL Label */ 
      _L___15: /* CIL Label */ 
      _L___14: /* CIL Label */ 
      _L___13: /* CIL Label */ ;
    }
  }
#line 342
  searched[0] = 0;
#line 343
  value = SearchMoveList(tree, ply, depth, wtm, alpha, beta, searched, in_check, repeat,
                         0);
#line 346
  return (value);
}
}
#line 379 "search.c"
int SearchMoveList(TREE *tree , int ply , int depth , int wtm , int alpha , int beta ,
                   int *searched , int in_check , int repeat , int mode___0 ) 
{ 
  TREE *current ;
  int extend ;
  int reduce ;
  int check ;
  int original_alpha ;
  int t_beta ;
  int i ;
  int j___0 ;
  int value ;
  int pv_node ;
  int search_result ;
  int order ;
  int moves_done ;
  int bestmove ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int proc ;
  int best ;
  ROOT_MOVE t ;
  ROOT_MOVE t___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 382
  original_alpha = alpha;
#line 383
  value = 0;
#line 383
  pv_node = alpha != beta - 1;
#line 384
  moves_done = 0;
#line 406
  tree->next_status[ply].phase = 2;
#line 407
  if (mode___0 == 1) {
#line 408
    current = tree->parent;
#line 409
    t_beta = alpha + 1;
  } else {
#line 411
    current = tree;
#line 412
    t_beta = beta;
  }
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! 1) {
#line 432
      goto while_break;
    }
#line 433
    if (ply == 1) {
#line 433
      if (moves_done == 1) {
#line 433
        if (alpha == original_alpha) {
#line 433
          if (mode___0 == 0) {
#line 435
            goto while_break;
          } else {
#line 433
            goto _L___1;
          }
        } else {
#line 433
          goto _L___1;
        }
      } else {
#line 433
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
#line 436
    if (mode___0 == 1) {
#line 437
      LockX86(& current->lock);
    }
#line 438
    if (ply > 1) {
#line 438
      tmp = NextMove(current, ply, depth, wtm, in_check);
#line 438
      order = tmp;
    } else {
#line 438
      tmp___0 = NextRootMove(current, tree, wtm);
#line 438
      order = tmp___0;
    }
#line 440
    if (mode___0 == 1) {
#line 441
      tree->curmv[ply] = current->curmv[ply];
#line 442
      UnlockX86(& current->lock);
    }
#line 444
    if (! order) {
#line 445
      goto while_break;
    }
#line 451
    MakeMove(tree, ply, wtm, tree->curmv[ply]);
#line 452
    (tree->nodes_searched) ++;
#line 453
    search_result = 0;
#line 454
    if (in_check) {
#line 454
      goto _L___19;
    } else {
#line 454
      tmp___6 = Attacks(tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 454
      if (! tmp___6) {
        _L___19: /* CIL Label */ 
        {
#line 455
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 456
          (*(searched + 0)) ++;
#line 457
          moves_done ++;
#line 458
          search_result = 1;
#line 459
          *(searched + *(searched + 0)) = tree->curmv[ply];
#line 476
          extend = 0;
#line 477
          reduce = 0;
#line 478
          tmp___2 = Attacks(tree, (wtm ^ 1) ^ 1, tree->position.kingsq[wtm ^ 1]);
#line 478
          if (tmp___2) {
#line 479
            check = 1;
#line 480
            tmp___1 = SEEO(tree, wtm, tree->curmv[ply]);
#line 480
            if (tmp___1 - (int )pcval[(tree->curmv[ply] >> 15) & 7] <= 0) {
#line 483
              extend = check_depth;
#line 484
              (tree->extensions_done) ++;
            }
          } else {
#line 487
            check = 0;
          }
#line 532
          if (! in_check) {
#line 532
            if (! extend) {
#line 532
              goto _L___17;
            } else
#line 532
            if (! pv_node) {
              _L___17: /* CIL Label */ 
#line 532
              if (order > 1) {
#line 532
                if (((tree->curmv[ply] >> 12) & 7) == 1) {
#line 532
                  if (rankflip[wtm][((tree->curmv[ply] >> 6) & 63) >> 3] >= 5) {
#line 532
                    if (! (mask_passed[wtm][(tree->curmv[ply] >> 6) & 63] & tree->position.color[wtm ^ 1].pieces[1])) {
#line 532
                      goto _L___16;
                    } else {
#line 532
                      goto _L___14;
                    }
                  } else {
#line 532
                    goto _L___14;
                  }
                } else {
                  _L___14: /* CIL Label */ 
                  _L___13: /* CIL Label */ 
#line 534
                  if (depth < FP_depth) {
#line 534
                    if (! check) {
#line 534
                      if (wtm) {
#line 534
                        tmp___3 = tree->position.material_evaluation;
                      } else {
#line 534
                        tmp___3 = - tree->position.material_evaluation;
                      }
#line 534
                      if (tmp___3 + FP_margin[depth] <= alpha) {
#line 534
                        if (! pv_node) {
#line 536
                          (tree->moves_fpruned) ++;
#line 537
                          goto while_break___0;
                        } else {
#line 534
                          goto _L___4;
                        }
                      } else {
#line 534
                        goto _L___4;
                      }
                    } else {
#line 534
                      goto _L___4;
                    }
                  } else {
                    _L___4: /* CIL Label */ 
                    _L___3: /* CIL Label */ 
                    _L___2: /* CIL Label */ ;
                  }
#line 559
                  if (order > LMP[depth]) {
#line 559
                    if (depth < LMP_depth) {
#line 559
                      if (! pv_node) {
#line 559
                        if (! check) {
#line 559
                          if (alpha > -32468) {
#line 559
                            if (! ((tree->curmv[ply] >> 15) & 63)) {
#line 561
                              (tree->moves_mpruned) ++;
#line 562
                              goto while_break___0;
                            } else {
#line 559
                              goto _L___9;
                            }
                          } else {
#line 559
                            goto _L___9;
                          }
                        } else {
#line 559
                          goto _L___9;
                        }
                      } else {
#line 559
                        goto _L___9;
                      }
                    } else {
#line 559
                      goto _L___9;
                    }
                  } else {
                    _L___9: /* CIL Label */ 
                    _L___8: /* CIL Label */ 
                    _L___7: /* CIL Label */ 
                    _L___6: /* CIL Label */ 
                    _L___5: /* CIL Label */ ;
                  }
#line 580
                  if (depth < 31) {
#line 580
                    tmp___4 = depth;
                  } else {
#line 580
                    tmp___4 = 31;
                  }
#line 580
                  if (order < 63) {
#line 580
                    tmp___5 = order;
                  } else {
#line 580
                    tmp___5 = 63;
                  }
#line 580
                  reduce = (int )LMR[tmp___4][tmp___5];
#line 581
                  if (reduce) {
#line 581
                    if (pv_node) {
#line 581
                      goto _L___11;
                    } else
#line 581
                    if (extend) {
                      _L___11: /* CIL Label */ 
#line 582
                      reduce --;
                    } else {
#line 581
                      goto _L___10;
                    }
                  } else {
                    _L___10: /* CIL Label */ ;
                  }
#line 583
                  (tree->LMR_done[reduce]) ++;
                }
              } else {
#line 532
                goto _L___16;
              }
            } else {
#line 532
              goto _L___16;
            }
          } else {
            _L___16: /* CIL Label */ 
            _L___15: /* CIL Label */ 
            _L___12: /* CIL Label */ ;
          }
#line 599
          value = SearchMove(tree, ply, depth, wtm, alpha, t_beta, beta, extend, reduce,
                             check);
#line 602
          if (value > alpha) {
#line 603
            search_result = 2;
#line 604
            if (value >= beta) {
#line 605
              search_result = 3;
            }
#line 606
            if (mode___0 == 1) {
#line 606
              if (ply == 1) {
#line 607
                search_result = 3;
              } else {
#line 606
                goto _L___18;
              }
            } else {
              _L___18: /* CIL Label */ ;
            }
          }
#line 455
          if (! 0) {
#line 455
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 610
    UnmakeMove(tree, ply, wtm, tree->curmv[ply]);
#line 611
    if (abort_search) {
#line 611
      goto _L___20;
    } else
#line 611
    if (tree->stop) {
      _L___20: /* CIL Label */ 
#line 612
      goto while_break;
    }
#line 642
    if (search_result == 3) {
#line 643
      if (ply == 1) {
#line 644
        if (! tree->stop) {
#line 645
          tree->pv[1].path[1] = tree->curmv[1];
#line 646
          tree->pv[1].pathl = 2;
#line 647
          tree->pv[1].pathh = 0;
#line 648
          tree->pv[1].pathd = iteration;
#line 649
          tree->pv[0] = tree->pv[1];
        }
      }
#line 653
      if (mode___0 == 1) {
#line 654
        LockX86(& lock_smp);
#line 655
        LockX86(& (tree->parent)->lock);
#line 656
        if (! tree->stop) {
#line 659
          parallel_aborts ++;
#line 660
          proc = 0;
          {
#line 660
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 660
            if (! ((unsigned int )proc < smp_max_threads)) {
#line 660
              goto while_break___1;
            }
#line 661
            if ((tree->parent)->siblings[proc]) {
#line 661
              if (proc != tree->thread_id) {
#line 662
                ThreadStop((TREE *)(tree->parent)->siblings[proc]);
              } else {
#line 661
                goto _L___21;
              }
            } else {
              _L___21: /* CIL Label */ ;
            }
#line 660
            proc ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 664
        UnlockX86(& (tree->parent)->lock);
#line 665
        UnlockX86(& lock_smp);
#line 666
        return (beta);
      }
#line 669
      (tree->fail_highs) ++;
#line 670
      if (order == 1) {
#line 671
        (tree->fail_high_first_move) ++;
      }
#line 672
      HashStore(tree, ply, depth, wtm, 2, value, tree->curmv[ply]);
#line 673
      History(tree, ply, depth, wtm, tree->curmv[ply], searched);
#line 674
      return (beta);
    } else
#line 702
    if (search_result == 2) {
#line 703
      alpha = value;
#line 704
      if (ply == 1) {
#line 704
        if (mode___0 == 0) {
#line 710
          tree->pv[1].pathv = value;
#line 711
          tree->pv[0] = tree->pv[1];
#line 712
          best = 0;
          {
#line 712
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 712
            if (! (best < n_root_moves)) {
#line 712
              goto while_break___2;
            }
#line 713
            if (root_moves[best].move == tree->pv[1].path[1]) {
#line 714
              root_moves[best].path = tree->pv[1];
#line 715
              root_moves[best].path.pathv = alpha;
#line 716
              goto while_break___2;
            }
#line 712
            best ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 721
          if (best != 0) {
#line 723
            t = root_moves[best];
#line 724
            i = best;
            {
#line 724
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 724
              if (! (i > 0)) {
#line 724
                goto while_break___3;
              }
#line 725
              root_moves[i] = root_moves[i - 1];
#line 724
              i --;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 726
            root_moves[0] = t;
          }
#line 732
          i = 0;
          {
#line 732
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 732
            if (! (i < n_root_moves)) {
#line 732
              goto while_break___4;
            }
#line 733
            if (value <= root_moves[i].path.pathv) {
#line 735
              value = root_moves[i].path.pathv;
#line 736
              alpha = value;
#line 737
              tree->pv[0] = root_moves[i].path;
#line 738
              tree->pv[1] = tree->pv[0];
#line 739
              t___0 = root_moves[i];
#line 740
              j___0 = i;
              {
#line 740
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 740
                if (! (j___0 > 0)) {
#line 740
                  goto while_break___5;
                }
#line 741
                root_moves[j___0] = root_moves[j___0 - 1];
#line 740
                j___0 --;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 742
              root_moves[0] = t___0;
            }
#line 732
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 745
          Output(tree);
#line 746
          failhi_delta = 16;
#line 747
          faillo_delta = 16;
        } else {
#line 704
          goto _L___22;
        }
      } else {
        _L___22: /* CIL Label */ ;
      }
    } else
#line 759
    if (search_result == 0) {
#line 760
      goto while_continue;
    }
#line 761
    t_beta = alpha + 1;
#line 833
    if (mode___0 == 0) {
#line 833
      if (moves_done) {
#line 833
        if (smp_threads) {
#line 833
          tmp___8 = ThreadSplit(tree, ply, depth, alpha, original_alpha, moves_done);
#line 833
          if (tmp___8) {
            {
#line 835
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 836
              tree->alpha = alpha;
#line 837
              tree->beta = beta;
#line 838
              tree->value = (int volatile   )alpha;
#line 839
              tree->wtm = wtm;
#line 840
              tree->ply = ply;
#line 841
              tree->depth = depth;
#line 842
              tree->in_check = in_check;
#line 843
              tree->searched = searched;
#line 844
              tmp___7 = Split(tree);
#line 844
              if (tmp___7) {
#line 845
                if (abort_search) {
#line 845
                  goto _L___23;
                } else
#line 845
                if (tree->stop) {
                  _L___23: /* CIL Label */ 
#line 846
                  return (0);
                }
#line 847
                value = (int )tree->value;
#line 848
                if (value > alpha) {
#line 849
                  if (ply == 1) {
#line 850
                    tree->pv[0] = tree->pv[1];
                  }
#line 851
                  if (value >= beta) {
#line 852
                    HashStore(tree, ply, depth, wtm, 2, value, tree->cutmove);
#line 853
                    return (value);
                  }
#line 855
                  alpha = value;
#line 856
                  goto while_break___6;
                }
              }
#line 835
              if (! 0) {
#line 835
                goto while_break___6;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
          } else {
#line 833
            goto _L___26;
          }
        } else {
#line 833
          goto _L___26;
        }
      } else {
#line 833
        goto _L___26;
      }
    } else {
      _L___26: /* CIL Label */ 
      _L___25: /* CIL Label */ 
      _L___24: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 878
  if (abort_search) {
#line 878
    goto _L___28;
  } else
#line 878
  if (tree->stop) {
    _L___28: /* CIL Label */ 
#line 878
    goto _L___27;
  } else
#line 878
  if (mode___0 == 1) {
    _L___27: /* CIL Label */ 
#line 879
    return (alpha);
  }
#line 889
  if (moves_done == 0) {
#line 890
    tmp___10 = Attacks(tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 890
    if (tmp___10) {
#line 890
      value = - (32768 - ply);
    } else {
#line 890
      value = draw_score[wtm];
    }
#line 891
    if (value >= alpha) {
#line 891
      if (value < beta) {
        {
#line 892
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 892
          tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
#line 892
          tree->pv[ply - 1].pathl = ply;
#line 892
          tree->pv[ply - 1].pathh = 0;
#line 892
          tree->pv[ply - 1].pathd = iteration;
#line 892
          if (! 0) {
#line 892
            goto while_break___7;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
#line 891
        goto _L___29;
      }
    } else {
      _L___29: /* CIL Label */ ;
    }
#line 898
    return (value);
  } else {
#line 900
    if (alpha == original_alpha) {
#line 900
      bestmove = tree->hash_move[ply];
    } else {
#line 900
      bestmove = tree->pv[ply].path[ply];
    }
#line 903
    if (alpha == original_alpha) {
#line 903
      type = 1;
    } else {
#line 903
      type = 3;
    }
#line 904
    if (repeat == 2) {
#line 904
      if (alpha != - ((32768 - ply) - 1)) {
#line 905
        value = draw_score[wtm];
#line 906
        if (value < beta) {
          {
#line 907
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 907
            tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
#line 907
            tree->pv[ply - 1].pathl = ply;
#line 907
            tree->pv[ply - 1].pathh = 3;
#line 907
            tree->pv[ply - 1].pathd = iteration;
#line 907
            if (! 0) {
#line 907
              goto while_break___8;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 912
        return (value);
      } else {
#line 904
        goto _L___30;
      }
    } else
    _L___30: /* CIL Label */ 
#line 913
    if (alpha != original_alpha) {
#line 914
      tree->pv[ply - 1] = tree->pv[ply];
#line 915
      tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
    }
#line 917
    HashStore(tree, ply, depth, wtm, type, alpha, bestmove);
#line 918
    return (alpha);
  }
}
}
#line 933 "search.c"
int SearchMove(TREE *tree , int ply , int depth , int wtm , int alpha , int t_beta ,
               int beta , int extend , int reduce , int check ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 954
  if (((depth + extend) - reduce) - 1 > 0) {
#line 955
    tmp = Search(tree, ply + 1, ((depth + extend) - reduce) - 1, wtm ^ 1, - t_beta,
                 - alpha, check, 1);
#line 955
    value = - tmp;
#line 958
    if (value > alpha) {
#line 958
      if (reduce) {
#line 959
        tmp___0 = Search(tree, ply + 1, depth - 1, wtm ^ 1, - t_beta, - alpha, check,
                         1);
#line 959
        value = - tmp___0;
      } else {
#line 958
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
  } else {
#line 964
    tmp___1 = Quiesce(tree, ply + 1, wtm ^ 1, - t_beta, - alpha, 1);
#line 964
    value = - tmp___1;
  }
#line 965
  if (abort_search) {
#line 965
    goto _L___0;
  } else
#line 965
  if (tree->stop) {
    _L___0: /* CIL Label */ 
#line 966
    return (0);
  }
#line 980
  if (value > alpha) {
#line 980
    if (value < beta) {
#line 980
      if (t_beta < beta) {
#line 981
        if (ply == 1) {
#line 982
          return (beta);
        }
#line 983
        if ((depth + extend) - 1 > 0) {
#line 984
          tmp___2 = Search(tree, ply + 1, (depth + extend) - 1, wtm ^ 1, - beta, - alpha,
                           check, 1);
#line 984
          value = - tmp___2;
        } else {
#line 988
          tmp___3 = Quiesce(tree, ply + 1, wtm ^ 1, - beta, - alpha, 1);
#line 988
          value = - tmp___3;
        }
#line 989
        if (abort_search) {
#line 989
          goto _L___1;
        } else
#line 989
        if (tree->stop) {
          _L___1: /* CIL Label */ 
#line 990
          return (0);
        }
      } else {
#line 980
        goto _L___3;
      }
    } else {
#line 980
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    _L___2: /* CIL Label */ ;
  }
#line 992
  return (value);
}
}
#line 16 "movgen.c"
unsigned int *GenerateCaptures(TREE *tree , int ply , int side , unsigned int *move ) 
{ 
  uint64_t target ;
  uint64_t piecebd ;
  uint64_t moves ;
  uint64_t promotions ;
  uint64_t pcapturesl ;
  uint64_t pcapturesr ;
  int from ;
  int to ;
  int temp ;
  int common ;
  int enemy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  unsigned int *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  unsigned int *tmp___25 ;
  int tmp___26 ;
  uint64_t tmp___27 ;
  unsigned int *tmp___28 ;
  uint64_t tmp___29 ;
  unsigned long tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  unsigned int *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  unsigned int *tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  unsigned long tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  unsigned int *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  unsigned int *tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;

  {
#line 19
  enemy = side ^ 1;
#line 31
  piecebd = tree->position.color[side].pieces[2];
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! piecebd) {
#line 31
      goto while_break;
    }
#line 32
    if (side) {
#line 32
      tmp = __builtin_clzll((unsigned long long )piecebd);
#line 32
      from = 63 - tmp;
    } else {
#line 32
      tmp___0 = __builtin_ctzll((unsigned long long )piecebd);
#line 32
      from = tmp___0;
    }
#line 33
    moves = knight_attacks[from] & tree->position.color[enemy].pieces[0];
#line 34
    temp = from + (2 << 12);
    {
#line 35
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 35
      if (! moves) {
#line 35
        goto while_break___0;
      }
#line 35
      if (side) {
#line 35
        tmp___1 = __builtin_clzll((unsigned long long )moves);
#line 35
        to = 63 - tmp___1;
      } else {
#line 35
        tmp___2 = __builtin_ctzll((unsigned long long )moves);
#line 35
        to = tmp___2;
      }
#line 35
      tmp___3 = move;
#line 35
      move ++;
#line 35
      if ((int )tree->position.board[to] > 0) {
#line 35
        tmp___4 = (int )tree->position.board[to];
      } else {
#line 35
        tmp___4 = - ((int )tree->position.board[to]);
      }
#line 35
      *tmp___3 = (unsigned int )((temp | (to << 6)) | (tmp___4 << 15));
#line 35
      moves = clear_mask[to] & moves;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 31
    piecebd = clear_mask[from] & piecebd;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  piecebd = tree->position.color[side].pieces[3];
  {
#line 48
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 48
    if (! piecebd) {
#line 48
      goto while_break___1;
    }
#line 49
    if (side) {
#line 49
      tmp___5 = __builtin_clzll((unsigned long long )piecebd);
#line 49
      from = 63 - tmp___5;
    } else {
#line 49
      tmp___6 = __builtin_ctzll((unsigned long long )piecebd);
#line 49
      from = tmp___6;
    }
#line 50
    moves = *(magic_bishop_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[from]) * (unsigned long )magic_bishop[from] >> magic_bishop_shift[from])) & tree->position.color[enemy].pieces[0];
#line 51
    temp = from + (3 << 12);
    {
#line 52
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 52
      if (! moves) {
#line 52
        goto while_break___2;
      }
#line 52
      if (side) {
#line 52
        tmp___7 = __builtin_clzll((unsigned long long )moves);
#line 52
        to = 63 - tmp___7;
      } else {
#line 52
        tmp___8 = __builtin_ctzll((unsigned long long )moves);
#line 52
        to = tmp___8;
      }
#line 52
      tmp___9 = move;
#line 52
      move ++;
#line 52
      if ((int )tree->position.board[to] > 0) {
#line 52
        tmp___10 = (int )tree->position.board[to];
      } else {
#line 52
        tmp___10 = - ((int )tree->position.board[to]);
      }
#line 52
      *tmp___9 = (unsigned int )((temp | (to << 6)) | (tmp___10 << 15));
#line 52
      moves = clear_mask[to] & moves;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 48
    piecebd = clear_mask[from] & piecebd;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 54
  piecebd = tree->position.color[side].pieces[4];
  {
#line 54
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 54
    if (! piecebd) {
#line 54
      goto while_break___3;
    }
#line 55
    if (side) {
#line 55
      tmp___11 = __builtin_clzll((unsigned long long )piecebd);
#line 55
      from = 63 - tmp___11;
    } else {
#line 55
      tmp___12 = __builtin_ctzll((unsigned long long )piecebd);
#line 55
      from = tmp___12;
    }
#line 56
    moves = *(magic_rook_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[from]) * (unsigned long )magic_rook[from] >> magic_rook_shift[from])) & tree->position.color[enemy].pieces[0];
#line 57
    temp = from + (4 << 12);
    {
#line 58
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 58
      if (! moves) {
#line 58
        goto while_break___4;
      }
#line 58
      if (side) {
#line 58
        tmp___13 = __builtin_clzll((unsigned long long )moves);
#line 58
        to = 63 - tmp___13;
      } else {
#line 58
        tmp___14 = __builtin_ctzll((unsigned long long )moves);
#line 58
        to = tmp___14;
      }
#line 58
      tmp___15 = move;
#line 58
      move ++;
#line 58
      if ((int )tree->position.board[to] > 0) {
#line 58
        tmp___16 = (int )tree->position.board[to];
      } else {
#line 58
        tmp___16 = - ((int )tree->position.board[to]);
      }
#line 58
      *tmp___15 = (unsigned int )((temp | (to << 6)) | (tmp___16 << 15));
#line 58
      moves = clear_mask[to] & moves;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 54
    piecebd = clear_mask[from] & piecebd;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 60
  piecebd = tree->position.color[side].pieces[5];
  {
#line 60
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 60
    if (! piecebd) {
#line 60
      goto while_break___5;
    }
#line 61
    if (side) {
#line 61
      tmp___17 = __builtin_clzll((unsigned long long )piecebd);
#line 61
      from = 63 - tmp___17;
    } else {
#line 61
      tmp___18 = __builtin_ctzll((unsigned long long )piecebd);
#line 61
      from = tmp___18;
    }
#line 62
    moves = (*(magic_bishop_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[from]) * (unsigned long )magic_bishop[from] >> magic_bishop_shift[from])) | *(magic_rook_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[from]) * (unsigned long )magic_rook[from] >> magic_rook_shift[from]))) & tree->position.color[enemy].pieces[0];
#line 63
    temp = from + (5 << 12);
    {
#line 64
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 64
      if (! moves) {
#line 64
        goto while_break___6;
      }
#line 64
      if (side) {
#line 64
        tmp___19 = __builtin_clzll((unsigned long long )moves);
#line 64
        to = 63 - tmp___19;
      } else {
#line 64
        tmp___20 = __builtin_ctzll((unsigned long long )moves);
#line 64
        to = tmp___20;
      }
#line 64
      tmp___21 = move;
#line 64
      move ++;
#line 64
      if ((int )tree->position.board[to] > 0) {
#line 64
        tmp___22 = (int )tree->position.board[to];
      } else {
#line 64
        tmp___22 = - ((int )tree->position.board[to]);
      }
#line 64
      *tmp___21 = (unsigned int )((temp | (to << 6)) | (tmp___22 << 15));
#line 64
      moves = clear_mask[to] & moves;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 60
    piecebd = clear_mask[from] & piecebd;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 75
  from = tree->position.kingsq[side];
#line 76
  moves = king_attacks[from] & tree->position.color[enemy].pieces[0];
#line 77
  temp = from + (6 << 12);
  {
#line 78
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 78
    if (! moves) {
#line 78
      goto while_break___7;
    }
#line 78
    if (side) {
#line 78
      tmp___23 = __builtin_clzll((unsigned long long )moves);
#line 78
      to = 63 - tmp___23;
    } else {
#line 78
      tmp___24 = __builtin_ctzll((unsigned long long )moves);
#line 78
      to = tmp___24;
    }
#line 78
    tmp___25 = move;
#line 78
    move ++;
#line 78
    if ((int )tree->position.board[to] > 0) {
#line 78
      tmp___26 = (int )tree->position.board[to];
    } else {
#line 78
      tmp___26 = - ((int )tree->position.board[to]);
    }
#line 78
    *tmp___25 = (unsigned int )((temp | (to << 6)) | (tmp___26 << 15));
#line 78
    moves = clear_mask[to] & moves;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 92
  promotions = tree->position.color[side].pieces[1] & rank_mask[rank7[side]];
#line 93
  if (side) {
#line 93
    tmp___27 = promotions << 8;
  } else {
#line 93
    tmp___27 = promotions >> 8;
  }
#line 93
  promotions = tmp___27 & ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]);
  {
#line 95
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 95
    if (! promotions) {
#line 95
      goto while_break___8;
    }
#line 96
    to = __builtin_ctzll((unsigned long long )promotions);
#line 97
    tmp___28 = move;
#line 97
    move ++;
#line 97
    *tmp___28 = (unsigned int )((((to + (int )pawnadv1[side]) | (to << 6)) | (1 << 12)) | (5 << 18));
#line 95
    promotions = clear_mask[to] & promotions;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 100
  if (tree->status[ply].enpassant_target) {
#line 100
    tmp___29 = set_mask[tree->status[ply].enpassant_target];
  } else {
#line 100
    tmp___29 = (uint64_t )0;
  }
#line 100
  target = tree->position.color[enemy].pieces[0] | tmp___29;
#line 101
  if (side) {
#line 101
    tmp___30 = (tree->position.color[1].pieces[1] & (unsigned long )mask_left_edge) << 7;
  } else {
#line 101
    tmp___30 = (tree->position.color[0].pieces[1] & (unsigned long )mask_left_edge) >> 9;
  }
#line 101
  pcapturesl = tmp___30 & target;
  {
#line 104
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 104
    if (! pcapturesl) {
#line 104
      goto while_break___9;
    }
#line 105
    if (side) {
#line 105
      tmp___31 = __builtin_clzll((unsigned long long )pcapturesl);
#line 105
      to = 63 - tmp___31;
    } else {
#line 105
      tmp___32 = __builtin_ctzll((unsigned long long )pcapturesl);
#line 105
      to = tmp___32;
    }
#line 106
    common = ((to + (int )capleft[side]) | (to << 6)) | (1 << 12);
#line 107
    if (side) {
#line 107
      tmp___38 = to < 56;
    } else {
#line 107
      tmp___38 = to > 7;
    }
#line 107
    if (tmp___38) {
#line 108
      tmp___33 = move;
#line 108
      move ++;
#line 108
      if (tree->position.board[to]) {
#line 108
        if ((int )tree->position.board[to] > 0) {
#line 108
          tmp___34 = (int )tree->position.board[to];
        } else {
#line 108
          tmp___34 = - ((int )tree->position.board[to]);
        }
#line 108
        tmp___35 = tmp___34;
      } else {
#line 108
        tmp___35 = 1;
      }
#line 108
      *tmp___33 = (unsigned int )(common | (tmp___35 << 15));
    } else {
#line 110
      tmp___36 = move;
#line 110
      move ++;
#line 110
      if ((int )tree->position.board[to] > 0) {
#line 110
        tmp___37 = (int )tree->position.board[to];
      } else {
#line 110
        tmp___37 = - ((int )tree->position.board[to]);
      }
#line 110
      *tmp___36 = (unsigned int )((common | (tmp___37 << 15)) | (5 << 18));
    }
#line 104
    pcapturesl = clear_mask[to] & pcapturesl;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 112
  if (side) {
#line 112
    tmp___39 = (tree->position.color[1].pieces[1] & (unsigned long )mask_right_edge) << 9;
  } else {
#line 112
    tmp___39 = (tree->position.color[0].pieces[1] & (unsigned long )mask_right_edge) >> 7;
  }
#line 112
  pcapturesr = tmp___39 & target;
  {
#line 115
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 115
    if (! pcapturesr) {
#line 115
      goto while_break___10;
    }
#line 116
    if (side) {
#line 116
      tmp___40 = __builtin_clzll((unsigned long long )pcapturesr);
#line 116
      to = 63 - tmp___40;
    } else {
#line 116
      tmp___41 = __builtin_ctzll((unsigned long long )pcapturesr);
#line 116
      to = tmp___41;
    }
#line 117
    common = ((to + (int )capright[side]) | (to << 6)) | (1 << 12);
#line 118
    if (side) {
#line 118
      tmp___47 = to < 56;
    } else {
#line 118
      tmp___47 = to > 7;
    }
#line 118
    if (tmp___47) {
#line 119
      tmp___42 = move;
#line 119
      move ++;
#line 119
      if (tree->position.board[to]) {
#line 119
        if ((int )tree->position.board[to] > 0) {
#line 119
          tmp___43 = (int )tree->position.board[to];
        } else {
#line 119
          tmp___43 = - ((int )tree->position.board[to]);
        }
#line 119
        tmp___44 = tmp___43;
      } else {
#line 119
        tmp___44 = 1;
      }
#line 119
      *tmp___42 = (unsigned int )(common | (tmp___44 << 15));
    } else {
#line 121
      tmp___45 = move;
#line 121
      move ++;
#line 121
      if ((int )tree->position.board[to] > 0) {
#line 121
        tmp___46 = (int )tree->position.board[to];
      } else {
#line 121
        tmp___46 = - ((int )tree->position.board[to]);
      }
#line 121
      *tmp___45 = (unsigned int )((common | (tmp___46 << 15)) | (5 << 18));
    }
#line 115
    pcapturesr = clear_mask[to] & pcapturesr;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 123
  return (move);
}
}
#line 163 "movgen.c"
unsigned int *GenerateChecks(TREE *tree , int side , unsigned int *move ) 
{ 
  uint64_t temp_target ;
  uint64_t target ;
  uint64_t piecebd ;
  uint64_t moves ;
  uint64_t padvances1 ;
  uint64_t blockers ;
  uint64_t checkers ;
  int from ;
  int to ;
  int promote ;
  int temp ;
  int enemy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  unsigned int *tmp___21 ;
  int tmp___22 ;
  uint64_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  unsigned int *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  unsigned int *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  unsigned int *tmp___37 ;
  int tmp___38 ;
  unsigned long tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  unsigned int *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  unsigned int *tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  unsigned int *tmp___54 ;
  int tmp___55 ;
  unsigned long tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  unsigned int *tmp___60 ;

  {
#line 166
  enemy = side ^ 1;
#line 181
  target = ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]);
#line 189
  temp_target = target & knight_attacks[tree->position.kingsq[enemy]];
#line 190
  piecebd = tree->position.color[side].pieces[2];
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! piecebd) {
#line 190
      goto while_break;
    }
#line 191
    if (side) {
#line 191
      tmp = __builtin_clzll((unsigned long long )piecebd);
#line 191
      from = 63 - tmp;
    } else {
#line 191
      tmp___0 = __builtin_ctzll((unsigned long long )piecebd);
#line 191
      from = tmp___0;
    }
#line 192
    moves = knight_attacks[from] & temp_target;
#line 193
    temp = from + (2 << 12);
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      if (! moves) {
#line 194
        goto while_break___0;
      }
#line 194
      if (side) {
#line 194
        tmp___1 = __builtin_clzll((unsigned long long )moves);
#line 194
        to = 63 - tmp___1;
      } else {
#line 194
        tmp___2 = __builtin_ctzll((unsigned long long )moves);
#line 194
        to = tmp___2;
      }
#line 194
      tmp___3 = move;
#line 194
      move ++;
#line 194
      if ((int )tree->position.board[to] > 0) {
#line 194
        tmp___4 = (int )tree->position.board[to];
      } else {
#line 194
        tmp___4 = - ((int )tree->position.board[to]);
      }
#line 194
      *tmp___3 = (unsigned int )((temp | (to << 6)) | (tmp___4 << 15));
#line 194
      moves = clear_mask[to] & moves;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 190
    piecebd = clear_mask[from] & piecebd;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  temp_target = target & *(magic_bishop_indices[tree->position.kingsq[enemy]] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[tree->position.kingsq[enemy]]) * (unsigned long )magic_bishop[tree->position.kingsq[enemy]] >> magic_bishop_shift[tree->position.kingsq[enemy]]));
#line 204
  piecebd = tree->position.color[side].pieces[3];
  {
#line 204
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 204
    if (! piecebd) {
#line 204
      goto while_break___1;
    }
#line 205
    if (side) {
#line 205
      tmp___5 = __builtin_clzll((unsigned long long )piecebd);
#line 205
      from = 63 - tmp___5;
    } else {
#line 205
      tmp___6 = __builtin_ctzll((unsigned long long )piecebd);
#line 205
      from = tmp___6;
    }
#line 206
    moves = *(magic_bishop_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[from]) * (unsigned long )magic_bishop[from] >> magic_bishop_shift[from])) & temp_target;
#line 207
    temp = from + (3 << 12);
    {
#line 208
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 208
      if (! moves) {
#line 208
        goto while_break___2;
      }
#line 208
      if (side) {
#line 208
        tmp___7 = __builtin_clzll((unsigned long long )moves);
#line 208
        to = 63 - tmp___7;
      } else {
#line 208
        tmp___8 = __builtin_ctzll((unsigned long long )moves);
#line 208
        to = tmp___8;
      }
#line 208
      tmp___9 = move;
#line 208
      move ++;
#line 208
      if ((int )tree->position.board[to] > 0) {
#line 208
        tmp___10 = (int )tree->position.board[to];
      } else {
#line 208
        tmp___10 = - ((int )tree->position.board[to]);
      }
#line 208
      *tmp___9 = (unsigned int )((temp | (to << 6)) | (tmp___10 << 15));
#line 208
      moves = clear_mask[to] & moves;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 204
    piecebd = clear_mask[from] & piecebd;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 210
  temp_target = target & *(magic_rook_indices[tree->position.kingsq[enemy]] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[tree->position.kingsq[enemy]]) * (unsigned long )magic_rook[tree->position.kingsq[enemy]] >> magic_rook_shift[tree->position.kingsq[enemy]]));
#line 211
  piecebd = tree->position.color[side].pieces[4];
  {
#line 211
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 211
    if (! piecebd) {
#line 211
      goto while_break___3;
    }
#line 212
    if (side) {
#line 212
      tmp___11 = __builtin_clzll((unsigned long long )piecebd);
#line 212
      from = 63 - tmp___11;
    } else {
#line 212
      tmp___12 = __builtin_ctzll((unsigned long long )piecebd);
#line 212
      from = tmp___12;
    }
#line 213
    moves = *(magic_rook_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[from]) * (unsigned long )magic_rook[from] >> magic_rook_shift[from])) & temp_target;
#line 214
    temp = from + (4 << 12);
    {
#line 215
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 215
      if (! moves) {
#line 215
        goto while_break___4;
      }
#line 215
      if (side) {
#line 215
        tmp___13 = __builtin_clzll((unsigned long long )moves);
#line 215
        to = 63 - tmp___13;
      } else {
#line 215
        tmp___14 = __builtin_ctzll((unsigned long long )moves);
#line 215
        to = tmp___14;
      }
#line 215
      tmp___15 = move;
#line 215
      move ++;
#line 215
      if ((int )tree->position.board[to] > 0) {
#line 215
        tmp___16 = (int )tree->position.board[to];
      } else {
#line 215
        tmp___16 = - ((int )tree->position.board[to]);
      }
#line 215
      *tmp___15 = (unsigned int )((temp | (to << 6)) | (tmp___16 << 15));
#line 215
      moves = clear_mask[to] & moves;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 211
    piecebd = clear_mask[from] & piecebd;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 217
  temp_target = target & (*(magic_bishop_indices[tree->position.kingsq[enemy]] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[tree->position.kingsq[enemy]]) * (unsigned long )magic_bishop[tree->position.kingsq[enemy]] >> magic_bishop_shift[tree->position.kingsq[enemy]])) | *(magic_rook_indices[tree->position.kingsq[enemy]] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[tree->position.kingsq[enemy]]) * (unsigned long )magic_rook[tree->position.kingsq[enemy]] >> magic_rook_shift[tree->position.kingsq[enemy]])));
#line 218
  piecebd = tree->position.color[side].pieces[5];
  {
#line 218
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 218
    if (! piecebd) {
#line 218
      goto while_break___5;
    }
#line 219
    if (side) {
#line 219
      tmp___17 = __builtin_clzll((unsigned long long )piecebd);
#line 219
      from = 63 - tmp___17;
    } else {
#line 219
      tmp___18 = __builtin_ctzll((unsigned long long )piecebd);
#line 219
      from = tmp___18;
    }
#line 220
    moves = (*(magic_bishop_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[from]) * (unsigned long )magic_bishop[from] >> magic_bishop_shift[from])) | *(magic_rook_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[from]) * (unsigned long )magic_rook[from] >> magic_rook_shift[from]))) & temp_target;
#line 221
    temp = from + (5 << 12);
    {
#line 222
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 222
      if (! moves) {
#line 222
        goto while_break___6;
      }
#line 222
      if (side) {
#line 222
        tmp___19 = __builtin_clzll((unsigned long long )moves);
#line 222
        to = 63 - tmp___19;
      } else {
#line 222
        tmp___20 = __builtin_ctzll((unsigned long long )moves);
#line 222
        to = tmp___20;
      }
#line 222
      tmp___21 = move;
#line 222
      move ++;
#line 222
      if ((int )tree->position.board[to] > 0) {
#line 222
        tmp___22 = (int )tree->position.board[to];
      } else {
#line 222
        tmp___22 = - ((int )tree->position.board[to]);
      }
#line 222
      *tmp___21 = (unsigned int )((temp | (to << 6)) | (tmp___22 << 15));
#line 222
      moves = clear_mask[to] & moves;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 218
    piecebd = clear_mask[from] & piecebd;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 231
  temp_target = target & pawn_attacks[enemy][tree->position.kingsq[enemy]];
#line 232
  if (side) {
#line 232
    tmp___23 = tree->position.color[1].pieces[1] << 8;
  } else {
#line 232
    tmp___23 = tree->position.color[0].pieces[1] >> 8;
  }
#line 232
  padvances1 = tmp___23 & temp_target;
  {
#line 233
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 233
    if (! padvances1) {
#line 233
      goto while_break___7;
    }
#line 234
    if (side) {
#line 234
      tmp___24 = __builtin_clzll((unsigned long long )padvances1);
#line 234
      to = 63 - tmp___24;
    } else {
#line 234
      tmp___25 = __builtin_ctzll((unsigned long long )padvances1);
#line 234
      to = tmp___25;
    }
#line 235
    tmp___26 = move;
#line 235
    move ++;
#line 235
    *tmp___26 = (unsigned int )(((to + (int )pawnadv1[side]) | (to << 6)) | (1 << 12));
#line 233
    padvances1 = clear_mask[to] & padvances1;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 261
  blockers = *(magic_bishop_indices[tree->position.kingsq[enemy]] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[tree->position.kingsq[enemy]]) * (unsigned long )magic_bishop[tree->position.kingsq[enemy]] >> magic_bishop_shift[tree->position.kingsq[enemy]])) & ((tree->position.color[side].pieces[4] | tree->position.color[side].pieces[2]) | tree->position.color[side].pieces[1]);
#line 264
  if (blockers) {
#line 265
    checkers = *(magic_bishop_indices[tree->position.kingsq[enemy]] + ((((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & ~ blockers) & (unsigned long )magic_bishop_mask[tree->position.kingsq[enemy]]) * (unsigned long )magic_bishop[tree->position.kingsq[enemy]] >> magic_bishop_shift[tree->position.kingsq[enemy]])) & (tree->position.color[side].pieces[3] | tree->position.color[side].pieces[5]);
#line 268
    if (checkers) {
#line 269
      if (plus7dir[tree->position.kingsq[enemy]] & blockers) {
#line 269
        if (! (plus7dir[tree->position.kingsq[enemy]] & checkers)) {
#line 271
          blockers &= ~ plus7dir[tree->position.kingsq[enemy]];
        } else {
#line 269
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
#line 272
      if (plus9dir[tree->position.kingsq[enemy]] & blockers) {
#line 272
        if (! (plus9dir[tree->position.kingsq[enemy]] & checkers)) {
#line 274
          blockers &= ~ plus9dir[tree->position.kingsq[enemy]];
        } else {
#line 272
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
#line 275
      if (minus7dir[tree->position.kingsq[enemy]] & blockers) {
#line 275
        if (! (minus7dir[tree->position.kingsq[enemy]] & checkers)) {
#line 277
          blockers &= ~ minus7dir[tree->position.kingsq[enemy]];
        } else {
#line 275
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ ;
      }
#line 278
      if (minus9dir[tree->position.kingsq[enemy]] & blockers) {
#line 278
        if (! (minus9dir[tree->position.kingsq[enemy]] & checkers)) {
#line 280
          blockers &= ~ minus9dir[tree->position.kingsq[enemy]];
        } else {
#line 278
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ ;
      }
#line 281
      target = ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]);
#line 289
      temp_target = target & ~ knight_attacks[tree->position.kingsq[enemy]];
#line 290
      piecebd = tree->position.color[side].pieces[2] & blockers;
      {
#line 290
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 290
        if (! piecebd) {
#line 290
          goto while_break___8;
        }
#line 291
        if (side) {
#line 291
          tmp___27 = __builtin_clzll((unsigned long long )piecebd);
#line 291
          from = 63 - tmp___27;
        } else {
#line 291
          tmp___28 = __builtin_ctzll((unsigned long long )piecebd);
#line 291
          from = tmp___28;
        }
#line 292
        moves = knight_attacks[from] & temp_target;
#line 293
        temp = from + (2 << 12);
        {
#line 294
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 294
          if (! moves) {
#line 294
            goto while_break___9;
          }
#line 294
          if (side) {
#line 294
            tmp___29 = __builtin_clzll((unsigned long long )moves);
#line 294
            to = 63 - tmp___29;
          } else {
#line 294
            tmp___30 = __builtin_ctzll((unsigned long long )moves);
#line 294
            to = tmp___30;
          }
#line 294
          tmp___31 = move;
#line 294
          move ++;
#line 294
          if ((int )tree->position.board[to] > 0) {
#line 294
            tmp___32 = (int )tree->position.board[to];
          } else {
#line 294
            tmp___32 = - ((int )tree->position.board[to]);
          }
#line 294
          *tmp___31 = (unsigned int )((temp | (to << 6)) | (tmp___32 << 15));
#line 294
          moves = clear_mask[to] & moves;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 290
        piecebd = clear_mask[from] & piecebd;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 303
      target = ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]);
#line 304
      temp_target = target & ~ *(magic_rook_indices[tree->position.kingsq[enemy]] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[tree->position.kingsq[enemy]]) * (unsigned long )magic_rook[tree->position.kingsq[enemy]] >> magic_rook_shift[tree->position.kingsq[enemy]]));
#line 305
      piecebd = tree->position.color[side].pieces[4] & blockers;
      {
#line 305
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 305
        if (! piecebd) {
#line 305
          goto while_break___10;
        }
#line 306
        if (side) {
#line 306
          tmp___33 = __builtin_clzll((unsigned long long )piecebd);
#line 306
          from = 63 - tmp___33;
        } else {
#line 306
          tmp___34 = __builtin_ctzll((unsigned long long )piecebd);
#line 306
          from = tmp___34;
        }
#line 307
        moves = *(magic_rook_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[from]) * (unsigned long )magic_rook[from] >> magic_rook_shift[from])) & temp_target;
#line 308
        temp = from + (4 << 12);
        {
#line 309
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 309
          if (! moves) {
#line 309
            goto while_break___11;
          }
#line 309
          if (side) {
#line 309
            tmp___35 = __builtin_clzll((unsigned long long )moves);
#line 309
            to = 63 - tmp___35;
          } else {
#line 309
            tmp___36 = __builtin_ctzll((unsigned long long )moves);
#line 309
            to = tmp___36;
          }
#line 309
          tmp___37 = move;
#line 309
          move ++;
#line 309
          if ((int )tree->position.board[to] > 0) {
#line 309
            tmp___38 = (int )tree->position.board[to];
          } else {
#line 309
            tmp___38 = - ((int )tree->position.board[to]);
          }
#line 309
          *tmp___37 = (unsigned int )((temp | (to << 6)) | (tmp___38 << 15));
#line 309
          moves = clear_mask[to] & moves;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 305
        piecebd = clear_mask[from] & piecebd;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 318
      if (side) {
#line 318
        tmp___39 = ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) >> 8;
      } else {
#line 318
        tmp___39 = ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) << 8;
      }
#line 318
      piecebd = (tree->position.color[side].pieces[1] & blockers) & tmp___39;
      {
#line 321
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 321
        if (! piecebd) {
#line 321
          goto while_break___12;
        }
#line 322
        if (side) {
#line 322
          tmp___40 = __builtin_clzll((unsigned long long )piecebd);
#line 322
          from = 63 - tmp___40;
        } else {
#line 322
          tmp___41 = __builtin_ctzll((unsigned long long )piecebd);
#line 322
          from = tmp___41;
        }
#line 323
        to = from + (int )pawnadv1[enemy];
#line 324
        if (side) {
#line 324
          tmp___42 = to > 55;
        } else {
#line 324
          tmp___42 = to < 8;
        }
#line 324
        if (tmp___42) {
#line 325
          promote = 5;
        } else {
#line 327
          promote = 0;
        }
#line 328
        tmp___43 = move;
#line 328
        move ++;
#line 328
        *tmp___43 = (unsigned int )(((from | (to << 6)) | (1 << 12)) | (promote << 18));
#line 321
        piecebd = clear_mask[from] & piecebd;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
  }
#line 342
  blockers = *(magic_rook_indices[tree->position.kingsq[enemy]] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[tree->position.kingsq[enemy]]) * (unsigned long )magic_rook[tree->position.kingsq[enemy]] >> magic_rook_shift[tree->position.kingsq[enemy]])) & ((tree->position.color[side].pieces[3] | tree->position.color[side].pieces[2]) | (tree->position.color[side].pieces[1] & rank_mask[tree->position.kingsq[enemy] >> 3]));
#line 346
  if (blockers) {
#line 347
    checkers = *(magic_rook_indices[tree->position.kingsq[enemy]] + ((((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & ~ blockers) & (unsigned long )magic_rook_mask[tree->position.kingsq[enemy]]) * (unsigned long )magic_rook[tree->position.kingsq[enemy]] >> magic_rook_shift[tree->position.kingsq[enemy]])) & (tree->position.color[side].pieces[4] | tree->position.color[side].pieces[5]);
#line 350
    if (checkers) {
#line 351
      if (plus1dir[tree->position.kingsq[enemy]] & blockers) {
#line 351
        if (! (plus1dir[tree->position.kingsq[enemy]] & checkers)) {
#line 353
          blockers &= ~ plus1dir[tree->position.kingsq[enemy]];
        } else {
#line 351
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ ;
      }
#line 354
      if (plus8dir[tree->position.kingsq[enemy]] & blockers) {
#line 354
        if (! (plus8dir[tree->position.kingsq[enemy]] & checkers)) {
#line 356
          blockers &= ~ plus8dir[tree->position.kingsq[enemy]];
        } else {
#line 354
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ ;
      }
#line 357
      if (minus1dir[tree->position.kingsq[enemy]] & blockers) {
#line 357
        if (! (minus1dir[tree->position.kingsq[enemy]] & checkers)) {
#line 359
          blockers &= ~ minus1dir[tree->position.kingsq[enemy]];
        } else {
#line 357
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ ;
      }
#line 360
      if (minus8dir[tree->position.kingsq[enemy]] & blockers) {
#line 360
        if (! (minus8dir[tree->position.kingsq[enemy]] & checkers)) {
#line 362
          blockers &= ~ minus8dir[tree->position.kingsq[enemy]];
        } else {
#line 360
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ ;
      }
#line 363
      target = ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]);
#line 371
      temp_target = target & ~ knight_attacks[tree->position.kingsq[enemy]];
#line 372
      piecebd = tree->position.color[side].pieces[2] & blockers;
      {
#line 372
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 372
        if (! piecebd) {
#line 372
          goto while_break___13;
        }
#line 373
        if (side) {
#line 373
          tmp___44 = __builtin_clzll((unsigned long long )piecebd);
#line 373
          from = 63 - tmp___44;
        } else {
#line 373
          tmp___45 = __builtin_ctzll((unsigned long long )piecebd);
#line 373
          from = tmp___45;
        }
#line 374
        moves = knight_attacks[from] & temp_target;
#line 375
        temp = from + (2 << 12);
        {
#line 376
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 376
          if (! moves) {
#line 376
            goto while_break___14;
          }
#line 376
          if (side) {
#line 376
            tmp___46 = __builtin_clzll((unsigned long long )moves);
#line 376
            to = 63 - tmp___46;
          } else {
#line 376
            tmp___47 = __builtin_ctzll((unsigned long long )moves);
#line 376
            to = tmp___47;
          }
#line 376
          tmp___48 = move;
#line 376
          move ++;
#line 376
          if ((int )tree->position.board[to] > 0) {
#line 376
            tmp___49 = (int )tree->position.board[to];
          } else {
#line 376
            tmp___49 = - ((int )tree->position.board[to]);
          }
#line 376
          *tmp___48 = (unsigned int )((temp | (to << 6)) | (tmp___49 << 15));
#line 376
          moves = clear_mask[to] & moves;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 372
        piecebd = clear_mask[from] & piecebd;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 385
      target = ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]);
#line 386
      temp_target = target & ~ *(magic_bishop_indices[tree->position.kingsq[enemy]] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[tree->position.kingsq[enemy]]) * (unsigned long )magic_bishop[tree->position.kingsq[enemy]] >> magic_bishop_shift[tree->position.kingsq[enemy]]));
#line 387
      piecebd = tree->position.color[side].pieces[3] & blockers;
      {
#line 387
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 387
        if (! piecebd) {
#line 387
          goto while_break___15;
        }
#line 388
        if (side) {
#line 388
          tmp___50 = __builtin_clzll((unsigned long long )piecebd);
#line 388
          from = 63 - tmp___50;
        } else {
#line 388
          tmp___51 = __builtin_ctzll((unsigned long long )piecebd);
#line 388
          from = tmp___51;
        }
#line 389
        moves = *(magic_bishop_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[from]) * (unsigned long )magic_bishop[from] >> magic_bishop_shift[from])) & temp_target;
#line 390
        temp = from + (3 << 12);
        {
#line 391
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 391
          if (! moves) {
#line 391
            goto while_break___16;
          }
#line 391
          if (side) {
#line 391
            tmp___52 = __builtin_clzll((unsigned long long )moves);
#line 391
            to = 63 - tmp___52;
          } else {
#line 391
            tmp___53 = __builtin_ctzll((unsigned long long )moves);
#line 391
            to = tmp___53;
          }
#line 391
          tmp___54 = move;
#line 391
          move ++;
#line 391
          if ((int )tree->position.board[to] > 0) {
#line 391
            tmp___55 = (int )tree->position.board[to];
          } else {
#line 391
            tmp___55 = - ((int )tree->position.board[to]);
          }
#line 391
          *tmp___54 = (unsigned int )((temp | (to << 6)) | (tmp___55 << 15));
#line 391
          moves = clear_mask[to] & moves;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 387
        piecebd = clear_mask[from] & piecebd;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 400
      if (side) {
#line 400
        tmp___56 = ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) >> 8;
      } else {
#line 400
        tmp___56 = ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) << 8;
      }
#line 400
      piecebd = (tree->position.color[side].pieces[1] & blockers) & tmp___56;
      {
#line 403
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 403
        if (! piecebd) {
#line 403
          goto while_break___17;
        }
#line 404
        if (side) {
#line 404
          tmp___57 = __builtin_clzll((unsigned long long )piecebd);
#line 404
          from = 63 - tmp___57;
        } else {
#line 404
          tmp___58 = __builtin_ctzll((unsigned long long )piecebd);
#line 404
          from = tmp___58;
        }
#line 405
        to = from + (int )pawnadv1[enemy];
#line 406
        if (side) {
#line 406
          tmp___59 = to > 55;
        } else {
#line 406
          tmp___59 = to < 8;
        }
#line 406
        if (tmp___59) {
#line 407
          promote = 5;
        } else {
#line 409
          promote = 0;
        }
#line 410
        tmp___60 = move;
#line 410
        move ++;
#line 410
        *tmp___60 = (unsigned int )(((from | (to << 6)) | (1 << 12)) | (promote << 18));
#line 403
        piecebd = clear_mask[from] & piecebd;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
  }
#line 414
  return (move);
}
}
#line 441 "movgen.c"
unsigned int *GenerateCheckEvasions(TREE *tree , int ply , int side , unsigned int *move ) 
{ 
  uint64_t target ;
  uint64_t targetc ;
  uint64_t targetp ;
  uint64_t piecebd ;
  uint64_t moves ;
  uint64_t empty___0 ;
  uint64_t checksqs ;
  uint64_t padvances1 ;
  uint64_t padvances2 ;
  uint64_t pcapturesl ;
  uint64_t pcapturesr ;
  uint64_t padvances1_all ;
  int from ;
  int to ;
  int temp ;
  int common ;
  int enemy ;
  int king_square ;
  int checkers ;
  int checking_square ;
  int check_direction1 ;
  int check_direction2 ;
  uint64_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned int *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned int *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  unsigned int *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  unsigned int *tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  unsigned int *tmp___40 ;
  unsigned int *tmp___41 ;
  unsigned int *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  uint64_t tmp___45 ;
  uint64_t tmp___46 ;
  uint64_t tmp___47 ;
  uint64_t tmp___48 ;
  uint64_t tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  unsigned int *tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  unsigned int *tmp___55 ;
  int tmp___56 ;
  unsigned int *tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  unsigned int *tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  unsigned int *tmp___66 ;
  int tmp___67 ;
  unsigned int *tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;

  {
#line 445
  enemy = side ^ 1;
#line 446
  check_direction1 = 0;
#line 446
  check_direction2 = 0;
#line 457
  king_square = tree->position.kingsq[side];
#line 458
  tmp = AttacksTo(tree, king_square);
#line 458
  checksqs = tmp & tree->position.color[enemy].pieces[0];
#line 459
  checkers = __builtin_popcountll((unsigned long long )checksqs);
#line 460
  if (checkers == 1) {
#line 461
    checking_square = __builtin_ctzll((unsigned long long )checksqs);
#line 462
    if ((int )tree->position.board[checking_square] != (int )pieces[enemy][1]) {
#line 463
      check_direction1 = (int )directions[checking_square][king_square];
    }
#line 464
    target = intervening[king_square][checking_square];
#line 465
    target |= checksqs;
#line 466
    target |= tree->position.color[enemy].pieces[6];
  } else {
#line 468
    target = tree->position.color[enemy].pieces[6];
#line 469
    checking_square = __builtin_ctzll((unsigned long long )checksqs);
#line 470
    if ((int )tree->position.board[checking_square] != (int )pieces[enemy][1]) {
#line 471
      check_direction1 = (int )directions[checking_square][king_square];
    }
#line 472
    tmp___0 = __builtin_clzll((unsigned long long )checksqs);
#line 472
    checking_square = 63 - tmp___0;
#line 473
    if ((int )tree->position.board[checking_square] != (int )pieces[enemy][1]) {
#line 474
      check_direction2 = (int )directions[checking_square][king_square];
    }
  }
#line 494
  from = king_square;
#line 495
  temp = from + (6 << 12);
#line 496
  moves = king_attacks[from] & ~ tree->position.color[side].pieces[0];
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    if (! moves) {
#line 496
      goto while_break;
    }
#line 497
    if (side) {
#line 497
      tmp___1 = __builtin_clzll((unsigned long long )moves);
#line 497
      to = 63 - tmp___1;
    } else {
#line 497
      tmp___2 = __builtin_ctzll((unsigned long long )moves);
#line 497
      to = tmp___2;
    }
#line 498
    tmp___5 = Attacks(tree, enemy, to);
#line 498
    if (tmp___5) {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    } else
#line 498
    if ((int )directions[from][to] != check_direction1) {
#line 498
      if ((int )directions[from][to] != check_direction2) {
#line 501
        tmp___3 = move;
#line 501
        move ++;
#line 501
        if ((int )tree->position.board[to] > 0) {
#line 501
          tmp___4 = (int )tree->position.board[to];
        } else {
#line 501
          tmp___4 = - ((int )tree->position.board[to]);
        }
#line 501
        *tmp___3 = (unsigned int )((temp | (to << 6)) | (tmp___4 << 15));
      } else {
#line 498
        goto _L___0;
      }
    } else {
#line 498
      goto _L___0;
    }
#line 496
    moves = clear_mask[to] & moves;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  if (checkers == 1) {
#line 514
    piecebd = tree->position.color[side].pieces[2];
    {
#line 514
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 514
      if (! piecebd) {
#line 514
        goto while_break___0;
      }
#line 515
      if (side) {
#line 515
        tmp___6 = __builtin_clzll((unsigned long long )piecebd);
#line 515
        from = 63 - tmp___6;
      } else {
#line 515
        tmp___7 = __builtin_ctzll((unsigned long long )piecebd);
#line 515
        from = tmp___7;
      }
#line 516
      tmp___12 = PinnedOnKing(tree, side, from);
#line 516
      if (! tmp___12) {
#line 517
        moves = knight_attacks[from] & target;
#line 518
        temp = from + (2 << 12);
        {
#line 519
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 519
          if (! moves) {
#line 519
            goto while_break___1;
          }
#line 519
          if (side) {
#line 519
            tmp___8 = __builtin_clzll((unsigned long long )moves);
#line 519
            to = 63 - tmp___8;
          } else {
#line 519
            tmp___9 = __builtin_ctzll((unsigned long long )moves);
#line 519
            to = tmp___9;
          }
#line 519
          tmp___10 = move;
#line 519
          move ++;
#line 519
          if ((int )tree->position.board[to] > 0) {
#line 519
            tmp___11 = (int )tree->position.board[to];
          } else {
#line 519
            tmp___11 = - ((int )tree->position.board[to]);
          }
#line 519
          *tmp___10 = (unsigned int )((temp | (to << 6)) | (tmp___11 << 15));
#line 519
          moves = clear_mask[to] & moves;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 514
      piecebd = clear_mask[from] & piecebd;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 533
    piecebd = tree->position.color[side].pieces[3];
    {
#line 533
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 533
      if (! piecebd) {
#line 533
        goto while_break___2;
      }
#line 534
      if (side) {
#line 534
        tmp___13 = __builtin_clzll((unsigned long long )piecebd);
#line 534
        from = 63 - tmp___13;
      } else {
#line 534
        tmp___14 = __builtin_ctzll((unsigned long long )piecebd);
#line 534
        from = tmp___14;
      }
#line 535
      tmp___19 = PinnedOnKing(tree, side, from);
#line 535
      if (! tmp___19) {
#line 536
        moves = *(magic_bishop_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[from]) * (unsigned long )magic_bishop[from] >> magic_bishop_shift[from])) & target;
#line 537
        temp = from + (3 << 12);
        {
#line 538
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 538
          if (! moves) {
#line 538
            goto while_break___3;
          }
#line 538
          if (side) {
#line 538
            tmp___15 = __builtin_clzll((unsigned long long )moves);
#line 538
            to = 63 - tmp___15;
          } else {
#line 538
            tmp___16 = __builtin_ctzll((unsigned long long )moves);
#line 538
            to = tmp___16;
          }
#line 538
          tmp___17 = move;
#line 538
          move ++;
#line 538
          if ((int )tree->position.board[to] > 0) {
#line 538
            tmp___18 = (int )tree->position.board[to];
          } else {
#line 538
            tmp___18 = - ((int )tree->position.board[to]);
          }
#line 538
          *tmp___17 = (unsigned int )((temp | (to << 6)) | (tmp___18 << 15));
#line 538
          moves = clear_mask[to] & moves;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 533
      piecebd = clear_mask[from] & piecebd;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 541
    piecebd = tree->position.color[side].pieces[4];
    {
#line 541
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 541
      if (! piecebd) {
#line 541
        goto while_break___4;
      }
#line 542
      if (side) {
#line 542
        tmp___20 = __builtin_clzll((unsigned long long )piecebd);
#line 542
        from = 63 - tmp___20;
      } else {
#line 542
        tmp___21 = __builtin_ctzll((unsigned long long )piecebd);
#line 542
        from = tmp___21;
      }
#line 543
      tmp___26 = PinnedOnKing(tree, side, from);
#line 543
      if (! tmp___26) {
#line 544
        moves = *(magic_rook_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[from]) * (unsigned long )magic_rook[from] >> magic_rook_shift[from])) & target;
#line 545
        temp = from + (4 << 12);
        {
#line 546
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 546
          if (! moves) {
#line 546
            goto while_break___5;
          }
#line 546
          if (side) {
#line 546
            tmp___22 = __builtin_clzll((unsigned long long )moves);
#line 546
            to = 63 - tmp___22;
          } else {
#line 546
            tmp___23 = __builtin_ctzll((unsigned long long )moves);
#line 546
            to = tmp___23;
          }
#line 546
          tmp___24 = move;
#line 546
          move ++;
#line 546
          if ((int )tree->position.board[to] > 0) {
#line 546
            tmp___25 = (int )tree->position.board[to];
          } else {
#line 546
            tmp___25 = - ((int )tree->position.board[to]);
          }
#line 546
          *tmp___24 = (unsigned int )((temp | (to << 6)) | (tmp___25 << 15));
#line 546
          moves = clear_mask[to] & moves;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 541
      piecebd = clear_mask[from] & piecebd;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 549
    piecebd = tree->position.color[side].pieces[5];
    {
#line 549
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 549
      if (! piecebd) {
#line 549
        goto while_break___6;
      }
#line 550
      if (side) {
#line 550
        tmp___27 = __builtin_clzll((unsigned long long )piecebd);
#line 550
        from = 63 - tmp___27;
      } else {
#line 550
        tmp___28 = __builtin_ctzll((unsigned long long )piecebd);
#line 550
        from = tmp___28;
      }
#line 551
      tmp___33 = PinnedOnKing(tree, side, from);
#line 551
      if (! tmp___33) {
#line 552
        moves = (*(magic_bishop_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[from]) * (unsigned long )magic_bishop[from] >> magic_bishop_shift[from])) | *(magic_rook_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[from]) * (unsigned long )magic_rook[from] >> magic_rook_shift[from]))) & target;
#line 553
        temp = from + (5 << 12);
        {
#line 554
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 554
          if (! moves) {
#line 554
            goto while_break___7;
          }
#line 554
          if (side) {
#line 554
            tmp___29 = __builtin_clzll((unsigned long long )moves);
#line 554
            to = 63 - tmp___29;
          } else {
#line 554
            tmp___30 = __builtin_ctzll((unsigned long long )moves);
#line 554
            to = tmp___30;
          }
#line 554
          tmp___31 = move;
#line 554
          move ++;
#line 554
          if ((int )tree->position.board[to] > 0) {
#line 554
            tmp___32 = (int )tree->position.board[to];
          } else {
#line 554
            tmp___32 = - ((int )tree->position.board[to]);
          }
#line 554
          *tmp___31 = (unsigned int )((temp | (to << 6)) | (tmp___32 << 15));
#line 554
          moves = clear_mask[to] & moves;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 549
      piecebd = clear_mask[from] & piecebd;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 571
    empty___0 = ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]);
#line 572
    targetp = target & empty___0;
#line 573
    if (side) {
#line 574
      padvances1 = (tree->position.color[1].pieces[1] << 8) & targetp;
#line 575
      padvances1_all = (tree->position.color[1].pieces[1] << 8) & empty___0;
#line 576
      padvances2 = ((padvances1_all & (255UL << 16)) << 8) & targetp;
    } else {
#line 578
      padvances1 = (tree->position.color[0].pieces[1] >> 8) & targetp;
#line 579
      padvances1_all = (tree->position.color[0].pieces[1] >> 8) & empty___0;
#line 580
      padvances2 = ((padvances1_all & (255UL << 40)) >> 8) & targetp;
    }
    {
#line 591
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 591
      if (! padvances2) {
#line 591
        goto while_break___8;
      }
#line 592
      if (side) {
#line 592
        tmp___34 = __builtin_clzll((unsigned long long )padvances2);
#line 592
        to = 63 - tmp___34;
      } else {
#line 592
        tmp___35 = __builtin_ctzll((unsigned long long )padvances2);
#line 592
        to = tmp___35;
      }
#line 593
      tmp___37 = PinnedOnKing(tree, side, to + (int )pawnadv2[side]);
#line 593
      if (! tmp___37) {
#line 594
        tmp___36 = move;
#line 594
        move ++;
#line 594
        *tmp___36 = (unsigned int )(((to + (int )pawnadv2[side]) | (to << 6)) | (1 << 12));
      }
#line 591
      padvances2 = clear_mask[to] & padvances2;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 596
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 596
      if (! padvances1) {
#line 596
        goto while_break___9;
      }
#line 597
      if (side) {
#line 597
        tmp___38 = __builtin_clzll((unsigned long long )padvances1);
#line 597
        to = 63 - tmp___38;
      } else {
#line 597
        tmp___39 = __builtin_ctzll((unsigned long long )padvances1);
#line 597
        to = tmp___39;
      }
#line 598
      tmp___44 = PinnedOnKing(tree, side, to + (int )pawnadv1[side]);
#line 598
      if (! tmp___44) {
#line 599
        common = ((to + (int )pawnadv1[side]) | (to << 6)) | (1 << 12);
#line 600
        if (side) {
#line 600
          tmp___43 = to < 56;
        } else {
#line 600
          tmp___43 = to > 7;
        }
#line 600
        if (tmp___43) {
#line 601
          tmp___40 = move;
#line 601
          move ++;
#line 601
          *tmp___40 = (unsigned int )common;
        } else {
#line 603
          tmp___41 = move;
#line 603
          move ++;
#line 603
          *tmp___41 = (unsigned int )(common | (5 << 18));
#line 604
          tmp___42 = move;
#line 604
          move ++;
#line 604
          *tmp___42 = (unsigned int )(common | (2 << 18));
        }
      }
#line 596
      padvances1 = clear_mask[to] & padvances1;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 616
    if (tree->status[ply].enpassant_target) {
#line 616
      tmp___45 = set_mask[tree->status[ply].enpassant_target];
    } else {
#line 616
      tmp___45 = (uint64_t )0;
    }
#line 616
    targetc = tree->position.color[enemy].pieces[0] | tmp___45;
#line 617
    targetc &= target;
#line 618
    if (side) {
#line 618
      if (tree->status[ply].enpassant_target) {
#line 618
        tmp___47 = set_mask[tree->status[ply].enpassant_target];
      } else {
#line 618
        tmp___47 = (uint64_t )0;
      }
#line 618
      tmp___49 = tmp___47 >> 8;
    } else {
#line 618
      if (tree->status[ply].enpassant_target) {
#line 618
        tmp___48 = set_mask[tree->status[ply].enpassant_target];
      } else {
#line 618
        tmp___48 = (uint64_t )0;
      }
#line 618
      tmp___49 = tmp___48 << 8;
    }
#line 618
    if ((tree->position.color[enemy].pieces[1] & target) & tmp___49) {
#line 620
      if (tree->status[ply].enpassant_target) {
#line 620
        tmp___46 = set_mask[tree->status[ply].enpassant_target];
      } else {
#line 620
        tmp___46 = (uint64_t )0;
      }
#line 620
      targetc |= tmp___46;
    }
#line 621
    if (side) {
#line 622
      pcapturesl = ((tree->position.color[1].pieces[1] & (unsigned long )mask_left_edge) << 7) & targetc;
#line 623
      pcapturesr = ((tree->position.color[1].pieces[1] & (unsigned long )mask_right_edge) << 9) & targetc;
    } else {
#line 625
      pcapturesl = ((tree->position.color[0].pieces[1] & (unsigned long )mask_left_edge) >> 9) & targetc;
#line 626
      pcapturesr = ((tree->position.color[0].pieces[1] & (unsigned long )mask_right_edge) >> 7) & targetc;
    }
    {
#line 628
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 628
      if (! pcapturesl) {
#line 628
        goto while_break___10;
      }
#line 629
      if (side) {
#line 629
        tmp___50 = __builtin_clzll((unsigned long long )pcapturesl);
#line 629
        to = 63 - tmp___50;
      } else {
#line 629
        tmp___51 = __builtin_ctzll((unsigned long long )pcapturesl);
#line 629
        to = tmp___51;
      }
#line 630
      tmp___60 = PinnedOnKing(tree, side, to + (int )capleft[side]);
#line 630
      if (! tmp___60) {
#line 631
        common = ((to + (int )capleft[side]) | (to << 6)) | (1 << 12);
#line 632
        if (side) {
#line 632
          tmp___59 = to < 56;
        } else {
#line 632
          tmp___59 = to > 7;
        }
#line 632
        if (tmp___59) {
#line 633
          tmp___52 = move;
#line 633
          move ++;
#line 633
          if (tree->position.board[to]) {
#line 633
            if ((int )tree->position.board[to] > 0) {
#line 633
              tmp___53 = (int )tree->position.board[to];
            } else {
#line 633
              tmp___53 = - ((int )tree->position.board[to]);
            }
#line 633
            tmp___54 = tmp___53;
          } else {
#line 633
            tmp___54 = 1;
          }
#line 633
          *tmp___52 = (unsigned int )(common | (tmp___54 << 15));
        } else {
#line 635
          tmp___55 = move;
#line 635
          move ++;
#line 635
          if ((int )tree->position.board[to] > 0) {
#line 635
            tmp___56 = (int )tree->position.board[to];
          } else {
#line 635
            tmp___56 = - ((int )tree->position.board[to]);
          }
#line 635
          *tmp___55 = (unsigned int )((common | (tmp___56 << 15)) | (5 << 18));
#line 636
          tmp___57 = move;
#line 636
          move ++;
#line 636
          if ((int )tree->position.board[to] > 0) {
#line 636
            tmp___58 = (int )tree->position.board[to];
          } else {
#line 636
            tmp___58 = - ((int )tree->position.board[to]);
          }
#line 636
          *tmp___57 = (unsigned int )((common | (tmp___58 << 15)) | (2 << 18));
        }
      }
#line 628
      pcapturesl = clear_mask[to] & pcapturesl;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 640
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 640
      if (! pcapturesr) {
#line 640
        goto while_break___11;
      }
#line 641
      if (side) {
#line 641
        tmp___61 = __builtin_clzll((unsigned long long )pcapturesr);
#line 641
        to = 63 - tmp___61;
      } else {
#line 641
        tmp___62 = __builtin_ctzll((unsigned long long )pcapturesr);
#line 641
        to = tmp___62;
      }
#line 642
      tmp___71 = PinnedOnKing(tree, side, to + (int )capright[side]);
#line 642
      if (! tmp___71) {
#line 643
        common = ((to + (int )capright[side]) | (to << 6)) | (1 << 12);
#line 644
        if (side) {
#line 644
          tmp___70 = to < 56;
        } else {
#line 644
          tmp___70 = to > 7;
        }
#line 644
        if (tmp___70) {
#line 645
          tmp___63 = move;
#line 645
          move ++;
#line 645
          if (tree->position.board[to]) {
#line 645
            if ((int )tree->position.board[to] > 0) {
#line 645
              tmp___64 = (int )tree->position.board[to];
            } else {
#line 645
              tmp___64 = - ((int )tree->position.board[to]);
            }
#line 645
            tmp___65 = tmp___64;
          } else {
#line 645
            tmp___65 = 1;
          }
#line 645
          *tmp___63 = (unsigned int )(common | (tmp___65 << 15));
        } else {
#line 647
          tmp___66 = move;
#line 647
          move ++;
#line 647
          if ((int )tree->position.board[to] > 0) {
#line 647
            tmp___67 = (int )tree->position.board[to];
          } else {
#line 647
            tmp___67 = - ((int )tree->position.board[to]);
          }
#line 647
          *tmp___66 = (unsigned int )((common | (tmp___67 << 15)) | (5 << 18));
#line 648
          tmp___68 = move;
#line 648
          move ++;
#line 648
          if ((int )tree->position.board[to] > 0) {
#line 648
            tmp___69 = (int )tree->position.board[to];
          } else {
#line 648
            tmp___69 = - ((int )tree->position.board[to]);
          }
#line 648
          *tmp___68 = (unsigned int )((common | (tmp___69 << 15)) | (2 << 18));
        }
      }
#line 640
      pcapturesr = clear_mask[to] & pcapturesr;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
#line 653
  return (move);
}
}
#line 678 "movgen.c"
unsigned int *GenerateNoncaptures(TREE *tree , int ply , int side , unsigned int *move ) 
{ 
  uint64_t target ;
  uint64_t piecebd ;
  uint64_t moves ;
  uint64_t padvances1 ;
  uint64_t padvances2 ;
  uint64_t pcapturesl ;
  uint64_t pcapturesr ;
  int from ;
  int to ;
  int temp ;
  int common ;
  int enemy ;
  unsigned int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned int *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  unsigned int *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  unsigned int *tmp___33 ;
  int tmp___34 ;
  uint64_t tmp___35 ;
  unsigned long tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  unsigned int *tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  unsigned int *tmp___42 ;
  unsigned int *tmp___43 ;
  unsigned int *tmp___44 ;
  unsigned int *tmp___45 ;
  int tmp___46 ;
  unsigned long tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  unsigned int *tmp___50 ;
  int tmp___51 ;
  unsigned int *tmp___52 ;
  int tmp___53 ;
  unsigned int *tmp___54 ;
  int tmp___55 ;
  unsigned long tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  unsigned int *tmp___59 ;
  int tmp___60 ;
  unsigned int *tmp___61 ;
  int tmp___62 ;
  unsigned int *tmp___63 ;
  int tmp___64 ;

  {
#line 682
  enemy = side ^ 1;
#line 691
  if ((int )tree->status[ply].castle[side] > 0) {
#line 692
    if ((int )tree->status[ply].castle[side] & 1) {
#line 692
      if (! ((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )OO[side])) {
#line 692
        tmp___0 = Attacks(tree, enemy, (int )OOsqs[side][0]);
#line 692
        if (tmp___0) {
#line 692
          goto _L___2;
        } else {
#line 692
          tmp___1 = Attacks(tree, enemy, (int )OOsqs[side][1]);
#line 692
          if (tmp___1) {
#line 692
            goto _L___2;
          } else {
#line 692
            tmp___2 = Attacks(tree, enemy, (int )OOsqs[side][2]);
#line 692
            if (tmp___2) {
#line 692
              goto _L___2;
            } else {
#line 696
              tmp = move;
#line 696
              move ++;
#line 696
              *tmp = (unsigned int )(((6 << 12) + (int )(OOto[side] << 6)) + (int )OOfrom[side]);
            }
          }
        }
      } else {
#line 692
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___1: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
#line 698
    if ((int )tree->status[ply].castle[side] & 2) {
#line 698
      if (! ((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )OOO[side])) {
#line 698
        tmp___4 = Attacks(tree, enemy, (int )OOOsqs[side][0]);
#line 698
        if (tmp___4) {
#line 698
          goto _L___6;
        } else {
#line 698
          tmp___5 = Attacks(tree, enemy, (int )OOOsqs[side][1]);
#line 698
          if (tmp___5) {
#line 698
            goto _L___6;
          } else {
#line 698
            tmp___6 = Attacks(tree, enemy, (int )OOOsqs[side][2]);
#line 698
            if (tmp___6) {
#line 698
              goto _L___6;
            } else {
#line 702
              tmp___3 = move;
#line 702
              move ++;
#line 702
              *tmp___3 = (unsigned int )(((6 << 12) + (int )(OOOto[side] << 6)) + (int )OOfrom[side]);
            }
          }
        }
      } else {
#line 698
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
      _L___5: /* CIL Label */ 
      _L___4: /* CIL Label */ 
      _L___3: /* CIL Label */ ;
    }
  }
#line 705
  target = ~ (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]);
#line 716
  piecebd = tree->position.color[side].pieces[2];
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! piecebd) {
#line 716
      goto while_break;
    }
#line 717
    if (side) {
#line 717
      tmp___7 = __builtin_clzll((unsigned long long )piecebd);
#line 717
      from = 63 - tmp___7;
    } else {
#line 717
      tmp___8 = __builtin_ctzll((unsigned long long )piecebd);
#line 717
      from = tmp___8;
    }
#line 718
    moves = knight_attacks[from] & target;
#line 719
    temp = from + (2 << 12);
    {
#line 720
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 720
      if (! moves) {
#line 720
        goto while_break___0;
      }
#line 720
      if (side) {
#line 720
        tmp___9 = __builtin_clzll((unsigned long long )moves);
#line 720
        to = 63 - tmp___9;
      } else {
#line 720
        tmp___10 = __builtin_ctzll((unsigned long long )moves);
#line 720
        to = tmp___10;
      }
#line 720
      tmp___11 = move;
#line 720
      move ++;
#line 720
      if ((int )tree->position.board[to] > 0) {
#line 720
        tmp___12 = (int )tree->position.board[to];
      } else {
#line 720
        tmp___12 = - ((int )tree->position.board[to]);
      }
#line 720
      *tmp___11 = (unsigned int )((temp | (to << 6)) | (tmp___12 << 15));
#line 720
      moves = clear_mask[to] & moves;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 716
    piecebd = clear_mask[from] & piecebd;
  }
  while_break: /* CIL Label */ ;
  }
#line 733
  piecebd = tree->position.color[side].pieces[3];
  {
#line 733
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 733
    if (! piecebd) {
#line 733
      goto while_break___1;
    }
#line 734
    if (side) {
#line 734
      tmp___13 = __builtin_clzll((unsigned long long )piecebd);
#line 734
      from = 63 - tmp___13;
    } else {
#line 734
      tmp___14 = __builtin_ctzll((unsigned long long )piecebd);
#line 734
      from = tmp___14;
    }
#line 735
    moves = *(magic_bishop_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[from]) * (unsigned long )magic_bishop[from] >> magic_bishop_shift[from])) & target;
#line 736
    temp = from + (3 << 12);
    {
#line 737
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 737
      if (! moves) {
#line 737
        goto while_break___2;
      }
#line 737
      if (side) {
#line 737
        tmp___15 = __builtin_clzll((unsigned long long )moves);
#line 737
        to = 63 - tmp___15;
      } else {
#line 737
        tmp___16 = __builtin_ctzll((unsigned long long )moves);
#line 737
        to = tmp___16;
      }
#line 737
      tmp___17 = move;
#line 737
      move ++;
#line 737
      if ((int )tree->position.board[to] > 0) {
#line 737
        tmp___18 = (int )tree->position.board[to];
      } else {
#line 737
        tmp___18 = - ((int )tree->position.board[to]);
      }
#line 737
      *tmp___17 = (unsigned int )((temp | (to << 6)) | (tmp___18 << 15));
#line 737
      moves = clear_mask[to] & moves;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 733
    piecebd = clear_mask[from] & piecebd;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 739
  piecebd = tree->position.color[side].pieces[4];
  {
#line 739
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 739
    if (! piecebd) {
#line 739
      goto while_break___3;
    }
#line 740
    if (side) {
#line 740
      tmp___19 = __builtin_clzll((unsigned long long )piecebd);
#line 740
      from = 63 - tmp___19;
    } else {
#line 740
      tmp___20 = __builtin_ctzll((unsigned long long )piecebd);
#line 740
      from = tmp___20;
    }
#line 741
    moves = *(magic_rook_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[from]) * (unsigned long )magic_rook[from] >> magic_rook_shift[from])) & target;
#line 742
    temp = from + (4 << 12);
    {
#line 743
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 743
      if (! moves) {
#line 743
        goto while_break___4;
      }
#line 743
      if (side) {
#line 743
        tmp___21 = __builtin_clzll((unsigned long long )moves);
#line 743
        to = 63 - tmp___21;
      } else {
#line 743
        tmp___22 = __builtin_ctzll((unsigned long long )moves);
#line 743
        to = tmp___22;
      }
#line 743
      tmp___23 = move;
#line 743
      move ++;
#line 743
      if ((int )tree->position.board[to] > 0) {
#line 743
        tmp___24 = (int )tree->position.board[to];
      } else {
#line 743
        tmp___24 = - ((int )tree->position.board[to]);
      }
#line 743
      *tmp___23 = (unsigned int )((temp | (to << 6)) | (tmp___24 << 15));
#line 743
      moves = clear_mask[to] & moves;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 739
    piecebd = clear_mask[from] & piecebd;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 745
  piecebd = tree->position.color[side].pieces[5];
  {
#line 745
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 745
    if (! piecebd) {
#line 745
      goto while_break___5;
    }
#line 746
    if (side) {
#line 746
      tmp___25 = __builtin_clzll((unsigned long long )piecebd);
#line 746
      from = 63 - tmp___25;
    } else {
#line 746
      tmp___26 = __builtin_ctzll((unsigned long long )piecebd);
#line 746
      from = tmp___26;
    }
#line 747
    moves = (*(magic_bishop_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[from]) * (unsigned long )magic_bishop[from] >> magic_bishop_shift[from])) | *(magic_rook_indices[from] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[from]) * (unsigned long )magic_rook[from] >> magic_rook_shift[from]))) & target;
#line 748
    temp = from + (5 << 12);
    {
#line 749
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 749
      if (! moves) {
#line 749
        goto while_break___6;
      }
#line 749
      if (side) {
#line 749
        tmp___27 = __builtin_clzll((unsigned long long )moves);
#line 749
        to = 63 - tmp___27;
      } else {
#line 749
        tmp___28 = __builtin_ctzll((unsigned long long )moves);
#line 749
        to = tmp___28;
      }
#line 749
      tmp___29 = move;
#line 749
      move ++;
#line 749
      if ((int )tree->position.board[to] > 0) {
#line 749
        tmp___30 = (int )tree->position.board[to];
      } else {
#line 749
        tmp___30 = - ((int )tree->position.board[to]);
      }
#line 749
      *tmp___29 = (unsigned int )((temp | (to << 6)) | (tmp___30 << 15));
#line 749
      moves = clear_mask[to] & moves;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 745
    piecebd = clear_mask[from] & piecebd;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 760
  from = tree->position.kingsq[side];
#line 761
  moves = king_attacks[from] & target;
#line 762
  temp = from + (6 << 12);
  {
#line 763
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 763
    if (! moves) {
#line 763
      goto while_break___7;
    }
#line 763
    if (side) {
#line 763
      tmp___31 = __builtin_clzll((unsigned long long )moves);
#line 763
      to = 63 - tmp___31;
    } else {
#line 763
      tmp___32 = __builtin_ctzll((unsigned long long )moves);
#line 763
      to = tmp___32;
    }
#line 763
    tmp___33 = move;
#line 763
    move ++;
#line 763
    if ((int )tree->position.board[to] > 0) {
#line 763
      tmp___34 = (int )tree->position.board[to];
    } else {
#line 763
      tmp___34 = - ((int )tree->position.board[to]);
    }
#line 763
    *tmp___33 = (unsigned int )((temp | (to << 6)) | (tmp___34 << 15));
#line 763
    moves = clear_mask[to] & moves;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 783
  if (side) {
#line 783
    tmp___35 = tree->position.color[side].pieces[1] << 8;
  } else {
#line 783
    tmp___35 = tree->position.color[side].pieces[1] >> 8;
  }
#line 783
  padvances1 = tmp___35 & target;
#line 784
  if (side) {
#line 784
    tmp___36 = (padvances1 & (unsigned long )mask_advance_2_w) << 8;
  } else {
#line 784
    tmp___36 = (padvances1 & (unsigned long )mask_advance_2_b) >> 8;
  }
#line 784
  padvances2 = tmp___36 & target;
  {
#line 796
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 796
    if (! padvances2) {
#line 796
      goto while_break___8;
    }
#line 797
    if (side) {
#line 797
      tmp___37 = __builtin_clzll((unsigned long long )padvances2);
#line 797
      to = 63 - tmp___37;
    } else {
#line 797
      tmp___38 = __builtin_ctzll((unsigned long long )padvances2);
#line 797
      to = tmp___38;
    }
#line 798
    tmp___39 = move;
#line 798
    move ++;
#line 798
    *tmp___39 = (unsigned int )(((to + (int )pawnadv2[side]) | (to << 6)) | (1 << 12));
#line 796
    padvances2 = clear_mask[to] & padvances2;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 800
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 800
    if (! padvances1) {
#line 800
      goto while_break___9;
    }
#line 801
    if (side) {
#line 801
      tmp___40 = __builtin_clzll((unsigned long long )padvances1);
#line 801
      to = 63 - tmp___40;
    } else {
#line 801
      tmp___41 = __builtin_ctzll((unsigned long long )padvances1);
#line 801
      to = tmp___41;
    }
#line 802
    common = ((to + (int )pawnadv1[side]) | (to << 6)) | (1 << 12);
#line 803
    if (side) {
#line 803
      tmp___46 = to < 56;
    } else {
#line 803
      tmp___46 = to > 7;
    }
#line 803
    if (tmp___46) {
#line 804
      tmp___42 = move;
#line 804
      move ++;
#line 804
      *tmp___42 = (unsigned int )common;
    } else {
#line 806
      tmp___43 = move;
#line 806
      move ++;
#line 806
      *tmp___43 = (unsigned int )(common | (4 << 18));
#line 807
      tmp___44 = move;
#line 807
      move ++;
#line 807
      *tmp___44 = (unsigned int )(common | (3 << 18));
#line 808
      tmp___45 = move;
#line 808
      move ++;
#line 808
      *tmp___45 = (unsigned int )(common | (2 << 18));
    }
#line 800
    padvances1 = clear_mask[to] & padvances1;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 820
  target = tree->position.color[enemy].pieces[0] & rank_mask[rank8[side]];
#line 821
  if (side) {
#line 821
    tmp___47 = (tree->position.color[1].pieces[1] & (unsigned long )mask_left_edge) << 7;
  } else {
#line 821
    tmp___47 = (tree->position.color[0].pieces[1] & (unsigned long )mask_left_edge) >> 9;
  }
#line 821
  pcapturesl = tmp___47 & target;
  {
#line 824
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 824
    if (! pcapturesl) {
#line 824
      goto while_break___10;
    }
#line 825
    if (side) {
#line 825
      tmp___48 = __builtin_clzll((unsigned long long )pcapturesl);
#line 825
      to = 63 - tmp___48;
    } else {
#line 825
      tmp___49 = __builtin_ctzll((unsigned long long )pcapturesl);
#line 825
      to = tmp___49;
    }
#line 826
    common = ((to + (int )capleft[side]) | (to << 6)) | (1 << 12);
#line 827
    tmp___50 = move;
#line 827
    move ++;
#line 827
    if ((int )tree->position.board[to] > 0) {
#line 827
      tmp___51 = (int )tree->position.board[to];
    } else {
#line 827
      tmp___51 = - ((int )tree->position.board[to]);
    }
#line 827
    *tmp___50 = (unsigned int )((common | (tmp___51 << 15)) | (4 << 18));
#line 828
    tmp___52 = move;
#line 828
    move ++;
#line 828
    if ((int )tree->position.board[to] > 0) {
#line 828
      tmp___53 = (int )tree->position.board[to];
    } else {
#line 828
      tmp___53 = - ((int )tree->position.board[to]);
    }
#line 828
    *tmp___52 = (unsigned int )((common | (tmp___53 << 15)) | (3 << 18));
#line 829
    tmp___54 = move;
#line 829
    move ++;
#line 829
    if ((int )tree->position.board[to] > 0) {
#line 829
      tmp___55 = (int )tree->position.board[to];
    } else {
#line 829
      tmp___55 = - ((int )tree->position.board[to]);
    }
#line 829
    *tmp___54 = (unsigned int )((common | (tmp___55 << 15)) | (2 << 18));
#line 824
    pcapturesl = clear_mask[to] & pcapturesl;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 831
  if (side) {
#line 831
    tmp___56 = (tree->position.color[1].pieces[1] & (unsigned long )mask_right_edge) << 9;
  } else {
#line 831
    tmp___56 = (tree->position.color[0].pieces[1] & (unsigned long )mask_right_edge) >> 7;
  }
#line 831
  pcapturesr = tmp___56 & target;
  {
#line 834
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 834
    if (! pcapturesr) {
#line 834
      goto while_break___11;
    }
#line 835
    if (side) {
#line 835
      tmp___57 = __builtin_clzll((unsigned long long )pcapturesr);
#line 835
      to = 63 - tmp___57;
    } else {
#line 835
      tmp___58 = __builtin_ctzll((unsigned long long )pcapturesr);
#line 835
      to = tmp___58;
    }
#line 836
    common = ((to + (int )capright[side]) | (to << 6)) | (1 << 12);
#line 837
    tmp___59 = move;
#line 837
    move ++;
#line 837
    if ((int )tree->position.board[to] > 0) {
#line 837
      tmp___60 = (int )tree->position.board[to];
    } else {
#line 837
      tmp___60 = - ((int )tree->position.board[to]);
    }
#line 837
    *tmp___59 = (unsigned int )((common | (tmp___60 << 15)) | (4 << 18));
#line 838
    tmp___61 = move;
#line 838
    move ++;
#line 838
    if ((int )tree->position.board[to] > 0) {
#line 838
      tmp___62 = (int )tree->position.board[to];
    } else {
#line 838
      tmp___62 = - ((int )tree->position.board[to]);
    }
#line 838
    *tmp___61 = (unsigned int )((common | (tmp___62 << 15)) | (3 << 18));
#line 839
    tmp___63 = move;
#line 839
    move ++;
#line 839
    if ((int )tree->position.board[to] > 0) {
#line 839
      tmp___64 = (int )tree->position.board[to];
    } else {
#line 839
      tmp___64 = - ((int )tree->position.board[to]);
    }
#line 839
    *tmp___63 = (unsigned int )((common | (tmp___64 << 15)) | (2 << 18));
#line 834
    pcapturesr = clear_mask[to] & pcapturesr;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 841
  return (move);
}
}
#line 855 "movgen.c"
int PinnedOnKing(TREE *tree , int side , int square ) 
{ 
  int ray ;
  int enemy ;
  int tmp ;

  {
#line 856
  enemy = side ^ 1;
#line 867
  ray = (int )directions[square][tree->position.kingsq[side]];
#line 868
  if (! ray) {
#line 869
    return (0);
  }
#line 881
  if (ray > 0) {
#line 881
    tmp = ray;
  } else {
#line 881
    tmp = - ray;
  }
  {
#line 882
  if (tmp == 1) {
#line 882
    goto case_1;
  }
#line 887
  if (tmp == 7) {
#line 887
    goto case_7;
  }
#line 893
  if (tmp == 8) {
#line 893
    goto case_8;
  }
#line 898
  if (tmp == 9) {
#line 898
    goto case_9;
  }
#line 881
  goto switch_break;
  case_1: /* CIL Label */ 
#line 883
  if ((*(magic_rook_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square])) & rank_mask[square >> 3]) & tree->position.color[side].pieces[6]) {
#line 884
    return (((*(magic_rook_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square])) & rank_mask[square >> 3]) & (tree->position.color[enemy].pieces[4] | tree->position.color[enemy].pieces[5])) != 0UL);
  } else {
#line 886
    return (0);
  }
  case_7: /* CIL Label */ 
#line 888
  if ((*(magic_bishop_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[square]) * (unsigned long )magic_bishop[square] >> magic_bishop_shift[square])) & (plus7dir[square] | minus7dir[square])) & tree->position.color[side].pieces[6]) {
#line 889
    return (((*(magic_bishop_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[square]) * (unsigned long )magic_bishop[square] >> magic_bishop_shift[square])) & (plus7dir[square] | minus7dir[square])) & (tree->position.color[enemy].pieces[3] | tree->position.color[enemy].pieces[5])) != 0UL);
  } else {
#line 892
    return (0);
  }
  case_8: /* CIL Label */ 
#line 894
  if ((*(magic_rook_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square])) & file_mask[square & 7]) & tree->position.color[side].pieces[6]) {
#line 895
    return (((*(magic_rook_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square])) & file_mask[square & 7]) & (tree->position.color[enemy].pieces[4] | tree->position.color[enemy].pieces[5])) != 0UL);
  } else {
#line 897
    return (0);
  }
  case_9: /* CIL Label */ 
#line 899
  if ((*(magic_bishop_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[square]) * (unsigned long )magic_bishop[square] >> magic_bishop_shift[square])) & (plus9dir[square] | minus9dir[square])) & tree->position.color[side].pieces[6]) {
#line 900
    return (((*(magic_bishop_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[square]) * (unsigned long )magic_bishop[square] >> magic_bishop_shift[square])) & (plus9dir[square] | minus9dir[square])) & (tree->position.color[enemy].pieces[3] | tree->position.color[enemy].pieces[5])) != 0UL);
  } else {
#line 903
    return (0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 905
  return (0);
}
}
#line 24 "make.c"
void MakeMove(TREE *tree , int ply , int side , int move ) 
{ 
  uint64_t bit_move ;
  int piece ;
  int from ;
  int to ;
  int captured ;
  int promote ;
  int enemy ;
  int cpiece ;
  int tmp ;
  int tmp___0 ;

  {
#line 26
  enemy = side ^ 1;
#line 55
  tree->status[ply + 1] = tree->status[ply];
#line 56
  tree->save_hash_key[ply] = tree->position.hash_key;
#line 57
  tree->save_pawn_hash_key[ply] = tree->position.pawn_hash_key;
#line 58
  if (tree->status[ply + 1].enpassant_target) {
#line 59
    tree->position.hash_key ^= (unsigned long )enpassant_random[tree->status[ply + 1].enpassant_target];
#line 60
    tree->status[ply + 1].enpassant_target = (uint8_t )0;
  }
#line 62
  tree->status[ply + 1].reversible = (uint8_t )((int )tree->status[ply + 1].reversible + 1);
#line 71
  piece = (move >> 12) & 7;
#line 72
  from = move & 63;
#line 73
  to = (move >> 6) & 63;
#line 74
  captured = (move >> 15) & 7;
#line 75
  promote = (move >> 18) & 7;
#line 76
  bit_move = set_mask[from] | set_mask[to];
#line 77
  cpiece = (int )tree->position.board[to];
#line 78
  tree->position.color[side].pieces[piece] = bit_move ^ tree->position.color[side].pieces[piece];
#line 79
  tree->position.color[side].pieces[0] = bit_move ^ tree->position.color[side].pieces[0];
#line 80
  tree->position.hash_key ^= (unsigned long )randoms[side][piece][from];
#line 81
  tree->position.hash_key ^= (unsigned long )randoms[side][piece][to];
#line 82
  tree->position.board[from] = (int8_t )0;
#line 83
  tree->position.board[to] = (int8_t )pieces[side][piece];
  {
#line 93
  if (piece == 1) {
#line 93
    goto case_1;
  }
#line 127
  if (piece == 5) {
#line 127
    goto case_5;
  }
#line 127
  if (piece == 3) {
#line 127
    goto case_5;
  }
#line 127
  if (piece == 2) {
#line 127
    goto case_5;
  }
#line 129
  if (piece == 4) {
#line 129
    goto case_4;
  }
#line 140
  if (piece == 6) {
#line 140
    goto case_6;
  }
#line 92
  goto switch_break;
  case_1: /* CIL Label */ 
#line 94
  tree->position.pawn_hash_key ^= (unsigned long )randoms[side][1][from];
#line 95
  tree->position.pawn_hash_key ^= (unsigned long )randoms[side][1][to];
#line 96
  tree->status[ply + 1].reversible = (uint8_t )0;
#line 97
  if (captured == 1) {
#line 97
    if (! cpiece) {
#line 98
      tree->position.color[enemy].pieces[1] = clear_mask[to + (int )epsq[side]] & tree->position.color[enemy].pieces[1];
#line 99
      tree->position.color[enemy].pieces[0] = clear_mask[to + (int )epsq[side]] & tree->position.color[enemy].pieces[0];
#line 100
      tree->position.hash_key ^= (unsigned long )randoms[enemy][1][to + (int )epsq[side]];
#line 101
      tree->position.pawn_hash_key ^= (unsigned long )randoms[enemy][1][to + (int )epsq[side]];
#line 102
      tree->position.board[to + (int )epsq[side]] = (int8_t )0;
#line 103
      tree->position.material_evaluation -= piece_values[enemy][1];
#line 104
      tree->position.pieces[enemy][1] = (char )((int )tree->position.pieces[enemy][1] - 1);
#line 105
      tree->position.total_all_pieces = (char )((int )tree->position.total_all_pieces - 1);
#line 106
      captured = 0;
    } else {
#line 97
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 108
  if (promote) {
#line 109
    tree->position.pieces[side][1] = (char )((int )tree->position.pieces[side][1] - 1);
#line 110
    tree->position.material_evaluation -= piece_values[side][1];
#line 111
    tree->position.color[side].pieces[1] = clear_mask[to] & tree->position.color[side].pieces[1];
#line 112
    tree->position.hash_key ^= (unsigned long )randoms[side][1][to];
#line 113
    tree->position.pawn_hash_key ^= (unsigned long )randoms[side][1][to];
#line 114
    tree->position.hash_key ^= (unsigned long )randoms[side][promote][to];
#line 115
    tree->position.board[to] = (int8_t )pieces[side][promote];
#line 116
    tree->position.pieces[side][0] = (char )((int )tree->position.pieces[side][0] + (int )p_vals[promote]);
#line 117
    tree->position.pieces[side][promote] = (char )((int )tree->position.pieces[side][promote] + 1);
#line 118
    tree->position.material_evaluation += piece_values[side][promote];
#line 119
    tree->position.color[side].pieces[promote] = set_mask[to] | tree->position.color[side].pieces[promote];
  } else {
#line 120
    if (to - from > 0) {
#line 120
      tmp = to - from;
    } else {
#line 120
      tmp = - (to - from);
    }
#line 120
    if (tmp == 16) {
#line 120
      if (mask_eptest[to] & tree->position.color[enemy].pieces[1]) {
#line 121
        tree->status[ply + 1].enpassant_target = (uint8_t )(to + (int )epsq[side]);
#line 122
        tree->position.hash_key ^= (unsigned long )enpassant_random[to + (int )epsq[side]];
      } else {
#line 120
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
  }
#line 124
  goto switch_break;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 128
  goto switch_break;
  case_4: /* CIL Label */ 
#line 130
  if ((int )tree->status[ply + 1].castle[side] > 0) {
#line 131
    if (from == (int )rook_A[side]) {
#line 131
      if ((int )tree->status[ply + 1].castle[side] & 2) {
#line 132
        tree->status[ply + 1].castle[side] = (int8_t )((int )tree->status[ply + 1].castle[side] & 1);
#line 133
        tree->position.hash_key ^= (unsigned long )castle_random[1][side];
      } else {
#line 131
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 134
    if (from == (int )rook_H[side]) {
#line 134
      if ((int )tree->status[ply + 1].castle[side] & 1) {
#line 135
        tree->status[ply + 1].castle[side] = (int8_t )((int )tree->status[ply + 1].castle[side] & 2);
#line 136
        tree->position.hash_key ^= (unsigned long )castle_random[0][side];
      } else {
#line 134
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
  }
#line 139
  goto switch_break;
  case_6: /* CIL Label */ 
#line 141
  tree->position.kingsq[side] = to;
#line 142
  if ((int )tree->status[ply + 1].castle[side] > 0) {
#line 143
    if ((int )tree->status[ply + 1].castle[side] & 2) {
#line 144
      tree->position.hash_key ^= (unsigned long )castle_random[1][side];
    }
#line 145
    if ((int )tree->status[ply + 1].castle[side] & 1) {
#line 146
      tree->position.hash_key ^= (unsigned long )castle_random[0][side];
    }
#line 147
    if (to - from > 0) {
#line 147
      tmp___0 = to - from;
    } else {
#line 147
      tmp___0 = - (to - from);
    }
#line 147
    if (tmp___0 == 2) {
#line 148
      tree->status[ply + 1].castle[side] = (int8_t )-1;
#line 149
      piece = 4;
#line 150
      if (to == (int )rook_G[side]) {
#line 151
        from = (int )rook_H[side];
#line 152
        to = (int )rook_F[side];
      } else {
#line 154
        from = (int )rook_A[side];
#line 155
        to = (int )rook_D[side];
      }
#line 157
      bit_move = set_mask[from] | set_mask[to];
#line 158
      tree->position.color[side].pieces[4] = bit_move ^ tree->position.color[side].pieces[4];
#line 159
      tree->position.color[side].pieces[0] = bit_move ^ tree->position.color[side].pieces[0];
#line 160
      tree->position.hash_key ^= (unsigned long )randoms[side][4][from];
#line 161
      tree->position.hash_key ^= (unsigned long )randoms[side][4][to];
#line 162
      tree->position.board[from] = (int8_t )0;
#line 163
      tree->position.board[to] = (int8_t )pieces[side][4];
    } else {
#line 165
      tree->status[ply + 1].castle[side] = (int8_t )0;
    }
  }
#line 167
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 178
  if (captured) {
#line 179
    tree->status[ply + 1].reversible = (uint8_t )0;
#line 180
    tree->position.total_all_pieces = (char )((int )tree->position.total_all_pieces - 1);
#line 181
    if (promote) {
#line 182
      piece = promote;
    }
#line 183
    tree->position.hash_key ^= (unsigned long )randoms[enemy][captured][to];
#line 184
    tree->position.color[enemy].pieces[captured] = clear_mask[to] & tree->position.color[enemy].pieces[captured];
#line 185
    tree->position.color[enemy].pieces[0] = clear_mask[to] & tree->position.color[enemy].pieces[0];
#line 186
    tree->position.material_evaluation -= piece_values[enemy][captured];
#line 187
    tree->position.pieces[enemy][captured] = (char )((int )tree->position.pieces[enemy][captured] - 1);
#line 188
    if (captured != 1) {
#line 189
      tree->position.pieces[enemy][0] = (char )((int )tree->position.pieces[enemy][0] - (int )p_vals[captured]);
    }
    {
#line 191
    if (captured == 1) {
#line 191
      goto case_1___0;
    }
#line 196
    if (captured == 5) {
#line 196
      goto case_5___0;
    }
#line 196
    if (captured == 3) {
#line 196
      goto case_5___0;
    }
#line 196
    if (captured == 2) {
#line 196
      goto case_5___0;
    }
#line 198
    if (captured == 4) {
#line 198
      goto case_4___0;
    }
#line 209
    if (captured == 6) {
#line 209
      goto case_6___0;
    }
#line 190
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 192
    tree->position.pawn_hash_key ^= (unsigned long )randoms[enemy][1][to];
#line 193
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
#line 197
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 199
    if ((int )tree->status[ply + 1].castle[enemy] > 0) {
#line 200
      if (to == (int )rook_A[enemy]) {
#line 200
        if ((int )tree->status[ply + 1].castle[enemy] & 2) {
#line 201
          tree->status[ply + 1].castle[enemy] = (int8_t )((int )tree->status[ply + 1].castle[enemy] & 1);
#line 202
          tree->position.hash_key ^= (unsigned long )castle_random[1][enemy];
        } else {
#line 200
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 203
      if (to == (int )rook_H[enemy]) {
#line 203
        if ((int )tree->status[ply + 1].castle[enemy] & 1) {
#line 204
          tree->status[ply + 1].castle[enemy] = (int8_t )((int )tree->status[ply + 1].castle[enemy] & 2);
#line 205
          tree->position.hash_key ^= (unsigned long )castle_random[0][enemy];
        } else {
#line 203
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ ;
      }
    }
#line 208
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 222
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 228
  return;
}
}
#line 244 "make.c"
void MakeMoveRoot(TREE *tree , int side , int move ) 
{ 
  int player ;

  {
#line 255
  MakeMove(tree, 0, side, move);
#line 256
  if ((int )tree->status[1].reversible == 0) {
#line 257
    rep_index = -1;
  }
#line 258
  rep_index ++;
#line 258
  tree->rep_list[rep_index] = tree->position.hash_key;
#line 272
  player = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (player <= 1)) {
#line 272
      goto while_break;
    }
#line 273
    if (0 > (int )tree->status[1].castle[player]) {
#line 273
      tree->status[1].castle[player] = (int8_t )0;
    } else {
#line 273
      tree->status[1].castle[player] = tree->status[1].castle[player];
    }
#line 272
    player ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  tree->status[0] = tree->status[1];
#line 275
  return;
}
}
#line 14 "unmake.c"
void UnmakeMove(TREE *tree , int ply , int side , int move ) 
{ 
  uint64_t bit_move ;
  int piece ;
  int from ;
  int to ;
  int captured ;
  int promote ;
  int enemy ;
  int tmp ;

  {
#line 16
  enemy = side ^ 1;
#line 27
  tree->position.hash_key = tree->save_hash_key[ply];
#line 28
  tree->position.pawn_hash_key = tree->save_pawn_hash_key[ply];
#line 37
  piece = (move >> 12) & 7;
#line 38
  from = move & 63;
#line 39
  to = (move >> 6) & 63;
#line 40
  captured = (move >> 15) & 7;
#line 41
  promote = (move >> 18) & 7;
#line 42
  bit_move = set_mask[from] | set_mask[to];
#line 43
  tree->position.color[side].pieces[piece] = bit_move ^ tree->position.color[side].pieces[piece];
#line 44
  tree->position.color[side].pieces[0] = bit_move ^ tree->position.color[side].pieces[0];
#line 45
  tree->position.board[to] = (int8_t )0;
#line 46
  tree->position.board[from] = (int8_t )pieces[side][piece];
  {
#line 57
  if (piece == 1) {
#line 57
    goto case_1;
  }
#line 83
  if (piece == 5) {
#line 83
    goto case_5;
  }
#line 83
  if (piece == 4) {
#line 83
    goto case_5;
  }
#line 83
  if (piece == 3) {
#line 83
    goto case_5;
  }
#line 83
  if (piece == 2) {
#line 83
    goto case_5;
  }
#line 85
  if (piece == 6) {
#line 85
    goto case_6;
  }
#line 56
  goto switch_break;
  case_1: /* CIL Label */ 
#line 58
  if (captured == 1) {
#line 59
    if ((int )tree->status[ply].enpassant_target == to) {
#line 60
      tree->position.total_all_pieces = (char )((int )tree->position.total_all_pieces + 1);
#line 61
      tree->position.color[enemy].pieces[1] = set_mask[to + (int )epsq[side]] | tree->position.color[enemy].pieces[1];
#line 62
      tree->position.color[enemy].pieces[0] = set_mask[to + (int )epsq[side]] | tree->position.color[enemy].pieces[0];
#line 63
      tree->position.board[to + (int )epsq[side]] = (int8_t )pieces[enemy][1];
#line 64
      tree->position.material_evaluation -= piece_values[side][1];
#line 65
      tree->position.pieces[enemy][1] = (char )((int )tree->position.pieces[enemy][1] + 1);
#line 66
      captured = 0;
    }
  }
#line 69
  if (promote) {
#line 70
    tree->position.pieces[side][1] = (char )((int )tree->position.pieces[side][1] + 1);
#line 71
    tree->position.color[side].pieces[1] = clear_mask[to] & tree->position.color[side].pieces[1];
#line 72
    tree->position.color[side].pieces[0] = clear_mask[to] & tree->position.color[side].pieces[0];
#line 73
    tree->position.color[side].pieces[promote] = clear_mask[to] & tree->position.color[side].pieces[promote];
#line 74
    tree->position.material_evaluation -= piece_values[side][promote];
#line 75
    tree->position.material_evaluation += piece_values[side][1];
#line 76
    tree->position.pieces[side][0] = (char )((int )tree->position.pieces[side][0] - (int )p_vals[promote]);
#line 77
    tree->position.pieces[side][promote] = (char )((int )tree->position.pieces[side][promote] - 1);
  }
#line 79
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 84
  goto switch_break;
  case_6: /* CIL Label */ 
#line 86
  tree->position.kingsq[side] = from;
#line 87
  if (to - from > 0) {
#line 87
    tmp = to - from;
  } else {
#line 87
    tmp = - (to - from);
  }
#line 87
  if (tmp == 2) {
#line 88
    if (to == (int )rook_G[side]) {
#line 89
      from = (int )rook_H[side];
#line 90
      to = (int )rook_F[side];
    } else {
#line 92
      from = (int )rook_A[side];
#line 93
      to = (int )rook_D[side];
    }
#line 95
    bit_move = set_mask[from] | set_mask[to];
#line 96
    tree->position.color[side].pieces[4] = bit_move ^ tree->position.color[side].pieces[4];
#line 97
    tree->position.color[side].pieces[0] = bit_move ^ tree->position.color[side].pieces[0];
#line 98
    tree->position.board[to] = (int8_t )0;
#line 99
    tree->position.board[from] = (int8_t )pieces[side][4];
  }
#line 101
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 111
  if (captured) {
#line 112
    tree->position.total_all_pieces = (char )((int )tree->position.total_all_pieces + 1);
#line 113
    tree->position.color[enemy].pieces[captured] = set_mask[to] | tree->position.color[enemy].pieces[captured];
#line 114
    tree->position.color[enemy].pieces[0] = set_mask[to] | tree->position.color[enemy].pieces[0];
#line 115
    tree->position.material_evaluation += piece_values[enemy][captured];
#line 116
    tree->position.board[to] = (int8_t )pieces[enemy][captured];
#line 117
    tree->position.pieces[enemy][captured] = (char )((int )tree->position.pieces[enemy][captured] + 1);
#line 118
    if (captured != 1) {
#line 119
      tree->position.pieces[enemy][0] = (char )((int )tree->position.pieces[enemy][0] + (int )p_vals[captured]);
    }
  }
#line 124
  return;
}
}
#line 173 "thread.c"
int Split(TREE *tree ) 
{ 
  TREE *child ;
  int tid ;
  int tstart ;
  int tend ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 199
  tmp = ReadClock();
#line 199
  tstart = (int )tmp;
#line 200
  tree->nprocs = (int volatile   )0;
#line 201
  tid = 0;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! ((unsigned int )tid < smp_max_threads)) {
#line 201
      goto while_break;
    }
#line 202
    tree->siblings[tid] = (struct tree * volatile  )0;
#line 201
    tid ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  child = GetBlock(tree, tree->thread_id);
#line 204
  if (! child) {
#line 205
    return (0);
  }
#line 206
  CopyFromParent(child);
#line 207
  thread[tree->thread_id].tree = child;
#line 208
  tree->joined = (int volatile   )0;
#line 209
  tree->joinable = (int volatile   )1;
#line 210
  parallel_splits ++;
#line 211
  smp_split = (int volatile   )0;
#line 212
  tmp___0 = ReadClock();
#line 212
  tend = (int )tmp___0;
#line 213
  thread[tree->thread_id].idle += (unsigned int )(tend - tstart);
#line 238
  ThreadWait(tree->thread_id, tree);
#line 239
  if (! tree->joined) {
#line 240
    parallel_splits_wasted ++;
  }
#line 241
  return (1);
}
}
#line 259 "thread.c"
int Join(int64_t tid ) 
{ 
  TREE *tree ;
  TREE *join_block ;
  TREE *child ;
  int interest ;
  int best_interest ;
  int current ;
  int pass ;

  {
#line 261
  pass = 0;
#line 298
  pass = 0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (pass < 3)) {
#line 298
      goto while_break;
    }
#line 299
    best_interest = -999999;
#line 300
    join_block = (TREE *)0;
#line 301
    current = 0;
    {
#line 301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 301
      if (! ((unsigned int )current <= smp_max_threads * 64U)) {
#line 301
        goto while_break___0;
      }
#line 302
      tree = block[current];
#line 303
      if (tree->joinable) {
#line 303
        if (tree->ply <= tree->depth / 2) {
#line 303
          goto _L___1;
        } else
#line 303
        if ((unsigned int )tree->nprocs < smp_split_group) {
          _L___1: /* CIL Label */ 
#line 303
          if ((int64_t )tree->thread_id != tid) {
#line 305
            interest = tree->depth * 2 - *(tree->searched + 0);
#line 306
            if (interest > best_interest) {
#line 307
              best_interest = interest;
#line 308
              join_block = tree;
            }
          } else {
#line 303
            goto _L___0;
          }
        } else {
#line 303
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        _L: /* CIL Label */ ;
      }
#line 301
      current ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 346
    if (join_block) {
#line 347
      LockX86(& join_block->lock);
#line 348
      if (join_block->joinable) {
#line 349
        child = GetBlock(join_block, (int )tid);
#line 350
        UnlockX86(& join_block->lock);
#line 351
        if (child) {
#line 352
          CopyFromParent(child);
#line 353
          thread[tid].tree = child;
#line 354
          parallel_joins ++;
#line 355
          return (1);
        }
      } else {
#line 358
        UnlockX86(& join_block->lock);
#line 359
        goto while_break;
      }
    }
#line 298
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  smp_split = (int volatile   )1;
#line 373
  return (0);
}
}
#line 390 "thread.c"
void ThreadAffinity(int cpu ) 
{ 


  {
#line 401
  return;
}
}
#line 416 "thread.c"
void *ThreadInit(void *t ) 
{ 
  int tid ;

  {
#line 417
  tid = (int )((int64_t )t);
#line 419
  ThreadAffinity(tid);
#line 423
  thread[tid].blocks = (uint64_t )0xffffffffffffffffull;
#line 424
  LockX86(& lock_smp);
#line 425
  initialized_threads += (int volatile   )1;
#line 426
  UnlockX86(& lock_smp);
#line 427
  WaitForAllThreadsInitialized();
#line 428
  ThreadWait(tid, (TREE *)0);
#line 429
  LockX86(& lock_smp);
#line 430
  smp_threads -= (int volatile   )1;
#line 431
  UnlockX86(& lock_smp);
#line 432
  return ((void *)0);
}
}
#line 454 "thread.c"
int ThreadSplit(TREE *tree , int ply , int depth , int alpha , int o_alpha , int done ) 
{ 
  TREE *used ;
  int64_t tblocks ;
  int temp ;
  int unused ;
  int tmp ;

  {
#line 458
  unused = 0;
#line 469
  if ((unsigned int )depth < smp_min_split_depth) {
#line 470
    return (0);
  }
#line 494
  if (! smp_split) {
#line 495
    if ((unsigned int )depth < smp_gratuitous_depth) {
#line 495
      goto _L;
    } else
#line 495
    if (done > 1) {
      _L: /* CIL Label */ 
#line 496
      return (0);
    }
#line 497
    tblocks = (int64_t )(~ thread[tree->thread_id].blocks);
    {
#line 498
    while (1) {
      while_continue: /* CIL Label */ ;
#line 498
      if (! tblocks) {
#line 498
        goto while_break;
      }
#line 499
      temp = __builtin_ctzll((unsigned long long )tblocks);
#line 500
      used = block[(temp + tree->thread_id * 64) + 1];
#line 501
      if (used->joinable) {
#line 501
        if (! used->joined) {
#line 502
          unused ++;
        } else {
#line 501
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
#line 503
      tblocks = (int64_t )(clear_mask[temp] & (unsigned long )tblocks);
    }
    while_break: /* CIL Label */ ;
    }
#line 505
    if ((unsigned int )unused > smp_gratuitous_limit) {
#line 506
      return (0);
    }
  } else {
#line 527
    if (ply == 1) {
#line 527
      if (! smp_split_at_root) {
#line 527
        goto _L___3;
      } else {
#line 527
        tmp = NextRootMoveParallel();
#line 527
        if (tmp) {
#line 527
          if (alpha == o_alpha) {
            _L___2: /* CIL Label */ 
#line 529
            return (0);
          } else {
#line 527
            goto _L___1;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 527
          goto _L___2;
        }
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
#line 530
    tblocks = (int64_t )(~ thread[tree->thread_id].blocks);
    {
#line 531
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 531
      if (! tblocks) {
#line 531
        goto while_break___0;
      }
#line 532
      temp = __builtin_ctzll((unsigned long long )tblocks);
#line 533
      used = block[(temp + tree->thread_id * 64) + 1];
#line 534
      if (used->joinable) {
#line 534
        if (! used->joined) {
#line 535
          unused ++;
        } else {
#line 534
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ ;
      }
#line 536
      tblocks = (int64_t )(clear_mask[temp] & (unsigned long )tblocks);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 538
    if ((unsigned int )unused > smp_gratuitous_limit) {
#line 539
      return (0);
    }
  }
#line 541
  return (1);
}
}
#line 558 "thread.c"
void ThreadStop(TREE *tree ) 
{ 
  int proc ;

  {
#line 561
  LockX86(& tree->lock);
#line 562
  tree->stop = (int volatile   )1;
#line 563
  tree->joinable = (int volatile   )0;
#line 564
  proc = 0;
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! ((unsigned int )proc < smp_max_threads)) {
#line 564
      goto while_break;
    }
#line 565
    if (tree->siblings[proc]) {
#line 566
      ThreadStop((TREE *)tree->siblings[proc]);
    }
#line 564
    proc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 567
  UnlockX86(& tree->lock);
#line 568
  return;
}
}
#line 580 "thread.c"
void ThreadTrace(TREE *tree , int depth , int brief ) 
{ 
  int proc ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 583
  LockX86(& tree->lock);
#line 584
  LockX86(& lock_io);
#line 585
  if (! brief) {
#line 586
    i = 0;
    {
#line 586
    while (1) {
      while_continue: /* CIL Label */ ;
#line 586
      if (! (i < 4 * depth)) {
#line 586
        goto while_break;
      }
#line 587
      Print(4095, " ");
#line 586
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 588
    depth ++;
#line 589
    tmp = FindBlockID(tree);
#line 589
    Print(4095, "block[%d]  thread=%d  ply=%d  nprocs=%d  ", tmp, tree->thread_id,
          tree->ply, tree->nprocs);
#line 591
    Print(4095, "joined=%d  joinable=%d  stop=%d  nodes=%d", tree->joined, tree->joinable,
          tree->stop, tree->nodes_searched);
#line 593
    tmp___0 = FindBlockID(tree->parent);
#line 593
    Print(4095, "  parent=%d\n", tmp___0);
  } else
#line 595
  if (tree->nprocs > (int volatile   )1) {
#line 596
    i = 0;
    {
#line 596
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 596
      if (! (i < 4 * depth)) {
#line 596
        goto while_break___0;
      }
#line 597
      Print(4095, " ");
#line 596
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 598
    depth ++;
#line 599
    Print(4095, "(ply %d)", tree->ply);
  }
#line 602
  if (tree->nprocs) {
#line 603
    if (! brief) {
#line 604
      i = 0;
      {
#line 604
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 604
        if (! (i < 4 * depth)) {
#line 604
          goto while_break___1;
        }
#line 605
        Print(4095, " ");
#line 604
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 606
      tmp___1 = FindBlockID(tree->parent);
#line 606
      Print(4095, "          parent=%d  sibling threads=", tmp___1);
#line 608
      proc = 0;
      {
#line 608
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 608
        if (! ((unsigned int )proc < smp_max_threads)) {
#line 608
          goto while_break___2;
        }
#line 609
        if (tree->siblings[proc]) {
#line 610
          tmp___2 = FindBlockID((TREE *)tree->siblings[proc]);
#line 610
          Print(4095, " %d(%d)", proc, tmp___2);
        }
#line 608
        proc ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 611
      Print(4095, "\n");
    } else
#line 613
    if (tree->nprocs > (int volatile   )1) {
#line 614
      Print(4095, " helping= ");
#line 615
      proc = 0;
      {
#line 615
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 615
        if (! ((unsigned int )proc < smp_max_threads)) {
#line 615
          goto while_break___3;
        }
#line 616
        if (tree->siblings[proc]) {
#line 617
          if (proc == tree->thread_id) {
#line 618
            Print(4095, "[");
          }
#line 619
          Print(4095, "%d", proc);
#line 620
          if (proc == tree->thread_id) {
#line 621
            Print(4095, "]");
          }
#line 622
          Print(4095, " ");
        }
#line 615
        proc ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 624
      Print(4095, "\n");
    }
  }
#line 628
  UnlockX86(& lock_io);
#line 629
  proc = 0;
  {
#line 629
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 629
    if (! ((unsigned int )proc < smp_max_threads)) {
#line 629
      goto while_break___4;
    }
#line 630
    if (tree->siblings[proc]) {
#line 631
      ThreadTrace((TREE *)tree->siblings[proc], depth, brief);
    }
#line 629
    proc ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 632
  UnlockX86(& tree->lock);
#line 633
  return;
}
}
#line 657 "thread.c"
int ThreadWait(int tid , TREE *waiting ) 
{ 
  int value ;
  int tstart ;
  int tend ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 680
    if (! 1) {
#line 680
      goto while_break;
    }
#line 681
    tmp = ReadClock();
#line 681
    tstart = (int )tmp;
    {
#line 682
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 682
      if (! thread[tid].tree) {
#line 682
        if (! waiting) {
#line 682
          goto _L___2;
        } else
#line 682
        if (waiting->nprocs) {
          _L___2: /* CIL Label */ 
#line 682
          tmp___0 = Join((int64_t )tid);
#line 682
          if (tmp___0) {
#line 682
            goto _L___1;
          } else
#line 682
          if (! (! thread[tid].terminate)) {
#line 682
            goto _L___1;
          }
        } else {
#line 682
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        _L___0: /* CIL Label */ 
        _L: /* CIL Label */ 
#line 682
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 684
    tmp___1 = ReadClock();
#line 684
    tend = (int )tmp___1;
#line 685
    if (! thread[tid].tree) {
#line 686
      thread[tid].tree = waiting;
    }
#line 687
    thread[tid].idle += (unsigned int )(tend - tstart);
#line 688
    if ((unsigned long )thread[tid].tree == (unsigned long )waiting) {
#line 688
      goto _L___3;
    } else
#line 688
    if (thread[tid].terminate) {
      _L___3: /* CIL Label */ 
#line 689
      return (0);
    }
#line 711
    value = SearchMoveList(thread[tid].tree, (thread[tid].tree)->ply, (thread[tid].tree)->depth,
                           (thread[tid].tree)->wtm, (thread[tid].tree)->alpha, (thread[tid].tree)->beta,
                           (thread[tid].tree)->searched, (thread[tid].tree)->in_check,
                           0, 1);
#line 716
    tmp___2 = ReadClock();
#line 716
    tstart = (int )tmp___2;
#line 717
    LockX86(& ((thread[tid].tree)->parent)->lock);
#line 718
    ((thread[tid].tree)->parent)->joinable = (int volatile   )0;
#line 719
    CopyToParent((thread[tid].tree)->parent, thread[tid].tree, value);
#line 720
    ((thread[tid].tree)->parent)->nprocs -= (int volatile   )1;
#line 721
    ((thread[tid].tree)->parent)->siblings[tid] = (struct tree * volatile  )0;
#line 722
    UnlockX86(& ((thread[tid].tree)->parent)->lock);
#line 723
    thread[tid].tree = (TREE *)0;
#line 724
    tmp___3 = ReadClock();
#line 724
    tend = (int )tmp___3;
#line 725
    thread[tid].idle += (unsigned int )(tend - tstart);
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (0);
}
}
#line 739 "thread.c"
void CopyFromParent(TREE *child ) 
{ 
  TREE *parent ;
  int i ;
  int ply ;

  {
#line 740
  parent = child->parent;
#line 752
  ply = parent->ply;
#line 753
  child->ply = ply;
#line 754
  child->position = parent->position;
#line 755
  i = 0;
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 755
    if (! (i <= rep_index + parent->ply)) {
#line 755
      goto while_break;
    }
#line 756
    child->rep_list[i] = parent->rep_list[i];
#line 755
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 757
  i = ply - 1;
  {
#line 757
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 757
    if (! (i < 129)) {
#line 757
      goto while_break___0;
    }
#line 758
    child->killers[i] = parent->killers[i];
#line 757
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 759
  i = 0;
  {
#line 759
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 759
    if (! (i < 4096)) {
#line 759
      goto while_break___1;
    }
#line 760
    child->counter_move[i] = parent->counter_move[i];
#line 761
    child->move_pair[i] = parent->move_pair[i];
#line 759
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 763
  i = ply - 1;
  {
#line 763
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 763
    if (! (i <= ply)) {
#line 763
      goto while_break___2;
    }
#line 764
    child->curmv[i] = parent->curmv[i];
#line 765
    child->pv[i] = parent->pv[i];
#line 763
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 767
  child->in_check = parent->in_check;
#line 768
  child->last[ply] = child->move_list;
#line 769
  child->status[ply] = parent->status[ply];
#line 770
  child->status[1] = parent->status[1];
#line 771
  child->save_hash_key[ply] = parent->save_hash_key[ply];
#line 772
  child->save_pawn_hash_key[ply] = parent->save_pawn_hash_key[ply];
#line 773
  child->nodes_searched = (uint64_t )0;
#line 774
  child->fail_highs = (uint64_t )0;
#line 775
  child->fail_high_first_move = (uint64_t )0;
#line 776
  child->evaluations = (uint64_t )0;
#line 777
  child->egtb_probes = (uint64_t )0;
#line 778
  child->egtb_hits = (uint64_t )0;
#line 779
  child->extensions_done = (uint64_t )0;
#line 780
  child->qchecks_done = (uint64_t )0;
#line 781
  child->moves_fpruned = (uint64_t )0;
#line 782
  child->moves_mpruned = (uint64_t )0;
#line 783
  i = 0;
  {
#line 783
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 783
    if (! (i < 16)) {
#line 783
      goto while_break___3;
    }
#line 784
    child->LMR_done[i] = (uint64_t )0;
#line 785
    child->null_done[i] = (uint64_t )0;
#line 783
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 787
  child->alpha = parent->alpha;
#line 788
  child->beta = parent->beta;
#line 789
  child->value = parent->value;
#line 790
  child->wtm = parent->wtm;
#line 791
  child->depth = parent->depth;
#line 792
  child->searched = parent->searched;
#line 793
  strcpy(child->root_move_text, (char const   *)(parent->root_move_text));
#line 794
  strcpy(child->remaining_moves_text, (char const   *)(parent->remaining_moves_text));
#line 795
  return;
}
}
#line 807 "thread.c"
void CopyToParent(TREE *parent , TREE *child , int value ) 
{ 
  int i ;
  int ply ;
  int which ;
  int tmp ;

  {
#line 808
  ply = parent->ply;
#line 837
  if (child->nodes_searched) {
#line 837
    if (! child->stop) {
#line 837
      if (value > (int )parent->value) {
#line 837
        if (! abort_search) {
#line 839
          parent->pv[ply] = child->pv[ply];
#line 840
          parent->value = (int volatile   )value;
#line 841
          parent->cutmove = child->curmv[ply];
#line 842
          i = 0;
          {
#line 842
          while (1) {
            while_continue: /* CIL Label */ ;
#line 842
            if (! (i < 4096)) {
#line 842
              goto while_break;
            }
#line 843
            parent->counter_move[i] = child->counter_move[i];
#line 844
            parent->move_pair[i] = child->move_pair[i];
#line 842
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
        } else {
#line 837
          goto _L___1;
        }
      } else {
#line 837
        goto _L___1;
      }
    } else {
#line 837
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ ;
  }
#line 847
  if (child->stop) {
#line 847
    if (ply == 1) {
#line 848
      which = 0;
      {
#line 848
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 848
        if (! (which < n_root_moves)) {
#line 848
          goto while_break___0;
        }
#line 849
        if (root_moves[which].move == child->curmv[ply]) {
#line 850
          root_moves[which].status &= 7U;
#line 851
          goto while_break___0;
        }
#line 848
        which ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 847
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ ;
  }
#line 853
  parent->nodes_searched += child->nodes_searched;
#line 854
  parent->fail_highs += child->fail_highs;
#line 855
  parent->fail_high_first_move += child->fail_high_first_move;
#line 856
  parent->evaluations += child->evaluations;
#line 857
  parent->egtb_probes += child->egtb_probes;
#line 858
  parent->egtb_hits += child->egtb_hits;
#line 859
  parent->extensions_done += child->extensions_done;
#line 860
  parent->qchecks_done += child->qchecks_done;
#line 861
  parent->moves_fpruned += child->moves_fpruned;
#line 862
  parent->moves_mpruned += child->moves_mpruned;
#line 863
  i = 1;
  {
#line 863
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 863
    if (! (i < 16)) {
#line 863
      goto while_break___1;
    }
#line 864
    parent->LMR_done[i] += child->LMR_done[i];
#line 865
    parent->null_done[i] += child->null_done[i];
#line 863
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 867
  tmp = FindBlockID(child);
#line 867
  which = (tmp - 64 * child->thread_id) - 1;
#line 868
  thread[child->thread_id].blocks = set_mask[which] | thread[child->thread_id].blocks;
#line 869
  return;
}
}
#line 890 "thread.c"
static int warnings  =    0;
#line 888 "thread.c"
TREE *GetBlock(TREE *parent , int tid ) 
{ 
  TREE *child ;
  int i ;
  int unused ;

  {
#line 924
  if (thread[tid].blocks) {
#line 925
    unused = __builtin_ctzll((unsigned long long )thread[tid].blocks);
#line 926
    thread[tid].blocks = clear_mask[unused] & thread[tid].blocks;
#line 927
    thread[tid].max_blocks = set_mask[unused] | thread[tid].max_blocks;
  } else {
#line 929
    warnings ++;
#line 929
    if (warnings < 6) {
#line 930
      Print(2048, "WARNING.  local SMP block cannot be allocated, thread %d\n", tid);
    }
#line 932
    return ((TREE *)0);
  }
#line 934
  child = block[(unused + tid * 64) + 1];
#line 947
  i = 0;
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
#line 947
    if (! ((unsigned int )i < smp_max_threads)) {
#line 947
      goto while_break;
    }
#line 948
    child->siblings[i] = (struct tree * volatile  )0;
#line 947
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 949
  child->nprocs = (int volatile   )0;
#line 950
  child->stop = (int volatile   )0;
#line 951
  child->joinable = (int volatile   )0;
#line 952
  child->joined = (int volatile   )0;
#line 953
  child->parent = parent;
#line 954
  child->thread_id = tid;
#line 955
  parent->nprocs += (int volatile   )1;
#line 956
  parent->siblings[tid] = (struct tree * volatile  )child;
#line 957
  parent->joined = (int volatile   )1;
#line 958
  return (child);
}
}
#line 971 "thread.c"
void WaitForAllThreadsInitialized(void) 
{ 


  {
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    if (! ((unsigned int )initialized_threads < smp_max_threads)) {
#line 972
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 973
  return;
}
}
#line 34 "repeat.c"
int Repeat(TREE *tree , int ply ) 
{ 
  int where ;
  int count ;

  {
#line 48
  tree->rep_list[rep_index + ply] = tree->position.hash_key;
#line 49
  if ((int )tree->status[ply].reversible < 4) {
#line 50
    return (0);
  }
#line 51
  if ((int )tree->status[ply].reversible > 99) {
#line 52
    return (3);
  }
#line 68
  count = (int )tree->status[ply].reversible / 2 - 1;
#line 69
  where = (rep_index + ply) - 4;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! count) {
#line 69
      goto while_break;
    }
#line 70
    if (tree->position.hash_key == tree->rep_list[where]) {
#line 71
      return (2);
    }
#line 69
    where -= 2;
#line 69
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (0);
}
}
#line 88 "repeat.c"
int Repeat3x(TREE *tree ) 
{ 
  int reps ;
  int where ;

  {
#line 89
  reps = 0;
#line 99
  if ((int )tree->status[0].reversible > 99) {
#line 100
    return (2);
  }
#line 112
  where = rep_index % 2;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (where < rep_index)) {
#line 112
      goto while_break;
    }
#line 113
    if (tree->position.hash_key == tree->rep_list[where]) {
#line 114
      reps ++;
    }
#line 112
    where += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return (reps == 2);
}
}
#line 16 "next.c"
int NextMove(TREE *tree , int ply , int depth , int side , int in_check ) 
{ 
  unsigned int *movep ;
  unsigned int *bestp ;
  int hist ;
  int bestval ;
  int possible ;
  unsigned int *tmp ;
  int tmp___0 ;
  unsigned int *tmp___1 ;
  int tmp___2 ;
  unsigned int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  unsigned int *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned int *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  unsigned int *tmp___28 ;

  {
  {
#line 42
  if (tree->next_status[ply].phase == 2) {
#line 42
    goto case_2;
  }
#line 75
  if (tree->next_status[ply].phase == 3) {
#line 75
    goto case_3;
  }
#line 122
  if (tree->next_status[ply].phase == 4) {
#line 122
    goto case_4;
  }
#line 147
  if (tree->next_status[ply].phase == 5) {
#line 147
    goto case_5;
  }
#line 157
  if (tree->next_status[ply].phase == 6) {
#line 157
    goto case_6;
  }
#line 167
  if (tree->next_status[ply].phase == 7) {
#line 167
    goto case_7;
  }
#line 177
  if (tree->next_status[ply].phase == 8) {
#line 177
    goto case_8;
  }
#line 196
  if (tree->next_status[ply].phase == 9) {
#line 196
    goto case_9;
  }
#line 206
  if (tree->next_status[ply].phase == 10) {
#line 206
    goto case_10;
  }
#line 225
  if (tree->next_status[ply].phase == 11) {
#line 225
    goto case_11;
  }
#line 235
  if (tree->next_status[ply].phase == 12) {
#line 235
    goto case_12;
  }
#line 253
  if (tree->next_status[ply].phase == 13) {
#line 253
    goto case_13;
  }
#line 305
  if (tree->next_status[ply].phase == 14) {
#line 305
    goto case_14;
  }
#line 341
  if (tree->next_status[ply].phase == 15) {
#line 341
    goto case_15;
  }
#line 350
  goto switch_default;
  case_2: /* CIL Label */ 
#line 43
  tree->next_status[ply].order = 0;
#line 44
  tree->next_status[ply].exclude = & tree->next_status[ply].done[0];
#line 45
  tree->next_status[ply].phase = 3;
#line 46
  if (tree->hash_move[ply]) {
#line 47
    tree->curmv[ply] = tree->hash_move[ply];
#line 48
    tmp = tree->next_status[ply].exclude;
#line 48
    (tree->next_status[ply].exclude) ++;
#line 48
    *tmp = (unsigned int )tree->curmv[ply];
#line 49
    tmp___0 = ValidMove(tree, ply, side, tree->curmv[ply]);
#line 49
    if (tmp___0) {
#line 50
      tree->phase[ply] = 2;
#line 51
      (tree->next_status[ply].order) ++;
#line 51
      return (tree->next_status[ply].order);
    }
  }
  case_3: /* CIL Label */ 
#line 76
  tree->next_status[ply].phase = 4;
#line 77
  if (! in_check) {
#line 78
    tree->last[ply] = GenerateCaptures(tree, ply, side, tree->last[ply - 1]);
  } else {
#line 81
    tree->last[ply] = GenerateCheckEvasions(tree, ply, side, tree->last[ply - 1]);
  }
#line 94
  tree->next_status[ply].remaining = 0;
#line 95
  movep = tree->last[ply - 1];
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! ((unsigned long )movep < (unsigned long )tree->last[ply])) {
#line 95
      goto while_break;
    }
#line 96
    if (*movep == (unsigned int )tree->hash_move[ply]) {
#line 97
      *movep = 0U;
#line 98
      tree->next_status[ply].exclude = & tree->next_status[ply].done[0];
    } else {
#line 100
      *movep += (unsigned int )MVV_LVA[(*movep >> 15) & 7U][(*movep >> 12) & 7U];
#line 101
      (tree->next_status[ply].remaining) ++;
    }
#line 95
    movep ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  NextSort(tree, ply);
#line 104
  tree->next_status[ply].last = tree->last[ply - 1];
#line 105
  if (in_check) {
#line 106
    goto remaining_moves;
  }
  case_4: /* CIL Label */ 
  {
#line 123
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 123
    if (! tree->next_status[ply].remaining) {
#line 123
      goto while_break___0;
    }
#line 124
    tmp___1 = tree->next_status[ply].last;
#line 124
    (tree->next_status[ply].last) ++;
#line 124
    tree->curmv[ply] = (int )(*tmp___1 & 2097151U);
#line 125
    (tree->next_status[ply].remaining) --;
#line 125
    if (! tree->next_status[ply].remaining) {
#line 126
      tree->next_status[ply].phase = 5;
    }
#line 127
    if (pcval[(tree->curmv[ply] >> 12) & 7] <= pcval[(tree->curmv[ply] >> 15) & 7]) {
#line 127
      goto _L;
    } else {
#line 127
      tmp___2 = SEE(tree, side, tree->curmv[ply]);
#line 127
      if (tmp___2 >= 0) {
        _L: /* CIL Label */ 
#line 130
        *(tree->next_status[ply].last - 1) = 0U;
#line 131
        tree->phase[ply] = 4;
#line 132
        (tree->next_status[ply].order) ++;
#line 132
        return (tree->next_status[ply].order);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  case_5: /* CIL Label */ 
#line 148
  possible = (int )tree->killers[ply].move1;
#line 149
  tmp___4 = Exclude(tree, ply, possible);
#line 149
  if (tmp___4) {
    _L___0: /* CIL Label */ ;
  } else {
#line 149
    tmp___5 = ValidMove(tree, ply, side, possible);
#line 149
    if (tmp___5) {
#line 151
      tree->curmv[ply] = possible;
#line 152
      tmp___3 = tree->next_status[ply].exclude;
#line 152
      (tree->next_status[ply].exclude) ++;
#line 152
      *tmp___3 = (unsigned int )possible;
#line 153
      tree->next_status[ply].phase = 6;
#line 154
      tree->phase[ply] = 5;
#line 155
      (tree->next_status[ply].order) ++;
#line 155
      return (tree->next_status[ply].order);
    } else {
#line 149
      goto _L___0;
    }
  }
  case_6: /* CIL Label */ 
#line 158
  possible = (int )tree->killers[ply].move2;
#line 159
  tmp___7 = Exclude(tree, ply, possible);
#line 159
  if (tmp___7) {
    _L___1: /* CIL Label */ ;
  } else {
#line 159
    tmp___8 = ValidMove(tree, ply, side, possible);
#line 159
    if (tmp___8) {
#line 161
      tree->curmv[ply] = possible;
#line 162
      tmp___6 = tree->next_status[ply].exclude;
#line 162
      (tree->next_status[ply].exclude) ++;
#line 162
      *tmp___6 = (unsigned int )possible;
#line 163
      if (ply < 3) {
#line 163
        tree->next_status[ply].phase = 9;
      } else {
#line 163
        tree->next_status[ply].phase = 7;
      }
#line 164
      tree->phase[ply] = 6;
#line 165
      (tree->next_status[ply].order) ++;
#line 165
      return (tree->next_status[ply].order);
    } else {
#line 159
      goto _L___1;
    }
  }
  case_7: /* CIL Label */ 
#line 168
  possible = (int )tree->killers[ply - 2].move1;
#line 169
  tmp___10 = Exclude(tree, ply, possible);
#line 169
  if (tmp___10) {
    _L___2: /* CIL Label */ ;
  } else {
#line 169
    tmp___11 = ValidMove(tree, ply, side, possible);
#line 169
    if (tmp___11) {
#line 171
      tree->curmv[ply] = possible;
#line 172
      tmp___9 = tree->next_status[ply].exclude;
#line 172
      (tree->next_status[ply].exclude) ++;
#line 172
      *tmp___9 = (unsigned int )possible;
#line 173
      tree->next_status[ply].phase = 8;
#line 174
      tree->phase[ply] = 7;
#line 175
      (tree->next_status[ply].order) ++;
#line 175
      return (tree->next_status[ply].order);
    } else {
#line 169
      goto _L___2;
    }
  }
  case_8: /* CIL Label */ 
#line 178
  possible = (int )tree->killers[ply - 2].move2;
#line 179
  tmp___13 = Exclude(tree, ply, possible);
#line 179
  if (tmp___13) {
    _L___3: /* CIL Label */ ;
  } else {
#line 179
    tmp___14 = ValidMove(tree, ply, side, possible);
#line 179
    if (tmp___14) {
#line 181
      tree->curmv[ply] = possible;
#line 182
      tmp___12 = tree->next_status[ply].exclude;
#line 182
      (tree->next_status[ply].exclude) ++;
#line 182
      *tmp___12 = (unsigned int )possible;
#line 183
      tree->next_status[ply].phase = 9;
#line 184
      tree->phase[ply] = 8;
#line 185
      (tree->next_status[ply].order) ++;
#line 185
      return (tree->next_status[ply].order);
    } else {
#line 179
      goto _L___3;
    }
  }
  case_9: /* CIL Label */ 
#line 197
  possible = (int )tree->counter_move[tree->curmv[ply - 1] & 4095].move1;
#line 198
  tmp___16 = Exclude(tree, ply, possible);
#line 198
  if (tmp___16) {
    _L___4: /* CIL Label */ ;
  } else {
#line 198
    tmp___17 = ValidMove(tree, ply, side, possible);
#line 198
    if (tmp___17) {
#line 200
      tree->curmv[ply] = possible;
#line 201
      tmp___15 = tree->next_status[ply].exclude;
#line 201
      (tree->next_status[ply].exclude) ++;
#line 201
      *tmp___15 = (unsigned int )possible;
#line 202
      tree->next_status[ply].phase = 10;
#line 203
      tree->phase[ply] = 9;
#line 204
      (tree->next_status[ply].order) ++;
#line 204
      return (tree->next_status[ply].order);
    } else {
#line 198
      goto _L___4;
    }
  }
  case_10: /* CIL Label */ 
#line 207
  possible = (int )tree->counter_move[tree->curmv[ply - 1] & 4095].move2;
#line 208
  tmp___19 = Exclude(tree, ply, possible);
#line 208
  if (tmp___19) {
    _L___5: /* CIL Label */ ;
  } else {
#line 208
    tmp___20 = ValidMove(tree, ply, side, possible);
#line 208
    if (tmp___20) {
#line 210
      tree->curmv[ply] = possible;
#line 211
      tmp___18 = tree->next_status[ply].exclude;
#line 211
      (tree->next_status[ply].exclude) ++;
#line 211
      *tmp___18 = (unsigned int )possible;
#line 212
      tree->next_status[ply].phase = 11;
#line 213
      tree->phase[ply] = 10;
#line 214
      (tree->next_status[ply].order) ++;
#line 214
      return (tree->next_status[ply].order);
    } else {
#line 208
      goto _L___5;
    }
  }
  case_11: /* CIL Label */ 
#line 226
  possible = (int )tree->move_pair[tree->curmv[ply - 2] & 4095].move1;
#line 227
  tmp___22 = Exclude(tree, ply, possible);
#line 227
  if (tmp___22) {
    _L___6: /* CIL Label */ ;
  } else {
#line 227
    tmp___23 = ValidMove(tree, ply, side, possible);
#line 227
    if (tmp___23) {
#line 229
      tree->curmv[ply] = possible;
#line 230
      tmp___21 = tree->next_status[ply].exclude;
#line 230
      (tree->next_status[ply].exclude) ++;
#line 230
      *tmp___21 = (unsigned int )possible;
#line 231
      tree->next_status[ply].phase = 12;
#line 232
      tree->phase[ply] = 11;
#line 233
      (tree->next_status[ply].order) ++;
#line 233
      return (tree->next_status[ply].order);
    } else {
#line 227
      goto _L___6;
    }
  }
  case_12: /* CIL Label */ 
#line 236
  possible = (int )tree->move_pair[tree->curmv[ply - 2] & 4095].move2;
#line 237
  tmp___25 = Exclude(tree, ply, possible);
#line 237
  if (tmp___25) {
    _L___7: /* CIL Label */ ;
  } else {
#line 237
    tmp___26 = ValidMove(tree, ply, side, possible);
#line 237
    if (tmp___26) {
#line 239
      tree->curmv[ply] = possible;
#line 240
      tmp___24 = tree->next_status[ply].exclude;
#line 240
      (tree->next_status[ply].exclude) ++;
#line 240
      *tmp___24 = (unsigned int )possible;
#line 241
      tree->next_status[ply].phase = 13;
#line 242
      tree->phase[ply] = 12;
#line 243
      (tree->next_status[ply].order) ++;
#line 243
      return (tree->next_status[ply].order);
    } else {
#line 237
      goto _L___7;
    }
  }
  case_13: /* CIL Label */ 
#line 254
  if (! in_check) {
#line 255
    tree->last[ply] = GenerateNoncaptures(tree, ply, side, tree->last[ply]);
  }
#line 257
  tree->next_status[ply].last = tree->last[ply - 1];
#line 270
  tree->next_status[ply].remaining = 0;
#line 271
  tree->next_status[ply].phase = 14;
#line 272
  bestval = -99999999;
#line 273
  bestp = (unsigned int *)0;
#line 274
  movep = tree->last[ply - 1];
  {
#line 274
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 274
    if (! ((unsigned long )movep < (unsigned long )tree->last[ply])) {
#line 274
      goto while_break___1;
    }
#line 275
    if (*movep) {
#line 276
      tmp___27 = Exclude(tree, ply, (int )*movep);
#line 276
      if (tmp___27) {
#line 277
        *movep = 0U;
      } else
#line 278
      if (depth >= 6) {
#line 279
        (tree->next_status[ply].remaining) ++;
#line 280
        hist = history[((unsigned int )(side << 9) + (((*movep >> 12) & 7U) << 6)) + ((*movep >> 6) & 63U)];
#line 281
        if (hist > bestval) {
#line 282
          bestval = hist;
#line 283
          bestp = movep;
        }
      }
    }
#line 274
    movep ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 287
  tree->next_status[ply].remaining /= 2;
#line 288
  if (bestp) {
#line 289
    tree->curmv[ply] = (int )(*bestp & 2097151U);
#line 290
    *bestp = 0U;
#line 291
    tree->phase[ply] = 14;
#line 292
    (tree->next_status[ply].order) ++;
#line 292
    return (tree->next_status[ply].order);
  }
#line 294
  goto remaining_moves;
  case_14: /* CIL Label */ 
#line 306
  if (depth >= 6) {
#line 307
    bestval = -99999999;
#line 308
    bestp = (unsigned int *)0;
#line 309
    movep = tree->last[ply - 1];
    {
#line 309
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 309
      if (! ((unsigned long )movep < (unsigned long )tree->last[ply])) {
#line 309
        goto while_break___2;
      }
#line 310
      if (*movep) {
#line 311
        hist = history[((unsigned int )(side << 9) + (((*movep >> 12) & 7U) << 6)) + ((*movep >> 6) & 63U)];
#line 312
        if (hist > bestval) {
#line 313
          bestval = hist;
#line 314
          bestp = movep;
        }
      }
#line 309
      movep ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 317
    if (bestp) {
#line 318
      tree->curmv[ply] = (int )(*bestp & 2097151U);
#line 319
      *bestp = 0U;
#line 320
      (tree->next_status[ply].remaining) --;
#line 320
      if (tree->next_status[ply].remaining <= 0) {
#line 321
        tree->next_status[ply].phase = 15;
#line 322
        tree->next_status[ply].last = tree->last[ply - 1];
      }
#line 324
      tree->phase[ply] = 14;
#line 325
      (tree->next_status[ply].order) ++;
#line 325
      return (tree->next_status[ply].order);
    }
  }
  remaining_moves: 
#line 339
  tree->next_status[ply].phase = 15;
#line 340
  tree->next_status[ply].last = tree->last[ply - 1];
  case_15: /* CIL Label */ 
  {
#line 342
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 342
    if (! ((unsigned long )tree->next_status[ply].last < (unsigned long )tree->last[ply])) {
#line 342
      goto while_break___3;
    }
#line 344
    if (*(tree->next_status[ply].last)) {
#line 345
      tmp___28 = tree->next_status[ply].last;
#line 345
      (tree->next_status[ply].last) ++;
#line 345
      tree->curmv[ply] = (int )(*tmp___28 & 2097151U);
#line 346
      tree->phase[ply] = 15;
#line 347
      (tree->next_status[ply].order) ++;
#line 347
      return (tree->next_status[ply].order);
    }
#line 342
    (tree->next_status[ply].last) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 349
  return (0);
  switch_default: /* CIL Label */ 
#line 351
  Print(4095, "oops!  next_status.phase is bad! [phase=%d]\n", tree->next_status[ply].phase);
  switch_break: /* CIL Label */ ;
  }
#line 354
  return (0);
}
}
#line 391 "next.c"
int NextRootMove(TREE *tree , TREE *mytree , int side ) 
{ 
  uint64_t total_nodes ;
  int which ;
  int i ;
  int t ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 405
  if (! annotate_mode) {
#line 405
    if (! pondering) {
#line 405
      if (! booking) {
#line 405
        if (n_root_moves == 1) {
#line 405
          if (iteration > 10) {
#line 407
            abort_search = 1;
#line 408
            return (0);
          } else {
#line 405
            goto _L___2;
          }
        } else {
#line 405
          goto _L___2;
        }
      } else {
#line 405
        goto _L___2;
      }
    } else {
#line 405
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ ;
  }
#line 424
  which = 0;
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 424
    if (! (which < n_root_moves)) {
#line 424
      goto while_break;
    }
#line 425
    if (! (root_moves[which].status & 8U)) {
#line 426
      if (search_move) {
#line 427
        if (root_moves[which].move != search_move) {
#line 428
          root_moves[which].status |= 8U;
#line 429
          goto __Cont;
        }
      }
#line 432
      tree->curmv[1] = root_moves[which].move;
#line 433
      root_moves[which].status |= 8U;
#line 450
      tmp___5 = ReadClock();
#line 450
      if (tmp___5 - start_time > noise_level) {
#line 450
        if (display_options & 16) {
#line 451
          sprintf(mytree->remaining_moves_text, (char const   *)"%d/%d", which + 1,
                  n_root_moves);
#line 453
          end_time = ReadClock();
#line 454
          LockX86(& lock_io);
#line 455
          if (pondering) {
#line 456
            tmp = Display2Times(end_time - start_time);
#line 456
            printf((char const   *)"         %2i   %s%7s?  ", iteration, tmp, mytree->remaining_moves_text);
          } else {
#line 460
            tmp___0 = Display2Times(end_time - start_time);
#line 460
            printf((char const   *)"         %2i   %s%7s*  ", iteration, tmp___0,
                   mytree->remaining_moves_text);
          }
#line 463
          printf((char const   *)"%d. ", move_number);
#line 464
          if (side ^ 1) {
#line 465
            printf((char const   *)"... ");
          }
#line 466
          tmp___1 = OutputMove(tree, 1, side, tree->curmv[1]);
#line 466
          strcpy(mytree->root_move_text, (char const   *)tmp___1);
#line 468
          total_nodes = (block[0])->nodes_searched;
#line 469
          t = 0;
          {
#line 469
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 469
            if (! ((unsigned int )t < smp_max_threads)) {
#line 469
              goto while_break___0;
            }
#line 470
            i = 0;
            {
#line 470
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 470
              if (! (i < 64)) {
#line 470
                goto while_break___1;
              }
#line 471
              if (! (thread[t].blocks & set_mask[i])) {
#line 472
                total_nodes += (block[(t * 64 + 1) + i])->nodes_searched;
              }
#line 470
              i ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 469
            t ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 473
          if (end_time - start_time > 1U) {
#line 473
            tmp___2 = end_time - start_time;
          } else {
#line 473
            tmp___2 = 1U;
          }
#line 473
          nodes_per_second = (unsigned int )((total_nodes * 100UL) / (uint64_t )tmp___2);
#line 474
          tmp___3 = strlen((char const   *)(mytree->root_move_text));
#line 474
          i = (int )tmp___3;
#line 475
          if (i < 8) {
#line 475
            i = i;
          } else {
#line 475
            i = 8;
          }
#line 476
          strncat(mytree->root_move_text, (char const   *)"          ", (size_t )(8 - i));
#line 477
          printf((char const   *)"%s", mytree->root_move_text);
#line 478
          tmp___4 = DisplayKMB((uint64_t )nodes_per_second, 0);
#line 478
          printf((char const   *)"(%snps)             \r", tmp___4);
#line 479
          fflush(stdout);
#line 480
          UnlockX86(& lock_io);
        } else {
#line 450
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ ;
      }
#line 494
      if (root_moves[which].status & 4U) {
#line 495
        tree->phase[1] = 1;
      } else {
#line 497
        tree->phase[1] = 15;
      }
#line 498
      return (which + 1);
    }
    __Cont: /* CIL Label */ 
#line 424
    which ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  return (0);
}
}
#line 520 "next.c"
int NextRootMoveParallel(void) 
{ 
  int which ;

  {
#line 544
  which = 0;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    if (! (which < n_root_moves)) {
#line 544
      goto while_break;
    }
#line 545
    if (! (root_moves[which].status & 8U)) {
#line 546
      goto while_break;
    }
#line 544
    which ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  if (which < n_root_moves) {
#line 547
    if (! (root_moves[which].status & 4U)) {
#line 548
      return (1);
    } else {
#line 547
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 549
  return (0);
}
}
#line 568 "next.c"
int Exclude(TREE *tree , int ply , int move ) 
{ 
  unsigned int *i ;

  {
#line 571
  if ((unsigned long )tree->next_status[ply].exclude > (unsigned long )(& tree->next_status[ply].done[0])) {
#line 572
    i = & tree->next_status[ply].done[0];
    {
#line 572
    while (1) {
      while_continue: /* CIL Label */ ;
#line 572
      if (! ((unsigned long )i < (unsigned long )tree->next_status[ply].exclude)) {
#line 572
        goto while_break;
      }
#line 574
      if ((unsigned int )move == *i) {
#line 575
        return (1);
      }
#line 572
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 576
  return (0);
}
}
#line 589 "next.c"
void NextSort(TREE *tree , int ply ) 
{ 
  unsigned int temp ;
  unsigned int *movep ;
  unsigned int *tmovep ;

  {
#line 599
  if ((unsigned long )tree->last[ply] > (unsigned long )(tree->last[ply - 1] + 1)) {
#line 600
    movep = tree->last[ply - 1] + 1;
    {
#line 600
    while (1) {
      while_continue: /* CIL Label */ ;
#line 600
      if (! ((unsigned long )movep < (unsigned long )tree->last[ply])) {
#line 600
        goto while_break;
      }
#line 601
      temp = *movep;
#line 602
      tmovep = movep - 1;
      {
#line 603
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 603
        if ((unsigned long )tmovep >= (unsigned long )tree->last[ply - 1]) {
#line 603
          if (! (*tmovep >> 21 < temp >> 21)) {
#line 603
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 603
          goto while_break___0;
        }
#line 604
        *(tmovep + 1) = *tmovep;
#line 605
        tmovep --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 607
      *(tmovep + 1) = temp;
#line 600
      movep ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 610
  return;
}
}
#line 24 "history.c"
void History(TREE *tree , int ply , int depth , int side , int move , int *searched ) 
{ 
  int i ;
  int index___0 ;
  int mindex ;

  {
#line 53
  if (! ((move >> 15) & 63)) {
#line 54
    if (tree->killers[ply].move1 != (uint32_t )move) {
#line 55
      tree->killers[ply].move2 = tree->killers[ply].move1;
#line 56
      tree->killers[ply].move1 = (uint32_t )move;
    }
#line 66
    if (tree->counter_move[tree->curmv[ply - 1] & 4095].move1 != (uint32_t )move) {
#line 67
      tree->counter_move[tree->curmv[ply - 1] & 4095].move2 = tree->counter_move[tree->curmv[ply - 1] & 4095].move1;
#line 69
      tree->counter_move[tree->curmv[ply - 1] & 4095].move1 = (uint32_t )move;
    }
#line 80
    if (ply > 2) {
#line 81
      if (tree->move_pair[tree->curmv[ply - 2] & 4095].move1 != (uint32_t )move) {
#line 82
        tree->move_pair[tree->curmv[ply - 2] & 4095].move2 = tree->move_pair[tree->curmv[ply - 2] & 4095].move1;
#line 84
        tree->move_pair[tree->curmv[ply - 2] & 4095].move1 = (uint32_t )move;
      }
    }
#line 95
    if (depth > 5) {
#line 96
      mindex = ((side << 9) + (((move >> 12) & 7) << 6)) + ((move >> 6) & 63);
#line 97
      history[mindex] += (2048 - history[mindex]) >> 5;
#line 107
      i = 1;
      {
#line 107
      while (1) {
        while_continue: /* CIL Label */ ;
#line 107
        if (! (i <= *(searched + 0))) {
#line 107
          goto while_break;
        }
#line 108
        index___0 = ((side << 9) + (((*(searched + i) >> 12) & 7) << 6)) + ((*(searched + i) >> 6) & 63);
#line 109
        if (index___0 != mindex) {
#line 110
          history[index___0] -= history[index___0] >> 5;
        }
#line 107
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 114
  return;
}
}
#line 42 "quiesce.c"
int Quiesce(TREE *tree , int ply , int wtm , int alpha , int beta , int checks ) 
{ 
  unsigned int *next___0 ;
  unsigned int *movep ;
  int original_alpha ;
  int value ;
  int repeat ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 45
  original_alpha = alpha;
#line 54
  if (ply >= 128) {
#line 55
    return (beta);
  }
#line 62
  if (tree->thread_id == 0) {
#line 63
    next_time_check --;
  }
#line 77
  if (checks) {
#line 78
    repeat = Repeat(tree, ply);
#line 79
    if (repeat) {
#line 80
      value = draw_score[wtm];
#line 81
      if (value < beta) {
        {
#line 82
        while (1) {
          while_continue: /* CIL Label */ ;
#line 82
          tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
#line 82
          tree->pv[ply - 1].pathl = ply;
#line 82
          tree->pv[ply - 1].pathh = repeat;
#line 82
          tree->pv[ply - 1].pathd = iteration;
#line 82
          if (! 0) {
#line 82
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 87
      return (value);
    }
  }
#line 101
  value = Evaluate(tree, ply, wtm, alpha, beta);
#line 107
  if (value > alpha) {
#line 108
    if (value >= beta) {
#line 109
      return (value);
    }
#line 110
    alpha = value;
#line 111
    tree->pv[ply].pathl = ply;
#line 112
    tree->pv[ply].pathh = 0;
#line 113
    tree->pv[ply].pathd = iteration;
  }
#line 133
  tree->last[ply] = GenerateCaptures(tree, ply, wtm, tree->last[ply - 1]);
#line 134
  movep = tree->last[ply - 1];
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 134
    if (! ((unsigned long )movep < (unsigned long )tree->last[ply])) {
#line 134
      goto while_break___0;
    }
#line 135
    if (((*movep >> 15) & 7U) == 6U) {
#line 136
      return (beta);
    }
#line 137
    *movep += (unsigned int )MVV_LVA[(*movep >> 15) & 7U][(*movep >> 12) & 7U];
#line 134
    movep ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 139
  if (! checks) {
#line 139
    if ((unsigned long )tree->last[ply] == (unsigned long )tree->last[ply - 1]) {
#line 140
      if (alpha != original_alpha) {
#line 141
        tree->pv[ply - 1] = tree->pv[ply];
#line 142
        tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
      }
#line 144
      return (value);
    } else {
#line 139
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 146
  NextSort(tree, ply);
#line 172
  next___0 = tree->last[ply - 1];
  {
#line 172
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 172
    if (! ((unsigned long )next___0 < (unsigned long )tree->last[ply])) {
#line 172
      goto while_break___1;
    }
#line 173
    tree->curmv[ply] = (int )(*next___0 & 2097151U);
#line 174
    if (pcval[(tree->curmv[ply] >> 12) & 7] > pcval[(tree->curmv[ply] >> 15) & 7]) {
#line 174
      if ((int )tree->position.pieces[wtm ^ 1][0] - (int )p_vals[(tree->curmv[ply] >> 15) & 7] > 0) {
#line 174
        tmp = SEE(tree, wtm, tree->curmv[ply]);
#line 174
        if (tmp < 0) {
#line 178
          goto __Cont;
        } else {
#line 174
          goto _L___1;
        }
      } else {
#line 174
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      _L___0: /* CIL Label */ ;
    }
#line 184
    MakeMove(tree, ply, wtm, tree->curmv[ply]);
#line 185
    (tree->nodes_searched) ++;
#line 186
    if (! checks) {
#line 187
      tmp___0 = Quiesce(tree, ply + 1, wtm ^ 1, - beta, - alpha, 0);
#line 187
      value = - tmp___0;
    } else {
#line 188
      tmp___4 = Attacks(tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 188
      if (! tmp___4) {
#line 189
        tmp___3 = Attacks(tree, (wtm ^ 1) ^ 1, tree->position.kingsq[wtm ^ 1]);
#line 189
        if (tmp___3) {
#line 190
          (tree->qchecks_done) ++;
#line 191
          tmp___1 = QuiesceEvasions(tree, ply + 1, wtm ^ 1, - beta, - alpha);
#line 191
          value = - tmp___1;
        } else {
#line 193
          tmp___2 = Quiesce(tree, ply + 1, wtm ^ 1, - beta, - alpha, 0);
#line 193
          value = - tmp___2;
        }
      }
    }
#line 195
    UnmakeMove(tree, ply, wtm, tree->curmv[ply]);
#line 196
    if (abort_search) {
#line 196
      goto _L___2;
    } else
#line 196
    if (tree->stop) {
      _L___2: /* CIL Label */ 
#line 197
      return (0);
    }
#line 198
    if (value > alpha) {
#line 199
      if (value >= beta) {
#line 200
        return (value);
      }
#line 201
      alpha = value;
    }
    __Cont: /* CIL Label */ 
#line 172
    next___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 218
  if (checks) {
#line 219
    tree->last[ply] = GenerateChecks(tree, wtm, tree->last[ply - 1]);
#line 229
    next___0 = tree->last[ply - 1];
    {
#line 229
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 229
      if (! ((unsigned long )next___0 < (unsigned long )tree->last[ply])) {
#line 229
        goto while_break___2;
      }
#line 230
      tree->curmv[ply] = (int )(*next___0 & 2097151U);
#line 231
      tmp___7 = SEE(tree, wtm, tree->curmv[ply]);
#line 231
      if (tmp___7 >= 0) {
#line 237
        MakeMove(tree, ply, wtm, tree->curmv[ply]);
#line 238
        (tree->nodes_searched) ++;
#line 239
        tmp___6 = Attacks(tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 239
        if (! tmp___6) {
#line 240
          (tree->qchecks_done) ++;
#line 241
          tmp___5 = QuiesceEvasions(tree, ply + 1, wtm ^ 1, - beta, - alpha);
#line 241
          value = - tmp___5;
        }
#line 243
        UnmakeMove(tree, ply, wtm, tree->curmv[ply]);
#line 244
        if (abort_search) {
#line 244
          goto _L___3;
        } else
#line 244
        if (tree->stop) {
          _L___3: /* CIL Label */ 
#line 245
          return (0);
        }
#line 246
        if (value > alpha) {
#line 247
          if (value >= beta) {
#line 248
            return (value);
          }
#line 249
          alpha = value;
        }
      }
#line 229
      next___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 264
  if (alpha != original_alpha) {
#line 265
    tree->pv[ply - 1] = tree->pv[ply];
#line 266
    tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
  }
#line 268
  return (alpha);
}
}
#line 288 "quiesce.c"
int QuiesceEvasions(TREE *tree , int ply , int wtm , int alpha , int beta ) 
{ 
  int original_alpha ;
  int value ;
  int moves_searched ;
  int order ;
  int repeat ;
  int tmp ;

  {
#line 290
  moves_searched = 0;
#line 299
  if (ply >= 128) {
#line 300
    return (beta);
  }
#line 317
  repeat = Repeat(tree, ply);
#line 318
  if (repeat) {
#line 319
    value = draw_score[wtm];
#line 320
    if (value < beta) {
      {
#line 321
      while (1) {
        while_continue: /* CIL Label */ ;
#line 321
        tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
#line 321
        tree->pv[ply - 1].pathl = ply;
#line 321
        tree->pv[ply - 1].pathh = repeat;
#line 321
        tree->pv[ply - 1].pathd = iteration;
#line 321
        if (! 0) {
#line 321
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 326
    return (value);
  }
#line 328
  original_alpha = alpha;
#line 342
  tree->hash_move[ply] = 0;
#line 343
  tree->next_status[ply].phase = 2;
  {
#line 344
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 344
    order = NextMove(tree, ply, 0, wtm, 1);
#line 344
    if (! order) {
#line 344
      goto while_break___0;
    }
#line 350
    moves_searched ++;
#line 351
    MakeMove(tree, ply, wtm, tree->curmv[ply]);
#line 352
    (tree->nodes_searched) ++;
#line 353
    tmp = Quiesce(tree, ply + 1, wtm ^ 1, - beta, - alpha, 0);
#line 353
    value = - tmp;
#line 354
    UnmakeMove(tree, ply, wtm, tree->curmv[ply]);
#line 355
    if (abort_search) {
#line 355
      goto _L;
    } else
#line 355
    if (tree->stop) {
      _L: /* CIL Label */ 
#line 356
      return (0);
    }
#line 357
    if (value > alpha) {
#line 358
      if (value >= beta) {
#line 359
        return (value);
      }
#line 360
      alpha = value;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  if (moves_searched == 0) {
#line 373
    value = - (32768 - ply);
#line 374
    if (value >= alpha) {
#line 374
      if (value < beta) {
        {
#line 375
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 375
          tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
#line 375
          tree->pv[ply - 1].pathl = ply;
#line 375
          tree->pv[ply - 1].pathh = 0;
#line 375
          tree->pv[ply - 1].pathd = iteration;
#line 375
          if (! 0) {
#line 375
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 374
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 381
    return (value);
  } else
#line 382
  if (alpha != original_alpha) {
#line 383
    tree->pv[ply - 1] = tree->pv[ply];
#line 384
    tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
  }
#line 386
  return (alpha);
}
}
#line 10 "evaluate.h"
int const   pawn_can_promote  =    (int const   )525;
#line 11 "evaluate.h"
int const   pawn_file_width  =    (int const   )8;
#line 12 "evaluate.h"
int const   pawn_unsupported[2]  = {      (int const   )-8,      (int const   )-4};
#line 13 "evaluate.h"
int const   pawn_defects[2][8]  = { {        (int const   )0,        (int const   )0,        (int const   )0,        (int const   )1, 
            (int const   )2,        (int const   )3,        (int const   )0,        (int const   )0}, 
   {        (int const   )0,        (int const   )0,        (int const   )3,        (int const   )2, 
            (int const   )1,        (int const   )0,        (int const   )0,        (int const   )0}};
#line 17 "evaluate.h"
int const   passed_pawn[8]  = 
#line 17
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )2, 
        (int const   )6,      (int const   )12,      (int const   )21,      (int const   )0};
#line 18 "evaluate.h"
int const   passed_pawn_base[2]  = {      (int const   )4,      (int const   )8};
#line 19 "evaluate.h"
int const   passed_pawn_free_advance  =    (int const   )8;
#line 20 "evaluate.h"
int const   passed_pawn_free_advance_1  =    (int const   )5;
#line 21 "evaluate.h"
int const   passed_pawn_defended  =    (int const   )3;
#line 22 "evaluate.h"
int const   passed_pawn_defended_1  =    (int const   )2;
#line 23 "evaluate.h"
int const   passed_pawn_candidate[2][8]  = { {        (int const   )0,        (int const   )2,        (int const   )2,        (int const   )6, 
            (int const   )13,        (int const   )32,        (int const   )0,        (int const   )0}, 
   {        (int const   )0,        (int const   )5,        (int const   )5,        (int const   )11, 
            (int const   )27,        (int const   )65,        (int const   )0,        (int const   )0}};
#line 27 "evaluate.h"
int const   pawn_doubled[2][8]  = { {        (int const   )7,        (int const   )8,        (int const   )9,        (int const   )9, 
            (int const   )9,        (int const   )9,        (int const   )8,        (int const   )7}, 
   {        (int const   )22,        (int const   )19,        (int const   )19,        (int const   )19, 
            (int const   )19,        (int const   )19,        (int const   )19,        (int const   )22}};
#line 31 "evaluate.h"
int const   pawn_isolated[2][8]  = { {        (int const   )14,        (int const   )21,        (int const   )23,        (int const   )23, 
            (int const   )23,        (int const   )23,        (int const   )21,        (int const   )14}, 
   {        (int const   )5,        (int const   )7,        (int const   )8,        (int const   )8, 
            (int const   )8,        (int const   )8,        (int const   )7,        (int const   )5}};
#line 35 "evaluate.h"
int const   pawn_backward[2][8]  = { {        (int const   )8,        (int const   )12,        (int const   )14,        (int const   )14, 
            (int const   )14,        (int const   )14,        (int const   )12,        (int const   )8}, 
   {        (int const   )2,        (int const   )3,        (int const   )3,        (int const   )3, 
            (int const   )3,        (int const   )3,        (int const   )3,        (int const   )2}};
#line 39 "evaluate.h"
int const   pawn_connected[2][8][8]  = { { {          (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0}, 
     {          (int const   )0,          (int const   )1,          (int const   )1,          (int const   )2, 
                (int const   )2,          (int const   )1,          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )2,          (int const   )2,          (int const   )3, 
                (int const   )3,          (int const   )2,          (int const   )2,          (int const   )1}, 
     {          (int const   )3,          (int const   )5,          (int const   )6,          (int const   )10, 
                (int const   )10,          (int const   )6,          (int const   )5,          (int const   )3}, 
     {          (int const   )12,          (int const   )14,          (int const   )17,          (int const   )22, 
                (int const   )22,          (int const   )17,          (int const   )14,          (int const   )12}, 
     {          (int const   )27,          (int const   )29,          (int const   )31,          (int const   )35, 
                (int const   )35,          (int const   )31,          (int const   )29,          (int const   )27}, 
     {          (int const   )54,          (int const   )63,          (int const   )65,          (int const   )70, 
                (int const   )70,          (int const   )65,          (int const   )63,          (int const   )54}, 
     {          (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0}}, 
   { {          (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0}, 
     {          (int const   )1,          (int const   )3,          (int const   )3,          (int const   )3, 
                (int const   )3,          (int const   )3,          (int const   )1,          (int const   )1}, 
     {          (int const   )3,          (int const   )6,          (int const   )6,          (int const   )6, 
                (int const   )6,          (int const   )6,          (int const   )6,          (int const   )1}, 
     {          (int const   )6,          (int const   )10,          (int const   )10,          (int const   )10, 
                (int const   )10,          (int const   )10,          (int const   )10,          (int const   )3}, 
     {          (int const   )13,          (int const   )17,          (int const   )17,          (int const   )17, 
                (int const   )17,          (int const   )17,          (int const   )17,          (int const   )13}, 
     {          (int const   )32,          (int const   )38,          (int const   )38,          (int const   )38, 
                (int const   )38,          (int const   )38,          (int const   )38,          (int const   )32}, 
     {          (int const   )76,          (int const   )87,          (int const   )87,          (int const   )87, 
                (int const   )87,          (int const   )87,          (int const   )87,          (int const   )76}, 
     {          (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0}}};
#line 58 "evaluate.h"
int const   pval[2][64]  = { {        (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )-5,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )-5, 
            (int const   )-5,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )-5, 
            (int const   )-5,        (int const   )0,        (int const   )3,        (int const   )5, 
            (int const   )5,        (int const   )3,        (int const   )0,        (int const   )-5, 
            (int const   )-5,        (int const   )0,        (int const   )5,        (int const   )10, 
            (int const   )10,        (int const   )5,        (int const   )0,        (int const   )-5, 
            (int const   )-5,        (int const   )0,        (int const   )3,        (int const   )5, 
            (int const   )5,        (int const   )3,        (int const   )0,        (int const   )-5, 
            (int const   )-5,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )-5, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}, 
   {        (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )-5,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )-5, 
            (int const   )-5,        (int const   )0,        (int const   )3,        (int const   )5, 
            (int const   )5,        (int const   )3,        (int const   )0,        (int const   )-5, 
            (int const   )-5,        (int const   )0,        (int const   )5,        (int const   )10, 
            (int const   )10,        (int const   )5,        (int const   )0,        (int const   )-5, 
            (int const   )-5,        (int const   )0,        (int const   )3,        (int const   )5, 
            (int const   )5,        (int const   )3,        (int const   )0,        (int const   )-5, 
            (int const   )-5,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )-5, 
            (int const   )-5,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )-5, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}};
#line 84 "evaluate.h"
int const   king_tropism_n[8]  = 
#line 84
  {      (int const   )3,      (int const   )3,      (int const   )3,      (int const   )2, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )0};
#line 85 "evaluate.h"
int const   knight_outpost[2][64]  = { {        (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )1,        (int const   )4,        (int const   )4, 
            (int const   )4,        (int const   )4,        (int const   )1,        (int const   )0, 
            (int const   )0,        (int const   )2,        (int const   )6,        (int const   )8, 
            (int const   )8,        (int const   )6,        (int const   )2,        (int const   )0, 
            (int const   )0,        (int const   )1,        (int const   )4,        (int const   )4, 
            (int const   )4,        (int const   )4,        (int const   )1,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}, 
   {        (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )1,        (int const   )4,        (int const   )4, 
            (int const   )4,        (int const   )4,        (int const   )1,        (int const   )0, 
            (int const   )0,        (int const   )2,        (int const   )6,        (int const   )8, 
            (int const   )8,        (int const   )6,        (int const   )2,        (int const   )0, 
            (int const   )0,        (int const   )1,        (int const   )4,        (int const   )4, 
            (int const   )4,        (int const   )4,        (int const   )1,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}};
#line 104 "evaluate.h"
int const   nval[2][2][64]  = { { {          (int const   )-41,          (int const   )-29,          (int const   )-27,          (int const   )-15, 
                (int const   )-15,          (int const   )-27,          (int const   )-29,          (int const   )-41, 
                (int const   )-9,          (int const   )4,          (int const   )14,          (int const   )20, 
                (int const   )20,          (int const   )14,          (int const   )4,          (int const   )-9, 
                (int const   )-7,          (int const   )10,          (int const   )23,          (int const   )29, 
                (int const   )29,          (int const   )23,          (int const   )10,          (int const   )-7, 
                (int const   )-5,          (int const   )12,          (int const   )25,          (int const   )32, 
                (int const   )32,          (int const   )25,          (int const   )12,          (int const   )-5, 
                (int const   )-5,          (int const   )10,          (int const   )23,          (int const   )28, 
                (int const   )28,          (int const   )23,          (int const   )10,          (int const   )-5, 
                (int const   )-7,          (int const   )-2,          (int const   )19,          (int const   )19, 
                (int const   )19,          (int const   )19,          (int const   )-2,          (int const   )-7, 
                (int const   )-9,          (int const   )-6,          (int const   )-2,          (int const   )0, 
                (int const   )0,          (int const   )-2,          (int const   )-6,          (int const   )-9, 
                (int const   )-31,          (int const   )-29,          (int const   )-27,          (int const   )-25, 
                (int const   )-25,          (int const   )-27,          (int const   )-29,          (int const   )-31}, 
     {          (int const   )-31,          (int const   )-29,          (int const   )-27,          (int const   )-25, 
                (int const   )-25,          (int const   )-27,          (int const   )-29,          (int const   )-31, 
                (int const   )-9,          (int const   )-6,          (int const   )-2,          (int const   )0, 
                (int const   )0,          (int const   )-2,          (int const   )-6,          (int const   )-9, 
                (int const   )-7,          (int const   )-2,          (int const   )19,          (int const   )19, 
                (int const   )19,          (int const   )19,          (int const   )-2,          (int const   )-7, 
                (int const   )-5,          (int const   )10,          (int const   )23,          (int const   )28, 
                (int const   )28,          (int const   )23,          (int const   )10,          (int const   )-5, 
                (int const   )-5,          (int const   )12,          (int const   )25,          (int const   )32, 
                (int const   )32,          (int const   )25,          (int const   )12,          (int const   )-5, 
                (int const   )-7,          (int const   )10,          (int const   )23,          (int const   )29, 
                (int const   )29,          (int const   )23,          (int const   )10,          (int const   )-7, 
                (int const   )-9,          (int const   )4,          (int const   )14,          (int const   )20, 
                (int const   )20,          (int const   )14,          (int const   )4,          (int const   )-9, 
                (int const   )-41,          (int const   )-29,          (int const   )-27,          (int const   )-15, 
                (int const   )-15,          (int const   )-27,          (int const   )-29,          (int const   )-41}}, 
   { {          (int const   )-41,          (int const   )-29,          (int const   )-27,          (int const   )-15, 
                (int const   )-15,          (int const   )-27,          (int const   )-29,          (int const   )-41, 
                (int const   )-9,          (int const   )4,          (int const   )14,          (int const   )20, 
                (int const   )20,          (int const   )14,          (int const   )4,          (int const   )-9, 
                (int const   )-7,          (int const   )10,          (int const   )23,          (int const   )29, 
                (int const   )29,          (int const   )23,          (int const   )10,          (int const   )-7, 
                (int const   )-5,          (int const   )12,          (int const   )25,          (int const   )32, 
                (int const   )32,          (int const   )25,          (int const   )12,          (int const   )-5, 
                (int const   )-5,          (int const   )10,          (int const   )23,          (int const   )28, 
                (int const   )28,          (int const   )23,          (int const   )10,          (int const   )-5, 
                (int const   )-7,          (int const   )-2,          (int const   )19,          (int const   )19, 
                (int const   )19,          (int const   )19,          (int const   )-2,          (int const   )-7, 
                (int const   )-9,          (int const   )-6,          (int const   )-2,          (int const   )0, 
                (int const   )0,          (int const   )-2,          (int const   )-6,          (int const   )-9, 
                (int const   )-31,          (int const   )-29,          (int const   )-27,          (int const   )-25, 
                (int const   )-25,          (int const   )-27,          (int const   )-29,          (int const   )-31}, 
     {          (int const   )-31,          (int const   )-29,          (int const   )-27,          (int const   )-25, 
                (int const   )-25,          (int const   )-27,          (int const   )-29,          (int const   )-31, 
                (int const   )-9,          (int const   )-6,          (int const   )-2,          (int const   )0, 
                (int const   )0,          (int const   )-2,          (int const   )-6,          (int const   )-9, 
                (int const   )-7,          (int const   )-2,          (int const   )19,          (int const   )19, 
                (int const   )19,          (int const   )19,          (int const   )-2,          (int const   )-7, 
                (int const   )-5,          (int const   )10,          (int const   )23,          (int const   )28, 
                (int const   )28,          (int const   )23,          (int const   )10,          (int const   )-5, 
                (int const   )-5,          (int const   )12,          (int const   )25,          (int const   )32, 
                (int const   )32,          (int const   )25,          (int const   )12,          (int const   )-5, 
                (int const   )-7,          (int const   )10,          (int const   )23,          (int const   )29, 
                (int const   )29,          (int const   )23,          (int const   )10,          (int const   )-7, 
                (int const   )-9,          (int const   )4,          (int const   )14,          (int const   )20, 
                (int const   )20,          (int const   )14,          (int const   )4,          (int const   )-9, 
                (int const   )-41,          (int const   )-29,          (int const   )-27,          (int const   )-15, 
                (int const   )-15,          (int const   )-27,          (int const   )-29,          (int const   )-41}}};
#line 148 "evaluate.h"
int const   bishop_trapped  =    (int const   )174;
#line 149 "evaluate.h"
int const   bishop_pawns_on_color[2]  = {      (int const   )4,      (int const   )6};
#line 150 "evaluate.h"
int const   bishop_wing_pawns[2]  = {      (int const   )18,      (int const   )36};
#line 151 "evaluate.h"
int const   bishop_pair[2]  = {      (int const   )38,      (int const   )56};
#line 152 "evaluate.h"
int const   king_tropism_b[8]  = 
#line 152
  {      (int const   )2,      (int const   )2,      (int const   )2,      (int const   )1, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 153 "evaluate.h"
int const   bishop_outpost[2][64]  = { {        (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )1,        (int const   )3,        (int const   )3, 
            (int const   )3,        (int const   )3,        (int const   )1,        (int const   )0, 
            (int const   )0,        (int const   )3,        (int const   )5,        (int const   )5, 
            (int const   )5,        (int const   )5,        (int const   )3,        (int const   )0, 
            (int const   )0,        (int const   )1,        (int const   )2,        (int const   )2, 
            (int const   )2,        (int const   )2,        (int const   )1,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )1,        (int const   )1, 
            (int const   )1,        (int const   )1,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}, 
   {        (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )1,        (int const   )1, 
            (int const   )1,        (int const   )1,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )1,        (int const   )2,        (int const   )2, 
            (int const   )2,        (int const   )2,        (int const   )1,        (int const   )0, 
            (int const   )0,        (int const   )3,        (int const   )5,        (int const   )5, 
            (int const   )5,        (int const   )5,        (int const   )3,        (int const   )0, 
            (int const   )0,        (int const   )1,        (int const   )3,        (int const   )3, 
            (int const   )3,        (int const   )3,        (int const   )1,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}};
#line 172 "evaluate.h"
int const   bval[2][2][64]  = { { {          (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )8, 
                (int const   )8,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )12, 
                (int const   )12,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )12, 
                (int const   )12,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )8, 
                (int const   )8,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )-15,          (int const   )-15,          (int const   )-15,          (int const   )-15, 
                (int const   )-15,          (int const   )-15,          (int const   )-15,          (int const   )-15}, 
     {          (int const   )-15,          (int const   )-15,          (int const   )-15,          (int const   )-15, 
                (int const   )-15,          (int const   )-15,          (int const   )-15,          (int const   )-15, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )8, 
                (int const   )8,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )12, 
                (int const   )12,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )12, 
                (int const   )12,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )8, 
                (int const   )8,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0}}, 
   { {          (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )8, 
                (int const   )8,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )12, 
                (int const   )12,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )12, 
                (int const   )12,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )8, 
                (int const   )8,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )-15,          (int const   )-15,          (int const   )-15,          (int const   )-15, 
                (int const   )-15,          (int const   )-15,          (int const   )-15,          (int const   )-15}, 
     {          (int const   )-15,          (int const   )-15,          (int const   )-15,          (int const   )-15, 
                (int const   )-15,          (int const   )-15,          (int const   )-15,          (int const   )-15, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )8, 
                (int const   )8,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )12, 
                (int const   )12,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )12, 
                (int const   )12,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )8,          (int const   )8, 
                (int const   )8,          (int const   )8,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0}}};
#line 216 "evaluate.h"
int const   rook_on_7th[2]  = {      (int const   )25,      (int const   )35};
#line 217 "evaluate.h"
int const   rook_connected_7th[2]  = {      (int const   )6,      (int const   )10};
#line 218 "evaluate.h"
int const   rook_open_file[2]  = {      (int const   )35,      (int const   )20};
#line 219 "evaluate.h"
int const   rook_half_open_file[2]  = {      (int const   )10,      (int const   )10};
#line 220 "evaluate.h"
int const   king_tropism_r[8]  = 
#line 220
  {      (int const   )4,      (int const   )4,      (int const   )3,      (int const   )2, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1};
#line 228 "evaluate.h"
int const   king_tropism_q[8]  = 
#line 228
  {      (int const   )6,      (int const   )6,      (int const   )5,      (int const   )4, 
        (int const   )3,      (int const   )2,      (int const   )2,      (int const   )2};
#line 229 "evaluate.h"
int const   qval[2][2][64]  = { { {          (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )6, 
                (int const   )6,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )6,          (int const   )8, 
                (int const   )8,          (int const   )6,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )6,          (int const   )8, 
                (int const   )8,          (int const   )6,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )6, 
                (int const   )6,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0}, 
     {          (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )6, 
                (int const   )6,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )6,          (int const   )8, 
                (int const   )8,          (int const   )6,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )6,          (int const   )8, 
                (int const   )8,          (int const   )6,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )6, 
                (int const   )6,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0}}, 
   { {          (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )6, 
                (int const   )6,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )6,          (int const   )8, 
                (int const   )8,          (int const   )6,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )6,          (int const   )8, 
                (int const   )8,          (int const   )6,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )6, 
                (int const   )6,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0}, 
     {          (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )6, 
                (int const   )6,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )6,          (int const   )8, 
                (int const   )8,          (int const   )6,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )6,          (int const   )8, 
                (int const   )8,          (int const   )6,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )4,          (int const   )4,          (int const   )6, 
                (int const   )6,          (int const   )4,          (int const   )4,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )4,          (int const   )4, 
                (int const   )4,          (int const   )4,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0, 
                (int const   )0,          (int const   )0,          (int const   )0,          (int const   )0}}};
#line 273 "evaluate.h"
int king_safety[16][16]  ;
#line 274 "evaluate.h"
int const   king_safety_mate_threat  =    (int const   )600;
#line 275 "evaluate.h"
int const   king_king_tropism  =    (int const   )10;
#line 276 "evaluate.h"
int const   open_file[8]  = 
#line 276
  {      (int const   )6,      (int const   )5,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )5,      (int const   )6};
#line 277 "evaluate.h"
int const   half_open_file[8]  = 
#line 277
  {      (int const   )4,      (int const   )4,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )4,      (int const   )4};
#line 278 "evaluate.h"
int const   safety_vector[16]  = 
#line 278
  {      (int const   )0,      (int const   )7,      (int const   )14,      (int const   )21, 
        (int const   )28,      (int const   )35,      (int const   )42,      (int const   )49, 
        (int const   )56,      (int const   )63,      (int const   )70,      (int const   )77, 
        (int const   )84,      (int const   )91,      (int const   )98,      (int const   )105};
#line 282 "evaluate.h"
int const   tropism_vector[16]  = 
#line 282
  {      (int const   )0,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )5,      (int const   )11,      (int const   )20, 
        (int const   )32,      (int const   )47,      (int const   )65,      (int const   )86, 
        (int const   )110,      (int const   )137,      (int const   )167,      (int const   )200};
#line 286 "evaluate.h"
int const   kval[2][64]  = { {        (int const   )-40,        (int const   )-40,        (int const   )-40,        (int const   )-40, 
            (int const   )-40,        (int const   )-40,        (int const   )-40,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )-10,        (int const   )-10, 
            (int const   )-10,        (int const   )-10,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )60,        (int const   )60, 
            (int const   )60,        (int const   )60,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )60,        (int const   )60, 
            (int const   )60,        (int const   )60,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )40,        (int const   )40, 
            (int const   )40,        (int const   )40,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )20,        (int const   )20, 
            (int const   )20,        (int const   )20,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )-10,        (int const   )-10, 
            (int const   )-10,        (int const   )-10,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-40,        (int const   )-40,        (int const   )-40, 
            (int const   )-40,        (int const   )-40,        (int const   )-40,        (int const   )-40}, 
   {        (int const   )-40,        (int const   )-40,        (int const   )-40,        (int const   )-40, 
            (int const   )-40,        (int const   )-40,        (int const   )-40,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )-10,        (int const   )-10, 
            (int const   )-10,        (int const   )-10,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )20,        (int const   )20, 
            (int const   )20,        (int const   )20,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )40,        (int const   )40, 
            (int const   )40,        (int const   )40,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )60,        (int const   )60, 
            (int const   )60,        (int const   )60,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )60,        (int const   )60, 
            (int const   )60,        (int const   )60,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-10,        (int const   )-10,        (int const   )-10, 
            (int const   )-10,        (int const   )-10,        (int const   )-10,        (int const   )-40, 
            (int const   )-40,        (int const   )-40,        (int const   )-40,        (int const   )-40, 
            (int const   )-40,        (int const   )-40,        (int const   )-40,        (int const   )-40}};
#line 312 "evaluate.h"
int const   bad_trade  =    (int const   )90;
#line 313 "evaluate.h"
int const   dark_corner[2]  = {      (int const   )0,      (int const   )7};
#line 314 "evaluate.h"
int const   light_corner[2]  = {      (int const   )7,      (int const   )0};
#line 315 "evaluate.h"
int const   direction[2]  = {      (int const   )-8,      (int const   )8};
#line 316 "evaluate.h"
char const   square_color[64]  = 
#line 316
  {      (char const   )1,      (char const   )0,      (char const   )1,      (char const   )0, 
        (char const   )1,      (char const   )0,      (char const   )1,      (char const   )0, 
        (char const   )0,      (char const   )1,      (char const   )0,      (char const   )1, 
        (char const   )0,      (char const   )1,      (char const   )0,      (char const   )1, 
        (char const   )1,      (char const   )0,      (char const   )1,      (char const   )0, 
        (char const   )1,      (char const   )0,      (char const   )1,      (char const   )0, 
        (char const   )0,      (char const   )1,      (char const   )0,      (char const   )1, 
        (char const   )0,      (char const   )1,      (char const   )0,      (char const   )1, 
        (char const   )1,      (char const   )0,      (char const   )1,      (char const   )0, 
        (char const   )1,      (char const   )0,      (char const   )1,      (char const   )0, 
        (char const   )0,      (char const   )1,      (char const   )0,      (char const   )1, 
        (char const   )0,      (char const   )1,      (char const   )0,      (char const   )1, 
        (char const   )1,      (char const   )0,      (char const   )1,      (char const   )0, 
        (char const   )1,      (char const   )0,      (char const   )1,      (char const   )0, 
        (char const   )0,      (char const   )1,      (char const   )0,      (char const   )1, 
        (char const   )0,      (char const   )1,      (char const   )0,      (char const   )1};
#line 333 "evaluate.h"
int const   development_thematic  =    (int const   )12;
#line 334 "evaluate.h"
int const   development_losing_castle  =    (int const   )20;
#line 335 "evaluate.h"
int const   development_not_castled  =    (int const   )20;
#line 336 "evaluate.h"
int const   wtm_bonus[2]  = {      (int const   )5,      (int const   )8};
#line 344 "evaluate.h"
uint64_t burner[10]  = 
#line 344
  {      (uint64_t )1,      (uint64_t )2,      (uint64_t )3,      (uint64_t )4, 
        (uint64_t )5,      (uint64_t )6,      (uint64_t )7,      (uint64_t )8, 
        (uint64_t )9,      (uint64_t )10};
#line 345 "evaluate.h"
int const   burnc[10]  = 
#line 345
  {      (int const   )128000,      (int const   )64000,      (int const   )32400,      (int const   )15200, 
        (int const   )7600,      (int const   )3800,      (int const   )1960,      (int const   )1040, 
        (int const   )480,      (int const   )140};
#line 357 "evaluate.h"
char const   b_n_mate_dark_squares[64]  = 
#line 357
  {      (char const   )99,      (char const   )90,      (char const   )80,      (char const   )70, 
        (char const   )60,      (char const   )50,      (char const   )40,      (char const   )30, 
        (char const   )90,      (char const   )80,      (char const   )70,      (char const   )60, 
        (char const   )50,      (char const   )40,      (char const   )30,      (char const   )40, 
        (char const   )80,      (char const   )70,      (char const   )60,      (char const   )50, 
        (char const   )40,      (char const   )30,      (char const   )40,      (char const   )50, 
        (char const   )70,      (char const   )60,      (char const   )50,      (char const   )40, 
        (char const   )30,      (char const   )40,      (char const   )50,      (char const   )60, 
        (char const   )60,      (char const   )50,      (char const   )40,      (char const   )30, 
        (char const   )40,      (char const   )50,      (char const   )60,      (char const   )70, 
        (char const   )50,      (char const   )40,      (char const   )30,      (char const   )40, 
        (char const   )50,      (char const   )60,      (char const   )70,      (char const   )80, 
        (char const   )40,      (char const   )30,      (char const   )40,      (char const   )50, 
        (char const   )60,      (char const   )70,      (char const   )80,      (char const   )90, 
        (char const   )30,      (char const   )40,      (char const   )50,      (char const   )60, 
        (char const   )70,      (char const   )80,      (char const   )90,      (char const   )99};
#line 367 "evaluate.h"
char const   b_n_mate_light_squares[64]  = 
#line 367
  {      (char const   )30,      (char const   )40,      (char const   )50,      (char const   )60, 
        (char const   )70,      (char const   )80,      (char const   )90,      (char const   )99, 
        (char const   )40,      (char const   )30,      (char const   )40,      (char const   )50, 
        (char const   )60,      (char const   )70,      (char const   )80,      (char const   )90, 
        (char const   )50,      (char const   )40,      (char const   )30,      (char const   )40, 
        (char const   )50,      (char const   )60,      (char const   )70,      (char const   )80, 
        (char const   )60,      (char const   )50,      (char const   )40,      (char const   )30, 
        (char const   )40,      (char const   )50,      (char const   )60,      (char const   )70, 
        (char const   )70,      (char const   )60,      (char const   )50,      (char const   )40, 
        (char const   )30,      (char const   )40,      (char const   )50,      (char const   )60, 
        (char const   )80,      (char const   )70,      (char const   )60,      (char const   )50, 
        (char const   )40,      (char const   )30,      (char const   )40,      (char const   )50, 
        (char const   )90,      (char const   )80,      (char const   )70,      (char const   )60, 
        (char const   )50,      (char const   )40,      (char const   )30,      (char const   )40, 
        (char const   )99,      (char const   )90,      (char const   )80,      (char const   )70, 
        (char const   )60,      (char const   )50,      (char const   )40,      (char const   )30};
#line 377 "evaluate.h"
int const   mate[64]  = 
#line 377
  {      (int const   )200,      (int const   )180,      (int const   )160,      (int const   )140, 
        (int const   )140,      (int const   )160,      (int const   )180,      (int const   )200, 
        (int const   )180,      (int const   )160,      (int const   )140,      (int const   )120, 
        (int const   )120,      (int const   )140,      (int const   )160,      (int const   )180, 
        (int const   )160,      (int const   )140,      (int const   )120,      (int const   )100, 
        (int const   )100,      (int const   )120,      (int const   )140,      (int const   )160, 
        (int const   )140,      (int const   )120,      (int const   )100,      (int const   )100, 
        (int const   )100,      (int const   )100,      (int const   )120,      (int const   )140, 
        (int const   )140,      (int const   )120,      (int const   )100,      (int const   )100, 
        (int const   )100,      (int const   )100,      (int const   )120,      (int const   )140, 
        (int const   )160,      (int const   )140,      (int const   )120,      (int const   )100, 
        (int const   )100,      (int const   )120,      (int const   )140,      (int const   )160, 
        (int const   )180,      (int const   )160,      (int const   )140,      (int const   )120, 
        (int const   )120,      (int const   )140,      (int const   )160,      (int const   )180, 
        (int const   )200,      (int const   )180,      (int const   )160,      (int const   )140, 
        (int const   )140,      (int const   )160,      (int const   )180,      (int const   )200};
#line 19 "evaluate.c"
int Evaluate(TREE *tree , int ply , int wtm , int alpha , int beta ) 
{ 
  PAWN_HASH_ENTRY *ptable ;
  PXOR *pxtable ;
  int score ;
  int side ;
  int can_win ;
  int phase ;
  int lscore ;
  int cutoff ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int w_mat ;
  int b_mat ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 22
  can_win = 3;
#line 56
  if (tree->position.pieces[1][0]) {
#line 56
    if (tree->position.pieces[0][0]) {
#line 56
      cutoff = 305;
    } else {
#line 56
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 56
    cutoff = 490;
  }
#line 58
  if (wtm) {
#line 58
    lscore = tree->position.material_evaluation;
  } else {
#line 58
    lscore = - tree->position.material_evaluation;
  }
#line 59
  if (lscore + cutoff < alpha) {
#line 60
    return (alpha);
  }
#line 61
  if (lscore - cutoff > beta) {
#line 62
    return (beta);
  }
#line 86
  (tree->evaluations) ++;
#line 87
  tree->score_mg = 0;
#line 88
  tree->score_eg = 0;
#line 89
  EvaluateMaterial(tree, wtm);
#line 90
  if ((int )tree->position.pieces[1][0] < 13) {
#line 90
    if ((int )tree->position.pieces[0][0] < 13) {
#line 91
      side = 0;
      {
#line 91
      while (1) {
        while_continue: /* CIL Label */ ;
#line 91
        if (! (side <= 1)) {
#line 91
          goto while_break;
        }
#line 92
        tmp = EvaluateWinningChances(tree, side, wtm);
#line 92
        if (! tmp) {
#line 93
          can_win ^= 1 << side;
        }
#line 91
        side ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 90
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 112
  tree->all_pawns = tree->position.color[0].pieces[1] | tree->position.color[1].pieces[1];
#line 113
  if (! tree->all_pawns) {
#line 114
    if ((int )tree->position.pieces[1][0] > 3) {
#line 114
      goto _L___3;
    } else
#line 114
    if ((int )tree->position.pieces[0][0] > 3) {
      _L___3: /* CIL Label */ 
#line 115
      if (tree->position.material_evaluation > 0) {
#line 116
        EvaluateMate(tree, 1);
      } else
#line 117
      if (tree->position.material_evaluation < 0) {
#line 118
        EvaluateMate(tree, 0);
      }
#line 119
      if (tree->score_eg > draw_score[1]) {
#line 119
        if (! (can_win & 2)) {
#line 120
          tree->score_eg /= 16;
        } else {
#line 119
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ ;
      }
#line 121
      if (tree->score_eg < draw_score[1]) {
#line 121
        if (! (can_win & 1)) {
#line 122
          tree->score_eg /= 16;
        } else {
#line 121
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ ;
      }
#line 130
      if (wtm) {
#line 130
        tmp___0 = tree->score_eg;
      } else {
#line 130
        tmp___0 = - tree->score_eg;
      }
#line 130
      return (tmp___0);
    }
  } else {
#line 156
    if (tree->position.pawn_hash_key == tree->pawn_score.key) {
#line 157
      tree->score_mg += tree->pawn_score.score_mg;
#line 158
      tree->score_eg += tree->pawn_score.score_eg;
    } else {
#line 170
      ptable = pawn_hash_table + (tree->position.pawn_hash_key & pawn_hash_mask);
#line 171
      pxtable = (PXOR *)(& tree->pawn_score);
#line 172
      tree->pawn_score = *ptable;
#line 173
      tree->pawn_score.key ^= pxtable->entry[1] ^ pxtable->entry[2];
#line 174
      if (tree->pawn_score.key != tree->position.pawn_hash_key) {
#line 175
        tree->pawn_score.key = tree->position.pawn_hash_key;
#line 176
        tree->pawn_score.score_mg = 0;
#line 177
        tree->pawn_score.score_eg = 0;
#line 178
        side = 0;
        {
#line 178
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 178
          if (! (side <= 1)) {
#line 178
            goto while_break___0;
          }
#line 179
          EvaluatePawns(tree, side);
#line 178
          side ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 180
        ptable->key = (pxtable->entry[0] ^ pxtable->entry[1]) ^ pxtable->entry[2];
#line 182
        memcpy((void *)((char *)ptable + 8), (void const   *)((char *)(& tree->pawn_score) + 8),
               sizeof(PAWN_HASH_ENTRY ) - 8UL);
      }
#line 185
      tree->score_mg += tree->pawn_score.score_mg;
#line 186
      tree->score_eg += tree->pawn_score.score_eg;
    }
#line 199
    if (tree->pawn_score.passed[0]) {
#line 199
      goto _L___7;
    } else
#line 199
    if (tree->pawn_score.passed[1]) {
      _L___7: /* CIL Label */ 
#line 200
      side = 0;
      {
#line 200
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 200
        if (! (side <= 1)) {
#line 200
          goto while_break___1;
        }
#line 201
        if (tree->pawn_score.passed[side]) {
#line 202
          EvaluatePassedPawns(tree, side, wtm);
        }
#line 200
        side ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 203
      if ((int )tree->position.pieces[1][0] == 0) {
#line 203
        if (tree->pawn_score.passed[0]) {
#line 203
          goto _L___4;
        } else {
#line 203
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 203
      if ((int )tree->position.pieces[0][0] == 0) {
#line 203
        if (tree->pawn_score.passed[1]) {
          _L___4: /* CIL Label */ 
#line 207
          EvaluatePassedPawnRaces(tree, wtm);
        } else {
#line 203
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ ;
      }
    }
  }
#line 219
  side = 0;
  {
#line 219
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 219
    if (! (side <= 1)) {
#line 219
      goto while_break___2;
    }
#line 220
    if ((int )tree->status[1].castle[side] > 0) {
#line 221
      EvaluateCastling(tree, ply, side);
    }
#line 219
    side ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 232
  if (tree->position.color[1].pieces[5]) {
#line 232
    if ((int )tree->position.pieces[1][0] > 9) {
#line 232
      goto _L___8;
    } else {
#line 232
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 232
  if ((int )tree->position.pieces[1][4] > 1) {
#line 232
    if ((int )tree->position.pieces[1][0] > 15) {
      _L___8: /* CIL Label */ 
#line 232
      tmp___1 = 1;
    } else {
#line 232
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ 
#line 232
    tmp___1 = 0;
  }
#line 232
  tree->dangerous[1] = tmp___1;
#line 234
  if (tree->position.color[0].pieces[5]) {
#line 234
    if ((int )tree->position.pieces[0][0] > 9) {
#line 234
      goto _L___11;
    } else {
#line 234
      goto _L___13;
    }
  } else
  _L___13: /* CIL Label */ 
#line 234
  if ((int )tree->position.pieces[0][4] > 1) {
#line 234
    if ((int )tree->position.pieces[0][0] > 15) {
      _L___11: /* CIL Label */ 
#line 234
      tmp___2 = 1;
    } else {
#line 234
      goto _L___12;
    }
  } else {
    _L___12: /* CIL Label */ 
#line 234
    tmp___2 = 0;
  }
#line 234
  tree->dangerous[0] = tmp___2;
#line 248
  if (62 < (int )tree->position.pieces[1][0] + (int )tree->position.pieces[0][0]) {
#line 248
    phase = 62;
  } else {
#line 248
    phase = (int )tree->position.pieces[1][0] + (int )tree->position.pieces[0][0];
  }
#line 250
  score = (tree->score_mg * phase + tree->score_eg * (62 - phase)) / 62;
#line 251
  if (wtm) {
#line 251
    lscore = score;
  } else {
#line 251
    lscore = - score;
  }
#line 252
  w_mat = (2 * (int )tree->position.pieces[1][4] + (int )tree->position.pieces[1][2]) + (int )tree->position.pieces[1][3];
#line 254
  b_mat = (2 * (int )tree->position.pieces[0][4] + (int )tree->position.pieces[0][2]) + (int )tree->position.pieces[0][3];
#line 256
  tmp___3 = abs(w_mat - b_mat);
#line 256
  cutoff = (72 + (w_mat + b_mat) * 8) + tmp___3 * 16;
#line 257
  if (tree->dangerous[1]) {
#line 257
    goto _L___14;
  } else
#line 257
  if (tree->dangerous[0]) {
    _L___14: /* CIL Label */ 
#line 258
    cutoff += 35;
  }
#line 274
  if (lscore + cutoff > alpha) {
#line 274
    if (lscore - cutoff < beta) {
#line 275
      tree->tropism[1] = 0;
#line 276
      tree->tropism[0] = 0;
#line 277
      side = 0;
      {
#line 277
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 277
        if (! (side <= 1)) {
#line 277
          goto while_break___3;
        }
#line 278
        if (tree->position.color[side].pieces[2]) {
#line 279
          EvaluateKnights(tree, side);
        }
#line 277
        side ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 280
      side = 0;
      {
#line 280
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 280
        if (! (side <= 1)) {
#line 280
          goto while_break___4;
        }
#line 281
        if (tree->position.color[side].pieces[3]) {
#line 282
          EvaluateBishops(tree, side);
        }
#line 280
        side ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 283
      side = 0;
      {
#line 283
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 283
        if (! (side <= 1)) {
#line 283
          goto while_break___5;
        }
#line 284
        if (tree->position.color[side].pieces[4]) {
#line 285
          EvaluateRooks(tree, side);
        }
#line 283
        side ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 286
      side = 0;
      {
#line 286
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 286
        if (! (side <= 1)) {
#line 286
          goto while_break___6;
        }
#line 287
        if (tree->position.color[side].pieces[5]) {
#line 288
          EvaluateQueens(tree, side);
        }
#line 286
        side ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 289
      side = 0;
      {
#line 289
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 289
        if (! (side <= 1)) {
#line 289
          goto while_break___7;
        }
#line 290
        EvaluateKing(tree, ply, side);
#line 289
        side ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    } else {
#line 274
      goto _L___15;
    }
  } else {
    _L___15: /* CIL Label */ ;
  }
#line 304
  score = (tree->score_mg * phase + tree->score_eg * (62 - phase)) / 62;
#line 305
  score = EvaluateDraws(tree, ply, can_win, score);
#line 313
  if (wtm) {
#line 313
    tmp___4 = score;
  } else {
#line 313
    tmp___4 = - score;
  }
#line 313
  return (tmp___4);
}
}
#line 324 "evaluate.c"
void EvaluateBishops(TREE *tree , int side ) 
{ 
  uint64_t temp ;
  uint64_t moves ;
  int square ;
  int special ;
  int i ;
  int mobility ;
  int score_eg ;
  int score_mg ;
  int enemy ;
  int tpawns ;
  uint64_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 327
  score_eg = 0;
#line 327
  score_mg = 0;
#line 327
  enemy = side ^ 1;
#line 336
  temp = tree->position.color[side].pieces[3];
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! temp) {
#line 336
      goto while_break;
    }
#line 337
    square = __builtin_ctzll((unsigned long long )temp);
#line 338
    score_mg += (int )bval[0][side][square];
#line 339
    score_eg += (int )bval[1][side][square];
#line 352
    special = (int )bishop_outpost[side][square];
#line 353
    if (special) {
#line 354
      if (! (mask_pattacks[enemy][square] & tree->position.color[enemy].pieces[1])) {
#line 355
        if (pawn_attacks[enemy][square] & tree->position.color[side].pieces[1]) {
#line 356
          special += special / 2;
#line 357
          if (! tree->position.color[enemy].pieces[2]) {
#line 357
            if (square_color[square]) {
#line 357
              tmp = dark_squares;
            } else {
#line 357
              tmp = ~ dark_squares;
            }
#line 357
            if (tmp & (unsigned long const   )tree->position.color[enemy].pieces[3]) {
#line 357
              goto _L;
            } else {
#line 358
              special += (int )bishop_outpost[side][square];
            }
          } else {
            _L: /* CIL Label */ ;
          }
        }
#line 360
        score_eg += special;
#line 361
        score_mg += special;
      }
    }
#line 374
    if ((int )tree->position.pieces[side][3] == 1) {
#line 375
      if (dark_squares & (unsigned long const   )set_mask[square]) {
#line 376
        tpawns = __builtin_popcountll((unsigned long long )(dark_squares & (unsigned long const   )tree->position.color[side].pieces[1]));
      } else {
#line 378
        tpawns = __builtin_popcountll((unsigned long long )(~ dark_squares & (unsigned long const   )tree->position.color[side].pieces[1]));
      }
#line 379
      score_mg -= tpawns * (int )bishop_pawns_on_color[0];
#line 380
      score_eg -= tpawns * (int )bishop_pawns_on_color[1];
    }
#line 391
    mobility = (int )*(magic_bishop_mobility_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[square]) * (unsigned long )magic_bishop[square] >> magic_bishop_shift[square]));
#line 392
    if (mobility < 0) {
#line 392
      if (pawn_attacks[enemy][square] & tree->position.color[side].pieces[1]) {
#line 392
        if ((square & 7) == 0) {
#line 392
          goto _L___1;
        } else
#line 392
        if ((square & 7) == 7) {
          _L___1: /* CIL Label */ 
#line 394
          mobility -= 8;
        } else {
#line 392
          goto _L___2;
        }
      } else {
#line 392
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___0: /* CIL Label */ ;
    }
#line 395
    score_mg += mobility;
#line 396
    score_eg += mobility;
#line 404
    if (tree->dangerous[side]) {
#line 405
      moves = king_attacks[tree->position.kingsq[enemy]];
#line 406
      if (bishop_attacks[square] & moves) {
#line 406
        if (*(magic_bishop_indices[square] + ((((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & ~ tree->position.color[side].pieces[5]) & (unsigned long )magic_bishop_mask[square]) * (unsigned long )magic_bishop[square] >> magic_bishop_shift[square])) & moves) {
#line 406
          i = 1;
        } else {
#line 406
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 406
        tmp___5 = abs((square & 7) - (tree->position.kingsq[enemy] & 7));
#line 406
        tmp___6 = abs((square >> 3) - (tree->position.kingsq[enemy] >> 3));
#line 406
        if (tmp___5 > tmp___6) {
#line 406
          tmp___2 = abs((square & 7) - (tree->position.kingsq[enemy] & 7));
#line 406
          tmp___4 = tmp___2;
        } else {
#line 406
          tmp___3 = abs((square >> 3) - (tree->position.kingsq[enemy] >> 3));
#line 406
          tmp___4 = tmp___3;
        }
#line 406
        i = tmp___4;
      }
#line 409
      tree->tropism[side] += (int )king_tropism_b[i];
    }
#line 336
    temp &= temp - 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  if ((int )tree->position.pieces[side][3] > 1) {
#line 421
    score_mg += (int )bishop_pair[0];
#line 422
    score_eg += (int )bishop_pair[1];
  } else
#line 433
  if (tree->all_pawns & (unsigned long )mask_fgh) {
#line 433
    if (tree->all_pawns & (unsigned long )mask_abc) {
#line 434
      score_mg += (int )bishop_wing_pawns[0];
#line 435
      score_eg += (int )bishop_wing_pawns[1];
    } else {
#line 433
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ ;
  }
#line 438
  tree->score_mg += (int )(sign[side] * (int const   )score_mg);
#line 439
  tree->score_eg += (int )(sign[side] * (int const   )score_eg);
#line 440
  return;
}
}
#line 453 "evaluate.c"
void EvaluateCastling(TREE *tree , int ply , int side ) 
{ 
  int enemy ;
  int oq ;
  int score_mg ;

  {
#line 454
  enemy = side ^ 1;
#line 454
  score_mg = 0;
#line 471
  if (tree->position.color[enemy].pieces[5]) {
#line 471
    oq = 3;
  } else {
#line 471
    oq = 1;
  }
#line 472
  if ((int )tree->status[ply].castle[side] != (int )tree->status[1].castle[side]) {
#line 473
    if ((int )tree->status[ply].castle[side] == 0) {
#line 474
      score_mg -= oq * (int )development_losing_castle;
    } else
#line 475
    if ((int )tree->status[ply].castle[side] > 0) {
#line 476
      score_mg -= (oq * (int )development_losing_castle) / 2;
    }
  } else {
#line 478
    score_mg -= oq * (int )development_not_castled;
  }
#line 479
  tree->score_mg += (int )(sign[side] * (int const   )score_mg);
#line 480
  return;
}
}
#line 493 "evaluate.c"
int EvaluateDraws(TREE *tree , int ply , int can_win , int score ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int closeness ;

  {
#line 524
  if ((int )tree->position.pieces[1][0] <= 8) {
#line 524
    if ((int )tree->position.pieces[0][0] <= 8) {
#line 525
      if ((int )tree->position.pieces[1][3] == 1) {
#line 525
        if ((int )tree->position.pieces[0][3] == 1) {
#line 526
          tmp___0 = __builtin_ctzll((unsigned long long )tree->position.color[0].pieces[3]);
#line 526
          tmp___1 = __builtin_ctzll((unsigned long long )tree->position.color[1].pieces[3]);
#line 526
          if ((int const   )square_color[tmp___0] != (int const   )square_color[tmp___1]) {
#line 528
            if ((int )tree->position.pieces[1][0] == 3) {
#line 528
              if ((int )tree->position.pieces[0][0] == 3) {
#line 528
                if ((int )tree->position.pieces[1][1] < 4) {
#line 528
                  if ((int )tree->position.pieces[0][1] < 4) {
#line 528
                    goto _L___0;
                  } else {
#line 528
                    goto _L___1;
                  }
                } else {
                  _L___1: /* CIL Label */ 
#line 528
                  if ((int )tree->position.pieces[1][1] - (int )tree->position.pieces[0][1] > 0) {
#line 528
                    tmp = (int )tree->position.pieces[1][1] - (int )tree->position.pieces[0][1];
                  } else {
#line 528
                    tmp = - ((int )tree->position.pieces[1][1] - (int )tree->position.pieces[0][1]);
                  }
#line 528
                  if (tmp < 2) {
                    _L___0: /* CIL Label */ 
#line 533
                    score = score / 2 + draw_score[1];
                  } else {
#line 528
                    goto _L___2;
                  }
                }
              } else {
#line 528
                goto _L___2;
              }
            } else
            _L___2: /* CIL Label */ 
            _L: /* CIL Label */ 
#line 534
            if ((int )tree->position.pieces[1][0] == (int )tree->position.pieces[0][0]) {
#line 535
              score = (3 * score) / 4 + draw_score[1];
            }
          }
        } else {
#line 525
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ ;
      }
    } else {
#line 524
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ ;
  }
#line 550
  if (can_win != 3) {
#line 551
    if (can_win & 1) {
#line 552
      if (score > draw_score[1]) {
#line 553
        score = score / 16 + draw_score[1];
      }
    } else
#line 554
    if (can_win & 2) {
#line 555
      if (score < draw_score[1]) {
#line 556
        score = score / 16 + draw_score[1];
      }
    } else {
#line 558
      score = draw_score[1];
    }
  }
#line 574
  if ((int )tree->status[ply].reversible > 80) {
#line 575
    closeness = 101 - (int )tree->status[ply].reversible;
#line 577
    score = draw_score[1] + (score * closeness) / 20;
  }
#line 579
  return (score);
}
}
#line 593 "evaluate.c"
int EvaluateHasOpposition(int on_move , int king___0 , int enemy_king ) 
{ 
  int file_distance ;
  int rank_distance ;

  {
#line 596
  file_distance = abs((king___0 & 7) - (enemy_king & 7));
#line 597
  rank_distance = abs((king___0 >> 3) - (enemy_king >> 3));
#line 598
  if (rank_distance < 2) {
#line 599
    return (1);
  }
#line 600
  if (on_move) {
#line 601
    if (rank_distance & 1) {
#line 602
      rank_distance --;
    }
#line 603
    if (file_distance & 1) {
#line 604
      file_distance --;
    }
  }
#line 606
  if (! (file_distance & 1)) {
#line 606
    if (! (rank_distance & 1)) {
#line 607
      return (1);
    } else {
#line 606
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 608
  return (0);
}
}
#line 619 "evaluate.c"
void EvaluateKing(TREE *tree , int ply , int side ) 
{ 
  int score_eg ;
  int score_mg ;
  int defects ;
  int ksq ;
  int enemy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 620
  score_eg = 0;
#line 620
  score_mg = 0;
#line 621
  ksq = tree->position.kingsq[side];
#line 621
  enemy = side ^ 1;
#line 632
  score_eg += (int )kval[side][ksq];
#line 642
  if (tree->dangerous[enemy]) {
#line 643
    defects = 0;
#line 644
    if ((int )tree->status[ply].castle[side] <= 0) {
#line 645
      if ((ksq & 7) > 4) {
#line 646
        defects = (int )tree->pawn_score.defects_k[side];
      } else
#line 647
      if ((ksq & 7) < 3) {
#line 648
        defects = (int )tree->pawn_score.defects_q[side];
      } else {
#line 650
        defects = (int )tree->pawn_score.defects_m[side];
      }
    } else {
#line 652
      if ((int )tree->status[ply].castle[side] == 3) {
#line 653
        if ((int )tree->pawn_score.defects_k[side] < (int )tree->pawn_score.defects_m[side]) {
#line 653
          tmp___1 = (int )tree->pawn_score.defects_k[side];
        } else {
#line 653
          tmp___1 = (int )tree->pawn_score.defects_m[side];
        }
#line 653
        if (tmp___1 < (int )tree->pawn_score.defects_q[side]) {
#line 653
          if ((int )tree->pawn_score.defects_k[side] < (int )tree->pawn_score.defects_m[side]) {
#line 653
            tmp___0 = (int )tree->pawn_score.defects_k[side];
          } else {
#line 653
            tmp___0 = (int )tree->pawn_score.defects_m[side];
          }
#line 653
          defects = tmp___0;
        } else {
#line 653
          defects = (int )tree->pawn_score.defects_q[side];
        }
      } else
#line 657
      if ((int )tree->status[ply].castle[side] == 1) {
#line 658
        if ((int )tree->pawn_score.defects_k[side] < (int )tree->pawn_score.defects_m[side]) {
#line 658
          defects = (int )tree->pawn_score.defects_k[side];
        } else {
#line 658
          defects = (int )tree->pawn_score.defects_m[side];
        }
      } else
#line 662
      if ((int )tree->pawn_score.defects_q[side] < (int )tree->pawn_score.defects_m[side]) {
#line 662
        defects = (int )tree->pawn_score.defects_q[side];
      } else {
#line 662
        defects = (int )tree->pawn_score.defects_m[side];
      }
#line 665
      if (defects < 3) {
#line 666
        defects = 3;
      }
    }
#line 676
    if (tree->tropism[enemy] < 0) {
#line 677
      tree->tropism[enemy] = 0;
    } else
#line 678
    if (tree->tropism[enemy] > 15) {
#line 679
      tree->tropism[enemy] = 15;
    }
#line 680
    if (defects > 15) {
#line 681
      defects = 15;
    }
#line 682
    score_mg -= king_safety[defects][tree->tropism[enemy]];
  }
#line 684
  tree->score_mg += (int )(sign[side] * (int const   )score_mg);
#line 685
  tree->score_eg += (int )(sign[side] * (int const   )score_eg);
#line 686
  return;
}
}
#line 698 "evaluate.c"
int EvaluateKingsFile(TREE *tree , int side , int first , int last ) 
{ 
  int defects ;
  int file ;
  int enemy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 699
  defects = 0;
#line 699
  enemy = side ^ 1;
#line 701
  file = first;
  {
#line 701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 701
    if (! (file <= last)) {
#line 701
      goto while_break;
    }
#line 702
    if (! (file_mask[file] & tree->all_pawns)) {
#line 703
      defects += (int )open_file[file];
    } else {
#line 705
      if (! (file_mask[file] & tree->position.color[enemy].pieces[1])) {
#line 706
        defects += (int )(half_open_file[file] / 2);
      } else {
#line 708
        if (enemy) {
#line 708
          tmp = __builtin_clzll((unsigned long long )(file_mask[file] & tree->position.color[enemy].pieces[1]));
#line 708
          tmp___1 = 63 - tmp;
        } else {
#line 708
          tmp___0 = __builtin_ctzll((unsigned long long )(file_mask[file] & tree->position.color[enemy].pieces[1]));
#line 708
          tmp___1 = tmp___0;
        }
#line 708
        defects += (int )pawn_defects[side][tmp___1 >> 3];
      }
#line 711
      if (! (file_mask[file] & tree->position.color[side].pieces[1])) {
#line 712
        defects += (int )half_open_file[file];
      } else
#line 713
      if (! (tree->position.color[side].pieces[1] & set_mask[sqflip[side][8] + (int const   )file])) {
#line 714
        defects ++;
#line 715
        if (! (tree->position.color[side].pieces[1] & set_mask[sqflip[side][16] + (int const   )file])) {
#line 716
          defects ++;
        }
      }
    }
#line 701
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 719
  return (defects);
}
}
#line 730 "evaluate.c"
void EvaluateKnights(TREE *tree , int side ) 
{ 
  uint64_t temp ;
  int square ;
  int special ;
  int i ;
  int score_eg ;
  int score_mg ;
  int enemy ;
  uint64_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 732
  score_eg = 0;
#line 732
  score_mg = 0;
#line 732
  enemy = side ^ 1;
#line 742
  temp = tree->position.color[side].pieces[2];
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 742
    if (! temp) {
#line 742
      goto while_break;
    }
#line 743
    square = __builtin_ctzll((unsigned long long )temp);
#line 744
    score_mg += (int )nval[0][side][square];
#line 745
    score_eg += (int )nval[1][side][square];
#line 758
    special = (int )knight_outpost[side][square];
#line 759
    if (special) {
#line 759
      if (! (mask_pattacks[enemy][square] & tree->position.color[enemy].pieces[1])) {
#line 760
        if (pawn_attacks[enemy][square] & tree->position.color[side].pieces[1]) {
#line 761
          special += special / 2;
#line 762
          if (! tree->position.color[enemy].pieces[2]) {
#line 762
            if (square_color[square]) {
#line 762
              tmp = dark_squares;
            } else {
#line 762
              tmp = ~ dark_squares;
            }
#line 762
            if (tmp & (unsigned long const   )tree->position.color[enemy].pieces[3]) {
#line 762
              goto _L;
            } else {
#line 763
              special += (int )knight_outpost[side][square];
            }
          } else {
            _L: /* CIL Label */ ;
          }
        }
#line 765
        score_eg += special;
#line 766
        score_mg += special;
      } else {
#line 759
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 775
    if (tree->dangerous[side]) {
#line 776
      tmp___4 = abs((square & 7) - (tree->position.kingsq[enemy] & 7));
#line 776
      tmp___5 = abs((square >> 3) - (tree->position.kingsq[enemy] >> 3));
#line 776
      if (tmp___4 > tmp___5) {
#line 776
        tmp___2 = abs((square & 7) - (tree->position.kingsq[enemy] & 7));
#line 776
        i = tmp___2;
      } else {
#line 776
        tmp___3 = abs((square >> 3) - (tree->position.kingsq[enemy] >> 3));
#line 776
        i = tmp___3;
      }
#line 777
      tree->tropism[side] += (int )king_tropism_n[i];
    }
#line 742
    temp &= temp - 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 780
  tree->score_mg += (int )(sign[side] * (int const   )score_mg);
#line 781
  tree->score_eg += (int )(sign[side] * (int const   )score_eg);
#line 782
  return;
}
}
#line 795 "evaluate.c"
void EvaluateMate(TREE *tree , int side ) 
{ 
  int mate_score ;
  int enemy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 796
  mate_score = 0;
#line 796
  enemy = side ^ 1;
#line 808
  if (! tree->position.pieces[enemy][0]) {
#line 808
    if ((int )tree->position.pieces[side][3] == 1) {
#line 808
      if ((int )tree->position.pieces[side][2] == 1) {
#line 810
        if (dark_squares & (unsigned long const   )tree->position.color[side].pieces[3]) {
#line 811
          mate_score = (int )b_n_mate_dark_squares[tree->position.kingsq[enemy]];
        } else {
#line 813
          mate_score = (int )b_n_mate_light_squares[tree->position.kingsq[enemy]];
        }
      } else {
#line 808
        goto _L___0;
      }
    } else {
#line 808
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
#line 824
    mate_score = (int )mate[tree->position.kingsq[enemy]];
  }
#line 833
  tmp___4 = abs((tree->position.kingsq[side] & 7) - (tree->position.kingsq[enemy] & 7));
#line 833
  tmp___5 = abs((tree->position.kingsq[side] >> 3) - (tree->position.kingsq[enemy] >> 3));
#line 833
  if (tmp___4 > tmp___5) {
#line 833
    tmp___1 = abs((tree->position.kingsq[side] & 7) - (tree->position.kingsq[enemy] & 7));
#line 833
    tmp___3 = tmp___1;
  } else {
#line 833
    tmp___2 = abs((tree->position.kingsq[side] >> 3) - (tree->position.kingsq[enemy] >> 3));
#line 833
    tmp___3 = tmp___2;
  }
#line 833
  mate_score -= tmp___3 * (int )king_king_tropism;
#line 834
  tree->score_eg += (int )(sign[side] * (int const   )mate_score);
#line 835
  return;
}
}
#line 847 "evaluate.c"
void EvaluateMaterial(TREE *tree , int wtm ) 
{ 
  int score_mg ;
  int score_eg ;
  int majors ;
  int minors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 859
  if (wtm) {
#line 859
    tmp = wtm_bonus[0];
  } else {
#line 859
    tmp = - wtm_bonus[0];
  }
#line 859
  score_mg = tree->position.material_evaluation + (int )tmp;
#line 860
  if (wtm) {
#line 860
    tmp___0 = wtm_bonus[1];
  } else {
#line 860
    tmp___0 = - wtm_bonus[1];
  }
#line 860
  score_eg = tree->position.material_evaluation + (int )tmp___0;
#line 877
  majors = (((int )tree->position.pieces[1][4] + 2 * (int )tree->position.pieces[1][5]) - (int )tree->position.pieces[0][4]) - 2 * (int )tree->position.pieces[0][5];
#line 880
  minors = (((int )tree->position.pieces[1][2] + (int )tree->position.pieces[1][3]) - (int )tree->position.pieces[0][2]) - (int )tree->position.pieces[0][3];
#line 883
  if (majors) {
#line 883
    goto _L___0;
  } else
#line 883
  if (minors) {
    _L___0: /* CIL Label */ 
#line 884
    if ((int )tree->position.pieces[1][0] - (int )tree->position.pieces[0][0] > 0) {
#line 884
      tmp___3 = (int )tree->position.pieces[1][0] - (int )tree->position.pieces[0][0];
    } else {
#line 884
      tmp___3 = - ((int )tree->position.pieces[1][0] - (int )tree->position.pieces[0][0]);
    }
#line 884
    if (tmp___3 != 2) {
#line 884
      if ((int )tree->position.pieces[1][0] - (int )tree->position.pieces[0][0] != 0) {
#line 886
        if ((int )tree->position.pieces[1][0] - (int )tree->position.pieces[0][0] < 0) {
#line 886
          tmp___1 = -1;
        } else {
#line 886
          tmp___1 = 1;
        }
#line 886
        score_mg += tmp___1 * (int )bad_trade;
#line 889
        if ((int )tree->position.pieces[1][0] - (int )tree->position.pieces[0][0] < 0) {
#line 889
          tmp___2 = -1;
        } else {
#line 889
          tmp___2 = 1;
        }
#line 889
        score_eg += tmp___2 * (int )bad_trade;
      } else {
#line 884
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
  }
#line 894
  tree->score_mg += score_mg;
#line 895
  tree->score_eg += score_eg;
#line 896
  return;
}
}
#line 916 "evaluate.c"
void EvaluatePassedPawns(TREE *tree , int side , int wtm ) 
{ 
  uint64_t behind ;
  uint64_t forward ;
  uint64_t backward ;
  uint64_t attacked ;
  uint64_t defended ;
  uint64_t thispawn ;
  int file ;
  int square ;
  int score ;
  int score_mg ;
  int score_eg ;
  int next_sq ;
  int pawns ;
  int rank ;
  int mg_base ;
  int eg_base ;
  int bonus ;
  int enemy ;
  uint64_t fsliders ;
  uint64_t esliders ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 918
  score_mg = 0;
#line 918
  score_eg = 0;
#line 919
  enemy = side ^ 1;
#line 920
  fsliders = tree->position.color[side].pieces[5] | tree->position.color[side].pieces[4];
#line 921
  esliders = tree->position.color[enemy].pieces[5] | tree->position.color[enemy].pieces[4];
#line 933
  pawns = (int )tree->pawn_score.passed[side];
  {
#line 933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 933
    if (! pawns) {
#line 933
      goto while_break;
    }
#line 934
    file = (int )lsb_8bit[pawns];
#line 935
    thispawn = tree->position.color[side].pieces[1] & file_mask[file];
#line 936
    if (thispawn) {
#line 937
      if (side) {
#line 937
        tmp = __builtin_clzll((unsigned long long )thispawn);
#line 937
        square = 63 - tmp;
      } else {
#line 937
        tmp___0 = __builtin_ctzll((unsigned long long )thispawn);
#line 937
        square = tmp___0;
      }
#line 938
      rank = (int )rankflip[side][square >> 3];
#line 939
      score = (int )passed_pawn[rank];
#line 959
      if (score) {
#line 960
        mg_base = score * (int )passed_pawn_base[0];
#line 961
        eg_base = score * (int )passed_pawn_base[1];
#line 962
        next_sq = square + (int )direction[side];
#line 963
        tmp___6 = abs((tree->position.kingsq[enemy] & 7) - (next_sq & 7));
#line 963
        tmp___7 = abs((tree->position.kingsq[enemy] >> 3) - (next_sq >> 3));
#line 963
        if (tmp___6 > tmp___7) {
#line 963
          tmp___3 = abs((tree->position.kingsq[enemy] & 7) - (next_sq & 7));
#line 963
          tmp___5 = tmp___3;
        } else {
#line 963
          tmp___4 = abs((tree->position.kingsq[enemy] >> 3) - (next_sq >> 3));
#line 963
          tmp___5 = tmp___4;
        }
#line 963
        tmp___13 = abs((tree->position.kingsq[side] & 7) - (next_sq & 7));
#line 963
        tmp___14 = abs((tree->position.kingsq[side] >> 3) - (next_sq >> 3));
#line 963
        if (tmp___13 > tmp___14) {
#line 963
          tmp___10 = abs((tree->position.kingsq[side] & 7) - (next_sq & 7));
#line 963
          tmp___12 = tmp___10;
        } else {
#line 963
          tmp___11 = abs((tree->position.kingsq[side] >> 3) - (next_sq >> 3));
#line 963
          tmp___12 = tmp___11;
        }
#line 963
        eg_base += (tmp___5 * 2) * score - tmp___12 * score;
#line 966
        if (rank < 6) {
#line 967
          tmp___20 = abs((tree->position.kingsq[side] & 7) - ((next_sq + (int )direction[side]) & 7));
#line 967
          tmp___21 = abs((tree->position.kingsq[side] >> 3) - ((next_sq + (int )direction[side]) >> 3));
#line 967
          if (tmp___20 > tmp___21) {
#line 967
            tmp___17 = abs((tree->position.kingsq[side] & 7) - ((next_sq + (int )direction[side]) & 7));
#line 967
            tmp___19 = tmp___17;
          } else {
#line 967
            tmp___18 = abs((tree->position.kingsq[side] >> 3) - ((next_sq + (int )direction[side]) >> 3));
#line 967
            tmp___19 = tmp___18;
          }
#line 967
          eg_base -= (tmp___19 * score) / 2;
        }
#line 987
        if (! ((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & set_mask[next_sq])) {
#line 988
          bonus = 0;
#line 989
          if (tree->position.color[side].pieces[1] & pawn_attacks[enemy][next_sq]) {
#line 990
            bonus = (int )passed_pawn_free_advance;
          } else {
#line 992
            attacked = (uint64_t )0;
#line 993
            if (side) {
#line 993
              forward = plus8dir[square];
            } else {
#line 993
              forward = minus8dir[square];
            }
#line 994
            if (side) {
#line 994
              backward = minus8dir[square];
            } else {
#line 994
              backward = plus8dir[square];
            }
#line 995
            behind = backward & esliders;
#line 995
            if (behind) {
#line 995
              if ((*(magic_rook_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square])) & file_mask[square & 7]) & behind) {
#line 997
                attacked = forward;
              } else {
#line 995
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 999
              attacked = Attacked(tree, enemy, forward);
            }
#line 1000
            if (! attacked) {
#line 1001
              bonus = (int )passed_pawn_free_advance;
            } else
#line 1002
            if (! (attacked & set_mask[next_sq])) {
#line 1003
              bonus = (int )passed_pawn_free_advance_1;
            }
#line 1017
            behind = backward & fsliders;
#line 1017
            if (behind) {
#line 1017
              if ((*(magic_rook_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square])) & file_mask[square & 7]) & behind) {
#line 1019
                defended = forward;
              } else {
#line 1017
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
#line 1021
              defended = Attacked(tree, side, forward);
            }
#line 1022
            if (defended == forward) {
#line 1023
              bonus += (int )passed_pawn_defended;
            } else
#line 1024
            if (defended & set_mask[next_sq]) {
#line 1025
              bonus += (int )passed_pawn_defended_1;
            }
          }
#line 1037
          mg_base += bonus * score;
#line 1038
          eg_base += bonus * score;
        }
#line 1040
        score_mg += mg_base;
#line 1041
        score_eg += eg_base;
      } else {
#line 1043
        score_eg += 4;
      }
    }
#line 933
    pawns &= pawns - 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1054
  tree->score_mg += (int )(sign[side] * (int const   )score_mg);
#line 1055
  tree->score_eg += (int )(sign[side] * (int const   )score_eg);
#line 1056
  return;
}
}
#line 1081 "evaluate.c"
void EvaluatePassedPawnRaces(TREE *tree , int wtm ) 
{ 
  uint64_t pawns ;
  uint64_t thispawn ;
  int file ;
  int square ;
  int queen_distance ;
  int pawnsq ;
  int passed ;
  int side ;
  int enemy ;
  int queener[2] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  uint64_t tmp___44 ;

  {
#line 1084
  queener[0] = 8;
#line 1084
  queener[1] = 8;
#line 1094
  side = 0;
  {
#line 1094
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1094
    if (! (side <= 1)) {
#line 1094
      goto while_break;
    }
#line 1095
    enemy = side ^ 1;
#line 1096
    if (tree->position.color[side].pieces[1]) {
#line 1096
      if (! tree->position.color[enemy].pieces[1]) {
#line 1096
        if ((int )tree->position.pieces[1][0] == 0) {
#line 1096
          if ((int )tree->position.pieces[0][0] == 0) {
#line 1098
            pawns = tree->position.color[side].pieces[1];
            {
#line 1098
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1098
              if (! pawns) {
#line 1098
                goto while_break___0;
              }
#line 1099
              pawnsq = __builtin_ctzll((unsigned long long )pawns);
#line 1107
              if (sign[side] * (int const   )(tree->position.kingsq[side] >> 3) <= sign[side] * (int const   )(pawnsq >> 3)) {
#line 1108
                goto __Cont;
              }
#line 1118
              if ((pawnsq & 7) == 0) {
#line 1119
                if ((tree->position.kingsq[side] & 7) == 1) {
#line 1119
                  tmp___4 = abs((tree->position.kingsq[side] & 7) - (int )(sqflip[side][56] & 7));
#line 1119
                  tmp___5 = abs((tree->position.kingsq[side] >> 3) - (int )(sqflip[side][56] >> 3));
#line 1119
                  if (tmp___4 > tmp___5) {
#line 1119
                    tmp___1 = abs((tree->position.kingsq[side] & 7) - (int )(sqflip[side][56] & 7));
#line 1119
                    tmp___3 = tmp___1;
                  } else {
#line 1119
                    tmp___2 = abs((tree->position.kingsq[side] >> 3) - (int )(sqflip[side][56] >> 3));
#line 1119
                    tmp___3 = tmp___2;
                  }
#line 1119
                  tmp___11 = abs((tree->position.kingsq[enemy] & 7) - (int )(sqflip[side][56] & 7));
#line 1119
                  tmp___12 = abs((tree->position.kingsq[enemy] >> 3) - (int )(sqflip[side][56] >> 3));
#line 1119
                  if (tmp___11 > tmp___12) {
#line 1119
                    tmp___8 = abs((tree->position.kingsq[enemy] & 7) - (int )(sqflip[side][56] & 7));
#line 1119
                    tmp___10 = tmp___8;
                  } else {
#line 1119
                    tmp___9 = abs((tree->position.kingsq[enemy] >> 3) - (int )(sqflip[side][56] >> 3));
#line 1119
                    tmp___10 = tmp___9;
                  }
#line 1119
                  if (tmp___3 < tmp___10) {
#line 1123
                    tree->score_eg += (int )(sign[side] * pawn_can_promote);
#line 1124
                    return;
                  } else {
#line 1119
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ ;
                }
#line 1126
                goto __Cont;
              } else
#line 1127
              if ((pawnsq & 7) == 7) {
#line 1128
                if ((tree->position.kingsq[side] & 7) == 6) {
#line 1128
                  tmp___18 = abs((tree->position.kingsq[side] & 7) - (int )(sqflip[side][63] & 7));
#line 1128
                  tmp___19 = abs((tree->position.kingsq[side] >> 3) - (int )(sqflip[side][63] >> 3));
#line 1128
                  if (tmp___18 > tmp___19) {
#line 1128
                    tmp___15 = abs((tree->position.kingsq[side] & 7) - (int )(sqflip[side][63] & 7));
#line 1128
                    tmp___17 = tmp___15;
                  } else {
#line 1128
                    tmp___16 = abs((tree->position.kingsq[side] >> 3) - (int )(sqflip[side][63] >> 3));
#line 1128
                    tmp___17 = tmp___16;
                  }
#line 1128
                  tmp___25 = abs((tree->position.kingsq[enemy] & 7) - (int )(sqflip[side][63] & 7));
#line 1128
                  tmp___26 = abs((tree->position.kingsq[enemy] >> 3) - (int )(sqflip[side][63] >> 3));
#line 1128
                  if (tmp___25 > tmp___26) {
#line 1128
                    tmp___22 = abs((tree->position.kingsq[enemy] & 7) - (int )(sqflip[side][63] & 7));
#line 1128
                    tmp___24 = tmp___22;
                  } else {
#line 1128
                    tmp___23 = abs((tree->position.kingsq[enemy] >> 3) - (int )(sqflip[side][63] >> 3));
#line 1128
                    tmp___24 = tmp___23;
                  }
#line 1128
                  if (tmp___17 < tmp___24) {
#line 1132
                    tree->score_eg += (int )(sign[side] * pawn_can_promote);
#line 1133
                    return;
                  } else {
#line 1128
                    goto _L___0;
                  }
                } else {
                  _L___0: /* CIL Label */ ;
                }
#line 1135
                goto __Cont;
              }
#line 1147
              tmp___33 = abs((tree->position.kingsq[side] & 7) - (pawnsq & 7));
#line 1147
              tmp___34 = abs((tree->position.kingsq[side] >> 3) - (pawnsq >> 3));
#line 1147
              if (tmp___33 > tmp___34) {
#line 1147
                tmp___30 = abs((tree->position.kingsq[side] & 7) - (pawnsq & 7));
#line 1147
                tmp___32 = tmp___30;
              } else {
#line 1147
                tmp___31 = abs((tree->position.kingsq[side] >> 3) - (pawnsq >> 3));
#line 1147
                tmp___32 = tmp___31;
              }
#line 1147
              tmp___40 = abs((tree->position.kingsq[enemy] & 7) - (pawnsq & 7));
#line 1147
              tmp___41 = abs((tree->position.kingsq[enemy] >> 3) - (pawnsq >> 3));
#line 1147
              if (tmp___40 > tmp___41) {
#line 1147
                tmp___37 = abs((tree->position.kingsq[enemy] & 7) - (pawnsq & 7));
#line 1147
                tmp___39 = tmp___37;
              } else {
#line 1147
                tmp___38 = abs((tree->position.kingsq[enemy] >> 3) - (pawnsq >> 3));
#line 1147
                tmp___39 = tmp___38;
              }
#line 1147
              if (tmp___32 < tmp___39) {
#line 1148
                if (sign[side] * (int const   )(tree->position.kingsq[side] >> 3) > sign[side] * (int const   )(((pawnsq >> 3) - 1) + 2 * side)) {
#line 1150
                  tree->score_eg += (int )(sign[side] * pawn_can_promote);
#line 1151
                  return;
                }
#line 1153
                if (tree->position.kingsq[side] >> 3 == (int )rank6[side]) {
#line 1154
                  tree->score_eg += (int )(sign[side] * pawn_can_promote);
#line 1155
                  return;
                }
#line 1165
                if (tree->position.kingsq[side] >> 3 == ((pawnsq >> 3) - 1) + 2 * side) {
#line 1165
                  tmp___27 = EvaluateHasOpposition(wtm == side, tree->position.kingsq[side],
                                                   tree->position.kingsq[enemy]);
#line 1165
                  if (tmp___27) {
#line 1168
                    tree->score_eg += (int )(sign[side] * pawn_can_promote);
#line 1169
                    return;
                  } else {
#line 1165
                    goto _L___1;
                  }
                } else {
                  _L___1: /* CIL Label */ ;
                }
              }
              __Cont: /* CIL Label */ 
#line 1098
              pawns &= pawns - 1UL;
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
#line 1096
            goto _L___4;
          }
        } else {
#line 1096
          goto _L___4;
        }
      } else {
#line 1096
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
      _L___3: /* CIL Label */ 
      _L___2: /* CIL Label */ ;
    }
#line 1183
    if ((int )tree->position.pieces[enemy][0] == 0) {
#line 1183
      if (tree->pawn_score.passed[side]) {
#line 1184
        passed = (int )tree->pawn_score.passed[side];
        {
#line 1185
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1185
          if (! passed) {
#line 1185
            goto while_break___1;
          }
#line 1186
          file = (int )lsb_8bit[passed];
#line 1187
          thispawn = tree->position.color[side].pieces[1] & file_mask[file];
#line 1188
          if (thispawn) {
#line 1189
            if (side) {
#line 1189
              tmp___42 = __builtin_clzll((unsigned long long )thispawn);
#line 1189
              square = 63 - tmp___42;
            } else {
#line 1189
              tmp___43 = __builtin_ctzll((unsigned long long )thispawn);
#line 1189
              square = tmp___43;
            }
#line 1190
            if (! (pawn_race[side][wtm][square] & tree->position.color[enemy].pieces[6])) {
#line 1191
              if (rank8[side] - (int const   )(square >> 3) > 0) {
#line 1191
                queen_distance = (int )(rank8[side] - (int const   )(square >> 3));
              } else {
#line 1191
                queen_distance = (int )(- (rank8[side] - (int const   )(square >> 3)));
              }
#line 1192
              if (side) {
#line 1192
                tmp___44 = plus8dir[square];
              } else {
#line 1192
                tmp___44 = minus8dir[square];
              }
#line 1192
              if (tree->position.color[side].pieces[6] & tmp___44) {
#line 1193
                if (file == 0) {
#line 1193
                  goto _L___5;
                } else
#line 1193
                if (file == 7) {
                  _L___5: /* CIL Label */ 
#line 1194
                  queen_distance = 99;
                }
#line 1195
                queen_distance ++;
              }
#line 1197
              if (square >> 3 == (int )rank2[side]) {
#line 1198
                queen_distance --;
              }
#line 1199
              if (queen_distance < queener[side]) {
#line 1200
                queener[side] = queen_distance;
              }
            }
          }
#line 1185
          passed &= passed - 1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 1183
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ ;
    }
#line 1094
    side ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1218
  if (queener[1] < queener[0]) {
#line 1219
    tree->score_eg += (int )(pawn_can_promote + (int const   )((5 - queener[1]) * 10));
  } else
#line 1220
  if (queener[0] < queener[1]) {
#line 1221
    tree->score_eg -= (int )(pawn_can_promote + (int const   )((5 - queener[0]) * 10));
  }
#line 1222
  return;
}
}
#line 1245 "evaluate.c"
void EvaluatePawns(TREE *tree , int side ) 
{ 
  uint64_t pawns ;
  uint64_t attackers ;
  uint64_t defenders ;
  uint64_t doubled ;
  uint64_t supported ;
  uint64_t connected ;
  uint64_t passed ;
  uint64_t backward ;
  int square ;
  int file ;
  int rank ;
  int score_eg ;
  int score_mg ;
  int enemy ;
  unsigned int isolated ;
  unsigned int pawn_files ;
  uint64_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  uint64_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1248
  score_eg = 0;
#line 1248
  score_mg = 0;
#line 1248
  enemy = side ^ 1;
#line 1249
  pawn_files = 0U;
#line 1258
  tree->pawn_score.passed[side] = (unsigned char)0;
#line 1259
  pawns = tree->position.color[side].pieces[1];
  {
#line 1259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1259
    if (! pawns) {
#line 1259
      goto while_break;
    }
#line 1260
    square = __builtin_ctzll((unsigned long long )pawns);
#line 1261
    file = square & 7;
#line 1262
    rank = (int )rankflip[side][square >> 3];
#line 1263
    pawn_files |= (unsigned int )(1 << file);
#line 1274
    score_mg += (int )pval[side][square];
#line 1283
    isolated = (unsigned int )(! (tree->position.color[side].pieces[1] & mask_pawn_isolated[square]));
#line 1284
    if (isolated) {
#line 1285
      score_mg -= (int )pawn_isolated[0][file];
#line 1286
      score_eg -= (int )pawn_isolated[1][file];
    }
#line 1298
    supported = tree->position.color[side].pieces[1] & pawn_attacks[enemy][square];
#line 1299
    if (! isolated) {
#line 1299
      if (! supported) {
#line 1300
        score_mg += (int )pawn_unsupported[0];
#line 1301
        score_eg += (int )pawn_unsupported[1];
      } else {
#line 1299
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 1317
    if (side) {
#line 1317
      tmp = plus8dir[square];
    } else {
#line 1317
      tmp = minus8dir[square];
    }
#line 1317
    doubled = tree->position.color[side].pieces[1] & tmp;
#line 1318
    if (doubled) {
#line 1319
      if (side) {
#line 1319
        tmp___0 = __builtin_clzll((unsigned long long )doubled);
#line 1319
        tmp___2 = 63 - tmp___0;
      } else {
#line 1319
        tmp___1 = __builtin_ctzll((unsigned long long )doubled);
#line 1319
        tmp___2 = tmp___1;
      }
#line 1319
      tmp___3 = abs((square >> 3) - (tmp___2 >> 3));
#line 1319
      score_mg -= (int )(pawn_doubled[0][file] / (int const   )tmp___3);
#line 1322
      if (side) {
#line 1322
        tmp___4 = __builtin_clzll((unsigned long long )doubled);
#line 1322
        tmp___6 = 63 - tmp___4;
      } else {
#line 1322
        tmp___5 = __builtin_ctzll((unsigned long long )doubled);
#line 1322
        tmp___6 = tmp___5;
      }
#line 1322
      tmp___7 = abs((square >> 3) - (tmp___6 >> 3));
#line 1322
      score_eg -= (int )(pawn_doubled[1][file] / (int const   )tmp___7);
    }
#line 1334
    connected = tree->position.color[side].pieces[1] & mask_pawn_connected[side][square];
#line 1335
    if (connected) {
#line 1336
      score_mg += (int )pawn_connected[0][rank][file];
#line 1337
      score_eg += (int )pawn_connected[1][rank][file];
    }
#line 1347
    passed = (uint64_t )(! (tree->position.color[enemy].pieces[1] & mask_passed[side][square]));
#line 1348
    if (passed) {
#line 1349
      tree->pawn_score.passed[side] = (unsigned char )((int )tree->pawn_score.passed[side] | (1 << file));
    }
#line 1358
    backward = (uint64_t )0;
#line 1359
    if (! ((((passed | (unsigned long )isolated) | connected) | (tree->position.color[side].pieces[1] & mask_pattacks[side][square])) | (tree->position.color[enemy].pieces[1] & pawn_attacks[side][square]))) {
#line 1362
      backward = tree->position.color[enemy].pieces[1] & pawn_attacks[side][square + (int )direction[side]];
    }
#line 1363
    if (backward) {
#line 1364
      score_mg -= (int )pawn_backward[0][file];
#line 1365
      score_eg -= (int )pawn_backward[1][file];
    }
#line 1379
    if (! ((passed | backward) | (unsigned long )isolated)) {
#line 1379
      if (side) {
#line 1379
        tmp___10 = plus8dir[square];
      } else {
#line 1379
        tmp___10 = minus8dir[square];
      }
#line 1379
      if (tree->position.color[enemy].pieces[1] & tmp___10) {
#line 1379
        goto _L___0;
      } else {
#line 1381
        defenders = mask_pattacks[side][square + (int )direction[side]] & tree->position.color[side].pieces[1];
#line 1382
        attackers = mask_pattacks[enemy][square] & tree->position.color[enemy].pieces[1];
#line 1383
        tmp___8 = __builtin_popcountll((unsigned long long )defenders);
#line 1383
        tmp___9 = __builtin_popcountll((unsigned long long )attackers);
#line 1383
        if (tmp___8 >= tmp___9) {
#line 1384
          score_mg += (int )passed_pawn_candidate[0][rank];
#line 1385
          score_eg += (int )passed_pawn_candidate[1][rank];
        }
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 1259
    pawns &= pawns - 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 1402
  score_eg += (int )(pawn_file_width * (int const   )((int )msb_8bit[pawn_files] - (int )lsb_8bit[pawn_files]));
#line 1417
  tmp___11 = EvaluateKingsFile(tree, side, 0, 2);
#line 1417
  tree->pawn_score.defects_q[side] = (unsigned char )tmp___11;
#line 1419
  tmp___12 = EvaluateKingsFile(tree, side, 2, 5);
#line 1419
  tree->pawn_score.defects_m[side] = (unsigned char )tmp___12;
#line 1421
  tmp___13 = EvaluateKingsFile(tree, side, 5, 7);
#line 1421
  tree->pawn_score.defects_k[side] = (unsigned char )tmp___13;
#line 1431
  tree->pawn_score.score_mg += (int32_t )(sign[side] * (int const   )score_mg);
#line 1432
  tree->pawn_score.score_eg += (int32_t )(sign[side] * (int const   )score_eg);
#line 1433
  return;
}
}
#line 1443 "evaluate.c"
void EvaluateQueens(TREE *tree , int side ) 
{ 
  uint64_t temp ;
  int square ;
  int i ;
  int score_mg ;
  int score_eg ;
  int enemy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1445
  score_mg = 0;
#line 1445
  score_eg = 0;
#line 1445
  enemy = side ^ 1;
#line 1455
  temp = tree->position.color[side].pieces[5];
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    if (! temp) {
#line 1455
      goto while_break;
    }
#line 1456
    square = __builtin_ctzll((unsigned long long )temp);
#line 1465
    score_mg += (int )qval[0][side][square];
#line 1466
    score_eg += (int )qval[1][side][square];
#line 1474
    if (tree->dangerous[side]) {
#line 1475
      i = tree->position.kingsq[enemy];
#line 1476
      tmp___4 = abs((square & 7) - (i & 7));
#line 1476
      tmp___5 = abs((square >> 3) - (i >> 3));
#line 1476
      if (tmp___4 > tmp___5) {
#line 1476
        tmp___1 = abs((square & 7) - (i & 7));
#line 1476
        tmp___3 = tmp___1;
      } else {
#line 1476
        tmp___2 = abs((square >> 3) - (i >> 3));
#line 1476
        tmp___3 = tmp___2;
      }
#line 1476
      tree->tropism[side] += (int )king_tropism_q[tmp___3];
#line 1477
      tmp___6 = abs((square >> 3) - (i >> 3));
#line 1477
      tmp___7 = abs((square & 7) - (i & 7));
#line 1477
      i = 8 - (tmp___6 + tmp___7);
#line 1478
      score_mg += i;
#line 1479
      score_eg += i;
    }
#line 1455
    temp &= temp - 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 1482
  tree->score_mg += (int )(sign[side] * (int const   )score_mg);
#line 1483
  tree->score_eg += (int )(sign[side] * (int const   )score_eg);
#line 1484
  return;
}
}
#line 1494 "evaluate.c"
void EvaluateRooks(TREE *tree , int side ) 
{ 
  uint64_t temp ;
  uint64_t moves ;
  int square ;
  int rank ;
  int file ;
  int i ;
  int mobility ;
  int score_mg ;
  int score_eg ;
  int enemy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1496
  score_mg = 0;
#line 1496
  score_eg = 0;
#line 1497
  enemy = side ^ 1;
#line 1506
  temp = tree->position.color[side].pieces[4];
  {
#line 1506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1506
    if (! temp) {
#line 1506
      goto while_break;
    }
#line 1507
    square = __builtin_ctzll((unsigned long long )temp);
#line 1508
    file = square & 7;
#line 1509
    rank = square >> 3;
#line 1519
    if (! (file_mask[file] & tree->position.color[side].pieces[1])) {
#line 1520
      if (! (file_mask[file] & tree->position.color[enemy].pieces[1])) {
#line 1521
        score_mg += (int )rook_open_file[0];
#line 1522
        score_eg += (int )rook_open_file[1];
      } else {
#line 1524
        score_mg += (int )rook_half_open_file[0];
#line 1525
        score_eg += (int )rook_half_open_file[1];
      }
    }
#line 1538
    mobility = (int )*(magic_rook_mobility_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square]));
#line 1539
    score_mg += mobility;
#line 1540
    score_eg += mobility;
#line 1551
    if (mobility < 0) {
#line 1551
      if (rank == (int )rank1[side]) {
#line 1551
        if (rank == tree->position.kingsq[side] >> 3) {
#line 1552
          i = tree->position.kingsq[side] & 7;
#line 1553
          if (i > 4) {
#line 1554
            if (file > i) {
#line 1555
              score_mg += mobility * 3;
#line 1556
              score_eg += mobility * 3;
            }
          } else
#line 1558
          if (i < 3) {
#line 1558
            if (file < i) {
#line 1559
              score_mg += mobility * 3;
#line 1560
              score_eg += mobility * 3;
            } else {
#line 1558
              goto _L;
            }
          } else {
            _L: /* CIL Label */ ;
          }
        } else {
#line 1551
          goto _L___3;
        }
      } else {
#line 1551
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
    _L___2: /* CIL Label */ 
#line 1576
    if (rank == (int )rank7[side]) {
#line 1576
      if (tree->position.kingsq[enemy] >> 3 == (int )rank8[side]) {
#line 1576
        goto _L___1;
      } else
#line 1576
      if (tree->position.color[enemy].pieces[1] & rank_mask[rank]) {
        _L___1: /* CIL Label */ 
#line 1578
        score_mg += (int )rook_on_7th[0];
#line 1579
        score_eg += (int )rook_on_7th[1];
#line 1580
        if ((*(magic_rook_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square])) & rank_mask[square >> 3]) & (tree->position.color[side].pieces[5] | tree->position.color[side].pieces[4])) {
#line 1581
          score_mg += (int )rook_connected_7th[0];
#line 1582
          score_eg += (int )rook_connected_7th[1];
        }
      } else {
#line 1576
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 1592
    if (tree->dangerous[side]) {
#line 1593
      moves = king_attacks[tree->position.kingsq[enemy]];
#line 1594
      if (rook_attacks[square] & moves) {
#line 1594
        if (*(magic_rook_indices[square] + ((((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & ~ (tree->position.color[side].pieces[5] | tree->position.color[side].pieces[4])) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square])) & moves) {
#line 1594
          i = 1;
        } else {
#line 1594
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 1594
        tmp___4 = abs((square & 7) - (tree->position.kingsq[enemy] & 7));
#line 1594
        tmp___5 = abs((square >> 3) - (tree->position.kingsq[enemy] >> 3));
#line 1594
        if (tmp___4 > tmp___5) {
#line 1594
          tmp___1 = abs((square & 7) - (tree->position.kingsq[enemy] & 7));
#line 1594
          tmp___3 = tmp___1;
        } else {
#line 1594
          tmp___2 = abs((square >> 3) - (tree->position.kingsq[enemy] >> 3));
#line 1594
          tmp___3 = tmp___2;
        }
#line 1594
        i = tmp___3;
      }
#line 1598
      tree->tropism[side] += (int )king_tropism_r[i];
    }
#line 1506
    temp &= temp - 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 1601
  tree->score_mg += (int )(sign[side] * (int const   )score_mg);
#line 1602
  tree->score_eg += (int )(sign[side] * (int const   )score_eg);
#line 1603
  return;
}
}
#line 1619 "evaluate.c"
int EvaluateWinningChances(TREE *tree , int side , int wtm ) 
{ 
  int square ;
  int ekd ;
  int promote ;
  int majors ;
  int minors ;
  int enemy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1620
  enemy = side ^ 1;
#line 1622
  if (! tree->position.color[side].pieces[1]) {
#line 1634
    if ((int )tree->position.pieces[side][0] <= 3) {
#line 1635
      return (0);
    }
#line 1636
    if ((int )tree->position.pieces[side][0] - (int )tree->position.pieces[enemy][0] <= 3) {
#line 1636
      if (mask_not_edge & (unsigned long const   )tree->position.color[enemy].pieces[6]) {
#line 1638
        return (0);
      } else {
#line 1636
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 1647
    majors = (((int )tree->position.pieces[1][4] + 2 * (int )tree->position.pieces[1][5]) - (int )tree->position.pieces[0][4]) - 2 * (int )tree->position.pieces[0][5];
#line 1650
    if (majors > 0) {
#line 1650
      tmp = majors;
    } else {
#line 1650
      tmp = - majors;
    }
#line 1650
    if (tmp == 1) {
#line 1651
      minors = (((int )tree->position.pieces[0][2] + (int )tree->position.pieces[0][3]) - (int )tree->position.pieces[1][2]) - (int )tree->position.pieces[1][3];
#line 1654
      if (majors == minors) {
#line 1655
        return (0);
      }
    }
  } else
#line 1666
  if ((int )tree->position.pieces[1][0] == 0) {
#line 1666
    if ((int )tree->position.pieces[0][0] == 0) {
#line 1666
      if (tree->position.color[1].pieces[1] & (unsigned long )not_rook_pawns) {
#line 1666
        if (tree->position.color[0].pieces[1] & (unsigned long )not_rook_pawns) {
#line 1668
          return (1);
        } else {
#line 1666
          goto _L___2;
        }
      } else {
#line 1666
        goto _L___2;
      }
    } else {
#line 1666
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ ;
  }
#line 1681
  if (! (tree->position.color[side].pieces[1] & (unsigned long )not_rook_pawns)) {
    {
#line 1682
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1683
      if ((int )tree->position.pieces[side][0] > 3) {
#line 1683
        goto _L___3;
      } else
#line 1683
      if ((int )tree->position.pieces[side][0] == 3) {
#line 1683
        if (tree->position.color[side].pieces[2]) {
          _L___3: /* CIL Label */ 
#line 1685
          goto __Cont;
        } else {
#line 1683
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ ;
      }
#line 1686
      if (file_mask[0] & tree->position.color[side].pieces[1]) {
#line 1686
        if (file_mask[7] & tree->position.color[side].pieces[1]) {
#line 1687
          goto __Cont;
        } else {
#line 1686
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ ;
      }
#line 1688
      if (tree->position.color[side].pieces[3]) {
#line 1689
        if (tree->position.color[side].pieces[3] & (unsigned long )dark_squares) {
#line 1690
          if (file_mask[dark_corner[side]] & tree->position.color[side].pieces[1]) {
#line 1691
            goto __Cont;
          }
        } else
#line 1692
        if (file_mask[light_corner[side]] & tree->position.color[side].pieces[1]) {
#line 1693
          goto __Cont;
        }
      }
#line 1695
      if (tree->position.color[side].pieces[1] & file_mask[0]) {
#line 1696
        promote = 56;
      } else {
#line 1698
        promote = 63;
      }
#line 1699
      tmp___5 = abs((tree->position.kingsq[enemy] & 7) - (int )(sqflip[side][promote] & 7));
#line 1699
      tmp___6 = abs((tree->position.kingsq[enemy] >> 3) - (int )(sqflip[side][promote] >> 3));
#line 1699
      if (tmp___5 > tmp___6) {
#line 1699
        tmp___2 = abs((tree->position.kingsq[enemy] & 7) - (int )(sqflip[side][promote] & 7));
#line 1699
        tmp___4 = tmp___2;
      } else {
#line 1699
        tmp___3 = abs((tree->position.kingsq[enemy] >> 3) - (int )(sqflip[side][promote] >> 3));
#line 1699
        tmp___4 = tmp___3;
      }
#line 1699
      ekd = tmp___4 - (wtm != side);
#line 1700
      if (ekd <= 1) {
#line 1701
        return (0);
      }
      __Cont: /* CIL Label */ 
#line 1682
      if (! 0) {
#line 1682
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1712
  if ((int )tree->position.pieces[side][1] == 1) {
#line 1712
    if ((int )tree->position.pieces[enemy][1] == 0) {
#line 1712
      if ((int )tree->position.pieces[side][0] == 5) {
#line 1712
        if ((int )tree->position.pieces[enemy][0] == 5) {
#line 1714
          square = __builtin_ctzll((unsigned long long )tree->position.color[side].pieces[1]);
#line 1715
          tmp___7 = abs((tree->position.kingsq[enemy] & 7) - (square & 7));
#line 1715
          if (tmp___7 <= 1) {
#line 1715
            if (side) {
#line 1715
              tmp___8 = tree->position.kingsq[enemy] >> 3 > square >> 3;
            } else {
#line 1715
              tmp___8 = tree->position.kingsq[enemy] >> 3 < square >> 3;
            }
#line 1715
            if (tmp___8) {
#line 1717
              return (0);
            } else {
#line 1715
              goto _L___6;
            }
          } else {
            _L___6: /* CIL Label */ ;
          }
        } else {
#line 1712
          goto _L___9;
        }
      } else {
#line 1712
        goto _L___9;
      }
    } else {
#line 1712
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ 
    _L___8: /* CIL Label */ 
    _L___7: /* CIL Label */ ;
  }
#line 1727
  if (tree->position.pieces[side][1]) {
#line 1728
    return (1);
  }
#line 1737
  if ((int )tree->position.pieces[side][0] == 6) {
#line 1738
    if ((int )tree->position.pieces[enemy][0] == 3) {
#line 1738
      if (tree->position.color[side].pieces[2]) {
#line 1738
        goto _L___11;
      } else
#line 1738
      if (! tree->position.color[enemy].pieces[2]) {
        _L___11: /* CIL Label */ 
#line 1740
        return (0);
      } else {
#line 1738
        goto _L___10;
      }
    } else {
      _L___10: /* CIL Label */ ;
    }
  }
#line 1749
  if ((int )tree->position.pieces[side][0] == 6) {
#line 1749
    if (! tree->position.color[side].pieces[3]) {
#line 1749
      if ((int )tree->position.pieces[enemy][0] + (int )tree->position.pieces[enemy][1] == 0) {
#line 1751
        return (0);
      } else {
#line 1749
        goto _L___13;
      }
    } else {
#line 1749
      goto _L___13;
    }
  } else {
    _L___13: /* CIL Label */ 
    _L___12: /* CIL Label */ ;
  }
#line 1760
  return (1);
}
}
#line 1775 "evaluate.c"
void InitializeKingSafety(void) 
{ 
  int safety ;
  int tropism ;

  {
#line 1778
  safety = 0;
  {
#line 1778
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1778
    if (! (safety < 16)) {
#line 1778
      goto while_break;
    }
#line 1779
    tropism = 0;
    {
#line 1779
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1779
      if (! (tropism < 16)) {
#line 1779
        goto while_break___0;
      }
#line 1780
      king_safety[safety][tropism] = (180 * (int )(((safety_vector[safety] + 100) * (tropism_vector[tropism] + 100)) / 100 - 100)) / 100;
#line 1779
      tropism ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1778
    safety ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1785
  return;
}
}
#line 60 "hash.c"
int HashProbe(TREE *tree , int ply , int depth , int side , int alpha , int beta ,
              int *value ) 
{ 
  HASH_ENTRY *htable ;
  HPATH_ENTRY *ptable ;
  uint64_t word1 ;
  uint64_t word2 ;
  uint64_t temp_hashkey ;
  int type ;
  int draft ;
  int avoid_null ;
  int val ;
  int entry ;
  int i ;
  int tmp ;

  {
#line 65
  avoid_null = 0;
#line 77
  tree->hash_move[ply] = 0;
#line 78
  if (side) {
#line 78
    temp_hashkey = tree->position.hash_key;
  } else {
#line 78
    temp_hashkey = ~ tree->position.hash_key;
  }
#line 79
  htable = hash_table + (temp_hashkey & hash_mask);
#line 80
  entry = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (entry < 4)) {
#line 80
      goto while_break;
    }
#line 81
    word1 = (htable + entry)->word1;
#line 82
    word2 = (htable + entry)->word2 ^ word1;
#line 83
    if (word2 == temp_hashkey) {
#line 84
      goto while_break;
    }
#line 80
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  if (entry < 4) {
#line 113
    val = (int )((word1 & 131071UL) - 65536UL);
#line 114
    draft = (int )((word1 >> 17) & 32767UL);
#line 115
    tree->hash_move[ply] = (int )((word1 >> 32) & 2097151UL);
#line 116
    type = (int )((word1 >> 53) & 3UL);
#line 117
    if (type & 1) {
#line 117
      if (((depth - null_depth) - depth / null_divisor) - 1 <= draft) {
#line 117
        if (val < beta) {
#line 119
          avoid_null = 2;
        } else {
#line 117
          goto _L___0;
        }
      } else {
#line 117
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
#line 120
    if (depth <= draft) {
#line 121
      if (val > 32000) {
#line 122
        val -= ply - 1;
      } else
#line 123
      if (val < -32000) {
#line 124
        val += ply - 1;
      }
#line 125
      *value = val;
      {
#line 145
      if (type == 3) {
#line 145
        goto case_3;
      }
#line 170
      if (type == 1) {
#line 170
        goto case_1;
      }
#line 181
      if (type == 2) {
#line 181
        goto case_2;
      }
#line 144
      goto switch_break;
      case_3: /* CIL Label */ 
#line 146
      if (val > alpha) {
#line 146
        if (val < beta) {
#line 147
          if (word1 >> 55 != (uint64_t )transposition_age) {
#line 148
            word1 = (uint64_t )(((unsigned long long )word1 & 0x007fffffffffffffull) | (unsigned long long )((uint64_t )transposition_age << 55));
#line 150
            (htable + entry)->word1 = word1;
#line 151
            (htable + entry)->word2 = word1 ^ word2;
          }
          {
#line 153
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 153
            tree->pv[ply - 1].path[ply - 1] = tree->curmv[ply - 1];
#line 153
            tree->pv[ply - 1].pathl = ply;
#line 153
            tree->pv[ply - 1].pathh = 1;
#line 153
            tree->pv[ply - 1].pathd = iteration;
#line 153
            if (! 0) {
#line 153
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 154
          ptable = hash_path + (temp_hashkey & hash_path_mask);
#line 155
          entry = 0;
          {
#line 155
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 155
            if (! (entry < 16)) {
#line 155
              goto while_break___1;
            }
#line 156
            if ((ptable + entry)->path_sig == temp_hashkey) {
#line 157
              i = ply;
              {
#line 157
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 157
                if (128 < (ptable + entry)->hash_pathl + ply) {
#line 157
                  tmp = 128;
                } else {
#line 157
                  tmp = (ptable + entry)->hash_pathl + ply;
                }
#line 157
                if (! (i < tmp)) {
#line 157
                  goto while_break___2;
                }
#line 159
                tree->pv[ply - 1].path[i] = (ptable + entry)->hash_path_moves[i - ply];
#line 157
                i ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 161
              if ((ptable + entry)->hash_pathl + ply < 128) {
#line 162
                tree->pv[ply - 1].pathh = 0;
              }
#line 163
              if (128 < ply + (ptable + entry)->hash_pathl) {
#line 163
                tree->pv[ply - 1].pathl = 128;
              } else {
#line 163
                tree->pv[ply - 1].pathl = ply + (ptable + entry)->hash_pathl;
              }
#line 165
              (ptable + entry)->hash_path_age = transposition_age;
#line 166
              goto while_break___1;
            }
#line 155
            entry ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 146
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ ;
      }
#line 169
      return (1);
      case_1: /* CIL Label */ 
#line 171
      if (val <= alpha) {
#line 172
        if (word1 >> 55 != (uint64_t )transposition_age) {
#line 173
          word1 = (uint64_t )(((unsigned long long )word1 & 0x007fffffffffffffull) | (unsigned long long )((uint64_t )transposition_age << 55));
#line 175
          (htable + entry)->word1 = word1;
#line 176
          (htable + entry)->word2 = word1 ^ word2;
        }
#line 178
        return (1);
      }
#line 180
      goto switch_break;
      case_2: /* CIL Label */ 
#line 182
      if (val >= beta) {
#line 183
        if (word1 >> 55 != (uint64_t )transposition_age) {
#line 184
          word1 = (uint64_t )(((unsigned long long )word1 & 0x007fffffffffffffull) | (unsigned long long )((uint64_t )transposition_age << 55));
#line 186
          (htable + entry)->word1 = word1;
#line 187
          (htable + entry)->word2 = word1 ^ word2;
        }
#line 189
        return (1);
      }
#line 191
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 194
    return (avoid_null);
  }
#line 196
  return (0);
}
}
#line 238 "hash.c"
void HashStore(TREE *tree , int ply , int depth , int side , int type , int value ,
               int bestmove ) 
{ 
  HASH_ENTRY *htable ;
  HASH_ENTRY *replace ;
  HPATH_ENTRY *ptable ;
  uint64_t word1 ;
  uint64_t temp_hashkey ;
  int entry ;
  int draft ;
  int age ;
  int replace_draft ;
  int i ;
  int j___0 ;

  {
#line 240
  replace = (HASH_ENTRY *)0;
#line 253
  word1 = (uint64_t )transposition_age;
#line 254
  word1 = (word1 << 2) | (unsigned long )type;
#line 255
  if (value > 32000) {
#line 256
    value += ply - 1;
  } else
#line 257
  if (value < -32000) {
#line 258
    value -= ply - 1;
  }
#line 259
  word1 = (word1 << 21) | (unsigned long )bestmove;
#line 260
  word1 = (word1 << 15) | (unsigned long )depth;
#line 261
  word1 = (word1 << 17) | (unsigned long )(value + 65536);
#line 262
  if (side) {
#line 262
    temp_hashkey = tree->position.hash_key;
  } else {
#line 262
    temp_hashkey = ~ tree->position.hash_key;
  }
#line 292
  htable = hash_table + (temp_hashkey & hash_mask);
#line 293
  entry = 0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (entry < 4)) {
#line 293
      goto while_break;
    }
#line 294
    if (temp_hashkey == ((htable + entry)->word1 ^ (htable + entry)->word2)) {
#line 295
      replace = htable + entry;
#line 296
      goto while_break;
    }
#line 293
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  if (! replace) {
#line 300
    replace_draft = 99999;
#line 301
    entry = 0;
    {
#line 301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 301
      if (! (entry < 4)) {
#line 301
        goto while_break___0;
      }
#line 302
      age = (int )((htable + entry)->word1 >> 55);
#line 303
      draft = (int )(((htable + entry)->word1 >> 17) & 32767UL);
#line 304
      if (age != transposition_age) {
#line 304
        if (replace_draft > draft) {
#line 305
          replace = htable + entry;
#line 306
          replace_draft = draft;
        } else {
#line 304
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
#line 301
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 309
    if (! replace) {
#line 310
      entry = 0;
      {
#line 310
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 310
        if (! (entry < 4)) {
#line 310
          goto while_break___1;
        }
#line 311
        draft = (int )(((htable + entry)->word1 >> 17) & 32767UL);
#line 312
        if (replace_draft > draft) {
#line 313
          replace = htable + entry;
#line 314
          replace_draft = draft;
        }
#line 310
        entry ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 329
  replace->word1 = word1;
#line 330
  replace->word2 = temp_hashkey ^ word1;
#line 341
  if (type == 3) {
#line 342
    ptable = hash_path + (temp_hashkey & hash_path_mask);
#line 343
    i = 0;
    {
#line 343
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 343
      if (! (i < 16)) {
#line 343
        goto while_break___2;
      }
#line 344
      if (ptable->path_sig == temp_hashkey) {
#line 344
        goto _L___0;
      } else
#line 344
      if (transposition_age != ptable->hash_path_age) {
        _L___0: /* CIL Label */ 
#line 346
        j___0 = ply;
        {
#line 346
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 346
          if (! (j___0 < tree->pv[ply - 1].pathl)) {
#line 346
            goto while_break___3;
          }
#line 347
          ptable->hash_path_moves[j___0 - ply] = tree->pv[ply - 1].path[j___0];
#line 346
          j___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 348
        ptable->hash_pathl = tree->pv[ply - 1].pathl - ply;
#line 349
        ptable->path_sig = temp_hashkey;
#line 350
        ptable->hash_path_age = transposition_age;
#line 351
        goto while_break___2;
      }
#line 343
      i ++;
#line 343
      ptable ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 355
  return;
}
}
#line 369 "hash.c"
void HashStorePV(TREE *tree , int side , int ply ) 
{ 
  HASH_ENTRY *htable ;
  HASH_ENTRY *replace ;
  uint64_t temp_hashkey ;
  uint64_t word1 ;
  int entry ;
  int draft ;
  int replace_draft ;
  int age ;

  {
#line 383
  if (side) {
#line 383
    temp_hashkey = tree->position.hash_key;
  } else {
#line 383
    temp_hashkey = ~ tree->position.hash_key;
  }
#line 384
  word1 = (uint64_t )transposition_age;
#line 385
  word1 <<= 2;
#line 386
  word1 = (word1 << 21) | (unsigned long )tree->pv[0].path[ply];
#line 387
  word1 = (word1 << 32) | 65536UL;
#line 417
  htable = hash_table + (temp_hashkey & hash_mask);
#line 418
  entry = 0;
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (! (entry < 4)) {
#line 418
      goto while_break;
    }
#line 419
    if (((htable + entry)->word2 ^ (htable + entry)->word1) == temp_hashkey) {
#line 420
      (htable + entry)->word1 &= ~ (2097151UL << 32);
#line 421
      (htable + entry)->word1 |= (uint64_t )tree->pv[0].path[ply] << 32;
#line 422
      (htable + entry)->word2 = temp_hashkey ^ (htable + entry)->word1;
#line 423
      goto while_break;
    }
#line 418
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  if (entry == 4) {
#line 427
    replace = (HASH_ENTRY *)0;
#line 428
    replace_draft = 99999;
#line 429
    entry = 0;
    {
#line 429
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 429
      if (! (entry < 4)) {
#line 429
        goto while_break___0;
      }
#line 430
      age = (int )((htable + entry)->word1 >> 55);
#line 431
      draft = (int )(((htable + entry)->word1 >> 17) & 32767UL);
#line 432
      if (age != transposition_age) {
#line 432
        if (replace_draft > draft) {
#line 433
          replace = htable + entry;
#line 434
          replace_draft = draft;
        } else {
#line 432
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
#line 429
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 437
    if (! replace) {
#line 438
      entry = 0;
      {
#line 438
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 438
        if (! (entry < 4)) {
#line 438
          goto while_break___1;
        }
#line 439
        draft = (int )(((htable + entry)->word1 >> 17) & 32767UL);
#line 440
        if (replace_draft > draft) {
#line 441
          replace = htable + entry;
#line 442
          replace_draft = draft;
        }
#line 438
        entry ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 446
    replace->word1 = word1;
#line 447
    replace->word2 = temp_hashkey ^ word1;
  }
#line 449
  return;
}
}
#line 14 "attacks.c"
int Attacks(TREE *tree , int side , int square ) 
{ 


  {
#line 15
  if (rook_attacks[square] & (tree->position.color[side].pieces[4] | tree->position.color[side].pieces[5])) {
#line 15
    if (*(magic_rook_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square])) & (tree->position.color[side].pieces[4] | tree->position.color[side].pieces[5])) {
#line 18
      return (1);
    } else {
#line 15
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 19
  if (bishop_attacks[square] & (tree->position.color[side].pieces[3] | tree->position.color[side].pieces[5])) {
#line 19
    if (*(magic_bishop_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[square]) * (unsigned long )magic_bishop[square] >> magic_bishop_shift[square])) & (tree->position.color[side].pieces[3] | tree->position.color[side].pieces[5])) {
#line 22
      return (1);
    } else {
#line 19
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 23
  if (knight_attacks[square] & tree->position.color[side].pieces[2]) {
#line 24
    return (1);
  }
#line 25
  if (pawn_attacks[side ^ 1][square] & tree->position.color[side].pieces[1]) {
#line 26
    return (1);
  }
#line 27
  if (king_attacks[square] & tree->position.color[side].pieces[6]) {
#line 28
    return (1);
  }
#line 29
  return (0);
}
}
#line 46 "attacks.c"
uint64_t AttacksTo(TREE *tree , int square ) 
{ 
  uint64_t attacks ;
  uint64_t bsliders ;
  uint64_t rsliders ;

  {
#line 47
  attacks = (pawn_attacks[1][square] & tree->position.color[0].pieces[1]) | (pawn_attacks[0][square] & tree->position.color[1].pieces[1]);
#line 50
  bsliders = ((tree->position.color[1].pieces[3] | tree->position.color[0].pieces[3]) | tree->position.color[1].pieces[5]) | tree->position.color[0].pieces[5];
#line 52
  rsliders = ((tree->position.color[1].pieces[4] | tree->position.color[0].pieces[4]) | tree->position.color[1].pieces[5]) | tree->position.color[0].pieces[5];
#line 54
  attacks |= knight_attacks[square] & (tree->position.color[0].pieces[2] | tree->position.color[1].pieces[2]);
#line 55
  if (bishop_attacks[square] & bsliders) {
#line 56
    attacks |= *(magic_bishop_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[square]) * (unsigned long )magic_bishop[square] >> magic_bishop_shift[square])) & bsliders;
  }
#line 57
  if (rook_attacks[square] & rsliders) {
#line 58
    attacks |= *(magic_rook_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square])) & rsliders;
  }
#line 59
  attacks |= king_attacks[square] & (tree->position.color[0].pieces[6] | tree->position.color[1].pieces[6]);
#line 60
  return (attacks);
}
}
#line 72 "attacks.c"
uint64_t AttacksFrom(TREE *tree , int side , int source ) 
{ 
  int tmp ;

  {
#line 74
  if ((int )tree->position.board[source] > 0) {
#line 74
    tmp = (int )tree->position.board[source];
  } else {
#line 74
    tmp = - ((int )tree->position.board[source]);
  }
  {
#line 75
  if (tmp == 5) {
#line 75
    goto case_5;
  }
#line 77
  if (tmp == 4) {
#line 77
    goto case_4;
  }
#line 79
  if (tmp == 3) {
#line 79
    goto case_3;
  }
#line 81
  if (tmp == 2) {
#line 81
    goto case_2;
  }
#line 83
  if (tmp == 1) {
#line 83
    goto case_1;
  }
#line 85
  if (tmp == 6) {
#line 85
    goto case_6;
  }
#line 74
  goto switch_break;
  case_5: /* CIL Label */ 
#line 76
  return (*(magic_bishop_indices[source] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[source]) * (unsigned long )magic_bishop[source] >> magic_bishop_shift[source])) | *(magic_rook_indices[source] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[source]) * (unsigned long )magic_rook[source] >> magic_rook_shift[source])));
  case_4: /* CIL Label */ 
#line 78
  return (*(magic_rook_indices[source] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[source]) * (unsigned long )magic_rook[source] >> magic_rook_shift[source])));
  case_3: /* CIL Label */ 
#line 80
  return (*(magic_bishop_indices[source] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[source]) * (unsigned long )magic_bishop[source] >> magic_bishop_shift[source])));
  case_2: /* CIL Label */ 
#line 82
  return (knight_attacks[source]);
  case_1: /* CIL Label */ 
#line 84
  return (pawn_attacks[side][source]);
  case_6: /* CIL Label */ 
#line 86
  return (king_attacks[source]);
  switch_break: /* CIL Label */ ;
  }
#line 88
  return ((uint64_t )0);
}
}
#line 101 "attacks.c"
uint64_t Attacked(TREE *tree , int side , uint64_t squares___0 ) 
{ 
  uint64_t bsliders ;
  uint64_t rsliders ;
  uint64_t set ;
  int square ;

  {
#line 105
  bsliders = tree->position.color[side].pieces[3] | tree->position.color[side].pieces[5];
#line 106
  rsliders = tree->position.color[side].pieces[4] | tree->position.color[side].pieces[5];
#line 107
  set = squares___0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! set) {
#line 107
      goto while_break;
    }
#line 108
    square = __builtin_ctzll((unsigned long long )set);
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      if (king_attacks[square] & tree->position.color[side].pieces[6]) {
#line 111
        goto while_break___0;
      }
#line 112
      if (knight_attacks[square] & tree->position.color[side].pieces[2]) {
#line 113
        goto while_break___0;
      }
#line 114
      if (bishop_attacks[square] & bsliders) {
#line 114
        if (*(magic_bishop_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_bishop_mask[square]) * (unsigned long )magic_bishop[square] >> magic_bishop_shift[square])) & bsliders) {
#line 116
          goto while_break___0;
        } else {
#line 114
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
#line 117
      if (rook_attacks[square] & rsliders) {
#line 117
        if (*(magic_rook_indices[square] + (((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )magic_rook_mask[square]) * (unsigned long )magic_rook[square] >> magic_rook_shift[square])) & rsliders) {
#line 119
          goto while_break___0;
        } else {
#line 117
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
#line 120
      squares___0 = clear_mask[square] & squares___0;
#line 109
      if (! 0) {
#line 109
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 107
    set &= set - 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return (squares___0);
}
}
#line 23 "see.c"
int SEE(TREE *tree , int wtm , int move ) 
{ 
  uint64_t attacks ;
  uint64_t temp ;
  uint64_t toccupied ;
  uint64_t bsliders ;
  uint64_t rsliders ;
  int attacked_piece ;
  int piece ;
  int nc ;
  int see_list[32] ;
  int source ;
  int target ;
  int tmp ;
  int tmp___0 ;

  {
#line 24
  temp = (uint64_t )0;
#line 24
  toccupied = tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0];
#line 25
  bsliders = ((tree->position.color[1].pieces[3] | tree->position.color[0].pieces[3]) | tree->position.color[1].pieces[5]) | tree->position.color[0].pieces[5];
#line 27
  rsliders = ((tree->position.color[1].pieces[4] | tree->position.color[0].pieces[4]) | tree->position.color[1].pieces[5]) | tree->position.color[0].pieces[5];
#line 29
  nc = 1;
#line 30
  source = move & 63;
#line 30
  target = (move >> 6) & 63;
#line 41
  attacks = AttacksTo(tree, target);
#line 42
  attacked_piece = (int )pcval[(move >> 15) & 7];
#line 51
  wtm ^= 1;
#line 52
  see_list[0] = attacked_piece;
#line 53
  piece = (move >> 12) & 7;
#line 54
  attacked_piece = (int )pcval[piece];
#line 55
  toccupied = clear_mask[source] & toccupied;
#line 56
  if (piece & 1) {
#line 57
    attacks |= *(magic_bishop_indices[target] + ((toccupied & (unsigned long )magic_bishop_mask[target]) * (unsigned long )magic_bishop[target] >> magic_bishop_shift[target])) & bsliders;
  }
#line 58
  if (piece != 6) {
#line 58
    if (piece == 1) {
#line 58
      goto _L___0;
    } else
#line 58
    if (piece & 4) {
      _L___0: /* CIL Label */ 
#line 59
      attacks |= *(magic_rook_indices[target] + ((toccupied & (unsigned long )magic_rook_mask[target]) * (unsigned long )magic_rook[target] >> magic_rook_shift[target])) & rsliders;
    } else {
#line 58
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 75
  attacks &= toccupied;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! attacks) {
#line 75
      goto while_break;
    }
#line 76
    piece = 1;
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      if (! (piece <= 6)) {
#line 76
        goto while_break___0;
      }
#line 77
      temp = tree->position.color[wtm].pieces[piece] & attacks;
#line 77
      if (temp) {
#line 78
        goto while_break___0;
      }
#line 76
      piece ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 79
    if (piece > 6) {
#line 80
      goto while_break;
    }
#line 81
    toccupied ^= temp & - temp;
#line 82
    if (piece & 1) {
#line 83
      attacks |= *(magic_bishop_indices[target] + ((toccupied & (unsigned long )magic_bishop_mask[target]) * (unsigned long )magic_bishop[target] >> magic_bishop_shift[target])) & bsliders;
    }
#line 84
    if (piece != 6) {
#line 84
      if (piece & 4) {
#line 85
        attacks |= *(magic_rook_indices[target] + ((toccupied & (unsigned long )magic_rook_mask[target]) * (unsigned long )magic_rook[target] >> magic_rook_shift[target])) & rsliders;
      } else {
#line 84
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
#line 86
    see_list[nc] = - see_list[nc - 1] + attacked_piece;
#line 87
    attacked_piece = (int )pcval[piece];
#line 88
    tmp = nc;
#line 88
    nc ++;
#line 88
    if (see_list[tmp] - attacked_piece > 0) {
#line 89
      goto while_break;
    }
#line 90
    wtm ^= 1;
#line 75
    attacks &= toccupied;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    nc --;
#line 101
    if (! nc) {
#line 101
      goto while_break___1;
    }
#line 102
    if (- see_list[nc - 1] > see_list[nc]) {
#line 102
      tmp___0 = - see_list[nc - 1];
    } else {
#line 102
      tmp___0 = see_list[nc];
    }
#line 102
    see_list[nc - 1] = - tmp___0;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 103
  return (see_list[0]);
}
}
#line 117 "see.c"
int SEEO(TREE *tree , int wtm , int move ) 
{ 
  uint64_t attacks ;
  uint64_t temp ;
  uint64_t toccupied ;
  uint64_t bsliders ;
  uint64_t rsliders ;
  int attacked_piece ;
  int piece ;
  int nc ;
  int see_list[32] ;
  int target ;
  int tmp ;
  int tmp___0 ;

  {
#line 118
  temp = (uint64_t )0;
#line 118
  toccupied = tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0];
#line 119
  bsliders = ((tree->position.color[1].pieces[3] | tree->position.color[0].pieces[3]) | tree->position.color[1].pieces[5]) | tree->position.color[0].pieces[5];
#line 121
  rsliders = ((tree->position.color[1].pieces[4] | tree->position.color[0].pieces[4]) | tree->position.color[1].pieces[5]) | tree->position.color[0].pieces[5];
#line 123
  nc = 1;
#line 123
  target = (move >> 6) & 63;
#line 134
  attacks = AttacksTo(tree, target);
#line 135
  attacked_piece = (int )pcval[(move >> 12) & 7];
#line 145
  wtm ^= 1;
#line 146
  see_list[0] = attacked_piece;
#line 147
  piece = 1;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (piece <= 6)) {
#line 147
      goto while_break;
    }
#line 148
    temp = tree->position.color[wtm].pieces[piece] & attacks;
#line 148
    if (temp) {
#line 149
      goto while_break;
    }
#line 147
    piece ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  if (piece > 6) {
#line 151
    return (0);
  }
#line 152
  toccupied ^= temp & - temp;
#line 153
  if (piece & 1) {
#line 154
    attacks |= *(magic_bishop_indices[target] + ((toccupied & (unsigned long )magic_bishop_mask[target]) * (unsigned long )magic_bishop[target] >> magic_bishop_shift[target])) & bsliders;
  }
#line 155
  if (piece != 6) {
#line 155
    if (piece & 4) {
#line 156
      attacks |= *(magic_rook_indices[target] + ((toccupied & (unsigned long )magic_rook_mask[target]) * (unsigned long )magic_rook[target] >> magic_rook_shift[target])) & rsliders;
    } else {
#line 155
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 157
  attacked_piece = (int )pcval[piece];
#line 158
  wtm ^= 1;
#line 174
  attacks &= toccupied;
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 174
    if (! attacks) {
#line 174
      goto while_break___0;
    }
#line 175
    piece = 1;
    {
#line 175
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 175
      if (! (piece <= 6)) {
#line 175
        goto while_break___1;
      }
#line 176
      temp = tree->position.color[wtm].pieces[piece] & attacks;
#line 176
      if (temp) {
#line 177
        goto while_break___1;
      }
#line 175
      piece ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 178
    if (piece > 6) {
#line 179
      goto while_break___0;
    }
#line 180
    toccupied ^= temp & - temp;
#line 181
    if (piece & 1) {
#line 182
      attacks |= *(magic_bishop_indices[target] + ((toccupied & (unsigned long )magic_bishop_mask[target]) * (unsigned long )magic_bishop[target] >> magic_bishop_shift[target])) & bsliders;
    }
#line 183
    if (piece != 6) {
#line 183
      if (piece & 4) {
#line 184
        attacks |= *(magic_rook_indices[target] + ((toccupied & (unsigned long )magic_rook_mask[target]) * (unsigned long )magic_rook[target] >> magic_rook_shift[target])) & rsliders;
      } else {
#line 183
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 185
    see_list[nc] = - see_list[nc - 1] + attacked_piece;
#line 186
    attacked_piece = (int )pcval[piece];
#line 187
    tmp = nc;
#line 187
    nc ++;
#line 187
    if (see_list[tmp] - attacked_piece > 0) {
#line 188
      goto while_break___0;
    }
#line 189
    wtm ^= 1;
#line 174
    attacks &= toccupied;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 200
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 200
    nc --;
#line 200
    if (! nc) {
#line 200
      goto while_break___2;
    }
#line 201
    if (- see_list[nc - 1] > see_list[nc]) {
#line 201
      tmp___0 = - see_list[nc - 1];
    } else {
#line 201
      tmp___0 = see_list[nc];
    }
#line 201
    see_list[nc - 1] = - tmp___0;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 202
  return (see_list[0]);
}
}
#line 37 "/usr/include/errno.h"
extern int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 45
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 79 "/usr/include/ctype.h"
extern unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 81
extern __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 83
extern __int32_t const   **( __attribute__((__leaf__)) __ctype_toupper_loc)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 108
extern int ( __attribute__((__leaf__)) isalnum)(int  )  __attribute__((__nothrow__)) ;
#line 109
extern int ( __attribute__((__leaf__)) isalpha)(int  )  __attribute__((__nothrow__)) ;
#line 110
extern int ( __attribute__((__leaf__)) iscntrl)(int  )  __attribute__((__nothrow__)) ;
#line 111
extern int ( __attribute__((__leaf__)) isdigit)(int  )  __attribute__((__nothrow__)) ;
#line 112
extern int ( __attribute__((__leaf__)) islower)(int  )  __attribute__((__nothrow__)) ;
#line 113
extern int ( __attribute__((__leaf__)) isgraph)(int  )  __attribute__((__nothrow__)) ;
#line 114
extern int ( __attribute__((__leaf__)) isprint)(int  )  __attribute__((__nothrow__)) ;
#line 115
extern int ( __attribute__((__leaf__)) ispunct)(int  )  __attribute__((__nothrow__)) ;
#line 116
extern int ( __attribute__((__leaf__)) isspace)(int  )  __attribute__((__nothrow__)) ;
#line 117
extern int ( __attribute__((__leaf__)) isupper)(int  )  __attribute__((__nothrow__)) ;
#line 118
extern int ( __attribute__((__leaf__)) isxdigit)(int  )  __attribute__((__nothrow__)) ;
#line 122
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c )  __attribute__((__nothrow__)) ;
#line 125
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c )  __attribute__((__nothrow__)) ;
#line 130
extern int ( __attribute__((__leaf__)) isblank)(int  )  __attribute__((__nothrow__)) ;
#line 135
extern int ( __attribute__((__leaf__)) isctype)(int __c , int __mask )  __attribute__((__nothrow__)) ;
#line 142
extern int ( __attribute__((__leaf__)) isascii)(int __c )  __attribute__((__nothrow__)) ;
#line 146
extern int ( __attribute__((__leaf__)) toascii)(int __c )  __attribute__((__nothrow__)) ;
#line 150
extern int ( __attribute__((__leaf__)) _toupper)(int  )  __attribute__((__nothrow__)) ;
#line 151
extern int ( __attribute__((__leaf__)) _tolower)(int  )  __attribute__((__nothrow__)) ;
#line 206
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c )  __attribute__((__nothrow__)) ;
#line 206 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 209
  if (__c >= -128) {
#line 209
    if (__c < 256) {
#line 209
      tmp = __ctype_tolower_loc();
#line 209
      tmp___0 = *(*tmp + __c);
    } else {
#line 209
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 209
    tmp___0 = (__int32_t const   )__c;
  }
#line 209
  return ((int )tmp___0);
}
}
#line 212
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c )  __attribute__((__nothrow__)) ;
#line 212 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 215
  if (__c >= -128) {
#line 215
    if (__c < 256) {
#line 215
      tmp = __ctype_toupper_loc();
#line 215
      tmp___0 = *(*tmp + __c);
    } else {
#line 215
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 215
    tmp___0 = (__int32_t const   )__c;
  }
#line 215
  return ((int )tmp___0);
}
}
#line 251
extern int ( __attribute__((__leaf__)) isalnum_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 252
extern int ( __attribute__((__leaf__)) isalpha_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 253
extern int ( __attribute__((__leaf__)) iscntrl_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 254
extern int ( __attribute__((__leaf__)) isdigit_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 255
extern int ( __attribute__((__leaf__)) islower_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 256
extern int ( __attribute__((__leaf__)) isgraph_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 257
extern int ( __attribute__((__leaf__)) isprint_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 258
extern int ( __attribute__((__leaf__)) ispunct_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 259
extern int ( __attribute__((__leaf__)) isspace_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 260
extern int ( __attribute__((__leaf__)) isupper_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 261
extern int ( __attribute__((__leaf__)) isxdigit_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 263
extern int ( __attribute__((__leaf__)) isblank_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 267
extern int ( __attribute__((__leaf__)) __tolower_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 268
extern int ( __attribute__((__leaf__)) tolower_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 271
extern int ( __attribute__((__leaf__)) __toupper_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 272
extern int ( __attribute__((__leaf__)) toupper_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 77 "/usr/include/signal.h"
extern __sighandler_t ( __attribute__((__leaf__)) __sysv_signal)(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 80
extern __sighandler_t ( __attribute__((__leaf__)) sysv_signal)(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 88
extern __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 112
extern int ( __attribute__((__leaf__)) kill)(__pid_t __pid , int __sig )  __attribute__((__nothrow__)) ;
#line 119
extern int ( __attribute__((__leaf__)) killpg)(__pid_t __pgrp , int __sig )  __attribute__((__nothrow__)) ;
#line 123
extern int ( __attribute__((__leaf__)) raise)(int __sig )  __attribute__((__nothrow__)) ;
#line 127
extern __sighandler_t ( __attribute__((__leaf__)) ssignal)(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 129
extern int ( __attribute__((__leaf__)) gsignal)(int __sig )  __attribute__((__nothrow__)) ;
#line 134
extern void psignal(int __sig , char const   *__s ) ;
#line 137
extern void psiginfo(siginfo_t const   *__pinfo , char const   *__s ) ;
#line 151
extern int sigpause(int __sig )  __asm__("__xpg_sigpause") __attribute__((__deprecated__("Use the sigsuspend function instead"))) ;
#line 173
extern int ( __attribute__((__leaf__)) sigblock)(int __mask )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 176
extern int ( __attribute__((__leaf__)) sigsetmask)(int __mask )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 179
extern int ( __attribute__((__leaf__)) siggetmask)(void)  __attribute__((__nothrow__,
__deprecated__)) ;
#line 199
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set )  __attribute__((__nothrow__)) ;
#line 202
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set )  __attribute__((__nothrow__)) ;
#line 205
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                  int __signo )  __attribute__((__nothrow__)) ;
#line 208
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigdelset)(sigset_t *__set ,
                                                                  int __signo )  __attribute__((__nothrow__)) ;
#line 211
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigismember)(sigset_t const   *__set ,
                                                                    int __signo )  __attribute__((__nothrow__)) ;
#line 216
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigisemptyset)(sigset_t const   *__set )  __attribute__((__nothrow__)) ;
#line 219
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) sigandset)(sigset_t *__set ,
                                                                      sigset_t const   *__left ,
                                                                      sigset_t const   *__right )  __attribute__((__nothrow__)) ;
#line 223
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) sigorset)(sigset_t *__set ,
                                                                     sigset_t const   *__left ,
                                                                     sigset_t const   *__right )  __attribute__((__nothrow__)) ;
#line 232
extern int ( __attribute__((__leaf__)) sigprocmask)(int __how , sigset_t const   * __restrict  __set ,
                                                    sigset_t * __restrict  __oset )  __attribute__((__nothrow__)) ;
#line 240
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const   *__set ) ;
#line 243
extern int ( __attribute__((__leaf__)) sigaction)(int __sig , struct sigaction  const  * __restrict  __act ,
                                                  struct sigaction * __restrict  __oact )  __attribute__((__nothrow__)) ;
#line 247
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigpending)(sigset_t *__set )  __attribute__((__nothrow__)) ;
#line 255
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const   * __restrict  __set ,
                                                        int * __restrict  __sig ) ;
#line 264
extern int ( __attribute__((__nonnull__(1))) sigwaitinfo)(sigset_t const   * __restrict  __set ,
                                                          siginfo_t * __restrict  __info ) ;
#line 273
extern int ( __attribute__((__nonnull__(1))) sigtimedwait)(sigset_t const   * __restrict  __set ,
                                                           siginfo_t * __restrict  __info ,
                                                           struct timespec  const  * __restrict  __timeout ) ;
#line 292
extern int ( __attribute__((__leaf__)) sigqueue)(__pid_t __pid , int __sig , union sigval  const  __val )  __attribute__((__nothrow__)) ;
#line 304
extern int ( __attribute__((__leaf__)) sigreturn)(struct sigcontext *__scp )  __attribute__((__nothrow__)) ;
#line 324
extern int ( __attribute__((__leaf__)) siginterrupt)(int __sig , int __interrupt )  __attribute__((__nothrow__,
__deprecated__("Use sigaction with SA_RESTART instead"))) ;
#line 333
extern int ( __attribute__((__leaf__)) sigaltstack)(stack_t const   * __restrict  __ss ,
                                                    stack_t * __restrict  __oss )  __attribute__((__nothrow__)) ;
#line 347
extern int ( __attribute__((__leaf__)) sigstack)(struct sigstack *__ss , struct sigstack *__oss )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 355
extern int ( __attribute__((__leaf__)) sighold)(int __sig )  __attribute__((__nothrow__,
__deprecated__("Use the sigprocmask function instead"))) ;
#line 359
extern int ( __attribute__((__leaf__)) sigrelse)(int __sig )  __attribute__((__nothrow__,
__deprecated__("Use the sigprocmask function instead"))) ;
#line 363
extern int ( __attribute__((__leaf__)) sigignore)(int __sig )  __attribute__((__nothrow__,
__deprecated__("Use the signal function instead"))) ;
#line 367
extern __sighandler_t ( __attribute__((__leaf__)) sigset)(int __sig , void (*__disp)(int  ) )  __attribute__((__nothrow__,
__deprecated__("Use the signal and sigprocmask functions instead"))) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern int ( __attribute__((__leaf__)) pthread_sigmask)(int __how , __sigset_t const   * __restrict  __newmask ,
                                                        __sigset_t * __restrict  __oldmask )  __attribute__((__nothrow__)) ;
#line 36
extern int ( __attribute__((__leaf__)) pthread_kill)(pthread_t __threadid , int __signo )  __attribute__((__nothrow__)) ;
#line 40
extern int ( __attribute__((__leaf__)) pthread_sigqueue)(pthread_t __threadid , int __signo ,
                                                         union sigval  const  __value )  __attribute__((__nothrow__)) ;
#line 383 "/usr/include/signal.h"
extern int ( __attribute__((__leaf__)) __libc_current_sigrtmin)(void)  __attribute__((__nothrow__)) ;
#line 385
extern int ( __attribute__((__leaf__)) __libc_current_sigrtmax)(void)  __attribute__((__nothrow__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h"
extern int tgkill(__pid_t __tgid , __pid_t __tid , int __signal ) ;
#line 83 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(int *__stat_loc ) ;
#line 106
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 127
extern int waitid(idtype_t __idtype , __id_t __id , siginfo_t *__infop , int __options ) ;
#line 143
extern __pid_t wait3(int *__stat_loc , int __options , struct rusage *__usage )  __attribute__((__nothrow__)) ;
#line 159
extern __pid_t wait4(__pid_t __pid , int *__stat_loc , int __options , struct rusage *__usage )  __attribute__((__nothrow__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern clock_t ( __attribute__((__leaf__)) times)(struct tms *__buffer )  __attribute__((__nothrow__)) ;
#line 67 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                     void * __restrict  __tz )  __attribute__((__nothrow__)) ;
#line 86
extern int ( __attribute__((__leaf__)) settimeofday)(struct timeval  const  *__tv ,
                                                     struct timezone  const  *__tz )  __attribute__((__nothrow__)) ;
#line 94
extern int ( __attribute__((__leaf__)) adjtime)(struct timeval  const  *__delta ,
                                                struct timeval *__olddelta )  __attribute__((__nothrow__)) ;
#line 149
extern int ( __attribute__((__leaf__)) getitimer)(__itimer_which_t __which , struct itimerval *__value )  __attribute__((__nothrow__)) ;
#line 155
extern int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which , struct itimerval  const  * __restrict  __new ,
                                                  struct itimerval * __restrict  __old )  __attribute__((__nothrow__)) ;
#line 162
extern int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const   *__file ,
                                                               struct timeval  const  *__tvp )  __attribute__((__nothrow__)) ;
#line 189
extern int ( __attribute__((__nonnull__(1), __leaf__)) lutimes)(char const   *__file ,
                                                                struct timeval  const  *__tvp )  __attribute__((__nothrow__)) ;
#line 193
extern int ( __attribute__((__leaf__)) futimes)(int __fd , struct timeval  const  *__tvp )  __attribute__((__nothrow__)) ;
#line 214
extern int ( __attribute__((__leaf__)) futimesat)(int __fd , char const   *__file ,
                                                  struct timeval  const  *__tvp )  __attribute__((__nothrow__)) ;
#line 32 "utility.c"
void AlignedMalloc(void **pointer , uint64_t alignment , size_t size ) 
{ 
  uint64_t temp ;

  {
#line 35
  segments[nsegments][0] = malloc((size + alignment) - 1UL);
#line 36
  segments[nsegments][1] = segments[nsegments][0];
#line 37
  temp = (uint64_t )segments[nsegments][0];
#line 38
  temp = ((temp + alignment) - 1UL) & ~ (alignment - 1UL);
#line 39
  segments[nsegments][1] = (void *)temp;
#line 40
  *pointer = segments[nsegments][1];
#line 41
  nsegments ++;
#line 42
  return;
}
}
#line 53 "utility.c"
uint64_t atoiKMB(char *input ) 
{ 
  uint64_t size ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 56
  tmp = atoi((char const   *)input);
#line 56
  size = (uint64_t )tmp;
#line 57
  tmp___0 = strchr((char const   *)input, 'K');
#line 57
  if (tmp___0) {
#line 57
    goto _L;
  } else {
#line 57
    tmp___1 = strchr((char const   *)input, 'k');
#line 57
    if (tmp___1) {
      _L: /* CIL Label */ 
#line 58
      size *= (uint64_t )(1 << 10);
    }
  }
#line 59
  tmp___2 = strchr((char const   *)input, 'M');
#line 59
  if (tmp___2) {
#line 59
    goto _L___0;
  } else {
#line 59
    tmp___3 = strchr((char const   *)input, 'm');
#line 59
    if (tmp___3) {
      _L___0: /* CIL Label */ 
#line 60
      size *= (uint64_t )(1 << 20);
    }
  }
#line 61
  tmp___4 = strchr((char const   *)input, 'B');
#line 61
  if (tmp___4) {
#line 61
    goto _L___3;
  } else {
#line 61
    tmp___5 = strchr((char const   *)input, 'b');
#line 61
    if (tmp___5) {
      _L___3: /* CIL Label */ 
#line 61
      goto _L___2;
    } else {
#line 61
      tmp___6 = strchr((char const   *)input, 'G');
#line 61
      if (tmp___6) {
        _L___2: /* CIL Label */ 
#line 61
        goto _L___1;
      } else {
#line 61
        tmp___7 = strchr((char const   *)input, 'g');
#line 61
        if (tmp___7) {
          _L___1: /* CIL Label */ 
#line 63
          size *= (uint64_t )(1 << 30);
        }
      }
    }
  }
#line 64
  return (size);
}
}
#line 75 "utility.c"
void AlignedRemalloc(void **pointer , uint64_t alignment , size_t size ) 
{ 
  uint64_t temp ;
  int i ;

  {
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < nsegments)) {
#line 79
      goto while_break;
    }
#line 80
    if ((unsigned long )segments[i][1] == (unsigned long )*pointer) {
#line 81
      goto while_break;
    }
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  if (i == nsegments) {
#line 83
    Print(4095, "ERROR  AlignedRemalloc() given an invalid pointer\n");
#line 84
    exit(1);
  }
#line 86
  free(segments[i][0]);
#line 87
  segments[i][0] = malloc((size + alignment) - 1UL);
#line 88
  temp = (uint64_t )segments[i][0];
#line 89
  temp = ((temp + alignment) - 1UL) & ~ (alignment - 1UL);
#line 90
  segments[i][1] = (void *)temp;
#line 91
  *pointer = segments[i][1];
#line 92
  return;
}
}
#line 103 "utility.c"
void BookClusterIn(FILE *file , int positions , BOOK_POSITION *buffer___3 ) 
{ 
  int i ;
  char file_buffer[8000UL * sizeof(BOOK_POSITION )] ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 107
  tmp = fread((void *)(file_buffer), (size_t )positions, sizeof(BOOK_POSITION ), file);
#line 107
  i = (int )tmp;
#line 108
  if (i <= 0) {
#line 109
    perror((char const   *)"BookClusterIn fread error: ");
  }
#line 110
  i = 0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i < positions)) {
#line 110
      goto while_break;
    }
#line 111
    (buffer___3 + i)->position = BookIn64((unsigned char *)(file_buffer + (unsigned long )i * sizeof(BOOK_POSITION )));
#line 113
    tmp___0 = BookIn32((unsigned char *)((file_buffer + (unsigned long )i * sizeof(BOOK_POSITION )) + 8));
#line 113
    (buffer___3 + i)->status_played = (unsigned int )tmp___0;
#line 116
    (buffer___3 + i)->learn = BookIn32f((unsigned char *)((file_buffer + (unsigned long )i * sizeof(BOOK_POSITION )) + 12));
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 131 "utility.c"
void BookClusterOut(FILE *file , int positions , BOOK_POSITION *buffer___3 ) 
{ 
  int i ;
  char file_buffer[8000UL * sizeof(BOOK_POSITION )] ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < positions)) {
#line 135
      goto while_break;
    }
#line 136
    tmp = BookOut64((buffer___3 + i)->position);
#line 136
    memcpy((void *)(file_buffer + (unsigned long )i * sizeof(BOOK_POSITION )), (void const   *)tmp,
           (size_t )8);
#line 138
    tmp___0 = BookOut32((int )(buffer___3 + i)->status_played);
#line 138
    memcpy((void *)((file_buffer + (unsigned long )i * sizeof(BOOK_POSITION )) + 8),
           (void const   *)tmp___0, (size_t )4);
#line 140
    tmp___1 = BookOut32f((buffer___3 + i)->learn);
#line 140
    memcpy((void *)((file_buffer + (unsigned long )i * sizeof(BOOK_POSITION )) + 12),
           (void const   *)tmp___1, (size_t )4);
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  fwrite((void const   * __restrict  )(file_buffer), (size_t )positions, sizeof(BOOK_POSITION ),
         (FILE * __restrict  )file);
#line 144
  return;
}
}
#line 155 "utility.c"
float BookIn32f(unsigned char *ch ) 
{ 
  union __anonunion_temp_788510206 temp ;

  {
#line 161
  temp.iv = ((((int )*(ch + 3) << 24) | ((int )*(ch + 2) << 16)) | ((int )*(ch + 1) << 8)) | (int )*(ch + 0);
#line 162
  return (temp.fv);
}
}
#line 174 "utility.c"
int BookIn32(unsigned char *ch ) 
{ 


  {
#line 175
  return (((((int )*(ch + 3) << 24) | ((int )*(ch + 2) << 16)) | ((int )*(ch + 1) << 8)) | (int )*(ch + 0));
}
}
#line 187 "utility.c"
uint64_t BookIn64(unsigned char *ch ) 
{ 


  {
#line 188
  return (((((((((uint64_t )*(ch + 7) << 56) | ((uint64_t )*(ch + 6) << 48)) | ((uint64_t )*(ch + 5) << 40)) | ((uint64_t )*(ch + 4) << 32)) | ((uint64_t )*(ch + 3) << 24)) | ((uint64_t )*(ch + 2) << 16)) | ((uint64_t )*(ch + 1) << 8)) | (uint64_t )*(ch + 0));
}
}
#line 203 "utility.c"
unsigned char *BookOut32(int val ) 
{ 


  {
#line 204
  convert_buff[3] = (unsigned char )((val >> 24) & 0xff);
#line 205
  convert_buff[2] = (unsigned char )((val >> 16) & 0xff);
#line 206
  convert_buff[1] = (unsigned char )((val >> 8) & 0xff);
#line 207
  convert_buff[0] = (unsigned char )(val & 0xff);
#line 208
  return (convert_buff);
}
}
#line 220 "utility.c"
unsigned char *BookOut32f(float val ) 
{ 
  union __anonunion_temp_788510207 temp ;

  {
#line 226
  temp.fv = val;
#line 227
  convert_buff[3] = (unsigned char )((temp.iv >> 24) & 0xff);
#line 228
  convert_buff[2] = (unsigned char )((temp.iv >> 16) & 0xff);
#line 229
  convert_buff[1] = (unsigned char )((temp.iv >> 8) & 0xff);
#line 230
  convert_buff[0] = (unsigned char )(temp.iv & 0xff);
#line 231
  return (convert_buff);
}
}
#line 243 "utility.c"
unsigned char *BookOut64(uint64_t val ) 
{ 


  {
#line 244
  convert_buff[7] = (unsigned char )((val >> 56) & 255UL);
#line 245
  convert_buff[6] = (unsigned char )((val >> 48) & 255UL);
#line 246
  convert_buff[5] = (unsigned char )((val >> 40) & 255UL);
#line 247
  convert_buff[4] = (unsigned char )((val >> 32) & 255UL);
#line 248
  convert_buff[3] = (unsigned char )((val >> 24) & 255UL);
#line 249
  convert_buff[2] = (unsigned char )((val >> 16) & 255UL);
#line 250
  convert_buff[1] = (unsigned char )((val >> 8) & 255UL);
#line 251
  convert_buff[0] = (unsigned char )(val & 255UL);
#line 252
  return (convert_buff);
}
}
#line 312 "utility.c"
int CheckInput(void) 
{ 
  fd_set readfds ;
  struct timeval tv ;
  int data___0 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int __i ;
  fd_set *__arr ;
  long __d ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long __d___0 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;

  {
#line 317
  if (! xboard) {
#line 317
    tmp = fileno(stdin);
#line 317
    tmp___0 = isatty(tmp);
#line 317
    if (tmp___0) {
#line 317
      goto _L;
    } else {
#line 318
      return (0);
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 319
  if (batch_mode) {
#line 320
    return (0);
  }
#line 321
  tmp___1 = strchr((char const   *)(cmd_buffer), '\n');
#line 321
  if (tmp___1) {
#line 322
    return (1);
  }
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    __arr = & readfds;
#line 323
    __i = 0U;
    {
#line 323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 323
      if (! ((unsigned long )__i < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 323
        goto while_break___0;
      }
#line 323
      __arr->fds_bits[__i] = (__fd_mask )0;
#line 323
      __i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 323
    if (! 0) {
#line 323
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  tmp___2 = fileno(stdin);
#line 324
  __d = (long )tmp___2;
#line 324
  if (0) {
#line 324
    if (0L <= __d) {
#line 324
      if (__d < 1024L) {
#line 324
        tmp___4 = __d / (long )(8 * (int )sizeof(__fd_mask ));
      } else {
#line 324
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 324
      tmp___3 = __fdelt_warn(__d);
#line 324
      tmp___4 = tmp___3;
    }
#line 324
    tmp___6 = tmp___4;
  } else {
#line 324
    tmp___5 = __fdelt_chk(__d);
#line 324
    tmp___6 = tmp___5;
  }
#line 324
  tmp___7 = fileno(stdin);
#line 324
  readfds.fds_bits[tmp___6] |= (__fd_mask )(1UL << tmp___7 % (8 * (int )sizeof(__fd_mask )));
#line 325
  tv.tv_sec = (__time_t )0;
#line 326
  tv.tv_usec = (__suseconds_t )0;
#line 327
  select(16, (fd_set * __restrict  )(& readfds), (fd_set * __restrict  )0, (fd_set * __restrict  )0,
         (struct timeval * __restrict  )(& tv));
#line 328
  tmp___8 = fileno(stdin);
#line 328
  __d___0 = (long )tmp___8;
#line 328
  if (0) {
#line 328
    if (0L <= __d___0) {
#line 328
      if (__d___0 < 1024L) {
#line 328
        tmp___10 = __d___0 / (long )(8 * (int )sizeof(__fd_mask ));
      } else {
#line 328
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 328
      tmp___9 = __fdelt_warn(__d___0);
#line 328
      tmp___10 = tmp___9;
    }
#line 328
    tmp___12 = tmp___10;
  } else {
#line 328
    tmp___11 = __fdelt_chk(__d___0);
#line 328
    tmp___12 = tmp___11;
  }
#line 328
  tmp___13 = fileno(stdin);
#line 328
  data___0 = (readfds.fds_bits[tmp___12] & (__fd_mask )(1UL << tmp___13 % (8 * (int )sizeof(__fd_mask )))) != 0L;
#line 329
  return (data___0);
}
}
#line 344 "utility.c"
void ClearHashTableScores(void) 
{ 
  int i ;

  {
#line 347
  if (hash_table) {
#line 348
    i = 0;
    {
#line 348
    while (1) {
      while_continue: /* CIL Label */ ;
#line 348
      if (! ((size_t )i < hash_table_size)) {
#line 348
        goto while_break;
      }
#line 349
      (hash_table + i)->word2 ^= (hash_table + i)->word1;
#line 350
      (hash_table + i)->word1 = ((hash_table + i)->word1 & mask_clear_entry) | 65536UL;
#line 352
      (hash_table + i)->word2 ^= (hash_table + i)->word1;
#line 348
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 354
  return;
}
}
#line 371 "utility.c"
int ComputeDifficulty(int difficulty___0 , int direction___0 ) 
{ 
  int searched ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 372
  searched = 0;
#line 416
  if (direction___0) {
#line 417
    i = 0;
    {
#line 417
    while (1) {
      while_continue: /* CIL Label */ ;
#line 417
      if (! (i < n_root_moves)) {
#line 417
        goto while_break;
      }
#line 418
      if (root_moves[i].status & 8U) {
#line 419
        searched ++;
      }
#line 417
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 420
    if (searched == 0) {
#line 421
      if (direction___0 > 0) {
#line 422
        return (difficulty___0);
      }
#line 423
      if (direction___0 < 0) {
#line 424
        if (100 > difficulty___0) {
#line 424
          difficulty___0 = 100;
        } else {
#line 424
          difficulty___0 = difficulty___0;
        }
      }
    } else
#line 426
    if (difficulty___0 < 100) {
#line 427
      difficulty___0 = 120;
    } else {
#line 429
      difficulty___0 += 20;
    }
  } else {
#line 443
    searched = 0;
#line 444
    i = 0;
    {
#line 444
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 444
      if (! (i < n_root_moves)) {
#line 444
        goto while_break___0;
      }
#line 445
      if (root_moves[i].bm_age == 3) {
#line 446
        searched ++;
      }
#line 444
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 447
    if (searched <= 1) {
#line 448
      difficulty___0 = (90 * difficulty___0) / 100;
    }
  }
#line 461
  if (difficulty___0 < 200) {
#line 461
    tmp___1 = difficulty___0;
  } else {
#line 461
    tmp___1 = 200;
  }
#line 461
  if (60 > tmp___1) {
#line 461
    difficulty___0 = 60;
  } else {
#line 461
    if (difficulty___0 < 200) {
#line 461
      tmp___0 = difficulty___0;
    } else {
#line 461
      tmp___0 = 200;
    }
#line 461
    difficulty___0 = tmp___0;
  }
#line 462
  return (difficulty___0);
}
}
#line 475 "utility.c"
void CraftyExit(int exit_type ) 
{ 
  int proc ;

  {
#line 478
  proc = 1;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (proc < 4)) {
#line 478
      goto while_break;
    }
#line 479
    thread[proc].terminate = (unsigned int volatile   )1;
#line 478
    proc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 480
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 480
    if (! smp_threads) {
#line 480
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 481
  exit(exit_type);
}
}
#line 494 "utility.c"
void DisplayArray(int *array , int size ) 
{ 
  int i ;
  int j___0 ;
  int len ;
  int tmp ;
  int tmp___0 ;

  {
#line 495
  len = 16;
#line 497
  if (size > 0) {
#line 497
    tmp___0 = size;
  } else {
#line 497
    tmp___0 = - size;
  }
#line 497
  if (tmp___0 % 10 == 0) {
#line 498
    len = 10;
  } else {
#line 499
    if (size > 0) {
#line 499
      tmp = size;
    } else {
#line 499
      tmp = - size;
    }
#line 499
    if (tmp % 8 == 0) {
#line 500
      len = 8;
    }
  }
#line 501
  if (size > 0) {
#line 501
    if (size % 16 == 0) {
#line 501
      if (len == 8) {
#line 502
        len = 16;
      } else {
#line 501
        goto _L___0;
      }
    } else {
#line 501
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ ;
  }
#line 503
  if (size > 0) {
#line 504
    printf((char const   *)"    ");
#line 505
    i = 0;
    {
#line 505
    while (1) {
      while_continue: /* CIL Label */ ;
#line 505
      if (! (i < size)) {
#line 505
        goto while_break;
      }
#line 506
      printf((char const   *)"%3d ", *(array + i));
#line 507
      if ((i + 1) % len == 0) {
#line 508
        printf((char const   *)"\n");
#line 509
        if (i < size - 1) {
#line 510
          printf((char const   *)"    ");
        }
      }
#line 505
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 513
    if (i % len != 0) {
#line 514
      printf((char const   *)"\n");
    }
  }
#line 516
  if (size < 0) {
#line 517
    i = 0;
    {
#line 517
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 517
      if (! (i < 8)) {
#line 517
        goto while_break___0;
      }
#line 518
      printf((char const   *)"    ");
#line 519
      j___0 = 0;
      {
#line 519
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 519
        if (! (j___0 < 8)) {
#line 519
          goto while_break___1;
        }
#line 520
        printf((char const   *)"%3d ", *(array + ((7 - i) * 8 + j___0)));
#line 519
        j___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 522
      printf((char const   *)" | %d\n", 8 - i);
#line 517
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 524
    printf((char const   *)"    ---------------------------------\n");
#line 525
    printf((char const   *)"      a   b   c   d   e   f   g   h\n");
  }
#line 527
  return;
}
}
#line 539 "utility.c"
void DisplayArrayX2(int *array , int *array2 , int size ) 
{ 
  int i ;
  int j___0 ;

  {
#line 542
  if (size == 256) {
#line 543
    printf((char const   *)"    ----------- Middlegame -----------   ");
#line 544
    printf((char const   *)"    ------------- Endgame -----------\n");
#line 545
    i = 0;
    {
#line 545
    while (1) {
      while_continue: /* CIL Label */ ;
#line 545
      if (! (i < 8)) {
#line 545
        goto while_break;
      }
#line 546
      printf((char const   *)"    ");
#line 547
      j___0 = 0;
      {
#line 547
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 547
        if (! (j___0 < 8)) {
#line 547
          goto while_break___0;
        }
#line 548
        printf((char const   *)"%3d ", *(array + ((7 - i) * 8 + j___0)));
#line 547
        j___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 549
      printf((char const   *)"  |  %d  |", 8 - i);
#line 550
      printf((char const   *)"  ");
#line 551
      j___0 = 0;
      {
#line 551
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 551
        if (! (j___0 < 8)) {
#line 551
          goto while_break___1;
        }
#line 552
        printf((char const   *)"%3d ", *(array2 + ((7 - i) * 8 + j___0)));
#line 551
        j___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 553
      printf((char const   *)"\n");
#line 545
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 555
    printf((char const   *)"    ----------------------------------       ---------------------------------\n");
#line 557
    printf((char const   *)"      a   b   c   d   e   f   g   h        ");
#line 558
    printf((char const   *)"      a   b   c   d   e   f   g   h\n");
  } else
#line 559
  if (size == 32) {
#line 560
    printf((char const   *)"    ----------- Middlegame -----------   ");
#line 561
    printf((char const   *)"    ------------- Endgame -----------\n");
#line 562
    printf((char const   *)"    ");
#line 563
    i = 0;
    {
#line 563
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 563
      if (! (i < 8)) {
#line 563
        goto while_break___2;
      }
#line 564
      printf((char const   *)"%3d ", *(array + i));
#line 563
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 565
    printf((char const   *)"  |     |");
#line 566
    printf((char const   *)"  ");
#line 567
    i = 0;
    {
#line 567
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 567
      if (! (i < 8)) {
#line 567
        goto while_break___3;
      }
#line 568
      printf((char const   *)"%3d ", *(array2 + i));
#line 567
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 569
    printf((char const   *)"\n");
  } else
#line 570
  if (size <= 20) {
#line 571
    size /= 2;
#line 572
    printf((char const   *)"    ");
#line 573
    i = 0;
    {
#line 573
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 573
      if (! (i < size)) {
#line 573
        goto while_break___4;
      }
#line 574
      printf((char const   *)"%3d ", *(array + i));
#line 573
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 575
    printf((char const   *)"  |<mg    eg>|");
#line 576
    printf((char const   *)"  ");
#line 577
    i = 0;
    {
#line 577
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 577
      if (! (i < size)) {
#line 577
        goto while_break___5;
      }
#line 578
      printf((char const   *)"%3d ", *(array2 + i));
#line 577
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 579
    printf((char const   *)"\n");
  } else
#line 580
  if (size > 128) {
#line 581
    printf((char const   *)"    ----------- Middlegame -----------   ");
#line 582
    printf((char const   *)"    ------------- Endgame -----------\n");
#line 583
    i = 0;
    {
#line 583
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 583
      if (! (i < size / 32)) {
#line 583
        goto while_break___6;
      }
#line 584
      printf((char const   *)"    ");
#line 585
      j___0 = 0;
      {
#line 585
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 585
        if (! (j___0 < 8)) {
#line 585
          goto while_break___7;
        }
#line 586
        printf((char const   *)"%3d ", *(array + ((7 - i) * 8 + j___0)));
#line 585
        j___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 587
      printf((char const   *)"  |  %d  |", 8 - i);
#line 588
      printf((char const   *)"  ");
#line 589
      j___0 = 0;
      {
#line 589
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 589
        if (! (j___0 < 8)) {
#line 589
          goto while_break___8;
        }
#line 590
        printf((char const   *)"%3d ", *(array2 + ((7 - i) * 8 + j___0)));
#line 589
        j___0 ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 591
      printf((char const   *)"\n");
#line 583
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
#line 594
    Print(4095, "ERROR, invalid size = -%d in packet\n", size);
  }
#line 595
  return;
}
}
#line 606 "utility.c"
void DisplayBitBoard(uint64_t board ) 
{ 
  int i ;
  int j___0 ;
  int x___0 ;

  {
#line 609
  i = 56;
  {
#line 609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 609
    if (! (i >= 0)) {
#line 609
      goto while_break;
    }
#line 610
    x___0 = (int )((board >> i) & 255UL);
#line 611
    j___0 = 1;
    {
#line 611
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 611
      if (! (j___0 < 256)) {
#line 611
        goto while_break___0;
      }
#line 612
      if (x___0 & j___0) {
#line 613
        Print(4095, "X ");
      } else {
#line 615
        Print(4095, "- ");
      }
#line 611
      j___0 <<= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 616
    Print(4095, "\n");
#line 609
    i -= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 618
  return;
}
}
#line 630 "utility.c"
void Display2BitBoards(uint64_t board1 , uint64_t board2 ) 
{ 
  int i ;
  int j___0 ;
  int x___0 ;
  int y___0 ;

  {
#line 633
  i = 56;
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 633
    if (! (i >= 0)) {
#line 633
      goto while_break;
    }
#line 634
    x___0 = (int )((board1 >> i) & 255UL);
#line 635
    j___0 = 1;
    {
#line 635
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 635
      if (! (j___0 < 256)) {
#line 635
        goto while_break___0;
      }
#line 636
      if (x___0 & j___0) {
#line 637
        printf((char const   *)"X ");
      } else {
#line 639
        printf((char const   *)"- ");
      }
#line 635
      j___0 <<= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 640
    printf((char const   *)"    ");
#line 641
    y___0 = (int )((board2 >> i) & 255UL);
#line 642
    j___0 = 1;
    {
#line 642
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 642
      if (! (j___0 < 256)) {
#line 642
        goto while_break___1;
      }
#line 643
      if (y___0 & j___0) {
#line 644
        printf((char const   *)"X ");
      } else {
#line 646
        printf((char const   *)"- ");
      }
#line 642
      j___0 <<= 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 647
    printf((char const   *)"\n");
#line 633
    i -= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  return;
}
}
#line 662 "utility.c"
static char const   display_string[16][4]  = 
#line 662
  { {        (char const   )'<',        (char const   )'K',        (char const   )'>',        (char const   )'\000'}, 
   {        (char const   )'<',        (char const   )'Q',        (char const   )'>',        (char const   )'\000'}, 
   {        (char const   )'<',        (char const   )'R',        (char const   )'>',        (char const   )'\000'}, 
   {        (char const   )'<',        (char const   )'B',        (char const   )'>',        (char const   )'\000'}, 
   {        (char const   )'<',        (char const   )'N',        (char const   )'>',        (char const   )'\000'}, 
   {        (char const   )'<',        (char const   )'P',        (char const   )'>',        (char const   )'\000'}, 
   {        (char const   )' ',        (char const   )' ',        (char const   )' ',        (char const   )'\000'}, 
   {        (char const   )'-',        (char const   )'P',        (char const   )'-',        (char const   )'\000'}, 
   {        (char const   )'-',        (char const   )'N',        (char const   )'-',        (char const   )'\000'}, 
   {        (char const   )'-',        (char const   )'B',        (char const   )'-',        (char const   )'\000'}, 
   {        (char const   )'-',        (char const   )'R',        (char const   )'-',        (char const   )'\000'}, 
   {        (char const   )'-',        (char const   )'Q',        (char const   )'-',        (char const   )'\000'}, 
   {        (char const   )'-',        (char const   )'K',        (char const   )'-',        (char const   )'\000'}, 
   {        (char const   )' ',        (char const   )'.',        (char const   )' ',        (char const   )'\000'}};
#line 660 "utility.c"
void DisplayChessBoard(FILE *display_file , POSITION pos ) 
{ 
  int display_board[64] ;
  int i ;
  int j___0 ;

  {
#line 675
  i = 0;
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (! (i < 64)) {
#line 675
      goto while_break;
    }
#line 676
    display_board[i] = (int )pos.board[i] + 6;
#line 677
    if ((int )pos.board[i] == 0) {
#line 678
      if ((i / 8 & 1) == (i % 8 & 1)) {
#line 679
        display_board[i] = 13;
      }
    }
#line 675
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 690
  fprintf(display_file, (char const   *)"\n       +---+---+---+---+---+---+---+---+\n");
#line 691
  i = 7;
  {
#line 691
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 691
    if (! (i >= 0)) {
#line 691
      goto while_break___0;
    }
#line 692
    fprintf(display_file, (char const   *)"   %2d  ", i + 1);
#line 693
    j___0 = 0;
    {
#line 693
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 693
      if (! (j___0 < 8)) {
#line 693
        goto while_break___1;
      }
#line 694
      fprintf(display_file, (char const   *)"|%s", display_string[display_board[i * 8 + j___0]]);
#line 693
      j___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 695
    fprintf(display_file, (char const   *)"|\n");
#line 696
    fprintf(display_file, (char const   *)"       +---+---+---+---+---+---+---+---+\n");
#line 691
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 698
  fprintf(display_file, (char const   *)"         a   b   c   d   e   f   g   h\n\n");
#line 699
  return;
}
}
#line 709 "utility.c"
void DisplayChessMove(char *title , int move ) 
{ 


  {
#line 710
  Print(4095, "%s  piece=%d, from=%d, to=%d, captured=%d, promote=%d\n", title, (move >> 12) & 7,
        move & 63, (move >> 6) & 63, (move >> 15) & 7, (move >> 18) & 7);
#line 713
  return;
}
}
#line 726 "utility.c"
static char out[20]  ;
#line 724 "utility.c"
char *DisplayEvaluation(int value , int wtm ) 
{ 
  int tvalue ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 728
  if (wtm) {
#line 728
    tvalue = value;
  } else {
#line 728
    tvalue = - value;
  }
#line 729
  if (value > 0) {
#line 729
    tmp___5 = value;
  } else {
#line 729
    tmp___5 = - value;
  }
#line 729
  if (tmp___5 > 32000) {
    _L___6: /* CIL Label */ 
#line 731
    if (value > 0) {
#line 731
      tmp___4 = value;
    } else {
#line 731
      tmp___4 = - value;
    }
#line 731
    if (tmp___4 > 32768) {
#line 732
      if (tvalue < 0) {
#line 733
        sprintf(out, (char const   *)" -infnty");
      } else {
#line 735
        sprintf(out, (char const   *)" +infnty");
      }
    } else {
#line 737
      if (value > 0) {
#line 737
        tmp = value;
      } else {
#line 737
        tmp = - value;
      }
#line 737
      if (tmp > 30000) {
#line 737
        if (value > 0) {
#line 737
          tmp___0 = value;
        } else {
#line 737
          tmp___0 = - value;
        }
#line 737
        if (tmp___0 < 32000) {
#line 738
          if (wtm) {
#line 739
            if (value == 31000) {
#line 740
              sprintf(out, (char const   *)"   Won ");
            } else
#line 741
            if (value == -31000) {
#line 742
              sprintf(out, (char const   *)"  Lost ");
            }
          } else
#line 744
          if (value == 31000) {
#line 745
            sprintf(out, (char const   *)"  -Won ");
          } else
#line 746
          if (value == -31000) {
#line 747
            sprintf(out, (char const   *)" -Lost ");
          }
        } else {
#line 737
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
#line 750
      if (value > 0) {
#line 750
        tmp___3 = value;
      } else {
#line 750
        tmp___3 = - value;
      }
#line 750
      if (tmp___3 > 32000) {
#line 751
        if (value == 32766) {
#line 751
          if (wtm) {
#line 752
            sprintf(out, (char const   *)"   Mate");
          } else {
#line 751
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 753
        if (value == 32766) {
#line 753
          if (! wtm) {
#line 754
            sprintf(out, (char const   *)"  -Mate");
          } else {
#line 753
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 755
        if (value == -32767) {
#line 755
          if (wtm) {
#line 756
            sprintf(out, (char const   *)"  -Mate");
          } else {
#line 755
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 757
        if (value == -32767) {
#line 757
          if (! wtm) {
#line 758
            sprintf(out, (char const   *)"   Mate");
          } else {
#line 757
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 759
        if (value > 0) {
#line 759
          if (wtm) {
#line 760
            sprintf(out, (char const   *)"  Mat%.2d", (32768 - value) / 2);
          } else {
#line 759
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 761
        if (value > 0) {
#line 761
          if (! wtm) {
#line 762
            sprintf(out, (char const   *)" -Mat%.2d", (32768 - value) / 2);
          } else {
#line 761
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 763
        if (wtm) {
#line 764
          if (value > 0) {
#line 764
            tmp___1 = value;
          } else {
#line 764
            tmp___1 = - value;
          }
#line 764
          sprintf(out, (char const   *)" -Mat%.2d", (32768 - tmp___1) / 2);
        } else {
#line 766
          if (value > 0) {
#line 766
            tmp___2 = value;
          } else {
#line 766
            tmp___2 = - value;
          }
#line 766
          sprintf(out, (char const   *)"  Mat%.2d", (32768 - tmp___2) / 2);
        }
      }
    }
  } else {
#line 729
    if (value > 0) {
#line 729
      tmp___6 = value;
    } else {
#line 729
      tmp___6 = - value;
    }
#line 729
    if (tmp___6 > 30000) {
#line 729
      if (value > 0) {
#line 729
        tmp___7 = value;
      } else {
#line 729
        tmp___7 = - value;
      }
#line 729
      if (tmp___7 < 32000) {
#line 729
        goto _L___6;
      } else {
#line 729
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
#line 730
      sprintf(out, (char const   *)"%7.2f", (double )((float )tvalue) / 100.0);
    }
  }
#line 769
  return (out);
}
}
#line 783 "utility.c"
static char out___0[10]  ;
#line 781 "utility.c"
char *DisplayEvaluationKibitz(int value , int wtm ) 
{ 
  int tvalue ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 785
  if (wtm) {
#line 785
    tvalue = value;
  } else {
#line 785
    tvalue = - value;
  }
#line 786
  if (value > 0) {
#line 786
    tmp___2 = value;
  } else {
#line 786
    tmp___2 = - value;
  }
#line 786
  if (tmp___2 > 32000) {
#line 788
    if (value > 0) {
#line 788
      tmp___1 = value;
    } else {
#line 788
      tmp___1 = - value;
    }
#line 788
    if (tmp___1 > 32768) {
#line 789
      if (tvalue < 0) {
#line 790
        sprintf(out___0, (char const   *)"-infnty");
      } else {
#line 792
        sprintf(out___0, (char const   *)"+infnty");
      }
    } else
#line 793
    if (value == 32766) {
#line 793
      if (wtm) {
#line 794
        sprintf(out___0, (char const   *)"Mate");
      } else {
#line 793
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 795
    if (value == 32766) {
#line 795
      if (! wtm) {
#line 796
        sprintf(out___0, (char const   *)"-Mate");
      } else {
#line 795
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 797
    if (value == -32767) {
#line 797
      if (wtm) {
#line 798
        sprintf(out___0, (char const   *)"-Mate");
      } else {
#line 797
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 799
    if (value == -32767) {
#line 799
      if (! wtm) {
#line 800
        sprintf(out___0, (char const   *)"Mate");
      } else {
#line 799
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 801
    if (value > 0) {
#line 801
      if (wtm) {
#line 802
        sprintf(out___0, (char const   *)"Mat%.2d", (32768 - value) / 2);
      } else {
#line 801
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 803
    if (value > 0) {
#line 803
      if (! wtm) {
#line 804
        sprintf(out___0, (char const   *)"-Mat%.2d", (32768 - value) / 2);
      } else {
#line 803
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 805
    if (wtm) {
#line 806
      if (value > 0) {
#line 806
        tmp = value;
      } else {
#line 806
        tmp = - value;
      }
#line 806
      sprintf(out___0, (char const   *)"-Mat%.2d", (32768 - tmp) / 2);
    } else {
#line 808
      if (value > 0) {
#line 808
        tmp___0 = value;
      } else {
#line 808
        tmp___0 = - value;
      }
#line 808
      sprintf(out___0, (char const   *)"Mat%.2d", (32768 - tmp___0) / 2);
    }
  } else {
#line 787
    sprintf(out___0, (char const   *)"%+.2f", (double )((float )tvalue) / 100.0);
  }
#line 809
  return (out___0);
}
}
#line 820 "utility.c"
static char buffer___0[4096]  ;
#line 819 "utility.c"
char *DisplayPath(TREE *tree , int wtm , PATH *pv ) 
{ 
  int i ;
  int t_move_number ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 830
  t_move_number = move_number;
#line 831
  sprintf(buffer___0, (char const   *)" %d.", move_number);
#line 832
  if (! wtm) {
#line 833
    tmp = strlen((char const   *)(buffer___0));
#line 833
    sprintf(buffer___0 + tmp, (char const   *)" ...");
  }
#line 834
  i = 1;
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if (! (i < pv->pathl)) {
#line 834
      goto while_break;
    }
#line 835
    if (i > 1) {
#line 835
      if (wtm) {
#line 836
        tmp___0 = strlen((char const   *)(buffer___0));
#line 836
        sprintf(buffer___0 + tmp___0, (char const   *)" %d.", t_move_number);
      } else {
#line 835
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 837
    tmp___1 = OutputMove(tree, i, wtm, pv->path[i]);
#line 837
    tmp___2 = strlen((char const   *)(buffer___0));
#line 837
    sprintf(buffer___0 + tmp___2, (char const   *)" %s", tmp___1);
#line 839
    MakeMove(tree, i, wtm, pv->path[i]);
#line 840
    wtm ^= 1;
#line 841
    if (wtm) {
#line 842
      t_move_number ++;
    }
#line 834
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 844
  if (pv->pathh == 1) {
#line 845
    tmp___3 = strlen((char const   *)(buffer___0));
#line 845
    sprintf(buffer___0 + tmp___3, (char const   *)" <HT>");
  } else
#line 846
  if (pv->pathh == 2) {
#line 847
    tmp___4 = strlen((char const   *)(buffer___0));
#line 847
    sprintf(buffer___0 + tmp___4, (char const   *)" <3-fold>");
  } else
#line 848
  if (pv->pathh == 3) {
#line 849
    tmp___5 = strlen((char const   *)(buffer___0));
#line 849
    sprintf(buffer___0 + tmp___5, (char const   *)" <50-move>");
  } else
#line 850
  if (pv->pathh == 4) {
#line 851
    tmp___6 = strlen((char const   *)(buffer___0));
#line 851
    sprintf(buffer___0 + tmp___6, (char const   *)" <EGTB>");
  }
#line 852
  tmp___8 = strlen((char const   *)(buffer___0));
#line 852
  if (tmp___8 < 30UL) {
#line 853
    i = 0;
    {
#line 853
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 853
      tmp___7 = strlen((char const   *)(buffer___0));
#line 853
      if (! ((size_t )i < 30UL - tmp___7)) {
#line 853
        goto while_break___0;
      }
#line 854
      strcat(buffer___0, (char const   *)" ");
#line 853
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 855
  strcpy(kibitz_text, (char const   *)(buffer___0));
#line 856
  i = pv->pathl - 1;
  {
#line 856
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 856
    if (! (i > 0)) {
#line 856
      goto while_break___1;
    }
#line 857
    wtm ^= 1;
#line 858
    UnmakeMove(tree, i, wtm, pv->path[i]);
#line 856
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 860
  return (buffer___0);
}
}
#line 871 "utility.c"
void DisplayFail(TREE *tree , int type , int level , int wtm , int time___0 , int move ,
                 int value , int force___0 ) 
{ 
  char buffer___3[4096] ;
  char *fh_indicator ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 884
  if ((unsigned int )time___0 < noise_level) {
#line 885
    return;
  }
#line 886
  if (type == 1) {
#line 887
    if (wtm) {
#line 887
      fh_indicator = "++";
    } else {
#line 887
      fh_indicator = "--";
    }
  } else
#line 889
  if (wtm) {
#line 889
    fh_indicator = "--";
  } else {
#line 889
    fh_indicator = "++";
  }
#line 890
  tmp = Display2Times(end_time - start_time);
#line 890
  Print(4, "         %2i   %s     %2s   ", iteration, tmp, fh_indicator);
#line 902
  if (! pondering) {
#line 903
    sprintf(buffer___3, (char const   *)"%d.", move_number);
#line 904
    if (! wtm) {
#line 905
      tmp___0 = strlen((char const   *)(buffer___3));
#line 905
      sprintf(buffer___3 + tmp___0, (char const   *)" ...");
    }
  } else
#line 907
  if (wtm) {
#line 908
    sprintf(buffer___3, (char const   *)"%d. ... (%s) %d.", move_number - 1, ponder_text,
            move_number);
  } else {
#line 911
    sprintf(buffer___3, (char const   *)"%d. (%s)", move_number, ponder_text);
  }
#line 913
  if (type == 1) {
#line 913
    tmp___1 = '!';
  } else {
#line 913
    tmp___1 = '?';
  }
#line 913
  tmp___2 = OutputMove(tree, 1, wtm, move);
#line 913
  tmp___3 = strlen((char const   *)(buffer___3));
#line 913
  sprintf(buffer___3 + tmp___3, (char const   *)" %s%c", tmp___2, tmp___1);
#line 915
  strcpy(kibitz_text, (char const   *)(buffer___3));
#line 916
  if ((unsigned int )time___0 >= noise_level) {
#line 916
    goto _L;
  } else
#line 916
  if (force___0) {
    _L: /* CIL Label */ 
#line 917
    noise_block = 0;
#line 918
    LockX86(& lock_io);
#line 919
    Print(4, "%s", buffer___3);
#line 920
    UnlockX86(& lock_io);
#line 921
    if (type == 1) {
#line 922
      tmp___4 = DisplayEvaluationKibitz(value, wtm);
#line 922
      if (wtm) {
#line 922
        tmp___5 = '>';
      } else {
#line 922
        tmp___5 = '<';
      }
#line 922
      Print(4, " (%c%s)                   \n", tmp___5, tmp___4);
    } else {
#line 925
      tmp___6 = DisplayEvaluationKibitz(value, wtm);
#line 925
      if (wtm) {
#line 925
        tmp___7 = '<';
      } else {
#line 925
        tmp___7 = '>';
      }
#line 925
      Print(4, " (%c%s)                   \n", tmp___7, tmp___6);
    }
  }
#line 928
  return;
}
}
#line 937 "utility.c"
void DisplayPV(TREE *tree , int level , int wtm , int time___0 , PATH *pv , int force___0 ) 
{ 
  char buffer___3[4096] ;
  char *buffp ;
  char *bufftemp ;
  char blanks[40] ;
  int i ;
  int len ;
  int t_move_number ;
  int nskip ;
  int twtm ;
  int pv_depth ;
  unsigned int idle_time ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;

  {
#line 940
  blanks[0] = (char )' ';
#line 940
  blanks[1] = (char )' ';
#line 940
  blanks[2] = (char )' ';
#line 940
  blanks[3] = (char )' ';
#line 940
  blanks[4] = (char )' ';
#line 940
  blanks[5] = (char )' ';
#line 940
  blanks[6] = (char )' ';
#line 940
  blanks[7] = (char )' ';
#line 940
  blanks[8] = (char )' ';
#line 940
  blanks[9] = (char )' ';
#line 940
  blanks[10] = (char )' ';
#line 940
  blanks[11] = (char )' ';
#line 940
  blanks[12] = (char )' ';
#line 940
  blanks[13] = (char )' ';
#line 940
  blanks[14] = (char )' ';
#line 940
  blanks[15] = (char )' ';
#line 940
  blanks[16] = (char )' ';
#line 940
  blanks[17] = (char )' ';
#line 940
  blanks[18] = (char )' ';
#line 940
  blanks[19] = (char )' ';
#line 940
  blanks[20] = (char )' ';
#line 940
  blanks[21] = (char )' ';
#line 940
  blanks[22] = (char )' ';
#line 940
  blanks[23] = (char )' ';
#line 940
  blanks[24] = (char )' ';
#line 940
  blanks[25] = (char )' ';
#line 940
  blanks[26] = (char )' ';
#line 940
  blanks[27] = (char )' ';
#line 940
  blanks[28] = (char )' ';
#line 940
  blanks[29] = (char )' ';
#line 940
  blanks[30] = (char )' ';
#line 940
  blanks[31] = (char )' ';
#line 940
  blanks[32] = (char )' ';
#line 940
  blanks[33] = (char )' ';
#line 940
  blanks[34] = (char )' ';
#line 940
  blanks[35] = (char )' ';
#line 940
  blanks[36] = (char )' ';
#line 940
  blanks[37] = (char )' ';
#line 940
  blanks[38] = (char )' ';
#line 940
  blanks[39] = (char )' ';
#line 941
  nskip = 0;
#line 941
  twtm = wtm;
#line 941
  pv_depth = pv->pathd;
#line 951
  i = 0;
  {
#line 951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 951
    if (! (i < n_root_moves)) {
#line 951
      goto while_break;
    }
#line 952
    if (root_moves[i].status & 4U) {
#line 953
      nskip ++;
    }
#line 951
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 954
  i = 0;
  {
#line 954
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 954
    if (! (i < 4096)) {
#line 954
      goto while_break___0;
    }
#line 955
    buffer___3[i] = (char )' ';
#line 954
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 956
  t_move_number = move_number;
#line 957
  if (! pondering) {
#line 957
    goto _L;
  } else
#line 957
  if (analyze_mode) {
    _L: /* CIL Label */ 
#line 958
    sprintf(buffer___3, (char const   *)"%d.", move_number);
#line 959
    if (! wtm) {
#line 960
      tmp = strlen((char const   *)(buffer___3));
#line 960
      sprintf(buffer___3 + tmp, (char const   *)" ...");
    }
  } else
#line 962
  if (wtm) {
#line 963
    sprintf(buffer___3, (char const   *)"%d. ... (%s) %d.", move_number - 1, ponder_text,
            move_number);
  } else {
#line 966
    sprintf(buffer___3, (char const   *)"%d. (%s)", move_number, ponder_text);
  }
#line 968
  i = 1;
  {
#line 968
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 968
    if (! (i < pv->pathl)) {
#line 968
      goto while_break___1;
    }
#line 969
    if (i > 1) {
#line 969
      if (wtm) {
#line 970
        tmp___0 = strlen((char const   *)(buffer___3));
#line 970
        sprintf(buffer___3 + tmp___0, (char const   *)" %d.", t_move_number);
      } else {
#line 969
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 971
    tmp___1 = OutputMove(tree, i, wtm, pv->path[i]);
#line 971
    tmp___2 = strlen((char const   *)(buffer___3));
#line 971
    sprintf(buffer___3 + tmp___2, (char const   *)" %s", tmp___1);
#line 973
    MakeMove(tree, i, wtm, pv->path[i]);
#line 974
    wtm ^= 1;
#line 975
    if (wtm) {
#line 976
      t_move_number ++;
    }
#line 968
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 978
  if (pv->pathh == 1) {
#line 979
    tmp___3 = strlen((char const   *)(buffer___3));
#line 979
    sprintf(buffer___3 + tmp___3, (char const   *)" <HT>");
  } else
#line 980
  if (pv->pathh == 2) {
#line 981
    tmp___4 = strlen((char const   *)(buffer___3));
#line 981
    sprintf(buffer___3 + tmp___4, (char const   *)" <3-fold>");
  } else
#line 982
  if (pv->pathh == 3) {
#line 983
    tmp___5 = strlen((char const   *)(buffer___3));
#line 983
    sprintf(buffer___3 + tmp___5, (char const   *)" <50-move>");
  } else
#line 984
  if (pv->pathh == 4) {
#line 985
    tmp___6 = strlen((char const   *)(buffer___3));
#line 985
    sprintf(buffer___3 + tmp___6, (char const   *)" <EGTB>");
  }
#line 986
  if (nskip > 1) {
#line 986
    if (smp_max_threads > 1U) {
#line 987
      tmp___7 = strlen((char const   *)(buffer___3));
#line 987
      sprintf(buffer___3 + tmp___7, (char const   *)" (s=%d)", nskip);
    } else {
#line 986
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 988
  tmp___9 = strlen((char const   *)(buffer___3));
#line 988
  if (tmp___9 < 30UL) {
#line 989
    tmp___8 = strlen((char const   *)(buffer___3));
#line 989
    len = (int )(30UL - tmp___8);
#line 990
    i = 0;
    {
#line 990
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 990
      if (! (i < len)) {
#line 990
        goto while_break___2;
      }
#line 991
      strcat(buffer___3, (char const   *)" ");
#line 990
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 993
  strcpy(kibitz_text, (char const   *)(buffer___3));
#line 994
  if ((unsigned int )time___0 >= noise_level) {
#line 994
    goto _L___2;
  } else
#line 994
  if (force___0) {
    _L___2: /* CIL Label */ 
#line 995
    noise_block = 0;
#line 996
    LockX86(& lock_io);
#line 997
    Print(2, "         ");
#line 998
    if (level == 6) {
#line 999
      tmp___10 = DisplayEvaluation(pv->pathv, twtm);
#line 999
      tmp___11 = Display2Times((unsigned int )time___0);
#line 999
      Print(2, "%2i   %s%s   ", pv_depth, tmp___11, tmp___10);
    } else {
#line 1002
      tmp___12 = DisplayEvaluation(pv->pathv, twtm);
#line 1002
      tmp___13 = Display2Times((unsigned int )time___0);
#line 1002
      Print(2, "%2i-> %s%s   ", pv_depth, tmp___13, tmp___12);
    }
#line 1004
    buffp = buffer___3;
    {
#line 1005
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1006
      tmp___14 = strlen((char const   *)buffp);
#line 1006
      if ((int )tmp___14 > line_length - 38) {
#line 1007
        bufftemp = (buffp + line_length) - 38;
        {
#line 1008
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1008
          if (! ((int )*bufftemp != 32)) {
#line 1008
            goto while_break___4;
          }
#line 1009
          bufftemp --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1010
        if ((int )*(bufftemp - 1) == 46) {
          {
#line 1011
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1011
            bufftemp --;
#line 1011
            if (! ((int )*bufftemp != 32)) {
#line 1011
              goto while_break___5;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      } else {
#line 1013
        bufftemp = (char *)0;
      }
#line 1014
      if (bufftemp) {
#line 1015
        *bufftemp = (char)0;
      }
#line 1016
      Print(2, "%s\n", buffp);
#line 1017
      buffp = bufftemp + 1;
#line 1018
      if (bufftemp) {
#line 1019
        tmp___15 = strlen((char const   *)buffp);
#line 1019
        tmp___16 = strncmp((char const   *)buffp, (char const   *)(blanks), tmp___15);
#line 1019
        if (! tmp___16) {
#line 1020
          bufftemp = (char *)0;
        }
      }
#line 1021
      if (bufftemp) {
#line 1022
        Print(2, "                                     ");
      }
#line 1005
      if (! bufftemp) {
#line 1005
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1024
    idle_time = 0U;
#line 1025
    i = 0;
    {
#line 1025
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1025
      if (! ((unsigned int )i < smp_max_threads)) {
#line 1025
        goto while_break___6;
      }
#line 1026
      idle_time += thread[i].idle;
#line 1025
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1027
    if (100U < (100U * idle_time) / (smp_max_threads * (end_time - start_time) + 1U)) {
#line 1027
      tmp___17 = 100U;
    } else {
#line 1027
      tmp___17 = (100U * idle_time) / (smp_max_threads * (end_time - start_time) + 1U);
    }
#line 1027
    busy_percent = 100U - tmp___17;
#line 1030
    Kibitz(level, twtm, pv_depth, (int )(end_time - start_time), pv->pathv, tree->nodes_searched,
           (int )busy_percent, (int )tree->egtb_hits, kibitz_text);
#line 1032
    UnlockX86(& lock_io);
  }
#line 1034
  i = pv->pathl - 1;
  {
#line 1034
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1034
    if (! (i > 0)) {
#line 1034
      goto while_break___7;
    }
#line 1035
    wtm ^= 1;
#line 1036
    UnmakeMove(tree, i, wtm, pv->path[i]);
#line 1034
    i --;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1038
  return;
}
}
#line 1050 "utility.c"
static char out___1[32]  ;
#line 1049 "utility.c"
char *DisplayHHMMSS(unsigned int time___0 ) 
{ 


  {
#line 1052
  time___0 /= 100U;
#line 1053
  sprintf(out___1, (char const   *)"%3u:%02u:%02u", time___0 / 3600U, (time___0 % 3600U) / 60U,
          time___0 % 60U);
#line 1054
  return (out___1);
}
}
#line 1067 "utility.c"
static char out___2[10]  ;
#line 1066 "utility.c"
char *DisplayHHMM(unsigned int time___0 ) 
{ 


  {
#line 1069
  time___0 /= 6000U;
#line 1070
  sprintf(out___2, (char const   *)"%3u:%02u", time___0 / 60U, time___0 % 60U);
#line 1071
  return (out___2);
}
}
#line 1085 "utility.c"
static char out___3[10]  ;
#line 1084 "utility.c"
char *DisplayKMB(uint64_t val , int type ) 
{ 


  {
#line 1087
  if (type == 0) {
#line 1088
    if (val < 1000UL) {
#line 1089
      sprintf(out___3, (char const   *)"%lu", val);
    } else
#line 1090
    if (val < 1000000UL) {
#line 1091
      sprintf(out___3, (char const   *)"%.1fK", (double )val / (double )1000);
    } else
#line 1092
    if (val < 1000000000UL) {
#line 1093
      sprintf(out___3, (char const   *)"%.1fM", (double )val / (double )1000000);
    } else {
#line 1095
      sprintf(out___3, (char const   *)"%.1fB", (double )val / (double )1000000000);
    }
  } else
#line 1097
  if (val > 0UL) {
#line 1097
    if (! ((unsigned long long )val & 0x000000003fffffffULL)) {
#line 1098
      sprintf(out___3, (char const   *)"%dG", (int )(val / (uint64_t )(1 << 30)));
    } else {
#line 1097
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1099
  if (val > 0UL) {
#line 1099
    if (! ((unsigned long long )val & 0x00000000000fffffULL)) {
#line 1100
      sprintf(out___3, (char const   *)"%dM", (int )(val / (uint64_t )(1 << 20)));
    } else {
#line 1099
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1101
  if (val > 0UL) {
#line 1101
    if (! ((unsigned long long )val & 0x00000000000003ffULL)) {
#line 1102
      sprintf(out___3, (char const   *)"%dK", (int )(val / (uint64_t )(1 << 10)));
    } else {
#line 1101
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1104
    sprintf(out___3, (char const   *)"%lu", val);
  }
#line 1106
  return (out___3);
}
}
#line 1122 "utility.c"
static char out___4[10]  ;
#line 1121 "utility.c"
char *DisplayTime(unsigned int time___0 ) 
{ 


  {
#line 1124
  if (time___0 < 6000U) {
#line 1125
    sprintf(out___4, (char const   *)"%6.2f", (double )((float )time___0) / 100.0);
  } else {
#line 1127
    time___0 /= 100U;
#line 1128
    sprintf(out___4, (char const   *)"%3u:%02u", time___0 / 60U, time___0 % 60U);
  }
#line 1130
  return (out___4);
}
}
#line 1151 "utility.c"
static char out___5[20]  ;
#line 1151 "utility.c"
static char tout[10]  ;
#line 1149 "utility.c"
char *Display2Times(unsigned int time___0 ) 
{ 
  int ttime ;
  int c ;
  int spaces ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 1153
  if (time___0 < 6000U) {
#line 1154
    sprintf(out___5, (char const   *)"%6.2f", (double )((float )time___0) / 100.0);
  } else {
#line 1156
    time___0 /= 100U;
#line 1157
    sprintf(out___5, (char const   *)"%3u:%02u", time___0 / 60U, time___0 % 60U);
  }
#line 1159
  if (search_time_limit) {
#line 1160
    ttime = search_time_limit;
  } else {
#line 1162
    ttime = (difficulty * time_limit) / 100;
  }
#line 1163
  if (ttime < 360000) {
#line 1164
    if (ttime < 6000) {
#line 1165
      sprintf(tout, (char const   *)"%6.2f", (double )((float )ttime) / 100.0);
    } else {
#line 1167
      ttime /= 100;
#line 1168
      sprintf(tout, (char const   *)"%3u:%02u", ttime / 60, ttime % 60);
    }
#line 1170
    tmp = strspn((char const   *)(tout), (char const   *)" ");
#line 1170
    c = (int )tmp;
#line 1171
    strcat(out___5, (char const   *)"/");
#line 1172
    strcat(out___5, (char const   *)(tout + c));
  } else {
#line 1174
    strcat(out___5, (char const   *)"       ");
  }
#line 1175
  tmp___0 = strlen((char const   *)(out___5));
#line 1175
  spaces = (int )(13UL - tmp___0);
#line 1176
  c = 0;
  {
#line 1176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1176
    if (! (c < spaces)) {
#line 1176
      goto while_break;
    }
#line 1177
    strcat(out___5, (char const   *)" ");
#line 1176
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1178
  return (out___5);
}
}
#line 1191 "utility.c"
static char out___6[10]  ;
#line 1190 "utility.c"
char *DisplayTimeKibitz(unsigned int time___0 ) 
{ 


  {
#line 1193
  if (time___0 < 6000U) {
#line 1194
    sprintf(out___6, (char const   *)"%.2f", (double )((float )time___0) / 100.0);
  } else {
#line 1196
    time___0 /= 100U;
#line 1197
    sprintf(out___6, (char const   *)"%u:%02u", time___0 / 60U, time___0 % 60U);
  }
#line 1199
  return (out___6);
}
}
#line 1212 "utility.c"
static char buffer___1[4096]  ;
#line 1210 "utility.c"
char *FormatPV(TREE *tree , int wtm , PATH pv ) 
{ 
  int i ;
  int t_move_number ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 1221
  t_move_number = move_number;
#line 1222
  sprintf(buffer___1, (char const   *)" %d.", move_number);
#line 1223
  if (! wtm) {
#line 1224
    tmp = strlen((char const   *)(buffer___1));
#line 1224
    sprintf(buffer___1 + tmp, (char const   *)" ...");
  }
#line 1225
  i = 1;
  {
#line 1225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1225
    if (! (i < pv.pathl)) {
#line 1225
      goto while_break;
    }
#line 1226
    if (i > 1) {
#line 1226
      if (wtm) {
#line 1227
        tmp___0 = strlen((char const   *)(buffer___1));
#line 1227
        sprintf(buffer___1 + tmp___0, (char const   *)" %d.", t_move_number);
      } else {
#line 1226
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 1228
    tmp___1 = OutputMove(tree, i, wtm, pv.path[i]);
#line 1228
    tmp___2 = strlen((char const   *)(buffer___1));
#line 1228
    sprintf(buffer___1 + tmp___2, (char const   *)" %s", tmp___1);
#line 1230
    MakeMove(tree, i, wtm, pv.path[i]);
#line 1231
    wtm ^= 1;
#line 1232
    if (wtm) {
#line 1233
      t_move_number ++;
    }
#line 1225
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  i = pv.pathl - 1;
  {
#line 1235
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1235
    if (! (i > 0)) {
#line 1235
      goto while_break___0;
    }
#line 1236
    wtm ^= 1;
#line 1237
    UnmakeMove(tree, i, wtm, pv.path[i]);
#line 1235
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1239
  return (buffer___1);
}
}
#line 1253 "utility.c"
int GameOver(int wtm ) 
{ 
  TREE *tree ;
  unsigned int *mvp ;
  unsigned int *lastm ;
  unsigned int rmoves[256] ;
  unsigned int over___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 1254
  tree = (TREE *)block[0];
#line 1255
  over___0 = 1U;
#line 1265
  lastm = GenerateCaptures((TREE *)tree, 1, wtm, rmoves);
#line 1266
  lastm = GenerateNoncaptures((TREE *)tree, 1, wtm, lastm);
#line 1277
  mvp = rmoves;
  {
#line 1277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1277
    if (! ((unsigned long )mvp < (unsigned long )lastm)) {
#line 1277
      goto while_break;
    }
#line 1278
    MakeMove((TREE *)tree, 1, wtm, (int )*mvp);
#line 1279
    tmp = Attacks((TREE *)tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 1279
    if (! tmp) {
#line 1280
      over___0 = 0U;
    }
#line 1281
    UnmakeMove((TREE *)tree, 1, wtm, (int )*mvp);
#line 1277
    mvp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1294
  if (! over___0) {
#line 1295
    return (0);
  } else {
#line 1296
    tmp___0 = Attacks((TREE *)tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 1296
    if (tmp___0) {
#line 1299
      return (2);
    } else {
#line 1297
      return (1);
    }
  }
}
}
#line 1311 "utility.c"
unsigned int ReadClock(void) 
{ 
  struct timeval timeval ;
  struct timezone timezone___0 ;

  {
#line 1317
  gettimeofday((struct timeval * __restrict  )(& timeval), (void * __restrict  )(& timezone___0));
#line 1318
  return ((unsigned int )(timeval.tv_sec * 100L + timeval.tv_usec / 10000L));
}
}
#line 1332 "utility.c"
int FindBlockID(TREE *which ) 
{ 
  int i ;

  {
#line 1335
  i = 0;
  {
#line 1335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1335
    if (! ((unsigned int )i <= smp_max_threads * 64U)) {
#line 1335
      goto while_break;
    }
#line 1336
    if ((unsigned long )which == (unsigned long )block[i]) {
#line 1337
      return (i);
    }
#line 1335
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1338
  return (-1);
}
}
#line 1351 "utility.c"
int InvalidPosition(TREE *tree ) 
{ 
  int error ;
  int wp ;
  int wn ;
  int wb ;
  int wr ;
  int wq ;
  int wk ;
  int bp ;
  int bn ;
  int bb ;
  int br ;
  int bq ;
  int bk ;
  int tmp ;

  {
#line 1352
  error = 0;
#line 1354
  wp = __builtin_popcountll((unsigned long long )tree->position.color[1].pieces[1]);
#line 1355
  wn = __builtin_popcountll((unsigned long long )tree->position.color[1].pieces[2]);
#line 1356
  wb = __builtin_popcountll((unsigned long long )tree->position.color[1].pieces[3]);
#line 1357
  wr = __builtin_popcountll((unsigned long long )tree->position.color[1].pieces[4]);
#line 1358
  wq = __builtin_popcountll((unsigned long long )tree->position.color[1].pieces[5]);
#line 1359
  wk = __builtin_popcountll((unsigned long long )tree->position.color[1].pieces[6]);
#line 1360
  bp = __builtin_popcountll((unsigned long long )tree->position.color[0].pieces[1]);
#line 1361
  bn = __builtin_popcountll((unsigned long long )tree->position.color[0].pieces[2]);
#line 1362
  bb = __builtin_popcountll((unsigned long long )tree->position.color[0].pieces[3]);
#line 1363
  br = __builtin_popcountll((unsigned long long )tree->position.color[0].pieces[4]);
#line 1364
  bq = __builtin_popcountll((unsigned long long )tree->position.color[0].pieces[5]);
#line 1365
  bk = __builtin_popcountll((unsigned long long )tree->position.color[0].pieces[6]);
#line 1366
  if (wp > 8) {
#line 1367
    Print(4095, "illegal position, too many white pawns\n");
#line 1368
    error = 1;
  }
#line 1370
  if (wn) {
#line 1370
    if (wp + wn > 10) {
#line 1371
      Print(4095, "illegal position, too many white knights\n");
#line 1372
      error = 1;
    } else {
#line 1370
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 1374
  if (wb) {
#line 1374
    if (wp + wb > 10) {
#line 1375
      Print(4095, "illegal position, too many white bishops\n");
#line 1376
      error = 1;
    } else {
#line 1374
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 1378
  if (wr) {
#line 1378
    if (wp + wr > 10) {
#line 1379
      Print(4095, "illegal position, too many white rooks\n");
#line 1380
      error = 1;
    } else {
#line 1378
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 1382
  if (wq) {
#line 1382
    if (wp + wq > 10) {
#line 1383
      Print(4095, "illegal position, too many white queens\n");
#line 1384
      error = 1;
    } else {
#line 1382
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ ;
  }
#line 1386
  if (wk == 0) {
#line 1387
    Print(4095, "illegal position, no white king\n");
#line 1388
    error = 1;
  }
#line 1390
  if (wk > 1) {
#line 1391
    Print(4095, "illegal position, multiple white kings\n");
#line 1392
    error = 1;
  }
#line 1394
  if (((wn + wb) + wr) + wq) {
#line 1394
    if ((((wp + wn) + wb) + wr) + wq > 15) {
#line 1395
      Print(4095, "illegal position, too many white pieces\n");
#line 1396
      error = 1;
    } else {
#line 1394
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ ;
  }
#line 1398
  if (tree->position.color[1].pieces[1] & (rank_mask[0] | rank_mask[7])) {
#line 1399
    Print(4095, "illegal position, white pawns on first/eighth rank(s)\n");
#line 1400
    error = 1;
  }
#line 1402
  if (bp > 8) {
#line 1403
    Print(4095, "illegal position, too many black pawns\n");
#line 1404
    error = 1;
  }
#line 1406
  if (bn) {
#line 1406
    if (bp + bn > 10) {
#line 1407
      Print(4095, "illegal position, too many black knights\n");
#line 1408
      error = 1;
    } else {
#line 1406
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ ;
  }
#line 1410
  if (bb) {
#line 1410
    if (bp + bb > 10) {
#line 1411
      Print(4095, "illegal position, too many black bishops\n");
#line 1412
      error = 1;
    } else {
#line 1410
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ ;
  }
#line 1414
  if (br) {
#line 1414
    if (bp + br > 10) {
#line 1415
      Print(4095, "illegal position, too many black rooks\n");
#line 1416
      error = 1;
    } else {
#line 1414
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ ;
  }
#line 1418
  if (bq) {
#line 1418
    if (bp + bq > 10) {
#line 1419
      Print(4095, "illegal position, too many black queens\n");
#line 1420
      error = 1;
    } else {
#line 1418
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ ;
  }
#line 1422
  if (bk == 0) {
#line 1423
    Print(4095, "illegal position, no black king\n");
#line 1424
    error = 1;
  }
#line 1426
  if (bk > 1) {
#line 1427
    Print(4095, "illegal position, multiple black kings\n");
#line 1428
    error = 1;
  }
#line 1430
  if (((bn + bb) + br) + bq) {
#line 1430
    if ((((bp + bn) + bb) + br) + bq > 15) {
#line 1431
      Print(4095, "illegal position, too many black pieces\n");
#line 1432
      error = 1;
    } else {
#line 1430
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ ;
  }
#line 1434
  if (tree->position.color[0].pieces[1] & (rank_mask[0] | rank_mask[7])) {
#line 1435
    Print(4095, "illegal position, black pawns on first/eighth rank(s)\n");
#line 1436
    error = 1;
  }
#line 1438
  if (error == 0) {
#line 1438
    tmp = Attacks(tree, ! game_wtm ^ 1, tree->position.kingsq[! game_wtm]);
#line 1438
    if (tmp) {
#line 1439
      Print(4095, "ERROR side not on move is in check!\n");
#line 1440
      error = 1;
    } else {
#line 1438
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ ;
  }
#line 1442
  return (error);
}
}
#line 1454 "utility.c"
int KingPawnSquare(int pawn___0 , int king___0 , int queen___0 , int ptm ) 
{ 
  int pdist ;
  int kdist ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1457
  if ((pawn___0 >> 3) - (queen___0 >> 3) > 0) {
#line 1457
    tmp = (pawn___0 >> 3) - (queen___0 >> 3);
  } else {
#line 1457
    tmp = - ((pawn___0 >> 3) - (queen___0 >> 3));
  }
#line 1457
  pdist = tmp + ! ptm;
#line 1458
  tmp___4 = abs((king___0 & 7) - (queen___0 & 7));
#line 1458
  tmp___5 = abs((king___0 >> 3) - (queen___0 >> 3));
#line 1458
  if (tmp___4 > tmp___5) {
#line 1458
    tmp___2 = abs((king___0 & 7) - (queen___0 & 7));
#line 1458
    kdist = tmp___2;
  } else {
#line 1458
    tmp___3 = abs((king___0 >> 3) - (queen___0 >> 3));
#line 1458
    kdist = tmp___3;
  }
#line 1459
  return (pdist >= kdist);
}
}
#line 1473 "utility.c"
int Mated(TREE *tree , int ply , int wtm ) 
{ 
  unsigned int rmoves[256] ;
  unsigned int *mvp ;
  unsigned int *lastm ;
  int temp ;
  int tmp ;

  {
#line 1475
  temp = 0;
#line 1486
  lastm = GenerateCaptures(tree, ply, wtm, rmoves);
#line 1487
  lastm = GenerateNoncaptures(tree, ply, wtm, lastm);
#line 1496
  mvp = rmoves;
  {
#line 1496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1496
    if (! ((unsigned long )mvp < (unsigned long )lastm)) {
#line 1496
      goto while_break;
    }
#line 1497
    MakeMove(tree, ply, wtm, (int )*mvp);
#line 1498
    temp = Attacks(tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 1499
    UnmakeMove(tree, ply, wtm, (int )*mvp);
#line 1500
    if (! temp) {
#line 1501
      goto while_break;
    }
#line 1496
    mvp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1511
  if (! temp) {
#line 1512
    return (0);
  }
#line 1521
  tmp = Attacks(tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 1521
  if (tmp) {
#line 1522
    return (1);
  }
#line 1523
  return (2);
}
}
#line 1535 "utility.c"
int ParseTime(char *string ) 
{ 
  int time___0 ;
  int minutes ;

  {
#line 1536
  time___0 = 0;
#line 1536
  minutes = 0;
  {
#line 1538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1538
    if (! *string) {
#line 1538
      goto while_break;
    }
    {
#line 1549
    if ((int )*string == 57) {
#line 1549
      goto case_57;
    }
#line 1549
    if ((int )*string == 56) {
#line 1549
      goto case_57;
    }
#line 1549
    if ((int )*string == 55) {
#line 1549
      goto case_57;
    }
#line 1549
    if ((int )*string == 54) {
#line 1549
      goto case_57;
    }
#line 1549
    if ((int )*string == 53) {
#line 1549
      goto case_57;
    }
#line 1549
    if ((int )*string == 52) {
#line 1549
      goto case_57;
    }
#line 1549
    if ((int )*string == 51) {
#line 1549
      goto case_57;
    }
#line 1549
    if ((int )*string == 50) {
#line 1549
      goto case_57;
    }
#line 1549
    if ((int )*string == 49) {
#line 1549
      goto case_57;
    }
#line 1549
    if ((int )*string == 48) {
#line 1549
      goto case_57;
    }
#line 1552
    if ((int )*string == 58) {
#line 1552
      goto case_58;
    }
#line 1556
    goto switch_default;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 1550
    minutes = (minutes * 10 + (int )*string) - 48;
#line 1551
    goto switch_break;
    case_58: /* CIL Label */ 
#line 1553
    time___0 = time___0 * 60 + minutes;
#line 1554
    minutes = 0;
#line 1555
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1557
    Print(4095, "illegal character in time, please re-enter\n");
#line 1558
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1560
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1562
  return (time___0 * 60 + minutes);
}
}
#line 1575 "utility.c"
void Pass(void) 
{ 
  int halfmoves_done ;
  int prev_pass ;
  char buffer___3[128] ;
  int tmp ;
  int tmp___0 ;

  {
#line 1576
  halfmoves_done = (int )(2 * (move_number - 1) + (1 - game_wtm));
#line 1577
  prev_pass = 0;
#line 1581
  if (halfmoves_done > 0) {
#line 1582
    if (history_file) {
#line 1583
      fseek(history_file, (long )((halfmoves_done - 1) * 10), 0);
#line 1584
      tmp = fscanf(history_file, (char const   *)"%s", buffer___3);
#line 1584
      if (tmp == 0) {
#line 1584
        goto _L;
      } else {
#line 1584
        tmp___0 = strcmp((char const   *)(buffer___3), (char const   *)"pass");
#line 1584
        if (tmp___0 == 0) {
          _L: /* CIL Label */ 
#line 1586
          prev_pass = 1;
        }
      }
    }
  }
#line 1589
  if (prev_pass) {
#line 1590
    if (game_wtm) {
#line 1591
      move_number --;
    }
  } else {
#line 1593
    if (history_file) {
#line 1594
      fseek(history_file, (long )(halfmoves_done * 10), 0);
#line 1595
      fprintf(history_file, (char const   *)"%9s\n", "pass");
    }
#line 1597
    if (! game_wtm) {
#line 1598
      move_number ++;
    }
  }
#line 1600
  game_wtm ^= 1;
#line 1601
  return;
}
}
#line 1620 "utility.c"
void Print(int vb , char *fmt  , ...) 
{ 
  va_list ap ;

  {
#line 1623
  __builtin_va_start(ap, fmt);
#line 1624
  if (vb == 4095) {
#line 1624
    goto _L;
  } else
#line 1624
  if (vb & display_options) {
    _L: /* CIL Label */ 
#line 1625
    vprintf((char const   *)fmt, ap);
#line 1626
    fflush(stdout);
  }
#line 1628
  if (time_limit > 5) {
#line 1628
    goto _L___1;
  } else
#line 1628
  if (tc_time_remaining[root_wtm] > 1000) {
    _L___1: /* CIL Label */ 
#line 1628
    goto _L___0;
  } else
#line 1628
  if (vb == 4095) {
    _L___0: /* CIL Label */ 
#line 1629
    __builtin_va_start(ap, fmt);
#line 1630
    if (log_file) {
#line 1631
      vfprintf(log_file, (char const   *)fmt, ap);
#line 1632
      fflush(log_file);
    }
  }
#line 1635
  __builtin_va_end(ap);
#line 1636
  return;
}
}
#line 1654 "utility.c"
static uint64_t const   x[55]  = 
#line 1654
  {      (uint64_t const   )1410651636UL,      (uint64_t const   )3012776752UL,      (uint64_t const   )3497475623UL,      (uint64_t const   )2892145026UL, 
        (uint64_t const   )1571949714UL,      (uint64_t const   )3253082284UL,      (uint64_t const   )3489895018UL,      (uint64_t const   )387949491UL, 
        (uint64_t const   )2597396737UL,      (uint64_t const   )1981903553UL,      (uint64_t const   )3160251843UL,      (uint64_t const   )129444464UL, 
        (uint64_t const   )1851443344UL,      (uint64_t const   )4156445905UL,      (uint64_t const   )224604922UL,      (uint64_t const   )1455067070UL, 
        (uint64_t const   )3953493484UL,      (uint64_t const   )1460937157UL,      (uint64_t const   )2528362617UL,      (uint64_t const   )317430674UL, 
        (uint64_t const   )3229354360UL,      (uint64_t const   )117491133UL,      (uint64_t const   )832845075UL,      (uint64_t const   )1961600170UL, 
        (uint64_t const   )1321557429UL,      (uint64_t const   )747750121UL,      (uint64_t const   )545747446UL,      (uint64_t const   )810476036UL, 
        (uint64_t const   )503334515UL,      (uint64_t const   )4088144633UL,      (uint64_t const   )2824216555UL,      (uint64_t const   )3738252341UL, 
        (uint64_t const   )3493754131UL,      (uint64_t const   )3672533954UL,      (uint64_t const   )29494241UL,      (uint64_t const   )1180928407UL, 
        (uint64_t const   )4213624418UL,      (uint64_t const   )33062851UL,      (uint64_t const   )3221315737UL,      (uint64_t const   )1145213552UL, 
        (uint64_t const   )2957984897UL,      (uint64_t const   )4078668503UL,      (uint64_t const   )2262661702UL,      (uint64_t const   )65478801UL, 
        (uint64_t const   )2527208841UL,      (uint64_t const   )1960622036UL,      (uint64_t const   )315685891UL,      (uint64_t const   )1196037864UL, 
        (uint64_t const   )804614524UL,      (uint64_t const   )1421733266UL,      (uint64_t const   )2017105031UL,      (uint64_t const   )3882325900UL, 
        (uint64_t const   )810735053UL,      (uint64_t const   )384606609UL,      (uint64_t const   )2393861397UL};
#line 1667 "utility.c"
static int init  =    1;
#line 1668 "utility.c"
static uint64_t y[55]  ;
#line 1669 "utility.c"
static int j  ;
#line 1669 "utility.c"
static int k  ;
#line 1648 "utility.c"
unsigned int Random32(void) 
{ 
  uint64_t ul ;
  int i ;
  uint64_t tmp ;

  {
#line 1672
  if (init) {
#line 1675
    init = 0;
#line 1676
    i = 0;
    {
#line 1676
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1676
      if (! (i < 55)) {
#line 1676
        goto while_break;
      }
#line 1677
      y[i] = (uint64_t )x[i];
#line 1676
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1678
    j = 23;
#line 1679
    k = 54;
  }
#line 1681
  tmp = y[k] + y[j];
#line 1681
  y[k] = tmp;
#line 1681
  ul = tmp;
#line 1682
  j --;
#line 1682
  if (j < 0) {
#line 1683
    j = 54;
  }
#line 1684
  k --;
#line 1684
  if (k < 0) {
#line 1685
    k = 54;
  }
#line 1686
  return ((unsigned int )ul);
}
}
#line 1698 "utility.c"
uint64_t Random64(void) 
{ 
  uint64_t result ;
  unsigned int r1 ;
  unsigned int r2 ;

  {
#line 1702
  r1 = Random32();
#line 1703
  r2 = Random32();
#line 1704
  result = (unsigned long )r1 | ((uint64_t )r2 << 32);
#line 1705
  return (result);
}
}
#line 1716 "utility.c"
int Read(int wait___0 , char *buffer___3 ) 
{ 
  char *eol ;
  char *ret ;
  char readdata ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
#line 1719
  *buffer___3 = (char)0;
#line 1725
  tmp___4 = strchr((char const   *)(cmd_buffer), '\n');
#line 1725
  if (! tmp___4) {
#line 1733
    if (! wait___0) {
#line 1734
      tmp___1 = CheckInput();
#line 1734
      if (tmp___1) {
#line 1735
        tmp = ReadInput();
#line 1735
        readdata = (char )tmp;
#line 1736
        tmp___0 = strchr((char const   *)(cmd_buffer), '\n');
#line 1736
        if (! tmp___0) {
#line 1737
          return (0);
        }
#line 1738
        if (! readdata) {
#line 1739
          return (-1);
        }
      } else {
#line 1741
        return (0);
      }
    } else {
      {
#line 1750
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1750
        tmp___3 = strchr((char const   *)(cmd_buffer), '\n');
#line 1750
        if (tmp___3) {
#line 1750
          goto while_break;
        }
#line 1751
        tmp___2 = ReadInput();
#line 1751
        readdata = (char )tmp___2;
#line 1752
        if (! readdata) {
#line 1753
          return (-1);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1755
  eol = strchr((char const   *)(cmd_buffer), '\n');
#line 1756
  *eol = (char)0;
#line 1757
  ret = strchr((char const   *)(cmd_buffer), '\r');
#line 1758
  if (ret) {
#line 1759
    *ret = (char )' ';
  }
#line 1760
  strcpy(buffer___3, (char const   *)(cmd_buffer));
#line 1761
  tmp___5 = strlen((char const   *)(eol + 1));
#line 1761
  memmove((void *)(cmd_buffer), (void const   *)(eol + 1), tmp___5 + 1UL);
#line 1762
  return (1);
}
}
#line 1773 "utility.c"
void ReadClear(void) 
{ 


  {
#line 1774
  cmd_buffer[0] = (char)0;
#line 1775
  return;
}
}
#line 1786 "utility.c"
int ReadParse(char *buffer___3 , char **args___0 , char *delims ) 
{ 
  int nargs___0 ;
  char *next___0 ;
  char tbuffer[4096] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 1790
  strcpy(tbuffer, (char const   *)buffer___3);
#line 1791
  nargs___0 = 0;
  {
#line 1791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1791
    if (! (nargs___0 < 512)) {
#line 1791
      goto while_break;
    }
#line 1792
    *(*(args___0 + nargs___0)) = (char)0;
#line 1791
    nargs___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1793
  next___0 = strtok((char * __restrict  )(tbuffer), (char const   * __restrict  )delims);
#line 1794
  if (! next___0) {
#line 1795
    return (0);
  }
#line 1796
  tmp = strlen((char const   *)next___0);
#line 1796
  if (tmp > 255UL) {
#line 1797
    Print(4095, "ERROR, ignoring token %s, max allowable len = 255\n", next___0);
  } else {
#line 1799
    strcpy(*(args___0 + 0), (char const   *)next___0);
  }
#line 1800
  nargs___0 = 1;
  {
#line 1800
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1800
    if (! (nargs___0 < 512)) {
#line 1800
      goto while_break___0;
    }
#line 1801
    next___0 = strtok((char * __restrict  )0, (char const   * __restrict  )delims);
#line 1802
    if (! next___0) {
#line 1803
      goto while_break___0;
    }
#line 1804
    tmp___0 = strlen((char const   *)next___0);
#line 1804
    if (tmp___0 > 255UL) {
#line 1805
      Print(4095, "ERROR, ignoring token %s, max allowable len = 255\n", next___0);
    } else {
#line 1808
      strcpy(*(args___0 + nargs___0), (char const   *)next___0);
    }
#line 1800
    nargs___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1810
  return (nargs___0);
}
}
#line 1821 "utility.c"
int ReadInput(void) 
{ 
  int bytes ;
  char buffer___3[4096] ;
  char *end ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1825
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1826
    tmp = fileno(input_stream);
#line 1826
    tmp___0 = read(tmp, (void *)(buffer___3), (size_t )2048);
#line 1826
    bytes = (int )tmp___0;
#line 1825
    if (bytes < 0) {
#line 1825
      tmp___1 = __errno_location();
#line 1825
      if (! (*tmp___1 == 4)) {
#line 1825
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1825
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1828
  if (bytes == 0) {
#line 1829
    if ((unsigned long )input_stream != (unsigned long )stdin) {
#line 1830
      fclose(input_stream);
    }
#line 1831
    input_stream = stdin;
#line 1832
    return (0);
  } else
#line 1833
  if (bytes < 0) {
#line 1834
    Print(4095, "ERROR!  input I/O stream is unreadable, exiting.\n");
#line 1835
    CraftyExit(1);
  }
#line 1837
  tmp___2 = strlen((char const   *)(cmd_buffer));
#line 1837
  end = cmd_buffer + tmp___2;
#line 1838
  memcpy((void *)end, (void const   *)(buffer___3), (size_t )bytes);
#line 1839
  *(end + bytes) = (char)0;
#line 1840
  return (1);
}
}
#line 1854 "utility.c"
static char text[128]  ;
#line 1852 "utility.c"
int ReadChessMove(TREE *tree , FILE *input , int wtm , int one_move ) 
{ 
  int move ;
  int status___0 ;
  char *tmove ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1853
  move = 0;
  {
#line 1857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1857
    if (! (move == 0)) {
#line 1857
      goto while_break;
    }
#line 1858
    status___0 = fscanf(input, (char const   *)"%s", text);
#line 1859
    if (status___0 <= 0) {
#line 1860
      return (-1);
    }
#line 1861
    tmp___0 = strcmp((char const   *)(text), (char const   *)"0-0");
#line 1861
    if (tmp___0) {
#line 1861
      tmp___1 = strcmp((char const   *)(text), (char const   *)"0-0-0");
#line 1861
      if (tmp___1) {
#line 1862
        tmp = strspn((char const   *)(text), (char const   *)"0123456789.");
#line 1862
        tmove = text + tmp;
      } else {
#line 1861
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1864
      tmove = text;
    }
#line 1865
    if ((int )*(tmove + 0) >= 97) {
#line 1865
      if ((int )*(tmove + 0) <= 122) {
#line 1865
        goto _L___2;
      } else {
#line 1865
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1865
    if ((int )*(tmove + 0) >= 65) {
#line 1865
      if ((int )*(tmove + 0) <= 90) {
        _L___2: /* CIL Label */ 
#line 1865
        goto _L___1;
      } else {
#line 1865
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 1865
      tmp___3 = strcmp((char const   *)tmove, (char const   *)"0-0");
#line 1865
      if (tmp___3) {
#line 1865
        tmp___4 = strcmp((char const   *)tmove, (char const   *)"0-0-0");
#line 1865
        if (! tmp___4) {
          _L___0: /* CIL Label */ 
#line 1868
          tmp___2 = strcmp((char const   *)tmove, (char const   *)"exit");
#line 1868
          if (! tmp___2) {
#line 1869
            return (-1);
          }
#line 1870
          move = InputMove(tree, 0, wtm, 1, 0, tmove);
        }
      } else {
        _L___1: /* CIL Label */ 
#line 1865
        goto _L___0;
      }
    }
#line 1872
    if (one_move) {
#line 1873
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1875
  return (move);
}
}
#line 1887 "utility.c"
int ReadNextMove(TREE *tree , char *text___0 , int ply , int wtm ) 
{ 
  char *tmove ;
  int move ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1889
  move = 0;
#line 1891
  tmp___0 = strcmp((char const   *)text___0, (char const   *)"0-0");
#line 1891
  if (tmp___0) {
#line 1891
    tmp___1 = strcmp((char const   *)text___0, (char const   *)"0-0-0");
#line 1891
    if (tmp___1) {
#line 1892
      tmp = strspn((char const   *)text___0, (char const   *)"0123456789./-");
#line 1892
      tmove = text___0 + tmp;
    } else {
#line 1891
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1894
    tmove = text___0;
  }
#line 1895
  if ((int )*(tmove + 0) >= 97) {
#line 1895
    if ((int )*(tmove + 0) <= 122) {
#line 1895
      goto _L___2;
    } else {
#line 1895
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 1895
  if ((int )*(tmove + 0) >= 65) {
#line 1895
    if ((int )*(tmove + 0) <= 90) {
      _L___2: /* CIL Label */ 
#line 1895
      goto _L___1;
    } else {
#line 1895
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 1895
    tmp___3 = strcmp((char const   *)tmove, (char const   *)"0-0");
#line 1895
    if (tmp___3) {
#line 1895
      tmp___4 = strcmp((char const   *)tmove, (char const   *)"0-0-0");
#line 1895
      if (! tmp___4) {
        _L___0: /* CIL Label */ 
#line 1898
        tmp___2 = strcmp((char const   *)tmove, (char const   *)"exit");
#line 1898
        if (! tmp___2) {
#line 1899
          return (-1);
        }
#line 1900
        move = InputMove(tree, ply, wtm, 1, 0, tmove);
      }
    } else {
      _L___1: /* CIL Label */ 
#line 1895
      goto _L___0;
    }
  }
#line 1902
  return (move);
}
}
#line 1917 "utility.c"
static int data  =    0;
#line 1917 "utility.c"
static int lines_read  =    0;
#line 1919 "utility.c"
static char input_buffer[4096]  ;
#line 1916 "utility.c"
int ReadPGN(FILE *input , int option ) 
{ 
  int braces ;
  int parens ;
  int brackets ;
  int analysis ;
  int last_good_line ;
  char *eof ;
  char analysis_move[64] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *bracket1 ;
  char *bracket2 ;
  char value[128] ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *skip ;
  char *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  char *skip___0 ;
  char *ch ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmove ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  size_t tmp___34 ;
  char *tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  int skip___1 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  char *first ;
  char *last ;
  char *percent ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  unsigned short const   **tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;

  {
#line 1918
  braces = 0;
#line 1918
  parens = 0;
#line 1918
  brackets = 0;
#line 1918
  analysis = 0;
#line 1931
  pgn_suggested_percent = 0;
#line 1932
  if (! input) {
#line 1933
    lines_read = 0;
#line 1934
    data = 0;
#line 1935
    return (0);
  }
#line 1937
  if (option == -1) {
#line 1938
    data = 0;
  }
#line 1939
  if (option == -2) {
#line 1940
    return (lines_read);
  }
  {
#line 1949
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1949
    if (! 1) {
#line 1949
      goto while_break;
    }
#line 1950
    if (! data) {
#line 1951
      eof = fgets(input_buffer, 4096, input);
#line 1952
      if (! eof) {
#line 1953
        return (-1);
      }
#line 1954
      tmp___0 = strchr((char const   *)(input_buffer), '\n');
#line 1954
      if (tmp___0) {
#line 1955
        tmp = strchr((char const   *)(input_buffer), '\n');
#line 1955
        *tmp = (char)0;
      }
#line 1956
      tmp___2 = strchr((char const   *)(input_buffer), '\r');
#line 1956
      if (tmp___2) {
#line 1957
        tmp___1 = strchr((char const   *)(input_buffer), '\r');
#line 1957
        *tmp___1 = (char )' ';
      }
#line 1958
      lines_read ++;
#line 1959
      buffer[0] = (char)0;
#line 1960
      sscanf((char const   *)(input_buffer), (char const   *)"%s", buffer);
#line 1961
      if ((int )buffer[0] == 91) {
        {
#line 1962
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1965
          strcpy(buffer, (char const   *)(input_buffer));
#line 1966
          bracket1 = strchr((char const   *)(input_buffer), '\"');
#line 1967
          if ((unsigned long )bracket1 == (unsigned long )((char *)0)) {
#line 1968
            return (1);
          }
#line 1969
          bracket2 = strchr((char const   *)(bracket1 + 1), '\"');
#line 1970
          if ((unsigned long )bracket2 == (unsigned long )((char *)0)) {
#line 1971
            return (1);
          }
#line 1972
          *bracket1 = (char)0;
#line 1973
          *bracket2 = (char)0;
#line 1974
          strcpy(value, (char const   *)(bracket1 + 1));
#line 1975
          tmp___12 = strstr((char const   *)(input_buffer), (char const   *)"Event");
#line 1975
          if (tmp___12) {
#line 1976
            strcpy(pgn_event, (char const   *)(value));
          } else {
#line 1977
            tmp___11 = strstr((char const   *)(input_buffer), (char const   *)"Site");
#line 1977
            if (tmp___11) {
#line 1978
              strcpy(pgn_site, (char const   *)(value));
            } else {
#line 1979
              tmp___10 = strstr((char const   *)(input_buffer), (char const   *)"Round");
#line 1979
              if (tmp___10) {
#line 1980
                strcpy(pgn_round, (char const   *)(value));
              } else {
#line 1981
                tmp___9 = strstr((char const   *)(input_buffer), (char const   *)"Date");
#line 1981
                if (tmp___9) {
#line 1982
                  strcpy(pgn_date, (char const   *)(value));
                } else {
#line 1983
                  tmp___8 = strstr((char const   *)(input_buffer), (char const   *)"WhiteElo");
#line 1983
                  if (tmp___8) {
#line 1984
                    strcpy(pgn_white_elo, (char const   *)(value));
                  } else {
#line 1985
                    tmp___7 = strstr((char const   *)(input_buffer), (char const   *)"White");
#line 1985
                    if (tmp___7) {
#line 1986
                      strcpy(pgn_white, (char const   *)(value));
                    } else {
#line 1987
                      tmp___6 = strstr((char const   *)(input_buffer), (char const   *)"BlackElo");
#line 1987
                      if (tmp___6) {
#line 1988
                        strcpy(pgn_black_elo, (char const   *)(value));
                      } else {
#line 1989
                        tmp___5 = strstr((char const   *)(input_buffer), (char const   *)"Black");
#line 1989
                        if (tmp___5) {
#line 1990
                          strcpy(pgn_black, (char const   *)(value));
                        } else {
#line 1991
                          tmp___4 = strstr((char const   *)(input_buffer), (char const   *)"Result");
#line 1991
                          if (tmp___4) {
#line 1992
                            strcpy(pgn_result, (char const   *)(value));
                          } else {
#line 1993
                            tmp___3 = strstr((char const   *)(input_buffer), (char const   *)"FEN");
#line 1993
                            if (tmp___3) {
#line 1994
                              sprintf(buffer, (char const   *)"setboard %s", value);
#line 1995
                              Option(block[0]);
#line 1996
                              goto __Cont;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
#line 1998
          return (1);
          __Cont: /* CIL Label */ 
#line 1962
          if (! 0) {
#line 1962
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 2000
      data = 1;
    } else {
#line 2013
      buffer[0] = (char)0;
#line 2014
      sscanf((char const   *)(input_buffer), (char const   *)"%s", buffer);
#line 2015
      tmp___16 = strlen((char const   *)(buffer));
#line 2015
      if (tmp___16 == 0UL) {
#line 2016
        data = 0;
#line 2017
        goto while_continue;
      } else {
#line 2021
        tmp___13 = strstr((char const   *)(input_buffer), (char const   *)(buffer));
#line 2021
        tmp___14 = strlen((char const   *)(buffer));
#line 2021
        skip = tmp___13 + tmp___14;
#line 2022
        if (skip) {
#line 2023
          tmp___15 = strlen((char const   *)skip);
#line 2023
          memmove((void *)(input_buffer), (void const   *)skip, tmp___15 + 1UL);
        }
      }
#line 2035
      last_good_line = lines_read;
#line 2036
      analysis_move[0] = (char)0;
#line 2037
      tmp___44 = strchr((char const   *)(buffer), '{');
#line 2037
      if (tmp___44) {
#line 2037
        goto _L___10;
      } else {
#line 2037
        tmp___45 = strchr((char const   *)(buffer), '(');
#line 2037
        if (tmp___45) {
          _L___10: /* CIL Label */ 
          {
#line 2038
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2038
            if (! 1) {
#line 2038
              goto while_break___1;
            }
#line 2041
            analysis = 1;
            {
#line 2042
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2042
              ch = strpbrk((char const   *)(buffer), (char const   *)"(){}[]");
#line 2042
              if (! ch) {
#line 2042
                goto while_break___2;
              }
#line 2043
              if ((int )*ch == 40) {
#line 2044
                tmp___17 = strchr((char const   *)(buffer), '(');
#line 2044
                *tmp___17 = (char )' ';
#line 2045
                if (! braces) {
#line 2046
                  parens ++;
                }
              }
#line 2048
              if ((int )*ch == 41) {
#line 2049
                tmp___18 = strchr((char const   *)(buffer), ')');
#line 2049
                *tmp___18 = (char )' ';
#line 2050
                if (! braces) {
#line 2051
                  parens --;
                }
              }
#line 2053
              if ((int )*ch == 123) {
#line 2054
                tmp___19 = strchr((char const   *)(buffer), '{');
#line 2054
                *tmp___19 = (char )' ';
#line 2055
                braces ++;
              }
#line 2057
              if ((int )*ch == 125) {
#line 2058
                tmp___20 = strchr((char const   *)(buffer), '}');
#line 2058
                *tmp___20 = (char )' ';
#line 2059
                braces --;
              }
#line 2061
              if ((int )*ch == 91) {
#line 2062
                tmp___21 = strchr((char const   *)(buffer), '[');
#line 2062
                *tmp___21 = (char )' ';
#line 2063
                if (! braces) {
#line 2064
                  brackets ++;
                }
              }
#line 2066
              if ((int )*ch == 93) {
#line 2067
                tmp___22 = strchr((char const   *)(buffer), ']');
#line 2067
                *tmp___22 = (char )' ';
#line 2068
                if (! braces) {
#line 2069
                  brackets --;
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 2072
            if (analysis) {
#line 2072
              if ((int )analysis_move[0] == 0) {
#line 2073
                tmp___28 = strspn((char const   *)(buffer), (char const   *)" ");
#line 2073
                tmp___29 = strlen((char const   *)(buffer));
#line 2073
                if (tmp___28 != tmp___29) {
#line 2074
                  tmove = analysis_move;
#line 2076
                  sscanf((char const   *)(buffer), (char const   *)"%64s", analysis_move);
#line 2077
                  strcpy(buffer, (char const   *)(analysis_move));
#line 2078
                  tmp___24 = strcmp((char const   *)(buffer), (char const   *)"0-0");
#line 2078
                  if (tmp___24) {
#line 2078
                    tmp___25 = strcmp((char const   *)(buffer), (char const   *)"0-0-0");
#line 2078
                    if (tmp___25) {
#line 2079
                      tmp___23 = strspn((char const   *)(buffer), (char const   *)"0123456789.");
#line 2079
                      tmove = buffer + tmp___23;
                    } else {
#line 2078
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
#line 2081
                    tmove = buffer;
                  }
#line 2082
                  if ((int )*(tmove + 0) >= 97) {
#line 2082
                    if ((int )*(tmove + 0) <= 122) {
#line 2082
                      goto _L___2;
                    } else {
#line 2082
                      goto _L___4;
                    }
                  } else
                  _L___4: /* CIL Label */ 
#line 2082
                  if ((int )*(tmove + 0) >= 65) {
#line 2082
                    if ((int )*(tmove + 0) <= 90) {
                      _L___2: /* CIL Label */ 
#line 2082
                      goto _L___1;
                    } else {
#line 2082
                      goto _L___3;
                    }
                  } else {
                    _L___3: /* CIL Label */ 
#line 2082
                    tmp___26 = strcmp((char const   *)tmove, (char const   *)"0-0");
#line 2082
                    if (tmp___26) {
#line 2082
                      tmp___27 = strcmp((char const   *)tmove, (char const   *)"0-0-0");
#line 2082
                      if (tmp___27) {
#line 2087
                        analysis_move[0] = (char)0;
                      } else {
                        _L___0: /* CIL Label */ 
#line 2085
                        strcpy(analysis_move, (char const   *)(buffer));
                      }
                    } else {
                      _L___1: /* CIL Label */ 
#line 2082
                      goto _L___0;
                    }
                  }
                }
              } else {
#line 2072
                goto _L___5;
              }
            } else {
              _L___5: /* CIL Label */ ;
            }
#line 2090
            if (parens == 0) {
#line 2090
              if (braces == 0) {
#line 2090
                if (brackets == 0) {
#line 2091
                  goto while_break___1;
                } else {
#line 2090
                  goto _L___7;
                }
              } else {
#line 2090
                goto _L___7;
              }
            } else {
              _L___7: /* CIL Label */ 
              _L___6: /* CIL Label */ ;
            }
#line 2092
            buffer[0] = (char)0;
#line 2093
            sscanf((char const   *)(input_buffer), (char const   *)"%s", buffer);
#line 2094
            tmp___34 = strlen((char const   *)(buffer));
#line 2094
            if (tmp___34 == 0UL) {
#line 2095
              eof = fgets(input_buffer, 4096, input);
#line 2096
              if (! eof) {
#line 2097
                parens = 0;
#line 2098
                braces = 0;
#line 2099
                brackets = 0;
#line 2100
                return (-1);
              }
#line 2102
              tmp___31 = strchr((char const   *)(input_buffer), '\n');
#line 2102
              if (tmp___31) {
#line 2103
                tmp___30 = strchr((char const   *)(input_buffer), '\n');
#line 2103
                *tmp___30 = (char)0;
              }
#line 2104
              tmp___33 = strchr((char const   *)(input_buffer), '\r');
#line 2104
              if (tmp___33) {
#line 2105
                tmp___32 = strchr((char const   *)(input_buffer), '\r');
#line 2105
                *tmp___32 = (char )' ';
              }
#line 2106
              lines_read ++;
#line 2107
              if (lines_read - last_good_line >= 100) {
#line 2108
                parens = 0;
#line 2109
                braces = 0;
#line 2110
                brackets = 0;
#line 2111
                Print(4095, "ERROR.  comment spans over 100 lines, starting at line %d\n",
                      last_good_line);
#line 2114
                goto while_break___1;
              }
            }
#line 2117
            tmp___35 = strstr((char const   *)(input_buffer), (char const   *)(buffer));
#line 2117
            tmp___36 = strlen((char const   *)(buffer));
#line 2117
            skip___0 = tmp___35 + tmp___36;
#line 2118
            tmp___37 = strlen((char const   *)skip___0);
#line 2118
            memmove((void *)(input_buffer), (void const   *)skip___0, tmp___37 + 1UL);
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 2122
          tmp___39 = strspn((char const   *)(buffer), (char const   *)"0123456789./-");
#line 2122
          skip___1 = (int )tmp___39;
#line 2122
          if (skip___1) {
#line 2123
            if (skip___1 > 1) {
#line 2124
              tmp___38 = strlen((char const   *)(buffer + skip___1));
#line 2124
              memmove((void *)(buffer), (void const   *)(buffer + skip___1), tmp___38 + 1UL);
            }
          }
#line 2126
          tmp___42 = __ctype_b_loc();
#line 2126
          if ((int const   )*(*tmp___42 + (int )buffer[0]) & 1024) {
#line 2126
            goto _L___9;
          } else {
#line 2126
            tmp___43 = strchr((char const   *)(buffer), '-');
#line 2126
            if (tmp___43) {
              _L___9: /* CIL Label */ 
#line 2129
              tmp___40 = strspn((char const   *)(input_buffer), (char const   *)" ");
#line 2129
              first = input_buffer + tmp___40;
#line 2130
              if ((unsigned long )first == (unsigned long )((char *)0)) {
#line 2130
                goto _L___8;
              } else
#line 2130
              if ((int )*first != 123) {
                _L___8: /* CIL Label */ 
#line 2131
                return (0);
              }
#line 2132
              last = strchr((char const   *)(input_buffer), '}');
#line 2133
              if ((unsigned long )last == (unsigned long )((char *)0)) {
#line 2134
                return (0);
              }
#line 2135
              percent = strstr((char const   *)first, (char const   *)"play");
#line 2136
              if ((unsigned long )percent == (unsigned long )((char *)0)) {
#line 2137
                return (0);
              }
#line 2138
              tmp___41 = strspn((char const   *)(percent + 4), (char const   *)" ");
#line 2138
              pgn_suggested_percent = atoi((char const   *)((percent + 4) + tmp___41));
#line 2140
              return (0);
            }
          }
        }
      }
#line 2143
      if (analysis_move[0]) {
#line 2143
        if (option == 1) {
#line 2144
          strcpy(buffer, (char const   *)(analysis_move));
#line 2145
          return (2);
        } else {
#line 2143
          goto _L___11;
        }
      } else {
        _L___11: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2149
  return (0);
}
}
#line 2160 "utility.c"
void RestoreGame(void) 
{ 
  int i ;
  int v ;
  int move ;
  char cmd[16] ;
  int tmp ;

  {
#line 2164
  if (! history_file) {
#line 2165
    return;
  }
#line 2166
  game_wtm = 1;
#line 2167
  InitializeChessBoard(block[0]);
#line 2168
  i = 0;
  {
#line 2168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2168
    if (! (i < 500)) {
#line 2168
      goto while_break;
    }
#line 2169
    fseek(history_file, (long )(i * 10), 0);
#line 2170
    strcpy(cmd, (char const   *)"");
#line 2171
    v = fscanf(history_file, (char const   *)"%s", cmd);
#line 2172
    if (v < 0) {
#line 2173
      perror((char const   *)"RestoreGame fscanf error: ");
    }
#line 2174
    tmp = strcmp((char const   *)(cmd), (char const   *)"pass");
#line 2174
    if (tmp) {
#line 2175
      move = InputMove(block[0], 0, game_wtm, 1, 0, cmd);
#line 2176
      if (move) {
#line 2177
        MakeMoveRoot(block[0], game_wtm, move);
      } else {
#line 2179
        goto while_break;
      }
    }
#line 2181
    game_wtm ^= 1;
#line 2168
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2183
  return;
}
}
#line 2193 "utility.c"
void Kibitz(int level , int wtm , int depth , int time___0 , int value , uint64_t nodes ,
            int ip , int tb_hits , char *pv ) 
{ 
  int nps ;
  uint64_t tmp ;
  char prefix[128] ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 2197
  if (time___0) {
#line 2197
    tmp = (100UL * nodes) / (uint64_t )time___0;
  } else {
#line 2197
    tmp = nodes;
  }
#line 2197
  nps = (int )tmp;
#line 2198
  if (! puzzling) {
#line 2201
    if (! (kibitz & 16)) {
#line 2202
      sprintf(prefix, (char const   *)"kibitz");
    } else {
#line 2204
      sprintf(prefix, (char const   *)"whisper");
    }
    {
#line 2206
    if (level == 1) {
#line 2206
      goto case_1;
    }
#line 2214
    if (level == 2) {
#line 2214
      goto case_2;
    }
#line 2222
    if (level == 3) {
#line 2222
      goto case_3;
    }
#line 2226
    if (level == 4) {
#line 2226
      goto case_4;
    }
#line 2230
    if (level == 5) {
#line 2230
      goto case_5;
    }
#line 2205
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2207
    if ((kibitz & 15) >= 1) {
#line 2208
      if (value > 0) {
#line 2209
        printf((char const   *)"%s mate in %d moves.\n\n", prefix, value);
      }
#line 2210
      if (value < 0) {
#line 2211
        printf((char const   *)"%s mated in %d moves.\n\n", prefix, - value);
      }
    }
#line 2213
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2215
    if ((kibitz & 15) >= 2) {
#line 2216
      tmp___0 = DisplayTimeKibitz((unsigned int )time___0);
#line 2216
      tmp___1 = DisplayKMB((uint64_t )nps, 0);
#line 2216
      tmp___2 = DisplayEvaluationKibitz(value, wtm);
#line 2216
      printf((char const   *)"%s ply=%d; eval=%s; nps=%s; time=%s(%d%%)", prefix,
             depth, tmp___2, tmp___1, tmp___0, ip);
#line 2219
      tmp___3 = DisplayKMB((uint64_t )tb_hits, 0);
#line 2219
      printf((char const   *)"; egtb=%s\n", tmp___3);
    }
#line 2221
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2223
    if ((kibitz & 15) >= 3) {
#line 2223
      if (nodes > 5000UL) {
#line 2223
        goto _L___0;
      } else
#line 2223
      if (level == 2) {
        _L___0: /* CIL Label */ 
#line 2224
        printf((char const   *)"%s %s\n", prefix, pv);
      } else {
#line 2223
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 2225
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2227
    if ((kibitz & 15) >= 4) {
#line 2228
      printf((char const   *)"%s %s\n", prefix, pv);
    }
#line 2229
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2231
    if ((kibitz & 15) >= 5) {
#line 2231
      if (nodes > 5000UL) {
#line 2232
        tmp___4 = DisplayEvaluationKibitz(value, wtm);
#line 2232
        tmp___5 = DisplayTimeKibitz((unsigned int )time___0);
#line 2232
        tmp___6 = DisplayKMB((uint64_t )nps, 0);
#line 2232
        printf((char const   *)"%s d%d-> %s/s %s(%d%%) %s %s ", prefix, depth, tmp___6,
               tmp___5, ip, tmp___4, pv);
#line 2235
        if (tb_hits) {
#line 2236
          tmp___7 = DisplayKMB((uint64_t )tb_hits, 0);
#line 2236
          printf((char const   *)"egtb=%s", tmp___7);
        }
#line 2237
        printf((char const   *)"\n");
      } else {
#line 2231
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
#line 2239
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2241
    if (wtm) {
#line 2241
      value = value;
    } else {
#line 2241
      value = - value;
    }
#line 2242
    if (post) {
#line 2242
      if (level > 1) {
#line 2243
        tmp___8 = strstr((char const   *)pv, (char const   *)"book");
#line 2243
        if (tmp___8) {
#line 2244
          printf((char const   *)"      %2d  %5d %7d %lu %s\n", depth, value, time___0,
                 nodes, pv + 10);
        } else {
#line 2247
          printf((char const   *)"      %2d  %5d %7d %lu %s\n", depth, value, time___0,
                 nodes, pv);
        }
      } else {
#line 2242
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ ;
    }
#line 2250
    fflush(stdout);
  }
#line 2252
  return;
}
}
#line 2261 "utility.c"
void Output(TREE *tree ) 
{ 
  int wtm ;
  int i ;

  {
#line 2274
  wtm = root_wtm;
#line 2275
  if (! abort_search) {
#line 2276
    kibitz_depth = iteration;
#line 2277
    end_time = ReadClock();
#line 2278
    DisplayPV(tree, 6, wtm, (int )(end_time - start_time), & tree->pv[1], 0);
#line 2279
    i = 0;
    {
#line 2279
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2279
      if (! (i < n_root_moves)) {
#line 2279
        goto while_break;
      }
#line 2280
      if (tree->pv[1].path[1] == root_moves[i].move) {
#line 2281
        goto while_break;
      }
#line 2279
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2282
    root_moves[i].path = tree->pv[1];
#line 2283
    root_moves[i].bm_age = 4;
  }
#line 2285
  return;
}
}
#line 2295 "utility.c"
void Trace(TREE *tree , int ply , int depth , int wtm , int alpha , int beta , char const   *name ,
           int mode___0 , int phase , int order ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 2299
  LockX86(& lock_io);
#line 2300
  i = 1;
  {
#line 2300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2300
    if (! (i < ply)) {
#line 2300
      goto while_break;
    }
#line 2301
    Print(-1, "  ");
#line 2300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2302
  if (phase != 16) {
#line 2303
    tmp = DisplayEvaluation(alpha, 1);
#line 2303
    tmp___0 = OutputMove(tree, ply, wtm, tree->curmv[ply]);
#line 2303
    Print(-1, "%d  %s(%d) d:%2d [%s,", ply, tmp___0, order, depth, tmp);
#line 2305
    if (mode___0) {
#line 2305
      tmp___1 = 'P';
    } else {
#line 2305
      tmp___1 = 'S';
    }
#line 2305
    tmp___2 = DisplayEvaluation(beta, 1);
#line 2305
    Print(-1, "%s] n:%lu %s(%c:%d)", tmp___2, tree->nodes_searched, name, tmp___1,
          phase);
#line 2307
    Print(-1, " (t=%d)\n", tree->thread_id);
  } else {
#line 2309
    Print(-1, "%d window/eval(%s) = {", ply, name);
#line 2310
    tmp___3 = DisplayEvaluation(alpha, 1);
#line 2310
    Print(-1, "%s, ", tmp___3);
#line 2311
    tmp___4 = DisplayEvaluation(depth, 1);
#line 2311
    Print(-1, "%s, ", tmp___4);
#line 2312
    tmp___5 = DisplayEvaluation(beta, 1);
#line 2312
    Print(-1, "%s}\n", tmp___5);
  }
#line 2314
  fflush((FILE *)0);
#line 2315
  UnlockX86(& lock_io);
#line 2316
  return;
}
}
#line 2325 "utility.c"
int StrCnt(char *string , char testchar ) 
{ 
  int count ;
  int i ;
  size_t tmp ;

  {
#line 2326
  count = 0;
#line 2328
  i = 0;
  {
#line 2328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2328
    tmp = strlen((char const   *)string);
#line 2328
    if (! ((size_t )i < tmp)) {
#line 2328
      goto while_break;
    }
#line 2329
    if ((int )*(string + i) == (int )testchar) {
#line 2330
      count ++;
    }
#line 2328
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2331
  return (count);
}
}
#line 2344 "utility.c"
int ValidMove(TREE *tree , int ply , int wtm , int move ) 
{ 
  int btm ;
  int tmp ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;
  uint64_t tmp___2 ;
  uint64_t tmp___3 ;
  uint64_t tmp___4 ;
  uint64_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  uint64_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 2345
  btm = wtm ^ 1;
#line 2354
  if (wtm) {
#line 2354
    tmp = (move >> 12) & 7;
  } else {
#line 2354
    tmp = - ((move >> 12) & 7);
  }
#line 2354
  if ((int )tree->position.board[move & 63] != tmp) {
#line 2355
    return (0);
  }
  {
#line 2365
  if (((move >> 12) & 7) == 0) {
#line 2365
    goto case_0;
  }
#line 2379
  if (((move >> 12) & 7) == 6) {
#line 2379
    goto case_6;
  }
#line 2407
  if (((move >> 12) & 7) == 1) {
#line 2407
    goto case_1;
  }
#line 2440
  if (((move >> 12) & 7) == 3) {
#line 2440
    goto case_3;
  }
#line 2440
  if (((move >> 12) & 7) == 4) {
#line 2440
    goto case_3;
  }
#line 2440
  if (((move >> 12) & 7) == 5) {
#line 2440
    goto case_3;
  }
#line 2444
  if (((move >> 12) & 7) == 2) {
#line 2444
    goto case_2;
  }
#line 2356
  goto switch_break;
  case_0: /* CIL Label */ 
#line 2366
  return (0);
  case_6: /* CIL Label */ 
#line 2380
  if ((move & 63) - ((move >> 6) & 63) > 0) {
#line 2380
    tmp___6 = (move & 63) - ((move >> 6) & 63);
  } else {
#line 2380
    tmp___6 = - ((move & 63) - ((move >> 6) & 63));
  }
#line 2380
  if (tmp___6 == 2) {
#line 2381
    if ((int )tree->status[ply].castle[wtm] > 0) {
#line 2382
      if (((move >> 6) & 63) == (int )csq[wtm]) {
#line 2383
        if (! ((int )tree->status[ply].castle[wtm] & 2)) {
#line 2383
          goto _L___2;
        } else
#line 2383
        if ((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )OOO[wtm]) {
          _L___2: /* CIL Label */ 
#line 2383
          goto _L___1;
        } else {
#line 2383
          tmp___0 = AttacksTo(tree, (int )csq[wtm]);
#line 2383
          if (tmp___0 & tree->position.color[btm].pieces[0]) {
            _L___1: /* CIL Label */ 
#line 2383
            goto _L___0;
          } else {
#line 2383
            tmp___1 = AttacksTo(tree, (int )dsq[wtm]);
#line 2383
            if (tmp___1 & tree->position.color[btm].pieces[0]) {
              _L___0: /* CIL Label */ 
#line 2383
              goto _L;
            } else {
#line 2383
              tmp___2 = AttacksTo(tree, (int )esq[wtm]);
#line 2383
              if (tmp___2 & tree->position.color[btm].pieces[0]) {
                _L: /* CIL Label */ 
#line 2387
                return (0);
              }
            }
          }
        }
      } else
#line 2388
      if (((move >> 6) & 63) == (int )gsq[wtm]) {
#line 2389
        if (! ((int )tree->status[ply].castle[wtm] & 1)) {
#line 2389
          goto _L___6;
        } else
#line 2389
        if ((tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]) & (unsigned long )OO[wtm]) {
          _L___6: /* CIL Label */ 
#line 2389
          goto _L___5;
        } else {
#line 2389
          tmp___3 = AttacksTo(tree, (int )esq[wtm]);
#line 2389
          if (tmp___3 & tree->position.color[btm].pieces[0]) {
            _L___5: /* CIL Label */ 
#line 2389
            goto _L___4;
          } else {
#line 2389
            tmp___4 = AttacksTo(tree, (int )fsq[wtm]);
#line 2389
            if (tmp___4 & tree->position.color[btm].pieces[0]) {
              _L___4: /* CIL Label */ 
#line 2389
              goto _L___3;
            } else {
#line 2389
              tmp___5 = AttacksTo(tree, (int )gsq[wtm]);
#line 2389
              if (tmp___5 & tree->position.color[btm].pieces[0]) {
                _L___3: /* CIL Label */ 
#line 2393
                return (0);
              }
            }
          }
        }
      }
    } else {
#line 2396
      return (0);
    }
#line 2397
    return (1);
  }
#line 2399
  goto switch_break;
  case_1: /* CIL Label */ 
#line 2408
  if (wtm) {
#line 2408
    tmp___7 = ((move >> 6) & 63) - (move & 63);
  } else {
#line 2408
    tmp___7 = (move & 63) - ((move >> 6) & 63);
  }
#line 2408
  if (tmp___7 < 0) {
#line 2409
    return (0);
  }
#line 2410
  if ((move & 63) - ((move >> 6) & 63) > 0) {
#line 2410
    tmp___9 = (move & 63) - ((move >> 6) & 63);
  } else {
#line 2410
    tmp___9 = - ((move & 63) - ((move >> 6) & 63));
  }
#line 2410
  if (tmp___9 == 8) {
#line 2411
    if (tree->position.board[(move >> 6) & 63]) {
#line 2411
      tmp___8 = 0;
    } else {
#line 2411
      tmp___8 = 1;
    }
#line 2411
    return (tmp___8);
  }
#line 2412
  if ((move & 63) - ((move >> 6) & 63) > 0) {
#line 2412
    tmp___11 = (move & 63) - ((move >> 6) & 63);
  } else {
#line 2412
    tmp___11 = - ((move & 63) - ((move >> 6) & 63));
  }
#line 2412
  if (tmp___11 == 16) {
#line 2413
    if (tree->position.board[(move >> 6) & 63]) {
#line 2413
      goto _L___7;
    } else
#line 2413
    if (tree->position.board[((move >> 6) & 63) + (int )epdir[wtm]]) {
      _L___7: /* CIL Label */ 
#line 2413
      tmp___10 = 0;
    } else {
#line 2413
      tmp___10 = 1;
    }
#line 2413
    return (tmp___10);
  }
#line 2414
  if (! ((move >> 15) & 7)) {
#line 2415
    return (0);
  }
#line 2426
  if ((int )tree->position.board[(move >> 6) & 63] == 0) {
#line 2426
    if (wtm) {
#line 2426
      tmp___12 = -1;
    } else {
#line 2426
      tmp___12 = 1;
    }
#line 2426
    if ((int )tree->position.board[((move >> 6) & 63) + (int )epdir[wtm]] == tmp___12) {
#line 2426
      if (tree->status[ply].enpassant_target) {
#line 2426
        tmp___13 = set_mask[tree->status[ply].enpassant_target];
      } else {
#line 2426
        tmp___13 = (uint64_t )0;
      }
#line 2426
      if (tmp___13 & set_mask[(move >> 6) & 63]) {
#line 2429
        return (1);
      } else {
#line 2426
        goto _L___9;
      }
    } else {
#line 2426
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ 
    _L___8: /* CIL Label */ ;
  }
#line 2430
  goto switch_break;
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 2441
  if (! (intervening[move & 63][(move >> 6) & 63] & (tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]))) {
#line 2442
    goto switch_break;
  }
#line 2443
  return (0);
  case_2: /* CIL Label */ 
#line 2445
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2456
  if (wtm) {
#line 2456
    tmp___16 = - ((int )tree->position.board[(move >> 6) & 63]);
  } else {
#line 2456
    tmp___16 = (int )tree->position.board[(move >> 6) & 63];
  }
#line 2456
  if (((move >> 15) & 7) == tmp___16) {
#line 2456
    if (((move >> 15) & 7) != 6) {
#line 2456
      tmp___15 = 1;
    } else {
#line 2456
      goto _L___10;
    }
  } else {
    _L___10: /* CIL Label */ 
#line 2456
    tmp___15 = 0;
  }
#line 2456
  return (tmp___15);
}
}
#line 2470 "utility.c"
int VerifyMove(TREE *tree , int ply , int wtm , int move ) 
{ 
  unsigned int moves[256] ;
  unsigned int *mv ;
  unsigned int *mvp ;
  int tmp ;

  {
#line 2476
  if (move == 0) {
#line 2477
    return (0);
  }
#line 2478
  tree->status[129] = tree->status[ply];
#line 2479
  mvp = GenerateCaptures(tree, 129, wtm, moves);
#line 2480
  mvp = GenerateNoncaptures(tree, 129, wtm, mvp);
#line 2481
  mv = & moves[0];
  {
#line 2481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2481
    if (! ((unsigned long )mv < (unsigned long )mvp)) {
#line 2481
      goto while_break;
    }
#line 2482
    MakeMove(tree, 129, wtm, (int )*mv);
#line 2483
    tmp = Attacks(tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 2483
    if (tmp) {
      _L: /* CIL Label */ ;
    } else
#line 2483
    if ((unsigned int )move == *mv) {
#line 2484
      UnmakeMove(tree, 129, wtm, (int )*mv);
#line 2485
      return (1);
    } else {
#line 2483
      goto _L;
    }
#line 2487
    UnmakeMove(tree, 129, wtm, (int )*mv);
#line 2481
    mv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2489
  return (0);
}
}
#line 100 "tbprobe.c"
static _Bool do_move(struct pos *pos , struct pos  const  *pos0 , uint16_t move ) ;
#line 101
static int probe_dtz(struct pos  const  *pos , int *success ) ;
#line 103 "tbprobe.c"
unsigned int TB_LARGEST  =    0U;
#line 387 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
extern __ssize_t ( __attribute__((__leaf__)) readahead)(int __fd , __off64_t __offset ,
                                                        size_t __count )  __attribute__((__nothrow__)) ;
#line 395
extern int sync_file_range(int __fd , __off64_t __offset , __off64_t __count , unsigned int __flags ) ;
#line 403
extern __ssize_t vmsplice(int __fdout , struct iovec  const  *__iov , size_t __count ,
                          unsigned int __flags ) ;
#line 410
extern __ssize_t splice(int __fdin , __off64_t *__offin , int __fdout , __off64_t *__offout ,
                        size_t __len , unsigned int __flags ) ;
#line 418
extern __ssize_t tee(int __fdin , int __fdout , size_t __len , unsigned int __flags ) ;
#line 426
extern int fallocate(int __fd , int __mode , __off_t __offset , __off_t __len ) ;
#line 437
extern int fallocate64(int __fd , int __mode , __off64_t __offset , __off64_t __len ) ;
#line 443
extern int ( __attribute__((__leaf__)) name_to_handle_at)(int __dfd , char const   *__name ,
                                                          struct file_handle *__handle ,
                                                          int *__mnt_id , int __flags )  __attribute__((__nothrow__)) ;
#line 451
extern int open_by_handle_at(int __mountdirfd , struct file_handle *__handle , int __flags ) ;
#line 177 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 186
extern int fcntl64(int __fd , int __cmd  , ...) ;
#line 209
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) open)(char const   *__path , int __oflag  , ...) ;
#line 219
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) open64)(char const   *__path , int __oflag  , ...) ;
#line 233
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__, __artificial__,
__always_inline__)) openat)(int __fd , char const   *__path , int __oflag  , ...) ;
#line 244
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__, __artificial__,
__always_inline__)) openat64)(int __fd , char const   *__path , int __oflag  , ...) ;
#line 255
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 265
extern int ( __attribute__((__nonnull__(1))) creat64)(char const   *__file , mode_t __mode ) ;
#line 301
extern int ( __attribute__((__leaf__)) posix_fadvise)(int __fd , off_t __offset ,
                                                      off_t __len , int __advise )  __attribute__((__nothrow__)) ;
#line 313
extern int ( __attribute__((__leaf__)) posix_fadvise64)(int __fd , off64_t __offset ,
                                                        off64_t __len , int __advise )  __attribute__((__nothrow__)) ;
#line 323
extern int posix_fallocate(int __fd , off_t __offset , off_t __len ) ;
#line 334
extern int posix_fallocate64(int __fd , off64_t __offset , off64_t __len ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int ( __attribute__((__nonnull__(1))) __open_2)(char const   *__path , int __oflag ) ;
#line 27
extern int ( __attribute__((__nonnull__(1))) __open_alias)(char const   *__path ,
                                                           int __oflag  , ...)  __asm__("open")  ;
#line 37
extern void __open_too_many_args(void)  __attribute__((__error__("open can be called either with 2 or 3 arguments, not more"))) ;
#line 39
extern void __open_missing_mode(void)  __attribute__((__error__("open with O_CREAT or O_TMPFILE in second argument needs 3 arguments"))) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) open)(char const   *__path , int __oflag  , ...) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 45
  tmp = __builtin_va_arg_pack_len();
#line 45
  if (tmp > 1) {
#line 46
    __open_too_many_args();
  }
#line 48
  if (0) {
#line 50
    if ((__oflag & 0100) != 0) {
#line 50
      goto _L___0;
    } else
#line 50
    if ((__oflag & 4259840) == 4259840) {
      _L___0: /* CIL Label */ 
#line 50
      tmp___1 = __builtin_va_arg_pack_len();
#line 50
      if (tmp___1 < 1) {
#line 52
        __open_missing_mode();
#line 53
        tmp___0 = __open_2(__path, __oflag);
#line 53
        return (tmp___0);
      } else {
#line 50
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 55
    tmp___2 = __open_alias(__path, __oflag, __builtin_va_arg_pack());
#line 55
    return (tmp___2);
  }
#line 58
  tmp___4 = __builtin_va_arg_pack_len();
#line 58
  if (tmp___4 < 1) {
#line 59
    tmp___3 = __open_2(__path, __oflag);
#line 59
    return (tmp___3);
  }
#line 61
  tmp___5 = __open_alias(__path, __oflag, __builtin_va_arg_pack());
#line 61
  return (tmp___5);
}
}
#line 82
extern int ( __attribute__((__nonnull__(1))) __open64_2)(char const   *__path , int __oflag ) ;
#line 83
extern int ( __attribute__((__nonnull__(1))) __open64_alias)(char const   *__path ,
                                                             int __oflag  , ...)  __asm__("open64")  ;
#line 86
extern void __open64_too_many_args(void)  __attribute__((__error__("open64 can be called either with 2 or 3 arguments, not more"))) ;
#line 88
extern void __open64_missing_mode(void)  __attribute__((__error__("open64 with O_CREAT or O_TMPFILE in second argument needs 3 arguments"))) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) open64)(char const   *__path , int __oflag  , ...) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 94
  tmp = __builtin_va_arg_pack_len();
#line 94
  if (tmp > 1) {
#line 95
    __open64_too_many_args();
  }
#line 97
  if (0) {
#line 99
    if ((__oflag & 0100) != 0) {
#line 99
      goto _L___0;
    } else
#line 99
    if ((__oflag & 4259840) == 4259840) {
      _L___0: /* CIL Label */ 
#line 99
      tmp___1 = __builtin_va_arg_pack_len();
#line 99
      if (tmp___1 < 1) {
#line 101
        __open64_missing_mode();
#line 102
        tmp___0 = __open64_2(__path, __oflag);
#line 102
        return (tmp___0);
      } else {
#line 99
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 104
    tmp___2 = __open64_alias(__path, __oflag, __builtin_va_arg_pack());
#line 104
    return (tmp___2);
  }
#line 107
  tmp___4 = __builtin_va_arg_pack_len();
#line 107
  if (tmp___4 < 1) {
#line 108
    tmp___3 = __open64_2(__path, __oflag);
#line 108
    return (tmp___3);
  }
#line 110
  tmp___5 = __open64_alias(__path, __oflag, __builtin_va_arg_pack());
#line 110
  return (tmp___5);
}
}
#line 138
extern int ( __attribute__((__nonnull__(2))) __openat_2)(int __fd , char const   *__path ,
                                                         int __oflag ) ;
#line 140
extern int ( __attribute__((__nonnull__(2))) __openat_alias)(int __fd , char const   *__path ,
                                                             int __oflag  , ...)  __asm__("openat")  ;
#line 153
extern void __openat_too_many_args(void)  __attribute__((__error__("openat can be called either with 3 or 4 arguments, not more"))) ;
#line 155
extern void __openat_missing_mode(void)  __attribute__((__error__("openat with O_CREAT or O_TMPFILE in third argument needs 4 arguments"))) ;
#line 158 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__, __artificial__,
__always_inline__)) openat)(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 161
  tmp = __builtin_va_arg_pack_len();
#line 161
  if (tmp > 1) {
#line 162
    __openat_too_many_args();
  }
#line 164
  if (0) {
#line 166
    if ((__oflag & 0100) != 0) {
#line 166
      goto _L___0;
    } else
#line 166
    if ((__oflag & 4259840) == 4259840) {
      _L___0: /* CIL Label */ 
#line 166
      tmp___1 = __builtin_va_arg_pack_len();
#line 166
      if (tmp___1 < 1) {
#line 168
        __openat_missing_mode();
#line 169
        tmp___0 = __openat_2(__fd, __path, __oflag);
#line 169
        return (tmp___0);
      } else {
#line 166
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 171
    tmp___2 = __openat_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
#line 171
    return (tmp___2);
  }
#line 174
  tmp___4 = __builtin_va_arg_pack_len();
#line 174
  if (tmp___4 < 1) {
#line 175
    tmp___3 = __openat_2(__fd, __path, __oflag);
#line 175
    return (tmp___3);
  }
#line 177
  tmp___5 = __openat_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
#line 177
  return (tmp___5);
}
}
#line 204
extern int ( __attribute__((__nonnull__(2))) __openat64_2)(int __fd , char const   *__path ,
                                                           int __oflag ) ;
#line 206
extern int ( __attribute__((__nonnull__(2))) __openat64_alias)(int __fd , char const   *__path ,
                                                               int __oflag  , ...)  __asm__("openat64")  ;
#line 209
extern void __openat64_too_many_args(void)  __attribute__((__error__("openat64 can be called either with 3 or 4 arguments, not more"))) ;
#line 211
extern void __openat64_missing_mode(void)  __attribute__((__error__("openat64 with O_CREAT or O_TMPFILE in third argument needs 4 arguments"))) ;
#line 215 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__, __artificial__,
__always_inline__)) openat64)(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 218
  tmp = __builtin_va_arg_pack_len();
#line 218
  if (tmp > 1) {
#line 219
    __openat64_too_many_args();
  }
#line 221
  if (0) {
#line 223
    if ((__oflag & 0100) != 0) {
#line 223
      goto _L___0;
    } else
#line 223
    if ((__oflag & 4259840) == 4259840) {
      _L___0: /* CIL Label */ 
#line 223
      tmp___1 = __builtin_va_arg_pack_len();
#line 223
      if (tmp___1 < 1) {
#line 225
        __openat64_missing_mode();
#line 226
        tmp___0 = __openat64_2(__fd, __path, __oflag);
#line 226
        return (tmp___0);
      } else {
#line 223
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 228
    tmp___2 = __openat64_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
#line 228
    return (tmp___2);
  }
#line 231
  tmp___4 = __builtin_va_arg_pack_len();
#line 231
  if (tmp___4 < 1) {
#line 232
    tmp___3 = __openat64_2(__fd, __path, __oflag);
#line 232
    return (tmp___3);
  }
#line 234
  tmp___5 = __openat64_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
#line 234
  return (tmp___5);
}
}
#line 55 "/usr/include/x86_64-linux-gnu/bits/mman-shared.h"
extern int ( __attribute__((__leaf__)) memfd_create)(char const   *__name , unsigned int __flags )  __attribute__((__nothrow__)) ;
#line 59
extern int ( __attribute__((__leaf__)) mlock2)(void const   *__addr , size_t __length ,
                                               unsigned int __flags )  __attribute__((__nothrow__)) ;
#line 65
extern int ( __attribute__((__leaf__)) pkey_alloc)(unsigned int __flags , unsigned int __access_rights )  __attribute__((__nothrow__)) ;
#line 69
extern int ( __attribute__((__leaf__)) pkey_set)(int __key , unsigned int __access_rights )  __attribute__((__nothrow__)) ;
#line 73
extern int ( __attribute__((__leaf__)) pkey_get)(int __key )  __attribute__((__nothrow__)) ;
#line 77
extern int ( __attribute__((__leaf__)) pkey_free)(int __key )  __attribute__((__nothrow__)) ;
#line 81
extern int ( __attribute__((__leaf__)) pkey_mprotect)(void *__addr , size_t __len ,
                                                      int __prot , int __pkey )  __attribute__((__nothrow__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern void *( __attribute__((__leaf__)) mmap)(void *__addr , size_t __len , int __prot ,
                                               int __flags , int __fd , __off_t __offset )  __attribute__((__nothrow__)) ;
#line 70
extern void *( __attribute__((__leaf__)) mmap64)(void *__addr , size_t __len , int __prot ,
                                                 int __flags , int __fd , __off64_t __offset )  __attribute__((__nothrow__)) ;
#line 76
extern int ( __attribute__((__leaf__)) munmap)(void *__addr , size_t __len )  __attribute__((__nothrow__)) ;
#line 81
extern int ( __attribute__((__leaf__)) mprotect)(void *__addr , size_t __len , int __prot )  __attribute__((__nothrow__)) ;
#line 89
extern int msync(void *__addr , size_t __len , int __flags ) ;
#line 94
extern int ( __attribute__((__leaf__)) madvise)(void *__addr , size_t __len , int __advice )  __attribute__((__nothrow__)) ;
#line 98
extern int ( __attribute__((__leaf__)) posix_madvise)(void *__addr , size_t __len ,
                                                      int __advice )  __attribute__((__nothrow__)) ;
#line 103
extern int ( __attribute__((__leaf__)) mlock)(void const   *__addr , size_t __len )  __attribute__((__nothrow__)) ;
#line 106
extern int ( __attribute__((__leaf__)) munlock)(void const   *__addr , size_t __len )  __attribute__((__nothrow__)) ;
#line 111
extern int ( __attribute__((__leaf__)) mlockall)(int __flags )  __attribute__((__nothrow__)) ;
#line 115
extern int ( __attribute__((__leaf__)) munlockall)(void)  __attribute__((__nothrow__)) ;
#line 123
extern int ( __attribute__((__leaf__)) mincore)(void *__start , size_t __len , unsigned char *__vec )  __attribute__((__nothrow__)) ;
#line 133
extern void *( __attribute__((__leaf__)) mremap)(void *__addr , size_t __old_len ,
                                                 size_t __new_len , int __flags  , ...)  __attribute__((__nothrow__)) ;
#line 138
extern int ( __attribute__((__leaf__)) remap_file_pages)(void *__start , size_t __size ,
                                                         int __prot , size_t __pgoff ,
                                                         int __flags )  __attribute__((__nothrow__)) ;
#line 144
extern int shm_open(char const   *__name , int __oflag , mode_t __mode ) ;
#line 147
extern int shm_unlink(char const   *__name ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/mman_ext.h"
extern __ssize_t ( __attribute__((__leaf__)) process_madvise)(int __pid_fd , struct iovec  const  *__iov ,
                                                              size_t __count , int __advice ,
                                                              unsigned int __flags )  __attribute__((__nothrow__)) ;
#line 30
extern int ( __attribute__((__leaf__)) process_mrelease)(int pidfd , unsigned int flags )  __attribute__((__nothrow__)) ;
#line 42 "tbcore.c"
static pthread_mutex_t TB_MUTEX  ;
#line 45 "tbcore.c"
static int tb_initialized  =    0;
#line 46 "tbcore.c"
static int num_paths  =    0;
#line 47 "tbcore.c"
static char *path_string  =    (char *)((void *)0);
#line 48 "tbcore.c"
static char **paths  =    (char **)((void *)0);
#line 50 "tbcore.c"
static int TBnum_piece  ;
#line 50 "tbcore.c"
static int TBnum_pawn  ;
#line 51 "tbcore.c"
static struct TBEntry_piece TB_piece[254]  ;
#line 52 "tbcore.c"
static struct TBEntry_pawn TB_pawn[256]  ;
#line 54 "tbcore.c"
static struct TBHashEntry TB_hash[1 << 10][5]  ;
#line 58 "tbcore.c"
static struct DTZTableEntry DTZ_table[64]  ;
#line 60
static void init_indices(void) ;
#line 61
static uint64_t calc_key_from_pcs(int *pcs , int mirror ) ;
#line 62
static void free_wdl_entry(struct TBEntry *entry ) ;
#line 63
static void free_dtz_entry(struct TBEntry *entry ) ;
#line 65 "tbcore.c"
static int open_tb(char const   *str , char const   *suffix ) 
{ 
  int i ;
  int fd ;
  char file[256] ;

  {
#line 70
  i = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < num_paths)) {
#line 70
      goto while_break;
    }
#line 71
    strcpy(file, (char const   *)*(paths + i));
#line 72
    strcat(file, (char const   *)"/");
#line 73
    strcat(file, str);
#line 74
    strcat(file, suffix);
#line 76
    fd = open((char const   *)(file), 00);
#line 81
    if (fd != -1) {
#line 82
      return (fd);
    }
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (-1);
}
}
#line 87 "tbcore.c"
static void close_tb(int fd ) 
{ 


  {
#line 89
  close(fd);
#line 93
  return;
}
}
#line 95 "tbcore.c"
static char *map_file(char const   *name , char const   *suffix , uint64 *mapping ) 
{ 
  int fd ;
  int tmp ;
  struct stat statbuf ;
  char *data___0 ;
  void *tmp___0 ;

  {
#line 96
  tmp = open_tb(name, suffix);
#line 96
  fd = tmp;
#line 97
  if (fd == -1) {
#line 98
    return ((char *)((void *)0));
  }
#line 101
  fstat(fd, & statbuf);
#line 102
  *mapping = (uint64 )statbuf.st_size;
#line 103
  tmp___0 = mmap((void *)0, (size_t )statbuf.st_size, 0x1, 0x01, fd, (__off_t )0);
#line 103
  data___0 = (char *)tmp___0;
#line 105
  if ((unsigned long )data___0 == (unsigned long )((char *)-1)) {
#line 106
    printf((char const   *)"Could not mmap() %s.\n", name);
#line 107
    exit(1);
  }
#line 127
  close_tb(fd);
#line 128
  return (data___0);
}
}
#line 132 "tbcore.c"
static void unmap_file(char *data___0 , uint64 size ) 
{ 


  {
#line 133
  if (! data___0) {
#line 134
    return;
  }
#line 135
  munmap((void *)data___0, (size_t )size);
#line 136
  return;
}
}
#line 146 "tbcore.c"
static void add_to_hash(struct TBEntry *ptr , uint64 key ) 
{ 
  int i ;
  int hshidx ;

  {
#line 148
  hshidx = (int )(key >> 54);
#line 149
  i = 0;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (i < 5) {
#line 150
      if (! TB_hash[hshidx][i].ptr) {
#line 150
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 150
      goto while_break;
    }
#line 151
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  if (i == 5) {
#line 153
    printf((char const   *)"HSHMAX too low!\n");
#line 154
    exit(1);
  } else {
#line 156
    TB_hash[hshidx][i].key = key;
#line 157
    TB_hash[hshidx][i].ptr = ptr;
  }
#line 159
  return;
}
}
#line 161 "tbcore.c"
static char pchr[6]  = {      (char )'K',      (char )'Q',      (char )'R',      (char )'B', 
        (char )'N',      (char )'P'};
#line 163 "tbcore.c"
static void init_tb(char *str ) 
{ 
  int fd ;
  struct TBEntry *entry ;
  int i ;
  int j___0 ;
  int pcs[16] ;
  uint64 key ;
  uint64 key2 ;
  int color ;
  char *s ;
  uint64_t tmp ;
  uint64_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct TBEntry_pawn *ptr ;
  struct TBEntry_piece *ptr___0 ;

  {
#line 171
  fd = open_tb((char const   *)str, (char const   *)".rtbw");
#line 172
  if (fd == -1) {
#line 173
    return;
  }
#line 174
  close_tb(fd);
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < 16)) {
#line 176
      goto while_break;
    }
#line 177
    pcs[i] = 0;
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  color = 0;
#line 179
  s = str;
  {
#line 179
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 179
    if (! *s) {
#line 179
      goto while_break___0;
    }
    {
#line 181
    if ((int )*s == 80) {
#line 181
      goto case_80;
    }
#line 184
    if ((int )*s == 78) {
#line 184
      goto case_78;
    }
#line 187
    if ((int )*s == 66) {
#line 187
      goto case_66;
    }
#line 190
    if ((int )*s == 82) {
#line 190
      goto case_82;
    }
#line 193
    if ((int )*s == 81) {
#line 193
      goto case_81;
    }
#line 196
    if ((int )*s == 75) {
#line 196
      goto case_75;
    }
#line 199
    if ((int )*s == 118) {
#line 199
      goto case_118;
    }
#line 180
    goto switch_break;
    case_80: /* CIL Label */ 
#line 182
    (pcs[1 | color]) ++;
#line 183
    goto switch_break;
    case_78: /* CIL Label */ 
#line 185
    (pcs[2 | color]) ++;
#line 186
    goto switch_break;
    case_66: /* CIL Label */ 
#line 188
    (pcs[3 | color]) ++;
#line 189
    goto switch_break;
    case_82: /* CIL Label */ 
#line 191
    (pcs[4 | color]) ++;
#line 192
    goto switch_break;
    case_81: /* CIL Label */ 
#line 194
    (pcs[5 | color]) ++;
#line 195
    goto switch_break;
    case_75: /* CIL Label */ 
#line 197
    (pcs[6 | color]) ++;
#line 198
    goto switch_break;
    case_118: /* CIL Label */ 
#line 200
    color = 0x08;
#line 201
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 179
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 203
  tmp = calc_key_from_pcs(pcs, 0);
#line 203
  key = (uint64 )tmp;
#line 204
  tmp___0 = calc_key_from_pcs(pcs, 1);
#line 204
  key2 = (uint64 )tmp___0;
#line 205
  if (pcs[1] + pcs[9] == 0) {
#line 206
    if (TBnum_piece == 254) {
#line 207
      printf((char const   *)"TBMAX_PIECE limit too low!\n");
#line 208
      exit(1);
    }
#line 210
    tmp___1 = TBnum_piece;
#line 210
    TBnum_piece ++;
#line 210
    entry = (struct TBEntry *)(& TB_piece[tmp___1]);
  } else {
#line 212
    if (TBnum_pawn == 256) {
#line 213
      printf((char const   *)"TBMAX_PAWN limit too low!\n");
#line 214
      exit(1);
    }
#line 216
    tmp___2 = TBnum_pawn;
#line 216
    TBnum_pawn ++;
#line 216
    entry = (struct TBEntry *)(& TB_pawn[tmp___2]);
  }
#line 218
  entry->key = key;
#line 219
  entry->ready = (ubyte )0;
#line 220
  entry->num = (ubyte )0;
#line 221
  i = 0;
  {
#line 221
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 221
    if (! (i < 16)) {
#line 221
      goto while_break___1;
    }
#line 222
    entry->num = (ubyte )((int )entry->num + pcs[i]);
#line 221
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 223
  entry->symmetric = (ubyte )(key == key2);
#line 224
  entry->has_pawns = (ubyte )(pcs[1] + pcs[9] > 0);
#line 225
  if ((unsigned int )entry->num > TB_LARGEST) {
#line 226
    TB_LARGEST = (unsigned int )entry->num;
  }
#line 228
  if (entry->has_pawns) {
#line 229
    ptr = (struct TBEntry_pawn *)entry;
#line 230
    ptr->pawns[0] = (ubyte )pcs[1];
#line 231
    ptr->pawns[1] = (ubyte )pcs[9];
#line 232
    if (pcs[9] > 0) {
#line 232
      if (pcs[1] == 0) {
#line 232
        goto _L___0;
      } else
#line 232
      if (pcs[9] < pcs[1]) {
        _L___0: /* CIL Label */ 
#line 234
        ptr->pawns[0] = (ubyte )pcs[9];
#line 235
        ptr->pawns[1] = (ubyte )pcs[1];
      } else {
#line 232
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
  } else {
#line 238
    ptr___0 = (struct TBEntry_piece *)entry;
#line 239
    i = 0;
#line 239
    j___0 = 0;
    {
#line 239
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 239
      if (! (i < 16)) {
#line 239
        goto while_break___2;
      }
#line 240
      if (pcs[i] == 1) {
#line 241
        j___0 ++;
      }
#line 239
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 242
    if (j___0 >= 3) {
#line 243
      ptr___0->enc_type = (ubyte )0;
    } else
#line 244
    if (j___0 == 2) {
#line 245
      ptr___0->enc_type = (ubyte )2;
    } else {
#line 247
      j___0 = 16;
#line 248
      i = 0;
      {
#line 248
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 248
        if (! (i < 16)) {
#line 248
          goto while_break___3;
        }
#line 249
        if (pcs[i] < j___0) {
#line 249
          if (pcs[i] > 1) {
#line 250
            j___0 = pcs[i];
          } else {
#line 249
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ ;
        }
#line 251
        ptr___0->enc_type = (ubyte )(1 + j___0);
#line 248
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 255
  add_to_hash(entry, key);
#line 256
  if (key2 != key) {
#line 257
    add_to_hash(entry, key2);
  }
#line 258
  return;
}
}
#line 260 "tbcore.c"
void init_tablebases(char const   *path ) 
{ 
  char str[16] ;
  int i ;
  int j___0 ;
  int k___0 ;
  int l ;
  struct TBEntry *entry ;
  char const   *p ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 264
  if (tb_initialized) {
#line 265
    free((void *)path_string);
#line 266
    free((void *)paths);
#line 268
    i = 0;
    {
#line 268
    while (1) {
      while_continue: /* CIL Label */ ;
#line 268
      if (! (i < TBnum_piece)) {
#line 268
        goto while_break;
      }
#line 269
      entry = (struct TBEntry *)(& TB_piece[i]);
#line 270
      free_wdl_entry(entry);
#line 268
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 272
    i = 0;
    {
#line 272
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 272
      if (! (i < TBnum_pawn)) {
#line 272
        goto while_break___0;
      }
#line 273
      entry = (struct TBEntry *)(& TB_pawn[i]);
#line 274
      free_wdl_entry(entry);
#line 272
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 276
    i = 0;
    {
#line 276
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 276
      if (! (i < 64)) {
#line 276
        goto while_break___1;
      }
#line 277
      if (DTZ_table[i].entry) {
#line 278
        free_dtz_entry(DTZ_table[i].entry);
      }
#line 276
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 280
    init_indices();
#line 281
    tb_initialized = 1;
  }
#line 284
  p = path;
#line 285
  tmp = strlen(p);
#line 285
  if (tmp == 0UL) {
#line 285
    goto _L;
  } else {
#line 285
    tmp___0 = strcmp(p, (char const   *)"<empty>");
#line 285
    if (! tmp___0) {
      _L: /* CIL Label */ 
#line 286
      return;
    }
  }
#line 287
  tmp___1 = strlen(p);
#line 287
  tmp___2 = malloc(tmp___1 + 1UL);
#line 287
  path_string = (char *)tmp___2;
#line 288
  strcpy(path_string, p);
#line 289
  num_paths = 0;
#line 290
  i = 0;
  {
#line 290
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 291
    if ((int )*(path_string + i) != 58) {
#line 292
      num_paths ++;
    }
    {
#line 293
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 293
      if (*(path_string + i)) {
#line 293
        if (! ((int )*(path_string + i) != 58)) {
#line 293
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 293
        goto while_break___3;
      }
#line 294
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 295
    if (! *(path_string + i)) {
#line 296
      goto while_break___2;
    }
#line 297
    *(path_string + i) = (char)0;
#line 290
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 299
  tmp___3 = malloc((unsigned long )num_paths * sizeof(char *));
#line 299
  paths = (char **)tmp___3;
#line 300
  j___0 = 0;
#line 300
  i = j___0;
  {
#line 300
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 300
    if (! (i < num_paths)) {
#line 300
      goto while_break___4;
    }
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (! *(path_string + j___0))) {
#line 301
        goto while_break___5;
      }
#line 302
      j___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 303
    *(paths + i) = path_string + j___0;
    {
#line 304
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 304
      if (! *(path_string + j___0)) {
#line 304
        goto while_break___6;
      }
#line 305
      j___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 300
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 308
  pthread_mutex_init(& TB_MUTEX, (pthread_mutexattr_t const   *)((void *)0));
#line 310
  TBnum_pawn = 0;
#line 310
  TBnum_piece = TBnum_pawn;
#line 311
  TB_LARGEST = 0U;
#line 313
  i = 0;
  {
#line 313
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 313
    if (! (i < 1 << 10)) {
#line 313
      goto while_break___7;
    }
#line 314
    j___0 = 0;
    {
#line 314
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 314
      if (! (j___0 < 5)) {
#line 314
        goto while_break___8;
      }
#line 315
      TB_hash[i][j___0].key = 0ULL;
#line 316
      TB_hash[i][j___0].ptr = (struct TBEntry *)((void *)0);
#line 314
      j___0 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 313
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 319
  i = 0;
  {
#line 319
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 319
    if (! (i < 64)) {
#line 319
      goto while_break___9;
    }
#line 320
    DTZ_table[i].entry = (struct TBEntry *)((void *)0);
#line 319
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 322
  i = 1;
  {
#line 322
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 322
    if (! (i < 6)) {
#line 322
      goto while_break___10;
    }
#line 323
    sprintf(str, (char const   *)"K%cvK", (int )pchr[i]);
#line 324
    init_tb(str);
#line 322
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 327
  i = 1;
  {
#line 327
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 327
    if (! (i < 6)) {
#line 327
      goto while_break___11;
    }
#line 328
    j___0 = i;
    {
#line 328
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 328
      if (! (j___0 < 6)) {
#line 328
        goto while_break___12;
      }
#line 329
      sprintf(str, (char const   *)"K%cvK%c", (int )pchr[i], (int )pchr[j___0]);
#line 330
      init_tb(str);
#line 328
      j___0 ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 327
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 333
  i = 1;
  {
#line 333
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 333
    if (! (i < 6)) {
#line 333
      goto while_break___13;
    }
#line 334
    j___0 = i;
    {
#line 334
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 334
      if (! (j___0 < 6)) {
#line 334
        goto while_break___14;
      }
#line 335
      sprintf(str, (char const   *)"K%c%cvK", (int )pchr[i], (int )pchr[j___0]);
#line 336
      init_tb(str);
#line 334
      j___0 ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 333
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 339
  i = 1;
  {
#line 339
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 339
    if (! (i < 6)) {
#line 339
      goto while_break___15;
    }
#line 340
    j___0 = i;
    {
#line 340
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 340
      if (! (j___0 < 6)) {
#line 340
        goto while_break___16;
      }
#line 341
      k___0 = 1;
      {
#line 341
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 341
        if (! (k___0 < 6)) {
#line 341
          goto while_break___17;
        }
#line 342
        sprintf(str, (char const   *)"K%c%cvK%c", (int )pchr[i], (int )pchr[j___0],
                (int )pchr[k___0]);
#line 343
        init_tb(str);
#line 341
        k___0 ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 340
      j___0 ++;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 339
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 346
  i = 1;
  {
#line 346
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 346
    if (! (i < 6)) {
#line 346
      goto while_break___18;
    }
#line 347
    j___0 = i;
    {
#line 347
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 347
      if (! (j___0 < 6)) {
#line 347
        goto while_break___19;
      }
#line 348
      k___0 = j___0;
      {
#line 348
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 348
        if (! (k___0 < 6)) {
#line 348
          goto while_break___20;
        }
#line 349
        sprintf(str, (char const   *)"K%c%c%cvK", (int )pchr[i], (int )pchr[j___0],
                (int )pchr[k___0]);
#line 350
        init_tb(str);
#line 348
        k___0 ++;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 347
      j___0 ++;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 346
    i ++;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 353
  i = 1;
  {
#line 353
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 353
    if (! (i < 6)) {
#line 353
      goto while_break___21;
    }
#line 354
    j___0 = i;
    {
#line 354
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 354
      if (! (j___0 < 6)) {
#line 354
        goto while_break___22;
      }
#line 355
      k___0 = i;
      {
#line 355
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 355
        if (! (k___0 < 6)) {
#line 355
          goto while_break___23;
        }
#line 356
        if (i == k___0) {
#line 356
          l = j___0;
        } else {
#line 356
          l = k___0;
        }
        {
#line 356
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 356
          if (! (l < 6)) {
#line 356
            goto while_break___24;
          }
#line 357
          sprintf(str, (char const   *)"K%c%cvK%c%c", (int )pchr[i], (int )pchr[j___0],
                  (int )pchr[k___0], (int )pchr[l]);
#line 358
          init_tb(str);
#line 356
          l ++;
        }
        while_break___24: /* CIL Label */ ;
        }
#line 355
        k___0 ++;
      }
      while_break___23: /* CIL Label */ ;
      }
#line 354
      j___0 ++;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 353
    i ++;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 361
  i = 1;
  {
#line 361
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 361
    if (! (i < 6)) {
#line 361
      goto while_break___25;
    }
#line 362
    j___0 = i;
    {
#line 362
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 362
      if (! (j___0 < 6)) {
#line 362
        goto while_break___26;
      }
#line 363
      k___0 = j___0;
      {
#line 363
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 363
        if (! (k___0 < 6)) {
#line 363
          goto while_break___27;
        }
#line 364
        l = 1;
        {
#line 364
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 364
          if (! (l < 6)) {
#line 364
            goto while_break___28;
          }
#line 365
          sprintf(str, (char const   *)"K%c%c%cvK%c", (int )pchr[i], (int )pchr[j___0],
                  (int )pchr[k___0], (int )pchr[l]);
#line 366
          init_tb(str);
#line 364
          l ++;
        }
        while_break___28: /* CIL Label */ ;
        }
#line 363
        k___0 ++;
      }
      while_break___27: /* CIL Label */ ;
      }
#line 362
      j___0 ++;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 361
    i ++;
  }
  while_break___25: /* CIL Label */ ;
  }
#line 369
  i = 1;
  {
#line 369
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 369
    if (! (i < 6)) {
#line 369
      goto while_break___29;
    }
#line 370
    j___0 = i;
    {
#line 370
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 370
      if (! (j___0 < 6)) {
#line 370
        goto while_break___30;
      }
#line 371
      k___0 = j___0;
      {
#line 371
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 371
        if (! (k___0 < 6)) {
#line 371
          goto while_break___31;
        }
#line 372
        l = k___0;
        {
#line 372
        while (1) {
          while_continue___32: /* CIL Label */ ;
#line 372
          if (! (l < 6)) {
#line 372
            goto while_break___32;
          }
#line 373
          sprintf(str, (char const   *)"K%c%c%c%cvK", (int )pchr[i], (int )pchr[j___0],
                  (int )pchr[k___0], (int )pchr[l]);
#line 374
          init_tb(str);
#line 372
          l ++;
        }
        while_break___32: /* CIL Label */ ;
        }
#line 371
        k___0 ++;
      }
      while_break___31: /* CIL Label */ ;
      }
#line 370
      j___0 ++;
    }
    while_break___30: /* CIL Label */ ;
    }
#line 369
    i ++;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 378
  return;
}
}
#line 380 "tbcore.c"
static char const   offdiag[64]  = 
#line 380
  {      (char const   )0,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )1,      (char const   )0,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )1,      (char const   )1,      (char const   )0,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )0, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )0,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )0,      (char const   )-1,      (char const   )-1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )0,      (char const   )-1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )0};
#line 391 "tbcore.c"
static ubyte const   triangle[64]  = 
#line 391
  {      (ubyte const   )6,      (ubyte const   )0,      (ubyte const   )1,      (ubyte const   )2, 
        (ubyte const   )2,      (ubyte const   )1,      (ubyte const   )0,      (ubyte const   )6, 
        (ubyte const   )0,      (ubyte const   )7,      (ubyte const   )3,      (ubyte const   )4, 
        (ubyte const   )4,      (ubyte const   )3,      (ubyte const   )7,      (ubyte const   )0, 
        (ubyte const   )1,      (ubyte const   )3,      (ubyte const   )8,      (ubyte const   )5, 
        (ubyte const   )5,      (ubyte const   )8,      (ubyte const   )3,      (ubyte const   )1, 
        (ubyte const   )2,      (ubyte const   )4,      (ubyte const   )5,      (ubyte const   )9, 
        (ubyte const   )9,      (ubyte const   )5,      (ubyte const   )4,      (ubyte const   )2, 
        (ubyte const   )2,      (ubyte const   )4,      (ubyte const   )5,      (ubyte const   )9, 
        (ubyte const   )9,      (ubyte const   )5,      (ubyte const   )4,      (ubyte const   )2, 
        (ubyte const   )1,      (ubyte const   )3,      (ubyte const   )8,      (ubyte const   )5, 
        (ubyte const   )5,      (ubyte const   )8,      (ubyte const   )3,      (ubyte const   )1, 
        (ubyte const   )0,      (ubyte const   )7,      (ubyte const   )3,      (ubyte const   )4, 
        (ubyte const   )4,      (ubyte const   )3,      (ubyte const   )7,      (ubyte const   )0, 
        (ubyte const   )6,      (ubyte const   )0,      (ubyte const   )1,      (ubyte const   )2, 
        (ubyte const   )2,      (ubyte const   )1,      (ubyte const   )0,      (ubyte const   )6};
#line 402 "tbcore.c"
static ubyte const   invtriangle[10]  = 
#line 402
  {      (ubyte const   )1,      (ubyte const   )2,      (ubyte const   )3,      (ubyte const   )10, 
        (ubyte const   )11,      (ubyte const   )19,      (ubyte const   )0,      (ubyte const   )9, 
        (ubyte const   )18,      (ubyte const   )27};
#line 406 "tbcore.c"
static ubyte const   invdiag[16]  = 
#line 406
  {      (ubyte const   )0,      (ubyte const   )9,      (ubyte const   )18,      (ubyte const   )27, 
        (ubyte const   )36,      (ubyte const   )45,      (ubyte const   )54,      (ubyte const   )63, 
        (ubyte const   )7,      (ubyte const   )14,      (ubyte const   )21,      (ubyte const   )28, 
        (ubyte const   )35,      (ubyte const   )42,      (ubyte const   )49,      (ubyte const   )56};
#line 411 "tbcore.c"
static ubyte const   flipdiag[64]  = 
#line 411
  {      (ubyte const   )0,      (ubyte const   )8,      (ubyte const   )16,      (ubyte const   )24, 
        (ubyte const   )32,      (ubyte const   )40,      (ubyte const   )48,      (ubyte const   )56, 
        (ubyte const   )1,      (ubyte const   )9,      (ubyte const   )17,      (ubyte const   )25, 
        (ubyte const   )33,      (ubyte const   )41,      (ubyte const   )49,      (ubyte const   )57, 
        (ubyte const   )2,      (ubyte const   )10,      (ubyte const   )18,      (ubyte const   )26, 
        (ubyte const   )34,      (ubyte const   )42,      (ubyte const   )50,      (ubyte const   )58, 
        (ubyte const   )3,      (ubyte const   )11,      (ubyte const   )19,      (ubyte const   )27, 
        (ubyte const   )35,      (ubyte const   )43,      (ubyte const   )51,      (ubyte const   )59, 
        (ubyte const   )4,      (ubyte const   )12,      (ubyte const   )20,      (ubyte const   )28, 
        (ubyte const   )36,      (ubyte const   )44,      (ubyte const   )52,      (ubyte const   )60, 
        (ubyte const   )5,      (ubyte const   )13,      (ubyte const   )21,      (ubyte const   )29, 
        (ubyte const   )37,      (ubyte const   )45,      (ubyte const   )53,      (ubyte const   )61, 
        (ubyte const   )6,      (ubyte const   )14,      (ubyte const   )22,      (ubyte const   )30, 
        (ubyte const   )38,      (ubyte const   )46,      (ubyte const   )54,      (ubyte const   )62, 
        (ubyte const   )7,      (ubyte const   )15,      (ubyte const   )23,      (ubyte const   )31, 
        (ubyte const   )39,      (ubyte const   )47,      (ubyte const   )55,      (ubyte const   )63};
#line 422 "tbcore.c"
static ubyte const   lower[64]  = 
#line 422
  {      (ubyte const   )28,      (ubyte const   )0,      (ubyte const   )1,      (ubyte const   )2, 
        (ubyte const   )3,      (ubyte const   )4,      (ubyte const   )5,      (ubyte const   )6, 
        (ubyte const   )0,      (ubyte const   )29,      (ubyte const   )7,      (ubyte const   )8, 
        (ubyte const   )9,      (ubyte const   )10,      (ubyte const   )11,      (ubyte const   )12, 
        (ubyte const   )1,      (ubyte const   )7,      (ubyte const   )30,      (ubyte const   )13, 
        (ubyte const   )14,      (ubyte const   )15,      (ubyte const   )16,      (ubyte const   )17, 
        (ubyte const   )2,      (ubyte const   )8,      (ubyte const   )13,      (ubyte const   )31, 
        (ubyte const   )18,      (ubyte const   )19,      (ubyte const   )20,      (ubyte const   )21, 
        (ubyte const   )3,      (ubyte const   )9,      (ubyte const   )14,      (ubyte const   )18, 
        (ubyte const   )32,      (ubyte const   )22,      (ubyte const   )23,      (ubyte const   )24, 
        (ubyte const   )4,      (ubyte const   )10,      (ubyte const   )15,      (ubyte const   )19, 
        (ubyte const   )22,      (ubyte const   )33,      (ubyte const   )25,      (ubyte const   )26, 
        (ubyte const   )5,      (ubyte const   )11,      (ubyte const   )16,      (ubyte const   )20, 
        (ubyte const   )23,      (ubyte const   )25,      (ubyte const   )34,      (ubyte const   )27, 
        (ubyte const   )6,      (ubyte const   )12,      (ubyte const   )17,      (ubyte const   )21, 
        (ubyte const   )24,      (ubyte const   )26,      (ubyte const   )27,      (ubyte const   )35};
#line 433 "tbcore.c"
static ubyte const   diag[64]  = 
#line 433
  {      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )8, 
        (ubyte const   )0,      (ubyte const   )1,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )9,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )2,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )10,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )3, 
        (ubyte const   )11,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )12, 
        (ubyte const   )4,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )13,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )5,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )14,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )6,      (ubyte const   )0, 
        (ubyte const   )15,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )7};
#line 444 "tbcore.c"
static ubyte const   flap[64]  = 
#line 444
  {      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )6,      (ubyte const   )12,      (ubyte const   )18, 
        (ubyte const   )18,      (ubyte const   )12,      (ubyte const   )6,      (ubyte const   )0, 
        (ubyte const   )1,      (ubyte const   )7,      (ubyte const   )13,      (ubyte const   )19, 
        (ubyte const   )19,      (ubyte const   )13,      (ubyte const   )7,      (ubyte const   )1, 
        (ubyte const   )2,      (ubyte const   )8,      (ubyte const   )14,      (ubyte const   )20, 
        (ubyte const   )20,      (ubyte const   )14,      (ubyte const   )8,      (ubyte const   )2, 
        (ubyte const   )3,      (ubyte const   )9,      (ubyte const   )15,      (ubyte const   )21, 
        (ubyte const   )21,      (ubyte const   )15,      (ubyte const   )9,      (ubyte const   )3, 
        (ubyte const   )4,      (ubyte const   )10,      (ubyte const   )16,      (ubyte const   )22, 
        (ubyte const   )22,      (ubyte const   )16,      (ubyte const   )10,      (ubyte const   )4, 
        (ubyte const   )5,      (ubyte const   )11,      (ubyte const   )17,      (ubyte const   )23, 
        (ubyte const   )23,      (ubyte const   )17,      (ubyte const   )11,      (ubyte const   )5, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0};
#line 455 "tbcore.c"
static ubyte const   ptwist[64]  = 
#line 455
  {      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )47,      (ubyte const   )35,      (ubyte const   )23,      (ubyte const   )11, 
        (ubyte const   )10,      (ubyte const   )22,      (ubyte const   )34,      (ubyte const   )46, 
        (ubyte const   )45,      (ubyte const   )33,      (ubyte const   )21,      (ubyte const   )9, 
        (ubyte const   )8,      (ubyte const   )20,      (ubyte const   )32,      (ubyte const   )44, 
        (ubyte const   )43,      (ubyte const   )31,      (ubyte const   )19,      (ubyte const   )7, 
        (ubyte const   )6,      (ubyte const   )18,      (ubyte const   )30,      (ubyte const   )42, 
        (ubyte const   )41,      (ubyte const   )29,      (ubyte const   )17,      (ubyte const   )5, 
        (ubyte const   )4,      (ubyte const   )16,      (ubyte const   )28,      (ubyte const   )40, 
        (ubyte const   )39,      (ubyte const   )27,      (ubyte const   )15,      (ubyte const   )3, 
        (ubyte const   )2,      (ubyte const   )14,      (ubyte const   )26,      (ubyte const   )38, 
        (ubyte const   )37,      (ubyte const   )25,      (ubyte const   )13,      (ubyte const   )1, 
        (ubyte const   )0,      (ubyte const   )12,      (ubyte const   )24,      (ubyte const   )36, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0, 
        (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0,      (ubyte const   )0};
#line 466 "tbcore.c"
static ubyte const   invflap[24]  = 
#line 466
  {      (ubyte const   )8,      (ubyte const   )16,      (ubyte const   )24,      (ubyte const   )32, 
        (ubyte const   )40,      (ubyte const   )48,      (ubyte const   )9,      (ubyte const   )17, 
        (ubyte const   )25,      (ubyte const   )33,      (ubyte const   )41,      (ubyte const   )49, 
        (ubyte const   )10,      (ubyte const   )18,      (ubyte const   )26,      (ubyte const   )34, 
        (ubyte const   )42,      (ubyte const   )50,      (ubyte const   )11,      (ubyte const   )19, 
        (ubyte const   )27,      (ubyte const   )35,      (ubyte const   )43,      (ubyte const   )51};
#line 473 "tbcore.c"
static ubyte const   invptwist[48]  = 
#line 473
  {      (ubyte const   )52,      (ubyte const   )51,      (ubyte const   )44,      (ubyte const   )43, 
        (ubyte const   )36,      (ubyte const   )35,      (ubyte const   )28,      (ubyte const   )27, 
        (ubyte const   )20,      (ubyte const   )19,      (ubyte const   )12,      (ubyte const   )11, 
        (ubyte const   )53,      (ubyte const   )50,      (ubyte const   )45,      (ubyte const   )42, 
        (ubyte const   )37,      (ubyte const   )34,      (ubyte const   )29,      (ubyte const   )26, 
        (ubyte const   )21,      (ubyte const   )18,      (ubyte const   )13,      (ubyte const   )10, 
        (ubyte const   )54,      (ubyte const   )49,      (ubyte const   )46,      (ubyte const   )41, 
        (ubyte const   )38,      (ubyte const   )33,      (ubyte const   )30,      (ubyte const   )25, 
        (ubyte const   )22,      (ubyte const   )17,      (ubyte const   )14,      (ubyte const   )9, 
        (ubyte const   )55,      (ubyte const   )48,      (ubyte const   )47,      (ubyte const   )40, 
        (ubyte const   )39,      (ubyte const   )32,      (ubyte const   )31,      (ubyte const   )24, 
        (ubyte const   )23,      (ubyte const   )16,      (ubyte const   )15,      (ubyte const   )8};
#line 480 "tbcore.c"
static ubyte const   file_to_file[8]  = 
#line 480
  {      (ubyte const   )0,      (ubyte const   )1,      (ubyte const   )2,      (ubyte const   )3, 
        (ubyte const   )3,      (ubyte const   )2,      (ubyte const   )1,      (ubyte const   )0};
#line 485 "tbcore.c"
static short const   KK_idx[10][64]  = 
#line 485
  { {        (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )0, 
            (short const   )1,        (short const   )2,        (short const   )3,        (short const   )4, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )5, 
            (short const   )6,        (short const   )7,        (short const   )8,        (short const   )9, 
            (short const   )10,        (short const   )11,        (short const   )12,        (short const   )13, 
            (short const   )14,        (short const   )15,        (short const   )16,        (short const   )17, 
            (short const   )18,        (short const   )19,        (short const   )20,        (short const   )21, 
            (short const   )22,        (short const   )23,        (short const   )24,        (short const   )25, 
            (short const   )26,        (short const   )27,        (short const   )28,        (short const   )29, 
            (short const   )30,        (short const   )31,        (short const   )32,        (short const   )33, 
            (short const   )34,        (short const   )35,        (short const   )36,        (short const   )37, 
            (short const   )38,        (short const   )39,        (short const   )40,        (short const   )41, 
            (short const   )42,        (short const   )43,        (short const   )44,        (short const   )45, 
            (short const   )46,        (short const   )47,        (short const   )48,        (short const   )49, 
            (short const   )50,        (short const   )51,        (short const   )52,        (short const   )53, 
            (short const   )54,        (short const   )55,        (short const   )56,        (short const   )57}, 
   {        (short const   )58,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )59,        (short const   )60,        (short const   )61,        (short const   )62, 
            (short const   )63,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )64,        (short const   )65,        (short const   )66,        (short const   )67, 
            (short const   )68,        (short const   )69,        (short const   )70,        (short const   )71, 
            (short const   )72,        (short const   )73,        (short const   )74,        (short const   )75, 
            (short const   )76,        (short const   )77,        (short const   )78,        (short const   )79, 
            (short const   )80,        (short const   )81,        (short const   )82,        (short const   )83, 
            (short const   )84,        (short const   )85,        (short const   )86,        (short const   )87, 
            (short const   )88,        (short const   )89,        (short const   )90,        (short const   )91, 
            (short const   )92,        (short const   )93,        (short const   )94,        (short const   )95, 
            (short const   )96,        (short const   )97,        (short const   )98,        (short const   )99, 
            (short const   )100,        (short const   )101,        (short const   )102,        (short const   )103, 
            (short const   )104,        (short const   )105,        (short const   )106,        (short const   )107, 
            (short const   )108,        (short const   )109,        (short const   )110,        (short const   )111, 
            (short const   )112,        (short const   )113,        (short const   )114,        (short const   )115}, 
   {        (short const   )116,        (short const   )117,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )118,        (short const   )119,        (short const   )120, 
            (short const   )121,        (short const   )122,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )123,        (short const   )124,        (short const   )125, 
            (short const   )126,        (short const   )127,        (short const   )128,        (short const   )129, 
            (short const   )130,        (short const   )131,        (short const   )132,        (short const   )133, 
            (short const   )134,        (short const   )135,        (short const   )136,        (short const   )137, 
            (short const   )138,        (short const   )139,        (short const   )140,        (short const   )141, 
            (short const   )142,        (short const   )143,        (short const   )144,        (short const   )145, 
            (short const   )146,        (short const   )147,        (short const   )148,        (short const   )149, 
            (short const   )150,        (short const   )151,        (short const   )152,        (short const   )153, 
            (short const   )154,        (short const   )155,        (short const   )156,        (short const   )157, 
            (short const   )158,        (short const   )159,        (short const   )160,        (short const   )161, 
            (short const   )162,        (short const   )163,        (short const   )164,        (short const   )165, 
            (short const   )166,        (short const   )167,        (short const   )168,        (short const   )169, 
            (short const   )170,        (short const   )171,        (short const   )172,        (short const   )173}, 
   {        (short const   )174,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )175,        (short const   )176,        (short const   )177,        (short const   )178, 
            (short const   )179,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )180,        (short const   )181,        (short const   )182,        (short const   )183, 
            (short const   )184,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )185,        (short const   )186,        (short const   )187,        (short const   )188, 
            (short const   )189,        (short const   )190,        (short const   )191,        (short const   )192, 
            (short const   )193,        (short const   )194,        (short const   )195,        (short const   )196, 
            (short const   )197,        (short const   )198,        (short const   )199,        (short const   )200, 
            (short const   )201,        (short const   )202,        (short const   )203,        (short const   )204, 
            (short const   )205,        (short const   )206,        (short const   )207,        (short const   )208, 
            (short const   )209,        (short const   )210,        (short const   )211,        (short const   )212, 
            (short const   )213,        (short const   )214,        (short const   )215,        (short const   )216, 
            (short const   )217,        (short const   )218,        (short const   )219,        (short const   )220, 
            (short const   )221,        (short const   )222,        (short const   )223,        (short const   )224, 
            (short const   )225,        (short const   )226,        (short const   )227,        (short const   )228}, 
   {        (short const   )229,        (short const   )230,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )231,        (short const   )232,        (short const   )233, 
            (short const   )234,        (short const   )235,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )236,        (short const   )237,        (short const   )238, 
            (short const   )239,        (short const   )240,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )241,        (short const   )242,        (short const   )243, 
            (short const   )244,        (short const   )245,        (short const   )246,        (short const   )247, 
            (short const   )248,        (short const   )249,        (short const   )250,        (short const   )251, 
            (short const   )252,        (short const   )253,        (short const   )254,        (short const   )255, 
            (short const   )256,        (short const   )257,        (short const   )258,        (short const   )259, 
            (short const   )260,        (short const   )261,        (short const   )262,        (short const   )263, 
            (short const   )264,        (short const   )265,        (short const   )266,        (short const   )267, 
            (short const   )268,        (short const   )269,        (short const   )270,        (short const   )271, 
            (short const   )272,        (short const   )273,        (short const   )274,        (short const   )275, 
            (short const   )276,        (short const   )277,        (short const   )278,        (short const   )279, 
            (short const   )280,        (short const   )281,        (short const   )282,        (short const   )283}, 
   {        (short const   )284,        (short const   )285,        (short const   )286,        (short const   )287, 
            (short const   )288,        (short const   )289,        (short const   )290,        (short const   )291, 
            (short const   )292,        (short const   )293,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )294,        (short const   )295,        (short const   )296, 
            (short const   )297,        (short const   )298,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )299,        (short const   )300,        (short const   )301, 
            (short const   )302,        (short const   )303,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )304,        (short const   )305,        (short const   )306, 
            (short const   )307,        (short const   )308,        (short const   )309,        (short const   )310, 
            (short const   )311,        (short const   )312,        (short const   )313,        (short const   )314, 
            (short const   )315,        (short const   )316,        (short const   )317,        (short const   )318, 
            (short const   )319,        (short const   )320,        (short const   )321,        (short const   )322, 
            (short const   )323,        (short const   )324,        (short const   )325,        (short const   )326, 
            (short const   )327,        (short const   )328,        (short const   )329,        (short const   )330, 
            (short const   )331,        (short const   )332,        (short const   )333,        (short const   )334, 
            (short const   )335,        (short const   )336,        (short const   )337,        (short const   )338}, 
   {        (short const   )-1,        (short const   )-1,        (short const   )339,        (short const   )340, 
            (short const   )341,        (short const   )342,        (short const   )343,        (short const   )344, 
            (short const   )-1,        (short const   )-1,        (short const   )345,        (short const   )346, 
            (short const   )347,        (short const   )348,        (short const   )349,        (short const   )350, 
            (short const   )-1,        (short const   )-1,        (short const   )441,        (short const   )351, 
            (short const   )352,        (short const   )353,        (short const   )354,        (short const   )355, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )442, 
            (short const   )356,        (short const   )357,        (short const   )358,        (short const   )359, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )443,        (short const   )360,        (short const   )361,        (short const   )362, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )444,        (short const   )363,        (short const   )364, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )-1,        (short const   )445,        (short const   )365, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )446}, 
   {        (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )366, 
            (short const   )367,        (short const   )368,        (short const   )369,        (short const   )370, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )371, 
            (short const   )372,        (short const   )373,        (short const   )374,        (short const   )375, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )376, 
            (short const   )377,        (short const   )378,        (short const   )379,        (short const   )380, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )447, 
            (short const   )381,        (short const   )382,        (short const   )383,        (short const   )384, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )448,        (short const   )385,        (short const   )386,        (short const   )387, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )449,        (short const   )388,        (short const   )389, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )-1,        (short const   )450,        (short const   )390, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )451}, 
   {        (short const   )452,        (short const   )391,        (short const   )392,        (short const   )393, 
            (short const   )394,        (short const   )395,        (short const   )396,        (short const   )397, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )398,        (short const   )399,        (short const   )400,        (short const   )401, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )402,        (short const   )403,        (short const   )404,        (short const   )405, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )406,        (short const   )407,        (short const   )408,        (short const   )409, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )453,        (short const   )410,        (short const   )411,        (short const   )412, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )454,        (short const   )413,        (short const   )414, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )-1,        (short const   )455,        (short const   )415, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )456}, 
   {        (short const   )457,        (short const   )416,        (short const   )417,        (short const   )418, 
            (short const   )419,        (short const   )420,        (short const   )421,        (short const   )422, 
            (short const   )-1,        (short const   )458,        (short const   )423,        (short const   )424, 
            (short const   )425,        (short const   )426,        (short const   )427,        (short const   )428, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )429,        (short const   )430,        (short const   )431, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )432,        (short const   )433,        (short const   )434, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )435,        (short const   )436,        (short const   )437, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )459,        (short const   )438,        (short const   )439, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )-1,        (short const   )460,        (short const   )440, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )-1, 
            (short const   )-1,        (short const   )-1,        (short const   )-1,        (short const   )461}};
#line 674 "tbcore.c"
static int binomial[5][64]  ;
#line 675 "tbcore.c"
static int pawnidx[5][24]  ;
#line 676 "tbcore.c"
static int pfactor[5][4]  ;
#line 682 "tbcore.c"
static void init_indices(void) 
{ 
  int i ;
  int j___0 ;
  int k___0 ;
  int f ;
  int l ;
  int s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 686
  i = 0;
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 686
    if (! (i < 5)) {
#line 686
      goto while_break;
    }
#line 687
    j___0 = 0;
    {
#line 687
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 687
      if (! (j___0 < 64)) {
#line 687
        goto while_break___0;
      }
#line 688
      f = j___0;
#line 689
      l = 1;
#line 690
      k___0 = 1;
      {
#line 690
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 690
        if (! (k___0 <= i)) {
#line 690
          goto while_break___1;
        }
#line 691
        f *= j___0 - k___0;
#line 692
        l *= k___0 + 1;
#line 690
        k___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 694
      binomial[i][j___0] = f / l;
#line 687
      j___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 686
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  i = 0;
  {
#line 697
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 697
    if (! (i < 5)) {
#line 697
      goto while_break___2;
    }
#line 698
    s = 0;
#line 699
    j___0 = 0;
    {
#line 699
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 699
      if (! (j___0 < 6)) {
#line 699
        goto while_break___3;
      }
#line 700
      pawnidx[i][j___0] = s;
#line 701
      if (i == 0) {
#line 701
        tmp = 1;
      } else {
#line 701
        tmp = binomial[i - 1][ptwist[invflap[j___0]]];
      }
#line 701
      s += tmp;
#line 699
      j___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 703
    pfactor[i][0] = s;
#line 704
    s = 0;
    {
#line 705
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 705
      if (! (j___0 < 12)) {
#line 705
        goto while_break___4;
      }
#line 706
      pawnidx[i][j___0] = s;
#line 707
      if (i == 0) {
#line 707
        tmp___0 = 1;
      } else {
#line 707
        tmp___0 = binomial[i - 1][ptwist[invflap[j___0]]];
      }
#line 707
      s += tmp___0;
#line 705
      j___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 709
    pfactor[i][1] = s;
#line 710
    s = 0;
    {
#line 711
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 711
      if (! (j___0 < 18)) {
#line 711
        goto while_break___5;
      }
#line 712
      pawnidx[i][j___0] = s;
#line 713
      if (i == 0) {
#line 713
        tmp___1 = 1;
      } else {
#line 713
        tmp___1 = binomial[i - 1][ptwist[invflap[j___0]]];
      }
#line 713
      s += tmp___1;
#line 711
      j___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 715
    pfactor[i][2] = s;
#line 716
    s = 0;
    {
#line 717
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 717
      if (! (j___0 < 24)) {
#line 717
        goto while_break___6;
      }
#line 718
      pawnidx[i][j___0] = s;
#line 719
      if (i == 0) {
#line 719
        tmp___2 = 1;
      } else {
#line 719
        tmp___2 = binomial[i - 1][ptwist[invflap[j___0]]];
      }
#line 719
      s += tmp___2;
#line 717
      j___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 721
    pfactor[i][3] = s;
#line 697
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 734
  return;
}
}
#line 737 "tbcore.c"
static uint64 encode_piece(struct TBEntry_piece *ptr , ubyte *norm , int *pos , int *factor ) 
{ 
  uint64 idx ;
  int i ;
  int j___0 ;
  int k___0 ;
  int m ;
  int l ;
  int p ;
  int n ;
  int tmp ;
  int t ;
  int tmp___0 ;
  int s ;

  {
#line 741
  n = (int )ptr->num;
#line 743
  if (*(pos + 0) & 0x04) {
#line 744
    i = 0;
    {
#line 744
    while (1) {
      while_continue: /* CIL Label */ ;
#line 744
      if (! (i < n)) {
#line 744
        goto while_break;
      }
#line 745
      *(pos + i) ^= 0x07;
#line 744
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 747
  if (*(pos + 0) & 0x20) {
#line 748
    i = 0;
    {
#line 748
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 748
      if (! (i < n)) {
#line 748
        goto while_break___0;
      }
#line 749
      *(pos + i) ^= 0x38;
#line 748
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 752
  i = 0;
  {
#line 752
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 752
    if (! (i < n)) {
#line 752
      goto while_break___1;
    }
#line 753
    if (offdiag[*(pos + i)]) {
#line 754
      goto while_break___1;
    }
#line 752
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 755
  if ((int )ptr->enc_type == 0) {
#line 755
    tmp = 3;
  } else {
#line 755
    tmp = 2;
  }
#line 755
  if (i < tmp) {
#line 755
    if ((int const   )offdiag[*(pos + i)] > 0) {
#line 756
      i = 0;
      {
#line 756
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 756
        if (! (i < n)) {
#line 756
          goto while_break___2;
        }
#line 757
        *(pos + i) = (int )flipdiag[*(pos + i)];
#line 756
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 755
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  {
#line 761
  if ((int )ptr->enc_type == 0) {
#line 761
    goto case_0;
  }
#line 782
  if ((int )ptr->enc_type == 1) {
#line 782
    goto case_1;
  }
#line 796
  goto switch_default;
  case_0: /* CIL Label */ 
#line 762
  i = *(pos + 1) > *(pos + 0);
#line 763
  j___0 = (*(pos + 2) > *(pos + 0)) + (*(pos + 2) > *(pos + 1));
#line 765
  if (offdiag[*(pos + 0)]) {
#line 766
    idx = (uint64 )((((int const   )triangle[*(pos + 0)] * 63) * 62 + (int const   )((*(pos + 1) - i) * 62)) + (int const   )(*(pos + 2) - j___0));
  } else
#line 767
  if (offdiag[*(pos + 1)]) {
#line 768
    idx = (uint64 )((((23436 + (int )(((int const   )diag[*(pos + 0)] * 28) * 62)) + (int )((int const   )lower[*(pos + 1)] * 62)) + *(pos + 2)) - j___0);
  } else
#line 771
  if (offdiag[*(pos + 2)]) {
#line 772
    idx = (uint64 )(((30380 + (int )(((int const   )diag[*(pos + 0)] * 7) * 28)) + (int )(((int const   )diag[*(pos + 1)] - (int const   )i) * 28)) + (int )lower[*(pos + 2)]);
  } else {
#line 776
    idx = (uint64 )(((31164 + (int )(((int const   )diag[*(pos + 0)] * 7) * 6)) + (int )(((int const   )diag[*(pos + 1)] - (int const   )i) * 6)) + (int )((int const   )diag[*(pos + 2)] - (int const   )j___0));
  }
#line 779
  i = 3;
#line 780
  goto switch_break;
  case_1: /* CIL Label */ 
#line 783
  j___0 = (*(pos + 2) > *(pos + 0)) + (*(pos + 2) > *(pos + 1));
#line 785
  idx = (uint64 )KK_idx[triangle[*(pos + 0)]][*(pos + 1)];
#line 786
  if (idx < 441ULL) {
#line 787
    idx += (uint64 )(441 * (*(pos + 2) - j___0));
  } else {
#line 789
    idx = (27342ULL + (idx - 441ULL)) + (uint64 )(21 * (int )lower[*(pos + 2)]);
#line 790
    if (! offdiag[*(pos + 2)]) {
#line 791
      idx -= (uint64 )(j___0 * 21);
    }
  }
#line 793
  i = 3;
#line 794
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 797
  idx = (uint64 )KK_idx[triangle[*(pos + 0)]][*(pos + 1)];
#line 798
  i = 2;
#line 799
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 801
  idx *= (uint64 )*(factor + 0);
  {
#line 803
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 803
    if (! (i < n)) {
#line 803
      goto while_break___3;
    }
#line 804
    t = (int )*(norm + i);
#line 805
    j___0 = i;
    {
#line 805
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 805
      if (! (j___0 < i + t)) {
#line 805
        goto while_break___4;
      }
#line 806
      k___0 = j___0 + 1;
      {
#line 806
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 806
        if (! (k___0 < i + t)) {
#line 806
          goto while_break___5;
        }
#line 807
        if (*(pos + j___0) > *(pos + k___0)) {
#line 808
          tmp___0 = *(pos + j___0);
#line 808
          *(pos + j___0) = *(pos + k___0);
#line 808
          *(pos + k___0) = tmp___0;
        }
#line 806
        k___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 805
      j___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 809
    s = 0;
#line 810
    m = i;
    {
#line 810
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 810
      if (! (m < i + t)) {
#line 810
        goto while_break___6;
      }
#line 811
      p = *(pos + m);
#line 812
      l = 0;
#line 812
      j___0 = 0;
      {
#line 812
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 812
        if (! (l < i)) {
#line 812
          goto while_break___7;
        }
#line 813
        j___0 += p > *(pos + l);
#line 812
        l ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 814
      s += binomial[m - i][p - j___0];
#line 810
      m ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 816
    idx += (uint64 )s * (uint64 )*(factor + i);
#line 817
    i += t;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 820
  return (idx);
}
}
#line 948 "tbcore.c"
static int pawn_file(struct TBEntry_pawn *ptr , int *pos ) 
{ 
  int i ;
  int tmp ;

  {
#line 951
  i = 1;
  {
#line 951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 951
    if (! (i < (int )ptr->pawns[0])) {
#line 951
      goto while_break;
    }
#line 952
    if ((int const   )flap[*(pos + 0)] > (int const   )flap[*(pos + i)]) {
#line 953
      tmp = *(pos + 0);
#line 953
      *(pos + 0) = *(pos + i);
#line 953
      *(pos + i) = tmp;
    }
#line 951
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 955
  return ((int )file_to_file[*(pos + 0) & 0x07]);
}
}
#line 958 "tbcore.c"
static uint64 encode_pawn(struct TBEntry_pawn *ptr , ubyte *norm , int *pos , int *factor ) 
{ 
  uint64 idx ;
  int i ;
  int j___0 ;
  int k___0 ;
  int m ;
  int s ;
  int t ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int p ;
  int tmp___1 ;
  int p___0 ;

  {
#line 962
  n = (int )ptr->num;
#line 964
  if (*(pos + 0) & 0x04) {
#line 965
    i = 0;
    {
#line 965
    while (1) {
      while_continue: /* CIL Label */ ;
#line 965
      if (! (i < n)) {
#line 965
        goto while_break;
      }
#line 966
      *(pos + i) ^= 0x07;
#line 965
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 968
  i = 1;
  {
#line 968
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 968
    if (! (i < (int )ptr->pawns[0])) {
#line 968
      goto while_break___0;
    }
#line 969
    j___0 = i + 1;
    {
#line 969
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 969
      if (! (j___0 < (int )ptr->pawns[0])) {
#line 969
        goto while_break___1;
      }
#line 970
      if ((int const   )ptwist[*(pos + i)] < (int const   )ptwist[*(pos + j___0)]) {
#line 971
        tmp = *(pos + i);
#line 971
        *(pos + i) = *(pos + j___0);
#line 971
        *(pos + j___0) = tmp;
      }
#line 969
      j___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 968
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 973
  t = (int )ptr->pawns[0] - 1;
#line 974
  idx = (uint64 )pawnidx[t][flap[*(pos + 0)]];
#line 975
  i = t;
  {
#line 975
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 975
    if (! (i > 0)) {
#line 975
      goto while_break___2;
    }
#line 976
    idx += (uint64 )binomial[t - i][ptwist[*(pos + i)]];
#line 975
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 977
  idx *= (uint64 )*(factor + 0);
#line 980
  i = (int )ptr->pawns[0];
#line 981
  t = i + (int )ptr->pawns[1];
#line 982
  if (t > i) {
#line 983
    j___0 = i;
    {
#line 983
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 983
      if (! (j___0 < t)) {
#line 983
        goto while_break___3;
      }
#line 984
      k___0 = j___0 + 1;
      {
#line 984
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 984
        if (! (k___0 < t)) {
#line 984
          goto while_break___4;
        }
#line 985
        if (*(pos + j___0) > *(pos + k___0)) {
#line 986
          tmp___0 = *(pos + j___0);
#line 986
          *(pos + j___0) = *(pos + k___0);
#line 986
          *(pos + k___0) = tmp___0;
        }
#line 984
        k___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 983
      j___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 987
    s = 0;
#line 988
    m = i;
    {
#line 988
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 988
      if (! (m < t)) {
#line 988
        goto while_break___5;
      }
#line 989
      p = *(pos + m);
#line 990
      k___0 = 0;
#line 990
      j___0 = 0;
      {
#line 990
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 990
        if (! (k___0 < i)) {
#line 990
          goto while_break___6;
        }
#line 991
        j___0 += p > *(pos + k___0);
#line 990
        k___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 992
      s += binomial[m - i][(p - j___0) - 8];
#line 988
      m ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 994
    idx += (uint64 )s * (uint64 )*(factor + i);
#line 995
    i = t;
  }
  {
#line 998
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 998
    if (! (i < n)) {
#line 998
      goto while_break___7;
    }
#line 999
    t = (int )*(norm + i);
#line 1000
    j___0 = i;
    {
#line 1000
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1000
      if (! (j___0 < i + t)) {
#line 1000
        goto while_break___8;
      }
#line 1001
      k___0 = j___0 + 1;
      {
#line 1001
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1001
        if (! (k___0 < i + t)) {
#line 1001
          goto while_break___9;
        }
#line 1002
        if (*(pos + j___0) > *(pos + k___0)) {
#line 1003
          tmp___1 = *(pos + j___0);
#line 1003
          *(pos + j___0) = *(pos + k___0);
#line 1003
          *(pos + k___0) = tmp___1;
        }
#line 1001
        k___0 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1000
      j___0 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1004
    s = 0;
#line 1005
    m = i;
    {
#line 1005
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1005
      if (! (m < i + t)) {
#line 1005
        goto while_break___10;
      }
#line 1006
      p___0 = *(pos + m);
#line 1007
      k___0 = 0;
#line 1007
      j___0 = 0;
      {
#line 1007
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1007
        if (! (k___0 < i)) {
#line 1007
          goto while_break___11;
        }
#line 1008
        j___0 += p___0 > *(pos + k___0);
#line 1007
        k___0 ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1009
      s += binomial[m - i][p___0 - j___0];
#line 1005
      m ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1011
    idx += (uint64 )s * (uint64 )*(factor + i);
#line 1012
    i += t;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1015
  return (idx);
}
}
#line 1018
static ubyte decompress_pairs(struct PairsData *d , uint64 idx ) ;
#line 1021 "tbcore.c"
static int subfactor(int k___0 , int n ) 
{ 
  int i ;
  int f ;
  int l ;

  {
#line 1024
  f = n;
#line 1025
  l = 1;
#line 1026
  i = 1;
  {
#line 1026
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1026
    if (! (i < k___0)) {
#line 1026
      goto while_break;
    }
#line 1027
    f *= n - i;
#line 1028
    l *= i + 1;
#line 1026
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1031
  return (f / l);
}
}
#line 1039
static uint64 calc_factors_piece(int *factor , int num , int order , ubyte *norm ,
                                 ubyte enc_type ) ;
#line 1039 "tbcore.c"
static int pivfac[3]  = {      31332,      28056,      462};
#line 1034 "tbcore.c"
static uint64 calc_factors_piece(int *factor , int num , int order , ubyte *norm ,
                                 ubyte enc_type ) 
{ 
  int i ;
  int k___0 ;
  int n ;
  uint64 f ;
  int tmp ;

  {
#line 1044
  n = 64 - (int )*(norm + 0);
#line 1046
  f = (uint64 )1;
#line 1047
  i = (int )*(norm + 0);
#line 1047
  k___0 = 0;
  {
#line 1047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1047
    if (i < num) {
#line 1047
      goto _L;
    } else
#line 1047
    if (k___0 == order) {
      _L: /* CIL Label */ ;
    } else {
#line 1047
      goto while_break;
    }
#line 1048
    if (k___0 == order) {
#line 1049
      *(factor + 0) = (int )f;
#line 1051
      f *= (uint64 )pivfac[enc_type];
    } else {
#line 1059
      *(factor + i) = (int )f;
#line 1060
      tmp = subfactor((int )*(norm + i), n);
#line 1060
      f *= (uint64 )tmp;
#line 1061
      n -= (int )*(norm + i);
#line 1062
      i += (int )*(norm + i);
    }
#line 1047
    k___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1066
  return (f);
}
}
#line 1069 "tbcore.c"
static uint64 calc_factors_pawn(int *factor , int num , int order , int order2 , ubyte *norm ,
                                int file ) 
{ 
  int i ;
  int k___0 ;
  int n ;
  uint64 f ;
  int tmp ;
  int tmp___0 ;

  {
#line 1074
  i = (int )*(norm + 0);
#line 1075
  if (order2 < 0x0f) {
#line 1076
    i += (int )*(norm + i);
  }
#line 1077
  n = 64 - i;
#line 1079
  f = (uint64 )1;
#line 1080
  k___0 = 0;
  {
#line 1080
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1080
    if (i < num) {
#line 1080
      goto _L___0;
    } else
#line 1080
    if (k___0 == order) {
      _L___0: /* CIL Label */ 
#line 1080
      goto _L;
    } else
#line 1080
    if (k___0 == order2) {
      _L: /* CIL Label */ ;
    } else {
#line 1080
      goto while_break;
    }
#line 1081
    if (k___0 == order) {
#line 1082
      *(factor + 0) = (int )f;
#line 1083
      f *= (uint64 )pfactor[(int )*(norm + 0) - 1][file];
    } else
#line 1084
    if (k___0 == order2) {
#line 1085
      *(factor + *(norm + 0)) = (int )f;
#line 1086
      tmp = subfactor((int )*(norm + *(norm + 0)), 48 - (int )*(norm + 0));
#line 1086
      f *= (uint64 )tmp;
    } else {
#line 1088
      *(factor + i) = (int )f;
#line 1089
      tmp___0 = subfactor((int )*(norm + i), n);
#line 1089
      f *= (uint64 )tmp___0;
#line 1090
      n -= (int )*(norm + i);
#line 1091
      i += (int )*(norm + i);
    }
#line 1080
    k___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1095
  return (f);
}
}
#line 1098 "tbcore.c"
static void set_norm_piece(struct TBEntry_piece *ptr , ubyte *norm , ubyte *pieces___3 ) 
{ 
  int i ;
  int j___0 ;

  {
#line 1102
  i = 0;
  {
#line 1102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1102
    if (! (i < (int )ptr->num)) {
#line 1102
      goto while_break;
    }
#line 1103
    *(norm + i) = (ubyte )0;
#line 1102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1106
  if ((int )ptr->enc_type == 0) {
#line 1106
    goto case_0;
  }
#line 1109
  if ((int )ptr->enc_type == 2) {
#line 1109
    goto case_2;
  }
#line 1112
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1107
  *(norm + 0) = (ubyte )3;
#line 1108
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1110
  *(norm + 0) = (ubyte )2;
#line 1111
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1113
  *(norm + 0) = (ubyte )((int )ptr->enc_type - 1);
#line 1114
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1117
  i = (int )*(norm + 0);
  {
#line 1117
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1117
    if (! (i < (int )ptr->num)) {
#line 1117
      goto while_break___0;
    }
#line 1118
    j___0 = i;
    {
#line 1118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1118
      if (j___0 < (int )ptr->num) {
#line 1118
        if (! ((int )*(pieces___3 + j___0) == (int )*(pieces___3 + i))) {
#line 1118
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1118
        goto while_break___1;
      }
#line 1119
      *(norm + i) = (ubyte )((int )*(norm + i) + 1);
#line 1118
      j___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1117
    i += (int )*(norm + i);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1120
  return;
}
}
#line 1122 "tbcore.c"
static void set_norm_pawn(struct TBEntry_pawn *ptr , ubyte *norm , ubyte *pieces___3 ) 
{ 
  int i ;
  int j___0 ;

  {
#line 1126
  i = 0;
  {
#line 1126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1126
    if (! (i < (int )ptr->num)) {
#line 1126
      goto while_break;
    }
#line 1127
    *(norm + i) = (ubyte )0;
#line 1126
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1129
  *(norm + 0) = ptr->pawns[0];
#line 1130
  if (ptr->pawns[1]) {
#line 1131
    *(norm + ptr->pawns[0]) = ptr->pawns[1];
  }
#line 1133
  i = (int )ptr->pawns[0] + (int )ptr->pawns[1];
  {
#line 1133
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1133
    if (! (i < (int )ptr->num)) {
#line 1133
      goto while_break___0;
    }
#line 1134
    j___0 = i;
    {
#line 1134
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1134
      if (j___0 < (int )ptr->num) {
#line 1134
        if (! ((int )*(pieces___3 + j___0) == (int )*(pieces___3 + i))) {
#line 1134
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1134
        goto while_break___1;
      }
#line 1135
      *(norm + i) = (ubyte )((int )*(norm + i) + 1);
#line 1134
      j___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1133
    i += (int )*(norm + i);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1136
  return;
}
}
#line 1138 "tbcore.c"
static void setup_pieces_piece(struct TBEntry_piece *ptr , unsigned char *data___0 ,
                               uint64 *tb_size ) 
{ 
  int i ;
  int order ;

  {
#line 1143
  i = 0;
  {
#line 1143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1143
    if (! (i < (int )ptr->num)) {
#line 1143
      goto while_break;
    }
#line 1144
    ptr->pieces[0][i] = (ubyte )((int )*(data___0 + (i + 1)) & 0x0f);
#line 1143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1145
  order = (int )*(data___0 + 0) & 0x0f;
#line 1146
  set_norm_piece(ptr, ptr->norm[0], ptr->pieces[0]);
#line 1147
  *(tb_size + 0) = calc_factors_piece(ptr->factor[0], (int )ptr->num, order, ptr->norm[0],
                                      ptr->enc_type);
#line 1151
  i = 0;
  {
#line 1151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1151
    if (! (i < (int )ptr->num)) {
#line 1151
      goto while_break___0;
    }
#line 1152
    ptr->pieces[1][i] = (ubyte )((int )*(data___0 + (i + 1)) >> 4);
#line 1151
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1153
  order = (int )*(data___0 + 0) >> 4;
#line 1154
  set_norm_piece(ptr, ptr->norm[1], ptr->pieces[1]);
#line 1155
  *(tb_size + 1) = calc_factors_piece(ptr->factor[1], (int )ptr->num, order, ptr->norm[1],
                                      ptr->enc_type);
#line 1158
  return;
}
}
#line 1160 "tbcore.c"
static void setup_pieces_piece_dtz(struct DTZEntry_piece *ptr , unsigned char *data___0 ,
                                   uint64 *tb_size ) 
{ 
  int i ;
  int order ;

  {
#line 1165
  i = 0;
  {
#line 1165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1165
    if (! (i < (int )ptr->num)) {
#line 1165
      goto while_break;
    }
#line 1166
    ptr->pieces[i] = (ubyte )((int )*(data___0 + (i + 1)) & 0x0f);
#line 1165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1167
  order = (int )*(data___0 + 0) & 0x0f;
#line 1168
  set_norm_piece((struct TBEntry_piece *)ptr, ptr->norm, ptr->pieces);
#line 1169
  *(tb_size + 0) = calc_factors_piece(ptr->factor, (int )ptr->num, order, ptr->norm,
                                      ptr->enc_type);
#line 1172
  return;
}
}
#line 1174 "tbcore.c"
static void setup_pieces_pawn(struct TBEntry_pawn *ptr , unsigned char *data___0 ,
                              uint64 *tb_size , int f ) 
{ 
  int i ;
  int j___0 ;
  int order ;
  int order2 ;

  {
#line 1179
  j___0 = 1 + ((int )ptr->pawns[1] > 0);
#line 1180
  order = (int )*(data___0 + 0) & 0x0f;
#line 1181
  if (ptr->pawns[1]) {
#line 1181
    order2 = (int )*(data___0 + 1) & 0x0f;
  } else {
#line 1181
    order2 = 0x0f;
  }
#line 1182
  i = 0;
  {
#line 1182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1182
    if (! (i < (int )ptr->num)) {
#line 1182
      goto while_break;
    }
#line 1183
    ptr->file[f].pieces[0][i] = (ubyte )((int )*(data___0 + (i + j___0)) & 0x0f);
#line 1182
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  set_norm_pawn(ptr, ptr->file[f].norm[0], ptr->file[f].pieces[0]);
#line 1185
  *(tb_size + 0) = calc_factors_pawn(ptr->file[f].factor[0], (int )ptr->num, order,
                                     order2, ptr->file[f].norm[0], f);
#line 1189
  order = (int )*(data___0 + 0) >> 4;
#line 1190
  if (ptr->pawns[1]) {
#line 1190
    order2 = (int )*(data___0 + 1) >> 4;
  } else {
#line 1190
    order2 = 0x0f;
  }
#line 1191
  i = 0;
  {
#line 1191
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1191
    if (! (i < (int )ptr->num)) {
#line 1191
      goto while_break___0;
    }
#line 1192
    ptr->file[f].pieces[1][i] = (ubyte )((int )*(data___0 + (i + j___0)) >> 4);
#line 1191
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1193
  set_norm_pawn(ptr, ptr->file[f].norm[1], ptr->file[f].pieces[1]);
#line 1194
  *(tb_size + 1) = calc_factors_pawn(ptr->file[f].factor[1], (int )ptr->num, order,
                                     order2, ptr->file[f].norm[1], f);
#line 1197
  return;
}
}
#line 1199 "tbcore.c"
static void setup_pieces_pawn_dtz(struct DTZEntry_pawn *ptr , unsigned char *data___0 ,
                                  uint64 *tb_size , int f ) 
{ 
  int i ;
  int j___0 ;
  int order ;
  int order2 ;

  {
#line 1204
  j___0 = 1 + ((int )ptr->pawns[1] > 0);
#line 1205
  order = (int )*(data___0 + 0) & 0x0f;
#line 1206
  if (ptr->pawns[1]) {
#line 1206
    order2 = (int )*(data___0 + 1) & 0x0f;
  } else {
#line 1206
    order2 = 0x0f;
  }
#line 1207
  i = 0;
  {
#line 1207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1207
    if (! (i < (int )ptr->num)) {
#line 1207
      goto while_break;
    }
#line 1208
    ptr->file[f].pieces[i] = (ubyte )((int )*(data___0 + (i + j___0)) & 0x0f);
#line 1207
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1209
  set_norm_pawn((struct TBEntry_pawn *)ptr, ptr->file[f].norm, ptr->file[f].pieces);
#line 1211
  *(tb_size + 0) = calc_factors_pawn(ptr->file[f].factor, (int )ptr->num, order, order2,
                                     ptr->file[f].norm, f);
#line 1214
  return;
}
}
#line 1216 "tbcore.c"
static void calc_symlen(struct PairsData *d , int s , char *tmp ) 
{ 
  int s1 ;
  int s2 ;
  int w ;

  {
#line 1219
  w = *((int *)(d->sympat + 3 * s));
#line 1220
  s2 = (w >> 12) & 0x0fff;
#line 1221
  if (s2 == 0x0fff) {
#line 1222
    *(d->symlen + s) = (ubyte )0;
  } else {
#line 1224
    s1 = w & 0x0fff;
#line 1225
    if (! *(tmp + s1)) {
#line 1226
      calc_symlen(d, s1, tmp);
    }
#line 1227
    if (! *(tmp + s2)) {
#line 1228
      calc_symlen(d, s2, tmp);
    }
#line 1229
    *(d->symlen + s) = (ubyte )(((int )*(d->symlen + s1) + (int )*(d->symlen + s2)) + 1);
  }
#line 1231
  *(tmp + s) = (char)1;
#line 1232
  return;
}
}
#line 1234 "tbcore.c"
static struct PairsData *setup_pairs(unsigned char *data___0 , uint64 tb_size , uint64 *size ,
                                     unsigned char **next___0 , ubyte *flags , int wdl ) 
{ 
  struct PairsData *d ;
  int i ;
  void *tmp ;
  uint64 tmp___0 ;
  uint64 tmp___1 ;
  int blocksize ;
  int idxbits ;
  int real_num_blocks ;
  int num_blocks ;
  int max_len ;
  int min_len ;
  int h ;
  int num_syms ;
  void *tmp___2 ;
  int num_indices ;
  char tmp___3[4096] ;

  {
#line 1239
  *flags = *(data___0 + 0);
#line 1240
  if ((int )*(data___0 + 0) & 0x80) {
#line 1241
    tmp = malloc(sizeof(struct PairsData ));
#line 1241
    d = (struct PairsData *)tmp;
#line 1242
    d->idxbits = 0;
#line 1243
    if (wdl) {
#line 1244
      d->min_len = (int )*(data___0 + 1);
    } else {
#line 1246
      d->min_len = 0;
    }
#line 1247
    *next___0 = data___0 + 2;
#line 1248
    tmp___1 = (uint64 )0;
#line 1248
    *(size + 2) = tmp___1;
#line 1248
    tmp___0 = tmp___1;
#line 1248
    *(size + 1) = tmp___0;
#line 1248
    *(size + 0) = tmp___0;
#line 1249
    return (d);
  }
#line 1252
  blocksize = (int )*(data___0 + 1);
#line 1253
  idxbits = (int )*(data___0 + 2);
#line 1254
  real_num_blocks = (int )*((uint32 *)(data___0 + 4));
#line 1255
  num_blocks = real_num_blocks + (int )*(data___0 + 3);
#line 1256
  max_len = (int )*(data___0 + 8);
#line 1257
  min_len = (int )*(data___0 + 9);
#line 1258
  h = (max_len - min_len) + 1;
#line 1259
  num_syms = (int )*((ushort___0 *)(data___0 + (10 + 2 * h)));
#line 1260
  tmp___2 = malloc((sizeof(struct PairsData ) + (unsigned long )(h - 1) * sizeof(base_t )) + (unsigned long )num_syms);
#line 1260
  d = (struct PairsData *)tmp___2;
#line 1262
  d->blocksize = blocksize;
#line 1263
  d->idxbits = idxbits;
#line 1264
  d->offset = (ushort___0 *)(data___0 + 10);
#line 1265
  d->symlen = ((ubyte *)d + sizeof(struct PairsData )) + (unsigned long )(h - 1) * sizeof(base_t );
#line 1267
  d->sympat = data___0 + (12 + 2 * h);
#line 1268
  d->min_len = min_len;
#line 1269
  *next___0 = data___0 + (((12 + 2 * h) + 3 * num_syms) + (num_syms & 1));
#line 1271
  num_indices = (int )(((tb_size + (1ULL << idxbits)) - 1ULL) >> idxbits);
#line 1272
  *(size + 0) = 6ULL * (unsigned long long )num_indices;
#line 1273
  *(size + 1) = 2ULL * (unsigned long long )num_blocks;
#line 1274
  *(size + 2) = (1ULL << blocksize) * (unsigned long long )real_num_blocks;
#line 1278
  i = 0;
  {
#line 1278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1278
    if (! (i < num_syms)) {
#line 1278
      goto while_break;
    }
#line 1279
    tmp___3[i] = (char)0;
#line 1278
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1280
  i = 0;
  {
#line 1280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1280
    if (! (i < num_syms)) {
#line 1280
      goto while_break___0;
    }
#line 1281
    if (! tmp___3[i]) {
#line 1282
      calc_symlen(d, i, tmp___3);
    }
#line 1280
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1284
  d->base[h - 1] = (base_t )0;
#line 1285
  i = h - 2;
  {
#line 1285
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1285
    if (! (i >= 0)) {
#line 1285
      goto while_break___1;
    }
#line 1286
    d->base[i] = ((d->base[i + 1] + (base_t )*(d->offset + i)) - (base_t )*(d->offset + (i + 1))) / 2U;
#line 1285
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1291
  i = 0;
  {
#line 1291
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1291
    if (! (i < h)) {
#line 1291
      goto while_break___2;
    }
#line 1292
    d->base[i] <<= 32 - (min_len + i);
#line 1291
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1295
  d->offset -= d->min_len;
#line 1297
  return (d);
}
}
#line 1300 "tbcore.c"
static int init_table_wdl(struct TBEntry *entry , char *str ) 
{ 
  ubyte *next___0 ;
  int f ;
  int s ;
  uint64 tb_size[8] ;
  uint64 size[24] ;
  ubyte flags ;
  ubyte *data___0 ;
  int split ;
  int files___0 ;
  int tmp ;
  struct TBEntry_piece *ptr ;
  struct TBEntry_pawn *ptr___0 ;

  {
#line 1308
  entry->data = map_file((char const   *)str, (char const   *)".rtbw", & entry->mapping);
#line 1309
  if (! entry->data) {
#line 1310
    printf((char const   *)"Could not find %s.rtbw\n", str);
#line 1311
    return (0);
  }
#line 1314
  data___0 = (ubyte *)entry->data;
#line 1315
  if (*((uint32 *)data___0 + 0) != 1562634353U) {
#line 1316
    printf((char const   *)"Corrupted table.\n");
#line 1317
    unmap_file(entry->data, entry->mapping);
#line 1318
    entry->data = (char *)0;
#line 1319
    return (0);
  }
#line 1322
  split = (int )*(data___0 + 4) & 0x01;
#line 1323
  if ((int )*(data___0 + 4) & 0x02) {
#line 1323
    tmp = 4;
  } else {
#line 1323
    tmp = 1;
  }
#line 1323
  files___0 = tmp;
#line 1325
  data___0 += 5;
#line 1327
  if (! entry->has_pawns) {
#line 1328
    ptr = (struct TBEntry_piece *)entry;
#line 1329
    setup_pieces_piece(ptr, data___0, & tb_size[0]);
#line 1330
    data___0 += (int )ptr->num + 1;
#line 1331
    data___0 += (uintptr_t )data___0 & 1UL;
#line 1333
    ptr->precomp[0] = setup_pairs(data___0, tb_size[0], & size[0], & next___0, & flags,
                                  1);
#line 1335
    data___0 = next___0;
#line 1336
    if (split) {
#line 1337
      ptr->precomp[1] = setup_pairs(data___0, tb_size[1], & size[3], & next___0, & flags,
                                    1);
#line 1339
      data___0 = next___0;
    } else {
#line 1341
      ptr->precomp[1] = (struct PairsData *)((void *)0);
    }
#line 1343
    (ptr->precomp[0])->indextable = (char *)data___0;
#line 1344
    data___0 += size[0];
#line 1345
    if (split) {
#line 1346
      (ptr->precomp[1])->indextable = (char *)data___0;
#line 1347
      data___0 += size[3];
    }
#line 1350
    (ptr->precomp[0])->sizetable = (ushort___0 *)data___0;
#line 1351
    data___0 += size[1];
#line 1352
    if (split) {
#line 1353
      (ptr->precomp[1])->sizetable = (ushort___0 *)data___0;
#line 1354
      data___0 += size[4];
    }
#line 1357
    data___0 = (ubyte *)(((uintptr_t )data___0 + 63UL) & 18446744073709551552UL);
#line 1358
    (ptr->precomp[0])->data = data___0;
#line 1359
    data___0 += size[2];
#line 1360
    if (split) {
#line 1361
      data___0 = (ubyte *)(((uintptr_t )data___0 + 63UL) & 18446744073709551552UL);
#line 1362
      (ptr->precomp[1])->data = data___0;
    }
  } else {
#line 1365
    ptr___0 = (struct TBEntry_pawn *)entry;
#line 1366
    s = 1 + ((int )ptr___0->pawns[1] > 0);
#line 1367
    f = 0;
    {
#line 1367
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1367
      if (! (f < 4)) {
#line 1367
        goto while_break;
      }
#line 1368
      setup_pieces_pawn(ptr___0, data___0, & tb_size[2 * f], f);
#line 1370
      data___0 += (int )ptr___0->num + s;
#line 1367
      f ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1372
    data___0 += (uintptr_t )data___0 & 1UL;
#line 1374
    f = 0;
    {
#line 1374
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1374
      if (! (f < files___0)) {
#line 1374
        goto while_break___0;
      }
#line 1375
      ptr___0->file[f].precomp[0] = setup_pairs(data___0, tb_size[2 * f], & size[6 * f],
                                                & next___0, & flags, 1);
#line 1377
      data___0 = next___0;
#line 1378
      if (split) {
#line 1379
        ptr___0->file[f].precomp[1] = setup_pairs(data___0, tb_size[2 * f + 1], & size[6 * f + 3],
                                                  & next___0, & flags, 1);
#line 1382
        data___0 = next___0;
      } else {
#line 1384
        ptr___0->file[f].precomp[1] = (struct PairsData *)((void *)0);
      }
#line 1374
      f ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1387
    f = 0;
    {
#line 1387
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1387
      if (! (f < files___0)) {
#line 1387
        goto while_break___1;
      }
#line 1388
      (ptr___0->file[f].precomp[0])->indextable = (char *)data___0;
#line 1389
      data___0 += size[6 * f];
#line 1390
      if (split) {
#line 1391
        (ptr___0->file[f].precomp[1])->indextable = (char *)data___0;
#line 1392
        data___0 += size[6 * f + 3];
      }
#line 1387
      f ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1396
    f = 0;
    {
#line 1396
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1396
      if (! (f < files___0)) {
#line 1396
        goto while_break___2;
      }
#line 1397
      (ptr___0->file[f].precomp[0])->sizetable = (ushort___0 *)data___0;
#line 1398
      data___0 += size[6 * f + 1];
#line 1399
      if (split) {
#line 1400
        (ptr___0->file[f].precomp[1])->sizetable = (ushort___0 *)data___0;
#line 1401
        data___0 += size[6 * f + 4];
      }
#line 1396
      f ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1405
    f = 0;
    {
#line 1405
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1405
      if (! (f < files___0)) {
#line 1405
        goto while_break___3;
      }
#line 1406
      data___0 = (ubyte *)(((uintptr_t )data___0 + 63UL) & 18446744073709551552UL);
#line 1407
      (ptr___0->file[f].precomp[0])->data = data___0;
#line 1408
      data___0 += size[6 * f + 2];
#line 1409
      if (split) {
#line 1410
        data___0 = (ubyte *)(((uintptr_t )data___0 + 63UL) & 18446744073709551552UL);
#line 1411
        (ptr___0->file[f].precomp[1])->data = data___0;
#line 1412
        data___0 += size[6 * f + 5];
      }
#line 1405
      f ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1417
  return (1);
}
}
#line 1420 "tbcore.c"
static int init_table_dtz(struct TBEntry *entry ) 
{ 
  ubyte *data___0 ;
  ubyte *next___0 ;
  int f ;
  int s ;
  uint64 tb_size[4] ;
  uint64 size[12] ;
  int files___0 ;
  int tmp ;
  struct DTZEntry_piece *ptr ;
  int i ;
  struct DTZEntry_pawn *ptr___0 ;
  int i___0 ;

  {
#line 1421
  data___0 = (ubyte *)entry->data;
#line 1427
  if (! data___0) {
#line 1428
    return (0);
  }
#line 1430
  if (*((uint32 *)data___0 + 0) != 0xa50c66d7) {
#line 1431
    printf((char const   *)"Corrupted table.\n");
#line 1432
    return (0);
  }
#line 1435
  if ((int )*(data___0 + 4) & 0x02) {
#line 1435
    tmp = 4;
  } else {
#line 1435
    tmp = 1;
  }
#line 1435
  files___0 = tmp;
#line 1437
  data___0 += 5;
#line 1439
  if (! entry->has_pawns) {
#line 1440
    ptr = (struct DTZEntry_piece *)entry;
#line 1441
    setup_pieces_piece_dtz(ptr, data___0, & tb_size[0]);
#line 1442
    data___0 += (int )ptr->num + 1;
#line 1443
    data___0 += (uintptr_t )data___0 & 1UL;
#line 1445
    ptr->precomp = setup_pairs(data___0, tb_size[0], & size[0], & next___0, & ptr->flags,
                               0);
#line 1447
    data___0 = next___0;
#line 1449
    ptr->map = data___0;
#line 1450
    if ((int )ptr->flags & 2) {
#line 1452
      i = 0;
      {
#line 1452
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1452
        if (! (i < 4)) {
#line 1452
          goto while_break;
        }
#line 1453
        ptr->map_idx[i] = (ushort___0 )((data___0 + 1) - ptr->map);
#line 1454
        data___0 += 1 + (int )*(data___0 + 0);
#line 1452
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1456
      data___0 += (uintptr_t )data___0 & 1UL;
    }
#line 1459
    (ptr->precomp)->indextable = (char *)data___0;
#line 1460
    data___0 += size[0];
#line 1462
    (ptr->precomp)->sizetable = (ushort___0 *)data___0;
#line 1463
    data___0 += size[1];
#line 1465
    data___0 = (ubyte *)(((uintptr_t )data___0 + 63UL) & 18446744073709551552UL);
#line 1466
    (ptr->precomp)->data = data___0;
#line 1467
    data___0 += size[2];
  } else {
#line 1469
    ptr___0 = (struct DTZEntry_pawn *)entry;
#line 1470
    s = 1 + ((int )ptr___0->pawns[1] > 0);
#line 1471
    f = 0;
    {
#line 1471
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1471
      if (! (f < 4)) {
#line 1471
        goto while_break___0;
      }
#line 1472
      setup_pieces_pawn_dtz(ptr___0, data___0, & tb_size[f], f);
#line 1473
      data___0 += (int )ptr___0->num + s;
#line 1471
      f ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1475
    data___0 += (uintptr_t )data___0 & 1UL;
#line 1477
    f = 0;
    {
#line 1477
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1477
      if (! (f < files___0)) {
#line 1477
        goto while_break___1;
      }
#line 1478
      ptr___0->file[f].precomp = setup_pairs(data___0, tb_size[f], & size[3 * f],
                                             & next___0, & ptr___0->flags[f], 0);
#line 1481
      data___0 = next___0;
#line 1477
      f ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1484
    ptr___0->map = data___0;
#line 1485
    f = 0;
    {
#line 1485
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1485
      if (! (f < files___0)) {
#line 1485
        goto while_break___2;
      }
#line 1486
      if ((int )ptr___0->flags[f] & 2) {
#line 1488
        i___0 = 0;
        {
#line 1488
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1488
          if (! (i___0 < 4)) {
#line 1488
            goto while_break___3;
          }
#line 1489
          ptr___0->map_idx[f][i___0] = (ushort___0 )((data___0 + 1) - ptr___0->map);
#line 1490
          data___0 += 1 + (int )*(data___0 + 0);
#line 1488
          i___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1485
      f ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1494
    data___0 += (uintptr_t )data___0 & 1UL;
#line 1496
    f = 0;
    {
#line 1496
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1496
      if (! (f < files___0)) {
#line 1496
        goto while_break___4;
      }
#line 1497
      (ptr___0->file[f].precomp)->indextable = (char *)data___0;
#line 1498
      data___0 += size[3 * f];
#line 1496
      f ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1501
    f = 0;
    {
#line 1501
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1501
      if (! (f < files___0)) {
#line 1501
        goto while_break___5;
      }
#line 1502
      (ptr___0->file[f].precomp)->sizetable = (ushort___0 *)data___0;
#line 1503
      data___0 += size[3 * f + 1];
#line 1501
      f ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1506
    f = 0;
    {
#line 1506
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1506
      if (! (f < files___0)) {
#line 1506
        goto while_break___6;
      }
#line 1507
      data___0 = (ubyte *)(((uintptr_t )data___0 + 63UL) & 18446744073709551552UL);
#line 1508
      (ptr___0->file[f].precomp)->data = data___0;
#line 1509
      data___0 += size[3 * f + 2];
#line 1506
      f ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1513
  return (1);
}
}
#line 1516 "tbcore.c"
static ubyte decompress_pairs(struct PairsData *d , uint64 idx ) 
{ 
  uint32 mainidx ;
  int litidx ;
  uint32 block___0 ;
  uint32 tmp ;
  uint32 *ptr ;
  int m ;
  ushort___0 *offset ;
  base_t *base ;
  ubyte *symlen ;
  int sym ;
  int bitcnt ;
  uint32 next___0 ;
  uint32 code ;
  uint32 *tmp___0 ;
  int tmp___1 ;
  int l ;
  uint32 *tmp___2 ;
  int tmp___3 ;
  ubyte *sympat ;
  int w ;
  int s1 ;

  {
#line 1517
  if (! d->idxbits) {
#line 1518
    return ((ubyte )d->min_len);
  }
#line 1520
  mainidx = (uint32 )(idx >> d->idxbits);
#line 1521
  litidx = (int )((idx & (unsigned long long )((1 << d->idxbits) - 1)) - (unsigned long long )(1 << (d->idxbits - 1)));
#line 1522
  block___0 = *((uint32 *)(d->indextable + 6U * mainidx));
#line 1523
  litidx += (int )*((ushort___0 *)((d->indextable + 6U * mainidx) + 4));
#line 1524
  if (litidx < 0) {
    {
#line 1525
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1526
      block___0 --;
#line 1526
      litidx += (int )*(d->sizetable + block___0) + 1;
#line 1525
      if (! (litidx < 0)) {
#line 1525
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1529
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1529
      if (! (litidx > (int )*(d->sizetable + block___0))) {
#line 1529
        goto while_break___0;
      }
#line 1530
      tmp = block___0;
#line 1530
      block___0 ++;
#line 1530
      litidx -= (int )*(d->sizetable + tmp) + 1;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1533
  ptr = (uint32 *)(d->data + (block___0 << d->blocksize));
#line 1535
  m = d->min_len;
#line 1536
  offset = d->offset;
#line 1537
  base = d->base - m;
#line 1538
  symlen = d->symlen;
#line 1561
  next___0 = (uint32 )0;
#line 1562
  tmp___0 = ptr;
#line 1562
  ptr ++;
#line 1562
  tmp___1 = __builtin_bswap32((int )*tmp___0);
#line 1562
  code = (uint32 )tmp___1;
#line 1563
  bitcnt = 0;
  {
#line 1564
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1565
    l = m;
    {
#line 1566
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1566
      if (! (code < *(base + l))) {
#line 1566
        goto while_break___2;
      }
#line 1567
      l ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1568
    sym = (int )((uint32 )*(offset + l) + ((code - *(base + l)) >> (32 - l)));
#line 1569
    if (litidx < (int )*(symlen + sym) + 1) {
#line 1570
      goto while_break___1;
    }
#line 1571
    litidx -= (int )*(symlen + sym) + 1;
#line 1572
    code <<= l;
#line 1573
    if (bitcnt < l) {
#line 1574
      if (bitcnt) {
#line 1575
        code |= next___0 >> (32 - l);
#line 1576
        l -= bitcnt;
      }
#line 1578
      tmp___2 = ptr;
#line 1578
      ptr ++;
#line 1578
      tmp___3 = __builtin_bswap32((int )*tmp___2);
#line 1578
      next___0 = (uint32 )tmp___3;
#line 1579
      bitcnt = 32;
    }
#line 1581
    code |= next___0 >> (32 - l);
#line 1582
    next___0 <<= l;
#line 1583
    bitcnt -= l;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1587
  sympat = d->sympat;
  {
#line 1588
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1588
    if (! ((int )*(symlen + sym) != 0)) {
#line 1588
      goto while_break___3;
    }
#line 1589
    w = *((int *)(sympat + 3 * sym));
#line 1590
    s1 = w & 0x0fff;
#line 1591
    if (litidx < (int )*(symlen + s1) + 1) {
#line 1592
      sym = s1;
    } else {
#line 1594
      litidx -= (int )*(symlen + s1) + 1;
#line 1595
      sym = (w >> 12) & 0x0fff;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1599
  return (*(sympat + 3 * sym));
}
}
#line 1602 "tbcore.c"
void load_dtz_table(char *str , uint64 key1 , uint64 key2 ) 
{ 
  int i ;
  struct TBEntry *ptr ;
  struct TBEntry *ptr3 ;
  struct TBHashEntry *ptr2 ;
  unsigned long tmp ;
  void *tmp___0 ;
  struct DTZEntry_pawn *entry ;
  struct DTZEntry_piece *entry___0 ;
  int tmp___1 ;

  {
#line 1607
  DTZ_table[0].key1 = key1;
#line 1608
  DTZ_table[0].key2 = key2;
#line 1609
  DTZ_table[0].entry = (struct TBEntry *)((void *)0);
#line 1612
  ptr2 = TB_hash[key1 >> 54];
#line 1613
  i = 0;
  {
#line 1613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1613
    if (! (i < 5)) {
#line 1613
      goto while_break;
    }
#line 1614
    if ((ptr2 + i)->key == key1) {
#line 1615
      goto while_break;
    }
#line 1613
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1616
  if (i == 5) {
#line 1617
    return;
  }
#line 1618
  ptr = (ptr2 + i)->ptr;
#line 1620
  if (ptr->has_pawns) {
#line 1620
    tmp = sizeof(struct DTZEntry_pawn );
  } else {
#line 1620
    tmp = sizeof(struct DTZEntry_piece );
  }
#line 1620
  tmp___0 = malloc(tmp);
#line 1620
  ptr3 = (struct TBEntry *)tmp___0;
#line 1624
  ptr3->data = map_file((char const   *)str, (char const   *)".rtbz", & ptr3->mapping);
#line 1625
  ptr3->key = ptr->key;
#line 1626
  ptr3->num = ptr->num;
#line 1627
  ptr3->symmetric = ptr->symmetric;
#line 1628
  ptr3->has_pawns = ptr->has_pawns;
#line 1629
  if (ptr3->has_pawns) {
#line 1630
    entry = (struct DTZEntry_pawn *)ptr3;
#line 1631
    entry->pawns[0] = ((struct TBEntry_pawn *)ptr)->pawns[0];
#line 1632
    entry->pawns[1] = ((struct TBEntry_pawn *)ptr)->pawns[1];
  } else {
#line 1634
    entry___0 = (struct DTZEntry_piece *)ptr3;
#line 1635
    entry___0->enc_type = ((struct TBEntry_piece *)ptr)->enc_type;
  }
#line 1637
  tmp___1 = init_table_dtz(ptr3);
#line 1637
  if (tmp___1) {
#line 1640
    DTZ_table[0].entry = ptr3;
  } else {
#line 1638
    free((void *)ptr3);
  }
#line 1641
  return;
}
}
#line 1643 "tbcore.c"
static void free_wdl_entry(struct TBEntry *entry ) 
{ 
  struct TBEntry_piece *ptr ;
  struct TBEntry_pawn *ptr___0 ;
  int f ;

  {
#line 1644
  unmap_file(entry->data, entry->mapping);
#line 1645
  if (! entry->has_pawns) {
#line 1646
    ptr = (struct TBEntry_piece *)entry;
#line 1647
    free((void *)ptr->precomp[0]);
#line 1648
    if (ptr->precomp[1]) {
#line 1649
      free((void *)ptr->precomp[1]);
    }
  } else {
#line 1651
    ptr___0 = (struct TBEntry_pawn *)entry;
#line 1653
    f = 0;
    {
#line 1653
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1653
      if (! (f < 4)) {
#line 1653
        goto while_break;
      }
#line 1654
      free((void *)ptr___0->file[f].precomp[0]);
#line 1655
      if (ptr___0->file[f].precomp[1]) {
#line 1656
        free((void *)ptr___0->file[f].precomp[1]);
      }
#line 1653
      f ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1659
  return;
}
}
#line 1661 "tbcore.c"
static void free_dtz_entry(struct TBEntry *entry ) 
{ 
  struct DTZEntry_piece *ptr ;
  struct DTZEntry_pawn *ptr___0 ;
  int f ;

  {
#line 1662
  unmap_file(entry->data, entry->mapping);
#line 1663
  if (! entry->has_pawns) {
#line 1664
    ptr = (struct DTZEntry_piece *)entry;
#line 1665
    free((void *)ptr->precomp);
  } else {
#line 1667
    ptr___0 = (struct DTZEntry_pawn *)entry;
#line 1669
    f = 0;
    {
#line 1669
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1669
      if (! (f < 4)) {
#line 1669
        goto while_break;
      }
#line 1670
      free((void *)ptr___0->file[f].precomp);
#line 1669
      f ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1672
  free((void *)entry);
#line 1673
  return;
}
}
#line 1675 "tbcore.c"
static int wdl_to_map[5]  = {      1,      3,      0,      2, 
        0};
#line 1676 "tbcore.c"
static ubyte pa_flags[5]  = {      (ubyte )8,      (ubyte )0,      (ubyte )0,      (ubyte )0, 
        (ubyte )4};
#line 109 "tbprobe.c"
__inline static unsigned int _lsb(uint64_t b ) 
{ 
  size_t idx ;

  {
#line 111
  __asm__  ("bsfq %1, %0": "=r" (idx): "rm" (b));
#line 112
  return ((unsigned int )idx);
}
}
#line 493 "tbprobe.c"
static void prt_str(struct pos  const  *pos , char *str , _Bool mirror ) 
{ 
  uint64_t white___0 ;
  uint64_t black___0 ;
  int i ;
  uint64_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 494
  white___0 = (uint64_t )pos->white;
#line 494
  black___0 = (uint64_t )pos->black;
#line 496
  if (mirror) {
#line 497
    tmp = white___0;
#line 498
    white___0 = black___0;
#line 499
    black___0 = tmp;
  }
#line 501
  tmp___0 = str;
#line 501
  str ++;
#line 501
  *tmp___0 = (char )'K';
#line 502
  i = __builtin_popcountll((unsigned long long )(white___0 & (unsigned long )pos->queens));
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i > 0)) {
#line 502
      goto while_break;
    }
#line 503
    tmp___1 = str;
#line 503
    str ++;
#line 503
    *tmp___1 = (char )'Q';
#line 502
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  i = __builtin_popcountll((unsigned long long )(white___0 & (unsigned long )pos->rooks));
  {
#line 504
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 504
    if (! (i > 0)) {
#line 504
      goto while_break___0;
    }
#line 505
    tmp___2 = str;
#line 505
    str ++;
#line 505
    *tmp___2 = (char )'R';
#line 504
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 506
  i = __builtin_popcountll((unsigned long long )(white___0 & (unsigned long )pos->bishops));
  {
#line 506
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 506
    if (! (i > 0)) {
#line 506
      goto while_break___1;
    }
#line 507
    tmp___3 = str;
#line 507
    str ++;
#line 507
    *tmp___3 = (char )'B';
#line 506
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 508
  i = __builtin_popcountll((unsigned long long )(white___0 & (unsigned long )pos->knights));
  {
#line 508
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 508
    if (! (i > 0)) {
#line 508
      goto while_break___2;
    }
#line 509
    tmp___4 = str;
#line 509
    str ++;
#line 509
    *tmp___4 = (char )'N';
#line 508
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 510
  i = __builtin_popcountll((unsigned long long )(white___0 & (unsigned long )pos->pawns));
  {
#line 510
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 510
    if (! (i > 0)) {
#line 510
      goto while_break___3;
    }
#line 511
    tmp___5 = str;
#line 511
    str ++;
#line 511
    *tmp___5 = (char )'P';
#line 510
    i --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 512
  tmp___6 = str;
#line 512
  str ++;
#line 512
  *tmp___6 = (char )'v';
#line 513
  tmp___7 = str;
#line 513
  str ++;
#line 513
  *tmp___7 = (char )'K';
#line 514
  i = __builtin_popcountll((unsigned long long )(black___0 & (unsigned long )pos->queens));
  {
#line 514
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 514
    if (! (i > 0)) {
#line 514
      goto while_break___4;
    }
#line 515
    tmp___8 = str;
#line 515
    str ++;
#line 515
    *tmp___8 = (char )'Q';
#line 514
    i --;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 516
  i = __builtin_popcountll((unsigned long long )(black___0 & (unsigned long )pos->rooks));
  {
#line 516
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 516
    if (! (i > 0)) {
#line 516
      goto while_break___5;
    }
#line 517
    tmp___9 = str;
#line 517
    str ++;
#line 517
    *tmp___9 = (char )'R';
#line 516
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 518
  i = __builtin_popcountll((unsigned long long )(black___0 & (unsigned long )pos->bishops));
  {
#line 518
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 518
    if (! (i > 0)) {
#line 518
      goto while_break___6;
    }
#line 519
    tmp___10 = str;
#line 519
    str ++;
#line 519
    *tmp___10 = (char )'B';
#line 518
    i --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 520
  i = __builtin_popcountll((unsigned long long )(black___0 & (unsigned long )pos->knights));
  {
#line 520
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 520
    if (! (i > 0)) {
#line 520
      goto while_break___7;
    }
#line 521
    tmp___11 = str;
#line 521
    str ++;
#line 521
    *tmp___11 = (char )'N';
#line 520
    i --;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 522
  i = __builtin_popcountll((unsigned long long )(black___0 & (unsigned long )pos->pawns));
  {
#line 522
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 522
    if (! (i > 0)) {
#line 522
      goto while_break___8;
    }
#line 523
    tmp___12 = str;
#line 523
    str ++;
#line 523
    *tmp___12 = (char )'P';
#line 522
    i --;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 524
  tmp___13 = str;
#line 524
  str ++;
#line 524
  *tmp___13 = (char )'\000';
#line 525
  return;
}
}
#line 530 "tbprobe.c"
static uint64_t calc_key(struct pos  const  *pos , _Bool mirror ) 
{ 
  uint64_t white___0 ;
  uint64_t black___0 ;
  uint64_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 531
  white___0 = (uint64_t )pos->white;
#line 531
  black___0 = (uint64_t )pos->black;
#line 532
  if (mirror) {
#line 533
    tmp = white___0;
#line 534
    white___0 = black___0;
#line 535
    black___0 = tmp;
  }
#line 537
  tmp___0 = __builtin_popcountll((unsigned long long )(white___0 & (unsigned long )pos->queens));
#line 537
  tmp___1 = __builtin_popcountll((unsigned long long )(white___0 & (unsigned long )pos->rooks));
#line 537
  tmp___2 = __builtin_popcountll((unsigned long long )(white___0 & (unsigned long )pos->bishops));
#line 537
  tmp___3 = __builtin_popcountll((unsigned long long )(white___0 & (unsigned long )pos->knights));
#line 537
  tmp___4 = __builtin_popcountll((unsigned long long )(white___0 & (unsigned long )pos->pawns));
#line 537
  tmp___5 = __builtin_popcountll((unsigned long long )(black___0 & (unsigned long )pos->queens));
#line 537
  tmp___6 = __builtin_popcountll((unsigned long long )(black___0 & (unsigned long )pos->rooks));
#line 537
  tmp___7 = __builtin_popcountll((unsigned long long )(black___0 & (unsigned long )pos->bishops));
#line 537
  tmp___8 = __builtin_popcountll((unsigned long long )(black___0 & (unsigned long )pos->knights));
#line 537
  tmp___9 = __builtin_popcountll((unsigned long long )(black___0 & (unsigned long )pos->pawns));
#line 537
  return ((uint64_t )((((((((((unsigned long long )tmp___0 * 11811845319353239651ull + (unsigned long long )tmp___1 * 10979190538029446137ull) + (unsigned long long )tmp___2 * 12311744257139811149ull) + (unsigned long long )tmp___3 * 15202887380319082783ull) + (unsigned long long )tmp___4 * 17008651141875982339ull) + (unsigned long long )tmp___5 * 15484752644942473553ull) + (unsigned long long )tmp___6 * 18264461213049635989ull) + (unsigned long long )tmp___7 * 15394650811035483107ull) + (unsigned long long )tmp___8 * 13469005675588064321ull) + (unsigned long long )tmp___9 * 11695583624105689831ull));
}
}
#line 549 "tbprobe.c"
static uint64_t calc_key_from_pcs(int *pcs , int mirror ) 
{ 


  {
#line 550
  if (mirror) {
#line 550
    mirror = 8;
  } else {
#line 550
    mirror = 0;
  }
#line 551
  return ((uint64_t )((((((((((unsigned long long )*(pcs + (5 ^ mirror)) * 11811845319353239651ull + (unsigned long long )*(pcs + (4 ^ mirror)) * 10979190538029446137ull) + (unsigned long long )*(pcs + (3 ^ mirror)) * 12311744257139811149ull) + (unsigned long long )*(pcs + (2 ^ mirror)) * 15202887380319082783ull) + (unsigned long long )*(pcs + (1 ^ mirror)) * 17008651141875982339ull) + (unsigned long long )*(pcs + (13 ^ mirror)) * 15484752644942473553ull) + (unsigned long long )*(pcs + (12 ^ mirror)) * 18264461213049635989ull) + (unsigned long long )*(pcs + (11 ^ mirror)) * 15394650811035483107ull) + (unsigned long long )*(pcs + (10 ^ mirror)) * 13469005675588064321ull) + (unsigned long long )*(pcs + (9 ^ mirror)) * 11695583624105689831ull));
}
}
#line 563 "tbprobe.c"
static uint64_t get_pieces(struct pos  const  *pos , uint8_t code ) 
{ 


  {
  {
#line 565
  if ((int )code == 6) {
#line 565
    goto case_6;
  }
#line 567
  if ((int )code == 5) {
#line 567
    goto case_5;
  }
#line 569
  if ((int )code == 4) {
#line 569
    goto case_4;
  }
#line 571
  if ((int )code == 3) {
#line 571
    goto case_3;
  }
#line 573
  if ((int )code == 2) {
#line 573
    goto case_2;
  }
#line 575
  if ((int )code == 1) {
#line 575
    goto case_1;
  }
#line 577
  if ((int )code == 14) {
#line 577
    goto case_14;
  }
#line 579
  if ((int )code == 13) {
#line 579
    goto case_13;
  }
#line 581
  if ((int )code == 12) {
#line 581
    goto case_12;
  }
#line 583
  if ((int )code == 11) {
#line 583
    goto case_11;
  }
#line 585
  if ((int )code == 10) {
#line 585
    goto case_10;
  }
#line 587
  if ((int )code == 9) {
#line 587
    goto case_9;
  }
#line 589
  goto switch_default;
  case_6: /* CIL Label */ 
#line 566
  return ((uint64_t )(pos->kings & pos->white));
  case_5: /* CIL Label */ 
#line 568
  return ((uint64_t )(pos->queens & pos->white));
  case_4: /* CIL Label */ 
#line 570
  return ((uint64_t )(pos->rooks & pos->white));
  case_3: /* CIL Label */ 
#line 572
  return ((uint64_t )(pos->bishops & pos->white));
  case_2: /* CIL Label */ 
#line 574
  return ((uint64_t )(pos->knights & pos->white));
  case_1: /* CIL Label */ 
#line 576
  return ((uint64_t )(pos->pawns & pos->white));
  case_14: /* CIL Label */ 
#line 578
  return ((uint64_t )(pos->kings & pos->black));
  case_13: /* CIL Label */ 
#line 580
  return ((uint64_t )(pos->queens & pos->black));
  case_12: /* CIL Label */ 
#line 582
  return ((uint64_t )(pos->rooks & pos->black));
  case_11: /* CIL Label */ 
#line 584
  return ((uint64_t )(pos->bishops & pos->black));
  case_10: /* CIL Label */ 
#line 586
  return ((uint64_t )(pos->knights & pos->black));
  case_9: /* CIL Label */ 
#line 588
  return ((uint64_t )(pos->pawns & pos->black));
  switch_default: /* CIL Label */ 
#line 590
  return ((uint64_t )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 594 "tbprobe.c"
static int probe_wdl_table(struct pos  const  *pos , int *success ) 
{ 
  struct TBEntry *ptr ;
  struct TBHashEntry *ptr2 ;
  uint64_t idx ;
  uint64_t key ;
  int i ;
  uint8_t res ;
  int p[6] ;
  char str[16] ;
  int tmp ;
  int bside ;
  int mirror ;
  int cmirror ;
  struct TBEntry_piece *entry ;
  uint8_t *pc ;
  uint64_t bb ;
  uint64_t tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  uint64 tmp___3 ;
  struct TBEntry_pawn *entry___0 ;
  int k___0 ;
  uint64_t bb___0 ;
  uint64_t tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  int f ;
  int tmp___7 ;
  uint8_t *pc___0 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  uint64 tmp___10 ;

  {
#line 604
  key = calc_key(pos, (_Bool)0);
#line 607
  if (key == 0UL) {
#line 608
    return (0);
  }
#line 610
  ptr2 = TB_hash[key >> 54];
#line 611
  i = 0;
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (! (i < 5)) {
#line 611
      goto while_break;
    }
#line 612
    if ((ptr2 + i)->key == (uint64 )key) {
#line 613
      goto while_break;
    }
#line 611
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  if (i == 5) {
#line 616
    *success = 0;
#line 617
    return (0);
  }
#line 620
  ptr = (ptr2 + i)->ptr;
#line 621
  if (! ptr->ready) {
#line 622
    pthread_mutex_lock(& TB_MUTEX);
#line 623
    if (! ptr->ready) {
#line 625
      prt_str(pos, str, (_Bool )(ptr->key != (uint64 )key));
#line 626
      tmp = init_table_wdl(ptr, str);
#line 626
      if (! tmp) {
#line 627
        (ptr2 + i)->key = 0ULL;
#line 628
        *success = 0;
#line 629
        pthread_mutex_unlock(& TB_MUTEX);
#line 630
        return (0);
      }
#line 633
      __asm__  volatile   ("": : : "memory");
#line 634
      ptr->ready = (ubyte )1;
    }
#line 636
    pthread_mutex_unlock(& TB_MUTEX);
  }
#line 640
  if (! ptr->symmetric) {
#line 641
    if ((uint64 )key != ptr->key) {
#line 642
      cmirror = 8;
#line 643
      mirror = 0x38;
#line 644
      bside = (int )pos->turn;
    } else {
#line 646
      mirror = 0;
#line 646
      cmirror = mirror;
#line 647
      bside = ! pos->turn;
    }
  } else {
#line 650
    if (pos->turn) {
#line 650
      cmirror = 0;
    } else {
#line 650
      cmirror = 8;
    }
#line 651
    if (pos->turn) {
#line 651
      mirror = 0;
    } else {
#line 651
      mirror = 0x38;
    }
#line 652
    bside = 0;
  }
#line 658
  if (! ptr->has_pawns) {
#line 659
    entry = (struct TBEntry_piece *)ptr;
#line 660
    pc = entry->pieces[bside];
#line 661
    i = 0;
    {
#line 661
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 661
      if (! (i < (int )entry->num)) {
#line 661
        goto while_break___0;
      }
#line 662
      tmp___0 = get_pieces(pos, (uint8_t )((int )*(pc + i) ^ cmirror));
#line 662
      bb = tmp___0;
      {
#line 663
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 664
        tmp___1 = i;
#line 664
        i ++;
#line 664
        tmp___2 = _lsb(bb);
#line 664
        p[tmp___1] = (int )tmp___2;
#line 665
        bb &= bb - 1UL;
#line 663
        if (! bb) {
#line 663
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 668
    tmp___3 = encode_piece(entry, entry->norm[bside], p, entry->factor[bside]);
#line 668
    idx = (uint64_t )tmp___3;
#line 669
    res = decompress_pairs(entry->precomp[bside], (uint64 )idx);
  } else {
#line 671
    entry___0 = (struct TBEntry_pawn *)ptr;
#line 672
    k___0 = (int )entry___0->file[0].pieces[0][0] ^ cmirror;
#line 673
    tmp___4 = get_pieces(pos, (uint8_t )k___0);
#line 673
    bb___0 = tmp___4;
#line 674
    i = 0;
    {
#line 675
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 676
      tmp___5 = i;
#line 676
      i ++;
#line 676
      tmp___6 = _lsb(bb___0);
#line 676
      p[tmp___5] = (int )(tmp___6 ^ (unsigned int )mirror);
#line 677
      bb___0 &= bb___0 - 1UL;
#line 675
      if (! bb___0) {
#line 675
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 679
    tmp___7 = pawn_file(entry___0, p);
#line 679
    f = tmp___7;
#line 680
    pc___0 = entry___0->file[f].pieces[bside];
    {
#line 681
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 681
      if (! (i < (int )entry___0->num)) {
#line 681
        goto while_break___3;
      }
#line 682
      bb___0 = get_pieces(pos, (uint8_t )((int )*(pc___0 + i) ^ cmirror));
      {
#line 683
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 684
        tmp___8 = i;
#line 684
        i ++;
#line 684
        tmp___9 = _lsb(bb___0);
#line 684
        p[tmp___8] = (int )(tmp___9 ^ (unsigned int )mirror);
#line 685
        bb___0 &= bb___0 - 1UL;
#line 683
        if (! bb___0) {
#line 683
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 688
    tmp___10 = encode_pawn(entry___0, entry___0->file[f].norm[bside], p, entry___0->file[f].factor[bside]);
#line 688
    idx = (uint64_t )tmp___10;
#line 691
    res = decompress_pairs(entry___0->file[f].precomp[bside], (uint64 )idx);
  }
#line 694
  return ((int )res - 2);
}
}
#line 697 "tbprobe.c"
static int probe_dtz_table(struct pos  const  *pos , int wdl , int *success ) 
{ 
  struct TBEntry *ptr ;
  uint64_t idx ;
  int i ;
  int res ;
  int p[6] ;
  uint64_t key ;
  uint64_t tmp ;
  struct DTZTableEntry table_entry ;
  struct TBHashEntry *ptr2 ;
  char str[16] ;
  int mirror ;
  uint64_t key1 ;
  uint64_t tmp___0 ;
  uint64_t key2 ;
  uint64_t tmp___1 ;
  int bside ;
  int mirror___0 ;
  int cmirror ;
  struct DTZEntry_piece *entry ;
  uint8_t *pc ;
  uint64_t bb ;
  uint64_t tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  uint64 tmp___5 ;
  ubyte tmp___6 ;
  struct DTZEntry_pawn *entry___0 ;
  int k___0 ;
  uint64_t bb___0 ;
  uint64_t tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int f ;
  int tmp___10 ;
  uint8_t *pc___0 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  uint64 tmp___13 ;
  ubyte tmp___14 ;

  {
#line 704
  tmp = calc_key(pos, (_Bool)0);
#line 704
  key = tmp;
#line 706
  if (DTZ_table[0].key1 != (uint64 )key) {
#line 706
    if (DTZ_table[0].key2 != (uint64 )key) {
#line 707
      i = 1;
      {
#line 707
      while (1) {
        while_continue: /* CIL Label */ ;
#line 707
        if (! (i < 64)) {
#line 707
          goto while_break;
        }
#line 708
        if (DTZ_table[i].key1 == (uint64 )key) {
#line 708
          goto _L;
        } else
#line 708
        if (DTZ_table[i].key2 == (uint64 )key) {
          _L: /* CIL Label */ 
#line 709
          goto while_break;
        }
#line 707
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 713
      if (i < 64) {
#line 714
        table_entry = DTZ_table[i];
        {
#line 715
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 715
          if (! (i > 0)) {
#line 715
            goto while_break___0;
          }
#line 716
          DTZ_table[i] = DTZ_table[i - 1];
#line 715
          i --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 717
        DTZ_table[0] = table_entry;
      } else {
#line 719
        ptr2 = TB_hash[key >> 54];
#line 720
        i = 0;
        {
#line 720
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 720
          if (! (i < 5)) {
#line 720
            goto while_break___1;
          }
#line 721
          if ((ptr2 + i)->key == (uint64 )key) {
#line 722
            goto while_break___1;
          }
#line 720
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 724
        if (i == 5) {
#line 725
          *success = 0;
#line 726
          return (0);
        }
#line 728
        ptr = (ptr2 + i)->ptr;
#line 730
        mirror = ptr->key != (uint64 )key;
#line 731
        prt_str(pos, str, (_Bool )mirror);
#line 732
        if (DTZ_table[63].entry) {
#line 733
          free_dtz_entry(DTZ_table[63].entry);
        }
#line 734
        i = 63;
        {
#line 734
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 734
          if (! (i > 0)) {
#line 734
            goto while_break___2;
          }
#line 735
          DTZ_table[i] = DTZ_table[i - 1];
#line 734
          i --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 736
        tmp___0 = calc_key(pos, (_Bool )mirror);
#line 736
        key1 = tmp___0;
#line 737
        tmp___1 = calc_key(pos, (_Bool )(! mirror));
#line 737
        key2 = tmp___1;
#line 738
        load_dtz_table(str, (uint64 )key1, (uint64 )key2);
      }
    } else {
#line 706
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 742
  ptr = DTZ_table[0].entry;
#line 743
  if (! ptr) {
#line 744
    *success = 0;
#line 745
    return (0);
  }
#line 749
  if (! ptr->symmetric) {
#line 750
    if ((uint64 )key != ptr->key) {
#line 751
      cmirror = 8;
#line 752
      mirror___0 = 0x38;
#line 753
      bside = (int )pos->turn;
    } else {
#line 755
      mirror___0 = 0;
#line 755
      cmirror = mirror___0;
#line 756
      bside = ! pos->turn;
    }
  } else {
#line 759
    if (pos->turn) {
#line 759
      cmirror = 0;
    } else {
#line 759
      cmirror = 8;
    }
#line 760
    if (pos->turn) {
#line 760
      mirror___0 = 0;
    } else {
#line 760
      mirror___0 = 0x38;
    }
#line 761
    bside = 0;
  }
#line 764
  if (! ptr->has_pawns) {
#line 765
    entry = (struct DTZEntry_piece *)ptr;
#line 766
    if (((int )entry->flags & 1) != bside) {
#line 766
      if (! entry->symmetric) {
#line 767
        *success = -1;
#line 768
        return (0);
      } else {
#line 766
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
#line 770
    pc = entry->pieces;
#line 771
    i = 0;
    {
#line 771
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 771
      if (! (i < (int )entry->num)) {
#line 771
        goto while_break___3;
      }
#line 772
      tmp___2 = get_pieces(pos, (uint8_t )((int )*(pc + i) ^ cmirror));
#line 772
      bb = tmp___2;
      {
#line 773
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 774
        tmp___3 = i;
#line 774
        i ++;
#line 774
        tmp___4 = _lsb(bb);
#line 774
        p[tmp___3] = (int )tmp___4;
#line 775
        bb &= bb - 1UL;
#line 773
        if (! bb) {
#line 773
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 779
    tmp___5 = encode_piece((struct TBEntry_piece *)entry, entry->norm, p, entry->factor);
#line 779
    idx = (uint64_t )tmp___5;
#line 782
    tmp___6 = decompress_pairs(entry->precomp, (uint64 )idx);
#line 782
    res = (int )tmp___6;
#line 784
    if ((int )entry->flags & 2) {
#line 785
      res = (int )*(entry->map + ((int )entry->map_idx[wdl_to_map[wdl + 2]] + res));
    }
#line 786
    if (! ((int )entry->flags & (int )pa_flags[wdl + 2])) {
#line 786
      goto _L___2;
    } else
#line 786
    if (wdl & 1) {
      _L___2: /* CIL Label */ 
#line 787
      res *= 2;
    }
  } else {
#line 789
    entry___0 = (struct DTZEntry_pawn *)ptr;
#line 790
    k___0 = (int )entry___0->file[0].pieces[0] ^ cmirror;
#line 791
    tmp___7 = get_pieces(pos, (uint8_t )k___0);
#line 791
    bb___0 = tmp___7;
#line 792
    i = 0;
    {
#line 793
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 794
      tmp___8 = i;
#line 794
      i ++;
#line 794
      tmp___9 = _lsb(bb___0);
#line 794
      p[tmp___8] = (int )(tmp___9 ^ (unsigned int )mirror___0);
#line 795
      bb___0 &= bb___0 - 1UL;
#line 793
      if (! bb___0) {
#line 793
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 798
    tmp___10 = pawn_file((struct TBEntry_pawn *)entry___0, p);
#line 798
    f = tmp___10;
#line 799
    if (((int )entry___0->flags[f] & 1) != bside) {
#line 800
      *success = -1;
#line 801
      return (0);
    }
#line 803
    pc___0 = entry___0->file[f].pieces;
    {
#line 804
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 804
      if (! (i < (int )entry___0->num)) {
#line 804
        goto while_break___6;
      }
#line 805
      bb___0 = get_pieces(pos, (uint8_t )((int )*(pc___0 + i) ^ cmirror));
      {
#line 806
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 807
        tmp___11 = i;
#line 807
        i ++;
#line 807
        tmp___12 = _lsb(bb___0);
#line 807
        p[tmp___11] = (int )(tmp___12 ^ (unsigned int )mirror___0);
#line 808
        bb___0 &= bb___0 - 1UL;
#line 806
        if (! bb___0) {
#line 806
          goto while_break___7;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 812
    tmp___13 = encode_pawn((struct TBEntry_pawn *)entry___0, entry___0->file[f].norm,
                           p, entry___0->file[f].factor);
#line 812
    idx = (uint64_t )tmp___13;
#line 815
    tmp___14 = decompress_pairs(entry___0->file[f].precomp, (uint64 )idx);
#line 815
    res = (int )tmp___14;
#line 817
    if ((int )entry___0->flags[f] & 2) {
#line 818
      res = (int )*(entry___0->map + ((int )entry___0->map_idx[f][wdl_to_map[wdl + 2]] + res));
    }
#line 819
    if (! ((int )entry___0->flags[f] & (int )pa_flags[wdl + 2])) {
#line 819
      goto _L___3;
    } else
#line 819
    if (wdl & 1) {
      _L___3: /* CIL Label */ 
#line 820
      res *= 2;
    }
  }
#line 823
  return (res);
}
}
#line 826 "tbprobe.c"
static uint16_t *add_move(uint16_t *moves , _Bool promotes , unsigned int from , unsigned int to ) 
{ 
  uint16_t *tmp ;
  uint16_t *tmp___0 ;
  uint16_t *tmp___1 ;
  uint16_t *tmp___2 ;
  uint16_t *tmp___3 ;

  {
#line 828
  if (! promotes) {
#line 829
    tmp = moves;
#line 829
    moves ++;
#line 829
    *tmp = (uint16_t )(((from & 63U) << 6) | (to & 63U));
  } else {
#line 831
    tmp___0 = moves;
#line 831
    moves ++;
#line 831
    *tmp___0 = (uint16_t )(((unsigned int )(1 << 12) | ((from & 63U) << 6)) | (to & 63U));
#line 832
    tmp___1 = moves;
#line 832
    moves ++;
#line 832
    *tmp___1 = (uint16_t )(((unsigned int )(4 << 12) | ((from & 63U) << 6)) | (to & 63U));
#line 833
    tmp___2 = moves;
#line 833
    moves ++;
#line 833
    *tmp___2 = (uint16_t )(((unsigned int )(2 << 12) | ((from & 63U) << 6)) | (to & 63U));
#line 834
    tmp___3 = moves;
#line 834
    moves ++;
#line 834
    *tmp___3 = (uint16_t )(((unsigned int )(3 << 12) | ((from & 63U) << 6)) | (to & 63U));
  }
#line 836
  return (moves);
}
}
#line 842 "tbprobe.c"
static uint16_t *gen_captures_or_promotions(struct pos  const  *pos , uint16_t *moves ) 
{ 
  uint64_t occ ;
  uint64_t us ;
  uint64_t tmp ;
  uint64_t them ;
  uint64_t tmp___0 ;
  uint64_t b ;
  uint64_t att ;
  unsigned int from ;
  unsigned int tmp___1 ;
  unsigned int to ;
  unsigned int tmp___2 ;
  unsigned int from___0 ;
  unsigned int tmp___3 ;
  unsigned int to___0 ;
  unsigned int tmp___4 ;
  unsigned int from___1 ;
  unsigned int tmp___5 ;
  unsigned int to___1 ;
  unsigned int tmp___6 ;
  unsigned int from___2 ;
  unsigned int tmp___7 ;
  unsigned int to___2 ;
  unsigned int tmp___8 ;
  unsigned int from___3 ;
  unsigned int tmp___9 ;
  unsigned int to___3 ;
  unsigned int tmp___10 ;
  unsigned int from___4 ;
  unsigned int tmp___11 ;
  unsigned int to___4 ;
  unsigned int to___5 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  unsigned int to___6 ;
  unsigned int to___7 ;

  {
#line 844
  occ = (uint64_t )(pos->white | pos->black);
#line 845
  if (pos->turn) {
#line 845
    tmp = pos->white;
  } else {
#line 845
    tmp = pos->black;
  }
#line 845
  us = (uint64_t )tmp;
#line 845
  if (pos->turn) {
#line 845
    tmp___0 = pos->black;
  } else {
#line 845
    tmp___0 = pos->white;
  }
#line 845
  them = (uint64_t )tmp___0;
#line 849
  tmp___1 = _lsb((uint64_t )(pos->kings & (unsigned long )us));
#line 849
  from = tmp___1;
#line 850
  att = king_attacks[from] & them;
  {
#line 850
  while (1) {
    while_continue: /* CIL Label */ ;
#line 850
    if (! att) {
#line 850
      goto while_break;
    }
#line 851
    tmp___2 = _lsb(att);
#line 851
    to = tmp___2;
#line 852
    moves = add_move(moves, (_Bool)0, from, to);
#line 850
    att &= att - 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 855
  b = us & (unsigned long )pos->queens;
  {
#line 855
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 855
    if (! b) {
#line 855
      goto while_break___0;
    }
#line 856
    tmp___3 = _lsb(b);
#line 856
    from___0 = tmp___3;
#line 857
    att = (*(magic_bishop_indices[from___0] + ((occ & (unsigned long )magic_bishop_mask[from___0]) * (unsigned long )magic_bishop[from___0] >> magic_bishop_shift[from___0])) | *(magic_rook_indices[from___0] + ((occ & (unsigned long )magic_rook_mask[from___0]) * (unsigned long )magic_rook[from___0] >> magic_rook_shift[from___0]))) & them;
    {
#line 857
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 857
      if (! att) {
#line 857
        goto while_break___1;
      }
#line 858
      tmp___4 = _lsb(att);
#line 858
      to___0 = tmp___4;
#line 859
      moves = add_move(moves, (_Bool)0, from___0, to___0);
#line 857
      att &= att - 1UL;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 855
    b &= b - 1UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 862
  b = us & (unsigned long )pos->rooks;
  {
#line 862
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 862
    if (! b) {
#line 862
      goto while_break___2;
    }
#line 863
    tmp___5 = _lsb(b);
#line 863
    from___1 = tmp___5;
#line 864
    att = *(magic_rook_indices[from___1] + ((occ & (unsigned long )magic_rook_mask[from___1]) * (unsigned long )magic_rook[from___1] >> magic_rook_shift[from___1])) & them;
    {
#line 864
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 864
      if (! att) {
#line 864
        goto while_break___3;
      }
#line 865
      tmp___6 = _lsb(att);
#line 865
      to___1 = tmp___6;
#line 866
      moves = add_move(moves, (_Bool)0, from___1, to___1);
#line 864
      att &= att - 1UL;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 862
    b &= b - 1UL;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 869
  b = us & (unsigned long )pos->bishops;
  {
#line 869
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 869
    if (! b) {
#line 869
      goto while_break___4;
    }
#line 870
    tmp___7 = _lsb(b);
#line 870
    from___2 = tmp___7;
#line 871
    att = *(magic_bishop_indices[from___2] + ((occ & (unsigned long )magic_bishop_mask[from___2]) * (unsigned long )magic_bishop[from___2] >> magic_bishop_shift[from___2])) & them;
    {
#line 871
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 871
      if (! att) {
#line 871
        goto while_break___5;
      }
#line 872
      tmp___8 = _lsb(att);
#line 872
      to___2 = tmp___8;
#line 873
      moves = add_move(moves, (_Bool)0, from___2, to___2);
#line 871
      att &= att - 1UL;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 869
    b &= b - 1UL;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 876
  b = us & (unsigned long )pos->knights;
  {
#line 876
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 876
    if (! b) {
#line 876
      goto while_break___6;
    }
#line 877
    tmp___9 = _lsb(b);
#line 877
    from___3 = tmp___9;
#line 878
    att = knight_attacks[from___3] & them;
    {
#line 878
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 878
      if (! att) {
#line 878
        goto while_break___7;
      }
#line 879
      tmp___10 = _lsb(att);
#line 879
      to___3 = tmp___10;
#line 880
      moves = add_move(moves, (_Bool)0, from___3, to___3);
#line 878
      att &= att - 1UL;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 876
    b &= b - 1UL;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 883
  b = us & (unsigned long )pos->pawns;
  {
#line 883
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 883
    if (! b) {
#line 883
      goto while_break___8;
    }
#line 884
    tmp___11 = _lsb(b);
#line 884
    from___4 = tmp___11;
#line 885
    att = pawn_attacks[pos->turn][from___4];
#line 886
    if ((int )pos->ep != 0) {
#line 886
      if ((att & (1UL << (int )pos->ep)) != 0UL) {
#line 887
        to___4 = (unsigned int )pos->ep;
#line 888
        moves = add_move(moves, (_Bool)0, from___4, to___4);
      } else {
#line 886
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 890
    att &= them;
    {
#line 890
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 890
      if (! att) {
#line 890
        goto while_break___9;
      }
#line 891
      tmp___12 = _lsb(att);
#line 891
      to___5 = tmp___12;
#line 892
      if (to___5 >> 3 == 7U) {
#line 892
        goto _L___0;
      } else
#line 892
      if (to___5 >> 3 == 0U) {
        _L___0: /* CIL Label */ 
#line 892
        tmp___13 = 1;
      } else {
#line 892
        tmp___13 = 0;
      }
#line 892
      moves = add_move(moves, (_Bool )tmp___13, from___4, to___5);
#line 890
      att &= att - 1UL;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 894
    if (pos->turn) {
#line 894
      if (from___4 >> 3 == 6U) {
#line 895
        to___6 = from___4 + 8U;
#line 896
        if (((1UL << to___6) & occ) == 0UL) {
#line 897
          moves = add_move(moves, (_Bool)1, from___4, to___6);
        }
      } else {
#line 894
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 898
    if (! pos->turn) {
#line 898
      if (from___4 >> 3 == 1U) {
#line 899
        to___7 = from___4 - 8U;
#line 900
        if (((1UL << to___7) & occ) == 0UL) {
#line 901
          moves = add_move(moves, (_Bool)1, from___4, to___7);
        }
      } else {
#line 898
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
#line 883
    b &= b - 1UL;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 904
  return (moves);
}
}
#line 910 "tbprobe.c"
static uint16_t *gen_pawn_quiets_or_promotions(struct pos  const  *pos , uint16_t *moves ) 
{ 
  uint64_t occ ;
  uint64_t us ;
  uint64_t tmp ;
  uint64_t b ;
  uint64_t att ;
  unsigned int from ;
  unsigned int tmp___0 ;
  unsigned int next___0 ;
  int tmp___1 ;
  unsigned int next2 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int to ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 912
  occ = (uint64_t )(pos->white | pos->black);
#line 913
  if (pos->turn) {
#line 913
    tmp = pos->white;
  } else {
#line 913
    tmp = pos->black;
  }
#line 913
  us = (uint64_t )tmp;
#line 916
  b = us & (unsigned long )pos->pawns;
  {
#line 916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 916
    if (! b) {
#line 916
      goto while_break;
    }
#line 917
    tmp___0 = _lsb(b);
#line 917
    from = tmp___0;
#line 918
    if (pos->turn) {
#line 918
      tmp___1 = 8;
    } else {
#line 918
      tmp___1 = -8;
    }
#line 918
    next___0 = from + (unsigned int )tmp___1;
#line 919
    att = (uint64_t )0;
#line 920
    if (((1UL << next___0) & occ) == 0UL) {
#line 921
      att |= 1UL << next___0;
#line 922
      if (pos->turn) {
#line 922
        tmp___2 = 16;
      } else {
#line 922
        tmp___2 = -16;
      }
#line 922
      next2 = from + (unsigned int )tmp___2;
#line 923
      if (pos->turn) {
#line 923
        tmp___3 = from >> 3 == 1U;
      } else {
#line 923
        tmp___3 = from >> 3 == 6U;
      }
#line 923
      if (tmp___3) {
#line 923
        if (((1UL << next2) & occ) == 0UL) {
#line 925
          att |= 1UL << next2;
        } else {
#line 923
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
    }
    {
#line 927
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 927
      if (! att) {
#line 927
        goto while_break___0;
      }
#line 928
      tmp___4 = _lsb(att);
#line 928
      to = tmp___4;
#line 929
      if (to >> 3 == 7U) {
#line 929
        goto _L___0;
      } else
#line 929
      if (to >> 3 == 0U) {
        _L___0: /* CIL Label */ 
#line 929
        tmp___5 = 1;
      } else {
#line 929
        tmp___5 = 0;
      }
#line 929
      moves = add_move(moves, (_Bool )tmp___5, from, to);
#line 927
      att &= att - 1UL;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 916
    b &= b - 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 932
  return (moves);
}
}
#line 938 "tbprobe.c"
static uint16_t *gen_pawn_ep_captures(struct pos  const  *pos , uint16_t *moves ) 
{ 
  uint64_t ep ;
  unsigned int to ;
  uint64_t us ;
  uint64_t tmp ;
  uint64_t b ;
  unsigned int from ;
  unsigned int tmp___0 ;

  {
#line 939
  if ((int )pos->ep == 0) {
#line 940
    return (moves);
  }
#line 941
  ep = 1UL << (int )pos->ep;
#line 942
  to = (unsigned int )pos->ep;
#line 943
  if (pos->turn) {
#line 943
    tmp = pos->white;
  } else {
#line 943
    tmp = pos->black;
  }
#line 943
  us = (uint64_t )tmp;
#line 945
  b = us & (unsigned long )pos->pawns;
  {
#line 945
  while (1) {
    while_continue: /* CIL Label */ ;
#line 945
    if (! b) {
#line 945
      goto while_break;
    }
#line 946
    tmp___0 = _lsb(b);
#line 946
    from = tmp___0;
#line 947
    if ((pawn_attacks[pos->turn][from] & ep) != 0UL) {
#line 948
      moves = add_move(moves, (_Bool)0, from, to);
    }
#line 945
    b &= b - 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 950
  return (moves);
}
}
#line 956 "tbprobe.c"
static uint16_t *gen_moves(struct pos  const  *pos , uint16_t *moves ) 
{ 
  uint64_t occ ;
  uint64_t us ;
  uint64_t tmp ;
  uint64_t them ;
  uint64_t tmp___0 ;
  uint64_t b ;
  uint64_t att ;
  unsigned int from ;
  unsigned int tmp___1 ;
  unsigned int to ;
  unsigned int tmp___2 ;
  unsigned int from___0 ;
  unsigned int tmp___3 ;
  unsigned int to___0 ;
  unsigned int tmp___4 ;
  unsigned int from___1 ;
  unsigned int tmp___5 ;
  unsigned int to___1 ;
  unsigned int tmp___6 ;
  unsigned int from___2 ;
  unsigned int tmp___7 ;
  unsigned int to___2 ;
  unsigned int tmp___8 ;
  unsigned int from___3 ;
  unsigned int tmp___9 ;
  unsigned int to___3 ;
  unsigned int tmp___10 ;
  unsigned int from___4 ;
  unsigned int tmp___11 ;
  unsigned int next___0 ;
  int tmp___12 ;
  unsigned int to___4 ;
  unsigned int next2 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int to___5 ;
  unsigned int tmp___15 ;
  int tmp___16 ;

  {
#line 957
  occ = (uint64_t )(pos->white | pos->black);
#line 958
  if (pos->turn) {
#line 958
    tmp = pos->white;
  } else {
#line 958
    tmp = pos->black;
  }
#line 958
  us = (uint64_t )tmp;
#line 958
  if (pos->turn) {
#line 958
    tmp___0 = pos->black;
  } else {
#line 958
    tmp___0 = pos->white;
  }
#line 958
  them = (uint64_t )tmp___0;
#line 963
  tmp___1 = _lsb((uint64_t )(pos->kings & (unsigned long )us));
#line 963
  from = tmp___1;
#line 964
  att = king_attacks[from] & ~ us;
  {
#line 964
  while (1) {
    while_continue: /* CIL Label */ ;
#line 964
    if (! att) {
#line 964
      goto while_break;
    }
#line 965
    tmp___2 = _lsb(att);
#line 965
    to = tmp___2;
#line 966
    moves = add_move(moves, (_Bool)0, from, to);
#line 964
    att &= att - 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 969
  b = us & (unsigned long )pos->queens;
  {
#line 969
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 969
    if (! b) {
#line 969
      goto while_break___0;
    }
#line 970
    tmp___3 = _lsb(b);
#line 970
    from___0 = tmp___3;
#line 971
    att = (*(magic_bishop_indices[from___0] + ((occ & (unsigned long )magic_bishop_mask[from___0]) * (unsigned long )magic_bishop[from___0] >> magic_bishop_shift[from___0])) | *(magic_rook_indices[from___0] + ((occ & (unsigned long )magic_rook_mask[from___0]) * (unsigned long )magic_rook[from___0] >> magic_rook_shift[from___0]))) & ~ us;
    {
#line 971
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 971
      if (! att) {
#line 971
        goto while_break___1;
      }
#line 972
      tmp___4 = _lsb(att);
#line 972
      to___0 = tmp___4;
#line 973
      moves = add_move(moves, (_Bool)0, from___0, to___0);
#line 971
      att &= att - 1UL;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 969
    b &= b - 1UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 976
  b = us & (unsigned long )pos->rooks;
  {
#line 976
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 976
    if (! b) {
#line 976
      goto while_break___2;
    }
#line 977
    tmp___5 = _lsb(b);
#line 977
    from___1 = tmp___5;
#line 978
    att = *(magic_rook_indices[from___1] + ((occ & (unsigned long )magic_rook_mask[from___1]) * (unsigned long )magic_rook[from___1] >> magic_rook_shift[from___1])) & ~ us;
    {
#line 978
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 978
      if (! att) {
#line 978
        goto while_break___3;
      }
#line 979
      tmp___6 = _lsb(att);
#line 979
      to___1 = tmp___6;
#line 980
      moves = add_move(moves, (_Bool)0, from___1, to___1);
#line 978
      att &= att - 1UL;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 976
    b &= b - 1UL;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 983
  b = us & (unsigned long )pos->bishops;
  {
#line 983
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 983
    if (! b) {
#line 983
      goto while_break___4;
    }
#line 984
    tmp___7 = _lsb(b);
#line 984
    from___2 = tmp___7;
#line 985
    att = *(magic_bishop_indices[from___2] + ((occ & (unsigned long )magic_bishop_mask[from___2]) * (unsigned long )magic_bishop[from___2] >> magic_bishop_shift[from___2])) & ~ us;
    {
#line 985
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 985
      if (! att) {
#line 985
        goto while_break___5;
      }
#line 986
      tmp___8 = _lsb(att);
#line 986
      to___2 = tmp___8;
#line 987
      moves = add_move(moves, (_Bool)0, from___2, to___2);
#line 985
      att &= att - 1UL;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 983
    b &= b - 1UL;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 990
  b = us & (unsigned long )pos->knights;
  {
#line 990
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 990
    if (! b) {
#line 990
      goto while_break___6;
    }
#line 991
    tmp___9 = _lsb(b);
#line 991
    from___3 = tmp___9;
#line 992
    att = knight_attacks[from___3] & ~ us;
    {
#line 992
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 992
      if (! att) {
#line 992
        goto while_break___7;
      }
#line 993
      tmp___10 = _lsb(att);
#line 993
      to___3 = tmp___10;
#line 994
      moves = add_move(moves, (_Bool)0, from___3, to___3);
#line 992
      att &= att - 1UL;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 990
    b &= b - 1UL;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 997
  b = us & (unsigned long )pos->pawns;
  {
#line 997
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 997
    if (! b) {
#line 997
      goto while_break___8;
    }
#line 998
    tmp___11 = _lsb(b);
#line 998
    from___4 = tmp___11;
#line 999
    if (pos->turn) {
#line 999
      tmp___12 = 8;
    } else {
#line 999
      tmp___12 = -8;
    }
#line 999
    next___0 = from___4 + (unsigned int )tmp___12;
#line 1000
    att = pawn_attacks[pos->turn][from___4];
#line 1001
    if ((int )pos->ep != 0) {
#line 1001
      if ((att & (1UL << (int )pos->ep)) != 0UL) {
#line 1002
        to___4 = (unsigned int )pos->ep;
#line 1003
        moves = add_move(moves, (_Bool)0, from___4, to___4);
      } else {
#line 1001
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 1005
    att &= them;
#line 1006
    if (((1UL << next___0) & occ) == 0UL) {
#line 1007
      att |= 1UL << next___0;
#line 1008
      if (pos->turn) {
#line 1008
        tmp___13 = 16;
      } else {
#line 1008
        tmp___13 = -16;
      }
#line 1008
      next2 = from___4 + (unsigned int )tmp___13;
#line 1009
      if (pos->turn) {
#line 1009
        tmp___14 = from___4 >> 3 == 1U;
      } else {
#line 1009
        tmp___14 = from___4 >> 3 == 6U;
      }
#line 1009
      if (tmp___14) {
#line 1009
        if (((1UL << next2) & occ) == 0UL) {
#line 1011
          att |= 1UL << next2;
        } else {
#line 1009
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
    }
    {
#line 1013
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1013
      if (! att) {
#line 1013
        goto while_break___9;
      }
#line 1014
      tmp___15 = _lsb(att);
#line 1014
      to___5 = tmp___15;
#line 1015
      if (to___5 >> 3 == 7U) {
#line 1015
        goto _L___1;
      } else
#line 1015
      if (to___5 >> 3 == 0U) {
        _L___1: /* CIL Label */ 
#line 1015
        tmp___16 = 1;
      } else {
#line 1015
        tmp___16 = 0;
      }
#line 1015
      moves = add_move(moves, (_Bool )tmp___16, from___4, to___5);
#line 1013
      att &= att - 1UL;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 997
    b &= b - 1UL;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1018
  return (moves);
}
}
#line 1024 "tbprobe.c"
static _Bool is_en_passant(struct pos  const  *pos , uint16_t move ) 
{ 
  uint16_t from ;
  uint16_t to ;
  uint64_t us ;
  uint64_t tmp ;

  {
#line 1025
  from = (uint16_t )(((int )move >> 6) & 0x3F);
#line 1026
  to = (uint16_t )((int )move & 0x3F);
#line 1027
  if (pos->turn) {
#line 1027
    tmp = pos->white;
  } else {
#line 1027
    tmp = pos->black;
  }
#line 1027
  us = (uint64_t )tmp;
#line 1028
  if ((int )pos->ep == 0) {
#line 1029
    return ((_Bool)0);
  }
#line 1030
  if ((int )to != (int )pos->ep) {
#line 1031
    return ((_Bool)0);
  }
#line 1032
  if ((((1UL << (int )from) & us) & (unsigned long )pos->pawns) != 0UL) {
#line 1033
    return ((_Bool)0);
  }
#line 1034
  return ((_Bool)1);
}
}
#line 1040 "tbprobe.c"
static _Bool is_legal(struct pos  const  *pos ) 
{ 
  uint64_t occ ;
  uint64_t us ;
  uint64_t tmp ;
  uint64_t them ;
  uint64_t tmp___0 ;
  uint64_t king___0 ;
  unsigned int sq ;
  unsigned int tmp___1 ;
  uint64_t ratt ;
  uint64_t batt ;

  {
#line 1041
  occ = (uint64_t )(pos->white | pos->black);
#line 1042
  if (pos->turn) {
#line 1042
    tmp = pos->black;
  } else {
#line 1042
    tmp = pos->white;
  }
#line 1042
  us = (uint64_t )tmp;
#line 1042
  if (pos->turn) {
#line 1042
    tmp___0 = pos->white;
  } else {
#line 1042
    tmp___0 = pos->black;
  }
#line 1042
  them = (uint64_t )tmp___0;
#line 1044
  king___0 = (uint64_t )(pos->kings & (unsigned long )us);
#line 1045
  tmp___1 = _lsb(king___0);
#line 1045
  sq = tmp___1;
#line 1046
  if (king_attacks[sq] & (unsigned long )(pos->kings & (unsigned long )them)) {
#line 1047
    return ((_Bool)0);
  }
#line 1048
  ratt = *(magic_rook_indices[sq] + ((occ & (unsigned long )magic_rook_mask[sq]) * (unsigned long )magic_rook[sq] >> magic_rook_shift[sq]));
#line 1049
  batt = *(magic_bishop_indices[sq] + ((occ & (unsigned long )magic_bishop_mask[sq]) * (unsigned long )magic_bishop[sq] >> magic_bishop_shift[sq]));
#line 1050
  if (ratt & (unsigned long )(pos->rooks & (unsigned long )them)) {
#line 1051
    return ((_Bool)0);
  }
#line 1052
  if (batt & (unsigned long )(pos->bishops & (unsigned long )them)) {
#line 1053
    return ((_Bool)0);
  }
#line 1054
  if ((ratt | batt) & (unsigned long )(pos->queens & (unsigned long )them)) {
#line 1055
    return ((_Bool)0);
  }
#line 1056
  if (knight_attacks[sq] & (unsigned long )(pos->knights & (unsigned long )them)) {
#line 1057
    return ((_Bool)0);
  }
#line 1058
  if (pawn_attacks[! pos->turn][sq] & (unsigned long )(pos->pawns & (unsigned long )them)) {
#line 1059
    return ((_Bool)0);
  }
#line 1060
  return ((_Bool)1);
}
}
#line 1066 "tbprobe.c"
static _Bool is_check(struct pos  const  *pos ) 
{ 
  uint64_t occ ;
  uint64_t us ;
  uint64_t tmp ;
  uint64_t them ;
  uint64_t tmp___0 ;
  uint64_t king___0 ;
  unsigned int sq ;
  unsigned int tmp___1 ;
  uint64_t ratt ;
  uint64_t batt ;

  {
#line 1067
  occ = (uint64_t )(pos->white | pos->black);
#line 1068
  if (pos->turn) {
#line 1068
    tmp = pos->white;
  } else {
#line 1068
    tmp = pos->black;
  }
#line 1068
  us = (uint64_t )tmp;
#line 1068
  if (pos->turn) {
#line 1068
    tmp___0 = pos->black;
  } else {
#line 1068
    tmp___0 = pos->white;
  }
#line 1068
  them = (uint64_t )tmp___0;
#line 1070
  king___0 = (uint64_t )(pos->kings & (unsigned long )us);
#line 1071
  tmp___1 = _lsb(king___0);
#line 1071
  sq = tmp___1;
#line 1072
  ratt = *(magic_rook_indices[sq] + ((occ & (unsigned long )magic_rook_mask[sq]) * (unsigned long )magic_rook[sq] >> magic_rook_shift[sq]));
#line 1073
  batt = *(magic_bishop_indices[sq] + ((occ & (unsigned long )magic_bishop_mask[sq]) * (unsigned long )magic_bishop[sq] >> magic_bishop_shift[sq]));
#line 1074
  if (ratt & (unsigned long )(pos->rooks & (unsigned long )them)) {
#line 1075
    return ((_Bool)1);
  }
#line 1076
  if (batt & (unsigned long )(pos->bishops & (unsigned long )them)) {
#line 1077
    return ((_Bool)1);
  }
#line 1078
  if ((ratt | batt) & (unsigned long )(pos->queens & (unsigned long )them)) {
#line 1079
    return ((_Bool)1);
  }
#line 1080
  if (knight_attacks[sq] & (unsigned long )(pos->knights & (unsigned long )them)) {
#line 1081
    return ((_Bool)1);
  }
#line 1082
  if (pawn_attacks[pos->turn][sq] & (unsigned long )(pos->pawns & (unsigned long )them)) {
#line 1083
    return ((_Bool)1);
  }
#line 1084
  return ((_Bool)0);
}
}
#line 1090 "tbprobe.c"
static _Bool is_mate(struct pos  const  *pos ) 
{ 
  _Bool tmp ;
  uint16_t moves0[193] ;
  uint16_t *moves ;
  uint16_t *end ;
  uint16_t *tmp___0 ;
  struct pos pos1 ;
  _Bool tmp___1 ;

  {
#line 1091
  tmp = is_check(pos);
#line 1091
  if (! tmp) {
#line 1092
    return ((_Bool)0);
  }
#line 1094
  moves = moves0;
#line 1095
  tmp___0 = gen_moves(pos, moves);
#line 1095
  end = tmp___0;
  {
#line 1096
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1096
    if (! ((unsigned long )moves < (unsigned long )end)) {
#line 1096
      goto while_break;
    }
#line 1098
    tmp___1 = do_move(& pos1, pos, *moves);
#line 1098
    if (tmp___1) {
#line 1099
      return ((_Bool)0);
    }
#line 1096
    moves ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1101
  return ((_Bool)1);
}
}
#line 1107 "tbprobe.c"
static _Bool is_valid(struct pos  const  *pos ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
#line 1108
  tmp = __builtin_popcountll((unsigned long long )pos->kings);
#line 1108
  if (tmp != 2) {
#line 1109
    return ((_Bool)0);
  }
#line 1110
  tmp___0 = __builtin_popcountll((unsigned long long )(pos->kings & pos->white));
#line 1110
  if (tmp___0 != 1) {
#line 1111
    return ((_Bool)0);
  }
#line 1112
  tmp___1 = __builtin_popcountll((unsigned long long )(pos->kings & pos->black));
#line 1112
  if (tmp___1 != 1) {
#line 1113
    return ((_Bool)0);
  }
#line 1114
  if ((pos->white & pos->black) != 0UL) {
#line 1115
    return ((_Bool)0);
  }
#line 1116
  if ((pos->kings & pos->queens) != 0UL) {
#line 1117
    return ((_Bool)0);
  }
#line 1118
  if ((pos->kings & pos->rooks) != 0UL) {
#line 1119
    return ((_Bool)0);
  }
#line 1120
  if ((pos->kings & pos->bishops) != 0UL) {
#line 1121
    return ((_Bool)0);
  }
#line 1122
  if ((pos->kings & pos->knights) != 0UL) {
#line 1123
    return ((_Bool)0);
  }
#line 1124
  if ((pos->kings & pos->pawns) != 0UL) {
#line 1125
    return ((_Bool)0);
  }
#line 1126
  if ((pos->queens & pos->rooks) != 0UL) {
#line 1127
    return ((_Bool)0);
  }
#line 1128
  if ((pos->queens & pos->bishops) != 0UL) {
#line 1129
    return ((_Bool)0);
  }
#line 1130
  if ((pos->queens & pos->knights) != 0UL) {
#line 1131
    return ((_Bool)0);
  }
#line 1132
  if ((pos->queens & pos->pawns) != 0UL) {
#line 1133
    return ((_Bool)0);
  }
#line 1134
  if ((pos->rooks & pos->bishops) != 0UL) {
#line 1135
    return ((_Bool)0);
  }
#line 1136
  if ((pos->rooks & pos->knights) != 0UL) {
#line 1137
    return ((_Bool)0);
  }
#line 1138
  if ((pos->rooks & pos->pawns) != 0UL) {
#line 1139
    return ((_Bool)0);
  }
#line 1140
  if ((pos->bishops & pos->knights) != 0UL) {
#line 1141
    return ((_Bool)0);
  }
#line 1142
  if ((pos->bishops & pos->pawns) != 0UL) {
#line 1143
    return ((_Bool)0);
  }
#line 1144
  if ((pos->knights & pos->pawns) != 0UL) {
#line 1145
    return ((_Bool)0);
  }
#line 1146
  if ((pos->white | pos->black) != (((((pos->kings | pos->queens) | pos->rooks) | pos->bishops) | pos->knights) | pos->pawns)) {
#line 1149
    return ((_Bool)0);
  }
#line 1150
  tmp___2 = is_legal(pos);
#line 1150
  return (tmp___2);
}
}
#line 1157 "tbprobe.c"
static _Bool do_move(struct pos *pos , struct pos  const  *pos0 , uint16_t move ) 
{ 
  unsigned int from ;
  unsigned int to ;
  unsigned int promotes ;
  unsigned int ep_to ;
  unsigned int tmp ;
  uint64_t ep_mask ;
  _Bool tmp___0 ;

  {
#line 1158
  from = (unsigned int )(((int )move >> 6) & 0x3F);
#line 1159
  to = (unsigned int )((int )move & 0x3F);
#line 1160
  promotes = (unsigned int )(((int )move >> 12) & 0x7);
#line 1161
  pos->turn = (_Bool )(! pos0->turn);
#line 1162
  pos->white = (uint64_t )(((pos0->white & (unsigned long )(~ (1UL << to))) & (unsigned long )(~ (1UL << from))) | (((pos0->white >> from) & 1UL) << to));
#line 1163
  pos->black = (uint64_t )(((pos0->black & (unsigned long )(~ (1UL << to))) & (unsigned long )(~ (1UL << from))) | (((pos0->black >> from) & 1UL) << to));
#line 1164
  pos->kings = (uint64_t )(((pos0->kings & (unsigned long )(~ (1UL << to))) & (unsigned long )(~ (1UL << from))) | (((pos0->kings >> from) & 1UL) << to));
#line 1165
  pos->queens = (uint64_t )(((pos0->queens & (unsigned long )(~ (1UL << to))) & (unsigned long )(~ (1UL << from))) | (((pos0->queens >> from) & 1UL) << to));
#line 1166
  pos->rooks = (uint64_t )(((pos0->rooks & (unsigned long )(~ (1UL << to))) & (unsigned long )(~ (1UL << from))) | (((pos0->rooks >> from) & 1UL) << to));
#line 1167
  pos->bishops = (uint64_t )(((pos0->bishops & (unsigned long )(~ (1UL << to))) & (unsigned long )(~ (1UL << from))) | (((pos0->bishops >> from) & 1UL) << to));
#line 1168
  pos->knights = (uint64_t )(((pos0->knights & (unsigned long )(~ (1UL << to))) & (unsigned long )(~ (1UL << from))) | (((pos0->knights >> from) & 1UL) << to));
#line 1169
  pos->pawns = (uint64_t )(((pos0->pawns & (unsigned long )(~ (1UL << to))) & (unsigned long )(~ (1UL << from))) | (((pos0->pawns >> from) & 1UL) << to));
#line 1170
  pos->ep = (uint8_t )0;
#line 1171
  if (promotes != 0U) {
#line 1172
    pos->pawns &= ~ (1UL << to);
    {
#line 1174
    if (promotes == 1U) {
#line 1174
      goto case_1;
    }
#line 1177
    if (promotes == 2U) {
#line 1177
      goto case_2;
    }
#line 1180
    if (promotes == 3U) {
#line 1180
      goto case_3;
    }
#line 1183
    if (promotes == 4U) {
#line 1183
      goto case_4;
    }
#line 1173
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1175
    pos->queens |= 1UL << to;
#line 1176
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1178
    pos->rooks |= 1UL << to;
#line 1179
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1181
    pos->bishops |= 1UL << to;
#line 1182
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1184
    pos->knights |= 1UL << to;
#line 1185
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1187
    pos->rule50 = (uint8_t )0;
  } else
#line 1188
  if (((1UL << from) & (unsigned long )pos0->pawns) != 0UL) {
#line 1189
    pos->rule50 = (uint8_t )0;
#line 1190
    if (from >> 3 == 1U) {
#line 1190
      if (to >> 3 == 3U) {
#line 1190
        if (((pawn_attacks[1][from + 8U] & (unsigned long )pos0->pawns) & (unsigned long )pos0->black) != 0UL) {
#line 1192
          pos->ep = (uint8_t )(from + 8U);
        } else {
#line 1190
          goto _L___2;
        }
      } else {
#line 1190
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
#line 1193
    if (from >> 3 == 6U) {
#line 1193
      if (to >> 3 == 4U) {
#line 1193
        if (((pawn_attacks[0][from - 8U] & (unsigned long )pos0->pawns) & (unsigned long )pos0->white) != 0UL) {
#line 1195
          pos->ep = (uint8_t )(from - 8U);
        } else {
#line 1193
          goto _L___0;
        }
      } else {
#line 1193
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
#line 1196
    if (to == (unsigned int )pos0->ep) {
#line 1197
      if (pos0->turn) {
#line 1197
        tmp = to + 8U;
      } else {
#line 1197
        tmp = to - 8U;
      }
#line 1197
      ep_to = tmp;
#line 1198
      ep_mask = ~ (1UL << ep_to);
#line 1199
      pos->white &= ep_mask;
#line 1200
      pos->black &= ep_mask;
#line 1201
      pos->pawns &= ep_mask;
    }
  } else
#line 1203
  if (((1UL << to) & (unsigned long )(pos0->white | pos0->black)) != 0UL) {
#line 1204
    pos->rule50 = (uint8_t )0;
  } else {
#line 1206
    pos->rule50 = (uint8_t )((int )pos0->rule50 + 1);
  }
#line 1207
  tmp___0 = is_legal((struct pos  const  *)pos);
#line 1207
  if (! tmp___0) {
#line 1208
    return ((_Bool)0);
  }
#line 1209
  return ((_Bool)1);
}
}
#line 1212 "tbprobe.c"
static int probe_ab(struct pos  const  *pos , int alpha , int beta , int *success ) 
{ 
  int v ;
  uint16_t moves0[64] ;
  uint16_t *moves ;
  uint16_t *end ;
  uint16_t *tmp ;
  _Bool tmp___0 ;
  struct pos pos1 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
#line 1215
  moves = moves0;
#line 1216
  tmp = gen_captures_or_promotions(pos, moves);
#line 1216
  end = tmp;
  {
#line 1217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1217
    if (! ((unsigned long )moves < (unsigned long )end)) {
#line 1217
      goto while_break;
    }
#line 1218
    tmp___0 = is_en_passant(pos, *moves);
#line 1218
    if (tmp___0) {
#line 1219
      goto __Cont;
    }
#line 1221
    tmp___1 = do_move(& pos1, pos, *moves);
#line 1221
    if (! tmp___1) {
#line 1222
      goto __Cont;
    }
#line 1223
    tmp___2 = probe_ab((struct pos  const  *)(& pos1), - beta, - alpha, success);
#line 1223
    v = - tmp___2;
#line 1224
    if (*success == 0) {
#line 1225
      return (0);
    }
#line 1226
    if (v > alpha) {
#line 1227
      if (v >= beta) {
#line 1228
        *success = 2;
#line 1229
        return (v);
      }
#line 1231
      alpha = v;
    }
    __Cont: /* CIL Label */ 
#line 1217
    moves ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  v = probe_wdl_table(pos, success);
#line 1236
  if (*success == 0) {
#line 1237
    return (0);
  }
#line 1238
  if (alpha >= v) {
#line 1239
    *success = 1 + (alpha > 0);
#line 1240
    return (alpha);
  } else {
#line 1242
    *success = 1;
#line 1243
    return (v);
  }
}
}
#line 1247 "tbprobe.c"
static int probe_wdl(struct pos  const  *pos , int *success ) 
{ 
  int v ;
  int tmp ;
  int v1 ;
  uint16_t moves0[2] ;
  uint16_t *moves ;
  uint16_t *end ;
  uint16_t *tmp___0 ;
  struct pos pos1 ;
  _Bool tmp___1 ;
  int v0 ;
  int tmp___2 ;
  uint16_t moves0___0[193] ;
  uint16_t *moves___0 ;
  uint16_t *end___0 ;
  uint16_t *tmp___3 ;
  _Bool found ;
  _Bool tmp___4 ;
  struct pos pos1___0 ;
  _Bool tmp___5 ;

  {
#line 1248
  *success = 1;
#line 1249
  tmp = probe_ab(pos, -2, 2, success);
#line 1249
  v = tmp;
#line 1250
  if (*success == 0) {
#line 1251
    return (0);
  }
#line 1254
  if ((int )pos->ep == 0) {
#line 1255
    return (v);
  }
#line 1258
  v1 = -3;
#line 1260
  moves = moves0;
#line 1261
  tmp___0 = gen_pawn_ep_captures(pos, moves);
#line 1261
  end = tmp___0;
  {
#line 1262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1262
    if (! ((unsigned long )moves < (unsigned long )end)) {
#line 1262
      goto while_break;
    }
#line 1264
    tmp___1 = do_move(& pos1, pos, *moves);
#line 1264
    if (! tmp___1) {
#line 1265
      goto __Cont;
    }
#line 1266
    tmp___2 = probe_ab(pos, -2, 2, success);
#line 1266
    v0 = - tmp___2;
#line 1267
    if (*success == 0) {
#line 1268
      return (0);
    }
#line 1269
    if (v0 > v1) {
#line 1270
      v1 = v0;
    }
    __Cont: /* CIL Label */ 
#line 1262
    moves ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1272
  if (v1 > -3) {
#line 1273
    if (v1 >= v) {
#line 1274
      v = v1;
    } else
#line 1275
    if (v == 0) {
#line 1278
      moves___0 = moves0___0;
#line 1279
      tmp___3 = gen_moves(pos, moves___0);
#line 1279
      end___0 = tmp___3;
#line 1280
      found = (_Bool)0;
      {
#line 1281
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1281
        if (! ((unsigned long )moves___0 < (unsigned long )end___0)) {
#line 1281
          goto while_break___0;
        }
#line 1282
        tmp___4 = is_en_passant(pos, *moves___0);
#line 1282
        if (tmp___4) {
#line 1283
          goto __Cont___0;
        }
#line 1285
        tmp___5 = do_move(& pos1___0, pos, *moves___0);
#line 1285
        if (tmp___5) {
#line 1286
          found = (_Bool)1;
#line 1287
          goto while_break___0;
        }
        __Cont___0: /* CIL Label */ 
#line 1281
        moves___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1290
      if (! found) {
#line 1291
        v = v1;
      }
    }
  }
#line 1295
  return (v);
}
}
#line 1298 "tbprobe.c"
static int probe_dtz_no_ep(struct pos  const  *pos , int *success ) 
{ 
  int wdl ;
  int dtz ;
  int tmp ;
  uint16_t moves0[193] ;
  uint16_t *moves ;
  uint16_t *end ;
  struct pos pos1 ;
  _Bool tmp___0 ;
  int v ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int best ;
  struct pos pos1___0 ;
  _Bool tmp___7 ;
  int v___0 ;
  int tmp___8 ;
  int best___0 ;
  int v___1 ;
  struct pos pos1___1 ;
  _Bool tmp___9 ;
  int tmp___10 ;

  {
#line 1300
  wdl = probe_ab(pos, -2, 2, success);
#line 1301
  if (wdl == 0) {
#line 1302
    return (0);
  }
#line 1303
  if (*success == 2) {
#line 1304
    if (wdl == 2) {
#line 1304
      tmp = 1;
    } else {
#line 1304
      tmp = 101;
    }
#line 1304
    return (tmp);
  }
#line 1307
  moves = moves0;
#line 1307
  end = (uint16_t *)((void *)0);
#line 1309
  if (wdl > 0) {
#line 1312
    end = gen_pawn_quiets_or_promotions(pos, moves);
    {
#line 1313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1313
      if (! ((unsigned long )moves < (unsigned long )end)) {
#line 1313
        goto while_break;
      }
#line 1315
      tmp___0 = do_move(& pos1, pos, *moves);
#line 1315
      if (! tmp___0) {
#line 1316
        goto __Cont;
      }
#line 1320
      if ((int )pos1.ep == 0) {
#line 1320
        tmp___1 = probe_ab((struct pos  const  *)(& pos1), -2, - wdl + 1, success);
#line 1320
        tmp___3 = - tmp___1;
      } else {
#line 1320
        tmp___2 = probe_wdl((struct pos  const  *)(& pos1), success);
#line 1320
        tmp___3 = - tmp___2;
      }
#line 1320
      v = tmp___3;
#line 1321
      if (*success == 0) {
#line 1322
        return (0);
      }
#line 1323
      if (v == wdl) {
#line 1324
        if (v == 2) {
#line 1324
          tmp___4 = 1;
        } else {
#line 1324
          tmp___4 = 101;
        }
#line 1324
        return (tmp___4);
      }
      __Cont: /* CIL Label */ 
#line 1313
      moves ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1328
  tmp___5 = probe_dtz_table(pos, wdl, success);
#line 1328
  dtz = 1 + tmp___5;
#line 1329
  if (*success >= 0) {
#line 1330
    if (wdl & 1) {
#line 1331
      dtz += 100;
    }
#line 1332
    if (wdl >= 0) {
#line 1332
      tmp___6 = dtz;
    } else {
#line 1332
      tmp___6 = - dtz;
    }
#line 1332
    return (tmp___6);
  }
#line 1335
  if (wdl > 0) {
#line 1336
    best = 0xFFFF;
#line 1337
    moves = moves0;
#line 1338
    end = gen_moves(pos, moves);
    {
#line 1339
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1339
      if (! ((unsigned long )moves < (unsigned long )end)) {
#line 1339
        goto while_break___0;
      }
#line 1341
      tmp___7 = do_move(& pos1___0, pos, *moves);
#line 1341
      if (! tmp___7) {
#line 1342
        goto __Cont___0;
      }
#line 1343
      if ((int )pos1___0.rule50 == 0) {
#line 1344
        goto __Cont___0;
      }
#line 1345
      tmp___8 = probe_dtz((struct pos  const  *)(& pos1___0), success);
#line 1345
      v___0 = - tmp___8;
#line 1346
      if (*success == 0) {
#line 1347
        return (0);
      }
#line 1348
      if (v___0 > 0) {
#line 1348
        if (v___0 + 1 < best) {
#line 1349
          best = v___0 + 1;
        } else {
#line 1348
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 1339
      moves ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1351
    __goblint_assert(best != 0xFFFF);
#line 1352
    return (best);
  } else {
#line 1354
    best___0 = -1;
#line 1355
    end = gen_moves(pos, moves);
    {
#line 1356
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1356
      if (! ((unsigned long )moves < (unsigned long )end)) {
#line 1356
        goto while_break___1;
      }
#line 1359
      tmp___9 = do_move(& pos1___1, pos, *moves);
#line 1359
      if (! tmp___9) {
#line 1360
        goto __Cont___1;
      }
#line 1361
      if ((int )pos1___1.rule50 == 0) {
#line 1362
        if (wdl == -2) {
#line 1363
          v___1 = -1;
        } else {
#line 1365
          v___1 = probe_ab((struct pos  const  *)(& pos1___1), 1, 2, success);
#line 1366
          if (v___1 == 2) {
#line 1366
            v___1 = 0;
          } else {
#line 1366
            v___1 = -101;
          }
        }
      } else {
#line 1369
        tmp___10 = probe_dtz((struct pos  const  *)(& pos1___1), success);
#line 1369
        v___1 = - tmp___10 - 1;
      }
#line 1370
      if (*success == 0) {
#line 1371
        return (0);
      }
#line 1372
      if (v___1 < best___0) {
#line 1373
        best___0 = v___1;
      }
      __Cont___1: /* CIL Label */ 
#line 1356
      moves ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1375
    return (best___0);
  }
}
}
#line 1379 "tbprobe.c"
static int const   wdl_to_dtz[5]  = {      (int const   )-1,      (int const   )-101,      (int const   )0,      (int const   )101, 
        (int const   )1};
#line 1410 "tbprobe.c"
static int probe_dtz(struct pos  const  *pos , int *success ) 
{ 
  int v ;
  int tmp ;
  int v1 ;
  uint16_t moves0[2] ;
  uint16_t *moves ;
  uint16_t *end ;
  uint16_t *tmp___0 ;
  struct pos pos1 ;
  _Bool tmp___1 ;
  int v0 ;
  int tmp___2 ;
  uint16_t moves0___0[193] ;
  uint16_t *moves___0 ;
  uint16_t *end___0 ;
  uint16_t *tmp___3 ;
  _Bool found ;
  _Bool tmp___4 ;
  struct pos pos1___0 ;
  _Bool tmp___5 ;

  {
#line 1411
  *success = 1;
#line 1412
  tmp = probe_dtz_no_ep(pos, success);
#line 1412
  v = tmp;
#line 1413
  if (*success == 0) {
#line 1414
    return (0);
  }
#line 1416
  if ((int )pos->ep == 0) {
#line 1417
    return (v);
  }
#line 1419
  v1 = -3;
#line 1421
  moves = moves0;
#line 1422
  tmp___0 = gen_pawn_ep_captures(pos, moves);
#line 1422
  end = tmp___0;
  {
#line 1423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1423
    if (! ((unsigned long )moves < (unsigned long )end)) {
#line 1423
      goto while_break;
    }
#line 1425
    tmp___1 = do_move(& pos1, pos, *moves);
#line 1425
    if (! tmp___1) {
#line 1426
      goto __Cont;
    }
#line 1427
    tmp___2 = probe_ab(pos, -2, 2, success);
#line 1427
    v0 = - tmp___2;
#line 1428
    if (*success == 0) {
#line 1429
      return (0);
    }
#line 1430
    if (v0 > v1) {
#line 1431
      v1 = v0;
    }
    __Cont: /* CIL Label */ 
#line 1423
    moves ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1434
  if (v1 > -3) {
#line 1435
    v1 = (int )wdl_to_dtz[v1 + 2];
#line 1436
    if (v < -100) {
#line 1437
      if (v1 >= 0) {
#line 1438
        v = v1;
      }
    } else
#line 1439
    if (v < 0) {
#line 1440
      if (v1 >= 0) {
#line 1440
        goto _L;
      } else
#line 1440
      if (v1 < -100) {
        _L: /* CIL Label */ 
#line 1441
        v = v1;
      }
    } else
#line 1442
    if (v > 100) {
#line 1443
      if (v1 > 0) {
#line 1444
        v = v1;
      }
    } else
#line 1445
    if (v > 0) {
#line 1446
      if (v1 == 1) {
#line 1447
        v = v1;
      }
    } else
#line 1448
    if (v1 >= 0) {
#line 1449
      v = v1;
    } else {
#line 1452
      moves___0 = moves0___0;
#line 1453
      tmp___3 = gen_moves(pos, moves___0);
#line 1453
      end___0 = tmp___3;
#line 1454
      found = (_Bool)0;
      {
#line 1455
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1455
        if (! ((unsigned long )moves___0 < (unsigned long )end___0)) {
#line 1455
          goto while_break___0;
        }
#line 1456
        tmp___4 = is_en_passant(pos, *moves___0);
#line 1456
        if (tmp___4) {
#line 1457
          goto __Cont___0;
        }
#line 1459
        tmp___5 = do_move(& pos1___0, pos, *moves___0);
#line 1459
        if (tmp___5) {
#line 1460
          found = (_Bool)1;
#line 1461
          goto while_break___0;
        }
        __Cont___0: /* CIL Label */ 
#line 1455
        moves___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1464
      if (! found) {
#line 1465
        v = v1;
      }
    }
  }
#line 1469
  return (v);
}
}
#line 1472 "tbprobe.c"
unsigned int dtz_to_wdl(int cnt50 , int dtz ) 
{ 
  int wdl ;

  {
#line 1473
  wdl = 0;
#line 1474
  if (dtz > 0) {
#line 1475
    if (dtz + cnt50 <= 100) {
#line 1475
      wdl = 2;
    } else {
#line 1475
      wdl = 1;
    }
  } else
#line 1476
  if (dtz < 0) {
#line 1477
    if (- dtz + cnt50 <= 100) {
#line 1477
      wdl = -2;
    } else {
#line 1477
      wdl = -1;
    }
  }
#line 1478
  return ((unsigned int )(wdl + 2));
}
}
#line 1481 "tbprobe.c"
static uint16_t probe_root(struct pos  const  *pos , int *score , unsigned int *results ) 
{ 
  int success ;
  int dtz ;
  int tmp ;
  int16_t scores[193] ;
  uint16_t moves0[193] ;
  uint16_t *moves ;
  uint16_t *end ;
  uint16_t *tmp___0 ;
  size_t len ;
  size_t num_draw ;
  unsigned int j___0 ;
  unsigned int i ;
  struct pos pos1 ;
  _Bool tmp___1 ;
  int v ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  unsigned int res ;
  unsigned int tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  int best ;
  uint16_t best_move ;
  int v___0 ;
  int tmp___10 ;
  int best___0 ;
  uint16_t best_move___0 ;
  int v___1 ;
  int tmp___11 ;
  size_t count ;
  uint64_t tmp___12 ;
  int v___2 ;

  {
#line 1484
  tmp = probe_dtz(pos, & success);
#line 1484
  dtz = tmp;
#line 1485
  if (! success) {
#line 1486
    return ((uint16_t )0);
  }
#line 1490
  moves = moves0;
#line 1491
  tmp___0 = gen_moves(pos, moves);
#line 1491
  end = tmp___0;
#line 1492
  len = (size_t )(end - moves);
#line 1493
  num_draw = (size_t )0;
#line 1494
  j___0 = 0U;
#line 1495
  i = 0U;
#line 1496
  i = 0U;
  {
#line 1496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1496
    if (! ((size_t )i < len)) {
#line 1496
      goto while_break;
    }
#line 1498
    tmp___1 = do_move(& pos1, pos, *(moves + i));
#line 1498
    if (! tmp___1) {
#line 1499
      scores[i] = (int16_t )0x7FFF;
#line 1500
      goto __Cont;
    }
#line 1502
    v = 0;
#line 1503
    if (dtz > 0) {
#line 1503
      tmp___4 = is_mate((struct pos  const  *)(& pos1));
#line 1503
      if (tmp___4) {
#line 1504
        v = 1;
      } else {
#line 1503
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1506
    if ((int )pos1.rule50 != 0) {
#line 1507
      tmp___2 = probe_dtz((struct pos  const  *)(& pos1), & success);
#line 1507
      v = - tmp___2;
#line 1508
      if (v > 0) {
#line 1509
        v ++;
      } else
#line 1510
      if (v < 0) {
#line 1511
        v --;
      }
    } else {
#line 1513
      tmp___3 = probe_wdl((struct pos  const  *)(& pos1), & success);
#line 1513
      v = - tmp___3;
#line 1514
      v = (int )wdl_to_dtz[v + 2];
    }
#line 1517
    num_draw += (size_t )(v == 0);
#line 1518
    if (! success) {
#line 1519
      return ((uint16_t )0);
    }
#line 1520
    scores[i] = (int16_t )v;
#line 1521
    if ((unsigned long )results != (unsigned long )((void *)0)) {
#line 1522
      res = 0U;
#line 1523
      tmp___5 = dtz_to_wdl((int )pos->rule50, v);
#line 1523
      res = (res & 4294967280U) | (tmp___5 & 15U);
#line 1524
      res = (res & 4294902783U) | (unsigned int )(((((int )*(moves + i) >> 6) & 0x3F) << 10) & 0x0000FC00);
#line 1525
      res = (res & 4294966287U) | (unsigned int )((((int )*(moves + i) & 0x3F) << 4) & 0x000003F0);
#line 1526
      res = (res & 4294508543U) | (unsigned int )(((((int )*(moves + i) >> 12) & 0x7) << 16) & 0x00070000);
#line 1527
      tmp___6 = is_en_passant(pos, *(moves + i));
#line 1527
      res = (res & 4294443007U) | (unsigned int )(((int )tmp___6 << 19) & 0x00080000);
#line 1528
      if (dtz < 0) {
#line 1528
        tmp___7 = - dtz;
      } else {
#line 1528
        tmp___7 = dtz;
      }
#line 1528
      res = (res & 1048575U) | ((unsigned int )(tmp___7 << 20) & 0xFFF00000);
#line 1529
      tmp___8 = j___0;
#line 1529
      j___0 ++;
#line 1529
      *(results + tmp___8) = res;
    }
    __Cont: /* CIL Label */ 
#line 1496
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1532
  if ((unsigned long )results != (unsigned long )((void *)0)) {
#line 1533
    tmp___9 = j___0;
#line 1533
    j___0 ++;
#line 1533
    *(results + tmp___9) = 0xFFFFFFFF;
  }
#line 1534
  if ((unsigned long )score != (unsigned long )((void *)0)) {
#line 1535
    *score = dtz;
  }
#line 1538
  if (dtz > 0) {
#line 1540
    best = 0xFFFF;
#line 1541
    best_move = (uint16_t )0;
#line 1542
    i = 0U;
    {
#line 1542
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1542
      if (! ((size_t )i < len)) {
#line 1542
        goto while_break___0;
      }
#line 1543
      v___0 = (int )scores[i];
#line 1544
      if (v___0 == 0x7FFF) {
#line 1545
        goto __Cont___0;
      }
#line 1546
      if (v___0 > 0) {
#line 1546
        if (v___0 < best) {
#line 1547
          best = v___0;
#line 1548
          best_move = *(moves + i);
        } else {
#line 1546
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 1542
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1551
    if (best == 0xFFFF) {
#line 1551
      tmp___10 = 0;
    } else {
#line 1551
      tmp___10 = (int )best_move;
    }
#line 1551
    return ((uint16_t )tmp___10);
  } else
#line 1552
  if (dtz < 0) {
#line 1554
    best___0 = 0;
#line 1555
    best_move___0 = (uint16_t )0;
#line 1556
    i = 0U;
    {
#line 1556
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1556
      if (! ((size_t )i < len)) {
#line 1556
        goto while_break___1;
      }
#line 1557
      v___1 = (int )scores[i];
#line 1558
      if (v___1 == 0x7FFF) {
#line 1559
        goto __Cont___1;
      }
#line 1560
      if (v___1 < best___0) {
#line 1561
        best___0 = v___1;
#line 1562
        best_move___0 = *(moves + i);
      }
      __Cont___1: /* CIL Label */ 
#line 1556
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1565
    if (best___0 == 0) {
#line 1565
      tmp___11 = 0xFFFE;
    } else {
#line 1565
      tmp___11 = (int )best_move___0;
    }
#line 1565
    return ((uint16_t )tmp___11);
  } else {
#line 1569
    if (num_draw == 0UL) {
#line 1570
      return ((uint16_t )0xFFFF);
    }
#line 1574
    tmp___12 = calc_key(pos, (_Bool )(! pos->turn));
#line 1574
    count = tmp___12 % num_draw;
#line 1575
    i = 0U;
    {
#line 1575
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1575
      if (! ((size_t )i < len)) {
#line 1575
        goto while_break___2;
      }
#line 1576
      v___2 = (int )scores[i];
#line 1577
      if (v___2 == 0x7FFF) {
#line 1578
        goto __Cont___2;
      }
#line 1579
      if (v___2 == 0) {
#line 1580
        if (count == 0UL) {
#line 1581
          return (*(moves + i));
        }
#line 1582
        count --;
      }
      __Cont___2: /* CIL Label */ 
#line 1575
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1585
    return ((uint16_t )0);
  }
}
}
#line 1589 "tbprobe.c"
extern _Bool tb_init_impl(char const   *path ) 
{ 


  {
#line 1590
  if (sizeof(uint64_t ) != 8UL) {
#line 1590
    if (sizeof(uint32_t ) != 4UL) {
#line 1590
      if (sizeof(uint16_t ) != 2UL) {
#line 1590
        if (sizeof(uint8_t ) != 1UL) {
#line 1592
          return ((_Bool)0);
        } else {
#line 1590
          goto _L___1;
        }
      } else {
#line 1590
        goto _L___1;
      }
    } else {
#line 1590
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ ;
  }
#line 1598
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 1599
    path = (char const   *)"";
  }
#line 1600
  init_tablebases(path);
#line 1601
  return ((_Bool)1);
}
}
#line 1620 "tbprobe.c"
static uint64_t cache[4096]  = {      (uint64_t )0};
#line 1604 "tbprobe.c"
extern unsigned int tb_probe_wdl_impl(uint64_t white___0 , uint64_t black___0 , uint64_t kings ,
                                      uint64_t queens , uint64_t rooks , uint64_t bishops ,
                                      uint64_t knights , uint64_t pawns , unsigned int ep ,
                                      _Bool turn , uint64_t hash ) 
{ 
  struct pos pos ;
  uint64_t idx ;
  int success ;
  int v ;
  int tmp ;
  unsigned int result ;

  {
#line 1607
  pos.white = white___0;
#line 1607
  pos.black = black___0;
#line 1607
  pos.kings = kings;
#line 1607
  pos.queens = queens;
#line 1607
  pos.rooks = rooks;
#line 1607
  pos.bishops = bishops;
#line 1607
  pos.knights = knights;
#line 1607
  pos.pawns = pawns;
#line 1607
  pos.rule50 = (uint8_t )0;
#line 1607
  pos.ep = (uint8_t )ep;
#line 1607
  pos.turn = turn;
#line 1621
  idx = hash % 1024UL;
#line 1622
  if ((cache[idx] & 18446744073709551608UL) == (hash & 18446744073709551608UL)) {
#line 1628
    return ((unsigned int )(cache[idx] & 7UL));
  }
#line 1632
  tmp = probe_wdl((struct pos  const  *)(& pos), & success);
#line 1632
  v = tmp;
#line 1633
  if (success == 0) {
#line 1634
    return (0xFFFFFFFF);
  }
#line 1635
  result = (unsigned int )(v + 2);
#line 1636
  hash &= 18446744073709551608UL;
#line 1637
  hash |= (uint64_t )result;
#line 1638
  cache[idx] = hash;
#line 1639
  return (result);
}
}
#line 1642 "tbprobe.c"
extern unsigned int tb_probe_root_impl(uint64_t white___0 , uint64_t black___0 , uint64_t kings ,
                                       uint64_t queens , uint64_t rooks , uint64_t bishops ,
                                       uint64_t knights , uint64_t pawns , unsigned int rule50 ,
                                       unsigned int ep , _Bool turn , unsigned int *results ) 
{ 
  struct pos pos ;
  int dtz ;
  _Bool tmp ;
  uint16_t move ;
  uint16_t tmp___0 ;
  unsigned int res ;
  unsigned int tmp___1 ;
  _Bool tmp___2 ;

  {
#line 1646
  pos.white = white___0;
#line 1646
  pos.black = black___0;
#line 1646
  pos.kings = kings;
#line 1646
  pos.queens = queens;
#line 1646
  pos.rooks = rooks;
#line 1646
  pos.bishops = bishops;
#line 1646
  pos.knights = knights;
#line 1646
  pos.pawns = pawns;
#line 1646
  pos.rule50 = (uint8_t )rule50;
#line 1646
  pos.ep = (uint8_t )ep;
#line 1646
  pos.turn = turn;
#line 1660
  tmp = is_valid((struct pos  const  *)(& pos));
#line 1660
  if (! tmp) {
#line 1661
    return (0xFFFFFFFF);
  }
#line 1662
  tmp___0 = probe_root((struct pos  const  *)(& pos), & dtz, results);
#line 1662
  move = tmp___0;
#line 1663
  if ((int )move == 0) {
#line 1664
    return (0xFFFFFFFF);
  }
#line 1665
  if ((int )move == 0xFFFE) {
#line 1666
    return ((unsigned int )((4 << 0) & 0x0000000F));
  }
#line 1667
  if ((int )move == 0xFFFF) {
#line 1668
    return ((unsigned int )((2 << 0) & 0x0000000F));
  }
#line 1669
  res = 0U;
#line 1670
  tmp___1 = dtz_to_wdl((int )rule50, dtz);
#line 1670
  res = (res & 4294967280U) | (tmp___1 & 15U);
#line 1671
  res = (res & 4294902783U) | (unsigned int )(((((int )move >> 6) & 0x3F) << 10) & 0x0000FC00);
#line 1672
  res = (res & 4294966287U) | (unsigned int )((((int )move & 0x3F) << 4) & 0x000003F0);
#line 1673
  res = (res & 4294508543U) | (unsigned int )(((((int )move >> 12) & 0x7) << 16) & 0x00070000);
#line 1674
  tmp___2 = is_en_passant((struct pos  const  *)(& pos), move);
#line 1674
  res = (res & 4294443007U) | (unsigned int )(((int )tmp___2 << 19) & 0x00080000);
#line 1675
  return (res);
}
}
#line 1680 "tbprobe.c"
unsigned int tb_pop_count(uint64_t bb ) 
{ 
  int tmp ;

  {
#line 1681
  tmp = __builtin_popcountll((unsigned long long )bb);
#line 1681
  return ((unsigned int )tmp);
}
}
#line 1684 "tbprobe.c"
unsigned int tb_lsb(uint64_t bb ) 
{ 
  unsigned int tmp ;

  {
#line 1685
  tmp = _lsb(bb);
#line 1685
  return (tmp);
}
}
#line 1688 "tbprobe.c"
uint64_t tb_pop_lsb(uint64_t bb ) 
{ 


  {
#line 1689
  return (bb & (bb - 1UL));
}
}
#line 1692 "tbprobe.c"
uint64_t tb_king_attacks(unsigned int sq ) 
{ 


  {
#line 1693
  return (king_attacks[sq]);
}
}
#line 1696 "tbprobe.c"
uint64_t tb_queen_attacks(unsigned int sq , uint64_t occ ) 
{ 


  {
#line 1697
  return (*(magic_bishop_indices[sq] + ((occ & (unsigned long )magic_bishop_mask[sq]) * (unsigned long )magic_bishop[sq] >> magic_bishop_shift[sq])) | *(magic_rook_indices[sq] + ((occ & (unsigned long )magic_rook_mask[sq]) * (unsigned long )magic_rook[sq] >> magic_rook_shift[sq])));
}
}
#line 1700 "tbprobe.c"
uint64_t tb_rook_attacks(unsigned int sq , uint64_t occ ) 
{ 


  {
#line 1701
  return (*(magic_rook_indices[sq] + ((occ & (unsigned long )magic_rook_mask[sq]) * (unsigned long )magic_rook[sq] >> magic_rook_shift[sq])));
}
}
#line 1704 "tbprobe.c"
uint64_t tb_bishop_attacks(unsigned int sq , uint64_t occ ) 
{ 


  {
#line 1705
  return (*(magic_bishop_indices[sq] + ((occ & (unsigned long )magic_bishop_mask[sq]) * (unsigned long )magic_bishop[sq] >> magic_bishop_shift[sq])));
}
}
#line 1708 "tbprobe.c"
uint64_t tb_knight_attacks(unsigned int sq ) 
{ 


  {
#line 1709
  return (knight_attacks[sq]);
}
}
#line 1712 "tbprobe.c"
uint64_t tb_pawn_attacks(unsigned int sq , _Bool color ) 
{ 


  {
#line 1713
  return (pawn_attacks[color][sq]);
}
}
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassify)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 24
extern int ( __attribute__((__leaf__)) __signbit)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 29
extern int ( __attribute__((__leaf__)) __isinf)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finite)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 37
extern int ( __attribute__((__leaf__)) __isnan)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 41
extern int ( __attribute__((__leaf__)) __iseqsig)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 44
extern int ( __attribute__((__leaf__)) __issignaling)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern double ( __attribute__((__leaf__)) acos)(double __x )  __attribute__((__nothrow__)) ;
#line 53
extern double ( __attribute__((__leaf__)) __acos)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) asin)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) __asin)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) atan)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) __atan)(double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) atan2)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) __atan2)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) cos)(double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) __cos)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) sin)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) __sin)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) tan)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) __tan)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) cosh)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) __cosh)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) sinh)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) __sinh)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) tanh)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) __tanh)(double __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincos)(double __x , double *__sinx , double *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincos)(double __x , double *__sinx , double *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) acosh)(double __x )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) __acosh)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) asinh)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) __asinh)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) atanh)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) __atanh)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) exp)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) __exp)(double __x )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) frexp)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) __frexp)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) ldexp)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) __ldexp)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) log)(double __x )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) __log)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) log10)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) __log10)(double __x )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__leaf__)) modf)(double __x , double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__nonnull__(2), __leaf__)) __modf)(double __x , double *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) exp10)(double __x )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) __exp10)(double __x )  __attribute__((__nothrow__)) ;
#line 117
extern double ( __attribute__((__leaf__)) exp2m1)(double __x )  __attribute__((__nothrow__)) ;
#line 117
extern double ( __attribute__((__leaf__)) __exp2m1)(double __x )  __attribute__((__nothrow__)) ;
#line 120
extern double ( __attribute__((__leaf__)) exp10m1)(double __x )  __attribute__((__nothrow__)) ;
#line 120
extern double ( __attribute__((__leaf__)) __exp10m1)(double __x )  __attribute__((__nothrow__)) ;
#line 123
extern double ( __attribute__((__leaf__)) log2p1)(double __x )  __attribute__((__nothrow__)) ;
#line 123
extern double ( __attribute__((__leaf__)) __log2p1)(double __x )  __attribute__((__nothrow__)) ;
#line 126
extern double ( __attribute__((__leaf__)) log10p1)(double __x )  __attribute__((__nothrow__)) ;
#line 126
extern double ( __attribute__((__leaf__)) __log10p1)(double __x )  __attribute__((__nothrow__)) ;
#line 129
extern double ( __attribute__((__leaf__)) logp1)(double __x )  __attribute__((__nothrow__)) ;
#line 129
extern double ( __attribute__((__leaf__)) __logp1)(double __x )  __attribute__((__nothrow__)) ;
#line 134
extern double ( __attribute__((__leaf__)) expm1)(double __x )  __attribute__((__nothrow__)) ;
#line 134
extern double ( __attribute__((__leaf__)) __expm1)(double __x )  __attribute__((__nothrow__)) ;
#line 137
extern double ( __attribute__((__leaf__)) log1p)(double __x )  __attribute__((__nothrow__)) ;
#line 137
extern double ( __attribute__((__leaf__)) __log1p)(double __x )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) logb)(double __x )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) __logb)(double __x )  __attribute__((__nothrow__)) ;
#line 145
extern double ( __attribute__((__leaf__)) exp2)(double __x )  __attribute__((__nothrow__)) ;
#line 145
extern double ( __attribute__((__leaf__)) __exp2)(double __x )  __attribute__((__nothrow__)) ;
#line 148
extern double ( __attribute__((__leaf__)) log2)(double __x )  __attribute__((__nothrow__)) ;
#line 148
extern double ( __attribute__((__leaf__)) __log2)(double __x )  __attribute__((__nothrow__)) ;
#line 155
extern double ( __attribute__((__leaf__)) pow)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 155
extern double ( __attribute__((__leaf__)) __pow)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 158
extern double ( __attribute__((__leaf__)) sqrt)(double __x )  __attribute__((__nothrow__)) ;
#line 158
extern double ( __attribute__((__leaf__)) __sqrt)(double __x )  __attribute__((__nothrow__)) ;
#line 162
extern double ( __attribute__((__leaf__)) hypot)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 162
extern double ( __attribute__((__leaf__)) __hypot)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 167
extern double ( __attribute__((__leaf__)) cbrt)(double __x )  __attribute__((__nothrow__)) ;
#line 167
extern double ( __attribute__((__leaf__)) __cbrt)(double __x )  __attribute__((__nothrow__)) ;
#line 174
extern double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 174
extern double ( __attribute__((__leaf__)) __ceil)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern double ( __attribute__((__leaf__)) __fabs)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern double ( __attribute__((__leaf__)) __floor)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 183
extern double ( __attribute__((__leaf__)) fmod)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 183
extern double ( __attribute__((__leaf__)) __fmod)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 192
extern int ( __attribute__((__leaf__)) isinf)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 198
extern int ( __attribute__((__leaf__)) finite)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 202
extern double ( __attribute__((__leaf__)) drem)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 202
extern double ( __attribute__((__leaf__)) __drem)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 206
extern double ( __attribute__((__leaf__)) significand)(double __x )  __attribute__((__nothrow__)) ;
#line 206
extern double ( __attribute__((__leaf__)) __significand)(double __x )  __attribute__((__nothrow__)) ;
#line 213
extern double ( __attribute__((__leaf__)) copysign)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 213
extern double ( __attribute__((__leaf__)) __copysign)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 218
extern double ( __attribute__((__leaf__)) nan)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 218
extern double ( __attribute__((__leaf__)) __nan)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 228
extern int ( __attribute__((__leaf__)) isnan)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 235
extern double ( __attribute__((__leaf__)) j0)(double  )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) __j0)(double  )  __attribute__((__nothrow__)) ;
#line 236
extern double ( __attribute__((__leaf__)) j1)(double  )  __attribute__((__nothrow__)) ;
#line 236
extern double ( __attribute__((__leaf__)) __j1)(double  )  __attribute__((__nothrow__)) ;
#line 237
extern double ( __attribute__((__leaf__)) jn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 237
extern double ( __attribute__((__leaf__)) __jn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 238
extern double ( __attribute__((__leaf__)) y0)(double  )  __attribute__((__nothrow__)) ;
#line 238
extern double ( __attribute__((__leaf__)) __y0)(double  )  __attribute__((__nothrow__)) ;
#line 239
extern double ( __attribute__((__leaf__)) y1)(double  )  __attribute__((__nothrow__)) ;
#line 239
extern double ( __attribute__((__leaf__)) __y1)(double  )  __attribute__((__nothrow__)) ;
#line 240
extern double ( __attribute__((__leaf__)) yn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 240
extern double ( __attribute__((__leaf__)) __yn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 246
extern double ( __attribute__((__leaf__)) erf)(double  )  __attribute__((__nothrow__)) ;
#line 246
extern double ( __attribute__((__leaf__)) __erf)(double  )  __attribute__((__nothrow__)) ;
#line 247
extern double ( __attribute__((__leaf__)) erfc)(double  )  __attribute__((__nothrow__)) ;
#line 247
extern double ( __attribute__((__leaf__)) __erfc)(double  )  __attribute__((__nothrow__)) ;
#line 248
extern double ( __attribute__((__leaf__)) lgamma)(double  )  __attribute__((__nothrow__)) ;
#line 248
extern double ( __attribute__((__leaf__)) __lgamma)(double  )  __attribute__((__nothrow__)) ;
#line 253
extern double ( __attribute__((__leaf__)) tgamma)(double  )  __attribute__((__nothrow__)) ;
#line 253
extern double ( __attribute__((__leaf__)) __tgamma)(double  )  __attribute__((__nothrow__)) ;
#line 259
extern double ( __attribute__((__leaf__)) gamma)(double  )  __attribute__((__nothrow__)) ;
#line 259
extern double ( __attribute__((__leaf__)) __gamma)(double  )  __attribute__((__nothrow__)) ;
#line 267
extern double ( __attribute__((__leaf__)) lgamma_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 267
extern double ( __attribute__((__leaf__)) __lgamma_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 274
extern double ( __attribute__((__leaf__)) rint)(double __x )  __attribute__((__nothrow__)) ;
#line 274
extern double ( __attribute__((__leaf__)) __rint)(double __x )  __attribute__((__nothrow__)) ;
#line 277
extern double ( __attribute__((__leaf__)) nextafter)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 277
extern double ( __attribute__((__leaf__)) __nextafter)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 279
extern double ( __attribute__((__leaf__)) nexttoward)(double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 279
extern double ( __attribute__((__leaf__)) __nexttoward)(double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 284
extern double ( __attribute__((__leaf__)) nextdown)(double __x )  __attribute__((__nothrow__)) ;
#line 284
extern double ( __attribute__((__leaf__)) __nextdown)(double __x )  __attribute__((__nothrow__)) ;
#line 286
extern double ( __attribute__((__leaf__)) nextup)(double __x )  __attribute__((__nothrow__)) ;
#line 286
extern double ( __attribute__((__leaf__)) __nextup)(double __x )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) remainder)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) __remainder)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) scalbn)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) __scalbn)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) ilogb)(double __x )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) __ilogb)(double __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) llogb)(double __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) __llogb)(double __x )  __attribute__((__nothrow__)) ;
#line 308
extern double ( __attribute__((__leaf__)) scalbln)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 308
extern double ( __attribute__((__leaf__)) __scalbln)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 312
extern double ( __attribute__((__leaf__)) nearbyint)(double __x )  __attribute__((__nothrow__)) ;
#line 312
extern double ( __attribute__((__leaf__)) __nearbyint)(double __x )  __attribute__((__nothrow__)) ;
#line 316
extern double ( __attribute__((__leaf__)) round)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 316
extern double ( __attribute__((__leaf__)) __round)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern double ( __attribute__((__leaf__)) trunc)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern double ( __attribute__((__leaf__)) __trunc)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 325
extern double ( __attribute__((__leaf__)) remquo)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 325
extern double ( __attribute__((__leaf__)) __remquo)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) lrint)(double __x )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) __lrint)(double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) llrint)(double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) __llrint)(double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) lround)(double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) __lround)(double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) llround)(double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) __llround)(double __x )  __attribute__((__nothrow__)) ;
#line 344
extern double ( __attribute__((__leaf__)) fdim)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 344
extern double ( __attribute__((__leaf__)) __fdim)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 348
extern double ( __attribute__((__leaf__)) fmax)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 348
extern double ( __attribute__((__leaf__)) __fmax)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern double ( __attribute__((__leaf__)) fmin)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern double ( __attribute__((__leaf__)) __fmin)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 355
extern double ( __attribute__((__leaf__)) fma)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 355
extern double ( __attribute__((__leaf__)) __fma)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 360
extern double ( __attribute__((__leaf__)) roundeven)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 360
extern double ( __attribute__((__leaf__)) __roundeven)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) fromfp)(double __x , int __round , unsigned int __width )  __attribute__((__nothrow__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) __fromfp)(double __x , int __round ,
                                                        unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) ufromfp)(double __x , int __round ,
                                                        unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfp)(double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) fromfpx)(double __x , int __round ,
                                                       unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) __fromfpx)(double __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpx)(double __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpx)(double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 385
extern int ( __attribute__((__leaf__)) canonicalize)(double *__cx , double const   *__x )  __attribute__((__nothrow__)) ;
#line 392
extern double ( __attribute__((__leaf__)) fmaxmag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 392
extern double ( __attribute__((__leaf__)) __fmaxmag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern double ( __attribute__((__leaf__)) fminmag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern double ( __attribute__((__leaf__)) __fminmag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern double ( __attribute__((__leaf__)) fmaximum)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern double ( __attribute__((__leaf__)) __fmaximum)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern double ( __attribute__((__leaf__)) fminimum)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern double ( __attribute__((__leaf__)) __fminimum)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern double ( __attribute__((__leaf__)) fmaximum_num)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern double ( __attribute__((__leaf__)) __fmaximum_num)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern double ( __attribute__((__leaf__)) fminimum_num)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern double ( __attribute__((__leaf__)) __fminimum_num)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern double ( __attribute__((__leaf__)) fmaximum_mag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern double ( __attribute__((__leaf__)) __fmaximum_mag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern double ( __attribute__((__leaf__)) fminimum_mag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern double ( __attribute__((__leaf__)) __fminimum_mag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern double ( __attribute__((__leaf__)) fmaximum_mag_num)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern double ( __attribute__((__leaf__)) __fmaximum_mag_num)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern double ( __attribute__((__leaf__)) fminimum_mag_num)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern double ( __attribute__((__leaf__)) __fminimum_mag_num)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 426
extern int ( __attribute__((__leaf__)) totalorder)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 431
extern int ( __attribute__((__leaf__)) totalordermag)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 436
extern double ( __attribute__((__leaf__)) getpayload)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 436
extern double ( __attribute__((__leaf__)) __getpayload)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 439
extern int ( __attribute__((__leaf__)) setpayload)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 442
extern int ( __attribute__((__leaf__)) setpayloadsig)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 450
extern double ( __attribute__((__leaf__)) scalb)(double __x , double __n )  __attribute__((__nothrow__)) ;
#line 450
extern double ( __attribute__((__leaf__)) __scalb)(double __x , double __n )  __attribute__((__nothrow__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassifyf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 24
extern int ( __attribute__((__leaf__)) __signbitf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 29
extern int ( __attribute__((__leaf__)) __isinff)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finitef)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 37
extern int ( __attribute__((__leaf__)) __isnanf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 41
extern int ( __attribute__((__leaf__)) __iseqsigf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 44
extern int ( __attribute__((__leaf__)) __issignalingf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern float ( __attribute__((__leaf__)) acosf)(float __x )  __attribute__((__nothrow__)) ;
#line 53
extern float ( __attribute__((__leaf__)) __acosf)(float __x )  __attribute__((__nothrow__)) ;
#line 55
extern float ( __attribute__((__leaf__)) asinf)(float __x )  __attribute__((__nothrow__)) ;
#line 55
extern float ( __attribute__((__leaf__)) __asinf)(float __x )  __attribute__((__nothrow__)) ;
#line 57
extern float ( __attribute__((__leaf__)) atanf)(float __x )  __attribute__((__nothrow__)) ;
#line 57
extern float ( __attribute__((__leaf__)) __atanf)(float __x )  __attribute__((__nothrow__)) ;
#line 59
extern float ( __attribute__((__leaf__)) atan2f)(float __y , float __x )  __attribute__((__nothrow__)) ;
#line 59
extern float ( __attribute__((__leaf__)) __atan2f)(float __y , float __x )  __attribute__((__nothrow__)) ;
#line 62
extern float ( __attribute__((__leaf__)) cosf)(float __x )  __attribute__((__nothrow__)) ;
#line 62
extern float ( __attribute__((__leaf__)) __cosf)(float __x )  __attribute__((__nothrow__)) ;
#line 64
extern float ( __attribute__((__leaf__)) sinf)(float __x )  __attribute__((__nothrow__)) ;
#line 64
extern float ( __attribute__((__leaf__)) __sinf)(float __x )  __attribute__((__nothrow__)) ;
#line 66
extern float ( __attribute__((__leaf__)) tanf)(float __x )  __attribute__((__nothrow__)) ;
#line 66
extern float ( __attribute__((__leaf__)) __tanf)(float __x )  __attribute__((__nothrow__)) ;
#line 71
extern float ( __attribute__((__leaf__)) coshf)(float __x )  __attribute__((__nothrow__)) ;
#line 71
extern float ( __attribute__((__leaf__)) __coshf)(float __x )  __attribute__((__nothrow__)) ;
#line 73
extern float ( __attribute__((__leaf__)) sinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 73
extern float ( __attribute__((__leaf__)) __sinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 75
extern float ( __attribute__((__leaf__)) tanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 75
extern float ( __attribute__((__leaf__)) __tanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf)(float __x , float *__sinx , float *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf)(float __x , float *__sinx , float *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern float ( __attribute__((__leaf__)) acoshf)(float __x )  __attribute__((__nothrow__)) ;
#line 85
extern float ( __attribute__((__leaf__)) __acoshf)(float __x )  __attribute__((__nothrow__)) ;
#line 87
extern float ( __attribute__((__leaf__)) asinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 87
extern float ( __attribute__((__leaf__)) __asinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 89
extern float ( __attribute__((__leaf__)) atanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 89
extern float ( __attribute__((__leaf__)) __atanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 95
extern float ( __attribute__((__leaf__)) expf)(float __x )  __attribute__((__nothrow__)) ;
#line 95
extern float ( __attribute__((__leaf__)) __expf)(float __x )  __attribute__((__nothrow__)) ;
#line 98
extern float ( __attribute__((__leaf__)) frexpf)(float __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern float ( __attribute__((__leaf__)) __frexpf)(float __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern float ( __attribute__((__leaf__)) ldexpf)(float __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern float ( __attribute__((__leaf__)) __ldexpf)(float __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern float ( __attribute__((__leaf__)) logf)(float __x )  __attribute__((__nothrow__)) ;
#line 104
extern float ( __attribute__((__leaf__)) __logf)(float __x )  __attribute__((__nothrow__)) ;
#line 107
extern float ( __attribute__((__leaf__)) log10f)(float __x )  __attribute__((__nothrow__)) ;
#line 107
extern float ( __attribute__((__leaf__)) __log10f)(float __x )  __attribute__((__nothrow__)) ;
#line 110
extern float ( __attribute__((__leaf__)) modff)(float __x , float *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern float ( __attribute__((__nonnull__(2), __leaf__)) __modff)(float __x , float *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern float ( __attribute__((__leaf__)) exp10f)(float __x )  __attribute__((__nothrow__)) ;
#line 114
extern float ( __attribute__((__leaf__)) __exp10f)(float __x )  __attribute__((__nothrow__)) ;
#line 117
extern float ( __attribute__((__leaf__)) exp2m1f)(float __x )  __attribute__((__nothrow__)) ;
#line 117
extern float ( __attribute__((__leaf__)) __exp2m1f)(float __x )  __attribute__((__nothrow__)) ;
#line 120
extern float ( __attribute__((__leaf__)) exp10m1f)(float __x )  __attribute__((__nothrow__)) ;
#line 120
extern float ( __attribute__((__leaf__)) __exp10m1f)(float __x )  __attribute__((__nothrow__)) ;
#line 123
extern float ( __attribute__((__leaf__)) log2p1f)(float __x )  __attribute__((__nothrow__)) ;
#line 123
extern float ( __attribute__((__leaf__)) __log2p1f)(float __x )  __attribute__((__nothrow__)) ;
#line 126
extern float ( __attribute__((__leaf__)) log10p1f)(float __x )  __attribute__((__nothrow__)) ;
#line 126
extern float ( __attribute__((__leaf__)) __log10p1f)(float __x )  __attribute__((__nothrow__)) ;
#line 129
extern float ( __attribute__((__leaf__)) logp1f)(float __x )  __attribute__((__nothrow__)) ;
#line 129
extern float ( __attribute__((__leaf__)) __logp1f)(float __x )  __attribute__((__nothrow__)) ;
#line 134
extern float ( __attribute__((__leaf__)) expm1f)(float __x )  __attribute__((__nothrow__)) ;
#line 134
extern float ( __attribute__((__leaf__)) __expm1f)(float __x )  __attribute__((__nothrow__)) ;
#line 137
extern float ( __attribute__((__leaf__)) log1pf)(float __x )  __attribute__((__nothrow__)) ;
#line 137
extern float ( __attribute__((__leaf__)) __log1pf)(float __x )  __attribute__((__nothrow__)) ;
#line 140
extern float ( __attribute__((__leaf__)) logbf)(float __x )  __attribute__((__nothrow__)) ;
#line 140
extern float ( __attribute__((__leaf__)) __logbf)(float __x )  __attribute__((__nothrow__)) ;
#line 145
extern float ( __attribute__((__leaf__)) exp2f)(float __x )  __attribute__((__nothrow__)) ;
#line 145
extern float ( __attribute__((__leaf__)) __exp2f)(float __x )  __attribute__((__nothrow__)) ;
#line 148
extern float ( __attribute__((__leaf__)) log2f)(float __x )  __attribute__((__nothrow__)) ;
#line 148
extern float ( __attribute__((__leaf__)) __log2f)(float __x )  __attribute__((__nothrow__)) ;
#line 155
extern float ( __attribute__((__leaf__)) powf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 155
extern float ( __attribute__((__leaf__)) __powf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 158
extern float ( __attribute__((__leaf__)) sqrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 158
extern float ( __attribute__((__leaf__)) __sqrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 162
extern float ( __attribute__((__leaf__)) hypotf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 162
extern float ( __attribute__((__leaf__)) __hypotf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 167
extern float ( __attribute__((__leaf__)) cbrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 167
extern float ( __attribute__((__leaf__)) __cbrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 174
extern float ( __attribute__((__leaf__)) ceilf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 174
extern float ( __attribute__((__leaf__)) __ceilf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern float ( __attribute__((__leaf__)) fabsf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern float ( __attribute__((__leaf__)) __fabsf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern float ( __attribute__((__leaf__)) floorf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern float ( __attribute__((__leaf__)) __floorf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 183
extern float ( __attribute__((__leaf__)) fmodf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 183
extern float ( __attribute__((__leaf__)) __fmodf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 192
extern int ( __attribute__((__leaf__)) isinff)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 198
extern int ( __attribute__((__leaf__)) finitef)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 202
extern float ( __attribute__((__leaf__)) dremf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 202
extern float ( __attribute__((__leaf__)) __dremf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 206
extern float ( __attribute__((__leaf__)) significandf)(float __x )  __attribute__((__nothrow__)) ;
#line 206
extern float ( __attribute__((__leaf__)) __significandf)(float __x )  __attribute__((__nothrow__)) ;
#line 213
extern float ( __attribute__((__leaf__)) copysignf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 213
extern float ( __attribute__((__leaf__)) __copysignf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 218
extern float ( __attribute__((__leaf__)) nanf)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 218
extern float ( __attribute__((__leaf__)) __nanf)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 228
extern int ( __attribute__((__leaf__)) isnanf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 235
extern float ( __attribute__((__leaf__)) j0f)(float  )  __attribute__((__nothrow__)) ;
#line 235
extern float ( __attribute__((__leaf__)) __j0f)(float  )  __attribute__((__nothrow__)) ;
#line 236
extern float ( __attribute__((__leaf__)) j1f)(float  )  __attribute__((__nothrow__)) ;
#line 236
extern float ( __attribute__((__leaf__)) __j1f)(float  )  __attribute__((__nothrow__)) ;
#line 237
extern float ( __attribute__((__leaf__)) jnf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 237
extern float ( __attribute__((__leaf__)) __jnf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 238
extern float ( __attribute__((__leaf__)) y0f)(float  )  __attribute__((__nothrow__)) ;
#line 238
extern float ( __attribute__((__leaf__)) __y0f)(float  )  __attribute__((__nothrow__)) ;
#line 239
extern float ( __attribute__((__leaf__)) y1f)(float  )  __attribute__((__nothrow__)) ;
#line 239
extern float ( __attribute__((__leaf__)) __y1f)(float  )  __attribute__((__nothrow__)) ;
#line 240
extern float ( __attribute__((__leaf__)) ynf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 240
extern float ( __attribute__((__leaf__)) __ynf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 246
extern float ( __attribute__((__leaf__)) erff)(float  )  __attribute__((__nothrow__)) ;
#line 246
extern float ( __attribute__((__leaf__)) __erff)(float  )  __attribute__((__nothrow__)) ;
#line 247
extern float ( __attribute__((__leaf__)) erfcf)(float  )  __attribute__((__nothrow__)) ;
#line 247
extern float ( __attribute__((__leaf__)) __erfcf)(float  )  __attribute__((__nothrow__)) ;
#line 248
extern float ( __attribute__((__leaf__)) lgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 248
extern float ( __attribute__((__leaf__)) __lgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 253
extern float ( __attribute__((__leaf__)) tgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 253
extern float ( __attribute__((__leaf__)) __tgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 259
extern float ( __attribute__((__leaf__)) gammaf)(float  )  __attribute__((__nothrow__)) ;
#line 259
extern float ( __attribute__((__leaf__)) __gammaf)(float  )  __attribute__((__nothrow__)) ;
#line 267
extern float ( __attribute__((__leaf__)) lgammaf_r)(float  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 267
extern float ( __attribute__((__leaf__)) __lgammaf_r)(float  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 274
extern float ( __attribute__((__leaf__)) rintf)(float __x )  __attribute__((__nothrow__)) ;
#line 274
extern float ( __attribute__((__leaf__)) __rintf)(float __x )  __attribute__((__nothrow__)) ;
#line 277
extern float ( __attribute__((__leaf__)) nextafterf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 277
extern float ( __attribute__((__leaf__)) __nextafterf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 279
extern float ( __attribute__((__leaf__)) nexttowardf)(float __x , long double __y )  __attribute__((__nothrow__)) ;
#line 279
extern float ( __attribute__((__leaf__)) __nexttowardf)(float __x , long double __y )  __attribute__((__nothrow__)) ;
#line 284
extern float ( __attribute__((__leaf__)) nextdownf)(float __x )  __attribute__((__nothrow__)) ;
#line 284
extern float ( __attribute__((__leaf__)) __nextdownf)(float __x )  __attribute__((__nothrow__)) ;
#line 286
extern float ( __attribute__((__leaf__)) nextupf)(float __x )  __attribute__((__nothrow__)) ;
#line 286
extern float ( __attribute__((__leaf__)) __nextupf)(float __x )  __attribute__((__nothrow__)) ;
#line 290
extern float ( __attribute__((__leaf__)) remainderf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 290
extern float ( __attribute__((__leaf__)) __remainderf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 294
extern float ( __attribute__((__leaf__)) scalbnf)(float __x , int __n )  __attribute__((__nothrow__)) ;
#line 294
extern float ( __attribute__((__leaf__)) __scalbnf)(float __x , int __n )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) ilogbf)(float __x )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) __ilogbf)(float __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) llogbf)(float __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) __llogbf)(float __x )  __attribute__((__nothrow__)) ;
#line 308
extern float ( __attribute__((__leaf__)) scalblnf)(float __x , long __n )  __attribute__((__nothrow__)) ;
#line 308
extern float ( __attribute__((__leaf__)) __scalblnf)(float __x , long __n )  __attribute__((__nothrow__)) ;
#line 312
extern float ( __attribute__((__leaf__)) nearbyintf)(float __x )  __attribute__((__nothrow__)) ;
#line 312
extern float ( __attribute__((__leaf__)) __nearbyintf)(float __x )  __attribute__((__nothrow__)) ;
#line 316
extern float ( __attribute__((__leaf__)) roundf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 316
extern float ( __attribute__((__leaf__)) __roundf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern float ( __attribute__((__leaf__)) truncf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern float ( __attribute__((__leaf__)) __truncf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 325
extern float ( __attribute__((__leaf__)) remquof)(float __x , float __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 325
extern float ( __attribute__((__leaf__)) __remquof)(float __x , float __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) lrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) __lrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) llrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) __llrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) lroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) __lroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) llroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) __llroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 344
extern float ( __attribute__((__leaf__)) fdimf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 344
extern float ( __attribute__((__leaf__)) __fdimf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 348
extern float ( __attribute__((__leaf__)) fmaxf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 348
extern float ( __attribute__((__leaf__)) __fmaxf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern float ( __attribute__((__leaf__)) fminf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern float ( __attribute__((__leaf__)) __fminf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 355
extern float ( __attribute__((__leaf__)) fmaf)(float __x , float __y , float __z )  __attribute__((__nothrow__)) ;
#line 355
extern float ( __attribute__((__leaf__)) __fmaf)(float __x , float __y , float __z )  __attribute__((__nothrow__)) ;
#line 360
extern float ( __attribute__((__leaf__)) roundevenf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 360
extern float ( __attribute__((__leaf__)) __roundevenf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) fromfpf)(float __x , int __round , unsigned int __width )  __attribute__((__nothrow__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf)(float __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf)(float __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf)(float __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf)(float __x , int __round ,
                                                        unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf)(float __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf)(float __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf)(float __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 385
extern int ( __attribute__((__leaf__)) canonicalizef)(float *__cx , float const   *__x )  __attribute__((__nothrow__)) ;
#line 392
extern float ( __attribute__((__leaf__)) fmaxmagf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 392
extern float ( __attribute__((__leaf__)) __fmaxmagf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern float ( __attribute__((__leaf__)) fminmagf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern float ( __attribute__((__leaf__)) __fminmagf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern float ( __attribute__((__leaf__)) fmaximumf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern float ( __attribute__((__leaf__)) __fmaximumf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern float ( __attribute__((__leaf__)) fminimumf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern float ( __attribute__((__leaf__)) __fminimumf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern float ( __attribute__((__leaf__)) fmaximum_numf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern float ( __attribute__((__leaf__)) __fmaximum_numf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern float ( __attribute__((__leaf__)) fminimum_numf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern float ( __attribute__((__leaf__)) __fminimum_numf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern float ( __attribute__((__leaf__)) fmaximum_magf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern float ( __attribute__((__leaf__)) __fmaximum_magf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern float ( __attribute__((__leaf__)) fminimum_magf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern float ( __attribute__((__leaf__)) __fminimum_magf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern float ( __attribute__((__leaf__)) fmaximum_mag_numf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern float ( __attribute__((__leaf__)) __fmaximum_mag_numf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern float ( __attribute__((__leaf__)) fminimum_mag_numf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern float ( __attribute__((__leaf__)) __fminimum_mag_numf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 426
extern int ( __attribute__((__leaf__)) totalorderf)(float const   *__x , float const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 431
extern int ( __attribute__((__leaf__)) totalordermagf)(float const   *__x , float const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 436
extern float ( __attribute__((__leaf__)) getpayloadf)(float const   *__x )  __attribute__((__nothrow__)) ;
#line 436
extern float ( __attribute__((__leaf__)) __getpayloadf)(float const   *__x )  __attribute__((__nothrow__)) ;
#line 439
extern int ( __attribute__((__leaf__)) setpayloadf)(float *__x , float __payload )  __attribute__((__nothrow__)) ;
#line 442
extern int ( __attribute__((__leaf__)) setpayloadsigf)(float *__x , float __payload )  __attribute__((__nothrow__)) ;
#line 450
extern float ( __attribute__((__leaf__)) scalbf)(float __x , float __n )  __attribute__((__nothrow__)) ;
#line 450
extern float ( __attribute__((__leaf__)) __scalbf)(float __x , float __n )  __attribute__((__nothrow__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassifyl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 24
extern int ( __attribute__((__leaf__)) __signbitl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 29
extern int ( __attribute__((__leaf__)) __isinfl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finitel)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 37
extern int ( __attribute__((__leaf__)) __isnanl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 41
extern int ( __attribute__((__leaf__)) __iseqsigl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 44
extern int ( __attribute__((__leaf__)) __issignalingl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern long double ( __attribute__((__leaf__)) acosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 53
extern long double ( __attribute__((__leaf__)) __acosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 55
extern long double ( __attribute__((__leaf__)) asinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 55
extern long double ( __attribute__((__leaf__)) __asinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 57
extern long double ( __attribute__((__leaf__)) atanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 57
extern long double ( __attribute__((__leaf__)) __atanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 59
extern long double ( __attribute__((__leaf__)) atan2l)(long double __y , long double __x )  __attribute__((__nothrow__)) ;
#line 59
extern long double ( __attribute__((__leaf__)) __atan2l)(long double __y , long double __x )  __attribute__((__nothrow__)) ;
#line 62
extern long double ( __attribute__((__leaf__)) cosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 62
extern long double ( __attribute__((__leaf__)) __cosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 64
extern long double ( __attribute__((__leaf__)) sinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 64
extern long double ( __attribute__((__leaf__)) __sinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 66
extern long double ( __attribute__((__leaf__)) tanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 66
extern long double ( __attribute__((__leaf__)) __tanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 71
extern long double ( __attribute__((__leaf__)) coshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 71
extern long double ( __attribute__((__leaf__)) __coshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 73
extern long double ( __attribute__((__leaf__)) sinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 73
extern long double ( __attribute__((__leaf__)) __sinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 75
extern long double ( __attribute__((__leaf__)) tanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 75
extern long double ( __attribute__((__leaf__)) __tanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosl)(long double __x , long double *__sinx ,
                                                 long double *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosl)(long double __x , long double *__sinx ,
                                                   long double *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern long double ( __attribute__((__leaf__)) acoshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 85
extern long double ( __attribute__((__leaf__)) __acoshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 87
extern long double ( __attribute__((__leaf__)) asinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 87
extern long double ( __attribute__((__leaf__)) __asinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 89
extern long double ( __attribute__((__leaf__)) atanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 89
extern long double ( __attribute__((__leaf__)) __atanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 95
extern long double ( __attribute__((__leaf__)) expl)(long double __x )  __attribute__((__nothrow__)) ;
#line 95
extern long double ( __attribute__((__leaf__)) __expl)(long double __x )  __attribute__((__nothrow__)) ;
#line 98
extern long double ( __attribute__((__leaf__)) frexpl)(long double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern long double ( __attribute__((__leaf__)) __frexpl)(long double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern long double ( __attribute__((__leaf__)) ldexpl)(long double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern long double ( __attribute__((__leaf__)) __ldexpl)(long double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern long double ( __attribute__((__leaf__)) logl)(long double __x )  __attribute__((__nothrow__)) ;
#line 104
extern long double ( __attribute__((__leaf__)) __logl)(long double __x )  __attribute__((__nothrow__)) ;
#line 107
extern long double ( __attribute__((__leaf__)) log10l)(long double __x )  __attribute__((__nothrow__)) ;
#line 107
extern long double ( __attribute__((__leaf__)) __log10l)(long double __x )  __attribute__((__nothrow__)) ;
#line 110
extern long double ( __attribute__((__leaf__)) modfl)(long double __x , long double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern long double ( __attribute__((__nonnull__(2), __leaf__)) __modfl)(long double __x ,
                                                                        long double *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern long double ( __attribute__((__leaf__)) exp10l)(long double __x )  __attribute__((__nothrow__)) ;
#line 114
extern long double ( __attribute__((__leaf__)) __exp10l)(long double __x )  __attribute__((__nothrow__)) ;
#line 117
extern long double ( __attribute__((__leaf__)) exp2m1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 117
extern long double ( __attribute__((__leaf__)) __exp2m1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 120
extern long double ( __attribute__((__leaf__)) exp10m1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 120
extern long double ( __attribute__((__leaf__)) __exp10m1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 123
extern long double ( __attribute__((__leaf__)) log2p1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 123
extern long double ( __attribute__((__leaf__)) __log2p1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 126
extern long double ( __attribute__((__leaf__)) log10p1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 126
extern long double ( __attribute__((__leaf__)) __log10p1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 129
extern long double ( __attribute__((__leaf__)) logp1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 129
extern long double ( __attribute__((__leaf__)) __logp1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 134
extern long double ( __attribute__((__leaf__)) expm1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 134
extern long double ( __attribute__((__leaf__)) __expm1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 137
extern long double ( __attribute__((__leaf__)) log1pl)(long double __x )  __attribute__((__nothrow__)) ;
#line 137
extern long double ( __attribute__((__leaf__)) __log1pl)(long double __x )  __attribute__((__nothrow__)) ;
#line 140
extern long double ( __attribute__((__leaf__)) logbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 140
extern long double ( __attribute__((__leaf__)) __logbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 145
extern long double ( __attribute__((__leaf__)) exp2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 145
extern long double ( __attribute__((__leaf__)) __exp2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 148
extern long double ( __attribute__((__leaf__)) log2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 148
extern long double ( __attribute__((__leaf__)) __log2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 155
extern long double ( __attribute__((__leaf__)) powl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 155
extern long double ( __attribute__((__leaf__)) __powl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 158
extern long double ( __attribute__((__leaf__)) sqrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 158
extern long double ( __attribute__((__leaf__)) __sqrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 162
extern long double ( __attribute__((__leaf__)) hypotl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 162
extern long double ( __attribute__((__leaf__)) __hypotl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 167
extern long double ( __attribute__((__leaf__)) cbrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 167
extern long double ( __attribute__((__leaf__)) __cbrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 174
extern long double ( __attribute__((__leaf__)) ceill)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 174
extern long double ( __attribute__((__leaf__)) __ceill)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern long double ( __attribute__((__leaf__)) fabsl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern long double ( __attribute__((__leaf__)) __fabsl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern long double ( __attribute__((__leaf__)) floorl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern long double ( __attribute__((__leaf__)) __floorl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 183
extern long double ( __attribute__((__leaf__)) fmodl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 183
extern long double ( __attribute__((__leaf__)) __fmodl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 192
extern int ( __attribute__((__leaf__)) isinfl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 198
extern int ( __attribute__((__leaf__)) finitel)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 202
extern long double ( __attribute__((__leaf__)) dreml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 202
extern long double ( __attribute__((__leaf__)) __dreml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 206
extern long double ( __attribute__((__leaf__)) significandl)(long double __x )  __attribute__((__nothrow__)) ;
#line 206
extern long double ( __attribute__((__leaf__)) __significandl)(long double __x )  __attribute__((__nothrow__)) ;
#line 213
extern long double ( __attribute__((__leaf__)) copysignl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 213
extern long double ( __attribute__((__leaf__)) __copysignl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 218
extern long double ( __attribute__((__leaf__)) nanl)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 218
extern long double ( __attribute__((__leaf__)) __nanl)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 228
extern int ( __attribute__((__leaf__)) isnanl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 235
extern long double ( __attribute__((__leaf__)) j0l)(long double  )  __attribute__((__nothrow__)) ;
#line 235
extern long double ( __attribute__((__leaf__)) __j0l)(long double  )  __attribute__((__nothrow__)) ;
#line 236
extern long double ( __attribute__((__leaf__)) j1l)(long double  )  __attribute__((__nothrow__)) ;
#line 236
extern long double ( __attribute__((__leaf__)) __j1l)(long double  )  __attribute__((__nothrow__)) ;
#line 237
extern long double ( __attribute__((__leaf__)) jnl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 237
extern long double ( __attribute__((__leaf__)) __jnl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 238
extern long double ( __attribute__((__leaf__)) y0l)(long double  )  __attribute__((__nothrow__)) ;
#line 238
extern long double ( __attribute__((__leaf__)) __y0l)(long double  )  __attribute__((__nothrow__)) ;
#line 239
extern long double ( __attribute__((__leaf__)) y1l)(long double  )  __attribute__((__nothrow__)) ;
#line 239
extern long double ( __attribute__((__leaf__)) __y1l)(long double  )  __attribute__((__nothrow__)) ;
#line 240
extern long double ( __attribute__((__leaf__)) ynl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 240
extern long double ( __attribute__((__leaf__)) __ynl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 246
extern long double ( __attribute__((__leaf__)) erfl)(long double  )  __attribute__((__nothrow__)) ;
#line 246
extern long double ( __attribute__((__leaf__)) __erfl)(long double  )  __attribute__((__nothrow__)) ;
#line 247
extern long double ( __attribute__((__leaf__)) erfcl)(long double  )  __attribute__((__nothrow__)) ;
#line 247
extern long double ( __attribute__((__leaf__)) __erfcl)(long double  )  __attribute__((__nothrow__)) ;
#line 248
extern long double ( __attribute__((__leaf__)) lgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 248
extern long double ( __attribute__((__leaf__)) __lgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 253
extern long double ( __attribute__((__leaf__)) tgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 253
extern long double ( __attribute__((__leaf__)) __tgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 259
extern long double ( __attribute__((__leaf__)) gammal)(long double  )  __attribute__((__nothrow__)) ;
#line 259
extern long double ( __attribute__((__leaf__)) __gammal)(long double  )  __attribute__((__nothrow__)) ;
#line 267
extern long double ( __attribute__((__leaf__)) lgammal_r)(long double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 267
extern long double ( __attribute__((__leaf__)) __lgammal_r)(long double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 274
extern long double ( __attribute__((__leaf__)) rintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 274
extern long double ( __attribute__((__leaf__)) __rintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 277
extern long double ( __attribute__((__leaf__)) nextafterl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 277
extern long double ( __attribute__((__leaf__)) __nextafterl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 279
extern long double ( __attribute__((__leaf__)) nexttowardl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 279
extern long double ( __attribute__((__leaf__)) __nexttowardl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 284
extern long double ( __attribute__((__leaf__)) nextdownl)(long double __x )  __attribute__((__nothrow__)) ;
#line 284
extern long double ( __attribute__((__leaf__)) __nextdownl)(long double __x )  __attribute__((__nothrow__)) ;
#line 286
extern long double ( __attribute__((__leaf__)) nextupl)(long double __x )  __attribute__((__nothrow__)) ;
#line 286
extern long double ( __attribute__((__leaf__)) __nextupl)(long double __x )  __attribute__((__nothrow__)) ;
#line 290
extern long double ( __attribute__((__leaf__)) remainderl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 290
extern long double ( __attribute__((__leaf__)) __remainderl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 294
extern long double ( __attribute__((__leaf__)) scalbnl)(long double __x , int __n )  __attribute__((__nothrow__)) ;
#line 294
extern long double ( __attribute__((__leaf__)) __scalbnl)(long double __x , int __n )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) ilogbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) __ilogbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) llogbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) __llogbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 308
extern long double ( __attribute__((__leaf__)) scalblnl)(long double __x , long __n )  __attribute__((__nothrow__)) ;
#line 308
extern long double ( __attribute__((__leaf__)) __scalblnl)(long double __x , long __n )  __attribute__((__nothrow__)) ;
#line 312
extern long double ( __attribute__((__leaf__)) nearbyintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 312
extern long double ( __attribute__((__leaf__)) __nearbyintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long double ( __attribute__((__leaf__)) roundl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 316
extern long double ( __attribute__((__leaf__)) __roundl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern long double ( __attribute__((__leaf__)) truncl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern long double ( __attribute__((__leaf__)) __truncl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 325
extern long double ( __attribute__((__leaf__)) remquol)(long double __x , long double __y ,
                                                        int *__quo )  __attribute__((__nothrow__)) ;
#line 325
extern long double ( __attribute__((__leaf__)) __remquol)(long double __x , long double __y ,
                                                          int *__quo )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) lrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) __lrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) llrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) __llrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) lroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) __lroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) llroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) __llroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 344
extern long double ( __attribute__((__leaf__)) fdiml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 344
extern long double ( __attribute__((__leaf__)) __fdiml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 348
extern long double ( __attribute__((__leaf__)) fmaxl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 348
extern long double ( __attribute__((__leaf__)) __fmaxl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern long double ( __attribute__((__leaf__)) fminl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern long double ( __attribute__((__leaf__)) __fminl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 355
extern long double ( __attribute__((__leaf__)) fmal)(long double __x , long double __y ,
                                                     long double __z )  __attribute__((__nothrow__)) ;
#line 355
extern long double ( __attribute__((__leaf__)) __fmal)(long double __x , long double __y ,
                                                       long double __z )  __attribute__((__nothrow__)) ;
#line 360
extern long double ( __attribute__((__leaf__)) roundevenl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 360
extern long double ( __attribute__((__leaf__)) __roundevenl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) fromfpl)(long double __x , int __round ,
                                                       unsigned int __width )  __attribute__((__nothrow__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) __fromfpl)(long double __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpl)(long double __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpl)(long double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) fromfpxl)(long double __x , int __round ,
                                                        unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxl)(long double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxl)(long double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxl)(long double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 385
extern int ( __attribute__((__leaf__)) canonicalizel)(long double *__cx , long double const   *__x )  __attribute__((__nothrow__)) ;
#line 392
extern long double ( __attribute__((__leaf__)) fmaxmagl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 392
extern long double ( __attribute__((__leaf__)) __fmaxmagl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern long double ( __attribute__((__leaf__)) fminmagl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern long double ( __attribute__((__leaf__)) __fminmagl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern long double ( __attribute__((__leaf__)) fmaximuml)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern long double ( __attribute__((__leaf__)) __fmaximuml)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern long double ( __attribute__((__leaf__)) fminimuml)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern long double ( __attribute__((__leaf__)) __fminimuml)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern long double ( __attribute__((__leaf__)) fmaximum_numl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern long double ( __attribute__((__leaf__)) __fmaximum_numl)(long double __x ,
                                                                long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern long double ( __attribute__((__leaf__)) fminimum_numl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern long double ( __attribute__((__leaf__)) __fminimum_numl)(long double __x ,
                                                                long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern long double ( __attribute__((__leaf__)) fmaximum_magl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern long double ( __attribute__((__leaf__)) __fmaximum_magl)(long double __x ,
                                                                long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern long double ( __attribute__((__leaf__)) fminimum_magl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern long double ( __attribute__((__leaf__)) __fminimum_magl)(long double __x ,
                                                                long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern long double ( __attribute__((__leaf__)) fmaximum_mag_numl)(long double __x ,
                                                                  long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern long double ( __attribute__((__leaf__)) __fmaximum_mag_numl)(long double __x ,
                                                                    long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern long double ( __attribute__((__leaf__)) fminimum_mag_numl)(long double __x ,
                                                                  long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern long double ( __attribute__((__leaf__)) __fminimum_mag_numl)(long double __x ,
                                                                    long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 426
extern int ( __attribute__((__leaf__)) totalorderl)(long double const   *__x , long double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 431
extern int ( __attribute__((__leaf__)) totalordermagl)(long double const   *__x ,
                                                       long double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 436
extern long double ( __attribute__((__leaf__)) getpayloadl)(long double const   *__x )  __attribute__((__nothrow__)) ;
#line 436
extern long double ( __attribute__((__leaf__)) __getpayloadl)(long double const   *__x )  __attribute__((__nothrow__)) ;
#line 439
extern int ( __attribute__((__leaf__)) setpayloadl)(long double *__x , long double __payload )  __attribute__((__nothrow__)) ;
#line 442
extern int ( __attribute__((__leaf__)) setpayloadsigl)(long double *__x , long double __payload )  __attribute__((__nothrow__)) ;
#line 450
extern long double ( __attribute__((__leaf__)) scalbl)(long double __x , long double __n )  __attribute__((__nothrow__)) ;
#line 450
extern long double ( __attribute__((__leaf__)) __scalbl)(long double __x , long double __n )  __attribute__((__nothrow__)) ;
#line 53
extern float ( __attribute__((__leaf__)) acosf32)(float __x )  __attribute__((__nothrow__)) ;
#line 53
extern float ( __attribute__((__leaf__)) __acosf32)(float __x )  __attribute__((__nothrow__)) ;
#line 55
extern float ( __attribute__((__leaf__)) asinf32)(float __x )  __attribute__((__nothrow__)) ;
#line 55
extern float ( __attribute__((__leaf__)) __asinf32)(float __x )  __attribute__((__nothrow__)) ;
#line 57
extern float ( __attribute__((__leaf__)) atanf32)(float __x )  __attribute__((__nothrow__)) ;
#line 57
extern float ( __attribute__((__leaf__)) __atanf32)(float __x )  __attribute__((__nothrow__)) ;
#line 59
extern float ( __attribute__((__leaf__)) atan2f32)(float __y , float __x )  __attribute__((__nothrow__)) ;
#line 59
extern float ( __attribute__((__leaf__)) __atan2f32)(float __y , float __x )  __attribute__((__nothrow__)) ;
#line 62
extern float ( __attribute__((__leaf__)) cosf32)(float __x )  __attribute__((__nothrow__)) ;
#line 62
extern float ( __attribute__((__leaf__)) __cosf32)(float __x )  __attribute__((__nothrow__)) ;
#line 64
extern float ( __attribute__((__leaf__)) sinf32)(float __x )  __attribute__((__nothrow__)) ;
#line 64
extern float ( __attribute__((__leaf__)) __sinf32)(float __x )  __attribute__((__nothrow__)) ;
#line 66
extern float ( __attribute__((__leaf__)) tanf32)(float __x )  __attribute__((__nothrow__)) ;
#line 66
extern float ( __attribute__((__leaf__)) __tanf32)(float __x )  __attribute__((__nothrow__)) ;
#line 71
extern float ( __attribute__((__leaf__)) coshf32)(float __x )  __attribute__((__nothrow__)) ;
#line 71
extern float ( __attribute__((__leaf__)) __coshf32)(float __x )  __attribute__((__nothrow__)) ;
#line 73
extern float ( __attribute__((__leaf__)) sinhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 73
extern float ( __attribute__((__leaf__)) __sinhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 75
extern float ( __attribute__((__leaf__)) tanhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 75
extern float ( __attribute__((__leaf__)) __tanhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf32)(float __x , float *__sinx , float *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf32)(float __x , float *__sinx , float *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern float ( __attribute__((__leaf__)) acoshf32)(float __x )  __attribute__((__nothrow__)) ;
#line 85
extern float ( __attribute__((__leaf__)) __acoshf32)(float __x )  __attribute__((__nothrow__)) ;
#line 87
extern float ( __attribute__((__leaf__)) asinhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 87
extern float ( __attribute__((__leaf__)) __asinhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 89
extern float ( __attribute__((__leaf__)) atanhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 89
extern float ( __attribute__((__leaf__)) __atanhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 95
extern float ( __attribute__((__leaf__)) expf32)(float __x )  __attribute__((__nothrow__)) ;
#line 95
extern float ( __attribute__((__leaf__)) __expf32)(float __x )  __attribute__((__nothrow__)) ;
#line 98
extern float ( __attribute__((__leaf__)) frexpf32)(float __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern float ( __attribute__((__leaf__)) __frexpf32)(float __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern float ( __attribute__((__leaf__)) ldexpf32)(float __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern float ( __attribute__((__leaf__)) __ldexpf32)(float __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern float ( __attribute__((__leaf__)) logf32)(float __x )  __attribute__((__nothrow__)) ;
#line 104
extern float ( __attribute__((__leaf__)) __logf32)(float __x )  __attribute__((__nothrow__)) ;
#line 107
extern float ( __attribute__((__leaf__)) log10f32)(float __x )  __attribute__((__nothrow__)) ;
#line 107
extern float ( __attribute__((__leaf__)) __log10f32)(float __x )  __attribute__((__nothrow__)) ;
#line 110
extern float ( __attribute__((__leaf__)) modff32)(float __x , float *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern float ( __attribute__((__nonnull__(2), __leaf__)) __modff32)(float __x , float *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern float ( __attribute__((__leaf__)) exp10f32)(float __x )  __attribute__((__nothrow__)) ;
#line 114
extern float ( __attribute__((__leaf__)) __exp10f32)(float __x )  __attribute__((__nothrow__)) ;
#line 117
extern float ( __attribute__((__leaf__)) exp2m1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 117
extern float ( __attribute__((__leaf__)) __exp2m1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 120
extern float ( __attribute__((__leaf__)) exp10m1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 120
extern float ( __attribute__((__leaf__)) __exp10m1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 123
extern float ( __attribute__((__leaf__)) log2p1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 123
extern float ( __attribute__((__leaf__)) __log2p1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 126
extern float ( __attribute__((__leaf__)) log10p1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 126
extern float ( __attribute__((__leaf__)) __log10p1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 129
extern float ( __attribute__((__leaf__)) logp1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 129
extern float ( __attribute__((__leaf__)) __logp1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 134
extern float ( __attribute__((__leaf__)) expm1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 134
extern float ( __attribute__((__leaf__)) __expm1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 137
extern float ( __attribute__((__leaf__)) log1pf32)(float __x )  __attribute__((__nothrow__)) ;
#line 137
extern float ( __attribute__((__leaf__)) __log1pf32)(float __x )  __attribute__((__nothrow__)) ;
#line 140
extern float ( __attribute__((__leaf__)) logbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 140
extern float ( __attribute__((__leaf__)) __logbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 145
extern float ( __attribute__((__leaf__)) exp2f32)(float __x )  __attribute__((__nothrow__)) ;
#line 145
extern float ( __attribute__((__leaf__)) __exp2f32)(float __x )  __attribute__((__nothrow__)) ;
#line 148
extern float ( __attribute__((__leaf__)) log2f32)(float __x )  __attribute__((__nothrow__)) ;
#line 148
extern float ( __attribute__((__leaf__)) __log2f32)(float __x )  __attribute__((__nothrow__)) ;
#line 155
extern float ( __attribute__((__leaf__)) powf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 155
extern float ( __attribute__((__leaf__)) __powf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 158
extern float ( __attribute__((__leaf__)) sqrtf32)(float __x )  __attribute__((__nothrow__)) ;
#line 158
extern float ( __attribute__((__leaf__)) __sqrtf32)(float __x )  __attribute__((__nothrow__)) ;
#line 162
extern float ( __attribute__((__leaf__)) hypotf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 162
extern float ( __attribute__((__leaf__)) __hypotf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 167
extern float ( __attribute__((__leaf__)) cbrtf32)(float __x )  __attribute__((__nothrow__)) ;
#line 167
extern float ( __attribute__((__leaf__)) __cbrtf32)(float __x )  __attribute__((__nothrow__)) ;
#line 174
extern float ( __attribute__((__leaf__)) ceilf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 174
extern float ( __attribute__((__leaf__)) __ceilf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern float ( __attribute__((__leaf__)) fabsf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern float ( __attribute__((__leaf__)) __fabsf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern float ( __attribute__((__leaf__)) floorf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern float ( __attribute__((__leaf__)) __floorf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 183
extern float ( __attribute__((__leaf__)) fmodf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 183
extern float ( __attribute__((__leaf__)) __fmodf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 213
extern float ( __attribute__((__leaf__)) copysignf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 213
extern float ( __attribute__((__leaf__)) __copysignf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 218
extern float ( __attribute__((__leaf__)) nanf32)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 218
extern float ( __attribute__((__leaf__)) __nanf32)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 235
extern float ( __attribute__((__leaf__)) j0f32)(float  )  __attribute__((__nothrow__)) ;
#line 235
extern float ( __attribute__((__leaf__)) __j0f32)(float  )  __attribute__((__nothrow__)) ;
#line 236
extern float ( __attribute__((__leaf__)) j1f32)(float  )  __attribute__((__nothrow__)) ;
#line 236
extern float ( __attribute__((__leaf__)) __j1f32)(float  )  __attribute__((__nothrow__)) ;
#line 237
extern float ( __attribute__((__leaf__)) jnf32)(int  , float  )  __attribute__((__nothrow__)) ;
#line 237
extern float ( __attribute__((__leaf__)) __jnf32)(int  , float  )  __attribute__((__nothrow__)) ;
#line 238
extern float ( __attribute__((__leaf__)) y0f32)(float  )  __attribute__((__nothrow__)) ;
#line 238
extern float ( __attribute__((__leaf__)) __y0f32)(float  )  __attribute__((__nothrow__)) ;
#line 239
extern float ( __attribute__((__leaf__)) y1f32)(float  )  __attribute__((__nothrow__)) ;
#line 239
extern float ( __attribute__((__leaf__)) __y1f32)(float  )  __attribute__((__nothrow__)) ;
#line 240
extern float ( __attribute__((__leaf__)) ynf32)(int  , float  )  __attribute__((__nothrow__)) ;
#line 240
extern float ( __attribute__((__leaf__)) __ynf32)(int  , float  )  __attribute__((__nothrow__)) ;
#line 246
extern float ( __attribute__((__leaf__)) erff32)(float  )  __attribute__((__nothrow__)) ;
#line 246
extern float ( __attribute__((__leaf__)) __erff32)(float  )  __attribute__((__nothrow__)) ;
#line 247
extern float ( __attribute__((__leaf__)) erfcf32)(float  )  __attribute__((__nothrow__)) ;
#line 247
extern float ( __attribute__((__leaf__)) __erfcf32)(float  )  __attribute__((__nothrow__)) ;
#line 248
extern float ( __attribute__((__leaf__)) lgammaf32)(float  )  __attribute__((__nothrow__)) ;
#line 248
extern float ( __attribute__((__leaf__)) __lgammaf32)(float  )  __attribute__((__nothrow__)) ;
#line 253
extern float ( __attribute__((__leaf__)) tgammaf32)(float  )  __attribute__((__nothrow__)) ;
#line 253
extern float ( __attribute__((__leaf__)) __tgammaf32)(float  )  __attribute__((__nothrow__)) ;
#line 267
extern float ( __attribute__((__leaf__)) lgammaf32_r)(float  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 267
extern float ( __attribute__((__leaf__)) __lgammaf32_r)(float  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 274
extern float ( __attribute__((__leaf__)) rintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 274
extern float ( __attribute__((__leaf__)) __rintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 277
extern float ( __attribute__((__leaf__)) nextafterf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 277
extern float ( __attribute__((__leaf__)) __nextafterf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 284
extern float ( __attribute__((__leaf__)) nextdownf32)(float __x )  __attribute__((__nothrow__)) ;
#line 284
extern float ( __attribute__((__leaf__)) __nextdownf32)(float __x )  __attribute__((__nothrow__)) ;
#line 286
extern float ( __attribute__((__leaf__)) nextupf32)(float __x )  __attribute__((__nothrow__)) ;
#line 286
extern float ( __attribute__((__leaf__)) __nextupf32)(float __x )  __attribute__((__nothrow__)) ;
#line 290
extern float ( __attribute__((__leaf__)) remainderf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 290
extern float ( __attribute__((__leaf__)) __remainderf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 294
extern float ( __attribute__((__leaf__)) scalbnf32)(float __x , int __n )  __attribute__((__nothrow__)) ;
#line 294
extern float ( __attribute__((__leaf__)) __scalbnf32)(float __x , int __n )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) ilogbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) __ilogbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) llogbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) __llogbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 308
extern float ( __attribute__((__leaf__)) scalblnf32)(float __x , long __n )  __attribute__((__nothrow__)) ;
#line 308
extern float ( __attribute__((__leaf__)) __scalblnf32)(float __x , long __n )  __attribute__((__nothrow__)) ;
#line 312
extern float ( __attribute__((__leaf__)) nearbyintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 312
extern float ( __attribute__((__leaf__)) __nearbyintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 316
extern float ( __attribute__((__leaf__)) roundf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 316
extern float ( __attribute__((__leaf__)) __roundf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern float ( __attribute__((__leaf__)) truncf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern float ( __attribute__((__leaf__)) __truncf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 325
extern float ( __attribute__((__leaf__)) remquof32)(float __x , float __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 325
extern float ( __attribute__((__leaf__)) __remquof32)(float __x , float __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) lrintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) __lrintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) llrintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) __llrintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) lroundf32)(float __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) __lroundf32)(float __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) llroundf32)(float __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) __llroundf32)(float __x )  __attribute__((__nothrow__)) ;
#line 344
extern float ( __attribute__((__leaf__)) fdimf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 344
extern float ( __attribute__((__leaf__)) __fdimf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 348
extern float ( __attribute__((__leaf__)) fmaxf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 348
extern float ( __attribute__((__leaf__)) __fmaxf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern float ( __attribute__((__leaf__)) fminf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern float ( __attribute__((__leaf__)) __fminf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 355
extern float ( __attribute__((__leaf__)) fmaf32)(float __x , float __y , float __z )  __attribute__((__nothrow__)) ;
#line 355
extern float ( __attribute__((__leaf__)) __fmaf32)(float __x , float __y , float __z )  __attribute__((__nothrow__)) ;
#line 360
extern float ( __attribute__((__leaf__)) roundevenf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 360
extern float ( __attribute__((__leaf__)) __roundevenf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) fromfpf32)(float __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf32)(float __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf32)(float __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf32)(float __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf32)(float __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf32)(float __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf32)(float __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf32)(float __x , int __round ,
                                                              unsigned int __width )  __attribute__((__nothrow__)) ;
#line 385
extern int ( __attribute__((__leaf__)) canonicalizef32)(float *__cx , float const   *__x )  __attribute__((__nothrow__)) ;
#line 392
extern float ( __attribute__((__leaf__)) fmaxmagf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 392
extern float ( __attribute__((__leaf__)) __fmaxmagf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern float ( __attribute__((__leaf__)) fminmagf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern float ( __attribute__((__leaf__)) __fminmagf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern float ( __attribute__((__leaf__)) fmaximumf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern float ( __attribute__((__leaf__)) __fmaximumf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern float ( __attribute__((__leaf__)) fminimumf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern float ( __attribute__((__leaf__)) __fminimumf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern float ( __attribute__((__leaf__)) fmaximum_numf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern float ( __attribute__((__leaf__)) __fmaximum_numf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern float ( __attribute__((__leaf__)) fminimum_numf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern float ( __attribute__((__leaf__)) __fminimum_numf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern float ( __attribute__((__leaf__)) fmaximum_magf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern float ( __attribute__((__leaf__)) __fmaximum_magf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern float ( __attribute__((__leaf__)) fminimum_magf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern float ( __attribute__((__leaf__)) __fminimum_magf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern float ( __attribute__((__leaf__)) fmaximum_mag_numf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern float ( __attribute__((__leaf__)) __fmaximum_mag_numf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern float ( __attribute__((__leaf__)) fminimum_mag_numf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern float ( __attribute__((__leaf__)) __fminimum_mag_numf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 426
extern int ( __attribute__((__leaf__)) totalorderf32)(float const   *__x , float const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 431
extern int ( __attribute__((__leaf__)) totalordermagf32)(float const   *__x , float const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 436
extern float ( __attribute__((__leaf__)) getpayloadf32)(float const   *__x )  __attribute__((__nothrow__)) ;
#line 436
extern float ( __attribute__((__leaf__)) __getpayloadf32)(float const   *__x )  __attribute__((__nothrow__)) ;
#line 439
extern int ( __attribute__((__leaf__)) setpayloadf32)(float *__x , float __payload )  __attribute__((__nothrow__)) ;
#line 442
extern int ( __attribute__((__leaf__)) setpayloadsigf32)(float *__x , float __payload )  __attribute__((__nothrow__)) ;
#line 53
extern double ( __attribute__((__leaf__)) acosf64)(double __x )  __attribute__((__nothrow__)) ;
#line 53
extern double ( __attribute__((__leaf__)) __acosf64)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) asinf64)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) __asinf64)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) atanf64)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) __atanf64)(double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) atan2f64)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) __atan2f64)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) cosf64)(double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) __cosf64)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) sinf64)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) __sinf64)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) tanf64)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) __tanf64)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) coshf64)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) __coshf64)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) sinhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) __sinhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) tanhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) __tanhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf64)(double __x , double *__sinx , double *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf64)(double __x , double *__sinx ,
                                                     double *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) acoshf64)(double __x )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) __acoshf64)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) asinhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) __asinhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) atanhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) __atanhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) expf64)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) __expf64)(double __x )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) frexpf64)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) __frexpf64)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) ldexpf64)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) __ldexpf64)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) logf64)(double __x )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) __logf64)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) log10f64)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) __log10f64)(double __x )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__leaf__)) modff64)(double __x , double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__nonnull__(2), __leaf__)) __modff64)(double __x ,
                                                                     double *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) exp10f64)(double __x )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) __exp10f64)(double __x )  __attribute__((__nothrow__)) ;
#line 117
extern double ( __attribute__((__leaf__)) exp2m1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 117
extern double ( __attribute__((__leaf__)) __exp2m1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 120
extern double ( __attribute__((__leaf__)) exp10m1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 120
extern double ( __attribute__((__leaf__)) __exp10m1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 123
extern double ( __attribute__((__leaf__)) log2p1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 123
extern double ( __attribute__((__leaf__)) __log2p1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 126
extern double ( __attribute__((__leaf__)) log10p1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 126
extern double ( __attribute__((__leaf__)) __log10p1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 129
extern double ( __attribute__((__leaf__)) logp1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 129
extern double ( __attribute__((__leaf__)) __logp1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 134
extern double ( __attribute__((__leaf__)) expm1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 134
extern double ( __attribute__((__leaf__)) __expm1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 137
extern double ( __attribute__((__leaf__)) log1pf64)(double __x )  __attribute__((__nothrow__)) ;
#line 137
extern double ( __attribute__((__leaf__)) __log1pf64)(double __x )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) logbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) __logbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 145
extern double ( __attribute__((__leaf__)) exp2f64)(double __x )  __attribute__((__nothrow__)) ;
#line 145
extern double ( __attribute__((__leaf__)) __exp2f64)(double __x )  __attribute__((__nothrow__)) ;
#line 148
extern double ( __attribute__((__leaf__)) log2f64)(double __x )  __attribute__((__nothrow__)) ;
#line 148
extern double ( __attribute__((__leaf__)) __log2f64)(double __x )  __attribute__((__nothrow__)) ;
#line 155
extern double ( __attribute__((__leaf__)) powf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 155
extern double ( __attribute__((__leaf__)) __powf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 158
extern double ( __attribute__((__leaf__)) sqrtf64)(double __x )  __attribute__((__nothrow__)) ;
#line 158
extern double ( __attribute__((__leaf__)) __sqrtf64)(double __x )  __attribute__((__nothrow__)) ;
#line 162
extern double ( __attribute__((__leaf__)) hypotf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 162
extern double ( __attribute__((__leaf__)) __hypotf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 167
extern double ( __attribute__((__leaf__)) cbrtf64)(double __x )  __attribute__((__nothrow__)) ;
#line 167
extern double ( __attribute__((__leaf__)) __cbrtf64)(double __x )  __attribute__((__nothrow__)) ;
#line 174
extern double ( __attribute__((__leaf__)) ceilf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 174
extern double ( __attribute__((__leaf__)) __ceilf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern double ( __attribute__((__leaf__)) fabsf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern double ( __attribute__((__leaf__)) __fabsf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern double ( __attribute__((__leaf__)) floorf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern double ( __attribute__((__leaf__)) __floorf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 183
extern double ( __attribute__((__leaf__)) fmodf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 183
extern double ( __attribute__((__leaf__)) __fmodf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 213
extern double ( __attribute__((__leaf__)) copysignf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 213
extern double ( __attribute__((__leaf__)) __copysignf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 218
extern double ( __attribute__((__leaf__)) nanf64)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 218
extern double ( __attribute__((__leaf__)) __nanf64)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) j0f64)(double  )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) __j0f64)(double  )  __attribute__((__nothrow__)) ;
#line 236
extern double ( __attribute__((__leaf__)) j1f64)(double  )  __attribute__((__nothrow__)) ;
#line 236
extern double ( __attribute__((__leaf__)) __j1f64)(double  )  __attribute__((__nothrow__)) ;
#line 237
extern double ( __attribute__((__leaf__)) jnf64)(int  , double  )  __attribute__((__nothrow__)) ;
#line 237
extern double ( __attribute__((__leaf__)) __jnf64)(int  , double  )  __attribute__((__nothrow__)) ;
#line 238
extern double ( __attribute__((__leaf__)) y0f64)(double  )  __attribute__((__nothrow__)) ;
#line 238
extern double ( __attribute__((__leaf__)) __y0f64)(double  )  __attribute__((__nothrow__)) ;
#line 239
extern double ( __attribute__((__leaf__)) y1f64)(double  )  __attribute__((__nothrow__)) ;
#line 239
extern double ( __attribute__((__leaf__)) __y1f64)(double  )  __attribute__((__nothrow__)) ;
#line 240
extern double ( __attribute__((__leaf__)) ynf64)(int  , double  )  __attribute__((__nothrow__)) ;
#line 240
extern double ( __attribute__((__leaf__)) __ynf64)(int  , double  )  __attribute__((__nothrow__)) ;
#line 246
extern double ( __attribute__((__leaf__)) erff64)(double  )  __attribute__((__nothrow__)) ;
#line 246
extern double ( __attribute__((__leaf__)) __erff64)(double  )  __attribute__((__nothrow__)) ;
#line 247
extern double ( __attribute__((__leaf__)) erfcf64)(double  )  __attribute__((__nothrow__)) ;
#line 247
extern double ( __attribute__((__leaf__)) __erfcf64)(double  )  __attribute__((__nothrow__)) ;
#line 248
extern double ( __attribute__((__leaf__)) lgammaf64)(double  )  __attribute__((__nothrow__)) ;
#line 248
extern double ( __attribute__((__leaf__)) __lgammaf64)(double  )  __attribute__((__nothrow__)) ;
#line 253
extern double ( __attribute__((__leaf__)) tgammaf64)(double  )  __attribute__((__nothrow__)) ;
#line 253
extern double ( __attribute__((__leaf__)) __tgammaf64)(double  )  __attribute__((__nothrow__)) ;
#line 267
extern double ( __attribute__((__leaf__)) lgammaf64_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 267
extern double ( __attribute__((__leaf__)) __lgammaf64_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 274
extern double ( __attribute__((__leaf__)) rintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 274
extern double ( __attribute__((__leaf__)) __rintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 277
extern double ( __attribute__((__leaf__)) nextafterf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 277
extern double ( __attribute__((__leaf__)) __nextafterf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 284
extern double ( __attribute__((__leaf__)) nextdownf64)(double __x )  __attribute__((__nothrow__)) ;
#line 284
extern double ( __attribute__((__leaf__)) __nextdownf64)(double __x )  __attribute__((__nothrow__)) ;
#line 286
extern double ( __attribute__((__leaf__)) nextupf64)(double __x )  __attribute__((__nothrow__)) ;
#line 286
extern double ( __attribute__((__leaf__)) __nextupf64)(double __x )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) remainderf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) __remainderf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) scalbnf64)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) __scalbnf64)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) ilogbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) __ilogbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) llogbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) __llogbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 308
extern double ( __attribute__((__leaf__)) scalblnf64)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 308
extern double ( __attribute__((__leaf__)) __scalblnf64)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 312
extern double ( __attribute__((__leaf__)) nearbyintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 312
extern double ( __attribute__((__leaf__)) __nearbyintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 316
extern double ( __attribute__((__leaf__)) roundf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 316
extern double ( __attribute__((__leaf__)) __roundf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern double ( __attribute__((__leaf__)) truncf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern double ( __attribute__((__leaf__)) __truncf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 325
extern double ( __attribute__((__leaf__)) remquof64)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 325
extern double ( __attribute__((__leaf__)) __remquof64)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) lrintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) __lrintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) llrintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) __llrintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) lroundf64)(double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) __lroundf64)(double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) llroundf64)(double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) __llroundf64)(double __x )  __attribute__((__nothrow__)) ;
#line 344
extern double ( __attribute__((__leaf__)) fdimf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 344
extern double ( __attribute__((__leaf__)) __fdimf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 348
extern double ( __attribute__((__leaf__)) fmaxf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 348
extern double ( __attribute__((__leaf__)) __fmaxf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern double ( __attribute__((__leaf__)) fminf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern double ( __attribute__((__leaf__)) __fminf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 355
extern double ( __attribute__((__leaf__)) fmaf64)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 355
extern double ( __attribute__((__leaf__)) __fmaf64)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 360
extern double ( __attribute__((__leaf__)) roundevenf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 360
extern double ( __attribute__((__leaf__)) __roundevenf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) fromfpf64)(double __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf64)(double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf64)(double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf64)(double __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf64)(double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf64)(double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf64)(double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf64)(double __x , int __round ,
                                                              unsigned int __width )  __attribute__((__nothrow__)) ;
#line 385
extern int ( __attribute__((__leaf__)) canonicalizef64)(double *__cx , double const   *__x )  __attribute__((__nothrow__)) ;
#line 392
extern double ( __attribute__((__leaf__)) fmaxmagf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 392
extern double ( __attribute__((__leaf__)) __fmaxmagf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern double ( __attribute__((__leaf__)) fminmagf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern double ( __attribute__((__leaf__)) __fminmagf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern double ( __attribute__((__leaf__)) fmaximumf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern double ( __attribute__((__leaf__)) __fmaximumf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern double ( __attribute__((__leaf__)) fminimumf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern double ( __attribute__((__leaf__)) __fminimumf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern double ( __attribute__((__leaf__)) fmaximum_numf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern double ( __attribute__((__leaf__)) __fmaximum_numf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern double ( __attribute__((__leaf__)) fminimum_numf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern double ( __attribute__((__leaf__)) __fminimum_numf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern double ( __attribute__((__leaf__)) fmaximum_magf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern double ( __attribute__((__leaf__)) __fmaximum_magf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern double ( __attribute__((__leaf__)) fminimum_magf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern double ( __attribute__((__leaf__)) __fminimum_magf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern double ( __attribute__((__leaf__)) fmaximum_mag_numf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern double ( __attribute__((__leaf__)) __fmaximum_mag_numf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern double ( __attribute__((__leaf__)) fminimum_mag_numf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern double ( __attribute__((__leaf__)) __fminimum_mag_numf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 426
extern int ( __attribute__((__leaf__)) totalorderf64)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 431
extern int ( __attribute__((__leaf__)) totalordermagf64)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 436
extern double ( __attribute__((__leaf__)) getpayloadf64)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 436
extern double ( __attribute__((__leaf__)) __getpayloadf64)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 439
extern int ( __attribute__((__leaf__)) setpayloadf64)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 442
extern int ( __attribute__((__leaf__)) setpayloadsigf64)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassifyf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 24
extern int ( __attribute__((__leaf__)) __signbitf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 29
extern int ( __attribute__((__leaf__)) __isinff128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finitef128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 37
extern int ( __attribute__((__leaf__)) __isnanf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 41
extern int ( __attribute__((__leaf__)) __iseqsigf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 44
extern int ( __attribute__((__leaf__)) __issignalingf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern _Float128 ( __attribute__((__leaf__)) acosf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 53
extern _Float128 ( __attribute__((__leaf__)) __acosf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 55
extern _Float128 ( __attribute__((__leaf__)) asinf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 55
extern _Float128 ( __attribute__((__leaf__)) __asinf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 57
extern _Float128 ( __attribute__((__leaf__)) atanf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 57
extern _Float128 ( __attribute__((__leaf__)) __atanf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 59
extern _Float128 ( __attribute__((__leaf__)) atan2f128)(_Float128 __y , _Float128 __x )  __attribute__((__nothrow__)) ;
#line 59
extern _Float128 ( __attribute__((__leaf__)) __atan2f128)(_Float128 __y , _Float128 __x )  __attribute__((__nothrow__)) ;
#line 62
extern _Float128 ( __attribute__((__leaf__)) cosf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 62
extern _Float128 ( __attribute__((__leaf__)) __cosf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 64
extern _Float128 ( __attribute__((__leaf__)) sinf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 64
extern _Float128 ( __attribute__((__leaf__)) __sinf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 66
extern _Float128 ( __attribute__((__leaf__)) tanf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 66
extern _Float128 ( __attribute__((__leaf__)) __tanf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 71
extern _Float128 ( __attribute__((__leaf__)) coshf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 71
extern _Float128 ( __attribute__((__leaf__)) __coshf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 73
extern _Float128 ( __attribute__((__leaf__)) sinhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 73
extern _Float128 ( __attribute__((__leaf__)) __sinhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 75
extern _Float128 ( __attribute__((__leaf__)) tanhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 75
extern _Float128 ( __attribute__((__leaf__)) __tanhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf128)(_Float128 __x , _Float128 *__sinx ,
                                                    _Float128 *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf128)(_Float128 __x , _Float128 *__sinx ,
                                                      _Float128 *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern _Float128 ( __attribute__((__leaf__)) acoshf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 85
extern _Float128 ( __attribute__((__leaf__)) __acoshf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 87
extern _Float128 ( __attribute__((__leaf__)) asinhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 87
extern _Float128 ( __attribute__((__leaf__)) __asinhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 89
extern _Float128 ( __attribute__((__leaf__)) atanhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 89
extern _Float128 ( __attribute__((__leaf__)) __atanhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 95
extern _Float128 ( __attribute__((__leaf__)) expf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 95
extern _Float128 ( __attribute__((__leaf__)) __expf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 98
extern _Float128 ( __attribute__((__leaf__)) frexpf128)(_Float128 __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern _Float128 ( __attribute__((__leaf__)) __frexpf128)(_Float128 __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern _Float128 ( __attribute__((__leaf__)) ldexpf128)(_Float128 __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern _Float128 ( __attribute__((__leaf__)) __ldexpf128)(_Float128 __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern _Float128 ( __attribute__((__leaf__)) logf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 104
extern _Float128 ( __attribute__((__leaf__)) __logf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 107
extern _Float128 ( __attribute__((__leaf__)) log10f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 107
extern _Float128 ( __attribute__((__leaf__)) __log10f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 110
extern _Float128 ( __attribute__((__leaf__)) modff128)(_Float128 __x , _Float128 *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern _Float128 ( __attribute__((__nonnull__(2), __leaf__)) __modff128)(_Float128 __x ,
                                                                         _Float128 *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern _Float128 ( __attribute__((__leaf__)) exp10f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 114
extern _Float128 ( __attribute__((__leaf__)) __exp10f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 117
extern _Float128 ( __attribute__((__leaf__)) exp2m1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 117
extern _Float128 ( __attribute__((__leaf__)) __exp2m1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 120
extern _Float128 ( __attribute__((__leaf__)) exp10m1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 120
extern _Float128 ( __attribute__((__leaf__)) __exp10m1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 123
extern _Float128 ( __attribute__((__leaf__)) log2p1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 123
extern _Float128 ( __attribute__((__leaf__)) __log2p1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 126
extern _Float128 ( __attribute__((__leaf__)) log10p1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 126
extern _Float128 ( __attribute__((__leaf__)) __log10p1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 129
extern _Float128 ( __attribute__((__leaf__)) logp1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 129
extern _Float128 ( __attribute__((__leaf__)) __logp1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 134
extern _Float128 ( __attribute__((__leaf__)) expm1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 134
extern _Float128 ( __attribute__((__leaf__)) __expm1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 137
extern _Float128 ( __attribute__((__leaf__)) log1pf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 137
extern _Float128 ( __attribute__((__leaf__)) __log1pf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 140
extern _Float128 ( __attribute__((__leaf__)) logbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 140
extern _Float128 ( __attribute__((__leaf__)) __logbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 145
extern _Float128 ( __attribute__((__leaf__)) exp2f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 145
extern _Float128 ( __attribute__((__leaf__)) __exp2f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 148
extern _Float128 ( __attribute__((__leaf__)) log2f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 148
extern _Float128 ( __attribute__((__leaf__)) __log2f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 155
extern _Float128 ( __attribute__((__leaf__)) powf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 155
extern _Float128 ( __attribute__((__leaf__)) __powf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 158
extern _Float128 ( __attribute__((__leaf__)) sqrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 158
extern _Float128 ( __attribute__((__leaf__)) __sqrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 162
extern _Float128 ( __attribute__((__leaf__)) hypotf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 162
extern _Float128 ( __attribute__((__leaf__)) __hypotf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 167
extern _Float128 ( __attribute__((__leaf__)) cbrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 167
extern _Float128 ( __attribute__((__leaf__)) __cbrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 174
extern _Float128 ( __attribute__((__leaf__)) ceilf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 174
extern _Float128 ( __attribute__((__leaf__)) __ceilf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern _Float128 ( __attribute__((__leaf__)) fabsf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern _Float128 ( __attribute__((__leaf__)) __fabsf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern _Float128 ( __attribute__((__leaf__)) floorf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern _Float128 ( __attribute__((__leaf__)) __floorf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 183
extern _Float128 ( __attribute__((__leaf__)) fmodf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 183
extern _Float128 ( __attribute__((__leaf__)) __fmodf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 213
extern _Float128 ( __attribute__((__leaf__)) copysignf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 213
extern _Float128 ( __attribute__((__leaf__)) __copysignf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 218
extern _Float128 ( __attribute__((__leaf__)) nanf128)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 218
extern _Float128 ( __attribute__((__leaf__)) __nanf128)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 235
extern _Float128 ( __attribute__((__leaf__)) j0f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 235
extern _Float128 ( __attribute__((__leaf__)) __j0f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 236
extern _Float128 ( __attribute__((__leaf__)) j1f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 236
extern _Float128 ( __attribute__((__leaf__)) __j1f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 237
extern _Float128 ( __attribute__((__leaf__)) jnf128)(int  , _Float128  )  __attribute__((__nothrow__)) ;
#line 237
extern _Float128 ( __attribute__((__leaf__)) __jnf128)(int  , _Float128  )  __attribute__((__nothrow__)) ;
#line 238
extern _Float128 ( __attribute__((__leaf__)) y0f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 238
extern _Float128 ( __attribute__((__leaf__)) __y0f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 239
extern _Float128 ( __attribute__((__leaf__)) y1f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 239
extern _Float128 ( __attribute__((__leaf__)) __y1f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 240
extern _Float128 ( __attribute__((__leaf__)) ynf128)(int  , _Float128  )  __attribute__((__nothrow__)) ;
#line 240
extern _Float128 ( __attribute__((__leaf__)) __ynf128)(int  , _Float128  )  __attribute__((__nothrow__)) ;
#line 246
extern _Float128 ( __attribute__((__leaf__)) erff128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 246
extern _Float128 ( __attribute__((__leaf__)) __erff128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 247
extern _Float128 ( __attribute__((__leaf__)) erfcf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 247
extern _Float128 ( __attribute__((__leaf__)) __erfcf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 248
extern _Float128 ( __attribute__((__leaf__)) lgammaf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 248
extern _Float128 ( __attribute__((__leaf__)) __lgammaf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 253
extern _Float128 ( __attribute__((__leaf__)) tgammaf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 253
extern _Float128 ( __attribute__((__leaf__)) __tgammaf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 267
extern _Float128 ( __attribute__((__leaf__)) lgammaf128_r)(_Float128  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 267
extern _Float128 ( __attribute__((__leaf__)) __lgammaf128_r)(_Float128  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 274
extern _Float128 ( __attribute__((__leaf__)) rintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 274
extern _Float128 ( __attribute__((__leaf__)) __rintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 277
extern _Float128 ( __attribute__((__leaf__)) nextafterf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 277
extern _Float128 ( __attribute__((__leaf__)) __nextafterf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 284
extern _Float128 ( __attribute__((__leaf__)) nextdownf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 284
extern _Float128 ( __attribute__((__leaf__)) __nextdownf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 286
extern _Float128 ( __attribute__((__leaf__)) nextupf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 286
extern _Float128 ( __attribute__((__leaf__)) __nextupf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 290
extern _Float128 ( __attribute__((__leaf__)) remainderf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 290
extern _Float128 ( __attribute__((__leaf__)) __remainderf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 294
extern _Float128 ( __attribute__((__leaf__)) scalbnf128)(_Float128 __x , int __n )  __attribute__((__nothrow__)) ;
#line 294
extern _Float128 ( __attribute__((__leaf__)) __scalbnf128)(_Float128 __x , int __n )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) ilogbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) __ilogbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) llogbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) __llogbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 308
extern _Float128 ( __attribute__((__leaf__)) scalblnf128)(_Float128 __x , long __n )  __attribute__((__nothrow__)) ;
#line 308
extern _Float128 ( __attribute__((__leaf__)) __scalblnf128)(_Float128 __x , long __n )  __attribute__((__nothrow__)) ;
#line 312
extern _Float128 ( __attribute__((__leaf__)) nearbyintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 312
extern _Float128 ( __attribute__((__leaf__)) __nearbyintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 316
extern _Float128 ( __attribute__((__leaf__)) roundf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 316
extern _Float128 ( __attribute__((__leaf__)) __roundf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern _Float128 ( __attribute__((__leaf__)) truncf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern _Float128 ( __attribute__((__leaf__)) __truncf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 325
extern _Float128 ( __attribute__((__leaf__)) remquof128)(_Float128 __x , _Float128 __y ,
                                                         int *__quo )  __attribute__((__nothrow__)) ;
#line 325
extern _Float128 ( __attribute__((__leaf__)) __remquof128)(_Float128 __x , _Float128 __y ,
                                                           int *__quo )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) lrintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) __lrintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) llrintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) __llrintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) lroundf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) __lroundf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) llroundf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) __llroundf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 344
extern _Float128 ( __attribute__((__leaf__)) fdimf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 344
extern _Float128 ( __attribute__((__leaf__)) __fdimf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 348
extern _Float128 ( __attribute__((__leaf__)) fmaxf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 348
extern _Float128 ( __attribute__((__leaf__)) __fmaxf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern _Float128 ( __attribute__((__leaf__)) fminf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern _Float128 ( __attribute__((__leaf__)) __fminf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 355
extern _Float128 ( __attribute__((__leaf__)) fmaf128)(_Float128 __x , _Float128 __y ,
                                                      _Float128 __z )  __attribute__((__nothrow__)) ;
#line 355
extern _Float128 ( __attribute__((__leaf__)) __fmaf128)(_Float128 __x , _Float128 __y ,
                                                        _Float128 __z )  __attribute__((__nothrow__)) ;
#line 360
extern _Float128 ( __attribute__((__leaf__)) roundevenf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 360
extern _Float128 ( __attribute__((__leaf__)) __roundevenf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) fromfpf128)(_Float128 __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf128)(_Float128 __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf128)(_Float128 __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf128)(_Float128 __x , int __round ,
                                                              unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf128)(_Float128 __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf128)(_Float128 __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf128)(_Float128 __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf128)(_Float128 __x , int __round ,
                                                               unsigned int __width )  __attribute__((__nothrow__)) ;
#line 385
extern int ( __attribute__((__leaf__)) canonicalizef128)(_Float128 *__cx , _Float128 const   *__x )  __attribute__((__nothrow__)) ;
#line 392
extern _Float128 ( __attribute__((__leaf__)) fmaxmagf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 392
extern _Float128 ( __attribute__((__leaf__)) __fmaxmagf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern _Float128 ( __attribute__((__leaf__)) fminmagf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern _Float128 ( __attribute__((__leaf__)) __fminmagf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern _Float128 ( __attribute__((__leaf__)) fmaximumf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern _Float128 ( __attribute__((__leaf__)) __fmaximumf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern _Float128 ( __attribute__((__leaf__)) fminimumf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern _Float128 ( __attribute__((__leaf__)) __fminimumf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern _Float128 ( __attribute__((__leaf__)) fmaximum_numf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern _Float128 ( __attribute__((__leaf__)) __fmaximum_numf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern _Float128 ( __attribute__((__leaf__)) fminimum_numf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern _Float128 ( __attribute__((__leaf__)) __fminimum_numf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern _Float128 ( __attribute__((__leaf__)) fmaximum_magf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern _Float128 ( __attribute__((__leaf__)) __fmaximum_magf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern _Float128 ( __attribute__((__leaf__)) fminimum_magf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern _Float128 ( __attribute__((__leaf__)) __fminimum_magf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern _Float128 ( __attribute__((__leaf__)) fmaximum_mag_numf128)(_Float128 __x ,
                                                                   _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern _Float128 ( __attribute__((__leaf__)) __fmaximum_mag_numf128)(_Float128 __x ,
                                                                     _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern _Float128 ( __attribute__((__leaf__)) fminimum_mag_numf128)(_Float128 __x ,
                                                                   _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern _Float128 ( __attribute__((__leaf__)) __fminimum_mag_numf128)(_Float128 __x ,
                                                                     _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 426
extern int ( __attribute__((__leaf__)) totalorderf128)(_Float128 const   *__x , _Float128 const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 431
extern int ( __attribute__((__leaf__)) totalordermagf128)(_Float128 const   *__x ,
                                                          _Float128 const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 436
extern _Float128 ( __attribute__((__leaf__)) getpayloadf128)(_Float128 const   *__x )  __attribute__((__nothrow__)) ;
#line 436
extern _Float128 ( __attribute__((__leaf__)) __getpayloadf128)(_Float128 const   *__x )  __attribute__((__nothrow__)) ;
#line 439
extern int ( __attribute__((__leaf__)) setpayloadf128)(_Float128 *__x , _Float128 __payload )  __attribute__((__nothrow__)) ;
#line 442
extern int ( __attribute__((__leaf__)) setpayloadsigf128)(_Float128 *__x , _Float128 __payload )  __attribute__((__nothrow__)) ;
#line 53
extern double ( __attribute__((__leaf__)) acosf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 53
extern double ( __attribute__((__leaf__)) __acosf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) asinf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) __asinf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) atanf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) __atanf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) atan2f32x)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) __atan2f32x)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) cosf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) __cosf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) sinf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) __sinf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) tanf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) __tanf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) coshf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) __coshf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) sinhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) __sinhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) tanhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) __tanhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf32x)(double __x , double *__sinx ,
                                                    double *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf32x)(double __x , double *__sinx ,
                                                      double *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) acoshf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) __acoshf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) asinhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) __asinhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) atanhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) __atanhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) expf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) __expf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) frexpf32x)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) __frexpf32x)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) ldexpf32x)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) __ldexpf32x)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) logf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) __logf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) log10f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) __log10f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__leaf__)) modff32x)(double __x , double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__nonnull__(2), __leaf__)) __modff32x)(double __x ,
                                                                      double *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) exp10f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) __exp10f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 117
extern double ( __attribute__((__leaf__)) exp2m1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 117
extern double ( __attribute__((__leaf__)) __exp2m1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 120
extern double ( __attribute__((__leaf__)) exp10m1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 120
extern double ( __attribute__((__leaf__)) __exp10m1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 123
extern double ( __attribute__((__leaf__)) log2p1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 123
extern double ( __attribute__((__leaf__)) __log2p1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 126
extern double ( __attribute__((__leaf__)) log10p1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 126
extern double ( __attribute__((__leaf__)) __log10p1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 129
extern double ( __attribute__((__leaf__)) logp1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 129
extern double ( __attribute__((__leaf__)) __logp1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 134
extern double ( __attribute__((__leaf__)) expm1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 134
extern double ( __attribute__((__leaf__)) __expm1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 137
extern double ( __attribute__((__leaf__)) log1pf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 137
extern double ( __attribute__((__leaf__)) __log1pf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) logbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) __logbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 145
extern double ( __attribute__((__leaf__)) exp2f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 145
extern double ( __attribute__((__leaf__)) __exp2f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 148
extern double ( __attribute__((__leaf__)) log2f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 148
extern double ( __attribute__((__leaf__)) __log2f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 155
extern double ( __attribute__((__leaf__)) powf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 155
extern double ( __attribute__((__leaf__)) __powf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 158
extern double ( __attribute__((__leaf__)) sqrtf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 158
extern double ( __attribute__((__leaf__)) __sqrtf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 162
extern double ( __attribute__((__leaf__)) hypotf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 162
extern double ( __attribute__((__leaf__)) __hypotf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 167
extern double ( __attribute__((__leaf__)) cbrtf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 167
extern double ( __attribute__((__leaf__)) __cbrtf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 174
extern double ( __attribute__((__leaf__)) ceilf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 174
extern double ( __attribute__((__leaf__)) __ceilf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern double ( __attribute__((__leaf__)) fabsf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern double ( __attribute__((__leaf__)) __fabsf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern double ( __attribute__((__leaf__)) floorf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern double ( __attribute__((__leaf__)) __floorf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 183
extern double ( __attribute__((__leaf__)) fmodf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 183
extern double ( __attribute__((__leaf__)) __fmodf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 213
extern double ( __attribute__((__leaf__)) copysignf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 213
extern double ( __attribute__((__leaf__)) __copysignf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 218
extern double ( __attribute__((__leaf__)) nanf32x)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 218
extern double ( __attribute__((__leaf__)) __nanf32x)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) j0f32x)(double  )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) __j0f32x)(double  )  __attribute__((__nothrow__)) ;
#line 236
extern double ( __attribute__((__leaf__)) j1f32x)(double  )  __attribute__((__nothrow__)) ;
#line 236
extern double ( __attribute__((__leaf__)) __j1f32x)(double  )  __attribute__((__nothrow__)) ;
#line 237
extern double ( __attribute__((__leaf__)) jnf32x)(int  , double  )  __attribute__((__nothrow__)) ;
#line 237
extern double ( __attribute__((__leaf__)) __jnf32x)(int  , double  )  __attribute__((__nothrow__)) ;
#line 238
extern double ( __attribute__((__leaf__)) y0f32x)(double  )  __attribute__((__nothrow__)) ;
#line 238
extern double ( __attribute__((__leaf__)) __y0f32x)(double  )  __attribute__((__nothrow__)) ;
#line 239
extern double ( __attribute__((__leaf__)) y1f32x)(double  )  __attribute__((__nothrow__)) ;
#line 239
extern double ( __attribute__((__leaf__)) __y1f32x)(double  )  __attribute__((__nothrow__)) ;
#line 240
extern double ( __attribute__((__leaf__)) ynf32x)(int  , double  )  __attribute__((__nothrow__)) ;
#line 240
extern double ( __attribute__((__leaf__)) __ynf32x)(int  , double  )  __attribute__((__nothrow__)) ;
#line 246
extern double ( __attribute__((__leaf__)) erff32x)(double  )  __attribute__((__nothrow__)) ;
#line 246
extern double ( __attribute__((__leaf__)) __erff32x)(double  )  __attribute__((__nothrow__)) ;
#line 247
extern double ( __attribute__((__leaf__)) erfcf32x)(double  )  __attribute__((__nothrow__)) ;
#line 247
extern double ( __attribute__((__leaf__)) __erfcf32x)(double  )  __attribute__((__nothrow__)) ;
#line 248
extern double ( __attribute__((__leaf__)) lgammaf32x)(double  )  __attribute__((__nothrow__)) ;
#line 248
extern double ( __attribute__((__leaf__)) __lgammaf32x)(double  )  __attribute__((__nothrow__)) ;
#line 253
extern double ( __attribute__((__leaf__)) tgammaf32x)(double  )  __attribute__((__nothrow__)) ;
#line 253
extern double ( __attribute__((__leaf__)) __tgammaf32x)(double  )  __attribute__((__nothrow__)) ;
#line 267
extern double ( __attribute__((__leaf__)) lgammaf32x_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 267
extern double ( __attribute__((__leaf__)) __lgammaf32x_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 274
extern double ( __attribute__((__leaf__)) rintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 274
extern double ( __attribute__((__leaf__)) __rintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 277
extern double ( __attribute__((__leaf__)) nextafterf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 277
extern double ( __attribute__((__leaf__)) __nextafterf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 284
extern double ( __attribute__((__leaf__)) nextdownf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 284
extern double ( __attribute__((__leaf__)) __nextdownf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 286
extern double ( __attribute__((__leaf__)) nextupf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 286
extern double ( __attribute__((__leaf__)) __nextupf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) remainderf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) __remainderf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) scalbnf32x)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) __scalbnf32x)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) ilogbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) __ilogbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) llogbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) __llogbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 308
extern double ( __attribute__((__leaf__)) scalblnf32x)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 308
extern double ( __attribute__((__leaf__)) __scalblnf32x)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 312
extern double ( __attribute__((__leaf__)) nearbyintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 312
extern double ( __attribute__((__leaf__)) __nearbyintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 316
extern double ( __attribute__((__leaf__)) roundf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 316
extern double ( __attribute__((__leaf__)) __roundf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern double ( __attribute__((__leaf__)) truncf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern double ( __attribute__((__leaf__)) __truncf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 325
extern double ( __attribute__((__leaf__)) remquof32x)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 325
extern double ( __attribute__((__leaf__)) __remquof32x)(double __x , double __y ,
                                                        int *__quo )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) lrintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) __lrintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) llrintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) __llrintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) lroundf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) __lroundf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) llroundf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) __llroundf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 344
extern double ( __attribute__((__leaf__)) fdimf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 344
extern double ( __attribute__((__leaf__)) __fdimf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 348
extern double ( __attribute__((__leaf__)) fmaxf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 348
extern double ( __attribute__((__leaf__)) __fmaxf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern double ( __attribute__((__leaf__)) fminf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern double ( __attribute__((__leaf__)) __fminf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 355
extern double ( __attribute__((__leaf__)) fmaf32x)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 355
extern double ( __attribute__((__leaf__)) __fmaf32x)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 360
extern double ( __attribute__((__leaf__)) roundevenf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 360
extern double ( __attribute__((__leaf__)) __roundevenf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) fromfpf32x)(double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf32x)(double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf32x)(double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf32x)(double __x , int __round ,
                                                              unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf32x)(double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf32x)(double __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf32x)(double __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf32x)(double __x , int __round ,
                                                               unsigned int __width )  __attribute__((__nothrow__)) ;
#line 385
extern int ( __attribute__((__leaf__)) canonicalizef32x)(double *__cx , double const   *__x )  __attribute__((__nothrow__)) ;
#line 392
extern double ( __attribute__((__leaf__)) fmaxmagf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 392
extern double ( __attribute__((__leaf__)) __fmaxmagf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern double ( __attribute__((__leaf__)) fminmagf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern double ( __attribute__((__leaf__)) __fminmagf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern double ( __attribute__((__leaf__)) fmaximumf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern double ( __attribute__((__leaf__)) __fmaximumf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern double ( __attribute__((__leaf__)) fminimumf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern double ( __attribute__((__leaf__)) __fminimumf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern double ( __attribute__((__leaf__)) fmaximum_numf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern double ( __attribute__((__leaf__)) __fmaximum_numf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern double ( __attribute__((__leaf__)) fminimum_numf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern double ( __attribute__((__leaf__)) __fminimum_numf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern double ( __attribute__((__leaf__)) fmaximum_magf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern double ( __attribute__((__leaf__)) __fmaximum_magf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern double ( __attribute__((__leaf__)) fminimum_magf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern double ( __attribute__((__leaf__)) __fminimum_magf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern double ( __attribute__((__leaf__)) fmaximum_mag_numf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern double ( __attribute__((__leaf__)) __fmaximum_mag_numf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern double ( __attribute__((__leaf__)) fminimum_mag_numf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern double ( __attribute__((__leaf__)) __fminimum_mag_numf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 426
extern int ( __attribute__((__leaf__)) totalorderf32x)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 431
extern int ( __attribute__((__leaf__)) totalordermagf32x)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 436
extern double ( __attribute__((__leaf__)) getpayloadf32x)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 436
extern double ( __attribute__((__leaf__)) __getpayloadf32x)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 439
extern int ( __attribute__((__leaf__)) setpayloadf32x)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 442
extern int ( __attribute__((__leaf__)) setpayloadsigf32x)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 53
extern long double ( __attribute__((__leaf__)) acosf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 53
extern long double ( __attribute__((__leaf__)) __acosf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 55
extern long double ( __attribute__((__leaf__)) asinf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 55
extern long double ( __attribute__((__leaf__)) __asinf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 57
extern long double ( __attribute__((__leaf__)) atanf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 57
extern long double ( __attribute__((__leaf__)) __atanf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 59
extern long double ( __attribute__((__leaf__)) atan2f64x)(long double __y , long double __x )  __attribute__((__nothrow__)) ;
#line 59
extern long double ( __attribute__((__leaf__)) __atan2f64x)(long double __y , long double __x )  __attribute__((__nothrow__)) ;
#line 62
extern long double ( __attribute__((__leaf__)) cosf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 62
extern long double ( __attribute__((__leaf__)) __cosf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 64
extern long double ( __attribute__((__leaf__)) sinf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 64
extern long double ( __attribute__((__leaf__)) __sinf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 66
extern long double ( __attribute__((__leaf__)) tanf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 66
extern long double ( __attribute__((__leaf__)) __tanf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 71
extern long double ( __attribute__((__leaf__)) coshf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 71
extern long double ( __attribute__((__leaf__)) __coshf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 73
extern long double ( __attribute__((__leaf__)) sinhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 73
extern long double ( __attribute__((__leaf__)) __sinhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 75
extern long double ( __attribute__((__leaf__)) tanhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 75
extern long double ( __attribute__((__leaf__)) __tanhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf64x)(long double __x , long double *__sinx ,
                                                    long double *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf64x)(long double __x , long double *__sinx ,
                                                      long double *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern long double ( __attribute__((__leaf__)) acoshf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 85
extern long double ( __attribute__((__leaf__)) __acoshf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 87
extern long double ( __attribute__((__leaf__)) asinhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 87
extern long double ( __attribute__((__leaf__)) __asinhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 89
extern long double ( __attribute__((__leaf__)) atanhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 89
extern long double ( __attribute__((__leaf__)) __atanhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 95
extern long double ( __attribute__((__leaf__)) expf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 95
extern long double ( __attribute__((__leaf__)) __expf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 98
extern long double ( __attribute__((__leaf__)) frexpf64x)(long double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern long double ( __attribute__((__leaf__)) __frexpf64x)(long double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern long double ( __attribute__((__leaf__)) ldexpf64x)(long double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern long double ( __attribute__((__leaf__)) __ldexpf64x)(long double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern long double ( __attribute__((__leaf__)) logf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 104
extern long double ( __attribute__((__leaf__)) __logf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 107
extern long double ( __attribute__((__leaf__)) log10f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 107
extern long double ( __attribute__((__leaf__)) __log10f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 110
extern long double ( __attribute__((__leaf__)) modff64x)(long double __x , long double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern long double ( __attribute__((__nonnull__(2), __leaf__)) __modff64x)(long double __x ,
                                                                           long double *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern long double ( __attribute__((__leaf__)) exp10f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 114
extern long double ( __attribute__((__leaf__)) __exp10f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 117
extern long double ( __attribute__((__leaf__)) exp2m1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 117
extern long double ( __attribute__((__leaf__)) __exp2m1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 120
extern long double ( __attribute__((__leaf__)) exp10m1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 120
extern long double ( __attribute__((__leaf__)) __exp10m1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 123
extern long double ( __attribute__((__leaf__)) log2p1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 123
extern long double ( __attribute__((__leaf__)) __log2p1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 126
extern long double ( __attribute__((__leaf__)) log10p1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 126
extern long double ( __attribute__((__leaf__)) __log10p1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 129
extern long double ( __attribute__((__leaf__)) logp1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 129
extern long double ( __attribute__((__leaf__)) __logp1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 134
extern long double ( __attribute__((__leaf__)) expm1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 134
extern long double ( __attribute__((__leaf__)) __expm1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 137
extern long double ( __attribute__((__leaf__)) log1pf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 137
extern long double ( __attribute__((__leaf__)) __log1pf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 140
extern long double ( __attribute__((__leaf__)) logbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 140
extern long double ( __attribute__((__leaf__)) __logbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 145
extern long double ( __attribute__((__leaf__)) exp2f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 145
extern long double ( __attribute__((__leaf__)) __exp2f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 148
extern long double ( __attribute__((__leaf__)) log2f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 148
extern long double ( __attribute__((__leaf__)) __log2f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 155
extern long double ( __attribute__((__leaf__)) powf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 155
extern long double ( __attribute__((__leaf__)) __powf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 158
extern long double ( __attribute__((__leaf__)) sqrtf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 158
extern long double ( __attribute__((__leaf__)) __sqrtf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 162
extern long double ( __attribute__((__leaf__)) hypotf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 162
extern long double ( __attribute__((__leaf__)) __hypotf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 167
extern long double ( __attribute__((__leaf__)) cbrtf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 167
extern long double ( __attribute__((__leaf__)) __cbrtf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 174
extern long double ( __attribute__((__leaf__)) ceilf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 174
extern long double ( __attribute__((__leaf__)) __ceilf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern long double ( __attribute__((__leaf__)) fabsf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern long double ( __attribute__((__leaf__)) __fabsf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern long double ( __attribute__((__leaf__)) floorf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern long double ( __attribute__((__leaf__)) __floorf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 183
extern long double ( __attribute__((__leaf__)) fmodf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 183
extern long double ( __attribute__((__leaf__)) __fmodf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 213
extern long double ( __attribute__((__leaf__)) copysignf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 213
extern long double ( __attribute__((__leaf__)) __copysignf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 218
extern long double ( __attribute__((__leaf__)) nanf64x)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 218
extern long double ( __attribute__((__leaf__)) __nanf64x)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 235
extern long double ( __attribute__((__leaf__)) j0f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 235
extern long double ( __attribute__((__leaf__)) __j0f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 236
extern long double ( __attribute__((__leaf__)) j1f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 236
extern long double ( __attribute__((__leaf__)) __j1f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 237
extern long double ( __attribute__((__leaf__)) jnf64x)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 237
extern long double ( __attribute__((__leaf__)) __jnf64x)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 238
extern long double ( __attribute__((__leaf__)) y0f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 238
extern long double ( __attribute__((__leaf__)) __y0f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 239
extern long double ( __attribute__((__leaf__)) y1f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 239
extern long double ( __attribute__((__leaf__)) __y1f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 240
extern long double ( __attribute__((__leaf__)) ynf64x)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 240
extern long double ( __attribute__((__leaf__)) __ynf64x)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 246
extern long double ( __attribute__((__leaf__)) erff64x)(long double  )  __attribute__((__nothrow__)) ;
#line 246
extern long double ( __attribute__((__leaf__)) __erff64x)(long double  )  __attribute__((__nothrow__)) ;
#line 247
extern long double ( __attribute__((__leaf__)) erfcf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 247
extern long double ( __attribute__((__leaf__)) __erfcf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 248
extern long double ( __attribute__((__leaf__)) lgammaf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 248
extern long double ( __attribute__((__leaf__)) __lgammaf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 253
extern long double ( __attribute__((__leaf__)) tgammaf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 253
extern long double ( __attribute__((__leaf__)) __tgammaf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 267
extern long double ( __attribute__((__leaf__)) lgammaf64x_r)(long double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 267
extern long double ( __attribute__((__leaf__)) __lgammaf64x_r)(long double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 274
extern long double ( __attribute__((__leaf__)) rintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 274
extern long double ( __attribute__((__leaf__)) __rintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 277
extern long double ( __attribute__((__leaf__)) nextafterf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 277
extern long double ( __attribute__((__leaf__)) __nextafterf64x)(long double __x ,
                                                                long double __y )  __attribute__((__nothrow__)) ;
#line 284
extern long double ( __attribute__((__leaf__)) nextdownf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 284
extern long double ( __attribute__((__leaf__)) __nextdownf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 286
extern long double ( __attribute__((__leaf__)) nextupf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 286
extern long double ( __attribute__((__leaf__)) __nextupf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 290
extern long double ( __attribute__((__leaf__)) remainderf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 290
extern long double ( __attribute__((__leaf__)) __remainderf64x)(long double __x ,
                                                                long double __y )  __attribute__((__nothrow__)) ;
#line 294
extern long double ( __attribute__((__leaf__)) scalbnf64x)(long double __x , int __n )  __attribute__((__nothrow__)) ;
#line 294
extern long double ( __attribute__((__leaf__)) __scalbnf64x)(long double __x , int __n )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) ilogbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) __ilogbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) llogbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 303
extern long ( __attribute__((__leaf__)) __llogbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 308
extern long double ( __attribute__((__leaf__)) scalblnf64x)(long double __x , long __n )  __attribute__((__nothrow__)) ;
#line 308
extern long double ( __attribute__((__leaf__)) __scalblnf64x)(long double __x , long __n )  __attribute__((__nothrow__)) ;
#line 312
extern long double ( __attribute__((__leaf__)) nearbyintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 312
extern long double ( __attribute__((__leaf__)) __nearbyintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long double ( __attribute__((__leaf__)) roundf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 316
extern long double ( __attribute__((__leaf__)) __roundf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern long double ( __attribute__((__leaf__)) truncf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern long double ( __attribute__((__leaf__)) __truncf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 325
extern long double ( __attribute__((__leaf__)) remquof64x)(long double __x , long double __y ,
                                                           int *__quo )  __attribute__((__nothrow__)) ;
#line 325
extern long double ( __attribute__((__leaf__)) __remquof64x)(long double __x , long double __y ,
                                                             int *__quo )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) lrintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) __lrintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) llrintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) __llrintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) lroundf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) __lroundf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) llroundf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) __llroundf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 344
extern long double ( __attribute__((__leaf__)) fdimf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 344
extern long double ( __attribute__((__leaf__)) __fdimf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 348
extern long double ( __attribute__((__leaf__)) fmaxf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 348
extern long double ( __attribute__((__leaf__)) __fmaxf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern long double ( __attribute__((__leaf__)) fminf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern long double ( __attribute__((__leaf__)) __fminf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 355
extern long double ( __attribute__((__leaf__)) fmaf64x)(long double __x , long double __y ,
                                                        long double __z )  __attribute__((__nothrow__)) ;
#line 355
extern long double ( __attribute__((__leaf__)) __fmaf64x)(long double __x , long double __y ,
                                                          long double __z )  __attribute__((__nothrow__)) ;
#line 360
extern long double ( __attribute__((__leaf__)) roundevenf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 360
extern long double ( __attribute__((__leaf__)) __roundevenf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) fromfpf64x)(long double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 364
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf64x)(long double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf64x)(long double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 369
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf64x)(long double __x , int __round ,
                                                              unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf64x)(long double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 375
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf64x)(long double __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf64x)(long double __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 381
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf64x)(long double __x , int __round ,
                                                               unsigned int __width )  __attribute__((__nothrow__)) ;
#line 385
extern int ( __attribute__((__leaf__)) canonicalizef64x)(long double *__cx , long double const   *__x )  __attribute__((__nothrow__)) ;
#line 392
extern long double ( __attribute__((__leaf__)) fmaxmagf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 392
extern long double ( __attribute__((__leaf__)) __fmaxmagf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern long double ( __attribute__((__leaf__)) fminmagf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 395
extern long double ( __attribute__((__leaf__)) __fminmagf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern long double ( __attribute__((__leaf__)) fmaximumf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern long double ( __attribute__((__leaf__)) __fmaximumf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern long double ( __attribute__((__leaf__)) fminimumf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 403
extern long double ( __attribute__((__leaf__)) __fminimumf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern long double ( __attribute__((__leaf__)) fmaximum_numf64x)(long double __x ,
                                                                 long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 406
extern long double ( __attribute__((__leaf__)) __fmaximum_numf64x)(long double __x ,
                                                                   long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern long double ( __attribute__((__leaf__)) fminimum_numf64x)(long double __x ,
                                                                 long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 409
extern long double ( __attribute__((__leaf__)) __fminimum_numf64x)(long double __x ,
                                                                   long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern long double ( __attribute__((__leaf__)) fmaximum_magf64x)(long double __x ,
                                                                 long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 412
extern long double ( __attribute__((__leaf__)) __fmaximum_magf64x)(long double __x ,
                                                                   long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern long double ( __attribute__((__leaf__)) fminimum_magf64x)(long double __x ,
                                                                 long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 415
extern long double ( __attribute__((__leaf__)) __fminimum_magf64x)(long double __x ,
                                                                   long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern long double ( __attribute__((__leaf__)) fmaximum_mag_numf64x)(long double __x ,
                                                                     long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 418
extern long double ( __attribute__((__leaf__)) __fmaximum_mag_numf64x)(long double __x ,
                                                                       long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern long double ( __attribute__((__leaf__)) fminimum_mag_numf64x)(long double __x ,
                                                                     long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 421
extern long double ( __attribute__((__leaf__)) __fminimum_mag_numf64x)(long double __x ,
                                                                       long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 426
extern int ( __attribute__((__leaf__)) totalorderf64x)(long double const   *__x ,
                                                       long double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 431
extern int ( __attribute__((__leaf__)) totalordermagf64x)(long double const   *__x ,
                                                          long double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 436
extern long double ( __attribute__((__leaf__)) getpayloadf64x)(long double const   *__x )  __attribute__((__nothrow__)) ;
#line 436
extern long double ( __attribute__((__leaf__)) __getpayloadf64x)(long double const   *__x )  __attribute__((__nothrow__)) ;
#line 439
extern int ( __attribute__((__leaf__)) setpayloadf64x)(long double *__x , long double __payload )  __attribute__((__nothrow__)) ;
#line 442
extern int ( __attribute__((__leaf__)) setpayloadsigf64x)(long double *__x , long double __payload )  __attribute__((__nothrow__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h"
extern float ( __attribute__((__leaf__)) fadd)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) fdiv)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) ffma)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) fmul)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 36
extern float ( __attribute__((__leaf__)) fsqrt)(double __x )  __attribute__((__nothrow__)) ;
#line 39
extern float ( __attribute__((__leaf__)) fsub)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 24
extern float ( __attribute__((__leaf__)) faddl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) fdivl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) ffmal)(long double __x , long double __y ,
                                                long double __z )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) fmull)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 36
extern float ( __attribute__((__leaf__)) fsqrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 39
extern float ( __attribute__((__leaf__)) fsubl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) daddl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) ddivl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) dfmal)(long double __x , long double __y ,
                                                 long double __z )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) dmull)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 36
extern double ( __attribute__((__leaf__)) dsqrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 39
extern double ( __attribute__((__leaf__)) dsubl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 24
extern float ( __attribute__((__leaf__)) f32addf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) f32divf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) f32fmaf32x)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) f32mulf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 36
extern float ( __attribute__((__leaf__)) f32sqrtf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 39
extern float ( __attribute__((__leaf__)) f32subf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 24
extern float ( __attribute__((__leaf__)) f32addf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) f32divf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) f32fmaf64)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) f32mulf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 36
extern float ( __attribute__((__leaf__)) f32sqrtf64)(double __x )  __attribute__((__nothrow__)) ;
#line 39
extern float ( __attribute__((__leaf__)) f32subf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 24
extern float ( __attribute__((__leaf__)) f32addf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) f32divf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) f32fmaf64x)(long double __x , long double __y ,
                                                     long double __z )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) f32mulf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 36
extern float ( __attribute__((__leaf__)) f32sqrtf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 39
extern float ( __attribute__((__leaf__)) f32subf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 24
extern float ( __attribute__((__leaf__)) f32addf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) f32divf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) f32fmaf128)(_Float128 __x , _Float128 __y ,
                                                     _Float128 __z )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) f32mulf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 36
extern float ( __attribute__((__leaf__)) f32sqrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 39
extern float ( __attribute__((__leaf__)) f32subf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) f32xaddf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) f32xdivf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) f32xfmaf64)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) f32xmulf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 36
extern double ( __attribute__((__leaf__)) f32xsqrtf64)(double __x )  __attribute__((__nothrow__)) ;
#line 39
extern double ( __attribute__((__leaf__)) f32xsubf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) f32xaddf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) f32xdivf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) f32xfmaf64x)(long double __x , long double __y ,
                                                       long double __z )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) f32xmulf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 36
extern double ( __attribute__((__leaf__)) f32xsqrtf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 39
extern double ( __attribute__((__leaf__)) f32xsubf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) f32xaddf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) f32xdivf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) f32xfmaf128)(_Float128 __x , _Float128 __y ,
                                                       _Float128 __z )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) f32xmulf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 36
extern double ( __attribute__((__leaf__)) f32xsqrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 39
extern double ( __attribute__((__leaf__)) f32xsubf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) f64addf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) f64divf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) f64fmaf64x)(long double __x , long double __y ,
                                                      long double __z )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) f64mulf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 36
extern double ( __attribute__((__leaf__)) f64sqrtf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 39
extern double ( __attribute__((__leaf__)) f64subf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) f64addf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) f64divf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) f64fmaf128)(_Float128 __x , _Float128 __y ,
                                                      _Float128 __z )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) f64mulf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 36
extern double ( __attribute__((__leaf__)) f64sqrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 39
extern double ( __attribute__((__leaf__)) f64subf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 24
extern long double ( __attribute__((__leaf__)) f64xaddf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 27
extern long double ( __attribute__((__leaf__)) f64xdivf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 30
extern long double ( __attribute__((__leaf__)) f64xfmaf128)(_Float128 __x , _Float128 __y ,
                                                            _Float128 __z )  __attribute__((__nothrow__)) ;
#line 33
extern long double ( __attribute__((__leaf__)) f64xmulf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 36
extern long double ( __attribute__((__leaf__)) f64xsqrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 39
extern long double ( __attribute__((__leaf__)) f64xsubf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 854 "/usr/include/math.h"
extern int signgam ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h"
extern int ( __attribute__((__leaf__)) __iscanonicall)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 44 "book.c"
static int book_moves[200]  ;
#line 45 "book.c"
static BOOK_POSITION start_moves[200]  ;
#line 46 "book.c"
static uint64_t selected_key[200]  ;
#line 47 "book.c"
static int selected[200]  ;
#line 48 "book.c"
static int selected_order_played[200]  ;
#line 48 "book.c"
static int selected_value[200]  ;
#line 49 "book.c"
static int selected_status[200]  ;
#line 49 "book.c"
static int selected_percent[200]  ;
#line 49 "book.c"
static int book_development[200]  ;
#line 51 "book.c"
static int bs_played[200]  ;
#line 51 "book.c"
static int bs_percent[200]  ;
#line 52 "book.c"
static int book_status[200]  ;
#line 52 "book.c"
static int evaluations[200]  ;
#line 52 "book.c"
static int bs_learn[200]  ;
#line 53 "book.c"
static float bs_value[200]  ;
#line 53 "book.c"
static float total_value  ;
#line 54 "book.c"
static uint64_t book_key[200]  ;
#line 54 "book.c"
static uint64_t bs_key[200]  ;
#line 43 "book.c"
int Book(TREE *tree , int wtm ) 
{ 
  int m1_status ;
  int forced ;
  int total_percent ;
  int play_percentage ;
  float tempr ;
  int done ;
  int i ;
  int j___0 ;
  int last_move ;
  int temp ;
  int which ;
  int minlv ;
  int maxlv ;
  int maxp ;
  int minev ;
  int maxev ;
  int nflagged ;
  int im ;
  int value ;
  int np ;
  int book_ponder_move ;
  int cluster ;
  int scluster ;
  int test ;
  int v ;
  unsigned char buf32[4] ;
  uint64_t temp_hash_key ;
  uint64_t common ;
  uint64_t tempk ;
  int key ;
  int nmoves ;
  int num_selected ;
  int st ;
  int percent_played ;
  int total_played ;
  int total_moves___0 ;
  int smoves ;
  int distribution ;
  int initial_development ;
  char *kibitz_p ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  double tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;

  {
#line 55
  forced = 0;
#line 55
  play_percentage = 0;
#line 57
  minlv = 999999;
#line 57
  maxlv = -999999;
#line 58
  maxp = -999999;
#line 58
  minev = 999999;
#line 58
  maxev = -999999;
#line 77
  if (moves_out_of_book > 6) {
#line 78
    return (0);
  }
#line 88
  test = (int )(tree->position.hash_key >> 49);
#line 89
  smoves = 0;
#line 90
  if (books_file) {
#line 91
    fseek(books_file, (long )((unsigned long )test * sizeof(int )), 0);
#line 92
    tmp = fread((void *)(buf32), (size_t )4, (size_t )1, books_file);
#line 92
    v = (int )tmp;
#line 93
    if (v <= 0) {
#line 94
      perror((char const   *)"Book() fread error: ");
    }
#line 95
    key = BookIn32(buf32);
#line 96
    if (key > 0) {
#line 97
      fseek(books_file, (long )key, 0);
#line 98
      tmp___0 = fread((void *)(buf32), (size_t )4, (size_t )1, books_file);
#line 98
      v = (int )tmp___0;
#line 99
      if (v <= 0) {
#line 100
        perror((char const   *)"Book() fread error: ");
      }
#line 101
      scluster = BookIn32(buf32);
#line 102
      if (scluster) {
#line 103
        BookClusterIn(books_file, scluster, book_buffer);
      }
#line 104
      im = 0;
      {
#line 104
      while (1) {
        while_continue: /* CIL Label */ ;
#line 104
        if (! (im < n_root_moves)) {
#line 104
          goto while_break;
        }
#line 105
        common = tree->position.hash_key & (65535UL << 48);
#line 106
        MakeMove(tree, 1, wtm, root_moves[im].move);
#line 107
        tmp___1 = Repeat(tree, 2);
#line 107
        if (tmp___1) {
#line 108
          UnmakeMove(tree, 1, wtm, root_moves[im].move);
#line 109
          return (0);
        }
#line 111
        if (wtm) {
#line 111
          temp_hash_key = tree->position.hash_key;
        } else {
#line 111
          temp_hash_key = ~ tree->position.hash_key;
        }
#line 112
        temp_hash_key = (temp_hash_key & ~ (65535UL << 48)) | common;
#line 113
        i = 0;
        {
#line 113
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 113
          if (! (i < scluster)) {
#line 113
            goto while_break___0;
          }
#line 114
          if (! (temp_hash_key ^ book_buffer[i].position)) {
#line 115
            tmp___2 = smoves;
#line 115
            smoves ++;
#line 115
            start_moves[tmp___2] = book_buffer[i];
#line 116
            goto while_break___0;
          }
#line 113
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 118
        UnmakeMove(tree, 1, wtm, root_moves[im].move);
#line 104
        im ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 132
  test = (int )(tree->position.hash_key >> 49);
#line 133
  if (book_file) {
#line 134
    fseek(book_file, (long )((unsigned long )test * sizeof(int )), 0);
#line 135
    tmp___3 = fread((void *)(buf32), (size_t )4, (size_t )1, book_file);
#line 135
    v = (int )tmp___3;
#line 136
    if (v <= 0) {
#line 137
      perror((char const   *)"Book() fread error: ");
    }
#line 138
    key = BookIn32(buf32);
#line 139
    if (key > 0) {
#line 140
      book_learn_seekto = key;
#line 141
      fseek(book_file, (long )key, 0);
#line 142
      tmp___4 = fread((void *)(buf32), (size_t )4, (size_t )1, book_file);
#line 142
      v = (int )tmp___4;
#line 143
      if (v <= 0) {
#line 144
        perror((char const   *)"Book() fread error: ");
      }
#line 145
      cluster = BookIn32(buf32);
#line 146
      if (cluster) {
#line 147
        BookClusterIn(book_file, cluster, book_buffer);
      }
    } else {
#line 149
      cluster = 0;
    }
#line 150
    if (! cluster) {
#line 150
      if (! smoves) {
#line 151
        return (0);
      } else {
#line 150
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 161
    i = 0;
    {
#line 161
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 161
      if (! (i < smoves)) {
#line 161
        goto while_break___1;
      }
#line 162
      j___0 = 0;
      {
#line 162
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 162
        if (! (j___0 < cluster)) {
#line 162
          goto while_break___2;
        }
#line 163
        if (! (book_buffer[j___0].position ^ start_moves[i].position)) {
#line 164
          goto while_break___2;
        }
#line 162
        j___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 165
      if (j___0 >= cluster) {
#line 166
        book_buffer[cluster] = start_moves[i];
#line 167
        book_buffer[cluster].status_played &= 037700000000;
#line 169
        cluster ++;
      }
#line 161
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 181
    initial_development = tree->score_mg;
#line 182
    EvaluateCastling(tree, 1, wtm);
#line 183
    initial_development = tree->score_mg - initial_development;
#line 184
    total_moves___0 = 0;
#line 185
    nmoves = 0;
#line 186
    im = 0;
    {
#line 186
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 186
      if (! (im < n_root_moves)) {
#line 186
        goto while_break___3;
      }
#line 187
      common = tree->position.hash_key & (65535UL << 48);
#line 188
      MakeMove(tree, 1, wtm, root_moves[im].move);
#line 189
      tmp___5 = Repeat(tree, 2);
#line 189
      if (tmp___5) {
#line 190
        UnmakeMove(tree, 1, wtm, root_moves[im].move);
#line 191
        return (0);
      }
#line 193
      if (wtm) {
#line 193
        temp_hash_key = tree->position.hash_key;
      } else {
#line 193
        temp_hash_key = ~ tree->position.hash_key;
      }
#line 194
      temp_hash_key = (temp_hash_key & ~ (65535UL << 48)) | common;
#line 195
      i = 0;
      {
#line 195
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 195
        if (! (i < cluster)) {
#line 195
          goto while_break___4;
        }
#line 196
        if (! (temp_hash_key ^ book_buffer[i].position)) {
#line 197
          book_status[nmoves] = (int )(book_buffer[i].status_played >> 24);
#line 198
          bs_played[nmoves] = (int )(book_buffer[i].status_played & 16777215U);
#line 199
          bs_learn[nmoves] = (int )((double )book_buffer[i].learn * 100.0);
#line 200
          if (puzzling) {
#line 201
            (bs_played[nmoves]) ++;
          }
#line 202
          tree->curmv[1] = root_moves[im].move;
#line 203
          if (! ((root_moves[im].move >> 15) & 7)) {
#line 204
            book_development[nmoves] = tree->score_mg;
#line 205
            EvaluateCastling(tree, 2, wtm);
#line 206
            book_development[nmoves] = tree->score_mg - book_development[nmoves];
          } else {
#line 209
            book_development[nmoves] = 0;
          }
#line 210
          total_moves___0 += bs_played[nmoves];
#line 211
          evaluations[nmoves] = Evaluate(tree, 2, wtm, -99999, 99999);
#line 212
          if (wtm) {
#line 212
            tmp___6 = tree->position.material_evaluation;
          } else {
#line 212
            tmp___6 = - tree->position.material_evaluation;
          }
#line 212
          evaluations[nmoves] -= tmp___6;
#line 213
          bs_percent[nmoves] = 0;
#line 214
          j___0 = 0;
          {
#line 214
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 214
            if (! (j___0 < smoves)) {
#line 214
              goto while_break___5;
            }
#line 215
            if (! (book_buffer[i].position ^ start_moves[j___0].position)) {
#line 216
              book_status[nmoves] = (int )((unsigned int )book_status[nmoves] | (start_moves[j___0].status_played >> 24));
#line 217
              bs_percent[nmoves] = (int )(start_moves[j___0].status_played & 16777215U);
#line 218
              goto while_break___5;
            }
#line 214
            j___0 ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 221
          book_moves[nmoves] = root_moves[im].move;
#line 222
          book_key[nmoves] = temp_hash_key;
#line 223
          nmoves ++;
#line 224
          goto while_break___4;
        }
#line 195
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 227
      UnmakeMove(tree, 1, wtm, root_moves[im].move);
#line 186
      im ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 229
    if (! nmoves) {
#line 230
      return (0);
    }
#line 231
    book_learn_nmoves = nmoves;
#line 241
    i = 0;
    {
#line 241
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 241
      if (! (i < nmoves)) {
#line 241
        goto while_break___6;
      }
#line 242
      if (! (book_status[i] & 0x02)) {
#line 243
        if (maxp > bs_played[i]) {
#line 243
          maxp = maxp;
        } else {
#line 243
          maxp = bs_played[i];
        }
      }
#line 241
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 244
    i = 0;
    {
#line 244
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 244
      if (! (i < nmoves)) {
#line 244
        goto while_break___7;
      }
#line 245
      if (bs_learn[i] <= -80) {
#line 245
        if (! bs_percent[i]) {
#line 245
          if (! (book_status[i] & 0x18)) {
#line 247
            book_status[i] |= 0x02;
          } else {
#line 245
            goto _L___1;
          }
        } else {
#line 245
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        _L___0: /* CIL Label */ ;
      }
#line 248
      if (wtm) {
#line 248
        if (! (book_status[i] & 0x80)) {
#line 248
          if (! bs_percent[i]) {
#line 248
            if (! (book_status[i] & 0x18)) {
#line 250
              book_status[i] |= 0x02;
            } else {
#line 248
              goto _L___4;
            }
          } else {
#line 248
            goto _L___4;
          }
        } else {
#line 248
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
        _L___3: /* CIL Label */ 
        _L___2: /* CIL Label */ ;
      }
#line 251
      if (! wtm) {
#line 251
        if (! (book_status[i] & 0x20)) {
#line 251
          if (! bs_percent[i]) {
#line 251
            if (! (book_status[i] & 0x18)) {
#line 253
              book_status[i] |= 0x02;
            } else {
#line 251
              goto _L___7;
            }
          } else {
#line 251
            goto _L___7;
          }
        } else {
#line 251
          goto _L___7;
        }
      } else {
        _L___7: /* CIL Label */ 
        _L___6: /* CIL Label */ 
        _L___5: /* CIL Label */ ;
      }
#line 254
      if (bs_played[i] < maxp / 10) {
#line 254
        if (! bs_percent[i]) {
#line 254
          if (book_random) {
#line 254
            if (! (book_status[i] & 0x18)) {
#line 256
              book_status[i] |= 0x02;
            } else {
#line 254
              goto _L___10;
            }
          } else {
#line 254
            goto _L___10;
          }
        } else {
#line 254
          goto _L___10;
        }
      } else {
        _L___10: /* CIL Label */ 
        _L___9: /* CIL Label */ 
        _L___8: /* CIL Label */ ;
      }
#line 257
      if (bs_learn[i] >= 100) {
#line 257
        if (! (book_status[i] & 0x03)) {
#line 258
          book_status[i] |= 0x08;
        } else {
#line 257
          goto _L___11;
        }
      } else {
        _L___11: /* CIL Label */ ;
      }
#line 259
      if (bs_percent[i]) {
#line 260
        book_status[i] |= 0x08;
      }
#line 244
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 271
    i = 0;
    {
#line 271
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 271
      if (! (i < nmoves)) {
#line 271
        goto while_break___8;
      }
#line 272
      if (! (book_status[i] & 0x02)) {
#line 273
        if (minlv < bs_learn[i]) {
#line 273
          minlv = minlv;
        } else {
#line 273
          minlv = bs_learn[i];
        }
#line 274
        if (maxlv > bs_learn[i]) {
#line 274
          maxlv = maxlv;
        } else {
#line 274
          maxlv = bs_learn[i];
        }
#line 275
        if (minev < evaluations[i]) {
#line 275
          minev = minev;
        } else {
#line 275
          minev = evaluations[i];
        }
#line 276
        if (maxev > evaluations[i]) {
#line 276
          maxev = maxev;
        } else {
#line 276
          maxev = evaluations[i];
        }
#line 277
        if (maxp > bs_played[i]) {
#line 277
          maxp = maxp;
        } else {
#line 277
          maxp = bs_played[i];
        }
      }
#line 271
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 280
    maxp ++;
#line 281
    i = 0;
    {
#line 281
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 281
      if (! (i < nmoves)) {
#line 281
        goto while_break___9;
      }
#line 282
      bs_value[i] = (float )1;
#line 283
      bs_value[i] = (float )((double )bs_value[i] + ((double )((float )bs_played[i] / (float )maxp) * 1000.0) * (double )book_weight_freq);
#line 285
      if (minlv < maxlv) {
#line 286
        bs_value[i] = (float )((double )bs_value[i] + ((double )((float )(bs_learn[i] - minlv) / (float )(maxlv - minlv)) * 1000.0) * (double )book_weight_learn);
      }
#line 289
      if (minev < maxev) {
#line 290
        if (maxev - minev > 50) {
#line 290
          tmp___7 = maxev - minev;
        } else {
#line 290
          tmp___7 = 50;
        }
#line 290
        bs_value[i] = (float )((double )bs_value[i] + ((double )((float )(evaluations[i] - minev) / (float )tmp___7) * 1000.0) * (double )book_weight_eval);
      }
#line 281
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 294
    total_played = total_moves___0;
#line 303
    i = 0;
    {
#line 303
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 303
      if (! (i < nmoves)) {
#line 303
        goto while_break___10;
      }
#line 304
      if (book_status[i] & 0x18) {
#line 305
        goto while_break___10;
      }
#line 303
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 306
    if (i < nmoves) {
#line 307
      i = 0;
      {
#line 307
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 307
        if (! (i < nmoves)) {
#line 307
          goto while_break___11;
        }
#line 308
        if (book_status[i] & 0x18) {
#line 309
          bs_value[i] = (float )((double )bs_value[i] + 8000.0);
        }
#line 310
        if (! (book_status[i] & 0x03)) {
#line 311
          bs_value[i] = (float )((double )bs_value[i] + 4000.0);
        }
#line 307
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
#line 321
    if (nmoves) {
      {
#line 322
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 323
        done = 1;
#line 324
        i = 0;
        {
#line 324
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 324
          if (! (i < nmoves - 1)) {
#line 324
            goto while_break___13;
          }
#line 325
          if (bs_percent[i] < bs_percent[i + 1]) {
#line 325
            goto _L___12;
          } else
#line 325
          if (bs_percent[i] == bs_percent[i + 1]) {
#line 325
            if (bs_value[i] < bs_value[i + 1]) {
              _L___12: /* CIL Label */ 
#line 328
              tempr = (float )bs_played[i];
#line 329
              bs_played[i] = bs_played[i + 1];
#line 330
              bs_played[i + 1] = (int )tempr;
#line 331
              tempr = bs_value[i];
#line 332
              bs_value[i] = bs_value[i + 1];
#line 333
              bs_value[i + 1] = tempr;
#line 334
              temp = evaluations[i];
#line 335
              evaluations[i] = evaluations[i + 1];
#line 336
              evaluations[i + 1] = temp;
#line 337
              temp = bs_learn[i];
#line 338
              bs_learn[i] = bs_learn[i + 1];
#line 339
              bs_learn[i + 1] = temp;
#line 340
              temp = book_development[i];
#line 341
              book_development[i] = book_development[i + 1];
#line 342
              book_development[i + 1] = temp;
#line 343
              temp = book_moves[i];
#line 344
              book_moves[i] = book_moves[i + 1];
#line 345
              book_moves[i + 1] = temp;
#line 346
              temp = book_status[i];
#line 347
              book_status[i] = book_status[i + 1];
#line 348
              book_status[i + 1] = temp;
#line 349
              temp = bs_percent[i];
#line 350
              bs_percent[i] = bs_percent[i + 1];
#line 351
              bs_percent[i + 1] = temp;
#line 352
              tempk = book_key[i];
#line 353
              book_key[i] = book_key[i + 1];
#line 354
              book_key[i + 1] = tempk;
#line 355
              done = 0;
            } else {
#line 325
              goto _L___13;
            }
          } else {
            _L___13: /* CIL Label */ ;
          }
#line 324
          i ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 322
        if (! (! done)) {
#line 322
          goto while_break___12;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 367
    if (show_book) {
#line 368
      Print(32, "  after screening, the following moves can be played\n");
#line 369
      Print(32, "  move     played    %%  score    learn    sortv   P%%  P\n");
#line 371
      i = 0;
      {
#line 371
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 371
        if (! (i < nmoves)) {
#line 371
          goto while_break___14;
        }
#line 372
        tmp___8 = OutputMove(tree, 1, wtm, book_moves[i]);
#line 372
        Print(32, "%6s", tmp___8);
#line 373
        st = book_status[i];
#line 374
        if (st & 0x1f) {
#line 375
          if (st & 0x01) {
#line 376
            Print(32, "??");
          } else
#line 377
          if (st & 0x02) {
#line 378
            Print(32, "? ");
          } else
#line 379
          if (st & 0x04) {
#line 380
            Print(32, "= ");
          } else
#line 381
          if (st & 0x08) {
#line 382
            Print(32, "! ");
          } else
#line 383
          if (st & 0x10) {
#line 384
            Print(32, "!!");
          }
        } else {
#line 386
          Print(32, "  ");
        }
#line 387
        Print(32, "   %6d", bs_played[i]);
#line 388
        if (total_moves___0 > 1) {
#line 388
          tmp___9 = total_moves___0;
        } else {
#line 388
          tmp___9 = 1;
        }
#line 388
        Print(32, "  %3d", (100 * bs_played[i]) / tmp___9);
#line 389
        tmp___10 = DisplayEvaluation(evaluations[i], wtm);
#line 389
        Print(32, "%s", tmp___10);
#line 390
        Print(32, "%9.2f", (double )((float )bs_learn[i]) / 100.0);
#line 391
        Print(32, " %9.1f", (double )bs_value[i]);
#line 392
        Print(32, " %3d", bs_percent[i]);
#line 393
        if (book_status[i] & book_accept_mask) {
#line 393
          if (! (book_status[i] & book_reject_mask)) {
#line 393
            goto _L___16;
          } else {
#line 393
            goto _L___21;
          }
        } else
        _L___21: /* CIL Label */ 
#line 393
        if (! (book_status[i] & book_reject_mask)) {
#line 393
          if (bs_percent[i]) {
#line 393
            goto _L___20;
          } else
#line 393
          if (book_status[i] & 0x18) {
            _L___20: /* CIL Label */ 
#line 393
            goto _L___18;
          } else
#line 393
          if (wtm) {
#line 393
            if (book_status[i] & 0x80) {
              _L___18: /* CIL Label */ 
#line 393
              goto _L___16;
            } else {
#line 393
              goto _L___19;
            }
          } else
          _L___19: /* CIL Label */ 
#line 393
          if (! wtm) {
#line 393
            if (book_status[i] & 0x20) {
              _L___16: /* CIL Label */ 
              _L___14: /* CIL Label */ 
#line 398
              Print(32, "  Y");
            } else {
#line 393
              goto _L___17;
            }
          } else {
            _L___17: /* CIL Label */ 
#line 393
            goto _L___15;
          }
        } else {
          _L___15: /* CIL Label */ 
#line 400
          Print(32, "  N");
        }
#line 401
        Print(32, "\n");
#line 371
        i ++;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 413
    i = 0;
    {
#line 413
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 413
      if (! (i < nmoves)) {
#line 413
        goto while_break___15;
      }
#line 414
      if (bs_percent[i]) {
#line 415
        play_percentage = 1;
      }
#line 413
      i ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 426
    num_selected = 0;
#line 427
    if (! play_percentage) {
#line 428
      i = 0;
      {
#line 428
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 428
        if (! (i < nmoves)) {
#line 428
          goto while_break___16;
        }
#line 429
        if (! (book_status[i] & 0x03)) {
#line 429
          goto _L___22;
        } else
#line 429
        if (bs_percent[i]) {
          _L___22: /* CIL Label */ 
#line 430
          selected_status[num_selected] = book_status[i];
#line 431
          selected_order_played[num_selected] = bs_played[i];
#line 432
          selected_value[num_selected] = (int )bs_value[i];
#line 433
          selected_percent[num_selected] = bs_percent[i];
#line 434
          selected_key[num_selected] = book_key[i];
#line 435
          tmp___11 = num_selected;
#line 435
          num_selected ++;
#line 435
          selected[tmp___11] = book_moves[i];
        }
#line 428
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
    } else {
#line 438
      i = 0;
      {
#line 438
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 438
        if (! (i < nmoves)) {
#line 438
          goto while_break___17;
        }
#line 439
        if (bs_percent[i]) {
#line 440
          selected_status[num_selected] = book_status[i];
#line 441
          selected_order_played[num_selected] = bs_played[i];
#line 442
          selected_value[num_selected] = (int )bs_value[i];
#line 443
          selected_percent[num_selected] = bs_percent[i];
#line 444
          selected_key[num_selected] = book_key[i];
#line 445
          tmp___12 = num_selected;
#line 445
          num_selected ++;
#line 445
          selected[tmp___12] = book_moves[i];
        }
#line 438
        i ++;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
#line 448
    i = 0;
    {
#line 448
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 448
      if (! (i < num_selected)) {
#line 448
        goto while_break___18;
      }
#line 449
      book_status[i] = selected_status[i];
#line 450
      bs_played[i] = selected_order_played[i];
#line 451
      bs_value[i] = (float )selected_value[i];
#line 452
      bs_percent[i] = selected_percent[i];
#line 453
      book_moves[i] = selected[i];
#line 448
      i ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 455
    nmoves = num_selected;
#line 465
    if (! puzzling) {
      {
#line 466
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 467
        kibitz_text[0] = (char )'\000';
#line 468
        if (! nmoves) {
#line 469
          goto while_break___19;
        }
#line 470
        sprintf(kibitz_text, (char const   *)"book moves (");
#line 471
        tmp___13 = strlen((char const   *)(kibitz_text));
#line 471
        kibitz_p = kibitz_text + tmp___13;
#line 472
        i = 0;
        {
#line 472
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 472
          if (! (i < nmoves)) {
#line 472
            goto while_break___20;
          }
#line 473
          if (total_played > 1) {
#line 473
            tmp___14 = total_played;
          } else {
#line 473
            tmp___14 = 1;
          }
#line 473
          tmp___15 = OutputMove(tree, 1, wtm, book_moves[i]);
#line 473
          sprintf(kibitz_p, (char const   *)"%s %d%%", tmp___15, (100 * bs_played[i]) / tmp___14);
#line 475
          tmp___16 = strlen((char const   *)(kibitz_text));
#line 475
          kibitz_p = kibitz_text + tmp___16;
#line 476
          if (i < nmoves - 1) {
#line 477
            sprintf(kibitz_p, (char const   *)", ");
#line 478
            tmp___17 = strlen((char const   *)(kibitz_text));
#line 478
            kibitz_p = kibitz_text + tmp___17;
          }
#line 472
          i ++;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 481
        sprintf(kibitz_p, (char const   *)")\n");
#line 466
        if (! 0) {
#line 466
          goto while_break___19;
        }
      }
      while_break___19: /* CIL Label */ ;
      }
    }
#line 497
    num_selected = 0;
#line 498
    if (! num_selected) {
#line 498
      if (! puzzling) {
#line 499
        if (book_accept_mask & 16) {
#line 500
          i = 0;
          {
#line 500
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 500
            if (! (i < nmoves)) {
#line 500
              goto while_break___21;
            }
#line 501
            if (book_status[i] & 16) {
#line 502
              forced = 1;
#line 503
              selected_status[num_selected] = book_status[i];
#line 504
              selected_order_played[num_selected] = bs_played[i];
#line 505
              selected_value[num_selected] = (int )bs_value[i];
#line 506
              selected_key[num_selected] = book_key[i];
#line 507
              tmp___18 = num_selected;
#line 507
              num_selected ++;
#line 507
              selected[tmp___18] = book_moves[i];
            }
#line 500
            i ++;
          }
          while_break___21: /* CIL Label */ ;
          }
        }
      } else {
#line 498
        goto _L___23;
      }
    } else {
      _L___23: /* CIL Label */ ;
    }
#line 509
    if (! num_selected) {
#line 509
      if (! puzzling) {
#line 510
        if (book_accept_mask & 8) {
#line 511
          i = 0;
          {
#line 511
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 511
            if (! (i < nmoves)) {
#line 511
              goto while_break___22;
            }
#line 512
            if (book_status[i] & 8) {
#line 513
              forced = 1;
#line 514
              selected_status[num_selected] = book_status[i];
#line 515
              selected_order_played[num_selected] = bs_played[i];
#line 516
              selected_value[num_selected] = (int )bs_value[i];
#line 517
              selected_key[num_selected] = book_key[i];
#line 518
              tmp___19 = num_selected;
#line 518
              num_selected ++;
#line 518
              selected[tmp___19] = book_moves[i];
            }
#line 511
            i ++;
          }
          while_break___22: /* CIL Label */ ;
          }
        }
      } else {
#line 509
        goto _L___24;
      }
    } else {
      _L___24: /* CIL Label */ ;
    }
#line 520
    if (! num_selected) {
#line 520
      if (! puzzling) {
#line 521
        if (book_accept_mask & 4) {
#line 522
          i = 0;
          {
#line 522
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 522
            if (! (i < nmoves)) {
#line 522
              goto while_break___23;
            }
#line 523
            if (book_status[i] & 4) {
#line 524
              selected_status[num_selected] = book_status[i];
#line 525
              selected_order_played[num_selected] = bs_played[i];
#line 526
              selected_value[num_selected] = (int )bs_value[i];
#line 527
              selected_key[num_selected] = book_key[i];
#line 528
              tmp___20 = num_selected;
#line 528
              num_selected ++;
#line 528
              selected[tmp___20] = book_moves[i];
            }
#line 522
            i ++;
          }
          while_break___23: /* CIL Label */ ;
          }
        }
      } else {
#line 520
        goto _L___25;
      }
    } else {
      _L___25: /* CIL Label */ ;
    }
#line 530
    if (! num_selected) {
#line 530
      if (! puzzling) {
#line 531
        i = 0;
        {
#line 531
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 531
          if (! (i < nmoves)) {
#line 531
            goto while_break___24;
          }
#line 532
          if (book_status[i] & book_accept_mask) {
#line 533
            selected_status[num_selected] = book_status[i];
#line 534
            selected_order_played[num_selected] = bs_played[i];
#line 535
            selected_value[num_selected] = (int )bs_value[i];
#line 536
            selected_key[num_selected] = book_key[i];
#line 537
            tmp___21 = num_selected;
#line 537
            num_selected ++;
#line 537
            selected[tmp___21] = book_moves[i];
          }
#line 531
          i ++;
        }
        while_break___24: /* CIL Label */ ;
        }
      } else {
#line 530
        goto _L___26;
      }
    } else {
      _L___26: /* CIL Label */ ;
    }
#line 539
    if (! num_selected) {
#line 540
      i = 0;
      {
#line 540
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 540
        if (! (i < nmoves)) {
#line 540
          goto while_break___25;
        }
#line 541
        selected_status[num_selected] = book_status[i];
#line 542
        selected_order_played[num_selected] = bs_played[i];
#line 543
        selected_value[num_selected] = (int )bs_value[i];
#line 544
        selected_key[num_selected] = book_key[i];
#line 545
        tmp___22 = num_selected;
#line 545
        num_selected ++;
#line 545
        selected[tmp___22] = book_moves[i];
#line 540
        i ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
#line 547
    if (! num_selected) {
#line 548
      return (0);
    }
#line 549
    i = 0;
    {
#line 549
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 549
      if (! (i < num_selected)) {
#line 549
        goto while_break___26;
      }
#line 550
      book_status[i] = selected_status[i];
#line 551
      book_moves[i] = selected[i];
#line 552
      bs_played[i] = selected_order_played[i];
#line 553
      bs_value[i] = (float )selected_value[i];
#line 554
      bs_key[i] = selected_key[i];
#line 549
      i ++;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 556
    nmoves = num_selected;
#line 557
    if (nmoves == 0) {
#line 558
      return (0);
    }
#line 559
    Print(32, "               book moves {");
#line 560
    i = 0;
    {
#line 560
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 560
      if (! (i < nmoves)) {
#line 560
        goto while_break___27;
      }
#line 561
      tmp___23 = OutputMove(tree, 1, wtm, book_moves[i]);
#line 561
      Print(32, "%s", tmp___23);
#line 562
      if (i < nmoves - 1) {
#line 563
        Print(32, ", ");
      }
#line 560
      i ++;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 565
    Print(32, "}\n");
#line 566
    nflagged = 0;
#line 567
    i = 0;
    {
#line 567
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 567
      if (! (i < nmoves)) {
#line 567
        goto while_break___28;
      }
#line 568
      if (book_status[i] & 8) {
#line 569
        nflagged ++;
      }
#line 567
      i ++;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 570
    if (nmoves < book_selection_width) {
#line 570
      tmp___26 = nmoves;
    } else {
#line 570
      tmp___26 = book_selection_width;
    }
#line 570
    if (tmp___26 > nflagged) {
#line 570
      if (nmoves < book_selection_width) {
#line 570
        tmp___25 = nmoves;
      } else {
#line 570
        tmp___25 = book_selection_width;
      }
#line 570
      nmoves = tmp___25;
    } else {
#line 570
      nmoves = nflagged;
    }
#line 571
    if (show_book) {
#line 572
      Print(32, "               moves considered {");
#line 573
      i = 0;
      {
#line 573
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 573
        if (! (i < nmoves)) {
#line 573
          goto while_break___29;
        }
#line 574
        tmp___27 = OutputMove(tree, 1, wtm, book_moves[i]);
#line 574
        Print(32, "%s", tmp___27);
#line 575
        if (i < nmoves - 1) {
#line 576
          Print(32, ", ");
        }
#line 573
        i ++;
      }
      while_break___29: /* CIL Label */ ;
      }
#line 578
      Print(32, "}\n");
    }
#line 589
    total_value = (float )0.0;
#line 590
    total_percent = 0;
#line 591
    i = 0;
    {
#line 591
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 591
      if (! (i < nmoves)) {
#line 591
        goto while_break___30;
      }
#line 592
      if (! bs_percent[i]) {
#line 593
        total_value += bs_value[i];
      }
#line 594
      total_percent += bs_percent[i];
#line 591
      i ++;
    }
    while_break___30: /* CIL Label */ ;
    }
#line 596
    tmp___28 = fabs((double )total_value);
#line 596
    if (tmp___28 < 0.0001) {
#line 597
      total_value = (float )1000.0;
    }
#line 598
    if (total_percent > 99) {
#line 598
      total_percent = 99;
    } else {
#line 598
      total_percent = total_percent;
    }
#line 599
    i = 0;
    {
#line 599
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 599
      if (! (i < nmoves)) {
#line 599
        goto while_break___31;
      }
#line 600
      if (bs_percent[i]) {
#line 601
        bs_value[i] = (float )((((double )total_value / (1.0 - (double )((float )total_percent) / 100.0)) * (double )((float )bs_percent[i])) / 100.0);
      }
#line 599
      i ++;
    }
    while_break___31: /* CIL Label */ ;
    }
#line 612
    if (show_book) {
#line 613
      Print(32, "  move     played    %%  score     sortv  P%%  P\n");
#line 614
      i = 0;
      {
#line 614
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 614
        if (! (i < nmoves)) {
#line 614
          goto while_break___32;
        }
#line 615
        tmp___29 = OutputMove(tree, 1, wtm, book_moves[i]);
#line 615
        Print(32, "%6s", tmp___29);
#line 616
        st = book_status[i];
#line 617
        if (st & 0x1f) {
#line 618
          if (st & 0x01) {
#line 619
            Print(32, "??");
          } else
#line 620
          if (st & 0x02) {
#line 621
            Print(32, "? ");
          } else
#line 622
          if (st & 0x04) {
#line 623
            Print(32, "= ");
          } else
#line 624
          if (st & 0x08) {
#line 625
            Print(32, "! ");
          } else
#line 626
          if (st & 0x10) {
#line 627
            Print(32, "!!");
          }
        } else {
#line 629
          Print(32, "  ");
        }
#line 630
        Print(32, "   %6d", bs_played[i]);
#line 631
        if (total_moves___0 > 1) {
#line 631
          tmp___30 = total_moves___0;
        } else {
#line 631
          tmp___30 = 1;
        }
#line 631
        Print(32, "  %3d", (100 * bs_played[i]) / tmp___30);
#line 632
        tmp___31 = DisplayEvaluation(evaluations[i], wtm);
#line 632
        Print(32, "%s", tmp___31);
#line 633
        Print(32, " %9.1f", (double )bs_value[i]);
#line 634
        Print(32, " %3d", bs_percent[i]);
#line 635
        if (book_status[i] & book_accept_mask) {
#line 635
          if (! (book_status[i] & book_reject_mask)) {
#line 635
            goto _L___29;
          } else {
#line 635
            goto _L___32;
          }
        } else
        _L___32: /* CIL Label */ 
#line 635
        if (! (book_status[i] & book_reject_mask)) {
#line 635
          if (wtm) {
#line 635
            if (book_status[i] & 0x80) {
#line 635
              goto _L___29;
            } else {
#line 635
              goto _L___31;
            }
          } else
          _L___31: /* CIL Label */ 
#line 635
          if (! wtm) {
#line 635
            if (book_status[i] & 0x20) {
              _L___29: /* CIL Label */ 
              _L___27: /* CIL Label */ 
#line 640
              Print(32, "  Y");
            } else {
#line 635
              goto _L___30;
            }
          } else {
            _L___30: /* CIL Label */ 
#line 635
            goto _L___28;
          }
        } else {
          _L___28: /* CIL Label */ 
#line 642
          Print(32, "  N");
        }
#line 643
        Print(32, "\n");
#line 614
        i ++;
      }
      while_break___32: /* CIL Label */ ;
      }
    }
#line 655
    if (nmoves) {
#line 655
      if (! puzzling) {
#line 655
        goto _L___38;
      } else
#line 655
      if ((unsigned int )mode != 1U) {
        _L___38: /* CIL Label */ 
#line 656
        np = bs_played[nmoves - 1];
#line 657
        if (! puzzling) {
#line 657
          if (! book_random) {
#line 657
            goto _L___34;
          } else
#line 657
          if ((unsigned int )mode == 1U) {
#line 657
            if (np < book_search_trigger) {
              _L___34: /* CIL Label */ 
#line 659
              if (! forced) {
#line 660
                n_root_moves = nmoves;
#line 661
                i = 0;
                {
#line 661
                while (1) {
                  while_continue___33: /* CIL Label */ ;
#line 661
                  if (! (i < n_root_moves)) {
#line 661
                    goto while_break___33;
                  }
#line 662
                  root_moves[i].move = book_moves[i];
#line 663
                  root_moves[i].status = 0U;
#line 661
                  i ++;
                }
                while_break___33: /* CIL Label */ ;
                }
#line 665
                last_pv.pathd = 0;
#line 666
                booking = 1;
#line 667
                value = Iterate(wtm, booking, 1);
#line 668
                booking = 0;
#line 669
                if (value < -50) {
#line 670
                  last_pv.pathd = 0;
#line 671
                  return (0);
                }
              } else {
#line 674
                tree->pv[0].path[1] = book_moves[0];
#line 675
                tree->pv[0].pathl = 2;
#line 676
                tree->pv[0].pathd = 0;
#line 677
                tree->pv[0].pathv = 0;
              }
#line 679
              return (1);
            } else {
#line 657
              goto _L___35;
            }
          } else {
            _L___35: /* CIL Label */ 
#line 657
            goto _L___33;
          }
        } else {
          _L___33: /* CIL Label */ ;
        }
      } else {
#line 655
        goto _L___37;
      }
    } else
    _L___37: /* CIL Label */ 
#line 693
    if ((unsigned int )mode == 1U) {
#line 693
      if (puzzling) {
#line 694
        RootMoveList(wtm);
#line 695
        i = 0;
        {
#line 695
        while (1) {
          while_continue___34: /* CIL Label */ ;
#line 695
          if (! (i < n_root_moves)) {
#line 695
            goto while_break___34;
          }
#line 696
          j___0 = 0;
          {
#line 696
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 696
            if (! (j___0 < nmoves)) {
#line 696
              goto while_break___35;
            }
#line 697
            if (root_moves[i].move == book_moves[j___0]) {
#line 698
              root_moves[i].move = 0;
            }
#line 696
            j___0 ++;
          }
          while_break___35: /* CIL Label */ ;
          }
#line 695
          i ++;
        }
        while_break___34: /* CIL Label */ ;
        }
#line 699
        i = 0;
#line 699
        j___0 = 0;
        {
#line 699
        while (1) {
          while_continue___36: /* CIL Label */ ;
#line 699
          if (! (i < n_root_moves)) {
#line 699
            goto while_break___36;
          }
#line 700
          if (root_moves[i].move != 0) {
#line 701
            tmp___32 = j___0;
#line 701
            j___0 ++;
#line 701
            root_moves[tmp___32] = root_moves[i];
          }
#line 699
          i ++;
        }
        while_break___36: /* CIL Label */ ;
        }
#line 702
        n_root_moves = j___0;
#line 703
        Print(32, "               moves considered {only non-book moves}\n");
#line 704
        nmoves = j___0;
#line 705
        if (nmoves > 1) {
#line 706
          last_pv.pathd = 0;
#line 707
          booking = 1;
#line 708
          Iterate(wtm, booking, 1);
#line 709
          booking = 0;
        } else {
#line 711
          tree->pv[0].path[1] = book_moves[0];
#line 712
          tree->pv[0].pathl = 2;
#line 713
          tree->pv[0].pathd = 0;
        }
#line 715
        return (1);
      } else {
#line 693
        goto _L___36;
      }
    } else {
      _L___36: /* CIL Label */ ;
    }
#line 717
    last_move = nmoves;
#line 727
    tmp___33 = Random32();
#line 727
    which = (int )tmp___33;
#line 728
    tmp___34 = ReadClock();
#line 728
    j___0 = (int )((tmp___34 / 100U) % 13U);
#line 729
    i = 0;
    {
#line 729
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 729
      if (! (i < j___0)) {
#line 729
        goto while_break___37;
      }
#line 730
      tmp___35 = Random32();
#line 730
      which = (int )tmp___35;
#line 729
      i ++;
    }
    while_break___37: /* CIL Label */ ;
    }
#line 731
    total_moves___0 = 0;
#line 732
    i = 0;
    {
#line 732
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 732
      if (! (i < last_move)) {
#line 732
        goto while_break___38;
      }
#line 733
      if (bs_percent[0]) {
#line 734
        total_moves___0 = (int )((float )total_moves___0 + bs_value[i]);
      } else {
#line 736
        total_moves___0 = (int )((float )total_moves___0 + bs_value[i] * bs_value[i]);
      }
#line 732
      i ++;
    }
    while_break___38: /* CIL Label */ ;
    }
#line 738
    if (which > 0) {
#line 738
      tmp___36 = which;
    } else {
#line 738
      tmp___36 = - which;
    }
#line 738
    if (total_moves___0 > 1) {
#line 738
      tmp___37 = total_moves___0;
    } else {
#line 738
      tmp___37 = 1;
    }
#line 738
    distribution = tmp___36 % tmp___37;
#line 739
    which = 0;
    {
#line 739
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 739
      if (! (which < last_move)) {
#line 739
        goto while_break___39;
      }
#line 740
      if (bs_percent[0]) {
#line 741
        distribution = (int )((float )distribution - bs_value[which]);
      } else {
#line 743
        distribution = (int )((float )distribution - bs_value[which] * bs_value[which]);
      }
#line 744
      if (distribution < 0) {
#line 745
        goto while_break___39;
      }
#line 739
      which ++;
    }
    while_break___39: /* CIL Label */ ;
    }
#line 747
    if (which < last_move - 1) {
#line 747
      which = which;
    } else {
#line 747
      which = last_move - 1;
    }
#line 748
    tree->pv[0].path[1] = book_moves[which];
#line 749
    if (total_played > 1) {
#line 749
      tmp___38 = total_played;
    } else {
#line 749
      tmp___38 = 1;
    }
#line 749
    percent_played = (100 * bs_played[which]) / tmp___38;
#line 750
    total_played = bs_played[which];
#line 751
    m1_status = book_status[which];
#line 752
    tree->pv[0].pathl = 2;
#line 753
    tree->pv[0].pathd = 0;
#line 754
    if ((unsigned int )mode != 1U) {
#line 755
      MakeMove(tree, 1, wtm, book_moves[which]);
#line 756
      book_ponder_move = BookPonderMove(tree, wtm ^ 1);
#line 756
      if (book_ponder_move) {
#line 757
        tree->pv[0].path[2] = book_ponder_move;
#line 758
        tree->pv[0].pathl = 3;
      }
#line 760
      UnmakeMove(tree, 1, wtm, book_moves[which]);
    }
#line 762
    book_learn_key = bs_key[which];
#line 763
    Print(32, "               book   0.0s    %3d%%   ", percent_played);
#line 764
    tmp___39 = OutputMove(tree, 1, wtm, tree->pv[0].path[1]);
#line 764
    Print(32, " %s", tmp___39);
#line 765
    st = (m1_status & book_accept_mask) & -225;
#line 766
    if (st) {
#line 767
      if (st & 1) {
#line 768
        Print(32, "??");
      } else
#line 769
      if (st & 2) {
#line 770
        Print(32, "?");
      } else
#line 771
      if (st & 4) {
#line 772
        Print(32, "=");
      } else
#line 773
      if (st & 8) {
#line 774
        Print(32, "!");
      } else
#line 775
      if (st & 16) {
#line 776
        Print(32, "!!");
      }
    }
#line 778
    MakeMove(tree, 1, wtm, tree->pv[0].path[1]);
#line 779
    if (tree->pv[0].pathl > 2) {
#line 780
      tmp___40 = OutputMove(tree, 2, wtm ^ 1, tree->pv[0].path[2]);
#line 780
      Print(32, " %s", tmp___40);
    }
#line 781
    UnmakeMove(tree, 1, wtm, tree->pv[0].path[1]);
#line 782
    Print(32, "\n");
#line 783
    return (1);
  }
#line 785
  return (0);
}
}
#line 802 "book.c"
static unsigned int book_moves___0[200]  ;
#line 800 "book.c"
int BookPonderMove(TREE *tree , int wtm ) 
{ 
  uint64_t temp_hash_key ;
  uint64_t common ;
  int i ;
  int v ;
  int key ;
  int cluster ;
  int n_moves ;
  int im ;
  int played ;
  int tplayed ;
  unsigned int *lastm ;
  int book_ponder_move ;
  int test ;
  unsigned char buf32[4] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 805
  book_ponder_move = 0;
#line 818
  if (book_file) {
#line 819
    test = (int )(tree->position.hash_key >> 49);
#line 820
    fseek(book_file, (long )((unsigned long )test * sizeof(int )), 0);
#line 821
    tmp = fread((void *)(buf32), (size_t )4, (size_t )1, book_file);
#line 821
    v = (int )tmp;
#line 822
    if (v <= 0) {
#line 823
      perror((char const   *)"Book() fread error: ");
    }
#line 824
    key = BookIn32(buf32);
#line 825
    if (key > 0) {
#line 826
      fseek(book_file, (long )key, 0);
#line 827
      tmp___0 = fread((void *)(buf32), (size_t )4, (size_t )1, book_file);
#line 827
      v = (int )tmp___0;
#line 828
      if (v <= 0) {
#line 829
        perror((char const   *)"Book() fread error: ");
      }
#line 830
      cluster = BookIn32(buf32);
#line 831
      if (cluster) {
#line 832
        BookClusterIn(book_file, cluster, book_buffer);
      }
    } else {
#line 834
      cluster = 0;
    }
#line 835
    if (! cluster) {
#line 836
      return (0);
    }
#line 837
    lastm = GenerateCaptures(tree, 2, wtm, book_moves___0);
#line 838
    lastm = GenerateNoncaptures(tree, 2, wtm, lastm);
#line 839
    n_moves = (int )(lastm - book_moves___0);
#line 849
    played = -1;
#line 850
    im = 0;
    {
#line 850
    while (1) {
      while_continue: /* CIL Label */ ;
#line 850
      if (! (im < n_moves)) {
#line 850
        goto while_break;
      }
#line 851
      common = tree->position.hash_key & (65535UL << 48);
#line 852
      MakeMove(tree, 2, wtm, (int )book_moves___0[im]);
#line 853
      if (wtm) {
#line 853
        temp_hash_key = tree->position.hash_key;
      } else {
#line 853
        temp_hash_key = ~ tree->position.hash_key;
      }
#line 854
      temp_hash_key = (temp_hash_key & ~ (65535UL << 48)) | common;
#line 855
      i = 0;
      {
#line 855
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 855
        if (! (i < cluster)) {
#line 855
          goto while_break___0;
        }
#line 856
        if (! (temp_hash_key ^ book_buffer[i].position)) {
#line 857
          tplayed = (int )(book_buffer[i].status_played & 16777215U);
#line 858
          if (tplayed > played) {
#line 859
            played = tplayed;
#line 860
            book_ponder_move = (int )book_moves___0[im];
          }
#line 862
          goto while_break___0;
        }
#line 855
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 865
      UnmakeMove(tree, 2, wtm, (int )book_moves___0[im]);
#line 850
      im ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 868
  return (book_ponder_move);
}
}
#line 924 "book.c"
static char schar[2]  = {      (char )'.',      (char )'\000'};
#line 919 "book.c"
void Bookup(TREE *tree , int nargs___0 , char **args___0 ) 
{ 
  BB_POSITION *bbuffer ;
  uint64_t temp_hash_key ;
  uint64_t common ;
  FILE *book_input ;
  char fname[128] ;
  char start ;
  char *ch ;
  char output_filename[128] ;
  int result ;
  int played ;
  int i ;
  int mask_word ;
  int total_moves___0 ;
  int move ;
  int move_num ;
  int wtm ;
  int book_positions ;
  int major ;
  int minor ;
  int cluster ;
  int max_cluster ;
  int ignored ;
  int ignored_mp ;
  int ignored_lose ;
  int errors ;
  int data_read___0 ;
  int start_elapsed_time ;
  int ply ;
  int max_ply ;
  int stat___0 ;
  int files___0 ;
  int buffered ;
  int min_played ;
  int games_parsed ;
  int wins ;
  int losses ;
  BOOK_POSITION current ;
  BOOK_POSITION next___0 ;
  BB_POSITION temp ;
  int last ;
  int cluster_seek ;
  int next_cluster ;
  int counter ;
  int *index___0 ;
  int max_search_depth ;
  double wl_percent ;
  double tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  void *tmp___28 ;
  long tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  unsigned char *tmp___32 ;
  size_t tmp___33 ;
  long tmp___34 ;
  unsigned char *tmp___35 ;
  size_t tmp___36 ;
  unsigned char *tmp___37 ;
  unsigned char *tmp___38 ;
  unsigned int tmp___39 ;
  char *tmp___40 ;

  {
#line 925
  result = 0;
#line 927
  ignored = 0;
#line 927
  ignored_mp = 0;
#line 927
  ignored_lose = 0;
#line 930
  max_ply = 256;
#line 931
  files___0 = 0;
#line 931
  buffered = 0;
#line 931
  min_played = 0;
#line 931
  games_parsed = 0;
#line 937
  wl_percent = 0.0;
#line 950
  tmp___9 = strcmp((char const   *)*(args___0 + 1), (char const   *)"create");
#line 950
  if (tmp___9) {
#line 967
    tmp___8 = strcmp((char const   *)*(args___0 + 1), (char const   *)"off");
#line 967
    if (tmp___8) {
#line 980
      tmp___7 = strcmp((char const   *)*(args___0 + 1), (char const   *)"on");
#line 980
      if (tmp___7) {
#line 989
        tmp___6 = strcmp((char const   *)*(args___0 + 1), (char const   *)"mask");
#line 989
        if (tmp___6) {
#line 1002
          tmp___5 = strcmp((char const   *)*(args___0 + 1), (char const   *)"random");
#line 1002
          if (tmp___5) {
#line 1022
            tmp___4 = strcmp((char const   *)*(args___0 + 1), (char const   *)"trigger");
#line 1022
            if (tmp___4) {
#line 1031
              tmp___3 = strcmp((char const   *)*(args___0 + 1), (char const   *)"width");
#line 1031
              if (tmp___3) {
#line 1042
                Print(4095, "usage:  book [option] [filename] [maxply] [minplay]\n");
#line 1043
                return;
              } else {
#line 1032
                if (nargs___0 < 3) {
#line 1033
                  Print(4095, "usage:  book width <n>\n");
#line 1034
                  return;
                }
#line 1036
                book_selection_width = atoi((char const   *)*(args___0 + 2));
#line 1037
                book_random = 1;
#line 1038
                Print(4095, "choose from %d best moves.\n", book_selection_width);
#line 1039
                Print(4095, "  ..book random set to 1.\n");
#line 1040
                return;
              }
            } else {
#line 1023
              if (nargs___0 < 3) {
#line 1024
                Print(4095, "usage:  book trigger <n>\n");
#line 1025
                return;
              }
#line 1027
              book_search_trigger = atoi((char const   *)*(args___0 + 2));
#line 1028
              Print(4095, "search book moves if the most popular was not played\n");
#line 1029
              Print(4095, "at least %d times.\n", book_search_trigger);
#line 1030
              return;
            }
          } else {
#line 1003
            if (nargs___0 < 3) {
#line 1004
              Print(4095, "usage:  book random <n>\n");
#line 1005
              return;
            }
#line 1007
            book_random = atoi((char const   *)*(args___0 + 2));
            {
#line 1009
            if (book_random == 0) {
#line 1009
              goto case_0;
            }
#line 1014
            if (book_random == 1) {
#line 1014
              goto case_1;
            }
#line 1017
            goto switch_default;
            case_0: /* CIL Label */ 
#line 1010
            Print(4095, "play best book line after search.\n");
#line 1011
            Print(4095, "  ..book selection width set to 99.\n");
#line 1012
            book_selection_width = 99;
#line 1013
            goto switch_break;
            case_1: /* CIL Label */ 
#line 1015
            Print(4095, "choose from book moves randomly (using weights.)\n");
#line 1016
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 1018
            Print(4095, "valid options are 0-1.\n");
#line 1019
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
#line 1021
            return;
          }
        } else
#line 990
        if (nargs___0 < 4) {
#line 991
          Print(4095, "usage:  book mask accept|reject value\n");
#line 992
          return;
        } else {
#line 993
          tmp___2 = strcmp((char const   *)*(args___0 + 2), (char const   *)"accept");
#line 993
          if (tmp___2) {
#line 997
            tmp___1 = strcmp((char const   *)*(args___0 + 2), (char const   *)"reject");
#line 997
            if (! tmp___1) {
#line 998
              book_reject_mask = BookMask(*(args___0 + 3));
#line 999
              book_accept_mask &= ~ book_reject_mask;
#line 1000
              return;
            }
          } else {
#line 994
            book_accept_mask = BookMask(*(args___0 + 3));
#line 995
            book_reject_mask &= ~ book_accept_mask;
#line 996
            return;
          }
        }
      } else {
#line 981
        if (! book_file) {
#line 982
          sprintf(fname, (char const   *)"%s/book.bin", book_path);
#line 983
          book_file = fopen((char const   * __restrict  )(fname), (char const   * __restrict  )"rb+");
#line 984
          sprintf(fname, (char const   *)"%s/books.bin", book_path);
#line 985
          books_file = fopen((char const   * __restrict  )(fname), (char const   * __restrict  )"rb+");
#line 986
          Print(4095, "book file enabled.\n");
        }
#line 988
        return;
      }
    } else {
#line 968
      if (book_file) {
#line 969
        fclose(book_file);
      }
#line 970
      if (books_file) {
#line 971
        fclose(normal_bs_file);
      }
#line 972
      if (computer_bs_file) {
#line 973
        fclose(computer_bs_file);
      }
#line 974
      book_file = (FILE *)0;
#line 975
      books_file = (FILE *)0;
#line 976
      computer_bs_file = (FILE *)0;
#line 977
      normal_bs_file = (FILE *)0;
#line 978
      Print(4095, "book file disabled.\n");
#line 979
      return;
    }
  } else {
#line 951
    if (nargs___0 < 4) {
#line 952
      Print(4095, "usage:  <binfile> create <pgn-filename> ");
#line 953
      Print(4095, "maxply [minplay] [win/lose %%]\n");
#line 954
      return;
    }
#line 956
    max_ply = atoi((char const   *)*(args___0 + 3));
#line 957
    if (nargs___0 >= 5) {
#line 958
      min_played = atoi((char const   *)*(args___0 + 4));
    }
#line 960
    if (nargs___0 > 5) {
#line 961
      tmp = atof((char const   *)*(args___0 + 5));
#line 961
      wl_percent = tmp / 100.0;
    }
#line 963
    strcpy(output_filename, (char const   *)*(args___0 + 0));
#line 964
    tmp___0 = strstr((char const   *)(output_filename), (char const   *)".bin");
#line 964
    if (! tmp___0) {
#line 965
      strcat(output_filename, (char const   *)".bin");
    }
  }
#line 1045
  book_input = fopen((char const   * __restrict  )*(args___0 + 2), (char const   * __restrict  )"r");
#line 1045
  if (! book_input) {
#line 1046
    printf((char const   *)"file %s does not exist.\n", *(args___0 + 2));
#line 1047
    return;
  }
#line 1049
  ReadPGN((FILE *)0, 0);
#line 1050
  if (book_file) {
#line 1051
    fclose(book_file);
  }
#line 1052
  book_file = fopen((char const   * __restrict  )(output_filename), (char const   * __restrict  )"wb+");
#line 1053
  tmp___10 = malloc(sizeof(BB_POSITION ) * 4000000UL);
#line 1053
  bbuffer = (BB_POSITION *)tmp___10;
#line 1054
  if (! bbuffer) {
#line 1055
    Print(4095, "Unable to malloc() sort buffer, aborting\n");
#line 1056
    CraftyExit(1);
  }
#line 1058
  fseek(book_file, 0L, 0);
#line 1074
  major = atoi((char const   *)(version));
#line 1075
  tmp___11 = strchr((char const   *)(version), '.');
#line 1075
  minor = atoi((char const   *)(tmp___11 + 1));
#line 1076
  major = (major << 16) + minor;
#line 1077
  tmp___12 = strstr((char const   *)(output_filename), (char const   *)"book.bin");
#line 1077
  if (tmp___12) {
#line 1077
    tmp___13 = 0;
  } else {
#line 1077
    tmp___13 = 1;
  }
#line 1077
  start = (char )tmp___13;
#line 1078
  printf((char const   *)"parsing pgn move file (100k moves/dot)\n");
#line 1079
  tmp___14 = ReadClock();
#line 1079
  start_elapsed_time = (int )tmp___14;
#line 1080
  if (book_file) {
#line 1081
    total_moves___0 = 0;
#line 1082
    max_search_depth = 0;
#line 1083
    errors = 0;
    {
#line 1084
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1085
      data_read___0 = ReadPGN(book_input, 0);
#line 1086
      if (data_read___0 == -1) {
#line 1087
        Print(4095, "end-of-file reached\n");
      }
#line 1084
      if (! (data_read___0 == 0)) {
#line 1084
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1089
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1090
      if (data_read___0 < 0) {
#line 1091
        Print(4095, "end-of-file reached\n");
#line 1092
        goto while_break___0;
      }
#line 1094
      if (data_read___0 == 1) {
#line 1095
        tmp___20 = strstr((char const   *)(buffer), (char const   *)"Site");
#line 1095
        if (tmp___20) {
#line 1096
          games_parsed ++;
#line 1097
          result = 3;
        } else {
#line 1098
          tmp___19 = strstr((char const   *)(buffer), (char const   *)"esult");
#line 1098
          if (tmp___19) {
#line 1099
            tmp___18 = strstr((char const   *)(buffer), (char const   *)"1-0");
#line 1099
            if (tmp___18) {
#line 1100
              result = 2;
            } else {
#line 1101
              tmp___17 = strstr((char const   *)(buffer), (char const   *)"0-1");
#line 1101
              if (tmp___17) {
#line 1102
                result = 1;
              } else {
#line 1103
                tmp___16 = strstr((char const   *)(buffer), (char const   *)"1/2-1/2");
#line 1103
                if (tmp___16) {
#line 1104
                  result = 0;
                } else {
#line 1105
                  tmp___15 = strstr((char const   *)(buffer), (char const   *)"*");
#line 1105
                  if (tmp___15) {
#line 1106
                    result = 3;
                  }
                }
              }
            }
          }
        }
#line 1108
        data_read___0 = ReadPGN(book_input, 0);
      } else {
        {
#line 1110
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1111
          wtm = 1;
#line 1112
          InitializeChessBoard(tree);
#line 1113
          tree->status[1] = tree->status[0];
#line 1114
          move_num = 1;
#line 1115
          tree->status[2] = tree->status[1];
#line 1116
          ply = 0;
#line 1117
          data_read___0 = 0;
          {
#line 1124
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1124
            if (! (data_read___0 == 0)) {
#line 1124
              goto while_break___2;
            }
#line 1125
            mask_word = 0;
#line 1126
            ch = strpbrk((char const   *)(buffer), (char const   *)"?!");
#line 1126
            if (ch) {
#line 1127
              mask_word = BookMask(ch);
#line 1128
              *ch = (char)0;
            }
#line 1130
            tmp___25 = strchr((char const   *)(buffer), '$');
#line 1130
            if (tmp___25) {
              _L___0: /* CIL Label */ ;
            } else {
#line 1130
              tmp___26 = strchr((char const   *)(buffer), '*');
#line 1130
              if (tmp___26) {
#line 1130
                goto _L___0;
              } else {
#line 1131
                if (ply < max_ply) {
#line 1132
                  move = ReadNextMove(tree, buffer, 2, wtm);
                } else {
#line 1134
                  move = 0;
#line 1135
                  ignored ++;
                }
#line 1137
                if (move) {
#line 1138
                  ply ++;
#line 1139
                  if (max_search_depth > ply) {
#line 1139
                    max_search_depth = max_search_depth;
                  } else {
#line 1139
                    max_search_depth = ply;
                  }
#line 1140
                  total_moves___0 ++;
#line 1141
                  common = tree->position.hash_key & (65535UL << 48);
#line 1142
                  MakeMove(tree, 2, wtm, move);
#line 1143
                  tree->status[2] = tree->status[3];
#line 1144
                  if (ply <= max_ply) {
#line 1145
                    if (wtm) {
#line 1145
                      temp_hash_key = tree->position.hash_key;
                    } else {
#line 1145
                      temp_hash_key = ~ tree->position.hash_key;
                    }
#line 1146
                    temp_hash_key = (temp_hash_key & ~ (65535UL << 48)) | common;
#line 1148
                    memcpy((void *)((bbuffer + buffered)->position), (void const   *)((char *)(& temp_hash_key)),
                           (size_t )8);
#line 1150
                    if (result & 1) {
#line 1151
                      mask_word |= 0x20;
                    }
#line 1152
                    if (result == 0) {
#line 1153
                      mask_word |= 0x40;
                    }
#line 1154
                    if (result & 2) {
#line 1155
                      mask_word |= 0x80;
                    }
#line 1156
                    (bbuffer + buffered)->status = (unsigned char )mask_word;
#line 1157
                    tmp___21 = buffered;
#line 1157
                    buffered ++;
#line 1157
                    (bbuffer + tmp___21)->percent_play = (unsigned char )(pgn_suggested_percent + (wtm << 7));
#line 1159
                    if (buffered >= 4000000) {
#line 1160
                      files___0 ++;
#line 1160
                      BookSort(bbuffer, buffered, files___0);
#line 1161
                      buffered = 0;
#line 1162
                      strcpy(schar, (char const   *)"S");
                    }
                  }
#line 1165
                  if (! (total_moves___0 % 100000)) {
#line 1166
                    printf((char const   *)"%s", schar);
#line 1167
                    strcpy(schar, (char const   *)".");
#line 1168
                    if (! (total_moves___0 % 6000000)) {
#line 1169
                      printf((char const   *)" (%dk)\n", total_moves___0 / 1000);
                    }
#line 1170
                    fflush(stdout);
                  }
#line 1172
                  wtm ^= 1;
#line 1173
                  if (wtm) {
#line 1174
                    move_num ++;
                  }
                } else {
#line 1198
                  tmp___23 = strspn((char const   *)(buffer), (char const   *)"0123456789/-.*");
#line 1198
                  tmp___24 = strlen((char const   *)(buffer));
#line 1198
                  if (tmp___23 != tmp___24) {
#line 1198
                    if (ply < max_ply) {
#line 1200
                      errors ++;
#line 1201
                      tmp___22 = ReadPGN(book_input, -2);
#line 1201
                      Print(4095, "ERROR!  move %d: %s is illegal (line %d)\n", move_num,
                            buffer, tmp___22);
#line 1203
                      ReadPGN(book_input, -1);
#line 1204
                      DisplayChessBoard(stdout, tree->position);
                      {
#line 1205
                      while (1) {
                        while_continue___3: /* CIL Label */ ;
#line 1206
                        data_read___0 = ReadPGN(book_input, 0);
#line 1207
                        if (data_read___0 == -1) {
#line 1208
                          Print(4095, "end-of-file reached\n");
                        }
#line 1205
                        if (! (data_read___0 == 0)) {
#line 1205
                          goto while_break___3;
                        }
                      }
                      while_break___3: /* CIL Label */ ;
                      }
#line 1210
                      goto while_break___2;
                    } else {
#line 1198
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ ;
                  }
                }
              }
            }
#line 1213
            data_read___0 = ReadPGN(book_input, 0);
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1215
          strcpy(initial_position, (char const   *)"");
#line 1110
          if (! 0) {
#line 1110
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1089
      tmp___27 = strcmp((char const   *)(buffer), (char const   *)"end");
#line 1089
      if (tmp___27) {
#line 1089
        if (! (data_read___0 != -1)) {
#line 1089
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 1089
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1218
    if ((unsigned long )book_input != (unsigned long )stdin) {
#line 1219
      fclose(book_input);
    }
#line 1220
    if (buffered) {
#line 1221
      files___0 ++;
#line 1221
      BookSort(bbuffer, buffered, files___0);
    }
#line 1222
    free((void *)bbuffer);
#line 1223
    printf((char const   *)"S  <done>\n");
#line 1224
    if (total_moves___0 == 0) {
#line 1225
      Print(4095, "ERROR - empty input PGN file\n");
#line 1226
      return;
    }
#line 1237
    printf((char const   *)"merging sorted files (%d) (100k/dot)\n", files___0);
#line 1238
    counter = 0;
#line 1239
    tmp___28 = malloc(32768UL * sizeof(int ));
#line 1239
    index___0 = (int *)tmp___28;
#line 1240
    if (! index___0) {
#line 1241
      Print(4095, "Unable to malloc() index block, aborting\n");
#line 1242
      CraftyExit(1);
    }
#line 1244
    i = 0;
    {
#line 1244
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1244
      if (! (i < 32768)) {
#line 1244
        goto while_break___4;
      }
#line 1245
      *(index___0 + i) = -1;
#line 1244
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1246
    temp = BookupNextPosition(files___0, 1);
#line 1247
    memcpy((void *)((char *)(& current.position)), (void const   *)(temp.position),
           (size_t )8);
#line 1248
    current.status_played = (unsigned int )((int )temp.status << 24);
#line 1249
    if (start) {
#line 1250
      current.status_played += (unsigned int )((int )temp.percent_play & 127);
    }
#line 1251
    current.learn = (float )0.0;
#line 1252
    played = 1;
#line 1253
    fclose(book_file);
#line 1254
    book_file = fopen((char const   * __restrict  )(output_filename), (char const   * __restrict  )"wb+");
#line 1255
    fseek(book_file, (long )(sizeof(int ) * 32768UL), 0);
#line 1256
    last = (int )(current.position >> 49);
#line 1257
    tmp___29 = ftell(book_file);
#line 1257
    *(index___0 + last) = (int )tmp___29;
#line 1258
    book_positions = 0;
#line 1259
    cluster = 0;
#line 1260
    cluster_seek = (int )(sizeof(int ) * 32768UL);
#line 1261
    fseek(book_file, (long )((unsigned long )cluster_seek + sizeof(int )), 0);
#line 1262
    max_cluster = 0;
#line 1263
    wins = 0;
#line 1264
    losses = 0;
#line 1265
    if ((int )temp.status & 128) {
#line 1265
      if ((int )temp.percent_play & 128) {
#line 1266
        wins ++;
      } else {
#line 1265
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ ;
    }
#line 1267
    if ((int )temp.status & 128) {
#line 1267
      if (! ((int )temp.percent_play & 128)) {
#line 1268
        losses ++;
      } else {
#line 1267
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ ;
    }
#line 1269
    if ((int )temp.status & 32) {
#line 1269
      if (! ((int )temp.percent_play & 128)) {
#line 1270
        wins ++;
      } else {
#line 1269
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ ;
    }
#line 1271
    if ((int )temp.status & 32) {
#line 1271
      if ((int )temp.percent_play & 128) {
#line 1272
        losses ++;
      } else {
#line 1271
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ ;
    }
    {
#line 1273
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1273
      if (! 1) {
#line 1273
        goto while_break___5;
      }
#line 1274
      temp = BookupNextPosition(files___0, 0);
#line 1275
      memcpy((void *)((char *)(& next___0.position)), (void const   *)(temp.position),
             (size_t )8);
#line 1276
      next___0.status_played = (unsigned int )((int )temp.status << 24);
#line 1277
      if (start) {
#line 1278
        next___0.status_played += (unsigned int )((int )temp.percent_play & 127);
      }
#line 1279
      next___0.learn = (float )0.0;
#line 1280
      counter ++;
#line 1281
      if (counter % 100000 == 0) {
#line 1282
        printf((char const   *)".");
#line 1283
        if (counter % 6000000 == 0) {
#line 1284
          printf((char const   *)" (%dk)\n", counter / 1000);
        }
#line 1285
        fflush(stdout);
      }
#line 1287
      if (current.position == next___0.position) {
#line 1288
        current.status_played |= next___0.status_played;
#line 1289
        played ++;
#line 1290
        if ((int )temp.status & 128) {
#line 1290
          if ((int )temp.percent_play & 128) {
#line 1291
            wins ++;
          } else {
#line 1290
            goto _L___6;
          }
        } else {
          _L___6: /* CIL Label */ ;
        }
#line 1292
        if ((int )temp.status & 128) {
#line 1292
          if (! ((int )temp.percent_play & 128)) {
#line 1293
            losses ++;
          } else {
#line 1292
            goto _L___7;
          }
        } else {
          _L___7: /* CIL Label */ ;
        }
#line 1294
        if ((int )temp.status & 32) {
#line 1294
          if (! ((int )temp.percent_play & 128)) {
#line 1295
            wins ++;
          } else {
#line 1294
            goto _L___8;
          }
        } else {
          _L___8: /* CIL Label */ ;
        }
#line 1296
        if ((int )temp.status & 32) {
#line 1296
          if ((int )temp.percent_play & 128) {
#line 1297
            losses ++;
          } else {
#line 1296
            goto _L___9;
          }
        } else {
          _L___9: /* CIL Label */ ;
        }
      } else {
#line 1299
        if (played >= min_played) {
#line 1299
          if ((double )wins >= (double )losses * wl_percent) {
#line 1300
            book_positions ++;
#line 1301
            cluster ++;
#line 1302
            if (max_cluster > cluster) {
#line 1302
              max_cluster = max_cluster;
            } else {
#line 1302
              max_cluster = cluster;
            }
#line 1303
            if (! start) {
#line 1304
              current.status_played += (unsigned int )played;
            }
#line 1305
            current.learn = (float )0.0;
#line 1306
            tmp___30 = BookOut64(current.position);
#line 1306
            memcpy((void *)(& book_buffer_char[0].position), (void const   *)((void *)tmp___30),
                   (size_t )8);
#line 1308
            tmp___31 = BookOut32((int )current.status_played);
#line 1308
            memcpy((void *)(& book_buffer_char[0].status_played), (void const   *)((void *)tmp___31),
                   (size_t )4);
#line 1310
            tmp___32 = BookOut32((int )current.learn);
#line 1310
            memcpy((void *)(& book_buffer_char[0].learn), (void const   *)((void *)tmp___32),
                   (size_t )4);
#line 1312
            tmp___33 = fwrite((void const   * __restrict  )(book_buffer_char), sizeof(BOOK_POSITION ),
                              (size_t )1, (FILE * __restrict  )book_file);
#line 1312
            stat___0 = (int )tmp___33;
#line 1314
            if (stat___0 != 1) {
#line 1315
              Print(4095, "ERROR!  write failed, disk probably full.\n");
            }
          } else {
#line 1299
            goto _L___10;
          }
        } else
        _L___10: /* CIL Label */ 
#line 1316
        if (played < min_played) {
#line 1317
          ignored_mp ++;
        } else {
#line 1319
          ignored_lose ++;
        }
#line 1320
        if (last != (int )(next___0.position >> 49)) {
#line 1321
          tmp___34 = ftell(book_file);
#line 1321
          next_cluster = (int )tmp___34;
#line 1322
          fseek(book_file, (long )cluster_seek, 0);
#line 1323
          tmp___35 = BookOut32(cluster);
#line 1323
          memcpy((void *)(& cluster), (void const   *)tmp___35, (size_t )4);
#line 1324
          tmp___36 = fwrite((void const   * __restrict  )(& cluster), sizeof(int ),
                            (size_t )1, (FILE * __restrict  )book_file);
#line 1324
          stat___0 = (int )tmp___36;
#line 1325
          if (stat___0 != 1) {
#line 1326
            Print(4095, "ERROR!  write failed, disk probably full.\n");
          }
#line 1327
          if (next___0.position == 0UL) {
#line 1328
            goto while_break___5;
          }
#line 1329
          fseek(book_file, (long )((unsigned long )next_cluster + sizeof(int )), 0);
#line 1330
          cluster_seek = next_cluster;
#line 1331
          last = (int )(next___0.position >> 49);
#line 1332
          *(index___0 + last) = next_cluster;
#line 1333
          cluster = 0;
        }
#line 1335
        wins = 0;
#line 1336
        losses = 0;
#line 1337
        if ((int )temp.status & 128) {
#line 1337
          if ((int )temp.percent_play & 128) {
#line 1338
            wins ++;
          } else {
#line 1337
            goto _L___11;
          }
        } else {
          _L___11: /* CIL Label */ ;
        }
#line 1339
        if ((int )temp.status & 128) {
#line 1339
          if (! ((int )temp.percent_play & 128)) {
#line 1340
            losses ++;
          } else {
#line 1339
            goto _L___12;
          }
        } else {
          _L___12: /* CIL Label */ ;
        }
#line 1341
        if ((int )temp.status & 32) {
#line 1341
          if (! ((int )temp.percent_play & 128)) {
#line 1342
            wins ++;
          } else {
#line 1341
            goto _L___13;
          }
        } else {
          _L___13: /* CIL Label */ ;
        }
#line 1343
        if ((int )temp.status & 32) {
#line 1343
          if ((int )temp.percent_play & 128) {
#line 1344
            losses ++;
          } else {
#line 1343
            goto _L___14;
          }
        } else {
          _L___14: /* CIL Label */ ;
        }
#line 1345
        current = next___0;
#line 1346
        played = 1;
#line 1347
        if (next___0.position == 0UL) {
#line 1348
          goto while_break___5;
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1351
    fseek(book_file, 0L, 0);
#line 1352
    i = 0;
    {
#line 1352
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1352
      if (! (i < 32768)) {
#line 1352
        goto while_break___6;
      }
#line 1353
      tmp___37 = BookOut32(*(index___0 + i));
#line 1353
      memcpy((void *)(& cluster), (void const   *)((void *)tmp___37), (size_t )4);
#line 1354
      fwrite((void const   * __restrict  )(& cluster), (size_t )4, (size_t )1, (FILE * __restrict  )book_file);
#line 1352
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1356
    fseek(book_file, 0L, 2);
#line 1357
    tmp___38 = BookOut32(major);
#line 1357
    memcpy((void *)(& cluster), (void const   *)((void *)tmp___38), (size_t )4);
#line 1358
    fwrite((void const   * __restrict  )(& cluster), (size_t )4, (size_t )1, (FILE * __restrict  )book_file);
#line 1367
    i = 1;
    {
#line 1367
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1367
      if (! (i <= files___0)) {
#line 1367
        goto while_break___7;
      }
#line 1368
      sprintf(fname, (char const   *)"sort.%d", i);
#line 1369
      remove((char const   *)(fname));
#line 1367
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1371
    free((void *)index___0);
#line 1372
    tmp___39 = ReadClock();
#line 1372
    start_elapsed_time = (int )(tmp___39 - (unsigned int )start_elapsed_time);
#line 1373
    Print(4095, "\n\nparsed %d moves (%d games).\n", total_moves___0, games_parsed);
#line 1375
    Print(4095, "found %d errors during parsing.\n", errors);
#line 1376
    Print(4095, "ignored %d moves (maxply=%d).\n", ignored, max_ply);
#line 1377
    Print(4095, "ignored %d moves (minplayed=%d).\n", ignored_mp, min_played);
#line 1379
    Print(4095, "ignored %d moves (win/lose=%.1f%%).\n", ignored_lose, wl_percent * (double )100);
#line 1381
    Print(4095, "book contains %d unique positions.\n", book_positions);
#line 1382
    Print(4095, "deepest book line was %d plies.\n", max_search_depth);
#line 1383
    Print(4095, "longest cluster of moves was %d.\n", max_cluster);
#line 1384
    tmp___40 = DisplayTime((unsigned int )start_elapsed_time);
#line 1384
    Print(4095, "time used:  %s elapsed.\n", tmp___40);
  }
#line 1386
  strcpy(initial_position, (char const   *)"");
#line 1387
  InitializeChessBoard(tree);
#line 1388
  return;
}
}
#line 1400 "book.c"
int BookMask(char *flags ) 
{ 
  int i ;
  int mask ;
  size_t tmp ;

  {
#line 1403
  mask = 0;
#line 1404
  i = 0;
  {
#line 1404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1404
    tmp = strlen((char const   *)flags);
#line 1404
    if (! (i < (int )tmp)) {
#line 1404
      goto while_break;
    }
#line 1405
    if ((int )*(flags + i) == 63) {
#line 1406
      if ((int )*(flags + (i + 1)) == 63) {
#line 1407
        mask |= 1;
#line 1408
        i ++;
      } else {
#line 1410
        mask |= 2;
      }
    } else
#line 1411
    if ((int )*(flags + i) == 61) {
#line 1412
      mask |= 4;
    } else
#line 1413
    if ((int )*(flags + i) == 33) {
#line 1414
      if ((int )*(flags + (i + 1)) == 33) {
#line 1415
        mask |= 16;
#line 1416
        i ++;
      } else {
#line 1418
        mask |= 8;
      }
    }
#line 1404
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1421
  return (mask);
}
}
#line 1433 "book.c"
void BookSort(BB_POSITION *buffer___3 , int number , int fileno___0 ) 
{ 
  char fname[16] ;
  FILE *output_file ;
  int stat___0 ;
  size_t tmp ;

  {
#line 1438
  qsort((void *)((char *)buffer___3), (size_t )number, sizeof(BB_POSITION ), & BookupCompare);
#line 1439
  sprintf(fname, (char const   *)"sort.%d", fileno___0);
#line 1440
  output_file = fopen((char const   * __restrict  )(fname), (char const   * __restrict  )"wb+");
#line 1440
  if (! output_file) {
#line 1441
    printf((char const   *)"ERROR.  unable to open sort output file\n");
  }
#line 1442
  tmp = fwrite((void const   * __restrict  )buffer___3, sizeof(BB_POSITION ), (size_t )number,
               (FILE * __restrict  )output_file);
#line 1442
  stat___0 = (int )tmp;
#line 1443
  if (stat___0 != number) {
#line 1444
    Print(4095, "ERROR!  write failed, disk probably full.\n");
  }
#line 1445
  fclose(output_file);
#line 1446
  return;
}
}
#line 1461 "book.c"
static FILE *input_file[100]  ;
#line 1462 "book.c"
static BB_POSITION *buffer___2[100]  ;
#line 1463 "book.c"
static int data_read[100]  ;
#line 1463 "book.c"
static int next[100]  ;
#line 1459 "book.c"
BB_POSITION BookupNextPosition(int files___0 , int init___0 ) 
{ 
  char fname[20] ;
  int i ;
  int used ;
  BB_POSITION least ;
  FILE *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  uint64_t p1___0 ;
  uint64_t p2___0 ;
  size_t tmp___2 ;

  {
#line 1467
  if (init___0) {
#line 1468
    i = 1;
    {
#line 1468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1468
      if (! (i <= files___0)) {
#line 1468
        goto while_break;
      }
#line 1469
      sprintf(fname, (char const   *)"sort.%d", i);
#line 1470
      tmp = fopen((char const   * __restrict  )(fname), (char const   * __restrict  )"rb");
#line 1470
      input_file[i] = tmp;
#line 1470
      if (! tmp) {
#line 1471
        printf((char const   *)"unable to open sort.%d file, may be too many files open.\n",
               i);
#line 1473
        CraftyExit(1);
      }
#line 1475
      tmp___0 = malloc(sizeof(BB_POSITION ) * 1000UL);
#line 1475
      buffer___2[i] = (BB_POSITION *)tmp___0;
#line 1476
      if (! buffer___2[i]) {
#line 1477
        printf((char const   *)"out of memory.  aborting. \n");
#line 1478
        CraftyExit(1);
      }
#line 1480
      fseek(input_file[i], 0L, 0);
#line 1481
      tmp___1 = fread((void *)buffer___2[i], sizeof(BB_POSITION ), (size_t )1000,
                      input_file[i]);
#line 1481
      data_read[i] = (int )tmp___1;
#line 1483
      next[i] = 0;
#line 1468
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1486
  i = 0;
  {
#line 1486
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1486
    if (! (i < 8)) {
#line 1486
      goto while_break___0;
    }
#line 1487
    least.position[i] = (unsigned char)0;
#line 1486
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1488
  least.status = (unsigned char)0;
#line 1489
  least.percent_play = (unsigned char)0;
#line 1490
  used = -1;
#line 1491
  i = 1;
  {
#line 1491
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1491
    if (! (i <= files___0)) {
#line 1491
      goto while_break___1;
    }
#line 1492
    if (data_read[i]) {
#line 1493
      least = *(buffer___2[i] + next[i]);
#line 1494
      used = i;
#line 1495
      goto while_break___1;
    }
#line 1491
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1497
  if (i > files___0) {
#line 1498
    i = 1;
    {
#line 1498
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1498
      if (! (i <= files___0)) {
#line 1498
        goto while_break___2;
      }
#line 1499
      fclose(input_file[i]);
#line 1498
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1500
    return (least);
  }
#line 1502
  i ++;
  {
#line 1502
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1502
    if (! (i <= files___0)) {
#line 1502
      goto while_break___3;
    }
#line 1503
    if (data_read[i]) {
#line 1506
      memcpy((void *)((char *)(& p1___0)), (void const   *)(least.position), (size_t )8);
#line 1507
      memcpy((void *)((char *)(& p2___0)), (void const   *)((buffer___2[i] + next[i])->position),
             (size_t )8);
#line 1508
      if (p1___0 > p2___0) {
#line 1509
        least = *(buffer___2[i] + next[i]);
#line 1510
        used = i;
      }
    }
#line 1502
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1514
  (data_read[used]) --;
#line 1514
  if (data_read[used] == 0) {
#line 1515
    tmp___2 = fread((void *)buffer___2[used], sizeof(BB_POSITION ), (size_t )1000,
                    input_file[used]);
#line 1515
    data_read[used] = (int )tmp___2;
#line 1518
    next[used] = 0;
  } else {
#line 1520
    (next[used]) ++;
  }
#line 1521
  return (least);
}
}
#line 1525 "book.c"
static uint64_t p1  ;
#line 1525 "book.c"
static uint64_t p2  ;
#line 1524 "book.c"
int BookupCompare(void const   *pos1 , void const   *pos2 ) 
{ 


  {
#line 1527
  memcpy((void *)((char *)(& p1)), (void const   *)(((BB_POSITION *)pos1)->position),
         (size_t )8);
#line 1528
  memcpy((void *)((char *)(& p2)), (void const   *)(((BB_POSITION *)pos2)->position),
         (size_t )8);
#line 1529
  if (p1 < p2) {
#line 1530
    return (-1);
  }
#line 1531
  if (p1 > p2) {
#line 1532
    return (1);
  }
#line 1533
  return (0);
}
}
#line 46 "autotune.c"
void AutoTune(int nargs___0 , char **args___0 ) 
{ 
  unsigned int target_time ;
  unsigned int accuracy ;
  unsigned int atstart ;
  unsigned int atend ;
  unsigned int time___0 ;
  unsigned int current ;
  unsigned int setting[64] ;
  unsigned int times___0[64] ;
  unsigned int last_time ;
  unsigned int stageii ;
  int benchd ;
  int i ;
  int v ;
  int p ;
  int best ;
  int bestv ;
  int samples ;
  FILE *craftyrc ;
  FILE *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 47
  target_time = 3000U;
#line 47
  accuracy = 4U;
#line 50
  tmp = fopen((char const   * __restrict  )".craftyrc", (char const   * __restrict  )"a");
#line 50
  craftyrc = tmp;
#line 59
  if (smp_max_threads < 2U) {
#line 60
    Print(4095, "ERROR: smpmt must be set to > 1 for tuning to work\n");
#line 61
    fclose(craftyrc);
#line 62
    return;
  }
#line 64
  if (nargs___0 > 1) {
#line 65
    tmp___0 = atoi((char const   *)*(args___0 + 1));
#line 65
    target_time = (unsigned int )(tmp___0 * 100);
  }
#line 66
  if (nargs___0 > 2) {
#line 67
    tmp___1 = atoi((char const   *)*(args___0 + 2));
#line 67
    accuracy = (unsigned int )tmp___1;
  }
#line 68
  tmp___2 = DisplayHHMMSS(target_time);
#line 68
  Print(4095, "AutoTune()  time=%s  accuracy=%d\n", tmp___2, accuracy);
#line 83
  atstart = ReadClock();
#line 84
  stageii = 0U;
#line 85
  v = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (v < autotune_params)) {
#line 85
      goto while_break;
    }
#line 86
    current = tune[v].min;
    {
#line 86
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 86
      if (! (current <= tune[v].max)) {
#line 86
        goto while_break___0;
      }
#line 88
      stageii ++;
#line 86
      current += tune[v].increment;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 85
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  Print(4095, "Calculating optimal benchmark setting.\n");
#line 90
  tmp___3 = DisplayHHMMSS(6U * target_time);
#line 90
  Print(4095, "Target time average = %s.\n", tmp___3);
#line 91
  tmp___4 = DisplayHHMMSS((accuracy * 12U) * target_time);
#line 91
  Print(4095, "Estimated run time (stage I) is %s.\n", tmp___4);
#line 93
  tmp___5 = DisplayHHMMSS(((accuracy * stageii) * 4U) * target_time);
#line 93
  Print(4095, "Estimated run time (stage II) is %s.\n", tmp___5);
#line 95
  Print(4095, "\nBegin stage I (calibration)\n");
#line 96
  last_time = 0U;
#line 97
  benchd = -5;
  {
#line 97
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 97
    if (! (benchd < 10)) {
#line 97
      goto while_break___1;
    }
#line 98
    Print(4095, "bench %2d:", benchd);
#line 99
    time___0 = 0U;
#line 100
    v = 0;
    {
#line 100
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 100
      if (! ((unsigned int )v < accuracy)) {
#line 100
        goto while_break___2;
      }
#line 101
      tmp___6 = Bench(benchd, 1);
#line 101
      time___0 += (unsigned int )tmp___6;
#line 100
      v ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 102
    time___0 /= accuracy;
#line 103
    tmp___7 = DisplayHHMMSS(time___0);
#line 103
    Print(4095, " ->%s\n", tmp___7);
#line 104
    if (time___0 > 6U * target_time) {
#line 105
      goto while_break___1;
    }
#line 106
    last_time = time___0;
#line 97
    benchd ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 108
  benchd --;
#line 109
  Print(4095, "Optimal setting is bench %d\n", benchd);
#line 110
  atend = ReadClock();
#line 111
  tmp___8 = DisplayHHMMSS(atend - atstart);
#line 111
  Print(4095, "Actual runtime for Stage I: %s\n", tmp___8);
#line 113
  tmp___9 = DisplayHHMMSS((accuracy * stageii) * last_time);
#line 113
  Print(4095, "New estimated run time (stage II) is %s.\n", tmp___9);
#line 115
  Print(4095, "\nBegin stage II (SMP testing).\n");
#line 116
  atstart = ReadClock();
#line 135
  v = 0;
  {
#line 135
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 135
    if (! (v < autotune_params)) {
#line 135
      goto while_break___3;
    }
#line 136
    Print(4095, "auto-tuning %s (%d ~ %d by %d)\n", tune[v].description, tune[v].min,
          tune[v].max, tune[v].increment);
#line 138
    current = *(tune[v].parameter);
#line 139
    samples = 0;
#line 140
    if (v == 0) {
#line 140
      if (tune[v].min > smp_max_threads) {
#line 141
        samples = 1;
#line 142
        times___0[0] = 0U;
#line 143
        setting[0] = smp_max_threads;
      } else {
#line 140
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 145
      current = tune[v].min;
      {
#line 145
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 145
        if (! (current <= tune[v].max)) {
#line 145
          goto while_break___4;
        }
#line 147
        Print(4095, "Testing %d: ", current);
#line 148
        *(tune[v].parameter) = current;
#line 149
        time___0 = 0U;
#line 150
        p = 0;
        {
#line 150
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 150
          if (! ((unsigned int )p < accuracy)) {
#line 150
            goto while_break___5;
          }
#line 151
          tmp___10 = Bench(benchd, 1);
#line 151
          time___0 += (unsigned int )tmp___10;
#line 150
          p ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 152
        time___0 /= accuracy;
#line 153
        times___0[samples] = time___0;
#line 154
        tmp___11 = samples;
#line 154
        samples ++;
#line 154
        setting[tmp___11] = current;
#line 155
        tmp___12 = DisplayHHMMSS(time___0);
#line 155
        Print(4095, " ->%s\n", tmp___12);
#line 145
        current += tune[v].increment;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 157
    best = 0;
#line 158
    bestv = (int )times___0[0];
#line 159
    i = 1;
    {
#line 159
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 159
      if (! (i < samples)) {
#line 159
        goto while_break___6;
      }
#line 160
      if ((unsigned int )bestv > times___0[i]) {
#line 161
        bestv = (int )times___0[i];
#line 162
        best = i;
      }
#line 159
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 164
    fprintf(craftyrc, (char const   *)"%s=%d\n", tune[v].command, setting[best]);
#line 165
    Print(4095, "adding %s=%d to .craftyrc file.\n", tune[v].command, setting[best]);
#line 135
    v ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 168
  atend = ReadClock();
#line 169
  tmp___13 = DisplayHHMMSS(atend - atstart);
#line 169
  Print(4095, "Runtime for StageII: %s\n", tmp___13);
#line 170
  fclose(craftyrc);
#line 171
  return;
}
}
#line 19 "analyze.c"
void Analyze(void) 
{ 
  int i ;
  int v ;
  int move ;
  int back_number ;
  int readstat ;
  TREE *tree ;
  int save_swindle_mode ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *outmove ;
  char *tmp___2 ;
  char announce[64] ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 20
  readstat = 1;
#line 21
  tree = (TREE *)block[0];
#line 30
  save_swindle_mode = swindle_mode;
#line 32
  swindle_mode = 0;
#line 33
  ponder_move = 0;
#line 34
  analyze_mode = 1;
#line 35
  if (! xboard) {
#line 36
    display_options |= 7;
  }
#line 37
  printf((char const   *)"Analyze Mode: type \"exit\" to terminate.\n");
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! 1) {
#line 46
      goto while_break;
    }
    {
#line 47
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 48
      last_pv.pathd = 0;
#line 49
      last_pv.pathl = 0;
#line 50
      input_status = 0;
#line 51
      pondering = 1;
#line 52
      tree->status[1] = tree->status[0];
#line 53
      Iterate(game_wtm, 1, 0);
#line 54
      pondering = 0;
#line 55
      if (book_move) {
#line 56
        moves_out_of_book = 0;
      }
#line 57
      if (! xboard) {
#line 58
        if (game_wtm) {
#line 59
          printf((char const   *)"analyze.White(%d): ", move_number);
        } else {
#line 61
          printf((char const   *)"analyze.Black(%d): ", move_number);
        }
#line 62
        fflush(stdout);
      }
#line 74
      if (! input_status) {
        {
#line 75
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 76
          readstat = Read(1, buffer);
#line 77
          if (readstat < 0) {
#line 78
            goto while_break___1;
          }
#line 79
          nargs = ReadParse(buffer, args, " \t;");
#line 80
          Print(32, "%s\n", buffer);
#line 81
          tmp = strstr((char const   *)args[0], (char const   *)"timeleft");
#line 81
          if (tmp) {
#line 81
            if (! xboard) {
#line 82
              if (game_wtm) {
#line 83
                printf((char const   *)"analyze.White(%d): ", move_number);
              } else {
#line 85
                printf((char const   *)"analyze.Black(%d): ", move_number);
              }
#line 86
              fflush(stdout);
            } else {
#line 81
              goto _L;
            }
          } else {
            _L: /* CIL Label */ ;
          }
#line 75
          tmp___0 = strstr((char const   *)args[0], (char const   *)"timeleft");
#line 75
          if (! tmp___0) {
#line 75
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 90
        nargs = ReadParse(buffer, args, " \t;");
      }
#line 91
      if (readstat < 0) {
#line 92
        goto while_break___0;
      }
#line 93
      move = 0;
#line 94
      tmp___1 = strcmp((char const   *)args[0], (char const   *)"exit");
#line 94
      if (! tmp___1) {
#line 95
        goto while_break___0;
      }
#line 105
      tmp___5 = OptionMatch("back", args[0]);
#line 105
      if (tmp___5) {
#line 106
        if (nargs > 1) {
#line 107
          back_number = atoi((char const   *)args[1]);
        } else {
#line 109
          back_number = 1;
        }
#line 110
        i = 0;
        {
#line 110
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 110
          if (! (i < back_number)) {
#line 110
            goto while_break___2;
          }
#line 111
          game_wtm ^= 1;
#line 112
          if (game_wtm ^ 1) {
#line 113
            move_number --;
          }
#line 110
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 115
        if (move_number == 0) {
#line 116
          move_number = 1;
#line 117
          game_wtm = 1;
        }
#line 119
        sprintf(buffer, (char const   *)"reset %d", move_number);
#line 120
        Option((TREE *)tree);
#line 121
        display = tree->position;
      } else {
#line 122
        tmp___4 = Option((TREE *)tree);
#line 122
        if (tmp___4) {
#line 123
          display = tree->position;
        } else {
#line 134
          move = InputMove((TREE *)tree, 0, game_wtm, 1, 0, buffer);
#line 134
          if (move) {
#line 135
            tmp___2 = OutputMove((TREE *)tree, 0, game_wtm, move);
#line 135
            outmove = tmp___2;
#line 137
            if (history_file) {
#line 138
              fseek(history_file, (long )((((move_number - 1) * 2 + 1) - game_wtm) * 10),
                    0);
#line 140
              fprintf(history_file, (char const   *)"%9s\n", outmove);
            }
#line 142
            if (game_wtm) {
#line 143
              Print(32, "White(%d): ", move_number);
            } else {
#line 145
              Print(32, "Black(%d): ", move_number);
            }
#line 146
            Print(32, "%s\n", outmove);
#line 147
            if (speech) {
#line 150
              strcpy(announce, (char const   *)"./speak ");
#line 151
              strcat(announce, (char const   *)outmove);
#line 152
              strcat(announce, (char const   *)" &");
#line 153
              v = system((char const   *)(announce));
#line 154
              if (v != 0) {
#line 155
                perror((char const   *)"Analyze() system() error: ");
              }
            }
#line 157
            MakeMoveRoot((TREE *)tree, game_wtm, move);
#line 158
            display = tree->position;
#line 159
            last_mate_score = 0;
#line 160
            if (log_file) {
#line 161
              DisplayChessBoard(log_file, tree->position);
            }
          } else {
#line 172
            pondering = 0;
#line 173
            tmp___3 = Option((TREE *)tree);
#line 173
            if (tmp___3 == 0) {
#line 174
              printf((char const   *)"illegal move: %s\n", buffer);
            }
#line 175
            pondering = 1;
#line 176
            display = tree->position;
          }
        }
      }
#line 47
      if (! (! move)) {
#line 47
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 179
    if (readstat < 0) {
#line 179
      goto _L___0;
    } else {
#line 179
      tmp___6 = strcmp((char const   *)args[0], (char const   *)"exit");
#line 179
      if (! tmp___6) {
        _L___0: /* CIL Label */ 
#line 180
        goto while_break;
      }
    }
#line 181
    game_wtm ^= 1;
#line 182
    if (game_wtm) {
#line 183
      move_number ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  analyze_mode = 0;
#line 186
  printf((char const   *)"analyze complete.\n");
#line 187
  pondering = 0;
#line 188
  swindle_mode = save_swindle_mode;
#line 189
  return;
}
}
#line 74 "annotate.c"
void Annotate(void) 
{ 
  FILE *annotate_in ;
  FILE *annotate_out ;
  char text___0[128] ;
  char tbuffer[4096] ;
  char colors[32] ;
  unsigned int tmp ;
  char pname[128] ;
  unsigned int tmp___0 ;
  int annotate_margin ;
  int annotate_score[100] ;
  int player_score ;
  int best_moves ;
  int annotate_wtm ;
  int annotate_search_time_limit ;
  int search_player ;
  int twtm ;
  int path_len ;
  int analysis_printed ;
  int wtm ;
  int move_num ;
  int line1 ;
  int line2 ;
  int move ;
  int suggested ;
  int i ;
  int searches_done ;
  int read_status ;
  PATH temp[100] ;
  PATH player_pv ;
  int temp_search_depth ;
  TREE *tree ;
  char html_br[5] ;
  unsigned int tmp___1 ;
  int save_swindle_mode ;
  int html_mode ;
  int latex ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  size_t tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;

  {
#line 76
  colors[0] = (char )'\000';
#line 76
  tmp = 1U;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (tmp >= 32U) {
#line 76
      goto while_break;
    }
#line 76
    colors[tmp] = (char)0;
#line 76
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  pname[0] = (char )'\000';
#line 76
  tmp___0 = 1U;
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if (tmp___0 >= 128U) {
#line 76
      goto while_break___0;
    }
#line 76
    pname[tmp___0] = (char)0;
#line 76
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 81
  analysis_printed = 0;
#line 86
  tree = (TREE *)block[0];
#line 87
  html_br[0] = (char )'\000';
#line 87
  tmp___1 = 1U;
  {
#line 87
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 87
    if (tmp___1 >= 5U) {
#line 87
      goto while_break___1;
    }
#line 87
    html_br[tmp___1] = (char)0;
#line 87
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 89
  html_mode = 0;
#line 90
  latex = 0;
#line 100
  save_swindle_mode = swindle_mode;
#line 101
  tmp___2 = strcmp((char const   *)args[0], (char const   *)"annotateh");
#line 101
  if (! tmp___2) {
#line 102
    html_mode = 1;
#line 103
    strcpy(html_br, (char const   *)"<br>");
  }
#line 105
  tmp___3 = strcmp((char const   *)args[0], (char const   *)"annotatet");
#line 105
  if (! tmp___3) {
#line 106
    latex = 1;
#line 107
    strcpy(html_br, (char const   *)"\\\\");
  }
#line 109
  strcpy(tbuffer, (char const   *)(buffer));
#line 110
  nargs = ReadParse(tbuffer, args, " \t;");
#line 111
  if (nargs < 6) {
#line 112
    printf((char const   *)"usage: annotate <file> <color> <moves> <margin> <time> [nmoves]\n");
#line 114
    return;
  }
#line 116
  annotate_in = fopen((char const   * __restrict  )args[1], (char const   * __restrict  )"r");
#line 117
  if ((unsigned long )annotate_in == (unsigned long )((void *)0)) {
#line 118
    Print(4095, "unable to open %s for input\n", args[1]);
#line 119
    return;
  }
#line 121
  nargs = ReadParse(tbuffer, args, " \t;");
#line 122
  strcpy(text___0, (char const   *)args[1]);
#line 123
  if (html_mode == 1) {
#line 124
    tmp___4 = strlen((char const   *)(text___0));
#line 124
    strcpy(text___0 + tmp___4, (char const   *)".html");
  } else
#line 125
  if (latex == 1) {
#line 126
    tmp___5 = strlen((char const   *)(text___0));
#line 126
    strcpy(text___0 + tmp___5, (char const   *)".tex");
  } else {
#line 128
    tmp___6 = strlen((char const   *)(text___0));
#line 128
    strcpy(text___0 + tmp___6, (char const   *)".can");
  }
#line 129
  annotate_out = fopen((char const   * __restrict  )(text___0), (char const   * __restrict  )"w");
#line 130
  if ((unsigned long )annotate_out == (unsigned long )((void *)0)) {
#line 131
    Print(4095, "unable to open %s for output\n", text___0);
#line 132
    return;
  }
#line 134
  if (html_mode == 1) {
#line 135
    AnnotateHeaderHTML(text___0, annotate_out);
  }
#line 136
  if (latex == 1) {
#line 137
    AnnotateHeaderTeX(annotate_out);
  }
#line 138
  tmp___7 = strlen((char const   *)args[2]);
#line 138
  if (tmp___7 <= 2UL) {
#line 139
    strcpy(colors, (char const   *)args[2]);
  } else {
#line 141
    strcpy(pname, (char const   *)args[2]);
  }
#line 142
  line1 = 1;
#line 143
  line2 = 999;
#line 144
  tmp___8 = strchr((char const   *)args[3], 'b');
#line 144
  if (tmp___8) {
#line 145
    line2 = -1;
  }
#line 146
  tmp___9 = strchr((char const   *)args[3], '-');
#line 146
  if (tmp___9) {
#line 147
    sscanf((char const   *)args[3], (char const   *)"%d-%d", & line1, & line2);
  } else {
#line 149
    sscanf((char const   *)args[3], (char const   *)"%d", & line1);
#line 150
    line2 = 999;
  }
#line 152
  tmp___10 = atof((char const   *)args[4]);
#line 152
  annotate_margin = (int )(tmp___10 * (double )piece_values[1][1]);
#line 153
  tmp___11 = atof((char const   *)args[5]);
#line 153
  annotate_search_time_limit = (int )(tmp___11 * (double )100);
#line 154
  if (nargs > 6) {
#line 155
    best_moves = atoi((char const   *)args[6]);
  } else {
#line 157
    best_moves = 1;
  }
#line 170
  annotate_mode = 1;
#line 171
  swindle_mode = 0;
#line 172
  ponder = 0;
#line 173
  temp_search_depth = search_depth;
#line 174
  read_status = ReadPGN((FILE *)0, 0);
#line 175
  read_status = ReadPGN(annotate_in, 0);
#line 176
  player_pv.path[1] = 0;
  {
#line 177
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 177
    if (! (read_status != -1)) {
#line 177
      goto while_break___2;
    }
#line 178
    ponder_move = 0;
#line 179
    last_pv.pathd = 0;
#line 180
    last_pv.pathl = 0;
#line 181
    player_pv.pathd = 0;
#line 182
    player_pv.pathl = 0;
#line 183
    tree->pv[0].pathl = 0;
#line 184
    tree->pv[0].pathd = 0;
#line 185
    analysis_printed = 0;
#line 186
    InitializeChessBoard((TREE *)tree);
#line 187
    tree->status[1] = tree->status[0];
#line 188
    wtm = 1;
#line 189
    move_number = 1;
    {
#line 198
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 199
      read_status = ReadPGN(annotate_in, 0);
#line 198
      if (! (read_status == 1)) {
#line 198
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 201
    if (read_status == -1) {
#line 202
      goto while_break___2;
    }
#line 203
    if (latex == 0) {
#line 204
      fprintf(annotate_out, (char const   *)"[Event \"%s\"]%s\n", pgn_event, html_br);
#line 205
      fprintf(annotate_out, (char const   *)"[Site \"%s\"]%s\n", pgn_site, html_br);
#line 206
      fprintf(annotate_out, (char const   *)"[Date \"%s\"]%s\n", pgn_date, html_br);
#line 207
      fprintf(annotate_out, (char const   *)"[Round \"%s\"]%s\n", pgn_round, html_br);
#line 208
      fprintf(annotate_out, (char const   *)"[White \"%s\"]%s\n", pgn_white, html_br);
#line 209
      fprintf(annotate_out, (char const   *)"[WhiteElo \"%s\"]%s\n", pgn_white_elo,
              html_br);
#line 210
      fprintf(annotate_out, (char const   *)"[Black \"%s\"]%s\n", pgn_black, html_br);
#line 211
      fprintf(annotate_out, (char const   *)"[BlackElo \"%s\"]%s\n", pgn_black_elo,
              html_br);
#line 212
      fprintf(annotate_out, (char const   *)"[Result \"%s\"]%s\n", pgn_result, html_br);
#line 213
      fprintf(annotate_out, (char const   *)"[Annotator \"Crafty v%s\"]%s\n", version,
              html_br);
#line 215
      tmp___16 = strlen((char const   *)(colors));
#line 215
      if (tmp___16 != 0UL) {
#line 216
        tmp___14 = strcmp((char const   *)(colors), (char const   *)"bw");
#line 216
        if (tmp___14) {
#line 216
          tmp___15 = strcmp((char const   *)(colors), (char const   *)"wb");
#line 216
          if (tmp___15) {
#line 219
            tmp___13 = strchr((char const   *)(colors), 'b');
#line 219
            if (tmp___13) {
#line 220
              fprintf(annotate_out, (char const   *)"{annotating only black moves.}%s\n",
                      html_br);
            } else {
#line 222
              tmp___12 = strchr((char const   *)(colors), 'w');
#line 222
              if (tmp___12) {
#line 223
                fprintf(annotate_out, (char const   *)"{annotating only white moves.}%s\n",
                        html_br);
              }
            }
          } else {
            _L: /* CIL Label */ 
#line 217
            fprintf(annotate_out, (char const   *)"{annotating both black and white moves.}%s\n",
                    html_br);
          }
        } else {
#line 216
          goto _L;
        }
      } else {
#line 226
        fprintf(annotate_out, (char const   *)"{annotating for player %s}%s\n", pname,
                html_br);
      }
#line 228
      tmp___17 = DisplayEvaluationKibitz(annotate_margin, wtm);
#line 228
      fprintf(annotate_out, (char const   *)"{using a scoring margin of %s pawns.}%s\n",
              tmp___17, html_br);
#line 230
      tmp___18 = DisplayTimeKibitz((unsigned int )annotate_search_time_limit);
#line 230
      fprintf(annotate_out, (char const   *)"{search time limit is %s}%s\n%s\n", tmp___18,
              html_br, html_br);
    } else {
#line 233
      fprintf(annotate_out, (char const   *)"\\textbf{\\sc %s %s -- %s %s}%s\n", pgn_white,
              pgn_white_elo, pgn_black, pgn_black_elo, html_br);
#line 235
      fprintf(annotate_out, (char const   *)"{\\em %s, %s}%s\n", pgn_site, pgn_date,
              html_br);
#line 236
      fprintf(annotate_out, (char const   *)"{\\small %s, Round: %s}%s\n", pgn_event,
              pgn_round, html_br);
#line 238
      fprintf(annotate_out, (char const   *)"\\begin{mainline}{%s}{Crafty v%s}\n",
              pgn_result, version);
    }
#line 241
    tmp___25 = strlen((char const   *)(colors));
#line 241
    if (tmp___25) {
#line 242
      tmp___22 = strcmp((char const   *)(colors), (char const   *)"w");
#line 242
      if (tmp___22) {
#line 244
        tmp___21 = strcmp((char const   *)(colors), (char const   *)"b");
#line 244
        if (tmp___21) {
#line 246
          tmp___20 = strcmp((char const   *)(colors), (char const   *)"wb");
#line 246
          if (tmp___20) {
#line 248
            tmp___19 = strcmp((char const   *)(colors), (char const   *)"bw");
#line 248
            if (tmp___19) {
#line 251
              Print(4095, "invalid color specification, retry\n");
#line 252
              fclose(annotate_out);
#line 253
              return;
            } else {
#line 249
              annotate_wtm = 2;
            }
          } else {
#line 247
            annotate_wtm = 2;
          }
        } else {
#line 245
          annotate_wtm = 0;
        }
      } else {
#line 243
        annotate_wtm = 1;
      }
    } else {
#line 256
      tmp___24 = strstr((char const   *)(pgn_white), (char const   *)(pname));
#line 256
      if (tmp___24) {
#line 257
        annotate_wtm = 1;
      } else {
#line 258
        tmp___23 = strstr((char const   *)(pgn_black), (char const   *)(pname));
#line 258
        if (tmp___23) {
#line 259
          annotate_wtm = 0;
        } else {
#line 261
          Print(4095, "Player name doesn\'t match any PGN name tag, retry\n");
#line 262
          fclose(annotate_out);
#line 263
          return;
        }
      }
    }
    {
#line 266
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 266
      if (! 1) {
#line 266
        goto while_break___4;
      }
#line 267
      fflush(annotate_out);
#line 268
      move = ReadNextMove((TREE *)tree, buffer, 0, wtm);
#line 269
      if (move <= 0) {
#line 270
        goto while_break___4;
      }
#line 271
      tmp___26 = OutputMove((TREE *)tree, 0, wtm, move);
#line 271
      strcpy(text___0, (char const   *)tmp___26);
#line 272
      if (history_file) {
#line 273
        fseek(history_file, (long )((((move_number - 1) * 2 + 1) - wtm) * 10), 0);
#line 274
        fprintf(history_file, (char const   *)"%9s\n", text___0);
      }
#line 276
      if (wtm) {
#line 277
        Print(4095, "White(%d): %s\n", move_number, text___0);
      } else {
#line 279
        Print(4095, "Black(%d): %s\n", move_number, text___0);
      }
#line 280
      if (analysis_printed) {
#line 281
        if (wtm) {
#line 281
          tmp___27 = "";
        } else {
#line 281
          tmp___27 = "     ...";
        }
#line 281
        fprintf(annotate_out, (char const   *)"%3d.%s%8s\n", move_number, tmp___27,
                text___0);
      } else
#line 284
      if (wtm) {
#line 285
        fprintf(annotate_out, (char const   *)"%3d.%8s", move_number, text___0);
      } else {
#line 287
        fprintf(annotate_out, (char const   *)"%8s\n", text___0);
      }
#line 289
      analysis_printed = 0;
#line 290
      if (move_number >= line1) {
#line 290
        if (move_number <= line2) {
#line 291
          if (annotate_wtm == 2) {
#line 291
            goto _L___8;
          } else
#line 291
          if (annotate_wtm == wtm) {
            _L___8: /* CIL Label */ 
#line 292
            last_pv.pathd = 0;
#line 293
            last_pv.pathl = 0;
#line 294
            thinking = 1;
#line 295
            RootMoveList(wtm);
#line 306
            search_time_limit = annotate_search_time_limit;
#line 307
            search_depth = temp_search_depth;
#line 308
            player_score = -999999;
#line 309
            search_player = 1;
#line 310
            searches_done = 0;
            {
#line 310
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 310
              if (best_moves > 0) {
#line 310
                tmp___28 = best_moves;
              } else {
#line 310
                tmp___28 = - best_moves;
              }
#line 310
              if (! (searches_done < tmp___28)) {
#line 310
                goto while_break___5;
              }
#line 312
              if (searches_done > 0) {
#line 313
                search_time_limit = 3 * annotate_search_time_limit;
#line 314
                search_depth = temp[0].pathd;
              }
#line 316
              Print(4095, "\n              Searching all legal moves.");
#line 317
              Print(4095, "----------------------------------\n");
#line 318
              tree->status[1] = tree->status[0];
#line 319
              InitializeHashTables(0);
#line 320
              annotate_score[searches_done] = Iterate(wtm, 4, 1);
#line 321
              if (tree->pv[0].path[1] == move) {
#line 322
                player_score = annotate_score[searches_done];
#line 323
                player_pv = tree->pv[0];
#line 324
                search_player = 0;
              }
#line 326
              temp[searches_done] = tree->pv[0];
#line 327
              i = 0;
              {
#line 327
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 327
                if (! (i < n_root_moves)) {
#line 327
                  goto while_break___6;
                }
#line 328
                if (root_moves[i].move == tree->pv[0].path[1]) {
                  {
#line 329
                  while (1) {
                    while_continue___7: /* CIL Label */ ;
#line 329
                    if (! (i < n_root_moves)) {
#line 329
                      goto while_break___7;
                    }
#line 330
                    root_moves[i] = root_moves[i + 1];
#line 329
                    i ++;
                  }
                  while_break___7: /* CIL Label */ ;
                  }
#line 331
                  n_root_moves --;
#line 332
                  goto while_break___6;
                }
#line 327
                i ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 335
              if (n_root_moves == 0) {
#line 335
                goto _L___0;
              } else
#line 335
              if (annotate_margin >= 0) {
#line 335
                if (player_score + annotate_margin > annotate_score[searches_done]) {
#line 335
                  if (best_moves > 0) {
                    _L___0: /* CIL Label */ 
#line 339
                    if (n_root_moves == 0) {
#line 340
                      searches_done ++;
                    }
#line 341
                    goto while_break___5;
                  } else {
#line 335
                    goto _L___2;
                  }
                } else {
#line 335
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                _L___1: /* CIL Label */ ;
              }
#line 310
              searches_done ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 344
            if (search_player) {
#line 345
              Print(4095, "\n              Searching only the move played in game.");
#line 347
              Print(4095, "--------------------\n");
#line 348
              tree->status[1] = tree->status[0];
#line 349
              search_move = move;
#line 350
              root_moves[0].move = move;
#line 351
              root_moves[0].status = 0U;
#line 352
              n_root_moves = 1;
#line 353
              search_time_limit = 3 * annotate_search_time_limit;
#line 354
              search_depth = temp[0].pathd;
#line 355
              if (search_depth == temp_search_depth) {
#line 356
                search_time_limit = annotate_search_time_limit;
              }
#line 357
              InitializeHashTables(0);
#line 358
              player_score = Iterate(wtm, 4, 1);
#line 359
              player_pv = tree->pv[0];
#line 360
              search_depth = temp_search_depth;
#line 361
              search_time_limit = annotate_search_time_limit;
#line 362
              search_move = 0;
            }
#line 373
            thinking = 0;
#line 374
            if (player_pv.pathd > 1) {
#line 374
              if (player_pv.pathl >= 1) {
#line 374
                if (player_score + annotate_margin < annotate_score[0]) {
#line 374
                  if (temp[0].path[1] != player_pv.path[1]) {
#line 374
                    goto _L___5;
                  } else
#line 374
                  if (annotate_margin < 0) {
                    _L___5: /* CIL Label */ 
#line 374
                    goto _L___4;
                  } else
#line 374
                  if (best_moves != 1) {
                    _L___4: /* CIL Label */ 
#line 378
                    if (wtm) {
#line 379
                      analysis_printed = 1;
#line 380
                      fprintf(annotate_out, (char const   *)"%s\n", html_br);
                    }
#line 382
                    if (html_mode == 1) {
#line 383
                      AnnotatePositionHTML((TREE *)tree, wtm, annotate_out);
                    }
#line 384
                    if (latex == 1) {
#line 385
                      AnnotatePositionTeX((TREE *)tree, wtm, annotate_out);
#line 386
                      tmp___29 = DisplayEvaluationKibitz(player_score, wtm);
#line 386
                      fprintf(annotate_out, (char const   *)"   \\begin{variation}\\{%d:%s\\}",
                              player_pv.pathd, tmp___29);
                    } else {
#line 390
                      tmp___30 = DisplayEvaluationKibitz(player_score, wtm);
#line 390
                      fprintf(annotate_out, (char const   *)"                ({%d:%s}",
                              player_pv.pathd, tmp___30);
                    }
#line 393
                    path_len = player_pv.pathl;
#line 394
                    tmp___31 = FormatPV((TREE *)tree, wtm, player_pv);
#line 394
                    fprintf(annotate_out, (char const   *)" %s", tmp___31);
#line 395
                    if (latex == 1) {
#line 396
                      tmp___32 = AnnotateVtoNAG(player_score, wtm, html_mode, latex);
#line 396
                      fprintf(annotate_out, (char const   *)" %s\n   \\end{variation}\n",
                              tmp___32);
                    } else {
#line 399
                      tmp___33 = AnnotateVtoNAG(player_score, wtm, html_mode, latex);
#line 399
                      fprintf(annotate_out, (char const   *)" %s)%s\n", tmp___33,
                              html_br);
                    }
#line 401
                    move_num = 0;
                    {
#line 401
                    while (1) {
                      while_continue___8: /* CIL Label */ ;
#line 401
                      if (! (move_num < searches_done)) {
#line 401
                        goto while_break___8;
                      }
#line 402
                      if (move != temp[move_num].path[1]) {
#line 403
                        if (latex == 1) {
#line 404
                          tmp___34 = DisplayEvaluationKibitz(annotate_score[move_num],
                                                             wtm);
#line 404
                          fprintf(annotate_out, (char const   *)"   \\begin{variation}\\{%d:%s\\}",
                                  temp[move_num].pathd, tmp___34);
                        } else {
#line 408
                          tmp___35 = DisplayEvaluationKibitz(annotate_score[move_num],
                                                             wtm);
#line 408
                          fprintf(annotate_out, (char const   *)"                ({%d:%s}",
                                  temp[move_num].pathd, tmp___35);
                        }
#line 411
                        path_len = temp[move_num].pathl;
#line 412
                        tmp___36 = FormatPV((TREE *)tree, wtm, temp[move_num]);
#line 412
                        fprintf(annotate_out, (char const   *)" %s", tmp___36);
#line 414
                        if (latex == 1) {
#line 415
                          tmp___37 = AnnotateVtoNAG(annotate_score[move_num], wtm,
                                                    html_mode, latex);
#line 415
                          fprintf(annotate_out, (char const   *)" %s\n   \\end{variation}\n",
                                  tmp___37);
                        } else {
#line 419
                          tmp___38 = AnnotateVtoNAG(annotate_score[move_num], wtm,
                                                    html_mode, latex);
#line 419
                          fprintf(annotate_out, (char const   *)" %s)%s\n", tmp___38,
                                  html_br);
                        }
                      }
#line 401
                      move_num ++;
                    }
                    while_break___8: /* CIL Label */ ;
                    }
#line 424
                    if (html_mode == 1) {
#line 425
                      fprintf(annotate_out, (char const   *)"<br>\n");
                    }
#line 426
                    if (line2 < 0) {
#line 427
                      line2 --;
                    }
                  } else {
#line 374
                    goto _L___7;
                  }
                } else {
#line 374
                  goto _L___7;
                }
              } else {
#line 374
                goto _L___7;
              }
            } else {
              _L___7: /* CIL Label */ 
              _L___6: /* CIL Label */ 
              _L___3: /* CIL Label */ ;
            }
          }
        } else {
#line 290
          goto _L___9;
        }
      } else {
        _L___9: /* CIL Label */ ;
      }
#line 441
      read_status = ReadPGN(annotate_in, 1);
      {
#line 442
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 442
        if (! (read_status == 2)) {
#line 442
          goto while_break___9;
        }
#line 443
        suggested = InputMove((TREE *)tree, 0, wtm, 1, 0, buffer);
#line 444
        if (suggested > 0) {
#line 445
          thinking = 1;
#line 446
          Print(4095, "\n              Searching only the move suggested.");
#line 447
          Print(4095, "--------------------\n");
#line 448
          tree->status[1] = tree->status[0];
#line 449
          search_move = suggested;
#line 450
          search_time_limit = 3 * annotate_search_time_limit;
#line 451
          search_depth = temp[0].pathd;
#line 452
          InitializeHashTables(0);
#line 453
          annotate_score[0] = Iterate(wtm, 4, 0);
#line 454
          search_depth = temp_search_depth;
#line 455
          search_time_limit = annotate_search_time_limit;
#line 456
          search_move = 0;
#line 457
          thinking = 0;
#line 458
          twtm = wtm;
#line 459
          path_len = tree->pv[0].pathl;
#line 460
          if (tree->pv[0].pathd > 1) {
#line 460
            if (path_len >= 1) {
#line 461
              if (wtm) {
#line 461
                if (! analysis_printed) {
#line 462
                  analysis_printed = 1;
#line 463
                  fprintf(annotate_out, (char const   *)"%s\n", html_br);
                } else {
#line 461
                  goto _L___10;
                }
              } else {
                _L___10: /* CIL Label */ ;
              }
#line 465
              tmp___39 = DisplayEvaluationKibitz(annotate_score[0], wtm);
#line 465
              fprintf(annotate_out, (char const   *)"                ({suggested %d:%s}",
                      tree->pv[0].pathd, tmp___39);
#line 468
              i = 1;
              {
#line 468
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 468
                if (! (i <= path_len)) {
#line 468
                  goto while_break___10;
                }
#line 469
                tmp___40 = OutputMove((TREE *)tree, i, twtm, tree->pv[0].path[i]);
#line 469
                fprintf(annotate_out, (char const   *)" %s", tmp___40);
#line 471
                MakeMove((TREE *)tree, i, twtm, tree->pv[0].path[i]);
#line 472
                twtm ^= 1;
#line 468
                i ++;
              }
              while_break___10: /* CIL Label */ ;
              }
#line 474
              i = path_len;
              {
#line 474
              while (1) {
                while_continue___11: /* CIL Label */ ;
#line 474
                if (! (i > 0)) {
#line 474
                  goto while_break___11;
                }
#line 475
                twtm ^= 1;
#line 476
                UnmakeMove((TREE *)tree, i, twtm, tree->pv[0].path[i]);
#line 474
                i --;
              }
              while_break___11: /* CIL Label */ ;
              }
#line 478
              tmp___41 = AnnotateVtoNAG(annotate_score[0], wtm, html_mode, latex);
#line 478
              fprintf(annotate_out, (char const   *)" %s)%s\n", tmp___41, html_br);
            } else {
#line 460
              goto _L___11;
            }
          } else {
            _L___11: /* CIL Label */ ;
          }
        }
#line 483
        read_status = ReadPGN(annotate_in, 1);
#line 484
        if (read_status != 2) {
#line 485
          goto while_break___9;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 487
      if (analysis_printed) {
#line 487
        if (latex == 0) {
#line 488
          fprintf(annotate_out, (char const   *)"%s\n", html_br);
        } else {
#line 487
          goto _L___12;
        }
      } else {
        _L___12: /* CIL Label */ ;
      }
#line 489
      MakeMoveRoot((TREE *)tree, wtm, move);
#line 490
      wtm ^= 1;
#line 491
      if (wtm) {
#line 492
        move_number ++;
      }
#line 493
      if (read_status != 0) {
#line 494
        goto while_break___4;
      }
#line 495
      if (line2 < -1) {
#line 496
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 498
    fprintf(annotate_out, (char const   *)"  %s %s\n\n", pgn_result, html_br);
#line 499
    if (html_mode == 1) {
#line 500
      fprintf(annotate_out, (char const   *)"%s\n", html_br);
#line 501
      AnnotateFooterHTML(annotate_out);
    }
#line 503
    if (latex == 1) {
#line 504
      AnnotatePositionTeX((TREE *)tree, wtm, annotate_out);
#line 505
      fprintf(annotate_out, (char const   *)"\\end{mainline}\n");
#line 506
      tmp___46 = strlen((char const   *)(colors));
#line 506
      if (tmp___46 != 0UL) {
#line 507
        fprintf(annotate_out, (char const   *)"\\begin{flushright}{\\small ");
#line 508
        tmp___44 = strcmp((char const   *)(colors), (char const   *)"bw");
#line 508
        if (tmp___44) {
#line 508
          tmp___45 = strcmp((char const   *)(colors), (char const   *)"wb");
#line 508
          if (tmp___45) {
#line 511
            tmp___43 = strchr((char const   *)(colors), 'b');
#line 511
            if (tmp___43) {
#line 512
              fprintf(annotate_out, (char const   *)"annotating only black moves.%s\n",
                      html_br);
            } else {
#line 513
              tmp___42 = strchr((char const   *)(colors), 'w');
#line 513
              if (tmp___42) {
#line 514
                fprintf(annotate_out, (char const   *)"annotating only white moves.%s\n",
                        html_br);
              }
            }
          } else {
            _L___13: /* CIL Label */ 
#line 509
            fprintf(annotate_out, (char const   *)"annotating both black and white moves.%s\n",
                    html_br);
          }
        } else {
#line 508
          goto _L___13;
        }
      } else {
#line 516
        fprintf(annotate_out, (char const   *)"annotating for player %s%s\n", pname,
                html_br);
      }
#line 517
      tmp___47 = DisplayEvaluationKibitz(annotate_margin, wtm);
#line 517
      fprintf(annotate_out, (char const   *)"using a scoring margin of %s pawns.%s\n",
              tmp___47, html_br);
#line 519
      tmp___48 = DisplayTimeKibitz((unsigned int )annotate_search_time_limit);
#line 519
      fprintf(annotate_out, (char const   *)"search time limit is %s%s\n", tmp___48,
              html_br);
#line 521
      fprintf(annotate_out, (char const   *)" } \\end{flushright}");
#line 522
      AnnotateFooterTeX(annotate_out);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 525
  if (annotate_out) {
#line 526
    fclose(annotate_out);
  }
#line 527
  if (annotate_in) {
#line 528
    fclose(annotate_in);
  }
#line 529
  search_time_limit = 0;
#line 530
  annotate_mode = 0;
#line 531
  swindle_mode = save_swindle_mode;
#line 532
  return;
}
}
#line 541 "annotate.c"
void AnnotateHeaderHTML(char *title_text , FILE *annotate_out ) 
{ 


  {
#line 542
  fprintf(annotate_out, (char const   *)"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"\n");
#line 544
  fprintf(annotate_out, (char const   *)"          \"http://www.w3.org/TR/REC-html40/loose.dtd\">\n");
#line 546
  fprintf(annotate_out, (char const   *)"<HTML>\n");
#line 547
  fprintf(annotate_out, (char const   *)"<HEAD><TITLE>%s</TITLE>\n", title_text);
#line 548
  fprintf(annotate_out, (char const   *)"<LINK rev=\"made\" href=\"hyatt@cis.uab.edu\"></HEAD>\n");
#line 550
  fprintf(annotate_out, (char const   *)"<BODY BGColor=\"#ffffff\" text=\"#000000\" link=\"#0000ee\" vlink=\"#551a8b\">\n");
#line 553
  return;
}
}
#line 555 "annotate.c"
void AnnotateFooterHTML(FILE *annotate_out ) 
{ 


  {
#line 556
  fprintf(annotate_out, (char const   *)"</BODY>\n");
#line 557
  fprintf(annotate_out, (char const   *)"</HTML>\n");
#line 558
  return;
}
}
#line 559 "annotate.c"
void AnnotatePositionHTML(TREE *tree , int wtm , FILE *annotate_out ) 
{ 
  char filename[32] ;
  char html_piece ;
  char alt[32] ;
  int rank ;
  int file ;

  {
#line 565
  fprintf(annotate_out, (char const   *)"<br>\n");
#line 566
  fprintf(annotate_out, (char const   *)"<TABLE Border=1 CellSpacing=0 CellPadding=0>\n\n");
#line 567
  rank = 7;
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    if (! (rank >= 0)) {
#line 567
      goto while_break;
    }
#line 568
    fprintf(annotate_out, (char const   *)"<TR>\n");
#line 569
    file = 0;
    {
#line 569
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 569
      if (! (file <= 7)) {
#line 569
        goto while_break___0;
      }
#line 570
      strcpy(filename, (char const   *)"bitmaps/");
#line 571
      if ((rank + file) % 2) {
#line 572
        strcat(filename, (char const   *)"w");
      } else {
#line 574
        strcat(filename, (char const   *)"b");
      }
#line 575
      html_piece = (char )translate[(int )tree->position.board[(rank << 3) + file] + 6];
      {
#line 577
      if ((int )html_piece == 112) {
#line 577
        goto case_112;
      }
#line 581
      if ((int )html_piece == 114) {
#line 581
        goto case_114;
      }
#line 585
      if ((int )html_piece == 110) {
#line 585
        goto case_110;
      }
#line 589
      if ((int )html_piece == 98) {
#line 589
        goto case_98;
      }
#line 593
      if ((int )html_piece == 113) {
#line 593
        goto case_113;
      }
#line 597
      if ((int )html_piece == 107) {
#line 597
        goto case_107;
      }
#line 601
      if ((int )html_piece == 80) {
#line 601
        goto case_80;
      }
#line 605
      if ((int )html_piece == 82) {
#line 605
        goto case_82;
      }
#line 609
      if ((int )html_piece == 78) {
#line 609
        goto case_78;
      }
#line 613
      if ((int )html_piece == 66) {
#line 613
        goto case_66;
      }
#line 617
      if ((int )html_piece == 81) {
#line 617
        goto case_81;
      }
#line 621
      if ((int )html_piece == 75) {
#line 621
        goto case_75;
      }
#line 625
      goto switch_default;
      case_112: /* CIL Label */ 
#line 578
      strcat(filename, (char const   *)"bp");
#line 579
      strcpy(alt, (char const   *)"*P");
#line 580
      goto switch_break;
      case_114: /* CIL Label */ 
#line 582
      strcat(filename, (char const   *)"br");
#line 583
      strcpy(alt, (char const   *)"*R");
#line 584
      goto switch_break;
      case_110: /* CIL Label */ 
#line 586
      strcat(filename, (char const   *)"bn");
#line 587
      strcpy(alt, (char const   *)"*N");
#line 588
      goto switch_break;
      case_98: /* CIL Label */ 
#line 590
      strcat(filename, (char const   *)"bb");
#line 591
      strcpy(alt, (char const   *)"*B");
#line 592
      goto switch_break;
      case_113: /* CIL Label */ 
#line 594
      strcat(filename, (char const   *)"bq");
#line 595
      strcpy(alt, (char const   *)"*Q");
#line 596
      goto switch_break;
      case_107: /* CIL Label */ 
#line 598
      strcat(filename, (char const   *)"bk");
#line 599
      strcpy(alt, (char const   *)"*K");
#line 600
      goto switch_break;
      case_80: /* CIL Label */ 
#line 602
      strcat(filename, (char const   *)"wp");
#line 603
      strcpy(alt, (char const   *)"P");
#line 604
      goto switch_break;
      case_82: /* CIL Label */ 
#line 606
      strcat(filename, (char const   *)"wr");
#line 607
      strcpy(alt, (char const   *)"R");
#line 608
      goto switch_break;
      case_78: /* CIL Label */ 
#line 610
      strcat(filename, (char const   *)"wn");
#line 611
      strcpy(alt, (char const   *)"N");
#line 612
      goto switch_break;
      case_66: /* CIL Label */ 
#line 614
      strcat(filename, (char const   *)"wb");
#line 615
      strcpy(alt, (char const   *)"B");
#line 616
      goto switch_break;
      case_81: /* CIL Label */ 
#line 618
      strcat(filename, (char const   *)"wq");
#line 619
      strcpy(alt, (char const   *)"Q");
#line 620
      goto switch_break;
      case_75: /* CIL Label */ 
#line 622
      strcat(filename, (char const   *)"wk");
#line 623
      strcpy(alt, (char const   *)"K");
#line 624
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 626
      strcat(filename, (char const   *)"sq");
#line 627
      strcpy(alt, (char const   *)" ");
#line 628
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 630
      strcat(filename, (char const   *)".gif");
#line 631
      fprintf(annotate_out, (char const   *)"<TD><IMG ALT=\"%s\" SRC=\"%s\"></TD>\n",
              alt, filename);
#line 569
      file ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 634
    fprintf(annotate_out, (char const   *)"</TR>\n\n");
#line 567
    rank --;
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  fprintf(annotate_out, (char const   *)"</TABLE>\n");
#line 637
  if (wtm) {
#line 638
    fprintf(annotate_out, (char const   *)"<H2>White to move.</H2>\n");
  } else {
#line 640
    fprintf(annotate_out, (char const   *)"<H2>Black to move.</H2>\n");
  }
#line 641
  fprintf(annotate_out, (char const   *)"<BR>\n");
#line 642
  return;
}
}
#line 658 "annotate.c"
void AnnotateHeaderTeX(FILE *annotate_out ) 
{ 


  {
#line 659
  fprintf(annotate_out, (char const   *)"\\documentclass[12pt,twocolumn]{article}\n");
#line 660
  fprintf(annotate_out, (char const   *)"%% This is a LaTeX file generated by Crafty \n");
#line 661
  fprintf(annotate_out, (char const   *)"%% You must have the \"chess12\" package to typeset this file.\n");
#line 663
  fprintf(annotate_out, (char const   *)"\n");
#line 664
  fprintf(annotate_out, (char const   *)"\\usepackage{times}\n");
#line 665
  fprintf(annotate_out, (char const   *)"\\usepackage{a4wide}\n");
#line 666
  fprintf(annotate_out, (char const   *)"\\usepackage{chess}\n");
#line 667
  fprintf(annotate_out, (char const   *)"\\usepackage{bdfchess}\n");
#line 668
  fprintf(annotate_out, (char const   *)"\\usepackage[T1]{fontenc}\n");
#line 669
  fprintf(annotate_out, (char const   *)"\n");
#line 670
  fprintf(annotate_out, (char const   *)"\\setlength{\\columnsep}{7mm}\n");
#line 671
  fprintf(annotate_out, (char const   *)"\\setlength{\\parindent}{0pt}\n");
#line 672
  fprintf(annotate_out, (char const   *)"\n");
#line 673
  fprintf(annotate_out, (char const   *)"%% Macros for variations and diagrams:\n");
#line 674
  fprintf(annotate_out, (char const   *)"\\newenvironment{mainline}[2]{\\bf\\newcommand{\\result}{#1}%%\n");
#line 676
  fprintf(annotate_out, (char const   *)"\\newcommand{\\commentator}{#2}\\begin{chess}}%%\n");
#line 677
  fprintf(annotate_out, (char const   *)"{\\end{chess}\\finito{\\result}{\\commentator}}\n");
#line 678
  fprintf(annotate_out, (char const   *)"\\newenvironment{variation}{[\\begingroup\\rm\\ignorespaces}%%\n");
#line 680
  fprintf(annotate_out, (char const   *)"{\\endgroup]\\ignorespaces\\newline}\n");
#line 681
  fprintf(annotate_out, (char const   *)"\\newcommand{\\finito}[2]{{\\bf\\hfill#1\\hfill[#2]\\par}}\n");
#line 683
  fprintf(annotate_out, (char const   *)"\\setlength{\\parindent}{0pt}\n");
#line 684
  fprintf(annotate_out, (char const   *)"\\newenvironment{diagram}{\\begin{nochess}}{$$\\showboard$$\\end{nochess}}\n");
#line 687
  fprintf(annotate_out, (char const   *)"\n\n\\begin{document}\n\n");
#line 688
  return;
}
}
#line 690 "annotate.c"
void AnnotateFooterTeX(FILE *annotate_out ) 
{ 


  {
#line 691
  fprintf(annotate_out, (char const   *)"\n\n\\end{document}\n");
#line 692
  return;
}
}
#line 693 "annotate.c"
void AnnotatePositionTeX(TREE *tree , int wtm , FILE *annotate_out ) 
{ 
  char filename[32] ;
  char html_piece ;
  int rank ;
  int file ;

  {
#line 698
  fprintf(annotate_out, (char const   *)"\\begin{diagram}\n\\board\n");
#line 699
  rank = 7;
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! (rank >= 0)) {
#line 699
      goto while_break;
    }
#line 700
    fprintf(annotate_out, (char const   *)"   {");
#line 701
    file = 0;
    {
#line 701
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 701
      if (! (file <= 7)) {
#line 701
        goto while_break___0;
      }
#line 702
      if ((rank + file) % 2) {
#line 703
        strcpy(filename, (char const   *)" ");
      } else {
#line 705
        strcpy(filename, (char const   *)"*");
      }
#line 706
      html_piece = (char )translate[(int )tree->position.board[(rank << 3) + file] + 6];
      {
#line 708
      if ((int )html_piece == 112) {
#line 708
        goto case_112;
      }
#line 711
      if ((int )html_piece == 114) {
#line 711
        goto case_114;
      }
#line 714
      if ((int )html_piece == 110) {
#line 714
        goto case_110;
      }
#line 717
      if ((int )html_piece == 98) {
#line 717
        goto case_98;
      }
#line 720
      if ((int )html_piece == 113) {
#line 720
        goto case_113;
      }
#line 723
      if ((int )html_piece == 107) {
#line 723
        goto case_107;
      }
#line 726
      if ((int )html_piece == 80) {
#line 726
        goto case_80;
      }
#line 729
      if ((int )html_piece == 82) {
#line 729
        goto case_82;
      }
#line 732
      if ((int )html_piece == 78) {
#line 732
        goto case_78;
      }
#line 735
      if ((int )html_piece == 66) {
#line 735
        goto case_66;
      }
#line 738
      if ((int )html_piece == 81) {
#line 738
        goto case_81;
      }
#line 741
      if ((int )html_piece == 75) {
#line 741
        goto case_75;
      }
#line 744
      goto switch_default;
      case_112: /* CIL Label */ 
#line 709
      strcpy(filename, (char const   *)"p");
#line 710
      goto switch_break;
      case_114: /* CIL Label */ 
#line 712
      strcpy(filename, (char const   *)"r");
#line 713
      goto switch_break;
      case_110: /* CIL Label */ 
#line 715
      strcpy(filename, (char const   *)"n");
#line 716
      goto switch_break;
      case_98: /* CIL Label */ 
#line 718
      strcpy(filename, (char const   *)"b");
#line 719
      goto switch_break;
      case_113: /* CIL Label */ 
#line 721
      strcpy(filename, (char const   *)"q");
#line 722
      goto switch_break;
      case_107: /* CIL Label */ 
#line 724
      strcpy(filename, (char const   *)"k");
#line 725
      goto switch_break;
      case_80: /* CIL Label */ 
#line 727
      strcpy(filename, (char const   *)"P");
#line 728
      goto switch_break;
      case_82: /* CIL Label */ 
#line 730
      strcpy(filename, (char const   *)"R");
#line 731
      goto switch_break;
      case_78: /* CIL Label */ 
#line 733
      strcpy(filename, (char const   *)"N");
#line 734
      goto switch_break;
      case_66: /* CIL Label */ 
#line 736
      strcpy(filename, (char const   *)"B");
#line 737
      goto switch_break;
      case_81: /* CIL Label */ 
#line 739
      strcpy(filename, (char const   *)"Q");
#line 740
      goto switch_break;
      case_75: /* CIL Label */ 
#line 742
      strcpy(filename, (char const   *)"K");
#line 743
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 745
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 747
      fprintf(annotate_out, (char const   *)"%s", filename);
#line 701
      file ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 749
    fprintf(annotate_out, (char const   *)"}\n");
#line 699
    rank --;
  }
  while_break: /* CIL Label */ ;
  }
#line 751
  fprintf(annotate_out, (char const   *)"\\end{diagram}\n");
#line 752
  fprintf(annotate_out, (char const   *)"\\begin{center} \\begin{nochess}\n  {\\small ");
#line 753
  if (wtm) {
#line 754
    fprintf(annotate_out, (char const   *)"White to move.\n");
  } else {
#line 756
    fprintf(annotate_out, (char const   *)"Black to move.\n");
  }
#line 757
  fprintf(annotate_out, (char const   *)"}\n \\end{nochess}\\end{center} \n\n");
#line 758
  fprintf(annotate_out, (char const   *)"\n");
#line 759
  return;
}
}
#line 761 "annotate.c"
static char buf[64]  ;
#line 760 "annotate.c"
char *AnnotateVtoNAG(int value , int wtm , int html_mode , int latex ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 763
  if (! wtm) {
#line 764
    value = - value;
  }
#line 765
  if (value > 150) {
#line 766
    if (html_mode) {
#line 766
      tmp = "+-";
    } else {
#line 766
      tmp = "$18";
    }
#line 766
    strcpy(buf, (char const   *)tmp);
  } else
#line 767
  if (value > 70) {
#line 768
    if (html_mode) {
#line 768
      tmp___0 = "+/-";
    } else {
#line 768
      tmp___0 = "$16";
    }
#line 768
    strcpy(buf, (char const   *)tmp___0);
  } else
#line 769
  if (value > 30) {
#line 770
    if (html_mode) {
#line 770
      tmp___1 = "+=";
    } else {
#line 770
      tmp___1 = "$14";
    }
#line 770
    strcpy(buf, (char const   *)tmp___1);
  } else
#line 771
  if (value < -150) {
#line 772
    if (html_mode) {
#line 772
      tmp___2 = "-+";
    } else {
#line 772
      tmp___2 = "$19";
    }
#line 772
    strcpy(buf, (char const   *)tmp___2);
  } else
#line 773
  if (value < -70) {
#line 774
    if (html_mode) {
#line 774
      tmp___3 = "-/+";
    } else {
#line 774
      tmp___3 = "$17";
    }
#line 774
    strcpy(buf, (char const   *)tmp___3);
  } else
#line 775
  if (value < -30) {
#line 776
    if (html_mode) {
#line 776
      tmp___4 = "=+";
    } else {
#line 776
      tmp___4 = "$15";
    }
#line 776
    strcpy(buf, (char const   *)tmp___4);
  } else {
#line 778
    if (html_mode) {
#line 778
      tmp___5 = "=";
    } else {
#line 778
      tmp___5 = "$10";
    }
#line 778
    strcpy(buf, (char const   *)tmp___5);
  }
#line 779
  if (latex == 1) {
#line 780
    if (value > 150) {
#line 781
      strcpy(buf, (char const   *)"\\wdecisive");
    } else
#line 782
    if (value > 70) {
#line 783
      strcpy(buf, (char const   *)"\\wupperhand");
    } else
#line 784
    if (value > 30) {
#line 785
      strcpy(buf, (char const   *)"\\wbetter");
    } else
#line 786
    if (value < -150) {
#line 787
      strcpy(buf, (char const   *)"\\bdecisive");
    } else
#line 788
    if (value < -70) {
#line 789
      strcpy(buf, (char const   *)"\\bupperhand");
    } else
#line 790
    if (value < -30) {
#line 791
      strcpy(buf, (char const   *)"\\bbetter");
    } else {
#line 793
      strcpy(buf, (char const   *)"\\equal");
    }
  }
#line 795
  return (buf);
}
}
#line 14 "bench.c"
int Bench(int increase , int autotune ) 
{ 
  uint64_t nodes ;
  int old_do ;
  int old_st ;
  int old_sd ;
  int total_time_used ;
  int pos ;
  int old_mt ;
  FILE *old_books ;
  FILE *old_book ;
  TREE *tree ;
  char fen[64][80] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  unsigned int tmp___56 ;
  unsigned int tmp___57 ;
  unsigned int tmp___58 ;
  unsigned int tmp___59 ;
  unsigned int tmp___60 ;
  unsigned int tmp___61 ;
  unsigned int tmp___62 ;
  int fen_depth ;
  uint64_t tmp___63 ;
  char *tmp___64 ;
  uint64_t tmp___65 ;
  char *tmp___66 ;

  {
#line 15
  nodes = (uint64_t )0;
#line 16
  old_mt = (int )smp_max_threads;
#line 18
  tree = (TREE *)block[0];
#line 19
  fen[0][0] = (char )'3';
#line 19
  fen[0][1] = (char )'q';
#line 19
  fen[0][2] = (char )'2';
#line 19
  fen[0][3] = (char )'k';
#line 19
  fen[0][4] = (char )'1';
#line 19
  fen[0][5] = (char )'/';
#line 19
  fen[0][6] = (char )'p';
#line 19
  fen[0][7] = (char )'b';
#line 19
  fen[0][8] = (char )'3';
#line 19
  fen[0][9] = (char )'p';
#line 19
  fen[0][10] = (char )'1';
#line 19
  fen[0][11] = (char )'p';
#line 19
  fen[0][12] = (char )'/';
#line 19
  fen[0][13] = (char )'4';
#line 19
  fen[0][14] = (char )'p';
#line 19
  fen[0][15] = (char )'b';
#line 19
  fen[0][16] = (char )'p';
#line 19
  fen[0][17] = (char )'1';
#line 19
  fen[0][18] = (char )'/';
#line 19
  fen[0][19] = (char )'2';
#line 19
  fen[0][20] = (char )'r';
#line 19
  fen[0][21] = (char )'5';
#line 19
  fen[0][22] = (char )'/';
#line 19
  fen[0][23] = (char )'P';
#line 19
  fen[0][24] = (char )'p';
#line 19
  fen[0][25] = (char )'N';
#line 19
  fen[0][26] = (char )'2';
#line 19
  fen[0][27] = (char )'N';
#line 19
  fen[0][28] = (char )'2';
#line 19
  fen[0][29] = (char )'/';
#line 19
  fen[0][30] = (char )'1';
#line 19
  fen[0][31] = (char )'P';
#line 19
  fen[0][32] = (char )'2';
#line 19
  fen[0][33] = (char )'P';
#line 19
  fen[0][34] = (char )'2';
#line 19
  fen[0][35] = (char )'P';
#line 19
  fen[0][36] = (char )'/';
#line 19
  fen[0][37] = (char )'5';
#line 19
  fen[0][38] = (char )'P';
#line 19
  fen[0][39] = (char )'P';
#line 19
  fen[0][40] = (char )'1';
#line 19
  fen[0][41] = (char )'/';
#line 19
  fen[0][42] = (char )'Q';
#line 19
  fen[0][43] = (char )'2';
#line 19
  fen[0][44] = (char )'R';
#line 19
  fen[0][45] = (char )'2';
#line 19
  fen[0][46] = (char )'K';
#line 19
  fen[0][47] = (char )'1';
#line 19
  fen[0][48] = (char )' ';
#line 19
  fen[0][49] = (char )'b';
#line 19
  fen[0][50] = (char )'\000';
#line 19
  tmp = 51U;
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    if (tmp >= 80U) {
#line 19
      goto while_break;
    }
#line 19
    fen[0][tmp] = (char)0;
#line 19
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 19
  fen[1][0] = (char )'2';
#line 19
  fen[1][1] = (char )'r';
#line 19
  fen[1][2] = (char )'2';
#line 19
  fen[1][3] = (char )'r';
#line 19
  fen[1][4] = (char )'k';
#line 19
  fen[1][5] = (char )'1';
#line 19
  fen[1][6] = (char )'/';
#line 19
  fen[1][7] = (char )'1';
#line 19
  fen[1][8] = (char )'b';
#line 19
  fen[1][9] = (char )'q';
#line 19
  fen[1][10] = (char )'n';
#line 19
  fen[1][11] = (char )'b';
#line 19
  fen[1][12] = (char )'p';
#line 19
  fen[1][13] = (char )'p';
#line 19
  fen[1][14] = (char )'1';
#line 19
  fen[1][15] = (char )'/';
#line 19
  fen[1][16] = (char )'1';
#line 19
  fen[1][17] = (char )'p';
#line 19
  fen[1][18] = (char )'1';
#line 19
  fen[1][19] = (char )'p';
#line 19
  fen[1][20] = (char )'p';
#line 19
  fen[1][21] = (char )'n';
#line 19
  fen[1][22] = (char )'1';
#line 19
  fen[1][23] = (char )'p';
#line 19
  fen[1][24] = (char )'/';
#line 19
  fen[1][25] = (char )'p';
#line 19
  fen[1][26] = (char )'P';
#line 19
  fen[1][27] = (char )'6';
#line 19
  fen[1][28] = (char )'/';
#line 19
  fen[1][29] = (char )'N';
#line 19
  fen[1][30] = (char )'1';
#line 19
  fen[1][31] = (char )'P';
#line 19
  fen[1][32] = (char )'1';
#line 19
  fen[1][33] = (char )'P';
#line 19
  fen[1][34] = (char )'3';
#line 19
  fen[1][35] = (char )'/';
#line 19
  fen[1][36] = (char )'P';
#line 19
  fen[1][37] = (char )'2';
#line 19
  fen[1][38] = (char )'B';
#line 19
  fen[1][39] = (char )'1';
#line 19
  fen[1][40] = (char )'N';
#line 19
  fen[1][41] = (char )'1';
#line 19
  fen[1][42] = (char )'P';
#line 19
  fen[1][43] = (char )'/';
#line 19
  fen[1][44] = (char )'1';
#line 19
  fen[1][45] = (char )'B';
#line 19
  fen[1][46] = (char )'2';
#line 19
  fen[1][47] = (char )'Q';
#line 19
  fen[1][48] = (char )'P';
#line 19
  fen[1][49] = (char )'P';
#line 19
  fen[1][50] = (char )'1';
#line 19
  fen[1][51] = (char )'/';
#line 19
  fen[1][52] = (char )'R';
#line 19
  fen[1][53] = (char )'2';
#line 19
  fen[1][54] = (char )'R';
#line 19
  fen[1][55] = (char )'2';
#line 19
  fen[1][56] = (char )'K';
#line 19
  fen[1][57] = (char )'1';
#line 19
  fen[1][58] = (char )' ';
#line 19
  fen[1][59] = (char )'b';
#line 19
  fen[1][60] = (char )'\000';
#line 19
  tmp___0 = 61U;
  {
#line 19
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 19
    if (tmp___0 >= 80U) {
#line 19
      goto while_break___0;
    }
#line 19
    fen[1][tmp___0] = (char)0;
#line 19
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 19
  fen[2][0] = (char )'3';
#line 19
  fen[2][1] = (char )'r';
#line 19
  fen[2][2] = (char )'r';
#line 19
  fen[2][3] = (char )'1';
#line 19
  fen[2][4] = (char )'k';
#line 19
  fen[2][5] = (char )'1';
#line 19
  fen[2][6] = (char )'/';
#line 19
  fen[2][7] = (char )'p';
#line 19
  fen[2][8] = (char )'p';
#line 19
  fen[2][9] = (char )'3';
#line 19
  fen[2][10] = (char )'p';
#line 19
  fen[2][11] = (char )'p';
#line 19
  fen[2][12] = (char )'1';
#line 19
  fen[2][13] = (char )'/';
#line 19
  fen[2][14] = (char )'1';
#line 19
  fen[2][15] = (char )'q';
#line 19
  fen[2][16] = (char )'n';
#line 19
  fen[2][17] = (char )'2';
#line 19
  fen[2][18] = (char )'n';
#line 19
  fen[2][19] = (char )'p';
#line 19
  fen[2][20] = (char )'1';
#line 19
  fen[2][21] = (char )'/';
#line 19
  fen[2][22] = (char )'8';
#line 19
  fen[2][23] = (char )'/';
#line 19
  fen[2][24] = (char )'3';
#line 19
  fen[2][25] = (char )'p';
#line 19
  fen[2][26] = (char )'4';
#line 19
  fen[2][27] = (char )'/';
#line 19
  fen[2][28] = (char )'P';
#line 19
  fen[2][29] = (char )'P';
#line 19
  fen[2][30] = (char )'1';
#line 19
  fen[2][31] = (char )'R';
#line 19
  fen[2][32] = (char )'1';
#line 19
  fen[2][33] = (char )'P';
#line 19
  fen[2][34] = (char )'2';
#line 19
  fen[2][35] = (char )'/';
#line 19
  fen[2][36] = (char )'2';
#line 19
  fen[2][37] = (char )'P';
#line 19
  fen[2][38] = (char )'1';
#line 19
  fen[2][39] = (char )'N';
#line 19
  fen[2][40] = (char )'Q';
#line 19
  fen[2][41] = (char )'P';
#line 19
  fen[2][42] = (char )'P';
#line 19
  fen[2][43] = (char )'/';
#line 19
  fen[2][44] = (char )'R';
#line 19
  fen[2][45] = (char )'1';
#line 19
  fen[2][46] = (char )'B';
#line 19
  fen[2][47] = (char )'3';
#line 19
  fen[2][48] = (char )'K';
#line 19
  fen[2][49] = (char )'1';
#line 19
  fen[2][50] = (char )' ';
#line 19
  fen[2][51] = (char )'b';
#line 19
  fen[2][52] = (char )'\000';
#line 19
  tmp___1 = 53U;
  {
#line 19
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 19
    if (tmp___1 >= 80U) {
#line 19
      goto while_break___1;
    }
#line 19
    fen[2][tmp___1] = (char)0;
#line 19
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 19
  fen[3][0] = (char )'4';
#line 19
  fen[3][1] = (char )'r';
#line 19
  fen[3][2] = (char )'1';
#line 19
  fen[3][3] = (char )'k';
#line 19
  fen[3][4] = (char )'1';
#line 19
  fen[3][5] = (char )'/';
#line 19
  fen[3][6] = (char )'r';
#line 19
  fen[3][7] = (char )'1';
#line 19
  fen[3][8] = (char )'q';
#line 19
  fen[3][9] = (char )'2';
#line 19
  fen[3][10] = (char )'p';
#line 19
  fen[3][11] = (char )'p';
#line 19
  fen[3][12] = (char )'p';
#line 19
  fen[3][13] = (char )'/';
#line 19
  fen[3][14] = (char )'p';
#line 19
  fen[3][15] = (char )'p';
#line 19
  fen[3][16] = (char )'p';
#line 19
  fen[3][17] = (char )'2';
#line 19
  fen[3][18] = (char )'n';
#line 19
  fen[3][19] = (char )'2';
#line 19
  fen[3][20] = (char )'/';
#line 19
  fen[3][21] = (char )'4';
#line 19
  fen[3][22] = (char )'P';
#line 19
  fen[3][23] = (char )'3';
#line 19
  fen[3][24] = (char )'/';
#line 19
  fen[3][25] = (char )'5';
#line 19
  fen[3][26] = (char )'R';
#line 19
  fen[3][27] = (char )'b';
#line 19
  fen[3][28] = (char )'1';
#line 19
  fen[3][29] = (char )'/';
#line 19
  fen[3][30] = (char )'1';
#line 19
  fen[3][31] = (char )'N';
#line 19
  fen[3][32] = (char )'1';
#line 19
  fen[3][33] = (char )'B';
#line 19
  fen[3][34] = (char )'Q';
#line 19
  fen[3][35] = (char )'3';
#line 19
  fen[3][36] = (char )'/';
#line 19
  fen[3][37] = (char )'P';
#line 19
  fen[3][38] = (char )'P';
#line 19
  fen[3][39] = (char )'P';
#line 19
  fen[3][40] = (char )'3';
#line 19
  fen[3][41] = (char )'P';
#line 19
  fen[3][42] = (char )'P';
#line 19
  fen[3][43] = (char )'/';
#line 19
  fen[3][44] = (char )'R';
#line 19
  fen[3][45] = (char )'5';
#line 19
  fen[3][46] = (char )'K';
#line 19
  fen[3][47] = (char )'1';
#line 19
  fen[3][48] = (char )' ';
#line 19
  fen[3][49] = (char )'w';
#line 19
  fen[3][50] = (char )'\000';
#line 19
  tmp___2 = 51U;
  {
#line 19
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 19
    if (tmp___2 >= 80U) {
#line 19
      goto while_break___2;
    }
#line 19
    fen[3][tmp___2] = (char)0;
#line 19
    tmp___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 19
  fen[4][0] = (char )'1';
#line 19
  fen[4][1] = (char )'r';
#line 19
  fen[4][2] = (char )'3';
#line 19
  fen[4][3] = (char )'k';
#line 19
  fen[4][4] = (char )'2';
#line 19
  fen[4][5] = (char )'/';
#line 19
  fen[4][6] = (char )'4';
#line 19
  fen[4][7] = (char )'q';
#line 19
  fen[4][8] = (char )'3';
#line 19
  fen[4][9] = (char )'/';
#line 19
  fen[4][10] = (char )'2';
#line 19
  fen[4][11] = (char )'P';
#line 19
  fen[4][12] = (char )'p';
#line 19
  fen[4][13] = (char )'3';
#line 19
  fen[4][14] = (char )'b';
#line 19
  fen[4][15] = (char )'/';
#line 19
  fen[4][16] = (char )'3';
#line 19
  fen[4][17] = (char )'B';
#line 19
  fen[4][18] = (char )'p';
#line 19
  fen[4][19] = (char )'3';
#line 19
  fen[4][20] = (char )'/';
#line 19
  fen[4][21] = (char )'2';
#line 19
  fen[4][22] = (char )'Q';
#line 19
  fen[4][23] = (char )'2';
#line 19
  fen[4][24] = (char )'p';
#line 19
  fen[4][25] = (char )'2';
#line 19
  fen[4][26] = (char )'/';
#line 19
  fen[4][27] = (char )'1';
#line 19
  fen[4][28] = (char )'p';
#line 19
  fen[4][29] = (char )'1';
#line 19
  fen[4][30] = (char )'P';
#line 19
  fen[4][31] = (char )'2';
#line 19
  fen[4][32] = (char )'P';
#line 19
  fen[4][33] = (char )'1';
#line 19
  fen[4][34] = (char )'/';
#line 19
  fen[4][35] = (char )'1';
#line 19
  fen[4][36] = (char )'P';
#line 19
  fen[4][37] = (char )'2';
#line 19
  fen[4][38] = (char )'K';
#line 19
  fen[4][39] = (char )'P';
#line 19
  fen[4][40] = (char )'2';
#line 19
  fen[4][41] = (char )'/';
#line 19
  fen[4][42] = (char )'3';
#line 19
  fen[4][43] = (char )'N';
#line 19
  fen[4][44] = (char )'4';
#line 19
  fen[4][45] = (char )' ';
#line 19
  fen[4][46] = (char )'w';
#line 19
  fen[4][47] = (char )'\000';
#line 19
  tmp___3 = 48U;
  {
#line 19
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 19
    if (tmp___3 >= 80U) {
#line 19
      goto while_break___3;
    }
#line 19
    fen[4][tmp___3] = (char)0;
#line 19
    tmp___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 19
  fen[5][0] = (char )'3';
#line 19
  fen[5][1] = (char )'r';
#line 19
  fen[5][2] = (char )'1';
#line 19
  fen[5][3] = (char )'r';
#line 19
  fen[5][4] = (char )'k';
#line 19
  fen[5][5] = (char )'1';
#line 19
  fen[5][6] = (char )'/';
#line 19
  fen[5][7] = (char )'p';
#line 19
  fen[5][8] = (char )'5';
#line 19
  fen[5][9] = (char )'p';
#line 19
  fen[5][10] = (char )'p';
#line 19
  fen[5][11] = (char )'/';
#line 19
  fen[5][12] = (char )'b';
#line 19
  fen[5][13] = (char )'p';
#line 19
  fen[5][14] = (char )'p';
#line 19
  fen[5][15] = (char )'1';
#line 19
  fen[5][16] = (char )'p';
#line 19
  fen[5][17] = (char )'p';
#line 19
  fen[5][18] = (char )'2';
#line 19
  fen[5][19] = (char )'/';
#line 19
  fen[5][20] = (char )'8';
#line 19
  fen[5][21] = (char )'/';
#line 19
  fen[5][22] = (char )'q';
#line 19
  fen[5][23] = (char )'1';
#line 19
  fen[5][24] = (char )'P';
#line 19
  fen[5][25] = (char )'P';
#line 19
  fen[5][26] = (char )'1';
#line 19
  fen[5][27] = (char )'P';
#line 19
  fen[5][28] = (char )'2';
#line 19
  fen[5][29] = (char )'/';
#line 19
  fen[5][30] = (char )'b';
#line 19
  fen[5][31] = (char )'3';
#line 19
  fen[5][32] = (char )'P';
#line 19
  fen[5][33] = (char )'3';
#line 19
  fen[5][34] = (char )'/';
#line 19
  fen[5][35] = (char )'P';
#line 19
  fen[5][36] = (char )'2';
#line 19
  fen[5][37] = (char )'N';
#line 19
  fen[5][38] = (char )'Q';
#line 19
  fen[5][39] = (char )'R';
#line 19
  fen[5][40] = (char )'P';
#line 19
  fen[5][41] = (char )'P';
#line 19
  fen[5][42] = (char )'/';
#line 19
  fen[5][43] = (char )'1';
#line 19
  fen[5][44] = (char )'R';
#line 19
  fen[5][45] = (char )'2';
#line 19
  fen[5][46] = (char )'B';
#line 19
  fen[5][47] = (char )'1';
#line 19
  fen[5][48] = (char )'K';
#line 19
  fen[5][49] = (char )'1';
#line 19
  fen[5][50] = (char )' ';
#line 19
  fen[5][51] = (char )'b';
#line 19
  fen[5][52] = (char )'\000';
#line 19
  tmp___4 = 53U;
  {
#line 19
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 19
    if (tmp___4 >= 80U) {
#line 19
      goto while_break___4;
    }
#line 19
    fen[5][tmp___4] = (char)0;
#line 19
    tmp___4 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 19
  fen[6][0] = (char )'8';
#line 19
  fen[6][1] = (char )'/';
#line 19
  fen[6][2] = (char )'R';
#line 19
  fen[6][3] = (char )'7';
#line 19
  fen[6][4] = (char )'/';
#line 19
  fen[6][5] = (char )'2';
#line 19
  fen[6][6] = (char )'q';
#line 19
  fen[6][7] = (char )'5';
#line 19
  fen[6][8] = (char )'/';
#line 19
  fen[6][9] = (char )'8';
#line 19
  fen[6][10] = (char )'/';
#line 19
  fen[6][11] = (char )'6';
#line 19
  fen[6][12] = (char )'k';
#line 19
  fen[6][13] = (char )'1';
#line 19
  fen[6][14] = (char )'/';
#line 19
  fen[6][15] = (char )'8';
#line 19
  fen[6][16] = (char )'/';
#line 19
  fen[6][17] = (char )'1';
#line 19
  fen[6][18] = (char )'P';
#line 19
  fen[6][19] = (char )'5';
#line 19
  fen[6][20] = (char )'p';
#line 19
  fen[6][21] = (char )'/';
#line 19
  fen[6][22] = (char )'K';
#line 19
  fen[6][23] = (char )'6';
#line 19
  fen[6][24] = (char )'R';
#line 19
  fen[6][25] = (char )' ';
#line 19
  fen[6][26] = (char )'w';
#line 19
  fen[6][27] = (char )'\000';
#line 19
  tmp___5 = 28U;
  {
#line 19
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 19
    if (tmp___5 >= 80U) {
#line 19
      goto while_break___5;
    }
#line 19
    fen[6][tmp___5] = (char)0;
#line 19
    tmp___5 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 19
  fen[7][0] = (char )'2';
#line 19
  fen[7][1] = (char )'r';
#line 19
  fen[7][2] = (char )'3';
#line 19
  fen[7][3] = (char )'k';
#line 19
  fen[7][4] = (char )'1';
#line 19
  fen[7][5] = (char )'/';
#line 19
  fen[7][6] = (char )'1';
#line 19
  fen[7][7] = (char )'p';
#line 19
  fen[7][8] = (char )'2';
#line 19
  fen[7][9] = (char )'q';
#line 19
  fen[7][10] = (char )'1';
#line 19
  fen[7][11] = (char )'p';
#line 19
  fen[7][12] = (char )'p';
#line 19
  fen[7][13] = (char )'/';
#line 19
  fen[7][14] = (char )'2';
#line 19
  fen[7][15] = (char )'b';
#line 19
  fen[7][16] = (char )'1';
#line 19
  fen[7][17] = (char )'p';
#line 19
  fen[7][18] = (char )'r';
#line 19
  fen[7][19] = (char )'2';
#line 19
  fen[7][20] = (char )'/';
#line 19
  fen[7][21] = (char )'p';
#line 19
  fen[7][22] = (char )'1';
#line 19
  fen[7][23] = (char )'p';
#line 19
  fen[7][24] = (char )'p';
#line 19
  fen[7][25] = (char )'4';
#line 19
  fen[7][26] = (char )'/';
#line 19
  fen[7][27] = (char )'6';
#line 19
  fen[7][28] = (char )'Q';
#line 19
  fen[7][29] = (char )'1';
#line 19
  fen[7][30] = (char )'/';
#line 19
  fen[7][31] = (char )'1';
#line 19
  fen[7][32] = (char )'P';
#line 19
  fen[7][33] = (char )'1';
#line 19
  fen[7][34] = (char )'P';
#line 19
  fen[7][35] = (char )'P';
#line 19
  fen[7][36] = (char )'1';
#line 19
  fen[7][37] = (char )'R';
#line 19
  fen[7][38] = (char )'1';
#line 19
  fen[7][39] = (char )'/';
#line 19
  fen[7][40] = (char )'P';
#line 19
  fen[7][41] = (char )'1';
#line 19
  fen[7][42] = (char )'P';
#line 19
  fen[7][43] = (char )'N';
#line 19
  fen[7][44] = (char )'2';
#line 19
  fen[7][45] = (char )'P';
#line 19
  fen[7][46] = (char )'P';
#line 19
  fen[7][47] = (char )'/';
#line 19
  fen[7][48] = (char )'5';
#line 19
  fen[7][49] = (char )'R';
#line 19
  fen[7][50] = (char )'K';
#line 19
  fen[7][51] = (char )'1';
#line 19
  fen[7][52] = (char )' ';
#line 19
  fen[7][53] = (char )'w';
#line 19
  fen[7][54] = (char )'\000';
#line 19
  tmp___6 = 55U;
  {
#line 19
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 19
    if (tmp___6 >= 80U) {
#line 19
      goto while_break___6;
    }
#line 19
    fen[7][tmp___6] = (char)0;
#line 19
    tmp___6 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 19
  fen[8][0] = (char )'4';
#line 19
  fen[8][1] = (char )'r';
#line 19
  fen[8][2] = (char )'r';
#line 19
  fen[8][3] = (char )'k';
#line 19
  fen[8][4] = (char )'1';
#line 19
  fen[8][5] = (char )'/';
#line 19
  fen[8][6] = (char )'p';
#line 19
  fen[8][7] = (char )'p';
#line 19
  fen[8][8] = (char )'1';
#line 19
  fen[8][9] = (char )'n';
#line 19
  fen[8][10] = (char )'3';
#line 19
  fen[8][11] = (char )'p';
#line 19
  fen[8][12] = (char )'/';
#line 19
  fen[8][13] = (char )'3';
#line 19
  fen[8][14] = (char )'q';
#line 19
  fen[8][15] = (char )'2';
#line 19
  fen[8][16] = (char )'p';
#line 19
  fen[8][17] = (char )'Q';
#line 19
  fen[8][18] = (char )'/';
#line 19
  fen[8][19] = (char )'2';
#line 19
  fen[8][20] = (char )'p';
#line 19
  fen[8][21] = (char )'1';
#line 19
  fen[8][22] = (char )'p';
#line 19
  fen[8][23] = (char )'b';
#line 19
  fen[8][24] = (char )'2';
#line 19
  fen[8][25] = (char )'/';
#line 19
  fen[8][26] = (char )'2';
#line 19
  fen[8][27] = (char )'P';
#line 19
  fen[8][28] = (char )'P';
#line 19
  fen[8][29] = (char )'4';
#line 19
  fen[8][30] = (char )'/';
#line 19
  fen[8][31] = (char )'2';
#line 19
  fen[8][32] = (char )'P';
#line 19
  fen[8][33] = (char )'3';
#line 19
  fen[8][34] = (char )'N';
#line 19
  fen[8][35] = (char )'1';
#line 19
  fen[8][36] = (char )'/';
#line 19
  fen[8][37] = (char )'P';
#line 19
  fen[8][38] = (char )'2';
#line 19
  fen[8][39] = (char )'B';
#line 19
  fen[8][40] = (char )'2';
#line 19
  fen[8][41] = (char )'P';
#line 19
  fen[8][42] = (char )'P';
#line 19
  fen[8][43] = (char )'/';
#line 19
  fen[8][44] = (char )'4';
#line 19
  fen[8][45] = (char )'R';
#line 19
  fen[8][46] = (char )'R';
#line 19
  fen[8][47] = (char )'K';
#line 19
  fen[8][48] = (char )'1';
#line 19
  fen[8][49] = (char )' ';
#line 19
  fen[8][50] = (char )'b';
#line 19
  fen[8][51] = (char )'\000';
#line 19
  tmp___7 = 52U;
  {
#line 19
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 19
    if (tmp___7 >= 80U) {
#line 19
      goto while_break___7;
    }
#line 19
    fen[8][tmp___7] = (char)0;
#line 19
    tmp___7 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 19
  fen[9][0] = (char )'5';
#line 19
  fen[9][1] = (char )'r';
#line 19
  fen[9][2] = (char )'1';
#line 19
  fen[9][3] = (char )'k';
#line 19
  fen[9][4] = (char )'/';
#line 19
  fen[9][5] = (char )'6';
#line 19
  fen[9][6] = (char )'p';
#line 19
  fen[9][7] = (char )'/';
#line 19
  fen[9][8] = (char )'1';
#line 19
  fen[9][9] = (char )'n';
#line 19
  fen[9][10] = (char )'2';
#line 19
  fen[9][11] = (char )'Q';
#line 19
  fen[9][12] = (char )'2';
#line 19
  fen[9][13] = (char )'p';
#line 19
  fen[9][14] = (char )'/';
#line 19
  fen[9][15] = (char )'4';
#line 19
  fen[9][16] = (char )'p';
#line 19
  fen[9][17] = (char )'/';
#line 19
  fen[9][18] = (char )'/';
#line 19
  fen[9][19] = (char )'7';
#line 19
  fen[9][20] = (char )'P';
#line 19
  fen[9][21] = (char )'/';
#line 19
  fen[9][22] = (char )'P';
#line 19
  fen[9][23] = (char )'P';
#line 19
  fen[9][24] = (char )'4';
#line 19
  fen[9][25] = (char )'P';
#line 19
  fen[9][26] = (char )'K';
#line 19
  fen[9][27] = (char )'/';
#line 19
  fen[9][28] = (char )'R';
#line 19
  fen[9][29] = (char )'1';
#line 19
  fen[9][30] = (char )'B';
#line 19
  fen[9][31] = (char )'1';
#line 19
  fen[9][32] = (char )'q';
#line 19
  fen[9][33] = (char )'/';
#line 19
  fen[9][34] = (char )' ';
#line 19
  fen[9][35] = (char )'w';
#line 19
  fen[9][36] = (char )'\000';
#line 19
  tmp___8 = 37U;
  {
#line 19
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 19
    if (tmp___8 >= 80U) {
#line 19
      goto while_break___8;
    }
#line 19
    fen[9][tmp___8] = (char)0;
#line 19
    tmp___8 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 19
  fen[10][0] = (char )'4';
#line 19
  fen[10][1] = (char )'b';
#line 19
  fen[10][2] = (char )'3';
#line 19
  fen[10][3] = (char )'/';
#line 19
  fen[10][4] = (char )'p';
#line 19
  fen[10][5] = (char )'3';
#line 19
  fen[10][6] = (char )'k';
#line 19
  fen[10][7] = (char )'p';
#line 19
  fen[10][8] = (char )'2';
#line 19
  fen[10][9] = (char )'/';
#line 19
  fen[10][10] = (char )'6';
#line 19
  fen[10][11] = (char )'p';
#line 19
  fen[10][12] = (char )'1';
#line 19
  fen[10][13] = (char )'/';
#line 19
  fen[10][14] = (char )'3';
#line 19
  fen[10][15] = (char )'p';
#line 19
  fen[10][16] = (char )'P';
#line 19
  fen[10][17] = (char )'2';
#line 19
  fen[10][18] = (char )'p';
#line 19
  fen[10][19] = (char )'/';
#line 19
  fen[10][20] = (char )'2';
#line 19
  fen[10][21] = (char )'p';
#line 19
  fen[10][22] = (char )'P';
#line 19
  fen[10][23] = (char )'1';
#line 19
  fen[10][24] = (char )'P';
#line 19
  fen[10][25] = (char )'2';
#line 19
  fen[10][26] = (char )'/';
#line 19
  fen[10][27] = (char )'4';
#line 19
  fen[10][28] = (char )'K';
#line 19
  fen[10][29] = (char )'1';
#line 19
  fen[10][30] = (char )'P';
#line 19
  fen[10][31] = (char )'1';
#line 19
  fen[10][32] = (char )'/';
#line 19
  fen[10][33] = (char )'P';
#line 19
  fen[10][34] = (char )'3';
#line 19
  fen[10][35] = (char )'N';
#line 19
  fen[10][36] = (char )'2';
#line 19
  fen[10][37] = (char )'P';
#line 19
  fen[10][38] = (char )'/';
#line 19
  fen[10][39] = (char )'8';
#line 19
  fen[10][40] = (char )' ';
#line 19
  fen[10][41] = (char )'w';
#line 19
  fen[10][42] = (char )'\000';
#line 19
  tmp___9 = 43U;
  {
#line 19
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 19
    if (tmp___9 >= 80U) {
#line 19
      goto while_break___9;
    }
#line 19
    fen[10][tmp___9] = (char)0;
#line 19
    tmp___9 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 19
  fen[11][0] = (char )'r';
#line 19
  fen[11][1] = (char )'1';
#line 19
  fen[11][2] = (char )'b';
#line 19
  fen[11][3] = (char )'q';
#line 19
  fen[11][4] = (char )'k';
#line 19
  fen[11][5] = (char )'b';
#line 19
  fen[11][6] = (char )'1';
#line 19
  fen[11][7] = (char )'r';
#line 19
  fen[11][8] = (char )'/';
#line 19
  fen[11][9] = (char )'4';
#line 19
  fen[11][10] = (char )'n';
#line 19
  fen[11][11] = (char )'p';
#line 19
  fen[11][12] = (char )'p';
#line 19
  fen[11][13] = (char )'1';
#line 19
  fen[11][14] = (char )'/';
#line 19
  fen[11][15] = (char )'p';
#line 19
  fen[11][16] = (char )'1';
#line 19
  fen[11][17] = (char )'p';
#line 19
  fen[11][18] = (char )'4';
#line 19
  fen[11][19] = (char )'p';
#line 19
  fen[11][20] = (char )'/';
#line 19
  fen[11][21] = (char )'1';
#line 19
  fen[11][22] = (char )'p';
#line 19
  fen[11][23] = (char )'1';
#line 19
  fen[11][24] = (char )'p';
#line 19
  fen[11][25] = (char )'P';
#line 19
  fen[11][26] = (char )'1';
#line 19
  fen[11][27] = (char )'B';
#line 19
  fen[11][28] = (char )'1';
#line 19
  fen[11][29] = (char )'/';
#line 19
  fen[11][30] = (char )'8';
#line 19
  fen[11][31] = (char )'/';
#line 19
  fen[11][32] = (char )'1';
#line 19
  fen[11][33] = (char )'B';
#line 19
  fen[11][34] = (char )'6';
#line 19
  fen[11][35] = (char )'/';
#line 19
  fen[11][36] = (char )'P';
#line 19
  fen[11][37] = (char )'P';
#line 19
  fen[11][38] = (char )'P';
#line 19
  fen[11][39] = (char )'N';
#line 19
  fen[11][40] = (char )'1';
#line 19
  fen[11][41] = (char )'P';
#line 19
  fen[11][42] = (char )'P';
#line 19
  fen[11][43] = (char )'P';
#line 19
  fen[11][44] = (char )'/';
#line 19
  fen[11][45] = (char )'R';
#line 19
  fen[11][46] = (char )'2';
#line 19
  fen[11][47] = (char )'Q';
#line 19
  fen[11][48] = (char )'1';
#line 19
  fen[11][49] = (char )'R';
#line 19
  fen[11][50] = (char )'K';
#line 19
  fen[11][51] = (char )'1';
#line 19
  fen[11][52] = (char )' ';
#line 19
  fen[11][53] = (char )'w';
#line 19
  fen[11][54] = (char )'\000';
#line 19
  tmp___10 = 55U;
  {
#line 19
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 19
    if (tmp___10 >= 80U) {
#line 19
      goto while_break___10;
    }
#line 19
    fen[11][tmp___10] = (char)0;
#line 19
    tmp___10 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 19
  fen[12][0] = (char )'7';
#line 19
  fen[12][1] = (char )'k';
#line 19
  fen[12][2] = (char )'/';
#line 19
  fen[12][3] = (char )'3';
#line 19
  fen[12][4] = (char )'p';
#line 19
  fen[12][5] = (char )'2';
#line 19
  fen[12][6] = (char )'p';
#line 19
  fen[12][7] = (char )'p';
#line 19
  fen[12][8] = (char )'/';
#line 19
  fen[12][9] = (char )'4';
#line 19
  fen[12][10] = (char )'q';
#line 19
  fen[12][11] = (char )'3';
#line 19
  fen[12][12] = (char )'/';
#line 19
  fen[12][13] = (char )'8';
#line 19
  fen[12][14] = (char )'/';
#line 19
  fen[12][15] = (char )'4';
#line 19
  fen[12][16] = (char )'Q';
#line 19
  fen[12][17] = (char )'3';
#line 19
  fen[12][18] = (char )'/';
#line 19
  fen[12][19] = (char )'5';
#line 19
  fen[12][20] = (char )'K';
#line 19
  fen[12][21] = (char )'p';
#line 19
  fen[12][22] = (char )'1';
#line 19
  fen[12][23] = (char )'/';
#line 19
  fen[12][24] = (char )'P';
#line 19
  fen[12][25] = (char )'6';
#line 19
  fen[12][26] = (char )'b';
#line 19
  fen[12][27] = (char )'/';
#line 19
  fen[12][28] = (char )'8';
#line 19
  fen[12][29] = (char )' ';
#line 19
  fen[12][30] = (char )'w';
#line 19
  fen[12][31] = (char )'\000';
#line 19
  tmp___11 = 32U;
  {
#line 19
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 19
    if (tmp___11 >= 80U) {
#line 19
      goto while_break___11;
    }
#line 19
    fen[12][tmp___11] = (char)0;
#line 19
    tmp___11 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 19
  fen[13][0] = (char )'2';
#line 19
  fen[13][1] = (char )'r';
#line 19
  fen[13][2] = (char )'1';
#line 19
  fen[13][3] = (char )'n';
#line 19
  fen[13][4] = (char )'r';
#line 19
  fen[13][5] = (char )'k';
#line 19
  fen[13][6] = (char )'1';
#line 19
  fen[13][7] = (char )'/';
#line 19
  fen[13][8] = (char )'p';
#line 19
  fen[13][9] = (char )'2';
#line 19
  fen[13][10] = (char )'q';
#line 19
  fen[13][11] = (char )'1';
#line 19
  fen[13][12] = (char )'p';
#line 19
  fen[13][13] = (char )'p';
#line 19
  fen[13][14] = (char )'p';
#line 19
  fen[13][15] = (char )'/';
#line 19
  fen[13][16] = (char )'b';
#line 19
  fen[13][17] = (char )'p';
#line 19
  fen[13][18] = (char )'1';
#line 19
  fen[13][19] = (char )'p';
#line 19
  fen[13][20] = (char )'4';
#line 19
  fen[13][21] = (char )'/';
#line 19
  fen[13][22] = (char )'n';
#line 19
  fen[13][23] = (char )'1';
#line 19
  fen[13][24] = (char )'p';
#line 19
  fen[13][25] = (char )'P';
#line 19
  fen[13][26] = (char )'p';
#line 19
  fen[13][27] = (char )'3';
#line 19
  fen[13][28] = (char )'/';
#line 19
  fen[13][29] = (char )'P';
#line 19
  fen[13][30] = (char )'1';
#line 19
  fen[13][31] = (char )'P';
#line 19
  fen[13][32] = (char )'1';
#line 19
  fen[13][33] = (char )'P';
#line 19
  fen[13][34] = (char )'3';
#line 19
  fen[13][35] = (char )'/';
#line 19
  fen[13][36] = (char )'2';
#line 19
  fen[13][37] = (char )'P';
#line 19
  fen[13][38] = (char )'B';
#line 19
  fen[13][39] = (char )'B';
#line 19
  fen[13][40] = (char )'1';
#line 19
  fen[13][41] = (char )'N';
#line 19
  fen[13][42] = (char )'1';
#line 19
  fen[13][43] = (char )'/';
#line 19
  fen[13][44] = (char )'4';
#line 19
  fen[13][45] = (char )'Q';
#line 19
  fen[13][46] = (char )'P';
#line 19
  fen[13][47] = (char )'P';
#line 19
  fen[13][48] = (char )'P';
#line 19
  fen[13][49] = (char )'/';
#line 19
  fen[13][50] = (char )'R';
#line 19
  fen[13][51] = (char )'4';
#line 19
  fen[13][52] = (char )'R';
#line 19
  fen[13][53] = (char )'K';
#line 19
  fen[13][54] = (char )'1';
#line 19
  fen[13][55] = (char )' ';
#line 19
  fen[13][56] = (char )'w';
#line 19
  fen[13][57] = (char )'\000';
#line 19
  tmp___12 = 58U;
  {
#line 19
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 19
    if (tmp___12 >= 80U) {
#line 19
      goto while_break___12;
    }
#line 19
    fen[13][tmp___12] = (char)0;
#line 19
    tmp___12 ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 19
  fen[14][0] = (char )'8';
#line 19
  fen[14][1] = (char )'/';
#line 19
  fen[14][2] = (char )'3';
#line 19
  fen[14][3] = (char )'k';
#line 19
  fen[14][4] = (char )'4';
#line 19
  fen[14][5] = (char )'/';
#line 19
  fen[14][6] = (char )'8';
#line 19
  fen[14][7] = (char )'/';
#line 19
  fen[14][8] = (char )'8';
#line 19
  fen[14][9] = (char )'/';
#line 19
  fen[14][10] = (char )'8';
#line 19
  fen[14][11] = (char )'/';
#line 19
  fen[14][12] = (char )'4';
#line 19
  fen[14][13] = (char )'B';
#line 19
  fen[14][14] = (char )'3';
#line 19
  fen[14][15] = (char )'/';
#line 19
  fen[14][16] = (char )'4';
#line 19
  fen[14][17] = (char )'K';
#line 19
  fen[14][18] = (char )'B';
#line 19
  fen[14][19] = (char )'2';
#line 19
  fen[14][20] = (char )'/';
#line 19
  fen[14][21] = (char )'2';
#line 19
  fen[14][22] = (char )'B';
#line 19
  fen[14][23] = (char )'5';
#line 19
  fen[14][24] = (char )' ';
#line 19
  fen[14][25] = (char )'w';
#line 19
  fen[14][26] = (char )'\000';
#line 19
  tmp___13 = 27U;
  {
#line 19
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 19
    if (tmp___13 >= 80U) {
#line 19
      goto while_break___13;
    }
#line 19
    fen[14][tmp___13] = (char)0;
#line 19
    tmp___13 ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 19
  fen[15][0] = (char )'6';
#line 19
  fen[15][1] = (char )'k';
#line 19
  fen[15][2] = (char )'1';
#line 19
  fen[15][3] = (char )'/';
#line 19
  fen[15][4] = (char )'6';
#line 19
  fen[15][5] = (char )'p';
#line 19
  fen[15][6] = (char )'1';
#line 19
  fen[15][7] = (char )'/';
#line 19
  fen[15][8] = (char )'P';
#line 19
  fen[15][9] = (char )'6';
#line 19
  fen[15][10] = (char )'p';
#line 19
  fen[15][11] = (char )'/';
#line 19
  fen[15][12] = (char )'r';
#line 19
  fen[15][13] = (char )'1';
#line 19
  fen[15][14] = (char )'N';
#line 19
  fen[15][15] = (char )'5';
#line 19
  fen[15][16] = (char )'/';
#line 19
  fen[15][17] = (char )'5';
#line 19
  fen[15][18] = (char )'p';
#line 19
  fen[15][19] = (char )'2';
#line 19
  fen[15][20] = (char )'/';
#line 19
  fen[15][21] = (char )'7';
#line 19
  fen[15][22] = (char )'P';
#line 19
  fen[15][23] = (char )'/';
#line 19
  fen[15][24] = (char )'1';
#line 19
  fen[15][25] = (char )'b';
#line 19
  fen[15][26] = (char )'3';
#line 19
  fen[15][27] = (char )'P';
#line 19
  fen[15][28] = (char )'P';
#line 19
  fen[15][29] = (char )'1';
#line 19
  fen[15][30] = (char )'/';
#line 19
  fen[15][31] = (char )'4';
#line 19
  fen[15][32] = (char )'R';
#line 19
  fen[15][33] = (char )'1';
#line 19
  fen[15][34] = (char )'K';
#line 19
  fen[15][35] = (char )'1';
#line 19
  fen[15][36] = (char )' ';
#line 19
  fen[15][37] = (char )'w';
#line 19
  fen[15][38] = (char )'\000';
#line 19
  tmp___14 = 39U;
  {
#line 19
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 19
    if (tmp___14 >= 80U) {
#line 19
      goto while_break___14;
    }
#line 19
    fen[15][tmp___14] = (char)0;
#line 19
    tmp___14 ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 19
  fen[16][0] = (char )'8';
#line 19
  fen[16][1] = (char )'/';
#line 19
  fen[16][2] = (char )'2';
#line 19
  fen[16][3] = (char )'p';
#line 19
  fen[16][4] = (char )'5';
#line 19
  fen[16][5] = (char )'/';
#line 19
  fen[16][6] = (char )'3';
#line 19
  fen[16][7] = (char )'p';
#line 19
  fen[16][8] = (char )'4';
#line 19
  fen[16][9] = (char )'/';
#line 19
  fen[16][10] = (char )'K';
#line 19
  fen[16][11] = (char )'P';
#line 19
  fen[16][12] = (char )'5';
#line 19
  fen[16][13] = (char )'r';
#line 19
  fen[16][14] = (char )'/';
#line 19
  fen[16][15] = (char )'1';
#line 19
  fen[16][16] = (char )'R';
#line 19
  fen[16][17] = (char )'3';
#line 19
  fen[16][18] = (char )'p';
#line 19
  fen[16][19] = (char )'1';
#line 19
  fen[16][20] = (char )'k';
#line 19
  fen[16][21] = (char )'/';
#line 19
  fen[16][22] = (char )'8';
#line 19
  fen[16][23] = (char )'/';
#line 19
  fen[16][24] = (char )'4';
#line 19
  fen[16][25] = (char )'P';
#line 19
  fen[16][26] = (char )'1';
#line 19
  fen[16][27] = (char )'P';
#line 19
  fen[16][28] = (char )'1';
#line 19
  fen[16][29] = (char )'/';
#line 19
  fen[16][30] = (char )'8';
#line 19
  fen[16][31] = (char )' ';
#line 19
  fen[16][32] = (char )'w';
#line 19
  fen[16][33] = (char )'\000';
#line 19
  tmp___15 = 34U;
  {
#line 19
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 19
    if (tmp___15 >= 80U) {
#line 19
      goto while_break___15;
    }
#line 19
    fen[16][tmp___15] = (char)0;
#line 19
    tmp___15 ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 19
  fen[17][0] = (char )'r';
#line 19
  fen[17][1] = (char )'2';
#line 19
  fen[17][2] = (char )'q';
#line 19
  fen[17][3] = (char )'1';
#line 19
  fen[17][4] = (char )'r';
#line 19
  fen[17][5] = (char )'k';
#line 19
  fen[17][6] = (char )'1';
#line 19
  fen[17][7] = (char )'/';
#line 19
  fen[17][8] = (char )'1';
#line 19
  fen[17][9] = (char )'p';
#line 19
  fen[17][10] = (char )'p';
#line 19
  fen[17][11] = (char )'n';
#line 19
  fen[17][12] = (char )'b';
#line 19
  fen[17][13] = (char )'p';
#line 19
  fen[17][14] = (char )'p';
#line 19
  fen[17][15] = (char )'p';
#line 19
  fen[17][16] = (char )'/';
#line 19
  fen[17][17] = (char )'p';
#line 19
  fen[17][18] = (char )'2';
#line 19
  fen[17][19] = (char )'p';
#line 19
  fen[17][20] = (char )'1';
#line 19
  fen[17][21] = (char )'n';
#line 19
  fen[17][22] = (char )'b';
#line 19
  fen[17][23] = (char )'1';
#line 19
  fen[17][24] = (char )'/';
#line 19
  fen[17][25] = (char )'3';
#line 19
  fen[17][26] = (char )'P';
#line 19
  fen[17][27] = (char )'p';
#line 19
  fen[17][28] = (char )'3';
#line 19
  fen[17][29] = (char )'/';
#line 19
  fen[17][30] = (char )'2';
#line 19
  fen[17][31] = (char )'P';
#line 19
  fen[17][32] = (char )'1';
#line 19
  fen[17][33] = (char )'P';
#line 19
  fen[17][34] = (char )'1';
#line 19
  fen[17][35] = (char )'P';
#line 19
  fen[17][36] = (char )'1';
#line 19
  fen[17][37] = (char )'/';
#line 19
  fen[17][38] = (char )'2';
#line 19
  fen[17][39] = (char )'N';
#line 19
  fen[17][40] = (char )'2';
#line 19
  fen[17][41] = (char )'N';
#line 19
  fen[17][42] = (char )'1';
#line 19
  fen[17][43] = (char )'P';
#line 19
  fen[17][44] = (char )'/';
#line 19
  fen[17][45] = (char )'P';
#line 19
  fen[17][46] = (char )'P';
#line 19
  fen[17][47] = (char )'B';
#line 19
  fen[17][48] = (char )'1';
#line 19
  fen[17][49] = (char )'Q';
#line 19
  fen[17][50] = (char )'P';
#line 19
  fen[17][51] = (char )'2';
#line 19
  fen[17][52] = (char )'/';
#line 19
  fen[17][53] = (char )'R';
#line 19
  fen[17][54] = (char )'1';
#line 19
  fen[17][55] = (char )'B';
#line 19
  fen[17][56] = (char )'2';
#line 19
  fen[17][57] = (char )'R';
#line 19
  fen[17][58] = (char )'K';
#line 19
  fen[17][59] = (char )'1';
#line 19
  fen[17][60] = (char )' ';
#line 19
  fen[17][61] = (char )'b';
#line 19
  fen[17][62] = (char )'\000';
#line 19
  tmp___16 = 63U;
  {
#line 19
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 19
    if (tmp___16 >= 80U) {
#line 19
      goto while_break___16;
    }
#line 19
    fen[17][tmp___16] = (char)0;
#line 19
    tmp___16 ++;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 19
  fen[18][0] = (char )'2';
#line 19
  fen[18][1] = (char )'k';
#line 19
  fen[18][2] = (char )'r';
#line 19
  fen[18][3] = (char )'1';
#line 19
  fen[18][4] = (char )'b';
#line 19
  fen[18][5] = (char )'n';
#line 19
  fen[18][6] = (char )'r';
#line 19
  fen[18][7] = (char )'/';
#line 19
  fen[18][8] = (char )'p';
#line 19
  fen[18][9] = (char )'b';
#line 19
  fen[18][10] = (char )'p';
#line 19
  fen[18][11] = (char )'q';
#line 19
  fen[18][12] = (char )'4';
#line 19
  fen[18][13] = (char )'/';
#line 19
  fen[18][14] = (char )'2';
#line 19
  fen[18][15] = (char )'n';
#line 19
  fen[18][16] = (char )'1';
#line 19
  fen[18][17] = (char )'p';
#line 19
  fen[18][18] = (char )'p';
#line 19
  fen[18][19] = (char )'2';
#line 19
  fen[18][20] = (char )'/';
#line 19
  fen[18][21] = (char )'3';
#line 19
  fen[18][22] = (char )'p';
#line 19
  fen[18][23] = (char )'3';
#line 19
  fen[18][24] = (char )'p';
#line 19
  fen[18][25] = (char )'/';
#line 19
  fen[18][26] = (char )'3';
#line 19
  fen[18][27] = (char )'P';
#line 19
  fen[18][28] = (char )'1';
#line 19
  fen[18][29] = (char )'P';
#line 19
  fen[18][30] = (char )'1';
#line 19
  fen[18][31] = (char )'B';
#line 19
  fen[18][32] = (char )'/';
#line 19
  fen[18][33] = (char )'2';
#line 19
  fen[18][34] = (char )'N';
#line 19
  fen[18][35] = (char )'2';
#line 19
  fen[18][36] = (char )'N';
#line 19
  fen[18][37] = (char )'1';
#line 19
  fen[18][38] = (char )'Q';
#line 19
  fen[18][39] = (char )'/';
#line 19
  fen[18][40] = (char )'P';
#line 19
  fen[18][41] = (char )'P';
#line 19
  fen[18][42] = (char )'P';
#line 19
  fen[18][43] = (char )'3';
#line 19
  fen[18][44] = (char )'P';
#line 19
  fen[18][45] = (char )'P';
#line 19
  fen[18][46] = (char )'/';
#line 19
  fen[18][47] = (char )'2';
#line 19
  fen[18][48] = (char )'K';
#line 19
  fen[18][49] = (char )'R';
#line 19
  fen[18][50] = (char )'1';
#line 19
  fen[18][51] = (char )'B';
#line 19
  fen[18][52] = (char )'1';
#line 19
  fen[18][53] = (char )'R';
#line 19
  fen[18][54] = (char )' ';
#line 19
  fen[18][55] = (char )'w';
#line 19
  fen[18][56] = (char )'\000';
#line 19
  tmp___17 = 57U;
  {
#line 19
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 19
    if (tmp___17 >= 80U) {
#line 19
      goto while_break___17;
    }
#line 19
    fen[18][tmp___17] = (char)0;
#line 19
    tmp___17 ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 19
  fen[19][0] = (char )'8';
#line 19
  fen[19][1] = (char )'/';
#line 19
  fen[19][2] = (char )'2';
#line 19
  fen[19][3] = (char )'p';
#line 19
  fen[19][4] = (char )'5';
#line 19
  fen[19][5] = (char )'/';
#line 19
  fen[19][6] = (char )'8';
#line 19
  fen[19][7] = (char )'/';
#line 19
  fen[19][8] = (char )'2';
#line 19
  fen[19][9] = (char )'k';
#line 19
  fen[19][10] = (char )'P';
#line 19
  fen[19][11] = (char )'K';
#line 19
  fen[19][12] = (char )'p';
#line 19
  fen[19][13] = (char )'1';
#line 19
  fen[19][14] = (char )'p';
#line 19
  fen[19][15] = (char )'/';
#line 19
  fen[19][16] = (char )'2';
#line 19
  fen[19][17] = (char )'p';
#line 19
  fen[19][18] = (char )'4';
#line 19
  fen[19][19] = (char )'P';
#line 19
  fen[19][20] = (char )'/';
#line 19
  fen[19][21] = (char )'2';
#line 19
  fen[19][22] = (char )'P';
#line 19
  fen[19][23] = (char )'5';
#line 19
  fen[19][24] = (char )'/';
#line 19
  fen[19][25] = (char )'3';
#line 19
  fen[19][26] = (char )'P';
#line 19
  fen[19][27] = (char )'4';
#line 19
  fen[19][28] = (char )'/';
#line 19
  fen[19][29] = (char )'8';
#line 19
  fen[19][30] = (char )' ';
#line 19
  fen[19][31] = (char )'w';
#line 19
  fen[19][32] = (char )'\000';
#line 19
  tmp___18 = 33U;
  {
#line 19
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 19
    if (tmp___18 >= 80U) {
#line 19
      goto while_break___18;
    }
#line 19
    fen[19][tmp___18] = (char)0;
#line 19
    tmp___18 ++;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 19
  fen[20][0] = (char )'3';
#line 19
  fen[20][1] = (char )'r';
#line 19
  fen[20][2] = (char )'n';
#line 19
  fen[20][3] = (char )'2';
#line 19
  fen[20][4] = (char )'k';
#line 19
  fen[20][5] = (char )'/';
#line 19
  fen[20][6] = (char )'p';
#line 19
  fen[20][7] = (char )'p';
#line 19
  fen[20][8] = (char )'b';
#line 19
  fen[20][9] = (char )'2';
#line 19
  fen[20][10] = (char )'r';
#line 19
  fen[20][11] = (char )'p';
#line 19
  fen[20][12] = (char )'p';
#line 19
  fen[20][13] = (char )'/';
#line 19
  fen[20][14] = (char )'2';
#line 19
  fen[20][15] = (char )'p';
#line 19
  fen[20][16] = (char )'p';
#line 19
  fen[20][17] = (char )'q';
#line 19
  fen[20][18] = (char )'p';
#line 19
  fen[20][19] = (char )'2';
#line 19
  fen[20][20] = (char )'/';
#line 19
  fen[20][21] = (char )'5';
#line 19
  fen[20][22] = (char )'N';
#line 19
  fen[20][23] = (char )'2';
#line 19
  fen[20][24] = (char )'/';
#line 19
  fen[20][25] = (char )'2';
#line 19
  fen[20][26] = (char )'P';
#line 19
  fen[20][27] = (char )'1';
#line 19
  fen[20][28] = (char )'P';
#line 19
  fen[20][29] = (char )'3';
#line 19
  fen[20][30] = (char )'/';
#line 19
  fen[20][31] = (char )'1';
#line 19
  fen[20][32] = (char )'P';
#line 19
  fen[20][33] = (char )'5';
#line 19
  fen[20][34] = (char )'Q';
#line 19
  fen[20][35] = (char )'/';
#line 19
  fen[20][36] = (char )'P';
#line 19
  fen[20][37] = (char )'B';
#line 19
  fen[20][38] = (char )'3';
#line 19
  fen[20][39] = (char )'P';
#line 19
  fen[20][40] = (char )'P';
#line 19
  fen[20][41] = (char )'P';
#line 19
  fen[20][42] = (char )'/';
#line 19
  fen[20][43] = (char )'3';
#line 19
  fen[20][44] = (char )'R';
#line 19
  fen[20][45] = (char )'R';
#line 19
  fen[20][46] = (char )'1';
#line 19
  fen[20][47] = (char )'K';
#line 19
  fen[20][48] = (char )'1';
#line 19
  fen[20][49] = (char )' ';
#line 19
  fen[20][50] = (char )'w';
#line 19
  fen[20][51] = (char )'\000';
#line 19
  tmp___19 = 52U;
  {
#line 19
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 19
    if (tmp___19 >= 80U) {
#line 19
      goto while_break___19;
    }
#line 19
    fen[20][tmp___19] = (char)0;
#line 19
    tmp___19 ++;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 19
  fen[21][0] = (char )'r';
#line 19
  fen[21][1] = (char )'n';
#line 19
  fen[21][2] = (char )'b';
#line 19
  fen[21][3] = (char )'q';
#line 19
  fen[21][4] = (char )'k';
#line 19
  fen[21][5] = (char )'b';
#line 19
  fen[21][6] = (char )'1';
#line 19
  fen[21][7] = (char )'r';
#line 19
  fen[21][8] = (char )'/';
#line 19
  fen[21][9] = (char )'p';
#line 19
  fen[21][10] = (char )'3';
#line 19
  fen[21][11] = (char )'p';
#line 19
  fen[21][12] = (char )'p';
#line 19
  fen[21][13] = (char )'p';
#line 19
  fen[21][14] = (char )'p';
#line 19
  fen[21][15] = (char )'/';
#line 19
  fen[21][16] = (char )'1';
#line 19
  fen[21][17] = (char )'p';
#line 19
  fen[21][18] = (char )'6';
#line 19
  fen[21][19] = (char )'/';
#line 19
  fen[21][20] = (char )'2';
#line 19
  fen[21][21] = (char )'p';
#line 19
  fen[21][22] = (char )'p';
#line 19
  fen[21][23] = (char )'P';
#line 19
  fen[21][24] = (char )'3';
#line 19
  fen[21][25] = (char )'/';
#line 19
  fen[21][26] = (char )'3';
#line 19
  fen[21][27] = (char )'N';
#line 19
  fen[21][28] = (char )'4';
#line 19
  fen[21][29] = (char )'/';
#line 19
  fen[21][30] = (char )'2';
#line 19
  fen[21][31] = (char )'P';
#line 19
  fen[21][32] = (char )'5';
#line 19
  fen[21][33] = (char )'/';
#line 19
  fen[21][34] = (char )'P';
#line 19
  fen[21][35] = (char )'P';
#line 19
  fen[21][36] = (char )'P';
#line 19
  fen[21][37] = (char )'1';
#line 19
  fen[21][38] = (char )'Q';
#line 19
  fen[21][39] = (char )'P';
#line 19
  fen[21][40] = (char )'P';
#line 19
  fen[21][41] = (char )'P';
#line 19
  fen[21][42] = (char )'/';
#line 19
  fen[21][43] = (char )'R';
#line 19
  fen[21][44] = (char )'1';
#line 19
  fen[21][45] = (char )'B';
#line 19
  fen[21][46] = (char )'1';
#line 19
  fen[21][47] = (char )'K';
#line 19
  fen[21][48] = (char )'B';
#line 19
  fen[21][49] = (char )'1';
#line 19
  fen[21][50] = (char )'R';
#line 19
  fen[21][51] = (char )' ';
#line 19
  fen[21][52] = (char )'w';
#line 19
  fen[21][53] = (char )'\000';
#line 19
  tmp___20 = 54U;
  {
#line 19
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 19
    if (tmp___20 >= 80U) {
#line 19
      goto while_break___20;
    }
#line 19
    fen[21][tmp___20] = (char)0;
#line 19
    tmp___20 ++;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 19
  fen[22][0] = (char )'2';
#line 19
  fen[22][1] = (char )'r';
#line 19
  fen[22][2] = (char )'3';
#line 19
  fen[22][3] = (char )'k';
#line 19
  fen[22][4] = (char )'1';
#line 19
  fen[22][5] = (char )'/';
#line 19
  fen[22][6] = (char )'p';
#line 19
  fen[22][7] = (char )'p';
#line 19
  fen[22][8] = (char )'p';
#line 19
  fen[22][9] = (char )'R';
#line 19
  fen[22][10] = (char )'1';
#line 19
  fen[22][11] = (char )'p';
#line 19
  fen[22][12] = (char )'p';
#line 19
  fen[22][13] = (char )'1';
#line 19
  fen[22][14] = (char )'/';
#line 19
  fen[22][15] = (char )'4';
#line 19
  fen[22][16] = (char )'p';
#line 19
  fen[22][17] = (char )'3';
#line 19
  fen[22][18] = (char )'/';
#line 19
  fen[22][19] = (char )'4';
#line 19
  fen[22][20] = (char )'P';
#line 19
  fen[22][21] = (char )'1';
#line 19
  fen[22][22] = (char )'P';
#line 19
  fen[22][23] = (char )'1';
#line 19
  fen[22][24] = (char )'/';
#line 19
  fen[22][25] = (char )'5';
#line 19
  fen[22][26] = (char )'P';
#line 19
  fen[22][27] = (char )'2';
#line 19
  fen[22][28] = (char )'/';
#line 19
  fen[22][29] = (char )'1';
#line 19
  fen[22][30] = (char )'P';
#line 19
  fen[22][31] = (char )'4';
#line 19
  fen[22][32] = (char )'K';
#line 19
  fen[22][33] = (char )'1';
#line 19
  fen[22][34] = (char )'/';
#line 19
  fen[22][35] = (char )'P';
#line 19
  fen[22][36] = (char )'1';
#line 19
  fen[22][37] = (char )'P';
#line 19
  fen[22][38] = (char )'5';
#line 19
  fen[22][39] = (char )'/';
#line 19
  fen[22][40] = (char )'8';
#line 19
  fen[22][41] = (char )' ';
#line 19
  fen[22][42] = (char )'w';
#line 19
  fen[22][43] = (char )'\000';
#line 19
  tmp___21 = 44U;
  {
#line 19
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 19
    if (tmp___21 >= 80U) {
#line 19
      goto while_break___21;
    }
#line 19
    fen[22][tmp___21] = (char)0;
#line 19
    tmp___21 ++;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 19
  fen[23][0] = (char )'/';
#line 19
  fen[23][1] = (char )'k';
#line 19
  fen[23][2] = (char )'/';
#line 19
  fen[23][3] = (char )'r';
#line 19
  fen[23][4] = (char )'n';
#line 19
  fen[23][5] = (char )'n';
#line 19
  fen[23][6] = (char )'/';
#line 19
  fen[23][7] = (char )'/';
#line 19
  fen[23][8] = (char )'/';
#line 19
  fen[23][9] = (char )'/';
#line 19
  fen[23][10] = (char )'5';
#line 19
  fen[23][11] = (char )'R';
#line 19
  fen[23][12] = (char )'B';
#line 19
  fen[23][13] = (char )'B';
#line 19
  fen[23][14] = (char )'/';
#line 19
  fen[23][15] = (char )'K';
#line 19
  fen[23][16] = (char )'/';
#line 19
  fen[23][17] = (char )' ';
#line 19
  fen[23][18] = (char )'w';
#line 19
  fen[23][19] = (char )'\000';
#line 19
  tmp___22 = 20U;
  {
#line 19
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 19
    if (tmp___22 >= 80U) {
#line 19
      goto while_break___22;
    }
#line 19
    fen[23][tmp___22] = (char)0;
#line 19
    tmp___22 ++;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 19
  fen[24][0] = (char )'r';
#line 19
  fen[24][1] = (char )'1';
#line 19
  fen[24][2] = (char )'b';
#line 19
  fen[24][3] = (char )'q';
#line 19
  fen[24][4] = (char )'1';
#line 19
  fen[24][5] = (char )'r';
#line 19
  fen[24][6] = (char )'k';
#line 19
  fen[24][7] = (char )'1';
#line 19
  fen[24][8] = (char )'/';
#line 19
  fen[24][9] = (char )'p';
#line 19
  fen[24][10] = (char )'p';
#line 19
  fen[24][11] = (char )'p';
#line 19
  fen[24][12] = (char )'1';
#line 19
  fen[24][13] = (char )'n';
#line 19
  fen[24][14] = (char )'p';
#line 19
  fen[24][15] = (char )'p';
#line 19
  fen[24][16] = (char )'p';
#line 19
  fen[24][17] = (char )'/';
#line 19
  fen[24][18] = (char )'4';
#line 19
  fen[24][19] = (char )'n';
#line 19
  fen[24][20] = (char )'3';
#line 19
  fen[24][21] = (char )'/';
#line 19
  fen[24][22] = (char )'3';
#line 19
  fen[24][23] = (char )'p';
#line 19
  fen[24][24] = (char )'3';
#line 19
  fen[24][25] = (char )'Q';
#line 19
  fen[24][26] = (char )'/';
#line 19
  fen[24][27] = (char )'3';
#line 19
  fen[24][28] = (char )'P';
#line 19
  fen[24][29] = (char )'4';
#line 19
  fen[24][30] = (char )'/';
#line 19
  fen[24][31] = (char )'1';
#line 19
  fen[24][32] = (char )'B';
#line 19
  fen[24][33] = (char )'P';
#line 19
  fen[24][34] = (char )'1';
#line 19
  fen[24][35] = (char )'B';
#line 19
  fen[24][36] = (char )'3';
#line 19
  fen[24][37] = (char )'/';
#line 19
  fen[24][38] = (char )'P';
#line 19
  fen[24][39] = (char )'P';
#line 19
  fen[24][40] = (char )'1';
#line 19
  fen[24][41] = (char )'N';
#line 19
  fen[24][42] = (char )'2';
#line 19
  fen[24][43] = (char )'P';
#line 19
  fen[24][44] = (char )'P';
#line 19
  fen[24][45] = (char )'/';
#line 19
  fen[24][46] = (char )'R';
#line 19
  fen[24][47] = (char )'4';
#line 19
  fen[24][48] = (char )'R';
#line 19
  fen[24][49] = (char )'K';
#line 19
  fen[24][50] = (char )'1';
#line 19
  fen[24][51] = (char )' ';
#line 19
  fen[24][52] = (char )'w';
#line 19
  fen[24][53] = (char )'\000';
#line 19
  tmp___23 = 54U;
  {
#line 19
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 19
    if (tmp___23 >= 80U) {
#line 19
      goto while_break___23;
    }
#line 19
    fen[24][tmp___23] = (char)0;
#line 19
    tmp___23 ++;
  }
  while_break___23: /* CIL Label */ ;
  }
#line 19
  fen[25][0] = (char )'8';
#line 19
  fen[25][1] = (char )'/';
#line 19
  fen[25][2] = (char )'8';
#line 19
  fen[25][3] = (char )'/';
#line 19
  fen[25][4] = (char )'3';
#line 19
  fen[25][5] = (char )'P';
#line 19
  fen[25][6] = (char )'3';
#line 19
  fen[25][7] = (char )'k';
#line 19
  fen[25][8] = (char )'/';
#line 19
  fen[25][9] = (char )'8';
#line 19
  fen[25][10] = (char )'/';
#line 19
  fen[25][11] = (char )'1';
#line 19
  fen[25][12] = (char )'p';
#line 19
  fen[25][13] = (char )'6';
#line 19
  fen[25][14] = (char )'/';
#line 19
  fen[25][15] = (char )'8';
#line 19
  fen[25][16] = (char )'/';
#line 19
  fen[25][17] = (char )'1';
#line 19
  fen[25][18] = (char )'P';
#line 19
  fen[25][19] = (char )'6';
#line 19
  fen[25][20] = (char )'/';
#line 19
  fen[25][21] = (char )'1';
#line 19
  fen[25][22] = (char )'K';
#line 19
  fen[25][23] = (char )'3';
#line 19
  fen[25][24] = (char )'n';
#line 19
  fen[25][25] = (char )'2';
#line 19
  fen[25][26] = (char )' ';
#line 19
  fen[25][27] = (char )'b';
#line 19
  fen[25][28] = (char )'\000';
#line 19
  tmp___24 = 29U;
  {
#line 19
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 19
    if (tmp___24 >= 80U) {
#line 19
      goto while_break___24;
    }
#line 19
    fen[25][tmp___24] = (char)0;
#line 19
    tmp___24 ++;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 19
  fen[26][0] = (char )'8';
#line 19
  fen[26][1] = (char )'/';
#line 19
  fen[26][2] = (char )'2';
#line 19
  fen[26][3] = (char )'p';
#line 19
  fen[26][4] = (char )'4';
#line 19
  fen[26][5] = (char )'P';
#line 19
  fen[26][6] = (char )'/';
#line 19
  fen[26][7] = (char )'8';
#line 19
  fen[26][8] = (char )'/';
#line 19
  fen[26][9] = (char )'k';
#line 19
  fen[26][10] = (char )'r';
#line 19
  fen[26][11] = (char )'6';
#line 19
  fen[26][12] = (char )'/';
#line 19
  fen[26][13] = (char )'6';
#line 19
  fen[26][14] = (char )'R';
#line 19
  fen[26][15] = (char )'1';
#line 19
  fen[26][16] = (char )'/';
#line 19
  fen[26][17] = (char )'8';
#line 19
  fen[26][18] = (char )'/';
#line 19
  fen[26][19] = (char )'8';
#line 19
  fen[26][20] = (char )'/';
#line 19
  fen[26][21] = (char )'1';
#line 19
  fen[26][22] = (char )'K';
#line 19
  fen[26][23] = (char )'6';
#line 19
  fen[26][24] = (char )' ';
#line 19
  fen[26][25] = (char )'w';
#line 19
  fen[26][26] = (char )'\000';
#line 19
  tmp___25 = 27U;
  {
#line 19
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 19
    if (tmp___25 >= 80U) {
#line 19
      goto while_break___25;
    }
#line 19
    fen[26][tmp___25] = (char)0;
#line 19
    tmp___25 ++;
  }
  while_break___25: /* CIL Label */ ;
  }
#line 19
  fen[27][0] = (char )'r';
#line 19
  fen[27][1] = (char )'2';
#line 19
  fen[27][2] = (char )'q';
#line 19
  fen[27][3] = (char )'n';
#line 19
  fen[27][4] = (char )'r';
#line 19
  fen[27][5] = (char )'n';
#line 19
  fen[27][6] = (char )'k';
#line 19
  fen[27][7] = (char )'/';
#line 19
  fen[27][8] = (char )'p';
#line 19
  fen[27][9] = (char )'2';
#line 19
  fen[27][10] = (char )'b';
#line 19
  fen[27][11] = (char )'2';
#line 19
  fen[27][12] = (char )'b';
#line 19
  fen[27][13] = (char )'1';
#line 19
  fen[27][14] = (char )'/';
#line 19
  fen[27][15] = (char )'1';
#line 19
  fen[27][16] = (char )'p';
#line 19
  fen[27][17] = (char )'1';
#line 19
  fen[27][18] = (char )'p';
#line 19
  fen[27][19] = (char )'2';
#line 19
  fen[27][20] = (char )'p';
#line 19
  fen[27][21] = (char )'p';
#line 19
  fen[27][22] = (char )'/';
#line 19
  fen[27][23] = (char )'2';
#line 19
  fen[27][24] = (char )'p';
#line 19
  fen[27][25] = (char )'P';
#line 19
  fen[27][26] = (char )'p';
#line 19
  fen[27][27] = (char )'p';
#line 19
  fen[27][28] = (char )'2';
#line 19
  fen[27][29] = (char )'/';
#line 19
  fen[27][30] = (char )'1';
#line 19
  fen[27][31] = (char )'P';
#line 19
  fen[27][32] = (char )'P';
#line 19
  fen[27][33] = (char )'1';
#line 19
  fen[27][34] = (char )'P';
#line 19
  fen[27][35] = (char )'3';
#line 19
  fen[27][36] = (char )'/';
#line 19
  fen[27][37] = (char )'P';
#line 19
  fen[27][38] = (char )'R';
#line 19
  fen[27][39] = (char )'N';
#line 19
  fen[27][40] = (char )'B';
#line 19
  fen[27][41] = (char )'B';
#line 19
  fen[27][42] = (char )'3';
#line 19
  fen[27][43] = (char )'/';
#line 19
  fen[27][44] = (char )'3';
#line 19
  fen[27][45] = (char )'Q';
#line 19
  fen[27][46] = (char )'N';
#line 19
  fen[27][47] = (char )'P';
#line 19
  fen[27][48] = (char )'P';
#line 19
  fen[27][49] = (char )'P';
#line 19
  fen[27][50] = (char )'/';
#line 19
  fen[27][51] = (char )'5';
#line 19
  fen[27][52] = (char )'R';
#line 19
  fen[27][53] = (char )'K';
#line 19
  fen[27][54] = (char )'1';
#line 19
  fen[27][55] = (char )' ';
#line 19
  fen[27][56] = (char )'w';
#line 19
  fen[27][57] = (char )'\000';
#line 19
  tmp___26 = 58U;
  {
#line 19
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 19
    if (tmp___26 >= 80U) {
#line 19
      goto while_break___26;
    }
#line 19
    fen[27][tmp___26] = (char)0;
#line 19
    tmp___26 ++;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 19
  fen[28][0] = (char )'5';
#line 19
  fen[28][1] = (char )'k';
#line 19
  fen[28][2] = (char )'2';
#line 19
  fen[28][3] = (char )'/';
#line 19
  fen[28][4] = (char )'7';
#line 19
  fen[28][5] = (char )'R';
#line 19
  fen[28][6] = (char )'/';
#line 19
  fen[28][7] = (char )'4';
#line 19
  fen[28][8] = (char )'P';
#line 19
  fen[28][9] = (char )'2';
#line 19
  fen[28][10] = (char )'p';
#line 19
  fen[28][11] = (char )'/';
#line 19
  fen[28][12] = (char )'5';
#line 19
  fen[28][13] = (char )'K';
#line 19
  fen[28][14] = (char )'2';
#line 19
  fen[28][15] = (char )'/';
#line 19
  fen[28][16] = (char )'p';
#line 19
  fen[28][17] = (char )'1';
#line 19
  fen[28][18] = (char )'r';
#line 19
  fen[28][19] = (char )'2';
#line 19
  fen[28][20] = (char )'P';
#line 19
  fen[28][21] = (char )'1';
#line 19
  fen[28][22] = (char )'p';
#line 19
  fen[28][23] = (char )'/';
#line 19
  fen[28][24] = (char )'8';
#line 19
  fen[28][25] = (char )'/';
#line 19
  fen[28][26] = (char )'8';
#line 19
  fen[28][27] = (char )'/';
#line 19
  fen[28][28] = (char )'8';
#line 19
  fen[28][29] = (char )' ';
#line 19
  fen[28][30] = (char )'b';
#line 19
  fen[28][31] = (char )'\000';
#line 19
  tmp___27 = 32U;
  {
#line 19
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 19
    if (tmp___27 >= 80U) {
#line 19
      goto while_break___27;
    }
#line 19
    fen[28][tmp___27] = (char)0;
#line 19
    tmp___27 ++;
  }
  while_break___27: /* CIL Label */ ;
  }
#line 19
  fen[29][0] = (char )'r';
#line 19
  fen[29][1] = (char )'q';
#line 19
  fen[29][2] = (char )'3';
#line 19
  fen[29][3] = (char )'r';
#line 19
  fen[29][4] = (char )'k';
#line 19
  fen[29][5] = (char )'1';
#line 19
  fen[29][6] = (char )'/';
#line 19
  fen[29][7] = (char )'p';
#line 19
  fen[29][8] = (char )'p';
#line 19
  fen[29][9] = (char )'p';
#line 19
  fen[29][10] = (char )'2';
#line 19
  fen[29][11] = (char )'p';
#line 19
  fen[29][12] = (char )'p';
#line 19
  fen[29][13] = (char )'p';
#line 19
  fen[29][14] = (char )'/';
#line 19
  fen[29][15] = (char )'1';
#line 19
  fen[29][16] = (char )'b';
#line 19
  fen[29][17] = (char )'n';
#line 19
  fen[29][18] = (char )'p';
#line 19
  fen[29][19] = (char )'b';
#line 19
  fen[29][20] = (char )'3';
#line 19
  fen[29][21] = (char )'/';
#line 19
  fen[29][22] = (char )'3';
#line 19
  fen[29][23] = (char )'N';
#line 19
  fen[29][24] = (char )'2';
#line 19
  fen[29][25] = (char )'B';
#line 19
  fen[29][26] = (char )'1';
#line 19
  fen[29][27] = (char )'/';
#line 19
  fen[29][28] = (char )'3';
#line 19
  fen[29][29] = (char )'N';
#line 19
  fen[29][30] = (char )'P';
#line 19
  fen[29][31] = (char )'3';
#line 19
  fen[29][32] = (char )'/';
#line 19
  fen[29][33] = (char )'7';
#line 19
  fen[29][34] = (char )'P';
#line 19
  fen[29][35] = (char )'/';
#line 19
  fen[29][36] = (char )'P';
#line 19
  fen[29][37] = (char )'P';
#line 19
  fen[29][38] = (char )'P';
#line 19
  fen[29][39] = (char )'Q';
#line 19
  fen[29][40] = (char )'1';
#line 19
  fen[29][41] = (char )'P';
#line 19
  fen[29][42] = (char )'P';
#line 19
  fen[29][43] = (char )'1';
#line 19
  fen[29][44] = (char )'/';
#line 19
  fen[29][45] = (char )'2';
#line 19
  fen[29][46] = (char )'K';
#line 19
  fen[29][47] = (char )'R';
#line 19
  fen[29][48] = (char )'3';
#line 19
  fen[29][49] = (char )'R';
#line 19
  fen[29][50] = (char )' ';
#line 19
  fen[29][51] = (char )'w';
#line 19
  fen[29][52] = (char )'\000';
#line 19
  tmp___28 = 53U;
  {
#line 19
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 19
    if (tmp___28 >= 80U) {
#line 19
      goto while_break___28;
    }
#line 19
    fen[29][tmp___28] = (char)0;
#line 19
    tmp___28 ++;
  }
  while_break___28: /* CIL Label */ ;
  }
#line 19
  fen[30][0] = (char )'2';
#line 19
  fen[30][1] = (char )'q';
#line 19
  fen[30][2] = (char )'1';
#line 19
  fen[30][3] = (char )'r';
#line 19
  fen[30][4] = (char )'r';
#line 19
  fen[30][5] = (char )'1';
#line 19
  fen[30][6] = (char )'k';
#line 19
  fen[30][7] = (char )'/';
#line 19
  fen[30][8] = (char )'3';
#line 19
  fen[30][9] = (char )'b';
#line 19
  fen[30][10] = (char )'b';
#line 19
  fen[30][11] = (char )'n';
#line 19
  fen[30][12] = (char )'n';
#line 19
  fen[30][13] = (char )'p';
#line 19
  fen[30][14] = (char )'/';
#line 19
  fen[30][15] = (char )'p';
#line 19
  fen[30][16] = (char )'2';
#line 19
  fen[30][17] = (char )'p';
#line 19
  fen[30][18] = (char )'1';
#line 19
  fen[30][19] = (char )'p';
#line 19
  fen[30][20] = (char )'p';
#line 19
  fen[30][21] = (char )'1';
#line 19
  fen[30][22] = (char )'/';
#line 19
  fen[30][23] = (char )'2';
#line 19
  fen[30][24] = (char )'p';
#line 19
  fen[30][25] = (char )'P';
#line 19
  fen[30][26] = (char )'p';
#line 19
  fen[30][27] = (char )'3';
#line 19
  fen[30][28] = (char )'/';
#line 19
  fen[30][29] = (char )'P';
#line 19
  fen[30][30] = (char )'p';
#line 19
  fen[30][31] = (char )'P';
#line 19
  fen[30][32] = (char )'1';
#line 19
  fen[30][33] = (char )'P';
#line 19
  fen[30][34] = (char )'1';
#line 19
  fen[30][35] = (char )'P';
#line 19
  fen[30][36] = (char )'1';
#line 19
  fen[30][37] = (char )'/';
#line 19
  fen[30][38] = (char )'1';
#line 19
  fen[30][39] = (char )'P';
#line 19
  fen[30][40] = (char )'2';
#line 19
  fen[30][41] = (char )'B';
#line 19
  fen[30][42] = (char )'N';
#line 19
  fen[30][43] = (char )'N';
#line 19
  fen[30][44] = (char )'P';
#line 19
  fen[30][45] = (char )'/';
#line 19
  fen[30][46] = (char )'2';
#line 19
  fen[30][47] = (char )'B';
#line 19
  fen[30][48] = (char )'Q';
#line 19
  fen[30][49] = (char )'1';
#line 19
  fen[30][50] = (char )'P';
#line 19
  fen[30][51] = (char )'R';
#line 19
  fen[30][52] = (char )'K';
#line 19
  fen[30][53] = (char )'/';
#line 19
  fen[30][54] = (char )'7';
#line 19
  fen[30][55] = (char )'R';
#line 19
  fen[30][56] = (char )' ';
#line 19
  fen[30][57] = (char )'b';
#line 19
  fen[30][58] = (char )'\000';
#line 19
  tmp___29 = 59U;
  {
#line 19
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 19
    if (tmp___29 >= 80U) {
#line 19
      goto while_break___29;
    }
#line 19
    fen[30][tmp___29] = (char)0;
#line 19
    tmp___29 ++;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 19
  fen[31][0] = (char )'2';
#line 19
  fen[31][1] = (char )'r';
#line 19
  fen[31][2] = (char )'q';
#line 19
  fen[31][3] = (char )'k';
#line 19
  fen[31][4] = (char )'b';
#line 19
  fen[31][5] = (char )'1';
#line 19
  fen[31][6] = (char )'r';
#line 19
  fen[31][7] = (char )'/';
#line 19
  fen[31][8] = (char )'p';
#line 19
  fen[31][9] = (char )'p';
#line 19
  fen[31][10] = (char )'p';
#line 19
  fen[31][11] = (char )'2';
#line 19
  fen[31][12] = (char )'p';
#line 19
  fen[31][13] = (char )'2';
#line 19
  fen[31][14] = (char )'/';
#line 19
  fen[31][15] = (char )'2';
#line 19
  fen[31][16] = (char )'n';
#line 19
  fen[31][17] = (char )'p';
#line 19
  fen[31][18] = (char )'b';
#line 19
  fen[31][19] = (char )'1';
#line 19
  fen[31][20] = (char )'p';
#line 19
  fen[31][21] = (char )'1';
#line 19
  fen[31][22] = (char )'/';
#line 19
  fen[31][23] = (char )'1';
#line 19
  fen[31][24] = (char )'N';
#line 19
  fen[31][25] = (char )'1';
#line 19
  fen[31][26] = (char )'N';
#line 19
  fen[31][27] = (char )'n';
#line 19
  fen[31][28] = (char )'2';
#line 19
  fen[31][29] = (char )'p';
#line 19
  fen[31][30] = (char )'/';
#line 19
  fen[31][31] = (char )'2';
#line 19
  fen[31][32] = (char )'P';
#line 19
  fen[31][33] = (char )'1';
#line 19
  fen[31][34] = (char )'P';
#line 19
  fen[31][35] = (char )'P';
#line 19
  fen[31][36] = (char )'2';
#line 19
  fen[31][37] = (char )'/';
#line 19
  fen[31][38] = (char )'8';
#line 19
  fen[31][39] = (char )'/';
#line 19
  fen[31][40] = (char )'P';
#line 19
  fen[31][41] = (char )'P';
#line 19
  fen[31][42] = (char )'2';
#line 19
  fen[31][43] = (char )'B';
#line 19
  fen[31][44] = (char )'1';
#line 19
  fen[31][45] = (char )'P';
#line 19
  fen[31][46] = (char )'P';
#line 19
  fen[31][47] = (char )'/';
#line 19
  fen[31][48] = (char )'R';
#line 19
  fen[31][49] = (char )'1';
#line 19
  fen[31][50] = (char )'B';
#line 19
  fen[31][51] = (char )'Q';
#line 19
  fen[31][52] = (char )'K';
#line 19
  fen[31][53] = (char )'2';
#line 19
  fen[31][54] = (char )'R';
#line 19
  fen[31][55] = (char )' ';
#line 19
  fen[31][56] = (char )'b';
#line 19
  fen[31][57] = (char )'\000';
#line 19
  tmp___30 = 58U;
  {
#line 19
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 19
    if (tmp___30 >= 80U) {
#line 19
      goto while_break___30;
    }
#line 19
    fen[31][tmp___30] = (char)0;
#line 19
    tmp___30 ++;
  }
  while_break___30: /* CIL Label */ ;
  }
#line 19
  fen[32][0] = (char )'r';
#line 19
  fen[32][1] = (char )'2';
#line 19
  fen[32][2] = (char )'q';
#line 19
  fen[32][3] = (char )'1';
#line 19
  fen[32][4] = (char )'r';
#line 19
  fen[32][5] = (char )'k';
#line 19
  fen[32][6] = (char )'1';
#line 19
  fen[32][7] = (char )'/';
#line 19
  fen[32][8] = (char )'4';
#line 19
  fen[32][9] = (char )'b';
#line 19
  fen[32][10] = (char )'p';
#line 19
  fen[32][11] = (char )'p';
#line 19
  fen[32][12] = (char )'p';
#line 19
  fen[32][13] = (char )'/';
#line 19
  fen[32][14] = (char )'p';
#line 19
  fen[32][15] = (char )'2';
#line 19
  fen[32][16] = (char )'p';
#line 19
  fen[32][17] = (char )'4';
#line 19
  fen[32][18] = (char )'/';
#line 19
  fen[32][19] = (char )'2';
#line 19
  fen[32][20] = (char )'p';
#line 19
  fen[32][21] = (char )'P';
#line 19
  fen[32][22] = (char )'4';
#line 19
  fen[32][23] = (char )'/';
#line 19
  fen[32][24] = (char )'3';
#line 19
  fen[32][25] = (char )'p';
#line 19
  fen[32][26] = (char )'P';
#line 19
  fen[32][27] = (char )'3';
#line 19
  fen[32][28] = (char )'/';
#line 19
  fen[32][29] = (char )'3';
#line 19
  fen[32][30] = (char )'Q';
#line 19
  fen[32][31] = (char )'4';
#line 19
  fen[32][32] = (char )'/';
#line 19
  fen[32][33] = (char )'P';
#line 19
  fen[32][34] = (char )'P';
#line 19
  fen[32][35] = (char )'1';
#line 19
  fen[32][36] = (char )'B';
#line 19
  fen[32][37] = (char )'1';
#line 19
  fen[32][38] = (char )'P';
#line 19
  fen[32][39] = (char )'P';
#line 19
  fen[32][40] = (char )'P';
#line 19
  fen[32][41] = (char )'/';
#line 19
  fen[32][42] = (char )'R';
#line 19
  fen[32][43] = (char )'3';
#line 19
  fen[32][44] = (char )'R';
#line 19
  fen[32][45] = (char )'1';
#line 19
  fen[32][46] = (char )'K';
#line 19
  fen[32][47] = (char )'1';
#line 19
  fen[32][48] = (char )' ';
#line 19
  fen[32][49] = (char )'w';
#line 19
  fen[32][50] = (char )'\000';
#line 19
  tmp___31 = 51U;
  {
#line 19
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 19
    if (tmp___31 >= 80U) {
#line 19
      goto while_break___31;
    }
#line 19
    fen[32][tmp___31] = (char)0;
#line 19
    tmp___31 ++;
  }
  while_break___31: /* CIL Label */ ;
  }
#line 19
  fen[33][0] = (char )'6';
#line 19
  fen[33][1] = (char )'k';
#line 19
  fen[33][2] = (char )'1';
#line 19
  fen[33][3] = (char )'/';
#line 19
  fen[33][4] = (char )'6';
#line 19
  fen[33][5] = (char )'p';
#line 19
  fen[33][6] = (char )'1';
#line 19
  fen[33][7] = (char )'/';
#line 19
  fen[33][8] = (char )'6';
#line 19
  fen[33][9] = (char )'P';
#line 19
  fen[33][10] = (char )'p';
#line 19
  fen[33][11] = (char )'/';
#line 19
  fen[33][12] = (char )'p';
#line 19
  fen[33][13] = (char )'p';
#line 19
  fen[33][14] = (char )'p';
#line 19
  fen[33][15] = (char )'5';
#line 19
  fen[33][16] = (char )'/';
#line 19
  fen[33][17] = (char )'3';
#line 19
  fen[33][18] = (char )'p';
#line 19
  fen[33][19] = (char )'n';
#line 19
  fen[33][20] = (char )'2';
#line 19
  fen[33][21] = (char )'P';
#line 19
  fen[33][22] = (char )'/';
#line 19
  fen[33][23] = (char )'1';
#line 19
  fen[33][24] = (char )'P';
#line 19
  fen[33][25] = (char )'3';
#line 19
  fen[33][26] = (char )'K';
#line 19
  fen[33][27] = (char )'2';
#line 19
  fen[33][28] = (char )'/';
#line 19
  fen[33][29] = (char )'1';
#line 19
  fen[33][30] = (char )'P';
#line 19
  fen[33][31] = (char )'P';
#line 19
  fen[33][32] = (char )'2';
#line 19
  fen[33][33] = (char )'P';
#line 19
  fen[33][34] = (char )'2';
#line 19
  fen[33][35] = (char )'/';
#line 19
  fen[33][36] = (char )'3';
#line 19
  fen[33][37] = (char )'N';
#line 19
  fen[33][38] = (char )'4';
#line 19
  fen[33][39] = (char )' ';
#line 19
  fen[33][40] = (char )'b';
#line 19
  fen[33][41] = (char )'\000';
#line 19
  tmp___32 = 42U;
  {
#line 19
  while (1) {
    while_continue___32: /* CIL Label */ ;
#line 19
    if (tmp___32 >= 80U) {
#line 19
      goto while_break___32;
    }
#line 19
    fen[33][tmp___32] = (char)0;
#line 19
    tmp___32 ++;
  }
  while_break___32: /* CIL Label */ ;
  }
#line 19
  fen[34][0] = (char )'8';
#line 19
  fen[34][1] = (char )'/';
#line 19
  fen[34][2] = (char )'3';
#line 19
  fen[34][3] = (char )'p';
#line 19
  fen[34][4] = (char )'3';
#line 19
  fen[34][5] = (char )'B';
#line 19
  fen[34][6] = (char )'/';
#line 19
  fen[34][7] = (char )'5';
#line 19
  fen[34][8] = (char )'p';
#line 19
  fen[34][9] = (char )'2';
#line 19
  fen[34][10] = (char )'/';
#line 19
  fen[34][11] = (char )'5';
#line 19
  fen[34][12] = (char )'P';
#line 19
  fen[34][13] = (char )'2';
#line 19
  fen[34][14] = (char )'/';
#line 19
  fen[34][15] = (char )'p';
#line 19
  fen[34][16] = (char )'7';
#line 19
  fen[34][17] = (char )'/';
#line 19
  fen[34][18] = (char )'P';
#line 19
  fen[34][19] = (char )'P';
#line 19
  fen[34][20] = (char )'5';
#line 19
  fen[34][21] = (char )'b';
#line 19
  fen[34][22] = (char )'/';
#line 19
  fen[34][23] = (char )'k';
#line 19
  fen[34][24] = (char )'7';
#line 19
  fen[34][25] = (char )'/';
#line 19
  fen[34][26] = (char )'6';
#line 19
  fen[34][27] = (char )'K';
#line 19
  fen[34][28] = (char )'1';
#line 19
  fen[34][29] = (char )' ';
#line 19
  fen[34][30] = (char )'w';
#line 19
  fen[34][31] = (char )'\000';
#line 19
  tmp___33 = 32U;
  {
#line 19
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 19
    if (tmp___33 >= 80U) {
#line 19
      goto while_break___33;
    }
#line 19
    fen[34][tmp___33] = (char)0;
#line 19
    tmp___33 ++;
  }
  while_break___33: /* CIL Label */ ;
  }
#line 19
  fen[35][0] = (char )'r';
#line 19
  fen[35][1] = (char )'1';
#line 19
  fen[35][2] = (char )'b';
#line 19
  fen[35][3] = (char )'b';
#line 19
  fen[35][4] = (char )'k';
#line 19
  fen[35][5] = (char )'1';
#line 19
  fen[35][6] = (char )'n';
#line 19
  fen[35][7] = (char )'r';
#line 19
  fen[35][8] = (char )'/';
#line 19
  fen[35][9] = (char )'p';
#line 19
  fen[35][10] = (char )'p';
#line 19
  fen[35][11] = (char )'3';
#line 19
  fen[35][12] = (char )'p';
#line 19
  fen[35][13] = (char )'1';
#line 19
  fen[35][14] = (char )'p';
#line 19
  fen[35][15] = (char )'/';
#line 19
  fen[35][16] = (char )'2';
#line 19
  fen[35][17] = (char )'n';
#line 19
  fen[35][18] = (char )'5';
#line 19
  fen[35][19] = (char )'/';
#line 19
  fen[35][20] = (char )'1';
#line 19
  fen[35][21] = (char )'N';
#line 19
  fen[35][22] = (char )'4';
#line 19
  fen[35][23] = (char )'p';
#line 19
  fen[35][24] = (char )'1';
#line 19
  fen[35][25] = (char )'/';
#line 19
  fen[35][26] = (char )'2';
#line 19
  fen[35][27] = (char )'N';
#line 19
  fen[35][28] = (char )'p';
#line 19
  fen[35][29] = (char )'1';
#line 19
  fen[35][30] = (char )'B';
#line 19
  fen[35][31] = (char )'2';
#line 19
  fen[35][32] = (char )'/';
#line 19
  fen[35][33] = (char )'8';
#line 19
  fen[35][34] = (char )'/';
#line 19
  fen[35][35] = (char )'P';
#line 19
  fen[35][36] = (char )'P';
#line 19
  fen[35][37] = (char )'P';
#line 19
  fen[35][38] = (char )'2';
#line 19
  fen[35][39] = (char )'P';
#line 19
  fen[35][40] = (char )'P';
#line 19
  fen[35][41] = (char )'P';
#line 19
  fen[35][42] = (char )'/';
#line 19
  fen[35][43] = (char )'2';
#line 19
  fen[35][44] = (char )'K';
#line 19
  fen[35][45] = (char )'R';
#line 19
  fen[35][46] = (char )'1';
#line 19
  fen[35][47] = (char )'B';
#line 19
  fen[35][48] = (char )'1';
#line 19
  fen[35][49] = (char )'R';
#line 19
  fen[35][50] = (char )' ';
#line 19
  fen[35][51] = (char )'w';
#line 19
  fen[35][52] = (char )'\000';
#line 19
  tmp___34 = 53U;
  {
#line 19
  while (1) {
    while_continue___34: /* CIL Label */ ;
#line 19
    if (tmp___34 >= 80U) {
#line 19
      goto while_break___34;
    }
#line 19
    fen[35][tmp___34] = (char)0;
#line 19
    tmp___34 ++;
  }
  while_break___34: /* CIL Label */ ;
  }
#line 19
  fen[36][0] = (char )'8';
#line 19
  fen[36][1] = (char )'/';
#line 19
  fen[36][2] = (char )'1';
#line 19
  fen[36][3] = (char )'p';
#line 19
  fen[36][4] = (char )'3';
#line 19
  fen[36][5] = (char )'p';
#line 19
  fen[36][6] = (char )'p';
#line 19
  fen[36][7] = (char )'1';
#line 19
  fen[36][8] = (char )'/';
#line 19
  fen[36][9] = (char )'7';
#line 19
  fen[36][10] = (char )'p';
#line 19
  fen[36][11] = (char )'/';
#line 19
  fen[36][12] = (char )'5';
#line 19
  fen[36][13] = (char )'P';
#line 19
  fen[36][14] = (char )'1';
#line 19
  fen[36][15] = (char )'P';
#line 19
  fen[36][16] = (char )'/';
#line 19
  fen[36][17] = (char )'2';
#line 19
  fen[36][18] = (char )'k';
#line 19
  fen[36][19] = (char )'3';
#line 19
  fen[36][20] = (char )'P';
#line 19
  fen[36][21] = (char )'1';
#line 19
  fen[36][22] = (char )'/';
#line 19
  fen[36][23] = (char )'8';
#line 19
  fen[36][24] = (char )'/';
#line 19
  fen[36][25] = (char )'2';
#line 19
  fen[36][26] = (char )'K';
#line 19
  fen[36][27] = (char )'2';
#line 19
  fen[36][28] = (char )'P';
#line 19
  fen[36][29] = (char )'2';
#line 19
  fen[36][30] = (char )'/';
#line 19
  fen[36][31] = (char )'8';
#line 19
  fen[36][32] = (char )' ';
#line 19
  fen[36][33] = (char )'w';
#line 19
  fen[36][34] = (char )'\000';
#line 19
  tmp___35 = 35U;
  {
#line 19
  while (1) {
    while_continue___35: /* CIL Label */ ;
#line 19
    if (tmp___35 >= 80U) {
#line 19
      goto while_break___35;
    }
#line 19
    fen[36][tmp___35] = (char)0;
#line 19
    tmp___35 ++;
  }
  while_break___35: /* CIL Label */ ;
  }
#line 19
  fen[37][0] = (char )'8';
#line 19
  fen[37][1] = (char )'/';
#line 19
  fen[37][2] = (char )'8';
#line 19
  fen[37][3] = (char )'/';
#line 19
  fen[37][4] = (char )'8';
#line 19
  fen[37][5] = (char )'/';
#line 19
  fen[37][6] = (char )'5';
#line 19
  fen[37][7] = (char )'N';
#line 19
  fen[37][8] = (char )'2';
#line 19
  fen[37][9] = (char )'/';
#line 19
  fen[37][10] = (char )'8';
#line 19
  fen[37][11] = (char )'/';
#line 19
  fen[37][12] = (char )'p';
#line 19
  fen[37][13] = (char )'7';
#line 19
  fen[37][14] = (char )'/';
#line 19
  fen[37][15] = (char )'8';
#line 19
  fen[37][16] = (char )'/';
#line 19
  fen[37][17] = (char )'2';
#line 19
  fen[37][18] = (char )'N';
#line 19
  fen[37][19] = (char )'K';
#line 19
  fen[37][20] = (char )'3';
#line 19
  fen[37][21] = (char )'k';
#line 19
  fen[37][22] = (char )' ';
#line 19
  fen[37][23] = (char )'w';
#line 19
  fen[37][24] = (char )'\000';
#line 19
  tmp___36 = 25U;
  {
#line 19
  while (1) {
    while_continue___36: /* CIL Label */ ;
#line 19
    if (tmp___36 >= 80U) {
#line 19
      goto while_break___36;
    }
#line 19
    fen[37][tmp___36] = (char)0;
#line 19
    tmp___36 ++;
  }
  while_break___36: /* CIL Label */ ;
  }
#line 19
  fen[38][0] = (char )'r';
#line 19
  fen[38][1] = (char )'1';
#line 19
  fen[38][2] = (char )'b';
#line 19
  fen[38][3] = (char )'q';
#line 19
  fen[38][4] = (char )'1';
#line 19
  fen[38][5] = (char )'r';
#line 19
  fen[38][6] = (char )'1';
#line 19
  fen[38][7] = (char )'k';
#line 19
  fen[38][8] = (char )'/';
#line 19
  fen[38][9] = (char )'b';
#line 19
  fen[38][10] = (char )'1';
#line 19
  fen[38][11] = (char )'p';
#line 19
  fen[38][12] = (char )'1';
#line 19
  fen[38][13] = (char )'n';
#line 19
  fen[38][14] = (char )'p';
#line 19
  fen[38][15] = (char )'p';
#line 19
  fen[38][16] = (char )'1';
#line 19
  fen[38][17] = (char )'/';
#line 19
  fen[38][18] = (char )'p';
#line 19
  fen[38][19] = (char )'2';
#line 19
  fen[38][20] = (char )'p';
#line 19
  fen[38][21] = (char )'3';
#line 19
  fen[38][22] = (char )'p';
#line 19
  fen[38][23] = (char )'/';
#line 19
  fen[38][24] = (char )'1';
#line 19
  fen[38][25] = (char )'p';
#line 19
  fen[38][26] = (char )'6';
#line 19
  fen[38][27] = (char )'/';
#line 19
  fen[38][28] = (char )'3';
#line 19
  fen[38][29] = (char )'P';
#line 19
  fen[38][30] = (char )'P';
#line 19
  fen[38][31] = (char )'3';
#line 19
  fen[38][32] = (char )'/';
#line 19
  fen[38][33] = (char )'1';
#line 19
  fen[38][34] = (char )'B';
#line 19
  fen[38][35] = (char )'2';
#line 19
  fen[38][36] = (char )'N';
#line 19
  fen[38][37] = (char )'N';
#line 19
  fen[38][38] = (char )'2';
#line 19
  fen[38][39] = (char )'/';
#line 19
  fen[38][40] = (char )'P';
#line 19
  fen[38][41] = (char )'P';
#line 19
  fen[38][42] = (char )'3';
#line 19
  fen[38][43] = (char )'P';
#line 19
  fen[38][44] = (char )'P';
#line 19
  fen[38][45] = (char )'P';
#line 19
  fen[38][46] = (char )'/';
#line 19
  fen[38][47] = (char )'R';
#line 19
  fen[38][48] = (char )'2';
#line 19
  fen[38][49] = (char )'Q';
#line 19
  fen[38][50] = (char )'1';
#line 19
  fen[38][51] = (char )'R';
#line 19
  fen[38][52] = (char )'K';
#line 19
  fen[38][53] = (char )'1';
#line 19
  fen[38][54] = (char )' ';
#line 19
  fen[38][55] = (char )'w';
#line 19
  fen[38][56] = (char )'\000';
#line 19
  tmp___37 = 57U;
  {
#line 19
  while (1) {
    while_continue___37: /* CIL Label */ ;
#line 19
    if (tmp___37 >= 80U) {
#line 19
      goto while_break___37;
    }
#line 19
    fen[38][tmp___37] = (char)0;
#line 19
    tmp___37 ++;
  }
  while_break___37: /* CIL Label */ ;
  }
#line 19
  fen[39][0] = (char )'8';
#line 19
  fen[39][1] = (char )'/';
#line 19
  fen[39][2] = (char )'8';
#line 19
  fen[39][3] = (char )'/';
#line 19
  fen[39][4] = (char )'1';
#line 19
  fen[39][5] = (char )'P';
#line 19
  fen[39][6] = (char )'6';
#line 19
  fen[39][7] = (char )'/';
#line 19
  fen[39][8] = (char )'5';
#line 19
  fen[39][9] = (char )'p';
#line 19
  fen[39][10] = (char )'r';
#line 19
  fen[39][11] = (char )'1';
#line 19
  fen[39][12] = (char )'/';
#line 19
  fen[39][13] = (char )'8';
#line 19
  fen[39][14] = (char )'/';
#line 19
  fen[39][15] = (char )'4';
#line 19
  fen[39][16] = (char )'R';
#line 19
  fen[39][17] = (char )'3';
#line 19
  fen[39][18] = (char )'/';
#line 19
  fen[39][19] = (char )'7';
#line 19
  fen[39][20] = (char )'k';
#line 19
  fen[39][21] = (char )'/';
#line 19
  fen[39][22] = (char )'2';
#line 19
  fen[39][23] = (char )'K';
#line 19
  fen[39][24] = (char )'5';
#line 19
  fen[39][25] = (char )' ';
#line 19
  fen[39][26] = (char )'w';
#line 19
  fen[39][27] = (char )'\000';
#line 19
  tmp___38 = 28U;
  {
#line 19
  while (1) {
    while_continue___38: /* CIL Label */ ;
#line 19
    if (tmp___38 >= 80U) {
#line 19
      goto while_break___38;
    }
#line 19
    fen[39][tmp___38] = (char)0;
#line 19
    tmp___38 ++;
  }
  while_break___38: /* CIL Label */ ;
  }
#line 19
  fen[40][0] = (char )'4';
#line 19
  fen[40][1] = (char )'k';
#line 19
  fen[40][2] = (char )'2';
#line 19
  fen[40][3] = (char )'r';
#line 19
  fen[40][4] = (char )'/';
#line 19
  fen[40][5] = (char )'1';
#line 19
  fen[40][6] = (char )'p';
#line 19
  fen[40][7] = (char )'b';
#line 19
  fen[40][8] = (char )'2';
#line 19
  fen[40][9] = (char )'p';
#line 19
  fen[40][10] = (char )'p';
#line 19
  fen[40][11] = (char )'p';
#line 19
  fen[40][12] = (char )'/';
#line 19
  fen[40][13] = (char )'1';
#line 19
  fen[40][14] = (char )'p';
#line 19
  fen[40][15] = (char )'2';
#line 19
  fen[40][16] = (char )'p';
#line 19
  fen[40][17] = (char )'3';
#line 19
  fen[40][18] = (char )'/';
#line 19
  fen[40][19] = (char )'1';
#line 19
  fen[40][20] = (char )'R';
#line 19
  fen[40][21] = (char )'1';
#line 19
  fen[40][22] = (char )'p';
#line 19
  fen[40][23] = (char )'4';
#line 19
  fen[40][24] = (char )'/';
#line 19
  fen[40][25] = (char )'3';
#line 19
  fen[40][26] = (char )'P';
#line 19
  fen[40][27] = (char )'4';
#line 19
  fen[40][28] = (char )'/';
#line 19
  fen[40][29] = (char )'2';
#line 19
  fen[40][30] = (char )'r';
#line 19
  fen[40][31] = (char )'1';
#line 19
  fen[40][32] = (char )'P';
#line 19
  fen[40][33] = (char )'N';
#line 19
  fen[40][34] = (char )'2';
#line 19
  fen[40][35] = (char )'/';
#line 19
  fen[40][36] = (char )'P';
#line 19
  fen[40][37] = (char )'4';
#line 19
  fen[40][38] = (char )'P';
#line 19
  fen[40][39] = (char )'P';
#line 19
  fen[40][40] = (char )'P';
#line 19
  fen[40][41] = (char )'/';
#line 19
  fen[40][42] = (char )'1';
#line 19
  fen[40][43] = (char )'R';
#line 19
  fen[40][44] = (char )'4';
#line 19
  fen[40][45] = (char )'K';
#line 19
  fen[40][46] = (char )'1';
#line 19
  fen[40][47] = (char )' ';
#line 19
  fen[40][48] = (char )'b';
#line 19
  fen[40][49] = (char )'\000';
#line 19
  tmp___39 = 50U;
  {
#line 19
  while (1) {
    while_continue___39: /* CIL Label */ ;
#line 19
    if (tmp___39 >= 80U) {
#line 19
      goto while_break___39;
    }
#line 19
    fen[40][tmp___39] = (char)0;
#line 19
    tmp___39 ++;
  }
  while_break___39: /* CIL Label */ ;
  }
#line 19
  fen[41][0] = (char )'r';
#line 19
  fen[41][1] = (char )'1';
#line 19
  fen[41][2] = (char )'b';
#line 19
  fen[41][3] = (char )'q';
#line 19
  fen[41][4] = (char )'1';
#line 19
  fen[41][5] = (char )'r';
#line 19
  fen[41][6] = (char )'1';
#line 19
  fen[41][7] = (char )'k';
#line 19
  fen[41][8] = (char )'/';
#line 19
  fen[41][9] = (char )'1';
#line 19
  fen[41][10] = (char )'p';
#line 19
  fen[41][11] = (char )'p';
#line 19
  fen[41][12] = (char )'1';
#line 19
  fen[41][13] = (char )'n';
#line 19
  fen[41][14] = (char )'1';
#line 19
  fen[41][15] = (char )'p';
#line 19
  fen[41][16] = (char )'p';
#line 19
  fen[41][17] = (char )'/';
#line 19
  fen[41][18] = (char )'1';
#line 19
  fen[41][19] = (char )'p';
#line 19
  fen[41][20] = (char )'1';
#line 19
  fen[41][21] = (char )'p';
#line 19
  fen[41][22] = (char )'4';
#line 19
  fen[41][23] = (char )'/';
#line 19
  fen[41][24] = (char )'4';
#line 19
  fen[41][25] = (char )'p';
#line 19
  fen[41][26] = (char )'2';
#line 19
  fen[41][27] = (char )'Q';
#line 19
  fen[41][28] = (char )'/';
#line 19
  fen[41][29] = (char )'4';
#line 19
  fen[41][30] = (char )'P';
#line 19
  fen[41][31] = (char )'p';
#line 19
  fen[41][32] = (char )'2';
#line 19
  fen[41][33] = (char )'/';
#line 19
  fen[41][34] = (char )'1';
#line 19
  fen[41][35] = (char )'B';
#line 19
  fen[41][36] = (char )'N';
#line 19
  fen[41][37] = (char )'P';
#line 19
  fen[41][38] = (char )'4';
#line 19
  fen[41][39] = (char )'/';
#line 19
  fen[41][40] = (char )'P';
#line 19
  fen[41][41] = (char )'P';
#line 19
  fen[41][42] = (char )'P';
#line 19
  fen[41][43] = (char )'2';
#line 19
  fen[41][44] = (char )'P';
#line 19
  fen[41][45] = (char )'P';
#line 19
  fen[41][46] = (char )'P';
#line 19
  fen[41][47] = (char )'/';
#line 19
  fen[41][48] = (char )'3';
#line 19
  fen[41][49] = (char )'R';
#line 19
  fen[41][50] = (char )'1';
#line 19
  fen[41][51] = (char )'R';
#line 19
  fen[41][52] = (char )'K';
#line 19
  fen[41][53] = (char )'1';
#line 19
  fen[41][54] = (char )' ';
#line 19
  fen[41][55] = (char )'w';
#line 19
  fen[41][56] = (char )'\000';
#line 19
  tmp___40 = 57U;
  {
#line 19
  while (1) {
    while_continue___40: /* CIL Label */ ;
#line 19
    if (tmp___40 >= 80U) {
#line 19
      goto while_break___40;
    }
#line 19
    fen[41][tmp___40] = (char)0;
#line 19
    tmp___40 ++;
  }
  while_break___40: /* CIL Label */ ;
  }
#line 19
  fen[42][0] = (char )'3';
#line 19
  fen[42][1] = (char )'r';
#line 19
  fen[42][2] = (char )'1';
#line 19
  fen[42][3] = (char )'k';
#line 19
  fen[42][4] = (char )'2';
#line 19
  fen[42][5] = (char )'/';
#line 19
  fen[42][6] = (char )'4';
#line 19
  fen[42][7] = (char )'n';
#line 19
  fen[42][8] = (char )'p';
#line 19
  fen[42][9] = (char )'p';
#line 19
  fen[42][10] = (char )'1';
#line 19
  fen[42][11] = (char )'/';
#line 19
  fen[42][12] = (char )'1';
#line 19
  fen[42][13] = (char )'p';
#line 19
  fen[42][14] = (char )'p';
#line 19
  fen[42][15] = (char )'r';
#line 19
  fen[42][16] = (char )'3';
#line 19
  fen[42][17] = (char )'p';
#line 19
  fen[42][18] = (char )'/';
#line 19
  fen[42][19] = (char )'p';
#line 19
  fen[42][20] = (char )'6';
#line 19
  fen[42][21] = (char )'P';
#line 19
  fen[42][22] = (char )'/';
#line 19
  fen[42][23] = (char )'P';
#line 19
  fen[42][24] = (char )'2';
#line 19
  fen[42][25] = (char )'P';
#line 19
  fen[42][26] = (char )'P';
#line 19
  fen[42][27] = (char )'P';
#line 19
  fen[42][28] = (char )'P';
#line 19
  fen[42][29] = (char )'1';
#line 19
  fen[42][30] = (char )'/';
#line 19
  fen[42][31] = (char )'1';
#line 19
  fen[42][32] = (char )'N';
#line 19
  fen[42][33] = (char )'R';
#line 19
  fen[42][34] = (char )'5';
#line 19
  fen[42][35] = (char )'/';
#line 19
  fen[42][36] = (char )'5';
#line 19
  fen[42][37] = (char )'K';
#line 19
  fen[42][38] = (char )'2';
#line 19
  fen[42][39] = (char )'/';
#line 19
  fen[42][40] = (char )'2';
#line 19
  fen[42][41] = (char )'R';
#line 19
  fen[42][42] = (char )'5';
#line 19
  fen[42][43] = (char )' ';
#line 19
  fen[42][44] = (char )'w';
#line 19
  fen[42][45] = (char )'\000';
#line 19
  tmp___41 = 46U;
  {
#line 19
  while (1) {
    while_continue___41: /* CIL Label */ ;
#line 19
    if (tmp___41 >= 80U) {
#line 19
      goto while_break___41;
    }
#line 19
    fen[42][tmp___41] = (char)0;
#line 19
    tmp___41 ++;
  }
  while_break___41: /* CIL Label */ ;
  }
#line 19
  fen[43][0] = (char )'r';
#line 19
  fen[43][1] = (char )'3';
#line 19
  fen[43][2] = (char )'r';
#line 19
  fen[43][3] = (char )'1';
#line 19
  fen[43][4] = (char )'k';
#line 19
  fen[43][5] = (char )'1';
#line 19
  fen[43][6] = (char )'/';
#line 19
  fen[43][7] = (char )'2';
#line 19
  fen[43][8] = (char )'p';
#line 19
  fen[43][9] = (char )'2';
#line 19
  fen[43][10] = (char )'p';
#line 19
  fen[43][11] = (char )'p';
#line 19
  fen[43][12] = (char )'p';
#line 19
  fen[43][13] = (char )'/';
#line 19
  fen[43][14] = (char )'p';
#line 19
  fen[43][15] = (char )'1';
#line 19
  fen[43][16] = (char )'p';
#line 19
  fen[43][17] = (char )'1';
#line 19
  fen[43][18] = (char )'b';
#line 19
  fen[43][19] = (char )'n';
#line 19
  fen[43][20] = (char )'2';
#line 19
  fen[43][21] = (char )'/';
#line 19
  fen[43][22] = (char )'8';
#line 19
  fen[43][23] = (char )'/';
#line 19
  fen[43][24] = (char )'1';
#line 19
  fen[43][25] = (char )'q';
#line 19
  fen[43][26] = (char )'2';
#line 19
  fen[43][27] = (char )'P';
#line 19
  fen[43][28] = (char )'3';
#line 19
  fen[43][29] = (char )'/';
#line 19
  fen[43][30] = (char )'2';
#line 19
  fen[43][31] = (char )'N';
#line 19
  fen[43][32] = (char )'P';
#line 19
  fen[43][33] = (char )'Q';
#line 19
  fen[43][34] = (char )'N';
#line 19
  fen[43][35] = (char )'2';
#line 19
  fen[43][36] = (char )'/';
#line 19
  fen[43][37] = (char )'P';
#line 19
  fen[43][38] = (char )'P';
#line 19
  fen[43][39] = (char )'P';
#line 19
  fen[43][40] = (char )'3';
#line 19
  fen[43][41] = (char )'P';
#line 19
  fen[43][42] = (char )'P';
#line 19
  fen[43][43] = (char )'/';
#line 19
  fen[43][44] = (char )'R';
#line 19
  fen[43][45] = (char )'4';
#line 19
  fen[43][46] = (char )'R';
#line 19
  fen[43][47] = (char )'K';
#line 19
  fen[43][48] = (char )'1';
#line 19
  fen[43][49] = (char )' ';
#line 19
  fen[43][50] = (char )'b';
#line 19
  fen[43][51] = (char )'\000';
#line 19
  tmp___42 = 52U;
  {
#line 19
  while (1) {
    while_continue___42: /* CIL Label */ ;
#line 19
    if (tmp___42 >= 80U) {
#line 19
      goto while_break___42;
    }
#line 19
    fen[43][tmp___42] = (char)0;
#line 19
    tmp___42 ++;
  }
  while_break___42: /* CIL Label */ ;
  }
#line 19
  fen[44][0] = (char )'6';
#line 19
  fen[44][1] = (char )'k';
#line 19
  fen[44][2] = (char )'1';
#line 19
  fen[44][3] = (char )'/';
#line 19
  fen[44][4] = (char )'4';
#line 19
  fen[44][5] = (char )'p';
#line 19
  fen[44][6] = (char )'p';
#line 19
  fen[44][7] = (char )'1';
#line 19
  fen[44][8] = (char )'p';
#line 19
  fen[44][9] = (char )'/';
#line 19
  fen[44][10] = (char )'3';
#line 19
  fen[44][11] = (char )'p';
#line 19
  fen[44][12] = (char )'2';
#line 19
  fen[44][13] = (char )'p';
#line 19
  fen[44][14] = (char )'1';
#line 19
  fen[44][15] = (char )'/';
#line 19
  fen[44][16] = (char )'P';
#line 19
  fen[44][17] = (char )'1';
#line 19
  fen[44][18] = (char )'p';
#line 19
  fen[44][19] = (char )'P';
#line 19
  fen[44][20] = (char )'b';
#line 19
  fen[44][21] = (char )'3';
#line 19
  fen[44][22] = (char )'/';
#line 19
  fen[44][23] = (char )'R';
#line 19
  fen[44][24] = (char )'7';
#line 19
  fen[44][25] = (char )'/';
#line 19
  fen[44][26] = (char )'1';
#line 19
  fen[44][27] = (char )'r';
#line 19
  fen[44][28] = (char )'2';
#line 19
  fen[44][29] = (char )'P';
#line 19
  fen[44][30] = (char )'1';
#line 19
  fen[44][31] = (char )'P';
#line 19
  fen[44][32] = (char )'P';
#line 19
  fen[44][33] = (char )'/';
#line 19
  fen[44][34] = (char )'3';
#line 19
  fen[44][35] = (char )'B';
#line 19
  fen[44][36] = (char )'1';
#line 19
  fen[44][37] = (char )'P';
#line 19
  fen[44][38] = (char )'2';
#line 19
  fen[44][39] = (char )'/';
#line 19
  fen[44][40] = (char )'6';
#line 19
  fen[44][41] = (char )'K';
#line 19
  fen[44][42] = (char )'1';
#line 19
  fen[44][43] = (char )' ';
#line 19
  fen[44][44] = (char )'w';
#line 19
  fen[44][45] = (char )'\000';
#line 19
  tmp___43 = 46U;
  {
#line 19
  while (1) {
    while_continue___43: /* CIL Label */ ;
#line 19
    if (tmp___43 >= 80U) {
#line 19
      goto while_break___43;
    }
#line 19
    fen[44][tmp___43] = (char)0;
#line 19
    tmp___43 ++;
  }
  while_break___43: /* CIL Label */ ;
  }
#line 19
  fen[45][0] = (char )'r';
#line 19
  fen[45][1] = (char )'1';
#line 19
  fen[45][2] = (char )'b';
#line 19
  fen[45][3] = (char )'q';
#line 19
  fen[45][4] = (char )'k';
#line 19
  fen[45][5] = (char )'2';
#line 19
  fen[45][6] = (char )'r';
#line 19
  fen[45][7] = (char )'/';
#line 19
  fen[45][8] = (char )'p';
#line 19
  fen[45][9] = (char )'p';
#line 19
  fen[45][10] = (char )'2';
#line 19
  fen[45][11] = (char )'b';
#line 19
  fen[45][12] = (char )'p';
#line 19
  fen[45][13] = (char )'p';
#line 19
  fen[45][14] = (char )'p';
#line 19
  fen[45][15] = (char )'/';
#line 19
  fen[45][16] = (char )'2';
#line 19
  fen[45][17] = (char )'p';
#line 19
  fen[45][18] = (char )'5';
#line 19
  fen[45][19] = (char )'/';
#line 19
  fen[45][20] = (char )'3';
#line 19
  fen[45][21] = (char )'p';
#line 19
  fen[45][22] = (char )'P';
#line 19
  fen[45][23] = (char )'3';
#line 19
  fen[45][24] = (char )'/';
#line 19
  fen[45][25] = (char )'P';
#line 19
  fen[45][26] = (char )'2';
#line 19
  fen[45][27] = (char )'Q';
#line 19
  fen[45][28] = (char )'1';
#line 19
  fen[45][29] = (char )'P';
#line 19
  fen[45][30] = (char )'2';
#line 19
  fen[45][31] = (char )'/';
#line 19
  fen[45][32] = (char )'2';
#line 19
  fen[45][33] = (char )'N';
#line 19
  fen[45][34] = (char )'1';
#line 19
  fen[45][35] = (char )'B';
#line 19
  fen[45][36] = (char )'3';
#line 19
  fen[45][37] = (char )'/';
#line 19
  fen[45][38] = (char )'1';
#line 19
  fen[45][39] = (char )'P';
#line 19
  fen[45][40] = (char )'P';
#line 19
  fen[45][41] = (char )'3';
#line 19
  fen[45][42] = (char )'P';
#line 19
  fen[45][43] = (char )'P';
#line 19
  fen[45][44] = (char )'/';
#line 19
  fen[45][45] = (char )'R';
#line 19
  fen[45][46] = (char )'4';
#line 19
  fen[45][47] = (char )'R';
#line 19
  fen[45][48] = (char )'K';
#line 19
  fen[45][49] = (char )'1';
#line 19
  fen[45][50] = (char )' ';
#line 19
  fen[45][51] = (char )'b';
#line 19
  fen[45][52] = (char )'\000';
#line 19
  tmp___44 = 53U;
  {
#line 19
  while (1) {
    while_continue___44: /* CIL Label */ ;
#line 19
    if (tmp___44 >= 80U) {
#line 19
      goto while_break___44;
    }
#line 19
    fen[45][tmp___44] = (char)0;
#line 19
    tmp___44 ++;
  }
  while_break___44: /* CIL Label */ ;
  }
#line 19
  fen[46][0] = (char )'r';
#line 19
  fen[46][1] = (char )'1';
#line 19
  fen[46][2] = (char )'q';
#line 19
  fen[46][3] = (char )'2';
#line 19
  fen[46][4] = (char )'r';
#line 19
  fen[46][5] = (char )'k';
#line 19
  fen[46][6] = (char )'1';
#line 19
  fen[46][7] = (char )'/';
#line 19
  fen[46][8] = (char )'2';
#line 19
  fen[46][9] = (char )'p';
#line 19
  fen[46][10] = (char )'1';
#line 19
  fen[46][11] = (char )'b';
#line 19
  fen[46][12] = (char )'p';
#line 19
  fen[46][13] = (char )'p';
#line 19
  fen[46][14] = (char )'p';
#line 19
  fen[46][15] = (char )'/';
#line 19
  fen[46][16] = (char )'2';
#line 19
  fen[46][17] = (char )'P';
#line 19
  fen[46][18] = (char )'p';
#line 19
  fen[46][19] = (char )'4';
#line 19
  fen[46][20] = (char )'/';
#line 19
  fen[46][21] = (char )'p';
#line 19
  fen[46][22] = (char )'6';
#line 19
  fen[46][23] = (char )'b';
#line 19
  fen[46][24] = (char )'/';
#line 19
  fen[46][25] = (char )'Q';
#line 19
  fen[46][26] = (char )'1';
#line 19
  fen[46][27] = (char )'P';
#line 19
  fen[46][28] = (char )'N';
#line 19
  fen[46][29] = (char )'p';
#line 19
  fen[46][30] = (char )'3';
#line 19
  fen[46][31] = (char )'/';
#line 19
  fen[46][32] = (char )'4';
#line 19
  fen[46][33] = (char )'B';
#line 19
  fen[46][34] = (char )'3';
#line 19
  fen[46][35] = (char )'/';
#line 19
  fen[46][36] = (char )'P';
#line 19
  fen[46][37] = (char )'P';
#line 19
  fen[46][38] = (char )'1';
#line 19
  fen[46][39] = (char )'R';
#line 19
  fen[46][40] = (char )'1';
#line 19
  fen[46][41] = (char )'P';
#line 19
  fen[46][42] = (char )'P';
#line 19
  fen[46][43] = (char )'P';
#line 19
  fen[46][44] = (char )'/';
#line 19
  fen[46][45] = (char )'2';
#line 19
  fen[46][46] = (char )'K';
#line 19
  fen[46][47] = (char )'4';
#line 19
  fen[46][48] = (char )'R';
#line 19
  fen[46][49] = (char )' ';
#line 19
  fen[46][50] = (char )'w';
#line 19
  fen[46][51] = (char )'\000';
#line 19
  tmp___45 = 52U;
  {
#line 19
  while (1) {
    while_continue___45: /* CIL Label */ ;
#line 19
    if (tmp___45 >= 80U) {
#line 19
      goto while_break___45;
    }
#line 19
    fen[46][tmp___45] = (char)0;
#line 19
    tmp___45 ++;
  }
  while_break___45: /* CIL Label */ ;
  }
#line 19
  fen[47][0] = (char )'8';
#line 19
  fen[47][1] = (char )'/';
#line 19
  fen[47][2] = (char )'p';
#line 19
  fen[47][3] = (char )'p';
#line 19
  fen[47][4] = (char )'2';
#line 19
  fen[47][5] = (char )'r';
#line 19
  fen[47][6] = (char )'1';
#line 19
  fen[47][7] = (char )'k';
#line 19
  fen[47][8] = (char )'1';
#line 19
  fen[47][9] = (char )'/';
#line 19
  fen[47][10] = (char )'2';
#line 19
  fen[47][11] = (char )'p';
#line 19
  fen[47][12] = (char )'1';
#line 19
  fen[47][13] = (char )'p';
#line 19
  fen[47][14] = (char )'3';
#line 19
  fen[47][15] = (char )'/';
#line 19
  fen[47][16] = (char )'3';
#line 19
  fen[47][17] = (char )'p';
#line 19
  fen[47][18] = (char )'P';
#line 19
  fen[47][19] = (char )'2';
#line 19
  fen[47][20] = (char )'p';
#line 19
  fen[47][21] = (char )'/';
#line 19
  fen[47][22] = (char )'1';
#line 19
  fen[47][23] = (char )'P';
#line 19
  fen[47][24] = (char )'1';
#line 19
  fen[47][25] = (char )'P';
#line 19
  fen[47][26] = (char )'1';
#line 19
  fen[47][27] = (char )'P';
#line 19
  fen[47][28] = (char )'1';
#line 19
  fen[47][29] = (char )'P';
#line 19
  fen[47][30] = (char )'/';
#line 19
  fen[47][31] = (char )'P';
#line 19
  fen[47][32] = (char )'5';
#line 19
  fen[47][33] = (char )'K';
#line 19
  fen[47][34] = (char )'R';
#line 19
  fen[47][35] = (char )'/';
#line 19
  fen[47][36] = (char )'8';
#line 19
  fen[47][37] = (char )'/';
#line 19
  fen[47][38] = (char )'8';
#line 19
  fen[47][39] = (char )' ';
#line 19
  fen[47][40] = (char )'w';
#line 19
  fen[47][41] = (char )'\000';
#line 19
  tmp___46 = 42U;
  {
#line 19
  while (1) {
    while_continue___46: /* CIL Label */ ;
#line 19
    if (tmp___46 >= 80U) {
#line 19
      goto while_break___46;
    }
#line 19
    fen[47][tmp___46] = (char)0;
#line 19
    tmp___46 ++;
  }
  while_break___46: /* CIL Label */ ;
  }
#line 19
  fen[48][0] = (char )'3';
#line 19
  fen[48][1] = (char )'b';
#line 19
  fen[48][2] = (char )'4';
#line 19
  fen[48][3] = (char )'/';
#line 19
  fen[48][4] = (char )'5';
#line 19
  fen[48][5] = (char )'k';
#line 19
  fen[48][6] = (char )'p';
#line 19
  fen[48][7] = (char )'1';
#line 19
  fen[48][8] = (char )'/';
#line 19
  fen[48][9] = (char )'1';
#line 19
  fen[48][10] = (char )'p';
#line 19
  fen[48][11] = (char )'1';
#line 19
  fen[48][12] = (char )'p';
#line 19
  fen[48][13] = (char )'1';
#line 19
  fen[48][14] = (char )'p';
#line 19
  fen[48][15] = (char )'1';
#line 19
  fen[48][16] = (char )'p';
#line 19
  fen[48][17] = (char )'/';
#line 19
  fen[48][18] = (char )'p';
#line 19
  fen[48][19] = (char )'P';
#line 19
  fen[48][20] = (char )'1';
#line 19
  fen[48][21] = (char )'P';
#line 19
  fen[48][22] = (char )'p';
#line 19
  fen[48][23] = (char )'P';
#line 19
  fen[48][24] = (char )'1';
#line 19
  fen[48][25] = (char )'P';
#line 19
  fen[48][26] = (char )'/';
#line 19
  fen[48][27] = (char )'P';
#line 19
  fen[48][28] = (char )'1';
#line 19
  fen[48][29] = (char )'P';
#line 19
  fen[48][30] = (char )'1';
#line 19
  fen[48][31] = (char )'P';
#line 19
  fen[48][32] = (char )'3';
#line 19
  fen[48][33] = (char )'/';
#line 19
  fen[48][34] = (char )'3';
#line 19
  fen[48][35] = (char )'K';
#line 19
  fen[48][36] = (char )'N';
#line 19
  fen[48][37] = (char )'3';
#line 19
  fen[48][38] = (char )'/';
#line 19
  fen[48][39] = (char )'8';
#line 19
  fen[48][40] = (char )'/';
#line 19
  fen[48][41] = (char )'8';
#line 19
  fen[48][42] = (char )' ';
#line 19
  fen[48][43] = (char )'w';
#line 19
  fen[48][44] = (char )'\000';
#line 19
  tmp___47 = 45U;
  {
#line 19
  while (1) {
    while_continue___47: /* CIL Label */ ;
#line 19
    if (tmp___47 >= 80U) {
#line 19
      goto while_break___47;
    }
#line 19
    fen[48][tmp___47] = (char)0;
#line 19
    tmp___47 ++;
  }
  while_break___47: /* CIL Label */ ;
  }
#line 19
  fen[49][0] = (char )'r';
#line 19
  fen[49][1] = (char )'1';
#line 19
  fen[49][2] = (char )'b';
#line 19
  fen[49][3] = (char )'q';
#line 19
  fen[49][4] = (char )'1';
#line 19
  fen[49][5] = (char )'r';
#line 19
  fen[49][6] = (char )'k';
#line 19
  fen[49][7] = (char )'1';
#line 19
  fen[49][8] = (char )'/';
#line 19
  fen[49][9] = (char )'p';
#line 19
  fen[49][10] = (char )'p';
#line 19
  fen[49][11] = (char )'2';
#line 19
  fen[49][12] = (char )'p';
#line 19
  fen[49][13] = (char )'p';
#line 19
  fen[49][14] = (char )'b';
#line 19
  fen[49][15] = (char )'p';
#line 19
  fen[49][16] = (char )'/';
#line 19
  fen[49][17] = (char )'2';
#line 19
  fen[49][18] = (char )'n';
#line 19
  fen[49][19] = (char )'p';
#line 19
  fen[49][20] = (char )'2';
#line 19
  fen[49][21] = (char )'p';
#line 19
  fen[49][22] = (char )'1';
#line 19
  fen[49][23] = (char )'/';
#line 19
  fen[49][24] = (char )'2';
#line 19
  fen[49][25] = (char )'n';
#line 19
  fen[49][26] = (char )'5';
#line 19
  fen[49][27] = (char )'/';
#line 19
  fen[49][28] = (char )'P';
#line 19
  fen[49][29] = (char )'3';
#line 19
  fen[49][30] = (char )'P';
#line 19
  fen[49][31] = (char )'P';
#line 19
  fen[49][32] = (char )'2';
#line 19
  fen[49][33] = (char )'/';
#line 19
  fen[49][34] = (char )'N';
#line 19
  fen[49][35] = (char )'1';
#line 19
  fen[49][36] = (char )'P';
#line 19
  fen[49][37] = (char )'2';
#line 19
  fen[49][38] = (char )'N';
#line 19
  fen[49][39] = (char )'2';
#line 19
  fen[49][40] = (char )'/';
#line 19
  fen[49][41] = (char )'1';
#line 19
  fen[49][42] = (char )'P';
#line 19
  fen[49][43] = (char )'B';
#line 19
  fen[49][44] = (char )'3';
#line 19
  fen[49][45] = (char )'P';
#line 19
  fen[49][46] = (char )'P';
#line 19
  fen[49][47] = (char )'/';
#line 19
  fen[49][48] = (char )'R';
#line 19
  fen[49][49] = (char )'1';
#line 19
  fen[49][50] = (char )'B';
#line 19
  fen[49][51] = (char )'1';
#line 19
  fen[49][52] = (char )'Q';
#line 19
  fen[49][53] = (char )'R';
#line 19
  fen[49][54] = (char )'K';
#line 19
  fen[49][55] = (char )'1';
#line 19
  fen[49][56] = (char )' ';
#line 19
  fen[49][57] = (char )'b';
#line 19
  fen[49][58] = (char )'\000';
#line 19
  tmp___48 = 59U;
  {
#line 19
  while (1) {
    while_continue___48: /* CIL Label */ ;
#line 19
    if (tmp___48 >= 80U) {
#line 19
      goto while_break___48;
    }
#line 19
    fen[49][tmp___48] = (char)0;
#line 19
    tmp___48 ++;
  }
  while_break___48: /* CIL Label */ ;
  }
#line 19
  fen[50][0] = (char )'r';
#line 19
  fen[50][1] = (char )'3';
#line 19
  fen[50][2] = (char )'r';
#line 19
  fen[50][3] = (char )'1';
#line 19
  fen[50][4] = (char )'k';
#line 19
  fen[50][5] = (char )'1';
#line 19
  fen[50][6] = (char )'/';
#line 19
  fen[50][7] = (char )'p';
#line 19
  fen[50][8] = (char )'p';
#line 19
  fen[50][9] = (char )'q';
#line 19
  fen[50][10] = (char )'b';
#line 19
  fen[50][11] = (char )'1';
#line 19
  fen[50][12] = (char )'p';
#line 19
  fen[50][13] = (char )'p';
#line 19
  fen[50][14] = (char )'p';
#line 19
  fen[50][15] = (char )'/';
#line 19
  fen[50][16] = (char )'8';
#line 19
  fen[50][17] = (char )'/';
#line 19
  fen[50][18] = (char )'4';
#line 19
  fen[50][19] = (char )'p';
#line 19
  fen[50][20] = (char )'1';
#line 19
  fen[50][21] = (char )'N';
#line 19
  fen[50][22] = (char )'Q';
#line 19
  fen[50][23] = (char )'/';
#line 19
  fen[50][24] = (char )'8';
#line 19
  fen[50][25] = (char )'/';
#line 19
  fen[50][26] = (char )'2';
#line 19
  fen[50][27] = (char )'P';
#line 19
  fen[50][28] = (char )'5';
#line 19
  fen[50][29] = (char )'/';
#line 19
  fen[50][30] = (char )'P';
#line 19
  fen[50][31] = (char )'P';
#line 19
  fen[50][32] = (char )'3';
#line 19
  fen[50][33] = (char )'P';
#line 19
  fen[50][34] = (char )'P';
#line 19
  fen[50][35] = (char )'P';
#line 19
  fen[50][36] = (char )'/';
#line 19
  fen[50][37] = (char )'R';
#line 19
  fen[50][38] = (char )'3';
#line 19
  fen[50][39] = (char )'R';
#line 19
  fen[50][40] = (char )'1';
#line 19
  fen[50][41] = (char )'K';
#line 19
  fen[50][42] = (char )'1';
#line 19
  fen[50][43] = (char )' ';
#line 19
  fen[50][44] = (char )'b';
#line 19
  fen[50][45] = (char )'\000';
#line 19
  tmp___49 = 46U;
  {
#line 19
  while (1) {
    while_continue___49: /* CIL Label */ ;
#line 19
    if (tmp___49 >= 80U) {
#line 19
      goto while_break___49;
    }
#line 19
    fen[50][tmp___49] = (char)0;
#line 19
    tmp___49 ++;
  }
  while_break___49: /* CIL Label */ ;
  }
#line 19
  fen[51][0] = (char )'r';
#line 19
  fen[51][1] = (char )'n';
#line 19
  fen[51][2] = (char )'b';
#line 19
  fen[51][3] = (char )'q';
#line 19
  fen[51][4] = (char )'k';
#line 19
  fen[51][5] = (char )'b';
#line 19
  fen[51][6] = (char )'1';
#line 19
  fen[51][7] = (char )'r';
#line 19
  fen[51][8] = (char )'/';
#line 19
  fen[51][9] = (char )'p';
#line 19
  fen[51][10] = (char )'3';
#line 19
  fen[51][11] = (char )'p';
#line 19
  fen[51][12] = (char )'p';
#line 19
  fen[51][13] = (char )'p';
#line 19
  fen[51][14] = (char )'p';
#line 19
  fen[51][15] = (char )'/';
#line 19
  fen[51][16] = (char )'1';
#line 19
  fen[51][17] = (char )'p';
#line 19
  fen[51][18] = (char )'6';
#line 19
  fen[51][19] = (char )'/';
#line 19
  fen[51][20] = (char )'2';
#line 19
  fen[51][21] = (char )'p';
#line 19
  fen[51][22] = (char )'p';
#line 19
  fen[51][23] = (char )'P';
#line 19
  fen[51][24] = (char )'3';
#line 19
  fen[51][25] = (char )'/';
#line 19
  fen[51][26] = (char )'3';
#line 19
  fen[51][27] = (char )'N';
#line 19
  fen[51][28] = (char )'4';
#line 19
  fen[51][29] = (char )'/';
#line 19
  fen[51][30] = (char )'2';
#line 19
  fen[51][31] = (char )'P';
#line 19
  fen[51][32] = (char )'5';
#line 19
  fen[51][33] = (char )'/';
#line 19
  fen[51][34] = (char )'P';
#line 19
  fen[51][35] = (char )'P';
#line 19
  fen[51][36] = (char )'P';
#line 19
  fen[51][37] = (char )'1';
#line 19
  fen[51][38] = (char )'Q';
#line 19
  fen[51][39] = (char )'P';
#line 19
  fen[51][40] = (char )'P';
#line 19
  fen[51][41] = (char )'P';
#line 19
  fen[51][42] = (char )'/';
#line 19
  fen[51][43] = (char )'R';
#line 19
  fen[51][44] = (char )'1';
#line 19
  fen[51][45] = (char )'B';
#line 19
  fen[51][46] = (char )'1';
#line 19
  fen[51][47] = (char )'K';
#line 19
  fen[51][48] = (char )'B';
#line 19
  fen[51][49] = (char )'1';
#line 19
  fen[51][50] = (char )'R';
#line 19
  fen[51][51] = (char )' ';
#line 19
  fen[51][52] = (char )'w';
#line 19
  fen[51][53] = (char )'\000';
#line 19
  tmp___50 = 54U;
  {
#line 19
  while (1) {
    while_continue___50: /* CIL Label */ ;
#line 19
    if (tmp___50 >= 80U) {
#line 19
      goto while_break___50;
    }
#line 19
    fen[51][tmp___50] = (char)0;
#line 19
    tmp___50 ++;
  }
  while_break___50: /* CIL Label */ ;
  }
#line 19
  fen[52][0] = (char )'r';
#line 19
  fen[52][1] = (char )'n';
#line 19
  fen[52][2] = (char )'b';
#line 19
  fen[52][3] = (char )'q';
#line 19
  fen[52][4] = (char )'k';
#line 19
  fen[52][5] = (char )'b';
#line 19
  fen[52][6] = (char )'n';
#line 19
  fen[52][7] = (char )'r';
#line 19
  fen[52][8] = (char )'/';
#line 19
  fen[52][9] = (char )'p';
#line 19
  fen[52][10] = (char )'p';
#line 19
  fen[52][11] = (char )'p';
#line 19
  fen[52][12] = (char )'p';
#line 19
  fen[52][13] = (char )'p';
#line 19
  fen[52][14] = (char )'p';
#line 19
  fen[52][15] = (char )'p';
#line 19
  fen[52][16] = (char )'p';
#line 19
  fen[52][17] = (char )'/';
#line 19
  fen[52][18] = (char )'8';
#line 19
  fen[52][19] = (char )'/';
#line 19
  fen[52][20] = (char )'8';
#line 19
  fen[52][21] = (char )'/';
#line 19
  fen[52][22] = (char )'8';
#line 19
  fen[52][23] = (char )'/';
#line 19
  fen[52][24] = (char )'8';
#line 19
  fen[52][25] = (char )'/';
#line 19
  fen[52][26] = (char )'P';
#line 19
  fen[52][27] = (char )'P';
#line 19
  fen[52][28] = (char )'P';
#line 19
  fen[52][29] = (char )'P';
#line 19
  fen[52][30] = (char )'P';
#line 19
  fen[52][31] = (char )'P';
#line 19
  fen[52][32] = (char )'P';
#line 19
  fen[52][33] = (char )'P';
#line 19
  fen[52][34] = (char )'/';
#line 19
  fen[52][35] = (char )'R';
#line 19
  fen[52][36] = (char )'N';
#line 19
  fen[52][37] = (char )'B';
#line 19
  fen[52][38] = (char )'Q';
#line 19
  fen[52][39] = (char )'K';
#line 19
  fen[52][40] = (char )'B';
#line 19
  fen[52][41] = (char )'N';
#line 19
  fen[52][42] = (char )'R';
#line 19
  fen[52][43] = (char )' ';
#line 19
  fen[52][44] = (char )'w';
#line 19
  fen[52][45] = (char )'\000';
#line 19
  tmp___51 = 46U;
  {
#line 19
  while (1) {
    while_continue___51: /* CIL Label */ ;
#line 19
    if (tmp___51 >= 80U) {
#line 19
      goto while_break___51;
    }
#line 19
    fen[52][tmp___51] = (char)0;
#line 19
    tmp___51 ++;
  }
  while_break___51: /* CIL Label */ ;
  }
#line 19
  fen[53][0] = (char )'/';
#line 19
  fen[53][1] = (char )'k';
#line 19
  fen[53][2] = (char )'/';
#line 19
  fen[53][3] = (char )'3';
#line 19
  fen[53][4] = (char )'p';
#line 19
  fen[53][5] = (char )'/';
#line 19
  fen[53][6] = (char )'p';
#line 19
  fen[53][7] = (char )'2';
#line 19
  fen[53][8] = (char )'P';
#line 19
  fen[53][9] = (char )'1';
#line 19
  fen[53][10] = (char )'p';
#line 19
  fen[53][11] = (char )'/';
#line 19
  fen[53][12] = (char )'P';
#line 19
  fen[53][13] = (char )'2';
#line 19
  fen[53][14] = (char )'P';
#line 19
  fen[53][15] = (char )'1';
#line 19
  fen[53][16] = (char )'P';
#line 19
  fen[53][17] = (char )'/';
#line 19
  fen[53][18] = (char )'/';
#line 19
  fen[53][19] = (char )'/';
#line 19
  fen[53][20] = (char )'K';
#line 19
  fen[53][21] = (char )'/';
#line 19
  fen[53][22] = (char )' ';
#line 19
  fen[53][23] = (char )'w';
#line 19
  fen[53][24] = (char )'\000';
#line 19
  tmp___52 = 25U;
  {
#line 19
  while (1) {
    while_continue___52: /* CIL Label */ ;
#line 19
    if (tmp___52 >= 80U) {
#line 19
      goto while_break___52;
    }
#line 19
    fen[53][tmp___52] = (char)0;
#line 19
    tmp___52 ++;
  }
  while_break___52: /* CIL Label */ ;
  }
#line 19
  fen[54][0] = (char )'r';
#line 19
  fen[54][1] = (char )'n';
#line 19
  fen[54][2] = (char )'b';
#line 19
  fen[54][3] = (char )'2';
#line 19
  fen[54][4] = (char )'r';
#line 19
  fen[54][5] = (char )'1';
#line 19
  fen[54][6] = (char )'k';
#line 19
  fen[54][7] = (char )'/';
#line 19
  fen[54][8] = (char )'p';
#line 19
  fen[54][9] = (char )'p';
#line 19
  fen[54][10] = (char )'2';
#line 19
  fen[54][11] = (char )'p';
#line 19
  fen[54][12] = (char )'2';
#line 19
  fen[54][13] = (char )'p';
#line 19
  fen[54][14] = (char )'/';
#line 19
  fen[54][15] = (char )'2';
#line 19
  fen[54][16] = (char )'p';
#line 19
  fen[54][17] = (char )'p';
#line 19
  fen[54][18] = (char )'2';
#line 19
  fen[54][19] = (char )'p';
#line 19
  fen[54][20] = (char )'1';
#line 19
  fen[54][21] = (char )'/';
#line 19
  fen[54][22] = (char )'q';
#line 19
  fen[54][23] = (char )'2';
#line 19
  fen[54][24] = (char )'P';
#line 19
  fen[54][25] = (char )'1';
#line 19
  fen[54][26] = (char )'p';
#line 19
  fen[54][27] = (char )'2';
#line 19
  fen[54][28] = (char )'/';
#line 19
  fen[54][29] = (char )'8';
#line 19
  fen[54][30] = (char )'/';
#line 19
  fen[54][31] = (char )'1';
#line 19
  fen[54][32] = (char )'P';
#line 19
  fen[54][33] = (char )'b';
#line 19
  fen[54][34] = (char )'2';
#line 19
  fen[54][35] = (char )'N';
#line 19
  fen[54][36] = (char )'P';
#line 19
  fen[54][37] = (char )'1';
#line 19
  fen[54][38] = (char )'/';
#line 19
  fen[54][39] = (char )'P';
#line 19
  fen[54][40] = (char )'B';
#line 19
  fen[54][41] = (char )'2';
#line 19
  fen[54][42] = (char )'P';
#line 19
  fen[54][43] = (char )'P';
#line 19
  fen[54][44] = (char )'B';
#line 19
  fen[54][45] = (char )'P';
#line 19
  fen[54][46] = (char )'/';
#line 19
  fen[54][47] = (char )'R';
#line 19
  fen[54][48] = (char )'2';
#line 19
  fen[54][49] = (char )'Q';
#line 19
  fen[54][50] = (char )'1';
#line 19
  fen[54][51] = (char )'R';
#line 19
  fen[54][52] = (char )'K';
#line 19
  fen[54][53] = (char )'1';
#line 19
  fen[54][54] = (char )' ';
#line 19
  fen[54][55] = (char )'w';
#line 19
  fen[54][56] = (char )'\000';
#line 19
  tmp___53 = 57U;
  {
#line 19
  while (1) {
    while_continue___53: /* CIL Label */ ;
#line 19
    if (tmp___53 >= 80U) {
#line 19
      goto while_break___53;
    }
#line 19
    fen[54][tmp___53] = (char)0;
#line 19
    tmp___53 ++;
  }
  while_break___53: /* CIL Label */ ;
  }
#line 19
  fen[55][0] = (char )'8';
#line 19
  fen[55][1] = (char )'/';
#line 19
  fen[55][2] = (char )'6';
#line 19
  fen[55][3] = (char )'p';
#line 19
  fen[55][4] = (char )'k';
#line 19
  fen[55][5] = (char )'/';
#line 19
  fen[55][6] = (char )'1';
#line 19
  fen[55][7] = (char )'p';
#line 19
  fen[55][8] = (char )'6';
#line 19
  fen[55][9] = (char )'/';
#line 19
  fen[55][10] = (char )'8';
#line 19
  fen[55][11] = (char )'/';
#line 19
  fen[55][12] = (char )'P';
#line 19
  fen[55][13] = (char )'P';
#line 19
  fen[55][14] = (char )'3';
#line 19
  fen[55][15] = (char )'p';
#line 19
  fen[55][16] = (char )'1';
#line 19
  fen[55][17] = (char )'p';
#line 19
  fen[55][18] = (char )'/';
#line 19
  fen[55][19] = (char )'5';
#line 19
  fen[55][20] = (char )'P';
#line 19
  fen[55][21] = (char )'2';
#line 19
  fen[55][22] = (char )'/';
#line 19
  fen[55][23] = (char )'4';
#line 19
  fen[55][24] = (char )'K';
#line 19
  fen[55][25] = (char )'P';
#line 19
  fen[55][26] = (char )'1';
#line 19
  fen[55][27] = (char )'q';
#line 19
  fen[55][28] = (char )'/';
#line 19
  fen[55][29] = (char )'3';
#line 19
  fen[55][30] = (char )'Q';
#line 19
  fen[55][31] = (char )'4';
#line 19
  fen[55][32] = (char )' ';
#line 19
  fen[55][33] = (char )'w';
#line 19
  fen[55][34] = (char )'\000';
#line 19
  tmp___54 = 35U;
  {
#line 19
  while (1) {
    while_continue___54: /* CIL Label */ ;
#line 19
    if (tmp___54 >= 80U) {
#line 19
      goto while_break___54;
    }
#line 19
    fen[55][tmp___54] = (char)0;
#line 19
    tmp___54 ++;
  }
  while_break___54: /* CIL Label */ ;
  }
#line 19
  fen[56][0] = (char )'8';
#line 19
  fen[56][1] = (char )'/';
#line 19
  fen[56][2] = (char )'3';
#line 19
  fen[56][3] = (char )'p';
#line 19
  fen[56][4] = (char )'4';
#line 19
  fen[56][5] = (char )'/';
#line 19
  fen[56][6] = (char )'p';
#line 19
  fen[56][7] = (char )'1';
#line 19
  fen[56][8] = (char )'b';
#line 19
  fen[56][9] = (char )'k';
#line 19
  fen[56][10] = (char )'3';
#line 19
  fen[56][11] = (char )'p';
#line 19
  fen[56][12] = (char )'/';
#line 19
  fen[56][13] = (char )'P';
#line 19
  fen[56][14] = (char )'p';
#line 19
  fen[56][15] = (char )'6';
#line 19
  fen[56][16] = (char )'/';
#line 19
  fen[56][17] = (char )'1';
#line 19
  fen[56][18] = (char )'K';
#line 19
  fen[56][19] = (char )'p';
#line 19
  fen[56][20] = (char )'1';
#line 19
  fen[56][21] = (char )'P';
#line 19
  fen[56][22] = (char )'p';
#line 19
  fen[56][23] = (char )'P';
#line 19
  fen[56][24] = (char )'p';
#line 19
  fen[56][25] = (char )'/';
#line 19
  fen[56][26] = (char )'2';
#line 19
  fen[56][27] = (char )'P';
#line 19
  fen[56][28] = (char )'2';
#line 19
  fen[56][29] = (char )'P';
#line 19
  fen[56][30] = (char )'1';
#line 19
  fen[56][31] = (char )'P';
#line 19
  fen[56][32] = (char )'/';
#line 19
  fen[56][33] = (char )'2';
#line 19
  fen[56][34] = (char )'P';
#line 19
  fen[56][35] = (char )'5';
#line 19
  fen[56][36] = (char )'/';
#line 19
  fen[56][37] = (char )'5';
#line 19
  fen[56][38] = (char )'B';
#line 19
  fen[56][39] = (char )'2';
#line 19
  fen[56][40] = (char )' ';
#line 19
  fen[56][41] = (char )'b';
#line 19
  fen[56][42] = (char )'\000';
#line 19
  tmp___55 = 43U;
  {
#line 19
  while (1) {
    while_continue___55: /* CIL Label */ ;
#line 19
    if (tmp___55 >= 80U) {
#line 19
      goto while_break___55;
    }
#line 19
    fen[56][tmp___55] = (char)0;
#line 19
    tmp___55 ++;
  }
  while_break___55: /* CIL Label */ ;
  }
#line 19
  fen[57][0] = (char )'1';
#line 19
  fen[57][1] = (char )'n';
#line 19
  fen[57][2] = (char )'k';
#line 19
  fen[57][3] = (char )'1';
#line 19
  fen[57][4] = (char )'r';
#line 19
  fen[57][5] = (char )'1';
#line 19
  fen[57][6] = (char )'r';
#line 19
  fen[57][7] = (char )'1';
#line 19
  fen[57][8] = (char )'/';
#line 19
  fen[57][9] = (char )'p';
#line 19
  fen[57][10] = (char )'p';
#line 19
  fen[57][11] = (char )'2';
#line 19
  fen[57][12] = (char )'n';
#line 19
  fen[57][13] = (char )'1';
#line 19
  fen[57][14] = (char )'p';
#line 19
  fen[57][15] = (char )'p';
#line 19
  fen[57][16] = (char )'/';
#line 19
  fen[57][17] = (char )'4';
#line 19
  fen[57][18] = (char )'p';
#line 19
  fen[57][19] = (char )'3';
#line 19
  fen[57][20] = (char )'/';
#line 19
  fen[57][21] = (char )'q';
#line 19
  fen[57][22] = (char )'2';
#line 19
  fen[57][23] = (char )'p';
#line 19
  fen[57][24] = (char )'P';
#line 19
  fen[57][25] = (char )'p';
#line 19
  fen[57][26] = (char )'1';
#line 19
  fen[57][27] = (char )'N';
#line 19
  fen[57][28] = (char )'/';
#line 19
  fen[57][29] = (char )'b';
#line 19
  fen[57][30] = (char )'1';
#line 19
  fen[57][31] = (char )'p';
#line 19
  fen[57][32] = (char )'P';
#line 19
  fen[57][33] = (char )'1';
#line 19
  fen[57][34] = (char )'P';
#line 19
  fen[57][35] = (char )'2';
#line 19
  fen[57][36] = (char )'/';
#line 19
  fen[57][37] = (char )'B';
#line 19
  fen[57][38] = (char )'1';
#line 19
  fen[57][39] = (char )'P';
#line 19
  fen[57][40] = (char )'2';
#line 19
  fen[57][41] = (char )'R';
#line 19
  fen[57][42] = (char )'2';
#line 19
  fen[57][43] = (char )'/';
#line 19
  fen[57][44] = (char )'2';
#line 19
  fen[57][45] = (char )'P';
#line 19
  fen[57][46] = (char )'1';
#line 19
  fen[57][47] = (char )'B';
#line 19
  fen[57][48] = (char )'1';
#line 19
  fen[57][49] = (char )'P';
#line 19
  fen[57][50] = (char )'P';
#line 19
  fen[57][51] = (char )'/';
#line 19
  fen[57][52] = (char )'R';
#line 19
  fen[57][53] = (char )'2';
#line 19
  fen[57][54] = (char )'Q';
#line 19
  fen[57][55] = (char )'2';
#line 19
  fen[57][56] = (char )'K';
#line 19
  fen[57][57] = (char )'1';
#line 19
  fen[57][58] = (char )' ';
#line 19
  fen[57][59] = (char )'w';
#line 19
  fen[57][60] = (char )'\000';
#line 19
  tmp___56 = 61U;
  {
#line 19
  while (1) {
    while_continue___56: /* CIL Label */ ;
#line 19
    if (tmp___56 >= 80U) {
#line 19
      goto while_break___56;
    }
#line 19
    fen[57][tmp___56] = (char)0;
#line 19
    tmp___56 ++;
  }
  while_break___56: /* CIL Label */ ;
  }
#line 19
  fen[58][0] = (char )'2';
#line 19
  fen[58][1] = (char )'K';
#line 19
  fen[58][2] = (char )'5';
#line 19
  fen[58][3] = (char )'/';
#line 19
  fen[58][4] = (char )'p';
#line 19
  fen[58][5] = (char )'7';
#line 19
  fen[58][6] = (char )'/';
#line 19
  fen[58][7] = (char )'7';
#line 19
  fen[58][8] = (char )'P';
#line 19
  fen[58][9] = (char )'/';
#line 19
  fen[58][10] = (char )'5';
#line 19
  fen[58][11] = (char )'p';
#line 19
  fen[58][12] = (char )'R';
#line 19
  fen[58][13] = (char )'1';
#line 19
  fen[58][14] = (char )'/';
#line 19
  fen[58][15] = (char )'8';
#line 19
  fen[58][16] = (char )'/';
#line 19
  fen[58][17] = (char )'5';
#line 19
  fen[58][18] = (char )'k';
#line 19
  fen[58][19] = (char )'2';
#line 19
  fen[58][20] = (char )'/';
#line 19
  fen[58][21] = (char )'r';
#line 19
  fen[58][22] = (char )'7';
#line 19
  fen[58][23] = (char )'/';
#line 19
  fen[58][24] = (char )'8';
#line 19
  fen[58][25] = (char )' ';
#line 19
  fen[58][26] = (char )'w';
#line 19
  fen[58][27] = (char )'\000';
#line 19
  tmp___57 = 28U;
  {
#line 19
  while (1) {
    while_continue___57: /* CIL Label */ ;
#line 19
    if (tmp___57 >= 80U) {
#line 19
      goto while_break___57;
    }
#line 19
    fen[58][tmp___57] = (char)0;
#line 19
    tmp___57 ++;
  }
  while_break___57: /* CIL Label */ ;
  }
#line 19
  fen[59][0] = (char )'3';
#line 19
  fen[59][1] = (char )'r';
#line 19
  fen[59][2] = (char )'r';
#line 19
  fen[59][3] = (char )'3';
#line 19
  fen[59][4] = (char )'/';
#line 19
  fen[59][5] = (char )'2';
#line 19
  fen[59][6] = (char )'p';
#line 19
  fen[59][7] = (char )'q';
#line 19
  fen[59][8] = (char )'2';
#line 19
  fen[59][9] = (char )'p';
#line 19
  fen[59][10] = (char )'k';
#line 19
  fen[59][11] = (char )'/';
#line 19
  fen[59][12] = (char )'p';
#line 19
  fen[59][13] = (char )'2';
#line 19
  fen[59][14] = (char )'p';
#line 19
  fen[59][15] = (char )'1';
#line 19
  fen[59][16] = (char )'p';
#line 19
  fen[59][17] = (char )'n';
#line 19
  fen[59][18] = (char )'p';
#line 19
  fen[59][19] = (char )'/';
#line 19
  fen[59][20] = (char )'8';
#line 19
  fen[59][21] = (char )'/';
#line 19
  fen[59][22] = (char )'2';
#line 19
  fen[59][23] = (char )'Q';
#line 19
  fen[59][24] = (char )'B';
#line 19
  fen[59][25] = (char )'P';
#line 19
  fen[59][26] = (char )'P';
#line 19
  fen[59][27] = (char )'2';
#line 19
  fen[59][28] = (char )'/';
#line 19
  fen[59][29] = (char )'1';
#line 19
  fen[59][30] = (char )'P';
#line 19
  fen[59][31] = (char )'6';
#line 19
  fen[59][32] = (char )'/';
#line 19
  fen[59][33] = (char )'P';
#line 19
  fen[59][34] = (char )'5';
#line 19
  fen[59][35] = (char )'P';
#line 19
  fen[59][36] = (char )'P';
#line 19
  fen[59][37] = (char )'/';
#line 19
  fen[59][38] = (char )'4';
#line 19
  fen[59][39] = (char )'R';
#line 19
  fen[59][40] = (char )'R';
#line 19
  fen[59][41] = (char )'K';
#line 19
  fen[59][42] = (char )'1';
#line 19
  fen[59][43] = (char )' ';
#line 19
  fen[59][44] = (char )'b';
#line 19
  fen[59][45] = (char )'\000';
#line 19
  tmp___58 = 46U;
  {
#line 19
  while (1) {
    while_continue___58: /* CIL Label */ ;
#line 19
    if (tmp___58 >= 80U) {
#line 19
      goto while_break___58;
    }
#line 19
    fen[59][tmp___58] = (char)0;
#line 19
    tmp___58 ++;
  }
  while_break___58: /* CIL Label */ ;
  }
#line 19
  fen[60][0] = (char )'r';
#line 19
  fen[60][1] = (char )'1';
#line 19
  fen[60][2] = (char )'b';
#line 19
  fen[60][3] = (char )'2';
#line 19
  fen[60][4] = (char )'r';
#line 19
  fen[60][5] = (char )'k';
#line 19
  fen[60][6] = (char )'1';
#line 19
  fen[60][7] = (char )'/';
#line 19
  fen[60][8] = (char )'2';
#line 19
  fen[60][9] = (char )'q';
#line 19
  fen[60][10] = (char )'1';
#line 19
  fen[60][11] = (char )'b';
#line 19
  fen[60][12] = (char )'1';
#line 19
  fen[60][13] = (char )'p';
#line 19
  fen[60][14] = (char )'p';
#line 19
  fen[60][15] = (char )'/';
#line 19
  fen[60][16] = (char )'p';
#line 19
  fen[60][17] = (char )'2';
#line 19
  fen[60][18] = (char )'p';
#line 19
  fen[60][19] = (char )'p';
#line 19
  fen[60][20] = (char )'n';
#line 19
  fen[60][21] = (char )'2';
#line 19
  fen[60][22] = (char )'/';
#line 19
  fen[60][23] = (char )'1';
#line 19
  fen[60][24] = (char )'p';
#line 19
  fen[60][25] = (char )'6';
#line 19
  fen[60][26] = (char )'/';
#line 19
  fen[60][27] = (char )'3';
#line 19
  fen[60][28] = (char )'Q';
#line 19
  fen[60][29] = (char )'P';
#line 19
  fen[60][30] = (char )'3';
#line 19
  fen[60][31] = (char )'/';
#line 19
  fen[60][32] = (char )'1';
#line 19
  fen[60][33] = (char )'B';
#line 19
  fen[60][34] = (char )'N';
#line 19
  fen[60][35] = (char )'1';
#line 19
  fen[60][36] = (char )'B';
#line 19
  fen[60][37] = (char )'3';
#line 19
  fen[60][38] = (char )'/';
#line 19
  fen[60][39] = (char )'P';
#line 19
  fen[60][40] = (char )'P';
#line 19
  fen[60][41] = (char )'P';
#line 19
  fen[60][42] = (char )'3';
#line 19
  fen[60][43] = (char )'P';
#line 19
  fen[60][44] = (char )'P';
#line 19
  fen[60][45] = (char )'/';
#line 19
  fen[60][46] = (char )'R';
#line 19
  fen[60][47] = (char )'4';
#line 19
  fen[60][48] = (char )'R';
#line 19
  fen[60][49] = (char )'K';
#line 19
  fen[60][50] = (char )'1';
#line 19
  fen[60][51] = (char )' ';
#line 19
  fen[60][52] = (char )'w';
#line 19
  fen[60][53] = (char )'\000';
#line 19
  tmp___59 = 54U;
  {
#line 19
  while (1) {
    while_continue___59: /* CIL Label */ ;
#line 19
    if (tmp___59 >= 80U) {
#line 19
      goto while_break___59;
    }
#line 19
    fen[60][tmp___59] = (char)0;
#line 19
    tmp___59 ++;
  }
  while_break___59: /* CIL Label */ ;
  }
#line 19
  fen[61][0] = (char )'8';
#line 19
  fen[61][1] = (char )'/';
#line 19
  fen[61][2] = (char )'8';
#line 19
  fen[61][3] = (char )'/';
#line 19
  fen[61][4] = (char )'8';
#line 19
  fen[61][5] = (char )'/';
#line 19
  fen[61][6] = (char )'8';
#line 19
  fen[61][7] = (char )'/';
#line 19
  fen[61][8] = (char )'5';
#line 19
  fen[61][9] = (char )'k';
#line 19
  fen[61][10] = (char )'p';
#line 19
  fen[61][11] = (char )'1';
#line 19
  fen[61][12] = (char )'/';
#line 19
  fen[61][13] = (char )'P';
#line 19
  fen[61][14] = (char )'7';
#line 19
  fen[61][15] = (char )'/';
#line 19
  fen[61][16] = (char )'8';
#line 19
  fen[61][17] = (char )'/';
#line 19
  fen[61][18] = (char )'1';
#line 19
  fen[61][19] = (char )'K';
#line 19
  fen[61][20] = (char )'1';
#line 19
  fen[61][21] = (char )'N';
#line 19
  fen[61][22] = (char )'4';
#line 19
  fen[61][23] = (char )' ';
#line 19
  fen[61][24] = (char )'w';
#line 19
  fen[61][25] = (char )'\000';
#line 19
  tmp___60 = 26U;
  {
#line 19
  while (1) {
    while_continue___60: /* CIL Label */ ;
#line 19
    if (tmp___60 >= 80U) {
#line 19
      goto while_break___60;
    }
#line 19
    fen[61][tmp___60] = (char)0;
#line 19
    tmp___60 ++;
  }
  while_break___60: /* CIL Label */ ;
  }
#line 19
  fen[62][0] = (char )'r';
#line 19
  fen[62][1] = (char )'4';
#line 19
  fen[62][2] = (char )'k';
#line 19
  fen[62][3] = (char )'2';
#line 19
  fen[62][4] = (char )'/';
#line 19
  fen[62][5] = (char )'p';
#line 19
  fen[62][6] = (char )'b';
#line 19
  fen[62][7] = (char )'2';
#line 19
  fen[62][8] = (char )'b';
#line 19
  fen[62][9] = (char )'p';
#line 19
  fen[62][10] = (char )'1';
#line 19
  fen[62][11] = (char )'r';
#line 19
  fen[62][12] = (char )'/';
#line 19
  fen[62][13] = (char )'1';
#line 19
  fen[62][14] = (char )'p';
#line 19
  fen[62][15] = (char )'1';
#line 19
  fen[62][16] = (char )'q';
#line 19
  fen[62][17] = (char )'p';
#line 19
  fen[62][18] = (char )'2';
#line 19
  fen[62][19] = (char )'p';
#line 19
  fen[62][20] = (char )'/';
#line 19
  fen[62][21] = (char )'3';
#line 19
  fen[62][22] = (char )'p';
#line 19
  fen[62][23] = (char )'N';
#line 19
  fen[62][24] = (char )'p';
#line 19
  fen[62][25] = (char )'2';
#line 19
  fen[62][26] = (char )'/';
#line 19
  fen[62][27] = (char )'3';
#line 19
  fen[62][28] = (char )'P';
#line 19
  fen[62][29] = (char )'1';
#line 19
  fen[62][30] = (char )'P';
#line 19
  fen[62][31] = (char )'2';
#line 19
  fen[62][32] = (char )'/';
#line 19
  fen[62][33] = (char )'2';
#line 19
  fen[62][34] = (char )'N';
#line 19
  fen[62][35] = (char )'3';
#line 19
  fen[62][36] = (char )'P';
#line 19
  fen[62][37] = (char )'1';
#line 19
  fen[62][38] = (char )'/';
#line 19
  fen[62][39] = (char )'P';
#line 19
  fen[62][40] = (char )'P';
#line 19
  fen[62][41] = (char )'P';
#line 19
  fen[62][42] = (char )'1';
#line 19
  fen[62][43] = (char )'Q';
#line 19
  fen[62][44] = (char )'2';
#line 19
  fen[62][45] = (char )'P';
#line 19
  fen[62][46] = (char )'/';
#line 19
  fen[62][47] = (char )'2';
#line 19
  fen[62][48] = (char )'K';
#line 19
  fen[62][49] = (char )'R';
#line 19
  fen[62][50] = (char )'R';
#line 19
  fen[62][51] = (char )'3';
#line 19
  fen[62][52] = (char )' ';
#line 19
  fen[62][53] = (char )'w';
#line 19
  fen[62][54] = (char )'\000';
#line 19
  tmp___61 = 55U;
  {
#line 19
  while (1) {
    while_continue___61: /* CIL Label */ ;
#line 19
    if (tmp___61 >= 80U) {
#line 19
      goto while_break___61;
    }
#line 19
    fen[62][tmp___61] = (char)0;
#line 19
    tmp___61 ++;
  }
  while_break___61: /* CIL Label */ ;
  }
#line 19
  fen[63][0] = (char )'r';
#line 19
  fen[63][1] = (char )'3';
#line 19
  fen[63][2] = (char )'k';
#line 19
  fen[63][3] = (char )'2';
#line 19
  fen[63][4] = (char )'r';
#line 19
  fen[63][5] = (char )'/';
#line 19
  fen[63][6] = (char )'p';
#line 19
  fen[63][7] = (char )'1';
#line 19
  fen[63][8] = (char )'p';
#line 19
  fen[63][9] = (char )'p';
#line 19
  fen[63][10] = (char )'q';
#line 19
  fen[63][11] = (char )'p';
#line 19
  fen[63][12] = (char )'b';
#line 19
  fen[63][13] = (char )'1';
#line 19
  fen[63][14] = (char )'/';
#line 19
  fen[63][15] = (char )'b';
#line 19
  fen[63][16] = (char )'n';
#line 19
  fen[63][17] = (char )'2';
#line 19
  fen[63][18] = (char )'p';
#line 19
  fen[63][19] = (char )'n';
#line 19
  fen[63][20] = (char )'p';
#line 19
  fen[63][21] = (char )'1';
#line 19
  fen[63][22] = (char )'/';
#line 19
  fen[63][23] = (char )'3';
#line 19
  fen[63][24] = (char )'P';
#line 19
  fen[63][25] = (char )'N';
#line 19
  fen[63][26] = (char )'3';
#line 19
  fen[63][27] = (char )'/';
#line 19
  fen[63][28] = (char )'1';
#line 19
  fen[63][29] = (char )'p';
#line 19
  fen[63][30] = (char )'2';
#line 19
  fen[63][31] = (char )'P';
#line 19
  fen[63][32] = (char )'3';
#line 19
  fen[63][33] = (char )'/';
#line 19
  fen[63][34] = (char )'2';
#line 19
  fen[63][35] = (char )'N';
#line 19
  fen[63][36] = (char )'2';
#line 19
  fen[63][37] = (char )'Q';
#line 19
  fen[63][38] = (char )'1';
#line 19
  fen[63][39] = (char )'p';
#line 19
  fen[63][40] = (char )'/';
#line 19
  fen[63][41] = (char )'P';
#line 19
  fen[63][42] = (char )'P';
#line 19
  fen[63][43] = (char )'P';
#line 19
  fen[63][44] = (char )'B';
#line 19
  fen[63][45] = (char )'B';
#line 19
  fen[63][46] = (char )'P';
#line 19
  fen[63][47] = (char )'P';
#line 19
  fen[63][48] = (char )'P';
#line 19
  fen[63][49] = (char )'/';
#line 19
  fen[63][50] = (char )'R';
#line 19
  fen[63][51] = (char )'3';
#line 19
  fen[63][52] = (char )'K';
#line 19
  fen[63][53] = (char )'2';
#line 19
  fen[63][54] = (char )'R';
#line 19
  fen[63][55] = (char )' ';
#line 19
  fen[63][56] = (char )'w';
#line 19
  fen[63][57] = (char )'\000';
#line 19
  tmp___62 = 58U;
  {
#line 19
  while (1) {
    while_continue___62: /* CIL Label */ ;
#line 19
    if (tmp___62 >= 80U) {
#line 19
      goto while_break___62;
    }
#line 19
    fen[63][tmp___62] = (char)0;
#line 19
    tmp___62 ++;
  }
  while_break___62: /* CIL Label */ ;
  }
#line 85
  fen_depth = 16;
#line 94
  total_time_used = 0;
#line 95
  old_st = search_time_limit;
#line 96
  old_sd = search_depth;
#line 97
  old_do = display_options;
#line 98
  search_time_limit = 90000;
#line 99
  display_options = 1;
#line 100
  old_book = book_file;
#line 101
  book_file = (FILE *)0;
#line 102
  old_books = books_file;
#line 103
  books_file = (FILE *)0;
#line 104
  if (! autotune) {
#line 105
    if (increase) {
#line 106
      Print(4095, "Running serial benchmark (modifying depth by %d plies). . .\n",
            increase);
    } else {
#line 110
      Print(4095, "Running serial benchmark. . .\n");
    }
#line 111
    fflush(stdout);
  }
#line 123
  pos = 0;
  {
#line 123
  while (1) {
    while_continue___63: /* CIL Label */ ;
#line 123
    if (! (pos < 64)) {
#line 123
      goto while_break___63;
    }
#line 124
    strcpy(buffer, (char const   *)(fen[pos]));
#line 125
    nargs = ReadParse(buffer, args, " \t;=");
#line 126
    SetBoard((TREE *)tree, nargs, args, 0);
#line 127
    search_depth = fen_depth + increase;
#line 128
    last_pv.pathd = 0;
#line 129
    thinking = 1;
#line 130
    tree->status[1] = tree->status[0];
#line 131
    InitializeHashTables(0);
#line 132
    Iterate(game_wtm, 1, 0);
#line 133
    thinking = 0;
#line 134
    nodes += tree->nodes_searched;
#line 135
    total_time_used = (int )((unsigned int )total_time_used + (program_end_time - program_start_time));
#line 136
    if ((uint64_t )program_end_time - (uint64_t )program_start_time > 1UL) {
#line 136
      tmp___63 = (uint64_t )program_end_time - (uint64_t )program_start_time;
    } else {
#line 136
      tmp___63 = (uint64_t )1;
    }
#line 136
    nodes_per_second = (unsigned int )((tree->nodes_searched * 100UL) / tmp___63);
#line 139
    if (pos % 7 == 0) {
#line 140
      Print(4095, "pos: ");
    }
#line 141
    tmp___64 = DisplayKMB((uint64_t )nodes_per_second, 0);
#line 141
    Print(4095, "%2d(%s) ", pos + 1, tmp___64);
#line 142
    if (pos % 7 == 6) {
#line 143
      Print(4095, "\n");
    }
#line 144
    fflush(stdout);
#line 123
    pos ++;
  }
  while_break___63: /* CIL Label */ ;
  }
#line 153
  if (! autotune) {
#line 154
    printf((char const   *)"\n");
  }
#line 155
  if (! autotune) {
#line 156
    Print(4095, "\nTotal nodes: %lu\n", nodes);
#line 157
    Print(4095, "Raw nodes per second: %d\n", (int )((double )nodes / ((double )total_time_used / 100.0)));
#line 159
    Print(4095, "Total elapsed time: %.2f\n\n", (double )total_time_used / 100.0);
  }
#line 170
  if (smp_max_threads == 0U) {
#line 171
    smp_max_threads = 2U;
#line 172
    Print(4095, "Running SMP benchmark (%d threads)...\n", smp_max_threads);
#line 173
    fflush(stdout);
#line 174
    Print(4095, "pos: ");
#line 175
    pos = 0;
    {
#line 175
    while (1) {
      while_continue___64: /* CIL Label */ ;
#line 175
      if (pos < 2) {
#line 175
        if (! (old_mt == 0)) {
#line 175
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 175
        goto while_break___64;
      }
#line 176
      strcpy(buffer, (char const   *)(fen[pos]));
#line 177
      nargs = ReadParse(buffer, args, " \t;=");
#line 178
      SetBoard((TREE *)tree, nargs, args, 0);
#line 179
      search_depth = fen_depth + increase;
#line 180
      last_pv.pathd = 0;
#line 181
      thinking = 1;
#line 182
      tree->status[1] = tree->status[0];
#line 183
      InitializeHashTables(0);
#line 184
      Iterate(game_wtm, 1, 0);
#line 185
      thinking = 0;
#line 186
      nodes += tree->nodes_searched;
#line 187
      total_time_used = (int )((unsigned int )total_time_used + (program_end_time - program_start_time));
#line 188
      if ((uint64_t )program_end_time - (uint64_t )program_start_time > 1UL) {
#line 188
        tmp___65 = (uint64_t )program_end_time - (uint64_t )program_start_time;
      } else {
#line 188
        tmp___65 = (uint64_t )1;
      }
#line 188
      nodes_per_second = (unsigned int )((tree->nodes_searched * 100UL) / tmp___65);
#line 191
      tmp___66 = DisplayKMB((uint64_t )nodes_per_second, 0);
#line 191
      Print(4095, "%2d(%s) ", pos + 1, tmp___66);
#line 175
      pos ++;
    }
    while_break___64: /* CIL Label */ ;
    }
  }
#line 201
  if (! autotune) {
#line 202
    printf((char const   *)"\n");
  }
#line 203
  if (! autotune) {
#line 203
    if (old_mt == 0) {
#line 204
      Print(4095, "\nTotal nodes: %lu\n", nodes);
#line 205
      Print(4095, "Raw nodes per second: %d\n", (int )((double )nodes / ((double )total_time_used / 100.0)));
#line 207
      Print(4095, "Total elapsed time: %.2f\n\n", (double )total_time_used / 100.0);
    } else {
#line 203
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 210
  input_stream = stdin;
#line 211
  early_exit = 99;
#line 212
  display_options = old_do;
#line 213
  search_time_limit = old_st;
#line 214
  search_depth = old_sd;
#line 215
  if (0 > old_mt) {
#line 215
    smp_max_threads = 0U;
  } else {
#line 215
    smp_max_threads = (unsigned int )old_mt;
  }
#line 216
  books_file = old_books;
#line 217
  book_file = old_book;
#line 218
  InitializeChessBoard((TREE *)tree);
#line 219
  return (total_time_used);
}
}
#line 3 "data.c"
int scale  =    100;
#line 11 "data.c"
int presult  =    0;
#line 13 "data.c"
int allow_cores  =    1;
#line 14 "data.c"
int allow_memory  =    1;
#line 24 "data.c"
int line_length  =    80;
#line 36 "data.c"
int learn_positions_count  =    0;
#line 47 "data.c"
int nsegments  =    0;
#line 52 "data.c"
uint64_t const   randoms[2][7][64]  = { { {          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull}, 
     {          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0xd1fc122dd721044cull,          (uint64_t const   )0xa4159629bd0ce70eull,          (uint64_t const   )0xab5da9e9ae24ad63ull,          (uint64_t const   )0x32e60a2983d1c843ull, 
                (uint64_t const   )0x3c3cf99dabf131aaull,          (uint64_t const   )0xd83283085553e1fdull,          (uint64_t const   )0x180370f4abada20full,          (uint64_t const   )0xa7db417ed5cef0f6ull, 
                (uint64_t const   )0x8940b08b9b2fc0d4ull,          (uint64_t const   )0x852d84b34edc83d2ull,          (uint64_t const   )0x068d4a5f2548652full,          (uint64_t const   )0x35ce432f12163d2eull, 
                (uint64_t const   )0xc9ba66fee4843746ull,          (uint64_t const   )0xabccc0992b67af9eull,          (uint64_t const   )0x217f1caa6a824b26ull,          (uint64_t const   )0x4a05addc1ea2e944ull, 
                (uint64_t const   )0xfe2312497bf4c414ull,          (uint64_t const   )0x8495248ab305ee8full,          (uint64_t const   )0xcb96c4247c24e036ull,          (uint64_t const   )0xab76533d29e3c6eaull, 
                (uint64_t const   )0xc0944c15e3c09778ull,          (uint64_t const   )0x1053b4ccf6c024d6ull,          (uint64_t const   )0x8d96dda010ba133aull,          (uint64_t const   )0x9f59cef04505da02ull, 
                (uint64_t const   )0x581ae15866c42214ull,          (uint64_t const   )0x3a61654f9da998bfull,          (uint64_t const   )0x47efd3ec19fb73c0ull,          (uint64_t const   )0x2126b228fdb69cb5ull, 
                (uint64_t const   )0xbb2ff9574df0d641ull,          (uint64_t const   )0x32b9d1ed571b84b8ull,          (uint64_t const   )0x4f688c6727828a1full,          (uint64_t const   )0x576784e75cc9d113ull, 
                (uint64_t const   )0x15e82e121ffd9115ull,          (uint64_t const   )0xbc0156dbcef2a7deull,          (uint64_t const   )0x6365ce9628bd842eull,          (uint64_t const   )0x3a898fc4ece11b80ull, 
                (uint64_t const   )0xa6f7652af004d29full,          (uint64_t const   )0x5fa9ca7e22d71d72ull,          (uint64_t const   )0x5a06111a2088be1full,          (uint64_t const   )0x05aae96e3384dfe4ull, 
                (uint64_t const   )0xe697a8f517ab3d3full,          (uint64_t const   )0x9d3c1d1302e84551ull,          (uint64_t const   )0x6e0b75ab4901a6c9ull,          (uint64_t const   )0xd35c48fba6cf7eefull, 
                (uint64_t const   )0xc8ee1ca11e20a35eull,          (uint64_t const   )0x382637115387cc68ull,          (uint64_t const   )0x8d499580f4544852ull,          (uint64_t const   )0x1e4a273c98576ebdull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull}, 
     {          (uint64_t const   )0x2009a159d9509cb5ull,          (uint64_t const   )0x5fa8c13086419e55ull,          (uint64_t const   )0xea13669343bcd4b9ull,          (uint64_t const   )0x3e47b851efbef3a4ull, 
                (uint64_t const   )0x6caa31dec6814cc6ull,          (uint64_t const   )0x992161e6ef2c2919ull,          (uint64_t const   )0x8bed069c11856a55ull,          (uint64_t const   )0x5c73de210d683e98ull, 
                (uint64_t const   )0xa7185f2616bd83c1ull,          (uint64_t const   )0xd7c04ef29cf3751eull,          (uint64_t const   )0x9f46f244eaf78bcfull,          (uint64_t const   )0x38f85c7bcda11a85ull, 
                (uint64_t const   )0x22f1e6aabfe845aaull,          (uint64_t const   )0xa8aa67f9237dbb68ull,          (uint64_t const   )0x90e2e582b1c84a64ull,          (uint64_t const   )0x5c685bafc31b3c9full, 
                (uint64_t const   )0xc031fe468f6f6967ull,          (uint64_t const   )0x8d75aa382752602aull,          (uint64_t const   )0x244475599eceffd5ull,          (uint64_t const   )0x0d0cfcd52bb265d4ull, 
                (uint64_t const   )0xda433164b4750dc1ull,          (uint64_t const   )0x85dfeab10d5752d6ull,          (uint64_t const   )0x7225a1188a0376ebull,          (uint64_t const   )0xa8be7b123a102607ull, 
                (uint64_t const   )0x603b914a4429875eull,          (uint64_t const   )0x399be2aedab54c3bull,          (uint64_t const   )0x58d916991d8a5cc4ull,          (uint64_t const   )0x35b8f864e4685bdbull, 
                (uint64_t const   )0x46739c9baf790ac0ull,          (uint64_t const   )0xd1327ef186fb215aull,          (uint64_t const   )0x140368fd88e26668ull,          (uint64_t const   )0xd38e499b69fa1e25ull, 
                (uint64_t const   )0xc96f5a7d211f3f9full,          (uint64_t const   )0x97655506a678b4bcull,          (uint64_t const   )0x7f8ddfb015f07d87ull,          (uint64_t const   )0xbf7bfed396840428ull, 
                (uint64_t const   )0xfd2f0668eb41e684ull,          (uint64_t const   )0x24936e7db2759b2dull,          (uint64_t const   )0x267a311ebcd14f08ull,          (uint64_t const   )0xf5a13e0e1d60b856ull, 
                (uint64_t const   )0x69f15803d26af16aull,          (uint64_t const   )0x82fac9552fa58953ull,          (uint64_t const   )0xd71ea59c19c54beaull,          (uint64_t const   )0x62fdb302c66279d4ull, 
                (uint64_t const   )0xf0c1baa7e1513de5ull,          (uint64_t const   )0x363454db33ee5ef4ull,          (uint64_t const   )0xab4045843a34f2e0ull,          (uint64_t const   )0x73f10c94a39100fdull, 
                (uint64_t const   )0x0a86593ec58517e8ull,          (uint64_t const   )0xae96e568385585deull,          (uint64_t const   )0x608a57252ef6f020ull,          (uint64_t const   )0x39cac56cc61f3368ull, 
                (uint64_t const   )0x44a6a43e32a682b4ull,          (uint64_t const   )0xa085261969416c01ull,          (uint64_t const   )0xbb870177729e6283ull,          (uint64_t const   )0x1276bdc2fc1b7238ull, 
                (uint64_t const   )0x77bcdc0127c4da80ull,          (uint64_t const   )0xbf16bb430520dde5ull,          (uint64_t const   )0x153a63a94e385bddull,          (uint64_t const   )0x95104c33771f4a98ull, 
                (uint64_t const   )0xb0ff0dfa8ef47265ull,          (uint64_t const   )0xc48762efcfbadae4ull,          (uint64_t const   )0xf70e5b4dae84cfd0ull,          (uint64_t const   )0x250cabf0859b323bull}, 
     {          (uint64_t const   )0xf71c3f6b2fd5891cull,          (uint64_t const   )0x5d5675218dd4da7eull,          (uint64_t const   )0xd8e7b9cd991893a1ull,          (uint64_t const   )0xe4e1af2cf1bcb046ull, 
                (uint64_t const   )0xa762655491b63283ull,          (uint64_t const   )0xd8dc072d881ba73aull,          (uint64_t const   )0xdb9cdd7d25570179ull,          (uint64_t const   )0x76618a18da1cfd9aull, 
                (uint64_t const   )0xe4ed6cee7fb62d0cull,          (uint64_t const   )0xfebc55cf05ef2fbfull,          (uint64_t const   )0x9a9f5c4a59c51554ull,          (uint64_t const   )0xea91c3d8f98c3ecfull, 
                (uint64_t const   )0x2f71c5493a5be25aull,          (uint64_t const   )0x8c4d65413c6bbfe6ull,          (uint64_t const   )0x9f06ed35f9a2eac6ull,          (uint64_t const   )0x178831e02b8775b2ull, 
                (uint64_t const   )0x10a3d155d65cd6c1ull,          (uint64_t const   )0x4b7a69b028a0cd53ull,          (uint64_t const   )0xd7b84fb5e0de02f0ull,          (uint64_t const   )0x9e266498ec93bb5cull, 
                (uint64_t const   )0xea0e4ad3f773090dull,          (uint64_t const   )0x4cf4b1acc505eb02ull,          (uint64_t const   )0x11bea6e26eff78fdull,          (uint64_t const   )0x7986363d8e9c8b02ull, 
                (uint64_t const   )0xff2ca02deb5af054ull,          (uint64_t const   )0x3ad2351100f322d5ull,          (uint64_t const   )0x24a21f70f0b14613ull,          (uint64_t const   )0x475dbafc509421a2ull, 
                (uint64_t const   )0x9e78abd3cd79162cull,          (uint64_t const   )0xe492fd5185f74274ull,          (uint64_t const   )0xc974fffbb9c5bcbdull,          (uint64_t const   )0x2fdc971bd1756a88ull, 
                (uint64_t const   )0x7229f20d9ed56e61ull,          (uint64_t const   )0x724bb3259de1f22full,          (uint64_t const   )0xebdba47c4a9c567aull,          (uint64_t const   )0xf93c634904fe151aull, 
                (uint64_t const   )0x051bcfecd0485d42ull,          (uint64_t const   )0x94974a65ffaf78a4ull,          (uint64_t const   )0x1e2e5e3f8b50a25dull,          (uint64_t const   )0x81b99d563b25e57aull, 
                (uint64_t const   )0xdae46bb9fceadb75ull,          (uint64_t const   )0xde35e8171244a7b5ull,          (uint64_t const   )0xf4fc75ad58cca9f2ull,          (uint64_t const   )0x06396ddce8fd9c68ull, 
                (uint64_t const   )0x9acabf60af793fb6ull,          (uint64_t const   )0x5329b615e95c5bdfull,          (uint64_t const   )0xd86f5fd82254a62full,          (uint64_t const   )0xf0af6c56a32479b2ull, 
                (uint64_t const   )0xca21baeeba56a815ull,          (uint64_t const   )0x0396c3624ca42a50ull,          (uint64_t const   )0xaccae9419d0f493full,          (uint64_t const   )0x6d148daab4ac1bb7ull, 
                (uint64_t const   )0xdbd78e8efc177ba2ull,          (uint64_t const   )0xcee72e2a4d16dcc6ull,          (uint64_t const   )0x4590974f7d6ec962ull,          (uint64_t const   )0xd3b28408305b5764ull, 
                (uint64_t const   )0x20c201d44df1eb89ull,          (uint64_t const   )0x0cef72d2cdef5930ull,          (uint64_t const   )0xa9e4ca60ebc9a62aull,          (uint64_t const   )0x8f84dab7d30110cdull, 
                (uint64_t const   )0x6803ad1d2c809a22ull,          (uint64_t const   )0x4e3319dcbeefdd75ull,          (uint64_t const   )0xb1c8fe5b88eaedbbull,          (uint64_t const   )0x3d5ceaecade87f00ull}, 
     {          (uint64_t const   )0xdb87073201334b8eull,          (uint64_t const   )0x5a37d087e1ae272bull,          (uint64_t const   )0x80b67cc99b9d27a1ull,          (uint64_t const   )0xd09d5f7db214f4baull, 
                (uint64_t const   )0x3306a98928d65742ull,          (uint64_t const   )0x65bc1cc4ac254147ull,          (uint64_t const   )0x92e266c8e0c61bd7ull,          (uint64_t const   )0x3efe1a6dd93a7ea9ull, 
                (uint64_t const   )0x516008fcc74b5982ull,          (uint64_t const   )0x7087c00b1219938aull,          (uint64_t const   )0x54ed780d615a4d93ull,          (uint64_t const   )0xf7b393019e97eb56ull, 
                (uint64_t const   )0x282b3182cb55067cull,          (uint64_t const   )0xf74719c6e544ea8dull,          (uint64_t const   )0x35629880486810e2ull,          (uint64_t const   )0xccb4db1f1f298264ull, 
                (uint64_t const   )0x801d864f04ade5d0ull,          (uint64_t const   )0xe32ae6267b0c6f71ull,          (uint64_t const   )0xc33dbe2c2656b326ull,          (uint64_t const   )0x8cf005f6aced02b1ull, 
                (uint64_t const   )0x1f4f622ce80d5b56ull,          (uint64_t const   )0x5c5166351f09065cull,          (uint64_t const   )0x27ee88da0b3f17f3ull,          (uint64_t const   )0x24342d232e1cc60dull, 
                (uint64_t const   )0xe71b0ef73358b399ull,          (uint64_t const   )0x8032078133780469ull,          (uint64_t const   )0xe34b1780fa310f3dull,          (uint64_t const   )0xcde826ad5c866d50ull, 
                (uint64_t const   )0x61cbad7ae034ed02ull,          (uint64_t const   )0x7ec80dc7d5443ff8ull,          (uint64_t const   )0x7552b2e6a70d2fefull,          (uint64_t const   )0xb5c65d387d8a622eull, 
                (uint64_t const   )0xcb74a3731b1404dfull,          (uint64_t const   )0x3d17820c84c52320ull,          (uint64_t const   )0x012907839e217ebbull,          (uint64_t const   )0xeb7f86a56d1ae07aull, 
                (uint64_t const   )0xf934a28184b8bc95ull,          (uint64_t const   )0xe18c5514a3ffc474ull,          (uint64_t const   )0x81e302d64f1e874aull,          (uint64_t const   )0x993d2d29543a0051ull, 
                (uint64_t const   )0x4710980708601e84ull,          (uint64_t const   )0xc7301ea9cc8b59beull,          (uint64_t const   )0x947c354adc6fc86full,          (uint64_t const   )0xba7443084a3f3d4dull, 
                (uint64_t const   )0x468112e49b318b2eull,          (uint64_t const   )0x636e353267f00946ull,          (uint64_t const   )0xae160a34615f3ce7ull,          (uint64_t const   )0xd38ce1fbfa0ae670ull, 
                (uint64_t const   )0x183da8dda4081ec1ull,          (uint64_t const   )0xeccb6d0700512aa9ull,          (uint64_t const   )0xafffc8e3770d1024ull,          (uint64_t const   )0xcc95e0c2786e2d74ull, 
                (uint64_t const   )0x7a889c70ef7b2d7bull,          (uint64_t const   )0xc1612de64cbd613full,          (uint64_t const   )0xf102a29abfbadfefull,          (uint64_t const   )0x9aa9300a182763faull, 
                (uint64_t const   )0x1bc552dcfcfd38a8ull,          (uint64_t const   )0x0a7b6521e6b8170dull,          (uint64_t const   )0x2ba06c62d6b1efcdull,          (uint64_t const   )0xeea0e6daafd143a8ull, 
                (uint64_t const   )0x9d02cbfd6f7cc234ull,          (uint64_t const   )0x8aecebc23d68acb5ull,          (uint64_t const   )0x1d1aa95d783617a7ull,          (uint64_t const   )0x514e9d5763edb419ull}, 
     {          (uint64_t const   )0x1e8860e4e8afcffcull,          (uint64_t const   )0x107fb5302e49b653ull,          (uint64_t const   )0x453ca2eb419de2c5ull,          (uint64_t const   )0xa3094e8eb1649123ull, 
                (uint64_t const   )0xe850ac9a440dd0afull,          (uint64_t const   )0xe6eb2d90ade835b6ull,          (uint64_t const   )0x75dfa9af6b2e2517ull,          (uint64_t const   )0x89d272086a4586b0ull, 
                (uint64_t const   )0x04f2d543b5fdd518ull,          (uint64_t const   )0xec4c28a9a0d6e1e7ull,          (uint64_t const   )0x17258fcd264c21dbull,          (uint64_t const   )0xf556bc18377a9614ull, 
                (uint64_t const   )0x1ed98b8d00ed78d9ull,          (uint64_t const   )0x878cc5541b15235aull,          (uint64_t const   )0xbdaad05ff19daba8ull,          (uint64_t const   )0x92847c097dfa71e5ull, 
                (uint64_t const   )0x350e0dd9be966d1full,          (uint64_t const   )0xa6a60d7f6f49639cull,          (uint64_t const   )0x8e070da95c30c7b1ull,          (uint64_t const   )0x86cfaab004eeb6baull, 
                (uint64_t const   )0xebaaec50d1c327f4ull,          (uint64_t const   )0xc2fe1876ab524708ull,          (uint64_t const   )0xc6f6d37551ec8e3dull,          (uint64_t const   )0x64d37e4c261b7ceeull, 
                (uint64_t const   )0x5c4238429df044d6ull,          (uint64_t const   )0xffc2dcfba6020f1cull,          (uint64_t const   )0x219884780eb85505ull,          (uint64_t const   )0x7b344c05cf490f3cull, 
                (uint64_t const   )0x6357c42cdd1ece03ull,          (uint64_t const   )0xe843f0447fc918ccull,          (uint64_t const   )0x3f6b9ecca16d6a9cull,          (uint64_t const   )0xcadd7b5fa7f80548ull, 
                (uint64_t const   )0x99932206ba13d48eull,          (uint64_t const   )0x2e2c3d8d923d7498ull,          (uint64_t const   )0x313c5a25c7cc37ecull,          (uint64_t const   )0x1ad15364afedeef6ull, 
                (uint64_t const   )0xfd191a29a2e31a19ull,          (uint64_t const   )0x260efed6924e37c5ull,          (uint64_t const   )0x59131a8c25dde4d2ull,          (uint64_t const   )0x7c21c4dec49fcb54ull, 
                (uint64_t const   )0x7e6ce786fbf85990ull,          (uint64_t const   )0xd9e19bec0755de20ull,          (uint64_t const   )0xbd6610b15f183afbull,          (uint64_t const   )0x8973e87e3a7c8151ull, 
                (uint64_t const   )0x08dc85a2ef21e267ull,          (uint64_t const   )0x8a5d053e38e38217ull,          (uint64_t const   )0x362b10df55d34595ull,          (uint64_t const   )0xec947b5836bd99a6ull, 
                (uint64_t const   )0xa86b61318e8e0669ull,          (uint64_t const   )0x77fb8d13554c503bull,          (uint64_t const   )0x7f2e977aecd4b847ull,          (uint64_t const   )0x1a1209b4297349a0ull, 
                (uint64_t const   )0x246ef6a2583a91d2ull,          (uint64_t const   )0xe899f0f10718bb1bull,          (uint64_t const   )0x8caf1fed80b0bf73ull,          (uint64_t const   )0x6692b681b5b0cd56ull, 
                (uint64_t const   )0x88a59e6e5279a693ull,          (uint64_t const   )0x2bca6fda2127725bull,          (uint64_t const   )0xde231627953ee461ull,          (uint64_t const   )0xa6a84fe6019b1505ull, 
                (uint64_t const   )0x3aa8d5c92821286full,          (uint64_t const   )0x3fc7c4ff83788dc8ull,          (uint64_t const   )0x2f1c86701e11126cull,          (uint64_t const   )0xbcf523cd44449d04ull}, 
     {          (uint64_t const   )0xb6bd2e675553abfbull,          (uint64_t const   )0x0e77d5c32d27b9f1ull,          (uint64_t const   )0x514eeb41d9c3d9ffull,          (uint64_t const   )0x628b101131d29234ull, 
                (uint64_t const   )0x8ffb7c8ed0e68e19ull,          (uint64_t const   )0x8ae2aad5fb090e47ull,          (uint64_t const   )0x189f977852a4f512ull,          (uint64_t const   )0x95ca324d8b0efd83ull, 
                (uint64_t const   )0x738c57e030fdae11ull,          (uint64_t const   )0x959b0a940dd59306ull,          (uint64_t const   )0x65da2016543c234bull,          (uint64_t const   )0x4b832a3630d9185cull, 
                (uint64_t const   )0x0c097ea2fdbf0d2cull,          (uint64_t const   )0xfb4c8e0aa5234704ull,          (uint64_t const   )0x7ac234e158f27179ull,          (uint64_t const   )0xbac5a1e34be49be8ull, 
                (uint64_t const   )0x971437a9f55584bbull,          (uint64_t const   )0x0b936a48e3a2ff38ull,          (uint64_t const   )0xce5064cedf5414ffull,          (uint64_t const   )0xe843d8e0f1a1b404ull, 
                (uint64_t const   )0x94b3ca3bb9a34c7full,          (uint64_t const   )0x2ad9eef539a002e0ull,          (uint64_t const   )0x6775351b325f3972ull,          (uint64_t const   )0x73a452a5d7816842ull, 
                (uint64_t const   )0x8f820c6a3867e2f5ull,          (uint64_t const   )0x195da076e4eb0c03ull,          (uint64_t const   )0xbf06d1e5880ef7e9ull,          (uint64_t const   )0x10194dde08d9bfb5ull, 
                (uint64_t const   )0xc43bf19aac12b322ull,          (uint64_t const   )0xe5574447f21ad4fbull,          (uint64_t const   )0x0022f70230a30040ull,          (uint64_t const   )0xb92a66f9542cc415ull, 
                (uint64_t const   )0x8fbcd882499ec90dull,          (uint64_t const   )0x7d7ee407c482adb5ull,          (uint64_t const   )0xf284329e4afed0eaull,          (uint64_t const   )0xa4a200b66d4b9a8full, 
                (uint64_t const   )0x9d579f70abf43ad5ull,          (uint64_t const   )0x6d99c3c17a861697ull,          (uint64_t const   )0xefdfea41ede917ffull,          (uint64_t const   )0x0dd85b0a545ce9ebull, 
                (uint64_t const   )0x695f389eb81c31c4ull,          (uint64_t const   )0x3e49b5c0ed676305ull,          (uint64_t const   )0x4c0792eaab653521ull,          (uint64_t const   )0xae7febb40ef265f8ull, 
                (uint64_t const   )0x735fd7bae0b300b6ull,          (uint64_t const   )0x5cd2f906d01617fdull,          (uint64_t const   )0xe425e6a2194f35b8ull,          (uint64_t const   )0x5e454d35558f736full, 
                (uint64_t const   )0xd6f7a25040a80510ull,          (uint64_t const   )0x9ff8fd33a560058cull,          (uint64_t const   )0xc7615283555e4d1aull,          (uint64_t const   )0x46403dffc8013c90ull, 
                (uint64_t const   )0x4e4a44a1479e3e2eull,          (uint64_t const   )0xc658ada906c5037bull,          (uint64_t const   )0x54e1529f6a6c0706ull,          (uint64_t const   )0x5a929ed61f0bb3d6ull, 
                (uint64_t const   )0x657aacb5a4eef250ull,          (uint64_t const   )0x8d75f946b56d5c44ull,          (uint64_t const   )0x3852aab719722cbaull,          (uint64_t const   )0xa7e416420eb9da68ull, 
                (uint64_t const   )0x9b7a5005d064dd92ull,          (uint64_t const   )0xeaf7ce1d22dee993ull,          (uint64_t const   )0x34aced1247e27fb8ull,          (uint64_t const   )0xf23478d46ca33d46ull}}, 
   { {          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull}, 
     {          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x6b90680243c4b54cull,          (uint64_t const   )0x044703d57fb1e299ull,          (uint64_t const   )0x8a3c60812c08665aull,          (uint64_t const   )0x32dc7de4cae88a7bull, 
                (uint64_t const   )0x6e3060c4bbed7feeull,          (uint64_t const   )0x09a012c21457c46full,          (uint64_t const   )0x713f791a21ad43caull,          (uint64_t const   )0x5a4d0ec873244cdfull, 
                (uint64_t const   )0x59a713355c986f8full,          (uint64_t const   )0xa347356dba0fbfadull,          (uint64_t const   )0x6650c485ba5b1243ull,          (uint64_t const   )0x2d86094817cc64f2ull, 
                (uint64_t const   )0x20fdc446a93f6201ull,          (uint64_t const   )0x1db9308f0d27dbdfull,          (uint64_t const   )0x98f63ae9645b1111ull,          (uint64_t const   )0x03415b7672cca0bdull, 
                (uint64_t const   )0x910f4a575767cff3ull,          (uint64_t const   )0x5182927aff4f928cull,          (uint64_t const   )0xdde2b660565a30dcull,          (uint64_t const   )0x3f42ec666558c5b3ull, 
                (uint64_t const   )0xce05da712568cac7ull,          (uint64_t const   )0xfd9326b46e518555ull,          (uint64_t const   )0x9334d36563994ecdull,          (uint64_t const   )0x3bd434362a7b358cull, 
                (uint64_t const   )0x14b4d64afc2171bbull,          (uint64_t const   )0x8332f03346030a46ull,          (uint64_t const   )0x56300105aba021c0ull,          (uint64_t const   )0x470610c2fb63b7b5ull, 
                (uint64_t const   )0x10c12cf0c2f837f5ull,          (uint64_t const   )0x7d8af8d403969661ull,          (uint64_t const   )0xa8cb40dbe096915dull,          (uint64_t const   )0xfb306c5498354397ull, 
                (uint64_t const   )0xe25d9ee093992b8bull,          (uint64_t const   )0x1f406a7e77f19817ull,          (uint64_t const   )0x06592044d4d8c7e7ull,          (uint64_t const   )0x986ca3c584c84454ull, 
                (uint64_t const   )0xcec495f755c884f0ull,          (uint64_t const   )0x3d8e0276e94a3fb3ull,          (uint64_t const   )0x6dfc65f711f0e645ull,          (uint64_t const   )0xf04572c328e9c0fdull, 
                (uint64_t const   )0x1de908cfe3f5fc3bull,          (uint64_t const   )0xe1e609e5214fc6f0ull,          (uint64_t const   )0x1b97e198798ccc46ull,          (uint64_t const   )0x52983c479b769f0dull, 
                (uint64_t const   )0xe1ad316c24a875e2ull,          (uint64_t const   )0x759a9b5ac9742a91ull,          (uint64_t const   )0x6bb1e5f7b2bb7e47ull,          (uint64_t const   )0xbdd56e8cc40b30baull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull, 
                (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull,          (uint64_t const   )0x0000000000000000ull}, 
     {          (uint64_t const   )0xe543c7cd3569a2d2ull,          (uint64_t const   )0x56312cb746ff2365ull,          (uint64_t const   )0x03e7298e5b86bf22ull,          (uint64_t const   )0x516e9a17bf3b9d0eull, 
                (uint64_t const   )0xb507b363062bfe41ull,          (uint64_t const   )0x7600192a061dd0e5ull,          (uint64_t const   )0x1d3fdfd7ab7ed9eeull,          (uint64_t const   )0x422f696efd2a98f8ull, 
                (uint64_t const   )0x4d3652c8c76f687cull,          (uint64_t const   )0x9f7711eae210b999ull,          (uint64_t const   )0x3fe55a4a3db93342ull,          (uint64_t const   )0xf9867077d2c22292ull, 
                (uint64_t const   )0x06938ebd5352aba1ull,          (uint64_t const   )0xcfbdf8fd28e52d4aull,          (uint64_t const   )0x9f5dc89b771ea0baull,          (uint64_t const   )0x76170ff911d3d955ull, 
                (uint64_t const   )0x7e7bddf4e7d92fadull,          (uint64_t const   )0x28bb97717bb86c3full,          (uint64_t const   )0xe14b10911730bfe5ull,          (uint64_t const   )0x65fdc8cfbb000784ull, 
                (uint64_t const   )0x3413b92f048583c8ull,          (uint64_t const   )0x449ccb9483380adcull,          (uint64_t const   )0xa4a34f7dd630cec5ull,          (uint64_t const   )0xf23142fcbf290710ull, 
                (uint64_t const   )0xab1645e0b73ebeb6ull,          (uint64_t const   )0x9f7ac648b66b58efull,          (uint64_t const   )0x81da786a8e1a3a07ull,          (uint64_t const   )0xab80b2cb27644d91ull, 
                (uint64_t const   )0xc57b0159cd1cf77aull,          (uint64_t const   )0x84425693d1e998f6ull,          (uint64_t const   )0xa086ad9f1b17e973ull,          (uint64_t const   )0x6c29c7100c6ea19bull, 
                (uint64_t const   )0x3a318a14b98d372bull,          (uint64_t const   )0xf01ba582f9382406ull,          (uint64_t const   )0xa1cde875f370ae9cull,          (uint64_t const   )0xb9a0ab780158707eull, 
                (uint64_t const   )0x8d26ff790475117eull,          (uint64_t const   )0xdd33f98a55e26ad9ull,          (uint64_t const   )0x549c9afccdff9451ull,          (uint64_t const   )0xfed35e6c20eabe08ull, 
                (uint64_t const   )0xee602ea3d3b08637ull,          (uint64_t const   )0xfb60f74da1a791f3ull,          (uint64_t const   )0xb25a86f4ba75b20eull,          (uint64_t const   )0x5402f6bd8285b194ull, 
                (uint64_t const   )0xb5e9f6533809151full,          (uint64_t const   )0x074c656721f3bb77ull,          (uint64_t const   )0x5ccdeff9d4bbbf2dull,          (uint64_t const   )0xbe262f406756394dull, 
                (uint64_t const   )0x105f0a553888caadull,          (uint64_t const   )0xb364c84f9a7f366dull,          (uint64_t const   )0x13c5a20c72a2e3ceull,          (uint64_t const   )0xb6121d22131c0104ull, 
                (uint64_t const   )0xa4cb87927ec6cc17ull,          (uint64_t const   )0x897b31544122583bull,          (uint64_t const   )0xd9bed4853c502a78ull,          (uint64_t const   )0x211fee372e06645full, 
                (uint64_t const   )0x87d38f49fd841678ull,          (uint64_t const   )0x22644edaa636120aull,          (uint64_t const   )0x693c919475426cccull,          (uint64_t const   )0x77b3666bd380005dull, 
                (uint64_t const   )0x09972e5b72ba54c1ull,          (uint64_t const   )0xa6d576eb8a9adbefull,          (uint64_t const   )0x151e128a1470cc43ull,          (uint64_t const   )0xba872ea0ccbcac7cull}, 
     {          (uint64_t const   )0xfaadf26b0bedcb90ull,          (uint64_t const   )0x577ac5a51e5651c5ull,          (uint64_t const   )0xfaa9928d90ecc574ull,          (uint64_t const   )0xf4d0746e2cd9c2cbull, 
                (uint64_t const   )0x297b213cebe4451bull,          (uint64_t const   )0xdcda00e8a1970957ull,          (uint64_t const   )0xebc24328279cf3c0ull,          (uint64_t const   )0xafbc7b8a2782f71aull, 
                (uint64_t const   )0x2b8ae9d228a44b14ull,          (uint64_t const   )0x7b91361891e74156ull,          (uint64_t const   )0x7c744bd7713ebc3cull,          (uint64_t const   )0xf30ff94d8ae2dbbcull, 
                (uint64_t const   )0x952d28d81c4cd5e5ull,          (uint64_t const   )0xca1da973d1bb1a14ull,          (uint64_t const   )0x0dc59391a4b26780ull,          (uint64_t const   )0x73974085e2ebdfedull, 
                (uint64_t const   )0x6a9d797790afccadull,          (uint64_t const   )0x192a2b602b123aabull,          (uint64_t const   )0x19c8a787015bc845ull,          (uint64_t const   )0xad40920248a2e551ull, 
                (uint64_t const   )0xd1c0fbdcb077da5dull,          (uint64_t const   )0xf0d3a2e4b44b9030ull,          (uint64_t const   )0x4ff44c34da7b4dd0ull,          (uint64_t const   )0x65ca4e0e02964227ull, 
                (uint64_t const   )0x1fc804c725e40440ull,          (uint64_t const   )0xde8e75b6789090ffull,          (uint64_t const   )0xda82400db9d07a0aull,          (uint64_t const   )0x7f850c159d730e8dull, 
                (uint64_t const   )0x88f3cb3c8b5dbf18ull,          (uint64_t const   )0xaa16f0d4828d0050ull,          (uint64_t const   )0x46a26a52fc055ad2ull,          (uint64_t const   )0x9924d71d3d7359bfull, 
                (uint64_t const   )0x73580533d9f2fb99ull,          (uint64_t const   )0x187096a491259118ull,          (uint64_t const   )0x7777434ec63d90f8ull,          (uint64_t const   )0x8e6e9922b252bdb1ull, 
                (uint64_t const   )0xb1af461d516eee12ull,          (uint64_t const   )0x4fcd31f2f421c717ull,          (uint64_t const   )0x65651bc93644c5e1ull,          (uint64_t const   )0x9bd1e1fa908307daull, 
                (uint64_t const   )0x5aaee550208ae7f0ull,          (uint64_t const   )0x4ec958544caaa9c3ull,          (uint64_t const   )0x298e4a3f09caee63ull,          (uint64_t const   )0x29d4a3cab10a9a44ull, 
                (uint64_t const   )0x9e6a3fde44907510ull,          (uint64_t const   )0x19cc5ee9aa4fbc78ull,          (uint64_t const   )0xc01a289fe006387full,          (uint64_t const   )0x3ee6737f5f934fb3ull, 
                (uint64_t const   )0x65fad64d232fe9eeull,          (uint64_t const   )0x2a487fc2e4f569fbull,          (uint64_t const   )0x67fb5df086391215ull,          (uint64_t const   )0xc1b5e63af64d55e8ull, 
                (uint64_t const   )0xd33f764f4052ecb7ull,          (uint64_t const   )0x0899d25e2b391f79ull,          (uint64_t const   )0xc70158cce44d2e70ull,          (uint64_t const   )0xb53262e2308fa659ull, 
                (uint64_t const   )0x20f7402ecd84404cull,          (uint64_t const   )0x15d1b9bb5466ad4cull,          (uint64_t const   )0xfd8d825e26a8a2d1ull,          (uint64_t const   )0x18d96f18f8b826d0ull, 
                (uint64_t const   )0xf72067659687ef21ull,          (uint64_t const   )0xf08610bafd66009full,          (uint64_t const   )0x1a4e1ba1fdb05563ull,          (uint64_t const   )0x1324d44c84bbef0aull}, 
     {          (uint64_t const   )0xc7613d66f20232d4ull,          (uint64_t const   )0x3ede983f7b06516bull,          (uint64_t const   )0x578460a649b24a39ull,          (uint64_t const   )0xd5bd4ad2cc618853ull, 
                (uint64_t const   )0x6da1e9f12833259cull,          (uint64_t const   )0x1f9ca81ea33005a0ull,          (uint64_t const   )0xae981ca25036ed10ull,          (uint64_t const   )0x5d69e428228cca9aull, 
                (uint64_t const   )0xa17023dd34f22effull,          (uint64_t const   )0xd08c493917325f88ull,          (uint64_t const   )0x79e16b54bdca7e02ull,          (uint64_t const   )0x3654be3ac3a26289ull, 
                (uint64_t const   )0xac56a76157fd0921ull,          (uint64_t const   )0xc517aa54a54ed12dull,          (uint64_t const   )0x4dd1b68eb1ada829ull,          (uint64_t const   )0x161037898e176e8dull, 
                (uint64_t const   )0x98db096afb729bebull,          (uint64_t const   )0x03e9d68eabc9d7feull,          (uint64_t const   )0xdf27c2fb173845dcull,          (uint64_t const   )0x2aee2474d7bf2d7cull, 
                (uint64_t const   )0xf5d6d12955e96f2dull,          (uint64_t const   )0xf734ec0a2d041943ull,          (uint64_t const   )0x72999224bb580060ull,          (uint64_t const   )0xccdcad5bdc7bd1a1ull, 
                (uint64_t const   )0xa9bca8004f1d7086ull,          (uint64_t const   )0xc2c7ffb795d4e1e7ull,          (uint64_t const   )0xd28da598cbfbc3caull,          (uint64_t const   )0x08126a5da13c42d9ull, 
                (uint64_t const   )0x13e15ad5c2d3d951ull,          (uint64_t const   )0x4d9c20c7eaa8703dull,          (uint64_t const   )0xab894b4e6ebca682ull,          (uint64_t const   )0x53214a10ad7c784eull, 
                (uint64_t const   )0x9906d6c9c38b591eull,          (uint64_t const   )0x476bd91a4ca0c161ull,          (uint64_t const   )0x95265cbe69f01d02ull,          (uint64_t const   )0x01cedc5a39e5b5c9ull, 
                (uint64_t const   )0xc0ef0788f08d9463ull,          (uint64_t const   )0x80927db966612b20ull,          (uint64_t const   )0x9630082145dd2f1eull,          (uint64_t const   )0x600f737ed7910113ull, 
                (uint64_t const   )0xb9302c026f2a80b2ull,          (uint64_t const   )0xff49c8f0afc01a91ull,          (uint64_t const   )0x39a0b9dbbc8e5d10ull,          (uint64_t const   )0x4e93e5fbc38cafd7ull, 
                (uint64_t const   )0x44d0aec75c666288ull,          (uint64_t const   )0x5ea41ef6508a97efull,          (uint64_t const   )0x6ce58a3a4917dffdull,          (uint64_t const   )0x57b84b8764d3da3dull, 
                (uint64_t const   )0xedf320cbe664658cull,          (uint64_t const   )0x3bea7e195d96172aull,          (uint64_t const   )0x72abd9c2b876c142ull,          (uint64_t const   )0xaf2ce404a46dae6eull, 
                (uint64_t const   )0x4f050de918e728b2ull,          (uint64_t const   )0xcb458cba72881a48ull,          (uint64_t const   )0xdadcfcb48f1c02a8ull,          (uint64_t const   )0x1167bf4ccb9f1a34ull, 
                (uint64_t const   )0x2f791f047047bd5dull,          (uint64_t const   )0xcd60c5789e26b8b6ull,          (uint64_t const   )0x1a620288f4a12b4bull,          (uint64_t const   )0x1b43a4a5b7f5244dull, 
                (uint64_t const   )0x3a93e22c7f6b3c55ull,          (uint64_t const   )0xa5da9b1ba501f044ull,          (uint64_t const   )0xac918f8b4d9d1e00ull,          (uint64_t const   )0x9fba7867a63c8ac8ull}, 
     {          (uint64_t const   )0xb5663909d9d6303aull,          (uint64_t const   )0x1122bbd8f31a9801ull,          (uint64_t const   )0xb26dfdc7254c0ac9ull,          (uint64_t const   )0x80923ffe2bae8db2ull, 
                (uint64_t const   )0xdf3939952977e95full,          (uint64_t const   )0x89ef22889d7081a6ull,          (uint64_t const   )0xddeeb25f2e41e526ull,          (uint64_t const   )0x77aa072d06890a48ull, 
                (uint64_t const   )0x8b1e7a1bc43beb1cull,          (uint64_t const   )0xeef27b1803a60f3aull,          (uint64_t const   )0x116569c8ba82a83aull,          (uint64_t const   )0x861eddf3fdf4d64full, 
                (uint64_t const   )0x12fc5033c7c95105ull,          (uint64_t const   )0xc9997d1a2f05161aull,          (uint64_t const   )0x56dbac3597f7e48bull,          (uint64_t const   )0x997968b0dadb71b6ull, 
                (uint64_t const   )0x51c153dd787cf748ull,          (uint64_t const   )0x190b253068b60e60ull,          (uint64_t const   )0xa98dcc93091ee1daull,          (uint64_t const   )0xe7f1c48a17f0c994ull, 
                (uint64_t const   )0x294532d1f3b50a20ull,          (uint64_t const   )0xe393a663d106d4b2ull,          (uint64_t const   )0xc95a8e15d4e4aac2ull,          (uint64_t const   )0x058a1a4819387af4ull, 
                (uint64_t const   )0xb7fe4077025d3331ull,          (uint64_t const   )0x17369b1ad4dfb135ull,          (uint64_t const   )0xfd1836fd44897416ull,          (uint64_t const   )0x734f98ea7a95ea1dull, 
                (uint64_t const   )0x44dbebde2de33051ull,          (uint64_t const   )0x3e572ff979d8ca38ull,          (uint64_t const   )0xd53c5a45bb8cdfa1ull,          (uint64_t const   )0x1169ade998830992ull, 
                (uint64_t const   )0xc6b5b477d2ee43b5ull,          (uint64_t const   )0x11d58b895af5f73aull,          (uint64_t const   )0xcfe3985db2d35d21ull,          (uint64_t const   )0xc9c6056490e28221ull, 
                (uint64_t const   )0xbba44fb18d7bad4cull,          (uint64_t const   )0xd1b94354c3d22c4dull,          (uint64_t const   )0xfb0d0d4c55eedddeull,          (uint64_t const   )0x3b18e9ef00b4c810ull, 
                (uint64_t const   )0x73e101f840df8084ull,          (uint64_t const   )0xd64f148443724752ull,          (uint64_t const   )0xb017cbfb12688bd6ull,          (uint64_t const   )0x89e6a53131fc7242ull, 
                (uint64_t const   )0x2f6bc2d724af9792ull,          (uint64_t const   )0x1af46d6374011c6aull,          (uint64_t const   )0xe7d461f15c6129b4ull,          (uint64_t const   )0xbd7b0f8478d446abull, 
                (uint64_t const   )0x8cab2463b6c0e01dull,          (uint64_t const   )0xa69dee16a765d2b0ull,          (uint64_t const   )0x144588401f496bf3ull,          (uint64_t const   )0x3d761d20063ee258ull, 
                (uint64_t const   )0x48c0b32df8ddc0fbull,          (uint64_t const   )0x1ad8889a5aa8e26cull,          (uint64_t const   )0x2aadb6180f80c2d3ull,          (uint64_t const   )0xb7c9d582a54c0b2cull, 
                (uint64_t const   )0xa9448d0f698b8370ull,          (uint64_t const   )0xd6814d04b2584c63ull,          (uint64_t const   )0x80576b83319d83f9ull,          (uint64_t const   )0x906953398a3df494ull, 
                (uint64_t const   )0xe7a11b9d7d769494ull,          (uint64_t const   )0x59714b37b93b5e39ull,          (uint64_t const   )0xa5280a61ef2d0450ull,          (uint64_t const   )0xcaf1ca6cd004e7bcull}, 
     {          (uint64_t const   )0x0c92df7ab48210acull,          (uint64_t const   )0x70c766782c6225c0ull,          (uint64_t const   )0x2b627e280a8dd01full,          (uint64_t const   )0xf8a95606e064f51bull, 
                (uint64_t const   )0xecb6d461dd6c8568ull,          (uint64_t const   )0xe8e9d8da88a760e7ull,          (uint64_t const   )0xb253ddc5e1b54ff4ull,          (uint64_t const   )0xb518eacb142499c5ull, 
                (uint64_t const   )0x5ba23807ace2576bull,          (uint64_t const   )0xb5d274ebd42fcb9cull,          (uint64_t const   )0x1dfc510cd7016641ull,          (uint64_t const   )0x81b2aa898d7ff740ull, 
                (uint64_t const   )0xb3f8b22a412d350full,          (uint64_t const   )0x9010d26bd30013d6ull,          (uint64_t const   )0x31a160801ed3585full,          (uint64_t const   )0xf18717011ddb123bull, 
                (uint64_t const   )0x475fb6cd262d3895ull,          (uint64_t const   )0xf86a9bada37fe981ull,          (uint64_t const   )0x579fe8f10c63060cull,          (uint64_t const   )0x1ea46e3bcbee6f47ull, 
                (uint64_t const   )0x0dfa846a5626e47aull,          (uint64_t const   )0xe76ff8e4aab118a0ull,          (uint64_t const   )0xa83a45a05758d1c4ull,          (uint64_t const   )0xff293f1d1de94a79ull, 
                (uint64_t const   )0x6d34106328ce50acull,          (uint64_t const   )0x7f3dd6bb2c715f0dull,          (uint64_t const   )0x01a6483cc3fb62c0ull,          (uint64_t const   )0xa60927ade8ccdca7ull, 
                (uint64_t const   )0x73c1dc8d32c0180full,          (uint64_t const   )0x02f86bcc14474ff9ull,          (uint64_t const   )0x3804de0c37c58434ull,          (uint64_t const   )0xfc10f3a3c497c54dull, 
                (uint64_t const   )0x96a1e55142ddb8dbull,          (uint64_t const   )0xc92548d8939af17aull,          (uint64_t const   )0xbc5edf6509acaf89ull,          (uint64_t const   )0xac0b9688d3023544ull, 
                (uint64_t const   )0x4163dbff847088b3ull,          (uint64_t const   )0x563f3cfce243d3f8ull,          (uint64_t const   )0x8f263f7ce1f7b3ccull,          (uint64_t const   )0xe7365cbc6a7f8730ull, 
                (uint64_t const   )0x46c1f063e6b8ca39ull,          (uint64_t const   )0x21cbc42ba4582264ull,          (uint64_t const   )0x55dff0476966e4b4ull,          (uint64_t const   )0x223e2c38b61edc4eull, 
                (uint64_t const   )0x3a21ced28a3d6fa8ull,          (uint64_t const   )0xd5884ee48c058d27ull,          (uint64_t const   )0x884d4eac614c987aull,          (uint64_t const   )0x02327b02f1a6a37full, 
                (uint64_t const   )0xec14f49f926b0d1dull,          (uint64_t const   )0xad980ec0c9b3ccdcull,          (uint64_t const   )0xad0f89f58a31f96cull,          (uint64_t const   )0x1004ad6869a8c64dull, 
                (uint64_t const   )0x73334f7053ecda9cull,          (uint64_t const   )0xe5c726eb2395f91full,          (uint64_t const   )0x3eacccee6b0d2cf0ull,          (uint64_t const   )0x54fe44475c2803fbull, 
                (uint64_t const   )0x4e691ecbfdff4c35ull,          (uint64_t const   )0x0d4dd3188efdf8f3ull,          (uint64_t const   )0x4ce513f999517686ull,          (uint64_t const   )0x451033ddedb79722ull, 
                (uint64_t const   )0x7fafe619290cf26eull,          (uint64_t const   )0xb744be4992d915b4ull,          (uint64_t const   )0x8011bf394690d8d1ull,          (uint64_t const   )0x9475361b15b45cd5ull}}};
#line 364 "data.c"
uint64_t const   castle_random[2][2]  = { {        (uint64_t const   )0x557723689550b69bull,        (uint64_t const   )0xa92c541efa336c6cull}, 
   {        (uint64_t const   )0xc7bedab779d5361bull,        (uint64_t const   )0x3bb70e80435e60b7ull}};
#line 368 "data.c"
uint64_t const   enpassant_random[65]  = 
#line 368
  {      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0xf2c1412f44c13c98ull,      (uint64_t const   )0x76b4b7ccb0c9bd1eull,      (uint64_t const   )0x0303f047ef3166cdull,      (uint64_t const   )0xcf4da3850ff5c35aull, 
        (uint64_t const   )0x0bb57340632ec140ull,      (uint64_t const   )0x189156c368616498ull,      (uint64_t const   )0x71b862b8cede277dull,      (uint64_t const   )0x26e0433817e6d7d7ull, 
        (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0x1f2af0448165ab3aull,      (uint64_t const   )0x51f0d423276d44dbull,      (uint64_t const   )0x12d51a6ba742f661ull,      (uint64_t const   )0x8fa3e91c53630e1full, 
        (uint64_t const   )0x16573a4eb7f48c08ull,      (uint64_t const   )0xe1c1e4bc9690e409ull,      (uint64_t const   )0x5f2bf4422dde33bbull,      (uint64_t const   )0xcd4cefba64f407a1ull, 
        (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull,      (uint64_t const   )0x0000000000000000ull, 
        (uint64_t const   )0x0000000000000000ull};
#line 402 "data.c"
uint64_t const   OO[2]  = {      (uint64_t const   )0x6000000000000000ull,      (uint64_t const   )0x0000000000000060ull};
#line 403 "data.c"
uint64_t const   OOO[2]  = {      (uint64_t const   )0x0E00000000000000ull,      (uint64_t const   )0x000000000000000Eull};
#line 404 "data.c"
unsigned long const   mask_efgh  =    (uint64_t const   )0xf0f0f0f0f0f0f0f0ull;
#line 405 "data.c"
unsigned long const   mask_fgh  =    (uint64_t const   )0xe0e0e0e0e0e0e0e0ull;
#line 406 "data.c"
unsigned long const   mask_abc  =    (uint64_t const   )0x0707070707070707ull;
#line 407 "data.c"
unsigned long const   mask_abcd  =    (uint64_t const   )0x0f0f0f0f0f0f0f0full;
#line 408 "data.c"
unsigned long const   mask_advance_2_w  =    (uint64_t const   )0x0000000000ff0000ull;
#line 409 "data.c"
unsigned long const   mask_advance_2_b  =    (uint64_t const   )0x0000ff0000000000ull;
#line 410 "data.c"
unsigned long const   mask_left_edge  =    (uint64_t const   )0xfefefefefefefefeull;
#line 411 "data.c"
unsigned long const   mask_right_edge  =    (uint64_t const   )0x7f7f7f7f7f7f7f7full;
#line 412 "data.c"
unsigned long const   mask_not_edge  =    (uint64_t const   )0x007e7e7e7e7e7e00ull;
#line 413 "data.c"
unsigned long const   mask_rook_files  =    (uint64_t const   )0x8181818181818181ull;
#line 414 "data.c"
unsigned long const   dark_squares  =    (uint64_t const   )0xaa55aa55aa55aa55ull;
#line 415 "data.c"
unsigned long const   not_rook_pawns  =    (uint64_t const   )0x007e7e7e7e7e7e00ull;
#line 440 "data.c"
int const   OOsqs[2][3]  = { {        (int const   )60,        (int const   )61,        (int const   )62}, 
   {        (int const   )4,        (int const   )5,        (int const   )6}};
#line 441 "data.c"
int const   OOOsqs[2][3]  = { {        (int const   )60,        (int const   )59,        (int const   )58}, 
   {        (int const   )4,        (int const   )3,        (int const   )2}};
#line 442 "data.c"
int const   OOfrom[2]  = {      (int const   )60,      (int const   )4};
#line 443 "data.c"
int const   OOto[2]  = {      (int const   )62,      (int const   )6};
#line 444 "data.c"
int const   OOOto[2]  = {      (int const   )58,      (int const   )2};
#line 446 "data.c"
char version[8]  = {      (char )'2',      (char )'5',      (char )'.',      (char )'2', 
        (char )'\000'};
#line 447 "data.c"
PLAYING_MODE mode  =    (PLAYING_MODE )0;
#line 448 "data.c"
int batch_mode  =    0;
#line 449 "data.c"
int swindle_mode  =    1;
#line 450 "data.c"
int call_flag  =    0;
#line 451 "data.c"
int crafty_rating  =    2500;
#line 452 "data.c"
int opponent_rating  =    2500;
#line 453 "data.c"
int last_search_value  =    0;
#line 454 "data.c"
int FP_margin[16]  = 
#line 454
  {      0,      100,      150,      200, 
        250,      300,      400,      500, 
        600,      700,      800,      900, 
        1000,      1100,      1200,      1300};
#line 456 "data.c"
int FP_depth  =    7;
#line 458 "data.c"
int LMP_depth  =    16;
#line 459 "data.c"
int LMP_base  =    3;
#line 460 "data.c"
double LMP_scale  =    1.9;
#line 461 "data.c"
int pgn_suggested_percent  =    0;
#line 462 "data.c"
char pgn_event[128]  = {      (char )'?',      (char )'\000'};
#line 463 "data.c"
char pgn_site[128]  = {      (char )'?',      (char )'\000'};
#line 464 "data.c"
char pgn_date[128]  = 
#line 464
  {      (char )'?',      (char )'?',      (char )'?',      (char )'?', 
        (char )'.',      (char )'?',      (char )'?',      (char )'.', 
        (char )'?',      (char )'?',      (char )'\000'};
#line 465 "data.c"
char pgn_round[128]  = {      (char )'?',      (char )'\000'};
#line 466 "data.c"
char pgn_white[128]  = 
#line 466
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )'\000'};
#line 467 "data.c"
char pgn_white_elo[128]  = {      (char )'\000'};
#line 468 "data.c"
char pgn_black[128]  = 
#line 468
  {      (char )'C',      (char )'r',      (char )'a',      (char )'f', 
        (char )'t',      (char )'y',      (char )' ',      (char )'2', 
        (char )'5',      (char )'.',      (char )'2',      (char )'\000'};
#line 469 "data.c"
char pgn_black_elo[128]  = {      (char )'\000'};
#line 470 "data.c"
char pgn_result[128]  = {      (char )'*',      (char )'\000'};
#line 478 "data.c"
int output_format  =    0;
#line 480 "data.c"
int EGTBlimit  =    0;
#line 481 "data.c"
int EGTB_use  =    0;
#line 482 "data.c"
int EGTB_draw  =    0;
#line 483 "data.c"
int EGTB_depth  =    0;
#line 484 "data.c"
size_t EGTB_cache_size  =    (size_t )16777216;
#line 485 "data.c"
void *EGTB_cache  =    (void *)0;
#line 486 "data.c"
int EGTB_setup  =    0;
#line 488 "data.c"
int xboard  =    0;
#line 489 "data.c"
int xboard_done  =    0;
#line 490 "data.c"
int pong  =    0;
#line 491 "data.c"
int early_exit  =    99;
#line 492 "data.c"
char book_path[128]  = {      (char )'.',      (char )'\000'};
#line 493 "data.c"
char log_path[128]  = {      (char )'.',      (char )'\000'};
#line 494 "data.c"
char tb_path[128]  = 
#line 494
  {      (char )'.',      (char )'/',      (char )'s',      (char )'y', 
        (char )'z',      (char )'y',      (char )'g',      (char )'y', 
        (char )'\000'};
#line 495 "data.c"
char rc_path[128]  = {      (char )'.',      (char )'\000'};
#line 496 "data.c"
int initialized  =    0;
#line 497 "data.c"
int kibitz  =    0;
#line 498 "data.c"
int post  =    0;
#line 499 "data.c"
int log_id  =    1;
#line 500 "data.c"
int game_wtm  =    1;
#line 501 "data.c"
int last_opponent_move  =    0;
#line 502 "data.c"
int check_depth  =    1;
#line 503 "data.c"
int null_depth  =    3;
#line 504 "data.c"
int null_divisor  =    6;
#line 505 "data.c"
int LMR_rdepth  =    1;
#line 506 "data.c"
int LMR_min  =    1;
#line 507 "data.c"
int LMR_max  =    15;
#line 508 "data.c"
double LMR_db  =    1.8;
#line 509 "data.c"
double LMR_mb  =    1.0;
#line 510 "data.c"
double LMR_s  =    2.0;
#line 513 "data.c"
int search_depth  =    0;
#line 514 "data.c"
uint64_t search_nodes  =    (uint64_t )0;
#line 515 "data.c"
uint64_t temp_search_nodes  =    (uint64_t )0;
#line 516 "data.c"
int search_move  =    0;
#line 517 "data.c"
int predicted  =    0;
#line 518 "data.c"
int time_used  =    0;
#line 519 "data.c"
int time_used_opponent  =    0;
#line 520 "data.c"
int analyze_mode  =    0;
#line 521 "data.c"
int annotate_mode  =    0;
#line 522 "data.c"
int input_status  =    0;
#line 523 "data.c"
int resign  =    9;
#line 524 "data.c"
int resign_counter  =    0;
#line 525 "data.c"
int resign_count  =    5;
#line 526 "data.c"
int draw_counter  =    0;
#line 527 "data.c"
int draw_count  =    5;
#line 528 "data.c"
int draw_offer_pending  =    0;
#line 529 "data.c"
int draw_offered  =    0;
#line 530 "data.c"
int offer_draws  =    1;
#line 531 "data.c"
int dynamic_draw_score  =    1;
#line 532 "data.c"
int adaptive_hash  =    0;
#line 533 "data.c"
size_t adaptive_hash_min  =    (size_t )0;
#line 534 "data.c"
size_t adaptive_hash_max  =    (size_t )0;
#line 535 "data.c"
size_t adaptive_hashp_min  =    (size_t )0;
#line 536 "data.c"
size_t adaptive_hashp_max  =    (size_t )0;
#line 537 "data.c"
int time_limit  =    100;
#line 538 "data.c"
int force  =    0;
#line 539 "data.c"
char initial_position[80]  = {      (char )'\000'};
#line 540 "data.c"
char ponder_text[512]  = {      (char )'\000'};
#line 541 "data.c"
char book_hint[512]  = {      (char )'\000'};
#line 542 "data.c"
int over  =    0;
#line 543 "data.c"
int usage_level  =    0;
#line 544 "data.c"
char audible_alarm  =    (char)7;
#line 545 "data.c"
char speech  =    (char)0;
#line 546 "data.c"
int book_accept_mask  =    ~ 03;
#line 547 "data.c"
int book_reject_mask  =    3;
#line 548 "data.c"
int book_random  =    1;
#line 549 "data.c"
float book_weight_learn  =    (float )1.0;
#line 550 "data.c"
float book_weight_freq  =    (float )1.0;
#line 551 "data.c"
float book_weight_eval  =    (float )0.1;
#line 552 "data.c"
int book_search_trigger  =    20;
#line 553 "data.c"
int learn  =    1;
#line 554 "data.c"
int learning  =    100;
#line 555 "data.c"
int learn_value  =    0;
#line 558 "data.c"
int root_wtm  =    1;
#line 566 "data.c"
int quit  =    0;
#line 579 "data.c"
unsigned int smp_max_threads  =    0U;
#line 580 "data.c"
unsigned int smp_split_group  =    8U;
#line 581 "data.c"
unsigned int smp_split_at_root  =    1U;
#line 582 "data.c"
unsigned int smp_min_split_depth  =    5U;
#line 583 "data.c"
unsigned int smp_gratuitous_depth  =    10U;
#line 584 "data.c"
unsigned int smp_gratuitous_limit  =    6U;
#line 585 "data.c"
int smp_nice  =    1;
#line 586 "data.c"
int smp_affinity  =    0;
#line 587 "data.c"
int smp_affinity_increment  =    1;
#line 591 "data.c"
int smp_numa  =    0;
#line 603 "data.c"
int autotune_params  =    4;
#line 604 "data.c"
struct autotune tune[16]  = {      {4U, 20U, 4U, {(char )'m', (char )'a', (char )'x', (char )' ', (char )'t', (char )'h',
                    (char )'r', (char )'e', (char )'a', (char )'d', (char )' ', (char )'g',
                    (char )'r', (char )'o', (char )'u', (char )'p', (char )'\000'},
      {(char )'s', (char )'m', (char )'p', (char )'g', (char )'r', (char )'o', (char )'u',
       (char )'p', (char )'\000'}, & smp_split_group}, 
        {4U, 8U, 1U, {(char )'m', (char )'i', (char )'n', (char )' ', (char )'s', (char )'p',
                   (char )'l', (char )'i', (char )'t', (char )' ', (char )'d', (char )'e',
                   (char )'p', (char )'t', (char )'h', (char )'\000'}, {(char )'s',
                                                                        (char )'m',
                                                                        (char )'p',
                                                                        (char )'m',
                                                                        (char )'i',
                                                                        (char )'n',
                                                                        (char )'\000'},
      & smp_min_split_depth}, 
        {10U, 16U, 2U, {(char )'m', (char )'i', (char )'n', (char )' ', (char )'g', (char )'r',
                     (char )'a', (char )'t', (char )'u', (char )'i', (char )'t', (char )'o',
                     (char )'u', (char )'s', (char )' ', (char )'s', (char )'p', (char )'l',
                     (char )'i', (char )'t', (char )' ', (char )'d', (char )'e', (char )'p',
                     (char )'t', (char )'h', (char )'\000'}, {(char )'s', (char )'m',
                                                              (char )'p', (char )'g',
                                                              (char )'s', (char )'d',
                                                              (char )'\000'}, & smp_gratuitous_depth}, 
        {1U, 8U, 2U, {(char )'g', (char )'r', (char )'a', (char )'t', (char )'u', (char )'i',
                   (char )'t', (char )'o', (char )'u', (char )'s', (char )' ', (char )'s',
                   (char )'p', (char )'l', (char )'i', (char )'t', (char )' ', (char )'l',
                   (char )'i', (char )'m', (char )'i', (char )'t', (char )'\000'},
      {(char )'s', (char )'m', (char )'p', (char )'g', (char )'s', (char )'l', (char )'\000'},
      & smp_gratuitous_limit}};
#line 614 "data.c"
unsigned int busy_percent  =    0U;
#line 615 "data.c"
uint64_t game_max_blocks  =    (uint64_t )0;
#line 616 "data.c"
int volatile   smp_split  =    (int volatile   )0;
#line 617 "data.c"
int volatile   smp_threads  =    (int volatile   )0;
#line 618 "data.c"
int volatile   initialized_threads  =    (int volatile   )0;
#line 619 "data.c"
int crafty_is_white  =    0;
#line 620 "data.c"
unsigned int nodes_between_time_checks  =    1000000U;
#line 621 "data.c"
unsigned int nodes_per_second  =    1000000U;
#line 622 "data.c"
int next_time_check  =    100000;
#line 623 "data.c"
int transposition_age  =    0;
#line 624 "data.c"
int thinking  =    0;
#line 625 "data.c"
int pondering  =    0;
#line 626 "data.c"
int puzzling  =    0;
#line 627 "data.c"
int booking  =    0;
#line 644 "data.c"
int display_options  =    2107;
#line 645 "data.c"
unsigned int noise_level  =    100U;
#line 646 "data.c"
int noise_block  =    0;
#line 647 "data.c"
int tc_moves  =    60;
#line 648 "data.c"
int tc_time  =    180000;
#line 649 "data.c"
int tc_time_remaining[2]  = {      180000,      180000};
#line 650 "data.c"
int tc_moves_remaining[2]  = {      60,      60};
#line 651 "data.c"
int tc_secondary_moves  =    30;
#line 652 "data.c"
int tc_secondary_time  =    90000;
#line 653 "data.c"
int tc_increment  =    0;
#line 654 "data.c"
int tc_sudden_death  =    0;
#line 655 "data.c"
int tc_safety_margin  =    0;
#line 656 "data.c"
int draw_score[2]  = {      0,      0};
#line 659 "data.c"
int move_number  =    1;
#line 660 "data.c"
int moves_out_of_book  =    0;
#line 661 "data.c"
int first_nonbook_factor  =    0;
#line 662 "data.c"
int first_nonbook_span  =    0;
#line 666 "data.c"
int show_book  =    0;
#line 667 "data.c"
int book_selection_width  =    5;
#line 668 "data.c"
int ponder  =    1;
#line 669 "data.c"
int trace_level  =    0;
#line 672 "data.c"
size_t hash_table_size  =    (size_t )(1ull << 20);
#line 673 "data.c"
uint64_t hash_mask  =    (uint64_t )(((1ull << 20) - 1ULL) & 18446744073709551612ULL);
#line 674 "data.c"
size_t hash_path_size  =    (size_t )(1ull << 16);
#line 675 "data.c"
uint64_t hash_path_mask  =    (uint64_t )(((1ull << 16) - 1ULL) & 18446744073709551600ULL);
#line 676 "data.c"
size_t pawn_hash_table_size  =    (size_t )(1ull << 18);
#line 677 "data.c"
uint64_t pawn_hash_mask  =    (uint64_t )((1ull << 18) - 1ULL);
#line 678 "data.c"
uint64_t mask_clear_entry  =    (uint64_t )0xff9ffffffffe0000ull;
#line 679 "data.c"
int abs_draw_score  =    0;
#line 680 "data.c"
int accept_draws  =    1;
#line 681 "data.c"
char const   translate[13]  = 
#line 681
  {      (char const   )'k',      (char const   )'q',      (char const   )'r',      (char const   )'b', 
        (char const   )'n',      (char const   )'p',      (char const   )0,      (char const   )'P', 
        (char const   )'N',      (char const   )'B',      (char const   )'R',      (char const   )'Q', 
        (char const   )'K'};
#line 683 "data.c"
uint64_t const   magic_bishop[64]  = 
#line 683
  {      (uint64_t const   )0x0002020202020200ull,      (uint64_t const   )0x0002020202020000ull,      (uint64_t const   )0x0004010202000000ull,      (uint64_t const   )0x0004040080000000ull, 
        (uint64_t const   )0x0001104000000000ull,      (uint64_t const   )0x0000821040000000ull,      (uint64_t const   )0x0000410410400000ull,      (uint64_t const   )0x0000104104104000ull, 
        (uint64_t const   )0x0000040404040400ull,      (uint64_t const   )0x0000020202020200ull,      (uint64_t const   )0x0000040102020000ull,      (uint64_t const   )0x0000040400800000ull, 
        (uint64_t const   )0x0000011040000000ull,      (uint64_t const   )0x0000008210400000ull,      (uint64_t const   )0x0000004104104000ull,      (uint64_t const   )0x0000002082082000ull, 
        (uint64_t const   )0x0004000808080800ull,      (uint64_t const   )0x0002000404040400ull,      (uint64_t const   )0x0001000202020200ull,      (uint64_t const   )0x0000800802004000ull, 
        (uint64_t const   )0x0000800400A00000ull,      (uint64_t const   )0x0000200100884000ull,      (uint64_t const   )0x0000400082082000ull,      (uint64_t const   )0x0000200041041000ull, 
        (uint64_t const   )0x0002080010101000ull,      (uint64_t const   )0x0001040008080800ull,      (uint64_t const   )0x0000208004010400ull,      (uint64_t const   )0x0000404004010200ull, 
        (uint64_t const   )0x0000840000802000ull,      (uint64_t const   )0x0000404002011000ull,      (uint64_t const   )0x0000808001041000ull,      (uint64_t const   )0x0000404000820800ull, 
        (uint64_t const   )0x0001041000202000ull,      (uint64_t const   )0x0000820800101000ull,      (uint64_t const   )0x0000104400080800ull,      (uint64_t const   )0x0000020080080080ull, 
        (uint64_t const   )0x0000404040040100ull,      (uint64_t const   )0x0000808100020100ull,      (uint64_t const   )0x0001010100020800ull,      (uint64_t const   )0x0000808080010400ull, 
        (uint64_t const   )0x0000820820004000ull,      (uint64_t const   )0x0000410410002000ull,      (uint64_t const   )0x0000082088001000ull,      (uint64_t const   )0x0000002011000800ull, 
        (uint64_t const   )0x0000080100400400ull,      (uint64_t const   )0x0001010101000200ull,      (uint64_t const   )0x0002020202000400ull,      (uint64_t const   )0x0001010101000200ull, 
        (uint64_t const   )0x0000410410400000ull,      (uint64_t const   )0x0000208208200000ull,      (uint64_t const   )0x0000002084100000ull,      (uint64_t const   )0x0000000020880000ull, 
        (uint64_t const   )0x0000001002020000ull,      (uint64_t const   )0x0000040408020000ull,      (uint64_t const   )0x0004040404040000ull,      (uint64_t const   )0x0002020202020000ull, 
        (uint64_t const   )0x0000104104104000ull,      (uint64_t const   )0x0000002082082000ull,      (uint64_t const   )0x0000000020841000ull,      (uint64_t const   )0x0000000000208800ull, 
        (uint64_t const   )0x0000000010020200ull,      (uint64_t const   )0x0000000404080200ull,      (uint64_t const   )0x0000040404040400ull,      (uint64_t const   )0x0002020202020200ull};
#line 707 "data.c"
uint64_t const   magic_bishop_mask[64]  = 
#line 707
  {      (uint64_t const   )0x0040201008040200ull,      (uint64_t const   )0x0000402010080400ull,      (uint64_t const   )0x0000004020100A00ull,      (uint64_t const   )0x0000000040221400ull, 
        (uint64_t const   )0x0000000002442800ull,      (uint64_t const   )0x0000000204085000ull,      (uint64_t const   )0x0000020408102000ull,      (uint64_t const   )0x0002040810204000ull, 
        (uint64_t const   )0x0020100804020000ull,      (uint64_t const   )0x0040201008040000ull,      (uint64_t const   )0x00004020100A0000ull,      (uint64_t const   )0x0000004022140000ull, 
        (uint64_t const   )0x0000000244280000ull,      (uint64_t const   )0x0000020408500000ull,      (uint64_t const   )0x0002040810200000ull,      (uint64_t const   )0x0004081020400000ull, 
        (uint64_t const   )0x0010080402000200ull,      (uint64_t const   )0x0020100804000400ull,      (uint64_t const   )0x004020100A000A00ull,      (uint64_t const   )0x0000402214001400ull, 
        (uint64_t const   )0x0000024428002800ull,      (uint64_t const   )0x0002040850005000ull,      (uint64_t const   )0x0004081020002000ull,      (uint64_t const   )0x0008102040004000ull, 
        (uint64_t const   )0x0008040200020400ull,      (uint64_t const   )0x0010080400040800ull,      (uint64_t const   )0x0020100A000A1000ull,      (uint64_t const   )0x0040221400142200ull, 
        (uint64_t const   )0x0002442800284400ull,      (uint64_t const   )0x0004085000500800ull,      (uint64_t const   )0x0008102000201000ull,      (uint64_t const   )0x0010204000402000ull, 
        (uint64_t const   )0x0004020002040800ull,      (uint64_t const   )0x0008040004081000ull,      (uint64_t const   )0x00100A000A102000ull,      (uint64_t const   )0x0022140014224000ull, 
        (uint64_t const   )0x0044280028440200ull,      (uint64_t const   )0x0008500050080400ull,      (uint64_t const   )0x0010200020100800ull,      (uint64_t const   )0x0020400040201000ull, 
        (uint64_t const   )0x0002000204081000ull,      (uint64_t const   )0x0004000408102000ull,      (uint64_t const   )0x000A000A10204000ull,      (uint64_t const   )0x0014001422400000ull, 
        (uint64_t const   )0x0028002844020000ull,      (uint64_t const   )0x0050005008040200ull,      (uint64_t const   )0x0020002010080400ull,      (uint64_t const   )0x0040004020100800ull, 
        (uint64_t const   )0x0000020408102000ull,      (uint64_t const   )0x0000040810204000ull,      (uint64_t const   )0x00000A1020400000ull,      (uint64_t const   )0x0000142240000000ull, 
        (uint64_t const   )0x0000284402000000ull,      (uint64_t const   )0x0000500804020000ull,      (uint64_t const   )0x0000201008040200ull,      (uint64_t const   )0x0000402010080400ull, 
        (uint64_t const   )0x0002040810204000ull,      (uint64_t const   )0x0004081020400000ull,      (uint64_t const   )0x000A102040000000ull,      (uint64_t const   )0x0014224000000000ull, 
        (uint64_t const   )0x0028440200000000ull,      (uint64_t const   )0x0050080402000000ull,      (uint64_t const   )0x0020100804020000ull,      (uint64_t const   )0x0040201008040200ull};
#line 731 "data.c"
unsigned int const   magic_bishop_shift[64]  = 
#line 731
  {      (unsigned int const   )58,      (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59, 
        (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )58, 
        (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59, 
        (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59, 
        (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )57,      (unsigned int const   )57, 
        (unsigned int const   )57,      (unsigned int const   )57,      (unsigned int const   )59,      (unsigned int const   )59, 
        (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )57,      (unsigned int const   )55, 
        (unsigned int const   )55,      (unsigned int const   )57,      (unsigned int const   )59,      (unsigned int const   )59, 
        (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )57,      (unsigned int const   )55, 
        (unsigned int const   )55,      (unsigned int const   )57,      (unsigned int const   )59,      (unsigned int const   )59, 
        (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )57,      (unsigned int const   )57, 
        (unsigned int const   )57,      (unsigned int const   )57,      (unsigned int const   )59,      (unsigned int const   )59, 
        (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59, 
        (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59, 
        (unsigned int const   )58,      (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59, 
        (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )59,      (unsigned int const   )58};
#line 742 "data.c"
uint64_t *magic_bishop_indices[64]  = 
#line 742
  {      magic_bishop_table + 4992,      magic_bishop_table + 2624,      magic_bishop_table + 256,      magic_bishop_table + 896, 
        magic_bishop_table + 1280,      magic_bishop_table + 1664,      magic_bishop_table + 4800,      magic_bishop_table + 5120, 
        magic_bishop_table + 2560,      magic_bishop_table + 2656,      magic_bishop_table + 288,      magic_bishop_table + 928, 
        magic_bishop_table + 1312,      magic_bishop_table + 1696,      magic_bishop_table + 4832,      magic_bishop_table + 4928, 
        magic_bishop_table + 0,      magic_bishop_table + 128,      magic_bishop_table + 320,      magic_bishop_table + 960, 
        magic_bishop_table + 1344,      magic_bishop_table + 1728,      magic_bishop_table + 2304,      magic_bishop_table + 2432, 
        magic_bishop_table + 32,      magic_bishop_table + 160,      magic_bishop_table + 448,      magic_bishop_table + 2752, 
        magic_bishop_table + 3776,      magic_bishop_table + 1856,      magic_bishop_table + 2336,      magic_bishop_table + 2464, 
        magic_bishop_table + 64,      magic_bishop_table + 192,      magic_bishop_table + 576,      magic_bishop_table + 3264, 
        magic_bishop_table + 4288,      magic_bishop_table + 1984,      magic_bishop_table + 2368,      magic_bishop_table + 2496, 
        magic_bishop_table + 96,      magic_bishop_table + 224,      magic_bishop_table + 704,      magic_bishop_table + 1088, 
        magic_bishop_table + 1472,      magic_bishop_table + 2112,      magic_bishop_table + 2400,      magic_bishop_table + 2528, 
        magic_bishop_table + 2592,      magic_bishop_table + 2688,      magic_bishop_table + 832,      magic_bishop_table + 1216, 
        magic_bishop_table + 1600,      magic_bishop_table + 2240,      magic_bishop_table + 4864,      magic_bishop_table + 4960, 
        magic_bishop_table + 5056,      magic_bishop_table + 2720,      magic_bishop_table + 864,      magic_bishop_table + 1248, 
        magic_bishop_table + 1632,      magic_bishop_table + 2272,      magic_bishop_table + 4896,      magic_bishop_table + 5184};
#line 777 "data.c"
int16_t *magic_bishop_mobility_indices[64]  = 
#line 777
  {      magic_bishop_mobility_table + 4992,      magic_bishop_mobility_table + 2624,      magic_bishop_mobility_table + 256,      magic_bishop_mobility_table + 896, 
        magic_bishop_mobility_table + 1280,      magic_bishop_mobility_table + 1664,      magic_bishop_mobility_table + 4800,      magic_bishop_mobility_table + 5120, 
        magic_bishop_mobility_table + 2560,      magic_bishop_mobility_table + 2656,      magic_bishop_mobility_table + 288,      magic_bishop_mobility_table + 928, 
        magic_bishop_mobility_table + 1312,      magic_bishop_mobility_table + 1696,      magic_bishop_mobility_table + 4832,      magic_bishop_mobility_table + 4928, 
        magic_bishop_mobility_table + 0,      magic_bishop_mobility_table + 128,      magic_bishop_mobility_table + 320,      magic_bishop_mobility_table + 960, 
        magic_bishop_mobility_table + 1344,      magic_bishop_mobility_table + 1728,      magic_bishop_mobility_table + 2304,      magic_bishop_mobility_table + 2432, 
        magic_bishop_mobility_table + 32,      magic_bishop_mobility_table + 160,      magic_bishop_mobility_table + 448,      magic_bishop_mobility_table + 2752, 
        magic_bishop_mobility_table + 3776,      magic_bishop_mobility_table + 1856,      magic_bishop_mobility_table + 2336,      magic_bishop_mobility_table + 2464, 
        magic_bishop_mobility_table + 64,      magic_bishop_mobility_table + 192,      magic_bishop_mobility_table + 576,      magic_bishop_mobility_table + 3264, 
        magic_bishop_mobility_table + 4288,      magic_bishop_mobility_table + 1984,      magic_bishop_mobility_table + 2368,      magic_bishop_mobility_table + 2496, 
        magic_bishop_mobility_table + 96,      magic_bishop_mobility_table + 224,      magic_bishop_mobility_table + 704,      magic_bishop_mobility_table + 1088, 
        magic_bishop_mobility_table + 1472,      magic_bishop_mobility_table + 2112,      magic_bishop_mobility_table + 2400,      magic_bishop_mobility_table + 2528, 
        magic_bishop_mobility_table + 2592,      magic_bishop_mobility_table + 2688,      magic_bishop_mobility_table + 832,      magic_bishop_mobility_table + 1216, 
        magic_bishop_mobility_table + 1600,      magic_bishop_mobility_table + 2240,      magic_bishop_mobility_table + 4864,      magic_bishop_mobility_table + 4960, 
        magic_bishop_mobility_table + 5056,      magic_bishop_mobility_table + 2720,      magic_bishop_mobility_table + 864,      magic_bishop_mobility_table + 1248, 
        magic_bishop_mobility_table + 1632,      magic_bishop_mobility_table + 2272,      magic_bishop_mobility_table + 4896,      magic_bishop_mobility_table + 5184};
#line 812 "data.c"
uint64_t *magic_rook_indices[64]  = 
#line 812
  {      magic_rook_table + 86016,      magic_rook_table + 73728,      magic_rook_table + 36864,      magic_rook_table + 43008, 
        magic_rook_table + 47104,      magic_rook_table + 51200,      magic_rook_table + 77824,      magic_rook_table + 94208, 
        magic_rook_table + 69632,      magic_rook_table + 32768,      magic_rook_table + 38912,      magic_rook_table + 10240, 
        magic_rook_table + 14336,      magic_rook_table + 53248,      magic_rook_table + 57344,      magic_rook_table + 81920, 
        magic_rook_table + 24576,      magic_rook_table + 33792,      magic_rook_table + 6144,      magic_rook_table + 11264, 
        magic_rook_table + 15360,      magic_rook_table + 18432,      magic_rook_table + 58368,      magic_rook_table + 61440, 
        magic_rook_table + 26624,      magic_rook_table + 4096,      magic_rook_table + 7168,      magic_rook_table + 0, 
        magic_rook_table + 2048,      magic_rook_table + 19456,      magic_rook_table + 22528,      magic_rook_table + 63488, 
        magic_rook_table + 28672,      magic_rook_table + 5120,      magic_rook_table + 8192,      magic_rook_table + 1024, 
        magic_rook_table + 3072,      magic_rook_table + 20480,      magic_rook_table + 23552,      magic_rook_table + 65536, 
        magic_rook_table + 30720,      magic_rook_table + 34816,      magic_rook_table + 9216,      magic_rook_table + 12288, 
        magic_rook_table + 16384,      magic_rook_table + 21504,      magic_rook_table + 59392,      magic_rook_table + 67584, 
        magic_rook_table + 71680,      magic_rook_table + 35840,      magic_rook_table + 39936,      magic_rook_table + 13312, 
        magic_rook_table + 17408,      magic_rook_table + 54272,      magic_rook_table + 60416,      magic_rook_table + 83968, 
        magic_rook_table + 90112,      magic_rook_table + 75776,      magic_rook_table + 40960,      magic_rook_table + 45056, 
        magic_rook_table + 49152,      magic_rook_table + 55296,      magic_rook_table + 79872,      magic_rook_table + 98304};
#line 847 "data.c"
int16_t *magic_rook_mobility_indices[64]  = 
#line 847
  {      magic_rook_mobility_table + 86016,      magic_rook_mobility_table + 73728,      magic_rook_mobility_table + 36864,      magic_rook_mobility_table + 43008, 
        magic_rook_mobility_table + 47104,      magic_rook_mobility_table + 51200,      magic_rook_mobility_table + 77824,      magic_rook_mobility_table + 94208, 
        magic_rook_mobility_table + 69632,      magic_rook_mobility_table + 32768,      magic_rook_mobility_table + 38912,      magic_rook_mobility_table + 10240, 
        magic_rook_mobility_table + 14336,      magic_rook_mobility_table + 53248,      magic_rook_mobility_table + 57344,      magic_rook_mobility_table + 81920, 
        magic_rook_mobility_table + 24576,      magic_rook_mobility_table + 33792,      magic_rook_mobility_table + 6144,      magic_rook_mobility_table + 11264, 
        magic_rook_mobility_table + 15360,      magic_rook_mobility_table + 18432,      magic_rook_mobility_table + 58368,      magic_rook_mobility_table + 61440, 
        magic_rook_mobility_table + 26624,      magic_rook_mobility_table + 4096,      magic_rook_mobility_table + 7168,      magic_rook_mobility_table + 0, 
        magic_rook_mobility_table + 2048,      magic_rook_mobility_table + 19456,      magic_rook_mobility_table + 22528,      magic_rook_mobility_table + 63488, 
        magic_rook_mobility_table + 28672,      magic_rook_mobility_table + 5120,      magic_rook_mobility_table + 8192,      magic_rook_mobility_table + 1024, 
        magic_rook_mobility_table + 3072,      magic_rook_mobility_table + 20480,      magic_rook_mobility_table + 23552,      magic_rook_mobility_table + 65536, 
        magic_rook_mobility_table + 30720,      magic_rook_mobility_table + 34816,      magic_rook_mobility_table + 9216,      magic_rook_mobility_table + 12288, 
        magic_rook_mobility_table + 16384,      magic_rook_mobility_table + 21504,      magic_rook_mobility_table + 59392,      magic_rook_mobility_table + 67584, 
        magic_rook_mobility_table + 71680,      magic_rook_mobility_table + 35840,      magic_rook_mobility_table + 39936,      magic_rook_mobility_table + 13312, 
        magic_rook_mobility_table + 17408,      magic_rook_mobility_table + 54272,      magic_rook_mobility_table + 60416,      magic_rook_mobility_table + 83968, 
        magic_rook_mobility_table + 90112,      magic_rook_mobility_table + 75776,      magic_rook_mobility_table + 40960,      magic_rook_mobility_table + 45056, 
        magic_rook_mobility_table + 49152,      magic_rook_mobility_table + 55296,      magic_rook_mobility_table + 79872,      magic_rook_mobility_table + 98304};
#line 881 "data.c"
uint64_t const   magic_rook[64]  = 
#line 881
  {      (uint64_t const   )0x0080001020400080ull,      (uint64_t const   )0x0040001000200040ull,      (uint64_t const   )0x0080081000200080ull,      (uint64_t const   )0x0080040800100080ull, 
        (uint64_t const   )0x0080020400080080ull,      (uint64_t const   )0x0080010200040080ull,      (uint64_t const   )0x0080008001000200ull,      (uint64_t const   )0x0080002040800100ull, 
        (uint64_t const   )0x0000800020400080ull,      (uint64_t const   )0x0000400020005000ull,      (uint64_t const   )0x0000801000200080ull,      (uint64_t const   )0x0000800800100080ull, 
        (uint64_t const   )0x0000800400080080ull,      (uint64_t const   )0x0000800200040080ull,      (uint64_t const   )0x0000800100020080ull,      (uint64_t const   )0x0000800040800100ull, 
        (uint64_t const   )0x0000208000400080ull,      (uint64_t const   )0x0000404000201000ull,      (uint64_t const   )0x0000808010002000ull,      (uint64_t const   )0x0000808008001000ull, 
        (uint64_t const   )0x0000808004000800ull,      (uint64_t const   )0x0000808002000400ull,      (uint64_t const   )0x0000010100020004ull,      (uint64_t const   )0x0000020000408104ull, 
        (uint64_t const   )0x0000208080004000ull,      (uint64_t const   )0x0000200040005000ull,      (uint64_t const   )0x0000100080200080ull,      (uint64_t const   )0x0000080080100080ull, 
        (uint64_t const   )0x0000040080080080ull,      (uint64_t const   )0x0000020080040080ull,      (uint64_t const   )0x0000010080800200ull,      (uint64_t const   )0x0000800080004100ull, 
        (uint64_t const   )0x0000204000800080ull,      (uint64_t const   )0x0000200040401000ull,      (uint64_t const   )0x0000100080802000ull,      (uint64_t const   )0x0000080080801000ull, 
        (uint64_t const   )0x0000040080800800ull,      (uint64_t const   )0x0000020080800400ull,      (uint64_t const   )0x0000020001010004ull,      (uint64_t const   )0x0000800040800100ull, 
        (uint64_t const   )0x0000204000808000ull,      (uint64_t const   )0x0000200040008080ull,      (uint64_t const   )0x0000100020008080ull,      (uint64_t const   )0x0000080010008080ull, 
        (uint64_t const   )0x0000040008008080ull,      (uint64_t const   )0x0000020004008080ull,      (uint64_t const   )0x0000010002008080ull,      (uint64_t const   )0x0000004081020004ull, 
        (uint64_t const   )0x0000204000800080ull,      (uint64_t const   )0x0000200040008080ull,      (uint64_t const   )0x0000100020008080ull,      (uint64_t const   )0x0000080010008080ull, 
        (uint64_t const   )0x0000040008008080ull,      (uint64_t const   )0x0000020004008080ull,      (uint64_t const   )0x0000800100020080ull,      (uint64_t const   )0x0000800041000080ull, 
        (uint64_t const   )0x00FFFCDDFCED714Aull,      (uint64_t const   )0x007FFCDDFCED714Aull,      (uint64_t const   )0x003FFFCDFFD88096ull,      (uint64_t const   )0x0000040810002101ull, 
        (uint64_t const   )0x0001000204080011ull,      (uint64_t const   )0x0001000204000801ull,      (uint64_t const   )0x0001000082000401ull,      (uint64_t const   )0x0001FFFAABFAD1A2ull};
#line 905 "data.c"
uint64_t const   magic_rook_mask[64]  = 
#line 905
  {      (uint64_t const   )0x000101010101017Eull,      (uint64_t const   )0x000202020202027Cull,      (uint64_t const   )0x000404040404047Aull,      (uint64_t const   )0x0008080808080876ull, 
        (uint64_t const   )0x001010101010106Eull,      (uint64_t const   )0x002020202020205Eull,      (uint64_t const   )0x004040404040403Eull,      (uint64_t const   )0x008080808080807Eull, 
        (uint64_t const   )0x0001010101017E00ull,      (uint64_t const   )0x0002020202027C00ull,      (uint64_t const   )0x0004040404047A00ull,      (uint64_t const   )0x0008080808087600ull, 
        (uint64_t const   )0x0010101010106E00ull,      (uint64_t const   )0x0020202020205E00ull,      (uint64_t const   )0x0040404040403E00ull,      (uint64_t const   )0x0080808080807E00ull, 
        (uint64_t const   )0x00010101017E0100ull,      (uint64_t const   )0x00020202027C0200ull,      (uint64_t const   )0x00040404047A0400ull,      (uint64_t const   )0x0008080808760800ull, 
        (uint64_t const   )0x00101010106E1000ull,      (uint64_t const   )0x00202020205E2000ull,      (uint64_t const   )0x00404040403E4000ull,      (uint64_t const   )0x00808080807E8000ull, 
        (uint64_t const   )0x000101017E010100ull,      (uint64_t const   )0x000202027C020200ull,      (uint64_t const   )0x000404047A040400ull,      (uint64_t const   )0x0008080876080800ull, 
        (uint64_t const   )0x001010106E101000ull,      (uint64_t const   )0x002020205E202000ull,      (uint64_t const   )0x004040403E404000ull,      (uint64_t const   )0x008080807E808000ull, 
        (uint64_t const   )0x0001017E01010100ull,      (uint64_t const   )0x0002027C02020200ull,      (uint64_t const   )0x0004047A04040400ull,      (uint64_t const   )0x0008087608080800ull, 
        (uint64_t const   )0x0010106E10101000ull,      (uint64_t const   )0x0020205E20202000ull,      (uint64_t const   )0x0040403E40404000ull,      (uint64_t const   )0x0080807E80808000ull, 
        (uint64_t const   )0x00017E0101010100ull,      (uint64_t const   )0x00027C0202020200ull,      (uint64_t const   )0x00047A0404040400ull,      (uint64_t const   )0x0008760808080800ull, 
        (uint64_t const   )0x00106E1010101000ull,      (uint64_t const   )0x00205E2020202000ull,      (uint64_t const   )0x00403E4040404000ull,      (uint64_t const   )0x00807E8080808000ull, 
        (uint64_t const   )0x007E010101010100ull,      (uint64_t const   )0x007C020202020200ull,      (uint64_t const   )0x007A040404040400ull,      (uint64_t const   )0x0076080808080800ull, 
        (uint64_t const   )0x006E101010101000ull,      (uint64_t const   )0x005E202020202000ull,      (uint64_t const   )0x003E404040404000ull,      (uint64_t const   )0x007E808080808000ull, 
        (uint64_t const   )0x7E01010101010100ull,      (uint64_t const   )0x7C02020202020200ull,      (uint64_t const   )0x7A04040404040400ull,      (uint64_t const   )0x7608080808080800ull, 
        (uint64_t const   )0x6E10101010101000ull,      (uint64_t const   )0x5E20202020202000ull,      (uint64_t const   )0x3E40404040404000ull,      (uint64_t const   )0x7E80808080808000ull};
#line 929 "data.c"
unsigned int const   magic_rook_shift[64]  = 
#line 929
  {      (unsigned int const   )52,      (unsigned int const   )53,      (unsigned int const   )53,      (unsigned int const   )53, 
        (unsigned int const   )53,      (unsigned int const   )53,      (unsigned int const   )53,      (unsigned int const   )52, 
        (unsigned int const   )53,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54, 
        (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )53, 
        (unsigned int const   )53,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54, 
        (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )53, 
        (unsigned int const   )53,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54, 
        (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )53, 
        (unsigned int const   )53,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54, 
        (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )53, 
        (unsigned int const   )53,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54, 
        (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )53, 
        (unsigned int const   )53,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54, 
        (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )53, 
        (unsigned int const   )53,      (unsigned int const   )54,      (unsigned int const   )54,      (unsigned int const   )53, 
        (unsigned int const   )53,      (unsigned int const   )53,      (unsigned int const   )53,      (unsigned int const   )53};
#line 939 "data.c"
uint64_t const   mobility_mask_b[4]  = {      (uint64_t const   )0xFF818181818181FFull,      (uint64_t const   )0x007E424242427E00ull,      (uint64_t const   )0x00003C24243C0000ull,      (uint64_t const   )0x0000001818000000ull};
#line 943 "data.c"
uint64_t const   mobility_mask_r[4]  = {      (uint64_t const   )0x8181818181818181ull,      (uint64_t const   )0x4242424242424242ull,      (uint64_t const   )0x2424242424242424ull,      (uint64_t const   )0x1818181818181818ull};
#line 950 "data.c"
int const   rankflip[2][8]  = { {        (int const   )7,        (int const   )6,        (int const   )5,        (int const   )4, 
            (int const   )3,        (int const   )2,        (int const   )1,        (int const   )0}, 
   {        (int const   )0,        (int const   )1,        (int const   )2,        (int const   )3, 
            (int const   )4,        (int const   )5,        (int const   )6,        (int const   )7}};
#line 954 "data.c"
int const   sqflip[2][64]  = { {        (int const   )56,        (int const   )57,        (int const   )58,        (int const   )59, 
            (int const   )60,        (int const   )61,        (int const   )62,        (int const   )63, 
            (int const   )48,        (int const   )49,        (int const   )50,        (int const   )51, 
            (int const   )52,        (int const   )53,        (int const   )54,        (int const   )55, 
            (int const   )40,        (int const   )41,        (int const   )42,        (int const   )43, 
            (int const   )44,        (int const   )45,        (int const   )46,        (int const   )47, 
            (int const   )32,        (int const   )33,        (int const   )34,        (int const   )35, 
            (int const   )36,        (int const   )37,        (int const   )38,        (int const   )39, 
            (int const   )24,        (int const   )25,        (int const   )26,        (int const   )27, 
            (int const   )28,        (int const   )29,        (int const   )30,        (int const   )31, 
            (int const   )16,        (int const   )17,        (int const   )18,        (int const   )19, 
            (int const   )20,        (int const   )21,        (int const   )22,        (int const   )23, 
            (int const   )8,        (int const   )9,        (int const   )10,        (int const   )11, 
            (int const   )12,        (int const   )13,        (int const   )14,        (int const   )15, 
            (int const   )0,        (int const   )1,        (int const   )2,        (int const   )3, 
            (int const   )4,        (int const   )5,        (int const   )6,        (int const   )7}, 
   {        (int const   )0,        (int const   )1,        (int const   )2,        (int const   )3, 
            (int const   )4,        (int const   )5,        (int const   )6,        (int const   )7, 
            (int const   )8,        (int const   )9,        (int const   )10,        (int const   )11, 
            (int const   )12,        (int const   )13,        (int const   )14,        (int const   )15, 
            (int const   )16,        (int const   )17,        (int const   )18,        (int const   )19, 
            (int const   )20,        (int const   )21,        (int const   )22,        (int const   )23, 
            (int const   )24,        (int const   )25,        (int const   )26,        (int const   )27, 
            (int const   )28,        (int const   )29,        (int const   )30,        (int const   )31, 
            (int const   )32,        (int const   )33,        (int const   )34,        (int const   )35, 
            (int const   )36,        (int const   )37,        (int const   )38,        (int const   )39, 
            (int const   )40,        (int const   )41,        (int const   )42,        (int const   )43, 
            (int const   )44,        (int const   )45,        (int const   )46,        (int const   )47, 
            (int const   )48,        (int const   )49,        (int const   )50,        (int const   )51, 
            (int const   )52,        (int const   )53,        (int const   )54,        (int const   )55, 
            (int const   )56,        (int const   )57,        (int const   )58,        (int const   )59, 
            (int const   )60,        (int const   )61,        (int const   )62,        (int const   )63}};
#line 973 "data.c"
int const   rank1[2]  = {      (int const   )7,      (int const   )0};
#line 974 "data.c"
int const   rank2[2]  = {      (int const   )6,      (int const   )1};
#line 975 "data.c"
int const   rank3[2]  = {      (int const   )5,      (int const   )2};
#line 976 "data.c"
int const   rank4[2]  = {      (int const   )4,      (int const   )3};
#line 977 "data.c"
int const   rank5[2]  = {      (int const   )3,      (int const   )4};
#line 978 "data.c"
int const   rank6[2]  = {      (int const   )2,      (int const   )5};
#line 979 "data.c"
int const   rank7[2]  = {      (int const   )1,      (int const   )6};
#line 980 "data.c"
int const   rank8[2]  = {      (int const   )0,      (int const   )7};
#line 981 "data.c"
int const   epdir[2]  = {      (int const   )8,      (int const   )-8};
#line 982 "data.c"
int const   csq[2]  = {      (int const   )58,      (int const   )2};
#line 983 "data.c"
int const   dsq[2]  = {      (int const   )59,      (int const   )3};
#line 984 "data.c"
int const   esq[2]  = {      (int const   )60,      (int const   )4};
#line 985 "data.c"
int const   fsq[2]  = {      (int const   )61,      (int const   )5};
#line 986 "data.c"
int const   gsq[2]  = {      (int const   )62,      (int const   )6};
#line 988 "data.c"
int const   sign[2]  = {      (int const   )-1,      (int const   )1};
#line 989 "data.c"
int const   epsq[2]  = {      (int const   )8,      (int const   )-8};
#line 990 "data.c"
int const   rook_A[2]  = {      (int const   )56,      (int const   )0};
#line 991 "data.c"
int const   rook_D[2]  = {      (int const   )59,      (int const   )3};
#line 992 "data.c"
int const   rook_F[2]  = {      (int const   )61,      (int const   )5};
#line 993 "data.c"
int const   rook_G[2]  = {      (int const   )62,      (int const   )6};
#line 994 "data.c"
int const   rook_H[2]  = {      (int const   )63,      (int const   )7};
#line 995 "data.c"
int const   pawnadv1[2]  = {      (int const   )8,      (int const   )-8};
#line 996 "data.c"
int const   pawnadv2[2]  = {      (int const   )16,      (int const   )-16};
#line 997 "data.c"
int const   capleft[2]  = {      (int const   )9,      (int const   )-7};
#line 998 "data.c"
int const   capright[2]  = {      (int const   )7,      (int const   )-9};
#line 999 "data.c"
char const   empty_sqs[9]  = 
#line 999
  {      (char const   )0,      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8'};
#line 1000 "data.c"
int const   pcval[7]  = {      (int const   )0,      (int const   )100,      (int const   )300,      (int const   )300, 
        (int const   )500,      (int const   )900,      (int const   )9900};
#line 1001 "data.c"
int const   p_vals[7]  = {      (int const   )0,      (int const   )1,      (int const   )3,      (int const   )3, 
        (int const   )5,      (int const   )9,      (int const   )99};
#line 1002 "data.c"
int const   MVV_LVA[7][7]  = { {        (int const   )0,        (int const   )(5 << 21),        (int const   )(4 << 21),        (int const   )(4 << 21), 
            (int const   )(3 << 21),        (int const   )(2 << 21),        (int const   )(1 << 21)}, 
   {        (int const   )0,        (int const   )(10 << 21),        (int const   )(9 << 21),        (int const   )(9 << 21), 
            (int const   )(8 << 21),        (int const   )(7 << 21),        (int const   )(6 << 21)}, 
   {        (int const   )0,        (int const   )(15 << 21),        (int const   )(14 << 21),        (int const   )(14 << 21), 
            (int const   )(13 << 21),        (int const   )(12 << 21),        (int const   )(11 << 21)}, 
   {        (int const   )0,        (int const   )(15 << 21),        (int const   )(14 << 21),        (int const   )(14 << 21), 
            (int const   )(13 << 21),        (int const   )(12 << 21),        (int const   )(11 << 21)}, 
   {        (int const   )0,        (int const   )(20 << 21),        (int const   )(19 << 21),        (int const   )(19 << 21), 
            (int const   )(18 << 21),        (int const   )(17 << 21),        (int const   )(16 << 21)}, 
   {        (int const   )0,        (int const   )(25 << 21),        (int const   )(24 << 21),        (int const   )(24 << 21), 
            (int const   )(23 << 21),        (int const   )(22 << 21),        (int const   )(21 << 21)}, 
   {        (int const   )0,        (int const   )(30 << 21),        (int const   )(29 << 21),        (int const   )(29 << 21), 
            (int const   )(28 << 21),        (int const   )(27 << 21),        (int const   )(26 << 21)}};
#line 1010 "data.c"
int const   pieces[2][7]  = { {        (int const   )0,        (int const   )-1,        (int const   )-2,        (int const   )-3, 
            (int const   )-4,        (int const   )-5,        (int const   )-6}, 
   {        (int const   )0,        (int const   )1,        (int const   )2,        (int const   )3, 
            (int const   )4,        (int const   )5,        (int const   )6}};
#line 1014 "data.c"
int const   lower_n  =    (int const   )16;
#line 1015 "data.c"
int const   lower_b  =    (int const   )10;
#line 1016 "data.c"
int const   mobility_score_n[4]  = {      (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4};
#line 1017 "data.c"
int const   mobility_score_b[4]  = {      (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4};
#line 1018 "data.c"
int const   mobility_score_r[4]  = {      (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4};
#line 1019 "data.c"
int const   mob_curve_r[48]  = 
#line 1019
  {      (int const   )-27,      (int const   )-23,      (int const   )-21,      (int const   )-19, 
        (int const   )-15,      (int const   )-10,      (int const   )-9,      (int const   )-8, 
        (int const   )-7,      (int const   )-6,      (int const   )-5,      (int const   )-4, 
        (int const   )-3,      (int const   )-2,      (int const   )-1,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )16, 
        (int const   )17,      (int const   )18,      (int const   )19,      (int const   )20, 
        (int const   )21,      (int const   )22,      (int const   )23,      (int const   )24, 
        (int const   )25,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )31,      (int const   )32};
#line 1027 "data.c"
int piece_values[2][7]  = { {        0,        -100,        -305,        -305, 
            -490,        -1000,        -40000}, 
   {        0,        100,        305,        305, 
            490,        1000,        40000}};
#line 1049 "data.c"
struct personality_term personality_packet[256]  = 
#line 1049
  {      {"search options                          ", 0, 0, (void *)0}, 
        {"check extension                         ", 1, 0, (void *)(& check_depth)}, 
        {"null-move reduction                     ", 1, 0, (void *)(& null_depth)}, 
        {"null-move adaptive divisor              ", 1, 0, (void *)(& null_divisor)}, 
        {"LMR min distance to frontier            ", 1, 0, (void *)(& LMR_rdepth)}, 
        {"LMR min reduction                       ", 1, 0, (void *)(& LMR_min)}, 
        {"LMR max reduction                       ", 1, 0, (void *)(& LMR_max)}, 
        {"LMR formula depth bias                  ", 3, 0, (void *)(& LMR_db)}, 
        {"LMR formula moves searched bias         ", 3, 0, (void *)(& LMR_mb)}, 
        {"LMR scale factor                        ", 3, 0, (void *)(& LMR_s)}, 
        {"search options (continued)              ", 0, 0, (void *)0}, 
        {(char *)((void *)0), 0, 0, (void *)0}};
#line 26 "drawn.c"
int Drawn(TREE *tree , int value ) 
{ 
  int tmp ;

  {
#line 35
  if (tree->position.pieces[1][1]) {
#line 35
    goto _L;
  } else
#line 35
  if (tree->position.pieces[0][1]) {
    _L: /* CIL Label */ 
#line 36
    return (0);
  }
#line 45
  if (value > 0) {
#line 45
    tmp = value;
  } else {
#line 45
    tmp = - value;
  }
#line 45
  if (tmp > 32000) {
#line 46
    return (0);
  }
#line 56
  if ((int )tree->position.pieces[1][0] + (int )tree->position.pieces[0][0] < 4) {
#line 57
    return (2);
  }
#line 58
  if ((int )tree->position.pieces[1][0] < 5) {
#line 58
    if ((int )tree->position.pieces[0][0] < 5) {
#line 59
      return (1);
    } else {
#line 58
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 60
  if ((int )tree->position.pieces[1][0] == 5) {
#line 60
    goto _L___1;
  } else
#line 60
  if ((int )tree->position.pieces[1][0] > 6) {
    _L___1: /* CIL Label */ 
#line 61
    return (0);
  }
#line 62
  if ((int )tree->position.pieces[0][0] == 5) {
#line 62
    goto _L___2;
  } else
#line 62
  if ((int )tree->position.pieces[0][0] > 6) {
    _L___2: /* CIL Label */ 
#line 63
    return (0);
  }
#line 64
  if ((int )tree->position.pieces[1][0] == 6) {
#line 64
    if (! tree->position.color[1].pieces[3]) {
#line 64
      if (tree->position.material_evaluation > 0) {
#line 64
        goto _L___3;
      } else {
#line 64
        goto _L___7;
      }
    } else {
#line 64
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
  _L___6: /* CIL Label */ 
#line 64
  if ((int )tree->position.pieces[0][0] == 6) {
#line 64
    if (! tree->position.color[0].pieces[3]) {
#line 64
      if (tree->position.material_evaluation < 0) {
        _L___3: /* CIL Label */ 
#line 67
        return (1);
      } else {
#line 64
        goto _L___5;
      }
    } else {
#line 64
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ ;
  }
#line 81
  if (value != draw_score[game_wtm]) {
#line 82
    return (0);
  }
#line 83
  if ((int )tree->position.pieces[1][0] == (int )tree->position.pieces[0][0]) {
#line 84
    return (1);
  }
#line 85
  return (0);
}
}
#line 33 "edit.c"
static char const   pieces___0[15]  = 
#line 33 "edit.c"
  {      (char const   )'x',      (char const   )'X',      (char const   )'P',      (char const   )'p', 
        (char const   )'N',      (char const   )'n',      (char const   )'B',      (char const   )'b', 
        (char const   )'R',      (char const   )'r',      (char const   )'Q',      (char const   )'q', 
        (char const   )'K',      (char const   )'k',      (char const   )'\000'};
#line 30 "edit.c"
void Edit(void) 
{ 
  int athome ;
  int i ;
  int piece ;
  int readstat ;
  int square ;
  int tfile ;
  int trank ;
  int wtm ;
  int error ;
  TREE *tree ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 31
  athome = 1;
#line 31
  wtm = 1;
#line 31
  error = 0;
#line 37
  tree = (TREE *)block[0];
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! 1) {
#line 47
      goto while_break;
    }
#line 48
    if ((unsigned long )input_stream == (unsigned long )stdin) {
#line 48
      if (! xboard) {
#line 49
        if (wtm) {
#line 50
          printf((char const   *)"edit(white): ");
        } else {
#line 52
          printf((char const   *)"edit(black): ");
        }
      } else {
#line 48
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 54
    fflush(stdout);
#line 55
    readstat = Read(1, buffer);
#line 56
    if (readstat < 0) {
#line 57
      return;
    }
#line 58
    nargs = ReadParse(buffer, args, " \t;");
#line 59
    if (xboard) {
#line 60
      Print(32, "edit.command:%s\n", args[0]);
    }
#line 61
    tmp___0 = strcmp((char const   *)args[0], (char const   *)"white");
#line 61
    if (tmp___0) {
#line 63
      tmp = strcmp((char const   *)args[0], (char const   *)"black");
#line 63
      if (! tmp) {
#line 64
        wtm = 0;
      }
    } else {
#line 62
      wtm = 1;
    }
#line 65
    tmp___9 = strcmp((char const   *)args[0], (char const   *)"#");
#line 65
    if (tmp___9) {
#line 68
      tmp___8 = strcmp((char const   *)args[0], (char const   *)"c");
#line 68
      if (tmp___8) {
#line 70
        tmp___6 = strcmp((char const   *)args[0], (char const   *)"end");
#line 70
        if (tmp___6) {
#line 70
          tmp___7 = strcmp((char const   *)args[0], (char const   *)".");
#line 70
          if (tmp___7) {
#line 72
            tmp___5 = strcmp((char const   *)args[0], (char const   *)"d");
#line 72
            if (tmp___5) {
#line 74
              tmp___4 = strlen((char const   *)args[0]);
#line 74
              if (tmp___4 == 3UL) {
#line 75
                tmp___2 = strchr(pieces___0, (int )*(args[0] + 0));
#line 75
                if (tmp___2) {
#line 76
                  tmp___1 = strchr(pieces___0, (int )*(args[0] + 0));
#line 76
                  piece = (int )((tmp___1 - (char *)(pieces___0)) >> 1);
#line 77
                  tfile = (int )*(args[0] + 1) - 97;
#line 78
                  trank = (int )*(args[0] + 2) - 49;
#line 79
                  square = (trank << 3) + tfile;
#line 80
                  if (square < 0) {
#line 80
                    goto _L___0;
                  } else
#line 80
                  if (square > 63) {
                    _L___0: /* CIL Label */ 
#line 81
                    printf((char const   *)"unrecognized square %s\n", args[0]);
                  }
#line 82
                  if (wtm) {
#line 83
                    tree->position.board[square] = (int8_t )piece;
                  } else {
#line 85
                    tree->position.board[square] = (int8_t )(- piece);
                  }
                }
              } else {
#line 87
                tmp___3 = strlen((char const   *)args[0]);
#line 87
                if (tmp___3 == 2UL) {
#line 88
                  piece = 1;
#line 89
                  tfile = (int )*(args[0] + 0) - 97;
#line 90
                  trank = (int )*(args[0] + 1) - 49;
#line 91
                  square = (trank << 3) + tfile;
#line 92
                  if (square < 0) {
#line 92
                    goto _L___1;
                  } else
#line 92
                  if (square > 63) {
                    _L___1: /* CIL Label */ 
#line 93
                    printf((char const   *)"unrecognized square %s\n", args[0]);
                  }
#line 94
                  if (wtm) {
#line 95
                    tree->position.board[square] = (int8_t )piece;
                  } else {
#line 97
                    tree->position.board[square] = (int8_t )(- piece);
                  }
                } else {
#line 99
                  printf((char const   *)"unrecognized piece %s\n", args[0]);
                }
              }
            } else {
#line 73
              DisplayChessBoard(stdout, tree->position);
            }
          } else {
            _L___2: /* CIL Label */ 
#line 71
            goto while_break;
          }
        } else {
#line 70
          goto _L___2;
        }
      } else {
#line 69
        wtm ^= 1;
      }
    } else {
#line 66
      i = 0;
      {
#line 66
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 66
        if (! (i < 64)) {
#line 66
          goto while_break___0;
        }
#line 67
        tree->position.board[i] = (int8_t )0;
#line 66
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  tree->status[0].castle[1] = (int8_t )0;
#line 116
  tree->status[0].castle[0] = (int8_t )0;
#line 117
  tree->status[0].enpassant_target = (uint8_t )0;
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 118
    if (! (i < 16)) {
#line 118
      goto while_break___1;
    }
#line 119
    if ((int )tree->position.board[i] == 0) {
#line 119
      goto _L___3;
    } else
#line 119
    if ((int )tree->position.board[i + 48] == 0) {
      _L___3: /* CIL Label */ 
#line 120
      athome = 0;
    }
#line 118
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 121
  if (! athome) {
#line 121
    goto _L___4;
  } else
#line 121
  if ((int )tree->position.board[0] == 4) {
#line 121
    if ((int )tree->position.board[1] == 2) {
#line 121
      if ((int )tree->position.board[2] == 3) {
#line 121
        if ((int )tree->position.board[3] == 5) {
#line 121
          if ((int )tree->position.board[4] == 6) {
#line 121
            if ((int )tree->position.board[5] == 3) {
#line 121
              if ((int )tree->position.board[6] == 2) {
#line 121
                if ((int )tree->position.board[7] == 4) {
#line 121
                  if ((int )tree->position.board[56] == -4) {
#line 121
                    if ((int )tree->position.board[57] == -2) {
#line 121
                      if ((int )tree->position.board[58] == -3) {
#line 121
                        if ((int )tree->position.board[59] == -5) {
#line 121
                          if ((int )tree->position.board[60] == -6) {
#line 121
                            if ((int )tree->position.board[61] == -3) {
#line 121
                              if ((int )tree->position.board[62] == -2) {
#line 121
                                if ((int )tree->position.board[63] == -4) {
                                  _L___4: /* CIL Label */ 
#line 128
                                  if ((int )tree->position.board[4] == 6) {
#line 129
                                    if ((int )tree->position.board[0] == 4) {
#line 130
                                      tree->status[0].castle[1] = (int8_t )((int )tree->status[0].castle[1] | 2);
                                    }
#line 131
                                    if ((int )tree->position.board[7] == 4) {
#line 132
                                      tree->status[0].castle[1] = (int8_t )((int )tree->status[0].castle[1] | 1);
                                    }
                                  }
#line 134
                                  if ((int )tree->position.board[60] == -6) {
#line 135
                                    if ((int )tree->position.board[56] == -4) {
#line 136
                                      tree->status[0].castle[0] = (int8_t )((int )tree->status[0].castle[0] | 2);
                                    }
#line 137
                                    if ((int )tree->position.board[63] == -4) {
#line 138
                                      tree->status[0].castle[0] = (int8_t )((int )tree->status[0].castle[0] | 1);
                                    }
                                  }
                                } else {
#line 121
                                  goto _L___19;
                                }
                              } else {
#line 121
                                goto _L___19;
                              }
                            } else {
#line 121
                              goto _L___19;
                            }
                          } else {
#line 121
                            goto _L___19;
                          }
                        } else {
#line 121
                          goto _L___19;
                        }
                      } else {
#line 121
                        goto _L___19;
                      }
                    } else {
#line 121
                      goto _L___19;
                    }
                  } else {
#line 121
                    goto _L___19;
                  }
                } else {
#line 121
                  goto _L___19;
                }
              } else {
#line 121
                goto _L___19;
              }
            } else {
#line 121
              goto _L___19;
            }
          } else {
#line 121
            goto _L___19;
          }
        } else {
#line 121
          goto _L___19;
        }
      } else {
#line 121
        goto _L___19;
      }
    } else {
#line 121
      goto _L___19;
    }
  } else {
    _L___19: /* CIL Label */ 
    _L___18: /* CIL Label */ 
    _L___17: /* CIL Label */ 
    _L___16: /* CIL Label */ 
    _L___15: /* CIL Label */ 
    _L___14: /* CIL Label */ 
    _L___13: /* CIL Label */ 
    _L___12: /* CIL Label */ 
    _L___11: /* CIL Label */ 
    _L___10: /* CIL Label */ 
    _L___9: /* CIL Label */ 
    _L___8: /* CIL Label */ 
    _L___7: /* CIL Label */ 
    _L___6: /* CIL Label */ 
    _L___5: /* CIL Label */ ;
  }
#line 149
  SetChessBitBoards((TREE *)tree);
#line 150
  tmp___10 = InvalidPosition((TREE *)tree);
#line 150
  error += tmp___10;
#line 151
  if (! error) {
#line 152
    if (log_file) {
#line 153
      DisplayChessBoard(log_file, tree->position);
    }
#line 154
    wtm = 1;
#line 155
    move_number = 1;
#line 156
    rep_index = 0;
#line 157
    tree->rep_list[0] = tree->position.hash_key;
#line 158
    tree->status[0].reversible = (uint8_t )0;
#line 159
    moves_out_of_book = 0;
  } else {
#line 161
    InitializeChessBoard((TREE *)tree);
#line 162
    Print(4095, "Illegal position, using normal initial chess position\n");
  }
#line 164
  return;
}
}
#line 35 "evtest.c"
void EVTest(char *filename ) 
{ 
  FILE *test_input ;
  char *eof ;
  char buff[4096] ;
  TREE *tree ;
  char *delim ;
  int s1 ;
  int s2 ;
  int s3 ;
  int s4 ;
  int id ;
  int tmp ;
  int tmp___0 ;

  {
#line 39
  tree = (TREE *)block[0];
#line 48
  test_input = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 48
  if (! test_input) {
#line 49
    printf((char const   *)"file %s does not exist.\n", filename);
#line 50
    return;
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! 1) {
#line 52
      goto while_break;
    }
#line 53
    eof = fgets(buffer, 4096, test_input);
#line 54
    if (eof) {
#line 57
      delim = strchr((char const   *)(buffer), '\n');
#line 58
      if (delim) {
#line 59
        *delim = (char)0;
      }
#line 60
      delim = strchr((char const   *)(buffer), '\r');
#line 61
      if (delim) {
#line 62
        *delim = (char )' ';
      }
    } else {
#line 64
      goto while_break;
    }
#line 65
    strcpy(buff, (char const   *)(buffer));
#line 66
    nargs = ReadParse(buffer, args, " \t;");
#line 67
    tmp___0 = strcmp((char const   *)args[0], (char const   *)"end");
#line 67
    if (tmp___0) {
#line 81
      id = 2;
      {
#line 81
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 81
        if (! (id < nargs)) {
#line 81
          goto while_break___0;
        }
#line 82
        tmp = strcmp((char const   *)args[id], (char const   *)"id");
#line 82
        if (! tmp) {
#line 83
          goto while_break___0;
        }
#line 81
        id ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 84
      if (id >= nargs) {
#line 85
        id = 0;
      }
#line 86
      SetBoard((TREE *)tree, nargs, args, 0);
#line 87
      tree->status[0].castle[1] = (int8_t )0;
#line 88
      tree->status[1].castle[1] = (int8_t )0;
#line 89
      tree->status[0].castle[0] = (int8_t )0;
#line 90
      tree->status[1].castle[0] = (int8_t )0;
#line 91
      tree->pawn_score.key = (uint64_t )0;
#line 92
      root_wtm = game_wtm;
#line 93
      s1 = Evaluate((TREE *)tree, 0, game_wtm, -99999, 99999);
#line 94
      strcpy(buffer, (char const   *)"flop");
#line 95
      Option((TREE *)tree);
#line 96
      tree->pawn_score.key = (uint64_t )0;
#line 97
      root_wtm = game_wtm;
#line 98
      s2 = Evaluate((TREE *)tree, 0, game_wtm, -99999, 99999);
#line 99
      strcpy(buffer, (char const   *)"flip");
#line 100
      Option((TREE *)tree);
#line 101
      tree->pawn_score.key = (uint64_t )0;
#line 102
      root_wtm = game_wtm;
#line 103
      s3 = Evaluate((TREE *)tree, 0, game_wtm, -99999, 99999);
#line 104
      strcpy(buffer, (char const   *)"flop");
#line 105
      Option((TREE *)tree);
#line 106
      tree->pawn_score.key = (uint64_t )0;
#line 107
      root_wtm = game_wtm;
#line 108
      s4 = Evaluate((TREE *)tree, 0, game_wtm, -99999, 99999);
#line 119
      if (s1 != s2) {
#line 119
        goto _L___3;
      } else
#line 119
      if (s1 != s3) {
        _L___3: /* CIL Label */ 
#line 119
        goto _L___2;
      } else
#line 119
      if (s1 != s4) {
        _L___2: /* CIL Label */ 
#line 119
        goto _L___1;
      } else
#line 119
      if (s2 != s3) {
        _L___1: /* CIL Label */ 
#line 119
        goto _L___0;
      } else
#line 119
      if (s2 != s4) {
        _L___0: /* CIL Label */ 
#line 119
        goto _L;
      } else
#line 119
      if (s3 != s4) {
        _L: /* CIL Label */ 
#line 121
        strcpy(buffer, (char const   *)"flip");
#line 122
        Option((TREE *)tree);
#line 123
        printf((char const   *)"FEN = %s\n", buff);
#line 124
        DisplayChessBoard(stdout, tree->position);
#line 125
        if (id) {
#line 126
          Print(4095, "id=%s  ", args[id + 1]);
        }
#line 127
        Print(4095, "wtm=%d  score=%d  %d (flop)  %d (flip)  %d (flop)\n", game_wtm,
              s1, s2, s3, s4);
      }
    } else {
#line 68
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  input_stream = stdin;
#line 133
  return;
}
}
#line 20 "init.c"
void Initialize(void) 
{ 
  TREE *tree ;
  int j___0 ;
  int v ;
  int major ;
  int id ;
  int i ;
  int node ;
  int maj_min ;
  size_t tmp ;

  {
#line 27
  tree = block[0];
#line 28
  j___0 = 1;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (j___0 <= 256)) {
#line 28
      goto while_break;
    }
#line 29
    block[j___0] = (TREE *)((void *)0);
#line 28
    j___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  InitializeMasks();
#line 31
  InitializeMagic();
#line 32
  InitializeSMP();
#line 33
  InitializeAttackBoards();
#line 34
  InitializePawnMasks();
#line 35
  InitializeChessBoard(tree);
#line 36
  InitializeKillers();
#line 43
  tree->last[0] = tree->move_list;
#line 44
  tree->last[1] = tree->move_list;
#line 45
  sprintf(log_filename, (char const   *)"%s/book.bin", book_path);
#line 46
  book_file = fopen((char const   * __restrict  )(log_filename), (char const   * __restrict  )"rb+");
#line 47
  if (! book_file) {
#line 48
    book_file = fopen((char const   * __restrict  )(log_filename), (char const   * __restrict  )"rb");
#line 49
    if (! book_file) {
#line 50
      Print(2048, "unable to open book file [%s/book.bin].\n", book_path);
#line 51
      Print(32, "book is disabled\n");
    } else {
#line 53
      Print(2048, "unable to open book file [%s/book.bin] for \"write\".\n", book_path);
#line 55
      Print(32, "learning is disabled\n");
    }
  }
#line 58
  sprintf(log_filename, (char const   *)"%s/books.bin", book_path);
#line 59
  normal_bs_file = fopen((char const   * __restrict  )(log_filename), (char const   * __restrict  )"rb");
#line 60
  books_file = normal_bs_file;
#line 61
  if (! normal_bs_file) {
#line 62
    Print(32, "unable to open book file [%s/books.bin].\n", book_path);
  }
#line 63
  sprintf(log_filename, (char const   *)"%s/bookc.bin", book_path);
#line 64
  computer_bs_file = fopen((char const   * __restrict  )(log_filename), (char const   * __restrict  )"rb");
#line 65
  if (computer_bs_file) {
#line 66
    Print(32, "found computer opening book file [%s/bookc.bin].\n", book_path);
  }
#line 68
  if (book_file) {
#line 70
    fseek(book_file, - ((long )sizeof(int )), 2);
#line 71
    tmp = fread((void *)(& maj_min), (size_t )4, (size_t )1, book_file);
#line 71
    v = (int )tmp;
#line 72
    if (v <= 0) {
#line 73
      perror((char const   *)"Initialize() fread error: ");
    }
#line 74
    major = BookIn32((unsigned char *)(& maj_min));
#line 75
    major >>= 16;
#line 76
    if (major < 23) {
#line 77
      Print(4095, "\nERROR!  book.bin not made by version 23.0 or later\n");
#line 78
      fclose(book_file);
#line 79
      fclose(books_file);
#line 80
      book_file = (FILE *)0;
#line 81
      books_file = (FILE *)0;
    }
  }
#line 84
  id = InitializeGetLogID();
#line 85
  sprintf(log_filename, (char const   *)"%s/log.%03d", log_path, id);
#line 86
  sprintf(history_filename, (char const   *)"%s/game.%03d", log_path, id);
#line 87
  log_file = fopen((char const   * __restrict  )(log_filename), (char const   * __restrict  )"w");
#line 88
  history_file = fopen((char const   * __restrict  )(history_filename), (char const   * __restrict  )"w+");
#line 89
  if (! history_file) {
#line 90
    printf((char const   *)"ERROR, unable to open game history file, exiting\n");
#line 91
    CraftyExit(1);
  }
#line 93
  AlignedMalloc((void **)((void *)(& hash_table)), (uint64_t )64, sizeof(HASH_ENTRY ) * hash_table_size);
#line 95
  AlignedMalloc((void **)((void *)(& hash_path)), (uint64_t )64, sizeof(HPATH_ENTRY ) * hash_path_size);
#line 97
  AlignedMalloc((void **)((void *)(& pawn_hash_table)), (uint64_t )64, sizeof(PAWN_HASH_ENTRY ) * pawn_hash_table_size);
#line 99
  if (! hash_table) {
#line 100
    Print(2048, "AlignedMalloc() failed, not enough memory (primary trans/ref table).\n");
#line 102
    hash_table_size = (size_t )0;
#line 103
    hash_table = (HASH_ENTRY *)0;
  }
#line 105
  if (! pawn_hash_table) {
#line 106
    Print(2048, "AlignedMalloc() failed, not enough memory (pawn hash table).\n");
#line 108
    pawn_hash_table_size = (size_t )0;
#line 109
    pawn_hash_table = (PAWN_HASH_ENTRY *)0;
  }
#line 131
  ThreadAffinity(smp_affinity);
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! (i < 4)) {
#line 135
      goto while_break___0;
    }
#line 136
    j___0 = 0;
    {
#line 136
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 136
      if (! (j___0 < 64)) {
#line 136
        goto while_break___1;
      }
#line 137
      AlignedMalloc((void **)(& block[(i * 64 + j___0) + 1]), (uint64_t )2048, sizeof(TREE ));
#line 136
      j___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 135
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 141
  i = 1;
  {
#line 141
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 141
    if (! (i < 64)) {
#line 141
      goto while_break___2;
    }
#line 142
    memset((void *)((char *)block[i]), 0, sizeof(TREE ));
#line 143
    (block[i])->lock = (int volatile   )0;
#line 141
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 145
  node = 1;
  {
#line 145
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 145
    if (! (node < 4)) {
#line 145
      goto while_break___3;
    }
#line 146
    ThreadAffinity(node);
#line 147
    i = 0;
    {
#line 147
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 147
      if (! (i < 64)) {
#line 147
        goto while_break___4;
      }
#line 148
      memset((void *)((char *)block[node * 64 + i]), 0, sizeof(TREE ));
#line 149
      (block[node * 64 + i])->lock = (int volatile   )0;
#line 147
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 145
    node ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 152
  ThreadAffinity(0);
#line 155
  thread[0].blocks = (uint64_t )0xffffffffffffffffull;
#line 156
  initialized_threads += (int volatile   )1;
#line 157
  InitializeHashTables(1);
#line 158
  InitializeKingSafety();
#line 159
  InitializeLMP();
#line 160
  InitializeLMR();
#line 161
  return;
}
}
#line 174 "init.c"
static int const   knightsq[8]  = 
#line 174
  {      (int const   )-17,      (int const   )-15,      (int const   )-10,      (int const   )-6, 
        (int const   )6,      (int const   )10,      (int const   )15,      (int const   )17};
#line 175 "init.c"
static int const   bishopsq[4]  = {      (int const   )-9,      (int const   )-7,      (int const   )7,      (int const   )9};
#line 176 "init.c"
static int const   rooksq[4]  = {      (int const   )-8,      (int const   )-1,      (int const   )1,      (int const   )8};
#line 171 "init.c"
void InitializeAttackBoards(void) 
{ 
  int i ;
  int j___0 ;
  int d ;
  int s ;
  int t ;
  int frank ;
  int ffile ;
  int trank ;
  int tfile ;
  int sq ;
  int lastsq ;
  uint64_t sqs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 182
  i = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < 64)) {
#line 182
      goto while_break;
    }
#line 183
    pawn_attacks[1][i] = (uint64_t )0;
#line 184
    if (i < 56) {
#line 185
      j___0 = 2;
      {
#line 185
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 185
        if (! (j___0 < 4)) {
#line 185
          goto while_break___0;
        }
#line 186
        sq = i + (int )bishopsq[j___0];
#line 187
        if ((sq >> 3) - (i >> 3) > 0) {
#line 187
          tmp = (sq >> 3) - (i >> 3);
        } else {
#line 187
          tmp = - ((sq >> 3) - (i >> 3));
        }
#line 187
        if (tmp == 1) {
#line 187
          if ((sq & 7) - (i & 7) > 0) {
#line 187
            tmp___0 = (sq & 7) - (i & 7);
          } else {
#line 187
            tmp___0 = - ((sq & 7) - (i & 7));
          }
#line 187
          if (tmp___0 == 1) {
#line 187
            if (sq < 64) {
#line 187
              if (sq > -1) {
#line 189
                pawn_attacks[1][i] |= 1UL << sq;
              } else {
#line 187
                goto _L___1;
              }
            } else {
#line 187
              goto _L___1;
            }
          } else {
#line 187
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          _L___0: /* CIL Label */ 
          _L: /* CIL Label */ ;
        }
#line 185
        j___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 192
    pawn_attacks[0][i] = (uint64_t )0;
#line 193
    if (i > 7) {
#line 194
      j___0 = 0;
      {
#line 194
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 194
        if (! (j___0 < 2)) {
#line 194
          goto while_break___1;
        }
#line 195
        sq = i + (int )bishopsq[j___0];
#line 196
        if ((sq >> 3) - (i >> 3) > 0) {
#line 196
          tmp___1 = (sq >> 3) - (i >> 3);
        } else {
#line 196
          tmp___1 = - ((sq >> 3) - (i >> 3));
        }
#line 196
        if (tmp___1 == 1) {
#line 196
          if ((sq & 7) - (i & 7) > 0) {
#line 196
            tmp___2 = (sq & 7) - (i & 7);
          } else {
#line 196
            tmp___2 = - ((sq & 7) - (i & 7));
          }
#line 196
          if (tmp___2 == 1) {
#line 196
            if (sq < 64) {
#line 196
              if (sq > -1) {
#line 198
                pawn_attacks[0][i] |= 1UL << sq;
              } else {
#line 196
                goto _L___4;
              }
            } else {
#line 196
              goto _L___4;
            }
          } else {
#line 196
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          _L___3: /* CIL Label */ 
          _L___2: /* CIL Label */ ;
        }
#line 194
        j___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 182
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  i = 0;
  {
#line 205
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 205
    if (! (i < 64)) {
#line 205
      goto while_break___2;
    }
#line 206
    knight_attacks[i] = (uint64_t )0;
#line 207
    frank = i >> 3;
#line 208
    ffile = i & 7;
#line 209
    j___0 = 0;
    {
#line 209
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 209
      if (! (j___0 < 8)) {
#line 209
        goto while_break___3;
      }
#line 210
      sq = i + (int )knightsq[j___0];
#line 211
      if (sq < 0) {
#line 211
        goto _L___5;
      } else
#line 211
      if (sq > 63) {
        _L___5: /* CIL Label */ 
#line 212
        goto __Cont;
      }
#line 213
      trank = sq >> 3;
#line 214
      tfile = sq & 7;
#line 215
      if (frank - trank > 0) {
#line 215
        tmp___3 = frank - trank;
      } else {
#line 215
        tmp___3 = - (frank - trank);
      }
#line 215
      if (tmp___3 > 2) {
#line 215
        goto _L___6;
      } else {
#line 215
        if (ffile - tfile > 0) {
#line 215
          tmp___4 = ffile - tfile;
        } else {
#line 215
          tmp___4 = - (ffile - tfile);
        }
#line 215
        if (tmp___4 > 2) {
          _L___6: /* CIL Label */ 
#line 216
          goto __Cont;
        }
      }
#line 217
      knight_attacks[i] |= 1UL << sq;
      __Cont: /* CIL Label */ 
#line 209
      j___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 205
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 223
  i = 0;
  {
#line 223
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 223
    if (! (i < 64)) {
#line 223
      goto while_break___4;
    }
#line 224
    j___0 = 0;
    {
#line 224
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 224
      if (! (j___0 < 4)) {
#line 224
        goto while_break___5;
      }
#line 225
      sq = i;
#line 226
      lastsq = sq;
#line 227
      sq += (int )bishopsq[j___0];
      {
#line 228
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 228
        if ((sq >> 3) - (lastsq >> 3) > 0) {
#line 228
          tmp___5 = (sq >> 3) - (lastsq >> 3);
        } else {
#line 228
          tmp___5 = - ((sq >> 3) - (lastsq >> 3));
        }
#line 228
        if (tmp___5 == 1) {
#line 228
          if ((sq & 7) - (lastsq & 7) > 0) {
#line 228
            tmp___6 = (sq & 7) - (lastsq & 7);
          } else {
#line 228
            tmp___6 = - ((sq & 7) - (lastsq & 7));
          }
#line 228
          if (tmp___6 == 1) {
#line 228
            if (sq < 64) {
#line 228
              if (! (sq > -1)) {
#line 228
                goto _L___9;
              }
            } else {
#line 228
              goto _L___9;
            }
          } else {
#line 228
            goto _L___9;
          }
        } else {
          _L___9: /* CIL Label */ 
          _L___8: /* CIL Label */ 
          _L___7: /* CIL Label */ 
#line 228
          goto while_break___6;
        }
#line 230
        if (bishopsq[j___0] == 7) {
#line 231
          plus7dir[i] |= 1UL << sq;
        } else
#line 232
        if (bishopsq[j___0] == 9) {
#line 233
          plus9dir[i] |= 1UL << sq;
        } else
#line 234
        if (bishopsq[j___0] == -7) {
#line 235
          minus7dir[i] |= 1UL << sq;
        } else {
#line 237
          minus9dir[i] |= 1UL << sq;
        }
#line 238
        lastsq = sq;
#line 239
        sq += (int )bishopsq[j___0];
      }
      while_break___6: /* CIL Label */ ;
      }
#line 224
      j___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 223
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 243
  plus1dir[64] = (uint64_t )0;
#line 244
  plus7dir[64] = (uint64_t )0;
#line 245
  plus8dir[64] = (uint64_t )0;
#line 246
  plus9dir[64] = (uint64_t )0;
#line 247
  minus1dir[64] = (uint64_t )0;
#line 248
  minus7dir[64] = (uint64_t )0;
#line 249
  minus8dir[64] = (uint64_t )0;
#line 250
  minus9dir[64] = (uint64_t )0;
#line 254
  i = 0;
  {
#line 254
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 254
    if (! (i < 64)) {
#line 254
      goto while_break___7;
    }
#line 255
    j___0 = 0;
    {
#line 255
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 255
      if (! (j___0 < 4)) {
#line 255
        goto while_break___8;
      }
#line 256
      sq = i;
#line 257
      lastsq = sq;
#line 258
      sq += (int )rooksq[j___0];
      {
#line 259
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 259
        if ((sq >> 3) - (lastsq >> 3) > 0) {
#line 259
          tmp___7 = (sq >> 3) - (lastsq >> 3);
        } else {
#line 259
          tmp___7 = - ((sq >> 3) - (lastsq >> 3));
        }
#line 259
        if (tmp___7 == 1) {
#line 259
          if ((sq & 7) - (lastsq & 7) > 0) {
#line 259
            tmp___8 = (sq & 7) - (lastsq & 7);
          } else {
#line 259
            tmp___8 = - ((sq & 7) - (lastsq & 7));
          }
#line 259
          if (tmp___8 == 0) {
#line 259
            goto _L___12;
          } else {
#line 259
            goto _L___14;
          }
        } else {
          _L___14: /* CIL Label */ 
#line 259
          if ((sq >> 3) - (lastsq >> 3) > 0) {
#line 259
            tmp___9 = (sq >> 3) - (lastsq >> 3);
          } else {
#line 259
            tmp___9 = - ((sq >> 3) - (lastsq >> 3));
          }
#line 259
          if (tmp___9 == 0) {
#line 259
            if ((sq & 7) - (lastsq & 7) > 0) {
#line 259
              tmp___10 = (sq & 7) - (lastsq & 7);
            } else {
#line 259
              tmp___10 = - ((sq & 7) - (lastsq & 7));
            }
#line 259
            if (tmp___10 == 1) {
              _L___12: /* CIL Label */ 
#line 259
              if (sq < 64) {
#line 259
                if (! (sq > -1)) {
#line 259
                  goto _L___13;
                }
              } else {
#line 259
                goto _L___13;
              }
            } else {
#line 259
              goto _L___13;
            }
          } else {
            _L___13: /* CIL Label */ 
            _L___11: /* CIL Label */ 
            _L___10: /* CIL Label */ 
#line 259
            goto while_break___9;
          }
        }
#line 263
        if (rooksq[j___0] == 1) {
#line 264
          plus1dir[i] |= 1UL << sq;
        } else
#line 265
        if (rooksq[j___0] == 8) {
#line 266
          plus8dir[i] |= 1UL << sq;
        } else
#line 267
        if (rooksq[j___0] == -1) {
#line 268
          minus1dir[i] |= 1UL << sq;
        } else {
#line 270
          minus8dir[i] |= 1UL << sq;
        }
#line 271
        lastsq = sq;
#line 272
        sq += (int )rooksq[j___0];
      }
      while_break___9: /* CIL Label */ ;
      }
#line 255
      j___0 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 254
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 279
  i = 0;
  {
#line 279
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 279
    if (! (i < 64)) {
#line 279
      goto while_break___10;
    }
#line 280
    bishop_attacks[i] = ((plus9dir[i] | minus9dir[i]) | plus7dir[i]) | minus7dir[i];
#line 279
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 286
  i = 0;
  {
#line 286
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 286
    if (! (i < 64)) {
#line 286
      goto while_break___11;
    }
#line 287
    rook_attacks[i] = file_mask[i & 7] | rank_mask[i >> 3];
#line 286
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 292
  i = 0;
  {
#line 292
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 292
    if (! (i < 64)) {
#line 292
      goto while_break___12;
    }
#line 293
    king_attacks[i] = (uint64_t )0;
#line 294
    j___0 = 0;
    {
#line 294
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 294
      if (! (j___0 < 64)) {
#line 294
        goto while_break___13;
      }
#line 295
      tmp___16 = abs((i & 7) - (j___0 & 7));
#line 295
      tmp___17 = abs((i >> 3) - (j___0 >> 3));
#line 295
      if (tmp___16 > tmp___17) {
#line 295
        tmp___13 = abs((i & 7) - (j___0 & 7));
#line 295
        tmp___15 = tmp___13;
      } else {
#line 295
        tmp___14 = abs((i >> 3) - (j___0 >> 3));
#line 295
        tmp___15 = tmp___14;
      }
#line 295
      if (tmp___15 == 1) {
#line 296
        king_attacks[i] |= set_mask[j___0];
      }
#line 294
      j___0 ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 292
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 307
    if (! (i < 64)) {
#line 307
      goto while_break___14;
    }
#line 308
    j___0 = 0;
    {
#line 308
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 308
      if (! (j___0 < 64)) {
#line 308
        goto while_break___15;
      }
#line 309
      intervening[i][j___0] = (uint64_t )0;
#line 308
      j___0 ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 310
    sqs = plus1dir[i];
    {
#line 311
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 311
      if (! sqs) {
#line 311
        goto while_break___16;
      }
#line 312
      j___0 = __builtin_ctzll((unsigned long long )sqs);
#line 313
      directions[i][j___0] = (int8_t )1;
#line 314
      intervening[i][j___0] = plus1dir[i] ^ plus1dir[j___0 - 1];
#line 315
      sqs &= sqs - 1UL;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 317
    sqs = plus7dir[i];
    {
#line 318
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 318
      if (! sqs) {
#line 318
        goto while_break___17;
      }
#line 319
      j___0 = __builtin_ctzll((unsigned long long )sqs);
#line 320
      directions[i][j___0] = (int8_t )7;
#line 321
      intervening[i][j___0] = plus7dir[i] ^ plus7dir[j___0 - 7];
#line 322
      sqs &= sqs - 1UL;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 324
    sqs = plus8dir[i];
    {
#line 325
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 325
      if (! sqs) {
#line 325
        goto while_break___18;
      }
#line 326
      j___0 = __builtin_ctzll((unsigned long long )sqs);
#line 327
      directions[i][j___0] = (int8_t )8;
#line 328
      intervening[i][j___0] = plus8dir[i] ^ plus8dir[j___0 - 8];
#line 329
      sqs &= sqs - 1UL;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 331
    sqs = plus9dir[i];
    {
#line 332
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 332
      if (! sqs) {
#line 332
        goto while_break___19;
      }
#line 333
      j___0 = __builtin_ctzll((unsigned long long )sqs);
#line 334
      directions[i][j___0] = (int8_t )9;
#line 335
      intervening[i][j___0] = plus9dir[i] ^ plus9dir[j___0 - 9];
#line 336
      sqs &= sqs - 1UL;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 338
    sqs = minus1dir[i];
    {
#line 339
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 339
      if (! sqs) {
#line 339
        goto while_break___20;
      }
#line 340
      j___0 = __builtin_ctzll((unsigned long long )sqs);
#line 341
      directions[i][j___0] = (int8_t )-1;
#line 342
      intervening[i][j___0] = minus1dir[i] ^ minus1dir[j___0 + 1];
#line 343
      sqs &= sqs - 1UL;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 345
    sqs = minus7dir[i];
    {
#line 346
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 346
      if (! sqs) {
#line 346
        goto while_break___21;
      }
#line 347
      j___0 = __builtin_ctzll((unsigned long long )sqs);
#line 348
      directions[i][j___0] = (int8_t )-7;
#line 349
      intervening[i][j___0] = minus7dir[i] ^ minus7dir[j___0 + 7];
#line 350
      sqs &= sqs - 1UL;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 352
    sqs = minus8dir[i];
    {
#line 353
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 353
      if (! sqs) {
#line 353
        goto while_break___22;
      }
#line 354
      j___0 = __builtin_ctzll((unsigned long long )sqs);
#line 355
      directions[i][j___0] = (int8_t )-8;
#line 356
      intervening[i][j___0] = minus8dir[i] ^ minus8dir[j___0 + 8];
#line 357
      sqs &= sqs - 1UL;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 359
    sqs = minus9dir[i];
    {
#line 360
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 360
      if (! sqs) {
#line 360
        goto while_break___23;
      }
#line 361
      j___0 = __builtin_ctzll((unsigned long long )sqs);
#line 362
      directions[i][j___0] = (int8_t )-9;
#line 363
      intervening[i][j___0] = minus9dir[i] ^ minus9dir[j___0 + 9];
#line 364
      sqs &= sqs - 1UL;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 307
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 374
  s = 0;
  {
#line 374
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 374
    if (! (s < 64)) {
#line 374
      goto while_break___24;
    }
#line 375
    distance_ring[s][0] = set_mask[s];
#line 376
    d = 1;
    {
#line 376
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 376
      if (! (d < 8)) {
#line 376
        goto while_break___25;
      }
#line 377
      distance_ring[s][d] = (uint64_t )0;
#line 378
      t = 0;
      {
#line 378
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 378
        if (! (t < 64)) {
#line 378
          goto while_break___26;
        }
#line 379
        tmp___23 = abs((s & 7) - (t & 7));
#line 379
        tmp___24 = abs((s >> 3) - (t >> 3));
#line 379
        if (tmp___23 > tmp___24) {
#line 379
          tmp___20 = abs((s & 7) - (t & 7));
#line 379
          tmp___22 = tmp___20;
        } else {
#line 379
          tmp___21 = abs((s >> 3) - (t >> 3));
#line 379
          tmp___22 = tmp___21;
        }
#line 379
        if (tmp___22 == d) {
#line 380
          distance_ring[s][d] |= set_mask[t];
        }
#line 378
        t ++;
      }
      while_break___26: /* CIL Label */ ;
      }
#line 376
      d ++;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 374
    s ++;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 383
  return;
}
}
#line 396 "init.c"
void InitializeMagic(void) 
{ 
  int i ;
  int j___0 ;
  int m ;
  int initmagicmoves_bitpos64_database[64] ;
  int squares___0[64] ;
  int numsquares ;
  uint64_t temp ;
  uint64_t abit ;
  int tmp ;
  uint64_t moves ;
  uint64_t tempoccupied ;
  uint64_t tmp___0 ;
  int tmp___1 ;
  int squares___1[64] ;
  int numsquares___0 ;
  uint64_t temp___0 ;
  uint64_t abit___0 ;
  int tmp___2 ;
  uint64_t tempoccupied___0 ;
  uint64_t tmp___3 ;
  uint64_t moves___0 ;
  uint64_t tmp___4 ;
  int tmp___5 ;

  {
#line 398
  initmagicmoves_bitpos64_database[0] = 63;
#line 398
  initmagicmoves_bitpos64_database[1] = 0;
#line 398
  initmagicmoves_bitpos64_database[2] = 58;
#line 398
  initmagicmoves_bitpos64_database[3] = 1;
#line 398
  initmagicmoves_bitpos64_database[4] = 59;
#line 398
  initmagicmoves_bitpos64_database[5] = 47;
#line 398
  initmagicmoves_bitpos64_database[6] = 53;
#line 398
  initmagicmoves_bitpos64_database[7] = 2;
#line 398
  initmagicmoves_bitpos64_database[8] = 60;
#line 398
  initmagicmoves_bitpos64_database[9] = 39;
#line 398
  initmagicmoves_bitpos64_database[10] = 48;
#line 398
  initmagicmoves_bitpos64_database[11] = 27;
#line 398
  initmagicmoves_bitpos64_database[12] = 54;
#line 398
  initmagicmoves_bitpos64_database[13] = 33;
#line 398
  initmagicmoves_bitpos64_database[14] = 42;
#line 398
  initmagicmoves_bitpos64_database[15] = 3;
#line 398
  initmagicmoves_bitpos64_database[16] = 61;
#line 398
  initmagicmoves_bitpos64_database[17] = 51;
#line 398
  initmagicmoves_bitpos64_database[18] = 37;
#line 398
  initmagicmoves_bitpos64_database[19] = 40;
#line 398
  initmagicmoves_bitpos64_database[20] = 49;
#line 398
  initmagicmoves_bitpos64_database[21] = 18;
#line 398
  initmagicmoves_bitpos64_database[22] = 28;
#line 398
  initmagicmoves_bitpos64_database[23] = 20;
#line 398
  initmagicmoves_bitpos64_database[24] = 55;
#line 398
  initmagicmoves_bitpos64_database[25] = 30;
#line 398
  initmagicmoves_bitpos64_database[26] = 34;
#line 398
  initmagicmoves_bitpos64_database[27] = 11;
#line 398
  initmagicmoves_bitpos64_database[28] = 43;
#line 398
  initmagicmoves_bitpos64_database[29] = 14;
#line 398
  initmagicmoves_bitpos64_database[30] = 22;
#line 398
  initmagicmoves_bitpos64_database[31] = 4;
#line 398
  initmagicmoves_bitpos64_database[32] = 62;
#line 398
  initmagicmoves_bitpos64_database[33] = 57;
#line 398
  initmagicmoves_bitpos64_database[34] = 46;
#line 398
  initmagicmoves_bitpos64_database[35] = 52;
#line 398
  initmagicmoves_bitpos64_database[36] = 38;
#line 398
  initmagicmoves_bitpos64_database[37] = 26;
#line 398
  initmagicmoves_bitpos64_database[38] = 32;
#line 398
  initmagicmoves_bitpos64_database[39] = 41;
#line 398
  initmagicmoves_bitpos64_database[40] = 50;
#line 398
  initmagicmoves_bitpos64_database[41] = 36;
#line 398
  initmagicmoves_bitpos64_database[42] = 17;
#line 398
  initmagicmoves_bitpos64_database[43] = 19;
#line 398
  initmagicmoves_bitpos64_database[44] = 29;
#line 398
  initmagicmoves_bitpos64_database[45] = 10;
#line 398
  initmagicmoves_bitpos64_database[46] = 13;
#line 398
  initmagicmoves_bitpos64_database[47] = 21;
#line 398
  initmagicmoves_bitpos64_database[48] = 56;
#line 398
  initmagicmoves_bitpos64_database[49] = 45;
#line 398
  initmagicmoves_bitpos64_database[50] = 25;
#line 398
  initmagicmoves_bitpos64_database[51] = 31;
#line 398
  initmagicmoves_bitpos64_database[52] = 35;
#line 398
  initmagicmoves_bitpos64_database[53] = 16;
#line 398
  initmagicmoves_bitpos64_database[54] = 9;
#line 398
  initmagicmoves_bitpos64_database[55] = 12;
#line 398
  initmagicmoves_bitpos64_database[56] = 44;
#line 398
  initmagicmoves_bitpos64_database[57] = 24;
#line 398
  initmagicmoves_bitpos64_database[58] = 15;
#line 398
  initmagicmoves_bitpos64_database[59] = 8;
#line 398
  initmagicmoves_bitpos64_database[60] = 23;
#line 398
  initmagicmoves_bitpos64_database[61] = 7;
#line 398
  initmagicmoves_bitpos64_database[62] = 6;
#line 398
  initmagicmoves_bitpos64_database[63] = 5;
#line 411
  i = 0;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! (i < 64)) {
#line 411
      goto while_break;
    }
#line 413
    numsquares = 0;
#line 414
    temp = (uint64_t )magic_bishop_mask[i];
    {
#line 416
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 416
      if (! temp) {
#line 416
        goto while_break___0;
      }
#line 417
      abit = temp & - temp;
#line 419
      tmp = numsquares;
#line 419
      numsquares ++;
#line 419
      squares___0[tmp] = initmagicmoves_bitpos64_database[(unsigned long long )abit * 0x07EDD5E59A4E28C2ull >> 58];
#line 422
      temp ^= abit;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 424
    temp = (uint64_t )0;
    {
#line 424
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 424
      if (! (temp < 1UL << numsquares)) {
#line 424
        goto while_break___1;
      }
#line 426
      tmp___0 = InitializeMagicOccupied(squares___0, numsquares, temp);
#line 426
      tempoccupied = tmp___0;
#line 428
      moves = InitializeMagicBishop(i, tempoccupied);
#line 429
      *(magic_bishop_indices[i] + (tempoccupied * (uint64_t )magic_bishop[i] >> magic_bishop_shift[i])) = moves;
#line 431
      moves |= set_mask[i];
#line 432
      m = (int )(- lower_b);
#line 433
      j___0 = 0;
      {
#line 433
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 433
        if (! (j___0 < 4)) {
#line 433
          goto while_break___2;
        }
#line 434
        tmp___1 = __builtin_popcountll((unsigned long long )(moves & (unsigned long )mobility_mask_b[j___0]));
#line 434
        m += tmp___1 * (int )mobility_score_b[j___0];
#line 433
        j___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 435
      if (m < 0) {
#line 436
        m *= 2;
      }
#line 437
      *(magic_bishop_mobility_indices[i] + (tempoccupied * (uint64_t )magic_bishop[i] >> magic_bishop_shift[i])) = (int16_t )m;
#line 424
      temp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 411
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  i = 0;
  {
#line 444
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 444
    if (! (i < 64)) {
#line 444
      goto while_break___3;
    }
#line 446
    numsquares___0 = 0;
#line 447
    temp___0 = (uint64_t )magic_rook_mask[i];
    {
#line 449
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 449
      if (! temp___0) {
#line 449
        goto while_break___4;
      }
#line 450
      abit___0 = temp___0 & - temp___0;
#line 452
      tmp___2 = numsquares___0;
#line 452
      numsquares___0 ++;
#line 452
      squares___1[tmp___2] = initmagicmoves_bitpos64_database[(unsigned long long )abit___0 * 0x07EDD5E59A4E28C2ull >> 58];
#line 455
      temp___0 ^= abit___0;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 457
    temp___0 = (uint64_t )0;
    {
#line 457
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 457
      if (! (temp___0 < 1UL << numsquares___0)) {
#line 457
        goto while_break___5;
      }
#line 458
      tmp___3 = InitializeMagicOccupied(squares___1, numsquares___0, temp___0);
#line 458
      tempoccupied___0 = tmp___3;
#line 460
      tmp___4 = InitializeMagicRook(i, tempoccupied___0);
#line 460
      moves___0 = tmp___4;
#line 461
      *(magic_rook_indices[i] + (tempoccupied___0 * (uint64_t )magic_rook[i] >> magic_rook_shift[i])) = moves___0;
#line 463
      moves___0 |= set_mask[i];
#line 464
      m = -1;
#line 465
      j___0 = 0;
      {
#line 465
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 465
        if (! (j___0 < 4)) {
#line 465
          goto while_break___6;
        }
#line 466
        tmp___5 = __builtin_popcountll((unsigned long long )(moves___0 & (unsigned long )mobility_mask_r[j___0]));
#line 466
        m += tmp___5 * (int )mobility_score_r[j___0];
#line 465
        j___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 467
      *(magic_rook_mobility_indices[i] + (tempoccupied___0 * (uint64_t )magic_rook[i] >> magic_rook_shift[i])) = (int16_t )mob_curve_r[m];
#line 457
      temp___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 444
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 472
  return;
}
}
#line 482 "init.c"
uint64_t InitializeMagicBishop(int square , uint64_t occupied___0 ) 
{ 
  uint64_t ret ;
  uint64_t abit ;
  uint64_t abit2 ;
  uint64_t rowbits ;

  {
#line 483
  ret = (uint64_t )0;
#line 486
  rowbits = 255UL << 8 * (square / 8);
#line 488
  abit = 1UL << square;
#line 489
  abit2 = abit;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    abit <<= 7;
#line 492
    abit2 >>= 1;
#line 493
    if (abit2 & rowbits) {
#line 494
      ret |= abit;
    } else {
#line 496
      goto while_break;
    }
#line 490
    if (abit) {
#line 490
      if (! (! (abit & occupied___0))) {
#line 490
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 490
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 498
  abit = 1UL << square;
#line 499
  abit2 = abit;
  {
#line 500
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 501
    abit <<= 9;
#line 502
    abit2 <<= 1;
#line 503
    if (abit2 & rowbits) {
#line 504
      ret |= abit;
    } else {
#line 506
      goto while_break___0;
    }
#line 500
    if (abit) {
#line 500
      if (! (! (abit & occupied___0))) {
#line 500
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 500
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 508
  abit = 1UL << square;
#line 509
  abit2 = abit;
  {
#line 510
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 511
    abit >>= 7;
#line 512
    abit2 <<= 1;
#line 513
    if (abit2 & rowbits) {
#line 514
      ret |= abit;
    } else {
#line 516
      goto while_break___1;
    }
#line 510
    if (abit) {
#line 510
      if (! (! (abit & occupied___0))) {
#line 510
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 510
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 518
  abit = 1UL << square;
#line 519
  abit2 = abit;
  {
#line 520
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 521
    abit >>= 9;
#line 522
    abit2 >>= 1;
#line 523
    if (abit2 & rowbits) {
#line 524
      ret |= abit;
    } else {
#line 526
      goto while_break___2;
    }
#line 520
    if (abit) {
#line 520
      if (! (! (abit & occupied___0))) {
#line 520
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 520
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 528
  return (ret);
}
}
#line 539 "init.c"
uint64_t InitializeMagicOccupied(int *squares___0 , int numSquares , uint64_t linoccupied ) 
{ 
  int i ;
  uint64_t ret ;

  {
#line 542
  ret = (uint64_t )0;
#line 544
  i = 0;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    if (! (i < numSquares)) {
#line 544
      goto while_break;
    }
#line 545
    if (linoccupied & (1UL << i)) {
#line 546
      ret |= 1UL << *(squares___0 + i);
    }
#line 544
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  return (ret);
}
}
#line 558 "init.c"
uint64_t InitializeMagicRook(int square , uint64_t occupied___0 ) 
{ 
  uint64_t ret ;
  uint64_t abit ;
  uint64_t rowbits ;

  {
#line 559
  ret = (uint64_t )0;
#line 561
  rowbits = 255UL << 8 * (square / 8);
#line 563
  abit = 1UL << square;
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    abit <<= 8;
#line 566
    ret |= abit;
#line 564
    if (abit) {
#line 564
      if (! (! (abit & occupied___0))) {
#line 564
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 564
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  abit = 1UL << square;
  {
#line 569
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 570
    abit >>= 8;
#line 571
    ret |= abit;
#line 569
    if (abit) {
#line 569
      if (! (! (abit & occupied___0))) {
#line 569
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 569
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 573
  abit = 1UL << square;
  {
#line 574
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 575
    abit <<= 1;
#line 576
    if (abit & rowbits) {
#line 577
      ret |= abit;
    } else {
#line 579
      goto while_break___1;
    }
#line 574
    if (! (! (abit & occupied___0))) {
#line 574
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 581
  abit = 1UL << square;
  {
#line 582
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 583
    abit >>= 1;
#line 584
    if (abit & rowbits) {
#line 585
      ret |= abit;
    } else {
#line 587
      goto while_break___2;
    }
#line 582
    if (! (! (abit & occupied___0))) {
#line 582
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 589
  return (ret);
}
}
#line 601 "init.c"
void InitializeChessBoard(TREE *tree ) 
{ 
  int i ;
  int nargs___0 ;
  size_t tmp ;

  {
#line 604
  tmp = strlen((char const   *)(initial_position));
#line 604
  if (tmp) {
#line 607
    nargs___0 = ReadParse(initial_position, args, " \t;");
#line 608
    SetBoard(tree, nargs___0, args, 1);
  } else {
#line 610
    i = 0;
    {
#line 610
    while (1) {
      while_continue: /* CIL Label */ ;
#line 610
      if (! (i < 64)) {
#line 610
        goto while_break;
      }
#line 611
      tree->position.board[i] = (int8_t )0;
#line 610
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 612
    game_wtm = 1;
#line 616
    i = 0;
    {
#line 616
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 616
      if (! (i < 8)) {
#line 616
        goto while_break___0;
      }
#line 617
      tree->position.board[i + 8] = (int8_t )1;
#line 618
      tree->position.board[i + 48] = (int8_t )-1;
#line 616
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 623
    tree->position.board[1] = (int8_t )2;
#line 624
    tree->position.board[6] = (int8_t )2;
#line 625
    tree->position.board[57] = (int8_t )-2;
#line 626
    tree->position.board[62] = (int8_t )-2;
#line 630
    tree->position.board[2] = (int8_t )3;
#line 631
    tree->position.board[5] = (int8_t )3;
#line 632
    tree->position.board[58] = (int8_t )-3;
#line 633
    tree->position.board[61] = (int8_t )-3;
#line 637
    tree->position.board[0] = (int8_t )4;
#line 638
    tree->position.board[7] = (int8_t )4;
#line 639
    tree->position.board[56] = (int8_t )-4;
#line 640
    tree->position.board[63] = (int8_t )-4;
#line 644
    tree->position.board[3] = (int8_t )5;
#line 645
    tree->position.board[59] = (int8_t )-5;
#line 649
    tree->position.board[4] = (int8_t )6;
#line 650
    tree->position.board[60] = (int8_t )-6;
#line 654
    tree->status[0].castle[0] = (int8_t )3;
#line 655
    tree->status[0].castle[1] = (int8_t )3;
#line 659
    tree->status[0].enpassant_target = (uint8_t )0;
#line 663
    SetChessBitBoards(tree);
  }
#line 668
  tree->status[0].reversible = (uint8_t )0;
#line 669
  rep_index = 0;
#line 670
  tree->rep_list[0] = tree->position.hash_key;
#line 671
  return;
}
}
#line 681 "init.c"
void SetChessBitBoards(TREE *tree ) 
{ 
  int side ;
  int piece ;
  int square ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 684
  tree->position.hash_key = (uint64_t )0;
#line 685
  tree->position.pawn_hash_key = (uint64_t )0;
#line 686
  tree->position.material_evaluation = 0;
#line 687
  side = 0;
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if (! (side <= 1)) {
#line 687
      goto while_break;
    }
#line 688
    piece = 0;
    {
#line 688
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 688
      if (! (piece <= 6)) {
#line 688
        goto while_break___0;
      }
#line 689
      tree->position.color[side].pieces[piece] = (uint64_t )0;
#line 688
      piece ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 687
    side ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 690
  square = 0;
  {
#line 690
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 690
    if (! (square < 64)) {
#line 690
      goto while_break___1;
    }
#line 691
    if (! tree->position.board[square]) {
#line 692
      goto __Cont;
    }
#line 693
    piece = (int )tree->position.board[square];
#line 694
    if (piece > 0) {
#line 694
      side = 1;
    } else {
#line 694
      side = 0;
    }
#line 695
    if (piece > 0) {
#line 695
      tmp = piece;
    } else {
#line 695
      tmp = - piece;
    }
#line 695
    tree->position.color[side].pieces[tmp] |= set_mask[square];
#line 696
    tree->position.color[side].pieces[0] |= set_mask[square];
#line 697
    if (piece > 0) {
#line 697
      tmp___0 = piece;
    } else {
#line 697
      tmp___0 = - piece;
    }
#line 697
    tree->position.hash_key ^= (unsigned long )randoms[side][tmp___0][square];
#line 698
    if (piece > 0) {
#line 698
      tmp___1 = piece;
    } else {
#line 698
      tmp___1 = - piece;
    }
#line 698
    if (tmp___1 == 1) {
#line 699
      tree->position.pawn_hash_key ^= (unsigned long )randoms[side][1][square];
    }
#line 700
    if (piece > 0) {
#line 700
      tmp___2 = piece;
    } else {
#line 700
      tmp___2 = - piece;
    }
#line 700
    tree->position.material_evaluation += piece_values[side][tmp___2];
    __Cont: /* CIL Label */ 
#line 690
    square ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 702
  if (tree->position.color[1].pieces[6]) {
#line 703
    tree->position.kingsq[1] = __builtin_ctzll((unsigned long long )tree->position.color[1].pieces[6]);
  }
#line 704
  if (tree->position.color[0].pieces[6]) {
#line 705
    tree->position.kingsq[0] = __builtin_ctzll((unsigned long long )tree->position.color[0].pieces[6]);
  }
#line 706
  if (tree->status[0].enpassant_target) {
#line 707
    tree->position.hash_key ^= (unsigned long )enpassant_random[tree->status[0].enpassant_target];
  }
#line 708
  if (! ((int )tree->status[0].castle[1] & 1)) {
#line 709
    tree->position.hash_key ^= (unsigned long )castle_random[0][1];
  }
#line 710
  if (! ((int )tree->status[0].castle[1] & 2)) {
#line 711
    tree->position.hash_key ^= (unsigned long )castle_random[1][1];
  }
#line 712
  if (! ((int )tree->status[0].castle[0] & 1)) {
#line 713
    tree->position.hash_key ^= (unsigned long )castle_random[0][0];
  }
#line 714
  if (! ((int )tree->status[0].castle[0] & 2)) {
#line 715
    tree->position.hash_key ^= (unsigned long )castle_random[1][0];
  }
#line 719
  side = 0;
  {
#line 719
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 719
    if (! (side <= 1)) {
#line 719
      goto while_break___2;
    }
#line 720
    piece = 1;
    {
#line 720
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 720
      if (! (piece <= 6)) {
#line 720
        goto while_break___3;
      }
#line 721
      tmp___3 = __builtin_popcountll((unsigned long long )tree->position.color[side].pieces[piece]);
#line 721
      tree->position.pieces[side][piece] = (char )tmp___3;
#line 720
      piece ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 719
    side ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 722
  side = 0;
  {
#line 722
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 722
    if (! (side <= 1)) {
#line 722
      goto while_break___4;
    }
#line 723
    tree->position.pieces[side][0] = (char)0;
#line 724
    piece = 2;
    {
#line 724
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 724
      if (! (piece < 6)) {
#line 724
        goto while_break___5;
      }
#line 725
      tmp___4 = __builtin_popcountll((unsigned long long )tree->position.color[side].pieces[piece]);
#line 725
      tree->position.pieces[side][0] = (char )((int )tree->position.pieces[side][0] + tmp___4 * (int )p_vals[piece]);
#line 724
      piece ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 722
    side ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 728
  tmp___5 = __builtin_popcountll((unsigned long long )(tree->position.color[1].pieces[0] | tree->position.color[0].pieces[0]));
#line 728
  tree->position.total_all_pieces = (char )tmp___5;
#line 729
  rep_index = 0;
#line 730
  tree->rep_list[0] = tree->position.hash_key;
#line 731
  return;
}
}
#line 744 "init.c"
int InitializeGetLogID(void) 
{ 
  int t ;
  int total_files ;
  struct stat *fileinfo ;
  void *tmp ;
  char tfn[128] ;
  FILE *tlog ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 745
  total_files = 0;
#line 747
  tmp = malloc(sizeof(struct stat ));
#line 747
  fileinfo = (struct stat *)tmp;
  {
#line 750
  while (1) {
    while_continue: /* CIL Label */ ;
#line 750
    if (! (total_files < 300)) {
#line 750
      goto while_break;
    }
#line 751
    sprintf(log_filename, (char const   *)"%s/log.%03d", log_path, log_id);
#line 752
    sprintf(history_filename, (char const   *)"%s/game.%03d", log_path, log_id);
#line 753
    log_file = fopen((char const   * __restrict  )(log_filename), (char const   * __restrict  )"r");
#line 754
    if (! log_file) {
#line 755
      goto while_break;
    }
#line 756
    fclose(log_file);
#line 757
    total_files ++;
#line 750
    log_id ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  sprintf(tfn, (char const   *)"%s/log.%03d", log_path, log_id - 1);
#line 771
  tlog = fopen((char const   * __restrict  )(tfn), (char const   * __restrict  )"r+");
#line 772
  if (tlog) {
#line 773
    tmp___0 = fileno(tlog);
#line 773
    fstat(tmp___0, fileinfo);
#line 774
    if (fileinfo->st_size < 2000L) {
#line 775
      log_id --;
    }
  }
#line 779
  tmp___1 = log_id;
#line 779
  log_id ++;
#line 779
  t = tmp___1;
#line 780
  return (t);
}
}
#line 805 "init.c"
void InitializeHashTables(int fault_in ) 
{ 
  uint64_t mem_per_node ;
  int node ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 809
  transposition_age = 0;
#line 810
  if (fault_in) {
#line 810
    if (smp_numa) {
#line 820
      if (smp_max_threads > 1U) {
#line 820
        tmp = smp_max_threads;
      } else {
#line 820
        tmp = 1U;
      }
#line 820
      mem_per_node = (hash_table_size * sizeof(HASH_ENTRY )) / (size_t )tmp;
#line 822
      node = 0;
      {
#line 822
      while (1) {
        while_continue: /* CIL Label */ ;
#line 822
        if (! ((unsigned int )node < smp_max_threads)) {
#line 822
          goto while_break;
        }
#line 823
        ThreadAffinity(node);
#line 824
        memset((void *)((char *)hash_table + (uint64_t )node * mem_per_node), 0, mem_per_node);
#line 822
        node ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 826
      ThreadAffinity(0);
#line 827
      if (smp_max_threads > 1U) {
#line 827
        tmp___0 = smp_max_threads;
      } else {
#line 827
        tmp___0 = 1U;
      }
#line 827
      if (mem_per_node * (uint64_t )tmp___0 < hash_table_size * sizeof(HASH_ENTRY )) {
#line 829
        memset((void *)((char *)hash_table + (uint64_t )smp_max_threads * mem_per_node),
               0, hash_table_size * sizeof(HASH_ENTRY ) - mem_per_node * (uint64_t )smp_max_threads);
      }
#line 841
      if (smp_max_threads > 1U) {
#line 841
        tmp___1 = smp_max_threads;
      } else {
#line 841
        tmp___1 = 1U;
      }
#line 841
      mem_per_node = (hash_path_size * sizeof(HPATH_ENTRY )) / (size_t )tmp___1;
#line 843
      node = 0;
      {
#line 843
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 843
        if (! ((unsigned int )node < smp_max_threads)) {
#line 843
          goto while_break___0;
        }
#line 844
        ThreadAffinity(node);
#line 845
        memset((void *)((char *)hash_path + (uint64_t )node * mem_per_node), 0, mem_per_node);
#line 843
        node ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 847
      ThreadAffinity(0);
#line 848
      if (smp_max_threads > 1U) {
#line 848
        tmp___2 = smp_max_threads;
      } else {
#line 848
        tmp___2 = 1U;
      }
#line 848
      if (mem_per_node * (uint64_t )tmp___2 < hash_path_size * sizeof(HPATH_ENTRY )) {
#line 850
        memset((void *)((char *)hash_path + (uint64_t )smp_max_threads * mem_per_node),
               0, hash_path_size * sizeof(HPATH_ENTRY ) - mem_per_node * (uint64_t )smp_max_threads);
      }
#line 862
      if (smp_max_threads > 1U) {
#line 862
        tmp___3 = smp_max_threads;
      } else {
#line 862
        tmp___3 = 1U;
      }
#line 862
      mem_per_node = (pawn_hash_table_size * sizeof(PAWN_HASH_ENTRY )) / (size_t )tmp___3;
#line 865
      node = 0;
      {
#line 865
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 865
        if (! ((unsigned int )node < smp_max_threads)) {
#line 865
          goto while_break___1;
        }
#line 866
        ThreadAffinity(node);
#line 867
        memset((void *)((char *)pawn_hash_table + (uint64_t )node * mem_per_node),
               0, mem_per_node);
#line 865
        node ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 869
      ThreadAffinity(0);
#line 870
      if (smp_max_threads > 1U) {
#line 870
        tmp___4 = smp_max_threads;
      } else {
#line 870
        tmp___4 = 1U;
      }
#line 870
      if (mem_per_node * (uint64_t )tmp___4 < pawn_hash_table_size * sizeof(PAWN_HASH_ENTRY )) {
#line 872
        memset((void *)((char *)pawn_hash_table + (uint64_t )smp_max_threads * mem_per_node),
               0, pawn_hash_table_size * sizeof(PAWN_HASH_ENTRY ) - mem_per_node * (uint64_t )smp_max_threads);
      }
#line 883
      ThreadAffinity(smp_affinity);
    } else {
#line 810
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 894
    memset((void *)((char *)hash_table), 0, hash_table_size * sizeof(HASH_ENTRY ));
#line 895
    memset((void *)((char *)hash_path), 0, hash_path_size * sizeof(HPATH_ENTRY ));
#line 896
    memset((void *)((char *)pawn_hash_table), 0, pawn_hash_table_size * sizeof(PAWN_HASH_ENTRY ));
  }
#line 899
  return;
}
}
#line 910 "init.c"
void InitializeKillers(void) 
{ 
  int i ;

  {
#line 913
  i = 0;
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    if (! (i < 129)) {
#line 913
      goto while_break;
    }
#line 914
    (block[0])->killers[i].move1 = (uint32_t )0;
#line 915
    (block[0])->killers[i].move2 = (uint32_t )0;
#line 913
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 917
  i = 0;
  {
#line 917
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 917
    if (! (i < 1024)) {
#line 917
      goto while_break___0;
    }
#line 918
    history[i] = 1024;
#line 917
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 919
  return;
}
}
#line 929 "init.c"
void InitializeMasks(void) 
{ 
  int i ;
  int j___0 ;

  {
#line 935
  i = 0;
  {
#line 935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 935
    if (! (i < 64)) {
#line 935
      goto while_break;
    }
#line 936
    clear_mask[i] = ~ (1UL << i);
#line 937
    set_mask[i] = 1UL << i;
#line 935
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 939
  clear_mask[64] = (uint64_t )0;
#line 940
  set_mask[64] = (uint64_t )0;
#line 944
  rank_mask[0] = (uint64_t )255;
#line 945
  i = 1;
  {
#line 945
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 945
    if (! (i < 8)) {
#line 945
      goto while_break___0;
    }
#line 946
    rank_mask[i] = rank_mask[i - 1] << 8;
#line 945
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 947
  file_mask[0] = (uint64_t )1;
#line 948
  i = 1;
  {
#line 948
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 948
    if (! (i < 8)) {
#line 948
      goto while_break___1;
    }
#line 949
    file_mask[0] |= file_mask[0] << 8;
#line 948
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 950
  i = 1;
  {
#line 950
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 950
    if (! (i < 8)) {
#line 950
      goto while_break___2;
    }
#line 951
    file_mask[i] = file_mask[i - 1] << 1;
#line 950
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 956
  msb[0] = (unsigned char)64;
#line 957
  lsb[0] = (unsigned char)16;
#line 958
  i = 1;
  {
#line 958
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 958
    if (! (i < 65536)) {
#line 958
      goto while_break___3;
    }
#line 959
    lsb[i] = (unsigned char)16;
#line 960
    j___0 = 0;
    {
#line 960
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 960
      if (! (j___0 < 16)) {
#line 960
        goto while_break___4;
      }
#line 961
      if (i & (1 << j___0)) {
#line 962
        msb[i] = (unsigned char )j___0;
#line 963
        if ((int )lsb[i] == 16) {
#line 964
          lsb[i] = (unsigned char )j___0;
        }
      }
#line 960
      j___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 958
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 968
  msb_8bit[0] = (unsigned char)8;
#line 969
  lsb_8bit[0] = (unsigned char)8;
#line 970
  pop_cnt_8bit[0] = (unsigned char)0;
#line 971
  i = 1;
  {
#line 971
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 971
    if (! (i < 256)) {
#line 971
      goto while_break___5;
    }
#line 972
    pop_cnt_8bit[i] = (unsigned char)0;
#line 973
    j___0 = 0;
    {
#line 973
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 973
      if (! (j___0 < 8)) {
#line 973
        goto while_break___6;
      }
#line 974
      if (i & (1 << j___0)) {
#line 975
        pop_cnt_8bit[i] = (unsigned char )((int )pop_cnt_8bit[i] + 1);
      }
#line 973
      j___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 976
    lsb_8bit[i] = (unsigned char)8;
#line 977
    j___0 = 0;
    {
#line 977
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 977
      if (! (j___0 < 8)) {
#line 977
        goto while_break___7;
      }
#line 978
      if (i & (1 << j___0)) {
#line 979
        msb_8bit[i] = (unsigned char )j___0;
#line 980
        if ((int )lsb_8bit[i] == 8) {
#line 981
          lsb_8bit[i] = (unsigned char )j___0;
        }
      }
#line 977
      j___0 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 971
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 985
  return;
}
}
#line 995 "init.c"
void InitializePawnMasks(void) 
{ 
  int i ;
  int j___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1002
  i = 0;
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (! (i < 64)) {
#line 1002
      goto while_break;
    }
#line 1003
    if (! (i & 7)) {
#line 1004
      mask_pawn_isolated[i] = file_mask[(i & 7) + 1];
    } else
#line 1005
    if ((i & 7) == 7) {
#line 1006
      mask_pawn_isolated[i] = file_mask[(i & 7) - 1];
    } else {
#line 1008
      mask_pawn_isolated[i] = file_mask[(i & 7) - 1] | file_mask[(i & 7) + 1];
    }
#line 1002
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1015
  i = 0;
  {
#line 1015
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1015
    if (! (i < 64)) {
#line 1015
      goto while_break___0;
    }
#line 1016
    if (! (i & 7)) {
#line 1017
      mask_passed[1][i] = plus8dir[i] | plus8dir[i + 1];
#line 1018
      mask_passed[0][i] = minus8dir[i] | minus8dir[i + 1];
    } else
#line 1019
    if ((i & 7) == 7) {
#line 1020
      mask_passed[1][i] = plus8dir[i - 1] | plus8dir[i];
#line 1021
      mask_passed[0][i] = minus8dir[i - 1] | minus8dir[i];
    } else {
#line 1023
      mask_passed[1][i] = (plus8dir[i - 1] | plus8dir[i]) | plus8dir[i + 1];
#line 1024
      mask_passed[0][i] = (minus8dir[i - 1] | minus8dir[i]) | minus8dir[i + 1];
    }
#line 1015
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1031
  i = 8;
  {
#line 1031
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1031
    if (! (i < 56)) {
#line 1031
      goto while_break___1;
    }
#line 1032
    if ((i & 7) > 0) {
#line 1032
      if ((i & 7) < 7) {
#line 1033
        mask_pawn_connected[1][i] = ((set_mask[i - 1] | set_mask[i + 1]) | set_mask[i - 9]) | set_mask[i - 7];
#line 1035
        mask_pawn_connected[0][i] = ((set_mask[i - 1] | set_mask[i + 1]) | set_mask[i + 9]) | set_mask[i + 7];
      } else {
#line 1032
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1037
    if ((i & 7) == 0) {
#line 1038
      mask_pawn_connected[1][i] = set_mask[i + 1] | set_mask[i - 7];
#line 1039
      mask_pawn_connected[0][i] = set_mask[i + 1] | set_mask[i + 9];
    } else
#line 1040
    if ((i & 7) == 7) {
#line 1041
      mask_pawn_connected[1][i] = set_mask[i - 1] | set_mask[i - 9];
#line 1042
      mask_pawn_connected[0][i] = set_mask[i - 1] | set_mask[i + 7];
    }
#line 1031
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1049
  i = 8;
  {
#line 1049
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1049
    if (! (i < 56)) {
#line 1049
      goto while_break___2;
    }
#line 1050
    if (! (i & 7)) {
#line 1051
      mask_pattacks[1][i] = minus8dir[i + 1];
#line 1052
      mask_pattacks[0][i] = plus8dir[i + 1];
    } else
#line 1053
    if ((i & 7) == 7) {
#line 1054
      mask_pattacks[1][i] = minus8dir[i - 1];
#line 1055
      mask_pattacks[0][i] = plus8dir[i - 1];
    } else {
#line 1057
      mask_pattacks[1][i] = minus8dir[i - 1] | minus8dir[i + 1];
#line 1058
      mask_pattacks[0][i] = plus8dir[i + 1] | plus8dir[i - 1];
    }
#line 1049
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1065
  i = 0;
  {
#line 1065
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1065
    if (! (i < 64)) {
#line 1065
      goto while_break___3;
    }
#line 1066
    mask_eptest[i] = (uint64_t )0;
#line 1065
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1067
  i = 25;
  {
#line 1067
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1067
    if (! (i < 31)) {
#line 1067
      goto while_break___4;
    }
#line 1068
    mask_eptest[i] = set_mask[i - 1] | set_mask[i + 1];
#line 1067
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1069
  i = 33;
  {
#line 1069
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1069
    if (! (i < 39)) {
#line 1069
      goto while_break___5;
    }
#line 1070
    mask_eptest[i] = set_mask[i - 1] | set_mask[i + 1];
#line 1069
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1071
  mask_eptest[24] = set_mask[25];
#line 1072
  mask_eptest[31] = set_mask[30];
#line 1073
  mask_eptest[32] = set_mask[33];
#line 1074
  mask_eptest[39] = set_mask[38];
#line 1083
  i = 0;
  {
#line 1083
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1083
    if (! (i < 64)) {
#line 1083
      goto while_break___6;
    }
#line 1084
    pawn_race[1][1][i] = (uint64_t )0;
#line 1085
    pawn_race[1][0][i] = (uint64_t )0;
#line 1086
    pawn_race[0][1][i] = (uint64_t )0;
#line 1087
    pawn_race[0][0][i] = (uint64_t )0;
#line 1083
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1089
  j___0 = 8;
  {
#line 1089
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1089
    if (! (j___0 < 56)) {
#line 1089
      goto while_break___7;
    }
#line 1090
    i = 0;
    {
#line 1090
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1090
      if (! (i < 64)) {
#line 1090
        goto while_break___8;
      }
#line 1092
      if (j___0 < 16) {
#line 1093
        tmp = KingPawnSquare(j___0 + 8, i, (j___0 & 7) + 56, 1);
#line 1093
        if (tmp) {
#line 1094
          pawn_race[1][1][j___0] |= set_mask[i];
        }
      } else {
#line 1096
        tmp___0 = KingPawnSquare(j___0, i, (j___0 & 7) + 56, 1);
#line 1096
        if (tmp___0) {
#line 1097
          pawn_race[1][1][j___0] |= set_mask[i];
        }
      }
#line 1100
      if (j___0 < 16) {
#line 1101
        tmp___1 = KingPawnSquare(j___0 + 8, i, (j___0 & 7) + 56, 0);
#line 1101
        if (tmp___1) {
#line 1102
          pawn_race[1][0][j___0] |= set_mask[i];
        }
      } else {
#line 1104
        tmp___2 = KingPawnSquare(j___0, i, (j___0 & 7) + 56, 0);
#line 1104
        if (tmp___2) {
#line 1105
          pawn_race[1][0][j___0] |= set_mask[i];
        }
      }
#line 1108
      if (j___0 > 47) {
#line 1109
        tmp___3 = KingPawnSquare(j___0 - 8, i, j___0 & 7, 0);
#line 1109
        if (tmp___3) {
#line 1110
          pawn_race[0][1][j___0] |= set_mask[i];
        }
      } else {
#line 1112
        tmp___4 = KingPawnSquare(j___0, i, j___0 & 7, 0);
#line 1112
        if (tmp___4) {
#line 1113
          pawn_race[0][1][j___0] |= set_mask[i];
        }
      }
#line 1116
      if (j___0 > 47) {
#line 1117
        tmp___5 = KingPawnSquare(j___0 - 8, i, j___0 & 7, 1);
#line 1117
        if (tmp___5) {
#line 1118
          pawn_race[0][0][j___0] |= set_mask[i];
        }
      } else {
#line 1120
        tmp___6 = KingPawnSquare(j___0, i, j___0 & 7, 1);
#line 1120
        if (tmp___6) {
#line 1121
          pawn_race[0][0][j___0] |= set_mask[i];
        }
      }
#line 1090
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1089
    j___0 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1125
  return;
}
}
#line 1135 "init.c"
void InitializeLMP(void) 
{ 
  int i ;
  double tmp ;

  {
#line 1138
  i = 0;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! (i < LMP_depth)) {
#line 1138
      goto while_break;
    }
#line 1139
    tmp = pow((double )i + .5, LMP_scale);
#line 1139
    LMP[i] = (int )((double )LMP_base + tmp);
#line 1138
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1140
  return;
}
}
#line 1151 "init.c"
void InitializeLMR(void) 
{ 
  int d ;
  int m ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 1154
  d = 0;
  {
#line 1154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1154
    if (! (d < 32)) {
#line 1154
      goto while_break;
    }
#line 1155
    m = 0;
    {
#line 1155
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1155
      if (! (m < 64)) {
#line 1155
        goto while_break___0;
      }
#line 1156
      LMR[d][m] = (uint8_t )0;
#line 1155
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1154
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1157
  d = 3;
  {
#line 1157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1157
    if (! (d < 32)) {
#line 1157
      goto while_break___1;
    }
#line 1158
    m = 1;
    {
#line 1158
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1158
      if (! (m < 64)) {
#line 1158
        goto while_break___2;
      }
#line 1159
      tmp___18 = log((double )d * LMR_db);
#line 1159
      tmp___19 = log((double )m * LMR_mb);
#line 1159
      if ((tmp___18 * tmp___19) / LMR_s < (double )LMR_max) {
#line 1159
        tmp___15 = log((double )d * LMR_db);
#line 1159
        tmp___16 = log((double )m * LMR_mb);
#line 1159
        tmp___17 = (tmp___15 * tmp___16) / LMR_s;
      } else {
#line 1159
        tmp___17 = (double )LMR_max;
      }
#line 1159
      if (tmp___17 > (double )LMR_min) {
#line 1159
        tmp___11 = log((double )d * LMR_db);
#line 1159
        tmp___12 = log((double )m * LMR_mb);
#line 1159
        if ((tmp___11 * tmp___12) / LMR_s < (double )LMR_max) {
#line 1159
          tmp___8 = log((double )d * LMR_db);
#line 1159
          tmp___9 = log((double )m * LMR_mb);
#line 1159
          tmp___10 = (tmp___8 * tmp___9) / LMR_s;
        } else {
#line 1159
          tmp___10 = (double )LMR_max;
        }
#line 1159
        LMR[d][m] = (uint8_t )tmp___10;
      } else {
#line 1159
        LMR[d][m] = (uint8_t )LMR_min;
      }
#line 1162
      if ((d - 1) - LMR_rdepth > 0) {
#line 1162
        tmp___22 = (d - 1) - LMR_rdepth;
      } else {
#line 1162
        tmp___22 = 0;
      }
#line 1162
      if ((int )LMR[d][m] < tmp___22) {
#line 1162
        LMR[d][m] = LMR[d][m];
      } else {
#line 1162
        if ((d - 1) - LMR_rdepth > 0) {
#line 1162
          tmp___21 = (d - 1) - LMR_rdepth;
        } else {
#line 1162
          tmp___21 = 0;
        }
#line 1162
        LMR[d][m] = (uint8_t )tmp___21;
      }
#line 1158
      m ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1157
    d ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1164
  return;
}
}
#line 1173 "init.c"
void InitializeSMP(void) 
{ 


  {
#line 1174
  lock_smp = (int volatile   )0;
#line 1175
  lock_io = (int volatile   )0;
#line 1176
  (block[0])->lock = (int volatile   )0;
#line 1178
  pthread_attr_init(& attributes);
#line 1179
  pthread_attr_setdetachstate(& attributes, 1);
#line 1181
  return;
}
}
#line 26 "input.c"
static char const   pieces___1[15]  = 
#line 26 "input.c"
  {      (char const   )' ',      (char const   )' ',      (char const   )'P',      (char const   )'p', 
        (char const   )'N',      (char const   )'n',      (char const   )'B',      (char const   )'b', 
        (char const   )'R',      (char const   )'r',      (char const   )'Q',      (char const   )'q', 
        (char const   )'K',      (char const   )'k',      (char const   )'\000'};
#line 30 "input.c"
static char const   pro_pieces[15]  = 
#line 30
  {      (char const   )' ',      (char const   )' ',      (char const   )'P',      (char const   )'p', 
        (char const   )'N',      (char const   )'n',      (char const   )'B',      (char const   )'b', 
        (char const   )'R',      (char const   )'r',      (char const   )'Q',      (char const   )'q', 
        (char const   )'K',      (char const   )'k',      (char const   )'\000'};
#line 18 "input.c"
int InputMove(TREE *tree , int ply , int wtm , int silent , int ponder_list , char *text___0 ) 
{ 
  unsigned int moves[220] ;
  unsigned int *mv ;
  unsigned int *mvp ;
  unsigned int *goodmove ;
  int piece ;
  int capture ;
  int promote ;
  int give_check ;
  int ffile ;
  int frank ;
  int tfile ;
  int trank ;
  int current ;
  int i ;
  int nleft ;
  char *goodchar ;
  char *tc ;
  char movetext[128] ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *prom ;
  size_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
#line 20
  goodmove = (unsigned int *)0;
#line 21
  piece = -1;
#line 43
  tc = strchr((char const   *)text___0, '!');
#line 43
  if (tc) {
#line 44
    *tc = (char)0;
  }
#line 45
  tc = strchr((char const   *)text___0, '?');
#line 45
  if (tc) {
#line 46
    *tc = (char)0;
  }
#line 55
  tmp = strlen((char const   *)text___0);
#line 55
  if (tmp == 0UL) {
#line 56
    return (0);
  }
#line 57
  if ((int )*(text___0 + 0) >= 97) {
#line 57
    if ((int )*(text___0 + 0) <= 104) {
#line 57
      if ((int )*(text___0 + 1) >= 49) {
#line 57
        if ((int )*(text___0 + 1) <= 56) {
#line 57
          if ((int )*(text___0 + 2) >= 97) {
#line 57
            if ((int )*(text___0 + 2) <= 104) {
#line 57
              if ((int )*(text___0 + 3) >= 49) {
#line 57
                if ((int )*(text___0 + 3) <= 56) {
#line 60
                  tmp___0 = InputMoveICS(tree, ply, wtm, silent, ponder_list, text___0);
#line 60
                  return (tmp___0);
                } else {
#line 57
                  goto _L___5;
                }
              } else {
#line 57
                goto _L___5;
              }
            } else {
#line 57
              goto _L___5;
            }
          } else {
#line 57
            goto _L___5;
          }
        } else {
#line 57
          goto _L___5;
        }
      } else {
#line 57
        goto _L___5;
      }
    } else {
#line 57
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
    _L___3: /* CIL Label */ 
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ ;
  }
#line 70
  tree->status[129] = tree->status[ply];
#line 71
  strcpy(movetext, (char const   *)text___0);
#line 72
  moves[0] = 0U;
#line 73
  piece = 0;
#line 74
  capture = 0;
#line 75
  promote = 0;
#line 76
  give_check = 0;
#line 77
  frank = -1;
#line 78
  ffile = -1;
#line 79
  trank = -1;
#line 80
  tfile = -1;
#line 81
  goodchar = strchr((char const   *)(movetext), '#');
#line 82
  if (goodchar) {
#line 83
    *goodchar = (char)0;
  }
#line 92
  tmp___26 = strcmp((char const   *)(movetext), (char const   *)"o-o");
#line 92
  if (tmp___26) {
#line 92
    tmp___27 = strcmp((char const   *)(movetext), (char const   *)"o-o+");
#line 92
    if (tmp___27) {
#line 92
      tmp___28 = strcmp((char const   *)(movetext), (char const   *)"O-O");
#line 92
      if (tmp___28) {
#line 92
        tmp___29 = strcmp((char const   *)(movetext), (char const   *)"O-O+");
#line 92
        if (tmp___29) {
#line 92
          tmp___30 = strcmp((char const   *)(movetext), (char const   *)"0-0");
#line 92
          if (tmp___30) {
#line 92
            tmp___31 = strcmp((char const   *)(movetext), (char const   *)"0-0+");
#line 92
            if (tmp___31) {
#line 107
              tmp___20 = strcmp((char const   *)(movetext), (char const   *)"o-o-o");
#line 107
              if (tmp___20) {
#line 107
                tmp___21 = strcmp((char const   *)(movetext), (char const   *)"o-o-o+");
#line 107
                if (tmp___21) {
#line 107
                  tmp___22 = strcmp((char const   *)(movetext), (char const   *)"O-O-O");
#line 107
                  if (tmp___22) {
#line 107
                    tmp___23 = strcmp((char const   *)(movetext), (char const   *)"O-O-O+");
#line 107
                    if (tmp___23) {
#line 107
                      tmp___24 = strcmp((char const   *)(movetext), (char const   *)"0-0-0");
#line 107
                      if (tmp___24) {
#line 107
                        tmp___25 = strcmp((char const   *)(movetext), (char const   *)"0-0-0+");
#line 107
                        if (tmp___25) {
#line 133
                          if ((int )movetext[0] == 98) {
#line 133
                            if ((int )movetext[1] == 98) {
#line 134
                              movetext[0] = (char )'B';
                            } else {
#line 133
                              goto _L___6;
                            }
                          } else {
                            _L___6: /* CIL Label */ ;
                          }
#line 144
                          tmp___2 = strchr((char const   *)(movetext), '+');
#line 144
                          if (tmp___2) {
#line 145
                            tmp___1 = strchr((char const   *)(movetext), '+');
#line 145
                            *tmp___1 = (char)0;
#line 146
                            give_check = 1;
                          }
#line 157
                          tmp___8 = strchr((char const   *)(movetext), '=');
#line 157
                          if (tmp___8) {
#line 158
                            goodchar = strchr((char const   *)(movetext), '=');
#line 159
                            goodchar ++;
#line 160
                            tmp___3 = strchr(pro_pieces, (int )*goodchar);
#line 160
                            promote = (int )((tmp___3 - (char *)(pro_pieces)) >> 1);
#line 161
                            tmp___4 = strchr((char const   *)(movetext), '=');
#line 161
                            *tmp___4 = (char)0;
                          } else {
#line 175
                            tmp___5 = strlen((char const   *)(movetext));
#line 175
                            tmp___6 = strchr(pro_pieces, (int )movetext[tmp___5 - 1UL]);
#line 175
                            prom = tmp___6;
#line 177
                            if (prom) {
#line 178
                              promote = (int )((prom - (char *)(pro_pieces)) >> 1);
#line 179
                              tmp___7 = strlen((char const   *)(movetext));
#line 179
                              movetext[tmp___7 - 1UL] = (char)0;
                            }
                          }
#line 192
                          tmp___9 = strlen((char const   *)(movetext));
#line 192
                          current = (int )(tmp___9 - 1UL);
#line 193
                          trank = (int )movetext[current] - 49;
#line 194
                          if (trank >= 0) {
#line 194
                            if (trank <= 7) {
#line 195
                              movetext[current] = (char)0;
                            } else {
#line 194
                              goto _L___7;
                            }
                          } else {
                            _L___7: /* CIL Label */ 
#line 197
                            trank = -1;
                          }
#line 198
                          tmp___10 = strlen((char const   *)(movetext));
#line 198
                          current = (int )(tmp___10 - 1UL);
#line 199
                          tfile = (int )movetext[current] - 97;
#line 200
                          if (tfile >= 0) {
#line 200
                            if (tfile <= 7) {
#line 201
                              movetext[current] = (char)0;
                            } else {
#line 200
                              goto _L___8;
                            }
                          } else {
                            _L___8: /* CIL Label */ 
#line 203
                            tfile = -1;
                          }
#line 204
                          tmp___19 = strlen((char const   *)(movetext));
#line 204
                          if (tmp___19) {
#line 214
                            tmp___13 = strchr((char const   *)"  PpNnBBRrQqKk", (int )movetext[0]);
#line 214
                            if (tmp___13) {
#line 215
                              tmp___11 = strchr(pieces___1, (int )movetext[0]);
#line 215
                              piece = (int )((tmp___11 - (char *)(pieces___1)) >> 1);
#line 216
                              i = 0;
                              {
#line 216
                              while (1) {
                                while_continue: /* CIL Label */ ;
#line 216
                                tmp___12 = strlen((char const   *)(movetext));
#line 216
                                if (! (i < (int )tmp___12)) {
#line 216
                                  goto while_break;
                                }
#line 217
                                movetext[i] = movetext[i + 1];
#line 216
                                i ++;
                              }
                              while_break: /* CIL Label */ ;
                              }
                            }
#line 229
                            tmp___15 = strlen((char const   *)(movetext));
#line 229
                            if (tmp___15) {
#line 229
                              tmp___16 = strlen((char const   *)(movetext));
#line 229
                              if ((int )movetext[tmp___16 - 1UL] == 120) {
#line 230
                                capture = 1;
#line 231
                                tmp___14 = strlen((char const   *)(movetext));
#line 231
                                movetext[tmp___14 - 1UL] = (char)0;
                              } else {
#line 229
                                goto _L___9;
                              }
                            } else {
                              _L___9: /* CIL Label */ 
#line 233
                              capture = 0;
                            }
#line 243
                            tmp___18 = strlen((char const   *)(movetext));
#line 243
                            if (tmp___18) {
#line 244
                              ffile = (int )movetext[0] - 97;
#line 245
                              if (ffile < 0) {
#line 245
                                goto _L___12;
                              } else
#line 245
                              if (ffile > 7) {
                                _L___12: /* CIL Label */ 
#line 246
                                ffile = -1;
#line 247
                                frank = (int )movetext[0] - 49;
#line 248
                                if (frank < 0) {
#line 248
                                  goto _L___10;
                                } else
#line 248
                                if (frank > 7) {
                                  _L___10: /* CIL Label */ 
#line 249
                                  piece = -1;
                                }
                              } else {
#line 251
                                tmp___17 = strlen((char const   *)(movetext));
#line 251
                                if (tmp___17 == 2UL) {
#line 252
                                  frank = (int )movetext[1] - 49;
#line 253
                                  if (frank < 0) {
#line 253
                                    goto _L___11;
                                  } else
#line 253
                                  if (frank > 7) {
                                    _L___11: /* CIL Label */ 
#line 254
                                    piece = -1;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          _L___13: /* CIL Label */ 
#line 110
                          piece = 6;
#line 111
                          if (wtm) {
#line 112
                            ffile = 4;
#line 113
                            frank = 0;
#line 114
                            tfile = 2;
#line 115
                            trank = 0;
                          } else {
#line 117
                            ffile = 4;
#line 118
                            frank = 7;
#line 119
                            tfile = 2;
#line 120
                            trank = 7;
                          }
                        }
                      } else {
                        _L___14: /* CIL Label */ 
#line 107
                        goto _L___13;
                      }
                    } else {
                      _L___15: /* CIL Label */ 
#line 107
                      goto _L___14;
                    }
                  } else {
                    _L___16: /* CIL Label */ 
#line 107
                    goto _L___15;
                  }
                } else {
                  _L___17: /* CIL Label */ 
#line 107
                  goto _L___16;
                }
              } else {
#line 107
                goto _L___17;
              }
            } else {
              _L___18: /* CIL Label */ 
#line 95
              piece = 6;
#line 96
              if (wtm) {
#line 97
                ffile = 4;
#line 98
                frank = 0;
#line 99
                tfile = 6;
#line 100
                trank = 0;
              } else {
#line 102
                ffile = 4;
#line 103
                frank = 7;
#line 104
                tfile = 6;
#line 105
                trank = 7;
              }
            }
          } else {
            _L___19: /* CIL Label */ 
#line 92
            goto _L___18;
          }
        } else {
          _L___20: /* CIL Label */ 
#line 92
          goto _L___19;
        }
      } else {
        _L___21: /* CIL Label */ 
#line 92
        goto _L___20;
      }
    } else {
      _L___22: /* CIL Label */ 
#line 92
      goto _L___21;
    }
  } else {
#line 92
    goto _L___22;
  }
#line 275
  if (! piece) {
#line 276
    piece = 1;
  }
#line 277
  if (! ponder_list) {
#line 278
    mvp = GenerateCaptures(tree, 129, wtm, moves);
#line 279
    mvp = GenerateNoncaptures(tree, 129, wtm, mvp);
  } else {
#line 281
    i = 0;
    {
#line 281
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 281
      if (! (i < num_ponder_moves)) {
#line 281
        goto while_break___0;
      }
#line 282
      moves[i] = ponder_moves[i];
#line 281
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 283
    mvp = moves + num_ponder_moves;
  }
#line 285
  mv = & moves[0];
  {
#line 285
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 285
    if (! ((unsigned long )mv < (unsigned long )mvp)) {
#line 285
      goto while_break___1;
    }
#line 286
    if (piece) {
#line 286
      if (((*mv >> 12) & 7U) != (unsigned int )piece) {
#line 287
        *mv = 0U;
      } else {
#line 286
        goto _L___23;
      }
    } else {
      _L___23: /* CIL Label */ ;
    }
#line 288
    if (ffile >= 0) {
#line 288
      if (((*mv & 63U) & 7U) != (unsigned int )ffile) {
#line 289
        *mv = 0U;
      } else {
#line 288
        goto _L___24;
      }
    } else {
      _L___24: /* CIL Label */ ;
    }
#line 290
    if (capture) {
#line 290
      if (! ((*mv >> 15) & 7U)) {
#line 291
        *mv = 0U;
      } else {
#line 290
        goto _L___25;
      }
    } else {
      _L___25: /* CIL Label */ ;
    }
#line 292
    if (promote) {
#line 292
      if (((*mv >> 18) & 7U) != (unsigned int )promote) {
#line 293
        *mv = 0U;
      } else {
#line 292
        goto _L___26;
      }
    } else {
      _L___26: /* CIL Label */ ;
    }
#line 294
    if (frank >= 0) {
#line 294
      if ((*mv & 63U) >> 3 != (unsigned int )frank) {
#line 295
        *mv = 0U;
      } else {
#line 294
        goto _L___27;
      }
    } else {
      _L___27: /* CIL Label */ ;
    }
#line 296
    if (tfile >= 0) {
#line 296
      if ((((*mv >> 6) & 63U) & 7U) != (unsigned int )tfile) {
#line 297
        *mv = 0U;
      } else {
#line 296
        goto _L___28;
      }
    } else {
      _L___28: /* CIL Label */ ;
    }
#line 298
    if (trank >= 0) {
#line 298
      if (((*mv >> 6) & 63U) >> 3 != (unsigned int )trank) {
#line 299
        *mv = 0U;
      } else {
#line 298
        goto _L___29;
      }
    } else {
      _L___29: /* CIL Label */ ;
    }
#line 300
    if (! ponder_list) {
#line 300
      if (*mv) {
#line 301
        MakeMove(tree, 129, wtm, (int )*mv);
#line 302
        tmp___32 = Attacks(tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 302
        if (tmp___32) {
#line 302
          goto _L___30;
        } else
#line 302
        if (give_check) {
#line 302
          tmp___33 = Attacks(tree, (wtm ^ 1) ^ 1, tree->position.kingsq[wtm ^ 1]);
#line 302
          if (tmp___33) {
#line 302
            goto _L___31;
          } else {
            _L___30: /* CIL Label */ 
#line 303
            UnmakeMove(tree, 129, wtm, (int )*mv);
#line 304
            *mv = 0U;
          }
        } else {
          _L___31: /* CIL Label */ 
#line 306
          UnmakeMove(tree, 129, wtm, (int )*mv);
        }
      } else {
#line 300
        goto _L___32;
      }
    } else {
      _L___32: /* CIL Label */ ;
    }
#line 285
    mv ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 320
  nleft = 0;
#line 321
  mv = & moves[0];
  {
#line 321
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 321
    if (! ((unsigned long )mv < (unsigned long )mvp)) {
#line 321
      goto while_break___2;
    }
#line 322
    if (*mv) {
#line 323
      nleft ++;
#line 324
      goodmove = mv;
    }
#line 321
    mv ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 327
  if (nleft == 1) {
#line 328
    return ((int )*goodmove);
  }
#line 329
  if (! silent) {
#line 330
    if (nleft == 0) {
#line 331
      Print(4095, "Illegal move: %s\n", text___0);
    } else
#line 332
    if (piece < 0) {
#line 333
      Print(4095, "Illegal move (unrecognizable): %s\n", text___0);
    } else {
#line 335
      Print(4095, "Illegal move (ambiguous): %s\n", text___0);
    }
  }
#line 337
  return (0);
}
}
#line 356 "input.c"
static char const   pieces___2[15]  = 
#line 356
  {      (char const   )' ',      (char const   )' ',      (char const   )'P',      (char const   )'p', 
        (char const   )'N',      (char const   )'n',      (char const   )'B',      (char const   )'b', 
        (char const   )'R',      (char const   )'r',      (char const   )'Q',      (char const   )'q', 
        (char const   )'K',      (char const   )'k',      (char const   )'\000'};
#line 349 "input.c"
int InputMoveICS(TREE *tree , int ply , int wtm , int silent , int ponder_list , char *text___0 ) 
{ 
  unsigned int moves[220] ;
  unsigned int *mv ;
  unsigned int *mvp ;
  unsigned int *goodmove ;
  int piece ;
  int promote ;
  int ffile ;
  int frank ;
  int tfile ;
  int trank ;
  int i ;
  int nleft ;
  char movetext[128] ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 351
  goodmove = (unsigned int *)0;
#line 352
  piece = -1;
#line 369
  tmp = strlen((char const   *)text___0);
#line 369
  if (tmp == 0UL) {
#line 370
    return (0);
  }
#line 371
  tree->status[129] = tree->status[ply];
#line 372
  strcpy(movetext, (char const   *)text___0);
#line 373
  moves[0] = 0U;
#line 374
  promote = 0;
#line 383
  tmp___5 = strcmp((char const   *)(movetext), (char const   *)"o-o");
#line 383
  if (tmp___5) {
#line 383
    tmp___6 = strcmp((char const   *)(movetext), (char const   *)"O-O");
#line 383
    if (tmp___6) {
#line 383
      tmp___7 = strcmp((char const   *)(movetext), (char const   *)"0-0");
#line 383
      if (tmp___7) {
#line 397
        tmp___2 = strcmp((char const   *)(movetext), (char const   *)"o-o-o");
#line 397
        if (tmp___2) {
#line 397
          tmp___3 = strcmp((char const   *)(movetext), (char const   *)"O-O-O");
#line 397
          if (tmp___3) {
#line 397
            tmp___4 = strcmp((char const   *)(movetext), (char const   *)"0-0-0");
#line 397
            if (tmp___4) {
#line 421
              ffile = (int )movetext[0] - 97;
#line 422
              frank = (int )movetext[1] - 49;
#line 423
              tfile = (int )movetext[2] - 97;
#line 424
              trank = (int )movetext[3] - 49;
#line 434
              if ((int )movetext[4] == 61) {
#line 435
                tmp___0 = strchr(pieces___2, (int )movetext[5]);
#line 435
                promote = (int )((tmp___0 - (char *)(pieces___2)) >> 1);
              } else
#line 436
              if ((int )movetext[4] != 0) {
#line 436
                if ((int )movetext[4] != 32) {
#line 437
                  tmp___1 = strchr(pieces___2, (int )movetext[4]);
#line 437
                  promote = (int )((tmp___1 - (char *)(pieces___2)) >> 1);
                } else {
#line 436
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ ;
              }
            } else {
              _L___0: /* CIL Label */ 
#line 399
              piece = 6;
#line 400
              if (wtm) {
#line 401
                ffile = 4;
#line 402
                frank = 0;
#line 403
                tfile = 2;
#line 404
                trank = 0;
              } else {
#line 406
                ffile = 4;
#line 407
                frank = 7;
#line 408
                tfile = 2;
#line 409
                trank = 7;
              }
            }
          } else {
            _L___1: /* CIL Label */ 
#line 397
            goto _L___0;
          }
        } else {
#line 397
          goto _L___1;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 385
        piece = 6;
#line 386
        if (wtm) {
#line 387
          ffile = 4;
#line 388
          frank = 0;
#line 389
          tfile = 6;
#line 390
          trank = 0;
        } else {
#line 392
          ffile = 4;
#line 393
          frank = 7;
#line 394
          tfile = 6;
#line 395
          trank = 7;
        }
      }
    } else {
      _L___3: /* CIL Label */ 
#line 383
      goto _L___2;
    }
  } else {
#line 383
    goto _L___3;
  }
#line 454
  if (! ponder_list) {
#line 455
    mvp = GenerateCaptures(tree, 129, wtm, moves);
#line 456
    mvp = GenerateNoncaptures(tree, 129, wtm, mvp);
  } else {
#line 458
    i = 0;
    {
#line 458
    while (1) {
      while_continue: /* CIL Label */ ;
#line 458
      if (! (i < num_ponder_moves)) {
#line 458
        goto while_break;
      }
#line 459
      moves[i] = ponder_moves[i];
#line 458
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 460
    mvp = moves + num_ponder_moves;
  }
#line 462
  mv = & moves[0];
  {
#line 462
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 462
    if (! ((unsigned long )mv < (unsigned long )mvp)) {
#line 462
      goto while_break___0;
    }
#line 463
    if (((*mv >> 18) & 7U) != (unsigned int )promote) {
#line 464
      *mv = 0U;
    }
#line 465
    if ((*mv & 63U) >> 3 != (unsigned int )frank) {
#line 466
      *mv = 0U;
    }
#line 467
    if (((*mv & 63U) & 7U) != (unsigned int )ffile) {
#line 468
      *mv = 0U;
    }
#line 469
    if (((*mv >> 6) & 63U) >> 3 != (unsigned int )trank) {
#line 470
      *mv = 0U;
    }
#line 471
    if ((((*mv >> 6) & 63U) & 7U) != (unsigned int )tfile) {
#line 472
      *mv = 0U;
    }
#line 473
    if (! ponder_list) {
#line 473
      if (*mv) {
#line 474
        MakeMove(tree, 129, wtm, (int )*mv);
#line 475
        tmp___8 = Attacks(tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 475
        if (tmp___8) {
#line 476
          UnmakeMove(tree, 129, wtm, (int )*mv);
#line 477
          *mv = 0U;
        } else {
#line 479
          UnmakeMove(tree, 129, wtm, (int )*mv);
        }
      } else {
#line 473
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ ;
    }
#line 462
    mv ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 493
  nleft = 0;
#line 494
  mv = & moves[0];
  {
#line 494
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 494
    if (! ((unsigned long )mv < (unsigned long )mvp)) {
#line 494
      goto while_break___1;
    }
#line 495
    if (*mv) {
#line 496
      nleft ++;
#line 497
      goodmove = mv;
    }
#line 494
    mv ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 500
  if (nleft == 1) {
#line 501
    return ((int )*goodmove);
  }
#line 502
  if (! silent) {
#line 503
    if (nleft == 0) {
#line 504
      Print(4095, "Illegal move: %s\n", text___0);
    } else
#line 505
    if (piece < 0) {
#line 506
      Print(4095, "Illegal move (unrecognizable): %s\n", text___0);
    } else {
#line 508
      Print(4095, "Illegal move (ambiguous): %s\n", text___0);
    }
  }
#line 510
  return (0);
}
}
#line 17 "interrupt.c"
void Interrupt(int ply ) 
{ 
  TREE *tree ;
  int temp ;
  int i ;
  int left ;
  int readstat ;
  int result ;
  int time_used___0 ;
  int save_move_number ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 18
  tree = (TREE *)block[0];
#line 19
  left = 0;
#line 29
  if (puzzling) {
#line 30
    abort_search = 2;
  } else {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 43
      if (! 1) {
#line 43
        goto while_break;
      }
#line 44
      readstat = Read(0, buffer);
#line 45
      if (readstat <= 0) {
#line 46
        goto while_break;
      }
#line 47
      nargs = ReadParse(buffer, args, " \t;");
#line 48
      if (nargs == 0) {
#line 49
        Print(32, "ok.\n");
#line 50
        goto while_break;
      }
#line 52
      tmp = strcmp((char const   *)args[0], (char const   *)".");
#line 52
      if (tmp) {
#line 53
        save_move_number = move_number;
#line 54
        if (! game_wtm) {
#line 55
          move_number --;
        }
#line 56
        if (root_wtm) {
#line 57
          Print(32, "Black(%d): %s\n", move_number, buffer);
        } else {
#line 59
          Print(32, "White(%d): %s\n", move_number, buffer);
        }
#line 60
        move_number = save_move_number;
      }
#line 70
      tmp___6 = strcmp((char const   *)args[0], (char const   *)".");
#line 70
      if (tmp___6) {
#line 100
        tmp___5 = strcmp((char const   *)args[0], (char const   *)"?");
#line 100
        if (tmp___5) {
#line 112
          tmp___4 = strcmp((char const   *)args[0], (char const   *)"@");
#line 112
          if (tmp___4) {
#line 136
            save_move_number = move_number;
#line 137
            if (! analyze_mode) {
#line 137
              if (! game_wtm) {
#line 138
                move_number --;
              } else {
#line 137
                goto _L;
              }
            } else {
              _L: /* CIL Label */ ;
            }
#line 139
            result = Option((TREE *)tree);
#line 140
            move_number = save_move_number;
#line 141
            if (result >= 2) {
#line 142
              if (thinking) {
#line 142
                if (result != 3) {
#line 143
                  Print(32, "command not legal now.\n");
                } else {
#line 142
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
#line 145
                abort_search = 2;
#line 146
                input_status = 2;
#line 147
                goto while_break;
              }
            } else
#line 149
            if (result != 1) {
#line 149
              if (analyze_mode) {
#line 150
                abort_search = 1;
#line 151
                input_status = 2;
#line 152
                goto while_break;
              } else {
#line 149
                goto _L___7;
              }
            } else
            _L___7: /* CIL Label */ 
#line 166
            if (! result) {
#line 167
              if (pondering) {
#line 168
                nargs = ReadParse(buffer, args, " \t;");
#line 169
                temp = InputMove((TREE *)tree, 0, root_wtm ^ 1, 1, 1, args[0]);
#line 170
                if (temp) {
#line 171
                  if ((temp & 63) == (ponder_move & 63)) {
#line 171
                    if (((temp >> 6) & 63) == ((ponder_move >> 6) & 63)) {
#line 171
                      if (((temp >> 12) & 7) == ((ponder_move >> 12) & 7)) {
#line 171
                        if (((temp >> 15) & 7) == ((ponder_move >> 15) & 7)) {
#line 171
                          if (((temp >> 18) & 7) == ((ponder_move >> 18) & 7)) {
#line 176
                            predicted ++;
#line 177
                            input_status = 1;
#line 178
                            pondering = 0;
#line 179
                            thinking = 1;
#line 180
                            opponent_end_time = ReadClock();
#line 181
                            program_start_time = ReadClock();
#line 182
                            Print(32, "predicted move made.\n");
                          } else {
#line 171
                            goto _L___4;
                          }
                        } else {
#line 171
                          goto _L___4;
                        }
                      } else {
#line 171
                        goto _L___4;
                      }
                    } else {
#line 171
                      goto _L___4;
                    }
                  } else {
                    _L___4: /* CIL Label */ 
                    _L___3: /* CIL Label */ 
                    _L___2: /* CIL Label */ 
                    _L___1: /* CIL Label */ 
#line 184
                    input_status = 2;
#line 185
                    abort_search = 2;
#line 186
                    goto while_break;
                  }
                } else {
#line 188
                  tmp___1 = strcmp((char const   *)args[0], (char const   *)"go");
#line 188
                  if (tmp___1) {
#line 188
                    tmp___2 = strcmp((char const   *)args[0], (char const   *)"move");
#line 188
                    if (tmp___2) {
#line 188
                      tmp___3 = strcmp((char const   *)args[0], (char const   *)"SP");
#line 188
                      if (tmp___3) {
#line 193
                        Print(4095, "Illegal move: %s\n", args[0]);
                      } else {
                        _L___5: /* CIL Label */ 
#line 190
                        abort_search = 2;
#line 191
                        goto while_break;
                      }
                    } else {
                      _L___6: /* CIL Label */ 
#line 188
                      goto _L___5;
                    }
                  } else {
#line 188
                    goto _L___6;
                  }
                }
              } else {
#line 195
                Print(4095, "unrecognized/illegal command: %s\n", args[0]);
              }
            }
          } else
#line 113
          if (pondering) {
#line 114
            predicted ++;
#line 115
            input_status = 1;
#line 116
            pondering = 0;
#line 117
            thinking = 1;
#line 118
            opponent_end_time = ReadClock();
#line 119
            program_start_time = ReadClock();
#line 120
            Print(32, "predicted move made.\n");
          }
        } else
#line 101
        if (thinking) {
#line 102
          abort_search = 1;
        }
      } else
#line 71
      if (xboard) {
#line 72
        end_time = ReadClock();
#line 73
        time_used___0 = (int )(end_time - start_time);
#line 74
        printf((char const   *)"stat01: %d ", time_used___0);
#line 75
        printf((char const   *)"%lu ", tree->nodes_searched);
#line 76
        printf((char const   *)"%d ", iteration);
#line 77
        i = 0;
        {
#line 77
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 77
          if (! (i < n_root_moves)) {
#line 77
            goto while_break___0;
          }
#line 78
          if (! (root_moves[i].status & 8U)) {
#line 79
            left ++;
          }
#line 77
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 80
        printf((char const   *)"%d %d\n", left, n_root_moves);
#line 81
        fflush(stdout);
#line 82
        goto while_break;
      } else {
#line 84
        end_time = ReadClock();
#line 85
        time_used___0 = (int )(end_time - start_time);
#line 86
        tmp___0 = DisplayTime((unsigned int )time_used___0);
#line 86
        printf((char const   *)"time:%s ", tmp___0);
#line 87
        printf((char const   *)"nodes:%lu\n", tree->nodes_searched);
#line 89
        ThreadTrace(block[0], 0, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 199
  if (log_file) {
#line 200
    fflush(log_file);
  }
#line 201
  return;
}
}
#line 19 "learn.c"
int LearnAdjust(int value ) 
{ 


  {
#line 21
  if (learning / 10 > 0) {
#line 22
    return (value / (learning / 10));
  } else {
#line 24
    return (0);
  }
}
}
#line 45 "learn.c"
void LearnBook(void) 
{ 
  float book_learn[64] ;
  float t_learn_value ;
  int nplies ;
  int thisply ;
  int i ;
  int j___0 ;
  int v ;
  int cluster ;
  unsigned char buf32[4] ;
  int tmp ;
  size_t tmp___0 ;
  double tmp___1 ;

  {
#line 47
  nplies = 0;
#line 47
  thisply = 0;
#line 60
  if (! book_file) {
#line 61
    return;
  }
#line 62
  if (! learn) {
#line 63
    return;
  }
#line 64
  if (learn_value > 0) {
#line 64
    tmp = learn_value;
  } else {
#line 64
    tmp = - learn_value;
  }
#line 64
  if (tmp != learning) {
#line 65
    learn_value = LearnAdjust(learn_value);
  }
#line 66
  learn = 0;
#line 67
  Print(32, "LearnBook() updating book database\n");
#line 83
  t_learn_value = (float )((double )((float )learn_value) / 100.0);
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < 64)) {
#line 84
      goto while_break;
    }
#line 85
    if (learn_nmoves[i] > 1) {
#line 86
      nplies ++;
    }
#line 84
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  if (nplies > 1) {
#line 87
    nplies = nplies;
  } else {
#line 87
    nplies = 1;
  }
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (i < 64)) {
#line 88
      goto while_break___0;
    }
#line 89
    if (learn_nmoves[i] > 1) {
#line 90
      thisply ++;
    }
#line 91
    book_learn[i] = (t_learn_value * (float )thisply) / (float )nplies;
#line 88
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (i < 64) {
#line 101
      if (! learn_seekto[i]) {
#line 101
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 101
      goto while_break___1;
    }
#line 102
    if (learn_seekto[i] > 0) {
#line 103
      fseek(book_file, (long )learn_seekto[i], 0);
#line 104
      tmp___0 = fread((void *)(buf32), (size_t )4, (size_t )1, book_file);
#line 104
      v = (int )tmp___0;
#line 105
      if (v <= 0) {
#line 106
        perror((char const   *)"Learn() fread error: ");
      }
#line 107
      cluster = BookIn32(buf32);
#line 108
      if (cluster) {
#line 109
        BookClusterIn(book_file, cluster, book_buffer);
      }
#line 110
      j___0 = 0;
      {
#line 110
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 110
        if (! (j___0 < cluster)) {
#line 110
          goto while_break___2;
        }
#line 111
        if (! (learn_key[i] ^ book_buffer[j___0].position)) {
#line 112
          goto while_break___2;
        }
#line 110
        j___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 113
      if (j___0 >= cluster) {
#line 114
        return;
      }
#line 115
      tmp___1 = fabs((double )book_buffer[j___0].learn);
#line 115
      if (tmp___1 < 0.0001) {
#line 116
        book_buffer[j___0].learn = book_learn[i];
      } else {
#line 118
        book_buffer[j___0].learn = (float )((double )(book_buffer[j___0].learn + book_learn[i]) / 2.0);
      }
#line 119
      fseek(book_file, (long )(learn_seekto[i] + 4), 0);
#line 120
      if (cluster) {
#line 121
        BookClusterOut(book_file, cluster, book_buffer);
      }
#line 122
      fflush(book_file);
    }
#line 101
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 125
  return;
}
}
#line 143 "learn.c"
static float const   rating_mult_t[11]  = 
#line 143
  {      (float const   ).00625,      (float const   ).0125,      (float const   ).025,      (float const   ).05, 
        (float const   ).075,      (float const   ).1,      (float const   )0.15,      (float const   )0.2, 
        (float const   )0.25,      (float const   )0.3,      (float const   )0.35};
#line 146 "learn.c"
static float const   rating_mult_ut[11]  = 
#line 146
  {      (float const   ).25,      (float const   ).2,      (float const   ).15,      (float const   ).1, 
        (float const   ).05,      (float const   ).025,      (float const   ).012,      (float const   ).006, 
        (float const   ).003,      (float const   ).001};
#line 140 "learn.c"
int LearnFunction(int sv , int search_depth___0 , int rating_difference , int trusted_value ) 
{ 
  float multiplier ;
  int sd ;
  int rd ;
  int value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 151
  if (search_depth___0 - 10 < 19) {
#line 151
    tmp___1 = search_depth___0 - 10;
  } else {
#line 151
    tmp___1 = 19;
  }
#line 151
  if (tmp___1 > 0) {
#line 151
    if (search_depth___0 - 10 < 19) {
#line 151
      tmp___0 = search_depth___0 - 10;
    } else {
#line 151
      tmp___0 = 19;
    }
#line 151
    sd = tmp___0;
  } else {
#line 151
    sd = 0;
  }
#line 152
  if (rating_difference / 200 < 5) {
#line 152
    tmp___5 = rating_difference / 200;
  } else {
#line 152
    tmp___5 = 5;
  }
#line 152
  if (tmp___5 > -5) {
#line 152
    if (rating_difference / 200 < 5) {
#line 152
      tmp___3 = rating_difference / 200;
    } else {
#line 152
      tmp___3 = 5;
    }
#line 152
    tmp___4 = tmp___3;
  } else {
#line 152
    tmp___4 = -5;
  }
#line 152
  rd = tmp___4 + 5;
#line 153
  if (trusted_value) {
#line 154
    multiplier = (float )(rating_mult_t[rd] * (float const   )sd);
  } else {
#line 156
    multiplier = (float )(rating_mult_ut[rd] * (float const   )sd);
  }
#line 157
  if (sv < 5 * learning) {
#line 157
    tmp___8 = sv;
  } else {
#line 157
    tmp___8 = 5 * learning;
  }
#line 157
  if (tmp___8 > -5 * learning) {
#line 157
    if (sv < 5 * learning) {
#line 157
      tmp___7 = sv;
    } else {
#line 157
      tmp___7 = 5 * learning;
    }
#line 157
    sv = tmp___7;
  } else {
#line 157
    sv = -5 * learning;
  }
#line 158
  value = (int )((float )sv * multiplier);
#line 159
  return (value);
}
}
#line 192 "learn.c"
void LearnValue(int search_value , int search_depth___0 ) 
{ 
  int i ;
  int interval ;
  int best_eval ;
  int best_eval_p ;
  int worst_eval ;
  int worst_eval_p ;
  int best_after_worst_eval ;
  int worst_after_best_eval ;

  {
#line 194
  best_eval = -999999;
#line 194
  best_eval_p = 0;
#line 195
  worst_eval = 999999;
#line 195
  worst_eval_p = 0;
#line 196
  best_after_worst_eval = -999999;
#line 196
  worst_after_best_eval = 999999;
#line 208
  if (! book_file) {
#line 209
    return;
  }
#line 210
  if (! learn) {
#line 210
    goto _L;
  } else
#line 210
  if (learn_value != 0) {
    _L: /* CIL Label */ 
#line 211
    return;
  }
#line 212
  if (moves_out_of_book <= 10) {
#line 213
    if (moves_out_of_book) {
#line 214
      book_learn_eval[moves_out_of_book - 1] = search_value;
#line 215
      book_learn_depth[moves_out_of_book - 1] = search_depth___0;
    }
  } else
#line 228
  if (moves_out_of_book == 11) {
#line 229
    if (moves_out_of_book < 1) {
#line 230
      return;
    }
#line 231
    if (10 < moves_out_of_book) {
#line 231
      interval = 10;
    } else {
#line 231
      interval = moves_out_of_book;
    }
#line 232
    if (interval < 2) {
#line 233
      return;
    }
#line 234
    i = 0;
    {
#line 234
    while (1) {
      while_continue: /* CIL Label */ ;
#line 234
      if (! (i < interval)) {
#line 234
        goto while_break;
      }
#line 235
      if (book_learn_eval[i] > best_eval) {
#line 236
        best_eval = book_learn_eval[i];
#line 237
        best_eval_p = i;
      }
#line 239
      if (book_learn_eval[i] < worst_eval) {
#line 240
        worst_eval = book_learn_eval[i];
#line 241
        worst_eval_p = i;
      }
#line 234
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 244
    if (best_eval_p < interval - 1) {
#line 245
      i = best_eval_p;
      {
#line 245
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 245
        if (! (i < interval)) {
#line 245
          goto while_break___0;
        }
#line 246
        if (book_learn_eval[i] < worst_after_best_eval) {
#line 247
          worst_after_best_eval = book_learn_eval[i];
        }
#line 245
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 249
      worst_after_best_eval = book_learn_eval[interval - 1];
    }
#line 250
    if (worst_eval_p < interval - 1) {
#line 251
      i = worst_eval_p;
      {
#line 251
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 251
        if (! (i < interval)) {
#line 251
          goto while_break___1;
        }
#line 252
        if (book_learn_eval[i] > best_after_worst_eval) {
#line 253
          best_after_worst_eval = book_learn_eval[i];
        }
#line 251
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 255
      best_after_worst_eval = book_learn_eval[interval - 1];
    }
#line 280
    if (best_eval == best_after_worst_eval) {
#line 281
      learn_value = best_eval;
#line 282
      i = 0;
      {
#line 282
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 282
        if (! (i < interval)) {
#line 282
          goto while_break___2;
        }
#line 283
        if (learn_value == book_learn_eval[i]) {
#line 284
          if (search_depth___0 > book_learn_depth[i]) {
#line 284
            search_depth___0 = search_depth___0;
          } else {
#line 284
            search_depth___0 = book_learn_depth[i];
          }
        }
#line 282
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 295
    if (worst_eval == worst_after_best_eval) {
#line 296
      learn_value = worst_eval;
#line 297
      i = 0;
      {
#line 297
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 297
        if (! (i < interval)) {
#line 297
          goto while_break___3;
        }
#line 298
        if (learn_value == book_learn_eval[i]) {
#line 299
          if (search_depth___0 > book_learn_depth[i]) {
#line 299
            search_depth___0 = search_depth___0;
          } else {
#line 299
            search_depth___0 = book_learn_depth[i];
          }
        }
#line 297
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 311
      learn_value = 0;
#line 312
      search_depth___0 = 0;
#line 313
      i = 0;
      {
#line 313
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 313
        if (! (i < interval)) {
#line 313
          goto while_break___4;
        }
#line 314
        learn_value += book_learn_eval[i];
#line 315
        search_depth___0 += book_learn_depth[i];
#line 313
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 317
      learn_value /= interval;
#line 318
      search_depth___0 /= interval;
    }
#line 320
    learn_value = LearnFunction(learn_value, search_depth___0, crafty_rating - opponent_rating,
                                learn_value < 0);
  }
#line 324
  return;
}
}
#line 72 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 78
extern void endpwent(void) ;
#line 84
extern struct passwd *getpwent(void) ;
#line 94
extern struct passwd *( __attribute__((__nonnull__(1))) fgetpwent)(FILE *__stream ) ;
#line 102
extern int putpwent(struct passwd  const  * __restrict  __p , FILE * __restrict  __f ) ;
#line 110
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
#line 139
extern int ( __attribute__((__nonnull__(1,2,4))) getpwent_r)(struct passwd * __restrict  __resultbuf ,
                                                             char * __restrict  __buffer ,
                                                             size_t __buflen , struct passwd ** __restrict  __result )  __attribute__((__access__(__write_only__,2,3))) ;
#line 146
extern int ( __attribute__((__nonnull__(2,3,5))) getpwuid_r)(__uid_t __uid , struct passwd * __restrict  __resultbuf ,
                                                             char * __restrict  __buffer ,
                                                             size_t __buflen , struct passwd ** __restrict  __result )  __attribute__((__access__(__write_only__,3,4))) ;
#line 153
extern int ( __attribute__((__nonnull__(1,2,3,5))) getpwnam_r)(char const   * __restrict  __name ,
                                                               struct passwd * __restrict  __resultbuf ,
                                                               char * __restrict  __buffer ,
                                                               size_t __buflen , struct passwd ** __restrict  __result )  __attribute__((__access__(__write_only__,3,4))) ;
#line 169
extern int ( __attribute__((__nonnull__(1,2,3,5))) fgetpwent_r)(FILE * __restrict  __stream ,
                                                                struct passwd * __restrict  __resultbuf ,
                                                                char * __restrict  __buffer ,
                                                                size_t __buflen ,
                                                                struct passwd ** __restrict  __result )  __attribute__((__access__(__write_only__,3,4))) ;
#line 188
extern int getpw(__uid_t __uid , char *__buffer ) ;
#line 4251 "main.c"
int main(int argc , char **argv ) 
{ 
  TREE *tree ;
  FILE *personality ;
  int move ;
  int readstat ;
  int value ;
  int i ;
  int v ;
  int result ;
  int draw_type ;
  char announce[128] ;
  char path[1024] ;
  struct passwd *pwd ;
  long tmp ;
  char *directory_spec ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  __uid_t tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int drawsc ;
  int tmp___20 ;
  int tmp___21 ;
  char *moveptr ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 4254
  value = 0;
#line 4265
  tmp = sysconf(84);
#line 4265
  hardware_processors = (unsigned int )tmp;
#line 4271
  tmp___0 = getenv((char const   *)"CRAFTY_BOOK_PATH");
#line 4271
  directory_spec = tmp___0;
#line 4273
  if (directory_spec) {
#line 4274
    strncpy(book_path, (char const   *)directory_spec, sizeof(book_path));
  }
#line 4275
  directory_spec = getenv((char const   *)"CRAFTY_LOG_PATH");
#line 4276
  if (directory_spec) {
#line 4277
    strncpy(log_path, (char const   *)directory_spec, sizeof(log_path));
  }
#line 4278
  directory_spec = getenv((char const   *)"CRAFTY_TB_PATH");
#line 4279
  if (directory_spec) {
#line 4280
    strncpy(tb_path, (char const   *)directory_spec, sizeof(tb_path));
  }
#line 4281
  directory_spec = getenv((char const   *)"CRAFTY_RC_PATH");
#line 4282
  if (directory_spec) {
#line 4283
    strncpy(rc_path, (char const   *)directory_spec, sizeof(rc_path));
  }
#line 4284
  tmp___2 = getenv((char const   *)"CRAFTY_XBOARD");
#line 4284
  if (tmp___2) {
#line 4285
    Print(-1, "feature done=0\n");
#line 4286
    xboard_done = 0;
  } else
#line 4287
  if (argc > 1) {
#line 4287
    tmp___1 = strcmp((char const   *)*(argv + 1), (char const   *)"xboard");
#line 4287
    if (tmp___1) {
#line 4287
      goto _L;
    } else {
#line 4288
      Print(-1, "feature done=0\n");
#line 4289
      xboard_done = 0;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 4300
  AlignedMalloc((void **)((void *)(& tree)), (uint64_t )2048, sizeof(TREE ));
#line 4301
  block[0] = tree;
#line 4302
  memset((void *)block[0], 0, sizeof(TREE ));
#line 4303
  tree->ply = 1;
#line 4304
  input_stream = stdin;
#line 4305
  i = 0;
  {
#line 4305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4305
    if (! (i < 512)) {
#line 4305
      goto while_break;
    }
#line 4306
    tmp___3 = malloc((size_t )256);
#line 4306
    args[i] = (char *)tmp___3;
#line 4305
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4307
  if (argc > 1) {
#line 4308
    i = 1;
    {
#line 4308
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4308
      if (! (i < argc)) {
#line 4308
        goto while_break___0;
      }
#line 4309
      tmp___4 = strstr((char const   *)*(argv + i), (char const   *)"path");
#line 4309
      if (tmp___4) {
#line 4309
        goto _L___1;
      } else {
#line 4309
        tmp___5 = strstr((char const   *)*(argv + i), (char const   *)"log");
#line 4309
        if (tmp___5) {
          _L___1: /* CIL Label */ 
#line 4309
          goto _L___0;
        } else {
#line 4309
          tmp___6 = strstr((char const   *)*(argv + 1), (char const   *)"affinity");
#line 4309
          if (tmp___6) {
            _L___0: /* CIL Label */ 
#line 4311
            strcpy(buffer, (char const   *)*(argv + i));
#line 4312
            result = Option(tree);
#line 4313
            if (result == 0) {
#line 4314
              Print(2048, "ERROR \"%s\" is unknown command-line option\n", buffer);
            }
#line 4316
            display = tree->position;
          }
        }
      }
#line 4308
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4330
  input_stream = fopen((char const   * __restrict  )".craftyrc", (char const   * __restrict  )"r");
#line 4331
  if (! input_stream) {
#line 4332
    tmp___7 = getuid();
#line 4332
    pwd = getpwuid(tmp___7);
#line 4332
    if (pwd) {
#line 4333
      sprintf(path, (char const   *)"%s/.craftyrc", pwd->pw_dir);
#line 4334
      input_stream = fopen((char const   * __restrict  )(path), (char const   * __restrict  )"r");
    }
  }
#line 4336
  if (input_stream) {
    {
#line 4341
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4341
      if (! 1) {
#line 4341
        goto while_break___1;
      }
#line 4342
      readstat = Read(1, buffer);
#line 4343
      if (readstat < 0) {
#line 4344
        goto while_break___1;
      }
#line 4345
      tmp___8 = strstr((char const   *)(buffer), (char const   *)"path");
#line 4345
      if (! tmp___8) {
#line 4346
        goto while_continue___1;
      }
#line 4347
      result = Option(tree);
#line 4348
      if (result == 0) {
#line 4349
        Print(2048, "ERROR \"%s\" is unknown rc-file option\n", buffer);
      }
#line 4350
      if ((unsigned long )input_stream == (unsigned long )stdin) {
#line 4351
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 4360
  Initialize();
#line 4370
  if (argc > 1) {
#line 4371
    i = 1;
    {
#line 4371
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4371
      if (! (i < argc)) {
#line 4371
        goto while_break___2;
      }
#line 4372
      tmp___11 = strcmp((char const   *)*(argv + i), (char const   *)"c");
#line 4372
      if (tmp___11) {
#line 4373
        tmp___10 = strstr((char const   *)*(argv + i), (char const   *)"path");
#line 4373
        if (! tmp___10) {
#line 4374
          tmp___9 = strlen((char const   *)*(argv + i));
#line 4374
          if (tmp___9 > 255UL) {
#line 4375
            Print(-1, "ERROR ignoring token %s, 255 character max\n", *(argv + i));
          } else {
#line 4378
            strcpy(buffer, (char const   *)*(argv + i));
#line 4379
            Print(32, "(info) command line option \"%s\"\n", buffer);
#line 4380
            result = Option(tree);
#line 4381
            if (result == 0) {
#line 4382
              Print(2048, "ERROR \"%s\" is unknown command-line option\n", buffer);
            }
          }
        }
      }
#line 4371
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 4387
  display = tree->position;
#line 4388
  initialized = 1;
#line 4389
  move_actually_played = 0;
#line 4400
  input_stream = fopen((char const   * __restrict  )".craftyrc", (char const   * __restrict  )"r");
#line 4401
  if (! input_stream) {
#line 4402
    tmp___12 = getuid();
#line 4402
    pwd = getpwuid(tmp___12);
#line 4402
    if (pwd) {
#line 4403
      sprintf(path, (char const   *)"%s/.craftyrc", pwd->pw_dir);
#line 4404
      input_stream = fopen((char const   * __restrict  )(path), (char const   * __restrict  )"r");
    }
  }
#line 4406
  if (input_stream) {
    {
#line 4411
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4411
      if (! 1) {
#line 4411
        goto while_break___3;
      }
#line 4412
      readstat = Read(1, buffer);
#line 4413
      if (readstat < 0) {
#line 4414
        goto while_break___3;
      }
#line 4415
      tmp___13 = strstr((char const   *)(buffer), (char const   *)"path");
#line 4415
      if (tmp___13) {
#line 4416
        goto while_continue___3;
      }
#line 4417
      result = Option(tree);
#line 4418
      if (result == 0) {
#line 4419
        Print(2048, "ERROR \"%s\" is unknown rc-file option\n", buffer);
      }
#line 4420
      if ((unsigned long )input_stream == (unsigned long )stdin) {
#line 4421
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 4424
  input_stream = stdin;
#line 4426
  if (xboard) {
#line 4427
    signal(2, (void (*)(int  ))1);
  }
#line 4429
  if (smp_max_threads) {
#line 4430
    Print(32, "\nCrafty v%s (%d threads)\n\n", version, smp_max_threads);
  } else {
#line 4432
    Print(32, "\nCrafty v%s\n\n", version);
  }
#line 4433
  if (hardware_processors > 0U) {
#line 4434
    Print(32, "machine has %d processors\n\n", hardware_processors);
  }
#line 4445
  personality = fopen((char const   * __restrict  )"crafty.cpf", (char const   * __restrict  )"r");
#line 4445
  if (personality) {
#line 4446
    fclose(personality);
#line 4447
    Print(-1, "using default personality file \"crafty.cpf\"\n");
#line 4448
    sprintf(buffer, (char const   *)"personality load crafty.cpf");
#line 4449
    Option(tree);
  }
  {
#line 4510
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 4510
    if (! 1) {
#line 4510
      goto while_break___4;
    }
#line 4511
    presult = 0;
    {
#line 4512
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 4513
      opponent_start_time = ReadClock();
#line 4514
      input_status = 0;
#line 4515
      display = tree->position;
#line 4516
      move = 0;
#line 4517
      presult = 0;
#line 4518
      if (xboard_done == 0) {
#line 4518
        if (xboard) {
#line 4519
          xboard_done = 1;
#line 4520
          Print(-1, "feature done=1\n");
        } else {
#line 4518
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ ;
      }
      {
#line 4522
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 4523
        if (presult != 2) {
#line 4524
          presult = 0;
        }
#line 4525
        result = 0;
#line 4526
        if (pong) {
#line 4527
          Print(-1, "pong %d\n", pong);
#line 4528
          pong = 0;
        }
#line 4530
        display = tree->position;
#line 4531
        if (presult != 2) {
#line 4531
          if (move_number != 1) {
#line 4531
            goto _L___4;
          } else
#line 4531
          if (! game_wtm) {
            _L___4: /* CIL Label */ 
#line 4532
            presult = Ponder(game_wtm);
          } else {
#line 4531
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ ;
        }
#line 4533
        if (presult == 1) {
#line 4534
          value = last_root_value;
        } else
#line 4535
        if (presult == 2) {
#line 4536
          value = ponder_value;
        }
#line 4537
        if (presult == 0) {
#line 4537
          goto _L___6;
        } else
#line 4537
        if (presult == 2) {
          _L___6: /* CIL Label */ 
#line 4538
          if (! xboard) {
#line 4539
            if (game_wtm) {
#line 4539
              tmp___14 = "White";
            } else {
#line 4539
              tmp___14 = "Black";
            }
#line 4539
            printf((char const   *)"%s(%d): ", tmp___14, move_number);
#line 4540
            fflush(stdout);
          }
#line 4542
          readstat = Read(1, buffer);
#line 4543
          if (log_file) {
#line 4544
            if (game_wtm) {
#line 4544
              tmp___15 = "White";
            } else {
#line 4544
              tmp___15 = "Black";
            }
#line 4544
            fprintf(log_file, (char const   *)"%s(%d): %s\n", tmp___15, move_number,
                    buffer);
          }
#line 4546
          if (readstat < 0) {
#line 4546
            if ((unsigned long )input_stream == (unsigned long )stdin) {
#line 4547
              strcpy(buffer, (char const   *)"end");
#line 4548
              Option(tree);
            } else {
#line 4546
              goto _L___5;
            }
          } else {
            _L___5: /* CIL Label */ ;
          }
        }
#line 4551
        if (presult == 1) {
#line 4552
          goto while_break___6;
        }
#line 4553
        opponent_end_time = ReadClock();
#line 4554
        result = Option(tree);
#line 4555
        if (result == 0) {
#line 4556
          nargs = ReadParse(buffer, args, " \t;");
#line 4557
          move = InputMove(tree, 0, game_wtm, 0, 0, args[0]);
#line 4558
          result = ! move;
#line 4559
          if (move) {
#line 4560
            last_pv.path[1] = 0;
          }
        } else {
#line 4562
          input_status = 0;
#line 4563
          if (result == 3) {
#line 4564
            presult = 0;
          }
        }
#line 4522
        if (! (result > 0)) {
#line 4522
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 4567
      if (presult == 1) {
#line 4568
        move = ponder_move;
      }
#line 4577
      if (result == 0) {
#line 4578
        fseek(history_file, (long )((((move_number - 1) * 2 + 1) - game_wtm) * 10),
              0);
#line 4580
        tmp___16 = OutputMove(tree, 0, game_wtm, move);
#line 4580
        fprintf(history_file, (char const   *)"%9s\n", tmp___16);
#line 4581
        MakeMoveRoot(tree, game_wtm, move);
#line 4582
        tree->curmv[0] = move;
#line 4583
        time_used_opponent = (int )(opponent_end_time - opponent_start_time);
#line 4584
        if (! force) {
#line 4585
          tmp___17 = DisplayTime((unsigned int )time_used_opponent);
#line 4585
          Print(1, "              time used: %s\n", tmp___17);
        }
#line 4587
        TimeAdjust(game_wtm, time_used_opponent);
#line 4588
        game_wtm ^= 1;
#line 4589
        if (game_wtm) {
#line 4590
          move_number ++;
        }
#line 4591
        move_actually_played = 1;
#line 4592
        last_opponent_move = move;
#line 4613
        draw_type = Repeat3x(tree);
#line 4613
        if (draw_type == 1) {
#line 4614
          Print(1, "I claim a draw by 3-fold repetition.\n");
#line 4615
          value = draw_score[game_wtm];
#line 4616
          if (xboard) {
#line 4617
            Print(-1, "1/2-1/2 {Drawn by 3-fold repetition}\n");
          }
        }
#line 4619
        if (draw_type == 2) {
#line 4620
          tmp___18 = Mated(tree, 0, game_wtm);
#line 4620
          if (! tmp___18) {
#line 4621
            Print(1, "I claim a draw by the 50 move rule.\n");
#line 4622
            value = draw_score[game_wtm];
#line 4623
            if (xboard) {
#line 4624
              Print(-1, "1/2-1/2 {Drawn by 50-move rule}\n");
            }
          }
        }
#line 4627
        tmp___19 = Drawn(tree, last_search_value);
#line 4627
        if (tmp___19 == 2) {
#line 4628
          Print(1, "I claim a draw due to insufficient material.\n");
#line 4629
          if (xboard) {
#line 4630
            Print(-1, "1/2-1/2 {Insufficient material}\n");
          }
        }
      } else {
#line 4633
        presult = 0;
      }
#line 4512
      if (! force) {
#line 4512
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 4647
    crafty_is_white = game_wtm;
#line 4648
    if (presult == 2) {
#line 4649
      if ((ponder_move & 63) == (move & 63)) {
#line 4649
        if (((ponder_move >> 6) & 63) == ((move >> 6) & 63)) {
#line 4649
          if (((ponder_move >> 12) & 7) == ((move >> 12) & 7)) {
#line 4649
            if (((ponder_move >> 15) & 7) == ((move >> 15) & 7)) {
#line 4649
              if (((ponder_move >> 18) & 7) == ((move >> 18) & 7)) {
#line 4653
                presult = 1;
#line 4654
                if (! book_move) {
#line 4655
                  predicted ++;
                }
              } else {
#line 4649
                goto _L___10;
              }
            } else {
#line 4649
              goto _L___10;
            }
          } else {
#line 4649
            goto _L___10;
          }
        } else {
#line 4649
          goto _L___10;
        }
      } else {
        _L___10: /* CIL Label */ 
        _L___9: /* CIL Label */ 
        _L___8: /* CIL Label */ 
        _L___7: /* CIL Label */ 
#line 4657
        presult = 0;
      }
    }
#line 4659
    ponder_move = 0;
#line 4660
    thinking = 1;
#line 4661
    if (presult != 1) {
#line 4662
      strcpy(kibitz_text, (char const   *)"n/a");
#line 4663
      last_pv.pathd = 0;
#line 4664
      last_pv.pathl = 0;
#line 4665
      display = tree->position;
#line 4666
      tree->status[1] = tree->status[0];
#line 4667
      value = Iterate(game_wtm, 1, 0);
    }
#line 4686
    if (draw_offer_pending) {
#line 4687
      drawsc = abs_draw_score;
#line 4689
      draw_offer_pending = 0;
#line 4690
      if (move_number < 40) {
#line 4690
        goto _L___11;
      } else
#line 4690
      if (! accept_draws) {
        _L___11: /* CIL Label */ 
#line 4691
        drawsc = -300;
      }
#line 4692
      if (value <= drawsc) {
#line 4692
        if (tc_increment != 0) {
#line 4692
          goto _L___13;
        } else
#line 4692
        if (tc_time_remaining[game_wtm ^ 1] >= 1000) {
          _L___13: /* CIL Label */ 
#line 4694
          if (xboard) {
#line 4695
            Print(-1, "offer draw\n");
          } else {
#line 4697
            Print(1, "Draw accepted.\n");
#line 4698
            if (audible_alarm) {
#line 4699
              printf((char const   *)"%c", (int )audible_alarm);
            }
#line 4700
            if (speech) {
#line 4701
              strcpy(announce, (char const   *)"./speak ");
#line 4702
              strcat(announce, (char const   *)"Drawaccept");
#line 4703
              v = system((char const   *)(announce));
#line 4704
              if (v != 0) {
#line 4705
                perror((char const   *)"main() system() error: ");
              }
            }
          }
#line 4708
          Print(-1, "1/2-1/2 {Draw agreed}\n");
#line 4709
          strcpy(pgn_result, (char const   *)"1/2-1/2");
        } else {
#line 4692
          goto _L___12;
        }
      } else
      _L___12: /* CIL Label */ 
#line 4711
      if (! xboard) {
#line 4712
        Print(1, "Draw declined.\n");
#line 4713
        if (speech) {
#line 4714
          strcpy(announce, (char const   *)"./speak ");
#line 4715
          strcat(announce, (char const   *)"Drawdecline");
#line 4716
          v = system((char const   *)(announce));
#line 4717
          if (v != 0) {
#line 4718
            perror((char const   *)"main() system() error: ");
          }
        }
      }
    }
#line 4735
    last_pv = tree->pv[0];
#line 4736
    last_value = value;
#line 4737
    if (last_value > 0) {
#line 4737
      tmp___20 = last_value;
    } else {
#line 4737
      tmp___20 = - last_value;
    }
#line 4737
    if (tmp___20 > 32000) {
#line 4738
      last_mate_score = last_value;
    }
#line 4739
    thinking = 0;
#line 4740
    if (! last_pv.pathl) {
#line 4741
      tmp___21 = Attacks(tree, game_wtm ^ 1, tree->position.kingsq[game_wtm]);
#line 4741
      if (tmp___21) {
#line 4742
        over = 1;
#line 4743
        if (game_wtm) {
#line 4744
          Print(-1, "0-1 {Black mates}\n");
#line 4745
          strcpy(pgn_result, (char const   *)"0-1");
        } else {
#line 4747
          Print(-1, "1-0 {White mates}\n");
#line 4748
          strcpy(pgn_result, (char const   *)"1-0");
        }
#line 4750
        if (speech) {
#line 4751
          strcpy(announce, (char const   *)"./speak ");
#line 4752
          strcat(announce, (char const   *)"Checkmate");
#line 4753
          v = system((char const   *)(announce));
#line 4754
          if (v != 0) {
#line 4755
            perror((char const   *)"main() system() error: ");
          }
        }
      } else {
#line 4758
        over = 1;
#line 4759
        if (! xboard) {
#line 4760
          Print(1, "stalemate\n");
#line 4761
          if (speech) {
#line 4762
            strcpy(announce, (char const   *)"./speak ");
#line 4763
            strcat(announce, (char const   *)"Stalemate");
#line 4764
            v = system((char const   *)(announce));
#line 4765
            if (v != 0) {
#line 4766
              perror((char const   *)"main() system() error: ");
            }
          }
        } else {
#line 4769
          Print(-1, "1/2-1/2 {stalemate}\n");
        }
      }
    } else {
#line 4772
      if (value > 32000) {
#line 4772
        if (value < 32766) {
#line 4773
          Print(1, "\nmate in %d moves.\n\n", (32768 - value) / 2);
#line 4774
          Kibitz(1, game_wtm, 0, 0, (32768 - value) / 2, tree->nodes_searched, 0,
                 0, " ");
        } else {
#line 4772
          goto _L___15;
        }
      } else
      _L___15: /* CIL Label */ 
#line 4776
      if (- value > 32000) {
#line 4776
        if (- value < 32767) {
#line 4777
          Print(1, "\nmated in %d moves.\n\n", (32768 + value) / 2);
#line 4778
          Kibitz(1, game_wtm, 0, 0, - (32768 + value) / 2, tree->nodes_searched, 0,
                 0, " ");
        } else {
#line 4776
          goto _L___14;
        }
      } else {
        _L___14: /* CIL Label */ ;
      }
#line 4792
      tree->status[129] = tree->status[0];
#line 4793
      ResignOrDraw(tree, value);
#line 4802
      if (speech) {
#line 4803
        tmp___22 = OutputMove(tree, 0, game_wtm, last_pv.path[1]);
#line 4803
        moveptr = tmp___22;
#line 4805
        strcpy(announce, (char const   *)"./speak ");
#line 4806
        strcat(announce, (char const   *)moveptr);
#line 4807
        strcat(announce, (char const   *)" &");
#line 4808
        v = system((char const   *)(announce));
#line 4809
        if (v != 0) {
#line 4810
          perror((char const   *)"main() system() error: ");
        }
      }
#line 4812
      if (! xboard) {
#line 4812
        if (audible_alarm) {
#line 4813
          printf((char const   *)"%c", (int )audible_alarm);
        } else {
#line 4812
          goto _L___16;
        }
      } else {
        _L___16: /* CIL Label */ ;
      }
#line 4814
      tmp___23 = OutputMove(tree, 0, game_wtm, last_pv.path[1]);
#line 4814
      if (game_wtm) {
#line 4814
        tmp___24 = "White";
      } else {
#line 4814
        tmp___24 = "Black";
      }
#line 4814
      Print(1, "%s(%d): %s\n", tmp___24, move_number, tmp___23);
#line 4816
      if (xboard) {
#line 4817
        tmp___25 = OutputMove(tree, 0, game_wtm, last_pv.path[1]);
#line 4817
        printf((char const   *)"move %s\n", tmp___25);
      }
#line 4818
      fflush(stdout);
#line 4819
      if (value == 32766) {
#line 4820
        if (game_wtm) {
#line 4821
          Print(-1, "1-0 {White mates}\n");
#line 4822
          strcpy(pgn_result, (char const   *)"1-0");
        } else {
#line 4824
          Print(-1, "0-1 {Black mates}\n");
#line 4825
          strcpy(pgn_result, (char const   *)"0-1");
        }
      }
#line 4828
      time_used = (int )(program_end_time - program_start_time);
#line 4829
      tmp___26 = DisplayTime((unsigned int )time_used);
#line 4829
      Print(1, "              time used: %s\n", tmp___26);
#line 4830
      TimeAdjust(game_wtm, time_used);
#line 4831
      fseek(history_file, (long )((((move_number - 1) * 2 + 1) - game_wtm) * 10),
            0);
#line 4833
      tmp___27 = OutputMove(tree, 0, game_wtm, last_pv.path[1]);
#line 4833
      fprintf(history_file, (char const   *)"%9s\n", tmp___27);
#line 4835
      last_search_value = value;
#line 4836
      if (kibitz) {
#line 4837
        if (kibitz_depth) {
#line 4838
          Kibitz(2, game_wtm, kibitz_depth, (int )(end_time - start_time), value,
                 tree->nodes_searched, (int )busy_percent, (int )tree->egtb_hits,
                 kibitz_text);
        } else {
#line 4842
          Kibitz(4, game_wtm, 0, 0, 0, (uint64_t )0, 0, 0, kibitz_text);
        }
      }
#line 4844
      MakeMoveRoot(tree, game_wtm, last_pv.path[1]);
#line 4845
      tree->curmv[0] = move;
#line 4860
      game_wtm ^= 1;
#line 4861
      if (game_wtm) {
#line 4862
        move_number ++;
      }
#line 4863
      move_actually_played = 1;
#line 4864
      draw_type = Repeat3x(tree);
#line 4864
      if (draw_type == 1) {
#line 4865
        Print(1, "I claim a draw by 3-fold repetition after my move.\n");
#line 4866
        if (xboard) {
#line 4867
          Print(-1, "1/2-1/2 {Drawn by 3-fold repetition}\n");
        }
#line 4868
        value = draw_score[game_wtm];
      }
#line 4870
      if (draw_type == 2) {
#line 4870
        if (last_search_value < 32000) {
#line 4871
          Print(1, "I claim a draw by the 50 move rule after my move.\n");
#line 4872
          if (xboard) {
#line 4873
            Print(-1, "1/2-1/2 {Drawn by 50-move rule}\n");
          }
#line 4874
          value = draw_score[game_wtm];
        } else {
#line 4870
          goto _L___17;
        }
      } else {
        _L___17: /* CIL Label */ ;
      }
#line 4876
      tmp___28 = Drawn(tree, last_search_value);
#line 4876
      if (tmp___28 == 2) {
#line 4877
        Print(1, "I claim a draw due to insufficient material after my move.\n");
#line 4879
        if (xboard) {
#line 4880
          Print(-1, "1/2-1/2 {Insufficient material}\n");
        }
      }
#line 4885
      if (log_file) {
#line 4886
        DisplayChessBoard(log_file, tree->position);
      }
#line 4897
      if (last_pv.pathl > 2) {
#line 4897
        tmp___29 = VerifyMove(tree, 0, game_wtm, last_pv.path[2]);
#line 4897
        if (tmp___29) {
#line 4898
          ponder_move = last_pv.path[2];
#line 4899
          i = 1;
          {
#line 4899
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 4899
            if (! (i < last_pv.pathl - 2)) {
#line 4899
              goto while_break___7;
            }
#line 4900
            last_pv.path[i] = last_pv.path[i + 2];
#line 4899
            i ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 4901
          if (last_pv.pathl > 2) {
#line 4901
            last_pv.pathl -= 2;
          } else {
#line 4901
            last_pv.pathl = 0;
          }
#line 4902
          last_pv.pathd -= 2;
#line 4903
          if (last_pv.pathd > last_pv.pathl) {
#line 4904
            last_pv.pathd = last_pv.pathl;
          }
#line 4905
          if (last_pv.pathl == 0) {
#line 4906
            last_pv.pathd = 0;
          }
#line 4907
          tree->pv[0] = last_pv;
        } else {
#line 4897
          goto _L___18;
        }
      } else {
        _L___18: /* CIL Label */ 
#line 4909
        last_pv.pathd = 0;
#line 4910
        last_pv.pathl = 0;
#line 4911
        ponder_move = 0;
#line 4912
        tree->pv[0] = last_pv;
      }
    }
#line 4916
    strcpy(buffer, (char const   *)"score");
#line 4917
    Option(tree);
#line 4919
    i = GameOver(game_wtm);
#line 4919
    if (i) {
#line 4920
      if (i == 1) {
#line 4921
        Print(-1, "1/2-1/2 {stalemate}\n");
      }
    }
#line 4923
    if (book_move) {
#line 4924
      moves_out_of_book = 0;
#line 4925
      predicted ++;
#line 4926
      if (ponder_move) {
#line 4927
        tmp___30 = OutputMove(tree, 0, game_wtm, ponder_move);
#line 4927
        sprintf(book_hint, (char const   *)"%s", tmp___30);
      }
    } else {
#line 4929
      moves_out_of_book ++;
    }
#line 4942
    if (learning) {
#line 4942
      if (moves_out_of_book) {
#line 4942
        if (! learn_value) {
#line 4943
          LearnValue(last_value, last_pv.pathd + 2);
        } else {
#line 4942
          goto _L___20;
        }
      } else {
#line 4942
        goto _L___20;
      }
    } else {
      _L___20: /* CIL Label */ 
      _L___19: /* CIL Label */ ;
    }
#line 4944
    if (learn_positions_count < 63) {
#line 4945
      learn_seekto[learn_positions_count] = book_learn_seekto;
#line 4946
      learn_key[learn_positions_count] = book_learn_key;
#line 4947
      tmp___31 = learn_positions_count;
#line 4947
      learn_positions_count ++;
#line 4947
      learn_nmoves[tmp___31] = book_learn_nmoves;
    }
#line 4949
    if ((unsigned int )mode == 1U) {
#line 4950
      strcpy(buffer, (char const   *)"clock");
#line 4951
      Option(tree);
#line 4952
      Print(32, "if clocks are wrong, use \'settc\' command to adjust them\n");
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 4955
  return (0);
}
}
#line 21 "option.c"
int Option(TREE *tree ) 
{ 
  int v ;
  int tmp ;
  char *tmp___0 ;
  uint64_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int mod ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int side ;
  char *tmp___17 ;
  char *tmp___18 ;
  int i ;
  int set ;
  int old_display_options ;
  char *doptions[8] ;
  char *descriptions[8] ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int file ;
  int rank ;
  int piece ;
  int temp ;
  int file___0 ;
  int rank___0 ;
  int piece___0 ;
  int move ;
  int movenum ;
  int save_move_number ;
  char text___0[16] ;
  char *tmp___31 ;
  char *tmp___32 ;
  int t ;
  char temp___0[128] ;
  int tmp___33 ;
  int tmp___34 ;
  int i___0 ;
  char buffer___3[128] ;
  size_t old_hash_size ;
  size_t new_hash_size ;
  int tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  size_t old_hash_size___0 ;
  size_t new_hash_size___0 ;
  int tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  size_t old_hash_size___1 ;
  size_t new_hash_size___1 ;
  int tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  FILE *helpfile ;
  char *readstat ;
  int lines ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  int tmp___47 ;
  size_t tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int index___0[32768] ;
  int i___1 ;
  int j___0 ;
  int cluster ;
  unsigned char buf32[4] ;
  size_t tmp___55 ;
  size_t tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  char *tmp___59 ;
  int tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;
  uint64_t positions_per_move ;
  float percent ;
  int optimal_hash_size ;
  char **targs ;
  char listname[5][3] ;
  unsigned int tmp___63 ;
  char **listaddr[5] ;
  int i___2 ;
  int list ;
  int lastent ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  size_t tmp___67 ;
  void *tmp___68 ;
  char filename[256] ;
  FILE *file___1 ;
  char *tmp___69 ;
  size_t tmp___70 ;
  void *tmp___71 ;
  char filename___0[256] ;
  FILE *file___2 ;
  char *tmp___72 ;
  size_t tmp___73 ;
  void *tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int i___3 ;
  int i___4 ;
  int j___1 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  char *axis ;
  char *axis___0 ;
  char title[64] ;
  char *readstat___0 ;
  FILE *prob_file ;
  char *delim ;
  int tmp___81 ;
  char *tmp___82 ;
  int tmp___83 ;
  char *delim___0 ;
  int tmp___84 ;
  int tmp___85 ;
  char filename___1[64] ;
  int id ;
  int tmp___86 ;
  int tmp___87 ;
  uint64_t size ;
  size_t hmemory ;
  size_t pmemory ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  char *next___0 ;
  int i___5 ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___94 ;
  __int32_t const   **tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  FILE *normal_bs_file___0 ;
  int tmp___99 ;
  unsigned int tmp___100 ;
  double tmp___101 ;
  char *tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int i___6 ;
  int j___2 ;
  int param ;
  int index___1 ;
  int value ;
  int tmp___105 ;
  FILE *file___3 ;
  char filename___2[256] ;
  char *tmp___106 ;
  char *delim___1 ;
  char *tmp___107 ;
  int tmp___108 ;
  char filename___3[256] ;
  FILE *file___4 ;
  char *tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  char *tmp___114 ;
  char *tmp___115 ;
  char *tmp___116 ;
  char *tmp___117 ;
  char *tmp___118 ;
  char *tmp___119 ;
  char *tmp___120 ;
  char *tmp___121 ;
  char *tmp___122 ;
  int i___7 ;
  int clock_before ;
  int clock_after ;
  unsigned int *mv ;
  float time_used___0 ;
  clock_t tmp___123 ;
  clock_t tmp___124 ;
  clock_t tmp___125 ;
  clock_t tmp___126 ;
  clock_t tmp___127 ;
  clock_t tmp___128 ;
  clock_t tmp___129 ;
  clock_t tmp___130 ;
  float time_used___1 ;
  int i___8 ;
  int clock_before___0 ;
  int clock_after___0 ;
  clock_t tmp___131 ;
  clock_t tmp___132 ;
  clock_t tmp___133 ;
  clock_t tmp___134 ;
  int i___9 ;
  size_t tmp___135 ;
  size_t tmp___136 ;
  size_t tmp___137 ;
  size_t tmp___138 ;
  size_t tmp___139 ;
  size_t tmp___140 ;
  size_t tmp___141 ;
  size_t tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  int pversion ;
  int tmp___152 ;
  int rd ;
  int tmp___153 ;
  int tmp___154 ;
  int tmp___155 ;
  FILE *read_input ;
  int append ;
  int move___0 ;
  int readstat___1 ;
  int tmp___156 ;
  char *tmp___157 ;
  char *tmp___158 ;
  int tmp___159 ;
  int i___10 ;
  int move___1 ;
  int nmoves ;
  int tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  char *tmp___165 ;
  struct tm *timestruct ;
  FILE *output_file ;
  time_t secs ;
  int i___11 ;
  int more ;
  int swtm ;
  char input[128] ;
  char text___1[128] ;
  char *next___1 ;
  int tmp___166 ;
  int tmp___167 ;
  size_t tmp___168 ;
  size_t tmp___169 ;
  size_t tmp___170 ;
  FILE *output_file___0 ;
  int rank___1 ;
  int file___5 ;
  int nempty ;
  int tmp___171 ;
  size_t tmp___172 ;
  size_t tmp___173 ;
  size_t tmp___174 ;
  size_t tmp___175 ;
  int tmp___176 ;
  int tmp___177 ;
  size_t tmp___178 ;
  size_t tmp___179 ;
  size_t tmp___180 ;
  size_t tmp___181 ;
  size_t tmp___182 ;
  size_t tmp___183 ;
  size_t tmp___184 ;
  size_t tmp___185 ;
  int phase ;
  int s ;
  int tw ;
  int tb ;
  int mgb ;
  int mgw ;
  int egb ;
  int egw ;
  int trop[2] ;
  char *tmp___186 ;
  char *tmp___187 ;
  char *tmp___188 ;
  char *tmp___189 ;
  char *tmp___190 ;
  char *tmp___191 ;
  char *tmp___192 ;
  char *tmp___193 ;
  char *tmp___194 ;
  char *tmp___195 ;
  char *tmp___196 ;
  char *tmp___197 ;
  char *tmp___198 ;
  char *tmp___199 ;
  char *tmp___200 ;
  char *tmp___201 ;
  char *tmp___202 ;
  char *tmp___203 ;
  char *tmp___204 ;
  char *tmp___205 ;
  char *tmp___206 ;
  char *tmp___207 ;
  char *tmp___208 ;
  char *tmp___209 ;
  char *tmp___210 ;
  char *tmp___211 ;
  char *tmp___212 ;
  char *tmp___213 ;
  char *tmp___214 ;
  char *tmp___215 ;
  char *tmp___216 ;
  char *tmp___217 ;
  char *tmp___218 ;
  char *tmp___219 ;
  char *tmp___220 ;
  char *tmp___221 ;
  char *tmp___222 ;
  char *tmp___223 ;
  char *tmp___224 ;
  char *tmp___225 ;
  char *tmp___226 ;
  char *tmp___227 ;
  char *tmp___228 ;
  char *tmp___229 ;
  char *tmp___230 ;
  char *tmp___231 ;
  char *tmp___232 ;
  char *tmp___233 ;
  char *tmp___234 ;
  char *tmp___235 ;
  char *tmp___236 ;
  char *tmp___237 ;
  int margin ;
  int save_noise ;
  int save_display ;
  int tmp___238 ;
  int tmp___239 ;
  char *tmp___240 ;
  char *tmp___241 ;
  int tmp___242 ;
  int tmp___243 ;
  int tmp___244 ;
  int tmp___245 ;
  int proc ;
  int tmp___246 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  double tmp___253 ;
  int tmp___254 ;
  int tmp___255 ;
  struct tm *timestruct___0 ;
  uint64_t secs___0 ;
  time_t tmp___256 ;
  FILE *unsolved ;
  int save_noise___0 ;
  int save_display___0 ;
  char *tmp___257 ;
  int tmp___258 ;
  int tmp___259 ;
  int tmp___260 ;
  int tmp___261 ;
  int tmp___262 ;
  int tmp___263 ;
  int tmp___264 ;
  int tmp___265 ;
  int tmp___266 ;
  int i___12 ;
  unsigned int tmp___267 ;
  unsigned int tmp___268 ;
  int tmp___269 ;
  int tmp___270 ;
  int tmp___271 ;
  int tmp___272 ;
  int tmp___273 ;
  int tmp___274 ;
  int tmp___275 ;
  int tmp___276 ;
  int tmp___277 ;
  int tmp___278 ;
  int tmp___279 ;
  int tmp___280 ;
  int tmp___281 ;
  int tmp___282 ;
  int tmp___283 ;
  int tmp___284 ;
  int tmp___285 ;
  int tmp___286 ;
  int tmp___287 ;
  int tmp___288 ;
  int tmp___289 ;
  int tmp___290 ;
  int tmp___291 ;
  int tmp___292 ;
  int tmp___293 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  int tmp___298 ;
  int tmp___299 ;
  int tmp___300 ;
  int tmp___301 ;
  int tmp___302 ;
  int tmp___303 ;
  int tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  int tmp___310 ;
  int tmp___311 ;
  int tmp___312 ;
  int tmp___313 ;
  int tmp___314 ;
  int tmp___315 ;
  int tmp___316 ;
  int tmp___317 ;
  int tmp___318 ;
  int tmp___319 ;
  int tmp___320 ;
  int tmp___321 ;
  int tmp___322 ;
  int tmp___323 ;
  int tmp___324 ;
  int tmp___325 ;
  int tmp___326 ;
  int tmp___327 ;
  int tmp___328 ;
  int tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  int tmp___332 ;
  int tmp___333 ;
  int tmp___334 ;
  int tmp___335 ;
  int tmp___336 ;
  int tmp___337 ;
  int tmp___338 ;
  int tmp___339 ;
  int tmp___340 ;
  int tmp___341 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  int tmp___346 ;
  int tmp___347 ;
  int tmp___348 ;
  int tmp___349 ;
  int tmp___350 ;
  int tmp___351 ;
  int tmp___352 ;
  int tmp___353 ;
  int tmp___354 ;
  int tmp___355 ;
  int tmp___356 ;
  int tmp___357 ;
  int tmp___358 ;
  int tmp___359 ;
  int tmp___360 ;
  int tmp___361 ;
  int tmp___362 ;
  int tmp___363 ;
  int tmp___364 ;
  int tmp___365 ;
  int tmp___366 ;
  int tmp___367 ;
  int tmp___368 ;
  int tmp___369 ;
  int tmp___370 ;
  int tmp___371 ;
  int tmp___372 ;
  int tmp___373 ;
  int tmp___374 ;
  int tmp___375 ;
  int tmp___376 ;
  int tmp___377 ;
  int tmp___378 ;
  int tmp___379 ;
  int tmp___380 ;
  int tmp___381 ;
  int tmp___382 ;
  int tmp___383 ;
  int tmp___384 ;
  int tmp___385 ;
  int tmp___386 ;
  int tmp___387 ;
  int tmp___388 ;
  int tmp___389 ;
  int tmp___390 ;
  int tmp___391 ;
  int tmp___392 ;
  int tmp___393 ;
  int tmp___394 ;
  int tmp___395 ;
  int tmp___396 ;
  int tmp___397 ;
  int tmp___398 ;

  {
#line 32
  tmp = StrCnt(buffer, (char )'/');
#line 32
  if (tmp >= 7) {
#line 33
    nargs = ReadParse(buffer, args, " \t;=");
  } else {
#line 35
    nargs = ReadParse(buffer, args, " \t;=/");
  }
#line 36
  if (! nargs) {
#line 37
    return (1);
  }
#line 38
  if ((int )*(args[0] + 0) == 35) {
#line 39
    return (1);
  }
#line 73
  if ((int )buffer[0] == 33) {
#line 74
    if (! xboard) {
#line 75
      tmp___0 = strchr((char const   *)(buffer), '!');
#line 75
      v = system((char const   *)(tmp___0 + 1));
#line 76
      if (v != 0) {
#line 77
        perror((char const   *)"Option() system() error: ");
      }
    }
  } else {
#line 88
    tmp___398 = OptionMatch(".", args[0]);
#line 88
    if (tmp___398) {
#line 89
      if (xboard) {
#line 90
        printf((char const   *)"stat01: 0 0 0 0 0\n");
#line 91
        fflush(stdout);
#line 92
        return (1);
      } else {
#line 94
        return (0);
      }
    } else {
#line 104
      tmp___397 = OptionMatch("accepted", args[0]);
#line 104
      if (! tmp___397) {
#line 123
        tmp___396 = OptionMatch("adaptive", args[0]);
#line 123
        if (tmp___396) {
#line 124
          if (nargs != 6) {
#line 125
            printf((char const   *)"usage:  adaptive NPS hmin hmax pmin pmax\n");
#line 126
            return (1);
          }
#line 128
          if (nargs > 1) {
#line 129
            tmp___1 = atoiKMB(args[1]);
#line 129
            adaptive_hash = (int )tmp___1;
#line 130
            adaptive_hash_min = atoiKMB(args[2]);
#line 131
            adaptive_hash_max = atoiKMB(args[3]);
#line 132
            adaptive_hashp_min = atoiKMB(args[4]);
#line 133
            adaptive_hashp_max = atoiKMB(args[5]);
          }
#line 135
          tmp___2 = DisplayKMB((uint64_t )adaptive_hash, 1);
#line 135
          Print(32, "adaptive estimated NPS =  %s\n", tmp___2);
#line 136
          tmp___3 = DisplayKMB(adaptive_hash_min, 1);
#line 136
          Print(32, "adaptive minimum hsize =  %s\n", tmp___3);
#line 138
          tmp___4 = DisplayKMB(adaptive_hash_max, 1);
#line 138
          Print(32, "adaptive maximum hsize =  %s\n", tmp___4);
#line 140
          tmp___5 = DisplayKMB(adaptive_hashp_min, 1);
#line 140
          Print(32, "adaptive minimum psize =  %s\n", tmp___5);
#line 142
          tmp___6 = DisplayKMB(adaptive_hashp_max, 1);
#line 142
          Print(32, "adaptive maximum psize =  %s\n", tmp___6);
        } else {
#line 152
          tmp___395 = OptionMatch("alarm", args[0]);
#line 152
          if (tmp___395) {
#line 153
            tmp___8 = strcmp((char const   *)args[1], (char const   *)"on");
#line 153
            if (tmp___8) {
#line 155
              tmp___7 = strcmp((char const   *)args[1], (char const   *)"off");
#line 155
              if (tmp___7) {
#line 158
                printf((char const   *)"usage:  alarm on|off\n");
              } else {
#line 156
                audible_alarm = (char)0;
              }
            } else {
#line 154
              audible_alarm = (char)7;
            }
          } else {
#line 172
            tmp___394 = OptionMatch("analyze", args[0]);
#line 172
            if (tmp___394) {
#line 173
              if (thinking) {
#line 173
                goto _L;
              } else
#line 173
              if (pondering) {
                _L: /* CIL Label */ 
#line 174
                return (2);
              }
#line 175
              Analyze();
            } else {
#line 188
              tmp___391 = OptionMatch("annotate", args[0]);
#line 188
              if (tmp___391) {
#line 188
                goto _L___79;
              } else {
#line 188
                tmp___392 = OptionMatch("annotateh", args[0]);
#line 188
                if (tmp___392) {
                  _L___79: /* CIL Label */ 
#line 188
                  goto _L___78;
                } else {
#line 188
                  tmp___393 = OptionMatch("annotatet", args[0]);
#line 188
                  if (tmp___393) {
                    _L___78: /* CIL Label */ 
#line 190
                    if (thinking) {
#line 190
                      goto _L___0;
                    } else
#line 190
                    if (pondering) {
                      _L___0: /* CIL Label */ 
#line 191
                      return (2);
                    }
#line 192
                    Annotate();
                  } else {
#line 202
                    tmp___390 = OptionMatch("autotune", args[0]);
#line 202
                    if (tmp___390) {
#line 203
                      if (thinking) {
#line 203
                        goto _L___1;
                      } else
#line 203
                      if (pondering) {
                        _L___1: /* CIL Label */ 
#line 204
                        return (2);
                      }
#line 205
                      AutoTune(nargs, args);
                    } else {
#line 216
                      tmp___389 = OptionMatch("batch", args[0]);
#line 216
                      if (tmp___389) {
#line 217
                        tmp___10 = strcmp((char const   *)args[1], (char const   *)"on");
#line 217
                        if (tmp___10) {
#line 219
                          tmp___9 = strcmp((char const   *)args[1], (char const   *)"off");
#line 219
                          if (tmp___9) {
#line 222
                            printf((char const   *)"usage:  batch on|off\n");
                          } else {
#line 220
                            batch_mode = 0;
                          }
                        } else {
#line 218
                          batch_mode = 1;
                        }
                      } else {
#line 231
                        tmp___388 = OptionMatch("beep", args[0]);
#line 231
                        if (tmp___388) {
#line 232
                          return (xboard);
                        } else {
#line 245
                          tmp___387 = OptionMatch("bench", args[0]);
#line 245
                          if (tmp___387) {
#line 246
                            mod = 0;
#line 248
                            if (nargs > 1) {
#line 249
                              mod = atoi((char const   *)args[1]);
                            }
#line 250
                            Bench(mod, 0);
                          } else {
#line 260
                            tmp___386 = OptionMatch("bk", args[0]);
#line 260
                            if (tmp___386) {
#line 261
                              printf((char const   *)"\t%s\n\n", book_hint);
#line 262
                              fflush(stdout);
#line 263
                              return (xboard);
                            } else {
#line 272
                              tmp___385 = OptionMatch("white", args[0]);
#line 272
                              if (tmp___385) {
#line 273
                                if (thinking) {
#line 273
                                  goto _L___2;
                                } else
#line 273
                                if (pondering) {
                                  _L___2: /* CIL Label */ 
#line 274
                                  return (2);
                                }
#line 275
                                game_wtm = 1;
#line 276
                                ponder_move = 0;
#line 277
                                last_pv.pathd = 0;
#line 278
                                last_pv.pathl = 0;
#line 279
                                if (! game_wtm) {
#line 280
                                  Pass();
                                }
#line 281
                                force = 0;
                              } else {
#line 282
                                tmp___384 = OptionMatch("black", args[0]);
#line 282
                                if (tmp___384) {
#line 283
                                  if (thinking) {
#line 283
                                    goto _L___3;
                                  } else
#line 283
                                  if (pondering) {
                                    _L___3: /* CIL Label */ 
#line 284
                                    return (2);
                                  }
#line 285
                                  game_wtm = 0;
#line 286
                                  ponder_move = 0;
#line 287
                                  last_pv.pathd = 0;
#line 288
                                  last_pv.pathl = 0;
#line 289
                                  if (game_wtm) {
#line 290
                                    Pass();
                                  }
#line 291
                                  force = 0;
                                } else {
#line 300
                                  tmp___383 = OptionMatch("bogus", args[0]);
#line 300
                                  if (tmp___383) {
#line 301
                                    return (xboard);
                                  } else {
#line 310
                                    tmp___382 = OptionMatch("book", args[0]);
#line 310
                                    if (tmp___382) {
#line 311
                                      nargs = ReadParse(buffer, args, " \t;");
#line 312
                                      Bookup(tree, nargs, args);
                                    } else {
#line 313
                                      tmp___381 = strcmp((char const   *)"create",
                                                         (char const   *)*(args + 1));
#line 313
                                      if (tmp___381) {
#line 324
                                        tmp___380 = OptionMatch("bookw", args[0]);
#line 324
                                        if (tmp___380) {
#line 325
                                          if (nargs > 1) {
#line 326
                                            tmp___16 = OptionMatch("frequency", args[1]);
#line 326
                                            if (tmp___16) {
#line 327
                                              tmp___11 = atof((char const   *)args[2]);
#line 327
                                              book_weight_freq = (float )tmp___11;
                                            } else {
#line 328
                                              tmp___15 = OptionMatch("evaluation",
                                                                     args[1]);
#line 328
                                              if (tmp___15) {
#line 329
                                                tmp___12 = atof((char const   *)args[2]);
#line 329
                                                book_weight_eval = (float )tmp___12;
                                              } else {
#line 330
                                                tmp___14 = OptionMatch("learning",
                                                                       args[1]);
#line 330
                                                if (tmp___14) {
#line 331
                                                  tmp___13 = atof((char const   *)args[2]);
#line 331
                                                  book_weight_learn = (float )tmp___13;
                                                }
                                              }
                                            }
                                          } else {
#line 333
                                            Print(32, "frequency (freq)..............%4.2f\n",
                                                  (double )book_weight_freq);
#line 334
                                            Print(32, "static evaluation (eval)......%4.2f\n",
                                                  (double )book_weight_eval);
#line 335
                                            Print(32, "learning (learn)..............%4.2f\n",
                                                  (double )book_weight_learn);
                                          }
                                        } else {
#line 345
                                          tmp___379 = OptionMatch("clock", args[0]);
#line 345
                                          if (tmp___379) {
#line 348
                                            side = 1;
                                            {
#line 348
                                            while (1) {
                                              while_continue: /* CIL Label */ ;
#line 348
                                              if (! (side >= 0)) {
#line 348
                                                goto while_break;
                                              }
#line 349
                                              tmp___17 = DisplayHHMMSS((unsigned int )tc_time_remaining[side]);
#line 349
                                              if (side) {
#line 349
                                                tmp___18 = "white";
                                              } else {
#line 349
                                                tmp___18 = "black";
                                              }
#line 349
                                              Print(32, "time remaining (%s): %s",
                                                    tmp___18, tmp___17);
#line 351
                                              if (tc_sudden_death != 1) {
#line 352
                                                Print(32, "  (%d more moves)", tc_moves_remaining[side]);
                                              }
#line 353
                                              Print(32, "\n");
#line 348
                                              side --;
                                            }
                                            while_break: /* CIL Label */ ;
                                            }
#line 355
                                            Print(32, "\n");
#line 356
                                            if (tc_sudden_death == 1) {
#line 357
                                              Print(32, "Sudden-death time control in effect\n");
                                            }
                                          } else {
#line 366
                                            tmp___378 = OptionMatch("computer", args[0]);
#line 366
                                            if (tmp___378) {
#line 367
                                              Print(32, "playing a computer!\n");
#line 368
                                              accept_draws = 1;
#line 369
                                              if (resign) {
#line 370
                                                resign = 10;
                                              }
#line 371
                                              resign_count = 4;
#line 372
                                              usage_level = 0;
#line 373
                                              if (computer_bs_file) {
#line 373
                                                books_file = computer_bs_file;
                                              } else {
#line 373
                                                books_file = normal_bs_file;
                                              }
                                            } else {
#line 399
                                              tmp___377 = OptionMatch("display", args[0]);
#line 399
                                              if (tmp___377) {
#line 400
                                                old_display_options = display_options;
#line 401
                                                doptions[0] = "moveinfo";
#line 401
                                                doptions[1] = "pv";
#line 401
                                                doptions[2] = "fail";
#line 401
                                                doptions[3] = "stats";
#line 401
                                                doptions[4] = "moves";
#line 401
                                                doptions[5] = "info";
#line 401
                                                doptions[6] = "ply1";
#line 401
                                                doptions[7] = "movelist";
#line 404
                                                descriptions[0] = "display move time/results/etc";
#line 404
                                                descriptions[1] = "principal variation";
#line 404
                                                descriptions[2] = "fail highs/lows";
#line 404
                                                descriptions[3] = "search statistics";
#line 404
                                                descriptions[4] = "root moves as they are searched";
#line 404
                                                descriptions[5] = "general information";
#line 404
                                                descriptions[6] = "ply1 move list after each iteration";
#line 404
                                                descriptions[7] = "root move list and scores prior to search";
#line 411
                                                if (nargs > 1) {
#line 412
                                                  tmp___19 = strcmp((char const   *)args[1],
                                                                    (char const   *)"all");
#line 412
                                                  if (! tmp___19) {
#line 413
                                                    old_display_options = ~ display_options;
                                                  }
#line 414
                                                  i = 0;
                                                  {
#line 414
                                                  while (1) {
                                                    while_continue___0: /* CIL Label */ ;
#line 414
                                                    if (! (i < 8)) {
#line 414
                                                      goto while_break___0;
                                                    }
#line 415
                                                    tmp___21 = strstr((char const   *)args[1],
                                                                      (char const   *)doptions[i]);
#line 415
                                                    if (tmp___21) {
#line 416
                                                      tmp___20 = strstr((char const   *)args[1],
                                                                        (char const   *)"no");
#line 416
                                                      if (tmp___20) {
#line 417
                                                        set = 0;
                                                      } else {
#line 419
                                                        set = 1;
                                                      }
#line 420
                                                      display_options &= ~ (1 << i);
#line 421
                                                      display_options |= set << i;
#line 422
                                                      goto while_break___0;
                                                    }
#line 414
                                                    i ++;
                                                  }
                                                  while_break___0: /* CIL Label */ ;
                                                  }
#line 425
                                                  i = 0;
                                                  {
#line 425
                                                  while (1) {
                                                    while_continue___1: /* CIL Label */ ;
#line 425
                                                    if (! (i < 8)) {
#line 425
                                                      goto while_break___1;
                                                    }
#line 426
                                                    if ((old_display_options & (1 << i)) != (display_options & (1 << i))) {
#line 427
                                                      Print(32, "display ");
#line 428
                                                      if (! (display_options & (1 << i))) {
#line 429
                                                        Print(32, "no");
                                                      }
#line 430
                                                      Print(32, "%s (%s)\n", doptions[i],
                                                            descriptions[i]);
                                                    }
#line 425
                                                    i ++;
                                                  }
                                                  while_break___1: /* CIL Label */ ;
                                                  }
                                                } else {
#line 434
                                                  DisplayChessBoard(stdout, display);
                                                }
                                              } else {
#line 444
                                                tmp___376 = OptionMatch("debug", args[0]);
#line 444
                                                if (tmp___376) {
#line 445
                                                  Print(32, "ERROR:  no debug code included\n");
                                                } else {
#line 455
                                                  tmp___375 = OptionMatch("depth",
                                                                          args[0]);
#line 455
                                                  if (tmp___375) {
#line 456
                                                    if (nargs < 2) {
#line 457
                                                      printf((char const   *)"usage:  depth <n>\n");
#line 458
                                                      return (1);
                                                    }
#line 460
                                                    search_depth = atoi((char const   *)args[1]);
#line 461
                                                    Print(32, "search depth set to %d.\n",
                                                          search_depth);
                                                  } else {
#line 471
                                                    tmp___374 = OptionMatch("draw",
                                                                            args[0]);
#line 471
                                                    if (tmp___374) {
#line 472
                                                      if (nargs == 1) {
#line 473
                                                        draw_offer_pending = 1;
#line 474
                                                        if (draw_offered) {
#line 475
                                                          Print(4095, "1/2-1/2 {Draw agreed}\n");
#line 476
                                                          strcpy(pgn_result, (char const   *)"1/2-1/2");
                                                        }
                                                      } else {
#line 479
                                                        tmp___27 = strcmp((char const   *)args[1],
                                                                          (char const   *)"accept");
#line 479
                                                        if (tmp___27) {
#line 482
                                                          tmp___26 = strcmp((char const   *)args[1],
                                                                            (char const   *)"decline");
#line 482
                                                          if (tmp___26) {
#line 485
                                                            tmp___25 = strcmp((char const   *)args[1],
                                                                              (char const   *)"dynamic");
#line 485
                                                            if (tmp___25) {
#line 490
                                                              tmp___24 = strcmp((char const   *)args[1],
                                                                                (char const   *)"offer");
#line 490
                                                              if (tmp___24) {
#line 493
                                                                tmp___23 = strcmp((char const   *)args[1],
                                                                                  (char const   *)"nooffer");
#line 493
                                                                if (tmp___23) {
#line 497
                                                                  Print(32, "usage: draw accept|decline|offer|nooffer\n");
                                                                } else {
#line 494
                                                                  offer_draws = 0;
#line 495
                                                                  Print(32, "do not offer draws\n");
                                                                }
                                                              } else {
#line 491
                                                                offer_draws = 1;
#line 492
                                                                Print(32, "offer draws\n");
                                                              }
                                                            } else {
#line 486
                                                              if (nargs > 2) {
#line 487
                                                                dynamic_draw_score = atoi((char const   *)args[2]);
                                                              }
#line 488
                                                              if (dynamic_draw_score) {
#line 488
                                                                tmp___22 = "enabled";
                                                              } else {
#line 488
                                                                tmp___22 = "disabled";
                                                              }
#line 488
                                                              Print(32, "dynamic draw scores %s\n",
                                                                    tmp___22);
                                                            }
                                                          } else {
#line 483
                                                            accept_draws = 0;
#line 484
                                                            Print(32, "decline draw offers\n");
                                                          }
                                                        } else {
#line 480
                                                          accept_draws = 1;
#line 481
                                                          Print(32, "accept draw offers\n");
                                                        }
                                                      }
                                                    } else {
#line 507
                                                      tmp___373 = OptionMatch("easy",
                                                                              args[0]);
#line 507
                                                      if (tmp___373) {
#line 508
                                                        if (thinking) {
#line 508
                                                          goto _L___4;
                                                        } else
#line 508
                                                        if (pondering) {
                                                          _L___4: /* CIL Label */ 
#line 509
                                                          return (2);
                                                        }
#line 510
                                                        ponder = 0;
#line 511
                                                        Print(32, "pondering disabled.\n");
                                                      } else {
#line 520
                                                        tmp___371 = OptionMatch("echo",
                                                                                args[0]);
#line 520
                                                        if (tmp___371) {
#line 520
                                                          goto _L___77;
                                                        } else {
#line 520
                                                          tmp___372 = OptionMatch("title",
                                                                                  args[0]);
#line 520
                                                          if (tmp___372) {
                                                            _L___77: /* CIL Label */ ;
                                                          } else {
#line 529
                                                            tmp___370 = OptionMatch("edit",
                                                                                    args[0]);
#line 529
                                                            if (tmp___370) {
#line 530
                                                              if (thinking) {
#line 530
                                                                goto _L___5;
                                                              } else
#line 530
                                                              if (pondering) {
                                                                _L___5: /* CIL Label */ 
#line 531
                                                                return (2);
                                                              }
#line 532
                                                              Edit();
#line 533
                                                              move_number = 1;
#line 534
                                                              if (! game_wtm) {
#line 535
                                                                game_wtm = 1;
#line 536
                                                                Pass();
                                                              }
#line 538
                                                              ponder_move = 0;
#line 539
                                                              last_pv.pathd = 0;
#line 540
                                                              last_pv.pathl = 0;
#line 541
                                                              strcpy(buffer, (char const   *)"savepos *");
#line 542
                                                              Option(tree);
                                                            } else {
#line 551
                                                              tmp___369 = OptionMatch("egtb",
                                                                                      args[0]);
#line 551
                                                              if (tmp___369) {
#line 553
                                                                tmp___28 = strcmp((char const   *)args[1],
                                                                                  (char const   *)"off");
#line 553
                                                                if (tmp___28) {
#line 556
                                                                  if (! EGTB_setup) {
#line 557
                                                                    tb_init((char const   *)(tb_path));
#line 558
                                                                    EGTB_setup = 1;
                                                                  }
#line 560
                                                                  EGTBlimit = (int )TB_LARGEST;
                                                                } else {
#line 554
                                                                  EGTBlimit = 0;
                                                                }
#line 562
                                                                if (EGTBlimit) {
#line 563
                                                                  Print(32, "SYZYGY EGTB access enabled, %d piece TBs found\n",
                                                                        TB_LARGEST);
                                                                } else {
#line 566
                                                                  Print(32, "SYZYGY EGTB access disabled.\n");
                                                                }
                                                              } else {
#line 581
                                                                tmp___368 = OptionMatch("egtbd",
                                                                                        args[0]);
#line 581
                                                                if (tmp___368) {
#line 582
                                                                  if (nargs > 1) {
#line 583
                                                                    EGTB_depth = atoi((char const   *)args[1]);
                                                                  }
#line 584
                                                                  Print(32, "EGTB probe depth set to %d\n",
                                                                        EGTB_depth);
                                                                } else {
#line 594
                                                                  tmp___366 = OptionMatch("end",
                                                                                          args[0]);
#line 594
                                                                  if (tmp___366) {
#line 594
                                                                    goto _L___76;
                                                                  } else {
#line 594
                                                                    tmp___367 = OptionMatch("quit",
                                                                                            args[0]);
#line 594
                                                                    if (tmp___367) {
                                                                      _L___76: /* CIL Label */ 
#line 595
                                                                      abort_search = 1;
#line 596
                                                                      quit = 1;
#line 597
                                                                      if (crafty_is_white) {
#line 597
                                                                        last_search_value = last_search_value;
                                                                      } else {
#line 597
                                                                        last_search_value = - last_search_value;
                                                                      }
#line 599
                                                                      if (moves_out_of_book) {
#line 600
                                                                        LearnBook();
                                                                      }
#line 601
                                                                      if (thinking) {
#line 601
                                                                        goto _L___6;
                                                                      } else
#line 601
                                                                      if (pondering) {
                                                                        _L___6: /* CIL Label */ 
#line 602
                                                                        return (1);
                                                                      }
#line 603
                                                                      CraftyExit(0);
                                                                    } else {
#line 613
                                                                      tmp___365 = OptionMatch("evtest",
                                                                                              args[0]);
#line 613
                                                                      if (tmp___365) {
#line 614
                                                                        if (thinking) {
#line 614
                                                                          goto _L___7;
                                                                        } else
#line 614
                                                                        if (pondering) {
                                                                          _L___7: /* CIL Label */ 
#line 615
                                                                          return (2);
                                                                        }
#line 616
                                                                        if (nargs < 2) {
#line 617
                                                                          printf((char const   *)"usage:  evtest <filename>\n");
#line 618
                                                                          return (1);
                                                                        }
#line 620
                                                                        EVTest(args[1]);
#line 621
                                                                        ponder_move = 0;
#line 622
                                                                        last_pv.pathd = 0;
#line 623
                                                                        last_pv.pathl = 0;
                                                                      } else {
#line 632
                                                                        tmp___364 = OptionMatch("exit",
                                                                                                args[0]);
#line 632
                                                                        if (tmp___364) {
#line 633
                                                                          if (analyze_mode) {
#line 634
                                                                            return (0);
                                                                          }
#line 635
                                                                          if ((unsigned long )input_stream != (unsigned long )stdin) {
#line 636
                                                                            fclose(input_stream);
                                                                          }
#line 637
                                                                          input_stream = stdin;
#line 638
                                                                          ReadClear();
#line 639
                                                                          Print(32,
                                                                                "\n");
                                                                        } else {
#line 649
                                                                          tmp___363 = OptionMatch("flag",
                                                                                                  args[0]);
#line 649
                                                                          if (tmp___363) {
#line 650
                                                                            if (nargs < 2) {
#line 651
                                                                              printf((char const   *)"usage:  flag on|off\n");
#line 652
                                                                              return (1);
                                                                            }
#line 654
                                                                            tmp___30 = strcmp((char const   *)args[1],
                                                                                              (char const   *)"on");
#line 654
                                                                            if (tmp___30) {
#line 656
                                                                              tmp___29 = strcmp((char const   *)args[1],
                                                                                                (char const   *)"off");
#line 656
                                                                              if (! tmp___29) {
#line 657
                                                                                call_flag = 0;
                                                                              }
                                                                            } else {
#line 655
                                                                              call_flag = 1;
                                                                            }
#line 658
                                                                            if (call_flag) {
#line 659
                                                                              Print(32,
                                                                                    "end game on time forfeits\n");
                                                                            } else {
#line 661
                                                                              Print(32,
                                                                                    "ignore time forfeits\n");
                                                                            }
                                                                          } else {
#line 672
                                                                            tmp___362 = OptionMatch("flip",
                                                                                                    args[0]);
#line 672
                                                                            if (tmp___362) {
#line 675
                                                                              if (thinking) {
#line 675
                                                                                goto _L___8;
                                                                              } else
#line 675
                                                                              if (pondering) {
                                                                                _L___8: /* CIL Label */ 
#line 676
                                                                                return (2);
                                                                              }
#line 677
                                                                              rank = 0;
                                                                              {
#line 677
                                                                              while (1) {
                                                                                while_continue___2: /* CIL Label */ ;
#line 677
                                                                                if (! (rank < 4)) {
#line 677
                                                                                  goto while_break___2;
                                                                                }
#line 678
                                                                                file = 0;
                                                                                {
#line 678
                                                                                while (1) {
                                                                                  while_continue___3: /* CIL Label */ ;
#line 678
                                                                                  if (! (file < 8)) {
#line 678
                                                                                    goto while_break___3;
                                                                                  }
#line 679
                                                                                  piece = - ((int )tree->position.board[(rank << 3) + file]);
#line 680
                                                                                  tree->position.board[(rank << 3) + file] = (int8_t )(- ((int )tree->position.board[((7 - rank) << 3) + file]));
#line 681
                                                                                  tree->position.board[((7 - rank) << 3) + file] = (int8_t )piece;
#line 678
                                                                                  file ++;
                                                                                }
                                                                                while_break___3: /* CIL Label */ ;
                                                                                }
#line 677
                                                                                rank ++;
                                                                              }
                                                                              while_break___2: /* CIL Label */ ;
                                                                              }
#line 684
                                                                              game_wtm ^= 1;
#line 685
                                                                              temp = (int )tree->status[0].castle[1];
#line 686
                                                                              tree->status[0].castle[1] = tree->status[0].castle[0];
#line 687
                                                                              tree->status[0].castle[0] = (int8_t )temp;
#line 688
                                                                              SetChessBitBoards(tree);
                                                                            } else {
#line 702
                                                                              tmp___361 = OptionMatch("flop",
                                                                                                      args[0]);
#line 702
                                                                              if (tmp___361) {
#line 705
                                                                                if (thinking) {
#line 705
                                                                                  goto _L___9;
                                                                                } else
#line 705
                                                                                if (pondering) {
                                                                                  _L___9: /* CIL Label */ 
#line 706
                                                                                  return (2);
                                                                                }
#line 707
                                                                                rank___0 = 0;
                                                                                {
#line 707
                                                                                while (1) {
                                                                                  while_continue___4: /* CIL Label */ ;
#line 707
                                                                                  if (! (rank___0 < 8)) {
#line 707
                                                                                    goto while_break___4;
                                                                                  }
#line 708
                                                                                  file___0 = 0;
                                                                                  {
#line 708
                                                                                  while (1) {
                                                                                    while_continue___5: /* CIL Label */ ;
#line 708
                                                                                    if (! (file___0 < 4)) {
#line 708
                                                                                      goto while_break___5;
                                                                                    }
#line 709
                                                                                    piece___0 = (int )tree->position.board[(rank___0 << 3) + file___0];
#line 710
                                                                                    tree->position.board[(rank___0 << 3) + file___0] = tree->position.board[((rank___0 << 3) + 7) - file___0];
#line 711
                                                                                    tree->position.board[((rank___0 << 3) + 7) - file___0] = (int8_t )piece___0;
#line 708
                                                                                    file___0 ++;
                                                                                  }
                                                                                  while_break___5: /* CIL Label */ ;
                                                                                  }
#line 707
                                                                                  rank___0 ++;
                                                                                }
                                                                                while_break___4: /* CIL Label */ ;
                                                                                }
#line 714
                                                                                SetChessBitBoards(tree);
                                                                              } else {
#line 727
                                                                                tmp___360 = OptionMatch("force",
                                                                                                        args[0]);
#line 727
                                                                                if (tmp___360) {
#line 731
                                                                                  if (thinking) {
#line 731
                                                                                    goto _L___10;
                                                                                  } else
#line 731
                                                                                  if (pondering) {
                                                                                    _L___10: /* CIL Label */ 
#line 732
                                                                                    return (3);
                                                                                  }
#line 733
                                                                                  if (xboard) {
#line 734
                                                                                    force = 1;
#line 735
                                                                                    return (3);
                                                                                  }
#line 737
                                                                                  if (nargs < 2) {
#line 738
                                                                                    printf((char const   *)"usage:  force <move>\n");
#line 739
                                                                                    return (1);
                                                                                  }
#line 741
                                                                                  ponder_move = 0;
#line 742
                                                                                  presult = 0;
#line 743
                                                                                  last_pv.pathd = 0;
#line 744
                                                                                  last_pv.pathl = 0;
#line 745
                                                                                  save_move_number = move_number;
#line 746
                                                                                  movenum = move_number;
#line 747
                                                                                  if (game_wtm) {
#line 748
                                                                                    movenum --;
                                                                                  }
#line 749
                                                                                  strcpy(text___0,
                                                                                         (char const   *)args[1]);
#line 750
                                                                                  sprintf(buffer,
                                                                                          (char const   *)"reset %d",
                                                                                          movenum);
#line 751
                                                                                  game_wtm ^= 1;
#line 752
                                                                                  Option(tree);
#line 753
                                                                                  move = InputMove(tree,
                                                                                                   0,
                                                                                                   game_wtm,
                                                                                                   0,
                                                                                                   0,
                                                                                                   text___0);
#line 754
                                                                                  if (move) {
#line 755
                                                                                    if ((unsigned long )input_stream != (unsigned long )stdin) {
#line 756
                                                                                      tmp___31 = OutputMove(tree,
                                                                                                            0,
                                                                                                            game_wtm,
                                                                                                            move);
#line 756
                                                                                      printf((char const   *)"%s\n",
                                                                                             tmp___31);
                                                                                    }
#line 757
                                                                                    if (history_file) {
#line 758
                                                                                      fseek(history_file,
                                                                                            (long )((((movenum - 1) * 2 + 1) - game_wtm) * 10),
                                                                                            0);
#line 760
                                                                                      tmp___32 = OutputMove(tree,
                                                                                                            0,
                                                                                                            game_wtm,
                                                                                                            move);
#line 760
                                                                                      fprintf(history_file,
                                                                                              (char const   *)"%9s\n",
                                                                                              tmp___32);
                                                                                    }
#line 762
                                                                                    MakeMoveRoot(tree,
                                                                                                 game_wtm,
                                                                                                 move);
#line 763
                                                                                    last_pv.pathd = 0;
#line 764
                                                                                    last_pv.pathl = 0;
                                                                                  } else
#line 765
                                                                                  if ((unsigned long )input_stream == (unsigned long )stdin) {
#line 766
                                                                                    printf((char const   *)"illegal move.\n");
                                                                                  }
#line 767
                                                                                  game_wtm ^= 1;
#line 768
                                                                                  move_number = save_move_number;
#line 769
                                                                                  strcpy(ponder_text,
                                                                                         (char const   *)"none");
                                                                                } else {
#line 779
                                                                                  tmp___358 = OptionMatch("go",
                                                                                                          args[0]);
#line 779
                                                                                  if (tmp___358) {
#line 779
                                                                                    goto _L___75;
                                                                                  } else {
#line 779
                                                                                    tmp___359 = OptionMatch("move",
                                                                                                            args[0]);
#line 779
                                                                                    if (tmp___359) {
                                                                                      _L___75: /* CIL Label */ 
#line 783
                                                                                      if (thinking) {
#line 783
                                                                                        goto _L___11;
                                                                                      } else
#line 783
                                                                                      if (pondering) {
                                                                                        _L___11: /* CIL Label */ 
#line 784
                                                                                        return (2);
                                                                                      }
#line 785
                                                                                      if (game_wtm) {
#line 786
                                                                                        tmp___33 = strncmp((char const   *)(pgn_white),
                                                                                                           (char const   *)"Crafty",
                                                                                                           (size_t )6);
#line 786
                                                                                        if (tmp___33) {
#line 787
                                                                                          strcpy(temp___0,
                                                                                                 (char const   *)(pgn_white));
#line 788
                                                                                          strcpy(pgn_white,
                                                                                                 (char const   *)(pgn_black));
#line 789
                                                                                          strcpy(pgn_black,
                                                                                                 (char const   *)(temp___0));
                                                                                        }
                                                                                      } else {
#line 792
                                                                                        tmp___34 = strncmp((char const   *)(pgn_black),
                                                                                                           (char const   *)"Crafty",
                                                                                                           (size_t )6);
#line 792
                                                                                        if (tmp___34) {
#line 793
                                                                                          strcpy(temp___0,
                                                                                                 (char const   *)(pgn_white));
#line 794
                                                                                          strcpy(pgn_white,
                                                                                                 (char const   *)(pgn_black));
#line 795
                                                                                          strcpy(pgn_black,
                                                                                                 (char const   *)(temp___0));
                                                                                        }
                                                                                      }
#line 798
                                                                                      t = tc_time_remaining[1];
#line 799
                                                                                      tc_time_remaining[1] = tc_time_remaining[0];
#line 800
                                                                                      tc_time_remaining[0] = t;
#line 801
                                                                                      t = tc_moves_remaining[1];
#line 802
                                                                                      tc_moves_remaining[1] = tc_moves_remaining[0];
#line 803
                                                                                      tc_moves_remaining[0] = t;
#line 804
                                                                                      force = 0;
#line 805
                                                                                      return (-1);
                                                                                    } else {
#line 814
                                                                                      tmp___357 = OptionMatch("history",
                                                                                                              args[0]);
#line 814
                                                                                      if (tmp___357) {
#line 818
                                                                                        if (history_file) {
#line 819
                                                                                          printf((char const   *)"    white       black\n");
#line 820
                                                                                          i___0 = 0;
                                                                                          {
#line 820
                                                                                          while (1) {
                                                                                            while_continue___6: /* CIL Label */ ;
#line 820
                                                                                            if (! (i___0 < ((move_number - 1) * 2 - game_wtm) + 1)) {
#line 820
                                                                                              goto while_break___6;
                                                                                            }
#line 821
                                                                                            fseek(history_file,
                                                                                                  (long )(i___0 * 10),
                                                                                                  0);
#line 822
                                                                                            v = fscanf(history_file,
                                                                                                       (char const   *)"%s",
                                                                                                       buffer___3);
#line 823
                                                                                            if (v <= 0) {
#line 824
                                                                                              perror((char const   *)"Option() fscanf error: ");
                                                                                            }
#line 825
                                                                                            if (! (i___0 % 2)) {
#line 826
                                                                                              printf((char const   *)"%3d",
                                                                                                     i___0 / 2 + 1);
                                                                                            }
#line 827
                                                                                            printf((char const   *)"  %-10s",
                                                                                                   buffer___3);
#line 828
                                                                                            if (i___0 % 2 == 1) {
#line 829
                                                                                              printf((char const   *)"\n");
                                                                                            }
#line 820
                                                                                            i___0 ++;
                                                                                          }
                                                                                          while_break___6: /* CIL Label */ ;
                                                                                          }
#line 831
                                                                                          if (game_wtm ^ 1) {
#line 832
                                                                                            printf((char const   *)"  ...\n");
                                                                                          }
                                                                                        }
                                                                                      } else {
#line 842
                                                                                        tmp___356 = OptionMatch("hard",
                                                                                                                args[0]);
#line 842
                                                                                        if (tmp___356) {
#line 843
                                                                                          ponder = 1;
#line 844
                                                                                          Print(32,
                                                                                                "pondering enabled.\n");
                                                                                        } else {
#line 864
                                                                                          tmp___355 = OptionMatch("hash",
                                                                                                                  args[0]);
#line 864
                                                                                          if (tmp___355) {
#line 865
                                                                                            old_hash_size = hash_table_size;
#line 867
                                                                                            if (thinking) {
#line 867
                                                                                              goto _L___12;
                                                                                            } else
#line 867
                                                                                            if (pondering) {
                                                                                              _L___12: /* CIL Label */ 
#line 868
                                                                                              return (2);
                                                                                            }
#line 869
                                                                                            if (nargs > 1) {
#line 870
                                                                                              allow_memory = 0;
#line 871
                                                                                              if (xboard) {
#line 872
                                                                                                Print(4095,
                                                                                                      "Warning--  xboard \'memory\' option disabled\n");
                                                                                              }
#line 873
                                                                                              new_hash_size = atoiKMB(args[1]);
#line 874
                                                                                              if (new_hash_size < 65536UL) {
#line 875
                                                                                                printf((char const   *)"ERROR.  Minimum hash table size is 64K bytes.\n");
#line 876
                                                                                                return (1);
                                                                                              }
#line 878
                                                                                              tmp___35 = __builtin_clzll((unsigned long long )new_hash_size);
#line 878
                                                                                              hash_table_size = (size_t )((1ull << (63 - tmp___35)) / 16ULL);
#line 879
                                                                                              AlignedRemalloc((void **)((void *)(& hash_table)),
                                                                                                              (uint64_t )64,
                                                                                                              hash_table_size * sizeof(HASH_ENTRY ));
#line 881
                                                                                              if (! hash_table) {
#line 882
                                                                                                printf((char const   *)"AlignedRemalloc() failed, not enough memory.\n");
#line 883
                                                                                                exit(1);
                                                                                              }
#line 885
                                                                                              hash_mask = (hash_table_size - 1UL) & 18446744073709551612UL;
                                                                                            }
#line 887
                                                                                            tmp___36 = DisplayKMB(hash_table_size * sizeof(HASH_ENTRY ),
                                                                                                                  1);
#line 887
                                                                                            Print(32,
                                                                                                  "hash table memory = %s bytes",
                                                                                                  tmp___36);
#line 889
                                                                                            tmp___37 = DisplayKMB(hash_table_size,
                                                                                                                  1);
#line 889
                                                                                            Print(32,
                                                                                                  " (%s entries).\n",
                                                                                                  tmp___37);
#line 890
                                                                                            InitializeHashTables(old_hash_size != hash_table_size);
                                                                                          } else {
#line 909
                                                                                            tmp___354 = OptionMatch("phash",
                                                                                                                    args[0]);
#line 909
                                                                                            if (tmp___354) {
#line 910
                                                                                              old_hash_size___0 = hash_path_size;
#line 912
                                                                                              if (thinking) {
#line 912
                                                                                                goto _L___13;
                                                                                              } else
#line 912
                                                                                              if (pondering) {
                                                                                                _L___13: /* CIL Label */ 
#line 913
                                                                                                return (2);
                                                                                              }
#line 914
                                                                                              if (nargs > 1) {
#line 915
                                                                                                new_hash_size___0 = atoiKMB(args[1]);
#line 916
                                                                                                if (new_hash_size___0 < 65536UL) {
#line 917
                                                                                                  printf((char const   *)"ERROR.  Minimum phash table size is 64K bytes.\n");
#line 918
                                                                                                  return (1);
                                                                                                }
#line 920
                                                                                                tmp___38 = __builtin_clzll((unsigned long long )(new_hash_size___0 / sizeof(HPATH_ENTRY )));
#line 920
                                                                                                hash_path_size = (size_t )(1ull << (63 - tmp___38));
#line 921
                                                                                                AlignedRemalloc((void **)((void *)(& hash_path)),
                                                                                                                (uint64_t )64,
                                                                                                                sizeof(HPATH_ENTRY ) * hash_path_size);
#line 923
                                                                                                if (! hash_path) {
#line 924
                                                                                                  printf((char const   *)"AlignedRemalloc() failed, not enough memory.\n");
#line 925
                                                                                                  hash_path_size = (size_t )0;
#line 926
                                                                                                  hash_path = (HPATH_ENTRY *)0;
                                                                                                }
#line 928
                                                                                                hash_path_mask = (hash_path_size - 1UL) & 18446744073709551600UL;
                                                                                              }
#line 930
                                                                                              tmp___39 = DisplayKMB(hash_path_size * sizeof(HPATH_ENTRY ),
                                                                                                                    1);
#line 930
                                                                                              Print(32,
                                                                                                    "hash path table memory = %s bytes",
                                                                                                    tmp___39);
#line 932
                                                                                              tmp___40 = DisplayKMB(hash_path_size,
                                                                                                                    1);
#line 932
                                                                                              Print(32,
                                                                                                    " (%s entries).\n",
                                                                                                    tmp___40);
#line 933
                                                                                              InitializeHashTables(old_hash_size___0 != hash_path_size);
                                                                                            } else {
#line 942
                                                                                              tmp___353 = OptionMatch("hashp",
                                                                                                                      args[0]);
#line 942
                                                                                              if (tmp___353) {
#line 943
                                                                                                old_hash_size___1 = pawn_hash_table_size;
#line 945
                                                                                                if (thinking) {
#line 945
                                                                                                  goto _L___14;
                                                                                                } else
#line 945
                                                                                                if (pondering) {
                                                                                                  _L___14: /* CIL Label */ 
#line 946
                                                                                                  return (2);
                                                                                                }
#line 947
                                                                                                if (nargs > 1) {
#line 948
                                                                                                  allow_memory = 0;
#line 949
                                                                                                  if (xboard) {
#line 950
                                                                                                    Print(4095,
                                                                                                          "Warning--  xboard \'memory\' option disabled\n");
                                                                                                  }
#line 951
                                                                                                  new_hash_size___1 = atoiKMB(args[1]);
#line 952
                                                                                                  if (new_hash_size___1 < 16384UL) {
#line 953
                                                                                                    printf((char const   *)"ERROR.  Minimum pawn hash table size is 16K bytes.\n");
#line 954
                                                                                                    return (1);
                                                                                                  }
#line 956
                                                                                                  tmp___41 = __builtin_clzll((unsigned long long )(new_hash_size___1 / sizeof(PAWN_HASH_ENTRY )));
#line 956
                                                                                                  pawn_hash_table_size = (size_t )(1ull << (63 - tmp___41));
#line 958
                                                                                                  AlignedRemalloc((void **)((void *)(& pawn_hash_table)),
                                                                                                                  (uint64_t )64,
                                                                                                                  sizeof(PAWN_HASH_ENTRY ) * pawn_hash_table_size);
#line 960
                                                                                                  if (! pawn_hash_table) {
#line 961
                                                                                                    printf((char const   *)"AlignedRemalloc() failed, not enough memory.\n");
#line 962
                                                                                                    exit(1);
                                                                                                  }
#line 964
                                                                                                  pawn_hash_mask = pawn_hash_table_size - 1UL;
                                                                                                }
#line 966
                                                                                                tmp___42 = DisplayKMB(pawn_hash_table_size * sizeof(PAWN_HASH_ENTRY ),
                                                                                                                      1);
#line 966
                                                                                                Print(32,
                                                                                                      "pawn hash table memory = %s bytes",
                                                                                                      tmp___42);
#line 968
                                                                                                tmp___43 = DisplayKMB(pawn_hash_table_size,
                                                                                                                      1);
#line 968
                                                                                                Print(32,
                                                                                                      " (%s entries).\n",
                                                                                                      tmp___43);
#line 969
                                                                                                InitializeHashTables(old_hash_size___1 != pawn_hash_table_size);
                                                                                              } else {
#line 978
                                                                                                tmp___352 = OptionMatch("help",
                                                                                                                        args[0]);
#line 978
                                                                                                if (tmp___352) {
#line 980
                                                                                                  readstat = (char *)-1;
#line 981
                                                                                                  lines = 0;
#line 983
                                                                                                  helpfile = fopen((char const   * __restrict  )"crafty.hlp",
                                                                                                                   (char const   * __restrict  )"r");
#line 984
                                                                                                  if (! helpfile) {
#line 985
                                                                                                    printf((char const   *)"ERROR.  Unable to open \"crafty.hlp\" -- help unavailable\n");
#line 986
                                                                                                    return (1);
                                                                                                  }
#line 988
                                                                                                  if (nargs > 1) {
                                                                                                    {
#line 989
                                                                                                    while (1) {
                                                                                                      while_continue___7: /* CIL Label */ ;
#line 989
                                                                                                      if (! 1) {
#line 989
                                                                                                        goto while_break___7;
                                                                                                      }
#line 990
                                                                                                      readstat = fgets(buffer,
                                                                                                                       128,
                                                                                                                       helpfile);
#line 991
                                                                                                      if (! readstat) {
#line 992
                                                                                                        printf((char const   *)"Sorry, no help available for \"%s\"\n",
                                                                                                               args[1]);
#line 993
                                                                                                        fclose(helpfile);
#line 994
                                                                                                        return (1);
                                                                                                      }
#line 996
                                                                                                      if ((int )buffer[0] == 60) {
#line 997
                                                                                                        tmp___44 = strstr((char const   *)(buffer),
                                                                                                                          (char const   *)args[1]);
#line 997
                                                                                                        if (tmp___44) {
#line 998
                                                                                                          goto while_break___7;
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                    while_break___7: /* CIL Label */ ;
                                                                                                    }
                                                                                                  }
                                                                                                  {
#line 1002
                                                                                                  while (1) {
                                                                                                    while_continue___8: /* CIL Label */ ;
#line 1002
                                                                                                    if (! 1) {
#line 1002
                                                                                                      goto while_break___8;
                                                                                                    }
#line 1003
                                                                                                    readstat = fgets(buffer,
                                                                                                                     128,
                                                                                                                     helpfile);
#line 1004
                                                                                                    if (! readstat) {
#line 1005
                                                                                                      goto while_break___8;
                                                                                                    }
#line 1006
                                                                                                    tmp___46 = strchr((char const   *)(buffer),
                                                                                                                      '\n');
#line 1006
                                                                                                    if (tmp___46) {
#line 1007
                                                                                                      tmp___45 = strchr((char const   *)(buffer),
                                                                                                                        '\n');
#line 1007
                                                                                                      *tmp___45 = (char)0;
                                                                                                    }
#line 1008
                                                                                                    tmp___47 = strcmp((char const   *)(buffer),
                                                                                                                      (char const   *)"<end>");
#line 1008
                                                                                                    if (! tmp___47) {
#line 1009
                                                                                                      goto while_break___8;
                                                                                                    }
#line 1010
                                                                                                    printf((char const   *)"%s\n",
                                                                                                           buffer);
#line 1011
                                                                                                    lines ++;
#line 1012
                                                                                                    if (lines > 22) {
#line 1013
                                                                                                      lines = 0;
#line 1014
                                                                                                      printf((char const   *)"<return> for more...");
#line 1015
                                                                                                      fflush(stdout);
#line 1016
                                                                                                      Read(1,
                                                                                                           buffer);
                                                                                                    }
                                                                                                  }
                                                                                                  while_break___8: /* CIL Label */ ;
                                                                                                  }
#line 1019
                                                                                                  fclose(helpfile);
                                                                                                } else {
#line 1029
                                                                                                  tmp___351 = OptionMatch("hint",
                                                                                                                          args[0]);
#line 1029
                                                                                                  if (tmp___351) {
#line 1030
                                                                                                    tmp___48 = strlen((char const   *)(ponder_text));
#line 1030
                                                                                                    if (tmp___48) {
#line 1031
                                                                                                      printf((char const   *)"Hint: %s\n",
                                                                                                             ponder_text);
#line 1032
                                                                                                      fflush(stdout);
                                                                                                    }
                                                                                                  } else {
#line 1044
                                                                                                    tmp___350 = OptionMatch("input",
                                                                                                                            args[0]);
#line 1044
                                                                                                    if (tmp___350) {
#line 1045
                                                                                                      if (thinking) {
#line 1045
                                                                                                        goto _L___15;
                                                                                                      } else
#line 1045
                                                                                                      if (pondering) {
                                                                                                        _L___15: /* CIL Label */ 
#line 1046
                                                                                                        return (2);
                                                                                                      }
#line 1047
                                                                                                      nargs = ReadParse(buffer,
                                                                                                                        args,
                                                                                                                        " \t=");
#line 1048
                                                                                                      if (nargs < 2) {
#line 1049
                                                                                                        printf((char const   *)"usage:  input <filename>\n");
#line 1050
                                                                                                        return (1);
                                                                                                      }
#line 1052
                                                                                                      input_stream = fopen((char const   * __restrict  )args[1],
                                                                                                                           (char const   * __restrict  )"r");
#line 1052
                                                                                                      if (! input_stream) {
#line 1053
                                                                                                        printf((char const   *)"file does not exist.\n");
#line 1054
                                                                                                        input_stream = stdin;
                                                                                                      }
                                                                                                    } else {
#line 1064
                                                                                                      tmp___349 = OptionMatch("info",
                                                                                                                              args[0]);
#line 1064
                                                                                                      if (tmp___349) {
#line 1065
                                                                                                        Print(32,
                                                                                                              "Crafty version %s\n",
                                                                                                              version);
#line 1066
                                                                                                        Print(32,
                                                                                                              "number of threads =         %2d\n",
                                                                                                              smp_max_threads);
#line 1067
                                                                                                        tmp___49 = DisplayKMB(hash_table_size * 64UL,
                                                                                                                              1);
#line 1067
                                                                                                        Print(32,
                                                                                                              "hash table memory = %s bytes",
                                                                                                              tmp___49);
#line 1069
                                                                                                        tmp___50 = DisplayKMB(hash_table_size * 5UL,
                                                                                                                              0);
#line 1069
                                                                                                        Print(32,
                                                                                                              " (%s entries).\n",
                                                                                                              tmp___50);
#line 1070
                                                                                                        tmp___51 = DisplayKMB(pawn_hash_table_size * sizeof(PAWN_HASH_ENTRY ),
                                                                                                                              1);
#line 1070
                                                                                                        Print(32,
                                                                                                              "pawn hash table memory = %5s\n",
                                                                                                              tmp___51);
#line 1072
                                                                                                        if (! tc_sudden_death) {
#line 1073
                                                                                                          Print(32,
                                                                                                                "%d moves/%d minutes %d seconds primary time control\n",
                                                                                                                tc_moves,
                                                                                                                tc_time / 6000,
                                                                                                                (tc_time / 100) % 60);
#line 1075
                                                                                                          Print(32,
                                                                                                                "%d moves/%d minutes %d seconds secondary time control\n",
                                                                                                                tc_secondary_moves,
                                                                                                                tc_secondary_time / 6000,
                                                                                                                (tc_secondary_time / 100) % 60);
#line 1078
                                                                                                          if (tc_increment) {
#line 1079
                                                                                                            Print(32,
                                                                                                                  "increment %d seconds.\n",
                                                                                                                  tc_increment / 100);
                                                                                                          }
                                                                                                        } else
#line 1080
                                                                                                        if (tc_sudden_death == 1) {
#line 1081
                                                                                                          Print(32,
                                                                                                                " game/%d minutes primary time control\n",
                                                                                                                tc_time / 6000);
#line 1082
                                                                                                          if (tc_increment) {
#line 1083
                                                                                                            Print(32,
                                                                                                                  "increment %d seconds.\n",
                                                                                                                  (tc_increment / 100) % 60);
                                                                                                          }
                                                                                                        } else
#line 1084
                                                                                                        if (tc_sudden_death == 2) {
#line 1085
                                                                                                          Print(32,
                                                                                                                "%d moves/%d minutes primary time control\n",
                                                                                                                tc_moves,
                                                                                                                tc_time / 6000);
#line 1087
                                                                                                          Print(32,
                                                                                                                "game/%d minutes secondary time control\n",
                                                                                                                tc_secondary_time / 6000);
#line 1089
                                                                                                          if (tc_increment) {
#line 1090
                                                                                                            Print(32,
                                                                                                                  "increment %d seconds.\n",
                                                                                                                  tc_increment / 100);
                                                                                                          }
                                                                                                        }
#line 1092
                                                                                                        Print(32,
                                                                                                              "book frequency (freq)..............%4.2f\n",
                                                                                                              (double )book_weight_freq);
#line 1093
                                                                                                        Print(32,
                                                                                                              "book static evaluation (eval)......%4.2f\n",
                                                                                                              (double )book_weight_eval);
#line 1094
                                                                                                        Print(32,
                                                                                                              "book learning (learn)..............%4.2f\n",
                                                                                                              (double )book_weight_learn);
                                                                                                      } else {
#line 1108
                                                                                                        tmp___348 = OptionMatch("kibitz",
                                                                                                                                args[0]);
#line 1108
                                                                                                        if (tmp___348) {
#line 1109
                                                                                                          if (nargs < 2) {
#line 1110
                                                                                                            printf((char const   *)"usage:  kibitz <level>\n");
#line 1111
                                                                                                            return (1);
                                                                                                          }
#line 1113
                                                                                                          tmp___54 = atoi((char const   *)args[1]);
#line 1113
                                                                                                          if (5 < tmp___54) {
#line 1113
                                                                                                            kibitz = 5;
                                                                                                          } else {
#line 1113
                                                                                                            tmp___53 = atoi((char const   *)args[1]);
#line 1113
                                                                                                            kibitz = tmp___53;
                                                                                                          }
                                                                                                        } else {
#line 1129
                                                                                                          tmp___347 = OptionMatch("learn",
                                                                                                                                  args[0]);
#line 1129
                                                                                                          if (tmp___347) {
#line 1130
                                                                                                            if (nargs == 2) {
#line 1131
                                                                                                              tmp___57 = OptionMatch("clear",
                                                                                                                                     *(args + 1));
#line 1131
                                                                                                              if (tmp___57) {
#line 1135
                                                                                                                fseek(book_file,
                                                                                                                      0L,
                                                                                                                      0);
#line 1136
                                                                                                                i___1 = 0;
                                                                                                                {
#line 1136
                                                                                                                while (1) {
                                                                                                                  while_continue___9: /* CIL Label */ ;
#line 1136
                                                                                                                  if (! (i___1 < 32768)) {
#line 1136
                                                                                                                    goto while_break___9;
                                                                                                                  }
#line 1137
                                                                                                                  tmp___55 = fread((void *)(buf32),
                                                                                                                                   (size_t )4,
                                                                                                                                   (size_t )1,
                                                                                                                                   book_file);
#line 1137
                                                                                                                  v = (int )tmp___55;
#line 1138
                                                                                                                  if (v <= 0) {
#line 1139
                                                                                                                    perror((char const   *)"Option() fread error: ");
                                                                                                                  }
#line 1140
                                                                                                                  index___0[i___1] = BookIn32(buf32);
#line 1136
                                                                                                                  i___1 ++;
                                                                                                                }
                                                                                                                while_break___9: /* CIL Label */ ;
                                                                                                                }
#line 1142
                                                                                                                i___1 = 0;
                                                                                                                {
#line 1142
                                                                                                                while (1) {
                                                                                                                  while_continue___10: /* CIL Label */ ;
#line 1142
                                                                                                                  if (! (i___1 < 32768)) {
#line 1142
                                                                                                                    goto while_break___10;
                                                                                                                  }
#line 1143
                                                                                                                  if (index___0[i___1] > 0) {
#line 1144
                                                                                                                    fseek(book_file,
                                                                                                                          (long )index___0[i___1],
                                                                                                                          0);
#line 1145
                                                                                                                    tmp___56 = fread((void *)(buf32),
                                                                                                                                     (size_t )4,
                                                                                                                                     (size_t )1,
                                                                                                                                     book_file);
#line 1145
                                                                                                                    v = (int )tmp___56;
#line 1146
                                                                                                                    if (v <= 0) {
#line 1147
                                                                                                                      perror((char const   *)"Option() fread error: ");
                                                                                                                    }
#line 1148
                                                                                                                    cluster = BookIn32(buf32);
#line 1149
                                                                                                                    if (cluster) {
#line 1150
                                                                                                                      BookClusterIn(book_file,
                                                                                                                                    cluster,
                                                                                                                                    book_buffer);
                                                                                                                    }
#line 1151
                                                                                                                    j___0 = 0;
                                                                                                                    {
#line 1151
                                                                                                                    while (1) {
                                                                                                                      while_continue___11: /* CIL Label */ ;
#line 1151
                                                                                                                      if (! (j___0 < cluster)) {
#line 1151
                                                                                                                        goto while_break___11;
                                                                                                                      }
#line 1152
                                                                                                                      book_buffer[j___0].learn = (float )0.0;
#line 1151
                                                                                                                      j___0 ++;
                                                                                                                    }
                                                                                                                    while_break___11: /* CIL Label */ ;
                                                                                                                    }
#line 1153
                                                                                                                    fseek(book_file,
                                                                                                                          (long )((unsigned long )index___0[i___1] + sizeof(int )),
                                                                                                                          0);
#line 1154
                                                                                                                    if (cluster) {
#line 1155
                                                                                                                      BookClusterOut(book_file,
                                                                                                                                     cluster,
                                                                                                                                     book_buffer);
                                                                                                                    }
                                                                                                                  }
#line 1142
                                                                                                                  i___1 ++;
                                                                                                                }
                                                                                                                while_break___10: /* CIL Label */ ;
                                                                                                                }
                                                                                                              } else {
#line 1158
                                                                                                                learning = atoi((char const   *)args[1]);
#line 1159
                                                                                                                if (learning > 0) {
#line 1159
                                                                                                                  learn = 1;
                                                                                                                } else {
#line 1159
                                                                                                                  learn = 0;
                                                                                                                }
#line 1160
                                                                                                                if (learning) {
#line 1161
                                                                                                                  Print(32,
                                                                                                                        "book learning enabled {-%d,+%d}\n",
                                                                                                                        learning,
                                                                                                                        learning);
                                                                                                                } else {
#line 1163
                                                                                                                  Print(32,
                                                                                                                        "book learning disabled\n");
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          } else {
#line 1175
                                                                                                            tmp___346 = OptionMatch("level",
                                                                                                                                    args[0]);
#line 1175
                                                                                                            if (tmp___346) {
#line 1176
                                                                                                              if (nargs < 4) {
#line 1177
                                                                                                                printf((char const   *)"usage:  level <nmoves> <stime> <inc>\n");
#line 1178
                                                                                                                return (1);
                                                                                                              }
#line 1180
                                                                                                              tc_moves = atoi((char const   *)args[1]);
#line 1181
                                                                                                              tmp___58 = atoi((char const   *)args[2]);
#line 1181
                                                                                                              tc_time = tmp___58 * 60;
#line 1182
                                                                                                              tmp___61 = strchr((char const   *)args[2],
                                                                                                                                ':');
#line 1182
                                                                                                              if (tmp___61) {
#line 1183
                                                                                                                tmp___59 = strchr((char const   *)args[2],
                                                                                                                                  ':');
#line 1183
                                                                                                                tmp___60 = atoi((char const   *)(tmp___59 + 1));
#line 1183
                                                                                                                tc_time += tmp___60;
                                                                                                              }
#line 1184
                                                                                                              tc_time *= 100;
#line 1185
                                                                                                              tmp___62 = atoi((char const   *)args[3]);
#line 1185
                                                                                                              tc_increment = tmp___62 * 100;
#line 1186
                                                                                                              tc_time_remaining[1] = tc_time;
#line 1187
                                                                                                              tc_time_remaining[0] = tc_time;
#line 1188
                                                                                                              if (! tc_moves) {
#line 1189
                                                                                                                tc_sudden_death = 1;
#line 1190
                                                                                                                tc_moves = 1000;
#line 1191
                                                                                                                tc_moves_remaining[1] = 1000;
#line 1192
                                                                                                                tc_moves_remaining[0] = 1000;
                                                                                                              } else {
#line 1194
                                                                                                                tc_sudden_death = 0;
                                                                                                              }
#line 1195
                                                                                                              if (tc_moves) {
#line 1196
                                                                                                                tc_secondary_moves = tc_moves;
#line 1197
                                                                                                                tc_secondary_time = tc_time;
#line 1198
                                                                                                                tc_moves_remaining[1] = tc_moves;
#line 1199
                                                                                                                tc_moves_remaining[0] = tc_moves;
                                                                                                              }
#line 1201
                                                                                                              if (! tc_sudden_death) {
#line 1202
                                                                                                                Print(32,
                                                                                                                      "%d moves/%d seconds primary time control\n",
                                                                                                                      tc_moves,
                                                                                                                      tc_time / 100);
#line 1204
                                                                                                                Print(32,
                                                                                                                      "%d moves/%d seconds secondary time control\n",
                                                                                                                      tc_secondary_moves,
                                                                                                                      tc_secondary_time / 100);
#line 1206
                                                                                                                if (tc_increment) {
#line 1207
                                                                                                                  Print(32,
                                                                                                                        "increment %d seconds.\n",
                                                                                                                        tc_increment / 100);
                                                                                                                }
                                                                                                              } else
#line 1208
                                                                                                              if (tc_sudden_death == 1) {
#line 1209
                                                                                                                Print(32,
                                                                                                                      " game/%d seconds primary time control\n",
                                                                                                                      tc_time / 100);
#line 1210
                                                                                                                if (tc_increment) {
#line 1211
                                                                                                                  Print(32,
                                                                                                                        "increment %d seconds.\n",
                                                                                                                        tc_increment / 100);
                                                                                                                }
                                                                                                              }
#line 1213
                                                                                                              if (adaptive_hash) {
#line 1218
                                                                                                                TimeSet(1);
#line 1219
                                                                                                                time_limit /= 100;
#line 1220
                                                                                                                positions_per_move = (uint64_t )((time_limit * adaptive_hash) / 16);
#line 1221
                                                                                                                optimal_hash_size = (int )(positions_per_move * 16UL);
#line 1222
                                                                                                                printf((char const   *)"optimal=%d\n",
                                                                                                                       optimal_hash_size);
#line 1223
                                                                                                                if ((size_t )optimal_hash_size > adaptive_hash_min) {
#line 1223
                                                                                                                  optimal_hash_size = optimal_hash_size;
                                                                                                                } else {
#line 1223
                                                                                                                  optimal_hash_size = (int )adaptive_hash_min;
                                                                                                                }
#line 1224
                                                                                                                if ((size_t )optimal_hash_size < adaptive_hash_max) {
#line 1224
                                                                                                                  optimal_hash_size = optimal_hash_size;
                                                                                                                } else {
#line 1224
                                                                                                                  optimal_hash_size = (int )adaptive_hash_max;
                                                                                                                }
#line 1225
                                                                                                                sprintf(buffer,
                                                                                                                        (char const   *)"hash=%d\n",
                                                                                                                        optimal_hash_size);
#line 1226
                                                                                                                Option(tree);
#line 1227
                                                                                                                percent = (float )((size_t )optimal_hash_size - adaptive_hash_min) / (float )(adaptive_hash_max - adaptive_hash_min);
#line 1231
                                                                                                                optimal_hash_size = (int )((float )adaptive_hashp_min + percent * (float )(adaptive_hashp_max - adaptive_hashp_min));
#line 1234
                                                                                                                if ((size_t )optimal_hash_size > adaptive_hashp_min) {
#line 1234
                                                                                                                  optimal_hash_size = optimal_hash_size;
                                                                                                                } else {
#line 1234
                                                                                                                  optimal_hash_size = (int )adaptive_hashp_min;
                                                                                                                }
#line 1235
                                                                                                                sprintf(buffer,
                                                                                                                        (char const   *)"hashp=%d\n",
                                                                                                                        optimal_hash_size);
#line 1236
                                                                                                                Option(tree);
                                                                                                              }
                                                                                                            } else {
#line 1249
                                                                                                              tmp___345 = OptionMatch("linelength",
                                                                                                                                      args[0]);
#line 1249
                                                                                                              if (tmp___345) {
#line 1250
                                                                                                                if (nargs > 2) {
#line 1251
                                                                                                                  printf((char const   *)"usage:  linelength <n>\n");
#line 1252
                                                                                                                  return (1);
                                                                                                                }
#line 1254
                                                                                                                if (nargs == 2) {
#line 1255
                                                                                                                  line_length = atoi((char const   *)args[1]);
                                                                                                                }
#line 1256
                                                                                                                printf((char const   *)"line length set to %d.\n",
                                                                                                                       line_length);
                                                                                                              } else {
#line 1310
                                                                                                                tmp___344 = OptionMatch("list",
                                                                                                                                        args[0]);
#line 1310
                                                                                                                if (tmp___344) {
#line 1312
                                                                                                                  listname[0][0] = (char )'A';
#line 1312
                                                                                                                  listname[0][1] = (char )'K';
#line 1312
                                                                                                                  listname[0][2] = (char )'\000';
#line 1312
                                                                                                                  listname[1][0] = (char )'B';
#line 1312
                                                                                                                  listname[1][1] = (char )'\000';
#line 1312
                                                                                                                  tmp___63 = 2U;
                                                                                                                  {
#line 1312
                                                                                                                  while (1) {
                                                                                                                    while_continue___12: /* CIL Label */ ;
#line 1312
                                                                                                                    if (tmp___63 >= 3U) {
#line 1312
                                                                                                                      goto while_break___12;
                                                                                                                    }
#line 1312
                                                                                                                    listname[1][tmp___63] = (char)0;
#line 1312
                                                                                                                    tmp___63 ++;
                                                                                                                  }
                                                                                                                  while_break___12: /* CIL Label */ ;
                                                                                                                  }
#line 1312
                                                                                                                  listname[2][0] = (char )'G';
#line 1312
                                                                                                                  listname[2][1] = (char )'M';
#line 1312
                                                                                                                  listname[2][2] = (char )'\000';
#line 1312
                                                                                                                  listname[3][0] = (char )'I';
#line 1312
                                                                                                                  listname[3][1] = (char )'M';
#line 1312
                                                                                                                  listname[3][2] = (char )'\000';
#line 1312
                                                                                                                  listname[4][0] = (char )'S';
#line 1312
                                                                                                                  listname[4][1] = (char )'P';
#line 1312
                                                                                                                  listname[4][2] = (char )'\000';
#line 1313
                                                                                                                  listaddr[0] = AK_list;
#line 1313
                                                                                                                  listaddr[1] = B_list;
#line 1313
                                                                                                                  listaddr[2] = GM_list;
#line 1313
                                                                                                                  listaddr[3] = IM_list;
#line 1313
                                                                                                                  listaddr[4] = SP_list;
#line 1316
                                                                                                                  lastent = -1;
#line 1318
                                                                                                                  targs = args;
#line 1319
                                                                                                                  list = 0;
                                                                                                                  {
#line 1319
                                                                                                                  while (1) {
                                                                                                                    while_continue___13: /* CIL Label */ ;
#line 1319
                                                                                                                    if (! (list < 5)) {
#line 1319
                                                                                                                      goto while_break___13;
                                                                                                                    }
#line 1320
                                                                                                                    tmp___64 = strcmp((char const   *)(listname[list]),
                                                                                                                                      (char const   *)args[1]);
#line 1320
                                                                                                                    if (! tmp___64) {
#line 1321
                                                                                                                      goto while_break___13;
                                                                                                                    }
#line 1319
                                                                                                                    list ++;
                                                                                                                  }
                                                                                                                  while_break___13: /* CIL Label */ ;
                                                                                                                  }
#line 1323
                                                                                                                  if (list > 4) {
#line 1324
                                                                                                                    printf((char const   *)"usage:  list AK|B|GM|IM|P|SP +name1 -name2 etc\n");
#line 1325
                                                                                                                    return (1);
                                                                                                                  }
#line 1327
                                                                                                                  nargs -= 2;
#line 1328
                                                                                                                  targs += 2;
#line 1329
                                                                                                                  if (nargs) {
                                                                                                                    {
#line 1330
                                                                                                                    while (1) {
                                                                                                                      while_continue___14: /* CIL Label */ ;
#line 1330
                                                                                                                      if (! nargs) {
#line 1330
                                                                                                                        goto while_break___14;
                                                                                                                      }
#line 1331
                                                                                                                      if ((int )*(*(targs + 0) + 0) == 45) {
#line 1332
                                                                                                                        i___2 = 0;
                                                                                                                        {
#line 1332
                                                                                                                        while (1) {
                                                                                                                          while_continue___15: /* CIL Label */ ;
#line 1332
                                                                                                                          if (! (i___2 < 128)) {
#line 1332
                                                                                                                            goto while_break___15;
                                                                                                                          }
#line 1333
                                                                                                                          if (*(listaddr[list] + i___2)) {
#line 1334
                                                                                                                            tmp___65 = strcmp((char const   *)*(listaddr[list] + i___2),
                                                                                                                                              (char const   *)(*(targs + 0) + 1));
#line 1334
                                                                                                                            if (! tmp___65) {
#line 1335
                                                                                                                              free((void *)*(listaddr[list] + i___2));
#line 1336
                                                                                                                              *(listaddr[list] + i___2) = (char *)((void *)0);
#line 1337
                                                                                                                              Print(32,
                                                                                                                                    "%s removed from %s list.\n",
                                                                                                                                    *(targs + 0) + 1,
                                                                                                                                    listname[list]);
#line 1339
                                                                                                                              goto while_break___15;
                                                                                                                            }
                                                                                                                          }
#line 1332
                                                                                                                          i___2 ++;
                                                                                                                        }
                                                                                                                        while_break___15: /* CIL Label */ ;
                                                                                                                        }
                                                                                                                      } else
#line 1342
                                                                                                                      if ((int )*(*(targs + 0) + 0) == 43) {
#line 1343
                                                                                                                        i___2 = 0;
                                                                                                                        {
#line 1343
                                                                                                                        while (1) {
                                                                                                                          while_continue___16: /* CIL Label */ ;
#line 1343
                                                                                                                          if (! (i___2 < 128)) {
#line 1343
                                                                                                                            goto while_break___16;
                                                                                                                          }
#line 1344
                                                                                                                          if (*(listaddr[list] + i___2)) {
#line 1345
                                                                                                                            tmp___66 = strcmp((char const   *)*(listaddr[list] + i___2),
                                                                                                                                              (char const   *)(*(targs + 0) + 1));
#line 1345
                                                                                                                            if (! tmp___66) {
#line 1346
                                                                                                                              Print(32,
                                                                                                                                    "Warning: %s is already in %s list.\n",
                                                                                                                                    *(targs + 0) + 1,
                                                                                                                                    listname[list]);
#line 1348
                                                                                                                              goto while_break___16;
                                                                                                                            }
                                                                                                                          }
#line 1343
                                                                                                                          i___2 ++;
                                                                                                                        }
                                                                                                                        while_break___16: /* CIL Label */ ;
                                                                                                                        }
#line 1351
                                                                                                                        i___2 = 0;
                                                                                                                        {
#line 1351
                                                                                                                        while (1) {
                                                                                                                          while_continue___17: /* CIL Label */ ;
#line 1351
                                                                                                                          if (! (i___2 < 128)) {
#line 1351
                                                                                                                            goto while_break___17;
                                                                                                                          }
#line 1352
                                                                                                                          if ((unsigned long )*(listaddr[list] + i___2) == (unsigned long )((void *)0)) {
#line 1353
                                                                                                                            goto while_break___17;
                                                                                                                          }
#line 1351
                                                                                                                          i___2 ++;
                                                                                                                        }
                                                                                                                        while_break___17: /* CIL Label */ ;
                                                                                                                        }
#line 1354
                                                                                                                        if (i___2 >= 128) {
#line 1355
                                                                                                                          Print(32,
                                                                                                                                "ERROR!  %s list is full at 128 entries\n",
                                                                                                                                listname[list]);
                                                                                                                        } else {
#line 1358
                                                                                                                          tmp___67 = strlen((char const   *)*(targs + 0));
#line 1358
                                                                                                                          tmp___68 = malloc(tmp___67);
#line 1358
                                                                                                                          *(listaddr[list] + i___2) = (char *)tmp___68;
#line 1359
                                                                                                                          strcpy(*(listaddr[list] + i___2),
                                                                                                                                 (char const   *)(*(targs + 0) + 1));
#line 1360
                                                                                                                          Print(32,
                                                                                                                                "%s added to %s list.\n",
                                                                                                                                *(targs + 0) + 1,
                                                                                                                                listname[list]);
#line 1361
                                                                                                                          if (list == 5) {
#line 1362
                                                                                                                            lastent = i___2;
                                                                                                                          }
                                                                                                                        }
                                                                                                                      } else {
#line 1364
                                                                                                                        tmp___77 = strcmp((char const   *)*(targs + 0),
                                                                                                                                          (char const   *)"clear");
#line 1364
                                                                                                                        if (tmp___77) {
#line 1369
                                                                                                                          tmp___76 = strcmp((char const   *)*(targs + 0),
                                                                                                                                            (char const   *)"book");
#line 1369
                                                                                                                          if (tmp___76) {
                                                                                                                            _L___17: /* CIL Label */ 
#line 1388
                                                                                                                            tmp___75 = strcmp((char const   *)*(targs + 0),
                                                                                                                                              (char const   *)"personality");
#line 1388
                                                                                                                            if (tmp___75) {
                                                                                                                              _L___16: /* CIL Label */ 
#line 1407
                                                                                                                              printf((char const   *)"error, name must be preceeded by +/- flag.\n");
                                                                                                                            } else
#line 1388
                                                                                                                            if (lastent != -1) {
#line 1392
                                                                                                                              strcat(filename___0,
                                                                                                                                     (char const   *)*(targs + 1));
#line 1393
                                                                                                                              tmp___72 = strstr((char const   *)args[2],
                                                                                                                                                (char const   *)".cpf");
#line 1393
                                                                                                                              if (! tmp___72) {
#line 1394
                                                                                                                                strcat(filename___0,
                                                                                                                                       (char const   *)".cpf");
                                                                                                                              }
#line 1395
                                                                                                                              file___2 = fopen((char const   * __restrict  )(filename___0),
                                                                                                                                               (char const   * __restrict  )"r");
#line 1396
                                                                                                                              if (! file___2) {
#line 1397
                                                                                                                                Print(4095,
                                                                                                                                      "ERROR  personality file %s can not be opened\n",
                                                                                                                                      filename___0);
#line 1399
                                                                                                                                goto while_break___14;
                                                                                                                              }
#line 1401
                                                                                                                              fclose(file___2);
#line 1402
                                                                                                                              tmp___73 = strlen((char const   *)(filename___0));
#line 1402
                                                                                                                              tmp___74 = malloc(tmp___73 + 1UL);
#line 1402
                                                                                                                              SP_personality_filename[lastent] = (char *)tmp___74;
#line 1403
                                                                                                                              strcpy(SP_personality_filename[lastent],
                                                                                                                                     (char const   *)(filename___0));
#line 1404
                                                                                                                              nargs --;
#line 1405
                                                                                                                              targs ++;
                                                                                                                            } else {
#line 1388
                                                                                                                              goto _L___16;
                                                                                                                            }
                                                                                                                          } else
#line 1369
                                                                                                                          if (lastent != -1) {
#line 1373
                                                                                                                            strcpy(filename,
                                                                                                                                   (char const   *)(book_path));
#line 1374
                                                                                                                            strcat(filename,
                                                                                                                                   (char const   *)"/");
#line 1375
                                                                                                                            strcat(filename,
                                                                                                                                   (char const   *)*(targs + 1));
#line 1376
                                                                                                                            tmp___69 = strstr((char const   *)args[2],
                                                                                                                                              (char const   *)".bin");
#line 1376
                                                                                                                            if (! tmp___69) {
#line 1377
                                                                                                                              strcat(filename,
                                                                                                                                     (char const   *)".bin");
                                                                                                                            }
#line 1378
                                                                                                                            file___1 = fopen((char const   * __restrict  )(filename),
                                                                                                                                             (char const   * __restrict  )"r");
#line 1379
                                                                                                                            if (! file___1) {
#line 1380
                                                                                                                              Print(4095,
                                                                                                                                    "ERROR  book file %s can not be opened\n",
                                                                                                                                    filename);
#line 1381
                                                                                                                              goto while_break___14;
                                                                                                                            }
#line 1383
                                                                                                                            fclose(file___1);
#line 1384
                                                                                                                            tmp___70 = strlen((char const   *)(filename));
#line 1384
                                                                                                                            tmp___71 = malloc(tmp___70 + 1UL);
#line 1384
                                                                                                                            SP_opening_filename[lastent] = (char *)tmp___71;
#line 1385
                                                                                                                            strcpy(SP_opening_filename[lastent],
                                                                                                                                   (char const   *)(filename));
#line 1386
                                                                                                                            nargs --;
#line 1387
                                                                                                                            targs ++;
                                                                                                                          } else {
#line 1369
                                                                                                                            goto _L___17;
                                                                                                                          }
                                                                                                                        } else {
#line 1365
                                                                                                                          i___2 = 0;
                                                                                                                          {
#line 1365
                                                                                                                          while (1) {
                                                                                                                            while_continue___18: /* CIL Label */ ;
#line 1365
                                                                                                                            if (! (i___2 < 128)) {
#line 1365
                                                                                                                              goto while_break___18;
                                                                                                                            }
#line 1366
                                                                                                                            free((void *)*(listaddr[list] + i___2));
#line 1367
                                                                                                                            *(listaddr[list] + i___2) = (char *)((void *)0);
#line 1365
                                                                                                                            i___2 ++;
                                                                                                                          }
                                                                                                                          while_break___18: /* CIL Label */ ;
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
#line 1408
                                                                                                                      nargs --;
#line 1409
                                                                                                                      targs ++;
                                                                                                                    }
                                                                                                                    while_break___14: /* CIL Label */ ;
                                                                                                                    }
                                                                                                                  } else {
#line 1412
                                                                                                                    Print(32,
                                                                                                                          "%s List:\n",
                                                                                                                          listname[list]);
#line 1413
                                                                                                                    i___2 = 0;
                                                                                                                    {
#line 1413
                                                                                                                    while (1) {
                                                                                                                      while_continue___19: /* CIL Label */ ;
#line 1413
                                                                                                                      if (! (i___2 < 128)) {
#line 1413
                                                                                                                        goto while_break___19;
                                                                                                                      }
#line 1414
                                                                                                                      if (*(listaddr[list] + i___2)) {
#line 1415
                                                                                                                        Print(32,
                                                                                                                              "%s",
                                                                                                                              *(listaddr[list] + i___2));
#line 1416
                                                                                                                        if (list == 5) {
#line 1417
                                                                                                                          if (SP_opening_filename[i___2]) {
#line 1418
                                                                                                                            Print(32,
                                                                                                                                  "  book=%s",
                                                                                                                                  SP_opening_filename[i___2]);
                                                                                                                          }
#line 1419
                                                                                                                          if (SP_personality_filename[i___2]) {
#line 1420
                                                                                                                            Print(32,
                                                                                                                                  "  personality=%s",
                                                                                                                                  SP_personality_filename[i___2]);
                                                                                                                          }
                                                                                                                        }
#line 1422
                                                                                                                        Print(32,
                                                                                                                              "\n");
                                                                                                                      }
#line 1413
                                                                                                                      i___2 ++;
                                                                                                                    }
                                                                                                                    while_break___19: /* CIL Label */ ;
                                                                                                                    }
                                                                                                                  }
                                                                                                                } else {
#line 1448
                                                                                                                  tmp___343 = OptionMatch("lmp",
                                                                                                                                          args[0]);
#line 1448
                                                                                                                  if (tmp___343) {
#line 1451
                                                                                                                    if (nargs > 1) {
#line 1451
                                                                                                                      if (nargs < 4) {
#line 1451
                                                                                                                        goto _L___18;
                                                                                                                      } else {
#line 1451
                                                                                                                        goto _L___19;
                                                                                                                      }
                                                                                                                    } else
                                                                                                                    _L___19: /* CIL Label */ 
#line 1451
                                                                                                                    if (nargs > 4) {
                                                                                                                      _L___18: /* CIL Label */ 
#line 1452
                                                                                                                      printf((char const   *)"usage:  lmp <maxdepth> <base> <scale>\n");
#line 1453
                                                                                                                      return (1);
                                                                                                                    }
#line 1455
                                                                                                                    if (nargs > 1) {
#line 1456
                                                                                                                      LMP_depth = atoi((char const   *)args[1]);
#line 1457
                                                                                                                      LMP_base = atoi((char const   *)args[2]);
#line 1458
                                                                                                                      LMP_scale = atof((char const   *)args[3]);
#line 1459
                                                                                                                      InitializeLMP();
                                                                                                                    }
#line 1461
                                                                                                                    Print(32,
                                                                                                                          "LMP depth=%d  base=%d  scale=%f\n",
                                                                                                                          LMP_depth,
                                                                                                                          LMP_base,
                                                                                                                          LMP_scale);
#line 1463
                                                                                                                    Print(32,
                                                                                                                          "depth:  ");
#line 1464
                                                                                                                    i___3 = 1;
                                                                                                                    {
#line 1464
                                                                                                                    while (1) {
                                                                                                                      while_continue___20: /* CIL Label */ ;
#line 1464
                                                                                                                      if (! (i___3 < 16)) {
#line 1464
                                                                                                                        goto while_break___20;
                                                                                                                      }
#line 1465
                                                                                                                      Print(32,
                                                                                                                            "%4d",
                                                                                                                            i___3);
#line 1464
                                                                                                                      i___3 ++;
                                                                                                                    }
                                                                                                                    while_break___20: /* CIL Label */ ;
                                                                                                                    }
#line 1466
                                                                                                                    Print(32,
                                                                                                                          "\n");
#line 1467
                                                                                                                    Print(32,
                                                                                                                          "movcnt: ");
#line 1468
                                                                                                                    i___3 = 1;
                                                                                                                    {
#line 1468
                                                                                                                    while (1) {
                                                                                                                      while_continue___21: /* CIL Label */ ;
#line 1468
                                                                                                                      if (! (i___3 < 16)) {
#line 1468
                                                                                                                        goto while_break___21;
                                                                                                                      }
#line 1469
                                                                                                                      Print(32,
                                                                                                                            "%4d",
                                                                                                                            LMP[i___3]);
#line 1468
                                                                                                                      i___3 ++;
                                                                                                                    }
                                                                                                                    while_break___21: /* CIL Label */ ;
                                                                                                                    }
#line 1470
                                                                                                                    Print(32,
                                                                                                                          "\n");
                                                                                                                  } else {
#line 1507
                                                                                                                    tmp___342 = OptionMatch("lmr",
                                                                                                                                            args[0]);
#line 1507
                                                                                                                    if (tmp___342) {
#line 1510
                                                                                                                      if (nargs > 1) {
#line 1510
                                                                                                                        if (nargs < 6) {
#line 1510
                                                                                                                          goto _L___20;
                                                                                                                        } else {
#line 1510
                                                                                                                          goto _L___21;
                                                                                                                        }
                                                                                                                      } else
                                                                                                                      _L___21: /* CIL Label */ 
#line 1510
                                                                                                                      if (nargs > 7) {
                                                                                                                        _L___20: /* CIL Label */ 
#line 1511
                                                                                                                        printf((char const   *)"usage:  lmr <min> <max> <depth bias> <move bias> <scale>\n");
#line 1512
                                                                                                                        return (1);
                                                                                                                      }
#line 1514
                                                                                                                      if (nargs > 1) {
#line 1515
                                                                                                                        LMR_min = atoi((char const   *)args[1]);
#line 1516
                                                                                                                        tmp___80 = atoi((char const   *)args[2]);
#line 1516
                                                                                                                        if (tmp___80 < 15) {
#line 1516
                                                                                                                          tmp___79 = atoi((char const   *)args[2]);
#line 1516
                                                                                                                          LMR_max = tmp___79;
                                                                                                                        } else {
#line 1516
                                                                                                                          LMR_max = 15;
                                                                                                                        }
#line 1517
                                                                                                                        LMR_db = atof((char const   *)args[3]);
#line 1518
                                                                                                                        LMR_mb = atof((char const   *)args[4]);
#line 1519
                                                                                                                        LMR_s = atof((char const   *)args[5]);
#line 1520
                                                                                                                        InitializeLMR();
                                                                                                                      }
#line 1522
                                                                                                                      if (nargs > 6) {
#line 1523
                                                                                                                        axis = "|||||||||||depth left|||||||||||";
#line 1525
                                                                                                                        Print(32,
                                                                                                                              "LMR values:  %d(min) %d(max) %.2f(depth) %.2f(moves) %.2f(scale).\n",
                                                                                                                              LMR_min,
                                                                                                                              LMR_max,
                                                                                                                              LMR_db,
                                                                                                                              LMR_mb,
                                                                                                                              LMR_s);
#line 1528
                                                                                                                        Print(32,
                                                                                                                              "\n                 LMR reductions[depth][moves]\n");
#line 1529
                                                                                                                        Print(32,
                                                                                                                              "  ----------------------moves searched-----------------\n");
#line 1530
                                                                                                                        Print(32,
                                                                                                                              " |      ");
#line 1531
                                                                                                                        i___4 = 0;
                                                                                                                        {
#line 1531
                                                                                                                        while (1) {
                                                                                                                          while_continue___22: /* CIL Label */ ;
#line 1531
                                                                                                                          if (! (i___4 < 64)) {
#line 1531
                                                                                                                            goto while_break___22;
                                                                                                                          }
#line 1532
                                                                                                                          Print(32,
                                                                                                                                "%3d",
                                                                                                                                i___4);
#line 1531
                                                                                                                          i___4 ++;
                                                                                                                        }
                                                                                                                        while_break___22: /* CIL Label */ ;
                                                                                                                        }
#line 1533
                                                                                                                        Print(32,
                                                                                                                              "\n");
#line 1534
                                                                                                                        i___4 = 0;
                                                                                                                        {
#line 1534
                                                                                                                        while (1) {
                                                                                                                          while_continue___23: /* CIL Label */ ;
#line 1534
                                                                                                                          if (! (i___4 < 32)) {
#line 1534
                                                                                                                            goto while_break___23;
                                                                                                                          }
#line 1535
                                                                                                                          Print(32,
                                                                                                                                " %c %3d: ",
                                                                                                                                (int )*(axis + i___4),
                                                                                                                                i___4);
#line 1536
                                                                                                                          j___1 = 0;
                                                                                                                          {
#line 1536
                                                                                                                          while (1) {
                                                                                                                            while_continue___24: /* CIL Label */ ;
#line 1536
                                                                                                                            if (! (j___1 < 64)) {
#line 1536
                                                                                                                              goto while_break___24;
                                                                                                                            }
#line 1537
                                                                                                                            Print(32,
                                                                                                                                  " %2d",
                                                                                                                                  (int )LMR[i___4][j___1]);
#line 1536
                                                                                                                            j___1 ++;
                                                                                                                          }
                                                                                                                          while_break___24: /* CIL Label */ ;
                                                                                                                          }
#line 1538
                                                                                                                          Print(32,
                                                                                                                                "\n");
#line 1534
                                                                                                                          i___4 ++;
                                                                                                                        }
                                                                                                                        while_break___23: /* CIL Label */ ;
                                                                                                                        }
                                                                                                                      } else {
#line 1541
                                                                                                                        axis___0 = "||depth left|||";
#line 1543
                                                                                                                        Print(32,
                                                                                                                              "LMR values:  %d(min) %d(max) %.2f(depth) %.2f(moves) %.2f(scale).\n",
                                                                                                                              LMR_min,
                                                                                                                              LMR_max,
                                                                                                                              LMR_db,
                                                                                                                              LMR_mb,
                                                                                                                              LMR_s);
#line 1546
                                                                                                                        Print(32,
                                                                                                                              "\n                 LMR reductions[depth][moves]\n");
#line 1547
                                                                                                                        Print(32,
                                                                                                                              "  ----------------------moves searched------------------\n");
#line 1548
                                                                                                                        Print(32,
                                                                                                                              " |      ");
#line 1549
                                                                                                                        i___4 = 2;
                                                                                                                        {
#line 1549
                                                                                                                        while (1) {
                                                                                                                          while_continue___25: /* CIL Label */ ;
#line 1549
                                                                                                                          if (! (i___4 < 64)) {
#line 1549
                                                                                                                            goto while_break___25;
                                                                                                                          }
#line 1550
                                                                                                                          Print(32,
                                                                                                                                "%3d",
                                                                                                                                i___4);
#line 1549
                                                                                                                          i___4 += 4;
                                                                                                                        }
                                                                                                                        while_break___25: /* CIL Label */ ;
                                                                                                                        }
#line 1551
                                                                                                                        Print(32,
                                                                                                                              "\n");
#line 1552
                                                                                                                        i___4 = 3;
                                                                                                                        {
#line 1552
                                                                                                                        while (1) {
                                                                                                                          while_continue___26: /* CIL Label */ ;
#line 1552
                                                                                                                          if (! (i___4 < 32)) {
#line 1552
                                                                                                                            goto while_break___26;
                                                                                                                          }
#line 1553
                                                                                                                          Print(32,
                                                                                                                                " %c %3d: ",
                                                                                                                                (int )*(axis___0 + (i___4 - 3) / 2),
                                                                                                                                i___4);
#line 1554
                                                                                                                          j___1 = 2;
                                                                                                                          {
#line 1554
                                                                                                                          while (1) {
                                                                                                                            while_continue___27: /* CIL Label */ ;
#line 1554
                                                                                                                            if (! (j___1 < 64)) {
#line 1554
                                                                                                                              goto while_break___27;
                                                                                                                            }
#line 1555
                                                                                                                            Print(32,
                                                                                                                                  " %2d",
                                                                                                                                  (int )LMR[i___4][j___1]);
#line 1554
                                                                                                                            j___1 += 4;
                                                                                                                          }
                                                                                                                          while_break___27: /* CIL Label */ ;
                                                                                                                          }
#line 1556
                                                                                                                          Print(32,
                                                                                                                                "\n");
#line 1552
                                                                                                                          i___4 += 2;
                                                                                                                        }
                                                                                                                        while_break___26: /* CIL Label */ ;
                                                                                                                        }
#line 1558
                                                                                                                        Print(32,
                                                                                                                              "    note:  table is shown compressed, each index is in\n");
#line 1559
                                                                                                                        Print(32,
                                                                                                                              "    units of 1, all rows/columns are not shown above\n");
                                                                                                                      }
                                                                                                                    } else {
#line 1572
                                                                                                                      tmp___341 = OptionMatch("load",
                                                                                                                                              args[0]);
#line 1572
                                                                                                                      if (tmp___341) {
#line 1577
                                                                                                                        if (thinking) {
#line 1577
                                                                                                                          goto _L___22;
                                                                                                                        } else
#line 1577
                                                                                                                        if (pondering) {
                                                                                                                          _L___22: /* CIL Label */ 
#line 1578
                                                                                                                          return (2);
                                                                                                                        }
#line 1579
                                                                                                                        nargs = ReadParse(buffer,
                                                                                                                                          args,
                                                                                                                                          " \t=");
#line 1580
                                                                                                                        if (nargs < 3) {
#line 1581
                                                                                                                          printf((char const   *)"usage:  input <filename> title\n");
#line 1582
                                                                                                                          return (1);
                                                                                                                        }
#line 1584
                                                                                                                        prob_file = fopen((char const   * __restrict  )args[1],
                                                                                                                                          (char const   * __restrict  )"r");
#line 1584
                                                                                                                        if (! prob_file) {
#line 1585
                                                                                                                          printf((char const   *)"file does not exist.\n");
#line 1586
                                                                                                                          return (1);
                                                                                                                        }
#line 1588
                                                                                                                        strcpy(title,
                                                                                                                               (char const   *)args[2]);
                                                                                                                        {
#line 1589
                                                                                                                        while (1) {
                                                                                                                          while_continue___28: /* CIL Label */ ;
#line 1589
                                                                                                                          tmp___83 = feof(prob_file);
#line 1589
                                                                                                                          if (tmp___83) {
#line 1589
                                                                                                                            goto while_break___28;
                                                                                                                          }
#line 1590
                                                                                                                          readstat___0 = fgets(buffer,
                                                                                                                                               128,
                                                                                                                                               prob_file);
#line 1591
                                                                                                                          if (readstat___0) {
#line 1594
                                                                                                                            delim = strchr((char const   *)(buffer),
                                                                                                                                           '\n');
#line 1595
                                                                                                                            if (delim) {
#line 1596
                                                                                                                              *delim = (char)0;
                                                                                                                            }
#line 1597
                                                                                                                            delim = strchr((char const   *)(buffer),
                                                                                                                                           '\r');
#line 1598
                                                                                                                            if (delim) {
#line 1599
                                                                                                                              *delim = (char )' ';
                                                                                                                            }
                                                                                                                          }
#line 1601
                                                                                                                          if ((unsigned long )readstat___0 == (unsigned long )((void *)0)) {
#line 1602
                                                                                                                            goto while_break___28;
                                                                                                                          }
#line 1603
                                                                                                                          nargs = ReadParse(buffer,
                                                                                                                                            args,
                                                                                                                                            " \t;\n");
#line 1604
                                                                                                                          tmp___81 = strcmp((char const   *)args[0],
                                                                                                                                            (char const   *)"title");
#line 1604
                                                                                                                          if (tmp___81) {
                                                                                                                            _L___23: /* CIL Label */ ;
                                                                                                                          } else {
#line 1604
                                                                                                                            tmp___82 = strstr((char const   *)(buffer),
                                                                                                                                              (char const   *)(title));
#line 1604
                                                                                                                            if (tmp___82) {
#line 1605
                                                                                                                              goto while_break___28;
                                                                                                                            } else {
#line 1604
                                                                                                                              goto _L___23;
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                        while_break___28: /* CIL Label */ ;
                                                                                                                        }
                                                                                                                        {
#line 1607
                                                                                                                        while (1) {
                                                                                                                          while_continue___29: /* CIL Label */ ;
#line 1607
                                                                                                                          tmp___85 = feof(prob_file);
#line 1607
                                                                                                                          if (tmp___85) {
#line 1607
                                                                                                                            goto while_break___29;
                                                                                                                          }
#line 1608
                                                                                                                          readstat___0 = fgets(buffer,
                                                                                                                                               128,
                                                                                                                                               prob_file);
#line 1609
                                                                                                                          if (readstat___0) {
#line 1612
                                                                                                                            delim___0 = strchr((char const   *)(buffer),
                                                                                                                                               '\n');
#line 1613
                                                                                                                            if (delim___0) {
#line 1614
                                                                                                                              *delim___0 = (char)0;
                                                                                                                            }
#line 1615
                                                                                                                            delim___0 = strchr((char const   *)(buffer),
                                                                                                                                               '\r');
#line 1616
                                                                                                                            if (delim___0) {
#line 1617
                                                                                                                              *delim___0 = (char )' ';
                                                                                                                            }
                                                                                                                          }
#line 1619
                                                                                                                          if ((unsigned long )readstat___0 == (unsigned long )((void *)0)) {
#line 1620
                                                                                                                            goto while_break___29;
                                                                                                                          }
#line 1621
                                                                                                                          nargs = ReadParse(buffer,
                                                                                                                                            args,
                                                                                                                                            " \t;\n");
#line 1622
                                                                                                                          tmp___84 = strcmp((char const   *)args[0],
                                                                                                                                            (char const   *)"setboard");
#line 1622
                                                                                                                          if (! tmp___84) {
#line 1623
                                                                                                                            Option(tree);
#line 1624
                                                                                                                            goto while_break___29;
                                                                                                                          }
                                                                                                                        }
                                                                                                                        while_break___29: /* CIL Label */ ;
                                                                                                                        }
#line 1627
                                                                                                                        fclose(prob_file);
                                                                                                                      } else {
#line 1641
                                                                                                                        tmp___340 = OptionMatch("log",
                                                                                                                                                args[0]);
#line 1641
                                                                                                                        if (tmp___340) {
#line 1644
                                                                                                                          if (nargs < 2) {
#line 1645
                                                                                                                            printf((char const   *)"usage:  log on|off|n [filename]\n");
#line 1646
                                                                                                                            return (1);
                                                                                                                          }
#line 1648
                                                                                                                          tmp___87 = strcmp((char const   *)args[1],
                                                                                                                                            (char const   *)"on");
#line 1648
                                                                                                                          if (tmp___87) {
#line 1656
                                                                                                                            tmp___86 = strcmp((char const   *)args[1],
                                                                                                                                              (char const   *)"off");
#line 1656
                                                                                                                            if (tmp___86) {
#line 1664
                                                                                                                              if ((int )*(args[1] + 0) >= 48) {
#line 1664
                                                                                                                                if ((int )*(args[1] + 0) <= 57) {
#line 1665
                                                                                                                                  log_id = atoi((char const   *)args[1]);
                                                                                                                                } else {
#line 1664
                                                                                                                                  goto _L___24;
                                                                                                                                }
                                                                                                                              } else {
                                                                                                                                _L___24: /* CIL Label */ ;
                                                                                                                              }
                                                                                                                            } else {
#line 1657
                                                                                                                              if (log_file) {
#line 1658
                                                                                                                                fclose(log_file);
                                                                                                                              }
#line 1659
                                                                                                                              log_file = (FILE *)0;
#line 1660
                                                                                                                              sprintf(filename___1,
                                                                                                                                      (char const   *)"%s/log.%03d",
                                                                                                                                      log_path,
                                                                                                                                      log_id - 1);
#line 1661
                                                                                                                              remove((char const   *)(filename___1));
#line 1662
                                                                                                                              sprintf(filename___1,
                                                                                                                                      (char const   *)"%s/game.%03d",
                                                                                                                                      log_path,
                                                                                                                                      log_id - 1);
#line 1663
                                                                                                                              remove((char const   *)(filename___1));
                                                                                                                            }
                                                                                                                          } else {
#line 1651
                                                                                                                            id = InitializeGetLogID();
#line 1652
                                                                                                                            sprintf(log_filename,
                                                                                                                                    (char const   *)"%s/log.%03d",
                                                                                                                                    log_path,
                                                                                                                                    id);
#line 1653
                                                                                                                            sprintf(history_filename,
                                                                                                                                    (char const   *)"%s/game.%03d",
                                                                                                                                    log_path,
                                                                                                                                    id);
#line 1654
                                                                                                                            log_file = fopen((char const   * __restrict  )(log_filename),
                                                                                                                                             (char const   * __restrict  )"w");
#line 1655
                                                                                                                            history_file = fopen((char const   * __restrict  )(history_filename),
                                                                                                                                                 (char const   * __restrict  )"w+");
                                                                                                                          }
                                                                                                                        } else {
#line 1676
                                                                                                                          tmp___339 = OptionMatch("memory",
                                                                                                                                                  args[0]);
#line 1676
                                                                                                                          if (tmp___339) {
#line 1679
                                                                                                                            if (nargs < 2) {
#line 1680
                                                                                                                              printf((char const   *)"usage:  memory <size>\n");
#line 1681
                                                                                                                              return (1);
                                                                                                                            }
#line 1683
                                                                                                                            if (allow_memory) {
#line 1684
                                                                                                                              tmp___88 = atoi((char const   *)args[1]);
#line 1684
                                                                                                                              size = (uint64_t )tmp___88;
#line 1685
                                                                                                                              if (size == 0UL) {
#line 1686
                                                                                                                                Print(4095,
                                                                                                                                      "ERROR - memory size can not be zero\n");
#line 1687
                                                                                                                                return (1);
                                                                                                                              }
#line 1689
                                                                                                                              tmp___89 = __builtin_clzll((unsigned long long )size);
#line 1689
                                                                                                                              hmemory = (size_t )(1ull << (63 - tmp___89));
#line 1690
                                                                                                                              size &= ~ hmemory;
#line 1691
                                                                                                                              tmp___90 = __builtin_clzll((unsigned long long )size);
#line 1691
                                                                                                                              pmemory = (size_t )(1ull << (63 - tmp___90));
#line 1692
                                                                                                                              sprintf(buffer,
                                                                                                                                      (char const   *)"hash %luM\n",
                                                                                                                                      hmemory);
#line 1693
                                                                                                                              Option(tree);
#line 1694
                                                                                                                              if (pmemory) {
#line 1695
                                                                                                                                sprintf(buffer,
                                                                                                                                        (char const   *)"hashp %luM\n",
                                                                                                                                        pmemory);
#line 1696
                                                                                                                                Option(tree);
                                                                                                                              }
                                                                                                                            } else {
#line 1699
                                                                                                                              Print(4095,
                                                                                                                                    "WARNING - memory command ignored.\n");
                                                                                                                            }
                                                                                                                          } else {
#line 1711
                                                                                                                            tmp___338 = OptionMatch("mode",
                                                                                                                                                    args[0]);
#line 1711
                                                                                                                            if (tmp___338) {
#line 1712
                                                                                                                              if (nargs > 1) {
#line 1713
                                                                                                                                tmp___93 = strcmp((char const   *)args[1],
                                                                                                                                                  (char const   *)"tournament");
#line 1713
                                                                                                                                if (tmp___93) {
#line 1717
                                                                                                                                  tmp___92 = strcmp((char const   *)args[1],
                                                                                                                                                    (char const   *)"normal");
#line 1717
                                                                                                                                  if (tmp___92) {
#line 1722
                                                                                                                                    tmp___91 = strcmp((char const   *)args[1],
                                                                                                                                                      (char const   *)"match");
#line 1722
                                                                                                                                    if (tmp___91) {
#line 1728
                                                                                                                                      printf((char const   *)"usage:  mode normal|tournament|match\n");
#line 1729
                                                                                                                                      mode = (PLAYING_MODE )0;
#line 1730
                                                                                                                                      book_weight_learn = (float )1.0;
#line 1731
                                                                                                                                      book_weight_freq = (float )1.0;
#line 1732
                                                                                                                                      book_weight_eval = (float )0.5;
                                                                                                                                    } else {
#line 1723
                                                                                                                                      mode = (PLAYING_MODE )0;
#line 1724
                                                                                                                                      book_weight_learn = (float )1.0;
#line 1725
                                                                                                                                      book_weight_freq = (float )0.2;
#line 1726
                                                                                                                                      book_weight_eval = (float )0.1;
                                                                                                                                    }
                                                                                                                                  } else {
#line 1718
                                                                                                                                    mode = (PLAYING_MODE )0;
#line 1719
                                                                                                                                    book_weight_learn = (float )1.0;
#line 1720
                                                                                                                                    book_weight_freq = (float )1.0;
#line 1721
                                                                                                                                    book_weight_eval = (float )0.5;
                                                                                                                                  }
                                                                                                                                } else {
#line 1714
                                                                                                                                  mode = (PLAYING_MODE )1;
#line 1715
                                                                                                                                  printf((char const   *)"use \'settc\' command if a game is restarted after Crafty\n");
#line 1716
                                                                                                                                  printf((char const   *)"has been terminated for any reason.\n");
                                                                                                                                }
                                                                                                                              }
#line 1735
                                                                                                                              if ((unsigned int )mode == 1U) {
#line 1736
                                                                                                                                printf((char const   *)"tournament mode.\n");
                                                                                                                              } else
#line 1737
                                                                                                                              if ((unsigned int )mode == 0U) {
#line 1738
                                                                                                                                printf((char const   *)"normal mode.\n");
                                                                                                                              }
                                                                                                                            } else {
#line 1754
                                                                                                                              tmp___337 = OptionMatch("name",
                                                                                                                                                      args[0]);
#line 1754
                                                                                                                              if (tmp___337) {
#line 1758
                                                                                                                                if (nargs < 2) {
#line 1759
                                                                                                                                  printf((char const   *)"usage:  name <name>\n");
#line 1760
                                                                                                                                  return (1);
                                                                                                                                }
#line 1762
                                                                                                                                if (game_wtm) {
#line 1763
                                                                                                                                  strcpy(pgn_white,
                                                                                                                                         (char const   *)args[1]);
#line 1764
                                                                                                                                  sprintf(pgn_black,
                                                                                                                                          (char const   *)"Crafty %s",
                                                                                                                                          version);
                                                                                                                                } else {
#line 1766
                                                                                                                                  strcpy(pgn_black,
                                                                                                                                         (char const   *)args[1]);
#line 1767
                                                                                                                                  sprintf(pgn_white,
                                                                                                                                          (char const   *)"Crafty %s",
                                                                                                                                          version);
                                                                                                                                }
#line 1769
                                                                                                                                Print(32,
                                                                                                                                      "Crafty %s vs %s\n",
                                                                                                                                      version,
                                                                                                                                      args[1]);
#line 1770
                                                                                                                                next___0 = args[1];
                                                                                                                                {
#line 1771
                                                                                                                                while (1) {
                                                                                                                                  while_continue___30: /* CIL Label */ ;
#line 1771
                                                                                                                                  if (! *next___0) {
#line 1771
                                                                                                                                    goto while_break___30;
                                                                                                                                  }
#line 1772
                                                                                                                                  if (sizeof(*next___0) > 1UL) {
#line 1772
                                                                                                                                    if (0) {
#line 1772
                                                                                                                                      __c = (int )*next___0;
#line 1772
                                                                                                                                      if (__c < -128) {
#line 1772
                                                                                                                                        goto _L___25;
                                                                                                                                      } else
#line 1772
                                                                                                                                      if (__c > 255) {
                                                                                                                                        _L___25: /* CIL Label */ 
#line 1772
                                                                                                                                        __res = __c;
                                                                                                                                      } else {
#line 1772
                                                                                                                                        tmp___94 = __ctype_tolower_loc();
#line 1772
                                                                                                                                        __res = (int )*(*tmp___94 + __c);
                                                                                                                                      }
                                                                                                                                    } else {
#line 1772
                                                                                                                                      __res = tolower((int )*next___0);
                                                                                                                                    }
                                                                                                                                  } else {
#line 1772
                                                                                                                                    tmp___95 = __ctype_tolower_loc();
#line 1772
                                                                                                                                    __res = (int )*(*tmp___95 + (int )*next___0);
                                                                                                                                  }
#line 1772
                                                                                                                                  *next___0 = (char )__res;
#line 1773
                                                                                                                                  next___0 ++;
                                                                                                                                }
                                                                                                                                while_break___30: /* CIL Label */ ;
                                                                                                                                }
#line 1775
                                                                                                                                if ((unsigned int )mode != 1U) {
#line 1776
                                                                                                                                  i___5 = 0;
                                                                                                                                  {
#line 1776
                                                                                                                                  while (1) {
                                                                                                                                    while_continue___31: /* CIL Label */ ;
#line 1776
                                                                                                                                    if (! (i___5 < 128)) {
#line 1776
                                                                                                                                      goto while_break___31;
                                                                                                                                    }
#line 1777
                                                                                                                                    if (AK_list[i___5]) {
#line 1777
                                                                                                                                      tmp___96 = strcmp((char const   *)AK_list[i___5],
                                                                                                                                                        (char const   *)args[1]);
#line 1777
                                                                                                                                      if (tmp___96) {
#line 1777
                                                                                                                                        goto _L___26;
                                                                                                                                      } else {
#line 1778
                                                                                                                                        kibitz = 4;
#line 1779
                                                                                                                                        goto while_break___31;
                                                                                                                                      }
                                                                                                                                    } else {
                                                                                                                                      _L___26: /* CIL Label */ ;
                                                                                                                                    }
#line 1776
                                                                                                                                    i___5 ++;
                                                                                                                                  }
                                                                                                                                  while_break___31: /* CIL Label */ ;
                                                                                                                                  }
#line 1781
                                                                                                                                  i___5 = 0;
                                                                                                                                  {
#line 1781
                                                                                                                                  while (1) {
                                                                                                                                    while_continue___32: /* CIL Label */ ;
#line 1781
                                                                                                                                    if (! (i___5 < 128)) {
#line 1781
                                                                                                                                      goto while_break___32;
                                                                                                                                    }
#line 1782
                                                                                                                                    if (GM_list[i___5]) {
#line 1782
                                                                                                                                      tmp___97 = strcmp((char const   *)GM_list[i___5],
                                                                                                                                                        (char const   *)args[1]);
#line 1782
                                                                                                                                      if (tmp___97) {
#line 1782
                                                                                                                                        goto _L___27;
                                                                                                                                      } else {
#line 1783
                                                                                                                                        Print(32,
                                                                                                                                              "playing a GM!\n");
#line 1784
                                                                                                                                        book_selection_width = 3;
#line 1785
                                                                                                                                        if (6 < resign) {
#line 1785
                                                                                                                                          resign = 6;
                                                                                                                                        } else {
#line 1785
                                                                                                                                          resign = resign;
                                                                                                                                        }
#line 1786
                                                                                                                                        resign_count = 4;
#line 1787
                                                                                                                                        draw_count = 4;
#line 1788
                                                                                                                                        accept_draws = 1;
#line 1789
                                                                                                                                        kibitz = 0;
#line 1790
                                                                                                                                        goto while_break___32;
                                                                                                                                      }
                                                                                                                                    } else {
                                                                                                                                      _L___27: /* CIL Label */ ;
                                                                                                                                    }
#line 1781
                                                                                                                                    i___5 ++;
                                                                                                                                  }
                                                                                                                                  while_break___32: /* CIL Label */ ;
                                                                                                                                  }
#line 1792
                                                                                                                                  i___5 = 0;
                                                                                                                                  {
#line 1792
                                                                                                                                  while (1) {
                                                                                                                                    while_continue___33: /* CIL Label */ ;
#line 1792
                                                                                                                                    if (! (i___5 < 128)) {
#line 1792
                                                                                                                                      goto while_break___33;
                                                                                                                                    }
#line 1793
                                                                                                                                    if (IM_list[i___5]) {
#line 1793
                                                                                                                                      tmp___98 = strcmp((char const   *)IM_list[i___5],
                                                                                                                                                        (char const   *)args[1]);
#line 1793
                                                                                                                                      if (tmp___98) {
#line 1793
                                                                                                                                        goto _L___28;
                                                                                                                                      } else {
#line 1794
                                                                                                                                        Print(32,
                                                                                                                                              "playing an IM!\n");
#line 1795
                                                                                                                                        book_selection_width = 4;
#line 1796
                                                                                                                                        if (9 < resign) {
#line 1796
                                                                                                                                          resign = 9;
                                                                                                                                        } else {
#line 1796
                                                                                                                                          resign = resign;
                                                                                                                                        }
#line 1797
                                                                                                                                        resign_count = 5;
#line 1798
                                                                                                                                        draw_count = 4;
#line 1799
                                                                                                                                        accept_draws = 1;
#line 1800
                                                                                                                                        kibitz = 0;
#line 1801
                                                                                                                                        goto while_break___33;
                                                                                                                                      }
                                                                                                                                    } else {
                                                                                                                                      _L___28: /* CIL Label */ ;
                                                                                                                                    }
#line 1792
                                                                                                                                    i___5 ++;
                                                                                                                                  }
                                                                                                                                  while_break___33: /* CIL Label */ ;
                                                                                                                                  }
#line 1803
                                                                                                                                  i___5 = 0;
                                                                                                                                  {
#line 1803
                                                                                                                                  while (1) {
                                                                                                                                    while_continue___34: /* CIL Label */ ;
#line 1803
                                                                                                                                    if (! (i___5 < 128)) {
#line 1803
                                                                                                                                      goto while_break___34;
                                                                                                                                    }
#line 1804
                                                                                                                                    if (SP_list[i___5]) {
#line 1804
                                                                                                                                      tmp___99 = strcmp((char const   *)SP_list[i___5],
                                                                                                                                                        (char const   *)args[1]);
#line 1804
                                                                                                                                      if (tmp___99) {
#line 1804
                                                                                                                                        goto _L___29;
                                                                                                                                      } else {
#line 1805
                                                                                                                                        normal_bs_file___0 = books_file;
#line 1807
                                                                                                                                        Print(32,
                                                                                                                                              "playing a special player!\n");
#line 1808
                                                                                                                                        if (SP_opening_filename[i___5]) {
#line 1809
                                                                                                                                          books_file = fopen((char const   * __restrict  )SP_opening_filename[i___5],
                                                                                                                                                             (char const   * __restrict  )"rb");
#line 1810
                                                                                                                                          if (! books_file) {
#line 1811
                                                                                                                                            Print(4095,
                                                                                                                                                  "Error!  unable to open %s for player %s.\n",
                                                                                                                                                  SP_opening_filename[i___5],
                                                                                                                                                  SP_list[i___5]);
#line 1813
                                                                                                                                            books_file = normal_bs_file___0;
                                                                                                                                          }
                                                                                                                                        }
#line 1816
                                                                                                                                        if (SP_personality_filename[i___5]) {
#line 1817
                                                                                                                                          sprintf(buffer,
                                                                                                                                                  (char const   *)"personality load %s\n",
                                                                                                                                                  SP_personality_filename[i___5]);
#line 1819
                                                                                                                                          Option(tree);
                                                                                                                                        }
#line 1821
                                                                                                                                        goto while_break___34;
                                                                                                                                      }
                                                                                                                                    } else {
                                                                                                                                      _L___29: /* CIL Label */ ;
                                                                                                                                    }
#line 1803
                                                                                                                                    i___5 ++;
                                                                                                                                  }
                                                                                                                                  while_break___34: /* CIL Label */ ;
                                                                                                                                  }
                                                                                                                                }
#line 1824
                                                                                                                                if (1U > smp_max_threads) {
#line 1824
                                                                                                                                  tmp___100 = 1U;
                                                                                                                                } else {
#line 1824
                                                                                                                                  tmp___100 = smp_max_threads;
                                                                                                                                }
#line 1824
                                                                                                                                printf((char const   *)"tellicsnoalias kibitz Hello from Crafty v%s! (%d cpus)\n",
                                                                                                                                       version,
                                                                                                                                       tmp___100);
                                                                                                                              } else {
#line 1834
                                                                                                                                tmp___336 = OptionMatch("new",
                                                                                                                                                        args[0]);
#line 1834
                                                                                                                                if (tmp___336) {
#line 1835
                                                                                                                                  Print(4095,
                                                                                                                                        "NOTICE:  new command not implemented, please exit and\n");
#line 1836
                                                                                                                                  Print(4095,
                                                                                                                                        "restart crafty to re-initialize everything for a new game\n");
#line 1837
                                                                                                                                  return (1);
                                                                                                                                } else {
#line 1851
                                                                                                                                  tmp___335 = OptionMatch("noise",
                                                                                                                                                          args[0]);
#line 1851
                                                                                                                                  if (tmp___335) {
#line 1852
                                                                                                                                    if (nargs < 2) {
#line 1853
                                                                                                                                      printf((char const   *)"usage:  noise <n>\n");
#line 1854
                                                                                                                                      return (1);
                                                                                                                                    }
#line 1856
                                                                                                                                    tmp___101 = atof((char const   *)args[1]);
#line 1856
                                                                                                                                    noise_level = (unsigned int )(tmp___101 * (double )100);
#line 1857
                                                                                                                                    Print(32,
                                                                                                                                          "noise level set to %.2f seconds.\n",
                                                                                                                                          (double )((float )noise_level) / 100.0);
                                                                                                                                  } else {
#line 1882
                                                                                                                                    tmp___334 = OptionMatch("null",
                                                                                                                                                            args[0]);
#line 1882
                                                                                                                                    if (tmp___334) {
#line 1884
                                                                                                                                      if (nargs > 3) {
#line 1885
                                                                                                                                        printf((char const   *)"usage:  null <min> <divisor>\n");
#line 1886
                                                                                                                                        return (1);
                                                                                                                                      }
#line 1888
                                                                                                                                      if (nargs > 1) {
#line 1889
                                                                                                                                        null_depth = atoi((char const   *)args[1]);
#line 1890
                                                                                                                                        null_divisor = atoi((char const   *)args[2]);
                                                                                                                                      }
#line 1892
                                                                                                                                      Print(32,
                                                                                                                                            "null move:  R = %d + depth / %d\n",
                                                                                                                                            null_depth,
                                                                                                                                            null_divisor);
                                                                                                                                    } else {
#line 1903
                                                                                                                                      tmp___333 = OptionMatch("otim",
                                                                                                                                                              args[0]);
#line 1903
                                                                                                                                      if (tmp___333) {
#line 1904
                                                                                                                                        if (nargs < 2) {
#line 1905
                                                                                                                                          printf((char const   *)"usage:  otime <time(unit=.01 secs))>\n");
#line 1906
                                                                                                                                          return (1);
                                                                                                                                        }
#line 1908
                                                                                                                                        tc_time_remaining[game_wtm] = atoi((char const   *)args[1]);
#line 1909
                                                                                                                                        if (log_file) {
#line 1909
                                                                                                                                          if (time_limit > 99) {
#line 1910
                                                                                                                                            tmp___102 = DisplayTime((unsigned int )tc_time_remaining[game_wtm]);
#line 1910
                                                                                                                                            fprintf(log_file,
                                                                                                                                                    (char const   *)"time remaining: %s (opponent).\n",
                                                                                                                                                    tmp___102);
                                                                                                                                          } else {
#line 1909
                                                                                                                                            goto _L___30;
                                                                                                                                          }
                                                                                                                                        } else {
                                                                                                                                          _L___30: /* CIL Label */ ;
                                                                                                                                        }
#line 1912
                                                                                                                                        if (call_flag) {
#line 1912
                                                                                                                                          if (xboard) {
#line 1912
                                                                                                                                            if (tc_time_remaining[game_wtm] < 1) {
#line 1913
                                                                                                                                              if (crafty_is_white) {
#line 1914
                                                                                                                                                Print(32,
                                                                                                                                                      "1-0 {Black ran out of time}\n");
                                                                                                                                              } else {
#line 1916
                                                                                                                                                Print(32,
                                                                                                                                                      "0-1 {White ran out of time}\n");
                                                                                                                                              }
                                                                                                                                            } else {
#line 1912
                                                                                                                                              goto _L___32;
                                                                                                                                            }
                                                                                                                                          } else {
#line 1912
                                                                                                                                            goto _L___32;
                                                                                                                                          }
                                                                                                                                        } else {
                                                                                                                                          _L___32: /* CIL Label */ 
                                                                                                                                          _L___31: /* CIL Label */ ;
                                                                                                                                        }
                                                                                                                                      } else {
#line 1927
                                                                                                                                        tmp___332 = OptionMatch("output",
                                                                                                                                                                args[0]);
#line 1927
                                                                                                                                        if (tmp___332) {
#line 1928
                                                                                                                                          if (nargs < 2) {
#line 1929
                                                                                                                                            printf((char const   *)"usage:  output long|short\n");
#line 1930
                                                                                                                                            return (1);
                                                                                                                                          }
#line 1932
                                                                                                                                          tmp___104 = strcmp((char const   *)args[1],
                                                                                                                                                             (char const   *)"long");
#line 1932
                                                                                                                                          if (tmp___104) {
#line 1934
                                                                                                                                            tmp___103 = strcmp((char const   *)args[1],
                                                                                                                                                               (char const   *)"short");
#line 1934
                                                                                                                                            if (tmp___103) {
#line 1937
                                                                                                                                              printf((char const   *)"usage:  output long|short\n");
                                                                                                                                            } else {
#line 1935
                                                                                                                                              output_format = 0;
                                                                                                                                            }
                                                                                                                                          } else {
#line 1933
                                                                                                                                            output_format = 1;
                                                                                                                                          }
#line 1938
                                                                                                                                          if (output_format == 1) {
#line 1939
                                                                                                                                            Print(32,
                                                                                                                                                  "output moves in long algebraic format\n");
                                                                                                                                          } else
#line 1940
                                                                                                                                          if (output_format == 0) {
#line 1941
                                                                                                                                            Print(32,
                                                                                                                                                  "output moves in short algebraic format\n");
                                                                                                                                          }
                                                                                                                                        } else {
#line 1951
                                                                                                                                          tmp___331 = OptionMatch("personality",
                                                                                                                                                                  args[0]);
#line 1951
                                                                                                                                          if (tmp___331) {
#line 1962
                                                                                                                                            if (nargs == 2) {
#line 1962
                                                                                                                                              tmp___105 = strcmp((char const   *)args[1],
                                                                                                                                                                 (char const   *)"list");
#line 1962
                                                                                                                                              if (tmp___105) {
#line 1962
                                                                                                                                                goto _L___33;
                                                                                                                                              } else {
#line 1963
                                                                                                                                                printf((char const   *)"\n");
#line 1964
                                                                                                                                                i___6 = 0;
                                                                                                                                                {
#line 1964
                                                                                                                                                while (1) {
                                                                                                                                                  while_continue___35: /* CIL Label */ ;
#line 1964
                                                                                                                                                  if (! (i___6 < 256)) {
#line 1964
                                                                                                                                                    goto while_break___35;
                                                                                                                                                  }
#line 1965
                                                                                                                                                  if (! personality_packet[i___6].description) {
#line 1966
                                                                                                                                                    goto __Cont;
                                                                                                                                                  }
#line 1967
                                                                                                                                                  if (personality_packet[i___6].value) {
                                                                                                                                                    {
#line 1969
                                                                                                                                                    if (personality_packet[i___6].type == 1) {
#line 1969
                                                                                                                                                      goto case_1;
                                                                                                                                                    }
#line 1973
                                                                                                                                                    if (personality_packet[i___6].type == 2) {
#line 1973
                                                                                                                                                      goto case_2;
                                                                                                                                                    }
#line 1979
                                                                                                                                                    if (personality_packet[i___6].type == 3) {
#line 1979
                                                                                                                                                      goto case_3;
                                                                                                                                                    }
#line 1983
                                                                                                                                                    if (personality_packet[i___6].type == 4) {
#line 1983
                                                                                                                                                      goto case_4;
                                                                                                                                                    }
#line 1968
                                                                                                                                                    goto switch_break;
                                                                                                                                                    case_1: /* CIL Label */ 
#line 1970
                                                                                                                                                    printf((char const   *)"%3d  %s %7d\n",
                                                                                                                                                           i___6,
                                                                                                                                                           personality_packet[i___6].description,
                                                                                                                                                           *((int *)personality_packet[i___6].value));
#line 1972
                                                                                                                                                    goto switch_break;
                                                                                                                                                    case_2: /* CIL Label */ 
#line 1974
                                                                                                                                                    printf((char const   *)"%3d  %s %7d (mg) %7d (eg)\n",
                                                                                                                                                           i___6,
                                                                                                                                                           personality_packet[i___6].description,
                                                                                                                                                           *((int *)personality_packet[i___6].value + 0),
                                                                                                                                                           *((int *)personality_packet[i___6].value + 1));
#line 1978
                                                                                                                                                    goto switch_break;
                                                                                                                                                    case_3: /* CIL Label */ 
#line 1980
                                                                                                                                                    printf((char const   *)"%3d  %s %7.2f\n",
                                                                                                                                                           i___6,
                                                                                                                                                           personality_packet[i___6].description,
                                                                                                                                                           *((double *)personality_packet[i___6].value));
#line 1982
                                                                                                                                                    goto switch_break;
                                                                                                                                                    case_4: /* CIL Label */ 
#line 1984
                                                                                                                                                    printf((char const   *)"%3d  %s    ",
                                                                                                                                                           i___6,
                                                                                                                                                           personality_packet[i___6].description);
#line 1985
                                                                                                                                                    j___2 = 0;
                                                                                                                                                    {
#line 1985
                                                                                                                                                    while (1) {
                                                                                                                                                      while_continue___36: /* CIL Label */ ;
#line 1985
                                                                                                                                                      if (! (j___2 < personality_packet[i___6].size)) {
#line 1985
                                                                                                                                                        goto while_break___36;
                                                                                                                                                      }
#line 1986
                                                                                                                                                      printf((char const   *)"%4d",
                                                                                                                                                             *((int *)personality_packet[i___6].value + j___2));
#line 1985
                                                                                                                                                      j___2 ++;
                                                                                                                                                    }
                                                                                                                                                    while_break___36: /* CIL Label */ ;
                                                                                                                                                    }
#line 1987
                                                                                                                                                    printf((char const   *)"\n");
#line 1988
                                                                                                                                                    goto switch_break;
                                                                                                                                                    switch_break: /* CIL Label */ ;
                                                                                                                                                    }
                                                                                                                                                  } else {
#line 1991
                                                                                                                                                    printf((char const   *)"==================================================\n");
#line 1992
                                                                                                                                                    printf((char const   *)"=         %s  =\n",
                                                                                                                                                           personality_packet[i___6].description);
#line 1993
                                                                                                                                                    printf((char const   *)"==================================================\n");
                                                                                                                                                  }
                                                                                                                                                  __Cont: /* CIL Label */ 
#line 1964
                                                                                                                                                  i___6 ++;
                                                                                                                                                }
                                                                                                                                                while_break___35: /* CIL Label */ ;
                                                                                                                                                }
#line 1996
                                                                                                                                                printf((char const   *)"\n");
#line 1997
                                                                                                                                                return (1);
                                                                                                                                              }
                                                                                                                                            } else {
                                                                                                                                              _L___33: /* CIL Label */ ;
                                                                                                                                            }
#line 2007
                                                                                                                                            tmp___108 = strcmp((char const   *)args[1],
                                                                                                                                                               (char const   *)"load");
#line 2007
                                                                                                                                            if (! tmp___108) {
#line 2011
                                                                                                                                              strcpy(filename___2,
                                                                                                                                                     (char const   *)args[2]);
#line 2012
                                                                                                                                              tmp___106 = strstr((char const   *)(filename___2),
                                                                                                                                                                 (char const   *)".cpf");
#line 2012
                                                                                                                                              if (! tmp___106) {
#line 2013
                                                                                                                                                strcat(filename___2,
                                                                                                                                                       (char const   *)".cpf");
                                                                                                                                              }
#line 2014
                                                                                                                                              Print(32,
                                                                                                                                                    "Loading personality file %s\n",
                                                                                                                                                    filename___2);
#line 2015
                                                                                                                                              file___3 = fopen((char const   * __restrict  )(filename___2),
                                                                                                                                                               (char const   * __restrict  )"r+");
#line 2015
                                                                                                                                              if (file___3) {
                                                                                                                                                {
#line 2016
                                                                                                                                                while (1) {
                                                                                                                                                  while_continue___37: /* CIL Label */ ;
#line 2016
                                                                                                                                                  tmp___107 = fgets(buffer,
                                                                                                                                                                    4096,
                                                                                                                                                                    file___3);
#line 2016
                                                                                                                                                  if (! tmp___107) {
#line 2016
                                                                                                                                                    goto while_break___37;
                                                                                                                                                  }
#line 2019
                                                                                                                                                  delim___1 = strchr((char const   *)(buffer),
                                                                                                                                                                     '\n');
#line 2020
                                                                                                                                                  if (delim___1) {
#line 2021
                                                                                                                                                    *delim___1 = (char)0;
                                                                                                                                                  }
#line 2022
                                                                                                                                                  delim___1 = strstr((char const   *)(buffer),
                                                                                                                                                                     (char const   *)"->");
#line 2023
                                                                                                                                                  if (delim___1) {
#line 2024
                                                                                                                                                    *delim___1 = (char)0;
                                                                                                                                                  }
#line 2025
                                                                                                                                                  delim___1 = strchr((char const   *)(buffer),
                                                                                                                                                                     '\r');
#line 2026
                                                                                                                                                  if (delim___1) {
#line 2027
                                                                                                                                                    *delim___1 = (char )' ';
                                                                                                                                                  }
#line 2028
                                                                                                                                                  Option(tree);
                                                                                                                                                }
                                                                                                                                                while_break___37: /* CIL Label */ ;
                                                                                                                                                }
#line 2030
                                                                                                                                                fclose(file___3);
                                                                                                                                              }
#line 2032
                                                                                                                                              return (1);
                                                                                                                                            }
#line 2042
                                                                                                                                            if (nargs == 3) {
#line 2042
                                                                                                                                              tmp___110 = strcmp((char const   *)args[1],
                                                                                                                                                                 (char const   *)"save");
#line 2042
                                                                                                                                              if (tmp___110) {
#line 2042
                                                                                                                                                goto _L___34;
                                                                                                                                              } else {
#line 2046
                                                                                                                                                strcpy(filename___3,
                                                                                                                                                       (char const   *)args[2]);
#line 2047
                                                                                                                                                tmp___109 = strstr((char const   *)(filename___3),
                                                                                                                                                                   (char const   *)".cpf");
#line 2047
                                                                                                                                                if (! tmp___109) {
#line 2048
                                                                                                                                                  strcat(filename___3,
                                                                                                                                                         (char const   *)".cpf");
                                                                                                                                                }
#line 2049
                                                                                                                                                file___4 = fopen((char const   * __restrict  )(filename___3),
                                                                                                                                                                 (char const   * __restrict  )"w");
#line 2050
                                                                                                                                                if (! file___4) {
#line 2051
                                                                                                                                                  printf((char const   *)"ERROR.  Unable to open %s for writing\n",
                                                                                                                                                         args[2]);
#line 2052
                                                                                                                                                  return (1);
                                                                                                                                                }
#line 2054
                                                                                                                                                printf((char const   *)"saving to file \"%s\"\n",
                                                                                                                                                       filename___3);
#line 2055
                                                                                                                                                fprintf(file___4,
                                                                                                                                                        (char const   *)"# Crafty v%s personality file\n",
                                                                                                                                                        version);
#line 2056
                                                                                                                                                i___6 = 0;
                                                                                                                                                {
#line 2056
                                                                                                                                                while (1) {
                                                                                                                                                  while_continue___38: /* CIL Label */ ;
#line 2056
                                                                                                                                                  if (! (i___6 < 256)) {
#line 2056
                                                                                                                                                    goto while_break___38;
                                                                                                                                                  }
#line 2057
                                                                                                                                                  if (! personality_packet[i___6].description) {
#line 2058
                                                                                                                                                    goto __Cont___0;
                                                                                                                                                  }
#line 2059
                                                                                                                                                  if (personality_packet[i___6].value) {
#line 2060
                                                                                                                                                    if (personality_packet[i___6].size <= 1) {
#line 2061
                                                                                                                                                      fprintf(file___4,
                                                                                                                                                              (char const   *)"personality %3d %7d\n",
                                                                                                                                                              i___6,
                                                                                                                                                              *((int *)personality_packet[i___6].value));
                                                                                                                                                    } else
#line 2063
                                                                                                                                                    if (personality_packet[i___6].size > 1) {
#line 2064
                                                                                                                                                      fprintf(file___4,
                                                                                                                                                              (char const   *)"personality %3d ",
                                                                                                                                                              i___6);
#line 2065
                                                                                                                                                      j___2 = 0;
                                                                                                                                                      {
#line 2065
                                                                                                                                                      while (1) {
                                                                                                                                                        while_continue___39: /* CIL Label */ ;
#line 2065
                                                                                                                                                        if (! (j___2 < personality_packet[i___6].size)) {
#line 2065
                                                                                                                                                          goto while_break___39;
                                                                                                                                                        }
#line 2066
                                                                                                                                                        fprintf(file___4,
                                                                                                                                                                (char const   *)"%d ",
                                                                                                                                                                *((int *)personality_packet[i___6].value + j___2));
#line 2065
                                                                                                                                                        j___2 ++;
                                                                                                                                                      }
                                                                                                                                                      while_break___39: /* CIL Label */ ;
                                                                                                                                                      }
#line 2067
                                                                                                                                                      fprintf(file___4,
                                                                                                                                                              (char const   *)"\n");
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                  __Cont___0: /* CIL Label */ 
#line 2056
                                                                                                                                                  i___6 ++;
                                                                                                                                                }
                                                                                                                                                while_break___38: /* CIL Label */ ;
                                                                                                                                                }
#line 2071
                                                                                                                                                fprintf(file___4,
                                                                                                                                                        (char const   *)"exit\n");
#line 2072
                                                                                                                                                fclose(file___4);
#line 2073
                                                                                                                                                return (1);
                                                                                                                                              }
                                                                                                                                            } else {
                                                                                                                                              _L___34: /* CIL Label */ ;
                                                                                                                                            }
#line 2083
                                                                                                                                            param = atoi((char const   *)args[1]);
#line 2084
                                                                                                                                            value = atoi((char const   *)args[2]);
#line 2085
                                                                                                                                            if (! personality_packet[param].value) {
#line 2086
                                                                                                                                              Print(4095,
                                                                                                                                                    "ERROR.  evaluation term %d is not defined\n",
                                                                                                                                                    param);
#line 2087
                                                                                                                                              return (1);
                                                                                                                                            }
#line 2089
                                                                                                                                            if (personality_packet[param].size == 0) {
#line 2090
                                                                                                                                              if (nargs > 3) {
#line 2091
                                                                                                                                                printf((char const   *)"this eval term requires exactly 1 value.\n");
#line 2092
                                                                                                                                                return (1);
                                                                                                                                              }
#line 2094
                                                                                                                                              *((int *)personality_packet[param].value) = value;
                                                                                                                                            } else {
#line 2105
                                                                                                                                              index___1 = nargs - 2;
#line 2106
                                                                                                                                              if (index___1 != personality_packet[param].size) {
#line 2107
                                                                                                                                                if (personality_packet[param].size > 0) {
#line 2107
                                                                                                                                                  tmp___111 = personality_packet[param].size;
                                                                                                                                                } else {
#line 2107
                                                                                                                                                  tmp___111 = - personality_packet[param].size;
                                                                                                                                                }
#line 2107
                                                                                                                                                printf((char const   *)"this eval term (%s [%d]) requires exactly %d values, found %d.\n",
                                                                                                                                                       personality_packet[param].description,
                                                                                                                                                       param,
                                                                                                                                                       tmp___111,
                                                                                                                                                       index___1);
#line 2111
                                                                                                                                                return (1);
                                                                                                                                              }
#line 2113
                                                                                                                                              i___6 = 0;
                                                                                                                                              {
#line 2113
                                                                                                                                              while (1) {
                                                                                                                                                while_continue___40: /* CIL Label */ ;
#line 2113
                                                                                                                                                if (! (i___6 < index___1)) {
#line 2113
                                                                                                                                                  goto while_break___40;
                                                                                                                                                }
#line 2114
                                                                                                                                                *((int *)personality_packet[param].value + i___6) = atoi((char const   *)args[i___6 + 2]);
#line 2113
                                                                                                                                                i___6 ++;
                                                                                                                                              }
                                                                                                                                              while_break___40: /* CIL Label */ ;
                                                                                                                                              }
                                                                                                                                            }
#line 2116
                                                                                                                                            InitializeKingSafety();
                                                                                                                                          } else {
#line 2126
                                                                                                                                            tmp___328 = OptionMatch("logpath",
                                                                                                                                                                    args[0]);
#line 2126
                                                                                                                                            if (tmp___328) {
#line 2126
                                                                                                                                              goto _L___74;
                                                                                                                                            } else {
#line 2126
                                                                                                                                              tmp___329 = OptionMatch("bookpath",
                                                                                                                                                                      args[0]);
#line 2126
                                                                                                                                              if (tmp___329) {
                                                                                                                                                _L___74: /* CIL Label */ 
#line 2126
                                                                                                                                                goto _L___73;
                                                                                                                                              } else {
#line 2126
                                                                                                                                                tmp___330 = OptionMatch("tbpath",
                                                                                                                                                                        args[0]);
#line 2126
                                                                                                                                                if (tmp___330) {
                                                                                                                                                  _L___73: /* CIL Label */ 
#line 2128
                                                                                                                                                  tmp___112 = OptionMatch("logpath",
                                                                                                                                                                          args[0]);
#line 2128
                                                                                                                                                  if (tmp___112) {
#line 2128
                                                                                                                                                    goto _L___35;
                                                                                                                                                  } else {
#line 2128
                                                                                                                                                    tmp___113 = OptionMatch("bookpath",
                                                                                                                                                                            args[0]);
#line 2128
                                                                                                                                                    if (tmp___113) {
                                                                                                                                                      _L___35: /* CIL Label */ 
#line 2129
                                                                                                                                                      if (log_file) {
#line 2130
                                                                                                                                                        Print(4095,
                                                                                                                                                              "ERROR -- this must be used on command line only\n");
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                  }
#line 2132
                                                                                                                                                  nargs = ReadParse(buffer,
                                                                                                                                                                    args,
                                                                                                                                                                    " \t=");
#line 2133
                                                                                                                                                  if (nargs < 2) {
#line 2134
                                                                                                                                                    printf((char const   *)"usage:  bookpath|perspath|logpath|tbpath <path>\n");
#line 2135
                                                                                                                                                    return (1);
                                                                                                                                                  }
#line 2137
                                                                                                                                                  tmp___122 = strchr((char const   *)args[1],
                                                                                                                                                                     '(');
#line 2137
                                                                                                                                                  if (tmp___122) {
#line 2148
                                                                                                                                                    tmp___121 = strchr((char const   *)args[1],
                                                                                                                                                                       ')');
#line 2148
                                                                                                                                                    if (tmp___121) {
#line 2149
                                                                                                                                                      tmp___117 = strchr((char const   *)args[1],
                                                                                                                                                                         ')');
#line 2149
                                                                                                                                                      *tmp___117 = (char)0;
#line 2150
                                                                                                                                                      tmp___120 = strstr((char const   *)args[0],
                                                                                                                                                                         (char const   *)"bookpath");
#line 2150
                                                                                                                                                      if (tmp___120) {
#line 2151
                                                                                                                                                        strcpy(book_path,
                                                                                                                                                               (char const   *)(args[1] + 1));
                                                                                                                                                      } else {
#line 2152
                                                                                                                                                        tmp___119 = strstr((char const   *)args[0],
                                                                                                                                                                           (char const   *)"logpath");
#line 2152
                                                                                                                                                        if (tmp___119) {
#line 2153
                                                                                                                                                          strcpy(log_path,
                                                                                                                                                                 (char const   *)(args[1] + 1));
                                                                                                                                                        } else {
#line 2155
                                                                                                                                                          tmp___118 = strstr((char const   *)args[0],
                                                                                                                                                                             (char const   *)"tbpath");
#line 2155
                                                                                                                                                          if (tmp___118) {
#line 2156
                                                                                                                                                            strcpy(tb_path,
                                                                                                                                                                   (char const   *)(args[1] + 1));
                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                    } else {
#line 2159
                                                                                                                                                      Print(4095,
                                                                                                                                                            "ERROR multiple paths must be enclosed in ( and )\n");
                                                                                                                                                    }
                                                                                                                                                  } else {
#line 2138
                                                                                                                                                    tmp___116 = strstr((char const   *)args[0],
                                                                                                                                                                       (char const   *)"bookpath");
#line 2138
                                                                                                                                                    if (tmp___116) {
#line 2139
                                                                                                                                                      strcpy(book_path,
                                                                                                                                                             (char const   *)args[1]);
                                                                                                                                                    } else {
#line 2140
                                                                                                                                                      tmp___115 = strstr((char const   *)args[0],
                                                                                                                                                                         (char const   *)"logpath");
#line 2140
                                                                                                                                                      if (tmp___115) {
#line 2141
                                                                                                                                                        strcpy(log_path,
                                                                                                                                                               (char const   *)args[1]);
                                                                                                                                                      } else {
#line 2143
                                                                                                                                                        tmp___114 = strstr((char const   *)args[0],
                                                                                                                                                                           (char const   *)"tbpath");
#line 2143
                                                                                                                                                        if (tmp___114) {
#line 2144
                                                                                                                                                          strcpy(tb_path,
                                                                                                                                                                 (char const   *)args[1]);
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                } else {
#line 2170
                                                                                                                                                  tmp___327 = OptionMatch("perf",
                                                                                                                                                                          args[0]);
#line 2170
                                                                                                                                                  if (tmp___327) {
#line 2175
                                                                                                                                                    if (thinking) {
#line 2175
                                                                                                                                                      goto _L___36;
                                                                                                                                                    } else
#line 2175
                                                                                                                                                    if (pondering) {
                                                                                                                                                      _L___36: /* CIL Label */ 
#line 2176
                                                                                                                                                      return (2);
                                                                                                                                                    }
#line 2177
                                                                                                                                                    tmp___123 = clock();
#line 2177
                                                                                                                                                    clock_before = (int )tmp___123;
                                                                                                                                                    {
#line 2178
                                                                                                                                                    while (1) {
                                                                                                                                                      while_continue___41: /* CIL Label */ ;
#line 2178
                                                                                                                                                      tmp___124 = clock();
#line 2178
                                                                                                                                                      if (! (tmp___124 == (clock_t )clock_before)) {
#line 2178
                                                                                                                                                        goto while_break___41;
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                    while_break___41: /* CIL Label */ ;
                                                                                                                                                    }
#line 2179
                                                                                                                                                    tmp___125 = clock();
#line 2179
                                                                                                                                                    clock_before = (int )tmp___125;
#line 2180
                                                                                                                                                    i___7 = 0;
                                                                                                                                                    {
#line 2180
                                                                                                                                                    while (1) {
                                                                                                                                                      while_continue___42: /* CIL Label */ ;
#line 2180
                                                                                                                                                      if (! (i___7 < 4000000)) {
#line 2180
                                                                                                                                                        goto while_break___42;
                                                                                                                                                      }
#line 2181
                                                                                                                                                      tree->last[1] = GenerateCaptures(tree,
                                                                                                                                                                                       0,
                                                                                                                                                                                       game_wtm,
                                                                                                                                                                                       tree->last[0]);
#line 2182
                                                                                                                                                      tree->last[1] = GenerateNoncaptures(tree,
                                                                                                                                                                                          0,
                                                                                                                                                                                          game_wtm,
                                                                                                                                                                                          tree->last[1]);
#line 2180
                                                                                                                                                      i___7 ++;
                                                                                                                                                    }
                                                                                                                                                    while_break___42: /* CIL Label */ ;
                                                                                                                                                    }
#line 2184
                                                                                                                                                    tmp___126 = clock();
#line 2184
                                                                                                                                                    clock_after = (int )tmp___126;
#line 2185
                                                                                                                                                    time_used___0 = ((float )clock_after - (float )clock_before) / (float )1000000L;
#line 2187
                                                                                                                                                    printf((char const   *)"generated %d moves, time=%.2f seconds\n",
                                                                                                                                                           (int )(tree->last[1] - tree->last[0]) * 4000000,
                                                                                                                                                           (double )time_used___0);
#line 2189
                                                                                                                                                    printf((char const   *)"generated %d moves per second\n",
                                                                                                                                                           (int )((float )(4000000L * (tree->last[1] - tree->last[0])) / time_used___0));
#line 2192
                                                                                                                                                    tmp___127 = clock();
#line 2192
                                                                                                                                                    clock_before = (int )tmp___127;
                                                                                                                                                    {
#line 2193
                                                                                                                                                    while (1) {
                                                                                                                                                      while_continue___43: /* CIL Label */ ;
#line 2193
                                                                                                                                                      tmp___128 = clock();
#line 2193
                                                                                                                                                      if (! (tmp___128 == (clock_t )clock_before)) {
#line 2193
                                                                                                                                                        goto while_break___43;
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                    while_break___43: /* CIL Label */ ;
                                                                                                                                                    }
#line 2194
                                                                                                                                                    tmp___129 = clock();
#line 2194
                                                                                                                                                    clock_before = (int )tmp___129;
#line 2195
                                                                                                                                                    i___7 = 0;
                                                                                                                                                    {
#line 2195
                                                                                                                                                    while (1) {
                                                                                                                                                      while_continue___44: /* CIL Label */ ;
#line 2195
                                                                                                                                                      if (! (i___7 < 4000000)) {
#line 2195
                                                                                                                                                        goto while_break___44;
                                                                                                                                                      }
#line 2196
                                                                                                                                                      tree->last[1] = GenerateCaptures(tree,
                                                                                                                                                                                       0,
                                                                                                                                                                                       game_wtm,
                                                                                                                                                                                       tree->last[0]);
#line 2197
                                                                                                                                                      tree->last[1] = GenerateNoncaptures(tree,
                                                                                                                                                                                          0,
                                                                                                                                                                                          game_wtm,
                                                                                                                                                                                          tree->last[1]);
#line 2198
                                                                                                                                                      mv = tree->last[0];
                                                                                                                                                      {
#line 2198
                                                                                                                                                      while (1) {
                                                                                                                                                        while_continue___45: /* CIL Label */ ;
#line 2198
                                                                                                                                                        if (! ((unsigned long )mv < (unsigned long )tree->last[1])) {
#line 2198
                                                                                                                                                          goto while_break___45;
                                                                                                                                                        }
#line 2199
                                                                                                                                                        MakeMove(tree,
                                                                                                                                                                 0,
                                                                                                                                                                 game_wtm,
                                                                                                                                                                 (int )*mv);
#line 2200
                                                                                                                                                        UnmakeMove(tree,
                                                                                                                                                                   0,
                                                                                                                                                                   game_wtm,
                                                                                                                                                                   (int )*mv);
#line 2198
                                                                                                                                                        mv ++;
                                                                                                                                                      }
                                                                                                                                                      while_break___45: /* CIL Label */ ;
                                                                                                                                                      }
#line 2195
                                                                                                                                                      i___7 ++;
                                                                                                                                                    }
                                                                                                                                                    while_break___44: /* CIL Label */ ;
                                                                                                                                                    }
#line 2203
                                                                                                                                                    tmp___130 = clock();
#line 2203
                                                                                                                                                    clock_after = (int )tmp___130;
#line 2204
                                                                                                                                                    time_used___0 = ((float )clock_after - (float )clock_before) / (float )1000000L;
#line 2206
                                                                                                                                                    printf((char const   *)"generated/made/unmade %d moves, time=%.2f seconds\n",
                                                                                                                                                           (int )(tree->last[1] - tree->last[0]) * 4000000,
                                                                                                                                                           (double )time_used___0);
#line 2208
                                                                                                                                                    printf((char const   *)"generated/made/unmade %d moves per second\n",
                                                                                                                                                           (int )((float )(4000000L * (tree->last[1] - tree->last[0])) / time_used___0));
                                                                                                                                                  } else {
#line 2219
                                                                                                                                                    tmp___326 = OptionMatch("perft",
                                                                                                                                                                            args[0]);
#line 2219
                                                                                                                                                    if (tmp___326) {
#line 2223
                                                                                                                                                      if (thinking) {
#line 2223
                                                                                                                                                        goto _L___37;
                                                                                                                                                      } else
#line 2223
                                                                                                                                                      if (pondering) {
                                                                                                                                                        _L___37: /* CIL Label */ 
#line 2224
                                                                                                                                                        return (2);
                                                                                                                                                      }
#line 2225
                                                                                                                                                      tmp___131 = clock();
#line 2225
                                                                                                                                                      clock_before___0 = (int )tmp___131;
                                                                                                                                                      {
#line 2226
                                                                                                                                                      while (1) {
                                                                                                                                                        while_continue___46: /* CIL Label */ ;
#line 2226
                                                                                                                                                        tmp___132 = clock();
#line 2226
                                                                                                                                                        if (! (tmp___132 == (clock_t )clock_before___0)) {
#line 2226
                                                                                                                                                          goto while_break___46;
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                      while_break___46: /* CIL Label */ ;
                                                                                                                                                      }
#line 2227
                                                                                                                                                      tmp___133 = clock();
#line 2227
                                                                                                                                                      clock_before___0 = (int )tmp___133;
#line 2228
                                                                                                                                                      if (nargs < 2) {
#line 2229
                                                                                                                                                        printf((char const   *)"usage:  perft <depth>\n");
#line 2230
                                                                                                                                                        return (1);
                                                                                                                                                      }
#line 2232
                                                                                                                                                      tree->status[1] = tree->status[0];
#line 2233
                                                                                                                                                      tree->last[0] = tree->move_list;
#line 2234
                                                                                                                                                      i___8 = atoi((char const   *)args[1]);
#line 2235
                                                                                                                                                      if (i___8 <= 0) {
#line 2236
                                                                                                                                                        Print(32,
                                                                                                                                                              "usage:  perft <maxply>\n");
#line 2237
                                                                                                                                                        return (1);
                                                                                                                                                      }
#line 2239
                                                                                                                                                      total_moves = (uint64_t )0;
#line 2240
                                                                                                                                                      OptionPerft(tree,
                                                                                                                                                                  1,
                                                                                                                                                                  i___8,
                                                                                                                                                                  game_wtm);
#line 2241
                                                                                                                                                      tmp___134 = clock();
#line 2241
                                                                                                                                                      clock_after___0 = (int )tmp___134;
#line 2242
                                                                                                                                                      time_used___1 = ((float )clock_after___0 - (float )clock_before___0) / (float )1000000L;
#line 2244
                                                                                                                                                      printf((char const   *)"total moves=%lu  time=%.2f\n",
                                                                                                                                                             total_moves,
                                                                                                                                                             (double )time_used___1);
                                                                                                                                                    } else {
#line 2253
                                                                                                                                                      tmp___325 = OptionMatch("pgn",
                                                                                                                                                                              args[0]);
#line 2253
                                                                                                                                                      if (tmp___325) {
#line 2256
                                                                                                                                                        if (nargs < 3) {
#line 2257
                                                                                                                                                          printf((char const   *)"usage:  pgn <tag> <value>\n");
#line 2258
                                                                                                                                                          return (1);
                                                                                                                                                        }
#line 2260
                                                                                                                                                        tmp___149 = strcmp((char const   *)args[1],
                                                                                                                                                                           (char const   *)"Event");
#line 2260
                                                                                                                                                        if (tmp___149) {
#line 2266
                                                                                                                                                          tmp___148 = strcmp((char const   *)args[1],
                                                                                                                                                                             (char const   *)"Site");
#line 2266
                                                                                                                                                          if (tmp___148) {
#line 2272
                                                                                                                                                            tmp___147 = strcmp((char const   *)args[1],
                                                                                                                                                                               (char const   *)"Round");
#line 2272
                                                                                                                                                            if (tmp___147) {
#line 2275
                                                                                                                                                              tmp___146 = strcmp((char const   *)args[1],
                                                                                                                                                                                 (char const   *)"White");
#line 2275
                                                                                                                                                              if (tmp___146) {
#line 2281
                                                                                                                                                                tmp___145 = strcmp((char const   *)args[1],
                                                                                                                                                                                   (char const   *)"WhiteElo");
#line 2281
                                                                                                                                                                if (tmp___145) {
#line 2284
                                                                                                                                                                  tmp___144 = strcmp((char const   *)args[1],
                                                                                                                                                                                     (char const   *)"Black");
#line 2284
                                                                                                                                                                  if (tmp___144) {
#line 2290
                                                                                                                                                                    tmp___143 = strcmp((char const   *)args[1],
                                                                                                                                                                                       (char const   *)"BlackElo");
#line 2290
                                                                                                                                                                    if (! tmp___143) {
#line 2291
                                                                                                                                                                      pgn_black_elo[0] = (char)0;
#line 2292
                                                                                                                                                                      strcpy(pgn_black_elo,
                                                                                                                                                                             (char const   *)args[2]);
                                                                                                                                                                    }
                                                                                                                                                                  } else {
#line 2285
                                                                                                                                                                    pgn_black[0] = (char)0;
#line 2286
                                                                                                                                                                    i___9 = 2;
                                                                                                                                                                    {
#line 2286
                                                                                                                                                                    while (1) {
                                                                                                                                                                      while_continue___47: /* CIL Label */ ;
#line 2286
                                                                                                                                                                      if (! (i___9 < nargs)) {
#line 2286
                                                                                                                                                                        goto while_break___47;
                                                                                                                                                                      }
#line 2287
                                                                                                                                                                      tmp___141 = strlen((char const   *)(pgn_black));
#line 2287
                                                                                                                                                                      strcpy(pgn_black + tmp___141,
                                                                                                                                                                             (char const   *)args[i___9]);
#line 2288
                                                                                                                                                                      tmp___142 = strlen((char const   *)(pgn_black));
#line 2288
                                                                                                                                                                      strcpy(pgn_black + tmp___142,
                                                                                                                                                                             (char const   *)" ");
#line 2286
                                                                                                                                                                      i___9 ++;
                                                                                                                                                                    }
                                                                                                                                                                    while_break___47: /* CIL Label */ ;
                                                                                                                                                                    }
                                                                                                                                                                  }
                                                                                                                                                                } else {
#line 2282
                                                                                                                                                                  pgn_white_elo[0] = (char)0;
#line 2283
                                                                                                                                                                  strcpy(pgn_white_elo,
                                                                                                                                                                         (char const   *)args[2]);
                                                                                                                                                                }
                                                                                                                                                              } else {
#line 2276
                                                                                                                                                                pgn_white[0] = (char)0;
#line 2277
                                                                                                                                                                i___9 = 2;
                                                                                                                                                                {
#line 2277
                                                                                                                                                                while (1) {
                                                                                                                                                                  while_continue___48: /* CIL Label */ ;
#line 2277
                                                                                                                                                                  if (! (i___9 < nargs)) {
#line 2277
                                                                                                                                                                    goto while_break___48;
                                                                                                                                                                  }
#line 2278
                                                                                                                                                                  tmp___139 = strlen((char const   *)(pgn_white));
#line 2278
                                                                                                                                                                  strcpy(pgn_white + tmp___139,
                                                                                                                                                                         (char const   *)args[i___9]);
#line 2279
                                                                                                                                                                  tmp___140 = strlen((char const   *)(pgn_white));
#line 2279
                                                                                                                                                                  strcpy(pgn_white + tmp___140,
                                                                                                                                                                         (char const   *)" ");
#line 2277
                                                                                                                                                                  i___9 ++;
                                                                                                                                                                }
                                                                                                                                                                while_break___48: /* CIL Label */ ;
                                                                                                                                                                }
                                                                                                                                                              }
                                                                                                                                                            } else {
#line 2273
                                                                                                                                                              pgn_round[0] = (char)0;
#line 2274
                                                                                                                                                              strcpy(pgn_round,
                                                                                                                                                                     (char const   *)args[2]);
                                                                                                                                                            }
                                                                                                                                                          } else {
#line 2267
                                                                                                                                                            pgn_site[0] = (char)0;
#line 2268
                                                                                                                                                            i___9 = 2;
                                                                                                                                                            {
#line 2268
                                                                                                                                                            while (1) {
                                                                                                                                                              while_continue___49: /* CIL Label */ ;
#line 2268
                                                                                                                                                              if (! (i___9 < nargs)) {
#line 2268
                                                                                                                                                                goto while_break___49;
                                                                                                                                                              }
#line 2269
                                                                                                                                                              tmp___137 = strlen((char const   *)(pgn_site));
#line 2269
                                                                                                                                                              strcpy(pgn_site + tmp___137,
                                                                                                                                                                     (char const   *)args[i___9]);
#line 2270
                                                                                                                                                              tmp___138 = strlen((char const   *)(pgn_site));
#line 2270
                                                                                                                                                              strcpy(pgn_site + tmp___138,
                                                                                                                                                                     (char const   *)" ");
#line 2268
                                                                                                                                                              i___9 ++;
                                                                                                                                                            }
                                                                                                                                                            while_break___49: /* CIL Label */ ;
                                                                                                                                                            }
                                                                                                                                                          }
                                                                                                                                                        } else {
#line 2261
                                                                                                                                                          pgn_event[0] = (char)0;
#line 2262
                                                                                                                                                          i___9 = 2;
                                                                                                                                                          {
#line 2262
                                                                                                                                                          while (1) {
                                                                                                                                                            while_continue___50: /* CIL Label */ ;
#line 2262
                                                                                                                                                            if (! (i___9 < nargs)) {
#line 2262
                                                                                                                                                              goto while_break___50;
                                                                                                                                                            }
#line 2263
                                                                                                                                                            tmp___135 = strlen((char const   *)(pgn_event));
#line 2263
                                                                                                                                                            strcpy(pgn_event + tmp___135,
                                                                                                                                                                   (char const   *)args[i___9]);
#line 2264
                                                                                                                                                            tmp___136 = strlen((char const   *)(pgn_event));
#line 2264
                                                                                                                                                            strcpy(pgn_event + tmp___136,
                                                                                                                                                                   (char const   *)" ");
#line 2262
                                                                                                                                                            i___9 ++;
                                                                                                                                                          }
                                                                                                                                                          while_break___50: /* CIL Label */ ;
                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                                                                      } else {
#line 2304
                                                                                                                                                        tmp___324 = OptionMatch("ping",
                                                                                                                                                                                args[0]);
#line 2304
                                                                                                                                                        if (tmp___324) {
#line 2305
                                                                                                                                                          if (pondering) {
#line 2306
                                                                                                                                                            Print(-1,
                                                                                                                                                                  "pong %s\n",
                                                                                                                                                                  args[1]);
                                                                                                                                                          } else {
#line 2308
                                                                                                                                                            pong = atoi((char const   *)args[1]);
                                                                                                                                                          }
                                                                                                                                                        } else {
#line 2319
                                                                                                                                                          tmp___323 = OptionMatch("playother",
                                                                                                                                                                                  args[0]);
#line 2319
                                                                                                                                                          if (tmp___323) {
#line 2320
                                                                                                                                                            force = 0;
                                                                                                                                                          } else {
#line 2330
                                                                                                                                                            tmp___322 = OptionMatch("ponder",
                                                                                                                                                                                    args[0]);
#line 2330
                                                                                                                                                            if (tmp___322) {
#line 2331
                                                                                                                                                              if (thinking) {
#line 2331
                                                                                                                                                                goto _L___38;
                                                                                                                                                              } else
#line 2331
                                                                                                                                                              if (pondering) {
                                                                                                                                                                _L___38: /* CIL Label */ 
#line 2332
                                                                                                                                                                return (2);
                                                                                                                                                              }
#line 2333
                                                                                                                                                              if (nargs < 2) {
#line 2334
                                                                                                                                                                printf((char const   *)"usage:  ponder off|on|<move>\n");
#line 2335
                                                                                                                                                                return (1);
                                                                                                                                                              }
#line 2337
                                                                                                                                                              tmp___151 = strcmp((char const   *)args[1],
                                                                                                                                                                                 (char const   *)"on");
#line 2337
                                                                                                                                                              if (tmp___151) {
#line 2340
                                                                                                                                                                tmp___150 = strcmp((char const   *)args[1],
                                                                                                                                                                                   (char const   *)"off");
#line 2340
                                                                                                                                                                if (tmp___150) {
#line 2344
                                                                                                                                                                  ponder_move = InputMove(tree,
                                                                                                                                                                                          0,
                                                                                                                                                                                          game_wtm,
                                                                                                                                                                                          0,
                                                                                                                                                                                          0,
                                                                                                                                                                                          args[1]);
#line 2345
                                                                                                                                                                  last_pv.pathd = 0;
#line 2346
                                                                                                                                                                  last_pv.pathl = 0;
                                                                                                                                                                } else {
#line 2341
                                                                                                                                                                  ponder = 0;
#line 2342
                                                                                                                                                                  Print(32,
                                                                                                                                                                        "pondering disabled.\n");
                                                                                                                                                                }
                                                                                                                                                              } else {
#line 2338
                                                                                                                                                                ponder = 1;
#line 2339
                                                                                                                                                                Print(32,
                                                                                                                                                                      "pondering enabled.\n");
                                                                                                                                                              }
                                                                                                                                                            } else {
#line 2357
                                                                                                                                                              tmp___321 = OptionMatch("post",
                                                                                                                                                                                      args[0]);
#line 2357
                                                                                                                                                              if (tmp___321) {
#line 2358
                                                                                                                                                                post = 1;
                                                                                                                                                              } else {
#line 2359
                                                                                                                                                                tmp___320 = OptionMatch("nopost",
                                                                                                                                                                                        args[0]);
#line 2359
                                                                                                                                                                if (tmp___320) {
#line 2360
                                                                                                                                                                  post = 0;
                                                                                                                                                                } else {
#line 2371
                                                                                                                                                                  tmp___319 = OptionMatch("protover",
                                                                                                                                                                                          args[0]);
#line 2371
                                                                                                                                                                  if (tmp___319) {
#line 2372
                                                                                                                                                                    tmp___152 = atoi((char const   *)args[1]);
#line 2372
                                                                                                                                                                    pversion = tmp___152;
#line 2374
                                                                                                                                                                    if (pversion >= 1) {
#line 2374
                                                                                                                                                                      if (pversion <= 3) {
#line 2375
                                                                                                                                                                        if (pversion >= 2) {
#line 2376
                                                                                                                                                                          Print(-1,
                                                                                                                                                                                "feature ping=1 setboard=1 san=1 time=1 draw=1\n");
#line 2377
                                                                                                                                                                          Print(-1,
                                                                                                                                                                                "feature sigint=0 sigterm=0 reuse=0 analyze=1\n");
#line 2378
                                                                                                                                                                          Print(-1,
                                                                                                                                                                                "feature myname=\"Crafty-%s\" name=1\n",
                                                                                                                                                                                version);
#line 2379
                                                                                                                                                                          Print(-1,
                                                                                                                                                                                "feature playother=1 colors=0 memory=%d\n",
                                                                                                                                                                                allow_memory);
#line 2381
                                                                                                                                                                          Print(-1,
                                                                                                                                                                                "feature smp=%d\n",
                                                                                                                                                                                allow_cores);
#line 2383
                                                                                                                                                                          Print(-1,
                                                                                                                                                                                "feature variants=\"normal,nocastle\"\n");
#line 2384
                                                                                                                                                                          Print(-1,
                                                                                                                                                                                "feature done=1\n");
#line 2385
                                                                                                                                                                          xboard_done = 1;
                                                                                                                                                                        }
                                                                                                                                                                      } else {
#line 2374
                                                                                                                                                                        goto _L___39;
                                                                                                                                                                      }
                                                                                                                                                                    } else {
                                                                                                                                                                      _L___39: /* CIL Label */ 
#line 2388
                                                                                                                                                                      Print(4095,
                                                                                                                                                                            "ERROR, bogus xboard protocol version received.\n");
                                                                                                                                                                    }
                                                                                                                                                                  } else {
#line 2397
                                                                                                                                                                    tmp___318 = OptionMatch("random",
                                                                                                                                                                                            args[0]);
#line 2397
                                                                                                                                                                    if (tmp___318) {
#line 2398
                                                                                                                                                                      return (xboard);
                                                                                                                                                                    } else {
#line 2409
                                                                                                                                                                      tmp___317 = OptionMatch("rating",
                                                                                                                                                                                              args[0]);
#line 2409
                                                                                                                                                                      if (tmp___317) {
#line 2412
                                                                                                                                                                        if (nargs < 3) {
#line 2413
                                                                                                                                                                          printf((char const   *)"usage:  rating <Crafty> <opponent>\n");
#line 2414
                                                                                                                                                                          return (1);
                                                                                                                                                                        }
#line 2416
                                                                                                                                                                        crafty_rating = atoi((char const   *)args[1]);
#line 2417
                                                                                                                                                                        opponent_rating = atoi((char const   *)args[2]);
#line 2418
                                                                                                                                                                        if (crafty_rating == 0) {
#line 2418
                                                                                                                                                                          if (opponent_rating == 0) {
#line 2419
                                                                                                                                                                            crafty_rating = 2500;
#line 2420
                                                                                                                                                                            opponent_rating = 2300;
                                                                                                                                                                          } else {
#line 2418
                                                                                                                                                                            goto _L___40;
                                                                                                                                                                          }
                                                                                                                                                                        } else {
                                                                                                                                                                          _L___40: /* CIL Label */ ;
                                                                                                                                                                        }
#line 2422
                                                                                                                                                                        if (dynamic_draw_score) {
#line 2423
                                                                                                                                                                          rd = opponent_rating - crafty_rating;
#line 2424
                                                                                                                                                                          if (rd < 300) {
#line 2424
                                                                                                                                                                            tmp___155 = rd;
                                                                                                                                                                          } else {
#line 2424
                                                                                                                                                                            tmp___155 = 300;
                                                                                                                                                                          }
#line 2424
                                                                                                                                                                          if (tmp___155 > -300) {
#line 2424
                                                                                                                                                                            if (rd < 300) {
#line 2424
                                                                                                                                                                              tmp___154 = rd;
                                                                                                                                                                            } else {
#line 2424
                                                                                                                                                                              tmp___154 = 300;
                                                                                                                                                                            }
#line 2424
                                                                                                                                                                            rd = tmp___154;
                                                                                                                                                                          } else {
#line 2424
                                                                                                                                                                            rd = -300;
                                                                                                                                                                          }
#line 2425
                                                                                                                                                                          abs_draw_score = rd / 8;
#line 2426
                                                                                                                                                                          if (log_file) {
#line 2427
                                                                                                                                                                            fprintf(log_file,
                                                                                                                                                                                    (char const   *)"Crafty\'s rating: %d.\n",
                                                                                                                                                                                    crafty_rating);
#line 2428
                                                                                                                                                                            fprintf(log_file,
                                                                                                                                                                                    (char const   *)"opponent\'s rating: %d.\n",
                                                                                                                                                                                    opponent_rating);
#line 2429
                                                                                                                                                                            fprintf(log_file,
                                                                                                                                                                                    (char const   *)"draw score: %d.\n",
                                                                                                                                                                                    abs_draw_score);
                                                                                                                                                                          }
                                                                                                                                                                        }
                                                                                                                                                                      } else {
#line 2442
                                                                                                                                                                        tmp___316 = OptionMatch("remove",
                                                                                                                                                                                                args[0]);
#line 2442
                                                                                                                                                                        if (tmp___316) {
#line 2443
                                                                                                                                                                          if (thinking) {
#line 2443
                                                                                                                                                                            goto _L___41;
                                                                                                                                                                          } else
#line 2443
                                                                                                                                                                          if (pondering) {
                                                                                                                                                                            _L___41: /* CIL Label */ 
#line 2444
                                                                                                                                                                            return (2);
                                                                                                                                                                          }
#line 2445
                                                                                                                                                                          move_number --;
#line 2446
                                                                                                                                                                          sprintf(buffer,
                                                                                                                                                                                  (char const   *)"reset %d",
                                                                                                                                                                                  move_number);
#line 2447
                                                                                                                                                                          Option(tree);
                                                                                                                                                                        } else {
#line 2465
                                                                                                                                                                          tmp___314 = OptionMatch("read",
                                                                                                                                                                                                  args[0]);
#line 2465
                                                                                                                                                                          if (tmp___314) {
#line 2465
                                                                                                                                                                            goto _L___72;
                                                                                                                                                                          } else {
#line 2465
                                                                                                                                                                            tmp___315 = OptionMatch("reada",
                                                                                                                                                                                                    args[0]);
#line 2465
                                                                                                                                                                            if (tmp___315) {
                                                                                                                                                                              _L___72: /* CIL Label */ 
#line 2466
                                                                                                                                                                              read_input = (FILE *)0;
#line 2469
                                                                                                                                                                              if (thinking) {
#line 2469
                                                                                                                                                                                goto _L___42;
                                                                                                                                                                              } else
#line 2469
                                                                                                                                                                              if (pondering) {
                                                                                                                                                                                _L___42: /* CIL Label */ 
#line 2470
                                                                                                                                                                                return (2);
                                                                                                                                                                              }
#line 2471
                                                                                                                                                                              nargs = ReadParse(buffer,
                                                                                                                                                                                                args,
                                                                                                                                                                                                " \t=");
#line 2472
                                                                                                                                                                              tmp___156 = strcmp((char const   *)"reada",
                                                                                                                                                                                                 (char const   *)args[0]);
#line 2472
                                                                                                                                                                              if (tmp___156) {
#line 2475
                                                                                                                                                                                append = 0;
                                                                                                                                                                              } else {
#line 2473
                                                                                                                                                                                append = 1;
                                                                                                                                                                              }
#line 2476
                                                                                                                                                                              ponder_move = 0;
#line 2477
                                                                                                                                                                              last_pv.pathd = 0;
#line 2478
                                                                                                                                                                              last_pv.pathl = 0;
#line 2479
                                                                                                                                                                              if (nargs > 1) {
#line 2480
                                                                                                                                                                                read_input = fopen((char const   * __restrict  )args[1],
                                                                                                                                                                                                   (char const   * __restrict  )"r");
#line 2480
                                                                                                                                                                                if (! read_input) {
#line 2481
                                                                                                                                                                                  printf((char const   *)"file %s does not exist.\n",
                                                                                                                                                                                         args[1]);
#line 2482
                                                                                                                                                                                  return (1);
                                                                                                                                                                                }
                                                                                                                                                                              } else {
#line 2485
                                                                                                                                                                                printf((char const   *)"type \"exit\" to terminate.\n");
#line 2486
                                                                                                                                                                                read_input = stdin;
                                                                                                                                                                              }
#line 2488
                                                                                                                                                                              if (! append) {
#line 2489
                                                                                                                                                                                InitializeChessBoard(tree);
#line 2490
                                                                                                                                                                                game_wtm = 1;
#line 2491
                                                                                                                                                                                move_number = 1;
#line 2492
                                                                                                                                                                                tc_moves_remaining[1] = tc_moves;
#line 2493
                                                                                                                                                                                tc_moves_remaining[0] = tc_moves;
                                                                                                                                                                              }
#line 2498
                                                                                                                                                                              readstat___1 = ReadPGN((FILE *)0,
                                                                                                                                                                                                     0);
                                                                                                                                                                              {
#line 2499
                                                                                                                                                                              while (1) {
                                                                                                                                                                                while_continue___51: /* CIL Label */ ;
#line 2500
                                                                                                                                                                                if ((unsigned long )read_input == (unsigned long )stdin) {
#line 2501
                                                                                                                                                                                  if (game_wtm) {
#line 2502
                                                                                                                                                                                    printf((char const   *)"read.White(%d): ",
                                                                                                                                                                                           move_number);
                                                                                                                                                                                  } else {
#line 2504
                                                                                                                                                                                    printf((char const   *)"read.Black(%d): ",
                                                                                                                                                                                           move_number);
                                                                                                                                                                                  }
#line 2505
                                                                                                                                                                                  fflush(stdout);
                                                                                                                                                                                }
#line 2507
                                                                                                                                                                                readstat___1 = ReadPGN(read_input,
                                                                                                                                                                                                       0);
#line 2499
                                                                                                                                                                                if (! (readstat___1 == 1)) {
#line 2499
                                                                                                                                                                                  goto while_break___51;
                                                                                                                                                                                }
                                                                                                                                                                              }
                                                                                                                                                                              while_break___51: /* CIL Label */ ;
                                                                                                                                                                              }
#line 2509
                                                                                                                                                                              if (readstat___1 < 0) {
#line 2510
                                                                                                                                                                                return (1);
                                                                                                                                                                              }
                                                                                                                                                                              {
#line 2514
                                                                                                                                                                              while (1) {
                                                                                                                                                                                while_continue___52: /* CIL Label */ ;
#line 2515
                                                                                                                                                                                move___0 = 0;
#line 2516
                                                                                                                                                                                move___0 = ReadNextMove(tree,
                                                                                                                                                                                                        buffer,
                                                                                                                                                                                                        0,
                                                                                                                                                                                                        game_wtm);
#line 2517
                                                                                                                                                                                if (move___0) {
#line 2518
                                                                                                                                                                                  if ((unsigned long )read_input != (unsigned long )stdin) {
#line 2519
                                                                                                                                                                                    tmp___157 = OutputMove(tree,
                                                                                                                                                                                                           0,
                                                                                                                                                                                                           game_wtm,
                                                                                                                                                                                                           move___0);
#line 2519
                                                                                                                                                                                    printf((char const   *)"%s ",
                                                                                                                                                                                           tmp___157);
#line 2520
                                                                                                                                                                                    if (! (move_number % 8)) {
#line 2520
                                                                                                                                                                                      if (game_wtm ^ 1) {
#line 2521
                                                                                                                                                                                        printf((char const   *)"\n");
                                                                                                                                                                                      } else {
#line 2520
                                                                                                                                                                                        goto _L___43;
                                                                                                                                                                                      }
                                                                                                                                                                                    } else {
                                                                                                                                                                                      _L___43: /* CIL Label */ ;
                                                                                                                                                                                    }
                                                                                                                                                                                  }
#line 2523
                                                                                                                                                                                  fseek(history_file,
                                                                                                                                                                                        (long )((((move_number - 1) * 2 + 1) - game_wtm) * 10),
                                                                                                                                                                                        0);
#line 2525
                                                                                                                                                                                  tmp___158 = OutputMove(tree,
                                                                                                                                                                                                         0,
                                                                                                                                                                                                         game_wtm,
                                                                                                                                                                                                         move___0);
#line 2525
                                                                                                                                                                                  fprintf(history_file,
                                                                                                                                                                                          (char const   *)"%9s\n",
                                                                                                                                                                                          tmp___158);
#line 2526
                                                                                                                                                                                  MakeMoveRoot(tree,
                                                                                                                                                                                               game_wtm,
                                                                                                                                                                                               move___0);
#line 2527
                                                                                                                                                                                  TimeAdjust(game_wtm,
                                                                                                                                                                                             0);
                                                                                                                                                                                } else
#line 2531
                                                                                                                                                                                if (! read_input) {
#line 2532
                                                                                                                                                                                  printf((char const   *)"illegal move.\n");
                                                                                                                                                                                }
#line 2533
                                                                                                                                                                                if (move___0) {
#line 2534
                                                                                                                                                                                  game_wtm ^= 1;
#line 2535
                                                                                                                                                                                  if (game_wtm) {
#line 2536
                                                                                                                                                                                    move_number ++;
                                                                                                                                                                                  }
                                                                                                                                                                                }
#line 2538
                                                                                                                                                                                if ((unsigned long )read_input == (unsigned long )stdin) {
#line 2539
                                                                                                                                                                                  if (game_wtm) {
#line 2540
                                                                                                                                                                                    printf((char const   *)"read.White(%d): ",
                                                                                                                                                                                           move_number);
                                                                                                                                                                                  } else {
#line 2542
                                                                                                                                                                                    printf((char const   *)"read.Black(%d): ",
                                                                                                                                                                                           move_number);
                                                                                                                                                                                  }
#line 2543
                                                                                                                                                                                  fflush(stdout);
                                                                                                                                                                                }
#line 2545
                                                                                                                                                                                readstat___1 = ReadPGN(read_input,
                                                                                                                                                                                                       0);
#line 2546
                                                                                                                                                                                if (readstat___1 < 0) {
#line 2547
                                                                                                                                                                                  goto while_break___52;
                                                                                                                                                                                }
#line 2548
                                                                                                                                                                                tmp___159 = strcmp((char const   *)(buffer),
                                                                                                                                                                                                   (char const   *)"exit");
#line 2548
                                                                                                                                                                                if (! tmp___159) {
#line 2549
                                                                                                                                                                                  goto while_break___52;
                                                                                                                                                                                }
#line 2514
                                                                                                                                                                                if (! 1) {
#line 2514
                                                                                                                                                                                  goto while_break___52;
                                                                                                                                                                                }
                                                                                                                                                                              }
                                                                                                                                                                              while_break___52: /* CIL Label */ ;
                                                                                                                                                                              }
#line 2551
                                                                                                                                                                              moves_out_of_book = 0;
#line 2552
                                                                                                                                                                              printf((char const   *)"NOTICE: %d moves to next time control\n",
                                                                                                                                                                                     tc_moves_remaining[root_wtm]);
#line 2554
                                                                                                                                                                              root_wtm = ! game_wtm;
#line 2555
                                                                                                                                                                              if ((unsigned long )read_input != (unsigned long )stdin) {
#line 2556
                                                                                                                                                                                printf((char const   *)"\n");
#line 2557
                                                                                                                                                                                fclose(read_input);
                                                                                                                                                                              }
                                                                                                                                                                            } else {
#line 2568
                                                                                                                                                                              tmp___313 = OptionMatch("rejected",
                                                                                                                                                                                                      args[0]);
#line 2568
                                                                                                                                                                              if (tmp___313) {
#line 2569
                                                                                                                                                                                Print(4095,
                                                                                                                                                                                      "ERROR.  feature %s rejected by xboard\n",
                                                                                                                                                                                      args[1]);
                                                                                                                                                                              } else {
#line 2582
                                                                                                                                                                                tmp___312 = OptionMatch("reset",
                                                                                                                                                                                                        args[0]);
#line 2582
                                                                                                                                                                                if (tmp___312) {
#line 2585
                                                                                                                                                                                  if (! history_file) {
#line 2586
                                                                                                                                                                                    return (1);
                                                                                                                                                                                  }
#line 2587
                                                                                                                                                                                  if (thinking) {
#line 2587
                                                                                                                                                                                    goto _L___44;
                                                                                                                                                                                  } else
#line 2587
                                                                                                                                                                                  if (pondering) {
                                                                                                                                                                                    _L___44: /* CIL Label */ 
#line 2588
                                                                                                                                                                                    return (2);
                                                                                                                                                                                  }
#line 2589
                                                                                                                                                                                  if (nargs < 2) {
#line 2590
                                                                                                                                                                                    printf((char const   *)"usage:  reset <movenumber>\n");
#line 2591
                                                                                                                                                                                    return (1);
                                                                                                                                                                                  }
#line 2593
                                                                                                                                                                                  ponder_move = 0;
#line 2594
                                                                                                                                                                                  last_mate_score = 0;
#line 2595
                                                                                                                                                                                  last_pv.pathd = 0;
#line 2596
                                                                                                                                                                                  last_pv.pathl = 0;
#line 2597
                                                                                                                                                                                  if (thinking) {
#line 2597
                                                                                                                                                                                    goto _L___45;
                                                                                                                                                                                  } else
#line 2597
                                                                                                                                                                                  if (pondering) {
                                                                                                                                                                                    _L___45: /* CIL Label */ 
#line 2598
                                                                                                                                                                                    return (2);
                                                                                                                                                                                  }
#line 2599
                                                                                                                                                                                  over = 0;
#line 2600
                                                                                                                                                                                  move_number = atoi((char const   *)args[1]);
#line 2601
                                                                                                                                                                                  if (! move_number) {
#line 2602
                                                                                                                                                                                    move_number = 1;
#line 2603
                                                                                                                                                                                    return (1);
                                                                                                                                                                                  }
#line 2605
                                                                                                                                                                                  nmoves = ((move_number - 1) * 2 + 1) - game_wtm;
#line 2606
                                                                                                                                                                                  root_wtm = game_wtm ^ 1;
#line 2607
                                                                                                                                                                                  InitializeChessBoard(tree);
#line 2608
                                                                                                                                                                                  game_wtm = 1;
#line 2609
                                                                                                                                                                                  move_number = 1;
#line 2610
                                                                                                                                                                                  tc_moves_remaining[1] = tc_moves;
#line 2611
                                                                                                                                                                                  tc_moves_remaining[0] = tc_moves;
#line 2612
                                                                                                                                                                                  i___10 = 0;
                                                                                                                                                                                  {
#line 2612
                                                                                                                                                                                  while (1) {
                                                                                                                                                                                    while_continue___53: /* CIL Label */ ;
#line 2612
                                                                                                                                                                                    if (! (i___10 < nmoves)) {
#line 2612
                                                                                                                                                                                      goto while_break___53;
                                                                                                                                                                                    }
#line 2613
                                                                                                                                                                                    fseek(history_file,
                                                                                                                                                                                          (long )(i___10 * 10),
                                                                                                                                                                                          0);
#line 2614
                                                                                                                                                                                    v = fscanf(history_file,
                                                                                                                                                                                               (char const   *)"%s",
                                                                                                                                                                                               buffer);
#line 2615
                                                                                                                                                                                    if (v <= 0) {
#line 2616
                                                                                                                                                                                      perror((char const   *)"Option() fscanf error: ");
                                                                                                                                                                                    }
#line 2622
                                                                                                                                                                                    tmp___160 = strcmp((char const   *)(buffer),
                                                                                                                                                                                                       (char const   *)"pass");
#line 2622
                                                                                                                                                                                    if (tmp___160 == 0) {
#line 2623
                                                                                                                                                                                      game_wtm ^= 1;
#line 2624
                                                                                                                                                                                      if (game_wtm) {
#line 2625
                                                                                                                                                                                        move_number ++;
                                                                                                                                                                                      }
#line 2626
                                                                                                                                                                                      goto __Cont___1;
                                                                                                                                                                                    }
#line 2628
                                                                                                                                                                                    move___1 = InputMove(tree,
                                                                                                                                                                                                         0,
                                                                                                                                                                                                         game_wtm,
                                                                                                                                                                                                         0,
                                                                                                                                                                                                         0,
                                                                                                                                                                                                         buffer);
#line 2629
                                                                                                                                                                                    if (move___1) {
#line 2630
                                                                                                                                                                                      MakeMoveRoot(tree,
                                                                                                                                                                                                   game_wtm,
                                                                                                                                                                                                   move___1);
                                                                                                                                                                                    } else {
#line 2632
                                                                                                                                                                                      printf((char const   *)"ERROR!  move %s is illegal\n",
                                                                                                                                                                                             buffer);
#line 2633
                                                                                                                                                                                      goto while_break___53;
                                                                                                                                                                                    }
#line 2635
                                                                                                                                                                                    TimeAdjust(game_wtm,
                                                                                                                                                                                               0);
#line 2636
                                                                                                                                                                                    game_wtm ^= 1;
#line 2637
                                                                                                                                                                                    if (game_wtm) {
#line 2638
                                                                                                                                                                                      move_number ++;
                                                                                                                                                                                    }
                                                                                                                                                                                    __Cont___1: /* CIL Label */ 
#line 2612
                                                                                                                                                                                    i___10 ++;
                                                                                                                                                                                  }
                                                                                                                                                                                  while_break___53: /* CIL Label */ ;
                                                                                                                                                                                  }
#line 2640
                                                                                                                                                                                  moves_out_of_book = 0;
#line 2641
                                                                                                                                                                                  printf((char const   *)"NOTICE: %d moves to next time control\n",
                                                                                                                                                                                         tc_moves_remaining[root_wtm]);
                                                                                                                                                                                } else {
#line 2655
                                                                                                                                                                                  tmp___311 = OptionMatch("resign",
                                                                                                                                                                                                          args[0]);
#line 2655
                                                                                                                                                                                  if (tmp___311) {
#line 2656
                                                                                                                                                                                    if (nargs < 2) {
#line 2657
                                                                                                                                                                                      if (crafty_is_white) {
#line 2658
                                                                                                                                                                                        Print(4095,
                                                                                                                                                                                              "result 1-0\n");
#line 2659
                                                                                                                                                                                        strcpy(pgn_result,
                                                                                                                                                                                               (char const   *)"1-0");
                                                                                                                                                                                      } else {
#line 2661
                                                                                                                                                                                        Print(4095,
                                                                                                                                                                                              "result 0-1\n");
#line 2662
                                                                                                                                                                                        strcpy(pgn_result,
                                                                                                                                                                                               (char const   *)"0-1");
                                                                                                                                                                                      }
#line 2664
                                                                                                                                                                                      learn_value = 300;
#line 2665
                                                                                                                                                                                      LearnBook();
#line 2666
                                                                                                                                                                                      return (1);
                                                                                                                                                                                    }
#line 2668
                                                                                                                                                                                    resign = atoi((char const   *)args[1]);
#line 2669
                                                                                                                                                                                    if (nargs == 3) {
#line 2670
                                                                                                                                                                                      resign_count = atoi((char const   *)args[2]);
                                                                                                                                                                                    }
#line 2671
                                                                                                                                                                                    if (resign) {
#line 2672
                                                                                                                                                                                      Print(32,
                                                                                                                                                                                            "resign after %d consecutive moves with score < %d.\n",
                                                                                                                                                                                            resign_count,
                                                                                                                                                                                            - resign);
                                                                                                                                                                                    } else {
#line 2675
                                                                                                                                                                                      Print(32,
                                                                                                                                                                                            "disabled resignations.\n");
                                                                                                                                                                                    }
                                                                                                                                                                                  } else {
#line 2686
                                                                                                                                                                                    tmp___310 = OptionMatch("result",
                                                                                                                                                                                                            args[0]);
#line 2686
                                                                                                                                                                                    if (tmp___310) {
#line 2687
                                                                                                                                                                                      if (nargs > 1) {
#line 2688
                                                                                                                                                                                        tmp___163 = strcmp((char const   *)args[1],
                                                                                                                                                                                                           (char const   *)"1-0");
#line 2688
                                                                                                                                                                                        if (tmp___163) {
#line 2694
                                                                                                                                                                                          tmp___162 = strcmp((char const   *)args[1],
                                                                                                                                                                                                             (char const   *)"0-1");
#line 2694
                                                                                                                                                                                          if (tmp___162) {
#line 2700
                                                                                                                                                                                            tmp___161 = strcmp((char const   *)args[1],
                                                                                                                                                                                                               (char const   *)"1/2-1/2");
#line 2700
                                                                                                                                                                                            if (! tmp___161) {
#line 2701
                                                                                                                                                                                              strcpy(pgn_result,
                                                                                                                                                                                                     (char const   *)"1/2-1/2");
#line 2702
                                                                                                                                                                                              learn_value = 1;
                                                                                                                                                                                            }
                                                                                                                                                                                          } else {
#line 2695
                                                                                                                                                                                            strcpy(pgn_result,
                                                                                                                                                                                                   (char const   *)"0-1");
#line 2696
                                                                                                                                                                                            if (crafty_is_white) {
#line 2697
                                                                                                                                                                                              learn_value = -300;
                                                                                                                                                                                            } else {
#line 2699
                                                                                                                                                                                              learn_value = 300;
                                                                                                                                                                                            }
                                                                                                                                                                                          }
                                                                                                                                                                                        } else {
#line 2689
                                                                                                                                                                                          strcpy(pgn_result,
                                                                                                                                                                                                 (char const   *)"1-0");
#line 2690
                                                                                                                                                                                          if (crafty_is_white) {
#line 2691
                                                                                                                                                                                            learn_value = 300;
                                                                                                                                                                                          } else {
#line 2693
                                                                                                                                                                                            learn_value = -300;
                                                                                                                                                                                          }
                                                                                                                                                                                        }
#line 2704
                                                                                                                                                                                        LearnBook();
#line 2705
                                                                                                                                                                                        return (1);
                                                                                                                                                                                      }
                                                                                                                                                                                    } else {
#line 2718
                                                                                                                                                                                      tmp___309 = OptionMatch("safety",
                                                                                                                                                                                                              args[0]);
#line 2718
                                                                                                                                                                                      if (tmp___309) {
#line 2719
                                                                                                                                                                                        if (nargs == 2) {
#line 2720
                                                                                                                                                                                          tmp___164 = atoi((char const   *)args[1]);
#line 2720
                                                                                                                                                                                          tc_safety_margin = tmp___164 * 100;
                                                                                                                                                                                        }
#line 2721
                                                                                                                                                                                        tmp___165 = DisplayTime((unsigned int )tc_safety_margin);
#line 2721
                                                                                                                                                                                        Print(32,
                                                                                                                                                                                              "safety margin set to %s.\n",
                                                                                                                                                                                              tmp___165);
                                                                                                                                                                                      } else {
#line 2731
                                                                                                                                                                                        tmp___308 = OptionMatch("savegame",
                                                                                                                                                                                                                args[0]);
#line 2731
                                                                                                                                                                                        if (tmp___308) {
#line 2738
                                                                                                                                                                                          output_file = stdout;
#line 2739
                                                                                                                                                                                          secs = time((time_t *)0);
#line 2740
                                                                                                                                                                                          timestruct = localtime((time_t const   *)(& secs));
#line 2741
                                                                                                                                                                                          if (nargs > 1) {
#line 2742
                                                                                                                                                                                            output_file = fopen((char const   * __restrict  )args[1],
                                                                                                                                                                                                                (char const   * __restrict  )"w");
#line 2742
                                                                                                                                                                                            if (! output_file) {
#line 2743
                                                                                                                                                                                              printf((char const   *)"unable to open %s for write.\n",
                                                                                                                                                                                                     args[1]);
#line 2744
                                                                                                                                                                                              return (1);
                                                                                                                                                                                            }
                                                                                                                                                                                          }
#line 2747
                                                                                                                                                                                          fprintf(output_file,
                                                                                                                                                                                                  (char const   *)"[Event \"%s\"]\n",
                                                                                                                                                                                                  pgn_event);
#line 2748
                                                                                                                                                                                          fprintf(output_file,
                                                                                                                                                                                                  (char const   *)"[Site \"%s\"]\n",
                                                                                                                                                                                                  pgn_site);
#line 2749
                                                                                                                                                                                          fprintf(output_file,
                                                                                                                                                                                                  (char const   *)"[Date \"%4d.%02d.%02d\"]\n",
                                                                                                                                                                                                  timestruct->tm_year + 1900,
                                                                                                                                                                                                  timestruct->tm_mon + 1,
                                                                                                                                                                                                  timestruct->tm_mday);
#line 2752
                                                                                                                                                                                          fprintf(output_file,
                                                                                                                                                                                                  (char const   *)"[Round \"%s\"]\n",
                                                                                                                                                                                                  pgn_round);
#line 2753
                                                                                                                                                                                          fprintf(output_file,
                                                                                                                                                                                                  (char const   *)"[White \"%s\"]\n",
                                                                                                                                                                                                  pgn_white);
#line 2754
                                                                                                                                                                                          fprintf(output_file,
                                                                                                                                                                                                  (char const   *)"[WhiteElo \"%s\"]\n",
                                                                                                                                                                                                  pgn_white_elo);
#line 2755
                                                                                                                                                                                          fprintf(output_file,
                                                                                                                                                                                                  (char const   *)"[Black \"%s\"]\n",
                                                                                                                                                                                                  pgn_black);
#line 2756
                                                                                                                                                                                          fprintf(output_file,
                                                                                                                                                                                                  (char const   *)"[BlackElo \"%s\"]\n",
                                                                                                                                                                                                  pgn_black_elo);
#line 2757
                                                                                                                                                                                          fprintf(output_file,
                                                                                                                                                                                                  (char const   *)"[Result \"%s\"]\n",
                                                                                                                                                                                                  pgn_result);
#line 2759
                                                                                                                                                                                          swtm = 1;
#line 2760
                                                                                                                                                                                          if (move_number > 1) {
#line 2760
                                                                                                                                                                                            goto _L___47;
                                                                                                                                                                                          } else
#line 2760
                                                                                                                                                                                          if (! game_wtm) {
                                                                                                                                                                                            _L___47: /* CIL Label */ 
#line 2761
                                                                                                                                                                                            fseek(history_file,
                                                                                                                                                                                                  0L,
                                                                                                                                                                                                  0);
#line 2762
                                                                                                                                                                                            tmp___166 = fscanf(history_file,
                                                                                                                                                                                                               (char const   *)"%s",
                                                                                                                                                                                                               input);
#line 2762
                                                                                                                                                                                            if (tmp___166 == 1) {
#line 2762
                                                                                                                                                                                              tmp___167 = strcmp((char const   *)(input),
                                                                                                                                                                                                                 (char const   *)"pass");
#line 2762
                                                                                                                                                                                              if (tmp___167 == 0) {
#line 2764
                                                                                                                                                                                                swtm = 0;
                                                                                                                                                                                              } else {
#line 2762
                                                                                                                                                                                                goto _L___46;
                                                                                                                                                                                              }
                                                                                                                                                                                            } else {
                                                                                                                                                                                              _L___46: /* CIL Label */ ;
                                                                                                                                                                                            }
                                                                                                                                                                                          }
#line 2766
                                                                                                                                                                                          if (initial_position[0]) {
#line 2767
                                                                                                                                                                                            fprintf(output_file,
                                                                                                                                                                                                    (char const   *)"[FEN \"%s\"]\n[SetUp \"1\"]\n",
                                                                                                                                                                                                    initial_position);
                                                                                                                                                                                          } else
#line 2768
                                                                                                                                                                                          if (! swtm) {
#line 2769
                                                                                                                                                                                            fprintf(output_file,
                                                                                                                                                                                                    (char const   *)"[FEN \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR b KQkq - 0 1\"\n[SetUp \"1\"]\n");
                                                                                                                                                                                          }
#line 2773
                                                                                                                                                                                          fprintf(output_file,
                                                                                                                                                                                                  (char const   *)"\n");
#line 2774
                                                                                                                                                                                          next___1 = text___1;
#line 2775
                                                                                                                                                                                          if (! swtm) {
#line 2776
                                                                                                                                                                                            strcpy(next___1,
                                                                                                                                                                                                   (char const   *)"1... ");
#line 2777
                                                                                                                                                                                            tmp___168 = strlen((char const   *)(text___1));
#line 2777
                                                                                                                                                                                            next___1 = text___1 + tmp___168;
                                                                                                                                                                                          }
#line 2780
                                                                                                                                                                                          more = 0;
#line 2781
                                                                                                                                                                                          if (swtm) {
#line 2781
                                                                                                                                                                                            i___11 = 0;
                                                                                                                                                                                          } else {
#line 2781
                                                                                                                                                                                            i___11 = 1;
                                                                                                                                                                                          }
                                                                                                                                                                                          {
#line 2781
                                                                                                                                                                                          while (1) {
                                                                                                                                                                                            while_continue___54: /* CIL Label */ ;
#line 2781
                                                                                                                                                                                            if (! (i___11 < ((move_number - 1) * 2 - game_wtm) + 1)) {
#line 2781
                                                                                                                                                                                              goto while_break___54;
                                                                                                                                                                                            }
#line 2782
                                                                                                                                                                                            fseek(history_file,
                                                                                                                                                                                                  (long )(i___11 * 10),
                                                                                                                                                                                                  0);
#line 2783
                                                                                                                                                                                            v = fscanf(history_file,
                                                                                                                                                                                                       (char const   *)"%s",
                                                                                                                                                                                                       input);
#line 2784
                                                                                                                                                                                            if (v <= 0) {
#line 2785
                                                                                                                                                                                              perror((char const   *)"Option() fscanf error: ");
                                                                                                                                                                                            }
#line 2786
                                                                                                                                                                                            if (! (i___11 % 2)) {
#line 2787
                                                                                                                                                                                              sprintf(next___1,
                                                                                                                                                                                                      (char const   *)"%d. ",
                                                                                                                                                                                                      i___11 / 2 + 1);
#line 2788
                                                                                                                                                                                              tmp___169 = strlen((char const   *)(text___1));
#line 2788
                                                                                                                                                                                              next___1 = text___1 + tmp___169;
                                                                                                                                                                                            }
#line 2790
                                                                                                                                                                                            sprintf(next___1,
                                                                                                                                                                                                    (char const   *)"%s ",
                                                                                                                                                                                                    input);
#line 2791
                                                                                                                                                                                            tmp___170 = strlen((char const   *)(text___1));
#line 2791
                                                                                                                                                                                            next___1 = text___1 + tmp___170;
#line 2792
                                                                                                                                                                                            more = 1;
#line 2793
                                                                                                                                                                                            if (next___1 - text___1 >= 60L) {
#line 2794
                                                                                                                                                                                              fprintf(output_file,
                                                                                                                                                                                                      (char const   *)"%s\n",
                                                                                                                                                                                                      text___1);
#line 2795
                                                                                                                                                                                              more = 0;
#line 2796
                                                                                                                                                                                              next___1 = text___1;
                                                                                                                                                                                            }
#line 2781
                                                                                                                                                                                            i___11 ++;
                                                                                                                                                                                          }
                                                                                                                                                                                          while_break___54: /* CIL Label */ ;
                                                                                                                                                                                          }
#line 2799
                                                                                                                                                                                          if (more) {
#line 2800
                                                                                                                                                                                            fprintf(output_file,
                                                                                                                                                                                                    (char const   *)"%s",
                                                                                                                                                                                                    text___1);
                                                                                                                                                                                          }
#line 2801
                                                                                                                                                                                          fprintf(output_file,
                                                                                                                                                                                                  (char const   *)"%s\n",
                                                                                                                                                                                                  pgn_result);
#line 2802
                                                                                                                                                                                          if ((unsigned long )output_file != (unsigned long )stdout) {
#line 2803
                                                                                                                                                                                            fclose(output_file);
                                                                                                                                                                                          }
#line 2804
                                                                                                                                                                                          printf((char const   *)"PGN save complete.\n");
                                                                                                                                                                                        } else {
#line 2815
                                                                                                                                                                                          tmp___307 = OptionMatch("savepos",
                                                                                                                                                                                                                  args[0]);
#line 2815
                                                                                                                                                                                          if (tmp___307) {
#line 2819
                                                                                                                                                                                            output_file___0 = stdout;
#line 2820
                                                                                                                                                                                            if (nargs > 1) {
#line 2821
                                                                                                                                                                                              tmp___171 = strcmp((char const   *)args[1],
                                                                                                                                                                                                                 (char const   *)"*");
#line 2821
                                                                                                                                                                                              if (tmp___171) {
#line 2824
                                                                                                                                                                                                output_file___0 = fopen((char const   * __restrict  )args[1],
                                                                                                                                                                                                                        (char const   * __restrict  )"w");
#line 2824
                                                                                                                                                                                                if (! output_file___0) {
#line 2825
                                                                                                                                                                                                  printf((char const   *)"unable to open %s for write.\n",
                                                                                                                                                                                                         args[1]);
#line 2826
                                                                                                                                                                                                  return (1);
                                                                                                                                                                                                }
                                                                                                                                                                                              } else {
#line 2822
                                                                                                                                                                                                output_file___0 = (FILE *)0;
#line 2823
                                                                                                                                                                                                strcpy(initial_position,
                                                                                                                                                                                                       (char const   *)"");
                                                                                                                                                                                              }
                                                                                                                                                                                            }
#line 2829
                                                                                                                                                                                            if (output_file___0) {
#line 2830
                                                                                                                                                                                              fprintf(output_file___0,
                                                                                                                                                                                                      (char const   *)"setboard ");
                                                                                                                                                                                            }
#line 2831
                                                                                                                                                                                            rank___1 = 7;
                                                                                                                                                                                            {
#line 2831
                                                                                                                                                                                            while (1) {
                                                                                                                                                                                              while_continue___55: /* CIL Label */ ;
#line 2831
                                                                                                                                                                                              if (! (rank___1 >= 0)) {
#line 2831
                                                                                                                                                                                                goto while_break___55;
                                                                                                                                                                                              }
#line 2832
                                                                                                                                                                                              nempty = 0;
#line 2833
                                                                                                                                                                                              file___5 = 0;
                                                                                                                                                                                              {
#line 2833
                                                                                                                                                                                              while (1) {
                                                                                                                                                                                                while_continue___56: /* CIL Label */ ;
#line 2833
                                                                                                                                                                                                if (! (file___5 <= 7)) {
#line 2833
                                                                                                                                                                                                  goto while_break___56;
                                                                                                                                                                                                }
#line 2834
                                                                                                                                                                                                if (tree->position.board[(rank___1 << 3) + file___5]) {
#line 2835
                                                                                                                                                                                                  if (nempty) {
#line 2836
                                                                                                                                                                                                    if (output_file___0) {
#line 2837
                                                                                                                                                                                                      fprintf(output_file___0,
                                                                                                                                                                                                              (char const   *)"%c",
                                                                                                                                                                                                              (int const   )empty_sqs[nempty]);
                                                                                                                                                                                                    } else {
#line 2839
                                                                                                                                                                                                      tmp___172 = strlen((char const   *)(initial_position));
#line 2839
                                                                                                                                                                                                      sprintf(initial_position + tmp___172,
                                                                                                                                                                                                              (char const   *)"%c",
                                                                                                                                                                                                              (int const   )empty_sqs[nempty]);
                                                                                                                                                                                                    }
#line 2841
                                                                                                                                                                                                    nempty = 0;
                                                                                                                                                                                                  }
#line 2843
                                                                                                                                                                                                  if (output_file___0) {
#line 2844
                                                                                                                                                                                                    fprintf(output_file___0,
                                                                                                                                                                                                            (char const   *)"%c",
                                                                                                                                                                                                            (int const   )translate[(int )tree->position.board[(rank___1 << 3) + file___5] + 6]);
                                                                                                                                                                                                  } else {
#line 2847
                                                                                                                                                                                                    tmp___173 = strlen((char const   *)(initial_position));
#line 2847
                                                                                                                                                                                                    sprintf(initial_position + tmp___173,
                                                                                                                                                                                                            (char const   *)"%c",
                                                                                                                                                                                                            (int const   )translate[(int )tree->position.board[(rank___1 << 3) + file___5] + 6]);
                                                                                                                                                                                                  }
                                                                                                                                                                                                } else {
#line 2850
                                                                                                                                                                                                  nempty ++;
                                                                                                                                                                                                }
#line 2833
                                                                                                                                                                                                file___5 ++;
                                                                                                                                                                                              }
                                                                                                                                                                                              while_break___56: /* CIL Label */ ;
                                                                                                                                                                                              }
#line 2852
                                                                                                                                                                                              if (empty_sqs[nempty]) {
#line 2853
                                                                                                                                                                                                if (output_file___0) {
#line 2854
                                                                                                                                                                                                  fprintf(output_file___0,
                                                                                                                                                                                                          (char const   *)"%c",
                                                                                                                                                                                                          (int const   )empty_sqs[nempty]);
                                                                                                                                                                                                } else {
#line 2856
                                                                                                                                                                                                  tmp___174 = strlen((char const   *)(initial_position));
#line 2856
                                                                                                                                                                                                  sprintf(initial_position + tmp___174,
                                                                                                                                                                                                          (char const   *)"%c",
                                                                                                                                                                                                          (int const   )empty_sqs[nempty]);
                                                                                                                                                                                                }
                                                                                                                                                                                              }
#line 2859
                                                                                                                                                                                              if (rank___1 != 0) {
#line 2860
                                                                                                                                                                                                if (output_file___0) {
#line 2861
                                                                                                                                                                                                  fprintf(output_file___0,
                                                                                                                                                                                                          (char const   *)"/");
                                                                                                                                                                                                } else {
#line 2863
                                                                                                                                                                                                  tmp___175 = strlen((char const   *)(initial_position));
#line 2863
                                                                                                                                                                                                  sprintf(initial_position + tmp___175,
                                                                                                                                                                                                          (char const   *)"/");
                                                                                                                                                                                                }
                                                                                                                                                                                              }
#line 2831
                                                                                                                                                                                              rank___1 --;
                                                                                                                                                                                            }
                                                                                                                                                                                            while_break___55: /* CIL Label */ ;
                                                                                                                                                                                            }
#line 2866
                                                                                                                                                                                            if (output_file___0) {
#line 2867
                                                                                                                                                                                              if (game_wtm) {
#line 2867
                                                                                                                                                                                                tmp___176 = 'w';
                                                                                                                                                                                              } else {
#line 2867
                                                                                                                                                                                                tmp___176 = 'b';
                                                                                                                                                                                              }
#line 2867
                                                                                                                                                                                              fprintf(output_file___0,
                                                                                                                                                                                                      (char const   *)" %c ",
                                                                                                                                                                                                      tmp___176);
                                                                                                                                                                                            } else {
#line 2869
                                                                                                                                                                                              if (game_wtm) {
#line 2869
                                                                                                                                                                                                tmp___177 = 'w';
                                                                                                                                                                                              } else {
#line 2869
                                                                                                                                                                                                tmp___177 = 'b';
                                                                                                                                                                                              }
#line 2869
                                                                                                                                                                                              tmp___178 = strlen((char const   *)(initial_position));
#line 2869
                                                                                                                                                                                              sprintf(initial_position + tmp___178,
                                                                                                                                                                                                      (char const   *)" %c ",
                                                                                                                                                                                                      tmp___177);
                                                                                                                                                                                            }
#line 2871
                                                                                                                                                                                            if ((int )tree->status[0].castle[1] & 1) {
#line 2872
                                                                                                                                                                                              if (output_file___0) {
#line 2873
                                                                                                                                                                                                fprintf(output_file___0,
                                                                                                                                                                                                        (char const   *)"K");
                                                                                                                                                                                              } else {
#line 2875
                                                                                                                                                                                                tmp___179 = strlen((char const   *)(initial_position));
#line 2875
                                                                                                                                                                                                sprintf(initial_position + tmp___179,
                                                                                                                                                                                                        (char const   *)"K");
                                                                                                                                                                                              }
                                                                                                                                                                                            }
#line 2877
                                                                                                                                                                                            if ((int )tree->status[0].castle[1] & 2) {
#line 2878
                                                                                                                                                                                              if (output_file___0) {
#line 2879
                                                                                                                                                                                                fprintf(output_file___0,
                                                                                                                                                                                                        (char const   *)"Q");
                                                                                                                                                                                              } else {
#line 2881
                                                                                                                                                                                                tmp___180 = strlen((char const   *)(initial_position));
#line 2881
                                                                                                                                                                                                sprintf(initial_position + tmp___180,
                                                                                                                                                                                                        (char const   *)"Q");
                                                                                                                                                                                              }
                                                                                                                                                                                            }
#line 2883
                                                                                                                                                                                            if ((int )tree->status[0].castle[0] & 1) {
#line 2884
                                                                                                                                                                                              if (output_file___0) {
#line 2885
                                                                                                                                                                                                fprintf(output_file___0,
                                                                                                                                                                                                        (char const   *)"k");
                                                                                                                                                                                              } else {
#line 2887
                                                                                                                                                                                                tmp___181 = strlen((char const   *)(initial_position));
#line 2887
                                                                                                                                                                                                sprintf(initial_position + tmp___181,
                                                                                                                                                                                                        (char const   *)"k");
                                                                                                                                                                                              }
                                                                                                                                                                                            }
#line 2889
                                                                                                                                                                                            if ((int )tree->status[0].castle[0] & 2) {
#line 2890
                                                                                                                                                                                              if (output_file___0) {
#line 2891
                                                                                                                                                                                                fprintf(output_file___0,
                                                                                                                                                                                                        (char const   *)"q");
                                                                                                                                                                                              } else {
#line 2893
                                                                                                                                                                                                tmp___182 = strlen((char const   *)(initial_position));
#line 2893
                                                                                                                                                                                                sprintf(initial_position + tmp___182,
                                                                                                                                                                                                        (char const   *)"q");
                                                                                                                                                                                              }
                                                                                                                                                                                            }
#line 2895
                                                                                                                                                                                            if (! tree->status[0].castle[1]) {
#line 2895
                                                                                                                                                                                              if (! tree->status[0].castle[0]) {
#line 2896
                                                                                                                                                                                                if (output_file___0) {
#line 2897
                                                                                                                                                                                                  fprintf(output_file___0,
                                                                                                                                                                                                          (char const   *)" -");
                                                                                                                                                                                                } else {
#line 2899
                                                                                                                                                                                                  tmp___183 = strlen((char const   *)(initial_position));
#line 2899
                                                                                                                                                                                                  sprintf(initial_position + tmp___183,
                                                                                                                                                                                                          (char const   *)" -");
                                                                                                                                                                                                }
                                                                                                                                                                                              } else {
#line 2895
                                                                                                                                                                                                goto _L___48;
                                                                                                                                                                                              }
                                                                                                                                                                                            } else {
                                                                                                                                                                                              _L___48: /* CIL Label */ ;
                                                                                                                                                                                            }
#line 2901
                                                                                                                                                                                            if (tree->status[0].enpassant_target) {
#line 2902
                                                                                                                                                                                              if (output_file___0) {
#line 2903
                                                                                                                                                                                                fprintf(output_file___0,
                                                                                                                                                                                                        (char const   *)" %c%c",
                                                                                                                                                                                                        ((int )tree->status[0].enpassant_target & 7) + 97,
                                                                                                                                                                                                        ((int )tree->status[0].enpassant_target >> 3) + 49);
                                                                                                                                                                                              } else {
#line 2906
                                                                                                                                                                                                tmp___184 = strlen((char const   *)(initial_position));
#line 2906
                                                                                                                                                                                                sprintf(initial_position + tmp___184,
                                                                                                                                                                                                        (char const   *)" %c%c",
                                                                                                                                                                                                        ((int )tree->status[0].enpassant_target & 7) + 97,
                                                                                                                                                                                                        ((int )tree->status[0].enpassant_target >> 3) + 49);
                                                                                                                                                                                              }
                                                                                                                                                                                            } else
#line 2909
                                                                                                                                                                                            if (output_file___0) {
#line 2910
                                                                                                                                                                                              fprintf(output_file___0,
                                                                                                                                                                                                      (char const   *)" -");
                                                                                                                                                                                            } else {
#line 2912
                                                                                                                                                                                              tmp___185 = strlen((char const   *)(initial_position));
#line 2912
                                                                                                                                                                                              sprintf(initial_position + tmp___185,
                                                                                                                                                                                                      (char const   *)" -");
                                                                                                                                                                                            }
#line 2914
                                                                                                                                                                                            if (output_file___0) {
#line 2915
                                                                                                                                                                                              fprintf(output_file___0,
                                                                                                                                                                                                      (char const   *)"\n");
                                                                                                                                                                                            }
#line 2916
                                                                                                                                                                                            if (output_file___0) {
#line 2916
                                                                                                                                                                                              if ((unsigned long )output_file___0 != (unsigned long )stdout) {
#line 2917
                                                                                                                                                                                                fprintf(output_file___0,
                                                                                                                                                                                                        (char const   *)"exit\n");
#line 2918
                                                                                                                                                                                                fclose(output_file___0);
                                                                                                                                                                                              } else {
#line 2916
                                                                                                                                                                                                goto _L___49;
                                                                                                                                                                                              }
                                                                                                                                                                                            } else {
                                                                                                                                                                                              _L___49: /* CIL Label */ ;
                                                                                                                                                                                            }
#line 2920
                                                                                                                                                                                            if (output_file___0) {
#line 2921
                                                                                                                                                                                              printf((char const   *)"FEN save complete.\n");
                                                                                                                                                                                            }
                                                                                                                                                                                          } else {
#line 2932
                                                                                                                                                                                            tmp___306 = strcmp((char const   *)"scale",
                                                                                                                                                                                                               (char const   *)args[0]);
#line 2932
                                                                                                                                                                                            if (tmp___306) {
#line 2943
                                                                                                                                                                                              tmp___305 = OptionMatch("score",
                                                                                                                                                                                                                      args[0]);
#line 2943
                                                                                                                                                                                              if (tmp___305) {
#line 2946
                                                                                                                                                                                                if (thinking) {
#line 2946
                                                                                                                                                                                                  goto _L___50;
                                                                                                                                                                                                } else
#line 2946
                                                                                                                                                                                                if (pondering) {
                                                                                                                                                                                                  _L___50: /* CIL Label */ 
#line 2947
                                                                                                                                                                                                  return (2);
                                                                                                                                                                                                }
#line 2948
                                                                                                                                                                                                memset((void *)(& tree->pawn_score),
                                                                                                                                                                                                       0,
                                                                                                                                                                                                       sizeof(tree->pawn_score));
#line 2949
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "note: scores are for the white side\n");
#line 2950
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "                       ");
#line 2951
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " +-----------white----------+");
#line 2952
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "-----------black----------+\n");
#line 2953
                                                                                                                                                                                                tree->score_mg = 0;
#line 2954
                                                                                                                                                                                                tree->score_eg = 0;
#line 2955
                                                                                                                                                                                                mgb = tree->score_mg;
#line 2956
                                                                                                                                                                                                EvaluateMaterial(tree,
                                                                                                                                                                                                                 game_wtm);
#line 2957
                                                                                                                                                                                                mgb = tree->score_mg - mgb;
#line 2958
                                                                                                                                                                                                tmp___186 = DisplayEvaluation(mgb,
                                                                                                                                                                                                                              1);
#line 2958
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "material.......%s",
                                                                                                                                                                                                      tmp___186);
#line 2959
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "  |    comp     mg      eg   |");
#line 2960
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "    comp     mg      eg   |\n");
#line 2961
                                                                                                                                                                                                root_wtm = game_wtm ^ 1;
#line 2962
                                                                                                                                                                                                tree->status[1] = tree->status[0];
#line 2963
                                                                                                                                                                                                s = Evaluate(tree,
                                                                                                                                                                                                             1,
                                                                                                                                                                                                             game_wtm,
                                                                                                                                                                                                             -99999,
                                                                                                                                                                                                             99999);
#line 2964
                                                                                                                                                                                                trop[0] = tree->tropism[0];
#line 2965
                                                                                                                                                                                                trop[1] = tree->tropism[1];
#line 2966
                                                                                                                                                                                                if (! game_wtm) {
#line 2967
                                                                                                                                                                                                  s = - s;
                                                                                                                                                                                                }
#line 2968
                                                                                                                                                                                                tree->score_mg = 0;
#line 2969
                                                                                                                                                                                                tree->score_eg = 0;
#line 2970
                                                                                                                                                                                                if (62 < (int )tree->position.pieces[1][0] + (int )tree->position.pieces[0][0]) {
#line 2970
                                                                                                                                                                                                  phase = 62;
                                                                                                                                                                                                } else {
#line 2970
                                                                                                                                                                                                  phase = (int )tree->position.pieces[1][0] + (int )tree->position.pieces[0][0];
                                                                                                                                                                                                }
#line 2972
                                                                                                                                                                                                tree->pawn_score.score_mg = 0;
#line 2973
                                                                                                                                                                                                tree->pawn_score.score_eg = 0;
#line 2974
                                                                                                                                                                                                mgb = tree->pawn_score.score_mg;
#line 2975
                                                                                                                                                                                                egb = tree->pawn_score.score_eg;
#line 2976
                                                                                                                                                                                                EvaluatePawns(tree,
                                                                                                                                                                                                              0);
#line 2977
                                                                                                                                                                                                mgb = tree->pawn_score.score_mg - mgb;
#line 2978
                                                                                                                                                                                                egb = tree->pawn_score.score_eg - egb;
#line 2979
                                                                                                                                                                                                mgw = tree->pawn_score.score_mg;
#line 2980
                                                                                                                                                                                                egw = tree->pawn_score.score_eg;
#line 2981
                                                                                                                                                                                                EvaluatePawns(tree,
                                                                                                                                                                                                              1);
#line 2982
                                                                                                                                                                                                mgw = tree->pawn_score.score_mg - mgw;
#line 2983
                                                                                                                                                                                                egw = tree->pawn_score.score_eg - egw;
#line 2984
                                                                                                                                                                                                tb = (mgb * phase + egb * (62 - phase)) / 62;
#line 2985
                                                                                                                                                                                                tw = (mgw * phase + egw * (62 - phase)) / 62;
#line 2986
                                                                                                                                                                                                tmp___187 = DisplayEvaluation(tb + tw,
                                                                                                                                                                                                                              1);
#line 2986
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "pawns..........%s  |",
                                                                                                                                                                                                      tmp___187);
#line 2987
                                                                                                                                                                                                tmp___188 = DisplayEvaluation(tw,
                                                                                                                                                                                                                              1);
#line 2987
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___188);
#line 2988
                                                                                                                                                                                                tmp___189 = DisplayEvaluation(mgw,
                                                                                                                                                                                                                              1);
#line 2988
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___189);
#line 2989
                                                                                                                                                                                                tmp___190 = DisplayEvaluation(egw,
                                                                                                                                                                                                                              1);
#line 2989
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |",
                                                                                                                                                                                                      tmp___190);
#line 2990
                                                                                                                                                                                                tmp___191 = DisplayEvaluation(tb,
                                                                                                                                                                                                                              1);
#line 2990
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___191);
#line 2991
                                                                                                                                                                                                tmp___192 = DisplayEvaluation(mgb,
                                                                                                                                                                                                                              1);
#line 2991
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___192);
#line 2992
                                                                                                                                                                                                tmp___193 = DisplayEvaluation(egb,
                                                                                                                                                                                                                              1);
#line 2992
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |\n",
                                                                                                                                                                                                      tmp___193);
#line 2993
                                                                                                                                                                                                mgb = tree->score_mg;
#line 2994
                                                                                                                                                                                                egb = tree->score_eg;
#line 2995
                                                                                                                                                                                                EvaluatePassedPawns(tree,
                                                                                                                                                                                                                    0,
                                                                                                                                                                                                                    game_wtm);
#line 2996
                                                                                                                                                                                                mgb = tree->score_mg - mgb;
#line 2997
                                                                                                                                                                                                egb = tree->score_eg - egb;
#line 2998
                                                                                                                                                                                                mgw = tree->score_mg;
#line 2999
                                                                                                                                                                                                egw = tree->score_eg;
#line 3000
                                                                                                                                                                                                EvaluatePassedPawns(tree,
                                                                                                                                                                                                                    1,
                                                                                                                                                                                                                    game_wtm);
#line 3001
                                                                                                                                                                                                mgw = tree->score_mg - mgw;
#line 3002
                                                                                                                                                                                                egw = tree->score_eg - egw;
#line 3003
                                                                                                                                                                                                tb = (mgb * phase + egb * (62 - phase)) / 62;
#line 3004
                                                                                                                                                                                                tw = (mgw * phase + egw * (62 - phase)) / 62;
#line 3005
                                                                                                                                                                                                tmp___194 = DisplayEvaluation(tb + tw,
                                                                                                                                                                                                                              1);
#line 3005
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "passed pawns...%s  |",
                                                                                                                                                                                                      tmp___194);
#line 3006
                                                                                                                                                                                                tmp___195 = DisplayEvaluation(tw,
                                                                                                                                                                                                                              1);
#line 3006
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___195);
#line 3007
                                                                                                                                                                                                tmp___196 = DisplayEvaluation(mgw,
                                                                                                                                                                                                                              1);
#line 3007
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___196);
#line 3008
                                                                                                                                                                                                tmp___197 = DisplayEvaluation(egw,
                                                                                                                                                                                                                              1);
#line 3008
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |",
                                                                                                                                                                                                      tmp___197);
#line 3009
                                                                                                                                                                                                tmp___198 = DisplayEvaluation(tb,
                                                                                                                                                                                                                              1);
#line 3009
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___198);
#line 3010
                                                                                                                                                                                                tmp___199 = DisplayEvaluation(mgb,
                                                                                                                                                                                                                              1);
#line 3010
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___199);
#line 3011
                                                                                                                                                                                                tmp___200 = DisplayEvaluation(egb,
                                                                                                                                                                                                                              1);
#line 3011
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |\n",
                                                                                                                                                                                                      tmp___200);
#line 3012
                                                                                                                                                                                                mgb = tree->score_mg;
#line 3013
                                                                                                                                                                                                egb = tree->score_eg;
#line 3014
                                                                                                                                                                                                EvaluateKnights(tree,
                                                                                                                                                                                                                0);
#line 3015
                                                                                                                                                                                                mgb = tree->score_mg - mgb;
#line 3016
                                                                                                                                                                                                egb = tree->score_eg - egb;
#line 3017
                                                                                                                                                                                                mgw = tree->score_mg;
#line 3018
                                                                                                                                                                                                egw = tree->score_eg;
#line 3019
                                                                                                                                                                                                EvaluateKnights(tree,
                                                                                                                                                                                                                1);
#line 3020
                                                                                                                                                                                                mgw = tree->score_mg - mgw;
#line 3021
                                                                                                                                                                                                egw = tree->score_eg - egw;
#line 3022
                                                                                                                                                                                                tb = (mgb * phase + egb * (62 - phase)) / 62;
#line 3023
                                                                                                                                                                                                tw = (mgw * phase + egw * (62 - phase)) / 62;
#line 3024
                                                                                                                                                                                                tmp___201 = DisplayEvaluation(tb + tw,
                                                                                                                                                                                                                              1);
#line 3024
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "knights........%s  |",
                                                                                                                                                                                                      tmp___201);
#line 3025
                                                                                                                                                                                                tmp___202 = DisplayEvaluation(tw,
                                                                                                                                                                                                                              1);
#line 3025
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___202);
#line 3026
                                                                                                                                                                                                tmp___203 = DisplayEvaluation(mgw,
                                                                                                                                                                                                                              1);
#line 3026
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___203);
#line 3027
                                                                                                                                                                                                tmp___204 = DisplayEvaluation(egw,
                                                                                                                                                                                                                              1);
#line 3027
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |",
                                                                                                                                                                                                      tmp___204);
#line 3028
                                                                                                                                                                                                tmp___205 = DisplayEvaluation(tb,
                                                                                                                                                                                                                              1);
#line 3028
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___205);
#line 3029
                                                                                                                                                                                                tmp___206 = DisplayEvaluation(mgb,
                                                                                                                                                                                                                              1);
#line 3029
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___206);
#line 3030
                                                                                                                                                                                                tmp___207 = DisplayEvaluation(egb,
                                                                                                                                                                                                                              1);
#line 3030
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |\n",
                                                                                                                                                                                                      tmp___207);
#line 3031
                                                                                                                                                                                                mgb = tree->score_mg;
#line 3032
                                                                                                                                                                                                egb = tree->score_eg;
#line 3033
                                                                                                                                                                                                EvaluateBishops(tree,
                                                                                                                                                                                                                0);
#line 3034
                                                                                                                                                                                                mgb = tree->score_mg - mgb;
#line 3035
                                                                                                                                                                                                egb = tree->score_eg - egb;
#line 3036
                                                                                                                                                                                                mgw = tree->score_mg;
#line 3037
                                                                                                                                                                                                egw = tree->score_eg;
#line 3038
                                                                                                                                                                                                EvaluateBishops(tree,
                                                                                                                                                                                                                1);
#line 3039
                                                                                                                                                                                                mgw = tree->score_mg - mgw;
#line 3040
                                                                                                                                                                                                egw = tree->score_eg - egw;
#line 3041
                                                                                                                                                                                                tb = (mgb * phase + egb * (62 - phase)) / 62;
#line 3042
                                                                                                                                                                                                tw = (mgw * phase + egw * (62 - phase)) / 62;
#line 3043
                                                                                                                                                                                                tmp___208 = DisplayEvaluation(tb + tw,
                                                                                                                                                                                                                              1);
#line 3043
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "bishops........%s  |",
                                                                                                                                                                                                      tmp___208);
#line 3044
                                                                                                                                                                                                tmp___209 = DisplayEvaluation(tw,
                                                                                                                                                                                                                              1);
#line 3044
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___209);
#line 3045
                                                                                                                                                                                                tmp___210 = DisplayEvaluation(mgw,
                                                                                                                                                                                                                              1);
#line 3045
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___210);
#line 3046
                                                                                                                                                                                                tmp___211 = DisplayEvaluation(egw,
                                                                                                                                                                                                                              1);
#line 3046
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |",
                                                                                                                                                                                                      tmp___211);
#line 3047
                                                                                                                                                                                                tmp___212 = DisplayEvaluation(tb,
                                                                                                                                                                                                                              1);
#line 3047
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___212);
#line 3048
                                                                                                                                                                                                tmp___213 = DisplayEvaluation(mgb,
                                                                                                                                                                                                                              1);
#line 3048
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___213);
#line 3049
                                                                                                                                                                                                tmp___214 = DisplayEvaluation(egb,
                                                                                                                                                                                                                              1);
#line 3049
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |\n",
                                                                                                                                                                                                      tmp___214);
#line 3050
                                                                                                                                                                                                mgb = tree->score_mg;
#line 3051
                                                                                                                                                                                                egb = tree->score_eg;
#line 3052
                                                                                                                                                                                                EvaluateRooks(tree,
                                                                                                                                                                                                              0);
#line 3053
                                                                                                                                                                                                mgb = tree->score_mg - mgb;
#line 3054
                                                                                                                                                                                                egb = tree->score_eg - egb;
#line 3055
                                                                                                                                                                                                mgw = tree->score_mg;
#line 3056
                                                                                                                                                                                                egw = tree->score_eg;
#line 3057
                                                                                                                                                                                                EvaluateRooks(tree,
                                                                                                                                                                                                              1);
#line 3058
                                                                                                                                                                                                mgw = tree->score_mg - mgw;
#line 3059
                                                                                                                                                                                                egw = tree->score_eg - egw;
#line 3060
                                                                                                                                                                                                tb = (mgb * phase + egb * (62 - phase)) / 62;
#line 3061
                                                                                                                                                                                                tw = (mgw * phase + egw * (62 - phase)) / 62;
#line 3062
                                                                                                                                                                                                tmp___215 = DisplayEvaluation(tb + tw,
                                                                                                                                                                                                                              1);
#line 3062
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "rooks..........%s  |",
                                                                                                                                                                                                      tmp___215);
#line 3063
                                                                                                                                                                                                tmp___216 = DisplayEvaluation(tw,
                                                                                                                                                                                                                              1);
#line 3063
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___216);
#line 3064
                                                                                                                                                                                                tmp___217 = DisplayEvaluation(mgw,
                                                                                                                                                                                                                              1);
#line 3064
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___217);
#line 3065
                                                                                                                                                                                                tmp___218 = DisplayEvaluation(egw,
                                                                                                                                                                                                                              1);
#line 3065
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |",
                                                                                                                                                                                                      tmp___218);
#line 3066
                                                                                                                                                                                                tmp___219 = DisplayEvaluation(tb,
                                                                                                                                                                                                                              1);
#line 3066
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___219);
#line 3067
                                                                                                                                                                                                tmp___220 = DisplayEvaluation(mgb,
                                                                                                                                                                                                                              1);
#line 3067
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___220);
#line 3068
                                                                                                                                                                                                tmp___221 = DisplayEvaluation(egb,
                                                                                                                                                                                                                              1);
#line 3068
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |\n",
                                                                                                                                                                                                      tmp___221);
#line 3069
                                                                                                                                                                                                mgb = tree->score_mg;
#line 3070
                                                                                                                                                                                                egb = tree->score_eg;
#line 3071
                                                                                                                                                                                                EvaluateQueens(tree,
                                                                                                                                                                                                               0);
#line 3072
                                                                                                                                                                                                mgb = tree->score_mg - mgb;
#line 3073
                                                                                                                                                                                                egb = tree->score_eg - egb;
#line 3074
                                                                                                                                                                                                mgw = tree->score_mg;
#line 3075
                                                                                                                                                                                                egw = tree->score_eg;
#line 3076
                                                                                                                                                                                                EvaluateQueens(tree,
                                                                                                                                                                                                               1);
#line 3077
                                                                                                                                                                                                mgw = tree->score_mg - mgw;
#line 3078
                                                                                                                                                                                                egw = tree->score_eg - egw;
#line 3079
                                                                                                                                                                                                tb = (mgb * phase + egb * (62 - phase)) / 62;
#line 3080
                                                                                                                                                                                                tw = (mgw * phase + egw * (62 - phase)) / 62;
#line 3081
                                                                                                                                                                                                tmp___222 = DisplayEvaluation(tb + tw,
                                                                                                                                                                                                                              1);
#line 3081
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "queens.........%s  |",
                                                                                                                                                                                                      tmp___222);
#line 3082
                                                                                                                                                                                                tmp___223 = DisplayEvaluation(tw,
                                                                                                                                                                                                                              1);
#line 3082
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___223);
#line 3083
                                                                                                                                                                                                tmp___224 = DisplayEvaluation(mgw,
                                                                                                                                                                                                                              1);
#line 3083
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___224);
#line 3084
                                                                                                                                                                                                tmp___225 = DisplayEvaluation(egw,
                                                                                                                                                                                                                              1);
#line 3084
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |",
                                                                                                                                                                                                      tmp___225);
#line 3085
                                                                                                                                                                                                tmp___226 = DisplayEvaluation(tb,
                                                                                                                                                                                                                              1);
#line 3085
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___226);
#line 3086
                                                                                                                                                                                                tmp___227 = DisplayEvaluation(mgb,
                                                                                                                                                                                                                              1);
#line 3086
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___227);
#line 3087
                                                                                                                                                                                                tmp___228 = DisplayEvaluation(egb,
                                                                                                                                                                                                                              1);
#line 3087
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |\n",
                                                                                                                                                                                                      tmp___228);
#line 3088
                                                                                                                                                                                                tree->tropism[0] = trop[0];
#line 3089
                                                                                                                                                                                                tree->tropism[1] = trop[1];
#line 3090
                                                                                                                                                                                                mgb = tree->score_mg;
#line 3091
                                                                                                                                                                                                egb = tree->score_eg;
#line 3092
                                                                                                                                                                                                EvaluateKing(tree,
                                                                                                                                                                                                             1,
                                                                                                                                                                                                             0);
#line 3093
                                                                                                                                                                                                mgb = tree->score_mg - mgb;
#line 3094
                                                                                                                                                                                                egb = tree->score_eg - egb;
#line 3095
                                                                                                                                                                                                mgw = tree->score_mg;
#line 3096
                                                                                                                                                                                                egw = tree->score_eg;
#line 3097
                                                                                                                                                                                                EvaluateKing(tree,
                                                                                                                                                                                                             1,
                                                                                                                                                                                                             1);
#line 3098
                                                                                                                                                                                                mgw = tree->score_mg - mgw;
#line 3099
                                                                                                                                                                                                egw = tree->score_eg - egw;
#line 3100
                                                                                                                                                                                                tb = (mgb * phase + egb * (62 - phase)) / 62;
#line 3101
                                                                                                                                                                                                tw = (mgw * phase + egw * (62 - phase)) / 62;
#line 3102
                                                                                                                                                                                                tmp___229 = DisplayEvaluation(tb + tw,
                                                                                                                                                                                                                              1);
#line 3102
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "kings..........%s  |",
                                                                                                                                                                                                      tmp___229);
#line 3103
                                                                                                                                                                                                tmp___230 = DisplayEvaluation(tw,
                                                                                                                                                                                                                              1);
#line 3103
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___230);
#line 3104
                                                                                                                                                                                                tmp___231 = DisplayEvaluation(mgw,
                                                                                                                                                                                                                              1);
#line 3104
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___231);
#line 3105
                                                                                                                                                                                                tmp___232 = DisplayEvaluation(egw,
                                                                                                                                                                                                                              1);
#line 3105
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |",
                                                                                                                                                                                                      tmp___232);
#line 3106
                                                                                                                                                                                                tmp___233 = DisplayEvaluation(tb,
                                                                                                                                                                                                                              1);
#line 3106
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___233);
#line 3107
                                                                                                                                                                                                tmp___234 = DisplayEvaluation(mgb,
                                                                                                                                                                                                                              1);
#line 3107
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s",
                                                                                                                                                                                                      tmp___234);
#line 3108
                                                                                                                                                                                                tmp___235 = DisplayEvaluation(egb,
                                                                                                                                                                                                                              1);
#line 3108
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      " %s  |\n",
                                                                                                                                                                                                      tmp___235);
#line 3109
                                                                                                                                                                                                egb = tree->score_eg;
#line 3110
                                                                                                                                                                                                if ((int )tree->position.pieces[1][0] == 0) {
#line 3110
                                                                                                                                                                                                  if (tree->pawn_score.passed[0]) {
#line 3110
                                                                                                                                                                                                    goto _L___51;
                                                                                                                                                                                                  } else {
#line 3110
                                                                                                                                                                                                    goto _L___53;
                                                                                                                                                                                                  }
                                                                                                                                                                                                } else
                                                                                                                                                                                                _L___53: /* CIL Label */ 
#line 3110
                                                                                                                                                                                                if ((int )tree->position.pieces[0][0] == 0) {
#line 3110
                                                                                                                                                                                                  if (tree->pawn_score.passed[1]) {
                                                                                                                                                                                                    _L___51: /* CIL Label */ 
#line 3113
                                                                                                                                                                                                    EvaluatePassedPawnRaces(tree,
                                                                                                                                                                                                                            game_wtm);
                                                                                                                                                                                                  } else {
#line 3110
                                                                                                                                                                                                    goto _L___52;
                                                                                                                                                                                                  }
                                                                                                                                                                                                } else {
                                                                                                                                                                                                  _L___52: /* CIL Label */ ;
                                                                                                                                                                                                }
#line 3114
                                                                                                                                                                                                egb = tree->score_eg - egb;
#line 3115
                                                                                                                                                                                                tmp___236 = DisplayEvaluation(egb,
                                                                                                                                                                                                                              1);
#line 3115
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "pawn races.....%s",
                                                                                                                                                                                                      tmp___236);
#line 3116
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "  +--------------------------+--------------------------+\n");
#line 3117
                                                                                                                                                                                                tmp___237 = DisplayEvaluation(s,
                                                                                                                                                                                                                              1);
#line 3117
                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                      "total..........%s\n",
                                                                                                                                                                                                      tmp___237);
                                                                                                                                                                                              } else {
#line 3128
                                                                                                                                                                                                tmp___304 = OptionMatch("screen",
                                                                                                                                                                                                                        args[0]);
#line 3128
                                                                                                                                                                                                if (tmp___304) {
#line 3129
                                                                                                                                                                                                  margin = 9999999;
#line 3131
                                                                                                                                                                                                  nargs = ReadParse(buffer,
                                                                                                                                                                                                                    args,
                                                                                                                                                                                                                    " \t;=");
#line 3132
                                                                                                                                                                                                  if (thinking) {
#line 3132
                                                                                                                                                                                                    goto _L___54;
                                                                                                                                                                                                  } else
#line 3132
                                                                                                                                                                                                  if (pondering) {
                                                                                                                                                                                                    _L___54: /* CIL Label */ 
#line 3133
                                                                                                                                                                                                    return (2);
                                                                                                                                                                                                  }
#line 3134
                                                                                                                                                                                                  if (nargs < 3) {
#line 3135
                                                                                                                                                                                                    printf((char const   *)"usage:  screen <filename> score-margin\n");
#line 3136
                                                                                                                                                                                                    return (1);
                                                                                                                                                                                                  }
#line 3138
                                                                                                                                                                                                  save_noise = (int )noise_level;
#line 3139
                                                                                                                                                                                                  save_display = display_options;
#line 3140
                                                                                                                                                                                                  early_exit = 99;
#line 3141
                                                                                                                                                                                                  margin = atoi((char const   *)args[2]);
#line 3142
                                                                                                                                                                                                  noise_level = 99999999U;
#line 3143
                                                                                                                                                                                                  display_options = 2048;
#line 3144
                                                                                                                                                                                                  Test(args[1],
                                                                                                                                                                                                       (FILE *)0,
                                                                                                                                                                                                       1,
                                                                                                                                                                                                       margin);
#line 3145
                                                                                                                                                                                                  noise_level = (unsigned int )save_noise;
#line 3146
                                                                                                                                                                                                  display_options = save_display;
#line 3147
                                                                                                                                                                                                  ponder_move = 0;
#line 3148
                                                                                                                                                                                                  last_pv.pathd = 0;
#line 3149
                                                                                                                                                                                                  last_pv.pathl = 0;
                                                                                                                                                                                                } else {
#line 3159
                                                                                                                                                                                                  tmp___303 = OptionMatch("sd",
                                                                                                                                                                                                                          args[0]);
#line 3159
                                                                                                                                                                                                  if (tmp___303) {
#line 3160
                                                                                                                                                                                                    if (nargs < 2) {
#line 3161
                                                                                                                                                                                                      printf((char const   *)"usage:  sd <depth>\n");
#line 3162
                                                                                                                                                                                                      return (1);
                                                                                                                                                                                                    }
#line 3164
                                                                                                                                                                                                    search_depth = atoi((char const   *)args[1]);
#line 3165
                                                                                                                                                                                                    Print(32,
                                                                                                                                                                                                          "search depth set to %d.\n",
                                                                                                                                                                                                          search_depth);
                                                                                                                                                                                                  } else {
#line 3175
                                                                                                                                                                                                    tmp___302 = OptionMatch("search",
                                                                                                                                                                                                                            args[0]);
#line 3175
                                                                                                                                                                                                    if (tmp___302) {
#line 3176
                                                                                                                                                                                                      if (thinking) {
#line 3176
                                                                                                                                                                                                        goto _L___55;
                                                                                                                                                                                                      } else
#line 3176
                                                                                                                                                                                                      if (pondering) {
                                                                                                                                                                                                        _L___55: /* CIL Label */ 
#line 3177
                                                                                                                                                                                                        return (2);
                                                                                                                                                                                                      }
#line 3178
                                                                                                                                                                                                      if (nargs < 2) {
#line 3179
                                                                                                                                                                                                        printf((char const   *)"usage:  search <move>\n");
#line 3180
                                                                                                                                                                                                        return (1);
                                                                                                                                                                                                      }
#line 3182
                                                                                                                                                                                                      search_move = InputMove(tree,
                                                                                                                                                                                                                              0,
                                                                                                                                                                                                                              game_wtm,
                                                                                                                                                                                                                              0,
                                                                                                                                                                                                                              0,
                                                                                                                                                                                                                              args[1]);
#line 3183
                                                                                                                                                                                                      if (! search_move) {
#line 3184
                                                                                                                                                                                                        search_move = InputMove(tree,
                                                                                                                                                                                                                                0,
                                                                                                                                                                                                                                game_wtm ^ 1,
                                                                                                                                                                                                                                0,
                                                                                                                                                                                                                                0,
                                                                                                                                                                                                                                args[1]);
                                                                                                                                                                                                      }
#line 3185
                                                                                                                                                                                                      if (! search_move) {
#line 3186
                                                                                                                                                                                                        printf((char const   *)"illegal move.\n");
                                                                                                                                                                                                      }
                                                                                                                                                                                                    } else {
#line 3196
                                                                                                                                                                                                      tmp___301 = OptionMatch("setboard",
                                                                                                                                                                                                                              args[0]);
#line 3196
                                                                                                                                                                                                      if (tmp___301) {
#line 3197
                                                                                                                                                                                                        if (thinking) {
#line 3197
                                                                                                                                                                                                          goto _L___56;
                                                                                                                                                                                                        } else
#line 3197
                                                                                                                                                                                                        if (pondering) {
                                                                                                                                                                                                          _L___56: /* CIL Label */ 
#line 3198
                                                                                                                                                                                                          return (2);
                                                                                                                                                                                                        }
#line 3199
                                                                                                                                                                                                        nargs = ReadParse(buffer,
                                                                                                                                                                                                                          args,
                                                                                                                                                                                                                          " \t;=");
#line 3200
                                                                                                                                                                                                        if (nargs < 3) {
#line 3201
                                                                                                                                                                                                          printf((char const   *)"usage:  setboard <fen>\n");
#line 3202
                                                                                                                                                                                                          return (1);
                                                                                                                                                                                                        }
#line 3204
                                                                                                                                                                                                        SetBoard(tree,
                                                                                                                                                                                                                 nargs - 1,
                                                                                                                                                                                                                 args + 1,
                                                                                                                                                                                                                 0);
#line 3205
                                                                                                                                                                                                        move_number = 1;
#line 3206
                                                                                                                                                                                                        if (! game_wtm) {
#line 3207
                                                                                                                                                                                                          game_wtm = 1;
#line 3208
                                                                                                                                                                                                          Pass();
                                                                                                                                                                                                        }
#line 3210
                                                                                                                                                                                                        ponder_move = 0;
#line 3211
                                                                                                                                                                                                        last_pv.pathd = 0;
#line 3212
                                                                                                                                                                                                        last_pv.pathl = 0;
#line 3213
                                                                                                                                                                                                        over = 0;
#line 3214
                                                                                                                                                                                                        strcpy(buffer,
                                                                                                                                                                                                               (char const   *)"savepos *");
#line 3215
                                                                                                                                                                                                        Option(tree);
                                                                                                                                                                                                      } else {
#line 3216
                                                                                                                                                                                                        tmp___300 = StrCnt(args[0],
                                                                                                                                                                                                                           (char )'/');
#line 3216
                                                                                                                                                                                                        if (tmp___300 > 3) {
#line 3217
                                                                                                                                                                                                          if (thinking) {
#line 3217
                                                                                                                                                                                                            goto _L___57;
                                                                                                                                                                                                          } else
#line 3217
                                                                                                                                                                                                          if (pondering) {
                                                                                                                                                                                                            _L___57: /* CIL Label */ 
#line 3218
                                                                                                                                                                                                            return (2);
                                                                                                                                                                                                          }
#line 3219
                                                                                                                                                                                                          nargs = ReadParse(buffer,
                                                                                                                                                                                                                            args,
                                                                                                                                                                                                                            " \t;=");
#line 3220
                                                                                                                                                                                                          SetBoard(tree,
                                                                                                                                                                                                                   nargs,
                                                                                                                                                                                                                   args,
                                                                                                                                                                                                                   0);
#line 3221
                                                                                                                                                                                                          move_number = 1;
#line 3222
                                                                                                                                                                                                          if (! game_wtm) {
#line 3223
                                                                                                                                                                                                            game_wtm = 1;
#line 3224
                                                                                                                                                                                                            Pass();
                                                                                                                                                                                                          }
#line 3226
                                                                                                                                                                                                          ponder_move = 0;
#line 3227
                                                                                                                                                                                                          last_pv.pathd = 0;
#line 3228
                                                                                                                                                                                                          last_pv.pathl = 0;
#line 3229
                                                                                                                                                                                                          over = 0;
#line 3230
                                                                                                                                                                                                          strcpy(buffer,
                                                                                                                                                                                                                 (char const   *)"savepos *");
#line 3231
                                                                                                                                                                                                          Option(tree);
                                                                                                                                                                                                        } else {
#line 3241
                                                                                                                                                                                                          tmp___299 = OptionMatch("settc",
                                                                                                                                                                                                                                  args[0]);
#line 3241
                                                                                                                                                                                                          if (tmp___299) {
#line 3242
                                                                                                                                                                                                            if (thinking) {
#line 3242
                                                                                                                                                                                                              goto _L___58;
                                                                                                                                                                                                            } else
#line 3242
                                                                                                                                                                                                            if (pondering) {
                                                                                                                                                                                                              _L___58: /* CIL Label */ 
#line 3243
                                                                                                                                                                                                              return (2);
                                                                                                                                                                                                            }
#line 3244
                                                                                                                                                                                                            if (nargs < 4) {
#line 3245
                                                                                                                                                                                                              printf((char const   *)"usage:  settc <wmoves> <wtime> <bmoves> <btime>\n");
#line 3246
                                                                                                                                                                                                              return (1);
                                                                                                                                                                                                            }
#line 3248
                                                                                                                                                                                                            tc_moves_remaining[1] = atoi((char const   *)args[1]);
#line 3249
                                                                                                                                                                                                            tmp___238 = ParseTime(args[2]);
#line 3249
                                                                                                                                                                                                            tc_time_remaining[1] = tmp___238 * 6000;
#line 3250
                                                                                                                                                                                                            tc_moves_remaining[0] = atoi((char const   *)args[3]);
#line 3251
                                                                                                                                                                                                            tmp___239 = ParseTime(args[4]);
#line 3251
                                                                                                                                                                                                            tc_time_remaining[0] = tmp___239 * 6000;
#line 3252
                                                                                                                                                                                                            tmp___240 = DisplayTime((unsigned int )tc_time_remaining[1]);
#line 3252
                                                                                                                                                                                                            Print(32,
                                                                                                                                                                                                                  "time remaining: %s (white).\n",
                                                                                                                                                                                                                  tmp___240);
#line 3254
                                                                                                                                                                                                            tmp___241 = DisplayTime((unsigned int )tc_time_remaining[0]);
#line 3254
                                                                                                                                                                                                            Print(32,
                                                                                                                                                                                                                  "time remaining: %s (black).\n",
                                                                                                                                                                                                                  tmp___241);
#line 3256
                                                                                                                                                                                                            if (tc_sudden_death != 1) {
#line 3257
                                                                                                                                                                                                              Print(32,
                                                                                                                                                                                                                    "%d moves to next time control (white)\n",
                                                                                                                                                                                                                    tc_moves_remaining[1]);
#line 3259
                                                                                                                                                                                                              Print(32,
                                                                                                                                                                                                                    "%d moves to next time control (black)\n",
                                                                                                                                                                                                                    tc_moves_remaining[0]);
                                                                                                                                                                                                            } else {
#line 3262
                                                                                                                                                                                                              Print(32,
                                                                                                                                                                                                                    "Sudden-death time control in effect\n");
                                                                                                                                                                                                            }
#line 3263
                                                                                                                                                                                                            TimeSet(999);
                                                                                                                                                                                                          } else {
#line 3273
                                                                                                                                                                                                            tmp___298 = OptionMatch("show",
                                                                                                                                                                                                                                    args[0]);
#line 3273
                                                                                                                                                                                                            if (tmp___298) {
#line 3274
                                                                                                                                                                                                              if (nargs < 2) {
#line 3275
                                                                                                                                                                                                                printf((char const   *)"usage:  show book\n");
#line 3276
                                                                                                                                                                                                                return (1);
                                                                                                                                                                                                              }
#line 3278
                                                                                                                                                                                                              tmp___242 = OptionMatch("book",
                                                                                                                                                                                                                                      args[1]);
#line 3278
                                                                                                                                                                                                              if (tmp___242) {
#line 3279
                                                                                                                                                                                                                show_book = ! show_book;
#line 3280
                                                                                                                                                                                                                if (show_book) {
#line 3281
                                                                                                                                                                                                                  Print(32,
                                                                                                                                                                                                                        "show book statistics\n");
                                                                                                                                                                                                                } else {
#line 3283
                                                                                                                                                                                                                  Print(32,
                                                                                                                                                                                                                        "don\'t show book statistics\n");
                                                                                                                                                                                                                }
                                                                                                                                                                                                              }
                                                                                                                                                                                                            } else {
#line 3369
                                                                                                                                                                                                              tmp___297 = OptionMatch("smpaffinity",
                                                                                                                                                                                                                                      args[0]);
#line 3369
                                                                                                                                                                                                              if (tmp___297) {
#line 3370
                                                                                                                                                                                                                if (nargs < 2) {
#line 3371
                                                                                                                                                                                                                  printf((char const   *)"usage:  smpaffinity <0/1>\n");
#line 3372
                                                                                                                                                                                                                  return (1);
                                                                                                                                                                                                                }
#line 3374
                                                                                                                                                                                                                tmp___243 = strcmp((char const   *)args[1],
                                                                                                                                                                                                                                   (char const   *)"off");
#line 3374
                                                                                                                                                                                                                if (tmp___243) {
#line 3377
                                                                                                                                                                                                                  smp_affinity = atoi((char const   *)args[1]);
                                                                                                                                                                                                                } else {
#line 3375
                                                                                                                                                                                                                  smp_affinity = -1;
                                                                                                                                                                                                                }
#line 3378
                                                                                                                                                                                                                if (smp_affinity >= 0) {
#line 3379
                                                                                                                                                                                                                  Print(32,
                                                                                                                                                                                                                        "smp processor affinity enabled.\n");
                                                                                                                                                                                                                } else {
#line 3381
                                                                                                                                                                                                                  Print(32,
                                                                                                                                                                                                                        "smp processor affinity disabled.\n");
                                                                                                                                                                                                                }
                                                                                                                                                                                                              } else {
#line 3382
                                                                                                                                                                                                                tmp___296 = OptionMatch("smpmin",
                                                                                                                                                                                                                                        args[0]);
#line 3382
                                                                                                                                                                                                                if (tmp___296) {
#line 3383
                                                                                                                                                                                                                  if (nargs < 2) {
#line 3384
                                                                                                                                                                                                                    printf((char const   *)"usage:  smpmin <depth>\n");
#line 3385
                                                                                                                                                                                                                    return (1);
                                                                                                                                                                                                                  }
#line 3387
                                                                                                                                                                                                                  tmp___244 = atoi((char const   *)args[1]);
#line 3387
                                                                                                                                                                                                                  smp_min_split_depth = (unsigned int )tmp___244;
#line 3388
                                                                                                                                                                                                                  Print(32,
                                                                                                                                                                                                                        "minimum thread depth set to %d.\n",
                                                                                                                                                                                                                        smp_min_split_depth);
                                                                                                                                                                                                                } else {
#line 3389
                                                                                                                                                                                                                  tmp___295 = OptionMatch("smpgroup",
                                                                                                                                                                                                                                          args[0]);
#line 3389
                                                                                                                                                                                                                  if (tmp___295) {
#line 3390
                                                                                                                                                                                                                    if (nargs < 2) {
#line 3391
                                                                                                                                                                                                                      printf((char const   *)"usage:  smpgroup <threads>\n");
#line 3392
                                                                                                                                                                                                                      return (1);
                                                                                                                                                                                                                    }
#line 3394
                                                                                                                                                                                                                    tmp___245 = atoi((char const   *)args[1]);
#line 3394
                                                                                                                                                                                                                    smp_split_group = (unsigned int )tmp___245;
#line 3395
                                                                                                                                                                                                                    Print(32,
                                                                                                                                                                                                                          "maximum thread group size set to %d.\n",
                                                                                                                                                                                                                          smp_split_group);
                                                                                                                                                                                                                  } else {
#line 3396
                                                                                                                                                                                                                    tmp___292 = OptionMatch("smpmt",
                                                                                                                                                                                                                                            args[0]);
#line 3396
                                                                                                                                                                                                                    if (tmp___292) {
#line 3396
                                                                                                                                                                                                                      goto _L___71;
                                                                                                                                                                                                                    } else {
#line 3396
                                                                                                                                                                                                                      tmp___293 = OptionMatch("mt",
                                                                                                                                                                                                                                              args[0]);
#line 3396
                                                                                                                                                                                                                      if (tmp___293) {
                                                                                                                                                                                                                        _L___71: /* CIL Label */ 
#line 3396
                                                                                                                                                                                                                        goto _L___70;
                                                                                                                                                                                                                      } else {
#line 3396
                                                                                                                                                                                                                        tmp___294 = OptionMatch("cores",
                                                                                                                                                                                                                                                args[0]);
#line 3396
                                                                                                                                                                                                                        if (tmp___294) {
                                                                                                                                                                                                                          _L___70: /* CIL Label */ 
#line 3400
                                                                                                                                                                                                                          if (nargs < 2) {
#line 3401
                                                                                                                                                                                                                            printf((char const   *)"usage:  smpmt=<threads>\n");
#line 3402
                                                                                                                                                                                                                            return (1);
                                                                                                                                                                                                                          }
#line 3404
                                                                                                                                                                                                                          if (thinking) {
#line 3404
                                                                                                                                                                                                                            goto _L___59;
                                                                                                                                                                                                                          } else
#line 3404
                                                                                                                                                                                                                          if (pondering) {
                                                                                                                                                                                                                            _L___59: /* CIL Label */ 
#line 3405
                                                                                                                                                                                                                            return (3);
                                                                                                                                                                                                                          }
#line 3406
                                                                                                                                                                                                                          allow_cores = 0;
#line 3407
                                                                                                                                                                                                                          if (xboard) {
#line 3408
                                                                                                                                                                                                                            Print(4095,
                                                                                                                                                                                                                                  "Warning--  xboard \'cores\' option disabled\n");
                                                                                                                                                                                                                          }
#line 3409
                                                                                                                                                                                                                          tmp___246 = atoi((char const   *)args[1]);
#line 3409
                                                                                                                                                                                                                          smp_max_threads = (unsigned int )tmp___246;
#line 3410
                                                                                                                                                                                                                          if (smp_max_threads > hardware_processors) {
#line 3411
                                                                                                                                                                                                                            Print(4095,
                                                                                                                                                                                                                                  "ERROR - machine has %d processors.\n",
                                                                                                                                                                                                                                  hardware_processors);
#line 3413
                                                                                                                                                                                                                            Print(4095,
                                                                                                                                                                                                                                  "ERROR - max threads can not exceed this limit.\n");
#line 3414
                                                                                                                                                                                                                            smp_max_threads = hardware_processors;
                                                                                                                                                                                                                          }
#line 3416
                                                                                                                                                                                                                          if (smp_max_threads > 4U) {
#line 3417
                                                                                                                                                                                                                            Print(4095,
                                                                                                                                                                                                                                  "ERROR - Crafty was compiled with CPUS=%d.",
                                                                                                                                                                                                                                  4);
#line 3418
                                                                                                                                                                                                                            Print(4095,
                                                                                                                                                                                                                                  "  mt can not exceed this value.\n");
#line 3419
                                                                                                                                                                                                                            smp_max_threads = 4U;
                                                                                                                                                                                                                          }
#line 3421
                                                                                                                                                                                                                          if (smp_max_threads == 1U) {
#line 3422
                                                                                                                                                                                                                            Print(4095,
                                                                                                                                                                                                                                  "ERROR - max threads can be set to zero (0) to");
#line 3423
                                                                                                                                                                                                                            Print(4095,
                                                                                                                                                                                                                                  " disable parallel search, otherwise it must be > 1.\n");
#line 3424
                                                                                                                                                                                                                            smp_max_threads = 0U;
                                                                                                                                                                                                                          }
#line 3426
                                                                                                                                                                                                                          if (smp_max_threads) {
#line 3427
                                                                                                                                                                                                                            Print(32,
                                                                                                                                                                                                                                  "max threads set to %d.\n",
                                                                                                                                                                                                                                  smp_max_threads);
                                                                                                                                                                                                                          } else {
#line 3429
                                                                                                                                                                                                                            Print(32,
                                                                                                                                                                                                                                  "parallel threads disabled.\n");
                                                                                                                                                                                                                          }
#line 3430
                                                                                                                                                                                                                          proc = 1;
                                                                                                                                                                                                                          {
#line 3430
                                                                                                                                                                                                                          while (1) {
                                                                                                                                                                                                                            while_continue___57: /* CIL Label */ ;
#line 3430
                                                                                                                                                                                                                            if (! (proc < 4)) {
#line 3430
                                                                                                                                                                                                                              goto while_break___57;
                                                                                                                                                                                                                            }
#line 3431
                                                                                                                                                                                                                            if ((unsigned int )proc >= smp_max_threads) {
#line 3432
                                                                                                                                                                                                                              thread[proc].terminate = (unsigned int volatile   )1;
                                                                                                                                                                                                                            }
#line 3430
                                                                                                                                                                                                                            proc ++;
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                          while_break___57: /* CIL Label */ ;
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                        } else {
#line 3433
                                                                                                                                                                                                                          tmp___291 = OptionMatch("smpnice",
                                                                                                                                                                                                                                                  args[0]);
#line 3433
                                                                                                                                                                                                                          if (tmp___291) {
#line 3434
                                                                                                                                                                                                                            if (nargs < 2) {
#line 3435
                                                                                                                                                                                                                              printf((char const   *)"usage:  smpnice 0|1\n");
#line 3436
                                                                                                                                                                                                                              return (1);
                                                                                                                                                                                                                            }
#line 3438
                                                                                                                                                                                                                            smp_nice = atoi((char const   *)args[1]);
#line 3439
                                                                                                                                                                                                                            if (smp_nice) {
#line 3440
                                                                                                                                                                                                                              Print(32,
                                                                                                                                                                                                                                    "SMP terminate extra threads when idle.\n");
                                                                                                                                                                                                                            } else {
#line 3442
                                                                                                                                                                                                                              Print(32,
                                                                                                                                                                                                                                    "SMP keep extra threads spinning when idle.\n");
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                          } else {
#line 3443
                                                                                                                                                                                                                            tmp___290 = OptionMatch("smpnuma",
                                                                                                                                                                                                                                                    args[0]);
#line 3443
                                                                                                                                                                                                                            if (tmp___290) {
#line 3444
                                                                                                                                                                                                                              if (nargs < 2) {
#line 3445
                                                                                                                                                                                                                                printf((char const   *)"usage:  smpnuma 0|1\n");
#line 3446
                                                                                                                                                                                                                                return (1);
                                                                                                                                                                                                                              }
#line 3448
                                                                                                                                                                                                                              smp_numa = atoi((char const   *)args[1]);
#line 3449
                                                                                                                                                                                                                              if (smp_numa) {
#line 3450
                                                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                                                      "SMP NUMA mode enabled.\n");
                                                                                                                                                                                                                              } else {
#line 3452
                                                                                                                                                                                                                                Print(32,
                                                                                                                                                                                                                                      "SMP NUMA mode disabled.\n");
                                                                                                                                                                                                                              }
                                                                                                                                                                                                                            } else {
#line 3453
                                                                                                                                                                                                                              tmp___289 = OptionMatch("smproot",
                                                                                                                                                                                                                                                      args[0]);
#line 3453
                                                                                                                                                                                                                              if (tmp___289) {
#line 3454
                                                                                                                                                                                                                                if (nargs < 2) {
#line 3455
                                                                                                                                                                                                                                  printf((char const   *)"usage:  smproot 0|1\n");
#line 3456
                                                                                                                                                                                                                                  return (1);
                                                                                                                                                                                                                                }
#line 3458
                                                                                                                                                                                                                                tmp___247 = atoi((char const   *)args[1]);
#line 3458
                                                                                                                                                                                                                                smp_split_at_root = (unsigned int )tmp___247;
#line 3459
                                                                                                                                                                                                                                if (smp_split_at_root) {
#line 3460
                                                                                                                                                                                                                                  Print(32,
                                                                                                                                                                                                                                        "SMP search split at ply >= 1.\n");
                                                                                                                                                                                                                                } else {
#line 3462
                                                                                                                                                                                                                                  Print(32,
                                                                                                                                                                                                                                        "SMP search split at ply > 1.\n");
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                              } else {
#line 3463
                                                                                                                                                                                                                                tmp___288 = OptionMatch("smpgsl",
                                                                                                                                                                                                                                                        args[0]);
#line 3463
                                                                                                                                                                                                                                if (tmp___288) {
#line 3464
                                                                                                                                                                                                                                  if (nargs < 2) {
#line 3465
                                                                                                                                                                                                                                    printf((char const   *)"usage:  smpgsl <n>\n");
#line 3466
                                                                                                                                                                                                                                    return (1);
                                                                                                                                                                                                                                  }
#line 3468
                                                                                                                                                                                                                                  tmp___248 = atoi((char const   *)args[1]);
#line 3468
                                                                                                                                                                                                                                  smp_gratuitous_limit = (unsigned int )tmp___248;
#line 3469
                                                                                                                                                                                                                                  Print(32,
                                                                                                                                                                                                                                        "maximum gratuitous splits allowed %d.\n",
                                                                                                                                                                                                                                        smp_gratuitous_limit);
                                                                                                                                                                                                                                } else {
#line 3471
                                                                                                                                                                                                                                  tmp___287 = OptionMatch("smpgsd",
                                                                                                                                                                                                                                                          args[0]);
#line 3471
                                                                                                                                                                                                                                  if (tmp___287) {
#line 3472
                                                                                                                                                                                                                                    if (nargs < 2) {
#line 3473
                                                                                                                                                                                                                                      printf((char const   *)"usage:  smpgsd <nodes>\n");
#line 3474
                                                                                                                                                                                                                                      return (1);
                                                                                                                                                                                                                                    }
#line 3476
                                                                                                                                                                                                                                    tmp___249 = atoi((char const   *)args[1]);
#line 3476
                                                                                                                                                                                                                                    smp_gratuitous_depth = (unsigned int )tmp___249;
#line 3477
                                                                                                                                                                                                                                    Print(32,
                                                                                                                                                                                                                                          "gratuitous split min depth %d.\n",
                                                                                                                                                                                                                                          smp_gratuitous_depth);
                                                                                                                                                                                                                                  } else {
#line 3488
                                                                                                                                                                                                                                    tmp___286 = OptionMatch("sn",
                                                                                                                                                                                                                                                            args[0]);
#line 3488
                                                                                                                                                                                                                                    if (tmp___286) {
#line 3489
                                                                                                                                                                                                                                      if (nargs < 2) {
#line 3490
                                                                                                                                                                                                                                        printf((char const   *)"usage:  sn <nodes>\n");
#line 3491
                                                                                                                                                                                                                                        return (1);
                                                                                                                                                                                                                                      }
#line 3493
                                                                                                                                                                                                                                      tmp___250 = atoi((char const   *)args[1]);
#line 3493
                                                                                                                                                                                                                                      search_nodes = (uint64_t )tmp___250;
#line 3494
                                                                                                                                                                                                                                      Print(32,
                                                                                                                                                                                                                                            "search nodes set to %lu.\n",
                                                                                                                                                                                                                                            search_nodes);
#line 3495
                                                                                                                                                                                                                                      ponder = 0;
                                                                                                                                                                                                                                    } else {
#line 3504
                                                                                                                                                                                                                                      tmp___285 = OptionMatch("speech",
                                                                                                                                                                                                                                                              args[0]);
#line 3504
                                                                                                                                                                                                                                      if (tmp___285) {
#line 3505
                                                                                                                                                                                                                                        if (nargs < 2) {
#line 3506
                                                                                                                                                                                                                                          printf((char const   *)"usage:  speech on|off\n");
#line 3507
                                                                                                                                                                                                                                          return (1);
                                                                                                                                                                                                                                        }
#line 3509
                                                                                                                                                                                                                                        tmp___252 = strcmp((char const   *)args[1],
                                                                                                                                                                                                                                                           (char const   *)"on");
#line 3509
                                                                                                                                                                                                                                        if (tmp___252) {
#line 3511
                                                                                                                                                                                                                                          tmp___251 = strcmp((char const   *)args[1],
                                                                                                                                                                                                                                                             (char const   *)"off");
#line 3511
                                                                                                                                                                                                                                          if (! tmp___251) {
#line 3512
                                                                                                                                                                                                                                            speech = (char)0;
                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                        } else {
#line 3510
                                                                                                                                                                                                                                          speech = (char)1;
                                                                                                                                                                                                                                        }
#line 3513
                                                                                                                                                                                                                                        if (speech) {
#line 3514
                                                                                                                                                                                                                                          Print(4095,
                                                                                                                                                                                                                                                "Audio output enabled\n");
                                                                                                                                                                                                                                        } else {
#line 3516
                                                                                                                                                                                                                                          Print(4095,
                                                                                                                                                                                                                                                "Audio output disabled\n");
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                      } else {
#line 3526
                                                                                                                                                                                                                                        tmp___284 = OptionMatch("st",
                                                                                                                                                                                                                                                                args[0]);
#line 3526
                                                                                                                                                                                                                                        if (tmp___284) {
#line 3527
                                                                                                                                                                                                                                          if (nargs < 2) {
#line 3528
                                                                                                                                                                                                                                            printf((char const   *)"usage:  st <time>\n");
#line 3529
                                                                                                                                                                                                                                            return (1);
                                                                                                                                                                                                                                          }
#line 3531
                                                                                                                                                                                                                                          tmp___253 = atof((char const   *)args[1]);
#line 3531
                                                                                                                                                                                                                                          search_time_limit = (int )(tmp___253 * (double )100);
#line 3532
                                                                                                                                                                                                                                          Print(32,
                                                                                                                                                                                                                                                "search time set to %.2f.\n",
                                                                                                                                                                                                                                                (double )((float )search_time_limit) / 100.0);
                                                                                                                                                                                                                                        } else {
#line 3542
                                                                                                                                                                                                                                          tmp___283 = OptionMatch("swindle",
                                                                                                                                                                                                                                                                  args[0]);
#line 3542
                                                                                                                                                                                                                                          if (tmp___283) {
#line 3543
                                                                                                                                                                                                                                            tmp___255 = strcmp((char const   *)args[1],
                                                                                                                                                                                                                                                               (char const   *)"on");
#line 3543
                                                                                                                                                                                                                                            if (tmp___255) {
#line 3545
                                                                                                                                                                                                                                              tmp___254 = strcmp((char const   *)args[1],
                                                                                                                                                                                                                                                                 (char const   *)"off");
#line 3545
                                                                                                                                                                                                                                              if (tmp___254) {
#line 3548
                                                                                                                                                                                                                                                printf((char const   *)"usage:  swindle on|off\n");
                                                                                                                                                                                                                                              } else {
#line 3546
                                                                                                                                                                                                                                                swindle_mode = 0;
                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                            } else {
#line 3544
                                                                                                                                                                                                                                              swindle_mode = 1;
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                          } else {
#line 3557
                                                                                                                                                                                                                                            tmp___282 = OptionMatch("tags",
                                                                                                                                                                                                                                                                    args[0]);
#line 3557
                                                                                                                                                                                                                                            if (tmp___282) {
#line 3561
                                                                                                                                                                                                                                              tmp___256 = time((time_t *)0);
#line 3561
                                                                                                                                                                                                                                              secs___0 = (uint64_t )tmp___256;
#line 3562
                                                                                                                                                                                                                                              timestruct___0 = localtime((time_t const   *)((time_t *)(& secs___0)));
#line 3563
                                                                                                                                                                                                                                              printf((char const   *)"[Event \"%s\"]\n",
                                                                                                                                                                                                                                                     pgn_event);
#line 3564
                                                                                                                                                                                                                                              printf((char const   *)"[Site \"%s\"]\n",
                                                                                                                                                                                                                                                     pgn_site);
#line 3565
                                                                                                                                                                                                                                              printf((char const   *)"[Date \"%4d.%02d.%02d\"]\n",
                                                                                                                                                                                                                                                     timestruct___0->tm_year + 1900,
                                                                                                                                                                                                                                                     timestruct___0->tm_mon + 1,
                                                                                                                                                                                                                                                     timestruct___0->tm_mday);
#line 3567
                                                                                                                                                                                                                                              printf((char const   *)"[Round \"%s\"]\n",
                                                                                                                                                                                                                                                     pgn_round);
#line 3568
                                                                                                                                                                                                                                              printf((char const   *)"[White \"%s\"]\n",
                                                                                                                                                                                                                                                     pgn_white);
#line 3569
                                                                                                                                                                                                                                              printf((char const   *)"[WhiteElo \"%s\"]\n",
                                                                                                                                                                                                                                                     pgn_white_elo);
#line 3570
                                                                                                                                                                                                                                              printf((char const   *)"[Black \"%s\"]\n",
                                                                                                                                                                                                                                                     pgn_black);
#line 3571
                                                                                                                                                                                                                                              printf((char const   *)"[BlackElo \"%s\"]\n",
                                                                                                                                                                                                                                                     pgn_black_elo);
#line 3572
                                                                                                                                                                                                                                              printf((char const   *)"[Result \"%s\"]\n",
                                                                                                                                                                                                                                                     pgn_result);
                                                                                                                                                                                                                                            } else {
#line 3582
                                                                                                                                                                                                                                              tmp___281 = OptionMatch("test",
                                                                                                                                                                                                                                                                      args[0]);
#line 3582
                                                                                                                                                                                                                                              if (tmp___281) {
#line 3583
                                                                                                                                                                                                                                                unsolved = (FILE *)((void *)0);
#line 3586
                                                                                                                                                                                                                                                if (thinking) {
#line 3586
                                                                                                                                                                                                                                                  goto _L___60;
                                                                                                                                                                                                                                                } else
#line 3586
                                                                                                                                                                                                                                                if (pondering) {
                                                                                                                                                                                                                                                  _L___60: /* CIL Label */ 
#line 3587
                                                                                                                                                                                                                                                  return (2);
                                                                                                                                                                                                                                                }
#line 3588
                                                                                                                                                                                                                                                nargs = ReadParse(buffer,
                                                                                                                                                                                                                                                                  args,
                                                                                                                                                                                                                                                                  " \t;=");
#line 3589
                                                                                                                                                                                                                                                if (nargs < 2) {
#line 3590
                                                                                                                                                                                                                                                  printf((char const   *)"usage:  test <filename> [exitcnt]\n");
#line 3591
                                                                                                                                                                                                                                                  return (1);
                                                                                                                                                                                                                                                }
#line 3593
                                                                                                                                                                                                                                                save_noise___0 = (int )noise_level;
#line 3594
                                                                                                                                                                                                                                                save_display___0 = display_options;
#line 3595
                                                                                                                                                                                                                                                if (nargs > 2) {
#line 3596
                                                                                                                                                                                                                                                  early_exit = atoi((char const   *)args[2]);
                                                                                                                                                                                                                                                }
#line 3597
                                                                                                                                                                                                                                                if (nargs > 3) {
#line 3598
                                                                                                                                                                                                                                                  unsolved = fopen((char const   * __restrict  )args[3],
                                                                                                                                                                                                                                                                   (char const   * __restrict  )"w+");
                                                                                                                                                                                                                                                }
#line 3599
                                                                                                                                                                                                                                                Test(args[1],
                                                                                                                                                                                                                                                     unsolved,
                                                                                                                                                                                                                                                     0,
                                                                                                                                                                                                                                                     0);
#line 3600
                                                                                                                                                                                                                                                noise_level = (unsigned int )save_noise___0;
#line 3601
                                                                                                                                                                                                                                                display_options = save_display___0;
#line 3602
                                                                                                                                                                                                                                                ponder_move = 0;
#line 3603
                                                                                                                                                                                                                                                last_pv.pathd = 0;
#line 3604
                                                                                                                                                                                                                                                last_pv.pathl = 0;
#line 3605
                                                                                                                                                                                                                                                if (unsolved) {
#line 3606
                                                                                                                                                                                                                                                  fclose(unsolved);
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                              } else {
#line 3639
                                                                                                                                                                                                                                                tmp___280 = OptionMatch("time",
                                                                                                                                                                                                                                                                        args[0]);
#line 3639
                                                                                                                                                                                                                                                if (tmp___280) {
#line 3640
                                                                                                                                                                                                                                                  if (xboard) {
#line 3641
                                                                                                                                                                                                                                                    tc_time_remaining[game_wtm ^ 1] = atoi((char const   *)args[1]);
#line 3642
                                                                                                                                                                                                                                                    if (log_file) {
#line 3642
                                                                                                                                                                                                                                                      if (time_limit > 99) {
#line 3643
                                                                                                                                                                                                                                                        tmp___257 = DisplayTime((unsigned int )tc_time_remaining[game_wtm ^ 1]);
#line 3643
                                                                                                                                                                                                                                                        fprintf(log_file,
                                                                                                                                                                                                                                                                (char const   *)"time remaining: %s (Crafty).\n",
                                                                                                                                                                                                                                                                tmp___257);
                                                                                                                                                                                                                                                      } else {
#line 3642
                                                                                                                                                                                                                                                        goto _L___61;
                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                      _L___61: /* CIL Label */ ;
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                  } else {
#line 3646
                                                                                                                                                                                                                                                    if (thinking) {
#line 3646
                                                                                                                                                                                                                                                      goto _L___62;
                                                                                                                                                                                                                                                    } else
#line 3646
                                                                                                                                                                                                                                                    if (pondering) {
                                                                                                                                                                                                                                                      _L___62: /* CIL Label */ 
#line 3647
                                                                                                                                                                                                                                                      return (2);
                                                                                                                                                                                                                                                    }
#line 3648
                                                                                                                                                                                                                                                    tc_moves = 60;
#line 3649
                                                                                                                                                                                                                                                    tc_time = 180000;
#line 3650
                                                                                                                                                                                                                                                    tc_moves_remaining[1] = 60;
#line 3651
                                                                                                                                                                                                                                                    tc_moves_remaining[0] = 60;
#line 3652
                                                                                                                                                                                                                                                    tc_time_remaining[1] = 180000;
#line 3653
                                                                                                                                                                                                                                                    tc_time_remaining[0] = 180000;
#line 3654
                                                                                                                                                                                                                                                    tc_secondary_moves = 60;
#line 3655
                                                                                                                                                                                                                                                    tc_secondary_time = 180000;
#line 3656
                                                                                                                                                                                                                                                    tc_increment = 0;
#line 3657
                                                                                                                                                                                                                                                    tc_sudden_death = 0;
#line 3661
                                                                                                                                                                                                                                                    if (nargs > 1) {
#line 3662
                                                                                                                                                                                                                                                      tmp___258 = strcmp((char const   *)args[1],
                                                                                                                                                                                                                                                                         (char const   *)"sd");
#line 3662
                                                                                                                                                                                                                                                      if (! tmp___258) {
#line 3663
                                                                                                                                                                                                                                                        tc_sudden_death = 1;
#line 3664
                                                                                                                                                                                                                                                        tc_moves = 1000;
                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                    }
#line 3666
                                                                                                                                                                                                                                                    if (nargs > 2) {
#line 3667
                                                                                                                                                                                                                                                      tc_moves = atoi((char const   *)args[1]);
#line 3668
                                                                                                                                                                                                                                                      tmp___259 = atoi((char const   *)args[2]);
#line 3668
                                                                                                                                                                                                                                                      tc_time = tmp___259 * 100;
                                                                                                                                                                                                                                                    }
#line 3673
                                                                                                                                                                                                                                                    tc_secondary_time = tc_time;
#line 3674
                                                                                                                                                                                                                                                    tc_secondary_moves = tc_moves;
#line 3675
                                                                                                                                                                                                                                                    if (nargs > 4) {
#line 3676
                                                                                                                                                                                                                                                      tmp___260 = strcmp((char const   *)args[3],
                                                                                                                                                                                                                                                                         (char const   *)"sd");
#line 3676
                                                                                                                                                                                                                                                      if (tmp___260) {
#line 3680
                                                                                                                                                                                                                                                        tc_secondary_moves = atoi((char const   *)args[3]);
                                                                                                                                                                                                                                                      } else {
#line 3677
                                                                                                                                                                                                                                                        tc_sudden_death = 2;
#line 3678
                                                                                                                                                                                                                                                        tc_secondary_moves = 1000;
                                                                                                                                                                                                                                                      }
#line 3681
                                                                                                                                                                                                                                                      tmp___261 = atoi((char const   *)args[4]);
#line 3681
                                                                                                                                                                                                                                                      tc_secondary_time = tmp___261 * 100;
                                                                                                                                                                                                                                                    }
#line 3683
                                                                                                                                                                                                                                                    if (nargs > 5) {
#line 3684
                                                                                                                                                                                                                                                      tmp___262 = atoi((char const   *)args[5]);
#line 3684
                                                                                                                                                                                                                                                      tc_increment = tmp___262 * 100;
                                                                                                                                                                                                                                                    }
#line 3685
                                                                                                                                                                                                                                                    tc_time_remaining[1] = tc_time;
#line 3686
                                                                                                                                                                                                                                                    tc_time_remaining[0] = tc_time;
#line 3687
                                                                                                                                                                                                                                                    tc_moves_remaining[1] = tc_moves;
#line 3688
                                                                                                                                                                                                                                                    tc_moves_remaining[0] = tc_moves;
#line 3689
                                                                                                                                                                                                                                                    if (! tc_sudden_death) {
#line 3690
                                                                                                                                                                                                                                                      Print(32,
                                                                                                                                                                                                                                                            "%d moves/%d minutes primary time control\n",
                                                                                                                                                                                                                                                            tc_moves,
                                                                                                                                                                                                                                                            tc_time / 100);
#line 3692
                                                                                                                                                                                                                                                      Print(32,
                                                                                                                                                                                                                                                            "%d moves/%d minutes secondary time control\n",
                                                                                                                                                                                                                                                            tc_secondary_moves,
                                                                                                                                                                                                                                                            tc_secondary_time / 100);
#line 3694
                                                                                                                                                                                                                                                      if (tc_increment) {
#line 3695
                                                                                                                                                                                                                                                        Print(32,
                                                                                                                                                                                                                                                              "increment %d seconds.\n",
                                                                                                                                                                                                                                                              tc_increment / 100);
                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                    } else
#line 3696
                                                                                                                                                                                                                                                    if (tc_sudden_death == 1) {
#line 3697
                                                                                                                                                                                                                                                      Print(32,
                                                                                                                                                                                                                                                            " game/%d minutes primary time control\n",
                                                                                                                                                                                                                                                            tc_time / 100);
#line 3698
                                                                                                                                                                                                                                                      if (tc_increment) {
#line 3699
                                                                                                                                                                                                                                                        Print(32,
                                                                                                                                                                                                                                                              "increment %d seconds.\n",
                                                                                                                                                                                                                                                              tc_increment / 100);
                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                    } else
#line 3700
                                                                                                                                                                                                                                                    if (tc_sudden_death == 2) {
#line 3701
                                                                                                                                                                                                                                                      Print(32,
                                                                                                                                                                                                                                                            "%d moves/%d minutes primary time control\n",
                                                                                                                                                                                                                                                            tc_moves,
                                                                                                                                                                                                                                                            tc_time / 100);
#line 3703
                                                                                                                                                                                                                                                      Print(32,
                                                                                                                                                                                                                                                            "game/%d minutes secondary time control\n",
                                                                                                                                                                                                                                                            tc_secondary_time / 100);
#line 3705
                                                                                                                                                                                                                                                      if (tc_increment) {
#line 3706
                                                                                                                                                                                                                                                        Print(32,
                                                                                                                                                                                                                                                              "increment %d seconds.\n",
                                                                                                                                                                                                                                                              tc_increment / 100);
                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                    }
#line 3708
                                                                                                                                                                                                                                                    tc_time *= 60;
#line 3709
                                                                                                                                                                                                                                                    tc_time_remaining[1] *= 60;
#line 3710
                                                                                                                                                                                                                                                    tc_time_remaining[0] *= 60;
#line 3711
                                                                                                                                                                                                                                                    tc_secondary_time *= 60;
#line 3712
                                                                                                                                                                                                                                                    tc_safety_margin = tc_time / 6;
                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                } else {
#line 3733
                                                                                                                                                                                                                                                  tmp___279 = OptionMatch("timebook",
                                                                                                                                                                                                                                                                          args[0]);
#line 3733
                                                                                                                                                                                                                                                  if (tmp___279) {
#line 3734
                                                                                                                                                                                                                                                    if (nargs < 3) {
#line 3735
                                                                                                                                                                                                                                                      printf((char const   *)"usage:  timebook <percentage> <move span>\n");
#line 3736
                                                                                                                                                                                                                                                      return (1);
                                                                                                                                                                                                                                                    }
#line 3738
                                                                                                                                                                                                                                                    first_nonbook_factor = atoi((char const   *)args[1]);
#line 3739
                                                                                                                                                                                                                                                    first_nonbook_span = atoi((char const   *)args[2]);
#line 3740
                                                                                                                                                                                                                                                    if (first_nonbook_factor < 0) {
#line 3740
                                                                                                                                                                                                                                                      goto _L___63;
                                                                                                                                                                                                                                                    } else
#line 3740
                                                                                                                                                                                                                                                    if (first_nonbook_factor > 500) {
                                                                                                                                                                                                                                                      _L___63: /* CIL Label */ 
#line 3741
                                                                                                                                                                                                                                                      Print(4095,
                                                                                                                                                                                                                                                            "ERROR, factor must be >= 0 and <= 500\n");
#line 3742
                                                                                                                                                                                                                                                      first_nonbook_factor = 0;
                                                                                                                                                                                                                                                    }
#line 3744
                                                                                                                                                                                                                                                    if (first_nonbook_span < 0) {
#line 3744
                                                                                                                                                                                                                                                      goto _L___64;
                                                                                                                                                                                                                                                    } else
#line 3744
                                                                                                                                                                                                                                                    if (first_nonbook_span > 30) {
                                                                                                                                                                                                                                                      _L___64: /* CIL Label */ 
#line 3745
                                                                                                                                                                                                                                                      Print(4095,
                                                                                                                                                                                                                                                            "ERROR, span must be >= 0 and <= 30\n");
#line 3746
                                                                                                                                                                                                                                                      first_nonbook_span = 0;
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                  } else {
#line 3757
                                                                                                                                                                                                                                                    tmp___278 = OptionMatch("trace",
                                                                                                                                                                                                                                                                            args[0]);
#line 3757
                                                                                                                                                                                                                                                    if (tmp___278) {
#line 3759
                                                                                                                                                                                                                                                      printf((char const   *)"Sorry, but I can\'t display traces unless compiled with -DTRACE\n");
#line 3762
                                                                                                                                                                                                                                                      if (nargs < 2) {
#line 3763
                                                                                                                                                                                                                                                        printf((char const   *)"usage:  trace <depth>\n");
#line 3764
                                                                                                                                                                                                                                                        return (1);
                                                                                                                                                                                                                                                      }
#line 3766
                                                                                                                                                                                                                                                      trace_level = atoi((char const   *)args[1]);
#line 3767
                                                                                                                                                                                                                                                      printf((char const   *)"trace=%d\n",
                                                                                                                                                                                                                                                             trace_level);
                                                                                                                                                                                                                                                    } else {
#line 3777
                                                                                                                                                                                                                                                      tmp___277 = OptionMatch("undo",
                                                                                                                                                                                                                                                                              args[0]);
#line 3777
                                                                                                                                                                                                                                                      if (tmp___277) {
#line 3778
                                                                                                                                                                                                                                                        if (thinking) {
#line 3778
                                                                                                                                                                                                                                                          goto _L___65;
                                                                                                                                                                                                                                                        } else
#line 3778
                                                                                                                                                                                                                                                        if (pondering) {
                                                                                                                                                                                                                                                          _L___65: /* CIL Label */ 
#line 3779
                                                                                                                                                                                                                                                          return (2);
                                                                                                                                                                                                                                                        }
#line 3780
                                                                                                                                                                                                                                                        if (! game_wtm) {
#line 3780
                                                                                                                                                                                                                                                          goto _L___66;
                                                                                                                                                                                                                                                        } else
#line 3780
                                                                                                                                                                                                                                                        if (move_number != 1) {
                                                                                                                                                                                                                                                          _L___66: /* CIL Label */ 
#line 3781
                                                                                                                                                                                                                                                          game_wtm ^= 1;
#line 3782
                                                                                                                                                                                                                                                          if (game_wtm ^ 1) {
#line 3783
                                                                                                                                                                                                                                                            move_number --;
                                                                                                                                                                                                                                                          }
#line 3784
                                                                                                                                                                                                                                                          sprintf(buffer,
                                                                                                                                                                                                                                                                  (char const   *)"reset %d",
                                                                                                                                                                                                                                                                  move_number);
#line 3785
                                                                                                                                                                                                                                                          Option(tree);
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                      } else {
#line 3801
                                                                                                                                                                                                                                                        tmp___276 = OptionMatch("usage",
                                                                                                                                                                                                                                                                                args[0]);
#line 3801
                                                                                                                                                                                                                                                        if (tmp___276) {
#line 3802
                                                                                                                                                                                                                                                          if (nargs < 2) {
#line 3803
                                                                                                                                                                                                                                                            printf((char const   *)"usage:  usage <percentage>\n");
#line 3804
                                                                                                                                                                                                                                                            return (1);
                                                                                                                                                                                                                                                          }
#line 3806
                                                                                                                                                                                                                                                          usage_level = atoi((char const   *)args[1]);
#line 3807
                                                                                                                                                                                                                                                          if (usage_level > 50) {
#line 3808
                                                                                                                                                                                                                                                            usage_level = 50;
                                                                                                                                                                                                                                                          } else
#line 3809
                                                                                                                                                                                                                                                          if (usage_level < -50) {
#line 3810
                                                                                                                                                                                                                                                            usage_level = -50;
                                                                                                                                                                                                                                                          }
#line 3811
                                                                                                                                                                                                                                                          Print(32,
                                                                                                                                                                                                                                                                "time usage up front set to %d percent increase/(-)decrease.\n",
                                                                                                                                                                                                                                                                usage_level);
                                                                                                                                                                                                                                                        } else {
#line 3822
                                                                                                                                                                                                                                                          tmp___275 = OptionMatch("variant",
                                                                                                                                                                                                                                                                                  args[0]);
#line 3822
                                                                                                                                                                                                                                                          if (tmp___275) {
#line 3823
                                                                                                                                                                                                                                                            if (thinking) {
#line 3823
                                                                                                                                                                                                                                                              goto _L___67;
                                                                                                                                                                                                                                                            } else
#line 3823
                                                                                                                                                                                                                                                            if (pondering) {
                                                                                                                                                                                                                                                              _L___67: /* CIL Label */ 
#line 3824
                                                                                                                                                                                                                                                              return (2);
                                                                                                                                                                                                                                                            }
#line 3825
                                                                                                                                                                                                                                                            printf((char const   *)"command=[%s]\n",
                                                                                                                                                                                                                                                                   buffer);
#line 3826
                                                                                                                                                                                                                                                            return (-1);
                                                                                                                                                                                                                                                          } else {
#line 3840
                                                                                                                                                                                                                                                            tmp___274 = OptionMatch("whisper",
                                                                                                                                                                                                                                                                                    args[0]);
#line 3840
                                                                                                                                                                                                                                                            if (tmp___274) {
#line 3841
                                                                                                                                                                                                                                                              if (nargs < 2) {
#line 3842
                                                                                                                                                                                                                                                                printf((char const   *)"usage:  whisper <level>\n");
#line 3843
                                                                                                                                                                                                                                                                return (1);
                                                                                                                                                                                                                                                              }
#line 3845
                                                                                                                                                                                                                                                              tmp___266 = atoi((char const   *)args[1]);
#line 3845
                                                                                                                                                                                                                                                              if (0 < tmp___266) {
#line 3845
                                                                                                                                                                                                                                                                tmp___265 = 0;
                                                                                                                                                                                                                                                              } else {
#line 3845
                                                                                                                                                                                                                                                                tmp___264 = atoi((char const   *)args[1]);
#line 3845
                                                                                                                                                                                                                                                                tmp___265 = tmp___264;
                                                                                                                                                                                                                                                              }
#line 3845
                                                                                                                                                                                                                                                              kibitz = 16 + tmp___265;
                                                                                                                                                                                                                                                            } else {
#line 3854
                                                                                                                                                                                                                                                              tmp___273 = OptionMatch("white",
                                                                                                                                                                                                                                                                                      args[0]);
#line 3854
                                                                                                                                                                                                                                                              if (tmp___273) {
#line 3855
                                                                                                                                                                                                                                                                if (thinking) {
#line 3855
                                                                                                                                                                                                                                                                  goto _L___68;
                                                                                                                                                                                                                                                                } else
#line 3855
                                                                                                                                                                                                                                                                if (pondering) {
                                                                                                                                                                                                                                                                  _L___68: /* CIL Label */ 
#line 3856
                                                                                                                                                                                                                                                                  return (2);
                                                                                                                                                                                                                                                                }
#line 3857
                                                                                                                                                                                                                                                                ponder_move = 0;
#line 3858
                                                                                                                                                                                                                                                                last_pv.pathd = 0;
#line 3859
                                                                                                                                                                                                                                                                last_pv.pathl = 0;
#line 3860
                                                                                                                                                                                                                                                                if (! game_wtm) {
#line 3861
                                                                                                                                                                                                                                                                  Pass();
                                                                                                                                                                                                                                                                }
#line 3862
                                                                                                                                                                                                                                                                force = 0;
                                                                                                                                                                                                                                                              } else {
#line 3874
                                                                                                                                                                                                                                                                tmp___272 = OptionMatch("wild",
                                                                                                                                                                                                                                                                                        args[0]);
#line 3874
                                                                                                                                                                                                                                                                if (tmp___272) {
#line 3877
                                                                                                                                                                                                                                                                  if (nargs < 2) {
#line 3878
                                                                                                                                                                                                                                                                    printf((char const   *)"usage:  wild <value>\n");
#line 3879
                                                                                                                                                                                                                                                                    return (1);
                                                                                                                                                                                                                                                                  }
#line 3881
                                                                                                                                                                                                                                                                  i___12 = atoi((char const   *)args[1]);
                                                                                                                                                                                                                                                                  {
#line 3883
                                                                                                                                                                                                                                                                  if (i___12 == 7) {
#line 3883
                                                                                                                                                                                                                                                                    goto case_7;
                                                                                                                                                                                                                                                                  }
#line 3887
                                                                                                                                                                                                                                                                  goto switch_default;
                                                                                                                                                                                                                                                                  case_7: /* CIL Label */ 
#line 3884
                                                                                                                                                                                                                                                                  strcpy(buffer,
                                                                                                                                                                                                                                                                         (char const   *)"setboard 4k/5ppp/////PPP/3K/ w");
#line 3885
                                                                                                                                                                                                                                                                  Option(tree);
#line 3886
                                                                                                                                                                                                                                                                  goto switch_break___0;
                                                                                                                                                                                                                                                                  switch_default: /* CIL Label */ 
#line 3888
                                                                                                                                                                                                                                                                  printf((char const   *)"sorry, only wild7 implemented at present\n");
#line 3889
                                                                                                                                                                                                                                                                  goto switch_break___0;
                                                                                                                                                                                                                                                                  switch_break___0: /* CIL Label */ ;
                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                } else {
#line 3901
                                                                                                                                                                                                                                                                  tmp___270 = OptionMatch("xboard",
                                                                                                                                                                                                                                                                                          args[0]);
#line 3901
                                                                                                                                                                                                                                                                  if (tmp___270) {
#line 3901
                                                                                                                                                                                                                                                                    goto _L___69;
                                                                                                                                                                                                                                                                  } else {
#line 3901
                                                                                                                                                                                                                                                                    tmp___271 = OptionMatch("winboard",
                                                                                                                                                                                                                                                                                            args[0]);
#line 3901
                                                                                                                                                                                                                                                                    if (tmp___271) {
                                                                                                                                                                                                                                                                      _L___69: /* CIL Label */ 
#line 3902
                                                                                                                                                                                                                                                                      if (! xboard) {
#line 3903
                                                                                                                                                                                                                                                                        signal(2,
                                                                                                                                                                                                                                                                               (void (*)(int  ))1);
#line 3904
                                                                                                                                                                                                                                                                        xboard = 1;
#line 3905
                                                                                                                                                                                                                                                                        display_options = 2048;
#line 3906
                                                                                                                                                                                                                                                                        Print(-1,
                                                                                                                                                                                                                                                                              "\n");
#line 3907
                                                                                                                                                                                                                                                                        if (1U > smp_max_threads) {
#line 3907
                                                                                                                                                                                                                                                                          tmp___267 = 1U;
                                                                                                                                                                                                                                                                        } else {
#line 3907
                                                                                                                                                                                                                                                                          tmp___267 = smp_max_threads;
                                                                                                                                                                                                                                                                        }
#line 3907
                                                                                                                                                                                                                                                                        Print(-1,
                                                                                                                                                                                                                                                                              "tellicsnoalias set 1 Crafty v%s (%d cpus)\n",
                                                                                                                                                                                                                                                                              version,
                                                                                                                                                                                                                                                                              tmp___267);
#line 3909
                                                                                                                                                                                                                                                                        if (1U > smp_max_threads) {
#line 3909
                                                                                                                                                                                                                                                                          tmp___268 = 1U;
                                                                                                                                                                                                                                                                        } else {
#line 3909
                                                                                                                                                                                                                                                                          tmp___268 = smp_max_threads;
                                                                                                                                                                                                                                                                        }
#line 3909
                                                                                                                                                                                                                                                                        Print(-1,
                                                                                                                                                                                                                                                                              "tellicsnoalias kibitz Hello from Crafty v%s! (%d cpus)\n",
                                                                                                                                                                                                                                                                              version,
                                                                                                                                                                                                                                                                              tmp___268);
                                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                                    } else {
#line 3922
                                                                                                                                                                                                                                                                      tmp___269 = OptionMatch("?",
                                                                                                                                                                                                                                                                                              args[0]);
#line 3922
                                                                                                                                                                                                                                                                      if (! tmp___269) {
#line 3932
                                                                                                                                                                                                                                                                        return (0);
                                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                              }
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                      }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                  }
                                                                                                                                                                                                                }
                                                                                                                                                                                                              }
                                                                                                                                                                                                            }
                                                                                                                                                                                                          }
                                                                                                                                                                                                        }
                                                                                                                                                                                                      }
                                                                                                                                                                                                    }
                                                                                                                                                                                                  }
                                                                                                                                                                                                }
                                                                                                                                                                                              }
                                                                                                                                                                                            } else {
#line 2933
                                                                                                                                                                                              scale = atoi((char const   *)args[1]);
                                                                                                                                                                                            }
                                                                                                                                                                                          }
                                                                                                                                                                                        }
                                                                                                                                                                                      }
                                                                                                                                                                                    }
                                                                                                                                                                                  }
                                                                                                                                                                                }
                                                                                                                                                                              }
                                                                                                                                                                            }
                                                                                                                                                                          }
                                                                                                                                                                        }
                                                                                                                                                                      }
                                                                                                                                                                    }
                                                                                                                                                                  }
                                                                                                                                                                }
                                                                                                                                                              }
                                                                                                                                                            }
                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                }
                                                                                                                                              }
                                                                                                                                            }
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                    }
                                                                                                                                  }
                                                                                                                                }
                                                                                                                              }
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      } else {
#line 314
                                        nargs = ReadParse(buffer, args, " \t;");
#line 315
                                        Bookup(tree, nargs, args);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3940
  return (1);
}
}
#line 3960 "option.c"
int OptionMatch(char *command , char *input ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 3968
  tmp = strcmp((char const   *)command, (char const   *)input);
#line 3968
  if (! tmp) {
#line 3969
    return (1);
  }
#line 3979
  tmp___0 = strstr((char const   *)command, (char const   *)input);
#line 3979
  if ((unsigned long )tmp___0 == (unsigned long )command) {
#line 3980
    return (1);
  }
#line 3981
  return (0);
}
}
#line 3984 "option.c"
void OptionPerft(TREE *tree , int ply , int depth , int wtm ) 
{ 
  unsigned int *mv ;
  int tmp ;

  {
#line 3991
  tree->last[ply] = GenerateCaptures(tree, ply, wtm, tree->last[ply - 1]);
#line 3992
  mv = tree->last[ply - 1];
  {
#line 3992
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3992
    if (! ((unsigned long )mv < (unsigned long )tree->last[ply])) {
#line 3992
      goto while_break;
    }
#line 3993
    if (((*mv >> 15) & 7U) == 6U) {
#line 3994
      return;
    }
#line 3992
    mv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3995
  tree->last[ply] = GenerateNoncaptures(tree, ply, wtm, tree->last[ply]);
#line 3999
  mv = tree->last[ply - 1];
  {
#line 3999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3999
    if (! ((unsigned long )mv < (unsigned long )tree->last[ply])) {
#line 3999
      goto while_break___0;
    }
#line 4003
    MakeMove(tree, ply, wtm, (int )*mv);
#line 4013
    if (depth - 1) {
#line 4014
      OptionPerft(tree, ply + 1, depth - 1, wtm ^ 1);
    } else {
#line 4015
      tmp = Attacks(tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 4015
      if (! tmp) {
#line 4016
        total_moves ++;
      }
    }
#line 4017
    UnmakeMove(tree, ply, wtm, (int )*mv);
#line 3999
    mv ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4019
  return;
}
}
#line 17 "output.c"
static char text_move[10]  ;
#line 17 "output.c"
static char new_text[10]  ;
#line 20 "output.c"
static char const   piece_names[7]  = {      (char const   )' ',      (char const   )'P',      (char const   )'N',      (char const   )'B', 
        (char const   )'R',      (char const   )'Q',      (char const   )'K'};
#line 16 "output.c"
char *OutputMove(TREE *tree , int ply , int wtm , int move ) 
{ 
  unsigned int *mvp ;
  char *text___0 ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;

  {
#line 19
  text___0 = text_move;
#line 29
  if (move == 0) {
#line 30
    strcpy(text___0, (char const   *)"null");
#line 31
    return (text___0);
  }
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (((move >> 12) & 7) == 6) {
#line 41
      if ((move & 63) - ((move >> 6) & 63) > 0) {
#line 41
        tmp = (move & 63) - ((move >> 6) & 63);
      } else {
#line 41
        tmp = - ((move & 63) - ((move >> 6) & 63));
      }
#line 41
      if (tmp == 2) {
#line 42
        if (wtm) {
#line 43
          if (((move >> 6) & 63) == 2) {
#line 44
            strcpy(text_move, (char const   *)"O-O-O");
          } else {
#line 46
            strcpy(text_move, (char const   *)"O-O");
          }
        } else
#line 48
        if (((move >> 6) & 63) == 58) {
#line 49
          strcpy(text_move, (char const   *)"O-O-O");
        } else {
#line 51
          strcpy(text_move, (char const   *)"O-O");
        }
#line 53
        goto while_break;
      } else {
#line 41
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 63
    text___0 = new_text;
#line 64
    if (((move >> 12) & 7) > 1) {
#line 65
      tmp___0 = text___0;
#line 65
      text___0 ++;
#line 65
      *tmp___0 = (char )piece_names[(move >> 12) & 7];
    }
#line 66
    tmp___1 = text___0;
#line 66
    text___0 ++;
#line 66
    *tmp___1 = (char )(((move & 63) & 7) + 97);
#line 67
    tmp___2 = text___0;
#line 67
    text___0 ++;
#line 67
    *tmp___2 = (char )(((move & 63) >> 3) + 49);
#line 68
    if ((move >> 15) & 7) {
#line 69
      tmp___3 = text___0;
#line 69
      text___0 ++;
#line 69
      *tmp___3 = (char )'x';
    }
#line 70
    tmp___4 = text___0;
#line 70
    text___0 ++;
#line 70
    *tmp___4 = (char )((((move >> 6) & 63) & 7) + 97);
#line 71
    tmp___5 = text___0;
#line 71
    text___0 ++;
#line 71
    *tmp___5 = (char )((((move >> 6) & 63) >> 3) + 49);
#line 72
    if ((move >> 18) & 7) {
#line 73
      tmp___6 = text___0;
#line 73
      text___0 ++;
#line 73
      *tmp___6 = (char )'=';
#line 74
      tmp___7 = text___0;
#line 74
      text___0 ++;
#line 74
      *tmp___7 = (char )piece_names[(move >> 18) & 7];
    }
#line 76
    *text___0 = (char )'\000';
#line 77
    strcpy(text_move, (char const   *)(new_text));
#line 78
    if (output_format > 0) {
#line 79
      goto while_break;
    }
#line 90
    if (((move >> 12) & 7) == 1) {
#line 91
      if (! ((move >> 15) & 7)) {
#line 92
        strcpy(text_move, (char const   *)(new_text + 2));
#line 93
        tmp___8 = InputMove(tree, ply, wtm, 1, 0, text_move);
#line 93
        if (tmp___8) {
#line 94
          goto while_break;
        }
      }
#line 104
      text_move[0] = new_text[0];
#line 105
      strcpy(text_move + 1, (char const   *)(new_text + 2));
#line 106
      tmp___9 = InputMove(tree, ply, wtm, 1, 0, text_move);
#line 106
      if (tmp___9) {
#line 107
        goto while_break;
      }
#line 117
      strcpy(text_move, (char const   *)(new_text));
#line 118
      goto while_break;
    }
#line 129
    if (! ((move >> 15) & 7)) {
#line 130
      text_move[0] = new_text[0];
#line 131
      strcpy(text_move + 1, (char const   *)(new_text + 3));
#line 132
      tmp___10 = InputMove(tree, ply, wtm, 1, 0, text_move);
#line 132
      if (tmp___10) {
#line 133
        goto while_break;
      }
#line 143
      text_move[0] = new_text[0];
#line 144
      text_move[1] = new_text[1];
#line 145
      strcpy(text_move + 2, (char const   *)(new_text + 3));
#line 146
      tmp___11 = InputMove(tree, ply, wtm, 1, 0, text_move);
#line 146
      if (tmp___11) {
#line 147
        goto while_break;
      }
#line 148
      text_move[0] = new_text[0];
#line 149
      strcpy(text_move + 1, (char const   *)(new_text + 2));
#line 150
      tmp___12 = InputMove(tree, ply, wtm, 1, 0, text_move);
#line 150
      if (tmp___12) {
#line 151
        goto while_break;
      }
#line 159
      strcpy(text_move, (char const   *)(new_text));
#line 160
      goto while_break;
    } else {
#line 170
      text_move[0] = new_text[0];
#line 171
      strcpy(text_move + 1, (char const   *)(new_text + 3));
#line 172
      tmp___13 = InputMove(tree, ply, wtm, 1, 0, text_move);
#line 172
      if (tmp___13) {
#line 173
        goto while_break;
      }
#line 182
      text_move[0] = new_text[0];
#line 183
      text_move[1] = new_text[1];
#line 184
      strcpy(text_move + 2, (char const   *)(new_text + 3));
#line 185
      tmp___14 = InputMove(tree, ply, wtm, 1, 0, text_move);
#line 185
      if (tmp___14) {
#line 186
        goto while_break;
      }
#line 187
      text_move[0] = new_text[0];
#line 188
      strcpy(text_move + 1, (char const   *)(new_text + 2));
#line 189
      tmp___15 = InputMove(tree, ply, wtm, 1, 0, text_move);
#line 189
      if (tmp___15) {
#line 190
        goto while_break;
      }
#line 198
      strcpy(text_move, (char const   *)(new_text));
#line 199
      goto while_break;
    }
#line 33
    if (! 0) {
#line 33
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  if (output_format == 0) {
#line 211
    tmp___16 = strlen((char const   *)(text_move));
#line 211
    text___0 = text_move + tmp___16;
#line 212
    tree->status[129] = tree->status[ply];
#line 213
    MakeMove(tree, 129, wtm, move);
#line 214
    tmp___19 = Attacks(tree, (wtm ^ 1) ^ 1, tree->position.kingsq[wtm ^ 1]);
#line 214
    if (tmp___19) {
#line 215
      mvp = GenerateCheckEvasions(tree, 130, wtm ^ 1, tree->move_list + 4800);
#line 218
      if ((unsigned long )mvp == (unsigned long )(tree->move_list + 4800)) {
#line 219
        tmp___17 = text___0;
#line 219
        text___0 ++;
#line 219
        *tmp___17 = (char )'#';
      } else {
#line 221
        tmp___18 = text___0;
#line 221
        text___0 ++;
#line 221
        *tmp___18 = (char )'+';
      }
    }
#line 223
    UnmakeMove(tree, 129, wtm, move);
#line 224
    *text___0 = (char)0;
  }
#line 226
  return (text_move);
}
}
#line 23 "ponder.c"
int Ponder(int wtm ) 
{ 
  TREE *tree ;
  int dalpha ;
  int dbeta ;
  int i ;
  unsigned int *n_ponder_moves ;
  unsigned int *mv ;
  int save_move_number ;
  int tlom ;
  int value ;
  int illegal ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned int *tmp___6 ;

  {
#line 24
  tree = (TREE *)block[0];
#line 25
  dalpha = -999999;
#line 25
  dbeta = 999999;
#line 27
  illegal = 0;
#line 40
  if (! ponder) {
#line 40
    goto _L___1;
  } else
#line 40
  if (force) {
    _L___1: /* CIL Label */ 
#line 40
    goto _L___0;
  } else
#line 40
  if (over) {
    _L___0: /* CIL Label */ 
#line 40
    goto _L;
  } else {
#line 40
    tmp = CheckInput();
#line 40
    if (tmp) {
      _L: /* CIL Label */ 
#line 41
      return (0);
    }
  }
#line 42
  save_move_number = move_number;
#line 52
  strcpy(ponder_text, (char const   *)"none");
#line 53
  if (ponder_move) {
#line 54
    tmp___0 = VerifyMove((TREE *)tree, 1, wtm, ponder_move);
#line 54
    if (! tmp___0) {
#line 55
      ponder_move = 0;
#line 56
      Print(4095, "ERROR.  ponder_move is illegal (1).\n");
#line 57
      Print(4095, "ERROR.  PV pathl=%d\n", last_pv.pathl);
#line 58
      Print(4095, "ERROR.  move=%d  %x\n", ponder_move, ponder_move);
    }
  }
#line 71
  if (! ponder_move) {
#line 72
    HashProbe((TREE *)tree, 0, 0, wtm, dalpha, dbeta, & value);
#line 73
    if (tree->hash_move[0]) {
#line 74
      ponder_move = tree->hash_move[0];
    }
#line 75
    if (ponder_move) {
#line 76
      tmp___1 = VerifyMove((TREE *)tree, 1, wtm, ponder_move);
#line 76
      if (! tmp___1) {
#line 77
        Print(4095, "ERROR.  ponder_move is illegal (2).\n");
#line 78
        Print(4095, "ERROR.  move=%d  %x\n", ponder_move, ponder_move);
#line 79
        ponder_move = 0;
      }
    }
  }
#line 93
  if (! ponder_move) {
#line 94
    TimeSet(2);
#line 95
    if (time_limit < 20) {
#line 96
      return (0);
    }
#line 97
    puzzling = 1;
#line 98
    Print(32, "              puzzling over a move to ponder.\n");
#line 99
    last_pv.pathl = 0;
#line 100
    last_pv.pathd = 0;
#line 101
    i = 0;
    {
#line 101
    while (1) {
      while_continue: /* CIL Label */ ;
#line 101
      if (! (i < 129)) {
#line 101
        goto while_break;
      }
#line 102
      tree->killers[i].move1 = (uint32_t )0;
#line 103
      tree->killers[i].move2 = (uint32_t )0;
#line 101
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 105
    Iterate(wtm, 2, 0);
#line 106
    i = 0;
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 106
      if (! (i < 129)) {
#line 106
        goto while_break___0;
      }
#line 107
      tree->killers[i].move1 = (uint32_t )0;
#line 108
      tree->killers[i].move2 = (uint32_t )0;
#line 106
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 110
    puzzling = 0;
#line 111
    if (tree->pv[0].pathl) {
#line 112
      ponder_move = tree->pv[0].path[1];
    }
#line 113
    if (! ponder_move) {
#line 114
      return (0);
    }
#line 115
    i = 1;
    {
#line 115
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 115
      if (! (i < tree->pv[0].pathl)) {
#line 115
        goto while_break___1;
      }
#line 116
      last_pv.path[i] = tree->pv[0].path[i + 1];
#line 115
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 117
    last_pv.pathl = tree->pv[0].pathl - 1;
#line 118
    last_pv.pathd = 0;
#line 119
    tmp___2 = VerifyMove((TREE *)tree, 1, wtm, ponder_move);
#line 119
    if (! tmp___2) {
#line 120
      ponder_move = 0;
#line 121
      Print(4095, "ERROR.  ponder_move is illegal (3).\n");
#line 122
      Print(4095, "ERROR.  PV pathl=%d\n", last_pv.pathl);
#line 123
      return (0);
    }
  }
#line 133
  if (wtm) {
#line 134
    tmp___3 = OutputMove((TREE *)tree, 0, wtm, ponder_move);
#line 134
    Print(32, "White(%d): %s [pondering]\n", move_number, tmp___3);
  } else {
#line 137
    tmp___4 = OutputMove((TREE *)tree, 0, wtm, ponder_move);
#line 137
    Print(32, "Black(%d): %s [pondering]\n", move_number, tmp___4);
  }
#line 139
  tmp___5 = OutputMove((TREE *)tree, 0, wtm, ponder_move);
#line 139
  sprintf(ponder_text, (char const   *)"%s", tmp___5);
#line 140
  if (post) {
#line 141
    printf((char const   *)"Hint: %s\n", ponder_text);
  }
#line 152
  n_ponder_moves = GenerateCaptures((TREE *)tree, 0, wtm, ponder_moves);
#line 153
  tmp___6 = GenerateNoncaptures((TREE *)tree, 0, wtm, n_ponder_moves);
#line 153
  num_ponder_moves = (int )(tmp___6 - ponder_moves);
#line 155
  mv = ponder_moves;
  {
#line 155
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 155
    if (! ((unsigned long )mv < (unsigned long )(ponder_moves + num_ponder_moves))) {
#line 155
      goto while_break___2;
    }
#line 156
    MakeMove((TREE *)tree, 0, wtm, (int )*mv);
#line 157
    illegal = Attacks((TREE *)tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 158
    UnmakeMove((TREE *)tree, 0, wtm, (int )*mv);
#line 159
    if (illegal) {
#line 160
      *mv = 0U;
    }
#line 155
    mv ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 172
  MakeMove((TREE *)tree, 0, wtm, ponder_move);
#line 173
  tree->curmv[0] = ponder_move;
#line 174
  rep_index ++;
#line 174
  tree->rep_list[rep_index] = tree->position.hash_key;
#line 175
  tlom = last_opponent_move;
#line 176
  last_opponent_move = ponder_move;
#line 177
  if (kibitz) {
#line 178
    strcpy(kibitz_text, (char const   *)"n/a");
  }
#line 179
  thinking = 0;
#line 180
  pondering = 1;
#line 181
  if (! wtm) {
#line 182
    move_number ++;
  }
#line 183
  ponder_value = Iterate(wtm ^ 1, 1, 0);
#line 184
  rep_index --;
#line 185
  move_number = save_move_number;
#line 186
  pondering = 0;
#line 187
  thinking = 0;
#line 188
  last_opponent_move = tlom;
#line 189
  UnmakeMove((TREE *)tree, 0, wtm, ponder_move);
#line 216
  if (input_status == 1) {
#line 217
    return (1);
  }
#line 218
  if (input_status == 2) {
#line 219
    return (3);
  }
#line 220
  return (2);
}
}
#line 20 "resign.c"
void ResignOrDraw(TREE *tree , int value ) 
{ 
  int v ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char announce[128] ;
  char announce___0[128] ;

  {
#line 21
  result = 0;
#line 31
  tmp = Drawn(tree, value);
#line 31
  if (tmp == 1) {
#line 32
    result = 2;
  }
#line 54
  if (tc_increment > 200) {
#line 54
    goto _L___0;
  } else
#line 54
  if (tc_time_remaining[root_wtm ^ 1] >= 3000) {
    _L___0: /* CIL Label */ 
#line 55
    if (resign) {
#line 56
      if (value < -32753) {
#line 57
        resign_counter ++;
#line 57
        if (resign_counter >= resign_count) {
#line 58
          result = 1;
        }
      } else
#line 59
      if (value < - resign * 100) {
#line 59
        if (value > -32000) {
#line 60
          resign_counter ++;
#line 60
          if (resign_counter >= resign_count) {
#line 61
            result = 1;
          }
        } else {
#line 59
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 63
        resign_counter = 0;
      }
    }
  }
#line 79
  if (tc_increment > 200) {
#line 79
    goto _L___2;
  } else
#line 79
  if (tc_time_remaining[root_wtm ^ 1] >= 3000) {
    _L___2: /* CIL Label */ 
#line 80
    if (value > 0) {
#line 80
      tmp___7 = value;
    } else {
#line 80
      tmp___7 = - value;
    }
#line 80
    if (draw_score[game_wtm] > 0) {
#line 80
      tmp___8 = draw_score[game_wtm];
    } else {
#line 80
      tmp___8 = - draw_score[game_wtm];
    }
#line 80
    if (tmp___7 - tmp___8 > 0) {
#line 80
      if (value > 0) {
#line 80
        tmp___2 = value;
      } else {
#line 80
        tmp___2 = - value;
      }
#line 80
      if (draw_score[game_wtm] > 0) {
#line 80
        tmp___3 = draw_score[game_wtm];
      } else {
#line 80
        tmp___3 = - draw_score[game_wtm];
      }
#line 80
      tmp___6 = tmp___2 - tmp___3;
    } else {
#line 80
      if (value > 0) {
#line 80
        tmp___4 = value;
      } else {
#line 80
        tmp___4 = - value;
      }
#line 80
      if (draw_score[game_wtm] > 0) {
#line 80
        tmp___5 = draw_score[game_wtm];
      } else {
#line 80
        tmp___5 = - draw_score[game_wtm];
      }
#line 80
      tmp___6 = - (tmp___4 - tmp___5);
    }
#line 80
    if (tmp___6 < 2) {
#line 80
      if (moves_out_of_book > 3) {
#line 82
        draw_counter ++;
#line 82
        if (draw_counter >= draw_count) {
#line 83
          draw_counter = 0;
#line 84
          result = 2;
        }
      } else {
#line 80
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 87
      draw_counter = 0;
    }
  }
#line 102
  if (result == 1) {
#line 103
    if (crafty_is_white) {
#line 103
      learn_value = -300;
    } else {
#line 103
      learn_value = 300;
    }
#line 104
    LearnBook();
#line 105
    if (xboard) {
#line 106
      Print(4095, "resign\n");
    }
#line 107
    if (audible_alarm) {
#line 108
      printf((char const   *)"%c", (int )audible_alarm);
    }
#line 109
    if (speech) {
#line 112
      strcpy(announce, (char const   *)"./speak ");
#line 113
      strcat(announce, (char const   *)"Resign");
#line 114
      v = system((char const   *)(announce));
#line 115
      if (v <= 0) {
#line 116
        perror((char const   *)"ResignOrDraw() system() error: ");
      }
    }
#line 118
    if (crafty_is_white) {
#line 119
      Print(4095, "0-1 {White resigns}\n");
#line 120
      strcpy(pgn_result, (char const   *)"0-1");
    } else {
#line 122
      Print(4095, "1-0 {Black resigns}\n");
#line 123
      strcpy(pgn_result, (char const   *)"1-0");
    }
  }
#line 126
  if (offer_draws) {
#line 126
    if (result == 2) {
#line 127
      draw_offered = 1;
#line 128
      if (! xboard) {
#line 129
        Print(1, "\nI offer a draw.\n\n");
#line 130
        if (audible_alarm) {
#line 131
          printf((char const   *)"%c", (int )audible_alarm);
        }
#line 132
        if (speech) {
#line 135
          strcpy(announce___0, (char const   *)"./speak ");
#line 136
          strcat(announce___0, (char const   *)"Drawoffer");
#line 137
          v = system((char const   *)(announce___0));
#line 138
          if (v <= 0) {
#line 139
            perror((char const   *)"ResignOrDraw() system() error: ");
          }
        }
      } else
#line 141
      if (xboard) {
#line 142
        Print(4095, "offer draw\n");
      } else {
#line 144
        Print(4095, "\n*draw\n");
      }
    } else {
#line 126
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 146
    draw_offered = 0;
  }
#line 147
  return;
}
}
#line 18 "root.c"
void RootMoveList(int wtm ) 
{ 
  TREE *tree ;
  ROOT_MOVE rtemp ;
  unsigned int mvp ;
  unsigned int *lastm ;
  unsigned int rmoves[256] ;
  int value ;
  int done ;
  int tb_result ;
  int tb_root ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 19
  tree = (TREE *)block[0];
#line 24
  tb_root = -9;
#line 44
  EGTB_draw = 0;
#line 45
  if (swindle_mode) {
#line 46
    if (EGTBlimit) {
#line 46
      if ((int )tree->position.total_all_pieces <= EGTBlimit) {
#line 46
        if ((int )tree->status[1].castle[1] + (int )tree->status[1].castle[0] == 0) {
#line 48
          tmp = tb_probe_root(tree->position.color[1].pieces[0], tree->position.color[0].pieces[0],
                              tree->position.color[1].pieces[6] | tree->position.color[0].pieces[6],
                              tree->position.color[1].pieces[5] | tree->position.color[0].pieces[5],
                              tree->position.color[1].pieces[4] | tree->position.color[0].pieces[4],
                              tree->position.color[1].pieces[3] | tree->position.color[0].pieces[3],
                              tree->position.color[1].pieces[2] | tree->position.color[0].pieces[2],
                              tree->position.color[1].pieces[1] | tree->position.color[0].pieces[1],
                              (unsigned int )tree->status[1].reversible, 0U, (unsigned int )tree->status[1].enpassant_target,
                              (_Bool )wtm, (unsigned int *)((void *)0));
#line 48
          tb_result = (int )tmp;
#line 54
          if ((unsigned int )tb_result != 0xFFFFFFFF) {
#line 55
            tb_root = tb_result & 0x0000000F;
#line 56
            if (tb_root == 2) {
#line 56
              if (wtm) {
#line 56
                tmp___0 = tree->position.material_evaluation;
              } else {
#line 56
                tmp___0 = - tree->position.material_evaluation;
              }
#line 56
              if (tmp___0 > 0) {
#line 56
                goto _L;
              } else {
#line 56
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 56
            if (tb_root == 3) {
              _L: /* CIL Label */ 
#line 58
              EGTB_draw = 1;
            }
          }
        } else {
#line 46
          goto _L___2;
        }
      } else {
#line 46
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___1: /* CIL Label */ ;
    }
  }
#line 71
  lastm = GenerateCaptures((TREE *)tree, 1, wtm, rmoves);
#line 72
  lastm = GenerateNoncaptures((TREE *)tree, 1, wtm, lastm);
#line 73
  n_root_moves = (int )(lastm - rmoves);
#line 74
  mvp = 0U;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (mvp < (unsigned int )n_root_moves)) {
#line 74
      goto while_break;
    }
#line 75
    root_moves[mvp].move = (int )rmoves[mvp];
#line 74
    mvp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  abort_search = 0;
#line 91
  mvp = 0U;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (mvp < (unsigned int )n_root_moves)) {
#line 91
      goto while_break___0;
    }
#line 92
    value = -4000000;
#line 100
    MakeMove((TREE *)tree, 1, wtm, root_moves[mvp].move);
#line 101
    (tree->nodes_searched) ++;
#line 102
    tmp___3 = Attacks((TREE *)tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 102
    if (! tmp___3) {
      {
#line 103
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 104
        tree->curmv[1] = root_moves[mvp].move;
#line 106
        if (EGTB_draw) {
#line 106
          if ((int )tree->position.total_all_pieces <= EGTBlimit) {
#line 106
            if ((int )tree->status[2].castle[1] + (int )tree->status[2].castle[0] == 0) {
#line 108
              tmp___1 = tb_probe_root(tree->position.color[1].pieces[0], tree->position.color[0].pieces[0],
                                      tree->position.color[1].pieces[6] | tree->position.color[0].pieces[6],
                                      tree->position.color[1].pieces[5] | tree->position.color[0].pieces[5],
                                      tree->position.color[1].pieces[4] | tree->position.color[0].pieces[4],
                                      tree->position.color[1].pieces[3] | tree->position.color[0].pieces[3],
                                      tree->position.color[1].pieces[2] | tree->position.color[0].pieces[2],
                                      tree->position.color[1].pieces[1] | tree->position.color[0].pieces[1],
                                      (unsigned int )tree->status[2].reversible, 0U,
                                      (unsigned int )tree->status[2].enpassant_target,
                                      (_Bool )(wtm ^ 1), (unsigned int *)((void *)0));
#line 108
              tb_result = (int )tmp___1;
#line 114
              if ((unsigned int )tb_result != 0xFFFFFFFF) {
#line 115
                tb_result = 4 - (tb_result & 0x0000000F);
#line 116
                if (tb_result < tb_root) {
#line 117
                  goto while_break___1;
                }
              }
            } else {
#line 106
              goto _L___4;
            }
          } else {
#line 106
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          _L___3: /* CIL Label */ ;
        }
#line 121
        tmp___2 = Quiesce((TREE *)tree, 2, wtm ^ 1, -32768, 32768, 0);
#line 121
        value = - tmp___2;
#line 131
        if (((root_moves[mvp].move >> 12) & 7) == ((last_pv.path[1] >> 12) & 7)) {
#line 131
          if ((root_moves[mvp].move & 63) == (last_pv.path[1] & 63)) {
#line 131
            if (((root_moves[mvp].move >> 6) & 63) == ((last_pv.path[1] >> 6) & 63)) {
#line 131
              if (((root_moves[mvp].move >> 15) & 7) == ((last_pv.path[1] >> 15) & 7)) {
#line 131
                if (((root_moves[mvp].move >> 18) & 7) == ((last_pv.path[1] >> 18) & 7)) {
#line 136
                  value += 2000000;
                } else {
#line 131
                  goto _L___8;
                }
              } else {
#line 131
                goto _L___8;
              }
            } else {
#line 131
              goto _L___8;
            }
          } else {
#line 131
            goto _L___8;
          }
        } else {
          _L___8: /* CIL Label */ 
          _L___7: /* CIL Label */ 
          _L___6: /* CIL Label */ 
          _L___5: /* CIL Label */ ;
        }
#line 145
        if ((root_moves[mvp].move >> 18) & 7) {
#line 145
          if (((root_moves[mvp].move >> 18) & 7) != 5) {
#line 147
            value -= 50;
          } else {
#line 145
            goto _L___9;
          }
        } else {
          _L___9: /* CIL Label */ ;
        }
#line 103
        if (! 0) {
#line 103
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 149
    root_moves[mvp].path = tree->pv[1];
#line 150
    root_moves[mvp].path.pathv = value;
#line 151
    root_moves[mvp].status = 0U;
#line 152
    root_moves[mvp].bm_age = 0;
#line 153
    UnmakeMove((TREE *)tree, 1, wtm, root_moves[mvp].move);
#line 91
    mvp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 163
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 164
    done = 1;
#line 165
    mvp = 0U;
    {
#line 165
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 165
      if (! (mvp < (unsigned int )(n_root_moves - 1))) {
#line 165
        goto while_break___3;
      }
#line 166
      if (root_moves[mvp].path.pathv < root_moves[mvp + 1U].path.pathv) {
#line 167
        rtemp = root_moves[mvp];
#line 168
        root_moves[mvp] = root_moves[mvp + 1U];
#line 169
        root_moves[mvp + 1U] = rtemp;
#line 170
        done = 0;
      }
#line 165
      mvp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 163
    if (! (! done)) {
#line 163
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 185
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 185
    if (! n_root_moves) {
#line 185
      goto while_break___4;
    }
#line 186
    if (root_moves[n_root_moves - 1].path.pathv > -3000000) {
#line 187
      goto while_break___4;
    }
#line 185
    n_root_moves --;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 188
  if (root_moves[0].path.pathv > 1000000) {
#line 189
    root_moves[0].path.pathv -= 2000000;
  }
#line 198
  if (display_options & 128) {
#line 199
    Print(128, "%d moves at root\n", n_root_moves);
#line 200
    Print(128, "     score    move/pv\n");
#line 201
    mvp = 0U;
    {
#line 201
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 201
      if (! (mvp < (unsigned int )n_root_moves)) {
#line 201
        goto while_break___5;
      }
#line 202
      tmp___4 = DisplayPath((TREE *)tree, wtm, & root_moves[mvp].path);
#line 202
      tmp___5 = DisplayEvaluation(root_moves[mvp].path.pathv, wtm);
#line 202
      Print(128, "%10s    %s\n", tmp___5, tmp___4);
#line 201
      mvp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 215
  mvp = 1U;
  {
#line 215
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 215
    if (! (mvp < (unsigned int )n_root_moves)) {
#line 215
      goto while_break___6;
    }
#line 216
    root_moves[mvp].path.pathv = -32768;
#line 215
    mvp ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 237 "root.c"
int RootMoveEGTB(int wtm ) 
{ 
  TREE *tree ;
  int tb_result ;
  int result ;
  unsigned int tmp ;
  int value ;
  int piece ;
  int captured ;
  unsigned int cmove ;
  unsigned int omove ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 239
  tree = (TREE *)block[0];
#line 253
  EGTB_use = EGTBlimit;
#line 254
  if (EGTB_use <= 0) {
#line 255
    return (0);
  }
#line 256
  if (EGTB_draw) {
#line 256
    if (! puzzling) {
#line 256
      if (swindle_mode) {
#line 257
        EGTB_use = 0;
      } else {
#line 256
        goto _L___0;
      }
    } else {
#line 256
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ ;
  }
#line 258
  if (EGTBlimit) {
#line 258
    if (! EGTB_use) {
#line 259
      Print(32, "Drawn at root, trying for swindle.\n");
    } else {
#line 258
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 260
  if (EGTB_use) {
#line 260
    if ((int )tree->position.total_all_pieces <= EGTBlimit) {
#line 260
      if (! tree->status[0].castle[1]) {
#line 260
        if (! tree->status[0].castle[0]) {
#line 262
          (tree->egtb_probes) ++;
#line 263
          tmp = tb_probe_root(tree->position.color[1].pieces[0], tree->position.color[0].pieces[0],
                              tree->position.color[1].pieces[6] | tree->position.color[0].pieces[6],
                              tree->position.color[1].pieces[5] | tree->position.color[0].pieces[5],
                              tree->position.color[1].pieces[4] | tree->position.color[0].pieces[4],
                              tree->position.color[1].pieces[3] | tree->position.color[0].pieces[3],
                              tree->position.color[1].pieces[2] | tree->position.color[0].pieces[2],
                              tree->position.color[1].pieces[1] | tree->position.color[0].pieces[1],
                              (unsigned int )tree->status[1].reversible, 0U, (unsigned int )tree->status[1].enpassant_target,
                              (_Bool )wtm, (unsigned int *)((void *)0));
#line 263
          tb_result = (int )tmp;
#line 269
          if ((unsigned int )tb_result != 0xFFFFFFFF) {
#line 273
            if (n_root_moves > 0) {
#line 274
              (tree->egtb_hits) ++;
#line 275
              result = tb_result & 0x0000000F;
              {
#line 277
              if (result == 0) {
#line 277
                goto case_0;
              }
#line 280
              if (result == 4) {
#line 280
                goto case_4;
              }
#line 283
              if (result == 1) {
#line 283
                goto case_1;
              }
#line 286
              if (result == 2) {
#line 286
                goto case_2;
              }
#line 289
              if (result == 3) {
#line 289
                goto case_3;
              }
#line 292
              goto switch_default;
              case_0: /* CIL Label */ 
#line 278
              value = -31000;
#line 279
              goto switch_break;
              case_4: /* CIL Label */ 
#line 281
              value = 31000;
#line 282
              goto switch_break;
              case_1: /* CIL Label */ 
#line 284
              value = -3;
#line 285
              goto switch_break;
              case_2: /* CIL Label */ 
#line 287
              value = 0;
#line 288
              goto switch_break;
              case_3: /* CIL Label */ 
#line 290
              value = 3;
#line 291
              goto switch_break;
              switch_default: /* CIL Label */ 
#line 293
              value = (int )(((unsigned int )tb_result & 0xFFF00000) >> 20);
#line 294
              goto switch_break;
              switch_break: /* CIL Label */ ;
              }
#line 296
              if (result != 0) {
#line 296
                if (result != 4) {
#line 297
                  if (wtm) {
#line 297
                    tmp___1 = tree->position.material_evaluation;
                  } else {
#line 297
                    tmp___1 = - tree->position.material_evaluation;
                  }
#line 297
                  if (tmp___1 > 0) {
#line 298
                    value ++;
                  } else {
#line 299
                    if (wtm) {
#line 299
                      tmp___0 = tree->position.material_evaluation;
                    } else {
#line 299
                      tmp___0 = - tree->position.material_evaluation;
                    }
#line 299
                    if (tmp___0 < 0) {
#line 300
                      value --;
                    }
                  }
                } else {
#line 296
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ ;
              }
#line 302
              piece = abs((int )tree->position.board[(tb_result & 0x0000FC00) >> 10]);
#line 303
              captured = abs((int )tree->position.board[(tb_result & 0x000003F0) >> 4]);
#line 304
              cmove = (unsigned int )(((((tb_result & 0x0000FC00) >> 10) | (((tb_result & 0x000003F0) >> 4) << 6)) | (piece << 12)) | (captured << 15));
#line 307
              if ((tb_result & 0x00070000) >> 16) {
#line 308
                cmove |= (unsigned int )((6 - ((tb_result & 0x00070000) >> 16)) << 18);
              }
#line 309
              end_time = ReadClock();
#line 310
              tree->pv[0].path[1] = (int )cmove;
#line 311
              tree->pv[0].pathl = 2;
#line 312
              tree->pv[0].pathh = 4;
#line 313
              tree->pv[0].pathd = 0;
#line 314
              tree->pv[0].pathv = value;
#line 315
              MakeMove((TREE *)tree, 1, wtm, (int )cmove);
#line 316
              result = Mated((TREE *)tree, 2, wtm ^ 1);
#line 317
              UnmakeMove((TREE *)tree, 1, wtm, (int )cmove);
#line 318
              if (result == 1) {
#line 319
                tree->pv[0].pathv = 32766;
              } else
#line 320
              if (result == 2) {
#line 321
                tree->pv[0].pathv = draw_score[wtm];
              } else {
#line 332
                MakeMove((TREE *)tree, 1, wtm, (int )cmove);
#line 333
                (tree->egtb_probes) ++;
#line 334
                tmp___2 = tb_probe_root(tree->position.color[1].pieces[0], tree->position.color[0].pieces[0],
                                        tree->position.color[1].pieces[6] | tree->position.color[0].pieces[6],
                                        tree->position.color[1].pieces[5] | tree->position.color[0].pieces[5],
                                        tree->position.color[1].pieces[4] | tree->position.color[0].pieces[4],
                                        tree->position.color[1].pieces[3] | tree->position.color[0].pieces[3],
                                        tree->position.color[1].pieces[2] | tree->position.color[0].pieces[2],
                                        tree->position.color[1].pieces[1] | tree->position.color[0].pieces[1],
                                        (unsigned int )tree->status[2].reversible,
                                        0U, (unsigned int )tree->status[2].enpassant_target,
                                        (_Bool )(wtm ^ 1), (unsigned int *)((void *)0));
#line 334
                tb_result = (int )tmp___2;
#line 340
                if ((unsigned int )tb_result != 0xFFFFFFFF) {
#line 341
                  (tree->egtb_hits) ++;
#line 342
                  piece = abs((int )tree->position.board[(tb_result & 0x0000FC00) >> 10]);
#line 343
                  captured = abs((int )tree->position.board[(tb_result & 0x000003F0) >> 4]);
#line 344
                  omove = (unsigned int )(((((tb_result & 0x0000FC00) >> 10) | (((tb_result & 0x000003F0) >> 4) << 6)) | (piece << 12)) | (captured << 15));
#line 347
                  if ((tb_result & 0x00070000) >> 16) {
#line 348
                    omove |= (unsigned int )((6 - ((tb_result & 0x00070000) >> 16)) << 18);
                  }
#line 349
                  end_time = ReadClock();
#line 350
                  tree->pv[0].path[2] = (int )omove;
#line 351
                  tree->pv[0].pathl = 3;
                }
#line 353
                UnmakeMove((TREE *)tree, 1, wtm, (int )cmove);
              }
            }
#line 365
            Print(2, "        depth     time       score   variation\n");
#line 366
            if (n_root_moves == 0) {
#line 367
              program_end_time = ReadClock();
#line 368
              tree->pv[0].pathl = 0;
#line 369
              tree->pv[0].pathd = 0;
#line 370
              tmp___3 = Attacks((TREE *)tree, wtm ^ 1, tree->position.kingsq[wtm]);
#line 370
              if (tmp___3) {
#line 371
                value = -32767;
              } else {
#line 373
                value = draw_score[wtm];
              }
#line 374
              Print(2, "                             Mated   (no moves)\n");
#line 375
              tree->nodes_searched = (uint64_t )1;
#line 376
              if (! puzzling) {
#line 377
                last_root_value = value;
              }
#line 378
              return (1);
            }
#line 380
            DisplayPV((TREE *)tree, 5, wtm, (int )(end_time - start_time), & tree->pv[0],
                      1);
#line 381
            return (1);
          }
        } else {
#line 260
          goto _L___5;
        }
      } else {
#line 260
        goto _L___5;
      }
    } else {
#line 260
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
    _L___3: /* CIL Label */ ;
  }
#line 385
  return (0);
}
}
#line 51 "setboard.c"
static char const   bdinfo[23]  = 
#line 51 "setboard.c"
  {      (char const   )'k',      (char const   )'q',      (char const   )'r',      (char const   )'b', 
        (char const   )'n',      (char const   )'p',      (char const   )'*',      (char const   )'P', 
        (char const   )'N',      (char const   )'B',      (char const   )'R',      (char const   )'Q', 
        (char const   )'K',      (char const   )'*',      (char const   )'1',      (char const   )'2', 
        (char const   )'3',      (char const   )'4',      (char const   )'5',      (char const   )'6', 
        (char const   )'7',      (char const   )'8',      (char const   )'/'};
#line 56 "setboard.c"
static char const   status[13]  = 
#line 56
  {      (char const   )'K',      (char const   )'Q',      (char const   )'k',      (char const   )'q', 
        (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )' '};
#line 60 "setboard.c"
static int const   firstsq[8]  = 
#line 60
  {      (int const   )56,      (int const   )48,      (int const   )40,      (int const   )32, 
        (int const   )24,      (int const   )16,      (int const   )8,      (int const   )0};
#line 47 "setboard.c"
void SetBoard(TREE *tree , int nargs___0 , char **args___0 , int special ) 
{ 
  int twtm ;
  int i ;
  int match ;
  int num ;
  int pos ;
  int square ;
  int tboard[64] ;
  int bcastle ;
  int ep ;
  int wcastle ;
  int error ;
  int whichsq ;
  char input[80] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 49
  error = 0;
#line 62
  if (special) {
#line 63
    strcpy(input, (char const   *)(initial_position));
  } else {
#line 65
    strcpy(input, (char const   *)*(args___0 + 0));
  }
#line 66
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < 64)) {
#line 66
      goto while_break;
    }
#line 67
    tboard[i] = 0;
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  whichsq = 0;
#line 78
  square = (int )firstsq[whichsq];
#line 79
  num = 0;
#line 80
  pos = 0;
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    tmp___0 = strlen((char const   *)*(args___0 + 0));
#line 80
    if (! (pos < (int )tmp___0)) {
#line 80
      goto while_break___0;
    }
#line 81
    match = 0;
    {
#line 81
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 81
      if (match < 23) {
#line 81
        if (! ((int )*(*(args___0 + 0) + pos) != (int )bdinfo[match])) {
#line 81
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 81
        goto while_break___1;
      }
#line 81
      match ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 82
    if (match > 22) {
#line 83
      goto while_break___0;
    } else
#line 87
    if (match == 22) {
#line 88
      num = 0;
#line 89
      if (whichsq > 6) {
#line 90
        goto while_break___0;
      }
#line 91
      whichsq ++;
#line 91
      square = (int )firstsq[whichsq];
    } else
#line 96
    if (match >= 14) {
#line 97
      num += match - 13;
#line 98
      square += match - 13;
#line 99
      if (num > 8) {
#line 100
        printf((char const   *)"more than 8 squares on one rank\n");
#line 101
        error = 1;
#line 102
        goto while_break___0;
      }
#line 104
      goto __Cont;
    } else {
#line 110
      num ++;
#line 110
      if (num > 8) {
#line 111
        printf((char const   *)"more than 8 squares on one rank\n");
#line 112
        error = 1;
#line 113
        goto while_break___0;
      }
#line 115
      tmp = square;
#line 115
      square ++;
#line 115
      tboard[tmp] = match - 6;
    }
    __Cont: /* CIL Label */ 
#line 80
    pos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 127
  twtm = 0;
#line 128
  ep = 0;
#line 129
  wcastle = 0;
#line 130
  bcastle = 0;
#line 138
  if ((int )*(*(args___0 + 1) + 0) == 119) {
#line 139
    twtm = 1;
  } else
#line 140
  if ((int )*(*(args___0 + 1) + 0) == 98) {
#line 141
    twtm = 0;
  } else {
#line 143
    printf((char const   *)"side to move is bad\n");
#line 144
    error = 1;
  }
#line 153
  if (nargs___0 > 2) {
#line 153
    tmp___3 = strlen((char const   *)*(args___0 + 2));
#line 153
    if (tmp___3) {
#line 154
      tmp___2 = strcmp((char const   *)*(args___0 + 2), (char const   *)"-");
#line 154
      if (tmp___2) {
#line 155
        pos = 0;
        {
#line 155
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 155
          tmp___1 = strlen((char const   *)*(args___0 + 2));
#line 155
          if (! (pos < (int )tmp___1)) {
#line 155
            goto while_break___2;
          }
#line 156
          match = 0;
          {
#line 156
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 156
            if (match < 13) {
#line 156
              if (! ((int )*(*(args___0 + 2) + pos) != (int )status[match])) {
#line 156
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
#line 156
              goto while_break___3;
            }
#line 156
            match ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 158
          if (match == 0) {
#line 159
            wcastle ++;
          } else
#line 160
          if (match == 1) {
#line 161
            wcastle += 2;
          } else
#line 162
          if (match == 2) {
#line 163
            bcastle ++;
          } else
#line 164
          if (match == 3) {
#line 165
            bcastle += 2;
          } else
#line 166
          if ((int )*(*(args___0 + 2) + 0) != 45) {
#line 167
            printf((char const   *)"castling status is bad.\n");
#line 168
            error = 1;
          }
#line 155
          pos ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
#line 153
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 173
  if (nargs___0 > 3) {
#line 173
    tmp___5 = strlen((char const   *)*(args___0 + 3));
#line 173
    if (tmp___5) {
#line 174
      tmp___4 = strcmp((char const   *)*(args___0 + 3), (char const   *)"-");
#line 174
      if (tmp___4) {
#line 175
        if ((int )*(*(args___0 + 3) + 0) >= 97) {
#line 175
          if ((int )*(*(args___0 + 3) + 0) <= 104) {
#line 175
            if ((int )*(*(args___0 + 3) + 1) > 48) {
#line 175
              if ((int )*(*(args___0 + 3) + 1) < 57) {
#line 177
                ep = (((int )*(*(args___0 + 3) + 1) - 49) * 8 + (int )*(*(args___0 + 3) + 0)) - 97;
              } else {
#line 175
                goto _L___4;
              }
            } else {
#line 175
              goto _L___4;
            }
          } else {
#line 175
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
        _L___3: /* CIL Label */ 
        _L___2: /* CIL Label */ 
#line 178
        if ((int )*(*(args___0 + 3) + 0) != 45) {
#line 179
          printf((char const   *)"enpassant status is bad.\n");
#line 180
          error = 1;
        }
      }
    } else {
#line 173
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ ;
  }
#line 184
  i = 0;
  {
#line 184
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 184
    if (! (i < 64)) {
#line 184
      goto while_break___4;
    }
#line 185
    tree->position.board[i] = (int8_t )tboard[i];
#line 184
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 186
  tree->status[0].castle[1] = (int8_t )wcastle;
#line 187
  tree->status[0].castle[0] = (int8_t )bcastle;
#line 188
  tree->status[0].enpassant_target = (uint8_t )0;
#line 189
  if (ep) {
    {
#line 190
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 191
      if (twtm) {
#line 191
        if (ep >> 3 == 5) {
#line 191
          if ((int )tree->position.board[ep - 8] == -1) {
#line 192
            if ((ep & 7) != 7) {
#line 192
              if ((int )tree->position.board[ep - 7] == 1) {
#line 193
                goto while_break___5;
              } else {
#line 192
                goto _L___6;
              }
            } else {
              _L___6: /* CIL Label */ ;
            }
#line 194
            if ((ep & 7) != 0) {
#line 194
              if ((int )tree->position.board[ep - 9] == 1) {
#line 195
                goto while_break___5;
              } else {
#line 194
                goto _L___7;
              }
            } else {
              _L___7: /* CIL Label */ ;
            }
          } else {
#line 191
            goto _L___13;
          }
        } else {
#line 191
          goto _L___13;
        }
      } else
      _L___13: /* CIL Label */ 
      _L___12: /* CIL Label */ 
#line 196
      if (! twtm) {
#line 196
        if (ep >> 3 == 2) {
#line 196
          if ((int )tree->position.board[ep + 8] == 1) {
#line 197
            if ((ep & 7) != 0) {
#line 197
              if ((int )tree->position.board[ep + 7] == -1) {
#line 198
                goto while_break___5;
              } else {
#line 197
                goto _L___8;
              }
            } else {
              _L___8: /* CIL Label */ ;
            }
#line 199
            if ((ep & 7) != 7) {
#line 199
              if ((int )tree->position.board[ep + 9] == -1) {
#line 200
                goto while_break___5;
              } else {
#line 199
                goto _L___9;
              }
            } else {
              _L___9: /* CIL Label */ ;
            }
          } else {
#line 196
            goto _L___11;
          }
        } else {
#line 196
          goto _L___11;
        }
      } else {
        _L___11: /* CIL Label */ 
        _L___10: /* CIL Label */ 
#line 202
        ep = 0;
      }
#line 204
      if (! ep) {
#line 205
        printf((char const   *)"enpassant status is bad.\n");
#line 206
        ep = 0;
#line 207
        error = 1;
      }
#line 190
      if (! 0) {
#line 190
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 210
    tree->status[0].enpassant_target = (uint8_t )ep;
  }
#line 220
  if ((int )tree->status[0].castle[1] & 2) {
#line 220
    if ((int )tree->position.board[0] != 4) {
#line 220
      goto _L___18;
    } else {
#line 220
      goto _L___20;
    }
  } else
  _L___20: /* CIL Label */ 
#line 220
  if ((int )tree->status[0].castle[1] & 1) {
#line 220
    if ((int )tree->position.board[7] != 4) {
      _L___18: /* CIL Label */ 
#line 220
      goto _L___16;
    } else {
#line 220
      goto _L___19;
    }
  } else
  _L___19: /* CIL Label */ 
#line 220
  if ((int )tree->status[0].castle[0] & 2) {
#line 220
    if ((int )tree->position.board[56] != -4) {
      _L___16: /* CIL Label */ 
#line 220
      goto _L___14;
    } else {
#line 220
      goto _L___17;
    }
  } else
  _L___17: /* CIL Label */ 
#line 220
  if ((int )tree->status[0].castle[0] & 1) {
#line 220
    if ((int )tree->position.board[63] != -4) {
      _L___14: /* CIL Label */ 
#line 224
      printf((char const   *)"ERROR-- castling status does not match board position\n");
#line 225
      error = 1;
    } else {
#line 220
      goto _L___15;
    }
  } else {
    _L___15: /* CIL Label */ ;
  }
#line 234
  SetChessBitBoards(tree);
#line 245
  game_wtm = twtm;
#line 246
  tmp___6 = InvalidPosition(tree);
#line 246
  error += tmp___6;
#line 247
  if (! error) {
#line 248
    if (log_file) {
#line 249
      DisplayChessBoard(log_file, tree->position);
    }
#line 250
    rep_index = 0;
#line 251
    tree->rep_list[0] = tree->position.hash_key;
#line 252
    tree->status[0].reversible = (uint8_t )0;
#line 253
    if (! special) {
#line 254
      last_mate_score = 0;
#line 255
      InitializeKillers();
#line 256
      last_pv.pathd = 0;
#line 257
      last_pv.pathl = 0;
#line 258
      tree->pv[0].pathd = 0;
#line 259
      tree->pv[0].pathl = 0;
#line 260
      moves_out_of_book = 0;
    }
  } else {
#line 263
    if (special) {
#line 264
      Print(4095, "bad string = \"%s\"\n", initial_position);
    } else {
#line 266
      Print(4095, "bad string = \"%s\"\n", *(args___0 + 0));
    }
#line 267
    InitializeChessBoard(tree);
#line 268
    Print(4095, "Illegal position, using normal initial chess position\n");
  }
#line 270
  return;
}
}
#line 36 "test.c"
void Test(char *filename , FILE *unsolved , int screen , int margin ) 
{ 
  TREE *tree ;
  FILE *test_input ;
  uint64_t nodes ;
  int i ;
  int move ;
  int right ;
  int wrong ;
  int correct ;
  int time___0 ;
  int len ;
  int nfailed ;
  float avg_depth ;
  char failed[8][4096] ;
  char *eof ;
  char *delim ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 37
  tree = (TREE *)block[0];
#line 39
  nodes = (uint64_t )0;
#line 40
  right = 0;
#line 40
  wrong = 0;
#line 40
  time___0 = 0;
#line 40
  nfailed = 0;
#line 41
  avg_depth = (float )0.0;
#line 54
  test_input = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 54
  if (! test_input) {
#line 55
    printf((char const   *)"file %s does not exist.\n", filename);
#line 56
    return;
  }
#line 58
  Print(4095, "\n");
#line 59
  eof = fgets(buffer, 4096, test_input);
#line 60
  tmp = strstr((char const   *)(buffer), (char const   *)"title");
#line 60
  if (! tmp) {
#line 61
    fclose(test_input);
#line 62
    TestEPD(filename, unsolved, screen, margin);
#line 63
    return;
  }
#line 65
  if (book_file) {
#line 66
    fclose(book_file);
#line 67
    book_file = (FILE *)0;
  }
#line 69
  if (books_file) {
#line 70
    fclose(books_file);
#line 71
    books_file = (FILE *)0;
  }
#line 73
  fclose(test_input);
#line 74
  test_input = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! 1) {
#line 75
      goto while_break;
    }
#line 76
    eof = fgets(buffer, 4096, test_input);
#line 77
    tmp___0 = nfailed;
#line 77
    nfailed ++;
#line 77
    strcpy(failed[tmp___0], (char const   *)(buffer));
#line 78
    if (eof) {
#line 79
      delim = strchr((char const   *)(buffer), '\n');
#line 80
      if (delim) {
#line 81
        *delim = (char)0;
      }
#line 82
      delim = strchr((char const   *)(buffer), '\r');
#line 83
      if (delim) {
#line 84
        *delim = (char )' ';
      }
    } else {
#line 86
      goto while_break;
    }
#line 87
    nargs = ReadParse(buffer, args, " \t;");
#line 88
    tmp___10 = strcmp((char const   *)args[0], (char const   *)"end");
#line 88
    if (tmp___10) {
#line 90
      tmp___9 = strcmp((char const   *)args[0], (char const   *)"title");
#line 90
      if (tmp___9) {
#line 108
        tmp___8 = strcmp((char const   *)args[0], (char const   *)"solution");
#line 108
        if (tmp___8) {
#line 109
          Option((TREE *)tree);
        } else {
#line 111
          number_of_solutions = 0;
#line 112
          solution_type = 0;
#line 113
          Print(4095, "solution ");
#line 114
          i = 1;
          {
#line 114
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 114
            if (! (i < nargs)) {
#line 114
              goto while_break___0;
            }
#line 115
            tmp___5 = strlen((char const   *)args[i]);
#line 115
            if ((int )*(args[i] + (tmp___5 - 1UL)) == 63) {
#line 116
              solution_type = 1;
#line 117
              tmp___2 = strlen((char const   *)args[i]);
#line 117
              *(args[i] + (tmp___2 - 1UL)) = (char )'\000';
            } else {
#line 118
              tmp___4 = strlen((char const   *)args[i]);
#line 118
              if ((int )*(*((args + i) + (tmp___4 - 1UL))) == 33) {
#line 119
                solution_type = 0;
#line 120
                tmp___3 = strlen((char const   *)args[i]);
#line 120
                *(args[i] + (tmp___3 - 1UL)) = (char )'\000';
              }
            }
#line 122
            move = InputMove((TREE *)tree, 0, game_wtm, 0, 0, args[i]);
#line 123
            if (move) {
#line 124
              solutions[number_of_solutions] = move;
#line 125
              tmp___6 = OutputMove((TREE *)tree, 0, game_wtm, move);
#line 125
              tmp___7 = number_of_solutions;
#line 125
              number_of_solutions ++;
#line 125
              Print(4095, "%d. %s", tmp___7 + 1, tmp___6);
#line 127
              if (solution_type == 1) {
#line 128
                Print(4095, "? ");
              } else {
#line 130
                Print(4095, "  ");
              }
            } else {
#line 132
              DisplayChessBoard(stdout, tree->position);
            }
#line 114
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 134
          Print(4095, "\n");
#line 135
          InitializeHashTables(0);
#line 136
          last_pv.pathd = 0;
#line 137
          thinking = 1;
#line 138
          tree->status[1] = tree->status[0];
#line 139
          Iterate(game_wtm, 1, 0);
#line 140
          thinking = 0;
#line 141
          nodes += tree->nodes_searched;
#line 142
          avg_depth += (float )iteration;
#line 143
          time___0 = (int )((unsigned int )time___0 + (end_time - start_time));
#line 144
          correct = solution_type;
#line 145
          i = 0;
          {
#line 145
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 145
            if (! (i < number_of_solutions)) {
#line 145
              goto while_break___1;
            }
#line 146
            if (! solution_type) {
#line 147
              if (solutions[i] == (tree->pv[1].path[1] & 0x001fffff)) {
#line 148
                correct = 1;
              }
            } else
#line 149
            if (solutions[i] == (tree->pv[1].path[1] & 0x001fffff)) {
#line 150
              correct = 0;
            }
#line 145
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 152
          if (correct) {
#line 153
            right ++;
#line 154
            Print(4095, "----------------------> solution correct (%d/%d).\n", right,
                  right + wrong);
          } else {
#line 157
            wrong ++;
#line 158
            Print(4095, "----------------------> solution incorrect (%d/%d).\n", right,
                  right + wrong);
#line 160
            if (unsolved) {
#line 161
              i = 0;
              {
#line 161
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 161
                if (! (i < nfailed)) {
#line 161
                  goto while_break___2;
                }
#line 162
                fputs((char const   * __restrict  )(failed[i]), (FILE * __restrict  )unsolved);
#line 161
                i ++;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
          }
#line 164
          nfailed = 0;
        }
      } else {
#line 91
        Print(4095, "======================================================================\n");
#line 94
        Print(4095, "! ");
#line 95
        len = 0;
#line 96
        i = 1;
        {
#line 96
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 96
          if (! (i < nargs)) {
#line 96
            goto while_break___3;
          }
#line 97
          Print(4095, "%s ", args[i]);
#line 98
          tmp___1 = strlen((char const   *)args[i]);
#line 98
          len = (int )((size_t )len + (tmp___1 + 1UL));
#line 99
          if (len > 65) {
#line 100
            goto while_break___3;
          }
#line 96
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 102
        i = len;
        {
#line 102
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 102
          if (! (i < 67)) {
#line 102
            goto while_break___4;
          }
#line 103
          printf((char const   *)" ");
#line 102
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 104
        Print(4095, "!\n");
#line 105
        Print(4095, "======================================================================\n");
      }
    } else {
#line 89
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  if (right + wrong) {
#line 175
    Print(4095, "\n\n\n");
#line 176
    Print(4095, "test results summary:\n\n");
#line 177
    Print(4095, "total positions searched..........%12d\n", right + wrong);
#line 178
    Print(4095, "number right......................%12d\n", right);
#line 179
    Print(4095, "number wrong......................%12d\n", wrong);
#line 180
    Print(4095, "percentage right..................%12d\n", (right * 100) / (right + wrong));
#line 182
    Print(4095, "percentage wrong..................%12d\n", (wrong * 100) / (right + wrong));
#line 184
    Print(4095, "total nodes searched..............%12lu\n", nodes);
#line 185
    Print(4095, "average search depth..............%12.1f\n", (double )(avg_depth / (float )(right + wrong)));
#line 187
    if (time___0 > 1) {
#line 187
      tmp___11 = time___0;
    } else {
#line 187
      tmp___11 = 1;
    }
#line 187
    Print(4095, "nodes per second..................%12lu\n", (nodes * 100UL) / (uint64_t )tmp___11);
#line 189
    tmp___12 = DisplayTime((unsigned int )time___0);
#line 189
    Print(4095, "total time........................%12s\n", tmp___12);
  }
#line 192
  input_stream = stdin;
#line 193
  early_exit = 99;
#line 194
  fclose(test_input);
#line 195
  return;
}
}
#line 226 "test.c"
void TestEPD(char *filename , FILE *unsolved , int screen , int margin ) 
{ 
  TREE *tree ;
  FILE *test_input ;
  FILE *test_output ;
  uint64_t nodes ;
  int i ;
  int move ;
  int right ;
  int wrong ;
  int correct ;
  int time___0 ;
  int len ;
  int culled ;
  int r ;
  float avg_depth ;
  char *eof ;
  char *mvs ;
  char *title ;
  char tbuffer[512] ;
  char failed[4096] ;
  char outfile[256] ;
  char *delim ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
#line 227
  tree = (TREE *)block[0];
#line 228
  test_output = (FILE *)0;
#line 229
  nodes = (uint64_t )0;
#line 230
  right = 0;
#line 230
  wrong = 0;
#line 230
  time___0 = 0;
#line 230
  culled = 0;
#line 230
  r = 0;
#line 232
  avg_depth = (float )0.0;
#line 245
  test_input = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 245
  if (! test_input) {
#line 246
    printf((char const   *)"file %s does not exist.\n", filename);
#line 247
    return;
  }
#line 249
  if (screen) {
#line 252
    strcpy(outfile, (char const   *)filename);
#line 253
    strcat(outfile, (char const   *)".screened");
#line 254
    test_output = fopen((char const   * __restrict  )(outfile), (char const   * __restrict  )"w");
#line 254
    if (! test_output) {
#line 255
      printf((char const   *)"file %s cannot be opened for write.\n", filename);
#line 256
      return;
    }
  }
#line 259
  if (book_file) {
#line 260
    fclose(book_file);
#line 261
    book_file = (FILE *)0;
  }
#line 263
  if (books_file) {
#line 264
    fclose(books_file);
#line 265
    books_file = (FILE *)0;
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! 1) {
#line 267
      goto while_break;
    }
#line 268
    eof = fgets(buffer, 4096, test_input);
#line 269
    strcpy(failed, (char const   *)(buffer));
#line 270
    Print(4095, "%s\n", buffer);
#line 271
    strcpy(tbuffer, (char const   *)(buffer));
#line 272
    if (eof) {
#line 275
      delim = strchr((char const   *)(buffer), '\n');
#line 276
      if (delim) {
#line 277
        *delim = (char)0;
      }
#line 278
      delim = strchr((char const   *)(buffer), '\r');
#line 279
      if (delim) {
#line 280
        *delim = (char )' ';
      }
    } else {
#line 282
      goto while_break;
    }
#line 283
    r ++;
#line 284
    mvs = strstr((char const   *)(buffer), (char const   *)" sd ");
#line 285
    if (mvs) {
#line 286
      search_depth = atoi((char const   *)(mvs + 3));
#line 287
      *(mvs - 1) = (char)0;
#line 288
      Print(4095, "search depth %d\n", search_depth);
    }
#line 290
    mvs = strstr((char const   *)(buffer), (char const   *)" bm ");
#line 291
    if (! mvs) {
#line 292
      mvs = strstr((char const   *)(buffer), (char const   *)" am ");
    }
#line 293
    if (! mvs) {
#line 293
      if (! screen) {
#line 294
        Print(4095, "Warning. am/bm field missing, input string follows\n%s\n", buffer);
      } else {
#line 293
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 296
    if (mvs) {
#line 297
      mvs ++;
    }
#line 298
    title = strstr((char const   *)(buffer), (char const   *)"id");
#line 299
    if (mvs) {
#line 300
      *(mvs - 1) = (char)0;
    }
#line 301
    if (title) {
#line 302
      *(title - 1) = (char)0;
    }
#line 303
    if (title) {
#line 304
      tmp = strchr((char const   *)title, '\"');
#line 304
      title = tmp + 1;
#line 305
      if (title) {
#line 306
        tmp___1 = strchr((char const   *)title, '\"');
#line 306
        if (tmp___1) {
#line 307
          tmp___0 = strchr((char const   *)title, '\"');
#line 307
          *tmp___0 = (char)0;
        }
      }
#line 310
      Print(4095, "======================================================================\n");
#line 313
      Print(4095, "! ");
#line 314
      Print(4095, "%s ", title);
#line 315
      tmp___2 = strlen((char const   *)title);
#line 315
      len = (int )(66UL - tmp___2);
#line 316
      i = 0;
      {
#line 316
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 316
        if (! (i < len)) {
#line 316
          goto while_break___0;
        }
#line 317
        printf((char const   *)" ");
#line 316
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 318
      Print(4095, "!\n");
#line 319
      Print(4095, "======================================================================\n");
    }
#line 323
    Option((TREE *)tree);
#line 324
    if (mvs) {
#line 325
      nargs = ReadParse(mvs, args, " \t;");
#line 326
      number_of_solutions = 0;
#line 327
      solution_type = 0;
#line 328
      tmp___3 = strcmp((char const   *)args[0], (char const   *)"am");
#line 328
      if (! tmp___3) {
#line 329
        solution_type = 1;
      }
#line 330
      Print(4095, "solution ");
#line 331
      i = 1;
      {
#line 331
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 331
        if (! (i < nargs)) {
#line 331
          goto while_break___1;
        }
#line 332
        tmp___4 = strcmp((char const   *)args[i], (char const   *)"c0");
#line 332
        if (! tmp___4) {
#line 333
          goto while_break___1;
        }
#line 334
        move = InputMove((TREE *)tree, 0, game_wtm, 0, 0, args[i]);
#line 335
        if (move) {
#line 336
          solutions[number_of_solutions] = move;
#line 337
          tmp___5 = OutputMove((TREE *)tree, 0, game_wtm, move);
#line 337
          tmp___6 = number_of_solutions;
#line 337
          number_of_solutions ++;
#line 337
          Print(4095, "%d. %s", tmp___6 + 1, tmp___5);
#line 339
          if (solution_type == 1) {
#line 340
            Print(4095, "? ");
          } else {
#line 342
            Print(4095, "  ");
          }
        } else {
#line 344
          DisplayChessBoard(stdout, tree->position);
        }
#line 331
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 347
    Print(4095, "\n");
#line 348
    InitializeHashTables(0);
#line 349
    last_pv.pathd = 0;
#line 350
    thinking = 1;
#line 351
    tree->status[1] = tree->status[0];
#line 352
    Iterate(game_wtm, 1, 0);
#line 353
    if (screen) {
#line 354
      if (last_root_value > 0) {
#line 354
        tmp___8 = last_root_value;
      } else {
#line 354
        tmp___8 = - last_root_value;
      }
#line 354
      if (tmp___8 < margin) {
#line 355
        tmp___7 = strlen((char const   *)(tbuffer));
#line 355
        fwrite((void const   * __restrict  )(tbuffer), (size_t )1, tmp___7, (FILE * __restrict  )test_output);
      } else {
#line 357
        culled ++;
      }
#line 358
      tmp___9 = DisplayEvaluation(last_root_value, game_wtm);
#line 358
      printf((char const   *)"record #%d,  culled %d, score=%s          \r", r, culled,
             tmp___9);
#line 360
      fflush(stdout);
    }
#line 362
    thinking = 0;
#line 363
    nodes += tree->nodes_searched;
#line 364
    avg_depth += (float )iteration;
#line 365
    time___0 = (int )((unsigned int )time___0 + (end_time - start_time));
#line 366
    if (! screen) {
#line 367
      correct = solution_type;
#line 368
      i = 0;
      {
#line 368
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 368
        if (! (i < number_of_solutions)) {
#line 368
          goto while_break___2;
        }
#line 369
        if (! solution_type) {
#line 370
          if (solutions[i] == (tree->pv[1].path[1] & 0x001fffff)) {
#line 371
            correct = 1;
          }
        } else
#line 372
        if (solutions[i] == (tree->pv[1].path[1] & 0x001fffff)) {
#line 373
          correct = 0;
        }
#line 368
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 375
      if (correct) {
#line 376
        right ++;
#line 377
        Print(4095, "----------------------> solution correct (%d/%d).\n", right,
              right + wrong);
      } else {
#line 380
        wrong ++;
#line 381
        Print(4095, "----------------------> solution incorrect (%d/%d).\n", right,
              right + wrong);
#line 383
        if (unsolved) {
#line 384
          fputs((char const   * __restrict  )(failed), (FILE * __restrict  )unsolved);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  if (r) {
#line 396
    Print(4095, "\n\n\n");
#line 397
    Print(4095, "test results summary:\n\n");
#line 398
    Print(4095, "total positions searched..........%12d\n", r);
#line 399
    if (! screen) {
#line 400
      Print(4095, "number right......................%12d\n", right);
#line 401
      Print(4095, "number wrong......................%12d\n", wrong);
#line 402
      Print(4095, "percentage right..................%12d\n", (right * 100) / (right + wrong));
#line 404
      Print(4095, "percentage wrong..................%12d\n", (wrong * 100) / (right + wrong));
    } else {
#line 407
      Print(4095, "records excluded..................%12d\n", culled);
    }
#line 409
    Print(4095, "total nodes searched..............%12lu\n", nodes);
#line 410
    Print(4095, "average search depth..............%12.1f\n", (double )(avg_depth / (float )r));
#line 411
    if (1 > time___0) {
#line 411
      tmp___10 = 1;
    } else {
#line 411
      tmp___10 = time___0;
    }
#line 411
    Print(4095, "nodes per second..................%12lu\n", (nodes * 100UL) / (uint64_t )tmp___10);
#line 413
    tmp___11 = DisplayTime((unsigned int )time___0);
#line 413
    Print(4095, "total time........................%12s\n", tmp___11);
  }
#line 416
  input_stream = stdin;
#line 417
  early_exit = 99;
#line 418
  fclose(test_input);
#line 419
  return;
}
}
#line 15 "time.c"
void TimeAdjust(int side , int time_used___0 ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 25
  (tc_moves_remaining[side]) --;
#line 26
  if (tc_time_remaining[side] > time_used___0) {
#line 26
    tmp = time_used___0;
  } else {
#line 26
    tmp = tc_time_remaining[side];
  }
#line 26
  tc_time_remaining[side] -= tmp;
#line 29
  if (! tc_moves_remaining[side]) {
#line 30
    if (tc_sudden_death == 2) {
#line 31
      tc_sudden_death = 1;
    }
#line 32
    tc_moves_remaining[side] += tc_secondary_moves;
#line 33
    tc_time_remaining[side] += tc_secondary_time;
#line 34
    if (side) {
#line 34
      tmp___0 = "white";
    } else {
#line 34
      tmp___0 = "black";
    }
#line 34
    Print(4095, "time control reached (%s)\n", tmp___0);
  }
#line 36
  if (tc_increment) {
#line 37
    tc_time_remaining[side] += tc_increment;
  }
#line 38
  return;
}
}
#line 104 "time.c"
int TimeCheck(TREE *tree , int busy ) 
{ 
  int time_used___0 ;
  int i ;
  int ndone ;
  unsigned int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 117
  tmp = ReadClock();
#line 117
  time_used___0 = (int )(tmp - start_time);
#line 118
  if ((unsigned int )time_used___0 >= noise_level) {
#line 118
    if (display_options & 16) {
#line 118
      if (time_used___0 > burp) {
#line 119
        LockX86(& lock_io);
#line 120
        if (pondering) {
#line 121
          tmp___0 = Display2Times((unsigned int )time_used___0);
#line 121
          printf((char const   *)"         %2i   %s%7s?  ", iteration, tmp___0, tree->remaining_moves_text);
        } else {
#line 124
          tmp___1 = Display2Times((unsigned int )time_used___0);
#line 124
          printf((char const   *)"         %2i   %s%7s*  ", iteration, tmp___1, tree->remaining_moves_text);
        }
#line 126
        if (display_options & 16) {
#line 127
          printf((char const   *)"%d. ", move_number);
        }
#line 128
        if (display_options & 16) {
#line 128
          if (root_wtm ^ 1) {
#line 129
            printf((char const   *)"... ");
          } else {
#line 128
            goto _L;
          }
        } else {
          _L: /* CIL Label */ ;
        }
#line 130
        tmp___2 = DisplayKMB((uint64_t )nodes_per_second, 0);
#line 130
        printf((char const   *)"%s(%snps)             \r", tree->root_move_text, tmp___2);
#line 132
        burp = (time_used___0 / 1500) * 1500 + 1500;
#line 133
        fflush(stdout);
#line 134
        UnlockX86(& lock_io);
      } else {
#line 118
        goto _L___1;
      }
    } else {
#line 118
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ ;
  }
#line 147
  if (n_root_moves == 1) {
#line 147
    if (! booking) {
#line 147
      if (! annotate_mode) {
#line 147
        if (! pondering) {
#line 147
          if (iteration > 1) {
#line 147
            if (time_used___0 > time_limit) {
#line 147
              goto _L___3;
            } else
#line 147
            if (time_used___0 > 100) {
              _L___3: /* CIL Label */ 
#line 149
              return (1);
            } else {
#line 147
              goto _L___7;
            }
          } else {
#line 147
            goto _L___7;
          }
        } else {
#line 147
          goto _L___7;
        }
      } else {
#line 147
        goto _L___7;
      }
    } else {
#line 147
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    _L___6: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___4: /* CIL Label */ 
    _L___2: /* CIL Label */ ;
  }
#line 150
  if (iteration <= 2) {
#line 151
    return (0);
  }
#line 162
  if (pondering) {
#line 162
    goto _L___8;
  } else
#line 162
  if (analyze_mode) {
    _L___8: /* CIL Label */ 
#line 163
    return (0);
  }
#line 164
  if (time_used___0 > absolute_time_limit) {
#line 165
    return (1);
  }
#line 175
  if (search_time_limit) {
#line 176
    if (time_used___0 < time_limit) {
#line 177
      return (0);
    } else {
#line 179
      return (1);
    }
  }
#line 192
  if (time_used___0 < (difficulty * time_limit) / 100) {
#line 193
    return (0);
  }
#line 194
  if (! busy) {
#line 195
    return (1);
  }
#line 212
  ndone = 0;
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i < n_root_moves)) {
#line 213
      goto while_break;
    }
#line 214
    if (root_moves[i].status & 8U) {
#line 215
      ndone ++;
    }
#line 213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  if (ndone == 1) {
#line 216
    if (! (root_moves[0].status & 1U)) {
#line 217
      return (1);
    } else {
#line 216
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ ;
  }
#line 230
  if (time_used___0 + 300 > tc_time_remaining[root_wtm]) {
#line 231
    return (1);
  }
#line 232
  return (0);
}
}
#line 247 "time.c"
void TimeSet(int search_type ) 
{ 
  int mult ;
  int extra ;
  int surplus ;
  int average ;
  int simple_average ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 248
  mult = 0;
#line 248
  extra = 0;
#line 252
  surplus = 0;
#line 253
  average = 0;
#line 271
  if (tc_sudden_death == 1) {
#line 272
    if (ponder) {
#line 272
      tmp = 20;
    } else {
#line 272
      tmp = 26;
    }
#line 272
    time_limit = (tc_time_remaining[root_wtm] - tc_safety_margin) / tmp + tc_increment;
#line 275
    if (time_limit * 5 < tc_time_remaining[root_wtm] / 2) {
#line 275
      absolute_time_limit = time_limit * 5;
    } else {
#line 275
      absolute_time_limit = tc_time_remaining[root_wtm] / 2;
    }
  } else {
#line 293
    if (move_number <= tc_moves) {
#line 294
      simple_average = (tc_time - tc_safety_margin) / tc_moves;
    } else {
#line 296
      simple_average = (tc_secondary_time - tc_safety_margin) / tc_secondary_moves;
    }
#line 298
    if ((tc_time_remaining[root_wtm] - tc_safety_margin) - simple_average * tc_moves_remaining[root_wtm] > 0) {
#line 298
      surplus = (tc_time_remaining[root_wtm] - tc_safety_margin) - simple_average * tc_moves_remaining[root_wtm];
    } else {
#line 298
      surplus = 0;
    }
#line 301
    average = ((tc_time_remaining[root_wtm] - tc_safety_margin) + tc_moves_remaining[root_wtm] * tc_increment) / tc_moves_remaining[root_wtm];
#line 305
    if (surplus < tc_safety_margin) {
#line 306
      if (average < simple_average) {
#line 306
        time_limit = average;
      } else {
#line 306
        time_limit = simple_average;
      }
    } else
#line 308
    if ((double )average < 2.0 * (double )simple_average) {
#line 308
      time_limit = average;
    } else {
#line 308
      time_limit = (int )(2.0 * (double )simple_average);
    }
  }
#line 311
  if (tc_increment > 200) {
#line 311
    if (moves_out_of_book < 2) {
#line 312
      time_limit = (int )((double )time_limit * 1.2);
    } else {
#line 311
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 313
  if (time_limit <= 0) {
#line 314
    time_limit = 5;
  }
#line 315
  absolute_time_limit = (time_limit + surplus / 2) + (tc_time_remaining[root_wtm] - tc_safety_margin) / 4;
#line 318
  if (absolute_time_limit > 5 * time_limit) {
#line 319
    absolute_time_limit = 5 * time_limit;
  }
#line 320
  if (absolute_time_limit > tc_time_remaining[root_wtm] / 2) {
#line 321
    absolute_time_limit = tc_time_remaining[root_wtm] / 2;
  }
#line 334
  if (usage_level) {
#line 335
    time_limit = (int )((double )time_limit * (1.0 + (double )usage_level / 100.0));
  }
#line 336
  if (first_nonbook_factor) {
#line 336
    if (moves_out_of_book < first_nonbook_span) {
#line 337
      mult = ((first_nonbook_span - moves_out_of_book) + 1) * first_nonbook_factor;
#line 339
      extra = ((time_limit * mult) / first_nonbook_span) / 100;
#line 340
      time_limit += extra;
    } else {
#line 336
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 350
  if (search_time_limit) {
#line 351
    time_limit = search_time_limit;
#line 352
    absolute_time_limit = time_limit;
  }
#line 354
  if (search_type == 2) {
#line 354
    goto _L___1;
  } else
#line 354
  if (search_type == booking) {
    _L___1: /* CIL Label */ 
#line 355
    time_limit /= 10;
#line 356
    absolute_time_limit = time_limit * 3;
  }
#line 358
  if (! tc_sudden_death) {
#line 358
    if (! search_time_limit) {
#line 358
      if (time_limit > (3 * tc_time) / tc_moves) {
#line 360
        time_limit = (3 * tc_time) / tc_moves;
      } else {
#line 358
        goto _L___3;
      }
    } else {
#line 358
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    _L___2: /* CIL Label */ ;
  }
#line 361
  if (time_limit < absolute_time_limit) {
#line 361
    time_limit = time_limit;
  } else {
#line 361
    time_limit = absolute_time_limit;
  }
#line 362
  if (search_type != 2) {
#line 363
    if (! tc_sudden_death) {
#line 364
      tmp___0 = DisplayTime((unsigned int )surplus);
#line 364
      Print(32, "        time surplus %s  ", tmp___0);
    } else {
#line 366
      Print(32, "        ");
    }
#line 367
    tmp___1 = DisplayTimeKibitz((unsigned int )time_limit);
#line 367
    Print(32, "time limit %s", tmp___1);
#line 368
    tmp___2 = DisplayTimeKibitz((unsigned int )absolute_time_limit);
#line 368
    Print(32, " (%s)\n", tmp___2);
  }
#line 370
  if (time_limit <= 1) {
#line 371
    time_limit = 1;
#line 372
    usage_level = 0;
  }
#line 374
  return;
}
}
#line 276 "/usr/include/pthread.h"
extern int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 , pthread_t __thread2 )  __attribute__((__nothrow__,
__const__)) ;
#line 5 "/home/petter/repositories/goblint/lib/libc/stub/src/pthread.c"
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) )  __attribute__((__goblint_stub__)) ;
#line 5 "/home/petter/repositories/goblint/lib/libc/stub/src/pthread.c"
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) ) 
{ 
  int top ;

  {
#line 8
  (*init_routine)();
#line 9
  return (top);
}
}
#line 7 "/home/petter/repositories/goblint/lib/libc/stub/src/stdlib.c"
void ( __attribute__((__nonnull__(1,4))) qsort)(void *ptr , size_t count , size_t size ,
                                                int (*comp)(void const   * , void const   * ) )  __attribute__((__goblint_stub__)) ;
#line 7 "/home/petter/repositories/goblint/lib/libc/stub/src/stdlib.c"
void ( __attribute__((__nonnull__(1,4))) qsort)(void *ptr , size_t count , size_t size ,
                                                int (*comp)(void const   * , void const   * ) ) 
{ 
  size_t i ;
  size_t j___0 ;
  size_t i___0 ;
  size_t j___1 ;
  int r ;
  size_t k___0 ;
  char *a ;
  char *b ;
  char c ;

  {
#line 9
  i = (size_t )0;
  {
#line 9
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9
    if (! (i < count)) {
#line 9
      goto while_break;
    }
#line 10
    j___0 = (size_t )0;
    {
#line 10
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10
      if (! (j___0 < count)) {
#line 10
        goto while_break___0;
      }
#line 11
      (*comp)((void const   *)(ptr + i * size), (void const   *)(ptr + j___0 * size));
#line 10
      j___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 9
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 16
  i___0 = (size_t )0;
  {
#line 16
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 16
    if (! (i___0 < count)) {
#line 16
      goto while_break___1;
    }
#line 17
    j___1 = (size_t )0;
    {
#line 17
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 17
      if (! (j___1 < count)) {
#line 17
        goto while_break___2;
      }
#line 19
      if (r) {
#line 21
        k___0 = (size_t )0;
        {
#line 21
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 21
          if (! (k___0 < size)) {
#line 21
            goto while_break___3;
          }
#line 22
          a = (char *)((ptr + i___0 * size) + k___0);
#line 23
          b = (char *)((ptr + j___1 * size) + k___0);
#line 24
          c = *a;
#line 25
          *a = *b;
#line 26
          *b = c;
#line 21
          k___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 17
      j___1 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 16
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 33
  return;
}
}
#line 37
void *bsearch(void const   *key , void const   *ptr , size_t count , size_t size ,
              int (*comp)(void const   * , void const   * ) )  __attribute__((__goblint_stub__)) ;
#line 38
void *bsearch(void const   *key , void const   *ptr , size_t count , size_t size ,
              int (*comp)(void const   * , void const   * ) )  __attribute__((__goblint_stub__)) ;
#line 38 "/home/petter/repositories/goblint/lib/libc/stub/src/stdlib.c"
void *bsearch(void const   *key , void const   *ptr , size_t count , size_t size ,
              int (*comp)(void const   * , void const   * ) ) 
{ 
  size_t i ;
  void const   *a ;
  int tmp ;

  {
#line 40
  i = (size_t )0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < count)) {
#line 40
      goto while_break;
    }
#line 41
    a = ptr + i * size;
#line 42
    tmp = (*comp)(key, a);
#line 42
    if (tmp == 0) {
#line 43
      return ((void *)a);
    }
#line 40
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return ((void *)0);
}
}
