// git clone https://github.com/id-Software/DOOM.git
// cd DOOM/linuxdoom-1.10
// mkdir linux
//    replace #include <errnos.h> with #include <errno.h> in i_video.c
// bear -- make CFLAGS="-m32 --std=gnu90 -Wall -DNORMALUNIX -DLINUX"

/* Generated by Goblint-CIL v. 2.0.5 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
typedef unsigned int size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 31 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 47 "/usr/include/bits/types.h"
typedef long long __int64_t;
#line 48 "/usr/include/bits/types.h"
typedef unsigned long long __uint64_t;
#line 52 "/usr/include/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 66 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 67 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 75 "/usr/include/bits/types.h"
typedef long long __intmax_t;
#line 76 "/usr/include/bits/types.h"
typedef unsigned long long __uintmax_t;
#line 145 "/usr/include/bits/types.h"
typedef __uint64_t __dev_t;
#line 146 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/bits/types.h"
typedef __uint64_t __ino64_t;
#line 150 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 152 "/usr/include/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/bits/types.h"
typedef __int64_t __off64_t;
#line 154 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/bits/types.h"
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
#line 155 "/usr/include/bits/types.h"
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
#line 156 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/bits/types.h"
typedef __uint64_t __rlim64_t;
#line 159 "/usr/include/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 163 "/usr/include/bits/types.h"
typedef __int64_t __suseconds64_t;
#line 165 "/usr/include/bits/types.h"
typedef int __daddr_t;
#line 166 "/usr/include/bits/types.h"
typedef int __key_t;
#line 169 "/usr/include/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/bits/types.h"
typedef void *__timer_t;
#line 175 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 180 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/bits/types.h"
typedef __int64_t __blkcnt64_t;
#line 184 "/usr/include/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 185 "/usr/include/bits/types.h"
typedef __uint64_t __fsblkcnt64_t;
#line 188 "/usr/include/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 189 "/usr/include/bits/types.h"
typedef __uint64_t __fsfilcnt64_t;
#line 192 "/usr/include/bits/types.h"
typedef int __fsword_t;
#line 194 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 197 "/usr/include/bits/types.h"
typedef long __syscall_slong_t;
#line 199 "/usr/include/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 203 "/usr/include/bits/types.h"
typedef __off64_t __loff_t;
#line 204 "/usr/include/bits/types.h"
typedef char *__caddr_t;
#line 207 "/usr/include/bits/types.h"
typedef int __intptr_t;
#line 210 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 215 "/usr/include/bits/types.h"
typedef int __sig_atomic_t;
#line 223 "/usr/include/bits/types.h"
typedef __int64_t __time64_t;
#line 13 "/usr/include/bits/types/__mbstate_t.h"
union __anonunion___value_628077854 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_69179079 {
   int __count ;
   union __anonunion___value_628077854 __value ;
};
#line 13 "/usr/include/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_69179079 __mbstate_t;
#line 10 "/usr/include/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 10 "/usr/include/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 10 "/usr/include/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   struct _IO_FILE **_prevchain ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 5UL * sizeof(void *)] ;
};
#line 27 "/usr/include/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_read_function_t(void *__cookie , char *__buf , size_t __nbytes );
#line 36 "/usr/include/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_write_function_t(void *__cookie , char const   *__buf , size_t __nbytes );
#line 45 "/usr/include/bits/types/cookie_io_functions_t.h"
typedef int cookie_seek_function_t(void *__cookie , __off64_t *__pos , int __w );
#line 48 "/usr/include/bits/types/cookie_io_functions_t.h"
typedef int cookie_close_function_t(void *__cookie );
#line 55 "/usr/include/bits/types/cookie_io_functions_t.h"
struct _IO_cookie_io_functions_t {
   cookie_read_function_t *read ;
   cookie_write_function_t *write ;
   cookie_seek_function_t *seek ;
   cookie_close_function_t *close ;
};
#line 55 "/usr/include/bits/types/cookie_io_functions_t.h"
typedef struct _IO_cookie_io_functions_t cookie_io_functions_t;
#line 53 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 78 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 85 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 27 "/usr/include/bits/types/__locale_t.h"
struct __locale_data ;
#line 27 "/usr/include/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 41 "/usr/include/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 33 "doomdef.h"
enum __anonenum_82154846 {
    VERSIONVERSION = 110
} ;
#line 38
enum __anonenum_GameMode_t_162005458 {
    sharewareshareware = 0,
    registeredregistered = 1,
    commercialcommercial = 2,
    retailretail = 3,
    indeterminedindetermined = 4
} ;
#line 38 "doomdef.h"
typedef enum __anonenum_GameMode_t_162005458 GameMode_t;
#line 51
enum __anonenum_GameMission_t_1047823281 {
    doomdoom = 0,
    doom2doom2 = 1,
    pack_tntpack_tnt = 2,
    pack_plutpack_plut = 3,
    nonenone = 4
} ;
#line 51 "doomdef.h"
typedef enum __anonenum_GameMission_t_1047823281 GameMission_t;
#line 63
enum __anonenum_Language_t_498788937 {
    englishenglish = 0,
    frenchfrench = 1,
    germangerman = 2,
    unknownunknown = 3
} ;
#line 63 "doomdef.h"
typedef enum __anonenum_Language_t_498788937 Language_t;
#line 127
enum __anonenum_gamestate_t_172446169 {
    GS_LEVELGS_LEVEL = 0,
    GS_INTERMISSIONGS_INTERMISSION = 1,
    GS_FINALEGS_FINALE = 2,
    GS_DEMOSCREENGS_DEMOSCREEN = 3
} ;
#line 127 "doomdef.h"
typedef enum __anonenum_gamestate_t_172446169 gamestate_t;
#line 147
enum __anonenum_skill_t_885973833 {
    sk_babysk_baby = 0,
    sk_easysk_easy = 1,
    sk_mediumsk_medium = 2,
    sk_hardsk_hard = 3,
    sk_nightmaresk_nightmare = 4
} ;
#line 147 "doomdef.h"
typedef enum __anonenum_skill_t_885973833 skill_t;
#line 162
enum __anonenum_card_t_650849349 {
    it_bluecardit_bluecard = 0,
    it_yellowcardit_yellowcard = 1,
    it_redcardit_redcard = 2,
    it_blueskullit_blueskull = 3,
    it_yellowskullit_yellowskull = 4,
    it_redskullit_redskull = 5,
    NUMCARDSNUMCARDS = 6
} ;
#line 162 "doomdef.h"
typedef enum __anonenum_card_t_650849349 card_t;
#line 180
enum __anonenum_weapontype_t_227036456 {
    wp_fistwp_fist = 0,
    wp_pistolwp_pistol = 1,
    wp_shotgunwp_shotgun = 2,
    wp_chaingunwp_chaingun = 3,
    wp_missilewp_missile = 4,
    wp_plasmawp_plasma = 5,
    wp_bfgwp_bfg = 6,
    wp_chainsawwp_chainsaw = 7,
    wp_supershotgunwp_supershotgun = 8,
    NUMWEAPONSNUMWEAPONS = 9,
    wp_nochangewp_nochange = 10
} ;
#line 180 "doomdef.h"
typedef enum __anonenum_weapontype_t_227036456 weapontype_t;
#line 201
enum __anonenum_ammotype_t_191554672 {
    am_clipam_clip = 0,
    am_shellam_shell = 1,
    am_cellam_cell = 2,
    am_mislam_misl = 3,
    NUMAMMONUMAMMO = 4,
    am_noammoam_noammo = 5
} ;
#line 201 "doomdef.h"
typedef enum __anonenum_ammotype_t_191554672 ammotype_t;
#line 214
enum __anonenum_powertype_t_807562229 {
    pw_invulnerabilitypw_invulnerability = 0,
    pw_strengthpw_strength = 1,
    pw_invisibilitypw_invisibility = 2,
    pw_ironfeetpw_ironfeet = 3,
    pw_allmappw_allmap = 4,
    pw_infraredpw_infrared = 5,
    NUMPOWERSNUMPOWERS = 6
} ;
#line 214 "doomdef.h"
typedef enum __anonenum_powertype_t_807562229 powertype_t;
#line 233
enum __anonenum_powerduration_t_927910835 {
    INVULNTICSINVULNTICS = 1050,
    INVISTICSINVISTICS = 2100,
    INFRATICSINFRATICS = 4200,
    IRONTICSIRONTICS = 2100
} ;
#line 233 "doomdef.h"
typedef enum __anonenum_powerduration_t_927910835 powerduration_t;
#line 34 "doomtype.h"
enum __anonenum_boolean_696322153 {
    falsefalse = 0,
    truetrue = 1
} ;
#line 34 "doomtype.h"
typedef enum __anonenum_boolean_696322153 boolean;
#line 36 "doomtype.h"
typedef unsigned char byte;
#line 33 "doomdef.h"
enum __anonenum_82154846___0 {
    VERSION___0VERSION___0 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526 {
    ML_LABELML_LABEL = 0,
    ML_THINGSML_THINGS = 1,
    ML_LINEDEFSML_LINEDEFS = 2,
    ML_SIDEDEFSML_SIDEDEFS = 3,
    ML_VERTEXESML_VERTEXES = 4,
    ML_SEGSML_SEGS = 5,
    ML_SSECTORSML_SSECTORS = 6,
    ML_NODESML_NODES = 7,
    ML_SECTORSML_SECTORS = 8,
    ML_REJECTML_REJECT = 9,
    ML_BLOCKMAPML_BLOCKMAP = 10
} ;
#line 60 "doomdata.h"
struct __anonstruct_mapvertex_t_964730938 {
   short x ;
   short y ;
};
#line 60 "doomdata.h"
typedef struct __anonstruct_mapvertex_t_964730938 mapvertex_t;
#line 69 "doomdata.h"
struct __anonstruct_mapsidedef_t_999264382 {
   short textureoffset ;
   short rowoffset ;
   char toptexture[8] ;
   char bottomtexture[8] ;
   char midtexture[8] ;
   short sector ;
};
#line 69 "doomdata.h"
typedef struct __anonstruct_mapsidedef_t_999264382 mapsidedef_t;
#line 84 "doomdata.h"
struct __anonstruct_maplinedef_t_746935382 {
   short v1 ;
   short v2 ;
   short flags ;
   short special ;
   short tag ;
   short sidenum[2] ;
};
#line 84 "doomdata.h"
typedef struct __anonstruct_maplinedef_t_746935382 maplinedef_t;
#line 141 "doomdata.h"
struct __anonstruct_mapsector_t_414681030 {
   short floorheight ;
   short ceilingheight ;
   char floorpic[8] ;
   char ceilingpic[8] ;
   short lightlevel ;
   short special ;
   short tag ;
};
#line 141 "doomdata.h"
typedef struct __anonstruct_mapsector_t_414681030 mapsector_t;
#line 153 "doomdata.h"
struct __anonstruct_mapsubsector_t_999264383 {
   short numsegs ;
   short firstseg ;
};
#line 153 "doomdata.h"
typedef struct __anonstruct_mapsubsector_t_999264383 mapsubsector_t;
#line 163 "doomdata.h"
struct __anonstruct_mapseg_t_999264384 {
   short v1 ;
   short v2 ;
   short angle ;
   short linedef ;
   short side ;
   short offset ;
};
#line 163 "doomdata.h"
typedef struct __anonstruct_mapseg_t_999264384 mapseg_t;
#line 180 "doomdata.h"
struct __anonstruct_mapnode_t_1060023366 {
   short x ;
   short y ;
   short dx ;
   short dy ;
   short bbox[2][4] ;
   unsigned short children[2] ;
};
#line 180 "doomdata.h"
typedef struct __anonstruct_mapnode_t_1060023366 mapnode_t;
#line 203 "doomdata.h"
struct __anonstruct_mapthing_t_767456377 {
   short x ;
   short y ;
   short angle ;
   short type ;
   short options ;
};
#line 203 "doomdata.h"
typedef struct __anonstruct_mapthing_t_767456377 mapthing_t;
#line 34 "d_items.h"
struct __anonstruct_weaponinfo_t_833619044 {
   ammotype_t ammo ;
   int upstate ;
   int downstate ;
   int readystate ;
   int atkstate ;
   int flashstate ;
};
#line 34 "d_items.h"
typedef struct __anonstruct_weaponinfo_t_833619044 weaponinfo_t;
#line 38 "m_fixed.h"
typedef int fixed_t;
#line 169 "/usr/include/math.h"
typedef long double float_t;
#line 170 "/usr/include/math.h"
typedef long double double_t;
#line 934
enum __anonenum_1037408945 {
    FP_NANFP_NAN = 0,
    FP_INFINITEFP_INFINITE = 1,
    FP_ZEROFP_ZERO = 2,
    FP_SUBNORMALFP_SUBNORMAL = 3,
    FP_NORMALFP_NORMAL = 4
} ;
#line 78 "tables.h"
typedef unsigned int angle_t;
#line 41 "d_think.h"
typedef void (*actionf_v)();
#line 42 "d_think.h"
typedef void (*actionf_p1)(void * );
#line 43 "d_think.h"
typedef void (*actionf_p2)(void * , void * );
#line 45 "d_think.h"
union __anonunion_actionf_t_738124893 {
   void (*acp1)(void * ) ;
   void (*acv)() ;
   void (*acp2)(void * , void * ) ;
};
#line 45 "d_think.h"
typedef union __anonunion_actionf_t_738124893 actionf_t;
#line 60 "d_think.h"
typedef actionf_t think_t;
#line 64 "d_think.h"
struct thinker_s {
   struct thinker_s *prev ;
   struct thinker_s *next ;
   think_t function ;
};
#line 64 "d_think.h"
typedef struct thinker_s thinker_t;
#line 30 "info.h"
enum __anonenum_spritenum_t_144226159 {
    SPR_TROOSPR_TROO = 0,
    SPR_SHTGSPR_SHTG = 1,
    SPR_PUNGSPR_PUNG = 2,
    SPR_PISGSPR_PISG = 3,
    SPR_PISFSPR_PISF = 4,
    SPR_SHTFSPR_SHTF = 5,
    SPR_SHT2SPR_SHT2 = 6,
    SPR_CHGGSPR_CHGG = 7,
    SPR_CHGFSPR_CHGF = 8,
    SPR_MISGSPR_MISG = 9,
    SPR_MISFSPR_MISF = 10,
    SPR_SAWGSPR_SAWG = 11,
    SPR_PLSGSPR_PLSG = 12,
    SPR_PLSFSPR_PLSF = 13,
    SPR_BFGGSPR_BFGG = 14,
    SPR_BFGFSPR_BFGF = 15,
    SPR_BLUDSPR_BLUD = 16,
    SPR_PUFFSPR_PUFF = 17,
    SPR_BAL1SPR_BAL1 = 18,
    SPR_BAL2SPR_BAL2 = 19,
    SPR_PLSSSPR_PLSS = 20,
    SPR_PLSESPR_PLSE = 21,
    SPR_MISLSPR_MISL = 22,
    SPR_BFS1SPR_BFS1 = 23,
    SPR_BFE1SPR_BFE1 = 24,
    SPR_BFE2SPR_BFE2 = 25,
    SPR_TFOGSPR_TFOG = 26,
    SPR_IFOGSPR_IFOG = 27,
    SPR_PLAYSPR_PLAY = 28,
    SPR_POSSSPR_POSS = 29,
    SPR_SPOSSPR_SPOS = 30,
    SPR_VILESPR_VILE = 31,
    SPR_FIRESPR_FIRE = 32,
    SPR_FATBSPR_FATB = 33,
    SPR_FBXPSPR_FBXP = 34,
    SPR_SKELSPR_SKEL = 35,
    SPR_MANFSPR_MANF = 36,
    SPR_FATTSPR_FATT = 37,
    SPR_CPOSSPR_CPOS = 38,
    SPR_SARGSPR_SARG = 39,
    SPR_HEADSPR_HEAD = 40,
    SPR_BAL7SPR_BAL7 = 41,
    SPR_BOSSSPR_BOSS = 42,
    SPR_BOS2SPR_BOS2 = 43,
    SPR_SKULSPR_SKUL = 44,
    SPR_SPIDSPR_SPID = 45,
    SPR_BSPISPR_BSPI = 46,
    SPR_APLSSPR_APLS = 47,
    SPR_APBXSPR_APBX = 48,
    SPR_CYBRSPR_CYBR = 49,
    SPR_PAINSPR_PAIN = 50,
    SPR_SSWVSPR_SSWV = 51,
    SPR_KEENSPR_KEEN = 52,
    SPR_BBRNSPR_BBRN = 53,
    SPR_BOSFSPR_BOSF = 54,
    SPR_ARM1SPR_ARM1 = 55,
    SPR_ARM2SPR_ARM2 = 56,
    SPR_BAR1SPR_BAR1 = 57,
    SPR_BEXPSPR_BEXP = 58,
    SPR_FCANSPR_FCAN = 59,
    SPR_BON1SPR_BON1 = 60,
    SPR_BON2SPR_BON2 = 61,
    SPR_BKEYSPR_BKEY = 62,
    SPR_RKEYSPR_RKEY = 63,
    SPR_YKEYSPR_YKEY = 64,
    SPR_BSKUSPR_BSKU = 65,
    SPR_RSKUSPR_RSKU = 66,
    SPR_YSKUSPR_YSKU = 67,
    SPR_STIMSPR_STIM = 68,
    SPR_MEDISPR_MEDI = 69,
    SPR_SOULSPR_SOUL = 70,
    SPR_PINVSPR_PINV = 71,
    SPR_PSTRSPR_PSTR = 72,
    SPR_PINSSPR_PINS = 73,
    SPR_MEGASPR_MEGA = 74,
    SPR_SUITSPR_SUIT = 75,
    SPR_PMAPSPR_PMAP = 76,
    SPR_PVISSPR_PVIS = 77,
    SPR_CLIPSPR_CLIP = 78,
    SPR_AMMOSPR_AMMO = 79,
    SPR_ROCKSPR_ROCK = 80,
    SPR_BROKSPR_BROK = 81,
    SPR_CELLSPR_CELL = 82,
    SPR_CELPSPR_CELP = 83,
    SPR_SHELSPR_SHEL = 84,
    SPR_SBOXSPR_SBOX = 85,
    SPR_BPAKSPR_BPAK = 86,
    SPR_BFUGSPR_BFUG = 87,
    SPR_MGUNSPR_MGUN = 88,
    SPR_CSAWSPR_CSAW = 89,
    SPR_LAUNSPR_LAUN = 90,
    SPR_PLASSPR_PLAS = 91,
    SPR_SHOTSPR_SHOT = 92,
    SPR_SGN2SPR_SGN2 = 93,
    SPR_COLUSPR_COLU = 94,
    SPR_SMT2SPR_SMT2 = 95,
    SPR_GOR1SPR_GOR1 = 96,
    SPR_POL2SPR_POL2 = 97,
    SPR_POL5SPR_POL5 = 98,
    SPR_POL4SPR_POL4 = 99,
    SPR_POL3SPR_POL3 = 100,
    SPR_POL1SPR_POL1 = 101,
    SPR_POL6SPR_POL6 = 102,
    SPR_GOR2SPR_GOR2 = 103,
    SPR_GOR3SPR_GOR3 = 104,
    SPR_GOR4SPR_GOR4 = 105,
    SPR_GOR5SPR_GOR5 = 106,
    SPR_SMITSPR_SMIT = 107,
    SPR_COL1SPR_COL1 = 108,
    SPR_COL2SPR_COL2 = 109,
    SPR_COL3SPR_COL3 = 110,
    SPR_COL4SPR_COL4 = 111,
    SPR_CANDSPR_CAND = 112,
    SPR_CBRASPR_CBRA = 113,
    SPR_COL6SPR_COL6 = 114,
    SPR_TRE1SPR_TRE1 = 115,
    SPR_TRE2SPR_TRE2 = 116,
    SPR_ELECSPR_ELEC = 117,
    SPR_CEYESPR_CEYE = 118,
    SPR_FSKUSPR_FSKU = 119,
    SPR_COL5SPR_COL5 = 120,
    SPR_TBLUSPR_TBLU = 121,
    SPR_TGRNSPR_TGRN = 122,
    SPR_TREDSPR_TRED = 123,
    SPR_SMBTSPR_SMBT = 124,
    SPR_SMGTSPR_SMGT = 125,
    SPR_SMRTSPR_SMRT = 126,
    SPR_HDB1SPR_HDB1 = 127,
    SPR_HDB2SPR_HDB2 = 128,
    SPR_HDB3SPR_HDB3 = 129,
    SPR_HDB4SPR_HDB4 = 130,
    SPR_HDB5SPR_HDB5 = 131,
    SPR_HDB6SPR_HDB6 = 132,
    SPR_POB1SPR_POB1 = 133,
    SPR_POB2SPR_POB2 = 134,
    SPR_BRS1SPR_BRS1 = 135,
    SPR_TLMPSPR_TLMP = 136,
    SPR_TLP2SPR_TLP2 = 137,
    NUMSPRITESNUMSPRITES = 138
} ;
#line 30 "info.h"
typedef enum __anonenum_spritenum_t_144226159 spritenum_t;
#line 174
enum __anonenum_statenum_t_515532113 {
    S_NULLS_NULL = 0,
    S_LIGHTDONES_LIGHTDONE = 1,
    S_PUNCHS_PUNCH = 2,
    S_PUNCHDOWNS_PUNCHDOWN = 3,
    S_PUNCHUPS_PUNCHUP = 4,
    S_PUNCH1S_PUNCH1 = 5,
    S_PUNCH2S_PUNCH2 = 6,
    S_PUNCH3S_PUNCH3 = 7,
    S_PUNCH4S_PUNCH4 = 8,
    S_PUNCH5S_PUNCH5 = 9,
    S_PISTOLS_PISTOL = 10,
    S_PISTOLDOWNS_PISTOLDOWN = 11,
    S_PISTOLUPS_PISTOLUP = 12,
    S_PISTOL1S_PISTOL1 = 13,
    S_PISTOL2S_PISTOL2 = 14,
    S_PISTOL3S_PISTOL3 = 15,
    S_PISTOL4S_PISTOL4 = 16,
    S_PISTOLFLASHS_PISTOLFLASH = 17,
    S_SGUNS_SGUN = 18,
    S_SGUNDOWNS_SGUNDOWN = 19,
    S_SGUNUPS_SGUNUP = 20,
    S_SGUN1S_SGUN1 = 21,
    S_SGUN2S_SGUN2 = 22,
    S_SGUN3S_SGUN3 = 23,
    S_SGUN4S_SGUN4 = 24,
    S_SGUN5S_SGUN5 = 25,
    S_SGUN6S_SGUN6 = 26,
    S_SGUN7S_SGUN7 = 27,
    S_SGUN8S_SGUN8 = 28,
    S_SGUN9S_SGUN9 = 29,
    S_SGUNFLASH1S_SGUNFLASH1 = 30,
    S_SGUNFLASH2S_SGUNFLASH2 = 31,
    S_DSGUNS_DSGUN = 32,
    S_DSGUNDOWNS_DSGUNDOWN = 33,
    S_DSGUNUPS_DSGUNUP = 34,
    S_DSGUN1S_DSGUN1 = 35,
    S_DSGUN2S_DSGUN2 = 36,
    S_DSGUN3S_DSGUN3 = 37,
    S_DSGUN4S_DSGUN4 = 38,
    S_DSGUN5S_DSGUN5 = 39,
    S_DSGUN6S_DSGUN6 = 40,
    S_DSGUN7S_DSGUN7 = 41,
    S_DSGUN8S_DSGUN8 = 42,
    S_DSGUN9S_DSGUN9 = 43,
    S_DSGUN10S_DSGUN10 = 44,
    S_DSNR1S_DSNR1 = 45,
    S_DSNR2S_DSNR2 = 46,
    S_DSGUNFLASH1S_DSGUNFLASH1 = 47,
    S_DSGUNFLASH2S_DSGUNFLASH2 = 48,
    S_CHAINS_CHAIN = 49,
    S_CHAINDOWNS_CHAINDOWN = 50,
    S_CHAINUPS_CHAINUP = 51,
    S_CHAIN1S_CHAIN1 = 52,
    S_CHAIN2S_CHAIN2 = 53,
    S_CHAIN3S_CHAIN3 = 54,
    S_CHAINFLASH1S_CHAINFLASH1 = 55,
    S_CHAINFLASH2S_CHAINFLASH2 = 56,
    S_MISSILES_MISSILE = 57,
    S_MISSILEDOWNS_MISSILEDOWN = 58,
    S_MISSILEUPS_MISSILEUP = 59,
    S_MISSILE1S_MISSILE1 = 60,
    S_MISSILE2S_MISSILE2 = 61,
    S_MISSILE3S_MISSILE3 = 62,
    S_MISSILEFLASH1S_MISSILEFLASH1 = 63,
    S_MISSILEFLASH2S_MISSILEFLASH2 = 64,
    S_MISSILEFLASH3S_MISSILEFLASH3 = 65,
    S_MISSILEFLASH4S_MISSILEFLASH4 = 66,
    S_SAWS_SAW = 67,
    S_SAWBS_SAWB = 68,
    S_SAWDOWNS_SAWDOWN = 69,
    S_SAWUPS_SAWUP = 70,
    S_SAW1S_SAW1 = 71,
    S_SAW2S_SAW2 = 72,
    S_SAW3S_SAW3 = 73,
    S_PLASMAS_PLASMA = 74,
    S_PLASMADOWNS_PLASMADOWN = 75,
    S_PLASMAUPS_PLASMAUP = 76,
    S_PLASMA1S_PLASMA1 = 77,
    S_PLASMA2S_PLASMA2 = 78,
    S_PLASMAFLASH1S_PLASMAFLASH1 = 79,
    S_PLASMAFLASH2S_PLASMAFLASH2 = 80,
    S_BFGS_BFG = 81,
    S_BFGDOWNS_BFGDOWN = 82,
    S_BFGUPS_BFGUP = 83,
    S_BFG1S_BFG1 = 84,
    S_BFG2S_BFG2 = 85,
    S_BFG3S_BFG3 = 86,
    S_BFG4S_BFG4 = 87,
    S_BFGFLASH1S_BFGFLASH1 = 88,
    S_BFGFLASH2S_BFGFLASH2 = 89,
    S_BLOOD1S_BLOOD1 = 90,
    S_BLOOD2S_BLOOD2 = 91,
    S_BLOOD3S_BLOOD3 = 92,
    S_PUFF1S_PUFF1 = 93,
    S_PUFF2S_PUFF2 = 94,
    S_PUFF3S_PUFF3 = 95,
    S_PUFF4S_PUFF4 = 96,
    S_TBALL1S_TBALL1 = 97,
    S_TBALL2S_TBALL2 = 98,
    S_TBALLX1S_TBALLX1 = 99,
    S_TBALLX2S_TBALLX2 = 100,
    S_TBALLX3S_TBALLX3 = 101,
    S_RBALL1S_RBALL1 = 102,
    S_RBALL2S_RBALL2 = 103,
    S_RBALLX1S_RBALLX1 = 104,
    S_RBALLX2S_RBALLX2 = 105,
    S_RBALLX3S_RBALLX3 = 106,
    S_PLASBALLS_PLASBALL = 107,
    S_PLASBALL2S_PLASBALL2 = 108,
    S_PLASEXPS_PLASEXP = 109,
    S_PLASEXP2S_PLASEXP2 = 110,
    S_PLASEXP3S_PLASEXP3 = 111,
    S_PLASEXP4S_PLASEXP4 = 112,
    S_PLASEXP5S_PLASEXP5 = 113,
    S_ROCKETS_ROCKET = 114,
    S_BFGSHOTS_BFGSHOT = 115,
    S_BFGSHOT2S_BFGSHOT2 = 116,
    S_BFGLANDS_BFGLAND = 117,
    S_BFGLAND2S_BFGLAND2 = 118,
    S_BFGLAND3S_BFGLAND3 = 119,
    S_BFGLAND4S_BFGLAND4 = 120,
    S_BFGLAND5S_BFGLAND5 = 121,
    S_BFGLAND6S_BFGLAND6 = 122,
    S_BFGEXPS_BFGEXP = 123,
    S_BFGEXP2S_BFGEXP2 = 124,
    S_BFGEXP3S_BFGEXP3 = 125,
    S_BFGEXP4S_BFGEXP4 = 126,
    S_EXPLODE1S_EXPLODE1 = 127,
    S_EXPLODE2S_EXPLODE2 = 128,
    S_EXPLODE3S_EXPLODE3 = 129,
    S_TFOGS_TFOG = 130,
    S_TFOG01S_TFOG01 = 131,
    S_TFOG02S_TFOG02 = 132,
    S_TFOG2S_TFOG2 = 133,
    S_TFOG3S_TFOG3 = 134,
    S_TFOG4S_TFOG4 = 135,
    S_TFOG5S_TFOG5 = 136,
    S_TFOG6S_TFOG6 = 137,
    S_TFOG7S_TFOG7 = 138,
    S_TFOG8S_TFOG8 = 139,
    S_TFOG9S_TFOG9 = 140,
    S_TFOG10S_TFOG10 = 141,
    S_IFOGS_IFOG = 142,
    S_IFOG01S_IFOG01 = 143,
    S_IFOG02S_IFOG02 = 144,
    S_IFOG2S_IFOG2 = 145,
    S_IFOG3S_IFOG3 = 146,
    S_IFOG4S_IFOG4 = 147,
    S_IFOG5S_IFOG5 = 148,
    S_PLAYS_PLAY = 149,
    S_PLAY_RUN1S_PLAY_RUN1 = 150,
    S_PLAY_RUN2S_PLAY_RUN2 = 151,
    S_PLAY_RUN3S_PLAY_RUN3 = 152,
    S_PLAY_RUN4S_PLAY_RUN4 = 153,
    S_PLAY_ATK1S_PLAY_ATK1 = 154,
    S_PLAY_ATK2S_PLAY_ATK2 = 155,
    S_PLAY_PAINS_PLAY_PAIN = 156,
    S_PLAY_PAIN2S_PLAY_PAIN2 = 157,
    S_PLAY_DIE1S_PLAY_DIE1 = 158,
    S_PLAY_DIE2S_PLAY_DIE2 = 159,
    S_PLAY_DIE3S_PLAY_DIE3 = 160,
    S_PLAY_DIE4S_PLAY_DIE4 = 161,
    S_PLAY_DIE5S_PLAY_DIE5 = 162,
    S_PLAY_DIE6S_PLAY_DIE6 = 163,
    S_PLAY_DIE7S_PLAY_DIE7 = 164,
    S_PLAY_XDIE1S_PLAY_XDIE1 = 165,
    S_PLAY_XDIE2S_PLAY_XDIE2 = 166,
    S_PLAY_XDIE3S_PLAY_XDIE3 = 167,
    S_PLAY_XDIE4S_PLAY_XDIE4 = 168,
    S_PLAY_XDIE5S_PLAY_XDIE5 = 169,
    S_PLAY_XDIE6S_PLAY_XDIE6 = 170,
    S_PLAY_XDIE7S_PLAY_XDIE7 = 171,
    S_PLAY_XDIE8S_PLAY_XDIE8 = 172,
    S_PLAY_XDIE9S_PLAY_XDIE9 = 173,
    S_POSS_STNDS_POSS_STND = 174,
    S_POSS_STND2S_POSS_STND2 = 175,
    S_POSS_RUN1S_POSS_RUN1 = 176,
    S_POSS_RUN2S_POSS_RUN2 = 177,
    S_POSS_RUN3S_POSS_RUN3 = 178,
    S_POSS_RUN4S_POSS_RUN4 = 179,
    S_POSS_RUN5S_POSS_RUN5 = 180,
    S_POSS_RUN6S_POSS_RUN6 = 181,
    S_POSS_RUN7S_POSS_RUN7 = 182,
    S_POSS_RUN8S_POSS_RUN8 = 183,
    S_POSS_ATK1S_POSS_ATK1 = 184,
    S_POSS_ATK2S_POSS_ATK2 = 185,
    S_POSS_ATK3S_POSS_ATK3 = 186,
    S_POSS_PAINS_POSS_PAIN = 187,
    S_POSS_PAIN2S_POSS_PAIN2 = 188,
    S_POSS_DIE1S_POSS_DIE1 = 189,
    S_POSS_DIE2S_POSS_DIE2 = 190,
    S_POSS_DIE3S_POSS_DIE3 = 191,
    S_POSS_DIE4S_POSS_DIE4 = 192,
    S_POSS_DIE5S_POSS_DIE5 = 193,
    S_POSS_XDIE1S_POSS_XDIE1 = 194,
    S_POSS_XDIE2S_POSS_XDIE2 = 195,
    S_POSS_XDIE3S_POSS_XDIE3 = 196,
    S_POSS_XDIE4S_POSS_XDIE4 = 197,
    S_POSS_XDIE5S_POSS_XDIE5 = 198,
    S_POSS_XDIE6S_POSS_XDIE6 = 199,
    S_POSS_XDIE7S_POSS_XDIE7 = 200,
    S_POSS_XDIE8S_POSS_XDIE8 = 201,
    S_POSS_XDIE9S_POSS_XDIE9 = 202,
    S_POSS_RAISE1S_POSS_RAISE1 = 203,
    S_POSS_RAISE2S_POSS_RAISE2 = 204,
    S_POSS_RAISE3S_POSS_RAISE3 = 205,
    S_POSS_RAISE4S_POSS_RAISE4 = 206,
    S_SPOS_STNDS_SPOS_STND = 207,
    S_SPOS_STND2S_SPOS_STND2 = 208,
    S_SPOS_RUN1S_SPOS_RUN1 = 209,
    S_SPOS_RUN2S_SPOS_RUN2 = 210,
    S_SPOS_RUN3S_SPOS_RUN3 = 211,
    S_SPOS_RUN4S_SPOS_RUN4 = 212,
    S_SPOS_RUN5S_SPOS_RUN5 = 213,
    S_SPOS_RUN6S_SPOS_RUN6 = 214,
    S_SPOS_RUN7S_SPOS_RUN7 = 215,
    S_SPOS_RUN8S_SPOS_RUN8 = 216,
    S_SPOS_ATK1S_SPOS_ATK1 = 217,
    S_SPOS_ATK2S_SPOS_ATK2 = 218,
    S_SPOS_ATK3S_SPOS_ATK3 = 219,
    S_SPOS_PAINS_SPOS_PAIN = 220,
    S_SPOS_PAIN2S_SPOS_PAIN2 = 221,
    S_SPOS_DIE1S_SPOS_DIE1 = 222,
    S_SPOS_DIE2S_SPOS_DIE2 = 223,
    S_SPOS_DIE3S_SPOS_DIE3 = 224,
    S_SPOS_DIE4S_SPOS_DIE4 = 225,
    S_SPOS_DIE5S_SPOS_DIE5 = 226,
    S_SPOS_XDIE1S_SPOS_XDIE1 = 227,
    S_SPOS_XDIE2S_SPOS_XDIE2 = 228,
    S_SPOS_XDIE3S_SPOS_XDIE3 = 229,
    S_SPOS_XDIE4S_SPOS_XDIE4 = 230,
    S_SPOS_XDIE5S_SPOS_XDIE5 = 231,
    S_SPOS_XDIE6S_SPOS_XDIE6 = 232,
    S_SPOS_XDIE7S_SPOS_XDIE7 = 233,
    S_SPOS_XDIE8S_SPOS_XDIE8 = 234,
    S_SPOS_XDIE9S_SPOS_XDIE9 = 235,
    S_SPOS_RAISE1S_SPOS_RAISE1 = 236,
    S_SPOS_RAISE2S_SPOS_RAISE2 = 237,
    S_SPOS_RAISE3S_SPOS_RAISE3 = 238,
    S_SPOS_RAISE4S_SPOS_RAISE4 = 239,
    S_SPOS_RAISE5S_SPOS_RAISE5 = 240,
    S_VILE_STNDS_VILE_STND = 241,
    S_VILE_STND2S_VILE_STND2 = 242,
    S_VILE_RUN1S_VILE_RUN1 = 243,
    S_VILE_RUN2S_VILE_RUN2 = 244,
    S_VILE_RUN3S_VILE_RUN3 = 245,
    S_VILE_RUN4S_VILE_RUN4 = 246,
    S_VILE_RUN5S_VILE_RUN5 = 247,
    S_VILE_RUN6S_VILE_RUN6 = 248,
    S_VILE_RUN7S_VILE_RUN7 = 249,
    S_VILE_RUN8S_VILE_RUN8 = 250,
    S_VILE_RUN9S_VILE_RUN9 = 251,
    S_VILE_RUN10S_VILE_RUN10 = 252,
    S_VILE_RUN11S_VILE_RUN11 = 253,
    S_VILE_RUN12S_VILE_RUN12 = 254,
    S_VILE_ATK1S_VILE_ATK1 = 255,
    S_VILE_ATK2S_VILE_ATK2 = 256,
    S_VILE_ATK3S_VILE_ATK3 = 257,
    S_VILE_ATK4S_VILE_ATK4 = 258,
    S_VILE_ATK5S_VILE_ATK5 = 259,
    S_VILE_ATK6S_VILE_ATK6 = 260,
    S_VILE_ATK7S_VILE_ATK7 = 261,
    S_VILE_ATK8S_VILE_ATK8 = 262,
    S_VILE_ATK9S_VILE_ATK9 = 263,
    S_VILE_ATK10S_VILE_ATK10 = 264,
    S_VILE_ATK11S_VILE_ATK11 = 265,
    S_VILE_HEAL1S_VILE_HEAL1 = 266,
    S_VILE_HEAL2S_VILE_HEAL2 = 267,
    S_VILE_HEAL3S_VILE_HEAL3 = 268,
    S_VILE_PAINS_VILE_PAIN = 269,
    S_VILE_PAIN2S_VILE_PAIN2 = 270,
    S_VILE_DIE1S_VILE_DIE1 = 271,
    S_VILE_DIE2S_VILE_DIE2 = 272,
    S_VILE_DIE3S_VILE_DIE3 = 273,
    S_VILE_DIE4S_VILE_DIE4 = 274,
    S_VILE_DIE5S_VILE_DIE5 = 275,
    S_VILE_DIE6S_VILE_DIE6 = 276,
    S_VILE_DIE7S_VILE_DIE7 = 277,
    S_VILE_DIE8S_VILE_DIE8 = 278,
    S_VILE_DIE9S_VILE_DIE9 = 279,
    S_VILE_DIE10S_VILE_DIE10 = 280,
    S_FIRE1S_FIRE1 = 281,
    S_FIRE2S_FIRE2 = 282,
    S_FIRE3S_FIRE3 = 283,
    S_FIRE4S_FIRE4 = 284,
    S_FIRE5S_FIRE5 = 285,
    S_FIRE6S_FIRE6 = 286,
    S_FIRE7S_FIRE7 = 287,
    S_FIRE8S_FIRE8 = 288,
    S_FIRE9S_FIRE9 = 289,
    S_FIRE10S_FIRE10 = 290,
    S_FIRE11S_FIRE11 = 291,
    S_FIRE12S_FIRE12 = 292,
    S_FIRE13S_FIRE13 = 293,
    S_FIRE14S_FIRE14 = 294,
    S_FIRE15S_FIRE15 = 295,
    S_FIRE16S_FIRE16 = 296,
    S_FIRE17S_FIRE17 = 297,
    S_FIRE18S_FIRE18 = 298,
    S_FIRE19S_FIRE19 = 299,
    S_FIRE20S_FIRE20 = 300,
    S_FIRE21S_FIRE21 = 301,
    S_FIRE22S_FIRE22 = 302,
    S_FIRE23S_FIRE23 = 303,
    S_FIRE24S_FIRE24 = 304,
    S_FIRE25S_FIRE25 = 305,
    S_FIRE26S_FIRE26 = 306,
    S_FIRE27S_FIRE27 = 307,
    S_FIRE28S_FIRE28 = 308,
    S_FIRE29S_FIRE29 = 309,
    S_FIRE30S_FIRE30 = 310,
    S_SMOKE1S_SMOKE1 = 311,
    S_SMOKE2S_SMOKE2 = 312,
    S_SMOKE3S_SMOKE3 = 313,
    S_SMOKE4S_SMOKE4 = 314,
    S_SMOKE5S_SMOKE5 = 315,
    S_TRACERS_TRACER = 316,
    S_TRACER2S_TRACER2 = 317,
    S_TRACEEXP1S_TRACEEXP1 = 318,
    S_TRACEEXP2S_TRACEEXP2 = 319,
    S_TRACEEXP3S_TRACEEXP3 = 320,
    S_SKEL_STNDS_SKEL_STND = 321,
    S_SKEL_STND2S_SKEL_STND2 = 322,
    S_SKEL_RUN1S_SKEL_RUN1 = 323,
    S_SKEL_RUN2S_SKEL_RUN2 = 324,
    S_SKEL_RUN3S_SKEL_RUN3 = 325,
    S_SKEL_RUN4S_SKEL_RUN4 = 326,
    S_SKEL_RUN5S_SKEL_RUN5 = 327,
    S_SKEL_RUN6S_SKEL_RUN6 = 328,
    S_SKEL_RUN7S_SKEL_RUN7 = 329,
    S_SKEL_RUN8S_SKEL_RUN8 = 330,
    S_SKEL_RUN9S_SKEL_RUN9 = 331,
    S_SKEL_RUN10S_SKEL_RUN10 = 332,
    S_SKEL_RUN11S_SKEL_RUN11 = 333,
    S_SKEL_RUN12S_SKEL_RUN12 = 334,
    S_SKEL_FIST1S_SKEL_FIST1 = 335,
    S_SKEL_FIST2S_SKEL_FIST2 = 336,
    S_SKEL_FIST3S_SKEL_FIST3 = 337,
    S_SKEL_FIST4S_SKEL_FIST4 = 338,
    S_SKEL_MISS1S_SKEL_MISS1 = 339,
    S_SKEL_MISS2S_SKEL_MISS2 = 340,
    S_SKEL_MISS3S_SKEL_MISS3 = 341,
    S_SKEL_MISS4S_SKEL_MISS4 = 342,
    S_SKEL_PAINS_SKEL_PAIN = 343,
    S_SKEL_PAIN2S_SKEL_PAIN2 = 344,
    S_SKEL_DIE1S_SKEL_DIE1 = 345,
    S_SKEL_DIE2S_SKEL_DIE2 = 346,
    S_SKEL_DIE3S_SKEL_DIE3 = 347,
    S_SKEL_DIE4S_SKEL_DIE4 = 348,
    S_SKEL_DIE5S_SKEL_DIE5 = 349,
    S_SKEL_DIE6S_SKEL_DIE6 = 350,
    S_SKEL_RAISE1S_SKEL_RAISE1 = 351,
    S_SKEL_RAISE2S_SKEL_RAISE2 = 352,
    S_SKEL_RAISE3S_SKEL_RAISE3 = 353,
    S_SKEL_RAISE4S_SKEL_RAISE4 = 354,
    S_SKEL_RAISE5S_SKEL_RAISE5 = 355,
    S_SKEL_RAISE6S_SKEL_RAISE6 = 356,
    S_FATSHOT1S_FATSHOT1 = 357,
    S_FATSHOT2S_FATSHOT2 = 358,
    S_FATSHOTX1S_FATSHOTX1 = 359,
    S_FATSHOTX2S_FATSHOTX2 = 360,
    S_FATSHOTX3S_FATSHOTX3 = 361,
    S_FATT_STNDS_FATT_STND = 362,
    S_FATT_STND2S_FATT_STND2 = 363,
    S_FATT_RUN1S_FATT_RUN1 = 364,
    S_FATT_RUN2S_FATT_RUN2 = 365,
    S_FATT_RUN3S_FATT_RUN3 = 366,
    S_FATT_RUN4S_FATT_RUN4 = 367,
    S_FATT_RUN5S_FATT_RUN5 = 368,
    S_FATT_RUN6S_FATT_RUN6 = 369,
    S_FATT_RUN7S_FATT_RUN7 = 370,
    S_FATT_RUN8S_FATT_RUN8 = 371,
    S_FATT_RUN9S_FATT_RUN9 = 372,
    S_FATT_RUN10S_FATT_RUN10 = 373,
    S_FATT_RUN11S_FATT_RUN11 = 374,
    S_FATT_RUN12S_FATT_RUN12 = 375,
    S_FATT_ATK1S_FATT_ATK1 = 376,
    S_FATT_ATK2S_FATT_ATK2 = 377,
    S_FATT_ATK3S_FATT_ATK3 = 378,
    S_FATT_ATK4S_FATT_ATK4 = 379,
    S_FATT_ATK5S_FATT_ATK5 = 380,
    S_FATT_ATK6S_FATT_ATK6 = 381,
    S_FATT_ATK7S_FATT_ATK7 = 382,
    S_FATT_ATK8S_FATT_ATK8 = 383,
    S_FATT_ATK9S_FATT_ATK9 = 384,
    S_FATT_ATK10S_FATT_ATK10 = 385,
    S_FATT_PAINS_FATT_PAIN = 386,
    S_FATT_PAIN2S_FATT_PAIN2 = 387,
    S_FATT_DIE1S_FATT_DIE1 = 388,
    S_FATT_DIE2S_FATT_DIE2 = 389,
    S_FATT_DIE3S_FATT_DIE3 = 390,
    S_FATT_DIE4S_FATT_DIE4 = 391,
    S_FATT_DIE5S_FATT_DIE5 = 392,
    S_FATT_DIE6S_FATT_DIE6 = 393,
    S_FATT_DIE7S_FATT_DIE7 = 394,
    S_FATT_DIE8S_FATT_DIE8 = 395,
    S_FATT_DIE9S_FATT_DIE9 = 396,
    S_FATT_DIE10S_FATT_DIE10 = 397,
    S_FATT_RAISE1S_FATT_RAISE1 = 398,
    S_FATT_RAISE2S_FATT_RAISE2 = 399,
    S_FATT_RAISE3S_FATT_RAISE3 = 400,
    S_FATT_RAISE4S_FATT_RAISE4 = 401,
    S_FATT_RAISE5S_FATT_RAISE5 = 402,
    S_FATT_RAISE6S_FATT_RAISE6 = 403,
    S_FATT_RAISE7S_FATT_RAISE7 = 404,
    S_FATT_RAISE8S_FATT_RAISE8 = 405,
    S_CPOS_STNDS_CPOS_STND = 406,
    S_CPOS_STND2S_CPOS_STND2 = 407,
    S_CPOS_RUN1S_CPOS_RUN1 = 408,
    S_CPOS_RUN2S_CPOS_RUN2 = 409,
    S_CPOS_RUN3S_CPOS_RUN3 = 410,
    S_CPOS_RUN4S_CPOS_RUN4 = 411,
    S_CPOS_RUN5S_CPOS_RUN5 = 412,
    S_CPOS_RUN6S_CPOS_RUN6 = 413,
    S_CPOS_RUN7S_CPOS_RUN7 = 414,
    S_CPOS_RUN8S_CPOS_RUN8 = 415,
    S_CPOS_ATK1S_CPOS_ATK1 = 416,
    S_CPOS_ATK2S_CPOS_ATK2 = 417,
    S_CPOS_ATK3S_CPOS_ATK3 = 418,
    S_CPOS_ATK4S_CPOS_ATK4 = 419,
    S_CPOS_PAINS_CPOS_PAIN = 420,
    S_CPOS_PAIN2S_CPOS_PAIN2 = 421,
    S_CPOS_DIE1S_CPOS_DIE1 = 422,
    S_CPOS_DIE2S_CPOS_DIE2 = 423,
    S_CPOS_DIE3S_CPOS_DIE3 = 424,
    S_CPOS_DIE4S_CPOS_DIE4 = 425,
    S_CPOS_DIE5S_CPOS_DIE5 = 426,
    S_CPOS_DIE6S_CPOS_DIE6 = 427,
    S_CPOS_DIE7S_CPOS_DIE7 = 428,
    S_CPOS_XDIE1S_CPOS_XDIE1 = 429,
    S_CPOS_XDIE2S_CPOS_XDIE2 = 430,
    S_CPOS_XDIE3S_CPOS_XDIE3 = 431,
    S_CPOS_XDIE4S_CPOS_XDIE4 = 432,
    S_CPOS_XDIE5S_CPOS_XDIE5 = 433,
    S_CPOS_XDIE6S_CPOS_XDIE6 = 434,
    S_CPOS_RAISE1S_CPOS_RAISE1 = 435,
    S_CPOS_RAISE2S_CPOS_RAISE2 = 436,
    S_CPOS_RAISE3S_CPOS_RAISE3 = 437,
    S_CPOS_RAISE4S_CPOS_RAISE4 = 438,
    S_CPOS_RAISE5S_CPOS_RAISE5 = 439,
    S_CPOS_RAISE6S_CPOS_RAISE6 = 440,
    S_CPOS_RAISE7S_CPOS_RAISE7 = 441,
    S_TROO_STNDS_TROO_STND = 442,
    S_TROO_STND2S_TROO_STND2 = 443,
    S_TROO_RUN1S_TROO_RUN1 = 444,
    S_TROO_RUN2S_TROO_RUN2 = 445,
    S_TROO_RUN3S_TROO_RUN3 = 446,
    S_TROO_RUN4S_TROO_RUN4 = 447,
    S_TROO_RUN5S_TROO_RUN5 = 448,
    S_TROO_RUN6S_TROO_RUN6 = 449,
    S_TROO_RUN7S_TROO_RUN7 = 450,
    S_TROO_RUN8S_TROO_RUN8 = 451,
    S_TROO_ATK1S_TROO_ATK1 = 452,
    S_TROO_ATK2S_TROO_ATK2 = 453,
    S_TROO_ATK3S_TROO_ATK3 = 454,
    S_TROO_PAINS_TROO_PAIN = 455,
    S_TROO_PAIN2S_TROO_PAIN2 = 456,
    S_TROO_DIE1S_TROO_DIE1 = 457,
    S_TROO_DIE2S_TROO_DIE2 = 458,
    S_TROO_DIE3S_TROO_DIE3 = 459,
    S_TROO_DIE4S_TROO_DIE4 = 460,
    S_TROO_DIE5S_TROO_DIE5 = 461,
    S_TROO_XDIE1S_TROO_XDIE1 = 462,
    S_TROO_XDIE2S_TROO_XDIE2 = 463,
    S_TROO_XDIE3S_TROO_XDIE3 = 464,
    S_TROO_XDIE4S_TROO_XDIE4 = 465,
    S_TROO_XDIE5S_TROO_XDIE5 = 466,
    S_TROO_XDIE6S_TROO_XDIE6 = 467,
    S_TROO_XDIE7S_TROO_XDIE7 = 468,
    S_TROO_XDIE8S_TROO_XDIE8 = 469,
    S_TROO_RAISE1S_TROO_RAISE1 = 470,
    S_TROO_RAISE2S_TROO_RAISE2 = 471,
    S_TROO_RAISE3S_TROO_RAISE3 = 472,
    S_TROO_RAISE4S_TROO_RAISE4 = 473,
    S_TROO_RAISE5S_TROO_RAISE5 = 474,
    S_SARG_STNDS_SARG_STND = 475,
    S_SARG_STND2S_SARG_STND2 = 476,
    S_SARG_RUN1S_SARG_RUN1 = 477,
    S_SARG_RUN2S_SARG_RUN2 = 478,
    S_SARG_RUN3S_SARG_RUN3 = 479,
    S_SARG_RUN4S_SARG_RUN4 = 480,
    S_SARG_RUN5S_SARG_RUN5 = 481,
    S_SARG_RUN6S_SARG_RUN6 = 482,
    S_SARG_RUN7S_SARG_RUN7 = 483,
    S_SARG_RUN8S_SARG_RUN8 = 484,
    S_SARG_ATK1S_SARG_ATK1 = 485,
    S_SARG_ATK2S_SARG_ATK2 = 486,
    S_SARG_ATK3S_SARG_ATK3 = 487,
    S_SARG_PAINS_SARG_PAIN = 488,
    S_SARG_PAIN2S_SARG_PAIN2 = 489,
    S_SARG_DIE1S_SARG_DIE1 = 490,
    S_SARG_DIE2S_SARG_DIE2 = 491,
    S_SARG_DIE3S_SARG_DIE3 = 492,
    S_SARG_DIE4S_SARG_DIE4 = 493,
    S_SARG_DIE5S_SARG_DIE5 = 494,
    S_SARG_DIE6S_SARG_DIE6 = 495,
    S_SARG_RAISE1S_SARG_RAISE1 = 496,
    S_SARG_RAISE2S_SARG_RAISE2 = 497,
    S_SARG_RAISE3S_SARG_RAISE3 = 498,
    S_SARG_RAISE4S_SARG_RAISE4 = 499,
    S_SARG_RAISE5S_SARG_RAISE5 = 500,
    S_SARG_RAISE6S_SARG_RAISE6 = 501,
    S_HEAD_STNDS_HEAD_STND = 502,
    S_HEAD_RUN1S_HEAD_RUN1 = 503,
    S_HEAD_ATK1S_HEAD_ATK1 = 504,
    S_HEAD_ATK2S_HEAD_ATK2 = 505,
    S_HEAD_ATK3S_HEAD_ATK3 = 506,
    S_HEAD_PAINS_HEAD_PAIN = 507,
    S_HEAD_PAIN2S_HEAD_PAIN2 = 508,
    S_HEAD_PAIN3S_HEAD_PAIN3 = 509,
    S_HEAD_DIE1S_HEAD_DIE1 = 510,
    S_HEAD_DIE2S_HEAD_DIE2 = 511,
    S_HEAD_DIE3S_HEAD_DIE3 = 512,
    S_HEAD_DIE4S_HEAD_DIE4 = 513,
    S_HEAD_DIE5S_HEAD_DIE5 = 514,
    S_HEAD_DIE6S_HEAD_DIE6 = 515,
    S_HEAD_RAISE1S_HEAD_RAISE1 = 516,
    S_HEAD_RAISE2S_HEAD_RAISE2 = 517,
    S_HEAD_RAISE3S_HEAD_RAISE3 = 518,
    S_HEAD_RAISE4S_HEAD_RAISE4 = 519,
    S_HEAD_RAISE5S_HEAD_RAISE5 = 520,
    S_HEAD_RAISE6S_HEAD_RAISE6 = 521,
    S_BRBALL1S_BRBALL1 = 522,
    S_BRBALL2S_BRBALL2 = 523,
    S_BRBALLX1S_BRBALLX1 = 524,
    S_BRBALLX2S_BRBALLX2 = 525,
    S_BRBALLX3S_BRBALLX3 = 526,
    S_BOSS_STNDS_BOSS_STND = 527,
    S_BOSS_STND2S_BOSS_STND2 = 528,
    S_BOSS_RUN1S_BOSS_RUN1 = 529,
    S_BOSS_RUN2S_BOSS_RUN2 = 530,
    S_BOSS_RUN3S_BOSS_RUN3 = 531,
    S_BOSS_RUN4S_BOSS_RUN4 = 532,
    S_BOSS_RUN5S_BOSS_RUN5 = 533,
    S_BOSS_RUN6S_BOSS_RUN6 = 534,
    S_BOSS_RUN7S_BOSS_RUN7 = 535,
    S_BOSS_RUN8S_BOSS_RUN8 = 536,
    S_BOSS_ATK1S_BOSS_ATK1 = 537,
    S_BOSS_ATK2S_BOSS_ATK2 = 538,
    S_BOSS_ATK3S_BOSS_ATK3 = 539,
    S_BOSS_PAINS_BOSS_PAIN = 540,
    S_BOSS_PAIN2S_BOSS_PAIN2 = 541,
    S_BOSS_DIE1S_BOSS_DIE1 = 542,
    S_BOSS_DIE2S_BOSS_DIE2 = 543,
    S_BOSS_DIE3S_BOSS_DIE3 = 544,
    S_BOSS_DIE4S_BOSS_DIE4 = 545,
    S_BOSS_DIE5S_BOSS_DIE5 = 546,
    S_BOSS_DIE6S_BOSS_DIE6 = 547,
    S_BOSS_DIE7S_BOSS_DIE7 = 548,
    S_BOSS_RAISE1S_BOSS_RAISE1 = 549,
    S_BOSS_RAISE2S_BOSS_RAISE2 = 550,
    S_BOSS_RAISE3S_BOSS_RAISE3 = 551,
    S_BOSS_RAISE4S_BOSS_RAISE4 = 552,
    S_BOSS_RAISE5S_BOSS_RAISE5 = 553,
    S_BOSS_RAISE6S_BOSS_RAISE6 = 554,
    S_BOSS_RAISE7S_BOSS_RAISE7 = 555,
    S_BOS2_STNDS_BOS2_STND = 556,
    S_BOS2_STND2S_BOS2_STND2 = 557,
    S_BOS2_RUN1S_BOS2_RUN1 = 558,
    S_BOS2_RUN2S_BOS2_RUN2 = 559,
    S_BOS2_RUN3S_BOS2_RUN3 = 560,
    S_BOS2_RUN4S_BOS2_RUN4 = 561,
    S_BOS2_RUN5S_BOS2_RUN5 = 562,
    S_BOS2_RUN6S_BOS2_RUN6 = 563,
    S_BOS2_RUN7S_BOS2_RUN7 = 564,
    S_BOS2_RUN8S_BOS2_RUN8 = 565,
    S_BOS2_ATK1S_BOS2_ATK1 = 566,
    S_BOS2_ATK2S_BOS2_ATK2 = 567,
    S_BOS2_ATK3S_BOS2_ATK3 = 568,
    S_BOS2_PAINS_BOS2_PAIN = 569,
    S_BOS2_PAIN2S_BOS2_PAIN2 = 570,
    S_BOS2_DIE1S_BOS2_DIE1 = 571,
    S_BOS2_DIE2S_BOS2_DIE2 = 572,
    S_BOS2_DIE3S_BOS2_DIE3 = 573,
    S_BOS2_DIE4S_BOS2_DIE4 = 574,
    S_BOS2_DIE5S_BOS2_DIE5 = 575,
    S_BOS2_DIE6S_BOS2_DIE6 = 576,
    S_BOS2_DIE7S_BOS2_DIE7 = 577,
    S_BOS2_RAISE1S_BOS2_RAISE1 = 578,
    S_BOS2_RAISE2S_BOS2_RAISE2 = 579,
    S_BOS2_RAISE3S_BOS2_RAISE3 = 580,
    S_BOS2_RAISE4S_BOS2_RAISE4 = 581,
    S_BOS2_RAISE5S_BOS2_RAISE5 = 582,
    S_BOS2_RAISE6S_BOS2_RAISE6 = 583,
    S_BOS2_RAISE7S_BOS2_RAISE7 = 584,
    S_SKULL_STNDS_SKULL_STND = 585,
    S_SKULL_STND2S_SKULL_STND2 = 586,
    S_SKULL_RUN1S_SKULL_RUN1 = 587,
    S_SKULL_RUN2S_SKULL_RUN2 = 588,
    S_SKULL_ATK1S_SKULL_ATK1 = 589,
    S_SKULL_ATK2S_SKULL_ATK2 = 590,
    S_SKULL_ATK3S_SKULL_ATK3 = 591,
    S_SKULL_ATK4S_SKULL_ATK4 = 592,
    S_SKULL_PAINS_SKULL_PAIN = 593,
    S_SKULL_PAIN2S_SKULL_PAIN2 = 594,
    S_SKULL_DIE1S_SKULL_DIE1 = 595,
    S_SKULL_DIE2S_SKULL_DIE2 = 596,
    S_SKULL_DIE3S_SKULL_DIE3 = 597,
    S_SKULL_DIE4S_SKULL_DIE4 = 598,
    S_SKULL_DIE5S_SKULL_DIE5 = 599,
    S_SKULL_DIE6S_SKULL_DIE6 = 600,
    S_SPID_STNDS_SPID_STND = 601,
    S_SPID_STND2S_SPID_STND2 = 602,
    S_SPID_RUN1S_SPID_RUN1 = 603,
    S_SPID_RUN2S_SPID_RUN2 = 604,
    S_SPID_RUN3S_SPID_RUN3 = 605,
    S_SPID_RUN4S_SPID_RUN4 = 606,
    S_SPID_RUN5S_SPID_RUN5 = 607,
    S_SPID_RUN6S_SPID_RUN6 = 608,
    S_SPID_RUN7S_SPID_RUN7 = 609,
    S_SPID_RUN8S_SPID_RUN8 = 610,
    S_SPID_RUN9S_SPID_RUN9 = 611,
    S_SPID_RUN10S_SPID_RUN10 = 612,
    S_SPID_RUN11S_SPID_RUN11 = 613,
    S_SPID_RUN12S_SPID_RUN12 = 614,
    S_SPID_ATK1S_SPID_ATK1 = 615,
    S_SPID_ATK2S_SPID_ATK2 = 616,
    S_SPID_ATK3S_SPID_ATK3 = 617,
    S_SPID_ATK4S_SPID_ATK4 = 618,
    S_SPID_PAINS_SPID_PAIN = 619,
    S_SPID_PAIN2S_SPID_PAIN2 = 620,
    S_SPID_DIE1S_SPID_DIE1 = 621,
    S_SPID_DIE2S_SPID_DIE2 = 622,
    S_SPID_DIE3S_SPID_DIE3 = 623,
    S_SPID_DIE4S_SPID_DIE4 = 624,
    S_SPID_DIE5S_SPID_DIE5 = 625,
    S_SPID_DIE6S_SPID_DIE6 = 626,
    S_SPID_DIE7S_SPID_DIE7 = 627,
    S_SPID_DIE8S_SPID_DIE8 = 628,
    S_SPID_DIE9S_SPID_DIE9 = 629,
    S_SPID_DIE10S_SPID_DIE10 = 630,
    S_SPID_DIE11S_SPID_DIE11 = 631,
    S_BSPI_STNDS_BSPI_STND = 632,
    S_BSPI_STND2S_BSPI_STND2 = 633,
    S_BSPI_SIGHTS_BSPI_SIGHT = 634,
    S_BSPI_RUN1S_BSPI_RUN1 = 635,
    S_BSPI_RUN2S_BSPI_RUN2 = 636,
    S_BSPI_RUN3S_BSPI_RUN3 = 637,
    S_BSPI_RUN4S_BSPI_RUN4 = 638,
    S_BSPI_RUN5S_BSPI_RUN5 = 639,
    S_BSPI_RUN6S_BSPI_RUN6 = 640,
    S_BSPI_RUN7S_BSPI_RUN7 = 641,
    S_BSPI_RUN8S_BSPI_RUN8 = 642,
    S_BSPI_RUN9S_BSPI_RUN9 = 643,
    S_BSPI_RUN10S_BSPI_RUN10 = 644,
    S_BSPI_RUN11S_BSPI_RUN11 = 645,
    S_BSPI_RUN12S_BSPI_RUN12 = 646,
    S_BSPI_ATK1S_BSPI_ATK1 = 647,
    S_BSPI_ATK2S_BSPI_ATK2 = 648,
    S_BSPI_ATK3S_BSPI_ATK3 = 649,
    S_BSPI_ATK4S_BSPI_ATK4 = 650,
    S_BSPI_PAINS_BSPI_PAIN = 651,
    S_BSPI_PAIN2S_BSPI_PAIN2 = 652,
    S_BSPI_DIE1S_BSPI_DIE1 = 653,
    S_BSPI_DIE2S_BSPI_DIE2 = 654,
    S_BSPI_DIE3S_BSPI_DIE3 = 655,
    S_BSPI_DIE4S_BSPI_DIE4 = 656,
    S_BSPI_DIE5S_BSPI_DIE5 = 657,
    S_BSPI_DIE6S_BSPI_DIE6 = 658,
    S_BSPI_DIE7S_BSPI_DIE7 = 659,
    S_BSPI_RAISE1S_BSPI_RAISE1 = 660,
    S_BSPI_RAISE2S_BSPI_RAISE2 = 661,
    S_BSPI_RAISE3S_BSPI_RAISE3 = 662,
    S_BSPI_RAISE4S_BSPI_RAISE4 = 663,
    S_BSPI_RAISE5S_BSPI_RAISE5 = 664,
    S_BSPI_RAISE6S_BSPI_RAISE6 = 665,
    S_BSPI_RAISE7S_BSPI_RAISE7 = 666,
    S_ARACH_PLAZS_ARACH_PLAZ = 667,
    S_ARACH_PLAZ2S_ARACH_PLAZ2 = 668,
    S_ARACH_PLEXS_ARACH_PLEX = 669,
    S_ARACH_PLEX2S_ARACH_PLEX2 = 670,
    S_ARACH_PLEX3S_ARACH_PLEX3 = 671,
    S_ARACH_PLEX4S_ARACH_PLEX4 = 672,
    S_ARACH_PLEX5S_ARACH_PLEX5 = 673,
    S_CYBER_STNDS_CYBER_STND = 674,
    S_CYBER_STND2S_CYBER_STND2 = 675,
    S_CYBER_RUN1S_CYBER_RUN1 = 676,
    S_CYBER_RUN2S_CYBER_RUN2 = 677,
    S_CYBER_RUN3S_CYBER_RUN3 = 678,
    S_CYBER_RUN4S_CYBER_RUN4 = 679,
    S_CYBER_RUN5S_CYBER_RUN5 = 680,
    S_CYBER_RUN6S_CYBER_RUN6 = 681,
    S_CYBER_RUN7S_CYBER_RUN7 = 682,
    S_CYBER_RUN8S_CYBER_RUN8 = 683,
    S_CYBER_ATK1S_CYBER_ATK1 = 684,
    S_CYBER_ATK2S_CYBER_ATK2 = 685,
    S_CYBER_ATK3S_CYBER_ATK3 = 686,
    S_CYBER_ATK4S_CYBER_ATK4 = 687,
    S_CYBER_ATK5S_CYBER_ATK5 = 688,
    S_CYBER_ATK6S_CYBER_ATK6 = 689,
    S_CYBER_PAINS_CYBER_PAIN = 690,
    S_CYBER_DIE1S_CYBER_DIE1 = 691,
    S_CYBER_DIE2S_CYBER_DIE2 = 692,
    S_CYBER_DIE3S_CYBER_DIE3 = 693,
    S_CYBER_DIE4S_CYBER_DIE4 = 694,
    S_CYBER_DIE5S_CYBER_DIE5 = 695,
    S_CYBER_DIE6S_CYBER_DIE6 = 696,
    S_CYBER_DIE7S_CYBER_DIE7 = 697,
    S_CYBER_DIE8S_CYBER_DIE8 = 698,
    S_CYBER_DIE9S_CYBER_DIE9 = 699,
    S_CYBER_DIE10S_CYBER_DIE10 = 700,
    S_PAIN_STNDS_PAIN_STND = 701,
    S_PAIN_RUN1S_PAIN_RUN1 = 702,
    S_PAIN_RUN2S_PAIN_RUN2 = 703,
    S_PAIN_RUN3S_PAIN_RUN3 = 704,
    S_PAIN_RUN4S_PAIN_RUN4 = 705,
    S_PAIN_RUN5S_PAIN_RUN5 = 706,
    S_PAIN_RUN6S_PAIN_RUN6 = 707,
    S_PAIN_ATK1S_PAIN_ATK1 = 708,
    S_PAIN_ATK2S_PAIN_ATK2 = 709,
    S_PAIN_ATK3S_PAIN_ATK3 = 710,
    S_PAIN_ATK4S_PAIN_ATK4 = 711,
    S_PAIN_PAINS_PAIN_PAIN = 712,
    S_PAIN_PAIN2S_PAIN_PAIN2 = 713,
    S_PAIN_DIE1S_PAIN_DIE1 = 714,
    S_PAIN_DIE2S_PAIN_DIE2 = 715,
    S_PAIN_DIE3S_PAIN_DIE3 = 716,
    S_PAIN_DIE4S_PAIN_DIE4 = 717,
    S_PAIN_DIE5S_PAIN_DIE5 = 718,
    S_PAIN_DIE6S_PAIN_DIE6 = 719,
    S_PAIN_RAISE1S_PAIN_RAISE1 = 720,
    S_PAIN_RAISE2S_PAIN_RAISE2 = 721,
    S_PAIN_RAISE3S_PAIN_RAISE3 = 722,
    S_PAIN_RAISE4S_PAIN_RAISE4 = 723,
    S_PAIN_RAISE5S_PAIN_RAISE5 = 724,
    S_PAIN_RAISE6S_PAIN_RAISE6 = 725,
    S_SSWV_STNDS_SSWV_STND = 726,
    S_SSWV_STND2S_SSWV_STND2 = 727,
    S_SSWV_RUN1S_SSWV_RUN1 = 728,
    S_SSWV_RUN2S_SSWV_RUN2 = 729,
    S_SSWV_RUN3S_SSWV_RUN3 = 730,
    S_SSWV_RUN4S_SSWV_RUN4 = 731,
    S_SSWV_RUN5S_SSWV_RUN5 = 732,
    S_SSWV_RUN6S_SSWV_RUN6 = 733,
    S_SSWV_RUN7S_SSWV_RUN7 = 734,
    S_SSWV_RUN8S_SSWV_RUN8 = 735,
    S_SSWV_ATK1S_SSWV_ATK1 = 736,
    S_SSWV_ATK2S_SSWV_ATK2 = 737,
    S_SSWV_ATK3S_SSWV_ATK3 = 738,
    S_SSWV_ATK4S_SSWV_ATK4 = 739,
    S_SSWV_ATK5S_SSWV_ATK5 = 740,
    S_SSWV_ATK6S_SSWV_ATK6 = 741,
    S_SSWV_PAINS_SSWV_PAIN = 742,
    S_SSWV_PAIN2S_SSWV_PAIN2 = 743,
    S_SSWV_DIE1S_SSWV_DIE1 = 744,
    S_SSWV_DIE2S_SSWV_DIE2 = 745,
    S_SSWV_DIE3S_SSWV_DIE3 = 746,
    S_SSWV_DIE4S_SSWV_DIE4 = 747,
    S_SSWV_DIE5S_SSWV_DIE5 = 748,
    S_SSWV_XDIE1S_SSWV_XDIE1 = 749,
    S_SSWV_XDIE2S_SSWV_XDIE2 = 750,
    S_SSWV_XDIE3S_SSWV_XDIE3 = 751,
    S_SSWV_XDIE4S_SSWV_XDIE4 = 752,
    S_SSWV_XDIE5S_SSWV_XDIE5 = 753,
    S_SSWV_XDIE6S_SSWV_XDIE6 = 754,
    S_SSWV_XDIE7S_SSWV_XDIE7 = 755,
    S_SSWV_XDIE8S_SSWV_XDIE8 = 756,
    S_SSWV_XDIE9S_SSWV_XDIE9 = 757,
    S_SSWV_RAISE1S_SSWV_RAISE1 = 758,
    S_SSWV_RAISE2S_SSWV_RAISE2 = 759,
    S_SSWV_RAISE3S_SSWV_RAISE3 = 760,
    S_SSWV_RAISE4S_SSWV_RAISE4 = 761,
    S_SSWV_RAISE5S_SSWV_RAISE5 = 762,
    S_KEENSTNDS_KEENSTND = 763,
    S_COMMKEENS_COMMKEEN = 764,
    S_COMMKEEN2S_COMMKEEN2 = 765,
    S_COMMKEEN3S_COMMKEEN3 = 766,
    S_COMMKEEN4S_COMMKEEN4 = 767,
    S_COMMKEEN5S_COMMKEEN5 = 768,
    S_COMMKEEN6S_COMMKEEN6 = 769,
    S_COMMKEEN7S_COMMKEEN7 = 770,
    S_COMMKEEN8S_COMMKEEN8 = 771,
    S_COMMKEEN9S_COMMKEEN9 = 772,
    S_COMMKEEN10S_COMMKEEN10 = 773,
    S_COMMKEEN11S_COMMKEEN11 = 774,
    S_COMMKEEN12S_COMMKEEN12 = 775,
    S_KEENPAINS_KEENPAIN = 776,
    S_KEENPAIN2S_KEENPAIN2 = 777,
    S_BRAINS_BRAIN = 778,
    S_BRAIN_PAINS_BRAIN_PAIN = 779,
    S_BRAIN_DIE1S_BRAIN_DIE1 = 780,
    S_BRAIN_DIE2S_BRAIN_DIE2 = 781,
    S_BRAIN_DIE3S_BRAIN_DIE3 = 782,
    S_BRAIN_DIE4S_BRAIN_DIE4 = 783,
    S_BRAINEYES_BRAINEYE = 784,
    S_BRAINEYESEES_BRAINEYESEE = 785,
    S_BRAINEYE1S_BRAINEYE1 = 786,
    S_SPAWN1S_SPAWN1 = 787,
    S_SPAWN2S_SPAWN2 = 788,
    S_SPAWN3S_SPAWN3 = 789,
    S_SPAWN4S_SPAWN4 = 790,
    S_SPAWNFIRE1S_SPAWNFIRE1 = 791,
    S_SPAWNFIRE2S_SPAWNFIRE2 = 792,
    S_SPAWNFIRE3S_SPAWNFIRE3 = 793,
    S_SPAWNFIRE4S_SPAWNFIRE4 = 794,
    S_SPAWNFIRE5S_SPAWNFIRE5 = 795,
    S_SPAWNFIRE6S_SPAWNFIRE6 = 796,
    S_SPAWNFIRE7S_SPAWNFIRE7 = 797,
    S_SPAWNFIRE8S_SPAWNFIRE8 = 798,
    S_BRAINEXPLODE1S_BRAINEXPLODE1 = 799,
    S_BRAINEXPLODE2S_BRAINEXPLODE2 = 800,
    S_BRAINEXPLODE3S_BRAINEXPLODE3 = 801,
    S_ARM1S_ARM1 = 802,
    S_ARM1AS_ARM1A = 803,
    S_ARM2S_ARM2 = 804,
    S_ARM2AS_ARM2A = 805,
    S_BAR1S_BAR1 = 806,
    S_BAR2S_BAR2 = 807,
    S_BEXPS_BEXP = 808,
    S_BEXP2S_BEXP2 = 809,
    S_BEXP3S_BEXP3 = 810,
    S_BEXP4S_BEXP4 = 811,
    S_BEXP5S_BEXP5 = 812,
    S_BBAR1S_BBAR1 = 813,
    S_BBAR2S_BBAR2 = 814,
    S_BBAR3S_BBAR3 = 815,
    S_BON1S_BON1 = 816,
    S_BON1AS_BON1A = 817,
    S_BON1BS_BON1B = 818,
    S_BON1CS_BON1C = 819,
    S_BON1DS_BON1D = 820,
    S_BON1ES_BON1E = 821,
    S_BON2S_BON2 = 822,
    S_BON2AS_BON2A = 823,
    S_BON2BS_BON2B = 824,
    S_BON2CS_BON2C = 825,
    S_BON2DS_BON2D = 826,
    S_BON2ES_BON2E = 827,
    S_BKEYS_BKEY = 828,
    S_BKEY2S_BKEY2 = 829,
    S_RKEYS_RKEY = 830,
    S_RKEY2S_RKEY2 = 831,
    S_YKEYS_YKEY = 832,
    S_YKEY2S_YKEY2 = 833,
    S_BSKULLS_BSKULL = 834,
    S_BSKULL2S_BSKULL2 = 835,
    S_RSKULLS_RSKULL = 836,
    S_RSKULL2S_RSKULL2 = 837,
    S_YSKULLS_YSKULL = 838,
    S_YSKULL2S_YSKULL2 = 839,
    S_STIMS_STIM = 840,
    S_MEDIS_MEDI = 841,
    S_SOULS_SOUL = 842,
    S_SOUL2S_SOUL2 = 843,
    S_SOUL3S_SOUL3 = 844,
    S_SOUL4S_SOUL4 = 845,
    S_SOUL5S_SOUL5 = 846,
    S_SOUL6S_SOUL6 = 847,
    S_PINVS_PINV = 848,
    S_PINV2S_PINV2 = 849,
    S_PINV3S_PINV3 = 850,
    S_PINV4S_PINV4 = 851,
    S_PSTRS_PSTR = 852,
    S_PINSS_PINS = 853,
    S_PINS2S_PINS2 = 854,
    S_PINS3S_PINS3 = 855,
    S_PINS4S_PINS4 = 856,
    S_MEGAS_MEGA = 857,
    S_MEGA2S_MEGA2 = 858,
    S_MEGA3S_MEGA3 = 859,
    S_MEGA4S_MEGA4 = 860,
    S_SUITS_SUIT = 861,
    S_PMAPS_PMAP = 862,
    S_PMAP2S_PMAP2 = 863,
    S_PMAP3S_PMAP3 = 864,
    S_PMAP4S_PMAP4 = 865,
    S_PMAP5S_PMAP5 = 866,
    S_PMAP6S_PMAP6 = 867,
    S_PVISS_PVIS = 868,
    S_PVIS2S_PVIS2 = 869,
    S_CLIPS_CLIP = 870,
    S_AMMOS_AMMO = 871,
    S_ROCKS_ROCK = 872,
    S_BROKS_BROK = 873,
    S_CELLS_CELL = 874,
    S_CELPS_CELP = 875,
    S_SHELS_SHEL = 876,
    S_SBOXS_SBOX = 877,
    S_BPAKS_BPAK = 878,
    S_BFUGS_BFUG = 879,
    S_MGUNS_MGUN = 880,
    S_CSAWS_CSAW = 881,
    S_LAUNS_LAUN = 882,
    S_PLASS_PLAS = 883,
    S_SHOTS_SHOT = 884,
    S_SHOT2S_SHOT2 = 885,
    S_COLUS_COLU = 886,
    S_STALAGS_STALAG = 887,
    S_BLOODYTWITCHS_BLOODYTWITCH = 888,
    S_BLOODYTWITCH2S_BLOODYTWITCH2 = 889,
    S_BLOODYTWITCH3S_BLOODYTWITCH3 = 890,
    S_BLOODYTWITCH4S_BLOODYTWITCH4 = 891,
    S_DEADTORSOS_DEADTORSO = 892,
    S_DEADBOTTOMS_DEADBOTTOM = 893,
    S_HEADSONSTICKS_HEADSONSTICK = 894,
    S_GIBSS_GIBS = 895,
    S_HEADONASTICKS_HEADONASTICK = 896,
    S_HEADCANDLESS_HEADCANDLES = 897,
    S_HEADCANDLES2S_HEADCANDLES2 = 898,
    S_DEADSTICKS_DEADSTICK = 899,
    S_LIVESTICKS_LIVESTICK = 900,
    S_LIVESTICK2S_LIVESTICK2 = 901,
    S_MEAT2S_MEAT2 = 902,
    S_MEAT3S_MEAT3 = 903,
    S_MEAT4S_MEAT4 = 904,
    S_MEAT5S_MEAT5 = 905,
    S_STALAGTITES_STALAGTITE = 906,
    S_TALLGRNCOLS_TALLGRNCOL = 907,
    S_SHRTGRNCOLS_SHRTGRNCOL = 908,
    S_TALLREDCOLS_TALLREDCOL = 909,
    S_SHRTREDCOLS_SHRTREDCOL = 910,
    S_CANDLESTIKS_CANDLESTIK = 911,
    S_CANDELABRAS_CANDELABRA = 912,
    S_SKULLCOLS_SKULLCOL = 913,
    S_TORCHTREES_TORCHTREE = 914,
    S_BIGTREES_BIGTREE = 915,
    S_TECHPILLARS_TECHPILLAR = 916,
    S_EVILEYES_EVILEYE = 917,
    S_EVILEYE2S_EVILEYE2 = 918,
    S_EVILEYE3S_EVILEYE3 = 919,
    S_EVILEYE4S_EVILEYE4 = 920,
    S_FLOATSKULLS_FLOATSKULL = 921,
    S_FLOATSKULL2S_FLOATSKULL2 = 922,
    S_FLOATSKULL3S_FLOATSKULL3 = 923,
    S_HEARTCOLS_HEARTCOL = 924,
    S_HEARTCOL2S_HEARTCOL2 = 925,
    S_BLUETORCHS_BLUETORCH = 926,
    S_BLUETORCH2S_BLUETORCH2 = 927,
    S_BLUETORCH3S_BLUETORCH3 = 928,
    S_BLUETORCH4S_BLUETORCH4 = 929,
    S_GREENTORCHS_GREENTORCH = 930,
    S_GREENTORCH2S_GREENTORCH2 = 931,
    S_GREENTORCH3S_GREENTORCH3 = 932,
    S_GREENTORCH4S_GREENTORCH4 = 933,
    S_REDTORCHS_REDTORCH = 934,
    S_REDTORCH2S_REDTORCH2 = 935,
    S_REDTORCH3S_REDTORCH3 = 936,
    S_REDTORCH4S_REDTORCH4 = 937,
    S_BTORCHSHRTS_BTORCHSHRT = 938,
    S_BTORCHSHRT2S_BTORCHSHRT2 = 939,
    S_BTORCHSHRT3S_BTORCHSHRT3 = 940,
    S_BTORCHSHRT4S_BTORCHSHRT4 = 941,
    S_GTORCHSHRTS_GTORCHSHRT = 942,
    S_GTORCHSHRT2S_GTORCHSHRT2 = 943,
    S_GTORCHSHRT3S_GTORCHSHRT3 = 944,
    S_GTORCHSHRT4S_GTORCHSHRT4 = 945,
    S_RTORCHSHRTS_RTORCHSHRT = 946,
    S_RTORCHSHRT2S_RTORCHSHRT2 = 947,
    S_RTORCHSHRT3S_RTORCHSHRT3 = 948,
    S_RTORCHSHRT4S_RTORCHSHRT4 = 949,
    S_HANGNOGUTSS_HANGNOGUTS = 950,
    S_HANGBNOBRAINS_HANGBNOBRAIN = 951,
    S_HANGTLOOKDNS_HANGTLOOKDN = 952,
    S_HANGTSKULLS_HANGTSKULL = 953,
    S_HANGTLOOKUPS_HANGTLOOKUP = 954,
    S_HANGTNOBRAINS_HANGTNOBRAIN = 955,
    S_COLONGIBSS_COLONGIBS = 956,
    S_SMALLPOOLS_SMALLPOOL = 957,
    S_BRAINSTEMS_BRAINSTEM = 958,
    S_TECHLAMPS_TECHLAMP = 959,
    S_TECHLAMP2S_TECHLAMP2 = 960,
    S_TECHLAMP3S_TECHLAMP3 = 961,
    S_TECHLAMP4S_TECHLAMP4 = 962,
    S_TECH2LAMPS_TECH2LAMP = 963,
    S_TECH2LAMP2S_TECH2LAMP2 = 964,
    S_TECH2LAMP3S_TECH2LAMP3 = 965,
    S_TECH2LAMP4S_TECH2LAMP4 = 966,
    NUMSTATESNUMSTATES = 967
} ;
#line 174 "info.h"
typedef enum __anonenum_statenum_t_515532113 statenum_t;
#line 1147 "info.h"
struct __anonstruct_state_t_708344530 {
   spritenum_t sprite ;
   long frame ;
   long tics ;
   actionf_t action ;
   statenum_t nextstate ;
   long misc1 ;
   long misc2 ;
};
#line 1147 "info.h"
typedef struct __anonstruct_state_t_708344530 state_t;
#line 1163
enum __anonenum_mobjtype_t_436645562 {
    MT_PLAYERMT_PLAYER = 0,
    MT_POSSESSEDMT_POSSESSED = 1,
    MT_SHOTGUYMT_SHOTGUY = 2,
    MT_VILEMT_VILE = 3,
    MT_FIREMT_FIRE = 4,
    MT_UNDEADMT_UNDEAD = 5,
    MT_TRACERMT_TRACER = 6,
    MT_SMOKEMT_SMOKE = 7,
    MT_FATSOMT_FATSO = 8,
    MT_FATSHOTMT_FATSHOT = 9,
    MT_CHAINGUYMT_CHAINGUY = 10,
    MT_TROOPMT_TROOP = 11,
    MT_SERGEANTMT_SERGEANT = 12,
    MT_SHADOWSMT_SHADOWS = 13,
    MT_HEADMT_HEAD = 14,
    MT_BRUISERMT_BRUISER = 15,
    MT_BRUISERSHOTMT_BRUISERSHOT = 16,
    MT_KNIGHTMT_KNIGHT = 17,
    MT_SKULLMT_SKULL = 18,
    MT_SPIDERMT_SPIDER = 19,
    MT_BABYMT_BABY = 20,
    MT_CYBORGMT_CYBORG = 21,
    MT_PAINMT_PAIN = 22,
    MT_WOLFSSMT_WOLFSS = 23,
    MT_KEENMT_KEEN = 24,
    MT_BOSSBRAINMT_BOSSBRAIN = 25,
    MT_BOSSSPITMT_BOSSSPIT = 26,
    MT_BOSSTARGETMT_BOSSTARGET = 27,
    MT_SPAWNSHOTMT_SPAWNSHOT = 28,
    MT_SPAWNFIREMT_SPAWNFIRE = 29,
    MT_BARRELMT_BARREL = 30,
    MT_TROOPSHOTMT_TROOPSHOT = 31,
    MT_HEADSHOTMT_HEADSHOT = 32,
    MT_ROCKETMT_ROCKET = 33,
    MT_PLASMAMT_PLASMA = 34,
    MT_BFGMT_BFG = 35,
    MT_ARACHPLAZMT_ARACHPLAZ = 36,
    MT_PUFFMT_PUFF = 37,
    MT_BLOODMT_BLOOD = 38,
    MT_TFOGMT_TFOG = 39,
    MT_IFOGMT_IFOG = 40,
    MT_TELEPORTMANMT_TELEPORTMAN = 41,
    MT_EXTRABFGMT_EXTRABFG = 42,
    MT_MISC0MT_MISC0 = 43,
    MT_MISC1MT_MISC1 = 44,
    MT_MISC2MT_MISC2 = 45,
    MT_MISC3MT_MISC3 = 46,
    MT_MISC4MT_MISC4 = 47,
    MT_MISC5MT_MISC5 = 48,
    MT_MISC6MT_MISC6 = 49,
    MT_MISC7MT_MISC7 = 50,
    MT_MISC8MT_MISC8 = 51,
    MT_MISC9MT_MISC9 = 52,
    MT_MISC10MT_MISC10 = 53,
    MT_MISC11MT_MISC11 = 54,
    MT_MISC12MT_MISC12 = 55,
    MT_INVMT_INV = 56,
    MT_MISC13MT_MISC13 = 57,
    MT_INSMT_INS = 58,
    MT_MISC14MT_MISC14 = 59,
    MT_MISC15MT_MISC15 = 60,
    MT_MISC16MT_MISC16 = 61,
    MT_MEGAMT_MEGA = 62,
    MT_CLIPMT_CLIP = 63,
    MT_MISC17MT_MISC17 = 64,
    MT_MISC18MT_MISC18 = 65,
    MT_MISC19MT_MISC19 = 66,
    MT_MISC20MT_MISC20 = 67,
    MT_MISC21MT_MISC21 = 68,
    MT_MISC22MT_MISC22 = 69,
    MT_MISC23MT_MISC23 = 70,
    MT_MISC24MT_MISC24 = 71,
    MT_MISC25MT_MISC25 = 72,
    MT_CHAINGUNMT_CHAINGUN = 73,
    MT_MISC26MT_MISC26 = 74,
    MT_MISC27MT_MISC27 = 75,
    MT_MISC28MT_MISC28 = 76,
    MT_SHOTGUNMT_SHOTGUN = 77,
    MT_SUPERSHOTGUNMT_SUPERSHOTGUN = 78,
    MT_MISC29MT_MISC29 = 79,
    MT_MISC30MT_MISC30 = 80,
    MT_MISC31MT_MISC31 = 81,
    MT_MISC32MT_MISC32 = 82,
    MT_MISC33MT_MISC33 = 83,
    MT_MISC34MT_MISC34 = 84,
    MT_MISC35MT_MISC35 = 85,
    MT_MISC36MT_MISC36 = 86,
    MT_MISC37MT_MISC37 = 87,
    MT_MISC38MT_MISC38 = 88,
    MT_MISC39MT_MISC39 = 89,
    MT_MISC40MT_MISC40 = 90,
    MT_MISC41MT_MISC41 = 91,
    MT_MISC42MT_MISC42 = 92,
    MT_MISC43MT_MISC43 = 93,
    MT_MISC44MT_MISC44 = 94,
    MT_MISC45MT_MISC45 = 95,
    MT_MISC46MT_MISC46 = 96,
    MT_MISC47MT_MISC47 = 97,
    MT_MISC48MT_MISC48 = 98,
    MT_MISC49MT_MISC49 = 99,
    MT_MISC50MT_MISC50 = 100,
    MT_MISC51MT_MISC51 = 101,
    MT_MISC52MT_MISC52 = 102,
    MT_MISC53MT_MISC53 = 103,
    MT_MISC54MT_MISC54 = 104,
    MT_MISC55MT_MISC55 = 105,
    MT_MISC56MT_MISC56 = 106,
    MT_MISC57MT_MISC57 = 107,
    MT_MISC58MT_MISC58 = 108,
    MT_MISC59MT_MISC59 = 109,
    MT_MISC60MT_MISC60 = 110,
    MT_MISC61MT_MISC61 = 111,
    MT_MISC62MT_MISC62 = 112,
    MT_MISC63MT_MISC63 = 113,
    MT_MISC64MT_MISC64 = 114,
    MT_MISC65MT_MISC65 = 115,
    MT_MISC66MT_MISC66 = 116,
    MT_MISC67MT_MISC67 = 117,
    MT_MISC68MT_MISC68 = 118,
    MT_MISC69MT_MISC69 = 119,
    MT_MISC70MT_MISC70 = 120,
    MT_MISC71MT_MISC71 = 121,
    MT_MISC72MT_MISC72 = 122,
    MT_MISC73MT_MISC73 = 123,
    MT_MISC74MT_MISC74 = 124,
    MT_MISC75MT_MISC75 = 125,
    MT_MISC76MT_MISC76 = 126,
    MT_MISC77MT_MISC77 = 127,
    MT_MISC78MT_MISC78 = 128,
    MT_MISC79MT_MISC79 = 129,
    MT_MISC80MT_MISC80 = 130,
    MT_MISC81MT_MISC81 = 131,
    MT_MISC82MT_MISC82 = 132,
    MT_MISC83MT_MISC83 = 133,
    MT_MISC84MT_MISC84 = 134,
    MT_MISC85MT_MISC85 = 135,
    MT_MISC86MT_MISC86 = 136,
    NUMMOBJTYPESNUMMOBJTYPES = 137
} ;
#line 1163 "info.h"
typedef enum __anonenum_mobjtype_t_436645562 mobjtype_t;
#line 1305 "info.h"
struct __anonstruct_mobjinfo_t_1045287111 {
   int doomednum ;
   int spawnstate ;
   int spawnhealth ;
   int seestate ;
   int seesound ;
   int reactiontime ;
   int attacksound ;
   int painstate ;
   int painchance ;
   int painsound ;
   int meleestate ;
   int missilestate ;
   int deathstate ;
   int xdeathstate ;
   int deathsound ;
   int speed ;
   int radius ;
   int height ;
   int mass ;
   int damage ;
   int activesound ;
   int flags ;
   int raisestate ;
};
#line 1305 "info.h"
typedef struct __anonstruct_mobjinfo_t_1045287111 mobjinfo_t;
#line 60 "p_pspr.h"
enum __anonenum_psprnum_t_422619266 {
    ps_weaponps_weapon = 0,
    ps_flashps_flash = 1,
    NUMPSPRITESNUMPSPRITES = 2
} ;
#line 60 "p_pspr.h"
typedef enum __anonenum_psprnum_t_422619266 psprnum_t;
#line 68 "p_pspr.h"
struct __anonstruct_pspdef_t_147693923 {
   state_t *state ;
   int tics ;
   fixed_t sx ;
   fixed_t sy ;
};
#line 68 "p_pspr.h"
typedef struct __anonstruct_pspdef_t_147693923 pspdef_t;
#line 117 "p_mobj.h"
enum __anonenum_mobjflag_t_222494501 {
    MF_SPECIALMF_SPECIAL = 1,
    MF_SOLIDMF_SOLID = 2,
    MF_SHOOTABLEMF_SHOOTABLE = 4,
    MF_NOSECTORMF_NOSECTOR = 8,
    MF_NOBLOCKMAPMF_NOBLOCKMAP = 16,
    MF_AMBUSHMF_AMBUSH = 32,
    MF_JUSTHITMF_JUSTHIT = 64,
    MF_JUSTATTACKEDMF_JUSTATTACKED = 128,
    MF_SPAWNCEILINGMF_SPAWNCEILING = 256,
    MF_NOGRAVITYMF_NOGRAVITY = 512,
    MF_DROPOFFMF_DROPOFF = 1024,
    MF_PICKUPMF_PICKUP = 2048,
    MF_NOCLIPMF_NOCLIP = 4096,
    MF_SLIDEMF_SLIDE = 8192,
    MF_FLOATMF_FLOAT = 16384,
    MF_TELEPORTMF_TELEPORT = 32768,
    MF_MISSILEMF_MISSILE = 65536,
    MF_DROPPEDMF_DROPPED = 131072,
    MF_SHADOWMF_SHADOW = 262144,
    MF_NOBLOODMF_NOBLOOD = 524288,
    MF_CORPSEMF_CORPSE = 1048576,
    MF_INFLOATMF_INFLOAT = 2097152,
    MF_COUNTKILLMF_COUNTKILL = 4194304,
    MF_COUNTITEMMF_COUNTITEM = 8388608,
    MF_SKULLFLYMF_SKULLFLY = 16777216,
    MF_NOTDMATCHMF_NOTDMATCH = 33554432,
    MF_TRANSLATIONMF_TRANSLATION = 201326592,
    MF_TRANSSHIFTMF_TRANSSHIFT = 26
} ;
#line 117 "p_mobj.h"
typedef enum __anonenum_mobjflag_t_222494501 mobjflag_t;
#line 207
struct subsector_s ;
#line 207
struct player_s ;
#line 207 "p_mobj.h"
struct mobj_s {
   thinker_t thinker ;
   fixed_t x ;
   fixed_t y ;
   fixed_t z ;
   struct mobj_s *snext ;
   struct mobj_s *sprev ;
   angle_t angle ;
   spritenum_t sprite ;
   int frame ;
   struct mobj_s *bnext ;
   struct mobj_s *bprev ;
   struct subsector_s *subsector ;
   fixed_t floorz ;
   fixed_t ceilingz ;
   fixed_t radius ;
   fixed_t height ;
   fixed_t momx ;
   fixed_t momy ;
   fixed_t momz ;
   int validcount ;
   mobjtype_t type ;
   mobjinfo_t *info ;
   int tics ;
   state_t *state ;
   int flags ;
   int health ;
   int movedir ;
   int movecount ;
   struct mobj_s *target ;
   int reactiontime ;
   int threshold ;
   struct player_s *player ;
   int lastlook ;
   mapthing_t spawnpoint ;
   struct mobj_s *tracer ;
};
#line 207 "p_mobj.h"
typedef struct mobj_s mobj_t;
#line 36 "d_ticcmd.h"
struct __anonstruct_ticcmd_t_143343932 {
   char forwardmove ;
   char sidemove ;
   short angleturn ;
   short consistancy ;
   byte chatchar ;
   byte buttons ;
};
#line 36 "d_ticcmd.h"
typedef struct __anonstruct_ticcmd_t_143343932 ticcmd_t;
#line 53 "d_player.h"
enum __anonenum_playerstate_t_84783675 {
    PST_LIVEPST_LIVE = 0,
    PST_DEADPST_DEAD = 1,
    PST_REBORNPST_REBORN = 2
} ;
#line 53 "d_player.h"
typedef enum __anonenum_playerstate_t_84783675 playerstate_t;
#line 68
enum __anonenum_cheat_t_408071005 {
    CF_NOCLIPCF_NOCLIP = 1,
    CF_GODMODECF_GODMODE = 2,
    CF_NOMOMENTUMCF_NOMOMENTUM = 4
} ;
#line 68 "d_player.h"
typedef enum __anonenum_cheat_t_408071005 cheat_t;
#line 83 "d_player.h"
struct player_s {
   mobj_t *mo ;
   playerstate_t playerstate ;
   ticcmd_t cmd ;
   fixed_t viewz ;
   fixed_t viewheight ;
   fixed_t deltaviewheight ;
   fixed_t bob ;
   int health ;
   int armorpoints ;
   int armortype ;
   int powers[6] ;
   boolean cards[6] ;
   boolean backpack ;
   int frags[4] ;
   weapontype_t readyweapon ;
   weapontype_t pendingweapon ;
   boolean weaponowned[9] ;
   int ammo[4] ;
   int maxammo[4] ;
   int attackdown ;
   int usedown ;
   int cheats ;
   int refire ;
   int killcount ;
   int itemcount ;
   int secretcount ;
   char *message ;
   int damagecount ;
   int bonuscount ;
   mobj_t *attacker ;
   int extralight ;
   int fixedcolormap ;
   int colormap ;
   pspdef_t psprites[2] ;
   boolean didsecret ;
};
#line 83 "d_player.h"
typedef struct player_s player_t;
#line 173 "d_player.h"
struct __anonstruct_wbplayerstruct_t_79923248 {
   boolean in ;
   int skills ;
   int sitems ;
   int ssecret ;
   int stime ;
   int frags[4] ;
   int score ;
};
#line 173 "d_player.h"
typedef struct __anonstruct_wbplayerstruct_t_79923248 wbplayerstruct_t;
#line 187 "d_player.h"
struct __anonstruct_wbstartstruct_t_336147554 {
   int epsd ;
   boolean didsecret ;
   int last ;
   int next ;
   int maxkills ;
   int maxitems ;
   int maxsecret ;
   int maxfrags ;
   int partime ;
   int pnum ;
   wbplayerstruct_t plyr[4] ;
};
#line 187 "d_player.h"
typedef struct __anonstruct_wbstartstruct_t_336147554 wbstartstruct_t;
#line 51 "d_net.h"
enum __anonenum_command_t_801802759 {
    CMD_SENDCMD_SEND = 1,
    CMD_GETCMD_GET = 2
} ;
#line 51 "d_net.h"
typedef enum __anonenum_command_t_801802759 command_t;
#line 62 "d_net.h"
struct __anonstruct_doomdata_t_825341267 {
   unsigned int checksum ;
   byte retransmitfrom ;
   byte starttic ;
   byte player ;
   byte numtics ;
   ticcmd_t cmds[12] ;
};
#line 62 "d_net.h"
typedef struct __anonstruct_doomdata_t_825341267 doomdata_t;
#line 79 "d_net.h"
struct __anonstruct_doomcom_t_172015005 {
   long id ;
   short intnum ;
   short command ;
   short remotenode ;
   short datalength ;
   short numnodes ;
   short ticdup ;
   short extratics ;
   short deathmatch ;
   short savegame ;
   short episode ;
   short map ;
   short skill ;
   short consoleplayer ;
   short numplayers ;
   short angleoffset ;
   short drone ;
   doomdata_t data ;
};
#line 79 "d_net.h"
typedef struct __anonstruct_doomcom_t_172015005 doomcom_t;
#line 329 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
typedef long wchar_t;
#line 59 "/usr/include/stdlib.h"
struct __anonstruct_div_t_773697287 {
   int quot ;
   int rem ;
};
#line 59 "/usr/include/stdlib.h"
typedef struct __anonstruct_div_t_773697287 div_t;
#line 67 "/usr/include/stdlib.h"
struct __anonstruct_ldiv_t_790849867 {
   long quot ;
   long rem ;
};
#line 67 "/usr/include/stdlib.h"
typedef struct __anonstruct_ldiv_t_790849867 ldiv_t;
#line 77 "/usr/include/stdlib.h"
struct __anonstruct_lldiv_t_103911545 {
   long long quot ;
   long long rem ;
};
#line 77 "/usr/include/stdlib.h"
typedef struct __anonstruct_lldiv_t_103911545 lldiv_t;
#line 33 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 97 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/sys/types.h"
typedef __id_t id_t;
#line 114 "/usr/include/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 10 "/usr/include/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/sys/types.h"
typedef int register_t;
#line 5 "/usr/include/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_764561023 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_764561023 __sigset_t;
#line 7 "/usr/include/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 11 "/usr/include/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_356711149 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 59 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_356711149 fd_set;
#line 77 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 25 "/usr/include/bits/atomic_wide_counter.h"
struct __anonstruct___value32_817613185 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 25 "/usr/include/bits/atomic_wide_counter.h"
union __anonunion___atomic_wide_counter_995552565 {
   unsigned long long __value64 ;
   struct __anonstruct___value32_817613185 __value32 ;
};
#line 25 "/usr/include/bits/atomic_wide_counter.h"
typedef union __anonunion___atomic_wide_counter_995552565 __atomic_wide_counter;
#line 51 "/usr/include/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 51 "/usr/include/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 57 "/usr/include/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 57 "/usr/include/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/bits/struct_mutex.h"
struct __anonstruct___elision_data_964730938 {
   short __espins ;
   short __eelision ;
};
#line 22 "/usr/include/bits/struct_mutex.h"
union __anonunion____missing_field_name_948368484 {
   struct __anonstruct___elision_data_964730938 __elision_data ;
   __pthread_slist_t __list ;
};
#line 22 "/usr/include/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_948368484 __annonCompField1 ;
};
#line 23 "/usr/include/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   unsigned char __flags ;
   unsigned char __shared ;
   signed char __rwelision ;
   unsigned char __pad2 ;
   int __cur_writer ;
};
#line 94 "/usr/include/bits/thread-shared-types.h"
struct __pthread_cond_s {
   __atomic_wide_counter __wseq ;
   __atomic_wide_counter __g1_start ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 105 "/usr/include/bits/thread-shared-types.h"
typedef unsigned int __tss_t;
#line 106 "/usr/include/bits/thread-shared-types.h"
typedef unsigned long __thrd_t;
#line 108 "/usr/include/bits/thread-shared-types.h"
struct __anonstruct___once_flag_995552566 {
   int __data ;
};
#line 108 "/usr/include/bits/thread-shared-types.h"
typedef struct __anonstruct___once_flag_995552566 __once_flag;
#line 27 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
#line 32 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
#line 41 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
#line 41 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
#line 49 "/usr/include/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[36] ;
   long __align ;
};
#line 62 "/usr/include/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 67 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
#line 75 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
#line 86 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_656928968 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[32] ;
   long __align ;
};
#line 86 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_656928968 pthread_rwlock_t;
#line 93 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_rwlockattr_t_145707745 {
   char __size[8] ;
   long __align ;
};
#line 93 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlockattr_t_145707745 pthread_rwlockattr_t;
#line 103 "/usr/include/bits/pthreadtypes.h"
typedef int volatile   pthread_spinlock_t;
#line 108 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_barrier_t_145707746 {
   char __size[20] ;
   long __align ;
};
#line 108 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_barrier_t_145707746 pthread_barrier_t;
#line 114 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_barrierattr_t_951761806 {
   char __size[4] ;
   int __align ;
};
#line 114 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_barrierattr_t_951761806 pthread_barrierattr_t;
#line 543 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 610 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 948 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 52 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 114
enum __itimer_which {
    ITIMER_REALITIMER_REAL = 0,
    ITIMER_VIRTUALITIMER_VIRTUAL = 1,
    ITIMER_PROFITIMER_PROF = 2
} ;
#line 130 "/usr/include/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 143 "/usr/include/sys/time.h"
typedef int __itimer_which_t;
#line 255 "/usr/include/unistd.h"
typedef __useconds_t useconds_t;
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/bits/confname.h"
enum __anonenum_437032235 {
    _PC_LINK_MAX_PC_LINK_MAX = 0,
    _PC_MAX_CANON_PC_MAX_CANON = 1,
    _PC_MAX_INPUT_PC_MAX_INPUT = 2,
    _PC_NAME_MAX_PC_NAME_MAX = 3,
    _PC_PATH_MAX_PC_PATH_MAX = 4,
    _PC_PIPE_BUF_PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED_PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC_PC_NO_TRUNC = 7,
    _PC_VDISABLE_PC_VDISABLE = 8,
    _PC_SYNC_IO_PC_SYNC_IO = 9,
    _PC_ASYNC_IO_PC_ASYNC_IO = 10,
    _PC_PRIO_IO_PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF_PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS_PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE_PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE_PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE_PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN_PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN_PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX_PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS_PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum_315186338 {
    _SC_ARG_MAX_SC_ARG_MAX = 0,
    _SC_CHILD_MAX_SC_CHILD_MAX = 1,
    _SC_CLK_TCK_SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX_SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX_SC_OPEN_MAX = 4,
    _SC_STREAM_MAX_SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX_SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL_SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS_SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS_SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING_SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS_SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO_SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO_SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO_SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC_SC_FSYNC = 15,
    _SC_MAPPED_FILES_SC_MAPPED_FILES = 16,
    _SC_MEMLOCK_SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE_SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION_SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING_SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES_SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS_SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX_SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX_SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX_SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX_SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX_SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX_SC_MQ_PRIO_MAX = 28,
    _SC_VERSION_SC_VERSION = 29,
    _SC_PAGESIZE_SC_PAGESIZE = 30,
    _SC_RTSIG_MAX_SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX_SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX_SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX_SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX_SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX_SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX_SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX_SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX_SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX_SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX_SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX_SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX_SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX_SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX_SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION_SC_2_VERSION = 46,
    _SC_2_C_BIND_SC_2_C_BIND = 47,
    _SC_2_C_DEV_SC_2_C_DEV = 48,
    _SC_2_FORT_DEV_SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN_SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV_SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF_SC_2_LOCALEDEF = 52,
    _SC_PII_SC_PII = 53,
    _SC_PII_XTI_SC_PII_XTI = 54,
    _SC_PII_SOCKET_SC_PII_SOCKET = 55,
    _SC_PII_INTERNET_SC_PII_INTERNET = 56,
    _SC_PII_OSI_SC_PII_OSI = 57,
    _SC_POLL_SC_POLL = 58,
    _SC_SELECT_SC_SELECT = 59,
    _SC_UIO_MAXIOV_SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX_SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM_SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM_SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS_SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS_SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M_SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX_SC_T_IOV_MAX = 66,
    _SC_THREADS_SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS_SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX_SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX_SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX_SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX_SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS_SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX_SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN_SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX_SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR_SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE_SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING_SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT_SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT_SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED_SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF_SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN_SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES_SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES_SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX_SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX_SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION_SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION_SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX_SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT_SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N_SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM_SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM_SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION_SC_2_C_VERSION = 96,
    _SC_2_UPE_SC_2_UPE = 97,
    _SC_XOPEN_XPG2_SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3_SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4_SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT_SC_CHAR_BIT = 101,
    _SC_CHAR_MAX_SC_CHAR_MAX = 102,
    _SC_CHAR_MIN_SC_CHAR_MIN = 103,
    _SC_INT_MAX_SC_INT_MAX = 104,
    _SC_INT_MIN_SC_INT_MIN = 105,
    _SC_LONG_BIT_SC_LONG_BIT = 106,
    _SC_WORD_BIT_SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX_SC_MB_LEN_MAX = 108,
    _SC_NZERO_SC_NZERO = 109,
    _SC_SSIZE_MAX_SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX_SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN_SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX_SC_SHRT_MAX = 113,
    _SC_SHRT_MIN_SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX_SC_UCHAR_MAX = 115,
    _SC_UINT_MAX_SC_UINT_MAX = 116,
    _SC_ULONG_MAX_SC_ULONG_MAX = 117,
    _SC_USHRT_MAX_SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX_SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX_SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX_SC_NL_MSGMAX = 121,
    _SC_NL_NMAX_SC_NL_NMAX = 122,
    _SC_NL_SETMAX_SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX_SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32_SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG_SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64_SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG_SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY_SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME_SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS_SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO_SC_ADVISORY_INFO = 132,
    _SC_BARRIERS_SC_BARRIERS = 133,
    _SC_BASE_SC_BASE = 134,
    _SC_C_LANG_SUPPORT_SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R_SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION_SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME_SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME_SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO_SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC_SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R_SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT_SC_FD_MGMT = 143,
    _SC_FIFO_SC_FIFO = 144,
    _SC_PIPE_SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES_SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING_SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM_SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK_SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS_SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS_SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING_SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS_SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS_SC_SPIN_LOCKS = 154,
    _SC_REGEXP_SC_REGEXP = 155,
    _SC_REGEX_VERSION_SC_REGEX_VERSION = 156,
    _SC_SHELL_SC_SHELL = 157,
    _SC_SIGNALS_SC_SIGNALS = 158,
    _SC_SPAWN_SC_SPAWN = 159,
    _SC_SPORADIC_SERVER_SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER_SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE_SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R_SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS_SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS_SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS_SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R_SC_USER_GROUPS_R = 167,
    _SC_2_PBS_SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING_SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE_SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE_SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK_SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX_SC_SYMLOOP_MAX = 173,
    _SC_STREAMS_SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT_SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32_SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG_SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64_SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG_SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX_SC_HOST_NAME_MAX = 180,
    _SC_TRACE_SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER_SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT_SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG_SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE_SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC_SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE_SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE_SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC_SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE_SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE_SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC_SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE_SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE_SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC_SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE_SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE_SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC_SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE_SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6_SC_IPV6 = 235,
    _SC_RAW_SOCKETS_SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32_SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG_SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64_SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG_SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX_SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX_SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX_SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX_SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX_SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS_SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT_SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT_SC_THREAD_ROBUST_PRIO_PROTECT = 248,
    _SC_MINSIGSTKSZ_SC_MINSIGSTKSZ = 249,
    _SC_SIGSTKSZ_SC_SIGSTKSZ = 250
} ;
#line 539
enum __anonenum_875524036 {
    _CS_PATH_CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS_CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION_CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION_CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS_CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS_CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS_CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS_CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS_CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS_CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS_CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS_CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS_CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS_CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS_CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS_CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS_CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS_CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS_CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS_CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS_CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS_CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS_CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS_CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS_CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS_CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS_CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS_CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS_CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS_CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS_CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS_CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS_CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS_CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS_CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS_CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS_CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS_CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS_CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS_CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS_CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS_CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS_CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS_CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS_CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS_CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS_CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV_CS_V6_ENV = 1148,
    _CS_V7_ENV_CS_V7_ENV = 1149
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___1 {
    VERSION___1VERSION___1 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___0 {
    ML_LABEL___0ML_LABEL___0 = 0,
    ML_THINGS___0ML_THINGS___0 = 1,
    ML_LINEDEFS___0ML_LINEDEFS___0 = 2,
    ML_SIDEDEFS___0ML_SIDEDEFS___0 = 3,
    ML_VERTEXES___0ML_VERTEXES___0 = 4,
    ML_SEGS___0ML_SEGS___0 = 5,
    ML_SSECTORS___0ML_SSECTORS___0 = 6,
    ML_NODES___0ML_NODES___0 = 7,
    ML_SECTORS___0ML_SECTORS___0 = 8,
    ML_REJECT___0ML_REJECT___0 = 9,
    ML_BLOCKMAP___0ML_BLOCKMAP___0 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___0 {
    FP_NAN___0FP_NAN___0 = 0,
    FP_INFINITE___0FP_INFINITE___0 = 1,
    FP_ZERO___0FP_ZERO___0 = 2,
    FP_SUBNORMAL___0FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0FP_NORMAL___0 = 4
} ;
#line 30 "sounds.h"
struct sfxinfo_struct ;
#line 30 "sounds.h"
typedef struct sfxinfo_struct sfxinfo_t;
#line 32 "sounds.h"
struct sfxinfo_struct {
   char *name ;
   int singularity ;
   int priority ;
   sfxinfo_t *link ;
   int pitch ;
   int volume ;
   void *data ;
   int usefulness ;
   int lumpnum ;
};
#line 70 "sounds.h"
struct __anonstruct_musicinfo_t_241015926 {
   char *name ;
   int lumpnum ;
   void *data ;
   int handle ;
};
#line 70 "sounds.h"
typedef struct __anonstruct_musicinfo_t_241015926 musicinfo_t;
#line 99
enum __anonenum_musicenum_t_963236332 {
    mus_Nonemus_None = 0,
    mus_e1m1mus_e1m1 = 1,
    mus_e1m2mus_e1m2 = 2,
    mus_e1m3mus_e1m3 = 3,
    mus_e1m4mus_e1m4 = 4,
    mus_e1m5mus_e1m5 = 5,
    mus_e1m6mus_e1m6 = 6,
    mus_e1m7mus_e1m7 = 7,
    mus_e1m8mus_e1m8 = 8,
    mus_e1m9mus_e1m9 = 9,
    mus_e2m1mus_e2m1 = 10,
    mus_e2m2mus_e2m2 = 11,
    mus_e2m3mus_e2m3 = 12,
    mus_e2m4mus_e2m4 = 13,
    mus_e2m5mus_e2m5 = 14,
    mus_e2m6mus_e2m6 = 15,
    mus_e2m7mus_e2m7 = 16,
    mus_e2m8mus_e2m8 = 17,
    mus_e2m9mus_e2m9 = 18,
    mus_e3m1mus_e3m1 = 19,
    mus_e3m2mus_e3m2 = 20,
    mus_e3m3mus_e3m3 = 21,
    mus_e3m4mus_e3m4 = 22,
    mus_e3m5mus_e3m5 = 23,
    mus_e3m6mus_e3m6 = 24,
    mus_e3m7mus_e3m7 = 25,
    mus_e3m8mus_e3m8 = 26,
    mus_e3m9mus_e3m9 = 27,
    mus_intermus_inter = 28,
    mus_intromus_intro = 29,
    mus_bunnymus_bunny = 30,
    mus_victormus_victor = 31,
    mus_introamus_introa = 32,
    mus_runninmus_runnin = 33,
    mus_stalksmus_stalks = 34,
    mus_countdmus_countd = 35,
    mus_betweemus_betwee = 36,
    mus_doommus_doom = 37,
    mus_the_damus_the_da = 38,
    mus_shawnmus_shawn = 39,
    mus_ddtblumus_ddtblu = 40,
    mus_in_citmus_in_cit = 41,
    mus_deadmus_dead = 42,
    mus_stlks2mus_stlks2 = 43,
    mus_theda2mus_theda2 = 44,
    mus_doom2mus_doom2 = 45,
    mus_ddtbl2mus_ddtbl2 = 46,
    mus_runni2mus_runni2 = 47,
    mus_dead2mus_dead2 = 48,
    mus_stlks3mus_stlks3 = 49,
    mus_romeromus_romero = 50,
    mus_shawn2mus_shawn2 = 51,
    mus_messagmus_messag = 52,
    mus_count2mus_count2 = 53,
    mus_ddtbl3mus_ddtbl3 = 54,
    mus_ampiemus_ampie = 55,
    mus_theda3mus_theda3 = 56,
    mus_adrianmus_adrian = 57,
    mus_messg2mus_messg2 = 58,
    mus_romer2mus_romer2 = 59,
    mus_tensemus_tense = 60,
    mus_shawn3mus_shawn3 = 61,
    mus_openinmus_openin = 62,
    mus_evilmus_evil = 63,
    mus_ultimamus_ultima = 64,
    mus_read_mmus_read_m = 65,
    mus_dm2ttlmus_dm2ttl = 66,
    mus_dm2intmus_dm2int = 67,
    NUMMUSICNUMMUSIC = 68
} ;
#line 99 "sounds.h"
typedef enum __anonenum_musicenum_t_963236332 musicenum_t;
#line 177
enum __anonenum_sfxenum_t_782196989 {
    sfx_Nonesfx_None = 0,
    sfx_pistolsfx_pistol = 1,
    sfx_shotgnsfx_shotgn = 2,
    sfx_sgcocksfx_sgcock = 3,
    sfx_dshtgnsfx_dshtgn = 4,
    sfx_dbopnsfx_dbopn = 5,
    sfx_dbclssfx_dbcls = 6,
    sfx_dbloadsfx_dbload = 7,
    sfx_plasmasfx_plasma = 8,
    sfx_bfgsfx_bfg = 9,
    sfx_sawupsfx_sawup = 10,
    sfx_sawidlsfx_sawidl = 11,
    sfx_sawfulsfx_sawful = 12,
    sfx_sawhitsfx_sawhit = 13,
    sfx_rlauncsfx_rlaunc = 14,
    sfx_rxplodsfx_rxplod = 15,
    sfx_firshtsfx_firsht = 16,
    sfx_firxplsfx_firxpl = 17,
    sfx_pstartsfx_pstart = 18,
    sfx_pstopsfx_pstop = 19,
    sfx_doropnsfx_doropn = 20,
    sfx_dorclssfx_dorcls = 21,
    sfx_stnmovsfx_stnmov = 22,
    sfx_swtchnsfx_swtchn = 23,
    sfx_swtchxsfx_swtchx = 24,
    sfx_plpainsfx_plpain = 25,
    sfx_dmpainsfx_dmpain = 26,
    sfx_popainsfx_popain = 27,
    sfx_vipainsfx_vipain = 28,
    sfx_mnpainsfx_mnpain = 29,
    sfx_pepainsfx_pepain = 30,
    sfx_slopsfx_slop = 31,
    sfx_itemupsfx_itemup = 32,
    sfx_wpnupsfx_wpnup = 33,
    sfx_oofsfx_oof = 34,
    sfx_teleptsfx_telept = 35,
    sfx_posit1sfx_posit1 = 36,
    sfx_posit2sfx_posit2 = 37,
    sfx_posit3sfx_posit3 = 38,
    sfx_bgsit1sfx_bgsit1 = 39,
    sfx_bgsit2sfx_bgsit2 = 40,
    sfx_sgtsitsfx_sgtsit = 41,
    sfx_cacsitsfx_cacsit = 42,
    sfx_brssitsfx_brssit = 43,
    sfx_cybsitsfx_cybsit = 44,
    sfx_spisitsfx_spisit = 45,
    sfx_bspsitsfx_bspsit = 46,
    sfx_kntsitsfx_kntsit = 47,
    sfx_vilsitsfx_vilsit = 48,
    sfx_mansitsfx_mansit = 49,
    sfx_pesitsfx_pesit = 50,
    sfx_sklatksfx_sklatk = 51,
    sfx_sgtatksfx_sgtatk = 52,
    sfx_skepchsfx_skepch = 53,
    sfx_vilatksfx_vilatk = 54,
    sfx_clawsfx_claw = 55,
    sfx_skeswgsfx_skeswg = 56,
    sfx_pldethsfx_pldeth = 57,
    sfx_pdiehisfx_pdiehi = 58,
    sfx_podth1sfx_podth1 = 59,
    sfx_podth2sfx_podth2 = 60,
    sfx_podth3sfx_podth3 = 61,
    sfx_bgdth1sfx_bgdth1 = 62,
    sfx_bgdth2sfx_bgdth2 = 63,
    sfx_sgtdthsfx_sgtdth = 64,
    sfx_cacdthsfx_cacdth = 65,
    sfx_skldthsfx_skldth = 66,
    sfx_brsdthsfx_brsdth = 67,
    sfx_cybdthsfx_cybdth = 68,
    sfx_spidthsfx_spidth = 69,
    sfx_bspdthsfx_bspdth = 70,
    sfx_vildthsfx_vildth = 71,
    sfx_kntdthsfx_kntdth = 72,
    sfx_pedthsfx_pedth = 73,
    sfx_skedthsfx_skedth = 74,
    sfx_posactsfx_posact = 75,
    sfx_bgactsfx_bgact = 76,
    sfx_dmactsfx_dmact = 77,
    sfx_bspactsfx_bspact = 78,
    sfx_bspwlksfx_bspwlk = 79,
    sfx_vilactsfx_vilact = 80,
    sfx_nowaysfx_noway = 81,
    sfx_barexpsfx_barexp = 82,
    sfx_punchsfx_punch = 83,
    sfx_hoofsfx_hoof = 84,
    sfx_metalsfx_metal = 85,
    sfx_chgunsfx_chgun = 86,
    sfx_tinksfx_tink = 87,
    sfx_bdopnsfx_bdopn = 88,
    sfx_bdclssfx_bdcls = 89,
    sfx_itmbksfx_itmbk = 90,
    sfx_flamesfx_flame = 91,
    sfx_flamstsfx_flamst = 92,
    sfx_getpowsfx_getpow = 93,
    sfx_bospitsfx_bospit = 94,
    sfx_boscubsfx_boscub = 95,
    sfx_bossitsfx_bossit = 96,
    sfx_bospnsfx_bospn = 97,
    sfx_bosdthsfx_bosdth = 98,
    sfx_manatksfx_manatk = 99,
    sfx_mandthsfx_mandth = 100,
    sfx_sssitsfx_sssit = 101,
    sfx_ssdthsfx_ssdth = 102,
    sfx_keenpnsfx_keenpn = 103,
    sfx_keendtsfx_keendt = 104,
    sfx_skeactsfx_skeact = 105,
    sfx_skesitsfx_skesit = 106,
    sfx_skeatksfx_skeatk = 107,
    sfx_radiosfx_radio = 108,
    NUMSFXNUMSFX = 109
} ;
#line 177 "sounds.h"
typedef enum __anonenum_sfxenum_t_782196989 sfxenum_t;
#line 35 "d_event.h"
enum __anonenum_evtype_t_537084405 {
    ev_keydownev_keydown = 0,
    ev_keyupev_keyup = 1,
    ev_mouseev_mouse = 2,
    ev_joystickev_joystick = 3
} ;
#line 35 "d_event.h"
typedef enum __anonenum_evtype_t_537084405 evtype_t;
#line 44 "d_event.h"
struct __anonstruct_event_t_676308523 {
   evtype_t type ;
   int data1 ;
   int data2 ;
   int data3 ;
};
#line 44 "d_event.h"
typedef struct __anonstruct_event_t_676308523 event_t;
#line 53
enum __anonenum_gameaction_t_122700457 {
    ga_nothingga_nothing = 0,
    ga_loadlevelga_loadlevel = 1,
    ga_newgamega_newgame = 2,
    ga_loadgamega_loadgame = 3,
    ga_savegamega_savegame = 4,
    ga_playdemoga_playdemo = 5,
    ga_completedga_completed = 6,
    ga_victoryga_victory = 7,
    ga_worlddonega_worlddone = 8,
    ga_screenshotga_screenshot = 9
} ;
#line 53 "d_event.h"
typedef enum __anonenum_gameaction_t_122700457 gameaction_t;
#line 72
enum __anonenum_buttoncode_t_259846657 {
    BT_ATTACKBT_ATTACK = 1,
    BT_USEBT_USE = 2,
    BT_SPECIALBT_SPECIAL = 128,
    BT_SPECIALMASKBT_SPECIALMASK = 3,
    BT_CHANGEBT_CHANGE = 4,
    BT_WEAPONMASKBT_WEAPONMASK = 56,
    BT_WEAPONSHIFTBT_WEAPONSHIFT = 3,
    BTS_PAUSEBTS_PAUSE = 1,
    BTS_SAVEGAMEBTS_SAVEGAME = 2,
    BTS_SAVEMASKBTS_SAVEMASK = 28,
    BTS_SAVESHIFTBTS_SAVESHIFT = 2
} ;
#line 72 "d_event.h"
typedef enum __anonenum_buttoncode_t_259846657 buttoncode_t;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___1 {
    FP_NAN___1FP_NAN___1 = 0,
    FP_INFINITE___1FP_INFINITE___1 = 1,
    FP_ZERO___1FP_ZERO___1 = 2,
    FP_SUBNORMAL___1FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1FP_NORMAL___1 = 4
} ;
#line 35 "/usr/include/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 26 "/usr/include/bits/struct_stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __glibc_reserved4 ;
   unsigned long __glibc_reserved5 ;
};
#line 24 "/usr/include/bits/confname.h"
enum __anonenum_437032235___0 {
    _PC_LINK_MAX___0_PC_LINK_MAX___0 = 0,
    _PC_MAX_CANON___0_PC_MAX_CANON___0 = 1,
    _PC_MAX_INPUT___0_PC_MAX_INPUT___0 = 2,
    _PC_NAME_MAX___0_PC_NAME_MAX___0 = 3,
    _PC_PATH_MAX___0_PC_PATH_MAX___0 = 4,
    _PC_PIPE_BUF___0_PC_PIPE_BUF___0 = 5,
    _PC_CHOWN_RESTRICTED___0_PC_CHOWN_RESTRICTED___0 = 6,
    _PC_NO_TRUNC___0_PC_NO_TRUNC___0 = 7,
    _PC_VDISABLE___0_PC_VDISABLE___0 = 8,
    _PC_SYNC_IO___0_PC_SYNC_IO___0 = 9,
    _PC_ASYNC_IO___0_PC_ASYNC_IO___0 = 10,
    _PC_PRIO_IO___0_PC_PRIO_IO___0 = 11,
    _PC_SOCK_MAXBUF___0_PC_SOCK_MAXBUF___0 = 12,
    _PC_FILESIZEBITS___0_PC_FILESIZEBITS___0 = 13,
    _PC_REC_INCR_XFER_SIZE___0_PC_REC_INCR_XFER_SIZE___0 = 14,
    _PC_REC_MAX_XFER_SIZE___0_PC_REC_MAX_XFER_SIZE___0 = 15,
    _PC_REC_MIN_XFER_SIZE___0_PC_REC_MIN_XFER_SIZE___0 = 16,
    _PC_REC_XFER_ALIGN___0_PC_REC_XFER_ALIGN___0 = 17,
    _PC_ALLOC_SIZE_MIN___0_PC_ALLOC_SIZE_MIN___0 = 18,
    _PC_SYMLINK_MAX___0_PC_SYMLINK_MAX___0 = 19,
    _PC_2_SYMLINKS___0_PC_2_SYMLINKS___0 = 20
} ;
#line 71
enum __anonenum_315186338___0 {
    _SC_ARG_MAX___0_SC_ARG_MAX___0 = 0,
    _SC_CHILD_MAX___0_SC_CHILD_MAX___0 = 1,
    _SC_CLK_TCK___0_SC_CLK_TCK___0 = 2,
    _SC_NGROUPS_MAX___0_SC_NGROUPS_MAX___0 = 3,
    _SC_OPEN_MAX___0_SC_OPEN_MAX___0 = 4,
    _SC_STREAM_MAX___0_SC_STREAM_MAX___0 = 5,
    _SC_TZNAME_MAX___0_SC_TZNAME_MAX___0 = 6,
    _SC_JOB_CONTROL___0_SC_JOB_CONTROL___0 = 7,
    _SC_SAVED_IDS___0_SC_SAVED_IDS___0 = 8,
    _SC_REALTIME_SIGNALS___0_SC_REALTIME_SIGNALS___0 = 9,
    _SC_PRIORITY_SCHEDULING___0_SC_PRIORITY_SCHEDULING___0 = 10,
    _SC_TIMERS___0_SC_TIMERS___0 = 11,
    _SC_ASYNCHRONOUS_IO___0_SC_ASYNCHRONOUS_IO___0 = 12,
    _SC_PRIORITIZED_IO___0_SC_PRIORITIZED_IO___0 = 13,
    _SC_SYNCHRONIZED_IO___0_SC_SYNCHRONIZED_IO___0 = 14,
    _SC_FSYNC___0_SC_FSYNC___0 = 15,
    _SC_MAPPED_FILES___0_SC_MAPPED_FILES___0 = 16,
    _SC_MEMLOCK___0_SC_MEMLOCK___0 = 17,
    _SC_MEMLOCK_RANGE___0_SC_MEMLOCK_RANGE___0 = 18,
    _SC_MEMORY_PROTECTION___0_SC_MEMORY_PROTECTION___0 = 19,
    _SC_MESSAGE_PASSING___0_SC_MESSAGE_PASSING___0 = 20,
    _SC_SEMAPHORES___0_SC_SEMAPHORES___0 = 21,
    _SC_SHARED_MEMORY_OBJECTS___0_SC_SHARED_MEMORY_OBJECTS___0 = 22,
    _SC_AIO_LISTIO_MAX___0_SC_AIO_LISTIO_MAX___0 = 23,
    _SC_AIO_MAX___0_SC_AIO_MAX___0 = 24,
    _SC_AIO_PRIO_DELTA_MAX___0_SC_AIO_PRIO_DELTA_MAX___0 = 25,
    _SC_DELAYTIMER_MAX___0_SC_DELAYTIMER_MAX___0 = 26,
    _SC_MQ_OPEN_MAX___0_SC_MQ_OPEN_MAX___0 = 27,
    _SC_MQ_PRIO_MAX___0_SC_MQ_PRIO_MAX___0 = 28,
    _SC_VERSION___0_SC_VERSION___0 = 29,
    _SC_PAGESIZE___0_SC_PAGESIZE___0 = 30,
    _SC_RTSIG_MAX___0_SC_RTSIG_MAX___0 = 31,
    _SC_SEM_NSEMS_MAX___0_SC_SEM_NSEMS_MAX___0 = 32,
    _SC_SEM_VALUE_MAX___0_SC_SEM_VALUE_MAX___0 = 33,
    _SC_SIGQUEUE_MAX___0_SC_SIGQUEUE_MAX___0 = 34,
    _SC_TIMER_MAX___0_SC_TIMER_MAX___0 = 35,
    _SC_BC_BASE_MAX___0_SC_BC_BASE_MAX___0 = 36,
    _SC_BC_DIM_MAX___0_SC_BC_DIM_MAX___0 = 37,
    _SC_BC_SCALE_MAX___0_SC_BC_SCALE_MAX___0 = 38,
    _SC_BC_STRING_MAX___0_SC_BC_STRING_MAX___0 = 39,
    _SC_COLL_WEIGHTS_MAX___0_SC_COLL_WEIGHTS_MAX___0 = 40,
    _SC_EQUIV_CLASS_MAX___0_SC_EQUIV_CLASS_MAX___0 = 41,
    _SC_EXPR_NEST_MAX___0_SC_EXPR_NEST_MAX___0 = 42,
    _SC_LINE_MAX___0_SC_LINE_MAX___0 = 43,
    _SC_RE_DUP_MAX___0_SC_RE_DUP_MAX___0 = 44,
    _SC_CHARCLASS_NAME_MAX___0_SC_CHARCLASS_NAME_MAX___0 = 45,
    _SC_2_VERSION___0_SC_2_VERSION___0 = 46,
    _SC_2_C_BIND___0_SC_2_C_BIND___0 = 47,
    _SC_2_C_DEV___0_SC_2_C_DEV___0 = 48,
    _SC_2_FORT_DEV___0_SC_2_FORT_DEV___0 = 49,
    _SC_2_FORT_RUN___0_SC_2_FORT_RUN___0 = 50,
    _SC_2_SW_DEV___0_SC_2_SW_DEV___0 = 51,
    _SC_2_LOCALEDEF___0_SC_2_LOCALEDEF___0 = 52,
    _SC_PII___0_SC_PII___0 = 53,
    _SC_PII_XTI___0_SC_PII_XTI___0 = 54,
    _SC_PII_SOCKET___0_SC_PII_SOCKET___0 = 55,
    _SC_PII_INTERNET___0_SC_PII_INTERNET___0 = 56,
    _SC_PII_OSI___0_SC_PII_OSI___0 = 57,
    _SC_POLL___0_SC_POLL___0 = 58,
    _SC_SELECT___0_SC_SELECT___0 = 59,
    _SC_UIO_MAXIOV___0_SC_UIO_MAXIOV___0 = 60,
    _SC_IOV_MAX___0_SC_IOV_MAX___0 = 60,
    _SC_PII_INTERNET_STREAM___0_SC_PII_INTERNET_STREAM___0 = 61,
    _SC_PII_INTERNET_DGRAM___0_SC_PII_INTERNET_DGRAM___0 = 62,
    _SC_PII_OSI_COTS___0_SC_PII_OSI_COTS___0 = 63,
    _SC_PII_OSI_CLTS___0_SC_PII_OSI_CLTS___0 = 64,
    _SC_PII_OSI_M___0_SC_PII_OSI_M___0 = 65,
    _SC_T_IOV_MAX___0_SC_T_IOV_MAX___0 = 66,
    _SC_THREADS___0_SC_THREADS___0 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___0_SC_THREAD_SAFE_FUNCTIONS___0 = 68,
    _SC_GETGR_R_SIZE_MAX___0_SC_GETGR_R_SIZE_MAX___0 = 69,
    _SC_GETPW_R_SIZE_MAX___0_SC_GETPW_R_SIZE_MAX___0 = 70,
    _SC_LOGIN_NAME_MAX___0_SC_LOGIN_NAME_MAX___0 = 71,
    _SC_TTY_NAME_MAX___0_SC_TTY_NAME_MAX___0 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___0_SC_THREAD_DESTRUCTOR_ITERATIONS___0 = 73,
    _SC_THREAD_KEYS_MAX___0_SC_THREAD_KEYS_MAX___0 = 74,
    _SC_THREAD_STACK_MIN___0_SC_THREAD_STACK_MIN___0 = 75,
    _SC_THREAD_THREADS_MAX___0_SC_THREAD_THREADS_MAX___0 = 76,
    _SC_THREAD_ATTR_STACKADDR___0_SC_THREAD_ATTR_STACKADDR___0 = 77,
    _SC_THREAD_ATTR_STACKSIZE___0_SC_THREAD_ATTR_STACKSIZE___0 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___0_SC_THREAD_PRIORITY_SCHEDULING___0 = 79,
    _SC_THREAD_PRIO_INHERIT___0_SC_THREAD_PRIO_INHERIT___0 = 80,
    _SC_THREAD_PRIO_PROTECT___0_SC_THREAD_PRIO_PROTECT___0 = 81,
    _SC_THREAD_PROCESS_SHARED___0_SC_THREAD_PROCESS_SHARED___0 = 82,
    _SC_NPROCESSORS_CONF___0_SC_NPROCESSORS_CONF___0 = 83,
    _SC_NPROCESSORS_ONLN___0_SC_NPROCESSORS_ONLN___0 = 84,
    _SC_PHYS_PAGES___0_SC_PHYS_PAGES___0 = 85,
    _SC_AVPHYS_PAGES___0_SC_AVPHYS_PAGES___0 = 86,
    _SC_ATEXIT_MAX___0_SC_ATEXIT_MAX___0 = 87,
    _SC_PASS_MAX___0_SC_PASS_MAX___0 = 88,
    _SC_XOPEN_VERSION___0_SC_XOPEN_VERSION___0 = 89,
    _SC_XOPEN_XCU_VERSION___0_SC_XOPEN_XCU_VERSION___0 = 90,
    _SC_XOPEN_UNIX___0_SC_XOPEN_UNIX___0 = 91,
    _SC_XOPEN_CRYPT___0_SC_XOPEN_CRYPT___0 = 92,
    _SC_XOPEN_ENH_I18N___0_SC_XOPEN_ENH_I18N___0 = 93,
    _SC_XOPEN_SHM___0_SC_XOPEN_SHM___0 = 94,
    _SC_2_CHAR_TERM___0_SC_2_CHAR_TERM___0 = 95,
    _SC_2_C_VERSION___0_SC_2_C_VERSION___0 = 96,
    _SC_2_UPE___0_SC_2_UPE___0 = 97,
    _SC_XOPEN_XPG2___0_SC_XOPEN_XPG2___0 = 98,
    _SC_XOPEN_XPG3___0_SC_XOPEN_XPG3___0 = 99,
    _SC_XOPEN_XPG4___0_SC_XOPEN_XPG4___0 = 100,
    _SC_CHAR_BIT___0_SC_CHAR_BIT___0 = 101,
    _SC_CHAR_MAX___0_SC_CHAR_MAX___0 = 102,
    _SC_CHAR_MIN___0_SC_CHAR_MIN___0 = 103,
    _SC_INT_MAX___0_SC_INT_MAX___0 = 104,
    _SC_INT_MIN___0_SC_INT_MIN___0 = 105,
    _SC_LONG_BIT___0_SC_LONG_BIT___0 = 106,
    _SC_WORD_BIT___0_SC_WORD_BIT___0 = 107,
    _SC_MB_LEN_MAX___0_SC_MB_LEN_MAX___0 = 108,
    _SC_NZERO___0_SC_NZERO___0 = 109,
    _SC_SSIZE_MAX___0_SC_SSIZE_MAX___0 = 110,
    _SC_SCHAR_MAX___0_SC_SCHAR_MAX___0 = 111,
    _SC_SCHAR_MIN___0_SC_SCHAR_MIN___0 = 112,
    _SC_SHRT_MAX___0_SC_SHRT_MAX___0 = 113,
    _SC_SHRT_MIN___0_SC_SHRT_MIN___0 = 114,
    _SC_UCHAR_MAX___0_SC_UCHAR_MAX___0 = 115,
    _SC_UINT_MAX___0_SC_UINT_MAX___0 = 116,
    _SC_ULONG_MAX___0_SC_ULONG_MAX___0 = 117,
    _SC_USHRT_MAX___0_SC_USHRT_MAX___0 = 118,
    _SC_NL_ARGMAX___0_SC_NL_ARGMAX___0 = 119,
    _SC_NL_LANGMAX___0_SC_NL_LANGMAX___0 = 120,
    _SC_NL_MSGMAX___0_SC_NL_MSGMAX___0 = 121,
    _SC_NL_NMAX___0_SC_NL_NMAX___0 = 122,
    _SC_NL_SETMAX___0_SC_NL_SETMAX___0 = 123,
    _SC_NL_TEXTMAX___0_SC_NL_TEXTMAX___0 = 124,
    _SC_XBS5_ILP32_OFF32___0_SC_XBS5_ILP32_OFF32___0 = 125,
    _SC_XBS5_ILP32_OFFBIG___0_SC_XBS5_ILP32_OFFBIG___0 = 126,
    _SC_XBS5_LP64_OFF64___0_SC_XBS5_LP64_OFF64___0 = 127,
    _SC_XBS5_LPBIG_OFFBIG___0_SC_XBS5_LPBIG_OFFBIG___0 = 128,
    _SC_XOPEN_LEGACY___0_SC_XOPEN_LEGACY___0 = 129,
    _SC_XOPEN_REALTIME___0_SC_XOPEN_REALTIME___0 = 130,
    _SC_XOPEN_REALTIME_THREADS___0_SC_XOPEN_REALTIME_THREADS___0 = 131,
    _SC_ADVISORY_INFO___0_SC_ADVISORY_INFO___0 = 132,
    _SC_BARRIERS___0_SC_BARRIERS___0 = 133,
    _SC_BASE___0_SC_BASE___0 = 134,
    _SC_C_LANG_SUPPORT___0_SC_C_LANG_SUPPORT___0 = 135,
    _SC_C_LANG_SUPPORT_R___0_SC_C_LANG_SUPPORT_R___0 = 136,
    _SC_CLOCK_SELECTION___0_SC_CLOCK_SELECTION___0 = 137,
    _SC_CPUTIME___0_SC_CPUTIME___0 = 138,
    _SC_THREAD_CPUTIME___0_SC_THREAD_CPUTIME___0 = 139,
    _SC_DEVICE_IO___0_SC_DEVICE_IO___0 = 140,
    _SC_DEVICE_SPECIFIC___0_SC_DEVICE_SPECIFIC___0 = 141,
    _SC_DEVICE_SPECIFIC_R___0_SC_DEVICE_SPECIFIC_R___0 = 142,
    _SC_FD_MGMT___0_SC_FD_MGMT___0 = 143,
    _SC_FIFO___0_SC_FIFO___0 = 144,
    _SC_PIPE___0_SC_PIPE___0 = 145,
    _SC_FILE_ATTRIBUTES___0_SC_FILE_ATTRIBUTES___0 = 146,
    _SC_FILE_LOCKING___0_SC_FILE_LOCKING___0 = 147,
    _SC_FILE_SYSTEM___0_SC_FILE_SYSTEM___0 = 148,
    _SC_MONOTONIC_CLOCK___0_SC_MONOTONIC_CLOCK___0 = 149,
    _SC_MULTI_PROCESS___0_SC_MULTI_PROCESS___0 = 150,
    _SC_SINGLE_PROCESS___0_SC_SINGLE_PROCESS___0 = 151,
    _SC_NETWORKING___0_SC_NETWORKING___0 = 152,
    _SC_READER_WRITER_LOCKS___0_SC_READER_WRITER_LOCKS___0 = 153,
    _SC_SPIN_LOCKS___0_SC_SPIN_LOCKS___0 = 154,
    _SC_REGEXP___0_SC_REGEXP___0 = 155,
    _SC_REGEX_VERSION___0_SC_REGEX_VERSION___0 = 156,
    _SC_SHELL___0_SC_SHELL___0 = 157,
    _SC_SIGNALS___0_SC_SIGNALS___0 = 158,
    _SC_SPAWN___0_SC_SPAWN___0 = 159,
    _SC_SPORADIC_SERVER___0_SC_SPORADIC_SERVER___0 = 160,
    _SC_THREAD_SPORADIC_SERVER___0_SC_THREAD_SPORADIC_SERVER___0 = 161,
    _SC_SYSTEM_DATABASE___0_SC_SYSTEM_DATABASE___0 = 162,
    _SC_SYSTEM_DATABASE_R___0_SC_SYSTEM_DATABASE_R___0 = 163,
    _SC_TIMEOUTS___0_SC_TIMEOUTS___0 = 164,
    _SC_TYPED_MEMORY_OBJECTS___0_SC_TYPED_MEMORY_OBJECTS___0 = 165,
    _SC_USER_GROUPS___0_SC_USER_GROUPS___0 = 166,
    _SC_USER_GROUPS_R___0_SC_USER_GROUPS_R___0 = 167,
    _SC_2_PBS___0_SC_2_PBS___0 = 168,
    _SC_2_PBS_ACCOUNTING___0_SC_2_PBS_ACCOUNTING___0 = 169,
    _SC_2_PBS_LOCATE___0_SC_2_PBS_LOCATE___0 = 170,
    _SC_2_PBS_MESSAGE___0_SC_2_PBS_MESSAGE___0 = 171,
    _SC_2_PBS_TRACK___0_SC_2_PBS_TRACK___0 = 172,
    _SC_SYMLOOP_MAX___0_SC_SYMLOOP_MAX___0 = 173,
    _SC_STREAMS___0_SC_STREAMS___0 = 174,
    _SC_2_PBS_CHECKPOINT___0_SC_2_PBS_CHECKPOINT___0 = 175,
    _SC_V6_ILP32_OFF32___0_SC_V6_ILP32_OFF32___0 = 176,
    _SC_V6_ILP32_OFFBIG___0_SC_V6_ILP32_OFFBIG___0 = 177,
    _SC_V6_LP64_OFF64___0_SC_V6_LP64_OFF64___0 = 178,
    _SC_V6_LPBIG_OFFBIG___0_SC_V6_LPBIG_OFFBIG___0 = 179,
    _SC_HOST_NAME_MAX___0_SC_HOST_NAME_MAX___0 = 180,
    _SC_TRACE___0_SC_TRACE___0 = 181,
    _SC_TRACE_EVENT_FILTER___0_SC_TRACE_EVENT_FILTER___0 = 182,
    _SC_TRACE_INHERIT___0_SC_TRACE_INHERIT___0 = 183,
    _SC_TRACE_LOG___0_SC_TRACE_LOG___0 = 184,
    _SC_LEVEL1_ICACHE_SIZE___0_SC_LEVEL1_ICACHE_SIZE___0 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___0_SC_LEVEL1_ICACHE_ASSOC___0 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___0_SC_LEVEL1_ICACHE_LINESIZE___0 = 187,
    _SC_LEVEL1_DCACHE_SIZE___0_SC_LEVEL1_DCACHE_SIZE___0 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___0_SC_LEVEL1_DCACHE_ASSOC___0 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___0_SC_LEVEL1_DCACHE_LINESIZE___0 = 190,
    _SC_LEVEL2_CACHE_SIZE___0_SC_LEVEL2_CACHE_SIZE___0 = 191,
    _SC_LEVEL2_CACHE_ASSOC___0_SC_LEVEL2_CACHE_ASSOC___0 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___0_SC_LEVEL2_CACHE_LINESIZE___0 = 193,
    _SC_LEVEL3_CACHE_SIZE___0_SC_LEVEL3_CACHE_SIZE___0 = 194,
    _SC_LEVEL3_CACHE_ASSOC___0_SC_LEVEL3_CACHE_ASSOC___0 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___0_SC_LEVEL3_CACHE_LINESIZE___0 = 196,
    _SC_LEVEL4_CACHE_SIZE___0_SC_LEVEL4_CACHE_SIZE___0 = 197,
    _SC_LEVEL4_CACHE_ASSOC___0_SC_LEVEL4_CACHE_ASSOC___0 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___0_SC_LEVEL4_CACHE_LINESIZE___0 = 199,
    _SC_IPV6___0_SC_IPV6___0 = 235,
    _SC_RAW_SOCKETS___0_SC_RAW_SOCKETS___0 = 236,
    _SC_V7_ILP32_OFF32___0_SC_V7_ILP32_OFF32___0 = 237,
    _SC_V7_ILP32_OFFBIG___0_SC_V7_ILP32_OFFBIG___0 = 238,
    _SC_V7_LP64_OFF64___0_SC_V7_LP64_OFF64___0 = 239,
    _SC_V7_LPBIG_OFFBIG___0_SC_V7_LPBIG_OFFBIG___0 = 240,
    _SC_SS_REPL_MAX___0_SC_SS_REPL_MAX___0 = 241,
    _SC_TRACE_EVENT_NAME_MAX___0_SC_TRACE_EVENT_NAME_MAX___0 = 242,
    _SC_TRACE_NAME_MAX___0_SC_TRACE_NAME_MAX___0 = 243,
    _SC_TRACE_SYS_MAX___0_SC_TRACE_SYS_MAX___0 = 244,
    _SC_TRACE_USER_EVENT_MAX___0_SC_TRACE_USER_EVENT_MAX___0 = 245,
    _SC_XOPEN_STREAMS___0_SC_XOPEN_STREAMS___0 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___0_SC_THREAD_ROBUST_PRIO_INHERIT___0 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___0_SC_THREAD_ROBUST_PRIO_PROTECT___0 = 248,
    _SC_MINSIGSTKSZ___0_SC_MINSIGSTKSZ___0 = 249,
    _SC_SIGSTKSZ___0_SC_SIGSTKSZ___0 = 250
} ;
#line 539
enum __anonenum_875524036___0 {
    _CS_PATH___0_CS_PATH___0 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___0_CS_V6_WIDTH_RESTRICTED_ENVS___0 = 1,
    _CS_GNU_LIBC_VERSION___0_CS_GNU_LIBC_VERSION___0 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___0_CS_GNU_LIBPTHREAD_VERSION___0 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___0_CS_V5_WIDTH_RESTRICTED_ENVS___0 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___0_CS_V7_WIDTH_RESTRICTED_ENVS___0 = 5,
    _CS_LFS_CFLAGS___0_CS_LFS_CFLAGS___0 = 1000,
    _CS_LFS_LDFLAGS___0_CS_LFS_LDFLAGS___0 = 1001,
    _CS_LFS_LIBS___0_CS_LFS_LIBS___0 = 1002,
    _CS_LFS_LINTFLAGS___0_CS_LFS_LINTFLAGS___0 = 1003,
    _CS_LFS64_CFLAGS___0_CS_LFS64_CFLAGS___0 = 1004,
    _CS_LFS64_LDFLAGS___0_CS_LFS64_LDFLAGS___0 = 1005,
    _CS_LFS64_LIBS___0_CS_LFS64_LIBS___0 = 1006,
    _CS_LFS64_LINTFLAGS___0_CS_LFS64_LINTFLAGS___0 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___0_CS_XBS5_ILP32_OFF32_CFLAGS___0 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___0_CS_XBS5_ILP32_OFF32_LDFLAGS___0 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___0_CS_XBS5_ILP32_OFF32_LIBS___0 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___0_CS_XBS5_ILP32_OFF32_LINTFLAGS___0 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___0_CS_XBS5_ILP32_OFFBIG_CFLAGS___0 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___0_CS_XBS5_ILP32_OFFBIG_LDFLAGS___0 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___0_CS_XBS5_ILP32_OFFBIG_LIBS___0 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___0_CS_XBS5_ILP32_OFFBIG_LINTFLAGS___0 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___0_CS_XBS5_LP64_OFF64_CFLAGS___0 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___0_CS_XBS5_LP64_OFF64_LDFLAGS___0 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___0_CS_XBS5_LP64_OFF64_LIBS___0 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___0_CS_XBS5_LP64_OFF64_LINTFLAGS___0 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___0_CS_XBS5_LPBIG_OFFBIG_CFLAGS___0 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___0_CS_XBS5_LPBIG_OFFBIG_LDFLAGS___0 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___0_CS_XBS5_LPBIG_OFFBIG_LIBS___0 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___0_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___0 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___0_CS_POSIX_V6_ILP32_OFF32_CFLAGS___0 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___0_CS_POSIX_V6_ILP32_OFF32_LDFLAGS___0 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___0_CS_POSIX_V6_ILP32_OFF32_LIBS___0 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___0_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___0 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___0_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___0 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___0_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___0 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___0_CS_POSIX_V6_ILP32_OFFBIG_LIBS___0 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___0_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___0 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___0_CS_POSIX_V6_LP64_OFF64_CFLAGS___0 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___0_CS_POSIX_V6_LP64_OFF64_LDFLAGS___0 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___0_CS_POSIX_V6_LP64_OFF64_LIBS___0 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___0_CS_POSIX_V6_LP64_OFF64_LINTFLAGS___0 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___0_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___0 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___0_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___0 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___0_CS_POSIX_V6_LPBIG_OFFBIG_LIBS___0 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___0_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___0 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___0_CS_POSIX_V7_ILP32_OFF32_CFLAGS___0 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___0_CS_POSIX_V7_ILP32_OFF32_LDFLAGS___0 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___0_CS_POSIX_V7_ILP32_OFF32_LIBS___0 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___0_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___0 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___0_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___0 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___0_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___0 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___0_CS_POSIX_V7_ILP32_OFFBIG_LIBS___0 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___0_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___0 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___0_CS_POSIX_V7_LP64_OFF64_CFLAGS___0 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___0_CS_POSIX_V7_LP64_OFF64_LDFLAGS___0 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___0_CS_POSIX_V7_LP64_OFF64_LIBS___0 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___0_CS_POSIX_V7_LP64_OFF64_LINTFLAGS___0 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___0_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___0 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___0_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___0 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___0_CS_POSIX_V7_LPBIG_OFFBIG_LIBS___0 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___0_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___0 = 1147,
    _CS_V6_ENV___0_CS_V6_ENV___0 = 1148,
    _CS_V7_ENV___0_CS_V7_ENV___0 = 1149
} ;
#line 27 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 36 "/usr/include/bits/ioctl-types.h"
struct termio {
   unsigned short c_iflag ;
   unsigned short c_oflag ;
   unsigned short c_cflag ;
   unsigned short c_lflag ;
   unsigned char c_line ;
   unsigned char c_cc[8] ;
};
#line 149 "/usr/include/linux/soundcard.h"
struct synth_control {
   int devno ;
   char data[4000] ;
};
#line 149 "/usr/include/linux/soundcard.h"
typedef struct synth_control synth_control;
#line 155 "/usr/include/linux/soundcard.h"
struct remove_sample {
   int devno ;
   int bankno ;
   int instrno ;
};
#line 155 "/usr/include/linux/soundcard.h"
typedef struct remove_sample remove_sample;
#line 162 "/usr/include/linux/soundcard.h"
struct seq_event_rec {
   unsigned char arr[8] ;
};
#line 162 "/usr/include/linux/soundcard.h"
typedef struct seq_event_rec seq_event_rec;
#line 209 "/usr/include/linux/soundcard.h"
struct patch_info {
   unsigned short key ;
   short device_no ;
   short instr_no ;
   unsigned int mode ;
   int len ;
   int loop_start ;
   int loop_end ;
   unsigned int base_freq ;
   unsigned int base_note ;
   unsigned int high_note ;
   unsigned int low_note ;
   int panning ;
   int detuning ;
   unsigned char env_rate[6] ;
   unsigned char env_offset[6] ;
   unsigned char tremolo_sweep ;
   unsigned char tremolo_rate ;
   unsigned char tremolo_depth ;
   unsigned char vibrato_sweep ;
   unsigned char vibrato_rate ;
   unsigned char vibrato_depth ;
   int scale_frequency ;
   unsigned int scale_factor ;
   int volume ;
   int fractions ;
   int reserved1 ;
   int spare[2] ;
   char data[1] ;
};
#line 298 "/usr/include/linux/soundcard.h"
struct sysex_info {
   short key ;
   short device_no ;
   int len ;
   unsigned char data[1] ;
};
#line 465 "/usr/include/linux/soundcard.h"
typedef unsigned char sbi_instr_data[32];
#line 467 "/usr/include/linux/soundcard.h"
struct sbi_instrument {
   unsigned short key ;
   short device ;
   int channel ;
   sbi_instr_data operators ;
};
#line 476 "/usr/include/linux/soundcard.h"
struct synth_info {
   char name[30] ;
   int device ;
   int synth_type ;
   int synth_subtype ;
   int perc_mode ;
   int nr_voices ;
   int nr_drums ;
   int instr_bank_size ;
   unsigned int capabilities ;
   int dummies[19] ;
};
#line 504 "/usr/include/linux/soundcard.h"
struct sound_timer_info {
   char name[32] ;
   int caps ;
};
#line 511 "/usr/include/linux/soundcard.h"
struct midi_info {
   char name[30] ;
   int device ;
   unsigned int capabilities ;
   int dev_type ;
   int dummies[18] ;
};
#line 522 "/usr/include/linux/soundcard.h"
struct __anonstruct_mpu_command_rec_630660898 {
   unsigned char cmd ;
   char nr_args ;
   char nr_returns ;
   unsigned char data[30] ;
};
#line 522 "/usr/include/linux/soundcard.h"
typedef struct __anonstruct_mpu_command_rec_630660898 mpu_command_rec;
#line 568 "/usr/include/linux/soundcard.h"
struct audio_buf_info {
   int fragments ;
   int fragstotal ;
   int fragsize ;
   int bytes ;
};
#line 568 "/usr/include/linux/soundcard.h"
typedef struct audio_buf_info audio_buf_info;
#line 602 "/usr/include/linux/soundcard.h"
struct count_info {
   int bytes ;
   int blocks ;
   int ptr ;
};
#line 602 "/usr/include/linux/soundcard.h"
typedef struct count_info count_info;
#line 611 "/usr/include/linux/soundcard.h"
struct buffmem_desc {
   unsigned int *buffer ;
   int size ;
};
#line 611 "/usr/include/linux/soundcard.h"
typedef struct buffmem_desc buffmem_desc;
#line 693 "/usr/include/linux/soundcard.h"
struct copr_buffer {
   int command ;
   int flags ;
   int len ;
   int offs ;
   unsigned char data[4000] ;
};
#line 693 "/usr/include/linux/soundcard.h"
typedef struct copr_buffer copr_buffer;
#line 705 "/usr/include/linux/soundcard.h"
struct copr_debug_buf {
   int command ;
   int parm1 ;
   int parm2 ;
   int flags ;
   int len ;
};
#line 705 "/usr/include/linux/soundcard.h"
typedef struct copr_debug_buf copr_debug_buf;
#line 713 "/usr/include/linux/soundcard.h"
struct copr_msg {
   int len ;
   unsigned char data[4000] ;
};
#line 713 "/usr/include/linux/soundcard.h"
typedef struct copr_msg copr_msg;
#line 902 "/usr/include/linux/soundcard.h"
struct mixer_info {
   char id[16] ;
   char name[32] ;
   int modify_counter ;
   int fillers[10] ;
};
#line 902 "/usr/include/linux/soundcard.h"
typedef struct mixer_info mixer_info;
#line 910 "/usr/include/linux/soundcard.h"
struct _old_mixer_info {
   char id[16] ;
   char name[32] ;
};
#line 910 "/usr/include/linux/soundcard.h"
typedef struct _old_mixer_info _old_mixer_info;
#line 925 "/usr/include/linux/soundcard.h"
typedef unsigned char mixer_record[128];
#line 953 "/usr/include/linux/soundcard.h"
struct mixer_vol_table {
   int num ;
   char name[32] ;
   int levels[32] ;
};
#line 953 "/usr/include/linux/soundcard.h"
typedef struct mixer_vol_table mixer_vol_table;
#line 7 "/usr/include/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 8 "/usr/include/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 24 "/usr/include/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 36 "/usr/include/bits/types/siginfo_t.h"
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 36 "/usr/include/bits/types/siginfo_t.h"
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/bits/types/siginfo_t.h"
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/bits/types/siginfo_t.h"
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 36 "/usr/include/bits/types/siginfo_t.h"
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
#line 36 "/usr/include/bits/types/siginfo_t.h"
union __anonunion__bounds_824241775 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 36 "/usr/include/bits/types/siginfo_t.h"
struct __anonstruct__sigfault_869400645 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_824241775 _bounds ;
};
#line 36 "/usr/include/bits/types/siginfo_t.h"
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
#line 36 "/usr/include/bits/types/siginfo_t.h"
struct __anonstruct__sigsys_634745154 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 36 "/usr/include/bits/types/siginfo_t.h"
union __anonunion__sifields_320592366 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_869400645 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_634745154 _sigsys ;
};
#line 36 "/usr/include/bits/types/siginfo_t.h"
struct __anonstruct_siginfo_t_274748733 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_320592366 _sifields ;
};
#line 36 "/usr/include/bits/types/siginfo_t.h"
typedef struct __anonstruct_siginfo_t_274748733 siginfo_t;
#line 35 "/usr/include/bits/siginfo-consts.h"
enum __anonenum_556971655 {
    SI_ASYNCNLSI_ASYNCNL = -60,
    SI_DETHREADSI_DETHREAD = -7,
    SI_TKILLSI_TKILL = -6,
    SI_SIGIOSI_SIGIO = -5,
    SI_ASYNCIOSI_ASYNCIO = -4,
    SI_MESGQSI_MESGQ = -3,
    SI_TIMERSI_TIMER = -2,
    SI_QUEUESI_QUEUE = -1,
    SI_USERSI_USER = 0,
    SI_KERNELSI_KERNEL = 128
} ;
#line 71
enum __anonenum_640648963 {
    ILL_ILLOPCILL_ILLOPC = 1,
    ILL_ILLOPNILL_ILLOPN = 2,
    ILL_ILLADRILL_ILLADR = 3,
    ILL_ILLTRPILL_ILLTRP = 4,
    ILL_PRVOPCILL_PRVOPC = 5,
    ILL_PRVREGILL_PRVREG = 6,
    ILL_COPROCILL_COPROC = 7,
    ILL_BADSTKILL_BADSTK = 8,
    ILL_BADIADDRILL_BADIADDR = 9
} ;
#line 94
enum __anonenum_457704180 {
    FPE_INTDIVFPE_INTDIV = 1,
    FPE_INTOVFFPE_INTOVF = 2,
    FPE_FLTDIVFPE_FLTDIV = 3,
    FPE_FLTOVFFPE_FLTOVF = 4,
    FPE_FLTUNDFPE_FLTUND = 5,
    FPE_FLTRESFPE_FLTRES = 6,
    FPE_FLTINVFPE_FLTINV = 7,
    FPE_FLTSUBFPE_FLTSUB = 8,
    FPE_FLTUNKFPE_FLTUNK = 14,
    FPE_CONDTRAPFPE_CONDTRAP = 15
} ;
#line 119
enum __anonenum_850350928 {
    SEGV_MAPERRSEGV_MAPERR = 1,
    SEGV_ACCERRSEGV_ACCERR = 2,
    SEGV_BNDERRSEGV_BNDERR = 3,
    SEGV_PKUERRSEGV_PKUERR = 4,
    SEGV_ACCADISEGV_ACCADI = 5,
    SEGV_ADIDERRSEGV_ADIDERR = 6,
    SEGV_ADIPERRSEGV_ADIPERR = 7,
    SEGV_MTEAERRSEGV_MTEAERR = 8,
    SEGV_MTESERRSEGV_MTESERR = 9,
    SEGV_CPERRSEGV_CPERR = 10
} ;
#line 144
enum __anonenum_1036286214 {
    BUS_ADRALNBUS_ADRALN = 1,
    BUS_ADRERRBUS_ADRERR = 2,
    BUS_OBJERRBUS_OBJERR = 3,
    BUS_MCEERR_ARBUS_MCEERR_AR = 4,
    BUS_MCEERR_AOBUS_MCEERR_AO = 5
} ;
#line 178
enum __anonenum_23175539 {
    CLD_EXITEDCLD_EXITED = 1,
    CLD_KILLEDCLD_KILLED = 2,
    CLD_DUMPEDCLD_DUMPED = 3,
    CLD_TRAPPEDCLD_TRAPPED = 4,
    CLD_STOPPEDCLD_STOPPED = 5,
    CLD_CONTINUEDCLD_CONTINUED = 6
} ;
#line 195
enum __anonenum_111643124 {
    POLL_INPOLL_IN = 1,
    POLL_OUTPOLL_OUT = 2,
    POLL_MSGPOLL_MSG = 3,
    POLL_ERRPOLL_ERR = 4,
    POLL_PRIPOLL_PRI = 5,
    POLL_HUPPOLL_HUP = 6
} ;
#line 16 "/usr/include/bits/types/sigval_t.h"
typedef __sigval_t sigval_t;
#line 22 "/usr/include/bits/types/sigevent_t.h"
struct __anonstruct__sigev_thread_746770901 {
   void (*_function)(__sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
#line 22 "/usr/include/bits/types/sigevent_t.h"
union __anonunion__sigev_un_1000371759 {
   int _pad[64UL / sizeof(int ) - 3UL] ;
   __pid_t _tid ;
   struct __anonstruct__sigev_thread_746770901 _sigev_thread ;
};
#line 22 "/usr/include/bits/types/sigevent_t.h"
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_1000371759 _sigev_un ;
};
#line 22 "/usr/include/bits/types/sigevent_t.h"
typedef struct sigevent sigevent_t;
#line 27 "/usr/include/bits/sigevent-consts.h"
enum __anonenum_852341087 {
    SIGEV_SIGNALSIGEV_SIGNAL = 0,
    SIGEV_NONESIGEV_NONE = 1,
    SIGEV_THREADSIGEV_THREAD = 2,
    SIGEV_THREAD_IDSIGEV_THREAD_ID = 4
} ;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 193 "/usr/include/signal.h"
typedef void (*sig_t)(int  );
#line 27 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 27 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/bits/sigcontext.h"
struct _fpx_sw_bytes {
   __uint32_t magic1 ;
   __uint32_t extended_size ;
   __uint64_t xstate_bv ;
   __uint32_t xstate_size ;
   __uint32_t __glibc_reserved1[7] ;
};
#line 40 "/usr/include/bits/sigcontext.h"
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 46 "/usr/include/bits/sigcontext.h"
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 53 "/usr/include/bits/sigcontext.h"
struct _xmmreg {
   __uint32_t element[4] ;
};
#line 62 "/usr/include/bits/sigcontext.h"
struct _fpstate {
   __uint32_t cw ;
   __uint32_t sw ;
   __uint32_t tag ;
   __uint32_t ipoff ;
   __uint32_t cssel ;
   __uint32_t dataoff ;
   __uint32_t datasel ;
   struct _fpreg _st[8] ;
   unsigned short status ;
   unsigned short magic ;
   __uint32_t _fxsr_env[6] ;
   __uint32_t mxcsr ;
   __uint32_t __glibc_reserved1 ;
   struct _fpxreg _fxsr_st[8] ;
   struct _xmmreg _xmm[8] ;
   __uint32_t __glibc_reserved2[56] ;
};
#line 95 "/usr/include/bits/sigcontext.h"
struct sigcontext {
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned long edi ;
   unsigned long esi ;
   unsigned long ebp ;
   unsigned long esp ;
   unsigned long ebx ;
   unsigned long edx ;
   unsigned long ecx ;
   unsigned long eax ;
   unsigned long trapno ;
   unsigned long err ;
   unsigned long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned long eflags ;
   unsigned long esp_at_signal ;
   unsigned short ss ;
   unsigned short __ssh ;
   struct _fpstate *fpstate ;
   unsigned long oldmask ;
   unsigned long cr2 ;
};
#line 177 "/usr/include/bits/sigcontext.h"
struct _xsave_hdr {
   __uint64_t xstate_bv ;
   __uint64_t __glibc_reserved1[2] ;
   __uint64_t __glibc_reserved2[5] ;
};
#line 184 "/usr/include/bits/sigcontext.h"
struct _ymmh_state {
   __uint32_t ymmh_space[64] ;
};
#line 189 "/usr/include/bits/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 26 "/usr/include/bits/types/stack_t.h"
struct __anonstruct_stack_t_648343364 {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 26 "/usr/include/bits/types/stack_t.h"
typedef struct __anonstruct_stack_t_648343364 stack_t;
#line 156 "/usr/include/sys/ucontext.h"
typedef int greg_t;
#line 165 "/usr/include/sys/ucontext.h"
typedef greg_t gregset_t[19];
#line 213 "/usr/include/sys/ucontext.h"
struct _libc_fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 219 "/usr/include/sys/ucontext.h"
struct _libc_fpstate {
   unsigned long cw ;
   unsigned long sw ;
   unsigned long tag ;
   unsigned long ipoff ;
   unsigned long cssel ;
   unsigned long dataoff ;
   unsigned long datasel ;
   struct _libc_fpreg _st[8] ;
   unsigned long status ;
};
#line 233 "/usr/include/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 236 "/usr/include/sys/ucontext.h"
struct __anonstruct_mcontext_t_260193669 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long oldmask ;
   unsigned long cr2 ;
};
#line 236 "/usr/include/sys/ucontext.h"
typedef struct __anonstruct_mcontext_t_260193669 mcontext_t;
#line 247 "/usr/include/sys/ucontext.h"
struct ucontext_t {
   unsigned long uc_flags ;
   struct ucontext_t *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
   unsigned long __ssp[4] ;
};
#line 247 "/usr/include/sys/ucontext.h"
typedef struct ucontext_t ucontext_t;
#line 27 "/usr/include/bits/ss_flags.h"
enum __anonenum_57186863 {
    SS_ONSTACKSS_ONSTACK = 1,
    SS_DISABLESS_DISABLE = 2
} ;
#line 23 "/usr/include/bits/types/struct_sigstack.h"
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
#line 58 "z_zone.h"
struct memblock_s {
   int size ;
   void **user ;
   int tag ;
   int id ;
   struct memblock_s *next ;
   struct memblock_s *prev ;
};
#line 58 "z_zone.h"
typedef struct memblock_s memblock_t;
#line 33 "doomdef.h"
enum __anonenum_82154846___2 {
    VERSION___2VERSION___2 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___1 {
    ML_LABEL___1ML_LABEL___1 = 0,
    ML_THINGS___1ML_THINGS___1 = 1,
    ML_LINEDEFS___1ML_LINEDEFS___1 = 2,
    ML_SIDEDEFS___1ML_SIDEDEFS___1 = 3,
    ML_VERTEXES___1ML_VERTEXES___1 = 4,
    ML_SEGS___1ML_SEGS___1 = 5,
    ML_SSECTORS___1ML_SSECTORS___1 = 6,
    ML_NODES___1ML_NODES___1 = 7,
    ML_SECTORS___1ML_SECTORS___1 = 8,
    ML_REJECT___1ML_REJECT___1 = 9,
    ML_BLOCKMAP___1ML_BLOCKMAP___1 = 10
} ;
#line 35 "w_wad.h"
struct __anonstruct_wadinfo_t_483049182 {
   char identification[4] ;
   int numlumps ;
   int infotableofs ;
};
#line 35 "w_wad.h"
typedef struct __anonstruct_wadinfo_t_483049182 wadinfo_t;
#line 45 "w_wad.h"
struct __anonstruct_filelump_t_478576807 {
   int filepos ;
   int size ;
   char name[8] ;
};
#line 45 "w_wad.h"
typedef struct __anonstruct_filelump_t_478576807 filelump_t;
#line 56 "w_wad.h"
struct __anonstruct_lumpinfo_t_380129968 {
   char name[8] ;
   int handle ;
   int position ;
   int size ;
};
#line 56 "w_wad.h"
typedef struct __anonstruct_lumpinfo_t_380129968 lumpinfo_t;
#line 904 "i_sound.c"
typedef int tSigSet;
#line 24 "/usr/include/bits/confname.h"
enum __anonenum_437032235___1 {
    _PC_LINK_MAX___1_PC_LINK_MAX___1 = 0,
    _PC_MAX_CANON___1_PC_MAX_CANON___1 = 1,
    _PC_MAX_INPUT___1_PC_MAX_INPUT___1 = 2,
    _PC_NAME_MAX___1_PC_NAME_MAX___1 = 3,
    _PC_PATH_MAX___1_PC_PATH_MAX___1 = 4,
    _PC_PIPE_BUF___1_PC_PIPE_BUF___1 = 5,
    _PC_CHOWN_RESTRICTED___1_PC_CHOWN_RESTRICTED___1 = 6,
    _PC_NO_TRUNC___1_PC_NO_TRUNC___1 = 7,
    _PC_VDISABLE___1_PC_VDISABLE___1 = 8,
    _PC_SYNC_IO___1_PC_SYNC_IO___1 = 9,
    _PC_ASYNC_IO___1_PC_ASYNC_IO___1 = 10,
    _PC_PRIO_IO___1_PC_PRIO_IO___1 = 11,
    _PC_SOCK_MAXBUF___1_PC_SOCK_MAXBUF___1 = 12,
    _PC_FILESIZEBITS___1_PC_FILESIZEBITS___1 = 13,
    _PC_REC_INCR_XFER_SIZE___1_PC_REC_INCR_XFER_SIZE___1 = 14,
    _PC_REC_MAX_XFER_SIZE___1_PC_REC_MAX_XFER_SIZE___1 = 15,
    _PC_REC_MIN_XFER_SIZE___1_PC_REC_MIN_XFER_SIZE___1 = 16,
    _PC_REC_XFER_ALIGN___1_PC_REC_XFER_ALIGN___1 = 17,
    _PC_ALLOC_SIZE_MIN___1_PC_ALLOC_SIZE_MIN___1 = 18,
    _PC_SYMLINK_MAX___1_PC_SYMLINK_MAX___1 = 19,
    _PC_2_SYMLINKS___1_PC_2_SYMLINKS___1 = 20
} ;
#line 71
enum __anonenum_315186338___1 {
    _SC_ARG_MAX___1_SC_ARG_MAX___1 = 0,
    _SC_CHILD_MAX___1_SC_CHILD_MAX___1 = 1,
    _SC_CLK_TCK___1_SC_CLK_TCK___1 = 2,
    _SC_NGROUPS_MAX___1_SC_NGROUPS_MAX___1 = 3,
    _SC_OPEN_MAX___1_SC_OPEN_MAX___1 = 4,
    _SC_STREAM_MAX___1_SC_STREAM_MAX___1 = 5,
    _SC_TZNAME_MAX___1_SC_TZNAME_MAX___1 = 6,
    _SC_JOB_CONTROL___1_SC_JOB_CONTROL___1 = 7,
    _SC_SAVED_IDS___1_SC_SAVED_IDS___1 = 8,
    _SC_REALTIME_SIGNALS___1_SC_REALTIME_SIGNALS___1 = 9,
    _SC_PRIORITY_SCHEDULING___1_SC_PRIORITY_SCHEDULING___1 = 10,
    _SC_TIMERS___1_SC_TIMERS___1 = 11,
    _SC_ASYNCHRONOUS_IO___1_SC_ASYNCHRONOUS_IO___1 = 12,
    _SC_PRIORITIZED_IO___1_SC_PRIORITIZED_IO___1 = 13,
    _SC_SYNCHRONIZED_IO___1_SC_SYNCHRONIZED_IO___1 = 14,
    _SC_FSYNC___1_SC_FSYNC___1 = 15,
    _SC_MAPPED_FILES___1_SC_MAPPED_FILES___1 = 16,
    _SC_MEMLOCK___1_SC_MEMLOCK___1 = 17,
    _SC_MEMLOCK_RANGE___1_SC_MEMLOCK_RANGE___1 = 18,
    _SC_MEMORY_PROTECTION___1_SC_MEMORY_PROTECTION___1 = 19,
    _SC_MESSAGE_PASSING___1_SC_MESSAGE_PASSING___1 = 20,
    _SC_SEMAPHORES___1_SC_SEMAPHORES___1 = 21,
    _SC_SHARED_MEMORY_OBJECTS___1_SC_SHARED_MEMORY_OBJECTS___1 = 22,
    _SC_AIO_LISTIO_MAX___1_SC_AIO_LISTIO_MAX___1 = 23,
    _SC_AIO_MAX___1_SC_AIO_MAX___1 = 24,
    _SC_AIO_PRIO_DELTA_MAX___1_SC_AIO_PRIO_DELTA_MAX___1 = 25,
    _SC_DELAYTIMER_MAX___1_SC_DELAYTIMER_MAX___1 = 26,
    _SC_MQ_OPEN_MAX___1_SC_MQ_OPEN_MAX___1 = 27,
    _SC_MQ_PRIO_MAX___1_SC_MQ_PRIO_MAX___1 = 28,
    _SC_VERSION___1_SC_VERSION___1 = 29,
    _SC_PAGESIZE___1_SC_PAGESIZE___1 = 30,
    _SC_RTSIG_MAX___1_SC_RTSIG_MAX___1 = 31,
    _SC_SEM_NSEMS_MAX___1_SC_SEM_NSEMS_MAX___1 = 32,
    _SC_SEM_VALUE_MAX___1_SC_SEM_VALUE_MAX___1 = 33,
    _SC_SIGQUEUE_MAX___1_SC_SIGQUEUE_MAX___1 = 34,
    _SC_TIMER_MAX___1_SC_TIMER_MAX___1 = 35,
    _SC_BC_BASE_MAX___1_SC_BC_BASE_MAX___1 = 36,
    _SC_BC_DIM_MAX___1_SC_BC_DIM_MAX___1 = 37,
    _SC_BC_SCALE_MAX___1_SC_BC_SCALE_MAX___1 = 38,
    _SC_BC_STRING_MAX___1_SC_BC_STRING_MAX___1 = 39,
    _SC_COLL_WEIGHTS_MAX___1_SC_COLL_WEIGHTS_MAX___1 = 40,
    _SC_EQUIV_CLASS_MAX___1_SC_EQUIV_CLASS_MAX___1 = 41,
    _SC_EXPR_NEST_MAX___1_SC_EXPR_NEST_MAX___1 = 42,
    _SC_LINE_MAX___1_SC_LINE_MAX___1 = 43,
    _SC_RE_DUP_MAX___1_SC_RE_DUP_MAX___1 = 44,
    _SC_CHARCLASS_NAME_MAX___1_SC_CHARCLASS_NAME_MAX___1 = 45,
    _SC_2_VERSION___1_SC_2_VERSION___1 = 46,
    _SC_2_C_BIND___1_SC_2_C_BIND___1 = 47,
    _SC_2_C_DEV___1_SC_2_C_DEV___1 = 48,
    _SC_2_FORT_DEV___1_SC_2_FORT_DEV___1 = 49,
    _SC_2_FORT_RUN___1_SC_2_FORT_RUN___1 = 50,
    _SC_2_SW_DEV___1_SC_2_SW_DEV___1 = 51,
    _SC_2_LOCALEDEF___1_SC_2_LOCALEDEF___1 = 52,
    _SC_PII___1_SC_PII___1 = 53,
    _SC_PII_XTI___1_SC_PII_XTI___1 = 54,
    _SC_PII_SOCKET___1_SC_PII_SOCKET___1 = 55,
    _SC_PII_INTERNET___1_SC_PII_INTERNET___1 = 56,
    _SC_PII_OSI___1_SC_PII_OSI___1 = 57,
    _SC_POLL___1_SC_POLL___1 = 58,
    _SC_SELECT___1_SC_SELECT___1 = 59,
    _SC_UIO_MAXIOV___1_SC_UIO_MAXIOV___1 = 60,
    _SC_IOV_MAX___1_SC_IOV_MAX___1 = 60,
    _SC_PII_INTERNET_STREAM___1_SC_PII_INTERNET_STREAM___1 = 61,
    _SC_PII_INTERNET_DGRAM___1_SC_PII_INTERNET_DGRAM___1 = 62,
    _SC_PII_OSI_COTS___1_SC_PII_OSI_COTS___1 = 63,
    _SC_PII_OSI_CLTS___1_SC_PII_OSI_CLTS___1 = 64,
    _SC_PII_OSI_M___1_SC_PII_OSI_M___1 = 65,
    _SC_T_IOV_MAX___1_SC_T_IOV_MAX___1 = 66,
    _SC_THREADS___1_SC_THREADS___1 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___1_SC_THREAD_SAFE_FUNCTIONS___1 = 68,
    _SC_GETGR_R_SIZE_MAX___1_SC_GETGR_R_SIZE_MAX___1 = 69,
    _SC_GETPW_R_SIZE_MAX___1_SC_GETPW_R_SIZE_MAX___1 = 70,
    _SC_LOGIN_NAME_MAX___1_SC_LOGIN_NAME_MAX___1 = 71,
    _SC_TTY_NAME_MAX___1_SC_TTY_NAME_MAX___1 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___1_SC_THREAD_DESTRUCTOR_ITERATIONS___1 = 73,
    _SC_THREAD_KEYS_MAX___1_SC_THREAD_KEYS_MAX___1 = 74,
    _SC_THREAD_STACK_MIN___1_SC_THREAD_STACK_MIN___1 = 75,
    _SC_THREAD_THREADS_MAX___1_SC_THREAD_THREADS_MAX___1 = 76,
    _SC_THREAD_ATTR_STACKADDR___1_SC_THREAD_ATTR_STACKADDR___1 = 77,
    _SC_THREAD_ATTR_STACKSIZE___1_SC_THREAD_ATTR_STACKSIZE___1 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___1_SC_THREAD_PRIORITY_SCHEDULING___1 = 79,
    _SC_THREAD_PRIO_INHERIT___1_SC_THREAD_PRIO_INHERIT___1 = 80,
    _SC_THREAD_PRIO_PROTECT___1_SC_THREAD_PRIO_PROTECT___1 = 81,
    _SC_THREAD_PROCESS_SHARED___1_SC_THREAD_PROCESS_SHARED___1 = 82,
    _SC_NPROCESSORS_CONF___1_SC_NPROCESSORS_CONF___1 = 83,
    _SC_NPROCESSORS_ONLN___1_SC_NPROCESSORS_ONLN___1 = 84,
    _SC_PHYS_PAGES___1_SC_PHYS_PAGES___1 = 85,
    _SC_AVPHYS_PAGES___1_SC_AVPHYS_PAGES___1 = 86,
    _SC_ATEXIT_MAX___1_SC_ATEXIT_MAX___1 = 87,
    _SC_PASS_MAX___1_SC_PASS_MAX___1 = 88,
    _SC_XOPEN_VERSION___1_SC_XOPEN_VERSION___1 = 89,
    _SC_XOPEN_XCU_VERSION___1_SC_XOPEN_XCU_VERSION___1 = 90,
    _SC_XOPEN_UNIX___1_SC_XOPEN_UNIX___1 = 91,
    _SC_XOPEN_CRYPT___1_SC_XOPEN_CRYPT___1 = 92,
    _SC_XOPEN_ENH_I18N___1_SC_XOPEN_ENH_I18N___1 = 93,
    _SC_XOPEN_SHM___1_SC_XOPEN_SHM___1 = 94,
    _SC_2_CHAR_TERM___1_SC_2_CHAR_TERM___1 = 95,
    _SC_2_C_VERSION___1_SC_2_C_VERSION___1 = 96,
    _SC_2_UPE___1_SC_2_UPE___1 = 97,
    _SC_XOPEN_XPG2___1_SC_XOPEN_XPG2___1 = 98,
    _SC_XOPEN_XPG3___1_SC_XOPEN_XPG3___1 = 99,
    _SC_XOPEN_XPG4___1_SC_XOPEN_XPG4___1 = 100,
    _SC_CHAR_BIT___1_SC_CHAR_BIT___1 = 101,
    _SC_CHAR_MAX___1_SC_CHAR_MAX___1 = 102,
    _SC_CHAR_MIN___1_SC_CHAR_MIN___1 = 103,
    _SC_INT_MAX___1_SC_INT_MAX___1 = 104,
    _SC_INT_MIN___1_SC_INT_MIN___1 = 105,
    _SC_LONG_BIT___1_SC_LONG_BIT___1 = 106,
    _SC_WORD_BIT___1_SC_WORD_BIT___1 = 107,
    _SC_MB_LEN_MAX___1_SC_MB_LEN_MAX___1 = 108,
    _SC_NZERO___1_SC_NZERO___1 = 109,
    _SC_SSIZE_MAX___1_SC_SSIZE_MAX___1 = 110,
    _SC_SCHAR_MAX___1_SC_SCHAR_MAX___1 = 111,
    _SC_SCHAR_MIN___1_SC_SCHAR_MIN___1 = 112,
    _SC_SHRT_MAX___1_SC_SHRT_MAX___1 = 113,
    _SC_SHRT_MIN___1_SC_SHRT_MIN___1 = 114,
    _SC_UCHAR_MAX___1_SC_UCHAR_MAX___1 = 115,
    _SC_UINT_MAX___1_SC_UINT_MAX___1 = 116,
    _SC_ULONG_MAX___1_SC_ULONG_MAX___1 = 117,
    _SC_USHRT_MAX___1_SC_USHRT_MAX___1 = 118,
    _SC_NL_ARGMAX___1_SC_NL_ARGMAX___1 = 119,
    _SC_NL_LANGMAX___1_SC_NL_LANGMAX___1 = 120,
    _SC_NL_MSGMAX___1_SC_NL_MSGMAX___1 = 121,
    _SC_NL_NMAX___1_SC_NL_NMAX___1 = 122,
    _SC_NL_SETMAX___1_SC_NL_SETMAX___1 = 123,
    _SC_NL_TEXTMAX___1_SC_NL_TEXTMAX___1 = 124,
    _SC_XBS5_ILP32_OFF32___1_SC_XBS5_ILP32_OFF32___1 = 125,
    _SC_XBS5_ILP32_OFFBIG___1_SC_XBS5_ILP32_OFFBIG___1 = 126,
    _SC_XBS5_LP64_OFF64___1_SC_XBS5_LP64_OFF64___1 = 127,
    _SC_XBS5_LPBIG_OFFBIG___1_SC_XBS5_LPBIG_OFFBIG___1 = 128,
    _SC_XOPEN_LEGACY___1_SC_XOPEN_LEGACY___1 = 129,
    _SC_XOPEN_REALTIME___1_SC_XOPEN_REALTIME___1 = 130,
    _SC_XOPEN_REALTIME_THREADS___1_SC_XOPEN_REALTIME_THREADS___1 = 131,
    _SC_ADVISORY_INFO___1_SC_ADVISORY_INFO___1 = 132,
    _SC_BARRIERS___1_SC_BARRIERS___1 = 133,
    _SC_BASE___1_SC_BASE___1 = 134,
    _SC_C_LANG_SUPPORT___1_SC_C_LANG_SUPPORT___1 = 135,
    _SC_C_LANG_SUPPORT_R___1_SC_C_LANG_SUPPORT_R___1 = 136,
    _SC_CLOCK_SELECTION___1_SC_CLOCK_SELECTION___1 = 137,
    _SC_CPUTIME___1_SC_CPUTIME___1 = 138,
    _SC_THREAD_CPUTIME___1_SC_THREAD_CPUTIME___1 = 139,
    _SC_DEVICE_IO___1_SC_DEVICE_IO___1 = 140,
    _SC_DEVICE_SPECIFIC___1_SC_DEVICE_SPECIFIC___1 = 141,
    _SC_DEVICE_SPECIFIC_R___1_SC_DEVICE_SPECIFIC_R___1 = 142,
    _SC_FD_MGMT___1_SC_FD_MGMT___1 = 143,
    _SC_FIFO___1_SC_FIFO___1 = 144,
    _SC_PIPE___1_SC_PIPE___1 = 145,
    _SC_FILE_ATTRIBUTES___1_SC_FILE_ATTRIBUTES___1 = 146,
    _SC_FILE_LOCKING___1_SC_FILE_LOCKING___1 = 147,
    _SC_FILE_SYSTEM___1_SC_FILE_SYSTEM___1 = 148,
    _SC_MONOTONIC_CLOCK___1_SC_MONOTONIC_CLOCK___1 = 149,
    _SC_MULTI_PROCESS___1_SC_MULTI_PROCESS___1 = 150,
    _SC_SINGLE_PROCESS___1_SC_SINGLE_PROCESS___1 = 151,
    _SC_NETWORKING___1_SC_NETWORKING___1 = 152,
    _SC_READER_WRITER_LOCKS___1_SC_READER_WRITER_LOCKS___1 = 153,
    _SC_SPIN_LOCKS___1_SC_SPIN_LOCKS___1 = 154,
    _SC_REGEXP___1_SC_REGEXP___1 = 155,
    _SC_REGEX_VERSION___1_SC_REGEX_VERSION___1 = 156,
    _SC_SHELL___1_SC_SHELL___1 = 157,
    _SC_SIGNALS___1_SC_SIGNALS___1 = 158,
    _SC_SPAWN___1_SC_SPAWN___1 = 159,
    _SC_SPORADIC_SERVER___1_SC_SPORADIC_SERVER___1 = 160,
    _SC_THREAD_SPORADIC_SERVER___1_SC_THREAD_SPORADIC_SERVER___1 = 161,
    _SC_SYSTEM_DATABASE___1_SC_SYSTEM_DATABASE___1 = 162,
    _SC_SYSTEM_DATABASE_R___1_SC_SYSTEM_DATABASE_R___1 = 163,
    _SC_TIMEOUTS___1_SC_TIMEOUTS___1 = 164,
    _SC_TYPED_MEMORY_OBJECTS___1_SC_TYPED_MEMORY_OBJECTS___1 = 165,
    _SC_USER_GROUPS___1_SC_USER_GROUPS___1 = 166,
    _SC_USER_GROUPS_R___1_SC_USER_GROUPS_R___1 = 167,
    _SC_2_PBS___1_SC_2_PBS___1 = 168,
    _SC_2_PBS_ACCOUNTING___1_SC_2_PBS_ACCOUNTING___1 = 169,
    _SC_2_PBS_LOCATE___1_SC_2_PBS_LOCATE___1 = 170,
    _SC_2_PBS_MESSAGE___1_SC_2_PBS_MESSAGE___1 = 171,
    _SC_2_PBS_TRACK___1_SC_2_PBS_TRACK___1 = 172,
    _SC_SYMLOOP_MAX___1_SC_SYMLOOP_MAX___1 = 173,
    _SC_STREAMS___1_SC_STREAMS___1 = 174,
    _SC_2_PBS_CHECKPOINT___1_SC_2_PBS_CHECKPOINT___1 = 175,
    _SC_V6_ILP32_OFF32___1_SC_V6_ILP32_OFF32___1 = 176,
    _SC_V6_ILP32_OFFBIG___1_SC_V6_ILP32_OFFBIG___1 = 177,
    _SC_V6_LP64_OFF64___1_SC_V6_LP64_OFF64___1 = 178,
    _SC_V6_LPBIG_OFFBIG___1_SC_V6_LPBIG_OFFBIG___1 = 179,
    _SC_HOST_NAME_MAX___1_SC_HOST_NAME_MAX___1 = 180,
    _SC_TRACE___1_SC_TRACE___1 = 181,
    _SC_TRACE_EVENT_FILTER___1_SC_TRACE_EVENT_FILTER___1 = 182,
    _SC_TRACE_INHERIT___1_SC_TRACE_INHERIT___1 = 183,
    _SC_TRACE_LOG___1_SC_TRACE_LOG___1 = 184,
    _SC_LEVEL1_ICACHE_SIZE___1_SC_LEVEL1_ICACHE_SIZE___1 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___1_SC_LEVEL1_ICACHE_ASSOC___1 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___1_SC_LEVEL1_ICACHE_LINESIZE___1 = 187,
    _SC_LEVEL1_DCACHE_SIZE___1_SC_LEVEL1_DCACHE_SIZE___1 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___1_SC_LEVEL1_DCACHE_ASSOC___1 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___1_SC_LEVEL1_DCACHE_LINESIZE___1 = 190,
    _SC_LEVEL2_CACHE_SIZE___1_SC_LEVEL2_CACHE_SIZE___1 = 191,
    _SC_LEVEL2_CACHE_ASSOC___1_SC_LEVEL2_CACHE_ASSOC___1 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___1_SC_LEVEL2_CACHE_LINESIZE___1 = 193,
    _SC_LEVEL3_CACHE_SIZE___1_SC_LEVEL3_CACHE_SIZE___1 = 194,
    _SC_LEVEL3_CACHE_ASSOC___1_SC_LEVEL3_CACHE_ASSOC___1 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___1_SC_LEVEL3_CACHE_LINESIZE___1 = 196,
    _SC_LEVEL4_CACHE_SIZE___1_SC_LEVEL4_CACHE_SIZE___1 = 197,
    _SC_LEVEL4_CACHE_ASSOC___1_SC_LEVEL4_CACHE_ASSOC___1 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___1_SC_LEVEL4_CACHE_LINESIZE___1 = 199,
    _SC_IPV6___1_SC_IPV6___1 = 235,
    _SC_RAW_SOCKETS___1_SC_RAW_SOCKETS___1 = 236,
    _SC_V7_ILP32_OFF32___1_SC_V7_ILP32_OFF32___1 = 237,
    _SC_V7_ILP32_OFFBIG___1_SC_V7_ILP32_OFFBIG___1 = 238,
    _SC_V7_LP64_OFF64___1_SC_V7_LP64_OFF64___1 = 239,
    _SC_V7_LPBIG_OFFBIG___1_SC_V7_LPBIG_OFFBIG___1 = 240,
    _SC_SS_REPL_MAX___1_SC_SS_REPL_MAX___1 = 241,
    _SC_TRACE_EVENT_NAME_MAX___1_SC_TRACE_EVENT_NAME_MAX___1 = 242,
    _SC_TRACE_NAME_MAX___1_SC_TRACE_NAME_MAX___1 = 243,
    _SC_TRACE_SYS_MAX___1_SC_TRACE_SYS_MAX___1 = 244,
    _SC_TRACE_USER_EVENT_MAX___1_SC_TRACE_USER_EVENT_MAX___1 = 245,
    _SC_XOPEN_STREAMS___1_SC_XOPEN_STREAMS___1 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___1_SC_THREAD_ROBUST_PRIO_INHERIT___1 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___1_SC_THREAD_ROBUST_PRIO_PROTECT___1 = 248,
    _SC_MINSIGSTKSZ___1_SC_MINSIGSTKSZ___1 = 249,
    _SC_SIGSTKSZ___1_SC_SIGSTKSZ___1 = 250
} ;
#line 539
enum __anonenum_875524036___1 {
    _CS_PATH___1_CS_PATH___1 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___1_CS_V6_WIDTH_RESTRICTED_ENVS___1 = 1,
    _CS_GNU_LIBC_VERSION___1_CS_GNU_LIBC_VERSION___1 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___1_CS_GNU_LIBPTHREAD_VERSION___1 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___1_CS_V5_WIDTH_RESTRICTED_ENVS___1 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___1_CS_V7_WIDTH_RESTRICTED_ENVS___1 = 5,
    _CS_LFS_CFLAGS___1_CS_LFS_CFLAGS___1 = 1000,
    _CS_LFS_LDFLAGS___1_CS_LFS_LDFLAGS___1 = 1001,
    _CS_LFS_LIBS___1_CS_LFS_LIBS___1 = 1002,
    _CS_LFS_LINTFLAGS___1_CS_LFS_LINTFLAGS___1 = 1003,
    _CS_LFS64_CFLAGS___1_CS_LFS64_CFLAGS___1 = 1004,
    _CS_LFS64_LDFLAGS___1_CS_LFS64_LDFLAGS___1 = 1005,
    _CS_LFS64_LIBS___1_CS_LFS64_LIBS___1 = 1006,
    _CS_LFS64_LINTFLAGS___1_CS_LFS64_LINTFLAGS___1 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___1_CS_XBS5_ILP32_OFF32_CFLAGS___1 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___1_CS_XBS5_ILP32_OFF32_LDFLAGS___1 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___1_CS_XBS5_ILP32_OFF32_LIBS___1 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___1_CS_XBS5_ILP32_OFF32_LINTFLAGS___1 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___1_CS_XBS5_ILP32_OFFBIG_CFLAGS___1 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___1_CS_XBS5_ILP32_OFFBIG_LDFLAGS___1 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___1_CS_XBS5_ILP32_OFFBIG_LIBS___1 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___1_CS_XBS5_ILP32_OFFBIG_LINTFLAGS___1 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___1_CS_XBS5_LP64_OFF64_CFLAGS___1 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___1_CS_XBS5_LP64_OFF64_LDFLAGS___1 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___1_CS_XBS5_LP64_OFF64_LIBS___1 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___1_CS_XBS5_LP64_OFF64_LINTFLAGS___1 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___1_CS_XBS5_LPBIG_OFFBIG_CFLAGS___1 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___1_CS_XBS5_LPBIG_OFFBIG_LDFLAGS___1 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___1_CS_XBS5_LPBIG_OFFBIG_LIBS___1 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___1_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___1 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___1_CS_POSIX_V6_ILP32_OFF32_CFLAGS___1 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___1_CS_POSIX_V6_ILP32_OFF32_LDFLAGS___1 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___1_CS_POSIX_V6_ILP32_OFF32_LIBS___1 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___1_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___1 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___1_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___1 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___1_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___1 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___1_CS_POSIX_V6_ILP32_OFFBIG_LIBS___1 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___1_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___1 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___1_CS_POSIX_V6_LP64_OFF64_CFLAGS___1 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___1_CS_POSIX_V6_LP64_OFF64_LDFLAGS___1 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___1_CS_POSIX_V6_LP64_OFF64_LIBS___1 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___1_CS_POSIX_V6_LP64_OFF64_LINTFLAGS___1 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___1_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___1 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___1_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___1 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___1_CS_POSIX_V6_LPBIG_OFFBIG_LIBS___1 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___1_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___1 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___1_CS_POSIX_V7_ILP32_OFF32_CFLAGS___1 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___1_CS_POSIX_V7_ILP32_OFF32_LDFLAGS___1 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___1_CS_POSIX_V7_ILP32_OFF32_LIBS___1 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___1_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___1 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___1_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___1 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___1_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___1 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___1_CS_POSIX_V7_ILP32_OFFBIG_LIBS___1 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___1_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___1 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___1_CS_POSIX_V7_LP64_OFF64_CFLAGS___1 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___1_CS_POSIX_V7_LP64_OFF64_LDFLAGS___1 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___1_CS_POSIX_V7_LP64_OFF64_LIBS___1 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___1_CS_POSIX_V7_LP64_OFF64_LINTFLAGS___1 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___1_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___1 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___1_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___1 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___1_CS_POSIX_V7_LPBIG_OFFBIG_LIBS___1 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___1_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___1 = 1147,
    _CS_V6_ENV___1_CS_V6_ENV___1 = 1148,
    _CS_V7_ENV___1_CS_V7_ENV___1 = 1149
} ;
#line 30 "/usr/include/bits/ipctypes.h"
typedef unsigned short __ipc_pid_t;
#line 28 "/usr/include/bits/ipc-perm.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   __mode_t mode ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
#line 43 "/usr/include/bits/shm.h"
typedef __syscall_ulong_t shmatt_t;
#line 24 "/usr/include/bits/types/struct_shmid_ds.h"
struct shmid_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time_t shm_atime ;
   unsigned long __shm_atime_high ;
   __time_t shm_dtime ;
   unsigned long __shm_dtime_high ;
   __time_t shm_ctime ;
   unsigned long __shm_ctime_high ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   __syscall_ulong_t __glibc_reserved5 ;
   __syscall_ulong_t __glibc_reserved6 ;
};
#line 26 "/usr/include/bits/types/struct_shmid64_ds.h"
struct __shmid64_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time64_t shm_atime ;
   __time64_t shm_dtime ;
   __time64_t shm_ctime ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   unsigned long __glibc_reserved5 ;
   unsigned long __glibc_reserved6 ;
};
#line 83 "/usr/include/bits/shm.h"
struct shminfo {
   __syscall_ulong_t shmmax ;
   __syscall_ulong_t shmmin ;
   __syscall_ulong_t shmmni ;
   __syscall_ulong_t shmseg ;
   __syscall_ulong_t shmall ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
   __syscall_ulong_t __glibc_reserved3 ;
   __syscall_ulong_t __glibc_reserved4 ;
};
#line 96 "/usr/include/bits/shm.h"
struct shm_info {
   int used_ids ;
   __syscall_ulong_t shm_tot ;
   __syscall_ulong_t shm_rss ;
   __syscall_ulong_t shm_swp ;
   __syscall_ulong_t swap_attempts ;
   __syscall_ulong_t swap_successes ;
};
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 70 "/usr/include/X11/X.h"
typedef unsigned long Mask;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 105 "/usr/include/X11/X.h"
typedef XID GContext;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 108 "/usr/include/X11/X.h"
typedef unsigned char KeyCode;
#line 145 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
typedef int ptrdiff_t;
#line 80 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 148 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 148 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 160 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExtCodes_897426155 {
   int extension ;
   int major_opcode ;
   int first_event ;
   int first_error ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExtCodes_897426155 XExtCodes;
#line 171 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPixmapFormatValues_582275743 {
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 171 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPixmapFormatValues_582275743 XPixmapFormatValues;
#line 181 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_48563222 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 181 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_48563222 XGCValues;
#line 214
struct _XGC ;
#line 214 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 227 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_1043007729 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 227 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_1043007729 Visual;
#line 243 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_253972742 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 243 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_253972742 Depth;
#line 255
struct _XDisplay ;
#line 257 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_1028754207 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 257 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_1028754207 Screen;
#line 280 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_231541112 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 280 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_231541112 ScreenFormat;
#line 290 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_781550119 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 290 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_781550119 XSetWindowAttributes;
#line 308 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_434820115 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 308 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_434820115 XWindowAttributes;
#line 341 "/usr/include/X11/Xlib.h"
struct __anonstruct_XHostAddress_478576807 {
   int family ;
   int length ;
   char *address ;
};
#line 341 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XHostAddress_478576807 XHostAddress;
#line 350 "/usr/include/X11/Xlib.h"
struct __anonstruct_XServerInterpretedAddress_967116238 {
   int typelength ;
   int valuelength ;
   char *type ;
   char *value ;
};
#line 350 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XServerInterpretedAddress_967116238 XServerInterpretedAddress;
#line 360 "/usr/include/X11/Xlib.h"
struct funcs {
   struct _XImage *(*create_image)(struct _XDisplay * , Visual * , unsigned int  ,
                                   int  , int  , char * , unsigned int  , unsigned int  ,
                                   int  , int  ) ;
   int (*destroy_image)(struct _XImage * ) ;
   unsigned long (*get_pixel)(struct _XImage * , int  , int  ) ;
   int (*put_pixel)(struct _XImage * , int  , int  , unsigned long  ) ;
   struct _XImage *(*sub_image)(struct _XImage * , int  , int  , unsigned int  , unsigned int  ) ;
   int (*add_pixel)(struct _XImage * , long  ) ;
};
#line 360 "/usr/include/X11/Xlib.h"
struct _XImage {
   int width ;
   int height ;
   int xoffset ;
   int format ;
   char *data ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_bit_order ;
   int bitmap_pad ;
   int depth ;
   int bytes_per_line ;
   int bits_per_pixel ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   XPointer obdata ;
   struct funcs f ;
};
#line 360 "/usr/include/X11/Xlib.h"
typedef struct _XImage XImage;
#line 399 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowChanges_401957784 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window sibling ;
   int stack_mode ;
};
#line 399 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowChanges_401957784 XWindowChanges;
#line 410 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_452238049 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 410 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_452238049 XColor;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSegment_25016377 {
   short x1 ;
   short y1 ;
   short x2 ;
   short y2 ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSegment_25016377 XSegment;
#line 426 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPoint_25016378 {
   short x ;
   short y ;
};
#line 426 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPoint_25016378 XPoint;
#line 430 "/usr/include/X11/Xlib.h"
struct __anonstruct_XRectangle_843929107 {
   short x ;
   short y ;
   unsigned short width ;
   unsigned short height ;
};
#line 430 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XRectangle_843929107 XRectangle;
#line 435 "/usr/include/X11/Xlib.h"
struct __anonstruct_XArc_343116347 {
   short x ;
   short y ;
   unsigned short width ;
   unsigned short height ;
   short angle1 ;
   short angle2 ;
};
#line 435 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XArc_343116347 XArc;
#line 444 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyboardControl_19145477 {
   int key_click_percent ;
   int bell_percent ;
   int bell_pitch ;
   int bell_duration ;
   int led ;
   int led_mode ;
   int key ;
   int auto_repeat_mode ;
};
#line 444 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyboardControl_19145477 XKeyboardControl;
#line 457 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyboardState_78158241 {
   int key_click_percent ;
   int bell_percent ;
   unsigned int bell_pitch ;
   unsigned int bell_duration ;
   unsigned long led_mask ;
   int global_auto_repeat ;
   char auto_repeats[32] ;
};
#line 457 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyboardState_78158241 XKeyboardState;
#line 468 "/usr/include/X11/Xlib.h"
struct __anonstruct_XTimeCoord_952324919 {
   Time time ;
   short x ;
   short y ;
};
#line 468 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XTimeCoord_952324919 XTimeCoord;
#line 475 "/usr/include/X11/Xlib.h"
struct __anonstruct_XModifierKeymap_439856431 {
   int max_keypermod ;
   KeyCode *modifiermap ;
};
#line 475 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XModifierKeymap_439856431 XModifierKeymap;
#line 487 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 490
struct _XPrivate ;
#line 491
struct _XrmHashBucketRec ;
#line 493 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_142170184 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 493 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_142170184 *_XPrivDisplay;
#line 557 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_539132468 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 557 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_539132468 XKeyEvent;
#line 572 "/usr/include/X11/Xlib.h"
typedef XKeyEvent XKeyPressedEvent;
#line 573 "/usr/include/X11/Xlib.h"
typedef XKeyEvent XKeyReleasedEvent;
#line 575 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_539132469 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 575 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_539132469 XButtonEvent;
#line 590 "/usr/include/X11/Xlib.h"
typedef XButtonEvent XButtonPressedEvent;
#line 591 "/usr/include/X11/Xlib.h"
typedef XButtonEvent XButtonReleasedEvent;
#line 593 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_761542621 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 593 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_761542621 XMotionEvent;
#line 608 "/usr/include/X11/Xlib.h"
typedef XMotionEvent XPointerMovedEvent;
#line 610 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_931299302 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 610 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_931299302 XCrossingEvent;
#line 631 "/usr/include/X11/Xlib.h"
typedef XCrossingEvent XEnterWindowEvent;
#line 632 "/usr/include/X11/Xlib.h"
typedef XCrossingEvent XLeaveWindowEvent;
#line 634 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_928561361 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 634 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_928561361 XFocusChangeEvent;
#line 649 "/usr/include/X11/Xlib.h"
typedef XFocusChangeEvent XFocusInEvent;
#line 650 "/usr/include/X11/Xlib.h"
typedef XFocusChangeEvent XFocusOutEvent;
#line 653 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_1018032483 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 653 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_1018032483 XKeymapEvent;
#line 662 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_243779916 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 662 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_243779916 XExposeEvent;
#line 673 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_683105012 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 673 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_683105012 XGraphicsExposeEvent;
#line 686 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_287833634 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 686 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_287833634 XNoExposeEvent;
#line 696 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_875659953 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 696 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_875659953 XVisibilityEvent;
#line 705 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_858555613 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 705 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_858555613 XCreateWindowEvent;
#line 718 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_690640112 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 718 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_690640112 XDestroyWindowEvent;
#line 727 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_964703214 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 727 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_964703214 XUnmapEvent;
#line 737 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_964703215 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 737 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_964703215 XMapEvent;
#line 747 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_964703216 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 747 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_964703216 XMapRequestEvent;
#line 756 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_825577104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 756 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_825577104 XReparentEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_381498350 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_381498350 XConfigureEvent;
#line 782 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_964703217 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 782 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_964703217 XGravityEvent;
#line 792 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_964703218 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 792 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_964703218 XResizeRequestEvent;
#line 801 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_951452228 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 801 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_951452228 XConfigureRequestEvent;
#line 816 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_964703219 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 816 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_964703219 XCirculateEvent;
#line 826 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_964703220 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 826 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_964703220 XCirculateRequestEvent;
#line 836 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_302529527 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 836 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_302529527 XPropertyEvent;
#line 847 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_580003272 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 847 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_580003272 XSelectionClearEvent;
#line 857 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_435630478 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 857 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_435630478 XSelectionRequestEvent;
#line 870 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_600652667 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 870 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_600652667 XSelectionEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_640581131 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_640581131 XColormapEvent;
#line 897 "/usr/include/X11/Xlib.h"
union __anonunion_data_51179373 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 897 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_1070971360 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_51179373 data ;
};
#line 897 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_1070971360 XClientMessageEvent;
#line 912 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_1070971361 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 912 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_1070971361 XMappingEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_992800826 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_992800826 XErrorEvent;
#line 934 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_676125185 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 934 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_676125185 XAnyEvent;
#line 948 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_1056705222 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 948 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_1056705222 XGenericEvent;
#line 958 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_135054216 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 958 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_135054216 XGenericEventCookie;
#line 973 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 973 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1017 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_1060023366 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1017 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_1060023366 XCharStruct;
#line 1030 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_809984170 {
   Atom name ;
   unsigned long card32 ;
};
#line 1030 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_809984170 XFontProp;
#line 1035 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_1181121 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1035 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_1181121 XFontStruct;
#line 1057 "/usr/include/X11/Xlib.h"
struct __anonstruct_XTextItem_757002657 {
   char *chars ;
   int nchars ;
   int delta ;
   Font font ;
};
#line 1057 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XTextItem_757002657 XTextItem;
#line 1064 "/usr/include/X11/Xlib.h"
struct __anonstruct_XChar2b_157313915 {
   unsigned char byte1 ;
   unsigned char byte2 ;
};
#line 1064 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XChar2b_157313915 XChar2b;
#line 1069 "/usr/include/X11/Xlib.h"
struct __anonstruct_XTextItem16_912088010 {
   XChar2b *chars ;
   int nchars ;
   int delta ;
   Font font ;
};
#line 1069 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XTextItem16_912088010 XTextItem16;
#line 1077 "/usr/include/X11/Xlib.h"
union __anonunion_XEDataObject_160618693 {
   Display *display ;
   GC gc ;
   Visual *visual ;
   Screen *screen ;
   ScreenFormat *pixmap_format ;
   XFontStruct *font ;
};
#line 1077 "/usr/include/X11/Xlib.h"
typedef union __anonunion_XEDataObject_160618693 XEDataObject;
#line 1084 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontSetExtents_707832071 {
   XRectangle max_ink_extent ;
   XRectangle max_logical_extent ;
};
#line 1084 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontSetExtents_707832071 XFontSetExtents;
#line 1093
struct _XOM ;
#line 1093 "/usr/include/X11/Xlib.h"
typedef struct _XOM *XOM;
#line 1094
struct _XOC ;
#line 1094 "/usr/include/X11/Xlib.h"
typedef struct _XOC *XOC;
#line 1094 "/usr/include/X11/Xlib.h"
typedef struct _XOC *XFontSet;
#line 1096 "/usr/include/X11/Xlib.h"
struct __anonstruct_XmbTextItem_634763290 {
   char *chars ;
   int nchars ;
   int delta ;
   XFontSet font_set ;
};
#line 1096 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XmbTextItem_634763290 XmbTextItem;
#line 1103 "/usr/include/X11/Xlib.h"
struct __anonstruct_XwcTextItem_705461812 {
   wchar_t *chars ;
   int nchars ;
   int delta ;
   XFontSet font_set ;
};
#line 1103 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XwcTextItem_705461812 XwcTextItem;
#line 1121 "/usr/include/X11/Xlib.h"
struct __anonstruct_XOMCharSetList_216488822 {
   int charset_count ;
   char **charset_list ;
};
#line 1121 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XOMCharSetList_216488822 XOMCharSetList;
#line 1126
enum __anonenum_XOrientation_172956481 {
    XOMOrientation_LTR_TTBXOMOrientation_LTR_TTB = 0,
    XOMOrientation_RTL_TTBXOMOrientation_RTL_TTB = 1,
    XOMOrientation_TTB_LTRXOMOrientation_TTB_LTR = 2,
    XOMOrientation_TTB_RTLXOMOrientation_TTB_RTL = 3,
    XOMOrientation_ContextXOMOrientation_Context = 4
} ;
#line 1126 "/usr/include/X11/Xlib.h"
typedef enum __anonenum_XOrientation_172956481 XOrientation;
#line 1134 "/usr/include/X11/Xlib.h"
struct __anonstruct_XOMOrientation_627520960 {
   int num_orientation ;
   XOrientation *orientation ;
};
#line 1134 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XOMOrientation_627520960 XOMOrientation;
#line 1139 "/usr/include/X11/Xlib.h"
struct __anonstruct_XOMFontInfo_1014488827 {
   int num_font ;
   XFontStruct **font_struct_list ;
   char **font_name_list ;
};
#line 1139 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XOMFontInfo_1014488827 XOMFontInfo;
#line 1145
struct _XIM ;
#line 1145 "/usr/include/X11/Xlib.h"
typedef struct _XIM *XIM;
#line 1146
struct _XIC ;
#line 1146 "/usr/include/X11/Xlib.h"
typedef struct _XIC *XIC;
#line 1148 "/usr/include/X11/Xlib.h"
typedef void (*XIMProc)(XIM  , XPointer  , XPointer  );
#line 1154 "/usr/include/X11/Xlib.h"
typedef int (*XICProc)(XIC  , XPointer  , XPointer  );
#line 1160 "/usr/include/X11/Xlib.h"
typedef void (*XIDProc)(Display * , XPointer  , XPointer  );
#line 1166 "/usr/include/X11/Xlib.h"
typedef unsigned long XIMStyle;
#line 1168 "/usr/include/X11/Xlib.h"
struct __anonstruct_XIMStyles_872085834 {
   unsigned short count_styles ;
   XIMStyle *supported_styles ;
};
#line 1168 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XIMStyles_872085834 XIMStyles;
#line 1233 "/usr/include/X11/Xlib.h"
typedef void *XVaNestedList;
#line 1235 "/usr/include/X11/Xlib.h"
struct __anonstruct_XIMCallback_781260077 {
   XPointer client_data ;
   void (*callback)(XIM  , XPointer  , XPointer  ) ;
};
#line 1235 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XIMCallback_781260077 XIMCallback;
#line 1240 "/usr/include/X11/Xlib.h"
struct __anonstruct_XICCallback_435313391 {
   XPointer client_data ;
   int (*callback)(XIC  , XPointer  , XPointer  ) ;
};
#line 1240 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XICCallback_435313391 XICCallback;
#line 1245 "/usr/include/X11/Xlib.h"
typedef unsigned long XIMFeedback;
#line 1257 "/usr/include/X11/Xlib.h"
union __anonunion_string_247629109 {
   char *multi_byte ;
   wchar_t *wide_char ;
};
#line 1257 "/usr/include/X11/Xlib.h"
struct _XIMText {
   unsigned short length ;
   XIMFeedback *feedback ;
   int encoding_is_wchar ;
   union __anonunion_string_247629109 string ;
};
#line 1257 "/usr/include/X11/Xlib.h"
typedef struct _XIMText XIMText;
#line 1267 "/usr/include/X11/Xlib.h"
typedef unsigned long XIMPreeditState;
#line 1273 "/usr/include/X11/Xlib.h"
struct _XIMPreeditStateNotifyCallbackStruct {
   XIMPreeditState state ;
};
#line 1273 "/usr/include/X11/Xlib.h"
typedef struct _XIMPreeditStateNotifyCallbackStruct XIMPreeditStateNotifyCallbackStruct;
#line 1277 "/usr/include/X11/Xlib.h"
typedef unsigned long XIMResetState;
#line 1282 "/usr/include/X11/Xlib.h"
typedef unsigned long XIMStringConversionFeedback;
#line 1291 "/usr/include/X11/Xlib.h"
union __anonunion_string_247629110 {
   char *mbs ;
   wchar_t *wcs ;
};
#line 1291 "/usr/include/X11/Xlib.h"
struct _XIMStringConversionText {
   unsigned short length ;
   XIMStringConversionFeedback *feedback ;
   int encoding_is_wchar ;
   union __anonunion_string_247629110 string ;
};
#line 1291 "/usr/include/X11/Xlib.h"
typedef struct _XIMStringConversionText XIMStringConversionText;
#line 1301 "/usr/include/X11/Xlib.h"
typedef unsigned short XIMStringConversionPosition;
#line 1303 "/usr/include/X11/Xlib.h"
typedef unsigned short XIMStringConversionType;
#line 1310 "/usr/include/X11/Xlib.h"
typedef unsigned short XIMStringConversionOperation;
#line 1315
enum __anonenum_XIMCaretDirection_292796504 {
    XIMForwardCharXIMForwardChar = 0,
    XIMBackwardCharXIMBackwardChar = 1,
    XIMForwardWordXIMForwardWord = 2,
    XIMBackwardWordXIMBackwardWord = 3,
    XIMCaretUpXIMCaretUp = 4,
    XIMCaretDownXIMCaretDown = 5,
    XIMNextLineXIMNextLine = 6,
    XIMPreviousLineXIMPreviousLine = 7,
    XIMLineStartXIMLineStart = 8,
    XIMLineEndXIMLineEnd = 9,
    XIMAbsolutePositionXIMAbsolutePosition = 10,
    XIMDontChangeXIMDontChange = 11
} ;
#line 1315 "/usr/include/X11/Xlib.h"
typedef enum __anonenum_XIMCaretDirection_292796504 XIMCaretDirection;
#line 1325 "/usr/include/X11/Xlib.h"
struct _XIMStringConversionCallbackStruct {
   XIMStringConversionPosition position ;
   XIMCaretDirection direction ;
   XIMStringConversionOperation operation ;
   unsigned short factor ;
   XIMStringConversionText *text ;
};
#line 1325 "/usr/include/X11/Xlib.h"
typedef struct _XIMStringConversionCallbackStruct XIMStringConversionCallbackStruct;
#line 1333 "/usr/include/X11/Xlib.h"
struct _XIMPreeditDrawCallbackStruct {
   int caret ;
   int chg_first ;
   int chg_length ;
   XIMText *text ;
};
#line 1333 "/usr/include/X11/Xlib.h"
typedef struct _XIMPreeditDrawCallbackStruct XIMPreeditDrawCallbackStruct;
#line 1340
enum __anonenum_XIMCaretStyle_676364800 {
    XIMIsInvisibleXIMIsInvisible = 0,
    XIMIsPrimaryXIMIsPrimary = 1,
    XIMIsSecondaryXIMIsSecondary = 2
} ;
#line 1340 "/usr/include/X11/Xlib.h"
typedef enum __anonenum_XIMCaretStyle_676364800 XIMCaretStyle;
#line 1346 "/usr/include/X11/Xlib.h"
struct _XIMPreeditCaretCallbackStruct {
   int position ;
   XIMCaretDirection direction ;
   XIMCaretStyle style ;
};
#line 1346 "/usr/include/X11/Xlib.h"
typedef struct _XIMPreeditCaretCallbackStruct XIMPreeditCaretCallbackStruct;
#line 1352
enum __anonenum_XIMStatusDataType_687507716 {
    XIMTextTypeXIMTextType = 0,
    XIMBitmapTypeXIMBitmapType = 1
} ;
#line 1352 "/usr/include/X11/Xlib.h"
typedef enum __anonenum_XIMStatusDataType_687507716 XIMStatusDataType;
#line 1357 "/usr/include/X11/Xlib.h"
union __anonunion_data_847948154 {
   XIMText *text ;
   Pixmap bitmap ;
};
#line 1357 "/usr/include/X11/Xlib.h"
struct _XIMStatusDrawCallbackStruct {
   XIMStatusDataType type ;
   union __anonunion_data_847948154 data ;
};
#line 1357 "/usr/include/X11/Xlib.h"
typedef struct _XIMStatusDrawCallbackStruct XIMStatusDrawCallbackStruct;
#line 1365 "/usr/include/X11/Xlib.h"
struct _XIMHotKeyTrigger {
   KeySym keysym ;
   int modifier ;
   int modifier_mask ;
};
#line 1365 "/usr/include/X11/Xlib.h"
typedef struct _XIMHotKeyTrigger XIMHotKeyTrigger;
#line 1371 "/usr/include/X11/Xlib.h"
struct _XIMHotKeyTriggers {
   int num_hot_key ;
   XIMHotKeyTrigger *key ;
};
#line 1371 "/usr/include/X11/Xlib.h"
typedef struct _XIMHotKeyTriggers XIMHotKeyTriggers;
#line 1376 "/usr/include/X11/Xlib.h"
typedef unsigned long XIMHotKeyState;
#line 1381 "/usr/include/X11/Xlib.h"
struct __anonstruct_XIMValuesList_116876337 {
   unsigned short count_values ;
   char **supported_values ;
};
#line 1381 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XIMValuesList_116876337 XIMValuesList;
#line 1847 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 1857 "/usr/include/X11/Xlib.h"
typedef int (*XIOErrorHandler)(Display * );
#line 1865 "/usr/include/X11/Xlib.h"
typedef void (*XIOErrorExitHandler)(Display * , void * );
#line 3963 "/usr/include/X11/Xlib.h"
typedef void (*XConnectionWatchProc)(Display * , XPointer  , int  , int  , XPointer * );
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_1070971362 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_464458872 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_1070971362 min_aspect ;
   struct __anonstruct_min_aspect_1070971362 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_464458872 XSizeHints;
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_1070986488 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_1070986488 XWMHints;
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_720178 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_720178 XTextProperty;
#line 174
enum __anonenum_XICCEncodingStyle_395029154 {
    XStringStyleXStringStyle = 0,
    XCompoundTextStyleXCompoundTextStyle = 1,
    XTextStyleXTextStyle = 2,
    XStdICCTextStyleXStdICCTextStyle = 3,
    XUTF8StringStyleXUTF8StringStyle = 4
} ;
#line 174 "/usr/include/X11/Xutil.h"
typedef enum __anonenum_XICCEncodingStyle_395029154 XICCEncodingStyle;
#line 183 "/usr/include/X11/Xutil.h"
struct __anonstruct_XIconSize_1070986489 {
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
};
#line 183 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XIconSize_1070986489 XIconSize;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_476363767 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_476363767 XClassHint;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 273
struct _XRegion ;
#line 273 "/usr/include/X11/Xutil.h"
typedef struct _XRegion *Region;
#line 287 "/usr/include/X11/Xutil.h"
struct __anonstruct_XVisualInfo_978511283 {
   Visual *visual ;
   VisualID visualid ;
   int screen ;
   int depth ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int colormap_size ;
   int bits_per_rgb ;
};
#line 287 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XVisualInfo_978511283 XVisualInfo;
#line 320 "/usr/include/X11/Xutil.h"
struct __anonstruct_XStandardColormap_185999813 {
   Colormap colormap ;
   unsigned long red_max ;
   unsigned long red_mult ;
   unsigned long green_max ;
   unsigned long green_mult ;
   unsigned long blue_max ;
   unsigned long blue_mult ;
   unsigned long base_pixel ;
   VisualID visualid ;
   XID killid ;
};
#line 320 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XStandardColormap_185999813 XStandardColormap;
#line 357 "/usr/include/X11/Xutil.h"
typedef int XContext;
#line 36 "/usr/include/X11/extensions/XShm.h"
typedef unsigned long ShmSeg;
#line 38 "/usr/include/X11/extensions/XShm.h"
struct __anonstruct_XShmCompletionEvent_282060815 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
   ShmSeg shmseg ;
   unsigned long offset ;
};
#line 38 "/usr/include/X11/extensions/XShm.h"
typedef struct __anonstruct_XShmCompletionEvent_282060815 XShmCompletionEvent;
#line 50 "/usr/include/X11/extensions/XShm.h"
struct __anonstruct_XShmSegmentInfo_357276616 {
   ShmSeg shmseg ;
   int shmid ;
   char *shmaddr ;
   int readOnly ;
};
#line 50 "/usr/include/X11/extensions/XShm.h"
typedef struct __anonstruct_XShmSegmentInfo_357276616 XShmSegmentInfo;
#line 26 "/usr/include/bits/types/struct_iovec.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 24 "/usr/include/bits/socket_type.h"
enum __socket_type {
    SOCK_STREAMSOCK_STREAM = 1,
    SOCK_DGRAMSOCK_DGRAM = 2,
    SOCK_RAWSOCK_RAW = 3,
    SOCK_RDMSOCK_RDM = 4,
    SOCK_SEQPACKETSOCK_SEQPACKET = 5,
    SOCK_DCCPSOCK_DCCP = 6,
    SOCK_PACKETSOCK_PACKET = 10,
    SOCK_CLOEXECSOCK_CLOEXEC = 524288,
    SOCK_NONBLOCKSOCK_NONBLOCK = 2048
} ;
#line 28 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 184 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
} __attribute__((__may_alias__)) ;
#line 197 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[(128UL - sizeof(unsigned short )) - sizeof(unsigned long )] ;
   unsigned long __ss_align ;
} __attribute__((__may_alias__)) ;
#line 206
enum __anonenum_1072026033 {
    MSG_OOBMSG_OOB = 1,
    MSG_PEEKMSG_PEEK = 2,
    MSG_DONTROUTEMSG_DONTROUTE = 4,
    MSG_CTRUNCMSG_CTRUNC = 8,
    MSG_PROXYMSG_PROXY = 16,
    MSG_TRUNCMSG_TRUNC = 32,
    MSG_DONTWAITMSG_DONTWAIT = 64,
    MSG_EORMSG_EOR = 128,
    MSG_WAITALLMSG_WAITALL = 256,
    MSG_FINMSG_FIN = 512,
    MSG_SYNMSG_SYN = 1024,
    MSG_CONFIRMMSG_CONFIRM = 2048,
    MSG_RSTMSG_RST = 4096,
    MSG_ERRQUEUEMSG_ERRQUEUE = 8192,
    MSG_NOSIGNALMSG_NOSIGNAL = 16384,
    MSG_MOREMSG_MORE = 32768,
    MSG_WAITFORONEMSG_WAITFORONE = 65536,
    MSG_BATCHMSG_BATCH = 262144,
    MSG_ZEROCOPYMSG_ZEROCOPY = 67108864,
    MSG_FASTOPENMSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXECMSG_CMSG_CLOEXEC = 1073741824
} ;
#line 263 "/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 281 "/usr/include/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 364
enum __anonenum_199289971 {
    SCM_RIGHTSSCM_RIGHTS = 1
} ;
#line 25 "/usr/include/linux/posix_types.h"
struct __anonstruct___kernel_fd_set_603278005 {
   unsigned long fds_bits[1024UL / (8UL * sizeof(long ))] ;
};
#line 25 "/usr/include/linux/posix_types.h"
typedef struct __anonstruct___kernel_fd_set_603278005 __kernel_fd_set;
#line 30 "/usr/include/linux/posix_types.h"
typedef void (*__kernel_sighandler_t)(int  );
#line 33 "/usr/include/linux/posix_types.h"
typedef int __kernel_key_t;
#line 34 "/usr/include/linux/posix_types.h"
typedef int __kernel_mqd_t;
#line 11 "/usr/include/asm/posix_types_32.h"
typedef unsigned short __kernel_mode_t;
#line 14 "/usr/include/asm/posix_types_32.h"
typedef unsigned short __kernel_ipc_pid_t;
#line 17 "/usr/include/asm/posix_types_32.h"
typedef unsigned short __kernel_uid_t;
#line 18 "/usr/include/asm/posix_types_32.h"
typedef unsigned short __kernel_gid_t;
#line 21 "/usr/include/asm/posix_types_32.h"
typedef unsigned short __kernel_old_dev_t;
#line 15 "/usr/include/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 16 "/usr/include/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 20 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_ino_t;
#line 28 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 41 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 45 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_daddr_t;
#line 49 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 50 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 54 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_uid_t __kernel_old_uid_t;
#line 55 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_gid_t __kernel_old_gid_t;
#line 68 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_size_t;
#line 69 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_ssize_t;
#line 70 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_ptrdiff_t;
#line 79 "/usr/include/asm-generic/posix_types.h"
struct __anonstruct___kernel_fsid_t_1072026034 {
   int val[2] ;
};
#line 79 "/usr/include/asm-generic/posix_types.h"
typedef struct __anonstruct___kernel_fsid_t_1072026034 __kernel_fsid_t;
#line 87 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 88 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 89 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_old_time_t;
#line 90 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 91 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_time64_t;
#line 92 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 93 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 94 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 95 "/usr/include/asm-generic/posix_types.h"
typedef char *__kernel_caddr_t;
#line 96 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_uid16_t;
#line 97 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_gid16_t;
#line 397 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 6 "/usr/include/bits/types/struct_osockaddr.h"
struct osockaddr {
   unsigned short sa_family ;
   unsigned char sa_data[14] ;
};
#line 41 "/usr/include/sys/socket.h"
enum __anonenum_606441560 {
    SHUT_RDSHUT_RD = 0,
    SHUT_WRSHUT_WR = 1,
    SHUT_RDWRSHUT_RDWR = 2
} ;
#line 24 "/usr/include/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 145 "/usr/include/bits/in.h"
struct ip_opts {
   struct in_addr ip_dst ;
   char ip_opts[40] ;
};
#line 152 "/usr/include/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 40 "/usr/include/netinet/in.h"
enum __anonenum_348530545 {
    IPPROTO_IPIPPROTO_IP = 0,
    IPPROTO_ICMPIPPROTO_ICMP = 1,
    IPPROTO_IGMPIPPROTO_IGMP = 2,
    IPPROTO_IPIPIPPROTO_IPIP = 4,
    IPPROTO_TCPIPPROTO_TCP = 6,
    IPPROTO_EGPIPPROTO_EGP = 8,
    IPPROTO_PUPIPPROTO_PUP = 12,
    IPPROTO_UDPIPPROTO_UDP = 17,
    IPPROTO_IDPIPPROTO_IDP = 22,
    IPPROTO_TPIPPROTO_TP = 29,
    IPPROTO_DCCPIPPROTO_DCCP = 33,
    IPPROTO_IPV6IPPROTO_IPV6 = 41,
    IPPROTO_RSVPIPPROTO_RSVP = 46,
    IPPROTO_GREIPPROTO_GRE = 47,
    IPPROTO_ESPIPPROTO_ESP = 50,
    IPPROTO_AHIPPROTO_AH = 51,
    IPPROTO_MTPIPPROTO_MTP = 92,
    IPPROTO_BEETPHIPPROTO_BEETPH = 94,
    IPPROTO_ENCAPIPPROTO_ENCAP = 98,
    IPPROTO_PIMIPPROTO_PIM = 103,
    IPPROTO_COMPIPPROTO_COMP = 108,
    IPPROTO_L2TPIPPROTO_L2TP = 115,
    IPPROTO_SCTPIPPROTO_SCTP = 132,
    IPPROTO_UDPLITEIPPROTO_UDPLITE = 136,
    IPPROTO_MPLSIPPROTO_MPLS = 137,
    IPPROTO_ETHERNETIPPROTO_ETHERNET = 143,
    IPPROTO_RAWIPPROTO_RAW = 255,
    IPPROTO_MPTCPIPPROTO_MPTCP = 262,
    IPPROTO_MAXIPPROTO_MAX = 263
} ;
#line 105
enum __anonenum_218739988 {
    IPPROTO_HOPOPTSIPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTINGIPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENTIPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6IPPROTO_ICMPV6 = 58,
    IPPROTO_NONEIPPROTO_NONE = 59,
    IPPROTO_DSTOPTSIPPROTO_DSTOPTS = 60,
    IPPROTO_MHIPPROTO_MH = 135
} ;
#line 125 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 128
enum __anonenum_662268580 {
    IPPORT_ECHOIPPORT_ECHO = 7,
    IPPORT_DISCARDIPPORT_DISCARD = 9,
    IPPORT_SYSTATIPPORT_SYSTAT = 11,
    IPPORT_DAYTIMEIPPORT_DAYTIME = 13,
    IPPORT_NETSTATIPPORT_NETSTAT = 15,
    IPPORT_FTPIPPORT_FTP = 21,
    IPPORT_TELNETIPPORT_TELNET = 23,
    IPPORT_SMTPIPPORT_SMTP = 25,
    IPPORT_TIMESERVERIPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVERIPPORT_NAMESERVER = 42,
    IPPORT_WHOISIPPORT_WHOIS = 43,
    IPPORT_MTPIPPORT_MTP = 57,
    IPPORT_TFTPIPPORT_TFTP = 69,
    IPPORT_RJEIPPORT_RJE = 77,
    IPPORT_FINGERIPPORT_FINGER = 79,
    IPPORT_TTYLINKIPPORT_TTYLINK = 87,
    IPPORT_SUPDUPIPPORT_SUPDUP = 95,
    IPPORT_EXECSERVERIPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVERIPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVERIPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVERIPPORT_EFSSERVER = 520,
    IPPORT_BIFFUDPIPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVERIPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVERIPPORT_ROUTESERVER = 520,
    IPPORT_RESERVEDIPPORT_RESERVED = 1024,
    IPPORT_USERRESERVEDIPPORT_USERRESERVED = 5000
} ;
#line 221 "/usr/include/netinet/in.h"
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 221 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
#line 247 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
} __attribute__((__may_alias__)) ;
#line 264 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
} __attribute__((__may_alias__)) ;
#line 276 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 286 "/usr/include/netinet/in.h"
struct ip_mreqn {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_address ;
   int imr_ifindex ;
};
#line 298 "/usr/include/netinet/in.h"
struct ip_mreq_source {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
   struct in_addr imr_sourceaddr ;
};
#line 313 "/usr/include/netinet/in.h"
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   unsigned int ipv6mr_interface ;
};
#line 325 "/usr/include/netinet/in.h"
struct group_req {
   uint32_t gr_interface ;
   struct sockaddr_storage gr_group ;
};
#line 334 "/usr/include/netinet/in.h"
struct group_source_req {
   uint32_t gsr_interface ;
   struct sockaddr_storage gsr_group ;
   struct sockaddr_storage gsr_source ;
};
#line 348 "/usr/include/netinet/in.h"
struct ip_msfilter {
   struct in_addr imsf_multiaddr ;
   struct in_addr imsf_interface ;
   uint32_t imsf_fmode ;
   uint32_t imsf_numsrc ;
   struct in_addr imsf_slist[1] ;
};
#line 369 "/usr/include/netinet/in.h"
struct group_filter {
   uint32_t gf_interface ;
   struct sockaddr_storage gf_group ;
   uint32_t gf_fmode ;
   uint32_t gf_numsrc ;
   struct sockaddr_storage gf_slist[1] ;
};
#line 35 "/usr/include/bits/siginfo-consts.h"
enum __anonenum_556971655___0 {
    SI_ASYNCNL___0SI_ASYNCNL___0 = -60,
    SI_DETHREAD___0SI_DETHREAD___0 = -7,
    SI_TKILL___0SI_TKILL___0 = -6,
    SI_SIGIO___0SI_SIGIO___0 = -5,
    SI_ASYNCIO___0SI_ASYNCIO___0 = -4,
    SI_MESGQ___0SI_MESGQ___0 = -3,
    SI_TIMER___0SI_TIMER___0 = -2,
    SI_QUEUE___0SI_QUEUE___0 = -1,
    SI_USER___0SI_USER___0 = 0,
    SI_KERNEL___0SI_KERNEL___0 = 128
} ;
#line 71
enum __anonenum_640648963___0 {
    ILL_ILLOPC___0ILL_ILLOPC___0 = 1,
    ILL_ILLOPN___0ILL_ILLOPN___0 = 2,
    ILL_ILLADR___0ILL_ILLADR___0 = 3,
    ILL_ILLTRP___0ILL_ILLTRP___0 = 4,
    ILL_PRVOPC___0ILL_PRVOPC___0 = 5,
    ILL_PRVREG___0ILL_PRVREG___0 = 6,
    ILL_COPROC___0ILL_COPROC___0 = 7,
    ILL_BADSTK___0ILL_BADSTK___0 = 8,
    ILL_BADIADDR___0ILL_BADIADDR___0 = 9
} ;
#line 94
enum __anonenum_457704180___0 {
    FPE_INTDIV___0FPE_INTDIV___0 = 1,
    FPE_INTOVF___0FPE_INTOVF___0 = 2,
    FPE_FLTDIV___0FPE_FLTDIV___0 = 3,
    FPE_FLTOVF___0FPE_FLTOVF___0 = 4,
    FPE_FLTUND___0FPE_FLTUND___0 = 5,
    FPE_FLTRES___0FPE_FLTRES___0 = 6,
    FPE_FLTINV___0FPE_FLTINV___0 = 7,
    FPE_FLTSUB___0FPE_FLTSUB___0 = 8,
    FPE_FLTUNK___0FPE_FLTUNK___0 = 14,
    FPE_CONDTRAP___0FPE_CONDTRAP___0 = 15
} ;
#line 119
enum __anonenum_850350928___0 {
    SEGV_MAPERR___0SEGV_MAPERR___0 = 1,
    SEGV_ACCERR___0SEGV_ACCERR___0 = 2,
    SEGV_BNDERR___0SEGV_BNDERR___0 = 3,
    SEGV_PKUERR___0SEGV_PKUERR___0 = 4,
    SEGV_ACCADI___0SEGV_ACCADI___0 = 5,
    SEGV_ADIDERR___0SEGV_ADIDERR___0 = 6,
    SEGV_ADIPERR___0SEGV_ADIPERR___0 = 7,
    SEGV_MTEAERR___0SEGV_MTEAERR___0 = 8,
    SEGV_MTESERR___0SEGV_MTESERR___0 = 9,
    SEGV_CPERR___0SEGV_CPERR___0 = 10
} ;
#line 144
enum __anonenum_1036286214___0 {
    BUS_ADRALN___0BUS_ADRALN___0 = 1,
    BUS_ADRERR___0BUS_ADRERR___0 = 2,
    BUS_OBJERR___0BUS_OBJERR___0 = 3,
    BUS_MCEERR_AR___0BUS_MCEERR_AR___0 = 4,
    BUS_MCEERR_AO___0BUS_MCEERR_AO___0 = 5
} ;
#line 178
enum __anonenum_23175539___0 {
    CLD_EXITED___0CLD_EXITED___0 = 1,
    CLD_KILLED___0CLD_KILLED___0 = 2,
    CLD_DUMPED___0CLD_DUMPED___0 = 3,
    CLD_TRAPPED___0CLD_TRAPPED___0 = 4,
    CLD_STOPPED___0CLD_STOPPED___0 = 5,
    CLD_CONTINUED___0CLD_CONTINUED___0 = 6
} ;
#line 195
enum __anonenum_111643124___0 {
    POLL_IN___0POLL_IN___0 = 1,
    POLL_OUT___0POLL_OUT___0 = 2,
    POLL_MSG___0POLL_MSG___0 = 3,
    POLL_ERR___0POLL_ERR___0 = 4,
    POLL_PRI___0POLL_PRI___0 = 5,
    POLL_HUP___0POLL_HUP___0 = 6
} ;
#line 27 "/usr/include/bits/sigevent-consts.h"
enum __anonenum_852341087___0 {
    SIGEV_SIGNAL___0SIGEV_SIGNAL___0 = 0,
    SIGEV_NONE___0SIGEV_NONE___0 = 1,
    SIGEV_THREAD___0SIGEV_THREAD___0 = 2,
    SIGEV_THREAD_ID___0SIGEV_THREAD_ID___0 = 4
} ;
#line 27 "/usr/include/bits/ss_flags.h"
enum __anonenum_57186863___0 {
    SS_ONSTACK___0SS_ONSTACK___0 = 1,
    SS_DISABLE___0SS_DISABLE___0 = 2
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___3 {
    VERSION___3VERSION___3 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___2 {
    ML_LABEL___2ML_LABEL___2 = 0,
    ML_THINGS___2ML_THINGS___2 = 1,
    ML_LINEDEFS___2ML_LINEDEFS___2 = 2,
    ML_SIDEDEFS___2ML_SIDEDEFS___2 = 3,
    ML_VERTEXES___2ML_VERTEXES___2 = 4,
    ML_SEGS___2ML_SEGS___2 = 5,
    ML_SSECTORS___2ML_SSECTORS___2 = 6,
    ML_NODES___2ML_NODES___2 = 7,
    ML_SECTORS___2ML_SECTORS___2 = 8,
    ML_REJECT___2ML_REJECT___2 = 9,
    ML_BLOCKMAP___2ML_BLOCKMAP___2 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___2 {
    FP_NAN___2FP_NAN___2 = 0,
    FP_INFINITE___2FP_INFINITE___2 = 1,
    FP_ZERO___2FP_ZERO___2 = 2,
    FP_SUBNORMAL___2FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2FP_NORMAL___2 = 4
} ;
#line 71 "r_defs.h"
struct __anonstruct_vertex_t_250850226 {
   fixed_t x ;
   fixed_t y ;
};
#line 71 "r_defs.h"
typedef struct __anonstruct_vertex_t_250850226 vertex_t;
#line 80
struct line_s ;
#line 88 "r_defs.h"
struct __anonstruct_degenmobj_t_948545096 {
   thinker_t thinker ;
   fixed_t x ;
   fixed_t y ;
   fixed_t z ;
};
#line 88 "r_defs.h"
typedef struct __anonstruct_degenmobj_t_948545096 degenmobj_t;
#line 101 "r_defs.h"
struct __anonstruct_sector_t_989966483 {
   fixed_t floorheight ;
   fixed_t ceilingheight ;
   short floorpic ;
   short ceilingpic ;
   short lightlevel ;
   short special ;
   short tag ;
   int soundtraversed ;
   mobj_t *soundtarget ;
   int blockbox[4] ;
   degenmobj_t soundorg ;
   int validcount ;
   mobj_t *thinglist ;
   void *specialdata ;
   int linecount ;
   struct line_s **lines ;
};
#line 101 "r_defs.h"
typedef struct __anonstruct_sector_t_989966483 sector_t;
#line 144 "r_defs.h"
struct __anonstruct_side_t_959374608 {
   fixed_t textureoffset ;
   fixed_t rowoffset ;
   short toptexture ;
   short bottomtexture ;
   short midtexture ;
   sector_t *sector ;
};
#line 144 "r_defs.h"
typedef struct __anonstruct_side_t_959374608 side_t;
#line 168
enum __anonenum_slopetype_t_1063414209 {
    ST_HORIZONTALST_HORIZONTAL = 0,
    ST_VERTICALST_VERTICAL = 1,
    ST_POSITIVEST_POSITIVE = 2,
    ST_NEGATIVEST_NEGATIVE = 3
} ;
#line 168 "r_defs.h"
typedef enum __anonenum_slopetype_t_1063414209 slopetype_t;
#line 179 "r_defs.h"
struct line_s {
   vertex_t *v1 ;
   vertex_t *v2 ;
   fixed_t dx ;
   fixed_t dy ;
   short flags ;
   short special ;
   short tag ;
   short sidenum[2] ;
   fixed_t bbox[4] ;
   slopetype_t slopetype ;
   sector_t *frontsector ;
   sector_t *backsector ;
   int validcount ;
   void *specialdata ;
};
#line 179 "r_defs.h"
typedef struct line_s line_t;
#line 227 "r_defs.h"
struct subsector_s {
   sector_t *sector ;
   short numlines ;
   short firstline ;
};
#line 227 "r_defs.h"
typedef struct subsector_s subsector_t;
#line 240 "r_defs.h"
struct __anonstruct_seg_t_265647821 {
   vertex_t *v1 ;
   vertex_t *v2 ;
   fixed_t offset ;
   angle_t angle ;
   side_t *sidedef ;
   line_t *linedef ;
   sector_t *frontsector ;
   sector_t *backsector ;
};
#line 240 "r_defs.h"
typedef struct __anonstruct_seg_t_265647821 seg_t;
#line 265 "r_defs.h"
struct __anonstruct_node_t_294178072 {
   fixed_t x ;
   fixed_t y ;
   fixed_t dx ;
   fixed_t dy ;
   fixed_t bbox[2][4] ;
   unsigned short children[2] ;
};
#line 265 "r_defs.h"
typedef struct __anonstruct_node_t_294178072 node_t;
#line 285 "r_defs.h"
struct __anonstruct_post_t_550296131 {
   byte topdelta ;
   byte length ;
};
#line 285 "r_defs.h"
typedef struct __anonstruct_post_t_550296131 post_t;
#line 292 "r_defs.h"
typedef post_t column_t;
#line 314 "r_defs.h"
typedef byte lighttable_t;
#line 322 "r_defs.h"
struct drawseg_s {
   seg_t *curline ;
   int x1 ;
   int x2 ;
   fixed_t scale1 ;
   fixed_t scale2 ;
   fixed_t scalestep ;
   int silhouette ;
   fixed_t bsilheight ;
   fixed_t tsilheight ;
   short *sprtopclip ;
   short *sprbottomclip ;
   short *maskedtexturecol ;
};
#line 322 "r_defs.h"
typedef struct drawseg_s drawseg_t;
#line 356 "r_defs.h"
struct __anonstruct_patch_t_182256734 {
   short width ;
   short height ;
   short leftoffset ;
   short topoffset ;
   int columnofs[8] ;
};
#line 356 "r_defs.h"
typedef struct __anonstruct_patch_t_182256734 patch_t;
#line 375 "r_defs.h"
struct vissprite_s {
   struct vissprite_s *prev ;
   struct vissprite_s *next ;
   int x1 ;
   int x2 ;
   fixed_t gx ;
   fixed_t gy ;
   fixed_t gz ;
   fixed_t gzt ;
   fixed_t startfrac ;
   fixed_t scale ;
   fixed_t xiscale ;
   fixed_t texturemid ;
   int patch ;
   lighttable_t *colormap ;
   int mobjflags ;
};
#line 375 "r_defs.h"
typedef struct vissprite_s vissprite_t;
#line 427 "r_defs.h"
struct __anonstruct_spriteframe_t_476658451 {
   boolean rotate ;
   short lump[8] ;
   byte flip[8] ;
};
#line 427 "r_defs.h"
typedef struct __anonstruct_spriteframe_t_476658451 spriteframe_t;
#line 448 "r_defs.h"
struct __anonstruct_spritedef_t_724750819 {
   int numframes ;
   spriteframe_t *spriteframes ;
};
#line 448 "r_defs.h"
typedef struct __anonstruct_spritedef_t_724750819 spritedef_t;
#line 460 "r_defs.h"
struct __anonstruct_visplane_t_443325719 {
   fixed_t height ;
   int picnum ;
   int lightlevel ;
   int minx ;
   int maxx ;
   byte pad1 ;
   byte top[320] ;
   byte pad2 ;
   byte pad3 ;
   byte bottom[320] ;
   byte pad4 ;
};
#line 460 "r_defs.h"
typedef struct __anonstruct_visplane_t_443325719 visplane_t;
#line 936 "i_video.c"
union __anonunion_pixel_695819067 {
   double d ;
   unsigned int u[2] ;
};
#line 206 "/usr/include/bits/socket.h"
enum __anonenum_1072026033___0 {
    MSG_OOB___0MSG_OOB___0 = 1,
    MSG_PEEK___0MSG_PEEK___0 = 2,
    MSG_DONTROUTE___0MSG_DONTROUTE___0 = 4,
    MSG_CTRUNC___0MSG_CTRUNC___0 = 8,
    MSG_PROXY___0MSG_PROXY___0 = 16,
    MSG_TRUNC___0MSG_TRUNC___0 = 32,
    MSG_DONTWAIT___0MSG_DONTWAIT___0 = 64,
    MSG_EOR___0MSG_EOR___0 = 128,
    MSG_WAITALL___0MSG_WAITALL___0 = 256,
    MSG_FIN___0MSG_FIN___0 = 512,
    MSG_SYN___0MSG_SYN___0 = 1024,
    MSG_CONFIRM___0MSG_CONFIRM___0 = 2048,
    MSG_RST___0MSG_RST___0 = 4096,
    MSG_ERRQUEUE___0MSG_ERRQUEUE___0 = 8192,
    MSG_NOSIGNAL___0MSG_NOSIGNAL___0 = 16384,
    MSG_MORE___0MSG_MORE___0 = 32768,
    MSG_WAITFORONE___0MSG_WAITFORONE___0 = 65536,
    MSG_BATCH___0MSG_BATCH___0 = 262144,
    MSG_ZEROCOPY___0MSG_ZEROCOPY___0 = 67108864,
    MSG_FASTOPEN___0MSG_FASTOPEN___0 = 536870912,
    MSG_CMSG_CLOEXEC___0MSG_CMSG_CLOEXEC___0 = 1073741824
} ;
#line 364
enum __anonenum_199289971___0 {
    SCM_RIGHTS___0SCM_RIGHTS___0 = 1
} ;
#line 41 "/usr/include/sys/socket.h"
enum __anonenum_606441560___0 {
    SHUT_RD___0SHUT_RD___0 = 0,
    SHUT_WR___0SHUT_WR___0 = 1,
    SHUT_RDWR___0SHUT_RDWR___0 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum_348530545___0 {
    IPPROTO_IP___0IPPROTO_IP___0 = 0,
    IPPROTO_ICMP___0IPPROTO_ICMP___0 = 1,
    IPPROTO_IGMP___0IPPROTO_IGMP___0 = 2,
    IPPROTO_IPIP___0IPPROTO_IPIP___0 = 4,
    IPPROTO_TCP___0IPPROTO_TCP___0 = 6,
    IPPROTO_EGP___0IPPROTO_EGP___0 = 8,
    IPPROTO_PUP___0IPPROTO_PUP___0 = 12,
    IPPROTO_UDP___0IPPROTO_UDP___0 = 17,
    IPPROTO_IDP___0IPPROTO_IDP___0 = 22,
    IPPROTO_TP___0IPPROTO_TP___0 = 29,
    IPPROTO_DCCP___0IPPROTO_DCCP___0 = 33,
    IPPROTO_IPV6___0IPPROTO_IPV6___0 = 41,
    IPPROTO_RSVP___0IPPROTO_RSVP___0 = 46,
    IPPROTO_GRE___0IPPROTO_GRE___0 = 47,
    IPPROTO_ESP___0IPPROTO_ESP___0 = 50,
    IPPROTO_AH___0IPPROTO_AH___0 = 51,
    IPPROTO_MTP___0IPPROTO_MTP___0 = 92,
    IPPROTO_BEETPH___0IPPROTO_BEETPH___0 = 94,
    IPPROTO_ENCAP___0IPPROTO_ENCAP___0 = 98,
    IPPROTO_PIM___0IPPROTO_PIM___0 = 103,
    IPPROTO_COMP___0IPPROTO_COMP___0 = 108,
    IPPROTO_L2TP___0IPPROTO_L2TP___0 = 115,
    IPPROTO_SCTP___0IPPROTO_SCTP___0 = 132,
    IPPROTO_UDPLITE___0IPPROTO_UDPLITE___0 = 136,
    IPPROTO_MPLS___0IPPROTO_MPLS___0 = 137,
    IPPROTO_ETHERNET___0IPPROTO_ETHERNET___0 = 143,
    IPPROTO_RAW___0IPPROTO_RAW___0 = 255,
    IPPROTO_MPTCP___0IPPROTO_MPTCP___0 = 262,
    IPPROTO_MAX___0IPPROTO_MAX___0 = 263
} ;
#line 105
enum __anonenum_218739988___0 {
    IPPROTO_HOPOPTS___0IPPROTO_HOPOPTS___0 = 0,
    IPPROTO_ROUTING___0IPPROTO_ROUTING___0 = 43,
    IPPROTO_FRAGMENT___0IPPROTO_FRAGMENT___0 = 44,
    IPPROTO_ICMPV6___0IPPROTO_ICMPV6___0 = 58,
    IPPROTO_NONE___0IPPROTO_NONE___0 = 59,
    IPPROTO_DSTOPTS___0IPPROTO_DSTOPTS___0 = 60,
    IPPROTO_MH___0IPPROTO_MH___0 = 135
} ;
#line 128
enum __anonenum_662268580___0 {
    IPPORT_ECHO___0IPPORT_ECHO___0 = 7,
    IPPORT_DISCARD___0IPPORT_DISCARD___0 = 9,
    IPPORT_SYSTAT___0IPPORT_SYSTAT___0 = 11,
    IPPORT_DAYTIME___0IPPORT_DAYTIME___0 = 13,
    IPPORT_NETSTAT___0IPPORT_NETSTAT___0 = 15,
    IPPORT_FTP___0IPPORT_FTP___0 = 21,
    IPPORT_TELNET___0IPPORT_TELNET___0 = 23,
    IPPORT_SMTP___0IPPORT_SMTP___0 = 25,
    IPPORT_TIMESERVER___0IPPORT_TIMESERVER___0 = 37,
    IPPORT_NAMESERVER___0IPPORT_NAMESERVER___0 = 42,
    IPPORT_WHOIS___0IPPORT_WHOIS___0 = 43,
    IPPORT_MTP___0IPPORT_MTP___0 = 57,
    IPPORT_TFTP___0IPPORT_TFTP___0 = 69,
    IPPORT_RJE___0IPPORT_RJE___0 = 77,
    IPPORT_FINGER___0IPPORT_FINGER___0 = 79,
    IPPORT_TTYLINK___0IPPORT_TTYLINK___0 = 87,
    IPPORT_SUPDUP___0IPPORT_SUPDUP___0 = 95,
    IPPORT_EXECSERVER___0IPPORT_EXECSERVER___0 = 512,
    IPPORT_LOGINSERVER___0IPPORT_LOGINSERVER___0 = 513,
    IPPORT_CMDSERVER___0IPPORT_CMDSERVER___0 = 514,
    IPPORT_EFSSERVER___0IPPORT_EFSSERVER___0 = 520,
    IPPORT_BIFFUDP___0IPPORT_BIFFUDP___0 = 512,
    IPPORT_WHOSERVER___0IPPORT_WHOSERVER___0 = 513,
    IPPORT_ROUTESERVER___0IPPORT_ROUTESERVER___0 = 520,
    IPPORT_RESERVED___0IPPORT_RESERVED___0 = 1024,
    IPPORT_USERRESERVED___0IPPORT_USERRESERVED___0 = 5000
} ;
#line 24 "/usr/include/bits/confname.h"
enum __anonenum_437032235___2 {
    _PC_LINK_MAX___2_PC_LINK_MAX___2 = 0,
    _PC_MAX_CANON___2_PC_MAX_CANON___2 = 1,
    _PC_MAX_INPUT___2_PC_MAX_INPUT___2 = 2,
    _PC_NAME_MAX___2_PC_NAME_MAX___2 = 3,
    _PC_PATH_MAX___2_PC_PATH_MAX___2 = 4,
    _PC_PIPE_BUF___2_PC_PIPE_BUF___2 = 5,
    _PC_CHOWN_RESTRICTED___2_PC_CHOWN_RESTRICTED___2 = 6,
    _PC_NO_TRUNC___2_PC_NO_TRUNC___2 = 7,
    _PC_VDISABLE___2_PC_VDISABLE___2 = 8,
    _PC_SYNC_IO___2_PC_SYNC_IO___2 = 9,
    _PC_ASYNC_IO___2_PC_ASYNC_IO___2 = 10,
    _PC_PRIO_IO___2_PC_PRIO_IO___2 = 11,
    _PC_SOCK_MAXBUF___2_PC_SOCK_MAXBUF___2 = 12,
    _PC_FILESIZEBITS___2_PC_FILESIZEBITS___2 = 13,
    _PC_REC_INCR_XFER_SIZE___2_PC_REC_INCR_XFER_SIZE___2 = 14,
    _PC_REC_MAX_XFER_SIZE___2_PC_REC_MAX_XFER_SIZE___2 = 15,
    _PC_REC_MIN_XFER_SIZE___2_PC_REC_MIN_XFER_SIZE___2 = 16,
    _PC_REC_XFER_ALIGN___2_PC_REC_XFER_ALIGN___2 = 17,
    _PC_ALLOC_SIZE_MIN___2_PC_ALLOC_SIZE_MIN___2 = 18,
    _PC_SYMLINK_MAX___2_PC_SYMLINK_MAX___2 = 19,
    _PC_2_SYMLINKS___2_PC_2_SYMLINKS___2 = 20
} ;
#line 71
enum __anonenum_315186338___2 {
    _SC_ARG_MAX___2_SC_ARG_MAX___2 = 0,
    _SC_CHILD_MAX___2_SC_CHILD_MAX___2 = 1,
    _SC_CLK_TCK___2_SC_CLK_TCK___2 = 2,
    _SC_NGROUPS_MAX___2_SC_NGROUPS_MAX___2 = 3,
    _SC_OPEN_MAX___2_SC_OPEN_MAX___2 = 4,
    _SC_STREAM_MAX___2_SC_STREAM_MAX___2 = 5,
    _SC_TZNAME_MAX___2_SC_TZNAME_MAX___2 = 6,
    _SC_JOB_CONTROL___2_SC_JOB_CONTROL___2 = 7,
    _SC_SAVED_IDS___2_SC_SAVED_IDS___2 = 8,
    _SC_REALTIME_SIGNALS___2_SC_REALTIME_SIGNALS___2 = 9,
    _SC_PRIORITY_SCHEDULING___2_SC_PRIORITY_SCHEDULING___2 = 10,
    _SC_TIMERS___2_SC_TIMERS___2 = 11,
    _SC_ASYNCHRONOUS_IO___2_SC_ASYNCHRONOUS_IO___2 = 12,
    _SC_PRIORITIZED_IO___2_SC_PRIORITIZED_IO___2 = 13,
    _SC_SYNCHRONIZED_IO___2_SC_SYNCHRONIZED_IO___2 = 14,
    _SC_FSYNC___2_SC_FSYNC___2 = 15,
    _SC_MAPPED_FILES___2_SC_MAPPED_FILES___2 = 16,
    _SC_MEMLOCK___2_SC_MEMLOCK___2 = 17,
    _SC_MEMLOCK_RANGE___2_SC_MEMLOCK_RANGE___2 = 18,
    _SC_MEMORY_PROTECTION___2_SC_MEMORY_PROTECTION___2 = 19,
    _SC_MESSAGE_PASSING___2_SC_MESSAGE_PASSING___2 = 20,
    _SC_SEMAPHORES___2_SC_SEMAPHORES___2 = 21,
    _SC_SHARED_MEMORY_OBJECTS___2_SC_SHARED_MEMORY_OBJECTS___2 = 22,
    _SC_AIO_LISTIO_MAX___2_SC_AIO_LISTIO_MAX___2 = 23,
    _SC_AIO_MAX___2_SC_AIO_MAX___2 = 24,
    _SC_AIO_PRIO_DELTA_MAX___2_SC_AIO_PRIO_DELTA_MAX___2 = 25,
    _SC_DELAYTIMER_MAX___2_SC_DELAYTIMER_MAX___2 = 26,
    _SC_MQ_OPEN_MAX___2_SC_MQ_OPEN_MAX___2 = 27,
    _SC_MQ_PRIO_MAX___2_SC_MQ_PRIO_MAX___2 = 28,
    _SC_VERSION___2_SC_VERSION___2 = 29,
    _SC_PAGESIZE___2_SC_PAGESIZE___2 = 30,
    _SC_RTSIG_MAX___2_SC_RTSIG_MAX___2 = 31,
    _SC_SEM_NSEMS_MAX___2_SC_SEM_NSEMS_MAX___2 = 32,
    _SC_SEM_VALUE_MAX___2_SC_SEM_VALUE_MAX___2 = 33,
    _SC_SIGQUEUE_MAX___2_SC_SIGQUEUE_MAX___2 = 34,
    _SC_TIMER_MAX___2_SC_TIMER_MAX___2 = 35,
    _SC_BC_BASE_MAX___2_SC_BC_BASE_MAX___2 = 36,
    _SC_BC_DIM_MAX___2_SC_BC_DIM_MAX___2 = 37,
    _SC_BC_SCALE_MAX___2_SC_BC_SCALE_MAX___2 = 38,
    _SC_BC_STRING_MAX___2_SC_BC_STRING_MAX___2 = 39,
    _SC_COLL_WEIGHTS_MAX___2_SC_COLL_WEIGHTS_MAX___2 = 40,
    _SC_EQUIV_CLASS_MAX___2_SC_EQUIV_CLASS_MAX___2 = 41,
    _SC_EXPR_NEST_MAX___2_SC_EXPR_NEST_MAX___2 = 42,
    _SC_LINE_MAX___2_SC_LINE_MAX___2 = 43,
    _SC_RE_DUP_MAX___2_SC_RE_DUP_MAX___2 = 44,
    _SC_CHARCLASS_NAME_MAX___2_SC_CHARCLASS_NAME_MAX___2 = 45,
    _SC_2_VERSION___2_SC_2_VERSION___2 = 46,
    _SC_2_C_BIND___2_SC_2_C_BIND___2 = 47,
    _SC_2_C_DEV___2_SC_2_C_DEV___2 = 48,
    _SC_2_FORT_DEV___2_SC_2_FORT_DEV___2 = 49,
    _SC_2_FORT_RUN___2_SC_2_FORT_RUN___2 = 50,
    _SC_2_SW_DEV___2_SC_2_SW_DEV___2 = 51,
    _SC_2_LOCALEDEF___2_SC_2_LOCALEDEF___2 = 52,
    _SC_PII___2_SC_PII___2 = 53,
    _SC_PII_XTI___2_SC_PII_XTI___2 = 54,
    _SC_PII_SOCKET___2_SC_PII_SOCKET___2 = 55,
    _SC_PII_INTERNET___2_SC_PII_INTERNET___2 = 56,
    _SC_PII_OSI___2_SC_PII_OSI___2 = 57,
    _SC_POLL___2_SC_POLL___2 = 58,
    _SC_SELECT___2_SC_SELECT___2 = 59,
    _SC_UIO_MAXIOV___2_SC_UIO_MAXIOV___2 = 60,
    _SC_IOV_MAX___2_SC_IOV_MAX___2 = 60,
    _SC_PII_INTERNET_STREAM___2_SC_PII_INTERNET_STREAM___2 = 61,
    _SC_PII_INTERNET_DGRAM___2_SC_PII_INTERNET_DGRAM___2 = 62,
    _SC_PII_OSI_COTS___2_SC_PII_OSI_COTS___2 = 63,
    _SC_PII_OSI_CLTS___2_SC_PII_OSI_CLTS___2 = 64,
    _SC_PII_OSI_M___2_SC_PII_OSI_M___2 = 65,
    _SC_T_IOV_MAX___2_SC_T_IOV_MAX___2 = 66,
    _SC_THREADS___2_SC_THREADS___2 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___2_SC_THREAD_SAFE_FUNCTIONS___2 = 68,
    _SC_GETGR_R_SIZE_MAX___2_SC_GETGR_R_SIZE_MAX___2 = 69,
    _SC_GETPW_R_SIZE_MAX___2_SC_GETPW_R_SIZE_MAX___2 = 70,
    _SC_LOGIN_NAME_MAX___2_SC_LOGIN_NAME_MAX___2 = 71,
    _SC_TTY_NAME_MAX___2_SC_TTY_NAME_MAX___2 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___2_SC_THREAD_DESTRUCTOR_ITERATIONS___2 = 73,
    _SC_THREAD_KEYS_MAX___2_SC_THREAD_KEYS_MAX___2 = 74,
    _SC_THREAD_STACK_MIN___2_SC_THREAD_STACK_MIN___2 = 75,
    _SC_THREAD_THREADS_MAX___2_SC_THREAD_THREADS_MAX___2 = 76,
    _SC_THREAD_ATTR_STACKADDR___2_SC_THREAD_ATTR_STACKADDR___2 = 77,
    _SC_THREAD_ATTR_STACKSIZE___2_SC_THREAD_ATTR_STACKSIZE___2 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___2_SC_THREAD_PRIORITY_SCHEDULING___2 = 79,
    _SC_THREAD_PRIO_INHERIT___2_SC_THREAD_PRIO_INHERIT___2 = 80,
    _SC_THREAD_PRIO_PROTECT___2_SC_THREAD_PRIO_PROTECT___2 = 81,
    _SC_THREAD_PROCESS_SHARED___2_SC_THREAD_PROCESS_SHARED___2 = 82,
    _SC_NPROCESSORS_CONF___2_SC_NPROCESSORS_CONF___2 = 83,
    _SC_NPROCESSORS_ONLN___2_SC_NPROCESSORS_ONLN___2 = 84,
    _SC_PHYS_PAGES___2_SC_PHYS_PAGES___2 = 85,
    _SC_AVPHYS_PAGES___2_SC_AVPHYS_PAGES___2 = 86,
    _SC_ATEXIT_MAX___2_SC_ATEXIT_MAX___2 = 87,
    _SC_PASS_MAX___2_SC_PASS_MAX___2 = 88,
    _SC_XOPEN_VERSION___2_SC_XOPEN_VERSION___2 = 89,
    _SC_XOPEN_XCU_VERSION___2_SC_XOPEN_XCU_VERSION___2 = 90,
    _SC_XOPEN_UNIX___2_SC_XOPEN_UNIX___2 = 91,
    _SC_XOPEN_CRYPT___2_SC_XOPEN_CRYPT___2 = 92,
    _SC_XOPEN_ENH_I18N___2_SC_XOPEN_ENH_I18N___2 = 93,
    _SC_XOPEN_SHM___2_SC_XOPEN_SHM___2 = 94,
    _SC_2_CHAR_TERM___2_SC_2_CHAR_TERM___2 = 95,
    _SC_2_C_VERSION___2_SC_2_C_VERSION___2 = 96,
    _SC_2_UPE___2_SC_2_UPE___2 = 97,
    _SC_XOPEN_XPG2___2_SC_XOPEN_XPG2___2 = 98,
    _SC_XOPEN_XPG3___2_SC_XOPEN_XPG3___2 = 99,
    _SC_XOPEN_XPG4___2_SC_XOPEN_XPG4___2 = 100,
    _SC_CHAR_BIT___2_SC_CHAR_BIT___2 = 101,
    _SC_CHAR_MAX___2_SC_CHAR_MAX___2 = 102,
    _SC_CHAR_MIN___2_SC_CHAR_MIN___2 = 103,
    _SC_INT_MAX___2_SC_INT_MAX___2 = 104,
    _SC_INT_MIN___2_SC_INT_MIN___2 = 105,
    _SC_LONG_BIT___2_SC_LONG_BIT___2 = 106,
    _SC_WORD_BIT___2_SC_WORD_BIT___2 = 107,
    _SC_MB_LEN_MAX___2_SC_MB_LEN_MAX___2 = 108,
    _SC_NZERO___2_SC_NZERO___2 = 109,
    _SC_SSIZE_MAX___2_SC_SSIZE_MAX___2 = 110,
    _SC_SCHAR_MAX___2_SC_SCHAR_MAX___2 = 111,
    _SC_SCHAR_MIN___2_SC_SCHAR_MIN___2 = 112,
    _SC_SHRT_MAX___2_SC_SHRT_MAX___2 = 113,
    _SC_SHRT_MIN___2_SC_SHRT_MIN___2 = 114,
    _SC_UCHAR_MAX___2_SC_UCHAR_MAX___2 = 115,
    _SC_UINT_MAX___2_SC_UINT_MAX___2 = 116,
    _SC_ULONG_MAX___2_SC_ULONG_MAX___2 = 117,
    _SC_USHRT_MAX___2_SC_USHRT_MAX___2 = 118,
    _SC_NL_ARGMAX___2_SC_NL_ARGMAX___2 = 119,
    _SC_NL_LANGMAX___2_SC_NL_LANGMAX___2 = 120,
    _SC_NL_MSGMAX___2_SC_NL_MSGMAX___2 = 121,
    _SC_NL_NMAX___2_SC_NL_NMAX___2 = 122,
    _SC_NL_SETMAX___2_SC_NL_SETMAX___2 = 123,
    _SC_NL_TEXTMAX___2_SC_NL_TEXTMAX___2 = 124,
    _SC_XBS5_ILP32_OFF32___2_SC_XBS5_ILP32_OFF32___2 = 125,
    _SC_XBS5_ILP32_OFFBIG___2_SC_XBS5_ILP32_OFFBIG___2 = 126,
    _SC_XBS5_LP64_OFF64___2_SC_XBS5_LP64_OFF64___2 = 127,
    _SC_XBS5_LPBIG_OFFBIG___2_SC_XBS5_LPBIG_OFFBIG___2 = 128,
    _SC_XOPEN_LEGACY___2_SC_XOPEN_LEGACY___2 = 129,
    _SC_XOPEN_REALTIME___2_SC_XOPEN_REALTIME___2 = 130,
    _SC_XOPEN_REALTIME_THREADS___2_SC_XOPEN_REALTIME_THREADS___2 = 131,
    _SC_ADVISORY_INFO___2_SC_ADVISORY_INFO___2 = 132,
    _SC_BARRIERS___2_SC_BARRIERS___2 = 133,
    _SC_BASE___2_SC_BASE___2 = 134,
    _SC_C_LANG_SUPPORT___2_SC_C_LANG_SUPPORT___2 = 135,
    _SC_C_LANG_SUPPORT_R___2_SC_C_LANG_SUPPORT_R___2 = 136,
    _SC_CLOCK_SELECTION___2_SC_CLOCK_SELECTION___2 = 137,
    _SC_CPUTIME___2_SC_CPUTIME___2 = 138,
    _SC_THREAD_CPUTIME___2_SC_THREAD_CPUTIME___2 = 139,
    _SC_DEVICE_IO___2_SC_DEVICE_IO___2 = 140,
    _SC_DEVICE_SPECIFIC___2_SC_DEVICE_SPECIFIC___2 = 141,
    _SC_DEVICE_SPECIFIC_R___2_SC_DEVICE_SPECIFIC_R___2 = 142,
    _SC_FD_MGMT___2_SC_FD_MGMT___2 = 143,
    _SC_FIFO___2_SC_FIFO___2 = 144,
    _SC_PIPE___2_SC_PIPE___2 = 145,
    _SC_FILE_ATTRIBUTES___2_SC_FILE_ATTRIBUTES___2 = 146,
    _SC_FILE_LOCKING___2_SC_FILE_LOCKING___2 = 147,
    _SC_FILE_SYSTEM___2_SC_FILE_SYSTEM___2 = 148,
    _SC_MONOTONIC_CLOCK___2_SC_MONOTONIC_CLOCK___2 = 149,
    _SC_MULTI_PROCESS___2_SC_MULTI_PROCESS___2 = 150,
    _SC_SINGLE_PROCESS___2_SC_SINGLE_PROCESS___2 = 151,
    _SC_NETWORKING___2_SC_NETWORKING___2 = 152,
    _SC_READER_WRITER_LOCKS___2_SC_READER_WRITER_LOCKS___2 = 153,
    _SC_SPIN_LOCKS___2_SC_SPIN_LOCKS___2 = 154,
    _SC_REGEXP___2_SC_REGEXP___2 = 155,
    _SC_REGEX_VERSION___2_SC_REGEX_VERSION___2 = 156,
    _SC_SHELL___2_SC_SHELL___2 = 157,
    _SC_SIGNALS___2_SC_SIGNALS___2 = 158,
    _SC_SPAWN___2_SC_SPAWN___2 = 159,
    _SC_SPORADIC_SERVER___2_SC_SPORADIC_SERVER___2 = 160,
    _SC_THREAD_SPORADIC_SERVER___2_SC_THREAD_SPORADIC_SERVER___2 = 161,
    _SC_SYSTEM_DATABASE___2_SC_SYSTEM_DATABASE___2 = 162,
    _SC_SYSTEM_DATABASE_R___2_SC_SYSTEM_DATABASE_R___2 = 163,
    _SC_TIMEOUTS___2_SC_TIMEOUTS___2 = 164,
    _SC_TYPED_MEMORY_OBJECTS___2_SC_TYPED_MEMORY_OBJECTS___2 = 165,
    _SC_USER_GROUPS___2_SC_USER_GROUPS___2 = 166,
    _SC_USER_GROUPS_R___2_SC_USER_GROUPS_R___2 = 167,
    _SC_2_PBS___2_SC_2_PBS___2 = 168,
    _SC_2_PBS_ACCOUNTING___2_SC_2_PBS_ACCOUNTING___2 = 169,
    _SC_2_PBS_LOCATE___2_SC_2_PBS_LOCATE___2 = 170,
    _SC_2_PBS_MESSAGE___2_SC_2_PBS_MESSAGE___2 = 171,
    _SC_2_PBS_TRACK___2_SC_2_PBS_TRACK___2 = 172,
    _SC_SYMLOOP_MAX___2_SC_SYMLOOP_MAX___2 = 173,
    _SC_STREAMS___2_SC_STREAMS___2 = 174,
    _SC_2_PBS_CHECKPOINT___2_SC_2_PBS_CHECKPOINT___2 = 175,
    _SC_V6_ILP32_OFF32___2_SC_V6_ILP32_OFF32___2 = 176,
    _SC_V6_ILP32_OFFBIG___2_SC_V6_ILP32_OFFBIG___2 = 177,
    _SC_V6_LP64_OFF64___2_SC_V6_LP64_OFF64___2 = 178,
    _SC_V6_LPBIG_OFFBIG___2_SC_V6_LPBIG_OFFBIG___2 = 179,
    _SC_HOST_NAME_MAX___2_SC_HOST_NAME_MAX___2 = 180,
    _SC_TRACE___2_SC_TRACE___2 = 181,
    _SC_TRACE_EVENT_FILTER___2_SC_TRACE_EVENT_FILTER___2 = 182,
    _SC_TRACE_INHERIT___2_SC_TRACE_INHERIT___2 = 183,
    _SC_TRACE_LOG___2_SC_TRACE_LOG___2 = 184,
    _SC_LEVEL1_ICACHE_SIZE___2_SC_LEVEL1_ICACHE_SIZE___2 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___2_SC_LEVEL1_ICACHE_ASSOC___2 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___2_SC_LEVEL1_ICACHE_LINESIZE___2 = 187,
    _SC_LEVEL1_DCACHE_SIZE___2_SC_LEVEL1_DCACHE_SIZE___2 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___2_SC_LEVEL1_DCACHE_ASSOC___2 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___2_SC_LEVEL1_DCACHE_LINESIZE___2 = 190,
    _SC_LEVEL2_CACHE_SIZE___2_SC_LEVEL2_CACHE_SIZE___2 = 191,
    _SC_LEVEL2_CACHE_ASSOC___2_SC_LEVEL2_CACHE_ASSOC___2 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___2_SC_LEVEL2_CACHE_LINESIZE___2 = 193,
    _SC_LEVEL3_CACHE_SIZE___2_SC_LEVEL3_CACHE_SIZE___2 = 194,
    _SC_LEVEL3_CACHE_ASSOC___2_SC_LEVEL3_CACHE_ASSOC___2 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___2_SC_LEVEL3_CACHE_LINESIZE___2 = 196,
    _SC_LEVEL4_CACHE_SIZE___2_SC_LEVEL4_CACHE_SIZE___2 = 197,
    _SC_LEVEL4_CACHE_ASSOC___2_SC_LEVEL4_CACHE_ASSOC___2 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___2_SC_LEVEL4_CACHE_LINESIZE___2 = 199,
    _SC_IPV6___2_SC_IPV6___2 = 235,
    _SC_RAW_SOCKETS___2_SC_RAW_SOCKETS___2 = 236,
    _SC_V7_ILP32_OFF32___2_SC_V7_ILP32_OFF32___2 = 237,
    _SC_V7_ILP32_OFFBIG___2_SC_V7_ILP32_OFFBIG___2 = 238,
    _SC_V7_LP64_OFF64___2_SC_V7_LP64_OFF64___2 = 239,
    _SC_V7_LPBIG_OFFBIG___2_SC_V7_LPBIG_OFFBIG___2 = 240,
    _SC_SS_REPL_MAX___2_SC_SS_REPL_MAX___2 = 241,
    _SC_TRACE_EVENT_NAME_MAX___2_SC_TRACE_EVENT_NAME_MAX___2 = 242,
    _SC_TRACE_NAME_MAX___2_SC_TRACE_NAME_MAX___2 = 243,
    _SC_TRACE_SYS_MAX___2_SC_TRACE_SYS_MAX___2 = 244,
    _SC_TRACE_USER_EVENT_MAX___2_SC_TRACE_USER_EVENT_MAX___2 = 245,
    _SC_XOPEN_STREAMS___2_SC_XOPEN_STREAMS___2 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___2_SC_THREAD_ROBUST_PRIO_INHERIT___2 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___2_SC_THREAD_ROBUST_PRIO_PROTECT___2 = 248,
    _SC_MINSIGSTKSZ___2_SC_MINSIGSTKSZ___2 = 249,
    _SC_SIGSTKSZ___2_SC_SIGSTKSZ___2 = 250
} ;
#line 539
enum __anonenum_875524036___2 {
    _CS_PATH___2_CS_PATH___2 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___2_CS_V6_WIDTH_RESTRICTED_ENVS___2 = 1,
    _CS_GNU_LIBC_VERSION___2_CS_GNU_LIBC_VERSION___2 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___2_CS_GNU_LIBPTHREAD_VERSION___2 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___2_CS_V5_WIDTH_RESTRICTED_ENVS___2 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___2_CS_V7_WIDTH_RESTRICTED_ENVS___2 = 5,
    _CS_LFS_CFLAGS___2_CS_LFS_CFLAGS___2 = 1000,
    _CS_LFS_LDFLAGS___2_CS_LFS_LDFLAGS___2 = 1001,
    _CS_LFS_LIBS___2_CS_LFS_LIBS___2 = 1002,
    _CS_LFS_LINTFLAGS___2_CS_LFS_LINTFLAGS___2 = 1003,
    _CS_LFS64_CFLAGS___2_CS_LFS64_CFLAGS___2 = 1004,
    _CS_LFS64_LDFLAGS___2_CS_LFS64_LDFLAGS___2 = 1005,
    _CS_LFS64_LIBS___2_CS_LFS64_LIBS___2 = 1006,
    _CS_LFS64_LINTFLAGS___2_CS_LFS64_LINTFLAGS___2 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___2_CS_XBS5_ILP32_OFF32_CFLAGS___2 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___2_CS_XBS5_ILP32_OFF32_LDFLAGS___2 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___2_CS_XBS5_ILP32_OFF32_LIBS___2 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___2_CS_XBS5_ILP32_OFF32_LINTFLAGS___2 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___2_CS_XBS5_ILP32_OFFBIG_CFLAGS___2 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___2_CS_XBS5_ILP32_OFFBIG_LDFLAGS___2 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___2_CS_XBS5_ILP32_OFFBIG_LIBS___2 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___2_CS_XBS5_ILP32_OFFBIG_LINTFLAGS___2 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___2_CS_XBS5_LP64_OFF64_CFLAGS___2 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___2_CS_XBS5_LP64_OFF64_LDFLAGS___2 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___2_CS_XBS5_LP64_OFF64_LIBS___2 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___2_CS_XBS5_LP64_OFF64_LINTFLAGS___2 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___2_CS_XBS5_LPBIG_OFFBIG_CFLAGS___2 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___2_CS_XBS5_LPBIG_OFFBIG_LDFLAGS___2 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___2_CS_XBS5_LPBIG_OFFBIG_LIBS___2 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___2_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___2 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___2_CS_POSIX_V6_ILP32_OFF32_CFLAGS___2 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___2_CS_POSIX_V6_ILP32_OFF32_LDFLAGS___2 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___2_CS_POSIX_V6_ILP32_OFF32_LIBS___2 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___2_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___2 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___2_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___2 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___2_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___2 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___2_CS_POSIX_V6_ILP32_OFFBIG_LIBS___2 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___2_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___2 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___2_CS_POSIX_V6_LP64_OFF64_CFLAGS___2 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___2_CS_POSIX_V6_LP64_OFF64_LDFLAGS___2 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___2_CS_POSIX_V6_LP64_OFF64_LIBS___2 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___2_CS_POSIX_V6_LP64_OFF64_LINTFLAGS___2 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___2_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___2 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___2_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___2 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___2_CS_POSIX_V6_LPBIG_OFFBIG_LIBS___2 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___2_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___2 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___2_CS_POSIX_V7_ILP32_OFF32_CFLAGS___2 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___2_CS_POSIX_V7_ILP32_OFF32_LDFLAGS___2 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___2_CS_POSIX_V7_ILP32_OFF32_LIBS___2 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___2_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___2 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___2_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___2 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___2_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___2 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___2_CS_POSIX_V7_ILP32_OFFBIG_LIBS___2 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___2_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___2 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___2_CS_POSIX_V7_LP64_OFF64_CFLAGS___2 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___2_CS_POSIX_V7_LP64_OFF64_LDFLAGS___2 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___2_CS_POSIX_V7_LP64_OFF64_LIBS___2 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___2_CS_POSIX_V7_LP64_OFF64_LINTFLAGS___2 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___2_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___2 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___2_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___2 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___2_CS_POSIX_V7_LPBIG_OFFBIG_LIBS___2 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___2_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___2 = 1147,
    _CS_V6_ENV___2_CS_V6_ENV___2 = 1148,
    _CS_V7_ENV___2_CS_V7_ENV___2 = 1149
} ;
#line 46 "/usr/include/rpc/netdb.h"
struct rpcent {
   char *r_name ;
   char **r_aliases ;
   int r_number ;
};
#line 26 "/usr/include/bits/netdb.h"
struct netent {
   char *n_name ;
   char **n_aliases ;
   int n_addrtype ;
   uint32_t n_net ;
};
#line 98 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 255 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 324 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 565 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 33 "doomdef.h"
enum __anonenum_82154846___4 {
    VERSION___4VERSION___4 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___3 {
    FP_NAN___3FP_NAN___3 = 0,
    FP_INFINITE___3FP_INFINITE___3 = 1,
    FP_ZERO___3FP_ZERO___3 = 2,
    FP_SUBNORMAL___3FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3FP_NORMAL___3 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___3 {
    ML_LABEL___3ML_LABEL___3 = 0,
    ML_THINGS___3ML_THINGS___3 = 1,
    ML_LINEDEFS___3ML_LINEDEFS___3 = 2,
    ML_SIDEDEFS___3ML_SIDEDEFS___3 = 3,
    ML_VERTEXES___3ML_VERTEXES___3 = 4,
    ML_SEGS___3ML_SEGS___3 = 5,
    ML_SSECTORS___3ML_SSECTORS___3 = 6,
    ML_NODES___3ML_NODES___3 = 7,
    ML_SECTORS___3ML_SECTORS___3 = 8,
    ML_REJECT___3ML_REJECT___3 = 9,
    ML_BLOCKMAP___3ML_BLOCKMAP___3 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___4 {
    FP_NAN___4FP_NAN___4 = 0,
    FP_INFINITE___4FP_INFINITE___4 = 1,
    FP_ZERO___4FP_ZERO___4 = 2,
    FP_SUBNORMAL___4FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4FP_NORMAL___4 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum_18926444 {
    _ISupper_ISupper = 256,
    _ISlower_ISlower = 512,
    _ISalpha_ISalpha = 1024,
    _ISdigit_ISdigit = 2048,
    _ISxdigit_ISxdigit = 4096,
    _ISspace_ISspace = 8192,
    _ISprint_ISprint = 16384,
    _ISgraph_ISgraph = 32768,
    _ISblank_ISblank = 1,
    _IScntrl_IScntrl = 2,
    _ISpunct_ISpunct = 4,
    _ISalnum_ISalnum = 8
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___5 {
    VERSION___5VERSION___5 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___5 {
    FP_NAN___5FP_NAN___5 = 0,
    FP_INFINITE___5FP_INFINITE___5 = 1,
    FP_ZERO___5FP_ZERO___5 = 2,
    FP_SUBNORMAL___5FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5FP_NORMAL___5 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___4 {
    ML_LABEL___4ML_LABEL___4 = 0,
    ML_THINGS___4ML_THINGS___4 = 1,
    ML_LINEDEFS___4ML_LINEDEFS___4 = 2,
    ML_SIDEDEFS___4ML_SIDEDEFS___4 = 3,
    ML_VERTEXES___4ML_VERTEXES___4 = 4,
    ML_SEGS___4ML_SEGS___4 = 5,
    ML_SSECTORS___4ML_SSECTORS___4 = 6,
    ML_NODES___4ML_NODES___4 = 7,
    ML_SECTORS___4ML_SECTORS___4 = 8,
    ML_REJECT___4ML_REJECT___4 = 9,
    ML_BLOCKMAP___4ML_BLOCKMAP___4 = 10
} ;
#line 334 "f_finale.c"
struct __anonstruct_castinfo_t_244424416 {
   char *name ;
   mobjtype_t type ;
};
#line 334 "f_finale.c"
typedef struct __anonstruct_castinfo_t_244424416 castinfo_t;
#line 33 "doomdef.h"
enum __anonenum_82154846___6 {
    VERSION___6VERSION___6 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___6 {
    FP_NAN___6FP_NAN___6 = 0,
    FP_INFINITE___6FP_INFINITE___6 = 1,
    FP_ZERO___6FP_ZERO___6 = 2,
    FP_SUBNORMAL___6FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6FP_NORMAL___6 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___5 {
    ML_LABEL___5ML_LABEL___5 = 0,
    ML_THINGS___5ML_THINGS___5 = 1,
    ML_LINEDEFS___5ML_LINEDEFS___5 = 2,
    ML_SIDEDEFS___5ML_SIDEDEFS___5 = 3,
    ML_VERTEXES___5ML_VERTEXES___5 = 4,
    ML_SEGS___5ML_SEGS___5 = 5,
    ML_SSECTORS___5ML_SSECTORS___5 = 6,
    ML_NODES___5ML_NODES___5 = 7,
    ML_SECTORS___5ML_SECTORS___5 = 8,
    ML_REJECT___5ML_REJECT___5 = 9,
    ML_BLOCKMAP___5ML_BLOCKMAP___5 = 10
} ;
#line 30 "f_wipe.h"
enum __anonenum_960858273 {
    wipe_ColorXFormwipe_ColorXForm = 0,
    wipe_Meltwipe_Melt = 1,
    wipe_NUMWIPESwipe_NUMWIPES = 2
} ;
#line 24 "/usr/include/bits/confname.h"
enum __anonenum_437032235___3 {
    _PC_LINK_MAX___3_PC_LINK_MAX___3 = 0,
    _PC_MAX_CANON___3_PC_MAX_CANON___3 = 1,
    _PC_MAX_INPUT___3_PC_MAX_INPUT___3 = 2,
    _PC_NAME_MAX___3_PC_NAME_MAX___3 = 3,
    _PC_PATH_MAX___3_PC_PATH_MAX___3 = 4,
    _PC_PIPE_BUF___3_PC_PIPE_BUF___3 = 5,
    _PC_CHOWN_RESTRICTED___3_PC_CHOWN_RESTRICTED___3 = 6,
    _PC_NO_TRUNC___3_PC_NO_TRUNC___3 = 7,
    _PC_VDISABLE___3_PC_VDISABLE___3 = 8,
    _PC_SYNC_IO___3_PC_SYNC_IO___3 = 9,
    _PC_ASYNC_IO___3_PC_ASYNC_IO___3 = 10,
    _PC_PRIO_IO___3_PC_PRIO_IO___3 = 11,
    _PC_SOCK_MAXBUF___3_PC_SOCK_MAXBUF___3 = 12,
    _PC_FILESIZEBITS___3_PC_FILESIZEBITS___3 = 13,
    _PC_REC_INCR_XFER_SIZE___3_PC_REC_INCR_XFER_SIZE___3 = 14,
    _PC_REC_MAX_XFER_SIZE___3_PC_REC_MAX_XFER_SIZE___3 = 15,
    _PC_REC_MIN_XFER_SIZE___3_PC_REC_MIN_XFER_SIZE___3 = 16,
    _PC_REC_XFER_ALIGN___3_PC_REC_XFER_ALIGN___3 = 17,
    _PC_ALLOC_SIZE_MIN___3_PC_ALLOC_SIZE_MIN___3 = 18,
    _PC_SYMLINK_MAX___3_PC_SYMLINK_MAX___3 = 19,
    _PC_2_SYMLINKS___3_PC_2_SYMLINKS___3 = 20
} ;
#line 71
enum __anonenum_315186338___3 {
    _SC_ARG_MAX___3_SC_ARG_MAX___3 = 0,
    _SC_CHILD_MAX___3_SC_CHILD_MAX___3 = 1,
    _SC_CLK_TCK___3_SC_CLK_TCK___3 = 2,
    _SC_NGROUPS_MAX___3_SC_NGROUPS_MAX___3 = 3,
    _SC_OPEN_MAX___3_SC_OPEN_MAX___3 = 4,
    _SC_STREAM_MAX___3_SC_STREAM_MAX___3 = 5,
    _SC_TZNAME_MAX___3_SC_TZNAME_MAX___3 = 6,
    _SC_JOB_CONTROL___3_SC_JOB_CONTROL___3 = 7,
    _SC_SAVED_IDS___3_SC_SAVED_IDS___3 = 8,
    _SC_REALTIME_SIGNALS___3_SC_REALTIME_SIGNALS___3 = 9,
    _SC_PRIORITY_SCHEDULING___3_SC_PRIORITY_SCHEDULING___3 = 10,
    _SC_TIMERS___3_SC_TIMERS___3 = 11,
    _SC_ASYNCHRONOUS_IO___3_SC_ASYNCHRONOUS_IO___3 = 12,
    _SC_PRIORITIZED_IO___3_SC_PRIORITIZED_IO___3 = 13,
    _SC_SYNCHRONIZED_IO___3_SC_SYNCHRONIZED_IO___3 = 14,
    _SC_FSYNC___3_SC_FSYNC___3 = 15,
    _SC_MAPPED_FILES___3_SC_MAPPED_FILES___3 = 16,
    _SC_MEMLOCK___3_SC_MEMLOCK___3 = 17,
    _SC_MEMLOCK_RANGE___3_SC_MEMLOCK_RANGE___3 = 18,
    _SC_MEMORY_PROTECTION___3_SC_MEMORY_PROTECTION___3 = 19,
    _SC_MESSAGE_PASSING___3_SC_MESSAGE_PASSING___3 = 20,
    _SC_SEMAPHORES___3_SC_SEMAPHORES___3 = 21,
    _SC_SHARED_MEMORY_OBJECTS___3_SC_SHARED_MEMORY_OBJECTS___3 = 22,
    _SC_AIO_LISTIO_MAX___3_SC_AIO_LISTIO_MAX___3 = 23,
    _SC_AIO_MAX___3_SC_AIO_MAX___3 = 24,
    _SC_AIO_PRIO_DELTA_MAX___3_SC_AIO_PRIO_DELTA_MAX___3 = 25,
    _SC_DELAYTIMER_MAX___3_SC_DELAYTIMER_MAX___3 = 26,
    _SC_MQ_OPEN_MAX___3_SC_MQ_OPEN_MAX___3 = 27,
    _SC_MQ_PRIO_MAX___3_SC_MQ_PRIO_MAX___3 = 28,
    _SC_VERSION___3_SC_VERSION___3 = 29,
    _SC_PAGESIZE___3_SC_PAGESIZE___3 = 30,
    _SC_RTSIG_MAX___3_SC_RTSIG_MAX___3 = 31,
    _SC_SEM_NSEMS_MAX___3_SC_SEM_NSEMS_MAX___3 = 32,
    _SC_SEM_VALUE_MAX___3_SC_SEM_VALUE_MAX___3 = 33,
    _SC_SIGQUEUE_MAX___3_SC_SIGQUEUE_MAX___3 = 34,
    _SC_TIMER_MAX___3_SC_TIMER_MAX___3 = 35,
    _SC_BC_BASE_MAX___3_SC_BC_BASE_MAX___3 = 36,
    _SC_BC_DIM_MAX___3_SC_BC_DIM_MAX___3 = 37,
    _SC_BC_SCALE_MAX___3_SC_BC_SCALE_MAX___3 = 38,
    _SC_BC_STRING_MAX___3_SC_BC_STRING_MAX___3 = 39,
    _SC_COLL_WEIGHTS_MAX___3_SC_COLL_WEIGHTS_MAX___3 = 40,
    _SC_EQUIV_CLASS_MAX___3_SC_EQUIV_CLASS_MAX___3 = 41,
    _SC_EXPR_NEST_MAX___3_SC_EXPR_NEST_MAX___3 = 42,
    _SC_LINE_MAX___3_SC_LINE_MAX___3 = 43,
    _SC_RE_DUP_MAX___3_SC_RE_DUP_MAX___3 = 44,
    _SC_CHARCLASS_NAME_MAX___3_SC_CHARCLASS_NAME_MAX___3 = 45,
    _SC_2_VERSION___3_SC_2_VERSION___3 = 46,
    _SC_2_C_BIND___3_SC_2_C_BIND___3 = 47,
    _SC_2_C_DEV___3_SC_2_C_DEV___3 = 48,
    _SC_2_FORT_DEV___3_SC_2_FORT_DEV___3 = 49,
    _SC_2_FORT_RUN___3_SC_2_FORT_RUN___3 = 50,
    _SC_2_SW_DEV___3_SC_2_SW_DEV___3 = 51,
    _SC_2_LOCALEDEF___3_SC_2_LOCALEDEF___3 = 52,
    _SC_PII___3_SC_PII___3 = 53,
    _SC_PII_XTI___3_SC_PII_XTI___3 = 54,
    _SC_PII_SOCKET___3_SC_PII_SOCKET___3 = 55,
    _SC_PII_INTERNET___3_SC_PII_INTERNET___3 = 56,
    _SC_PII_OSI___3_SC_PII_OSI___3 = 57,
    _SC_POLL___3_SC_POLL___3 = 58,
    _SC_SELECT___3_SC_SELECT___3 = 59,
    _SC_UIO_MAXIOV___3_SC_UIO_MAXIOV___3 = 60,
    _SC_IOV_MAX___3_SC_IOV_MAX___3 = 60,
    _SC_PII_INTERNET_STREAM___3_SC_PII_INTERNET_STREAM___3 = 61,
    _SC_PII_INTERNET_DGRAM___3_SC_PII_INTERNET_DGRAM___3 = 62,
    _SC_PII_OSI_COTS___3_SC_PII_OSI_COTS___3 = 63,
    _SC_PII_OSI_CLTS___3_SC_PII_OSI_CLTS___3 = 64,
    _SC_PII_OSI_M___3_SC_PII_OSI_M___3 = 65,
    _SC_T_IOV_MAX___3_SC_T_IOV_MAX___3 = 66,
    _SC_THREADS___3_SC_THREADS___3 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___3_SC_THREAD_SAFE_FUNCTIONS___3 = 68,
    _SC_GETGR_R_SIZE_MAX___3_SC_GETGR_R_SIZE_MAX___3 = 69,
    _SC_GETPW_R_SIZE_MAX___3_SC_GETPW_R_SIZE_MAX___3 = 70,
    _SC_LOGIN_NAME_MAX___3_SC_LOGIN_NAME_MAX___3 = 71,
    _SC_TTY_NAME_MAX___3_SC_TTY_NAME_MAX___3 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___3_SC_THREAD_DESTRUCTOR_ITERATIONS___3 = 73,
    _SC_THREAD_KEYS_MAX___3_SC_THREAD_KEYS_MAX___3 = 74,
    _SC_THREAD_STACK_MIN___3_SC_THREAD_STACK_MIN___3 = 75,
    _SC_THREAD_THREADS_MAX___3_SC_THREAD_THREADS_MAX___3 = 76,
    _SC_THREAD_ATTR_STACKADDR___3_SC_THREAD_ATTR_STACKADDR___3 = 77,
    _SC_THREAD_ATTR_STACKSIZE___3_SC_THREAD_ATTR_STACKSIZE___3 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___3_SC_THREAD_PRIORITY_SCHEDULING___3 = 79,
    _SC_THREAD_PRIO_INHERIT___3_SC_THREAD_PRIO_INHERIT___3 = 80,
    _SC_THREAD_PRIO_PROTECT___3_SC_THREAD_PRIO_PROTECT___3 = 81,
    _SC_THREAD_PROCESS_SHARED___3_SC_THREAD_PROCESS_SHARED___3 = 82,
    _SC_NPROCESSORS_CONF___3_SC_NPROCESSORS_CONF___3 = 83,
    _SC_NPROCESSORS_ONLN___3_SC_NPROCESSORS_ONLN___3 = 84,
    _SC_PHYS_PAGES___3_SC_PHYS_PAGES___3 = 85,
    _SC_AVPHYS_PAGES___3_SC_AVPHYS_PAGES___3 = 86,
    _SC_ATEXIT_MAX___3_SC_ATEXIT_MAX___3 = 87,
    _SC_PASS_MAX___3_SC_PASS_MAX___3 = 88,
    _SC_XOPEN_VERSION___3_SC_XOPEN_VERSION___3 = 89,
    _SC_XOPEN_XCU_VERSION___3_SC_XOPEN_XCU_VERSION___3 = 90,
    _SC_XOPEN_UNIX___3_SC_XOPEN_UNIX___3 = 91,
    _SC_XOPEN_CRYPT___3_SC_XOPEN_CRYPT___3 = 92,
    _SC_XOPEN_ENH_I18N___3_SC_XOPEN_ENH_I18N___3 = 93,
    _SC_XOPEN_SHM___3_SC_XOPEN_SHM___3 = 94,
    _SC_2_CHAR_TERM___3_SC_2_CHAR_TERM___3 = 95,
    _SC_2_C_VERSION___3_SC_2_C_VERSION___3 = 96,
    _SC_2_UPE___3_SC_2_UPE___3 = 97,
    _SC_XOPEN_XPG2___3_SC_XOPEN_XPG2___3 = 98,
    _SC_XOPEN_XPG3___3_SC_XOPEN_XPG3___3 = 99,
    _SC_XOPEN_XPG4___3_SC_XOPEN_XPG4___3 = 100,
    _SC_CHAR_BIT___3_SC_CHAR_BIT___3 = 101,
    _SC_CHAR_MAX___3_SC_CHAR_MAX___3 = 102,
    _SC_CHAR_MIN___3_SC_CHAR_MIN___3 = 103,
    _SC_INT_MAX___3_SC_INT_MAX___3 = 104,
    _SC_INT_MIN___3_SC_INT_MIN___3 = 105,
    _SC_LONG_BIT___3_SC_LONG_BIT___3 = 106,
    _SC_WORD_BIT___3_SC_WORD_BIT___3 = 107,
    _SC_MB_LEN_MAX___3_SC_MB_LEN_MAX___3 = 108,
    _SC_NZERO___3_SC_NZERO___3 = 109,
    _SC_SSIZE_MAX___3_SC_SSIZE_MAX___3 = 110,
    _SC_SCHAR_MAX___3_SC_SCHAR_MAX___3 = 111,
    _SC_SCHAR_MIN___3_SC_SCHAR_MIN___3 = 112,
    _SC_SHRT_MAX___3_SC_SHRT_MAX___3 = 113,
    _SC_SHRT_MIN___3_SC_SHRT_MIN___3 = 114,
    _SC_UCHAR_MAX___3_SC_UCHAR_MAX___3 = 115,
    _SC_UINT_MAX___3_SC_UINT_MAX___3 = 116,
    _SC_ULONG_MAX___3_SC_ULONG_MAX___3 = 117,
    _SC_USHRT_MAX___3_SC_USHRT_MAX___3 = 118,
    _SC_NL_ARGMAX___3_SC_NL_ARGMAX___3 = 119,
    _SC_NL_LANGMAX___3_SC_NL_LANGMAX___3 = 120,
    _SC_NL_MSGMAX___3_SC_NL_MSGMAX___3 = 121,
    _SC_NL_NMAX___3_SC_NL_NMAX___3 = 122,
    _SC_NL_SETMAX___3_SC_NL_SETMAX___3 = 123,
    _SC_NL_TEXTMAX___3_SC_NL_TEXTMAX___3 = 124,
    _SC_XBS5_ILP32_OFF32___3_SC_XBS5_ILP32_OFF32___3 = 125,
    _SC_XBS5_ILP32_OFFBIG___3_SC_XBS5_ILP32_OFFBIG___3 = 126,
    _SC_XBS5_LP64_OFF64___3_SC_XBS5_LP64_OFF64___3 = 127,
    _SC_XBS5_LPBIG_OFFBIG___3_SC_XBS5_LPBIG_OFFBIG___3 = 128,
    _SC_XOPEN_LEGACY___3_SC_XOPEN_LEGACY___3 = 129,
    _SC_XOPEN_REALTIME___3_SC_XOPEN_REALTIME___3 = 130,
    _SC_XOPEN_REALTIME_THREADS___3_SC_XOPEN_REALTIME_THREADS___3 = 131,
    _SC_ADVISORY_INFO___3_SC_ADVISORY_INFO___3 = 132,
    _SC_BARRIERS___3_SC_BARRIERS___3 = 133,
    _SC_BASE___3_SC_BASE___3 = 134,
    _SC_C_LANG_SUPPORT___3_SC_C_LANG_SUPPORT___3 = 135,
    _SC_C_LANG_SUPPORT_R___3_SC_C_LANG_SUPPORT_R___3 = 136,
    _SC_CLOCK_SELECTION___3_SC_CLOCK_SELECTION___3 = 137,
    _SC_CPUTIME___3_SC_CPUTIME___3 = 138,
    _SC_THREAD_CPUTIME___3_SC_THREAD_CPUTIME___3 = 139,
    _SC_DEVICE_IO___3_SC_DEVICE_IO___3 = 140,
    _SC_DEVICE_SPECIFIC___3_SC_DEVICE_SPECIFIC___3 = 141,
    _SC_DEVICE_SPECIFIC_R___3_SC_DEVICE_SPECIFIC_R___3 = 142,
    _SC_FD_MGMT___3_SC_FD_MGMT___3 = 143,
    _SC_FIFO___3_SC_FIFO___3 = 144,
    _SC_PIPE___3_SC_PIPE___3 = 145,
    _SC_FILE_ATTRIBUTES___3_SC_FILE_ATTRIBUTES___3 = 146,
    _SC_FILE_LOCKING___3_SC_FILE_LOCKING___3 = 147,
    _SC_FILE_SYSTEM___3_SC_FILE_SYSTEM___3 = 148,
    _SC_MONOTONIC_CLOCK___3_SC_MONOTONIC_CLOCK___3 = 149,
    _SC_MULTI_PROCESS___3_SC_MULTI_PROCESS___3 = 150,
    _SC_SINGLE_PROCESS___3_SC_SINGLE_PROCESS___3 = 151,
    _SC_NETWORKING___3_SC_NETWORKING___3 = 152,
    _SC_READER_WRITER_LOCKS___3_SC_READER_WRITER_LOCKS___3 = 153,
    _SC_SPIN_LOCKS___3_SC_SPIN_LOCKS___3 = 154,
    _SC_REGEXP___3_SC_REGEXP___3 = 155,
    _SC_REGEX_VERSION___3_SC_REGEX_VERSION___3 = 156,
    _SC_SHELL___3_SC_SHELL___3 = 157,
    _SC_SIGNALS___3_SC_SIGNALS___3 = 158,
    _SC_SPAWN___3_SC_SPAWN___3 = 159,
    _SC_SPORADIC_SERVER___3_SC_SPORADIC_SERVER___3 = 160,
    _SC_THREAD_SPORADIC_SERVER___3_SC_THREAD_SPORADIC_SERVER___3 = 161,
    _SC_SYSTEM_DATABASE___3_SC_SYSTEM_DATABASE___3 = 162,
    _SC_SYSTEM_DATABASE_R___3_SC_SYSTEM_DATABASE_R___3 = 163,
    _SC_TIMEOUTS___3_SC_TIMEOUTS___3 = 164,
    _SC_TYPED_MEMORY_OBJECTS___3_SC_TYPED_MEMORY_OBJECTS___3 = 165,
    _SC_USER_GROUPS___3_SC_USER_GROUPS___3 = 166,
    _SC_USER_GROUPS_R___3_SC_USER_GROUPS_R___3 = 167,
    _SC_2_PBS___3_SC_2_PBS___3 = 168,
    _SC_2_PBS_ACCOUNTING___3_SC_2_PBS_ACCOUNTING___3 = 169,
    _SC_2_PBS_LOCATE___3_SC_2_PBS_LOCATE___3 = 170,
    _SC_2_PBS_MESSAGE___3_SC_2_PBS_MESSAGE___3 = 171,
    _SC_2_PBS_TRACK___3_SC_2_PBS_TRACK___3 = 172,
    _SC_SYMLOOP_MAX___3_SC_SYMLOOP_MAX___3 = 173,
    _SC_STREAMS___3_SC_STREAMS___3 = 174,
    _SC_2_PBS_CHECKPOINT___3_SC_2_PBS_CHECKPOINT___3 = 175,
    _SC_V6_ILP32_OFF32___3_SC_V6_ILP32_OFF32___3 = 176,
    _SC_V6_ILP32_OFFBIG___3_SC_V6_ILP32_OFFBIG___3 = 177,
    _SC_V6_LP64_OFF64___3_SC_V6_LP64_OFF64___3 = 178,
    _SC_V6_LPBIG_OFFBIG___3_SC_V6_LPBIG_OFFBIG___3 = 179,
    _SC_HOST_NAME_MAX___3_SC_HOST_NAME_MAX___3 = 180,
    _SC_TRACE___3_SC_TRACE___3 = 181,
    _SC_TRACE_EVENT_FILTER___3_SC_TRACE_EVENT_FILTER___3 = 182,
    _SC_TRACE_INHERIT___3_SC_TRACE_INHERIT___3 = 183,
    _SC_TRACE_LOG___3_SC_TRACE_LOG___3 = 184,
    _SC_LEVEL1_ICACHE_SIZE___3_SC_LEVEL1_ICACHE_SIZE___3 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___3_SC_LEVEL1_ICACHE_ASSOC___3 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___3_SC_LEVEL1_ICACHE_LINESIZE___3 = 187,
    _SC_LEVEL1_DCACHE_SIZE___3_SC_LEVEL1_DCACHE_SIZE___3 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___3_SC_LEVEL1_DCACHE_ASSOC___3 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___3_SC_LEVEL1_DCACHE_LINESIZE___3 = 190,
    _SC_LEVEL2_CACHE_SIZE___3_SC_LEVEL2_CACHE_SIZE___3 = 191,
    _SC_LEVEL2_CACHE_ASSOC___3_SC_LEVEL2_CACHE_ASSOC___3 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___3_SC_LEVEL2_CACHE_LINESIZE___3 = 193,
    _SC_LEVEL3_CACHE_SIZE___3_SC_LEVEL3_CACHE_SIZE___3 = 194,
    _SC_LEVEL3_CACHE_ASSOC___3_SC_LEVEL3_CACHE_ASSOC___3 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___3_SC_LEVEL3_CACHE_LINESIZE___3 = 196,
    _SC_LEVEL4_CACHE_SIZE___3_SC_LEVEL4_CACHE_SIZE___3 = 197,
    _SC_LEVEL4_CACHE_ASSOC___3_SC_LEVEL4_CACHE_ASSOC___3 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___3_SC_LEVEL4_CACHE_LINESIZE___3 = 199,
    _SC_IPV6___3_SC_IPV6___3 = 235,
    _SC_RAW_SOCKETS___3_SC_RAW_SOCKETS___3 = 236,
    _SC_V7_ILP32_OFF32___3_SC_V7_ILP32_OFF32___3 = 237,
    _SC_V7_ILP32_OFFBIG___3_SC_V7_ILP32_OFFBIG___3 = 238,
    _SC_V7_LP64_OFF64___3_SC_V7_LP64_OFF64___3 = 239,
    _SC_V7_LPBIG_OFFBIG___3_SC_V7_LPBIG_OFFBIG___3 = 240,
    _SC_SS_REPL_MAX___3_SC_SS_REPL_MAX___3 = 241,
    _SC_TRACE_EVENT_NAME_MAX___3_SC_TRACE_EVENT_NAME_MAX___3 = 242,
    _SC_TRACE_NAME_MAX___3_SC_TRACE_NAME_MAX___3 = 243,
    _SC_TRACE_SYS_MAX___3_SC_TRACE_SYS_MAX___3 = 244,
    _SC_TRACE_USER_EVENT_MAX___3_SC_TRACE_USER_EVENT_MAX___3 = 245,
    _SC_XOPEN_STREAMS___3_SC_XOPEN_STREAMS___3 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___3_SC_THREAD_ROBUST_PRIO_INHERIT___3 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___3_SC_THREAD_ROBUST_PRIO_PROTECT___3 = 248,
    _SC_MINSIGSTKSZ___3_SC_MINSIGSTKSZ___3 = 249,
    _SC_SIGSTKSZ___3_SC_SIGSTKSZ___3 = 250
} ;
#line 539
enum __anonenum_875524036___3 {
    _CS_PATH___3_CS_PATH___3 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___3_CS_V6_WIDTH_RESTRICTED_ENVS___3 = 1,
    _CS_GNU_LIBC_VERSION___3_CS_GNU_LIBC_VERSION___3 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___3_CS_GNU_LIBPTHREAD_VERSION___3 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___3_CS_V5_WIDTH_RESTRICTED_ENVS___3 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___3_CS_V7_WIDTH_RESTRICTED_ENVS___3 = 5,
    _CS_LFS_CFLAGS___3_CS_LFS_CFLAGS___3 = 1000,
    _CS_LFS_LDFLAGS___3_CS_LFS_LDFLAGS___3 = 1001,
    _CS_LFS_LIBS___3_CS_LFS_LIBS___3 = 1002,
    _CS_LFS_LINTFLAGS___3_CS_LFS_LINTFLAGS___3 = 1003,
    _CS_LFS64_CFLAGS___3_CS_LFS64_CFLAGS___3 = 1004,
    _CS_LFS64_LDFLAGS___3_CS_LFS64_LDFLAGS___3 = 1005,
    _CS_LFS64_LIBS___3_CS_LFS64_LIBS___3 = 1006,
    _CS_LFS64_LINTFLAGS___3_CS_LFS64_LINTFLAGS___3 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___3_CS_XBS5_ILP32_OFF32_CFLAGS___3 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___3_CS_XBS5_ILP32_OFF32_LDFLAGS___3 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___3_CS_XBS5_ILP32_OFF32_LIBS___3 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___3_CS_XBS5_ILP32_OFF32_LINTFLAGS___3 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___3_CS_XBS5_ILP32_OFFBIG_CFLAGS___3 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___3_CS_XBS5_ILP32_OFFBIG_LDFLAGS___3 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___3_CS_XBS5_ILP32_OFFBIG_LIBS___3 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___3_CS_XBS5_ILP32_OFFBIG_LINTFLAGS___3 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___3_CS_XBS5_LP64_OFF64_CFLAGS___3 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___3_CS_XBS5_LP64_OFF64_LDFLAGS___3 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___3_CS_XBS5_LP64_OFF64_LIBS___3 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___3_CS_XBS5_LP64_OFF64_LINTFLAGS___3 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___3_CS_XBS5_LPBIG_OFFBIG_CFLAGS___3 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___3_CS_XBS5_LPBIG_OFFBIG_LDFLAGS___3 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___3_CS_XBS5_LPBIG_OFFBIG_LIBS___3 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___3_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___3 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___3_CS_POSIX_V6_ILP32_OFF32_CFLAGS___3 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___3_CS_POSIX_V6_ILP32_OFF32_LDFLAGS___3 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___3_CS_POSIX_V6_ILP32_OFF32_LIBS___3 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___3_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___3 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___3_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___3 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___3_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___3 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___3_CS_POSIX_V6_ILP32_OFFBIG_LIBS___3 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___3_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___3 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___3_CS_POSIX_V6_LP64_OFF64_CFLAGS___3 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___3_CS_POSIX_V6_LP64_OFF64_LDFLAGS___3 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___3_CS_POSIX_V6_LP64_OFF64_LIBS___3 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___3_CS_POSIX_V6_LP64_OFF64_LINTFLAGS___3 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___3_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___3 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___3_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___3 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___3_CS_POSIX_V6_LPBIG_OFFBIG_LIBS___3 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___3_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___3 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___3_CS_POSIX_V7_ILP32_OFF32_CFLAGS___3 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___3_CS_POSIX_V7_ILP32_OFF32_LDFLAGS___3 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___3_CS_POSIX_V7_ILP32_OFF32_LIBS___3 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___3_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___3 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___3_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___3 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___3_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___3 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___3_CS_POSIX_V7_ILP32_OFFBIG_LIBS___3 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___3_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___3 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___3_CS_POSIX_V7_LP64_OFF64_CFLAGS___3 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___3_CS_POSIX_V7_LP64_OFF64_LDFLAGS___3 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___3_CS_POSIX_V7_LP64_OFF64_LIBS___3 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___3_CS_POSIX_V7_LP64_OFF64_LINTFLAGS___3 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___3_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___3 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___3_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___3 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___3_CS_POSIX_V7_LPBIG_OFFBIG_LIBS___3 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___3_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___3 = 1147,
    _CS_V6_ENV___3_CS_V6_ENV___3 = 1148,
    _CS_V7_ENV___3_CS_V7_ENV___3 = 1149
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___7 {
    VERSION___7VERSION___7 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___6 {
    ML_LABEL___6ML_LABEL___6 = 0,
    ML_THINGS___6ML_THINGS___6 = 1,
    ML_LINEDEFS___6ML_LINEDEFS___6 = 2,
    ML_SIDEDEFS___6ML_SIDEDEFS___6 = 3,
    ML_VERTEXES___6ML_VERTEXES___6 = 4,
    ML_SEGS___6ML_SEGS___6 = 5,
    ML_SSECTORS___6ML_SSECTORS___6 = 6,
    ML_NODES___6ML_NODES___6 = 7,
    ML_SECTORS___6ML_SECTORS___6 = 8,
    ML_REJECT___6ML_REJECT___6 = 9,
    ML_BLOCKMAP___6ML_BLOCKMAP___6 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___7 {
    FP_NAN___7FP_NAN___7 = 0,
    FP_INFINITE___7FP_INFINITE___7 = 1,
    FP_ZERO___7FP_ZERO___7 = 2,
    FP_SUBNORMAL___7FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7FP_NORMAL___7 = 4
} ;
#line 30 "f_wipe.h"
enum __anonenum_960858273___0 {
    wipe_ColorXForm___0wipe_ColorXForm___0 = 0,
    wipe_Melt___0wipe_Melt___0 = 1,
    wipe_NUMWIPES___0wipe_NUMWIPES___0 = 2
} ;
#line 31 "wi_stuff.h"
enum __anonenum_stateenum_t_251819420 {
    NoStateNoState = -1,
    StatCountStatCount = 0,
    ShowNextLocShowNextLoc = 1
} ;
#line 31 "wi_stuff.h"
typedef enum __anonenum_stateenum_t_251819420 stateenum_t;
#line 59 "st_stuff.h"
enum __anonenum_st_stateenum_t_885061654 {
    AutomapStateAutomapState = 0,
    FirstPersonStateFirstPersonState = 1
} ;
#line 59 "st_stuff.h"
typedef enum __anonenum_st_stateenum_t_885061654 st_stateenum_t;
#line 68
enum __anonenum_st_chatstateenum_t_520982032 {
    StartChatStateStartChatState = 0,
    WaitDestStateWaitDestState = 1,
    GetChatStateGetChatState = 2
} ;
#line 68 "st_stuff.h"
typedef enum __anonenum_st_chatstateenum_t_520982032 st_chatstateenum_t;
#line 56 "r_bsp.h"
typedef void (*drawfunc_t)(int start , int stop );
#line 38 "r_plane.h"
typedef void (*planefunction_t)(int top , int bottom );
#line 33 "doomdef.h"
enum __anonenum_82154846___8 {
    VERSION___8VERSION___8 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___7 {
    ML_LABEL___7ML_LABEL___7 = 0,
    ML_THINGS___7ML_THINGS___7 = 1,
    ML_LINEDEFS___7ML_LINEDEFS___7 = 2,
    ML_SIDEDEFS___7ML_SIDEDEFS___7 = 3,
    ML_VERTEXES___7ML_VERTEXES___7 = 4,
    ML_SEGS___7ML_SEGS___7 = 5,
    ML_SSECTORS___7ML_SSECTORS___7 = 6,
    ML_NODES___7ML_NODES___7 = 7,
    ML_SECTORS___7ML_SECTORS___7 = 8,
    ML_REJECT___7ML_REJECT___7 = 9,
    ML_BLOCKMAP___7ML_BLOCKMAP___7 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___8 {
    FP_NAN___8FP_NAN___8 = 0,
    FP_INFINITE___8FP_INFINITE___8 = 1,
    FP_ZERO___8FP_ZERO___8 = 2,
    FP_SUBNORMAL___8FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8FP_NORMAL___8 = 4
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___9 {
    VERSION___9VERSION___9 = 110
} ;
#line 33
enum __anonenum_82154846___10 {
    VERSION___10VERSION___10 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___8 {
    ML_LABEL___8ML_LABEL___8 = 0,
    ML_THINGS___8ML_THINGS___8 = 1,
    ML_LINEDEFS___8ML_LINEDEFS___8 = 2,
    ML_SIDEDEFS___8ML_SIDEDEFS___8 = 3,
    ML_VERTEXES___8ML_VERTEXES___8 = 4,
    ML_SEGS___8ML_SEGS___8 = 5,
    ML_SSECTORS___8ML_SSECTORS___8 = 6,
    ML_NODES___8ML_NODES___8 = 7,
    ML_SECTORS___8ML_SECTORS___8 = 8,
    ML_REJECT___8ML_REJECT___8 = 9,
    ML_BLOCKMAP___8ML_BLOCKMAP___8 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___9 {
    FP_NAN___9FP_NAN___9 = 0,
    FP_INFINITE___9FP_INFINITE___9 = 1,
    FP_ZERO___9FP_ZERO___9 = 2,
    FP_SUBNORMAL___9FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9FP_NORMAL___9 = 4
} ;
#line 135 "p_local.h"
struct __anonstruct_divline_t_12881478 {
   fixed_t x ;
   fixed_t y ;
   fixed_t dx ;
   fixed_t dy ;
};
#line 135 "p_local.h"
typedef struct __anonstruct_divline_t_12881478 divline_t;
#line 144 "p_local.h"
union __anonunion_d_732575026 {
   mobj_t *thing ;
   line_t *line ;
};
#line 144 "p_local.h"
struct __anonstruct_intercept_t_178108778 {
   fixed_t frac ;
   boolean isaline ;
   union __anonunion_d_732575026 d ;
};
#line 144 "p_local.h"
typedef struct __anonstruct_intercept_t_178108778 intercept_t;
#line 159 "p_local.h"
typedef boolean (*traverser_t)(intercept_t *in );
#line 124 "p_spec.h"
struct __anonstruct_fireflicker_t_232867649 {
   thinker_t thinker ;
   sector_t *sector ;
   int count ;
   int maxlight ;
   int minlight ;
};
#line 124 "p_spec.h"
typedef struct __anonstruct_fireflicker_t_232867649 fireflicker_t;
#line 136 "p_spec.h"
struct __anonstruct_lightflash_t_454294603 {
   thinker_t thinker ;
   sector_t *sector ;
   int count ;
   int maxlight ;
   int minlight ;
   int maxtime ;
   int mintime ;
};
#line 136 "p_spec.h"
typedef struct __anonstruct_lightflash_t_454294603 lightflash_t;
#line 150 "p_spec.h"
struct __anonstruct_strobe_t_454294604 {
   thinker_t thinker ;
   sector_t *sector ;
   int count ;
   int minlight ;
   int maxlight ;
   int darktime ;
   int brighttime ;
};
#line 150 "p_spec.h"
typedef struct __anonstruct_strobe_t_454294604 strobe_t;
#line 165 "p_spec.h"
struct __anonstruct_glow_t_454294605 {
   thinker_t thinker ;
   sector_t *sector ;
   int minlight ;
   int maxlight ;
   int direction ;
};
#line 165 "p_spec.h"
typedef struct __anonstruct_glow_t_454294605 glow_t;
#line 209 "p_spec.h"
struct __anonstruct_switchlist_t_839105560 {
   char name1[9] ;
   char name2[9] ;
   short episode ;
};
#line 209 "p_spec.h"
typedef struct __anonstruct_switchlist_t_839105560 switchlist_t;
#line 218
enum __anonenum_bwhere_e_779772917 {
    toptop = 0,
    middlemiddle = 1,
    bottombottom = 2
} ;
#line 218 "p_spec.h"
typedef enum __anonenum_bwhere_e_779772917 bwhere_e;
#line 227 "p_spec.h"
struct __anonstruct_button_t_1017754913 {
   line_t *line ;
   bwhere_e where ;
   int btexture ;
   int btimer ;
   mobj_t *soundorg ;
};
#line 227 "p_spec.h"
typedef struct __anonstruct_button_t_1017754913 button_t;
#line 262
enum __anonenum_plat_e_756422206 {
    upup = 0,
    downdown = 1,
    waitingwaiting = 2,
    in_stasisin_stasis = 3
} ;
#line 262 "p_spec.h"
typedef enum __anonenum_plat_e_756422206 plat_e;
#line 273
enum __anonenum_plattype_e_80118117 {
    perpetualRaiseperpetualRaise = 0,
    downWaitUpStaydownWaitUpStay = 1,
    raiseAndChangeraiseAndChange = 2,
    raiseToNearestAndChangeraiseToNearestAndChange = 3,
    blazeDWUSblazeDWUS = 4
} ;
#line 273 "p_spec.h"
typedef enum __anonenum_plattype_e_80118117 plattype_e;
#line 285 "p_spec.h"
struct __anonstruct_plat_t_78972001 {
   thinker_t thinker ;
   sector_t *sector ;
   fixed_t speed ;
   fixed_t low ;
   fixed_t high ;
   int wait ;
   int count ;
   plat_e status ;
   plat_e oldstatus ;
   boolean crush ;
   int tag ;
   plattype_e type ;
};
#line 285 "p_spec.h"
typedef struct __anonstruct_plat_t_78972001 plat_t;
#line 328
enum __anonenum_vldoor_e_545340445 {
    normalnormal = 0,
    close30ThenOpenclose30ThenOpen = 1,
    close___0close___0 = 2,
    open___0open___0 = 3,
    raiseIn5MinsraiseIn5Mins = 4,
    blazeRaiseblazeRaise = 5,
    blazeOpenblazeOpen = 6,
    blazeCloseblazeClose = 7
} ;
#line 328 "p_spec.h"
typedef enum __anonenum_vldoor_e_545340445 vldoor_e;
#line 343 "p_spec.h"
struct __anonstruct_vldoor_t_303671386 {
   thinker_t thinker ;
   vldoor_e type ;
   sector_t *sector ;
   fixed_t topheight ;
   fixed_t speed ;
   int direction ;
   int topwait ;
   int topcountdown ;
};
#line 343 "p_spec.h"
typedef struct __anonstruct_vldoor_t_303671386 vldoor_t;
#line 480
enum __anonenum_ceiling_e_724196600 {
    lowerToFloorlowerToFloor = 0,
    raiseToHighestraiseToHighest = 1,
    lowerAndCrushlowerAndCrush = 2,
    crushAndRaisecrushAndRaise = 3,
    fastCrushAndRaisefastCrushAndRaise = 4,
    silentCrushAndRaisesilentCrushAndRaise = 5
} ;
#line 480 "p_spec.h"
typedef enum __anonenum_ceiling_e_724196600 ceiling_e;
#line 493 "p_spec.h"
struct __anonstruct_ceiling_t_300583118 {
   thinker_t thinker ;
   ceiling_e type ;
   sector_t *sector ;
   fixed_t bottomheight ;
   fixed_t topheight ;
   fixed_t speed ;
   boolean crush ;
   int direction ;
   int tag ;
   int olddirection ;
};
#line 493 "p_spec.h"
typedef struct __anonstruct_ceiling_t_300583118 ceiling_t;
#line 537
enum __anonenum_floor_e_662080336 {
    lowerFloorlowerFloor = 0,
    lowerFloorToLowestlowerFloorToLowest = 1,
    turboLowerturboLower = 2,
    raiseFloorraiseFloor = 3,
    raiseFloorToNearestraiseFloorToNearest = 4,
    raiseToTextureraiseToTexture = 5,
    lowerAndChangelowerAndChange = 6,
    raiseFloor24raiseFloor24 = 7,
    raiseFloor24AndChangeraiseFloor24AndChange = 8,
    raiseFloorCrushraiseFloorCrush = 9,
    raiseFloorTurboraiseFloorTurbo = 10,
    donutRaisedonutRaise = 11,
    raiseFloor512raiseFloor512 = 12
} ;
#line 537 "p_spec.h"
typedef enum __anonenum_floor_e_662080336 floor_e;
#line 575
enum __anonenum_stair_e_456903466 {
    build8build8 = 0,
    turbo16turbo16 = 1
} ;
#line 575 "p_spec.h"
typedef enum __anonenum_stair_e_456903466 stair_e;
#line 584 "p_spec.h"
struct __anonstruct_floormove_t_679127329 {
   thinker_t thinker ;
   floor_e type ;
   boolean crush ;
   sector_t *sector ;
   int direction ;
   int newspecial ;
   short texture ;
   fixed_t floordestheight ;
   fixed_t speed ;
};
#line 584 "p_spec.h"
typedef struct __anonstruct_floormove_t_679127329 floormove_t;
#line 602
enum __anonenum_result_e_342111047 {
    okok = 0,
    crushedcrushed = 1,
    pastdestpastdest = 2
} ;
#line 602 "p_spec.h"
typedef enum __anonenum_result_e_342111047 result_e;
#line 24 "/usr/include/bits/confname.h"
enum __anonenum_437032235___4 {
    _PC_LINK_MAX___4_PC_LINK_MAX___4 = 0,
    _PC_MAX_CANON___4_PC_MAX_CANON___4 = 1,
    _PC_MAX_INPUT___4_PC_MAX_INPUT___4 = 2,
    _PC_NAME_MAX___4_PC_NAME_MAX___4 = 3,
    _PC_PATH_MAX___4_PC_PATH_MAX___4 = 4,
    _PC_PIPE_BUF___4_PC_PIPE_BUF___4 = 5,
    _PC_CHOWN_RESTRICTED___4_PC_CHOWN_RESTRICTED___4 = 6,
    _PC_NO_TRUNC___4_PC_NO_TRUNC___4 = 7,
    _PC_VDISABLE___4_PC_VDISABLE___4 = 8,
    _PC_SYNC_IO___4_PC_SYNC_IO___4 = 9,
    _PC_ASYNC_IO___4_PC_ASYNC_IO___4 = 10,
    _PC_PRIO_IO___4_PC_PRIO_IO___4 = 11,
    _PC_SOCK_MAXBUF___4_PC_SOCK_MAXBUF___4 = 12,
    _PC_FILESIZEBITS___4_PC_FILESIZEBITS___4 = 13,
    _PC_REC_INCR_XFER_SIZE___4_PC_REC_INCR_XFER_SIZE___4 = 14,
    _PC_REC_MAX_XFER_SIZE___4_PC_REC_MAX_XFER_SIZE___4 = 15,
    _PC_REC_MIN_XFER_SIZE___4_PC_REC_MIN_XFER_SIZE___4 = 16,
    _PC_REC_XFER_ALIGN___4_PC_REC_XFER_ALIGN___4 = 17,
    _PC_ALLOC_SIZE_MIN___4_PC_ALLOC_SIZE_MIN___4 = 18,
    _PC_SYMLINK_MAX___4_PC_SYMLINK_MAX___4 = 19,
    _PC_2_SYMLINKS___4_PC_2_SYMLINKS___4 = 20
} ;
#line 71
enum __anonenum_315186338___4 {
    _SC_ARG_MAX___4_SC_ARG_MAX___4 = 0,
    _SC_CHILD_MAX___4_SC_CHILD_MAX___4 = 1,
    _SC_CLK_TCK___4_SC_CLK_TCK___4 = 2,
    _SC_NGROUPS_MAX___4_SC_NGROUPS_MAX___4 = 3,
    _SC_OPEN_MAX___4_SC_OPEN_MAX___4 = 4,
    _SC_STREAM_MAX___4_SC_STREAM_MAX___4 = 5,
    _SC_TZNAME_MAX___4_SC_TZNAME_MAX___4 = 6,
    _SC_JOB_CONTROL___4_SC_JOB_CONTROL___4 = 7,
    _SC_SAVED_IDS___4_SC_SAVED_IDS___4 = 8,
    _SC_REALTIME_SIGNALS___4_SC_REALTIME_SIGNALS___4 = 9,
    _SC_PRIORITY_SCHEDULING___4_SC_PRIORITY_SCHEDULING___4 = 10,
    _SC_TIMERS___4_SC_TIMERS___4 = 11,
    _SC_ASYNCHRONOUS_IO___4_SC_ASYNCHRONOUS_IO___4 = 12,
    _SC_PRIORITIZED_IO___4_SC_PRIORITIZED_IO___4 = 13,
    _SC_SYNCHRONIZED_IO___4_SC_SYNCHRONIZED_IO___4 = 14,
    _SC_FSYNC___4_SC_FSYNC___4 = 15,
    _SC_MAPPED_FILES___4_SC_MAPPED_FILES___4 = 16,
    _SC_MEMLOCK___4_SC_MEMLOCK___4 = 17,
    _SC_MEMLOCK_RANGE___4_SC_MEMLOCK_RANGE___4 = 18,
    _SC_MEMORY_PROTECTION___4_SC_MEMORY_PROTECTION___4 = 19,
    _SC_MESSAGE_PASSING___4_SC_MESSAGE_PASSING___4 = 20,
    _SC_SEMAPHORES___4_SC_SEMAPHORES___4 = 21,
    _SC_SHARED_MEMORY_OBJECTS___4_SC_SHARED_MEMORY_OBJECTS___4 = 22,
    _SC_AIO_LISTIO_MAX___4_SC_AIO_LISTIO_MAX___4 = 23,
    _SC_AIO_MAX___4_SC_AIO_MAX___4 = 24,
    _SC_AIO_PRIO_DELTA_MAX___4_SC_AIO_PRIO_DELTA_MAX___4 = 25,
    _SC_DELAYTIMER_MAX___4_SC_DELAYTIMER_MAX___4 = 26,
    _SC_MQ_OPEN_MAX___4_SC_MQ_OPEN_MAX___4 = 27,
    _SC_MQ_PRIO_MAX___4_SC_MQ_PRIO_MAX___4 = 28,
    _SC_VERSION___4_SC_VERSION___4 = 29,
    _SC_PAGESIZE___4_SC_PAGESIZE___4 = 30,
    _SC_RTSIG_MAX___4_SC_RTSIG_MAX___4 = 31,
    _SC_SEM_NSEMS_MAX___4_SC_SEM_NSEMS_MAX___4 = 32,
    _SC_SEM_VALUE_MAX___4_SC_SEM_VALUE_MAX___4 = 33,
    _SC_SIGQUEUE_MAX___4_SC_SIGQUEUE_MAX___4 = 34,
    _SC_TIMER_MAX___4_SC_TIMER_MAX___4 = 35,
    _SC_BC_BASE_MAX___4_SC_BC_BASE_MAX___4 = 36,
    _SC_BC_DIM_MAX___4_SC_BC_DIM_MAX___4 = 37,
    _SC_BC_SCALE_MAX___4_SC_BC_SCALE_MAX___4 = 38,
    _SC_BC_STRING_MAX___4_SC_BC_STRING_MAX___4 = 39,
    _SC_COLL_WEIGHTS_MAX___4_SC_COLL_WEIGHTS_MAX___4 = 40,
    _SC_EQUIV_CLASS_MAX___4_SC_EQUIV_CLASS_MAX___4 = 41,
    _SC_EXPR_NEST_MAX___4_SC_EXPR_NEST_MAX___4 = 42,
    _SC_LINE_MAX___4_SC_LINE_MAX___4 = 43,
    _SC_RE_DUP_MAX___4_SC_RE_DUP_MAX___4 = 44,
    _SC_CHARCLASS_NAME_MAX___4_SC_CHARCLASS_NAME_MAX___4 = 45,
    _SC_2_VERSION___4_SC_2_VERSION___4 = 46,
    _SC_2_C_BIND___4_SC_2_C_BIND___4 = 47,
    _SC_2_C_DEV___4_SC_2_C_DEV___4 = 48,
    _SC_2_FORT_DEV___4_SC_2_FORT_DEV___4 = 49,
    _SC_2_FORT_RUN___4_SC_2_FORT_RUN___4 = 50,
    _SC_2_SW_DEV___4_SC_2_SW_DEV___4 = 51,
    _SC_2_LOCALEDEF___4_SC_2_LOCALEDEF___4 = 52,
    _SC_PII___4_SC_PII___4 = 53,
    _SC_PII_XTI___4_SC_PII_XTI___4 = 54,
    _SC_PII_SOCKET___4_SC_PII_SOCKET___4 = 55,
    _SC_PII_INTERNET___4_SC_PII_INTERNET___4 = 56,
    _SC_PII_OSI___4_SC_PII_OSI___4 = 57,
    _SC_POLL___4_SC_POLL___4 = 58,
    _SC_SELECT___4_SC_SELECT___4 = 59,
    _SC_UIO_MAXIOV___4_SC_UIO_MAXIOV___4 = 60,
    _SC_IOV_MAX___4_SC_IOV_MAX___4 = 60,
    _SC_PII_INTERNET_STREAM___4_SC_PII_INTERNET_STREAM___4 = 61,
    _SC_PII_INTERNET_DGRAM___4_SC_PII_INTERNET_DGRAM___4 = 62,
    _SC_PII_OSI_COTS___4_SC_PII_OSI_COTS___4 = 63,
    _SC_PII_OSI_CLTS___4_SC_PII_OSI_CLTS___4 = 64,
    _SC_PII_OSI_M___4_SC_PII_OSI_M___4 = 65,
    _SC_T_IOV_MAX___4_SC_T_IOV_MAX___4 = 66,
    _SC_THREADS___4_SC_THREADS___4 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___4_SC_THREAD_SAFE_FUNCTIONS___4 = 68,
    _SC_GETGR_R_SIZE_MAX___4_SC_GETGR_R_SIZE_MAX___4 = 69,
    _SC_GETPW_R_SIZE_MAX___4_SC_GETPW_R_SIZE_MAX___4 = 70,
    _SC_LOGIN_NAME_MAX___4_SC_LOGIN_NAME_MAX___4 = 71,
    _SC_TTY_NAME_MAX___4_SC_TTY_NAME_MAX___4 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___4_SC_THREAD_DESTRUCTOR_ITERATIONS___4 = 73,
    _SC_THREAD_KEYS_MAX___4_SC_THREAD_KEYS_MAX___4 = 74,
    _SC_THREAD_STACK_MIN___4_SC_THREAD_STACK_MIN___4 = 75,
    _SC_THREAD_THREADS_MAX___4_SC_THREAD_THREADS_MAX___4 = 76,
    _SC_THREAD_ATTR_STACKADDR___4_SC_THREAD_ATTR_STACKADDR___4 = 77,
    _SC_THREAD_ATTR_STACKSIZE___4_SC_THREAD_ATTR_STACKSIZE___4 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___4_SC_THREAD_PRIORITY_SCHEDULING___4 = 79,
    _SC_THREAD_PRIO_INHERIT___4_SC_THREAD_PRIO_INHERIT___4 = 80,
    _SC_THREAD_PRIO_PROTECT___4_SC_THREAD_PRIO_PROTECT___4 = 81,
    _SC_THREAD_PROCESS_SHARED___4_SC_THREAD_PROCESS_SHARED___4 = 82,
    _SC_NPROCESSORS_CONF___4_SC_NPROCESSORS_CONF___4 = 83,
    _SC_NPROCESSORS_ONLN___4_SC_NPROCESSORS_ONLN___4 = 84,
    _SC_PHYS_PAGES___4_SC_PHYS_PAGES___4 = 85,
    _SC_AVPHYS_PAGES___4_SC_AVPHYS_PAGES___4 = 86,
    _SC_ATEXIT_MAX___4_SC_ATEXIT_MAX___4 = 87,
    _SC_PASS_MAX___4_SC_PASS_MAX___4 = 88,
    _SC_XOPEN_VERSION___4_SC_XOPEN_VERSION___4 = 89,
    _SC_XOPEN_XCU_VERSION___4_SC_XOPEN_XCU_VERSION___4 = 90,
    _SC_XOPEN_UNIX___4_SC_XOPEN_UNIX___4 = 91,
    _SC_XOPEN_CRYPT___4_SC_XOPEN_CRYPT___4 = 92,
    _SC_XOPEN_ENH_I18N___4_SC_XOPEN_ENH_I18N___4 = 93,
    _SC_XOPEN_SHM___4_SC_XOPEN_SHM___4 = 94,
    _SC_2_CHAR_TERM___4_SC_2_CHAR_TERM___4 = 95,
    _SC_2_C_VERSION___4_SC_2_C_VERSION___4 = 96,
    _SC_2_UPE___4_SC_2_UPE___4 = 97,
    _SC_XOPEN_XPG2___4_SC_XOPEN_XPG2___4 = 98,
    _SC_XOPEN_XPG3___4_SC_XOPEN_XPG3___4 = 99,
    _SC_XOPEN_XPG4___4_SC_XOPEN_XPG4___4 = 100,
    _SC_CHAR_BIT___4_SC_CHAR_BIT___4 = 101,
    _SC_CHAR_MAX___4_SC_CHAR_MAX___4 = 102,
    _SC_CHAR_MIN___4_SC_CHAR_MIN___4 = 103,
    _SC_INT_MAX___4_SC_INT_MAX___4 = 104,
    _SC_INT_MIN___4_SC_INT_MIN___4 = 105,
    _SC_LONG_BIT___4_SC_LONG_BIT___4 = 106,
    _SC_WORD_BIT___4_SC_WORD_BIT___4 = 107,
    _SC_MB_LEN_MAX___4_SC_MB_LEN_MAX___4 = 108,
    _SC_NZERO___4_SC_NZERO___4 = 109,
    _SC_SSIZE_MAX___4_SC_SSIZE_MAX___4 = 110,
    _SC_SCHAR_MAX___4_SC_SCHAR_MAX___4 = 111,
    _SC_SCHAR_MIN___4_SC_SCHAR_MIN___4 = 112,
    _SC_SHRT_MAX___4_SC_SHRT_MAX___4 = 113,
    _SC_SHRT_MIN___4_SC_SHRT_MIN___4 = 114,
    _SC_UCHAR_MAX___4_SC_UCHAR_MAX___4 = 115,
    _SC_UINT_MAX___4_SC_UINT_MAX___4 = 116,
    _SC_ULONG_MAX___4_SC_ULONG_MAX___4 = 117,
    _SC_USHRT_MAX___4_SC_USHRT_MAX___4 = 118,
    _SC_NL_ARGMAX___4_SC_NL_ARGMAX___4 = 119,
    _SC_NL_LANGMAX___4_SC_NL_LANGMAX___4 = 120,
    _SC_NL_MSGMAX___4_SC_NL_MSGMAX___4 = 121,
    _SC_NL_NMAX___4_SC_NL_NMAX___4 = 122,
    _SC_NL_SETMAX___4_SC_NL_SETMAX___4 = 123,
    _SC_NL_TEXTMAX___4_SC_NL_TEXTMAX___4 = 124,
    _SC_XBS5_ILP32_OFF32___4_SC_XBS5_ILP32_OFF32___4 = 125,
    _SC_XBS5_ILP32_OFFBIG___4_SC_XBS5_ILP32_OFFBIG___4 = 126,
    _SC_XBS5_LP64_OFF64___4_SC_XBS5_LP64_OFF64___4 = 127,
    _SC_XBS5_LPBIG_OFFBIG___4_SC_XBS5_LPBIG_OFFBIG___4 = 128,
    _SC_XOPEN_LEGACY___4_SC_XOPEN_LEGACY___4 = 129,
    _SC_XOPEN_REALTIME___4_SC_XOPEN_REALTIME___4 = 130,
    _SC_XOPEN_REALTIME_THREADS___4_SC_XOPEN_REALTIME_THREADS___4 = 131,
    _SC_ADVISORY_INFO___4_SC_ADVISORY_INFO___4 = 132,
    _SC_BARRIERS___4_SC_BARRIERS___4 = 133,
    _SC_BASE___4_SC_BASE___4 = 134,
    _SC_C_LANG_SUPPORT___4_SC_C_LANG_SUPPORT___4 = 135,
    _SC_C_LANG_SUPPORT_R___4_SC_C_LANG_SUPPORT_R___4 = 136,
    _SC_CLOCK_SELECTION___4_SC_CLOCK_SELECTION___4 = 137,
    _SC_CPUTIME___4_SC_CPUTIME___4 = 138,
    _SC_THREAD_CPUTIME___4_SC_THREAD_CPUTIME___4 = 139,
    _SC_DEVICE_IO___4_SC_DEVICE_IO___4 = 140,
    _SC_DEVICE_SPECIFIC___4_SC_DEVICE_SPECIFIC___4 = 141,
    _SC_DEVICE_SPECIFIC_R___4_SC_DEVICE_SPECIFIC_R___4 = 142,
    _SC_FD_MGMT___4_SC_FD_MGMT___4 = 143,
    _SC_FIFO___4_SC_FIFO___4 = 144,
    _SC_PIPE___4_SC_PIPE___4 = 145,
    _SC_FILE_ATTRIBUTES___4_SC_FILE_ATTRIBUTES___4 = 146,
    _SC_FILE_LOCKING___4_SC_FILE_LOCKING___4 = 147,
    _SC_FILE_SYSTEM___4_SC_FILE_SYSTEM___4 = 148,
    _SC_MONOTONIC_CLOCK___4_SC_MONOTONIC_CLOCK___4 = 149,
    _SC_MULTI_PROCESS___4_SC_MULTI_PROCESS___4 = 150,
    _SC_SINGLE_PROCESS___4_SC_SINGLE_PROCESS___4 = 151,
    _SC_NETWORKING___4_SC_NETWORKING___4 = 152,
    _SC_READER_WRITER_LOCKS___4_SC_READER_WRITER_LOCKS___4 = 153,
    _SC_SPIN_LOCKS___4_SC_SPIN_LOCKS___4 = 154,
    _SC_REGEXP___4_SC_REGEXP___4 = 155,
    _SC_REGEX_VERSION___4_SC_REGEX_VERSION___4 = 156,
    _SC_SHELL___4_SC_SHELL___4 = 157,
    _SC_SIGNALS___4_SC_SIGNALS___4 = 158,
    _SC_SPAWN___4_SC_SPAWN___4 = 159,
    _SC_SPORADIC_SERVER___4_SC_SPORADIC_SERVER___4 = 160,
    _SC_THREAD_SPORADIC_SERVER___4_SC_THREAD_SPORADIC_SERVER___4 = 161,
    _SC_SYSTEM_DATABASE___4_SC_SYSTEM_DATABASE___4 = 162,
    _SC_SYSTEM_DATABASE_R___4_SC_SYSTEM_DATABASE_R___4 = 163,
    _SC_TIMEOUTS___4_SC_TIMEOUTS___4 = 164,
    _SC_TYPED_MEMORY_OBJECTS___4_SC_TYPED_MEMORY_OBJECTS___4 = 165,
    _SC_USER_GROUPS___4_SC_USER_GROUPS___4 = 166,
    _SC_USER_GROUPS_R___4_SC_USER_GROUPS_R___4 = 167,
    _SC_2_PBS___4_SC_2_PBS___4 = 168,
    _SC_2_PBS_ACCOUNTING___4_SC_2_PBS_ACCOUNTING___4 = 169,
    _SC_2_PBS_LOCATE___4_SC_2_PBS_LOCATE___4 = 170,
    _SC_2_PBS_MESSAGE___4_SC_2_PBS_MESSAGE___4 = 171,
    _SC_2_PBS_TRACK___4_SC_2_PBS_TRACK___4 = 172,
    _SC_SYMLOOP_MAX___4_SC_SYMLOOP_MAX___4 = 173,
    _SC_STREAMS___4_SC_STREAMS___4 = 174,
    _SC_2_PBS_CHECKPOINT___4_SC_2_PBS_CHECKPOINT___4 = 175,
    _SC_V6_ILP32_OFF32___4_SC_V6_ILP32_OFF32___4 = 176,
    _SC_V6_ILP32_OFFBIG___4_SC_V6_ILP32_OFFBIG___4 = 177,
    _SC_V6_LP64_OFF64___4_SC_V6_LP64_OFF64___4 = 178,
    _SC_V6_LPBIG_OFFBIG___4_SC_V6_LPBIG_OFFBIG___4 = 179,
    _SC_HOST_NAME_MAX___4_SC_HOST_NAME_MAX___4 = 180,
    _SC_TRACE___4_SC_TRACE___4 = 181,
    _SC_TRACE_EVENT_FILTER___4_SC_TRACE_EVENT_FILTER___4 = 182,
    _SC_TRACE_INHERIT___4_SC_TRACE_INHERIT___4 = 183,
    _SC_TRACE_LOG___4_SC_TRACE_LOG___4 = 184,
    _SC_LEVEL1_ICACHE_SIZE___4_SC_LEVEL1_ICACHE_SIZE___4 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___4_SC_LEVEL1_ICACHE_ASSOC___4 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___4_SC_LEVEL1_ICACHE_LINESIZE___4 = 187,
    _SC_LEVEL1_DCACHE_SIZE___4_SC_LEVEL1_DCACHE_SIZE___4 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___4_SC_LEVEL1_DCACHE_ASSOC___4 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___4_SC_LEVEL1_DCACHE_LINESIZE___4 = 190,
    _SC_LEVEL2_CACHE_SIZE___4_SC_LEVEL2_CACHE_SIZE___4 = 191,
    _SC_LEVEL2_CACHE_ASSOC___4_SC_LEVEL2_CACHE_ASSOC___4 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___4_SC_LEVEL2_CACHE_LINESIZE___4 = 193,
    _SC_LEVEL3_CACHE_SIZE___4_SC_LEVEL3_CACHE_SIZE___4 = 194,
    _SC_LEVEL3_CACHE_ASSOC___4_SC_LEVEL3_CACHE_ASSOC___4 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___4_SC_LEVEL3_CACHE_LINESIZE___4 = 196,
    _SC_LEVEL4_CACHE_SIZE___4_SC_LEVEL4_CACHE_SIZE___4 = 197,
    _SC_LEVEL4_CACHE_ASSOC___4_SC_LEVEL4_CACHE_ASSOC___4 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___4_SC_LEVEL4_CACHE_LINESIZE___4 = 199,
    _SC_IPV6___4_SC_IPV6___4 = 235,
    _SC_RAW_SOCKETS___4_SC_RAW_SOCKETS___4 = 236,
    _SC_V7_ILP32_OFF32___4_SC_V7_ILP32_OFF32___4 = 237,
    _SC_V7_ILP32_OFFBIG___4_SC_V7_ILP32_OFFBIG___4 = 238,
    _SC_V7_LP64_OFF64___4_SC_V7_LP64_OFF64___4 = 239,
    _SC_V7_LPBIG_OFFBIG___4_SC_V7_LPBIG_OFFBIG___4 = 240,
    _SC_SS_REPL_MAX___4_SC_SS_REPL_MAX___4 = 241,
    _SC_TRACE_EVENT_NAME_MAX___4_SC_TRACE_EVENT_NAME_MAX___4 = 242,
    _SC_TRACE_NAME_MAX___4_SC_TRACE_NAME_MAX___4 = 243,
    _SC_TRACE_SYS_MAX___4_SC_TRACE_SYS_MAX___4 = 244,
    _SC_TRACE_USER_EVENT_MAX___4_SC_TRACE_USER_EVENT_MAX___4 = 245,
    _SC_XOPEN_STREAMS___4_SC_XOPEN_STREAMS___4 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___4_SC_THREAD_ROBUST_PRIO_INHERIT___4 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___4_SC_THREAD_ROBUST_PRIO_PROTECT___4 = 248,
    _SC_MINSIGSTKSZ___4_SC_MINSIGSTKSZ___4 = 249,
    _SC_SIGSTKSZ___4_SC_SIGSTKSZ___4 = 250
} ;
#line 539
enum __anonenum_875524036___4 {
    _CS_PATH___4_CS_PATH___4 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___4_CS_V6_WIDTH_RESTRICTED_ENVS___4 = 1,
    _CS_GNU_LIBC_VERSION___4_CS_GNU_LIBC_VERSION___4 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___4_CS_GNU_LIBPTHREAD_VERSION___4 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___4_CS_V5_WIDTH_RESTRICTED_ENVS___4 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___4_CS_V7_WIDTH_RESTRICTED_ENVS___4 = 5,
    _CS_LFS_CFLAGS___4_CS_LFS_CFLAGS___4 = 1000,
    _CS_LFS_LDFLAGS___4_CS_LFS_LDFLAGS___4 = 1001,
    _CS_LFS_LIBS___4_CS_LFS_LIBS___4 = 1002,
    _CS_LFS_LINTFLAGS___4_CS_LFS_LINTFLAGS___4 = 1003,
    _CS_LFS64_CFLAGS___4_CS_LFS64_CFLAGS___4 = 1004,
    _CS_LFS64_LDFLAGS___4_CS_LFS64_LDFLAGS___4 = 1005,
    _CS_LFS64_LIBS___4_CS_LFS64_LIBS___4 = 1006,
    _CS_LFS64_LINTFLAGS___4_CS_LFS64_LINTFLAGS___4 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___4_CS_XBS5_ILP32_OFF32_CFLAGS___4 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___4_CS_XBS5_ILP32_OFF32_LDFLAGS___4 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___4_CS_XBS5_ILP32_OFF32_LIBS___4 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___4_CS_XBS5_ILP32_OFF32_LINTFLAGS___4 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___4_CS_XBS5_ILP32_OFFBIG_CFLAGS___4 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___4_CS_XBS5_ILP32_OFFBIG_LDFLAGS___4 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___4_CS_XBS5_ILP32_OFFBIG_LIBS___4 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___4_CS_XBS5_ILP32_OFFBIG_LINTFLAGS___4 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___4_CS_XBS5_LP64_OFF64_CFLAGS___4 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___4_CS_XBS5_LP64_OFF64_LDFLAGS___4 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___4_CS_XBS5_LP64_OFF64_LIBS___4 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___4_CS_XBS5_LP64_OFF64_LINTFLAGS___4 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___4_CS_XBS5_LPBIG_OFFBIG_CFLAGS___4 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___4_CS_XBS5_LPBIG_OFFBIG_LDFLAGS___4 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___4_CS_XBS5_LPBIG_OFFBIG_LIBS___4 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___4_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___4 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___4_CS_POSIX_V6_ILP32_OFF32_CFLAGS___4 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___4_CS_POSIX_V6_ILP32_OFF32_LDFLAGS___4 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___4_CS_POSIX_V6_ILP32_OFF32_LIBS___4 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___4_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___4 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___4_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___4 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___4_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___4 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___4_CS_POSIX_V6_ILP32_OFFBIG_LIBS___4 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___4_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___4 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___4_CS_POSIX_V6_LP64_OFF64_CFLAGS___4 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___4_CS_POSIX_V6_LP64_OFF64_LDFLAGS___4 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___4_CS_POSIX_V6_LP64_OFF64_LIBS___4 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___4_CS_POSIX_V6_LP64_OFF64_LINTFLAGS___4 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___4_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___4 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___4_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___4 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___4_CS_POSIX_V6_LPBIG_OFFBIG_LIBS___4 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___4_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___4 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___4_CS_POSIX_V7_ILP32_OFF32_CFLAGS___4 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___4_CS_POSIX_V7_ILP32_OFF32_LDFLAGS___4 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___4_CS_POSIX_V7_ILP32_OFF32_LIBS___4 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___4_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___4 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___4_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___4 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___4_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___4 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___4_CS_POSIX_V7_ILP32_OFFBIG_LIBS___4 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___4_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___4 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___4_CS_POSIX_V7_LP64_OFF64_CFLAGS___4 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___4_CS_POSIX_V7_LP64_OFF64_LDFLAGS___4 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___4_CS_POSIX_V7_LP64_OFF64_LIBS___4 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___4_CS_POSIX_V7_LP64_OFF64_LINTFLAGS___4 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___4_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___4 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___4_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___4 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___4_CS_POSIX_V7_LPBIG_OFFBIG_LIBS___4 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___4_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___4 = 1147,
    _CS_V6_ENV___4_CS_V6_ENV___4 = 1148,
    _CS_V7_ENV___4_CS_V7_ENV___4 = 1149
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum_18926444___0 {
    _ISupper___0_ISupper___0 = 256,
    _ISlower___0_ISlower___0 = 512,
    _ISalpha___0_ISalpha___0 = 1024,
    _ISdigit___0_ISdigit___0 = 2048,
    _ISxdigit___0_ISxdigit___0 = 4096,
    _ISspace___0_ISspace___0 = 8192,
    _ISprint___0_ISprint___0 = 16384,
    _ISgraph___0_ISgraph___0 = 32768,
    _ISblank___0_ISblank___0 = 1,
    _IScntrl___0_IScntrl___0 = 2,
    _ISpunct___0_ISpunct___0 = 4,
    _ISalnum___0_ISalnum___0 = 8
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___11 {
    VERSION___11VERSION___11 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___10 {
    FP_NAN___10FP_NAN___10 = 0,
    FP_INFINITE___10FP_INFINITE___10 = 1,
    FP_ZERO___10FP_ZERO___10 = 2,
    FP_SUBNORMAL___10FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10FP_NORMAL___10 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___9 {
    ML_LABEL___9ML_LABEL___9 = 0,
    ML_THINGS___9ML_THINGS___9 = 1,
    ML_LINEDEFS___9ML_LINEDEFS___9 = 2,
    ML_SIDEDEFS___9ML_SIDEDEFS___9 = 3,
    ML_VERTEXES___9ML_VERTEXES___9 = 4,
    ML_SEGS___9ML_SEGS___9 = 5,
    ML_SSECTORS___9ML_SSECTORS___9 = 6,
    ML_NODES___9ML_NODES___9 = 7,
    ML_SECTORS___9ML_SECTORS___9 = 8,
    ML_REJECT___9ML_REJECT___9 = 9,
    ML_BLOCKMAP___9ML_BLOCKMAP___9 = 10
} ;
#line 140 "m_menu.c"
struct __anonstruct_menuitem_t_326938782 {
   short status ;
   char name[10] ;
   void (*routine)(int choice ) ;
   char alphaKey ;
};
#line 140 "m_menu.c"
typedef struct __anonstruct_menuitem_t_326938782 menuitem_t;
#line 158 "m_menu.c"
struct menu_s {
   short numitems ;
   struct menu_s *prevMenu ;
   menuitem_t *menuitems ;
   void (*routine)() ;
   short x ;
   short y ;
   short lastOn ;
};
#line 158 "m_menu.c"
typedef struct menu_s menu_t;
#line 239
enum __anonenum_main_e_112973811 {
    newgamenewgame = 0,
    optionsoptions = 1,
    loadgameloadgame = 2,
    savegamesavegame = 3,
    readthisreadthis = 4,
    quitdoomquitdoom = 5,
    main_endmain_end = 6
} ;
#line 275
enum __anonenum_episodes_e_479592101 {
    ep1ep1 = 0,
    ep2ep2 = 1,
    ep3ep3 = 2,
    ep4ep4 = 3,
    ep_endep_end = 4
} ;
#line 305
enum __anonenum_newgame_e_993994851 {
    killthingskillthings = 0,
    tooroughtoorough = 1,
    hurtmehurtme = 2,
    violenceviolence = 3,
    nightmarenightmare = 4,
    newg_endnewg_end = 5
} ;
#line 339
enum __anonenum_options_e_766045714 {
    endgameendgame = 0,
    messagesmessages = 1,
    detaildetail = 2,
    scrnsizescrnsize = 3,
    option_empty1option_empty1 = 4,
    mousesensmousesens = 5,
    option_empty2option_empty2 = 6,
    soundvolsoundvol = 7,
    opt_endopt_end = 8
} ;
#line 377
enum __anonenum_read_e_203113283 {
    rdthsempty1rdthsempty1 = 0,
    read1_endread1_end = 1
} ;
#line 398
enum __anonenum_read_e2_844223810 {
    rdthsempty2rdthsempty2 = 0,
    read2_endread2_end = 1
} ;
#line 422
enum __anonenum_sound_e_662858041 {
    sfx_volsfx_vol = 0,
    sfx_empty1sfx_empty1 = 1,
    music_volmusic_vol = 2,
    sfx_empty2sfx_empty2 = 3,
    sound_endsound_end = 4
} ;
#line 452
enum __anonenum_load_e_679472234 {
    load1load1 = 0,
    load2load2 = 1,
    load3load3 = 2,
    load4load4 = 3,
    load5load5 = 4,
    load6load6 = 5,
    load_endload_end = 6
} ;
#line 24 "/usr/include/bits/confname.h"
enum __anonenum_437032235___5 {
    _PC_LINK_MAX___5_PC_LINK_MAX___5 = 0,
    _PC_MAX_CANON___5_PC_MAX_CANON___5 = 1,
    _PC_MAX_INPUT___5_PC_MAX_INPUT___5 = 2,
    _PC_NAME_MAX___5_PC_NAME_MAX___5 = 3,
    _PC_PATH_MAX___5_PC_PATH_MAX___5 = 4,
    _PC_PIPE_BUF___5_PC_PIPE_BUF___5 = 5,
    _PC_CHOWN_RESTRICTED___5_PC_CHOWN_RESTRICTED___5 = 6,
    _PC_NO_TRUNC___5_PC_NO_TRUNC___5 = 7,
    _PC_VDISABLE___5_PC_VDISABLE___5 = 8,
    _PC_SYNC_IO___5_PC_SYNC_IO___5 = 9,
    _PC_ASYNC_IO___5_PC_ASYNC_IO___5 = 10,
    _PC_PRIO_IO___5_PC_PRIO_IO___5 = 11,
    _PC_SOCK_MAXBUF___5_PC_SOCK_MAXBUF___5 = 12,
    _PC_FILESIZEBITS___5_PC_FILESIZEBITS___5 = 13,
    _PC_REC_INCR_XFER_SIZE___5_PC_REC_INCR_XFER_SIZE___5 = 14,
    _PC_REC_MAX_XFER_SIZE___5_PC_REC_MAX_XFER_SIZE___5 = 15,
    _PC_REC_MIN_XFER_SIZE___5_PC_REC_MIN_XFER_SIZE___5 = 16,
    _PC_REC_XFER_ALIGN___5_PC_REC_XFER_ALIGN___5 = 17,
    _PC_ALLOC_SIZE_MIN___5_PC_ALLOC_SIZE_MIN___5 = 18,
    _PC_SYMLINK_MAX___5_PC_SYMLINK_MAX___5 = 19,
    _PC_2_SYMLINKS___5_PC_2_SYMLINKS___5 = 20
} ;
#line 71
enum __anonenum_315186338___5 {
    _SC_ARG_MAX___5_SC_ARG_MAX___5 = 0,
    _SC_CHILD_MAX___5_SC_CHILD_MAX___5 = 1,
    _SC_CLK_TCK___5_SC_CLK_TCK___5 = 2,
    _SC_NGROUPS_MAX___5_SC_NGROUPS_MAX___5 = 3,
    _SC_OPEN_MAX___5_SC_OPEN_MAX___5 = 4,
    _SC_STREAM_MAX___5_SC_STREAM_MAX___5 = 5,
    _SC_TZNAME_MAX___5_SC_TZNAME_MAX___5 = 6,
    _SC_JOB_CONTROL___5_SC_JOB_CONTROL___5 = 7,
    _SC_SAVED_IDS___5_SC_SAVED_IDS___5 = 8,
    _SC_REALTIME_SIGNALS___5_SC_REALTIME_SIGNALS___5 = 9,
    _SC_PRIORITY_SCHEDULING___5_SC_PRIORITY_SCHEDULING___5 = 10,
    _SC_TIMERS___5_SC_TIMERS___5 = 11,
    _SC_ASYNCHRONOUS_IO___5_SC_ASYNCHRONOUS_IO___5 = 12,
    _SC_PRIORITIZED_IO___5_SC_PRIORITIZED_IO___5 = 13,
    _SC_SYNCHRONIZED_IO___5_SC_SYNCHRONIZED_IO___5 = 14,
    _SC_FSYNC___5_SC_FSYNC___5 = 15,
    _SC_MAPPED_FILES___5_SC_MAPPED_FILES___5 = 16,
    _SC_MEMLOCK___5_SC_MEMLOCK___5 = 17,
    _SC_MEMLOCK_RANGE___5_SC_MEMLOCK_RANGE___5 = 18,
    _SC_MEMORY_PROTECTION___5_SC_MEMORY_PROTECTION___5 = 19,
    _SC_MESSAGE_PASSING___5_SC_MESSAGE_PASSING___5 = 20,
    _SC_SEMAPHORES___5_SC_SEMAPHORES___5 = 21,
    _SC_SHARED_MEMORY_OBJECTS___5_SC_SHARED_MEMORY_OBJECTS___5 = 22,
    _SC_AIO_LISTIO_MAX___5_SC_AIO_LISTIO_MAX___5 = 23,
    _SC_AIO_MAX___5_SC_AIO_MAX___5 = 24,
    _SC_AIO_PRIO_DELTA_MAX___5_SC_AIO_PRIO_DELTA_MAX___5 = 25,
    _SC_DELAYTIMER_MAX___5_SC_DELAYTIMER_MAX___5 = 26,
    _SC_MQ_OPEN_MAX___5_SC_MQ_OPEN_MAX___5 = 27,
    _SC_MQ_PRIO_MAX___5_SC_MQ_PRIO_MAX___5 = 28,
    _SC_VERSION___5_SC_VERSION___5 = 29,
    _SC_PAGESIZE___5_SC_PAGESIZE___5 = 30,
    _SC_RTSIG_MAX___5_SC_RTSIG_MAX___5 = 31,
    _SC_SEM_NSEMS_MAX___5_SC_SEM_NSEMS_MAX___5 = 32,
    _SC_SEM_VALUE_MAX___5_SC_SEM_VALUE_MAX___5 = 33,
    _SC_SIGQUEUE_MAX___5_SC_SIGQUEUE_MAX___5 = 34,
    _SC_TIMER_MAX___5_SC_TIMER_MAX___5 = 35,
    _SC_BC_BASE_MAX___5_SC_BC_BASE_MAX___5 = 36,
    _SC_BC_DIM_MAX___5_SC_BC_DIM_MAX___5 = 37,
    _SC_BC_SCALE_MAX___5_SC_BC_SCALE_MAX___5 = 38,
    _SC_BC_STRING_MAX___5_SC_BC_STRING_MAX___5 = 39,
    _SC_COLL_WEIGHTS_MAX___5_SC_COLL_WEIGHTS_MAX___5 = 40,
    _SC_EQUIV_CLASS_MAX___5_SC_EQUIV_CLASS_MAX___5 = 41,
    _SC_EXPR_NEST_MAX___5_SC_EXPR_NEST_MAX___5 = 42,
    _SC_LINE_MAX___5_SC_LINE_MAX___5 = 43,
    _SC_RE_DUP_MAX___5_SC_RE_DUP_MAX___5 = 44,
    _SC_CHARCLASS_NAME_MAX___5_SC_CHARCLASS_NAME_MAX___5 = 45,
    _SC_2_VERSION___5_SC_2_VERSION___5 = 46,
    _SC_2_C_BIND___5_SC_2_C_BIND___5 = 47,
    _SC_2_C_DEV___5_SC_2_C_DEV___5 = 48,
    _SC_2_FORT_DEV___5_SC_2_FORT_DEV___5 = 49,
    _SC_2_FORT_RUN___5_SC_2_FORT_RUN___5 = 50,
    _SC_2_SW_DEV___5_SC_2_SW_DEV___5 = 51,
    _SC_2_LOCALEDEF___5_SC_2_LOCALEDEF___5 = 52,
    _SC_PII___5_SC_PII___5 = 53,
    _SC_PII_XTI___5_SC_PII_XTI___5 = 54,
    _SC_PII_SOCKET___5_SC_PII_SOCKET___5 = 55,
    _SC_PII_INTERNET___5_SC_PII_INTERNET___5 = 56,
    _SC_PII_OSI___5_SC_PII_OSI___5 = 57,
    _SC_POLL___5_SC_POLL___5 = 58,
    _SC_SELECT___5_SC_SELECT___5 = 59,
    _SC_UIO_MAXIOV___5_SC_UIO_MAXIOV___5 = 60,
    _SC_IOV_MAX___5_SC_IOV_MAX___5 = 60,
    _SC_PII_INTERNET_STREAM___5_SC_PII_INTERNET_STREAM___5 = 61,
    _SC_PII_INTERNET_DGRAM___5_SC_PII_INTERNET_DGRAM___5 = 62,
    _SC_PII_OSI_COTS___5_SC_PII_OSI_COTS___5 = 63,
    _SC_PII_OSI_CLTS___5_SC_PII_OSI_CLTS___5 = 64,
    _SC_PII_OSI_M___5_SC_PII_OSI_M___5 = 65,
    _SC_T_IOV_MAX___5_SC_T_IOV_MAX___5 = 66,
    _SC_THREADS___5_SC_THREADS___5 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___5_SC_THREAD_SAFE_FUNCTIONS___5 = 68,
    _SC_GETGR_R_SIZE_MAX___5_SC_GETGR_R_SIZE_MAX___5 = 69,
    _SC_GETPW_R_SIZE_MAX___5_SC_GETPW_R_SIZE_MAX___5 = 70,
    _SC_LOGIN_NAME_MAX___5_SC_LOGIN_NAME_MAX___5 = 71,
    _SC_TTY_NAME_MAX___5_SC_TTY_NAME_MAX___5 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___5_SC_THREAD_DESTRUCTOR_ITERATIONS___5 = 73,
    _SC_THREAD_KEYS_MAX___5_SC_THREAD_KEYS_MAX___5 = 74,
    _SC_THREAD_STACK_MIN___5_SC_THREAD_STACK_MIN___5 = 75,
    _SC_THREAD_THREADS_MAX___5_SC_THREAD_THREADS_MAX___5 = 76,
    _SC_THREAD_ATTR_STACKADDR___5_SC_THREAD_ATTR_STACKADDR___5 = 77,
    _SC_THREAD_ATTR_STACKSIZE___5_SC_THREAD_ATTR_STACKSIZE___5 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___5_SC_THREAD_PRIORITY_SCHEDULING___5 = 79,
    _SC_THREAD_PRIO_INHERIT___5_SC_THREAD_PRIO_INHERIT___5 = 80,
    _SC_THREAD_PRIO_PROTECT___5_SC_THREAD_PRIO_PROTECT___5 = 81,
    _SC_THREAD_PROCESS_SHARED___5_SC_THREAD_PROCESS_SHARED___5 = 82,
    _SC_NPROCESSORS_CONF___5_SC_NPROCESSORS_CONF___5 = 83,
    _SC_NPROCESSORS_ONLN___5_SC_NPROCESSORS_ONLN___5 = 84,
    _SC_PHYS_PAGES___5_SC_PHYS_PAGES___5 = 85,
    _SC_AVPHYS_PAGES___5_SC_AVPHYS_PAGES___5 = 86,
    _SC_ATEXIT_MAX___5_SC_ATEXIT_MAX___5 = 87,
    _SC_PASS_MAX___5_SC_PASS_MAX___5 = 88,
    _SC_XOPEN_VERSION___5_SC_XOPEN_VERSION___5 = 89,
    _SC_XOPEN_XCU_VERSION___5_SC_XOPEN_XCU_VERSION___5 = 90,
    _SC_XOPEN_UNIX___5_SC_XOPEN_UNIX___5 = 91,
    _SC_XOPEN_CRYPT___5_SC_XOPEN_CRYPT___5 = 92,
    _SC_XOPEN_ENH_I18N___5_SC_XOPEN_ENH_I18N___5 = 93,
    _SC_XOPEN_SHM___5_SC_XOPEN_SHM___5 = 94,
    _SC_2_CHAR_TERM___5_SC_2_CHAR_TERM___5 = 95,
    _SC_2_C_VERSION___5_SC_2_C_VERSION___5 = 96,
    _SC_2_UPE___5_SC_2_UPE___5 = 97,
    _SC_XOPEN_XPG2___5_SC_XOPEN_XPG2___5 = 98,
    _SC_XOPEN_XPG3___5_SC_XOPEN_XPG3___5 = 99,
    _SC_XOPEN_XPG4___5_SC_XOPEN_XPG4___5 = 100,
    _SC_CHAR_BIT___5_SC_CHAR_BIT___5 = 101,
    _SC_CHAR_MAX___5_SC_CHAR_MAX___5 = 102,
    _SC_CHAR_MIN___5_SC_CHAR_MIN___5 = 103,
    _SC_INT_MAX___5_SC_INT_MAX___5 = 104,
    _SC_INT_MIN___5_SC_INT_MIN___5 = 105,
    _SC_LONG_BIT___5_SC_LONG_BIT___5 = 106,
    _SC_WORD_BIT___5_SC_WORD_BIT___5 = 107,
    _SC_MB_LEN_MAX___5_SC_MB_LEN_MAX___5 = 108,
    _SC_NZERO___5_SC_NZERO___5 = 109,
    _SC_SSIZE_MAX___5_SC_SSIZE_MAX___5 = 110,
    _SC_SCHAR_MAX___5_SC_SCHAR_MAX___5 = 111,
    _SC_SCHAR_MIN___5_SC_SCHAR_MIN___5 = 112,
    _SC_SHRT_MAX___5_SC_SHRT_MAX___5 = 113,
    _SC_SHRT_MIN___5_SC_SHRT_MIN___5 = 114,
    _SC_UCHAR_MAX___5_SC_UCHAR_MAX___5 = 115,
    _SC_UINT_MAX___5_SC_UINT_MAX___5 = 116,
    _SC_ULONG_MAX___5_SC_ULONG_MAX___5 = 117,
    _SC_USHRT_MAX___5_SC_USHRT_MAX___5 = 118,
    _SC_NL_ARGMAX___5_SC_NL_ARGMAX___5 = 119,
    _SC_NL_LANGMAX___5_SC_NL_LANGMAX___5 = 120,
    _SC_NL_MSGMAX___5_SC_NL_MSGMAX___5 = 121,
    _SC_NL_NMAX___5_SC_NL_NMAX___5 = 122,
    _SC_NL_SETMAX___5_SC_NL_SETMAX___5 = 123,
    _SC_NL_TEXTMAX___5_SC_NL_TEXTMAX___5 = 124,
    _SC_XBS5_ILP32_OFF32___5_SC_XBS5_ILP32_OFF32___5 = 125,
    _SC_XBS5_ILP32_OFFBIG___5_SC_XBS5_ILP32_OFFBIG___5 = 126,
    _SC_XBS5_LP64_OFF64___5_SC_XBS5_LP64_OFF64___5 = 127,
    _SC_XBS5_LPBIG_OFFBIG___5_SC_XBS5_LPBIG_OFFBIG___5 = 128,
    _SC_XOPEN_LEGACY___5_SC_XOPEN_LEGACY___5 = 129,
    _SC_XOPEN_REALTIME___5_SC_XOPEN_REALTIME___5 = 130,
    _SC_XOPEN_REALTIME_THREADS___5_SC_XOPEN_REALTIME_THREADS___5 = 131,
    _SC_ADVISORY_INFO___5_SC_ADVISORY_INFO___5 = 132,
    _SC_BARRIERS___5_SC_BARRIERS___5 = 133,
    _SC_BASE___5_SC_BASE___5 = 134,
    _SC_C_LANG_SUPPORT___5_SC_C_LANG_SUPPORT___5 = 135,
    _SC_C_LANG_SUPPORT_R___5_SC_C_LANG_SUPPORT_R___5 = 136,
    _SC_CLOCK_SELECTION___5_SC_CLOCK_SELECTION___5 = 137,
    _SC_CPUTIME___5_SC_CPUTIME___5 = 138,
    _SC_THREAD_CPUTIME___5_SC_THREAD_CPUTIME___5 = 139,
    _SC_DEVICE_IO___5_SC_DEVICE_IO___5 = 140,
    _SC_DEVICE_SPECIFIC___5_SC_DEVICE_SPECIFIC___5 = 141,
    _SC_DEVICE_SPECIFIC_R___5_SC_DEVICE_SPECIFIC_R___5 = 142,
    _SC_FD_MGMT___5_SC_FD_MGMT___5 = 143,
    _SC_FIFO___5_SC_FIFO___5 = 144,
    _SC_PIPE___5_SC_PIPE___5 = 145,
    _SC_FILE_ATTRIBUTES___5_SC_FILE_ATTRIBUTES___5 = 146,
    _SC_FILE_LOCKING___5_SC_FILE_LOCKING___5 = 147,
    _SC_FILE_SYSTEM___5_SC_FILE_SYSTEM___5 = 148,
    _SC_MONOTONIC_CLOCK___5_SC_MONOTONIC_CLOCK___5 = 149,
    _SC_MULTI_PROCESS___5_SC_MULTI_PROCESS___5 = 150,
    _SC_SINGLE_PROCESS___5_SC_SINGLE_PROCESS___5 = 151,
    _SC_NETWORKING___5_SC_NETWORKING___5 = 152,
    _SC_READER_WRITER_LOCKS___5_SC_READER_WRITER_LOCKS___5 = 153,
    _SC_SPIN_LOCKS___5_SC_SPIN_LOCKS___5 = 154,
    _SC_REGEXP___5_SC_REGEXP___5 = 155,
    _SC_REGEX_VERSION___5_SC_REGEX_VERSION___5 = 156,
    _SC_SHELL___5_SC_SHELL___5 = 157,
    _SC_SIGNALS___5_SC_SIGNALS___5 = 158,
    _SC_SPAWN___5_SC_SPAWN___5 = 159,
    _SC_SPORADIC_SERVER___5_SC_SPORADIC_SERVER___5 = 160,
    _SC_THREAD_SPORADIC_SERVER___5_SC_THREAD_SPORADIC_SERVER___5 = 161,
    _SC_SYSTEM_DATABASE___5_SC_SYSTEM_DATABASE___5 = 162,
    _SC_SYSTEM_DATABASE_R___5_SC_SYSTEM_DATABASE_R___5 = 163,
    _SC_TIMEOUTS___5_SC_TIMEOUTS___5 = 164,
    _SC_TYPED_MEMORY_OBJECTS___5_SC_TYPED_MEMORY_OBJECTS___5 = 165,
    _SC_USER_GROUPS___5_SC_USER_GROUPS___5 = 166,
    _SC_USER_GROUPS_R___5_SC_USER_GROUPS_R___5 = 167,
    _SC_2_PBS___5_SC_2_PBS___5 = 168,
    _SC_2_PBS_ACCOUNTING___5_SC_2_PBS_ACCOUNTING___5 = 169,
    _SC_2_PBS_LOCATE___5_SC_2_PBS_LOCATE___5 = 170,
    _SC_2_PBS_MESSAGE___5_SC_2_PBS_MESSAGE___5 = 171,
    _SC_2_PBS_TRACK___5_SC_2_PBS_TRACK___5 = 172,
    _SC_SYMLOOP_MAX___5_SC_SYMLOOP_MAX___5 = 173,
    _SC_STREAMS___5_SC_STREAMS___5 = 174,
    _SC_2_PBS_CHECKPOINT___5_SC_2_PBS_CHECKPOINT___5 = 175,
    _SC_V6_ILP32_OFF32___5_SC_V6_ILP32_OFF32___5 = 176,
    _SC_V6_ILP32_OFFBIG___5_SC_V6_ILP32_OFFBIG___5 = 177,
    _SC_V6_LP64_OFF64___5_SC_V6_LP64_OFF64___5 = 178,
    _SC_V6_LPBIG_OFFBIG___5_SC_V6_LPBIG_OFFBIG___5 = 179,
    _SC_HOST_NAME_MAX___5_SC_HOST_NAME_MAX___5 = 180,
    _SC_TRACE___5_SC_TRACE___5 = 181,
    _SC_TRACE_EVENT_FILTER___5_SC_TRACE_EVENT_FILTER___5 = 182,
    _SC_TRACE_INHERIT___5_SC_TRACE_INHERIT___5 = 183,
    _SC_TRACE_LOG___5_SC_TRACE_LOG___5 = 184,
    _SC_LEVEL1_ICACHE_SIZE___5_SC_LEVEL1_ICACHE_SIZE___5 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___5_SC_LEVEL1_ICACHE_ASSOC___5 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___5_SC_LEVEL1_ICACHE_LINESIZE___5 = 187,
    _SC_LEVEL1_DCACHE_SIZE___5_SC_LEVEL1_DCACHE_SIZE___5 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___5_SC_LEVEL1_DCACHE_ASSOC___5 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___5_SC_LEVEL1_DCACHE_LINESIZE___5 = 190,
    _SC_LEVEL2_CACHE_SIZE___5_SC_LEVEL2_CACHE_SIZE___5 = 191,
    _SC_LEVEL2_CACHE_ASSOC___5_SC_LEVEL2_CACHE_ASSOC___5 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___5_SC_LEVEL2_CACHE_LINESIZE___5 = 193,
    _SC_LEVEL3_CACHE_SIZE___5_SC_LEVEL3_CACHE_SIZE___5 = 194,
    _SC_LEVEL3_CACHE_ASSOC___5_SC_LEVEL3_CACHE_ASSOC___5 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___5_SC_LEVEL3_CACHE_LINESIZE___5 = 196,
    _SC_LEVEL4_CACHE_SIZE___5_SC_LEVEL4_CACHE_SIZE___5 = 197,
    _SC_LEVEL4_CACHE_ASSOC___5_SC_LEVEL4_CACHE_ASSOC___5 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___5_SC_LEVEL4_CACHE_LINESIZE___5 = 199,
    _SC_IPV6___5_SC_IPV6___5 = 235,
    _SC_RAW_SOCKETS___5_SC_RAW_SOCKETS___5 = 236,
    _SC_V7_ILP32_OFF32___5_SC_V7_ILP32_OFF32___5 = 237,
    _SC_V7_ILP32_OFFBIG___5_SC_V7_ILP32_OFFBIG___5 = 238,
    _SC_V7_LP64_OFF64___5_SC_V7_LP64_OFF64___5 = 239,
    _SC_V7_LPBIG_OFFBIG___5_SC_V7_LPBIG_OFFBIG___5 = 240,
    _SC_SS_REPL_MAX___5_SC_SS_REPL_MAX___5 = 241,
    _SC_TRACE_EVENT_NAME_MAX___5_SC_TRACE_EVENT_NAME_MAX___5 = 242,
    _SC_TRACE_NAME_MAX___5_SC_TRACE_NAME_MAX___5 = 243,
    _SC_TRACE_SYS_MAX___5_SC_TRACE_SYS_MAX___5 = 244,
    _SC_TRACE_USER_EVENT_MAX___5_SC_TRACE_USER_EVENT_MAX___5 = 245,
    _SC_XOPEN_STREAMS___5_SC_XOPEN_STREAMS___5 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___5_SC_THREAD_ROBUST_PRIO_INHERIT___5 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___5_SC_THREAD_ROBUST_PRIO_PROTECT___5 = 248,
    _SC_MINSIGSTKSZ___5_SC_MINSIGSTKSZ___5 = 249,
    _SC_SIGSTKSZ___5_SC_SIGSTKSZ___5 = 250
} ;
#line 539
enum __anonenum_875524036___5 {
    _CS_PATH___5_CS_PATH___5 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___5_CS_V6_WIDTH_RESTRICTED_ENVS___5 = 1,
    _CS_GNU_LIBC_VERSION___5_CS_GNU_LIBC_VERSION___5 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___5_CS_GNU_LIBPTHREAD_VERSION___5 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___5_CS_V5_WIDTH_RESTRICTED_ENVS___5 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___5_CS_V7_WIDTH_RESTRICTED_ENVS___5 = 5,
    _CS_LFS_CFLAGS___5_CS_LFS_CFLAGS___5 = 1000,
    _CS_LFS_LDFLAGS___5_CS_LFS_LDFLAGS___5 = 1001,
    _CS_LFS_LIBS___5_CS_LFS_LIBS___5 = 1002,
    _CS_LFS_LINTFLAGS___5_CS_LFS_LINTFLAGS___5 = 1003,
    _CS_LFS64_CFLAGS___5_CS_LFS64_CFLAGS___5 = 1004,
    _CS_LFS64_LDFLAGS___5_CS_LFS64_LDFLAGS___5 = 1005,
    _CS_LFS64_LIBS___5_CS_LFS64_LIBS___5 = 1006,
    _CS_LFS64_LINTFLAGS___5_CS_LFS64_LINTFLAGS___5 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___5_CS_XBS5_ILP32_OFF32_CFLAGS___5 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___5_CS_XBS5_ILP32_OFF32_LDFLAGS___5 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___5_CS_XBS5_ILP32_OFF32_LIBS___5 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___5_CS_XBS5_ILP32_OFF32_LINTFLAGS___5 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___5_CS_XBS5_ILP32_OFFBIG_CFLAGS___5 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___5_CS_XBS5_ILP32_OFFBIG_LDFLAGS___5 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___5_CS_XBS5_ILP32_OFFBIG_LIBS___5 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___5_CS_XBS5_ILP32_OFFBIG_LINTFLAGS___5 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___5_CS_XBS5_LP64_OFF64_CFLAGS___5 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___5_CS_XBS5_LP64_OFF64_LDFLAGS___5 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___5_CS_XBS5_LP64_OFF64_LIBS___5 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___5_CS_XBS5_LP64_OFF64_LINTFLAGS___5 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___5_CS_XBS5_LPBIG_OFFBIG_CFLAGS___5 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___5_CS_XBS5_LPBIG_OFFBIG_LDFLAGS___5 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___5_CS_XBS5_LPBIG_OFFBIG_LIBS___5 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___5_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___5 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___5_CS_POSIX_V6_ILP32_OFF32_CFLAGS___5 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___5_CS_POSIX_V6_ILP32_OFF32_LDFLAGS___5 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___5_CS_POSIX_V6_ILP32_OFF32_LIBS___5 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___5_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___5 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___5_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___5 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___5_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___5 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___5_CS_POSIX_V6_ILP32_OFFBIG_LIBS___5 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___5_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___5 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___5_CS_POSIX_V6_LP64_OFF64_CFLAGS___5 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___5_CS_POSIX_V6_LP64_OFF64_LDFLAGS___5 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___5_CS_POSIX_V6_LP64_OFF64_LIBS___5 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___5_CS_POSIX_V6_LP64_OFF64_LINTFLAGS___5 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___5_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___5 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___5_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___5 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___5_CS_POSIX_V6_LPBIG_OFFBIG_LIBS___5 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___5_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___5 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___5_CS_POSIX_V7_ILP32_OFF32_CFLAGS___5 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___5_CS_POSIX_V7_ILP32_OFF32_LDFLAGS___5 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___5_CS_POSIX_V7_ILP32_OFF32_LIBS___5 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___5_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___5 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___5_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___5 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___5_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___5 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___5_CS_POSIX_V7_ILP32_OFFBIG_LIBS___5 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___5_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___5 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___5_CS_POSIX_V7_LP64_OFF64_CFLAGS___5 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___5_CS_POSIX_V7_LP64_OFF64_LDFLAGS___5 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___5_CS_POSIX_V7_LP64_OFF64_LIBS___5 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___5_CS_POSIX_V7_LP64_OFF64_LINTFLAGS___5 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___5_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___5 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___5_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___5 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___5_CS_POSIX_V7_LPBIG_OFFBIG_LIBS___5 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___5_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___5 = 1147,
    _CS_V6_ENV___5_CS_V6_ENV___5 = 1148,
    _CS_V7_ENV___5_CS_V7_ENV___5 = 1149
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum_18926444___1 {
    _ISupper___1_ISupper___1 = 256,
    _ISlower___1_ISlower___1 = 512,
    _ISalpha___1_ISalpha___1 = 1024,
    _ISdigit___1_ISdigit___1 = 2048,
    _ISxdigit___1_ISxdigit___1 = 4096,
    _ISspace___1_ISspace___1 = 8192,
    _ISprint___1_ISprint___1 = 16384,
    _ISgraph___1_ISgraph___1 = 32768,
    _ISblank___1_ISblank___1 = 1,
    _IScntrl___1_IScntrl___1 = 2,
    _ISpunct___1_ISpunct___1 = 4,
    _ISalnum___1_ISalnum___1 = 8
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___12 {
    VERSION___12VERSION___12 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___11 {
    FP_NAN___11FP_NAN___11 = 0,
    FP_INFINITE___11FP_INFINITE___11 = 1,
    FP_ZERO___11FP_ZERO___11 = 2,
    FP_SUBNORMAL___11FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11FP_NORMAL___11 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___10 {
    ML_LABEL___10ML_LABEL___10 = 0,
    ML_THINGS___10ML_THINGS___10 = 1,
    ML_LINEDEFS___10ML_LINEDEFS___10 = 2,
    ML_SIDEDEFS___10ML_SIDEDEFS___10 = 3,
    ML_VERTEXES___10ML_VERTEXES___10 = 4,
    ML_SEGS___10ML_SEGS___10 = 5,
    ML_SSECTORS___10ML_SSECTORS___10 = 6,
    ML_NODES___10ML_NODES___10 = 7,
    ML_SECTORS___10ML_SECTORS___10 = 8,
    ML_REJECT___10ML_REJECT___10 = 9,
    ML_BLOCKMAP___10ML_BLOCKMAP___10 = 10
} ;
#line 225 "m_misc.c"
struct __anonstruct_default_t_207958591 {
   char *name ;
   int *location ;
   int defaultvalue ;
   int scantranslate ;
   int untranslated ;
};
#line 225 "m_misc.c"
typedef struct __anonstruct_default_t_207958591 default_t;
#line 411 "m_misc.c"
struct __anonstruct_pcx_t_1002945350 {
   char manufacturer ;
   char version ;
   char encoding ;
   char bits_per_pixel ;
   unsigned short xmin ;
   unsigned short ymin ;
   unsigned short xmax ;
   unsigned short ymax ;
   unsigned short hres ;
   unsigned short vres ;
   unsigned char palette[48] ;
   char reserved ;
   char color_planes ;
   unsigned short bytes_per_line ;
   unsigned short palette_type ;
   char filler[58] ;
   unsigned char data ;
};
#line 411 "m_misc.c"
typedef struct __anonstruct_pcx_t_1002945350 pcx_t;
#line 32 "m_bbox.h"
enum __anonenum_607001913 {
    BOXTOPBOXTOP = 0,
    BOXBOTTOMBOXBOTTOM = 1,
    BOXLEFTBOXLEFT = 2,
    BOXRIGHTBOXRIGHT = 3
} ;
#line 34 "m_cheat.h"
struct __anonstruct_cheatseq_t_157313915 {
   unsigned char *sequence ;
   unsigned char *p ;
};
#line 34 "m_cheat.h"
typedef struct __anonstruct_cheatseq_t_157313915 cheatseq_t;
#line 33 "doomdef.h"
enum __anonenum_82154846___13 {
    VERSION___13VERSION___13 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___12 {
    FP_NAN___12FP_NAN___12 = 0,
    FP_INFINITE___12FP_INFINITE___12 = 1,
    FP_ZERO___12FP_ZERO___12 = 2,
    FP_SUBNORMAL___12FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12FP_NORMAL___12 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___11 {
    ML_LABEL___11ML_LABEL___11 = 0,
    ML_THINGS___11ML_THINGS___11 = 1,
    ML_LINEDEFS___11ML_LINEDEFS___11 = 2,
    ML_SIDEDEFS___11ML_SIDEDEFS___11 = 3,
    ML_VERTEXES___11ML_VERTEXES___11 = 4,
    ML_SEGS___11ML_SEGS___11 = 5,
    ML_SSECTORS___11ML_SSECTORS___11 = 6,
    ML_NODES___11ML_NODES___11 = 7,
    ML_SECTORS___11ML_SECTORS___11 = 8,
    ML_REJECT___11ML_REJECT___11 = 9,
    ML_BLOCKMAP___11ML_BLOCKMAP___11 = 10
} ;
#line 128 "am_map.c"
struct __anonstruct_fpoint_t_1063414210 {
   int x ;
   int y ;
};
#line 128 "am_map.c"
typedef struct __anonstruct_fpoint_t_1063414210 fpoint_t;
#line 133 "am_map.c"
struct __anonstruct_fline_t_785528532 {
   fpoint_t a ;
   fpoint_t b ;
};
#line 133 "am_map.c"
typedef struct __anonstruct_fline_t_785528532 fline_t;
#line 138 "am_map.c"
struct __anonstruct_mpoint_t_353907576 {
   fixed_t x ;
   fixed_t y ;
};
#line 138 "am_map.c"
typedef struct __anonstruct_mpoint_t_353907576 mpoint_t;
#line 143 "am_map.c"
struct __anonstruct_mline_t_304307723 {
   mpoint_t a ;
   mpoint_t b ;
};
#line 143 "am_map.c"
typedef struct __anonstruct_mline_t_304307723 mline_t;
#line 148 "am_map.c"
struct __anonstruct_islope_t_353907577 {
   fixed_t slp ;
   fixed_t islp ;
};
#line 148 "am_map.c"
typedef struct __anonstruct_islope_t_353907577 islope_t;
#line 851
enum __anonenum_540708223 {
    LEFTLEFT = 1,
    RIGHTRIGHT = 2,
    BOTTOMBOTTOM = 4,
    TOPTOP = 8
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___14 {
    VERSION___14VERSION___14 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___13 {
    FP_NAN___13FP_NAN___13 = 0,
    FP_INFINITE___13FP_INFINITE___13 = 1,
    FP_ZERO___13FP_ZERO___13 = 2,
    FP_SUBNORMAL___13FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13FP_NORMAL___13 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___12 {
    ML_LABEL___12ML_LABEL___12 = 0,
    ML_THINGS___12ML_THINGS___12 = 1,
    ML_LINEDEFS___12ML_LINEDEFS___12 = 2,
    ML_SIDEDEFS___12ML_SIDEDEFS___12 = 3,
    ML_VERTEXES___12ML_VERTEXES___12 = 4,
    ML_SEGS___12ML_SEGS___12 = 5,
    ML_SSECTORS___12ML_SSECTORS___12 = 6,
    ML_NODES___12ML_NODES___12 = 7,
    ML_SECTORS___12ML_SECTORS___12 = 8,
    ML_REJECT___12ML_REJECT___12 = 9,
    ML_BLOCKMAP___12ML_BLOCKMAP___12 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___15 {
    VERSION___15VERSION___15 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___14 {
    FP_NAN___14FP_NAN___14 = 0,
    FP_INFINITE___14FP_INFINITE___14 = 1,
    FP_ZERO___14FP_ZERO___14 = 2,
    FP_SUBNORMAL___14FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14FP_NORMAL___14 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___13 {
    ML_LABEL___13ML_LABEL___13 = 0,
    ML_THINGS___13ML_THINGS___13 = 1,
    ML_LINEDEFS___13ML_LINEDEFS___13 = 2,
    ML_SIDEDEFS___13ML_SIDEDEFS___13 = 3,
    ML_VERTEXES___13ML_VERTEXES___13 = 4,
    ML_SEGS___13ML_SEGS___13 = 5,
    ML_SSECTORS___13ML_SSECTORS___13 = 6,
    ML_NODES___13ML_NODES___13 = 7,
    ML_SECTORS___13ML_SECTORS___13 = 8,
    ML_REJECT___13ML_REJECT___13 = 9,
    ML_BLOCKMAP___13ML_BLOCKMAP___13 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___16 {
    VERSION___16VERSION___16 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___15 {
    FP_NAN___15FP_NAN___15 = 0,
    FP_INFINITE___15FP_INFINITE___15 = 1,
    FP_ZERO___15FP_ZERO___15 = 2,
    FP_SUBNORMAL___15FP_SUBNORMAL___15 = 3,
    FP_NORMAL___15FP_NORMAL___15 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___14 {
    ML_LABEL___14ML_LABEL___14 = 0,
    ML_THINGS___14ML_THINGS___14 = 1,
    ML_LINEDEFS___14ML_LINEDEFS___14 = 2,
    ML_SIDEDEFS___14ML_SIDEDEFS___14 = 3,
    ML_VERTEXES___14ML_VERTEXES___14 = 4,
    ML_SEGS___14ML_SEGS___14 = 5,
    ML_SSECTORS___14ML_SSECTORS___14 = 6,
    ML_NODES___14ML_NODES___14 = 7,
    ML_SECTORS___14ML_SECTORS___14 = 8,
    ML_REJECT___14ML_REJECT___14 = 9,
    ML_BLOCKMAP___14ML_BLOCKMAP___14 = 10
} ;
#line 51 "p_enemy.c"
enum __anonenum_dirtype_t_678795573 {
    DI_EASTDI_EAST = 0,
    DI_NORTHEASTDI_NORTHEAST = 1,
    DI_NORTHDI_NORTH = 2,
    DI_NORTHWESTDI_NORTHWEST = 3,
    DI_WESTDI_WEST = 4,
    DI_SOUTHWESTDI_SOUTHWEST = 5,
    DI_SOUTHDI_SOUTH = 6,
    DI_SOUTHEASTDI_SOUTHEAST = 7,
    DI_NODIRDI_NODIR = 8,
    NUMDIRSNUMDIRS = 9
} ;
#line 51 "p_enemy.c"
typedef enum __anonenum_dirtype_t_678795573 dirtype_t;
#line 33 "doomdef.h"
enum __anonenum_82154846___17 {
    VERSION___17VERSION___17 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___16 {
    FP_NAN___16FP_NAN___16 = 0,
    FP_INFINITE___16FP_INFINITE___16 = 1,
    FP_ZERO___16FP_ZERO___16 = 2,
    FP_SUBNORMAL___16FP_SUBNORMAL___16 = 3,
    FP_NORMAL___16FP_NORMAL___16 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___15 {
    ML_LABEL___15ML_LABEL___15 = 0,
    ML_THINGS___15ML_THINGS___15 = 1,
    ML_LINEDEFS___15ML_LINEDEFS___15 = 2,
    ML_SIDEDEFS___15ML_SIDEDEFS___15 = 3,
    ML_VERTEXES___15ML_VERTEXES___15 = 4,
    ML_SEGS___15ML_SEGS___15 = 5,
    ML_SSECTORS___15ML_SSECTORS___15 = 6,
    ML_NODES___15ML_NODES___15 = 7,
    ML_SECTORS___15ML_SECTORS___15 = 8,
    ML_REJECT___15ML_REJECT___15 = 9,
    ML_BLOCKMAP___15ML_BLOCKMAP___15 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___18 {
    VERSION___18VERSION___18 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___16 {
    ML_LABEL___16ML_LABEL___16 = 0,
    ML_THINGS___16ML_THINGS___16 = 1,
    ML_LINEDEFS___16ML_LINEDEFS___16 = 2,
    ML_SIDEDEFS___16ML_SIDEDEFS___16 = 3,
    ML_VERTEXES___16ML_VERTEXES___16 = 4,
    ML_SEGS___16ML_SEGS___16 = 5,
    ML_SSECTORS___16ML_SSECTORS___16 = 6,
    ML_NODES___16ML_NODES___16 = 7,
    ML_SECTORS___16ML_SECTORS___16 = 8,
    ML_REJECT___16ML_REJECT___16 = 9,
    ML_BLOCKMAP___16ML_BLOCKMAP___16 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___17 {
    FP_NAN___17FP_NAN___17 = 0,
    FP_INFINITE___17FP_INFINITE___17 = 1,
    FP_ZERO___17FP_ZERO___17 = 2,
    FP_SUBNORMAL___17FP_SUBNORMAL___17 = 3,
    FP_NORMAL___17FP_NORMAL___17 = 4
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___19 {
    VERSION___19VERSION___19 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___18 {
    FP_NAN___18FP_NAN___18 = 0,
    FP_INFINITE___18FP_INFINITE___18 = 1,
    FP_ZERO___18FP_ZERO___18 = 2,
    FP_SUBNORMAL___18FP_SUBNORMAL___18 = 3,
    FP_NORMAL___18FP_NORMAL___18 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___17 {
    ML_LABEL___17ML_LABEL___17 = 0,
    ML_THINGS___17ML_THINGS___17 = 1,
    ML_LINEDEFS___17ML_LINEDEFS___17 = 2,
    ML_SIDEDEFS___17ML_SIDEDEFS___17 = 3,
    ML_VERTEXES___17ML_VERTEXES___17 = 4,
    ML_SEGS___17ML_SEGS___17 = 5,
    ML_SSECTORS___17ML_SSECTORS___17 = 6,
    ML_NODES___17ML_NODES___17 = 7,
    ML_SECTORS___17ML_SECTORS___17 = 8,
    ML_REJECT___17ML_REJECT___17 = 9,
    ML_BLOCKMAP___17ML_BLOCKMAP___17 = 10
} ;
#line 32 "m_bbox.h"
enum __anonenum_607001913___0 {
    BOXTOP___0BOXTOP___0 = 0,
    BOXBOTTOM___0BOXBOTTOM___0 = 1,
    BOXLEFT___0BOXLEFT___0 = 2,
    BOXRIGHT___0BOXRIGHT___0 = 3
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___20 {
    VERSION___20VERSION___20 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___19 {
    FP_NAN___19FP_NAN___19 = 0,
    FP_INFINITE___19FP_INFINITE___19 = 1,
    FP_ZERO___19FP_ZERO___19 = 2,
    FP_SUBNORMAL___19FP_SUBNORMAL___19 = 3,
    FP_NORMAL___19FP_NORMAL___19 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___18 {
    ML_LABEL___18ML_LABEL___18 = 0,
    ML_THINGS___18ML_THINGS___18 = 1,
    ML_LINEDEFS___18ML_LINEDEFS___18 = 2,
    ML_SIDEDEFS___18ML_SIDEDEFS___18 = 3,
    ML_VERTEXES___18ML_VERTEXES___18 = 4,
    ML_SEGS___18ML_SEGS___18 = 5,
    ML_SSECTORS___18ML_SSECTORS___18 = 6,
    ML_NODES___18ML_NODES___18 = 7,
    ML_SECTORS___18ML_SECTORS___18 = 8,
    ML_REJECT___18ML_REJECT___18 = 9,
    ML_BLOCKMAP___18ML_BLOCKMAP___18 = 10
} ;
#line 32 "m_bbox.h"
enum __anonenum_607001913___1 {
    BOXTOP___1BOXTOP___1 = 0,
    BOXBOTTOM___1BOXBOTTOM___1 = 1,
    BOXLEFT___1BOXLEFT___1 = 2,
    BOXRIGHT___1BOXRIGHT___1 = 3
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___21 {
    VERSION___21VERSION___21 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___20 {
    FP_NAN___20FP_NAN___20 = 0,
    FP_INFINITE___20FP_INFINITE___20 = 1,
    FP_ZERO___20FP_ZERO___20 = 2,
    FP_SUBNORMAL___20FP_SUBNORMAL___20 = 3,
    FP_NORMAL___20FP_NORMAL___20 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___19 {
    ML_LABEL___19ML_LABEL___19 = 0,
    ML_THINGS___19ML_THINGS___19 = 1,
    ML_LINEDEFS___19ML_LINEDEFS___19 = 2,
    ML_SIDEDEFS___19ML_SIDEDEFS___19 = 3,
    ML_VERTEXES___19ML_VERTEXES___19 = 4,
    ML_SEGS___19ML_SEGS___19 = 5,
    ML_SSECTORS___19ML_SSECTORS___19 = 6,
    ML_NODES___19ML_NODES___19 = 7,
    ML_SECTORS___19ML_SECTORS___19 = 8,
    ML_REJECT___19ML_REJECT___19 = 9,
    ML_BLOCKMAP___19ML_BLOCKMAP___19 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___22 {
    VERSION___22VERSION___22 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___21 {
    FP_NAN___21FP_NAN___21 = 0,
    FP_INFINITE___21FP_INFINITE___21 = 1,
    FP_ZERO___21FP_ZERO___21 = 2,
    FP_SUBNORMAL___21FP_SUBNORMAL___21 = 3,
    FP_NORMAL___21FP_NORMAL___21 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___20 {
    ML_LABEL___20ML_LABEL___20 = 0,
    ML_THINGS___20ML_THINGS___20 = 1,
    ML_LINEDEFS___20ML_LINEDEFS___20 = 2,
    ML_SIDEDEFS___20ML_SIDEDEFS___20 = 3,
    ML_VERTEXES___20ML_VERTEXES___20 = 4,
    ML_SEGS___20ML_SEGS___20 = 5,
    ML_SSECTORS___20ML_SSECTORS___20 = 6,
    ML_NODES___20ML_NODES___20 = 7,
    ML_SECTORS___20ML_SECTORS___20 = 8,
    ML_REJECT___20ML_REJECT___20 = 9,
    ML_BLOCKMAP___20ML_BLOCKMAP___20 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___23 {
    VERSION___23VERSION___23 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___22 {
    FP_NAN___22FP_NAN___22 = 0,
    FP_INFINITE___22FP_INFINITE___22 = 1,
    FP_ZERO___22FP_ZERO___22 = 2,
    FP_SUBNORMAL___22FP_SUBNORMAL___22 = 3,
    FP_NORMAL___22FP_NORMAL___22 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___21 {
    ML_LABEL___21ML_LABEL___21 = 0,
    ML_THINGS___21ML_THINGS___21 = 1,
    ML_LINEDEFS___21ML_LINEDEFS___21 = 2,
    ML_SIDEDEFS___21ML_SIDEDEFS___21 = 3,
    ML_VERTEXES___21ML_VERTEXES___21 = 4,
    ML_SEGS___21ML_SEGS___21 = 5,
    ML_SSECTORS___21ML_SSECTORS___21 = 6,
    ML_NODES___21ML_NODES___21 = 7,
    ML_SECTORS___21ML_SECTORS___21 = 8,
    ML_REJECT___21ML_REJECT___21 = 9,
    ML_BLOCKMAP___21ML_BLOCKMAP___21 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___23 {
    FP_NAN___23FP_NAN___23 = 0,
    FP_INFINITE___23FP_INFINITE___23 = 1,
    FP_ZERO___23FP_ZERO___23 = 2,
    FP_SUBNORMAL___23FP_SUBNORMAL___23 = 3,
    FP_NORMAL___23FP_NORMAL___23 = 4
} ;
#line 32 "m_bbox.h"
enum __anonenum_607001913___2 {
    BOXTOP___2BOXTOP___2 = 0,
    BOXBOTTOM___2BOXBOTTOM___2 = 1,
    BOXLEFT___2BOXLEFT___2 = 2,
    BOXRIGHT___2BOXRIGHT___2 = 3
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___24 {
    VERSION___24VERSION___24 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___22 {
    ML_LABEL___22ML_LABEL___22 = 0,
    ML_THINGS___22ML_THINGS___22 = 1,
    ML_LINEDEFS___22ML_LINEDEFS___22 = 2,
    ML_SIDEDEFS___22ML_SIDEDEFS___22 = 3,
    ML_VERTEXES___22ML_VERTEXES___22 = 4,
    ML_SEGS___22ML_SEGS___22 = 5,
    ML_SSECTORS___22ML_SSECTORS___22 = 6,
    ML_NODES___22ML_NODES___22 = 7,
    ML_SECTORS___22ML_SECTORS___22 = 8,
    ML_REJECT___22ML_REJECT___22 = 9,
    ML_BLOCKMAP___22ML_BLOCKMAP___22 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___25 {
    VERSION___25VERSION___25 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___24 {
    FP_NAN___24FP_NAN___24 = 0,
    FP_INFINITE___24FP_INFINITE___24 = 1,
    FP_ZERO___24FP_ZERO___24 = 2,
    FP_SUBNORMAL___24FP_SUBNORMAL___24 = 3,
    FP_NORMAL___24FP_NORMAL___24 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___23 {
    ML_LABEL___23ML_LABEL___23 = 0,
    ML_THINGS___23ML_THINGS___23 = 1,
    ML_LINEDEFS___23ML_LINEDEFS___23 = 2,
    ML_SIDEDEFS___23ML_SIDEDEFS___23 = 3,
    ML_VERTEXES___23ML_VERTEXES___23 = 4,
    ML_SEGS___23ML_SEGS___23 = 5,
    ML_SSECTORS___23ML_SSECTORS___23 = 6,
    ML_NODES___23ML_NODES___23 = 7,
    ML_SECTORS___23ML_SECTORS___23 = 8,
    ML_REJECT___23ML_REJECT___23 = 9,
    ML_BLOCKMAP___23ML_BLOCKMAP___23 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___26 {
    VERSION___26VERSION___26 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___24 {
    ML_LABEL___24ML_LABEL___24 = 0,
    ML_THINGS___24ML_THINGS___24 = 1,
    ML_LINEDEFS___24ML_LINEDEFS___24 = 2,
    ML_SIDEDEFS___24ML_SIDEDEFS___24 = 3,
    ML_VERTEXES___24ML_VERTEXES___24 = 4,
    ML_SEGS___24ML_SEGS___24 = 5,
    ML_SSECTORS___24ML_SSECTORS___24 = 6,
    ML_NODES___24ML_NODES___24 = 7,
    ML_SECTORS___24ML_SECTORS___24 = 8,
    ML_REJECT___24ML_REJECT___24 = 9,
    ML_BLOCKMAP___24ML_BLOCKMAP___24 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___25 {
    FP_NAN___25FP_NAN___25 = 0,
    FP_INFINITE___25FP_INFINITE___25 = 1,
    FP_ZERO___25FP_ZERO___25 = 2,
    FP_SUBNORMAL___25FP_SUBNORMAL___25 = 3,
    FP_NORMAL___25FP_NORMAL___25 = 4
} ;
#line 60 "p_spec.c"
struct __anonstruct_anim_t_708648705 {
   boolean istexture ;
   int picnum ;
   int basepic ;
   int numpics ;
   int speed ;
};
#line 60 "p_spec.c"
typedef struct __anonstruct_anim_t_708648705 anim_t;
#line 73 "p_spec.c"
struct __anonstruct_animdef_t_538830473 {
   boolean istexture ;
   char endname[9] ;
   char startname[9] ;
   int speed ;
};
#line 73 "p_spec.c"
typedef struct __anonstruct_animdef_t_538830473 animdef_t;
#line 33 "doomdef.h"
enum __anonenum_82154846___27 {
    VERSION___27VERSION___27 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___26 {
    FP_NAN___26FP_NAN___26 = 0,
    FP_INFINITE___26FP_INFINITE___26 = 1,
    FP_ZERO___26FP_ZERO___26 = 2,
    FP_SUBNORMAL___26FP_SUBNORMAL___26 = 3,
    FP_NORMAL___26FP_NORMAL___26 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___25 {
    ML_LABEL___25ML_LABEL___25 = 0,
    ML_THINGS___25ML_THINGS___25 = 1,
    ML_LINEDEFS___25ML_LINEDEFS___25 = 2,
    ML_SIDEDEFS___25ML_SIDEDEFS___25 = 3,
    ML_VERTEXES___25ML_VERTEXES___25 = 4,
    ML_SEGS___25ML_SEGS___25 = 5,
    ML_SSECTORS___25ML_SSECTORS___25 = 6,
    ML_NODES___25ML_NODES___25 = 7,
    ML_SECTORS___25ML_SECTORS___25 = 8,
    ML_REJECT___25ML_REJECT___25 = 9,
    ML_BLOCKMAP___25ML_BLOCKMAP___25 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___28 {
    VERSION___28VERSION___28 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___27 {
    FP_NAN___27FP_NAN___27 = 0,
    FP_INFINITE___27FP_INFINITE___27 = 1,
    FP_ZERO___27FP_ZERO___27 = 2,
    FP_SUBNORMAL___27FP_SUBNORMAL___27 = 3,
    FP_NORMAL___27FP_NORMAL___27 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___26 {
    ML_LABEL___26ML_LABEL___26 = 0,
    ML_THINGS___26ML_THINGS___26 = 1,
    ML_LINEDEFS___26ML_LINEDEFS___26 = 2,
    ML_SIDEDEFS___26ML_SIDEDEFS___26 = 3,
    ML_VERTEXES___26ML_VERTEXES___26 = 4,
    ML_SEGS___26ML_SEGS___26 = 5,
    ML_SSECTORS___26ML_SSECTORS___26 = 6,
    ML_NODES___26ML_NODES___26 = 7,
    ML_SECTORS___26ML_SECTORS___26 = 8,
    ML_REJECT___26ML_REJECT___26 = 9,
    ML_BLOCKMAP___26ML_BLOCKMAP___26 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___29 {
    VERSION___29VERSION___29 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___28 {
    FP_NAN___28FP_NAN___28 = 0,
    FP_INFINITE___28FP_INFINITE___28 = 1,
    FP_ZERO___28FP_ZERO___28 = 2,
    FP_SUBNORMAL___28FP_SUBNORMAL___28 = 3,
    FP_NORMAL___28FP_NORMAL___28 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___27 {
    ML_LABEL___27ML_LABEL___27 = 0,
    ML_THINGS___27ML_THINGS___27 = 1,
    ML_LINEDEFS___27ML_LINEDEFS___27 = 2,
    ML_SIDEDEFS___27ML_SIDEDEFS___27 = 3,
    ML_VERTEXES___27ML_VERTEXES___27 = 4,
    ML_SEGS___27ML_SEGS___27 = 5,
    ML_SSECTORS___27ML_SSECTORS___27 = 6,
    ML_NODES___27ML_NODES___27 = 7,
    ML_SECTORS___27ML_SECTORS___27 = 8,
    ML_REJECT___27ML_REJECT___27 = 9,
    ML_BLOCKMAP___27ML_BLOCKMAP___27 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___29 {
    FP_NAN___29FP_NAN___29 = 0,
    FP_INFINITE___29FP_INFINITE___29 = 1,
    FP_ZERO___29FP_ZERO___29 = 2,
    FP_SUBNORMAL___29FP_SUBNORMAL___29 = 3,
    FP_NORMAL___29FP_NORMAL___29 = 4
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___30 {
    VERSION___30VERSION___30 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___28 {
    ML_LABEL___28ML_LABEL___28 = 0,
    ML_THINGS___28ML_THINGS___28 = 1,
    ML_LINEDEFS___28ML_LINEDEFS___28 = 2,
    ML_SIDEDEFS___28ML_SIDEDEFS___28 = 3,
    ML_VERTEXES___28ML_VERTEXES___28 = 4,
    ML_SEGS___28ML_SEGS___28 = 5,
    ML_SSECTORS___28ML_SSECTORS___28 = 6,
    ML_NODES___28ML_NODES___28 = 7,
    ML_SECTORS___28ML_SECTORS___28 = 8,
    ML_REJECT___28ML_REJECT___28 = 9,
    ML_BLOCKMAP___28ML_BLOCKMAP___28 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___30 {
    FP_NAN___30FP_NAN___30 = 0,
    FP_INFINITE___30FP_INFINITE___30 = 1,
    FP_ZERO___30FP_ZERO___30 = 2,
    FP_SUBNORMAL___30FP_SUBNORMAL___30 = 3,
    FP_NORMAL___30FP_NORMAL___30 = 4
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___31 {
    VERSION___31VERSION___31 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___29 {
    ML_LABEL___29ML_LABEL___29 = 0,
    ML_THINGS___29ML_THINGS___29 = 1,
    ML_LINEDEFS___29ML_LINEDEFS___29 = 2,
    ML_SIDEDEFS___29ML_SIDEDEFS___29 = 3,
    ML_VERTEXES___29ML_VERTEXES___29 = 4,
    ML_SEGS___29ML_SEGS___29 = 5,
    ML_SSECTORS___29ML_SSECTORS___29 = 6,
    ML_NODES___29ML_NODES___29 = 7,
    ML_SECTORS___29ML_SECTORS___29 = 8,
    ML_REJECT___29ML_REJECT___29 = 9,
    ML_BLOCKMAP___29ML_BLOCKMAP___29 = 10
} ;
#line 220 "p_saveg.c"
enum __anonenum_thinkerclass_t_895877930 {
    tc_endtc_end = 0,
    tc_mobjtc_mobj = 1
} ;
#line 220 "p_saveg.c"
typedef enum __anonenum_thinkerclass_t_895877930 thinkerclass_t;
#line 329
enum __anonenum_specials_e_86675702 {
    tc_ceilingtc_ceiling = 0,
    tc_doortc_door = 1,
    tc_floortc_floor = 2,
    tc_plattc_plat = 3,
    tc_flashtc_flash = 4,
    tc_strobetc_strobe = 5,
    tc_glowtc_glow = 6,
    tc_endspecialstc_endspecials = 7
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___32 {
    VERSION___32VERSION___32 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___31 {
    FP_NAN___31FP_NAN___31 = 0,
    FP_INFINITE___31FP_INFINITE___31 = 1,
    FP_ZERO___31FP_ZERO___31 = 2,
    FP_SUBNORMAL___31FP_SUBNORMAL___31 = 3,
    FP_NORMAL___31FP_NORMAL___31 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___30 {
    ML_LABEL___30ML_LABEL___30 = 0,
    ML_THINGS___30ML_THINGS___30 = 1,
    ML_LINEDEFS___30ML_LINEDEFS___30 = 2,
    ML_SIDEDEFS___30ML_SIDEDEFS___30 = 3,
    ML_VERTEXES___30ML_VERTEXES___30 = 4,
    ML_SEGS___30ML_SEGS___30 = 5,
    ML_SSECTORS___30ML_SSECTORS___30 = 6,
    ML_NODES___30ML_NODES___30 = 7,
    ML_SECTORS___30ML_SECTORS___30 = 8,
    ML_REJECT___30ML_REJECT___30 = 9,
    ML_BLOCKMAP___30ML_BLOCKMAP___30 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___33 {
    VERSION___33VERSION___33 = 110
} ;
#line 32 "m_bbox.h"
enum __anonenum_607001913___3 {
    BOXTOP___3BOXTOP___3 = 0,
    BOXBOTTOM___3BOXBOTTOM___3 = 1,
    BOXLEFT___3BOXLEFT___3 = 2,
    BOXRIGHT___3BOXRIGHT___3 = 3
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___32 {
    FP_NAN___32FP_NAN___32 = 0,
    FP_INFINITE___32FP_INFINITE___32 = 1,
    FP_ZERO___32FP_ZERO___32 = 2,
    FP_SUBNORMAL___32FP_SUBNORMAL___32 = 3,
    FP_NORMAL___32FP_NORMAL___32 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___31 {
    ML_LABEL___31ML_LABEL___31 = 0,
    ML_THINGS___31ML_THINGS___31 = 1,
    ML_LINEDEFS___31ML_LINEDEFS___31 = 2,
    ML_SIDEDEFS___31ML_SIDEDEFS___31 = 3,
    ML_VERTEXES___31ML_VERTEXES___31 = 4,
    ML_SEGS___31ML_SEGS___31 = 5,
    ML_SSECTORS___31ML_SSECTORS___31 = 6,
    ML_NODES___31ML_NODES___31 = 7,
    ML_SECTORS___31ML_SECTORS___31 = 8,
    ML_REJECT___31ML_REJECT___31 = 9,
    ML_BLOCKMAP___31ML_BLOCKMAP___31 = 10
} ;
#line 80 "r_bsp.c"
struct __anonstruct_cliprange_t_773697287 {
   int first ;
   int last ;
};
#line 80 "r_bsp.c"
typedef struct __anonstruct_cliprange_t_773697287 cliprange_t;
#line 33 "doomdef.h"
enum __anonenum_82154846___34 {
    VERSION___34VERSION___34 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___33 {
    FP_NAN___33FP_NAN___33 = 0,
    FP_INFINITE___33FP_INFINITE___33 = 1,
    FP_ZERO___33FP_ZERO___33 = 2,
    FP_SUBNORMAL___33FP_SUBNORMAL___33 = 3,
    FP_NORMAL___33FP_NORMAL___33 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___32 {
    ML_LABEL___32ML_LABEL___32 = 0,
    ML_THINGS___32ML_THINGS___32 = 1,
    ML_LINEDEFS___32ML_LINEDEFS___32 = 2,
    ML_SIDEDEFS___32ML_SIDEDEFS___32 = 3,
    ML_VERTEXES___32ML_VERTEXES___32 = 4,
    ML_SEGS___32ML_SEGS___32 = 5,
    ML_SSECTORS___32ML_SSECTORS___32 = 6,
    ML_NODES___32ML_NODES___32 = 7,
    ML_SECTORS___32ML_SECTORS___32 = 8,
    ML_REJECT___32ML_REJECT___32 = 9,
    ML_BLOCKMAP___32ML_BLOCKMAP___32 = 10
} ;
#line 69 "r_data.c"
struct __anonstruct_mappatch_t_1063414210 {
   short originx ;
   short originy ;
   short patch ;
   short stepdir ;
   short colormap ;
};
#line 69 "r_data.c"
typedef struct __anonstruct_mappatch_t_1063414210 mappatch_t;
#line 84 "r_data.c"
struct __anonstruct_maptexture_t_1045448141 {
   char name[8] ;
   boolean masked ;
   short width ;
   short height ;
   void **columndirectory ;
   short patchcount ;
   mappatch_t patches[1] ;
};
#line 84 "r_data.c"
typedef struct __anonstruct_maptexture_t_1045448141 maptexture_t;
#line 99 "r_data.c"
struct __anonstruct_texpatch_t_582275743 {
   int originx ;
   int originy ;
   int patch ;
};
#line 99 "r_data.c"
typedef struct __anonstruct_texpatch_t_582275743 texpatch_t;
#line 113 "r_data.c"
struct __anonstruct_texture_t_828953010 {
   char name[8] ;
   short width ;
   short height ;
   short patchcount ;
   texpatch_t patches[1] ;
};
#line 113 "r_data.c"
typedef struct __anonstruct_texture_t_828953010 texture_t;
#line 33 "doomdef.h"
enum __anonenum_82154846___35 {
    VERSION___35VERSION___35 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___34 {
    FP_NAN___34FP_NAN___34 = 0,
    FP_INFINITE___34FP_INFINITE___34 = 1,
    FP_ZERO___34FP_ZERO___34 = 2,
    FP_SUBNORMAL___34FP_SUBNORMAL___34 = 3,
    FP_NORMAL___34FP_NORMAL___34 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___33 {
    ML_LABEL___33ML_LABEL___33 = 0,
    ML_THINGS___33ML_THINGS___33 = 1,
    ML_LINEDEFS___33ML_LINEDEFS___33 = 2,
    ML_SIDEDEFS___33ML_SIDEDEFS___33 = 3,
    ML_VERTEXES___33ML_VERTEXES___33 = 4,
    ML_SEGS___33ML_SEGS___33 = 5,
    ML_SSECTORS___33ML_SSECTORS___33 = 6,
    ML_NODES___33ML_NODES___33 = 7,
    ML_SECTORS___33ML_SECTORS___33 = 8,
    ML_REJECT___33ML_REJECT___33 = 9,
    ML_BLOCKMAP___33ML_BLOCKMAP___33 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___35 {
    FP_NAN___35FP_NAN___35 = 0,
    FP_INFINITE___35FP_INFINITE___35 = 1,
    FP_ZERO___35FP_ZERO___35 = 2,
    FP_SUBNORMAL___35FP_SUBNORMAL___35 = 3,
    FP_NORMAL___35FP_NORMAL___35 = 4
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___36 {
    VERSION___36VERSION___36 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___34 {
    ML_LABEL___34ML_LABEL___34 = 0,
    ML_THINGS___34ML_THINGS___34 = 1,
    ML_LINEDEFS___34ML_LINEDEFS___34 = 2,
    ML_SIDEDEFS___34ML_SIDEDEFS___34 = 3,
    ML_VERTEXES___34ML_VERTEXES___34 = 4,
    ML_SEGS___34ML_SEGS___34 = 5,
    ML_SSECTORS___34ML_SSECTORS___34 = 6,
    ML_NODES___34ML_NODES___34 = 7,
    ML_SECTORS___34ML_SECTORS___34 = 8,
    ML_REJECT___34ML_REJECT___34 = 9,
    ML_BLOCKMAP___34ML_BLOCKMAP___34 = 10
} ;
#line 32 "m_bbox.h"
enum __anonenum_607001913___4 {
    BOXTOP___4BOXTOP___4 = 0,
    BOXBOTTOM___4BOXBOTTOM___4 = 1,
    BOXLEFT___4BOXLEFT___4 = 2,
    BOXRIGHT___4BOXRIGHT___4 = 3
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___37 {
    VERSION___37VERSION___37 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___35 {
    ML_LABEL___35ML_LABEL___35 = 0,
    ML_THINGS___35ML_THINGS___35 = 1,
    ML_LINEDEFS___35ML_LINEDEFS___35 = 2,
    ML_SIDEDEFS___35ML_SIDEDEFS___35 = 3,
    ML_VERTEXES___35ML_VERTEXES___35 = 4,
    ML_SEGS___35ML_SEGS___35 = 5,
    ML_SSECTORS___35ML_SSECTORS___35 = 6,
    ML_NODES___35ML_NODES___35 = 7,
    ML_SECTORS___35ML_SECTORS___35 = 8,
    ML_REJECT___35ML_REJECT___35 = 9,
    ML_BLOCKMAP___35ML_BLOCKMAP___35 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___36 {
    FP_NAN___36FP_NAN___36 = 0,
    FP_INFINITE___36FP_INFINITE___36 = 1,
    FP_ZERO___36FP_ZERO___36 = 2,
    FP_SUBNORMAL___36FP_SUBNORMAL___36 = 3,
    FP_NORMAL___36FP_NORMAL___36 = 4
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___38 {
    VERSION___38VERSION___38 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___36 {
    ML_LABEL___36ML_LABEL___36 = 0,
    ML_THINGS___36ML_THINGS___36 = 1,
    ML_LINEDEFS___36ML_LINEDEFS___36 = 2,
    ML_SIDEDEFS___36ML_SIDEDEFS___36 = 3,
    ML_VERTEXES___36ML_VERTEXES___36 = 4,
    ML_SEGS___36ML_SEGS___36 = 5,
    ML_SSECTORS___36ML_SSECTORS___36 = 6,
    ML_NODES___36ML_NODES___36 = 7,
    ML_SECTORS___36ML_SECTORS___36 = 8,
    ML_REJECT___36ML_REJECT___36 = 9,
    ML_BLOCKMAP___36ML_BLOCKMAP___36 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___37 {
    FP_NAN___37FP_NAN___37 = 0,
    FP_INFINITE___37FP_INFINITE___37 = 1,
    FP_ZERO___37FP_ZERO___37 = 2,
    FP_SUBNORMAL___37FP_SUBNORMAL___37 = 3,
    FP_NORMAL___37FP_NORMAL___37 = 4
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___39 {
    VERSION___39VERSION___39 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___38 {
    FP_NAN___38FP_NAN___38 = 0,
    FP_INFINITE___38FP_INFINITE___38 = 1,
    FP_ZERO___38FP_ZERO___38 = 2,
    FP_SUBNORMAL___38FP_SUBNORMAL___38 = 3,
    FP_NORMAL___38FP_NORMAL___38 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___37 {
    ML_LABEL___37ML_LABEL___37 = 0,
    ML_THINGS___37ML_THINGS___37 = 1,
    ML_LINEDEFS___37ML_LINEDEFS___37 = 2,
    ML_SIDEDEFS___37ML_SIDEDEFS___37 = 3,
    ML_VERTEXES___37ML_VERTEXES___37 = 4,
    ML_SEGS___37ML_SEGS___37 = 5,
    ML_SSECTORS___37ML_SSECTORS___37 = 6,
    ML_NODES___37ML_NODES___37 = 7,
    ML_SECTORS___37ML_SECTORS___37 = 8,
    ML_REJECT___37ML_REJECT___37 = 9,
    ML_BLOCKMAP___37ML_BLOCKMAP___37 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___40 {
    VERSION___40VERSION___40 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___39 {
    FP_NAN___39FP_NAN___39 = 0,
    FP_INFINITE___39FP_INFINITE___39 = 1,
    FP_ZERO___39FP_ZERO___39 = 2,
    FP_SUBNORMAL___39FP_SUBNORMAL___39 = 3,
    FP_NORMAL___39FP_NORMAL___39 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___38 {
    ML_LABEL___38ML_LABEL___38 = 0,
    ML_THINGS___38ML_THINGS___38 = 1,
    ML_LINEDEFS___38ML_LINEDEFS___38 = 2,
    ML_SIDEDEFS___38ML_SIDEDEFS___38 = 3,
    ML_VERTEXES___38ML_VERTEXES___38 = 4,
    ML_SEGS___38ML_SEGS___38 = 5,
    ML_SSECTORS___38ML_SSECTORS___38 = 6,
    ML_NODES___38ML_NODES___38 = 7,
    ML_SECTORS___38ML_SECTORS___38 = 8,
    ML_REJECT___38ML_REJECT___38 = 9,
    ML_BLOCKMAP___38ML_BLOCKMAP___38 = 10
} ;
#line 54 "r_things.c"
struct __anonstruct_maskdraw_t_1068738709 {
   int x1 ;
   int x2 ;
   int column ;
   int topclip ;
   int bottomclip ;
};
#line 54 "r_things.c"
typedef struct __anonstruct_maskdraw_t_1068738709 maskdraw_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum_18926444___2 {
    _ISupper___2_ISupper___2 = 256,
    _ISlower___2_ISlower___2 = 512,
    _ISalpha___2_ISalpha___2 = 1024,
    _ISdigit___2_ISdigit___2 = 2048,
    _ISxdigit___2_ISxdigit___2 = 4096,
    _ISspace___2_ISspace___2 = 8192,
    _ISprint___2_ISprint___2 = 16384,
    _ISgraph___2_ISgraph___2 = 32768,
    _ISblank___2_ISblank___2 = 1,
    _IScntrl___2_IScntrl___2 = 2,
    _ISpunct___2_ISpunct___2 = 4,
    _ISalnum___2_ISalnum___2 = 8
} ;
#line 24 "/usr/include/bits/confname.h"
enum __anonenum_437032235___6 {
    _PC_LINK_MAX___6_PC_LINK_MAX___6 = 0,
    _PC_MAX_CANON___6_PC_MAX_CANON___6 = 1,
    _PC_MAX_INPUT___6_PC_MAX_INPUT___6 = 2,
    _PC_NAME_MAX___6_PC_NAME_MAX___6 = 3,
    _PC_PATH_MAX___6_PC_PATH_MAX___6 = 4,
    _PC_PIPE_BUF___6_PC_PIPE_BUF___6 = 5,
    _PC_CHOWN_RESTRICTED___6_PC_CHOWN_RESTRICTED___6 = 6,
    _PC_NO_TRUNC___6_PC_NO_TRUNC___6 = 7,
    _PC_VDISABLE___6_PC_VDISABLE___6 = 8,
    _PC_SYNC_IO___6_PC_SYNC_IO___6 = 9,
    _PC_ASYNC_IO___6_PC_ASYNC_IO___6 = 10,
    _PC_PRIO_IO___6_PC_PRIO_IO___6 = 11,
    _PC_SOCK_MAXBUF___6_PC_SOCK_MAXBUF___6 = 12,
    _PC_FILESIZEBITS___6_PC_FILESIZEBITS___6 = 13,
    _PC_REC_INCR_XFER_SIZE___6_PC_REC_INCR_XFER_SIZE___6 = 14,
    _PC_REC_MAX_XFER_SIZE___6_PC_REC_MAX_XFER_SIZE___6 = 15,
    _PC_REC_MIN_XFER_SIZE___6_PC_REC_MIN_XFER_SIZE___6 = 16,
    _PC_REC_XFER_ALIGN___6_PC_REC_XFER_ALIGN___6 = 17,
    _PC_ALLOC_SIZE_MIN___6_PC_ALLOC_SIZE_MIN___6 = 18,
    _PC_SYMLINK_MAX___6_PC_SYMLINK_MAX___6 = 19,
    _PC_2_SYMLINKS___6_PC_2_SYMLINKS___6 = 20
} ;
#line 71
enum __anonenum_315186338___6 {
    _SC_ARG_MAX___6_SC_ARG_MAX___6 = 0,
    _SC_CHILD_MAX___6_SC_CHILD_MAX___6 = 1,
    _SC_CLK_TCK___6_SC_CLK_TCK___6 = 2,
    _SC_NGROUPS_MAX___6_SC_NGROUPS_MAX___6 = 3,
    _SC_OPEN_MAX___6_SC_OPEN_MAX___6 = 4,
    _SC_STREAM_MAX___6_SC_STREAM_MAX___6 = 5,
    _SC_TZNAME_MAX___6_SC_TZNAME_MAX___6 = 6,
    _SC_JOB_CONTROL___6_SC_JOB_CONTROL___6 = 7,
    _SC_SAVED_IDS___6_SC_SAVED_IDS___6 = 8,
    _SC_REALTIME_SIGNALS___6_SC_REALTIME_SIGNALS___6 = 9,
    _SC_PRIORITY_SCHEDULING___6_SC_PRIORITY_SCHEDULING___6 = 10,
    _SC_TIMERS___6_SC_TIMERS___6 = 11,
    _SC_ASYNCHRONOUS_IO___6_SC_ASYNCHRONOUS_IO___6 = 12,
    _SC_PRIORITIZED_IO___6_SC_PRIORITIZED_IO___6 = 13,
    _SC_SYNCHRONIZED_IO___6_SC_SYNCHRONIZED_IO___6 = 14,
    _SC_FSYNC___6_SC_FSYNC___6 = 15,
    _SC_MAPPED_FILES___6_SC_MAPPED_FILES___6 = 16,
    _SC_MEMLOCK___6_SC_MEMLOCK___6 = 17,
    _SC_MEMLOCK_RANGE___6_SC_MEMLOCK_RANGE___6 = 18,
    _SC_MEMORY_PROTECTION___6_SC_MEMORY_PROTECTION___6 = 19,
    _SC_MESSAGE_PASSING___6_SC_MESSAGE_PASSING___6 = 20,
    _SC_SEMAPHORES___6_SC_SEMAPHORES___6 = 21,
    _SC_SHARED_MEMORY_OBJECTS___6_SC_SHARED_MEMORY_OBJECTS___6 = 22,
    _SC_AIO_LISTIO_MAX___6_SC_AIO_LISTIO_MAX___6 = 23,
    _SC_AIO_MAX___6_SC_AIO_MAX___6 = 24,
    _SC_AIO_PRIO_DELTA_MAX___6_SC_AIO_PRIO_DELTA_MAX___6 = 25,
    _SC_DELAYTIMER_MAX___6_SC_DELAYTIMER_MAX___6 = 26,
    _SC_MQ_OPEN_MAX___6_SC_MQ_OPEN_MAX___6 = 27,
    _SC_MQ_PRIO_MAX___6_SC_MQ_PRIO_MAX___6 = 28,
    _SC_VERSION___6_SC_VERSION___6 = 29,
    _SC_PAGESIZE___6_SC_PAGESIZE___6 = 30,
    _SC_RTSIG_MAX___6_SC_RTSIG_MAX___6 = 31,
    _SC_SEM_NSEMS_MAX___6_SC_SEM_NSEMS_MAX___6 = 32,
    _SC_SEM_VALUE_MAX___6_SC_SEM_VALUE_MAX___6 = 33,
    _SC_SIGQUEUE_MAX___6_SC_SIGQUEUE_MAX___6 = 34,
    _SC_TIMER_MAX___6_SC_TIMER_MAX___6 = 35,
    _SC_BC_BASE_MAX___6_SC_BC_BASE_MAX___6 = 36,
    _SC_BC_DIM_MAX___6_SC_BC_DIM_MAX___6 = 37,
    _SC_BC_SCALE_MAX___6_SC_BC_SCALE_MAX___6 = 38,
    _SC_BC_STRING_MAX___6_SC_BC_STRING_MAX___6 = 39,
    _SC_COLL_WEIGHTS_MAX___6_SC_COLL_WEIGHTS_MAX___6 = 40,
    _SC_EQUIV_CLASS_MAX___6_SC_EQUIV_CLASS_MAX___6 = 41,
    _SC_EXPR_NEST_MAX___6_SC_EXPR_NEST_MAX___6 = 42,
    _SC_LINE_MAX___6_SC_LINE_MAX___6 = 43,
    _SC_RE_DUP_MAX___6_SC_RE_DUP_MAX___6 = 44,
    _SC_CHARCLASS_NAME_MAX___6_SC_CHARCLASS_NAME_MAX___6 = 45,
    _SC_2_VERSION___6_SC_2_VERSION___6 = 46,
    _SC_2_C_BIND___6_SC_2_C_BIND___6 = 47,
    _SC_2_C_DEV___6_SC_2_C_DEV___6 = 48,
    _SC_2_FORT_DEV___6_SC_2_FORT_DEV___6 = 49,
    _SC_2_FORT_RUN___6_SC_2_FORT_RUN___6 = 50,
    _SC_2_SW_DEV___6_SC_2_SW_DEV___6 = 51,
    _SC_2_LOCALEDEF___6_SC_2_LOCALEDEF___6 = 52,
    _SC_PII___6_SC_PII___6 = 53,
    _SC_PII_XTI___6_SC_PII_XTI___6 = 54,
    _SC_PII_SOCKET___6_SC_PII_SOCKET___6 = 55,
    _SC_PII_INTERNET___6_SC_PII_INTERNET___6 = 56,
    _SC_PII_OSI___6_SC_PII_OSI___6 = 57,
    _SC_POLL___6_SC_POLL___6 = 58,
    _SC_SELECT___6_SC_SELECT___6 = 59,
    _SC_UIO_MAXIOV___6_SC_UIO_MAXIOV___6 = 60,
    _SC_IOV_MAX___6_SC_IOV_MAX___6 = 60,
    _SC_PII_INTERNET_STREAM___6_SC_PII_INTERNET_STREAM___6 = 61,
    _SC_PII_INTERNET_DGRAM___6_SC_PII_INTERNET_DGRAM___6 = 62,
    _SC_PII_OSI_COTS___6_SC_PII_OSI_COTS___6 = 63,
    _SC_PII_OSI_CLTS___6_SC_PII_OSI_CLTS___6 = 64,
    _SC_PII_OSI_M___6_SC_PII_OSI_M___6 = 65,
    _SC_T_IOV_MAX___6_SC_T_IOV_MAX___6 = 66,
    _SC_THREADS___6_SC_THREADS___6 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___6_SC_THREAD_SAFE_FUNCTIONS___6 = 68,
    _SC_GETGR_R_SIZE_MAX___6_SC_GETGR_R_SIZE_MAX___6 = 69,
    _SC_GETPW_R_SIZE_MAX___6_SC_GETPW_R_SIZE_MAX___6 = 70,
    _SC_LOGIN_NAME_MAX___6_SC_LOGIN_NAME_MAX___6 = 71,
    _SC_TTY_NAME_MAX___6_SC_TTY_NAME_MAX___6 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___6_SC_THREAD_DESTRUCTOR_ITERATIONS___6 = 73,
    _SC_THREAD_KEYS_MAX___6_SC_THREAD_KEYS_MAX___6 = 74,
    _SC_THREAD_STACK_MIN___6_SC_THREAD_STACK_MIN___6 = 75,
    _SC_THREAD_THREADS_MAX___6_SC_THREAD_THREADS_MAX___6 = 76,
    _SC_THREAD_ATTR_STACKADDR___6_SC_THREAD_ATTR_STACKADDR___6 = 77,
    _SC_THREAD_ATTR_STACKSIZE___6_SC_THREAD_ATTR_STACKSIZE___6 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___6_SC_THREAD_PRIORITY_SCHEDULING___6 = 79,
    _SC_THREAD_PRIO_INHERIT___6_SC_THREAD_PRIO_INHERIT___6 = 80,
    _SC_THREAD_PRIO_PROTECT___6_SC_THREAD_PRIO_PROTECT___6 = 81,
    _SC_THREAD_PROCESS_SHARED___6_SC_THREAD_PROCESS_SHARED___6 = 82,
    _SC_NPROCESSORS_CONF___6_SC_NPROCESSORS_CONF___6 = 83,
    _SC_NPROCESSORS_ONLN___6_SC_NPROCESSORS_ONLN___6 = 84,
    _SC_PHYS_PAGES___6_SC_PHYS_PAGES___6 = 85,
    _SC_AVPHYS_PAGES___6_SC_AVPHYS_PAGES___6 = 86,
    _SC_ATEXIT_MAX___6_SC_ATEXIT_MAX___6 = 87,
    _SC_PASS_MAX___6_SC_PASS_MAX___6 = 88,
    _SC_XOPEN_VERSION___6_SC_XOPEN_VERSION___6 = 89,
    _SC_XOPEN_XCU_VERSION___6_SC_XOPEN_XCU_VERSION___6 = 90,
    _SC_XOPEN_UNIX___6_SC_XOPEN_UNIX___6 = 91,
    _SC_XOPEN_CRYPT___6_SC_XOPEN_CRYPT___6 = 92,
    _SC_XOPEN_ENH_I18N___6_SC_XOPEN_ENH_I18N___6 = 93,
    _SC_XOPEN_SHM___6_SC_XOPEN_SHM___6 = 94,
    _SC_2_CHAR_TERM___6_SC_2_CHAR_TERM___6 = 95,
    _SC_2_C_VERSION___6_SC_2_C_VERSION___6 = 96,
    _SC_2_UPE___6_SC_2_UPE___6 = 97,
    _SC_XOPEN_XPG2___6_SC_XOPEN_XPG2___6 = 98,
    _SC_XOPEN_XPG3___6_SC_XOPEN_XPG3___6 = 99,
    _SC_XOPEN_XPG4___6_SC_XOPEN_XPG4___6 = 100,
    _SC_CHAR_BIT___6_SC_CHAR_BIT___6 = 101,
    _SC_CHAR_MAX___6_SC_CHAR_MAX___6 = 102,
    _SC_CHAR_MIN___6_SC_CHAR_MIN___6 = 103,
    _SC_INT_MAX___6_SC_INT_MAX___6 = 104,
    _SC_INT_MIN___6_SC_INT_MIN___6 = 105,
    _SC_LONG_BIT___6_SC_LONG_BIT___6 = 106,
    _SC_WORD_BIT___6_SC_WORD_BIT___6 = 107,
    _SC_MB_LEN_MAX___6_SC_MB_LEN_MAX___6 = 108,
    _SC_NZERO___6_SC_NZERO___6 = 109,
    _SC_SSIZE_MAX___6_SC_SSIZE_MAX___6 = 110,
    _SC_SCHAR_MAX___6_SC_SCHAR_MAX___6 = 111,
    _SC_SCHAR_MIN___6_SC_SCHAR_MIN___6 = 112,
    _SC_SHRT_MAX___6_SC_SHRT_MAX___6 = 113,
    _SC_SHRT_MIN___6_SC_SHRT_MIN___6 = 114,
    _SC_UCHAR_MAX___6_SC_UCHAR_MAX___6 = 115,
    _SC_UINT_MAX___6_SC_UINT_MAX___6 = 116,
    _SC_ULONG_MAX___6_SC_ULONG_MAX___6 = 117,
    _SC_USHRT_MAX___6_SC_USHRT_MAX___6 = 118,
    _SC_NL_ARGMAX___6_SC_NL_ARGMAX___6 = 119,
    _SC_NL_LANGMAX___6_SC_NL_LANGMAX___6 = 120,
    _SC_NL_MSGMAX___6_SC_NL_MSGMAX___6 = 121,
    _SC_NL_NMAX___6_SC_NL_NMAX___6 = 122,
    _SC_NL_SETMAX___6_SC_NL_SETMAX___6 = 123,
    _SC_NL_TEXTMAX___6_SC_NL_TEXTMAX___6 = 124,
    _SC_XBS5_ILP32_OFF32___6_SC_XBS5_ILP32_OFF32___6 = 125,
    _SC_XBS5_ILP32_OFFBIG___6_SC_XBS5_ILP32_OFFBIG___6 = 126,
    _SC_XBS5_LP64_OFF64___6_SC_XBS5_LP64_OFF64___6 = 127,
    _SC_XBS5_LPBIG_OFFBIG___6_SC_XBS5_LPBIG_OFFBIG___6 = 128,
    _SC_XOPEN_LEGACY___6_SC_XOPEN_LEGACY___6 = 129,
    _SC_XOPEN_REALTIME___6_SC_XOPEN_REALTIME___6 = 130,
    _SC_XOPEN_REALTIME_THREADS___6_SC_XOPEN_REALTIME_THREADS___6 = 131,
    _SC_ADVISORY_INFO___6_SC_ADVISORY_INFO___6 = 132,
    _SC_BARRIERS___6_SC_BARRIERS___6 = 133,
    _SC_BASE___6_SC_BASE___6 = 134,
    _SC_C_LANG_SUPPORT___6_SC_C_LANG_SUPPORT___6 = 135,
    _SC_C_LANG_SUPPORT_R___6_SC_C_LANG_SUPPORT_R___6 = 136,
    _SC_CLOCK_SELECTION___6_SC_CLOCK_SELECTION___6 = 137,
    _SC_CPUTIME___6_SC_CPUTIME___6 = 138,
    _SC_THREAD_CPUTIME___6_SC_THREAD_CPUTIME___6 = 139,
    _SC_DEVICE_IO___6_SC_DEVICE_IO___6 = 140,
    _SC_DEVICE_SPECIFIC___6_SC_DEVICE_SPECIFIC___6 = 141,
    _SC_DEVICE_SPECIFIC_R___6_SC_DEVICE_SPECIFIC_R___6 = 142,
    _SC_FD_MGMT___6_SC_FD_MGMT___6 = 143,
    _SC_FIFO___6_SC_FIFO___6 = 144,
    _SC_PIPE___6_SC_PIPE___6 = 145,
    _SC_FILE_ATTRIBUTES___6_SC_FILE_ATTRIBUTES___6 = 146,
    _SC_FILE_LOCKING___6_SC_FILE_LOCKING___6 = 147,
    _SC_FILE_SYSTEM___6_SC_FILE_SYSTEM___6 = 148,
    _SC_MONOTONIC_CLOCK___6_SC_MONOTONIC_CLOCK___6 = 149,
    _SC_MULTI_PROCESS___6_SC_MULTI_PROCESS___6 = 150,
    _SC_SINGLE_PROCESS___6_SC_SINGLE_PROCESS___6 = 151,
    _SC_NETWORKING___6_SC_NETWORKING___6 = 152,
    _SC_READER_WRITER_LOCKS___6_SC_READER_WRITER_LOCKS___6 = 153,
    _SC_SPIN_LOCKS___6_SC_SPIN_LOCKS___6 = 154,
    _SC_REGEXP___6_SC_REGEXP___6 = 155,
    _SC_REGEX_VERSION___6_SC_REGEX_VERSION___6 = 156,
    _SC_SHELL___6_SC_SHELL___6 = 157,
    _SC_SIGNALS___6_SC_SIGNALS___6 = 158,
    _SC_SPAWN___6_SC_SPAWN___6 = 159,
    _SC_SPORADIC_SERVER___6_SC_SPORADIC_SERVER___6 = 160,
    _SC_THREAD_SPORADIC_SERVER___6_SC_THREAD_SPORADIC_SERVER___6 = 161,
    _SC_SYSTEM_DATABASE___6_SC_SYSTEM_DATABASE___6 = 162,
    _SC_SYSTEM_DATABASE_R___6_SC_SYSTEM_DATABASE_R___6 = 163,
    _SC_TIMEOUTS___6_SC_TIMEOUTS___6 = 164,
    _SC_TYPED_MEMORY_OBJECTS___6_SC_TYPED_MEMORY_OBJECTS___6 = 165,
    _SC_USER_GROUPS___6_SC_USER_GROUPS___6 = 166,
    _SC_USER_GROUPS_R___6_SC_USER_GROUPS_R___6 = 167,
    _SC_2_PBS___6_SC_2_PBS___6 = 168,
    _SC_2_PBS_ACCOUNTING___6_SC_2_PBS_ACCOUNTING___6 = 169,
    _SC_2_PBS_LOCATE___6_SC_2_PBS_LOCATE___6 = 170,
    _SC_2_PBS_MESSAGE___6_SC_2_PBS_MESSAGE___6 = 171,
    _SC_2_PBS_TRACK___6_SC_2_PBS_TRACK___6 = 172,
    _SC_SYMLOOP_MAX___6_SC_SYMLOOP_MAX___6 = 173,
    _SC_STREAMS___6_SC_STREAMS___6 = 174,
    _SC_2_PBS_CHECKPOINT___6_SC_2_PBS_CHECKPOINT___6 = 175,
    _SC_V6_ILP32_OFF32___6_SC_V6_ILP32_OFF32___6 = 176,
    _SC_V6_ILP32_OFFBIG___6_SC_V6_ILP32_OFFBIG___6 = 177,
    _SC_V6_LP64_OFF64___6_SC_V6_LP64_OFF64___6 = 178,
    _SC_V6_LPBIG_OFFBIG___6_SC_V6_LPBIG_OFFBIG___6 = 179,
    _SC_HOST_NAME_MAX___6_SC_HOST_NAME_MAX___6 = 180,
    _SC_TRACE___6_SC_TRACE___6 = 181,
    _SC_TRACE_EVENT_FILTER___6_SC_TRACE_EVENT_FILTER___6 = 182,
    _SC_TRACE_INHERIT___6_SC_TRACE_INHERIT___6 = 183,
    _SC_TRACE_LOG___6_SC_TRACE_LOG___6 = 184,
    _SC_LEVEL1_ICACHE_SIZE___6_SC_LEVEL1_ICACHE_SIZE___6 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___6_SC_LEVEL1_ICACHE_ASSOC___6 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___6_SC_LEVEL1_ICACHE_LINESIZE___6 = 187,
    _SC_LEVEL1_DCACHE_SIZE___6_SC_LEVEL1_DCACHE_SIZE___6 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___6_SC_LEVEL1_DCACHE_ASSOC___6 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___6_SC_LEVEL1_DCACHE_LINESIZE___6 = 190,
    _SC_LEVEL2_CACHE_SIZE___6_SC_LEVEL2_CACHE_SIZE___6 = 191,
    _SC_LEVEL2_CACHE_ASSOC___6_SC_LEVEL2_CACHE_ASSOC___6 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___6_SC_LEVEL2_CACHE_LINESIZE___6 = 193,
    _SC_LEVEL3_CACHE_SIZE___6_SC_LEVEL3_CACHE_SIZE___6 = 194,
    _SC_LEVEL3_CACHE_ASSOC___6_SC_LEVEL3_CACHE_ASSOC___6 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___6_SC_LEVEL3_CACHE_LINESIZE___6 = 196,
    _SC_LEVEL4_CACHE_SIZE___6_SC_LEVEL4_CACHE_SIZE___6 = 197,
    _SC_LEVEL4_CACHE_ASSOC___6_SC_LEVEL4_CACHE_ASSOC___6 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___6_SC_LEVEL4_CACHE_LINESIZE___6 = 199,
    _SC_IPV6___6_SC_IPV6___6 = 235,
    _SC_RAW_SOCKETS___6_SC_RAW_SOCKETS___6 = 236,
    _SC_V7_ILP32_OFF32___6_SC_V7_ILP32_OFF32___6 = 237,
    _SC_V7_ILP32_OFFBIG___6_SC_V7_ILP32_OFFBIG___6 = 238,
    _SC_V7_LP64_OFF64___6_SC_V7_LP64_OFF64___6 = 239,
    _SC_V7_LPBIG_OFFBIG___6_SC_V7_LPBIG_OFFBIG___6 = 240,
    _SC_SS_REPL_MAX___6_SC_SS_REPL_MAX___6 = 241,
    _SC_TRACE_EVENT_NAME_MAX___6_SC_TRACE_EVENT_NAME_MAX___6 = 242,
    _SC_TRACE_NAME_MAX___6_SC_TRACE_NAME_MAX___6 = 243,
    _SC_TRACE_SYS_MAX___6_SC_TRACE_SYS_MAX___6 = 244,
    _SC_TRACE_USER_EVENT_MAX___6_SC_TRACE_USER_EVENT_MAX___6 = 245,
    _SC_XOPEN_STREAMS___6_SC_XOPEN_STREAMS___6 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___6_SC_THREAD_ROBUST_PRIO_INHERIT___6 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___6_SC_THREAD_ROBUST_PRIO_PROTECT___6 = 248,
    _SC_MINSIGSTKSZ___6_SC_MINSIGSTKSZ___6 = 249,
    _SC_SIGSTKSZ___6_SC_SIGSTKSZ___6 = 250
} ;
#line 539
enum __anonenum_875524036___6 {
    _CS_PATH___6_CS_PATH___6 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___6_CS_V6_WIDTH_RESTRICTED_ENVS___6 = 1,
    _CS_GNU_LIBC_VERSION___6_CS_GNU_LIBC_VERSION___6 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___6_CS_GNU_LIBPTHREAD_VERSION___6 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___6_CS_V5_WIDTH_RESTRICTED_ENVS___6 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___6_CS_V7_WIDTH_RESTRICTED_ENVS___6 = 5,
    _CS_LFS_CFLAGS___6_CS_LFS_CFLAGS___6 = 1000,
    _CS_LFS_LDFLAGS___6_CS_LFS_LDFLAGS___6 = 1001,
    _CS_LFS_LIBS___6_CS_LFS_LIBS___6 = 1002,
    _CS_LFS_LINTFLAGS___6_CS_LFS_LINTFLAGS___6 = 1003,
    _CS_LFS64_CFLAGS___6_CS_LFS64_CFLAGS___6 = 1004,
    _CS_LFS64_LDFLAGS___6_CS_LFS64_LDFLAGS___6 = 1005,
    _CS_LFS64_LIBS___6_CS_LFS64_LIBS___6 = 1006,
    _CS_LFS64_LINTFLAGS___6_CS_LFS64_LINTFLAGS___6 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___6_CS_XBS5_ILP32_OFF32_CFLAGS___6 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___6_CS_XBS5_ILP32_OFF32_LDFLAGS___6 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___6_CS_XBS5_ILP32_OFF32_LIBS___6 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___6_CS_XBS5_ILP32_OFF32_LINTFLAGS___6 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___6_CS_XBS5_ILP32_OFFBIG_CFLAGS___6 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___6_CS_XBS5_ILP32_OFFBIG_LDFLAGS___6 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___6_CS_XBS5_ILP32_OFFBIG_LIBS___6 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___6_CS_XBS5_ILP32_OFFBIG_LINTFLAGS___6 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___6_CS_XBS5_LP64_OFF64_CFLAGS___6 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___6_CS_XBS5_LP64_OFF64_LDFLAGS___6 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___6_CS_XBS5_LP64_OFF64_LIBS___6 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___6_CS_XBS5_LP64_OFF64_LINTFLAGS___6 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___6_CS_XBS5_LPBIG_OFFBIG_CFLAGS___6 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___6_CS_XBS5_LPBIG_OFFBIG_LDFLAGS___6 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___6_CS_XBS5_LPBIG_OFFBIG_LIBS___6 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___6_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___6 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___6_CS_POSIX_V6_ILP32_OFF32_CFLAGS___6 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___6_CS_POSIX_V6_ILP32_OFF32_LDFLAGS___6 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___6_CS_POSIX_V6_ILP32_OFF32_LIBS___6 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___6_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___6 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___6_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___6 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___6_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___6 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___6_CS_POSIX_V6_ILP32_OFFBIG_LIBS___6 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___6_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___6 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___6_CS_POSIX_V6_LP64_OFF64_CFLAGS___6 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___6_CS_POSIX_V6_LP64_OFF64_LDFLAGS___6 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___6_CS_POSIX_V6_LP64_OFF64_LIBS___6 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___6_CS_POSIX_V6_LP64_OFF64_LINTFLAGS___6 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___6_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___6 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___6_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___6 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___6_CS_POSIX_V6_LPBIG_OFFBIG_LIBS___6 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___6_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___6 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___6_CS_POSIX_V7_ILP32_OFF32_CFLAGS___6 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___6_CS_POSIX_V7_ILP32_OFF32_LDFLAGS___6 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___6_CS_POSIX_V7_ILP32_OFF32_LIBS___6 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___6_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___6 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___6_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___6 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___6_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___6 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___6_CS_POSIX_V7_ILP32_OFFBIG_LIBS___6 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___6_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___6 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___6_CS_POSIX_V7_LP64_OFF64_CFLAGS___6 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___6_CS_POSIX_V7_LP64_OFF64_LDFLAGS___6 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___6_CS_POSIX_V7_LP64_OFF64_LIBS___6 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___6_CS_POSIX_V7_LP64_OFF64_LINTFLAGS___6 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___6_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___6 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___6_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___6 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___6_CS_POSIX_V7_LPBIG_OFFBIG_LIBS___6 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___6_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___6 = 1147,
    _CS_V6_ENV___6_CS_V6_ENV___6 = 1148,
    _CS_V7_ENV___6_CS_V7_ENV___6 = 1149
} ;
#line 82 "/usr/include/malloc.h"
struct mallinfo {
   int arena ;
   int ordblks ;
   int smblks ;
   int hblks ;
   int hblkhd ;
   int usmblks ;
   int fsmblks ;
   int uordblks ;
   int fordblks ;
   int keepcost ;
};
#line 99 "/usr/include/malloc.h"
struct mallinfo2 {
   size_t arena ;
   size_t ordblks ;
   size_t smblks ;
   size_t hblks ;
   size_t hblkhd ;
   size_t usmblks ;
   size_t fsmblks ;
   size_t uordblks ;
   size_t fordblks ;
   size_t keepcost ;
};
#line 353 "w_wad.c"
union __anonunion_name8_951761807 {
   char s[9] ;
   int x[2] ;
};
#line 33 "doomdef.h"
enum __anonenum_82154846___41 {
    VERSION___41VERSION___41 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___40 {
    FP_NAN___40FP_NAN___40 = 0,
    FP_INFINITE___40FP_INFINITE___40 = 1,
    FP_ZERO___40FP_ZERO___40 = 2,
    FP_SUBNORMAL___40FP_SUBNORMAL___40 = 3,
    FP_NORMAL___40FP_NORMAL___40 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___39 {
    ML_LABEL___39ML_LABEL___39 = 0,
    ML_THINGS___39ML_THINGS___39 = 1,
    ML_LINEDEFS___39ML_LINEDEFS___39 = 2,
    ML_SIDEDEFS___39ML_SIDEDEFS___39 = 3,
    ML_VERTEXES___39ML_VERTEXES___39 = 4,
    ML_SEGS___39ML_SEGS___39 = 5,
    ML_SSECTORS___39ML_SSECTORS___39 = 6,
    ML_NODES___39ML_NODES___39 = 7,
    ML_SECTORS___39ML_SECTORS___39 = 8,
    ML_REJECT___39ML_REJECT___39 = 9,
    ML_BLOCKMAP___39ML_BLOCKMAP___39 = 10
} ;
#line 114 "wi_stuff.c"
enum __anonenum_animenum_t_917792770 {
    ANIM_ALWAYSANIM_ALWAYS = 0,
    ANIM_RANDOMANIM_RANDOM = 1,
    ANIM_LEVELANIM_LEVEL = 2
} ;
#line 114 "wi_stuff.c"
typedef enum __anonenum_animenum_t_917792770 animenum_t;
#line 122 "wi_stuff.c"
struct __anonstruct_point_t_773697287 {
   int x ;
   int y ;
};
#line 122 "wi_stuff.c"
typedef struct __anonstruct_point_t_773697287 point_t;
#line 134 "wi_stuff.c"
struct __anonstruct_anim_t_244083324 {
   animenum_t type ;
   int period ;
   int nanims ;
   point_t loc ;
   int data1 ;
   int data2 ;
   patch_t *p[3] ;
   int nexttic ;
   int lastdrawn ;
   int ctr ;
   int state ;
};
#line 134 "wi_stuff.c"
typedef struct __anonstruct_anim_t_244083324 anim_t___0;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___41 {
    FP_NAN___41FP_NAN___41 = 0,
    FP_INFINITE___41FP_INFINITE___41 = 1,
    FP_ZERO___41FP_ZERO___41 = 2,
    FP_SUBNORMAL___41FP_SUBNORMAL___41 = 3,
    FP_NORMAL___41FP_NORMAL___41 = 4
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___42 {
    VERSION___42VERSION___42 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___40 {
    ML_LABEL___40ML_LABEL___40 = 0,
    ML_THINGS___40ML_THINGS___40 = 1,
    ML_LINEDEFS___40ML_LINEDEFS___40 = 2,
    ML_SIDEDEFS___40ML_SIDEDEFS___40 = 3,
    ML_VERTEXES___40ML_VERTEXES___40 = 4,
    ML_SEGS___40ML_SEGS___40 = 5,
    ML_SSECTORS___40ML_SSECTORS___40 = 6,
    ML_NODES___40ML_NODES___40 = 7,
    ML_SECTORS___40ML_SECTORS___40 = 8,
    ML_REJECT___40ML_REJECT___40 = 9,
    ML_BLOCKMAP___40ML_BLOCKMAP___40 = 10
} ;
#line 32 "m_bbox.h"
enum __anonenum_607001913___5 {
    BOXTOP___5BOXTOP___5 = 0,
    BOXBOTTOM___5BOXBOTTOM___5 = 1,
    BOXLEFT___5BOXLEFT___5 = 2,
    BOXRIGHT___5BOXRIGHT___5 = 3
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum_18926444___3 {
    _ISupper___3_ISupper___3 = 256,
    _ISlower___3_ISlower___3 = 512,
    _ISalpha___3_ISalpha___3 = 1024,
    _ISdigit___3_ISdigit___3 = 2048,
    _ISxdigit___3_ISxdigit___3 = 4096,
    _ISspace___3_ISspace___3 = 8192,
    _ISprint___3_ISprint___3 = 16384,
    _ISgraph___3_ISgraph___3 = 32768,
    _ISblank___3_ISblank___3 = 1,
    _IScntrl___3_IScntrl___3 = 2,
    _ISpunct___3_ISpunct___3 = 4,
    _ISalnum___3_ISalnum___3 = 8
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___43 {
    VERSION___43VERSION___43 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___42 {
    FP_NAN___42FP_NAN___42 = 0,
    FP_INFINITE___42FP_INFINITE___42 = 1,
    FP_ZERO___42FP_ZERO___42 = 2,
    FP_SUBNORMAL___42FP_SUBNORMAL___42 = 3,
    FP_NORMAL___42FP_NORMAL___42 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___41 {
    ML_LABEL___41ML_LABEL___41 = 0,
    ML_THINGS___41ML_THINGS___41 = 1,
    ML_LINEDEFS___41ML_LINEDEFS___41 = 2,
    ML_SIDEDEFS___41ML_SIDEDEFS___41 = 3,
    ML_VERTEXES___41ML_VERTEXES___41 = 4,
    ML_SEGS___41ML_SEGS___41 = 5,
    ML_SSECTORS___41ML_SSECTORS___41 = 6,
    ML_NODES___41ML_NODES___41 = 7,
    ML_SECTORS___41ML_SECTORS___41 = 8,
    ML_REJECT___41ML_REJECT___41 = 9,
    ML_BLOCKMAP___41ML_BLOCKMAP___41 = 10
} ;
#line 44 "st_lib.h"
struct __anonstruct_st_number_t_568662620 {
   int x ;
   int y ;
   int width ;
   int oldnum ;
   int *num ;
   boolean *on ;
   patch_t **p ;
   int data ;
};
#line 44 "st_lib.h"
typedef struct __anonstruct_st_number_t_568662620 st_number_t;
#line 76 "st_lib.h"
struct __anonstruct_st_percent_t_422062039 {
   st_number_t n ;
   patch_t *p ;
};
#line 76 "st_lib.h"
typedef struct __anonstruct_st_percent_t_422062039 st_percent_t;
#line 89 "st_lib.h"
struct __anonstruct_st_multicon_t_298241913 {
   int x ;
   int y ;
   int oldinum ;
   int *inum ;
   boolean *on ;
   patch_t **p ;
   int data ;
};
#line 89 "st_lib.h"
typedef struct __anonstruct_st_multicon_t_298241913 st_multicon_t;
#line 118 "st_lib.h"
struct __anonstruct_st_binicon_t_314590282 {
   int x ;
   int y ;
   int oldval ;
   boolean *val ;
   boolean *on ;
   patch_t *p ;
   int data ;
};
#line 118 "st_lib.h"
typedef struct __anonstruct_st_binicon_t_314590282 st_binicon_t;
#line 33 "doomdef.h"
enum __anonenum_82154846___44 {
    VERSION___44VERSION___44 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___43 {
    FP_NAN___43FP_NAN___43 = 0,
    FP_INFINITE___43FP_INFINITE___43 = 1,
    FP_ZERO___43FP_ZERO___43 = 2,
    FP_SUBNORMAL___43FP_SUBNORMAL___43 = 3,
    FP_NORMAL___43FP_NORMAL___43 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___42 {
    ML_LABEL___42ML_LABEL___42 = 0,
    ML_THINGS___42ML_THINGS___42 = 1,
    ML_LINEDEFS___42ML_LINEDEFS___42 = 2,
    ML_SIDEDEFS___42ML_SIDEDEFS___42 = 3,
    ML_VERTEXES___42ML_VERTEXES___42 = 4,
    ML_SEGS___42ML_SEGS___42 = 5,
    ML_SSECTORS___42ML_SSECTORS___42 = 6,
    ML_NODES___42ML_NODES___42 = 7,
    ML_SECTORS___42ML_SECTORS___42 = 8,
    ML_REJECT___42ML_REJECT___42 = 9,
    ML_BLOCKMAP___42ML_BLOCKMAP___42 = 10
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum_18926444___4 {
    _ISupper___4_ISupper___4 = 256,
    _ISlower___4_ISlower___4 = 512,
    _ISalpha___4_ISalpha___4 = 1024,
    _ISdigit___4_ISdigit___4 = 2048,
    _ISxdigit___4_ISxdigit___4 = 4096,
    _ISspace___4_ISspace___4 = 8192,
    _ISprint___4_ISprint___4 = 16384,
    _ISgraph___4_ISgraph___4 = 32768,
    _ISblank___4_ISblank___4 = 1,
    _IScntrl___4_IScntrl___4 = 2,
    _ISpunct___4_ISpunct___4 = 4,
    _ISalnum___4_ISalnum___4 = 8
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___45 {
    VERSION___45VERSION___45 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___44 {
    FP_NAN___44FP_NAN___44 = 0,
    FP_INFINITE___44FP_INFINITE___44 = 1,
    FP_ZERO___44FP_ZERO___44 = 2,
    FP_SUBNORMAL___44FP_SUBNORMAL___44 = 3,
    FP_NORMAL___44FP_NORMAL___44 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___43 {
    ML_LABEL___43ML_LABEL___43 = 0,
    ML_THINGS___43ML_THINGS___43 = 1,
    ML_LINEDEFS___43ML_LINEDEFS___43 = 2,
    ML_SIDEDEFS___43ML_SIDEDEFS___43 = 3,
    ML_VERTEXES___43ML_VERTEXES___43 = 4,
    ML_SEGS___43ML_SEGS___43 = 5,
    ML_SSECTORS___43ML_SSECTORS___43 = 6,
    ML_NODES___43ML_NODES___43 = 7,
    ML_SECTORS___43ML_SECTORS___43 = 8,
    ML_REJECT___43ML_REJECT___43 = 9,
    ML_BLOCKMAP___43ML_BLOCKMAP___43 = 10
} ;
#line 45 "hu_lib.h"
struct __anonstruct_hu_textline_t_424010621 {
   int x ;
   int y ;
   patch_t **f ;
   int sc ;
   char l[81] ;
   int len ;
   int needsupdate ;
};
#line 45 "hu_lib.h"
typedef struct __anonstruct_hu_textline_t_424010621 hu_textline_t;
#line 65 "hu_lib.h"
struct __anonstruct_hu_stext_t_65011905 {
   hu_textline_t l[4] ;
   int h ;
   int cl ;
   boolean *on ;
   boolean laston ;
};
#line 65 "hu_lib.h"
typedef struct __anonstruct_hu_stext_t_65011905 hu_stext_t;
#line 81 "hu_lib.h"
struct __anonstruct_hu_itext_t_8644437 {
   hu_textline_t l ;
   int lm ;
   boolean *on ;
   boolean laston ;
};
#line 81 "hu_lib.h"
typedef struct __anonstruct_hu_itext_t_8644437 hu_itext_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum_18926444___5 {
    _ISupper___5_ISupper___5 = 256,
    _ISlower___5_ISlower___5 = 512,
    _ISalpha___5_ISalpha___5 = 1024,
    _ISdigit___5_ISdigit___5 = 2048,
    _ISxdigit___5_ISxdigit___5 = 4096,
    _ISspace___5_ISspace___5 = 8192,
    _ISprint___5_ISprint___5 = 16384,
    _ISgraph___5_ISgraph___5 = 32768,
    _ISblank___5_ISblank___5 = 1,
    _IScntrl___5_IScntrl___5 = 2,
    _ISpunct___5_ISpunct___5 = 4,
    _ISalnum___5_ISalnum___5 = 8
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___46 {
    VERSION___46VERSION___46 = 110
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___45 {
    FP_NAN___45FP_NAN___45 = 0,
    FP_INFINITE___45FP_INFINITE___45 = 1,
    FP_ZERO___45FP_ZERO___45 = 2,
    FP_SUBNORMAL___45FP_SUBNORMAL___45 = 3,
    FP_NORMAL___45FP_NORMAL___45 = 4
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___44 {
    ML_LABEL___44ML_LABEL___44 = 0,
    ML_THINGS___44ML_THINGS___44 = 1,
    ML_LINEDEFS___44ML_LINEDEFS___44 = 2,
    ML_SIDEDEFS___44ML_SIDEDEFS___44 = 3,
    ML_VERTEXES___44ML_VERTEXES___44 = 4,
    ML_SEGS___44ML_SEGS___44 = 5,
    ML_SSECTORS___44ML_SSECTORS___44 = 6,
    ML_NODES___44ML_NODES___44 = 7,
    ML_SECTORS___44ML_SECTORS___44 = 8,
    ML_REJECT___44ML_REJECT___44 = 9,
    ML_BLOCKMAP___44ML_BLOCKMAP___44 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___47 {
    VERSION___47VERSION___47 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___45 {
    ML_LABEL___45ML_LABEL___45 = 0,
    ML_THINGS___45ML_THINGS___45 = 1,
    ML_LINEDEFS___45ML_LINEDEFS___45 = 2,
    ML_SIDEDEFS___45ML_SIDEDEFS___45 = 3,
    ML_VERTEXES___45ML_VERTEXES___45 = 4,
    ML_SEGS___45ML_SEGS___45 = 5,
    ML_SSECTORS___45ML_SSECTORS___45 = 6,
    ML_NODES___45ML_NODES___45 = 7,
    ML_SECTORS___45ML_SECTORS___45 = 8,
    ML_REJECT___45ML_REJECT___45 = 9,
    ML_BLOCKMAP___45ML_BLOCKMAP___45 = 10
} ;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___46 {
    FP_NAN___46FP_NAN___46 = 0,
    FP_INFINITE___46FP_INFINITE___46 = 1,
    FP_ZERO___46FP_ZERO___46 = 2,
    FP_SUBNORMAL___46FP_SUBNORMAL___46 = 3,
    FP_NORMAL___46FP_NORMAL___46 = 4
} ;
#line 93 "s_sound.c"
struct __anonstruct_channel_t_64213081 {
   sfxinfo_t *sfxinfo ;
   void *origin ;
   int handle ;
};
#line 93 "s_sound.c"
typedef struct __anonstruct_channel_t_64213081 channel_t;
#line 33 "doomdef.h"
enum __anonenum_82154846___48 {
    VERSION___48VERSION___48 = 110
} ;
#line 46 "z_zone.c"
struct __anonstruct_memzone_t_1007269820 {
   int size ;
   memblock_t blocklist ;
   memblock_t *rover ;
};
#line 46 "z_zone.c"
typedef struct __anonstruct_memzone_t_1007269820 memzone_t;
#line 934 "/usr/include/math.h"
enum __anonenum_1037408945___47 {
    FP_NAN___47FP_NAN___47 = 0,
    FP_INFINITE___47FP_INFINITE___47 = 1,
    FP_ZERO___47FP_ZERO___47 = 2,
    FP_SUBNORMAL___47FP_SUBNORMAL___47 = 3,
    FP_NORMAL___47FP_NORMAL___47 = 4
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___49 {
    VERSION___49VERSION___49 = 110
} ;
#line 43 "doomdata.h"
enum __anonenum_715321526___46 {
    ML_LABEL___46ML_LABEL___46 = 0,
    ML_THINGS___46ML_THINGS___46 = 1,
    ML_LINEDEFS___46ML_LINEDEFS___46 = 2,
    ML_SIDEDEFS___46ML_SIDEDEFS___46 = 3,
    ML_VERTEXES___46ML_VERTEXES___46 = 4,
    ML_SEGS___46ML_SEGS___46 = 5,
    ML_SSECTORS___46ML_SSECTORS___46 = 6,
    ML_NODES___46ML_NODES___46 = 7,
    ML_SECTORS___46ML_SECTORS___46 = 8,
    ML_REJECT___46ML_REJECT___46 = 9,
    ML_BLOCKMAP___46ML_BLOCKMAP___46 = 10
} ;
#line 33 "doomdef.h"
enum __anonenum_82154846___50 {
    VERSION___50VERSION___50 = 110
} ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t___0;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t___0;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t___0 __int_least64_t___0;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t___0 __uint_least64_t___0;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t___0;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t___0;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t___0;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t___0;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t___0;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t___0;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t___0;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t___0;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t___0;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds64_t___0;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t___0;
#line 185 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t___0;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t___0;
#line 192 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t___0;
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t___0;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t___0 __loff_t___0;
#line 207 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t___0;
#line 214 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
typedef unsigned long size_t___0;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_cpu_set_t_826868708 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_cpu_set_t_826868708 cpu_set_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s___0 {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t___0 {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t___0 {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t___0 pthread_attr_t___0;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_335460617___0 {
   struct __pthread_mutex_s___0 __data ;
   char __size[40] ;
   long __align ;
};
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_335460617___0 pthread_mutex_t___0;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_656928968___0 {
   struct __pthread_rwlock_arch_t___0 __data ;
   char __size[56] ;
   long __align ;
};
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_656928968___0 pthread_rwlock_t___0;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_barrier_t_145707746___0 {
   char __size[32] ;
   long __align ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_barrier_t_145707746___0 pthread_barrier_t___0;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum_34415463 {
    PTHREAD_CREATE_JOINABLEPTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHEDPTHREAD_CREATE_DETACHED = 1
} ;
#line 47
enum __anonenum_508643754 {
    PTHREAD_MUTEX_TIMED_NPPTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NPPTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NPPTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NPPTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMALPTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVEPTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECKPTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_DEFAULT = 0
} ;
#line 69
enum __anonenum_931900394 {
    PTHREAD_MUTEX_STALLEDPTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NPPTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUSTPTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NPPTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 81
enum __anonenum_205214487 {
    PTHREAD_PRIO_NONEPTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERITPTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECTPTHREAD_PRIO_PROTECT = 2
} ;
#line 104
enum __anonenum_25043950 {
    PTHREAD_RWLOCK_PREFER_READER_NPPTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NPPTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NPPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NPPTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 124
enum __anonenum_436439511 {
    PTHREAD_INHERIT_SCHEDPTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHEDPTHREAD_EXPLICIT_SCHED = 1
} ;
#line 134
enum __anonenum_998661166 {
    PTHREAD_SCOPE_SYSTEMPTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESSPTHREAD_SCOPE_PROCESS = 1
} ;
#line 144
enum __anonenum_146137331 {
    PTHREAD_PROCESS_PRIVATEPTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHAREDPTHREAD_PROCESS_SHARED = 1
} ;
#line 159 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 168
enum __anonenum_53396917 {
    PTHREAD_CANCEL_ENABLEPTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLEPTHREAD_CANCEL_DISABLE = 1
} ;
#line 175
enum __anonenum_904563783 {
    PTHREAD_CANCEL_DEFERREDPTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUSPTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 538 "/usr/include/pthread.h"
struct __cancel_jmp_buf_tag {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 544 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_530692248 {
   struct __cancel_jmp_buf_tag __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 544 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_530692248  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 557 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 145 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
typedef long ptrdiff_t___0;
#line 329 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
typedef int wchar_t___0;
#line 425 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
struct __anonstruct_max_align_t_896270833 {
   long long __max_align_ll  __attribute__((__aligned__(__alignof__(long long )))) ;
   long double __max_align_ld  __attribute__((__aligned__(__alignof__(long double )))) ;
};
#line 425 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h"
typedef struct __anonstruct_max_align_t_896270833 max_align_t;
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_frob_return_address(void * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_and_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_or(...) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch(...) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_16(...) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_16(...) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_1(...) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or(...) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   void __sync_synchronize(...) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_or_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_4(...) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_4(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_n(...) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_add_and_fetch(...) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __atomic_signal_fence(int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_nand(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_2(...) ;  */
/* compiler builtin: 
   void __atomic_thread_fence(int  ) ;  */
/* compiler builtin: 
   void __atomic_store_16(...) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_8(...) ;  */
/* compiler builtin: 
   short __builtin_bswap16(short  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_2(...) ;  */
/* compiler builtin: 
   _Bool __atomic_test_and_set(void * , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_8(...) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_16(...) ;  */
/* compiler builtin: 
   void __atomic_clear(_Bool * , int  ) ;  */
/* compiler builtin: 
   void __atomic_store(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_2(...) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch(...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_4(...) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_sub_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_nand_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_16(...) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* compiler builtin: 
   _Bool __atomic_always_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_xor_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_8(...) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_1(...) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_and(...) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   void __atomic_feraiseexcept(int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_4(...) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_1(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_2(...) ;  */
/* compiler builtin: 
   void __sync_lock_release(...) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_8(...) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add(...) ;  */
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_2(...) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_n(...) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_16(...) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_n(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_1(...) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   char *__builtin_strcat(char * , char const   * ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_1(...) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_1(...) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_4(...) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_2(...) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __atomic_store_2(...) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_xor(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_4(...) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange(...) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_1(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_1(...) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_2(...) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   void __atomic_load(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_val_compare_and_swap(...) ;  */
/* compiler builtin: 
   void __atomic_store_4(...) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_16(...) ;  */
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_2(...) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   void __atomic_exchange(...) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_8(...) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_16(...) ;  */
/* compiler builtin: 
   void *__builtin_memchr(void const   * , int  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_2(...) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_2(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_16(...) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_16(...) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_4(...) ;  */
/* compiler builtin: 
   void __atomic_store_n(...) ;  */
/* compiler builtin: 
   void __builtin_trap(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_4(...) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_lock_test_and_set(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_16(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch(...) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_8(...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch(...) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void __atomic_store_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_8(...) ;  */
/* compiler builtin: 
   _Bool __sync_bool_compare_and_swap(...) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __builtin_tgmath(...) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_1(...) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   void __atomic_store_1(...) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_16(...) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_sub(...) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_2(...) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   _Bool __atomic_is_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub(...) ;  */
/* compiler builtin: 
   void *__builtin_extract_return_addr(void * ) ;  */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_4(...) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
#line 25 "doomdef.c"
static char const   rcsid[49]  = 
#line 25 "doomdef.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'b', 
        (char const   )'b',      (char const   )'o',      (char const   )'x',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 149 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 150
extern FILE *stdout ;
#line 151
extern FILE *stderr ;
#line 158
extern int ( __attribute__((__leaf__)) remove)(char const   *__filename )  __attribute__((__nothrow__)) ;
#line 160
extern int ( __attribute__((__leaf__)) rename)(char const   *__old , char const   *__new )  __attribute__((__nothrow__)) ;
#line 164
extern int ( __attribute__((__leaf__)) renameat)(int __oldfd , char const   *__old ,
                                                 int __newfd , char const   *__new )  __attribute__((__nothrow__)) ;
#line 184
extern int ( __attribute__((__nonnull__(1))) fclose)(FILE *__stream ) ;
#line 194
extern FILE *tmpfile(void)  __attribute__((__malloc__(fclose,1), __malloc__)) ;
#line 211
extern char *( __attribute__((__leaf__)) tmpnam)(char * )  __attribute__((__nothrow__)) ;
#line 216
extern char *( __attribute__((__leaf__)) tmpnam_r)(char *__s )  __attribute__((__nothrow__)) ;
#line 228
extern char *( __attribute__((__leaf__)) tempnam)(char const   *__dir , char const   *__pfx )  __attribute__((__nothrow__,
__malloc__(__builtin_free,1), __malloc__)) ;
#line 236
extern int fflush(FILE *__stream ) ;
#line 245
extern int fflush_unlocked(FILE *__stream ) ;
#line 264
extern FILE *fopen(char const   *__filename , char const   *__modes )  __attribute__((__malloc__(fclose,1),
__malloc__)) ;
#line 271
extern FILE *( __attribute__((__nonnull__(3))) freopen)(char const   *__filename ,
                                                        char const   *__modes , FILE *__stream ) ;
#line 299
extern FILE *( __attribute__((__leaf__)) fdopen)(int __fd , char const   *__modes )  __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
#line 306
extern FILE *( __attribute__((__leaf__)) fopencookie)(void *__magic_cookie , char const   *__modes ,
                                                      cookie_io_functions_t __io_funcs )  __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
#line 314
extern FILE *( __attribute__((__leaf__)) fmemopen)(void *__s , size_t __len , char const   *__modes )  __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
#line 320
extern FILE *( __attribute__((__leaf__)) open_memstream)(char **__bufloc , size_t *__sizeloc )  __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
#line 334
extern void ( __attribute__((__nonnull__(1), __leaf__)) setbuf)(FILE *__stream , char *__buf )  __attribute__((__nothrow__)) ;
#line 339
extern int ( __attribute__((__nonnull__(1), __leaf__)) setvbuf)(FILE *__stream , char *__buf ,
                                                                int __modes , size_t __n )  __attribute__((__nothrow__)) ;
#line 345
extern void ( __attribute__((__nonnull__(1), __leaf__)) setbuffer)(FILE *__stream ,
                                                                   char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 349
extern void ( __attribute__((__nonnull__(1), __leaf__)) setlinebuf)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 357
extern int ( __attribute__((__nonnull__(1))) fprintf)(FILE *__stream , char const   *__format 
                                                      , ...) ;
#line 363
extern int printf(char const   *__format  , ...) ;
#line 365
extern int sprintf(char *__s , char const   *__format  , ...)  __attribute__((__nothrow__)) ;
#line 372
extern int ( __attribute__((__nonnull__(1))) vfprintf)(FILE *__s , char const   *__format ,
                                                       __gnuc_va_list __arg ) ;
#line 378
extern int vprintf(char const   *__format , __gnuc_va_list __arg ) ;
#line 380
extern int vsprintf(char *__s , char const   *__format , __gnuc_va_list __arg )  __attribute__((__nothrow__)) ;
#line 385
extern int ( /* format attribute */  snprintf)(char *__s , size_t __maxlen , char const   *__format 
                                               , ...)  __attribute__((__nothrow__)) ;
#line 389
extern int ( /* format attribute */  vsnprintf)(char *__s , size_t __maxlen , char const   *__format ,
                                                __gnuc_va_list __arg )  __attribute__((__nothrow__)) ;
#line 397
extern int ( /* format attribute */  vasprintf)(char **__ptr , char const   *__f ,
                                                __gnuc_va_list __arg )  __attribute__((__nothrow__)) ;
#line 400
extern int ( /* format attribute */  __asprintf)(char **__ptr , char const   *__fmt 
                                                 , ...)  __attribute__((__nothrow__)) ;
#line 403
extern int ( /* format attribute */  asprintf)(char **__ptr , char const   *__fmt 
                                               , ...)  __attribute__((__nothrow__)) ;
#line 410
extern int ( /* format attribute */  vdprintf)(int __fd , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 413
extern int ( /* format attribute */  dprintf)(int __fd , char const   *__fmt  , ...) ;
#line 422
extern int ( __attribute__((__nonnull__(1))) fscanf)(FILE *__stream , char const   *__format 
                                                     , ...)  __asm__("__isoc99_fscanf")  ;
#line 428
extern int scanf(char const   *__format  , ...)  __asm__("__isoc99_scanf")  ;
#line 430
extern int ( __attribute__((__leaf__)) sscanf)(char const   *__s , char const   *__format 
                                               , ...)  __asm__("__isoc99_sscanf") __attribute__((__nothrow__)) ;
#line 490
extern int ( /* format attribute */ __attribute__((__nonnull__(1))) vfscanf)(FILE *__s ,
                                                                             char const   *__format ,
                                                                             __gnuc_va_list __arg )  __asm__("__isoc99_vfscanf")  ;
#line 498
extern int ( /* format attribute */  vscanf)(char const   *__format , __gnuc_va_list __arg )  __asm__("__isoc99_vscanf")  ;
#line 502
extern int ( /* format attribute */ __attribute__((__leaf__)) vsscanf)(char const   *__s ,
                                                                       char const   *__format ,
                                                                       __gnuc_va_list __arg )  __asm__("__isoc99_vsscanf") __attribute__((__nothrow__)) ;
#line 575
extern int ( __attribute__((__nonnull__(1))) fgetc)(FILE *__stream ) ;
#line 576
extern int ( __attribute__((__nonnull__(1))) getc)(FILE *__stream ) ;
#line 582
extern int getchar(void) ;
#line 589
extern int ( __attribute__((__nonnull__(1))) getc_unlocked)(FILE *__stream ) ;
#line 590
extern int getchar_unlocked(void) ;
#line 600
extern int ( __attribute__((__nonnull__(1))) fgetc_unlocked)(FILE *__stream ) ;
#line 611
extern int ( __attribute__((__nonnull__(2))) fputc)(int __c , FILE *__stream ) ;
#line 612
extern int ( __attribute__((__nonnull__(2))) putc)(int __c , FILE *__stream ) ;
#line 618
extern int putchar(int __c ) ;
#line 627
extern int ( __attribute__((__nonnull__(2))) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 635
extern int ( __attribute__((__nonnull__(2))) putc_unlocked)(int __c , FILE *__stream ) ;
#line 636
extern int putchar_unlocked(int __c ) ;
#line 643
extern int ( __attribute__((__nonnull__(1))) getw)(FILE *__stream ) ;
#line 646
extern int ( __attribute__((__nonnull__(2))) putw)(int __w , FILE *__stream ) ;
#line 654
extern char *( __attribute__((__nonnull__(3))) fgets)(char *__s , int __n , FILE *__stream )  __attribute__((__access__(__write_only__,1,2))) ;
#line 667
extern char *gets(char *__s )  __attribute__((__deprecated__)) ;
#line 689
extern __ssize_t ( __attribute__((__nonnull__(4))) __getdelim)(char **__lineptr ,
                                                               size_t *__n , int __delimiter ,
                                                               FILE *__stream ) ;
#line 692
extern __ssize_t ( __attribute__((__nonnull__(4))) getdelim)(char **__lineptr , size_t *__n ,
                                                             int __delimiter , FILE *__stream ) ;
#line 697
extern __ssize_t ( __attribute__((__nonnull__(3))) getline)(char **__lineptr , size_t *__n ,
                                                            FILE *__stream ) ;
#line 707
extern int ( __attribute__((__nonnull__(2))) fputs)(char const   *__s , FILE *__stream ) ;
#line 714
extern int puts(char const   *__s ) ;
#line 721
extern int ( __attribute__((__nonnull__(2))) ungetc)(int __c , FILE *__stream ) ;
#line 728
extern size_t ( __attribute__((__nonnull__(4))) fread)(void *__ptr , size_t __size ,
                                                       size_t __n , FILE *__stream ) ;
#line 735
extern size_t ( __attribute__((__nonnull__(4))) fwrite)(void const   *__ptr , size_t __size ,
                                                        size_t __n , FILE *__s ) ;
#line 756
extern size_t ( __attribute__((__nonnull__(4))) fread_unlocked)(void *__ptr , size_t __size ,
                                                                size_t __n , FILE *__stream ) ;
#line 759
extern size_t ( __attribute__((__nonnull__(4))) fwrite_unlocked)(void const   *__ptr ,
                                                                 size_t __size , size_t __n ,
                                                                 FILE *__stream ) ;
#line 769
extern int ( __attribute__((__nonnull__(1))) fseek)(FILE *__stream , long __off ,
                                                    int __whence ) ;
#line 775
extern long ( __attribute__((__nonnull__(1))) ftell)(FILE *__stream ) ;
#line 780
extern void ( __attribute__((__nonnull__(1))) rewind)(FILE *__stream ) ;
#line 793
extern int ( __attribute__((__nonnull__(1))) fseeko)(FILE *__stream , __off_t __off ,
                                                     int __whence ) ;
#line 799
extern __off_t ( __attribute__((__nonnull__(1))) ftello)(FILE *__stream ) ;
#line 819
extern int ( __attribute__((__nonnull__(1))) fgetpos)(FILE *__stream , fpos_t *__pos ) ;
#line 825
extern int ( __attribute__((__nonnull__(1))) fsetpos)(FILE *__stream , fpos_t const   *__pos ) ;
#line 850
extern void ( __attribute__((__nonnull__(1), __leaf__)) clearerr)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 852
extern int ( __attribute__((__nonnull__(1), __leaf__)) feof)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 854
extern int ( __attribute__((__nonnull__(1), __leaf__)) ferror)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 858
extern void ( __attribute__((__nonnull__(1), __leaf__)) clearerr_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 859
extern int ( __attribute__((__nonnull__(1), __leaf__)) feof_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 860
extern int ( __attribute__((__nonnull__(1), __leaf__)) ferror_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 868
extern void perror(char const   *__s )  __attribute__((__cold__)) ;
#line 873
extern int ( __attribute__((__nonnull__(1), __leaf__)) fileno)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 878
extern int ( __attribute__((__nonnull__(1), __leaf__)) fileno_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 887
extern int ( __attribute__((__nonnull__(1))) pclose)(FILE *__stream ) ;
#line 893
extern FILE *popen(char const   *__command , char const   *__modes )  __attribute__((__malloc__(pclose,1),
__malloc__)) ;
#line 901
extern char *( __attribute__((__leaf__)) ctermid)(char *__s )  __attribute__((__nothrow__,
__access__(__write_only__,1))) ;
#line 931
extern void ( __attribute__((__nonnull__(1), __leaf__)) flockfile)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 935
extern int ( __attribute__((__nonnull__(1), __leaf__)) ftrylockfile)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 938
extern void ( __attribute__((__nonnull__(1), __leaf__)) funlockfile)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 949
extern int __uflow(FILE * ) ;
#line 950
extern int __overflow(FILE * , int  ) ;
#line 43 "/usr/include/string.h"
extern void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void *__dest ,
                                                                   void const   *__src ,
                                                                   size_t __n )  __attribute__((__nothrow__)) ;
#line 47
extern void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                    void const   *__src ,
                                                                    size_t __n )  __attribute__((__nothrow__)) ;
#line 54
extern void *( __attribute__((__nonnull__(1,2), __leaf__)) memccpy)(void *__dest ,
                                                                    void const   *__src ,
                                                                    int __c , size_t __n )  __attribute__((__nothrow__,
__access__(__write_only__,1,4))) ;
#line 61
extern void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s , int __c ,
                                                                 size_t __n )  __attribute__((__nothrow__)) ;
#line 64
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                 void const   *__s2 ,
                                                                 size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 80
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) __memcmpeq)(void const   *__s1 ,
                                                                     void const   *__s2 ,
                                                                     size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 107
extern void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                 int __c , size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 141
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char *__dest ,
                                                                   char const   *__src )  __attribute__((__nothrow__)) ;
#line 144
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char *__dest ,
                                                                    char const   *__src ,
                                                                    size_t __n )  __attribute__((__nothrow__)) ;
#line 149
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char *__dest ,
                                                                   char const   *__src )  __attribute__((__nothrow__)) ;
#line 152
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char *__dest ,
                                                                    char const   *__src ,
                                                                    size_t __n )  __attribute__((__nothrow__)) ;
#line 156
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                 char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 159
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                  char const   *__s2 ,
                                                                  size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 163
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const   *__s1 ,
                                                                  char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 166
extern size_t ( __attribute__((__nonnull__(2), __leaf__)) strxfrm)(char *__dest ,
                                                                   char const   *__src ,
                                                                   size_t __n )  __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
#line 175
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) strcoll_l)(char const   *__s1 ,
                                                                      char const   *__s2 ,
                                                                      locale_t __l )  __attribute__((__pure__,
__nothrow__)) ;
#line 179
extern size_t ( __attribute__((__nonnull__(2,4), __leaf__)) strxfrm_l)(char *__dest ,
                                                                       char const   *__src ,
                                                                       size_t __n ,
                                                                       locale_t __l )  __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
#line 187
extern char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__nothrow__,
__malloc__)) ;
#line 195
extern char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                  size_t __n )  __attribute__((__nothrow__,
__malloc__)) ;
#line 246
extern char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                 int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 273
extern char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                  int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 286
extern char *( __attribute__((__nonnull__(1), __leaf__)) strchrnul)(char const   *__s ,
                                                                    int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 293
extern size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                     char const   *__reject )  __attribute__((__pure__,
__nothrow__)) ;
#line 297
extern size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                    char const   *__accept )  __attribute__((__pure__,
__nothrow__)) ;
#line 323
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                    char const   *__accept )  __attribute__((__pure__,
__nothrow__)) ;
#line 350
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                   char const   *__needle )  __attribute__((__pure__,
__nothrow__)) ;
#line 356
extern char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char *__s , char const   *__delim )  __attribute__((__nothrow__)) ;
#line 361
extern char *( __attribute__((__nonnull__(2,3), __leaf__)) __strtok_r)(char *__s ,
                                                                       char const   *__delim ,
                                                                       char **__save_ptr )  __attribute__((__nothrow__)) ;
#line 366
extern char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char *__s , char const   *__delim ,
                                                                     char **__save_ptr )  __attribute__((__nothrow__)) ;
#line 380
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strcasestr)(char const   *__haystack ,
                                                                       char const   *__needle )  __attribute__((__pure__,
__nothrow__)) ;
#line 389
extern void *( __attribute__((__nonnull__(1,3), __leaf__)) memmem)(void const   *__haystack ,
                                                                   size_t __haystacklen ,
                                                                   void const   *__needle ,
                                                                   size_t __needlelen )  __attribute__((__pure__,
__nothrow__, __access__(__read_only__,3,4), __access__(__read_only__,1,2))) ;
#line 397
extern void *( __attribute__((__nonnull__(1,2), __leaf__)) __mempcpy)(void *__dest ,
                                                                      void const   *__src ,
                                                                      size_t __n )  __attribute__((__nothrow__)) ;
#line 400
extern void *( __attribute__((__nonnull__(1,2), __leaf__)) mempcpy)(void *__dest ,
                                                                    void const   *__src ,
                                                                    size_t __n )  __attribute__((__nothrow__)) ;
#line 407
extern size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__,
__nothrow__)) ;
#line 413
extern size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                   size_t __maxlen )  __attribute__((__pure__,
__nothrow__)) ;
#line 419
extern char *( __attribute__((__leaf__)) strerror)(int __errnum )  __attribute__((__nothrow__)) ;
#line 432
extern int ( __attribute__((__nonnull__(2), __leaf__)) strerror_r)(int __errnum ,
                                                                   char *__buf , size_t __buflen )  __asm__("__xpg_strerror_r") __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 458
extern char *( __attribute__((__leaf__)) strerror_l)(int __errnum , locale_t __l )  __attribute__((__nothrow__)) ;
#line 34 "/usr/include/strings.h"
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) bcmp)(void const   *__s1 ,
                                                               void const   *__s2 ,
                                                               size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 38
extern void ( __attribute__((__nonnull__(1,2), __leaf__)) bcopy)(void const   *__src ,
                                                                 void *__dest , size_t __n )  __attribute__((__nothrow__)) ;
#line 42
extern void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s , size_t __n )  __attribute__((__nothrow__)) ;
#line 68
extern char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 96
extern char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                 int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 104
extern int ( __attribute__((__leaf__)) ffs)(int __i )  __attribute__((__nothrow__,
__const__)) ;
#line 110
extern int ( __attribute__((__leaf__)) ffsl)(long __l )  __attribute__((__nothrow__,
__const__)) ;
#line 111
extern int ( __attribute__((__leaf__)) ffsll)(long long __ll )  __attribute__((__nothrow__,
__const__)) ;
#line 116
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                     char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 120
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                      char const   *__s2 ,
                                                                      size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 128
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) strcasecmp_l)(char const   *__s1 ,
                                                                         char const   *__s2 ,
                                                                         locale_t __loc )  __attribute__((__pure__,
__nothrow__)) ;
#line 133
extern int ( __attribute__((__nonnull__(1,2,4), __leaf__)) strncasecmp_l)(char const   *__s1 ,
                                                                          char const   *__s2 ,
                                                                          size_t __n ,
                                                                          locale_t __loc )  __attribute__((__pure__,
__nothrow__)) ;
#line 466 "/usr/include/string.h"
extern void ( __attribute__((__nonnull__(1), __leaf__)) explicit_bzero)(void *__s ,
                                                                        size_t __n )  __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
#line 471
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strsep)(char **__stringp ,
                                                                   char const   *__delim )  __attribute__((__nothrow__)) ;
#line 478
extern char *( __attribute__((__leaf__)) strsignal)(int __sig )  __attribute__((__nothrow__)) ;
#line 489
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) __stpcpy)(char *__dest ,
                                                                     char const   *__src )  __attribute__((__nothrow__)) ;
#line 491
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char *__dest ,
                                                                   char const   *__src )  __attribute__((__nothrow__)) ;
#line 496
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) __stpncpy)(char *__dest ,
                                                                      char const   *__src ,
                                                                      size_t __n )  __attribute__((__nothrow__)) ;
#line 499
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) stpncpy)(char *__dest ,
                                                                    char const   *__src ,
                                                                    size_t __n )  __attribute__((__nothrow__)) ;
#line 506
extern size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strlcpy)(char *__dest ,
                                                                     char const   *__src ,
                                                                     size_t __n )  __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
#line 512
extern size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strlcat)(char *__dest ,
                                                                     char const   *__src ,
                                                                     size_t __n )  __attribute__((__nothrow__,
__access__(__read_write__,1,3))) ;
#line 24 "doomstat.c"
static char const   rcsid___0[49]  = 
#line 24 "doomstat.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'b', 
        (char const   )'b',      (char const   )'o',      (char const   )'x',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 45 "d_items.h"
weaponinfo_t weaponinfo[9] ;
#line 40 "m_fixed.h"
fixed_t FixedMul(fixed_t a , fixed_t b ) ;
#line 41
fixed_t FixedDiv(fixed_t a , fixed_t b ) ;
#line 42
fixed_t FixedDiv2(fixed_t a , fixed_t b ) ;
#line 20 "/usr/include/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassify)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 24
extern int ( __attribute__((__leaf__)) __signbit)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 29
extern int ( __attribute__((__leaf__)) __isinf)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finite)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 37
extern int ( __attribute__((__leaf__)) __isnan)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 41
extern int ( __attribute__((__leaf__)) __iseqsig)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 44
extern int ( __attribute__((__leaf__)) __issignaling)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 53 "/usr/include/bits/mathcalls.h"
extern double ( __attribute__((__leaf__)) acos)(double __x )  __attribute__((__nothrow__)) ;
#line 53
extern double ( __attribute__((__leaf__)) __acos)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) asin)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) __asin)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) atan)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) __atan)(double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) atan2)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) __atan2)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) cos)(double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) __cos)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) sin)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) __sin)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) tan)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) __tan)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) cosh)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) __cosh)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) sinh)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) __sinh)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) tanh)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) __tanh)(double __x )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) acosh)(double __x )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) __acosh)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) asinh)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) __asinh)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) atanh)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) __atanh)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) exp)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) __exp)(double __x )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) frexp)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) __frexp)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) ldexp)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) __ldexp)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) log)(double __x )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) __log)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) log10)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) __log10)(double __x )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__leaf__)) modf)(double __x , double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__nonnull__(2), __leaf__)) __modf)(double __x , double *__iptr )  __attribute__((__nothrow__)) ;
#line 134
extern double ( __attribute__((__leaf__)) expm1)(double __x )  __attribute__((__nothrow__)) ;
#line 134
extern double ( __attribute__((__leaf__)) __expm1)(double __x )  __attribute__((__nothrow__)) ;
#line 137
extern double ( __attribute__((__leaf__)) log1p)(double __x )  __attribute__((__nothrow__)) ;
#line 137
extern double ( __attribute__((__leaf__)) __log1p)(double __x )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) logb)(double __x )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) __logb)(double __x )  __attribute__((__nothrow__)) ;
#line 145
extern double ( __attribute__((__leaf__)) exp2)(double __x )  __attribute__((__nothrow__)) ;
#line 145
extern double ( __attribute__((__leaf__)) __exp2)(double __x )  __attribute__((__nothrow__)) ;
#line 148
extern double ( __attribute__((__leaf__)) log2)(double __x )  __attribute__((__nothrow__)) ;
#line 148
extern double ( __attribute__((__leaf__)) __log2)(double __x )  __attribute__((__nothrow__)) ;
#line 155
extern double ( __attribute__((__leaf__)) pow)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 155
extern double ( __attribute__((__leaf__)) __pow)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 158
extern double ( __attribute__((__leaf__)) sqrt)(double __x )  __attribute__((__nothrow__)) ;
#line 158
extern double ( __attribute__((__leaf__)) __sqrt)(double __x )  __attribute__((__nothrow__)) ;
#line 162
extern double ( __attribute__((__leaf__)) hypot)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 162
extern double ( __attribute__((__leaf__)) __hypot)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 167
extern double ( __attribute__((__leaf__)) cbrt)(double __x )  __attribute__((__nothrow__)) ;
#line 167
extern double ( __attribute__((__leaf__)) __cbrt)(double __x )  __attribute__((__nothrow__)) ;
#line 174
extern double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 174
extern double ( __attribute__((__leaf__)) __ceil)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern double ( __attribute__((__leaf__)) __fabs)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern double ( __attribute__((__leaf__)) __floor)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 183
extern double ( __attribute__((__leaf__)) fmod)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 183
extern double ( __attribute__((__leaf__)) __fmod)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 192
extern int ( __attribute__((__leaf__)) isinf)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 198
extern int ( __attribute__((__leaf__)) finite)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 202
extern double ( __attribute__((__leaf__)) drem)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 202
extern double ( __attribute__((__leaf__)) __drem)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 206
extern double ( __attribute__((__leaf__)) significand)(double __x )  __attribute__((__nothrow__)) ;
#line 206
extern double ( __attribute__((__leaf__)) __significand)(double __x )  __attribute__((__nothrow__)) ;
#line 213
extern double ( __attribute__((__leaf__)) copysign)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 213
extern double ( __attribute__((__leaf__)) __copysign)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 218
extern double ( __attribute__((__leaf__)) nan)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 218
extern double ( __attribute__((__leaf__)) __nan)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 228
extern int ( __attribute__((__leaf__)) isnan)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 235
extern double ( __attribute__((__leaf__)) j0)(double  )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) __j0)(double  )  __attribute__((__nothrow__)) ;
#line 236
extern double ( __attribute__((__leaf__)) j1)(double  )  __attribute__((__nothrow__)) ;
#line 236
extern double ( __attribute__((__leaf__)) __j1)(double  )  __attribute__((__nothrow__)) ;
#line 237
extern double ( __attribute__((__leaf__)) jn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 237
extern double ( __attribute__((__leaf__)) __jn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 238
extern double ( __attribute__((__leaf__)) y0)(double  )  __attribute__((__nothrow__)) ;
#line 238
extern double ( __attribute__((__leaf__)) __y0)(double  )  __attribute__((__nothrow__)) ;
#line 239
extern double ( __attribute__((__leaf__)) y1)(double  )  __attribute__((__nothrow__)) ;
#line 239
extern double ( __attribute__((__leaf__)) __y1)(double  )  __attribute__((__nothrow__)) ;
#line 240
extern double ( __attribute__((__leaf__)) yn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 240
extern double ( __attribute__((__leaf__)) __yn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 246
extern double ( __attribute__((__leaf__)) erf)(double  )  __attribute__((__nothrow__)) ;
#line 246
extern double ( __attribute__((__leaf__)) __erf)(double  )  __attribute__((__nothrow__)) ;
#line 247
extern double ( __attribute__((__leaf__)) erfc)(double  )  __attribute__((__nothrow__)) ;
#line 247
extern double ( __attribute__((__leaf__)) __erfc)(double  )  __attribute__((__nothrow__)) ;
#line 248
extern double ( __attribute__((__leaf__)) lgamma)(double  )  __attribute__((__nothrow__)) ;
#line 248
extern double ( __attribute__((__leaf__)) __lgamma)(double  )  __attribute__((__nothrow__)) ;
#line 253
extern double ( __attribute__((__leaf__)) tgamma)(double  )  __attribute__((__nothrow__)) ;
#line 253
extern double ( __attribute__((__leaf__)) __tgamma)(double  )  __attribute__((__nothrow__)) ;
#line 259
extern double ( __attribute__((__leaf__)) gamma)(double  )  __attribute__((__nothrow__)) ;
#line 259
extern double ( __attribute__((__leaf__)) __gamma)(double  )  __attribute__((__nothrow__)) ;
#line 267
extern double ( __attribute__((__leaf__)) lgamma_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 267
extern double ( __attribute__((__leaf__)) __lgamma_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 274
extern double ( __attribute__((__leaf__)) rint)(double __x )  __attribute__((__nothrow__)) ;
#line 274
extern double ( __attribute__((__leaf__)) __rint)(double __x )  __attribute__((__nothrow__)) ;
#line 277
extern double ( __attribute__((__leaf__)) nextafter)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 277
extern double ( __attribute__((__leaf__)) __nextafter)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 279
extern double ( __attribute__((__leaf__)) nexttoward)(double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 279
extern double ( __attribute__((__leaf__)) __nexttoward)(double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) remainder)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) __remainder)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) scalbn)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) __scalbn)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) ilogb)(double __x )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) __ilogb)(double __x )  __attribute__((__nothrow__)) ;
#line 308
extern double ( __attribute__((__leaf__)) scalbln)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 308
extern double ( __attribute__((__leaf__)) __scalbln)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 312
extern double ( __attribute__((__leaf__)) nearbyint)(double __x )  __attribute__((__nothrow__)) ;
#line 312
extern double ( __attribute__((__leaf__)) __nearbyint)(double __x )  __attribute__((__nothrow__)) ;
#line 316
extern double ( __attribute__((__leaf__)) round)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 316
extern double ( __attribute__((__leaf__)) __round)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern double ( __attribute__((__leaf__)) trunc)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern double ( __attribute__((__leaf__)) __trunc)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 325
extern double ( __attribute__((__leaf__)) remquo)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 325
extern double ( __attribute__((__leaf__)) __remquo)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) lrint)(double __x )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) __lrint)(double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) llrint)(double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) __llrint)(double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) lround)(double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) __lround)(double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) llround)(double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) __llround)(double __x )  __attribute__((__nothrow__)) ;
#line 344
extern double ( __attribute__((__leaf__)) fdim)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 344
extern double ( __attribute__((__leaf__)) __fdim)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 348
extern double ( __attribute__((__leaf__)) fmax)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 348
extern double ( __attribute__((__leaf__)) __fmax)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern double ( __attribute__((__leaf__)) fmin)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern double ( __attribute__((__leaf__)) __fmin)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 355
extern double ( __attribute__((__leaf__)) fma)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 355
extern double ( __attribute__((__leaf__)) __fma)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 450
extern double ( __attribute__((__leaf__)) scalb)(double __x , double __n )  __attribute__((__nothrow__)) ;
#line 450
extern double ( __attribute__((__leaf__)) __scalb)(double __x , double __n )  __attribute__((__nothrow__)) ;
#line 20 "/usr/include/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassifyf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 24
extern int ( __attribute__((__leaf__)) __signbitf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 29
extern int ( __attribute__((__leaf__)) __isinff)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finitef)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 37
extern int ( __attribute__((__leaf__)) __isnanf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 41
extern int ( __attribute__((__leaf__)) __iseqsigf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 44
extern int ( __attribute__((__leaf__)) __issignalingf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 53 "/usr/include/bits/mathcalls.h"
extern float ( __attribute__((__leaf__)) acosf)(float __x )  __attribute__((__nothrow__)) ;
#line 53
extern float ( __attribute__((__leaf__)) __acosf)(float __x )  __attribute__((__nothrow__)) ;
#line 55
extern float ( __attribute__((__leaf__)) asinf)(float __x )  __attribute__((__nothrow__)) ;
#line 55
extern float ( __attribute__((__leaf__)) __asinf)(float __x )  __attribute__((__nothrow__)) ;
#line 57
extern float ( __attribute__((__leaf__)) atanf)(float __x )  __attribute__((__nothrow__)) ;
#line 57
extern float ( __attribute__((__leaf__)) __atanf)(float __x )  __attribute__((__nothrow__)) ;
#line 59
extern float ( __attribute__((__leaf__)) atan2f)(float __y , float __x )  __attribute__((__nothrow__)) ;
#line 59
extern float ( __attribute__((__leaf__)) __atan2f)(float __y , float __x )  __attribute__((__nothrow__)) ;
#line 62
extern float ( __attribute__((__leaf__)) cosf)(float __x )  __attribute__((__nothrow__)) ;
#line 62
extern float ( __attribute__((__leaf__)) __cosf)(float __x )  __attribute__((__nothrow__)) ;
#line 64
extern float ( __attribute__((__leaf__)) sinf)(float __x )  __attribute__((__nothrow__)) ;
#line 64
extern float ( __attribute__((__leaf__)) __sinf)(float __x )  __attribute__((__nothrow__)) ;
#line 66
extern float ( __attribute__((__leaf__)) tanf)(float __x )  __attribute__((__nothrow__)) ;
#line 66
extern float ( __attribute__((__leaf__)) __tanf)(float __x )  __attribute__((__nothrow__)) ;
#line 71
extern float ( __attribute__((__leaf__)) coshf)(float __x )  __attribute__((__nothrow__)) ;
#line 71
extern float ( __attribute__((__leaf__)) __coshf)(float __x )  __attribute__((__nothrow__)) ;
#line 73
extern float ( __attribute__((__leaf__)) sinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 73
extern float ( __attribute__((__leaf__)) __sinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 75
extern float ( __attribute__((__leaf__)) tanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 75
extern float ( __attribute__((__leaf__)) __tanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 85
extern float ( __attribute__((__leaf__)) acoshf)(float __x )  __attribute__((__nothrow__)) ;
#line 85
extern float ( __attribute__((__leaf__)) __acoshf)(float __x )  __attribute__((__nothrow__)) ;
#line 87
extern float ( __attribute__((__leaf__)) asinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 87
extern float ( __attribute__((__leaf__)) __asinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 89
extern float ( __attribute__((__leaf__)) atanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 89
extern float ( __attribute__((__leaf__)) __atanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 95
extern float ( __attribute__((__leaf__)) expf)(float __x )  __attribute__((__nothrow__)) ;
#line 95
extern float ( __attribute__((__leaf__)) __expf)(float __x )  __attribute__((__nothrow__)) ;
#line 98
extern float ( __attribute__((__leaf__)) frexpf)(float __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern float ( __attribute__((__leaf__)) __frexpf)(float __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern float ( __attribute__((__leaf__)) ldexpf)(float __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern float ( __attribute__((__leaf__)) __ldexpf)(float __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern float ( __attribute__((__leaf__)) logf)(float __x )  __attribute__((__nothrow__)) ;
#line 104
extern float ( __attribute__((__leaf__)) __logf)(float __x )  __attribute__((__nothrow__)) ;
#line 107
extern float ( __attribute__((__leaf__)) log10f)(float __x )  __attribute__((__nothrow__)) ;
#line 107
extern float ( __attribute__((__leaf__)) __log10f)(float __x )  __attribute__((__nothrow__)) ;
#line 110
extern float ( __attribute__((__leaf__)) modff)(float __x , float *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern float ( __attribute__((__nonnull__(2), __leaf__)) __modff)(float __x , float *__iptr )  __attribute__((__nothrow__)) ;
#line 134
extern float ( __attribute__((__leaf__)) expm1f)(float __x )  __attribute__((__nothrow__)) ;
#line 134
extern float ( __attribute__((__leaf__)) __expm1f)(float __x )  __attribute__((__nothrow__)) ;
#line 137
extern float ( __attribute__((__leaf__)) log1pf)(float __x )  __attribute__((__nothrow__)) ;
#line 137
extern float ( __attribute__((__leaf__)) __log1pf)(float __x )  __attribute__((__nothrow__)) ;
#line 140
extern float ( __attribute__((__leaf__)) logbf)(float __x )  __attribute__((__nothrow__)) ;
#line 140
extern float ( __attribute__((__leaf__)) __logbf)(float __x )  __attribute__((__nothrow__)) ;
#line 145
extern float ( __attribute__((__leaf__)) exp2f)(float __x )  __attribute__((__nothrow__)) ;
#line 145
extern float ( __attribute__((__leaf__)) __exp2f)(float __x )  __attribute__((__nothrow__)) ;
#line 148
extern float ( __attribute__((__leaf__)) log2f)(float __x )  __attribute__((__nothrow__)) ;
#line 148
extern float ( __attribute__((__leaf__)) __log2f)(float __x )  __attribute__((__nothrow__)) ;
#line 155
extern float ( __attribute__((__leaf__)) powf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 155
extern float ( __attribute__((__leaf__)) __powf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 158
extern float ( __attribute__((__leaf__)) sqrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 158
extern float ( __attribute__((__leaf__)) __sqrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 162
extern float ( __attribute__((__leaf__)) hypotf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 162
extern float ( __attribute__((__leaf__)) __hypotf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 167
extern float ( __attribute__((__leaf__)) cbrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 167
extern float ( __attribute__((__leaf__)) __cbrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 174
extern float ( __attribute__((__leaf__)) ceilf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 174
extern float ( __attribute__((__leaf__)) __ceilf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern float ( __attribute__((__leaf__)) fabsf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern float ( __attribute__((__leaf__)) __fabsf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern float ( __attribute__((__leaf__)) floorf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern float ( __attribute__((__leaf__)) __floorf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 183
extern float ( __attribute__((__leaf__)) fmodf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 183
extern float ( __attribute__((__leaf__)) __fmodf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 192
extern int ( __attribute__((__leaf__)) isinff)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 198
extern int ( __attribute__((__leaf__)) finitef)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 202
extern float ( __attribute__((__leaf__)) dremf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 202
extern float ( __attribute__((__leaf__)) __dremf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 206
extern float ( __attribute__((__leaf__)) significandf)(float __x )  __attribute__((__nothrow__)) ;
#line 206
extern float ( __attribute__((__leaf__)) __significandf)(float __x )  __attribute__((__nothrow__)) ;
#line 213
extern float ( __attribute__((__leaf__)) copysignf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 213
extern float ( __attribute__((__leaf__)) __copysignf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 218
extern float ( __attribute__((__leaf__)) nanf)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 218
extern float ( __attribute__((__leaf__)) __nanf)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 228
extern int ( __attribute__((__leaf__)) isnanf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 235
extern float ( __attribute__((__leaf__)) j0f)(float  )  __attribute__((__nothrow__)) ;
#line 235
extern float ( __attribute__((__leaf__)) __j0f)(float  )  __attribute__((__nothrow__)) ;
#line 236
extern float ( __attribute__((__leaf__)) j1f)(float  )  __attribute__((__nothrow__)) ;
#line 236
extern float ( __attribute__((__leaf__)) __j1f)(float  )  __attribute__((__nothrow__)) ;
#line 237
extern float ( __attribute__((__leaf__)) jnf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 237
extern float ( __attribute__((__leaf__)) __jnf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 238
extern float ( __attribute__((__leaf__)) y0f)(float  )  __attribute__((__nothrow__)) ;
#line 238
extern float ( __attribute__((__leaf__)) __y0f)(float  )  __attribute__((__nothrow__)) ;
#line 239
extern float ( __attribute__((__leaf__)) y1f)(float  )  __attribute__((__nothrow__)) ;
#line 239
extern float ( __attribute__((__leaf__)) __y1f)(float  )  __attribute__((__nothrow__)) ;
#line 240
extern float ( __attribute__((__leaf__)) ynf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 240
extern float ( __attribute__((__leaf__)) __ynf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 246
extern float ( __attribute__((__leaf__)) erff)(float  )  __attribute__((__nothrow__)) ;
#line 246
extern float ( __attribute__((__leaf__)) __erff)(float  )  __attribute__((__nothrow__)) ;
#line 247
extern float ( __attribute__((__leaf__)) erfcf)(float  )  __attribute__((__nothrow__)) ;
#line 247
extern float ( __attribute__((__leaf__)) __erfcf)(float  )  __attribute__((__nothrow__)) ;
#line 248
extern float ( __attribute__((__leaf__)) lgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 248
extern float ( __attribute__((__leaf__)) __lgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 253
extern float ( __attribute__((__leaf__)) tgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 253
extern float ( __attribute__((__leaf__)) __tgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 259
extern float ( __attribute__((__leaf__)) gammaf)(float  )  __attribute__((__nothrow__)) ;
#line 259
extern float ( __attribute__((__leaf__)) __gammaf)(float  )  __attribute__((__nothrow__)) ;
#line 267
extern float ( __attribute__((__leaf__)) lgammaf_r)(float  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 267
extern float ( __attribute__((__leaf__)) __lgammaf_r)(float  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 274
extern float ( __attribute__((__leaf__)) rintf)(float __x )  __attribute__((__nothrow__)) ;
#line 274
extern float ( __attribute__((__leaf__)) __rintf)(float __x )  __attribute__((__nothrow__)) ;
#line 277
extern float ( __attribute__((__leaf__)) nextafterf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 277
extern float ( __attribute__((__leaf__)) __nextafterf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 279
extern float ( __attribute__((__leaf__)) nexttowardf)(float __x , long double __y )  __attribute__((__nothrow__)) ;
#line 279
extern float ( __attribute__((__leaf__)) __nexttowardf)(float __x , long double __y )  __attribute__((__nothrow__)) ;
#line 290
extern float ( __attribute__((__leaf__)) remainderf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 290
extern float ( __attribute__((__leaf__)) __remainderf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 294
extern float ( __attribute__((__leaf__)) scalbnf)(float __x , int __n )  __attribute__((__nothrow__)) ;
#line 294
extern float ( __attribute__((__leaf__)) __scalbnf)(float __x , int __n )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) ilogbf)(float __x )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) __ilogbf)(float __x )  __attribute__((__nothrow__)) ;
#line 308
extern float ( __attribute__((__leaf__)) scalblnf)(float __x , long __n )  __attribute__((__nothrow__)) ;
#line 308
extern float ( __attribute__((__leaf__)) __scalblnf)(float __x , long __n )  __attribute__((__nothrow__)) ;
#line 312
extern float ( __attribute__((__leaf__)) nearbyintf)(float __x )  __attribute__((__nothrow__)) ;
#line 312
extern float ( __attribute__((__leaf__)) __nearbyintf)(float __x )  __attribute__((__nothrow__)) ;
#line 316
extern float ( __attribute__((__leaf__)) roundf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 316
extern float ( __attribute__((__leaf__)) __roundf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern float ( __attribute__((__leaf__)) truncf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern float ( __attribute__((__leaf__)) __truncf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 325
extern float ( __attribute__((__leaf__)) remquof)(float __x , float __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 325
extern float ( __attribute__((__leaf__)) __remquof)(float __x , float __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) lrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) __lrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) llrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) __llrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) lroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) __lroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) llroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) __llroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 344
extern float ( __attribute__((__leaf__)) fdimf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 344
extern float ( __attribute__((__leaf__)) __fdimf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 348
extern float ( __attribute__((__leaf__)) fmaxf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 348
extern float ( __attribute__((__leaf__)) __fmaxf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern float ( __attribute__((__leaf__)) fminf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern float ( __attribute__((__leaf__)) __fminf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 355
extern float ( __attribute__((__leaf__)) fmaf)(float __x , float __y , float __z )  __attribute__((__nothrow__)) ;
#line 355
extern float ( __attribute__((__leaf__)) __fmaf)(float __x , float __y , float __z )  __attribute__((__nothrow__)) ;
#line 450
extern float ( __attribute__((__leaf__)) scalbf)(float __x , float __n )  __attribute__((__nothrow__)) ;
#line 450
extern float ( __attribute__((__leaf__)) __scalbf)(float __x , float __n )  __attribute__((__nothrow__)) ;
#line 20 "/usr/include/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassifyl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 24
extern int ( __attribute__((__leaf__)) __signbitl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 29
extern int ( __attribute__((__leaf__)) __isinfl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finitel)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 37
extern int ( __attribute__((__leaf__)) __isnanl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 41
extern int ( __attribute__((__leaf__)) __iseqsigl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 44
extern int ( __attribute__((__leaf__)) __issignalingl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 53 "/usr/include/bits/mathcalls.h"
extern long double ( __attribute__((__leaf__)) acosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 53
extern long double ( __attribute__((__leaf__)) __acosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 55
extern long double ( __attribute__((__leaf__)) asinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 55
extern long double ( __attribute__((__leaf__)) __asinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 57
extern long double ( __attribute__((__leaf__)) atanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 57
extern long double ( __attribute__((__leaf__)) __atanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 59
extern long double ( __attribute__((__leaf__)) atan2l)(long double __y , long double __x )  __attribute__((__nothrow__)) ;
#line 59
extern long double ( __attribute__((__leaf__)) __atan2l)(long double __y , long double __x )  __attribute__((__nothrow__)) ;
#line 62
extern long double ( __attribute__((__leaf__)) cosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 62
extern long double ( __attribute__((__leaf__)) __cosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 64
extern long double ( __attribute__((__leaf__)) sinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 64
extern long double ( __attribute__((__leaf__)) __sinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 66
extern long double ( __attribute__((__leaf__)) tanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 66
extern long double ( __attribute__((__leaf__)) __tanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 71
extern long double ( __attribute__((__leaf__)) coshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 71
extern long double ( __attribute__((__leaf__)) __coshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 73
extern long double ( __attribute__((__leaf__)) sinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 73
extern long double ( __attribute__((__leaf__)) __sinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 75
extern long double ( __attribute__((__leaf__)) tanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 75
extern long double ( __attribute__((__leaf__)) __tanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 85
extern long double ( __attribute__((__leaf__)) acoshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 85
extern long double ( __attribute__((__leaf__)) __acoshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 87
extern long double ( __attribute__((__leaf__)) asinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 87
extern long double ( __attribute__((__leaf__)) __asinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 89
extern long double ( __attribute__((__leaf__)) atanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 89
extern long double ( __attribute__((__leaf__)) __atanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 95
extern long double ( __attribute__((__leaf__)) expl)(long double __x )  __attribute__((__nothrow__)) ;
#line 95
extern long double ( __attribute__((__leaf__)) __expl)(long double __x )  __attribute__((__nothrow__)) ;
#line 98
extern long double ( __attribute__((__leaf__)) frexpl)(long double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern long double ( __attribute__((__leaf__)) __frexpl)(long double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern long double ( __attribute__((__leaf__)) ldexpl)(long double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern long double ( __attribute__((__leaf__)) __ldexpl)(long double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern long double ( __attribute__((__leaf__)) logl)(long double __x )  __attribute__((__nothrow__)) ;
#line 104
extern long double ( __attribute__((__leaf__)) __logl)(long double __x )  __attribute__((__nothrow__)) ;
#line 107
extern long double ( __attribute__((__leaf__)) log10l)(long double __x )  __attribute__((__nothrow__)) ;
#line 107
extern long double ( __attribute__((__leaf__)) __log10l)(long double __x )  __attribute__((__nothrow__)) ;
#line 110
extern long double ( __attribute__((__leaf__)) modfl)(long double __x , long double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern long double ( __attribute__((__nonnull__(2), __leaf__)) __modfl)(long double __x ,
                                                                        long double *__iptr )  __attribute__((__nothrow__)) ;
#line 134
extern long double ( __attribute__((__leaf__)) expm1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 134
extern long double ( __attribute__((__leaf__)) __expm1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 137
extern long double ( __attribute__((__leaf__)) log1pl)(long double __x )  __attribute__((__nothrow__)) ;
#line 137
extern long double ( __attribute__((__leaf__)) __log1pl)(long double __x )  __attribute__((__nothrow__)) ;
#line 140
extern long double ( __attribute__((__leaf__)) logbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 140
extern long double ( __attribute__((__leaf__)) __logbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 145
extern long double ( __attribute__((__leaf__)) exp2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 145
extern long double ( __attribute__((__leaf__)) __exp2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 148
extern long double ( __attribute__((__leaf__)) log2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 148
extern long double ( __attribute__((__leaf__)) __log2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 155
extern long double ( __attribute__((__leaf__)) powl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 155
extern long double ( __attribute__((__leaf__)) __powl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 158
extern long double ( __attribute__((__leaf__)) sqrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 158
extern long double ( __attribute__((__leaf__)) __sqrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 162
extern long double ( __attribute__((__leaf__)) hypotl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 162
extern long double ( __attribute__((__leaf__)) __hypotl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 167
extern long double ( __attribute__((__leaf__)) cbrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 167
extern long double ( __attribute__((__leaf__)) __cbrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 174
extern long double ( __attribute__((__leaf__)) ceill)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 174
extern long double ( __attribute__((__leaf__)) __ceill)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern long double ( __attribute__((__leaf__)) fabsl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 177
extern long double ( __attribute__((__leaf__)) __fabsl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern long double ( __attribute__((__leaf__)) floorl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 180
extern long double ( __attribute__((__leaf__)) __floorl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 183
extern long double ( __attribute__((__leaf__)) fmodl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 183
extern long double ( __attribute__((__leaf__)) __fmodl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 192
extern int ( __attribute__((__leaf__)) isinfl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 198
extern int ( __attribute__((__leaf__)) finitel)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 202
extern long double ( __attribute__((__leaf__)) dreml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 202
extern long double ( __attribute__((__leaf__)) __dreml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 206
extern long double ( __attribute__((__leaf__)) significandl)(long double __x )  __attribute__((__nothrow__)) ;
#line 206
extern long double ( __attribute__((__leaf__)) __significandl)(long double __x )  __attribute__((__nothrow__)) ;
#line 213
extern long double ( __attribute__((__leaf__)) copysignl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 213
extern long double ( __attribute__((__leaf__)) __copysignl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 218
extern long double ( __attribute__((__leaf__)) nanl)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 218
extern long double ( __attribute__((__leaf__)) __nanl)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 228
extern int ( __attribute__((__leaf__)) isnanl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 235
extern long double ( __attribute__((__leaf__)) j0l)(long double  )  __attribute__((__nothrow__)) ;
#line 235
extern long double ( __attribute__((__leaf__)) __j0l)(long double  )  __attribute__((__nothrow__)) ;
#line 236
extern long double ( __attribute__((__leaf__)) j1l)(long double  )  __attribute__((__nothrow__)) ;
#line 236
extern long double ( __attribute__((__leaf__)) __j1l)(long double  )  __attribute__((__nothrow__)) ;
#line 237
extern long double ( __attribute__((__leaf__)) jnl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 237
extern long double ( __attribute__((__leaf__)) __jnl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 238
extern long double ( __attribute__((__leaf__)) y0l)(long double  )  __attribute__((__nothrow__)) ;
#line 238
extern long double ( __attribute__((__leaf__)) __y0l)(long double  )  __attribute__((__nothrow__)) ;
#line 239
extern long double ( __attribute__((__leaf__)) y1l)(long double  )  __attribute__((__nothrow__)) ;
#line 239
extern long double ( __attribute__((__leaf__)) __y1l)(long double  )  __attribute__((__nothrow__)) ;
#line 240
extern long double ( __attribute__((__leaf__)) ynl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 240
extern long double ( __attribute__((__leaf__)) __ynl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 246
extern long double ( __attribute__((__leaf__)) erfl)(long double  )  __attribute__((__nothrow__)) ;
#line 246
extern long double ( __attribute__((__leaf__)) __erfl)(long double  )  __attribute__((__nothrow__)) ;
#line 247
extern long double ( __attribute__((__leaf__)) erfcl)(long double  )  __attribute__((__nothrow__)) ;
#line 247
extern long double ( __attribute__((__leaf__)) __erfcl)(long double  )  __attribute__((__nothrow__)) ;
#line 248
extern long double ( __attribute__((__leaf__)) lgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 248
extern long double ( __attribute__((__leaf__)) __lgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 253
extern long double ( __attribute__((__leaf__)) tgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 253
extern long double ( __attribute__((__leaf__)) __tgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 259
extern long double ( __attribute__((__leaf__)) gammal)(long double  )  __attribute__((__nothrow__)) ;
#line 259
extern long double ( __attribute__((__leaf__)) __gammal)(long double  )  __attribute__((__nothrow__)) ;
#line 267
extern long double ( __attribute__((__leaf__)) lgammal_r)(long double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 267
extern long double ( __attribute__((__leaf__)) __lgammal_r)(long double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 274
extern long double ( __attribute__((__leaf__)) rintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 274
extern long double ( __attribute__((__leaf__)) __rintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 277
extern long double ( __attribute__((__leaf__)) nextafterl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 277
extern long double ( __attribute__((__leaf__)) __nextafterl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 279
extern long double ( __attribute__((__leaf__)) nexttowardl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 279
extern long double ( __attribute__((__leaf__)) __nexttowardl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 290
extern long double ( __attribute__((__leaf__)) remainderl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 290
extern long double ( __attribute__((__leaf__)) __remainderl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 294
extern long double ( __attribute__((__leaf__)) scalbnl)(long double __x , int __n )  __attribute__((__nothrow__)) ;
#line 294
extern long double ( __attribute__((__leaf__)) __scalbnl)(long double __x , int __n )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) ilogbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 298
extern int ( __attribute__((__leaf__)) __ilogbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 308
extern long double ( __attribute__((__leaf__)) scalblnl)(long double __x , long __n )  __attribute__((__nothrow__)) ;
#line 308
extern long double ( __attribute__((__leaf__)) __scalblnl)(long double __x , long __n )  __attribute__((__nothrow__)) ;
#line 312
extern long double ( __attribute__((__leaf__)) nearbyintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 312
extern long double ( __attribute__((__leaf__)) __nearbyintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long double ( __attribute__((__leaf__)) roundl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 316
extern long double ( __attribute__((__leaf__)) __roundl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern long double ( __attribute__((__leaf__)) truncl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 320
extern long double ( __attribute__((__leaf__)) __truncl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 325
extern long double ( __attribute__((__leaf__)) remquol)(long double __x , long double __y ,
                                                        int *__quo )  __attribute__((__nothrow__)) ;
#line 325
extern long double ( __attribute__((__leaf__)) __remquol)(long double __x , long double __y ,
                                                          int *__quo )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) lrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 332
extern long ( __attribute__((__leaf__)) __lrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) llrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 334
extern long long ( __attribute__((__leaf__)) __llrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) lroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 338
extern long ( __attribute__((__leaf__)) __lroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) llroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long long ( __attribute__((__leaf__)) __llroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 344
extern long double ( __attribute__((__leaf__)) fdiml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 344
extern long double ( __attribute__((__leaf__)) __fdiml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 348
extern long double ( __attribute__((__leaf__)) fmaxl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 348
extern long double ( __attribute__((__leaf__)) __fmaxl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern long double ( __attribute__((__leaf__)) fminl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 351
extern long double ( __attribute__((__leaf__)) __fminl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 355
extern long double ( __attribute__((__leaf__)) fmal)(long double __x , long double __y ,
                                                     long double __z )  __attribute__((__nothrow__)) ;
#line 355
extern long double ( __attribute__((__leaf__)) __fmal)(long double __x , long double __y ,
                                                       long double __z )  __attribute__((__nothrow__)) ;
#line 450
extern long double ( __attribute__((__leaf__)) scalbl)(long double __x , long double __n )  __attribute__((__nothrow__)) ;
#line 450
extern long double ( __attribute__((__leaf__)) __scalbl)(long double __x , long double __n )  __attribute__((__nothrow__)) ;
#line 20 "/usr/include/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassifyf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 24
extern int ( __attribute__((__leaf__)) __signbitf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 29
extern int ( __attribute__((__leaf__)) __isinff128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finitef128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 37
extern int ( __attribute__((__leaf__)) __isnanf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 41
extern int ( __attribute__((__leaf__)) __iseqsigf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 44
extern int ( __attribute__((__leaf__)) __issignalingf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 854 "/usr/include/math.h"
extern int signgam ;
#line 58 "tables.h"
int finesine[10240] ;
#line 61
fixed_t *finecosine ;
#line 65
int finetangent[4096] ;
#line 84
angle_t tantoangle[2049] ;
#line 89
int SlopeDiv(unsigned int num___0 , unsigned int den ) ;
#line 1158 "info.h"
state_t states[967] ;
#line 1159
char *sprnames[138] ;
#line 1333
mobjinfo_t mobjinfo[137] ;
#line 132 "d_net.h"
void NetUpdate(void) ;
#line 136
void D_QuitNetGame(void) ;
#line 139
void TryRunTics(void) ;
#line 49 "doomstat.h"
boolean nomonsters ;
#line 50
boolean respawnparm ;
#line 51
boolean fastparm ;
#line 53
boolean devparm ;
#line 60
GameMode_t gamemode ;
#line 61
GameMission_t gamemission ;
#line 64 "doomstat.h"
boolean modifiedgame  ;
#line 69
Language_t language ;
#line 77
skill_t startskill ;
#line 78
int startepisode ;
#line 79
int startmap ;
#line 81
boolean autostart ;
#line 84
skill_t gameskill ;
#line 85
int gameepisode ;
#line 86
int gamemap ;
#line 89
boolean respawnmonsters ;
#line 92
boolean netgame ;
#line 96
boolean deathmatch ;
#line 109
int snd_SfxVolume ;
#line 110
int snd_MusicVolume ;
#line 116
extern int snd_MusicDevice ;
#line 117
extern int snd_SfxDevice ;
#line 119
extern int snd_DesiredMusicDevice ;
#line 120
extern int snd_DesiredSfxDevice ;
#line 130
extern boolean statusbaractive ;
#line 132
boolean automapactive ;
#line 133
boolean menuactive ;
#line 134
boolean paused ;
#line 137
boolean viewactive ;
#line 139
boolean nodrawers ;
#line 140
boolean noblit ;
#line 142
int viewwindowx ;
#line 143
int viewwindowy ;
#line 144
int viewheight ;
#line 145
int viewwidth ;
#line 146
int scaledviewwidth ;
#line 155
int viewangleoffset ;
#line 158
int consoleplayer ;
#line 159
int displayplayer ;
#line 166
int totalkills ;
#line 167
int totalitems ;
#line 168
int totalsecret ;
#line 171
int levelstarttic ;
#line 172
int leveltime ;
#line 180
boolean usergame ;
#line 183
boolean demoplayback ;
#line 184
boolean demorecording ;
#line 187
boolean singledemo ;
#line 193
gamestate_t gamestate ;
#line 208
int gametic ;
#line 212
player_t players[4] ;
#line 215
boolean playeringame[4] ;
#line 220
mapthing_t deathmatchstarts[10] ;
#line 221
mapthing_t *deathmatch_p ;
#line 224
mapthing_t playerstarts[4] ;
#line 228
wbstartstruct_t wminfo ;
#line 233
int maxammo[4] ;
#line 244
char basedefault[1024] ;
#line 245
FILE *debugfile ;
#line 248
boolean precache ;
#line 253
gamestate_t wipegamestate ;
#line 255
int mouseSensitivity ;
#line 258
boolean singletics ;
#line 260
int bodyqueslot ;
#line 267
int skyflatnum ;
#line 274
doomcom_t *doomcom ;
#line 277
doomdata_t *netbuffer ;
#line 280
ticcmd_t localcmds[12] ;
#line 281
int rndindex ;
#line 283
int maketic ;
#line 284
int nettics[8] ;
#line 286
ticcmd_t netcmds[4][12] ;
#line 287
int ticdup ;
#line 35 "doomstat.c"
GameMode_t gamemode  =    (GameMode_t )4;
#line 36 "doomstat.c"
GameMission_t gamemission  =    (GameMission_t )0;
#line 39 "doomstat.c"
Language_t language  =    (Language_t )0;
#line 24 "dstrings.c"
static char const   rcsid___1[49]  = 
#line 24 "dstrings.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'b', 
        (char const   )'b',      (char const   )'o',      (char const   )'x',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 58 "dstrings.h"
char *endmsg[23] ;
#line 35 "dstrings.c"
char *endmsg[23]  = 
#line 35 "dstrings.c"
  {      "are you sure you want to\nquit this great game?",      "please don\'t leave, there\'s more\ndemons to toast!",      "let\'s beat it -- this is turning\ninto a bloodbath!",      "i wouldn\'t leave if i were you.\ndos is much worse.", 
        "you\'re trying to say you like dos\nbetter than me, right?",      "don\'t leave yet -- there\'s a\ndemon around that corner!",      "ya know, next time you come in here\ni\'m gonna toast ya.",      "go ahead and leave. see if i care.you want to quit?\nthen, thou hast lost an eighth!", 
        "don\'t go now, there\'s a \ndimensional shambler waiting\nat the dos prompt!",      "get outta here and go back\nto your boring programs.",      "if i were your boss, i\'d \n deathmatch ya in a minute!",      "look, bud. you leave now\nand you forfeit your body count!", 
        "just leave. when you come\nback, i\'ll be waiting with a bat.",      "you\'re lucky i don\'t smack\nyou for thinking about leaving.fuck you, pussy!\nget the fuck out!",      "you quit and i\'ll jizz\nin your cystholes!",      "if you leave, i\'ll make\nthe lord drink my jizz.", 
        "hey, ron! can we say\n\'fuck\' in the game?",      "i\'d leave: this is just\nmore monsters and levels.\nwhat a load.",      "suck it down, asshole!\nyou\'re a fucking wimp!",      "don\'t quit now! we\'re \nstill spending your money!", 
        "THIS IS NO MESSAGE!\nPage intentionally left blank."};
#line 23 "i_system.c"
static char const   rcsid___2[49]  = 
#line 23 "i_system.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'b', 
        (char const   )'b',      (char const   )'o',      (char const   )'x',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 98 "/usr/include/stdlib.h"
extern size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void)  __attribute__((__nothrow__)) ;
#line 102
extern double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 105
extern int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 108
extern long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 113
extern long long ( __attribute__((__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 118
extern double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   *__nptr ,
                                                                  char **__endptr )  __attribute__((__nothrow__)) ;
#line 124
extern float ( __attribute__((__nonnull__(1), __leaf__)) strtof)(char const   *__nptr ,
                                                                 char **__endptr )  __attribute__((__nothrow__)) ;
#line 127
extern long double ( __attribute__((__nonnull__(1), __leaf__)) strtold)(char const   *__nptr ,
                                                                        char **__endptr )  __attribute__((__nothrow__)) ;
#line 177
extern long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base )  __attribute__((__nothrow__)) ;
#line 181
extern unsigned long ( __attribute__((__nonnull__(1), __leaf__)) strtoul)(char const   *__nptr ,
                                                                          char **__endptr ,
                                                                          int __base )  __attribute__((__nothrow__)) ;
#line 188
extern long long ( __attribute__((__nonnull__(1), __leaf__)) strtoq)(char const   *__nptr ,
                                                                     char **__endptr ,
                                                                     int __base )  __attribute__((__nothrow__)) ;
#line 193
extern unsigned long long ( __attribute__((__nonnull__(1), __leaf__)) strtouq)(char const   *__nptr ,
                                                                               char **__endptr ,
                                                                               int __base )  __attribute__((__nothrow__)) ;
#line 201
extern long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base )  __attribute__((__nothrow__)) ;
#line 206
extern unsigned long long ( __attribute__((__nonnull__(1), __leaf__)) strtoull)(char const   *__nptr ,
                                                                                char **__endptr ,
                                                                                int __base )  __attribute__((__nothrow__)) ;
#line 505
extern char *( __attribute__((__leaf__)) l64a)(long __n )  __attribute__((__nothrow__)) ;
#line 508
extern long ( __attribute__((__nonnull__(1), __leaf__)) a64l)(char const   *__s )  __attribute__((__pure__,
__nothrow__)) ;
#line 33 "/usr/include/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short tmp ;

  {
#line 37
  tmp = __builtin_bswap16((short )__bsx);
#line 37
  return ((__uint16_t )tmp);
}
}
#line 48 "/usr/include/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int tmp ;

  {
#line 52
  tmp = __builtin_bswap32((int )__bsx);
#line 52
  return ((__uint32_t )tmp);
}
}
#line 69 "/usr/include/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long tmp ;

  {
#line 73
  tmp = __builtin_bswap64((long )__bsx);
#line 73
  return ((__uint64_t )tmp);
}
}
#line 32 "/usr/include/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 38 "/usr/include/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 44 "/usr/include/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 102 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 127
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec  const  *__timeout , __sigset_t const   *__sigmask ) ;
#line 521 "/usr/include/stdlib.h"
extern long ( __attribute__((__leaf__)) random)(void)  __attribute__((__nothrow__)) ;
#line 524
extern void ( __attribute__((__leaf__)) srandom)(unsigned int __seed )  __attribute__((__nothrow__)) ;
#line 530
extern char *( __attribute__((__nonnull__(2), __leaf__)) initstate)(unsigned int __seed ,
                                                                    char *__statebuf ,
                                                                    size_t __statelen )  __attribute__((__nothrow__)) ;
#line 535
extern char *( __attribute__((__nonnull__(1), __leaf__)) setstate)(char *__statebuf )  __attribute__((__nothrow__)) ;
#line 554
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) random_r)(struct random_data *__buf ,
                                                                   int32_t *__result )  __attribute__((__nothrow__)) ;
#line 557
extern int ( __attribute__((__nonnull__(2), __leaf__)) srandom_r)(unsigned int __seed ,
                                                                  struct random_data *__buf )  __attribute__((__nothrow__)) ;
#line 560
extern int ( __attribute__((__nonnull__(2,4), __leaf__)) initstate_r)(unsigned int __seed ,
                                                                      char *__statebuf ,
                                                                      size_t __statelen ,
                                                                      struct random_data *__buf )  __attribute__((__nothrow__)) ;
#line 565
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) setstate_r)(char *__statebuf ,
                                                                     struct random_data *__buf )  __attribute__((__nothrow__)) ;
#line 573
extern int ( __attribute__((__leaf__)) rand)(void)  __attribute__((__nothrow__)) ;
#line 575
extern void ( __attribute__((__leaf__)) srand)(unsigned int __seed )  __attribute__((__nothrow__)) ;
#line 579
extern int ( __attribute__((__leaf__)) rand_r)(unsigned int *__seed )  __attribute__((__nothrow__)) ;
#line 587
extern double ( __attribute__((__leaf__)) drand48)(void)  __attribute__((__nothrow__)) ;
#line 588
extern double ( __attribute__((__nonnull__(1), __leaf__)) erand48)(unsigned short *__xsubi )  __attribute__((__nothrow__)) ;
#line 591
extern long ( __attribute__((__leaf__)) lrand48)(void)  __attribute__((__nothrow__)) ;
#line 592
extern long ( __attribute__((__nonnull__(1), __leaf__)) nrand48)(unsigned short *__xsubi )  __attribute__((__nothrow__)) ;
#line 596
extern long ( __attribute__((__leaf__)) mrand48)(void)  __attribute__((__nothrow__)) ;
#line 597
extern long ( __attribute__((__nonnull__(1), __leaf__)) jrand48)(unsigned short *__xsubi )  __attribute__((__nothrow__)) ;
#line 601
extern void ( __attribute__((__leaf__)) srand48)(long __seedval )  __attribute__((__nothrow__)) ;
#line 602
extern unsigned short *( __attribute__((__nonnull__(1), __leaf__)) seed48)(unsigned short *__seed16v )  __attribute__((__nothrow__)) ;
#line 604
extern void ( __attribute__((__nonnull__(1), __leaf__)) lcong48)(unsigned short *__param )  __attribute__((__nothrow__)) ;
#line 621
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) drand48_r)(struct drand48_data *__buffer ,
                                                                    double *__result )  __attribute__((__nothrow__)) ;
#line 623
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) erand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data *__buffer ,
                                                                    double *__result )  __attribute__((__nothrow__)) ;
#line 628
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lrand48_r)(struct drand48_data *__buffer ,
                                                                    long *__result )  __attribute__((__nothrow__)) ;
#line 631
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) nrand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data *__buffer ,
                                                                    long *__result )  __attribute__((__nothrow__)) ;
#line 637
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) mrand48_r)(struct drand48_data *__buffer ,
                                                                    long *__result )  __attribute__((__nothrow__)) ;
#line 640
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) jrand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data *__buffer ,
                                                                    long *__result )  __attribute__((__nothrow__)) ;
#line 646
extern int ( __attribute__((__nonnull__(2), __leaf__)) srand48_r)(long __seedval ,
                                                                  struct drand48_data *__buffer )  __attribute__((__nothrow__)) ;
#line 649
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) seed48_r)(unsigned short *__seed16v ,
                                                                   struct drand48_data *__buffer )  __attribute__((__nothrow__)) ;
#line 652
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lcong48_r)(unsigned short *__param ,
                                                                    struct drand48_data *__buffer )  __attribute__((__nothrow__)) ;
#line 657
extern __uint32_t ( __attribute__((__leaf__)) arc4random)(void)  __attribute__((__nothrow__)) ;
#line 661
extern void ( __attribute__((__nonnull__(1), __leaf__)) arc4random_buf)(void *__buf ,
                                                                        size_t __size )  __attribute__((__nothrow__)) ;
#line 666
extern __uint32_t ( __attribute__((__leaf__)) arc4random_uniform)(__uint32_t __upper_bound )  __attribute__((__nothrow__)) ;
#line 672
extern void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__nothrow__,
__malloc__, __alloc_size__(1))) ;
#line 675
extern void *( __attribute__((__leaf__)) calloc)(size_t __nmemb , size_t __size )  __attribute__((__nothrow__,
__malloc__, __alloc_size__(1,2))) ;
#line 683
extern void *( __attribute__((__warn_unused_result__, __leaf__)) realloc)(void *__ptr ,
                                                                          size_t __size )  __attribute__((__nothrow__,
__alloc_size__(2))) ;
#line 687
extern void ( __attribute__((__leaf__)) free)(void *__ptr )  __attribute__((__nothrow__)) ;
#line 695
extern void *( __attribute__((__warn_unused_result__, __leaf__)) reallocarray)(void *__ptr ,
                                                                               size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__nothrow__,
__malloc__(__builtin_free,1), __malloc__(reallocarray,1), __alloc_size__(2,3))) ;
#line 32 "/usr/include/alloca.h"
extern void *( __attribute__((__leaf__)) alloca)(size_t __size )  __attribute__((__nothrow__)) ;
#line 712 "/usr/include/stdlib.h"
extern void *( __attribute__((__leaf__)) valloc)(size_t __size )  __attribute__((__nothrow__,
__malloc__(__builtin_free,1), __malloc__, __alloc_size__(1))) ;
#line 718
extern int ( __attribute__((__nonnull__(1), __leaf__)) posix_memalign)(void **__memptr ,
                                                                       size_t __alignment ,
                                                                       size_t __size )  __attribute__((__nothrow__)) ;
#line 730
extern void ( __attribute__((__leaf__)) abort)(void)  __attribute__((__nothrow__,
__noreturn__)) ;
#line 734
extern int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) )  __attribute__((__nothrow__)) ;
#line 749
extern int ( __attribute__((__nonnull__(1), __leaf__)) on_exit)(void (*__func)(int __status ,
                                                                               void *__arg ) ,
                                                                void *__arg )  __attribute__((__nothrow__)) ;
#line 756
extern void ( __attribute__((__leaf__)) exit)(int __status )  __attribute__((__nothrow__,
__noreturn__)) ;
#line 768
extern void ( __attribute__((__leaf__)) _Exit)(int __status )  __attribute__((__nothrow__,
__noreturn__)) ;
#line 773
extern char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 786
extern int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string )  __attribute__((__nothrow__)) ;
#line 792
extern int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                               char const   *__value ,
                                                               int __replace )  __attribute__((__nothrow__)) ;
#line 796
extern int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 803
extern int ( __attribute__((__leaf__)) clearenv)(void)  __attribute__((__nothrow__)) ;
#line 814
extern char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template )  __attribute__((__nothrow__)) ;
#line 827
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 849
extern int ( __attribute__((__nonnull__(1))) mkstemps)(char *__template , int __suffixlen ) ;
#line 870
extern char *( __attribute__((__nonnull__(1), __leaf__)) mkdtemp)(char *__template )  __attribute__((__nothrow__)) ;
#line 923
extern int system(char const   *__command ) ;
#line 940
extern char *( __attribute__((__leaf__)) realpath)(char const   *__name , char *__resolved )  __attribute__((__nothrow__)) ;
#line 960
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 970
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 980
extern int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__nothrow__,
__const__)) ;
#line 981
extern long ( __attribute__((__leaf__)) labs)(long __x )  __attribute__((__nothrow__,
__const__)) ;
#line 984
extern long long ( __attribute__((__leaf__)) llabs)(long long __x )  __attribute__((__nothrow__,
__const__)) ;
#line 992
extern div_t ( __attribute__((__leaf__)) div)(int __numer , int __denom )  __attribute__((__nothrow__,
__const__)) ;
#line 994
extern ldiv_t ( __attribute__((__leaf__)) ldiv)(long __numer , long __denom )  __attribute__((__nothrow__,
__const__)) ;
#line 998
extern lldiv_t ( __attribute__((__leaf__)) lldiv)(long long __numer , long long __denom )  __attribute__((__nothrow__,
__const__)) ;
#line 1012
extern char *( __attribute__((__nonnull__(3,4), __leaf__)) ecvt)(double __value ,
                                                                 int __ndigit , int *__decpt ,
                                                                 int *__sign )  __attribute__((__nothrow__)) ;
#line 1018
extern char *( __attribute__((__nonnull__(3,4), __leaf__)) fcvt)(double __value ,
                                                                 int __ndigit , int *__decpt ,
                                                                 int *__sign )  __attribute__((__nothrow__)) ;
#line 1024
extern char *( __attribute__((__nonnull__(3), __leaf__)) gcvt)(double __value , int __ndigit ,
                                                               char *__buf )  __attribute__((__nothrow__)) ;
#line 1030
extern char *( __attribute__((__nonnull__(3,4), __leaf__)) qecvt)(long double __value ,
                                                                  int __ndigit , int *__decpt ,
                                                                  int *__sign )  __attribute__((__nothrow__)) ;
#line 1033
extern char *( __attribute__((__nonnull__(3,4), __leaf__)) qfcvt)(long double __value ,
                                                                  int __ndigit , int *__decpt ,
                                                                  int *__sign )  __attribute__((__nothrow__)) ;
#line 1036
extern char *( __attribute__((__nonnull__(3), __leaf__)) qgcvt)(long double __value ,
                                                                int __ndigit , char *__buf )  __attribute__((__nothrow__)) ;
#line 1042
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) ecvt_r)(double __value ,
                                                                   int __ndigit ,
                                                                   int *__decpt ,
                                                                   int *__sign , char *__buf ,
                                                                   size_t __len )  __attribute__((__nothrow__)) ;
#line 1045
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) fcvt_r)(double __value ,
                                                                   int __ndigit ,
                                                                   int *__decpt ,
                                                                   int *__sign , char *__buf ,
                                                                   size_t __len )  __attribute__((__nothrow__)) ;
#line 1049
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) qecvt_r)(long double __value ,
                                                                    int __ndigit ,
                                                                    int *__decpt ,
                                                                    int *__sign ,
                                                                    char *__buf ,
                                                                    size_t __len )  __attribute__((__nothrow__)) ;
#line 1053
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) qfcvt_r)(long double __value ,
                                                                    int __ndigit ,
                                                                    int *__decpt ,
                                                                    int *__sign ,
                                                                    char *__buf ,
                                                                    size_t __len )  __attribute__((__nothrow__)) ;
#line 1062
extern int ( __attribute__((__leaf__)) mblen)(char const   *__s , size_t __n )  __attribute__((__nothrow__)) ;
#line 1065
extern int ( __attribute__((__leaf__)) mbtowc)(wchar_t *__pwc , char const   *__s ,
                                               size_t __n )  __attribute__((__nothrow__)) ;
#line 1069
extern int ( __attribute__((__leaf__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 1073
extern size_t ( __attribute__((__leaf__)) mbstowcs)(wchar_t *__pwcs , char const   *__s ,
                                                    size_t __n )  __attribute__((__nothrow__,
__access__(__read_only__,2))) ;
#line 1077
extern size_t ( __attribute__((__leaf__)) wcstombs)(char *__s , wchar_t const   *__pwcs ,
                                                    size_t __n )  __attribute__((__nothrow__,
__access__(__read_only__,2), __access__(__write_only__,1,3))) ;
#line 1088
extern int ( __attribute__((__nonnull__(1), __leaf__)) rpmatch)(char const   *__response )  __attribute__((__nothrow__)) ;
#line 1099
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) getsubopt)(char **__optionp ,
                                                                      char **__tokens ,
                                                                      char **__valuep )  __attribute__((__nothrow__)) ;
#line 1145
extern int ( __attribute__((__nonnull__(1), __leaf__)) getloadavg)(double *__loadavg ,
                                                                   int __nelem )  __attribute__((__nothrow__)) ;
#line 67 "/usr/include/sys/time.h"
extern int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval *__tv ,
                                                                     void *__tz )  __attribute__((__nothrow__)) ;
#line 86
extern int ( __attribute__((__leaf__)) settimeofday)(struct timeval  const  *__tv ,
                                                     struct timezone  const  *__tz )  __attribute__((__nothrow__)) ;
#line 94
extern int ( __attribute__((__leaf__)) adjtime)(struct timeval  const  *__delta ,
                                                struct timeval *__olddelta )  __attribute__((__nothrow__)) ;
#line 149
extern int ( __attribute__((__leaf__)) getitimer)(__itimer_which_t __which , struct itimerval *__value )  __attribute__((__nothrow__)) ;
#line 155
extern int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which , struct itimerval  const  *__new ,
                                                  struct itimerval *__old )  __attribute__((__nothrow__)) ;
#line 162
extern int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const   *__file ,
                                                               struct timeval  const  *__tvp )  __attribute__((__nothrow__)) ;
#line 189
extern int ( __attribute__((__nonnull__(1), __leaf__)) lutimes)(char const   *__file ,
                                                                struct timeval  const  *__tvp )  __attribute__((__nothrow__)) ;
#line 193
extern int ( __attribute__((__leaf__)) futimes)(int __fd , struct timeval  const  *__tvp )  __attribute__((__nothrow__)) ;
#line 287 "/usr/include/unistd.h"
extern int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                               int __type )  __attribute__((__nothrow__)) ;
#line 309
extern int ( __attribute__((__nonnull__(2), __leaf__)) faccessat)(int __fd , char const   *__file ,
                                                                  int __type , int __flag )  __attribute__((__nothrow__)) ;
#line 339
extern __off_t ( __attribute__((__leaf__)) lseek)(int __fd , __off_t __offset , int __whence )  __attribute__((__nothrow__)) ;
#line 358
extern int close(int __fd ) ;
#line 363
extern void ( __attribute__((__leaf__)) closefrom)(int __lowfd )  __attribute__((__nothrow__)) ;
#line 371
extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__access__(__write_only__,2,3))) ;
#line 378
extern ssize_t write(int __fd , void const   *__buf , size_t __n )  __attribute__((__access__(__read_only__,2,3))) ;
#line 389
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__access__(__write_only__,2,3))) ;
#line 398
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset )  __attribute__((__access__(__read_only__,2,3))) ;
#line 437
extern int ( __attribute__((__leaf__)) pipe)(int *__pipedes )  __attribute__((__nothrow__)) ;
#line 452
extern unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds )  __attribute__((__nothrow__)) ;
#line 464
extern unsigned int sleep(unsigned int __seconds ) ;
#line 472
extern __useconds_t ( __attribute__((__leaf__)) ualarm)(__useconds_t __value , __useconds_t __interval )  __attribute__((__nothrow__)) ;
#line 480
extern int usleep(__useconds_t __useconds ) ;
#line 489
extern int pause(void) ;
#line 493
extern int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                              __uid_t __owner , __gid_t __group )  __attribute__((__nothrow__)) ;
#line 498
extern int ( __attribute__((__leaf__)) fchown)(int __fd , __uid_t __owner , __gid_t __group )  __attribute__((__nothrow__)) ;
#line 503
extern int ( __attribute__((__nonnull__(1), __leaf__)) lchown)(char const   *__file ,
                                                               __uid_t __owner , __gid_t __group )  __attribute__((__nothrow__)) ;
#line 511
extern int ( __attribute__((__nonnull__(2), __leaf__)) fchownat)(int __fd , char const   *__file ,
                                                                 __uid_t __owner ,
                                                                 __gid_t __group ,
                                                                 int __flag )  __attribute__((__nothrow__)) ;
#line 517
extern int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path )  __attribute__((__nothrow__)) ;
#line 521
extern int ( __attribute__((__leaf__)) fchdir)(int __fd )  __attribute__((__nothrow__)) ;
#line 531
extern char *( __attribute__((__leaf__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 545
extern char *( __attribute__((__nonnull__(1), __leaf__)) getwd)(char *__buf )  __attribute__((__nothrow__,
__deprecated__, __access__(__write_only__,1))) ;
#line 552
extern int ( __attribute__((__leaf__)) dup)(int __fd )  __attribute__((__nothrow__)) ;
#line 555
extern int ( __attribute__((__leaf__)) dup2)(int __fd , int __fd2 )  __attribute__((__nothrow__)) ;
#line 564
extern char **__environ ;
#line 572
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                 char **__argv , char **__envp )  __attribute__((__nothrow__)) ;
#line 578
extern int ( __attribute__((__nonnull__(2), __leaf__)) fexecve)(int __fd , char **__argv ,
                                                                char **__envp )  __attribute__((__nothrow__)) ;
#line 584
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                char **__argv )  __attribute__((__nothrow__)) ;
#line 589
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *__path ,
                                                                 char const   *__arg 
                                                                 , ...)  __attribute__((__nothrow__)) ;
#line 594
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                char const   *__arg 
                                                                , ...)  __attribute__((__nothrow__)) ;
#line 599
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                 char **__argv )  __attribute__((__nothrow__)) ;
#line 605
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                 char const   *__arg 
                                                                 , ...)  __attribute__((__nothrow__)) ;
#line 619
extern int ( __attribute__((__leaf__)) nice)(int __inc )  __attribute__((__nothrow__)) ;
#line 624
extern void _exit(int __status )  __attribute__((__noreturn__)) ;
#line 633
extern long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                  int __name )  __attribute__((__nothrow__)) ;
#line 637
extern long ( __attribute__((__leaf__)) fpathconf)(int __fd , int __name )  __attribute__((__nothrow__)) ;
#line 640
extern long ( __attribute__((__leaf__)) sysconf)(int __name )  __attribute__((__nothrow__)) ;
#line 644
extern size_t ( __attribute__((__leaf__)) confstr)(int __name , char *__buf , size_t __len )  __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 650
extern __pid_t ( __attribute__((__leaf__)) getpid)(void)  __attribute__((__nothrow__)) ;
#line 653
extern __pid_t ( __attribute__((__leaf__)) getppid)(void)  __attribute__((__nothrow__)) ;
#line 656
extern __pid_t ( __attribute__((__leaf__)) getpgrp)(void)  __attribute__((__nothrow__)) ;
#line 659
extern __pid_t ( __attribute__((__leaf__)) __getpgid)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 661
extern __pid_t ( __attribute__((__leaf__)) getpgid)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 668
extern int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid , __pid_t __pgid )  __attribute__((__nothrow__)) ;
#line 682
extern int ( __attribute__((__leaf__)) setpgrp)(void)  __attribute__((__nothrow__)) ;
#line 689
extern __pid_t ( __attribute__((__leaf__)) setsid)(void)  __attribute__((__nothrow__)) ;
#line 693
extern __pid_t ( __attribute__((__leaf__)) getsid)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 697
extern __uid_t ( __attribute__((__leaf__)) getuid)(void)  __attribute__((__nothrow__)) ;
#line 700
extern __uid_t ( __attribute__((__leaf__)) geteuid)(void)  __attribute__((__nothrow__)) ;
#line 703
extern __gid_t ( __attribute__((__leaf__)) getgid)(void)  __attribute__((__nothrow__)) ;
#line 706
extern __gid_t ( __attribute__((__leaf__)) getegid)(void)  __attribute__((__nothrow__)) ;
#line 711
extern int ( __attribute__((__leaf__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__,
__access__(__write_only__,2,1))) ;
#line 722
extern int ( __attribute__((__leaf__)) setuid)(__uid_t __uid )  __attribute__((__nothrow__)) ;
#line 727
extern int ( __attribute__((__leaf__)) setreuid)(__uid_t __ruid , __uid_t __euid )  __attribute__((__nothrow__)) ;
#line 732
extern int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid )  __attribute__((__nothrow__)) ;
#line 739
extern int ( __attribute__((__leaf__)) setgid)(__gid_t __gid )  __attribute__((__nothrow__)) ;
#line 744
extern int ( __attribute__((__leaf__)) setregid)(__gid_t __rgid , __gid_t __egid )  __attribute__((__nothrow__)) ;
#line 749
extern int ( __attribute__((__leaf__)) setegid)(__gid_t __gid )  __attribute__((__nothrow__)) ;
#line 778
extern __pid_t fork(void)  __attribute__((__nothrow__)) ;
#line 786
extern __pid_t ( __attribute__((__leaf__)) vfork)(void)  __attribute__((__nothrow__)) ;
#line 799
extern char *( __attribute__((__leaf__)) ttyname)(int __fd )  __attribute__((__nothrow__)) ;
#line 803
extern int ( __attribute__((__nonnull__(2), __leaf__)) ttyname_r)(int __fd , char *__buf ,
                                                                  size_t __buflen )  __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 809
extern int ( __attribute__((__leaf__)) isatty)(int __fd )  __attribute__((__nothrow__)) ;
#line 814
extern int ( __attribute__((__leaf__)) ttyslot)(void)  __attribute__((__nothrow__)) ;
#line 819
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                               char const   *__to )  __attribute__((__nothrow__)) ;
#line 825
extern int ( __attribute__((__nonnull__(2,4), __leaf__)) linkat)(int __fromfd , char const   *__from ,
                                                                 int __tofd , char const   *__to ,
                                                                 int __flags )  __attribute__((__nothrow__)) ;
#line 832
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                  char const   *__to )  __attribute__((__nothrow__)) ;
#line 838
extern ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   *__path ,
                                                                       char *__buf ,
                                                                       size_t __len )  __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
#line 847
extern int ( __attribute__((__nonnull__(1,3), __leaf__)) symlinkat)(char const   *__from ,
                                                                    int __tofd , char const   *__to )  __attribute__((__nothrow__)) ;
#line 851
extern ssize_t ( __attribute__((__nonnull__(2,3), __leaf__)) readlinkat)(int __fd ,
                                                                         char const   *__path ,
                                                                         char *__buf ,
                                                                         size_t __len )  __attribute__((__nothrow__,
__access__(__write_only__,3,4))) ;
#line 858
extern int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 862
extern int ( __attribute__((__nonnull__(2), __leaf__)) unlinkat)(int __fd , char const   *__name ,
                                                                 int __flag )  __attribute__((__nothrow__)) ;
#line 867
extern int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path )  __attribute__((__nothrow__)) ;
#line 871
extern __pid_t ( __attribute__((__leaf__)) tcgetpgrp)(int __fd )  __attribute__((__nothrow__)) ;
#line 874
extern int ( __attribute__((__leaf__)) tcsetpgrp)(int __fd , __pid_t __pgrp_id )  __attribute__((__nothrow__)) ;
#line 881
extern char *getlogin(void) ;
#line 889
extern int ( __attribute__((__nonnull__(1))) getlogin_r)(char *__name , size_t __name_len )  __attribute__((__access__(__write_only__,1,2))) ;
#line 895
extern int ( __attribute__((__nonnull__(1), __leaf__)) setlogin)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 36 "/usr/include/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt)(int ___argc , char **___argv ,
                                                                 char const   *__shortopts )  __attribute__((__nothrow__)) ;
#line 911 "/usr/include/unistd.h"
extern int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                    size_t __len )  __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
#line 919
extern int ( __attribute__((__nonnull__(1), __leaf__)) sethostname)(char const   *__name ,
                                                                    size_t __len )  __attribute__((__nothrow__,
__access__(__read_only__,1,2))) ;
#line 924
extern int ( __attribute__((__leaf__)) sethostid)(long __id )  __attribute__((__nothrow__)) ;
#line 930
extern int ( __attribute__((__nonnull__(1), __leaf__)) getdomainname)(char *__name ,
                                                                      size_t __len )  __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
#line 933
extern int ( __attribute__((__nonnull__(1), __leaf__)) setdomainname)(char const   *__name ,
                                                                      size_t __len )  __attribute__((__nothrow__,
__access__(__read_only__,1,2))) ;
#line 939
extern int ( __attribute__((__leaf__)) vhangup)(void)  __attribute__((__nothrow__)) ;
#line 942
extern int ( __attribute__((__nonnull__(1), __leaf__)) revoke)(char const   *__file )  __attribute__((__nothrow__)) ;
#line 950
extern int ( __attribute__((__nonnull__(1), __leaf__)) profil)(unsigned short *__sample_buffer ,
                                                               size_t __size , size_t __offset ,
                                                               unsigned int __scale )  __attribute__((__nothrow__)) ;
#line 958
extern int ( __attribute__((__leaf__)) acct)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 962
extern char *( __attribute__((__leaf__)) getusershell)(void)  __attribute__((__nothrow__)) ;
#line 963
extern void ( __attribute__((__leaf__)) endusershell)(void)  __attribute__((__nothrow__)) ;
#line 964
extern void ( __attribute__((__leaf__)) setusershell)(void)  __attribute__((__nothrow__)) ;
#line 970
extern int ( __attribute__((__leaf__)) daemon)(int __nochdir , int __noclose )  __attribute__((__nothrow__)) ;
#line 977
extern int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path )  __attribute__((__nothrow__)) ;
#line 981
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 989
extern int fsync(int __fd ) ;
#line 1002
extern long gethostid(void) ;
#line 1005
extern void ( __attribute__((__leaf__)) sync)(void)  __attribute__((__nothrow__)) ;
#line 1011
extern int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 1016
extern int ( __attribute__((__leaf__)) getdtablesize)(void)  __attribute__((__nothrow__)) ;
#line 1026
extern int ( __attribute__((__nonnull__(1), __leaf__)) truncate)(char const   *__file ,
                                                                 __off_t __length )  __attribute__((__nothrow__)) ;
#line 1049
extern int ( __attribute__((__leaf__)) ftruncate)(int __fd , __off_t __length )  __attribute__((__nothrow__)) ;
#line 1070
extern int ( __attribute__((__leaf__)) brk)(void *__addr )  __attribute__((__nothrow__)) ;
#line 1076
extern void *( __attribute__((__leaf__)) sbrk)(intptr_t __delta )  __attribute__((__nothrow__)) ;
#line 1091
extern long ( __attribute__((__leaf__)) syscall)(long __sysno  , ...)  __attribute__((__nothrow__)) ;
#line 1114
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 1150
extern int fdatasync(int __fildes ) ;
#line 1162
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) crypt)(char const   *__key ,
                                                                  char const   *__salt )  __attribute__((__nothrow__)) ;
#line 1201
extern int getentropy(void *__buffer , size_t __length )  __attribute__((__access__(__write_only__,1,2))) ;
#line 34 "m_misc.h"
boolean M_WriteFile(char const   *name , void *source , int length ) ;
#line 40
int M_ReadFile(char const   *name , byte **buffer___0 ) ;
#line 45
void M_ScreenShot(void) ;
#line 47
void M_LoadDefaults(void) ;
#line 49
void M_SaveDefaults(void) ;
#line 52
int M_DrawText(int x___0 , int y___1 , boolean direct , char *string ) ;
#line 37 "i_video.h"
void I_InitGraphics(void) ;
#line 40
void I_ShutdownGraphics(void) ;
#line 43
void I_SetPalette(byte *palette ) ;
#line 45
void I_UpdateNoBlit(void) ;
#line 46
void I_FinishUpdate(void) ;
#line 49
void I_WaitVBL(int count ) ;
#line 51
void I_ReadScreen(byte *scr ) ;
#line 53
void I_BeginRead(void) ;
#line 54
void I_EndRead(void) ;
#line 31 "i_sound.h"
FILE *sndserver ;
#line 32
char *sndserver_filename ;
#line 90 "sounds.h"
sfxinfo_t S_sfx[109] ;
#line 93
musicinfo_t S_music[68] ;
#line 41 "i_sound.h"
void I_InitSound(void) ;
#line 44
void I_UpdateSound(void) ;
#line 45
void I_SubmitSound(void) ;
#line 48
void I_ShutdownSound(void) ;
#line 56
void I_SetChannels(void) ;
#line 59
int I_GetSfxLumpNum(sfxinfo_t *sfx ) ;
#line 63
int I_StartSound(int id , int vol , int sep , int pitch , int priority___0 ) ;
#line 73
void I_StopSound(int handle ) ;
#line 78
int I_SoundIsPlaying(int handle ) ;
#line 82
void I_UpdateSoundParams(int handle , int vol , int sep , int pitch ) ;
#line 93
void I_InitMusic(void) ;
#line 94
void I_ShutdownMusic(void) ;
#line 96
void I_SetMusicVolume(int volume ) ;
#line 98
void I_PauseSong(int handle ) ;
#line 99
void I_ResumeSong(int handle ) ;
#line 101
int I_RegisterSong(void *data ) ;
#line 106
void I_PlaySong(int handle , int looping___0 ) ;
#line 111
void I_StopSong(int handle ) ;
#line 113
void I_UnRegisterSong(int handle ) ;
#line 110 "d_event.h"
event_t events[64] ;
#line 111
int eventhead ;
#line 112
int eventtail ;
#line 114
gameaction_t gameaction ;
#line 34 "g_game.h"
void G_DeathMatchSpawnPlayer(int playernum ) ;
#line 36
void G_InitNew(skill_t skill , int episode , int map ) ;
#line 41
void G_DeferedInitNew(skill_t skill , int episode , int map ) ;
#line 43
void G_DeferedPlayDemo(char *name ) ;
#line 47
void G_LoadGame(char *name ) ;
#line 49
void G_DoLoadGame(void) ;
#line 52
void G_SaveGame(int slot , char *description ) ;
#line 55
void G_RecordDemo(char *name ) ;
#line 57
void G_BeginRecording(void) ;
#line 59
extern void G_PlayDemo(char *name ) ;
#line 60
void G_TimeDemo(char *name ) ;
#line 61
boolean G_CheckDemoStatus(void) ;
#line 63
void G_ExitLevel(void) ;
#line 64
void G_SecretExitLevel(void) ;
#line 66
void G_WorldDone(void) ;
#line 68
void G_Ticker(void) ;
#line 69
boolean G_Responder(event_t *ev ) ;
#line 71
void G_ScreenShot(void) ;
#line 35 "i_system.h"
void I_Init(void) ;
#line 40
byte *I_ZoneBase(int *size ) ;
#line 45
int I_GetTime(void) ;
#line 56
void I_StartFrame(void) ;
#line 64
void I_StartTic(void) ;
#line 74
ticcmd_t *I_BaseTiccmd(void) ;
#line 79
void I_Quit(void) ;
#line 84
byte *I_AllocLow(int length ) ;
#line 86
void I_Tactile(int on , int off , int total___0 ) ;
#line 89
void I_Error(char *error  , ...) ;
#line 51 "i_system.c"
int mb_used  =    6;
#line 54 "i_system.c"
void I_Tactile(int on , int off , int total___0 ) 
{ 


  {
#line 61
  total___0 = 0;
#line 61
  off = total___0;
#line 61
  on = off;
#line 62
  return;
}
}
#line 64 "i_system.c"
ticcmd_t emptycmd  ;
#line 65 "i_system.c"
ticcmd_t *I_BaseTiccmd(void) 
{ 


  {
#line 67
  return (& emptycmd);
}
}
#line 71 "i_system.c"
int I_GetHeapSize(void) 
{ 


  {
#line 73
  return ((mb_used * 1024) * 1024);
}
}
#line 76 "i_system.c"
byte *I_ZoneBase(int *size ) 
{ 
  void *tmp ;

  {
#line 78
  *size = (mb_used * 1024) * 1024;
#line 79
  tmp = malloc((size_t )*size);
#line 79
  return ((byte *)tmp);
}
}
#line 93 "i_system.c"
static int basetime  =    0;
#line 88 "i_system.c"
int I_GetTime(void) 
{ 
  struct timeval tp ;
  struct timezone tzp ;
  int newtics ;

  {
#line 95
  gettimeofday((struct timeval * __restrict  )(& tp), (void * __restrict  )(& tzp));
#line 96
  if (! basetime) {
#line 97
    basetime = (int )tp.tv_sec;
  }
#line 98
  newtics = (int )((tp.tv_sec - (__time_t )basetime) * 35L + (tp.tv_usec * 35L) / 1000000L);
#line 99
  return (newtics);
}
}
#line 107 "i_system.c"
void I_Init(void) 
{ 


  {
#line 109
  I_InitSound();
#line 111
  return;
}
}
#line 116 "i_system.c"
void I_Quit(void) 
{ 


  {
#line 118
  D_QuitNetGame();
#line 119
  I_ShutdownSound();
#line 120
  I_ShutdownMusic();
#line 121
  M_SaveDefaults();
#line 122
  I_ShutdownGraphics();
#line 123
  exit(0);
}
}
#line 126 "i_system.c"
void I_WaitVBL(int count ) 
{ 


  {
#line 134
  usleep((__useconds_t )(count * 14285));
#line 137
  return;
}
}
#line 139 "i_system.c"
void I_BeginRead(void) 
{ 


  {
#line 141
  return;
}
}
#line 143 "i_system.c"
void I_EndRead(void) 
{ 


  {
#line 145
  return;
}
}
#line 147 "i_system.c"
byte *I_AllocLow(int length ) 
{ 
  byte *mem ;
  void *tmp ;

  {
#line 151
  tmp = malloc((size_t )length);
#line 151
  mem = (byte *)tmp;
#line 152
  memset((void *)mem, 0, (size_t )length);
#line 153
  return (mem);
}
}
#line 162 "i_system.c"
void I_Error(char *error  , ...) 
{ 
  va_list argptr ;

  {
#line 167
  __builtin_va_start(argptr, error);
#line 168
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: ");
#line 169
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )error, argptr);
#line 170
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 171
  __builtin_va_end(argptr);
#line 173
  fflush(stderr);
#line 176
  if (demorecording) {
#line 177
    G_CheckDemoStatus();
  }
#line 179
  D_QuitNetGame();
#line 180
  I_ShutdownGraphics();
#line 182
  exit(-1);
}
}
#line 24 "i_sound.c"
static char const   rcsid___3[49]  = 
#line 24 "i_sound.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'i',      (char const   )'_',      (char const   )'u', 
        (char const   )'n',      (char const   )'i',      (char const   )'x',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 177 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 209
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 233
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 255
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 301
extern int ( __attribute__((__leaf__)) posix_fadvise)(int __fd , __off_t __offset ,
                                                      __off_t __len , int __advise )  __attribute__((__nothrow__)) ;
#line 323
extern int posix_fallocate(int __fd , __off_t __offset , __off_t __len ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern int ( __attribute__((__leaf__)) ioctl)(int __fd , unsigned long __request 
                                              , ...)  __attribute__((__nothrow__)) ;
#line 1054 "/usr/include/linux/soundcard.h"
extern void seqbuf_dump(void) ;
#line 72 "/usr/include/time.h"
extern clock_t ( __attribute__((__leaf__)) clock)(void)  __attribute__((__nothrow__)) ;
#line 76
extern time_t ( __attribute__((__leaf__)) time)(time_t *__timer )  __attribute__((__nothrow__)) ;
#line 79
extern double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 99
extern size_t ( __attribute__((__nonnull__(1,3,4), __leaf__)) strftime)(char * __restrict  __s ,
                                                                        size_t __maxsize ,
                                                                        char const   * __restrict  __format ,
                                                                        struct tm  const  * __restrict  __tp )  __attribute__((__nothrow__)) ;
#line 116
extern size_t ( __attribute__((__leaf__)) strftime_l)(char * __restrict  __s , size_t __maxsize ,
                                                      char const   * __restrict  __format ,
                                                      struct tm  const  * __restrict  __tp ,
                                                      locale_t __loc )  __attribute__((__nothrow__)) ;
#line 132
extern struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer )  __attribute__((__nothrow__)) ;
#line 136
extern struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer )  __attribute__((__nothrow__)) ;
#line 154
extern struct tm *( __attribute__((__leaf__)) gmtime_r)(time_t const   *__timer ,
                                                        struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 159
extern struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   *__timer ,
                                                           struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 179
extern char *( __attribute__((__leaf__)) asctime)(struct tm  const  *__tp )  __attribute__((__nothrow__)) ;
#line 183
extern char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer )  __attribute__((__nothrow__)) ;
#line 197
extern char *( __attribute__((__leaf__)) asctime_r)(struct tm  const  *__tp , char *__buf )  __attribute__((__nothrow__)) ;
#line 202
extern char *( __attribute__((__leaf__)) ctime_r)(time_t const   *__timer , char *__buf )  __attribute__((__nothrow__)) ;
#line 217
extern char *__tzname[2] ;
#line 218
extern int __daylight ;
#line 219
extern long __timezone ;
#line 224
extern char *tzname[2] ;
#line 228
extern void ( __attribute__((__leaf__)) tzset)(void)  __attribute__((__nothrow__)) ;
#line 232
extern int daylight ;
#line 233
extern long timezone ;
#line 246
extern time_t ( __attribute__((__leaf__)) timegm)(struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 263
extern time_t ( __attribute__((__leaf__)) timelocal)(struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 271
extern int ( __attribute__((__leaf__)) dysize)(int __year )  __attribute__((__nothrow__,
__const__)) ;
#line 281
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 285
extern int ( __attribute__((__leaf__)) clock_getres)(clockid_t __clock_id , struct timespec *__res )  __attribute__((__nothrow__)) ;
#line 288
extern int ( __attribute__((__nonnull__(2), __leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                      struct timespec *__tp )  __attribute__((__nothrow__)) ;
#line 292
extern int ( __attribute__((__nonnull__(2), __leaf__)) clock_settime)(clockid_t __clock_id ,
                                                                      struct timespec  const  *__tp )  __attribute__((__nothrow__)) ;
#line 323
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec  const  *__req ,
                           struct timespec *__rem ) ;
#line 338
extern int ( __attribute__((__leaf__)) clock_getcpuclockid)(pid_t __pid , clockid_t *__clock_id )  __attribute__((__nothrow__)) ;
#line 343
extern int ( __attribute__((__leaf__)) timer_create)(clockid_t __clock_id , struct sigevent *__evp ,
                                                     timer_t *__timerid )  __attribute__((__nothrow__)) ;
#line 348
extern int ( __attribute__((__leaf__)) timer_delete)(timer_t __timerid )  __attribute__((__nothrow__)) ;
#line 352
extern int ( __attribute__((__leaf__)) timer_settime)(timer_t __timerid , int __flags ,
                                                      struct itimerspec  const  *__value ,
                                                      struct itimerspec *__ovalue )  __attribute__((__nothrow__)) ;
#line 357
extern int ( __attribute__((__leaf__)) timer_gettime)(timer_t __timerid , struct itimerspec *__value )  __attribute__((__nothrow__)) ;
#line 376
extern int ( __attribute__((__leaf__)) timer_getoverrun)(timer_t __timerid )  __attribute__((__nothrow__)) ;
#line 77 "/usr/include/signal.h"
extern __sighandler_t ( __attribute__((__leaf__)) __sysv_signal)(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 88
extern __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 112
extern int ( __attribute__((__leaf__)) kill)(__pid_t __pid , int __sig )  __attribute__((__nothrow__)) ;
#line 119
extern int ( __attribute__((__leaf__)) killpg)(__pid_t __pgrp , int __sig )  __attribute__((__nothrow__)) ;
#line 123
extern int ( __attribute__((__leaf__)) raise)(int __sig )  __attribute__((__nothrow__)) ;
#line 127
extern __sighandler_t ( __attribute__((__leaf__)) ssignal)(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 129
extern int ( __attribute__((__leaf__)) gsignal)(int __sig )  __attribute__((__nothrow__)) ;
#line 134
extern void psignal(int __sig , char const   *__s ) ;
#line 137
extern void psiginfo(siginfo_t const   *__pinfo , char const   *__s ) ;
#line 173
extern int ( __attribute__((__leaf__)) sigblock)(int __mask )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 176
extern int ( __attribute__((__leaf__)) sigsetmask)(int __mask )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 179
extern int ( __attribute__((__leaf__)) siggetmask)(void)  __attribute__((__nothrow__,
__deprecated__)) ;
#line 199
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set )  __attribute__((__nothrow__)) ;
#line 202
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set )  __attribute__((__nothrow__)) ;
#line 205
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                  int __signo )  __attribute__((__nothrow__)) ;
#line 208
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigdelset)(sigset_t *__set ,
                                                                  int __signo )  __attribute__((__nothrow__)) ;
#line 211
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigismember)(sigset_t const   *__set ,
                                                                    int __signo )  __attribute__((__nothrow__)) ;
#line 232
extern int ( __attribute__((__leaf__)) sigprocmask)(int __how , sigset_t const   *__set ,
                                                    sigset_t *__oset )  __attribute__((__nothrow__)) ;
#line 240
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const   *__set ) ;
#line 243
extern int ( __attribute__((__leaf__)) sigaction)(int __sig , struct sigaction  const  *__act ,
                                                  struct sigaction *__oact )  __attribute__((__nothrow__)) ;
#line 247
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigpending)(sigset_t *__set )  __attribute__((__nothrow__)) ;
#line 255
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const   *__set ,
                                                        int *__sig ) ;
#line 264
extern int ( __attribute__((__nonnull__(1))) sigwaitinfo)(sigset_t const   *__set ,
                                                          siginfo_t *__info ) ;
#line 273
extern int ( __attribute__((__nonnull__(1))) sigtimedwait)(sigset_t const   *__set ,
                                                           siginfo_t *__info , struct timespec  const  *__timeout ) ;
#line 292
extern int ( __attribute__((__leaf__)) sigqueue)(__pid_t __pid , int __sig , union sigval  const  __val )  __attribute__((__nothrow__)) ;
#line 304
extern int ( __attribute__((__leaf__)) sigreturn)(struct sigcontext *__scp )  __attribute__((__nothrow__)) ;
#line 324
extern int ( __attribute__((__leaf__)) siginterrupt)(int __sig , int __interrupt )  __attribute__((__nothrow__,
__deprecated__("Use sigaction with SA_RESTART instead"))) ;
#line 333
extern int ( __attribute__((__leaf__)) sigaltstack)(stack_t const   *__ss , stack_t *__oss )  __attribute__((__nothrow__)) ;
#line 347
extern int ( __attribute__((__leaf__)) sigstack)(struct sigstack *__ss , struct sigstack *__oss )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 31 "/usr/include/bits/sigthread.h"
extern int ( __attribute__((__leaf__)) pthread_sigmask)(int __how , __sigset_t const   *__newmask ,
                                                        __sigset_t *__oldmask )  __attribute__((__nothrow__)) ;
#line 36
extern int ( __attribute__((__leaf__)) pthread_kill)(pthread_t __threadid , int __signo )  __attribute__((__nothrow__)) ;
#line 383 "/usr/include/signal.h"
extern int ( __attribute__((__leaf__)) __libc_current_sigrtmin)(void)  __attribute__((__nothrow__)) ;
#line 385
extern int ( __attribute__((__leaf__)) __libc_current_sigrtmax)(void)  __attribute__((__nothrow__)) ;
#line 47 "z_zone.h"
void Z_Init(void) ;
#line 48
void *Z_Malloc(int size , int tag , void *user ) ;
#line 49
void Z_Free(void *ptr ) ;
#line 50
void Z_FreeTags(int lowtag , int hightag ) ;
#line 51
void Z_DumpHeap(int lowtag , int hightag ) ;
#line 52
void Z_FileDumpHeap(FILE *f ) ;
#line 53
void Z_CheckHeap(void) ;
#line 54
void Z_ChangeTag2(void *ptr , int tag ) ;
#line 55
int Z_FreeMemory(void) ;
#line 29 "m_argv.h"
int myargc ;
#line 30
char **myargv ;
#line 34
int M_CheckParm(char *check ) ;
#line 65 "w_wad.h"
void **lumpcache ;
#line 66
lumpinfo_t *lumpinfo ;
#line 67
int numlumps ;
#line 69
void W_InitMultipleFiles(char **filenames ) ;
#line 70
void W_Reload(void) ;
#line 72
int W_CheckNumForName(char *name ) ;
#line 73
int W_GetNumForName(char *name ) ;
#line 75
int W_LumpLength(int lump ) ;
#line 76
void W_ReadLump(int lump , void *dest ) ;
#line 78
void *W_CacheLumpNum(int lump , int tag ) ;
#line 79
void *W_CacheLumpName(char *name , int tag ) ;
#line 64 "i_sound.c"
FILE *sndserver  =    (FILE *)0;
#line 65 "i_sound.c"
char *sndserver_filename  =    "./sndserver ";
#line 84 "i_sound.c"
static int flag  =    0;
#line 103 "i_sound.c"
int lengths[109]  ;
#line 106 "i_sound.c"
int audio_fd  ;
#line 112 "i_sound.c"
short mixbuffer[2048]  ;
#line 116 "i_sound.c"
unsigned int channelstep[8]  ;
#line 118 "i_sound.c"
unsigned int channelstepremainder[8]  ;
#line 122 "i_sound.c"
unsigned char *channels[8]  ;
#line 123 "i_sound.c"
unsigned char *channelsend[8]  ;
#line 131 "i_sound.c"
int channelstart[8]  ;
#line 137 "i_sound.c"
int channelhandles[8]  ;
#line 141 "i_sound.c"
int channelids[8]  ;
#line 144 "i_sound.c"
int steptable[256]  ;
#line 147 "i_sound.c"
int vol_lookup[32768]  ;
#line 150 "i_sound.c"
int *channelleftvol_lookup[8]  ;
#line 151 "i_sound.c"
int *channelrightvol_lookup[8]  ;
#line 166
extern int errno ;
#line 159 "i_sound.c"
void myioctl(int fd , int command , int *arg ) 
{ 
  int rc ;

  {
#line 168
  rc = ioctl(fd, (unsigned long )command, arg);
#line 169
  if (rc < 0) {
#line 171
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ioctl(dsp,%d,arg) failed\n",
            command);
#line 172
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"errno=%d\n",
            errno);
#line 173
    exit(-1);
  }
#line 175
  return;
}
}
#line 185 "i_sound.c"
void *getsfx(char *sfxname , int *len ) 
{ 
  unsigned char *sfx ;
  unsigned char *paddedsfx ;
  int i ;
  int size ;
  int paddedsize ;
  char name[20] ;
  int sfxlump ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 201
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"ds%s", sfxname);
#line 213
  tmp = W_CheckNumForName(name);
#line 213
  if (tmp == -1) {
#line 214
    sfxlump = W_GetNumForName("dspistol");
  } else {
#line 216
    sfxlump = W_GetNumForName(name);
  }
#line 218
  size = W_LumpLength(sfxlump);
#line 226
  tmp___0 = W_CacheLumpNum(sfxlump, 1);
#line 226
  sfx = (unsigned char *)tmp___0;
#line 230
  paddedsize = (((size - 8) + 511) / 512) * 512;
#line 233
  tmp___1 = Z_Malloc(paddedsize + 8, 1, (void *)0);
#line 233
  paddedsfx = (unsigned char *)tmp___1;
#line 239
  memcpy((void * __restrict  )paddedsfx, (void const   * __restrict  )sfx, (size_t )size);
#line 240
  i = size;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (i < paddedsize + 8)) {
#line 240
      goto while_break;
    }
#line 241
    *(paddedsfx + i) = (unsigned char)128;
#line 240
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  Z_Free((void *)sfx);
#line 247
  *len = paddedsize;
#line 250
  return ((void *)(paddedsfx + 8));
}
}
#line 271
int addsfx(int sfxid , int volume , int step , int seperation ) ;
#line 271 "i_sound.c"
static unsigned short handlenums  =    (unsigned short)0;
#line 264 "i_sound.c"
int addsfx(int sfxid , int volume , int step , int seperation ) 
{ 
  int i ;
  int rc ;
  int oldest ;
  int oldestnum ;
  int slot ;
  int rightvol ;
  int leftvol ;
  unsigned short tmp ;

  {
#line 274
  rc = -1;
#line 276
  oldest = gametic;
#line 277
  oldestnum = 0;
#line 285
  if (sfxid == 10) {
#line 285
    goto _L___4;
  } else
#line 285
  if (sfxid == 11) {
    _L___4: /* CIL Label */ 
#line 285
    goto _L___3;
  } else
#line 285
  if (sfxid == 12) {
    _L___3: /* CIL Label */ 
#line 285
    goto _L___2;
  } else
#line 285
  if (sfxid == 13) {
    _L___2: /* CIL Label */ 
#line 285
    goto _L___1;
  } else
#line 285
  if (sfxid == 22) {
    _L___1: /* CIL Label */ 
#line 285
    goto _L___0;
  } else
#line 285
  if (sfxid == 1) {
    _L___0: /* CIL Label */ 
#line 293
    i = 0;
    {
#line 293
    while (1) {
      while_continue: /* CIL Label */ ;
#line 293
      if (! (i < 8)) {
#line 293
        goto while_break;
      }
#line 296
      if (channels[i]) {
#line 296
        if (channelids[i] == sfxid) {
#line 300
          channels[i] = (unsigned char *)0;
#line 303
          goto while_break;
        } else {
#line 296
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
#line 293
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 309
  i = 0;
  {
#line 309
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 309
    if (i < 8) {
#line 309
      if (! channels[i]) {
#line 309
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
#line 309
      goto while_break___0;
    }
#line 311
    if (channelstart[i] < oldest) {
#line 313
      oldestnum = i;
#line 314
      oldest = channelstart[i];
    }
#line 309
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 322
  if (i == 8) {
#line 323
    slot = oldestnum;
  } else {
#line 325
    slot = i;
  }
#line 330
  channels[slot] = (unsigned char *)S_sfx[sfxid].data;
#line 332
  channelsend[slot] = channels[slot] + lengths[sfxid];
#line 335
  if (! handlenums) {
#line 336
    handlenums = (unsigned short)100;
  }
#line 340
  tmp = handlenums;
#line 340
  handlenums = (unsigned short )((int )handlenums + 1);
#line 340
  rc = (int )tmp;
#line 340
  channelhandles[slot] = rc;
#line 344
  channelstep[slot] = (unsigned int )step;
#line 346
  channelstepremainder[slot] = 0U;
#line 348
  channelstart[slot] = gametic;
#line 352
  seperation ++;
#line 357
  leftvol = volume - ((volume * seperation) * seperation >> 16);
#line 359
  seperation -= 257;
#line 360
  rightvol = volume - ((volume * seperation) * seperation >> 16);
#line 364
  if (rightvol < 0) {
#line 364
    goto _L___6;
  } else
#line 364
  if (rightvol > 127) {
    _L___6: /* CIL Label */ 
#line 365
    I_Error("rightvol out of bounds");
  }
#line 367
  if (leftvol < 0) {
#line 367
    goto _L___7;
  } else
#line 367
  if (leftvol > 127) {
    _L___7: /* CIL Label */ 
#line 368
    I_Error("leftvol out of bounds");
  }
#line 372
  channelleftvol_lookup[slot] = & vol_lookup[leftvol * 256];
#line 373
  channelrightvol_lookup[slot] = & vol_lookup[rightvol * 256];
#line 377
  channelids[slot] = sfxid;
#line 380
  return (rc);
}
}
#line 396 "i_sound.c"
void I_SetChannels(void) 
{ 
  int i ;
  int j ;
  int *steptablemid ;
  double tmp ;

  {
#line 404
  steptablemid = steptable + 128;
#line 414
  i = -128;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < 128)) {
#line 414
      goto while_break;
    }
#line 415
    tmp = pow(2.0, (double )i / 64.0);
#line 415
    *(steptablemid + i) = (int )(tmp * 65536.0);
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 421
  i = 0;
  {
#line 421
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 421
    if (! (i < 128)) {
#line 421
      goto while_break___0;
    }
#line 422
    j = 0;
    {
#line 422
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 422
      if (! (j < 256)) {
#line 422
        goto while_break___1;
      }
#line 423
      vol_lookup[i * 256 + j] = ((i * (j - 128)) * 256) / 127;
#line 422
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 421
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 424
  return;
}
}
#line 427 "i_sound.c"
void I_SetSfxVolume(int volume ) 
{ 


  {
#line 434
  snd_SfxVolume = volume;
#line 435
  return;
}
}
#line 438 "i_sound.c"
void I_SetMusicVolume(int volume ) 
{ 


  {
#line 441
  snd_MusicVolume = volume;
#line 444
  return;
}
}
#line 451 "i_sound.c"
int I_GetSfxLumpNum(sfxinfo_t *sfx ) 
{ 
  char namebuf[9] ;
  int tmp ;

  {
#line 454
  sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"ds%s", sfx->name);
#line 455
  tmp = W_GetNumForName(namebuf);
#line 455
  return (tmp);
}
}
#line 470 "i_sound.c"
int I_StartSound(int id , int vol , int sep , int pitch , int priority___0 ) 
{ 


  {
#line 480
  priority___0 = 0;
#line 483
  if (sndserver) {
#line 485
    fprintf((FILE * __restrict  )sndserver, (char const   * __restrict  )"p%2.2x%2.2x%2.2x%2.2x\n",
            id, pitch, vol, sep);
#line 486
    fflush(sndserver);
  }
#line 489
  return (id);
}
}
#line 505 "i_sound.c"
void I_StopSound(int handle ) 
{ 


  {
#line 513
  handle = 0;
#line 514
  return;
}
}
#line 517 "i_sound.c"
int I_SoundIsPlaying(int handle ) 
{ 


  {
#line 520
  return (gametic < handle);
}
}
#line 539 "i_sound.c"
void I_UpdateSound(void) 
{ 
  register unsigned int sample ;
  register int dl ;
  register int dr ;
  short *leftout ;
  short *rightout ;
  short *leftend ;
  int step ;
  int chan ;

  {
#line 565
  leftout = mixbuffer;
#line 566
  rightout = mixbuffer + 1;
#line 567
  step = 2;
#line 571
  leftend = mixbuffer + 512 * step;
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! ((unsigned long )leftout != (unsigned long )leftend)) {
#line 576
      goto while_break;
    }
#line 579
    dl = 0;
#line 580
    dr = 0;
#line 585
    chan = 0;
    {
#line 585
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 585
      if (! (chan < 8)) {
#line 585
        goto while_break___0;
      }
#line 588
      if (channels[chan]) {
#line 591
        sample = (unsigned int )*(channels[chan]);
#line 596
        dl += *(channelleftvol_lookup[chan] + sample);
#line 597
        dr += *(channelrightvol_lookup[chan] + sample);
#line 599
        channelstepremainder[chan] += channelstep[chan];
#line 601
        channels[chan] += channelstepremainder[chan] >> 16;
#line 603
        channelstepremainder[chan] &= 65535U;
#line 606
        if ((unsigned long )channels[chan] >= (unsigned long )channelsend[chan]) {
#line 607
          channels[chan] = (unsigned char *)0;
        }
      }
#line 585
      chan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 617
    if (dl > 0x7fff) {
#line 618
      *leftout = (short)32767;
    } else
#line 619
    if (dl < -32768) {
#line 620
      *leftout = (short)-32768;
    } else {
#line 622
      *leftout = (short )dl;
    }
#line 625
    if (dr > 0x7fff) {
#line 626
      *rightout = (short)32767;
    } else
#line 627
    if (dr < -32768) {
#line 628
      *rightout = (short)-32768;
    } else {
#line 630
      *rightout = (short )dr;
    }
#line 633
    leftout += step;
#line 634
    rightout += step;
  }
  while_break: /* CIL Label */ ;
  }
#line 654
  return;
}
}
#line 665 "i_sound.c"
void I_SubmitSound(void) 
{ 


  {
#line 669
  write(audio_fd, (void const   *)(mixbuffer), (size_t )2048);
#line 670
  return;
}
}
#line 674 "i_sound.c"
void I_UpdateSoundParams(int handle , int vol , int sep , int pitch ) 
{ 


  {
#line 687
  pitch = 0;
#line 687
  sep = pitch;
#line 687
  vol = sep;
#line 687
  handle = vol;
#line 688
  return;
}
}
#line 693 "i_sound.c"
void I_ShutdownSound(void) 
{ 


  {
#line 696
  if (sndserver) {
#line 699
    fprintf((FILE * __restrict  )sndserver, (char const   * __restrict  )"q\n");
#line 700
    fflush(sndserver);
  }
#line 729
  return;
}
}
#line 737 "i_sound.c"
void I_InitSound(void) 
{ 
  char buffer___0[256] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 743
  tmp___0 = getenv((char const   *)"DOOMWADDIR");
#line 743
  if (tmp___0) {
#line 744
    tmp = getenv((char const   *)"DOOMWADDIR");
#line 744
    sprintf((char * __restrict  )(buffer___0), (char const   * __restrict  )"%s/%s",
            tmp, sndserver_filename);
  } else {
#line 748
    sprintf((char * __restrict  )(buffer___0), (char const   * __restrict  )"%s",
            sndserver_filename);
  }
#line 751
  tmp___1 = access((char const   *)(buffer___0), 1);
#line 751
  if (tmp___1) {
#line 757
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not start sound server [%s]\n",
            buffer___0);
  } else {
#line 753
    strcat((char * __restrict  )(buffer___0), (char const   * __restrict  )" -quiet");
#line 754
    sndserver = popen((char const   *)(buffer___0), (char const   *)"w");
  }
#line 825
  return;
}
}
#line 835 "i_sound.c"
void I_InitMusic(void) 
{ 


  {
#line 835
  return;
}
}
#line 836 "i_sound.c"
void I_ShutdownMusic(void) 
{ 


  {
#line 836
  return;
}
}
#line 838 "i_sound.c"
static int looping  =    0;
#line 839 "i_sound.c"
static int musicdies  =    -1;
#line 841 "i_sound.c"
void I_PlaySong(int handle , int looping___0 ) 
{ 


  {
#line 844
  looping___0 = 0;
#line 844
  handle = looping___0;
#line 845
  musicdies = gametic + 1050;
#line 846
  return;
}
}
#line 848 "i_sound.c"
void I_PauseSong(int handle ) 
{ 


  {
#line 851
  handle = 0;
#line 852
  return;
}
}
#line 854 "i_sound.c"
void I_ResumeSong(int handle ) 
{ 


  {
#line 857
  handle = 0;
#line 858
  return;
}
}
#line 860 "i_sound.c"
void I_StopSong(int handle ) 
{ 


  {
#line 863
  handle = 0;
#line 865
  looping = 0;
#line 866
  musicdies = 0;
#line 867
  return;
}
}
#line 869 "i_sound.c"
void I_UnRegisterSong(int handle ) 
{ 


  {
#line 872
  handle = 0;
#line 873
  return;
}
}
#line 875 "i_sound.c"
int I_RegisterSong(void *data ) 
{ 


  {
#line 878
  data = (void *)0;
#line 880
  return (1);
}
}
#line 884 "i_sound.c"
int I_QrySongPlaying(int handle ) 
{ 
  int tmp ;

  {
#line 887
  handle = 0;
#line 888
  if (looping) {
#line 888
    goto _L;
  } else
#line 888
  if (musicdies > gametic) {
    _L: /* CIL Label */ 
#line 888
    tmp = 1;
  } else {
#line 888
    tmp = 0;
  }
#line 888
  return (tmp);
}
}
#line 912 "i_sound.c"
static int itimer  =    0;
#line 914 "i_sound.c"
static int sig  =    14;
#line 917 "i_sound.c"
void I_HandleSoundTimer(int ignore ) 
{ 


  {
#line 923
  if (flag) {
#line 927
    write(audio_fd, (void const   *)(mixbuffer), (size_t )2048);
#line 930
    flag = 0;
  } else {
#line 933
    return;
  }
#line 936
  ignore = 0;
#line 937
  return;
}
}
#line 941 "i_sound.c"
int I_SoundSetTimer(int duration_of_tick ) 
{ 
  struct itimerval value ;
  struct itimerval ovalue ;
  struct sigaction act ;
  struct sigaction oact ;
  int res ;

  {
#line 955
  act.__sigaction_handler.sa_handler = & I_HandleSoundTimer;
#line 959
  act.sa_flags = 0x10000000;
#line 961
  sigaction(sig, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )(& oact));
#line 963
  value.it_interval.tv_sec = (__time_t )0;
#line 964
  value.it_interval.tv_usec = (__suseconds_t )duration_of_tick;
#line 965
  value.it_value.tv_sec = (__time_t )0;
#line 966
  value.it_value.tv_usec = (__suseconds_t )duration_of_tick;
#line 969
  res = setitimer(itimer, (struct itimerval  const  * __restrict  )(& value), (struct itimerval * __restrict  )(& ovalue));
#line 972
  if (res == -1) {
#line 973
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"I_SoundSetTimer: interrupt n.a.\n");
  }
#line 975
  return (res);
}
}
#line 980 "i_sound.c"
void I_SoundDelTimer(void) 
{ 
  int tmp ;

  {
#line 983
  tmp = I_SoundSetTimer(0);
#line 983
  if (tmp == -1) {
#line 984
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"I_SoundDelTimer: failed to remove interrupt. Doh!\n");
  }
#line 985
  return;
}
}
#line 24 "i_video.c"
static char const   rcsid___4[46]  = 
#line 24 "i_video.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'i',      (char const   )'_',      (char const   )'x', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'6', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )' ', 
        (char const   )'2',      (char const   )'2',      (char const   )':',      (char const   )'4', 
        (char const   )'5',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 50 "/usr/include/sys/ipc.h"
extern key_t ( __attribute__((__leaf__)) ftok)(char const   *__pathname , int __proj_id )  __attribute__((__nothrow__)) ;
#line 27 "/usr/include/bits/shmlba.h"
extern int ( __attribute__((__leaf__)) __getpagesize)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 50 "/usr/include/sys/shm.h"
extern int ( __attribute__((__leaf__)) shmctl)(int __shmid , int __cmd , struct shmid_ds *__buf )  __attribute__((__nothrow__)) ;
#line 62
extern int ( __attribute__((__leaf__)) shmget)(key_t __key , size_t __size , int __shmflg )  __attribute__((__nothrow__)) ;
#line 65
extern void *( __attribute__((__leaf__)) shmat)(int __shmid , void const   *__shmaddr ,
                                                int __shmflg )  __attribute__((__nothrow__)) ;
#line 69
extern int ( __attribute__((__leaf__)) shmdt)(void const   *__shmaddr )  __attribute__((__nothrow__)) ;
#line 62 "/usr/include/X11/Xlib.h"
extern int _Xmblen(char *str , int len ) ;
#line 1392
extern int _Xdebug ;
#line 1394
extern XFontStruct *XLoadQueryFont(Display * , char const   * ) ;
#line 1399
extern XFontStruct *XQueryFont(Display * , XID  ) ;
#line 1405
extern XTimeCoord *XGetMotionEvents(Display * , Window  , Time  , Time  , int * ) ;
#line 1413
extern XModifierKeymap *XDeleteModifiermapEntry(XModifierKeymap * , KeyCode  , int  ) ;
#line 1423
extern XModifierKeymap *XGetModifierMapping(Display * ) ;
#line 1427
extern XModifierKeymap *XInsertModifiermapEntry(XModifierKeymap * , KeyCode  , int  ) ;
#line 1437
extern XModifierKeymap *XNewModifiermap(int  ) ;
#line 1441
extern XImage *XCreateImage(Display * , Visual * , unsigned int  , int  , int  , char * ,
                            unsigned int  , unsigned int  , int  , int  ) ;
#line 1453
extern int XInitImage(XImage * ) ;
#line 1456
extern XImage *XGetImage(Display * , Drawable  , int  , int  , unsigned int  , unsigned int  ,
                         unsigned long  , int  ) ;
#line 1466
extern XImage *XGetSubImage(Display * , Drawable  , int  , int  , unsigned int  ,
                            unsigned int  , unsigned long  , int  , XImage * , int  ,
                            int  ) ;
#line 1483
extern Display *XOpenDisplay(char const   * ) ;
#line 1487
extern void XrmInitialize(void) ;
#line 1491
extern char *XFetchBytes(Display * , int * ) ;
#line 1495
extern char *XFetchBuffer(Display * , int * , int  ) ;
#line 1500
extern char *XGetAtomName(Display * , Atom  ) ;
#line 1504
extern int XGetAtomNames(Display * , Atom * , int  , char ** ) ;
#line 1510
extern char *XGetDefault(Display * , char const   * , char const   * ) ;
#line 1515
extern char *XDisplayName(char const   * ) ;
#line 1518
extern char *XKeysymToString(KeySym  ) ;
#line 1522
extern int (*XSynchronize(Display * , int  ))(Display * ) ;
#line 1528
extern int (*XSetAfterFunction(Display * , int (*)(Display * ) ))(Display * ) ;
#line 1536
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1541
extern int XInternAtoms(Display * , char ** , int  , int  , Atom * ) ;
#line 1548
extern Colormap XCopyColormapAndFree(Display * , Colormap  ) ;
#line 1552
extern Colormap XCreateColormap(Display * , Window  , Visual * , int  ) ;
#line 1558
extern Cursor XCreatePixmapCursor(Display * , Pixmap  , Pixmap  , XColor * , XColor * ,
                                  unsigned int  , unsigned int  ) ;
#line 1567
extern Cursor XCreateGlyphCursor(Display * , Font  , Font  , unsigned int  , unsigned int  ,
                                 XColor const   * , XColor const   * ) ;
#line 1576
extern Cursor XCreateFontCursor(Display * , unsigned int  ) ;
#line 1580
extern Font XLoadFont(Display * , char const   * ) ;
#line 1584
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1590
extern GContext XGContextFromGC(GC  ) ;
#line 1593
extern void XFlushGC(Display * , GC  ) ;
#line 1597
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 1604
extern Pixmap XCreateBitmapFromData(Display * , Drawable  , char const   * , unsigned int  ,
                                    unsigned int  ) ;
#line 1611
extern Pixmap XCreatePixmapFromBitmapData(Display * , Drawable  , char * , unsigned int  ,
                                          unsigned int  , unsigned long  , unsigned long  ,
                                          unsigned int  ) ;
#line 1621
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 1632
extern Window XGetSelectionOwner(Display * , Atom  ) ;
#line 1636
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 1650
extern Colormap *XListInstalledColormaps(Display * , Window  , int * ) ;
#line 1655
extern char **XListFonts(Display * , char const   * , int  , int * ) ;
#line 1661
extern char **XListFontsWithInfo(Display * , char const   * , int  , int * , XFontStruct ** ) ;
#line 1668
extern char **XGetFontPath(Display * , int * ) ;
#line 1672
extern char **XListExtensions(Display * , int * ) ;
#line 1676
extern Atom *XListProperties(Display * , Window  , int * ) ;
#line 1681
extern XHostAddress *XListHosts(Display * , int * , int * ) ;
#line 1686
extern KeySym __attribute__((__deprecated__))  XKeycodeToKeysym(Display * , KeyCode  ,
                                                                int  ) ;
#line 1696
extern KeySym XLookupKeysym(XKeyEvent * , int  ) ;
#line 1700
extern KeySym *XGetKeyboardMapping(Display * , KeyCode  , int  , int * ) ;
#line 1710
extern KeySym XStringToKeysym(char const   * ) ;
#line 1713
extern long XMaxRequestSize(Display * ) ;
#line 1716
extern long XExtendedMaxRequestSize(Display * ) ;
#line 1719
extern char *XResourceManagerString(Display * ) ;
#line 1722
extern char *XScreenResourceString(Screen * ) ;
#line 1725
extern unsigned long XDisplayMotionBufferSize(Display * ) ;
#line 1728
extern VisualID XVisualIDFromVisual(Visual * ) ;
#line 1734
extern int XInitThreads(void) ;
#line 1738
extern int XFreeThreads(void) ;
#line 1742
extern void XLockDisplay(Display * ) ;
#line 1746
extern void XUnlockDisplay(Display * ) ;
#line 1752
extern XExtCodes *XInitExtension(Display * , char const   * ) ;
#line 1757
extern XExtCodes *XAddExtension(Display * ) ;
#line 1760
extern XExtData *XFindOnExtensionList(XExtData ** , int  ) ;
#line 1764
extern XExtData **XEHeadOfExtensionList(XEDataObject  ) ;
#line 1769
extern Window XRootWindow(Display * , int  ) ;
#line 1773
extern Window XDefaultRootWindow(Display * ) ;
#line 1776
extern Window XRootWindowOfScreen(Screen * ) ;
#line 1779
extern Visual *XDefaultVisual(Display * , int  ) ;
#line 1783
extern Visual *XDefaultVisualOfScreen(Screen * ) ;
#line 1786
extern GC XDefaultGC(Display * , int  ) ;
#line 1790
extern GC XDefaultGCOfScreen(Screen * ) ;
#line 1793
extern unsigned long XBlackPixel(Display * , int  ) ;
#line 1797
extern unsigned long XWhitePixel(Display * , int  ) ;
#line 1801
extern unsigned long XAllPlanes(void) ;
#line 1804
extern unsigned long XBlackPixelOfScreen(Screen * ) ;
#line 1807
extern unsigned long XWhitePixelOfScreen(Screen * ) ;
#line 1810
extern unsigned long XNextRequest(Display * ) ;
#line 1813
extern unsigned long XLastKnownRequestProcessed(Display * ) ;
#line 1816
extern char *XServerVendor(Display * ) ;
#line 1819
extern char *XDisplayString(Display * ) ;
#line 1822
extern Colormap XDefaultColormap(Display * , int  ) ;
#line 1826
extern Colormap XDefaultColormapOfScreen(Screen * ) ;
#line 1829
extern Display *XDisplayOfScreen(Screen * ) ;
#line 1832
extern Screen *XScreenOfDisplay(Display * , int  ) ;
#line 1836
extern Screen *XDefaultScreenOfDisplay(Display * ) ;
#line 1839
extern long XEventMaskOfScreen(Screen * ) ;
#line 1843
extern int XScreenNumberOfScreen(Screen * ) ;
#line 1852
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 1861
extern XIOErrorHandler XSetIOErrorHandler(int (*)(Display * ) ) ;
#line 1870
extern void XSetIOErrorExitHandler(Display * , void (*)(Display * , void * ) , void * ) ;
#line 1876
extern XPixmapFormatValues *XListPixmapFormats(Display * , int * ) ;
#line 1880
extern int *XListDepths(Display * , int  , int * ) ;
#line 1888
extern int XReconfigureWMWindow(Display * , Window  , int  , unsigned int  , XWindowChanges * ) ;
#line 1896
extern int XGetWMProtocols(Display * , Window  , Atom ** , int * ) ;
#line 1902
extern int XSetWMProtocols(Display * , Window  , Atom * , int  ) ;
#line 1908
extern int XIconifyWindow(Display * , Window  , int  ) ;
#line 1913
extern int XWithdrawWindow(Display * , Window  , int  ) ;
#line 1918
extern int XGetCommand(Display * , Window  , char *** , int * ) ;
#line 1924
extern int XGetWMColormapWindows(Display * , Window  , Window ** , int * ) ;
#line 1930
extern int XSetWMColormapWindows(Display * , Window  , Window * , int  ) ;
#line 1936
extern void XFreeStringList(char ** ) ;
#line 1939
extern int XSetTransientForHint(Display * , Window  , Window  ) ;
#line 1947
extern int XActivateScreenSaver(Display * ) ;
#line 1951
extern int XAddHost(Display * , XHostAddress * ) ;
#line 1956
extern int XAddHosts(Display * , XHostAddress * , int  ) ;
#line 1962
extern int XAddToExtensionList(struct _XExtData ** , XExtData * ) ;
#line 1967
extern int XAddToSaveSet(Display * , Window  ) ;
#line 1972
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 1978
extern int XAllocColorCells(Display * , Colormap  , int  , unsigned long * , unsigned int  ,
                            unsigned long * , unsigned int  ) ;
#line 1988
extern int XAllocColorPlanes(Display * , Colormap  , int  , unsigned long * , int  ,
                             int  , int  , int  , unsigned long * , unsigned long * ,
                             unsigned long * ) ;
#line 2002
extern int XAllocNamedColor(Display * , Colormap  , char const   * , XColor * , XColor * ) ;
#line 2010
extern int XAllowEvents(Display * , int  , Time  ) ;
#line 2016
extern int XAutoRepeatOff(Display * ) ;
#line 2020
extern int XAutoRepeatOn(Display * ) ;
#line 2024
extern int XBell(Display * , int  ) ;
#line 2029
extern int XBitmapBitOrder(Display * ) ;
#line 2033
extern int XBitmapPad(Display * ) ;
#line 2037
extern int XBitmapUnit(Display * ) ;
#line 2041
extern int XCellsOfScreen(Screen * ) ;
#line 2045
extern int XChangeActivePointerGrab(Display * , unsigned int  , Cursor  , Time  ) ;
#line 2052
extern int XChangeGC(Display * , GC  , unsigned long  , XGCValues * ) ;
#line 2059
extern int XChangeKeyboardControl(Display * , unsigned long  , XKeyboardControl * ) ;
#line 2065
extern int XChangeKeyboardMapping(Display * , int  , int  , KeySym * , int  ) ;
#line 2073
extern int XChangePointerControl(Display * , int  , int  , int  , int  , int  ) ;
#line 2082
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 2093
extern int XChangeSaveSet(Display * , Window  , int  ) ;
#line 2099
extern int XChangeWindowAttributes(Display * , Window  , unsigned long  , XSetWindowAttributes * ) ;
#line 2106
extern int XCheckIfEvent(Display * , XEvent * , int (*)(Display * , XEvent * , XPointer  ) ,
                         XPointer  ) ;
#line 2117
extern int XCheckMaskEvent(Display * , long  , XEvent * ) ;
#line 2123
extern int XCheckTypedEvent(Display * , int  , XEvent * ) ;
#line 2129
extern int XCheckTypedWindowEvent(Display * , Window  , int  , XEvent * ) ;
#line 2136
extern int XCheckWindowEvent(Display * , Window  , long  , XEvent * ) ;
#line 2143
extern int XCirculateSubwindows(Display * , Window  , int  ) ;
#line 2149
extern int XCirculateSubwindowsDown(Display * , Window  ) ;
#line 2154
extern int XCirculateSubwindowsUp(Display * , Window  ) ;
#line 2159
extern int XClearArea(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                      int  ) ;
#line 2169
extern int XClearWindow(Display * , Window  ) ;
#line 2174
extern int XCloseDisplay(Display * ) ;
#line 2178
extern int XConfigureWindow(Display * , Window  , unsigned int  , XWindowChanges * ) ;
#line 2185
extern int XConnectionNumber(Display * ) ;
#line 2189
extern int XConvertSelection(Display * , Atom  , Atom  , Atom  , Window  , Time  ) ;
#line 2198
extern int XCopyArea(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                     unsigned int  , int  , int  ) ;
#line 2211
extern int XCopyGC(Display * , GC  , unsigned long  , GC  ) ;
#line 2218
extern int XCopyPlane(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                      unsigned int  , int  , int  , unsigned long  ) ;
#line 2232
extern int XDefaultDepth(Display * , int  ) ;
#line 2237
extern int XDefaultDepthOfScreen(Screen * ) ;
#line 2241
extern int XDefaultScreen(Display * ) ;
#line 2245
extern int XDefineCursor(Display * , Window  , Cursor  ) ;
#line 2251
extern int XDeleteProperty(Display * , Window  , Atom  ) ;
#line 2257
extern int XDestroyWindow(Display * , Window  ) ;
#line 2262
extern int XDestroySubwindows(Display * , Window  ) ;
#line 2267
extern int XDoesBackingStore(Screen * ) ;
#line 2271
extern int XDoesSaveUnders(Screen * ) ;
#line 2275
extern int XDisableAccessControl(Display * ) ;
#line 2280
extern int XDisplayCells(Display * , int  ) ;
#line 2285
extern int XDisplayHeight(Display * , int  ) ;
#line 2290
extern int XDisplayHeightMM(Display * , int  ) ;
#line 2295
extern int XDisplayKeycodes(Display * , int * , int * ) ;
#line 2301
extern int XDisplayPlanes(Display * , int  ) ;
#line 2306
extern int XDisplayWidth(Display * , int  ) ;
#line 2311
extern int XDisplayWidthMM(Display * , int  ) ;
#line 2316
extern int XDrawArc(Display * , Drawable  , GC  , int  , int  , unsigned int  , unsigned int  ,
                    int  , int  ) ;
#line 2328
extern int XDrawArcs(Display * , Drawable  , GC  , XArc * , int  ) ;
#line 2336
extern int XDrawImageString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                            int  ) ;
#line 2346
extern int XDrawImageString16(Display * , Drawable  , GC  , int  , int  , XChar2b const   * ,
                              int  ) ;
#line 2356
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2366
extern int XDrawLines(Display * , Drawable  , GC  , XPoint * , int  , int  ) ;
#line 2375
extern int XDrawPoint(Display * , Drawable  , GC  , int  , int  ) ;
#line 2383
extern int XDrawPoints(Display * , Drawable  , GC  , XPoint * , int  , int  ) ;
#line 2392
extern int XDrawRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2402
extern int XDrawRectangles(Display * , Drawable  , GC  , XRectangle * , int  ) ;
#line 2410
extern int XDrawSegments(Display * , Drawable  , GC  , XSegment * , int  ) ;
#line 2418
extern int XDrawString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                       int  ) ;
#line 2428
extern int XDrawString16(Display * , Drawable  , GC  , int  , int  , XChar2b const   * ,
                         int  ) ;
#line 2438
extern int XDrawText(Display * , Drawable  , GC  , int  , int  , XTextItem * , int  ) ;
#line 2448
extern int XDrawText16(Display * , Drawable  , GC  , int  , int  , XTextItem16 * ,
                       int  ) ;
#line 2458
extern int XEnableAccessControl(Display * ) ;
#line 2462
extern int XEventsQueued(Display * , int  ) ;
#line 2467
extern int XFetchName(Display * , Window  , char ** ) ;
#line 2473
extern int XFillArc(Display * , Drawable  , GC  , int  , int  , unsigned int  , unsigned int  ,
                    int  , int  ) ;
#line 2485
extern int XFillArcs(Display * , Drawable  , GC  , XArc * , int  ) ;
#line 2493
extern int XFillPolygon(Display * , Drawable  , GC  , XPoint * , int  , int  , int  ) ;
#line 2503
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2513
extern int XFillRectangles(Display * , Drawable  , GC  , XRectangle * , int  ) ;
#line 2521
extern int XFlush(Display * ) ;
#line 2525
extern int XForceScreenSaver(Display * , int  ) ;
#line 2530
extern int XFree(void * ) ;
#line 2534
extern int XFreeColormap(Display * , Colormap  ) ;
#line 2539
extern int XFreeColors(Display * , Colormap  , unsigned long * , int  , unsigned long  ) ;
#line 2547
extern int XFreeCursor(Display * , Cursor  ) ;
#line 2552
extern int XFreeExtensionList(char ** ) ;
#line 2556
extern int XFreeFont(Display * , XFontStruct * ) ;
#line 2561
extern int XFreeFontInfo(char ** , XFontStruct * , int  ) ;
#line 2567
extern int XFreeFontNames(char ** ) ;
#line 2571
extern int XFreeFontPath(char ** ) ;
#line 2575
extern int XFreeGC(Display * , GC  ) ;
#line 2580
extern int XFreeModifiermap(XModifierKeymap * ) ;
#line 2584
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 2589
extern int XGeometry(Display * , int  , char const   * , char const   * , unsigned int  ,
                     unsigned int  , unsigned int  , int  , int  , int * , int * ,
                     int * , int * ) ;
#line 2605
extern int XGetErrorDatabaseText(Display * , char const   * , char const   * , char const   * ,
                                 char * , int  ) ;
#line 2614
extern int XGetErrorText(Display * , int  , char * , int  ) ;
#line 2621
extern int XGetFontProperty(XFontStruct * , Atom  , unsigned long * ) ;
#line 2627
extern int XGetGCValues(Display * , GC  , unsigned long  , XGCValues * ) ;
#line 2634
extern int XGetGeometry(Display * , Drawable  , Window * , int * , int * , unsigned int * ,
                        unsigned int * , unsigned int * , unsigned int * ) ;
#line 2646
extern int XGetIconName(Display * , Window  , char ** ) ;
#line 2652
extern int XGetInputFocus(Display * , Window * , int * ) ;
#line 2658
extern int XGetKeyboardControl(Display * , XKeyboardState * ) ;
#line 2663
extern int XGetPointerControl(Display * , int * , int * , int * ) ;
#line 2670
extern int XGetPointerMapping(Display * , unsigned char * , int  ) ;
#line 2676
extern int XGetScreenSaver(Display * , int * , int * , int * , int * ) ;
#line 2684
extern int XGetTransientForHint(Display * , Window  , Window * ) ;
#line 2690
extern int XGetWindowProperty(Display * , Window  , Atom  , long  , long  , int  ,
                              Atom  , Atom * , int * , unsigned long * , unsigned long * ,
                              unsigned char ** ) ;
#line 2705
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 2711
extern int XGrabButton(Display * , unsigned int  , unsigned int  , Window  , int  ,
                       unsigned int  , int  , int  , Window  , Cursor  ) ;
#line 2724
extern int XGrabKey(Display * , int  , unsigned int  , Window  , int  , int  , int  ) ;
#line 2734
extern int XGrabKeyboard(Display * , Window  , int  , int  , int  , Time  ) ;
#line 2743
extern int XGrabPointer(Display * , Window  , int  , unsigned int  , int  , int  ,
                        Window  , Cursor  , Time  ) ;
#line 2755
extern int XGrabServer(Display * ) ;
#line 2759
extern int XHeightMMOfScreen(Screen * ) ;
#line 2763
extern int XHeightOfScreen(Screen * ) ;
#line 2767
extern int XIfEvent(Display * , XEvent * , int (*)(Display * , XEvent * , XPointer  ) ,
                    XPointer  ) ;
#line 2778
extern int XImageByteOrder(Display * ) ;
#line 2782
extern int XInstallColormap(Display * , Colormap  ) ;
#line 2787
extern KeyCode XKeysymToKeycode(Display * , KeySym  ) ;
#line 2792
extern int XKillClient(Display * , XID  ) ;
#line 2797
extern int XLookupColor(Display * , Colormap  , char const   * , XColor * , XColor * ) ;
#line 2805
extern int XLowerWindow(Display * , Window  ) ;
#line 2810
extern int XMapRaised(Display * , Window  ) ;
#line 2815
extern int XMapSubwindows(Display * , Window  ) ;
#line 2820
extern int XMapWindow(Display * , Window  ) ;
#line 2825
extern int XMaskEvent(Display * , long  , XEvent * ) ;
#line 2831
extern int XMaxCmapsOfScreen(Screen * ) ;
#line 2835
extern int XMinCmapsOfScreen(Screen * ) ;
#line 2839
extern int XMoveResizeWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ) ;
#line 2848
extern int XMoveWindow(Display * , Window  , int  , int  ) ;
#line 2855
extern int XNextEvent(Display * , XEvent * ) ;
#line 2860
extern int XNoOp(Display * ) ;
#line 2864
extern int XParseColor(Display * , Colormap  , char const   * , XColor * ) ;
#line 2871
extern int XParseGeometry(char const   * , int * , int * , unsigned int * , unsigned int * ) ;
#line 2879
extern int XPeekEvent(Display * , XEvent * ) ;
#line 2884
extern int XPeekIfEvent(Display * , XEvent * , int (*)(Display * , XEvent * , XPointer  ) ,
                        XPointer  ) ;
#line 2895
extern int XPending(Display * ) ;
#line 2899
extern int XPlanesOfScreen(Screen * ) ;
#line 2903
extern int XProtocolRevision(Display * ) ;
#line 2907
extern int XProtocolVersion(Display * ) ;
#line 2912
extern int XPutBackEvent(Display * , XEvent * ) ;
#line 2917
extern int XPutImage(Display * , Drawable  , GC  , XImage * , int  , int  , int  ,
                     int  , unsigned int  , unsigned int  ) ;
#line 2930
extern int XQLength(Display * ) ;
#line 2934
extern int XQueryBestCursor(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int * , unsigned int * ) ;
#line 2943
extern int XQueryBestSize(Display * , int  , Drawable  , unsigned int  , unsigned int  ,
                          unsigned int * , unsigned int * ) ;
#line 2953
extern int XQueryBestStipple(Display * , Drawable  , unsigned int  , unsigned int  ,
                             unsigned int * , unsigned int * ) ;
#line 2962
extern int XQueryBestTile(Display * , Drawable  , unsigned int  , unsigned int  ,
                          unsigned int * , unsigned int * ) ;
#line 2971
extern int XQueryColor(Display * , Colormap  , XColor * ) ;
#line 2977
extern int XQueryColors(Display * , Colormap  , XColor * , int  ) ;
#line 2984
extern int XQueryExtension(Display * , char const   * , int * , int * , int * ) ;
#line 2992
extern int XQueryKeymap(Display * , char * ) ;
#line 2997
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
#line 3009
extern int XQueryTextExtents(Display * , XID  , char const   * , int  , int * , int * ,
                             int * , XCharStruct * ) ;
#line 3020
extern int XQueryTextExtents16(Display * , XID  , XChar2b const   * , int  , int * ,
                               int * , int * , XCharStruct * ) ;
#line 3031
extern int XQueryTree(Display * , Window  , Window * , Window * , Window ** , unsigned int * ) ;
#line 3040
extern int XRaiseWindow(Display * , Window  ) ;
#line 3045
extern int XReadBitmapFile(Display * , Drawable  , char const   * , unsigned int * ,
                           unsigned int * , Pixmap * , int * , int * ) ;
#line 3056
extern int XReadBitmapFileData(char const   * , unsigned int * , unsigned int * ,
                               unsigned char ** , int * , int * ) ;
#line 3065
extern int XRebindKeysym(Display * , KeySym  , KeySym * , int  , unsigned char const   * ,
                         int  ) ;
#line 3074
extern int XRecolorCursor(Display * , Cursor  , XColor * , XColor * ) ;
#line 3081
extern int XRefreshKeyboardMapping(XMappingEvent * ) ;
#line 3085
extern int XRemoveFromSaveSet(Display * , Window  ) ;
#line 3090
extern int XRemoveHost(Display * , XHostAddress * ) ;
#line 3095
extern int XRemoveHosts(Display * , XHostAddress * , int  ) ;
#line 3101
extern int XReparentWindow(Display * , Window  , Window  , int  , int  ) ;
#line 3109
extern int XResetScreenSaver(Display * ) ;
#line 3113
extern int XResizeWindow(Display * , Window  , unsigned int  , unsigned int  ) ;
#line 3120
extern int XRestackWindows(Display * , Window * , int  ) ;
#line 3126
extern int XRotateBuffers(Display * , int  ) ;
#line 3131
extern int XRotateWindowProperties(Display * , Window  , Atom * , int  , int  ) ;
#line 3139
extern int XScreenCount(Display * ) ;
#line 3143
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3149
extern int XSendEvent(Display * , Window  , int  , long  , XEvent * ) ;
#line 3157
extern int XSetAccessControl(Display * , int  ) ;
#line 3162
extern int XSetArcMode(Display * , GC  , int  ) ;
#line 3168
extern int XSetBackground(Display * , GC  , unsigned long  ) ;
#line 3174
extern int XSetClipMask(Display * , GC  , Pixmap  ) ;
#line 3180
extern int XSetClipOrigin(Display * , GC  , int  , int  ) ;
#line 3187
extern int XSetClipRectangles(Display * , GC  , int  , int  , XRectangle * , int  ,
                              int  ) ;
#line 3197
extern int XSetCloseDownMode(Display * , int  ) ;
#line 3202
extern int XSetCommand(Display * , Window  , char ** , int  ) ;
#line 3209
extern int XSetDashes(Display * , GC  , int  , char const   * , int  ) ;
#line 3217
extern int XSetFillRule(Display * , GC  , int  ) ;
#line 3223
extern int XSetFillStyle(Display * , GC  , int  ) ;
#line 3229
extern int XSetFont(Display * , GC  , Font  ) ;
#line 3235
extern int XSetFontPath(Display * , char ** , int  ) ;
#line 3241
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 3247
extern int XSetFunction(Display * , GC  , int  ) ;
#line 3253
extern int XSetGraphicsExposures(Display * , GC  , int  ) ;
#line 3259
extern int XSetIconName(Display * , Window  , char const   * ) ;
#line 3265
extern int XSetInputFocus(Display * , Window  , int  , Time  ) ;
#line 3272
extern int XSetLineAttributes(Display * , GC  , unsigned int  , int  , int  , int  ) ;
#line 3281
extern int XSetModifierMapping(Display * , XModifierKeymap * ) ;
#line 3286
extern int XSetPlaneMask(Display * , GC  , unsigned long  ) ;
#line 3292
extern int XSetPointerMapping(Display * , unsigned char const   * , int  ) ;
#line 3298
extern int XSetScreenSaver(Display * , int  , int  , int  , int  ) ;
#line 3306
extern int XSetSelectionOwner(Display * , Atom  , Window  , Time  ) ;
#line 3313
extern int XSetState(Display * , GC  , unsigned long  , unsigned long  , int  , unsigned long  ) ;
#line 3322
extern int XSetStipple(Display * , GC  , Pixmap  ) ;
#line 3328
extern int XSetSubwindowMode(Display * , GC  , int  ) ;
#line 3334
extern int XSetTSOrigin(Display * , GC  , int  , int  ) ;
#line 3341
extern int XSetTile(Display * , GC  , Pixmap  ) ;
#line 3347
extern int XSetWindowBackground(Display * , Window  , unsigned long  ) ;
#line 3353
extern int XSetWindowBackgroundPixmap(Display * , Window  , Pixmap  ) ;
#line 3359
extern int XSetWindowBorder(Display * , Window  , unsigned long  ) ;
#line 3365
extern int XSetWindowBorderPixmap(Display * , Window  , Pixmap  ) ;
#line 3371
extern int XSetWindowBorderWidth(Display * , Window  , unsigned int  ) ;
#line 3377
extern int XSetWindowColormap(Display * , Window  , Colormap  ) ;
#line 3383
extern int XStoreBuffer(Display * , char const   * , int  , int  ) ;
#line 3390
extern int XStoreBytes(Display * , char const   * , int  ) ;
#line 3396
extern int XStoreColor(Display * , Colormap  , XColor * ) ;
#line 3402
extern int XStoreColors(Display * , Colormap  , XColor * , int  ) ;
#line 3409
extern int XStoreName(Display * , Window  , char const   * ) ;
#line 3415
extern int XStoreNamedColor(Display * , Colormap  , char const   * , unsigned long  ,
                            int  ) ;
#line 3423
extern int XSync(Display * , int  ) ;
#line 3428
extern int XTextExtents(XFontStruct * , char const   * , int  , int * , int * , int * ,
                        XCharStruct * ) ;
#line 3438
extern int XTextExtents16(XFontStruct * , XChar2b const   * , int  , int * , int * ,
                          int * , XCharStruct * ) ;
#line 3448
extern int XTextWidth(XFontStruct * , char const   * , int  ) ;
#line 3454
extern int XTextWidth16(XFontStruct * , XChar2b const   * , int  ) ;
#line 3460
extern int XTranslateCoordinates(Display * , Window  , Window  , int  , int  , int * ,
                                 int * , Window * ) ;
#line 3471
extern int XUndefineCursor(Display * , Window  ) ;
#line 3476
extern int XUngrabButton(Display * , unsigned int  , unsigned int  , Window  ) ;
#line 3483
extern int XUngrabKey(Display * , int  , unsigned int  , Window  ) ;
#line 3490
extern int XUngrabKeyboard(Display * , Time  ) ;
#line 3495
extern int XUngrabPointer(Display * , Time  ) ;
#line 3500
extern int XUngrabServer(Display * ) ;
#line 3504
extern int XUninstallColormap(Display * , Colormap  ) ;
#line 3509
extern int XUnloadFont(Display * , Font  ) ;
#line 3514
extern int XUnmapSubwindows(Display * , Window  ) ;
#line 3519
extern int XUnmapWindow(Display * , Window  ) ;
#line 3524
extern int XVendorRelease(Display * ) ;
#line 3528
extern int XWarpPointer(Display * , Window  , Window  , int  , int  , unsigned int  ,
                        unsigned int  , int  , int  ) ;
#line 3540
extern int XWidthMMOfScreen(Screen * ) ;
#line 3544
extern int XWidthOfScreen(Screen * ) ;
#line 3548
extern int XWindowEvent(Display * , Window  , long  , XEvent * ) ;
#line 3555
extern int XWriteBitmapFile(Display * , char const   * , Pixmap  , unsigned int  ,
                            unsigned int  , int  , int  ) ;
#line 3565
extern int XSupportsLocale(void) ;
#line 3567
extern char *XSetLocaleModifiers(char const   * ) ;
#line 3571
extern XOM XOpenOM(Display * , struct _XrmHashBucketRec * , char const   * , char const   * ) ;
#line 3578
extern int XCloseOM(XOM  ) ;
#line 3582
extern char *XSetOMValues(XOM   , ...)  __attribute__((__sentinel__(0))) ;
#line 3587
extern char *XGetOMValues(XOM   , ...)  __attribute__((__sentinel__(0))) ;
#line 3592
extern Display *XDisplayOfOM(XOM  ) ;
#line 3596
extern char *XLocaleOfOM(XOM  ) ;
#line 3600
extern XOC XCreateOC(XOM   , ...)  __attribute__((__sentinel__(0))) ;
#line 3605
extern void XDestroyOC(XOC  ) ;
#line 3609
extern XOM XOMOfOC(XOC  ) ;
#line 3613
extern char *XSetOCValues(XOC   , ...)  __attribute__((__sentinel__(0))) ;
#line 3618
extern char *XGetOCValues(XOC   , ...)  __attribute__((__sentinel__(0))) ;
#line 3623
extern XFontSet XCreateFontSet(Display * , char const   * , char *** , int * , char ** ) ;
#line 3631
extern void XFreeFontSet(Display * , XFontSet  ) ;
#line 3636
extern int XFontsOfFontSet(XFontSet  , XFontStruct *** , char *** ) ;
#line 3642
extern char *XBaseFontNameListOfFontSet(XFontSet  ) ;
#line 3646
extern char *XLocaleOfFontSet(XFontSet  ) ;
#line 3650
extern int XContextDependentDrawing(XFontSet  ) ;
#line 3654
extern int XDirectionalDependentDrawing(XFontSet  ) ;
#line 3658
extern int XContextualDrawing(XFontSet  ) ;
#line 3662
extern XFontSetExtents *XExtentsOfFontSet(XFontSet  ) ;
#line 3666
extern int XmbTextEscapement(XFontSet  , char const   * , int  ) ;
#line 3672
extern int XwcTextEscapement(XFontSet  , wchar_t const   * , int  ) ;
#line 3678
extern int Xutf8TextEscapement(XFontSet  , char const   * , int  ) ;
#line 3684
extern int XmbTextExtents(XFontSet  , char const   * , int  , XRectangle * , XRectangle * ) ;
#line 3692
extern int XwcTextExtents(XFontSet  , wchar_t const   * , int  , XRectangle * , XRectangle * ) ;
#line 3700
extern int Xutf8TextExtents(XFontSet  , char const   * , int  , XRectangle * , XRectangle * ) ;
#line 3708
extern int XmbTextPerCharExtents(XFontSet  , char const   * , int  , XRectangle * ,
                                 XRectangle * , int  , int * , XRectangle * , XRectangle * ) ;
#line 3720
extern int XwcTextPerCharExtents(XFontSet  , wchar_t const   * , int  , XRectangle * ,
                                 XRectangle * , int  , int * , XRectangle * , XRectangle * ) ;
#line 3732
extern int Xutf8TextPerCharExtents(XFontSet  , char const   * , int  , XRectangle * ,
                                   XRectangle * , int  , int * , XRectangle * , XRectangle * ) ;
#line 3744
extern void XmbDrawText(Display * , Drawable  , GC  , int  , int  , XmbTextItem * ,
                        int  ) ;
#line 3754
extern void XwcDrawText(Display * , Drawable  , GC  , int  , int  , XwcTextItem * ,
                        int  ) ;
#line 3764
extern void Xutf8DrawText(Display * , Drawable  , GC  , int  , int  , XmbTextItem * ,
                          int  ) ;
#line 3774
extern void XmbDrawString(Display * , Drawable  , XFontSet  , GC  , int  , int  ,
                          char const   * , int  ) ;
#line 3785
extern void XwcDrawString(Display * , Drawable  , XFontSet  , GC  , int  , int  ,
                          wchar_t const   * , int  ) ;
#line 3796
extern void Xutf8DrawString(Display * , Drawable  , XFontSet  , GC  , int  , int  ,
                            char const   * , int  ) ;
#line 3807
extern void XmbDrawImageString(Display * , Drawable  , XFontSet  , GC  , int  , int  ,
                               char const   * , int  ) ;
#line 3818
extern void XwcDrawImageString(Display * , Drawable  , XFontSet  , GC  , int  , int  ,
                               wchar_t const   * , int  ) ;
#line 3829
extern void Xutf8DrawImageString(Display * , Drawable  , XFontSet  , GC  , int  ,
                                 int  , char const   * , int  ) ;
#line 3840
extern XIM XOpenIM(Display * , struct _XrmHashBucketRec * , char * , char * ) ;
#line 3847
extern int XCloseIM(XIM  ) ;
#line 3851
extern char *XGetIMValues(XIM   , ...)  __attribute__((__sentinel__(0))) ;
#line 3855
extern char *XSetIMValues(XIM   , ...)  __attribute__((__sentinel__(0))) ;
#line 3859
extern Display *XDisplayOfIM(XIM  ) ;
#line 3863
extern char *XLocaleOfIM(XIM  ) ;
#line 3867
extern XIC XCreateIC(XIM   , ...)  __attribute__((__sentinel__(0))) ;
#line 3871
extern void XDestroyIC(XIC  ) ;
#line 3875
extern void XSetICFocus(XIC  ) ;
#line 3879
extern void XUnsetICFocus(XIC  ) ;
#line 3883
extern wchar_t *XwcResetIC(XIC  ) ;
#line 3887
extern char *XmbResetIC(XIC  ) ;
#line 3891
extern char *Xutf8ResetIC(XIC  ) ;
#line 3895
extern char *XSetICValues(XIC   , ...)  __attribute__((__sentinel__(0))) ;
#line 3899
extern char *XGetICValues(XIC   , ...)  __attribute__((__sentinel__(0))) ;
#line 3903
extern XIM XIMOfIC(XIC  ) ;
#line 3907
extern int XFilterEvent(XEvent * , Window  ) ;
#line 3912
extern int XmbLookupString(XIC  , XKeyPressedEvent * , char * , int  , KeySym * ,
                           int * ) ;
#line 3921
extern int XwcLookupString(XIC  , XKeyPressedEvent * , wchar_t * , int  , KeySym * ,
                           int * ) ;
#line 3930
extern int Xutf8LookupString(XIC  , XKeyPressedEvent * , char * , int  , KeySym * ,
                             int * ) ;
#line 3939
extern XVaNestedList XVaCreateNestedList(int   , ...)  __attribute__((__sentinel__(0))) ;
#line 3945
extern int XRegisterIMInstantiateCallback(Display * , struct _XrmHashBucketRec * ,
                                          char * , char * , void (*)(Display * , XPointer  ,
                                                                     XPointer  ) ,
                                          XPointer  ) ;
#line 3954
extern int XUnregisterIMInstantiateCallback(Display * , struct _XrmHashBucketRec * ,
                                            char * , char * , void (*)(Display * ,
                                                                       XPointer  ,
                                                                       XPointer  ) ,
                                            XPointer  ) ;
#line 3972
extern int XInternalConnectionNumbers(Display * , int ** , int * ) ;
#line 3978
extern void XProcessInternalConnection(Display * , int  ) ;
#line 3983
extern int XAddConnectionWatch(Display * , void (*)(Display * , XPointer  , int  ,
                                                    int  , XPointer * ) , XPointer  ) ;
#line 3989
extern void XRemoveConnectionWatch(Display * , void (*)(Display * , XPointer  , int  ,
                                                        int  , XPointer * ) , XPointer  ) ;
#line 3995
extern void XSetAuthorization(char * , int  , char * , int  ) ;
#line 4002
extern int _Xmbtowc(wchar_t * , char * , int  ) ;
#line 4008
extern int _Xwctomb(char * , wchar_t  ) ;
#line 4013
extern int XGetEventData(Display * , XGenericEventCookie * ) ;
#line 4018
extern void XFreeEventData(Display * , XGenericEventCookie * ) ;
#line 366 "/usr/include/X11/Xutil.h"
extern XClassHint *XAllocClassHint(void) ;
#line 370
extern XIconSize *XAllocIconSize(void) ;
#line 374
extern XSizeHints *XAllocSizeHints(void) ;
#line 378
extern XStandardColormap *XAllocStandardColormap(void) ;
#line 382
extern XWMHints *XAllocWMHints(void) ;
#line 386
extern int XClipBox(Region  , XRectangle * ) ;
#line 391
extern Region XCreateRegion(void) ;
#line 395
extern char const   *XDefaultString(void) ;
#line 397
extern int XDeleteContext(Display * , XID  , XContext  ) ;
#line 403
extern int XDestroyRegion(Region  ) ;
#line 407
extern int XEmptyRegion(Region  ) ;
#line 411
extern int XEqualRegion(Region  , Region  ) ;
#line 416
extern int XFindContext(Display * , XID  , XContext  , XPointer * ) ;
#line 423
extern int XGetClassHint(Display * , Window  , XClassHint * ) ;
#line 429
extern int XGetIconSizes(Display * , Window  , XIconSize ** , int * ) ;
#line 436
extern int XGetNormalHints(Display * , Window  , XSizeHints * ) ;
#line 442
extern int XGetRGBColormaps(Display * , Window  , XStandardColormap ** , int * , Atom  ) ;
#line 450
extern int XGetSizeHints(Display * , Window  , XSizeHints * , Atom  ) ;
#line 457
extern int XGetStandardColormap(Display * , Window  , XStandardColormap * , Atom  ) ;
#line 464
extern int XGetTextProperty(Display * , Window  , XTextProperty * , Atom  ) ;
#line 471
extern XVisualInfo *XGetVisualInfo(Display * , long  , XVisualInfo * , int * ) ;
#line 478
extern int XGetWMClientMachine(Display * , Window  , XTextProperty * ) ;
#line 484
extern XWMHints *XGetWMHints(Display * , Window  ) ;
#line 489
extern int XGetWMIconName(Display * , Window  , XTextProperty * ) ;
#line 495
extern int XGetWMName(Display * , Window  , XTextProperty * ) ;
#line 501
extern int XGetWMNormalHints(Display * , Window  , XSizeHints * , long * ) ;
#line 508
extern int XGetWMSizeHints(Display * , Window  , XSizeHints * , long * , Atom  ) ;
#line 516
extern int XGetZoomHints(Display * , Window  , XSizeHints * ) ;
#line 522
extern int XIntersectRegion(Region  , Region  , Region  ) ;
#line 528
extern void XConvertCase(KeySym  , KeySym * , KeySym * ) ;
#line 534
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 542
extern int XMatchVisualInfo(Display * , int  , int  , int  , XVisualInfo * ) ;
#line 550
extern int XOffsetRegion(Region  , int  , int  ) ;
#line 556
extern int XPointInRegion(Region  , int  , int  ) ;
#line 562
extern Region XPolygonRegion(XPoint * , int  , int  ) ;
#line 568
extern int XRectInRegion(Region  , int  , int  , unsigned int  , unsigned int  ) ;
#line 576
extern int XSaveContext(Display * , XID  , XContext  , char const   * ) ;
#line 583
extern int XSetClassHint(Display * , Window  , XClassHint * ) ;
#line 589
extern int XSetIconSizes(Display * , Window  , XIconSize * , int  ) ;
#line 596
extern int XSetNormalHints(Display * , Window  , XSizeHints * ) ;
#line 602
extern void XSetRGBColormaps(Display * , Window  , XStandardColormap * , int  , Atom  ) ;
#line 610
extern int XSetSizeHints(Display * , Window  , XSizeHints * , Atom  ) ;
#line 617
extern int XSetStandardProperties(Display * , Window  , char const   * , char const   * ,
                                  Pixmap  , char ** , int  , XSizeHints * ) ;
#line 628
extern void XSetTextProperty(Display * , Window  , XTextProperty * , Atom  ) ;
#line 635
extern void XSetWMClientMachine(Display * , Window  , XTextProperty * ) ;
#line 641
extern int XSetWMHints(Display * , Window  , XWMHints * ) ;
#line 647
extern void XSetWMIconName(Display * , Window  , XTextProperty * ) ;
#line 653
extern void XSetWMName(Display * , Window  , XTextProperty * ) ;
#line 659
extern void XSetWMNormalHints(Display * , Window  , XSizeHints * ) ;
#line 665
extern void XSetWMProperties(Display * , Window  , XTextProperty * , XTextProperty * ,
                             char ** , int  , XSizeHints * , XWMHints * , XClassHint * ) ;
#line 677
extern void XmbSetWMProperties(Display * , Window  , char const   * , char const   * ,
                               char ** , int  , XSizeHints * , XWMHints * , XClassHint * ) ;
#line 689
extern void Xutf8SetWMProperties(Display * , Window  , char const   * , char const   * ,
                                 char ** , int  , XSizeHints * , XWMHints * , XClassHint * ) ;
#line 701
extern void XSetWMSizeHints(Display * , Window  , XSizeHints * , Atom  ) ;
#line 708
extern int XSetRegion(Display * , GC  , Region  ) ;
#line 714
extern void XSetStandardColormap(Display * , Window  , XStandardColormap * , Atom  ) ;
#line 721
extern int XSetZoomHints(Display * , Window  , XSizeHints * ) ;
#line 727
extern int XShrinkRegion(Region  , int  , int  ) ;
#line 733
extern int XStringListToTextProperty(char ** , int  , XTextProperty * ) ;
#line 739
extern int XSubtractRegion(Region  , Region  , Region  ) ;
#line 745
extern int XmbTextListToTextProperty(Display *display , char **list , int count ,
                                     XICCEncodingStyle style , XTextProperty *text_prop_return ) ;
#line 753
extern int XwcTextListToTextProperty(Display *display , wchar_t **list , int count ,
                                     XICCEncodingStyle style , XTextProperty *text_prop_return ) ;
#line 761
extern int Xutf8TextListToTextProperty(Display *display , char **list , int count ,
                                       XICCEncodingStyle style , XTextProperty *text_prop_return ) ;
#line 769
extern void XwcFreeStringList(wchar_t **list ) ;
#line 773
extern int XTextPropertyToStringList(XTextProperty * , char *** , int * ) ;
#line 779
extern int XmbTextPropertyToTextList(Display *display , XTextProperty const   *text_prop ,
                                     char ***list_return , int *count_return ) ;
#line 786
extern int XwcTextPropertyToTextList(Display *display , XTextProperty const   *text_prop ,
                                     wchar_t ***list_return , int *count_return ) ;
#line 793
extern int Xutf8TextPropertyToTextList(Display *display , XTextProperty const   *text_prop ,
                                       char ***list_return , int *count_return ) ;
#line 800
extern int XUnionRectWithRegion(XRectangle * , Region  , Region  ) ;
#line 806
extern int XUnionRegion(Region  , Region  , Region  ) ;
#line 812
extern int XWMGeometry(Display * , int  , char const   * , char const   * , unsigned int  ,
                       XSizeHints * , int * , int * , int * , int * , int * ) ;
#line 826
extern int XXorRegion(Region  , Region  , Region  ) ;
#line 59 "/usr/include/X11/extensions/XShm.h"
extern int XShmQueryExtension(Display * ) ;
#line 63
extern int XShmGetEventBase(Display *dpy ) ;
#line 67
extern int XShmQueryVersion(Display * , int * , int * , int * ) ;
#line 74
extern int XShmPixmapFormat(Display * ) ;
#line 78
extern int XShmAttach(Display * , XShmSegmentInfo * ) ;
#line 83
extern int XShmDetach(Display * , XShmSegmentInfo * ) ;
#line 88
extern int XShmPutImage(Display * , Drawable  , GC  , XImage * , int  , int  , int  ,
                        int  , unsigned int  , unsigned int  , int  ) ;
#line 102
extern int XShmGetImage(Display * , Drawable  , XImage * , int  , int  , unsigned long  ) ;
#line 111
extern XImage *XShmCreateImage(Display * , Visual * , unsigned int  , int  , char * ,
                               XShmSegmentInfo * , unsigned int  , unsigned int  ) ;
#line 122
extern Pixmap XShmCreatePixmap(Display * , Drawable  , char * , XShmSegmentInfo * ,
                               unsigned int  , unsigned int  , unsigned int  ) ;
#line 317 "/usr/include/bits/socket.h"
extern struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                  struct cmsghdr *__cmsg )  __attribute__((__nothrow__)) ;
#line 102 "/usr/include/sys/socket.h"
extern int ( __attribute__((__leaf__)) socket)(int __domain , int __type , int __protocol )  __attribute__((__nothrow__)) ;
#line 108
extern int ( __attribute__((__leaf__)) socketpair)(int __domain , int __type , int __protocol ,
                                                   int *__fds )  __attribute__((__nothrow__)) ;
#line 112
extern int ( __attribute__((__leaf__)) bind)(int __fd , struct sockaddr  const  *__addr ,
                                             socklen_t __len )  __attribute__((__nothrow__)) ;
#line 116
extern int ( __attribute__((__leaf__)) getsockname)(int __fd , struct sockaddr *__addr ,
                                                    socklen_t *__len )  __attribute__((__nothrow__)) ;
#line 126
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 130
extern int ( __attribute__((__leaf__)) getpeername)(int __fd , struct sockaddr *__addr ,
                                                    socklen_t *__len )  __attribute__((__nothrow__)) ;
#line 138
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 145
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 152
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 163
extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags , struct sockaddr *__addr ,
                        socklen_t *__addr_len ) ;
#line 174
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 216
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 255
extern int ( __attribute__((__leaf__)) getsockopt)(int __fd , int __level , int __optname ,
                                                   void *__optval , socklen_t *__optlen )  __attribute__((__nothrow__)) ;
#line 277
extern int ( __attribute__((__leaf__)) setsockopt)(int __fd , int __level , int __optname ,
                                                   void const   *__optval , socklen_t __optlen )  __attribute__((__nothrow__)) ;
#line 296
extern int ( __attribute__((__leaf__)) listen)(int __fd , int __n )  __attribute__((__nothrow__)) ;
#line 306
extern int accept(int __fd , struct sockaddr *__addr , socklen_t *__addr_len ) ;
#line 324
extern int ( __attribute__((__leaf__)) shutdown)(int __fd , int __how )  __attribute__((__nothrow__)) ;
#line 329
extern int ( __attribute__((__leaf__)) sockatmark)(int __fd )  __attribute__((__nothrow__)) ;
#line 337
extern int ( __attribute__((__leaf__)) isfdtype)(int __fd , int __fdtype )  __attribute__((__nothrow__)) ;
#line 237 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 238
extern struct in6_addr  const  in6addr_loopback ;
#line 399
extern uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__nothrow__,
__const__)) ;
#line 400
extern uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__nothrow__,
__const__)) ;
#line 402
extern uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__nothrow__,
__const__)) ;
#line 404
extern uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__nothrow__,
__const__)) ;
#line 527
extern int ( __attribute__((__leaf__)) bindresvport)(int __sockfd , struct sockaddr_in *__sock_in )  __attribute__((__nothrow__)) ;
#line 530
extern int ( __attribute__((__leaf__)) bindresvport6)(int __sockfd , struct sockaddr_in6 *__sock_in )  __attribute__((__nothrow__)) ;
#line 37 "/usr/include/errno.h"
extern int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 44 "r_state.h"
fixed_t *textureheight ;
#line 47
fixed_t *spritewidth ;
#line 49
fixed_t *spriteoffset ;
#line 50
fixed_t *spritetopoffset ;
#line 52
lighttable_t *colormaps ;
#line 58
int firstflat ;
#line 61
int *flattranslation ;
#line 62
int *texturetranslation ;
#line 66
int firstspritelump ;
#line 67
int lastspritelump ;
#line 68
int numspritelumps ;
#line 75
int numsprites ;
#line 76
spritedef_t *sprites ;
#line 78
int numvertexes ;
#line 79
vertex_t *vertexes ;
#line 81
int numsegs ;
#line 82
seg_t *segs ;
#line 84
int numsectors ;
#line 85
sector_t *sectors ;
#line 87
int numsubsectors ;
#line 88
subsector_t *subsectors ;
#line 90
int numnodes ;
#line 91
node_t *nodes ;
#line 93
int numlines ;
#line 94
line_t *lines ;
#line 96
int numsides ;
#line 97
side_t *sides ;
#line 103
fixed_t viewx ;
#line 104
fixed_t viewy ;
#line 105
fixed_t viewz ;
#line 107
angle_t viewangle ;
#line 108
player_t *viewplayer ;
#line 112
angle_t clipangle ;
#line 114
int viewangletox[4096] ;
#line 115
angle_t xtoviewangle[321] ;
#line 118
fixed_t rw_distance ;
#line 119
angle_t rw_normalangle ;
#line 124
int rw_angle1 ;
#line 127
int sscount ;
#line 129
visplane_t *floorplane ;
#line 130
visplane_t *ceilingplane ;
#line 35 "r_data.h"
byte *R_GetColumn(int tex , int col ) ;
#line 42
void R_InitData(void) ;
#line 43
void R_PrecacheLevel(void) ;
#line 49
int R_FlatNumForName(char *name ) ;
#line 54
int R_TextureNumForName(char *name ) ;
#line 55
int R_CheckTextureNumForName(char *name ) ;
#line 47 "v_video.h"
byte *screens[5] ;
#line 49
int dirtybox[4] ;
#line 51
byte gammatable[5][256] ;
#line 52
int usegamma ;
#line 57
void V_Init(void) ;
#line 60
void V_CopyRect(int srcx , int srcy , int srcscrn , int width , int height , int destx ,
                int desty , int destscrn ) ;
#line 71
void V_DrawPatch(int x___0 , int y___1 , int scrn , patch_t *patch ) ;
#line 78
void V_DrawPatchDirect(int x___0 , int y___1 , int scrn , patch_t *patch ) ;
#line 87
void V_DrawBlock(int x___0 , int y___1 , int scrn , int width , int height , byte *src ) ;
#line 97
void V_GetBlock(int x___0 , int y___1 , int scrn , int width , int height , byte *dest ) ;
#line 107
void V_MarkRect(int x___0 , int y___1 , int width , int height ) ;
#line 37 "d_main.h"
char *wadfiles[20] ;
#line 39
void D_AddFile(char *file ) ;
#line 49
void D_DoomMain(void) ;
#line 52
void D_PostEvent(event_t *ev ) ;
#line 59
void D_PageTicker(void) ;
#line 60
void D_PageDrawer(void) ;
#line 61
void D_AdvanceDemo(void) ;
#line 62
void D_StartTitle(void) ;
#line 62 "i_video.c"
Display *X_display  =    (Display *)0;
#line 63 "i_video.c"
Window X_mainWindow  ;
#line 64 "i_video.c"
Colormap X_cmap  ;
#line 65 "i_video.c"
Visual *X_visual  ;
#line 66 "i_video.c"
GC X_gc  ;
#line 67 "i_video.c"
XEvent X_event  ;
#line 68 "i_video.c"
int X_screen  ;
#line 69 "i_video.c"
XVisualInfo X_visualinfo  ;
#line 70 "i_video.c"
XImage *image  ;
#line 71 "i_video.c"
int X_width  ;
#line 72 "i_video.c"
int X_height  ;
#line 75 "i_video.c"
boolean doShm  ;
#line 77 "i_video.c"
XShmSegmentInfo X_shminfo  ;
#line 78 "i_video.c"
int X_shmeventtype  ;
#line 83 "i_video.c"
boolean grabMouse  ;
#line 84 "i_video.c"
int doPointerWarp  =    1;
#line 90 "i_video.c"
static int multiply  =    1;
#line 97 "i_video.c"
int xlatekey(void) 
{ 
  int rc ;
  KeySym __attribute__((__deprecated__))  tmp ;

  {
#line 102
  tmp = XKeycodeToKeysym(X_display, (KeyCode )X_event.xkey.keycode, 0);
#line 102
  rc = (int )tmp;
  {
#line 104
  if (rc == 0xff51) {
#line 104
    goto case_65361;
  }
#line 105
  if (rc == 0xff53) {
#line 105
    goto case_65363;
  }
#line 106
  if (rc == 0xff54) {
#line 106
    goto case_65364;
  }
#line 107
  if (rc == 0xff52) {
#line 107
    goto case_65362;
  }
#line 108
  if (rc == 0xff1b) {
#line 108
    goto case_65307;
  }
#line 109
  if (rc == 0xff0d) {
#line 109
    goto case_65293;
  }
#line 110
  if (rc == 0xff09) {
#line 110
    goto case_65289;
  }
#line 111
  if (rc == 0xffbe) {
#line 111
    goto case_65470;
  }
#line 112
  if (rc == 0xffbf) {
#line 112
    goto case_65471;
  }
#line 113
  if (rc == 0xffc0) {
#line 113
    goto case_65472;
  }
#line 114
  if (rc == 0xffc1) {
#line 114
    goto case_65473;
  }
#line 115
  if (rc == 0xffc2) {
#line 115
    goto case_65474;
  }
#line 116
  if (rc == 0xffc3) {
#line 116
    goto case_65475;
  }
#line 117
  if (rc == 0xffc4) {
#line 117
    goto case_65476;
  }
#line 118
  if (rc == 0xffc5) {
#line 118
    goto case_65477;
  }
#line 119
  if (rc == 0xffc6) {
#line 119
    goto case_65478;
  }
#line 120
  if (rc == 0xffc7) {
#line 120
    goto case_65479;
  }
#line 121
  if (rc == 0xffc8) {
#line 121
    goto case_65480;
  }
#line 122
  if (rc == 0xffc9) {
#line 122
    goto case_65481;
  }
#line 125
  if (rc == 0xffff) {
#line 125
    goto case_65535;
  }
#line 125
  if (rc == 0xff08) {
#line 125
    goto case_65535;
  }
#line 127
  if (rc == 0xff13) {
#line 127
    goto case_65299;
  }
#line 130
  if (rc == 0x003d) {
#line 130
    goto case_61;
  }
#line 130
  if (rc == 0xffbd) {
#line 130
    goto case_61;
  }
#line 133
  if (rc == 0x002d) {
#line 133
    goto case_45;
  }
#line 133
  if (rc == 0xffad) {
#line 133
    goto case_45;
  }
#line 136
  if (rc == 0xffe2) {
#line 136
    goto case_65506;
  }
#line 136
  if (rc == 0xffe1) {
#line 136
    goto case_65506;
  }
#line 141
  if (rc == 0xffe4) {
#line 141
    goto case_65508;
  }
#line 141
  if (rc == 0xffe3) {
#line 141
    goto case_65508;
  }
#line 148
  if (rc == 0xffe8) {
#line 148
    goto case_65512;
  }
#line 148
  if (rc == 0xffea) {
#line 148
    goto case_65512;
  }
#line 148
  if (rc == 0xffe7) {
#line 148
    goto case_65512;
  }
#line 148
  if (rc == 0xffe9) {
#line 148
    goto case_65512;
  }
#line 152
  goto switch_default;
  case_65361: /* CIL Label */ 
#line 104
  rc = 0xac;
#line 104
  goto switch_break;
  case_65363: /* CIL Label */ 
#line 105
  rc = 0xae;
#line 105
  goto switch_break;
  case_65364: /* CIL Label */ 
#line 106
  rc = 0xaf;
#line 106
  goto switch_break;
  case_65362: /* CIL Label */ 
#line 107
  rc = 0xad;
#line 107
  goto switch_break;
  case_65307: /* CIL Label */ 
#line 108
  rc = 27;
#line 108
  goto switch_break;
  case_65293: /* CIL Label */ 
#line 109
  rc = 13;
#line 109
  goto switch_break;
  case_65289: /* CIL Label */ 
#line 110
  rc = 9;
#line 110
  goto switch_break;
  case_65470: /* CIL Label */ 
#line 111
  rc = 187;
#line 111
  goto switch_break;
  case_65471: /* CIL Label */ 
#line 112
  rc = 188;
#line 112
  goto switch_break;
  case_65472: /* CIL Label */ 
#line 113
  rc = 189;
#line 113
  goto switch_break;
  case_65473: /* CIL Label */ 
#line 114
  rc = 190;
#line 114
  goto switch_break;
  case_65474: /* CIL Label */ 
#line 115
  rc = 191;
#line 115
  goto switch_break;
  case_65475: /* CIL Label */ 
#line 116
  rc = 192;
#line 116
  goto switch_break;
  case_65476: /* CIL Label */ 
#line 117
  rc = 193;
#line 117
  goto switch_break;
  case_65477: /* CIL Label */ 
#line 118
  rc = 194;
#line 118
  goto switch_break;
  case_65478: /* CIL Label */ 
#line 119
  rc = 195;
#line 119
  goto switch_break;
  case_65479: /* CIL Label */ 
#line 120
  rc = 196;
#line 120
  goto switch_break;
  case_65480: /* CIL Label */ 
#line 121
  rc = 215;
#line 121
  goto switch_break;
  case_65481: /* CIL Label */ 
#line 122
  rc = 216;
#line 122
  goto switch_break;
  case_65535: /* CIL Label */ 
  case_65288: /* CIL Label */ 
#line 125
  rc = 127;
#line 125
  goto switch_break;
  case_65299: /* CIL Label */ 
#line 127
  rc = 0xff;
#line 127
  goto switch_break;
  case_61: /* CIL Label */ 
  case_65469: /* CIL Label */ 
#line 130
  rc = 0x3d;
#line 130
  goto switch_break;
  case_45: /* CIL Label */ 
  case_65453: /* CIL Label */ 
#line 133
  rc = 0x2d;
#line 133
  goto switch_break;
  case_65506: /* CIL Label */ 
  case_65505: /* CIL Label */ 
#line 137
  rc = 182;
#line 138
  goto switch_break;
  case_65508: /* CIL Label */ 
  case_65507: /* CIL Label */ 
#line 142
  rc = 157;
#line 143
  goto switch_break;
  case_65512: /* CIL Label */ 
  case_65514: /* CIL Label */ 
  case_65511: /* CIL Label */ 
  case_65513: /* CIL Label */ 
#line 149
  rc = 184;
#line 150
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 153
  if (rc >= 0x0020) {
#line 153
    if (rc <= 0x007e) {
#line 154
      rc = (rc - 0x0020) + 32;
    } else {
#line 153
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 155
  if (rc >= 65) {
#line 155
    if (rc <= 90) {
#line 156
      rc = (rc - 65) + 97;
    } else {
#line 155
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 157
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 160
  return (rc);
}
}
#line 164 "i_video.c"
void I_ShutdownGraphics(void) 
{ 
  int tmp ;

  {
#line 167
  tmp = XShmDetach(X_display, & X_shminfo);
#line 167
  if (! tmp) {
#line 168
    I_Error("XShmDetach() failed in I_ShutdownGraphics()");
  }
#line 171
  shmdt((void const   *)X_shminfo.shmaddr);
#line 172
  shmctl(X_shminfo.shmid, 0, (struct shmid_ds *)0);
#line 175
  image->data = (char *)((void *)0);
#line 176
  return;
}
}
#line 183 "i_video.c"
void I_StartFrame(void) 
{ 


  {
#line 187
  return;
}
}
#line 189 "i_video.c"
static int lastmousex  =    0;
#line 190 "i_video.c"
static int lastmousey  =    0;
#line 191 "i_video.c"
boolean mousemoved  =    (boolean )0;
#line 192 "i_video.c"
boolean shmFinished  ;
#line 194 "i_video.c"
void I_GetEvent(void) 
{ 
  event_t event ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 200
  XNextEvent(X_display, & X_event);
  {
#line 203
  if (X_event.type == 2) {
#line 203
    goto case_2;
  }
#line 209
  if (X_event.type == 3) {
#line 209
    goto case_3;
  }
#line 215
  if (X_event.type == 4) {
#line 215
    goto case_4;
  }
#line 228
  if (X_event.type == 5) {
#line 228
    goto case_5;
  }
#line 244
  if (X_event.type == 6) {
#line 244
    goto case_6;
  }
#line 271
  if (X_event.type == 22) {
#line 271
    goto case_22;
  }
#line 271
  if (X_event.type == 12) {
#line 271
    goto case_22;
  }
#line 274
  goto switch_default;
  case_2: /* CIL Label */ 
#line 204
  event.type = (evtype_t )0;
#line 205
  event.data1 = xlatekey();
#line 206
  D_PostEvent(& event);
#line 208
  goto switch_break;
  case_3: /* CIL Label */ 
#line 210
  event.type = (evtype_t )1;
#line 211
  event.data1 = xlatekey();
#line 212
  D_PostEvent(& event);
#line 214
  goto switch_break;
  case_4: /* CIL Label */ 
#line 216
  event.type = (evtype_t )2;
#line 217
  if (X_event.xbutton.state & (unsigned int )(1 << 9)) {
#line 217
    tmp = 2;
  } else {
#line 217
    tmp = 0;
  }
#line 217
  if (X_event.xbutton.state & (unsigned int )(1 << 10)) {
#line 217
    tmp___0 = 4;
  } else {
#line 217
    tmp___0 = 0;
  }
#line 217
  if (X_event.xbutton.button == 2U) {
#line 217
    tmp___1 = 2;
  } else {
#line 217
    tmp___1 = 0;
  }
#line 217
  if (X_event.xbutton.button == 3U) {
#line 217
    tmp___2 = 4;
  } else {
#line 217
    tmp___2 = 0;
  }
#line 217
  event.data1 = (int )((((((X_event.xbutton.state & (unsigned int )(1 << 8)) | (unsigned int )tmp) | (unsigned int )tmp___0) | (unsigned int )(X_event.xbutton.button == 1U)) | (unsigned int )tmp___1) | (unsigned int )tmp___2);
#line 224
  event.data3 = 0;
#line 224
  event.data2 = event.data3;
#line 225
  D_PostEvent(& event);
#line 227
  goto switch_break;
  case_5: /* CIL Label */ 
#line 229
  event.type = (evtype_t )2;
#line 230
  if (X_event.xbutton.state & (unsigned int )(1 << 9)) {
#line 230
    tmp___3 = 2;
  } else {
#line 230
    tmp___3 = 0;
  }
#line 230
  if (X_event.xbutton.state & (unsigned int )(1 << 10)) {
#line 230
    tmp___4 = 4;
  } else {
#line 230
    tmp___4 = 0;
  }
#line 230
  event.data1 = (int )(((X_event.xbutton.state & (unsigned int )(1 << 8)) | (unsigned int )tmp___3) | (unsigned int )tmp___4);
#line 235
  if (X_event.xbutton.button == 1U) {
#line 235
    tmp___5 = 1;
  } else {
#line 235
    tmp___5 = 0;
  }
#line 235
  if (X_event.xbutton.button == 2U) {
#line 235
    tmp___6 = 2;
  } else {
#line 235
    tmp___6 = 0;
  }
#line 235
  if (X_event.xbutton.button == 3U) {
#line 235
    tmp___7 = 4;
  } else {
#line 235
    tmp___7 = 0;
  }
#line 235
  event.data1 = ((event.data1 ^ tmp___5) ^ tmp___6) ^ tmp___7;
#line 240
  event.data3 = 0;
#line 240
  event.data2 = event.data3;
#line 241
  D_PostEvent(& event);
#line 243
  goto switch_break;
  case_6: /* CIL Label */ 
#line 245
  event.type = (evtype_t )2;
#line 246
  if (X_event.xmotion.state & (unsigned int )(1 << 9)) {
#line 246
    tmp___8 = 2;
  } else {
#line 246
    tmp___8 = 0;
  }
#line 246
  if (X_event.xmotion.state & (unsigned int )(1 << 10)) {
#line 246
    tmp___9 = 4;
  } else {
#line 246
    tmp___9 = 0;
  }
#line 246
  event.data1 = (int )(((X_event.xmotion.state & (unsigned int )(1 << 8)) | (unsigned int )tmp___8) | (unsigned int )tmp___9);
#line 250
  event.data2 = (X_event.xmotion.x - lastmousex) << 2;
#line 251
  event.data3 = (lastmousey - X_event.xmotion.y) << 2;
#line 253
  if (event.data2) {
#line 253
    goto _L___0;
  } else
#line 253
  if (event.data3) {
    _L___0: /* CIL Label */ 
#line 255
    lastmousex = X_event.xmotion.x;
#line 256
    lastmousey = X_event.xmotion.y;
#line 257
    if (X_event.xmotion.x != X_width / 2) {
#line 257
      if (X_event.xmotion.y != X_height / 2) {
#line 260
        D_PostEvent(& event);
#line 262
        mousemoved = (boolean )0;
      } else {
#line 257
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 265
      mousemoved = (boolean )1;
    }
  }
#line 268
  goto switch_break;
  case_22: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 272
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 275
  if (doShm) {
#line 275
    if (X_event.type == X_shmeventtype) {
#line 275
      shmFinished = (boolean )1;
    } else {
#line 275
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 276
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 281 "i_video.c"
Cursor createnullcursor(Display *display , Window root ) 
{ 
  Pixmap cursormask ;
  XGCValues xgc ;
  GC gc ;
  XColor dummycolour ;
  Cursor cursor ;

  {
#line 292
  cursormask = XCreatePixmap(display, root, 1U, 1U, 1U);
#line 293
  xgc.function = 0x0;
#line 294
  gc = XCreateGC(display, cursormask, (unsigned long )(1L << 0), & xgc);
#line 295
  XFillRectangle(display, cursormask, gc, 0, 0, 1U, 1U);
#line 296
  dummycolour.pixel = 0UL;
#line 297
  dummycolour.red = (unsigned short)0;
#line 298
  dummycolour.flags = (char)4;
#line 299
  cursor = XCreatePixmapCursor(display, cursormask, cursormask, & dummycolour, & dummycolour,
                               0U, 0U);
#line 301
  XFreePixmap(display, cursormask);
#line 302
  XFreeGC(display, gc);
#line 303
  return (cursor);
}
}
#line 309 "i_video.c"
void I_StartTic(void) 
{ 
  int tmp ;

  {
#line 312
  if (! X_display) {
#line 313
    return;
  }
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    tmp = XPending(X_display);
#line 315
    if (! tmp) {
#line 315
      goto while_break;
    }
#line 316
    I_GetEvent();
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  if (grabMouse) {
#line 323
    doPointerWarp --;
#line 323
    if (! doPointerWarp) {
#line 325
      XWarpPointer(X_display, (Window )0L, X_mainWindow, 0, 0, 0U, 0U, X_width / 2,
                   X_height / 2);
#line 332
      doPointerWarp = 1;
    }
  }
#line 336
  mousemoved = (boolean )0;
#line 338
  return;
}
}
#line 344 "i_video.c"
void I_UpdateNoBlit(void) 
{ 


  {
#line 347
  return;
}
}
#line 355 "i_video.c"
static int lasttic  ;
#line 479
void Expand4(unsigned int *lineptr , double *xline ) ;
#line 352 "i_video.c"
void I_FinishUpdate(void) 
{ 
  int tics ;
  int i ;
  unsigned int *olineptrs[2] ;
  unsigned int *ilineptr ;
  int x___0 ;
  int y___1 ;
  int i___0 ;
  unsigned int twoopixels ;
  unsigned int twomoreopixels ;
  unsigned int fouripixels ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  unsigned int *tmp___1 ;
  unsigned int *tmp___2 ;
  unsigned int *tmp___3 ;
  int tmp___4 ;
  unsigned int *olineptrs___0[3] ;
  unsigned int *ilineptr___0 ;
  int x___1 ;
  int y___2 ;
  int i___1 ;
  unsigned int fouropixels[3] ;
  unsigned int fouripixels___0 ;
  unsigned int *tmp___5 ;
  unsigned int *tmp___6 ;
  unsigned int *tmp___7 ;
  unsigned int *tmp___8 ;
  unsigned int *tmp___9 ;
  unsigned int *tmp___10 ;
  unsigned int *tmp___11 ;
  unsigned int *tmp___12 ;
  unsigned int *tmp___13 ;
  unsigned int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 361
  if (devparm) {
#line 364
    i = I_GetTime();
#line 365
    tics = i - lasttic;
#line 366
    lasttic = i;
#line 367
    if (tics > 20) {
#line 367
      tics = 20;
    }
#line 369
    i = 0;
    {
#line 369
    while (1) {
      while_continue: /* CIL Label */ ;
#line 369
      if (! (i < tics * 2)) {
#line 369
        goto while_break;
      }
#line 370
      *(screens[0] + (63680 + i)) = (byte )0xff;
#line 369
      i += 2;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 371
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 371
      if (! (i < 40)) {
#line 371
        goto while_break___0;
      }
#line 372
      *(screens[0] + (63680 + i)) = (byte )0x0;
#line 371
      i += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 377
  if (multiply == 2) {
#line 386
    ilineptr = (unsigned int *)screens[0];
#line 387
    i___0 = 0;
    {
#line 387
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 387
      if (! (i___0 < 2)) {
#line 387
        goto while_break___1;
      }
#line 388
      olineptrs[i___0] = (unsigned int *)(image->data + i___0 * X_width);
#line 387
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 390
    y___1 = 200;
    {
#line 391
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 391
      tmp___4 = y___1;
#line 391
      y___1 --;
#line 391
      if (! tmp___4) {
#line 391
        goto while_break___2;
      }
#line 393
      x___0 = 320;
      {
#line 394
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 396
        tmp = ilineptr;
#line 396
        ilineptr ++;
#line 396
        fouripixels = *tmp;
#line 397
        twoopixels = ((fouripixels & 0xff000000) | ((fouripixels >> 8) & 16776960U)) | ((fouripixels >> 16) & 255U);
#line 400
        twomoreopixels = (((fouripixels << 16) & 0xff000000) | ((fouripixels << 8) & 16776960U)) | (fouripixels & 255U);
#line 409
        tmp___0 = olineptrs[0];
#line 409
        (olineptrs[0]) ++;
#line 409
        *tmp___0 = twomoreopixels;
#line 410
        tmp___1 = olineptrs[1];
#line 410
        (olineptrs[1]) ++;
#line 410
        *tmp___1 = twomoreopixels;
#line 411
        tmp___2 = olineptrs[0];
#line 411
        (olineptrs[0]) ++;
#line 411
        *tmp___2 = twoopixels;
#line 412
        tmp___3 = olineptrs[1];
#line 412
        (olineptrs[1]) ++;
#line 412
        *tmp___3 = twoopixels;
#line 394
        x___0 -= 4;
#line 394
        if (! x___0) {
#line 394
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 415
      olineptrs[0] += X_width / 4;
#line 416
      olineptrs[1] += X_width / 4;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 420
  if (multiply == 3) {
#line 428
    ilineptr___0 = (unsigned int *)screens[0];
#line 429
    i___1 = 0;
    {
#line 429
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 429
      if (! (i___1 < 3)) {
#line 429
        goto while_break___4;
      }
#line 430
      olineptrs___0[i___1] = (unsigned int *)(image->data + i___1 * X_width);
#line 429
      i___1 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 432
    y___2 = 200;
    {
#line 433
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 433
      tmp___15 = y___2;
#line 433
      y___2 --;
#line 433
      if (! tmp___15) {
#line 433
        goto while_break___5;
      }
#line 435
      x___1 = 320;
      {
#line 436
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 438
        tmp___5 = ilineptr___0;
#line 438
        ilineptr___0 ++;
#line 438
        fouripixels___0 = *tmp___5;
#line 439
        fouropixels[0] = ((fouripixels___0 & 0xff000000) | ((fouripixels___0 >> 8) & 16711680U)) | ((fouripixels___0 >> 16) & 65535U);
#line 442
        fouropixels[1] = (((fouripixels___0 << 8) & 0xff000000) | (fouripixels___0 & 16776960U)) | ((fouripixels___0 >> 8) & 255U);
#line 445
        fouropixels[2] = (((fouripixels___0 << 16) & 0xffff0000) | ((fouripixels___0 << 8) & 65280U)) | (fouripixels___0 & 255U);
#line 459
        tmp___6 = olineptrs___0[0];
#line 459
        (olineptrs___0[0]) ++;
#line 459
        *tmp___6 = fouropixels[2];
#line 460
        tmp___7 = olineptrs___0[1];
#line 460
        (olineptrs___0[1]) ++;
#line 460
        *tmp___7 = fouropixels[2];
#line 461
        tmp___8 = olineptrs___0[2];
#line 461
        (olineptrs___0[2]) ++;
#line 461
        *tmp___8 = fouropixels[2];
#line 462
        tmp___9 = olineptrs___0[0];
#line 462
        (olineptrs___0[0]) ++;
#line 462
        *tmp___9 = fouropixels[1];
#line 463
        tmp___10 = olineptrs___0[1];
#line 463
        (olineptrs___0[1]) ++;
#line 463
        *tmp___10 = fouropixels[1];
#line 464
        tmp___11 = olineptrs___0[2];
#line 464
        (olineptrs___0[2]) ++;
#line 464
        *tmp___11 = fouropixels[1];
#line 465
        tmp___12 = olineptrs___0[0];
#line 465
        (olineptrs___0[0]) ++;
#line 465
        *tmp___12 = fouropixels[0];
#line 466
        tmp___13 = olineptrs___0[1];
#line 466
        (olineptrs___0[1]) ++;
#line 466
        *tmp___13 = fouropixels[0];
#line 467
        tmp___14 = olineptrs___0[2];
#line 467
        (olineptrs___0[2]) ++;
#line 467
        *tmp___14 = fouropixels[0];
#line 436
        x___1 -= 4;
#line 436
        if (! x___1) {
#line 436
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 470
      olineptrs___0[0] += (2 * X_width) / 4;
#line 471
      olineptrs___0[1] += (2 * X_width) / 4;
#line 472
      olineptrs___0[2] += (2 * X_width) / 4;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 476
  if (multiply == 4) {
#line 480
    Expand4((unsigned int *)screens[0], (double *)image->data);
  }
#line 483
  if (doShm) {
#line 486
    tmp___16 = XShmPutImage(X_display, X_mainWindow, X_gc, image, 0, 0, 0, 0, (unsigned int )X_width,
                            (unsigned int )X_height, 1);
#line 486
    if (! tmp___16) {
#line 494
      I_Error("XShmPutImage() failed\n");
    }
#line 497
    shmFinished = (boolean )0;
    {
#line 498
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 500
      I_GetEvent();
#line 498
      if (! (! shmFinished)) {
#line 498
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
#line 508
    XPutImage(X_display, X_mainWindow, X_gc, image, 0, 0, 0, 0, (unsigned int )X_width,
              (unsigned int )X_height);
#line 517
    XSync(X_display, 0);
  }
#line 521
  return;
}
}
#line 527 "i_video.c"
void I_ReadScreen(byte *scr ) 
{ 


  {
#line 529
  memcpy((void * __restrict  )scr, (void const   * __restrict  )screens[0], (size_t )64000);
#line 530
  return;
}
}
#line 536 "i_video.c"
static XColor colors[256]  ;
#line 543
void UploadNewPalette(Colormap cmap , byte *palette ) ;
#line 543 "i_video.c"
static boolean firstcall  =    (boolean )1;
#line 538 "i_video.c"
void UploadNewPalette(Colormap cmap , byte *palette ) 
{ 
  register int i ;
  register int c ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;

  {
#line 548
  if (X_visualinfo.class == 3) {
#line 548
    if (X_visualinfo.depth == 8) {
#line 552
      if (firstcall) {
#line 554
        firstcall = (boolean )0;
#line 555
        i = 0;
        {
#line 555
        while (1) {
          while_continue: /* CIL Label */ ;
#line 555
          if (! (i < 256)) {
#line 555
            goto while_break;
          }
#line 557
          colors[i].pixel = (unsigned long )i;
#line 558
          colors[i].flags = (char )(((1 << 0) | (1 << 1)) | (1 << 2));
#line 555
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 563
      i = 0;
      {
#line 563
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 563
        if (! (i < 256)) {
#line 563
          goto while_break___0;
        }
#line 565
        tmp = palette;
#line 565
        palette ++;
#line 565
        c = (int )gammatable[usegamma][*tmp];
#line 566
        colors[i].red = (unsigned short )((c << 8) + c);
#line 567
        tmp___0 = palette;
#line 567
        palette ++;
#line 567
        c = (int )gammatable[usegamma][*tmp___0];
#line 568
        colors[i].green = (unsigned short )((c << 8) + c);
#line 569
        tmp___1 = palette;
#line 569
        palette ++;
#line 569
        c = (int )gammatable[usegamma][*tmp___1];
#line 570
        colors[i].blue = (unsigned short )((c << 8) + c);
#line 563
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 574
      XStoreColors(X_display, cmap, colors, 256);
    } else {
#line 548
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 577
  return;
}
}
#line 582 "i_video.c"
void I_SetPalette(byte *palette ) 
{ 


  {
#line 584
  UploadNewPalette(X_cmap, palette);
#line 585
  return;
}
}
#line 595 "i_video.c"
void grabsharedmemory(int size ) 
{ 
  int key ;
  struct shmid_ds shminfo ;
  int minsize ;
  int id ;
  int rc ;
  int pollution ;
  __uid_t tmp ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
#line 598
  key = (((100 << 24) | (111 << 16)) | (111 << 8)) | 109;
#line 600
  minsize = 64000;
#line 604
  pollution = 5;
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 609
    id = shmget(key, (size_t )minsize, 0777);
#line 610
    if (id != -1) {
#line 612
      rc = shmctl(id, 2, & shminfo);
#line 613
      if (! rc) {
#line 615
        if (shminfo.shm_nattch) {
#line 617
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"User %d appears to be running DOOM.  Is that wise?\n",
                  shminfo.shm_cpid);
#line 619
          key ++;
        } else {
#line 623
          tmp = getuid();
#line 623
          if (tmp == shminfo.shm_perm.cuid) {
#line 625
            rc = shmctl(id, 0, (struct shmid_ds *)0);
#line 626
            if (! rc) {
#line 627
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Was able to kill my old shared memory\n");
            } else {
#line 630
              I_Error("Was NOT able to kill my old shared memory");
            }
#line 632
            id = shmget(key, (size_t )size, 1023);
#line 633
            if (id == -1) {
#line 634
              I_Error("Could not get shared memory");
            }
#line 636
            rc = shmctl(id, 2, & shminfo);
#line 638
            goto while_break;
          }
#line 641
          if ((size_t )size >= shminfo.shm_segsz) {
#line 643
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"will use %d\'s stale shared memory\n",
                    shminfo.shm_cpid);
#line 646
            goto while_break;
          } else {
#line 650
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"warning: can\'t use stale shared memory belonging to id %d, key=0x%x\n",
                    shminfo.shm_cpid, key);
#line 655
            key ++;
          }
        }
      } else {
#line 661
        I_Error("could not get stats on key=%d", key);
      }
    } else {
#line 666
      id = shmget(key, (size_t )size, 1023);
#line 667
      if (id == -1) {
#line 670
        tmp___0 = __errno_location();
#line 670
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"errno=%d\n",
                *tmp___0);
#line 671
        I_Error("Could not get any shared memory");
      }
#line 673
      goto while_break;
    }
#line 607
    pollution --;
#line 607
    if (! pollution) {
#line 607
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  if (! pollution) {
#line 679
    I_Error("Sorry, system too polluted with stale shared memory segments.\n");
  }
#line 683
  X_shminfo.shmid = id;
#line 686
  tmp___1 = shmat(id, (void const   *)0, 0);
#line 686
  X_shminfo.shmaddr = (char *)tmp___1;
#line 686
  image->data = X_shminfo.shmaddr;
#line 688
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"shared memory id=%d, addr=0x%x\n",
          id, (int )image->data);
#line 690
  return;
}
}
#line 711 "i_video.c"
static int firsttime  =    1;
#line 692 "i_video.c"
void I_InitGraphics(void) 
{ 
  char *displayname ;
  char *d ;
  int n ;
  int pnum ;
  int x___0 ;
  int y___1 ;
  char xsign ;
  char ysign ;
  int oktodraw ;
  unsigned long attribmask ;
  XSetWindowAttributes attribs ;
  XGCValues xgcvalues ;
  int valuemask ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  Cursor tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;

  {
#line 699
  x___0 = 0;
#line 700
  y___1 = 0;
#line 703
  xsign = (char )' ';
#line 704
  ysign = (char )' ';
#line 713
  if (! firsttime) {
#line 714
    return;
  }
#line 715
  firsttime = 0;
#line 717
  signal(2, (void (*)(int  ))(& I_Quit));
#line 719
  tmp = M_CheckParm("-2");
#line 719
  if (tmp) {
#line 720
    multiply = 2;
  }
#line 722
  tmp___0 = M_CheckParm("-3");
#line 722
  if (tmp___0) {
#line 723
    multiply = 3;
  }
#line 725
  tmp___1 = M_CheckParm("-4");
#line 725
  if (tmp___1) {
#line 726
    multiply = 4;
  }
#line 728
  X_width = 320 * multiply;
#line 729
  X_height = 200 * multiply;
#line 732
  pnum = M_CheckParm("-disp");
#line 732
  if (pnum) {
#line 733
    displayname = *(myargv + (pnum + 1));
  } else {
#line 735
    displayname = (char *)0;
  }
#line 738
  tmp___2 = M_CheckParm("-grabmouse");
#line 738
  if (tmp___2) {
#line 738
    tmp___3 = 1;
  } else {
#line 738
    tmp___3 = 0;
  }
#line 738
  grabMouse = (boolean )tmp___3;
#line 741
  pnum = M_CheckParm("-geom");
#line 741
  if (pnum) {
#line 744
    n = sscanf((char const   *)*(myargv + (pnum + 1)), (char const   *)"%c%d%c%d",
               & xsign, & x___0, & ysign, & y___1);
#line 746
    if (n == 2) {
#line 747
      y___1 = 0;
#line 747
      x___0 = y___1;
    } else
#line 748
    if (n == 6) {
#line 750
      if ((int )xsign == 45) {
#line 751
        x___0 = - x___0;
      }
#line 752
      if ((int )ysign == 45) {
#line 753
        y___1 = - y___1;
      }
    } else {
#line 756
      I_Error("bad -geom parameter");
    }
  }
#line 760
  X_display = XOpenDisplay((char const   *)displayname);
#line 761
  if (! X_display) {
#line 763
    if (displayname) {
#line 764
      I_Error("Could not open display [%s]", displayname);
    } else {
#line 766
      tmp___4 = getenv((char const   *)"DISPLAY");
#line 766
      I_Error("Could not open display (DISPLAY=[%s])", tmp___4);
    }
  }
#line 770
  X_screen = ((_XPrivDisplay )X_display)->default_screen;
#line 771
  tmp___5 = XMatchVisualInfo(X_display, X_screen, 8, 3, & X_visualinfo);
#line 771
  if (! tmp___5) {
#line 772
    I_Error("xdoom currently only supports 256-color PseudoColor screens");
  }
#line 773
  X_visual = X_visualinfo.visual;
#line 776
  tmp___6 = XShmQueryExtension(X_display);
#line 776
  doShm = (boolean )tmp___6;
#line 779
  if (doShm) {
#line 781
    if (! displayname) {
#line 781
      tmp___7 = getenv((char const   *)"DISPLAY");
#line 781
      displayname = tmp___7;
    }
#line 782
    if (displayname) {
#line 784
      d = displayname;
      {
#line 785
      while (1) {
        while_continue: /* CIL Label */ ;
#line 785
        if (*d) {
#line 785
          if (! ((int )*d != 58)) {
#line 785
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 785
          goto while_break;
        }
#line 785
        d ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 786
      if (*d) {
#line 786
        *d = (char)0;
      }
#line 787
      tmp___8 = strcasecmp((char const   *)displayname, (char const   *)"unix");
#line 787
      if (tmp___8) {
#line 787
        if (! *displayname) {
          _L___0: /* CIL Label */ ;
        } else {
#line 787
          doShm = (boolean )0;
        }
      } else {
#line 787
        goto _L___0;
      }
    }
  }
#line 791
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Using MITSHM extension\n");
#line 794
  X_cmap = XCreateColormap(X_display, (((_XPrivDisplay )X_display)->screens + X_screen)->root,
                           X_visual, 1);
#line 798
  attribmask = (unsigned long )(((1L << 11) | (1L << 13)) | (1L << 3));
#line 799
  attribs.event_mask = ((1L << 0) | (1L << 1)) | (1L << 15);
#line 805
  attribs.colormap = X_cmap;
#line 806
  attribs.border_pixel = 0UL;
#line 809
  X_mainWindow = XCreateWindow(X_display, (((_XPrivDisplay )X_display)->screens + X_screen)->root,
                               x___0, y___1, (unsigned int )X_width, (unsigned int )X_height,
                               0U, 8, 1U, X_visual, attribmask, & attribs);
#line 820
  tmp___9 = createnullcursor(X_display, X_mainWindow);
#line 820
  XDefineCursor(X_display, X_mainWindow, tmp___9);
#line 824
  valuemask = (int )(1L << 16);
#line 825
  xgcvalues.graphics_exposures = 0;
#line 826
  X_gc = XCreateGC(X_display, X_mainWindow, (unsigned long )valuemask, & xgcvalues);
#line 832
  XMapWindow(X_display, X_mainWindow);
#line 835
  oktodraw = 0;
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 836
    if (! (! oktodraw)) {
#line 836
      goto while_break___0;
    }
#line 838
    XNextEvent(X_display, & X_event);
#line 839
    if (X_event.type == 12) {
#line 839
      if (! X_event.xexpose.count) {
#line 842
        oktodraw = 1;
      } else {
#line 839
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 847
  if (grabMouse) {
#line 848
    XGrabPointer(X_display, X_mainWindow, 1, (unsigned int )(((1L << 2) | (1L << 3)) | (1L << 6)),
                 1, 1, X_mainWindow, (Cursor )0L, (Time )0L);
  }
#line 853
  if (doShm) {
#line 856
    tmp___10 = XShmGetEventBase(X_display);
#line 856
    X_shmeventtype = tmp___10;
#line 859
    image = XShmCreateImage(X_display, X_visual, 8U, 2, (char *)0, & X_shminfo, (unsigned int )X_width,
                            (unsigned int )X_height);
#line 868
    grabsharedmemory(image->bytes_per_line * image->height);
#line 885
    if (! image->data) {
#line 887
      perror((char const   *)"");
#line 888
      I_Error("shmat() failed in InitGraphics()");
    }
#line 892
    tmp___11 = XShmAttach(X_display, & X_shminfo);
#line 892
    if (! tmp___11) {
#line 893
      I_Error("XShmAttach() failed in InitGraphics()");
    }
  } else {
#line 898
    tmp___12 = malloc((size_t )(X_width * X_height));
#line 898
    image = XCreateImage(X_display, X_visual, 8U, 2, 0, (char *)tmp___12, (unsigned int )X_width,
                         (unsigned int )X_height, 8, X_width);
  }
#line 910
  if (multiply == 1) {
#line 911
    screens[0] = (unsigned char *)image->data;
  } else {
#line 913
    tmp___13 = malloc((size_t )64000);
#line 913
    screens[0] = (unsigned char *)tmp___13;
  }
#line 915
  return;
}
}
#line 918 "i_video.c"
unsigned int exptable[256]  ;
#line 920 "i_video.c"
void InitExpand(void) 
{ 
  int i ;

  {
#line 924
  i = 0;
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! (i < 256)) {
#line 924
      goto while_break;
    }
#line 925
    exptable[i] = (unsigned int )(((i | (i << 8)) | (i << 16)) | (i << 24));
#line 924
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 926
  return;
}
}
#line 928 "i_video.c"
double exptable2[65536]  ;
#line 930 "i_video.c"
void InitExpand2(void) 
{ 
  int i ;
  int j ;
  double *exp___0 ;
  union __anonunion_pixel_695819067 pixel ;
  double *tmp ;

  {
#line 942
  printf((char const   * __restrict  )"building exptable2...\n");
#line 943
  exp___0 = exptable2;
#line 944
  i = 0;
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (i < 256)) {
#line 944
      goto while_break;
    }
#line 946
    pixel.u[0] = (unsigned int )(((i | (i << 8)) | (i << 16)) | (i << 24));
#line 947
    j = 0;
    {
#line 947
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 947
      if (! (j < 256)) {
#line 947
        goto while_break___0;
      }
#line 949
      pixel.u[1] = (unsigned int )(((j | (j << 8)) | (j << 16)) | (j << 24));
#line 950
      tmp = exp___0;
#line 950
      exp___0 ++;
#line 950
      *tmp = pixel.d;
#line 947
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 944
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 953
  printf((char const   * __restrict  )"done.\n");
#line 954
  return;
}
}
#line 956 "i_video.c"
int inited  ;
#line 958 "i_video.c"
void Expand4(unsigned int *lineptr , double *xline ) 
{ 
  double dpixel ;
  unsigned int x___0 ;
  unsigned int y___1 ;
  unsigned int fourpixels ;
  unsigned int step ;
  double *exp___0 ;
  unsigned int tmp ;

  {
#line 970
  exp___0 = exptable2;
#line 971
  if (! inited) {
#line 973
    inited = 1;
#line 974
    InitExpand2();
  }
#line 978
  step = 480U;
#line 980
  y___1 = 199U;
  {
#line 981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 983
    x___0 = 320U;
    {
#line 985
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 987
      fourpixels = *(lineptr + 0);
#line 989
      dpixel = *((double *)((unsigned int )((int )exp___0) + ((fourpixels & 0xffff0000) >> 13)));
#line 990
      *(xline + 0) = dpixel;
#line 991
      *(xline + 160) = dpixel;
#line 992
      *(xline + 320) = dpixel;
#line 993
      *(xline + 480) = dpixel;
#line 995
      dpixel = *((double *)((unsigned int )((int )exp___0) + ((fourpixels & 65535U) << 3)));
#line 996
      *(xline + 1) = dpixel;
#line 997
      *(xline + 161) = dpixel;
#line 998
      *(xline + 321) = dpixel;
#line 999
      *(xline + 481) = dpixel;
#line 1001
      fourpixels = *(lineptr + 1);
#line 1003
      dpixel = *((double *)((unsigned int )((int )exp___0) + ((fourpixels & 0xffff0000) >> 13)));
#line 1004
      *(xline + 2) = dpixel;
#line 1005
      *(xline + 162) = dpixel;
#line 1006
      *(xline + 322) = dpixel;
#line 1007
      *(xline + 482) = dpixel;
#line 1009
      dpixel = *((double *)((unsigned int )((int )exp___0) + ((fourpixels & 65535U) << 3)));
#line 1010
      *(xline + 3) = dpixel;
#line 1011
      *(xline + 163) = dpixel;
#line 1012
      *(xline + 323) = dpixel;
#line 1013
      *(xline + 483) = dpixel;
#line 1015
      fourpixels = *(lineptr + 2);
#line 1017
      dpixel = *((double *)((unsigned int )((int )exp___0) + ((fourpixels & 0xffff0000) >> 13)));
#line 1018
      *(xline + 4) = dpixel;
#line 1019
      *(xline + 164) = dpixel;
#line 1020
      *(xline + 324) = dpixel;
#line 1021
      *(xline + 484) = dpixel;
#line 1023
      dpixel = *((double *)((unsigned int )((int )exp___0) + ((fourpixels & 65535U) << 3)));
#line 1024
      *(xline + 5) = dpixel;
#line 1025
      *(xline + 165) = dpixel;
#line 1026
      *(xline + 325) = dpixel;
#line 1027
      *(xline + 485) = dpixel;
#line 1029
      fourpixels = *(lineptr + 3);
#line 1031
      dpixel = *((double *)((unsigned int )((int )exp___0) + ((fourpixels & 0xffff0000) >> 13)));
#line 1032
      *(xline + 6) = dpixel;
#line 1033
      *(xline + 166) = dpixel;
#line 1034
      *(xline + 326) = dpixel;
#line 1035
      *(xline + 486) = dpixel;
#line 1037
      dpixel = *((double *)((unsigned int )((int )exp___0) + ((fourpixels & 65535U) << 3)));
#line 1038
      *(xline + 7) = dpixel;
#line 1039
      *(xline + 167) = dpixel;
#line 1040
      *(xline + 327) = dpixel;
#line 1041
      *(xline + 487) = dpixel;
#line 1043
      lineptr += 4;
#line 1044
      xline += 8;
#line 985
      x___0 -= 16U;
#line 985
      if (! x___0) {
#line 985
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1046
    xline += step;
#line 981
    tmp = y___1;
#line 981
    y___1 --;
#line 981
    if (! tmp) {
#line 981
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1048
  return;
}
}
#line 23 "i_net.c"
static char const   rcsid___5[49]  = 
#line 23 "i_net.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'b', 
        (char const   )'b',      (char const   )'o',      (char const   )'x',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 34 "/usr/include/arpa/inet.h"
extern in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp )  __attribute__((__nothrow__)) ;
#line 37
extern in_addr_t ( __attribute__((__leaf__)) inet_lnaof)(struct in_addr __in )  __attribute__((__nothrow__)) ;
#line 41
extern struct in_addr ( __attribute__((__leaf__)) inet_makeaddr)(in_addr_t __net ,
                                                                 in_addr_t __host )  __attribute__((__nothrow__)) ;
#line 45
extern in_addr_t ( __attribute__((__leaf__)) inet_netof)(struct in_addr __in )  __attribute__((__nothrow__)) ;
#line 49
extern in_addr_t ( __attribute__((__leaf__)) inet_network)(char const   *__cp )  __attribute__((__nothrow__)) ;
#line 53
extern char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in )  __attribute__((__nothrow__)) ;
#line 58
extern int ( __attribute__((__leaf__)) inet_pton)(int __af , char const   * __restrict  __cp ,
                                                  void * __restrict  __buf )  __attribute__((__nothrow__)) ;
#line 64
extern char const   *( __attribute__((__leaf__)) inet_ntop)(int __af , void const   * __restrict  __cp ,
                                                            char * __restrict  __buf ,
                                                            socklen_t __len )  __attribute__((__nothrow__)) ;
#line 73
extern int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp , struct in_addr *__inp )  __attribute__((__nothrow__)) ;
#line 77
extern char *( __attribute__((__leaf__)) inet_neta)(in_addr_t __net , char *__buf ,
                                                    size_t __len )  __attribute__((__nothrow__,
__deprecated__("Use inet_ntop instead"))) ;
#line 83
extern char *( __attribute__((__leaf__)) inet_net_ntop)(int __af , void const   *__cp ,
                                                        int __bits , char *__buf ,
                                                        size_t __len )  __attribute__((__nothrow__)) ;
#line 89
extern int ( __attribute__((__leaf__)) inet_net_pton)(int __af , char const   *__cp ,
                                                      void *__buf , size_t __len )  __attribute__((__nothrow__)) ;
#line 95
extern unsigned int ( __attribute__((__leaf__)) inet_nsap_addr)(char const   *__cp ,
                                                                unsigned char *__buf ,
                                                                int __len )  __attribute__((__nothrow__)) ;
#line 100
extern char *( __attribute__((__leaf__)) inet_nsap_ntoa)(int __len , unsigned char const   *__cp ,
                                                         char *__buf )  __attribute__((__nothrow__)) ;
#line 53 "/usr/include/rpc/netdb.h"
extern void ( __attribute__((__leaf__)) setrpcent)(int __stayopen )  __attribute__((__nothrow__)) ;
#line 54
extern void ( __attribute__((__leaf__)) endrpcent)(void)  __attribute__((__nothrow__)) ;
#line 55
extern struct rpcent *( __attribute__((__leaf__)) getrpcbyname)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 56
extern struct rpcent *( __attribute__((__leaf__)) getrpcbynumber)(int __number )  __attribute__((__nothrow__)) ;
#line 57
extern struct rpcent *( __attribute__((__leaf__)) getrpcent)(void)  __attribute__((__nothrow__)) ;
#line 60
extern int ( __attribute__((__leaf__)) getrpcbyname_r)(char const   *__name , struct rpcent *__result_buf ,
                                                       char *__buffer , size_t __buflen ,
                                                       struct rpcent **__result )  __attribute__((__nothrow__)) ;
#line 64
extern int ( __attribute__((__leaf__)) getrpcbynumber_r)(int __number , struct rpcent *__result_buf ,
                                                         char *__buffer , size_t __buflen ,
                                                         struct rpcent **__result )  __attribute__((__nothrow__)) ;
#line 68
extern int ( __attribute__((__leaf__)) getrpcent_r)(struct rpcent *__result_buf ,
                                                    char *__buffer , size_t __buflen ,
                                                    struct rpcent **__result )  __attribute__((__nothrow__)) ;
#line 59 "/usr/include/netdb.h"
extern int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 90
extern void ( __attribute__((__leaf__)) herror)(char const   *__str )  __attribute__((__nothrow__)) ;
#line 93
extern char const   *( __attribute__((__leaf__)) hstrerror)(int __err_num )  __attribute__((__nothrow__)) ;
#line 115
extern void sethostent(int __stay_open ) ;
#line 121
extern void endhostent(void) ;
#line 128
extern struct hostent *gethostent(void) ;
#line 135
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 142
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 153
extern struct hostent *gethostbyname2(char const   *__name , int __af ) ;
#line 165
extern int gethostent_r(struct hostent * __restrict  __result_buf , char * __restrict  __buf ,
                        size_t __buflen , struct hostent ** __restrict  __result ,
                        int * __restrict  __h_errnop ) ;
#line 170
extern int gethostbyaddr_r(void const   * __restrict  __addr , __socklen_t __len ,
                           int __type , struct hostent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                           int * __restrict  __h_errnop ) ;
#line 177
extern int gethostbyname_r(char const   * __restrict  __name , struct hostent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                           int * __restrict  __h_errnop ) ;
#line 183
extern int gethostbyname2_r(char const   * __restrict  __name , int __af , struct hostent * __restrict  __result_buf ,
                            char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                            int * __restrict  __h_errnop ) ;
#line 196
extern void setnetent(int __stay_open ) ;
#line 202
extern void endnetent(void) ;
#line 209
extern struct netent *getnetent(void) ;
#line 216
extern struct netent *getnetbyaddr(uint32_t __net , int __type ) ;
#line 222
extern struct netent *getnetbyname(char const   *__name ) ;
#line 235
extern int getnetent_r(struct netent * __restrict  __result_buf , char * __restrict  __buf ,
                       size_t __buflen , struct netent ** __restrict  __result , int * __restrict  __h_errnop ) ;
#line 240
extern int getnetbyaddr_r(uint32_t __net , int __type , struct netent * __restrict  __result_buf ,
                          char * __restrict  __buf , size_t __buflen , struct netent ** __restrict  __result ,
                          int * __restrict  __h_errnop ) ;
#line 246
extern int getnetbyname_r(char const   * __restrict  __name , struct netent * __restrict  __result_buf ,
                          char * __restrict  __buf , size_t __buflen , struct netent ** __restrict  __result ,
                          int * __restrict  __h_errnop ) ;
#line 268
extern void setservent(int __stay_open ) ;
#line 274
extern void endservent(void) ;
#line 281
extern struct servent *getservent(void) ;
#line 288
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 295
extern struct servent *getservbyport(int __port , char const   *__proto ) ;
#line 306
extern int getservent_r(struct servent * __restrict  __result_buf , char * __restrict  __buf ,
                        size_t __buflen , struct servent ** __restrict  __result ) ;
#line 310
extern int getservbyname_r(char const   * __restrict  __name , char const   * __restrict  __proto ,
                           struct servent * __restrict  __result_buf , char * __restrict  __buf ,
                           size_t __buflen , struct servent ** __restrict  __result ) ;
#line 316
extern int getservbyport_r(int __port , char const   * __restrict  __proto , struct servent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct servent ** __restrict  __result ) ;
#line 336
extern void setprotoent(int __stay_open ) ;
#line 342
extern void endprotoent(void) ;
#line 349
extern struct protoent *getprotoent(void) ;
#line 355
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 361
extern struct protoent *getprotobynumber(int __proto ) ;
#line 372
extern int getprotoent_r(struct protoent * __restrict  __result_buf , char * __restrict  __buf ,
                         size_t __buflen , struct protoent ** __restrict  __result ) ;
#line 376
extern int getprotobyname_r(char const   * __restrict  __name , struct protoent * __restrict  __result_buf ,
                            char * __restrict  __buf , size_t __buflen , struct protoent ** __restrict  __result ) ;
#line 381
extern int getprotobynumber_r(int __proto , struct protoent * __restrict  __result_buf ,
                              char * __restrict  __buf , size_t __buflen , struct protoent ** __restrict  __result ) ;
#line 393
extern int setnetgrent(char const   *__netgroup ) ;
#line 401
extern void endnetgrent(void) ;
#line 410
extern int getnetgrent(char ** __restrict  __hostp , char ** __restrict  __userp ,
                       char ** __restrict  __domainp ) ;
#line 421
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *__domain ) ;
#line 430
extern int getnetgrent_r(char ** __restrict  __hostp , char ** __restrict  __userp ,
                         char ** __restrict  __domainp , char * __restrict  __buffer ,
                         size_t __buflen ) ;
#line 449
extern int rcmd(char ** __restrict  __ahost , unsigned short __rport , char const   * __restrict  __locuser ,
                char const   * __restrict  __remuser , char const   * __restrict  __cmd ,
                int * __restrict  __fd2p ) ;
#line 461
extern int rcmd_af(char ** __restrict  __ahost , unsigned short __rport , char const   * __restrict  __locuser ,
                   char const   * __restrict  __remuser , char const   * __restrict  __cmd ,
                   int * __restrict  __fd2p , sa_family_t __af ) ;
#line 477
extern int rexec(char ** __restrict  __ahost , int __rport , char const   * __restrict  __name ,
                 char const   * __restrict  __pass , char const   * __restrict  __cmd ,
                 int * __restrict  __fd2p ) ;
#line 489
extern int rexec_af(char ** __restrict  __ahost , int __rport , char const   * __restrict  __name ,
                    char const   * __restrict  __pass , char const   * __restrict  __cmd ,
                    int * __restrict  __fd2p , sa_family_t __af ) ;
#line 503
extern int ruserok(char const   *__rhost , int __suser , char const   *__remuser ,
                   char const   *__locuser ) ;
#line 513
extern int ruserok_af(char const   *__rhost , int __suser , char const   *__remuser ,
                      char const   *__locuser , sa_family_t __af ) ;
#line 526
extern int iruserok(uint32_t __raddr , int __suser , char const   *__remuser , char const   *__locuser ) ;
#line 537
extern int iruserok_af(void const   *__raddr , int __suser , char const   *__remuser ,
                       char const   *__locuser , sa_family_t __af ) ;
#line 549
extern int rresvport(int *__alport ) ;
#line 558
extern int rresvport_af(int *__alport , sa_family_t __af ) ;
#line 660
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 666
extern void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai )  __attribute__((__nothrow__)) ;
#line 669
extern char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode )  __attribute__((__nothrow__)) ;
#line 675
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 36 "i_net.h"
void I_InitNetwork(void) ;
#line 37
void I_NetCmd(void) ;
#line 68 "i_net.c"
extern void NetSend(void) ;
#line 69
extern boolean NetListen(void) ;
#line 76 "i_net.c"
int DOOMPORT  =    5029;
#line 78 "i_net.c"
int sendsocket  ;
#line 79 "i_net.c"
int insocket  ;
#line 81 "i_net.c"
struct sockaddr_in sendaddress[8]  ;
#line 83 "i_net.c"
void (*netget)(void)  ;
#line 84 "i_net.c"
void (*netsend)(void)  ;
#line 90 "i_net.c"
int UDPsocket(void) 
{ 
  int s ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 95
  s = socket(2, 2, 17);
#line 96
  if (s < 0) {
#line 97
    tmp = __errno_location();
#line 97
    tmp___0 = strerror(*tmp);
#line 97
    I_Error("can\'t create socket: %s", tmp___0);
  }
#line 99
  return (s);
}
}
#line 105 "i_net.c"
void BindToLocalPort(int s , int port ) 
{ 
  int v ;
  struct sockaddr_in address ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 113
  memset((void *)(& address), 0, (size_t )sizeof(address));
#line 114
  address.sin_family = (sa_family_t )2;
#line 115
  address.sin_addr.s_addr = (in_addr_t )0x00000000;
#line 116
  address.sin_port = (in_port_t )port;
#line 118
  v = bind(s, (struct sockaddr  const  *)((void *)(& address)), (socklen_t )sizeof(address));
#line 119
  if (v == -1) {
#line 120
    tmp = __errno_location();
#line 120
    tmp___0 = strerror(*tmp);
#line 120
    I_Error("BindToPort: bind: %s", tmp___0);
  }
#line 121
  return;
}
}
#line 127 "i_net.c"
void PacketSend(void) 
{ 
  int c ;
  doomdata_t sw ;

  {
#line 133
  sw.checksum = (unsigned int )((((((unsigned long )netbuffer->checksum & 255UL) << 24) | (((unsigned long )netbuffer->checksum & 65280UL) << 8)) | (((unsigned long )netbuffer->checksum & 16711680UL) >> 8)) | (((unsigned long )netbuffer->checksum & 4278190080UL) >> 24));
#line 134
  sw.player = netbuffer->player;
#line 135
  sw.retransmitfrom = netbuffer->retransmitfrom;
#line 136
  sw.starttic = netbuffer->starttic;
#line 137
  sw.numtics = netbuffer->numtics;
#line 138
  c = 0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (c < (int )netbuffer->numtics)) {
#line 138
      goto while_break;
    }
#line 140
    sw.cmds[c].forwardmove = netbuffer->cmds[c].forwardmove;
#line 141
    sw.cmds[c].sidemove = netbuffer->cmds[c].sidemove;
#line 142
    sw.cmds[c].angleturn = (short )((unsigned short )((((int )((unsigned short )netbuffer->cmds[c].angleturn) & 0x00ff) << 8) | (((int )((unsigned short )netbuffer->cmds[c].angleturn) & 0xff00) >> 8)));
#line 143
    sw.cmds[c].consistancy = (short )((unsigned short )((((int )((unsigned short )netbuffer->cmds[c].consistancy) & 0x00ff) << 8) | (((int )((unsigned short )netbuffer->cmds[c].consistancy) & 0xff00) >> 8)));
#line 144
    sw.cmds[c].chatchar = netbuffer->cmds[c].chatchar;
#line 145
    sw.cmds[c].buttons = netbuffer->cmds[c].buttons;
#line 138
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  c = sendto(sendsocket, (void const   *)(& sw), (size_t )doomcom->datalength, 0,
             (struct sockaddr  const  *)((void *)(& sendaddress[doomcom->remotenode])),
             (socklen_t )sizeof(sendaddress[doomcom->remotenode]));
#line 155
  return;
}
}
#line 181
void PacketGet(void) ;
#line 181 "i_net.c"
static int first  =    1;
#line 161 "i_net.c"
void PacketGet(void) 
{ 
  int i ;
  int c ;
  struct sockaddr_in fromaddress ;
  int fromlen ;
  doomdata_t sw ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 169
  fromlen = (int )sizeof(fromaddress);
#line 170
  c = recvfrom(insocket, (void * __restrict  )(& sw), (size_t )sizeof(sw), 0, (struct sockaddr * __restrict  )((struct sockaddr *)(& fromaddress)),
               (socklen_t * __restrict  )(& fromlen));
#line 172
  if (c == -1) {
#line 174
    tmp___1 = __errno_location();
#line 174
    if (*tmp___1 != 11) {
#line 175
      tmp = __errno_location();
#line 175
      tmp___0 = strerror(*tmp);
#line 175
      I_Error("GetPacket: %s", tmp___0);
    }
#line 176
    doomcom->remotenode = (short)-1;
#line 177
    return;
  }
#line 182
  if (first) {
#line 183
    printf((char const   * __restrict  )"len=%d:p=[0x%x 0x%x] \n", c, *((int *)(& sw)),
           *((int *)(& sw) + 1));
  }
#line 184
  first = 0;
#line 188
  i = 0;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (i < (int )doomcom->numnodes)) {
#line 188
      goto while_break;
    }
#line 189
    if (fromaddress.sin_addr.s_addr == sendaddress[i].sin_addr.s_addr) {
#line 190
      goto while_break;
    }
#line 188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if (i == (int )doomcom->numnodes) {
#line 195
    doomcom->remotenode = (short)-1;
#line 196
    return;
  }
#line 199
  doomcom->remotenode = (short )i;
#line 200
  doomcom->datalength = (short )c;
#line 203
  netbuffer->checksum = (unsigned int )((((((unsigned long )sw.checksum & 255UL) << 24) | (((unsigned long )sw.checksum & 65280UL) << 8)) | (((unsigned long )sw.checksum & 16711680UL) >> 8)) | (((unsigned long )sw.checksum & 4278190080UL) >> 24));
#line 204
  netbuffer->player = sw.player;
#line 205
  netbuffer->retransmitfrom = sw.retransmitfrom;
#line 206
  netbuffer->starttic = sw.starttic;
#line 207
  netbuffer->numtics = sw.numtics;
#line 209
  c = 0;
  {
#line 209
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 209
    if (! (c < (int )netbuffer->numtics)) {
#line 209
      goto while_break___0;
    }
#line 211
    netbuffer->cmds[c].forwardmove = sw.cmds[c].forwardmove;
#line 212
    netbuffer->cmds[c].sidemove = sw.cmds[c].sidemove;
#line 213
    netbuffer->cmds[c].angleturn = (short )((unsigned short )((((int )((unsigned short )sw.cmds[c].angleturn) & 0x00ff) << 8) | (((int )((unsigned short )sw.cmds[c].angleturn) & 0xff00) >> 8)));
#line 214
    netbuffer->cmds[c].consistancy = (short )((unsigned short )((((int )((unsigned short )sw.cmds[c].consistancy) & 0x00ff) << 8) | (((int )((unsigned short )sw.cmds[c].consistancy) & 0xff00) >> 8)));
#line 215
    netbuffer->cmds[c].chatchar = sw.cmds[c].chatchar;
#line 216
    netbuffer->cmds[c].buttons = sw.cmds[c].buttons;
#line 209
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 222 "i_net.c"
int GetLocalAddress(void) 
{ 
  char hostname[1024] ;
  struct hostent *hostentry ;
  int v ;
  int *tmp ;

  {
#line 229
  v = gethostname(hostname, (size_t )sizeof(hostname));
#line 230
  if (v == -1) {
#line 231
    tmp = __errno_location();
#line 231
    I_Error("GetLocalAddress : gethostname: errno %d", *tmp);
  }
#line 233
  hostentry = gethostbyname((char const   *)(hostname));
#line 234
  if (! hostentry) {
#line 235
    I_Error("GetLocalAddress : gethostbyname: couldn\'t get local host");
  }
#line 237
  return (*((int *)*(hostentry->h_addr_list + 0)));
}
}
#line 244 "i_net.c"
void I_InitNetwork(void) 
{ 
  boolean trueval ;
  int i ;
  int p___0 ;
  struct hostent *hostentry ;
  void *tmp ;
  int tmp___0 ;
  short tmp___1 ;

  {
#line 246
  trueval = (boolean )1;
#line 251
  tmp = malloc((size_t )sizeof(*doomcom));
#line 251
  doomcom = (doomcom_t *)tmp;
#line 252
  memset((void *)doomcom, 0, (size_t )sizeof(*doomcom));
#line 255
  i = M_CheckParm("-dup");
#line 256
  if (i) {
#line 256
    if (i < myargc - 1) {
#line 258
      doomcom->ticdup = (short )((int )*(*(myargv + (i + 1)) + 0) - 48);
#line 259
      if ((int )doomcom->ticdup < 1) {
#line 260
        doomcom->ticdup = (short)1;
      }
#line 261
      if ((int )doomcom->ticdup > 9) {
#line 262
        doomcom->ticdup = (short)9;
      }
    } else {
#line 256
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 265
    doomcom->ticdup = (short)1;
  }
#line 267
  tmp___0 = M_CheckParm("-extratic");
#line 267
  if (tmp___0) {
#line 268
    doomcom->extratics = (short)1;
  } else {
#line 270
    doomcom->extratics = (short)0;
  }
#line 272
  p___0 = M_CheckParm("-port");
#line 273
  if (p___0) {
#line 273
    if (p___0 < myargc - 1) {
#line 275
      DOOMPORT = atoi((char const   *)*(myargv + (p___0 + 1)));
#line 276
      printf((char const   * __restrict  )"using alternate port %i\n", DOOMPORT);
    } else {
#line 273
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 281
  i = M_CheckParm("-net");
#line 282
  if (! i) {
#line 285
    netgame = (boolean )0;
#line 286
    doomcom->id = 0x12345678l;
#line 287
    tmp___1 = (short)1;
#line 287
    doomcom->numnodes = tmp___1;
#line 287
    doomcom->numplayers = tmp___1;
#line 288
    doomcom->deathmatch = (short)0;
#line 289
    doomcom->consoleplayer = (short)0;
#line 290
    return;
  }
#line 293
  netsend = & PacketSend;
#line 294
  netget = & PacketGet;
#line 295
  netgame = (boolean )1;
#line 298
  doomcom->consoleplayer = (short )((int )*(*(myargv + (i + 1)) + 0) - 49);
#line 300
  doomcom->numnodes = (short)1;
#line 302
  i ++;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    i ++;
#line 303
    if (i < myargc) {
#line 303
      if (! ((int )*(*(myargv + i) + 0) != 45)) {
#line 303
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 303
      goto while_break;
    }
#line 305
    sendaddress[doomcom->numnodes].sin_family = (sa_family_t )2;
#line 306
    sendaddress[doomcom->numnodes].sin_port = (unsigned short )((((int )((unsigned short )DOOMPORT) & 0x00ff) << 8) | (((int )((unsigned short )DOOMPORT) & 0xff00) >> 8));
#line 307
    if ((int )*(*(myargv + i) + 0) == 46) {
#line 309
      sendaddress[doomcom->numnodes].sin_addr.s_addr = inet_addr((char const   *)(*(myargv + i) + 1));
    } else {
#line 314
      hostentry = gethostbyname((char const   *)*(myargv + i));
#line 315
      if (! hostentry) {
#line 316
        I_Error("gethostbyname: couldn\'t find %s", *(myargv + i));
      }
#line 317
      sendaddress[doomcom->numnodes].sin_addr.s_addr = (in_addr_t )*((int *)*(hostentry->h_addr_list + 0));
    }
#line 320
    doomcom->numnodes = (short )((int )doomcom->numnodes + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  doomcom->id = 0x12345678l;
#line 324
  doomcom->numplayers = doomcom->numnodes;
#line 327
  insocket = UDPsocket();
#line 328
  BindToLocalPort(insocket, (int )((unsigned short )((((int )((unsigned short )DOOMPORT) & 0x00ff) << 8) | (((int )((unsigned short )DOOMPORT) & 0xff00) >> 8))));
#line 329
  ioctl(insocket, 21537UL, & trueval);
#line 331
  sendsocket = UDPsocket();
#line 332
  return;
}
}
#line 335 "i_net.c"
void I_NetCmd(void) 
{ 


  {
#line 337
  if ((int )doomcom->command == 1) {
#line 339
    (*netsend)();
  } else
#line 341
  if ((int )doomcom->command == 2) {
#line 343
    (*netget)();
  } else {
#line 346
    I_Error("Bad net cmd: %i\n", (int )doomcom->command);
  }
#line 347
  return;
}
}
#line 39 "tables.c"
static char const   rcsid___6[49]  = 
#line 39 "tables.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'4',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'1', 
        (char const   )'6',      (char const   )':',      (char const   )'4',      (char const   )'7', 
        (char const   )':',      (char const   )'5',      (char const   )'7',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 49 "tables.c"
int SlopeDiv(unsigned int num___0 , unsigned int den ) 
{ 
  unsigned int ans ;
  unsigned int tmp ;

  {
#line 56
  if (den < 512U) {
#line 57
    return (2048);
  }
#line 59
  ans = (num___0 << 3) / (den >> 8);
#line 61
  if (ans <= 2048U) {
#line 61
    tmp = ans;
  } else {
#line 61
    tmp = 2048U;
  }
#line 61
  return ((int )tmp);
}
}
#line 67 "tables.c"
int finetangent[4096]  = 
#line 67
  {      -170910304,      -56965752,      -34178904,      -24413316, 
        -18988036,      -15535599,      -13145455,      -11392683, 
        -10052327,      -8994149,      -8137527,      -7429880, 
        -6835455,      -6329090,      -5892567,      -5512368, 
        -5178251,      -4882318,      -4618375,      -4381502, 
        -4167737,      -3973855,      -3797206,      -3635590, 
        -3487165,      -3350381,      -3223918,      -3106651, 
        -2997613,      -2895966,      -2800983,      -2712030, 
        -2628549,      -2550052,      -2476104,      -2406322, 
        -2340362,      -2277919,      -2218719,      -2162516, 
        -2109087,      -2058233,      -2009771,      -1963536, 
        -1919378,      -1877161,      -1836758,      -1798063, 
        -1760956,      -1725348,      -1691149,      -1658278, 
        -1626658,      -1596220,      -1566898,      -1538632, 
        -1511367,      -1485049,      -1459630,      -1435065, 
        -1411312,      -1388330,      -1366084,      -1344537, 
        -1323658,      -1303416,      -1283783,      -1264730, 
        -1246234,      -1228269,      -1210813,      -1193846, 
        -1177345,      -1161294,      -1145673,      -1130465, 
        -1115654,      -1101225,      -1087164,      -1073455, 
        -1060087,      -1047046,      -1034322,      -1021901, 
        -1009774,      -997931,      -986361,      -975054, 
        -964003,      -953199,      -942633,      -932298, 
        -922186,      -912289,      -902602,      -893117, 
        -883829,      -874730,      -865817,      -857081, 
        -848520,      -840127,      -831898,      -823827, 
        -815910,      -808143,      -800521,      -793041, 
        -785699,      -778490,      -771411,      -764460, 
        -757631,      -750922,      -744331,      -737853, 
        -731486,      -725227,      -719074,      -713023, 
        -707072,      -701219,      -695462,      -689797, 
        -684223,      -678737,      -673338,      -668024, 
        -662792,      -657640,      -652568,      -647572, 
        -642651,      -637803,      -633028,      -628323, 
        -623686,      -619117,      -614613,      -610174, 
        -605798,      -601483,      -597229,      -593033, 
        -588896,      -584815,      -580789,      -576818, 
        -572901,      -569035,      -565221,      -561456, 
        -557741,      -554074,      -550455,      -546881, 
        -543354,      -539870,      -536431,      -533034, 
        -529680,      -526366,      -523094,      -519861, 
        -516667,      -513512,      -510394,      -507313, 
        -504269,      -501261,      -498287,      -495348, 
        -492443,      -489571,      -486732,      -483925, 
        -481150,      -478406,      -475692,      -473009, 
        -470355,      -467730,      -465133,      -462565, 
        -460024,      -457511,      -455024,      -452564, 
        -450129,      -447720,      -445337,      -442978, 
        -440643,      -438332,      -436045,      -433781, 
        -431540,      -429321,      -427125,      -424951, 
        -422798,      -420666,      -418555,      -416465, 
        -414395,      -412344,      -410314,      -408303, 
        -406311,      -404338,      -402384,      -400448, 
        -398530,      -396630,      -394747,      -392882, 
        -391034,      -389202,      -387387,      -385589, 
        -383807,      -382040,      -380290,      -378555, 
        -376835,      -375130,      -373440,      -371765, 
        -370105,      -368459,      -366826,      -365208, 
        -363604,      -362013,      -360436,      -358872, 
        -357321,      -355783,      -354257,      -352744, 
        -351244,      -349756,      -348280,      -346816, 
        -345364,      -343924,      -342495,      -341078, 
        -339671,      -338276,      -336892,      -335519, 
        -334157,      -332805,      -331464,      -330133, 
        -328812,      -327502,      -326201,      -324910, 
        -323629,      -322358,      -321097,      -319844, 
        -318601,      -317368,      -316143,      -314928, 
        -313721,      -312524,      -311335,      -310154, 
        -308983,      -307819,      -306664,      -305517, 
        -304379,      -303248,      -302126,      -301011, 
        -299904,      -298805,      -297714,      -296630, 
        -295554,      -294485,      -293423,      -292369, 
        -291322,      -290282,      -289249,      -288223, 
        -287204,      -286192,      -285186,      -284188, 
        -283195,      -282210,      -281231,      -280258, 
        -279292,      -278332,      -277378,      -276430, 
        -275489,      -274553,      -273624,      -272700, 
        -271782,      -270871,      -269965,      -269064, 
        -268169,      -267280,      -266397,      -265519, 
        -264646,      -263779,      -262917,      -262060, 
        -261209,      -260363,      -259522,      -258686, 
        -257855,      -257029,      -256208,      -255392, 
        -254581,      -253774,      -252973,      -252176, 
        -251384,      -250596,      -249813,      -249035, 
        -248261,      -247492,      -246727,      -245966, 
        -245210,      -244458,      -243711,      -242967, 
        -242228,      -241493,      -240763,      -240036, 
        -239314,      -238595,      -237881,      -237170, 
        -236463,      -235761,      -235062,      -234367, 
        -233676,      -232988,      -232304,      -231624, 
        -230948,      -230275,      -229606,      -228941, 
        -228279,      -227621,      -226966,      -226314, 
        -225666,      -225022,      -224381,      -223743, 
        -223108,      -222477,      -221849,      -221225, 
        -220603,      -219985,      -219370,      -218758, 
        -218149,      -217544,      -216941,      -216341, 
        -215745,      -215151,      -214561,      -213973, 
        -213389,      -212807,      -212228,      -211652, 
        -211079,      -210509,      -209941,      -209376, 
        -208815,      -208255,      -207699,      -207145, 
        -206594,      -206045,      -205500,      -204956, 
        -204416,      -203878,      -203342,      -202809, 
        -202279,      -201751,      -201226,      -200703, 
        -200182,      -199664,      -199149,      -198636, 
        -198125,      -197616,      -197110,      -196606, 
        -196105,      -195606,      -195109,      -194614, 
        -194122,      -193631,      -193143,      -192658, 
        -192174,      -191693,      -191213,      -190736, 
        -190261,      -189789,      -189318,      -188849, 
        -188382,      -187918,      -187455,      -186995, 
        -186536,      -186080,      -185625,      -185173, 
        -184722,      -184274,      -183827,      -183382, 
        -182939,      -182498,      -182059,      -181622, 
        -181186,      -180753,      -180321,      -179891, 
        -179463,      -179037,      -178612,      -178190, 
        -177769,      -177349,      -176932,      -176516, 
        -176102,      -175690,      -175279,      -174870, 
        -174463,      -174057,      -173653,      -173251, 
        -172850,      -172451,      -172053,      -171657, 
        -171263,      -170870,      -170479,      -170089, 
        -169701,      -169315,      -168930,      -168546, 
        -168164,      -167784,      -167405,      -167027, 
        -166651,      -166277,      -165904,      -165532, 
        -165162,      -164793,      -164426,      -164060, 
        -163695,      -163332,      -162970,      -162610, 
        -162251,      -161893,      -161537,      -161182, 
        -160828,      -160476,      -160125,      -159775, 
        -159427,      -159079,      -158734,      -158389, 
        -158046,      -157704,      -157363,      -157024, 
        -156686,      -156349,      -156013,      -155678, 
        -155345,      -155013,      -154682,      -154352, 
        -154024,      -153697,      -153370,      -153045, 
        -152722,      -152399,      -152077,      -151757, 
        -151438,      -151120,      -150803,      -150487, 
        -150172,      -149859,      -149546,      -149235, 
        -148924,      -148615,      -148307,      -148000, 
        -147693,      -147388,      -147084,      -146782, 
        -146480,      -146179,      -145879,      -145580, 
        -145282,      -144986,      -144690,      -144395, 
        -144101,      -143808,      -143517,      -143226, 
        -142936,      -142647,      -142359,      -142072, 
        -141786,      -141501,      -141217,      -140934, 
        -140651,      -140370,      -140090,      -139810, 
        -139532,      -139254,      -138977,      -138701, 
        -138426,      -138152,      -137879,      -137607, 
        -137335,      -137065,      -136795,      -136526, 
        -136258,      -135991,      -135725,      -135459, 
        -135195,      -134931,      -134668,      -134406, 
        -134145,      -133884,      -133625,      -133366, 
        -133108,      -132851,      -132594,      -132339, 
        -132084,      -131830,      -131576,      -131324, 
        -131072,      -130821,      -130571,      -130322, 
        -130073,      -129825,      -129578,      -129332, 
        -129086,      -128841,      -128597,      -128353, 
        -128111,      -127869,      -127627,      -127387, 
        -127147,      -126908,      -126669,      -126432, 
        -126195,      -125959,      -125723,      -125488, 
        -125254,      -125020,      -124787,      -124555, 
        -124324,      -124093,      -123863,      -123633, 
        -123404,      -123176,      -122949,      -122722, 
        -122496,      -122270,      -122045,      -121821, 
        -121597,      -121374,      -121152,      -120930, 
        -120709,      -120489,      -120269,      -120050, 
        -119831,      -119613,      -119396,      -119179, 
        -118963,      -118747,      -118532,      -118318, 
        -118104,      -117891,      -117678,      -117466, 
        -117254,      -117044,      -116833,      -116623, 
        -116414,      -116206,      -115998,      -115790, 
        -115583,      -115377,      -115171,      -114966, 
        -114761,      -114557,      -114354,      -114151, 
        -113948,      -113746,      -113545,      -113344, 
        -113143,      -112944,      -112744,      -112546, 
        -112347,      -112150,      -111952,      -111756, 
        -111560,      -111364,      -111169,      -110974, 
        -110780,      -110586,      -110393,      -110200, 
        -110008,      -109817,      -109626,      -109435, 
        -109245,      -109055,      -108866,      -108677, 
        -108489,      -108301,      -108114,      -107927, 
        -107741,      -107555,      -107369,      -107184, 
        -107000,      -106816,      -106632,      -106449, 
        -106266,      -106084,      -105902,      -105721, 
        -105540,      -105360,      -105180,      -105000, 
        -104821,      -104643,      -104465,      -104287, 
        -104109,      -103933,      -103756,      -103580, 
        -103404,      -103229,      -103054,      -102880, 
        -102706,      -102533,      -102360,      -102187, 
        -102015,      -101843,      -101671,      -101500, 
        -101330,      -101159,      -100990,      -100820, 
        -100651,      -100482,      -100314,      -100146, 
        -99979,      -99812,      -99645,      -99479, 
        -99313,      -99148,      -98982,      -98818, 
        -98653,      -98489,      -98326,      -98163, 
        -98000,      -97837,      -97675,      -97513, 
        -97352,      -97191,      -97030,      -96870, 
        -96710,      -96551,      -96391,      -96233, 
        -96074,      -95916,      -95758,      -95601, 
        -95444,      -95287,      -95131,      -94975, 
        -94819,      -94664,      -94509,      -94354, 
        -94200,      -94046,      -93892,      -93739, 
        -93586,      -93434,      -93281,      -93129, 
        -92978,      -92826,      -92675,      -92525, 
        -92375,      -92225,      -92075,      -91926, 
        -91777,      -91628,      -91480,      -91332, 
        -91184,      -91036,      -90889,      -90742, 
        -90596,      -90450,      -90304,      -90158, 
        -90013,      -89868,      -89724,      -89579, 
        -89435,      -89292,      -89148,      -89005, 
        -88862,      -88720,      -88577,      -88435, 
        -88294,      -88152,      -88011,      -87871, 
        -87730,      -87590,      -87450,      -87310, 
        -87171,      -87032,      -86893,      -86755, 
        -86616,      -86479,      -86341,      -86204, 
        -86066,      -85930,      -85793,      -85657, 
        -85521,      -85385,      -85250,      -85114, 
        -84980,      -84845,      -84710,      -84576, 
        -84443,      -84309,      -84176,      -84043, 
        -83910,      -83777,      -83645,      -83513, 
        -83381,      -83250,      -83118,      -82987, 
        -82857,      -82726,      -82596,      -82466, 
        -82336,      -82207,      -82078,      -81949, 
        -81820,      -81691,      -81563,      -81435, 
        -81307,      -81180,      -81053,      -80925, 
        -80799,      -80672,      -80546,      -80420, 
        -80294,      -80168,      -80043,      -79918, 
        -79793,      -79668,      -79544,      -79420, 
        -79296,      -79172,      -79048,      -78925, 
        -78802,      -78679,      -78557,      -78434, 
        -78312,      -78190,      -78068,      -77947, 
        -77826,      -77705,      -77584,      -77463, 
        -77343,      -77223,      -77103,      -76983, 
        -76864,      -76744,      -76625,      -76506, 
        -76388,      -76269,      -76151,      -76033, 
        -75915,      -75797,      -75680,      -75563, 
        -75446,      -75329,      -75213,      -75096, 
        -74980,      -74864,      -74748,      -74633, 
        -74517,      -74402,      -74287,      -74172, 
        -74058,      -73944,      -73829,      -73715, 
        -73602,      -73488,      -73375,      -73262, 
        -73149,      -73036,      -72923,      -72811, 
        -72699,      -72587,      -72475,      -72363, 
        -72252,      -72140,      -72029,      -71918, 
        -71808,      -71697,      -71587,      -71477, 
        -71367,      -71257,      -71147,      -71038, 
        -70929,      -70820,      -70711,      -70602, 
        -70494,      -70385,      -70277,      -70169, 
        -70061,      -69954,      -69846,      -69739, 
        -69632,      -69525,      -69418,      -69312, 
        -69205,      -69099,      -68993,      -68887, 
        -68781,      -68676,      -68570,      -68465, 
        -68360,      -68255,      -68151,      -68046, 
        -67942,      -67837,      -67733,      -67629, 
        -67526,      -67422,      -67319,      -67216, 
        -67113,      -67010,      -66907,      -66804, 
        -66702,      -66600,      -66498,      -66396, 
        -66294,      -66192,      -66091,      -65989, 
        -65888,      -65787,      -65686,      -65586, 
        -65485,      -65385,      -65285,      -65185, 
        -65085,      -64985,      -64885,      -64786, 
        -64687,      -64587,      -64488,      -64389, 
        -64291,      -64192,      -64094,      -63996, 
        -63897,      -63799,      -63702,      -63604, 
        -63506,      -63409,      -63312,      -63215, 
        -63118,      -63021,      -62924,      -62828, 
        -62731,      -62635,      -62539,      -62443, 
        -62347,      -62251,      -62156,      -62060, 
        -61965,      -61870,      -61775,      -61680, 
        -61585,      -61491,      -61396,      -61302, 
        -61208,      -61114,      -61020,      -60926, 
        -60833,      -60739,      -60646,      -60552, 
        -60459,      -60366,      -60273,      -60181, 
        -60088,      -59996,      -59903,      -59811, 
        -59719,      -59627,      -59535,      -59444, 
        -59352,      -59261,      -59169,      -59078, 
        -58987,      -58896,      -58805,      -58715, 
        -58624,      -58534,      -58443,      -58353, 
        -58263,      -58173,      -58083,      -57994, 
        -57904,      -57815,      -57725,      -57636, 
        -57547,      -57458,      -57369,      -57281, 
        -57192,      -57104,      -57015,      -56927, 
        -56839,      -56751,      -56663,      -56575, 
        -56487,      -56400,      -56312,      -56225, 
        -56138,      -56051,      -55964,      -55877, 
        -55790,      -55704,      -55617,      -55531, 
        -55444,      -55358,      -55272,      -55186, 
        -55100,      -55015,      -54929,      -54843, 
        -54758,      -54673,      -54587,      -54502, 
        -54417,      -54333,      -54248,      -54163, 
        -54079,      -53994,      -53910,      -53826, 
        -53741,      -53657,      -53574,      -53490, 
        -53406,      -53322,      -53239,      -53156, 
        -53072,      -52989,      -52906,      -52823, 
        -52740,      -52657,      -52575,      -52492, 
        -52410,      -52327,      -52245,      -52163, 
        -52081,      -51999,      -51917,      -51835, 
        -51754,      -51672,      -51591,      -51509, 
        -51428,      -51347,      -51266,      -51185, 
        -51104,      -51023,      -50942,      -50862, 
        -50781,      -50701,      -50621,      -50540, 
        -50460,      -50380,      -50300,      -50221, 
        -50141,      -50061,      -49982,      -49902, 
        -49823,      -49744,      -49664,      -49585, 
        -49506,      -49427,      -49349,      -49270, 
        -49191,      -49113,      -49034,      -48956, 
        -48878,      -48799,      -48721,      -48643, 
        -48565,      -48488,      -48410,      -48332, 
        -48255,      -48177,      -48100,      -48022, 
        -47945,      -47868,      -47791,      -47714, 
        -47637,      -47560,      -47484,      -47407, 
        -47331,      -47254,      -47178,      -47102, 
        -47025,      -46949,      -46873,      -46797, 
        -46721,      -46646,      -46570,      -46494, 
        -46419,      -46343,      -46268,      -46193, 
        -46118,      -46042,      -45967,      -45892, 
        -45818,      -45743,      -45668,      -45593, 
        -45519,      -45444,      -45370,      -45296, 
        -45221,      -45147,      -45073,      -44999, 
        -44925,      -44851,      -44778,      -44704, 
        -44630,      -44557,      -44483,      -44410, 
        -44337,      -44263,      -44190,      -44117, 
        -44044,      -43971,      -43898,      -43826, 
        -43753,      -43680,      -43608,      -43535, 
        -43463,      -43390,      -43318,      -43246, 
        -43174,      -43102,      -43030,      -42958, 
        -42886,      -42814,      -42743,      -42671, 
        -42600,      -42528,      -42457,      -42385, 
        -42314,      -42243,      -42172,      -42101, 
        -42030,      -41959,      -41888,      -41817, 
        -41747,      -41676,      -41605,      -41535, 
        -41465,      -41394,      -41324,      -41254, 
        -41184,      -41113,      -41043,      -40973, 
        -40904,      -40834,      -40764,      -40694, 
        -40625,      -40555,      -40486,      -40416, 
        -40347,      -40278,      -40208,      -40139, 
        -40070,      -40001,      -39932,      -39863, 
        -39794,      -39726,      -39657,      -39588, 
        -39520,      -39451,      -39383,      -39314, 
        -39246,      -39178,      -39110,      -39042, 
        -38973,      -38905,      -38837,      -38770, 
        -38702,      -38634,      -38566,      -38499, 
        -38431,      -38364,      -38296,      -38229, 
        -38161,      -38094,      -38027,      -37960, 
        -37893,      -37826,      -37759,      -37692, 
        -37625,      -37558,      -37491,      -37425, 
        -37358,      -37291,      -37225,      -37158, 
        -37092,      -37026,      -36959,      -36893, 
        -36827,      -36761,      -36695,      -36629, 
        -36563,      -36497,      -36431,      -36365, 
        -36300,      -36234,      -36168,      -36103, 
        -36037,      -35972,      -35907,      -35841, 
        -35776,      -35711,      -35646,      -35580, 
        -35515,      -35450,      -35385,      -35321, 
        -35256,      -35191,      -35126,      -35062, 
        -34997,      -34932,      -34868,      -34803, 
        -34739,      -34675,      -34610,      -34546, 
        -34482,      -34418,      -34354,      -34289, 
        -34225,      -34162,      -34098,      -34034, 
        -33970,      -33906,      -33843,      -33779, 
        -33715,      -33652,      -33588,      -33525, 
        -33461,      -33398,      -33335,      -33272, 
        -33208,      -33145,      -33082,      -33019, 
        -32956,      -32893,      -32830,      -32767, 
        -32705,      -32642,      -32579,      -32516, 
        -32454,      -32391,      -32329,      -32266, 
        -32204,      -32141,      -32079,      -32017, 
        -31955,      -31892,      -31830,      -31768, 
        -31706,      -31644,      -31582,      -31520, 
        -31458,      -31396,      -31335,      -31273, 
        -31211,      -31150,      -31088,      -31026, 
        -30965,      -30904,      -30842,      -30781, 
        -30719,      -30658,      -30597,      -30536, 
        -30474,      -30413,      -30352,      -30291, 
        -30230,      -30169,      -30108,      -30048, 
        -29987,      -29926,      -29865,      -29805, 
        -29744,      -29683,      -29623,      -29562, 
        -29502,      -29441,      -29381,      -29321, 
        -29260,      -29200,      -29140,      -29080, 
        -29020,      -28959,      -28899,      -28839, 
        -28779,      -28719,      -28660,      -28600, 
        -28540,      -28480,      -28420,      -28361, 
        -28301,      -28241,      -28182,      -28122, 
        -28063,      -28003,      -27944,      -27884, 
        -27825,      -27766,      -27707,      -27647, 
        -27588,      -27529,      -27470,      -27411, 
        -27352,      -27293,      -27234,      -27175, 
        -27116,      -27057,      -26998,      -26940, 
        -26881,      -26822,      -26763,      -26705, 
        -26646,      -26588,      -26529,      -26471, 
        -26412,      -26354,      -26295,      -26237, 
        -26179,      -26120,      -26062,      -26004, 
        -25946,      -25888,      -25830,      -25772, 
        -25714,      -25656,      -25598,      -25540, 
        -25482,      -25424,      -25366,      -25308, 
        -25251,      -25193,      -25135,      -25078, 
        -25020,      -24962,      -24905,      -24847, 
        -24790,      -24732,      -24675,      -24618, 
        -24560,      -24503,      -24446,      -24389, 
        -24331,      -24274,      -24217,      -24160, 
        -24103,      -24046,      -23989,      -23932, 
        -23875,      -23818,      -23761,      -23704, 
        -23647,      -23591,      -23534,      -23477, 
        -23420,      -23364,      -23307,      -23250, 
        -23194,      -23137,      -23081,      -23024, 
        -22968,      -22911,      -22855,      -22799, 
        -22742,      -22686,      -22630,      -22573, 
        -22517,      -22461,      -22405,      -22349, 
        -22293,      -22237,      -22181,      -22125, 
        -22069,      -22013,      -21957,      -21901, 
        -21845,      -21789,      -21733,      -21678, 
        -21622,      -21566,      -21510,      -21455, 
        -21399,      -21343,      -21288,      -21232, 
        -21177,      -21121,      -21066,      -21010, 
        -20955,      -20900,      -20844,      -20789, 
        -20734,      -20678,      -20623,      -20568, 
        -20513,      -20457,      -20402,      -20347, 
        -20292,      -20237,      -20182,      -20127, 
        -20072,      -20017,      -19962,      -19907, 
        -19852,      -19797,      -19742,      -19688, 
        -19633,      -19578,      -19523,      -19469, 
        -19414,      -19359,      -19305,      -19250, 
        -19195,      -19141,      -19086,      -19032, 
        -18977,      -18923,      -18868,      -18814, 
        -18760,      -18705,      -18651,      -18597, 
        -18542,      -18488,      -18434,      -18380, 
        -18325,      -18271,      -18217,      -18163, 
        -18109,      -18055,      -18001,      -17946, 
        -17892,      -17838,      -17784,      -17731, 
        -17677,      -17623,      -17569,      -17515, 
        -17461,      -17407,      -17353,      -17300, 
        -17246,      -17192,      -17138,      -17085, 
        -17031,      -16977,      -16924,      -16870, 
        -16817,      -16763,      -16710,      -16656, 
        -16603,      -16549,      -16496,      -16442, 
        -16389,      -16335,      -16282,      -16229, 
        -16175,      -16122,      -16069,      -16015, 
        -15962,      -15909,      -15856,      -15802, 
        -15749,      -15696,      -15643,      -15590, 
        -15537,      -15484,      -15431,      -15378, 
        -15325,      -15272,      -15219,      -15166, 
        -15113,      -15060,      -15007,      -14954, 
        -14901,      -14848,      -14795,      -14743, 
        -14690,      -14637,      -14584,      -14531, 
        -14479,      -14426,      -14373,      -14321, 
        -14268,      -14215,      -14163,      -14110, 
        -14057,      -14005,      -13952,      -13900, 
        -13847,      -13795,      -13742,      -13690, 
        -13637,      -13585,      -13533,      -13480, 
        -13428,      -13375,      -13323,      -13271, 
        -13218,      -13166,      -13114,      -13062, 
        -13009,      -12957,      -12905,      -12853, 
        -12800,      -12748,      -12696,      -12644, 
        -12592,      -12540,      -12488,      -12436, 
        -12383,      -12331,      -12279,      -12227, 
        -12175,      -12123,      -12071,      -12019, 
        -11967,      -11916,      -11864,      -11812, 
        -11760,      -11708,      -11656,      -11604, 
        -11552,      -11501,      -11449,      -11397, 
        -11345,      -11293,      -11242,      -11190, 
        -11138,      -11086,      -11035,      -10983, 
        -10931,      -10880,      -10828,      -10777, 
        -10725,      -10673,      -10622,      -10570, 
        -10519,      -10467,      -10415,      -10364, 
        -10312,      -10261,      -10209,      -10158, 
        -10106,      -10055,      -10004,      -9952, 
        -9901,      -9849,      -9798,      -9747, 
        -9695,      -9644,      -9592,      -9541, 
        -9490,      -9438,      -9387,      -9336, 
        -9285,      -9233,      -9182,      -9131, 
        -9080,      -9028,      -8977,      -8926, 
        -8875,      -8824,      -8772,      -8721, 
        -8670,      -8619,      -8568,      -8517, 
        -8466,      -8414,      -8363,      -8312, 
        -8261,      -8210,      -8159,      -8108, 
        -8057,      -8006,      -7955,      -7904, 
        -7853,      -7802,      -7751,      -7700, 
        -7649,      -7598,      -7547,      -7496, 
        -7445,      -7395,      -7344,      -7293, 
        -7242,      -7191,      -7140,      -7089, 
        -7038,      -6988,      -6937,      -6886, 
        -6835,      -6784,      -6733,      -6683, 
        -6632,      -6581,      -6530,      -6480, 
        -6429,      -6378,      -6327,      -6277, 
        -6226,      -6175,      -6124,      -6074, 
        -6023,      -5972,      -5922,      -5871, 
        -5820,      -5770,      -5719,      -5668, 
        -5618,      -5567,      -5517,      -5466, 
        -5415,      -5365,      -5314,      -5264, 
        -5213,      -5162,      -5112,      -5061, 
        -5011,      -4960,      -4910,      -4859, 
        -4808,      -4758,      -4707,      -4657, 
        -4606,      -4556,      -4505,      -4455, 
        -4404,      -4354,      -4303,      -4253, 
        -4202,      -4152,      -4101,      -4051, 
        -4001,      -3950,      -3900,      -3849, 
        -3799,      -3748,      -3698,      -3648, 
        -3597,      -3547,      -3496,      -3446, 
        -3395,      -3345,      -3295,      -3244, 
        -3194,      -3144,      -3093,      -3043, 
        -2992,      -2942,      -2892,      -2841, 
        -2791,      -2741,      -2690,      -2640, 
        -2590,      -2539,      -2489,      -2439, 
        -2388,      -2338,      -2288,      -2237, 
        -2187,      -2137,      -2086,      -2036, 
        -1986,      -1935,      -1885,      -1835, 
        -1784,      -1734,      -1684,      -1633, 
        -1583,      -1533,      -1483,      -1432, 
        -1382,      -1332,      -1281,      -1231, 
        -1181,      -1131,      -1080,      -1030, 
        -980,      -929,      -879,      -829, 
        -779,      -728,      -678,      -628, 
        -578,      -527,      -477,      -427, 
        -376,      -326,      -276,      -226, 
        -175,      -125,      -75,      -25, 
        25,      75,      125,      175, 
        226,      276,      326,      376, 
        427,      477,      527,      578, 
        628,      678,      728,      779, 
        829,      879,      929,      980, 
        1030,      1080,      1131,      1181, 
        1231,      1281,      1332,      1382, 
        1432,      1483,      1533,      1583, 
        1633,      1684,      1734,      1784, 
        1835,      1885,      1935,      1986, 
        2036,      2086,      2137,      2187, 
        2237,      2288,      2338,      2388, 
        2439,      2489,      2539,      2590, 
        2640,      2690,      2741,      2791, 
        2841,      2892,      2942,      2992, 
        3043,      3093,      3144,      3194, 
        3244,      3295,      3345,      3395, 
        3446,      3496,      3547,      3597, 
        3648,      3698,      3748,      3799, 
        3849,      3900,      3950,      4001, 
        4051,      4101,      4152,      4202, 
        4253,      4303,      4354,      4404, 
        4455,      4505,      4556,      4606, 
        4657,      4707,      4758,      4808, 
        4859,      4910,      4960,      5011, 
        5061,      5112,      5162,      5213, 
        5264,      5314,      5365,      5415, 
        5466,      5517,      5567,      5618, 
        5668,      5719,      5770,      5820, 
        5871,      5922,      5972,      6023, 
        6074,      6124,      6175,      6226, 
        6277,      6327,      6378,      6429, 
        6480,      6530,      6581,      6632, 
        6683,      6733,      6784,      6835, 
        6886,      6937,      6988,      7038, 
        7089,      7140,      7191,      7242, 
        7293,      7344,      7395,      7445, 
        7496,      7547,      7598,      7649, 
        7700,      7751,      7802,      7853, 
        7904,      7955,      8006,      8057, 
        8108,      8159,      8210,      8261, 
        8312,      8363,      8414,      8466, 
        8517,      8568,      8619,      8670, 
        8721,      8772,      8824,      8875, 
        8926,      8977,      9028,      9080, 
        9131,      9182,      9233,      9285, 
        9336,      9387,      9438,      9490, 
        9541,      9592,      9644,      9695, 
        9747,      9798,      9849,      9901, 
        9952,      10004,      10055,      10106, 
        10158,      10209,      10261,      10312, 
        10364,      10415,      10467,      10519, 
        10570,      10622,      10673,      10725, 
        10777,      10828,      10880,      10931, 
        10983,      11035,      11086,      11138, 
        11190,      11242,      11293,      11345, 
        11397,      11449,      11501,      11552, 
        11604,      11656,      11708,      11760, 
        11812,      11864,      11916,      11967, 
        12019,      12071,      12123,      12175, 
        12227,      12279,      12331,      12383, 
        12436,      12488,      12540,      12592, 
        12644,      12696,      12748,      12800, 
        12853,      12905,      12957,      13009, 
        13062,      13114,      13166,      13218, 
        13271,      13323,      13375,      13428, 
        13480,      13533,      13585,      13637, 
        13690,      13742,      13795,      13847, 
        13900,      13952,      14005,      14057, 
        14110,      14163,      14215,      14268, 
        14321,      14373,      14426,      14479, 
        14531,      14584,      14637,      14690, 
        14743,      14795,      14848,      14901, 
        14954,      15007,      15060,      15113, 
        15166,      15219,      15272,      15325, 
        15378,      15431,      15484,      15537, 
        15590,      15643,      15696,      15749, 
        15802,      15856,      15909,      15962, 
        16015,      16069,      16122,      16175, 
        16229,      16282,      16335,      16389, 
        16442,      16496,      16549,      16603, 
        16656,      16710,      16763,      16817, 
        16870,      16924,      16977,      17031, 
        17085,      17138,      17192,      17246, 
        17300,      17353,      17407,      17461, 
        17515,      17569,      17623,      17677, 
        17731,      17784,      17838,      17892, 
        17946,      18001,      18055,      18109, 
        18163,      18217,      18271,      18325, 
        18380,      18434,      18488,      18542, 
        18597,      18651,      18705,      18760, 
        18814,      18868,      18923,      18977, 
        19032,      19086,      19141,      19195, 
        19250,      19305,      19359,      19414, 
        19469,      19523,      19578,      19633, 
        19688,      19742,      19797,      19852, 
        19907,      19962,      20017,      20072, 
        20127,      20182,      20237,      20292, 
        20347,      20402,      20457,      20513, 
        20568,      20623,      20678,      20734, 
        20789,      20844,      20900,      20955, 
        21010,      21066,      21121,      21177, 
        21232,      21288,      21343,      21399, 
        21455,      21510,      21566,      21622, 
        21678,      21733,      21789,      21845, 
        21901,      21957,      22013,      22069, 
        22125,      22181,      22237,      22293, 
        22349,      22405,      22461,      22517, 
        22573,      22630,      22686,      22742, 
        22799,      22855,      22911,      22968, 
        23024,      23081,      23137,      23194, 
        23250,      23307,      23364,      23420, 
        23477,      23534,      23591,      23647, 
        23704,      23761,      23818,      23875, 
        23932,      23989,      24046,      24103, 
        24160,      24217,      24274,      24331, 
        24389,      24446,      24503,      24560, 
        24618,      24675,      24732,      24790, 
        24847,      24905,      24962,      25020, 
        25078,      25135,      25193,      25251, 
        25308,      25366,      25424,      25482, 
        25540,      25598,      25656,      25714, 
        25772,      25830,      25888,      25946, 
        26004,      26062,      26120,      26179, 
        26237,      26295,      26354,      26412, 
        26471,      26529,      26588,      26646, 
        26705,      26763,      26822,      26881, 
        26940,      26998,      27057,      27116, 
        27175,      27234,      27293,      27352, 
        27411,      27470,      27529,      27588, 
        27647,      27707,      27766,      27825, 
        27884,      27944,      28003,      28063, 
        28122,      28182,      28241,      28301, 
        28361,      28420,      28480,      28540, 
        28600,      28660,      28719,      28779, 
        28839,      28899,      28959,      29020, 
        29080,      29140,      29200,      29260, 
        29321,      29381,      29441,      29502, 
        29562,      29623,      29683,      29744, 
        29805,      29865,      29926,      29987, 
        30048,      30108,      30169,      30230, 
        30291,      30352,      30413,      30474, 
        30536,      30597,      30658,      30719, 
        30781,      30842,      30904,      30965, 
        31026,      31088,      31150,      31211, 
        31273,      31335,      31396,      31458, 
        31520,      31582,      31644,      31706, 
        31768,      31830,      31892,      31955, 
        32017,      32079,      32141,      32204, 
        32266,      32329,      32391,      32454, 
        32516,      32579,      32642,      32705, 
        32767,      32830,      32893,      32956, 
        33019,      33082,      33145,      33208, 
        33272,      33335,      33398,      33461, 
        33525,      33588,      33652,      33715, 
        33779,      33843,      33906,      33970, 
        34034,      34098,      34162,      34225, 
        34289,      34354,      34418,      34482, 
        34546,      34610,      34675,      34739, 
        34803,      34868,      34932,      34997, 
        35062,      35126,      35191,      35256, 
        35321,      35385,      35450,      35515, 
        35580,      35646,      35711,      35776, 
        35841,      35907,      35972,      36037, 
        36103,      36168,      36234,      36300, 
        36365,      36431,      36497,      36563, 
        36629,      36695,      36761,      36827, 
        36893,      36959,      37026,      37092, 
        37158,      37225,      37291,      37358, 
        37425,      37491,      37558,      37625, 
        37692,      37759,      37826,      37893, 
        37960,      38027,      38094,      38161, 
        38229,      38296,      38364,      38431, 
        38499,      38566,      38634,      38702, 
        38770,      38837,      38905,      38973, 
        39042,      39110,      39178,      39246, 
        39314,      39383,      39451,      39520, 
        39588,      39657,      39726,      39794, 
        39863,      39932,      40001,      40070, 
        40139,      40208,      40278,      40347, 
        40416,      40486,      40555,      40625, 
        40694,      40764,      40834,      40904, 
        40973,      41043,      41113,      41184, 
        41254,      41324,      41394,      41465, 
        41535,      41605,      41676,      41747, 
        41817,      41888,      41959,      42030, 
        42101,      42172,      42243,      42314, 
        42385,      42457,      42528,      42600, 
        42671,      42743,      42814,      42886, 
        42958,      43030,      43102,      43174, 
        43246,      43318,      43390,      43463, 
        43535,      43608,      43680,      43753, 
        43826,      43898,      43971,      44044, 
        44117,      44190,      44263,      44337, 
        44410,      44483,      44557,      44630, 
        44704,      44778,      44851,      44925, 
        44999,      45073,      45147,      45221, 
        45296,      45370,      45444,      45519, 
        45593,      45668,      45743,      45818, 
        45892,      45967,      46042,      46118, 
        46193,      46268,      46343,      46419, 
        46494,      46570,      46646,      46721, 
        46797,      46873,      46949,      47025, 
        47102,      47178,      47254,      47331, 
        47407,      47484,      47560,      47637, 
        47714,      47791,      47868,      47945, 
        48022,      48100,      48177,      48255, 
        48332,      48410,      48488,      48565, 
        48643,      48721,      48799,      48878, 
        48956,      49034,      49113,      49191, 
        49270,      49349,      49427,      49506, 
        49585,      49664,      49744,      49823, 
        49902,      49982,      50061,      50141, 
        50221,      50300,      50380,      50460, 
        50540,      50621,      50701,      50781, 
        50862,      50942,      51023,      51104, 
        51185,      51266,      51347,      51428, 
        51509,      51591,      51672,      51754, 
        51835,      51917,      51999,      52081, 
        52163,      52245,      52327,      52410, 
        52492,      52575,      52657,      52740, 
        52823,      52906,      52989,      53072, 
        53156,      53239,      53322,      53406, 
        53490,      53574,      53657,      53741, 
        53826,      53910,      53994,      54079, 
        54163,      54248,      54333,      54417, 
        54502,      54587,      54673,      54758, 
        54843,      54929,      55015,      55100, 
        55186,      55272,      55358,      55444, 
        55531,      55617,      55704,      55790, 
        55877,      55964,      56051,      56138, 
        56225,      56312,      56400,      56487, 
        56575,      56663,      56751,      56839, 
        56927,      57015,      57104,      57192, 
        57281,      57369,      57458,      57547, 
        57636,      57725,      57815,      57904, 
        57994,      58083,      58173,      58263, 
        58353,      58443,      58534,      58624, 
        58715,      58805,      58896,      58987, 
        59078,      59169,      59261,      59352, 
        59444,      59535,      59627,      59719, 
        59811,      59903,      59996,      60088, 
        60181,      60273,      60366,      60459, 
        60552,      60646,      60739,      60833, 
        60926,      61020,      61114,      61208, 
        61302,      61396,      61491,      61585, 
        61680,      61775,      61870,      61965, 
        62060,      62156,      62251,      62347, 
        62443,      62539,      62635,      62731, 
        62828,      62924,      63021,      63118, 
        63215,      63312,      63409,      63506, 
        63604,      63702,      63799,      63897, 
        63996,      64094,      64192,      64291, 
        64389,      64488,      64587,      64687, 
        64786,      64885,      64985,      65085, 
        65185,      65285,      65385,      65485, 
        65586,      65686,      65787,      65888, 
        65989,      66091,      66192,      66294, 
        66396,      66498,      66600,      66702, 
        66804,      66907,      67010,      67113, 
        67216,      67319,      67422,      67526, 
        67629,      67733,      67837,      67942, 
        68046,      68151,      68255,      68360, 
        68465,      68570,      68676,      68781, 
        68887,      68993,      69099,      69205, 
        69312,      69418,      69525,      69632, 
        69739,      69846,      69954,      70061, 
        70169,      70277,      70385,      70494, 
        70602,      70711,      70820,      70929, 
        71038,      71147,      71257,      71367, 
        71477,      71587,      71697,      71808, 
        71918,      72029,      72140,      72252, 
        72363,      72475,      72587,      72699, 
        72811,      72923,      73036,      73149, 
        73262,      73375,      73488,      73602, 
        73715,      73829,      73944,      74058, 
        74172,      74287,      74402,      74517, 
        74633,      74748,      74864,      74980, 
        75096,      75213,      75329,      75446, 
        75563,      75680,      75797,      75915, 
        76033,      76151,      76269,      76388, 
        76506,      76625,      76744,      76864, 
        76983,      77103,      77223,      77343, 
        77463,      77584,      77705,      77826, 
        77947,      78068,      78190,      78312, 
        78434,      78557,      78679,      78802, 
        78925,      79048,      79172,      79296, 
        79420,      79544,      79668,      79793, 
        79918,      80043,      80168,      80294, 
        80420,      80546,      80672,      80799, 
        80925,      81053,      81180,      81307, 
        81435,      81563,      81691,      81820, 
        81949,      82078,      82207,      82336, 
        82466,      82596,      82726,      82857, 
        82987,      83118,      83250,      83381, 
        83513,      83645,      83777,      83910, 
        84043,      84176,      84309,      84443, 
        84576,      84710,      84845,      84980, 
        85114,      85250,      85385,      85521, 
        85657,      85793,      85930,      86066, 
        86204,      86341,      86479,      86616, 
        86755,      86893,      87032,      87171, 
        87310,      87450,      87590,      87730, 
        87871,      88011,      88152,      88294, 
        88435,      88577,      88720,      88862, 
        89005,      89148,      89292,      89435, 
        89579,      89724,      89868,      90013, 
        90158,      90304,      90450,      90596, 
        90742,      90889,      91036,      91184, 
        91332,      91480,      91628,      91777, 
        91926,      92075,      92225,      92375, 
        92525,      92675,      92826,      92978, 
        93129,      93281,      93434,      93586, 
        93739,      93892,      94046,      94200, 
        94354,      94509,      94664,      94819, 
        94975,      95131,      95287,      95444, 
        95601,      95758,      95916,      96074, 
        96233,      96391,      96551,      96710, 
        96870,      97030,      97191,      97352, 
        97513,      97675,      97837,      98000, 
        98163,      98326,      98489,      98653, 
        98818,      98982,      99148,      99313, 
        99479,      99645,      99812,      99979, 
        100146,      100314,      100482,      100651, 
        100820,      100990,      101159,      101330, 
        101500,      101671,      101843,      102015, 
        102187,      102360,      102533,      102706, 
        102880,      103054,      103229,      103404, 
        103580,      103756,      103933,      104109, 
        104287,      104465,      104643,      104821, 
        105000,      105180,      105360,      105540, 
        105721,      105902,      106084,      106266, 
        106449,      106632,      106816,      107000, 
        107184,      107369,      107555,      107741, 
        107927,      108114,      108301,      108489, 
        108677,      108866,      109055,      109245, 
        109435,      109626,      109817,      110008, 
        110200,      110393,      110586,      110780, 
        110974,      111169,      111364,      111560, 
        111756,      111952,      112150,      112347, 
        112546,      112744,      112944,      113143, 
        113344,      113545,      113746,      113948, 
        114151,      114354,      114557,      114761, 
        114966,      115171,      115377,      115583, 
        115790,      115998,      116206,      116414, 
        116623,      116833,      117044,      117254, 
        117466,      117678,      117891,      118104, 
        118318,      118532,      118747,      118963, 
        119179,      119396,      119613,      119831, 
        120050,      120269,      120489,      120709, 
        120930,      121152,      121374,      121597, 
        121821,      122045,      122270,      122496, 
        122722,      122949,      123176,      123404, 
        123633,      123863,      124093,      124324, 
        124555,      124787,      125020,      125254, 
        125488,      125723,      125959,      126195, 
        126432,      126669,      126908,      127147, 
        127387,      127627,      127869,      128111, 
        128353,      128597,      128841,      129086, 
        129332,      129578,      129825,      130073, 
        130322,      130571,      130821,      131072, 
        131324,      131576,      131830,      132084, 
        132339,      132594,      132851,      133108, 
        133366,      133625,      133884,      134145, 
        134406,      134668,      134931,      135195, 
        135459,      135725,      135991,      136258, 
        136526,      136795,      137065,      137335, 
        137607,      137879,      138152,      138426, 
        138701,      138977,      139254,      139532, 
        139810,      140090,      140370,      140651, 
        140934,      141217,      141501,      141786, 
        142072,      142359,      142647,      142936, 
        143226,      143517,      143808,      144101, 
        144395,      144690,      144986,      145282, 
        145580,      145879,      146179,      146480, 
        146782,      147084,      147388,      147693, 
        148000,      148307,      148615,      148924, 
        149235,      149546,      149859,      150172, 
        150487,      150803,      151120,      151438, 
        151757,      152077,      152399,      152722, 
        153045,      153370,      153697,      154024, 
        154352,      154682,      155013,      155345, 
        155678,      156013,      156349,      156686, 
        157024,      157363,      157704,      158046, 
        158389,      158734,      159079,      159427, 
        159775,      160125,      160476,      160828, 
        161182,      161537,      161893,      162251, 
        162610,      162970,      163332,      163695, 
        164060,      164426,      164793,      165162, 
        165532,      165904,      166277,      166651, 
        167027,      167405,      167784,      168164, 
        168546,      168930,      169315,      169701, 
        170089,      170479,      170870,      171263, 
        171657,      172053,      172451,      172850, 
        173251,      173653,      174057,      174463, 
        174870,      175279,      175690,      176102, 
        176516,      176932,      177349,      177769, 
        178190,      178612,      179037,      179463, 
        179891,      180321,      180753,      181186, 
        181622,      182059,      182498,      182939, 
        183382,      183827,      184274,      184722, 
        185173,      185625,      186080,      186536, 
        186995,      187455,      187918,      188382, 
        188849,      189318,      189789,      190261, 
        190736,      191213,      191693,      192174, 
        192658,      193143,      193631,      194122, 
        194614,      195109,      195606,      196105, 
        196606,      197110,      197616,      198125, 
        198636,      199149,      199664,      200182, 
        200703,      201226,      201751,      202279, 
        202809,      203342,      203878,      204416, 
        204956,      205500,      206045,      206594, 
        207145,      207699,      208255,      208815, 
        209376,      209941,      210509,      211079, 
        211652,      212228,      212807,      213389, 
        213973,      214561,      215151,      215745, 
        216341,      216941,      217544,      218149, 
        218758,      219370,      219985,      220603, 
        221225,      221849,      222477,      223108, 
        223743,      224381,      225022,      225666, 
        226314,      226966,      227621,      228279, 
        228941,      229606,      230275,      230948, 
        231624,      232304,      232988,      233676, 
        234367,      235062,      235761,      236463, 
        237170,      237881,      238595,      239314, 
        240036,      240763,      241493,      242228, 
        242967,      243711,      244458,      245210, 
        245966,      246727,      247492,      248261, 
        249035,      249813,      250596,      251384, 
        252176,      252973,      253774,      254581, 
        255392,      256208,      257029,      257855, 
        258686,      259522,      260363,      261209, 
        262060,      262917,      263779,      264646, 
        265519,      266397,      267280,      268169, 
        269064,      269965,      270871,      271782, 
        272700,      273624,      274553,      275489, 
        276430,      277378,      278332,      279292, 
        280258,      281231,      282210,      283195, 
        284188,      285186,      286192,      287204, 
        288223,      289249,      290282,      291322, 
        292369,      293423,      294485,      295554, 
        296630,      297714,      298805,      299904, 
        301011,      302126,      303248,      304379, 
        305517,      306664,      307819,      308983, 
        310154,      311335,      312524,      313721, 
        314928,      316143,      317368,      318601, 
        319844,      321097,      322358,      323629, 
        324910,      326201,      327502,      328812, 
        330133,      331464,      332805,      334157, 
        335519,      336892,      338276,      339671, 
        341078,      342495,      343924,      345364, 
        346816,      348280,      349756,      351244, 
        352744,      354257,      355783,      357321, 
        358872,      360436,      362013,      363604, 
        365208,      366826,      368459,      370105, 
        371765,      373440,      375130,      376835, 
        378555,      380290,      382040,      383807, 
        385589,      387387,      389202,      391034, 
        392882,      394747,      396630,      398530, 
        400448,      402384,      404338,      406311, 
        408303,      410314,      412344,      414395, 
        416465,      418555,      420666,      422798, 
        424951,      427125,      429321,      431540, 
        433781,      436045,      438332,      440643, 
        442978,      445337,      447720,      450129, 
        452564,      455024,      457511,      460024, 
        462565,      465133,      467730,      470355, 
        473009,      475692,      478406,      481150, 
        483925,      486732,      489571,      492443, 
        495348,      498287,      501261,      504269, 
        507313,      510394,      513512,      516667, 
        519861,      523094,      526366,      529680, 
        533034,      536431,      539870,      543354, 
        546881,      550455,      554074,      557741, 
        561456,      565221,      569035,      572901, 
        576818,      580789,      584815,      588896, 
        593033,      597229,      601483,      605798, 
        610174,      614613,      619117,      623686, 
        628323,      633028,      637803,      642651, 
        647572,      652568,      657640,      662792, 
        668024,      673338,      678737,      684223, 
        689797,      695462,      701219,      707072, 
        713023,      719074,      725227,      731486, 
        737853,      744331,      750922,      757631, 
        764460,      771411,      778490,      785699, 
        793041,      800521,      808143,      815910, 
        823827,      831898,      840127,      848520, 
        857081,      865817,      874730,      883829, 
        893117,      902602,      912289,      922186, 
        932298,      942633,      953199,      964003, 
        975054,      986361,      997931,      1009774, 
        1021901,      1034322,      1047046,      1060087, 
        1073455,      1087164,      1101225,      1115654, 
        1130465,      1145673,      1161294,      1177345, 
        1193846,      1210813,      1228269,      1246234, 
        1264730,      1283783,      1303416,      1323658, 
        1344537,      1366084,      1388330,      1411312, 
        1435065,      1459630,      1485049,      1511367, 
        1538632,      1566898,      1596220,      1626658, 
        1658278,      1691149,      1725348,      1760956, 
        1798063,      1836758,      1877161,      1919378, 
        1963536,      2009771,      2058233,      2109087, 
        2162516,      2218719,      2277919,      2340362, 
        2406322,      2476104,      2550052,      2628549, 
        2712030,      2800983,      2895966,      2997613, 
        3106651,      3223918,      3350381,      3487165, 
        3635590,      3797206,      3973855,      4167737, 
        4381502,      4618375,      4882318,      5178251, 
        5512368,      5892567,      6329090,      6835455, 
        7429880,      8137527,      8994149,      10052327, 
        11392683,      13145455,      15535599,      18988036, 
        24413316,      34178904,      56965752,      170910304};
#line 584 "tables.c"
int finesine[10240]  = 
#line 584
  {      25,      75,      125,      175, 
        226,      276,      326,      376, 
        427,      477,      527,      578, 
        628,      678,      728,      779, 
        829,      879,      929,      980, 
        1030,      1080,      1130,      1181, 
        1231,      1281,      1331,      1382, 
        1432,      1482,      1532,      1583, 
        1633,      1683,      1733,      1784, 
        1834,      1884,      1934,      1985, 
        2035,      2085,      2135,      2186, 
        2236,      2286,      2336,      2387, 
        2437,      2487,      2537,      2587, 
        2638,      2688,      2738,      2788, 
        2839,      2889,      2939,      2989, 
        3039,      3090,      3140,      3190, 
        3240,      3291,      3341,      3391, 
        3441,      3491,      3541,      3592, 
        3642,      3692,      3742,      3792, 
        3843,      3893,      3943,      3993, 
        4043,      4093,      4144,      4194, 
        4244,      4294,      4344,      4394, 
        4445,      4495,      4545,      4595, 
        4645,      4695,      4745,      4796, 
        4846,      4896,      4946,      4996, 
        5046,      5096,      5146,      5197, 
        5247,      5297,      5347,      5397, 
        5447,      5497,      5547,      5597, 
        5647,      5697,      5748,      5798, 
        5848,      5898,      5948,      5998, 
        6048,      6098,      6148,      6198, 
        6248,      6298,      6348,      6398, 
        6448,      6498,      6548,      6598, 
        6648,      6698,      6748,      6798, 
        6848,      6898,      6948,      6998, 
        7048,      7098,      7148,      7198, 
        7248,      7298,      7348,      7398, 
        7448,      7498,      7548,      7598, 
        7648,      7697,      7747,      7797, 
        7847,      7897,      7947,      7997, 
        8047,      8097,      8147,      8196, 
        8246,      8296,      8346,      8396, 
        8446,      8496,      8545,      8595, 
        8645,      8695,      8745,      8794, 
        8844,      8894,      8944,      8994, 
        9043,      9093,      9143,      9193, 
        9243,      9292,      9342,      9392, 
        9442,      9491,      9541,      9591, 
        9640,      9690,      9740,      9790, 
        9839,      9889,      9939,      9988, 
        10038,      10088,      10137,      10187, 
        10237,      10286,      10336,      10386, 
        10435,      10485,      10534,      10584, 
        10634,      10683,      10733,      10782, 
        10832,      10882,      10931,      10981, 
        11030,      11080,      11129,      11179, 
        11228,      11278,      11327,      11377, 
        11426,      11476,      11525,      11575, 
        11624,      11674,      11723,      11773, 
        11822,      11872,      11921,      11970, 
        12020,      12069,      12119,      12168, 
        12218,      12267,      12316,      12366, 
        12415,      12464,      12514,      12563, 
        12612,      12662,      12711,      12760, 
        12810,      12859,      12908,      12957, 
        13007,      13056,      13105,      13154, 
        13204,      13253,      13302,      13351, 
        13401,      13450,      13499,      13548, 
        13597,      13647,      13696,      13745, 
        13794,      13843,      13892,      13941, 
        13990,      14040,      14089,      14138, 
        14187,      14236,      14285,      14334, 
        14383,      14432,      14481,      14530, 
        14579,      14628,      14677,      14726, 
        14775,      14824,      14873,      14922, 
        14971,      15020,      15069,      15118, 
        15167,      15215,      15264,      15313, 
        15362,      15411,      15460,      15509, 
        15557,      15606,      15655,      15704, 
        15753,      15802,      15850,      15899, 
        15948,      15997,      16045,      16094, 
        16143,      16191,      16240,      16289, 
        16338,      16386,      16435,      16484, 
        16532,      16581,      16629,      16678, 
        16727,      16775,      16824,      16872, 
        16921,      16970,      17018,      17067, 
        17115,      17164,      17212,      17261, 
        17309,      17358,      17406,      17455, 
        17503,      17551,      17600,      17648, 
        17697,      17745,      17793,      17842, 
        17890,      17939,      17987,      18035, 
        18084,      18132,      18180,      18228, 
        18277,      18325,      18373,      18421, 
        18470,      18518,      18566,      18614, 
        18663,      18711,      18759,      18807, 
        18855,      18903,      18951,      19000, 
        19048,      19096,      19144,      19192, 
        19240,      19288,      19336,      19384, 
        19432,      19480,      19528,      19576, 
        19624,      19672,      19720,      19768, 
        19816,      19864,      19912,      19959, 
        20007,      20055,      20103,      20151, 
        20199,      20246,      20294,      20342, 
        20390,      20438,      20485,      20533, 
        20581,      20629,      20676,      20724, 
        20772,      20819,      20867,      20915, 
        20962,      21010,      21057,      21105, 
        21153,      21200,      21248,      21295, 
        21343,      21390,      21438,      21485, 
        21533,      21580,      21628,      21675, 
        21723,      21770,      21817,      21865, 
        21912,      21960,      22007,      22054, 
        22102,      22149,      22196,      22243, 
        22291,      22338,      22385,      22433, 
        22480,      22527,      22574,      22621, 
        22668,      22716,      22763,      22810, 
        22857,      22904,      22951,      22998, 
        23045,      23092,      23139,      23186, 
        23233,      23280,      23327,      23374, 
        23421,      23468,      23515,      23562, 
        23609,      23656,      23703,      23750, 
        23796,      23843,      23890,      23937, 
        23984,      24030,      24077,      24124, 
        24171,      24217,      24264,      24311, 
        24357,      24404,      24451,      24497, 
        24544,      24591,      24637,      24684, 
        24730,      24777,      24823,      24870, 
        24916,      24963,      25009,      25056, 
        25102,      25149,      25195,      25241, 
        25288,      25334,      25381,      25427, 
        25473,      25520,      25566,      25612, 
        25658,      25705,      25751,      25797, 
        25843,      25889,      25936,      25982, 
        26028,      26074,      26120,      26166, 
        26212,      26258,      26304,      26350, 
        26396,      26442,      26488,      26534, 
        26580,      26626,      26672,      26718, 
        26764,      26810,      26856,      26902, 
        26947,      26993,      27039,      27085, 
        27131,      27176,      27222,      27268, 
        27313,      27359,      27405,      27450, 
        27496,      27542,      27587,      27633, 
        27678,      27724,      27770,      27815, 
        27861,      27906,      27952,      27997, 
        28042,      28088,      28133,      28179, 
        28224,      28269,      28315,      28360, 
        28405,      28451,      28496,      28541, 
        28586,      28632,      28677,      28722, 
        28767,      28812,      28858,      28903, 
        28948,      28993,      29038,      29083, 
        29128,      29173,      29218,      29263, 
        29308,      29353,      29398,      29443, 
        29488,      29533,      29577,      29622, 
        29667,      29712,      29757,      29801, 
        29846,      29891,      29936,      29980, 
        30025,      30070,      30114,      30159, 
        30204,      30248,      30293,      30337, 
        30382,      30426,      30471,      30515, 
        30560,      30604,      30649,      30693, 
        30738,      30782,      30826,      30871, 
        30915,      30959,      31004,      31048, 
        31092,      31136,      31181,      31225, 
        31269,      31313,      31357,      31402, 
        31446,      31490,      31534,      31578, 
        31622,      31666,      31710,      31754, 
        31798,      31842,      31886,      31930, 
        31974,      32017,      32061,      32105, 
        32149,      32193,      32236,      32280, 
        32324,      32368,      32411,      32455, 
        32499,      32542,      32586,      32630, 
        32673,      32717,      32760,      32804, 
        32847,      32891,      32934,      32978, 
        33021,      33065,      33108,      33151, 
        33195,      33238,      33281,      33325, 
        33368,      33411,      33454,      33498, 
        33541,      33584,      33627,      33670, 
        33713,      33756,      33799,      33843, 
        33886,      33929,      33972,      34015, 
        34057,      34100,      34143,      34186, 
        34229,      34272,      34315,      34358, 
        34400,      34443,      34486,      34529, 
        34571,      34614,      34657,      34699, 
        34742,      34785,      34827,      34870, 
        34912,      34955,      34997,      35040, 
        35082,      35125,      35167,      35210, 
        35252,      35294,      35337,      35379, 
        35421,      35464,      35506,      35548, 
        35590,      35633,      35675,      35717, 
        35759,      35801,      35843,      35885, 
        35927,      35969,      36011,      36053, 
        36095,      36137,      36179,      36221, 
        36263,      36305,      36347,      36388, 
        36430,      36472,      36514,      36555, 
        36597,      36639,      36681,      36722, 
        36764,      36805,      36847,      36889, 
        36930,      36972,      37013,      37055, 
        37096,      37137,      37179,      37220, 
        37262,      37303,      37344,      37386, 
        37427,      37468,      37509,      37551, 
        37592,      37633,      37674,      37715, 
        37756,      37797,      37838,      37879, 
        37920,      37961,      38002,      38043, 
        38084,      38125,      38166,      38207, 
        38248,      38288,      38329,      38370, 
        38411,      38451,      38492,      38533, 
        38573,      38614,      38655,      38695, 
        38736,      38776,      38817,      38857, 
        38898,      38938,      38979,      39019, 
        39059,      39100,      39140,      39180, 
        39221,      39261,      39301,      39341, 
        39382,      39422,      39462,      39502, 
        39542,      39582,      39622,      39662, 
        39702,      39742,      39782,      39822, 
        39862,      39902,      39942,      39982, 
        40021,      40061,      40101,      40141, 
        40180,      40220,      40260,      40300, 
        40339,      40379,      40418,      40458, 
        40497,      40537,      40576,      40616, 
        40655,      40695,      40734,      40773, 
        40813,      40852,      40891,      40931, 
        40970,      41009,      41048,      41087, 
        41127,      41166,      41205,      41244, 
        41283,      41322,      41361,      41400, 
        41439,      41478,      41517,      41556, 
        41595,      41633,      41672,      41711, 
        41750,      41788,      41827,      41866, 
        41904,      41943,      41982,      42020, 
        42059,      42097,      42136,      42174, 
        42213,      42251,      42290,      42328, 
        42366,      42405,      42443,      42481, 
        42520,      42558,      42596,      42634, 
        42672,      42711,      42749,      42787, 
        42825,      42863,      42901,      42939, 
        42977,      43015,      43053,      43091, 
        43128,      43166,      43204,      43242, 
        43280,      43317,      43355,      43393, 
        43430,      43468,      43506,      43543, 
        43581,      43618,      43656,      43693, 
        43731,      43768,      43806,      43843, 
        43880,      43918,      43955,      43992, 
        44029,      44067,      44104,      44141, 
        44178,      44215,      44252,      44289, 
        44326,      44363,      44400,      44437, 
        44474,      44511,      44548,      44585, 
        44622,      44659,      44695,      44732, 
        44769,      44806,      44842,      44879, 
        44915,      44952,      44989,      45025, 
        45062,      45098,      45135,      45171, 
        45207,      45244,      45280,      45316, 
        45353,      45389,      45425,      45462, 
        45498,      45534,      45570,      45606, 
        45642,      45678,      45714,      45750, 
        45786,      45822,      45858,      45894, 
        45930,      45966,      46002,      46037, 
        46073,      46109,      46145,      46180, 
        46216,      46252,      46287,      46323, 
        46358,      46394,      46429,      46465, 
        46500,      46536,      46571,      46606, 
        46642,      46677,      46712,      46747, 
        46783,      46818,      46853,      46888, 
        46923,      46958,      46993,      47028, 
        47063,      47098,      47133,      47168, 
        47203,      47238,      47273,      47308, 
        47342,      47377,      47412,      47446, 
        47481,      47516,      47550,      47585, 
        47619,      47654,      47688,      47723, 
        47757,      47792,      47826,      47860, 
        47895,      47929,      47963,      47998, 
        48032,      48066,      48100,      48134, 
        48168,      48202,      48237,      48271, 
        48305,      48338,      48372,      48406, 
        48440,      48474,      48508,      48542, 
        48575,      48609,      48643,      48676, 
        48710,      48744,      48777,      48811, 
        48844,      48878,      48911,      48945, 
        48978,      49012,      49045,      49078, 
        49112,      49145,      49178,      49211, 
        49244,      49278,      49311,      49344, 
        49377,      49410,      49443,      49476, 
        49509,      49542,      49575,      49608, 
        49640,      49673,      49706,      49739, 
        49771,      49804,      49837,      49869, 
        49902,      49935,      49967,      50000, 
        50032,      50065,      50097,      50129, 
        50162,      50194,      50226,      50259, 
        50291,      50323,      50355,      50387, 
        50420,      50452,      50484,      50516, 
        50548,      50580,      50612,      50644, 
        50675,      50707,      50739,      50771, 
        50803,      50834,      50866,      50898, 
        50929,      50961,      50993,      51024, 
        51056,      51087,      51119,      51150, 
        51182,      51213,      51244,      51276, 
        51307,      51338,      51369,      51401, 
        51432,      51463,      51494,      51525, 
        51556,      51587,      51618,      51649, 
        51680,      51711,      51742,      51773, 
        51803,      51834,      51865,      51896, 
        51926,      51957,      51988,      52018, 
        52049,      52079,      52110,      52140, 
        52171,      52201,      52231,      52262, 
        52292,      52322,      52353,      52383, 
        52413,      52443,      52473,      52503, 
        52534,      52564,      52594,      52624, 
        52653,      52683,      52713,      52743, 
        52773,      52803,      52832,      52862, 
        52892,      52922,      52951,      52981, 
        53010,      53040,      53069,      53099, 
        53128,      53158,      53187,      53216, 
        53246,      53275,      53304,      53334, 
        53363,      53392,      53421,      53450, 
        53479,      53508,      53537,      53566, 
        53595,      53624,      53653,      53682, 
        53711,      53739,      53768,      53797, 
        53826,      53854,      53883,      53911, 
        53940,      53969,      53997,      54026, 
        54054,      54082,      54111,      54139, 
        54167,      54196,      54224,      54252, 
        54280,      54308,      54337,      54365, 
        54393,      54421,      54449,      54477, 
        54505,      54533,      54560,      54588, 
        54616,      54644,      54672,      54699, 
        54727,      54755,      54782,      54810, 
        54837,      54865,      54892,      54920, 
        54947,      54974,      55002,      55029, 
        55056,      55084,      55111,      55138, 
        55165,      55192,      55219,      55246, 
        55274,      55300,      55327,      55354, 
        55381,      55408,      55435,      55462, 
        55489,      55515,      55542,      55569, 
        55595,      55622,      55648,      55675, 
        55701,      55728,      55754,      55781, 
        55807,      55833,      55860,      55886, 
        55912,      55938,      55965,      55991, 
        56017,      56043,      56069,      56095, 
        56121,      56147,      56173,      56199, 
        56225,      56250,      56276,      56302, 
        56328,      56353,      56379,      56404, 
        56430,      56456,      56481,      56507, 
        56532,      56557,      56583,      56608, 
        56633,      56659,      56684,      56709, 
        56734,      56760,      56785,      56810, 
        56835,      56860,      56885,      56910, 
        56935,      56959,      56984,      57009, 
        57034,      57059,      57083,      57108, 
        57133,      57157,      57182,      57206, 
        57231,      57255,      57280,      57304, 
        57329,      57353,      57377,      57402, 
        57426,      57450,      57474,      57498, 
        57522,      57546,      57570,      57594, 
        57618,      57642,      57666,      57690, 
        57714,      57738,      57762,      57785, 
        57809,      57833,      57856,      57880, 
        57903,      57927,      57950,      57974, 
        57997,      58021,      58044,      58067, 
        58091,      58114,      58137,      58160, 
        58183,      58207,      58230,      58253, 
        58276,      58299,      58322,      58345, 
        58367,      58390,      58413,      58436, 
        58459,      58481,      58504,      58527, 
        58549,      58572,      58594,      58617, 
        58639,      58662,      58684,      58706, 
        58729,      58751,      58773,      58795, 
        58818,      58840,      58862,      58884, 
        58906,      58928,      58950,      58972, 
        58994,      59016,      59038,      59059, 
        59081,      59103,      59125,      59146, 
        59168,      59190,      59211,      59233, 
        59254,      59276,      59297,      59318, 
        59340,      59361,      59382,      59404, 
        59425,      59446,      59467,      59488, 
        59509,      59530,      59551,      59572, 
        59593,      59614,      59635,      59656, 
        59677,      59697,      59718,      59739, 
        59759,      59780,      59801,      59821, 
        59842,      59862,      59883,      59903, 
        59923,      59944,      59964,      59984, 
        60004,      60025,      60045,      60065, 
        60085,      60105,      60125,      60145, 
        60165,      60185,      60205,      60225, 
        60244,      60264,      60284,      60304, 
        60323,      60343,      60363,      60382, 
        60402,      60421,      60441,      60460, 
        60479,      60499,      60518,      60537, 
        60556,      60576,      60595,      60614, 
        60633,      60652,      60671,      60690, 
        60709,      60728,      60747,      60766, 
        60785,      60803,      60822,      60841, 
        60859,      60878,      60897,      60915, 
        60934,      60952,      60971,      60989, 
        61007,      61026,      61044,      61062, 
        61081,      61099,      61117,      61135, 
        61153,      61171,      61189,      61207, 
        61225,      61243,      61261,      61279, 
        61297,      61314,      61332,      61350, 
        61367,      61385,      61403,      61420, 
        61438,      61455,      61473,      61490, 
        61507,      61525,      61542,      61559, 
        61577,      61594,      61611,      61628, 
        61645,      61662,      61679,      61696, 
        61713,      61730,      61747,      61764, 
        61780,      61797,      61814,      61831, 
        61847,      61864,      61880,      61897, 
        61913,      61930,      61946,      61963, 
        61979,      61995,      62012,      62028, 
        62044,      62060,      62076,      62092, 
        62108,      62125,      62141,      62156, 
        62172,      62188,      62204,      62220, 
        62236,      62251,      62267,      62283, 
        62298,      62314,      62329,      62345, 
        62360,      62376,      62391,      62407, 
        62422,      62437,      62453,      62468, 
        62483,      62498,      62513,      62528, 
        62543,      62558,      62573,      62588, 
        62603,      62618,      62633,      62648, 
        62662,      62677,      62692,      62706, 
        62721,      62735,      62750,      62764, 
        62779,      62793,      62808,      62822, 
        62836,      62850,      62865,      62879, 
        62893,      62907,      62921,      62935, 
        62949,      62963,      62977,      62991, 
        63005,      63019,      63032,      63046, 
        63060,      63074,      63087,      63101, 
        63114,      63128,      63141,      63155, 
        63168,      63182,      63195,      63208, 
        63221,      63235,      63248,      63261, 
        63274,      63287,      63300,      63313, 
        63326,      63339,      63352,      63365, 
        63378,      63390,      63403,      63416, 
        63429,      63441,      63454,      63466, 
        63479,      63491,      63504,      63516, 
        63528,      63541,      63553,      63565, 
        63578,      63590,      63602,      63614, 
        63626,      63638,      63650,      63662, 
        63674,      63686,      63698,      63709, 
        63721,      63733,      63745,      63756, 
        63768,      63779,      63791,      63803, 
        63814,      63825,      63837,      63848, 
        63859,      63871,      63882,      63893, 
        63904,      63915,      63927,      63938, 
        63949,      63960,      63971,      63981, 
        63992,      64003,      64014,      64025, 
        64035,      64046,      64057,      64067, 
        64078,      64088,      64099,      64109, 
        64120,      64130,      64140,      64151, 
        64161,      64171,      64181,      64192, 
        64202,      64212,      64222,      64232, 
        64242,      64252,      64261,      64271, 
        64281,      64291,      64301,      64310, 
        64320,      64330,      64339,      64349, 
        64358,      64368,      64377,      64387, 
        64396,      64405,      64414,      64424, 
        64433,      64442,      64451,      64460, 
        64469,      64478,      64487,      64496, 
        64505,      64514,      64523,      64532, 
        64540,      64549,      64558,      64566, 
        64575,      64584,      64592,      64601, 
        64609,      64617,      64626,      64634, 
        64642,      64651,      64659,      64667, 
        64675,      64683,      64691,      64699, 
        64707,      64715,      64723,      64731, 
        64739,      64747,      64754,      64762, 
        64770,      64777,      64785,      64793, 
        64800,      64808,      64815,      64822, 
        64830,      64837,      64844,      64852, 
        64859,      64866,      64873,      64880, 
        64887,      64895,      64902,      64908, 
        64915,      64922,      64929,      64936, 
        64943,      64949,      64956,      64963, 
        64969,      64976,      64982,      64989, 
        64995,      65002,      65008,      65015, 
        65021,      65027,      65033,      65040, 
        65046,      65052,      65058,      65064, 
        65070,      65076,      65082,      65088, 
        65094,      65099,      65105,      65111, 
        65117,      65122,      65128,      65133, 
        65139,      65144,      65150,      65155, 
        65161,      65166,      65171,      65177, 
        65182,      65187,      65192,      65197, 
        65202,      65207,      65212,      65217, 
        65222,      65227,      65232,      65237, 
        65242,      65246,      65251,      65256, 
        65260,      65265,      65270,      65274, 
        65279,      65283,      65287,      65292, 
        65296,      65300,      65305,      65309, 
        65313,      65317,      65321,      65325, 
        65329,      65333,      65337,      65341, 
        65345,      65349,      65352,      65356, 
        65360,      65363,      65367,      65371, 
        65374,      65378,      65381,      65385, 
        65388,      65391,      65395,      65398, 
        65401,      65404,      65408,      65411, 
        65414,      65417,      65420,      65423, 
        65426,      65429,      65431,      65434, 
        65437,      65440,      65442,      65445, 
        65448,      65450,      65453,      65455, 
        65458,      65460,      65463,      65465, 
        65467,      65470,      65472,      65474, 
        65476,      65478,      65480,      65482, 
        65484,      65486,      65488,      65490, 
        65492,      65494,      65496,      65497, 
        65499,      65501,      65502,      65504, 
        65505,      65507,      65508,      65510, 
        65511,      65513,      65514,      65515, 
        65516,      65518,      65519,      65520, 
        65521,      65522,      65523,      65524, 
        65525,      65526,      65527,      65527, 
        65528,      65529,      65530,      65530, 
        65531,      65531,      65532,      65532, 
        65533,      65533,      65534,      65534, 
        65534,      65535,      65535,      65535, 
        65535,      65535,      65535,      65535, 
        65535,      65535,      65535,      65535, 
        65535,      65535,      65535,      65534, 
        65534,      65534,      65533,      65533, 
        65532,      65532,      65531,      65531, 
        65530,      65530,      65529,      65528, 
        65527,      65527,      65526,      65525, 
        65524,      65523,      65522,      65521, 
        65520,      65519,      65518,      65516, 
        65515,      65514,      65513,      65511, 
        65510,      65508,      65507,      65505, 
        65504,      65502,      65501,      65499, 
        65497,      65496,      65494,      65492, 
        65490,      65488,      65486,      65484, 
        65482,      65480,      65478,      65476, 
        65474,      65472,      65470,      65467, 
        65465,      65463,      65460,      65458, 
        65455,      65453,      65450,      65448, 
        65445,      65442,      65440,      65437, 
        65434,      65431,      65429,      65426, 
        65423,      65420,      65417,      65414, 
        65411,      65408,      65404,      65401, 
        65398,      65395,      65391,      65388, 
        65385,      65381,      65378,      65374, 
        65371,      65367,      65363,      65360, 
        65356,      65352,      65349,      65345, 
        65341,      65337,      65333,      65329, 
        65325,      65321,      65317,      65313, 
        65309,      65305,      65300,      65296, 
        65292,      65287,      65283,      65279, 
        65274,      65270,      65265,      65260, 
        65256,      65251,      65246,      65242, 
        65237,      65232,      65227,      65222, 
        65217,      65212,      65207,      65202, 
        65197,      65192,      65187,      65182, 
        65177,      65171,      65166,      65161, 
        65155,      65150,      65144,      65139, 
        65133,      65128,      65122,      65117, 
        65111,      65105,      65099,      65094, 
        65088,      65082,      65076,      65070, 
        65064,      65058,      65052,      65046, 
        65040,      65033,      65027,      65021, 
        65015,      65008,      65002,      64995, 
        64989,      64982,      64976,      64969, 
        64963,      64956,      64949,      64943, 
        64936,      64929,      64922,      64915, 
        64908,      64902,      64895,      64887, 
        64880,      64873,      64866,      64859, 
        64852,      64844,      64837,      64830, 
        64822,      64815,      64808,      64800, 
        64793,      64785,      64777,      64770, 
        64762,      64754,      64747,      64739, 
        64731,      64723,      64715,      64707, 
        64699,      64691,      64683,      64675, 
        64667,      64659,      64651,      64642, 
        64634,      64626,      64617,      64609, 
        64600,      64592,      64584,      64575, 
        64566,      64558,      64549,      64540, 
        64532,      64523,      64514,      64505, 
        64496,      64487,      64478,      64469, 
        64460,      64451,      64442,      64433, 
        64424,      64414,      64405,      64396, 
        64387,      64377,      64368,      64358, 
        64349,      64339,      64330,      64320, 
        64310,      64301,      64291,      64281, 
        64271,      64261,      64252,      64242, 
        64232,      64222,      64212,      64202, 
        64192,      64181,      64171,      64161, 
        64151,      64140,      64130,      64120, 
        64109,      64099,      64088,      64078, 
        64067,      64057,      64046,      64035, 
        64025,      64014,      64003,      63992, 
        63981,      63971,      63960,      63949, 
        63938,      63927,      63915,      63904, 
        63893,      63882,      63871,      63859, 
        63848,      63837,      63825,      63814, 
        63803,      63791,      63779,      63768, 
        63756,      63745,      63733,      63721, 
        63709,      63698,      63686,      63674, 
        63662,      63650,      63638,      63626, 
        63614,      63602,      63590,      63578, 
        63565,      63553,      63541,      63528, 
        63516,      63504,      63491,      63479, 
        63466,      63454,      63441,      63429, 
        63416,      63403,      63390,      63378, 
        63365,      63352,      63339,      63326, 
        63313,      63300,      63287,      63274, 
        63261,      63248,      63235,      63221, 
        63208,      63195,      63182,      63168, 
        63155,      63141,      63128,      63114, 
        63101,      63087,      63074,      63060, 
        63046,      63032,      63019,      63005, 
        62991,      62977,      62963,      62949, 
        62935,      62921,      62907,      62893, 
        62879,      62865,      62850,      62836, 
        62822,      62808,      62793,      62779, 
        62764,      62750,      62735,      62721, 
        62706,      62692,      62677,      62662, 
        62648,      62633,      62618,      62603, 
        62588,      62573,      62558,      62543, 
        62528,      62513,      62498,      62483, 
        62468,      62453,      62437,      62422, 
        62407,      62391,      62376,      62360, 
        62345,      62329,      62314,      62298, 
        62283,      62267,      62251,      62236, 
        62220,      62204,      62188,      62172, 
        62156,      62141,      62125,      62108, 
        62092,      62076,      62060,      62044, 
        62028,      62012,      61995,      61979, 
        61963,      61946,      61930,      61913, 
        61897,      61880,      61864,      61847, 
        61831,      61814,      61797,      61780, 
        61764,      61747,      61730,      61713, 
        61696,      61679,      61662,      61645, 
        61628,      61611,      61594,      61577, 
        61559,      61542,      61525,      61507, 
        61490,      61473,      61455,      61438, 
        61420,      61403,      61385,      61367, 
        61350,      61332,      61314,      61297, 
        61279,      61261,      61243,      61225, 
        61207,      61189,      61171,      61153, 
        61135,      61117,      61099,      61081, 
        61062,      61044,      61026,      61007, 
        60989,      60971,      60952,      60934, 
        60915,      60897,      60878,      60859, 
        60841,      60822,      60803,      60785, 
        60766,      60747,      60728,      60709, 
        60690,      60671,      60652,      60633, 
        60614,      60595,      60576,      60556, 
        60537,      60518,      60499,      60479, 
        60460,      60441,      60421,      60402, 
        60382,      60363,      60343,      60323, 
        60304,      60284,      60264,      60244, 
        60225,      60205,      60185,      60165, 
        60145,      60125,      60105,      60085, 
        60065,      60045,      60025,      60004, 
        59984,      59964,      59944,      59923, 
        59903,      59883,      59862,      59842, 
        59821,      59801,      59780,      59759, 
        59739,      59718,      59697,      59677, 
        59656,      59635,      59614,      59593, 
        59572,      59551,      59530,      59509, 
        59488,      59467,      59446,      59425, 
        59404,      59382,      59361,      59340, 
        59318,      59297,      59276,      59254, 
        59233,      59211,      59190,      59168, 
        59146,      59125,      59103,      59081, 
        59059,      59038,      59016,      58994, 
        58972,      58950,      58928,      58906, 
        58884,      58862,      58840,      58818, 
        58795,      58773,      58751,      58729, 
        58706,      58684,      58662,      58639, 
        58617,      58594,      58572,      58549, 
        58527,      58504,      58481,      58459, 
        58436,      58413,      58390,      58367, 
        58345,      58322,      58299,      58276, 
        58253,      58230,      58207,      58183, 
        58160,      58137,      58114,      58091, 
        58067,      58044,      58021,      57997, 
        57974,      57950,      57927,      57903, 
        57880,      57856,      57833,      57809, 
        57785,      57762,      57738,      57714, 
        57690,      57666,      57642,      57618, 
        57594,      57570,      57546,      57522, 
        57498,      57474,      57450,      57426, 
        57402,      57377,      57353,      57329, 
        57304,      57280,      57255,      57231, 
        57206,      57182,      57157,      57133, 
        57108,      57083,      57059,      57034, 
        57009,      56984,      56959,      56935, 
        56910,      56885,      56860,      56835, 
        56810,      56785,      56760,      56734, 
        56709,      56684,      56659,      56633, 
        56608,      56583,      56557,      56532, 
        56507,      56481,      56456,      56430, 
        56404,      56379,      56353,      56328, 
        56302,      56276,      56250,      56225, 
        56199,      56173,      56147,      56121, 
        56095,      56069,      56043,      56017, 
        55991,      55965,      55938,      55912, 
        55886,      55860,      55833,      55807, 
        55781,      55754,      55728,      55701, 
        55675,      55648,      55622,      55595, 
        55569,      55542,      55515,      55489, 
        55462,      55435,      55408,      55381, 
        55354,      55327,      55300,      55274, 
        55246,      55219,      55192,      55165, 
        55138,      55111,      55084,      55056, 
        55029,      55002,      54974,      54947, 
        54920,      54892,      54865,      54837, 
        54810,      54782,      54755,      54727, 
        54699,      54672,      54644,      54616, 
        54588,      54560,      54533,      54505, 
        54477,      54449,      54421,      54393, 
        54365,      54337,      54308,      54280, 
        54252,      54224,      54196,      54167, 
        54139,      54111,      54082,      54054, 
        54026,      53997,      53969,      53940, 
        53911,      53883,      53854,      53826, 
        53797,      53768,      53739,      53711, 
        53682,      53653,      53624,      53595, 
        53566,      53537,      53508,      53479, 
        53450,      53421,      53392,      53363, 
        53334,      53304,      53275,      53246, 
        53216,      53187,      53158,      53128, 
        53099,      53069,      53040,      53010, 
        52981,      52951,      52922,      52892, 
        52862,      52832,      52803,      52773, 
        52743,      52713,      52683,      52653, 
        52624,      52594,      52564,      52534, 
        52503,      52473,      52443,      52413, 
        52383,      52353,      52322,      52292, 
        52262,      52231,      52201,      52171, 
        52140,      52110,      52079,      52049, 
        52018,      51988,      51957,      51926, 
        51896,      51865,      51834,      51803, 
        51773,      51742,      51711,      51680, 
        51649,      51618,      51587,      51556, 
        51525,      51494,      51463,      51432, 
        51401,      51369,      51338,      51307, 
        51276,      51244,      51213,      51182, 
        51150,      51119,      51087,      51056, 
        51024,      50993,      50961,      50929, 
        50898,      50866,      50834,      50803, 
        50771,      50739,      50707,      50675, 
        50644,      50612,      50580,      50548, 
        50516,      50484,      50452,      50420, 
        50387,      50355,      50323,      50291, 
        50259,      50226,      50194,      50162, 
        50129,      50097,      50065,      50032, 
        50000,      49967,      49935,      49902, 
        49869,      49837,      49804,      49771, 
        49739,      49706,      49673,      49640, 
        49608,      49575,      49542,      49509, 
        49476,      49443,      49410,      49377, 
        49344,      49311,      49278,      49244, 
        49211,      49178,      49145,      49112, 
        49078,      49045,      49012,      48978, 
        48945,      48911,      48878,      48844, 
        48811,      48777,      48744,      48710, 
        48676,      48643,      48609,      48575, 
        48542,      48508,      48474,      48440, 
        48406,      48372,      48338,      48304, 
        48271,      48237,      48202,      48168, 
        48134,      48100,      48066,      48032, 
        47998,      47963,      47929,      47895, 
        47860,      47826,      47792,      47757, 
        47723,      47688,      47654,      47619, 
        47585,      47550,      47516,      47481, 
        47446,      47412,      47377,      47342, 
        47308,      47273,      47238,      47203, 
        47168,      47133,      47098,      47063, 
        47028,      46993,      46958,      46923, 
        46888,      46853,      46818,      46783, 
        46747,      46712,      46677,      46642, 
        46606,      46571,      46536,      46500, 
        46465,      46429,      46394,      46358, 
        46323,      46287,      46252,      46216, 
        46180,      46145,      46109,      46073, 
        46037,      46002,      45966,      45930, 
        45894,      45858,      45822,      45786, 
        45750,      45714,      45678,      45642, 
        45606,      45570,      45534,      45498, 
        45462,      45425,      45389,      45353, 
        45316,      45280,      45244,      45207, 
        45171,      45135,      45098,      45062, 
        45025,      44989,      44952,      44915, 
        44879,      44842,      44806,      44769, 
        44732,      44695,      44659,      44622, 
        44585,      44548,      44511,      44474, 
        44437,      44400,      44363,      44326, 
        44289,      44252,      44215,      44178, 
        44141,      44104,      44067,      44029, 
        43992,      43955,      43918,      43880, 
        43843,      43806,      43768,      43731, 
        43693,      43656,      43618,      43581, 
        43543,      43506,      43468,      43430, 
        43393,      43355,      43317,      43280, 
        43242,      43204,      43166,      43128, 
        43091,      43053,      43015,      42977, 
        42939,      42901,      42863,      42825, 
        42787,      42749,      42711,      42672, 
        42634,      42596,      42558,      42520, 
        42481,      42443,      42405,      42366, 
        42328,      42290,      42251,      42213, 
        42174,      42136,      42097,      42059, 
        42020,      41982,      41943,      41904, 
        41866,      41827,      41788,      41750, 
        41711,      41672,      41633,      41595, 
        41556,      41517,      41478,      41439, 
        41400,      41361,      41322,      41283, 
        41244,      41205,      41166,      41127, 
        41088,      41048,      41009,      40970, 
        40931,      40891,      40852,      40813, 
        40773,      40734,      40695,      40655, 
        40616,      40576,      40537,      40497, 
        40458,      40418,      40379,      40339, 
        40300,      40260,      40220,      40180, 
        40141,      40101,      40061,      40021, 
        39982,      39942,      39902,      39862, 
        39822,      39782,      39742,      39702, 
        39662,      39622,      39582,      39542, 
        39502,      39462,      39422,      39382, 
        39341,      39301,      39261,      39221, 
        39180,      39140,      39100,      39059, 
        39019,      38979,      38938,      38898, 
        38857,      38817,      38776,      38736, 
        38695,      38655,      38614,      38573, 
        38533,      38492,      38451,      38411, 
        38370,      38329,      38288,      38248, 
        38207,      38166,      38125,      38084, 
        38043,      38002,      37961,      37920, 
        37879,      37838,      37797,      37756, 
        37715,      37674,      37633,      37592, 
        37551,      37509,      37468,      37427, 
        37386,      37344,      37303,      37262, 
        37220,      37179,      37137,      37096, 
        37055,      37013,      36972,      36930, 
        36889,      36847,      36805,      36764, 
        36722,      36681,      36639,      36597, 
        36556,      36514,      36472,      36430, 
        36388,      36347,      36305,      36263, 
        36221,      36179,      36137,      36095, 
        36053,      36011,      35969,      35927, 
        35885,      35843,      35801,      35759, 
        35717,      35675,      35633,      35590, 
        35548,      35506,      35464,      35421, 
        35379,      35337,      35294,      35252, 
        35210,      35167,      35125,      35082, 
        35040,      34997,      34955,      34912, 
        34870,      34827,      34785,      34742, 
        34699,      34657,      34614,      34571, 
        34529,      34486,      34443,      34400, 
        34358,      34315,      34272,      34229, 
        34186,      34143,      34100,      34057, 
        34015,      33972,      33929,      33886, 
        33843,      33799,      33756,      33713, 
        33670,      33627,      33584,      33541, 
        33498,      33454,      33411,      33368, 
        33325,      33281,      33238,      33195, 
        33151,      33108,      33065,      33021, 
        32978,      32934,      32891,      32847, 
        32804,      32760,      32717,      32673, 
        32630,      32586,      32542,      32499, 
        32455,      32411,      32368,      32324, 
        32280,      32236,      32193,      32149, 
        32105,      32061,      32017,      31974, 
        31930,      31886,      31842,      31798, 
        31754,      31710,      31666,      31622, 
        31578,      31534,      31490,      31446, 
        31402,      31357,      31313,      31269, 
        31225,      31181,      31136,      31092, 
        31048,      31004,      30959,      30915, 
        30871,      30826,      30782,      30738, 
        30693,      30649,      30604,      30560, 
        30515,      30471,      30426,      30382, 
        30337,      30293,      30248,      30204, 
        30159,      30114,      30070,      30025, 
        29980,      29936,      29891,      29846, 
        29801,      29757,      29712,      29667, 
        29622,      29577,      29533,      29488, 
        29443,      29398,      29353,      29308, 
        29263,      29218,      29173,      29128, 
        29083,      29038,      28993,      28948, 
        28903,      28858,      28812,      28767, 
        28722,      28677,      28632,      28586, 
        28541,      28496,      28451,      28405, 
        28360,      28315,      28269,      28224, 
        28179,      28133,      28088,      28042, 
        27997,      27952,      27906,      27861, 
        27815,      27770,      27724,      27678, 
        27633,      27587,      27542,      27496, 
        27450,      27405,      27359,      27313, 
        27268,      27222,      27176,      27131, 
        27085,      27039,      26993,      26947, 
        26902,      26856,      26810,      26764, 
        26718,      26672,      26626,      26580, 
        26534,      26488,      26442,      26396, 
        26350,      26304,      26258,      26212, 
        26166,      26120,      26074,      26028, 
        25982,      25936,      25889,      25843, 
        25797,      25751,      25705,      25658, 
        25612,      25566,      25520,      25473, 
        25427,      25381,      25334,      25288, 
        25241,      25195,      25149,      25102, 
        25056,      25009,      24963,      24916, 
        24870,      24823,      24777,      24730, 
        24684,      24637,      24591,      24544, 
        24497,      24451,      24404,      24357, 
        24311,      24264,      24217,      24171, 
        24124,      24077,      24030,      23984, 
        23937,      23890,      23843,      23796, 
        23750,      23703,      23656,      23609, 
        23562,      23515,      23468,      23421, 
        23374,      23327,      23280,      23233, 
        23186,      23139,      23092,      23045, 
        22998,      22951,      22904,      22857, 
        22810,      22763,      22716,      22668, 
        22621,      22574,      22527,      22480, 
        22433,      22385,      22338,      22291, 
        22243,      22196,      22149,      22102, 
        22054,      22007,      21960,      21912, 
        21865,      21817,      21770,      21723, 
        21675,      21628,      21580,      21533, 
        21485,      21438,      21390,      21343, 
        21295,      21248,      21200,      21153, 
        21105,      21057,      21010,      20962, 
        20915,      20867,      20819,      20772, 
        20724,      20676,      20629,      20581, 
        20533,      20485,      20438,      20390, 
        20342,      20294,      20246,      20199, 
        20151,      20103,      20055,      20007, 
        19959,      19912,      19864,      19816, 
        19768,      19720,      19672,      19624, 
        19576,      19528,      19480,      19432, 
        19384,      19336,      19288,      19240, 
        19192,      19144,      19096,      19048, 
        19000,      18951,      18903,      18855, 
        18807,      18759,      18711,      18663, 
        18614,      18566,      18518,      18470, 
        18421,      18373,      18325,      18277, 
        18228,      18180,      18132,      18084, 
        18035,      17987,      17939,      17890, 
        17842,      17793,      17745,      17697, 
        17648,      17600,      17551,      17503, 
        17455,      17406,      17358,      17309, 
        17261,      17212,      17164,      17115, 
        17067,      17018,      16970,      16921, 
        16872,      16824,      16775,      16727, 
        16678,      16629,      16581,      16532, 
        16484,      16435,      16386,      16338, 
        16289,      16240,      16191,      16143, 
        16094,      16045,      15997,      15948, 
        15899,      15850,      15802,      15753, 
        15704,      15655,      15606,      15557, 
        15509,      15460,      15411,      15362, 
        15313,      15264,      15215,      15167, 
        15118,      15069,      15020,      14971, 
        14922,      14873,      14824,      14775, 
        14726,      14677,      14628,      14579, 
        14530,      14481,      14432,      14383, 
        14334,      14285,      14236,      14187, 
        14138,      14089,      14040,      13990, 
        13941,      13892,      13843,      13794, 
        13745,      13696,      13646,      13597, 
        13548,      13499,      13450,      13401, 
        13351,      13302,      13253,      13204, 
        13154,      13105,      13056,      13007, 
        12957,      12908,      12859,      12810, 
        12760,      12711,      12662,      12612, 
        12563,      12514,      12464,      12415, 
        12366,      12316,      12267,      12218, 
        12168,      12119,      12069,      12020, 
        11970,      11921,      11872,      11822, 
        11773,      11723,      11674,      11624, 
        11575,      11525,      11476,      11426, 
        11377,      11327,      11278,      11228, 
        11179,      11129,      11080,      11030, 
        10981,      10931,      10882,      10832, 
        10782,      10733,      10683,      10634, 
        10584,      10534,      10485,      10435, 
        10386,      10336,      10286,      10237, 
        10187,      10137,      10088,      10038, 
        9988,      9939,      9889,      9839, 
        9790,      9740,      9690,      9640, 
        9591,      9541,      9491,      9442, 
        9392,      9342,      9292,      9243, 
        9193,      9143,      9093,      9043, 
        8994,      8944,      8894,      8844, 
        8794,      8745,      8695,      8645, 
        8595,      8545,      8496,      8446, 
        8396,      8346,      8296,      8246, 
        8196,      8147,      8097,      8047, 
        7997,      7947,      7897,      7847, 
        7797,      7747,      7697,      7648, 
        7598,      7548,      7498,      7448, 
        7398,      7348,      7298,      7248, 
        7198,      7148,      7098,      7048, 
        6998,      6948,      6898,      6848, 
        6798,      6748,      6698,      6648, 
        6598,      6548,      6498,      6448, 
        6398,      6348,      6298,      6248, 
        6198,      6148,      6098,      6048, 
        5998,      5948,      5898,      5848, 
        5798,      5748,      5697,      5647, 
        5597,      5547,      5497,      5447, 
        5397,      5347,      5297,      5247, 
        5197,      5146,      5096,      5046, 
        4996,      4946,      4896,      4846, 
        4796,      4745,      4695,      4645, 
        4595,      4545,      4495,      4445, 
        4394,      4344,      4294,      4244, 
        4194,      4144,      4093,      4043, 
        3993,      3943,      3893,      3843, 
        3792,      3742,      3692,      3642, 
        3592,      3541,      3491,      3441, 
        3391,      3341,      3291,      3240, 
        3190,      3140,      3090,      3039, 
        2989,      2939,      2889,      2839, 
        2788,      2738,      2688,      2638, 
        2587,      2537,      2487,      2437, 
        2387,      2336,      2286,      2236, 
        2186,      2135,      2085,      2035, 
        1985,      1934,      1884,      1834, 
        1784,      1733,      1683,      1633, 
        1583,      1532,      1482,      1432, 
        1382,      1331,      1281,      1231, 
        1181,      1130,      1080,      1030, 
        980,      929,      879,      829, 
        779,      728,      678,      628, 
        578,      527,      477,      427, 
        376,      326,      276,      226, 
        175,      125,      75,      25, 
        -25,      -75,      -125,      -175, 
        -226,      -276,      -326,      -376, 
        -427,      -477,      -527,      -578, 
        -628,      -678,      -728,      -779, 
        -829,      -879,      -929,      -980, 
        -1030,      -1080,      -1130,      -1181, 
        -1231,      -1281,      -1331,      -1382, 
        -1432,      -1482,      -1532,      -1583, 
        -1633,      -1683,      -1733,      -1784, 
        -1834,      -1884,      -1934,      -1985, 
        -2035,      -2085,      -2135,      -2186, 
        -2236,      -2286,      -2336,      -2387, 
        -2437,      -2487,      -2537,      -2588, 
        -2638,      -2688,      -2738,      -2788, 
        -2839,      -2889,      -2939,      -2989, 
        -3039,      -3090,      -3140,      -3190, 
        -3240,      -3291,      -3341,      -3391, 
        -3441,      -3491,      -3541,      -3592, 
        -3642,      -3692,      -3742,      -3792, 
        -3843,      -3893,      -3943,      -3993, 
        -4043,      -4093,      -4144,      -4194, 
        -4244,      -4294,      -4344,      -4394, 
        -4445,      -4495,      -4545,      -4595, 
        -4645,      -4695,      -4745,      -4796, 
        -4846,      -4896,      -4946,      -4996, 
        -5046,      -5096,      -5146,      -5197, 
        -5247,      -5297,      -5347,      -5397, 
        -5447,      -5497,      -5547,      -5597, 
        -5647,      -5697,      -5748,      -5798, 
        -5848,      -5898,      -5948,      -5998, 
        -6048,      -6098,      -6148,      -6198, 
        -6248,      -6298,      -6348,      -6398, 
        -6448,      -6498,      -6548,      -6598, 
        -6648,      -6698,      -6748,      -6798, 
        -6848,      -6898,      -6948,      -6998, 
        -7048,      -7098,      -7148,      -7198, 
        -7248,      -7298,      -7348,      -7398, 
        -7448,      -7498,      -7548,      -7598, 
        -7648,      -7697,      -7747,      -7797, 
        -7847,      -7897,      -7947,      -7997, 
        -8047,      -8097,      -8147,      -8196, 
        -8246,      -8296,      -8346,      -8396, 
        -8446,      -8496,      -8545,      -8595, 
        -8645,      -8695,      -8745,      -8794, 
        -8844,      -8894,      -8944,      -8994, 
        -9043,      -9093,      -9143,      -9193, 
        -9243,      -9292,      -9342,      -9392, 
        -9442,      -9491,      -9541,      -9591, 
        -9640,      -9690,      -9740,      -9790, 
        -9839,      -9889,      -9939,      -9988, 
        -10038,      -10088,      -10137,      -10187, 
        -10237,      -10286,      -10336,      -10386, 
        -10435,      -10485,      -10534,      -10584, 
        -10634,      -10683,      -10733,      -10782, 
        -10832,      -10882,      -10931,      -10981, 
        -11030,      -11080,      -11129,      -11179, 
        -11228,      -11278,      -11327,      -11377, 
        -11426,      -11476,      -11525,      -11575, 
        -11624,      -11674,      -11723,      -11773, 
        -11822,      -11872,      -11921,      -11970, 
        -12020,      -12069,      -12119,      -12168, 
        -12218,      -12267,      -12316,      -12366, 
        -12415,      -12464,      -12514,      -12563, 
        -12612,      -12662,      -12711,      -12760, 
        -12810,      -12859,      -12908,      -12957, 
        -13007,      -13056,      -13105,      -13154, 
        -13204,      -13253,      -13302,      -13351, 
        -13401,      -13450,      -13499,      -13548, 
        -13597,      -13647,      -13696,      -13745, 
        -13794,      -13843,      -13892,      -13941, 
        -13990,      -14040,      -14089,      -14138, 
        -14187,      -14236,      -14285,      -14334, 
        -14383,      -14432,      -14481,      -14530, 
        -14579,      -14628,      -14677,      -14726, 
        -14775,      -14824,      -14873,      -14922, 
        -14971,      -15020,      -15069,      -15118, 
        -15167,      -15215,      -15264,      -15313, 
        -15362,      -15411,      -15460,      -15509, 
        -15557,      -15606,      -15655,      -15704, 
        -15753,      -15802,      -15850,      -15899, 
        -15948,      -15997,      -16045,      -16094, 
        -16143,      -16191,      -16240,      -16289, 
        -16338,      -16386,      -16435,      -16484, 
        -16532,      -16581,      -16629,      -16678, 
        -16727,      -16775,      -16824,      -16872, 
        -16921,      -16970,      -17018,      -17067, 
        -17115,      -17164,      -17212,      -17261, 
        -17309,      -17358,      -17406,      -17455, 
        -17503,      -17551,      -17600,      -17648, 
        -17697,      -17745,      -17793,      -17842, 
        -17890,      -17939,      -17987,      -18035, 
        -18084,      -18132,      -18180,      -18228, 
        -18277,      -18325,      -18373,      -18421, 
        -18470,      -18518,      -18566,      -18614, 
        -18663,      -18711,      -18759,      -18807, 
        -18855,      -18903,      -18951,      -19000, 
        -19048,      -19096,      -19144,      -19192, 
        -19240,      -19288,      -19336,      -19384, 
        -19432,      -19480,      -19528,      -19576, 
        -19624,      -19672,      -19720,      -19768, 
        -19816,      -19864,      -19912,      -19959, 
        -20007,      -20055,      -20103,      -20151, 
        -20199,      -20246,      -20294,      -20342, 
        -20390,      -20438,      -20485,      -20533, 
        -20581,      -20629,      -20676,      -20724, 
        -20772,      -20819,      -20867,      -20915, 
        -20962,      -21010,      -21057,      -21105, 
        -21153,      -21200,      -21248,      -21295, 
        -21343,      -21390,      -21438,      -21485, 
        -21533,      -21580,      -21628,      -21675, 
        -21723,      -21770,      -21817,      -21865, 
        -21912,      -21960,      -22007,      -22054, 
        -22102,      -22149,      -22196,      -22243, 
        -22291,      -22338,      -22385,      -22433, 
        -22480,      -22527,      -22574,      -22621, 
        -22668,      -22716,      -22763,      -22810, 
        -22857,      -22904,      -22951,      -22998, 
        -23045,      -23092,      -23139,      -23186, 
        -23233,      -23280,      -23327,      -23374, 
        -23421,      -23468,      -23515,      -23562, 
        -23609,      -23656,      -23703,      -23750, 
        -23796,      -23843,      -23890,      -23937, 
        -23984,      -24030,      -24077,      -24124, 
        -24171,      -24217,      -24264,      -24311, 
        -24357,      -24404,      -24451,      -24497, 
        -24544,      -24591,      -24637,      -24684, 
        -24730,      -24777,      -24823,      -24870, 
        -24916,      -24963,      -25009,      -25056, 
        -25102,      -25149,      -25195,      -25241, 
        -25288,      -25334,      -25381,      -25427, 
        -25473,      -25520,      -25566,      -25612, 
        -25658,      -25705,      -25751,      -25797, 
        -25843,      -25889,      -25936,      -25982, 
        -26028,      -26074,      -26120,      -26166, 
        -26212,      -26258,      -26304,      -26350, 
        -26396,      -26442,      -26488,      -26534, 
        -26580,      -26626,      -26672,      -26718, 
        -26764,      -26810,      -26856,      -26902, 
        -26947,      -26993,      -27039,      -27085, 
        -27131,      -27176,      -27222,      -27268, 
        -27313,      -27359,      -27405,      -27450, 
        -27496,      -27542,      -27587,      -27633, 
        -27678,      -27724,      -27770,      -27815, 
        -27861,      -27906,      -27952,      -27997, 
        -28042,      -28088,      -28133,      -28179, 
        -28224,      -28269,      -28315,      -28360, 
        -28405,      -28451,      -28496,      -28541, 
        -28586,      -28632,      -28677,      -28722, 
        -28767,      -28812,      -28858,      -28903, 
        -28948,      -28993,      -29038,      -29083, 
        -29128,      -29173,      -29218,      -29263, 
        -29308,      -29353,      -29398,      -29443, 
        -29488,      -29533,      -29577,      -29622, 
        -29667,      -29712,      -29757,      -29801, 
        -29846,      -29891,      -29936,      -29980, 
        -30025,      -30070,      -30114,      -30159, 
        -30204,      -30248,      -30293,      -30337, 
        -30382,      -30426,      -30471,      -30515, 
        -30560,      -30604,      -30649,      -30693, 
        -30738,      -30782,      -30826,      -30871, 
        -30915,      -30959,      -31004,      -31048, 
        -31092,      -31136,      -31181,      -31225, 
        -31269,      -31313,      -31357,      -31402, 
        -31446,      -31490,      -31534,      -31578, 
        -31622,      -31666,      -31710,      -31754, 
        -31798,      -31842,      -31886,      -31930, 
        -31974,      -32017,      -32061,      -32105, 
        -32149,      -32193,      -32236,      -32280, 
        -32324,      -32368,      -32411,      -32455, 
        -32499,      -32542,      -32586,      -32630, 
        -32673,      -32717,      -32760,      -32804, 
        -32847,      -32891,      -32934,      -32978, 
        -33021,      -33065,      -33108,      -33151, 
        -33195,      -33238,      -33281,      -33325, 
        -33368,      -33411,      -33454,      -33498, 
        -33541,      -33584,      -33627,      -33670, 
        -33713,      -33756,      -33799,      -33843, 
        -33886,      -33929,      -33972,      -34015, 
        -34057,      -34100,      -34143,      -34186, 
        -34229,      -34272,      -34315,      -34358, 
        -34400,      -34443,      -34486,      -34529, 
        -34571,      -34614,      -34657,      -34699, 
        -34742,      -34785,      -34827,      -34870, 
        -34912,      -34955,      -34997,      -35040, 
        -35082,      -35125,      -35167,      -35210, 
        -35252,      -35294,      -35337,      -35379, 
        -35421,      -35464,      -35506,      -35548, 
        -35590,      -35633,      -35675,      -35717, 
        -35759,      -35801,      -35843,      -35885, 
        -35927,      -35969,      -36011,      -36053, 
        -36095,      -36137,      -36179,      -36221, 
        -36263,      -36305,      -36347,      -36388, 
        -36430,      -36472,      -36514,      -36555, 
        -36597,      -36639,      -36681,      -36722, 
        -36764,      -36805,      -36847,      -36889, 
        -36930,      -36972,      -37013,      -37055, 
        -37096,      -37137,      -37179,      -37220, 
        -37262,      -37303,      -37344,      -37386, 
        -37427,      -37468,      -37509,      -37551, 
        -37592,      -37633,      -37674,      -37715, 
        -37756,      -37797,      -37838,      -37879, 
        -37920,      -37961,      -38002,      -38043, 
        -38084,      -38125,      -38166,      -38207, 
        -38248,      -38288,      -38329,      -38370, 
        -38411,      -38451,      -38492,      -38533, 
        -38573,      -38614,      -38655,      -38695, 
        -38736,      -38776,      -38817,      -38857, 
        -38898,      -38938,      -38979,      -39019, 
        -39059,      -39100,      -39140,      -39180, 
        -39221,      -39261,      -39301,      -39341, 
        -39382,      -39422,      -39462,      -39502, 
        -39542,      -39582,      -39622,      -39662, 
        -39702,      -39742,      -39782,      -39822, 
        -39862,      -39902,      -39942,      -39982, 
        -40021,      -40061,      -40101,      -40141, 
        -40180,      -40220,      -40260,      -40299, 
        -40339,      -40379,      -40418,      -40458, 
        -40497,      -40537,      -40576,      -40616, 
        -40655,      -40695,      -40734,      -40773, 
        -40813,      -40852,      -40891,      -40931, 
        -40970,      -41009,      -41048,      -41087, 
        -41127,      -41166,      -41205,      -41244, 
        -41283,      -41322,      -41361,      -41400, 
        -41439,      -41478,      -41517,      -41556, 
        -41595,      -41633,      -41672,      -41711, 
        -41750,      -41788,      -41827,      -41866, 
        -41904,      -41943,      -41982,      -42020, 
        -42059,      -42097,      -42136,      -42174, 
        -42213,      -42251,      -42290,      -42328, 
        -42366,      -42405,      -42443,      -42481, 
        -42520,      -42558,      -42596,      -42634, 
        -42672,      -42711,      -42749,      -42787, 
        -42825,      -42863,      -42901,      -42939, 
        -42977,      -43015,      -43053,      -43091, 
        -43128,      -43166,      -43204,      -43242, 
        -43280,      -43317,      -43355,      -43393, 
        -43430,      -43468,      -43506,      -43543, 
        -43581,      -43618,      -43656,      -43693, 
        -43731,      -43768,      -43806,      -43843, 
        -43880,      -43918,      -43955,      -43992, 
        -44029,      -44067,      -44104,      -44141, 
        -44178,      -44215,      -44252,      -44289, 
        -44326,      -44363,      -44400,      -44437, 
        -44474,      -44511,      -44548,      -44585, 
        -44622,      -44659,      -44695,      -44732, 
        -44769,      -44806,      -44842,      -44879, 
        -44915,      -44952,      -44989,      -45025, 
        -45062,      -45098,      -45135,      -45171, 
        -45207,      -45244,      -45280,      -45316, 
        -45353,      -45389,      -45425,      -45462, 
        -45498,      -45534,      -45570,      -45606, 
        -45642,      -45678,      -45714,      -45750, 
        -45786,      -45822,      -45858,      -45894, 
        -45930,      -45966,      -46002,      -46037, 
        -46073,      -46109,      -46145,      -46180, 
        -46216,      -46252,      -46287,      -46323, 
        -46358,      -46394,      -46429,      -46465, 
        -46500,      -46536,      -46571,      -46606, 
        -46642,      -46677,      -46712,      -46747, 
        -46783,      -46818,      -46853,      -46888, 
        -46923,      -46958,      -46993,      -47028, 
        -47063,      -47098,      -47133,      -47168, 
        -47203,      -47238,      -47273,      -47308, 
        -47342,      -47377,      -47412,      -47446, 
        -47481,      -47516,      -47550,      -47585, 
        -47619,      -47654,      -47688,      -47723, 
        -47757,      -47792,      -47826,      -47860, 
        -47895,      -47929,      -47963,      -47998, 
        -48032,      -48066,      -48100,      -48134, 
        -48168,      -48202,      -48236,      -48271, 
        -48304,      -48338,      -48372,      -48406, 
        -48440,      -48474,      -48508,      -48542, 
        -48575,      -48609,      -48643,      -48676, 
        -48710,      -48744,      -48777,      -48811, 
        -48844,      -48878,      -48911,      -48945, 
        -48978,      -49012,      -49045,      -49078, 
        -49112,      -49145,      -49178,      -49211, 
        -49244,      -49278,      -49311,      -49344, 
        -49377,      -49410,      -49443,      -49476, 
        -49509,      -49542,      -49575,      -49608, 
        -49640,      -49673,      -49706,      -49739, 
        -49771,      -49804,      -49837,      -49869, 
        -49902,      -49935,      -49967,      -50000, 
        -50032,      -50065,      -50097,      -50129, 
        -50162,      -50194,      -50226,      -50259, 
        -50291,      -50323,      -50355,      -50387, 
        -50420,      -50452,      -50484,      -50516, 
        -50548,      -50580,      -50612,      -50644, 
        -50675,      -50707,      -50739,      -50771, 
        -50803,      -50834,      -50866,      -50898, 
        -50929,      -50961,      -50993,      -51024, 
        -51056,      -51087,      -51119,      -51150, 
        -51182,      -51213,      -51244,      -51276, 
        -51307,      -51338,      -51369,      -51401, 
        -51432,      -51463,      -51494,      -51525, 
        -51556,      -51587,      -51618,      -51649, 
        -51680,      -51711,      -51742,      -51773, 
        -51803,      -51834,      -51865,      -51896, 
        -51926,      -51957,      -51988,      -52018, 
        -52049,      -52079,      -52110,      -52140, 
        -52171,      -52201,      -52231,      -52262, 
        -52292,      -52322,      -52353,      -52383, 
        -52413,      -52443,      -52473,      -52503, 
        -52534,      -52564,      -52594,      -52624, 
        -52653,      -52683,      -52713,      -52743, 
        -52773,      -52803,      -52832,      -52862, 
        -52892,      -52922,      -52951,      -52981, 
        -53010,      -53040,      -53069,      -53099, 
        -53128,      -53158,      -53187,      -53216, 
        -53246,      -53275,      -53304,      -53334, 
        -53363,      -53392,      -53421,      -53450, 
        -53479,      -53508,      -53537,      -53566, 
        -53595,      -53624,      -53653,      -53682, 
        -53711,      -53739,      -53768,      -53797, 
        -53826,      -53854,      -53883,      -53911, 
        -53940,      -53969,      -53997,      -54026, 
        -54054,      -54082,      -54111,      -54139, 
        -54167,      -54196,      -54224,      -54252, 
        -54280,      -54308,      -54337,      -54365, 
        -54393,      -54421,      -54449,      -54477, 
        -54505,      -54533,      -54560,      -54588, 
        -54616,      -54644,      -54672,      -54699, 
        -54727,      -54755,      -54782,      -54810, 
        -54837,      -54865,      -54892,      -54920, 
        -54947,      -54974,      -55002,      -55029, 
        -55056,      -55084,      -55111,      -55138, 
        -55165,      -55192,      -55219,      -55246, 
        -55274,      -55300,      -55327,      -55354, 
        -55381,      -55408,      -55435,      -55462, 
        -55489,      -55515,      -55542,      -55569, 
        -55595,      -55622,      -55648,      -55675, 
        -55701,      -55728,      -55754,      -55781, 
        -55807,      -55833,      -55860,      -55886, 
        -55912,      -55938,      -55965,      -55991, 
        -56017,      -56043,      -56069,      -56095, 
        -56121,      -56147,      -56173,      -56199, 
        -56225,      -56250,      -56276,      -56302, 
        -56328,      -56353,      -56379,      -56404, 
        -56430,      -56456,      -56481,      -56507, 
        -56532,      -56557,      -56583,      -56608, 
        -56633,      -56659,      -56684,      -56709, 
        -56734,      -56760,      -56785,      -56810, 
        -56835,      -56860,      -56885,      -56910, 
        -56935,      -56959,      -56984,      -57009, 
        -57034,      -57059,      -57083,      -57108, 
        -57133,      -57157,      -57182,      -57206, 
        -57231,      -57255,      -57280,      -57304, 
        -57329,      -57353,      -57377,      -57402, 
        -57426,      -57450,      -57474,      -57498, 
        -57522,      -57546,      -57570,      -57594, 
        -57618,      -57642,      -57666,      -57690, 
        -57714,      -57738,      -57762,      -57785, 
        -57809,      -57833,      -57856,      -57880, 
        -57903,      -57927,      -57950,      -57974, 
        -57997,      -58021,      -58044,      -58067, 
        -58091,      -58114,      -58137,      -58160, 
        -58183,      -58207,      -58230,      -58253, 
        -58276,      -58299,      -58322,      -58345, 
        -58367,      -58390,      -58413,      -58436, 
        -58459,      -58481,      -58504,      -58527, 
        -58549,      -58572,      -58594,      -58617, 
        -58639,      -58662,      -58684,      -58706, 
        -58729,      -58751,      -58773,      -58795, 
        -58818,      -58840,      -58862,      -58884, 
        -58906,      -58928,      -58950,      -58972, 
        -58994,      -59016,      -59038,      -59059, 
        -59081,      -59103,      -59125,      -59146, 
        -59168,      -59190,      -59211,      -59233, 
        -59254,      -59276,      -59297,      -59318, 
        -59340,      -59361,      -59382,      -59404, 
        -59425,      -59446,      -59467,      -59488, 
        -59509,      -59530,      -59551,      -59572, 
        -59593,      -59614,      -59635,      -59656, 
        -59677,      -59697,      -59718,      -59739, 
        -59759,      -59780,      -59801,      -59821, 
        -59842,      -59862,      -59883,      -59903, 
        -59923,      -59944,      -59964,      -59984, 
        -60004,      -60025,      -60045,      -60065, 
        -60085,      -60105,      -60125,      -60145, 
        -60165,      -60185,      -60205,      -60225, 
        -60244,      -60264,      -60284,      -60304, 
        -60323,      -60343,      -60363,      -60382, 
        -60402,      -60421,      -60441,      -60460, 
        -60479,      -60499,      -60518,      -60537, 
        -60556,      -60576,      -60595,      -60614, 
        -60633,      -60652,      -60671,      -60690, 
        -60709,      -60728,      -60747,      -60766, 
        -60785,      -60803,      -60822,      -60841, 
        -60859,      -60878,      -60897,      -60915, 
        -60934,      -60952,      -60971,      -60989, 
        -61007,      -61026,      -61044,      -61062, 
        -61081,      -61099,      -61117,      -61135, 
        -61153,      -61171,      -61189,      -61207, 
        -61225,      -61243,      -61261,      -61279, 
        -61297,      -61314,      -61332,      -61350, 
        -61367,      -61385,      -61403,      -61420, 
        -61438,      -61455,      -61473,      -61490, 
        -61507,      -61525,      -61542,      -61559, 
        -61577,      -61594,      -61611,      -61628, 
        -61645,      -61662,      -61679,      -61696, 
        -61713,      -61730,      -61747,      -61764, 
        -61780,      -61797,      -61814,      -61831, 
        -61847,      -61864,      -61880,      -61897, 
        -61913,      -61930,      -61946,      -61963, 
        -61979,      -61995,      -62012,      -62028, 
        -62044,      -62060,      -62076,      -62092, 
        -62108,      -62125,      -62141,      -62156, 
        -62172,      -62188,      -62204,      -62220, 
        -62236,      -62251,      -62267,      -62283, 
        -62298,      -62314,      -62329,      -62345, 
        -62360,      -62376,      -62391,      -62407, 
        -62422,      -62437,      -62453,      -62468, 
        -62483,      -62498,      -62513,      -62528, 
        -62543,      -62558,      -62573,      -62588, 
        -62603,      -62618,      -62633,      -62648, 
        -62662,      -62677,      -62692,      -62706, 
        -62721,      -62735,      -62750,      -62764, 
        -62779,      -62793,      -62808,      -62822, 
        -62836,      -62850,      -62865,      -62879, 
        -62893,      -62907,      -62921,      -62935, 
        -62949,      -62963,      -62977,      -62991, 
        -63005,      -63019,      -63032,      -63046, 
        -63060,      -63074,      -63087,      -63101, 
        -63114,      -63128,      -63141,      -63155, 
        -63168,      -63182,      -63195,      -63208, 
        -63221,      -63235,      -63248,      -63261, 
        -63274,      -63287,      -63300,      -63313, 
        -63326,      -63339,      -63352,      -63365, 
        -63378,      -63390,      -63403,      -63416, 
        -63429,      -63441,      -63454,      -63466, 
        -63479,      -63491,      -63504,      -63516, 
        -63528,      -63541,      -63553,      -63565, 
        -63578,      -63590,      -63602,      -63614, 
        -63626,      -63638,      -63650,      -63662, 
        -63674,      -63686,      -63698,      -63709, 
        -63721,      -63733,      -63745,      -63756, 
        -63768,      -63779,      -63791,      -63803, 
        -63814,      -63825,      -63837,      -63848, 
        -63859,      -63871,      -63882,      -63893, 
        -63904,      -63915,      -63927,      -63938, 
        -63949,      -63960,      -63971,      -63981, 
        -63992,      -64003,      -64014,      -64025, 
        -64035,      -64046,      -64057,      -64067, 
        -64078,      -64088,      -64099,      -64109, 
        -64120,      -64130,      -64140,      -64151, 
        -64161,      -64171,      -64181,      -64192, 
        -64202,      -64212,      -64222,      -64232, 
        -64242,      -64252,      -64261,      -64271, 
        -64281,      -64291,      -64301,      -64310, 
        -64320,      -64330,      -64339,      -64349, 
        -64358,      -64368,      -64377,      -64387, 
        -64396,      -64405,      -64414,      -64424, 
        -64433,      -64442,      -64451,      -64460, 
        -64469,      -64478,      -64487,      -64496, 
        -64505,      -64514,      -64523,      -64532, 
        -64540,      -64549,      -64558,      -64566, 
        -64575,      -64584,      -64592,      -64601, 
        -64609,      -64617,      -64626,      -64634, 
        -64642,      -64651,      -64659,      -64667, 
        -64675,      -64683,      -64691,      -64699, 
        -64707,      -64715,      -64723,      -64731, 
        -64739,      -64747,      -64754,      -64762, 
        -64770,      -64777,      -64785,      -64793, 
        -64800,      -64808,      -64815,      -64822, 
        -64830,      -64837,      -64844,      -64852, 
        -64859,      -64866,      -64873,      -64880, 
        -64887,      -64895,      -64902,      -64908, 
        -64915,      -64922,      -64929,      -64936, 
        -64943,      -64949,      -64956,      -64963, 
        -64969,      -64976,      -64982,      -64989, 
        -64995,      -65002,      -65008,      -65015, 
        -65021,      -65027,      -65033,      -65040, 
        -65046,      -65052,      -65058,      -65064, 
        -65070,      -65076,      -65082,      -65088, 
        -65094,      -65099,      -65105,      -65111, 
        -65117,      -65122,      -65128,      -65133, 
        -65139,      -65144,      -65150,      -65155, 
        -65161,      -65166,      -65171,      -65177, 
        -65182,      -65187,      -65192,      -65197, 
        -65202,      -65207,      -65212,      -65217, 
        -65222,      -65227,      -65232,      -65237, 
        -65242,      -65246,      -65251,      -65256, 
        -65260,      -65265,      -65270,      -65274, 
        -65279,      -65283,      -65287,      -65292, 
        -65296,      -65300,      -65305,      -65309, 
        -65313,      -65317,      -65321,      -65325, 
        -65329,      -65333,      -65337,      -65341, 
        -65345,      -65349,      -65352,      -65356, 
        -65360,      -65363,      -65367,      -65371, 
        -65374,      -65378,      -65381,      -65385, 
        -65388,      -65391,      -65395,      -65398, 
        -65401,      -65404,      -65408,      -65411, 
        -65414,      -65417,      -65420,      -65423, 
        -65426,      -65429,      -65431,      -65434, 
        -65437,      -65440,      -65442,      -65445, 
        -65448,      -65450,      -65453,      -65455, 
        -65458,      -65460,      -65463,      -65465, 
        -65467,      -65470,      -65472,      -65474, 
        -65476,      -65478,      -65480,      -65482, 
        -65484,      -65486,      -65488,      -65490, 
        -65492,      -65494,      -65496,      -65497, 
        -65499,      -65501,      -65502,      -65504, 
        -65505,      -65507,      -65508,      -65510, 
        -65511,      -65513,      -65514,      -65515, 
        -65516,      -65518,      -65519,      -65520, 
        -65521,      -65522,      -65523,      -65524, 
        -65525,      -65526,      -65527,      -65527, 
        -65528,      -65529,      -65530,      -65530, 
        -65531,      -65531,      -65532,      -65532, 
        -65533,      -65533,      -65534,      -65534, 
        -65534,      -65535,      -65535,      -65535, 
        -65535,      -65535,      -65535,      -65535, 
        -65535,      -65535,      -65535,      -65535, 
        -65535,      -65535,      -65535,      -65534, 
        -65534,      -65534,      -65533,      -65533, 
        -65532,      -65532,      -65531,      -65531, 
        -65530,      -65530,      -65529,      -65528, 
        -65527,      -65527,      -65526,      -65525, 
        -65524,      -65523,      -65522,      -65521, 
        -65520,      -65519,      -65518,      -65516, 
        -65515,      -65514,      -65513,      -65511, 
        -65510,      -65508,      -65507,      -65505, 
        -65504,      -65502,      -65501,      -65499, 
        -65497,      -65496,      -65494,      -65492, 
        -65490,      -65488,      -65486,      -65484, 
        -65482,      -65480,      -65478,      -65476, 
        -65474,      -65472,      -65470,      -65467, 
        -65465,      -65463,      -65460,      -65458, 
        -65455,      -65453,      -65450,      -65448, 
        -65445,      -65442,      -65440,      -65437, 
        -65434,      -65431,      -65429,      -65426, 
        -65423,      -65420,      -65417,      -65414, 
        -65411,      -65408,      -65404,      -65401, 
        -65398,      -65395,      -65391,      -65388, 
        -65385,      -65381,      -65378,      -65374, 
        -65371,      -65367,      -65363,      -65360, 
        -65356,      -65352,      -65349,      -65345, 
        -65341,      -65337,      -65333,      -65329, 
        -65325,      -65321,      -65317,      -65313, 
        -65309,      -65305,      -65300,      -65296, 
        -65292,      -65287,      -65283,      -65279, 
        -65274,      -65270,      -65265,      -65260, 
        -65256,      -65251,      -65246,      -65242, 
        -65237,      -65232,      -65227,      -65222, 
        -65217,      -65212,      -65207,      -65202, 
        -65197,      -65192,      -65187,      -65182, 
        -65177,      -65171,      -65166,      -65161, 
        -65155,      -65150,      -65144,      -65139, 
        -65133,      -65128,      -65122,      -65117, 
        -65111,      -65105,      -65099,      -65094, 
        -65088,      -65082,      -65076,      -65070, 
        -65064,      -65058,      -65052,      -65046, 
        -65040,      -65033,      -65027,      -65021, 
        -65015,      -65008,      -65002,      -64995, 
        -64989,      -64982,      -64976,      -64969, 
        -64963,      -64956,      -64949,      -64943, 
        -64936,      -64929,      -64922,      -64915, 
        -64908,      -64902,      -64895,      -64887, 
        -64880,      -64873,      -64866,      -64859, 
        -64852,      -64844,      -64837,      -64830, 
        -64822,      -64815,      -64808,      -64800, 
        -64793,      -64785,      -64777,      -64770, 
        -64762,      -64754,      -64747,      -64739, 
        -64731,      -64723,      -64715,      -64707, 
        -64699,      -64691,      -64683,      -64675, 
        -64667,      -64659,      -64651,      -64642, 
        -64634,      -64626,      -64617,      -64609, 
        -64601,      -64592,      -64584,      -64575, 
        -64566,      -64558,      -64549,      -64540, 
        -64532,      -64523,      -64514,      -64505, 
        -64496,      -64487,      -64478,      -64469, 
        -64460,      -64451,      -64442,      -64433, 
        -64424,      -64414,      -64405,      -64396, 
        -64387,      -64377,      -64368,      -64358, 
        -64349,      -64339,      -64330,      -64320, 
        -64310,      -64301,      -64291,      -64281, 
        -64271,      -64261,      -64252,      -64242, 
        -64232,      -64222,      -64212,      -64202, 
        -64192,      -64181,      -64171,      -64161, 
        -64151,      -64140,      -64130,      -64120, 
        -64109,      -64099,      -64088,      -64078, 
        -64067,      -64057,      -64046,      -64035, 
        -64025,      -64014,      -64003,      -63992, 
        -63981,      -63971,      -63960,      -63949, 
        -63938,      -63927,      -63915,      -63904, 
        -63893,      -63882,      -63871,      -63859, 
        -63848,      -63837,      -63825,      -63814, 
        -63803,      -63791,      -63779,      -63768, 
        -63756,      -63745,      -63733,      -63721, 
        -63709,      -63698,      -63686,      -63674, 
        -63662,      -63650,      -63638,      -63626, 
        -63614,      -63602,      -63590,      -63578, 
        -63565,      -63553,      -63541,      -63528, 
        -63516,      -63504,      -63491,      -63479, 
        -63466,      -63454,      -63441,      -63429, 
        -63416,      -63403,      -63390,      -63378, 
        -63365,      -63352,      -63339,      -63326, 
        -63313,      -63300,      -63287,      -63274, 
        -63261,      -63248,      -63235,      -63221, 
        -63208,      -63195,      -63182,      -63168, 
        -63155,      -63141,      -63128,      -63114, 
        -63101,      -63087,      -63074,      -63060, 
        -63046,      -63032,      -63019,      -63005, 
        -62991,      -62977,      -62963,      -62949, 
        -62935,      -62921,      -62907,      -62893, 
        -62879,      -62865,      -62850,      -62836, 
        -62822,      -62808,      -62793,      -62779, 
        -62764,      -62750,      -62735,      -62721, 
        -62706,      -62692,      -62677,      -62662, 
        -62648,      -62633,      -62618,      -62603, 
        -62588,      -62573,      -62558,      -62543, 
        -62528,      -62513,      -62498,      -62483, 
        -62468,      -62453,      -62437,      -62422, 
        -62407,      -62391,      -62376,      -62360, 
        -62345,      -62329,      -62314,      -62298, 
        -62283,      -62267,      -62251,      -62236, 
        -62220,      -62204,      -62188,      -62172, 
        -62156,      -62141,      -62125,      -62108, 
        -62092,      -62076,      -62060,      -62044, 
        -62028,      -62012,      -61995,      -61979, 
        -61963,      -61946,      -61930,      -61913, 
        -61897,      -61880,      -61864,      -61847, 
        -61831,      -61814,      -61797,      -61780, 
        -61764,      -61747,      -61730,      -61713, 
        -61696,      -61679,      -61662,      -61645, 
        -61628,      -61611,      -61594,      -61577, 
        -61559,      -61542,      -61525,      -61507, 
        -61490,      -61473,      -61455,      -61438, 
        -61420,      -61403,      -61385,      -61367, 
        -61350,      -61332,      -61314,      -61297, 
        -61279,      -61261,      -61243,      -61225, 
        -61207,      -61189,      -61171,      -61153, 
        -61135,      -61117,      -61099,      -61081, 
        -61062,      -61044,      -61026,      -61007, 
        -60989,      -60971,      -60952,      -60934, 
        -60915,      -60897,      -60878,      -60859, 
        -60841,      -60822,      -60803,      -60785, 
        -60766,      -60747,      -60728,      -60709, 
        -60690,      -60671,      -60652,      -60633, 
        -60614,      -60595,      -60576,      -60556, 
        -60537,      -60518,      -60499,      -60479, 
        -60460,      -60441,      -60421,      -60402, 
        -60382,      -60363,      -60343,      -60323, 
        -60304,      -60284,      -60264,      -60244, 
        -60225,      -60205,      -60185,      -60165, 
        -60145,      -60125,      -60105,      -60085, 
        -60065,      -60045,      -60025,      -60004, 
        -59984,      -59964,      -59944,      -59923, 
        -59903,      -59883,      -59862,      -59842, 
        -59821,      -59801,      -59780,      -59759, 
        -59739,      -59718,      -59697,      -59677, 
        -59656,      -59635,      -59614,      -59593, 
        -59572,      -59551,      -59530,      -59509, 
        -59488,      -59467,      -59446,      -59425, 
        -59404,      -59382,      -59361,      -59340, 
        -59318,      -59297,      -59276,      -59254, 
        -59233,      -59211,      -59189,      -59168, 
        -59146,      -59125,      -59103,      -59081, 
        -59059,      -59038,      -59016,      -58994, 
        -58972,      -58950,      -58928,      -58906, 
        -58884,      -58862,      -58840,      -58818, 
        -58795,      -58773,      -58751,      -58729, 
        -58706,      -58684,      -58662,      -58639, 
        -58617,      -58594,      -58572,      -58549, 
        -58527,      -58504,      -58481,      -58459, 
        -58436,      -58413,      -58390,      -58367, 
        -58345,      -58322,      -58299,      -58276, 
        -58253,      -58230,      -58207,      -58183, 
        -58160,      -58137,      -58114,      -58091, 
        -58067,      -58044,      -58021,      -57997, 
        -57974,      -57950,      -57927,      -57903, 
        -57880,      -57856,      -57833,      -57809, 
        -57785,      -57762,      -57738,      -57714, 
        -57690,      -57666,      -57642,      -57618, 
        -57594,      -57570,      -57546,      -57522, 
        -57498,      -57474,      -57450,      -57426, 
        -57402,      -57377,      -57353,      -57329, 
        -57304,      -57280,      -57255,      -57231, 
        -57206,      -57182,      -57157,      -57133, 
        -57108,      -57083,      -57059,      -57034, 
        -57009,      -56984,      -56959,      -56935, 
        -56910,      -56885,      -56860,      -56835, 
        -56810,      -56785,      -56760,      -56734, 
        -56709,      -56684,      -56659,      -56633, 
        -56608,      -56583,      -56557,      -56532, 
        -56507,      -56481,      -56456,      -56430, 
        -56404,      -56379,      -56353,      -56328, 
        -56302,      -56276,      -56250,      -56225, 
        -56199,      -56173,      -56147,      -56121, 
        -56095,      -56069,      -56043,      -56017, 
        -55991,      -55965,      -55938,      -55912, 
        -55886,      -55860,      -55833,      -55807, 
        -55781,      -55754,      -55728,      -55701, 
        -55675,      -55648,      -55622,      -55595, 
        -55569,      -55542,      -55515,      -55489, 
        -55462,      -55435,      -55408,      -55381, 
        -55354,      -55327,      -55300,      -55274, 
        -55246,      -55219,      -55192,      -55165, 
        -55138,      -55111,      -55084,      -55056, 
        -55029,      -55002,      -54974,      -54947, 
        -54920,      -54892,      -54865,      -54837, 
        -54810,      -54782,      -54755,      -54727, 
        -54699,      -54672,      -54644,      -54616, 
        -54588,      -54560,      -54533,      -54505, 
        -54477,      -54449,      -54421,      -54393, 
        -54365,      -54337,      -54308,      -54280, 
        -54252,      -54224,      -54196,      -54167, 
        -54139,      -54111,      -54082,      -54054, 
        -54026,      -53997,      -53969,      -53940, 
        -53911,      -53883,      -53854,      -53826, 
        -53797,      -53768,      -53739,      -53711, 
        -53682,      -53653,      -53624,      -53595, 
        -53566,      -53537,      -53508,      -53479, 
        -53450,      -53421,      -53392,      -53363, 
        -53334,      -53304,      -53275,      -53246, 
        -53216,      -53187,      -53158,      -53128, 
        -53099,      -53069,      -53040,      -53010, 
        -52981,      -52951,      -52922,      -52892, 
        -52862,      -52832,      -52803,      -52773, 
        -52743,      -52713,      -52683,      -52653, 
        -52624,      -52594,      -52564,      -52534, 
        -52503,      -52473,      -52443,      -52413, 
        -52383,      -52353,      -52322,      -52292, 
        -52262,      -52231,      -52201,      -52171, 
        -52140,      -52110,      -52079,      -52049, 
        -52018,      -51988,      -51957,      -51926, 
        -51896,      -51865,      -51834,      -51803, 
        -51773,      -51742,      -51711,      -51680, 
        -51649,      -51618,      -51587,      -51556, 
        -51525,      -51494,      -51463,      -51432, 
        -51401,      -51369,      -51338,      -51307, 
        -51276,      -51244,      -51213,      -51182, 
        -51150,      -51119,      -51087,      -51056, 
        -51024,      -50993,      -50961,      -50929, 
        -50898,      -50866,      -50834,      -50803, 
        -50771,      -50739,      -50707,      -50675, 
        -50644,      -50612,      -50580,      -50548, 
        -50516,      -50484,      -50452,      -50420, 
        -50387,      -50355,      -50323,      -50291, 
        -50259,      -50226,      -50194,      -50162, 
        -50129,      -50097,      -50065,      -50032, 
        -50000,      -49967,      -49935,      -49902, 
        -49869,      -49837,      -49804,      -49771, 
        -49739,      -49706,      -49673,      -49640, 
        -49608,      -49575,      -49542,      -49509, 
        -49476,      -49443,      -49410,      -49377, 
        -49344,      -49311,      -49278,      -49244, 
        -49211,      -49178,      -49145,      -49112, 
        -49078,      -49045,      -49012,      -48978, 
        -48945,      -48911,      -48878,      -48844, 
        -48811,      -48777,      -48744,      -48710, 
        -48676,      -48643,      -48609,      -48575, 
        -48542,      -48508,      -48474,      -48440, 
        -48406,      -48372,      -48338,      -48305, 
        -48271,      -48237,      -48202,      -48168, 
        -48134,      -48100,      -48066,      -48032, 
        -47998,      -47963,      -47929,      -47895, 
        -47860,      -47826,      -47792,      -47757, 
        -47723,      -47688,      -47654,      -47619, 
        -47585,      -47550,      -47516,      -47481, 
        -47446,      -47412,      -47377,      -47342, 
        -47307,      -47273,      -47238,      -47203, 
        -47168,      -47133,      -47098,      -47063, 
        -47028,      -46993,      -46958,      -46923, 
        -46888,      -46853,      -46818,      -46783, 
        -46747,      -46712,      -46677,      -46642, 
        -46606,      -46571,      -46536,      -46500, 
        -46465,      -46429,      -46394,      -46358, 
        -46323,      -46287,      -46251,      -46216, 
        -46180,      -46145,      -46109,      -46073, 
        -46037,      -46002,      -45966,      -45930, 
        -45894,      -45858,      -45822,      -45786, 
        -45750,      -45714,      -45678,      -45642, 
        -45606,      -45570,      -45534,      -45498, 
        -45462,      -45425,      -45389,      -45353, 
        -45316,      -45280,      -45244,      -45207, 
        -45171,      -45135,      -45098,      -45062, 
        -45025,      -44989,      -44952,      -44915, 
        -44879,      -44842,      -44806,      -44769, 
        -44732,      -44695,      -44659,      -44622, 
        -44585,      -44548,      -44511,      -44474, 
        -44437,      -44400,      -44363,      -44326, 
        -44289,      -44252,      -44215,      -44178, 
        -44141,      -44104,      -44067,      -44029, 
        -43992,      -43955,      -43918,      -43880, 
        -43843,      -43806,      -43768,      -43731, 
        -43693,      -43656,      -43618,      -43581, 
        -43543,      -43506,      -43468,      -43430, 
        -43393,      -43355,      -43317,      -43280, 
        -43242,      -43204,      -43166,      -43128, 
        -43091,      -43053,      -43015,      -42977, 
        -42939,      -42901,      -42863,      -42825, 
        -42787,      -42749,      -42711,      -42672, 
        -42634,      -42596,      -42558,      -42520, 
        -42481,      -42443,      -42405,      -42366, 
        -42328,      -42290,      -42251,      -42213, 
        -42174,      -42136,      -42097,      -42059, 
        -42020,      -41982,      -41943,      -41904, 
        -41866,      -41827,      -41788,      -41750, 
        -41711,      -41672,      -41633,      -41595, 
        -41556,      -41517,      -41478,      -41439, 
        -41400,      -41361,      -41322,      -41283, 
        -41244,      -41205,      -41166,      -41127, 
        -41087,      -41048,      -41009,      -40970, 
        -40931,      -40891,      -40852,      -40813, 
        -40773,      -40734,      -40695,      -40655, 
        -40616,      -40576,      -40537,      -40497, 
        -40458,      -40418,      -40379,      -40339, 
        -40299,      -40260,      -40220,      -40180, 
        -40141,      -40101,      -40061,      -40021, 
        -39982,      -39942,      -39902,      -39862, 
        -39822,      -39782,      -39742,      -39702, 
        -39662,      -39622,      -39582,      -39542, 
        -39502,      -39462,      -39422,      -39382, 
        -39341,      -39301,      -39261,      -39221, 
        -39180,      -39140,      -39100,      -39059, 
        -39019,      -38979,      -38938,      -38898, 
        -38857,      -38817,      -38776,      -38736, 
        -38695,      -38655,      -38614,      -38573, 
        -38533,      -38492,      -38451,      -38411, 
        -38370,      -38329,      -38288,      -38248, 
        -38207,      -38166,      -38125,      -38084, 
        -38043,      -38002,      -37961,      -37920, 
        -37879,      -37838,      -37797,      -37756, 
        -37715,      -37674,      -37633,      -37592, 
        -37550,      -37509,      -37468,      -37427, 
        -37386,      -37344,      -37303,      -37262, 
        -37220,      -37179,      -37137,      -37096, 
        -37055,      -37013,      -36972,      -36930, 
        -36889,      -36847,      -36805,      -36764, 
        -36722,      -36681,      -36639,      -36597, 
        -36556,      -36514,      -36472,      -36430, 
        -36388,      -36347,      -36305,      -36263, 
        -36221,      -36179,      -36137,      -36095, 
        -36053,      -36011,      -35969,      -35927, 
        -35885,      -35843,      -35801,      -35759, 
        -35717,      -35675,      -35633,      -35590, 
        -35548,      -35506,      -35464,      -35421, 
        -35379,      -35337,      -35294,      -35252, 
        -35210,      -35167,      -35125,      -35082, 
        -35040,      -34997,      -34955,      -34912, 
        -34870,      -34827,      -34785,      -34742, 
        -34699,      -34657,      -34614,      -34571, 
        -34529,      -34486,      -34443,      -34400, 
        -34358,      -34315,      -34272,      -34229, 
        -34186,      -34143,      -34100,      -34057, 
        -34015,      -33972,      -33929,      -33886, 
        -33843,      -33799,      -33756,      -33713, 
        -33670,      -33627,      -33584,      -33541, 
        -33498,      -33454,      -33411,      -33368, 
        -33325,      -33281,      -33238,      -33195, 
        -33151,      -33108,      -33065,      -33021, 
        -32978,      -32934,      -32891,      -32847, 
        -32804,      -32760,      -32717,      -32673, 
        -32630,      -32586,      -32542,      -32499, 
        -32455,      -32411,      -32368,      -32324, 
        -32280,      -32236,      -32193,      -32149, 
        -32105,      -32061,      -32017,      -31974, 
        -31930,      -31886,      -31842,      -31798, 
        -31754,      -31710,      -31666,      -31622, 
        -31578,      -31534,      -31490,      -31446, 
        -31402,      -31357,      -31313,      -31269, 
        -31225,      -31181,      -31136,      -31092, 
        -31048,      -31004,      -30959,      -30915, 
        -30871,      -30826,      -30782,      -30738, 
        -30693,      -30649,      -30604,      -30560, 
        -30515,      -30471,      -30426,      -30382, 
        -30337,      -30293,      -30248,      -30204, 
        -30159,      -30114,      -30070,      -30025, 
        -29980,      -29936,      -29891,      -29846, 
        -29801,      -29757,      -29712,      -29667, 
        -29622,      -29577,      -29533,      -29488, 
        -29443,      -29398,      -29353,      -29308, 
        -29263,      -29218,      -29173,      -29128, 
        -29083,      -29038,      -28993,      -28948, 
        -28903,      -28858,      -28812,      -28767, 
        -28722,      -28677,      -28632,      -28586, 
        -28541,      -28496,      -28451,      -28405, 
        -28360,      -28315,      -28269,      -28224, 
        -28179,      -28133,      -28088,      -28042, 
        -27997,      -27952,      -27906,      -27861, 
        -27815,      -27770,      -27724,      -27678, 
        -27633,      -27587,      -27542,      -27496, 
        -27450,      -27405,      -27359,      -27313, 
        -27268,      -27222,      -27176,      -27131, 
        -27085,      -27039,      -26993,      -26947, 
        -26902,      -26856,      -26810,      -26764, 
        -26718,      -26672,      -26626,      -26580, 
        -26534,      -26488,      -26442,      -26396, 
        -26350,      -26304,      -26258,      -26212, 
        -26166,      -26120,      -26074,      -26028, 
        -25982,      -25936,      -25889,      -25843, 
        -25797,      -25751,      -25705,      -25658, 
        -25612,      -25566,      -25520,      -25473, 
        -25427,      -25381,      -25334,      -25288, 
        -25241,      -25195,      -25149,      -25102, 
        -25056,      -25009,      -24963,      -24916, 
        -24870,      -24823,      -24777,      -24730, 
        -24684,      -24637,      -24591,      -24544, 
        -24497,      -24451,      -24404,      -24357, 
        -24311,      -24264,      -24217,      -24171, 
        -24124,      -24077,      -24030,      -23984, 
        -23937,      -23890,      -23843,      -23796, 
        -23750,      -23703,      -23656,      -23609, 
        -23562,      -23515,      -23468,      -23421, 
        -23374,      -23327,      -23280,      -23233, 
        -23186,      -23139,      -23092,      -23045, 
        -22998,      -22951,      -22904,      -22857, 
        -22810,      -22763,      -22716,      -22668, 
        -22621,      -22574,      -22527,      -22480, 
        -22432,      -22385,      -22338,      -22291, 
        -22243,      -22196,      -22149,      -22102, 
        -22054,      -22007,      -21960,      -21912, 
        -21865,      -21817,      -21770,      -21723, 
        -21675,      -21628,      -21580,      -21533, 
        -21485,      -21438,      -21390,      -21343, 
        -21295,      -21248,      -21200,      -21153, 
        -21105,      -21057,      -21010,      -20962, 
        -20915,      -20867,      -20819,      -20772, 
        -20724,      -20676,      -20629,      -20581, 
        -20533,      -20485,      -20438,      -20390, 
        -20342,      -20294,      -20246,      -20199, 
        -20151,      -20103,      -20055,      -20007, 
        -19959,      -19912,      -19864,      -19816, 
        -19768,      -19720,      -19672,      -19624, 
        -19576,      -19528,      -19480,      -19432, 
        -19384,      -19336,      -19288,      -19240, 
        -19192,      -19144,      -19096,      -19048, 
        -19000,      -18951,      -18903,      -18855, 
        -18807,      -18759,      -18711,      -18663, 
        -18614,      -18566,      -18518,      -18470, 
        -18421,      -18373,      -18325,      -18277, 
        -18228,      -18180,      -18132,      -18084, 
        -18035,      -17987,      -17939,      -17890, 
        -17842,      -17793,      -17745,      -17697, 
        -17648,      -17600,      -17551,      -17503, 
        -17455,      -17406,      -17358,      -17309, 
        -17261,      -17212,      -17164,      -17115, 
        -17067,      -17018,      -16970,      -16921, 
        -16872,      -16824,      -16775,      -16727, 
        -16678,      -16629,      -16581,      -16532, 
        -16484,      -16435,      -16386,      -16338, 
        -16289,      -16240,      -16191,      -16143, 
        -16094,      -16045,      -15997,      -15948, 
        -15899,      -15850,      -15802,      -15753, 
        -15704,      -15655,      -15606,      -15557, 
        -15509,      -15460,      -15411,      -15362, 
        -15313,      -15264,      -15215,      -15167, 
        -15118,      -15069,      -15020,      -14971, 
        -14922,      -14873,      -14824,      -14775, 
        -14726,      -14677,      -14628,      -14579, 
        -14530,      -14481,      -14432,      -14383, 
        -14334,      -14285,      -14236,      -14187, 
        -14138,      -14089,      -14040,      -13990, 
        -13941,      -13892,      -13843,      -13794, 
        -13745,      -13696,      -13647,      -13597, 
        -13548,      -13499,      -13450,      -13401, 
        -13351,      -13302,      -13253,      -13204, 
        -13154,      -13105,      -13056,      -13007, 
        -12957,      -12908,      -12859,      -12810, 
        -12760,      -12711,      -12662,      -12612, 
        -12563,      -12514,      -12464,      -12415, 
        -12366,      -12316,      -12267,      -12217, 
        -12168,      -12119,      -12069,      -12020, 
        -11970,      -11921,      -11872,      -11822, 
        -11773,      -11723,      -11674,      -11624, 
        -11575,      -11525,      -11476,      -11426, 
        -11377,      -11327,      -11278,      -11228, 
        -11179,      -11129,      -11080,      -11030, 
        -10981,      -10931,      -10882,      -10832, 
        -10782,      -10733,      -10683,      -10634, 
        -10584,      -10534,      -10485,      -10435, 
        -10386,      -10336,      -10286,      -10237, 
        -10187,      -10137,      -10088,      -10038, 
        -9988,      -9939,      -9889,      -9839, 
        -9790,      -9740,      -9690,      -9640, 
        -9591,      -9541,      -9491,      -9442, 
        -9392,      -9342,      -9292,      -9243, 
        -9193,      -9143,      -9093,      -9043, 
        -8994,      -8944,      -8894,      -8844, 
        -8794,      -8745,      -8695,      -8645, 
        -8595,      -8545,      -8496,      -8446, 
        -8396,      -8346,      -8296,      -8246, 
        -8196,      -8147,      -8097,      -8047, 
        -7997,      -7947,      -7897,      -7847, 
        -7797,      -7747,      -7697,      -7648, 
        -7598,      -7548,      -7498,      -7448, 
        -7398,      -7348,      -7298,      -7248, 
        -7198,      -7148,      -7098,      -7048, 
        -6998,      -6948,      -6898,      -6848, 
        -6798,      -6748,      -6698,      -6648, 
        -6598,      -6548,      -6498,      -6448, 
        -6398,      -6348,      -6298,      -6248, 
        -6198,      -6148,      -6098,      -6048, 
        -5998,      -5948,      -5898,      -5848, 
        -5798,      -5747,      -5697,      -5647, 
        -5597,      -5547,      -5497,      -5447, 
        -5397,      -5347,      -5297,      -5247, 
        -5197,      -5146,      -5096,      -5046, 
        -4996,      -4946,      -4896,      -4846, 
        -4796,      -4745,      -4695,      -4645, 
        -4595,      -4545,      -4495,      -4445, 
        -4394,      -4344,      -4294,      -4244, 
        -4194,      -4144,      -4093,      -4043, 
        -3993,      -3943,      -3893,      -3843, 
        -3792,      -3742,      -3692,      -3642, 
        -3592,      -3541,      -3491,      -3441, 
        -3391,      -3341,      -3291,      -3240, 
        -3190,      -3140,      -3090,      -3039, 
        -2989,      -2939,      -2889,      -2839, 
        -2788,      -2738,      -2688,      -2638, 
        -2588,      -2537,      -2487,      -2437, 
        -2387,      -2336,      -2286,      -2236, 
        -2186,      -2135,      -2085,      -2035, 
        -1985,      -1934,      -1884,      -1834, 
        -1784,      -1733,      -1683,      -1633, 
        -1583,      -1532,      -1482,      -1432, 
        -1382,      -1331,      -1281,      -1231, 
        -1181,      -1130,      -1080,      -1030, 
        -980,      -929,      -879,      -829, 
        -779,      -728,      -678,      -628, 
        -578,      -527,      -477,      -427, 
        -376,      -326,      -276,      -226, 
        -175,      -125,      -75,      -25, 
        25,      75,      125,      175, 
        226,      276,      326,      376, 
        427,      477,      527,      578, 
        628,      678,      728,      779, 
        829,      879,      929,      980, 
        1030,      1080,      1130,      1181, 
        1231,      1281,      1331,      1382, 
        1432,      1482,      1532,      1583, 
        1633,      1683,      1733,      1784, 
        1834,      1884,      1934,      1985, 
        2035,      2085,      2135,      2186, 
        2236,      2286,      2336,      2387, 
        2437,      2487,      2537,      2587, 
        2638,      2688,      2738,      2788, 
        2839,      2889,      2939,      2989, 
        3039,      3090,      3140,      3190, 
        3240,      3291,      3341,      3391, 
        3441,      3491,      3542,      3592, 
        3642,      3692,      3742,      3792, 
        3843,      3893,      3943,      3993, 
        4043,      4093,      4144,      4194, 
        4244,      4294,      4344,      4394, 
        4445,      4495,      4545,      4595, 
        4645,      4695,      4745,      4796, 
        4846,      4896,      4946,      4996, 
        5046,      5096,      5146,      5197, 
        5247,      5297,      5347,      5397, 
        5447,      5497,      5547,      5597, 
        5647,      5697,      5747,      5798, 
        5848,      5898,      5948,      5998, 
        6048,      6098,      6148,      6198, 
        6248,      6298,      6348,      6398, 
        6448,      6498,      6548,      6598, 
        6648,      6698,      6748,      6798, 
        6848,      6898,      6948,      6998, 
        7048,      7098,      7148,      7198, 
        7248,      7298,      7348,      7398, 
        7448,      7498,      7548,      7598, 
        7648,      7697,      7747,      7797, 
        7847,      7897,      7947,      7997, 
        8047,      8097,      8147,      8196, 
        8246,      8296,      8346,      8396, 
        8446,      8496,      8545,      8595, 
        8645,      8695,      8745,      8794, 
        8844,      8894,      8944,      8994, 
        9043,      9093,      9143,      9193, 
        9243,      9292,      9342,      9392, 
        9442,      9491,      9541,      9591, 
        9640,      9690,      9740,      9790, 
        9839,      9889,      9939,      9988, 
        10038,      10088,      10137,      10187, 
        10237,      10286,      10336,      10386, 
        10435,      10485,      10534,      10584, 
        10634,      10683,      10733,      10782, 
        10832,      10882,      10931,      10981, 
        11030,      11080,      11129,      11179, 
        11228,      11278,      11327,      11377, 
        11426,      11476,      11525,      11575, 
        11624,      11674,      11723,      11773, 
        11822,      11872,      11921,      11970, 
        12020,      12069,      12119,      12168, 
        12218,      12267,      12316,      12366, 
        12415,      12464,      12514,      12563, 
        12612,      12662,      12711,      12760, 
        12810,      12859,      12908,      12957, 
        13007,      13056,      13105,      13154, 
        13204,      13253,      13302,      13351, 
        13401,      13450,      13499,      13548, 
        13597,      13647,      13696,      13745, 
        13794,      13843,      13892,      13941, 
        13990,      14040,      14089,      14138, 
        14187,      14236,      14285,      14334, 
        14383,      14432,      14481,      14530, 
        14579,      14628,      14677,      14726, 
        14775,      14824,      14873,      14922, 
        14971,      15020,      15069,      15118, 
        15167,      15215,      15264,      15313, 
        15362,      15411,      15460,      15509, 
        15557,      15606,      15655,      15704, 
        15753,      15802,      15850,      15899, 
        15948,      15997,      16045,      16094, 
        16143,      16191,      16240,      16289, 
        16338,      16386,      16435,      16484, 
        16532,      16581,      16629,      16678, 
        16727,      16775,      16824,      16872, 
        16921,      16970,      17018,      17067, 
        17115,      17164,      17212,      17261, 
        17309,      17358,      17406,      17455, 
        17503,      17551,      17600,      17648, 
        17697,      17745,      17793,      17842, 
        17890,      17939,      17987,      18035, 
        18084,      18132,      18180,      18228, 
        18277,      18325,      18373,      18421, 
        18470,      18518,      18566,      18614, 
        18663,      18711,      18759,      18807, 
        18855,      18903,      18951,      19000, 
        19048,      19096,      19144,      19192, 
        19240,      19288,      19336,      19384, 
        19432,      19480,      19528,      19576, 
        19624,      19672,      19720,      19768, 
        19816,      19864,      19912,      19959, 
        20007,      20055,      20103,      20151, 
        20199,      20246,      20294,      20342, 
        20390,      20438,      20485,      20533, 
        20581,      20629,      20676,      20724, 
        20772,      20819,      20867,      20915, 
        20962,      21010,      21057,      21105, 
        21153,      21200,      21248,      21295, 
        21343,      21390,      21438,      21485, 
        21533,      21580,      21628,      21675, 
        21723,      21770,      21817,      21865, 
        21912,      21960,      22007,      22054, 
        22102,      22149,      22196,      22243, 
        22291,      22338,      22385,      22432, 
        22480,      22527,      22574,      22621, 
        22668,      22716,      22763,      22810, 
        22857,      22904,      22951,      22998, 
        23045,      23092,      23139,      23186, 
        23233,      23280,      23327,      23374, 
        23421,      23468,      23515,      23562, 
        23609,      23656,      23703,      23750, 
        23796,      23843,      23890,      23937, 
        23984,      24030,      24077,      24124, 
        24171,      24217,      24264,      24311, 
        24357,      24404,      24451,      24497, 
        24544,      24591,      24637,      24684, 
        24730,      24777,      24823,      24870, 
        24916,      24963,      25009,      25056, 
        25102,      25149,      25195,      25241, 
        25288,      25334,      25381,      25427, 
        25473,      25520,      25566,      25612, 
        25658,      25705,      25751,      25797, 
        25843,      25889,      25936,      25982, 
        26028,      26074,      26120,      26166, 
        26212,      26258,      26304,      26350, 
        26396,      26442,      26488,      26534, 
        26580,      26626,      26672,      26718, 
        26764,      26810,      26856,      26902, 
        26947,      26993,      27039,      27085, 
        27131,      27176,      27222,      27268, 
        27313,      27359,      27405,      27450, 
        27496,      27542,      27587,      27633, 
        27678,      27724,      27770,      27815, 
        27861,      27906,      27952,      27997, 
        28042,      28088,      28133,      28179, 
        28224,      28269,      28315,      28360, 
        28405,      28451,      28496,      28541, 
        28586,      28632,      28677,      28722, 
        28767,      28812,      28858,      28903, 
        28948,      28993,      29038,      29083, 
        29128,      29173,      29218,      29263, 
        29308,      29353,      29398,      29443, 
        29488,      29533,      29577,      29622, 
        29667,      29712,      29757,      29801, 
        29846,      29891,      29936,      29980, 
        30025,      30070,      30114,      30159, 
        30204,      30248,      30293,      30337, 
        30382,      30427,      30471,      30516, 
        30560,      30604,      30649,      30693, 
        30738,      30782,      30826,      30871, 
        30915,      30959,      31004,      31048, 
        31092,      31136,      31181,      31225, 
        31269,      31313,      31357,      31402, 
        31446,      31490,      31534,      31578, 
        31622,      31666,      31710,      31754, 
        31798,      31842,      31886,      31930, 
        31974,      32017,      32061,      32105, 
        32149,      32193,      32236,      32280, 
        32324,      32368,      32411,      32455, 
        32499,      32542,      32586,      32630, 
        32673,      32717,      32760,      32804, 
        32847,      32891,      32934,      32978, 
        33021,      33065,      33108,      33151, 
        33195,      33238,      33281,      33325, 
        33368,      33411,      33454,      33498, 
        33541,      33584,      33627,      33670, 
        33713,      33756,      33799,      33843, 
        33886,      33929,      33972,      34015, 
        34057,      34100,      34143,      34186, 
        34229,      34272,      34315,      34358, 
        34400,      34443,      34486,      34529, 
        34571,      34614,      34657,      34699, 
        34742,      34785,      34827,      34870, 
        34912,      34955,      34997,      35040, 
        35082,      35125,      35167,      35210, 
        35252,      35294,      35337,      35379, 
        35421,      35464,      35506,      35548, 
        35590,      35633,      35675,      35717, 
        35759,      35801,      35843,      35885, 
        35927,      35969,      36011,      36053, 
        36095,      36137,      36179,      36221, 
        36263,      36305,      36347,      36388, 
        36430,      36472,      36514,      36556, 
        36597,      36639,      36681,      36722, 
        36764,      36805,      36847,      36889, 
        36930,      36972,      37013,      37055, 
        37096,      37137,      37179,      37220, 
        37262,      37303,      37344,      37386, 
        37427,      37468,      37509,      37551, 
        37592,      37633,      37674,      37715, 
        37756,      37797,      37838,      37879, 
        37920,      37961,      38002,      38043, 
        38084,      38125,      38166,      38207, 
        38248,      38288,      38329,      38370, 
        38411,      38451,      38492,      38533, 
        38573,      38614,      38655,      38695, 
        38736,      38776,      38817,      38857, 
        38898,      38938,      38979,      39019, 
        39059,      39100,      39140,      39180, 
        39221,      39261,      39301,      39341, 
        39382,      39422,      39462,      39502, 
        39542,      39582,      39622,      39662, 
        39702,      39742,      39782,      39822, 
        39862,      39902,      39942,      39982, 
        40021,      40061,      40101,      40141, 
        40180,      40220,      40260,      40299, 
        40339,      40379,      40418,      40458, 
        40497,      40537,      40576,      40616, 
        40655,      40695,      40734,      40773, 
        40813,      40852,      40891,      40931, 
        40970,      41009,      41048,      41087, 
        41127,      41166,      41205,      41244, 
        41283,      41322,      41361,      41400, 
        41439,      41478,      41517,      41556, 
        41595,      41633,      41672,      41711, 
        41750,      41788,      41827,      41866, 
        41904,      41943,      41982,      42020, 
        42059,      42097,      42136,      42174, 
        42213,      42251,      42290,      42328, 
        42366,      42405,      42443,      42481, 
        42520,      42558,      42596,      42634, 
        42672,      42711,      42749,      42787, 
        42825,      42863,      42901,      42939, 
        42977,      43015,      43053,      43091, 
        43128,      43166,      43204,      43242, 
        43280,      43317,      43355,      43393, 
        43430,      43468,      43506,      43543, 
        43581,      43618,      43656,      43693, 
        43731,      43768,      43806,      43843, 
        43880,      43918,      43955,      43992, 
        44029,      44067,      44104,      44141, 
        44178,      44215,      44252,      44289, 
        44326,      44363,      44400,      44437, 
        44474,      44511,      44548,      44585, 
        44622,      44659,      44695,      44732, 
        44769,      44806,      44842,      44879, 
        44915,      44952,      44989,      45025, 
        45062,      45098,      45135,      45171, 
        45207,      45244,      45280,      45316, 
        45353,      45389,      45425,      45462, 
        45498,      45534,      45570,      45606, 
        45642,      45678,      45714,      45750, 
        45786,      45822,      45858,      45894, 
        45930,      45966,      46002,      46037, 
        46073,      46109,      46145,      46180, 
        46216,      46252,      46287,      46323, 
        46358,      46394,      46429,      46465, 
        46500,      46536,      46571,      46606, 
        46642,      46677,      46712,      46747, 
        46783,      46818,      46853,      46888, 
        46923,      46958,      46993,      47028, 
        47063,      47098,      47133,      47168, 
        47203,      47238,      47273,      47308, 
        47342,      47377,      47412,      47446, 
        47481,      47516,      47550,      47585, 
        47619,      47654,      47688,      47723, 
        47757,      47792,      47826,      47861, 
        47895,      47929,      47963,      47998, 
        48032,      48066,      48100,      48134, 
        48168,      48202,      48237,      48271, 
        48305,      48338,      48372,      48406, 
        48440,      48474,      48508,      48542, 
        48575,      48609,      48643,      48676, 
        48710,      48744,      48777,      48811, 
        48844,      48878,      48911,      48945, 
        48978,      49012,      49045,      49078, 
        49112,      49145,      49178,      49211, 
        49244,      49278,      49311,      49344, 
        49377,      49410,      49443,      49476, 
        49509,      49542,      49575,      49608, 
        49640,      49673,      49706,      49739, 
        49771,      49804,      49837,      49869, 
        49902,      49935,      49967,      50000, 
        50032,      50064,      50097,      50129, 
        50162,      50194,      50226,      50259, 
        50291,      50323,      50355,      50387, 
        50420,      50452,      50484,      50516, 
        50548,      50580,      50612,      50644, 
        50675,      50707,      50739,      50771, 
        50803,      50834,      50866,      50898, 
        50929,      50961,      50993,      51024, 
        51056,      51087,      51119,      51150, 
        51182,      51213,      51244,      51276, 
        51307,      51338,      51369,      51401, 
        51432,      51463,      51494,      51525, 
        51556,      51587,      51618,      51649, 
        51680,      51711,      51742,      51773, 
        51803,      51834,      51865,      51896, 
        51926,      51957,      51988,      52018, 
        52049,      52079,      52110,      52140, 
        52171,      52201,      52231,      52262, 
        52292,      52322,      52353,      52383, 
        52413,      52443,      52473,      52503, 
        52534,      52564,      52594,      52624, 
        52653,      52683,      52713,      52743, 
        52773,      52803,      52832,      52862, 
        52892,      52922,      52951,      52981, 
        53010,      53040,      53069,      53099, 
        53128,      53158,      53187,      53216, 
        53246,      53275,      53304,      53334, 
        53363,      53392,      53421,      53450, 
        53479,      53508,      53537,      53566, 
        53595,      53624,      53653,      53682, 
        53711,      53739,      53768,      53797, 
        53826,      53854,      53883,      53912, 
        53940,      53969,      53997,      54026, 
        54054,      54082,      54111,      54139, 
        54167,      54196,      54224,      54252, 
        54280,      54309,      54337,      54365, 
        54393,      54421,      54449,      54477, 
        54505,      54533,      54560,      54588, 
        54616,      54644,      54672,      54699, 
        54727,      54755,      54782,      54810, 
        54837,      54865,      54892,      54920, 
        54947,      54974,      55002,      55029, 
        55056,      55084,      55111,      55138, 
        55165,      55192,      55219,      55246, 
        55274,      55300,      55327,      55354, 
        55381,      55408,      55435,      55462, 
        55489,      55515,      55542,      55569, 
        55595,      55622,      55648,      55675, 
        55701,      55728,      55754,      55781, 
        55807,      55833,      55860,      55886, 
        55912,      55938,      55965,      55991, 
        56017,      56043,      56069,      56095, 
        56121,      56147,      56173,      56199, 
        56225,      56250,      56276,      56302, 
        56328,      56353,      56379,      56404, 
        56430,      56456,      56481,      56507, 
        56532,      56557,      56583,      56608, 
        56633,      56659,      56684,      56709, 
        56734,      56760,      56785,      56810, 
        56835,      56860,      56885,      56910, 
        56935,      56959,      56984,      57009, 
        57034,      57059,      57083,      57108, 
        57133,      57157,      57182,      57206, 
        57231,      57255,      57280,      57304, 
        57329,      57353,      57377,      57402, 
        57426,      57450,      57474,      57498, 
        57522,      57546,      57570,      57594, 
        57618,      57642,      57666,      57690, 
        57714,      57738,      57762,      57785, 
        57809,      57833,      57856,      57880, 
        57903,      57927,      57950,      57974, 
        57997,      58021,      58044,      58067, 
        58091,      58114,      58137,      58160, 
        58183,      58207,      58230,      58253, 
        58276,      58299,      58322,      58345, 
        58367,      58390,      58413,      58436, 
        58459,      58481,      58504,      58527, 
        58549,      58572,      58594,      58617, 
        58639,      58662,      58684,      58706, 
        58729,      58751,      58773,      58795, 
        58818,      58840,      58862,      58884, 
        58906,      58928,      58950,      58972, 
        58994,      59016,      59038,      59059, 
        59081,      59103,      59125,      59146, 
        59168,      59190,      59211,      59233, 
        59254,      59276,      59297,      59318, 
        59340,      59361,      59382,      59404, 
        59425,      59446,      59467,      59488, 
        59509,      59530,      59551,      59572, 
        59593,      59614,      59635,      59656, 
        59677,      59697,      59718,      59739, 
        59759,      59780,      59801,      59821, 
        59842,      59862,      59883,      59903, 
        59923,      59944,      59964,      59984, 
        60004,      60025,      60045,      60065, 
        60085,      60105,      60125,      60145, 
        60165,      60185,      60205,      60225, 
        60244,      60264,      60284,      60304, 
        60323,      60343,      60363,      60382, 
        60402,      60421,      60441,      60460, 
        60479,      60499,      60518,      60537, 
        60556,      60576,      60595,      60614, 
        60633,      60652,      60671,      60690, 
        60709,      60728,      60747,      60766, 
        60785,      60803,      60822,      60841, 
        60859,      60878,      60897,      60915, 
        60934,      60952,      60971,      60989, 
        61007,      61026,      61044,      61062, 
        61081,      61099,      61117,      61135, 
        61153,      61171,      61189,      61207, 
        61225,      61243,      61261,      61279, 
        61297,      61314,      61332,      61350, 
        61367,      61385,      61403,      61420, 
        61438,      61455,      61473,      61490, 
        61507,      61525,      61542,      61559, 
        61577,      61594,      61611,      61628, 
        61645,      61662,      61679,      61696, 
        61713,      61730,      61747,      61764, 
        61780,      61797,      61814,      61831, 
        61847,      61864,      61880,      61897, 
        61913,      61930,      61946,      61963, 
        61979,      61995,      62012,      62028, 
        62044,      62060,      62076,      62092, 
        62108,      62125,      62141,      62156, 
        62172,      62188,      62204,      62220, 
        62236,      62251,      62267,      62283, 
        62298,      62314,      62329,      62345, 
        62360,      62376,      62391,      62407, 
        62422,      62437,      62453,      62468, 
        62483,      62498,      62513,      62528, 
        62543,      62558,      62573,      62588, 
        62603,      62618,      62633,      62648, 
        62662,      62677,      62692,      62706, 
        62721,      62735,      62750,      62764, 
        62779,      62793,      62808,      62822, 
        62836,      62850,      62865,      62879, 
        62893,      62907,      62921,      62935, 
        62949,      62963,      62977,      62991, 
        63005,      63019,      63032,      63046, 
        63060,      63074,      63087,      63101, 
        63114,      63128,      63141,      63155, 
        63168,      63182,      63195,      63208, 
        63221,      63235,      63248,      63261, 
        63274,      63287,      63300,      63313, 
        63326,      63339,      63352,      63365, 
        63378,      63390,      63403,      63416, 
        63429,      63441,      63454,      63466, 
        63479,      63491,      63504,      63516, 
        63528,      63541,      63553,      63565, 
        63578,      63590,      63602,      63614, 
        63626,      63638,      63650,      63662, 
        63674,      63686,      63698,      63709, 
        63721,      63733,      63745,      63756, 
        63768,      63779,      63791,      63803, 
        63814,      63825,      63837,      63848, 
        63859,      63871,      63882,      63893, 
        63904,      63915,      63927,      63938, 
        63949,      63960,      63971,      63981, 
        63992,      64003,      64014,      64025, 
        64035,      64046,      64057,      64067, 
        64078,      64088,      64099,      64109, 
        64120,      64130,      64140,      64151, 
        64161,      64171,      64181,      64192, 
        64202,      64212,      64222,      64232, 
        64242,      64252,      64261,      64271, 
        64281,      64291,      64301,      64310, 
        64320,      64330,      64339,      64349, 
        64358,      64368,      64377,      64387, 
        64396,      64405,      64414,      64424, 
        64433,      64442,      64451,      64460, 
        64469,      64478,      64487,      64496, 
        64505,      64514,      64523,      64532, 
        64540,      64549,      64558,      64566, 
        64575,      64584,      64592,      64600, 
        64609,      64617,      64626,      64634, 
        64642,      64651,      64659,      64667, 
        64675,      64683,      64691,      64699, 
        64707,      64715,      64723,      64731, 
        64739,      64747,      64754,      64762, 
        64770,      64777,      64785,      64793, 
        64800,      64808,      64815,      64822, 
        64830,      64837,      64844,      64852, 
        64859,      64866,      64873,      64880, 
        64887,      64895,      64902,      64908, 
        64915,      64922,      64929,      64936, 
        64943,      64949,      64956,      64963, 
        64969,      64976,      64982,      64989, 
        64995,      65002,      65008,      65015, 
        65021,      65027,      65033,      65040, 
        65046,      65052,      65058,      65064, 
        65070,      65076,      65082,      65088, 
        65094,      65099,      65105,      65111, 
        65117,      65122,      65128,      65133, 
        65139,      65144,      65150,      65155, 
        65161,      65166,      65171,      65177, 
        65182,      65187,      65192,      65197, 
        65202,      65207,      65212,      65217, 
        65222,      65227,      65232,      65237, 
        65242,      65246,      65251,      65256, 
        65260,      65265,      65270,      65274, 
        65279,      65283,      65287,      65292, 
        65296,      65300,      65305,      65309, 
        65313,      65317,      65321,      65325, 
        65329,      65333,      65337,      65341, 
        65345,      65349,      65352,      65356, 
        65360,      65363,      65367,      65371, 
        65374,      65378,      65381,      65385, 
        65388,      65391,      65395,      65398, 
        65401,      65404,      65408,      65411, 
        65414,      65417,      65420,      65423, 
        65426,      65429,      65431,      65434, 
        65437,      65440,      65442,      65445, 
        65448,      65450,      65453,      65455, 
        65458,      65460,      65463,      65465, 
        65467,      65470,      65472,      65474, 
        65476,      65478,      65480,      65482, 
        65484,      65486,      65488,      65490, 
        65492,      65494,      65496,      65497, 
        65499,      65501,      65502,      65504, 
        65505,      65507,      65508,      65510, 
        65511,      65513,      65514,      65515, 
        65516,      65518,      65519,      65520, 
        65521,      65522,      65523,      65524, 
        65525,      65526,      65527,      65527, 
        65528,      65529,      65530,      65530, 
        65531,      65531,      65532,      65532, 
        65533,      65533,      65534,      65534, 
        65534,      65535,      65535,      65535, 
        65535,      65535,      65535,      65535};
#line 1870 "tables.c"
angle_t tantoangle[2049]  = 
#line 1870
  {      (angle_t )0,      (angle_t )333772,      (angle_t )667544,      (angle_t )1001315, 
        (angle_t )1335086,      (angle_t )1668857,      (angle_t )2002626,      (angle_t )2336395, 
        (angle_t )2670163,      (angle_t )3003929,      (angle_t )3337694,      (angle_t )3671457, 
        (angle_t )4005219,      (angle_t )4338979,      (angle_t )4672736,      (angle_t )5006492, 
        (angle_t )5340245,      (angle_t )5673995,      (angle_t )6007743,      (angle_t )6341488, 
        (angle_t )6675230,      (angle_t )7008968,      (angle_t )7342704,      (angle_t )7676435, 
        (angle_t )8010164,      (angle_t )8343888,      (angle_t )8677609,      (angle_t )9011325, 
        (angle_t )9345037,      (angle_t )9678744,      (angle_t )10012447,      (angle_t )10346145, 
        (angle_t )10679838,      (angle_t )11013526,      (angle_t )11347209,      (angle_t )11680887, 
        (angle_t )12014558,      (angle_t )12348225,      (angle_t )12681885,      (angle_t )13015539, 
        (angle_t )13349187,      (angle_t )13682829,      (angle_t )14016464,      (angle_t )14350092, 
        (angle_t )14683714,      (angle_t )15017328,      (angle_t )15350936,      (angle_t )15684536, 
        (angle_t )16018129,      (angle_t )16351714,      (angle_t )16685291,      (angle_t )17018860, 
        (angle_t )17352422,      (angle_t )17685974,      (angle_t )18019518,      (angle_t )18353054, 
        (angle_t )18686582,      (angle_t )19020100,      (angle_t )19353610,      (angle_t )19687110, 
        (angle_t )20020600,      (angle_t )20354080,      (angle_t )20687552,      (angle_t )21021014, 
        (angle_t )21354466,      (angle_t )21687906,      (angle_t )22021338,      (angle_t )22354758, 
        (angle_t )22688168,      (angle_t )23021568,      (angle_t )23354956,      (angle_t )23688332, 
        (angle_t )24021698,      (angle_t )24355052,      (angle_t )24688396,      (angle_t )25021726, 
        (angle_t )25355046,      (angle_t )25688352,      (angle_t )26021648,      (angle_t )26354930, 
        (angle_t )26688200,      (angle_t )27021456,      (angle_t )27354702,      (angle_t )27687932, 
        (angle_t )28021150,      (angle_t )28354356,      (angle_t )28687548,      (angle_t )29020724, 
        (angle_t )29353888,      (angle_t )29687038,      (angle_t )30020174,      (angle_t )30353296, 
        (angle_t )30686404,      (angle_t )31019496,      (angle_t )31352574,      (angle_t )31685636, 
        (angle_t )32018684,      (angle_t )32351718,      (angle_t )32684734,      (angle_t )33017736, 
        (angle_t )33350722,      (angle_t )33683692,      (angle_t )34016648,      (angle_t )34349584, 
        (angle_t )34682508,      (angle_t )35015412,      (angle_t )35348300,      (angle_t )35681172, 
        (angle_t )36014028,      (angle_t )36346868,      (angle_t )36679688,      (angle_t )37012492, 
        (angle_t )37345276,      (angle_t )37678044,      (angle_t )38010792,      (angle_t )38343524, 
        (angle_t )38676240,      (angle_t )39008936,      (angle_t )39341612,      (angle_t )39674272, 
        (angle_t )40006912,      (angle_t )40339532,      (angle_t )40672132,      (angle_t )41004716, 
        (angle_t )41337276,      (angle_t )41669820,      (angle_t )42002344,      (angle_t )42334848, 
        (angle_t )42667332,      (angle_t )42999796,      (angle_t )43332236,      (angle_t )43664660, 
        (angle_t )43997060,      (angle_t )44329444,      (angle_t )44661800,      (angle_t )44994140, 
        (angle_t )45326456,      (angle_t )45658752,      (angle_t )45991028,      (angle_t )46323280, 
        (angle_t )46655512,      (angle_t )46987720,      (angle_t )47319908,      (angle_t )47652072, 
        (angle_t )47984212,      (angle_t )48316332,      (angle_t )48648428,      (angle_t )48980500, 
        (angle_t )49312548,      (angle_t )49644576,      (angle_t )49976580,      (angle_t )50308556, 
        (angle_t )50640512,      (angle_t )50972444,      (angle_t )51304352,      (angle_t )51636236, 
        (angle_t )51968096,      (angle_t )52299928,      (angle_t )52631740,      (angle_t )52963524, 
        (angle_t )53295284,      (angle_t )53627020,      (angle_t )53958728,      (angle_t )54290412, 
        (angle_t )54622068,      (angle_t )54953704,      (angle_t )55285308,      (angle_t )55616888, 
        (angle_t )55948444,      (angle_t )56279972,      (angle_t )56611472,      (angle_t )56942948, 
        (angle_t )57274396,      (angle_t )57605816,      (angle_t )57937212,      (angle_t )58268576, 
        (angle_t )58599916,      (angle_t )58931228,      (angle_t )59262512,      (angle_t )59593768, 
        (angle_t )59924992,      (angle_t )60256192,      (angle_t )60587364,      (angle_t )60918508, 
        (angle_t )61249620,      (angle_t )61580704,      (angle_t )61911760,      (angle_t )62242788, 
        (angle_t )62573788,      (angle_t )62904756,      (angle_t )63235692,      (angle_t )63566604, 
        (angle_t )63897480,      (angle_t )64228332,      (angle_t )64559148,      (angle_t )64889940, 
        (angle_t )65220696,      (angle_t )65551424,      (angle_t )65882120,      (angle_t )66212788, 
        (angle_t )66543420,      (angle_t )66874024,      (angle_t )67204600,      (angle_t )67535136, 
        (angle_t )67865648,      (angle_t )68196120,      (angle_t )68526568,      (angle_t )68856984, 
        (angle_t )69187360,      (angle_t )69517712,      (angle_t )69848024,      (angle_t )70178304, 
        (angle_t )70508560,      (angle_t )70838776,      (angle_t )71168960,      (angle_t )71499112, 
        (angle_t )71829224,      (angle_t )72159312,      (angle_t )72489360,      (angle_t )72819376, 
        (angle_t )73149360,      (angle_t )73479304,      (angle_t )73809216,      (angle_t )74139096, 
        (angle_t )74468936,      (angle_t )74798744,      (angle_t )75128520,      (angle_t )75458264, 
        (angle_t )75787968,      (angle_t )76117632,      (angle_t )76447264,      (angle_t )76776864, 
        (angle_t )77106424,      (angle_t )77435952,      (angle_t )77765440,      (angle_t )78094888, 
        (angle_t )78424304,      (angle_t )78753688,      (angle_t )79083032,      (angle_t )79412336, 
        (angle_t )79741608,      (angle_t )80070840,      (angle_t )80400032,      (angle_t )80729192, 
        (angle_t )81058312,      (angle_t )81387392,      (angle_t )81716432,      (angle_t )82045440, 
        (angle_t )82374408,      (angle_t )82703336,      (angle_t )83032224,      (angle_t )83361080, 
        (angle_t )83689896,      (angle_t )84018664,      (angle_t )84347400,      (angle_t )84676096, 
        (angle_t )85004760,      (angle_t )85333376,      (angle_t )85661952,      (angle_t )85990488, 
        (angle_t )86318984,      (angle_t )86647448,      (angle_t )86975864,      (angle_t )87304240, 
        (angle_t )87632576,      (angle_t )87960872,      (angle_t )88289128,      (angle_t )88617344, 
        (angle_t )88945520,      (angle_t )89273648,      (angle_t )89601736,      (angle_t )89929792, 
        (angle_t )90257792,      (angle_t )90585760,      (angle_t )90913688,      (angle_t )91241568, 
        (angle_t )91569408,      (angle_t )91897200,      (angle_t )92224960,      (angle_t )92552672, 
        (angle_t )92880336,      (angle_t )93207968,      (angle_t )93535552,      (angle_t )93863088, 
        (angle_t )94190584,      (angle_t )94518040,      (angle_t )94845448,      (angle_t )95172816, 
        (angle_t )95500136,      (angle_t )95827416,      (angle_t )96154648,      (angle_t )96481832, 
        (angle_t )96808976,      (angle_t )97136080,      (angle_t )97463136,      (angle_t )97790144, 
        (angle_t )98117112,      (angle_t )98444032,      (angle_t )98770904,      (angle_t )99097736, 
        (angle_t )99424520,      (angle_t )99751256,      (angle_t )100077944,      (angle_t )100404592, 
        (angle_t )100731192,      (angle_t )101057744,      (angle_t )101384248,      (angle_t )101710712, 
        (angle_t )102037128,      (angle_t )102363488,      (angle_t )102689808,      (angle_t )103016080, 
        (angle_t )103342312,      (angle_t )103668488,      (angle_t )103994616,      (angle_t )104320696, 
        (angle_t )104646736,      (angle_t )104972720,      (angle_t )105298656,      (angle_t )105624552, 
        (angle_t )105950392,      (angle_t )106276184,      (angle_t )106601928,      (angle_t )106927624, 
        (angle_t )107253272,      (angle_t )107578872,      (angle_t )107904416,      (angle_t )108229920, 
        (angle_t )108555368,      (angle_t )108880768,      (angle_t )109206120,      (angle_t )109531416, 
        (angle_t )109856664,      (angle_t )110181872,      (angle_t )110507016,      (angle_t )110832120, 
        (angle_t )111157168,      (angle_t )111482168,      (angle_t )111807112,      (angle_t )112132008, 
        (angle_t )112456856,      (angle_t )112781648,      (angle_t )113106392,      (angle_t )113431080, 
        (angle_t )113755720,      (angle_t )114080312,      (angle_t )114404848,      (angle_t )114729328, 
        (angle_t )115053760,      (angle_t )115378136,      (angle_t )115702464,      (angle_t )116026744, 
        (angle_t )116350960,      (angle_t )116675128,      (angle_t )116999248,      (angle_t )117323312, 
        (angle_t )117647320,      (angle_t )117971272,      (angle_t )118295176,      (angle_t )118619024, 
        (angle_t )118942816,      (angle_t )119266560,      (angle_t )119590248,      (angle_t )119913880, 
        (angle_t )120237456,      (angle_t )120560984,      (angle_t )120884456,      (angle_t )121207864, 
        (angle_t )121531224,      (angle_t )121854528,      (angle_t )122177784,      (angle_t )122500976, 
        (angle_t )122824112,      (angle_t )123147200,      (angle_t )123470224,      (angle_t )123793200, 
        (angle_t )124116120,      (angle_t )124438976,      (angle_t )124761784,      (angle_t )125084528, 
        (angle_t )125407224,      (angle_t )125729856,      (angle_t )126052432,      (angle_t )126374960, 
        (angle_t )126697424,      (angle_t )127019832,      (angle_t )127342184,      (angle_t )127664472, 
        (angle_t )127986712,      (angle_t )128308888,      (angle_t )128631008,      (angle_t )128953072, 
        (angle_t )129275080,      (angle_t )129597024,      (angle_t )129918912,      (angle_t )130240744, 
        (angle_t )130562520,      (angle_t )130884232,      (angle_t )131205888,      (angle_t )131527480, 
        (angle_t )131849016,      (angle_t )132170496,      (angle_t )132491912,      (angle_t )132813272, 
        (angle_t )133134576,      (angle_t )133455816,      (angle_t )133776992,      (angle_t )134098120, 
        (angle_t )134419184,      (angle_t )134740176,      (angle_t )135061120,      (angle_t )135382000, 
        (angle_t )135702816,      (angle_t )136023584,      (angle_t )136344272,      (angle_t )136664912, 
        (angle_t )136985488,      (angle_t )137306016,      (angle_t )137626464,      (angle_t )137946864, 
        (angle_t )138267184,      (angle_t )138587456,      (angle_t )138907664,      (angle_t )139227808, 
        (angle_t )139547904,      (angle_t )139867920,      (angle_t )140187888,      (angle_t )140507776, 
        (angle_t )140827616,      (angle_t )141147392,      (angle_t )141467104,      (angle_t )141786752, 
        (angle_t )142106336,      (angle_t )142425856,      (angle_t )142745312,      (angle_t )143064720, 
        (angle_t )143384048,      (angle_t )143703312,      (angle_t )144022512,      (angle_t )144341664, 
        (angle_t )144660736,      (angle_t )144979744,      (angle_t )145298704,      (angle_t )145617584, 
        (angle_t )145936400,      (angle_t )146255168,      (angle_t )146573856,      (angle_t )146892480, 
        (angle_t )147211040,      (angle_t )147529536,      (angle_t )147847968,      (angle_t )148166336, 
        (angle_t )148484640,      (angle_t )148802880,      (angle_t )149121056,      (angle_t )149439152, 
        (angle_t )149757200,      (angle_t )150075168,      (angle_t )150393072,      (angle_t )150710912, 
        (angle_t )151028688,      (angle_t )151346400,      (angle_t )151664048,      (angle_t )151981616, 
        (angle_t )152299136,      (angle_t )152616576,      (angle_t )152933952,      (angle_t )153251264, 
        (angle_t )153568496,      (angle_t )153885680,      (angle_t )154202784,      (angle_t )154519824, 
        (angle_t )154836784,      (angle_t )155153696,      (angle_t )155470528,      (angle_t )155787296, 
        (angle_t )156104000,      (angle_t )156420624,      (angle_t )156737200,      (angle_t )157053696, 
        (angle_t )157370112,      (angle_t )157686480,      (angle_t )158002768,      (angle_t )158318976, 
        (angle_t )158635136,      (angle_t )158951216,      (angle_t )159267232,      (angle_t )159583168, 
        (angle_t )159899040,      (angle_t )160214848,      (angle_t )160530592,      (angle_t )160846256, 
        (angle_t )161161840,      (angle_t )161477376,      (angle_t )161792832,      (angle_t )162108208, 
        (angle_t )162423520,      (angle_t )162738768,      (angle_t )163053952,      (angle_t )163369040, 
        (angle_t )163684080,      (angle_t )163999040,      (angle_t )164313936,      (angle_t )164628752, 
        (angle_t )164943504,      (angle_t )165258176,      (angle_t )165572784,      (angle_t )165887312, 
        (angle_t )166201776,      (angle_t )166516160,      (angle_t )166830480,      (angle_t )167144736, 
        (angle_t )167458912,      (angle_t )167773008,      (angle_t )168087040,      (angle_t )168400992, 
        (angle_t )168714880,      (angle_t )169028688,      (angle_t )169342432,      (angle_t )169656096, 
        (angle_t )169969696,      (angle_t )170283216,      (angle_t )170596672,      (angle_t )170910032, 
        (angle_t )171223344,      (angle_t )171536576,      (angle_t )171849728,      (angle_t )172162800, 
        (angle_t )172475808,      (angle_t )172788736,      (angle_t )173101600,      (angle_t )173414384, 
        (angle_t )173727104,      (angle_t )174039728,      (angle_t )174352288,      (angle_t )174664784, 
        (angle_t )174977200,      (angle_t )175289536,      (angle_t )175601792,      (angle_t )175913984, 
        (angle_t )176226096,      (angle_t )176538144,      (angle_t )176850096,      (angle_t )177161984, 
        (angle_t )177473792,      (angle_t )177785536,      (angle_t )178097200,      (angle_t )178408784, 
        (angle_t )178720288,      (angle_t )179031728,      (angle_t )179343088,      (angle_t )179654368, 
        (angle_t )179965568,      (angle_t )180276704,      (angle_t )180587744,      (angle_t )180898720, 
        (angle_t )181209616,      (angle_t )181520448,      (angle_t )181831184,      (angle_t )182141856, 
        (angle_t )182452448,      (angle_t )182762960,      (angle_t )183073408,      (angle_t )183383760, 
        (angle_t )183694048,      (angle_t )184004240,      (angle_t )184314368,      (angle_t )184624416, 
        (angle_t )184934400,      (angle_t )185244288,      (angle_t )185554096,      (angle_t )185863840, 
        (angle_t )186173504,      (angle_t )186483072,      (angle_t )186792576,      (angle_t )187102000, 
        (angle_t )187411344,      (angle_t )187720608,      (angle_t )188029808,      (angle_t )188338912, 
        (angle_t )188647936,      (angle_t )188956896,      (angle_t )189265760,      (angle_t )189574560, 
        (angle_t )189883264,      (angle_t )190191904,      (angle_t )190500448,      (angle_t )190808928, 
        (angle_t )191117312,      (angle_t )191425632,      (angle_t )191733872,      (angle_t )192042016, 
        (angle_t )192350096,      (angle_t )192658096,      (angle_t )192966000,      (angle_t )193273840, 
        (angle_t )193581584,      (angle_t )193889264,      (angle_t )194196848,      (angle_t )194504352, 
        (angle_t )194811792,      (angle_t )195119136,      (angle_t )195426400,      (angle_t )195733584, 
        (angle_t )196040688,      (angle_t )196347712,      (angle_t )196654656,      (angle_t )196961520, 
        (angle_t )197268304,      (angle_t )197574992,      (angle_t )197881616,      (angle_t )198188144, 
        (angle_t )198494592,      (angle_t )198800960,      (angle_t )199107248,      (angle_t )199413456, 
        (angle_t )199719584,      (angle_t )200025616,      (angle_t )200331584,      (angle_t )200637456, 
        (angle_t )200943248,      (angle_t )201248960,      (angle_t )201554576,      (angle_t )201860128, 
        (angle_t )202165584,      (angle_t )202470960,      (angle_t )202776256,      (angle_t )203081456, 
        (angle_t )203386592,      (angle_t )203691632,      (angle_t )203996592,      (angle_t )204301472, 
        (angle_t )204606256,      (angle_t )204910976,      (angle_t )205215600,      (angle_t )205520144, 
        (angle_t )205824592,      (angle_t )206128960,      (angle_t )206433248,      (angle_t )206737456, 
        (angle_t )207041584,      (angle_t )207345616,      (angle_t )207649568,      (angle_t )207953424, 
        (angle_t )208257216,      (angle_t )208560912,      (angle_t )208864512,      (angle_t )209168048, 
        (angle_t )209471488,      (angle_t )209774832,      (angle_t )210078112,      (angle_t )210381296, 
        (angle_t )210684384,      (angle_t )210987408,      (angle_t )211290336,      (angle_t )211593184, 
        (angle_t )211895936,      (angle_t )212198608,      (angle_t )212501184,      (angle_t )212803680, 
        (angle_t )213106096,      (angle_t )213408432,      (angle_t )213710672,      (angle_t )214012816, 
        (angle_t )214314880,      (angle_t )214616864,      (angle_t )214918768,      (angle_t )215220576, 
        (angle_t )215522288,      (angle_t )215823920,      (angle_t )216125472,      (angle_t )216426928, 
        (angle_t )216728304,      (angle_t )217029584,      (angle_t )217330784,      (angle_t )217631904, 
        (angle_t )217932928,      (angle_t )218233856,      (angle_t )218534704,      (angle_t )218835472, 
        (angle_t )219136144,      (angle_t )219436720,      (angle_t )219737216,      (angle_t )220037632, 
        (angle_t )220337952,      (angle_t )220638192,      (angle_t )220938336,      (angle_t )221238384, 
        (angle_t )221538352,      (angle_t )221838240,      (angle_t )222138032,      (angle_t )222437728, 
        (angle_t )222737344,      (angle_t )223036880,      (angle_t )223336304,      (angle_t )223635664, 
        (angle_t )223934912,      (angle_t )224234096,      (angle_t )224533168,      (angle_t )224832160, 
        (angle_t )225131072,      (angle_t )225429872,      (angle_t )225728608,      (angle_t )226027232, 
        (angle_t )226325776,      (angle_t )226624240,      (angle_t )226922608,      (angle_t )227220880, 
        (angle_t )227519056,      (angle_t )227817152,      (angle_t )228115168,      (angle_t )228413088, 
        (angle_t )228710912,      (angle_t )229008640,      (angle_t )229306288,      (angle_t )229603840, 
        (angle_t )229901312,      (angle_t )230198688,      (angle_t )230495968,      (angle_t )230793152, 
        (angle_t )231090256,      (angle_t )231387280,      (angle_t )231684192,      (angle_t )231981024, 
        (angle_t )232277760,      (angle_t )232574416,      (angle_t )232870960,      (angle_t )233167440, 
        (angle_t )233463808,      (angle_t )233760096,      (angle_t )234056288,      (angle_t )234352384, 
        (angle_t )234648384,      (angle_t )234944304,      (angle_t )235240128,      (angle_t )235535872, 
        (angle_t )235831504,      (angle_t )236127056,      (angle_t )236422512,      (angle_t )236717888, 
        (angle_t )237013152,      (angle_t )237308336,      (angle_t )237603424,      (angle_t )237898416, 
        (angle_t )238193328,      (angle_t )238488144,      (angle_t )238782864,      (angle_t )239077488, 
        (angle_t )239372016,      (angle_t )239666464,      (angle_t )239960816,      (angle_t )240255072, 
        (angle_t )240549232,      (angle_t )240843312,      (angle_t )241137280,      (angle_t )241431168, 
        (angle_t )241724960,      (angle_t )242018656,      (angle_t )242312256,      (angle_t )242605776, 
        (angle_t )242899200,      (angle_t )243192512,      (angle_t )243485744,      (angle_t )243778896, 
        (angle_t )244071936,      (angle_t )244364880,      (angle_t )244657744,      (angle_t )244950496, 
        (angle_t )245243168,      (angle_t )245535744,      (angle_t )245828224,      (angle_t )246120608, 
        (angle_t )246412912,      (angle_t )246705104,      (angle_t )246997216,      (angle_t )247289216, 
        (angle_t )247581136,      (angle_t )247872960,      (angle_t )248164688,      (angle_t )248456320, 
        (angle_t )248747856,      (angle_t )249039296,      (angle_t )249330640,      (angle_t )249621904, 
        (angle_t )249913056,      (angle_t )250204128,      (angle_t )250495088,      (angle_t )250785968, 
        (angle_t )251076736,      (angle_t )251367424,      (angle_t )251658016,      (angle_t )251948512, 
        (angle_t )252238912,      (angle_t )252529200,      (angle_t )252819408,      (angle_t )253109520, 
        (angle_t )253399536,      (angle_t )253689456,      (angle_t )253979280,      (angle_t )254269008, 
        (angle_t )254558640,      (angle_t )254848176,      (angle_t )255137632,      (angle_t )255426976, 
        (angle_t )255716224,      (angle_t )256005376,      (angle_t )256294432,      (angle_t )256583392, 
        (angle_t )256872256,      (angle_t )257161024,      (angle_t )257449696,      (angle_t )257738272, 
        (angle_t )258026752,      (angle_t )258315136,      (angle_t )258603424,      (angle_t )258891600, 
        (angle_t )259179696,      (angle_t )259467696,      (angle_t )259755600,      (angle_t )260043392, 
        (angle_t )260331104,      (angle_t )260618704,      (angle_t )260906224,      (angle_t )261193632, 
        (angle_t )261480960,      (angle_t )261768176,      (angle_t )262055296,      (angle_t )262342320, 
        (angle_t )262629248,      (angle_t )262916080,      (angle_t )263202816,      (angle_t )263489456, 
        (angle_t )263776000,      (angle_t )264062432,      (angle_t )264348784,      (angle_t )264635024, 
        (angle_t )264921168,      (angle_t )265207216,      (angle_t )265493168,      (angle_t )265779024, 
        (angle_t )266064784,      (angle_t )266350448,      (angle_t )266636000,      (angle_t )266921472, 
        (angle_t )267206832,      (angle_t )267492096,      (angle_t )267777264,      (angle_t )268062336, 
        (angle_t )268347312,      (angle_t )268632192,      (angle_t )268916960,      (angle_t )269201632, 
        (angle_t )269486208,      (angle_t )269770688,      (angle_t )270055072,      (angle_t )270339360, 
        (angle_t )270623552,      (angle_t )270907616,      (angle_t )271191616,      (angle_t )271475488, 
        (angle_t )271759296,      (angle_t )272042976,      (angle_t )272326560,      (angle_t )272610048, 
        (angle_t )272893440,      (angle_t )273176736,      (angle_t )273459936,      (angle_t )273743040, 
        (angle_t )274026048,      (angle_t )274308928,      (angle_t )274591744,      (angle_t )274874432, 
        (angle_t )275157024,      (angle_t )275439520,      (angle_t )275721920,      (angle_t )276004224, 
        (angle_t )276286432,      (angle_t )276568512,      (angle_t )276850528,      (angle_t )277132416, 
        (angle_t )277414240,      (angle_t )277695936,      (angle_t )277977536,      (angle_t )278259040, 
        (angle_t )278540448,      (angle_t )278821728,      (angle_t )279102944,      (angle_t )279384032, 
        (angle_t )279665056,      (angle_t )279945952,      (angle_t )280226752,      (angle_t )280507456, 
        (angle_t )280788064,      (angle_t )281068544,      (angle_t )281348960,      (angle_t )281629248, 
        (angle_t )281909472,      (angle_t )282189568,      (angle_t )282469568,      (angle_t )282749440, 
        (angle_t )283029248,      (angle_t )283308960,      (angle_t )283588544,      (angle_t )283868032, 
        (angle_t )284147424,      (angle_t )284426720,      (angle_t )284705920,      (angle_t )284985024, 
        (angle_t )285264000,      (angle_t )285542912,      (angle_t )285821696,      (angle_t )286100384, 
        (angle_t )286378976,      (angle_t )286657440,      (angle_t )286935840,      (angle_t )287214112, 
        (angle_t )287492320,      (angle_t )287770400,      (angle_t )288048384,      (angle_t )288326240, 
        (angle_t )288604032,      (angle_t )288881696,      (angle_t )289159264,      (angle_t )289436768, 
        (angle_t )289714112,      (angle_t )289991392,      (angle_t )290268576,      (angle_t )290545632, 
        (angle_t )290822592,      (angle_t )291099456,      (angle_t )291376224,      (angle_t )291652896, 
        (angle_t )291929440,      (angle_t )292205888,      (angle_t )292482272,      (angle_t )292758528, 
        (angle_t )293034656,      (angle_t )293310720,      (angle_t )293586656,      (angle_t )293862496, 
        (angle_t )294138240,      (angle_t )294413888,      (angle_t )294689440,      (angle_t )294964864, 
        (angle_t )295240192,      (angle_t )295515424,      (angle_t )295790560,      (angle_t )296065600, 
        (angle_t )296340512,      (angle_t )296615360,      (angle_t )296890080,      (angle_t )297164704, 
        (angle_t )297439200,      (angle_t )297713632,      (angle_t )297987936,      (angle_t )298262144, 
        (angle_t )298536256,      (angle_t )298810240,      (angle_t )299084160,      (angle_t )299357952, 
        (angle_t )299631648,      (angle_t )299905248,      (angle_t )300178720,      (angle_t )300452128, 
        (angle_t )300725408,      (angle_t )300998592,      (angle_t )301271680,      (angle_t )301544640, 
        (angle_t )301817536,      (angle_t )302090304,      (angle_t )302362976,      (angle_t )302635520, 
        (angle_t )302908000,      (angle_t )303180352,      (angle_t )303452608,      (angle_t )303724768, 
        (angle_t )303996800,      (angle_t )304268768,      (angle_t )304540608,      (angle_t )304812320, 
        (angle_t )305083968,      (angle_t )305355520,      (angle_t )305626944,      (angle_t )305898272, 
        (angle_t )306169472,      (angle_t )306440608,      (angle_t )306711616,      (angle_t )306982528, 
        (angle_t )307253344,      (angle_t )307524064,      (angle_t )307794656,      (angle_t )308065152, 
        (angle_t )308335552,      (angle_t )308605856,      (angle_t )308876032,      (angle_t )309146112, 
        (angle_t )309416096,      (angle_t )309685984,      (angle_t )309955744,      (angle_t )310225408, 
        (angle_t )310494976,      (angle_t )310764448,      (angle_t )311033824,      (angle_t )311303072, 
        (angle_t )311572224,      (angle_t )311841280,      (angle_t )312110208,      (angle_t )312379040, 
        (angle_t )312647776,      (angle_t )312916416,      (angle_t )313184960,      (angle_t )313453376, 
        (angle_t )313721696,      (angle_t )313989920,      (angle_t )314258016,      (angle_t )314526016, 
        (angle_t )314793920,      (angle_t )315061728,      (angle_t )315329408,      (angle_t )315597024, 
        (angle_t )315864512,      (angle_t )316131872,      (angle_t )316399168,      (angle_t )316666336, 
        (angle_t )316933408,      (angle_t )317200384,      (angle_t )317467232,      (angle_t )317733984, 
        (angle_t )318000640,      (angle_t )318267200,      (angle_t )318533632,      (angle_t )318799968, 
        (angle_t )319066208,      (angle_t )319332352,      (angle_t )319598368,      (angle_t )319864288, 
        (angle_t )320130112,      (angle_t )320395808,      (angle_t )320661408,      (angle_t )320926912, 
        (angle_t )321192320,      (angle_t )321457632,      (angle_t )321722816,      (angle_t )321987904, 
        (angle_t )322252864,      (angle_t )322517760,      (angle_t )322782528,      (angle_t )323047200, 
        (angle_t )323311744,      (angle_t )323576192,      (angle_t )323840544,      (angle_t )324104800, 
        (angle_t )324368928,      (angle_t )324632992,      (angle_t )324896928,      (angle_t )325160736, 
        (angle_t )325424448,      (angle_t )325688096,      (angle_t )325951584,      (angle_t )326215008, 
        (angle_t )326478304,      (angle_t )326741504,      (angle_t )327004608,      (angle_t )327267584, 
        (angle_t )327530464,      (angle_t )327793248,      (angle_t )328055904,      (angle_t )328318496, 
        (angle_t )328580960,      (angle_t )328843296,      (angle_t )329105568,      (angle_t )329367712, 
        (angle_t )329629760,      (angle_t )329891680,      (angle_t )330153536,      (angle_t )330415264, 
        (angle_t )330676864,      (angle_t )330938400,      (angle_t )331199808,      (angle_t )331461120, 
        (angle_t )331722304,      (angle_t )331983392,      (angle_t )332244384,      (angle_t )332505280, 
        (angle_t )332766048,      (angle_t )333026752,      (angle_t )333287296,      (angle_t )333547776, 
        (angle_t )333808128,      (angle_t )334068384,      (angle_t )334328544,      (angle_t )334588576, 
        (angle_t )334848512,      (angle_t )335108352,      (angle_t )335368064,      (angle_t )335627712, 
        (angle_t )335887200,      (angle_t )336146624,      (angle_t )336405920,      (angle_t )336665120, 
        (angle_t )336924224,      (angle_t )337183200,      (angle_t )337442112,      (angle_t )337700864, 
        (angle_t )337959552,      (angle_t )338218112,      (angle_t )338476576,      (angle_t )338734944, 
        (angle_t )338993184,      (angle_t )339251328,      (angle_t )339509376,      (angle_t )339767296, 
        (angle_t )340025120,      (angle_t )340282848,      (angle_t )340540480,      (angle_t )340797984, 
        (angle_t )341055392,      (angle_t )341312704,      (angle_t )341569888,      (angle_t )341826976, 
        (angle_t )342083968,      (angle_t )342340832,      (angle_t )342597600,      (angle_t )342854272, 
        (angle_t )343110848,      (angle_t )343367296,      (angle_t )343623648,      (angle_t )343879904, 
        (angle_t )344136032,      (angle_t )344392064,      (angle_t )344648000,      (angle_t )344903808, 
        (angle_t )345159520,      (angle_t )345415136,      (angle_t )345670656,      (angle_t )345926048, 
        (angle_t )346181344,      (angle_t )346436512,      (angle_t )346691616,      (angle_t )346946592, 
        (angle_t )347201440,      (angle_t )347456224,      (angle_t )347710880,      (angle_t )347965440, 
        (angle_t )348219872,      (angle_t )348474208,      (angle_t )348728448,      (angle_t )348982592, 
        (angle_t )349236608,      (angle_t )349490528,      (angle_t )349744320,      (angle_t )349998048, 
        (angle_t )350251648,      (angle_t )350505152,      (angle_t )350758528,      (angle_t )351011808, 
        (angle_t )351264992,      (angle_t )351518048,      (angle_t )351771040,      (angle_t )352023872, 
        (angle_t )352276640,      (angle_t )352529280,      (angle_t )352781824,      (angle_t )353034272, 
        (angle_t )353286592,      (angle_t )353538816,      (angle_t )353790944,      (angle_t )354042944, 
        (angle_t )354294880,      (angle_t )354546656,      (angle_t )354798368,      (angle_t )355049952, 
        (angle_t )355301440,      (angle_t )355552800,      (angle_t )355804096,      (angle_t )356055264, 
        (angle_t )356306304,      (angle_t )356557280,      (angle_t )356808128,      (angle_t )357058848, 
        (angle_t )357309504,      (angle_t )357560032,      (angle_t )357810464,      (angle_t )358060768, 
        (angle_t )358311008,      (angle_t )358561088,      (angle_t )358811104,      (angle_t )359060992, 
        (angle_t )359310784,      (angle_t )359560480,      (angle_t )359810048,      (angle_t )360059520, 
        (angle_t )360308896,      (angle_t )360558144,      (angle_t )360807296,      (angle_t )361056352, 
        (angle_t )361305312,      (angle_t )361554144,      (angle_t )361802880,      (angle_t )362051488, 
        (angle_t )362300032,      (angle_t )362548448,      (angle_t )362796736,      (angle_t )363044960, 
        (angle_t )363293056,      (angle_t )363541024,      (angle_t )363788928,      (angle_t )364036704, 
        (angle_t )364284384,      (angle_t )364531936,      (angle_t )364779392,      (angle_t )365026752, 
        (angle_t )365274016,      (angle_t )365521152,      (angle_t )365768192,      (angle_t )366015136, 
        (angle_t )366261952,      (angle_t )366508672,      (angle_t )366755296,      (angle_t )367001792, 
        (angle_t )367248192,      (angle_t )367494496,      (angle_t )367740704,      (angle_t )367986784, 
        (angle_t )368232768,      (angle_t )368478656,      (angle_t )368724416,      (angle_t )368970080, 
        (angle_t )369215648,      (angle_t )369461088,      (angle_t )369706432,      (angle_t )369951680, 
        (angle_t )370196800,      (angle_t )370441824,      (angle_t )370686752,      (angle_t )370931584, 
        (angle_t )371176288,      (angle_t )371420896,      (angle_t )371665408,      (angle_t )371909792, 
        (angle_t )372154080,      (angle_t )372398272,      (angle_t )372642336,      (angle_t )372886304, 
        (angle_t )373130176,      (angle_t )373373952,      (angle_t )373617600,      (angle_t )373861152, 
        (angle_t )374104608,      (angle_t )374347936,      (angle_t )374591168,      (angle_t )374834304, 
        (angle_t )375077312,      (angle_t )375320224,      (angle_t )375563040,      (angle_t )375805760, 
        (angle_t )376048352,      (angle_t )376290848,      (angle_t )376533248,      (angle_t )376775520, 
        (angle_t )377017696,      (angle_t )377259776,      (angle_t )377501728,      (angle_t )377743584, 
        (angle_t )377985344,      (angle_t )378227008,      (angle_t )378468544,      (angle_t )378709984, 
        (angle_t )378951328,      (angle_t )379192544,      (angle_t )379433664,      (angle_t )379674688, 
        (angle_t )379915584,      (angle_t )380156416,      (angle_t )380397088,      (angle_t )380637696, 
        (angle_t )380878176,      (angle_t )381118560,      (angle_t )381358848,      (angle_t )381599040, 
        (angle_t )381839104,      (angle_t )382079072,      (angle_t )382318912,      (angle_t )382558656, 
        (angle_t )382798304,      (angle_t )383037856,      (angle_t )383277280,      (angle_t )383516640, 
        (angle_t )383755840,      (angle_t )383994976,      (angle_t )384233984,      (angle_t )384472896, 
        (angle_t )384711712,      (angle_t )384950400,      (angle_t )385188992,      (angle_t )385427488, 
        (angle_t )385665888,      (angle_t )385904160,      (angle_t )386142336,      (angle_t )386380384, 
        (angle_t )386618368,      (angle_t )386856224,      (angle_t )387093984,      (angle_t )387331616, 
        (angle_t )387569152,      (angle_t )387806592,      (angle_t )388043936,      (angle_t )388281152, 
        (angle_t )388518272,      (angle_t )388755296,      (angle_t )388992224,      (angle_t )389229024, 
        (angle_t )389465728,      (angle_t )389702336,      (angle_t )389938816,      (angle_t )390175200, 
        (angle_t )390411488,      (angle_t )390647680,      (angle_t )390883744,      (angle_t )391119712, 
        (angle_t )391355584,      (angle_t )391591328,      (angle_t )391826976,      (angle_t )392062528, 
        (angle_t )392297984,      (angle_t )392533312,      (angle_t )392768544,      (angle_t )393003680, 
        (angle_t )393238720,      (angle_t )393473632,      (angle_t )393708448,      (angle_t )393943168, 
        (angle_t )394177760,      (angle_t )394412256,      (angle_t )394646656,      (angle_t )394880960, 
        (angle_t )395115136,      (angle_t )395349216,      (angle_t )395583200,      (angle_t )395817088, 
        (angle_t )396050848,      (angle_t )396284512,      (angle_t )396518080,      (angle_t )396751520, 
        (angle_t )396984864,      (angle_t )397218112,      (angle_t )397451264,      (angle_t )397684288, 
        (angle_t )397917248,      (angle_t )398150080,      (angle_t )398382784,      (angle_t )398615424, 
        (angle_t )398847936,      (angle_t )399080320,      (angle_t )399312640,      (angle_t )399544832, 
        (angle_t )399776928,      (angle_t )400008928,      (angle_t )400240832,      (angle_t )400472608, 
        (angle_t )400704288,      (angle_t )400935872,      (angle_t )401167328,      (angle_t )401398720, 
        (angle_t )401629984,      (angle_t )401861120,      (angle_t )402092192,      (angle_t )402323136, 
        (angle_t )402553984,      (angle_t )402784736,      (angle_t )403015360,      (angle_t )403245888, 
        (angle_t )403476320,      (angle_t )403706656,      (angle_t )403936896,      (angle_t )404167008, 
        (angle_t )404397024,      (angle_t )404626944,      (angle_t )404856736,      (angle_t )405086432, 
        (angle_t )405316032,      (angle_t )405545536,      (angle_t )405774912,      (angle_t )406004224, 
        (angle_t )406233408,      (angle_t )406462464,      (angle_t )406691456,      (angle_t )406920320, 
        (angle_t )407149088,      (angle_t )407377760,      (angle_t )407606336,      (angle_t )407834784, 
        (angle_t )408063136,      (angle_t )408291392,      (angle_t )408519520,      (angle_t )408747584, 
        (angle_t )408975520,      (angle_t )409203360,      (angle_t )409431072,      (angle_t )409658720, 
        (angle_t )409886240,      (angle_t )410113664,      (angle_t )410340992,      (angle_t )410568192, 
        (angle_t )410795296,      (angle_t )411022304,      (angle_t )411249216,      (angle_t )411476032, 
        (angle_t )411702720,      (angle_t )411929312,      (angle_t )412155808,      (angle_t )412382176, 
        (angle_t )412608480,      (angle_t )412834656,      (angle_t )413060736,      (angle_t )413286720, 
        (angle_t )413512576,      (angle_t )413738336,      (angle_t )413964000,      (angle_t )414189568, 
        (angle_t )414415040,      (angle_t )414640384,      (angle_t )414865632,      (angle_t )415090784, 
        (angle_t )415315840,      (angle_t )415540800,      (angle_t )415765632,      (angle_t )415990368, 
        (angle_t )416215008,      (angle_t )416439552,      (angle_t )416663968,      (angle_t )416888288, 
        (angle_t )417112512,      (angle_t )417336640,      (angle_t )417560672,      (angle_t )417784576, 
        (angle_t )418008384,      (angle_t )418232096,      (angle_t )418455712,      (angle_t )418679200, 
        (angle_t )418902624,      (angle_t )419125920,      (angle_t )419349120,      (angle_t )419572192, 
        (angle_t )419795200,      (angle_t )420018080,      (angle_t )420240864,      (angle_t )420463552, 
        (angle_t )420686144,      (angle_t )420908608,      (angle_t )421130976,      (angle_t )421353280, 
        (angle_t )421575424,      (angle_t )421797504,      (angle_t )422019488,      (angle_t )422241344, 
        (angle_t )422463104,      (angle_t )422684768,      (angle_t )422906336,      (angle_t )423127776, 
        (angle_t )423349120,      (angle_t )423570400,      (angle_t )423791520,      (angle_t )424012576, 
        (angle_t )424233536,      (angle_t )424454368,      (angle_t )424675104,      (angle_t )424895744, 
        (angle_t )425116288,      (angle_t )425336736,      (angle_t )425557056,      (angle_t )425777280, 
        (angle_t )425997408,      (angle_t )426217440,      (angle_t )426437376,      (angle_t )426657184, 
        (angle_t )426876928,      (angle_t )427096544,      (angle_t )427316064,      (angle_t )427535488, 
        (angle_t )427754784,      (angle_t )427974016,      (angle_t )428193120,      (angle_t )428412128, 
        (angle_t )428631040,      (angle_t )428849856,      (angle_t )429068544,      (angle_t )429287168, 
        (angle_t )429505664,      (angle_t )429724064,      (angle_t )429942368,      (angle_t )430160576, 
        (angle_t )430378656,      (angle_t )430596672,      (angle_t )430814560,      (angle_t )431032352, 
        (angle_t )431250048,      (angle_t )431467616,      (angle_t )431685120,      (angle_t )431902496, 
        (angle_t )432119808,      (angle_t )432336992,      (angle_t )432554080,      (angle_t )432771040, 
        (angle_t )432987936,      (angle_t )433204736,      (angle_t )433421408,      (angle_t )433637984, 
        (angle_t )433854464,      (angle_t )434070848,      (angle_t )434287104,      (angle_t )434503296, 
        (angle_t )434719360,      (angle_t )434935360,      (angle_t )435151232,      (angle_t )435367008, 
        (angle_t )435582656,      (angle_t )435798240,      (angle_t )436013696,      (angle_t )436229088, 
        (angle_t )436444352,      (angle_t )436659520,      (angle_t )436874592,      (angle_t )437089568, 
        (angle_t )437304416,      (angle_t )437519200,      (angle_t )437733856,      (angle_t )437948416, 
        (angle_t )438162880,      (angle_t )438377248,      (angle_t )438591520,      (angle_t )438805696, 
        (angle_t )439019744,      (angle_t )439233728,      (angle_t )439447584,      (angle_t )439661344, 
        (angle_t )439875008,      (angle_t )440088576,      (angle_t )440302048,      (angle_t )440515392, 
        (angle_t )440728672,      (angle_t )440941824,      (angle_t )441154880,      (angle_t )441367872, 
        (angle_t )441580736,      (angle_t )441793472,      (angle_t )442006144,      (angle_t )442218720, 
        (angle_t )442431168,      (angle_t )442643552,      (angle_t )442855808,      (angle_t )443067968, 
        (angle_t )443280032,      (angle_t )443492000,      (angle_t )443703872,      (angle_t )443915648, 
        (angle_t )444127296,      (angle_t )444338880,      (angle_t )444550336,      (angle_t )444761696, 
        (angle_t )444972992,      (angle_t )445184160,      (angle_t )445395232,      (angle_t )445606176, 
        (angle_t )445817056,      (angle_t )446027840,      (angle_t )446238496,      (angle_t )446449088, 
        (angle_t )446659552,      (angle_t )446869920,      (angle_t )447080192,      (angle_t )447290400, 
        (angle_t )447500448,      (angle_t )447710432,      (angle_t )447920320,      (angle_t )448130112, 
        (angle_t )448339776,      (angle_t )448549376,      (angle_t )448758848,      (angle_t )448968224, 
        (angle_t )449177536,      (angle_t )449386720,      (angle_t )449595808,      (angle_t )449804800, 
        (angle_t )450013664,      (angle_t )450222464,      (angle_t )450431168,      (angle_t )450639776, 
        (angle_t )450848256,      (angle_t )451056640,      (angle_t )451264960,      (angle_t )451473152, 
        (angle_t )451681248,      (angle_t )451889248,      (angle_t )452097152,      (angle_t )452304960, 
        (angle_t )452512672,      (angle_t )452720288,      (angle_t )452927808,      (angle_t )453135232, 
        (angle_t )453342528,      (angle_t )453549760,      (angle_t )453756864,      (angle_t )453963904, 
        (angle_t )454170816,      (angle_t )454377632,      (angle_t )454584384,      (angle_t )454791008, 
        (angle_t )454997536,      (angle_t )455203968,      (angle_t )455410304,      (angle_t )455616544, 
        (angle_t )455822688,      (angle_t )456028704,      (angle_t )456234656,      (angle_t )456440512, 
        (angle_t )456646240,      (angle_t )456851904,      (angle_t )457057472,      (angle_t )457262912, 
        (angle_t )457468256,      (angle_t )457673536,      (angle_t )457878688,      (angle_t )458083744, 
        (angle_t )458288736,      (angle_t )458493600,      (angle_t )458698368,      (angle_t )458903040, 
        (angle_t )459107616,      (angle_t )459312096,      (angle_t )459516480,      (angle_t )459720768, 
        (angle_t )459924960,      (angle_t )460129056,      (angle_t )460333056,      (angle_t )460536960, 
        (angle_t )460740736,      (angle_t )460944448,      (angle_t )461148064,      (angle_t )461351584, 
        (angle_t )461554976,      (angle_t )461758304,      (angle_t )461961536,      (angle_t )462164640, 
        (angle_t )462367680,      (angle_t )462570592,      (angle_t )462773440,      (angle_t )462976160, 
        (angle_t )463178816,      (angle_t )463381344,      (angle_t )463583776,      (angle_t )463786144, 
        (angle_t )463988384,      (angle_t )464190560,      (angle_t )464392608,      (angle_t )464594560, 
        (angle_t )464796448,      (angle_t )464998208,      (angle_t )465199872,      (angle_t )465401472, 
        (angle_t )465602944,      (angle_t )465804320,      (angle_t )466005600,      (angle_t )466206816, 
        (angle_t )466407904,      (angle_t )466608896,      (angle_t )466809824,      (angle_t )467010624, 
        (angle_t )467211328,      (angle_t )467411936,      (angle_t )467612480,      (angle_t )467812896, 
        (angle_t )468013216,      (angle_t )468213440,      (angle_t )468413600,      (angle_t )468613632, 
        (angle_t )468813568,      (angle_t )469013440,      (angle_t )469213184,      (angle_t )469412832, 
        (angle_t )469612416,      (angle_t )469811872,      (angle_t )470011232,      (angle_t )470210528, 
        (angle_t )470409696,      (angle_t )470608800,      (angle_t )470807776,      (angle_t )471006688, 
        (angle_t )471205472,      (angle_t )471404192,      (angle_t )471602784,      (angle_t )471801312, 
        (angle_t )471999712,      (angle_t )472198048,      (angle_t )472396288,      (angle_t )472594400, 
        (angle_t )472792448,      (angle_t )472990400,      (angle_t )473188256,      (angle_t )473385984, 
        (angle_t )473583648,      (angle_t )473781216,      (angle_t )473978688,      (angle_t )474176064, 
        (angle_t )474373344,      (angle_t )474570528,      (angle_t )474767616,      (angle_t )474964608, 
        (angle_t )475161504,      (angle_t )475358336,      (angle_t )475555040,      (angle_t )475751648, 
        (angle_t )475948192,      (angle_t )476144608,      (angle_t )476340928,      (angle_t )476537184, 
        (angle_t )476733312,      (angle_t )476929376,      (angle_t )477125344,      (angle_t )477321184, 
        (angle_t )477516960,      (angle_t )477712640,      (angle_t )477908224,      (angle_t )478103712, 
        (angle_t )478299104,      (angle_t )478494400,      (angle_t )478689600,      (angle_t )478884704, 
        (angle_t )479079744,      (angle_t )479274656,      (angle_t )479469504,      (angle_t )479664224, 
        (angle_t )479858880,      (angle_t )480053408,      (angle_t )480247872,      (angle_t )480442240, 
        (angle_t )480636512,      (angle_t )480830656,      (angle_t )481024736,      (angle_t )481218752, 
        (angle_t )481412640,      (angle_t )481606432,      (angle_t )481800128,      (angle_t )481993760, 
        (angle_t )482187264,      (angle_t )482380704,      (angle_t )482574016,      (angle_t )482767264, 
        (angle_t )482960416,      (angle_t )483153472,      (angle_t )483346432,      (angle_t )483539296, 
        (angle_t )483732064,      (angle_t )483924768,      (angle_t )484117344,      (angle_t )484309856, 
        (angle_t )484502240,      (angle_t )484694560,      (angle_t )484886784,      (angle_t )485078912, 
        (angle_t )485270944,      (angle_t )485462880,      (angle_t )485654720,      (angle_t )485846464, 
        (angle_t )486038144,      (angle_t )486229696,      (angle_t )486421184,      (angle_t )486612576, 
        (angle_t )486803840,      (angle_t )486995040,      (angle_t )487186176,      (angle_t )487377184, 
        (angle_t )487568096,      (angle_t )487758912,      (angle_t )487949664,      (angle_t )488140320, 
        (angle_t )488330880,      (angle_t )488521312,      (angle_t )488711712,      (angle_t )488901984, 
        (angle_t )489092160,      (angle_t )489282240,      (angle_t )489472256,      (angle_t )489662176, 
        (angle_t )489851968,      (angle_t )490041696,      (angle_t )490231328,      (angle_t )490420896, 
        (angle_t )490610336,      (angle_t )490799712,      (angle_t )490988960,      (angle_t )491178144, 
        (angle_t )491367232,      (angle_t )491556224,      (angle_t )491745120,      (angle_t )491933920, 
        (angle_t )492122656,      (angle_t )492311264,      (angle_t )492499808,      (angle_t )492688256, 
        (angle_t )492876608,      (angle_t )493064864,      (angle_t )493253056,      (angle_t )493441120, 
        (angle_t )493629120,      (angle_t )493817024,      (angle_t )494004832,      (angle_t )494192544, 
        (angle_t )494380160,      (angle_t )494567712,      (angle_t )494755136,      (angle_t )494942496, 
        (angle_t )495129760,      (angle_t )495316928,      (angle_t )495504000,      (angle_t )495691008, 
        (angle_t )495877888,      (angle_t )496064704,      (angle_t )496251424,      (angle_t )496438048, 
        (angle_t )496624608,      (angle_t )496811040,      (angle_t )496997408,      (angle_t )497183680, 
        (angle_t )497369856,      (angle_t )497555936,      (angle_t )497741920,      (angle_t )497927840, 
        (angle_t )498113632,      (angle_t )498299360,      (angle_t )498484992,      (angle_t )498670560, 
        (angle_t )498856000,      (angle_t )499041376,      (angle_t )499226656,      (angle_t )499411840, 
        (angle_t )499596928,      (angle_t )499781920,      (angle_t )499966848,      (angle_t )500151680, 
        (angle_t )500336416,      (angle_t )500521056,      (angle_t )500705600,      (angle_t )500890080, 
        (angle_t )501074464,      (angle_t )501258752,      (angle_t )501442944,      (angle_t )501627040, 
        (angle_t )501811072,      (angle_t )501995008,      (angle_t )502178848,      (angle_t )502362592, 
        (angle_t )502546240,      (angle_t )502729824,      (angle_t )502913312,      (angle_t )503096704, 
        (angle_t )503280000,      (angle_t )503463232,      (angle_t )503646368,      (angle_t )503829408, 
        (angle_t )504012352,      (angle_t )504195200,      (angle_t )504377984,      (angle_t )504560672, 
        (angle_t )504743264,      (angle_t )504925760,      (angle_t )505108192,      (angle_t )505290496, 
        (angle_t )505472736,      (angle_t )505654912,      (angle_t )505836960,      (angle_t )506018944, 
        (angle_t )506200832,      (angle_t )506382624,      (angle_t )506564320,      (angle_t )506745952, 
        (angle_t )506927488,      (angle_t )507108928,      (angle_t )507290272,      (angle_t )507471552, 
        (angle_t )507652736,      (angle_t )507833824,      (angle_t )508014816,      (angle_t )508195744, 
        (angle_t )508376576,      (angle_t )508557312,      (angle_t )508737952,      (angle_t )508918528, 
        (angle_t )509099008,      (angle_t )509279392,      (angle_t )509459680,      (angle_t )509639904, 
        (angle_t )509820032,      (angle_t )510000064,      (angle_t )510180000,      (angle_t )510359872, 
        (angle_t )510539648,      (angle_t )510719328,      (angle_t )510898944,      (angle_t )511078432, 
        (angle_t )511257856,      (angle_t )511437216,      (angle_t )511616448,      (angle_t )511795616, 
        (angle_t )511974688,      (angle_t )512153664,      (angle_t )512332576,      (angle_t )512511392, 
        (angle_t )512690112,      (angle_t )512868768,      (angle_t )513047296,      (angle_t )513225792, 
        (angle_t )513404160,      (angle_t )513582432,      (angle_t )513760640,      (angle_t )513938784, 
        (angle_t )514116800,      (angle_t )514294752,      (angle_t )514472608,      (angle_t )514650368, 
        (angle_t )514828064,      (angle_t )515005664,      (angle_t )515183168,      (angle_t )515360608, 
        (angle_t )515537952,      (angle_t )515715200,      (angle_t )515892352,      (angle_t )516069440, 
        (angle_t )516246432,      (angle_t )516423328,      (angle_t )516600160,      (angle_t )516776896, 
        (angle_t )516953536,      (angle_t )517130112,      (angle_t )517306592,      (angle_t )517482976, 
        (angle_t )517659264,      (angle_t )517835488,      (angle_t )518011616,      (angle_t )518187680, 
        (angle_t )518363648,      (angle_t )518539520,      (angle_t )518715296,      (angle_t )518891008, 
        (angle_t )519066624,      (angle_t )519242144,      (angle_t )519417600,      (angle_t )519592960, 
        (angle_t )519768256,      (angle_t )519943424,      (angle_t )520118528,      (angle_t )520293568, 
        (angle_t )520468480,      (angle_t )520643328,      (angle_t )520818112,      (angle_t )520992800, 
        (angle_t )521167392,      (angle_t )521341888,      (angle_t )521516320,      (angle_t )521690656, 
        (angle_t )521864896,      (angle_t )522039072,      (angle_t )522213152,      (angle_t )522387168, 
        (angle_t )522561056,      (angle_t )522734912,      (angle_t )522908640,      (angle_t )523082304, 
        (angle_t )523255872,      (angle_t )523429376,      (angle_t )523602784,      (angle_t )523776096, 
        (angle_t )523949312,      (angle_t )524122464,      (angle_t )524295552,      (angle_t )524468512, 
        (angle_t )524641440,      (angle_t )524814240,      (angle_t )524986976,      (angle_t )525159616, 
        (angle_t )525332192,      (angle_t )525504640,      (angle_t )525677056,      (angle_t )525849344, 
        (angle_t )526021568,      (angle_t )526193728,      (angle_t )526365792,      (angle_t )526537760, 
        (angle_t )526709632,      (angle_t )526881440,      (angle_t )527053152,      (angle_t )527224800, 
        (angle_t )527396352,      (angle_t )527567840,      (angle_t )527739200,      (angle_t )527910528, 
        (angle_t )528081728,      (angle_t )528252864,      (angle_t )528423936,      (angle_t )528594880, 
        (angle_t )528765760,      (angle_t )528936576,      (angle_t )529107296,      (angle_t )529277920, 
        (angle_t )529448480,      (angle_t )529618944,      (angle_t )529789344,      (angle_t )529959648, 
        (angle_t )530129856,      (angle_t )530300000,      (angle_t )530470048,      (angle_t )530640000, 
        (angle_t )530809888,      (angle_t )530979712,      (angle_t )531149440,      (angle_t )531319072, 
        (angle_t )531488608,      (angle_t )531658080,      (angle_t )531827488,      (angle_t )531996800, 
        (angle_t )532166016,      (angle_t )532335168,      (angle_t )532504224,      (angle_t )532673184, 
        (angle_t )532842080,      (angle_t )533010912,      (angle_t )533179616,      (angle_t )533348288, 
        (angle_t )533516832,      (angle_t )533685312,      (angle_t )533853728,      (angle_t )534022048, 
        (angle_t )534190272,      (angle_t )534358432,      (angle_t )534526496,      (angle_t )534694496, 
        (angle_t )534862400,      (angle_t )535030240,      (angle_t )535197984,      (angle_t )535365632, 
        (angle_t )535533216,      (angle_t )535700704,      (angle_t )535868128,      (angle_t )536035456, 
        (angle_t )536202720,      (angle_t )536369888,      (angle_t )536536992,      (angle_t )536704000, 
        (angle_t )536870912};
#line 25 "f_finale.c"
static char const   rcsid___7[51]  = 
#line 25 "f_finale.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'f',      (char const   )'_',      (char const   )'f', 
        (char const   )'i',      (char const   )'n',      (char const   )'a',      (char const   )'l', 
        (char const   )'e',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )' ',      (char const   )'2',      (char const   )'1',      (char const   )':', 
        (char const   )'2',      (char const   )'6',      (char const   )':',      (char const   )'3', 
        (char const   )'4',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 79 "/usr/include/ctype.h"
extern unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 81
extern __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 83
extern __int32_t const   **( __attribute__((__leaf__)) __ctype_toupper_loc)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 108
extern int ( __attribute__((__leaf__)) isalnum)(int  )  __attribute__((__nothrow__)) ;
#line 109
extern int ( __attribute__((__leaf__)) isalpha)(int  )  __attribute__((__nothrow__)) ;
#line 110
extern int ( __attribute__((__leaf__)) iscntrl)(int  )  __attribute__((__nothrow__)) ;
#line 111
extern int ( __attribute__((__leaf__)) isdigit)(int  )  __attribute__((__nothrow__)) ;
#line 112
extern int ( __attribute__((__leaf__)) islower)(int  )  __attribute__((__nothrow__)) ;
#line 113
extern int ( __attribute__((__leaf__)) isgraph)(int  )  __attribute__((__nothrow__)) ;
#line 114
extern int ( __attribute__((__leaf__)) isprint)(int  )  __attribute__((__nothrow__)) ;
#line 115
extern int ( __attribute__((__leaf__)) ispunct)(int  )  __attribute__((__nothrow__)) ;
#line 116
extern int ( __attribute__((__leaf__)) isspace)(int  )  __attribute__((__nothrow__)) ;
#line 117
extern int ( __attribute__((__leaf__)) isupper)(int  )  __attribute__((__nothrow__)) ;
#line 118
extern int ( __attribute__((__leaf__)) isxdigit)(int  )  __attribute__((__nothrow__)) ;
#line 122
extern int ( __attribute__((__leaf__)) tolower)(int __c )  __attribute__((__nothrow__)) ;
#line 125
extern int ( __attribute__((__leaf__)) toupper)(int __c )  __attribute__((__nothrow__)) ;
#line 130
extern int ( __attribute__((__leaf__)) isblank)(int  )  __attribute__((__nothrow__)) ;
#line 142
extern int ( __attribute__((__leaf__)) isascii)(int __c )  __attribute__((__nothrow__)) ;
#line 146
extern int ( __attribute__((__leaf__)) toascii)(int __c )  __attribute__((__nothrow__)) ;
#line 150
extern int ( __attribute__((__leaf__)) _toupper)(int  )  __attribute__((__nothrow__)) ;
#line 151
extern int ( __attribute__((__leaf__)) _tolower)(int  )  __attribute__((__nothrow__)) ;
#line 251
extern int ( __attribute__((__leaf__)) isalnum_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 252
extern int ( __attribute__((__leaf__)) isalpha_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 253
extern int ( __attribute__((__leaf__)) iscntrl_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 254
extern int ( __attribute__((__leaf__)) isdigit_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 255
extern int ( __attribute__((__leaf__)) islower_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 256
extern int ( __attribute__((__leaf__)) isgraph_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 257
extern int ( __attribute__((__leaf__)) isprint_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 258
extern int ( __attribute__((__leaf__)) ispunct_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 259
extern int ( __attribute__((__leaf__)) isspace_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 260
extern int ( __attribute__((__leaf__)) isupper_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 261
extern int ( __attribute__((__leaf__)) isxdigit_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 263
extern int ( __attribute__((__leaf__)) isblank_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 267
extern int ( __attribute__((__leaf__)) __tolower_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 268
extern int ( __attribute__((__leaf__)) tolower_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 271
extern int ( __attribute__((__leaf__)) __toupper_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 272
extern int ( __attribute__((__leaf__)) toupper_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 38 "s_sound.h"
void S_Init(int sfxVolume , int musicVolume ) ;
#line 51
void S_Start(void) ;
#line 58
void S_StartSound(void *origin , int sfx_id ) ;
#line 66
void S_StartSoundAtVolume(void *origin_p , int sfx_id , int volume ) ;
#line 74
void S_StopSound(void *origin ) ;
#line 78
void S_StartMusic(int m_id ) ;
#line 82
void S_ChangeMusic(int musicnum , int looping___0 ) ;
#line 88
void S_StopMusic(void) ;
#line 91
void S_PauseSound(void) ;
#line 92
void S_ResumeSound(void) ;
#line 98
void S_UpdateSounds(void *listener_p ) ;
#line 100
void S_SetMusicVolume(int volume ) ;
#line 101
void S_SetSfxVolume(int volume ) ;
#line 52 "f_finale.c"
int finalestage  ;
#line 54 "f_finale.c"
int finalecount  ;
#line 59 "f_finale.c"
char *e1text  =    "Once you beat the big badasses and\nclean out the moon base you\'re supposed\nto win, aren\'t you? Aren\'t you? Where\'s\nyour fat reward and ticket home? What\nthe hell is this? It\'s not supposed to\nend this way!\n\nIt stinks like rotten meat, but looks\nlike the lost Deimos base.  Looks like\nyou\'re stuck on The Shores of Hell.\nThe only way out is through.\n\nTo continue the DOOM experience, play\nThe Shores of Hell and its amazing\nsequel, Inferno!\n";
#line 60 "f_finale.c"
char *e2text  =    "You\'ve done it! The hideous cyber-\ndemon lord that ruled the lost Deimos\nmoon base has been slain and you\nare triumphant! But ... where are\nyou? You clamber to the edge of the\nmoon and look down to see the awful\ntruth.\n\nDeimos floats above Hell itself!\nYou\'ve never heard of anyone escaping\nfrom Hell, but you\'ll make the bastards\nsorry they ever heard of you! Quickly,\nyou rappel down to  the surface of\nHell.\n\nNow, it\'s on to the final chapter of\nDOOM! -- Inferno.";
#line 61 "f_finale.c"
char *e3text  =    "The loathsome spiderdemon that\nmasterminded the invasion of the moon\nbases and caused so much death has had\nits ass kicked for all time.\n\nA hidden doorway opens and you enter.\nYou\'ve proven too tough for Hell to\ncontain, and now Hell at last plays\nfair -- for you emerge from the door\nto see the green fields of Earth!\nHome at last.\n\nYou wonder what\'s been happening on\nEarth while you were battling evil\nunleashed. It\'s good that no Hell-\nspawn could have come through that\ndoor with you ...";
#line 62 "f_finale.c"
char *e4text  =    "the spider mastermind must have sent forth\nits legions of hellspawn before your\nfinal confrontation with that terrible\nbeast from hell.  but you stepped forward\nand brought forth eternal damnation and\nsuffering upon the horde as a true hero\nwould in the face of something so evil.\n\nbesides, someone was gonna pay for what\nhappened to daisy, your pet rabbit.\n\nbut now, you see spread before you more\npotential pain and gibbitude as a nation\nof demons run amok among our cities.\n\nnext stop, hell on earth!";
#line 64 "f_finale.c"
char *c1text  =    "YOU HAVE ENTERED DEEPLY INTO THE INFESTED\nSTARPORT. BUT SOMETHING IS WRONG. THE\nMONSTERS HAVE BROUGHT THEIR OWN REALITY\nWITH THEM, AND THE STARPORT\'S TECHNOLOGY\nIS BEING SUBVERTED BY THEIR PRESENCE.\n\nAHEAD, YOU SEE AN OUTPOST OF HELL, A\nFORTIFIED ZONE. IF YOU CAN GET PAST IT,\nYOU CAN PENETRATE INTO THE HAUNTED HEART\nOF THE STARBASE AND FIND THE CONTROLLING\nSWITCH WHICH HOLDS EARTH\'S POPULATION\nHOSTAGE.";
#line 65 "f_finale.c"
char *c2text  =    "YOU HAVE WON! YOUR VICTORY HAS ENABLED\nHUMANKIND TO EVACUATE EARTH AND ESCAPE\nTHE NIGHTMARE.  NOW YOU ARE THE ONLY\nHUMAN LEFT ON THE FACE OF THE PLANET.\nCANNIBAL MUTATIONS, CARNIVOROUS ALIENS,\nAND EVIL SPIRITS ARE YOUR ONLY NEIGHBORS.\nYOU SIT BACK AND WAIT FOR DEATH, CONTENT\nTHAT YOU HAVE SAVED YOUR SPECIES.\n\nBUT THEN, EARTH CONTROL BEAMS DOWN A\nMESSAGE FROM SPACE: \"SENSORS HAVE LOCATED\nTHE SOURCE OF THE ALIEN INVASION. IF YOU\nGO THERE, YOU MAY BE ABLE TO BLOCK THEIR\nENTRY.  THE ALIEN BASE IS IN THE HEART OF\nYOUR OWN HOME CITY, NOT FAR FROM THE\nSTARPORT.\" SLOWLY AND PAINFULLY YOU GET\nUP AND RETURN TO THE FRAY.";
#line 66 "f_finale.c"
char *c3text  =    "YOU ARE AT THE CORRUPT HEART OF THE CITY,\nSURROUNDED BY THE CORPSES OF YOUR ENEMIES.\nYOU SEE NO WAY TO DESTROY THE CREATURES\'\nENTRYWAY ON THIS SIDE, SO YOU CLENCH YOUR\nTEETH AND PLUNGE THROUGH IT.\n\nTHERE MUST BE A WAY TO CLOSE IT ON THE\nOTHER SIDE. WHAT DO YOU CARE IF YOU\'VE\nGOT TO GO THROUGH HELL TO GET TO IT?";
#line 67 "f_finale.c"
char *c4text  =    "THE HORRENDOUS VISAGE OF THE BIGGEST\nDEMON YOU\'VE EVER SEEN CRUMBLES BEFORE\nYOU, AFTER YOU PUMP YOUR ROCKETS INTO\nHIS EXPOSED BRAIN. THE MONSTER SHRIVELS\nUP AND DIES, ITS THRASHING LIMBS\nDEVASTATING UNTOLD MILES OF HELL\'S\nSURFACE.\n\nYOU\'VE DONE IT. THE INVASION IS OVER.\nEARTH IS SAVED. HELL IS A WRECK. YOU\nWONDER WHERE BAD FOLKS WILL GO WHEN THEY\nDIE, NOW. WIPING THE SWEAT FROM YOUR\nFOREHEAD YOU BEGIN THE LONG TREK BACK\nHOME. REBUILDING EARTH OUGHT TO BE A\nLOT MORE FUN THAN RUINING IT WAS.\n";
#line 68 "f_finale.c"
char *c5text  =    "CONGRATULATIONS, YOU\'VE FOUND THE SECRET\nLEVEL! LOOKS LIKE IT\'S BEEN BUILT BY\nHUMANS, RATHER THAN DEMONS. YOU WONDER\nWHO THE INMATES OF THIS CORNER OF HELL\nWILL BE.";
#line 69 "f_finale.c"
char *c6text  =    "CONGRATULATIONS, YOU\'VE FOUND THE\nSUPER SECRET LEVEL!  YOU\'D BETTER\nBLAZE THROUGH THIS ONE!\n";
#line 71 "f_finale.c"
char *p1text  =    "You gloat over the steaming carcass of the\nGuardian.  With its death, you\'ve wrested\nthe Accelerator from the stinking claws\nof Hell.  You relax and glance around the\nroom.  Damn!  There was supposed to be at\nleast one working prototype, but you can\'t\nsee it. The demons must have taken it.\n\nYou must find the prototype, or all your\nstruggles will have been wasted. Keep\nmoving, keep fighting, keep killing.\nOh yes, keep living, too.";
#line 72 "f_finale.c"
char *p2text  =    "Even the deadly Arch-Vile labyrinth could\nnot stop you, and you\'ve gotten to the\nprototype Accelerator which is soon\nefficiently and permanently deactivated.\n\nYou\'re good at that kind of thing.";
#line 73 "f_finale.c"
char *p3text  =    "You\'ve bashed and battered your way into\nthe heart of the devil-hive.  Time for a\nSearch-and-Destroy mission, aimed at the\nGatekeeper, whose foul offspring is\ncascading to Earth.  Yeah, he\'s bad. But\nyou know who\'s worse!\n\nGrinning evilly, you check your gear, and\nget ready to give the bastard a little Hell\nof your own making!";
#line 74 "f_finale.c"
char *p4text  =    "The Gatekeeper\'s evil face is splattered\nall over the place.  As its tattered corpse\ncollapses, an inverted Gate forms and\nsucks down the shards of the last\nprototype Accelerator, not to mention the\nfew remaining demons.  You\'re done. Hell\nhas gone back to pounding bad dead folks \ninstead of good live ones.  Remember to\ntell your grandkids to put a rocket\nlauncher in your coffin. If you go to Hell\nwhen you die, you\'ll need it for some\nfinal cleaning-up ...";
#line 75 "f_finale.c"
char *p5text  =    "You\'ve found the second-hardest level we\ngot. Hope you have a saved game a level or\ntwo previous.  If not, be prepared to die\naplenty. For master marines only.";
#line 76 "f_finale.c"
char *p6text  =    "Betcha wondered just what WAS the hardest\nlevel we had ready for ya?  Now you know.\nNo one gets out alive.";
#line 78 "f_finale.c"
char *t1text  =    "You\'ve fought your way out of the infested\nexperimental labs.   It seems that UAC has\nonce again gulped it down.  With their\nhigh turnover, it must be hard for poor\nold UAC to buy corporate health insurance\nnowadays..\n\nAhead lies the military complex, now\nswarming with diseased horrors hot to get\ntheir teeth into you. With luck, the\ncomplex still has some warlike ordnance\nlaying around.";
#line 79 "f_finale.c"
char *t2text  =    "You hear the grinding of heavy machinery\nahead.  You sure hope they\'re not stamping\nout new hellspawn, but you\'re ready to\nream out a whole herd if you have to.\nThey might be planning a blood feast, but\nyou feel about as mean as two thousand\nmaniacs packed into one mad killer.\n\nYou don\'t plan to go down easy.";
#line 80 "f_finale.c"
char *t3text  =    "The vista opening ahead looks real damn\nfamiliar. Smells familiar, too -- like\nfried excrement. You didn\'t like this\nplace before, and you sure as hell ain\'t\nplanning to like it now. The more you\nbrood on it, the madder you get.\nHefting your gun, an evil grin trickles\nonto your face. Time to take some names.";
#line 81 "f_finale.c"
char *t4text  =    "Suddenly, all is silent, from one horizon\nto the other. The agonizing echo of Hell\nfades away, the nightmare sky turns to\nblue, the heaps of monster corpses start \nto evaporate along with the evil stench \nthat filled the air. Jeeze, maybe you\'ve\ndone it. Have you really won?\n\nSomething rumbles in the distance.\nA blue light begins to glow inside the\nruined skull of the demon-spitter.";
#line 82 "f_finale.c"
char *t5text  =    "What now? Looks totally different. Kind\nof like King Tut\'s condo. Well,\nwhatever\'s here can\'t be any worse\nthan usual. Can it?  Or maybe it\'s best\nto let sleeping gods lie..";
#line 83 "f_finale.c"
char *t6text  =    "Time for a vacation. You\'ve burst the\nbowels of hell and by golly you\'re ready\nfor a break. You mutter to yourself,\nMaybe someone else can kick Hell\'s ass\nnext time around. Ahead lies a quiet town,\nwith peaceful flowing water, quaint\nbuildings, and presumably no Hellspawn.\n\nAs you step off the transport, you hear\nthe stomp of a cyberdemon\'s iron shoe.";
#line 85 "f_finale.c"
char *finaletext  ;
#line 86 "f_finale.c"
char *finaleflat  ;
#line 88
void F_StartCast(void) ;
#line 89
void F_CastTicker(void) ;
#line 90
boolean F_CastResponder(event_t *ev ) ;
#line 91
void F_CastDrawer(void) ;
#line 96 "f_finale.c"
void F_StartFinale(void) 
{ 


  {
#line 98
  gameaction = (gameaction_t )0;
#line 99
  gamestate = (gamestate_t )2;
#line 100
  viewactive = (boolean )0;
#line 101
  automapactive = (boolean )0;
  {
#line 112
  if ((unsigned int )gamemode == 3U) {
#line 112
    goto case_3;
  }
#line 112
  if ((unsigned int )gamemode == 1U) {
#line 112
    goto case_3;
  }
#line 112
  if ((unsigned int )gamemode == 0U) {
#line 112
    goto case_3;
  }
#line 142
  if ((unsigned int )gamemode == 2U) {
#line 142
    goto case_2___0;
  }
#line 181
  goto switch_default___1;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 114
  S_ChangeMusic(31, 1);
  {
#line 118
  if (gameepisode == 1) {
#line 118
    goto case_1___0;
  }
#line 122
  if (gameepisode == 2) {
#line 122
    goto case_2;
  }
#line 126
  if (gameepisode == 3) {
#line 126
    goto case_3___0;
  }
#line 130
  if (gameepisode == 4) {
#line 130
    goto case_4;
  }
#line 134
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 119
  finaleflat = "FLOOR4_8";
#line 120
  finaletext = e1text;
#line 121
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 123
  finaleflat = "SFLR6_1";
#line 124
  finaletext = e2text;
#line 125
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 127
  finaleflat = "MFLR8_4";
#line 128
  finaletext = e3text;
#line 129
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 131
  finaleflat = "MFLR8_3";
#line 132
  finaletext = e4text;
#line 133
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 136
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 138
  goto switch_break;
  case_2___0: /* CIL Label */ 
#line 144
  S_ChangeMusic(65, 1);
  {
#line 148
  if (gamemap == 6) {
#line 148
    goto case_6;
  }
#line 152
  if (gamemap == 11) {
#line 152
    goto case_11;
  }
#line 156
  if (gamemap == 20) {
#line 156
    goto case_20;
  }
#line 160
  if (gamemap == 30) {
#line 160
    goto case_30;
  }
#line 164
  if (gamemap == 15) {
#line 164
    goto case_15;
  }
#line 168
  if (gamemap == 31) {
#line 168
    goto case_31;
  }
#line 172
  goto switch_default___0;
  case_6: /* CIL Label */ 
#line 149
  finaleflat = "SLIME16";
#line 150
  finaletext = c1text;
#line 151
  goto switch_break___1;
  case_11: /* CIL Label */ 
#line 153
  finaleflat = "RROCK14";
#line 154
  finaletext = c2text;
#line 155
  goto switch_break___1;
  case_20: /* CIL Label */ 
#line 157
  finaleflat = "RROCK07";
#line 158
  finaletext = c3text;
#line 159
  goto switch_break___1;
  case_30: /* CIL Label */ 
#line 161
  finaleflat = "RROCK17";
#line 162
  finaletext = c4text;
#line 163
  goto switch_break___1;
  case_15: /* CIL Label */ 
#line 165
  finaleflat = "RROCK13";
#line 166
  finaletext = c5text;
#line 167
  goto switch_break___1;
  case_31: /* CIL Label */ 
#line 169
  finaleflat = "RROCK19";
#line 170
  finaletext = c6text;
#line 171
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 174
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 176
  goto switch_break;
  switch_default___1: /* CIL Label */ 
#line 182
  S_ChangeMusic(65, 1);
#line 183
  finaleflat = "F_SKY1";
#line 184
  finaletext = c1text;
#line 185
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 188
  finalestage = 0;
#line 189
  finalecount = 0;
#line 191
  return;
}
}
#line 195 "f_finale.c"
boolean F_Responder(event_t *event ) 
{ 
  boolean tmp ;

  {
#line 197
  if (finalestage == 2) {
#line 198
    tmp = F_CastResponder(event);
#line 198
    return (tmp);
  }
#line 200
  return ((boolean )0);
}
}
#line 207 "f_finale.c"
void F_Ticker(void) 
{ 
  int i ;
  size_t tmp ;

  {
#line 212
  if ((unsigned int )gamemode == 2U) {
#line 212
    if (finalecount > 50) {
#line 216
      i = 0;
      {
#line 216
      while (1) {
        while_continue: /* CIL Label */ ;
#line 216
        if (! (i < 4)) {
#line 216
          goto while_break;
        }
#line 217
        if (players[i].cmd.buttons) {
#line 218
          goto while_break;
        }
#line 216
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 220
      if (i < 4) {
#line 222
        if (gamemap == 30) {
#line 223
          F_StartCast();
        } else {
#line 225
          gameaction = (gameaction_t )8;
        }
      }
    } else {
#line 212
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 230
  finalecount ++;
#line 232
  if (finalestage == 2) {
#line 234
    F_CastTicker();
#line 235
    return;
  }
#line 238
  if ((unsigned int )gamemode == 2U) {
#line 239
    return;
  }
#line 241
  if (! finalestage) {
#line 241
    tmp = strlen((char const   *)finaletext);
#line 241
    if ((size_t )finalecount > tmp * 3U + 250U) {
#line 243
      finalecount = 0;
#line 244
      finalestage = 1;
#line 245
      wipegamestate = (gamestate_t )-1;
#line 246
      if (gameepisode == 3) {
#line 247
        S_StartMusic(30);
      }
    } else {
#line 241
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 249
  return;
}
}
#line 50 "hu_stuff.h"
void HU_Init(void) ;
#line 51
void HU_Start(void) ;
#line 53
boolean HU_Responder(event_t *ev ) ;
#line 55
void HU_Ticker(void) ;
#line 56
void HU_Drawer(void) ;
#line 57
char HU_dequeueChatChar(void) ;
#line 58
void HU_Erase(void) ;
#line 258 "f_finale.c"
patch_t *hu_font[63] ;
#line 261 "f_finale.c"
void F_TextWrite(void) 
{ 
  byte *src ;
  byte *dest ;
  int x___0 ;
  int y___1 ;
  int w ;
  int count ;
  char *ch ;
  int c ;
  int cx ;
  int cy ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 274
  tmp = W_CacheLumpName(finaleflat, 101);
#line 274
  src = (byte *)tmp;
#line 275
  dest = screens[0];
#line 277
  y___1 = 0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (y___1 < 200)) {
#line 277
      goto while_break;
    }
#line 279
    x___0 = 0;
    {
#line 279
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 279
      if (! (x___0 < 5)) {
#line 279
        goto while_break___0;
      }
#line 281
      memcpy((void * __restrict  )dest, (void const   * __restrict  )(src + ((y___1 & 63) << 6)),
             (size_t )64);
#line 282
      dest += 64;
#line 279
      x___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 284
    if (0) {
#line 286
      memcpy((void * __restrict  )dest, (void const   * __restrict  )(src + ((y___1 & 63) << 6)),
             (size_t )0);
#line 287
      dest += 0;
    }
#line 277
    y___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  V_MarkRect(0, 0, 320, 200);
#line 294
  cx = 10;
#line 295
  cy = 10;
#line 296
  ch = finaletext;
#line 298
  count = (finalecount - 10) / 3;
#line 299
  if (count < 0) {
#line 300
    count = 0;
  }
  {
#line 301
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 301
    if (! count) {
#line 301
      goto while_break___1;
    }
#line 303
    tmp___0 = ch;
#line 303
    ch ++;
#line 303
    c = (int )*tmp___0;
#line 304
    if (! c) {
#line 305
      goto while_break___1;
    }
#line 306
    if (c == 10) {
#line 308
      cx = 10;
#line 309
      cy += 11;
#line 310
      goto __Cont;
    }
#line 313
    tmp___1 = toupper(c);
#line 313
    c = tmp___1 - 33;
#line 314
    if (c < 0) {
#line 314
      goto _L;
    } else
#line 314
    if (c > 63) {
      _L: /* CIL Label */ 
#line 316
      cx += 4;
#line 317
      goto __Cont;
    }
#line 320
    w = (int )(hu_font[c])->width;
#line 321
    if (cx + w > 320) {
#line 322
      goto while_break___1;
    }
#line 323
    V_DrawPatch(cx, cy, 0, hu_font[c]);
#line 324
    cx += w;
    __Cont: /* CIL Label */ 
#line 301
    count --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 327
  return;
}
}
#line 340 "f_finale.c"
castinfo_t castorder[18]  = 
#line 340
  {      {"ZOMBIEMAN", (mobjtype_t )1}, 
        {"SHOTGUN GUY", (mobjtype_t )2}, 
        {"HEAVY WEAPON DUDE", (mobjtype_t )10}, 
        {"IMP", (mobjtype_t )11}, 
        {"DEMON", (mobjtype_t )12}, 
        {"LOST SOUL", (mobjtype_t )18}, 
        {"CACODEMON", (mobjtype_t )14}, 
        {"HELL KNIGHT", (mobjtype_t )17}, 
        {"BARON OF HELL", (mobjtype_t )15}, 
        {"ARACHNOTRON", (mobjtype_t )20}, 
        {"PAIN ELEMENTAL", (mobjtype_t )22}, 
        {"REVENANT", (mobjtype_t )5}, 
        {"MANCUBUS", (mobjtype_t )8}, 
        {"ARCH-VILE", (mobjtype_t )3}, 
        {"THE SPIDER MASTERMIND", (mobjtype_t )19}, 
        {"THE CYBERDEMON", (mobjtype_t )21}, 
        {"OUR HERO", (mobjtype_t )0}, 
        {(char *)((void *)0), (mobjtype_t )0}};
#line 362 "f_finale.c"
int castnum  ;
#line 363 "f_finale.c"
int casttics  ;
#line 364 "f_finale.c"
state_t *caststate  ;
#line 365 "f_finale.c"
boolean castdeath  ;
#line 366 "f_finale.c"
int castframes  ;
#line 367 "f_finale.c"
int castonmelee  ;
#line 368 "f_finale.c"
boolean castattacking  ;
#line 377 "f_finale.c"
void F_StartCast(void) 
{ 


  {
#line 379
  wipegamestate = (gamestate_t )-1;
#line 380
  castnum = 0;
#line 381
  caststate = & states[mobjinfo[castorder[castnum].type].seestate];
#line 382
  casttics = (int )caststate->tics;
#line 383
  castdeath = (boolean )0;
#line 384
  finalestage = 2;
#line 385
  castframes = 0;
#line 386
  castonmelee = 0;
#line 387
  castattacking = (boolean )0;
#line 388
  S_ChangeMusic(63, 1);
#line 389
  return;
}
}
#line 395 "f_finale.c"
void F_CastTicker(void) 
{ 
  int st ;
  int sfx ;

  {
#line 400
  casttics --;
#line 400
  if (casttics > 0) {
#line 401
    return;
  }
#line 403
  if (caststate->tics == -1L) {
#line 403
    goto _L;
  } else
#line 403
  if ((unsigned int )caststate->nextstate == 0U) {
    _L: /* CIL Label */ 
#line 406
    castnum ++;
#line 407
    castdeath = (boolean )0;
#line 408
    if ((unsigned long )castorder[castnum].name == (unsigned long )((void *)0)) {
#line 409
      castnum = 0;
    }
#line 410
    if (mobjinfo[castorder[castnum].type].seesound) {
#line 411
      S_StartSound((void *)0, mobjinfo[castorder[castnum].type].seesound);
    }
#line 412
    caststate = & states[mobjinfo[castorder[castnum].type].seestate];
#line 413
    castframes = 0;
  } else {
#line 418
    if ((unsigned long )caststate == (unsigned long )(& states[154])) {
#line 419
      goto _L___0;
    }
#line 420
    st = (int )caststate->nextstate;
#line 421
    caststate = & states[st];
#line 422
    castframes ++;
    {
#line 427
    if (st == 154) {
#line 427
      goto case_154;
    }
#line 428
    if (st == 185) {
#line 428
      goto case_185;
    }
#line 429
    if (st == 218) {
#line 429
      goto case_218;
    }
#line 430
    if (st == 256) {
#line 430
      goto case_256;
    }
#line 431
    if (st == 336) {
#line 431
      goto case_336;
    }
#line 432
    if (st == 338) {
#line 432
      goto case_338;
    }
#line 433
    if (st == 340) {
#line 433
      goto case_340;
    }
#line 436
    if (st == 377) {
#line 436
      goto case_377;
    }
#line 436
    if (st == 380) {
#line 436
      goto case_377;
    }
#line 436
    if (st == 383) {
#line 436
      goto case_377;
    }
#line 439
    if (st == 419) {
#line 439
      goto case_419;
    }
#line 439
    if (st == 418) {
#line 439
      goto case_419;
    }
#line 439
    if (st == 417) {
#line 439
      goto case_419;
    }
#line 440
    if (st == 454) {
#line 440
      goto case_454;
    }
#line 441
    if (st == 486) {
#line 441
      goto case_486;
    }
#line 444
    if (st == 505) {
#line 444
      goto case_505;
    }
#line 444
    if (st == 567) {
#line 444
      goto case_505;
    }
#line 444
    if (st == 538) {
#line 444
      goto case_505;
    }
#line 445
    if (st == 590) {
#line 445
      goto case_590;
    }
#line 447
    if (st == 617) {
#line 447
      goto case_617;
    }
#line 447
    if (st == 616) {
#line 447
      goto case_617;
    }
#line 448
    if (st == 648) {
#line 448
      goto case_648;
    }
#line 451
    if (st == 689) {
#line 451
      goto case_689;
    }
#line 451
    if (st == 687) {
#line 451
      goto case_689;
    }
#line 451
    if (st == 685) {
#line 451
      goto case_689;
    }
#line 452
    if (st == 710) {
#line 452
      goto case_710;
    }
#line 453
    goto switch_default;
    case_154: /* CIL Label */ 
#line 427
    sfx = 4;
#line 427
    goto switch_break;
    case_185: /* CIL Label */ 
#line 428
    sfx = 1;
#line 428
    goto switch_break;
    case_218: /* CIL Label */ 
#line 429
    sfx = 2;
#line 429
    goto switch_break;
    case_256: /* CIL Label */ 
#line 430
    sfx = 54;
#line 430
    goto switch_break;
    case_336: /* CIL Label */ 
#line 431
    sfx = 56;
#line 431
    goto switch_break;
    case_338: /* CIL Label */ 
#line 432
    sfx = 53;
#line 432
    goto switch_break;
    case_340: /* CIL Label */ 
#line 433
    sfx = 107;
#line 433
    goto switch_break;
    case_377: /* CIL Label */ 
    case_380: /* CIL Label */ 
    case_383: /* CIL Label */ 
#line 436
    sfx = 16;
#line 436
    goto switch_break;
    case_419: /* CIL Label */ 
    case_418: /* CIL Label */ 
    case_417: /* CIL Label */ 
#line 439
    sfx = 2;
#line 439
    goto switch_break;
    case_454: /* CIL Label */ 
#line 440
    sfx = 55;
#line 440
    goto switch_break;
    case_486: /* CIL Label */ 
#line 441
    sfx = 52;
#line 441
    goto switch_break;
    case_505: /* CIL Label */ 
    case_567: /* CIL Label */ 
    case_538: /* CIL Label */ 
#line 444
    sfx = 16;
#line 444
    goto switch_break;
    case_590: /* CIL Label */ 
#line 445
    sfx = 51;
#line 445
    goto switch_break;
    case_617: /* CIL Label */ 
    case_616: /* CIL Label */ 
#line 447
    sfx = 2;
#line 447
    goto switch_break;
    case_648: /* CIL Label */ 
#line 448
    sfx = 8;
#line 448
    goto switch_break;
    case_689: /* CIL Label */ 
    case_687: /* CIL Label */ 
    case_685: /* CIL Label */ 
#line 451
    sfx = 14;
#line 451
    goto switch_break;
    case_710: /* CIL Label */ 
#line 452
    sfx = 51;
#line 452
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 453
    sfx = 0;
#line 453
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 456
    if (sfx) {
#line 457
      S_StartSound((void *)0, sfx);
    }
  }
#line 460
  if (castframes == 12) {
#line 463
    castattacking = (boolean )1;
#line 464
    if (castonmelee) {
#line 465
      caststate = & states[mobjinfo[castorder[castnum].type].meleestate];
    } else {
#line 467
      caststate = & states[mobjinfo[castorder[castnum].type].missilestate];
    }
#line 468
    castonmelee ^= 1;
#line 469
    if ((unsigned long )caststate == (unsigned long )(& states[0])) {
#line 471
      if (castonmelee) {
#line 472
        caststate = & states[mobjinfo[castorder[castnum].type].meleestate];
      } else {
#line 475
        caststate = & states[mobjinfo[castorder[castnum].type].missilestate];
      }
    }
  }
#line 480
  if (castattacking) {
#line 482
    if (castframes == 24) {
#line 482
      goto _L___0;
    } else
#line 482
    if ((unsigned long )caststate == (unsigned long )(& states[mobjinfo[castorder[castnum].type].seestate])) {
      _L___0: /* CIL Label */ 
      stopattack: 
#line 486
      castattacking = (boolean )0;
#line 487
      castframes = 0;
#line 488
      caststate = & states[mobjinfo[castorder[castnum].type].seestate];
    }
  }
#line 492
  casttics = (int )caststate->tics;
#line 493
  if (casttics == -1) {
#line 494
    casttics = 15;
  }
#line 495
  return;
}
}
#line 502 "f_finale.c"
boolean F_CastResponder(event_t *ev ) 
{ 


  {
#line 504
  if ((unsigned int )ev->type != 0U) {
#line 505
    return ((boolean )0);
  }
#line 507
  if (castdeath) {
#line 508
    return ((boolean )1);
  }
#line 511
  castdeath = (boolean )1;
#line 512
  caststate = & states[mobjinfo[castorder[castnum].type].deathstate];
#line 513
  casttics = (int )caststate->tics;
#line 514
  castframes = 0;
#line 515
  castattacking = (boolean )0;
#line 516
  if (mobjinfo[castorder[castnum].type].deathsound) {
#line 517
    S_StartSound((void *)0, mobjinfo[castorder[castnum].type].deathsound);
  }
#line 519
  return ((boolean )1);
}
}
#line 523 "f_finale.c"
void F_CastPrint(char *text ) 
{ 
  char *ch ;
  int c ;
  int cx ;
  int w ;
  int width ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 532
  ch = text;
#line 533
  width = 0;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! ch) {
#line 535
      goto while_break;
    }
#line 537
    tmp = ch;
#line 537
    ch ++;
#line 537
    c = (int )*tmp;
#line 538
    if (! c) {
#line 539
      goto while_break;
    }
#line 540
    tmp___0 = toupper(c);
#line 540
    c = tmp___0 - 33;
#line 541
    if (c < 0) {
#line 541
      goto _L;
    } else
#line 541
    if (c > 63) {
      _L: /* CIL Label */ 
#line 543
      width += 4;
#line 544
      goto while_continue;
    }
#line 547
    w = (int )(hu_font[c])->width;
#line 548
    width += w;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  cx = 160 - width / 2;
#line 553
  ch = text;
  {
#line 554
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 554
    if (! ch) {
#line 554
      goto while_break___0;
    }
#line 556
    tmp___1 = ch;
#line 556
    ch ++;
#line 556
    c = (int )*tmp___1;
#line 557
    if (! c) {
#line 558
      goto while_break___0;
    }
#line 559
    tmp___2 = toupper(c);
#line 559
    c = tmp___2 - 33;
#line 560
    if (c < 0) {
#line 560
      goto _L___0;
    } else
#line 560
    if (c > 63) {
      _L___0: /* CIL Label */ 
#line 562
      cx += 4;
#line 563
      goto while_continue___0;
    }
#line 566
    w = (int )(hu_font[c])->width;
#line 567
    V_DrawPatch(cx, 180, 0, hu_font[c]);
#line 568
    cx += w;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 571
  return;
}
}
#line 577
void V_DrawPatchFlipped(int x___0 , int y___1 , int scrn , patch_t *patch ) ;
#line 579 "f_finale.c"
void F_CastDrawer(void) 
{ 
  spritedef_t *sprdef ;
  spriteframe_t *sprframe ;
  int lump ;
  boolean flip ;
  patch_t *patch ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 588
  tmp = W_CacheLumpName("BOSSBACK", 101);
#line 588
  V_DrawPatch(0, 0, 0, (patch_t *)tmp);
#line 590
  F_CastPrint(castorder[castnum].name);
#line 593
  sprdef = sprites + caststate->sprite;
#line 594
  sprframe = sprdef->spriteframes + (caststate->frame & 32767L);
#line 595
  lump = (int )sprframe->lump[0];
#line 596
  flip = (boolean )sprframe->flip[0];
#line 598
  tmp___0 = W_CacheLumpNum(lump + firstspritelump, 101);
#line 598
  patch = (patch_t *)tmp___0;
#line 599
  if (flip) {
#line 600
    V_DrawPatchFlipped(160, 170, 0, patch);
  } else {
#line 602
    V_DrawPatch(160, 170, 0, patch);
  }
#line 603
  return;
}
}
#line 609 "f_finale.c"
void F_DrawPatchCol(int x___0 , patch_t *patch , int col ) 
{ 
  column_t *column ;
  byte *source ;
  byte *dest ;
  byte *desttop ;
  int count ;
  byte *tmp ;
  int tmp___0 ;

  {
#line 621
  column = (column_t *)((byte *)patch + patch->columnofs[col]);
#line 622
  desttop = screens[0] + x___0;
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 625
    if (! ((int )column->topdelta != 0xff)) {
#line 625
      goto while_break;
    }
#line 627
    source = (byte *)column + 3;
#line 628
    dest = desttop + (int )column->topdelta * 320;
#line 629
    count = (int )column->length;
    {
#line 631
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 631
      tmp___0 = count;
#line 631
      count --;
#line 631
      if (! tmp___0) {
#line 631
        goto while_break___0;
      }
#line 633
      tmp = source;
#line 633
      source ++;
#line 633
      *dest = *tmp;
#line 634
      dest += 320;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 636
    column = (column_t *)(((byte *)column + (int )column->length) + 4);
  }
  while_break: /* CIL Label */ ;
  }
#line 638
  return;
}
}
#line 652 "f_finale.c"
static int laststage  ;
#line 644 "f_finale.c"
void F_BunnyScroll(void) 
{ 
  int scrolled ;
  int x___0 ;
  patch_t *p1 ;
  patch_t *p2 ;
  char name[10] ;
  int stage ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 654
  tmp = W_CacheLumpName("PFUB2", 50);
#line 654
  p1 = (patch_t *)tmp;
#line 655
  tmp___0 = W_CacheLumpName("PFUB1", 50);
#line 655
  p2 = (patch_t *)tmp___0;
#line 657
  V_MarkRect(0, 0, 320, 200);
#line 659
  scrolled = 320 - (finalecount - 230) / 2;
#line 660
  if (scrolled > 320) {
#line 661
    scrolled = 320;
  }
#line 662
  if (scrolled < 0) {
#line 663
    scrolled = 0;
  }
#line 665
  x___0 = 0;
  {
#line 665
  while (1) {
    while_continue: /* CIL Label */ ;
#line 665
    if (! (x___0 < 320)) {
#line 665
      goto while_break;
    }
#line 667
    if (x___0 + scrolled < 320) {
#line 668
      F_DrawPatchCol(x___0, p1, x___0 + scrolled);
    } else {
#line 670
      F_DrawPatchCol(x___0, p2, (x___0 + scrolled) - 320);
    }
#line 665
    x___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 673
  if (finalecount < 1130) {
#line 674
    return;
  }
#line 675
  if (finalecount < 1180) {
#line 677
    tmp___1 = W_CacheLumpName("END0", 101);
#line 677
    V_DrawPatch(108, 68, 0, (patch_t *)tmp___1);
#line 679
    laststage = 0;
#line 680
    return;
  }
#line 683
  stage = (finalecount - 1180) / 5;
#line 684
  if (stage > 6) {
#line 685
    stage = 6;
  }
#line 686
  if (stage > laststage) {
#line 688
    S_StartSound((void *)0, 1);
#line 689
    laststage = stage;
  }
#line 692
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"END%i", stage);
#line 693
  tmp___2 = W_CacheLumpName(name, 101);
#line 693
  V_DrawPatch(108, 68, 0, (patch_t *)tmp___2);
#line 694
  return;
}
}
#line 700 "f_finale.c"
void F_Drawer(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 702
  if (finalestage == 2) {
#line 704
    F_CastDrawer();
#line 705
    return;
  }
#line 708
  if (! finalestage) {
#line 709
    F_TextWrite();
  } else {
    {
#line 714
    if (gameepisode == 1) {
#line 714
      goto case_1;
    }
#line 722
    if (gameepisode == 2) {
#line 722
      goto case_2;
    }
#line 726
    if (gameepisode == 3) {
#line 726
      goto case_3;
    }
#line 729
    if (gameepisode == 4) {
#line 729
      goto case_4;
    }
#line 712
    goto switch_break;
    case_1: /* CIL Label */ 
#line 715
    if ((unsigned int )gamemode == 3U) {
#line 716
      tmp = W_CacheLumpName("CREDIT", 101);
#line 716
      V_DrawPatch(0, 0, 0, (patch_t *)tmp);
    } else {
#line 719
      tmp___0 = W_CacheLumpName("HELP2", 101);
#line 719
      V_DrawPatch(0, 0, 0, (patch_t *)tmp___0);
    }
#line 721
    goto switch_break;
    case_2: /* CIL Label */ 
#line 723
    tmp___1 = W_CacheLumpName("VICTORY2", 101);
#line 723
    V_DrawPatch(0, 0, 0, (patch_t *)tmp___1);
#line 725
    goto switch_break;
    case_3: /* CIL Label */ 
#line 727
    F_BunnyScroll();
#line 728
    goto switch_break;
    case_4: /* CIL Label */ 
#line 730
    tmp___2 = W_CacheLumpName("ENDPIC", 101);
#line 730
    V_DrawPatch(0, 0, 0, (patch_t *)tmp___2);
#line 732
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 736
  return;
}
}
#line 25 "f_wipe.c"
static char const   rcsid___8[49]  = 
#line 25 "f_wipe.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'f',      (char const   )'_',      (char const   )'w', 
        (char const   )'i',      (char const   )'p',      (char const   )'e',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'2',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'0',      (char const   )'9',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 33 "m_random.h"
int M_Random(void) ;
#line 36
int P_Random(void) ;
#line 39
void M_ClearRandom(void) ;
#line 41 "f_wipe.h"
int wipe_StartScreen(int x___0 , int y___1 , int width , int height ) ;
#line 49
int wipe_EndScreen(int x___0 , int y___1 , int width , int height ) ;
#line 57
int wipe_ScreenWipe(int wipeno , int x___0 , int y___1 , int width , int height ,
                    int ticks ) ;
#line 43 "f_wipe.c"
static boolean go  =    (boolean )0;
#line 45 "f_wipe.c"
static byte *wipe_scr_start  ;
#line 46 "f_wipe.c"
static byte *wipe_scr_end  ;
#line 47 "f_wipe.c"
static byte *wipe_scr  ;
#line 50 "f_wipe.c"
void wipe_shittyColMajorXform(short *array , int width , int height ) 
{ 
  int x___0 ;
  int y___1 ;
  short *dest ;
  void *tmp ;

  {
#line 60
  tmp = Z_Malloc((width * height) * 2, 1, (void *)0);
#line 60
  dest = (short *)tmp;
#line 62
  y___1 = 0;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (y___1 < height)) {
#line 62
      goto while_break;
    }
#line 63
    x___0 = 0;
    {
#line 63
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 63
      if (! (x___0 < width)) {
#line 63
        goto while_break___0;
      }
#line 64
      *(dest + (x___0 * height + y___1)) = *(array + (y___1 * width + x___0));
#line 63
      x___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 62
    y___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  memcpy((void * __restrict  )array, (void const   * __restrict  )dest, (size_t )((width * height) * 2));
#line 68
  Z_Free((void *)dest);
#line 70
  return;
}
}
#line 72 "f_wipe.c"
int wipe_initColorXForm(int width , int height , int ticks ) 
{ 


  {
#line 78
  memcpy((void * __restrict  )wipe_scr, (void const   * __restrict  )wipe_scr_start,
         (size_t )(width * height));
#line 79
  return (0);
}
}
#line 82 "f_wipe.c"
int wipe_doColorXForm(int width , int height , int ticks ) 
{ 
  boolean changed ;
  byte *w ;
  byte *e ;
  int newval ;

  {
#line 93
  changed = (boolean )0;
#line 94
  w = wipe_scr;
#line 95
  e = wipe_scr_end;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! ((unsigned long )w != (unsigned long )(wipe_scr + width * height))) {
#line 97
      goto while_break;
    }
#line 99
    if ((int )*w != (int )*e) {
#line 101
      if ((int )*w > (int )*e) {
#line 103
        newval = (int )*w - ticks;
#line 104
        if (newval < (int )*e) {
#line 105
          *w = *e;
        } else {
#line 107
          *w = (byte )newval;
        }
#line 108
        changed = (boolean )1;
      } else
#line 110
      if ((int )*w < (int )*e) {
#line 112
        newval = (int )*w + ticks;
#line 113
        if (newval > (int )*e) {
#line 114
          *w = *e;
        } else {
#line 116
          *w = (byte )newval;
        }
#line 117
        changed = (boolean )1;
      }
    }
#line 120
    w ++;
#line 121
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (! changed);
}
}
#line 128 "f_wipe.c"
int wipe_exitColorXForm(int width , int height , int ticks ) 
{ 


  {
#line 134
  return (0);
}
}
#line 138 "f_wipe.c"
static int *y  ;
#line 140 "f_wipe.c"
int wipe_initMelt(int width , int height , int ticks ) 
{ 
  int i ;
  int r ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 149
  memcpy((void * __restrict  )wipe_scr, (void const   * __restrict  )wipe_scr_start,
         (size_t )(width * height));
#line 153
  wipe_shittyColMajorXform((short *)wipe_scr_start, width / 2, height);
#line 154
  wipe_shittyColMajorXform((short *)wipe_scr_end, width / 2, height);
#line 158
  tmp = Z_Malloc((int )((unsigned long )width * sizeof(int )), 1, (void *)0);
#line 158
  y = (int *)tmp;
#line 159
  tmp___0 = M_Random();
#line 159
  *(y + 0) = - (tmp___0 % 16);
#line 160
  i = 1;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (i < width)) {
#line 160
      goto while_break;
    }
#line 162
    tmp___1 = M_Random();
#line 162
    r = tmp___1 % 3 - 1;
#line 163
    *(y + i) = *(y + (i - 1)) + r;
#line 164
    if (*(y + i) > 0) {
#line 164
      *(y + i) = 0;
    } else
#line 165
    if (*(y + i) == -16) {
#line 165
      *(y + i) = -15;
    }
#line 160
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return (0);
}
}
#line 171 "f_wipe.c"
int wipe_doMelt(int width , int height , int ticks ) 
{ 
  int i ;
  int j ;
  int dy ;
  int idx ;
  short *s ;
  short *d ;
  boolean done ;
  short *tmp ;
  short *tmp___0 ;
  int tmp___1 ;

  {
#line 184
  done = (boolean )1;
#line 186
  width /= 2;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    tmp___1 = ticks;
#line 188
    ticks --;
#line 188
    if (! tmp___1) {
#line 188
      goto while_break;
    }
#line 190
    i = 0;
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! (i < width)) {
#line 190
        goto while_break___0;
      }
#line 192
      if (*(y + i) < 0) {
#line 194
        (*(y + i)) ++;
#line 194
        done = (boolean )0;
      } else
#line 196
      if (*(y + i) < height) {
#line 198
        if (*(y + i) < 16) {
#line 198
          dy = *(y + i) + 1;
        } else {
#line 198
          dy = 8;
        }
#line 199
        if (*(y + i) + dy >= height) {
#line 199
          dy = height - *(y + i);
        }
#line 200
        s = (short *)wipe_scr_end + (i * height + *(y + i));
#line 201
        d = (short *)wipe_scr + (*(y + i) * width + i);
#line 202
        idx = 0;
#line 203
        j = dy;
        {
#line 203
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 203
          if (! j) {
#line 203
            goto while_break___1;
          }
#line 205
          tmp = s;
#line 205
          s ++;
#line 205
          *(d + idx) = *tmp;
#line 206
          idx += width;
#line 203
          j --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 208
        *(y + i) += dy;
#line 209
        s = (short *)wipe_scr_start + i * height;
#line 210
        d = (short *)wipe_scr + (*(y + i) * width + i);
#line 211
        idx = 0;
#line 212
        j = height - *(y + i);
        {
#line 212
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 212
          if (! j) {
#line 212
            goto while_break___2;
          }
#line 214
          tmp___0 = s;
#line 214
          s ++;
#line 214
          *(d + idx) = *tmp___0;
#line 215
          idx += width;
#line 212
          j --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 217
        done = (boolean )0;
      }
#line 190
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((int )done);
}
}
#line 226 "f_wipe.c"
int wipe_exitMelt(int width , int height , int ticks ) 
{ 


  {
#line 232
  Z_Free((void *)y);
#line 233
  return (0);
}
}
#line 236 "f_wipe.c"
int wipe_StartScreen(int x___0 , int y___1 , int width , int height ) 
{ 


  {
#line 243
  wipe_scr_start = screens[2];
#line 244
  I_ReadScreen(wipe_scr_start);
#line 245
  return (0);
}
}
#line 248 "f_wipe.c"
int wipe_EndScreen(int x___0 , int y___1 , int width , int height ) 
{ 


  {
#line 255
  wipe_scr_end = screens[3];
#line 256
  I_ReadScreen(wipe_scr_end);
#line 257
  V_DrawBlock(x___0, y___1, 0, width, height, wipe_scr_start);
#line 258
  return (0);
}
}
#line 271 "f_wipe.c"
static int (*wipes[6])(int  , int  , int  )  = {      & wipe_initColorXForm,      & wipe_doColorXForm,      & wipe_exitColorXForm,      & wipe_initMelt, 
        & wipe_doMelt,      & wipe_exitMelt};
#line 261 "f_wipe.c"
int wipe_ScreenWipe(int wipeno , int x___0 , int y___1 , int width , int height ,
                    int ticks ) 
{ 
  int rc ;

  {
#line 280
  if (! go) {
#line 282
    go = (boolean )1;
#line 284
    wipe_scr = screens[0];
#line 285
    (*(wipes[wipeno * 3]))(width, height, ticks);
  }
#line 289
  V_MarkRect(0, 0, width, height);
#line 290
  rc = (*(wipes[wipeno * 3 + 1]))(width, height, ticks);
#line 294
  if (rc) {
#line 296
    go = (boolean )0;
#line 297
    (*(wipes[wipeno * 3 + 2]))(width, height, ticks);
  }
#line 300
  return (! go);
}
}
#line 28 "d_main.c"
static char const   rcsid___9[49]  = 
#line 28 "d_main.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'d',      (char const   )'_',      (char const   )'m', 
        (char const   )'a',      (char const   )'i',      (char const   )'n',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'8',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'0',      (char const   )'9',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 205 "/usr/include/sys/stat.h"
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   *__file ,
                                                               struct stat *__buf )  __attribute__((__nothrow__)) ;
#line 210
extern int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd , struct stat *__buf )  __attribute__((__nothrow__)) ;
#line 264
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd , char const   *__file ,
                                                                  struct stat *__buf ,
                                                                  int __flag )  __attribute__((__nothrow__)) ;
#line 313
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   *__file ,
                                                                struct stat *__buf )  __attribute__((__nothrow__)) ;
#line 352
extern int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                              __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 359
extern int ( __attribute__((__nonnull__(1), __leaf__)) lchmod)(char const   *__file ,
                                                               __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 365
extern int ( __attribute__((__leaf__)) fchmod)(int __fd , __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 371
extern int ( __attribute__((__nonnull__(2), __leaf__)) fchmodat)(int __fd , char const   *__file ,
                                                                 __mode_t __mode ,
                                                                 int __flag )  __attribute__((__nothrow__)) ;
#line 380
extern __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask )  __attribute__((__nothrow__)) ;
#line 389
extern int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                              __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 396
extern int ( __attribute__((__nonnull__(2), __leaf__)) mkdirat)(int __fd , char const   *__path ,
                                                                __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 404
extern int ( __attribute__((__nonnull__(1), __leaf__)) mknod)(char const   *__path ,
                                                              __mode_t __mode , __dev_t __dev )  __attribute__((__nothrow__)) ;
#line 411
extern int ( __attribute__((__nonnull__(2), __leaf__)) mknodat)(int __fd , char const   *__path ,
                                                                __mode_t __mode ,
                                                                __dev_t __dev )  __attribute__((__nothrow__)) ;
#line 418
extern int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const   *__path ,
                                                               __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 425
extern int ( __attribute__((__nonnull__(2), __leaf__)) mkfifoat)(int __fd , char const   *__path ,
                                                                 __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 433
extern int ( __attribute__((__nonnull__(2), __leaf__)) utimensat)(int __fd , char const   *__path ,
                                                                  struct timespec  const  *__times ,
                                                                  int __flags )  __attribute__((__nothrow__)) ;
#line 452
extern int ( __attribute__((__leaf__)) futimens)(int __fd , struct timespec  const  *__times )  __attribute__((__nothrow__)) ;
#line 49 "doomstat.h"
boolean nomonsters  ;
#line 50 "doomstat.h"
boolean respawnparm  ;
#line 51 "doomstat.h"
boolean fastparm  ;
#line 53 "doomstat.h"
boolean devparm  ;
#line 77 "doomstat.h"
skill_t startskill  ;
#line 78 "doomstat.h"
int startepisode  ;
#line 79 "doomstat.h"
int startmap  ;
#line 81 "doomstat.h"
boolean autostart  ;
#line 244 "doomstat.h"
char basedefault[1024]  ;
#line 245 "doomstat.h"
FILE *debugfile  ;
#line 110 "d_event.h"
event_t events[64]  ;
#line 111 "d_event.h"
int eventhead  ;
#line 112 "d_event.h"
int eventtail  ;
#line 38 "m_menu.h"
boolean M_Responder(event_t *ev ) ;
#line 43
void M_Ticker(void) ;
#line 47
void M_Drawer(void) ;
#line 51
void M_Init(void) ;
#line 55
void M_StartControlPanel(void) ;
#line 40 "wi_stuff.h"
void WI_Ticker(void) ;
#line 44
void WI_Drawer(void) ;
#line 47
void WI_Start(wbstartstruct_t *wbstartstruct ) ;
#line 42 "st_stuff.h"
boolean ST_Responder(event_t *ev ) ;
#line 45
void ST_Ticker(void) ;
#line 48
void ST_Drawer(boolean fullscreen___0 , boolean refresh ) ;
#line 51
void ST_Start(void) ;
#line 54
void ST_Init(void) ;
#line 32 "am_map.h"
boolean AM_Responder(event_t *ev ) ;
#line 35
void AM_Ticker(void) ;
#line 39
void AM_Drawer(void) ;
#line 43
void AM_Stop(void) ;
#line 33 "p_setup.h"
void P_SetupLevel(int episode , int map , int playermask , skill_t skill ) ;
#line 41
void P_Init(void) ;
#line 38 "r_main.h"
fixed_t viewcos ;
#line 39
fixed_t viewsin ;
#line 48
int centerx ;
#line 49
int centery ;
#line 51
fixed_t centerxfrac ;
#line 52
fixed_t centeryfrac ;
#line 53
fixed_t projection ;
#line 55
int validcount ;
#line 57
int linecount ;
#line 58
int loopcount ;
#line 77
lighttable_t *scalelight[16][48] ;
#line 78
lighttable_t *scalelightfixed[48] ;
#line 79
lighttable_t *zlight[16][128] ;
#line 81
int extralight ;
#line 82
lighttable_t *fixedcolormap ;
#line 93
int detailshift ;
#line 100
void (*colfunc)(void) ;
#line 101
void (*basecolfunc)(void) ;
#line 102
void (*fuzzcolfunc)(void) ;
#line 104
void (*spanfunc)(void) ;
#line 109
int R_PointOnSide(fixed_t x___0 , fixed_t y___1 , node_t *node ) ;
#line 115
int R_PointOnSegSide(fixed_t x___0 , fixed_t y___1 , seg_t *line ) ;
#line 121
angle_t R_PointToAngle(fixed_t x___0 , fixed_t y___1 ) ;
#line 126
angle_t R_PointToAngle2(fixed_t x1 , fixed_t y1___0 , fixed_t x2 , fixed_t y2 ) ;
#line 133
fixed_t R_PointToDist(fixed_t x___0 , fixed_t y___1 ) ;
#line 139
fixed_t R_ScaleFromGlobalAngle(angle_t visangle ) ;
#line 141
subsector_t *R_PointInSubsector(fixed_t x___0 , fixed_t y___1 ) ;
#line 146
void R_AddPointToBox(int x___0 , int y___1 , fixed_t *box ) ;
#line 159
void R_RenderPlayerView(player_t *player ) ;
#line 162
void R_Init(void) ;
#line 165
void R_SetViewSize(int blocks , int detail ) ;
#line 31 "r_bsp.h"
seg_t *curline ;
#line 32
side_t *sidedef ;
#line 33
line_t *linedef ;
#line 34
sector_t *frontsector ;
#line 35
sector_t *backsector ;
#line 37
int rw_x ;
#line 38
int rw_stopx ;
#line 40
boolean segtextured ;
#line 43
boolean markfloor ;
#line 44
boolean markceiling ;
#line 46
extern boolean skymap ;
#line 48
drawseg_t drawsegs[256] ;
#line 49
drawseg_t *ds_p ;
#line 51
extern lighttable_t **hscalelight ;
#line 52
extern lighttable_t **vscalelight ;
#line 53
extern lighttable_t **dscalelight ;
#line 60
void R_ClearClipSegs(void) ;
#line 61
void R_ClearDrawSegs(void) ;
#line 64
void R_RenderBSPNode(int bspnum ) ;
#line 32 "r_segs.h"
void R_RenderMaskedSegRange(drawseg_t *ds , int x1 , int x2 ) ;
#line 35 "r_plane.h"
short *lastopening ;
#line 40
void (*floorfunc)(int top , int bottom ) ;
#line 41
extern void (*ceilingfunc_t)(int top , int bottom ) ;
#line 43
short floorclip[320] ;
#line 44
short ceilingclip[320] ;
#line 46
fixed_t yslope[200] ;
#line 47
fixed_t distscale[320] ;
#line 49
void R_InitPlanes(void) ;
#line 50
void R_ClearPlanes(void) ;
#line 52
void R_MapPlane(int y___1 , int x1 , int x2 ) ;
#line 58
void R_MakeSpans(int x___0 , int t1 , int b1 , int t2 , int b2 ) ;
#line 66
void R_DrawPlanes(void) ;
#line 68
visplane_t *R_FindPlane(fixed_t height , int picnum , int lightlevel ) ;
#line 74
visplane_t *R_CheckPlane(visplane_t *pl , int start , int stop ) ;
#line 33 "r_things.h"
vissprite_t vissprites[128] ;
#line 34
vissprite_t *vissprite_p ;
#line 35
vissprite_t vsprsortedhead ;
#line 39
short negonearray[320] ;
#line 40
short screenheightarray[320] ;
#line 43
short *mfloorclip ;
#line 44
short *mceilingclip ;
#line 45
fixed_t spryscale ;
#line 46
fixed_t sprtopscreen ;
#line 48
fixed_t pspritescale ;
#line 49
fixed_t pspriteiscale ;
#line 52
void R_DrawMaskedColumn(column_t *column ) ;
#line 55
void R_SortVisSprites(void) ;
#line 57
void R_AddSprites(sector_t *sec ) ;
#line 58
extern void R_AddPSprites(void) ;
#line 59
extern void R_DrawSprites(void) ;
#line 60
void R_InitSprites(char **namelist ) ;
#line 61
void R_ClearSprites(void) ;
#line 62
void R_DrawMasked(void) ;
#line 64
extern void R_ClipVisSprite(vissprite_t *vis , int xl , int xh ) ;
#line 32 "r_draw.h"
lighttable_t *dc_colormap ;
#line 33
int dc_x ;
#line 34
int dc_yl ;
#line 35
int dc_yh ;
#line 36
fixed_t dc_iscale ;
#line 37
fixed_t dc_texturemid ;
#line 40
byte *dc_source ;
#line 46
void R_DrawColumn(void) ;
#line 47
void R_DrawColumnLow(void) ;
#line 50
void R_DrawFuzzColumn(void) ;
#line 51
extern void R_DrawFuzzColumnLow(void) ;
#line 56
void R_DrawTranslatedColumn(void) ;
#line 57
extern void R_DrawTranslatedColumnLow(void) ;
#line 59
void R_VideoErase(unsigned int ofs , int count ) ;
#line 64
int ds_y ;
#line 65
int ds_x1 ;
#line 66
int ds_x2 ;
#line 68
lighttable_t *ds_colormap ;
#line 70
fixed_t ds_xfrac ;
#line 71
fixed_t ds_yfrac ;
#line 72
fixed_t ds_xstep ;
#line 73
fixed_t ds_ystep ;
#line 76
byte *ds_source ;
#line 78
byte *translationtables ;
#line 79
byte *dc_translation ;
#line 84
void R_DrawSpan(void) ;
#line 87
void R_DrawSpanLow(void) ;
#line 90
void R_InitBuffer(int width , int height ) ;
#line 98
void R_InitTranslationTables(void) ;
#line 103
void R_FillBackScreen(void) ;
#line 106
void R_DrawViewBorder(void) ;
#line 37 "d_main.h"
char *wadfiles[20]  ;
#line 89 "d_main.c"
void D_DoomLoop(void) ;
#line 100 "d_main.c"
boolean drone  ;
#line 102 "d_main.c"
boolean singletics  =    (boolean )0;
#line 110
boolean inhelpscreens ;
#line 119 "d_main.c"
boolean advancedemo  ;
#line 124 "d_main.c"
char wadfile[1024]  ;
#line 125 "d_main.c"
char mapdir[1024]  ;
#line 129
void D_CheckNetGame(void) ;
#line 130
void D_ProcessEvents(void) ;
#line 131
void G_BuildTiccmd(ticcmd_t *cmd ) ;
#line 132
void D_DoAdvanceDemo(void) ;
#line 150 "d_main.c"
void D_PostEvent(event_t *ev ) 
{ 


  {
#line 152
  events[eventhead] = *ev;
#line 153
  eventhead ++;
#line 153
  eventhead &= 63;
#line 154
  return;
}
}
#line 161 "d_main.c"
void D_ProcessEvents(void) 
{ 
  event_t *ev ;
  int tmp ;
  boolean tmp___0 ;

  {
#line 166
  if ((unsigned int )gamemode == 2U) {
#line 166
    tmp = W_CheckNumForName("map01");
#line 166
    if (tmp < 0) {
#line 168
      return;
    } else {
#line 166
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (eventtail != eventhead)) {
#line 170
      goto while_break;
    }
#line 172
    ev = & events[eventtail];
#line 173
    tmp___0 = M_Responder(ev);
#line 173
    if (tmp___0) {
#line 174
      goto __Cont;
    }
#line 175
    G_Responder(ev);
    __Cont: /* CIL Label */ 
#line 170
    eventtail ++;
#line 170
    eventtail &= 63;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return;
}
}
#line 188 "d_main.c"
gamestate_t wipegamestate  =    (gamestate_t )3;
#line 189
boolean setsizeneeded ;
#line 190
int showMessages ;
#line 191
void R_ExecuteSetViewSize(void) ;
#line 195
void D_Display(void) ;
#line 195 "d_main.c"
static boolean viewactivestate  =    (boolean )0;
#line 196 "d_main.c"
static boolean menuactivestate  =    (boolean )0;
#line 197 "d_main.c"
static boolean inhelpscreensstate  =    (boolean )0;
#line 198 "d_main.c"
static boolean fullscreen  =    (boolean )0;
#line 199 "d_main.c"
static gamestate_t oldgamestate  =    (gamestate_t )-1;
#line 200 "d_main.c"
static int borderdrawcount  ;
#line 193 "d_main.c"
void D_Display(void) 
{ 
  int nowtime ;
  int tics ;
  int wipestart ;
  int y___1 ;
  boolean done ;
  boolean wipe ;
  boolean redrawsbar ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 209
  if (nodrawers) {
#line 210
    return;
  }
#line 212
  redrawsbar = (boolean )0;
#line 215
  if (setsizeneeded) {
#line 217
    R_ExecuteSetViewSize();
#line 218
    oldgamestate = (gamestate_t )-1;
#line 219
    borderdrawcount = 3;
  }
#line 223
  if ((unsigned int )gamestate != (unsigned int )wipegamestate) {
#line 225
    wipe = (boolean )1;
#line 226
    wipe_StartScreen(0, 0, 320, 200);
  } else {
#line 229
    wipe = (boolean )0;
  }
#line 231
  if ((unsigned int )gamestate == 0U) {
#line 231
    if (gametic) {
#line 232
      HU_Erase();
    } else {
#line 231
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  {
#line 237
  if ((unsigned int )gamestate == 0U) {
#line 237
    goto case_0;
  }
#line 250
  if ((unsigned int )gamestate == 1U) {
#line 250
    goto case_1;
  }
#line 254
  if ((unsigned int )gamestate == 2U) {
#line 254
    goto case_2;
  }
#line 258
  if ((unsigned int )gamestate == 3U) {
#line 258
    goto case_3;
  }
#line 235
  goto switch_break;
  case_0: /* CIL Label */ 
#line 238
  if (! gametic) {
#line 239
    goto switch_break;
  }
#line 240
  if (automapactive) {
#line 241
    AM_Drawer();
  }
#line 242
  if (wipe) {
#line 242
    goto _L___0;
  } else
#line 242
  if (viewheight != 200) {
#line 242
    if (fullscreen) {
      _L___0: /* CIL Label */ 
#line 243
      redrawsbar = (boolean )1;
    } else {
#line 242
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 244
  if (inhelpscreensstate) {
#line 244
    if (! inhelpscreens) {
#line 245
      redrawsbar = (boolean )1;
    } else {
#line 244
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ ;
  }
#line 246
  ST_Drawer((boolean )(viewheight == 200), redrawsbar);
#line 247
  fullscreen = (boolean )(viewheight == 200);
#line 248
  goto switch_break;
  case_1: /* CIL Label */ 
#line 251
  WI_Drawer();
#line 252
  goto switch_break;
  case_2: /* CIL Label */ 
#line 255
  F_Drawer();
#line 256
  goto switch_break;
  case_3: /* CIL Label */ 
#line 259
  D_PageDrawer();
#line 260
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  I_UpdateNoBlit();
#line 267
  if ((unsigned int )gamestate == 0U) {
#line 267
    if (! automapactive) {
#line 267
      if (gametic) {
#line 268
        R_RenderPlayerView(& players[displayplayer]);
      } else {
#line 267
        goto _L___4;
      }
    } else {
#line 267
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
    _L___3: /* CIL Label */ ;
  }
#line 270
  if ((unsigned int )gamestate == 0U) {
#line 270
    if (gametic) {
#line 271
      HU_Drawer();
    } else {
#line 270
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ ;
  }
#line 274
  if ((unsigned int )gamestate != (unsigned int )oldgamestate) {
#line 274
    if ((unsigned int )gamestate != 0U) {
#line 275
      tmp = W_CacheLumpName("PLAYPAL", 101);
#line 275
      I_SetPalette((byte *)tmp);
    } else {
#line 274
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ ;
  }
#line 278
  if ((unsigned int )gamestate == 0U) {
#line 278
    if ((unsigned int )oldgamestate != 0U) {
#line 280
      viewactivestate = (boolean )0;
#line 281
      R_FillBackScreen();
    } else {
#line 278
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ ;
  }
#line 285
  if ((unsigned int )gamestate == 0U) {
#line 285
    if (! automapactive) {
#line 285
      if (scaledviewwidth != 320) {
#line 287
        if (menuactive) {
#line 287
          goto _L___9;
        } else
#line 287
        if (menuactivestate) {
          _L___9: /* CIL Label */ 
#line 287
          goto _L___8;
        } else
#line 287
        if (! viewactivestate) {
          _L___8: /* CIL Label */ 
#line 288
          borderdrawcount = 3;
        }
#line 289
        if (borderdrawcount) {
#line 291
          R_DrawViewBorder();
#line 292
          borderdrawcount --;
        }
      } else {
#line 285
        goto _L___11;
      }
    } else {
#line 285
      goto _L___11;
    }
  } else {
    _L___11: /* CIL Label */ 
    _L___10: /* CIL Label */ ;
  }
#line 297
  menuactivestate = menuactive;
#line 298
  viewactivestate = viewactive;
#line 299
  inhelpscreensstate = inhelpscreens;
#line 300
  wipegamestate = gamestate;
#line 300
  oldgamestate = wipegamestate;
#line 303
  if (paused) {
#line 305
    if (automapactive) {
#line 306
      y___1 = 4;
    } else {
#line 308
      y___1 = viewwindowy + 4;
    }
#line 309
    tmp___0 = W_CacheLumpName("M_PAUSE", 101);
#line 309
    V_DrawPatchDirect(viewwindowx + (scaledviewwidth - 68) / 2, y___1, 0, (patch_t *)tmp___0);
  }
#line 315
  M_Drawer();
#line 316
  NetUpdate();
#line 320
  if (! wipe) {
#line 322
    I_FinishUpdate();
#line 323
    return;
  }
#line 327
  wipe_EndScreen(0, 0, 320, 200);
#line 329
  tmp___1 = I_GetTime();
#line 329
  wipestart = tmp___1 - 1;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 335
      nowtime = I_GetTime();
#line 336
      tics = nowtime - wipestart;
#line 333
      if (! (! tics)) {
#line 333
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 338
    wipestart = nowtime;
#line 339
    tmp___2 = wipe_ScreenWipe(1, 0, 0, 320, 200, tics);
#line 339
    done = (boolean )tmp___2;
#line 341
    I_UpdateNoBlit();
#line 342
    M_Drawer();
#line 343
    I_FinishUpdate();
#line 331
    if (! (! done)) {
#line 331
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  return;
}
}
#line 354 "d_main.c"
void D_DoomLoop(void) 
{ 
  char filename[20] ;
  int tmp ;

  {
#line 356
  if (demorecording) {
#line 357
    G_BeginRecording();
  }
#line 359
  tmp = M_CheckParm("-debugfile");
#line 359
  if (tmp) {
#line 362
    sprintf((char * __restrict  )(filename), (char const   * __restrict  )"debug%i.txt",
            consoleplayer);
#line 363
    printf((char const   * __restrict  )"debug output to: %s\n", filename);
#line 364
    debugfile = fopen((char const   * __restrict  )(filename), (char const   * __restrict  )"w");
  }
#line 367
  I_InitGraphics();
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! 1) {
#line 369
      goto while_break;
    }
#line 372
    I_StartFrame();
#line 375
    if (singletics) {
#line 377
      I_StartTic();
#line 378
      D_ProcessEvents();
#line 379
      G_BuildTiccmd(& netcmds[consoleplayer][maketic % 12]);
#line 380
      if (advancedemo) {
#line 381
        D_DoAdvanceDemo();
      }
#line 382
      M_Ticker();
#line 383
      G_Ticker();
#line 384
      gametic ++;
#line 385
      maketic ++;
    } else {
#line 389
      TryRunTics();
    }
#line 392
    S_UpdateSounds((void *)players[consoleplayer].mo);
#line 395
    D_Display();
#line 404
    I_SubmitSound();
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 414 "d_main.c"
int demosequence  ;
#line 415 "d_main.c"
int pagetic  ;
#line 416 "d_main.c"
char *pagename  ;
#line 423 "d_main.c"
void D_PageTicker(void) 
{ 


  {
#line 425
  pagetic --;
#line 425
  if (pagetic < 0) {
#line 426
    D_AdvanceDemo();
  }
#line 427
  return;
}
}
#line 434 "d_main.c"
void D_PageDrawer(void) 
{ 
  void *tmp ;

  {
#line 436
  tmp = W_CacheLumpName(pagename, 101);
#line 436
  V_DrawPatch(0, 0, 0, (patch_t *)tmp);
#line 437
  return;
}
}
#line 444 "d_main.c"
void D_AdvanceDemo(void) 
{ 


  {
#line 446
  advancedemo = (boolean )1;
#line 447
  return;
}
}
#line 454 "d_main.c"
void D_DoAdvanceDemo(void) 
{ 


  {
#line 456
  players[consoleplayer].playerstate = (playerstate_t )0;
#line 457
  advancedemo = (boolean )0;
#line 458
  usergame = (boolean )0;
#line 459
  paused = (boolean )0;
#line 460
  gameaction = (gameaction_t )0;
#line 462
  if ((unsigned int )gamemode == 3U) {
#line 463
    demosequence = (demosequence + 1) % 7;
  } else {
#line 465
    demosequence = (demosequence + 1) % 6;
  }
  {
#line 469
  if (demosequence == 0) {
#line 469
    goto case_0;
  }
#line 481
  if (demosequence == 1) {
#line 481
    goto case_1;
  }
#line 484
  if (demosequence == 2) {
#line 484
    goto case_2;
  }
#line 489
  if (demosequence == 3) {
#line 489
    goto case_3;
  }
#line 492
  if (demosequence == 4) {
#line 492
    goto case_4;
  }
#line 510
  if (demosequence == 5) {
#line 510
    goto case_5;
  }
#line 514
  if (demosequence == 6) {
#line 514
    goto case_6;
  }
#line 467
  goto switch_break;
  case_0: /* CIL Label */ 
#line 470
  if ((unsigned int )gamemode == 2U) {
#line 471
    pagetic = 385;
  } else {
#line 473
    pagetic = 170;
  }
#line 474
  gamestate = (gamestate_t )3;
#line 475
  pagename = "TITLEPIC";
#line 476
  if ((unsigned int )gamemode == 2U) {
#line 477
    S_StartMusic(66);
  } else {
#line 479
    S_StartMusic(29);
  }
#line 480
  goto switch_break;
  case_1: /* CIL Label */ 
#line 482
  G_DeferedPlayDemo("demo1");
#line 483
  goto switch_break;
  case_2: /* CIL Label */ 
#line 485
  pagetic = 200;
#line 486
  gamestate = (gamestate_t )3;
#line 487
  pagename = "CREDIT";
#line 488
  goto switch_break;
  case_3: /* CIL Label */ 
#line 490
  G_DeferedPlayDemo("demo2");
#line 491
  goto switch_break;
  case_4: /* CIL Label */ 
#line 493
  gamestate = (gamestate_t )3;
#line 494
  if ((unsigned int )gamemode == 2U) {
#line 496
    pagetic = 385;
#line 497
    pagename = "TITLEPIC";
#line 498
    S_StartMusic(66);
  } else {
#line 502
    pagetic = 200;
#line 504
    if ((unsigned int )gamemode == 3U) {
#line 505
      pagename = "CREDIT";
    } else {
#line 507
      pagename = "HELP2";
    }
  }
#line 509
  goto switch_break;
  case_5: /* CIL Label */ 
#line 511
  G_DeferedPlayDemo("demo3");
#line 512
  goto switch_break;
  case_6: /* CIL Label */ 
#line 515
  G_DeferedPlayDemo("demo4");
#line 516
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 518
  return;
}
}
#line 525 "d_main.c"
void D_StartTitle(void) 
{ 


  {
#line 527
  gameaction = (gameaction_t )0;
#line 528
  demosequence = -1;
#line 529
  D_AdvanceDemo();
#line 530
  return;
}
}
#line 536 "d_main.c"
char title[128]  ;
#line 543 "d_main.c"
void D_AddFile(char *file ) 
{ 
  int numwadfiles ;
  char *newfile ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 548
  numwadfiles = 0;
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 548
    if (! wadfiles[numwadfiles]) {
#line 548
      goto while_break;
    }
#line 548
    numwadfiles ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  tmp = strlen((char const   *)file);
#line 551
  tmp___0 = malloc(tmp + 1U);
#line 551
  newfile = (char *)tmp___0;
#line 552
  strcpy((char * __restrict  )newfile, (char const   * __restrict  )file);
#line 554
  wadfiles[numwadfiles] = newfile;
#line 555
  return;
}
}
#line 563 "d_main.c"
void IdentifyVersion(void) 
{ 
  char *doom1wad ;
  char *doomwad ;
  char *doomuwad ;
  char *doom2wad ;
  char *doom2fwad ;
  char *plutoniawad ;
  char *tntwad ;
  char *home ;
  char *doomwaddir ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 578
  doomwaddir = getenv((char const   *)"DOOMWADDIR");
#line 579
  if (! doomwaddir) {
#line 580
    doomwaddir = ".";
  }
#line 583
  tmp = strlen((char const   *)doomwaddir);
#line 583
  tmp___0 = malloc(((tmp + 1U) + 9U) + 1U);
#line 583
  doom2wad = (char *)tmp___0;
#line 584
  sprintf((char * __restrict  )doom2wad, (char const   * __restrict  )"%s/doom2.wad",
          doomwaddir);
#line 587
  tmp___1 = strlen((char const   *)doomwaddir);
#line 587
  tmp___2 = malloc(((tmp___1 + 1U) + 8U) + 1U);
#line 587
  doomuwad = (char *)tmp___2;
#line 588
  sprintf((char * __restrict  )doomuwad, (char const   * __restrict  )"%s/doomu.wad",
          doomwaddir);
#line 591
  tmp___3 = strlen((char const   *)doomwaddir);
#line 591
  tmp___4 = malloc(((tmp___3 + 1U) + 8U) + 1U);
#line 591
  doomwad = (char *)tmp___4;
#line 592
  sprintf((char * __restrict  )doomwad, (char const   * __restrict  )"%s/doom.wad",
          doomwaddir);
#line 595
  tmp___5 = strlen((char const   *)doomwaddir);
#line 595
  tmp___6 = malloc(((tmp___5 + 1U) + 9U) + 1U);
#line 595
  doom1wad = (char *)tmp___6;
#line 596
  sprintf((char * __restrict  )doom1wad, (char const   * __restrict  )"%s/doom1.wad",
          doomwaddir);
#line 600
  tmp___7 = strlen((char const   *)doomwaddir);
#line 600
  tmp___8 = malloc(((tmp___7 + 1U) + 12U) + 1U);
#line 600
  plutoniawad = (char *)tmp___8;
#line 601
  sprintf((char * __restrict  )plutoniawad, (char const   * __restrict  )"%s/plutonia.wad",
          doomwaddir);
#line 603
  tmp___9 = strlen((char const   *)doomwaddir);
#line 603
  tmp___10 = malloc(((tmp___9 + 1U) + 9U) + 1U);
#line 603
  tntwad = (char *)tmp___10;
#line 604
  sprintf((char * __restrict  )tntwad, (char const   * __restrict  )"%s/tnt.wad",
          doomwaddir);
#line 608
  tmp___11 = strlen((char const   *)doomwaddir);
#line 608
  tmp___12 = malloc(((tmp___11 + 1U) + 10U) + 1U);
#line 608
  doom2fwad = (char *)tmp___12;
#line 609
  sprintf((char * __restrict  )doom2fwad, (char const   * __restrict  )"%s/doom2f.wad",
          doomwaddir);
#line 611
  home = getenv((char const   *)"HOME");
#line 612
  if (! home) {
#line 613
    I_Error("Please set $HOME to your home directory");
  }
#line 614
  sprintf((char * __restrict  )(basedefault), (char const   * __restrict  )"%s/.doomrc",
          home);
#line 617
  tmp___13 = M_CheckParm("-shdev");
#line 617
  if (tmp___13) {
#line 619
    gamemode = (GameMode_t )0;
#line 620
    devparm = (boolean )1;
#line 621
    D_AddFile("devdatadoom1.wad");
#line 622
    D_AddFile("devmapsdata_se/texture1.lmp");
#line 623
    D_AddFile("devmapsdata_se/pnames.lmp");
#line 624
    strcpy((char * __restrict  )(basedefault), (char const   * __restrict  )"devdatadefault.cfg");
#line 625
    return;
  }
#line 628
  tmp___14 = M_CheckParm("-regdev");
#line 628
  if (tmp___14) {
#line 630
    gamemode = (GameMode_t )1;
#line 631
    devparm = (boolean )1;
#line 632
    D_AddFile("devdatadoom.wad");
#line 633
    D_AddFile("devmapsdata_se/texture1.lmp");
#line 634
    D_AddFile("devmapsdata_se/texture2.lmp");
#line 635
    D_AddFile("devmapsdata_se/pnames.lmp");
#line 636
    strcpy((char * __restrict  )(basedefault), (char const   * __restrict  )"devdatadefault.cfg");
#line 637
    return;
  }
#line 640
  tmp___15 = M_CheckParm("-comdev");
#line 640
  if (tmp___15) {
#line 642
    gamemode = (GameMode_t )2;
#line 643
    devparm = (boolean )1;
#line 650
    D_AddFile("devdatadoom2.wad");
#line 652
    D_AddFile("devmapscdata/texture1.lmp");
#line 653
    D_AddFile("devmapscdata/pnames.lmp");
#line 654
    strcpy((char * __restrict  )(basedefault), (char const   * __restrict  )"devdatadefault.cfg");
#line 655
    return;
  }
#line 658
  tmp___16 = access((char const   *)doom2fwad, 4);
#line 658
  if (! tmp___16) {
#line 660
    gamemode = (GameMode_t )2;
#line 663
    language = (Language_t )1;
#line 664
    printf((char const   * __restrict  )"French version\n");
#line 665
    D_AddFile(doom2fwad);
#line 666
    return;
  }
#line 669
  tmp___17 = access((char const   *)doom2wad, 4);
#line 669
  if (! tmp___17) {
#line 671
    gamemode = (GameMode_t )2;
#line 672
    D_AddFile(doom2wad);
#line 673
    return;
  }
#line 676
  tmp___18 = access((char const   *)plutoniawad, 4);
#line 676
  if (! tmp___18) {
#line 678
    gamemode = (GameMode_t )2;
#line 679
    D_AddFile(plutoniawad);
#line 680
    return;
  }
#line 683
  tmp___19 = access((char const   *)tntwad, 4);
#line 683
  if (! tmp___19) {
#line 685
    gamemode = (GameMode_t )2;
#line 686
    D_AddFile(tntwad);
#line 687
    return;
  }
#line 690
  tmp___20 = access((char const   *)doomuwad, 4);
#line 690
  if (! tmp___20) {
#line 692
    gamemode = (GameMode_t )3;
#line 693
    D_AddFile(doomuwad);
#line 694
    return;
  }
#line 697
  tmp___21 = access((char const   *)doomwad, 4);
#line 697
  if (! tmp___21) {
#line 699
    gamemode = (GameMode_t )1;
#line 700
    D_AddFile(doomwad);
#line 701
    return;
  }
#line 704
  tmp___22 = access((char const   *)doom1wad, 4);
#line 704
  if (! tmp___22) {
#line 706
    gamemode = (GameMode_t )0;
#line 707
    D_AddFile(doom1wad);
#line 708
    return;
  }
#line 711
  printf((char const   * __restrict  )"Game mode indeterminate.\n");
#line 712
  gamemode = (GameMode_t )4;
#line 717
  return;
}
}
#line 722 "d_main.c"
void FindResponseFile(void) 
{ 
  int i ;
  FILE *handle ;
  int size ;
  int k ;
  int index___0 ;
  int indexinfile ;
  char *infile ;
  char *file ;
  char *moreargs[20] ;
  char *firstargv ;
  long tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 727
  i = 1;
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 727
    if (! (i < myargc)) {
#line 727
      goto while_break;
    }
#line 728
    if ((int )*(*(myargv + i) + 0) == 64) {
#line 741
      handle = fopen((char const   * __restrict  )(*(myargv + i) + 1), (char const   * __restrict  )"rb");
#line 742
      if (! handle) {
#line 744
        printf((char const   * __restrict  )"\nNo such response file!");
#line 745
        exit(1);
      }
#line 747
      printf((char const   * __restrict  )"Found response file %s!\n", *(myargv + i) + 1);
#line 748
      fseek(handle, 0L, 2);
#line 749
      tmp = ftell(handle);
#line 749
      size = (int )tmp;
#line 750
      fseek(handle, 0L, 0);
#line 751
      tmp___0 = malloc((size_t )size);
#line 751
      file = (char *)tmp___0;
#line 752
      fread((void * __restrict  )file, (size_t )size, (size_t )1, (FILE * __restrict  )handle);
#line 753
      fclose(handle);
#line 756
      index___0 = 0;
#line 756
      k = i + 1;
      {
#line 756
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 756
        if (! (k < myargc)) {
#line 756
          goto while_break___0;
        }
#line 757
        tmp___1 = index___0;
#line 757
        index___0 ++;
#line 757
        moreargs[tmp___1] = *(myargv + k);
#line 756
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 759
      firstargv = *(myargv + 0);
#line 760
      tmp___2 = malloc((size_t )(sizeof(char *) * 100UL));
#line 760
      myargv = (char **)tmp___2;
#line 761
      memset((void *)myargv, 0, (size_t )(sizeof(char *) * 100UL));
#line 762
      *(myargv + 0) = firstargv;
#line 764
      infile = file;
#line 765
      k = 0;
#line 765
      indexinfile = k;
#line 766
      indexinfile ++;
      {
#line 767
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 769
        tmp___3 = indexinfile;
#line 769
        indexinfile ++;
#line 769
        *(myargv + tmp___3) = infile + k;
        {
#line 770
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 770
          if (k < size) {
#line 770
            if ((int )*(infile + k) >= 33) {
#line 770
              if (! ((int )*(infile + k) <= 122)) {
#line 770
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
#line 770
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 770
            goto while_break___2;
          }
#line 772
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 773
        *(infile + k) = (char)0;
        {
#line 774
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 774
          if (k < size) {
#line 774
            if ((int )*(infile + k) <= 32) {
#line 774
              goto _L___2;
            } else
#line 774
            if ((int )*(infile + k) > 122) {
              _L___2: /* CIL Label */ ;
            } else {
#line 774
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 774
            goto while_break___3;
          }
#line 776
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 767
        if (! (k < size)) {
#line 767
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 779
      k = 0;
      {
#line 779
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 779
        if (! (k < index___0)) {
#line 779
          goto while_break___4;
        }
#line 780
        tmp___4 = indexinfile;
#line 780
        indexinfile ++;
#line 780
        *(myargv + tmp___4) = moreargs[k];
#line 779
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 781
      myargc = indexinfile;
#line 784
      printf((char const   * __restrict  )"%d command-line args:\n", myargc);
#line 785
      k = 1;
      {
#line 785
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 785
        if (! (k < myargc)) {
#line 785
          goto while_break___5;
        }
#line 786
        printf((char const   * __restrict  )"%s\n", *(myargv + k));
#line 785
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 788
      goto while_break;
    }
#line 727
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  return;
}
}
#line 888
int forwardmove[2] ;
#line 889
int sidemove[2] ;
#line 1120
void *statcopy ;
#line 796 "d_main.c"
void D_DoomMain(void) 
{ 
  int p___0 ;
  char file[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int scale ;
  int time___1 ;
  char name[23][8] ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  int i ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 801
  FindResponseFile();
#line 803
  IdentifyVersion();
#line 805
  setbuf((FILE * __restrict  )stdout, (char * __restrict  )((void *)0));
#line 806
  modifiedgame = (boolean )0;
#line 808
  tmp = M_CheckParm("-nomonsters");
#line 808
  nomonsters = (boolean )tmp;
#line 809
  tmp___0 = M_CheckParm("-respawn");
#line 809
  respawnparm = (boolean )tmp___0;
#line 810
  tmp___1 = M_CheckParm("-fast");
#line 810
  fastparm = (boolean )tmp___1;
#line 811
  tmp___2 = M_CheckParm("-devparm");
#line 811
  devparm = (boolean )tmp___2;
#line 812
  tmp___4 = M_CheckParm("-altdeath");
#line 812
  if (tmp___4) {
#line 813
    deathmatch = (boolean )2;
  } else {
#line 814
    tmp___3 = M_CheckParm("-deathmatch");
#line 814
    if (tmp___3) {
#line 815
      deathmatch = (boolean )1;
    }
  }
  {
#line 819
  if ((unsigned int )gamemode == 3U) {
#line 819
    goto case_3;
  }
#line 826
  if ((unsigned int )gamemode == 0U) {
#line 826
    goto case_0;
  }
#line 833
  if ((unsigned int )gamemode == 1U) {
#line 833
    goto case_1;
  }
#line 840
  if ((unsigned int )gamemode == 2U) {
#line 840
    goto case_2;
  }
#line 863
  goto switch_default;
  case_3: /* CIL Label */ 
#line 820
  sprintf((char * __restrict  )(title), (char const   * __restrict  )"                         The Ultimate DOOM Startup v%i.%i                           ",
          1, 10);
#line 825
  goto switch_break;
  case_0: /* CIL Label */ 
#line 827
  sprintf((char * __restrict  )(title), (char const   * __restrict  )"                            DOOM Shareware Startup v%i.%i                           ",
          1, 10);
#line 832
  goto switch_break;
  case_1: /* CIL Label */ 
#line 834
  sprintf((char * __restrict  )(title), (char const   * __restrict  )"                            DOOM Registered Startup v%i.%i                           ",
          1, 10);
#line 839
  goto switch_break;
  case_2: /* CIL Label */ 
#line 841
  sprintf((char * __restrict  )(title), (char const   * __restrict  )"                         DOOM 2: Hell on Earth v%i.%i                           ",
          1, 10);
#line 846
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 864
  sprintf((char * __restrict  )(title), (char const   * __restrict  )"                     Public DOOM - v%i.%i                           ",
          1, 10);
#line 869
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 872
  printf((char const   * __restrict  )"%s\n", title);
#line 874
  if (devparm) {
#line 875
    printf((char const   * __restrict  )"Development mode ON.\n");
  }
#line 877
  tmp___5 = M_CheckParm("-cdrom");
#line 877
  if (tmp___5) {
#line 879
    printf((char const   * __restrict  )"CD-ROM Version: default.cfg from c:\\doomdata\n");
#line 880
    mkdir((char const   *)"c:\\doomdata", (__mode_t )0);
#line 881
    strcpy((char * __restrict  )(basedefault), (char const   * __restrict  )"c:/doomdata/default.cfg");
  }
#line 885
  p___0 = M_CheckParm("-turbo");
#line 885
  if (p___0) {
#line 887
    scale = 200;
#line 891
    if (p___0 < myargc - 1) {
#line 892
      scale = atoi((char const   *)*(myargv + (p___0 + 1)));
    }
#line 893
    if (scale < 10) {
#line 894
      scale = 10;
    }
#line 895
    if (scale > 400) {
#line 896
      scale = 400;
    }
#line 897
    printf((char const   * __restrict  )"turbo scale: %i%%\n", scale);
#line 898
    forwardmove[0] = (forwardmove[0] * scale) / 100;
#line 899
    forwardmove[1] = (forwardmove[1] * scale) / 100;
#line 900
    sidemove[0] = (sidemove[0] * scale) / 100;
#line 901
    sidemove[1] = (sidemove[1] * scale) / 100;
  }
#line 909
  p___0 = M_CheckParm("-wart");
#line 910
  if (p___0) {
#line 912
    *(*(myargv + p___0) + 4) = (char )'p';
    {
#line 919
    if ((unsigned int )gamemode == 1U) {
#line 919
      goto case_1___0;
    }
#line 919
    if ((unsigned int )gamemode == 3U) {
#line 919
      goto case_1___0;
    }
#line 919
    if ((unsigned int )gamemode == 0U) {
#line 919
      goto case_1___0;
    }
#line 927
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 920
    sprintf((char * __restrict  )(file), (char const   * __restrict  )"~devmapsE%cM%c.wad",
            (int )*(*(myargv + (p___0 + 1)) + 0), (int )*(*(myargv + (p___0 + 2)) + 0));
#line 922
    printf((char const   * __restrict  )"Warping to Episode %s, Map %s.\n", *(myargv + (p___0 + 1)),
           *(myargv + (p___0 + 2)));
#line 924
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
#line 928
    p___0 = atoi((char const   *)*(myargv + (p___0 + 1)));
#line 929
    if (p___0 < 10) {
#line 930
      sprintf((char * __restrict  )(file), (char const   * __restrict  )"~devmapscdata/map0%i.wad",
              p___0);
    } else {
#line 932
      sprintf((char * __restrict  )(file), (char const   * __restrict  )"~devmapscdata/map%i.wad",
              p___0);
    }
#line 933
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 935
    D_AddFile(file);
  }
#line 938
  p___0 = M_CheckParm("-file");
#line 939
  if (p___0) {
#line 943
    modifiedgame = (boolean )1;
    {
#line 944
    while (1) {
      while_continue: /* CIL Label */ ;
#line 944
      p___0 ++;
#line 944
      if (p___0 != myargc) {
#line 944
        if (! ((int )*(*(myargv + p___0) + 0) != 45)) {
#line 944
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 944
        goto while_break;
      }
#line 945
      D_AddFile(*(myargv + p___0));
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 948
  p___0 = M_CheckParm("-playdemo");
#line 950
  if (! p___0) {
#line 951
    p___0 = M_CheckParm("-timedemo");
  }
#line 953
  if (p___0) {
#line 953
    if (p___0 < myargc - 1) {
#line 955
      sprintf((char * __restrict  )(file), (char const   * __restrict  )"%s.lmp",
              *(myargv + (p___0 + 1)));
#line 956
      D_AddFile(file);
#line 957
      printf((char const   * __restrict  )"Playing demo %s.lmp.\n", *(myargv + (p___0 + 1)));
    } else {
#line 953
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 961
  startskill = (skill_t )2;
#line 962
  startepisode = 1;
#line 963
  startmap = 1;
#line 964
  autostart = (boolean )0;
#line 967
  p___0 = M_CheckParm("-skill");
#line 968
  if (p___0) {
#line 968
    if (p___0 < myargc - 1) {
#line 970
      startskill = (skill_t )((int )*(*(myargv + (p___0 + 1)) + 0) - 49);
#line 971
      autostart = (boolean )1;
    } else {
#line 968
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 974
  p___0 = M_CheckParm("-episode");
#line 975
  if (p___0) {
#line 975
    if (p___0 < myargc - 1) {
#line 977
      startepisode = (int )*(*(myargv + (p___0 + 1)) + 0) - 48;
#line 978
      startmap = 1;
#line 979
      autostart = (boolean )1;
    } else {
#line 975
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ ;
  }
#line 982
  p___0 = M_CheckParm("-timer");
#line 983
  if (p___0) {
#line 983
    if (p___0 < myargc - 1) {
#line 983
      if (deathmatch) {
#line 986
        time___1 = atoi((char const   *)*(myargv + (p___0 + 1)));
#line 987
        printf((char const   * __restrict  )"Levels will end after %d minute", time___1);
#line 988
        if (time___1 > 1) {
#line 989
          printf((char const   * __restrict  )"s");
        }
#line 990
        printf((char const   * __restrict  )".\n");
      } else {
#line 983
        goto _L___4;
      }
    } else {
#line 983
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
    _L___3: /* CIL Label */ ;
  }
#line 993
  p___0 = M_CheckParm("-avg");
#line 994
  if (p___0) {
#line 994
    if (p___0 < myargc - 1) {
#line 994
      if (deathmatch) {
#line 995
        printf((char const   * __restrict  )"Austin Virtual Gaming: Levels will end after 20 minutes\n");
      } else {
#line 994
        goto _L___6;
      }
    } else {
#line 994
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
    _L___5: /* CIL Label */ ;
  }
#line 997
  p___0 = M_CheckParm("-warp");
#line 998
  if (p___0) {
#line 998
    if (p___0 < myargc - 1) {
#line 1000
      if ((unsigned int )gamemode == 2U) {
#line 1001
        startmap = atoi((char const   *)*(myargv + (p___0 + 1)));
      } else {
#line 1004
        startepisode = (int )*(*(myargv + (p___0 + 1)) + 0) - 48;
#line 1005
        startmap = (int )*(*(myargv + (p___0 + 2)) + 0) - 48;
      }
#line 1007
      autostart = (boolean )1;
    } else {
#line 998
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ ;
  }
#line 1011
  printf((char const   * __restrict  )"V_Init: allocate screens.\n");
#line 1012
  V_Init();
#line 1014
  printf((char const   * __restrict  )"M_LoadDefaults: Load system defaults.\n");
#line 1015
  M_LoadDefaults();
#line 1017
  printf((char const   * __restrict  )"Z_Init: Init zone memory allocation daemon. \n");
#line 1018
  Z_Init();
#line 1020
  printf((char const   * __restrict  )"W_Init: Init WADfiles.\n");
#line 1021
  W_InitMultipleFiles(wadfiles);
#line 1025
  if (modifiedgame) {
#line 1029
    name[0][0] = (char )'e';
#line 1029
    name[0][1] = (char )'2';
#line 1029
    name[0][2] = (char )'m';
#line 1029
    name[0][3] = (char )'1';
#line 1029
    name[0][4] = (char )'\000';
#line 1029
    tmp___6 = 5U;
    {
#line 1029
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1029
      if (tmp___6 >= 8U) {
#line 1029
        goto while_break___0;
      }
#line 1029
      name[0][tmp___6] = (char)0;
#line 1029
      tmp___6 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1029
    name[1][0] = (char )'e';
#line 1029
    name[1][1] = (char )'2';
#line 1029
    name[1][2] = (char )'m';
#line 1029
    name[1][3] = (char )'2';
#line 1029
    name[1][4] = (char )'\000';
#line 1029
    tmp___7 = 5U;
    {
#line 1029
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1029
      if (tmp___7 >= 8U) {
#line 1029
        goto while_break___1;
      }
#line 1029
      name[1][tmp___7] = (char)0;
#line 1029
      tmp___7 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1029
    name[2][0] = (char )'e';
#line 1029
    name[2][1] = (char )'2';
#line 1029
    name[2][2] = (char )'m';
#line 1029
    name[2][3] = (char )'3';
#line 1029
    name[2][4] = (char )'\000';
#line 1029
    tmp___8 = 5U;
    {
#line 1029
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1029
      if (tmp___8 >= 8U) {
#line 1029
        goto while_break___2;
      }
#line 1029
      name[2][tmp___8] = (char)0;
#line 1029
      tmp___8 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1029
    name[3][0] = (char )'e';
#line 1029
    name[3][1] = (char )'2';
#line 1029
    name[3][2] = (char )'m';
#line 1029
    name[3][3] = (char )'4';
#line 1029
    name[3][4] = (char )'\000';
#line 1029
    tmp___9 = 5U;
    {
#line 1029
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1029
      if (tmp___9 >= 8U) {
#line 1029
        goto while_break___3;
      }
#line 1029
      name[3][tmp___9] = (char)0;
#line 1029
      tmp___9 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1029
    name[4][0] = (char )'e';
#line 1029
    name[4][1] = (char )'2';
#line 1029
    name[4][2] = (char )'m';
#line 1029
    name[4][3] = (char )'5';
#line 1029
    name[4][4] = (char )'\000';
#line 1029
    tmp___10 = 5U;
    {
#line 1029
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1029
      if (tmp___10 >= 8U) {
#line 1029
        goto while_break___4;
      }
#line 1029
      name[4][tmp___10] = (char)0;
#line 1029
      tmp___10 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1029
    name[5][0] = (char )'e';
#line 1029
    name[5][1] = (char )'2';
#line 1029
    name[5][2] = (char )'m';
#line 1029
    name[5][3] = (char )'6';
#line 1029
    name[5][4] = (char )'\000';
#line 1029
    tmp___11 = 5U;
    {
#line 1029
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1029
      if (tmp___11 >= 8U) {
#line 1029
        goto while_break___5;
      }
#line 1029
      name[5][tmp___11] = (char)0;
#line 1029
      tmp___11 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1029
    name[6][0] = (char )'e';
#line 1029
    name[6][1] = (char )'2';
#line 1029
    name[6][2] = (char )'m';
#line 1029
    name[6][3] = (char )'7';
#line 1029
    name[6][4] = (char )'\000';
#line 1029
    tmp___12 = 5U;
    {
#line 1029
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1029
      if (tmp___12 >= 8U) {
#line 1029
        goto while_break___6;
      }
#line 1029
      name[6][tmp___12] = (char)0;
#line 1029
      tmp___12 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1029
    name[7][0] = (char )'e';
#line 1029
    name[7][1] = (char )'2';
#line 1029
    name[7][2] = (char )'m';
#line 1029
    name[7][3] = (char )'8';
#line 1029
    name[7][4] = (char )'\000';
#line 1029
    tmp___13 = 5U;
    {
#line 1029
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1029
      if (tmp___13 >= 8U) {
#line 1029
        goto while_break___7;
      }
#line 1029
      name[7][tmp___13] = (char)0;
#line 1029
      tmp___13 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1029
    name[8][0] = (char )'e';
#line 1029
    name[8][1] = (char )'2';
#line 1029
    name[8][2] = (char )'m';
#line 1029
    name[8][3] = (char )'9';
#line 1029
    name[8][4] = (char )'\000';
#line 1029
    tmp___14 = 5U;
    {
#line 1029
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1029
      if (tmp___14 >= 8U) {
#line 1029
        goto while_break___8;
      }
#line 1029
      name[8][tmp___14] = (char)0;
#line 1029
      tmp___14 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1029
    name[9][0] = (char )'e';
#line 1029
    name[9][1] = (char )'3';
#line 1029
    name[9][2] = (char )'m';
#line 1029
    name[9][3] = (char )'1';
#line 1029
    name[9][4] = (char )'\000';
#line 1029
    tmp___15 = 5U;
    {
#line 1029
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1029
      if (tmp___15 >= 8U) {
#line 1029
        goto while_break___9;
      }
#line 1029
      name[9][tmp___15] = (char)0;
#line 1029
      tmp___15 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1029
    name[10][0] = (char )'e';
#line 1029
    name[10][1] = (char )'3';
#line 1029
    name[10][2] = (char )'m';
#line 1029
    name[10][3] = (char )'3';
#line 1029
    name[10][4] = (char )'\000';
#line 1029
    tmp___16 = 5U;
    {
#line 1029
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1029
      if (tmp___16 >= 8U) {
#line 1029
        goto while_break___10;
      }
#line 1029
      name[10][tmp___16] = (char)0;
#line 1029
      tmp___16 ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1029
    name[11][0] = (char )'e';
#line 1029
    name[11][1] = (char )'3';
#line 1029
    name[11][2] = (char )'m';
#line 1029
    name[11][3] = (char )'3';
#line 1029
    name[11][4] = (char )'\000';
#line 1029
    tmp___17 = 5U;
    {
#line 1029
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1029
      if (tmp___17 >= 8U) {
#line 1029
        goto while_break___11;
      }
#line 1029
      name[11][tmp___17] = (char)0;
#line 1029
      tmp___17 ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1029
    name[12][0] = (char )'e';
#line 1029
    name[12][1] = (char )'3';
#line 1029
    name[12][2] = (char )'m';
#line 1029
    name[12][3] = (char )'4';
#line 1029
    name[12][4] = (char )'\000';
#line 1029
    tmp___18 = 5U;
    {
#line 1029
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1029
      if (tmp___18 >= 8U) {
#line 1029
        goto while_break___12;
      }
#line 1029
      name[12][tmp___18] = (char)0;
#line 1029
      tmp___18 ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1029
    name[13][0] = (char )'e';
#line 1029
    name[13][1] = (char )'3';
#line 1029
    name[13][2] = (char )'m';
#line 1029
    name[13][3] = (char )'5';
#line 1029
    name[13][4] = (char )'\000';
#line 1029
    tmp___19 = 5U;
    {
#line 1029
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1029
      if (tmp___19 >= 8U) {
#line 1029
        goto while_break___13;
      }
#line 1029
      name[13][tmp___19] = (char)0;
#line 1029
      tmp___19 ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1029
    name[14][0] = (char )'e';
#line 1029
    name[14][1] = (char )'3';
#line 1029
    name[14][2] = (char )'m';
#line 1029
    name[14][3] = (char )'6';
#line 1029
    name[14][4] = (char )'\000';
#line 1029
    tmp___20 = 5U;
    {
#line 1029
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1029
      if (tmp___20 >= 8U) {
#line 1029
        goto while_break___14;
      }
#line 1029
      name[14][tmp___20] = (char)0;
#line 1029
      tmp___20 ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 1029
    name[15][0] = (char )'e';
#line 1029
    name[15][1] = (char )'3';
#line 1029
    name[15][2] = (char )'m';
#line 1029
    name[15][3] = (char )'7';
#line 1029
    name[15][4] = (char )'\000';
#line 1029
    tmp___21 = 5U;
    {
#line 1029
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1029
      if (tmp___21 >= 8U) {
#line 1029
        goto while_break___15;
      }
#line 1029
      name[15][tmp___21] = (char)0;
#line 1029
      tmp___21 ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 1029
    name[16][0] = (char )'e';
#line 1029
    name[16][1] = (char )'3';
#line 1029
    name[16][2] = (char )'m';
#line 1029
    name[16][3] = (char )'8';
#line 1029
    name[16][4] = (char )'\000';
#line 1029
    tmp___22 = 5U;
    {
#line 1029
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 1029
      if (tmp___22 >= 8U) {
#line 1029
        goto while_break___16;
      }
#line 1029
      name[16][tmp___22] = (char)0;
#line 1029
      tmp___22 ++;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1029
    name[17][0] = (char )'e';
#line 1029
    name[17][1] = (char )'3';
#line 1029
    name[17][2] = (char )'m';
#line 1029
    name[17][3] = (char )'9';
#line 1029
    name[17][4] = (char )'\000';
#line 1029
    tmp___23 = 5U;
    {
#line 1029
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1029
      if (tmp___23 >= 8U) {
#line 1029
        goto while_break___17;
      }
#line 1029
      name[17][tmp___23] = (char)0;
#line 1029
      tmp___23 ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1029
    name[18][0] = (char )'d';
#line 1029
    name[18][1] = (char )'p';
#line 1029
    name[18][2] = (char )'h';
#line 1029
    name[18][3] = (char )'o';
#line 1029
    name[18][4] = (char )'o';
#line 1029
    name[18][5] = (char )'f';
#line 1029
    name[18][6] = (char )'\000';
#line 1029
    tmp___24 = 7U;
    {
#line 1029
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1029
      if (tmp___24 >= 8U) {
#line 1029
        goto while_break___18;
      }
#line 1029
      name[18][tmp___24] = (char)0;
#line 1029
      tmp___24 ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 1029
    name[19][0] = (char )'b';
#line 1029
    name[19][1] = (char )'f';
#line 1029
    name[19][2] = (char )'g';
#line 1029
    name[19][3] = (char )'g';
#line 1029
    name[19][4] = (char )'a';
#line 1029
    name[19][5] = (char )'0';
#line 1029
    name[19][6] = (char )'\000';
#line 1029
    tmp___25 = 7U;
    {
#line 1029
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1029
      if (tmp___25 >= 8U) {
#line 1029
        goto while_break___19;
      }
#line 1029
      name[19][tmp___25] = (char)0;
#line 1029
      tmp___25 ++;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 1029
    name[20][0] = (char )'h';
#line 1029
    name[20][1] = (char )'e';
#line 1029
    name[20][2] = (char )'a';
#line 1029
    name[20][3] = (char )'d';
#line 1029
    name[20][4] = (char )'a';
#line 1029
    name[20][5] = (char )'1';
#line 1029
    name[20][6] = (char )'\000';
#line 1029
    tmp___26 = 7U;
    {
#line 1029
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 1029
      if (tmp___26 >= 8U) {
#line 1029
        goto while_break___20;
      }
#line 1029
      name[20][tmp___26] = (char)0;
#line 1029
      tmp___26 ++;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 1029
    name[21][0] = (char )'c';
#line 1029
    name[21][1] = (char )'y';
#line 1029
    name[21][2] = (char )'b';
#line 1029
    name[21][3] = (char )'r';
#line 1029
    name[21][4] = (char )'a';
#line 1029
    name[21][5] = (char )'1';
#line 1029
    name[21][6] = (char )'\000';
#line 1029
    tmp___27 = 7U;
    {
#line 1029
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1029
      if (tmp___27 >= 8U) {
#line 1029
        goto while_break___21;
      }
#line 1029
      name[21][tmp___27] = (char)0;
#line 1029
      tmp___27 ++;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 1029
    name[22][0] = (char )'s';
#line 1029
    name[22][1] = (char )'p';
#line 1029
    name[22][2] = (char )'i';
#line 1029
    name[22][3] = (char )'d';
#line 1029
    name[22][4] = (char )'a';
#line 1029
    name[22][5] = (char )'1';
#line 1029
    name[22][6] = (char )'d';
#line 1029
    name[22][7] = (char )'1';
#line 1037
    if ((unsigned int )gamemode == 0U) {
#line 1038
      I_Error("\nYou cannot -file with the shareware version. Register!");
    }
#line 1043
    if ((unsigned int )gamemode == 1U) {
#line 1044
      i = 0;
      {
#line 1044
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 1044
        if (! (i < 23)) {
#line 1044
          goto while_break___22;
        }
#line 1045
        tmp___28 = W_CheckNumForName(name[i]);
#line 1045
        if (tmp___28 < 0) {
#line 1046
          I_Error("\nThis is not the registered version.");
        }
#line 1044
        i ++;
      }
      while_break___22: /* CIL Label */ ;
      }
    }
  }
#line 1050
  if (modifiedgame) {
#line 1052
    printf((char const   * __restrict  )"===========================================================================\nATTENTION:  This version of DOOM has been modified.  If you would like to\nget a copy of the original game, call 1-800-IDGAMES or see the readme file.\n        You will not receive technical support for modified games.\n                      press enter to continue\n===========================================================================\n");
#line 1060
    getchar();
  }
  {
#line 1068
  if ((unsigned int )gamemode == 4U) {
#line 1068
    goto case_4;
  }
#line 1068
  if ((unsigned int )gamemode == 0U) {
#line 1068
    goto case_4;
  }
#line 1077
  if ((unsigned int )gamemode == 2U) {
#line 1077
    goto case_2___1;
  }
#line 1077
  if ((unsigned int )gamemode == 3U) {
#line 1077
    goto case_2___1;
  }
#line 1077
  if ((unsigned int )gamemode == 1U) {
#line 1077
    goto case_2___1;
  }
#line 1086
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_0___1: /* CIL Label */ 
#line 1069
  printf((char const   * __restrict  )"===========================================================================\n                                Shareware!\n===========================================================================\n");
#line 1074
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  case_3___1: /* CIL Label */ 
  case_1___1: /* CIL Label */ 
#line 1078
  printf((char const   * __restrict  )"===========================================================================\n                 Commercial product - do not distribute!\n         Please report software piracy to the SPA: 1-800-388-PIR8\n===========================================================================\n");
#line 1084
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1088
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1091
  printf((char const   * __restrict  )"M_Init: Init miscellaneous info.\n");
#line 1092
  M_Init();
#line 1094
  printf((char const   * __restrict  )"R_Init: Init DOOM refresh daemon - ");
#line 1095
  R_Init();
#line 1097
  printf((char const   * __restrict  )"\nP_Init: Init Playloop state.\n");
#line 1098
  P_Init();
#line 1100
  printf((char const   * __restrict  )"I_Init: Setting up machine state.\n");
#line 1101
  I_Init();
#line 1103
  printf((char const   * __restrict  )"D_CheckNetGame: Checking network game status.\n");
#line 1104
  D_CheckNetGame();
#line 1106
  printf((char const   * __restrict  )"S_Init: Setting up sound.\n");
#line 1107
  S_Init(snd_SfxVolume, snd_MusicVolume);
#line 1109
  printf((char const   * __restrict  )"HU_Init: Setting up heads up display.\n");
#line 1110
  HU_Init();
#line 1112
  printf((char const   * __restrict  )"ST_Init: Init status bar.\n");
#line 1113
  ST_Init();
#line 1116
  p___0 = M_CheckParm("-statcopy");
#line 1117
  if (p___0) {
#line 1117
    if (p___0 < myargc - 1) {
#line 1122
      tmp___29 = atoi((char const   *)*(myargv + (p___0 + 1)));
#line 1122
      statcopy = (void *)tmp___29;
#line 1123
      printf((char const   * __restrict  )"External statistics registered.\n");
    } else {
#line 1117
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ ;
  }
#line 1127
  p___0 = M_CheckParm("-record");
#line 1129
  if (p___0) {
#line 1129
    if (p___0 < myargc - 1) {
#line 1131
      G_RecordDemo(*(myargv + (p___0 + 1)));
#line 1132
      autostart = (boolean )1;
    } else {
#line 1129
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ ;
  }
#line 1135
  p___0 = M_CheckParm("-playdemo");
#line 1136
  if (p___0) {
#line 1136
    if (p___0 < myargc - 1) {
#line 1138
      singledemo = (boolean )1;
#line 1139
      G_DeferedPlayDemo(*(myargv + (p___0 + 1)));
#line 1140
      D_DoomLoop();
    } else {
#line 1136
      goto _L___10;
    }
  } else {
    _L___10: /* CIL Label */ ;
  }
#line 1143
  p___0 = M_CheckParm("-timedemo");
#line 1144
  if (p___0) {
#line 1144
    if (p___0 < myargc - 1) {
#line 1146
      G_TimeDemo(*(myargv + (p___0 + 1)));
#line 1147
      D_DoomLoop();
    } else {
#line 1144
      goto _L___11;
    }
  } else {
    _L___11: /* CIL Label */ ;
  }
#line 1150
  p___0 = M_CheckParm("-loadgame");
#line 1151
  if (p___0) {
#line 1151
    if (p___0 < myargc - 1) {
#line 1153
      tmp___30 = M_CheckParm("-cdrom");
#line 1153
      if (tmp___30) {
#line 1154
        sprintf((char * __restrict  )(file), (char const   * __restrict  )"c:\\doomdata\\doomsav%c.dsg",
                (int )*(*(myargv + (p___0 + 1)) + 0));
      } else {
#line 1156
        sprintf((char * __restrict  )(file), (char const   * __restrict  )"doomsav%c.dsg",
                (int )*(*(myargv + (p___0 + 1)) + 0));
      }
#line 1157
      G_LoadGame(file);
    } else {
#line 1151
      goto _L___12;
    }
  } else {
    _L___12: /* CIL Label */ ;
  }
#line 1161
  if ((unsigned int )gameaction != 3U) {
#line 1163
    if (autostart) {
#line 1163
      goto _L___13;
    } else
#line 1163
    if (netgame) {
      _L___13: /* CIL Label */ 
#line 1164
      G_InitNew(startskill, startepisode, startmap);
    } else {
#line 1166
      D_StartTitle();
    }
  }
#line 1170
  D_DoomLoop();
#line 1171
  return;
}
}
#line 26 "d_net.c"
static char const   rcsid___10[48]  = 
#line 26 "d_net.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'d',      (char const   )'_',      (char const   )'n', 
        (char const   )'e',      (char const   )'t',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'3',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'7',      (char const   )'/', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )' ',      (char const   )'2',      (char const   )'2', 
        (char const   )':',      (char const   )'0',      (char const   )'1',      (char const   )':', 
        (char const   )'4',      (char const   )'7',      (char const   )' ',      (char const   )'b', 
        (char const   )'1',      (char const   )' ',      (char const   )'E',      (char const   )'x', 
        (char const   )'p',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 274 "doomstat.h"
doomcom_t *doomcom  ;
#line 277 "doomstat.h"
doomdata_t *netbuffer  ;
#line 280 "doomstat.h"
ticcmd_t localcmds[12]  ;
#line 283 "doomstat.h"
int maketic  ;
#line 284 "doomstat.h"
int nettics[8]  ;
#line 286 "doomstat.h"
ticcmd_t netcmds[4][12]  ;
#line 287 "doomstat.h"
int ticdup  ;
#line 64 "d_net.c"
boolean nodeingame[8]  ;
#line 65 "d_net.c"
boolean remoteresend[8]  ;
#line 66 "d_net.c"
int resendto[8]  ;
#line 67 "d_net.c"
int resendcount[8]  ;
#line 69 "d_net.c"
int nodeforplayer[4]  ;
#line 72 "d_net.c"
int lastnettic  ;
#line 73 "d_net.c"
int skiptics  ;
#line 75 "d_net.c"
int maxsend  ;
#line 82 "d_net.c"
boolean reboundpacket  ;
#line 83 "d_net.c"
doomdata_t reboundstore  ;
#line 90 "d_net.c"
int NetbufferSize(void) 
{ 


  {
#line 92
  return ((int )(& ((doomdata_t *)0)->cmds[netbuffer->numtics]));
}
}
#line 98 "d_net.c"
unsigned int NetbufferChecksum(void) 
{ 
  unsigned int c ;
  int i ;
  int l___0 ;
  int tmp ;

  {
#line 103
  c = 19088743U;
#line 107
  return (0U);
#line 110
  tmp = NetbufferSize();
#line 110
  l___0 = (tmp - (int )(& ((doomdata_t *)0)->retransmitfrom)) / 4;
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < l___0)) {
#line 111
      goto while_break;
    }
#line 112
    c += *((unsigned int *)(& netbuffer->retransmitfrom) + i) * (unsigned int )(i + 1);
#line 111
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return (c & 268435455U);
}
}
#line 120 "d_net.c"
int ExpandTics(int low ) 
{ 
  int delta ;

  {
#line 124
  delta = low - (maketic & 0xff);
#line 126
  if (delta >= -64) {
#line 126
    if (delta <= 64) {
#line 127
      return ((maketic & -256) + low);
    } else {
#line 126
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 128
  if (delta > 64) {
#line 129
    return (((maketic & -256) - 256) + low);
  }
#line 130
  if (delta < -64) {
#line 131
    return (((maketic & -256) + 256) + low);
  }
#line 133
  I_Error("ExpandTics: strange value %i at maketic %i", low, maketic);
#line 134
  return (0);
}
}
#line 142 "d_net.c"
void HSendPacket(int node , int flags ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;
  int i ;
  int realretrans ;
  int tmp___1 ;

  {
#line 147
  tmp = NetbufferChecksum();
#line 147
  netbuffer->checksum = tmp | (unsigned int )flags;
#line 149
  if (! node) {
#line 151
    reboundstore = *netbuffer;
#line 152
    reboundpacket = (boolean )1;
#line 153
    return;
  }
#line 156
  if (demoplayback) {
#line 157
    return;
  }
#line 159
  if (! netgame) {
#line 160
    I_Error("Tried to transmit to another node");
  }
#line 162
  doomcom->command = (short)1;
#line 163
  doomcom->remotenode = (short )node;
#line 164
  tmp___0 = NetbufferSize();
#line 164
  doomcom->datalength = (short )tmp___0;
#line 166
  if (debugfile) {
#line 170
    if (netbuffer->checksum & 1073741824U) {
#line 171
      realretrans = ExpandTics((int )netbuffer->retransmitfrom);
    } else {
#line 173
      realretrans = -1;
    }
#line 175
    tmp___1 = ExpandTics((int )netbuffer->starttic);
#line 175
    fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"send (%i + %i, R %i) [%i] ",
            tmp___1, (int )netbuffer->numtics, realretrans, (int )doomcom->datalength);
#line 179
    i = 0;
    {
#line 179
    while (1) {
      while_continue: /* CIL Label */ ;
#line 179
      if (! (i < (int )doomcom->datalength)) {
#line 179
        goto while_break;
      }
#line 180
      fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"%i ",
              (int )*((byte *)netbuffer + i));
#line 179
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 182
    fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"\n");
  }
#line 185
  I_NetCmd();
#line 186
  return;
}
}
#line 192 "d_net.c"
boolean HGetPacket(void) 
{ 
  int tmp ;
  unsigned int tmp___0 ;
  int realretrans ;
  int i ;
  int tmp___1 ;

  {
#line 194
  if (reboundpacket) {
#line 196
    *netbuffer = reboundstore;
#line 197
    doomcom->remotenode = (short)0;
#line 198
    reboundpacket = (boolean )0;
#line 199
    return ((boolean )1);
  }
#line 202
  if (! netgame) {
#line 203
    return ((boolean )0);
  }
#line 205
  if (demoplayback) {
#line 206
    return ((boolean )0);
  }
#line 208
  doomcom->command = (short)2;
#line 209
  I_NetCmd();
#line 211
  if ((int )doomcom->remotenode == -1) {
#line 212
    return ((boolean )0);
  }
#line 214
  tmp = NetbufferSize();
#line 214
  if ((int )doomcom->datalength != tmp) {
#line 216
    if (debugfile) {
#line 217
      fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"bad packet length %i\n",
              (int )doomcom->datalength);
    }
#line 218
    return ((boolean )0);
  }
#line 221
  tmp___0 = NetbufferChecksum();
#line 221
  if (tmp___0 != (netbuffer->checksum & 268435455U)) {
#line 223
    if (debugfile) {
#line 224
      fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"bad packet checksum\n");
    }
#line 225
    return ((boolean )0);
  }
#line 228
  if (debugfile) {
#line 233
    if (netbuffer->checksum & 536870912U) {
#line 234
      fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"setup packet\n");
    } else {
#line 237
      if (netbuffer->checksum & 1073741824U) {
#line 238
        realretrans = ExpandTics((int )netbuffer->retransmitfrom);
      } else {
#line 240
        realretrans = -1;
      }
#line 242
      tmp___1 = ExpandTics((int )netbuffer->starttic);
#line 242
      fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"get %i = (%i + %i, R %i)[%i] ",
              (int )doomcom->remotenode, tmp___1, (int )netbuffer->numtics, realretrans,
              (int )doomcom->datalength);
#line 247
      i = 0;
      {
#line 247
      while (1) {
        while_continue: /* CIL Label */ ;
#line 247
        if (! (i < (int )doomcom->datalength)) {
#line 247
          goto while_break;
        }
#line 248
        fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"%i ",
                (int )*((byte *)netbuffer + i));
#line 247
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 249
      fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"\n");
    }
  }
#line 252
  return ((boolean )1);
}
}
#line 259 "d_net.c"
char exitmsg[80]  ;
#line 261 "d_net.c"
void GetPackets(void) 
{ 
  int netconsole ;
  int netnode ;
  ticcmd_t *src ;
  ticcmd_t *dest ;
  int realend ;
  int realstart ;
  int start ;
  boolean tmp ;

  {
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    tmp = HGetPacket();
#line 269
    if (! tmp) {
#line 269
      goto while_break;
    }
#line 271
    if (netbuffer->checksum & 536870912U) {
#line 272
      goto while_continue;
    }
#line 274
    netconsole = (int )netbuffer->player & -129;
#line 275
    netnode = (int )doomcom->remotenode;
#line 279
    realstart = ExpandTics((int )netbuffer->starttic);
#line 280
    realend = realstart + (int )netbuffer->numtics;
#line 283
    if (netbuffer->checksum & 0x80000000) {
#line 285
      if (! nodeingame[netnode]) {
#line 286
        goto while_continue;
      }
#line 287
      nodeingame[netnode] = (boolean )0;
#line 288
      playeringame[netconsole] = (boolean )0;
#line 289
      strcpy((char * __restrict  )(exitmsg), (char const   * __restrict  )"Player 1 left the game");
#line 290
      exitmsg[7] = (char )((int )exitmsg[7] + netconsole);
#line 291
      players[consoleplayer].message = exitmsg;
#line 292
      if (demorecording) {
#line 293
        G_CheckDemoStatus();
      }
#line 294
      goto while_continue;
    }
#line 298
    if (netbuffer->checksum & 268435456U) {
#line 299
      I_Error("Killed by network driver");
    }
#line 301
    nodeforplayer[netconsole] = netnode;
#line 304
    if (resendcount[netnode] <= 0) {
#line 304
      if (netbuffer->checksum & 1073741824U) {
#line 307
        resendto[netnode] = ExpandTics((int )netbuffer->retransmitfrom);
#line 308
        if (debugfile) {
#line 309
          fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"retransmit from %i\n",
                  resendto[netnode]);
        }
#line 310
        resendcount[netnode] = 10;
      } else {
#line 304
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 313
      (resendcount[netnode]) --;
    }
#line 316
    if (realend == nettics[netnode]) {
#line 317
      goto while_continue;
    }
#line 319
    if (realend < nettics[netnode]) {
#line 321
      if (debugfile) {
#line 322
        fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"out of order packet (%i + %i)\n",
                realstart, (int )netbuffer->numtics);
      }
#line 325
      goto while_continue;
    }
#line 329
    if (realstart > nettics[netnode]) {
#line 332
      if (debugfile) {
#line 333
        fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"missed tics from %i (%i - %i)\n",
                netnode, realstart, nettics[netnode]);
      }
#line 336
      remoteresend[netnode] = (boolean )1;
#line 337
      goto while_continue;
    }
#line 344
    remoteresend[netnode] = (boolean )0;
#line 346
    start = nettics[netnode] - realstart;
#line 347
    src = & netbuffer->cmds[start];
    {
#line 349
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 349
      if (! (nettics[netnode] < realend)) {
#line 349
        goto while_break___0;
      }
#line 351
      dest = & netcmds[netconsole][nettics[netnode] % 12];
#line 352
      (nettics[netnode]) ++;
#line 353
      *dest = *src;
#line 354
      src ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  return;
}
}
#line 366 "d_net.c"
int gametime  ;
#line 368 "d_net.c"
void NetUpdate(void) 
{ 
  int nowtime ;
  int newtics ;
  int i ;
  int j ;
  int realstart ;
  int gameticdiv ;
  int tmp ;

  {
#line 377
  tmp = I_GetTime();
#line 377
  nowtime = tmp / ticdup;
#line 378
  newtics = nowtime - gametime;
#line 379
  gametime = nowtime;
#line 381
  if (newtics <= 0) {
#line 382
    goto listen;
  }
#line 384
  if (skiptics <= newtics) {
#line 386
    newtics -= skiptics;
#line 387
    skiptics = 0;
  } else {
#line 391
    skiptics -= newtics;
#line 392
    newtics = 0;
  }
#line 396
  netbuffer->player = (byte )consoleplayer;
#line 399
  gameticdiv = gametic / ticdup;
#line 400
  i = 0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (i < newtics)) {
#line 400
      goto while_break;
    }
#line 402
    I_StartTic();
#line 403
    D_ProcessEvents();
#line 404
    if (maketic - gameticdiv >= 5) {
#line 405
      goto while_break;
    }
#line 408
    G_BuildTiccmd(& localcmds[maketic % 12]);
#line 409
    maketic ++;
#line 400
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  if (singletics) {
#line 414
    return;
  }
#line 417
  i = 0;
  {
#line 417
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 417
    if (! (i < (int )doomcom->numnodes)) {
#line 417
      goto while_break___0;
    }
#line 418
    if (nodeingame[i]) {
#line 420
      realstart = resendto[i];
#line 420
      netbuffer->starttic = (byte )realstart;
#line 421
      netbuffer->numtics = (byte )(maketic - realstart);
#line 422
      if ((int )netbuffer->numtics > 12) {
#line 423
        I_Error("NetUpdate: netbuffer->numtics > BACKUPTICS");
      }
#line 425
      resendto[i] = maketic - (int )doomcom->extratics;
#line 427
      j = 0;
      {
#line 427
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 427
        if (! (j < (int )netbuffer->numtics)) {
#line 427
          goto while_break___1;
        }
#line 428
        netbuffer->cmds[j] = localcmds[(realstart + j) % 12];
#line 427
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 431
      if (remoteresend[i]) {
#line 433
        netbuffer->retransmitfrom = (byte )nettics[i];
#line 434
        HSendPacket(i, 0x40000000);
      } else {
#line 438
        netbuffer->retransmitfrom = (byte )0;
#line 439
        HSendPacket(i, 0);
      }
    }
#line 417
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  listen: 
#line 445
  GetPackets();
#line 446
  return;
}
}
#line 453 "d_net.c"
void CheckAbort(void) 
{ 
  event_t *ev ;
  int stoptic ;
  int tmp ;
  int tmp___0 ;

  {
#line 458
  tmp = I_GetTime();
#line 458
  stoptic = tmp + 2;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    tmp___0 = I_GetTime();
#line 459
    if (! (tmp___0 < stoptic)) {
#line 459
      goto while_break;
    }
#line 460
    I_StartTic();
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  I_StartTic();
  {
#line 463
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 463
    if (! (eventtail != eventhead)) {
#line 463
      goto while_break___0;
    }
#line 466
    ev = & events[eventtail];
#line 467
    if ((unsigned int )ev->type == 0U) {
#line 467
      if (ev->data1 == 27) {
#line 468
        I_Error("Network game synchronization aborted.");
      } else {
#line 467
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 463
    eventtail ++;
#line 463
    eventtail &= 63;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 470
  return;
}
}
#line 476 "d_net.c"
void D_ArbitrateNetStart(void) 
{ 
  int i ;
  boolean gotinfo[8] ;
  boolean tmp ;
  boolean tmp___0 ;

  {
#line 481
  autostart = (boolean )1;
#line 482
  memset((void *)(gotinfo), 0, (size_t )sizeof(gotinfo));
#line 484
  if (doomcom->consoleplayer) {
#line 487
    printf((char const   * __restrict  )"listening for network start info...\n");
    {
#line 488
    while (1) {
      while_continue: /* CIL Label */ ;
#line 488
      if (! 1) {
#line 488
        goto while_break;
      }
#line 490
      CheckAbort();
#line 491
      tmp = HGetPacket();
#line 491
      if (! tmp) {
#line 492
        goto while_continue;
      }
#line 493
      if (netbuffer->checksum & 536870912U) {
#line 495
        if ((int )netbuffer->player != 110) {
#line 496
          I_Error("Different DOOM versions cannot play a net game!");
        }
#line 497
        startskill = (skill_t )((int )netbuffer->retransmitfrom & 15);
#line 498
        deathmatch = (boolean )(((int )netbuffer->retransmitfrom & 0xc0) >> 6);
#line 499
        nomonsters = (boolean )(((int )netbuffer->retransmitfrom & 0x20) > 0);
#line 500
        respawnparm = (boolean )(((int )netbuffer->retransmitfrom & 0x10) > 0);
#line 501
        startmap = (int )netbuffer->starttic & 0x3f;
#line 502
        startepisode = (int )netbuffer->starttic >> 6;
#line 503
        return;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 510
    printf((char const   * __restrict  )"sending network start info...\n");
    {
#line 511
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 513
      CheckAbort();
#line 514
      i = 0;
      {
#line 514
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 514
        if (! (i < (int )doomcom->numnodes)) {
#line 514
          goto while_break___1;
        }
#line 516
        netbuffer->retransmitfrom = (byte )startskill;
#line 517
        if (deathmatch) {
#line 518
          netbuffer->retransmitfrom = (byte )((unsigned int )netbuffer->retransmitfrom | ((unsigned int )deathmatch << 6));
        }
#line 519
        if (nomonsters) {
#line 520
          netbuffer->retransmitfrom = (byte )((int )netbuffer->retransmitfrom | 0x20);
        }
#line 521
        if (respawnparm) {
#line 522
          netbuffer->retransmitfrom = (byte )((int )netbuffer->retransmitfrom | 0x10);
        }
#line 523
        netbuffer->starttic = (byte )(startepisode * 64 + startmap);
#line 524
        netbuffer->player = (byte )110;
#line 525
        netbuffer->numtics = (byte )0;
#line 526
        HSendPacket(i, 0x20000000);
#line 514
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 530
      i = 10;
      {
#line 530
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 530
        if (i) {
#line 530
          tmp___0 = HGetPacket();
#line 530
          if (! tmp___0) {
#line 530
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 530
          goto while_break___2;
        }
#line 532
        if (((int )netbuffer->player & 0x7f) < 8) {
#line 533
          gotinfo[(int )netbuffer->player & 0x7f] = (boolean )1;
        }
#line 530
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 542
      i = 1;
      {
#line 542
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 542
        if (! (i < (int )doomcom->numnodes)) {
#line 542
          goto while_break___3;
        }
#line 543
        if (! gotinfo[i]) {
#line 544
          goto while_break___3;
        }
#line 542
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 511
      if (! (i < (int )doomcom->numnodes)) {
#line 511
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 547
  return;
}
}
#line 555 "d_net.c"
void D_CheckNetGame(void) 
{ 
  int i ;

  {
#line 559
  i = 0;
  {
#line 559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 559
    if (! (i < 8)) {
#line 559
      goto while_break;
    }
#line 561
    nodeingame[i] = (boolean )0;
#line 562
    nettics[i] = 0;
#line 563
    remoteresend[i] = (boolean )0;
#line 564
    resendto[i] = 0;
#line 559
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  I_InitNetwork();
#line 569
  if (doomcom->id != 0x12345678l) {
#line 570
    I_Error("Doomcom buffer invalid!");
  }
#line 572
  netbuffer = & doomcom->data;
#line 573
  displayplayer = (int )doomcom->consoleplayer;
#line 573
  consoleplayer = displayplayer;
#line 574
  if (netgame) {
#line 575
    D_ArbitrateNetStart();
  }
#line 577
  printf((char const   * __restrict  )"startskill %i  deathmatch: %i  startmap: %i  startepisode: %i\n",
         (unsigned int )startskill, (unsigned int )deathmatch, startmap, startepisode);
#line 581
  ticdup = (int )doomcom->ticdup;
#line 582
  maxsend = 12 / (2 * ticdup) - 1;
#line 583
  if (maxsend < 1) {
#line 584
    maxsend = 1;
  }
#line 586
  i = 0;
  {
#line 586
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 586
    if (! (i < (int )doomcom->numplayers)) {
#line 586
      goto while_break___0;
    }
#line 587
    playeringame[i] = (boolean )1;
#line 586
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 588
  i = 0;
  {
#line 588
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 588
    if (! (i < (int )doomcom->numnodes)) {
#line 588
      goto while_break___1;
    }
#line 589
    nodeingame[i] = (boolean )1;
#line 588
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 591
  printf((char const   * __restrict  )"player %i of %i (%i nodes)\n", consoleplayer + 1,
         (int )doomcom->numplayers, (int )doomcom->numnodes);
#line 594
  return;
}
}
#line 602 "d_net.c"
void D_QuitNetGame(void) 
{ 
  int i ;
  int j ;

  {
#line 606
  if (debugfile) {
#line 607
    fclose(debugfile);
  }
#line 609
  if (! netgame) {
#line 609
    goto _L___1;
  } else
#line 609
  if (! usergame) {
    _L___1: /* CIL Label */ 
#line 609
    goto _L___0;
  } else
#line 609
  if (consoleplayer == -1) {
    _L___0: /* CIL Label */ 
#line 609
    goto _L;
  } else
#line 609
  if (demoplayback) {
    _L: /* CIL Label */ 
#line 610
    return;
  }
#line 613
  netbuffer->player = (byte )consoleplayer;
#line 614
  netbuffer->numtics = (byte )0;
#line 615
  i = 0;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! (i < 4)) {
#line 615
      goto while_break;
    }
#line 617
    j = 1;
    {
#line 617
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 617
      if (! (j < (int )doomcom->numnodes)) {
#line 617
        goto while_break___0;
      }
#line 618
      if (nodeingame[j]) {
#line 619
        HSendPacket(j, (-0x7FFFFFFF-1));
      }
#line 617
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 620
    I_WaitVBL(1);
#line 615
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 622
  return;
}
}
#line 629 "d_net.c"
int frametics[4]  ;
#line 630 "d_net.c"
int frameon  ;
#line 631 "d_net.c"
int frameskip[4]  ;
#line 632 "d_net.c"
int oldnettics  ;
#line 641 "d_net.c"
static int oldentertics  ;
#line 636 "d_net.c"
void TryRunTics(void) 
{ 
  int i ;
  int lowtic ;
  int entertic ;
  int realtics ;
  int availabletics ;
  int counts ;
  int numplaying ;
  int tmp ;
  int tmp___0 ;
  ticcmd_t *cmd ;
  int buf ;
  int j ;
  int tmp___1 ;

  {
#line 648
  tmp = I_GetTime();
#line 648
  entertic = tmp / ticdup;
#line 649
  realtics = entertic - oldentertics;
#line 650
  oldentertics = entertic;
#line 653
  NetUpdate();
#line 655
  lowtic = 0x7fffffff;
#line 656
  numplaying = 0;
#line 657
  i = 0;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! (i < (int )doomcom->numnodes)) {
#line 657
      goto while_break;
    }
#line 659
    if (nodeingame[i]) {
#line 661
      numplaying ++;
#line 662
      if (nettics[i] < lowtic) {
#line 663
        lowtic = nettics[i];
      }
    }
#line 657
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 666
  availabletics = lowtic - gametic / ticdup;
#line 669
  if (realtics < availabletics - 1) {
#line 670
    counts = realtics + 1;
  } else
#line 671
  if (realtics < availabletics) {
#line 672
    counts = realtics;
  } else {
#line 674
    counts = availabletics;
  }
#line 676
  if (counts < 1) {
#line 677
    counts = 1;
  }
#line 679
  frameon ++;
#line 681
  if (debugfile) {
#line 682
    fprintf((FILE * __restrict  )debugfile, (char const   * __restrict  )"=======real: %i  avail: %i  game: %i\n",
            realtics, availabletics, counts);
  }
#line 686
  if (! demoplayback) {
#line 690
    i = 0;
    {
#line 690
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 690
      if (! (i < 4)) {
#line 690
        goto while_break___0;
      }
#line 691
      if (playeringame[i]) {
#line 692
        goto while_break___0;
      }
#line 690
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 693
    if (! (consoleplayer == i)) {
#line 699
      if (nettics[0] <= nettics[nodeforplayer[i]]) {
#line 701
        gametime --;
      }
#line 704
      frameskip[frameon & 3] = oldnettics > nettics[nodeforplayer[i]];
#line 705
      oldnettics = nettics[0];
#line 706
      if (frameskip[0]) {
#line 706
        if (frameskip[1]) {
#line 706
          if (frameskip[2]) {
#line 706
            if (frameskip[3]) {
#line 708
              skiptics = 1;
            } else {
#line 706
              goto _L___1;
            }
          } else {
#line 706
            goto _L___1;
          }
        } else {
#line 706
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        _L___0: /* CIL Label */ 
        _L: /* CIL Label */ ;
      }
    }
  }
  {
#line 715
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 715
    if (! (lowtic < gametic / ticdup + counts)) {
#line 715
      goto while_break___1;
    }
#line 717
    NetUpdate();
#line 718
    lowtic = 0x7fffffff;
#line 720
    i = 0;
    {
#line 720
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 720
      if (! (i < (int )doomcom->numnodes)) {
#line 720
        goto while_break___2;
      }
#line 721
      if (nodeingame[i]) {
#line 721
        if (nettics[i] < lowtic) {
#line 722
          lowtic = nettics[i];
        } else {
#line 721
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ ;
      }
#line 720
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 724
    if (lowtic < gametic / ticdup) {
#line 725
      I_Error("TryRunTics: lowtic < gametic");
    }
#line 728
    tmp___0 = I_GetTime();
#line 728
    if (tmp___0 / ticdup - entertic >= 20) {
#line 730
      M_Ticker();
#line 731
      return;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 736
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 736
    tmp___1 = counts;
#line 736
    counts --;
#line 736
    if (! tmp___1) {
#line 736
      goto while_break___3;
    }
#line 738
    i = 0;
    {
#line 738
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 738
      if (! (i < ticdup)) {
#line 738
        goto while_break___4;
      }
#line 740
      if (gametic / ticdup > lowtic) {
#line 741
        I_Error("gametic>lowtic");
      }
#line 742
      if (advancedemo) {
#line 743
        D_DoAdvanceDemo();
      }
#line 744
      M_Ticker();
#line 745
      G_Ticker();
#line 746
      gametic ++;
#line 749
      if (i != ticdup - 1) {
#line 755
        buf = (gametic / ticdup) % 12;
#line 756
        j = 0;
        {
#line 756
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 756
          if (! (j < 4)) {
#line 756
            goto while_break___5;
          }
#line 758
          cmd = & netcmds[j][buf];
#line 759
          cmd->chatchar = (byte )0;
#line 760
          if ((int )cmd->buttons & 128) {
#line 761
            cmd->buttons = (byte )0;
          }
#line 756
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 738
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 765
    NetUpdate();
  }
  while_break___3: /* CIL Label */ ;
  }
#line 767
  return;
}
}
#line 23 "d_items.c"
static char const   rcsid___11[6]  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )'$',      (char const   )'\000'};
#line 47 "d_items.c"
weaponinfo_t weaponinfo[9]  = 
#line 47
  {      {(ammotype_t )5, 4, 3, 2, 5, 0}, 
        {(ammotype_t )0, 12, 11, 10, 13, 17}, 
        {(ammotype_t )1, 20, 19, 18, 21, 30}, 
        {(ammotype_t )0, 51, 50, 49, 52, 55}, 
        {(ammotype_t )3, 59, 58, 57, 60, 63}, 
        {(ammotype_t )2, 76, 75, 74, 77, 79}, 
        {(ammotype_t )2, 83, 82, 81, 84, 88}, 
        {(ammotype_t )5, 70, 69, 67, 71, 0}, 
        {(ammotype_t )1, 34, 33, 32, 35, 47}};
#line 24 "g_game.c"
static char const   rcsid___12[49]  = 
#line 24 "g_game.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'g',      (char const   )'_',      (char const   )'g', 
        (char const   )'a',      (char const   )'m',      (char const   )'e',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'8',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'0',      (char const   )'9',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 84 "doomstat.h"
skill_t gameskill  ;
#line 85 "doomstat.h"
int gameepisode  ;
#line 86 "doomstat.h"
int gamemap  ;
#line 89 "doomstat.h"
boolean respawnmonsters  ;
#line 92 "doomstat.h"
boolean netgame  ;
#line 96 "doomstat.h"
boolean deathmatch  ;
#line 134 "doomstat.h"
boolean paused  ;
#line 137 "doomstat.h"
boolean viewactive  ;
#line 139 "doomstat.h"
boolean nodrawers  ;
#line 140 "doomstat.h"
boolean noblit  ;
#line 158 "doomstat.h"
int consoleplayer  ;
#line 159 "doomstat.h"
int displayplayer  ;
#line 166 "doomstat.h"
int totalkills  ;
#line 167 "doomstat.h"
int totalitems  ;
#line 168 "doomstat.h"
int totalsecret  ;
#line 171 "doomstat.h"
int levelstarttic  ;
#line 180 "doomstat.h"
boolean usergame  ;
#line 183 "doomstat.h"
boolean demoplayback  ;
#line 184 "doomstat.h"
boolean demorecording  ;
#line 187 "doomstat.h"
boolean singledemo  ;
#line 193 "doomstat.h"
gamestate_t gamestate  ;
#line 208 "doomstat.h"
int gametic  ;
#line 212 "doomstat.h"
player_t players[4]  ;
#line 215 "doomstat.h"
boolean playeringame[4]  ;
#line 228 "doomstat.h"
wbstartstruct_t wminfo  ;
#line 260 "doomstat.h"
int bodyqueslot  ;
#line 114 "d_event.h"
gameaction_t gameaction  ;
#line 34 "p_saveg.h"
void P_ArchivePlayers(void) ;
#line 35
void P_UnArchivePlayers(void) ;
#line 36
void P_ArchiveWorld(void) ;
#line 37
void P_UnArchiveWorld(void) ;
#line 38
void P_ArchiveThinkers(void) ;
#line 39
void P_UnArchiveThinkers(void) ;
#line 40
void P_ArchiveSpecials(void) ;
#line 41
void P_UnArchiveSpecials(void) ;
#line 43
byte *save_p ;
#line 35 "p_tick.h"
void P_Ticker(void) ;
#line 70 "p_local.h"
thinker_t thinkercap ;
#line 73
void P_InitThinkers(void) ;
#line 74
void P_AddThinker(thinker_t *thinker ) ;
#line 75
void P_RemoveThinker(thinker_t *thinker ) ;
#line 81
void P_SetupPsprites(player_t *player ) ;
#line 82
void P_MovePsprites(player_t *player ) ;
#line 83
void P_DropWeapon(player_t *player ) ;
#line 89
void P_PlayerThink(player_t *player ) ;
#line 101
mapthing_t itemrespawnque[128] ;
#line 102
int itemrespawntime[128] ;
#line 103
int iquehead ;
#line 104
int iquetail ;
#line 107
void P_RespawnSpecials(void) ;
#line 109
mobj_t *P_SpawnMobj(fixed_t x___0 , fixed_t y___1 , fixed_t z , mobjtype_t type ) ;
#line 116
void P_RemoveMobj(mobj_t *mobj ) ;
#line 117
boolean P_SetMobjState(mobj_t *mobj , statenum_t state___0 ) ;
#line 118
void P_MobjThinker(mobj_t *mobj ) ;
#line 120
void P_SpawnPuff(fixed_t x___0 , fixed_t y___1 , fixed_t z ) ;
#line 121
void P_SpawnBlood(fixed_t x___0 , fixed_t y___1 , fixed_t z , int damage ) ;
#line 122
mobj_t *P_SpawnMissile(mobj_t *source , mobj_t *dest , mobjtype_t type ) ;
#line 123
void P_SpawnPlayerMissile(mobj_t *source , mobjtype_t type ) ;
#line 129
void P_NoiseAlert(mobj_t *target , mobj_t *emmiter ) ;
#line 156
intercept_t intercepts[128] ;
#line 157
intercept_t *intercept_p ;
#line 161
fixed_t P_AproxDistance(fixed_t dx , fixed_t dy ) ;
#line 162
int P_PointOnLineSide(fixed_t x___0 , fixed_t y___1 , line_t *line ) ;
#line 163
int P_PointOnDivlineSide(fixed_t x___0 , fixed_t y___1 , divline_t *line ) ;
#line 164
void P_MakeDivline(line_t *li , divline_t *dl ) ;
#line 165
fixed_t P_InterceptVector(divline_t *v2 , divline_t *v1 ) ;
#line 166
int P_BoxOnLineSide(fixed_t *tmbox , line_t *ld ) ;
#line 168
fixed_t opentop ;
#line 169
fixed_t openbottom ;
#line 170
fixed_t openrange ;
#line 171
fixed_t lowfloor ;
#line 173
void P_LineOpening(line_t *linedef___0 ) ;
#line 175
boolean P_BlockLinesIterator(int x___0 , int y___1 , boolean (*func)(line_t * ) ) ;
#line 176
boolean P_BlockThingsIterator(int x___0 , int y___1 , boolean (*func)(mobj_t * ) ) ;
#line 182
divline_t trace ;
#line 184
boolean P_PathTraverse(fixed_t x1 , fixed_t y1___0 , fixed_t x2 , fixed_t y2 , int flags ,
                       boolean (*trav)(intercept_t * ) ) ;
#line 193
void P_UnsetThingPosition(mobj_t *thing ) ;
#line 194
void P_SetThingPosition(mobj_t *thing ) ;
#line 203
boolean floatok ;
#line 204
fixed_t tmfloorz ;
#line 205
fixed_t tmceilingz ;
#line 208
line_t *ceilingline ;
#line 210
boolean P_CheckPosition(mobj_t *thing , fixed_t x___0 , fixed_t y___1 ) ;
#line 211
boolean P_TryMove(mobj_t *thing , fixed_t x___0 , fixed_t y___1 ) ;
#line 212
boolean P_TeleportMove(mobj_t *thing , fixed_t x___0 , fixed_t y___1 ) ;
#line 213
void P_SlideMove(mobj_t *mo ) ;
#line 214
boolean P_CheckSight(mobj_t *t1 , mobj_t *t2 ) ;
#line 215
void P_UseLines(player_t *player ) ;
#line 217
boolean P_ChangeSector(sector_t *sector , boolean crunch ) ;
#line 219
mobj_t *linetarget ;
#line 221
fixed_t P_AimLineAttack(mobj_t *t1 , angle_t angle , fixed_t distance ) ;
#line 227
void P_LineAttack(mobj_t *t1 , angle_t angle , fixed_t distance , fixed_t slope ,
                  int damage ) ;
#line 235
void P_RadiusAttack(mobj_t *spot , mobj_t *source , int damage ) ;
#line 246
byte *rejectmatrix ;
#line 247
short *blockmaplump ;
#line 248
short *blockmap ;
#line 249
int bmapwidth ;
#line 250
int bmapheight ;
#line 251
fixed_t bmaporgx ;
#line 252
fixed_t bmaporgy ;
#line 253
mobj_t **blocklinks ;
#line 261
int clipammo[4] ;
#line 263
void P_TouchSpecialThing(mobj_t *special , mobj_t *toucher ) ;
#line 268
void P_DamageMobj(mobj_t *target , mobj_t *inflictor , mobj_t *source , int damage ) ;
#line 33 "p_spec.h"
boolean levelTimer ;
#line 34
int levelTimeCount ;
#line 42
void P_InitPicAnims(void) ;
#line 45
void P_SpawnSpecials(void) ;
#line 48
void P_UpdateSpecials(void) ;
#line 51
boolean P_UseSpecialLine(mobj_t *thing , line_t *line , int side ) ;
#line 57
void P_ShootSpecialLine(mobj_t *thing , line_t *line ) ;
#line 62
void P_CrossSpecialLine(int linenum , int side , mobj_t *thing ) ;
#line 68
void P_PlayerInSpecialSector(player_t *player ) ;
#line 70
int twoSided(int sector , int line ) ;
#line 75
sector_t *getSector(int currentSector , int line , int side ) ;
#line 81
side_t *getSide(int currentSector , int line , int side ) ;
#line 87
fixed_t P_FindLowestFloorSurrounding(sector_t *sec ) ;
#line 88
fixed_t P_FindHighestFloorSurrounding(sector_t *sec ) ;
#line 90
fixed_t P_FindNextHighestFloor(sector_t *sec , int currentheight ) ;
#line 95
fixed_t P_FindLowestCeilingSurrounding(sector_t *sec ) ;
#line 96
fixed_t P_FindHighestCeilingSurrounding(sector_t *sec ) ;
#line 98
int P_FindSectorFromLineTag(line_t *line , int start ) ;
#line 103
int P_FindMinSurroundingLight(sector_t *sector , int max ) ;
#line 108
sector_t *getNextSector(line_t *line , sector_t *sec ) ;
#line 117
int EV_DoDonut(line_t *line ) ;
#line 181
void P_SpawnFireFlicker(sector_t *sector ) ;
#line 182
void T_LightFlash(lightflash_t *flash ) ;
#line 183
void P_SpawnLightFlash(sector_t *sector ) ;
#line 184
void T_StrobeFlash(strobe_t *flash ) ;
#line 186
void P_SpawnStrobeFlash(sector_t *sector , int fastOrSlow , int inSync ) ;
#line 192
void EV_StartLightStrobing(line_t *line ) ;
#line 193
void EV_TurnTagLightsOff(line_t *line ) ;
#line 195
void EV_LightTurnOn(line_t *line , int bright ) ;
#line 200
void T_Glow(glow_t *g ) ;
#line 201
void P_SpawnGlowingLight(sector_t *sector ) ;
#line 249
button_t buttonlist[16] ;
#line 251
void P_ChangeSwitchTexture(line_t *line , int useAgain ) ;
#line 256
void P_InitSwitchList(void) ;
#line 309
plat_t *activeplats[30] ;
#line 311
void T_PlatRaise(plat_t *plat ) ;
#line 313
int EV_DoPlat(line_t *line , plattype_e type , int amount ) ;
#line 319
void P_AddActivePlat(plat_t *plat ) ;
#line 320
void P_RemoveActivePlat(plat_t *plat ) ;
#line 321
void EV_StopPlat(line_t *line ) ;
#line 322
void P_ActivateInStasis(int tag ) ;
#line 367
void EV_VerticalDoor(line_t *line , mobj_t *thing ) ;
#line 372
int EV_DoDoor(line_t *line , vldoor_e type ) ;
#line 377
int EV_DoLockedDoor(line_t *line , vldoor_e type , mobj_t *thing ) ;
#line 383
void T_VerticalDoor(vldoor_t *door ) ;
#line 384
void P_SpawnDoorCloseIn30(sector_t *sec ) ;
#line 386
void P_SpawnDoorRaiseIn5Mins(sector_t *sec , int secnum ) ;
#line 520
ceiling_t *activeceilings[30] ;
#line 522
int EV_DoCeiling(line_t *line , ceiling_e type ) ;
#line 527
void T_MoveCeiling(ceiling_t *ceiling ) ;
#line 528
void P_AddActiveCeiling(ceiling_t *c ) ;
#line 529
void P_RemoveActiveCeiling(ceiling_t *c ) ;
#line 530
int EV_CeilingCrushStop(line_t *line ) ;
#line 531
void P_ActivateInStasisCeiling(line_t *line ) ;
#line 610
result_e T_MovePlane(sector_t *sector , fixed_t speed , fixed_t dest , boolean crush ,
                     int floorOrCeiling , int direction ) ;
#line 619
int EV_BuildStairs(line_t *line , stair_e type ) ;
#line 624
int EV_DoFloor(line_t *line , floor_e floortype ) ;
#line 629
void T_MoveFloor(floormove_t *floor___0 ) ;
#line 634
int EV_Teleport(line_t *line , int side , mobj_t *thing ) ;
#line 37 "r_sky.h"
int skytexture ;
#line 38
int skytexturemid ;
#line 41
void R_InitSkyMap(void) ;
#line 80 "g_game.c"
void G_ReadDemoTiccmd(ticcmd_t *cmd ) ;
#line 81
void G_WriteDemoTiccmd(ticcmd_t *cmd ) ;
#line 82
void G_PlayerReborn(int player ) ;
#line 85
void G_DoReborn(int playernum ) ;
#line 87
void G_DoLoadLevel(void) ;
#line 88
void G_DoNewGame(void) ;
#line 90
void G_DoPlayDemo(void) ;
#line 91
void G_DoCompleted(void) ;
#line 92
extern void G_DoVictory(void) ;
#line 93
void G_DoWorldDone(void) ;
#line 94
void G_DoSaveGame(void) ;
#line 105 "g_game.c"
boolean sendpause  ;
#line 106 "g_game.c"
boolean sendsave  ;
#line 109 "g_game.c"
boolean timingdemo  ;
#line 112 "g_game.c"
int starttime  ;
#line 127 "g_game.c"
char demoname[32]  ;
#line 130 "g_game.c"
boolean netdemo  ;
#line 131 "g_game.c"
byte *demobuffer  ;
#line 132 "g_game.c"
byte *demo_p  ;
#line 133 "g_game.c"
byte *demoend  ;
#line 136 "g_game.c"
boolean precache  =    (boolean )1;
#line 140 "g_game.c"
short consistancy[4][12]  ;
#line 142 "g_game.c"
byte *savebuffer  ;
#line 148 "g_game.c"
int key_right  ;
#line 149 "g_game.c"
int key_left  ;
#line 151 "g_game.c"
int key_up  ;
#line 152 "g_game.c"
int key_down  ;
#line 153 "g_game.c"
int key_strafeleft  ;
#line 154 "g_game.c"
int key_straferight  ;
#line 155 "g_game.c"
int key_fire  ;
#line 156 "g_game.c"
int key_use  ;
#line 157 "g_game.c"
int key_strafe  ;
#line 158 "g_game.c"
int key_speed  ;
#line 160 "g_game.c"
int mousebfire  ;
#line 161 "g_game.c"
int mousebstrafe  ;
#line 162 "g_game.c"
int mousebforward  ;
#line 164 "g_game.c"
int joybfire  ;
#line 165 "g_game.c"
int joybstrafe  ;
#line 166 "g_game.c"
int joybuse  ;
#line 167 "g_game.c"
int joybspeed  ;
#line 175 "g_game.c"
int forwardmove[2]  = {      0x19,      0x32};
#line 176 "g_game.c"
int sidemove[2]  = {      0x18,      0x28};
#line 177 "g_game.c"
fixed_t angleturn[3]  = {      640,      1280,      320};
#line 183 "g_game.c"
boolean gamekeydown[256]  ;
#line 184 "g_game.c"
int turnheld  ;
#line 186 "g_game.c"
boolean mousearray[4]  ;
#line 187 "g_game.c"
boolean *mousebuttons  =    & mousearray[1];
#line 190 "g_game.c"
int mousex  ;
#line 191 "g_game.c"
int mousey  ;
#line 193 "g_game.c"
int dclicktime  ;
#line 194 "g_game.c"
int dclickstate  ;
#line 195 "g_game.c"
int dclicks  ;
#line 196 "g_game.c"
int dclicktime2  ;
#line 197 "g_game.c"
int dclickstate2  ;
#line 198 "g_game.c"
int dclicks2  ;
#line 201 "g_game.c"
int joyxmove  ;
#line 202 "g_game.c"
int joyymove  ;
#line 203 "g_game.c"
boolean joyarray[5]  ;
#line 204 "g_game.c"
boolean *joybuttons  =    & joyarray[1];
#line 206 "g_game.c"
int savegameslot  ;
#line 207 "g_game.c"
char savedescription[32]  ;
#line 212 "g_game.c"
mobj_t *bodyque[32]  ;
#line 215 "g_game.c"
void *statcopy  ;
#line 219 "g_game.c"
int G_CmdChecksum(ticcmd_t *cmd ) 
{ 
  int i ;
  int sum ;

  {
#line 222
  sum = 0;
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! ((unsigned long )i < sizeof(*cmd) / 4UL - 1UL)) {
#line 224
      goto while_break;
    }
#line 225
    sum += *((int *)cmd + i);
#line 224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  return (sum);
}
}
#line 237 "g_game.c"
void G_BuildTiccmd(ticcmd_t *cmd ) 
{ 
  int i ;
  boolean strafe ;
  boolean bstrafe ;
  int speed ;
  int tspeed ;
  int forward ;
  int side ;
  ticcmd_t *base ;
  int tmp ;
  int tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;

  {
#line 249
  base = I_BaseTiccmd();
#line 250
  memcpy((void * __restrict  )cmd, (void const   * __restrict  )base, (size_t )sizeof(*cmd));
#line 252
  cmd->consistancy = consistancy[consoleplayer][maketic % 12];
#line 256
  if (gamekeydown[key_strafe]) {
#line 256
    goto _L___0;
  } else
#line 256
  if (*(mousebuttons + mousebstrafe)) {
    _L___0: /* CIL Label */ 
#line 256
    goto _L;
  } else
#line 256
  if (*(joybuttons + joybstrafe)) {
    _L: /* CIL Label */ 
#line 256
    tmp = 1;
  } else {
#line 256
    tmp = 0;
  }
#line 256
  strafe = (boolean )tmp;
#line 258
  if (gamekeydown[key_speed]) {
#line 258
    goto _L___1;
  } else
#line 258
  if (*(joybuttons + joybspeed)) {
    _L___1: /* CIL Label */ 
#line 258
    tmp___0 = 1;
  } else {
#line 258
    tmp___0 = 0;
  }
#line 258
  speed = tmp___0;
#line 260
  side = 0;
#line 260
  forward = side;
#line 264
  if (joyxmove < 0) {
#line 264
    goto _L___4;
  } else
#line 264
  if (joyxmove > 0) {
    _L___4: /* CIL Label */ 
#line 264
    goto _L___3;
  } else
#line 264
  if (gamekeydown[key_right]) {
    _L___3: /* CIL Label */ 
#line 264
    goto _L___2;
  } else
#line 264
  if (gamekeydown[key_left]) {
    _L___2: /* CIL Label */ 
#line 268
    turnheld += ticdup;
  } else {
#line 270
    turnheld = 0;
  }
#line 272
  if (turnheld < 6) {
#line 273
    tspeed = 2;
  } else {
#line 275
    tspeed = speed;
  }
#line 278
  if (strafe) {
#line 280
    if (gamekeydown[key_right]) {
#line 283
      side += sidemove[speed];
    }
#line 285
    if (gamekeydown[key_left]) {
#line 288
      side -= sidemove[speed];
    }
#line 290
    if (joyxmove > 0) {
#line 291
      side += sidemove[speed];
    }
#line 292
    if (joyxmove < 0) {
#line 293
      side -= sidemove[speed];
    }
  } else {
#line 298
    if (gamekeydown[key_right]) {
#line 299
      cmd->angleturn = (short )((int )cmd->angleturn - angleturn[tspeed]);
    }
#line 300
    if (gamekeydown[key_left]) {
#line 301
      cmd->angleturn = (short )((int )cmd->angleturn + angleturn[tspeed]);
    }
#line 302
    if (joyxmove > 0) {
#line 303
      cmd->angleturn = (short )((int )cmd->angleturn - angleturn[tspeed]);
    }
#line 304
    if (joyxmove < 0) {
#line 305
      cmd->angleturn = (short )((int )cmd->angleturn + angleturn[tspeed]);
    }
  }
#line 308
  if (gamekeydown[key_up]) {
#line 311
    forward += forwardmove[speed];
  }
#line 313
  if (gamekeydown[key_down]) {
#line 316
    forward -= forwardmove[speed];
  }
#line 318
  if (joyymove < 0) {
#line 319
    forward += forwardmove[speed];
  }
#line 320
  if (joyymove > 0) {
#line 321
    forward -= forwardmove[speed];
  }
#line 322
  if (gamekeydown[key_straferight]) {
#line 323
    side += sidemove[speed];
  }
#line 324
  if (gamekeydown[key_strafeleft]) {
#line 325
    side -= sidemove[speed];
  }
#line 328
  tmp___1 = HU_dequeueChatChar();
#line 328
  cmd->chatchar = (byte )tmp___1;
#line 330
  if (gamekeydown[key_fire]) {
#line 330
    goto _L___6;
  } else
#line 330
  if (*(mousebuttons + mousebfire)) {
    _L___6: /* CIL Label */ 
#line 330
    goto _L___5;
  } else
#line 330
  if (*(joybuttons + joybfire)) {
    _L___5: /* CIL Label */ 
#line 332
    cmd->buttons = (byte )((int )cmd->buttons | 1);
  }
#line 334
  if (gamekeydown[key_use]) {
#line 334
    goto _L___7;
  } else
#line 334
  if (*(joybuttons + joybuse)) {
    _L___7: /* CIL Label */ 
#line 336
    cmd->buttons = (byte )((int )cmd->buttons | 2);
#line 338
    dclicks = 0;
  }
#line 342
  i = 0;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! (i < 8)) {
#line 342
      goto while_break;
    }
#line 343
    if (gamekeydown[49 + i]) {
#line 345
      cmd->buttons = (byte )((int )cmd->buttons | 4);
#line 346
      cmd->buttons = (byte )((int )cmd->buttons | (i << 3));
#line 347
      goto while_break;
    }
#line 342
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  if (*(mousebuttons + mousebforward)) {
#line 352
    forward += forwardmove[speed];
  }
#line 355
  if ((unsigned int )*(mousebuttons + mousebforward) != (unsigned int )dclickstate) {
#line 355
    if (dclicktime > 1) {
#line 357
      dclickstate = (int )*(mousebuttons + mousebforward);
#line 358
      if (dclickstate) {
#line 359
        dclicks ++;
      }
#line 360
      if (dclicks == 2) {
#line 362
        cmd->buttons = (byte )((int )cmd->buttons | 2);
#line 363
        dclicks = 0;
      } else {
#line 366
        dclicktime = 0;
      }
    } else {
#line 355
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
#line 370
    dclicktime += ticdup;
#line 371
    if (dclicktime > 20) {
#line 373
      dclicks = 0;
#line 374
      dclickstate = 0;
    }
  }
#line 379
  if (*(mousebuttons + mousebstrafe)) {
#line 379
    goto _L___9;
  } else
#line 379
  if (*(joybuttons + joybstrafe)) {
    _L___9: /* CIL Label */ 
#line 379
    tmp___2 = 1;
  } else {
#line 379
    tmp___2 = 0;
  }
#line 379
  bstrafe = (boolean )tmp___2;
#line 382
  if ((unsigned int )bstrafe != (unsigned int )dclickstate2) {
#line 382
    if (dclicktime2 > 1) {
#line 384
      dclickstate2 = (int )bstrafe;
#line 385
      if (dclickstate2) {
#line 386
        dclicks2 ++;
      }
#line 387
      if (dclicks2 == 2) {
#line 389
        cmd->buttons = (byte )((int )cmd->buttons | 2);
#line 390
        dclicks2 = 0;
      } else {
#line 393
        dclicktime2 = 0;
      }
    } else {
#line 382
      goto _L___10;
    }
  } else {
    _L___10: /* CIL Label */ 
#line 397
    dclicktime2 += ticdup;
#line 398
    if (dclicktime2 > 20) {
#line 400
      dclicks2 = 0;
#line 401
      dclickstate2 = 0;
    }
  }
#line 405
  forward += mousey;
#line 406
  if (strafe) {
#line 407
    side += mousex * 2;
  } else {
#line 409
    cmd->angleturn = (short )((int )cmd->angleturn - mousex * 0x8);
  }
#line 411
  mousey = 0;
#line 411
  mousex = mousey;
#line 413
  if (forward > forwardmove[1]) {
#line 414
    forward = forwardmove[1];
  } else
#line 415
  if (forward < - forwardmove[1]) {
#line 416
    forward = - forwardmove[1];
  }
#line 417
  if (side > forwardmove[1]) {
#line 418
    side = forwardmove[1];
  } else
#line 419
  if (side < - forwardmove[1]) {
#line 420
    side = - forwardmove[1];
  }
#line 422
  cmd->forwardmove = (char )((int )cmd->forwardmove + forward);
#line 423
  cmd->sidemove = (char )((int )cmd->sidemove + side);
#line 426
  if (sendpause) {
#line 428
    sendpause = (boolean )0;
#line 429
    cmd->buttons = (byte )129;
  }
#line 432
  if (sendsave) {
#line 434
    sendsave = (boolean )0;
#line 435
    cmd->buttons = (byte )(130 | (savegameslot << 2));
  }
#line 437
  return;
}
}
#line 445 "g_game.c"
void G_DoLoadLevel(void) 
{ 
  int i ;

  {
#line 454
  skyflatnum = R_FlatNumForName("F_SKY1");
#line 458
  if ((unsigned int )gamemode == 2U) {
#line 458
    goto _L___0;
  } else
#line 458
  if ((unsigned int )gamemode == 2U) {
    _L___0: /* CIL Label */ 
#line 458
    goto _L;
  } else
#line 458
  if ((unsigned int )gamemode == 3U) {
    _L: /* CIL Label */ 
#line 462
    skytexture = R_TextureNumForName("SKY3");
#line 463
    if (gamemap < 12) {
#line 464
      skytexture = R_TextureNumForName("SKY1");
    } else
#line 466
    if (gamemap < 21) {
#line 467
      skytexture = R_TextureNumForName("SKY2");
    }
  }
#line 470
  levelstarttic = gametic;
#line 472
  if ((unsigned int )wipegamestate == 0U) {
#line 473
    wipegamestate = (gamestate_t )-1;
  }
#line 475
  gamestate = (gamestate_t )0;
#line 477
  i = 0;
  {
#line 477
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    if (! (i < 4)) {
#line 477
      goto while_break;
    }
#line 479
    if (playeringame[i]) {
#line 479
      if ((unsigned int )players[i].playerstate == 1U) {
#line 480
        players[i].playerstate = (playerstate_t )2;
      } else {
#line 479
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
#line 481
    memset((void *)(players[i].frags), 0, (size_t )sizeof(players[i].frags));
#line 477
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  P_SetupLevel(gameepisode, gamemap, 0, gameskill);
#line 485
  displayplayer = consoleplayer;
#line 486
  starttime = I_GetTime();
#line 487
  gameaction = (gameaction_t )0;
#line 488
  Z_CheckHeap();
#line 491
  memset((void *)(gamekeydown), 0, (size_t )sizeof(gamekeydown));
#line 492
  joyymove = 0;
#line 492
  joyxmove = joyymove;
#line 493
  mousey = 0;
#line 493
  mousex = mousey;
#line 494
  paused = (boolean )0;
#line 494
  sendsave = paused;
#line 494
  sendpause = sendsave;
#line 495
  memset((void *)mousebuttons, 0, (size_t )sizeof(mousebuttons));
#line 496
  memset((void *)joybuttons, 0, (size_t )sizeof(joybuttons));
#line 497
  return;
}
}
#line 504 "g_game.c"
boolean G_Responder(event_t *ev ) 
{ 
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;

  {
#line 507
  if ((unsigned int )gamestate == 0U) {
#line 507
    if ((unsigned int )ev->type == 0U) {
#line 507
      if (ev->data1 == 216) {
#line 507
        if (singledemo) {
#line 507
          goto _L___1;
        } else
#line 507
        if (! deathmatch) {
          _L___1: /* CIL Label */ 
          {
#line 511
          while (1) {
            while_continue: /* CIL Label */ ;
#line 513
            displayplayer ++;
#line 514
            if (displayplayer == 4) {
#line 515
              displayplayer = 0;
            }
#line 511
            if (! playeringame[displayplayer]) {
#line 511
              if (! (displayplayer != consoleplayer)) {
#line 511
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 511
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 517
          return ((boolean )1);
        } else {
#line 507
          goto _L___3;
        }
      } else {
#line 507
        goto _L___3;
      }
    } else {
#line 507
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    _L___2: /* CIL Label */ 
    _L___0: /* CIL Label */ ;
  }
#line 521
  if ((unsigned int )gameaction == 0U) {
#line 521
    if (! singledemo) {
#line 521
      if (demoplayback) {
#line 521
        goto _L___9;
      } else
#line 521
      if ((unsigned int )gamestate == 3U) {
        _L___9: /* CIL Label */ 
#line 525
        if ((unsigned int )ev->type == 0U) {
#line 525
          goto _L___6;
        } else
#line 525
        if ((unsigned int )ev->type == 2U) {
#line 525
          if (ev->data1) {
            _L___6: /* CIL Label */ 
#line 525
            goto _L___4;
          } else {
#line 525
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
#line 525
        if ((unsigned int )ev->type == 3U) {
#line 525
          if (ev->data1) {
            _L___4: /* CIL Label */ 
#line 529
            M_StartControlPanel();
#line 530
            return ((boolean )1);
          } else {
#line 525
            goto _L___5;
          }
        } else {
          _L___5: /* CIL Label */ ;
        }
#line 532
        return ((boolean )0);
      } else {
#line 521
        goto _L___10;
      }
    } else {
#line 521
      goto _L___10;
    }
  } else {
    _L___10: /* CIL Label */ 
    _L___8: /* CIL Label */ ;
  }
#line 535
  if ((unsigned int )gamestate == 0U) {
#line 544
    tmp = HU_Responder(ev);
#line 544
    if (tmp) {
#line 545
      return ((boolean )1);
    }
#line 546
    tmp___0 = ST_Responder(ev);
#line 546
    if (tmp___0) {
#line 547
      return ((boolean )1);
    }
#line 548
    tmp___1 = AM_Responder(ev);
#line 548
    if (tmp___1) {
#line 549
      return ((boolean )1);
    }
  }
#line 552
  if ((unsigned int )gamestate == 2U) {
#line 554
    tmp___2 = F_Responder(ev);
#line 554
    if (tmp___2) {
#line 555
      return ((boolean )1);
    }
  }
  {
#line 560
  if ((unsigned int )ev->type == 0U) {
#line 560
    goto case_0;
  }
#line 570
  if ((unsigned int )ev->type == 1U) {
#line 570
    goto case_1;
  }
#line 575
  if ((unsigned int )ev->type == 2U) {
#line 575
    goto case_2;
  }
#line 583
  if ((unsigned int )ev->type == 3U) {
#line 583
    goto case_3;
  }
#line 592
  goto switch_default;
  case_0: /* CIL Label */ 
#line 561
  if (ev->data1 == 0xff) {
#line 563
    sendpause = (boolean )1;
#line 564
    return ((boolean )1);
  }
#line 566
  if (ev->data1 < 256) {
#line 567
    gamekeydown[ev->data1] = (boolean )1;
  }
#line 568
  return ((boolean )1);
  case_1: /* CIL Label */ 
#line 571
  if (ev->data1 < 256) {
#line 572
    gamekeydown[ev->data1] = (boolean )0;
  }
#line 573
  return ((boolean )0);
  case_2: /* CIL Label */ 
#line 576
  *(mousebuttons + 0) = (boolean )(ev->data1 & 1);
#line 577
  *(mousebuttons + 1) = (boolean )(ev->data1 & 2);
#line 578
  *(mousebuttons + 2) = (boolean )(ev->data1 & 4);
#line 579
  mousex = (ev->data2 * (mouseSensitivity + 5)) / 10;
#line 580
  mousey = (ev->data3 * (mouseSensitivity + 5)) / 10;
#line 581
  return ((boolean )1);
  case_3: /* CIL Label */ 
#line 584
  *(joybuttons + 0) = (boolean )(ev->data1 & 1);
#line 585
  *(joybuttons + 1) = (boolean )(ev->data1 & 2);
#line 586
  *(joybuttons + 2) = (boolean )(ev->data1 & 4);
#line 587
  *(joybuttons + 3) = (boolean )(ev->data1 & 8);
#line 588
  joyxmove = ev->data2;
#line 589
  joyymove = ev->data3;
#line 590
  return ((boolean )1);
  switch_default: /* CIL Label */ 
#line 593
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 596
  return ((boolean )0);
}
}
#line 675 "g_game.c"
static char turbomessage[80]  ;
#line 676
char *player_names[4] ;
#line 605 "g_game.c"
void G_Ticker(void) 
{ 
  int i ;
  int buf ;
  ticcmd_t *cmd ;

  {
#line 612
  i = 0;
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 612
    if (! (i < 4)) {
#line 612
      goto while_break;
    }
#line 613
    if (playeringame[i]) {
#line 613
      if ((unsigned int )players[i].playerstate == 2U) {
#line 614
        G_DoReborn(i);
      } else {
#line 613
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 612
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 617
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 617
    if (! ((unsigned int )gameaction != 0U)) {
#line 617
      goto while_break___0;
    }
    {
#line 621
    if ((unsigned int )gameaction == 1U) {
#line 621
      goto case_1;
    }
#line 624
    if ((unsigned int )gameaction == 2U) {
#line 624
      goto case_2;
    }
#line 627
    if ((unsigned int )gameaction == 3U) {
#line 627
      goto case_3;
    }
#line 630
    if ((unsigned int )gameaction == 4U) {
#line 630
      goto case_4;
    }
#line 633
    if ((unsigned int )gameaction == 5U) {
#line 633
      goto case_5;
    }
#line 636
    if ((unsigned int )gameaction == 6U) {
#line 636
      goto case_6;
    }
#line 639
    if ((unsigned int )gameaction == 7U) {
#line 639
      goto case_7;
    }
#line 642
    if ((unsigned int )gameaction == 8U) {
#line 642
      goto case_8;
    }
#line 645
    if ((unsigned int )gameaction == 9U) {
#line 645
      goto case_9;
    }
#line 649
    if ((unsigned int )gameaction == 0U) {
#line 649
      goto case_0;
    }
#line 619
    goto switch_break;
    case_1: /* CIL Label */ 
#line 622
    G_DoLoadLevel();
#line 623
    goto switch_break;
    case_2: /* CIL Label */ 
#line 625
    G_DoNewGame();
#line 626
    goto switch_break;
    case_3: /* CIL Label */ 
#line 628
    G_DoLoadGame();
#line 629
    goto switch_break;
    case_4: /* CIL Label */ 
#line 631
    G_DoSaveGame();
#line 632
    goto switch_break;
    case_5: /* CIL Label */ 
#line 634
    G_DoPlayDemo();
#line 635
    goto switch_break;
    case_6: /* CIL Label */ 
#line 637
    G_DoCompleted();
#line 638
    goto switch_break;
    case_7: /* CIL Label */ 
#line 640
    F_StartFinale();
#line 641
    goto switch_break;
    case_8: /* CIL Label */ 
#line 643
    G_DoWorldDone();
#line 644
    goto switch_break;
    case_9: /* CIL Label */ 
#line 646
    M_ScreenShot();
#line 647
    gameaction = (gameaction_t )0;
#line 648
    goto switch_break;
    case_0: /* CIL Label */ 
#line 650
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 656
  buf = (gametic / ticdup) % 12;
#line 658
  i = 0;
  {
#line 658
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 658
    if (! (i < 4)) {
#line 658
      goto while_break___1;
    }
#line 660
    if (playeringame[i]) {
#line 662
      cmd = & players[i].cmd;
#line 664
      memcpy((void * __restrict  )cmd, (void const   * __restrict  )(& netcmds[i][buf]),
             (size_t )sizeof(ticcmd_t ));
#line 666
      if (demoplayback) {
#line 667
        G_ReadDemoTiccmd(cmd);
      }
#line 668
      if (demorecording) {
#line 669
        G_WriteDemoTiccmd(cmd);
      }
#line 672
      if ((int )cmd->forwardmove > 0x32) {
#line 672
        if (! (gametic & 31)) {
#line 672
          if (((gametic >> 5) & 3) == i) {
#line 677
            sprintf((char * __restrict  )(turbomessage), (char const   * __restrict  )"%s is turbo!",
                    player_names[i]);
#line 678
            players[consoleplayer].message = turbomessage;
          } else {
#line 672
            goto _L___1;
          }
        } else {
#line 672
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        _L___0: /* CIL Label */ ;
      }
#line 681
      if (netgame) {
#line 681
        if (! netdemo) {
#line 681
          if (! (gametic % ticdup)) {
#line 683
            if (gametic > 12) {
#line 683
              if ((int )consistancy[i][buf] != (int )cmd->consistancy) {
#line 686
                I_Error("consistency failure (%i should be %i)", (int )cmd->consistancy,
                        (int )consistancy[i][buf]);
              } else {
#line 683
                goto _L___2;
              }
            } else {
              _L___2: /* CIL Label */ ;
            }
#line 689
            if (players[i].mo) {
#line 690
              consistancy[i][buf] = (short )(players[i].mo)->x;
            } else {
#line 692
              consistancy[i][buf] = (short )rndindex;
            }
          } else {
#line 681
            goto _L___4;
          }
        } else {
#line 681
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
        _L___3: /* CIL Label */ ;
      }
    }
#line 658
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 698
  i = 0;
  {
#line 698
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 698
    if (! (i < 4)) {
#line 698
      goto while_break___2;
    }
#line 700
    if (playeringame[i]) {
#line 702
      if ((int )players[i].cmd.buttons & 128) {
        {
#line 706
        if (((int )players[i].cmd.buttons & 3) == 1) {
#line 706
          goto case_1___0;
        }
#line 714
        if (((int )players[i].cmd.buttons & 3) == 2) {
#line 714
          goto case_2___0;
        }
#line 704
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
#line 707
        paused = (boolean )((unsigned int )paused ^ 1U);
#line 708
        if (paused) {
#line 709
          S_PauseSound();
        } else {
#line 711
          S_ResumeSound();
        }
#line 712
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
#line 715
        if (! savedescription[0]) {
#line 716
          strcpy((char * __restrict  )(savedescription), (char const   * __restrict  )"NET GAME");
        }
#line 717
        savegameslot = ((int )players[i].cmd.buttons & 28) >> 2;
#line 719
        gameaction = (gameaction_t )4;
#line 720
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
#line 698
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 729
  if ((unsigned int )gamestate == 0U) {
#line 729
    goto case_0___0;
  }
#line 736
  if ((unsigned int )gamestate == 1U) {
#line 736
    goto case_1___1;
  }
#line 740
  if ((unsigned int )gamestate == 2U) {
#line 740
    goto case_2___1;
  }
#line 744
  if ((unsigned int )gamestate == 3U) {
#line 744
    goto case_3___0;
  }
#line 727
  goto switch_break___1;
  case_0___0: /* CIL Label */ 
#line 730
  P_Ticker();
#line 731
  ST_Ticker();
#line 732
  AM_Ticker();
#line 733
  HU_Ticker();
#line 734
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 737
  WI_Ticker();
#line 738
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 741
  F_Ticker();
#line 742
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
#line 745
  D_PageTicker();
#line 746
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 748
  return;
}
}
#line 761 "g_game.c"
void G_InitPlayer(int player ) 
{ 
  player_t *p___0 ;

  {
#line 766
  p___0 = & players[player];
#line 769
  G_PlayerReborn(player);
#line 771
  return;
}
}
#line 779 "g_game.c"
void G_PlayerFinishLevel(int player ) 
{ 
  player_t *p___0 ;

  {
#line 783
  p___0 = & players[player];
#line 785
  memset((void *)(p___0->powers), 0, (size_t )sizeof(p___0->powers));
#line 786
  memset((void *)(p___0->cards), 0, (size_t )sizeof(p___0->cards));
#line 787
  (p___0->mo)->flags &= -262145;
#line 788
  p___0->extralight = 0;
#line 789
  p___0->fixedcolormap = 0;
#line 790
  p___0->damagecount = 0;
#line 791
  p___0->bonuscount = 0;
#line 792
  return;
}
}
#line 800 "g_game.c"
void G_PlayerReborn(int player ) 
{ 
  player_t *p___0 ;
  int i ;
  int frags___0[4] ;
  int killcount ;
  int itemcount ;
  int secretcount ;
  int tmp ;
  weapontype_t tmp___0 ;

  {
#line 809
  memcpy((void * __restrict  )(frags___0), (void const   * __restrict  )(players[player].frags),
         (size_t )sizeof(frags___0));
#line 810
  killcount = players[player].killcount;
#line 811
  itemcount = players[player].itemcount;
#line 812
  secretcount = players[player].secretcount;
#line 814
  p___0 = & players[player];
#line 815
  memset((void *)p___0, 0, (size_t )sizeof(*p___0));
#line 817
  memcpy((void * __restrict  )(players[player].frags), (void const   * __restrict  )(frags___0),
         (size_t )sizeof(players[player].frags));
#line 818
  players[player].killcount = killcount;
#line 819
  players[player].itemcount = itemcount;
#line 820
  players[player].secretcount = secretcount;
#line 822
  tmp = 1;
#line 822
  p___0->attackdown = tmp;
#line 822
  p___0->usedown = tmp;
#line 823
  p___0->playerstate = (playerstate_t )0;
#line 824
  p___0->health = 100;
#line 825
  tmp___0 = (weapontype_t )1;
#line 825
  p___0->pendingweapon = tmp___0;
#line 825
  p___0->readyweapon = tmp___0;
#line 826
  p___0->weaponowned[0] = (boolean )1;
#line 827
  p___0->weaponowned[1] = (boolean )1;
#line 828
  p___0->ammo[0] = 50;
#line 830
  i = 0;
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 830
    if (! (i < 4)) {
#line 830
      goto while_break;
    }
#line 831
    p___0->maxammo[i] = maxammo[i];
#line 830
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 833
  return;
}
}
#line 841
void P_SpawnPlayer(mapthing_t *mthing ) ;
#line 843 "g_game.c"
boolean G_CheckSpot(int playernum , mapthing_t *mthing ) 
{ 
  fixed_t x___0 ;
  fixed_t y___1 ;
  subsector_t *ss ;
  unsigned int an ;
  mobj_t *mo ;
  int i ;
  boolean tmp ;

  {
#line 855
  if (! players[playernum].mo) {
#line 858
    i = 0;
    {
#line 858
    while (1) {
      while_continue: /* CIL Label */ ;
#line 858
      if (! (i < playernum)) {
#line 858
        goto while_break;
      }
#line 859
      if ((players[i].mo)->x == (int )mthing->x << 16) {
#line 859
        if ((players[i].mo)->y == (int )mthing->y << 16) {
#line 861
          return ((boolean )0);
        } else {
#line 859
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
#line 858
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 862
    return ((boolean )1);
  }
#line 865
  x___0 = (int )mthing->x << 16;
#line 866
  y___1 = (int )mthing->y << 16;
#line 868
  tmp = P_CheckPosition(players[playernum].mo, x___0, y___1);
#line 868
  if (! tmp) {
#line 869
    return ((boolean )0);
  }
#line 872
  if (bodyqueslot >= 32) {
#line 873
    P_RemoveMobj(bodyque[bodyqueslot % 32]);
  }
#line 874
  bodyque[bodyqueslot % 32] = players[playernum].mo;
#line 875
  bodyqueslot ++;
#line 878
  ss = R_PointInSubsector(x___0, y___1);
#line 879
  an = (unsigned int )(0x20000000 * ((int )mthing->angle / 45) >> 19);
#line 881
  mo = P_SpawnMobj(x___0 + 20 * *(finecosine + an), y___1 + 20 * finesine[an], (ss->sector)->floorheight,
                   (mobjtype_t )39);
#line 885
  if (players[consoleplayer].viewz != 1) {
#line 886
    S_StartSound((void *)mo, 35);
  }
#line 888
  return ((boolean )1);
}
}
#line 897 "g_game.c"
void G_DeathMatchSpawnPlayer(int playernum ) 
{ 
  int i ;
  int j ;
  int selections ;
  int tmp ;
  boolean tmp___0 ;

  {
#line 902
  selections = (int )(deathmatch_p - deathmatchstarts);
#line 903
  if (selections < 4) {
#line 904
    I_Error("Only %i deathmatch spots, 4 required", selections);
  }
#line 906
  j = 0;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! (j < 20)) {
#line 906
      goto while_break;
    }
#line 908
    tmp = P_Random();
#line 908
    i = tmp % selections;
#line 909
    tmp___0 = G_CheckSpot(playernum, & deathmatchstarts[i]);
#line 909
    if (tmp___0) {
#line 911
      deathmatchstarts[i].type = (short )(playernum + 1);
#line 912
      P_SpawnPlayer(& deathmatchstarts[i]);
#line 913
      return;
    }
#line 906
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 918
  P_SpawnPlayer(& playerstarts[playernum]);
#line 919
  return;
}
}
#line 924 "g_game.c"
void G_DoReborn(int playernum ) 
{ 
  int i ;
  boolean tmp ;
  boolean tmp___0 ;

  {
#line 928
  if (! netgame) {
#line 931
    gameaction = (gameaction_t )1;
  } else {
#line 938
    (players[playernum].mo)->player = (struct player_s *)((void *)0);
#line 941
    if (deathmatch) {
#line 943
      G_DeathMatchSpawnPlayer(playernum);
#line 944
      return;
    }
#line 947
    tmp = G_CheckSpot(playernum, & playerstarts[playernum]);
#line 947
    if (tmp) {
#line 949
      P_SpawnPlayer(& playerstarts[playernum]);
#line 950
      return;
    }
#line 954
    i = 0;
    {
#line 954
    while (1) {
      while_continue: /* CIL Label */ ;
#line 954
      if (! (i < 4)) {
#line 954
        goto while_break;
      }
#line 956
      tmp___0 = G_CheckSpot(playernum, & playerstarts[i]);
#line 956
      if (tmp___0) {
#line 958
        playerstarts[i].type = (short )(playernum + 1);
#line 959
        P_SpawnPlayer(& playerstarts[i]);
#line 960
        playerstarts[i].type = (short )(i + 1);
#line 961
        return;
      }
#line 954
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 965
    P_SpawnPlayer(& playerstarts[playernum]);
  }
#line 967
  return;
}
}
#line 970 "g_game.c"
void G_ScreenShot(void) 
{ 


  {
#line 972
  gameaction = (gameaction_t )9;
#line 973
  return;
}
}
#line 978 "g_game.c"
int pars[4][10]  = { {        0}, 
   {        0,        30,        75,        120, 
            90,        165,        180,        180, 
            30,        165}, 
   {        0,        90,        90,        90, 
            120,        90,        360,        240, 
            30,        170}, 
   {        0,        90,        45,        90, 
            150,        90,        90,        165, 
            30,        135}};
#line 987 "g_game.c"
int cpars[32]  = 
#line 987
  {      30,      90,      120,      120, 
        90,      150,      120,      120, 
        270,      90,      210,      150, 
        150,      150,      210,      150, 
        420,      150,      210,      150, 
        240,      150,      180,      150, 
        150,      300,      330,      420, 
        300,      180,      120,      30};
#line 999 "g_game.c"
boolean secretexit  ;
#line 1002 "g_game.c"
void G_ExitLevel(void) 
{ 


  {
#line 1004
  secretexit = (boolean )0;
#line 1005
  gameaction = (gameaction_t )6;
#line 1006
  return;
}
}
#line 1009 "g_game.c"
void G_SecretExitLevel(void) 
{ 
  int tmp ;

  {
#line 1012
  if ((unsigned int )gamemode == 2U) {
#line 1012
    tmp = W_CheckNumForName("map31");
#line 1012
    if (tmp < 0) {
#line 1014
      secretexit = (boolean )0;
    } else {
#line 1012
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1016
    secretexit = (boolean )1;
  }
#line 1017
  gameaction = (gameaction_t )6;
#line 1018
  return;
}
}
#line 1020 "g_game.c"
void G_DoCompleted(void) 
{ 
  int i ;

  {
#line 1024
  gameaction = (gameaction_t )0;
#line 1026
  i = 0;
  {
#line 1026
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1026
    if (! (i < 4)) {
#line 1026
      goto while_break;
    }
#line 1027
    if (playeringame[i]) {
#line 1028
      G_PlayerFinishLevel(i);
    }
#line 1026
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1030
  if (automapactive) {
#line 1031
    AM_Stop();
  }
#line 1033
  if ((unsigned int )gamemode != 2U) {
    {
#line 1036
    if (gamemap == 8) {
#line 1036
      goto case_8;
    }
#line 1039
    if (gamemap == 9) {
#line 1039
      goto case_9;
    }
#line 1034
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1037
    gameaction = (gameaction_t )7;
#line 1038
    return;
    case_9: /* CIL Label */ 
#line 1040
    i = 0;
    {
#line 1040
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1040
      if (! (i < 4)) {
#line 1040
        goto while_break___0;
      }
#line 1041
      players[i].didsecret = (boolean )1;
#line 1040
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1042
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1046
  if (gamemap == 8) {
#line 1046
    if ((unsigned int )gamemode != 2U) {
#line 1050
      gameaction = (gameaction_t )7;
#line 1051
      return;
    } else {
#line 1046
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 1054
  if (gamemap == 9) {
#line 1054
    if ((unsigned int )gamemode != 2U) {
#line 1058
      i = 0;
      {
#line 1058
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1058
        if (! (i < 4)) {
#line 1058
          goto while_break___1;
        }
#line 1059
        players[i].didsecret = (boolean )1;
#line 1058
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 1054
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 1064
  wminfo.didsecret = players[consoleplayer].didsecret;
#line 1065
  wminfo.epsd = gameepisode - 1;
#line 1066
  wminfo.last = gamemap - 1;
#line 1069
  if ((unsigned int )gamemode == 2U) {
#line 1071
    if (secretexit) {
      {
#line 1074
      if (gamemap == 15) {
#line 1074
        goto case_15;
      }
#line 1075
      if (gamemap == 31) {
#line 1075
        goto case_31;
      }
#line 1072
      goto switch_break___0;
      case_15: /* CIL Label */ 
#line 1074
      wminfo.next = 30;
#line 1074
      goto switch_break___0;
      case_31: /* CIL Label */ 
#line 1075
      wminfo.next = 31;
#line 1075
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 1081
      if (gamemap == 32) {
#line 1081
        goto case_32;
      }
#line 1081
      if (gamemap == 31) {
#line 1081
        goto case_32;
      }
#line 1082
      goto switch_default;
      case_32: /* CIL Label */ 
      case_31___0: /* CIL Label */ 
#line 1081
      wminfo.next = 15;
#line 1081
      goto switch_break___1;
      switch_default: /* CIL Label */ 
#line 1082
      wminfo.next = gamemap;
      switch_break___1: /* CIL Label */ ;
      }
    }
  } else
#line 1087
  if (secretexit) {
#line 1088
    wminfo.next = 8;
  } else
#line 1089
  if (gamemap == 9) {
    {
#line 1094
    if (gameepisode == 1) {
#line 1094
      goto case_1;
    }
#line 1097
    if (gameepisode == 2) {
#line 1097
      goto case_2;
    }
#line 1100
    if (gameepisode == 3) {
#line 1100
      goto case_3;
    }
#line 1103
    if (gameepisode == 4) {
#line 1103
      goto case_4;
    }
#line 1092
    goto switch_break___2;
    case_1: /* CIL Label */ 
#line 1095
    wminfo.next = 3;
#line 1096
    goto switch_break___2;
    case_2: /* CIL Label */ 
#line 1098
    wminfo.next = 5;
#line 1099
    goto switch_break___2;
    case_3: /* CIL Label */ 
#line 1101
    wminfo.next = 6;
#line 1102
    goto switch_break___2;
    case_4: /* CIL Label */ 
#line 1104
    wminfo.next = 2;
#line 1105
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
  } else {
#line 1109
    wminfo.next = gamemap;
  }
#line 1112
  wminfo.maxkills = totalkills;
#line 1113
  wminfo.maxitems = totalitems;
#line 1114
  wminfo.maxsecret = totalsecret;
#line 1115
  wminfo.maxfrags = 0;
#line 1116
  if ((unsigned int )gamemode == 2U) {
#line 1117
    wminfo.partime = 35 * cpars[gamemap - 1];
  } else {
#line 1119
    wminfo.partime = 35 * pars[gameepisode][gamemap];
  }
#line 1120
  wminfo.pnum = consoleplayer;
#line 1122
  i = 0;
  {
#line 1122
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1122
    if (! (i < 4)) {
#line 1122
      goto while_break___2;
    }
#line 1124
    wminfo.plyr[i].in = playeringame[i];
#line 1125
    wminfo.plyr[i].skills = players[i].killcount;
#line 1126
    wminfo.plyr[i].sitems = players[i].itemcount;
#line 1127
    wminfo.plyr[i].ssecret = players[i].secretcount;
#line 1128
    wminfo.plyr[i].stime = leveltime;
#line 1129
    memcpy((void * __restrict  )(wminfo.plyr[i].frags), (void const   * __restrict  )(players[i].frags),
           (size_t )sizeof(wminfo.plyr[i].frags));
#line 1122
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1133
  gamestate = (gamestate_t )1;
#line 1134
  viewactive = (boolean )0;
#line 1135
  automapactive = (boolean )0;
#line 1137
  if (statcopy) {
#line 1138
    memcpy((void * __restrict  )statcopy, (void const   * __restrict  )(& wminfo),
           (size_t )sizeof(wminfo));
  }
#line 1140
  WI_Start(& wminfo);
#line 1141
  return;
}
}
#line 1147 "g_game.c"
void G_WorldDone(void) 
{ 


  {
#line 1149
  gameaction = (gameaction_t )8;
#line 1151
  if (secretexit) {
#line 1152
    players[consoleplayer].didsecret = (boolean )1;
  }
#line 1154
  if ((unsigned int )gamemode == 2U) {
    {
#line 1159
    if (gamemap == 31) {
#line 1159
      goto case_31;
    }
#line 1159
    if (gamemap == 15) {
#line 1159
      goto case_31;
    }
#line 1165
    if (gamemap == 30) {
#line 1165
      goto case_30;
    }
#line 1165
    if (gamemap == 20) {
#line 1165
      goto case_30;
    }
#line 1165
    if (gamemap == 11) {
#line 1165
      goto case_30;
    }
#line 1165
    if (gamemap == 6) {
#line 1165
      goto case_30;
    }
#line 1156
    goto switch_break;
    case_31: /* CIL Label */ 
    case_15: /* CIL Label */ 
#line 1160
    if (! secretexit) {
#line 1161
      goto switch_break;
    }
    case_30: /* CIL Label */ 
    case_20: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 1166
    F_StartFinale();
#line 1167
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1170
  return;
}
}
#line 1172 "g_game.c"
void G_DoWorldDone(void) 
{ 


  {
#line 1174
  gamestate = (gamestate_t )0;
#line 1175
  gamemap = wminfo.next + 1;
#line 1176
  G_DoLoadLevel();
#line 1177
  gameaction = (gameaction_t )0;
#line 1178
  viewactive = (boolean )1;
#line 1179
  return;
}
}
#line 1190 "g_game.c"
char savename[256]  ;
#line 1192 "g_game.c"
void G_LoadGame(char *name ) 
{ 


  {
#line 1194
  strcpy((char * __restrict  )(savename), (char const   * __restrict  )name);
#line 1195
  gameaction = (gameaction_t )3;
#line 1196
  return;
}
}
#line 1201 "g_game.c"
void G_DoLoadGame(void) 
{ 
  int length ;
  int i ;
  int a ;
  int b ;
  int c ;
  char vcheck[16] ;
  int tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;

  {
#line 1208
  gameaction = (gameaction_t )0;
#line 1210
  length = M_ReadFile((char const   *)(savename), & savebuffer);
#line 1211
  save_p = savebuffer + 24;
#line 1214
  memset((void *)(vcheck), 0, (size_t )sizeof(vcheck));
#line 1215
  sprintf((char * __restrict  )(vcheck), (char const   * __restrict  )"version %i",
          110);
#line 1216
  tmp = strcmp((char const   *)save_p, (char const   *)(vcheck));
#line 1216
  if (tmp) {
#line 1217
    return;
  }
#line 1218
  save_p += 16;
#line 1220
  tmp___0 = save_p;
#line 1220
  save_p ++;
#line 1220
  gameskill = (skill_t )*tmp___0;
#line 1221
  tmp___1 = save_p;
#line 1221
  save_p ++;
#line 1221
  gameepisode = (int )*tmp___1;
#line 1222
  tmp___2 = save_p;
#line 1222
  save_p ++;
#line 1222
  gamemap = (int )*tmp___2;
#line 1223
  i = 0;
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    if (! (i < 4)) {
#line 1223
      goto while_break;
    }
#line 1224
    tmp___3 = save_p;
#line 1224
    save_p ++;
#line 1224
    playeringame[i] = (boolean )*tmp___3;
#line 1223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1227
  G_InitNew(gameskill, gameepisode, gamemap);
#line 1230
  tmp___4 = save_p;
#line 1230
  save_p ++;
#line 1230
  a = (int )*tmp___4;
#line 1231
  tmp___5 = save_p;
#line 1231
  save_p ++;
#line 1231
  b = (int )*tmp___5;
#line 1232
  tmp___6 = save_p;
#line 1232
  save_p ++;
#line 1232
  c = (int )*tmp___6;
#line 1233
  leveltime = ((a << 16) + (b << 8)) + c;
#line 1236
  P_UnArchivePlayers();
#line 1237
  P_UnArchiveWorld();
#line 1238
  P_UnArchiveThinkers();
#line 1239
  P_UnArchiveSpecials();
#line 1241
  if ((int )*save_p != 0x1d) {
#line 1242
    I_Error("Bad savegame");
  }
#line 1245
  Z_Free((void *)savebuffer);
#line 1247
  if (setsizeneeded) {
#line 1248
    R_ExecuteSetViewSize();
  }
#line 1251
  R_FillBackScreen();
#line 1252
  return;
}
}
#line 1260 "g_game.c"
void G_SaveGame(int slot , char *description ) 
{ 


  {
#line 1265
  savegameslot = slot;
#line 1266
  strcpy((char * __restrict  )(savedescription), (char const   * __restrict  )description);
#line 1267
  sendsave = (boolean )1;
#line 1268
  return;
}
}
#line 1270 "g_game.c"
void G_DoSaveGame(void) 
{ 
  char name[100] ;
  char name2[16] ;
  char *description ;
  int length ;
  int i ;
  int tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;

  {
#line 1278
  tmp = M_CheckParm("-cdrom");
#line 1278
  if (tmp) {
#line 1279
    sprintf((char * __restrict  )(name), (char const   * __restrict  )"c:\\doomdata\\doomsav%d.dsg",
            savegameslot);
  } else {
#line 1281
    sprintf((char * __restrict  )(name), (char const   * __restrict  )"doomsav%d.dsg",
            savegameslot);
  }
#line 1282
  description = savedescription;
#line 1284
  savebuffer = screens[1] + 0x4000;
#line 1284
  save_p = savebuffer;
#line 1286
  memcpy((void * __restrict  )save_p, (void const   * __restrict  )description, (size_t )24);
#line 1287
  save_p += 24;
#line 1288
  memset((void *)(name2), 0, (size_t )sizeof(name2));
#line 1289
  sprintf((char * __restrict  )(name2), (char const   * __restrict  )"version %i",
          110);
#line 1290
  memcpy((void * __restrict  )save_p, (void const   * __restrict  )(name2), (size_t )16);
#line 1291
  save_p += 16;
#line 1293
  tmp___0 = save_p;
#line 1293
  save_p ++;
#line 1293
  *tmp___0 = (byte )gameskill;
#line 1294
  tmp___1 = save_p;
#line 1294
  save_p ++;
#line 1294
  *tmp___1 = (byte )gameepisode;
#line 1295
  tmp___2 = save_p;
#line 1295
  save_p ++;
#line 1295
  *tmp___2 = (byte )gamemap;
#line 1296
  i = 0;
  {
#line 1296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1296
    if (! (i < 4)) {
#line 1296
      goto while_break;
    }
#line 1297
    tmp___3 = save_p;
#line 1297
    save_p ++;
#line 1297
    *tmp___3 = (byte )playeringame[i];
#line 1296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1298
  tmp___4 = save_p;
#line 1298
  save_p ++;
#line 1298
  *tmp___4 = (byte )(leveltime >> 16);
#line 1299
  tmp___5 = save_p;
#line 1299
  save_p ++;
#line 1299
  *tmp___5 = (byte )(leveltime >> 8);
#line 1300
  tmp___6 = save_p;
#line 1300
  save_p ++;
#line 1300
  *tmp___6 = (byte )leveltime;
#line 1302
  P_ArchivePlayers();
#line 1303
  P_ArchiveWorld();
#line 1304
  P_ArchiveThinkers();
#line 1305
  P_ArchiveSpecials();
#line 1307
  tmp___7 = save_p;
#line 1307
  save_p ++;
#line 1307
  *tmp___7 = (byte )0x1d;
#line 1309
  length = (int )(save_p - savebuffer);
#line 1310
  if (length > 0x2c000) {
#line 1311
    I_Error("Savegame buffer overrun");
  }
#line 1312
  M_WriteFile((char const   *)(name), (void *)savebuffer, length);
#line 1313
  gameaction = (gameaction_t )0;
#line 1314
  savedescription[0] = (char)0;
#line 1316
  players[consoleplayer].message = "game saved.";
#line 1319
  R_FillBackScreen();
#line 1320
  return;
}
}
#line 1328 "g_game.c"
skill_t d_skill  ;
#line 1329 "g_game.c"
int d_episode  ;
#line 1330 "g_game.c"
int d_map  ;
#line 1332 "g_game.c"
void G_DeferedInitNew(skill_t skill , int episode , int map ) 
{ 


  {
#line 1338
  d_skill = skill;
#line 1339
  d_episode = episode;
#line 1340
  d_map = map;
#line 1341
  gameaction = (gameaction_t )2;
#line 1342
  return;
}
}
#line 1345 "g_game.c"
void G_DoNewGame(void) 
{ 


  {
#line 1347
  demoplayback = (boolean )0;
#line 1348
  netdemo = (boolean )0;
#line 1349
  netgame = (boolean )0;
#line 1350
  deathmatch = (boolean )0;
#line 1351
  playeringame[3] = (boolean )0;
#line 1351
  playeringame[2] = playeringame[3];
#line 1351
  playeringame[1] = playeringame[2];
#line 1352
  respawnparm = (boolean )0;
#line 1353
  fastparm = (boolean )0;
#line 1354
  nomonsters = (boolean )0;
#line 1355
  consoleplayer = 0;
#line 1356
  G_InitNew(d_skill, d_episode, d_map);
#line 1357
  gameaction = (gameaction_t )0;
#line 1358
  return;
}
}
#line 1364 "g_game.c"
void G_InitNew(skill_t skill , int episode , int map ) 
{ 
  int i ;

  {
#line 1372
  if (paused) {
#line 1374
    paused = (boolean )0;
#line 1375
    S_ResumeSound();
  }
#line 1379
  if ((unsigned int )skill > 4U) {
#line 1380
    skill = (skill_t )4;
  }
#line 1386
  if (episode < 1) {
#line 1387
    episode = 1;
  }
#line 1389
  if ((unsigned int )gamemode == 3U) {
#line 1391
    if (episode > 4) {
#line 1392
      episode = 4;
    }
  } else
#line 1394
  if ((unsigned int )gamemode == 0U) {
#line 1396
    if (episode > 1) {
#line 1397
      episode = 1;
    }
  } else
#line 1401
  if (episode > 3) {
#line 1402
    episode = 3;
  }
#line 1407
  if (map < 1) {
#line 1408
    map = 1;
  }
#line 1410
  if (map > 9) {
#line 1410
    if ((unsigned int )gamemode != 2U) {
#line 1412
      map = 9;
    } else {
#line 1410
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 1414
  M_ClearRandom();
#line 1416
  if ((unsigned int )skill == 4U) {
#line 1416
    goto _L___0;
  } else
#line 1416
  if (respawnparm) {
    _L___0: /* CIL Label */ 
#line 1417
    respawnmonsters = (boolean )1;
  } else {
#line 1419
    respawnmonsters = (boolean )0;
  }
#line 1421
  if (fastparm) {
#line 1421
    goto _L___2;
  } else
#line 1421
  if ((unsigned int )skill == 4U) {
#line 1421
    if ((unsigned int )gameskill != 4U) {
      _L___2: /* CIL Label */ 
#line 1423
      i = 477;
      {
#line 1423
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1423
        if (! (i <= 489)) {
#line 1423
          goto while_break;
        }
#line 1424
        states[i].tics >>= 1;
#line 1423
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1425
      mobjinfo[16].speed = 20 * (1 << 16);
#line 1426
      mobjinfo[32].speed = 20 * (1 << 16);
#line 1427
      mobjinfo[31].speed = 20 * (1 << 16);
    } else {
#line 1421
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1429
  if ((unsigned int )skill != 4U) {
#line 1429
    if ((unsigned int )gameskill == 4U) {
#line 1431
      i = 477;
      {
#line 1431
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1431
        if (! (i <= 489)) {
#line 1431
          goto while_break___0;
        }
#line 1432
        states[i].tics <<= 1;
#line 1431
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1433
      mobjinfo[16].speed = 15 * (1 << 16);
#line 1434
      mobjinfo[32].speed = 10 * (1 << 16);
#line 1435
      mobjinfo[31].speed = 10 * (1 << 16);
    } else {
#line 1429
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 1440
  i = 0;
  {
#line 1440
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1440
    if (! (i < 4)) {
#line 1440
      goto while_break___1;
    }
#line 1441
    players[i].playerstate = (playerstate_t )2;
#line 1440
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1443
  usergame = (boolean )1;
#line 1444
  paused = (boolean )0;
#line 1445
  demoplayback = (boolean )0;
#line 1446
  automapactive = (boolean )0;
#line 1447
  viewactive = (boolean )1;
#line 1448
  gameepisode = episode;
#line 1449
  gamemap = map;
#line 1450
  gameskill = skill;
#line 1452
  viewactive = (boolean )1;
#line 1455
  if ((unsigned int )gamemode == 2U) {
#line 1457
    skytexture = R_TextureNumForName("SKY3");
#line 1458
    if (gamemap < 12) {
#line 1459
      skytexture = R_TextureNumForName("SKY1");
    } else
#line 1461
    if (gamemap < 21) {
#line 1462
      skytexture = R_TextureNumForName("SKY2");
    }
  } else {
    {
#line 1467
    if (episode == 1) {
#line 1467
      goto case_1;
    }
#line 1470
    if (episode == 2) {
#line 1470
      goto case_2;
    }
#line 1473
    if (episode == 3) {
#line 1473
      goto case_3;
    }
#line 1476
    if (episode == 4) {
#line 1476
      goto case_4;
    }
#line 1465
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1468
    skytexture = R_TextureNumForName("SKY1");
#line 1469
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1471
    skytexture = R_TextureNumForName("SKY2");
#line 1472
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1474
    skytexture = R_TextureNumForName("SKY3");
#line 1475
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1477
    skytexture = R_TextureNumForName("SKY4");
#line 1478
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1481
  G_DoLoadLevel();
#line 1482
  return;
}
}
#line 1491 "g_game.c"
void G_ReadDemoTiccmd(ticcmd_t *cmd ) 
{ 
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 1493
  if ((int )*demo_p == 0x80) {
#line 1496
    G_CheckDemoStatus();
#line 1497
    return;
  }
#line 1499
  tmp = demo_p;
#line 1499
  demo_p ++;
#line 1499
  cmd->forwardmove = (char )((signed char )*tmp);
#line 1500
  tmp___0 = demo_p;
#line 1500
  demo_p ++;
#line 1500
  cmd->sidemove = (char )((signed char )*tmp___0);
#line 1501
  tmp___1 = demo_p;
#line 1501
  demo_p ++;
#line 1501
  cmd->angleturn = (short )((int )*tmp___1 << 8);
#line 1502
  tmp___2 = demo_p;
#line 1502
  demo_p ++;
#line 1502
  cmd->buttons = *tmp___2;
#line 1503
  return;
}
}
#line 1506 "g_game.c"
void G_WriteDemoTiccmd(ticcmd_t *cmd ) 
{ 
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 1508
  if (gamekeydown[113]) {
#line 1509
    G_CheckDemoStatus();
  }
#line 1510
  tmp = demo_p;
#line 1510
  demo_p ++;
#line 1510
  *tmp = (byte )cmd->forwardmove;
#line 1511
  tmp___0 = demo_p;
#line 1511
  demo_p ++;
#line 1511
  *tmp___0 = (byte )cmd->sidemove;
#line 1512
  tmp___1 = demo_p;
#line 1512
  demo_p ++;
#line 1512
  *tmp___1 = (byte )(((int )cmd->angleturn + 128) >> 8);
#line 1513
  tmp___2 = demo_p;
#line 1513
  demo_p ++;
#line 1513
  *tmp___2 = cmd->buttons;
#line 1514
  demo_p -= 4;
#line 1515
  if ((unsigned long )demo_p > (unsigned long )(demoend - 16)) {
#line 1518
    G_CheckDemoStatus();
#line 1519
    return;
  }
#line 1522
  G_ReadDemoTiccmd(cmd);
#line 1523
  return;
}
}
#line 1530 "g_game.c"
void G_RecordDemo(char *name ) 
{ 
  int i ;
  int maxsize ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1535
  usergame = (boolean )0;
#line 1536
  strcpy((char * __restrict  )(demoname), (char const   * __restrict  )name);
#line 1537
  strcat((char * __restrict  )(demoname), (char const   * __restrict  )".lmp");
#line 1538
  maxsize = 0x20000;
#line 1539
  i = M_CheckParm("-maxdemo");
#line 1540
  if (i) {
#line 1540
    if (i < myargc - 1) {
#line 1541
      tmp = atoi((char const   *)*(myargv + (i + 1)));
#line 1541
      maxsize = tmp * 1024;
    } else {
#line 1540
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 1542
  tmp___0 = Z_Malloc(maxsize, 1, (void *)0);
#line 1542
  demobuffer = (byte *)tmp___0;
#line 1543
  demoend = demobuffer + maxsize;
#line 1545
  demorecording = (boolean )1;
#line 1546
  return;
}
}
#line 1549 "g_game.c"
void G_BeginRecording(void) 
{ 
  int i ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;

  {
#line 1553
  demo_p = demobuffer;
#line 1555
  tmp = demo_p;
#line 1555
  demo_p ++;
#line 1555
  *tmp = (byte )110;
#line 1556
  tmp___0 = demo_p;
#line 1556
  demo_p ++;
#line 1556
  *tmp___0 = (byte )gameskill;
#line 1557
  tmp___1 = demo_p;
#line 1557
  demo_p ++;
#line 1557
  *tmp___1 = (byte )gameepisode;
#line 1558
  tmp___2 = demo_p;
#line 1558
  demo_p ++;
#line 1558
  *tmp___2 = (byte )gamemap;
#line 1559
  tmp___3 = demo_p;
#line 1559
  demo_p ++;
#line 1559
  *tmp___3 = (byte )deathmatch;
#line 1560
  tmp___4 = demo_p;
#line 1560
  demo_p ++;
#line 1560
  *tmp___4 = (byte )respawnparm;
#line 1561
  tmp___5 = demo_p;
#line 1561
  demo_p ++;
#line 1561
  *tmp___5 = (byte )fastparm;
#line 1562
  tmp___6 = demo_p;
#line 1562
  demo_p ++;
#line 1562
  *tmp___6 = (byte )nomonsters;
#line 1563
  tmp___7 = demo_p;
#line 1563
  demo_p ++;
#line 1563
  *tmp___7 = (byte )consoleplayer;
#line 1565
  i = 0;
  {
#line 1565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1565
    if (! (i < 4)) {
#line 1565
      goto while_break;
    }
#line 1566
    tmp___8 = demo_p;
#line 1566
    demo_p ++;
#line 1566
    *tmp___8 = (byte )playeringame[i];
#line 1565
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1567
  return;
}
}
#line 1574 "g_game.c"
char *defdemoname  ;
#line 1576 "g_game.c"
void G_DeferedPlayDemo(char *name ) 
{ 


  {
#line 1578
  defdemoname = name;
#line 1579
  gameaction = (gameaction_t )5;
#line 1580
  return;
}
}
#line 1582 "g_game.c"
void G_DoPlayDemo(void) 
{ 
  skill_t skill ;
  int i ;
  int episode ;
  int map ;
  void *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;

  {
#line 1587
  gameaction = (gameaction_t )0;
#line 1588
  tmp = W_CacheLumpName(defdemoname, 1);
#line 1588
  demo_p = (byte *)tmp;
#line 1588
  demobuffer = demo_p;
#line 1589
  tmp___0 = demo_p;
#line 1589
  demo_p ++;
#line 1589
  if ((int )*tmp___0 != 110) {
#line 1591
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Demo is from a different game version!\n");
#line 1592
    gameaction = (gameaction_t )0;
#line 1593
    return;
  }
#line 1596
  tmp___1 = demo_p;
#line 1596
  demo_p ++;
#line 1596
  skill = (skill_t )*tmp___1;
#line 1597
  tmp___2 = demo_p;
#line 1597
  demo_p ++;
#line 1597
  episode = (int )*tmp___2;
#line 1598
  tmp___3 = demo_p;
#line 1598
  demo_p ++;
#line 1598
  map = (int )*tmp___3;
#line 1599
  tmp___4 = demo_p;
#line 1599
  demo_p ++;
#line 1599
  deathmatch = (boolean )*tmp___4;
#line 1600
  tmp___5 = demo_p;
#line 1600
  demo_p ++;
#line 1600
  respawnparm = (boolean )*tmp___5;
#line 1601
  tmp___6 = demo_p;
#line 1601
  demo_p ++;
#line 1601
  fastparm = (boolean )*tmp___6;
#line 1602
  tmp___7 = demo_p;
#line 1602
  demo_p ++;
#line 1602
  nomonsters = (boolean )*tmp___7;
#line 1603
  tmp___8 = demo_p;
#line 1603
  demo_p ++;
#line 1603
  consoleplayer = (int )*tmp___8;
#line 1605
  i = 0;
  {
#line 1605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1605
    if (! (i < 4)) {
#line 1605
      goto while_break;
    }
#line 1606
    tmp___9 = demo_p;
#line 1606
    demo_p ++;
#line 1606
    playeringame[i] = (boolean )*tmp___9;
#line 1605
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1607
  if (playeringame[1]) {
#line 1609
    netgame = (boolean )1;
#line 1610
    netdemo = (boolean )1;
  }
#line 1614
  precache = (boolean )0;
#line 1615
  G_InitNew(skill, episode, map);
#line 1616
  precache = (boolean )1;
#line 1618
  usergame = (boolean )0;
#line 1619
  demoplayback = (boolean )1;
#line 1620
  return;
}
}
#line 1625 "g_game.c"
void G_TimeDemo(char *name ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1627
  tmp = M_CheckParm("-nodraw");
#line 1627
  nodrawers = (boolean )tmp;
#line 1628
  tmp___0 = M_CheckParm("-noblit");
#line 1628
  noblit = (boolean )tmp___0;
#line 1629
  timingdemo = (boolean )1;
#line 1630
  singletics = (boolean )1;
#line 1632
  defdemoname = name;
#line 1633
  gameaction = (gameaction_t )5;
#line 1634
  return;
}
}
#line 1647 "g_game.c"
boolean G_CheckDemoStatus(void) 
{ 
  int endtime ;
  byte *tmp ;

  {
#line 1651
  if (timingdemo) {
#line 1653
    endtime = I_GetTime();
#line 1654
    I_Error("timed %i gametics in %i realtics", gametic, endtime - starttime);
  }
#line 1658
  if (demoplayback) {
#line 1660
    if (singledemo) {
#line 1661
      I_Quit();
    }
#line 1663
    if (((memblock_t *)(demobuffer - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1663
      I_Error("Z_CT at g_game.c:%i", 1663);
    }
#line 1663
    Z_ChangeTag2((void *)demobuffer, 101);
#line 1664
    demoplayback = (boolean )0;
#line 1665
    netdemo = (boolean )0;
#line 1666
    netgame = (boolean )0;
#line 1667
    deathmatch = (boolean )0;
#line 1668
    playeringame[3] = (boolean )0;
#line 1668
    playeringame[2] = playeringame[3];
#line 1668
    playeringame[1] = playeringame[2];
#line 1669
    respawnparm = (boolean )0;
#line 1670
    fastparm = (boolean )0;
#line 1671
    nomonsters = (boolean )0;
#line 1672
    consoleplayer = 0;
#line 1673
    D_AdvanceDemo();
#line 1674
    return ((boolean )1);
  }
#line 1677
  if (demorecording) {
#line 1679
    tmp = demo_p;
#line 1679
    demo_p ++;
#line 1679
    *tmp = (byte )0x80;
#line 1680
    M_WriteFile((char const   *)(demoname), (void *)demobuffer, (int )(demo_p - demobuffer));
#line 1681
    Z_Free((void *)demobuffer);
#line 1682
    demorecording = (boolean )0;
#line 1683
    I_Error("Demo %s recorded", demoname);
  }
#line 1686
  return ((boolean )0);
}
}
#line 25 "m_menu.c"
static char const   rcsid___13[49]  = 
#line 25 "m_menu.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'m', 
        (char const   )'e',      (char const   )'n',      (char const   )'u',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 133 "doomstat.h"
boolean menuactive  ;
#line 255 "doomstat.h"
int mouseSensitivity  ;
#line 69 "m_menu.c"
boolean message_dontfuckwithme ;
#line 71
boolean chat_on ;
#line 79 "m_menu.c"
int showMessages  ;
#line 83 "m_menu.c"
int detailLevel  ;
#line 84 "m_menu.c"
int screenblocks  ;
#line 87 "m_menu.c"
int screenSize  ;
#line 90 "m_menu.c"
int quickSaveSlot  ;
#line 93 "m_menu.c"
int messageToPrint  ;
#line 95 "m_menu.c"
char *messageString  ;
#line 98 "m_menu.c"
int messx  ;
#line 99 "m_menu.c"
int messy  ;
#line 100 "m_menu.c"
int messageLastMenuActive  ;
#line 103 "m_menu.c"
boolean messageNeedsInput  ;
#line 105 "m_menu.c"
void (*messageRoutine)(int response )  ;
#line 109 "m_menu.c"
char gammamsg[5][26]  = { {        (char )'G',        (char )'a',        (char )'m',        (char )'m', 
            (char )'a',        (char )' ',        (char )'c',        (char )'o', 
            (char )'r',        (char )'r',        (char )'e',        (char )'c', 
            (char )'t',        (char )'i',        (char )'o',        (char )'n', 
            (char )' ',        (char )'O',        (char )'F',        (char )'F', 
            (char )'\000'}, 
   {        (char )'G',        (char )'a',        (char )'m',        (char )'m', 
            (char )'a',        (char )' ',        (char )'c',        (char )'o', 
            (char )'r',        (char )'r',        (char )'e',        (char )'c', 
            (char )'t',        (char )'i',        (char )'o',        (char )'n', 
            (char )' ',        (char )'l',        (char )'e',        (char )'v', 
            (char )'e',        (char )'l',        (char )' ',        (char )'1', 
            (char )'\000'}, 
   {        (char )'G',        (char )'a',        (char )'m',        (char )'m', 
            (char )'a',        (char )' ',        (char )'c',        (char )'o', 
            (char )'r',        (char )'r',        (char )'e',        (char )'c', 
            (char )'t',        (char )'i',        (char )'o',        (char )'n', 
            (char )' ',        (char )'l',        (char )'e',        (char )'v', 
            (char )'e',        (char )'l',        (char )' ',        (char )'2', 
            (char )'\000'}, 
   {        (char )'G',        (char )'a',        (char )'m',        (char )'m', 
            (char )'a',        (char )' ',        (char )'c',        (char )'o', 
            (char )'r',        (char )'r',        (char )'e',        (char )'c', 
            (char )'t',        (char )'i',        (char )'o',        (char )'n', 
            (char )' ',        (char )'l',        (char )'e',        (char )'v', 
            (char )'e',        (char )'l',        (char )' ',        (char )'3', 
            (char )'\000'}, 
   {        (char )'G',        (char )'a',        (char )'m',        (char )'m', 
            (char )'a',        (char )' ',        (char )'c',        (char )'o', 
            (char )'r',        (char )'r',        (char )'e',        (char )'c', 
            (char )'t',        (char )'i',        (char )'o',        (char )'n', 
            (char )' ',        (char )'l',        (char )'e',        (char )'v', 
            (char )'e',        (char )'l',        (char )' ',        (char )'4', 
            (char )'\000'}};
#line 119 "m_menu.c"
int saveStringEnter  ;
#line 120 "m_menu.c"
int saveSlot  ;
#line 121 "m_menu.c"
int saveCharIndex  ;
#line 123 "m_menu.c"
char saveOldString[24]  ;
#line 125 "m_menu.c"
boolean inhelpscreens  ;
#line 132 "m_menu.c"
char savegamestrings[10][24]  ;
#line 134 "m_menu.c"
char endstring[160]  ;
#line 169 "m_menu.c"
short itemOn  ;
#line 170 "m_menu.c"
short skullAnimCounter  ;
#line 171 "m_menu.c"
short whichSkull  ;
#line 175 "m_menu.c"
char skullName[2][9]  = { {        (char )'M',        (char )'_',        (char )'S',        (char )'K', 
            (char )'U',        (char )'L',        (char )'L',        (char )'1', 
            (char )'\000'}, 
   {        (char )'M',        (char )'_',        (char )'S',        (char )'K', 
            (char )'U',        (char )'L',        (char )'L',        (char )'2', 
            (char )'\000'}};
#line 178 "m_menu.c"
menu_t *currentMenu  ;
#line 183
void M_NewGame(int choice ) ;
#line 184
void M_Episode(int choice ) ;
#line 185
void M_ChooseSkill(int choice ) ;
#line 186
void M_LoadGame(int choice ) ;
#line 187
void M_SaveGame(int choice ) ;
#line 188
void M_Options(int choice ) ;
#line 189
void M_EndGame(int choice ) ;
#line 190
void M_ReadThis(int choice ) ;
#line 191
void M_ReadThis2(int choice ) ;
#line 192
void M_QuitDOOM(int choice ) ;
#line 194
void M_ChangeMessages(int choice ) ;
#line 195
void M_ChangeSensitivity(int choice ) ;
#line 196
void M_SfxVol(int choice ) ;
#line 197
void M_MusicVol(int choice ) ;
#line 198
void M_ChangeDetail(int choice ) ;
#line 199
void M_SizeDisplay(int choice ) ;
#line 200
extern void M_StartGame(int choice ) ;
#line 201
void M_Sound(int choice ) ;
#line 203
void M_FinishReadThis(int choice ) ;
#line 204
void M_LoadSelect(int choice ) ;
#line 205
void M_SaveSelect(int choice ) ;
#line 206
void M_ReadSaveStrings(void) ;
#line 207
void M_QuickSave(void) ;
#line 208
void M_QuickLoad(void) ;
#line 210
void M_DrawMainMenu(void) ;
#line 211
void M_DrawReadThis1(void) ;
#line 212
void M_DrawReadThis2(void) ;
#line 213
void M_DrawNewGame(void) ;
#line 214
void M_DrawEpisode(void) ;
#line 215
void M_DrawOptions(void) ;
#line 216
void M_DrawSound(void) ;
#line 217
void M_DrawLoad(void) ;
#line 218
void M_DrawSave(void) ;
#line 220
void M_DrawSaveLoadBorder(int x___0 , int y___1 ) ;
#line 221
void M_SetupNextMenu(menu_t *menudef ) ;
#line 222
void M_DrawThermo(int x___0 , int y___1 , int thermWidth , int thermDot ) ;
#line 223
void M_DrawEmptyCell(menu_t *menu , int item ) ;
#line 224
void M_DrawSelCell(menu_t *menu , int item ) ;
#line 225
void M_WriteText(int x___0 , int y___1 , char *string ) ;
#line 226
int M_StringWidth(char *string ) ;
#line 227
int M_StringHeight(char *string ) ;
#line 229
void M_StartMessage(char *string , void *routine , boolean input ) ;
#line 230
void M_StopMessage(void) ;
#line 231
void M_ClearMenus(void) ;
#line 239 "m_menu.c"
enum __anonenum_main_e_112973811 main_e  ;
#line 250 "m_menu.c"
menuitem_t MainMenu[6]  = {      {(short)1, {(char )'M', (char )'_', (char )'N', (char )'G', (char )'A', (char )'M',
                 (char )'E', (char )'\000'}, & M_NewGame, (char )'n'}, 
        {(short)1, {(char )'M', (char )'_', (char )'O', (char )'P', (char )'T', (char )'I',
                 (char )'O', (char )'N', (char )'\000'}, & M_Options, (char )'o'}, 
        {(short)1, {(char )'M', (char )'_', (char )'L', (char )'O', (char )'A', (char )'D',
                 (char )'G', (char )'\000'}, & M_LoadGame, (char )'l'}, 
        {(short)1, {(char )'M', (char )'_', (char )'S', (char )'A', (char )'V', (char )'E',
                 (char )'G', (char )'\000'}, & M_SaveGame, (char )'s'}, 
        {(short)1, {(char )'M', (char )'_', (char )'R', (char )'D', (char )'T', (char )'H',
                 (char )'I', (char )'S', (char )'\000'}, & M_ReadThis, (char )'r'}, 
        {(short)1, {(char )'M', (char )'_', (char )'Q', (char )'U', (char )'I', (char )'T',
                 (char )'G', (char )'\000'}, & M_QuitDOOM, (char )'q'}};
#line 261 "m_menu.c"
menu_t MainDef  =    {(short)6, (struct menu_s *)((void *)0), MainMenu, (void (*)())(& M_DrawMainMenu),
    (short)97, (short)64, (short)0};
#line 275 "m_menu.c"
enum __anonenum_episodes_e_479592101 episodes_e  ;
#line 284 "m_menu.c"
menuitem_t EpisodeMenu[4]  = {      {(short)1, {(char )'M', (char )'_', (char )'E', (char )'P', (char )'I', (char )'1',
                 (char )'\000'}, & M_Episode, (char )'k'}, 
        {(short)1, {(char )'M', (char )'_', (char )'E', (char )'P', (char )'I', (char )'2',
                 (char )'\000'}, & M_Episode, (char )'t'}, 
        {(short)1, {(char )'M', (char )'_', (char )'E', (char )'P', (char )'I', (char )'3',
                 (char )'\000'}, & M_Episode, (char )'i'}, 
        {(short)1, {(char )'M', (char )'_', (char )'E', (char )'P', (char )'I', (char )'4',
                 (char )'\000'}, & M_Episode, (char )'t'}};
#line 292 "m_menu.c"
menu_t EpiDef  =    {(short)4, & MainDef, EpisodeMenu, (void (*)())(& M_DrawEpisode), (short)48, (short)63,
    (short)0};
#line 305 "m_menu.c"
enum __anonenum_newgame_e_993994851 newgame_e  ;
#line 315 "m_menu.c"
menuitem_t NewGameMenu[5]  = {      {(short)1, {(char )'M', (char )'_', (char )'J', (char )'K', (char )'I', (char )'L',
                 (char )'L', (char )'\000'}, & M_ChooseSkill, (char )'i'}, 
        {(short)1, {(char )'M', (char )'_', (char )'R', (char )'O', (char )'U', (char )'G',
                 (char )'H', (char )'\000'}, & M_ChooseSkill, (char )'h'}, 
        {(short)1, {(char )'M', (char )'_', (char )'H', (char )'U', (char )'R', (char )'T',
                 (char )'\000'}, & M_ChooseSkill, (char )'h'}, 
        {(short)1, {(char )'M', (char )'_', (char )'U', (char )'L', (char )'T', (char )'R',
                 (char )'A', (char )'\000'}, & M_ChooseSkill, (char )'u'}, 
        {(short)1, {(char )'M', (char )'_', (char )'N', (char )'M', (char )'A', (char )'R',
                 (char )'E', (char )'\000'}, & M_ChooseSkill, (char )'n'}};
#line 324 "m_menu.c"
menu_t NewDef  =    {(short)5, & EpiDef, NewGameMenu, (void (*)())(& M_DrawNewGame), (short)48, (short)63,
    (short)2};
#line 339 "m_menu.c"
enum __anonenum_options_e_766045714 options_e  ;
#line 352 "m_menu.c"
menuitem_t OptionsMenu[8]  = 
#line 352
  {      {(short)1, {(char )'M', (char )'_', (char )'E', (char )'N', (char )'D', (char )'G',
                 (char )'A', (char )'M', (char )'\000'}, & M_EndGame, (char )'e'}, 
        {(short)1, {(char )'M', (char )'_', (char )'M', (char )'E', (char )'S', (char )'S',
                 (char )'G', (char )'\000'}, & M_ChangeMessages, (char )'m'}, 
        {(short)1, {(char )'M', (char )'_', (char )'D', (char )'E', (char )'T', (char )'A',
                 (char )'I', (char )'L', (char )'\000'}, & M_ChangeDetail, (char )'g'}, 
        {(short)2, {(char )'M', (char )'_', (char )'S', (char )'C', (char )'R', (char )'N',
                 (char )'S', (char )'Z', (char )'\000'}, & M_SizeDisplay, (char )'s'}, 
        {(short)-1, {(char )'\000'}, (void (*)(int choice ))0, (char)0}, 
        {(short)2, {(char )'M', (char )'_', (char )'M', (char )'S', (char )'E', (char )'N',
                 (char )'S', (char )'\000'}, & M_ChangeSensitivity, (char )'m'}, 
        {(short)-1, {(char )'\000'}, (void (*)(int choice ))0, (char)0}, 
        {(short)1, {(char )'M', (char )'_', (char )'S', (char )'V', (char )'O', (char )'L',
                 (char )'\000'}, & M_Sound, (char )'s'}};
#line 364 "m_menu.c"
menu_t OptionsDef  =    {(short)8, & MainDef, OptionsMenu, (void (*)())(& M_DrawOptions), (short)60, (short)37,
    (short)0};
#line 377 "m_menu.c"
enum __anonenum_read_e_203113283 read_e  ;
#line 383 "m_menu.c"
menuitem_t ReadMenu1[1]  = {      {(short)1, {(char )'\000'}, & M_ReadThis2, (char)0}};
#line 388 "m_menu.c"
menu_t ReadDef1  =    {(short)1, & MainDef, ReadMenu1, (void (*)())(& M_DrawReadThis1), (short)280, (short)185,
    (short)0};
#line 398 "m_menu.c"
enum __anonenum_read_e2_844223810 read_e2  ;
#line 404 "m_menu.c"
menuitem_t ReadMenu2[1]  = {      {(short)1, {(char )'\000'}, & M_FinishReadThis, (char)0}};
#line 409 "m_menu.c"
menu_t ReadDef2  =    {(short)1, & ReadDef1, ReadMenu2, (void (*)())(& M_DrawReadThis2), (short)330,
    (short)175, (short)0};
#line 422 "m_menu.c"
enum __anonenum_sound_e_662858041 sound_e  ;
#line 431 "m_menu.c"
menuitem_t SoundMenu[4]  = {      {(short)2, {(char )'M', (char )'_', (char )'S', (char )'F', (char )'X', (char )'V',
                 (char )'O', (char )'L', (char )'\000'}, & M_SfxVol, (char )'s'}, 
        {(short)-1, {(char )'\000'}, (void (*)(int choice ))0, (char)0}, 
        {(short)2, {(char )'M', (char )'_', (char )'M', (char )'U', (char )'S', (char )'V',
                 (char )'O', (char )'L', (char )'\000'}, & M_MusicVol, (char )'m'}, 
        {(short)-1, {(char )'\000'}, (void (*)(int choice ))0, (char)0}};
#line 439 "m_menu.c"
menu_t SoundDef  =    {(short)4, & OptionsDef, SoundMenu, (void (*)())(& M_DrawSound), (short)80, (short)64,
    (short)0};
#line 452 "m_menu.c"
enum __anonenum_load_e_679472234 load_e  ;
#line 463 "m_menu.c"
menuitem_t LoadMenu[6]  = {      {(short)1, {(char )'\000'}, & M_LoadSelect, (char )'1'}, 
        {(short)1, {(char )'\000'}, & M_LoadSelect, (char )'2'}, 
        {(short)1, {(char )'\000'}, & M_LoadSelect, (char )'3'}, 
        {(short)1, {(char )'\000'}, & M_LoadSelect, (char )'4'}, 
        {(short)1, {(char )'\000'}, & M_LoadSelect, (char )'5'}, 
        {(short)1, {(char )'\000'}, & M_LoadSelect, (char )'6'}};
#line 473 "m_menu.c"
menu_t LoadDef  =    {(short)6, & MainDef, LoadMenu, (void (*)())(& M_DrawLoad), (short)80, (short)54,
    (short)0};
#line 486 "m_menu.c"
menuitem_t SaveMenu[6]  = {      {(short)1, {(char )'\000'}, & M_SaveSelect, (char )'1'}, 
        {(short)1, {(char )'\000'}, & M_SaveSelect, (char )'2'}, 
        {(short)1, {(char )'\000'}, & M_SaveSelect, (char )'3'}, 
        {(short)1, {(char )'\000'}, & M_SaveSelect, (char )'4'}, 
        {(short)1, {(char )'\000'}, & M_SaveSelect, (char )'5'}, 
        {(short)1, {(char )'\000'}, & M_SaveSelect, (char )'6'}};
#line 496 "m_menu.c"
menu_t SaveDef  =    {(short)6, & MainDef, SaveMenu, (void (*)())(& M_DrawSave), (short)80, (short)54,
    (short)0};
#line 511 "m_menu.c"
void M_ReadSaveStrings(void) 
{ 
  int handle ;
  int count ;
  int i ;
  char name[256] ;
  int tmp ;

  {
#line 518
  i = 0;
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 518
    if (! (i < 6)) {
#line 518
      goto while_break;
    }
#line 520
    tmp = M_CheckParm("-cdrom");
#line 520
    if (tmp) {
#line 521
      sprintf((char * __restrict  )(name), (char const   * __restrict  )"c:\\doomdata\\doomsav%d.dsg",
              i);
    } else {
#line 523
      sprintf((char * __restrict  )(name), (char const   * __restrict  )"doomsav%d.dsg",
              i);
    }
#line 525
    handle = open((char const   *)(name), 0, 0666);
#line 526
    if (handle == -1) {
#line 528
      strcpy((char * __restrict  )(& savegamestrings[i][0]), (char const   * __restrict  )"empty slot");
#line 529
      LoadMenu[i].status = (short)0;
#line 530
      goto __Cont;
    }
#line 532
    count = read(handle, (void *)(& savegamestrings[i]), (size_t )24);
#line 533
    close(handle);
#line 534
    LoadMenu[i].status = (short)1;
    __Cont: /* CIL Label */ 
#line 518
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  return;
}
}
#line 542 "m_menu.c"
void M_DrawLoad(void) 
{ 
  int i ;
  void *tmp ;

  {
#line 546
  tmp = W_CacheLumpName("M_LOADG", 101);
#line 546
  V_DrawPatchDirect(72, 28, 0, (patch_t *)tmp);
#line 547
  i = 0;
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! (i < 6)) {
#line 547
      goto while_break;
    }
#line 549
    M_DrawSaveLoadBorder((int )LoadDef.x, (int )LoadDef.y + 16 * i);
#line 550
    M_WriteText((int )LoadDef.x, (int )LoadDef.y + 16 * i, savegamestrings[i]);
#line 547
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  return;
}
}
#line 559 "m_menu.c"
void M_DrawSaveLoadBorder(int x___0 , int y___1 ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 563
  tmp = W_CacheLumpName("M_LSLEFT", 101);
#line 563
  V_DrawPatchDirect(x___0 - 8, y___1 + 7, 0, (patch_t *)tmp);
#line 565
  i = 0;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (! (i < 24)) {
#line 565
      goto while_break;
    }
#line 567
    tmp___0 = W_CacheLumpName("M_LSCNTR", 101);
#line 567
    V_DrawPatchDirect(x___0, y___1 + 7, 0, (patch_t *)tmp___0);
#line 568
    x___0 += 8;
#line 565
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  tmp___1 = W_CacheLumpName("M_LSRGHT", 101);
#line 571
  V_DrawPatchDirect(x___0, y___1 + 7, 0, (patch_t *)tmp___1);
#line 572
  return;
}
}
#line 579 "m_menu.c"
void M_LoadSelect(int choice ) 
{ 
  char name[256] ;
  int tmp ;

  {
#line 583
  tmp = M_CheckParm("-cdrom");
#line 583
  if (tmp) {
#line 584
    sprintf((char * __restrict  )(name), (char const   * __restrict  )"c:\\doomdata\\doomsav%d.dsg",
            choice);
  } else {
#line 586
    sprintf((char * __restrict  )(name), (char const   * __restrict  )"doomsav%d.dsg",
            choice);
  }
#line 587
  G_LoadGame(name);
#line 588
  M_ClearMenus();
#line 589
  return;
}
}
#line 594 "m_menu.c"
void M_LoadGame(int choice ) 
{ 


  {
#line 596
  if (netgame) {
#line 598
    M_StartMessage("you can\'t do load while in a net game!\n\npress a key.", (void *)0,
                   (boolean )0);
#line 599
    return;
  }
#line 602
  M_SetupNextMenu(& LoadDef);
#line 603
  M_ReadSaveStrings();
#line 604
  return;
}
}
#line 610 "m_menu.c"
void M_DrawSave(void) 
{ 
  int i ;
  void *tmp ;

  {
#line 614
  tmp = W_CacheLumpName("M_SAVEG", 101);
#line 614
  V_DrawPatchDirect(72, 28, 0, (patch_t *)tmp);
#line 615
  i = 0;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! (i < 6)) {
#line 615
      goto while_break;
    }
#line 617
    M_DrawSaveLoadBorder((int )LoadDef.x, (int )LoadDef.y + 16 * i);
#line 618
    M_WriteText((int )LoadDef.x, (int )LoadDef.y + 16 * i, savegamestrings[i]);
#line 615
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  if (saveStringEnter) {
#line 623
    i = M_StringWidth(savegamestrings[saveSlot]);
#line 624
    M_WriteText((int )LoadDef.x + i, (int )LoadDef.y + 16 * saveSlot, "_");
  }
#line 626
  return;
}
}
#line 631 "m_menu.c"
void M_DoSave(int slot ) 
{ 


  {
#line 633
  G_SaveGame(slot, savegamestrings[slot]);
#line 634
  M_ClearMenus();
#line 637
  if (quickSaveSlot == -2) {
#line 638
    quickSaveSlot = slot;
  }
#line 639
  return;
}
}
#line 644 "m_menu.c"
void M_SaveSelect(int choice ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
#line 647
  saveStringEnter = 1;
#line 649
  saveSlot = choice;
#line 650
  strcpy((char * __restrict  )(saveOldString), (char const   * __restrict  )(savegamestrings[choice]));
#line 651
  tmp = strcmp((char const   *)(savegamestrings[choice]), (char const   *)"empty slot");
#line 651
  if (! tmp) {
#line 652
    savegamestrings[choice][0] = (char)0;
  }
#line 653
  tmp___0 = strlen((char const   *)(savegamestrings[choice]));
#line 653
  saveCharIndex = (int )tmp___0;
#line 654
  return;
}
}
#line 659 "m_menu.c"
void M_SaveGame(int choice ) 
{ 


  {
#line 661
  if (! usergame) {
#line 663
    M_StartMessage("you can\'t save if you aren\'t playing!\n\npress a key.", (void *)0,
                   (boolean )0);
#line 664
    return;
  }
#line 667
  if ((unsigned int )gamestate != 0U) {
#line 668
    return;
  }
#line 670
  M_SetupNextMenu(& SaveDef);
#line 671
  M_ReadSaveStrings();
#line 672
  return;
}
}
#line 679 "m_menu.c"
char tempstring[80]  ;
#line 681 "m_menu.c"
void M_QuickSaveResponse(int ch ) 
{ 


  {
#line 683
  if (ch == 121) {
#line 685
    M_DoSave(quickSaveSlot);
#line 686
    S_StartSound((void *)0, 24);
  }
#line 688
  return;
}
}
#line 690 "m_menu.c"
void M_QuickSave(void) 
{ 


  {
#line 692
  if (! usergame) {
#line 694
    S_StartSound((void *)0, 34);
#line 695
    return;
  }
#line 698
  if ((unsigned int )gamestate != 0U) {
#line 699
    return;
  }
#line 701
  if (quickSaveSlot < 0) {
#line 703
    M_StartControlPanel();
#line 704
    M_ReadSaveStrings();
#line 705
    M_SetupNextMenu(& SaveDef);
#line 706
    quickSaveSlot = -2;
#line 707
    return;
  }
#line 709
  sprintf((char * __restrict  )(tempstring), (char const   * __restrict  )"quicksave over your game named\n\n\'%s\'?\n\npress y or n.",
          savegamestrings[quickSaveSlot]);
#line 710
  M_StartMessage(tempstring, (void *)(& M_QuickSaveResponse), (boolean )1);
#line 711
  return;
}
}
#line 718 "m_menu.c"
void M_QuickLoadResponse(int ch ) 
{ 


  {
#line 720
  if (ch == 121) {
#line 722
    M_LoadSelect(quickSaveSlot);
#line 723
    S_StartSound((void *)0, 24);
  }
#line 725
  return;
}
}
#line 728 "m_menu.c"
void M_QuickLoad(void) 
{ 


  {
#line 730
  if (netgame) {
#line 732
    M_StartMessage("you can\'t quickload during a netgame!\n\npress a key.", (void *)0,
                   (boolean )0);
#line 733
    return;
  }
#line 736
  if (quickSaveSlot < 0) {
#line 738
    M_StartMessage("you haven\'t picked a quicksave slot yet!\n\npress a key.", (void *)0,
                   (boolean )0);
#line 739
    return;
  }
#line 741
  sprintf((char * __restrict  )(tempstring), (char const   * __restrict  )"do you want to quickload the game named\n\n\'%s\'?\n\npress y or n.",
          savegamestrings[quickSaveSlot]);
#line 742
  M_StartMessage(tempstring, (void *)(& M_QuickLoadResponse), (boolean )1);
#line 743
  return;
}
}
#line 752 "m_menu.c"
void M_DrawReadThis1(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 754
  inhelpscreens = (boolean )1;
  {
#line 757
  if ((unsigned int )gamemode == 2U) {
#line 757
    goto case_2;
  }
#line 762
  if ((unsigned int )gamemode == 3U) {
#line 762
    goto case_3;
  }
#line 762
  if ((unsigned int )gamemode == 1U) {
#line 762
    goto case_3;
  }
#line 762
  if ((unsigned int )gamemode == 0U) {
#line 762
    goto case_3;
  }
#line 765
  goto switch_default;
  case_2: /* CIL Label */ 
#line 758
  tmp = W_CacheLumpName("HELP", 101);
#line 758
  V_DrawPatchDirect(0, 0, 0, (patch_t *)tmp);
#line 759
  goto switch_break;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 763
  tmp___0 = W_CacheLumpName("HELP1", 101);
#line 763
  V_DrawPatchDirect(0, 0, 0, (patch_t *)tmp___0);
#line 764
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 766
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 768
  return;
}
}
#line 776 "m_menu.c"
void M_DrawReadThis2(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 778
  inhelpscreens = (boolean )1;
  {
#line 782
  if ((unsigned int )gamemode == 2U) {
#line 782
    goto case_2;
  }
#line 782
  if ((unsigned int )gamemode == 3U) {
#line 782
    goto case_2;
  }
#line 787
  if ((unsigned int )gamemode == 1U) {
#line 787
    goto case_1;
  }
#line 787
  if ((unsigned int )gamemode == 0U) {
#line 787
    goto case_1;
  }
#line 790
  goto switch_default;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 784
  tmp = W_CacheLumpName("CREDIT", 101);
#line 784
  V_DrawPatchDirect(0, 0, 0, (patch_t *)tmp);
#line 785
  goto switch_break;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 788
  tmp___0 = W_CacheLumpName("HELP2", 101);
#line 788
  V_DrawPatchDirect(0, 0, 0, (patch_t *)tmp___0);
#line 789
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 791
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 793
  return;
}
}
#line 800 "m_menu.c"
void M_DrawSound(void) 
{ 
  void *tmp ;

  {
#line 802
  tmp = W_CacheLumpName("M_SVOL", 101);
#line 802
  V_DrawPatchDirect(60, 38, 0, (patch_t *)tmp);
#line 804
  M_DrawThermo((int )SoundDef.x, (int )SoundDef.y + 16, 16, snd_SfxVolume);
#line 807
  M_DrawThermo((int )SoundDef.x, (int )SoundDef.y + 48, 16, snd_MusicVolume);
#line 809
  return;
}
}
#line 811 "m_menu.c"
void M_Sound(int choice ) 
{ 


  {
#line 813
  M_SetupNextMenu(& SoundDef);
#line 814
  return;
}
}
#line 816 "m_menu.c"
void M_SfxVol(int choice ) 
{ 


  {
  {
#line 820
  if (choice == 0) {
#line 820
    goto case_0;
  }
#line 824
  if (choice == 1) {
#line 824
    goto case_1;
  }
#line 818
  goto switch_break;
  case_0: /* CIL Label */ 
#line 821
  if (snd_SfxVolume) {
#line 822
    snd_SfxVolume --;
  }
#line 823
  goto switch_break;
  case_1: /* CIL Label */ 
#line 825
  if (snd_SfxVolume < 15) {
#line 826
    snd_SfxVolume ++;
  }
#line 827
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 830
  S_SetSfxVolume(snd_SfxVolume);
#line 831
  return;
}
}
#line 833 "m_menu.c"
void M_MusicVol(int choice ) 
{ 


  {
  {
#line 837
  if (choice == 0) {
#line 837
    goto case_0;
  }
#line 841
  if (choice == 1) {
#line 841
    goto case_1;
  }
#line 835
  goto switch_break;
  case_0: /* CIL Label */ 
#line 838
  if (snd_MusicVolume) {
#line 839
    snd_MusicVolume --;
  }
#line 840
  goto switch_break;
  case_1: /* CIL Label */ 
#line 842
  if (snd_MusicVolume < 15) {
#line 843
    snd_MusicVolume ++;
  }
#line 844
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 847
  S_SetMusicVolume(snd_MusicVolume);
#line 848
  return;
}
}
#line 856 "m_menu.c"
void M_DrawMainMenu(void) 
{ 
  void *tmp ;

  {
#line 858
  tmp = W_CacheLumpName("M_DOOM", 101);
#line 858
  V_DrawPatchDirect(94, 2, 0, (patch_t *)tmp);
#line 859
  return;
}
}
#line 867 "m_menu.c"
void M_DrawNewGame(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 869
  tmp = W_CacheLumpName("M_NEWG", 101);
#line 869
  V_DrawPatchDirect(96, 14, 0, (patch_t *)tmp);
#line 870
  tmp___0 = W_CacheLumpName("M_SKILL", 101);
#line 870
  V_DrawPatchDirect(54, 38, 0, (patch_t *)tmp___0);
#line 871
  return;
}
}
#line 873 "m_menu.c"
void M_NewGame(int choice ) 
{ 


  {
#line 875
  if (netgame) {
#line 875
    if (! demoplayback) {
#line 877
      M_StartMessage("you can\'t start a new game\nwhile in a network game.\n\npress a key.",
                     (void *)0, (boolean )0);
#line 878
      return;
    } else {
#line 875
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 881
  if ((unsigned int )gamemode == 2U) {
#line 882
    M_SetupNextMenu(& NewDef);
  } else {
#line 884
    M_SetupNextMenu(& EpiDef);
  }
#line 885
  return;
}
}
#line 891 "m_menu.c"
int epi  ;
#line 893 "m_menu.c"
void M_DrawEpisode(void) 
{ 
  void *tmp ;

  {
#line 895
  tmp = W_CacheLumpName("M_EPISOD", 101);
#line 895
  V_DrawPatchDirect(54, 38, 0, (patch_t *)tmp);
#line 896
  return;
}
}
#line 898 "m_menu.c"
void M_VerifyNightmare(int ch ) 
{ 


  {
#line 900
  if (ch != 121) {
#line 901
    return;
  }
#line 903
  G_DeferedInitNew((skill_t )4, epi + 1, 1);
#line 904
  M_ClearMenus();
#line 905
  return;
}
}
#line 907 "m_menu.c"
void M_ChooseSkill(int choice ) 
{ 


  {
#line 909
  if (choice == 4) {
#line 911
    M_StartMessage("are you sure? this skill level\nisn\'t even remotely fair.\n\npress y or n.",
                   (void *)(& M_VerifyNightmare), (boolean )1);
#line 912
    return;
  }
#line 915
  G_DeferedInitNew((skill_t )choice, epi + 1, 1);
#line 916
  M_ClearMenus();
#line 917
  return;
}
}
#line 919 "m_menu.c"
void M_Episode(int choice ) 
{ 


  {
#line 921
  if ((unsigned int )gamemode == 0U) {
#line 921
    if (choice) {
#line 924
      M_StartMessage("this is the shareware version of doom.\n\nyou need to order the entire trilogy.\n\npress a key.",
                     (void *)0, (boolean )0);
#line 925
      M_SetupNextMenu(& ReadDef1);
#line 926
      return;
    } else {
#line 921
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 930
  if ((unsigned int )gamemode == 1U) {
#line 930
    if (choice > 2) {
#line 933
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"M_Episode: 4th episode requires UltimateDOOM\n");
#line 935
      choice = 0;
    } else {
#line 930
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 938
  epi = choice;
#line 939
  M_SetupNextMenu(& NewDef);
#line 940
  return;
}
}
#line 947 "m_menu.c"
char detailNames[2][9]  = { {        (char )'M',        (char )'_',        (char )'G',        (char )'D', 
            (char )'H',        (char )'I',        (char )'G',        (char )'H', 
            (char )'\000'}, 
   {        (char )'M',        (char )'_',        (char )'G',        (char )'D', 
            (char )'L',        (char )'O',        (char )'W',        (char )'\000'}};
#line 948 "m_menu.c"
char msgNames[2][9]  = { {        (char )'M',        (char )'_',        (char )'M',        (char )'S', 
            (char )'G',        (char )'O',        (char )'F',        (char )'F', 
            (char )'\000'}, 
   {        (char )'M',        (char )'_',        (char )'M',        (char )'S', 
            (char )'G',        (char )'O',        (char )'N',        (char )'\000'}};
#line 951 "m_menu.c"
void M_DrawOptions(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 953
  tmp = W_CacheLumpName("M_OPTTTL", 101);
#line 953
  V_DrawPatchDirect(108, 15, 0, (patch_t *)tmp);
#line 955
  tmp___0 = W_CacheLumpName(detailNames[detailLevel], 101);
#line 955
  V_DrawPatchDirect((int )OptionsDef.x + 175, (int )OptionsDef.y + 32, 0, (patch_t *)tmp___0);
#line 958
  tmp___1 = W_CacheLumpName(msgNames[showMessages], 101);
#line 958
  V_DrawPatchDirect((int )OptionsDef.x + 120, (int )OptionsDef.y + 16, 0, (patch_t *)tmp___1);
#line 961
  M_DrawThermo((int )OptionsDef.x, (int )OptionsDef.y + 96, 10, mouseSensitivity);
#line 964
  M_DrawThermo((int )OptionsDef.x, (int )OptionsDef.y + 64, 9, screenSize);
#line 966
  return;
}
}
#line 968 "m_menu.c"
void M_Options(int choice ) 
{ 


  {
#line 970
  M_SetupNextMenu(& OptionsDef);
#line 971
  return;
}
}
#line 978 "m_menu.c"
void M_ChangeMessages(int choice ) 
{ 


  {
#line 981
  choice = 0;
#line 982
  showMessages = 1 - showMessages;
#line 984
  if (! showMessages) {
#line 985
    players[consoleplayer].message = "Messages OFF";
  } else {
#line 987
    players[consoleplayer].message = "Messages ON";
  }
#line 989
  message_dontfuckwithme = (boolean )1;
#line 990
  return;
}
}
#line 996 "m_menu.c"
void M_EndGameResponse(int ch ) 
{ 


  {
#line 998
  if (ch != 121) {
#line 999
    return;
  }
#line 1001
  currentMenu->lastOn = itemOn;
#line 1002
  M_ClearMenus();
#line 1003
  D_StartTitle();
#line 1004
  return;
}
}
#line 1006 "m_menu.c"
void M_EndGame(int choice ) 
{ 


  {
#line 1008
  choice = 0;
#line 1009
  if (! usergame) {
#line 1011
    S_StartSound((void *)0, 34);
#line 1012
    return;
  }
#line 1015
  if (netgame) {
#line 1017
    M_StartMessage("you can\'t end a netgame!\n\npress a key.", (void *)0, (boolean )0);
#line 1018
    return;
  }
#line 1021
  M_StartMessage("are you sure you want to end the game?\n\npress y or n.", (void *)(& M_EndGameResponse),
                 (boolean )1);
#line 1022
  return;
}
}
#line 1030 "m_menu.c"
void M_ReadThis(int choice ) 
{ 


  {
#line 1032
  choice = 0;
#line 1033
  M_SetupNextMenu(& ReadDef1);
#line 1034
  return;
}
}
#line 1036 "m_menu.c"
void M_ReadThis2(int choice ) 
{ 


  {
#line 1038
  choice = 0;
#line 1039
  M_SetupNextMenu(& ReadDef2);
#line 1040
  return;
}
}
#line 1042 "m_menu.c"
void M_FinishReadThis(int choice ) 
{ 


  {
#line 1044
  choice = 0;
#line 1045
  M_SetupNextMenu(& MainDef);
#line 1046
  return;
}
}
#line 1054 "m_menu.c"
int quitsounds[8]  = 
#line 1054
  {      57,      26,      27,      31, 
        35,      36,      38,      52};
#line 1066 "m_menu.c"
int quitsounds2[8]  = 
#line 1066
  {      80,      93,      95,      31, 
        56,      72,      78,      52};
#line 1080 "m_menu.c"
void M_QuitResponse(int ch ) 
{ 


  {
#line 1082
  if (ch != 121) {
#line 1083
    return;
  }
#line 1084
  if (! netgame) {
#line 1086
    if ((unsigned int )gamemode == 2U) {
#line 1087
      S_StartSound((void *)0, quitsounds2[(gametic >> 2) & 7]);
    } else {
#line 1089
      S_StartSound((void *)0, quitsounds[(gametic >> 2) & 7]);
    }
#line 1090
    I_WaitVBL(105);
  }
#line 1092
  I_Quit();
#line 1093
  return;
}
}
#line 1098 "m_menu.c"
void M_QuitDOOM(int choice ) 
{ 


  {
#line 1102
  if ((unsigned int )language != 0U) {
#line 1103
    sprintf((char * __restrict  )(endstring), (char const   * __restrict  )"%s\n\n(press y to quit)",
            endmsg[0]);
  } else {
#line 1105
    sprintf((char * __restrict  )(endstring), (char const   * __restrict  )"%s\n\n(press y to quit)",
            endmsg[gametic % 20 + 1]);
  }
#line 1107
  M_StartMessage(endstring, (void *)(& M_QuitResponse), (boolean )1);
#line 1108
  return;
}
}
#line 1113 "m_menu.c"
void M_ChangeSensitivity(int choice ) 
{ 


  {
  {
#line 1117
  if (choice == 0) {
#line 1117
    goto case_0;
  }
#line 1121
  if (choice == 1) {
#line 1121
    goto case_1;
  }
#line 1115
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1118
  if (mouseSensitivity) {
#line 1119
    mouseSensitivity --;
  }
#line 1120
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1122
  if (mouseSensitivity < 9) {
#line 1123
    mouseSensitivity ++;
  }
#line 1124
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1126
  return;
}
}
#line 1131 "m_menu.c"
void M_ChangeDetail(int choice ) 
{ 


  {
#line 1133
  choice = 0;
#line 1134
  detailLevel = 1 - detailLevel;
#line 1137
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"M_ChangeDetail: low detail mode n.a.\n");
#line 1139
  return;
}
}
#line 1152 "m_menu.c"
void M_SizeDisplay(int choice ) 
{ 


  {
  {
#line 1156
  if (choice == 0) {
#line 1156
    goto case_0;
  }
#line 1163
  if (choice == 1) {
#line 1163
    goto case_1;
  }
#line 1154
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1157
  if (screenSize > 0) {
#line 1159
    screenblocks --;
#line 1160
    screenSize --;
  }
#line 1162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1164
  if (screenSize < 8) {
#line 1166
    screenblocks ++;
#line 1167
    screenSize ++;
  }
#line 1169
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1173
  R_SetViewSize(screenblocks, detailLevel);
#line 1174
  return;
}
}
#line 1182 "m_menu.c"
void M_DrawThermo(int x___0 , int y___1 , int thermWidth , int thermDot ) 
{ 
  int xx ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 1192
  xx = x___0;
#line 1193
  tmp = W_CacheLumpName("M_THERML", 101);
#line 1193
  V_DrawPatchDirect(xx, y___1, 0, (patch_t *)tmp);
#line 1194
  xx += 8;
#line 1195
  i = 0;
  {
#line 1195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1195
    if (! (i < thermWidth)) {
#line 1195
      goto while_break;
    }
#line 1197
    tmp___0 = W_CacheLumpName("M_THERMM", 101);
#line 1197
    V_DrawPatchDirect(xx, y___1, 0, (patch_t *)tmp___0);
#line 1198
    xx += 8;
#line 1195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1200
  tmp___1 = W_CacheLumpName("M_THERMR", 101);
#line 1200
  V_DrawPatchDirect(xx, y___1, 0, (patch_t *)tmp___1);
#line 1202
  tmp___2 = W_CacheLumpName("M_THERMO", 101);
#line 1202
  V_DrawPatchDirect((x___0 + 8) + thermDot * 8, y___1, 0, (patch_t *)tmp___2);
#line 1204
  return;
}
}
#line 1208 "m_menu.c"
void M_DrawEmptyCell(menu_t *menu , int item ) 
{ 
  void *tmp ;

  {
#line 1213
  tmp = W_CacheLumpName("M_CELL1", 101);
#line 1213
  V_DrawPatchDirect((int )menu->x - 10, ((int )menu->y + item * 16) - 1, 0, (patch_t *)tmp);
#line 1215
  return;
}
}
#line 1217 "m_menu.c"
void M_DrawSelCell(menu_t *menu , int item ) 
{ 
  void *tmp ;

  {
#line 1222
  tmp = W_CacheLumpName("M_CELL2", 101);
#line 1222
  V_DrawPatchDirect((int )menu->x - 10, ((int )menu->y + item * 16) - 1, 0, (patch_t *)tmp);
#line 1224
  return;
}
}
#line 1227 "m_menu.c"
void M_StartMessage(char *string , void *routine , boolean input ) 
{ 


  {
#line 1233
  messageLastMenuActive = (int )menuactive;
#line 1234
  messageToPrint = 1;
#line 1235
  messageString = string;
#line 1236
  messageRoutine = (void (*)(int response ))routine;
#line 1237
  messageNeedsInput = input;
#line 1238
  menuactive = (boolean )1;
#line 1239
  return;
}
}
#line 1244 "m_menu.c"
void M_StopMessage(void) 
{ 


  {
#line 1246
  menuactive = (boolean )messageLastMenuActive;
#line 1247
  messageToPrint = 0;
#line 1248
  return;
}
}
#line 1255 "m_menu.c"
int M_StringWidth(char *string ) 
{ 
  int i ;
  int w ;
  int c ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 1258
  w = 0;
#line 1261
  i = 0;
  {
#line 1261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1261
    tmp___0 = strlen((char const   *)string);
#line 1261
    if (! ((size_t )i < tmp___0)) {
#line 1261
      goto while_break;
    }
#line 1263
    tmp = toupper((int )*(string + i));
#line 1263
    c = tmp - 33;
#line 1264
    if (c < 0) {
#line 1264
      goto _L;
    } else
#line 1264
    if (c >= 63) {
      _L: /* CIL Label */ 
#line 1265
      w += 4;
    } else {
#line 1267
      w += (int )(hu_font[c])->width;
    }
#line 1261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1270
  return (w);
}
}
#line 1278 "m_menu.c"
int M_StringHeight(char *string ) 
{ 
  int i ;
  int h ;
  int height ;
  size_t tmp ;

  {
#line 1282
  height = (int )(hu_font[0])->height;
#line 1284
  h = height;
#line 1285
  i = 0;
  {
#line 1285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1285
    tmp = strlen((char const   *)string);
#line 1285
    if (! ((size_t )i < tmp)) {
#line 1285
      goto while_break;
    }
#line 1286
    if ((int )*(string + i) == 10) {
#line 1287
      h += height;
    }
#line 1285
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1289
  return (h);
}
}
#line 1296 "m_menu.c"
void M_WriteText(int x___0 , int y___1 , char *string ) 
{ 
  int w ;
  char *ch ;
  int c ;
  int cx ;
  int cy ;
  char *tmp ;
  int tmp___0 ;

  {
#line 1309
  ch = string;
#line 1310
  cx = x___0;
#line 1311
  cy = y___1;
  {
#line 1313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1313
    if (! 1) {
#line 1313
      goto while_break;
    }
#line 1315
    tmp = ch;
#line 1315
    ch ++;
#line 1315
    c = (int )*tmp;
#line 1316
    if (! c) {
#line 1317
      goto while_break;
    }
#line 1318
    if (c == 10) {
#line 1320
      cx = x___0;
#line 1321
      cy += 12;
#line 1322
      goto while_continue;
    }
#line 1325
    tmp___0 = toupper(c);
#line 1325
    c = tmp___0 - 33;
#line 1326
    if (c < 0) {
#line 1326
      goto _L;
    } else
#line 1326
    if (c >= 63) {
      _L: /* CIL Label */ 
#line 1328
      cx += 4;
#line 1329
      goto while_continue;
    }
#line 1332
    w = (int )(hu_font[c])->width;
#line 1333
    if (cx + w > 320) {
#line 1334
      goto while_break;
    }
#line 1335
    V_DrawPatchDirect(cx, cy, 0, hu_font[c]);
#line 1336
    cx += w;
  }
  while_break: /* CIL Label */ ;
  }
#line 1338
  return;
}
}
#line 1353 "m_menu.c"
static int joywait  =    0;
#line 1354 "m_menu.c"
static int mousewait  =    0;
#line 1355 "m_menu.c"
static int mousey___0  =    0;
#line 1356 "m_menu.c"
static int lasty  =    0;
#line 1357 "m_menu.c"
static int mousex___0  =    0;
#line 1358 "m_menu.c"
static int lastx  =    0;
#line 1349 "m_menu.c"
boolean M_Responder(event_t *ev ) 
{ 
  int ch ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;

  {
#line 1360
  ch = -1;
#line 1362
  if ((unsigned int )ev->type == 3U) {
#line 1362
    tmp___12 = I_GetTime();
#line 1362
    if (joywait < tmp___12) {
#line 1364
      if (ev->data3 == -1) {
#line 1366
        ch = 0xad;
#line 1367
        tmp = I_GetTime();
#line 1367
        joywait = tmp + 5;
      } else
#line 1369
      if (ev->data3 == 1) {
#line 1371
        ch = 0xaf;
#line 1372
        tmp___0 = I_GetTime();
#line 1372
        joywait = tmp___0 + 5;
      }
#line 1375
      if (ev->data2 == -1) {
#line 1377
        ch = 0xac;
#line 1378
        tmp___1 = I_GetTime();
#line 1378
        joywait = tmp___1 + 2;
      } else
#line 1380
      if (ev->data2 == 1) {
#line 1382
        ch = 0xae;
#line 1383
        tmp___2 = I_GetTime();
#line 1383
        joywait = tmp___2 + 2;
      }
#line 1386
      if (ev->data1 & 1) {
#line 1388
        ch = 13;
#line 1389
        tmp___3 = I_GetTime();
#line 1389
        joywait = tmp___3 + 5;
      }
#line 1391
      if (ev->data1 & 2) {
#line 1393
        ch = 127;
#line 1394
        tmp___4 = I_GetTime();
#line 1394
        joywait = tmp___4 + 5;
      }
    } else {
#line 1362
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1399
  if ((unsigned int )ev->type == 2U) {
#line 1399
    tmp___11 = I_GetTime();
#line 1399
    if (mousewait < tmp___11) {
#line 1401
      mousey___0 += ev->data3;
#line 1402
      if (mousey___0 < lasty - 30) {
#line 1404
        ch = 0xaf;
#line 1405
        tmp___5 = I_GetTime();
#line 1405
        mousewait = tmp___5 + 5;
#line 1406
        lasty -= 30;
#line 1406
        mousey___0 = lasty;
      } else
#line 1408
      if (mousey___0 > lasty + 30) {
#line 1410
        ch = 0xad;
#line 1411
        tmp___6 = I_GetTime();
#line 1411
        mousewait = tmp___6 + 5;
#line 1412
        lasty += 30;
#line 1412
        mousey___0 = lasty;
      }
#line 1415
      mousex___0 += ev->data2;
#line 1416
      if (mousex___0 < lastx - 30) {
#line 1418
        ch = 0xac;
#line 1419
        tmp___7 = I_GetTime();
#line 1419
        mousewait = tmp___7 + 5;
#line 1420
        lastx -= 30;
#line 1420
        mousex___0 = lastx;
      } else
#line 1422
      if (mousex___0 > lastx + 30) {
#line 1424
        ch = 0xae;
#line 1425
        tmp___8 = I_GetTime();
#line 1425
        mousewait = tmp___8 + 5;
#line 1426
        lastx += 30;
#line 1426
        mousex___0 = lastx;
      }
#line 1429
      if (ev->data1 & 1) {
#line 1431
        ch = 13;
#line 1432
        tmp___9 = I_GetTime();
#line 1432
        mousewait = tmp___9 + 15;
      }
#line 1435
      if (ev->data1 & 2) {
#line 1437
        ch = 127;
#line 1438
        tmp___10 = I_GetTime();
#line 1438
        mousewait = tmp___10 + 15;
      }
    } else {
#line 1399
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1442
  if ((unsigned int )ev->type == 0U) {
#line 1444
    ch = ev->data1;
  }
#line 1448
  if (ch == -1) {
#line 1449
    return ((boolean )0);
  }
#line 1453
  if (saveStringEnter) {
    {
#line 1457
    if (ch == 127) {
#line 1457
      goto case_127;
    }
#line 1465
    if (ch == 27) {
#line 1465
      goto case_27;
    }
#line 1470
    if (ch == 13) {
#line 1470
      goto case_13;
    }
#line 1476
    goto switch_default;
    case_127: /* CIL Label */ 
#line 1458
    if (saveCharIndex > 0) {
#line 1460
      saveCharIndex --;
#line 1461
      savegamestrings[saveSlot][saveCharIndex] = (char)0;
    }
#line 1463
    goto switch_break;
    case_27: /* CIL Label */ 
#line 1466
    saveStringEnter = 0;
#line 1467
    strcpy((char * __restrict  )(& savegamestrings[saveSlot][0]), (char const   * __restrict  )(saveOldString));
#line 1468
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1471
    saveStringEnter = 0;
#line 1472
    if (savegamestrings[saveSlot][0]) {
#line 1473
      M_DoSave(saveSlot);
    }
#line 1474
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1477
    ch = toupper(ch);
#line 1478
    if (ch != 32) {
#line 1479
      if (ch - 33 < 0) {
#line 1479
        goto _L___1;
      } else
#line 1479
      if (ch - 33 >= 63) {
        _L___1: /* CIL Label */ 
#line 1480
        goto switch_break;
      }
    }
#line 1481
    if (ch >= 32) {
#line 1481
      if (ch <= 127) {
#line 1481
        if (saveCharIndex < 23) {
#line 1481
          tmp___14 = M_StringWidth(savegamestrings[saveSlot]);
#line 1481
          if (tmp___14 < 176) {
#line 1486
            tmp___13 = saveCharIndex;
#line 1486
            saveCharIndex ++;
#line 1486
            savegamestrings[saveSlot][tmp___13] = (char )ch;
#line 1487
            savegamestrings[saveSlot][saveCharIndex] = (char)0;
          } else {
#line 1481
            goto _L___4;
          }
        } else {
#line 1481
          goto _L___4;
        }
      } else {
#line 1481
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
      _L___3: /* CIL Label */ 
      _L___2: /* CIL Label */ ;
    }
#line 1489
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1491
    return ((boolean )1);
  }
#line 1495
  if (messageToPrint) {
#line 1497
    if ((unsigned int )messageNeedsInput == 1U) {
#line 1497
      if (ch == 32) {
#line 1497
        goto _L___8;
      } else
#line 1497
      if (ch == 110) {
        _L___8: /* CIL Label */ 
#line 1497
        goto _L___7;
      } else
#line 1497
      if (ch == 121) {
        _L___7: /* CIL Label */ 
#line 1497
        goto _L___6;
      } else
#line 1497
      if (ch == 27) {
        _L___6: /* CIL Label */ 
#line 1497
        goto _L___5;
      } else {
#line 1499
        return ((boolean )0);
      }
    } else {
      _L___5: /* CIL Label */ ;
    }
#line 1501
    menuactive = (boolean )messageLastMenuActive;
#line 1502
    messageToPrint = 0;
#line 1503
    if (messageRoutine) {
#line 1504
      (*messageRoutine)(ch);
    }
#line 1506
    menuactive = (boolean )0;
#line 1507
    S_StartSound((void *)0, 24);
#line 1508
    return ((boolean )1);
  }
#line 1511
  if (devparm) {
#line 1511
    if (ch == 187) {
#line 1513
      G_ScreenShot();
#line 1514
      return ((boolean )1);
    } else {
#line 1511
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ ;
  }
#line 1519
  if (! menuactive) {
    {
#line 1522
    if (ch == 0x2d) {
#line 1522
      goto case_45;
    }
#line 1529
    if (ch == 0x3d) {
#line 1529
      goto case_61;
    }
#line 1536
    if (ch == 187) {
#line 1536
      goto case_187;
    }
#line 1548
    if (ch == 188) {
#line 1548
      goto case_188;
    }
#line 1554
    if (ch == 189) {
#line 1554
      goto case_189;
    }
#line 1560
    if (ch == 190) {
#line 1560
      goto case_190;
    }
#line 1567
    if (ch == 191) {
#line 1567
      goto case_191;
    }
#line 1572
    if (ch == 192) {
#line 1572
      goto case_192;
    }
#line 1577
    if (ch == 193) {
#line 1577
      goto case_193;
    }
#line 1582
    if (ch == 194) {
#line 1582
      goto case_194;
    }
#line 1587
    if (ch == 195) {
#line 1587
      goto case_195;
    }
#line 1592
    if (ch == 196) {
#line 1592
      goto case_196;
    }
#line 1597
    if (ch == 215) {
#line 1597
      goto case_215;
    }
#line 1520
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 1523
    if (automapactive) {
#line 1523
      goto _L___10;
    } else
#line 1523
    if (chat_on) {
      _L___10: /* CIL Label */ 
#line 1524
      return ((boolean )0);
    }
#line 1525
    M_SizeDisplay(0);
#line 1526
    S_StartSound((void *)0, 22);
#line 1527
    return ((boolean )1);
    case_61: /* CIL Label */ 
#line 1530
    if (automapactive) {
#line 1530
      goto _L___11;
    } else
#line 1530
    if (chat_on) {
      _L___11: /* CIL Label */ 
#line 1531
      return ((boolean )0);
    }
#line 1532
    M_SizeDisplay(1);
#line 1533
    S_StartSound((void *)0, 22);
#line 1534
    return ((boolean )1);
    case_187: /* CIL Label */ 
#line 1537
    M_StartControlPanel();
#line 1539
    if ((unsigned int )gamemode == 3U) {
#line 1540
      currentMenu = & ReadDef2;
    } else {
#line 1542
      currentMenu = & ReadDef1;
    }
#line 1544
    itemOn = (short)0;
#line 1545
    S_StartSound((void *)0, 23);
#line 1546
    return ((boolean )1);
    case_188: /* CIL Label */ 
#line 1549
    M_StartControlPanel();
#line 1550
    S_StartSound((void *)0, 23);
#line 1551
    M_SaveGame(0);
#line 1552
    return ((boolean )1);
    case_189: /* CIL Label */ 
#line 1555
    M_StartControlPanel();
#line 1556
    S_StartSound((void *)0, 23);
#line 1557
    M_LoadGame(0);
#line 1558
    return ((boolean )1);
    case_190: /* CIL Label */ 
#line 1561
    M_StartControlPanel();
#line 1562
    currentMenu = & SoundDef;
#line 1563
    itemOn = (short)0;
#line 1564
    S_StartSound((void *)0, 23);
#line 1565
    return ((boolean )1);
    case_191: /* CIL Label */ 
#line 1568
    M_ChangeDetail(0);
#line 1569
    S_StartSound((void *)0, 23);
#line 1570
    return ((boolean )1);
    case_192: /* CIL Label */ 
#line 1573
    S_StartSound((void *)0, 23);
#line 1574
    M_QuickSave();
#line 1575
    return ((boolean )1);
    case_193: /* CIL Label */ 
#line 1578
    S_StartSound((void *)0, 23);
#line 1579
    M_EndGame(0);
#line 1580
    return ((boolean )1);
    case_194: /* CIL Label */ 
#line 1583
    M_ChangeMessages(0);
#line 1584
    S_StartSound((void *)0, 23);
#line 1585
    return ((boolean )1);
    case_195: /* CIL Label */ 
#line 1588
    S_StartSound((void *)0, 23);
#line 1589
    M_QuickLoad();
#line 1590
    return ((boolean )1);
    case_196: /* CIL Label */ 
#line 1593
    S_StartSound((void *)0, 23);
#line 1594
    M_QuitDOOM(0);
#line 1595
    return ((boolean )1);
    case_215: /* CIL Label */ 
#line 1598
    usegamma ++;
#line 1599
    if (usegamma > 4) {
#line 1600
      usegamma = 0;
    }
#line 1601
    players[consoleplayer].message = gammamsg[usegamma];
#line 1602
    tmp___15 = W_CacheLumpName("PLAYPAL", 101);
#line 1602
    I_SetPalette((byte *)tmp___15);
#line 1603
    return ((boolean )1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1609
  if (! menuactive) {
#line 1611
    if (ch == 27) {
#line 1613
      M_StartControlPanel();
#line 1614
      S_StartSound((void *)0, 23);
#line 1615
      return ((boolean )1);
    }
#line 1617
    return ((boolean )0);
  }
  {
#line 1624
  if (ch == 0xaf) {
#line 1624
    goto case_175;
  }
#line 1634
  if (ch == 0xad) {
#line 1634
    goto case_173;
  }
#line 1644
  if (ch == 0xac) {
#line 1644
    goto case_172;
  }
#line 1653
  if (ch == 0xae) {
#line 1653
    goto case_174;
  }
#line 1662
  if (ch == 13) {
#line 1662
    goto case_13___0;
  }
#line 1680
  if (ch == 27) {
#line 1680
    goto case_27___0;
  }
#line 1686
  if (ch == 127) {
#line 1686
    goto case_127___0;
  }
#line 1696
  goto switch_default___0;
  case_175: /* CIL Label */ 
  {
#line 1625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1627
    if ((int )itemOn + 1 > (int )currentMenu->numitems - 1) {
#line 1628
      itemOn = (short)0;
    } else {
#line 1629
      itemOn = (short )((int )itemOn + 1);
    }
#line 1630
    S_StartSound((void *)0, 19);
#line 1625
    if (! ((int )(currentMenu->menuitems + itemOn)->status == -1)) {
#line 1625
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1632
  return ((boolean )1);
  case_173: /* CIL Label */ 
  {
#line 1635
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1637
    if (! itemOn) {
#line 1638
      itemOn = (short )((int )currentMenu->numitems - 1);
    } else {
#line 1639
      itemOn = (short )((int )itemOn - 1);
    }
#line 1640
    S_StartSound((void *)0, 19);
#line 1635
    if (! ((int )(currentMenu->menuitems + itemOn)->status == -1)) {
#line 1635
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1642
  return ((boolean )1);
  case_172: /* CIL Label */ 
#line 1645
  if ((currentMenu->menuitems + itemOn)->routine) {
#line 1645
    if ((int )(currentMenu->menuitems + itemOn)->status == 2) {
#line 1648
      S_StartSound((void *)0, 22);
#line 1649
      (*((currentMenu->menuitems + itemOn)->routine))(0);
    } else {
#line 1645
      goto _L___12;
    }
  } else {
    _L___12: /* CIL Label */ ;
  }
#line 1651
  return ((boolean )1);
  case_174: /* CIL Label */ 
#line 1654
  if ((currentMenu->menuitems + itemOn)->routine) {
#line 1654
    if ((int )(currentMenu->menuitems + itemOn)->status == 2) {
#line 1657
      S_StartSound((void *)0, 22);
#line 1658
      (*((currentMenu->menuitems + itemOn)->routine))(1);
    } else {
#line 1654
      goto _L___13;
    }
  } else {
    _L___13: /* CIL Label */ ;
  }
#line 1660
  return ((boolean )1);
  case_13___0: /* CIL Label */ 
#line 1663
  if ((currentMenu->menuitems + itemOn)->routine) {
#line 1663
    if ((currentMenu->menuitems + itemOn)->status) {
#line 1666
      currentMenu->lastOn = itemOn;
#line 1667
      if ((int )(currentMenu->menuitems + itemOn)->status == 2) {
#line 1669
        (*((currentMenu->menuitems + itemOn)->routine))(1);
#line 1670
        S_StartSound((void *)0, 22);
      } else {
#line 1674
        (*((currentMenu->menuitems + itemOn)->routine))((int )itemOn);
#line 1675
        S_StartSound((void *)0, 1);
      }
    } else {
#line 1663
      goto _L___14;
    }
  } else {
    _L___14: /* CIL Label */ ;
  }
#line 1678
  return ((boolean )1);
  case_27___0: /* CIL Label */ 
#line 1681
  currentMenu->lastOn = itemOn;
#line 1682
  M_ClearMenus();
#line 1683
  S_StartSound((void *)0, 24);
#line 1684
  return ((boolean )1);
  case_127___0: /* CIL Label */ 
#line 1687
  currentMenu->lastOn = itemOn;
#line 1688
  if (currentMenu->prevMenu) {
#line 1690
    currentMenu = currentMenu->prevMenu;
#line 1691
    itemOn = currentMenu->lastOn;
#line 1692
    S_StartSound((void *)0, 23);
  }
#line 1694
  return ((boolean )1);
  switch_default___0: /* CIL Label */ 
#line 1697
  i = (int )itemOn + 1;
  {
#line 1697
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1697
    if (! (i < (int )currentMenu->numitems)) {
#line 1697
      goto while_break___1;
    }
#line 1698
    if ((int )(currentMenu->menuitems + i)->alphaKey == ch) {
#line 1700
      itemOn = (short )i;
#line 1701
      S_StartSound((void *)0, 19);
#line 1702
      return ((boolean )1);
    }
#line 1697
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1704
  i = 0;
  {
#line 1704
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1704
    if (! (i <= (int )itemOn)) {
#line 1704
      goto while_break___2;
    }
#line 1705
    if ((int )(currentMenu->menuitems + i)->alphaKey == ch) {
#line 1707
      itemOn = (short )i;
#line 1708
      S_StartSound((void *)0, 19);
#line 1709
      return ((boolean )1);
    }
#line 1704
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1711
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1715
  return ((boolean )0);
}
}
#line 1723 "m_menu.c"
void M_StartControlPanel(void) 
{ 


  {
#line 1726
  if (menuactive) {
#line 1727
    return;
  }
#line 1729
  menuactive = (boolean )1;
#line 1730
  currentMenu = & MainDef;
#line 1731
  itemOn = currentMenu->lastOn;
#line 1732
  return;
}
}
#line 1742 "m_menu.c"
static short x  ;
#line 1743 "m_menu.c"
static short y___0  ;
#line 1740 "m_menu.c"
void M_Drawer(void) 
{ 
  short i ;
  short max ;
  char string[40] ;
  int start ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 1749
  inhelpscreens = (boolean )0;
#line 1753
  if (messageToPrint) {
#line 1755
    start = 0;
#line 1756
    tmp = M_StringHeight(messageString);
#line 1756
    y___0 = (short )(100 - tmp / 2);
    {
#line 1757
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1757
      if (! *(messageString + start)) {
#line 1757
        goto while_break;
      }
#line 1759
      i = (short)0;
      {
#line 1759
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1759
        tmp___0 = strlen((char const   *)(messageString + start));
#line 1759
        if (! ((size_t )i < tmp___0)) {
#line 1759
          goto while_break___0;
        }
#line 1760
        if ((int )*((messageString + start) + (int )i) == 10) {
#line 1762
          memset((void *)(string), 0, (size_t )40);
#line 1763
          strncpy((char * __restrict  )(string), (char const   * __restrict  )(messageString + start),
                  (size_t )i);
#line 1764
          start += (int )i + 1;
#line 1765
          goto while_break___0;
        }
#line 1759
        i = (short )((int )i + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1768
      tmp___1 = strlen((char const   *)(messageString + start));
#line 1768
      if ((size_t )i == tmp___1) {
#line 1770
        strcpy((char * __restrict  )(string), (char const   * __restrict  )(messageString + start));
#line 1771
        start += (int )i;
      }
#line 1774
      tmp___2 = M_StringWidth(string);
#line 1774
      x = (short )(160 - tmp___2 / 2);
#line 1775
      M_WriteText((int )x, (int )y___0, string);
#line 1776
      y___0 = (short )((int )y___0 + (int )(hu_font[0])->height);
    }
    while_break: /* CIL Label */ ;
    }
#line 1778
    return;
  }
#line 1781
  if (! menuactive) {
#line 1782
    return;
  }
#line 1784
  if (currentMenu->routine) {
#line 1785
    (*(currentMenu->routine))();
  }
#line 1788
  x = currentMenu->x;
#line 1789
  y___0 = currentMenu->y;
#line 1790
  max = currentMenu->numitems;
#line 1792
  i = (short)0;
  {
#line 1792
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1792
    if (! ((int )i < (int )max)) {
#line 1792
      goto while_break___1;
    }
#line 1794
    if ((currentMenu->menuitems + i)->name[0]) {
#line 1795
      tmp___3 = W_CacheLumpName((currentMenu->menuitems + i)->name, 101);
#line 1795
      V_DrawPatchDirect((int )x, (int )y___0, 0, (patch_t *)tmp___3);
    }
#line 1797
    y___0 = (short )((int )y___0 + 16);
#line 1792
    i = (short )((int )i + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1802
  tmp___4 = W_CacheLumpName(skullName[whichSkull], 101);
#line 1802
  V_DrawPatchDirect((int )x + -32, ((int )currentMenu->y - 5) + (int )itemOn * 16,
                    0, (patch_t *)tmp___4);
#line 1805
  return;
}
}
#line 1811 "m_menu.c"
void M_ClearMenus(void) 
{ 


  {
#line 1813
  menuactive = (boolean )0;
#line 1816
  return;
}
}
#line 1824 "m_menu.c"
void M_SetupNextMenu(menu_t *menudef ) 
{ 


  {
#line 1826
  currentMenu = menudef;
#line 1827
  itemOn = currentMenu->lastOn;
#line 1828
  return;
}
}
#line 1834 "m_menu.c"
void M_Ticker(void) 
{ 


  {
#line 1836
  skullAnimCounter = (short )((int )skullAnimCounter - 1);
#line 1836
  if ((int )skullAnimCounter <= 0) {
#line 1838
    whichSkull = (short )((int )whichSkull ^ 1);
#line 1839
    skullAnimCounter = (short)8;
  }
#line 1841
  return;
}
}
#line 1847 "m_menu.c"
void M_Init(void) 
{ 


  {
#line 1849
  currentMenu = & MainDef;
#line 1850
  menuactive = (boolean )0;
#line 1851
  itemOn = currentMenu->lastOn;
#line 1852
  whichSkull = (short)0;
#line 1853
  skullAnimCounter = (short)10;
#line 1854
  screenSize = screenblocks - 3;
#line 1855
  messageToPrint = 0;
#line 1856
  messageString = (char *)((void *)0);
#line 1857
  messageLastMenuActive = (int )menuactive;
#line 1858
  quickSaveSlot = -1;
  {
#line 1866
  if ((unsigned int )gamemode == 2U) {
#line 1866
    goto case_2;
  }
#line 1882
  if ((unsigned int )gamemode == 1U) {
#line 1882
    goto case_1;
  }
#line 1882
  if ((unsigned int )gamemode == 0U) {
#line 1882
    goto case_1;
  }
#line 1888
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1870
  MainMenu[4] = MainMenu[5];
#line 1871
  MainDef.numitems = (short )((int )MainDef.numitems - 1);
#line 1872
  MainDef.y = (short )((int )MainDef.y + 8);
#line 1873
  NewDef.prevMenu = & MainDef;
#line 1874
  ReadDef1.routine = (void (*)())(& M_DrawReadThis1);
#line 1875
  ReadDef1.x = (short)330;
#line 1876
  ReadDef1.y = (short)165;
#line 1877
  ReadMenu1[0].routine = & M_FinishReadThis;
#line 1878
  goto switch_break;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 1884
  EpiDef.numitems = (short )((int )EpiDef.numitems - 1);
#line 1885
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1889
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1892
  return;
}
}
#line 27 "m_misc.c"
static char const   rcsid___14[49]  = 
#line 27 "m_misc.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'m', 
        (char const   )'i',      (char const   )'s',      (char const   )'c',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 69 "m_misc.c"
int M_DrawText(int x___0 , int y___1 , boolean direct , char *string ) 
{ 
  int c ;
  int w ;
  int tmp ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! *string) {
#line 79
      goto while_break;
    }
#line 81
    tmp = toupper((int )*string);
#line 81
    c = tmp - 33;
#line 82
    string ++;
#line 83
    if (c < 0) {
#line 83
      goto _L;
    } else
#line 83
    if (c > 63) {
      _L: /* CIL Label */ 
#line 85
      x___0 += 4;
#line 86
      goto while_continue;
    }
#line 89
    w = (int )(hu_font[c])->width;
#line 90
    if (x___0 + w > 320) {
#line 91
      goto while_break;
    }
#line 92
    if (direct) {
#line 93
      V_DrawPatchDirect(x___0, y___1, 0, hu_font[c]);
    } else {
#line 95
      V_DrawPatch(x___0, y___1, 0, hu_font[c]);
    }
#line 96
    x___0 += w;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (x___0);
}
}
#line 112 "m_misc.c"
boolean M_WriteFile(char const   *name , void *source , int length ) 
{ 
  int handle ;
  int count ;

  {
#line 121
  handle = open(name, 577, 0666);
#line 123
  if (handle == -1) {
#line 124
    return ((boolean )0);
  }
#line 126
  count = write(handle, (void const   *)source, (size_t )length);
#line 127
  close(handle);
#line 129
  if (count < length) {
#line 130
    return ((boolean )0);
  }
#line 132
  return ((boolean )1);
}
}
#line 139 "m_misc.c"
int M_ReadFile(char const   *name , byte **buffer___0 ) 
{ 
  int handle ;
  int count ;
  int length ;
  struct stat fileinfo ;
  byte *buf ;
  int tmp ;
  void *tmp___0 ;

  {
#line 148
  handle = open(name, 0, 0666);
#line 149
  if (handle == -1) {
#line 150
    I_Error("Couldn\'t read file %s", name);
  }
#line 151
  tmp = fstat(handle, & fileinfo);
#line 151
  if (tmp == -1) {
#line 152
    I_Error("Couldn\'t read file %s", name);
  }
#line 153
  length = (int )fileinfo.st_size;
#line 154
  tmp___0 = Z_Malloc(length, 1, (void *)0);
#line 154
  buf = (byte *)tmp___0;
#line 155
  count = read(handle, (void *)buf, (size_t )length);
#line 156
  close(handle);
#line 158
  if (count < length) {
#line 159
    I_Error("Couldn\'t read file %s", name);
  }
#line 161
  *buffer___0 = buf;
#line 162
  return (length);
}
}
#line 169 "m_misc.c"
int usemouse  ;
#line 170 "m_misc.c"
int usejoystick  ;
#line 207
int numChannels ;
#line 217 "m_misc.c"
char *mousetype  ;
#line 218 "m_misc.c"
char *mousedev  ;
#line 221
char *chat_macros[10] ;
#line 234 "m_misc.c"
default_t defaults[41]  = 
#line 234
  {      {"mouse_sensitivity", & mouseSensitivity, 5, 0, 0}, 
        {"sfx_volume", & snd_SfxVolume, 8, 0, 0}, 
        {"music_volume", & snd_MusicVolume, 8, 0, 0}, 
        {"show_messages", & showMessages, 1, 0, 0}, 
        {"key_right", & key_right, 0xae, 0, 0}, 
        {"key_left", & key_left, 0xac, 0, 0}, 
        {"key_up", & key_up, 0xad, 0, 0}, 
        {"key_down", & key_down, 0xaf, 0, 0}, 
        {"key_strafeleft", & key_strafeleft, ',', 0, 0}, 
        {"key_straferight", & key_straferight, '.', 0, 0}, 
        {"key_fire", & key_fire, 157, 0, 0}, 
        {"key_use", & key_use, ' ', 0, 0}, 
        {"key_strafe", & key_strafe, 184, 0, 0}, 
        {"key_speed", & key_speed, 182, 0, 0}, 
        {"sndserver", (int *)(& sndserver_filename), (int )"sndserver", 0, 0}, 
        {"mb_used", & mb_used, 2, 0, 0}, 
        {"mousedev", (int *)(& mousedev), (int )"/dev/ttyS0", 0, 0}, 
        {"mousetype", (int *)(& mousetype), (int )"microsoft", 0, 0}, 
        {"use_mouse", & usemouse, 1, 0, 0}, 
        {"mouseb_fire", & mousebfire, 0, 0, 0}, 
        {"mouseb_strafe", & mousebstrafe, 1, 0, 0}, 
        {"mouseb_forward", & mousebforward, 2, 0, 0}, 
        {"use_joystick", & usejoystick, 0, 0, 0}, 
        {"joyb_fire", & joybfire, 0, 0, 0}, 
        {"joyb_strafe", & joybstrafe, 1, 0, 0}, 
        {"joyb_use", & joybuse, 3, 0, 0}, 
        {"joyb_speed", & joybspeed, 2, 0, 0}, 
        {"screenblocks", & screenblocks, 9, 0, 0}, 
        {"detaillevel", & detailLevel, 0, 0, 0}, 
        {"snd_channels", & numChannels, 3, 0, 0}, 
        {"usegamma", & usegamma, 0, 0, 0}, 
        {"chatmacro0", (int *)(& chat_macros[0]), (int )"No", 0, 0}, 
        {"chatmacro1", (int *)(& chat_macros[1]), (int )"I\'m ready to kick butt!", 0,
      0}, 
        {"chatmacro2", (int *)(& chat_macros[2]), (int )"I\'m OK.", 0, 0}, 
        {"chatmacro3", (int *)(& chat_macros[3]), (int )"I\'m not looking too good!",
      0, 0}, 
        {"chatmacro4", (int *)(& chat_macros[4]), (int )"Help!", 0, 0}, 
        {"chatmacro5", (int *)(& chat_macros[5]), (int )"You suck!", 0, 0}, 
        {"chatmacro6", (int *)(& chat_macros[6]), (int )"Next time, scumbag...", 0, 0}, 
        {"chatmacro7", (int *)(& chat_macros[7]), (int )"Come here!", 0, 0}, 
        {"chatmacro8", (int *)(& chat_macros[8]), (int )"I\'ll take care of it.", 0,
      0}, 
        {"chatmacro9", (int *)(& chat_macros[9]), (int )"Yes", 0, 0}};
#line 301 "m_misc.c"
int numdefaults  ;
#line 302 "m_misc.c"
char *defaultfile  ;
#line 308 "m_misc.c"
void M_SaveDefaults(void) 
{ 
  int i ;
  int v ;
  FILE *f ;

  {
#line 314
  f = fopen((char const   * __restrict  )defaultfile, (char const   * __restrict  )"w");
#line 315
  if (! f) {
#line 316
    return;
  }
#line 318
  i = 0;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! (i < numdefaults)) {
#line 318
      goto while_break;
    }
#line 320
    if (defaults[i].defaultvalue > -4095) {
#line 320
      if (defaults[i].defaultvalue < 0xfff) {
#line 323
        v = *(defaults[i].location);
#line 324
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s\t\t%i\n",
                defaults[i].name, v);
      } else {
#line 320
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 326
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s\t\t\"%s\"\n",
              defaults[i].name, *((char **)defaults[i].location));
    }
#line 318
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  fclose(f);
#line 332
  return;
}
}
#line 338
extern byte scantokey[128] ;
#line 340 "m_misc.c"
void M_LoadDefaults(void) 
{ 
  int i ;
  int len ;
  FILE *f ;
  char def[80] ;
  char strparm[100] ;
  char *newstring ;
  int parm ;
  boolean isstring ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 352
  numdefaults = (int )(sizeof(defaults) / sizeof(defaults[0]));
#line 353
  i = 0;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! (i < numdefaults)) {
#line 353
      goto while_break;
    }
#line 354
    *(defaults[i].location) = defaults[i].defaultvalue;
#line 353
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  i = M_CheckParm("-config");
#line 358
  if (i) {
#line 358
    if (i < myargc - 1) {
#line 360
      defaultfile = *(myargv + (i + 1));
#line 361
      printf((char const   * __restrict  )"\tdefault file: %s\n", defaultfile);
    } else {
#line 358
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 364
    defaultfile = basedefault;
  }
#line 367
  f = fopen((char const   * __restrict  )defaultfile, (char const   * __restrict  )"r");
#line 368
  if (f) {
    {
#line 370
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 370
      tmp___3 = feof(f);
#line 370
      if (tmp___3) {
#line 370
        goto while_break___0;
      }
#line 372
      isstring = (boolean )0;
#line 373
      tmp___2 = fscanf(f, (char const   *)"%79s %[^\n]\n", def, strparm);
#line 373
      if (tmp___2 == 2) {
#line 375
        if ((int )strparm[0] == 34) {
#line 378
          isstring = (boolean )1;
#line 379
          tmp = strlen((char const   *)(strparm));
#line 379
          len = (int )tmp;
#line 380
          tmp___0 = malloc((size_t )len);
#line 380
          newstring = (char *)tmp___0;
#line 381
          strparm[len - 1] = (char)0;
#line 382
          strcpy((char * __restrict  )newstring, (char const   * __restrict  )(strparm + 1));
        } else
#line 384
        if ((int )strparm[0] == 48) {
#line 384
          if ((int )strparm[1] == 120) {
#line 385
            sscanf((char const   *)(strparm + 2), (char const   *)"%x", & parm);
          } else {
#line 384
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 387
          sscanf((char const   *)(strparm), (char const   *)"%i", & parm);
        }
#line 388
        i = 0;
        {
#line 388
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 388
          if (! (i < numdefaults)) {
#line 388
            goto while_break___1;
          }
#line 389
          tmp___1 = strcmp((char const   *)(def), (char const   *)defaults[i].name);
#line 389
          if (! tmp___1) {
#line 391
            if (! isstring) {
#line 392
              *(defaults[i].location) = parm;
            } else {
#line 394
              *(defaults[i].location) = (int )newstring;
            }
#line 396
            goto while_break___1;
          }
#line 388
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 401
    fclose(f);
  }
#line 403
  return;
}
}
#line 441 "m_misc.c"
void WritePCXfile(char *filename , byte *data , int width , int height , byte *palette ) 
{ 
  int i ;
  int length ;
  pcx_t *pcx ;
  byte *pack ;
  void *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;

  {
#line 454
  tmp = Z_Malloc((width * height) * 2 + 1000, 1, (void *)0);
#line 454
  pcx = (pcx_t *)tmp;
#line 456
  pcx->manufacturer = (char)10;
#line 457
  pcx->version = (char)5;
#line 458
  pcx->encoding = (char)1;
#line 459
  pcx->bits_per_pixel = (char)8;
#line 460
  pcx->xmin = (unsigned short)0;
#line 461
  pcx->ymin = (unsigned short)0;
#line 462
  pcx->xmax = (unsigned short )(width - 1);
#line 463
  pcx->ymax = (unsigned short )(height - 1);
#line 464
  pcx->hres = (unsigned short )width;
#line 465
  pcx->vres = (unsigned short )height;
#line 466
  memset((void *)(pcx->palette), 0, (size_t )sizeof(pcx->palette));
#line 467
  pcx->color_planes = (char)1;
#line 468
  pcx->bytes_per_line = (unsigned short )width;
#line 469
  pcx->palette_type = (unsigned short)2;
#line 470
  memset((void *)(pcx->filler), 0, (size_t )sizeof(pcx->filler));
#line 474
  pack = & pcx->data;
#line 476
  i = 0;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (i < width * height)) {
#line 476
      goto while_break;
    }
#line 478
    if (((int )*data & 0xc0) != 0xc0) {
#line 479
      tmp___0 = pack;
#line 479
      pack ++;
#line 479
      tmp___1 = data;
#line 479
      data ++;
#line 479
      *tmp___0 = *tmp___1;
    } else {
#line 482
      tmp___2 = pack;
#line 482
      pack ++;
#line 482
      *tmp___2 = (byte )0xc1;
#line 483
      tmp___3 = pack;
#line 483
      pack ++;
#line 483
      tmp___4 = data;
#line 483
      data ++;
#line 483
      *tmp___3 = *tmp___4;
    }
#line 476
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  tmp___5 = pack;
#line 488
  pack ++;
#line 488
  *tmp___5 = (byte )0x0c;
#line 489
  i = 0;
  {
#line 489
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 489
    if (! (i < 768)) {
#line 489
      goto while_break___0;
    }
#line 490
    tmp___6 = pack;
#line 490
    pack ++;
#line 490
    tmp___7 = palette;
#line 490
    palette ++;
#line 490
    *tmp___6 = *tmp___7;
#line 489
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 493
  length = (int )(pack - (byte *)pcx);
#line 494
  M_WriteFile((char const   *)filename, (void *)pcx, length);
#line 496
  Z_Free((void *)pcx);
#line 497
  return;
}
}
#line 503 "m_misc.c"
void M_ScreenShot(void) 
{ 
  int i ;
  byte *linear ;
  char lbmname[12] ;
  int tmp ;
  void *tmp___0 ;

  {
#line 510
  linear = screens[2];
#line 511
  I_ReadScreen(linear);
#line 514
  strcpy((char * __restrict  )(lbmname), (char const   * __restrict  )"DOOM00.pcx");
#line 516
  i = 0;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (i <= 99)) {
#line 516
      goto while_break;
    }
#line 518
    lbmname[4] = (char )(i / 10 + 48);
#line 519
    lbmname[5] = (char )(i % 10 + 48);
#line 520
    tmp = access((char const   *)(lbmname), 0);
#line 520
    if (tmp == -1) {
#line 521
      goto while_break;
    }
#line 516
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  if (i == 100) {
#line 524
    I_Error("M_ScreenShot: Couldn\'t create a PCX");
  }
#line 527
  tmp___0 = W_CacheLumpName("PLAYPAL", 101);
#line 527
  WritePCXfile(lbmname, linear, 320, 200, (byte *)tmp___0);
#line 531
  players[consoleplayer].message = "screen shot";
#line 532
  return;
}
}
#line 23 "m_argv.c"
static char const   rcsid___15[49]  = 
#line 23 "m_argv.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'a', 
        (char const   )'r',      (char const   )'g',      (char const   )'v',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "m_argv.c"
int myargc  ;
#line 30 "m_argv.c"
char **myargv  ;
#line 41 "m_argv.c"
int M_CheckParm(char *check ) 
{ 
  int i ;
  int tmp ;

  {
#line 45
  i = 1;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < myargc)) {
#line 45
      goto while_break;
    }
#line 47
    tmp = strcasecmp((char const   *)check, (char const   *)*(myargv + i));
#line 47
    if (! tmp) {
#line 48
      return (i);
    }
#line 45
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return (0);
}
}
#line 27 "m_bbox.c"
static char const   rcsid___16[49]  = 
#line 27 "m_bbox.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'b', 
        (char const   )'b',      (char const   )'o',      (char const   )'x',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 41 "m_bbox.h"
void M_ClearBox(fixed_t *box ) ;
#line 43
void M_AddToBox(fixed_t *box , fixed_t x___0 , fixed_t y___1 ) ;
#line 39 "m_bbox.c"
void M_ClearBox(fixed_t *box ) 
{ 
  fixed_t tmp ;
  fixed_t tmp___0 ;

  {
#line 41
  tmp = (-0x7FFFFFFF-1);
#line 41
  *(box + 3) = tmp;
#line 41
  *(box + 0) = tmp;
#line 42
  tmp___0 = 0x7fffffff;
#line 42
  *(box + 2) = tmp___0;
#line 42
  *(box + 1) = tmp___0;
#line 43
  return;
}
}
#line 45 "m_bbox.c"
void M_AddToBox(fixed_t *box , fixed_t x___0 , fixed_t y___1 ) 
{ 


  {
#line 51
  if (x___0 < *(box + 2)) {
#line 52
    *(box + 2) = x___0;
  } else
#line 53
  if (x___0 > *(box + 3)) {
#line 54
    *(box + 3) = x___0;
  }
#line 55
  if (y___1 < *(box + 1)) {
#line 56
    *(box + 1) = y___1;
  } else
#line 57
  if (y___1 > *(box + 0)) {
#line 58
    *(box + 0) = y___1;
  }
#line 59
  return;
}
}
#line 25 "m_fixed.c"
static char const   rcsid___17[49]  = 
#line 25 "m_fixed.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'b', 
        (char const   )'b',      (char const   )'o',      (char const   )'x',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 43 "m_fixed.c"
fixed_t FixedMul(fixed_t a , fixed_t b ) 
{ 


  {
#line 48
  return ((fixed_t )((long long )a * (long long )b >> 16));
}
}
#line 57 "m_fixed.c"
fixed_t FixedDiv(fixed_t a , fixed_t b ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  fixed_t tmp___2 ;

  {
#line 62
  tmp___0 = abs(a);
#line 62
  tmp___1 = abs(b);
#line 62
  if (tmp___0 >> 14 >= tmp___1) {
#line 63
    if ((a ^ b) < 0) {
#line 63
      tmp = (-0x7FFFFFFF-1);
    } else {
#line 63
      tmp = 0x7fffffff;
    }
#line 63
    return (tmp);
  }
#line 64
  tmp___2 = FixedDiv2(a, b);
#line 64
  return (tmp___2);
}
}
#line 69 "m_fixed.c"
fixed_t FixedDiv2(fixed_t a , fixed_t b ) 
{ 
  double c ;

  {
#line 82
  c = ((double )a / (double )b) * (double )(1 << 16);
#line 84
  if (c >= 2147483648.0) {
#line 84
    goto _L;
  } else
#line 84
  if (c < - 2147483648.0) {
    _L: /* CIL Label */ 
#line 85
    I_Error("FixedDiv: divide by zero");
  }
#line 86
  return ((fixed_t )c);
}
}
#line 24 "m_swap.c"
static char const   rcsid___18[49]  = 
#line 24 "m_swap.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'b', 
        (char const   )'b',      (char const   )'o',      (char const   )'x',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "m_swap.c"
unsigned short SwapSHORT(unsigned short x___0 ) 
{ 


  {
#line 41
  return ((unsigned short )(((int )x___0 >> 8) | ((int )x___0 << 8)));
}
}
#line 45 "m_swap.c"
unsigned long SwapLONG(unsigned long x___0 ) 
{ 


  {
#line 47
  return ((((x___0 >> 24) | ((x___0 >> 8) & 65280UL)) | ((x___0 << 8) & 16711680UL)) | (x___0 << 24));
}
}
#line 25 "m_cheat.c"
static char const   rcsid___19[50]  = 
#line 25 "m_cheat.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'c', 
        (char const   )'h',      (char const   )'e',      (char const   )'a',      (char const   )'t', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'1', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )' ', 
        (char const   )'2',      (char const   )'1',      (char const   )':',      (char const   )'2', 
        (char const   )'4',      (char const   )':',      (char const   )'3',      (char const   )'4', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 41 "m_cheat.h"
int cht_CheckCheat(cheatseq_t *cht , char key ) ;
#line 47
void cht_GetParam(cheatseq_t *cht , char *buffer___0 ) ;
#line 34 "m_cheat.c"
static int firsttime___0  =    1;
#line 35 "m_cheat.c"
static unsigned char cheat_xlate_table[256]  ;
#line 42 "m_cheat.c"
int cht_CheckCheat(cheatseq_t *cht , char key ) 
{ 
  int i ;
  int rc ;
  unsigned char *tmp ;

  {
#line 48
  rc = 0;
#line 50
  if (firsttime___0) {
#line 52
    firsttime___0 = 0;
#line 53
    i = 0;
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
#line 53
      if (! (i < 256)) {
#line 53
        goto while_break;
      }
#line 53
      cheat_xlate_table[i] = (unsigned char )(((((((((i & 1) << 7) + ((i & 2) << 5)) + (i & 4)) + ((i & 8) << 1)) + ((i & 16) >> 1)) + (i & 32)) + ((i & 64) >> 5)) + ((i & 128) >> 7));
#line 53
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 56
  if (! cht->p) {
#line 57
    cht->p = cht->sequence;
  }
#line 59
  if ((int )*(cht->p) == 0) {
#line 60
    tmp = cht->p;
#line 60
    (cht->p) ++;
#line 60
    *tmp = (unsigned char )key;
  } else
#line 61
  if ((int )cheat_xlate_table[(unsigned char )key] == (int )*(cht->p)) {
#line 62
    (cht->p) ++;
  } else {
#line 64
    cht->p = cht->sequence;
  }
#line 66
  if ((int )*(cht->p) == 1) {
#line 67
    (cht->p) ++;
  } else
#line 68
  if ((int )*(cht->p) == 0xff) {
#line 70
    cht->p = cht->sequence;
#line 71
    rc = 1;
  }
#line 74
  return (rc);
}
}
#line 77 "m_cheat.c"
void cht_GetParam(cheatseq_t *cht , char *buffer___0 ) 
{ 
  unsigned char *p___0 ;
  unsigned char c ;
  unsigned char *tmp ;
  char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 85
  p___0 = cht->sequence;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    tmp = p___0;
#line 86
    p___0 ++;
#line 86
    if (! ((int )*tmp != 1)) {
#line 86
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    c = *p___0;
#line 91
    tmp___0 = buffer___0;
#line 91
    buffer___0 ++;
#line 91
    *tmp___0 = (char )c;
#line 92
    tmp___1 = p___0;
#line 92
    p___0 ++;
#line 92
    *tmp___1 = (unsigned char)0;
#line 88
    if (c) {
#line 88
      if (! ((int )*p___0 != 0xff)) {
#line 88
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 88
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 96
  if ((int )*p___0 == 0xff) {
#line 97
    *buffer___0 = (char)0;
  }
#line 99
  return;
}
}
#line 24 "m_random.c"
static char const   rcsid___20[51]  = 
#line 24 "m_random.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'r', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'o', 
        (char const   )'m',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'1',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )' ',      (char const   )'2',      (char const   )'2',      (char const   )':', 
        (char const   )'4',      (char const   )'5',      (char const   )':',      (char const   )'1', 
        (char const   )'1',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 31 "m_random.c"
unsigned char rndtable[256]  = 
#line 31
  {      (unsigned char)0,      (unsigned char)8,      (unsigned char)109,      (unsigned char)220, 
        (unsigned char)222,      (unsigned char)241,      (unsigned char)149,      (unsigned char)107, 
        (unsigned char)75,      (unsigned char)248,      (unsigned char)254,      (unsigned char)140, 
        (unsigned char)16,      (unsigned char)66,      (unsigned char)74,      (unsigned char)21, 
        (unsigned char)211,      (unsigned char)47,      (unsigned char)80,      (unsigned char)242, 
        (unsigned char)154,      (unsigned char)27,      (unsigned char)205,      (unsigned char)128, 
        (unsigned char)161,      (unsigned char)89,      (unsigned char)77,      (unsigned char)36, 
        (unsigned char)95,      (unsigned char)110,      (unsigned char)85,      (unsigned char)48, 
        (unsigned char)212,      (unsigned char)140,      (unsigned char)211,      (unsigned char)249, 
        (unsigned char)22,      (unsigned char)79,      (unsigned char)200,      (unsigned char)50, 
        (unsigned char)28,      (unsigned char)188,      (unsigned char)52,      (unsigned char)140, 
        (unsigned char)202,      (unsigned char)120,      (unsigned char)68,      (unsigned char)145, 
        (unsigned char)62,      (unsigned char)70,      (unsigned char)184,      (unsigned char)190, 
        (unsigned char)91,      (unsigned char)197,      (unsigned char)152,      (unsigned char)224, 
        (unsigned char)149,      (unsigned char)104,      (unsigned char)25,      (unsigned char)178, 
        (unsigned char)252,      (unsigned char)182,      (unsigned char)202,      (unsigned char)182, 
        (unsigned char)141,      (unsigned char)197,      (unsigned char)4,      (unsigned char)81, 
        (unsigned char)181,      (unsigned char)242,      (unsigned char)145,      (unsigned char)42, 
        (unsigned char)39,      (unsigned char)227,      (unsigned char)156,      (unsigned char)198, 
        (unsigned char)225,      (unsigned char)193,      (unsigned char)219,      (unsigned char)93, 
        (unsigned char)122,      (unsigned char)175,      (unsigned char)249,      (unsigned char)0, 
        (unsigned char)175,      (unsigned char)143,      (unsigned char)70,      (unsigned char)239, 
        (unsigned char)46,      (unsigned char)246,      (unsigned char)163,      (unsigned char)53, 
        (unsigned char)163,      (unsigned char)109,      (unsigned char)168,      (unsigned char)135, 
        (unsigned char)2,      (unsigned char)235,      (unsigned char)25,      (unsigned char)92, 
        (unsigned char)20,      (unsigned char)145,      (unsigned char)138,      (unsigned char)77, 
        (unsigned char)69,      (unsigned char)166,      (unsigned char)78,      (unsigned char)176, 
        (unsigned char)173,      (unsigned char)212,      (unsigned char)166,      (unsigned char)113, 
        (unsigned char)94,      (unsigned char)161,      (unsigned char)41,      (unsigned char)50, 
        (unsigned char)239,      (unsigned char)49,      (unsigned char)111,      (unsigned char)164, 
        (unsigned char)70,      (unsigned char)60,      (unsigned char)2,      (unsigned char)37, 
        (unsigned char)171,      (unsigned char)75,      (unsigned char)136,      (unsigned char)156, 
        (unsigned char)11,      (unsigned char)56,      (unsigned char)42,      (unsigned char)146, 
        (unsigned char)138,      (unsigned char)229,      (unsigned char)73,      (unsigned char)146, 
        (unsigned char)77,      (unsigned char)61,      (unsigned char)98,      (unsigned char)196, 
        (unsigned char)135,      (unsigned char)106,      (unsigned char)63,      (unsigned char)197, 
        (unsigned char)195,      (unsigned char)86,      (unsigned char)96,      (unsigned char)203, 
        (unsigned char)113,      (unsigned char)101,      (unsigned char)170,      (unsigned char)247, 
        (unsigned char)181,      (unsigned char)113,      (unsigned char)80,      (unsigned char)250, 
        (unsigned char)108,      (unsigned char)7,      (unsigned char)255,      (unsigned char)237, 
        (unsigned char)129,      (unsigned char)226,      (unsigned char)79,      (unsigned char)107, 
        (unsigned char)112,      (unsigned char)166,      (unsigned char)103,      (unsigned char)241, 
        (unsigned char)24,      (unsigned char)223,      (unsigned char)239,      (unsigned char)120, 
        (unsigned char)198,      (unsigned char)58,      (unsigned char)60,      (unsigned char)82, 
        (unsigned char)128,      (unsigned char)3,      (unsigned char)184,      (unsigned char)66, 
        (unsigned char)143,      (unsigned char)224,      (unsigned char)145,      (unsigned char)224, 
        (unsigned char)81,      (unsigned char)206,      (unsigned char)163,      (unsigned char)45, 
        (unsigned char)63,      (unsigned char)90,      (unsigned char)168,      (unsigned char)114, 
        (unsigned char)59,      (unsigned char)33,      (unsigned char)159,      (unsigned char)95, 
        (unsigned char)28,      (unsigned char)139,      (unsigned char)123,      (unsigned char)98, 
        (unsigned char)125,      (unsigned char)196,      (unsigned char)15,      (unsigned char)70, 
        (unsigned char)194,      (unsigned char)253,      (unsigned char)54,      (unsigned char)14, 
        (unsigned char)109,      (unsigned char)226,      (unsigned char)71,      (unsigned char)17, 
        (unsigned char)161,      (unsigned char)93,      (unsigned char)186,      (unsigned char)87, 
        (unsigned char)244,      (unsigned char)138,      (unsigned char)20,      (unsigned char)52, 
        (unsigned char)123,      (unsigned char)251,      (unsigned char)26,      (unsigned char)36, 
        (unsigned char)17,      (unsigned char)46,      (unsigned char)52,      (unsigned char)231, 
        (unsigned char)232,      (unsigned char)76,      (unsigned char)31,      (unsigned char)221, 
        (unsigned char)84,      (unsigned char)37,      (unsigned char)216,      (unsigned char)165, 
        (unsigned char)212,      (unsigned char)106,      (unsigned char)197,      (unsigned char)242, 
        (unsigned char)98,      (unsigned char)43,      (unsigned char)39,      (unsigned char)175, 
        (unsigned char)254,      (unsigned char)145,      (unsigned char)190,      (unsigned char)84, 
        (unsigned char)118,      (unsigned char)222,      (unsigned char)187,      (unsigned char)136, 
        (unsigned char)120,      (unsigned char)163,      (unsigned char)236,      (unsigned char)249};
#line 53 "m_random.c"
int rndindex  =    0;
#line 54 "m_random.c"
int prndindex  =    0;
#line 57 "m_random.c"
int P_Random(void) 
{ 


  {
#line 59
  prndindex = (prndindex + 1) & 0xff;
#line 60
  return ((int )rndtable[prndindex]);
}
}
#line 63 "m_random.c"
int M_Random(void) 
{ 


  {
#line 65
  rndindex = (rndindex + 1) & 0xff;
#line 66
  return ((int )rndtable[rndindex]);
}
}
#line 69 "m_random.c"
void M_ClearRandom(void) 
{ 


  {
#line 71
  prndindex = 0;
#line 71
  rndindex = prndindex;
#line 72
  return;
}
}
#line 24 "am_map.c"
static char const   rcsid___21[49]  = 
#line 24 "am_map.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'a',      (char const   )'m',      (char const   )'_', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'4',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'1',      (char const   )':',      (char const   )'2',      (char const   )'4', 
        (char const   )':',      (char const   )'3',      (char const   )'3',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 161 "am_map.c"
mline_t player_arrow[7]  = {      {{- ((128 * (1 << 16)) / 7) + ((128 * (1 << 16)) / 7) / 8, 0}, {(128 * (1 << 16)) / 7,
                                                                     0}}, 
        {{(128 * (1 << 16)) / 7, 0}, {(128 * (1 << 16)) / 7 - ((128 * (1 << 16)) / 7) / 2,
                                   ((128 * (1 << 16)) / 7) / 4}}, 
        {{(128 * (1 << 16)) / 7, 0}, {(128 * (1 << 16)) / 7 - ((128 * (1 << 16)) / 7) / 2,
                                   - ((128 * (1 << 16)) / 7) / 4}}, 
        {{- ((128 * (1 << 16)) / 7) + ((128 * (1 << 16)) / 7) / 8, 0}, {- ((128 * (1 << 16)) / 7) - ((128 * (1 << 16)) / 7) / 8,
                                                                     ((128 * (1 << 16)) / 7) / 4}}, 
        {{- ((128 * (1 << 16)) / 7) + ((128 * (1 << 16)) / 7) / 8, 0}, {- ((128 * (1 << 16)) / 7) - ((128 * (1 << 16)) / 7) / 8,
                                                                     - ((128 * (1 << 16)) / 7) / 4}}, 
        {{- ((128 * (1 << 16)) / 7) + (3 * ((128 * (1 << 16)) / 7)) / 8, 0}, {- ((128 * (1 << 16)) / 7) + ((128 * (1 << 16)) / 7) / 8,
                                                                           ((128 * (1 << 16)) / 7) / 4}}, 
        {{- ((128 * (1 << 16)) / 7) + (3 * ((128 * (1 << 16)) / 7)) / 8, 0}, {- ((128 * (1 << 16)) / 7) + ((128 * (1 << 16)) / 7) / 8,
                                                                           - ((128 * (1 << 16)) / 7) / 4}}};
#line 174 "am_map.c"
mline_t cheat_player_arrow[16]  = 
#line 174
  {      {{- ((128 * (1 << 16)) / 7) + ((128 * (1 << 16)) / 7) / 8, 0}, {(128 * (1 << 16)) / 7,
                                                                     0}}, 
        {{(128 * (1 << 16)) / 7, 0}, {(128 * (1 << 16)) / 7 - ((128 * (1 << 16)) / 7) / 2,
                                   ((128 * (1 << 16)) / 7) / 6}}, 
        {{(128 * (1 << 16)) / 7, 0}, {(128 * (1 << 16)) / 7 - ((128 * (1 << 16)) / 7) / 2,
                                   - ((128 * (1 << 16)) / 7) / 6}}, 
        {{- ((128 * (1 << 16)) / 7) + ((128 * (1 << 16)) / 7) / 8, 0}, {- ((128 * (1 << 16)) / 7) - ((128 * (1 << 16)) / 7) / 8,
                                                                     ((128 * (1 << 16)) / 7) / 6}}, 
        {{- ((128 * (1 << 16)) / 7) + ((128 * (1 << 16)) / 7) / 8, 0}, {- ((128 * (1 << 16)) / 7) - ((128 * (1 << 16)) / 7) / 8,
                                                                     - ((128 * (1 << 16)) / 7) / 6}}, 
        {{- ((128 * (1 << 16)) / 7) + (3 * ((128 * (1 << 16)) / 7)) / 8, 0}, {- ((128 * (1 << 16)) / 7) + ((128 * (1 << 16)) / 7) / 8,
                                                                           ((128 * (1 << 16)) / 7) / 6}}, 
        {{- ((128 * (1 << 16)) / 7) + (3 * ((128 * (1 << 16)) / 7)) / 8, 0}, {- ((128 * (1 << 16)) / 7) + ((128 * (1 << 16)) / 7) / 8,
                                                                           - ((128 * (1 << 16)) / 7) / 6}}, 
        {{- ((128 * (1 << 16)) / 7) / 2, 0}, {- ((128 * (1 << 16)) / 7) / 2, - ((128 * (1 << 16)) / 7) / 6}}, 
        {{- ((128 * (1 << 16)) / 7) / 2, - ((128 * (1 << 16)) / 7) / 6}, {- ((128 * (1 << 16)) / 7) / 2 + ((128 * (1 << 16)) / 7) / 6,
                                                                       - ((128 * (1 << 16)) / 7) / 6}}, 
        {{- ((128 * (1 << 16)) / 7) / 2 + ((128 * (1 << 16)) / 7) / 6, - ((128 * (1 << 16)) / 7) / 6},
      {- ((128 * (1 << 16)) / 7) / 2 + ((128 * (1 << 16)) / 7) / 6, ((128 * (1 << 16)) / 7) / 4}}, 
        {{- ((128 * (1 << 16)) / 7) / 6, 0}, {- ((128 * (1 << 16)) / 7) / 6, - ((128 * (1 << 16)) / 7) / 6}}, 
        {{- ((128 * (1 << 16)) / 7) / 6, - ((128 * (1 << 16)) / 7) / 6}, {0, - ((128 * (1 << 16)) / 7) / 6}}, 
        {{0, - ((128 * (1 << 16)) / 7) / 6}, {0, ((128 * (1 << 16)) / 7) / 4}}, 
        {{((128 * (1 << 16)) / 7) / 6, ((128 * (1 << 16)) / 7) / 4}, {((128 * (1 << 16)) / 7) / 6,
                                                                   - ((128 * (1 << 16)) / 7) / 7}}, 
        {{((128 * (1 << 16)) / 7) / 6, - ((128 * (1 << 16)) / 7) / 7}, {((128 * (1 << 16)) / 7) / 6 + ((128 * (1 << 16)) / 7) / 32,
                                                                     - ((128 * (1 << 16)) / 7) / 7 - ((128 * (1 << 16)) / 7) / 32}}, 
        {{((128 * (1 << 16)) / 7) / 6 + ((128 * (1 << 16)) / 7) / 32, - ((128 * (1 << 16)) / 7) / 7 - ((128 * (1 << 16)) / 7) / 32},
      {((128 * (1 << 16)) / 7) / 6 + ((128 * (1 << 16)) / 7) / 10, - ((128 * (1 << 16)) / 7) / 7}}};
#line 196 "am_map.c"
mline_t triangle_guy[3]  = {      {{(fixed_t )(- .867 * (double )(1 << 16)), (fixed_t )(- .5 * (double )(1 << 16))},
      {(fixed_t )(.867 * (double )(1 << 16)), (fixed_t )(- .5 * (double )(1 << 16))}}, 
        {{(fixed_t )(.867 * (double )(1 << 16)), (fixed_t )(- .5 * (double )(1 << 16))},
      {0, 1 << 16}}, 
        {{0, 1 << 16}, {(fixed_t )(- .867 * (double )(1 << 16)), (fixed_t )(- .5 * (double )(1 << 16))}}};
#line 205 "am_map.c"
mline_t thintriangle_guy[3]  = {      {{(fixed_t )(- .5 * (double )(1 << 16)), (fixed_t )(- .7 * (double )(1 << 16))},
      {1 << 16, 0}}, 
        {{1 << 16, 0}, {(fixed_t )(- .5 * (double )(1 << 16)), (fixed_t )(.7 * (double )(1 << 16))}}, 
        {{(fixed_t )(- .5 * (double )(1 << 16)), (fixed_t )(.7 * (double )(1 << 16))},
      {(fixed_t )(- .5 * (double )(1 << 16)), (fixed_t )(- .7 * (double )(1 << 16))}}};
#line 216 "am_map.c"
static int cheating  =    0;
#line 217 "am_map.c"
static int grid  =    0;
#line 219 "am_map.c"
static int leveljuststarted  =    1;
#line 221 "am_map.c"
boolean automapactive  =    (boolean )0;
#line 222 "am_map.c"
static int finit_width  =    320;
#line 223 "am_map.c"
static int finit_height  =    168;
#line 226 "am_map.c"
static int f_x  ;
#line 227 "am_map.c"
static int f_y  ;
#line 230 "am_map.c"
static int f_w  ;
#line 231 "am_map.c"
static int f_h  ;
#line 233 "am_map.c"
static int lightlev  ;
#line 234 "am_map.c"
static byte *fb  ;
#line 235 "am_map.c"
static int amclock  ;
#line 237 "am_map.c"
static mpoint_t m_paninc  ;
#line 238 "am_map.c"
static fixed_t mtof_zoommul  ;
#line 239 "am_map.c"
static fixed_t ftom_zoommul  ;
#line 241 "am_map.c"
static fixed_t m_x  ;
#line 241 "am_map.c"
static fixed_t m_y  ;
#line 242 "am_map.c"
static fixed_t m_x2  ;
#line 242 "am_map.c"
static fixed_t m_y2  ;
#line 247 "am_map.c"
static fixed_t m_w  ;
#line 248 "am_map.c"
static fixed_t m_h  ;
#line 251 "am_map.c"
static fixed_t min_x  ;
#line 252 "am_map.c"
static fixed_t min_y  ;
#line 253 "am_map.c"
static fixed_t max_x  ;
#line 254 "am_map.c"
static fixed_t max_y  ;
#line 256 "am_map.c"
static fixed_t max_w  ;
#line 257 "am_map.c"
static fixed_t max_h  ;
#line 260 "am_map.c"
static fixed_t min_w  ;
#line 261 "am_map.c"
static fixed_t min_h  ;
#line 264 "am_map.c"
static fixed_t min_scale_mtof  ;
#line 265 "am_map.c"
static fixed_t max_scale_mtof  ;
#line 268 "am_map.c"
static fixed_t old_m_w  ;
#line 268 "am_map.c"
static fixed_t old_m_h  ;
#line 269 "am_map.c"
static fixed_t old_m_x  ;
#line 269 "am_map.c"
static fixed_t old_m_y  ;
#line 272 "am_map.c"
static mpoint_t f_oldloc  ;
#line 275 "am_map.c"
static fixed_t scale_mtof  =    (fixed_t )(.2 * (double )(1 << 16));
#line 277 "am_map.c"
static fixed_t scale_ftom  ;
#line 279 "am_map.c"
static player_t *plr  ;
#line 281 "am_map.c"
static patch_t *marknums[10]  ;
#line 282 "am_map.c"
static mpoint_t markpoints[10]  ;
#line 283 "am_map.c"
static int markpointnum  =    0;
#line 285 "am_map.c"
static int followplayer  =    1;
#line 287 "am_map.c"
static unsigned char cheat_amap_seq[5]  = {      (unsigned char)178,      (unsigned char)38,      (unsigned char)38,      (unsigned char)46, 
        (unsigned char)255};
#line 288 "am_map.c"
static cheatseq_t cheat_amap  =    {cheat_amap_seq, (unsigned char *)0};
#line 290 "am_map.c"
static boolean stopped  =    (boolean )1;
#line 308 "am_map.c"
void AM_getIslope(mline_t *ml , islope_t *is ) 
{ 
  int dx ;
  int dy ;

  {
#line 315
  dy = ml->a.y - ml->b.y;
#line 316
  dx = ml->b.x - ml->a.x;
#line 317
  if (! dy) {
#line 317
    if (dx < 0) {
#line 317
      is->islp = -2147483647;
    } else {
#line 317
      is->islp = 0x7fffffff;
    }
  } else {
#line 318
    is->islp = FixedDiv(dx, dy);
  }
#line 319
  if (! dx) {
#line 319
    if (dy < 0) {
#line 319
      is->slp = -2147483647;
    } else {
#line 319
      is->slp = 0x7fffffff;
    }
  } else {
#line 320
    is->slp = FixedDiv(dy, dx);
  }
#line 322
  return;
}
}
#line 327 "am_map.c"
void AM_activateNewScale(void) 
{ 


  {
#line 329
  m_x += m_w / 2;
#line 330
  m_y += m_h / 2;
#line 331
  m_w = FixedMul(f_w << 16, scale_ftom);
#line 332
  m_h = FixedMul(f_h << 16, scale_ftom);
#line 333
  m_x -= m_w / 2;
#line 334
  m_y -= m_h / 2;
#line 335
  m_x2 = m_x + m_w;
#line 336
  m_y2 = m_y + m_h;
#line 337
  return;
}
}
#line 342 "am_map.c"
void AM_saveScaleAndLoc(void) 
{ 


  {
#line 344
  old_m_x = m_x;
#line 345
  old_m_y = m_y;
#line 346
  old_m_w = m_w;
#line 347
  old_m_h = m_h;
#line 348
  return;
}
}
#line 353 "am_map.c"
void AM_restoreScaleAndLoc(void) 
{ 


  {
#line 356
  m_w = old_m_w;
#line 357
  m_h = old_m_h;
#line 358
  if (! followplayer) {
#line 360
    m_x = old_m_x;
#line 361
    m_y = old_m_y;
  } else {
#line 363
    m_x = (plr->mo)->x - m_w / 2;
#line 364
    m_y = (plr->mo)->y - m_h / 2;
  }
#line 366
  m_x2 = m_x + m_w;
#line 367
  m_y2 = m_y + m_h;
#line 370
  scale_mtof = FixedDiv(f_w << 16, m_w);
#line 371
  scale_ftom = FixedDiv(1 << 16, scale_mtof);
#line 372
  return;
}
}
#line 377 "am_map.c"
void AM_addMark(void) 
{ 


  {
#line 379
  markpoints[markpointnum].x = m_x + m_w / 2;
#line 380
  markpoints[markpointnum].y = m_y + m_h / 2;
#line 381
  markpointnum = (markpointnum + 1) % 10;
#line 383
  return;
}
}
#line 389 "am_map.c"
void AM_findMinMaxBoundaries(void) 
{ 
  int i ;
  fixed_t a ;
  fixed_t b ;

  {
#line 395
  min_y = 0x7fffffff;
#line 395
  min_x = min_y;
#line 396
  max_y = -2147483647;
#line 396
  max_x = max_y;
#line 398
  i = 0;
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! (i < numvertexes)) {
#line 398
      goto while_break;
    }
#line 400
    if ((vertexes + i)->x < min_x) {
#line 401
      min_x = (vertexes + i)->x;
    } else
#line 402
    if ((vertexes + i)->x > max_x) {
#line 403
      max_x = (vertexes + i)->x;
    }
#line 405
    if ((vertexes + i)->y < min_y) {
#line 406
      min_y = (vertexes + i)->y;
    } else
#line 407
    if ((vertexes + i)->y > max_y) {
#line 408
      max_y = (vertexes + i)->y;
    }
#line 398
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  max_w = max_x - min_x;
#line 412
  max_h = max_y - min_y;
#line 414
  min_w = 32 * (1 << 16);
#line 415
  min_h = 32 * (1 << 16);
#line 417
  a = FixedDiv(f_w << 16, max_w);
#line 418
  b = FixedDiv(f_h << 16, max_h);
#line 420
  if (a < b) {
#line 420
    min_scale_mtof = a;
  } else {
#line 420
    min_scale_mtof = b;
  }
#line 421
  max_scale_mtof = FixedDiv(f_h << 16, 32 * (1 << 16));
#line 423
  return;
}
}
#line 429 "am_map.c"
void AM_changeWindowLoc(void) 
{ 


  {
#line 431
  if (m_paninc.x) {
#line 431
    goto _L;
  } else
#line 431
  if (m_paninc.y) {
    _L: /* CIL Label */ 
#line 433
    followplayer = 0;
#line 434
    f_oldloc.x = 0x7fffffff;
  }
#line 437
  m_x += m_paninc.x;
#line 438
  m_y += m_paninc.y;
#line 440
  if (m_x + m_w / 2 > max_x) {
#line 441
    m_x = max_x - m_w / 2;
  } else
#line 442
  if (m_x + m_w / 2 < min_x) {
#line 443
    m_x = min_x - m_w / 2;
  }
#line 445
  if (m_y + m_h / 2 > max_y) {
#line 446
    m_y = max_y - m_h / 2;
  } else
#line 447
  if (m_y + m_h / 2 < min_y) {
#line 448
    m_y = min_y - m_h / 2;
  }
#line 450
  m_x2 = m_x + m_w;
#line 451
  m_y2 = m_y + m_h;
#line 452
  return;
}
}
#line 461
void AM_initVariables(void) ;
#line 461 "am_map.c"
static event_t st_notify  =    {(evtype_t )1, ((97 << 24) + (109 << 16)) | (101 << 8), 0, 0};
#line 458 "am_map.c"
void AM_initVariables(void) 
{ 
  int pnum ;

  {
#line 463
  automapactive = (boolean )1;
#line 464
  fb = screens[0];
#line 466
  f_oldloc.x = 0x7fffffff;
#line 467
  amclock = 0;
#line 468
  lightlev = 0;
#line 470
  m_paninc.y = 0;
#line 470
  m_paninc.x = m_paninc.y;
#line 471
  ftom_zoommul = 1 << 16;
#line 472
  mtof_zoommul = 1 << 16;
#line 474
  m_w = FixedMul(f_w << 16, scale_ftom);
#line 475
  m_h = FixedMul(f_h << 16, scale_ftom);
#line 478
  pnum = consoleplayer;
#line 478
  if (! playeringame[pnum]) {
#line 479
    pnum = 0;
    {
#line 479
    while (1) {
      while_continue: /* CIL Label */ ;
#line 479
      if (! (pnum < 4)) {
#line 479
        goto while_break;
      }
#line 480
      if (playeringame[pnum]) {
#line 481
        goto while_break;
      }
#line 479
      pnum ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 483
  plr = & players[pnum];
#line 484
  m_x = (plr->mo)->x - m_w / 2;
#line 485
  m_y = (plr->mo)->y - m_h / 2;
#line 486
  AM_changeWindowLoc();
#line 489
  old_m_x = m_x;
#line 490
  old_m_y = m_y;
#line 491
  old_m_w = m_w;
#line 492
  old_m_h = m_h;
#line 495
  ST_Responder(& st_notify);
#line 497
  return;
}
}
#line 502 "am_map.c"
void AM_loadPics(void) 
{ 
  int i ;
  char namebuf[9] ;
  void *tmp ;

  {
#line 507
  i = 0;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! (i < 10)) {
#line 507
      goto while_break;
    }
#line 509
    sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"AMMNUM%d",
            i);
#line 510
    tmp = W_CacheLumpName(namebuf, 1);
#line 510
    marknums[i] = (patch_t *)tmp;
#line 507
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "am_map.c"
void AM_unloadPics(void) 
{ 
  int i ;

  {
#line 519
  i = 0;
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    if (! (i < 10)) {
#line 519
      goto while_break;
    }
#line 520
    if (((memblock_t *)((byte *)marknums[i] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 520
      I_Error("Z_CT at am_map.c:%i", 520);
    }
#line 520
    Z_ChangeTag2((void *)marknums[i], 101);
#line 519
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return;
}
}
#line 524 "am_map.c"
void AM_clearMarks(void) 
{ 
  int i ;

  {
#line 528
  i = 0;
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i < 10)) {
#line 528
      goto while_break;
    }
#line 529
    markpoints[i].x = -1;
#line 528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  markpointnum = 0;
#line 531
  return;
}
}
#line 537 "am_map.c"
void AM_LevelInit(void) 
{ 


  {
#line 539
  leveljuststarted = 0;
#line 541
  f_y = 0;
#line 541
  f_x = f_y;
#line 542
  f_w = finit_width;
#line 543
  f_h = finit_height;
#line 545
  AM_clearMarks();
#line 547
  AM_findMinMaxBoundaries();
#line 548
  scale_mtof = FixedDiv(min_scale_mtof, (int )(0.7 * (double )(1 << 16)));
#line 549
  if (scale_mtof > max_scale_mtof) {
#line 550
    scale_mtof = min_scale_mtof;
  }
#line 551
  scale_ftom = FixedDiv(1 << 16, scale_mtof);
#line 552
  return;
}
}
#line 562 "am_map.c"
static event_t st_notify___0  =    {(evtype_t )0, 1, ((97 << 24) + (109 << 16)) | (120 << 8), 0};
#line 560 "am_map.c"
void AM_Stop(void) 
{ 


  {
#line 564
  AM_unloadPics();
#line 565
  automapactive = (boolean )0;
#line 566
  ST_Responder(& st_notify___0);
#line 567
  stopped = (boolean )1;
#line 568
  return;
}
}
#line 575
void AM_Start(void) ;
#line 575 "am_map.c"
static int lastlevel  =    -1;
#line 575 "am_map.c"
static int lastepisode  =    -1;
#line 573 "am_map.c"
void AM_Start(void) 
{ 


  {
#line 577
  if (! stopped) {
#line 577
    AM_Stop();
  }
#line 578
  stopped = (boolean )0;
#line 579
  if (lastlevel != gamemap) {
#line 579
    goto _L;
  } else
#line 579
  if (lastepisode != gameepisode) {
    _L: /* CIL Label */ 
#line 581
    AM_LevelInit();
#line 582
    lastlevel = gamemap;
#line 583
    lastepisode = gameepisode;
  }
#line 585
  AM_initVariables();
#line 586
  AM_loadPics();
#line 587
  return;
}
}
#line 592 "am_map.c"
void AM_minOutWindowScale(void) 
{ 


  {
#line 594
  scale_mtof = min_scale_mtof;
#line 595
  scale_ftom = FixedDiv(1 << 16, scale_mtof);
#line 596
  AM_activateNewScale();
#line 597
  return;
}
}
#line 602 "am_map.c"
void AM_maxOutWindowScale(void) 
{ 


  {
#line 604
  scale_mtof = max_scale_mtof;
#line 605
  scale_ftom = FixedDiv(1 << 16, scale_mtof);
#line 606
  AM_activateNewScale();
#line 607
  return;
}
}
#line 619 "am_map.c"
static int cheatstate  =    0;
#line 620 "am_map.c"
static int bigstate  =    0;
#line 621 "am_map.c"
static char buffer[20]  ;
#line 613 "am_map.c"
boolean AM_Responder(event_t *ev ) 
{ 
  int rc ;
  fixed_t tmp ;
  fixed_t tmp___0 ;
  int tmp___1 ;

  {
#line 623
  rc = 0;
#line 625
  if (! automapactive) {
#line 627
    if ((unsigned int )ev->type == 0U) {
#line 627
      if (ev->data1 == 9) {
#line 629
        AM_Start();
#line 630
        viewactive = (boolean )0;
#line 631
        rc = 1;
      } else {
#line 627
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
  } else
#line 635
  if ((unsigned int )ev->type == 0U) {
#line 638
    rc = 1;
    {
#line 641
    if (ev->data1 == 0xae) {
#line 641
      goto case_174;
    }
#line 645
    if (ev->data1 == 0xac) {
#line 645
      goto case_172;
    }
#line 649
    if (ev->data1 == 0xad) {
#line 649
      goto case_173;
    }
#line 653
    if (ev->data1 == 0xaf) {
#line 653
      goto case_175;
    }
#line 657
    if (ev->data1 == 45) {
#line 657
      goto case_45;
    }
#line 661
    if (ev->data1 == 61) {
#line 661
      goto case_61;
    }
#line 665
    if (ev->data1 == 9) {
#line 665
      goto case_9;
    }
#line 670
    if (ev->data1 == 48) {
#line 670
      goto case_48;
    }
#line 679
    if (ev->data1 == 102) {
#line 679
      goto case_102;
    }
#line 684
    if (ev->data1 == 103) {
#line 684
      goto case_103;
    }
#line 688
    if (ev->data1 == 109) {
#line 688
      goto case_109;
    }
#line 693
    if (ev->data1 == 99) {
#line 693
      goto case_99;
    }
#line 697
    goto switch_default;
    case_174: /* CIL Label */ 
#line 642
    if (! followplayer) {
#line 642
      m_paninc.x = FixedMul(4 << 16, scale_ftom);
    } else {
#line 643
      rc = 0;
    }
#line 644
    goto switch_break;
    case_172: /* CIL Label */ 
#line 646
    if (! followplayer) {
#line 646
      tmp = FixedMul(4 << 16, scale_ftom);
#line 646
      m_paninc.x = - tmp;
    } else {
#line 647
      rc = 0;
    }
#line 648
    goto switch_break;
    case_173: /* CIL Label */ 
#line 650
    if (! followplayer) {
#line 650
      m_paninc.y = FixedMul(4 << 16, scale_ftom);
    } else {
#line 651
      rc = 0;
    }
#line 652
    goto switch_break;
    case_175: /* CIL Label */ 
#line 654
    if (! followplayer) {
#line 654
      tmp___0 = FixedMul(4 << 16, scale_ftom);
#line 654
      m_paninc.y = - tmp___0;
    } else {
#line 655
      rc = 0;
    }
#line 656
    goto switch_break;
    case_45: /* CIL Label */ 
#line 658
    mtof_zoommul = (int )((double )(1 << 16) / 1.02);
#line 659
    ftom_zoommul = (int )(1.02 * (double )(1 << 16));
#line 660
    goto switch_break;
    case_61: /* CIL Label */ 
#line 662
    mtof_zoommul = (int )(1.02 * (double )(1 << 16));
#line 663
    ftom_zoommul = (int )((double )(1 << 16) / 1.02);
#line 664
    goto switch_break;
    case_9: /* CIL Label */ 
#line 666
    bigstate = 0;
#line 667
    viewactive = (boolean )1;
#line 668
    AM_Stop();
#line 669
    goto switch_break;
    case_48: /* CIL Label */ 
#line 671
    bigstate = ! bigstate;
#line 672
    if (bigstate) {
#line 674
      AM_saveScaleAndLoc();
#line 675
      AM_minOutWindowScale();
    } else {
#line 677
      AM_restoreScaleAndLoc();
    }
#line 678
    goto switch_break;
    case_102: /* CIL Label */ 
#line 680
    followplayer = ! followplayer;
#line 681
    f_oldloc.x = 0x7fffffff;
#line 682
    if (followplayer) {
#line 682
      plr->message = "Follow Mode ON";
    } else {
#line 682
      plr->message = "Follow Mode OFF";
    }
#line 683
    goto switch_break;
    case_103: /* CIL Label */ 
#line 685
    grid = ! grid;
#line 686
    if (grid) {
#line 686
      plr->message = "Grid ON";
    } else {
#line 686
      plr->message = "Grid OFF";
    }
#line 687
    goto switch_break;
    case_109: /* CIL Label */ 
#line 689
    sprintf((char * __restrict  )(buffer), (char const   * __restrict  )"%s %d", "Marked Spot",
            markpointnum);
#line 690
    plr->message = buffer;
#line 691
    AM_addMark();
#line 692
    goto switch_break;
    case_99: /* CIL Label */ 
#line 694
    AM_clearMarks();
#line 695
    plr->message = "All Marks Cleared";
#line 696
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 698
    cheatstate = 0;
#line 699
    rc = 0;
    switch_break: /* CIL Label */ ;
    }
#line 701
    if (! deathmatch) {
#line 701
      tmp___1 = cht_CheckCheat(& cheat_amap, (char )ev->data1);
#line 701
      if (tmp___1) {
#line 703
        rc = 0;
#line 704
        cheating = (cheating + 1) % 3;
      } else {
#line 701
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
  } else
#line 708
  if ((unsigned int )ev->type == 1U) {
#line 710
    rc = 0;
    {
#line 713
    if (ev->data1 == 0xae) {
#line 713
      goto case_174___0;
    }
#line 716
    if (ev->data1 == 0xac) {
#line 716
      goto case_172___0;
    }
#line 719
    if (ev->data1 == 0xad) {
#line 719
      goto case_173___0;
    }
#line 722
    if (ev->data1 == 0xaf) {
#line 722
      goto case_175___0;
    }
#line 726
    if (ev->data1 == 61) {
#line 726
      goto case_61___0;
    }
#line 726
    if (ev->data1 == 45) {
#line 726
      goto case_61___0;
    }
#line 711
    goto switch_break___0;
    case_174___0: /* CIL Label */ 
#line 714
    if (! followplayer) {
#line 714
      m_paninc.x = 0;
    }
#line 715
    goto switch_break___0;
    case_172___0: /* CIL Label */ 
#line 717
    if (! followplayer) {
#line 717
      m_paninc.x = 0;
    }
#line 718
    goto switch_break___0;
    case_173___0: /* CIL Label */ 
#line 720
    if (! followplayer) {
#line 720
      m_paninc.y = 0;
    }
#line 721
    goto switch_break___0;
    case_175___0: /* CIL Label */ 
#line 723
    if (! followplayer) {
#line 723
      m_paninc.y = 0;
    }
#line 724
    goto switch_break___0;
    case_61___0: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
#line 727
    mtof_zoommul = 1 << 16;
#line 728
    ftom_zoommul = 1 << 16;
#line 729
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 733
  return ((boolean )rc);
}
}
#line 741 "am_map.c"
void AM_changeWindowScale(void) 
{ 


  {
#line 745
  scale_mtof = FixedMul(scale_mtof, mtof_zoommul);
#line 746
  scale_ftom = FixedDiv(1 << 16, scale_mtof);
#line 748
  if (scale_mtof < min_scale_mtof) {
#line 749
    AM_minOutWindowScale();
  } else
#line 750
  if (scale_mtof > max_scale_mtof) {
#line 751
    AM_maxOutWindowScale();
  } else {
#line 753
    AM_activateNewScale();
  }
#line 754
  return;
}
}
#line 760 "am_map.c"
void AM_doFollowPlayer(void) 
{ 
  fixed_t tmp ;
  fixed_t tmp___0 ;
  fixed_t tmp___1 ;
  fixed_t tmp___2 ;

  {
#line 763
  if (f_oldloc.x != (plr->mo)->x) {
#line 763
    goto _L;
  } else
#line 763
  if (f_oldloc.y != (plr->mo)->y) {
    _L: /* CIL Label */ 
#line 765
    tmp = FixedMul((plr->mo)->x, scale_mtof);
#line 765
    tmp___0 = FixedMul((tmp >> 16) << 16, scale_ftom);
#line 765
    m_x = tmp___0 - m_w / 2;
#line 766
    tmp___1 = FixedMul((plr->mo)->y, scale_mtof);
#line 766
    tmp___2 = FixedMul((tmp___1 >> 16) << 16, scale_ftom);
#line 766
    m_y = tmp___2 - m_h / 2;
#line 767
    m_x2 = m_x + m_w;
#line 768
    m_y2 = m_y + m_h;
#line 769
    f_oldloc.x = (plr->mo)->x;
#line 770
    f_oldloc.y = (plr->mo)->y;
  }
#line 779
  return;
}
}
#line 786
void AM_updateLightLev(void) ;
#line 786 "am_map.c"
static int nexttic  =    0;
#line 788 "am_map.c"
static int litelevels[8]  = 
#line 788
  {      0,      4,      7,      10, 
        12,      14,      15,      15};
#line 789 "am_map.c"
static int litelevelscnt  =    0;
#line 784 "am_map.c"
void AM_updateLightLev(void) 
{ 
  int tmp ;

  {
#line 792
  if (amclock > nexttic) {
#line 794
    tmp = litelevelscnt;
#line 794
    litelevelscnt ++;
#line 794
    lightlev = litelevels[tmp];
#line 795
    if ((unsigned long )litelevelscnt == sizeof(litelevels) / sizeof(int )) {
#line 795
      litelevelscnt = 0;
    }
#line 796
    nexttic = (amclock + 6) - amclock % 6;
  }
#line 799
  return;
}
}
#line 805 "am_map.c"
void AM_Ticker(void) 
{ 


  {
#line 808
  if (! automapactive) {
#line 809
    return;
  }
#line 811
  amclock ++;
#line 813
  if (followplayer) {
#line 814
    AM_doFollowPlayer();
  }
#line 817
  if (ftom_zoommul != 1 << 16) {
#line 818
    AM_changeWindowScale();
  }
#line 821
  if (m_paninc.x) {
#line 821
    goto _L;
  } else
#line 821
  if (m_paninc.y) {
    _L: /* CIL Label */ 
#line 822
    AM_changeWindowLoc();
  }
#line 827
  return;
}
}
#line 833 "am_map.c"
void AM_clearFB(int color ) 
{ 


  {
#line 835
  memset((void *)fb, color, (size_t )(f_w * f_h));
#line 836
  return;
}
}
#line 846 "am_map.c"
boolean AM_clipMline(mline_t *ml , fline_t *fl___0 ) 
{ 
  register int outcode1 ;
  register int outcode2 ;
  register int outside ;
  fpoint_t tmp ;
  int dx ;
  int dy ;
  fixed_t tmp___0 ;
  fixed_t tmp___1 ;
  fixed_t tmp___2 ;
  fixed_t tmp___3 ;

  {
#line 859
  outcode1 = 0;
#line 860
  outcode2 = 0;
#line 877
  if (ml->a.y > m_y2) {
#line 878
    outcode1 = 8;
  } else
#line 879
  if (ml->a.y < m_y) {
#line 880
    outcode1 = 4;
  }
#line 882
  if (ml->b.y > m_y2) {
#line 883
    outcode2 = 8;
  } else
#line 884
  if (ml->b.y < m_y) {
#line 885
    outcode2 = 4;
  }
#line 887
  if (outcode1 & outcode2) {
#line 888
    return ((boolean )0);
  }
#line 890
  if (ml->a.x < m_x) {
#line 891
    outcode1 |= 1;
  } else
#line 892
  if (ml->a.x > m_x2) {
#line 893
    outcode1 |= 2;
  }
#line 895
  if (ml->b.x < m_x) {
#line 896
    outcode2 |= 1;
  } else
#line 897
  if (ml->b.x > m_x2) {
#line 898
    outcode2 |= 2;
  }
#line 900
  if (outcode1 & outcode2) {
#line 901
    return ((boolean )0);
  }
#line 904
  tmp___0 = FixedMul(ml->a.x - m_x, scale_mtof);
#line 904
  fl___0->a.x = f_x + (tmp___0 >> 16);
#line 905
  tmp___1 = FixedMul(ml->a.y - m_y, scale_mtof);
#line 905
  fl___0->a.y = f_y + (f_h - (tmp___1 >> 16));
#line 906
  tmp___2 = FixedMul(ml->b.x - m_x, scale_mtof);
#line 906
  fl___0->b.x = f_x + (tmp___2 >> 16);
#line 907
  tmp___3 = FixedMul(ml->b.y - m_y, scale_mtof);
#line 907
  fl___0->b.y = f_y + (f_h - (tmp___3 >> 16));
#line 909
  outcode1 = 0;
#line 909
  if (fl___0->a.y < 0) {
#line 909
    outcode1 |= 8;
  } else
#line 909
  if (fl___0->a.y >= f_h) {
#line 909
    outcode1 |= 4;
  }
#line 909
  if (fl___0->a.x < 0) {
#line 909
    outcode1 |= 1;
  } else
#line 909
  if (fl___0->a.x >= f_w) {
#line 909
    outcode1 |= 2;
  }
#line 910
  outcode2 = 0;
#line 910
  if (fl___0->b.y < 0) {
#line 910
    outcode2 |= 8;
  } else
#line 910
  if (fl___0->b.y >= f_h) {
#line 910
    outcode2 |= 4;
  }
#line 910
  if (fl___0->b.x < 0) {
#line 910
    outcode2 |= 1;
  } else
#line 910
  if (fl___0->b.x >= f_w) {
#line 910
    outcode2 |= 2;
  }
#line 912
  if (outcode1 & outcode2) {
#line 913
    return ((boolean )0);
  }
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;
#line 915
    if (! (outcode1 | outcode2)) {
#line 915
      goto while_break;
    }
#line 919
    if (outcode1) {
#line 920
      outside = outcode1;
    } else {
#line 922
      outside = outcode2;
    }
#line 925
    if (outside & 8) {
#line 927
      dy = fl___0->a.y - fl___0->b.y;
#line 928
      dx = fl___0->b.x - fl___0->a.x;
#line 929
      tmp.x = fl___0->a.x + (dx * fl___0->a.y) / dy;
#line 930
      tmp.y = 0;
    } else
#line 932
    if (outside & 4) {
#line 934
      dy = fl___0->a.y - fl___0->b.y;
#line 935
      dx = fl___0->b.x - fl___0->a.x;
#line 936
      tmp.x = fl___0->a.x + (dx * (fl___0->a.y - f_h)) / dy;
#line 937
      tmp.y = f_h - 1;
    } else
#line 939
    if (outside & 2) {
#line 941
      dy = fl___0->b.y - fl___0->a.y;
#line 942
      dx = fl___0->b.x - fl___0->a.x;
#line 943
      tmp.y = fl___0->a.y + (dy * ((f_w - 1) - fl___0->a.x)) / dx;
#line 944
      tmp.x = f_w - 1;
    } else
#line 946
    if (outside & 1) {
#line 948
      dy = fl___0->b.y - fl___0->a.y;
#line 949
      dx = fl___0->b.x - fl___0->a.x;
#line 950
      tmp.y = fl___0->a.y + (dy * - fl___0->a.x) / dx;
#line 951
      tmp.x = 0;
    }
#line 954
    if (outside == outcode1) {
#line 956
      fl___0->a = tmp;
#line 957
      outcode1 = 0;
#line 957
      if (fl___0->a.y < 0) {
#line 957
        outcode1 |= 8;
      } else
#line 957
      if (fl___0->a.y >= f_h) {
#line 957
        outcode1 |= 4;
      }
#line 957
      if (fl___0->a.x < 0) {
#line 957
        outcode1 |= 1;
      } else
#line 957
      if (fl___0->a.x >= f_w) {
#line 957
        outcode1 |= 2;
      }
    } else {
#line 961
      fl___0->b = tmp;
#line 962
      outcode2 = 0;
#line 962
      if (fl___0->b.y < 0) {
#line 962
        outcode2 |= 8;
      } else
#line 962
      if (fl___0->b.y >= f_h) {
#line 962
        outcode2 |= 4;
      }
#line 962
      if (fl___0->b.x < 0) {
#line 962
        outcode2 |= 1;
      } else
#line 962
      if (fl___0->b.x >= f_w) {
#line 962
        outcode2 |= 2;
      }
    }
#line 965
    if (outcode1 & outcode2) {
#line 966
      return ((boolean )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 969
  return ((boolean )1);
}
}
#line 992
void AM_drawFline(fline_t *fl___0 , int color ) ;
#line 992 "am_map.c"
static int fuck  =    0;
#line 977 "am_map.c"
void AM_drawFline(fline_t *fl___0 , int color ) 
{ 
  register int x___0 ;
  register int y___1 ;
  register int dx ;
  register int dy ;
  register int sx ;
  register int sy ;
  register int ax ;
  register int ay ;
  register int d ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 995
  if (fl___0->a.x < 0) {
#line 995
    goto _L___5;
  } else
#line 995
  if (fl___0->a.x >= f_w) {
    _L___5: /* CIL Label */ 
#line 995
    goto _L___4;
  } else
#line 995
  if (fl___0->a.y < 0) {
    _L___4: /* CIL Label */ 
#line 995
    goto _L___3;
  } else
#line 995
  if (fl___0->a.y >= f_h) {
    _L___3: /* CIL Label */ 
#line 995
    goto _L___2;
  } else
#line 995
  if (fl___0->b.x < 0) {
    _L___2: /* CIL Label */ 
#line 995
    goto _L___1;
  } else
#line 995
  if (fl___0->b.x >= f_w) {
    _L___1: /* CIL Label */ 
#line 995
    goto _L___0;
  } else
#line 995
  if (fl___0->b.y < 0) {
    _L___0: /* CIL Label */ 
#line 995
    goto _L;
  } else
#line 995
  if (fl___0->b.y >= f_h) {
    _L: /* CIL Label */ 
#line 1000
    tmp = fuck;
#line 1000
    fuck ++;
#line 1000
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fuck %d \r",
            tmp);
#line 1001
    return;
  }
#line 1006
  dx = fl___0->b.x - fl___0->a.x;
#line 1007
  if (dx < 0) {
#line 1007
    tmp___0 = - dx;
  } else {
#line 1007
    tmp___0 = dx;
  }
#line 1007
  ax = 2 * tmp___0;
#line 1008
  if (dx < 0) {
#line 1008
    sx = -1;
  } else {
#line 1008
    sx = 1;
  }
#line 1010
  dy = fl___0->b.y - fl___0->a.y;
#line 1011
  if (dy < 0) {
#line 1011
    tmp___1 = - dy;
  } else {
#line 1011
    tmp___1 = dy;
  }
#line 1011
  ay = 2 * tmp___1;
#line 1012
  if (dy < 0) {
#line 1012
    sy = -1;
  } else {
#line 1012
    sy = 1;
  }
#line 1014
  x___0 = fl___0->a.x;
#line 1015
  y___1 = fl___0->a.y;
#line 1017
  if (ax > ay) {
#line 1019
    d = ay - ax / 2;
    {
#line 1020
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1020
      if (! 1) {
#line 1020
        goto while_break;
      }
#line 1022
      *(fb + (y___1 * f_w + x___0)) = (byte )color;
#line 1023
      if (x___0 == fl___0->b.x) {
#line 1023
        return;
      }
#line 1024
      if (d >= 0) {
#line 1026
        y___1 += sy;
#line 1027
        d -= ax;
      }
#line 1029
      x___0 += sx;
#line 1030
      d += ay;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1035
    d = ax - ay / 2;
    {
#line 1036
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1036
      if (! 1) {
#line 1036
        goto while_break___0;
      }
#line 1038
      *(fb + (y___1 * f_w + x___0)) = (byte )color;
#line 1039
      if (y___1 == fl___0->b.y) {
#line 1039
        return;
      }
#line 1040
      if (d >= 0) {
#line 1042
        x___0 += sx;
#line 1043
        d -= ay;
      }
#line 1045
      y___1 += sy;
#line 1046
      d += ax;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1049
  return;
}
}
#line 1060 "am_map.c"
static fline_t fl  ;
#line 1055 "am_map.c"
void AM_drawMline(mline_t *ml , int color ) 
{ 
  boolean tmp ;

  {
#line 1062
  tmp = AM_clipMline(ml, & fl);
#line 1062
  if (tmp) {
#line 1063
    AM_drawFline(& fl, color);
  }
#line 1064
  return;
}
}
#line 1071 "am_map.c"
void AM_drawGrid(int color ) 
{ 
  fixed_t x___0 ;
  fixed_t y___1 ;
  fixed_t start ;
  fixed_t end ;
  mline_t ml ;

  {
#line 1078
  start = m_x;
#line 1079
  if ((start - bmaporgx) % (128 << 16)) {
#line 1080
    start += (128 << 16) - (start - bmaporgx) % (128 << 16);
  }
#line 1082
  end = m_x + m_w;
#line 1085
  ml.a.y = m_y;
#line 1086
  ml.b.y = m_y + m_h;
#line 1087
  x___0 = start;
  {
#line 1087
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1087
    if (! (x___0 < end)) {
#line 1087
      goto while_break;
    }
#line 1089
    ml.a.x = x___0;
#line 1090
    ml.b.x = x___0;
#line 1091
    AM_drawMline(& ml, color);
#line 1087
    x___0 += 128 << 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 1095
  start = m_y;
#line 1096
  if ((start - bmaporgy) % (128 << 16)) {
#line 1097
    start += (128 << 16) - (start - bmaporgy) % (128 << 16);
  }
#line 1099
  end = m_y + m_h;
#line 1102
  ml.a.x = m_x;
#line 1103
  ml.b.x = m_x + m_w;
#line 1104
  y___1 = start;
  {
#line 1104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1104
    if (! (y___1 < end)) {
#line 1104
      goto while_break___0;
    }
#line 1106
    ml.a.y = y___1;
#line 1107
    ml.b.y = y___1;
#line 1108
    AM_drawMline(& ml, color);
#line 1104
    y___1 += 128 << 16;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1111
  return;
}
}
#line 1120 "am_map.c"
static mline_t l  ;
#line 1117 "am_map.c"
void AM_drawWalls(void) 
{ 
  int i ;

  {
#line 1122
  i = 0;
  {
#line 1122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1122
    if (! (i < numlines)) {
#line 1122
      goto while_break;
    }
#line 1124
    l.a.x = ((lines + i)->v1)->x;
#line 1125
    l.a.y = ((lines + i)->v1)->y;
#line 1126
    l.b.x = ((lines + i)->v2)->x;
#line 1127
    l.b.y = ((lines + i)->v2)->y;
#line 1128
    if (cheating) {
#line 1128
      goto _L___0;
    } else
#line 1128
    if ((int )(lines + i)->flags & 256) {
      _L___0: /* CIL Label */ 
#line 1130
      if ((int )(lines + i)->flags & 128) {
#line 1130
        if (! cheating) {
#line 1131
          goto __Cont;
        } else {
#line 1130
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
#line 1132
      if (! (lines + i)->backsector) {
#line 1134
        AM_drawMline(& l, 176 + lightlev);
      } else
#line 1138
      if ((int )(lines + i)->special == 39) {
#line 1140
        AM_drawMline(& l, 184);
      } else
#line 1142
      if ((int )(lines + i)->flags & 32) {
#line 1144
        if (cheating) {
#line 1144
          AM_drawMline(& l, 176 + lightlev);
        } else {
#line 1145
          AM_drawMline(& l, 176 + lightlev);
        }
      } else
#line 1147
      if (((lines + i)->backsector)->floorheight != ((lines + i)->frontsector)->floorheight) {
#line 1149
        AM_drawMline(& l, 64 + lightlev);
      } else
#line 1151
      if (((lines + i)->backsector)->ceilingheight != ((lines + i)->frontsector)->ceilingheight) {
#line 1153
        AM_drawMline(& l, 231 + lightlev);
      } else
#line 1155
      if (cheating) {
#line 1156
        AM_drawMline(& l, 96 + lightlev);
      }
    } else
#line 1160
    if (plr->powers[4]) {
#line 1162
      if (! ((int )(lines + i)->flags & 128)) {
#line 1162
        AM_drawMline(& l, 99);
      }
    }
    __Cont: /* CIL Label */ 
#line 1122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1165
  return;
}
}
#line 1172 "am_map.c"
void AM_rotate(fixed_t *x___0 , fixed_t *y___1 , angle_t a ) 
{ 
  fixed_t tmpx ;
  fixed_t tmp ;
  fixed_t tmp___0 ;
  fixed_t tmp___1 ;
  fixed_t tmp___2 ;

  {
#line 1180
  tmp = FixedMul(*x___0, *(finecosine + (a >> 19)));
#line 1180
  tmp___0 = FixedMul(*y___1, finesine[a >> 19]);
#line 1180
  tmpx = tmp - tmp___0;
#line 1184
  tmp___1 = FixedMul(*x___0, finesine[a >> 19]);
#line 1184
  tmp___2 = FixedMul(*y___1, *(finecosine + (a >> 19)));
#line 1184
  *y___1 = tmp___1 + tmp___2;
#line 1188
  *x___0 = tmpx;
#line 1189
  return;
}
}
#line 1191 "am_map.c"
void AM_drawLineCharacter(mline_t *lineguy , int lineguylines , fixed_t scale , angle_t angle ,
                          int color , fixed_t x___0 , fixed_t y___1 ) 
{ 
  int i ;
  mline_t l___0 ;

  {
#line 1204
  i = 0;
  {
#line 1204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1204
    if (! (i < lineguylines)) {
#line 1204
      goto while_break;
    }
#line 1206
    l___0.a.x = (lineguy + i)->a.x;
#line 1207
    l___0.a.y = (lineguy + i)->a.y;
#line 1209
    if (scale) {
#line 1211
      l___0.a.x = FixedMul(scale, l___0.a.x);
#line 1212
      l___0.a.y = FixedMul(scale, l___0.a.y);
    }
#line 1215
    if (angle) {
#line 1216
      AM_rotate(& l___0.a.x, & l___0.a.y, angle);
    }
#line 1218
    l___0.a.x += x___0;
#line 1219
    l___0.a.y += y___1;
#line 1221
    l___0.b.x = (lineguy + i)->b.x;
#line 1222
    l___0.b.y = (lineguy + i)->b.y;
#line 1224
    if (scale) {
#line 1226
      l___0.b.x = FixedMul(scale, l___0.b.x);
#line 1227
      l___0.b.y = FixedMul(scale, l___0.b.y);
    }
#line 1230
    if (angle) {
#line 1231
      AM_rotate(& l___0.b.x, & l___0.b.y, angle);
    }
#line 1233
    l___0.b.x += x___0;
#line 1234
    l___0.b.y += y___1;
#line 1236
    AM_drawMline(& l___0, color);
#line 1204
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1238
  return;
}
}
#line 1244
void AM_drawPlayers(void) ;
#line 1244 "am_map.c"
static int their_colors[4]  = {      112,      96,      64,      176};
#line 1240 "am_map.c"
void AM_drawPlayers(void) 
{ 
  int i ;
  player_t *p___0 ;
  int their_color ;
  int color ;

  {
#line 1245
  their_color = -1;
#line 1248
  if (! netgame) {
#line 1250
    if (cheating) {
#line 1251
      AM_drawLineCharacter(cheat_player_arrow, (int )(sizeof(cheat_player_arrow) / sizeof(mline_t )),
                           0, (plr->mo)->angle, 209, (plr->mo)->x, (plr->mo)->y);
    } else {
#line 1255
      AM_drawLineCharacter(player_arrow, (int )(sizeof(player_arrow) / sizeof(mline_t )),
                           0, (plr->mo)->angle, 209, (plr->mo)->x, (plr->mo)->y);
    }
#line 1258
    return;
  }
#line 1261
  i = 0;
  {
#line 1261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1261
    if (! (i < 4)) {
#line 1261
      goto while_break;
    }
#line 1263
    their_color ++;
#line 1264
    p___0 = & players[i];
#line 1266
    if (deathmatch) {
#line 1266
      if (! singledemo) {
#line 1266
        if ((unsigned long )p___0 != (unsigned long )plr) {
#line 1267
          goto __Cont;
        } else {
#line 1266
          goto _L___0;
        }
      } else {
#line 1266
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
#line 1269
    if (! playeringame[i]) {
#line 1270
      goto __Cont;
    }
#line 1272
    if (p___0->powers[2]) {
#line 1273
      color = 246;
    } else {
#line 1275
      color = their_colors[their_color];
    }
#line 1277
    AM_drawLineCharacter(player_arrow, (int )(sizeof(player_arrow) / sizeof(mline_t )),
                         0, (p___0->mo)->angle, color, (p___0->mo)->x, (p___0->mo)->y);
    __Cont: /* CIL Label */ 
#line 1261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1282
  return;
}
}
#line 1284 "am_map.c"
void AM_drawThings(int colors___0 , int colorrange ) 
{ 
  int i ;
  mobj_t *t ;

  {
#line 1292
  i = 0;
  {
#line 1292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1292
    if (! (i < numsectors)) {
#line 1292
      goto while_break;
    }
#line 1294
    t = (sectors + i)->thinglist;
    {
#line 1295
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1295
      if (! t) {
#line 1295
        goto while_break___0;
      }
#line 1297
      AM_drawLineCharacter(thintriangle_guy, (int )(sizeof(thintriangle_guy) / sizeof(mline_t )),
                           16 << 16, t->angle, colors___0 + lightlev, t->x, t->y);
#line 1300
      t = t->snext;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1292
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return;
}
}
#line 1305 "am_map.c"
void AM_drawMarks(void) 
{ 
  int i ;
  int fx ;
  int fy ;
  int w ;
  int h ;
  fixed_t tmp ;
  fixed_t tmp___0 ;

  {
#line 1309
  i = 0;
  {
#line 1309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1309
    if (! (i < 10)) {
#line 1309
      goto while_break;
    }
#line 1311
    if (markpoints[i].x != -1) {
#line 1315
      w = 5;
#line 1316
      h = 6;
#line 1317
      tmp = FixedMul(markpoints[i].x - m_x, scale_mtof);
#line 1317
      fx = f_x + (tmp >> 16);
#line 1318
      tmp___0 = FixedMul(markpoints[i].y - m_y, scale_mtof);
#line 1318
      fy = f_y + (f_h - (tmp___0 >> 16));
#line 1319
      if (fx >= f_x) {
#line 1319
        if (fx <= f_w - w) {
#line 1319
          if (fy >= f_y) {
#line 1319
            if (fy <= f_h - h) {
#line 1320
              V_DrawPatch(fx, fy, 0, marknums[i]);
            } else {
#line 1319
              goto _L___1;
            }
          } else {
#line 1319
            goto _L___1;
          }
        } else {
#line 1319
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        _L___0: /* CIL Label */ 
        _L: /* CIL Label */ ;
      }
    }
#line 1309
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1324
  return;
}
}
#line 1326 "am_map.c"
void AM_drawCrosshair(int color ) 
{ 


  {
#line 1328
  *(fb + (f_w * (f_h + 1)) / 2) = (byte )color;
#line 1330
  return;
}
}
#line 1332 "am_map.c"
void AM_Drawer(void) 
{ 


  {
#line 1334
  if (! automapactive) {
#line 1334
    return;
  }
#line 1336
  AM_clearFB(0);
#line 1337
  if (grid) {
#line 1338
    AM_drawGrid(104);
  }
#line 1339
  AM_drawWalls();
#line 1340
  AM_drawPlayers();
#line 1341
  if (cheating == 2) {
#line 1342
    AM_drawThings(112, 16);
  }
#line 1343
  AM_drawCrosshair(96);
#line 1345
  AM_drawMarks();
#line 1347
  V_MarkRect(f_x, f_y, f_w, f_h);
#line 1349
  return;
}
}
#line 23 "p_ceilng.c"
static char const   rcsid___22[51]  = 
#line 23 "p_ceilng.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'c', 
        (char const   )'e',      (char const   )'i',      (char const   )'l',      (char const   )'n', 
        (char const   )'g',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'4',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )' ',      (char const   )'1',      (char const   )'6',      (char const   )':', 
        (char const   )'4',      (char const   )'7',      (char const   )':',      (char const   )'5', 
        (char const   )'3',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 520 "p_spec.h"
ceiling_t *activeceilings[30]  ;
#line 52 "p_ceilng.c"
void T_MoveCeiling(ceiling_t *ceiling ) 
{ 
  result_e res ;

  {
  {
#line 58
  if (ceiling->direction == 0) {
#line 58
    goto case_0;
  }
#line 61
  if (ceiling->direction == 1) {
#line 61
    goto case_1;
  }
#line 105
  if (ceiling->direction == -1) {
#line 105
    goto case_neg_1;
  }
#line 56
  goto switch_break;
  case_0: /* CIL Label */ 
#line 60
  goto switch_break;
  case_1: /* CIL Label */ 
#line 63
  res = T_MovePlane(ceiling->sector, ceiling->speed, ceiling->topheight, (boolean )0,
                    1, ceiling->direction);
#line 68
  if (! (leveltime & 7)) {
    {
#line 72
    if ((unsigned int )ceiling->type == 5U) {
#line 72
      goto case_5;
    }
#line 74
    goto switch_default;
    case_5: /* CIL Label */ 
#line 73
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 75
    S_StartSound((void *)((mobj_t *)(& (ceiling->sector)->soundorg)), 22);
#line 78
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 82
  if ((unsigned int )res == 2U) {
    {
#line 86
    if ((unsigned int )ceiling->type == 1U) {
#line 86
      goto case_1___0;
    }
#line 90
    if ((unsigned int )ceiling->type == 5U) {
#line 90
      goto case_5___0;
    }
#line 94
    if ((unsigned int )ceiling->type == 3U) {
#line 94
      goto case_3;
    }
#line 94
    if ((unsigned int )ceiling->type == 4U) {
#line 94
      goto case_3;
    }
#line 98
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 87
    P_RemoveActiveCeiling(ceiling);
#line 88
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 91
    S_StartSound((void *)((mobj_t *)(& (ceiling->sector)->soundorg)), 19);
    case_3: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 95
    ceiling->direction = -1;
#line 96
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 99
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 103
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 107
  res = T_MovePlane(ceiling->sector, ceiling->speed, ceiling->bottomheight, ceiling->crush,
                    1, ceiling->direction);
#line 112
  if (! (leveltime & 7)) {
    {
#line 116
    if ((unsigned int )ceiling->type == 5U) {
#line 116
      goto case_5___1;
    }
#line 117
    goto switch_default___1;
    case_5___1: /* CIL Label */ 
#line 116
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
#line 118
    S_StartSound((void *)((mobj_t *)(& (ceiling->sector)->soundorg)), 22);
    switch_break___2: /* CIL Label */ ;
    }
  }
#line 123
  if ((unsigned int )res == 2U) {
    {
#line 127
    if ((unsigned int )ceiling->type == 5U) {
#line 127
      goto case_5___2;
    }
#line 130
    if ((unsigned int )ceiling->type == 3U) {
#line 130
      goto case_3___0;
    }
#line 132
    if ((unsigned int )ceiling->type == 4U) {
#line 132
      goto case_4___0;
    }
#line 137
    if ((unsigned int )ceiling->type == 0U) {
#line 137
      goto case_0___0;
    }
#line 137
    if ((unsigned int )ceiling->type == 2U) {
#line 137
      goto case_0___0;
    }
#line 141
    goto switch_default___2;
    case_5___2: /* CIL Label */ 
#line 128
    S_StartSound((void *)((mobj_t *)(& (ceiling->sector)->soundorg)), 19);
    case_3___0: /* CIL Label */ 
#line 131
    ceiling->speed = 1 << 16;
    case_4___0: /* CIL Label */ 
#line 133
    ceiling->direction = 1;
#line 134
    goto switch_break___3;
    case_0___0: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 138
    P_RemoveActiveCeiling(ceiling);
#line 139
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 142
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
  } else
#line 147
  if ((unsigned int )res == 1U) {
    {
#line 153
    if ((unsigned int )ceiling->type == 2U) {
#line 153
      goto case_2___0;
    }
#line 153
    if ((unsigned int )ceiling->type == 3U) {
#line 153
      goto case_2___0;
    }
#line 153
    if ((unsigned int )ceiling->type == 5U) {
#line 153
      goto case_2___0;
    }
#line 157
    goto switch_default___3;
    case_2___0: /* CIL Label */ 
    case_3___1: /* CIL Label */ 
    case_5___3: /* CIL Label */ 
#line 154
    ceiling->speed = (1 << 16) / 8;
#line 155
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
#line 158
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
  }
#line 162
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 171 "p_ceilng.c"
int EV_DoCeiling(line_t *line , ceiling_e type ) 
{ 
  int secnum ;
  int rtn ;
  sector_t *sec ;
  ceiling_t *ceiling ;
  void *tmp ;

  {
#line 181
  secnum = -1;
#line 182
  rtn = 0;
  {
#line 189
  if ((unsigned int )type == 3U) {
#line 189
    goto case_3;
  }
#line 189
  if ((unsigned int )type == 5U) {
#line 189
    goto case_3;
  }
#line 189
  if ((unsigned int )type == 4U) {
#line 189
    goto case_3;
  }
#line 191
  goto switch_default;
  case_3: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 190
  P_ActivateInStasisCeiling(line);
  switch_default: /* CIL Label */ 
#line 192
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    secnum = P_FindSectorFromLineTag(line, secnum);
#line 195
    if (! (secnum >= 0)) {
#line 195
      goto while_break;
    }
#line 197
    sec = sectors + secnum;
#line 198
    if (sec->specialdata) {
#line 199
      goto while_continue;
    }
#line 202
    rtn = 1;
#line 203
    tmp = Z_Malloc((int )sizeof(*ceiling), 51, (void *)0);
#line 203
    ceiling = (ceiling_t *)tmp;
#line 204
    P_AddThinker(& ceiling->thinker);
#line 205
    sec->specialdata = (void *)ceiling;
#line 206
    ceiling->thinker.function.acp1 = (void (*)(void * ))(& T_MoveCeiling);
#line 207
    ceiling->sector = sec;
#line 208
    ceiling->crush = (boolean )0;
    {
#line 212
    if ((unsigned int )type == 4U) {
#line 212
      goto case_4___0;
    }
#line 221
    if ((unsigned int )type == 3U) {
#line 221
      goto case_3___0;
    }
#line 221
    if ((unsigned int )type == 5U) {
#line 221
      goto case_3___0;
    }
#line 225
    if ((unsigned int )type == 0U) {
#line 225
      goto case_0;
    }
#line 225
    if ((unsigned int )type == 2U) {
#line 225
      goto case_0;
    }
#line 233
    if ((unsigned int )type == 1U) {
#line 233
      goto case_1;
    }
#line 210
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 213
    ceiling->crush = (boolean )1;
#line 214
    ceiling->topheight = sec->ceilingheight;
#line 215
    ceiling->bottomheight = sec->floorheight + 8 * (1 << 16);
#line 216
    ceiling->direction = -1;
#line 217
    ceiling->speed = (1 << 16) * 2;
#line 218
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
#line 222
    ceiling->crush = (boolean )1;
#line 223
    ceiling->topheight = sec->ceilingheight;
    case_0: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 226
    ceiling->bottomheight = sec->floorheight;
#line 227
    if ((unsigned int )type != 0U) {
#line 228
      ceiling->bottomheight += 8 * (1 << 16);
    }
#line 229
    ceiling->direction = -1;
#line 230
    ceiling->speed = 1 << 16;
#line 231
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 234
    ceiling->topheight = P_FindHighestCeilingSurrounding(sec);
#line 235
    ceiling->direction = 1;
#line 236
    ceiling->speed = 1 << 16;
#line 237
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 240
    ceiling->tag = (int )sec->tag;
#line 241
    ceiling->type = type;
#line 242
    P_AddActiveCeiling(ceiling);
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return (rtn);
}
}
#line 251 "p_ceilng.c"
void P_AddActiveCeiling(ceiling_t *c ) 
{ 
  int i ;

  {
#line 255
  i = 0;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (i < 30)) {
#line 255
      goto while_break;
    }
#line 257
    if ((unsigned long )activeceilings[i] == (unsigned long )((void *)0)) {
#line 259
      activeceilings[i] = c;
#line 260
      return;
    }
#line 255
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return;
}
}
#line 270 "p_ceilng.c"
void P_RemoveActiveCeiling(ceiling_t *c ) 
{ 
  int i ;

  {
#line 274
  i = 0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < 30)) {
#line 274
      goto while_break;
    }
#line 276
    if ((unsigned long )activeceilings[i] == (unsigned long )c) {
#line 278
      ((activeceilings[i])->sector)->specialdata = (void *)0;
#line 279
      P_RemoveThinker(& (activeceilings[i])->thinker);
#line 280
      activeceilings[i] = (ceiling_t *)((void *)0);
#line 281
      goto while_break;
    }
#line 274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return;
}
}
#line 291 "p_ceilng.c"
void P_ActivateInStasisCeiling(line_t *line ) 
{ 
  int i ;

  {
#line 295
  i = 0;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (i < 30)) {
#line 295
      goto while_break;
    }
#line 297
    if (activeceilings[i]) {
#line 297
      if ((activeceilings[i])->tag == (int )line->tag) {
#line 297
        if ((activeceilings[i])->direction == 0) {
#line 301
          (activeceilings[i])->direction = (activeceilings[i])->olddirection;
#line 302
          (activeceilings[i])->thinker.function.acp1 = (void (*)(void * ))(& T_MoveCeiling);
        } else {
#line 297
          goto _L___0;
        }
      } else {
#line 297
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
#line 295
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return;
}
}
#line 314 "p_ceilng.c"
int EV_CeilingCrushStop(line_t *line ) 
{ 
  int i ;
  int rtn ;

  {
#line 319
  rtn = 0;
#line 320
  i = 0;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! (i < 30)) {
#line 320
      goto while_break;
    }
#line 322
    if (activeceilings[i]) {
#line 322
      if ((activeceilings[i])->tag == (int )line->tag) {
#line 322
        if ((activeceilings[i])->direction != 0) {
#line 326
          (activeceilings[i])->olddirection = (activeceilings[i])->direction;
#line 327
          (activeceilings[i])->thinker.function.acv = (void (*)())((void *)0);
#line 328
          (activeceilings[i])->direction = 0;
#line 329
          rtn = 1;
        } else {
#line 322
          goto _L___0;
        }
      } else {
#line 322
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
#line 320
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  return (rtn);
}
}
#line 23 "p_doors.c"
static char const   rcsid___23[50]  = 
#line 23 "p_doors.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'d', 
        (char const   )'o',      (char const   )'o',      (char const   )'r',      (char const   )'s', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'4', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )' ', 
        (char const   )'1',      (char const   )'6',      (char const   )':',      (char const   )'4', 
        (char const   )'7',      (char const   )':',      (char const   )'5',      (char const   )'3', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 63 "p_doors.c"
void T_VerticalDoor(vldoor_t *door ) 
{ 
  result_e res ;

  {
  {
#line 69
  if (door->direction == 0) {
#line 69
    goto case_0;
  }
#line 99
  if (door->direction == 2) {
#line 99
    goto case_2;
  }
#line 118
  if (door->direction == -1) {
#line 118
    goto case_neg_1;
  }
#line 168
  if (door->direction == 1) {
#line 168
    goto case_1___1;
  }
#line 67
  goto switch_break;
  case_0: /* CIL Label */ 
#line 71
  (door->topcountdown) --;
#line 71
  if (! door->topcountdown) {
    {
#line 75
    if ((unsigned int )door->type == 5U) {
#line 75
      goto case_5;
    }
#line 81
    if ((unsigned int )door->type == 0U) {
#line 81
      goto case_0___0;
    }
#line 87
    if ((unsigned int )door->type == 1U) {
#line 87
      goto case_1;
    }
#line 93
    goto switch_default;
    case_5: /* CIL Label */ 
#line 76
    door->direction = -1;
#line 77
    S_StartSound((void *)((mobj_t *)(& (door->sector)->soundorg)), 89);
#line 79
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 82
    door->direction = -1;
#line 83
    S_StartSound((void *)((mobj_t *)(& (door->sector)->soundorg)), 21);
#line 85
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 88
    door->direction = 1;
#line 89
    S_StartSound((void *)((mobj_t *)(& (door->sector)->soundorg)), 20);
#line 91
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 94
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 97
  goto switch_break;
  case_2: /* CIL Label */ 
#line 101
  (door->topcountdown) --;
#line 101
  if (! door->topcountdown) {
    {
#line 105
    if ((unsigned int )door->type == 4U) {
#line 105
      goto case_4;
    }
#line 112
    goto switch_default___0;
    case_4: /* CIL Label */ 
#line 106
    door->direction = 1;
#line 107
    door->type = (vldoor_e )0;
#line 108
    S_StartSound((void *)((mobj_t *)(& (door->sector)->soundorg)), 20);
#line 110
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 113
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 116
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 120
  res = T_MovePlane(door->sector, door->speed, (door->sector)->floorheight, (boolean )0,
                    1, door->direction);
#line 124
  if ((unsigned int )res == 2U) {
    {
#line 129
    if ((unsigned int )door->type == 7U) {
#line 129
      goto case_7;
    }
#line 129
    if ((unsigned int )door->type == 5U) {
#line 129
      goto case_7;
    }
#line 137
    if ((unsigned int )door->type == 2U) {
#line 137
      goto case_2___0;
    }
#line 137
    if ((unsigned int )door->type == 0U) {
#line 137
      goto case_2___0;
    }
#line 142
    if ((unsigned int )door->type == 1U) {
#line 142
      goto case_1___0;
    }
#line 147
    goto switch_default___1;
    case_7: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
#line 130
    (door->sector)->specialdata = (void *)0;
#line 131
    P_RemoveThinker(& door->thinker);
#line 132
    S_StartSound((void *)((mobj_t *)(& (door->sector)->soundorg)), 89);
#line 134
    goto switch_break___2;
    case_2___0: /* CIL Label */ 
    case_0___1: /* CIL Label */ 
#line 138
    (door->sector)->specialdata = (void *)0;
#line 139
    P_RemoveThinker(& door->thinker);
#line 140
    goto switch_break___2;
    case_1___0: /* CIL Label */ 
#line 143
    door->direction = 0;
#line 144
    door->topcountdown = 1050;
#line 145
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
#line 148
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
  } else
#line 151
  if ((unsigned int )res == 1U) {
    {
#line 156
    if ((unsigned int )door->type == 2U) {
#line 156
      goto case_2___1;
    }
#line 156
    if ((unsigned int )door->type == 7U) {
#line 156
      goto case_2___1;
    }
#line 159
    goto switch_default___2;
    case_2___1: /* CIL Label */ 
    case_7___0: /* CIL Label */ 
#line 157
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 160
    door->direction = 1;
#line 161
    S_StartSound((void *)((mobj_t *)(& (door->sector)->soundorg)), 20);
#line 163
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
  }
#line 166
  goto switch_break;
  case_1___1: /* CIL Label */ 
#line 170
  res = T_MovePlane(door->sector, door->speed, door->topheight, (boolean )0, 1, door->direction);
#line 175
  if ((unsigned int )res == 2U) {
    {
#line 180
    if ((unsigned int )door->type == 0U) {
#line 180
      goto case_0___2;
    }
#line 180
    if ((unsigned int )door->type == 5U) {
#line 180
      goto case_0___2;
    }
#line 187
    if ((unsigned int )door->type == 3U) {
#line 187
      goto case_3;
    }
#line 187
    if ((unsigned int )door->type == 6U) {
#line 187
      goto case_3;
    }
#line 187
    if ((unsigned int )door->type == 1U) {
#line 187
      goto case_3;
    }
#line 192
    goto switch_default___3;
    case_0___2: /* CIL Label */ 
    case_5___1: /* CIL Label */ 
#line 181
    door->direction = 0;
#line 182
    door->topcountdown = door->topwait;
#line 183
    goto switch_break___4;
    case_3: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_1___2: /* CIL Label */ 
#line 188
    (door->sector)->specialdata = (void *)0;
#line 189
    P_RemoveThinker(& door->thinker);
#line 190
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
#line 193
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
  }
#line 196
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 198
  return;
}
}
#line 206 "p_doors.c"
int EV_DoLockedDoor(line_t *line , vldoor_e type , mobj_t *thing ) 
{ 
  player_t *p___0 ;
  int tmp ;

  {
#line 214
  p___0 = thing->player;
#line 216
  if (! p___0) {
#line 217
    return (0);
  }
  {
#line 222
  if ((int )line->special == 133) {
#line 222
    goto case_133;
  }
#line 222
  if ((int )line->special == 99) {
#line 222
    goto case_133;
  }
#line 234
  if ((int )line->special == 135) {
#line 234
    goto case_135;
  }
#line 234
  if ((int )line->special == 134) {
#line 234
    goto case_135;
  }
#line 246
  if ((int )line->special == 137) {
#line 246
    goto case_137;
  }
#line 246
  if ((int )line->special == 136) {
#line 246
    goto case_137;
  }
#line 219
  goto switch_break;
  case_133: /* CIL Label */ 
  case_99: /* CIL Label */ 
#line 223
  if (! p___0) {
#line 224
    return (0);
  }
#line 225
  if (! p___0->cards[0]) {
#line 225
    if (! p___0->cards[3]) {
#line 227
      p___0->message = "You need a blue key to activate this object";
#line 228
      S_StartSound((void *)0, 34);
#line 229
      return (0);
    } else {
#line 225
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 231
  goto switch_break;
  case_135: /* CIL Label */ 
  case_134: /* CIL Label */ 
#line 235
  if (! p___0) {
#line 236
    return (0);
  }
#line 237
  if (! p___0->cards[2]) {
#line 237
    if (! p___0->cards[5]) {
#line 239
      p___0->message = "You need a red key to activate this object";
#line 240
      S_StartSound((void *)0, 34);
#line 241
      return (0);
    } else {
#line 237
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 243
  goto switch_break;
  case_137: /* CIL Label */ 
  case_136: /* CIL Label */ 
#line 247
  if (! p___0) {
#line 248
    return (0);
  }
#line 249
  if (! p___0->cards[1]) {
#line 249
    if (! p___0->cards[4]) {
#line 252
      p___0->message = "You need a yellow key to activate this object";
#line 253
      S_StartSound((void *)0, 34);
#line 254
      return (0);
    } else {
#line 249
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 256
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 259
  tmp = EV_DoDoor(line, type);
#line 259
  return (tmp);
}
}
#line 263 "p_doors.c"
int EV_DoDoor(line_t *line , vldoor_e type ) 
{ 
  int secnum ;
  int rtn ;
  sector_t *sec ;
  vldoor_t *door ;
  void *tmp ;

  {
#line 272
  secnum = -1;
#line 273
  rtn = 0;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    secnum = P_FindSectorFromLineTag(line, secnum);
#line 275
    if (! (secnum >= 0)) {
#line 275
      goto while_break;
    }
#line 277
    sec = sectors + secnum;
#line 278
    if (sec->specialdata) {
#line 279
      goto while_continue;
    }
#line 283
    rtn = 1;
#line 284
    tmp = Z_Malloc((int )sizeof(*door), 51, (void *)0);
#line 284
    door = (vldoor_t *)tmp;
#line 285
    P_AddThinker(& door->thinker);
#line 286
    sec->specialdata = (void *)door;
#line 288
    door->thinker.function.acp1 = (void (*)(void * ))(& T_VerticalDoor);
#line 289
    door->sector = sec;
#line 290
    door->type = type;
#line 291
    door->topwait = 150;
#line 292
    door->speed = (1 << 16) * 2;
    {
#line 296
    if ((unsigned int )type == 7U) {
#line 296
      goto case_7;
    }
#line 305
    if ((unsigned int )type == 2U) {
#line 305
      goto case_2;
    }
#line 313
    if ((unsigned int )type == 1U) {
#line 313
      goto case_1;
    }
#line 321
    if ((unsigned int )type == 6U) {
#line 321
      goto case_6;
    }
#line 321
    if ((unsigned int )type == 5U) {
#line 321
      goto case_6;
    }
#line 332
    if ((unsigned int )type == 3U) {
#line 332
      goto case_3;
    }
#line 332
    if ((unsigned int )type == 0U) {
#line 332
      goto case_3;
    }
#line 341
    goto switch_default;
    case_7: /* CIL Label */ 
#line 297
    door->topheight = P_FindLowestCeilingSurrounding(sec);
#line 298
    door->topheight -= 4 * (1 << 16);
#line 299
    door->direction = -1;
#line 300
    door->speed = ((1 << 16) * 2) * 4;
#line 301
    S_StartSound((void *)((mobj_t *)(& (door->sector)->soundorg)), 89);
#line 303
    goto switch_break;
    case_2: /* CIL Label */ 
#line 306
    door->topheight = P_FindLowestCeilingSurrounding(sec);
#line 307
    door->topheight -= 4 * (1 << 16);
#line 308
    door->direction = -1;
#line 309
    S_StartSound((void *)((mobj_t *)(& (door->sector)->soundorg)), 21);
#line 311
    goto switch_break;
    case_1: /* CIL Label */ 
#line 314
    door->topheight = sec->ceilingheight;
#line 315
    door->direction = -1;
#line 316
    S_StartSound((void *)((mobj_t *)(& (door->sector)->soundorg)), 21);
#line 318
    goto switch_break;
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
#line 322
    door->direction = 1;
#line 323
    door->topheight = P_FindLowestCeilingSurrounding(sec);
#line 324
    door->topheight -= 4 * (1 << 16);
#line 325
    door->speed = ((1 << 16) * 2) * 4;
#line 326
    if (door->topheight != sec->ceilingheight) {
#line 327
      S_StartSound((void *)((mobj_t *)(& (door->sector)->soundorg)), 88);
    }
#line 329
    goto switch_break;
    case_3: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 333
    door->direction = 1;
#line 334
    door->topheight = P_FindLowestCeilingSurrounding(sec);
#line 335
    door->topheight -= 4 * (1 << 16);
#line 336
    if (door->topheight != sec->ceilingheight) {
#line 337
      S_StartSound((void *)((mobj_t *)(& (door->sector)->soundorg)), 20);
    }
#line 339
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 342
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  return (rtn);
}
}
#line 353 "p_doors.c"
void EV_VerticalDoor(line_t *line , mobj_t *thing ) 
{ 
  player_t *player ;
  int secnum ;
  sector_t *sec ;
  vldoor_t *door ;
  int side ;
  void *tmp ;

  {
#line 364
  side = 0;
#line 367
  player = thing->player;
  {
#line 372
  if ((int )line->special == 32) {
#line 372
    goto case_32;
  }
#line 372
  if ((int )line->special == 26) {
#line 372
    goto case_32;
  }
#line 385
  if ((int )line->special == 34) {
#line 385
    goto case_34;
  }
#line 385
  if ((int )line->special == 27) {
#line 385
    goto case_34;
  }
#line 399
  if ((int )line->special == 33) {
#line 399
    goto case_33;
  }
#line 399
  if ((int )line->special == 28) {
#line 399
    goto case_33;
  }
#line 369
  goto switch_break;
  case_32: /* CIL Label */ 
  case_26: /* CIL Label */ 
#line 373
  if (! player) {
#line 374
    return;
  }
#line 376
  if (! player->cards[0]) {
#line 376
    if (! player->cards[3]) {
#line 378
      player->message = "You need a blue key to open this door";
#line 379
      S_StartSound((void *)0, 34);
#line 380
      return;
    } else {
#line 376
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 382
  goto switch_break;
  case_34: /* CIL Label */ 
  case_27: /* CIL Label */ 
#line 386
  if (! player) {
#line 387
    return;
  }
#line 389
  if (! player->cards[1]) {
#line 389
    if (! player->cards[4]) {
#line 392
      player->message = "You need a yellow key to open this door";
#line 393
      S_StartSound((void *)0, 34);
#line 394
      return;
    } else {
#line 389
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 396
  goto switch_break;
  case_33: /* CIL Label */ 
  case_28: /* CIL Label */ 
#line 400
  if (! player) {
#line 401
    return;
  }
#line 403
  if (! player->cards[2]) {
#line 403
    if (! player->cards[5]) {
#line 405
      player->message = "You need a red key to open this door";
#line 406
      S_StartSound((void *)0, 34);
#line 407
      return;
    } else {
#line 403
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 409
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 413
  sec = (sides + line->sidenum[side ^ 1])->sector;
#line 414
  secnum = (int )(sec - sectors);
#line 416
  if (sec->specialdata) {
#line 418
    door = (vldoor_t *)sec->specialdata;
    {
#line 425
    if ((int )line->special == 117) {
#line 425
      goto case_117;
    }
#line 425
    if ((int )line->special == 28) {
#line 425
      goto case_117;
    }
#line 425
    if ((int )line->special == 27) {
#line 425
      goto case_117;
    }
#line 425
    if ((int )line->special == 26) {
#line 425
      goto case_117;
    }
#line 425
    if ((int )line->special == 1) {
#line 425
      goto case_117;
    }
#line 419
    goto switch_break___0;
    case_117: /* CIL Label */ 
    case_28___0: /* CIL Label */ 
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 426
    if (door->direction == -1) {
#line 427
      door->direction = 1;
    } else {
#line 430
      if (! thing->player) {
#line 431
        return;
      }
#line 433
      door->direction = -1;
    }
#line 435
    return;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 443
  if ((int )line->special == 118) {
#line 443
    goto case_118;
  }
#line 443
  if ((int )line->special == 117) {
#line 443
    goto case_118;
  }
#line 448
  if ((int )line->special == 31) {
#line 448
    goto case_31;
  }
#line 448
  if ((int )line->special == 1) {
#line 448
    goto case_31;
  }
#line 452
  goto switch_default;
  case_118: /* CIL Label */ 
  case_117___0: /* CIL Label */ 
#line 444
  S_StartSound((void *)((mobj_t *)(& sec->soundorg)), 88);
#line 445
  goto switch_break___1;
  case_31: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 449
  S_StartSound((void *)((mobj_t *)(& sec->soundorg)), 20);
#line 450
  goto switch_break___1;
  switch_default: /* CIL Label */ 
#line 453
  S_StartSound((void *)((mobj_t *)(& sec->soundorg)), 20);
#line 454
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 459
  tmp = Z_Malloc((int )sizeof(*door), 51, (void *)0);
#line 459
  door = (vldoor_t *)tmp;
#line 460
  P_AddThinker(& door->thinker);
#line 461
  sec->specialdata = (void *)door;
#line 462
  door->thinker.function.acp1 = (void (*)(void * ))(& T_VerticalDoor);
#line 463
  door->sector = sec;
#line 464
  door->direction = 1;
#line 465
  door->speed = (1 << 16) * 2;
#line 466
  door->topwait = 150;
  {
#line 473
  if ((int )line->special == 28) {
#line 473
    goto case_28___1;
  }
#line 473
  if ((int )line->special == 27) {
#line 473
    goto case_28___1;
  }
#line 473
  if ((int )line->special == 26) {
#line 473
    goto case_28___1;
  }
#line 473
  if ((int )line->special == 1) {
#line 473
    goto case_28___1;
  }
#line 480
  if ((int )line->special == 34) {
#line 480
    goto case_34___0;
  }
#line 480
  if ((int )line->special == 33) {
#line 480
    goto case_34___0;
  }
#line 480
  if ((int )line->special == 32) {
#line 480
    goto case_34___0;
  }
#line 480
  if ((int )line->special == 31) {
#line 480
    goto case_34___0;
  }
#line 485
  if ((int )line->special == 117) {
#line 485
    goto case_117___1;
  }
#line 489
  if ((int )line->special == 118) {
#line 489
    goto case_118___0;
  }
#line 468
  goto switch_break___2;
  case_28___1: /* CIL Label */ 
  case_27___1: /* CIL Label */ 
  case_26___1: /* CIL Label */ 
  case_1___1: /* CIL Label */ 
#line 474
  door->type = (vldoor_e )0;
#line 475
  goto switch_break___2;
  case_34___0: /* CIL Label */ 
  case_33___0: /* CIL Label */ 
  case_32___0: /* CIL Label */ 
  case_31___0: /* CIL Label */ 
#line 481
  door->type = (vldoor_e )3;
#line 482
  line->special = (short)0;
#line 483
  goto switch_break___2;
  case_117___1: /* CIL Label */ 
#line 486
  door->type = (vldoor_e )5;
#line 487
  door->speed = ((1 << 16) * 2) * 4;
#line 488
  goto switch_break___2;
  case_118___0: /* CIL Label */ 
#line 490
  door->type = (vldoor_e )6;
#line 491
  line->special = (short)0;
#line 492
  door->speed = ((1 << 16) * 2) * 4;
#line 493
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 497
  door->topheight = P_FindLowestCeilingSurrounding(sec);
#line 498
  door->topheight -= 4 * (1 << 16);
#line 499
  return;
}
}
#line 505 "p_doors.c"
void P_SpawnDoorCloseIn30(sector_t *sec ) 
{ 
  vldoor_t *door ;
  void *tmp ;

  {
#line 509
  tmp = Z_Malloc((int )sizeof(*door), 51, (void *)0);
#line 509
  door = (vldoor_t *)tmp;
#line 511
  P_AddThinker(& door->thinker);
#line 513
  sec->specialdata = (void *)door;
#line 514
  sec->special = (short)0;
#line 516
  door->thinker.function.acp1 = (void (*)(void * ))(& T_VerticalDoor);
#line 517
  door->sector = sec;
#line 518
  door->direction = 0;
#line 519
  door->type = (vldoor_e )0;
#line 520
  door->speed = (1 << 16) * 2;
#line 521
  door->topcountdown = 1050;
#line 522
  return;
}
}
#line 527 "p_doors.c"
void P_SpawnDoorRaiseIn5Mins(sector_t *sec , int secnum ) 
{ 
  vldoor_t *door ;
  void *tmp ;

  {
#line 534
  tmp = Z_Malloc((int )sizeof(*door), 51, (void *)0);
#line 534
  door = (vldoor_t *)tmp;
#line 536
  P_AddThinker(& door->thinker);
#line 538
  sec->specialdata = (void *)door;
#line 539
  sec->special = (short)0;
#line 541
  door->thinker.function.acp1 = (void (*)(void * ))(& T_VerticalDoor);
#line 542
  door->sector = sec;
#line 543
  door->direction = 2;
#line 544
  door->type = (vldoor_e )4;
#line 545
  door->speed = (1 << 16) * 2;
#line 546
  door->topheight = P_FindLowestCeilingSurrounding(sec);
#line 547
  door->topheight -= 4 * (1 << 16);
#line 548
  door->topwait = 150;
#line 549
  door->topcountdown = 10500;
#line 550
  return;
}
}
#line 26 "p_enemy.c"
static char const   rcsid___24[50]  = 
#line 26 "p_enemy.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'e', 
        (char const   )'n',      (char const   )'e',      (char const   )'m',      (char const   )'y', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )' ', 
        (char const   )'2',      (char const   )'2',      (char const   )':',      (char const   )'4', 
        (char const   )'5',      (char const   )':',      (char const   )'1',      (char const   )'1', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 70 "p_enemy.c"
dirtype_t opposite[9]  = 
#line 70
  {      (dirtype_t )4,      (dirtype_t )5,      (dirtype_t )6,      (dirtype_t )7, 
        (dirtype_t )0,      (dirtype_t )1,      (dirtype_t )2,      (dirtype_t )3, 
        (dirtype_t )8};
#line 76 "p_enemy.c"
dirtype_t diags[4]  = {      (dirtype_t )3,      (dirtype_t )1,      (dirtype_t )5,      (dirtype_t )7};
#line 85
void A_Fall(mobj_t *actor ) ;
#line 103 "p_enemy.c"
mobj_t *soundtarget  ;
#line 105 "p_enemy.c"
void P_RecursiveSound(sector_t *sec , int soundblocks ) 
{ 
  int i ;
  line_t *check ;
  sector_t *other ;

  {
#line 115
  if (sec->validcount == validcount) {
#line 115
    if (sec->soundtraversed <= soundblocks + 1) {
#line 118
      return;
    } else {
#line 115
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 121
  sec->validcount = validcount;
#line 122
  sec->soundtraversed = soundblocks + 1;
#line 123
  sec->soundtarget = soundtarget;
#line 125
  i = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (i < sec->linecount)) {
#line 125
      goto while_break;
    }
#line 127
    check = *(sec->lines + i);
#line 128
    if (! ((int )check->flags & 4)) {
#line 129
      goto __Cont;
    }
#line 131
    P_LineOpening(check);
#line 133
    if (openrange <= 0) {
#line 134
      goto __Cont;
    }
#line 136
    if ((unsigned long )(sides + check->sidenum[0])->sector == (unsigned long )sec) {
#line 137
      other = (sides + check->sidenum[1])->sector;
    } else {
#line 139
      other = (sides + check->sidenum[0])->sector;
    }
#line 141
    if ((int )check->flags & 64) {
#line 143
      if (! soundblocks) {
#line 144
        P_RecursiveSound(other, 1);
      }
    } else {
#line 147
      P_RecursiveSound(other, soundblocks);
    }
    __Cont: /* CIL Label */ 
#line 125
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 158 "p_enemy.c"
void P_NoiseAlert(mobj_t *target , mobj_t *emmiter ) 
{ 


  {
#line 163
  soundtarget = target;
#line 164
  validcount ++;
#line 165
  P_RecursiveSound((emmiter->subsector)->sector, 0);
#line 166
  return;
}
}
#line 174 "p_enemy.c"
boolean P_CheckMeleeRange(mobj_t *actor ) 
{ 
  mobj_t *pl ;
  fixed_t dist ;
  boolean tmp ;

  {
#line 179
  if (! actor->target) {
#line 180
    return ((boolean )0);
  }
#line 182
  pl = actor->target;
#line 183
  dist = P_AproxDistance(pl->x - actor->x, pl->y - actor->y);
#line 185
  if (dist >= (64 * (1 << 16) - 20 * (1 << 16)) + (pl->info)->radius) {
#line 186
    return ((boolean )0);
  }
#line 188
  tmp = P_CheckSight(actor, actor->target);
#line 188
  if (! tmp) {
#line 189
    return ((boolean )0);
  }
#line 191
  return ((boolean )1);
}
}
#line 197 "p_enemy.c"
boolean P_CheckMissileRange(mobj_t *actor ) 
{ 
  fixed_t dist ;
  boolean tmp ;
  fixed_t tmp___0 ;
  int tmp___1 ;

  {
#line 201
  tmp = P_CheckSight(actor, actor->target);
#line 201
  if (! tmp) {
#line 202
    return ((boolean )0);
  }
#line 204
  if (actor->flags & 64) {
#line 208
    actor->flags &= -65;
#line 209
    return ((boolean )1);
  }
#line 212
  if (actor->reactiontime) {
#line 213
    return ((boolean )0);
  }
#line 216
  tmp___0 = P_AproxDistance(actor->x - (actor->target)->x, actor->y - (actor->target)->y);
#line 216
  dist = tmp___0 - 64 * (1 << 16);
#line 219
  if (! (actor->info)->meleestate) {
#line 220
    dist -= 128 * (1 << 16);
  }
#line 222
  dist >>= 16;
#line 224
  if ((unsigned int )actor->type == 3U) {
#line 226
    if (dist > 896) {
#line 227
      return ((boolean )0);
    }
  }
#line 231
  if ((unsigned int )actor->type == 5U) {
#line 233
    if (dist < 196) {
#line 234
      return ((boolean )0);
    }
#line 235
    dist >>= 1;
  }
#line 239
  if ((unsigned int )actor->type == 21U) {
#line 239
    goto _L___0;
  } else
#line 239
  if ((unsigned int )actor->type == 19U) {
    _L___0: /* CIL Label */ 
#line 239
    goto _L;
  } else
#line 239
  if ((unsigned int )actor->type == 18U) {
    _L: /* CIL Label */ 
#line 243
    dist >>= 1;
  }
#line 246
  if (dist > 200) {
#line 247
    dist = 200;
  }
#line 249
  if ((unsigned int )actor->type == 21U) {
#line 249
    if (dist > 160) {
#line 250
      dist = 160;
    } else {
#line 249
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 252
  tmp___1 = P_Random();
#line 252
  if (tmp___1 < dist) {
#line 253
    return ((boolean )0);
  }
#line 255
  return ((boolean )1);
}
}
#line 264 "p_enemy.c"
fixed_t xspeed[8]  = 
#line 264
  {      1 << 16,      47000,      0,      -47000, 
        - (1 << 16),      -47000,      0,      47000};
#line 265 "p_enemy.c"
fixed_t yspeed[8]  = 
#line 265
  {      0,      47000,      1 << 16,      47000, 
        0,      -47000,      - (1 << 16),      -47000};
#line 269
line_t *spechit[8] ;
#line 270
int numspechit ;
#line 272 "p_enemy.c"
boolean P_Move(mobj_t *actor ) 
{ 
  fixed_t tryx ;
  fixed_t tryy ;
  line_t *ld ;
  boolean try_ok ;
  boolean good ;
  boolean tmp ;
  int tmp___0 ;

  {
#line 284
  if (actor->movedir == 8) {
#line 285
    return ((boolean )0);
  }
#line 287
  if ((unsigned int )actor->movedir >= 8U) {
#line 288
    I_Error("Weird actor->movedir!");
  }
#line 290
  tryx = actor->x + (actor->info)->speed * xspeed[actor->movedir];
#line 291
  tryy = actor->y + (actor->info)->speed * yspeed[actor->movedir];
#line 293
  try_ok = P_TryMove(actor, tryx, tryy);
#line 295
  if (! try_ok) {
#line 298
    if (actor->flags & 16384) {
#line 298
      if (floatok) {
#line 301
        if (actor->z < tmfloorz) {
#line 302
          actor->z += (1 << 16) * 4;
        } else {
#line 304
          actor->z -= (1 << 16) * 4;
        }
#line 306
        actor->flags |= 2097152;
#line 307
        return ((boolean )1);
      } else {
#line 298
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 310
    if (! numspechit) {
#line 311
      return ((boolean )0);
    }
#line 313
    actor->movedir = 8;
#line 314
    good = (boolean )0;
    {
#line 315
    while (1) {
      while_continue: /* CIL Label */ ;
#line 315
      tmp___0 = numspechit;
#line 315
      numspechit --;
#line 315
      if (! tmp___0) {
#line 315
        goto while_break;
      }
#line 317
      ld = spechit[numspechit];
#line 321
      tmp = P_UseSpecialLine(actor, ld, 0);
#line 321
      if (tmp) {
#line 322
        good = (boolean )1;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 324
    return (good);
  } else {
#line 328
    actor->flags &= -2097153;
  }
#line 332
  if (! (actor->flags & 16384)) {
#line 333
    actor->z = actor->floorz;
  }
#line 334
  return ((boolean )1);
}
}
#line 349 "p_enemy.c"
boolean P_TryWalk(mobj_t *actor ) 
{ 
  boolean tmp ;
  int tmp___0 ;

  {
#line 351
  tmp = P_Move(actor);
#line 351
  if (! tmp) {
#line 353
    return ((boolean )0);
  }
#line 356
  tmp___0 = P_Random();
#line 356
  actor->movecount = tmp___0 & 15;
#line 357
  return ((boolean )1);
}
}
#line 363 "p_enemy.c"
void P_NewChaseDir(mobj_t *actor ) 
{ 
  fixed_t deltax ;
  fixed_t deltay ;
  dirtype_t d[3] ;
  int tdir ;
  dirtype_t olddir ;
  dirtype_t turnaround ;
  boolean tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  boolean tmp___3 ;
  boolean tmp___4 ;
  boolean tmp___5 ;
  boolean tmp___6 ;
  boolean tmp___7 ;
  int tmp___8 ;
  boolean tmp___9 ;

  {
#line 375
  if (! actor->target) {
#line 376
    I_Error("P_NewChaseDir: called with no target");
  }
#line 378
  olddir = (dirtype_t )actor->movedir;
#line 379
  turnaround = opposite[olddir];
#line 381
  deltax = (actor->target)->x - actor->x;
#line 382
  deltay = (actor->target)->y - actor->y;
#line 384
  if (deltax > 10 * (1 << 16)) {
#line 385
    d[1] = (dirtype_t )0;
  } else
#line 386
  if (deltax < -10 * (1 << 16)) {
#line 387
    d[1] = (dirtype_t )4;
  } else {
#line 389
    d[1] = (dirtype_t )8;
  }
#line 391
  if (deltay < -10 * (1 << 16)) {
#line 392
    d[2] = (dirtype_t )6;
  } else
#line 393
  if (deltay > 10 * (1 << 16)) {
#line 394
    d[2] = (dirtype_t )2;
  } else {
#line 396
    d[2] = (dirtype_t )8;
  }
#line 399
  if ((unsigned int )d[1] != 8U) {
#line 399
    if ((unsigned int )d[2] != 8U) {
#line 402
      actor->movedir = (int )diags[((deltay < 0) << 1) + (deltax > 0)];
#line 403
      if ((unsigned int )actor->movedir != (unsigned int )turnaround) {
#line 403
        tmp = P_TryWalk(actor);
#line 403
        if (tmp) {
#line 404
          return;
        } else {
#line 403
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
    } else {
#line 399
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 408
  tmp___0 = P_Random();
#line 408
  if (tmp___0 > 200) {
#line 408
    goto _L___1;
  } else {
#line 408
    tmp___1 = abs(deltay);
#line 408
    tmp___2 = abs(deltax);
#line 408
    if (tmp___1 > tmp___2) {
      _L___1: /* CIL Label */ 
#line 411
      tdir = (int )d[1];
#line 412
      d[1] = d[2];
#line 413
      d[2] = (dirtype_t )tdir;
    }
  }
#line 416
  if ((unsigned int )d[1] == (unsigned int )turnaround) {
#line 417
    d[1] = (dirtype_t )8;
  }
#line 418
  if ((unsigned int )d[2] == (unsigned int )turnaround) {
#line 419
    d[2] = (dirtype_t )8;
  }
#line 421
  if ((unsigned int )d[1] != 8U) {
#line 423
    actor->movedir = (int )d[1];
#line 424
    tmp___3 = P_TryWalk(actor);
#line 424
    if (tmp___3) {
#line 427
      return;
    }
  }
#line 431
  if ((unsigned int )d[2] != 8U) {
#line 433
    actor->movedir = (int )d[2];
#line 435
    tmp___4 = P_TryWalk(actor);
#line 435
    if (tmp___4) {
#line 436
      return;
    }
  }
#line 441
  if ((unsigned int )olddir != 8U) {
#line 443
    actor->movedir = (int )olddir;
#line 445
    tmp___5 = P_TryWalk(actor);
#line 445
    if (tmp___5) {
#line 446
      return;
    }
  }
#line 450
  tmp___8 = P_Random();
#line 450
  if (tmp___8 & 1) {
#line 452
    tdir = 0;
    {
#line 452
    while (1) {
      while_continue: /* CIL Label */ ;
#line 452
      if (! (tdir <= 7)) {
#line 452
        goto while_break;
      }
#line 456
      if ((unsigned int )tdir != (unsigned int )turnaround) {
#line 458
        actor->movedir = tdir;
#line 460
        tmp___6 = P_TryWalk(actor);
#line 460
        if (tmp___6) {
#line 461
          return;
        }
      }
#line 452
      tdir ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 467
    tdir = 7;
    {
#line 467
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 467
      if (! (tdir != -1)) {
#line 467
        goto while_break___0;
      }
#line 471
      if ((unsigned int )tdir != (unsigned int )turnaround) {
#line 473
        actor->movedir = tdir;
#line 475
        tmp___7 = P_TryWalk(actor);
#line 475
        if (tmp___7) {
#line 476
          return;
        }
      }
#line 467
      tdir --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 481
  if ((unsigned int )turnaround != 8U) {
#line 483
    actor->movedir = (int )turnaround;
#line 484
    tmp___9 = P_TryWalk(actor);
#line 484
    if (tmp___9) {
#line 485
      return;
    }
  }
#line 488
  actor->movedir = 8;
#line 489
  return;
}
}
#line 498 "p_enemy.c"
boolean P_LookForPlayers(mobj_t *actor , boolean allaround ) 
{ 
  int c ;
  int stop ;
  player_t *player ;
  sector_t *sector ;
  angle_t an ;
  fixed_t dist ;
  int tmp ;
  boolean tmp___0 ;
  angle_t tmp___1 ;

  {
#line 510
  sector = (actor->subsector)->sector;
#line 512
  c = 0;
#line 513
  stop = (actor->lastlook - 1) & 3;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if (! playeringame[actor->lastlook]) {
#line 518
      goto __Cont;
    }
#line 520
    tmp = c;
#line 520
    c ++;
#line 520
    if (tmp == 2) {
#line 520
      goto _L;
    } else
#line 520
    if (actor->lastlook == stop) {
      _L: /* CIL Label */ 
#line 524
      return ((boolean )0);
    }
#line 527
    player = & players[actor->lastlook];
#line 529
    if (player->health <= 0) {
#line 530
      goto __Cont;
    }
#line 532
    tmp___0 = P_CheckSight(actor, player->mo);
#line 532
    if (! tmp___0) {
#line 533
      goto __Cont;
    }
#line 535
    if (! allaround) {
#line 537
      tmp___1 = R_PointToAngle2(actor->x, actor->y, (player->mo)->x, (player->mo)->y);
#line 537
      an = tmp___1 - actor->angle;
#line 543
      if (an > 1073741824U) {
#line 543
        if (an < 0xc0000000) {
#line 545
          dist = P_AproxDistance((player->mo)->x - actor->x, (player->mo)->y - actor->y);
#line 548
          if (dist > 64 * (1 << 16)) {
#line 549
            goto __Cont;
          }
        } else {
#line 543
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
    }
#line 553
    actor->target = player->mo;
#line 554
    return ((boolean )1);
    __Cont: /* CIL Label */ 
#line 515
    actor->lastlook = (actor->lastlook + 1) & 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return ((boolean )0);
}
}
#line 566 "p_enemy.c"
void A_KeenDie(mobj_t *mo ) 
{ 
  thinker_t *th ;
  mobj_t *mo2 ;
  line_t junk ;

  {
#line 572
  A_Fall(mo);
#line 576
  th = thinkercap.next;
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! ((unsigned long )th != (unsigned long )(& thinkercap))) {
#line 576
      goto while_break;
    }
#line 578
    if ((unsigned long )th->function.acp1 != (unsigned long )((void (*)(void * ))(& P_MobjThinker))) {
#line 579
      goto __Cont;
    }
#line 581
    mo2 = (mobj_t *)th;
#line 582
    if ((unsigned long )mo2 != (unsigned long )mo) {
#line 582
      if ((unsigned int )mo2->type == (unsigned int )mo->type) {
#line 582
        if (mo2->health > 0) {
#line 587
          return;
        } else {
#line 582
          goto _L___0;
        }
      } else {
#line 582
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 576
    th = th->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 591
  junk.tag = (short)666;
#line 592
  EV_DoDoor(& junk, (vldoor_e )3);
#line 593
  return;
}
}
#line 604 "p_enemy.c"
void A_Look(mobj_t *actor ) 
{ 
  mobj_t *targ ;
  boolean tmp ;
  boolean tmp___0 ;
  int sound ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 608
  actor->threshold = 0;
#line 609
  targ = ((actor->subsector)->sector)->soundtarget;
#line 611
  if (targ) {
#line 611
    if (targ->flags & 4) {
#line 614
      actor->target = targ;
#line 616
      if (actor->flags & 32) {
#line 618
        tmp = P_CheckSight(actor, actor->target);
#line 618
        if (tmp) {
#line 619
          goto seeyou;
        }
      } else {
#line 622
        goto seeyou;
      }
    } else {
#line 611
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 626
  tmp___0 = P_LookForPlayers(actor, (boolean )0);
#line 626
  if (! tmp___0) {
#line 627
    return;
  }
  seeyou: 
#line 631
  if ((actor->info)->seesound) {
    {
#line 639
    if ((actor->info)->seesound == 38) {
#line 639
      goto case_38;
    }
#line 639
    if ((actor->info)->seesound == 37) {
#line 639
      goto case_38;
    }
#line 639
    if ((actor->info)->seesound == 36) {
#line 639
      goto case_38;
    }
#line 644
    if ((actor->info)->seesound == 40) {
#line 644
      goto case_40;
    }
#line 644
    if ((actor->info)->seesound == 39) {
#line 644
      goto case_40;
    }
#line 648
    goto switch_default;
    case_38: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 640
    tmp___1 = P_Random();
#line 640
    sound = 36 + tmp___1 % 3;
#line 641
    goto switch_break;
    case_40: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 645
    tmp___2 = P_Random();
#line 645
    sound = 39 + tmp___2 % 2;
#line 646
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 649
    sound = (actor->info)->seesound;
#line 650
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 653
    if ((unsigned int )actor->type == 19U) {
#line 653
      goto _L___0;
    } else
#line 653
    if ((unsigned int )actor->type == 21U) {
      _L___0: /* CIL Label */ 
#line 657
      S_StartSound((void *)0, sound);
    } else {
#line 660
      S_StartSound((void *)actor, sound);
    }
  }
#line 663
  P_SetMobjState(actor, (statenum_t )(actor->info)->seestate);
#line 664
  return;
}
}
#line 672 "p_enemy.c"
void A_Chase(mobj_t *actor ) 
{ 
  int delta ;
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;
  boolean tmp___3 ;
  boolean tmp___4 ;
  int tmp___5 ;

  {
#line 676
  if (actor->reactiontime) {
#line 677
    (actor->reactiontime) --;
  }
#line 681
  if (actor->threshold) {
#line 683
    if (! actor->target) {
#line 683
      goto _L;
    } else
#line 683
    if ((actor->target)->health <= 0) {
      _L: /* CIL Label */ 
#line 686
      actor->threshold = 0;
    } else {
#line 689
      (actor->threshold) --;
    }
  }
#line 693
  if (actor->movedir < 8) {
#line 695
    actor->angle &= (unsigned int )(7 << 29);
#line 696
    delta = (int )(actor->angle - (angle_t )(actor->movedir << 29));
#line 698
    if (delta > 0) {
#line 699
      actor->angle -= 536870912U;
    } else
#line 700
    if (delta < 0) {
#line 701
      actor->angle += 536870912U;
    }
  }
#line 704
  if (! actor->target) {
#line 704
    goto _L___0;
  } else
#line 704
  if (! ((actor->target)->flags & 4)) {
    _L___0: /* CIL Label */ 
#line 708
    tmp = P_LookForPlayers(actor, (boolean )1);
#line 708
    if (tmp) {
#line 709
      return;
    }
#line 711
    P_SetMobjState(actor, (statenum_t )(actor->info)->spawnstate);
#line 712
    return;
  }
#line 716
  if (actor->flags & 128) {
#line 718
    actor->flags &= -129;
#line 719
    if ((unsigned int )gameskill != 4U) {
#line 719
      if (! fastparm) {
#line 720
        P_NewChaseDir(actor);
      } else {
#line 719
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
#line 721
    return;
  }
#line 725
  if ((actor->info)->meleestate) {
#line 725
    tmp___0 = P_CheckMeleeRange(actor);
#line 725
    if (tmp___0) {
#line 728
      if ((actor->info)->attacksound) {
#line 729
        S_StartSound((void *)actor, (actor->info)->attacksound);
      }
#line 731
      P_SetMobjState(actor, (statenum_t )(actor->info)->meleestate);
#line 732
      return;
    } else {
#line 725
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ ;
  }
#line 736
  if ((actor->info)->missilestate) {
#line 738
    if ((unsigned int )gameskill < 4U) {
#line 738
      if (! fastparm) {
#line 738
        if (actor->movecount) {
#line 741
          goto nomissile;
        } else {
#line 738
          goto _L___4;
        }
      } else {
#line 738
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
      _L___3: /* CIL Label */ ;
    }
#line 744
    tmp___1 = P_CheckMissileRange(actor);
#line 744
    if (! tmp___1) {
#line 745
      goto nomissile;
    }
#line 747
    P_SetMobjState(actor, (statenum_t )(actor->info)->missilestate);
#line 748
    actor->flags |= 128;
#line 749
    return;
  }
  nomissile: 
#line 755
  if (netgame) {
#line 755
    if (! actor->threshold) {
#line 755
      tmp___3 = P_CheckSight(actor, actor->target);
#line 755
      if (tmp___3) {
#line 755
        goto _L___6;
      } else {
#line 759
        tmp___2 = P_LookForPlayers(actor, (boolean )1);
#line 759
        if (tmp___2) {
#line 760
          return;
        }
      }
    } else {
#line 755
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
    _L___5: /* CIL Label */ ;
  }
#line 764
  (actor->movecount) --;
#line 764
  if (actor->movecount < 0) {
#line 764
    goto _L___7;
  } else {
#line 764
    tmp___4 = P_Move(actor);
#line 764
    if (! tmp___4) {
      _L___7: /* CIL Label */ 
#line 767
      P_NewChaseDir(actor);
    }
  }
#line 771
  if ((actor->info)->activesound) {
#line 771
    tmp___5 = P_Random();
#line 771
    if (tmp___5 < 3) {
#line 774
      S_StartSound((void *)actor, (actor->info)->activesound);
    } else {
#line 771
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ ;
  }
#line 776
  return;
}
}
#line 782 "p_enemy.c"
void A_FaceTarget(mobj_t *actor ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 784
  if (! actor->target) {
#line 785
    return;
  }
#line 787
  actor->flags &= -33;
#line 789
  actor->angle = R_PointToAngle2(actor->x, actor->y, (actor->target)->x, (actor->target)->y);
#line 794
  if ((actor->target)->flags & 262144) {
#line 795
    tmp = P_Random();
#line 795
    tmp___0 = P_Random();
#line 795
    actor->angle += (angle_t )((tmp - tmp___0) << 21);
  }
#line 796
  return;
}
}
#line 802 "p_enemy.c"
void A_PosAttack(mobj_t *actor ) 
{ 
  int angle ;
  int damage ;
  int slope ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 808
  if (! actor->target) {
#line 809
    return;
  }
#line 811
  A_FaceTarget(actor);
#line 812
  angle = (int )actor->angle;
#line 813
  slope = P_AimLineAttack(actor, (angle_t )angle, 2048 * (1 << 16));
#line 815
  S_StartSound((void *)actor, 1);
#line 816
  tmp = P_Random();
#line 816
  tmp___0 = P_Random();
#line 816
  angle += (tmp - tmp___0) << 20;
#line 817
  tmp___1 = P_Random();
#line 817
  damage = (tmp___1 % 5 + 1) * 3;
#line 818
  P_LineAttack(actor, (angle_t )angle, 2048 * (1 << 16), slope, damage);
#line 819
  return;
}
}
#line 821 "p_enemy.c"
void A_SPosAttack(mobj_t *actor ) 
{ 
  int i ;
  int angle ;
  int bangle ;
  int damage ;
  int slope ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 829
  if (! actor->target) {
#line 830
    return;
  }
#line 832
  S_StartSound((void *)actor, 2);
#line 833
  A_FaceTarget(actor);
#line 834
  bangle = (int )actor->angle;
#line 835
  slope = P_AimLineAttack(actor, (angle_t )bangle, 2048 * (1 << 16));
#line 837
  i = 0;
  {
#line 837
  while (1) {
    while_continue: /* CIL Label */ ;
#line 837
    if (! (i < 3)) {
#line 837
      goto while_break;
    }
#line 839
    tmp = P_Random();
#line 839
    tmp___0 = P_Random();
#line 839
    angle = bangle + ((tmp - tmp___0) << 20);
#line 840
    tmp___1 = P_Random();
#line 840
    damage = (tmp___1 % 5 + 1) * 3;
#line 841
    P_LineAttack(actor, (angle_t )angle, 2048 * (1 << 16), slope, damage);
#line 837
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 843
  return;
}
}
#line 845 "p_enemy.c"
void A_CPosAttack(mobj_t *actor ) 
{ 
  int angle ;
  int bangle ;
  int damage ;
  int slope ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 852
  if (! actor->target) {
#line 853
    return;
  }
#line 855
  S_StartSound((void *)actor, 2);
#line 856
  A_FaceTarget(actor);
#line 857
  bangle = (int )actor->angle;
#line 858
  slope = P_AimLineAttack(actor, (angle_t )bangle, 2048 * (1 << 16));
#line 860
  tmp = P_Random();
#line 860
  tmp___0 = P_Random();
#line 860
  angle = bangle + ((tmp - tmp___0) << 20);
#line 861
  tmp___1 = P_Random();
#line 861
  damage = (tmp___1 % 5 + 1) * 3;
#line 862
  P_LineAttack(actor, (angle_t )angle, 2048 * (1 << 16), slope, damage);
#line 863
  return;
}
}
#line 865 "p_enemy.c"
void A_CPosRefire(mobj_t *actor ) 
{ 
  int tmp ;
  boolean tmp___0 ;

  {
#line 868
  A_FaceTarget(actor);
#line 870
  tmp = P_Random();
#line 870
  if (tmp < 40) {
#line 871
    return;
  }
#line 873
  if (! actor->target) {
#line 873
    goto _L___0;
  } else
#line 873
  if ((actor->target)->health <= 0) {
    _L___0: /* CIL Label */ 
#line 873
    goto _L;
  } else {
#line 873
    tmp___0 = P_CheckSight(actor, actor->target);
#line 873
    if (! tmp___0) {
      _L: /* CIL Label */ 
#line 877
      P_SetMobjState(actor, (statenum_t )(actor->info)->seestate);
    }
  }
#line 879
  return;
}
}
#line 882 "p_enemy.c"
void A_SpidRefire(mobj_t *actor ) 
{ 
  int tmp ;
  boolean tmp___0 ;

  {
#line 885
  A_FaceTarget(actor);
#line 887
  tmp = P_Random();
#line 887
  if (tmp < 10) {
#line 888
    return;
  }
#line 890
  if (! actor->target) {
#line 890
    goto _L___0;
  } else
#line 890
  if ((actor->target)->health <= 0) {
    _L___0: /* CIL Label */ 
#line 890
    goto _L;
  } else {
#line 890
    tmp___0 = P_CheckSight(actor, actor->target);
#line 890
    if (! tmp___0) {
      _L: /* CIL Label */ 
#line 894
      P_SetMobjState(actor, (statenum_t )(actor->info)->seestate);
    }
  }
#line 896
  return;
}
}
#line 898 "p_enemy.c"
void A_BspiAttack(mobj_t *actor ) 
{ 


  {
#line 900
  if (! actor->target) {
#line 901
    return;
  }
#line 903
  A_FaceTarget(actor);
#line 906
  P_SpawnMissile(actor, actor->target, (mobjtype_t )36);
#line 907
  return;
}
}
#line 913 "p_enemy.c"
void A_TroopAttack(mobj_t *actor ) 
{ 
  int damage ;
  int tmp ;
  boolean tmp___0 ;

  {
#line 917
  if (! actor->target) {
#line 918
    return;
  }
#line 920
  A_FaceTarget(actor);
#line 921
  tmp___0 = P_CheckMeleeRange(actor);
#line 921
  if (tmp___0) {
#line 923
    S_StartSound((void *)actor, 55);
#line 924
    tmp = P_Random();
#line 924
    damage = (tmp % 8 + 1) * 3;
#line 925
    P_DamageMobj(actor->target, actor, actor, damage);
#line 926
    return;
  }
#line 931
  P_SpawnMissile(actor, actor->target, (mobjtype_t )31);
#line 932
  return;
}
}
#line 935 "p_enemy.c"
void A_SargAttack(mobj_t *actor ) 
{ 
  int damage ;
  int tmp ;
  boolean tmp___0 ;

  {
#line 939
  if (! actor->target) {
#line 940
    return;
  }
#line 942
  A_FaceTarget(actor);
#line 943
  tmp___0 = P_CheckMeleeRange(actor);
#line 943
  if (tmp___0) {
#line 945
    tmp = P_Random();
#line 945
    damage = (tmp % 10 + 1) * 4;
#line 946
    P_DamageMobj(actor->target, actor, actor, damage);
  }
#line 948
  return;
}
}
#line 950 "p_enemy.c"
void A_HeadAttack(mobj_t *actor ) 
{ 
  int damage ;
  int tmp ;
  boolean tmp___0 ;

  {
#line 954
  if (! actor->target) {
#line 955
    return;
  }
#line 957
  A_FaceTarget(actor);
#line 958
  tmp___0 = P_CheckMeleeRange(actor);
#line 958
  if (tmp___0) {
#line 960
    tmp = P_Random();
#line 960
    damage = (tmp % 6 + 1) * 10;
#line 961
    P_DamageMobj(actor->target, actor, actor, damage);
#line 962
    return;
  }
#line 966
  P_SpawnMissile(actor, actor->target, (mobjtype_t )32);
#line 967
  return;
}
}
#line 969 "p_enemy.c"
void A_CyberAttack(mobj_t *actor ) 
{ 


  {
#line 971
  if (! actor->target) {
#line 972
    return;
  }
#line 974
  A_FaceTarget(actor);
#line 975
  P_SpawnMissile(actor, actor->target, (mobjtype_t )33);
#line 976
  return;
}
}
#line 979 "p_enemy.c"
void A_BruisAttack(mobj_t *actor ) 
{ 
  int damage ;
  int tmp ;
  boolean tmp___0 ;

  {
#line 983
  if (! actor->target) {
#line 984
    return;
  }
#line 986
  tmp___0 = P_CheckMeleeRange(actor);
#line 986
  if (tmp___0) {
#line 988
    S_StartSound((void *)actor, 55);
#line 989
    tmp = P_Random();
#line 989
    damage = (tmp % 8 + 1) * 10;
#line 990
    P_DamageMobj(actor->target, actor, actor, damage);
#line 991
    return;
  }
#line 995
  P_SpawnMissile(actor, actor->target, (mobjtype_t )16);
#line 996
  return;
}
}
#line 1002 "p_enemy.c"
void A_SkelMissile(mobj_t *actor ) 
{ 
  mobj_t *mo ;

  {
#line 1006
  if (! actor->target) {
#line 1007
    return;
  }
#line 1009
  A_FaceTarget(actor);
#line 1010
  actor->z += 16 * (1 << 16);
#line 1011
  mo = P_SpawnMissile(actor, actor->target, (mobjtype_t )6);
#line 1012
  actor->z -= 16 * (1 << 16);
#line 1014
  mo->x += mo->momx;
#line 1015
  mo->y += mo->momy;
#line 1016
  mo->tracer = actor->target;
#line 1017
  return;
}
}
#line 1019 "p_enemy.c"
int TRACEANGLE  =    0xc000000;
#line 1021 "p_enemy.c"
void A_Tracer(mobj_t *actor ) 
{ 
  angle_t exact ;
  fixed_t dist ;
  fixed_t slope ;
  mobj_t *dest ;
  mobj_t *th ;
  int tmp ;

  {
#line 1029
  if (gametic & 3) {
#line 1030
    return;
  }
#line 1033
  P_SpawnPuff(actor->x, actor->y, actor->z);
#line 1035
  th = P_SpawnMobj(actor->x - actor->momx, actor->y - actor->momy, actor->z, (mobjtype_t )7);
#line 1039
  th->momz = 1 << 16;
#line 1040
  tmp = P_Random();
#line 1040
  th->tics -= tmp & 3;
#line 1041
  if (th->tics < 1) {
#line 1042
    th->tics = 1;
  }
#line 1045
  dest = actor->tracer;
#line 1047
  if (! dest) {
#line 1047
    goto _L;
  } else
#line 1047
  if (dest->health <= 0) {
    _L: /* CIL Label */ 
#line 1048
    return;
  }
#line 1051
  exact = R_PointToAngle2(actor->x, actor->y, dest->x, dest->y);
#line 1056
  if (exact != actor->angle) {
#line 1058
    if (exact - actor->angle > 0x80000000) {
#line 1060
      actor->angle -= (angle_t )TRACEANGLE;
#line 1061
      if (exact - actor->angle < 0x80000000) {
#line 1062
        actor->angle = exact;
      }
    } else {
#line 1066
      actor->angle += (angle_t )TRACEANGLE;
#line 1067
      if (exact - actor->angle > 0x80000000) {
#line 1068
        actor->angle = exact;
      }
    }
  }
#line 1072
  exact = actor->angle >> 19;
#line 1073
  actor->momx = FixedMul((actor->info)->speed, *(finecosine + exact));
#line 1074
  actor->momy = FixedMul((actor->info)->speed, finesine[exact]);
#line 1077
  dist = P_AproxDistance(dest->x - actor->x, dest->y - actor->y);
#line 1080
  dist /= (actor->info)->speed;
#line 1082
  if (dist < 1) {
#line 1083
    dist = 1;
  }
#line 1084
  slope = ((dest->z + 40 * (1 << 16)) - actor->z) / dist;
#line 1086
  if (slope < actor->momz) {
#line 1087
    actor->momz -= (1 << 16) / 8;
  } else {
#line 1089
    actor->momz += (1 << 16) / 8;
  }
#line 1090
  return;
}
}
#line 1093 "p_enemy.c"
void A_SkelWhoosh(mobj_t *actor ) 
{ 


  {
#line 1095
  if (! actor->target) {
#line 1096
    return;
  }
#line 1097
  A_FaceTarget(actor);
#line 1098
  S_StartSound((void *)actor, 56);
#line 1099
  return;
}
}
#line 1101 "p_enemy.c"
void A_SkelFist(mobj_t *actor ) 
{ 
  int damage ;
  int tmp ;
  boolean tmp___0 ;

  {
#line 1105
  if (! actor->target) {
#line 1106
    return;
  }
#line 1108
  A_FaceTarget(actor);
#line 1110
  tmp___0 = P_CheckMeleeRange(actor);
#line 1110
  if (tmp___0) {
#line 1112
    tmp = P_Random();
#line 1112
    damage = (tmp % 10 + 1) * 6;
#line 1113
    S_StartSound((void *)actor, 53);
#line 1114
    P_DamageMobj(actor->target, actor, actor, damage);
  }
#line 1116
  return;
}
}
#line 1124 "p_enemy.c"
mobj_t *corpsehit  ;
#line 1125 "p_enemy.c"
mobj_t *vileobj  ;
#line 1126 "p_enemy.c"
fixed_t viletryx  ;
#line 1127 "p_enemy.c"
fixed_t viletryy  ;
#line 1129 "p_enemy.c"
boolean PIT_VileCheck(mobj_t *thing ) 
{ 
  int maxdist ;
  boolean check ;
  int tmp ;
  int tmp___0 ;
  fixed_t tmp___1 ;

  {
#line 1134
  if (! (thing->flags & 1048576)) {
#line 1135
    return ((boolean )1);
  }
#line 1137
  if (thing->tics != -1) {
#line 1138
    return ((boolean )1);
  }
#line 1140
  if ((thing->info)->raisestate == 0) {
#line 1141
    return ((boolean )1);
  }
#line 1143
  maxdist = (thing->info)->radius + mobjinfo[3].radius;
#line 1145
  tmp = abs(thing->x - viletryx);
#line 1145
  if (tmp > maxdist) {
#line 1145
    goto _L;
  } else {
#line 1145
    tmp___0 = abs(thing->y - viletryy);
#line 1145
    if (tmp___0 > maxdist) {
      _L: /* CIL Label */ 
#line 1147
      return ((boolean )1);
    }
  }
#line 1149
  corpsehit = thing;
#line 1150
  tmp___1 = 0;
#line 1150
  corpsehit->momy = tmp___1;
#line 1150
  corpsehit->momx = tmp___1;
#line 1151
  corpsehit->height <<= 2;
#line 1152
  check = P_CheckPosition(corpsehit, corpsehit->x, corpsehit->y);
#line 1153
  corpsehit->height >>= 2;
#line 1155
  if (! check) {
#line 1156
    return ((boolean )1);
  }
#line 1158
  return ((boolean )0);
}
}
#line 1167 "p_enemy.c"
void A_VileChase(mobj_t *actor ) 
{ 
  int xl ;
  int xh ;
  int yl ;
  int yh ;
  int bx ;
  int by ;
  mobjinfo_t *info___0 ;
  mobj_t *temp ;
  boolean tmp ;

  {
#line 1180
  if (actor->movedir != 8) {
#line 1183
    viletryx = actor->x + (actor->info)->speed * xspeed[actor->movedir];
#line 1185
    viletryy = actor->y + (actor->info)->speed * yspeed[actor->movedir];
#line 1188
    xl = ((viletryx - bmaporgx) - (32 * (1 << 16)) * 2) >> 23;
#line 1189
    xh = ((viletryx - bmaporgx) + (32 * (1 << 16)) * 2) >> 23;
#line 1190
    yl = ((viletryy - bmaporgy) - (32 * (1 << 16)) * 2) >> 23;
#line 1191
    yh = ((viletryy - bmaporgy) + (32 * (1 << 16)) * 2) >> 23;
#line 1193
    vileobj = actor;
#line 1194
    bx = xl;
    {
#line 1194
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1194
      if (! (bx <= xh)) {
#line 1194
        goto while_break;
      }
#line 1196
      by = yl;
      {
#line 1196
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1196
        if (! (by <= yh)) {
#line 1196
          goto while_break___0;
        }
#line 1201
        tmp = P_BlockThingsIterator(bx, by, & PIT_VileCheck);
#line 1201
        if (! tmp) {
#line 1204
          temp = actor->target;
#line 1205
          actor->target = corpsehit;
#line 1206
          A_FaceTarget(actor);
#line 1207
          actor->target = temp;
#line 1209
          P_SetMobjState(actor, (statenum_t )266);
#line 1210
          S_StartSound((void *)corpsehit, 31);
#line 1211
          info___0 = corpsehit->info;
#line 1213
          P_SetMobjState(corpsehit, (statenum_t )info___0->raisestate);
#line 1214
          corpsehit->height <<= 2;
#line 1215
          corpsehit->flags = info___0->flags;
#line 1216
          corpsehit->health = info___0->spawnhealth;
#line 1217
          corpsehit->target = (struct mobj_s *)((void *)0);
#line 1219
          return;
        }
#line 1196
        by ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1194
      bx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1226
  A_Chase(actor);
#line 1227
  return;
}
}
#line 1233 "p_enemy.c"
void A_VileStart(mobj_t *actor ) 
{ 


  {
#line 1235
  S_StartSound((void *)actor, 54);
#line 1236
  return;
}
}
#line 1243
void A_Fire(mobj_t *actor ) ;
#line 1245 "p_enemy.c"
void A_StartFire(mobj_t *actor ) 
{ 


  {
#line 1247
  S_StartSound((void *)actor, 92);
#line 1248
  A_Fire(actor);
#line 1249
  return;
}
}
#line 1251 "p_enemy.c"
void A_FireCrackle(mobj_t *actor ) 
{ 


  {
#line 1253
  S_StartSound((void *)actor, 91);
#line 1254
  A_Fire(actor);
#line 1255
  return;
}
}
#line 1257 "p_enemy.c"
void A_Fire(mobj_t *actor ) 
{ 
  mobj_t *dest ;
  unsigned int an ;
  boolean tmp ;
  fixed_t tmp___0 ;
  fixed_t tmp___1 ;

  {
#line 1262
  dest = actor->tracer;
#line 1263
  if (! dest) {
#line 1264
    return;
  }
#line 1267
  tmp = P_CheckSight(actor->target, dest);
#line 1267
  if (! tmp) {
#line 1268
    return;
  }
#line 1270
  an = dest->angle >> 19;
#line 1272
  P_UnsetThingPosition(actor);
#line 1273
  tmp___0 = FixedMul(24 * (1 << 16), *(finecosine + an));
#line 1273
  actor->x = dest->x + tmp___0;
#line 1274
  tmp___1 = FixedMul(24 * (1 << 16), finesine[an]);
#line 1274
  actor->y = dest->y + tmp___1;
#line 1275
  actor->z = dest->z;
#line 1276
  P_SetThingPosition(actor);
#line 1277
  return;
}
}
#line 1285 "p_enemy.c"
void A_VileTarget(mobj_t *actor ) 
{ 
  mobj_t *fog ;

  {
#line 1289
  if (! actor->target) {
#line 1290
    return;
  }
#line 1292
  A_FaceTarget(actor);
#line 1294
  fog = P_SpawnMobj((actor->target)->x, (actor->target)->x, (actor->target)->z, (mobjtype_t )4);
#line 1298
  actor->tracer = fog;
#line 1299
  fog->target = actor;
#line 1300
  fog->tracer = actor->target;
#line 1301
  A_Fire(fog);
#line 1302
  return;
}
}
#line 1310 "p_enemy.c"
void A_VileAttack(mobj_t *actor ) 
{ 
  mobj_t *fire ;
  int an ;
  boolean tmp ;
  fixed_t tmp___0 ;
  fixed_t tmp___1 ;

  {
#line 1315
  if (! actor->target) {
#line 1316
    return;
  }
#line 1318
  A_FaceTarget(actor);
#line 1320
  tmp = P_CheckSight(actor, actor->target);
#line 1320
  if (! tmp) {
#line 1321
    return;
  }
#line 1323
  S_StartSound((void *)actor, 82);
#line 1324
  P_DamageMobj(actor->target, actor, actor, 20);
#line 1325
  (actor->target)->momz = (1000 * (1 << 16)) / ((actor->target)->info)->mass;
#line 1327
  an = (int )(actor->angle >> 19);
#line 1329
  fire = actor->tracer;
#line 1331
  if (! fire) {
#line 1332
    return;
  }
#line 1335
  tmp___0 = FixedMul(24 * (1 << 16), *(finecosine + an));
#line 1335
  fire->x = (actor->target)->x - tmp___0;
#line 1336
  tmp___1 = FixedMul(24 * (1 << 16), finesine[an]);
#line 1336
  fire->y = (actor->target)->y - tmp___1;
#line 1337
  P_RadiusAttack(fire, actor, 70);
#line 1338
  return;
}
}
#line 1351 "p_enemy.c"
void A_FatRaise(mobj_t *actor ) 
{ 


  {
#line 1353
  A_FaceTarget(actor);
#line 1354
  S_StartSound((void *)actor, 99);
#line 1355
  return;
}
}
#line 1358 "p_enemy.c"
void A_FatAttack1(mobj_t *actor ) 
{ 
  mobj_t *mo ;
  int an ;

  {
#line 1363
  A_FaceTarget(actor);
#line 1365
  actor->angle += 134217728U;
#line 1366
  P_SpawnMissile(actor, actor->target, (mobjtype_t )9);
#line 1368
  mo = P_SpawnMissile(actor, actor->target, (mobjtype_t )9);
#line 1369
  mo->angle += 134217728U;
#line 1370
  an = (int )(mo->angle >> 19);
#line 1371
  mo->momx = FixedMul((mo->info)->speed, *(finecosine + an));
#line 1372
  mo->momy = FixedMul((mo->info)->speed, finesine[an]);
#line 1373
  return;
}
}
#line 1375 "p_enemy.c"
void A_FatAttack2(mobj_t *actor ) 
{ 
  mobj_t *mo ;
  int an ;

  {
#line 1380
  A_FaceTarget(actor);
#line 1382
  actor->angle -= 134217728U;
#line 1383
  P_SpawnMissile(actor, actor->target, (mobjtype_t )9);
#line 1385
  mo = P_SpawnMissile(actor, actor->target, (mobjtype_t )9);
#line 1386
  mo->angle -= 268435456U;
#line 1387
  an = (int )(mo->angle >> 19);
#line 1388
  mo->momx = FixedMul((mo->info)->speed, *(finecosine + an));
#line 1389
  mo->momy = FixedMul((mo->info)->speed, finesine[an]);
#line 1390
  return;
}
}
#line 1392 "p_enemy.c"
void A_FatAttack3(mobj_t *actor ) 
{ 
  mobj_t *mo ;
  int an ;

  {
#line 1397
  A_FaceTarget(actor);
#line 1399
  mo = P_SpawnMissile(actor, actor->target, (mobjtype_t )9);
#line 1400
  mo->angle -= 67108864U;
#line 1401
  an = (int )(mo->angle >> 19);
#line 1402
  mo->momx = FixedMul((mo->info)->speed, *(finecosine + an));
#line 1403
  mo->momy = FixedMul((mo->info)->speed, finesine[an]);
#line 1405
  mo = P_SpawnMissile(actor, actor->target, (mobjtype_t )9);
#line 1406
  mo->angle += 67108864U;
#line 1407
  an = (int )(mo->angle >> 19);
#line 1408
  mo->momx = FixedMul((mo->info)->speed, *(finecosine + an));
#line 1409
  mo->momy = FixedMul((mo->info)->speed, finesine[an]);
#line 1410
  return;
}
}
#line 1419 "p_enemy.c"
void A_SkullAttack(mobj_t *actor ) 
{ 
  mobj_t *dest ;
  angle_t an ;
  int dist ;

  {
#line 1425
  if (! actor->target) {
#line 1426
    return;
  }
#line 1428
  dest = actor->target;
#line 1429
  actor->flags |= 16777216;
#line 1431
  S_StartSound((void *)actor, (actor->info)->attacksound);
#line 1432
  A_FaceTarget(actor);
#line 1433
  an = actor->angle >> 19;
#line 1434
  actor->momx = FixedMul(20 * (1 << 16), *(finecosine + an));
#line 1435
  actor->momy = FixedMul(20 * (1 << 16), finesine[an]);
#line 1436
  dist = P_AproxDistance(dest->x - actor->x, dest->y - actor->y);
#line 1437
  dist /= 20 * (1 << 16);
#line 1439
  if (dist < 1) {
#line 1440
    dist = 1;
  }
#line 1441
  actor->momz = ((dest->z + (dest->height >> 1)) - actor->z) / dist;
#line 1442
  return;
}
}
#line 1449 "p_enemy.c"
void A_PainShootSkull(mobj_t *actor , angle_t angle ) 
{ 
  fixed_t x___0 ;
  fixed_t y___1 ;
  fixed_t z ;
  mobj_t *newmobj ;
  angle_t an ;
  int prestep ;
  int count ;
  thinker_t *currentthinker ;
  fixed_t tmp ;
  fixed_t tmp___0 ;
  boolean tmp___1 ;

  {
#line 1465
  count = 0;
#line 1467
  currentthinker = thinkercap.next;
  {
#line 1468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1468
    if (! ((unsigned long )currentthinker != (unsigned long )(& thinkercap))) {
#line 1468
      goto while_break;
    }
#line 1470
    if ((unsigned long )currentthinker->function.acp1 == (unsigned long )((void (*)(void * ))(& P_MobjThinker))) {
#line 1470
      if ((unsigned int )((mobj_t *)currentthinker)->type == 18U) {
#line 1472
        count ++;
      } else {
#line 1470
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 1473
    currentthinker = currentthinker->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1478
  if (count > 20) {
#line 1479
    return;
  }
#line 1483
  an = angle >> 19;
#line 1485
  prestep = 4 * (1 << 16) + (3 * ((actor->info)->radius + mobjinfo[18].radius)) / 2;
#line 1489
  tmp = FixedMul(prestep, *(finecosine + an));
#line 1489
  x___0 = actor->x + tmp;
#line 1490
  tmp___0 = FixedMul(prestep, finesine[an]);
#line 1490
  y___1 = actor->y + tmp___0;
#line 1491
  z = actor->z + 8 * (1 << 16);
#line 1493
  newmobj = P_SpawnMobj(x___0, y___1, z, (mobjtype_t )18);
#line 1496
  tmp___1 = P_TryMove(newmobj, newmobj->x, newmobj->y);
#line 1496
  if (! tmp___1) {
#line 1499
    P_DamageMobj(newmobj, actor, actor, 10000);
#line 1500
    return;
  }
#line 1503
  newmobj->target = actor->target;
#line 1504
  A_SkullAttack(newmobj);
#line 1505
  return;
}
}
#line 1512 "p_enemy.c"
void A_PainAttack(mobj_t *actor ) 
{ 


  {
#line 1514
  if (! actor->target) {
#line 1515
    return;
  }
#line 1517
  A_FaceTarget(actor);
#line 1518
  A_PainShootSkull(actor, actor->angle);
#line 1519
  return;
}
}
#line 1522 "p_enemy.c"
void A_PainDie(mobj_t *actor ) 
{ 


  {
#line 1524
  A_Fall(actor);
#line 1525
  A_PainShootSkull(actor, actor->angle + 1073741824U);
#line 1526
  A_PainShootSkull(actor, actor->angle + 0x80000000);
#line 1527
  A_PainShootSkull(actor, actor->angle + 0xc0000000);
#line 1528
  return;
}
}
#line 1535 "p_enemy.c"
void A_Scream(mobj_t *actor ) 
{ 
  int sound ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1541
  if ((actor->info)->deathsound == 0) {
#line 1541
    goto case_0;
  }
#line 1546
  if ((actor->info)->deathsound == 61) {
#line 1546
    goto case_61;
  }
#line 1546
  if ((actor->info)->deathsound == 60) {
#line 1546
    goto case_61;
  }
#line 1546
  if ((actor->info)->deathsound == 59) {
#line 1546
    goto case_61;
  }
#line 1551
  if ((actor->info)->deathsound == 63) {
#line 1551
    goto case_63;
  }
#line 1551
  if ((actor->info)->deathsound == 62) {
#line 1551
    goto case_63;
  }
#line 1555
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1542
  return;
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
#line 1547
  tmp = P_Random();
#line 1547
  sound = 59 + tmp % 3;
#line 1548
  goto switch_break;
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
#line 1552
  tmp___0 = P_Random();
#line 1552
  sound = 62 + tmp___0 % 2;
#line 1553
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1556
  sound = (actor->info)->deathsound;
#line 1557
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1561
  if ((unsigned int )actor->type == 19U) {
#line 1561
    goto _L;
  } else
#line 1561
  if ((unsigned int )actor->type == 21U) {
    _L: /* CIL Label */ 
#line 1565
    S_StartSound((void *)0, sound);
  } else {
#line 1568
    S_StartSound((void *)actor, sound);
  }
#line 1569
  return;
}
}
#line 1572 "p_enemy.c"
void A_XScream(mobj_t *actor ) 
{ 


  {
#line 1574
  S_StartSound((void *)actor, 31);
#line 1575
  return;
}
}
#line 1577 "p_enemy.c"
void A_Pain(mobj_t *actor ) 
{ 


  {
#line 1579
  if ((actor->info)->painsound) {
#line 1580
    S_StartSound((void *)actor, (actor->info)->painsound);
  }
#line 1581
  return;
}
}
#line 1585 "p_enemy.c"
void A_Fall(mobj_t *actor ) 
{ 


  {
#line 1588
  actor->flags &= -3;
#line 1592
  return;
}
}
#line 1598 "p_enemy.c"
void A_Explode(mobj_t *thingy ) 
{ 


  {
#line 1600
  P_RadiusAttack(thingy, thingy->target, 128);
#line 1601
  return;
}
}
#line 1609 "p_enemy.c"
void A_BossDeath(mobj_t *mo ) 
{ 
  thinker_t *th ;
  mobj_t *mo2 ;
  line_t junk ;
  int i ;

  {
#line 1616
  if ((unsigned int )gamemode == 2U) {
#line 1618
    if (gamemap != 7) {
#line 1619
      return;
    }
#line 1621
    if ((unsigned int )mo->type != 8U) {
#line 1621
      if ((unsigned int )mo->type != 20U) {
#line 1623
        return;
      } else {
#line 1621
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
  } else {
    {
#line 1629
    if (gameepisode == 1) {
#line 1629
      goto case_1;
    }
#line 1637
    if (gameepisode == 2) {
#line 1637
      goto case_2;
    }
#line 1645
    if (gameepisode == 3) {
#line 1645
      goto case_3;
    }
#line 1654
    if (gameepisode == 4) {
#line 1654
      goto case_4;
    }
#line 1673
    goto switch_default___0;
    case_1: /* CIL Label */ 
#line 1630
    if (gamemap != 8) {
#line 1631
      return;
    }
#line 1633
    if ((unsigned int )mo->type != 15U) {
#line 1634
      return;
    }
#line 1635
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1638
    if (gamemap != 8) {
#line 1639
      return;
    }
#line 1641
    if ((unsigned int )mo->type != 21U) {
#line 1642
      return;
    }
#line 1643
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1646
    if (gamemap != 8) {
#line 1647
      return;
    }
#line 1649
    if ((unsigned int )mo->type != 19U) {
#line 1650
      return;
    }
#line 1652
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1657
    if (gamemap == 6) {
#line 1657
      goto case_6;
    }
#line 1662
    if (gamemap == 8) {
#line 1662
      goto case_8;
    }
#line 1667
    goto switch_default;
    case_6: /* CIL Label */ 
#line 1658
    if ((unsigned int )mo->type != 21U) {
#line 1659
      return;
    }
#line 1660
    goto switch_break___0;
    case_8: /* CIL Label */ 
#line 1663
    if ((unsigned int )mo->type != 19U) {
#line 1664
      return;
    }
#line 1665
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1668
    return;
#line 1669
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1671
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 1674
    if (gamemap != 8) {
#line 1675
      return;
    }
#line 1676
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1683
  i = 0;
  {
#line 1683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1683
    if (! (i < 4)) {
#line 1683
      goto while_break;
    }
#line 1684
    if (playeringame[i]) {
#line 1684
      if (players[i].health > 0) {
#line 1685
        goto while_break;
      } else {
#line 1684
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 1683
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1687
  if (i == 4) {
#line 1688
    return;
  }
#line 1692
  th = thinkercap.next;
  {
#line 1692
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1692
    if (! ((unsigned long )th != (unsigned long )(& thinkercap))) {
#line 1692
      goto while_break___0;
    }
#line 1694
    if ((unsigned long )th->function.acp1 != (unsigned long )((void (*)(void * ))(& P_MobjThinker))) {
#line 1695
      goto __Cont;
    }
#line 1697
    mo2 = (mobj_t *)th;
#line 1698
    if ((unsigned long )mo2 != (unsigned long )mo) {
#line 1698
      if ((unsigned int )mo2->type == (unsigned int )mo->type) {
#line 1698
        if (mo2->health > 0) {
#line 1703
          return;
        } else {
#line 1698
          goto _L___2;
        }
      } else {
#line 1698
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      _L___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1692
    th = th->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1708
  if ((unsigned int )gamemode == 2U) {
#line 1710
    if (gamemap == 7) {
#line 1712
      if ((unsigned int )mo->type == 8U) {
#line 1714
        junk.tag = (short)666;
#line 1715
        EV_DoFloor(& junk, (floor_e )1);
#line 1716
        return;
      }
#line 1719
      if ((unsigned int )mo->type == 20U) {
#line 1721
        junk.tag = (short)667;
#line 1722
        EV_DoFloor(& junk, (floor_e )5);
#line 1723
        return;
      }
    }
  } else {
    {
#line 1731
    if (gameepisode == 1) {
#line 1731
      goto case_1___0;
    }
#line 1737
    if (gameepisode == 4) {
#line 1737
      goto case_4___0;
    }
#line 1729
    goto switch_break___1;
    case_1___0: /* CIL Label */ 
#line 1732
    junk.tag = (short)666;
#line 1733
    EV_DoFloor(& junk, (floor_e )1);
#line 1734
    return;
#line 1735
    goto switch_break___1;
    case_4___0: /* CIL Label */ 
    {
#line 1740
    if (gamemap == 6) {
#line 1740
      goto case_6___0;
    }
#line 1746
    if (gamemap == 8) {
#line 1746
      goto case_8___0;
    }
#line 1738
    goto switch_break___2;
    case_6___0: /* CIL Label */ 
#line 1741
    junk.tag = (short)666;
#line 1742
    EV_DoDoor(& junk, (vldoor_e )6);
#line 1743
    return;
#line 1744
    goto switch_break___2;
    case_8___0: /* CIL Label */ 
#line 1747
    junk.tag = (short)666;
#line 1748
    EV_DoFloor(& junk, (floor_e )1);
#line 1749
    return;
#line 1750
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 1755
  G_ExitLevel();
#line 1756
  return;
}
}
#line 1759 "p_enemy.c"
void A_Hoof(mobj_t *mo ) 
{ 


  {
#line 1761
  S_StartSound((void *)mo, 84);
#line 1762
  A_Chase(mo);
#line 1763
  return;
}
}
#line 1765 "p_enemy.c"
void A_Metal(mobj_t *mo ) 
{ 


  {
#line 1767
  S_StartSound((void *)mo, 85);
#line 1768
  A_Chase(mo);
#line 1769
  return;
}
}
#line 1771 "p_enemy.c"
void A_BabyMetal(mobj_t *mo ) 
{ 


  {
#line 1773
  S_StartSound((void *)mo, 79);
#line 1774
  A_Chase(mo);
#line 1775
  return;
}
}
#line 1777 "p_enemy.c"
void A_OpenShotgun2(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 1782
  S_StartSound((void *)player->mo, 5);
#line 1783
  return;
}
}
#line 1785 "p_enemy.c"
void A_LoadShotgun2(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 1790
  S_StartSound((void *)player->mo, 7);
#line 1791
  return;
}
}
#line 1793
void A_ReFire(player_t *player , pspdef_t *psp ) ;
#line 1798 "p_enemy.c"
void A_CloseShotgun2(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 1803
  S_StartSound((void *)player->mo, 6);
#line 1804
  A_ReFire(player, psp);
#line 1805
  return;
}
}
#line 1809 "p_enemy.c"
mobj_t *braintargets[32]  ;
#line 1810 "p_enemy.c"
int numbraintargets  ;
#line 1811 "p_enemy.c"
int braintargeton  ;
#line 1813 "p_enemy.c"
void A_BrainAwake(mobj_t *mo ) 
{ 
  thinker_t *thinker ;
  mobj_t *m ;

  {
#line 1819
  numbraintargets = 0;
#line 1820
  braintargeton = 0;
#line 1822
  thinker = thinkercap.next;
#line 1823
  thinker = thinkercap.next;
  {
#line 1823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1823
    if (! ((unsigned long )thinker != (unsigned long )(& thinkercap))) {
#line 1823
      goto while_break;
    }
#line 1827
    if ((unsigned long )thinker->function.acp1 != (unsigned long )((void (*)(void * ))(& P_MobjThinker))) {
#line 1828
      goto __Cont;
    }
#line 1830
    m = (mobj_t *)thinker;
#line 1832
    if ((unsigned int )m->type == 27U) {
#line 1834
      braintargets[numbraintargets] = m;
#line 1835
      numbraintargets ++;
    }
    __Cont: /* CIL Label */ 
#line 1823
    thinker = thinker->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1839
  S_StartSound((void *)0, 96);
#line 1840
  return;
}
}
#line 1843 "p_enemy.c"
void A_BrainPain(mobj_t *mo ) 
{ 


  {
#line 1845
  S_StartSound((void *)0, 97);
#line 1846
  return;
}
}
#line 1849 "p_enemy.c"
void A_BrainScream(mobj_t *mo ) 
{ 
  int x___0 ;
  int y___1 ;
  int z ;
  mobj_t *th ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1856
  x___0 = mo->x - 196 * (1 << 16);
  {
#line 1856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1856
    if (! (x___0 < mo->x + 320 * (1 << 16))) {
#line 1856
      goto while_break;
    }
#line 1858
    y___1 = mo->y - 320 * (1 << 16);
#line 1859
    tmp = P_Random();
#line 1859
    z = 128 + (tmp * 2) * (1 << 16);
#line 1860
    th = P_SpawnMobj(x___0, y___1, z, (mobjtype_t )33);
#line 1861
    tmp___0 = P_Random();
#line 1861
    th->momz = tmp___0 * 512;
#line 1863
    P_SetMobjState(th, (statenum_t )799);
#line 1865
    tmp___1 = P_Random();
#line 1865
    th->tics -= tmp___1 & 7;
#line 1866
    if (th->tics < 1) {
#line 1867
      th->tics = 1;
    }
#line 1856
    x___0 += (1 << 16) * 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 1870
  S_StartSound((void *)0, 98);
#line 1871
  return;
}
}
#line 1875 "p_enemy.c"
void A_BrainExplode(mobj_t *mo ) 
{ 
  int x___0 ;
  int y___1 ;
  int z ;
  mobj_t *th ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1882
  tmp = P_Random();
#line 1882
  tmp___0 = P_Random();
#line 1882
  x___0 = mo->x + (tmp - tmp___0) * 2048;
#line 1883
  y___1 = mo->y;
#line 1884
  tmp___1 = P_Random();
#line 1884
  z = 128 + (tmp___1 * 2) * (1 << 16);
#line 1885
  th = P_SpawnMobj(x___0, y___1, z, (mobjtype_t )33);
#line 1886
  tmp___2 = P_Random();
#line 1886
  th->momz = tmp___2 * 512;
#line 1888
  P_SetMobjState(th, (statenum_t )799);
#line 1890
  tmp___3 = P_Random();
#line 1890
  th->tics -= tmp___3 & 7;
#line 1891
  if (th->tics < 1) {
#line 1892
    th->tics = 1;
  }
#line 1893
  return;
}
}
#line 1896 "p_enemy.c"
void A_BrainDie(mobj_t *mo ) 
{ 


  {
#line 1898
  G_ExitLevel();
#line 1899
  return;
}
}
#line 1906
void A_BrainSpit(mobj_t *mo ) ;
#line 1906 "p_enemy.c"
static int easy  =    0;
#line 1901 "p_enemy.c"
void A_BrainSpit(mobj_t *mo ) 
{ 
  mobj_t *targ ;
  mobj_t *newmobj ;

  {
#line 1908
  easy ^= 1;
#line 1909
  if ((unsigned int )gameskill <= 1U) {
#line 1909
    if (! easy) {
#line 1910
      return;
    } else {
#line 1909
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 1913
  targ = braintargets[braintargeton];
#line 1914
  braintargeton = (braintargeton + 1) % numbraintargets;
#line 1917
  newmobj = P_SpawnMissile(mo, targ, (mobjtype_t )28);
#line 1918
  newmobj->target = targ;
#line 1919
  newmobj->reactiontime = (int )((long )((targ->y - mo->y) / newmobj->momy) / (newmobj->state)->tics);
#line 1922
  S_StartSound((void *)0, 94);
#line 1923
  return;
}
}
#line 1927
void A_SpawnFly(mobj_t *mo ) ;
#line 1930 "p_enemy.c"
void A_SpawnSound(mobj_t *mo ) 
{ 


  {
#line 1932
  S_StartSound((void *)mo, 95);
#line 1933
  A_SpawnFly(mo);
#line 1934
  return;
}
}
#line 1936 "p_enemy.c"
void A_SpawnFly(mobj_t *mo ) 
{ 
  mobj_t *newmobj ;
  mobj_t *fog ;
  mobj_t *targ ;
  int r ;
  mobjtype_t type ;
  boolean tmp ;

  {
#line 1944
  (mo->reactiontime) --;
#line 1944
  if (mo->reactiontime) {
#line 1945
    return;
  }
#line 1947
  targ = mo->target;
#line 1950
  fog = P_SpawnMobj(targ->x, targ->y, targ->z, (mobjtype_t )29);
#line 1951
  S_StartSound((void *)fog, 35);
#line 1954
  r = P_Random();
#line 1958
  if (r < 50) {
#line 1959
    type = (mobjtype_t )11;
  } else
#line 1960
  if (r < 90) {
#line 1961
    type = (mobjtype_t )12;
  } else
#line 1962
  if (r < 120) {
#line 1963
    type = (mobjtype_t )13;
  } else
#line 1964
  if (r < 130) {
#line 1965
    type = (mobjtype_t )22;
  } else
#line 1966
  if (r < 160) {
#line 1967
    type = (mobjtype_t )14;
  } else
#line 1968
  if (r < 162) {
#line 1969
    type = (mobjtype_t )3;
  } else
#line 1970
  if (r < 172) {
#line 1971
    type = (mobjtype_t )5;
  } else
#line 1972
  if (r < 192) {
#line 1973
    type = (mobjtype_t )20;
  } else
#line 1974
  if (r < 222) {
#line 1975
    type = (mobjtype_t )8;
  } else
#line 1976
  if (r < 246) {
#line 1977
    type = (mobjtype_t )17;
  } else {
#line 1979
    type = (mobjtype_t )15;
  }
#line 1981
  newmobj = P_SpawnMobj(targ->x, targ->y, targ->z, type);
#line 1982
  tmp = P_LookForPlayers(newmobj, (boolean )1);
#line 1982
  if (tmp) {
#line 1983
    P_SetMobjState(newmobj, (statenum_t )(newmobj->info)->seestate);
  }
#line 1986
  P_TeleportMove(newmobj, newmobj->x, newmobj->y);
#line 1989
  P_RemoveMobj(mo);
#line 1990
  return;
}
}
#line 1994 "p_enemy.c"
void A_PlayerScream(mobj_t *mo ) 
{ 
  int sound ;

  {
#line 1997
  sound = 57;
#line 1999
  if ((unsigned int )gamemode == 2U) {
#line 1999
    if (mo->health < -50) {
#line 2004
      sound = 58;
    } else {
#line 1999
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 2007
  S_StartSound((void *)mo, sound);
#line 2008
  return;
}
}
#line 24 "p_floor.c"
static char const   rcsid___25[50]  = 
#line 24 "p_floor.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'f', 
        (char const   )'l',      (char const   )'o',      (char const   )'o',      (char const   )'r', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'4', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )' ', 
        (char const   )'1',      (char const   )'6',      (char const   )':',      (char const   )'4', 
        (char const   )'7',      (char const   )':',      (char const   )'5',      (char const   )'4', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 48 "p_floor.c"
result_e T_MovePlane(sector_t *sector , fixed_t speed , fixed_t dest , boolean crush ,
                     int floorOrCeiling , int direction ) 
{ 
  boolean flag___0 ;
  fixed_t lastpos ;

  {
  {
#line 62
  if (floorOrCeiling == 0) {
#line 62
    goto case_0;
  }
#line 129
  if (floorOrCeiling == 1) {
#line 129
    goto case_1___0;
  }
#line 60
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 66
  if (direction == -1) {
#line 66
    goto case_neg_1;
  }
#line 95
  if (direction == 1) {
#line 95
    goto case_1;
  }
#line 64
  goto switch_break___0;
  case_neg_1: /* CIL Label */ 
#line 68
  if (sector->floorheight - speed < dest) {
#line 70
    lastpos = sector->floorheight;
#line 71
    sector->floorheight = dest;
#line 72
    flag___0 = P_ChangeSector(sector, crush);
#line 73
    if ((unsigned int )flag___0 == 1U) {
#line 75
      sector->floorheight = lastpos;
#line 76
      P_ChangeSector(sector, crush);
    }
#line 79
    return ((result_e )2);
  } else {
#line 83
    lastpos = sector->floorheight;
#line 84
    sector->floorheight -= speed;
#line 85
    flag___0 = P_ChangeSector(sector, crush);
#line 86
    if ((unsigned int )flag___0 == 1U) {
#line 88
      sector->floorheight = lastpos;
#line 89
      P_ChangeSector(sector, crush);
#line 90
      return ((result_e )1);
    }
  }
#line 93
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 97
  if (sector->floorheight + speed > dest) {
#line 99
    lastpos = sector->floorheight;
#line 100
    sector->floorheight = dest;
#line 101
    flag___0 = P_ChangeSector(sector, crush);
#line 102
    if ((unsigned int )flag___0 == 1U) {
#line 104
      sector->floorheight = lastpos;
#line 105
      P_ChangeSector(sector, crush);
    }
#line 108
    return ((result_e )2);
  } else {
#line 113
    lastpos = sector->floorheight;
#line 114
    sector->floorheight += speed;
#line 115
    flag___0 = P_ChangeSector(sector, crush);
#line 116
    if ((unsigned int )flag___0 == 1U) {
#line 118
      if ((unsigned int )crush == 1U) {
#line 119
        return ((result_e )1);
      }
#line 120
      sector->floorheight = lastpos;
#line 121
      P_ChangeSector(sector, crush);
#line 122
      return ((result_e )1);
    }
  }
#line 125
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 127
  goto switch_break;
  case_1___0: /* CIL Label */ 
  {
#line 133
  if (direction == -1) {
#line 133
    goto case_neg_1___0;
  }
#line 167
  if (direction == 1) {
#line 167
    goto case_1___1;
  }
#line 131
  goto switch_break___1;
  case_neg_1___0: /* CIL Label */ 
#line 135
  if (sector->ceilingheight - speed < dest) {
#line 137
    lastpos = sector->ceilingheight;
#line 138
    sector->ceilingheight = dest;
#line 139
    flag___0 = P_ChangeSector(sector, crush);
#line 141
    if ((unsigned int )flag___0 == 1U) {
#line 143
      sector->ceilingheight = lastpos;
#line 144
      P_ChangeSector(sector, crush);
    }
#line 147
    return ((result_e )2);
  } else {
#line 152
    lastpos = sector->ceilingheight;
#line 153
    sector->ceilingheight -= speed;
#line 154
    flag___0 = P_ChangeSector(sector, crush);
#line 156
    if ((unsigned int )flag___0 == 1U) {
#line 158
      if ((unsigned int )crush == 1U) {
#line 159
        return ((result_e )1);
      }
#line 160
      sector->ceilingheight = lastpos;
#line 161
      P_ChangeSector(sector, crush);
#line 162
      return ((result_e )1);
    }
  }
#line 165
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 169
  if (sector->ceilingheight + speed > dest) {
#line 171
    lastpos = sector->ceilingheight;
#line 172
    sector->ceilingheight = dest;
#line 173
    flag___0 = P_ChangeSector(sector, crush);
#line 174
    if ((unsigned int )flag___0 == 1U) {
#line 176
      sector->ceilingheight = lastpos;
#line 177
      P_ChangeSector(sector, crush);
    }
#line 180
    return ((result_e )2);
  } else {
#line 184
    lastpos = sector->ceilingheight;
#line 185
    sector->ceilingheight += speed;
#line 186
    flag___0 = P_ChangeSector(sector, crush);
  }
#line 197
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 199
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 202
  return ((result_e )0);
}
}
#line 209 "p_floor.c"
void T_MoveFloor(floormove_t *floor___0 ) 
{ 
  result_e res ;

  {
#line 213
  res = T_MovePlane(floor___0->sector, floor___0->speed, floor___0->floordestheight,
                    floor___0->crush, 0, floor___0->direction);
#line 218
  if (! (leveltime & 7)) {
#line 219
    S_StartSound((void *)((mobj_t *)(& (floor___0->sector)->soundorg)), 22);
  }
#line 222
  if ((unsigned int )res == 2U) {
#line 224
    (floor___0->sector)->specialdata = (void *)0;
#line 226
    if (floor___0->direction == 1) {
      {
#line 230
      if ((unsigned int )floor___0->type == 11U) {
#line 230
        goto case_11;
      }
#line 233
      goto switch_default;
      case_11: /* CIL Label */ 
#line 231
      (floor___0->sector)->special = (short )floor___0->newspecial;
#line 232
      (floor___0->sector)->floorpic = floor___0->texture;
      switch_default: /* CIL Label */ 
#line 234
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 237
    if (floor___0->direction == -1) {
      {
#line 241
      if ((unsigned int )floor___0->type == 6U) {
#line 241
        goto case_6;
      }
#line 244
      goto switch_default___0;
      case_6: /* CIL Label */ 
#line 242
      (floor___0->sector)->special = (short )floor___0->newspecial;
#line 243
      (floor___0->sector)->floorpic = floor___0->texture;
      switch_default___0: /* CIL Label */ 
#line 245
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 248
    P_RemoveThinker(& floor___0->thinker);
#line 250
    S_StartSound((void *)((mobj_t *)(& (floor___0->sector)->soundorg)), 19);
  }
#line 254
  return;
}
}
#line 259 "p_floor.c"
int EV_DoFloor(line_t *line , floor_e floortype ) 
{ 
  int secnum ;
  int rtn ;
  int i ;
  sector_t *sec ;
  floormove_t *floor___0 ;
  void *tmp ;
  int minsize ;
  side_t *side ;
  int tmp___0 ;
  side_t *tmp___1 ;
  int tmp___2 ;

  {
#line 270
  secnum = -1;
#line 271
  rtn = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    secnum = P_FindSectorFromLineTag(line, secnum);
#line 272
    if (! (secnum >= 0)) {
#line 272
      goto while_break;
    }
#line 274
    sec = sectors + secnum;
#line 277
    if (sec->specialdata) {
#line 278
      goto while_continue;
    }
#line 281
    rtn = 1;
#line 282
    tmp = Z_Malloc((int )sizeof(*floor___0), 51, (void *)0);
#line 282
    floor___0 = (floormove_t *)tmp;
#line 283
    P_AddThinker(& floor___0->thinker);
#line 284
    sec->specialdata = (void *)floor___0;
#line 285
    floor___0->thinker.function.acp1 = (void (*)(void * ))(& T_MoveFloor);
#line 286
    floor___0->type = floortype;
#line 287
    floor___0->crush = (boolean )0;
    {
#line 291
    if ((unsigned int )floortype == 0U) {
#line 291
      goto case_0;
    }
#line 299
    if ((unsigned int )floortype == 1U) {
#line 299
      goto case_1;
    }
#line 307
    if ((unsigned int )floortype == 2U) {
#line 307
      goto case_2;
    }
#line 317
    if ((unsigned int )floortype == 9U) {
#line 317
      goto case_9;
    }
#line 319
    if ((unsigned int )floortype == 3U) {
#line 319
      goto case_3;
    }
#line 331
    if ((unsigned int )floortype == 10U) {
#line 331
      goto case_10;
    }
#line 339
    if ((unsigned int )floortype == 4U) {
#line 339
      goto case_4;
    }
#line 347
    if ((unsigned int )floortype == 7U) {
#line 347
      goto case_7;
    }
#line 354
    if ((unsigned int )floortype == 12U) {
#line 354
      goto case_12;
    }
#line 362
    if ((unsigned int )floortype == 8U) {
#line 362
      goto case_8;
    }
#line 372
    if ((unsigned int )floortype == 5U) {
#line 372
      goto case_5;
    }
#line 403
    if ((unsigned int )floortype == 6U) {
#line 403
      goto case_6;
    }
#line 439
    goto switch_default;
    case_0: /* CIL Label */ 
#line 292
    floor___0->direction = -1;
#line 293
    floor___0->sector = sec;
#line 294
    floor___0->speed = 1 << 16;
#line 295
    floor___0->floordestheight = P_FindHighestFloorSurrounding(sec);
#line 297
    goto switch_break;
    case_1: /* CIL Label */ 
#line 300
    floor___0->direction = -1;
#line 301
    floor___0->sector = sec;
#line 302
    floor___0->speed = 1 << 16;
#line 303
    floor___0->floordestheight = P_FindLowestFloorSurrounding(sec);
#line 305
    goto switch_break;
    case_2: /* CIL Label */ 
#line 308
    floor___0->direction = -1;
#line 309
    floor___0->sector = sec;
#line 310
    floor___0->speed = (1 << 16) * 4;
#line 311
    floor___0->floordestheight = P_FindHighestFloorSurrounding(sec);
#line 313
    if (floor___0->floordestheight != sec->floorheight) {
#line 314
      floor___0->floordestheight += 8 * (1 << 16);
    }
#line 315
    goto switch_break;
    case_9: /* CIL Label */ 
#line 318
    floor___0->crush = (boolean )1;
    case_3: /* CIL Label */ 
#line 320
    floor___0->direction = 1;
#line 321
    floor___0->sector = sec;
#line 322
    floor___0->speed = 1 << 16;
#line 323
    floor___0->floordestheight = P_FindLowestCeilingSurrounding(sec);
#line 325
    if (floor___0->floordestheight > sec->ceilingheight) {
#line 326
      floor___0->floordestheight = sec->ceilingheight;
    }
#line 327
    floor___0->floordestheight -= (8 * (1 << 16)) * ((unsigned int )floortype == 9U);
#line 329
    goto switch_break;
    case_10: /* CIL Label */ 
#line 332
    floor___0->direction = 1;
#line 333
    floor___0->sector = sec;
#line 334
    floor___0->speed = (1 << 16) * 4;
#line 335
    floor___0->floordestheight = P_FindNextHighestFloor(sec, sec->floorheight);
#line 337
    goto switch_break;
    case_4: /* CIL Label */ 
#line 340
    floor___0->direction = 1;
#line 341
    floor___0->sector = sec;
#line 342
    floor___0->speed = 1 << 16;
#line 343
    floor___0->floordestheight = P_FindNextHighestFloor(sec, sec->floorheight);
#line 345
    goto switch_break;
    case_7: /* CIL Label */ 
#line 348
    floor___0->direction = 1;
#line 349
    floor___0->sector = sec;
#line 350
    floor___0->speed = 1 << 16;
#line 351
    floor___0->floordestheight = (floor___0->sector)->floorheight + 24 * (1 << 16);
#line 353
    goto switch_break;
    case_12: /* CIL Label */ 
#line 355
    floor___0->direction = 1;
#line 356
    floor___0->sector = sec;
#line 357
    floor___0->speed = 1 << 16;
#line 358
    floor___0->floordestheight = (floor___0->sector)->floorheight + 512 * (1 << 16);
#line 360
    goto switch_break;
    case_8: /* CIL Label */ 
#line 363
    floor___0->direction = 1;
#line 364
    floor___0->sector = sec;
#line 365
    floor___0->speed = 1 << 16;
#line 366
    floor___0->floordestheight = (floor___0->sector)->floorheight + 24 * (1 << 16);
#line 368
    sec->floorpic = (line->frontsector)->floorpic;
#line 369
    sec->special = (line->frontsector)->special;
#line 370
    goto switch_break;
    case_5: /* CIL Label */ 
#line 374
    minsize = 0x7fffffff;
#line 377
    floor___0->direction = 1;
#line 378
    floor___0->sector = sec;
#line 379
    floor___0->speed = 1 << 16;
#line 380
    i = 0;
    {
#line 380
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 380
      if (! (i < sec->linecount)) {
#line 380
        goto while_break___0;
      }
#line 382
      tmp___0 = twoSided(secnum, i);
#line 382
      if (tmp___0) {
#line 384
        side = getSide(secnum, i, 0);
#line 385
        if ((int )side->bottomtexture >= 0) {
#line 386
          if (*(textureheight + side->bottomtexture) < minsize) {
#line 388
            minsize = *(textureheight + side->bottomtexture);
          }
        }
#line 390
        side = getSide(secnum, i, 1);
#line 391
        if ((int )side->bottomtexture >= 0) {
#line 392
          if (*(textureheight + side->bottomtexture) < minsize) {
#line 394
            minsize = *(textureheight + side->bottomtexture);
          }
        }
      }
#line 380
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 398
    floor___0->floordestheight = (floor___0->sector)->floorheight + minsize;
#line 401
    goto switch_break;
    case_6: /* CIL Label */ 
#line 404
    floor___0->direction = -1;
#line 405
    floor___0->sector = sec;
#line 406
    floor___0->speed = 1 << 16;
#line 407
    floor___0->floordestheight = P_FindLowestFloorSurrounding(sec);
#line 409
    floor___0->texture = sec->floorpic;
#line 411
    i = 0;
    {
#line 411
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 411
      if (! (i < sec->linecount)) {
#line 411
        goto while_break___1;
      }
#line 413
      tmp___2 = twoSided(secnum, i);
#line 413
      if (tmp___2) {
#line 415
        tmp___1 = getSide(secnum, i, 0);
#line 415
        if (tmp___1->sector - sectors == (long )secnum) {
#line 417
          sec = getSector(secnum, i, 1);
#line 419
          if (sec->floorheight == floor___0->floordestheight) {
#line 421
            floor___0->texture = sec->floorpic;
#line 422
            floor___0->newspecial = (int )sec->special;
#line 423
            goto while_break___1;
          }
        } else {
#line 428
          sec = getSector(secnum, i, 0);
#line 430
          if (sec->floorheight == floor___0->floordestheight) {
#line 432
            floor___0->texture = sec->floorpic;
#line 433
            floor___0->newspecial = (int )sec->special;
#line 434
            goto while_break___1;
          }
        }
      }
#line 411
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    switch_default: /* CIL Label */ 
#line 440
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  return (rtn);
}
}
#line 452 "p_floor.c"
int EV_BuildStairs(line_t *line , stair_e type ) 
{ 
  int secnum ;
  int height ;
  int i ;
  int newsecnum ;
  int texture ;
  int ok___0 ;
  int rtn ;
  sector_t *sec ;
  sector_t *tsec ;
  floormove_t *floor___0 ;
  fixed_t stairsize ;
  fixed_t speed ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 473
  secnum = -1;
#line 474
  rtn = 0;
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    secnum = P_FindSectorFromLineTag(line, secnum);
#line 475
    if (! (secnum >= 0)) {
#line 475
      goto while_break;
    }
#line 477
    sec = sectors + secnum;
#line 480
    if (sec->specialdata) {
#line 481
      goto while_continue;
    }
#line 484
    rtn = 1;
#line 485
    tmp = Z_Malloc((int )sizeof(*floor___0), 51, (void *)0);
#line 485
    floor___0 = (floormove_t *)tmp;
#line 486
    P_AddThinker(& floor___0->thinker);
#line 487
    sec->specialdata = (void *)floor___0;
#line 488
    floor___0->thinker.function.acp1 = (void (*)(void * ))(& T_MoveFloor);
#line 489
    floor___0->direction = 1;
#line 490
    floor___0->sector = sec;
    {
#line 493
    if ((unsigned int )type == 0U) {
#line 493
      goto case_0;
    }
#line 497
    if ((unsigned int )type == 1U) {
#line 497
      goto case_1;
    }
#line 491
    goto switch_break;
    case_0: /* CIL Label */ 
#line 494
    speed = (1 << 16) / 4;
#line 495
    stairsize = 8 * (1 << 16);
#line 496
    goto switch_break;
    case_1: /* CIL Label */ 
#line 498
    speed = (1 << 16) * 4;
#line 499
    stairsize = 16 * (1 << 16);
#line 500
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 502
    floor___0->speed = speed;
#line 503
    height = sec->floorheight + stairsize;
#line 504
    floor___0->floordestheight = height;
#line 506
    texture = (int )sec->floorpic;
    {
#line 511
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 513
      ok___0 = 0;
#line 514
      i = 0;
      {
#line 514
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 514
        if (! (i < sec->linecount)) {
#line 514
          goto while_break___1;
        }
#line 516
        if (! ((int )(*(sec->lines + i))->flags & 4)) {
#line 517
          goto __Cont;
        }
#line 519
        tsec = (*(sec->lines + i))->frontsector;
#line 520
        newsecnum = (int )(tsec - sectors);
#line 522
        if (secnum != newsecnum) {
#line 523
          goto __Cont;
        }
#line 525
        tsec = (*(sec->lines + i))->backsector;
#line 526
        newsecnum = (int )(tsec - sectors);
#line 528
        if ((int )tsec->floorpic != texture) {
#line 529
          goto __Cont;
        }
#line 531
        height += stairsize;
#line 533
        if (tsec->specialdata) {
#line 534
          goto __Cont;
        }
#line 536
        sec = tsec;
#line 537
        secnum = newsecnum;
#line 538
        tmp___0 = Z_Malloc((int )sizeof(*floor___0), 51, (void *)0);
#line 538
        floor___0 = (floormove_t *)tmp___0;
#line 540
        P_AddThinker(& floor___0->thinker);
#line 542
        sec->specialdata = (void *)floor___0;
#line 543
        floor___0->thinker.function.acp1 = (void (*)(void * ))(& T_MoveFloor);
#line 544
        floor___0->direction = 1;
#line 545
        floor___0->sector = sec;
#line 546
        floor___0->speed = speed;
#line 547
        floor___0->floordestheight = height;
#line 548
        ok___0 = 1;
#line 549
        goto while_break___1;
        __Cont: /* CIL Label */ 
#line 514
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 511
      if (! ok___0) {
#line 511
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  return (rtn);
}
}
#line 25 "p_inter.c"
static char const   rcsid___26[50]  = 
#line 25 "p_inter.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'4', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )' ', 
        (char const   )'2',      (char const   )'2',      (char const   )':',      (char const   )'4', 
        (char const   )'5',      (char const   )':',      (char const   )'1',      (char const   )'1', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 32 "p_inter.h"
boolean P_GivePower(player_t *player , int power ) ;
#line 58 "p_inter.c"
int maxammo[4]  = {      200,      50,      300,      50};
#line 59 "p_inter.c"
int clipammo[4]  = {      10,      4,      20,      1};
#line 73 "p_inter.c"
boolean P_GiveAmmo(player_t *player , ammotype_t ammo , int num___0 ) 
{ 
  int oldammo ;

  {
#line 81
  if ((unsigned int )ammo == 5U) {
#line 82
    return ((boolean )0);
  }
#line 84
  if ((unsigned int )ammo < 0U) {
#line 84
    goto _L;
  } else
#line 84
  if ((unsigned int )ammo > 4U) {
    _L: /* CIL Label */ 
#line 85
    I_Error("P_GiveAmmo: bad type %i", (unsigned int )ammo);
  }
#line 87
  if (player->ammo[ammo] == player->maxammo[ammo]) {
#line 88
    return ((boolean )0);
  }
#line 90
  if (num___0) {
#line 91
    num___0 *= clipammo[ammo];
  } else {
#line 93
    num___0 = clipammo[ammo] / 2;
  }
#line 95
  if ((unsigned int )gameskill == 0U) {
#line 95
    goto _L___0;
  } else
#line 95
  if ((unsigned int )gameskill == 4U) {
    _L___0: /* CIL Label */ 
#line 100
    num___0 <<= 1;
  }
#line 104
  oldammo = player->ammo[ammo];
#line 105
  player->ammo[ammo] += num___0;
#line 107
  if (player->ammo[ammo] > player->maxammo[ammo]) {
#line 108
    player->ammo[ammo] = player->maxammo[ammo];
  }
#line 113
  if (oldammo) {
#line 114
    return ((boolean )1);
  }
  {
#line 121
  if ((unsigned int )ammo == 0U) {
#line 121
    goto case_0;
  }
#line 131
  if ((unsigned int )ammo == 1U) {
#line 131
    goto case_1;
  }
#line 140
  if ((unsigned int )ammo == 2U) {
#line 140
    goto case_2;
  }
#line 149
  if ((unsigned int )ammo == 3U) {
#line 149
    goto case_3;
  }
#line 155
  goto switch_default;
  case_0: /* CIL Label */ 
#line 122
  if ((unsigned int )player->readyweapon == 0U) {
#line 124
    if (player->weaponowned[3]) {
#line 125
      player->pendingweapon = (weapontype_t )3;
    } else {
#line 127
      player->pendingweapon = (weapontype_t )1;
    }
  }
#line 129
  goto switch_break;
  case_1: /* CIL Label */ 
#line 132
  if ((unsigned int )player->readyweapon == 0U) {
#line 132
    goto _L___1;
  } else
#line 132
  if ((unsigned int )player->readyweapon == 1U) {
    _L___1: /* CIL Label */ 
#line 135
    if (player->weaponowned[2]) {
#line 136
      player->pendingweapon = (weapontype_t )2;
    }
  }
#line 138
  goto switch_break;
  case_2: /* CIL Label */ 
#line 141
  if ((unsigned int )player->readyweapon == 0U) {
#line 141
    goto _L___2;
  } else
#line 141
  if ((unsigned int )player->readyweapon == 1U) {
    _L___2: /* CIL Label */ 
#line 144
    if (player->weaponowned[5]) {
#line 145
      player->pendingweapon = (weapontype_t )5;
    }
  }
#line 147
  goto switch_break;
  case_3: /* CIL Label */ 
#line 150
  if ((unsigned int )player->readyweapon == 0U) {
#line 152
    if (player->weaponowned[4]) {
#line 153
      player->pendingweapon = (weapontype_t )4;
    }
  }
  switch_default: /* CIL Label */ 
#line 156
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 159
  return ((boolean )1);
}
}
#line 167 "p_inter.c"
boolean P_GiveWeapon(player_t *player , weapontype_t weapon , boolean dropped ) 
{ 
  boolean gaveammo ;
  boolean gaveweapon ;
  int tmp ;

  {
#line 176
  if (netgame) {
#line 176
    if ((unsigned int )deathmatch != 2U) {
#line 176
      if (! dropped) {
#line 181
        if (player->weaponowned[weapon]) {
#line 182
          return ((boolean )0);
        }
#line 184
        player->bonuscount += 6;
#line 185
        player->weaponowned[weapon] = (boolean )1;
#line 187
        if (deathmatch) {
#line 188
          P_GiveAmmo(player, weaponinfo[weapon].ammo, 5);
        } else {
#line 190
          P_GiveAmmo(player, weaponinfo[weapon].ammo, 2);
        }
#line 191
        player->pendingweapon = weapon;
#line 193
        if ((unsigned long )player == (unsigned long )(& players[consoleplayer])) {
#line 194
          S_StartSound((void *)0, 33);
        }
#line 195
        return ((boolean )0);
      } else {
#line 176
        goto _L___0;
      }
    } else {
#line 176
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ ;
  }
#line 198
  if ((unsigned int )weaponinfo[weapon].ammo != 5U) {
#line 202
    if (dropped) {
#line 203
      gaveammo = P_GiveAmmo(player, weaponinfo[weapon].ammo, 1);
    } else {
#line 205
      gaveammo = P_GiveAmmo(player, weaponinfo[weapon].ammo, 2);
    }
  } else {
#line 208
    gaveammo = (boolean )0;
  }
#line 210
  if (player->weaponowned[weapon]) {
#line 211
    gaveweapon = (boolean )0;
  } else {
#line 214
    gaveweapon = (boolean )1;
#line 215
    player->weaponowned[weapon] = (boolean )1;
#line 216
    player->pendingweapon = weapon;
  }
#line 219
  if (gaveweapon) {
#line 219
    goto _L___1;
  } else
#line 219
  if (gaveammo) {
    _L___1: /* CIL Label */ 
#line 219
    tmp = 1;
  } else {
#line 219
    tmp = 0;
  }
#line 219
  return ((boolean )tmp);
}
}
#line 228 "p_inter.c"
boolean P_GiveBody(player_t *player , int num___0 ) 
{ 


  {
#line 233
  if (player->health >= 100) {
#line 234
    return ((boolean )0);
  }
#line 236
  player->health += num___0;
#line 237
  if (player->health > 100) {
#line 238
    player->health = 100;
  }
#line 239
  (player->mo)->health = player->health;
#line 241
  return ((boolean )1);
}
}
#line 251 "p_inter.c"
boolean P_GiveArmor(player_t *player , int armortype ) 
{ 
  int hits ;

  {
#line 258
  hits = armortype * 100;
#line 259
  if (player->armorpoints >= hits) {
#line 260
    return ((boolean )0);
  }
#line 262
  player->armortype = armortype;
#line 263
  player->armorpoints = hits;
#line 265
  return ((boolean )1);
}
}
#line 273 "p_inter.c"
void P_GiveCard(player_t *player , card_t card ) 
{ 


  {
#line 278
  if (player->cards[card]) {
#line 279
    return;
  }
#line 281
  player->bonuscount = 6;
#line 282
  player->cards[card] = (boolean )1;
#line 283
  return;
}
}
#line 289 "p_inter.c"
boolean P_GivePower(player_t *player , int power ) 
{ 


  {
#line 294
  if (power == 0) {
#line 296
    player->powers[power] = 1050;
#line 297
    return ((boolean )1);
  }
#line 300
  if (power == 2) {
#line 302
    player->powers[power] = 2100;
#line 303
    (player->mo)->flags |= 262144;
#line 304
    return ((boolean )1);
  }
#line 307
  if (power == 5) {
#line 309
    player->powers[power] = 4200;
#line 310
    return ((boolean )1);
  }
#line 313
  if (power == 3) {
#line 315
    player->powers[power] = 2100;
#line 316
    return ((boolean )1);
  }
#line 319
  if (power == 1) {
#line 321
    P_GiveBody(player, 100);
#line 322
    player->powers[power] = 1;
#line 323
    return ((boolean )1);
  }
#line 326
  if (player->powers[power]) {
#line 327
    return ((boolean )0);
  }
#line 329
  player->powers[power] = 1;
#line 330
  return ((boolean )1);
}
}
#line 338 "p_inter.c"
void P_TouchSpecialThing(mobj_t *special , mobj_t *toucher ) 
{ 
  player_t *player ;
  int i ;
  fixed_t delta ;
  int sound ;
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;
  boolean tmp___3 ;
  boolean tmp___4 ;
  boolean tmp___5 ;
  boolean tmp___6 ;
  boolean tmp___7 ;
  boolean tmp___8 ;
  boolean tmp___9 ;
  boolean tmp___10 ;
  boolean tmp___11 ;
  boolean tmp___12 ;
  boolean tmp___13 ;
  boolean tmp___14 ;
  boolean tmp___15 ;
  boolean tmp___16 ;
  boolean tmp___17 ;
  boolean tmp___18 ;
  boolean tmp___19 ;
  boolean tmp___20 ;
  boolean tmp___21 ;
  boolean tmp___22 ;
  boolean tmp___23 ;
  boolean tmp___24 ;

  {
#line 348
  delta = special->z - toucher->z;
#line 350
  if (delta > toucher->height) {
#line 350
    goto _L;
  } else
#line 350
  if (delta < -8 * (1 << 16)) {
    _L: /* CIL Label */ 
#line 354
    return;
  }
#line 358
  sound = 32;
#line 359
  player = toucher->player;
#line 363
  if (toucher->health <= 0) {
#line 364
    return;
  }
  {
#line 370
  if ((unsigned int )special->sprite == 55U) {
#line 370
    goto case_55;
  }
#line 376
  if ((unsigned int )special->sprite == 56U) {
#line 376
    goto case_56;
  }
#line 383
  if ((unsigned int )special->sprite == 60U) {
#line 383
    goto case_60;
  }
#line 391
  if ((unsigned int )special->sprite == 61U) {
#line 391
    goto case_61;
  }
#line 400
  if ((unsigned int )special->sprite == 70U) {
#line 400
    goto case_70;
  }
#line 409
  if ((unsigned int )special->sprite == 74U) {
#line 409
    goto case_74;
  }
#line 421
  if ((unsigned int )special->sprite == 62U) {
#line 421
    goto case_62;
  }
#line 429
  if ((unsigned int )special->sprite == 64U) {
#line 429
    goto case_64;
  }
#line 437
  if ((unsigned int )special->sprite == 63U) {
#line 437
    goto case_63;
  }
#line 445
  if ((unsigned int )special->sprite == 65U) {
#line 445
    goto case_65;
  }
#line 453
  if ((unsigned int )special->sprite == 67U) {
#line 453
    goto case_67;
  }
#line 461
  if ((unsigned int )special->sprite == 66U) {
#line 461
    goto case_66;
  }
#line 470
  if ((unsigned int )special->sprite == 68U) {
#line 470
    goto case_68;
  }
#line 476
  if ((unsigned int )special->sprite == 69U) {
#line 476
    goto case_69;
  }
#line 488
  if ((unsigned int )special->sprite == 71U) {
#line 488
    goto case_71;
  }
#line 495
  if ((unsigned int )special->sprite == 72U) {
#line 495
    goto case_72;
  }
#line 504
  if ((unsigned int )special->sprite == 73U) {
#line 504
    goto case_73;
  }
#line 511
  if ((unsigned int )special->sprite == 75U) {
#line 511
    goto case_75;
  }
#line 518
  if ((unsigned int )special->sprite == 76U) {
#line 518
    goto case_76;
  }
#line 525
  if ((unsigned int )special->sprite == 77U) {
#line 525
    goto case_77;
  }
#line 533
  if ((unsigned int )special->sprite == 78U) {
#line 533
    goto case_78;
  }
#line 547
  if ((unsigned int )special->sprite == 79U) {
#line 547
    goto case_79;
  }
#line 553
  if ((unsigned int )special->sprite == 80U) {
#line 553
    goto case_80;
  }
#line 559
  if ((unsigned int )special->sprite == 81U) {
#line 559
    goto case_81;
  }
#line 565
  if ((unsigned int )special->sprite == 82U) {
#line 565
    goto case_82;
  }
#line 571
  if ((unsigned int )special->sprite == 83U) {
#line 571
    goto case_83;
  }
#line 577
  if ((unsigned int )special->sprite == 84U) {
#line 577
    goto case_84;
  }
#line 583
  if ((unsigned int )special->sprite == 85U) {
#line 583
    goto case_85;
  }
#line 589
  if ((unsigned int )special->sprite == 86U) {
#line 589
    goto case_86;
  }
#line 602
  if ((unsigned int )special->sprite == 87U) {
#line 602
    goto case_87;
  }
#line 609
  if ((unsigned int )special->sprite == 88U) {
#line 609
    goto case_88;
  }
#line 616
  if ((unsigned int )special->sprite == 89U) {
#line 616
    goto case_89;
  }
#line 623
  if ((unsigned int )special->sprite == 90U) {
#line 623
    goto case_90;
  }
#line 630
  if ((unsigned int )special->sprite == 91U) {
#line 630
    goto case_91;
  }
#line 637
  if ((unsigned int )special->sprite == 92U) {
#line 637
    goto case_92;
  }
#line 644
  if ((unsigned int )special->sprite == 93U) {
#line 644
    goto case_93;
  }
#line 651
  goto switch_default;
  case_55: /* CIL Label */ 
#line 371
  tmp = P_GiveArmor(player, 1);
#line 371
  if (! tmp) {
#line 372
    return;
  }
#line 373
  player->message = "Picked up the armor.";
#line 374
  goto switch_break;
  case_56: /* CIL Label */ 
#line 377
  tmp___0 = P_GiveArmor(player, 2);
#line 377
  if (! tmp___0) {
#line 378
    return;
  }
#line 379
  player->message = "Picked up the MegaArmor!";
#line 380
  goto switch_break;
  case_60: /* CIL Label */ 
#line 384
  (player->health) ++;
#line 385
  if (player->health > 200) {
#line 386
    player->health = 200;
  }
#line 387
  (player->mo)->health = player->health;
#line 388
  player->message = "Picked up a health bonus.";
#line 389
  goto switch_break;
  case_61: /* CIL Label */ 
#line 392
  (player->armorpoints) ++;
#line 393
  if (player->armorpoints > 200) {
#line 394
    player->armorpoints = 200;
  }
#line 395
  if (! player->armortype) {
#line 396
    player->armortype = 1;
  }
#line 397
  player->message = "Picked up an armor bonus.";
#line 398
  goto switch_break;
  case_70: /* CIL Label */ 
#line 401
  player->health += 100;
#line 402
  if (player->health > 200) {
#line 403
    player->health = 200;
  }
#line 404
  (player->mo)->health = player->health;
#line 405
  player->message = "Supercharge!";
#line 406
  sound = 93;
#line 407
  goto switch_break;
  case_74: /* CIL Label */ 
#line 410
  if ((unsigned int )gamemode != 2U) {
#line 411
    return;
  }
#line 412
  player->health = 200;
#line 413
  (player->mo)->health = player->health;
#line 414
  P_GiveArmor(player, 2);
#line 415
  player->message = "MegaSphere!";
#line 416
  sound = 93;
#line 417
  goto switch_break;
  case_62: /* CIL Label */ 
#line 422
  if (! player->cards[0]) {
#line 423
    player->message = "Picked up a blue keycard.";
  }
#line 424
  P_GiveCard(player, (card_t )0);
#line 425
  if (! netgame) {
#line 426
    goto switch_break;
  }
#line 427
  return;
  case_64: /* CIL Label */ 
#line 430
  if (! player->cards[1]) {
#line 431
    player->message = "Picked up a yellow keycard.";
  }
#line 432
  P_GiveCard(player, (card_t )1);
#line 433
  if (! netgame) {
#line 434
    goto switch_break;
  }
#line 435
  return;
  case_63: /* CIL Label */ 
#line 438
  if (! player->cards[2]) {
#line 439
    player->message = "Picked up a red keycard.";
  }
#line 440
  P_GiveCard(player, (card_t )2);
#line 441
  if (! netgame) {
#line 442
    goto switch_break;
  }
#line 443
  return;
  case_65: /* CIL Label */ 
#line 446
  if (! player->cards[3]) {
#line 447
    player->message = "Picked up a blue skull key.";
  }
#line 448
  P_GiveCard(player, (card_t )3);
#line 449
  if (! netgame) {
#line 450
    goto switch_break;
  }
#line 451
  return;
  case_67: /* CIL Label */ 
#line 454
  if (! player->cards[4]) {
#line 455
    player->message = "Picked up a yellow skull key.";
  }
#line 456
  P_GiveCard(player, (card_t )4);
#line 457
  if (! netgame) {
#line 458
    goto switch_break;
  }
#line 459
  return;
  case_66: /* CIL Label */ 
#line 462
  if (! player->cards[5]) {
#line 463
    player->message = "Picked up a red skull key.";
  }
#line 464
  P_GiveCard(player, (card_t )5);
#line 465
  if (! netgame) {
#line 466
    goto switch_break;
  }
#line 467
  return;
  case_68: /* CIL Label */ 
#line 471
  tmp___1 = P_GiveBody(player, 10);
#line 471
  if (! tmp___1) {
#line 472
    return;
  }
#line 473
  player->message = "Picked up a stimpack.";
#line 474
  goto switch_break;
  case_69: /* CIL Label */ 
#line 477
  tmp___2 = P_GiveBody(player, 25);
#line 477
  if (! tmp___2) {
#line 478
    return;
  }
#line 480
  if (player->health < 25) {
#line 481
    player->message = "Picked up a medikit that you REALLY need!";
  } else {
#line 483
    player->message = "Picked up a medikit.";
  }
#line 484
  goto switch_break;
  case_71: /* CIL Label */ 
#line 489
  tmp___3 = P_GivePower(player, 0);
#line 489
  if (! tmp___3) {
#line 490
    return;
  }
#line 491
  player->message = "Invulnerability!";
#line 492
  sound = 93;
#line 493
  goto switch_break;
  case_72: /* CIL Label */ 
#line 496
  tmp___4 = P_GivePower(player, 1);
#line 496
  if (! tmp___4) {
#line 497
    return;
  }
#line 498
  player->message = "Berserk!";
#line 499
  if ((unsigned int )player->readyweapon != 0U) {
#line 500
    player->pendingweapon = (weapontype_t )0;
  }
#line 501
  sound = 93;
#line 502
  goto switch_break;
  case_73: /* CIL Label */ 
#line 505
  tmp___5 = P_GivePower(player, 2);
#line 505
  if (! tmp___5) {
#line 506
    return;
  }
#line 507
  player->message = "Partial Invisibility";
#line 508
  sound = 93;
#line 509
  goto switch_break;
  case_75: /* CIL Label */ 
#line 512
  tmp___6 = P_GivePower(player, 3);
#line 512
  if (! tmp___6) {
#line 513
    return;
  }
#line 514
  player->message = "Radiation Shielding Suit";
#line 515
  sound = 93;
#line 516
  goto switch_break;
  case_76: /* CIL Label */ 
#line 519
  tmp___7 = P_GivePower(player, 4);
#line 519
  if (! tmp___7) {
#line 520
    return;
  }
#line 521
  player->message = "Computer Area Map";
#line 522
  sound = 93;
#line 523
  goto switch_break;
  case_77: /* CIL Label */ 
#line 526
  tmp___8 = P_GivePower(player, 5);
#line 526
  if (! tmp___8) {
#line 527
    return;
  }
#line 528
  player->message = "Light Amplification Visor";
#line 529
  sound = 93;
#line 530
  goto switch_break;
  case_78: /* CIL Label */ 
#line 534
  if (special->flags & 131072) {
#line 536
    tmp___9 = P_GiveAmmo(player, (ammotype_t )0, 0);
#line 536
    if (! tmp___9) {
#line 537
      return;
    }
  } else {
#line 541
    tmp___10 = P_GiveAmmo(player, (ammotype_t )0, 1);
#line 541
    if (! tmp___10) {
#line 542
      return;
    }
  }
#line 544
  player->message = "Picked up a clip.";
#line 545
  goto switch_break;
  case_79: /* CIL Label */ 
#line 548
  tmp___11 = P_GiveAmmo(player, (ammotype_t )0, 5);
#line 548
  if (! tmp___11) {
#line 549
    return;
  }
#line 550
  player->message = "Picked up a box of bullets.";
#line 551
  goto switch_break;
  case_80: /* CIL Label */ 
#line 554
  tmp___12 = P_GiveAmmo(player, (ammotype_t )3, 1);
#line 554
  if (! tmp___12) {
#line 555
    return;
  }
#line 556
  player->message = "Picked up a rocket.";
#line 557
  goto switch_break;
  case_81: /* CIL Label */ 
#line 560
  tmp___13 = P_GiveAmmo(player, (ammotype_t )3, 5);
#line 560
  if (! tmp___13) {
#line 561
    return;
  }
#line 562
  player->message = "Picked up a box of rockets.";
#line 563
  goto switch_break;
  case_82: /* CIL Label */ 
#line 566
  tmp___14 = P_GiveAmmo(player, (ammotype_t )2, 1);
#line 566
  if (! tmp___14) {
#line 567
    return;
  }
#line 568
  player->message = "Picked up an energy cell.";
#line 569
  goto switch_break;
  case_83: /* CIL Label */ 
#line 572
  tmp___15 = P_GiveAmmo(player, (ammotype_t )2, 5);
#line 572
  if (! tmp___15) {
#line 573
    return;
  }
#line 574
  player->message = "Picked up an energy cell pack.";
#line 575
  goto switch_break;
  case_84: /* CIL Label */ 
#line 578
  tmp___16 = P_GiveAmmo(player, (ammotype_t )1, 1);
#line 578
  if (! tmp___16) {
#line 579
    return;
  }
#line 580
  player->message = "Picked up 4 shotgun shells.";
#line 581
  goto switch_break;
  case_85: /* CIL Label */ 
#line 584
  tmp___17 = P_GiveAmmo(player, (ammotype_t )1, 5);
#line 584
  if (! tmp___17) {
#line 585
    return;
  }
#line 586
  player->message = "Picked up a box of shotgun shells.";
#line 587
  goto switch_break;
  case_86: /* CIL Label */ 
#line 590
  if (! player->backpack) {
#line 592
    i = 0;
    {
#line 592
    while (1) {
      while_continue: /* CIL Label */ ;
#line 592
      if (! (i < 4)) {
#line 592
        goto while_break;
      }
#line 593
      player->maxammo[i] *= 2;
#line 592
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 594
    player->backpack = (boolean )1;
  }
#line 596
  i = 0;
  {
#line 596
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 596
    if (! (i < 4)) {
#line 596
      goto while_break___0;
    }
#line 597
    P_GiveAmmo(player, (ammotype_t )i, 1);
#line 596
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 598
  player->message = "Picked up a backpack full of ammo!";
#line 599
  goto switch_break;
  case_87: /* CIL Label */ 
#line 603
  tmp___18 = P_GiveWeapon(player, (weapontype_t )6, (boolean )0);
#line 603
  if (! tmp___18) {
#line 604
    return;
  }
#line 605
  player->message = "You got the BFG9000!  Oh, yes.";
#line 606
  sound = 33;
#line 607
  goto switch_break;
  case_88: /* CIL Label */ 
#line 610
  tmp___19 = P_GiveWeapon(player, (weapontype_t )3, (boolean )(special->flags & 131072));
#line 610
  if (! tmp___19) {
#line 611
    return;
  }
#line 612
  player->message = "You got the chaingun!";
#line 613
  sound = 33;
#line 614
  goto switch_break;
  case_89: /* CIL Label */ 
#line 617
  tmp___20 = P_GiveWeapon(player, (weapontype_t )7, (boolean )0);
#line 617
  if (! tmp___20) {
#line 618
    return;
  }
#line 619
  player->message = "A chainsaw!  Find some meat!";
#line 620
  sound = 33;
#line 621
  goto switch_break;
  case_90: /* CIL Label */ 
#line 624
  tmp___21 = P_GiveWeapon(player, (weapontype_t )4, (boolean )0);
#line 624
  if (! tmp___21) {
#line 625
    return;
  }
#line 626
  player->message = "You got the rocket launcher!";
#line 627
  sound = 33;
#line 628
  goto switch_break;
  case_91: /* CIL Label */ 
#line 631
  tmp___22 = P_GiveWeapon(player, (weapontype_t )5, (boolean )0);
#line 631
  if (! tmp___22) {
#line 632
    return;
  }
#line 633
  player->message = "You got the plasma gun!";
#line 634
  sound = 33;
#line 635
  goto switch_break;
  case_92: /* CIL Label */ 
#line 638
  tmp___23 = P_GiveWeapon(player, (weapontype_t )2, (boolean )(special->flags & 131072));
#line 638
  if (! tmp___23) {
#line 639
    return;
  }
#line 640
  player->message = "You got the shotgun!";
#line 641
  sound = 33;
#line 642
  goto switch_break;
  case_93: /* CIL Label */ 
#line 645
  tmp___24 = P_GiveWeapon(player, (weapontype_t )8, (boolean )(special->flags & 131072));
#line 645
  if (! tmp___24) {
#line 646
    return;
  }
#line 647
  player->message = "You got the super shotgun!";
#line 648
  sound = 33;
#line 649
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 652
  I_Error("P_SpecialThing: Unknown gettable thing");
  switch_break: /* CIL Label */ ;
  }
#line 655
  if (special->flags & 8388608) {
#line 656
    (player->itemcount) ++;
  }
#line 657
  P_RemoveMobj(special);
#line 658
  player->bonuscount += 6;
#line 659
  if ((unsigned long )player == (unsigned long )(& players[consoleplayer])) {
#line 660
    S_StartSound((void *)0, sound);
  }
#line 661
  return;
}
}
#line 667 "p_inter.c"
void P_KillMobj(mobj_t *source , mobj_t *target ) 
{ 
  mobjtype_t item ;
  mobj_t *mo ;
  int tmp ;

  {
#line 675
  target->flags &= -16793605;
#line 677
  if ((unsigned int )target->type != 18U) {
#line 678
    target->flags &= -513;
  }
#line 680
  target->flags |= 1049600;
#line 681
  target->height >>= 2;
#line 683
  if (source) {
#line 683
    if (source->player) {
#line 686
      if (target->flags & 4194304) {
#line 687
        ((source->player)->killcount) ++;
      }
#line 689
      if (target->player) {
#line 690
        ((source->player)->frags[target->player - players]) ++;
      }
    } else {
#line 683
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 692
  if (! netgame) {
#line 692
    if (target->flags & 4194304) {
#line 696
      (players[0].killcount) ++;
    } else {
#line 692
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 699
  if (target->player) {
#line 702
    if (! source) {
#line 703
      ((target->player)->frags[target->player - players]) ++;
    }
#line 705
    target->flags &= -3;
#line 706
    (target->player)->playerstate = (playerstate_t )1;
#line 707
    P_DropWeapon(target->player);
#line 709
    if ((unsigned long )target->player == (unsigned long )(& players[consoleplayer])) {
#line 709
      if (automapactive) {
#line 714
        AM_Stop();
      } else {
#line 709
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
  }
#line 719
  if (target->health < - (target->info)->spawnhealth) {
#line 719
    if ((target->info)->xdeathstate) {
#line 722
      P_SetMobjState(target, (statenum_t )(target->info)->xdeathstate);
    } else {
#line 719
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 725
    P_SetMobjState(target, (statenum_t )(target->info)->deathstate);
  }
#line 726
  tmp = P_Random();
#line 726
  target->tics -= tmp & 3;
#line 728
  if (target->tics < 1) {
#line 729
    target->tics = 1;
  }
  {
#line 740
  if ((unsigned int )target->type == 1U) {
#line 740
    goto case_1;
  }
#line 740
  if ((unsigned int )target->type == 23U) {
#line 740
    goto case_1;
  }
#line 744
  if ((unsigned int )target->type == 2U) {
#line 744
    goto case_2;
  }
#line 748
  if ((unsigned int )target->type == 10U) {
#line 748
    goto case_10;
  }
#line 752
  goto switch_default;
  case_1: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 741
  item = (mobjtype_t )63;
#line 742
  goto switch_break;
  case_2: /* CIL Label */ 
#line 745
  item = (mobjtype_t )77;
#line 746
  goto switch_break;
  case_10: /* CIL Label */ 
#line 749
  item = (mobjtype_t )73;
#line 750
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 753
  return;
  switch_break: /* CIL Label */ ;
  }
#line 756
  mo = P_SpawnMobj(target->x, target->y, (-0x7FFFFFFF-1), item);
#line 757
  mo->flags |= 131072;
#line 758
  return;
}
}
#line 774 "p_inter.c"
void P_DamageMobj(mobj_t *target , mobj_t *inflictor , mobj_t *source , int damage ) 
{ 
  unsigned int ang ;
  int saved ;
  player_t *player ;
  fixed_t thrust ;
  int temp ;
  fixed_t tmp ;
  fixed_t tmp___0 ;
  int tmp___1 ;
  fixed_t tmp___2 ;
  fixed_t tmp___3 ;
  int tmp___4 ;

  {
#line 787
  if (! (target->flags & 4)) {
#line 788
    return;
  }
#line 790
  if (target->health <= 0) {
#line 791
    return;
  }
#line 793
  if (target->flags & 16777216) {
#line 795
    tmp___0 = 0;
#line 795
    target->momz = tmp___0;
#line 795
    tmp = tmp___0;
#line 795
    target->momy = tmp;
#line 795
    target->momx = tmp;
  }
#line 798
  player = target->player;
#line 799
  if (player) {
#line 799
    if ((unsigned int )gameskill == 0U) {
#line 800
      damage >>= 1;
    } else {
#line 799
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 806
  if (inflictor) {
#line 806
    if (! (target->flags & 4096)) {
#line 806
      if (! source) {
#line 806
        goto _L___5;
      } else
#line 806
      if (! source->player) {
        _L___5: /* CIL Label */ 
#line 806
        goto _L___4;
      } else
#line 806
      if ((unsigned int )(source->player)->readyweapon != 7U) {
        _L___4: /* CIL Label */ 
#line 812
        ang = R_PointToAngle2(inflictor->x, inflictor->y, target->x, target->y);
#line 817
        thrust = ((damage * ((1 << 16) >> 3)) * 100) / (target->info)->mass;
#line 820
        if (damage < 40) {
#line 820
          if (damage > target->health) {
#line 820
            if (target->z - inflictor->z > 64 * (1 << 16)) {
#line 820
              tmp___1 = P_Random();
#line 820
              if (tmp___1 & 1) {
#line 825
                ang += 0x80000000;
#line 826
                thrust *= 4;
              } else {
#line 820
                goto _L___2;
              }
            } else {
#line 820
              goto _L___2;
            }
          } else {
#line 820
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          _L___1: /* CIL Label */ 
          _L___0: /* CIL Label */ ;
        }
#line 829
        ang >>= 19;
#line 830
        tmp___2 = FixedMul(thrust, *(finecosine + ang));
#line 830
        target->momx += tmp___2;
#line 831
        tmp___3 = FixedMul(thrust, finesine[ang]);
#line 831
        target->momy += tmp___3;
      } else {
#line 806
        goto _L___6;
      }
    } else {
#line 806
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
    _L___3: /* CIL Label */ ;
  }
#line 835
  if (player) {
#line 838
    if ((int )((target->subsector)->sector)->special == 11) {
#line 838
      if (damage >= target->health) {
#line 841
        damage = target->health - 1;
      } else {
#line 838
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ ;
    }
#line 847
    if (damage < 1000) {
#line 847
      if (player->cheats & 2) {
#line 847
        goto _L___9;
      } else
#line 847
      if (player->powers[0]) {
        _L___9: /* CIL Label */ 
#line 851
        return;
      } else {
#line 847
        goto _L___8;
      }
    } else {
      _L___8: /* CIL Label */ ;
    }
#line 854
    if (player->armortype) {
#line 856
      if (player->armortype == 1) {
#line 857
        saved = damage / 3;
      } else {
#line 859
        saved = damage / 2;
      }
#line 861
      if (player->armorpoints <= saved) {
#line 864
        saved = player->armorpoints;
#line 865
        player->armortype = 0;
      }
#line 867
      player->armorpoints -= saved;
#line 868
      damage -= saved;
    }
#line 870
    player->health -= damage;
#line 871
    if (player->health < 0) {
#line 872
      player->health = 0;
    }
#line 874
    player->attacker = source;
#line 875
    player->damagecount += damage;
#line 877
    if (player->damagecount > 100) {
#line 878
      player->damagecount = 100;
    }
#line 880
    if (damage < 100) {
#line 880
      temp = damage;
    } else {
#line 880
      temp = 100;
    }
#line 882
    if ((unsigned long )player == (unsigned long )(& players[consoleplayer])) {
#line 883
      I_Tactile(40, 10, 40 + temp * 2);
    }
  }
#line 887
  target->health -= damage;
#line 888
  if (target->health <= 0) {
#line 890
    P_KillMobj(source, target);
#line 891
    return;
  }
#line 894
  tmp___4 = P_Random();
#line 894
  if (tmp___4 < (target->info)->painchance) {
#line 894
    if (! (target->flags & 16777216)) {
#line 897
      target->flags |= 64;
#line 899
      P_SetMobjState(target, (statenum_t )(target->info)->painstate);
    } else {
#line 894
      goto _L___10;
    }
  } else {
    _L___10: /* CIL Label */ ;
  }
#line 902
  target->reactiontime = 0;
#line 904
  if (! target->threshold) {
#line 904
    goto _L___15;
  } else
#line 904
  if ((unsigned int )target->type == 3U) {
    _L___15: /* CIL Label */ 
#line 904
    if (source) {
#line 904
      if ((unsigned long )source != (unsigned long )target) {
#line 904
        if ((unsigned int )source->type != 3U) {
#line 910
          target->target = source;
#line 911
          target->threshold = 100;
#line 912
          if ((unsigned long )target->state == (unsigned long )(& states[(target->info)->spawnstate])) {
#line 912
            if ((target->info)->seestate != 0) {
#line 914
              P_SetMobjState(target, (statenum_t )(target->info)->seestate);
            } else {
#line 912
              goto _L___11;
            }
          } else {
            _L___11: /* CIL Label */ ;
          }
        } else {
#line 904
          goto _L___14;
        }
      } else {
#line 904
        goto _L___14;
      }
    } else {
#line 904
      goto _L___14;
    }
  } else {
    _L___14: /* CIL Label */ 
    _L___13: /* CIL Label */ 
    _L___12: /* CIL Label */ ;
  }
#line 917
  return;
}
}
#line 25 "p_lights.c"
static char const   rcsid___27[51]  = 
#line 25 "p_lights.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'l', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'t', 
        (char const   )'s',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )' ',      (char const   )'2',      (char const   )'2',      (char const   )':', 
        (char const   )'4',      (char const   )'5',      (char const   )':',      (char const   )'1', 
        (char const   )'1',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 46 "p_lights.c"
void T_FireFlicker(fireflicker_t *flick ) 
{ 
  int amount ;
  int tmp ;

  {
#line 50
  (flick->count) --;
#line 50
  if (flick->count) {
#line 51
    return;
  }
#line 53
  tmp = P_Random();
#line 53
  amount = (tmp & 3) * 16;
#line 55
  if ((int )(flick->sector)->lightlevel - amount < flick->minlight) {
#line 56
    (flick->sector)->lightlevel = (short )flick->minlight;
  } else {
#line 58
    (flick->sector)->lightlevel = (short )(flick->maxlight - amount);
  }
#line 60
  flick->count = 4;
#line 61
  return;
}
}
#line 68 "p_lights.c"
void P_SpawnFireFlicker(sector_t *sector ) 
{ 
  fireflicker_t *flick ;
  void *tmp ;
  int tmp___0 ;

  {
#line 74
  sector->special = (short)0;
#line 76
  tmp = Z_Malloc((int )sizeof(*flick), 51, (void *)0);
#line 76
  flick = (fireflicker_t *)tmp;
#line 78
  P_AddThinker(& flick->thinker);
#line 80
  flick->thinker.function.acp1 = (void (*)(void * ))(& T_FireFlicker);
#line 81
  flick->sector = sector;
#line 82
  flick->maxlight = (int )sector->lightlevel;
#line 83
  tmp___0 = P_FindMinSurroundingLight(sector, (int )sector->lightlevel);
#line 83
  flick->minlight = tmp___0 + 16;
#line 84
  flick->count = 4;
#line 85
  return;
}
}
#line 98 "p_lights.c"
void T_LightFlash(lightflash_t *flash ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 100
  (flash->count) --;
#line 100
  if (flash->count) {
#line 101
    return;
  }
#line 103
  if ((int )(flash->sector)->lightlevel == flash->maxlight) {
#line 105
    (flash->sector)->lightlevel = (short )flash->minlight;
#line 106
    tmp = P_Random();
#line 106
    flash->count = (tmp & flash->mintime) + 1;
  } else {
#line 110
    (flash->sector)->lightlevel = (short )flash->maxlight;
#line 111
    tmp___0 = P_Random();
#line 111
    flash->count = (tmp___0 & flash->maxtime) + 1;
  }
#line 114
  return;
}
}
#line 124 "p_lights.c"
void P_SpawnLightFlash(sector_t *sector ) 
{ 
  lightflash_t *flash ;
  void *tmp ;
  int tmp___0 ;

  {
#line 129
  sector->special = (short)0;
#line 131
  tmp = Z_Malloc((int )sizeof(*flash), 51, (void *)0);
#line 131
  flash = (lightflash_t *)tmp;
#line 133
  P_AddThinker(& flash->thinker);
#line 135
  flash->thinker.function.acp1 = (void (*)(void * ))(& T_LightFlash);
#line 136
  flash->sector = sector;
#line 137
  flash->maxlight = (int )sector->lightlevel;
#line 139
  flash->minlight = P_FindMinSurroundingLight(sector, (int )sector->lightlevel);
#line 140
  flash->maxtime = 64;
#line 141
  flash->mintime = 7;
#line 142
  tmp___0 = P_Random();
#line 142
  flash->count = (tmp___0 & flash->maxtime) + 1;
#line 143
  return;
}
}
#line 155 "p_lights.c"
void T_StrobeFlash(strobe_t *flash ) 
{ 


  {
#line 157
  (flash->count) --;
#line 157
  if (flash->count) {
#line 158
    return;
  }
#line 160
  if ((int )(flash->sector)->lightlevel == flash->minlight) {
#line 162
    (flash->sector)->lightlevel = (short )flash->maxlight;
#line 163
    flash->count = flash->brighttime;
  } else {
#line 167
    (flash->sector)->lightlevel = (short )flash->minlight;
#line 168
    flash->count = flash->darktime;
  }
#line 171
  return;
}
}
#line 180 "p_lights.c"
void P_SpawnStrobeFlash(sector_t *sector , int fastOrSlow , int inSync ) 
{ 
  strobe_t *flash ;
  void *tmp ;
  int tmp___0 ;

  {
#line 188
  tmp = Z_Malloc((int )sizeof(*flash), 51, (void *)0);
#line 188
  flash = (strobe_t *)tmp;
#line 190
  P_AddThinker(& flash->thinker);
#line 192
  flash->sector = sector;
#line 193
  flash->darktime = fastOrSlow;
#line 194
  flash->brighttime = 5;
#line 195
  flash->thinker.function.acp1 = (void (*)(void * ))(& T_StrobeFlash);
#line 196
  flash->maxlight = (int )sector->lightlevel;
#line 197
  flash->minlight = P_FindMinSurroundingLight(sector, (int )sector->lightlevel);
#line 199
  if (flash->minlight == flash->maxlight) {
#line 200
    flash->minlight = 0;
  }
#line 203
  sector->special = (short)0;
#line 205
  if (! inSync) {
#line 206
    tmp___0 = P_Random();
#line 206
    flash->count = (tmp___0 & 7) + 1;
  } else {
#line 208
    flash->count = 1;
  }
#line 209
  return;
}
}
#line 215 "p_lights.c"
void EV_StartLightStrobing(line_t *line ) 
{ 
  int secnum ;
  sector_t *sec ;

  {
#line 220
  secnum = -1;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    secnum = P_FindSectorFromLineTag(line, secnum);
#line 221
    if (! (secnum >= 0)) {
#line 221
      goto while_break;
    }
#line 223
    sec = sectors + secnum;
#line 224
    if (sec->specialdata) {
#line 225
      goto while_continue;
    }
#line 227
    P_SpawnStrobeFlash(sec, 35, 0);
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 236 "p_lights.c"
void EV_TurnTagLightsOff(line_t *line ) 
{ 
  int i ;
  int j ;
  int min ;
  sector_t *sector ;
  sector_t *tsec ;
  line_t *templine ;

  {
#line 245
  sector = sectors;
#line 247
  j = 0;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (j < numsectors)) {
#line 247
      goto while_break;
    }
#line 249
    if ((int )sector->tag == (int )line->tag) {
#line 251
      min = (int )sector->lightlevel;
#line 252
      i = 0;
      {
#line 252
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 252
        if (! (i < sector->linecount)) {
#line 252
          goto while_break___0;
        }
#line 254
        templine = *(sector->lines + i);
#line 255
        tsec = getNextSector(templine, sector);
#line 256
        if (! tsec) {
#line 257
          goto __Cont;
        }
#line 258
        if ((int )tsec->lightlevel < min) {
#line 259
          min = (int )tsec->lightlevel;
        }
        __Cont: /* CIL Label */ 
#line 252
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 261
      sector->lightlevel = (short )min;
    }
#line 247
    j ++;
#line 247
    sector ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  return;
}
}
#line 270 "p_lights.c"
void EV_LightTurnOn(line_t *line , int bright ) 
{ 
  int i ;
  int j ;
  sector_t *sector ;
  sector_t *temp ;
  line_t *templine ;

  {
#line 281
  sector = sectors;
#line 283
  i = 0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i < numsectors)) {
#line 283
      goto while_break;
    }
#line 285
    if ((int )sector->tag == (int )line->tag) {
#line 290
      if (! bright) {
#line 292
        j = 0;
        {
#line 292
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 292
          if (! (j < sector->linecount)) {
#line 292
            goto while_break___0;
          }
#line 294
          templine = *(sector->lines + j);
#line 295
          temp = getNextSector(templine, sector);
#line 297
          if (! temp) {
#line 298
            goto __Cont;
          }
#line 300
          if ((int )temp->lightlevel > bright) {
#line 301
            bright = (int )temp->lightlevel;
          }
          __Cont: /* CIL Label */ 
#line 292
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 304
      sector->lightlevel = (short )bright;
    }
#line 283
    i ++;
#line 283
    sector ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  return;
}
}
#line 314 "p_lights.c"
void T_Glow(glow_t *g ) 
{ 


  {
  {
#line 318
  if (g->direction == -1) {
#line 318
    goto case_neg_1;
  }
#line 328
  if (g->direction == 1) {
#line 328
    goto case_1;
  }
#line 316
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 320
  (g->sector)->lightlevel = (short )((int )(g->sector)->lightlevel - 8);
#line 321
  if ((int )(g->sector)->lightlevel <= g->minlight) {
#line 323
    (g->sector)->lightlevel = (short )((int )(g->sector)->lightlevel + 8);
#line 324
    g->direction = 1;
  }
#line 326
  goto switch_break;
  case_1: /* CIL Label */ 
#line 330
  (g->sector)->lightlevel = (short )((int )(g->sector)->lightlevel + 8);
#line 331
  if ((int )(g->sector)->lightlevel >= g->maxlight) {
#line 333
    (g->sector)->lightlevel = (short )((int )(g->sector)->lightlevel - 8);
#line 334
    g->direction = -1;
  }
#line 336
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 338
  return;
}
}
#line 341 "p_lights.c"
void P_SpawnGlowingLight(sector_t *sector ) 
{ 
  glow_t *g ;
  void *tmp ;

  {
#line 345
  tmp = Z_Malloc((int )sizeof(*g), 51, (void *)0);
#line 345
  g = (glow_t *)tmp;
#line 347
  P_AddThinker(& g->thinker);
#line 349
  g->sector = sector;
#line 350
  g->minlight = P_FindMinSurroundingLight(sector, (int )sector->lightlevel);
#line 351
  g->maxlight = (int )sector->lightlevel;
#line 352
  g->thinker.function.acp1 = (void (*)(void * ))(& T_Glow);
#line 353
  g->direction = -1;
#line 355
  sector->special = (short)0;
#line 356
  return;
}
}
#line 25 "p_map.c"
static char const   rcsid___28[48]  = 
#line 25 "p_map.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'m', 
        (char const   )'a',      (char const   )'p',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'7',      (char const   )'/', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )' ',      (char const   )'2',      (char const   )'2', 
        (char const   )':',      (char const   )'4',      (char const   )'5',      (char const   )':', 
        (char const   )'1',      (char const   )'1',      (char const   )' ',      (char const   )'b', 
        (char const   )'1',      (char const   )' ',      (char const   )'E',      (char const   )'x', 
        (char const   )'p',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 203 "p_local.h"
boolean floatok  ;
#line 204 "p_local.h"
fixed_t tmfloorz  ;
#line 205 "p_local.h"
fixed_t tmceilingz  ;
#line 208 "p_local.h"
line_t *ceilingline  ;
#line 219 "p_local.h"
mobj_t *linetarget  ;
#line 46 "p_map.c"
fixed_t tmbbox[4]  ;
#line 47 "p_map.c"
mobj_t *tmthing  ;
#line 48 "p_map.c"
int tmflags  ;
#line 49 "p_map.c"
fixed_t tmx  ;
#line 50 "p_map.c"
fixed_t tmy  ;
#line 59 "p_map.c"
fixed_t tmdropoffz  ;
#line 69 "p_map.c"
line_t *spechit[8]  ;
#line 70 "p_map.c"
int numspechit  ;
#line 81 "p_map.c"
boolean PIT_StompThing(mobj_t *thing ) 
{ 
  fixed_t blockdist ;
  int tmp ;
  int tmp___0 ;

  {
#line 85
  if (! (thing->flags & 4)) {
#line 86
    return ((boolean )1);
  }
#line 88
  blockdist = thing->radius + tmthing->radius;
#line 90
  tmp = abs(thing->x - tmx);
#line 90
  if (tmp >= blockdist) {
#line 90
    goto _L;
  } else {
#line 90
    tmp___0 = abs(thing->y - tmy);
#line 90
    if (tmp___0 >= blockdist) {
      _L: /* CIL Label */ 
#line 94
      return ((boolean )1);
    }
  }
#line 98
  if ((unsigned long )thing == (unsigned long )tmthing) {
#line 99
    return ((boolean )1);
  }
#line 102
  if (! tmthing->player) {
#line 102
    if (gamemap != 30) {
#line 103
      return ((boolean )0);
    } else {
#line 102
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 105
  P_DamageMobj(thing, tmthing, tmthing, 10000);
#line 107
  return ((boolean )1);
}
}
#line 114 "p_map.c"
boolean P_TeleportMove(mobj_t *thing , fixed_t x___0 , fixed_t y___1 ) 
{ 
  int xl ;
  int xh ;
  int yl ;
  int yh ;
  int bx ;
  int by ;
  subsector_t *newsubsec ;
  boolean tmp ;

  {
#line 130
  tmthing = thing;
#line 131
  tmflags = thing->flags;
#line 133
  tmx = x___0;
#line 134
  tmy = y___1;
#line 136
  tmbbox[0] = y___1 + tmthing->radius;
#line 137
  tmbbox[1] = y___1 - tmthing->radius;
#line 138
  tmbbox[3] = x___0 + tmthing->radius;
#line 139
  tmbbox[2] = x___0 - tmthing->radius;
#line 141
  newsubsec = R_PointInSubsector(x___0, y___1);
#line 142
  ceilingline = (line_t *)((void *)0);
#line 148
  tmdropoffz = (newsubsec->sector)->floorheight;
#line 148
  tmfloorz = tmdropoffz;
#line 149
  tmceilingz = (newsubsec->sector)->ceilingheight;
#line 151
  validcount ++;
#line 152
  numspechit = 0;
#line 155
  xl = ((tmbbox[2] - bmaporgx) - 32 * (1 << 16)) >> 23;
#line 156
  xh = ((tmbbox[3] - bmaporgx) + 32 * (1 << 16)) >> 23;
#line 157
  yl = ((tmbbox[1] - bmaporgy) - 32 * (1 << 16)) >> 23;
#line 158
  yh = ((tmbbox[0] - bmaporgy) + 32 * (1 << 16)) >> 23;
#line 160
  bx = xl;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (bx <= xh)) {
#line 160
      goto while_break;
    }
#line 161
    by = yl;
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 161
      if (! (by <= yh)) {
#line 161
        goto while_break___0;
      }
#line 162
      tmp = P_BlockThingsIterator(bx, by, & PIT_StompThing);
#line 162
      if (! tmp) {
#line 163
        return ((boolean )0);
      }
#line 161
      by ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 160
    bx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  P_UnsetThingPosition(thing);
#line 169
  thing->floorz = tmfloorz;
#line 170
  thing->ceilingz = tmceilingz;
#line 171
  thing->x = x___0;
#line 172
  thing->y = y___1;
#line 174
  P_SetThingPosition(thing);
#line 176
  return ((boolean )1);
}
}
#line 189 "p_map.c"
boolean PIT_CheckLine(line_t *ld ) 
{ 
  int tmp ;

  {
#line 191
  if (tmbbox[3] <= ld->bbox[2]) {
#line 191
    goto _L___1;
  } else
#line 191
  if (tmbbox[2] >= ld->bbox[3]) {
    _L___1: /* CIL Label */ 
#line 191
    goto _L___0;
  } else
#line 191
  if (tmbbox[0] <= ld->bbox[1]) {
    _L___0: /* CIL Label */ 
#line 191
    goto _L;
  } else
#line 191
  if (tmbbox[1] >= ld->bbox[0]) {
    _L: /* CIL Label */ 
#line 195
    return ((boolean )1);
  }
#line 197
  tmp = P_BoxOnLineSide(tmbbox, ld);
#line 197
  if (tmp != -1) {
#line 198
    return ((boolean )1);
  }
#line 211
  if (! ld->backsector) {
#line 212
    return ((boolean )0);
  }
#line 214
  if (! (tmthing->flags & 65536)) {
#line 216
    if ((int )ld->flags & 1) {
#line 217
      return ((boolean )0);
    }
#line 219
    if (! tmthing->player) {
#line 219
      if ((int )ld->flags & 2) {
#line 220
        return ((boolean )0);
      } else {
#line 219
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ ;
    }
  }
#line 224
  P_LineOpening(ld);
#line 227
  if (opentop < tmceilingz) {
#line 229
    tmceilingz = opentop;
#line 230
    ceilingline = ld;
  }
#line 233
  if (openbottom > tmfloorz) {
#line 234
    tmfloorz = openbottom;
  }
#line 236
  if (lowfloor < tmdropoffz) {
#line 237
    tmdropoffz = lowfloor;
  }
#line 240
  if (ld->special) {
#line 242
    spechit[numspechit] = ld;
#line 243
    numspechit ++;
  }
#line 246
  return ((boolean )1);
}
}
#line 252 "p_map.c"
boolean PIT_CheckThing(mobj_t *thing ) 
{ 
  fixed_t blockdist ;
  boolean solid ;
  int damage ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  fixed_t tmp___2 ;
  fixed_t tmp___3 ;
  int tmp___4 ;

  {
#line 258
  if (! (thing->flags & 7)) {
#line 259
    return ((boolean )1);
  }
#line 261
  blockdist = thing->radius + tmthing->radius;
#line 263
  tmp = abs(thing->x - tmx);
#line 263
  if (tmp >= blockdist) {
#line 263
    goto _L;
  } else {
#line 263
    tmp___0 = abs(thing->y - tmy);
#line 263
    if (tmp___0 >= blockdist) {
      _L: /* CIL Label */ 
#line 267
      return ((boolean )1);
    }
  }
#line 271
  if ((unsigned long )thing == (unsigned long )tmthing) {
#line 272
    return ((boolean )1);
  }
#line 275
  if (tmthing->flags & 16777216) {
#line 277
    tmp___1 = P_Random();
#line 277
    damage = (tmp___1 % 8 + 1) * (tmthing->info)->damage;
#line 279
    P_DamageMobj(thing, tmthing, tmthing, damage);
#line 281
    tmthing->flags &= -16777217;
#line 282
    tmp___3 = 0;
#line 282
    tmthing->momz = tmp___3;
#line 282
    tmp___2 = tmp___3;
#line 282
    tmthing->momy = tmp___2;
#line 282
    tmthing->momx = tmp___2;
#line 284
    P_SetMobjState(tmthing, (statenum_t )(tmthing->info)->spawnstate);
#line 286
    return ((boolean )0);
  }
#line 291
  if (tmthing->flags & 65536) {
#line 294
    if (tmthing->z > thing->z + thing->height) {
#line 295
      return ((boolean )1);
    }
#line 296
    if (tmthing->z + tmthing->height < thing->z) {
#line 297
      return ((boolean )1);
    }
#line 299
    if (tmthing->target) {
#line 299
      if ((unsigned int )(tmthing->target)->type == (unsigned int )thing->type) {
#line 299
        goto _L___3;
      } else
#line 299
      if ((unsigned int )(tmthing->target)->type == 17U) {
#line 299
        if ((unsigned int )thing->type == 15U) {
          _L___3: /* CIL Label */ 
#line 299
          goto _L___1;
        } else {
#line 299
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 299
      if ((unsigned int )(tmthing->target)->type == 15U) {
#line 299
        if ((unsigned int )thing->type == 17U) {
          _L___1: /* CIL Label */ 
#line 305
          if ((unsigned long )thing == (unsigned long )tmthing->target) {
#line 306
            return ((boolean )1);
          }
#line 308
          if ((unsigned int )thing->type != 0U) {
#line 312
            return ((boolean )0);
          }
        } else {
#line 299
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 299
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 316
    if (! (thing->flags & 4)) {
#line 319
      return ((boolean )(! (thing->flags & 2)));
    }
#line 323
    tmp___4 = P_Random();
#line 323
    damage = (tmp___4 % 8 + 1) * (tmthing->info)->damage;
#line 324
    P_DamageMobj(thing, tmthing, tmthing->target, damage);
#line 327
    return ((boolean )0);
  }
#line 331
  if (thing->flags & 1) {
#line 333
    solid = (boolean )(thing->flags & 2);
#line 334
    if (tmflags & 2048) {
#line 337
      P_TouchSpecialThing(thing, tmthing);
    }
#line 339
    return ((boolean )(! solid));
  }
#line 342
  return ((boolean )(! (thing->flags & 2)));
}
}
#line 374 "p_map.c"
boolean P_CheckPosition(mobj_t *thing , fixed_t x___0 , fixed_t y___1 ) 
{ 
  int xl ;
  int xh ;
  int yl ;
  int yh ;
  int bx ;
  int by ;
  subsector_t *newsubsec ;
  boolean tmp ;
  boolean tmp___0 ;

  {
#line 388
  tmthing = thing;
#line 389
  tmflags = thing->flags;
#line 391
  tmx = x___0;
#line 392
  tmy = y___1;
#line 394
  tmbbox[0] = y___1 + tmthing->radius;
#line 395
  tmbbox[1] = y___1 - tmthing->radius;
#line 396
  tmbbox[3] = x___0 + tmthing->radius;
#line 397
  tmbbox[2] = x___0 - tmthing->radius;
#line 399
  newsubsec = R_PointInSubsector(x___0, y___1);
#line 400
  ceilingline = (line_t *)((void *)0);
#line 406
  tmdropoffz = (newsubsec->sector)->floorheight;
#line 406
  tmfloorz = tmdropoffz;
#line 407
  tmceilingz = (newsubsec->sector)->ceilingheight;
#line 409
  validcount ++;
#line 410
  numspechit = 0;
#line 412
  if (tmflags & 4096) {
#line 413
    return ((boolean )1);
  }
#line 420
  xl = ((tmbbox[2] - bmaporgx) - 32 * (1 << 16)) >> 23;
#line 421
  xh = ((tmbbox[3] - bmaporgx) + 32 * (1 << 16)) >> 23;
#line 422
  yl = ((tmbbox[1] - bmaporgy) - 32 * (1 << 16)) >> 23;
#line 423
  yh = ((tmbbox[0] - bmaporgy) + 32 * (1 << 16)) >> 23;
#line 425
  bx = xl;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (bx <= xh)) {
#line 425
      goto while_break;
    }
#line 426
    by = yl;
    {
#line 426
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 426
      if (! (by <= yh)) {
#line 426
        goto while_break___0;
      }
#line 427
      tmp = P_BlockThingsIterator(bx, by, & PIT_CheckThing);
#line 427
      if (! tmp) {
#line 428
        return ((boolean )0);
      }
#line 426
      by ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 425
    bx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  xl = (tmbbox[2] - bmaporgx) >> 23;
#line 432
  xh = (tmbbox[3] - bmaporgx) >> 23;
#line 433
  yl = (tmbbox[1] - bmaporgy) >> 23;
#line 434
  yh = (tmbbox[0] - bmaporgy) >> 23;
#line 436
  bx = xl;
  {
#line 436
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 436
    if (! (bx <= xh)) {
#line 436
      goto while_break___1;
    }
#line 437
    by = yl;
    {
#line 437
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 437
      if (! (by <= yh)) {
#line 437
        goto while_break___2;
      }
#line 438
      tmp___0 = P_BlockLinesIterator(bx, by, & PIT_CheckLine);
#line 438
      if (! tmp___0) {
#line 439
        return ((boolean )0);
      }
#line 437
      by ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 436
    bx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 441
  return ((boolean )1);
}
}
#line 450 "p_map.c"
boolean P_TryMove(mobj_t *thing , fixed_t x___0 , fixed_t y___1 ) 
{ 
  fixed_t oldx ;
  fixed_t oldy ;
  int side ;
  int oldside ;
  line_t *ld ;
  boolean tmp ;
  int tmp___0 ;

  {
#line 462
  floatok = (boolean )0;
#line 463
  tmp = P_CheckPosition(thing, x___0, y___1);
#line 463
  if (! tmp) {
#line 464
    return ((boolean )0);
  }
#line 466
  if (! (thing->flags & 4096)) {
#line 468
    if (tmceilingz - tmfloorz < thing->height) {
#line 469
      return ((boolean )0);
    }
#line 471
    floatok = (boolean )1;
#line 473
    if (! (thing->flags & 32768)) {
#line 473
      if (tmceilingz - thing->z < thing->height) {
#line 475
        return ((boolean )0);
      } else {
#line 473
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 477
    if (! (thing->flags & 32768)) {
#line 477
      if (tmfloorz - thing->z > 24 * (1 << 16)) {
#line 479
        return ((boolean )0);
      } else {
#line 477
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 481
    if (! (thing->flags & 17408)) {
#line 481
      if (tmfloorz - tmdropoffz > 24 * (1 << 16)) {
#line 483
        return ((boolean )0);
      } else {
#line 481
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
  }
#line 488
  P_UnsetThingPosition(thing);
#line 490
  oldx = thing->x;
#line 491
  oldy = thing->y;
#line 492
  thing->floorz = tmfloorz;
#line 493
  thing->ceilingz = tmceilingz;
#line 494
  thing->x = x___0;
#line 495
  thing->y = y___1;
#line 497
  P_SetThingPosition(thing);
#line 500
  if (! (thing->flags & 36864)) {
    {
#line 502
    while (1) {
      while_continue: /* CIL Label */ ;
#line 502
      tmp___0 = numspechit;
#line 502
      numspechit --;
#line 502
      if (! tmp___0) {
#line 502
        goto while_break;
      }
#line 505
      ld = spechit[numspechit];
#line 506
      side = P_PointOnLineSide(thing->x, thing->y, ld);
#line 507
      oldside = P_PointOnLineSide(oldx, oldy, ld);
#line 508
      if (side != oldside) {
#line 510
        if (ld->special) {
#line 511
          P_CrossSpecialLine((int )(ld - lines), oldside, thing);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 516
  return ((boolean )1);
}
}
#line 530 "p_map.c"
boolean P_ThingHeightClip(mobj_t *thing ) 
{ 
  boolean onfloor ;

  {
#line 534
  onfloor = (boolean )(thing->z == thing->floorz);
#line 536
  P_CheckPosition(thing, thing->x, thing->y);
#line 539
  thing->floorz = tmfloorz;
#line 540
  thing->ceilingz = tmceilingz;
#line 542
  if (onfloor) {
#line 545
    thing->z = thing->floorz;
  } else
#line 550
  if (thing->z + thing->height > thing->ceilingz) {
#line 551
    thing->z = thing->ceilingz - thing->height;
  }
#line 554
  if (thing->ceilingz - thing->floorz < thing->height) {
#line 555
    return ((boolean )0);
  }
#line 557
  return ((boolean )1);
}
}
#line 566 "p_map.c"
fixed_t bestslidefrac  ;
#line 567 "p_map.c"
fixed_t secondslidefrac  ;
#line 569 "p_map.c"
line_t *bestslideline  ;
#line 570 "p_map.c"
line_t *secondslideline  ;
#line 572 "p_map.c"
mobj_t *slidemo  ;
#line 574 "p_map.c"
fixed_t tmxmove  ;
#line 575 "p_map.c"
fixed_t tmymove  ;
#line 584 "p_map.c"
void P_HitSlideLine(line_t *ld ) 
{ 
  int side ;
  angle_t lineangle ;
  angle_t moveangle ;
  angle_t deltaangle ;
  fixed_t movelen ;
  fixed_t newlen ;

  {
#line 596
  if ((unsigned int )ld->slopetype == 0U) {
#line 598
    tmymove = 0;
#line 599
    return;
  }
#line 602
  if ((unsigned int )ld->slopetype == 1U) {
#line 604
    tmxmove = 0;
#line 605
    return;
  }
#line 608
  side = P_PointOnLineSide(slidemo->x, slidemo->y, ld);
#line 610
  lineangle = R_PointToAngle2(0, 0, ld->dx, ld->dy);
#line 612
  if (side == 1) {
#line 613
    lineangle += 0x80000000;
  }
#line 615
  moveangle = R_PointToAngle2(0, 0, tmxmove, tmymove);
#line 616
  deltaangle = moveangle - lineangle;
#line 618
  if (deltaangle > 0x80000000) {
#line 619
    deltaangle += 0x80000000;
  }
#line 622
  lineangle >>= 19;
#line 623
  deltaangle >>= 19;
#line 625
  movelen = P_AproxDistance(tmxmove, tmymove);
#line 626
  newlen = FixedMul(movelen, *(finecosine + deltaangle));
#line 628
  tmxmove = FixedMul(newlen, *(finecosine + lineangle));
#line 629
  tmymove = FixedMul(newlen, finesine[lineangle]);
#line 630
  return;
}
}
#line 636 "p_map.c"
boolean PTR_SlideTraverse(intercept_t *in ) 
{ 
  line_t *li ;
  int tmp ;

  {
#line 640
  if (! in->isaline) {
#line 641
    I_Error("PTR_SlideTraverse: not a line?");
  }
#line 643
  li = in->d.line;
#line 645
  if (! ((int )li->flags & 4)) {
#line 647
    tmp = P_PointOnLineSide(slidemo->x, slidemo->y, li);
#line 647
    if (tmp) {
#line 650
      return ((boolean )1);
    }
#line 652
    goto isblocking;
  }
#line 656
  P_LineOpening(li);
#line 658
  if (openrange < slidemo->height) {
#line 659
    goto isblocking;
  }
#line 661
  if (opentop - slidemo->z < slidemo->height) {
#line 662
    goto isblocking;
  }
#line 664
  if (openbottom - slidemo->z > 24 * (1 << 16)) {
#line 665
    goto isblocking;
  }
#line 668
  return ((boolean )1);
  isblocking: 
#line 673
  if (in->frac < bestslidefrac) {
#line 675
    secondslidefrac = bestslidefrac;
#line 676
    secondslideline = bestslideline;
#line 677
    bestslidefrac = in->frac;
#line 678
    bestslideline = li;
  }
#line 681
  return ((boolean )0);
}
}
#line 695 "p_map.c"
void P_SlideMove(mobj_t *mo ) 
{ 
  fixed_t leadx ;
  fixed_t leady ;
  fixed_t trailx ;
  fixed_t traily ;
  fixed_t newx ;
  fixed_t newy ;
  int hitcount ;
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;

  {
#line 705
  slidemo = mo;
#line 706
  hitcount = 0;
  retry: 
#line 709
  hitcount ++;
#line 709
  if (hitcount == 3) {
#line 710
    goto stairstep;
  }
#line 714
  if (mo->momx > 0) {
#line 716
    leadx = mo->x + mo->radius;
#line 717
    trailx = mo->x - mo->radius;
  } else {
#line 721
    leadx = mo->x - mo->radius;
#line 722
    trailx = mo->x + mo->radius;
  }
#line 725
  if (mo->momy > 0) {
#line 727
    leady = mo->y + mo->radius;
#line 728
    traily = mo->y - mo->radius;
  } else {
#line 732
    leady = mo->y - mo->radius;
#line 733
    traily = mo->y + mo->radius;
  }
#line 736
  bestslidefrac = (1 << 16) + 1;
#line 738
  P_PathTraverse(leadx, leady, leadx + mo->momx, leady + mo->momy, 1, & PTR_SlideTraverse);
#line 740
  P_PathTraverse(trailx, leady, trailx + mo->momx, leady + mo->momy, 1, & PTR_SlideTraverse);
#line 742
  P_PathTraverse(leadx, traily, leadx + mo->momx, traily + mo->momy, 1, & PTR_SlideTraverse);
#line 746
  if (bestslidefrac == (1 << 16) + 1) {
    stairstep: 
#line 750
    tmp = P_TryMove(mo, mo->x, mo->y + mo->momy);
#line 750
    if (! tmp) {
#line 751
      P_TryMove(mo, mo->x + mo->momx, mo->y);
    }
#line 752
    return;
  }
#line 756
  bestslidefrac -= 0x800;
#line 757
  if (bestslidefrac > 0) {
#line 759
    newx = FixedMul(mo->momx, bestslidefrac);
#line 760
    newy = FixedMul(mo->momy, bestslidefrac);
#line 762
    tmp___0 = P_TryMove(mo, mo->x + newx, mo->y + newy);
#line 762
    if (! tmp___0) {
#line 763
      goto stairstep;
    }
  }
#line 768
  bestslidefrac = (1 << 16) - (bestslidefrac + 0x800);
#line 770
  if (bestslidefrac > 1 << 16) {
#line 771
    bestslidefrac = 1 << 16;
  }
#line 773
  if (bestslidefrac <= 0) {
#line 774
    return;
  }
#line 776
  tmxmove = FixedMul(mo->momx, bestslidefrac);
#line 777
  tmymove = FixedMul(mo->momy, bestslidefrac);
#line 779
  P_HitSlideLine(bestslideline);
#line 781
  mo->momx = tmxmove;
#line 782
  mo->momy = tmymove;
#line 784
  tmp___1 = P_TryMove(mo, mo->x + tmxmove, mo->y + tmymove);
#line 784
  if (! tmp___1) {
#line 786
    goto retry;
  }
#line 788
  return;
}
}
#line 795 "p_map.c"
mobj_t *shootthing  ;
#line 799 "p_map.c"
fixed_t shootz  ;
#line 801 "p_map.c"
int la_damage  ;
#line 802 "p_map.c"
fixed_t attackrange  ;
#line 804 "p_map.c"
fixed_t aimslope  ;
#line 807
fixed_t topslope ;
#line 808
fixed_t bottomslope ;
#line 815 "p_map.c"
boolean PTR_AimTraverse(intercept_t *in ) 
{ 
  line_t *li ;
  mobj_t *th ;
  fixed_t slope ;
  fixed_t thingtopslope ;
  fixed_t thingbottomslope ;
  fixed_t dist ;

  {
#line 825
  if (in->isaline) {
#line 827
    li = in->d.line;
#line 829
    if (! ((int )li->flags & 4)) {
#line 830
      return ((boolean )0);
    }
#line 835
    P_LineOpening(li);
#line 837
    if (openbottom >= opentop) {
#line 838
      return ((boolean )0);
    }
#line 840
    dist = FixedMul(attackrange, in->frac);
#line 842
    if ((li->frontsector)->floorheight != (li->backsector)->floorheight) {
#line 844
      slope = FixedDiv(openbottom - shootz, dist);
#line 845
      if (slope > bottomslope) {
#line 846
        bottomslope = slope;
      }
    }
#line 849
    if ((li->frontsector)->ceilingheight != (li->backsector)->ceilingheight) {
#line 851
      slope = FixedDiv(opentop - shootz, dist);
#line 852
      if (slope < topslope) {
#line 853
        topslope = slope;
      }
    }
#line 856
    if (topslope <= bottomslope) {
#line 857
      return ((boolean )0);
    }
#line 859
    return ((boolean )1);
  }
#line 863
  th = in->d.thing;
#line 864
  if ((unsigned long )th == (unsigned long )shootthing) {
#line 865
    return ((boolean )1);
  }
#line 867
  if (! (th->flags & 4)) {
#line 868
    return ((boolean )1);
  }
#line 871
  dist = FixedMul(attackrange, in->frac);
#line 872
  thingtopslope = FixedDiv((th->z + th->height) - shootz, dist);
#line 874
  if (thingtopslope < bottomslope) {
#line 875
    return ((boolean )1);
  }
#line 877
  thingbottomslope = FixedDiv(th->z - shootz, dist);
#line 879
  if (thingbottomslope > topslope) {
#line 880
    return ((boolean )1);
  }
#line 883
  if (thingtopslope > topslope) {
#line 884
    thingtopslope = topslope;
  }
#line 886
  if (thingbottomslope < bottomslope) {
#line 887
    thingbottomslope = bottomslope;
  }
#line 889
  aimslope = (thingtopslope + thingbottomslope) / 2;
#line 890
  linetarget = th;
#line 892
  return ((boolean )0);
}
}
#line 899 "p_map.c"
boolean PTR_ShootTraverse(intercept_t *in ) 
{ 
  fixed_t x___0 ;
  fixed_t y___1 ;
  fixed_t z ;
  fixed_t frac ;
  line_t *li ;
  mobj_t *th ;
  fixed_t slope ;
  fixed_t dist ;
  fixed_t thingtopslope ;
  fixed_t thingbottomslope ;
  fixed_t tmp ;
  fixed_t tmp___0 ;
  fixed_t tmp___1 ;
  fixed_t tmp___2 ;
  fixed_t tmp___3 ;
  fixed_t tmp___4 ;
  fixed_t tmp___5 ;
  fixed_t tmp___6 ;
  fixed_t tmp___7 ;
  fixed_t tmp___8 ;

  {
#line 915
  if (in->isaline) {
#line 917
    li = in->d.line;
#line 919
    if (li->special) {
#line 920
      P_ShootSpecialLine(shootthing, li);
    }
#line 922
    if (! ((int )li->flags & 4)) {
#line 923
      goto hitline;
    }
#line 926
    P_LineOpening(li);
#line 928
    dist = FixedMul(attackrange, in->frac);
#line 930
    if ((li->frontsector)->floorheight != (li->backsector)->floorheight) {
#line 932
      slope = FixedDiv(openbottom - shootz, dist);
#line 933
      if (slope > aimslope) {
#line 934
        goto hitline;
      }
    }
#line 937
    if ((li->frontsector)->ceilingheight != (li->backsector)->ceilingheight) {
#line 939
      slope = FixedDiv(opentop - shootz, dist);
#line 940
      if (slope < aimslope) {
#line 941
        goto hitline;
      }
    }
#line 945
    return ((boolean )1);
    hitline: 
#line 951
    tmp = FixedDiv(4 * (1 << 16), attackrange);
#line 951
    frac = in->frac - tmp;
#line 952
    tmp___0 = FixedMul(trace.dx, frac);
#line 952
    x___0 = trace.x + tmp___0;
#line 953
    tmp___1 = FixedMul(trace.dy, frac);
#line 953
    y___1 = trace.y + tmp___1;
#line 954
    tmp___2 = FixedMul(frac, attackrange);
#line 954
    tmp___3 = FixedMul(aimslope, tmp___2);
#line 954
    z = shootz + tmp___3;
#line 956
    if ((int )(li->frontsector)->ceilingpic == skyflatnum) {
#line 959
      if (z > (li->frontsector)->ceilingheight) {
#line 960
        return ((boolean )0);
      }
#line 963
      if (li->backsector) {
#line 963
        if ((int )(li->backsector)->ceilingpic == skyflatnum) {
#line 964
          return ((boolean )0);
        } else {
#line 963
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
    }
#line 968
    P_SpawnPuff(x___0, y___1, z);
#line 971
    return ((boolean )0);
  }
#line 975
  th = in->d.thing;
#line 976
  if ((unsigned long )th == (unsigned long )shootthing) {
#line 977
    return ((boolean )1);
  }
#line 979
  if (! (th->flags & 4)) {
#line 980
    return ((boolean )1);
  }
#line 983
  dist = FixedMul(attackrange, in->frac);
#line 984
  thingtopslope = FixedDiv((th->z + th->height) - shootz, dist);
#line 986
  if (thingtopslope < aimslope) {
#line 987
    return ((boolean )1);
  }
#line 989
  thingbottomslope = FixedDiv(th->z - shootz, dist);
#line 991
  if (thingbottomslope > aimslope) {
#line 992
    return ((boolean )1);
  }
#line 997
  tmp___4 = FixedDiv(10 * (1 << 16), attackrange);
#line 997
  frac = in->frac - tmp___4;
#line 999
  tmp___5 = FixedMul(trace.dx, frac);
#line 999
  x___0 = trace.x + tmp___5;
#line 1000
  tmp___6 = FixedMul(trace.dy, frac);
#line 1000
  y___1 = trace.y + tmp___6;
#line 1001
  tmp___7 = FixedMul(frac, attackrange);
#line 1001
  tmp___8 = FixedMul(aimslope, tmp___7);
#line 1001
  z = shootz + tmp___8;
#line 1005
  if ((in->d.thing)->flags & 524288) {
#line 1006
    P_SpawnPuff(x___0, y___1, z);
  } else {
#line 1008
    P_SpawnBlood(x___0, y___1, z, la_damage);
  }
#line 1010
  if (la_damage) {
#line 1011
    P_DamageMobj(th, shootthing, shootthing, la_damage);
  }
#line 1014
  return ((boolean )0);
}
}
#line 1022 "p_map.c"
fixed_t P_AimLineAttack(mobj_t *t1 , angle_t angle , fixed_t distance ) 
{ 
  fixed_t x2 ;
  fixed_t y2 ;

  {
#line 1031
  angle >>= 19;
#line 1032
  shootthing = t1;
#line 1034
  x2 = t1->x + (distance >> 16) * *(finecosine + angle);
#line 1035
  y2 = t1->y + (distance >> 16) * finesine[angle];
#line 1036
  shootz = (t1->z + (t1->height >> 1)) + 8 * (1 << 16);
#line 1039
  topslope = (100 * (1 << 16)) / 160;
#line 1040
  bottomslope = (-100 * (1 << 16)) / 160;
#line 1042
  attackrange = distance;
#line 1043
  linetarget = (mobj_t *)((void *)0);
#line 1045
  P_PathTraverse(t1->x, t1->y, x2, y2, 3, & PTR_AimTraverse);
#line 1050
  if (linetarget) {
#line 1051
    return (aimslope);
  }
#line 1053
  return (0);
}
}
#line 1062 "p_map.c"
void P_LineAttack(mobj_t *t1 , angle_t angle , fixed_t distance , fixed_t slope ,
                  int damage ) 
{ 
  fixed_t x2 ;
  fixed_t y2 ;

  {
#line 1073
  angle >>= 19;
#line 1074
  shootthing = t1;
#line 1075
  la_damage = damage;
#line 1076
  x2 = t1->x + (distance >> 16) * *(finecosine + angle);
#line 1077
  y2 = t1->y + (distance >> 16) * finesine[angle];
#line 1078
  shootz = (t1->z + (t1->height >> 1)) + 8 * (1 << 16);
#line 1079
  attackrange = distance;
#line 1080
  aimslope = slope;
#line 1082
  P_PathTraverse(t1->x, t1->y, x2, y2, 3, & PTR_ShootTraverse);
#line 1086
  return;
}
}
#line 1093 "p_map.c"
mobj_t *usething  ;
#line 1095 "p_map.c"
boolean PTR_UseTraverse(intercept_t *in ) 
{ 
  int side ;
  int tmp ;

  {
#line 1099
  if (! (in->d.line)->special) {
#line 1101
    P_LineOpening(in->d.line);
#line 1102
    if (openrange <= 0) {
#line 1104
      S_StartSound((void *)usething, 81);
#line 1107
      return ((boolean )0);
    }
#line 1110
    return ((boolean )1);
  }
#line 1113
  side = 0;
#line 1114
  tmp = P_PointOnLineSide(usething->x, usething->y, in->d.line);
#line 1114
  if (tmp == 1) {
#line 1115
    side = 1;
  }
#line 1119
  P_UseSpecialLine(usething, in->d.line, side);
#line 1122
  return ((boolean )0);
}
}
#line 1130 "p_map.c"
void P_UseLines(player_t *player ) 
{ 
  int angle ;
  fixed_t x1 ;
  fixed_t y1___0 ;
  fixed_t x2 ;
  fixed_t y2 ;

  {
#line 1138
  usething = player->mo;
#line 1140
  angle = (int )((player->mo)->angle >> 19);
#line 1142
  x1 = (player->mo)->x;
#line 1143
  y1___0 = (player->mo)->y;
#line 1144
  x2 = x1 + (64 * (1 << 16) >> 16) * *(finecosine + angle);
#line 1145
  y2 = y1___0 + (64 * (1 << 16) >> 16) * finesine[angle];
#line 1147
  P_PathTraverse(x1, y1___0, x2, y2, 1, & PTR_UseTraverse);
#line 1148
  return;
}
}
#line 1154 "p_map.c"
mobj_t *bombsource  ;
#line 1155 "p_map.c"
mobj_t *bombspot  ;
#line 1156 "p_map.c"
int bombdamage  ;
#line 1164 "p_map.c"
boolean PIT_RadiusAttack(mobj_t *thing ) 
{ 
  fixed_t dx ;
  fixed_t dy ;
  fixed_t dist ;
  boolean tmp ;

  {
#line 1170
  if (! (thing->flags & 4)) {
#line 1171
    return ((boolean )1);
  }
#line 1175
  if ((unsigned int )thing->type == 21U) {
#line 1175
    goto _L;
  } else
#line 1175
  if ((unsigned int )thing->type == 19U) {
    _L: /* CIL Label */ 
#line 1177
    return ((boolean )1);
  }
#line 1179
  dx = abs(thing->x - bombspot->x);
#line 1180
  dy = abs(thing->y - bombspot->y);
#line 1182
  if (dx > dy) {
#line 1182
    dist = dx;
  } else {
#line 1182
    dist = dy;
  }
#line 1183
  dist = (dist - thing->radius) >> 16;
#line 1185
  if (dist < 0) {
#line 1186
    dist = 0;
  }
#line 1188
  if (dist >= bombdamage) {
#line 1189
    return ((boolean )1);
  }
#line 1191
  tmp = P_CheckSight(thing, bombspot);
#line 1191
  if (tmp) {
#line 1194
    P_DamageMobj(thing, bombspot, bombsource, bombdamage - dist);
  }
#line 1197
  return ((boolean )1);
}
}
#line 1205 "p_map.c"
void P_RadiusAttack(mobj_t *spot , mobj_t *source , int damage ) 
{ 
  int x___0 ;
  int y___1 ;
  int xl ;
  int xh ;
  int yl ;
  int yh ;
  fixed_t dist ;

  {
#line 1221
  dist = (damage + 32 * (1 << 16)) << 16;
#line 1222
  yh = ((spot->y + dist) - bmaporgy) >> 23;
#line 1223
  yl = ((spot->y - dist) - bmaporgy) >> 23;
#line 1224
  xh = ((spot->x + dist) - bmaporgx) >> 23;
#line 1225
  xl = ((spot->x - dist) - bmaporgx) >> 23;
#line 1226
  bombspot = spot;
#line 1227
  bombsource = source;
#line 1228
  bombdamage = damage;
#line 1230
  y___1 = yl;
  {
#line 1230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1230
    if (! (y___1 <= yh)) {
#line 1230
      goto while_break;
    }
#line 1231
    x___0 = xl;
    {
#line 1231
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1231
      if (! (x___0 <= xh)) {
#line 1231
        goto while_break___0;
      }
#line 1232
      P_BlockThingsIterator(x___0, y___1, & PIT_RadiusAttack);
#line 1231
      x___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1230
    y___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1233
  return;
}
}
#line 1250 "p_map.c"
boolean crushchange  ;
#line 1251 "p_map.c"
boolean nofit  ;
#line 1257 "p_map.c"
boolean PIT_ChangeSector(mobj_t *thing ) 
{ 
  mobj_t *mo ;
  boolean tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1261
  tmp = P_ThingHeightClip(thing);
#line 1261
  if (tmp) {
#line 1264
    return ((boolean )1);
  }
#line 1269
  if (thing->health <= 0) {
#line 1271
    P_SetMobjState(thing, (statenum_t )895);
#line 1273
    thing->flags &= -3;
#line 1274
    thing->height = 0;
#line 1275
    thing->radius = 0;
#line 1278
    return ((boolean )1);
  }
#line 1282
  if (thing->flags & 131072) {
#line 1284
    P_RemoveMobj(thing);
#line 1287
    return ((boolean )1);
  }
#line 1290
  if (! (thing->flags & 4)) {
#line 1293
    return ((boolean )1);
  }
#line 1296
  nofit = (boolean )1;
#line 1298
  if (crushchange) {
#line 1298
    if (! (leveltime & 3)) {
#line 1300
      P_DamageMobj(thing, (mobj_t *)((void *)0), (mobj_t *)((void *)0), 10);
#line 1303
      mo = P_SpawnMobj(thing->x, thing->y, thing->z + thing->height / 2, (mobjtype_t )38);
#line 1307
      tmp___0 = P_Random();
#line 1307
      tmp___1 = P_Random();
#line 1307
      mo->momx = (tmp___0 - tmp___1) << 12;
#line 1308
      tmp___2 = P_Random();
#line 1308
      tmp___3 = P_Random();
#line 1308
      mo->momy = (tmp___2 - tmp___3) << 12;
    } else {
#line 1298
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 1312
  return ((boolean )1);
}
}
#line 1320 "p_map.c"
boolean P_ChangeSector(sector_t *sector , boolean crunch ) 
{ 
  int x___0 ;
  int y___1 ;

  {
#line 1328
  nofit = (boolean )0;
#line 1329
  crushchange = crunch;
#line 1332
  x___0 = sector->blockbox[2];
  {
#line 1332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1332
    if (! (x___0 <= sector->blockbox[3])) {
#line 1332
      goto while_break;
    }
#line 1333
    y___1 = sector->blockbox[1];
    {
#line 1333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1333
      if (! (y___1 <= sector->blockbox[0])) {
#line 1333
        goto while_break___0;
      }
#line 1334
      P_BlockThingsIterator(x___0, y___1, & PIT_ChangeSector);
#line 1333
      y___1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1332
    x___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1337
  return (nofit);
}
}
#line 27 "p_maputl.c"
static char const   rcsid___29[51]  = 
#line 27 "p_maputl.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'m', 
        (char const   )'a',      (char const   )'p',      (char const   )'u',      (char const   )'t', 
        (char const   )'l',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )' ',      (char const   )'2',      (char const   )'2',      (char const   )':', 
        (char const   )'4',      (char const   )'5',      (char const   )':',      (char const   )'1', 
        (char const   )'1',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 156 "p_local.h"
intercept_t intercepts[128]  ;
#line 157 "p_local.h"
intercept_t *intercept_p  ;
#line 168 "p_local.h"
fixed_t opentop  ;
#line 169 "p_local.h"
fixed_t openbottom  ;
#line 170 "p_local.h"
fixed_t openrange  ;
#line 171 "p_local.h"
fixed_t lowfloor  ;
#line 182 "p_local.h"
divline_t trace  ;
#line 48 "p_maputl.c"
fixed_t P_AproxDistance(fixed_t dx , fixed_t dy ) 
{ 


  {
#line 53
  dx = abs(dx);
#line 54
  dy = abs(dy);
#line 55
  if (dx < dy) {
#line 56
    return ((dx + dy) - (dx >> 1));
  }
#line 57
  return ((dx + dy) - (dy >> 1));
}
}
#line 65 "p_maputl.c"
int P_PointOnLineSide(fixed_t x___0 , fixed_t y___1 , line_t *line ) 
{ 
  fixed_t dx ;
  fixed_t dy ;
  fixed_t left ;
  fixed_t right ;

  {
#line 76
  if (! line->dx) {
#line 78
    if (x___0 <= (line->v1)->x) {
#line 79
      return (line->dy > 0);
    }
#line 81
    return (line->dy < 0);
  }
#line 83
  if (! line->dy) {
#line 85
    if (y___1 <= (line->v1)->y) {
#line 86
      return (line->dx < 0);
    }
#line 88
    return (line->dx > 0);
  }
#line 91
  dx = x___0 - (line->v1)->x;
#line 92
  dy = y___1 - (line->v1)->y;
#line 94
  left = FixedMul(line->dy >> 16, dx);
#line 95
  right = FixedMul(dy, line->dx >> 16);
#line 97
  if (right < left) {
#line 98
    return (0);
  }
#line 99
  return (1);
}
}
#line 109 "p_maputl.c"
int P_BoxOnLineSide(fixed_t *tmbox , line_t *ld ) 
{ 
  int p1 ;
  int p2 ;

  {
  {
#line 119
  if ((unsigned int )ld->slopetype == 0U) {
#line 119
    goto case_0;
  }
#line 129
  if ((unsigned int )ld->slopetype == 1U) {
#line 129
    goto case_1;
  }
#line 139
  if ((unsigned int )ld->slopetype == 2U) {
#line 139
    goto case_2;
  }
#line 144
  if ((unsigned int )ld->slopetype == 3U) {
#line 144
    goto case_3;
  }
#line 117
  goto switch_break;
  case_0: /* CIL Label */ 
#line 120
  p1 = *(tmbox + 0) > (ld->v1)->y;
#line 121
  p2 = *(tmbox + 1) > (ld->v1)->y;
#line 122
  if (ld->dx < 0) {
#line 124
    p1 ^= 1;
#line 125
    p2 ^= 1;
  }
#line 127
  goto switch_break;
  case_1: /* CIL Label */ 
#line 130
  p1 = *(tmbox + 3) < (ld->v1)->x;
#line 131
  p2 = *(tmbox + 2) < (ld->v1)->x;
#line 132
  if (ld->dy < 0) {
#line 134
    p1 ^= 1;
#line 135
    p2 ^= 1;
  }
#line 137
  goto switch_break;
  case_2: /* CIL Label */ 
#line 140
  p1 = P_PointOnLineSide(*(tmbox + 2), *(tmbox + 0), ld);
#line 141
  p2 = P_PointOnLineSide(*(tmbox + 3), *(tmbox + 1), ld);
#line 142
  goto switch_break;
  case_3: /* CIL Label */ 
#line 145
  p1 = P_PointOnLineSide(*(tmbox + 3), *(tmbox + 0), ld);
#line 146
  p2 = P_PointOnLineSide(*(tmbox + 2), *(tmbox + 1), ld);
#line 147
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 150
  if (p1 == p2) {
#line 151
    return (p1);
  }
#line 152
  return (-1);
}
}
#line 160 "p_maputl.c"
int P_PointOnDivlineSide(fixed_t x___0 , fixed_t y___1 , divline_t *line ) 
{ 
  fixed_t dx ;
  fixed_t dy ;
  fixed_t left ;
  fixed_t right ;

  {
#line 171
  if (! line->dx) {
#line 173
    if (x___0 <= line->x) {
#line 174
      return (line->dy > 0);
    }
#line 176
    return (line->dy < 0);
  }
#line 178
  if (! line->dy) {
#line 180
    if (y___1 <= line->y) {
#line 181
      return (line->dx < 0);
    }
#line 183
    return (line->dx > 0);
  }
#line 186
  dx = x___0 - line->x;
#line 187
  dy = y___1 - line->y;
#line 190
  if ((unsigned int )(((line->dy ^ line->dx) ^ dx) ^ dy) & 0x80000000) {
#line 192
    if ((unsigned int )(line->dy ^ dx) & 0x80000000) {
#line 193
      return (1);
    }
#line 194
    return (0);
  }
#line 197
  left = FixedMul(line->dy >> 8, dx >> 8);
#line 198
  right = FixedMul(dy >> 8, line->dx >> 8);
#line 200
  if (right < left) {
#line 201
    return (0);
  }
#line 202
  return (1);
}
}
#line 210 "p_maputl.c"
void P_MakeDivline(line_t *li , divline_t *dl ) 
{ 


  {
#line 215
  dl->x = (li->v1)->x;
#line 216
  dl->y = (li->v1)->y;
#line 217
  dl->dx = li->dx;
#line 218
  dl->dy = li->dy;
#line 219
  return;
}
}
#line 230 "p_maputl.c"
fixed_t P_InterceptVector(divline_t *v2 , divline_t *v1 ) 
{ 
  fixed_t frac ;
  fixed_t num___0 ;
  fixed_t den ;
  fixed_t tmp ;
  fixed_t tmp___0 ;
  fixed_t tmp___1 ;
  fixed_t tmp___2 ;

  {
#line 240
  tmp = FixedMul(v1->dy >> 8, v2->dx);
#line 240
  tmp___0 = FixedMul(v1->dx >> 8, v2->dy);
#line 240
  den = tmp - tmp___0;
#line 242
  if (den == 0) {
#line 243
    return (0);
  }
#line 246
  tmp___1 = FixedMul((v1->x - v2->x) >> 8, v1->dy);
#line 246
  tmp___2 = FixedMul((v2->y - v1->y) >> 8, v1->dx);
#line 246
  num___0 = tmp___1 + tmp___2;
#line 250
  frac = FixedDiv(num___0, den);
#line 252
  return (frac);
}
}
#line 300 "p_maputl.c"
void P_LineOpening(line_t *linedef___0 ) 
{ 
  sector_t *front ;
  sector_t *back ;

  {
#line 305
  if ((int )linedef___0->sidenum[1] == -1) {
#line 308
    openrange = 0;
#line 309
    return;
  }
#line 312
  front = linedef___0->frontsector;
#line 313
  back = linedef___0->backsector;
#line 315
  if (front->ceilingheight < back->ceilingheight) {
#line 316
    opentop = front->ceilingheight;
  } else {
#line 318
    opentop = back->ceilingheight;
  }
#line 320
  if (front->floorheight > back->floorheight) {
#line 322
    openbottom = front->floorheight;
#line 323
    lowfloor = back->floorheight;
  } else {
#line 327
    openbottom = back->floorheight;
#line 328
    lowfloor = front->floorheight;
  }
#line 331
  openrange = opentop - openbottom;
#line 332
  return;
}
}
#line 347 "p_maputl.c"
void P_UnsetThingPosition(mobj_t *thing ) 
{ 
  int blockx ;
  int blocky ;

  {
#line 352
  if (! (thing->flags & 8)) {
#line 356
    if (thing->snext) {
#line 357
      (thing->snext)->sprev = thing->sprev;
    }
#line 359
    if (thing->sprev) {
#line 360
      (thing->sprev)->snext = thing->snext;
    } else {
#line 362
      ((thing->subsector)->sector)->thinglist = thing->snext;
    }
  }
#line 365
  if (! (thing->flags & 16)) {
#line 369
    if (thing->bnext) {
#line 370
      (thing->bnext)->bprev = thing->bprev;
    }
#line 372
    if (thing->bprev) {
#line 373
      (thing->bprev)->bnext = thing->bnext;
    } else {
#line 376
      blockx = (thing->x - bmaporgx) >> 23;
#line 377
      blocky = (thing->y - bmaporgy) >> 23;
#line 379
      if (blockx >= 0) {
#line 379
        if (blockx < bmapwidth) {
#line 379
          if (blocky >= 0) {
#line 379
            if (blocky < bmapheight) {
#line 382
              *(blocklinks + (blocky * bmapwidth + blockx)) = thing->bnext;
            } else {
#line 379
              goto _L___1;
            }
          } else {
#line 379
            goto _L___1;
          }
        } else {
#line 379
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        _L___0: /* CIL Label */ 
        _L: /* CIL Label */ ;
      }
    }
  }
#line 386
  return;
}
}
#line 395 "p_maputl.c"
void P_SetThingPosition(mobj_t *thing ) 
{ 
  subsector_t *ss ;
  sector_t *sec ;
  int blockx ;
  int blocky ;
  mobj_t **link___0 ;
  struct mobj_s *tmp ;

  {
#line 406
  ss = R_PointInSubsector(thing->x, thing->y);
#line 407
  thing->subsector = ss;
#line 409
  if (! (thing->flags & 8)) {
#line 412
    sec = ss->sector;
#line 414
    thing->sprev = (struct mobj_s *)((void *)0);
#line 415
    thing->snext = sec->thinglist;
#line 417
    if (sec->thinglist) {
#line 418
      (sec->thinglist)->sprev = thing;
    }
#line 420
    sec->thinglist = thing;
  }
#line 425
  if (! (thing->flags & 16)) {
#line 428
    blockx = (thing->x - bmaporgx) >> 23;
#line 429
    blocky = (thing->y - bmaporgy) >> 23;
#line 431
    if (blockx >= 0) {
#line 431
      if (blockx < bmapwidth) {
#line 431
        if (blocky >= 0) {
#line 431
          if (blocky < bmapheight) {
#line 436
            link___0 = blocklinks + (blocky * bmapwidth + blockx);
#line 437
            thing->bprev = (struct mobj_s *)((void *)0);
#line 438
            thing->bnext = *link___0;
#line 439
            if (*link___0) {
#line 440
              (*link___0)->bprev = thing;
            }
#line 442
            *link___0 = thing;
          } else {
#line 431
            goto _L___1;
          }
        } else {
#line 431
          goto _L___1;
        }
      } else {
#line 431
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 447
      tmp = (struct mobj_s *)((void *)0);
#line 447
      thing->bprev = tmp;
#line 447
      thing->bnext = tmp;
    }
  }
#line 450
  return;
}
}
#line 471 "p_maputl.c"
boolean P_BlockLinesIterator(int x___0 , int y___1 , boolean (*func)(line_t * ) ) 
{ 
  int offset ;
  short *list ;
  line_t *ld ;
  boolean tmp ;

  {
#line 481
  if (x___0 < 0) {
#line 481
    goto _L___1;
  } else
#line 481
  if (y___1 < 0) {
    _L___1: /* CIL Label */ 
#line 481
    goto _L___0;
  } else
#line 481
  if (x___0 >= bmapwidth) {
    _L___0: /* CIL Label */ 
#line 481
    goto _L;
  } else
#line 481
  if (y___1 >= bmapheight) {
    _L: /* CIL Label */ 
#line 486
    return ((boolean )1);
  }
#line 489
  offset = y___1 * bmapwidth + x___0;
#line 491
  offset = (int )*(blockmap + offset);
#line 493
  list = blockmaplump + offset;
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! ((int )*list != -1)) {
#line 493
      goto while_break;
    }
#line 495
    ld = lines + *list;
#line 497
    if (ld->validcount == validcount) {
#line 498
      goto __Cont;
    }
#line 500
    ld->validcount = validcount;
#line 502
    tmp = (*func)(ld);
#line 502
    if (! tmp) {
#line 503
      return ((boolean )0);
    }
    __Cont: /* CIL Label */ 
#line 493
    list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  return ((boolean )1);
}
}
#line 512 "p_maputl.c"
boolean P_BlockThingsIterator(int x___0 , int y___1 , boolean (*func)(mobj_t * ) ) 
{ 
  mobj_t *mobj ;
  boolean tmp ;

  {
#line 520
  if (x___0 < 0) {
#line 520
    goto _L___1;
  } else
#line 520
  if (y___1 < 0) {
    _L___1: /* CIL Label */ 
#line 520
    goto _L___0;
  } else
#line 520
  if (x___0 >= bmapwidth) {
    _L___0: /* CIL Label */ 
#line 520
    goto _L;
  } else
#line 520
  if (y___1 >= bmapheight) {
    _L: /* CIL Label */ 
#line 525
    return ((boolean )1);
  }
#line 529
  mobj = *(blocklinks + (y___1 * bmapwidth + x___0));
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! mobj) {
#line 529
      goto while_break;
    }
#line 533
    tmp = (*func)(mobj);
#line 533
    if (! tmp) {
#line 534
      return ((boolean )0);
    }
#line 529
    mobj = mobj->bnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  return ((boolean )1);
}
}
#line 548 "p_maputl.c"
boolean earlyout  ;
#line 549 "p_maputl.c"
int ptflags  ;
#line 561 "p_maputl.c"
boolean PIT_AddLineIntercepts(line_t *ld ) 
{ 
  int s1 ;
  int s2 ;
  fixed_t frac ;
  divline_t dl ;

  {
#line 570
  if (trace.dx > (1 << 16) * 16) {
#line 570
    goto _L___1;
  } else
#line 570
  if (trace.dy > (1 << 16) * 16) {
    _L___1: /* CIL Label */ 
#line 570
    goto _L___0;
  } else
#line 570
  if (trace.dx < - (1 << 16) * 16) {
    _L___0: /* CIL Label */ 
#line 570
    goto _L;
  } else
#line 570
  if (trace.dy < - (1 << 16) * 16) {
    _L: /* CIL Label */ 
#line 575
    s1 = P_PointOnDivlineSide((ld->v1)->x, (ld->v1)->y, & trace);
#line 576
    s2 = P_PointOnDivlineSide((ld->v2)->x, (ld->v2)->y, & trace);
  } else {
#line 580
    s1 = P_PointOnLineSide(trace.x, trace.y, ld);
#line 581
    s2 = P_PointOnLineSide(trace.x + trace.dx, trace.y + trace.dy, ld);
  }
#line 584
  if (s1 == s2) {
#line 585
    return ((boolean )1);
  }
#line 588
  P_MakeDivline(ld, & dl);
#line 589
  frac = P_InterceptVector(& trace, & dl);
#line 591
  if (frac < 0) {
#line 592
    return ((boolean )1);
  }
#line 595
  if (earlyout) {
#line 595
    if (frac < 1 << 16) {
#line 595
      if (! ld->backsector) {
#line 599
        return ((boolean )0);
      } else {
#line 595
        goto _L___3;
      }
    } else {
#line 595
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    _L___2: /* CIL Label */ ;
  }
#line 603
  intercept_p->frac = frac;
#line 604
  intercept_p->isaline = (boolean )1;
#line 605
  intercept_p->d.line = ld;
#line 606
  intercept_p ++;
#line 608
  return ((boolean )1);
}
}
#line 616 "p_maputl.c"
boolean PIT_AddThingIntercepts(mobj_t *thing ) 
{ 
  fixed_t x1 ;
  fixed_t y1___0 ;
  fixed_t x2 ;
  fixed_t y2 ;
  int s1 ;
  int s2 ;
  boolean tracepositive ;
  divline_t dl ;
  fixed_t frac ;

  {
#line 632
  tracepositive = (boolean )((trace.dx ^ trace.dy) > 0);
#line 635
  if (tracepositive) {
#line 637
    x1 = thing->x - thing->radius;
#line 638
    y1___0 = thing->y + thing->radius;
#line 640
    x2 = thing->x + thing->radius;
#line 641
    y2 = thing->y - thing->radius;
  } else {
#line 645
    x1 = thing->x - thing->radius;
#line 646
    y1___0 = thing->y - thing->radius;
#line 648
    x2 = thing->x + thing->radius;
#line 649
    y2 = thing->y + thing->radius;
  }
#line 652
  s1 = P_PointOnDivlineSide(x1, y1___0, & trace);
#line 653
  s2 = P_PointOnDivlineSide(x2, y2, & trace);
#line 655
  if (s1 == s2) {
#line 656
    return ((boolean )1);
  }
#line 658
  dl.x = x1;
#line 659
  dl.y = y1___0;
#line 660
  dl.dx = x2 - x1;
#line 661
  dl.dy = y2 - y1___0;
#line 663
  frac = P_InterceptVector(& trace, & dl);
#line 665
  if (frac < 0) {
#line 666
    return ((boolean )1);
  }
#line 668
  intercept_p->frac = frac;
#line 669
  intercept_p->isaline = (boolean )0;
#line 670
  intercept_p->d.thing = thing;
#line 671
  intercept_p ++;
#line 673
  return ((boolean )1);
}
}
#line 682 "p_maputl.c"
boolean P_TraverseIntercepts(boolean (*func)(intercept_t *in ) , fixed_t maxfrac ) 
{ 
  int count ;
  fixed_t dist ;
  intercept_t *scan ;
  intercept_t *in ;
  boolean tmp ;
  int tmp___0 ;

  {
#line 692
  count = (int )(intercept_p - intercepts);
#line 694
  in = (intercept_t *)0;
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    tmp___0 = count;
#line 696
    count --;
#line 696
    if (! tmp___0) {
#line 696
      goto while_break;
    }
#line 698
    dist = 0x7fffffff;
#line 699
    scan = intercepts;
    {
#line 699
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 699
      if (! ((unsigned long )scan < (unsigned long )intercept_p)) {
#line 699
        goto while_break___0;
      }
#line 701
      if (scan->frac < dist) {
#line 703
        dist = scan->frac;
#line 704
        in = scan;
      }
#line 699
      scan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 708
    if (dist > maxfrac) {
#line 709
      return ((boolean )1);
    }
#line 723
    tmp = (*func)(in);
#line 723
    if (! tmp) {
#line 724
      return ((boolean )0);
    }
#line 726
    in->frac = 0x7fffffff;
  }
  while_break: /* CIL Label */ ;
  }
#line 729
  return ((boolean )1);
}
}
#line 742 "p_maputl.c"
boolean P_PathTraverse(fixed_t x1 , fixed_t y1___0 , fixed_t x2 , fixed_t y2 , int flags ,
                       boolean (*trav)(intercept_t * ) ) 
{ 
  fixed_t xt1 ;
  fixed_t yt1 ;
  fixed_t xt2 ;
  fixed_t yt2 ;
  fixed_t xstep ;
  fixed_t ystep ;
  fixed_t partial ;
  fixed_t xintercept ;
  fixed_t yintercept ;
  int mapx ;
  int mapy ;
  int mapxstep ;
  int mapystep ;
  int count ;
  int tmp ;
  int tmp___0 ;
  fixed_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  fixed_t tmp___4 ;
  boolean tmp___5 ;
  boolean tmp___6 ;
  boolean tmp___7 ;

  {
#line 772
  earlyout = (boolean )(flags & 4);
#line 774
  validcount ++;
#line 775
  intercept_p = intercepts;
#line 777
  if (((x1 - bmaporgx) & (128 * (1 << 16) - 1)) == 0) {
#line 778
    x1 += 1 << 16;
  }
#line 780
  if (((y1___0 - bmaporgy) & (128 * (1 << 16) - 1)) == 0) {
#line 781
    y1___0 += 1 << 16;
  }
#line 783
  trace.x = x1;
#line 784
  trace.y = y1___0;
#line 785
  trace.dx = x2 - x1;
#line 786
  trace.dy = y2 - y1___0;
#line 788
  x1 -= bmaporgx;
#line 789
  y1___0 -= bmaporgy;
#line 790
  xt1 = x1 >> 23;
#line 791
  yt1 = y1___0 >> 23;
#line 793
  x2 -= bmaporgx;
#line 794
  y2 -= bmaporgy;
#line 795
  xt2 = x2 >> 23;
#line 796
  yt2 = y2 >> 23;
#line 798
  if (xt2 > xt1) {
#line 800
    mapxstep = 1;
#line 801
    partial = (1 << 16) - ((x1 >> 7) & ((1 << 16) - 1));
#line 802
    tmp = abs(x2 - x1);
#line 802
    ystep = FixedDiv(y2 - y1___0, tmp);
  } else
#line 804
  if (xt2 < xt1) {
#line 806
    mapxstep = -1;
#line 807
    partial = (x1 >> 7) & ((1 << 16) - 1);
#line 808
    tmp___0 = abs(x2 - x1);
#line 808
    ystep = FixedDiv(y2 - y1___0, tmp___0);
  } else {
#line 812
    mapxstep = 0;
#line 813
    partial = 1 << 16;
#line 814
    ystep = 256 * (1 << 16);
  }
#line 817
  tmp___1 = FixedMul(partial, ystep);
#line 817
  yintercept = (y1___0 >> 7) + tmp___1;
#line 820
  if (yt2 > yt1) {
#line 822
    mapystep = 1;
#line 823
    partial = (1 << 16) - ((y1___0 >> 7) & ((1 << 16) - 1));
#line 824
    tmp___2 = abs(y2 - y1___0);
#line 824
    xstep = FixedDiv(x2 - x1, tmp___2);
  } else
#line 826
  if (yt2 < yt1) {
#line 828
    mapystep = -1;
#line 829
    partial = (y1___0 >> 7) & ((1 << 16) - 1);
#line 830
    tmp___3 = abs(y2 - y1___0);
#line 830
    xstep = FixedDiv(x2 - x1, tmp___3);
  } else {
#line 834
    mapystep = 0;
#line 835
    partial = 1 << 16;
#line 836
    xstep = 256 * (1 << 16);
  }
#line 838
  tmp___4 = FixedMul(partial, xstep);
#line 838
  xintercept = (x1 >> 7) + tmp___4;
#line 843
  mapx = xt1;
#line 844
  mapy = yt1;
#line 846
  count = 0;
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    if (! (count < 64)) {
#line 846
      goto while_break;
    }
#line 848
    if (flags & 1) {
#line 850
      tmp___5 = P_BlockLinesIterator(mapx, mapy, & PIT_AddLineIntercepts);
#line 850
      if (! tmp___5) {
#line 851
        return ((boolean )0);
      }
    }
#line 854
    if (flags & 2) {
#line 856
      tmp___6 = P_BlockThingsIterator(mapx, mapy, & PIT_AddThingIntercepts);
#line 856
      if (! tmp___6) {
#line 857
        return ((boolean )0);
      }
    }
#line 860
    if (mapx == xt2) {
#line 860
      if (mapy == yt2) {
#line 863
        goto while_break;
      } else {
#line 860
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 866
    if (yintercept >> 16 == mapy) {
#line 868
      yintercept += ystep;
#line 869
      mapx += mapxstep;
    } else
#line 871
    if (xintercept >> 16 == mapx) {
#line 873
      xintercept += xstep;
#line 874
      mapy += mapystep;
    }
#line 846
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 879
  tmp___7 = P_TraverseIntercepts(trav, 1 << 16);
#line 879
  return (tmp___7);
}
}
#line 24 "p_plats.c"
static char const   rcsid___30[50]  = 
#line 24 "p_plats.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'p', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'s', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )' ', 
        (char const   )'2',      (char const   )'2',      (char const   )':',      (char const   )'4', 
        (char const   )'5',      (char const   )':',      (char const   )'1',      (char const   )'2', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 309 "p_spec.h"
plat_t *activeplats[30]  ;
#line 52 "p_plats.c"
void T_PlatRaise(plat_t *plat ) 
{ 
  result_e res ;

  {
  {
#line 58
  if ((unsigned int )plat->status == 0U) {
#line 58
    goto case_0;
  }
#line 108
  if ((unsigned int )plat->status == 1U) {
#line 108
    goto case_1___0;
  }
#line 119
  if ((unsigned int )plat->status == 2U) {
#line 119
    goto case_2___0;
  }
#line 128
  if ((unsigned int )plat->status == 3U) {
#line 128
    goto case_3___0;
  }
#line 56
  goto switch_break;
  case_0: /* CIL Label */ 
#line 59
  res = T_MovePlane(plat->sector, plat->speed, plat->high, plat->crush, 0, 1);
#line 64
  if ((unsigned int )plat->type == 2U) {
#line 64
    goto _L;
  } else
#line 64
  if ((unsigned int )plat->type == 3U) {
    _L: /* CIL Label */ 
#line 67
    if (! (leveltime & 7)) {
#line 68
      S_StartSound((void *)((mobj_t *)(& (plat->sector)->soundorg)), 22);
    }
  }
#line 73
  if ((unsigned int )res == 1U) {
#line 73
    if (! plat->crush) {
#line 75
      plat->count = plat->wait;
#line 76
      plat->status = (plat_e )1;
#line 77
      S_StartSound((void *)((mobj_t *)(& (plat->sector)->soundorg)), 18);
    } else {
#line 73
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 82
  if ((unsigned int )res == 2U) {
#line 84
    plat->count = plat->wait;
#line 85
    plat->status = (plat_e )2;
#line 86
    S_StartSound((void *)((mobj_t *)(& (plat->sector)->soundorg)), 19);
    {
#line 92
    if ((unsigned int )plat->type == 1U) {
#line 92
      goto case_1;
    }
#line 92
    if ((unsigned int )plat->type == 4U) {
#line 92
      goto case_1;
    }
#line 97
    if ((unsigned int )plat->type == 3U) {
#line 97
      goto case_3;
    }
#line 97
    if ((unsigned int )plat->type == 2U) {
#line 97
      goto case_3;
    }
#line 101
    goto switch_default;
    case_1: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 93
    P_RemoveActivePlat(plat);
#line 94
    goto switch_break___0;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 98
    P_RemoveActivePlat(plat);
#line 99
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 102
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 106
  goto switch_break;
  case_1___0: /* CIL Label */ 
#line 109
  res = T_MovePlane(plat->sector, plat->speed, plat->low, (boolean )0, 0, -1);
#line 111
  if ((unsigned int )res == 2U) {
#line 113
    plat->count = plat->wait;
#line 114
    plat->status = (plat_e )2;
#line 115
    S_StartSound((void *)((mobj_t *)(& (plat->sector)->soundorg)), 19);
  }
#line 117
  goto switch_break;
  case_2___0: /* CIL Label */ 
#line 120
  (plat->count) --;
#line 120
  if (! plat->count) {
#line 122
    if ((plat->sector)->floorheight == plat->low) {
#line 123
      plat->status = (plat_e )0;
    } else {
#line 125
      plat->status = (plat_e )1;
    }
#line 126
    S_StartSound((void *)((mobj_t *)(& (plat->sector)->soundorg)), 18);
  }
  case_3___0: /* CIL Label */ 
#line 129
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 138 "p_plats.c"
int EV_DoPlat(line_t *line , plattype_e type , int amount ) 
{ 
  plat_t *plat ;
  int secnum ;
  int rtn ;
  sector_t *sec ;
  void *tmp ;
  int tmp___0 ;

  {
#line 149
  secnum = -1;
#line 150
  rtn = 0;
  {
#line 156
  if ((unsigned int )type == 0U) {
#line 156
    goto case_0;
  }
#line 160
  goto switch_default;
  case_0: /* CIL Label */ 
#line 157
  P_ActivateInStasis((int )line->tag);
#line 158
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 161
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    secnum = P_FindSectorFromLineTag(line, secnum);
#line 164
    if (! (secnum >= 0)) {
#line 164
      goto while_break;
    }
#line 166
    sec = sectors + secnum;
#line 168
    if (sec->specialdata) {
#line 169
      goto while_continue;
    }
#line 172
    rtn = 1;
#line 173
    tmp = Z_Malloc((int )sizeof(*plat), 51, (void *)0);
#line 173
    plat = (plat_t *)tmp;
#line 174
    P_AddThinker(& plat->thinker);
#line 176
    plat->type = type;
#line 177
    plat->sector = sec;
#line 178
    (plat->sector)->specialdata = (void *)plat;
#line 179
    plat->thinker.function.acp1 = (void (*)(void * ))(& T_PlatRaise);
#line 180
    plat->crush = (boolean )0;
#line 181
    plat->tag = (int )line->tag;
    {
#line 185
    if ((unsigned int )type == 3U) {
#line 185
      goto case_3;
    }
#line 197
    if ((unsigned int )type == 2U) {
#line 197
      goto case_2;
    }
#line 207
    if ((unsigned int )type == 1U) {
#line 207
      goto case_1;
    }
#line 220
    if ((unsigned int )type == 4U) {
#line 220
      goto case_4;
    }
#line 233
    if ((unsigned int )type == 0U) {
#line 233
      goto case_0___0;
    }
#line 183
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 186
    plat->speed = (1 << 16) / 2;
#line 187
    sec->floorpic = ((sides + line->sidenum[0])->sector)->floorpic;
#line 188
    plat->high = P_FindNextHighestFloor(sec, sec->floorheight);
#line 189
    plat->wait = 0;
#line 190
    plat->status = (plat_e )0;
#line 192
    sec->special = (short)0;
#line 194
    S_StartSound((void *)((mobj_t *)(& sec->soundorg)), 22);
#line 195
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 198
    plat->speed = (1 << 16) / 2;
#line 199
    sec->floorpic = ((sides + line->sidenum[0])->sector)->floorpic;
#line 200
    plat->high = sec->floorheight + amount * (1 << 16);
#line 201
    plat->wait = 0;
#line 202
    plat->status = (plat_e )0;
#line 204
    S_StartSound((void *)((mobj_t *)(& sec->soundorg)), 22);
#line 205
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 208
    plat->speed = (1 << 16) * 4;
#line 209
    plat->low = P_FindLowestFloorSurrounding(sec);
#line 211
    if (plat->low > sec->floorheight) {
#line 212
      plat->low = sec->floorheight;
    }
#line 214
    plat->high = sec->floorheight;
#line 215
    plat->wait = 105;
#line 216
    plat->status = (plat_e )1;
#line 217
    S_StartSound((void *)((mobj_t *)(& sec->soundorg)), 18);
#line 218
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 221
    plat->speed = (1 << 16) * 8;
#line 222
    plat->low = P_FindLowestFloorSurrounding(sec);
#line 224
    if (plat->low > sec->floorheight) {
#line 225
      plat->low = sec->floorheight;
    }
#line 227
    plat->high = sec->floorheight;
#line 228
    plat->wait = 105;
#line 229
    plat->status = (plat_e )1;
#line 230
    S_StartSound((void *)((mobj_t *)(& sec->soundorg)), 18);
#line 231
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 234
    plat->speed = 1 << 16;
#line 235
    plat->low = P_FindLowestFloorSurrounding(sec);
#line 237
    if (plat->low > sec->floorheight) {
#line 238
      plat->low = sec->floorheight;
    }
#line 240
    plat->high = P_FindHighestFloorSurrounding(sec);
#line 242
    if (plat->high < sec->floorheight) {
#line 243
      plat->high = sec->floorheight;
    }
#line 245
    plat->wait = 105;
#line 246
    tmp___0 = P_Random();
#line 246
    plat->status = (plat_e )(tmp___0 & 1);
#line 248
    S_StartSound((void *)((mobj_t *)(& sec->soundorg)), 18);
#line 249
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 251
    P_AddActivePlat(plat);
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (rtn);
}
}
#line 258 "p_plats.c"
void P_ActivateInStasis(int tag ) 
{ 
  int i ;

  {
#line 262
  i = 0;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! (i < 30)) {
#line 262
      goto while_break;
    }
#line 263
    if (activeplats[i]) {
#line 263
      if ((activeplats[i])->tag == tag) {
#line 263
        if ((unsigned int )(activeplats[i])->status == 3U) {
#line 267
          (activeplats[i])->status = (activeplats[i])->oldstatus;
#line 268
          (activeplats[i])->thinker.function.acp1 = (void (*)(void * ))(& T_PlatRaise);
        } else {
#line 263
          goto _L___0;
        }
      } else {
#line 263
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
#line 262
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  return;
}
}
#line 273 "p_plats.c"
void EV_StopPlat(line_t *line ) 
{ 
  int j ;

  {
#line 277
  j = 0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (j < 30)) {
#line 277
      goto while_break;
    }
#line 278
    if (activeplats[j]) {
#line 278
      if ((unsigned int )(activeplats[j])->status != 3U) {
#line 278
        if ((activeplats[j])->tag == (int )line->tag) {
#line 282
          (activeplats[j])->oldstatus = (activeplats[j])->status;
#line 283
          (activeplats[j])->status = (plat_e )3;
#line 284
          (activeplats[j])->thinker.function.acv = (void (*)())((void *)0);
        } else {
#line 278
          goto _L___0;
        }
      } else {
#line 278
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
#line 277
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return;
}
}
#line 288 "p_plats.c"
void P_AddActivePlat(plat_t *plat ) 
{ 
  int i ;

  {
#line 292
  i = 0;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! (i < 30)) {
#line 292
      goto while_break;
    }
#line 293
    if ((unsigned long )activeplats[i] == (unsigned long )((void *)0)) {
#line 295
      activeplats[i] = plat;
#line 296
      return;
    }
#line 292
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  I_Error("P_AddActivePlat: no more plats!");
#line 299
  return;
}
}
#line 301 "p_plats.c"
void P_RemoveActivePlat(plat_t *plat ) 
{ 
  int i ;

  {
#line 304
  i = 0;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < 30)) {
#line 304
      goto while_break;
    }
#line 305
    if ((unsigned long )plat == (unsigned long )activeplats[i]) {
#line 307
      ((activeplats[i])->sector)->specialdata = (void *)0;
#line 308
      P_RemoveThinker(& (activeplats[i])->thinker);
#line 309
      activeplats[i] = (plat_t *)((void *)0);
#line 311
      return;
    }
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  I_Error("P_RemoveActivePlat: can\'t find plat!");
#line 314
  return;
}
}
#line 25 "p_pspr.c"
static char const   rcsid___31[49]  = 
#line 25 "p_pspr.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'p', 
        (char const   )'s',      (char const   )'p',      (char const   )'r',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'2',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 58 "p_pspr.c"
void P_SetPsprite(player_t *player , int position , statenum_t stnum ) 
{ 
  pspdef_t *psp ;
  state_t *state___0 ;

  {
#line 67
  psp = & player->psprites[position];
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! stnum) {
#line 74
      psp->state = (state_t *)((void *)0);
#line 75
      goto while_break;
    }
#line 78
    state___0 = & states[stnum];
#line 79
    psp->state = state___0;
#line 80
    psp->tics = (int )state___0->tics;
#line 82
    if (state___0->misc1) {
#line 85
      psp->sx = (fixed_t )(state___0->misc1 << 16);
#line 86
      psp->sy = (fixed_t )(state___0->misc2 << 16);
    }
#line 91
    if (state___0->action.acp2) {
#line 93
      (*(state___0->action.acp2))((void *)player, (void *)psp);
#line 94
      if (! psp->state) {
#line 95
        goto while_break;
      }
    }
#line 98
    stnum = (psp->state)->nextstate;
#line 69
    if (! (! psp->tics)) {
#line 69
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 109 "p_pspr.c"
fixed_t swingx  ;
#line 110 "p_pspr.c"
fixed_t swingy  ;
#line 112 "p_pspr.c"
void P_CalcSwing(player_t *player ) 
{ 
  fixed_t swing ;
  int angle ;
  fixed_t tmp ;

  {
#line 121
  swing = player->bob;
#line 123
  angle = 117 * leveltime & 8191;
#line 124
  swingx = FixedMul(swing, finesine[angle]);
#line 126
  angle = (117 * leveltime + 4096) & 8191;
#line 127
  tmp = FixedMul(swingx, finesine[angle]);
#line 127
  swingy = - tmp;
#line 128
  return;
}
}
#line 138 "p_pspr.c"
void P_BringUpWeapon(player_t *player ) 
{ 
  statenum_t newstate ;

  {
#line 142
  if ((unsigned int )player->pendingweapon == 10U) {
#line 143
    player->pendingweapon = player->readyweapon;
  }
#line 145
  if ((unsigned int )player->pendingweapon == 7U) {
#line 146
    S_StartSound((void *)player->mo, 10);
  }
#line 148
  newstate = (statenum_t )weaponinfo[player->pendingweapon].upstate;
#line 150
  player->pendingweapon = (weapontype_t )10;
#line 151
  player->psprites[0].sy = 128 * (1 << 16);
#line 153
  P_SetPsprite(player, 0, newstate);
#line 154
  return;
}
}
#line 161 "p_pspr.c"
boolean P_CheckAmmo(player_t *player ) 
{ 
  ammotype_t ammo ;
  int count ;

  {
#line 166
  ammo = weaponinfo[player->readyweapon].ammo;
#line 169
  if ((unsigned int )player->readyweapon == 6U) {
#line 170
    count = 40;
  } else
#line 171
  if ((unsigned int )player->readyweapon == 8U) {
#line 172
    count = 2;
  } else {
#line 174
    count = 1;
  }
#line 178
  if ((unsigned int )ammo == 5U) {
#line 178
    goto _L;
  } else
#line 178
  if (player->ammo[ammo] >= count) {
    _L: /* CIL Label */ 
#line 179
    return ((boolean )1);
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (player->weaponowned[5]) {
#line 185
      if (player->ammo[2]) {
#line 185
        if ((unsigned int )gamemode != 0U) {
#line 189
          player->pendingweapon = (weapontype_t )5;
        } else {
#line 185
          goto _L___8;
        }
      } else {
#line 185
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
    _L___7: /* CIL Label */ 
#line 191
    if (player->weaponowned[8]) {
#line 191
      if (player->ammo[1] > 2) {
#line 191
        if ((unsigned int )gamemode == 2U) {
#line 195
          player->pendingweapon = (weapontype_t )8;
        } else {
#line 191
          goto _L___6;
        }
      } else {
#line 191
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
    _L___5: /* CIL Label */ 
#line 197
    if (player->weaponowned[3]) {
#line 197
      if (player->ammo[0]) {
#line 200
        player->pendingweapon = (weapontype_t )3;
      } else {
#line 197
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 202
    if (player->weaponowned[2]) {
#line 202
      if (player->ammo[1]) {
#line 205
        player->pendingweapon = (weapontype_t )2;
      } else {
#line 202
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 207
    if (player->ammo[0]) {
#line 209
      player->pendingweapon = (weapontype_t )1;
    } else
#line 211
    if (player->weaponowned[7]) {
#line 213
      player->pendingweapon = (weapontype_t )7;
    } else
#line 215
    if (player->weaponowned[4]) {
#line 215
      if (player->ammo[3]) {
#line 218
        player->pendingweapon = (weapontype_t )4;
      } else {
#line 215
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 220
    if (player->weaponowned[6]) {
#line 220
      if (player->ammo[2] > 40) {
#line 220
        if ((unsigned int )gamemode != 0U) {
#line 224
          player->pendingweapon = (weapontype_t )6;
        } else {
#line 220
          goto _L___1;
        }
      } else {
#line 220
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      _L___0: /* CIL Label */ 
#line 229
      player->pendingweapon = (weapontype_t )0;
    }
#line 183
    if (! ((unsigned int )player->pendingweapon == 10U)) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  P_SetPsprite(player, 0, (statenum_t )weaponinfo[player->readyweapon].downstate);
#line 239
  return ((boolean )0);
}
}
#line 246 "p_pspr.c"
void P_FireWeapon(player_t *player ) 
{ 
  statenum_t newstate ;
  boolean tmp ;

  {
#line 250
  tmp = P_CheckAmmo(player);
#line 250
  if (! tmp) {
#line 251
    return;
  }
#line 253
  P_SetMobjState(player->mo, (statenum_t )154);
#line 254
  newstate = (statenum_t )weaponinfo[player->readyweapon].atkstate;
#line 255
  P_SetPsprite(player, 0, newstate);
#line 256
  P_NoiseAlert(player->mo, player->mo);
#line 257
  return;
}
}
#line 265 "p_pspr.c"
void P_DropWeapon(player_t *player ) 
{ 


  {
#line 267
  P_SetPsprite(player, 0, (statenum_t )weaponinfo[player->readyweapon].downstate);
#line 270
  return;
}
}
#line 281 "p_pspr.c"
void A_WeaponReady(player_t *player , pspdef_t *psp ) 
{ 
  statenum_t newstate ;
  int angle ;
  fixed_t tmp ;
  fixed_t tmp___0 ;

  {
#line 290
  if ((unsigned long )(player->mo)->state == (unsigned long )(& states[154])) {
#line 290
    goto _L;
  } else
#line 290
  if ((unsigned long )(player->mo)->state == (unsigned long )(& states[155])) {
    _L: /* CIL Label */ 
#line 293
    P_SetMobjState(player->mo, (statenum_t )149);
  }
#line 296
  if ((unsigned int )player->readyweapon == 7U) {
#line 296
    if ((unsigned long )psp->state == (unsigned long )(& states[67])) {
#line 299
      S_StartSound((void *)player->mo, 11);
    } else {
#line 296
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 304
  if ((unsigned int )player->pendingweapon != 10U) {
#line 304
    goto _L___1;
  } else
#line 304
  if (! player->health) {
    _L___1: /* CIL Label */ 
#line 308
    newstate = (statenum_t )weaponinfo[player->readyweapon].downstate;
#line 309
    P_SetPsprite(player, 0, newstate);
#line 310
    return;
  }
#line 315
  if ((int )player->cmd.buttons & 1) {
#line 317
    if (! player->attackdown) {
#line 317
      goto _L___2;
    } else
#line 317
    if ((unsigned int )player->readyweapon != 4U) {
#line 317
      if ((unsigned int )player->readyweapon != 6U) {
        _L___2: /* CIL Label */ 
#line 321
        player->attackdown = 1;
#line 322
        P_FireWeapon(player);
#line 323
        return;
      } else {
#line 317
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ ;
    }
  } else {
#line 327
    player->attackdown = 0;
  }
#line 330
  angle = 128 * leveltime & 8191;
#line 331
  tmp = FixedMul(player->bob, *(finecosine + angle));
#line 331
  psp->sx = (1 << 16) + tmp;
#line 332
  angle &= 4095;
#line 333
  tmp___0 = FixedMul(player->bob, finesine[angle]);
#line 333
  psp->sy = 32 * (1 << 16) + tmp___0;
#line 334
  return;
}
}
#line 343 "p_pspr.c"
void A_ReFire(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 350
  if ((int )player->cmd.buttons & 1) {
#line 350
    if ((unsigned int )player->pendingweapon == 10U) {
#line 350
      if (player->health) {
#line 354
        (player->refire) ++;
#line 355
        P_FireWeapon(player);
      } else {
#line 350
        goto _L___0;
      }
    } else {
#line 350
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
#line 359
    player->refire = 0;
#line 360
    P_CheckAmmo(player);
  }
#line 362
  return;
}
}
#line 365 "p_pspr.c"
void A_CheckReload(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 370
  P_CheckAmmo(player);
#line 375
  return;
}
}
#line 384 "p_pspr.c"
void A_Lower(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 389
  psp->sy += (1 << 16) * 6;
#line 392
  if (psp->sy < 128 * (1 << 16)) {
#line 393
    return;
  }
#line 396
  if ((unsigned int )player->playerstate == 1U) {
#line 398
    psp->sy = 128 * (1 << 16);
#line 401
    return;
  }
#line 406
  if (! player->health) {
#line 409
    P_SetPsprite(player, 0, (statenum_t )0);
#line 410
    return;
  }
#line 413
  player->readyweapon = player->pendingweapon;
#line 415
  P_BringUpWeapon(player);
#line 416
  return;
}
}
#line 422 "p_pspr.c"
void A_Raise(player_t *player , pspdef_t *psp ) 
{ 
  statenum_t newstate ;

  {
#line 429
  psp->sy -= (1 << 16) * 6;
#line 431
  if (psp->sy > 32 * (1 << 16)) {
#line 432
    return;
  }
#line 434
  psp->sy = 32 * (1 << 16);
#line 438
  newstate = (statenum_t )weaponinfo[player->readyweapon].readystate;
#line 440
  P_SetPsprite(player, 0, newstate);
#line 441
  return;
}
}
#line 448 "p_pspr.c"
void A_GunFlash(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 453
  P_SetMobjState(player->mo, (statenum_t )155);
#line 454
  P_SetPsprite(player, 1, (statenum_t )weaponinfo[player->readyweapon].flashstate);
#line 455
  return;
}
}
#line 467 "p_pspr.c"
void A_Punch(player_t *player , pspdef_t *psp ) 
{ 
  angle_t angle ;
  int damage ;
  int slope ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 476
  tmp = P_Random();
#line 476
  damage = (tmp % 10 + 1) << 1;
#line 478
  if (player->powers[1]) {
#line 479
    damage *= 10;
  }
#line 481
  angle = (player->mo)->angle;
#line 482
  tmp___0 = P_Random();
#line 482
  tmp___1 = P_Random();
#line 482
  angle += (angle_t )((tmp___0 - tmp___1) << 18);
#line 483
  slope = P_AimLineAttack(player->mo, angle, 64 * (1 << 16));
#line 484
  P_LineAttack(player->mo, angle, 64 * (1 << 16), slope, damage);
#line 487
  if (linetarget) {
#line 489
    S_StartSound((void *)player->mo, 83);
#line 490
    (player->mo)->angle = R_PointToAngle2((player->mo)->x, (player->mo)->y, linetarget->x,
                                          linetarget->y);
  }
#line 495
  return;
}
}
#line 501 "p_pspr.c"
void A_Saw(player_t *player , pspdef_t *psp ) 
{ 
  angle_t angle ;
  int damage ;
  int slope ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 510
  tmp = P_Random();
#line 510
  damage = 2 * (tmp % 10 + 1);
#line 511
  angle = (player->mo)->angle;
#line 512
  tmp___0 = P_Random();
#line 512
  tmp___1 = P_Random();
#line 512
  angle += (angle_t )((tmp___0 - tmp___1) << 18);
#line 515
  slope = P_AimLineAttack(player->mo, angle, 64 * (1 << 16) + 1);
#line 516
  P_LineAttack(player->mo, angle, 64 * (1 << 16) + 1, slope, damage);
#line 518
  if (! linetarget) {
#line 520
    S_StartSound((void *)player->mo, 12);
#line 521
    return;
  }
#line 523
  S_StartSound((void *)player->mo, 13);
#line 526
  angle = R_PointToAngle2((player->mo)->x, (player->mo)->y, linetarget->x, linetarget->y);
#line 528
  if (angle - (player->mo)->angle > 0x80000000) {
#line 530
    if (angle - (player->mo)->angle < 4241280205U) {
#line 531
      (player->mo)->angle = angle + 51130563U;
    } else {
#line 533
      (player->mo)->angle -= 53687091U;
    }
  } else
#line 537
  if (angle - (player->mo)->angle > 53687091U) {
#line 538
    (player->mo)->angle = angle - 51130563U;
  } else {
#line 540
    (player->mo)->angle += 53687091U;
  }
#line 542
  (player->mo)->flags |= 128;
#line 543
  return;
}
}
#line 550 "p_pspr.c"
void A_FireMissile(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 555
  (player->ammo[weaponinfo[player->readyweapon].ammo]) --;
#line 556
  P_SpawnPlayerMissile(player->mo, (mobjtype_t )33);
#line 557
  return;
}
}
#line 563 "p_pspr.c"
void A_FireBFG(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 568
  player->ammo[weaponinfo[player->readyweapon].ammo] -= 40;
#line 569
  P_SpawnPlayerMissile(player->mo, (mobjtype_t )35);
#line 570
  return;
}
}
#line 577 "p_pspr.c"
void A_FirePlasma(player_t *player , pspdef_t *psp ) 
{ 
  int tmp ;

  {
#line 582
  (player->ammo[weaponinfo[player->readyweapon].ammo]) --;
#line 584
  tmp = P_Random();
#line 584
  P_SetPsprite(player, 1, (statenum_t )(weaponinfo[player->readyweapon].flashstate + (tmp & 1)));
#line 588
  P_SpawnPlayerMissile(player->mo, (mobjtype_t )34);
#line 589
  return;
}
}
#line 598 "p_pspr.c"
fixed_t bulletslope  ;
#line 601 "p_pspr.c"
void P_BulletSlope(mobj_t *mo ) 
{ 
  angle_t an ;

  {
#line 606
  an = mo->angle;
#line 607
  bulletslope = P_AimLineAttack(mo, an, 1024 * (1 << 16));
#line 609
  if (! linetarget) {
#line 611
    an += (angle_t )(1 << 26);
#line 612
    bulletslope = P_AimLineAttack(mo, an, 1024 * (1 << 16));
#line 613
    if (! linetarget) {
#line 615
      an -= (angle_t )(2 << 26);
#line 616
      bulletslope = P_AimLineAttack(mo, an, 1024 * (1 << 16));
    }
  }
#line 619
  return;
}
}
#line 625 "p_pspr.c"
void P_GunShot(mobj_t *mo , boolean accurate ) 
{ 
  angle_t angle ;
  int damage ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 633
  tmp = P_Random();
#line 633
  damage = 5 * (tmp % 3 + 1);
#line 634
  angle = mo->angle;
#line 636
  if (! accurate) {
#line 637
    tmp___0 = P_Random();
#line 637
    tmp___1 = P_Random();
#line 637
    angle += (angle_t )((tmp___0 - tmp___1) << 18);
  }
#line 639
  P_LineAttack(mo, angle, 2048 * (1 << 16), bulletslope, damage);
#line 640
  return;
}
}
#line 646 "p_pspr.c"
void A_FirePistol(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 651
  S_StartSound((void *)player->mo, 1);
#line 653
  P_SetMobjState(player->mo, (statenum_t )155);
#line 654
  (player->ammo[weaponinfo[player->readyweapon].ammo]) --;
#line 656
  P_SetPsprite(player, 1, (statenum_t )weaponinfo[player->readyweapon].flashstate);
#line 660
  P_BulletSlope(player->mo);
#line 661
  P_GunShot(player->mo, (boolean )(! player->refire));
#line 662
  return;
}
}
#line 668 "p_pspr.c"
void A_FireShotgun(player_t *player , pspdef_t *psp ) 
{ 
  int i ;

  {
#line 675
  S_StartSound((void *)player->mo, 2);
#line 676
  P_SetMobjState(player->mo, (statenum_t )155);
#line 678
  (player->ammo[weaponinfo[player->readyweapon].ammo]) --;
#line 680
  P_SetPsprite(player, 1, (statenum_t )weaponinfo[player->readyweapon].flashstate);
#line 684
  P_BulletSlope(player->mo);
#line 686
  i = 0;
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 686
    if (! (i < 7)) {
#line 686
      goto while_break;
    }
#line 687
    P_GunShot(player->mo, (boolean )0);
#line 686
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 688
  return;
}
}
#line 695 "p_pspr.c"
void A_FireShotgun2(player_t *player , pspdef_t *psp ) 
{ 
  int i ;
  angle_t angle ;
  int damage ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 705
  S_StartSound((void *)player->mo, 4);
#line 706
  P_SetMobjState(player->mo, (statenum_t )155);
#line 708
  player->ammo[weaponinfo[player->readyweapon].ammo] -= 2;
#line 710
  P_SetPsprite(player, 1, (statenum_t )weaponinfo[player->readyweapon].flashstate);
#line 714
  P_BulletSlope(player->mo);
#line 716
  i = 0;
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (i < 20)) {
#line 716
      goto while_break;
    }
#line 718
    tmp = P_Random();
#line 718
    damage = 5 * (tmp % 3 + 1);
#line 719
    angle = (player->mo)->angle;
#line 720
    tmp___0 = P_Random();
#line 720
    tmp___1 = P_Random();
#line 720
    angle += (angle_t )((tmp___0 - tmp___1) << 19);
#line 721
    tmp___2 = P_Random();
#line 721
    tmp___3 = P_Random();
#line 721
    P_LineAttack(player->mo, angle, 2048 * (1 << 16), bulletslope + ((tmp___2 - tmp___3) << 5),
                 damage);
#line 716
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  return;
}
}
#line 732 "p_pspr.c"
void A_FireCGun(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 737
  S_StartSound((void *)player->mo, 1);
#line 739
  if (! player->ammo[weaponinfo[player->readyweapon].ammo]) {
#line 740
    return;
  }
#line 742
  P_SetMobjState(player->mo, (statenum_t )155);
#line 743
  (player->ammo[weaponinfo[player->readyweapon].ammo]) --;
#line 745
  P_SetPsprite(player, 1, (statenum_t )((psp->state + weaponinfo[player->readyweapon].flashstate) - & states[52]));
#line 751
  P_BulletSlope(player->mo);
#line 753
  P_GunShot(player->mo, (boolean )(! player->refire));
#line 754
  return;
}
}
#line 761 "p_pspr.c"
void A_Light0(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 763
  player->extralight = 0;
#line 764
  return;
}
}
#line 766 "p_pspr.c"
void A_Light1(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 768
  player->extralight = 1;
#line 769
  return;
}
}
#line 771 "p_pspr.c"
void A_Light2(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 773
  player->extralight = 2;
#line 774
  return;
}
}
#line 781 "p_pspr.c"
void A_BFGSpray(mobj_t *mo ) 
{ 
  int i ;
  int j ;
  int damage ;
  angle_t an ;
  int tmp ;

  {
#line 789
  i = 0;
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    if (! (i < 40)) {
#line 789
      goto while_break;
    }
#line 791
    an = (mo->angle - 536870912U) + (angle_t )(26843545 * i);
#line 795
    P_AimLineAttack(mo->target, an, 1024 * (1 << 16));
#line 797
    if (! linetarget) {
#line 798
      goto __Cont;
    }
#line 800
    P_SpawnMobj(linetarget->x, linetarget->y, linetarget->z + (linetarget->height >> 2),
                (mobjtype_t )42);
#line 805
    damage = 0;
#line 806
    j = 0;
    {
#line 806
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 806
      if (! (j < 15)) {
#line 806
        goto while_break___0;
      }
#line 807
      tmp = P_Random();
#line 807
      damage += (tmp & 7) + 1;
#line 806
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 809
    P_DamageMobj(linetarget, mo->target, mo->target, damage);
    __Cont: /* CIL Label */ 
#line 789
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 811
  return;
}
}
#line 817 "p_pspr.c"
void A_BFGsound(player_t *player , pspdef_t *psp ) 
{ 


  {
#line 822
  S_StartSound((void *)player->mo, 9);
#line 823
  return;
}
}
#line 831 "p_pspr.c"
void P_SetupPsprites(player_t *player ) 
{ 
  int i ;

  {
#line 836
  i = 0;
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! (i < 2)) {
#line 836
      goto while_break;
    }
#line 837
    player->psprites[i].state = (state_t *)((void *)0);
#line 836
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 840
  player->pendingweapon = player->readyweapon;
#line 841
  P_BringUpWeapon(player);
#line 842
  return;
}
}
#line 851 "p_pspr.c"
void P_MovePsprites(player_t *player ) 
{ 
  int i ;
  pspdef_t *psp ;
  state_t *state___0 ;

  {
#line 857
  psp = & player->psprites[0];
#line 858
  i = 0;
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 858
    if (! (i < 2)) {
#line 858
      goto while_break;
    }
#line 861
    state___0 = psp->state;
#line 861
    if (state___0) {
#line 866
      if (psp->tics != -1) {
#line 868
        (psp->tics) --;
#line 869
        if (! psp->tics) {
#line 870
          P_SetPsprite(player, i, (psp->state)->nextstate);
        }
      }
    }
#line 858
    i ++;
#line 858
    psp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  player->psprites[1].sx = player->psprites[0].sx;
#line 876
  player->psprites[1].sy = player->psprites[0].sy;
#line 877
  return;
}
}
#line 25 "p_setup.c"
static char const   rcsid___32[50]  = 
#line 25 "p_setup.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'u',      (char const   )'p', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )' ', 
        (char const   )'2',      (char const   )'2',      (char const   )':',      (char const   )'4', 
        (char const   )'5',      (char const   )':',      (char const   )'1',      (char const   )'2', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 78 "r_state.h"
int numvertexes  ;
#line 79 "r_state.h"
vertex_t *vertexes  ;
#line 81 "r_state.h"
int numsegs  ;
#line 82 "r_state.h"
seg_t *segs  ;
#line 84 "r_state.h"
int numsectors  ;
#line 85 "r_state.h"
sector_t *sectors  ;
#line 87 "r_state.h"
int numsubsectors  ;
#line 88 "r_state.h"
subsector_t *subsectors  ;
#line 90 "r_state.h"
int numnodes  ;
#line 91 "r_state.h"
node_t *nodes  ;
#line 93 "r_state.h"
int numlines  ;
#line 94 "r_state.h"
line_t *lines  ;
#line 96 "r_state.h"
int numsides  ;
#line 97 "r_state.h"
side_t *sides  ;
#line 246 "p_local.h"
byte *rejectmatrix  ;
#line 247 "p_local.h"
short *blockmaplump  ;
#line 248 "p_local.h"
short *blockmap  ;
#line 249 "p_local.h"
int bmapwidth  ;
#line 250 "p_local.h"
int bmapheight  ;
#line 251 "p_local.h"
fixed_t bmaporgx  ;
#line 252 "p_local.h"
fixed_t bmaporgy  ;
#line 253 "p_local.h"
mobj_t **blocklinks  ;
#line 220 "doomstat.h"
mapthing_t deathmatchstarts[10]  ;
#line 221 "doomstat.h"
mapthing_t *deathmatch_p  ;
#line 224 "doomstat.h"
mapthing_t playerstarts[4]  ;
#line 49 "p_setup.c"
void P_SpawnMapThing(mapthing_t *mthing ) ;
#line 122 "p_setup.c"
void P_LoadVertexes(int lump ) 
{ 
  byte *data ;
  int i ;
  mapvertex_t *ml ;
  vertex_t *li ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 131
  tmp = W_LumpLength(lump);
#line 131
  numvertexes = (int )((unsigned long )tmp / sizeof(mapvertex_t ));
#line 134
  tmp___0 = Z_Malloc((int )((unsigned long )numvertexes * sizeof(vertex_t )), 50,
                     (void *)0);
#line 134
  vertexes = (vertex_t *)tmp___0;
#line 137
  tmp___1 = W_CacheLumpNum(lump, 1);
#line 137
  data = (byte *)tmp___1;
#line 139
  ml = (mapvertex_t *)data;
#line 140
  li = vertexes;
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < numvertexes)) {
#line 144
      goto while_break;
    }
#line 146
    li->x = (int )ml->x << 16;
#line 147
    li->y = (int )ml->y << 16;
#line 144
    i ++;
#line 144
    li ++;
#line 144
    ml ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  Z_Free((void *)data);
#line 152
  return;
}
}
#line 159 "p_setup.c"
void P_LoadSegs(int lump ) 
{ 
  byte *data ;
  int i ;
  mapseg_t *ml ;
  seg_t *li ;
  line_t *ldef ;
  int linedef___0 ;
  int side ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 169
  tmp = W_LumpLength(lump);
#line 169
  numsegs = (int )((unsigned long )tmp / sizeof(mapseg_t ));
#line 170
  tmp___0 = Z_Malloc((int )((unsigned long )numsegs * sizeof(seg_t )), 50, (void *)0);
#line 170
  segs = (seg_t *)tmp___0;
#line 171
  memset((void *)segs, 0, (size_t )((unsigned long )numsegs * sizeof(seg_t )));
#line 172
  tmp___1 = W_CacheLumpNum(lump, 1);
#line 172
  data = (byte *)tmp___1;
#line 174
  ml = (mapseg_t *)data;
#line 175
  li = segs;
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < numsegs)) {
#line 176
      goto while_break;
    }
#line 178
    li->v1 = vertexes + ml->v1;
#line 179
    li->v2 = vertexes + ml->v2;
#line 181
    li->angle = (angle_t )((int )ml->angle << 16);
#line 182
    li->offset = (int )ml->offset << 16;
#line 183
    linedef___0 = (int )ml->linedef;
#line 184
    ldef = lines + linedef___0;
#line 185
    li->linedef = ldef;
#line 186
    side = (int )ml->side;
#line 187
    li->sidedef = sides + ldef->sidenum[side];
#line 188
    li->frontsector = (sides + ldef->sidenum[side])->sector;
#line 189
    if ((int )ldef->flags & 4) {
#line 190
      li->backsector = (sides + ldef->sidenum[side ^ 1])->sector;
    } else {
#line 192
      li->backsector = (sector_t *)0;
    }
#line 176
    i ++;
#line 176
    li ++;
#line 176
    ml ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  Z_Free((void *)data);
#line 196
  return;
}
}
#line 202 "p_setup.c"
void P_LoadSubsectors(int lump ) 
{ 
  byte *data ;
  int i ;
  mapsubsector_t *ms ;
  subsector_t *ss ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 209
  tmp = W_LumpLength(lump);
#line 209
  numsubsectors = (int )((unsigned long )tmp / sizeof(mapsubsector_t ));
#line 210
  tmp___0 = Z_Malloc((int )((unsigned long )numsubsectors * sizeof(subsector_t )),
                     50, (void *)0);
#line 210
  subsectors = (subsector_t *)tmp___0;
#line 211
  tmp___1 = W_CacheLumpNum(lump, 1);
#line 211
  data = (byte *)tmp___1;
#line 213
  ms = (mapsubsector_t *)data;
#line 214
  memset((void *)subsectors, 0, (size_t )((unsigned long )numsubsectors * sizeof(subsector_t )));
#line 215
  ss = subsectors;
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < numsubsectors)) {
#line 217
      goto while_break;
    }
#line 219
    ss->numlines = ms->numsegs;
#line 220
    ss->firstline = ms->firstseg;
#line 217
    i ++;
#line 217
    ss ++;
#line 217
    ms ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  Z_Free((void *)data);
#line 224
  return;
}
}
#line 231 "p_setup.c"
void P_LoadSectors(int lump ) 
{ 
  byte *data ;
  int i ;
  mapsector_t *ms ;
  sector_t *ss ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 238
  tmp = W_LumpLength(lump);
#line 238
  numsectors = (int )((unsigned long )tmp / sizeof(mapsector_t ));
#line 239
  tmp___0 = Z_Malloc((int )((unsigned long )numsectors * sizeof(sector_t )), 50, (void *)0);
#line 239
  sectors = (sector_t *)tmp___0;
#line 240
  memset((void *)sectors, 0, (size_t )((unsigned long )numsectors * sizeof(sector_t )));
#line 241
  tmp___1 = W_CacheLumpNum(lump, 1);
#line 241
  data = (byte *)tmp___1;
#line 243
  ms = (mapsector_t *)data;
#line 244
  ss = sectors;
#line 245
  i = 0;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! (i < numsectors)) {
#line 245
      goto while_break;
    }
#line 247
    ss->floorheight = (int )ms->floorheight << 16;
#line 248
    ss->ceilingheight = (int )ms->ceilingheight << 16;
#line 249
    tmp___2 = R_FlatNumForName(ms->floorpic);
#line 249
    ss->floorpic = (short )tmp___2;
#line 250
    tmp___3 = R_FlatNumForName(ms->ceilingpic);
#line 250
    ss->ceilingpic = (short )tmp___3;
#line 251
    ss->lightlevel = ms->lightlevel;
#line 252
    ss->special = ms->special;
#line 253
    ss->tag = ms->tag;
#line 254
    ss->thinglist = (mobj_t *)((void *)0);
#line 245
    i ++;
#line 245
    ss ++;
#line 245
    ms ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  Z_Free((void *)data);
#line 258
  return;
}
}
#line 264 "p_setup.c"
void P_LoadNodes(int lump ) 
{ 
  byte *data ;
  int i ;
  int j ;
  int k ;
  mapnode_t *mn ;
  node_t *no ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 273
  tmp = W_LumpLength(lump);
#line 273
  numnodes = (int )((unsigned long )tmp / sizeof(mapnode_t ));
#line 274
  tmp___0 = Z_Malloc((int )((unsigned long )numnodes * sizeof(node_t )), 50, (void *)0);
#line 274
  nodes = (node_t *)tmp___0;
#line 275
  tmp___1 = W_CacheLumpNum(lump, 1);
#line 275
  data = (byte *)tmp___1;
#line 277
  mn = (mapnode_t *)data;
#line 278
  no = nodes;
#line 280
  i = 0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (i < numnodes)) {
#line 280
      goto while_break;
    }
#line 282
    no->x = (int )mn->x << 16;
#line 283
    no->y = (int )mn->y << 16;
#line 284
    no->dx = (int )mn->dx << 16;
#line 285
    no->dy = (int )mn->dy << 16;
#line 286
    j = 0;
    {
#line 286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 286
      if (! (j < 2)) {
#line 286
        goto while_break___0;
      }
#line 288
      no->children[j] = mn->children[j];
#line 289
      k = 0;
      {
#line 289
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 289
        if (! (k < 4)) {
#line 289
          goto while_break___1;
        }
#line 290
        no->bbox[j][k] = (int )mn->bbox[j][k] << 16;
#line 289
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 286
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 280
    i ++;
#line 280
    no ++;
#line 280
    mn ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  Z_Free((void *)data);
#line 295
  return;
}
}
#line 301 "p_setup.c"
void P_LoadThings(int lump ) 
{ 
  byte *data ;
  int i ;
  mapthing_t *mt ;
  int numthings ;
  boolean spawn ;
  void *tmp ;
  int tmp___0 ;

  {
#line 309
  tmp = W_CacheLumpNum(lump, 1);
#line 309
  data = (byte *)tmp;
#line 310
  tmp___0 = W_LumpLength(lump);
#line 310
  numthings = (int )((unsigned long )tmp___0 / sizeof(mapthing_t ));
#line 312
  mt = (mapthing_t *)data;
#line 313
  i = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (i < numthings)) {
#line 313
      goto while_break;
    }
#line 315
    spawn = (boolean )1;
#line 318
    if ((unsigned int )gamemode != 2U) {
      {
#line 331
      if ((int )mt->type == 84) {
#line 331
        goto case_84;
      }
#line 331
      if ((int )mt->type == 66) {
#line 331
        goto case_84;
      }
#line 331
      if ((int )mt->type == 65) {
#line 331
        goto case_84;
      }
#line 331
      if ((int )mt->type == 71) {
#line 331
        goto case_84;
      }
#line 331
      if ((int )mt->type == 67) {
#line 331
        goto case_84;
      }
#line 331
      if ((int )mt->type == 69) {
#line 331
        goto case_84;
      }
#line 331
      if ((int )mt->type == 89) {
#line 331
        goto case_84;
      }
#line 331
      if ((int )mt->type == 88) {
#line 331
        goto case_84;
      }
#line 331
      if ((int )mt->type == 64) {
#line 331
        goto case_84;
      }
#line 331
      if ((int )mt->type == 68) {
#line 331
        goto case_84;
      }
#line 320
      goto switch_break;
      case_84: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_65: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_67: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_89: /* CIL Label */ 
      case_88: /* CIL Label */ 
      case_64: /* CIL Label */ 
      case_68: /* CIL Label */ 
#line 332
      spawn = (boolean )0;
#line 333
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 336
    if ((unsigned int )spawn == 0U) {
#line 337
      goto while_break;
    }
#line 340
    mt->x = mt->x;
#line 341
    mt->y = mt->y;
#line 342
    mt->angle = mt->angle;
#line 343
    mt->type = mt->type;
#line 344
    mt->options = mt->options;
#line 346
    P_SpawnMapThing(mt);
#line 313
    i ++;
#line 313
    mt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  Z_Free((void *)data);
#line 350
  return;
}
}
#line 357 "p_setup.c"
void P_LoadLineDefs(int lump ) 
{ 
  byte *data ;
  int i ;
  maplinedef_t *mld ;
  line_t *ld ;
  vertex_t *v1 ;
  vertex_t *v2 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  vertex_t *tmp___2 ;
  vertex_t *tmp___3 ;
  fixed_t tmp___4 ;

  {
#line 366
  tmp = W_LumpLength(lump);
#line 366
  numlines = (int )((unsigned long )tmp / sizeof(maplinedef_t ));
#line 367
  tmp___0 = Z_Malloc((int )((unsigned long )numlines * sizeof(line_t )), 50, (void *)0);
#line 367
  lines = (line_t *)tmp___0;
#line 368
  memset((void *)lines, 0, (size_t )((unsigned long )numlines * sizeof(line_t )));
#line 369
  tmp___1 = W_CacheLumpNum(lump, 1);
#line 369
  data = (byte *)tmp___1;
#line 371
  mld = (maplinedef_t *)data;
#line 372
  ld = lines;
#line 373
  i = 0;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (i < numlines)) {
#line 373
      goto while_break;
    }
#line 375
    ld->flags = mld->flags;
#line 376
    ld->special = mld->special;
#line 377
    ld->tag = mld->tag;
#line 378
    tmp___2 = vertexes + mld->v1;
#line 378
    ld->v1 = tmp___2;
#line 378
    v1 = tmp___2;
#line 379
    tmp___3 = vertexes + mld->v2;
#line 379
    ld->v2 = tmp___3;
#line 379
    v2 = tmp___3;
#line 380
    ld->dx = v2->x - v1->x;
#line 381
    ld->dy = v2->y - v1->y;
#line 383
    if (! ld->dx) {
#line 384
      ld->slopetype = (slopetype_t )1;
    } else
#line 385
    if (! ld->dy) {
#line 386
      ld->slopetype = (slopetype_t )0;
    } else {
#line 389
      tmp___4 = FixedDiv(ld->dy, ld->dx);
#line 389
      if (tmp___4 > 0) {
#line 390
        ld->slopetype = (slopetype_t )2;
      } else {
#line 392
        ld->slopetype = (slopetype_t )3;
      }
    }
#line 395
    if (v1->x < v2->x) {
#line 397
      ld->bbox[2] = v1->x;
#line 398
      ld->bbox[3] = v2->x;
    } else {
#line 402
      ld->bbox[2] = v2->x;
#line 403
      ld->bbox[3] = v1->x;
    }
#line 406
    if (v1->y < v2->y) {
#line 408
      ld->bbox[1] = v1->y;
#line 409
      ld->bbox[0] = v2->y;
    } else {
#line 413
      ld->bbox[1] = v2->y;
#line 414
      ld->bbox[0] = v1->y;
    }
#line 417
    ld->sidenum[0] = mld->sidenum[0];
#line 418
    ld->sidenum[1] = mld->sidenum[1];
#line 420
    if ((int )ld->sidenum[0] != -1) {
#line 421
      ld->frontsector = (sides + ld->sidenum[0])->sector;
    } else {
#line 423
      ld->frontsector = (sector_t *)0;
    }
#line 425
    if ((int )ld->sidenum[1] != -1) {
#line 426
      ld->backsector = (sides + ld->sidenum[1])->sector;
    } else {
#line 428
      ld->backsector = (sector_t *)0;
    }
#line 373
    i ++;
#line 373
    mld ++;
#line 373
    ld ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  Z_Free((void *)data);
#line 432
  return;
}
}
#line 438 "p_setup.c"
void P_LoadSideDefs(int lump ) 
{ 
  byte *data ;
  int i ;
  mapsidedef_t *msd ;
  side_t *sd ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 445
  tmp = W_LumpLength(lump);
#line 445
  numsides = (int )((unsigned long )tmp / sizeof(mapsidedef_t ));
#line 446
  tmp___0 = Z_Malloc((int )((unsigned long )numsides * sizeof(side_t )), 50, (void *)0);
#line 446
  sides = (side_t *)tmp___0;
#line 447
  memset((void *)sides, 0, (size_t )((unsigned long )numsides * sizeof(side_t )));
#line 448
  tmp___1 = W_CacheLumpNum(lump, 1);
#line 448
  data = (byte *)tmp___1;
#line 450
  msd = (mapsidedef_t *)data;
#line 451
  sd = sides;
#line 452
  i = 0;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! (i < numsides)) {
#line 452
      goto while_break;
    }
#line 454
    sd->textureoffset = (int )msd->textureoffset << 16;
#line 455
    sd->rowoffset = (int )msd->rowoffset << 16;
#line 456
    tmp___2 = R_TextureNumForName(msd->toptexture);
#line 456
    sd->toptexture = (short )tmp___2;
#line 457
    tmp___3 = R_TextureNumForName(msd->bottomtexture);
#line 457
    sd->bottomtexture = (short )tmp___3;
#line 458
    tmp___4 = R_TextureNumForName(msd->midtexture);
#line 458
    sd->midtexture = (short )tmp___4;
#line 459
    sd->sector = sectors + msd->sector;
#line 452
    i ++;
#line 452
    msd ++;
#line 452
    sd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  Z_Free((void *)data);
#line 463
  return;
}
}
#line 469 "p_setup.c"
void P_LoadBlockMap(int lump ) 
{ 
  int i ;
  int count ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 474
  tmp = W_CacheLumpNum(lump, 50);
#line 474
  blockmaplump = (short *)tmp;
#line 475
  blockmap = blockmaplump + 4;
#line 476
  tmp___0 = W_LumpLength(lump);
#line 476
  count = tmp___0 / 2;
#line 478
  i = 0;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i < count)) {
#line 478
      goto while_break;
    }
#line 479
    *(blockmaplump + i) = *(blockmaplump + i);
#line 478
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  bmaporgx = (int )*(blockmaplump + 0) << 16;
#line 482
  bmaporgy = (int )*(blockmaplump + 1) << 16;
#line 483
  bmapwidth = (int )*(blockmaplump + 2);
#line 484
  bmapheight = (int )*(blockmaplump + 3);
#line 487
  count = (int )((sizeof(*blocklinks) * (unsigned long )bmapwidth) * (unsigned long )bmapheight);
#line 488
  tmp___1 = Z_Malloc(count, 50, (void *)0);
#line 488
  blocklinks = (mobj_t **)tmp___1;
#line 489
  memset((void *)blocklinks, 0, (size_t )count);
#line 490
  return;
}
}
#line 499 "p_setup.c"
void P_GroupLines(void) 
{ 
  line_t **linebuffer ;
  int i ;
  int j ;
  int total___0 ;
  line_t *li ;
  sector_t *sector ;
  subsector_t *ss ;
  seg_t *seg ;
  fixed_t bbox[4] ;
  int block ;
  void *tmp ;
  line_t **tmp___0 ;

  {
#line 513
  ss = subsectors;
#line 514
  i = 0;
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! (i < numsubsectors)) {
#line 514
      goto while_break;
    }
#line 516
    seg = segs + ss->firstline;
#line 517
    ss->sector = (seg->sidedef)->sector;
#line 514
    i ++;
#line 514
    ss ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  li = lines;
#line 522
  total___0 = 0;
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 523
    if (! (i < numlines)) {
#line 523
      goto while_break___0;
    }
#line 525
    total___0 ++;
#line 526
    ((li->frontsector)->linecount) ++;
#line 528
    if (li->backsector) {
#line 528
      if ((unsigned long )li->backsector != (unsigned long )li->frontsector) {
#line 530
        ((li->backsector)->linecount) ++;
#line 531
        total___0 ++;
      } else {
#line 528
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 523
    i ++;
#line 523
    li ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 536
  tmp = Z_Malloc(total___0 * 4, 50, (void *)0);
#line 536
  linebuffer = (line_t **)tmp;
#line 537
  sector = sectors;
#line 538
  i = 0;
  {
#line 538
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 538
    if (! (i < numsectors)) {
#line 538
      goto while_break___1;
    }
#line 540
    M_ClearBox(bbox);
#line 541
    sector->lines = linebuffer;
#line 542
    li = lines;
#line 543
    j = 0;
    {
#line 543
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 543
      if (! (j < numlines)) {
#line 543
        goto while_break___2;
      }
#line 545
      if ((unsigned long )li->frontsector == (unsigned long )sector) {
#line 545
        goto _L___0;
      } else
#line 545
      if ((unsigned long )li->backsector == (unsigned long )sector) {
        _L___0: /* CIL Label */ 
#line 547
        tmp___0 = linebuffer;
#line 547
        linebuffer ++;
#line 547
        *tmp___0 = li;
#line 548
        M_AddToBox(bbox, (li->v1)->x, (li->v1)->y);
#line 549
        M_AddToBox(bbox, (li->v2)->x, (li->v2)->y);
      }
#line 543
      j ++;
#line 543
      li ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 552
    if (linebuffer - sector->lines != (long )sector->linecount) {
#line 553
      I_Error("P_GroupLines: miscounted");
    }
#line 556
    sector->soundorg.x = (bbox[3] + bbox[2]) / 2;
#line 557
    sector->soundorg.y = (bbox[0] + bbox[1]) / 2;
#line 560
    block = ((bbox[0] - bmaporgy) + 32 * (1 << 16)) >> 23;
#line 561
    if (block >= bmapheight) {
#line 561
      block = bmapheight - 1;
    } else {
#line 561
      block = block;
    }
#line 562
    sector->blockbox[0] = block;
#line 564
    block = ((bbox[1] - bmaporgy) - 32 * (1 << 16)) >> 23;
#line 565
    if (block < 0) {
#line 565
      block = 0;
    } else {
#line 565
      block = block;
    }
#line 566
    sector->blockbox[1] = block;
#line 568
    block = ((bbox[3] - bmaporgx) + 32 * (1 << 16)) >> 23;
#line 569
    if (block >= bmapwidth) {
#line 569
      block = bmapwidth - 1;
    } else {
#line 569
      block = block;
    }
#line 570
    sector->blockbox[3] = block;
#line 572
    block = ((bbox[2] - bmaporgx) - 32 * (1 << 16)) >> 23;
#line 573
    if (block < 0) {
#line 573
      block = 0;
    } else {
#line 573
      block = block;
    }
#line 574
    sector->blockbox[2] = block;
#line 538
    i ++;
#line 538
    sector ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 577
  return;
}
}
#line 583 "p_setup.c"
void P_SetupLevel(int episode , int map , int playermask , skill_t skill ) 
{ 
  int i ;
  char lumpname[9] ;
  int lumpnum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 594
  wminfo.maxfrags = 0;
#line 594
  totalsecret = wminfo.maxfrags;
#line 594
  totalitems = totalsecret;
#line 594
  totalkills = totalitems;
#line 595
  wminfo.partime = 180;
#line 596
  i = 0;
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
#line 596
    if (! (i < 4)) {
#line 596
      goto while_break;
    }
#line 598
    tmp___0 = 0;
#line 598
    players[i].itemcount = tmp___0;
#line 598
    tmp = tmp___0;
#line 598
    players[i].secretcount = tmp;
#line 598
    players[i].killcount = tmp;
#line 596
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  players[consoleplayer].viewz = 1;
#line 607
  S_Start();
#line 618
  Z_FreeTags(50, 99);
#line 622
  P_InitThinkers();
#line 625
  W_Reload();
#line 628
  if ((unsigned int )gamemode == 2U) {
#line 630
    if (map < 10) {
#line 631
      sprintf((char * __restrict  )(lumpname), (char const   * __restrict  )"map0%i",
              map);
    } else {
#line 633
      sprintf((char * __restrict  )(lumpname), (char const   * __restrict  )"map%i",
              map);
    }
  } else {
#line 637
    lumpname[0] = (char )'E';
#line 638
    lumpname[1] = (char )(48 + episode);
#line 639
    lumpname[2] = (char )'M';
#line 640
    lumpname[3] = (char )(48 + map);
#line 641
    lumpname[4] = (char)0;
  }
#line 644
  lumpnum = W_GetNumForName(lumpname);
#line 646
  leveltime = 0;
#line 649
  P_LoadBlockMap(lumpnum + 10);
#line 650
  P_LoadVertexes(lumpnum + 4);
#line 651
  P_LoadSectors(lumpnum + 8);
#line 652
  P_LoadSideDefs(lumpnum + 3);
#line 654
  P_LoadLineDefs(lumpnum + 2);
#line 655
  P_LoadSubsectors(lumpnum + 6);
#line 656
  P_LoadNodes(lumpnum + 7);
#line 657
  P_LoadSegs(lumpnum + 5);
#line 659
  tmp___1 = W_CacheLumpNum(lumpnum + 9, 50);
#line 659
  rejectmatrix = (byte *)tmp___1;
#line 660
  P_GroupLines();
#line 662
  bodyqueslot = 0;
#line 663
  deathmatch_p = deathmatchstarts;
#line 664
  P_LoadThings(lumpnum + 1);
#line 667
  if (deathmatch) {
#line 669
    i = 0;
    {
#line 669
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 669
      if (! (i < 4)) {
#line 669
        goto while_break___0;
      }
#line 670
      if (playeringame[i]) {
#line 672
        players[i].mo = (mobj_t *)((void *)0);
#line 673
        G_DeathMatchSpawnPlayer(i);
      }
#line 669
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 679
  iquetail = 0;
#line 679
  iquehead = iquetail;
#line 682
  P_SpawnSpecials();
#line 688
  if (precache) {
#line 689
    R_PrecacheLevel();
  }
#line 693
  return;
}
}
#line 700 "p_setup.c"
void P_Init(void) 
{ 


  {
#line 702
  P_InitSwitchList();
#line 703
  P_InitPicAnims();
#line 704
  R_InitSprites(sprnames);
#line 705
  return;
}
}
#line 24 "p_sight.c"
static char const   rcsid___33[50]  = 
#line 24 "p_sight.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'s', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'t', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'3', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'1', 
        (char const   )'/',      (char const   )'2',      (char const   )'8',      (char const   )' ', 
        (char const   )'2',      (char const   )'2',      (char const   )':',      (char const   )'0', 
        (char const   )'8',      (char const   )':',      (char const   )'2',      (char const   )'8', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 39 "p_sight.c"
fixed_t sightzstart  ;
#line 40 "p_sight.c"
fixed_t topslope  ;
#line 41 "p_sight.c"
fixed_t bottomslope  ;
#line 43 "p_sight.c"
divline_t strace  ;
#line 44 "p_sight.c"
fixed_t t2x  ;
#line 45 "p_sight.c"
fixed_t t2y  ;
#line 47 "p_sight.c"
int sightcounts[2]  ;
#line 54 "p_sight.c"
int P_DivlineSide(fixed_t x___0 , fixed_t y___1 , divline_t *node ) 
{ 
  fixed_t dx ;
  fixed_t dy ;
  fixed_t left ;
  fixed_t right ;

  {
#line 65
  if (! node->dx) {
#line 67
    if (x___0 == node->x) {
#line 68
      return (2);
    }
#line 70
    if (x___0 <= node->x) {
#line 71
      return (node->dy > 0);
    }
#line 73
    return (node->dy < 0);
  }
#line 76
  if (! node->dy) {
#line 78
    if (x___0 == node->y) {
#line 79
      return (2);
    }
#line 81
    if (y___1 <= node->y) {
#line 82
      return (node->dx < 0);
    }
#line 84
    return (node->dx > 0);
  }
#line 87
  dx = x___0 - node->x;
#line 88
  dy = y___1 - node->y;
#line 90
  left = (node->dy >> 16) * (dx >> 16);
#line 91
  right = (dy >> 16) * (node->dx >> 16);
#line 93
  if (right < left) {
#line 94
    return (0);
  }
#line 96
  if (left == right) {
#line 97
    return (2);
  }
#line 98
  return (1);
}
}
#line 108 "p_sight.c"
fixed_t P_InterceptVector2(divline_t *v2 , divline_t *v1 ) 
{ 
  fixed_t frac ;
  fixed_t num___0 ;
  fixed_t den ;
  fixed_t tmp ;
  fixed_t tmp___0 ;
  fixed_t tmp___1 ;
  fixed_t tmp___2 ;

  {
#line 117
  tmp = FixedMul(v1->dy >> 8, v2->dx);
#line 117
  tmp___0 = FixedMul(v1->dx >> 8, v2->dy);
#line 117
  den = tmp - tmp___0;
#line 119
  if (den == 0) {
#line 120
    return (0);
  }
#line 123
  tmp___1 = FixedMul((v1->x - v2->x) >> 8, v1->dy);
#line 123
  tmp___2 = FixedMul((v2->y - v1->y) >> 8, v1->dx);
#line 123
  num___0 = tmp___1 + tmp___2;
#line 125
  frac = FixedDiv(num___0, den);
#line 127
  return (frac);
}
}
#line 135 "p_sight.c"
boolean P_CrossSubsector(int num___0 ) 
{ 
  seg_t *seg ;
  line_t *line ;
  int s1 ;
  int s2 ;
  int count ;
  subsector_t *sub ;
  sector_t *front ;
  sector_t *back ;
  fixed_t opentop___0 ;
  fixed_t openbottom___0 ;
  divline_t divl ;
  vertex_t *v1 ;
  vertex_t *v2 ;
  fixed_t frac ;
  fixed_t slope ;

  {
#line 154
  if (num___0 >= numsubsectors) {
#line 155
    I_Error("P_CrossSubsector: ss %i with numss = %i", num___0, numsubsectors);
  }
#line 160
  sub = subsectors + num___0;
#line 163
  count = (int )sub->numlines;
#line 164
  seg = segs + sub->firstline;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! count) {
#line 166
      goto while_break;
    }
#line 168
    line = seg->linedef;
#line 171
    if (line->validcount == validcount) {
#line 172
      goto __Cont;
    }
#line 174
    line->validcount = validcount;
#line 176
    v1 = line->v1;
#line 177
    v2 = line->v2;
#line 178
    s1 = P_DivlineSide(v1->x, v1->y, & strace);
#line 179
    s2 = P_DivlineSide(v2->x, v2->y, & strace);
#line 182
    if (s1 == s2) {
#line 183
      goto __Cont;
    }
#line 185
    divl.x = v1->x;
#line 186
    divl.y = v1->y;
#line 187
    divl.dx = v2->x - v1->x;
#line 188
    divl.dy = v2->y - v1->y;
#line 189
    s1 = P_DivlineSide(strace.x, strace.y, & divl);
#line 190
    s2 = P_DivlineSide(t2x, t2y, & divl);
#line 193
    if (s1 == s2) {
#line 194
      goto __Cont;
    }
#line 198
    if (! ((int )line->flags & 4)) {
#line 199
      return ((boolean )0);
    }
#line 202
    front = seg->frontsector;
#line 203
    back = seg->backsector;
#line 206
    if (front->floorheight == back->floorheight) {
#line 206
      if (front->ceilingheight == back->ceilingheight) {
#line 208
        goto __Cont;
      } else {
#line 206
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 212
    if (front->ceilingheight < back->ceilingheight) {
#line 213
      opentop___0 = front->ceilingheight;
    } else {
#line 215
      opentop___0 = back->ceilingheight;
    }
#line 218
    if (front->floorheight > back->floorheight) {
#line 219
      openbottom___0 = front->floorheight;
    } else {
#line 221
      openbottom___0 = back->floorheight;
    }
#line 224
    if (openbottom___0 >= opentop___0) {
#line 225
      return ((boolean )0);
    }
#line 227
    frac = P_InterceptVector2(& strace, & divl);
#line 229
    if (front->floorheight != back->floorheight) {
#line 231
      slope = FixedDiv(openbottom___0 - sightzstart, frac);
#line 232
      if (slope > bottomslope) {
#line 233
        bottomslope = slope;
      }
    }
#line 236
    if (front->ceilingheight != back->ceilingheight) {
#line 238
      slope = FixedDiv(opentop___0 - sightzstart, frac);
#line 239
      if (slope < topslope) {
#line 240
        topslope = slope;
      }
    }
#line 243
    if (topslope <= bottomslope) {
#line 244
      return ((boolean )0);
    }
    __Cont: /* CIL Label */ 
#line 166
    seg ++;
#line 166
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return ((boolean )1);
}
}
#line 257 "p_sight.c"
boolean P_CrossBSPNode(int bspnum ) 
{ 
  node_t *bsp ;
  int side ;
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  int tmp___2 ;
  boolean tmp___3 ;

  {
#line 262
  if (bspnum & 0x8000) {
#line 264
    if (bspnum == -1) {
#line 265
      tmp = P_CrossSubsector(0);
#line 265
      return (tmp);
    } else {
#line 267
      tmp___0 = P_CrossSubsector(bspnum & -32769);
#line 267
      return (tmp___0);
    }
  }
#line 270
  bsp = nodes + bspnum;
#line 273
  side = P_DivlineSide(strace.x, strace.y, (divline_t *)bsp);
#line 274
  if (side == 2) {
#line 275
    side = 0;
  }
#line 278
  tmp___1 = P_CrossBSPNode((int )bsp->children[side]);
#line 278
  if (! tmp___1) {
#line 279
    return ((boolean )0);
  }
#line 282
  tmp___2 = P_DivlineSide(t2x, t2y, (divline_t *)bsp);
#line 282
  if (side == tmp___2) {
#line 285
    return ((boolean )1);
  }
#line 289
  tmp___3 = P_CrossBSPNode((int )bsp->children[side ^ 1]);
#line 289
  return (tmp___3);
}
}
#line 299 "p_sight.c"
boolean P_CheckSight(mobj_t *t1 , mobj_t *t2 ) 
{ 
  int s1 ;
  int s2 ;
  int pnum ;
  int bytenum ;
  int bitnum ;
  boolean tmp ;

  {
#line 313
  s1 = (int )((t1->subsector)->sector - sectors);
#line 314
  s2 = (int )((t2->subsector)->sector - sectors);
#line 315
  pnum = s1 * numsectors + s2;
#line 316
  bytenum = pnum >> 3;
#line 317
  bitnum = 1 << (pnum & 7);
#line 320
  if ((int )*(rejectmatrix + bytenum) & bitnum) {
#line 322
    (sightcounts[0]) ++;
#line 325
    return ((boolean )0);
  }
#line 330
  (sightcounts[1]) ++;
#line 332
  validcount ++;
#line 334
  sightzstart = (t1->z + t1->height) - (t1->height >> 2);
#line 335
  topslope = (t2->z + t2->height) - sightzstart;
#line 336
  bottomslope = t2->z - sightzstart;
#line 338
  strace.x = t1->x;
#line 339
  strace.y = t1->y;
#line 340
  t2x = t2->x;
#line 341
  t2y = t2->y;
#line 342
  strace.dx = t2->x - t1->x;
#line 343
  strace.dy = t2->y - t1->y;
#line 346
  tmp = P_CrossBSPNode(numnodes - 1);
#line 346
  return (tmp);
}
}
#line 28 "p_spec.c"
static char const   rcsid___34[49]  = 
#line 28 "p_spec.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'s', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'2',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 33 "p_spec.h"
boolean levelTimer  ;
#line 34 "p_spec.h"
int levelTimeCount  ;
#line 85 "p_spec.c"
anim_t anims[32]  ;
#line 86 "p_spec.c"
anim_t *lastanim  ;
#line 101 "p_spec.c"
animdef_t animdefs[23]  = 
#line 101
  {      {(boolean )0, {(char )'N', (char )'U', (char )'K', (char )'A', (char )'G', (char )'E',
                    (char )'3', (char )'\000'}, {(char )'N', (char )'U', (char )'K',
                                                 (char )'A', (char )'G', (char )'E',
                                                 (char )'1', (char )'\000'}, 8}, 
        {(boolean )0, {(char )'F', (char )'W', (char )'A', (char )'T', (char )'E', (char )'R',
                    (char )'4', (char )'\000'}, {(char )'F', (char )'W', (char )'A',
                                                 (char )'T', (char )'E', (char )'R',
                                                 (char )'1', (char )'\000'}, 8}, 
        {(boolean )0, {(char )'S', (char )'W', (char )'A', (char )'T', (char )'E', (char )'R',
                    (char )'4', (char )'\000'}, {(char )'S', (char )'W', (char )'A',
                                                 (char )'T', (char )'E', (char )'R',
                                                 (char )'1', (char )'\000'}, 8}, 
        {(boolean )0, {(char )'L', (char )'A', (char )'V', (char )'A', (char )'4', (char )'\000'},
      {(char )'L', (char )'A', (char )'V', (char )'A', (char )'1', (char )'\000'},
      8}, 
        {(boolean )0, {(char )'B', (char )'L', (char )'O', (char )'O', (char )'D', (char )'3',
                    (char )'\000'}, {(char )'B', (char )'L', (char )'O', (char )'O',
                                     (char )'D', (char )'1', (char )'\000'}, 8}, 
        {(boolean )0, {(char )'R', (char )'R', (char )'O', (char )'C', (char )'K', (char )'0',
                    (char )'8', (char )'\000'}, {(char )'R', (char )'R', (char )'O',
                                                 (char )'C', (char )'K', (char )'0',
                                                 (char )'5', (char )'\000'}, 8}, 
        {(boolean )0, {(char )'S', (char )'L', (char )'I', (char )'M', (char )'E', (char )'0',
                    (char )'4', (char )'\000'}, {(char )'S', (char )'L', (char )'I',
                                                 (char )'M', (char )'E', (char )'0',
                                                 (char )'1', (char )'\000'}, 8}, 
        {(boolean )0, {(char )'S', (char )'L', (char )'I', (char )'M', (char )'E', (char )'0',
                    (char )'8', (char )'\000'}, {(char )'S', (char )'L', (char )'I',
                                                 (char )'M', (char )'E', (char )'0',
                                                 (char )'5', (char )'\000'}, 8}, 
        {(boolean )0, {(char )'S', (char )'L', (char )'I', (char )'M', (char )'E', (char )'1',
                    (char )'2', (char )'\000'}, {(char )'S', (char )'L', (char )'I',
                                                 (char )'M', (char )'E', (char )'0',
                                                 (char )'9', (char )'\000'}, 8}, 
        {(boolean )1, {(char )'B', (char )'L', (char )'O', (char )'D', (char )'G', (char )'R',
                    (char )'4', (char )'\000'}, {(char )'B', (char )'L', (char )'O',
                                                 (char )'D', (char )'G', (char )'R',
                                                 (char )'1', (char )'\000'}, 8}, 
        {(boolean )1, {(char )'S', (char )'L', (char )'A', (char )'D', (char )'R', (char )'I',
                    (char )'P', (char )'3', (char )'\000'}, {(char )'S', (char )'L',
                                                             (char )'A', (char )'D',
                                                             (char )'R', (char )'I',
                                                             (char )'P', (char )'1',
                                                             (char )'\000'}, 8}, 
        {(boolean )1, {(char )'B', (char )'L', (char )'O', (char )'D', (char )'R', (char )'I',
                    (char )'P', (char )'4', (char )'\000'}, {(char )'B', (char )'L',
                                                             (char )'O', (char )'D',
                                                             (char )'R', (char )'I',
                                                             (char )'P', (char )'1',
                                                             (char )'\000'}, 8}, 
        {(boolean )1, {(char )'F', (char )'I', (char )'R', (char )'E', (char )'W', (char )'A',
                    (char )'L', (char )'L', (char )'\000'}, {(char )'F', (char )'I',
                                                             (char )'R', (char )'E',
                                                             (char )'W', (char )'A',
                                                             (char )'L', (char )'A',
                                                             (char )'\000'}, 8}, 
        {(boolean )1, {(char )'G', (char )'S', (char )'T', (char )'F', (char )'O', (char )'N',
                    (char )'T', (char )'3', (char )'\000'}, {(char )'G', (char )'S',
                                                             (char )'T', (char )'F',
                                                             (char )'O', (char )'N',
                                                             (char )'T', (char )'1',
                                                             (char )'\000'}, 8}, 
        {(boolean )1, {(char )'F', (char )'I', (char )'R', (char )'E', (char )'L', (char )'A',
                    (char )'V', (char )'A', (char )'\000'}, {(char )'F', (char )'I',
                                                             (char )'R', (char )'E',
                                                             (char )'L', (char )'A',
                                                             (char )'V', (char )'3',
                                                             (char )'\000'}, 8}, 
        {(boolean )1, {(char )'F', (char )'I', (char )'R', (char )'E', (char )'M', (char )'A',
                    (char )'G', (char )'3', (char )'\000'}, {(char )'F', (char )'I',
                                                             (char )'R', (char )'E',
                                                             (char )'M', (char )'A',
                                                             (char )'G', (char )'1',
                                                             (char )'\000'}, 8}, 
        {(boolean )1, {(char )'F', (char )'I', (char )'R', (char )'E', (char )'B', (char )'L',
                    (char )'U', (char )'2', (char )'\000'}, {(char )'F', (char )'I',
                                                             (char )'R', (char )'E',
                                                             (char )'B', (char )'L',
                                                             (char )'U', (char )'1',
                                                             (char )'\000'}, 8}, 
        {(boolean )1, {(char )'R', (char )'O', (char )'C', (char )'K', (char )'R', (char )'E',
                    (char )'D', (char )'3', (char )'\000'}, {(char )'R', (char )'O',
                                                             (char )'C', (char )'K',
                                                             (char )'R', (char )'E',
                                                             (char )'D', (char )'1',
                                                             (char )'\000'}, 8}, 
        {(boolean )1, {(char )'B', (char )'F', (char )'A', (char )'L', (char )'L', (char )'4',
                    (char )'\000'}, {(char )'B', (char )'F', (char )'A', (char )'L',
                                     (char )'L', (char )'1', (char )'\000'}, 8}, 
        {(boolean )1, {(char )'S', (char )'F', (char )'A', (char )'L', (char )'L', (char )'4',
                    (char )'\000'}, {(char )'S', (char )'F', (char )'A', (char )'L',
                                     (char )'L', (char )'1', (char )'\000'}, 8}, 
        {(boolean )1, {(char )'W', (char )'F', (char )'A', (char )'L', (char )'L', (char )'4',
                    (char )'\000'}, {(char )'W', (char )'F', (char )'A', (char )'L',
                                     (char )'L', (char )'1', (char )'\000'}, 8}, 
        {(boolean )1, {(char )'D', (char )'B', (char )'R', (char )'A', (char )'I', (char )'N',
                    (char )'4', (char )'\000'}, {(char )'D', (char )'B', (char )'R',
                                                 (char )'A', (char )'I', (char )'N',
                                                 (char )'1', (char )'\000'}, 8}, 
        {(boolean )-1, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                     (char)0, (char)0}, {(char)0, (char)0, (char)0, (char)0, (char)0,
                                         (char)0, (char)0, (char)0, (char)0}, 0}};
#line 143 "p_spec.c"
short numlinespecials  ;
#line 144 "p_spec.c"
line_t *linespeciallist[64]  ;
#line 148 "p_spec.c"
void P_InitPicAnims(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 154
  lastanim = anims;
#line 155
  i = 0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! ((unsigned int )animdefs[i].istexture != 4294967295U)) {
#line 155
      goto while_break;
    }
#line 157
    if (animdefs[i].istexture) {
#line 160
      tmp = R_CheckTextureNumForName(animdefs[i].startname);
#line 160
      if (tmp == -1) {
#line 161
        goto __Cont;
      }
#line 163
      lastanim->picnum = R_TextureNumForName(animdefs[i].endname);
#line 164
      lastanim->basepic = R_TextureNumForName(animdefs[i].startname);
    } else {
#line 168
      tmp___0 = W_CheckNumForName(animdefs[i].startname);
#line 168
      if (tmp___0 == -1) {
#line 169
        goto __Cont;
      }
#line 171
      lastanim->picnum = R_FlatNumForName(animdefs[i].endname);
#line 172
      lastanim->basepic = R_FlatNumForName(animdefs[i].startname);
    }
#line 175
    lastanim->istexture = animdefs[i].istexture;
#line 176
    lastanim->numpics = (lastanim->picnum - lastanim->basepic) + 1;
#line 178
    if (lastanim->numpics < 2) {
#line 179
      I_Error("P_InitPicAnims: bad cycle from %s to %s", animdefs[i].startname, animdefs[i].endname);
    }
#line 183
    lastanim->speed = animdefs[i].speed;
#line 184
    lastanim ++;
    __Cont: /* CIL Label */ 
#line 155
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 203 "p_spec.c"
side_t *getSide(int currentSector , int line , int side ) 
{ 


  {
#line 209
  return (sides + (*((sectors + currentSector)->lines + line))->sidenum[side]);
}
}
#line 219 "p_spec.c"
sector_t *getSector(int currentSector , int line , int side ) 
{ 


  {
#line 225
  return ((sides + (*((sectors + currentSector)->lines + line))->sidenum[side])->sector);
}
}
#line 234 "p_spec.c"
int twoSided(int sector , int line ) 
{ 


  {
#line 239
  return ((int )(*((sectors + sector)->lines + line))->flags & 4);
}
}
#line 250 "p_spec.c"
sector_t *getNextSector(line_t *line , sector_t *sec ) 
{ 


  {
#line 255
  if (! ((int )line->flags & 4)) {
#line 256
    return ((sector_t *)((void *)0));
  }
#line 258
  if ((unsigned long )line->frontsector == (unsigned long )sec) {
#line 259
    return (line->backsector);
  }
#line 261
  return (line->frontsector);
}
}
#line 270 "p_spec.c"
fixed_t P_FindLowestFloorSurrounding(sector_t *sec ) 
{ 
  int i ;
  line_t *check ;
  sector_t *other ;
  fixed_t floor___0 ;

  {
#line 275
  floor___0 = sec->floorheight;
#line 277
  i = 0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (i < sec->linecount)) {
#line 277
      goto while_break;
    }
#line 279
    check = *(sec->lines + i);
#line 280
    other = getNextSector(check, sec);
#line 282
    if (! other) {
#line 283
      goto __Cont;
    }
#line 285
    if (other->floorheight < floor___0) {
#line 286
      floor___0 = other->floorheight;
    }
    __Cont: /* CIL Label */ 
#line 277
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return (floor___0);
}
}
#line 297 "p_spec.c"
fixed_t P_FindHighestFloorSurrounding(sector_t *sec ) 
{ 
  int i ;
  line_t *check ;
  sector_t *other ;
  fixed_t floor___0 ;

  {
#line 302
  floor___0 = -500 * (1 << 16);
#line 304
  i = 0;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < sec->linecount)) {
#line 304
      goto while_break;
    }
#line 306
    check = *(sec->lines + i);
#line 307
    other = getNextSector(check, sec);
#line 309
    if (! other) {
#line 310
      goto __Cont;
    }
#line 312
    if (other->floorheight > floor___0) {
#line 313
      floor___0 = other->floorheight;
    }
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  return (floor___0);
}
}
#line 328 "p_spec.c"
fixed_t P_FindNextHighestFloor(sector_t *sec , int currentheight ) 
{ 
  int i ;
  int h ;
  int min ;
  line_t *check ;
  sector_t *other ;
  fixed_t height ;
  fixed_t heightlist[20] ;
  int tmp ;

  {
#line 338
  height = currentheight;
#line 343
  i = 0;
#line 343
  h = 0;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (i < sec->linecount)) {
#line 343
      goto while_break;
    }
#line 345
    check = *(sec->lines + i);
#line 346
    other = getNextSector(check, sec);
#line 348
    if (! other) {
#line 349
      goto __Cont;
    }
#line 351
    if (other->floorheight > height) {
#line 352
      tmp = h;
#line 352
      h ++;
#line 352
      heightlist[tmp] = other->floorheight;
    }
#line 355
    if (h >= 20) {
#line 357
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Sector with more than 20 adjoining sectors\n");
#line 359
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 343
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  if (! h) {
#line 365
    return (currentheight);
  }
#line 367
  min = heightlist[0];
#line 370
  i = 1;
  {
#line 370
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 370
    if (! (i < h)) {
#line 370
      goto while_break___0;
    }
#line 371
    if (heightlist[i] < min) {
#line 372
      min = heightlist[i];
    }
#line 370
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 374
  return (min);
}
}
#line 381 "p_spec.c"
fixed_t P_FindLowestCeilingSurrounding(sector_t *sec ) 
{ 
  int i ;
  line_t *check ;
  sector_t *other ;
  fixed_t height ;

  {
#line 387
  height = 0x7fffffff;
#line 389
  i = 0;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (i < sec->linecount)) {
#line 389
      goto while_break;
    }
#line 391
    check = *(sec->lines + i);
#line 392
    other = getNextSector(check, sec);
#line 394
    if (! other) {
#line 395
      goto __Cont;
    }
#line 397
    if (other->ceilingheight < height) {
#line 398
      height = other->ceilingheight;
    }
    __Cont: /* CIL Label */ 
#line 389
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return (height);
}
}
#line 407 "p_spec.c"
fixed_t P_FindHighestCeilingSurrounding(sector_t *sec ) 
{ 
  int i ;
  line_t *check ;
  sector_t *other ;
  fixed_t height ;

  {
#line 412
  height = 0;
#line 414
  i = 0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < sec->linecount)) {
#line 414
      goto while_break;
    }
#line 416
    check = *(sec->lines + i);
#line 417
    other = getNextSector(check, sec);
#line 419
    if (! other) {
#line 420
      goto __Cont;
    }
#line 422
    if (other->ceilingheight > height) {
#line 423
      height = other->ceilingheight;
    }
    __Cont: /* CIL Label */ 
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  return (height);
}
}
#line 433 "p_spec.c"
int P_FindSectorFromLineTag(line_t *line , int start ) 
{ 
  int i ;

  {
#line 440
  i = start + 1;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (i < numsectors)) {
#line 440
      goto while_break;
    }
#line 441
    if ((int )(sectors + i)->tag == (int )line->tag) {
#line 442
      return (i);
    }
#line 440
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  return (-1);
}
}
#line 453 "p_spec.c"
int P_FindMinSurroundingLight(sector_t *sector , int max ) 
{ 
  int i ;
  int min ;
  line_t *line ;
  sector_t *check ;

  {
#line 463
  min = max;
#line 464
  i = 0;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! (i < sector->linecount)) {
#line 464
      goto while_break;
    }
#line 466
    line = *(sector->lines + i);
#line 467
    check = getNextSector(line, sector);
#line 469
    if (! check) {
#line 470
      goto __Cont;
    }
#line 472
    if ((int )check->lightlevel < min) {
#line 473
      min = (int )check->lightlevel;
    }
    __Cont: /* CIL Label */ 
#line 464
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (min);
}
}
#line 491 "p_spec.c"
void P_CrossSpecialLine(int linenum , int side , mobj_t *thing ) 
{ 
  line_t *line ;
  int ok___0 ;

  {
#line 500
  line = lines + linenum;
#line 503
  if (! thing->player) {
    {
#line 513
    if ((unsigned int )thing->type == 16U) {
#line 513
      goto case_16;
    }
#line 513
    if ((unsigned int )thing->type == 32U) {
#line 513
      goto case_16;
    }
#line 513
    if ((unsigned int )thing->type == 31U) {
#line 513
      goto case_16;
    }
#line 513
    if ((unsigned int )thing->type == 35U) {
#line 513
      goto case_16;
    }
#line 513
    if ((unsigned int )thing->type == 34U) {
#line 513
      goto case_16;
    }
#line 513
    if ((unsigned int )thing->type == 33U) {
#line 513
      goto case_16;
    }
#line 517
    goto switch_default;
    case_16: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
#line 514
    return;
#line 515
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 517
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 520
    ok___0 = 0;
    {
#line 529
    if ((int )line->special == 88) {
#line 529
      goto case_88;
    }
#line 529
    if ((int )line->special == 10) {
#line 529
      goto case_88;
    }
#line 529
    if ((int )line->special == 4) {
#line 529
      goto case_88;
    }
#line 529
    if ((int )line->special == 126) {
#line 529
      goto case_88;
    }
#line 529
    if ((int )line->special == 125) {
#line 529
      goto case_88;
    }
#line 529
    if ((int )line->special == 97) {
#line 529
      goto case_88;
    }
#line 529
    if ((int )line->special == 39) {
#line 529
      goto case_88;
    }
#line 521
    goto switch_break___0;
    case_88: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_126: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 530
    ok___0 = 1;
#line 531
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 533
    if (! ok___0) {
#line 534
      return;
    }
  }
  {
#line 543
  if ((int )line->special == 2) {
#line 543
    goto case_2;
  }
#line 549
  if ((int )line->special == 3) {
#line 549
    goto case_3;
  }
#line 555
  if ((int )line->special == 4) {
#line 555
    goto case_4___0;
  }
#line 561
  if ((int )line->special == 5) {
#line 561
    goto case_5;
  }
#line 567
  if ((int )line->special == 6) {
#line 567
    goto case_6;
  }
#line 573
  if ((int )line->special == 8) {
#line 573
    goto case_8;
  }
#line 579
  if ((int )line->special == 10) {
#line 579
    goto case_10___0;
  }
#line 585
  if ((int )line->special == 12) {
#line 585
    goto case_12;
  }
#line 591
  if ((int )line->special == 13) {
#line 591
    goto case_13;
  }
#line 597
  if ((int )line->special == 16) {
#line 597
    goto case_16___0;
  }
#line 603
  if ((int )line->special == 17) {
#line 603
    goto case_17;
  }
#line 609
  if ((int )line->special == 19) {
#line 609
    goto case_19;
  }
#line 615
  if ((int )line->special == 22) {
#line 615
    goto case_22;
  }
#line 621
  if ((int )line->special == 25) {
#line 621
    goto case_25;
  }
#line 627
  if ((int )line->special == 30) {
#line 627
    goto case_30;
  }
#line 634
  if ((int )line->special == 35) {
#line 634
    goto case_35___0;
  }
#line 640
  if ((int )line->special == 36) {
#line 640
    goto case_36;
  }
#line 646
  if ((int )line->special == 37) {
#line 646
    goto case_37;
  }
#line 652
  if ((int )line->special == 38) {
#line 652
    goto case_38;
  }
#line 658
  if ((int )line->special == 39) {
#line 658
    goto case_39___0;
  }
#line 664
  if ((int )line->special == 40) {
#line 664
    goto case_40;
  }
#line 671
  if ((int )line->special == 44) {
#line 671
    goto case_44;
  }
#line 677
  if ((int )line->special == 52) {
#line 677
    goto case_52;
  }
#line 682
  if ((int )line->special == 53) {
#line 682
    goto case_53;
  }
#line 688
  if ((int )line->special == 54) {
#line 688
    goto case_54;
  }
#line 694
  if ((int )line->special == 56) {
#line 694
    goto case_56;
  }
#line 700
  if ((int )line->special == 57) {
#line 700
    goto case_57;
  }
#line 706
  if ((int )line->special == 58) {
#line 706
    goto case_58;
  }
#line 712
  if ((int )line->special == 59) {
#line 712
    goto case_59;
  }
#line 718
  if ((int )line->special == 104) {
#line 718
    goto case_104;
  }
#line 724
  if ((int )line->special == 108) {
#line 724
    goto case_108;
  }
#line 730
  if ((int )line->special == 109) {
#line 730
    goto case_109;
  }
#line 736
  if ((int )line->special == 100) {
#line 736
    goto case_100;
  }
#line 742
  if ((int )line->special == 110) {
#line 742
    goto case_110;
  }
#line 748
  if ((int )line->special == 119) {
#line 748
    goto case_119;
  }
#line 754
  if ((int )line->special == 121) {
#line 754
    goto case_121;
  }
#line 760
  if ((int )line->special == 124) {
#line 760
    goto case_124;
  }
#line 765
  if ((int )line->special == 125) {
#line 765
    goto case_125___0;
  }
#line 774
  if ((int )line->special == 130) {
#line 774
    goto case_130;
  }
#line 780
  if ((int )line->special == 141) {
#line 780
    goto case_141;
  }
#line 787
  if ((int )line->special == 72) {
#line 787
    goto case_72;
  }
#line 792
  if ((int )line->special == 73) {
#line 792
    goto case_73;
  }
#line 797
  if ((int )line->special == 74) {
#line 797
    goto case_74;
  }
#line 802
  if ((int )line->special == 75) {
#line 802
    goto case_75;
  }
#line 807
  if ((int )line->special == 76) {
#line 807
    goto case_76;
  }
#line 812
  if ((int )line->special == 77) {
#line 812
    goto case_77;
  }
#line 817
  if ((int )line->special == 79) {
#line 817
    goto case_79;
  }
#line 822
  if ((int )line->special == 80) {
#line 822
    goto case_80;
  }
#line 827
  if ((int )line->special == 81) {
#line 827
    goto case_81;
  }
#line 832
  if ((int )line->special == 82) {
#line 832
    goto case_82;
  }
#line 837
  if ((int )line->special == 83) {
#line 837
    goto case_83;
  }
#line 842
  if ((int )line->special == 84) {
#line 842
    goto case_84;
  }
#line 847
  if ((int )line->special == 86) {
#line 847
    goto case_86;
  }
#line 852
  if ((int )line->special == 87) {
#line 852
    goto case_87;
  }
#line 857
  if ((int )line->special == 88) {
#line 857
    goto case_88___0;
  }
#line 862
  if ((int )line->special == 89) {
#line 862
    goto case_89;
  }
#line 867
  if ((int )line->special == 90) {
#line 867
    goto case_90;
  }
#line 872
  if ((int )line->special == 91) {
#line 872
    goto case_91;
  }
#line 877
  if ((int )line->special == 92) {
#line 877
    goto case_92;
  }
#line 882
  if ((int )line->special == 93) {
#line 882
    goto case_93;
  }
#line 887
  if ((int )line->special == 94) {
#line 887
    goto case_94;
  }
#line 892
  if ((int )line->special == 95) {
#line 892
    goto case_95;
  }
#line 898
  if ((int )line->special == 96) {
#line 898
    goto case_96;
  }
#line 904
  if ((int )line->special == 97) {
#line 904
    goto case_97___0;
  }
#line 909
  if ((int )line->special == 98) {
#line 909
    goto case_98;
  }
#line 914
  if ((int )line->special == 105) {
#line 914
    goto case_105;
  }
#line 919
  if ((int )line->special == 106) {
#line 919
    goto case_106;
  }
#line 924
  if ((int )line->special == 107) {
#line 924
    goto case_107;
  }
#line 929
  if ((int )line->special == 120) {
#line 929
    goto case_120;
  }
#line 934
  if ((int )line->special == 126) {
#line 934
    goto case_126___0;
  }
#line 940
  if ((int )line->special == 128) {
#line 940
    goto case_128;
  }
#line 945
  if ((int )line->special == 129) {
#line 945
    goto case_129;
  }
#line 539
  goto switch_break___1;
  case_2: /* CIL Label */ 
#line 545
  EV_DoDoor(line, (vldoor_e )3);
#line 546
  line->special = (short)0;
#line 547
  goto switch_break___1;
  case_3: /* CIL Label */ 
#line 551
  EV_DoDoor(line, (vldoor_e )2);
#line 552
  line->special = (short)0;
#line 553
  goto switch_break___1;
  case_4___0: /* CIL Label */ 
#line 557
  EV_DoDoor(line, (vldoor_e )0);
#line 558
  line->special = (short)0;
#line 559
  goto switch_break___1;
  case_5: /* CIL Label */ 
#line 563
  EV_DoFloor(line, (floor_e )3);
#line 564
  line->special = (short)0;
#line 565
  goto switch_break___1;
  case_6: /* CIL Label */ 
#line 569
  EV_DoCeiling(line, (ceiling_e )4);
#line 570
  line->special = (short)0;
#line 571
  goto switch_break___1;
  case_8: /* CIL Label */ 
#line 575
  EV_BuildStairs(line, (stair_e )0);
#line 576
  line->special = (short)0;
#line 577
  goto switch_break___1;
  case_10___0: /* CIL Label */ 
#line 581
  EV_DoPlat(line, (plattype_e )1, 0);
#line 582
  line->special = (short)0;
#line 583
  goto switch_break___1;
  case_12: /* CIL Label */ 
#line 587
  EV_LightTurnOn(line, 0);
#line 588
  line->special = (short)0;
#line 589
  goto switch_break___1;
  case_13: /* CIL Label */ 
#line 593
  EV_LightTurnOn(line, 255);
#line 594
  line->special = (short)0;
#line 595
  goto switch_break___1;
  case_16___0: /* CIL Label */ 
#line 599
  EV_DoDoor(line, (vldoor_e )1);
#line 600
  line->special = (short)0;
#line 601
  goto switch_break___1;
  case_17: /* CIL Label */ 
#line 605
  EV_StartLightStrobing(line);
#line 606
  line->special = (short)0;
#line 607
  goto switch_break___1;
  case_19: /* CIL Label */ 
#line 611
  EV_DoFloor(line, (floor_e )0);
#line 612
  line->special = (short)0;
#line 613
  goto switch_break___1;
  case_22: /* CIL Label */ 
#line 617
  EV_DoPlat(line, (plattype_e )3, 0);
#line 618
  line->special = (short)0;
#line 619
  goto switch_break___1;
  case_25: /* CIL Label */ 
#line 623
  EV_DoCeiling(line, (ceiling_e )3);
#line 624
  line->special = (short)0;
#line 625
  goto switch_break___1;
  case_30: /* CIL Label */ 
#line 630
  EV_DoFloor(line, (floor_e )5);
#line 631
  line->special = (short)0;
#line 632
  goto switch_break___1;
  case_35___0: /* CIL Label */ 
#line 636
  EV_LightTurnOn(line, 35);
#line 637
  line->special = (short)0;
#line 638
  goto switch_break___1;
  case_36: /* CIL Label */ 
#line 642
  EV_DoFloor(line, (floor_e )2);
#line 643
  line->special = (short)0;
#line 644
  goto switch_break___1;
  case_37: /* CIL Label */ 
#line 648
  EV_DoFloor(line, (floor_e )6);
#line 649
  line->special = (short)0;
#line 650
  goto switch_break___1;
  case_38: /* CIL Label */ 
#line 654
  EV_DoFloor(line, (floor_e )1);
#line 655
  line->special = (short)0;
#line 656
  goto switch_break___1;
  case_39___0: /* CIL Label */ 
#line 660
  EV_Teleport(line, side, thing);
#line 661
  line->special = (short)0;
#line 662
  goto switch_break___1;
  case_40: /* CIL Label */ 
#line 666
  EV_DoCeiling(line, (ceiling_e )1);
#line 667
  EV_DoFloor(line, (floor_e )1);
#line 668
  line->special = (short)0;
#line 669
  goto switch_break___1;
  case_44: /* CIL Label */ 
#line 673
  EV_DoCeiling(line, (ceiling_e )2);
#line 674
  line->special = (short)0;
#line 675
  goto switch_break___1;
  case_52: /* CIL Label */ 
#line 679
  G_ExitLevel();
#line 680
  goto switch_break___1;
  case_53: /* CIL Label */ 
#line 684
  EV_DoPlat(line, (plattype_e )0, 0);
#line 685
  line->special = (short)0;
#line 686
  goto switch_break___1;
  case_54: /* CIL Label */ 
#line 690
  EV_StopPlat(line);
#line 691
  line->special = (short)0;
#line 692
  goto switch_break___1;
  case_56: /* CIL Label */ 
#line 696
  EV_DoFloor(line, (floor_e )9);
#line 697
  line->special = (short)0;
#line 698
  goto switch_break___1;
  case_57: /* CIL Label */ 
#line 702
  EV_CeilingCrushStop(line);
#line 703
  line->special = (short)0;
#line 704
  goto switch_break___1;
  case_58: /* CIL Label */ 
#line 708
  EV_DoFloor(line, (floor_e )7);
#line 709
  line->special = (short)0;
#line 710
  goto switch_break___1;
  case_59: /* CIL Label */ 
#line 714
  EV_DoFloor(line, (floor_e )8);
#line 715
  line->special = (short)0;
#line 716
  goto switch_break___1;
  case_104: /* CIL Label */ 
#line 720
  EV_TurnTagLightsOff(line);
#line 721
  line->special = (short)0;
#line 722
  goto switch_break___1;
  case_108: /* CIL Label */ 
#line 726
  EV_DoDoor(line, (vldoor_e )5);
#line 727
  line->special = (short)0;
#line 728
  goto switch_break___1;
  case_109: /* CIL Label */ 
#line 732
  EV_DoDoor(line, (vldoor_e )6);
#line 733
  line->special = (short)0;
#line 734
  goto switch_break___1;
  case_100: /* CIL Label */ 
#line 738
  EV_BuildStairs(line, (stair_e )1);
#line 739
  line->special = (short)0;
#line 740
  goto switch_break___1;
  case_110: /* CIL Label */ 
#line 744
  EV_DoDoor(line, (vldoor_e )7);
#line 745
  line->special = (short)0;
#line 746
  goto switch_break___1;
  case_119: /* CIL Label */ 
#line 750
  EV_DoFloor(line, (floor_e )4);
#line 751
  line->special = (short)0;
#line 752
  goto switch_break___1;
  case_121: /* CIL Label */ 
#line 756
  EV_DoPlat(line, (plattype_e )4, 0);
#line 757
  line->special = (short)0;
#line 758
  goto switch_break___1;
  case_124: /* CIL Label */ 
#line 762
  G_SecretExitLevel();
#line 763
  goto switch_break___1;
  case_125___0: /* CIL Label */ 
#line 767
  if (! thing->player) {
#line 769
    EV_Teleport(line, side, thing);
#line 770
    line->special = (short)0;
  }
#line 772
  goto switch_break___1;
  case_130: /* CIL Label */ 
#line 776
  EV_DoFloor(line, (floor_e )10);
#line 777
  line->special = (short)0;
#line 778
  goto switch_break___1;
  case_141: /* CIL Label */ 
#line 782
  EV_DoCeiling(line, (ceiling_e )5);
#line 783
  line->special = (short)0;
#line 784
  goto switch_break___1;
  case_72: /* CIL Label */ 
#line 789
  EV_DoCeiling(line, (ceiling_e )2);
#line 790
  goto switch_break___1;
  case_73: /* CIL Label */ 
#line 794
  EV_DoCeiling(line, (ceiling_e )3);
#line 795
  goto switch_break___1;
  case_74: /* CIL Label */ 
#line 799
  EV_CeilingCrushStop(line);
#line 800
  goto switch_break___1;
  case_75: /* CIL Label */ 
#line 804
  EV_DoDoor(line, (vldoor_e )2);
#line 805
  goto switch_break___1;
  case_76: /* CIL Label */ 
#line 809
  EV_DoDoor(line, (vldoor_e )1);
#line 810
  goto switch_break___1;
  case_77: /* CIL Label */ 
#line 814
  EV_DoCeiling(line, (ceiling_e )4);
#line 815
  goto switch_break___1;
  case_79: /* CIL Label */ 
#line 819
  EV_LightTurnOn(line, 35);
#line 820
  goto switch_break___1;
  case_80: /* CIL Label */ 
#line 824
  EV_LightTurnOn(line, 0);
#line 825
  goto switch_break___1;
  case_81: /* CIL Label */ 
#line 829
  EV_LightTurnOn(line, 255);
#line 830
  goto switch_break___1;
  case_82: /* CIL Label */ 
#line 834
  EV_DoFloor(line, (floor_e )1);
#line 835
  goto switch_break___1;
  case_83: /* CIL Label */ 
#line 839
  EV_DoFloor(line, (floor_e )0);
#line 840
  goto switch_break___1;
  case_84: /* CIL Label */ 
#line 844
  EV_DoFloor(line, (floor_e )6);
#line 845
  goto switch_break___1;
  case_86: /* CIL Label */ 
#line 849
  EV_DoDoor(line, (vldoor_e )3);
#line 850
  goto switch_break___1;
  case_87: /* CIL Label */ 
#line 854
  EV_DoPlat(line, (plattype_e )0, 0);
#line 855
  goto switch_break___1;
  case_88___0: /* CIL Label */ 
#line 859
  EV_DoPlat(line, (plattype_e )1, 0);
#line 860
  goto switch_break___1;
  case_89: /* CIL Label */ 
#line 864
  EV_StopPlat(line);
#line 865
  goto switch_break___1;
  case_90: /* CIL Label */ 
#line 869
  EV_DoDoor(line, (vldoor_e )0);
#line 870
  goto switch_break___1;
  case_91: /* CIL Label */ 
#line 874
  EV_DoFloor(line, (floor_e )3);
#line 875
  goto switch_break___1;
  case_92: /* CIL Label */ 
#line 879
  EV_DoFloor(line, (floor_e )7);
#line 880
  goto switch_break___1;
  case_93: /* CIL Label */ 
#line 884
  EV_DoFloor(line, (floor_e )8);
#line 885
  goto switch_break___1;
  case_94: /* CIL Label */ 
#line 889
  EV_DoFloor(line, (floor_e )9);
#line 890
  goto switch_break___1;
  case_95: /* CIL Label */ 
#line 895
  EV_DoPlat(line, (plattype_e )3, 0);
#line 896
  goto switch_break___1;
  case_96: /* CIL Label */ 
#line 901
  EV_DoFloor(line, (floor_e )5);
#line 902
  goto switch_break___1;
  case_97___0: /* CIL Label */ 
#line 906
  EV_Teleport(line, side, thing);
#line 907
  goto switch_break___1;
  case_98: /* CIL Label */ 
#line 911
  EV_DoFloor(line, (floor_e )2);
#line 912
  goto switch_break___1;
  case_105: /* CIL Label */ 
#line 916
  EV_DoDoor(line, (vldoor_e )5);
#line 917
  goto switch_break___1;
  case_106: /* CIL Label */ 
#line 921
  EV_DoDoor(line, (vldoor_e )6);
#line 922
  goto switch_break___1;
  case_107: /* CIL Label */ 
#line 926
  EV_DoDoor(line, (vldoor_e )7);
#line 927
  goto switch_break___1;
  case_120: /* CIL Label */ 
#line 931
  EV_DoPlat(line, (plattype_e )4, 0);
#line 932
  goto switch_break___1;
  case_126___0: /* CIL Label */ 
#line 936
  if (! thing->player) {
#line 937
    EV_Teleport(line, side, thing);
  }
#line 938
  goto switch_break___1;
  case_128: /* CIL Label */ 
#line 942
  EV_DoFloor(line, (floor_e )4);
#line 943
  goto switch_break___1;
  case_129: /* CIL Label */ 
#line 947
  EV_DoFloor(line, (floor_e )10);
#line 948
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 950
  return;
}
}
#line 958 "p_spec.c"
void P_ShootSpecialLine(mobj_t *thing , line_t *line ) 
{ 
  int ok___0 ;

  {
#line 966
  if (! thing->player) {
#line 968
    ok___0 = 0;
    {
#line 971
    if ((int )line->special == 46) {
#line 971
      goto case_46;
    }
#line 969
    goto switch_break;
    case_46: /* CIL Label */ 
#line 973
    ok___0 = 1;
#line 974
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 976
    if (! ok___0) {
#line 977
      return;
    }
  }
  {
#line 982
  if ((int )line->special == 24) {
#line 982
    goto case_24;
  }
#line 988
  if ((int )line->special == 46) {
#line 988
    goto case_46___0;
  }
#line 994
  if ((int )line->special == 47) {
#line 994
    goto case_47;
  }
#line 980
  goto switch_break___0;
  case_24: /* CIL Label */ 
#line 984
  EV_DoFloor(line, (floor_e )3);
#line 985
  P_ChangeSwitchTexture(line, 0);
#line 986
  goto switch_break___0;
  case_46___0: /* CIL Label */ 
#line 990
  EV_DoDoor(line, (vldoor_e )3);
#line 991
  P_ChangeSwitchTexture(line, 1);
#line 992
  goto switch_break___0;
  case_47: /* CIL Label */ 
#line 996
  EV_DoPlat(line, (plattype_e )3, 0);
#line 997
  P_ChangeSwitchTexture(line, 0);
#line 998
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1000
  return;
}
}
#line 1009 "p_spec.c"
void P_PlayerInSpecialSector(player_t *player ) 
{ 
  sector_t *sector ;
  int tmp ;

  {
#line 1013
  sector = ((player->mo)->subsector)->sector;
#line 1016
  if ((player->mo)->z != sector->floorheight) {
#line 1017
    return;
  }
  {
#line 1022
  if ((int )sector->special == 5) {
#line 1022
    goto case_5;
  }
#line 1029
  if ((int )sector->special == 7) {
#line 1029
    goto case_7;
  }
#line 1038
  if ((int )sector->special == 4) {
#line 1038
    goto case_4;
  }
#line 1038
  if ((int )sector->special == 16) {
#line 1038
    goto case_4;
  }
#line 1048
  if ((int )sector->special == 9) {
#line 1048
    goto case_9;
  }
#line 1054
  if ((int )sector->special == 11) {
#line 1054
    goto case_11;
  }
#line 1065
  goto switch_default;
  case_5: /* CIL Label */ 
#line 1024
  if (! player->powers[3]) {
#line 1025
    if (! (leveltime & 0x1f)) {
#line 1026
      P_DamageMobj(player->mo, (mobj_t *)((void *)0), (mobj_t *)((void *)0), 10);
    }
  }
#line 1027
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1031
  if (! player->powers[3]) {
#line 1032
    if (! (leveltime & 0x1f)) {
#line 1033
      P_DamageMobj(player->mo, (mobj_t *)((void *)0), (mobj_t *)((void *)0), 5);
    }
  }
#line 1034
  goto switch_break;
  case_4: /* CIL Label */ 
  case_16: /* CIL Label */ 
#line 1040
  if (! player->powers[3]) {
#line 1040
    goto _L;
  } else {
#line 1040
    tmp = P_Random();
#line 1040
    if (tmp < 5) {
      _L: /* CIL Label */ 
#line 1043
      if (! (leveltime & 0x1f)) {
#line 1044
        P_DamageMobj(player->mo, (mobj_t *)((void *)0), (mobj_t *)((void *)0), 20);
      }
    }
  }
#line 1046
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1050
  (player->secretcount) ++;
#line 1051
  sector->special = (short)0;
#line 1052
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1056
  player->cheats &= -3;
#line 1058
  if (! (leveltime & 0x1f)) {
#line 1059
    P_DamageMobj(player->mo, (mobj_t *)((void *)0), (mobj_t *)((void *)0), 20);
  }
#line 1061
  if (player->health <= 10) {
#line 1062
    G_ExitLevel();
  }
#line 1063
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1066
  I_Error("P_PlayerInSpecialSector: unknown special %i", (int )sector->special);
#line 1069
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1071
  return;
}
}
#line 1083 "p_spec.c"
void P_UpdateSpecials(void) 
{ 
  anim_t *anim ;
  int pic ;
  int i ;
  line_t *line ;

  {
#line 1092
  if ((unsigned int )levelTimer == 1U) {
#line 1094
    levelTimeCount --;
#line 1095
    if (! levelTimeCount) {
#line 1096
      G_ExitLevel();
    }
  }
#line 1100
  anim = anims;
  {
#line 1100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1100
    if (! ((unsigned long )anim < (unsigned long )lastanim)) {
#line 1100
      goto while_break;
    }
#line 1102
    i = anim->basepic;
    {
#line 1102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1102
      if (! (i < anim->basepic + anim->numpics)) {
#line 1102
        goto while_break___0;
      }
#line 1104
      pic = anim->basepic + (leveltime / anim->speed + i) % anim->numpics;
#line 1105
      if (anim->istexture) {
#line 1106
        *(texturetranslation + i) = pic;
      } else {
#line 1108
        *(flattranslation + i) = pic;
      }
#line 1102
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1100
    anim ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1114
  i = 0;
  {
#line 1114
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1114
    if (! (i < (int )numlinespecials)) {
#line 1114
      goto while_break___1;
    }
#line 1116
    line = linespeciallist[i];
    {
#line 1119
    if ((int )line->special == 48) {
#line 1119
      goto case_48;
    }
#line 1117
    goto switch_break;
    case_48: /* CIL Label */ 
#line 1121
    (sides + line->sidenum[0])->textureoffset += 1 << 16;
#line 1122
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1114
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1128
  i = 0;
  {
#line 1128
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1128
    if (! (i < 16)) {
#line 1128
      goto while_break___2;
    }
#line 1129
    if (buttonlist[i].btimer) {
#line 1131
      (buttonlist[i].btimer) --;
#line 1132
      if (! buttonlist[i].btimer) {
        {
#line 1136
        if ((unsigned int )buttonlist[i].where == 0U) {
#line 1136
          goto case_0;
        }
#line 1141
        if ((unsigned int )buttonlist[i].where == 1U) {
#line 1141
          goto case_1;
        }
#line 1146
        if ((unsigned int )buttonlist[i].where == 2U) {
#line 1146
          goto case_2;
        }
#line 1134
        goto switch_break___0;
        case_0: /* CIL Label */ 
#line 1137
        (sides + (buttonlist[i].line)->sidenum[0])->toptexture = (short )buttonlist[i].btexture;
#line 1139
        goto switch_break___0;
        case_1: /* CIL Label */ 
#line 1142
        (sides + (buttonlist[i].line)->sidenum[0])->midtexture = (short )buttonlist[i].btexture;
#line 1144
        goto switch_break___0;
        case_2: /* CIL Label */ 
#line 1147
        (sides + (buttonlist[i].line)->sidenum[0])->bottomtexture = (short )buttonlist[i].btexture;
#line 1149
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 1151
        S_StartSound((void *)((mobj_t *)(& buttonlist[i].soundorg)), 23);
#line 1152
        memset((void *)(& buttonlist[i]), 0, (size_t )sizeof(button_t ));
      }
    }
#line 1128
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1156
  return;
}
}
#line 1163 "p_spec.c"
int EV_DoDonut(line_t *line ) 
{ 
  sector_t *s1 ;
  sector_t *s2 ;
  sector_t *s3 ;
  int secnum ;
  int rtn ;
  int i ;
  floormove_t *floor___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1173
  secnum = -1;
#line 1174
  rtn = 0;
  {
#line 1175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1175
    secnum = P_FindSectorFromLineTag(line, secnum);
#line 1175
    if (! (secnum >= 0)) {
#line 1175
      goto while_break;
    }
#line 1177
    s1 = sectors + secnum;
#line 1180
    if (s1->specialdata) {
#line 1181
      goto while_continue;
    }
#line 1183
    rtn = 1;
#line 1184
    s2 = getNextSector(*(s1->lines + 0), s1);
#line 1185
    i = 0;
    {
#line 1185
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1185
      if (! (i < s2->linecount)) {
#line 1185
        goto while_break___0;
      }
#line 1187
      if (! (*(s2->lines + i))->flags & 4) {
#line 1187
        goto _L;
      } else
#line 1187
      if ((unsigned long )(*(s2->lines + i))->backsector == (unsigned long )s1) {
        _L: /* CIL Label */ 
#line 1189
        goto __Cont;
      }
#line 1190
      s3 = (*(s2->lines + i))->backsector;
#line 1193
      tmp = Z_Malloc((int )sizeof(*floor___0), 51, (void *)0);
#line 1193
      floor___0 = (floormove_t *)tmp;
#line 1194
      P_AddThinker(& floor___0->thinker);
#line 1195
      s2->specialdata = (void *)floor___0;
#line 1196
      floor___0->thinker.function.acp1 = (void (*)(void * ))(& T_MoveFloor);
#line 1197
      floor___0->type = (floor_e )11;
#line 1198
      floor___0->crush = (boolean )0;
#line 1199
      floor___0->direction = 1;
#line 1200
      floor___0->sector = s2;
#line 1201
      floor___0->speed = (1 << 16) / 2;
#line 1202
      floor___0->texture = s3->floorpic;
#line 1203
      floor___0->newspecial = 0;
#line 1204
      floor___0->floordestheight = s3->floorheight;
#line 1207
      tmp___0 = Z_Malloc((int )sizeof(*floor___0), 51, (void *)0);
#line 1207
      floor___0 = (floormove_t *)tmp___0;
#line 1208
      P_AddThinker(& floor___0->thinker);
#line 1209
      s1->specialdata = (void *)floor___0;
#line 1210
      floor___0->thinker.function.acp1 = (void (*)(void * ))(& T_MoveFloor);
#line 1211
      floor___0->type = (floor_e )0;
#line 1212
      floor___0->crush = (boolean )0;
#line 1213
      floor___0->direction = -1;
#line 1214
      floor___0->sector = s1;
#line 1215
      floor___0->speed = (1 << 16) / 2;
#line 1216
      floor___0->floordestheight = s3->floorheight;
#line 1217
      goto while_break___0;
      __Cont: /* CIL Label */ 
#line 1185
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1220
  return (rtn);
}
}
#line 1239 "p_spec.c"
void P_SpawnSpecials(void) 
{ 
  sector_t *sector ;
  int i ;
  int episode ;
  int tmp ;
  int time___1 ;
  int tmp___0 ;

  {
#line 1245
  episode = 1;
#line 1246
  tmp = W_CheckNumForName("texture2");
#line 1246
  if (tmp >= 0) {
#line 1247
    episode = 2;
  }
#line 1251
  levelTimer = (boolean )0;
#line 1253
  i = M_CheckParm("-avg");
#line 1254
  if (i) {
#line 1254
    if (deathmatch) {
#line 1256
      levelTimer = (boolean )1;
#line 1257
      levelTimeCount = 42000;
    } else {
#line 1254
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 1260
  i = M_CheckParm("-timer");
#line 1261
  if (i) {
#line 1261
    if (deathmatch) {
#line 1264
      tmp___0 = atoi((char const   *)*(myargv + (i + 1)));
#line 1264
      time___1 = (tmp___0 * 60) * 35;
#line 1265
      levelTimer = (boolean )1;
#line 1266
      levelTimeCount = time___1;
    } else {
#line 1261
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 1270
  sector = sectors;
#line 1271
  i = 0;
  {
#line 1271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1271
    if (! (i < numsectors)) {
#line 1271
      goto while_break;
    }
#line 1273
    if (! sector->special) {
#line 1274
      goto __Cont;
    }
    {
#line 1278
    if ((int )sector->special == 1) {
#line 1278
      goto case_1;
    }
#line 1283
    if ((int )sector->special == 2) {
#line 1283
      goto case_2;
    }
#line 1288
    if ((int )sector->special == 3) {
#line 1288
      goto case_3;
    }
#line 1293
    if ((int )sector->special == 4) {
#line 1293
      goto case_4;
    }
#line 1299
    if ((int )sector->special == 8) {
#line 1299
      goto case_8;
    }
#line 1303
    if ((int )sector->special == 9) {
#line 1303
      goto case_9;
    }
#line 1308
    if ((int )sector->special == 10) {
#line 1308
      goto case_10;
    }
#line 1313
    if ((int )sector->special == 12) {
#line 1313
      goto case_12;
    }
#line 1318
    if ((int )sector->special == 13) {
#line 1318
      goto case_13;
    }
#line 1323
    if ((int )sector->special == 14) {
#line 1323
      goto case_14;
    }
#line 1328
    if ((int )sector->special == 17) {
#line 1328
      goto case_17;
    }
#line 1276
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1280
    P_SpawnLightFlash(sector);
#line 1281
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1285
    P_SpawnStrobeFlash(sector, 15, 0);
#line 1286
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1290
    P_SpawnStrobeFlash(sector, 35, 0);
#line 1291
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1295
    P_SpawnStrobeFlash(sector, 15, 0);
#line 1296
    sector->special = (short)4;
#line 1297
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1301
    P_SpawnGlowingLight(sector);
#line 1302
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1305
    totalsecret ++;
#line 1306
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1310
    P_SpawnDoorCloseIn30(sector);
#line 1311
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1315
    P_SpawnStrobeFlash(sector, 35, 1);
#line 1316
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1320
    P_SpawnStrobeFlash(sector, 15, 1);
#line 1321
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1325
    P_SpawnDoorRaiseIn5Mins(sector, i);
#line 1326
    goto switch_break;
    case_17: /* CIL Label */ 
#line 1329
    P_SpawnFireFlicker(sector);
#line 1330
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1271
    i ++;
#line 1271
    sector ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1336
  numlinespecials = (short)0;
#line 1337
  i = 0;
  {
#line 1337
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1337
    if (! (i < numlines)) {
#line 1337
      goto while_break___0;
    }
    {
#line 1341
    if ((int )(lines + i)->special == 48) {
#line 1341
      goto case_48;
    }
#line 1339
    goto switch_break___0;
    case_48: /* CIL Label */ 
#line 1343
    linespeciallist[numlinespecials] = lines + i;
#line 1344
    numlinespecials = (short )((int )numlinespecials + 1);
#line 1345
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1337
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1351
  i = 0;
  {
#line 1351
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1351
    if (! (i < 30)) {
#line 1351
      goto while_break___1;
    }
#line 1352
    activeceilings[i] = (ceiling_t *)((void *)0);
#line 1351
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1354
  i = 0;
  {
#line 1354
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1354
    if (! (i < 30)) {
#line 1354
      goto while_break___2;
    }
#line 1355
    activeplats[i] = (plat_t *)((void *)0);
#line 1354
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1357
  i = 0;
  {
#line 1357
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1357
    if (! (i < 16)) {
#line 1357
      goto while_break___3;
    }
#line 1358
    memset((void *)(& buttonlist[i]), 0, (size_t )sizeof(button_t ));
#line 1357
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1362
  return;
}
}
#line 25 "p_switch.c"
static char const   rcsid___35[51]  = 
#line 25 "p_switch.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'s', 
        (char const   )'w',      (char const   )'i',      (char const   )'t',      (char const   )'c', 
        (char const   )'h',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'3',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'1',      (char const   )'/',      (char const   )'2',      (char const   )'8', 
        (char const   )' ',      (char const   )'2',      (char const   )'2',      (char const   )':', 
        (char const   )'0',      (char const   )'8',      (char const   )':',      (char const   )'2', 
        (char const   )'9',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 249 "p_spec.h"
button_t buttonlist[16]  ;
#line 48 "p_switch.c"
switchlist_t alphSwitchList[41]  = 
#line 48 "p_switch.c"
  {      {{(char )'S', (char )'W', (char )'1', (char )'B', (char )'R', (char )'C', (char )'O',
       (char )'M', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'B',
                                    (char )'R', (char )'C', (char )'O', (char )'M',
                                    (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'B', (char )'R', (char )'N', (char )'1',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'B', (char )'R',
                        (char )'N', (char )'1', (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'B', (char )'R', (char )'N', (char )'2',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'B', (char )'R',
                        (char )'N', (char )'2', (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'B', (char )'R', (char )'N', (char )'G',
       (char )'N', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'B',
                                    (char )'R', (char )'N', (char )'G', (char )'N',
                                    (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'B', (char )'R', (char )'O', (char )'W',
       (char )'N', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'B',
                                    (char )'R', (char )'O', (char )'W', (char )'N',
                                    (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'C', (char )'O', (char )'M', (char )'M',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'C', (char )'O',
                        (char )'M', (char )'M', (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'C', (char )'O', (char )'M', (char )'P',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'C', (char )'O',
                        (char )'M', (char )'P', (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'D', (char )'I', (char )'R', (char )'T',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'D', (char )'I',
                        (char )'R', (char )'T', (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'E', (char )'X', (char )'I', (char )'T',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'E', (char )'X',
                        (char )'I', (char )'T', (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'G', (char )'R', (char )'A', (char )'Y',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'G', (char )'R',
                        (char )'A', (char )'Y', (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'G', (char )'R', (char )'A', (char )'Y',
       (char )'1', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'G',
                                    (char )'R', (char )'A', (char )'Y', (char )'1',
                                    (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'M', (char )'E', (char )'T', (char )'A',
       (char )'L', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'M',
                                    (char )'E', (char )'T', (char )'A', (char )'L',
                                    (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'P', (char )'I', (char )'P', (char )'E',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'P', (char )'I',
                        (char )'P', (char )'E', (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'S', (char )'L', (char )'A', (char )'D',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'S', (char )'L',
                        (char )'A', (char )'D', (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'S', (char )'T', (char )'A', (char )'R',
       (char )'G', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'S',
                                    (char )'T', (char )'A', (char )'R', (char )'G',
                                    (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'S', (char )'T', (char )'O', (char )'N',
       (char )'1', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'S',
                                    (char )'T', (char )'O', (char )'N', (char )'1',
                                    (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'S', (char )'T', (char )'O', (char )'N',
       (char )'2', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'S',
                                    (char )'T', (char )'O', (char )'N', (char )'2',
                                    (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'S', (char )'T', (char )'O', (char )'N',
       (char )'E', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'S',
                                    (char )'T', (char )'O', (char )'N', (char )'E',
                                    (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'S', (char )'T', (char )'R', (char )'T',
       (char )'N', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'S',
                                    (char )'T', (char )'R', (char )'T', (char )'N',
                                    (char )'\000'}, (short)1}, 
        {{(char )'S', (char )'W', (char )'1', (char )'B', (char )'L', (char )'U', (char )'E',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'B', (char )'L',
                        (char )'U', (char )'E', (char )'\000'}, (short)2}, 
        {{(char )'S', (char )'W', (char )'1', (char )'C', (char )'M', (char )'T', (char )'\000'},
      {(char )'S', (char )'W', (char )'2', (char )'C', (char )'M', (char )'T', (char )'\000'},
      (short)2}, 
        {{(char )'S', (char )'W', (char )'1', (char )'G', (char )'A', (char )'R', (char )'G',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'G', (char )'A',
                        (char )'R', (char )'G', (char )'\000'}, (short)2}, 
        {{(char )'S', (char )'W', (char )'1', (char )'G', (char )'S', (char )'T', (char )'O',
       (char )'N', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'G',
                                    (char )'S', (char )'T', (char )'O', (char )'N',
                                    (char )'\000'}, (short)2}, 
        {{(char )'S', (char )'W', (char )'1', (char )'H', (char )'O', (char )'T', (char )'\000'},
      {(char )'S', (char )'W', (char )'2', (char )'H', (char )'O', (char )'T', (char )'\000'},
      (short)2}, 
        {{(char )'S', (char )'W', (char )'1', (char )'L', (char )'I', (char )'O', (char )'N',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'L', (char )'I',
                        (char )'O', (char )'N', (char )'\000'}, (short)2}, 
        {{(char )'S', (char )'W', (char )'1', (char )'S', (char )'A', (char )'T', (char )'Y',
       (char )'R', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'S',
                                    (char )'A', (char )'T', (char )'Y', (char )'R',
                                    (char )'\000'}, (short)2}, 
        {{(char )'S', (char )'W', (char )'1', (char )'S', (char )'K', (char )'I', (char )'N',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'S', (char )'K',
                        (char )'I', (char )'N', (char )'\000'}, (short)2}, 
        {{(char )'S', (char )'W', (char )'1', (char )'V', (char )'I', (char )'N', (char )'E',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'V', (char )'I',
                        (char )'N', (char )'E', (char )'\000'}, (short)2}, 
        {{(char )'S', (char )'W', (char )'1', (char )'W', (char )'O', (char )'O', (char )'D',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'W', (char )'O',
                        (char )'O', (char )'D', (char )'\000'}, (short)2}, 
        {{(char )'S', (char )'W', (char )'1', (char )'P', (char )'A', (char )'N', (char )'E',
       (char )'L', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'P',
                                    (char )'A', (char )'N', (char )'E', (char )'L',
                                    (char )'\000'}, (short)3}, 
        {{(char )'S', (char )'W', (char )'1', (char )'R', (char )'O', (char )'C', (char )'K',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'R', (char )'O',
                        (char )'C', (char )'K', (char )'\000'}, (short)3}, 
        {{(char )'S', (char )'W', (char )'1', (char )'M', (char )'E', (char )'T', (char )'2',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'M', (char )'E',
                        (char )'T', (char )'2', (char )'\000'}, (short)3}, 
        {{(char )'S', (char )'W', (char )'1', (char )'W', (char )'D', (char )'M', (char )'E',
       (char )'T', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'W',
                                    (char )'D', (char )'M', (char )'E', (char )'T',
                                    (char )'\000'}, (short)3}, 
        {{(char )'S', (char )'W', (char )'1', (char )'B', (char )'R', (char )'I', (char )'K',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'B', (char )'R',
                        (char )'I', (char )'K', (char )'\000'}, (short)3}, 
        {{(char )'S', (char )'W', (char )'1', (char )'M', (char )'O', (char )'D', (char )'1',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'M', (char )'O',
                        (char )'D', (char )'1', (char )'\000'}, (short)3}, 
        {{(char )'S', (char )'W', (char )'1', (char )'Z', (char )'I', (char )'M', (char )'\000'},
      {(char )'S', (char )'W', (char )'2', (char )'Z', (char )'I', (char )'M', (char )'\000'},
      (short)3}, 
        {{(char )'S', (char )'W', (char )'1', (char )'S', (char )'T', (char )'O', (char )'N',
       (char )'6', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'S',
                                    (char )'T', (char )'O', (char )'N', (char )'6',
                                    (char )'\000'}, (short)3}, 
        {{(char )'S', (char )'W', (char )'1', (char )'T', (char )'E', (char )'K', (char )'\000'},
      {(char )'S', (char )'W', (char )'2', (char )'T', (char )'E', (char )'K', (char )'\000'},
      (short)3}, 
        {{(char )'S', (char )'W', (char )'1', (char )'M', (char )'A', (char )'R', (char )'B',
       (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'M', (char )'A',
                        (char )'R', (char )'B', (char )'\000'}, (short)3}, 
        {{(char )'S', (char )'W', (char )'1', (char )'S', (char )'K', (char )'U', (char )'L',
       (char )'L', (char )'\000'}, {(char )'S', (char )'W', (char )'2', (char )'S',
                                    (char )'K', (char )'U', (char )'L', (char )'L',
                                    (char )'\000'}, (short)3}, 
        {{(char )'\000', (char )'\000'}, {(char )'\000', (char )'\000'}, (short)0}};
#line 99 "p_switch.c"
int switchlist[100]  ;
#line 100 "p_switch.c"
int numswitches  ;
#line 107 "p_switch.c"
void P_InitSwitchList(void) 
{ 
  int i ;
  int index___0 ;
  int episode ;
  int tmp ;
  int tmp___0 ;

  {
#line 113
  episode = 1;
#line 115
  if ((unsigned int )gamemode == 1U) {
#line 116
    episode = 2;
  } else
#line 118
  if ((unsigned int )gamemode == 2U) {
#line 119
    episode = 3;
  }
#line 121
  index___0 = 0;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 50)) {
#line 121
      goto while_break;
    }
#line 123
    if (! alphSwitchList[i].episode) {
#line 125
      numswitches = index___0 / 2;
#line 126
      switchlist[index___0] = -1;
#line 127
      goto while_break;
    }
#line 130
    if ((int )alphSwitchList[i].episode <= episode) {
#line 144
      tmp = index___0;
#line 144
      index___0 ++;
#line 144
      switchlist[tmp] = R_TextureNumForName(alphSwitchList[i].name1);
#line 145
      tmp___0 = index___0;
#line 145
      index___0 ++;
#line 145
      switchlist[tmp___0] = R_TextureNumForName(alphSwitchList[i].name2);
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 154 "p_switch.c"
void P_StartButton(line_t *line , bwhere_e w , int texture , int time___1 ) 
{ 
  int i ;

  {
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < 16)) {
#line 164
      goto while_break;
    }
#line 166
    if (buttonlist[i].btimer) {
#line 166
      if ((unsigned long )buttonlist[i].line == (unsigned long )line) {
#line 170
        return;
      } else {
#line 166
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 176
    if (! (i < 16)) {
#line 176
      goto while_break___0;
    }
#line 178
    if (! buttonlist[i].btimer) {
#line 180
      buttonlist[i].line = line;
#line 181
      buttonlist[i].where = w;
#line 182
      buttonlist[i].btexture = texture;
#line 183
      buttonlist[i].btimer = time___1;
#line 184
      buttonlist[i].soundorg = (mobj_t *)(& (line->frontsector)->soundorg);
#line 185
      return;
    }
#line 176
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 189
  I_Error("P_StartButton: no button slots left!");
#line 190
  return;
}
}
#line 200 "p_switch.c"
void P_ChangeSwitchTexture(line_t *line , int useAgain ) 
{ 
  int texTop ;
  int texMid ;
  int texBot ;
  int i ;
  int sound ;

  {
#line 211
  if (! useAgain) {
#line 212
    line->special = (short)0;
  }
#line 214
  texTop = (int )(sides + line->sidenum[0])->toptexture;
#line 215
  texMid = (int )(sides + line->sidenum[0])->midtexture;
#line 216
  texBot = (int )(sides + line->sidenum[0])->bottomtexture;
#line 218
  sound = 23;
#line 221
  if ((int )line->special == 11) {
#line 222
    sound = 24;
  }
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (i < numswitches * 2)) {
#line 224
      goto while_break;
    }
#line 226
    if (switchlist[i] == texTop) {
#line 228
      S_StartSound((void *)buttonlist[0].soundorg, sound);
#line 229
      (sides + line->sidenum[0])->toptexture = (short )switchlist[i ^ 1];
#line 231
      if (useAgain) {
#line 232
        P_StartButton(line, (bwhere_e )0, switchlist[i], 35);
      }
#line 234
      return;
    } else
#line 238
    if (switchlist[i] == texMid) {
#line 240
      S_StartSound((void *)buttonlist[0].soundorg, sound);
#line 241
      (sides + line->sidenum[0])->midtexture = (short )switchlist[i ^ 1];
#line 243
      if (useAgain) {
#line 244
        P_StartButton(line, (bwhere_e )1, switchlist[i], 35);
      }
#line 246
      return;
    } else
#line 250
    if (switchlist[i] == texBot) {
#line 252
      S_StartSound((void *)buttonlist[0].soundorg, sound);
#line 253
      (sides + line->sidenum[0])->bottomtexture = (short )switchlist[i ^ 1];
#line 255
      if (useAgain) {
#line 256
        P_StartButton(line, (bwhere_e )2, switchlist[i], 35);
      }
#line 258
      return;
    }
#line 224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return;
}
}
#line 275 "p_switch.c"
boolean P_UseSpecialLine(mobj_t *thing , line_t *line , int side ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;

  {
#line 284
  if (side) {
    {
#line 288
    if ((int )line->special == 124) {
#line 288
      goto case_124;
    }
#line 293
    goto switch_default;
    case_124: /* CIL Label */ 
#line 291
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 294
    return ((boolean )0);
#line 295
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 301
  if (! thing->player) {
#line 304
    if ((int )line->flags & 32) {
#line 305
      return ((boolean )0);
    }
    {
#line 312
    if ((int )line->special == 34) {
#line 312
      goto case_34;
    }
#line 312
    if ((int )line->special == 33) {
#line 312
      goto case_34;
    }
#line 312
    if ((int )line->special == 32) {
#line 312
      goto case_34;
    }
#line 312
    if ((int )line->special == 1) {
#line 312
      goto case_34;
    }
#line 315
    goto switch_default___0;
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 313
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 316
    return ((boolean )0);
#line 317
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 337
  if ((int )line->special == 118) {
#line 337
    goto case_118;
  }
#line 337
  if ((int )line->special == 117) {
#line 337
    goto case_118;
  }
#line 337
  if ((int )line->special == 34) {
#line 337
    goto case_118;
  }
#line 337
  if ((int )line->special == 33) {
#line 337
    goto case_118;
  }
#line 337
  if ((int )line->special == 32) {
#line 337
    goto case_118;
  }
#line 337
  if ((int )line->special == 31) {
#line 337
    goto case_118;
  }
#line 337
  if ((int )line->special == 28) {
#line 337
    goto case_118;
  }
#line 337
  if ((int )line->special == 27) {
#line 337
    goto case_118;
  }
#line 337
  if ((int )line->special == 26) {
#line 337
    goto case_118;
  }
#line 337
  if ((int )line->special == 1) {
#line 337
    goto case_118;
  }
#line 347
  if ((int )line->special == 7) {
#line 347
    goto case_7;
  }
#line 353
  if ((int )line->special == 9) {
#line 353
    goto case_9;
  }
#line 359
  if ((int )line->special == 11) {
#line 359
    goto case_11;
  }
#line 365
  if ((int )line->special == 14) {
#line 365
    goto case_14;
  }
#line 371
  if ((int )line->special == 15) {
#line 371
    goto case_15;
  }
#line 377
  if ((int )line->special == 18) {
#line 377
    goto case_18;
  }
#line 383
  if ((int )line->special == 20) {
#line 383
    goto case_20;
  }
#line 389
  if ((int )line->special == 21) {
#line 389
    goto case_21;
  }
#line 395
  if ((int )line->special == 23) {
#line 395
    goto case_23;
  }
#line 401
  if ((int )line->special == 29) {
#line 401
    goto case_29;
  }
#line 407
  if ((int )line->special == 41) {
#line 407
    goto case_41;
  }
#line 413
  if ((int )line->special == 71) {
#line 413
    goto case_71;
  }
#line 419
  if ((int )line->special == 49) {
#line 419
    goto case_49;
  }
#line 425
  if ((int )line->special == 50) {
#line 425
    goto case_50;
  }
#line 431
  if ((int )line->special == 51) {
#line 431
    goto case_51;
  }
#line 437
  if ((int )line->special == 55) {
#line 437
    goto case_55;
  }
#line 443
  if ((int )line->special == 101) {
#line 443
    goto case_101;
  }
#line 449
  if ((int )line->special == 102) {
#line 449
    goto case_102;
  }
#line 455
  if ((int )line->special == 103) {
#line 455
    goto case_103;
  }
#line 461
  if ((int )line->special == 111) {
#line 461
    goto case_111;
  }
#line 467
  if ((int )line->special == 112) {
#line 467
    goto case_112;
  }
#line 473
  if ((int )line->special == 113) {
#line 473
    goto case_113;
  }
#line 479
  if ((int )line->special == 122) {
#line 479
    goto case_122;
  }
#line 485
  if ((int )line->special == 127) {
#line 485
    goto case_127;
  }
#line 491
  if ((int )line->special == 131) {
#line 491
    goto case_131;
  }
#line 501
  if ((int )line->special == 137) {
#line 501
    goto case_137;
  }
#line 501
  if ((int )line->special == 135) {
#line 501
    goto case_137;
  }
#line 501
  if ((int )line->special == 133) {
#line 501
    goto case_137;
  }
#line 507
  if ((int )line->special == 140) {
#line 507
    goto case_140;
  }
#line 514
  if ((int )line->special == 42) {
#line 514
    goto case_42;
  }
#line 520
  if ((int )line->special == 43) {
#line 520
    goto case_43;
  }
#line 526
  if ((int )line->special == 45) {
#line 526
    goto case_45;
  }
#line 532
  if ((int )line->special == 60) {
#line 532
    goto case_60;
  }
#line 538
  if ((int )line->special == 61) {
#line 538
    goto case_61;
  }
#line 544
  if ((int )line->special == 62) {
#line 544
    goto case_62;
  }
#line 550
  if ((int )line->special == 63) {
#line 550
    goto case_63;
  }
#line 556
  if ((int )line->special == 64) {
#line 556
    goto case_64;
  }
#line 562
  if ((int )line->special == 66) {
#line 562
    goto case_66;
  }
#line 568
  if ((int )line->special == 67) {
#line 568
    goto case_67;
  }
#line 574
  if ((int )line->special == 65) {
#line 574
    goto case_65;
  }
#line 580
  if ((int )line->special == 68) {
#line 580
    goto case_68;
  }
#line 586
  if ((int )line->special == 69) {
#line 586
    goto case_69;
  }
#line 592
  if ((int )line->special == 70) {
#line 592
    goto case_70;
  }
#line 598
  if ((int )line->special == 114) {
#line 598
    goto case_114;
  }
#line 604
  if ((int )line->special == 115) {
#line 604
    goto case_115;
  }
#line 610
  if ((int )line->special == 116) {
#line 610
    goto case_116;
  }
#line 616
  if ((int )line->special == 123) {
#line 616
    goto case_123;
  }
#line 622
  if ((int )line->special == 132) {
#line 622
    goto case_132;
  }
#line 632
  if ((int )line->special == 136) {
#line 632
    goto case_136;
  }
#line 632
  if ((int )line->special == 134) {
#line 632
    goto case_136;
  }
#line 632
  if ((int )line->special == 99) {
#line 632
    goto case_136;
  }
#line 638
  if ((int )line->special == 138) {
#line 638
    goto case_138;
  }
#line 644
  if ((int )line->special == 139) {
#line 644
    goto case_139;
  }
#line 323
  goto switch_break___1;
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_34___0: /* CIL Label */ 
  case_33___0: /* CIL Label */ 
  case_32___0: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 338
  EV_VerticalDoor(line, thing);
#line 339
  goto switch_break___1;
  case_7: /* CIL Label */ 
#line 349
  tmp = EV_BuildStairs(line, (stair_e )0);
#line 349
  if (tmp) {
#line 350
    P_ChangeSwitchTexture(line, 0);
  }
#line 351
  goto switch_break___1;
  case_9: /* CIL Label */ 
#line 355
  tmp___0 = EV_DoDonut(line);
#line 355
  if (tmp___0) {
#line 356
    P_ChangeSwitchTexture(line, 0);
  }
#line 357
  goto switch_break___1;
  case_11: /* CIL Label */ 
#line 361
  P_ChangeSwitchTexture(line, 0);
#line 362
  G_ExitLevel();
#line 363
  goto switch_break___1;
  case_14: /* CIL Label */ 
#line 367
  tmp___1 = EV_DoPlat(line, (plattype_e )2, 32);
#line 367
  if (tmp___1) {
#line 368
    P_ChangeSwitchTexture(line, 0);
  }
#line 369
  goto switch_break___1;
  case_15: /* CIL Label */ 
#line 373
  tmp___2 = EV_DoPlat(line, (plattype_e )2, 24);
#line 373
  if (tmp___2) {
#line 374
    P_ChangeSwitchTexture(line, 0);
  }
#line 375
  goto switch_break___1;
  case_18: /* CIL Label */ 
#line 379
  tmp___3 = EV_DoFloor(line, (floor_e )4);
#line 379
  if (tmp___3) {
#line 380
    P_ChangeSwitchTexture(line, 0);
  }
#line 381
  goto switch_break___1;
  case_20: /* CIL Label */ 
#line 385
  tmp___4 = EV_DoPlat(line, (plattype_e )3, 0);
#line 385
  if (tmp___4) {
#line 386
    P_ChangeSwitchTexture(line, 0);
  }
#line 387
  goto switch_break___1;
  case_21: /* CIL Label */ 
#line 391
  tmp___5 = EV_DoPlat(line, (plattype_e )1, 0);
#line 391
  if (tmp___5) {
#line 392
    P_ChangeSwitchTexture(line, 0);
  }
#line 393
  goto switch_break___1;
  case_23: /* CIL Label */ 
#line 397
  tmp___6 = EV_DoFloor(line, (floor_e )1);
#line 397
  if (tmp___6) {
#line 398
    P_ChangeSwitchTexture(line, 0);
  }
#line 399
  goto switch_break___1;
  case_29: /* CIL Label */ 
#line 403
  tmp___7 = EV_DoDoor(line, (vldoor_e )0);
#line 403
  if (tmp___7) {
#line 404
    P_ChangeSwitchTexture(line, 0);
  }
#line 405
  goto switch_break___1;
  case_41: /* CIL Label */ 
#line 409
  tmp___8 = EV_DoCeiling(line, (ceiling_e )0);
#line 409
  if (tmp___8) {
#line 410
    P_ChangeSwitchTexture(line, 0);
  }
#line 411
  goto switch_break___1;
  case_71: /* CIL Label */ 
#line 415
  tmp___9 = EV_DoFloor(line, (floor_e )2);
#line 415
  if (tmp___9) {
#line 416
    P_ChangeSwitchTexture(line, 0);
  }
#line 417
  goto switch_break___1;
  case_49: /* CIL Label */ 
#line 421
  tmp___10 = EV_DoCeiling(line, (ceiling_e )3);
#line 421
  if (tmp___10) {
#line 422
    P_ChangeSwitchTexture(line, 0);
  }
#line 423
  goto switch_break___1;
  case_50: /* CIL Label */ 
#line 427
  tmp___11 = EV_DoDoor(line, (vldoor_e )2);
#line 427
  if (tmp___11) {
#line 428
    P_ChangeSwitchTexture(line, 0);
  }
#line 429
  goto switch_break___1;
  case_51: /* CIL Label */ 
#line 433
  P_ChangeSwitchTexture(line, 0);
#line 434
  G_SecretExitLevel();
#line 435
  goto switch_break___1;
  case_55: /* CIL Label */ 
#line 439
  tmp___12 = EV_DoFloor(line, (floor_e )9);
#line 439
  if (tmp___12) {
#line 440
    P_ChangeSwitchTexture(line, 0);
  }
#line 441
  goto switch_break___1;
  case_101: /* CIL Label */ 
#line 445
  tmp___13 = EV_DoFloor(line, (floor_e )3);
#line 445
  if (tmp___13) {
#line 446
    P_ChangeSwitchTexture(line, 0);
  }
#line 447
  goto switch_break___1;
  case_102: /* CIL Label */ 
#line 451
  tmp___14 = EV_DoFloor(line, (floor_e )0);
#line 451
  if (tmp___14) {
#line 452
    P_ChangeSwitchTexture(line, 0);
  }
#line 453
  goto switch_break___1;
  case_103: /* CIL Label */ 
#line 457
  tmp___15 = EV_DoDoor(line, (vldoor_e )3);
#line 457
  if (tmp___15) {
#line 458
    P_ChangeSwitchTexture(line, 0);
  }
#line 459
  goto switch_break___1;
  case_111: /* CIL Label */ 
#line 463
  tmp___16 = EV_DoDoor(line, (vldoor_e )5);
#line 463
  if (tmp___16) {
#line 464
    P_ChangeSwitchTexture(line, 0);
  }
#line 465
  goto switch_break___1;
  case_112: /* CIL Label */ 
#line 469
  tmp___17 = EV_DoDoor(line, (vldoor_e )6);
#line 469
  if (tmp___17) {
#line 470
    P_ChangeSwitchTexture(line, 0);
  }
#line 471
  goto switch_break___1;
  case_113: /* CIL Label */ 
#line 475
  tmp___18 = EV_DoDoor(line, (vldoor_e )7);
#line 475
  if (tmp___18) {
#line 476
    P_ChangeSwitchTexture(line, 0);
  }
#line 477
  goto switch_break___1;
  case_122: /* CIL Label */ 
#line 481
  tmp___19 = EV_DoPlat(line, (plattype_e )4, 0);
#line 481
  if (tmp___19) {
#line 482
    P_ChangeSwitchTexture(line, 0);
  }
#line 483
  goto switch_break___1;
  case_127: /* CIL Label */ 
#line 487
  tmp___20 = EV_BuildStairs(line, (stair_e )1);
#line 487
  if (tmp___20) {
#line 488
    P_ChangeSwitchTexture(line, 0);
  }
#line 489
  goto switch_break___1;
  case_131: /* CIL Label */ 
#line 493
  tmp___21 = EV_DoFloor(line, (floor_e )10);
#line 493
  if (tmp___21) {
#line 494
    P_ChangeSwitchTexture(line, 0);
  }
#line 495
  goto switch_break___1;
  case_137: /* CIL Label */ 
  case_135: /* CIL Label */ 
  case_133: /* CIL Label */ 
#line 503
  tmp___22 = EV_DoLockedDoor(line, (vldoor_e )6, thing);
#line 503
  if (tmp___22) {
#line 504
    P_ChangeSwitchTexture(line, 0);
  }
#line 505
  goto switch_break___1;
  case_140: /* CIL Label */ 
#line 509
  tmp___23 = EV_DoFloor(line, (floor_e )12);
#line 509
  if (tmp___23) {
#line 510
    P_ChangeSwitchTexture(line, 0);
  }
#line 511
  goto switch_break___1;
  case_42: /* CIL Label */ 
#line 516
  tmp___24 = EV_DoDoor(line, (vldoor_e )2);
#line 516
  if (tmp___24) {
#line 517
    P_ChangeSwitchTexture(line, 1);
  }
#line 518
  goto switch_break___1;
  case_43: /* CIL Label */ 
#line 522
  tmp___25 = EV_DoCeiling(line, (ceiling_e )0);
#line 522
  if (tmp___25) {
#line 523
    P_ChangeSwitchTexture(line, 1);
  }
#line 524
  goto switch_break___1;
  case_45: /* CIL Label */ 
#line 528
  tmp___26 = EV_DoFloor(line, (floor_e )0);
#line 528
  if (tmp___26) {
#line 529
    P_ChangeSwitchTexture(line, 1);
  }
#line 530
  goto switch_break___1;
  case_60: /* CIL Label */ 
#line 534
  tmp___27 = EV_DoFloor(line, (floor_e )1);
#line 534
  if (tmp___27) {
#line 535
    P_ChangeSwitchTexture(line, 1);
  }
#line 536
  goto switch_break___1;
  case_61: /* CIL Label */ 
#line 540
  tmp___28 = EV_DoDoor(line, (vldoor_e )3);
#line 540
  if (tmp___28) {
#line 541
    P_ChangeSwitchTexture(line, 1);
  }
#line 542
  goto switch_break___1;
  case_62: /* CIL Label */ 
#line 546
  tmp___29 = EV_DoPlat(line, (plattype_e )1, 1);
#line 546
  if (tmp___29) {
#line 547
    P_ChangeSwitchTexture(line, 1);
  }
#line 548
  goto switch_break___1;
  case_63: /* CIL Label */ 
#line 552
  tmp___30 = EV_DoDoor(line, (vldoor_e )0);
#line 552
  if (tmp___30) {
#line 553
    P_ChangeSwitchTexture(line, 1);
  }
#line 554
  goto switch_break___1;
  case_64: /* CIL Label */ 
#line 558
  tmp___31 = EV_DoFloor(line, (floor_e )3);
#line 558
  if (tmp___31) {
#line 559
    P_ChangeSwitchTexture(line, 1);
  }
#line 560
  goto switch_break___1;
  case_66: /* CIL Label */ 
#line 564
  tmp___32 = EV_DoPlat(line, (plattype_e )2, 24);
#line 564
  if (tmp___32) {
#line 565
    P_ChangeSwitchTexture(line, 1);
  }
#line 566
  goto switch_break___1;
  case_67: /* CIL Label */ 
#line 570
  tmp___33 = EV_DoPlat(line, (plattype_e )2, 32);
#line 570
  if (tmp___33) {
#line 571
    P_ChangeSwitchTexture(line, 1);
  }
#line 572
  goto switch_break___1;
  case_65: /* CIL Label */ 
#line 576
  tmp___34 = EV_DoFloor(line, (floor_e )9);
#line 576
  if (tmp___34) {
#line 577
    P_ChangeSwitchTexture(line, 1);
  }
#line 578
  goto switch_break___1;
  case_68: /* CIL Label */ 
#line 582
  tmp___35 = EV_DoPlat(line, (plattype_e )3, 0);
#line 582
  if (tmp___35) {
#line 583
    P_ChangeSwitchTexture(line, 1);
  }
#line 584
  goto switch_break___1;
  case_69: /* CIL Label */ 
#line 588
  tmp___36 = EV_DoFloor(line, (floor_e )4);
#line 588
  if (tmp___36) {
#line 589
    P_ChangeSwitchTexture(line, 1);
  }
#line 590
  goto switch_break___1;
  case_70: /* CIL Label */ 
#line 594
  tmp___37 = EV_DoFloor(line, (floor_e )2);
#line 594
  if (tmp___37) {
#line 595
    P_ChangeSwitchTexture(line, 1);
  }
#line 596
  goto switch_break___1;
  case_114: /* CIL Label */ 
#line 600
  tmp___38 = EV_DoDoor(line, (vldoor_e )5);
#line 600
  if (tmp___38) {
#line 601
    P_ChangeSwitchTexture(line, 1);
  }
#line 602
  goto switch_break___1;
  case_115: /* CIL Label */ 
#line 606
  tmp___39 = EV_DoDoor(line, (vldoor_e )6);
#line 606
  if (tmp___39) {
#line 607
    P_ChangeSwitchTexture(line, 1);
  }
#line 608
  goto switch_break___1;
  case_116: /* CIL Label */ 
#line 612
  tmp___40 = EV_DoDoor(line, (vldoor_e )7);
#line 612
  if (tmp___40) {
#line 613
    P_ChangeSwitchTexture(line, 1);
  }
#line 614
  goto switch_break___1;
  case_123: /* CIL Label */ 
#line 618
  tmp___41 = EV_DoPlat(line, (plattype_e )4, 0);
#line 618
  if (tmp___41) {
#line 619
    P_ChangeSwitchTexture(line, 1);
  }
#line 620
  goto switch_break___1;
  case_132: /* CIL Label */ 
#line 624
  tmp___42 = EV_DoFloor(line, (floor_e )10);
#line 624
  if (tmp___42) {
#line 625
    P_ChangeSwitchTexture(line, 1);
  }
#line 626
  goto switch_break___1;
  case_136: /* CIL Label */ 
  case_134: /* CIL Label */ 
  case_99: /* CIL Label */ 
#line 634
  tmp___43 = EV_DoLockedDoor(line, (vldoor_e )6, thing);
#line 634
  if (tmp___43) {
#line 635
    P_ChangeSwitchTexture(line, 1);
  }
#line 636
  goto switch_break___1;
  case_138: /* CIL Label */ 
#line 640
  EV_LightTurnOn(line, 255);
#line 641
  P_ChangeSwitchTexture(line, 1);
#line 642
  goto switch_break___1;
  case_139: /* CIL Label */ 
#line 646
  EV_LightTurnOn(line, 35);
#line 647
  P_ChangeSwitchTexture(line, 1);
#line 648
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 652
  return ((boolean )1);
}
}
#line 24 "p_mobj.c"
static char const   rcsid___36[49]  = 
#line 24 "p_mobj.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'m', 
        (char const   )'o',      (char const   )'b',      (char const   )'j',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'2',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 101 "p_local.h"
mapthing_t itemrespawnque[128]  ;
#line 102 "p_local.h"
int itemrespawntime[128]  ;
#line 103 "p_local.h"
int iquehead  ;
#line 104 "p_local.h"
int iquetail  ;
#line 51 "p_mobj.c"
int test  ;
#line 53 "p_mobj.c"
boolean P_SetMobjState(mobj_t *mobj , statenum_t state___0 ) 
{ 
  state_t *st ;

  {
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if ((unsigned int )state___0 == 0U) {
#line 64
      mobj->state = (state_t *)0;
#line 65
      P_RemoveMobj(mobj);
#line 66
      return ((boolean )0);
    }
#line 69
    st = & states[state___0];
#line 70
    mobj->state = st;
#line 71
    mobj->tics = (int )st->tics;
#line 72
    mobj->sprite = st->sprite;
#line 73
    mobj->frame = (int )st->frame;
#line 77
    if (st->action.acp1) {
#line 78
      (*(st->action.acp1))((void *)mobj);
    }
#line 80
    state___0 = st->nextstate;
#line 60
    if (! (! mobj->tics)) {
#line 60
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return ((boolean )1);
}
}
#line 90 "p_mobj.c"
void P_ExplodeMissile(mobj_t *mo ) 
{ 
  fixed_t tmp ;
  fixed_t tmp___0 ;
  int tmp___1 ;

  {
#line 92
  tmp___0 = 0;
#line 92
  mo->momz = tmp___0;
#line 92
  tmp = tmp___0;
#line 92
  mo->momy = tmp;
#line 92
  mo->momx = tmp;
#line 94
  P_SetMobjState(mo, (statenum_t )mobjinfo[mo->type].deathstate);
#line 96
  tmp___1 = P_Random();
#line 96
  mo->tics -= tmp___1 & 3;
#line 98
  if (mo->tics < 1) {
#line 99
    mo->tics = 1;
  }
#line 101
  mo->flags &= -65537;
#line 103
  if ((mo->info)->deathsound) {
#line 104
    S_StartSound((void *)mo, (mo->info)->deathsound);
  }
#line 105
  return;
}
}
#line 114 "p_mobj.c"
void P_XYMovement(mobj_t *mo ) 
{ 
  fixed_t ptryx ;
  fixed_t ptryy ;
  player_t *player ;
  fixed_t xmove ;
  fixed_t ymove ;
  fixed_t tmp ;
  fixed_t tmp___0 ;
  fixed_t tmp___1 ;
  boolean tmp___2 ;
  fixed_t tmp___3 ;

  {
#line 122
  if (! mo->momx) {
#line 122
    if (! mo->momy) {
#line 124
      if (mo->flags & 16777216) {
#line 127
        mo->flags &= -16777217;
#line 128
        tmp___0 = 0;
#line 128
        mo->momz = tmp___0;
#line 128
        tmp = tmp___0;
#line 128
        mo->momy = tmp;
#line 128
        mo->momx = tmp;
#line 130
        P_SetMobjState(mo, (statenum_t )(mo->info)->spawnstate);
      }
#line 132
      return;
    } else {
#line 122
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 135
  player = mo->player;
#line 137
  if (mo->momx > 30 * (1 << 16)) {
#line 138
    mo->momx = 30 * (1 << 16);
  } else
#line 139
  if (mo->momx < - (30 * (1 << 16))) {
#line 140
    mo->momx = - (30 * (1 << 16));
  }
#line 142
  if (mo->momy > 30 * (1 << 16)) {
#line 143
    mo->momy = 30 * (1 << 16);
  } else
#line 144
  if (mo->momy < - (30 * (1 << 16))) {
#line 145
    mo->momy = - (30 * (1 << 16));
  }
#line 147
  xmove = mo->momx;
#line 148
  ymove = mo->momy;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (xmove > (30 * (1 << 16)) / 2) {
#line 152
      goto _L___0;
    } else
#line 152
    if (ymove > (30 * (1 << 16)) / 2) {
      _L___0: /* CIL Label */ 
#line 154
      ptryx = mo->x + xmove / 2;
#line 155
      ptryy = mo->y + ymove / 2;
#line 156
      xmove >>= 1;
#line 157
      ymove >>= 1;
    } else {
#line 161
      ptryx = mo->x + xmove;
#line 162
      ptryy = mo->y + ymove;
#line 163
      ymove = 0;
#line 163
      xmove = ymove;
    }
#line 166
    tmp___2 = P_TryMove(mo, ptryx, ptryy);
#line 166
    if (! tmp___2) {
#line 169
      if (mo->player) {
#line 171
        P_SlideMove(mo);
      } else
#line 173
      if (mo->flags & 65536) {
#line 176
        if (ceilingline) {
#line 176
          if (ceilingline->backsector) {
#line 176
            if ((int )(ceilingline->backsector)->ceilingpic == skyflatnum) {
#line 183
              P_RemoveMobj(mo);
#line 184
              return;
            } else {
#line 176
              goto _L___2;
            }
          } else {
#line 176
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          _L___1: /* CIL Label */ ;
        }
#line 186
        P_ExplodeMissile(mo);
      } else {
#line 189
        tmp___1 = 0;
#line 189
        mo->momy = tmp___1;
#line 189
        mo->momx = tmp___1;
      }
    }
#line 150
    if (xmove) {
#line 150
      goto _L___3;
    } else
#line 150
    if (ymove) {
      _L___3: /* CIL Label */ ;
    } else {
#line 150
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  if (player) {
#line 194
    if (player->cheats & 4) {
#line 197
      tmp___3 = 0;
#line 197
      mo->momy = tmp___3;
#line 197
      mo->momx = tmp___3;
#line 198
      return;
    } else {
#line 194
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ ;
  }
#line 201
  if (mo->flags & 16842752) {
#line 202
    return;
  }
#line 204
  if (mo->z > mo->floorz) {
#line 205
    return;
  }
#line 207
  if (mo->flags & 1048576) {
#line 211
    if (mo->momx > (1 << 16) / 4) {
#line 211
      goto _L___7;
    } else
#line 211
    if (mo->momx < - (1 << 16) / 4) {
      _L___7: /* CIL Label */ 
#line 211
      goto _L___6;
    } else
#line 211
    if (mo->momy > (1 << 16) / 4) {
      _L___6: /* CIL Label */ 
#line 211
      goto _L___5;
    } else
#line 211
    if (mo->momy < - (1 << 16) / 4) {
      _L___5: /* CIL Label */ 
#line 216
      if (mo->floorz != ((mo->subsector)->sector)->floorheight) {
#line 217
        return;
      }
    }
  }
#line 221
  if (mo->momx > -4096) {
#line 221
    if (mo->momx < 0x1000) {
#line 221
      if (mo->momy > -4096) {
#line 221
        if (mo->momy < 0x1000) {
#line 221
          if (! player) {
#line 221
            goto _L___10;
          } else
#line 221
          if ((int )player->cmd.forwardmove == 0) {
#line 221
            if ((int )player->cmd.sidemove == 0) {
              _L___10: /* CIL Label */ 
#line 230
              if (player) {
#line 230
                if ((unsigned int )(((player->mo)->state - states) - 150L) < 4U) {
#line 231
                  P_SetMobjState(player->mo, (statenum_t )149);
                } else {
#line 230
                  goto _L___8;
                }
              } else {
                _L___8: /* CIL Label */ ;
              }
#line 233
              mo->momx = 0;
#line 234
              mo->momy = 0;
            } else {
#line 221
              goto _L___11;
            }
          } else {
            _L___11: /* CIL Label */ 
#line 221
            goto _L___14;
          }
        } else {
#line 221
          goto _L___14;
        }
      } else {
#line 221
        goto _L___14;
      }
    } else {
#line 221
      goto _L___14;
    }
  } else {
    _L___14: /* CIL Label */ 
    _L___13: /* CIL Label */ 
    _L___12: /* CIL Label */ 
    _L___9: /* CIL Label */ 
#line 238
    mo->momx = FixedMul(mo->momx, 0xe800);
#line 239
    mo->momy = FixedMul(mo->momy, 0xe800);
  }
#line 241
  return;
}
}
#line 246 "p_mobj.c"
void P_ZMovement(mobj_t *mo ) 
{ 
  fixed_t dist ;
  fixed_t delta ;

  {
#line 252
  if (mo->player) {
#line 252
    if (mo->z < mo->floorz) {
#line 254
      (mo->player)->viewheight -= mo->floorz - mo->z;
#line 256
      (mo->player)->deltaviewheight = (41 * (1 << 16) - (mo->player)->viewheight) >> 3;
    } else {
#line 252
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 261
  mo->z += mo->momz;
#line 263
  if (mo->flags & 16384) {
#line 263
    if (mo->target) {
#line 267
      if (! (mo->flags & 16777216)) {
#line 267
        if (! (mo->flags & 2097152)) {
#line 270
          dist = P_AproxDistance(mo->x - (mo->target)->x, mo->y - (mo->target)->y);
#line 273
          delta = ((mo->target)->z + (mo->height >> 1)) - mo->z;
#line 275
          if (delta < 0) {
#line 275
            if (dist < - (delta * 3)) {
#line 276
              mo->z -= (1 << 16) * 4;
            } else {
#line 275
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 277
          if (delta > 0) {
#line 277
            if (dist < delta * 3) {
#line 278
              mo->z += (1 << 16) * 4;
            } else {
#line 277
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ ;
          }
        } else {
#line 267
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ ;
      }
    } else {
#line 263
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ ;
  }
#line 284
  if (mo->z <= mo->floorz) {
#line 291
    if (mo->flags & 16777216) {
#line 294
      mo->momz = - mo->momz;
    }
#line 297
    if (mo->momz < 0) {
#line 299
      if (mo->player) {
#line 299
        if (mo->momz < - (1 << 16) * 8) {
#line 306
          (mo->player)->deltaviewheight = mo->momz >> 3;
#line 307
          S_StartSound((void *)mo, 34);
        } else {
#line 299
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ ;
      }
#line 309
      mo->momz = 0;
    }
#line 311
    mo->z = mo->floorz;
#line 313
    if (mo->flags & 65536) {
#line 313
      if (! (mo->flags & 4096)) {
#line 316
        P_ExplodeMissile(mo);
#line 317
        return;
      } else {
#line 313
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ ;
    }
  } else
#line 320
  if (! (mo->flags & 512)) {
#line 322
    if (mo->momz == 0) {
#line 323
      mo->momz = - (1 << 16) * 2;
    } else {
#line 325
      mo->momz -= 1 << 16;
    }
  }
#line 328
  if (mo->z + mo->height > mo->ceilingz) {
#line 331
    if (mo->momz > 0) {
#line 332
      mo->momz = 0;
    }
#line 334
    mo->z = mo->ceilingz - mo->height;
#line 337
    if (mo->flags & 16777216) {
#line 339
      mo->momz = - mo->momz;
    }
#line 342
    if (mo->flags & 65536) {
#line 342
      if (! (mo->flags & 4096)) {
#line 345
        P_ExplodeMissile(mo);
#line 346
        return;
      } else {
#line 342
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ ;
    }
  }
#line 349
  return;
}
}
#line 356 "p_mobj.c"
void P_NightmareRespawn(mobj_t *mobj ) 
{ 
  fixed_t x___0 ;
  fixed_t y___1 ;
  fixed_t z ;
  subsector_t *ss ;
  mobj_t *mo ;
  mapthing_t *mthing ;
  boolean tmp ;

  {
#line 366
  x___0 = (int )mobj->spawnpoint.x << 16;
#line 367
  y___1 = (int )mobj->spawnpoint.y << 16;
#line 370
  tmp = P_CheckPosition(mobj, x___0, y___1);
#line 370
  if (! tmp) {
#line 371
    return;
  }
#line 375
  mo = P_SpawnMobj(mobj->x, mobj->y, ((mobj->subsector)->sector)->floorheight, (mobjtype_t )39);
#line 379
  S_StartSound((void *)mo, 35);
#line 382
  ss = R_PointInSubsector(x___0, y___1);
#line 384
  mo = P_SpawnMobj(x___0, y___1, (ss->sector)->floorheight, (mobjtype_t )39);
#line 386
  S_StartSound((void *)mo, 35);
#line 389
  mthing = & mobj->spawnpoint;
#line 392
  if ((mobj->info)->flags & 256) {
#line 393
    z = 0x7fffffff;
  } else {
#line 395
    z = (-0x7FFFFFFF-1);
  }
#line 398
  mo = P_SpawnMobj(x___0, y___1, z, mobj->type);
#line 399
  mo->spawnpoint = mobj->spawnpoint;
#line 400
  mo->angle = (angle_t )(0x20000000 * ((int )mthing->angle / 45));
#line 402
  if ((int )mthing->options & 8) {
#line 403
    mo->flags |= 32;
  }
#line 405
  mo->reactiontime = 18;
#line 408
  P_RemoveMobj(mobj);
#line 409
  return;
}
}
#line 415 "p_mobj.c"
void P_MobjThinker(mobj_t *mobj ) 
{ 
  boolean tmp ;
  int tmp___0 ;

  {
#line 418
  if (mobj->momx) {
#line 418
    goto _L___0;
  } else
#line 418
  if (mobj->momy) {
    _L___0: /* CIL Label */ 
#line 418
    goto _L;
  } else
#line 418
  if (mobj->flags & 16777216) {
    _L: /* CIL Label */ 
#line 422
    P_XYMovement(mobj);
#line 425
    if ((unsigned long )mobj->thinker.function.acv == (unsigned long )((void (*)())-1)) {
#line 426
      return;
    }
  }
#line 428
  if (mobj->z != mobj->floorz) {
#line 428
    goto _L___1;
  } else
#line 428
  if (mobj->momz) {
    _L___1: /* CIL Label */ 
#line 431
    P_ZMovement(mobj);
#line 434
    if ((unsigned long )mobj->thinker.function.acv == (unsigned long )((void (*)())-1)) {
#line 435
      return;
    }
  }
#line 441
  if (mobj->tics != -1) {
#line 443
    (mobj->tics) --;
#line 446
    if (! mobj->tics) {
#line 447
      tmp = P_SetMobjState(mobj, (mobj->state)->nextstate);
#line 447
      if (! tmp) {
#line 448
        return;
      }
    }
  } else {
#line 453
    if (! (mobj->flags & 4194304)) {
#line 454
      return;
    }
#line 456
    if (! respawnmonsters) {
#line 457
      return;
    }
#line 459
    (mobj->movecount) ++;
#line 461
    if (mobj->movecount < 420) {
#line 462
      return;
    }
#line 464
    if (leveltime & 31) {
#line 465
      return;
    }
#line 467
    tmp___0 = P_Random();
#line 467
    if (tmp___0 > 4) {
#line 468
      return;
    }
#line 470
    P_NightmareRespawn(mobj);
  }
#line 473
  return;
}
}
#line 479 "p_mobj.c"
mobj_t *P_SpawnMobj(fixed_t x___0 , fixed_t y___1 , fixed_t z , mobjtype_t type ) 
{ 
  mobj_t *mobj ;
  state_t *st ;
  mobjinfo_t *info___0 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 490
  tmp = Z_Malloc((int )sizeof(*mobj), 50, (void *)0);
#line 490
  mobj = (mobj_t *)tmp;
#line 491
  memset((void *)mobj, 0, (size_t )sizeof(*mobj));
#line 492
  info___0 = & mobjinfo[type];
#line 494
  mobj->type = type;
#line 495
  mobj->info = info___0;
#line 496
  mobj->x = x___0;
#line 497
  mobj->y = y___1;
#line 498
  mobj->radius = info___0->radius;
#line 499
  mobj->height = info___0->height;
#line 500
  mobj->flags = info___0->flags;
#line 501
  mobj->health = info___0->spawnhealth;
#line 503
  if ((unsigned int )gameskill != 4U) {
#line 504
    mobj->reactiontime = info___0->reactiontime;
  }
#line 506
  tmp___0 = P_Random();
#line 506
  mobj->lastlook = tmp___0 % 4;
#line 509
  st = & states[info___0->spawnstate];
#line 511
  mobj->state = st;
#line 512
  mobj->tics = (int )st->tics;
#line 513
  mobj->sprite = st->sprite;
#line 514
  mobj->frame = (int )st->frame;
#line 517
  P_SetThingPosition(mobj);
#line 519
  mobj->floorz = ((mobj->subsector)->sector)->floorheight;
#line 520
  mobj->ceilingz = ((mobj->subsector)->sector)->ceilingheight;
#line 522
  if (z == (-0x7FFFFFFF-1)) {
#line 523
    mobj->z = mobj->floorz;
  } else
#line 524
  if (z == 0x7fffffff) {
#line 525
    mobj->z = mobj->ceilingz - (mobj->info)->height;
  } else {
#line 527
    mobj->z = z;
  }
#line 529
  mobj->thinker.function.acp1 = (void (*)(void * ))(& P_MobjThinker);
#line 531
  P_AddThinker(& mobj->thinker);
#line 533
  return (mobj);
}
}
#line 546 "p_mobj.c"
void P_RemoveMobj(mobj_t *mobj ) 
{ 


  {
#line 548
  if (mobj->flags & 1) {
#line 548
    if (! (mobj->flags & 131072)) {
#line 548
      if ((unsigned int )mobj->type != 56U) {
#line 548
        if ((unsigned int )mobj->type != 58U) {
#line 553
          itemrespawnque[iquehead] = mobj->spawnpoint;
#line 554
          itemrespawntime[iquehead] = leveltime;
#line 555
          iquehead = (iquehead + 1) & 127;
#line 558
          if (iquehead == iquetail) {
#line 559
            iquetail = (iquetail + 1) & 127;
          }
        } else {
#line 548
          goto _L___1;
        }
      } else {
#line 548
        goto _L___1;
      }
    } else {
#line 548
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ ;
  }
#line 563
  P_UnsetThingPosition(mobj);
#line 566
  S_StopSound((void *)mobj);
#line 569
  P_RemoveThinker((thinker_t *)mobj);
#line 570
  return;
}
}
#line 578 "p_mobj.c"
void P_RespawnSpecials(void) 
{ 
  fixed_t x___0 ;
  fixed_t y___1 ;
  fixed_t z ;
  subsector_t *ss ;
  mobj_t *mo ;
  mapthing_t *mthing ;
  int i ;

  {
#line 591
  if ((unsigned int )deathmatch != 2U) {
#line 592
    return;
  }
#line 595
  if (iquehead == iquetail) {
#line 596
    return;
  }
#line 599
  if (leveltime - itemrespawntime[iquetail] < 1050) {
#line 600
    return;
  }
#line 602
  mthing = & itemrespawnque[iquetail];
#line 604
  x___0 = (int )mthing->x << 16;
#line 605
  y___1 = (int )mthing->y << 16;
#line 608
  ss = R_PointInSubsector(x___0, y___1);
#line 609
  mo = P_SpawnMobj(x___0, y___1, (ss->sector)->floorheight, (mobjtype_t )40);
#line 610
  S_StartSound((void *)mo, 90);
#line 613
  i = 0;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if (! (i < 137)) {
#line 613
      goto while_break;
    }
#line 615
    if ((int )mthing->type == mobjinfo[i].doomednum) {
#line 616
      goto while_break;
    }
#line 613
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  if (mobjinfo[i].flags & 256) {
#line 621
    z = 0x7fffffff;
  } else {
#line 623
    z = (-0x7FFFFFFF-1);
  }
#line 625
  mo = P_SpawnMobj(x___0, y___1, z, (mobjtype_t )i);
#line 626
  mo->spawnpoint = *mthing;
#line 627
  mo->angle = (angle_t )(0x20000000 * ((int )mthing->angle / 45));
#line 630
  iquetail = (iquetail + 1) & 127;
#line 631
  return;
}
}
#line 642 "p_mobj.c"
void P_SpawnPlayer(mapthing_t *mthing ) 
{ 
  player_t *p___0 ;
  fixed_t x___0 ;
  fixed_t y___1 ;
  fixed_t z ;
  mobj_t *mobj ;
  int i ;

  {
#line 654
  if (! playeringame[(int )mthing->type - 1]) {
#line 655
    return;
  }
#line 657
  p___0 = & players[(int )mthing->type - 1];
#line 659
  if ((unsigned int )p___0->playerstate == 2U) {
#line 660
    G_PlayerReborn((int )mthing->type - 1);
  }
#line 662
  x___0 = (int )mthing->x << 16;
#line 663
  y___1 = (int )mthing->y << 16;
#line 664
  z = (-0x7FFFFFFF-1);
#line 665
  mobj = P_SpawnMobj(x___0, y___1, z, (mobjtype_t )0);
#line 668
  if ((int )mthing->type > 1) {
#line 669
    mobj->flags |= ((int )mthing->type - 1) << 26;
  }
#line 671
  mobj->angle = (angle_t )(0x20000000 * ((int )mthing->angle / 45));
#line 672
  mobj->player = p___0;
#line 673
  mobj->health = p___0->health;
#line 675
  p___0->mo = mobj;
#line 676
  p___0->playerstate = (playerstate_t )0;
#line 677
  p___0->refire = 0;
#line 678
  p___0->message = (char *)((void *)0);
#line 679
  p___0->damagecount = 0;
#line 680
  p___0->bonuscount = 0;
#line 681
  p___0->extralight = 0;
#line 682
  p___0->fixedcolormap = 0;
#line 683
  p___0->viewheight = 41 * (1 << 16);
#line 686
  P_SetupPsprites(p___0);
#line 689
  if (deathmatch) {
#line 690
    i = 0;
    {
#line 690
    while (1) {
      while_continue: /* CIL Label */ ;
#line 690
      if (! (i < 6)) {
#line 690
        goto while_break;
      }
#line 691
      p___0->cards[i] = (boolean )1;
#line 690
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 693
  if ((int )mthing->type - 1 == consoleplayer) {
#line 696
    ST_Start();
#line 698
    HU_Start();
  }
#line 700
  return;
}
}
#line 708 "p_mobj.c"
void P_SpawnMapThing(mapthing_t *mthing ) 
{ 
  int i ;
  int bit ;
  mobj_t *mobj ;
  fixed_t x___0 ;
  fixed_t y___1 ;
  fixed_t z ;
  int tmp ;

  {
#line 718
  if ((int )mthing->type == 11) {
#line 720
    if ((unsigned long )deathmatch_p < (unsigned long )(& deathmatchstarts[10])) {
#line 722
      memcpy((void * __restrict  )deathmatch_p, (void const   * __restrict  )mthing,
             (size_t )sizeof(*mthing));
#line 723
      deathmatch_p ++;
    }
#line 725
    return;
  }
#line 729
  if ((int )mthing->type <= 4) {
#line 732
    playerstarts[(int )mthing->type - 1] = *mthing;
#line 733
    if (! deathmatch) {
#line 734
      P_SpawnPlayer(mthing);
    }
#line 736
    return;
  }
#line 740
  if (! netgame) {
#line 740
    if ((int )mthing->options & 16) {
#line 741
      return;
    } else {
#line 740
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 743
  if ((unsigned int )gameskill == 0U) {
#line 744
    bit = 1;
  } else
#line 745
  if ((unsigned int )gameskill == 4U) {
#line 746
    bit = 4;
  } else {
#line 748
    bit = 1 << ((unsigned int )gameskill - 1U);
  }
#line 750
  if (! ((int )mthing->options & bit)) {
#line 751
    return;
  }
#line 754
  i = 0;
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
#line 754
    if (! (i < 137)) {
#line 754
      goto while_break;
    }
#line 755
    if ((int )mthing->type == mobjinfo[i].doomednum) {
#line 756
      goto while_break;
    }
#line 754
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 758
  if (i == 137) {
#line 759
    I_Error("P_SpawnMapThing: Unknown type %i at (%i, %i)", (int )mthing->type, (int )mthing->x,
            (int )mthing->y);
  }
#line 764
  if (deathmatch) {
#line 764
    if (mobjinfo[i].flags & 33554432) {
#line 765
      return;
    } else {
#line 764
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 768
  if (nomonsters) {
#line 768
    if (i == 18) {
#line 768
      goto _L___2;
    } else
#line 768
    if (mobjinfo[i].flags & 4194304) {
      _L___2: /* CIL Label */ 
#line 772
      return;
    } else {
#line 768
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 776
  x___0 = (int )mthing->x << 16;
#line 777
  y___1 = (int )mthing->y << 16;
#line 779
  if (mobjinfo[i].flags & 256) {
#line 780
    z = 0x7fffffff;
  } else {
#line 782
    z = (-0x7FFFFFFF-1);
  }
#line 784
  mobj = P_SpawnMobj(x___0, y___1, z, (mobjtype_t )i);
#line 785
  mobj->spawnpoint = *mthing;
#line 787
  if (mobj->tics > 0) {
#line 788
    tmp = P_Random();
#line 788
    mobj->tics = 1 + tmp % mobj->tics;
  }
#line 789
  if (mobj->flags & 4194304) {
#line 790
    totalkills ++;
  }
#line 791
  if (mobj->flags & 8388608) {
#line 792
    totalitems ++;
  }
#line 794
  mobj->angle = (angle_t )(0x20000000 * ((int )mthing->angle / 45));
#line 795
  if ((int )mthing->options & 8) {
#line 796
    mobj->flags |= 32;
  }
#line 797
  return;
}
}
#line 811 "p_mobj.c"
void P_SpawnPuff(fixed_t x___0 , fixed_t y___1 , fixed_t z ) 
{ 
  mobj_t *th ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 819
  tmp = P_Random();
#line 819
  tmp___0 = P_Random();
#line 819
  z += (tmp - tmp___0) << 10;
#line 821
  th = P_SpawnMobj(x___0, y___1, z, (mobjtype_t )37);
#line 822
  th->momz = 1 << 16;
#line 823
  tmp___1 = P_Random();
#line 823
  th->tics -= tmp___1 & 3;
#line 825
  if (th->tics < 1) {
#line 826
    th->tics = 1;
  }
#line 829
  if (attackrange == 64 * (1 << 16)) {
#line 830
    P_SetMobjState(th, (statenum_t )95);
  }
#line 831
  return;
}
}
#line 838 "p_mobj.c"
void P_SpawnBlood(fixed_t x___0 , fixed_t y___1 , fixed_t z , int damage ) 
{ 
  mobj_t *th ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 847
  tmp = P_Random();
#line 847
  tmp___0 = P_Random();
#line 847
  z += (tmp - tmp___0) << 10;
#line 848
  th = P_SpawnMobj(x___0, y___1, z, (mobjtype_t )38);
#line 849
  th->momz = (1 << 16) * 2;
#line 850
  tmp___1 = P_Random();
#line 850
  th->tics -= tmp___1 & 3;
#line 852
  if (th->tics < 1) {
#line 853
    th->tics = 1;
  }
#line 855
  if (damage <= 12) {
#line 855
    if (damage >= 9) {
#line 856
      P_SetMobjState(th, (statenum_t )91);
    } else {
#line 855
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 857
  if (damage < 9) {
#line 858
    P_SetMobjState(th, (statenum_t )92);
  }
#line 859
  return;
}
}
#line 868 "p_mobj.c"
void P_CheckMissileSpawn(mobj_t *th ) 
{ 
  int tmp ;
  boolean tmp___0 ;

  {
#line 870
  tmp = P_Random();
#line 870
  th->tics -= tmp & 3;
#line 871
  if (th->tics < 1) {
#line 872
    th->tics = 1;
  }
#line 876
  th->x += th->momx >> 1;
#line 877
  th->y += th->momy >> 1;
#line 878
  th->z += th->momz >> 1;
#line 880
  tmp___0 = P_TryMove(th, th->x, th->y);
#line 880
  if (! tmp___0) {
#line 881
    P_ExplodeMissile(th);
  }
#line 882
  return;
}
}
#line 888 "p_mobj.c"
mobj_t *P_SpawnMissile(mobj_t *source , mobj_t *dest , mobjtype_t type ) 
{ 
  mobj_t *th ;
  angle_t an ;
  int dist ;
  int tmp ;
  int tmp___0 ;

  {
#line 898
  th = P_SpawnMobj(source->x, source->y, source->z + 32 * (1 << 16), type);
#line 902
  if ((th->info)->seesound) {
#line 903
    S_StartSound((void *)th, (th->info)->seesound);
  }
#line 905
  th->target = source;
#line 906
  an = R_PointToAngle2(source->x, source->y, dest->x, dest->y);
#line 909
  if (dest->flags & 262144) {
#line 910
    tmp = P_Random();
#line 910
    tmp___0 = P_Random();
#line 910
    an += (angle_t )((tmp - tmp___0) << 20);
  }
#line 912
  th->angle = an;
#line 913
  an >>= 19;
#line 914
  th->momx = FixedMul((th->info)->speed, *(finecosine + an));
#line 915
  th->momy = FixedMul((th->info)->speed, finesine[an]);
#line 917
  dist = P_AproxDistance(dest->x - source->x, dest->y - source->y);
#line 918
  dist /= (th->info)->speed;
#line 920
  if (dist < 1) {
#line 921
    dist = 1;
  }
#line 923
  th->momz = (dest->z - source->z) / dist;
#line 924
  P_CheckMissileSpawn(th);
#line 926
  return (th);
}
}
#line 934 "p_mobj.c"
void P_SpawnPlayerMissile(mobj_t *source , mobjtype_t type ) 
{ 
  mobj_t *th ;
  angle_t an ;
  fixed_t x___0 ;
  fixed_t y___1 ;
  fixed_t z ;
  fixed_t slope ;

  {
#line 948
  an = source->angle;
#line 949
  slope = P_AimLineAttack(source, an, 1024 * (1 << 16));
#line 951
  if (! linetarget) {
#line 953
    an += (angle_t )(1 << 26);
#line 954
    slope = P_AimLineAttack(source, an, 1024 * (1 << 16));
#line 956
    if (! linetarget) {
#line 958
      an -= (angle_t )(2 << 26);
#line 959
      slope = P_AimLineAttack(source, an, 1024 * (1 << 16));
    }
#line 962
    if (! linetarget) {
#line 964
      an = source->angle;
#line 965
      slope = 0;
    }
  }
#line 969
  x___0 = source->x;
#line 970
  y___1 = source->y;
#line 971
  z = source->z + 32 * (1 << 16);
#line 973
  th = P_SpawnMobj(x___0, y___1, z, type);
#line 975
  if ((th->info)->seesound) {
#line 976
    S_StartSound((void *)th, (th->info)->seesound);
  }
#line 978
  th->target = source;
#line 979
  th->angle = an;
#line 980
  th->momx = FixedMul((th->info)->speed, *(finecosine + (an >> 19)));
#line 982
  th->momy = FixedMul((th->info)->speed, finesine[an >> 19]);
#line 984
  th->momz = FixedMul((th->info)->speed, slope);
#line 986
  P_CheckMissileSpawn(th);
#line 987
  return;
}
}
#line 24 "p_telept.c"
static char const   rcsid___37[51]  = 
#line 24 "p_telept.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'t', 
        (char const   )'e',      (char const   )'l',      (char const   )'e',      (char const   )'p', 
        (char const   )'t',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'3',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'1',      (char const   )'/',      (char const   )'2',      (char const   )'8', 
        (char const   )' ',      (char const   )'2',      (char const   )'2',      (char const   )':', 
        (char const   )'0',      (char const   )'8',      (char const   )':',      (char const   )'2', 
        (char const   )'9',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 47 "p_telept.c"
int EV_Teleport(line_t *line , int side , mobj_t *thing ) 
{ 
  int i ;
  int tag ;
  mobj_t *m ;
  mobj_t *fog ;
  unsigned int an ;
  thinker_t *thinker ;
  sector_t *sector ;
  fixed_t oldx ;
  fixed_t oldy ;
  fixed_t oldz ;
  boolean tmp ;
  fixed_t tmp___0 ;
  fixed_t tmp___1 ;

  {
#line 65
  if (thing->flags & 65536) {
#line 66
    return (0);
  }
#line 70
  if (side == 1) {
#line 71
    return (0);
  }
#line 74
  tag = (int )line->tag;
#line 75
  i = 0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i < numsectors)) {
#line 75
      goto while_break;
    }
#line 77
    if ((int )(sectors + i)->tag == tag) {
#line 79
      thinker = thinkercap.next;
#line 80
      thinker = thinkercap.next;
      {
#line 80
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 80
        if (! ((unsigned long )thinker != (unsigned long )(& thinkercap))) {
#line 80
          goto while_break___0;
        }
#line 85
        if ((unsigned long )thinker->function.acp1 != (unsigned long )((void (*)(void * ))(& P_MobjThinker))) {
#line 86
          goto __Cont;
        }
#line 88
        m = (mobj_t *)thinker;
#line 91
        if ((unsigned int )m->type != 41U) {
#line 92
          goto __Cont;
        }
#line 94
        sector = (m->subsector)->sector;
#line 96
        if (sector - sectors != (long )i) {
#line 97
          goto __Cont;
        }
#line 99
        oldx = thing->x;
#line 100
        oldy = thing->y;
#line 101
        oldz = thing->z;
#line 103
        tmp = P_TeleportMove(thing, m->x, m->y);
#line 103
        if (! tmp) {
#line 104
          return (0);
        }
#line 106
        thing->z = thing->floorz;
#line 107
        if (thing->player) {
#line 108
          (thing->player)->viewz = thing->z + (thing->player)->viewheight;
        }
#line 111
        fog = P_SpawnMobj(oldx, oldy, oldz, (mobjtype_t )39);
#line 112
        S_StartSound((void *)fog, 35);
#line 113
        an = m->angle >> 19;
#line 114
        fog = P_SpawnMobj(m->x + 20 * *(finecosine + an), m->y + 20 * finesine[an],
                          thing->z, (mobjtype_t )39);
#line 118
        S_StartSound((void *)fog, 35);
#line 121
        if (thing->player) {
#line 122
          thing->reactiontime = 18;
        }
#line 124
        thing->angle = m->angle;
#line 125
        tmp___1 = 0;
#line 125
        thing->momz = tmp___1;
#line 125
        tmp___0 = tmp___1;
#line 125
        thing->momy = tmp___0;
#line 125
        thing->momx = tmp___0;
#line 126
        return (1);
        __Cont: /* CIL Label */ 
#line 80
        thinker = thinker->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return (0);
}
}
#line 25 "p_tick.c"
static char const   rcsid___38[49]  = 
#line 25 "p_tick.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'t', 
        (char const   )'i',      (char const   )'c',      (char const   )'k',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'4',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'1', 
        (char const   )'6',      (char const   )':',      (char const   )'4',      (char const   )'7', 
        (char const   )':',      (char const   )'5',      (char const   )'5',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 70 "p_local.h"
thinker_t thinkercap  ;
#line 172 "doomstat.h"
int leveltime  ;
#line 53 "p_tick.c"
void P_InitThinkers(void) 
{ 


  {
#line 55
  thinkercap.next = & thinkercap;
#line 55
  thinkercap.prev = thinkercap.next;
#line 56
  return;
}
}
#line 65 "p_tick.c"
void P_AddThinker(thinker_t *thinker ) 
{ 


  {
#line 67
  (thinkercap.prev)->next = thinker;
#line 68
  thinker->next = & thinkercap;
#line 69
  thinker->prev = thinkercap.prev;
#line 70
  thinkercap.prev = thinker;
#line 71
  return;
}
}
#line 80 "p_tick.c"
void P_RemoveThinker(thinker_t *thinker ) 
{ 


  {
#line 83
  thinker->function.acv = (void (*)())-1;
#line 84
  return;
}
}
#line 92 "p_tick.c"
void P_AllocateThinker(thinker_t *thinker ) 
{ 


  {
#line 94
  return;
}
}
#line 101 "p_tick.c"
void P_RunThinkers(void) 
{ 
  thinker_t *currentthinker ;

  {
#line 105
  currentthinker = thinkercap.next;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! ((unsigned long )currentthinker != (unsigned long )(& thinkercap))) {
#line 106
      goto while_break;
    }
#line 108
    if ((unsigned long )currentthinker->function.acv == (unsigned long )((void (*)())-1)) {
#line 111
      (currentthinker->next)->prev = currentthinker->prev;
#line 112
      (currentthinker->prev)->next = currentthinker->next;
#line 113
      Z_Free((void *)currentthinker);
    } else
#line 117
    if (currentthinker->function.acp1) {
#line 118
      (*(currentthinker->function.acp1))((void *)currentthinker);
    }
#line 120
    currentthinker = currentthinker->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 130 "p_tick.c"
void P_Ticker(void) 
{ 
  int i ;

  {
#line 135
  if (paused) {
#line 136
    return;
  }
#line 139
  if (! netgame) {
#line 139
    if (menuactive) {
#line 139
      if (! demoplayback) {
#line 139
        if (players[consoleplayer].viewz != 1) {
#line 144
          return;
        } else {
#line 139
          goto _L___1;
        }
      } else {
#line 139
        goto _L___1;
      }
    } else {
#line 139
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ ;
  }
#line 148
  i = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i < 4)) {
#line 148
      goto while_break;
    }
#line 149
    if (playeringame[i]) {
#line 150
      P_PlayerThink(& players[i]);
    }
#line 148
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  P_RunThinkers();
#line 153
  P_UpdateSpecials();
#line 154
  P_RespawnSpecials();
#line 157
  leveltime ++;
#line 158
  return;
}
}
#line 24 "p_saveg.c"
static char const   rcsid___39[49]  = 
#line 24 "p_saveg.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'t', 
        (char const   )'i',      (char const   )'c',      (char const   )'k',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'4',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'1', 
        (char const   )'6',      (char const   )':',      (char const   )'4',      (char const   )'7', 
        (char const   )':',      (char const   )'5',      (char const   )'5',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "p_saveg.c"
byte *save_p  ;
#line 47 "p_saveg.c"
void P_ArchivePlayers(void) 
{ 
  int i ;
  int j ;
  player_t *dest ;

  {
#line 53
  i = 0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (i < 4)) {
#line 53
      goto while_break;
    }
#line 55
    if (! playeringame[i]) {
#line 56
      goto __Cont;
    }
#line 58
    save_p += (4 - ((int )save_p & 3)) & 3;
#line 60
    dest = (player_t *)save_p;
#line 61
    memcpy((void * __restrict  )dest, (void const   * __restrict  )(& players[i]),
           (size_t )sizeof(player_t ));
#line 62
    save_p += sizeof(player_t );
#line 63
    j = 0;
    {
#line 63
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 63
      if (! (j < 2)) {
#line 63
        goto while_break___0;
      }
#line 65
      if (dest->psprites[j].state) {
#line 67
        dest->psprites[j].state = (state_t *)(dest->psprites[j].state - states);
      }
#line 63
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 53
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 79 "p_saveg.c"
void P_UnArchivePlayers(void) 
{ 
  int i ;
  int j ;

  {
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < 4)) {
#line 84
      goto while_break;
    }
#line 86
    if (! playeringame[i]) {
#line 87
      goto __Cont;
    }
#line 89
    save_p += (4 - ((int )save_p & 3)) & 3;
#line 91
    memcpy((void * __restrict  )(& players[i]), (void const   * __restrict  )save_p,
           (size_t )sizeof(player_t ));
#line 92
    save_p += sizeof(player_t );
#line 95
    players[i].mo = (mobj_t *)((void *)0);
#line 96
    players[i].message = (char *)((void *)0);
#line 97
    players[i].attacker = (mobj_t *)((void *)0);
#line 99
    j = 0;
    {
#line 99
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 99
      if (! (j < 2)) {
#line 99
        goto while_break___0;
      }
#line 101
      if (players[i].psprites[j].state) {
#line 103
        players[i].psprites[j].state = & states[(int )players[i].psprites[j].state];
      }
#line 99
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 84
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 114 "p_saveg.c"
void P_ArchiveWorld(void) 
{ 
  int i ;
  int j ;
  sector_t *sec ;
  line_t *li ;
  side_t *si ;
  short *put ;
  short *tmp ;
  short *tmp___0 ;
  short *tmp___1 ;
  short *tmp___2 ;
  short *tmp___3 ;
  short *tmp___4 ;
  short *tmp___5 ;
  short *tmp___6 ;
  short *tmp___7 ;
  short *tmp___8 ;
  short *tmp___9 ;
  short *tmp___10 ;
  short *tmp___11 ;
  short *tmp___12 ;
  short *tmp___13 ;

  {
#line 123
  put = (short *)save_p;
#line 126
  i = 0;
#line 126
  sec = sectors;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (i < numsectors)) {
#line 126
      goto while_break;
    }
#line 128
    tmp = put;
#line 128
    put ++;
#line 128
    *tmp = (short )(sec->floorheight >> 16);
#line 129
    tmp___0 = put;
#line 129
    put ++;
#line 129
    *tmp___0 = (short )(sec->ceilingheight >> 16);
#line 130
    tmp___1 = put;
#line 130
    put ++;
#line 130
    *tmp___1 = sec->floorpic;
#line 131
    tmp___2 = put;
#line 131
    put ++;
#line 131
    *tmp___2 = sec->ceilingpic;
#line 132
    tmp___3 = put;
#line 132
    put ++;
#line 132
    *tmp___3 = sec->lightlevel;
#line 133
    tmp___4 = put;
#line 133
    put ++;
#line 133
    *tmp___4 = sec->special;
#line 134
    tmp___5 = put;
#line 134
    put ++;
#line 134
    *tmp___5 = sec->tag;
#line 126
    i ++;
#line 126
    sec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  i = 0;
#line 139
  li = lines;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    if (! (i < numlines)) {
#line 139
      goto while_break___0;
    }
#line 141
    tmp___6 = put;
#line 141
    put ++;
#line 141
    *tmp___6 = li->flags;
#line 142
    tmp___7 = put;
#line 142
    put ++;
#line 142
    *tmp___7 = li->special;
#line 143
    tmp___8 = put;
#line 143
    put ++;
#line 143
    *tmp___8 = li->tag;
#line 144
    j = 0;
    {
#line 144
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 144
      if (! (j < 2)) {
#line 144
        goto while_break___1;
      }
#line 146
      if ((int )li->sidenum[j] == -1) {
#line 147
        goto __Cont;
      }
#line 149
      si = sides + li->sidenum[j];
#line 151
      tmp___9 = put;
#line 151
      put ++;
#line 151
      *tmp___9 = (short )(si->textureoffset >> 16);
#line 152
      tmp___10 = put;
#line 152
      put ++;
#line 152
      *tmp___10 = (short )(si->rowoffset >> 16);
#line 153
      tmp___11 = put;
#line 153
      put ++;
#line 153
      *tmp___11 = si->toptexture;
#line 154
      tmp___12 = put;
#line 154
      put ++;
#line 154
      *tmp___12 = si->bottomtexture;
#line 155
      tmp___13 = put;
#line 155
      put ++;
#line 155
      *tmp___13 = si->midtexture;
      __Cont: /* CIL Label */ 
#line 144
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 139
    i ++;
#line 139
    li ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 159
  save_p = (byte *)put;
#line 160
  return;
}
}
#line 167 "p_saveg.c"
void P_UnArchiveWorld(void) 
{ 
  int i ;
  int j ;
  sector_t *sec ;
  line_t *li ;
  side_t *si ;
  short *get ;
  short *tmp ;
  short *tmp___0 ;
  short *tmp___1 ;
  short *tmp___2 ;
  short *tmp___3 ;
  short *tmp___4 ;
  short *tmp___5 ;
  short *tmp___6 ;
  short *tmp___7 ;
  short *tmp___8 ;
  short *tmp___9 ;
  short *tmp___10 ;
  short *tmp___11 ;
  short *tmp___12 ;
  short *tmp___13 ;

  {
#line 176
  get = (short *)save_p;
#line 179
  i = 0;
#line 179
  sec = sectors;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < numsectors)) {
#line 179
      goto while_break;
    }
#line 181
    tmp = get;
#line 181
    get ++;
#line 181
    sec->floorheight = (int )*tmp << 16;
#line 182
    tmp___0 = get;
#line 182
    get ++;
#line 182
    sec->ceilingheight = (int )*tmp___0 << 16;
#line 183
    tmp___1 = get;
#line 183
    get ++;
#line 183
    sec->floorpic = *tmp___1;
#line 184
    tmp___2 = get;
#line 184
    get ++;
#line 184
    sec->ceilingpic = *tmp___2;
#line 185
    tmp___3 = get;
#line 185
    get ++;
#line 185
    sec->lightlevel = *tmp___3;
#line 186
    tmp___4 = get;
#line 186
    get ++;
#line 186
    sec->special = *tmp___4;
#line 187
    tmp___5 = get;
#line 187
    get ++;
#line 187
    sec->tag = *tmp___5;
#line 188
    sec->specialdata = (void *)0;
#line 189
    sec->soundtarget = (mobj_t *)0;
#line 179
    i ++;
#line 179
    sec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  i = 0;
#line 193
  li = lines;
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 193
    if (! (i < numlines)) {
#line 193
      goto while_break___0;
    }
#line 195
    tmp___6 = get;
#line 195
    get ++;
#line 195
    li->flags = *tmp___6;
#line 196
    tmp___7 = get;
#line 196
    get ++;
#line 196
    li->special = *tmp___7;
#line 197
    tmp___8 = get;
#line 197
    get ++;
#line 197
    li->tag = *tmp___8;
#line 198
    j = 0;
    {
#line 198
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 198
      if (! (j < 2)) {
#line 198
        goto while_break___1;
      }
#line 200
      if ((int )li->sidenum[j] == -1) {
#line 201
        goto __Cont;
      }
#line 202
      si = sides + li->sidenum[j];
#line 203
      tmp___9 = get;
#line 203
      get ++;
#line 203
      si->textureoffset = (int )*tmp___9 << 16;
#line 204
      tmp___10 = get;
#line 204
      get ++;
#line 204
      si->rowoffset = (int )*tmp___10 << 16;
#line 205
      tmp___11 = get;
#line 205
      get ++;
#line 205
      si->toptexture = *tmp___11;
#line 206
      tmp___12 = get;
#line 206
      get ++;
#line 206
      si->bottomtexture = *tmp___12;
#line 207
      tmp___13 = get;
#line 207
      get ++;
#line 207
      si->midtexture = *tmp___13;
      __Cont: /* CIL Label */ 
#line 198
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 193
    i ++;
#line 193
    li ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 210
  save_p = (byte *)get;
#line 211
  return;
}
}
#line 232 "p_saveg.c"
void P_ArchiveThinkers(void) 
{ 
  thinker_t *th ;
  mobj_t *mobj ;
  byte *tmp ;
  byte *tmp___0 ;

  {
#line 238
  th = thinkercap.next;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! ((unsigned long )th != (unsigned long )(& thinkercap))) {
#line 238
      goto while_break;
    }
#line 240
    if ((unsigned long )th->function.acp1 == (unsigned long )((void (*)(void * ))(& P_MobjThinker))) {
#line 242
      tmp = save_p;
#line 242
      save_p ++;
#line 242
      *tmp = (byte )1;
#line 243
      save_p += (4 - ((int )save_p & 3)) & 3;
#line 244
      mobj = (mobj_t *)save_p;
#line 245
      memcpy((void * __restrict  )mobj, (void const   * __restrict  )th, (size_t )sizeof(*mobj));
#line 246
      save_p += sizeof(*mobj);
#line 247
      mobj->state = (state_t *)(mobj->state - states);
#line 249
      if (mobj->player) {
#line 250
        mobj->player = (player_t *)((mobj->player - players) + 1L);
      }
#line 251
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 238
    th = th->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  tmp___0 = save_p;
#line 258
  save_p ++;
#line 258
  *tmp___0 = (byte )0;
#line 259
  return;
}
}
#line 266 "p_saveg.c"
void P_UnArchiveThinkers(void) 
{ 
  byte tclass ;
  thinker_t *currentthinker ;
  thinker_t *next ;
  mobj_t *mobj ;
  byte *tmp ;
  void *tmp___0 ;

  {
#line 274
  currentthinker = thinkercap.next;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! ((unsigned long )currentthinker != (unsigned long )(& thinkercap))) {
#line 275
      goto while_break;
    }
#line 277
    next = currentthinker->next;
#line 279
    if ((unsigned long )currentthinker->function.acp1 == (unsigned long )((void (*)(void * ))(& P_MobjThinker))) {
#line 280
      P_RemoveMobj((mobj_t *)currentthinker);
    } else {
#line 282
      Z_Free((void *)currentthinker);
    }
#line 284
    currentthinker = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  P_InitThinkers();
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if (! 1) {
#line 289
      goto while_break___0;
    }
#line 291
    tmp = save_p;
#line 291
    save_p ++;
#line 291
    tclass = *tmp;
    {
#line 294
    if ((int )tclass == 0) {
#line 294
      goto case_0;
    }
#line 297
    if ((int )tclass == 1) {
#line 297
      goto case_1;
    }
#line 317
    goto switch_default;
    case_0: /* CIL Label */ 
#line 295
    return;
    case_1: /* CIL Label */ 
#line 298
    save_p += (4 - ((int )save_p & 3)) & 3;
#line 299
    tmp___0 = Z_Malloc((int )sizeof(*mobj), 50, (void *)0);
#line 299
    mobj = (mobj_t *)tmp___0;
#line 300
    memcpy((void * __restrict  )mobj, (void const   * __restrict  )save_p, (size_t )sizeof(*mobj));
#line 301
    save_p += sizeof(*mobj);
#line 302
    mobj->state = & states[(int )mobj->state];
#line 303
    mobj->target = (struct mobj_s *)((void *)0);
#line 304
    if (mobj->player) {
#line 306
      mobj->player = & players[(int )mobj->player - 1];
#line 307
      (mobj->player)->mo = mobj;
    }
#line 309
    P_SetThingPosition(mobj);
#line 310
    mobj->info = & mobjinfo[mobj->type];
#line 311
    mobj->floorz = ((mobj->subsector)->sector)->floorheight;
#line 312
    mobj->ceilingz = ((mobj->subsector)->sector)->ceilingheight;
#line 313
    mobj->thinker.function.acp1 = (void (*)(void * ))(& P_MobjThinker);
#line 314
    P_AddThinker(& mobj->thinker);
#line 315
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 318
    I_Error("Unknown tclass %i in savegame", (int )tclass);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  return;
}
}
#line 329 "p_saveg.c"
enum __anonenum_specials_e_86675702 specials_e  ;
#line 355 "p_saveg.c"
void P_ArchiveSpecials(void) 
{ 
  thinker_t *th ;
  ceiling_t *ceiling ;
  vldoor_t *door ;
  floormove_t *floor___0 ;
  plat_t *plat ;
  lightflash_t *flash ;
  strobe_t *strobe ;
  glow_t *glow ;
  int i ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;

  {
#line 368
  th = thinkercap.next;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! ((unsigned long )th != (unsigned long )(& thinkercap))) {
#line 368
      goto while_break;
    }
#line 370
    if ((unsigned long )th->function.acv == (unsigned long )((void (*)())((void *)0))) {
#line 372
      i = 0;
      {
#line 372
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 372
        if (! (i < 30)) {
#line 372
          goto while_break___0;
        }
#line 373
        if ((unsigned long )activeceilings[i] == (unsigned long )((ceiling_t *)th)) {
#line 374
          goto while_break___0;
        }
#line 372
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 376
      if (i < 30) {
#line 378
        tmp = save_p;
#line 378
        save_p ++;
#line 378
        *tmp = (byte )0;
#line 379
        save_p += (4 - ((int )save_p & 3)) & 3;
#line 380
        ceiling = (ceiling_t *)save_p;
#line 381
        memcpy((void * __restrict  )ceiling, (void const   * __restrict  )th, (size_t )sizeof(*ceiling));
#line 382
        save_p += sizeof(*ceiling);
#line 383
        ceiling->sector = (sector_t *)(ceiling->sector - sectors);
      }
#line 385
      goto __Cont;
    }
#line 388
    if ((unsigned long )th->function.acp1 == (unsigned long )((void (*)(void * ))(& T_MoveCeiling))) {
#line 390
      tmp___0 = save_p;
#line 390
      save_p ++;
#line 390
      *tmp___0 = (byte )0;
#line 391
      save_p += (4 - ((int )save_p & 3)) & 3;
#line 392
      ceiling = (ceiling_t *)save_p;
#line 393
      memcpy((void * __restrict  )ceiling, (void const   * __restrict  )th, (size_t )sizeof(*ceiling));
#line 394
      save_p += sizeof(*ceiling);
#line 395
      ceiling->sector = (sector_t *)(ceiling->sector - sectors);
#line 396
      goto __Cont;
    }
#line 399
    if ((unsigned long )th->function.acp1 == (unsigned long )((void (*)(void * ))(& T_VerticalDoor))) {
#line 401
      tmp___1 = save_p;
#line 401
      save_p ++;
#line 401
      *tmp___1 = (byte )1;
#line 402
      save_p += (4 - ((int )save_p & 3)) & 3;
#line 403
      door = (vldoor_t *)save_p;
#line 404
      memcpy((void * __restrict  )door, (void const   * __restrict  )th, (size_t )sizeof(*door));
#line 405
      save_p += sizeof(*door);
#line 406
      door->sector = (sector_t *)(door->sector - sectors);
#line 407
      goto __Cont;
    }
#line 410
    if ((unsigned long )th->function.acp1 == (unsigned long )((void (*)(void * ))(& T_MoveFloor))) {
#line 412
      tmp___2 = save_p;
#line 412
      save_p ++;
#line 412
      *tmp___2 = (byte )2;
#line 413
      save_p += (4 - ((int )save_p & 3)) & 3;
#line 414
      floor___0 = (floormove_t *)save_p;
#line 415
      memcpy((void * __restrict  )floor___0, (void const   * __restrict  )th, (size_t )sizeof(*floor___0));
#line 416
      save_p += sizeof(*floor___0);
#line 417
      floor___0->sector = (sector_t *)(floor___0->sector - sectors);
#line 418
      goto __Cont;
    }
#line 421
    if ((unsigned long )th->function.acp1 == (unsigned long )((void (*)(void * ))(& T_PlatRaise))) {
#line 423
      tmp___3 = save_p;
#line 423
      save_p ++;
#line 423
      *tmp___3 = (byte )3;
#line 424
      save_p += (4 - ((int )save_p & 3)) & 3;
#line 425
      plat = (plat_t *)save_p;
#line 426
      memcpy((void * __restrict  )plat, (void const   * __restrict  )th, (size_t )sizeof(*plat));
#line 427
      save_p += sizeof(*plat);
#line 428
      plat->sector = (sector_t *)(plat->sector - sectors);
#line 429
      goto __Cont;
    }
#line 432
    if ((unsigned long )th->function.acp1 == (unsigned long )((void (*)(void * ))(& T_LightFlash))) {
#line 434
      tmp___4 = save_p;
#line 434
      save_p ++;
#line 434
      *tmp___4 = (byte )4;
#line 435
      save_p += (4 - ((int )save_p & 3)) & 3;
#line 436
      flash = (lightflash_t *)save_p;
#line 437
      memcpy((void * __restrict  )flash, (void const   * __restrict  )th, (size_t )sizeof(*flash));
#line 438
      save_p += sizeof(*flash);
#line 439
      flash->sector = (sector_t *)(flash->sector - sectors);
#line 440
      goto __Cont;
    }
#line 443
    if ((unsigned long )th->function.acp1 == (unsigned long )((void (*)(void * ))(& T_StrobeFlash))) {
#line 445
      tmp___5 = save_p;
#line 445
      save_p ++;
#line 445
      *tmp___5 = (byte )5;
#line 446
      save_p += (4 - ((int )save_p & 3)) & 3;
#line 447
      strobe = (strobe_t *)save_p;
#line 448
      memcpy((void * __restrict  )strobe, (void const   * __restrict  )th, (size_t )sizeof(*strobe));
#line 449
      save_p += sizeof(*strobe);
#line 450
      strobe->sector = (sector_t *)(strobe->sector - sectors);
#line 451
      goto __Cont;
    }
#line 454
    if ((unsigned long )th->function.acp1 == (unsigned long )((void (*)(void * ))(& T_Glow))) {
#line 456
      tmp___6 = save_p;
#line 456
      save_p ++;
#line 456
      *tmp___6 = (byte )6;
#line 457
      save_p += (4 - ((int )save_p & 3)) & 3;
#line 458
      glow = (glow_t *)save_p;
#line 459
      memcpy((void * __restrict  )glow, (void const   * __restrict  )th, (size_t )sizeof(*glow));
#line 460
      save_p += sizeof(*glow);
#line 461
      glow->sector = (sector_t *)(glow->sector - sectors);
#line 462
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 368
    th = th->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 467
  tmp___7 = save_p;
#line 467
  save_p ++;
#line 467
  *tmp___7 = (byte )7;
#line 469
  return;
}
}
#line 475 "p_saveg.c"
void P_UnArchiveSpecials(void) 
{ 
  byte tclass ;
  ceiling_t *ceiling ;
  vldoor_t *door ;
  floormove_t *floor___0 ;
  plat_t *plat ;
  lightflash_t *flash ;
  strobe_t *strobe ;
  glow_t *glow ;
  byte *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 488
    if (! 1) {
#line 488
      goto while_break;
    }
#line 490
    tmp = save_p;
#line 490
    save_p ++;
#line 490
    tclass = *tmp;
    {
#line 493
    if ((int )tclass == 7) {
#line 493
      goto case_7;
    }
#line 496
    if ((int )tclass == 0) {
#line 496
      goto case_0;
    }
#line 511
    if ((int )tclass == 1) {
#line 511
      goto case_1;
    }
#line 522
    if ((int )tclass == 2) {
#line 522
      goto case_2;
    }
#line 533
    if ((int )tclass == 3) {
#line 533
      goto case_3;
    }
#line 548
    if ((int )tclass == 4) {
#line 548
      goto case_4;
    }
#line 558
    if ((int )tclass == 5) {
#line 558
      goto case_5;
    }
#line 568
    if ((int )tclass == 6) {
#line 568
      goto case_6;
    }
#line 578
    goto switch_default;
    case_7: /* CIL Label */ 
#line 494
    return;
    case_0: /* CIL Label */ 
#line 497
    save_p += (4 - ((int )save_p & 3)) & 3;
#line 498
    tmp___0 = Z_Malloc((int )sizeof(*ceiling), 50, (void *)0);
#line 498
    ceiling = (ceiling_t *)tmp___0;
#line 499
    memcpy((void * __restrict  )ceiling, (void const   * __restrict  )save_p, (size_t )sizeof(*ceiling));
#line 500
    save_p += sizeof(*ceiling);
#line 501
    ceiling->sector = sectors + (int )ceiling->sector;
#line 502
    (ceiling->sector)->specialdata = (void *)ceiling;
#line 504
    if (ceiling->thinker.function.acp1) {
#line 505
      ceiling->thinker.function.acp1 = (void (*)(void * ))(& T_MoveCeiling);
    }
#line 507
    P_AddThinker(& ceiling->thinker);
#line 508
    P_AddActiveCeiling(ceiling);
#line 509
    goto switch_break;
    case_1: /* CIL Label */ 
#line 512
    save_p += (4 - ((int )save_p & 3)) & 3;
#line 513
    tmp___1 = Z_Malloc((int )sizeof(*door), 50, (void *)0);
#line 513
    door = (vldoor_t *)tmp___1;
#line 514
    memcpy((void * __restrict  )door, (void const   * __restrict  )save_p, (size_t )sizeof(*door));
#line 515
    save_p += sizeof(*door);
#line 516
    door->sector = sectors + (int )door->sector;
#line 517
    (door->sector)->specialdata = (void *)door;
#line 518
    door->thinker.function.acp1 = (void (*)(void * ))(& T_VerticalDoor);
#line 519
    P_AddThinker(& door->thinker);
#line 520
    goto switch_break;
    case_2: /* CIL Label */ 
#line 523
    save_p += (4 - ((int )save_p & 3)) & 3;
#line 524
    tmp___2 = Z_Malloc((int )sizeof(*floor___0), 50, (void *)0);
#line 524
    floor___0 = (floormove_t *)tmp___2;
#line 525
    memcpy((void * __restrict  )floor___0, (void const   * __restrict  )save_p, (size_t )sizeof(*floor___0));
#line 526
    save_p += sizeof(*floor___0);
#line 527
    floor___0->sector = sectors + (int )floor___0->sector;
#line 528
    (floor___0->sector)->specialdata = (void *)floor___0;
#line 529
    floor___0->thinker.function.acp1 = (void (*)(void * ))(& T_MoveFloor);
#line 530
    P_AddThinker(& floor___0->thinker);
#line 531
    goto switch_break;
    case_3: /* CIL Label */ 
#line 534
    save_p += (4 - ((int )save_p & 3)) & 3;
#line 535
    tmp___3 = Z_Malloc((int )sizeof(*plat), 50, (void *)0);
#line 535
    plat = (plat_t *)tmp___3;
#line 536
    memcpy((void * __restrict  )plat, (void const   * __restrict  )save_p, (size_t )sizeof(*plat));
#line 537
    save_p += sizeof(*plat);
#line 538
    plat->sector = sectors + (int )plat->sector;
#line 539
    (plat->sector)->specialdata = (void *)plat;
#line 541
    if (plat->thinker.function.acp1) {
#line 542
      plat->thinker.function.acp1 = (void (*)(void * ))(& T_PlatRaise);
    }
#line 544
    P_AddThinker(& plat->thinker);
#line 545
    P_AddActivePlat(plat);
#line 546
    goto switch_break;
    case_4: /* CIL Label */ 
#line 549
    save_p += (4 - ((int )save_p & 3)) & 3;
#line 550
    tmp___4 = Z_Malloc((int )sizeof(*flash), 50, (void *)0);
#line 550
    flash = (lightflash_t *)tmp___4;
#line 551
    memcpy((void * __restrict  )flash, (void const   * __restrict  )save_p, (size_t )sizeof(*flash));
#line 552
    save_p += sizeof(*flash);
#line 553
    flash->sector = sectors + (int )flash->sector;
#line 554
    flash->thinker.function.acp1 = (void (*)(void * ))(& T_LightFlash);
#line 555
    P_AddThinker(& flash->thinker);
#line 556
    goto switch_break;
    case_5: /* CIL Label */ 
#line 559
    save_p += (4 - ((int )save_p & 3)) & 3;
#line 560
    tmp___5 = Z_Malloc((int )sizeof(*strobe), 50, (void *)0);
#line 560
    strobe = (strobe_t *)tmp___5;
#line 561
    memcpy((void * __restrict  )strobe, (void const   * __restrict  )save_p, (size_t )sizeof(*strobe));
#line 562
    save_p += sizeof(*strobe);
#line 563
    strobe->sector = sectors + (int )strobe->sector;
#line 564
    strobe->thinker.function.acp1 = (void (*)(void * ))(& T_StrobeFlash);
#line 565
    P_AddThinker(& strobe->thinker);
#line 566
    goto switch_break;
    case_6: /* CIL Label */ 
#line 569
    save_p += (4 - ((int )save_p & 3)) & 3;
#line 570
    tmp___6 = Z_Malloc((int )sizeof(*glow), 50, (void *)0);
#line 570
    glow = (glow_t *)tmp___6;
#line 571
    memcpy((void * __restrict  )glow, (void const   * __restrict  )save_p, (size_t )sizeof(*glow));
#line 572
    save_p += sizeof(*glow);
#line 573
    glow->sector = sectors + (int )glow->sector;
#line 574
    glow->thinker.function.acp1 = (void (*)(void * ))(& T_Glow);
#line 575
    P_AddThinker(& glow->thinker);
#line 576
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 579
    I_Error("P_UnarchiveSpecials:Unknown tclass %i in savegame", (int )tclass);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 585
  return;
}
}
#line 27 "p_user.c"
static char const   rcsid___40[49]  = 
#line 27 "p_user.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'_',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )'r',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'3',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'1',      (char const   )'/', 
        (char const   )'2',      (char const   )'8',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'0',      (char const   )'8', 
        (char const   )':',      (char const   )'2',      (char const   )'9',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 51 "p_user.c"
boolean onground  ;
#line 58 "p_user.c"
void P_Thrust(player_t *player , angle_t angle , fixed_t move ) 
{ 
  fixed_t tmp ;
  fixed_t tmp___0 ;

  {
#line 64
  angle >>= 19;
#line 66
  tmp = FixedMul(move, *(finecosine + angle));
#line 66
  (player->mo)->momx += tmp;
#line 67
  tmp___0 = FixedMul(move, finesine[angle]);
#line 67
  (player->mo)->momy += tmp___0;
#line 68
  return;
}
}
#line 77 "p_user.c"
void P_CalcHeight(player_t *player ) 
{ 
  int angle ;
  fixed_t bob ;
  fixed_t tmp ;
  fixed_t tmp___0 ;

  {
#line 88
  tmp = FixedMul((player->mo)->momx, (player->mo)->momx);
#line 88
  tmp___0 = FixedMul((player->mo)->momy, (player->mo)->momy);
#line 88
  player->bob = tmp + tmp___0;
#line 92
  player->bob >>= 2;
#line 94
  if (player->bob > 0x100000) {
#line 95
    player->bob = 0x100000;
  }
#line 97
  if (player->cheats & 4) {
#line 97
    goto _L;
  } else
#line 97
  if (! onground) {
    _L: /* CIL Label */ 
#line 99
    player->viewz = (player->mo)->z + 41 * (1 << 16);
#line 101
    if (player->viewz > (player->mo)->ceilingz - 4 * (1 << 16)) {
#line 102
      player->viewz = (player->mo)->ceilingz - 4 * (1 << 16);
    }
#line 104
    player->viewz = (player->mo)->z + player->viewheight;
#line 105
    return;
  }
#line 108
  angle = 409 * leveltime & 8191;
#line 109
  bob = FixedMul(player->bob / 2, finesine[angle]);
#line 113
  if ((unsigned int )player->playerstate == 0U) {
#line 115
    player->viewheight += player->deltaviewheight;
#line 117
    if (player->viewheight > 41 * (1 << 16)) {
#line 119
      player->viewheight = 41 * (1 << 16);
#line 120
      player->deltaviewheight = 0;
    }
#line 123
    if (player->viewheight < (41 * (1 << 16)) / 2) {
#line 125
      player->viewheight = (41 * (1 << 16)) / 2;
#line 126
      if (player->deltaviewheight <= 0) {
#line 127
        player->deltaviewheight = 1;
      }
    }
#line 130
    if (player->deltaviewheight) {
#line 132
      player->deltaviewheight += (1 << 16) / 4;
#line 133
      if (! player->deltaviewheight) {
#line 134
        player->deltaviewheight = 1;
      }
    }
  }
#line 137
  player->viewz = ((player->mo)->z + player->viewheight) + bob;
#line 139
  if (player->viewz > (player->mo)->ceilingz - 4 * (1 << 16)) {
#line 140
    player->viewz = (player->mo)->ceilingz - 4 * (1 << 16);
  }
#line 141
  return;
}
}
#line 148 "p_user.c"
void P_MovePlayer(player_t *player ) 
{ 
  ticcmd_t *cmd ;

  {
#line 152
  cmd = & player->cmd;
#line 154
  (player->mo)->angle += (angle_t )((int )cmd->angleturn << 16);
#line 158
  onground = (boolean )((player->mo)->z <= (player->mo)->floorz);
#line 160
  if (cmd->forwardmove) {
#line 160
    if (onground) {
#line 161
      P_Thrust(player, (player->mo)->angle, (int )cmd->forwardmove * 2048);
    } else {
#line 160
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 163
  if (cmd->sidemove) {
#line 163
    if (onground) {
#line 164
      P_Thrust(player, (player->mo)->angle - 1073741824U, (int )cmd->sidemove * 2048);
    } else {
#line 163
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 166
  if (cmd->forwardmove) {
#line 166
    goto _L___2;
  } else
#line 166
  if (cmd->sidemove) {
    _L___2: /* CIL Label */ 
#line 166
    if ((unsigned long )(player->mo)->state == (unsigned long )(& states[149])) {
#line 169
      P_SetMobjState(player->mo, (statenum_t )150);
    } else {
#line 166
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 171
  return;
}
}
#line 182 "p_user.c"
void P_DeathThink(player_t *player ) 
{ 
  angle_t angle ;
  angle_t delta ;

  {
#line 187
  P_MovePsprites(player);
#line 190
  if (player->viewheight > 6 * (1 << 16)) {
#line 191
    player->viewheight -= 1 << 16;
  }
#line 193
  if (player->viewheight < 6 * (1 << 16)) {
#line 194
    player->viewheight = 6 * (1 << 16);
  }
#line 196
  player->deltaviewheight = 0;
#line 197
  onground = (boolean )((player->mo)->z <= (player->mo)->floorz);
#line 198
  P_CalcHeight(player);
#line 200
  if (player->attacker) {
#line 200
    if ((unsigned long )player->attacker != (unsigned long )player->mo) {
#line 202
      angle = R_PointToAngle2((player->mo)->x, (player->mo)->y, (player->attacker)->x,
                              (player->attacker)->y);
#line 207
      delta = angle - (player->mo)->angle;
#line 209
      if (delta < 59652323U) {
#line 209
        goto _L;
      } else
#line 209
      if (delta > 4235314973U) {
        _L: /* CIL Label */ 
#line 213
        (player->mo)->angle = angle;
#line 215
        if (player->damagecount) {
#line 216
          (player->damagecount) --;
        }
      } else
#line 218
      if (delta < 0x80000000) {
#line 219
        (player->mo)->angle += 59652323U;
      } else {
#line 221
        (player->mo)->angle -= 59652323U;
      }
    } else {
#line 200
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 223
  if (player->damagecount) {
#line 224
    (player->damagecount) --;
  }
#line 227
  if ((int )player->cmd.buttons & 2) {
#line 228
    player->playerstate = (playerstate_t )2;
  }
#line 229
  return;
}
}
#line 236 "p_user.c"
void P_PlayerThink(player_t *player ) 
{ 
  ticcmd_t *cmd ;
  weapontype_t newweapon ;

  {
#line 242
  if (player->cheats & 1) {
#line 243
    (player->mo)->flags |= 4096;
  } else {
#line 245
    (player->mo)->flags &= -4097;
  }
#line 248
  cmd = & player->cmd;
#line 249
  if ((player->mo)->flags & 128) {
#line 251
    cmd->angleturn = (short)0;
#line 252
    cmd->forwardmove = (char)100;
#line 253
    cmd->sidemove = (char)0;
#line 254
    (player->mo)->flags &= -129;
  }
#line 258
  if ((unsigned int )player->playerstate == 1U) {
#line 260
    P_DeathThink(player);
#line 261
    return;
  }
#line 267
  if ((player->mo)->reactiontime) {
#line 268
    ((player->mo)->reactiontime) --;
  } else {
#line 270
    P_MovePlayer(player);
  }
#line 272
  P_CalcHeight(player);
#line 274
  if ((((player->mo)->subsector)->sector)->special) {
#line 275
    P_PlayerInSpecialSector(player);
  }
#line 280
  if ((int )cmd->buttons & 128) {
#line 281
    cmd->buttons = (byte )0;
  }
#line 283
  if ((int )cmd->buttons & 4) {
#line 288
    newweapon = (weapontype_t )(((int )cmd->buttons & 56) >> 3);
#line 290
    if ((unsigned int )newweapon == 0U) {
#line 290
      if (player->weaponowned[7]) {
#line 290
        if ((unsigned int )player->readyweapon == 7U) {
#line 290
          if (player->powers[1]) {
#line 290
            goto _L___1;
          } else {
#line 290
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 295
          newweapon = (weapontype_t )7;
        }
      } else {
#line 290
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
#line 298
    if ((unsigned int )gamemode == 2U) {
#line 298
      if ((unsigned int )newweapon == 2U) {
#line 298
        if (player->weaponowned[8]) {
#line 298
          if ((unsigned int )player->readyweapon != 8U) {
#line 303
            newweapon = (weapontype_t )8;
          } else {
#line 298
            goto _L___4;
          }
        } else {
#line 298
          goto _L___4;
        }
      } else {
#line 298
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
      _L___3: /* CIL Label */ 
      _L___2: /* CIL Label */ ;
    }
#line 307
    if (player->weaponowned[newweapon]) {
#line 307
      if ((unsigned int )newweapon != (unsigned int )player->readyweapon) {
#line 312
        if ((unsigned int )newweapon != 5U) {
#line 312
          if ((unsigned int )newweapon != 6U) {
#line 312
            goto _L___5;
          } else {
#line 312
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 312
        if ((unsigned int )gamemode != 0U) {
          _L___5: /* CIL Label */ 
#line 316
          player->pendingweapon = newweapon;
        }
      } else {
#line 307
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ ;
    }
  }
#line 322
  if ((int )cmd->buttons & 2) {
#line 324
    if (! player->usedown) {
#line 326
      P_UseLines(player);
#line 327
      player->usedown = 1;
    }
  } else {
#line 331
    player->usedown = 0;
  }
#line 334
  P_MovePsprites(player);
#line 339
  if (player->powers[1]) {
#line 340
    (player->powers[1]) ++;
  }
#line 342
  if (player->powers[0]) {
#line 343
    (player->powers[0]) --;
  }
#line 345
  if (player->powers[2]) {
#line 346
    (player->powers[2]) --;
#line 346
    if (! player->powers[2]) {
#line 347
      (player->mo)->flags &= -262145;
    }
  }
#line 349
  if (player->powers[5]) {
#line 350
    (player->powers[5]) --;
  }
#line 352
  if (player->powers[3]) {
#line 353
    (player->powers[3]) --;
  }
#line 355
  if (player->damagecount) {
#line 356
    (player->damagecount) --;
  }
#line 358
  if (player->bonuscount) {
#line 359
    (player->bonuscount) --;
  }
#line 363
  if (player->powers[0]) {
#line 365
    if (player->powers[0] > 128) {
#line 365
      goto _L___8;
    } else
#line 365
    if (player->powers[0] & 8) {
      _L___8: /* CIL Label */ 
#line 367
      player->fixedcolormap = 32;
    } else {
#line 369
      player->fixedcolormap = 0;
    }
  } else
#line 371
  if (player->powers[5]) {
#line 373
    if (player->powers[5] > 128) {
#line 373
      goto _L___9;
    } else
#line 373
    if (player->powers[5] & 8) {
      _L___9: /* CIL Label */ 
#line 377
      player->fixedcolormap = 1;
    } else {
#line 380
      player->fixedcolormap = 0;
    }
  } else {
#line 383
    player->fixedcolormap = 0;
  }
#line 384
  return;
}
}
#line 25 "r_bsp.c"
static char const   rcsid___41[48]  = 
#line 25 "r_bsp.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'_',      (char const   )'b', 
        (char const   )'s',      (char const   )'p',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'4',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'7',      (char const   )'/', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )' ',      (char const   )'2',      (char const   )'2', 
        (char const   )':',      (char const   )'4',      (char const   )'5',      (char const   )':', 
        (char const   )'1',      (char const   )'2',      (char const   )' ',      (char const   )'b', 
        (char const   )'1',      (char const   )' ',      (char const   )'E',      (char const   )'x', 
        (char const   )'p',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 47 "r_bsp.c"
seg_t *curline  ;
#line 48 "r_bsp.c"
side_t *sidedef  ;
#line 49 "r_bsp.c"
line_t *linedef  ;
#line 50 "r_bsp.c"
sector_t *frontsector  ;
#line 51 "r_bsp.c"
sector_t *backsector  ;
#line 53 "r_bsp.c"
drawseg_t drawsegs[256]  ;
#line 54 "r_bsp.c"
drawseg_t *ds_p  ;
#line 57
void R_StoreWallRange(int start , int stop ) ;
#line 68 "r_bsp.c"
void R_ClearDrawSegs(void) 
{ 


  {
#line 70
  ds_p = drawsegs;
#line 71
  return;
}
}
#line 91 "r_bsp.c"
cliprange_t *newend  ;
#line 92 "r_bsp.c"
cliprange_t solidsegs[32]  ;
#line 103 "r_bsp.c"
void R_ClipSolidWallSegment(int first___0 , int last ) 
{ 
  cliprange_t *next ;
  cliprange_t *start ;
  cliprange_t *tmp ;

  {
#line 113
  start = solidsegs;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (start->last < first___0 - 1)) {
#line 114
      goto while_break;
    }
#line 115
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (first___0 < start->first) {
#line 119
    if (last < start->first - 1) {
#line 123
      R_StoreWallRange(first___0, last);
#line 124
      next = newend;
#line 125
      newend ++;
      {
#line 127
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 127
        if (! ((unsigned long )next != (unsigned long )start)) {
#line 127
          goto while_break___0;
        }
#line 129
        *next = *(next - 1);
#line 130
        next --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 132
      next->first = first___0;
#line 133
      next->last = last;
#line 134
      return;
    }
#line 138
    R_StoreWallRange(first___0, start->first - 1);
#line 140
    start->first = first___0;
  }
#line 144
  if (last <= start->last) {
#line 145
    return;
  }
#line 147
  next = start;
  {
#line 148
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 148
    if (! (last >= (next + 1)->first - 1)) {
#line 148
      goto while_break___1;
    }
#line 151
    R_StoreWallRange(next->last + 1, (next + 1)->first - 1);
#line 152
    next ++;
#line 154
    if (last <= next->last) {
#line 158
      start->last = next->last;
#line 159
      goto crunch;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 164
  R_StoreWallRange(next->last + 1, last);
#line 166
  start->last = last;
  crunch: 
#line 171
  if ((unsigned long )next == (unsigned long )start) {
#line 174
    return;
  }
  {
#line 178
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 178
    tmp = next;
#line 178
    next ++;
#line 178
    if (! ((unsigned long )tmp != (unsigned long )newend)) {
#line 178
      goto while_break___2;
    }
#line 181
    start ++;
#line 181
    *start = *next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 184
  newend = start + 1;
#line 185
  return;
}
}
#line 196 "r_bsp.c"
void R_ClipPassWallSegment(int first___0 , int last ) 
{ 
  cliprange_t *start ;

  {
#line 205
  start = solidsegs;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (start->last < first___0 - 1)) {
#line 206
      goto while_break;
    }
#line 207
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  if (first___0 < start->first) {
#line 211
    if (last < start->first - 1) {
#line 214
      R_StoreWallRange(first___0, last);
#line 215
      return;
    }
#line 219
    R_StoreWallRange(first___0, start->first - 1);
  }
#line 223
  if (last <= start->last) {
#line 224
    return;
  }
  {
#line 226
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 226
    if (! (last >= (start + 1)->first - 1)) {
#line 226
      goto while_break___0;
    }
#line 229
    R_StoreWallRange(start->last + 1, (start + 1)->first - 1);
#line 230
    start ++;
#line 232
    if (last <= start->last) {
#line 233
      return;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 237
  R_StoreWallRange(start->last + 1, last);
#line 238
  return;
}
}
#line 245 "r_bsp.c"
void R_ClearClipSegs(void) 
{ 


  {
#line 247
  solidsegs[0].first = -2147483647;
#line 248
  solidsegs[0].last = -1;
#line 249
  solidsegs[1].first = viewwidth;
#line 250
  solidsegs[1].last = 0x7fffffff;
#line 251
  newend = solidsegs + 2;
#line 252
  return;
}
}
#line 259 "r_bsp.c"
void R_AddLine(seg_t *line ) 
{ 
  int x1 ;
  int x2 ;
  angle_t angle1 ;
  angle_t angle2 ;
  angle_t span ;
  angle_t tspan ;

  {
#line 268
  curline = line;
#line 271
  angle1 = R_PointToAngle((line->v1)->x, (line->v1)->y);
#line 272
  angle2 = R_PointToAngle((line->v2)->x, (line->v2)->y);
#line 276
  span = angle1 - angle2;
#line 279
  if (span >= 0x80000000) {
#line 280
    return;
  }
#line 283
  rw_angle1 = (int )angle1;
#line 284
  angle1 -= viewangle;
#line 285
  angle2 -= viewangle;
#line 287
  tspan = angle1 + clipangle;
#line 288
  if (tspan > 2U * clipangle) {
#line 290
    tspan -= 2U * clipangle;
#line 293
    if (tspan >= span) {
#line 294
      return;
    }
#line 296
    angle1 = clipangle;
  }
#line 298
  tspan = clipangle - angle2;
#line 299
  if (tspan > 2U * clipangle) {
#line 301
    tspan -= 2U * clipangle;
#line 304
    if (tspan >= span) {
#line 305
      return;
    }
#line 306
    angle2 = - clipangle;
  }
#line 311
  angle1 = (angle1 + 1073741824U) >> 19;
#line 312
  angle2 = (angle2 + 1073741824U) >> 19;
#line 313
  x1 = viewangletox[angle1];
#line 314
  x2 = viewangletox[angle2];
#line 317
  if (x1 == x2) {
#line 318
    return;
  }
#line 320
  backsector = line->backsector;
#line 323
  if (! backsector) {
#line 324
    goto clipsolid;
  }
#line 327
  if (backsector->ceilingheight <= frontsector->floorheight) {
#line 327
    goto _L;
  } else
#line 327
  if (backsector->floorheight >= frontsector->ceilingheight) {
    _L: /* CIL Label */ 
#line 329
    goto clipsolid;
  }
#line 332
  if (backsector->ceilingheight != frontsector->ceilingheight) {
#line 332
    goto _L___0;
  } else
#line 332
  if (backsector->floorheight != frontsector->floorheight) {
    _L___0: /* CIL Label */ 
#line 334
    goto clippass;
  }
#line 341
  if ((int )backsector->ceilingpic == (int )frontsector->ceilingpic) {
#line 341
    if ((int )backsector->floorpic == (int )frontsector->floorpic) {
#line 341
      if ((int )backsector->lightlevel == (int )frontsector->lightlevel) {
#line 341
        if ((int )(curline->sidedef)->midtexture == 0) {
#line 346
          return;
        } else {
#line 341
          goto _L___3;
        }
      } else {
#line 341
        goto _L___3;
      }
    } else {
#line 341
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ ;
  }
  clippass: 
#line 351
  R_ClipPassWallSegment(x1, x2 - 1);
#line 352
  return;
  clipsolid: 
#line 355
  R_ClipSolidWallSegment(x1, x2 - 1);
#line 356
  return;
}
}
#line 365 "r_bsp.c"
int checkcoord[12][4]  = 
#line 365
  { {        3,        0,        2,        1}, 
   {        3,        0,        2,        0}, 
   {        3,        1,        2,        0}, 
   {        0}, 
   {        2,        0,        2,        1}, 
   {        0,        0,        0,        0}, 
   {        3,        1,        3,        0}, 
   {        0}, 
   {        2,        0,        3,        1}, 
   {        2,        1,        3,        1}, 
   {        2,        1,        3,        0}};
#line 381 "r_bsp.c"
boolean R_CheckBBox(fixed_t *bspcoord ) 
{ 
  int boxx ;
  int boxy ;
  int boxpos ;
  fixed_t x1 ;
  fixed_t y1___0 ;
  fixed_t x2 ;
  fixed_t y2 ;
  angle_t angle1 ;
  angle_t angle2 ;
  angle_t span ;
  angle_t tspan ;
  cliprange_t *start ;
  int sx1 ;
  int sx2 ;
  angle_t tmp ;
  angle_t tmp___0 ;

  {
#line 404
  if (viewx <= *(bspcoord + 2)) {
#line 405
    boxx = 0;
  } else
#line 406
  if (viewx < *(bspcoord + 3)) {
#line 407
    boxx = 1;
  } else {
#line 409
    boxx = 2;
  }
#line 411
  if (viewy >= *(bspcoord + 0)) {
#line 412
    boxy = 0;
  } else
#line 413
  if (viewy > *(bspcoord + 1)) {
#line 414
    boxy = 1;
  } else {
#line 416
    boxy = 2;
  }
#line 418
  boxpos = (boxy << 2) + boxx;
#line 419
  if (boxpos == 5) {
#line 420
    return ((boolean )1);
  }
#line 422
  x1 = *(bspcoord + checkcoord[boxpos][0]);
#line 423
  y1___0 = *(bspcoord + checkcoord[boxpos][1]);
#line 424
  x2 = *(bspcoord + checkcoord[boxpos][2]);
#line 425
  y2 = *(bspcoord + checkcoord[boxpos][3]);
#line 428
  tmp = R_PointToAngle(x1, y1___0);
#line 428
  angle1 = tmp - viewangle;
#line 429
  tmp___0 = R_PointToAngle(x2, y2);
#line 429
  angle2 = tmp___0 - viewangle;
#line 431
  span = angle1 - angle2;
#line 434
  if (span >= 0x80000000) {
#line 435
    return ((boolean )1);
  }
#line 437
  tspan = angle1 + clipangle;
#line 439
  if (tspan > 2U * clipangle) {
#line 441
    tspan -= 2U * clipangle;
#line 444
    if (tspan >= span) {
#line 445
      return ((boolean )0);
    }
#line 447
    angle1 = clipangle;
  }
#line 449
  tspan = clipangle - angle2;
#line 450
  if (tspan > 2U * clipangle) {
#line 452
    tspan -= 2U * clipangle;
#line 455
    if (tspan >= span) {
#line 456
      return ((boolean )0);
    }
#line 458
    angle2 = - clipangle;
  }
#line 465
  angle1 = (angle1 + 1073741824U) >> 19;
#line 466
  angle2 = (angle2 + 1073741824U) >> 19;
#line 467
  sx1 = viewangletox[angle1];
#line 468
  sx2 = viewangletox[angle2];
#line 471
  if (sx1 == sx2) {
#line 472
    return ((boolean )0);
  }
#line 473
  sx2 --;
#line 475
  start = solidsegs;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (start->last < sx2)) {
#line 476
      goto while_break;
    }
#line 477
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  if (sx1 >= start->first) {
#line 479
    if (sx2 <= start->last) {
#line 483
      return ((boolean )0);
    } else {
#line 479
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 486
  return ((boolean )1);
}
}
#line 497 "r_bsp.c"
void R_Subsector(int num___0 ) 
{ 
  int count ;
  seg_t *line ;
  subsector_t *sub ;
  int tmp ;

  {
#line 504
  if (num___0 >= numsubsectors) {
#line 505
    I_Error("R_Subsector: ss %i with numss = %i", num___0, numsubsectors);
  }
#line 510
  sscount ++;
#line 511
  sub = subsectors + num___0;
#line 512
  frontsector = sub->sector;
#line 513
  count = (int )sub->numlines;
#line 514
  line = segs + sub->firstline;
#line 516
  if (frontsector->floorheight < viewz) {
#line 518
    floorplane = R_FindPlane(frontsector->floorheight, (int )frontsector->floorpic,
                             (int )frontsector->lightlevel);
  } else {
#line 523
    floorplane = (visplane_t *)((void *)0);
  }
#line 525
  if (frontsector->ceilingheight > viewz) {
#line 525
    goto _L;
  } else
#line 525
  if ((int )frontsector->ceilingpic == skyflatnum) {
    _L: /* CIL Label */ 
#line 528
    ceilingplane = R_FindPlane(frontsector->ceilingheight, (int )frontsector->ceilingpic,
                               (int )frontsector->lightlevel);
  } else {
#line 533
    ceilingplane = (visplane_t *)((void *)0);
  }
#line 535
  R_AddSprites(frontsector);
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    tmp = count;
#line 537
    count --;
#line 537
    if (! tmp) {
#line 537
      goto while_break;
    }
#line 539
    R_AddLine(line);
#line 540
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return;
}
}
#line 552 "r_bsp.c"
void R_RenderBSPNode(int bspnum ) 
{ 
  node_t *bsp ;
  int side ;
  boolean tmp ;

  {
#line 558
  if (bspnum & 0x8000) {
#line 560
    if (bspnum == -1) {
#line 561
      R_Subsector(0);
    } else {
#line 563
      R_Subsector(bspnum & -32769);
    }
#line 564
    return;
  }
#line 567
  bsp = nodes + bspnum;
#line 570
  side = R_PointOnSide(viewx, viewy, bsp);
#line 573
  R_RenderBSPNode((int )bsp->children[side]);
#line 576
  tmp = R_CheckBBox(bsp->bbox[side ^ 1]);
#line 576
  if (tmp) {
#line 577
    R_RenderBSPNode((int )bsp->children[side ^ 1]);
  }
#line 578
  return;
}
}
#line 27 "r_data.c"
static char const   rcsid___42[49]  = 
#line 27 "r_data.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'_',      (char const   )'d', 
        (char const   )'a',      (char const   )'t',      (char const   )'a',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'4',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'1', 
        (char const   )'6',      (char const   )':',      (char const   )'4',      (char const   )'7', 
        (char const   )':',      (char const   )'5',      (char const   )'5',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 44 "r_state.h"
fixed_t *textureheight  ;
#line 47 "r_state.h"
fixed_t *spritewidth  ;
#line 49 "r_state.h"
fixed_t *spriteoffset  ;
#line 50 "r_state.h"
fixed_t *spritetopoffset  ;
#line 52 "r_state.h"
lighttable_t *colormaps  ;
#line 58 "r_state.h"
int firstflat  ;
#line 61 "r_state.h"
int *flattranslation  ;
#line 62 "r_state.h"
int *texturetranslation  ;
#line 66 "r_state.h"
int firstspritelump  ;
#line 67 "r_state.h"
int lastspritelump  ;
#line 68 "r_state.h"
int numspritelumps  ;
#line 130 "r_data.c"
int lastflat  ;
#line 131 "r_data.c"
int numflats  ;
#line 133 "r_data.c"
int firstpatch  ;
#line 134 "r_data.c"
int lastpatch  ;
#line 135 "r_data.c"
int numpatches  ;
#line 141 "r_data.c"
int numtextures  ;
#line 142 "r_data.c"
texture_t **textures  ;
#line 145 "r_data.c"
int *texturewidthmask  ;
#line 148 "r_data.c"
int *texturecompositesize  ;
#line 149 "r_data.c"
short **texturecolumnlump  ;
#line 150 "r_data.c"
unsigned short **texturecolumnofs  ;
#line 151 "r_data.c"
byte **texturecomposite  ;
#line 184 "r_data.c"
void R_DrawColumnInCache(column_t *patch , byte *cache , int originy , int cacheheight ) 
{ 
  int count ;
  int position ;
  byte *source ;
  byte *dest ;

  {
#line 196
  dest = cache + 3;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((int )patch->topdelta != 0xff)) {
#line 198
      goto while_break;
    }
#line 200
    source = (byte *)patch + 3;
#line 201
    count = (int )patch->length;
#line 202
    position = originy + (int )patch->topdelta;
#line 204
    if (position < 0) {
#line 206
      count += position;
#line 207
      position = 0;
    }
#line 210
    if (position + count > cacheheight) {
#line 211
      count = cacheheight - position;
    }
#line 213
    if (count > 0) {
#line 214
      memcpy((void * __restrict  )(cache + position), (void const   * __restrict  )source,
             (size_t )count);
    }
#line 216
    patch = (column_t *)(((byte *)patch + (int )patch->length) + 4);
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 228 "r_data.c"
void R_GenerateComposite(int texnum ) 
{ 
  byte *block ;
  texture_t *texture ;
  texpatch_t *patch ;
  patch_t *realpatch ;
  int x___0 ;
  int x1 ;
  int x2 ;
  int i ;
  column_t *patchcol ;
  short *collump ;
  unsigned short *colofs ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 242
  texture = *(textures + texnum);
#line 244
  tmp = Z_Malloc(*(texturecompositesize + texnum), 1, (void *)(texturecomposite + texnum));
#line 244
  block = (byte *)tmp;
#line 248
  collump = *(texturecolumnlump + texnum);
#line 249
  colofs = *(texturecolumnofs + texnum);
#line 252
  patch = texture->patches;
#line 254
  i = 0;
#line 254
  patch = texture->patches;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (i < (int )texture->patchcount)) {
#line 254
      goto while_break;
    }
#line 258
    tmp___0 = W_CacheLumpNum(patch->patch, 101);
#line 258
    realpatch = (patch_t *)tmp___0;
#line 259
    x1 = patch->originx;
#line 260
    x2 = x1 + (int )realpatch->width;
#line 262
    if (x1 < 0) {
#line 263
      x___0 = 0;
    } else {
#line 265
      x___0 = x1;
    }
#line 267
    if (x2 > (int )texture->width) {
#line 268
      x2 = (int )texture->width;
    }
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 270
      if (! (x___0 < x2)) {
#line 270
        goto while_break___0;
      }
#line 273
      if ((int )*(collump + x___0) >= 0) {
#line 274
        goto __Cont;
      }
#line 276
      patchcol = (column_t *)((byte *)realpatch + realpatch->columnofs[x___0 - x1]);
#line 278
      R_DrawColumnInCache(patchcol, block + (int )*(colofs + x___0), patch->originy,
                          (int )texture->height);
      __Cont: /* CIL Label */ 
#line 270
      x___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 254
    i ++;
#line 254
    patch ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  if (((memblock_t *)(block - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 288
    I_Error("Z_CT at r_data.c:%i", 288);
  }
#line 288
  Z_ChangeTag2((void *)block, 101);
#line 289
  return;
}
}
#line 296 "r_data.c"
void R_GenerateLookup(int texnum ) 
{ 
  texture_t *texture ;
  byte *patchcount ;
  texpatch_t *patch ;
  patch_t *realpatch ;
  int x___0 ;
  int x1 ;
  int x2 ;
  int i ;
  short *collump ;
  unsigned short *colofs ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 309
  texture = *(textures + texnum);
#line 312
  *(texturecomposite + texnum) = (byte *)0;
#line 314
  *(texturecompositesize + texnum) = 0;
#line 315
  collump = *(texturecolumnlump + texnum);
#line 316
  colofs = *(texturecolumnofs + texnum);
#line 322
  tmp = __builtin_alloca((unsigned long )texture->width);
#line 322
  patchcount = (byte *)tmp;
#line 323
  memset((void *)patchcount, 0, (size_t )texture->width);
#line 324
  patch = texture->patches;
#line 326
  i = 0;
#line 326
  patch = texture->patches;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! (i < (int )texture->patchcount)) {
#line 326
      goto while_break;
    }
#line 330
    tmp___0 = W_CacheLumpNum(patch->patch, 101);
#line 330
    realpatch = (patch_t *)tmp___0;
#line 331
    x1 = patch->originx;
#line 332
    x2 = x1 + (int )realpatch->width;
#line 334
    if (x1 < 0) {
#line 335
      x___0 = 0;
    } else {
#line 337
      x___0 = x1;
    }
#line 339
    if (x2 > (int )texture->width) {
#line 340
      x2 = (int )texture->width;
    }
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (! (x___0 < x2)) {
#line 341
        goto while_break___0;
      }
#line 343
      *(patchcount + x___0) = (byte )((int )*(patchcount + x___0) + 1);
#line 344
      *(collump + x___0) = (short )patch->patch;
#line 345
      *(colofs + x___0) = (unsigned short )(realpatch->columnofs[x___0 - x1] + 3);
#line 341
      x___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 326
    i ++;
#line 326
    patch ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  x___0 = 0;
  {
#line 349
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 349
    if (! (x___0 < (int )texture->width)) {
#line 349
      goto while_break___1;
    }
#line 351
    if (! *(patchcount + x___0)) {
#line 353
      printf((char const   * __restrict  )"R_GenerateLookup: column without a patch (%s)\n",
             texture->name);
#line 355
      return;
    }
#line 359
    if ((int )*(patchcount + x___0) > 1) {
#line 362
      *(collump + x___0) = (short)-1;
#line 363
      *(colofs + x___0) = (unsigned short )*(texturecompositesize + texnum);
#line 365
      if (*(texturecompositesize + texnum) > 0x10000 - (int )texture->height) {
#line 367
        I_Error("R_GenerateLookup: texture %i is >64k", texnum);
      }
#line 371
      *(texturecompositesize + texnum) += (int )texture->height;
    }
#line 349
    x___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 374
  return;
}
}
#line 382 "r_data.c"
byte *R_GetColumn(int tex , int col ) 
{ 
  int lump ;
  int ofs ;
  void *tmp ;

  {
#line 390
  col &= *(texturewidthmask + tex);
#line 391
  lump = (int )*(*(texturecolumnlump + tex) + col);
#line 392
  ofs = (int )*(*(texturecolumnofs + tex) + col);
#line 394
  if (lump > 0) {
#line 395
    tmp = W_CacheLumpNum(lump, 101);
#line 395
    return ((byte *)tmp + ofs);
  }
#line 397
  if (! *(texturecomposite + tex)) {
#line 398
    R_GenerateComposite(tex);
  }
#line 400
  return (*(texturecomposite + tex) + ofs);
}
}
#line 411 "r_data.c"
void R_InitTextures(void) 
{ 
  maptexture_t *mtexture ;
  texture_t *texture ;
  mappatch_t *mpatch ;
  texpatch_t *patch ;
  int i ;
  int j ;
  int *maptex ;
  int *maptex2 ;
  int *maptex1 ;
  char name[9] ;
  char *names ;
  char *name_p ;
  int *patchlookup ;
  int totalwidth ;
  int nummappatches ;
  int offset ;
  int maxoff ;
  int maxoff2 ;
  int numtextures1 ;
  int numtextures2 ;
  int *directory ;
  int temp1 ;
  int temp2 ;
  int temp3 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  texture_t *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;

  {
#line 447
  name[8] = (char)0;
#line 448
  tmp = W_CacheLumpName("PNAMES", 1);
#line 448
  names = (char *)tmp;
#line 449
  nummappatches = *((int *)names);
#line 450
  name_p = names + 4;
#line 451
  tmp___0 = __builtin_alloca((unsigned long )nummappatches * sizeof(*patchlookup));
#line 451
  patchlookup = (int *)tmp___0;
#line 453
  i = 0;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! (i < nummappatches)) {
#line 453
      goto while_break;
    }
#line 455
    strncpy((char * __restrict  )(name), (char const   * __restrict  )(name_p + i * 8),
            (size_t )8);
#line 456
    *(patchlookup + i) = W_CheckNumForName(name);
#line 453
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  Z_Free((void *)names);
#line 463
  tmp___1 = W_CacheLumpName("TEXTURE1", 1);
#line 463
  maptex1 = (int *)tmp___1;
#line 463
  maptex = maptex1;
#line 464
  numtextures1 = *maptex;
#line 465
  tmp___2 = W_GetNumForName("TEXTURE1");
#line 465
  maxoff = W_LumpLength(tmp___2);
#line 466
  directory = maptex + 1;
#line 468
  tmp___5 = W_CheckNumForName("TEXTURE2");
#line 468
  if (tmp___5 != -1) {
#line 470
    tmp___3 = W_CacheLumpName("TEXTURE2", 1);
#line 470
    maptex2 = (int *)tmp___3;
#line 471
    numtextures2 = *maptex2;
#line 472
    tmp___4 = W_GetNumForName("TEXTURE2");
#line 472
    maxoff2 = W_LumpLength(tmp___4);
  } else {
#line 476
    maptex2 = (int *)((void *)0);
#line 477
    numtextures2 = 0;
#line 478
    maxoff2 = 0;
  }
#line 480
  numtextures = numtextures1 + numtextures2;
#line 482
  tmp___6 = Z_Malloc(numtextures * 4, 1, (void *)0);
#line 482
  textures = (texture_t **)tmp___6;
#line 483
  tmp___7 = Z_Malloc(numtextures * 4, 1, (void *)0);
#line 483
  texturecolumnlump = (short **)tmp___7;
#line 484
  tmp___8 = Z_Malloc(numtextures * 4, 1, (void *)0);
#line 484
  texturecolumnofs = (unsigned short **)tmp___8;
#line 485
  tmp___9 = Z_Malloc(numtextures * 4, 1, (void *)0);
#line 485
  texturecomposite = (byte **)tmp___9;
#line 486
  tmp___10 = Z_Malloc(numtextures * 4, 1, (void *)0);
#line 486
  texturecompositesize = (int *)tmp___10;
#line 487
  tmp___11 = Z_Malloc(numtextures * 4, 1, (void *)0);
#line 487
  texturewidthmask = (int *)tmp___11;
#line 488
  tmp___12 = Z_Malloc(numtextures * 4, 1, (void *)0);
#line 488
  textureheight = (fixed_t *)tmp___12;
#line 490
  totalwidth = 0;
#line 493
  temp1 = W_GetNumForName("S_START");
#line 494
  tmp___13 = W_GetNumForName("S_END");
#line 494
  temp2 = tmp___13 - 1;
#line 495
  temp3 = ((temp2 - temp1) + 63) / 64 + (numtextures + 63) / 64;
#line 496
  printf((char const   * __restrict  )"[");
#line 497
  i = 0;
  {
#line 497
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 497
    if (! (i < temp3)) {
#line 497
      goto while_break___0;
    }
#line 498
    printf((char const   * __restrict  )" ");
#line 497
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 499
  printf((char const   * __restrict  )"         ]");
#line 500
  i = 0;
  {
#line 500
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 500
    if (! (i < temp3)) {
#line 500
      goto while_break___1;
    }
#line 501
    printf((char const   * __restrict  )"\b");
#line 500
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 502
  printf((char const   * __restrict  )"\b\b\b\b\b\b\b\b\b\b");
#line 504
  i = 0;
  {
#line 504
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 504
    if (! (i < numtextures)) {
#line 504
      goto while_break___2;
    }
#line 506
    if (! (i & 63)) {
#line 507
      printf((char const   * __restrict  )".");
    }
#line 509
    if (i == numtextures1) {
#line 512
      maptex = maptex2;
#line 513
      maxoff = maxoff2;
#line 514
      directory = maptex + 1;
    }
#line 517
    offset = *directory;
#line 519
    if (offset > maxoff) {
#line 520
      I_Error("R_InitTextures: bad texture directory");
    }
#line 522
    mtexture = (maptexture_t *)((byte *)maptex + offset);
#line 524
    tmp___15 = Z_Malloc((int )(sizeof(texture_t ) + sizeof(texpatch_t ) * (unsigned long )((int )mtexture->patchcount - 1)),
                        1, (void *)0);
#line 524
    tmp___14 = (texture_t *)tmp___15;
#line 524
    *(textures + i) = tmp___14;
#line 524
    texture = tmp___14;
#line 529
    texture->width = mtexture->width;
#line 530
    texture->height = mtexture->height;
#line 531
    texture->patchcount = mtexture->patchcount;
#line 533
    memcpy((void * __restrict  )(texture->name), (void const   * __restrict  )(mtexture->name),
           (size_t )sizeof(texture->name));
#line 534
    mpatch = & mtexture->patches[0];
#line 535
    patch = & texture->patches[0];
#line 537
    j = 0;
    {
#line 537
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 537
      if (! (j < (int )texture->patchcount)) {
#line 537
        goto while_break___3;
      }
#line 539
      patch->originx = (int )mpatch->originx;
#line 540
      patch->originy = (int )mpatch->originy;
#line 541
      patch->patch = *(patchlookup + mpatch->patch);
#line 542
      if (patch->patch == -1) {
#line 544
        I_Error("R_InitTextures: Missing patch in texture %s", texture->name);
      }
#line 537
      j ++;
#line 537
      mpatch ++;
#line 537
      patch ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 548
    tmp___16 = Z_Malloc((int )texture->width * 2, 1, (void *)0);
#line 548
    *(texturecolumnlump + i) = (short *)tmp___16;
#line 549
    tmp___17 = Z_Malloc((int )texture->width * 2, 1, (void *)0);
#line 549
    *(texturecolumnofs + i) = (unsigned short *)tmp___17;
#line 551
    j = 1;
    {
#line 552
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 552
      if (! (j * 2 <= (int )texture->width)) {
#line 552
        goto while_break___4;
      }
#line 553
      j <<= 1;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 555
    *(texturewidthmask + i) = j - 1;
#line 556
    *(textureheight + i) = (int )texture->height << 16;
#line 558
    totalwidth += (int )texture->width;
#line 504
    i ++;
#line 504
    directory ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 561
  Z_Free((void *)maptex1);
#line 562
  if (maptex2) {
#line 563
    Z_Free((void *)maptex2);
  }
#line 566
  i = 0;
  {
#line 566
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 566
    if (! (i < numtextures)) {
#line 566
      goto while_break___5;
    }
#line 567
    R_GenerateLookup(i);
#line 566
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 570
  tmp___18 = Z_Malloc((numtextures + 1) * 4, 1, (void *)0);
#line 570
  texturetranslation = (int *)tmp___18;
#line 572
  i = 0;
  {
#line 572
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 572
    if (! (i < numtextures)) {
#line 572
      goto while_break___6;
    }
#line 573
    *(texturetranslation + i) = i;
#line 572
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 574
  return;
}
}
#line 581 "r_data.c"
void R_InitFlats(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 585
  tmp = W_GetNumForName("F_START");
#line 585
  firstflat = tmp + 1;
#line 586
  tmp___0 = W_GetNumForName("F_END");
#line 586
  lastflat = tmp___0 - 1;
#line 587
  numflats = (lastflat - firstflat) + 1;
#line 590
  tmp___1 = Z_Malloc((numflats + 1) * 4, 1, (void *)0);
#line 590
  flattranslation = (int *)tmp___1;
#line 592
  i = 0;
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (! (i < numflats)) {
#line 592
      goto while_break;
    }
#line 593
    *(flattranslation + i) = i;
#line 592
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  return;
}
}
#line 603 "r_data.c"
void R_InitSpriteLumps(void) 
{ 
  int i ;
  patch_t *patch ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 608
  tmp = W_GetNumForName("S_START");
#line 608
  firstspritelump = tmp + 1;
#line 609
  tmp___0 = W_GetNumForName("S_END");
#line 609
  lastspritelump = tmp___0 - 1;
#line 611
  numspritelumps = (lastspritelump - firstspritelump) + 1;
#line 612
  tmp___1 = Z_Malloc(numspritelumps * 4, 1, (void *)0);
#line 612
  spritewidth = (fixed_t *)tmp___1;
#line 613
  tmp___2 = Z_Malloc(numspritelumps * 4, 1, (void *)0);
#line 613
  spriteoffset = (fixed_t *)tmp___2;
#line 614
  tmp___3 = Z_Malloc(numspritelumps * 4, 1, (void *)0);
#line 614
  spritetopoffset = (fixed_t *)tmp___3;
#line 616
  i = 0;
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    if (! (i < numspritelumps)) {
#line 616
      goto while_break;
    }
#line 618
    if (! (i & 63)) {
#line 619
      printf((char const   * __restrict  )".");
    }
#line 621
    tmp___4 = W_CacheLumpNum(firstspritelump + i, 101);
#line 621
    patch = (patch_t *)tmp___4;
#line 622
    *(spritewidth + i) = (int )patch->width << 16;
#line 623
    *(spriteoffset + i) = (int )patch->leftoffset << 16;
#line 624
    *(spritetopoffset + i) = (int )patch->topoffset << 16;
#line 616
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 626
  return;
}
}
#line 633 "r_data.c"
void R_InitColormaps(void) 
{ 
  int lump ;
  int length ;
  int tmp ;
  void *tmp___0 ;

  {
#line 639
  lump = W_GetNumForName("COLORMAP");
#line 640
  tmp = W_LumpLength(lump);
#line 640
  length = tmp + 255;
#line 641
  tmp___0 = Z_Malloc(length, 1, (void *)0);
#line 641
  colormaps = (lighttable_t *)tmp___0;
#line 642
  colormaps = (byte *)(((int )colormaps + 255) & -256);
#line 643
  W_ReadLump(lump, (void *)colormaps);
#line 644
  return;
}
}
#line 654 "r_data.c"
void R_InitData(void) 
{ 


  {
#line 656
  R_InitTextures();
#line 657
  printf((char const   * __restrict  )"\nInitTextures");
#line 658
  R_InitFlats();
#line 659
  printf((char const   * __restrict  )"\nInitFlats");
#line 660
  R_InitSpriteLumps();
#line 661
  printf((char const   * __restrict  )"\nInitSprites");
#line 662
  R_InitColormaps();
#line 663
  printf((char const   * __restrict  )"\nInitColormaps");
#line 664
  return;
}
}
#line 672 "r_data.c"
int R_FlatNumForName(char *name ) 
{ 
  int i ;
  char namet[9] ;

  {
#line 677
  i = W_CheckNumForName(name);
#line 679
  if (i == -1) {
#line 681
    namet[8] = (char)0;
#line 682
    memcpy((void * __restrict  )(namet), (void const   * __restrict  )name, (size_t )8);
#line 683
    I_Error("R_FlatNumForName: %s not found", namet);
  }
#line 685
  return (i - firstflat);
}
}
#line 696 "r_data.c"
int R_CheckTextureNumForName(char *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 701
  if ((int )*(name + 0) == 45) {
#line 702
    return (0);
  }
#line 704
  i = 0;
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    if (! (i < numtextures)) {
#line 704
      goto while_break;
    }
#line 705
    tmp = strncasecmp((char const   *)((*(textures + i))->name), (char const   *)name,
                      (size_t )8);
#line 705
    if (! tmp) {
#line 706
      return (i);
    }
#line 704
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  return (-1);
}
}
#line 718 "r_data.c"
int R_TextureNumForName(char *name ) 
{ 
  int i ;

  {
#line 722
  i = R_CheckTextureNumForName(name);
#line 724
  if (i == -1) {
#line 726
    I_Error("R_TextureNumForName: %s not found", name);
  }
#line 729
  return (i);
}
}
#line 739 "r_data.c"
int flatmemory  ;
#line 740 "r_data.c"
int texturememory  ;
#line 741 "r_data.c"
int spritememory  ;
#line 743 "r_data.c"
void R_PrecacheLevel(void) 
{ 
  char *flatpresent ;
  char *texturepresent ;
  char *spritepresent ;
  int i ;
  int j ;
  int k ;
  int lump ;
  texture_t *texture ;
  thinker_t *th ;
  spriteframe_t *sf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 758
  if (demoplayback) {
#line 759
    return;
  }
#line 762
  tmp = __builtin_alloca((unsigned long )numflats);
#line 762
  flatpresent = (char *)tmp;
#line 763
  memset((void *)flatpresent, 0, (size_t )numflats);
#line 765
  i = 0;
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 765
    if (! (i < numsectors)) {
#line 765
      goto while_break;
    }
#line 767
    *(flatpresent + (sectors + i)->floorpic) = (char)1;
#line 768
    *(flatpresent + (sectors + i)->ceilingpic) = (char)1;
#line 765
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 771
  flatmemory = 0;
#line 773
  i = 0;
  {
#line 773
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 773
    if (! (i < numflats)) {
#line 773
      goto while_break___0;
    }
#line 775
    if (*(flatpresent + i)) {
#line 777
      lump = firstflat + i;
#line 778
      flatmemory += (lumpinfo + lump)->size;
#line 779
      W_CacheLumpNum(lump, 101);
    }
#line 773
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 784
  tmp___0 = __builtin_alloca((unsigned long )numtextures);
#line 784
  texturepresent = (char *)tmp___0;
#line 785
  memset((void *)texturepresent, 0, (size_t )numtextures);
#line 787
  i = 0;
  {
#line 787
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 787
    if (! (i < numsides)) {
#line 787
      goto while_break___1;
    }
#line 789
    *(texturepresent + (sides + i)->toptexture) = (char)1;
#line 790
    *(texturepresent + (sides + i)->midtexture) = (char)1;
#line 791
    *(texturepresent + (sides + i)->bottomtexture) = (char)1;
#line 787
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 800
  *(texturepresent + skytexture) = (char)1;
#line 802
  texturememory = 0;
#line 803
  i = 0;
  {
#line 803
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 803
    if (! (i < numtextures)) {
#line 803
      goto while_break___2;
    }
#line 805
    if (! *(texturepresent + i)) {
#line 806
      goto __Cont;
    }
#line 808
    texture = *(textures + i);
#line 810
    j = 0;
    {
#line 810
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 810
      if (! (j < (int )texture->patchcount)) {
#line 810
        goto while_break___3;
      }
#line 812
      lump = texture->patches[j].patch;
#line 813
      texturememory += (lumpinfo + lump)->size;
#line 814
      W_CacheLumpNum(lump, 101);
#line 810
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 803
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 819
  tmp___1 = __builtin_alloca((unsigned long )numsprites);
#line 819
  spritepresent = (char *)tmp___1;
#line 820
  memset((void *)spritepresent, 0, (size_t )numsprites);
#line 822
  th = thinkercap.next;
  {
#line 822
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 822
    if (! ((unsigned long )th != (unsigned long )(& thinkercap))) {
#line 822
      goto while_break___4;
    }
#line 824
    if ((unsigned long )th->function.acp1 == (unsigned long )((void (*)(void * ))(& P_MobjThinker))) {
#line 825
      *(spritepresent + ((mobj_t *)th)->sprite) = (char)1;
    }
#line 822
    th = th->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 828
  spritememory = 0;
#line 829
  i = 0;
  {
#line 829
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 829
    if (! (i < numsprites)) {
#line 829
      goto while_break___5;
    }
#line 831
    if (! *(spritepresent + i)) {
#line 832
      goto __Cont___0;
    }
#line 834
    j = 0;
    {
#line 834
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 834
      if (! (j < (sprites + i)->numframes)) {
#line 834
        goto while_break___6;
      }
#line 836
      sf = (sprites + i)->spriteframes + j;
#line 837
      k = 0;
      {
#line 837
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 837
        if (! (k < 8)) {
#line 837
          goto while_break___7;
        }
#line 839
        lump = firstspritelump + (int )sf->lump[k];
#line 840
        spritememory += (lumpinfo + lump)->size;
#line 841
        W_CacheLumpNum(lump, 101);
#line 837
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 834
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 829
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 845
  return;
}
}
#line 27 "r_draw.c"
static char const   rcsid___43[49]  = 
#line 27 "r_draw.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'_',      (char const   )'d', 
        (char const   )'r',      (char const   )'a',      (char const   )'w',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'4',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'1', 
        (char const   )'6',      (char const   )':',      (char const   )'4',      (char const   )'7', 
        (char const   )':',      (char const   )'5',      (char const   )'5',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 54 "r_state.h"
int viewwidth  ;
#line 55 "r_state.h"
int scaledviewwidth  ;
#line 56 "r_state.h"
int viewheight  ;
#line 43 "r_main.h"
int viewwindowx  ;
#line 44 "r_main.h"
int viewwindowy  ;
#line 32 "r_draw.h"
lighttable_t *dc_colormap  ;
#line 33 "r_draw.h"
int dc_x  ;
#line 34 "r_draw.h"
int dc_yl  ;
#line 35 "r_draw.h"
int dc_yh  ;
#line 36 "r_draw.h"
fixed_t dc_iscale  ;
#line 37 "r_draw.h"
fixed_t dc_texturemid  ;
#line 40 "r_draw.h"
byte *dc_source  ;
#line 64 "r_draw.h"
int ds_y  ;
#line 65 "r_draw.h"
int ds_x1  ;
#line 66 "r_draw.h"
int ds_x2  ;
#line 68 "r_draw.h"
lighttable_t *ds_colormap  ;
#line 70 "r_draw.h"
fixed_t ds_xfrac  ;
#line 71 "r_draw.h"
fixed_t ds_yfrac  ;
#line 72 "r_draw.h"
fixed_t ds_xstep  ;
#line 73 "r_draw.h"
fixed_t ds_ystep  ;
#line 76 "r_draw.h"
byte *ds_source  ;
#line 78 "r_draw.h"
byte *translationtables  ;
#line 79 "r_draw.h"
byte *dc_translation  ;
#line 63 "r_draw.c"
byte *viewimage  ;
#line 69 "r_draw.c"
byte *ylookup[832]  ;
#line 70 "r_draw.c"
int columnofs[1120]  ;
#line 76 "r_draw.c"
byte translations[3][256]  ;
#line 96 "r_draw.c"
int dccount  ;
#line 105 "r_draw.c"
void R_DrawColumn(void) 
{ 
  int count ;
  byte *dest ;
  fixed_t frac ;
  fixed_t fracstep ;
  int tmp ;

  {
#line 112
  count = dc_yh - dc_yl;
#line 115
  if (count < 0) {
#line 116
    return;
  }
#line 119
  if ((unsigned int )dc_x >= 320U) {
#line 119
    goto _L___0;
  } else
#line 119
  if (dc_yl < 0) {
    _L___0: /* CIL Label */ 
#line 119
    goto _L;
  } else
#line 119
  if (dc_yh >= 200) {
    _L: /* CIL Label */ 
#line 122
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
  }
#line 128
  dest = ylookup[dc_yl] + columnofs[dc_x];
#line 132
  fracstep = dc_iscale;
#line 133
  frac = dc_texturemid + (dc_yl - centery) * fracstep;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    *dest = *(dc_colormap + *(dc_source + ((frac >> 16) & 127)));
#line 144
    dest += 320;
#line 145
    frac += fracstep;
#line 138
    tmp = count;
#line 138
    count --;
#line 138
    if (! tmp) {
#line 138
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 211 "r_draw.c"
void R_DrawColumnLow(void) 
{ 
  int count ;
  byte *dest ;
  byte *dest2 ;
  fixed_t frac ;
  fixed_t fracstep ;
  byte tmp ;
  int tmp___0 ;

  {
#line 219
  count = dc_yh - dc_yl;
#line 222
  if (count < 0) {
#line 223
    return;
  }
#line 226
  if ((unsigned int )dc_x >= 320U) {
#line 226
    goto _L___0;
  } else
#line 226
  if (dc_yl < 0) {
    _L___0: /* CIL Label */ 
#line 226
    goto _L;
  } else
#line 226
  if (dc_yh >= 200) {
    _L: /* CIL Label */ 
#line 231
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
  }
#line 236
  dc_x <<= 1;
#line 238
  dest = ylookup[dc_yl] + columnofs[dc_x];
#line 239
  dest2 = ylookup[dc_yl] + columnofs[dc_x + 1];
#line 241
  fracstep = dc_iscale;
#line 242
  frac = dc_texturemid + (dc_yl - centery) * fracstep;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    tmp = *(dc_colormap + *(dc_source + ((frac >> 16) & 127)));
#line 247
    *dest = tmp;
#line 247
    *dest2 = tmp;
#line 248
    dest += 320;
#line 249
    dest2 += 320;
#line 250
    frac += fracstep;
#line 244
    tmp___0 = count;
#line 244
    count --;
#line 244
    if (! tmp___0) {
#line 244
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return;
}
}
#line 263 "r_draw.c"
int fuzzoffset[50]  = 
#line 263
  {      320,      -320,      320,      -320, 
        320,      320,      -320,      320, 
        320,      -320,      320,      320, 
        320,      -320,      320,      320, 
        320,      -320,      -320,      -320, 
        -320,      320,      -320,      -320, 
        320,      320,      320,      320, 
        -320,      320,      -320,      320, 
        320,      -320,      -320,      320, 
        320,      -320,      -320,      -320, 
        -320,      320,      320,      320, 
        320,      -320,      320,      320, 
        -320,      320};
#line 274 "r_draw.c"
int fuzzpos  =    0;
#line 285 "r_draw.c"
void R_DrawFuzzColumn(void) 
{ 
  int count ;
  byte *dest ;
  fixed_t frac ;
  fixed_t fracstep ;
  int tmp ;

  {
#line 293
  if (! dc_yl) {
#line 294
    dc_yl = 1;
  }
#line 297
  if (dc_yh == viewheight - 1) {
#line 298
    dc_yh = viewheight - 2;
  }
#line 300
  count = dc_yh - dc_yl;
#line 303
  if (count < 0) {
#line 304
    return;
  }
#line 308
  if ((unsigned int )dc_x >= 320U) {
#line 308
    goto _L___0;
  } else
#line 308
  if (dc_yl < 0) {
    _L___0: /* CIL Label */ 
#line 308
    goto _L;
  } else
#line 308
  if (dc_yh >= 200) {
    _L: /* CIL Label */ 
#line 311
    I_Error("R_DrawFuzzColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
  }
#line 343
  dest = ylookup[dc_yl] + columnofs[dc_x];
#line 346
  fracstep = dc_iscale;
#line 347
  frac = dc_texturemid + (dc_yl - centery) * fracstep;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    *dest = *(colormaps + (1536 + (int )*(dest + fuzzoffset[fuzzpos])));
#line 361
    fuzzpos ++;
#line 361
    if (fuzzpos == 50) {
#line 362
      fuzzpos = 0;
    }
#line 364
    dest += 320;
#line 366
    frac += fracstep;
#line 352
    tmp = count;
#line 352
    count --;
#line 352
    if (! tmp) {
#line 352
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return;
}
}
#line 385 "r_draw.c"
void R_DrawTranslatedColumn(void) 
{ 
  int count ;
  byte *dest ;
  fixed_t frac ;
  fixed_t fracstep ;
  int tmp ;

  {
#line 392
  count = dc_yh - dc_yl;
#line 393
  if (count < 0) {
#line 394
    return;
  }
#line 397
  if ((unsigned int )dc_x >= 320U) {
#line 397
    goto _L___0;
  } else
#line 397
  if (dc_yl < 0) {
    _L___0: /* CIL Label */ 
#line 397
    goto _L;
  } else
#line 397
  if (dc_yh >= 200) {
    _L: /* CIL Label */ 
#line 401
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
  }
#line 428
  dest = ylookup[dc_yl] + columnofs[dc_x];
#line 431
  fracstep = dc_iscale;
#line 432
  frac = dc_texturemid + (dc_yl - centery) * fracstep;
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    *dest = *(dc_colormap + *(dc_translation + *(dc_source + (frac >> 16))));
#line 443
    dest += 320;
#line 445
    frac += fracstep;
#line 435
    tmp = count;
#line 435
    count --;
#line 435
    if (! tmp) {
#line 435
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 459 "r_draw.c"
void R_InitTranslationTables(void) 
{ 
  int i ;
  void *tmp ;
  byte tmp___0 ;
  byte tmp___1 ;

  {
#line 463
  tmp = Z_Malloc(1023, 1, (void *)0);
#line 463
  translationtables = (byte *)tmp;
#line 464
  translationtables = (byte *)(((int )translationtables + 255) & -256);
#line 467
  i = 0;
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (! (i < 256)) {
#line 467
      goto while_break;
    }
#line 469
    if (i >= 0x70) {
#line 469
      if (i <= 0x7f) {
#line 472
        *(translationtables + i) = (byte )(0x60 + (i & 0xf));
#line 473
        *(translationtables + (i + 256)) = (byte )(0x40 + (i & 0xf));
#line 474
        *(translationtables + (i + 512)) = (byte )(0x20 + (i & 0xf));
      } else {
#line 469
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 479
      tmp___1 = (byte )i;
#line 479
      *(translationtables + (i + 512)) = tmp___1;
#line 479
      tmp___0 = tmp___1;
#line 479
      *(translationtables + (i + 256)) = tmp___0;
#line 479
      *(translationtables + i) = tmp___0;
    }
#line 467
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 483
  return;
}
}
#line 515 "r_draw.c"
int dscount  ;
#line 520 "r_draw.c"
void R_DrawSpan(void) 
{ 
  fixed_t xfrac ;
  fixed_t yfrac ;
  byte *dest ;
  int count ;
  int spot ;
  byte *tmp ;
  int tmp___0 ;

  {
#line 529
  if (ds_x2 < ds_x1) {
#line 529
    goto _L___1;
  } else
#line 529
  if (ds_x1 < 0) {
    _L___1: /* CIL Label */ 
#line 529
    goto _L___0;
  } else
#line 529
  if (ds_x2 >= 320) {
    _L___0: /* CIL Label */ 
#line 529
    goto _L;
  } else
#line 529
  if ((unsigned int )ds_y > 200U) {
    _L: /* CIL Label */ 
#line 534
    I_Error("R_DrawSpan: %i to %i at %i", ds_x1, ds_x2, ds_y);
  }
#line 541
  xfrac = ds_xfrac;
#line 542
  yfrac = ds_yfrac;
#line 544
  dest = ylookup[ds_y] + columnofs[ds_x1];
#line 547
  count = ds_x2 - ds_x1;
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    spot = ((yfrac >> 10) & 4032) + ((xfrac >> 16) & 63);
#line 556
    tmp = dest;
#line 556
    dest ++;
#line 556
    *tmp = *(ds_colormap + *(ds_source + spot));
#line 559
    xfrac += ds_xstep;
#line 560
    yfrac += ds_ystep;
#line 549
    tmp___0 = count;
#line 549
    count --;
#line 549
    if (! tmp___0) {
#line 549
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 563
  return;
}
}
#line 643 "r_draw.c"
void R_DrawSpanLow(void) 
{ 
  fixed_t xfrac ;
  fixed_t yfrac ;
  byte *dest ;
  int count ;
  int spot ;
  byte *tmp ;
  byte *tmp___0 ;
  int tmp___1 ;

  {
#line 652
  if (ds_x2 < ds_x1) {
#line 652
    goto _L___1;
  } else
#line 652
  if (ds_x1 < 0) {
    _L___1: /* CIL Label */ 
#line 652
    goto _L___0;
  } else
#line 652
  if (ds_x2 >= 320) {
    _L___0: /* CIL Label */ 
#line 652
    goto _L;
  } else
#line 652
  if ((unsigned int )ds_y > 200U) {
    _L: /* CIL Label */ 
#line 657
    I_Error("R_DrawSpan: %i to %i at %i", ds_x1, ds_x2, ds_y);
  }
#line 663
  xfrac = ds_xfrac;
#line 664
  yfrac = ds_yfrac;
#line 667
  ds_x1 <<= 1;
#line 668
  ds_x2 <<= 1;
#line 670
  dest = ylookup[ds_y] + columnofs[ds_x1];
#line 673
  count = ds_x2 - ds_x1;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    spot = ((yfrac >> 10) & 4032) + ((xfrac >> 16) & 63);
#line 679
    tmp = dest;
#line 679
    dest ++;
#line 679
    *tmp = *(ds_colormap + *(ds_source + spot));
#line 680
    tmp___0 = dest;
#line 680
    dest ++;
#line 680
    *tmp___0 = *(ds_colormap + *(ds_source + spot));
#line 682
    xfrac += ds_xstep;
#line 683
    yfrac += ds_ystep;
#line 674
    tmp___1 = count;
#line 674
    count --;
#line 674
    if (! tmp___1) {
#line 674
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  return;
}
}
#line 695 "r_draw.c"
void R_InitBuffer(int width , int height ) 
{ 
  int i ;

  {
#line 705
  viewwindowx = (320 - width) >> 1;
#line 708
  i = 0;
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (! (i < width)) {
#line 708
      goto while_break;
    }
#line 709
    columnofs[i] = viewwindowx + i;
#line 708
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  if (width == 320) {
#line 713
    viewwindowy = 0;
  } else {
#line 715
    viewwindowy = (168 - height) >> 1;
  }
#line 718
  i = 0;
  {
#line 718
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 718
    if (! (i < height)) {
#line 718
      goto while_break___0;
    }
#line 719
    ylookup[i] = screens[0] + (i + viewwindowy) * 320;
#line 718
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 720
  return;
}
}
#line 731 "r_draw.c"
void R_FillBackScreen(void) 
{ 
  byte *src ;
  byte *dest ;
  int x___0 ;
  int y___1 ;
  patch_t *patch ;
  char name1[9] ;
  char name2[8] ;
  char *name ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 740
  name1[0] = (char )'F';
#line 740
  name1[1] = (char )'L';
#line 740
  name1[2] = (char )'O';
#line 740
  name1[3] = (char )'O';
#line 740
  name1[4] = (char )'R';
#line 740
  name1[5] = (char )'7';
#line 740
  name1[6] = (char )'_';
#line 740
  name1[7] = (char )'2';
#line 740
  name1[8] = (char )'\000';
#line 743
  name2[0] = (char )'G';
#line 743
  name2[1] = (char )'R';
#line 743
  name2[2] = (char )'N';
#line 743
  name2[3] = (char )'R';
#line 743
  name2[4] = (char )'O';
#line 743
  name2[5] = (char )'C';
#line 743
  name2[6] = (char )'K';
#line 743
  name2[7] = (char )'\000';
#line 747
  if (scaledviewwidth == 320) {
#line 748
    return;
  }
#line 750
  if ((unsigned int )gamemode == 2U) {
#line 751
    name = name2;
  } else {
#line 753
    name = name1;
  }
#line 755
  tmp = W_CacheLumpName(name, 101);
#line 755
  src = (byte *)tmp;
#line 756
  dest = screens[1];
#line 758
  y___1 = 0;
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 758
    if (! (y___1 < 168)) {
#line 758
      goto while_break;
    }
#line 760
    x___0 = 0;
    {
#line 760
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 760
      if (! (x___0 < 5)) {
#line 760
        goto while_break___0;
      }
#line 762
      memcpy((void * __restrict  )dest, (void const   * __restrict  )(src + ((y___1 & 63) << 6)),
             (size_t )64);
#line 763
      dest += 64;
#line 760
      x___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 766
    if (0) {
#line 768
      memcpy((void * __restrict  )dest, (void const   * __restrict  )(src + ((y___1 & 63) << 6)),
             (size_t )0);
#line 769
      dest += 0;
    }
#line 758
    y___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 773
  tmp___0 = W_CacheLumpName("brdr_t", 101);
#line 773
  patch = (patch_t *)tmp___0;
#line 775
  x___0 = 0;
  {
#line 775
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 775
    if (! (x___0 < scaledviewwidth)) {
#line 775
      goto while_break___1;
    }
#line 776
    V_DrawPatch(viewwindowx + x___0, viewwindowy - 8, 1, patch);
#line 775
    x___0 += 8;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 777
  tmp___1 = W_CacheLumpName("brdr_b", 101);
#line 777
  patch = (patch_t *)tmp___1;
#line 779
  x___0 = 0;
  {
#line 779
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 779
    if (! (x___0 < scaledviewwidth)) {
#line 779
      goto while_break___2;
    }
#line 780
    V_DrawPatch(viewwindowx + x___0, viewwindowy + viewheight, 1, patch);
#line 779
    x___0 += 8;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 781
  tmp___2 = W_CacheLumpName("brdr_l", 101);
#line 781
  patch = (patch_t *)tmp___2;
#line 783
  y___1 = 0;
  {
#line 783
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 783
    if (! (y___1 < viewheight)) {
#line 783
      goto while_break___3;
    }
#line 784
    V_DrawPatch(viewwindowx - 8, viewwindowy + y___1, 1, patch);
#line 783
    y___1 += 8;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 785
  tmp___3 = W_CacheLumpName("brdr_r", 101);
#line 785
  patch = (patch_t *)tmp___3;
#line 787
  y___1 = 0;
  {
#line 787
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 787
    if (! (y___1 < viewheight)) {
#line 787
      goto while_break___4;
    }
#line 788
    V_DrawPatch(viewwindowx + scaledviewwidth, viewwindowy + y___1, 1, patch);
#line 787
    y___1 += 8;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 792
  tmp___4 = W_CacheLumpName("brdr_tl", 101);
#line 792
  V_DrawPatch(viewwindowx - 8, viewwindowy - 8, 1, (patch_t *)tmp___4);
#line 797
  tmp___5 = W_CacheLumpName("brdr_tr", 101);
#line 797
  V_DrawPatch(viewwindowx + scaledviewwidth, viewwindowy - 8, 1, (patch_t *)tmp___5);
#line 802
  tmp___6 = W_CacheLumpName("brdr_bl", 101);
#line 802
  V_DrawPatch(viewwindowx - 8, viewwindowy + viewheight, 1, (patch_t *)tmp___6);
#line 807
  tmp___7 = W_CacheLumpName("brdr_br", 101);
#line 807
  V_DrawPatch(viewwindowx + scaledviewwidth, viewwindowy + viewheight, 1, (patch_t *)tmp___7);
#line 811
  return;
}
}
#line 817 "r_draw.c"
void R_VideoErase(unsigned int ofs , int count ) 
{ 


  {
#line 827
  memcpy((void * __restrict  )(screens[0] + ofs), (void const   * __restrict  )(screens[1] + ofs),
         (size_t )count);
#line 828
  return;
}
}
#line 843 "r_draw.c"
void R_DrawViewBorder(void) 
{ 
  int top ;
  int side ;
  int ofs ;
  int i ;

  {
#line 850
  if (scaledviewwidth == 320) {
#line 851
    return;
  }
#line 853
  top = (168 - viewheight) / 2;
#line 854
  side = (320 - scaledviewwidth) / 2;
#line 857
  R_VideoErase(0U, top * 320 + side);
#line 860
  ofs = (viewheight + top) * 320 - side;
#line 861
  R_VideoErase((unsigned int )ofs, top * 320 + side);
#line 864
  ofs = (top * 320 + 320) - side;
#line 865
  side <<= 1;
#line 867
  i = 1;
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 867
    if (! (i < viewheight)) {
#line 867
      goto while_break;
    }
#line 869
    R_VideoErase((unsigned int )ofs, side);
#line 870
    ofs += 320;
#line 867
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 874
  V_MarkRect(0, 0, 320, 168);
#line 875
  return;
}
}
#line 27 "r_main.c"
static char const   rcsid___44[49]  = 
#line 27 "r_main.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'_',      (char const   )'m', 
        (char const   )'a',      (char const   )'i',      (char const   )'n',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'2',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 103 "r_state.h"
fixed_t viewx  ;
#line 104 "r_state.h"
fixed_t viewy  ;
#line 105 "r_state.h"
fixed_t viewz  ;
#line 107 "r_state.h"
angle_t viewangle  ;
#line 108 "r_state.h"
player_t *viewplayer  ;
#line 112 "r_state.h"
angle_t clipangle  ;
#line 114 "r_state.h"
int viewangletox[4096]  ;
#line 115 "r_state.h"
angle_t xtoviewangle[321]  ;
#line 127 "r_state.h"
int sscount  ;
#line 38 "r_main.h"
fixed_t viewcos  ;
#line 39 "r_main.h"
fixed_t viewsin  ;
#line 48 "r_main.h"
int centerx  ;
#line 49 "r_main.h"
int centery  ;
#line 51 "r_main.h"
fixed_t centerxfrac  ;
#line 52 "r_main.h"
fixed_t centeryfrac  ;
#line 53 "r_main.h"
fixed_t projection  ;
#line 57 "r_main.h"
int linecount  ;
#line 58 "r_main.h"
int loopcount  ;
#line 77 "r_main.h"
lighttable_t *scalelight[16][48]  ;
#line 78 "r_main.h"
lighttable_t *scalelightfixed[48]  ;
#line 79 "r_main.h"
lighttable_t *zlight[16][128]  ;
#line 81 "r_main.h"
int extralight  ;
#line 82 "r_main.h"
lighttable_t *fixedcolormap  ;
#line 93 "r_main.h"
int detailshift  ;
#line 100 "r_main.h"
void (*colfunc)(void)  ;
#line 101 "r_main.h"
void (*basecolfunc)(void)  ;
#line 102 "r_main.h"
void (*fuzzcolfunc)(void)  ;
#line 104 "r_main.h"
void (*spanfunc)(void)  ;
#line 52 "r_main.c"
int viewangleoffset  ;
#line 55 "r_main.c"
int validcount  =    1;
#line 59
lighttable_t **walllights ;
#line 69 "r_main.c"
int framecount  ;
#line 113 "r_main.c"
fixed_t *finecosine  =    & finesine[2048];
#line 128 "r_main.c"
void (*transcolfunc)(void)  ;
#line 138 "r_main.c"
void R_AddPointToBox(int x___0 , int y___1 , fixed_t *box ) 
{ 


  {
#line 144
  if (x___0 < *(box + 2)) {
#line 145
    *(box + 2) = x___0;
  }
#line 146
  if (x___0 > *(box + 3)) {
#line 147
    *(box + 3) = x___0;
  }
#line 148
  if (y___1 < *(box + 1)) {
#line 149
    *(box + 1) = y___1;
  }
#line 150
  if (y___1 > *(box + 0)) {
#line 151
    *(box + 0) = y___1;
  }
#line 152
  return;
}
}
#line 161 "r_main.c"
int R_PointOnSide(fixed_t x___0 , fixed_t y___1 , node_t *node ) 
{ 
  fixed_t dx ;
  fixed_t dy ;
  fixed_t left ;
  fixed_t right ;

  {
#line 172
  if (! node->dx) {
#line 174
    if (x___0 <= node->x) {
#line 175
      return (node->dy > 0);
    }
#line 177
    return (node->dy < 0);
  }
#line 179
  if (! node->dy) {
#line 181
    if (y___1 <= node->y) {
#line 182
      return (node->dx < 0);
    }
#line 184
    return (node->dx > 0);
  }
#line 187
  dx = x___0 - node->x;
#line 188
  dy = y___1 - node->y;
#line 191
  if ((unsigned int )(((node->dy ^ node->dx) ^ dx) ^ dy) & 0x80000000) {
#line 193
    if ((unsigned int )(node->dy ^ dx) & 0x80000000) {
#line 196
      return (1);
    }
#line 198
    return (0);
  }
#line 201
  left = FixedMul(node->dy >> 16, dx);
#line 202
  right = FixedMul(dy, node->dx >> 16);
#line 204
  if (right < left) {
#line 207
    return (0);
  }
#line 210
  return (1);
}
}
#line 214 "r_main.c"
int R_PointOnSegSide(fixed_t x___0 , fixed_t y___1 , seg_t *line ) 
{ 
  fixed_t lx ;
  fixed_t ly ;
  fixed_t ldx ;
  fixed_t ldy ;
  fixed_t dx ;
  fixed_t dy ;
  fixed_t left ;
  fixed_t right ;

  {
#line 229
  lx = (line->v1)->x;
#line 230
  ly = (line->v1)->y;
#line 232
  ldx = (line->v2)->x - lx;
#line 233
  ldy = (line->v2)->y - ly;
#line 235
  if (! ldx) {
#line 237
    if (x___0 <= lx) {
#line 238
      return (ldy > 0);
    }
#line 240
    return (ldy < 0);
  }
#line 242
  if (! ldy) {
#line 244
    if (y___1 <= ly) {
#line 245
      return (ldx < 0);
    }
#line 247
    return (ldx > 0);
  }
#line 250
  dx = x___0 - lx;
#line 251
  dy = y___1 - ly;
#line 254
  if ((unsigned int )(((ldy ^ ldx) ^ dx) ^ dy) & 0x80000000) {
#line 256
    if ((unsigned int )(ldy ^ dx) & 0x80000000) {
#line 259
      return (1);
    }
#line 261
    return (0);
  }
#line 264
  left = FixedMul(ldy >> 16, dx);
#line 265
  right = FixedMul(dy, ldx >> 16);
#line 267
  if (right < left) {
#line 270
    return (0);
  }
#line 273
  return (1);
}
}
#line 291 "r_main.c"
angle_t R_PointToAngle(fixed_t x___0 , fixed_t y___1 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 296
  x___0 -= viewx;
#line 297
  y___1 -= viewy;
#line 299
  if (! x___0) {
#line 299
    if (! y___1) {
#line 300
      return ((angle_t )0);
    } else {
#line 299
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 302
  if (x___0 >= 0) {
#line 305
    if (y___1 >= 0) {
#line 309
      if (x___0 > y___1) {
#line 312
        tmp = SlopeDiv((unsigned int )y___1, (unsigned int )x___0);
#line 312
        return (tantoangle[tmp]);
      } else {
#line 317
        tmp___0 = SlopeDiv((unsigned int )x___0, (unsigned int )y___1);
#line 317
        return (1073741823U - tantoangle[tmp___0]);
      }
    } else {
#line 323
      y___1 = - y___1;
#line 325
      if (x___0 > y___1) {
#line 328
        tmp___1 = SlopeDiv((unsigned int )y___1, (unsigned int )x___0);
#line 328
        return (- tantoangle[tmp___1]);
      } else {
#line 333
        tmp___2 = SlopeDiv((unsigned int )x___0, (unsigned int )y___1);
#line 333
        return (0xc0000000 + tantoangle[tmp___2]);
      }
    }
  } else {
#line 340
    x___0 = - x___0;
#line 342
    if (y___1 >= 0) {
#line 345
      if (x___0 > y___1) {
#line 348
        tmp___3 = SlopeDiv((unsigned int )y___1, (unsigned int )x___0);
#line 348
        return (2147483647U - tantoangle[tmp___3]);
      } else {
#line 353
        tmp___4 = SlopeDiv((unsigned int )x___0, (unsigned int )y___1);
#line 353
        return (1073741824U + tantoangle[tmp___4]);
      }
    } else {
#line 359
      y___1 = - y___1;
#line 361
      if (x___0 > y___1) {
#line 364
        tmp___5 = SlopeDiv((unsigned int )y___1, (unsigned int )x___0);
#line 364
        return (0x80000000 + tantoangle[tmp___5]);
      } else {
#line 369
        tmp___6 = SlopeDiv((unsigned int )x___0, (unsigned int )y___1);
#line 369
        return (3221225471U - tantoangle[tmp___6]);
      }
    }
  }
#line 373
  return ((angle_t )0);
}
}
#line 377 "r_main.c"
angle_t R_PointToAngle2(fixed_t x1 , fixed_t y1___0 , fixed_t x2 , fixed_t y2 ) 
{ 
  angle_t tmp ;

  {
#line 384
  viewx = x1;
#line 385
  viewy = y1___0;
#line 387
  tmp = R_PointToAngle(x2, y2);
#line 387
  return (tmp);
}
}
#line 391 "r_main.c"
fixed_t R_PointToDist(fixed_t x___0 , fixed_t y___1 ) 
{ 
  int angle ;
  fixed_t dx ;
  fixed_t dy ;
  fixed_t temp ;
  fixed_t dist ;
  fixed_t tmp ;

  {
#line 402
  dx = abs(x___0 - viewx);
#line 403
  dy = abs(y___1 - viewy);
#line 405
  if (dy > dx) {
#line 407
    temp = dx;
#line 408
    dx = dy;
#line 409
    dy = temp;
  }
#line 412
  tmp = FixedDiv(dy, dx);
#line 412
  angle = (int )((tantoangle[tmp >> 5] + 1073741824U) >> 19);
#line 415
  dist = FixedDiv(dx, finesine[angle]);
#line 417
  return (dist);
}
}
#line 426 "r_main.c"
void R_InitPointToAngle(void) 
{ 


  {
#line 443
  return;
}
}
#line 453 "r_main.c"
fixed_t R_ScaleFromGlobalAngle(angle_t visangle ) 
{ 
  fixed_t scale ;
  int anglea ;
  int angleb ;
  int sinea ;
  int sineb ;
  fixed_t num___0 ;
  int den ;
  fixed_t tmp ;

  {
#line 480
  anglea = (int )(1073741824U + (visangle - viewangle));
#line 481
  angleb = (int )(1073741824U + (visangle - rw_normalangle));
#line 484
  sinea = finesine[anglea >> 19];
#line 485
  sineb = finesine[angleb >> 19];
#line 486
  tmp = FixedMul(projection, sineb);
#line 486
  num___0 = tmp << detailshift;
#line 487
  den = FixedMul(rw_distance, sinea);
#line 489
  if (den > num___0 >> 16) {
#line 491
    scale = FixedDiv(num___0, den);
#line 493
    if (scale > 64 * (1 << 16)) {
#line 494
      scale = 64 * (1 << 16);
    } else
#line 495
    if (scale < 256) {
#line 496
      scale = 256;
    }
  } else {
#line 499
    scale = 64 * (1 << 16);
  }
#line 501
  return (scale);
}
}
#line 509 "r_main.c"
void R_InitTables(void) 
{ 


  {
#line 537
  return;
}
}
#line 544 "r_main.c"
void R_InitTextureMapping(void) 
{ 
  int i ;
  int x___0 ;
  int t ;
  fixed_t focallength ;

  {
#line 557
  focallength = FixedDiv(centerxfrac, finetangent[3072]);
#line 560
  i = 0;
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (! (i < 4096)) {
#line 560
      goto while_break;
    }
#line 562
    if (finetangent[i] > (1 << 16) * 2) {
#line 563
      t = -1;
    } else
#line 564
    if (finetangent[i] < - (1 << 16) * 2) {
#line 565
      t = viewwidth + 1;
    } else {
#line 568
      t = FixedMul(finetangent[i], focallength);
#line 569
      t = (((centerxfrac - t) + (1 << 16)) - 1) >> 16;
#line 571
      if (t < -1) {
#line 572
        t = -1;
      } else
#line 573
      if (t > viewwidth + 1) {
#line 574
        t = viewwidth + 1;
      }
    }
#line 576
    viewangletox[i] = t;
#line 560
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 582
  x___0 = 0;
  {
#line 582
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 582
    if (! (x___0 <= viewwidth)) {
#line 582
      goto while_break___0;
    }
#line 584
    i = 0;
    {
#line 585
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 585
      if (! (viewangletox[i] > x___0)) {
#line 585
        goto while_break___1;
      }
#line 586
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 587
    xtoviewangle[x___0] = (angle_t )((i << 19) - 0x40000000);
#line 582
    x___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 591
  i = 0;
  {
#line 591
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 591
    if (! (i < 4096)) {
#line 591
      goto while_break___2;
    }
#line 593
    t = FixedMul(finetangent[i], focallength);
#line 594
    t = centerx - t;
#line 596
    if (viewangletox[i] == -1) {
#line 597
      viewangletox[i] = 0;
    } else
#line 598
    if (viewangletox[i] == viewwidth + 1) {
#line 599
      viewangletox[i] = viewwidth;
    }
#line 591
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 602
  clipangle = xtoviewangle[0];
#line 603
  return;
}
}
#line 614 "r_main.c"
void R_InitLightTables(void) 
{ 
  int i ;
  int j ;
  int level ;
  int startmap___0 ;
  int scale ;

  {
#line 624
  i = 0;
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    if (! (i < 16)) {
#line 624
      goto while_break;
    }
#line 626
    startmap___0 = (((15 - i) * 2) * 32) / 16;
#line 627
    j = 0;
    {
#line 627
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 627
      if (! (j < 128)) {
#line 627
        goto while_break___0;
      }
#line 629
      scale = FixedDiv(160 * (1 << 16), (j + 1) << 20);
#line 630
      scale >>= 12;
#line 631
      level = startmap___0 - scale / 2;
#line 633
      if (level < 0) {
#line 634
        level = 0;
      }
#line 636
      if (level >= 32) {
#line 637
        level = 31;
      }
#line 639
      zlight[i][j] = colormaps + level * 256;
#line 627
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 624
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  return;
}
}
#line 652 "r_main.c"
boolean setsizeneeded  ;
#line 653 "r_main.c"
int setblocks  ;
#line 654 "r_main.c"
int setdetail  ;
#line 657 "r_main.c"
void R_SetViewSize(int blocks , int detail ) 
{ 


  {
#line 662
  setsizeneeded = (boolean )1;
#line 663
  setblocks = blocks;
#line 664
  setdetail = detail;
#line 665
  return;
}
}
#line 671 "r_main.c"
void R_ExecuteSetViewSize(void) 
{ 
  fixed_t cosadj ;
  fixed_t dy ;
  int i ;
  int j ;
  int level ;
  int startmap___0 ;

  {
#line 680
  setsizeneeded = (boolean )0;
#line 682
  if (setblocks == 11) {
#line 684
    scaledviewwidth = 320;
#line 685
    viewheight = 200;
  } else {
#line 689
    scaledviewwidth = setblocks * 32;
#line 690
    viewheight = (setblocks * 168) / 10 & -8;
  }
#line 693
  detailshift = setdetail;
#line 694
  viewwidth = scaledviewwidth >> detailshift;
#line 696
  centery = viewheight / 2;
#line 697
  centerx = viewwidth / 2;
#line 698
  centerxfrac = centerx << 16;
#line 699
  centeryfrac = centery << 16;
#line 700
  projection = centerxfrac;
#line 702
  if (! detailshift) {
#line 704
    basecolfunc = & R_DrawColumn;
#line 704
    colfunc = basecolfunc;
#line 705
    fuzzcolfunc = & R_DrawFuzzColumn;
#line 706
    transcolfunc = & R_DrawTranslatedColumn;
#line 707
    spanfunc = & R_DrawSpan;
  } else {
#line 711
    basecolfunc = & R_DrawColumnLow;
#line 711
    colfunc = basecolfunc;
#line 712
    fuzzcolfunc = & R_DrawFuzzColumn;
#line 713
    transcolfunc = & R_DrawTranslatedColumn;
#line 714
    spanfunc = & R_DrawSpanLow;
  }
#line 717
  R_InitBuffer(scaledviewwidth, viewheight);
#line 719
  R_InitTextureMapping();
#line 722
  pspritescale = ((1 << 16) * viewwidth) / 320;
#line 723
  pspriteiscale = ((1 << 16) * 320) / viewwidth;
#line 726
  i = 0;
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 726
    if (! (i < viewwidth)) {
#line 726
      goto while_break;
    }
#line 727
    screenheightarray[i] = (short )viewheight;
#line 726
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 730
  i = 0;
  {
#line 730
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 730
    if (! (i < viewheight)) {
#line 730
      goto while_break___0;
    }
#line 732
    dy = ((i - viewheight / 2) << 16) + (1 << 16) / 2;
#line 733
    dy = abs(dy);
#line 734
    yslope[i] = FixedDiv(((viewwidth << detailshift) / 2) * (1 << 16), dy);
#line 730
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 737
  i = 0;
  {
#line 737
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 737
    if (! (i < viewwidth)) {
#line 737
      goto while_break___1;
    }
#line 739
    cosadj = abs(*(finecosine + (xtoviewangle[i] >> 19)));
#line 740
    distscale[i] = FixedDiv(1 << 16, cosadj);
#line 737
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 745
  i = 0;
  {
#line 745
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 745
    if (! (i < 16)) {
#line 745
      goto while_break___2;
    }
#line 747
    startmap___0 = (((15 - i) * 2) * 32) / 16;
#line 748
    j = 0;
    {
#line 748
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 748
      if (! (j < 48)) {
#line 748
        goto while_break___3;
      }
#line 750
      level = startmap___0 - ((j * 320) / (viewwidth << detailshift)) / 2;
#line 752
      if (level < 0) {
#line 753
        level = 0;
      }
#line 755
      if (level >= 32) {
#line 756
        level = 31;
      }
#line 758
      scalelight[i][j] = colormaps + level * 256;
#line 748
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 745
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 761
  return;
}
}
#line 773 "r_main.c"
void R_Init(void) 
{ 


  {
#line 775
  R_InitData();
#line 776
  printf((char const   * __restrict  )"\nR_InitData");
#line 777
  R_InitPointToAngle();
#line 778
  printf((char const   * __restrict  )"\nR_InitPointToAngle");
#line 779
  R_InitTables();
#line 781
  printf((char const   * __restrict  )"\nR_InitTables");
#line 783
  R_SetViewSize(screenblocks, detailLevel);
#line 784
  R_InitPlanes();
#line 785
  printf((char const   * __restrict  )"\nR_InitPlanes");
#line 786
  R_InitLightTables();
#line 787
  printf((char const   * __restrict  )"\nR_InitLightTables");
#line 788
  R_InitSkyMap();
#line 789
  printf((char const   * __restrict  )"\nR_InitSkyMap");
#line 790
  R_InitTranslationTables();
#line 791
  printf((char const   * __restrict  )"\nR_InitTranslationsTables");
#line 793
  framecount = 0;
#line 794
  return;
}
}
#line 800 "r_main.c"
subsector_t *R_PointInSubsector(fixed_t x___0 , fixed_t y___1 ) 
{ 
  node_t *node ;
  int side ;
  int nodenum ;

  {
#line 810
  if (! numnodes) {
#line 811
    return (subsectors);
  }
#line 813
  nodenum = numnodes - 1;
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 815
    if (! (! (nodenum & 0x8000))) {
#line 815
      goto while_break;
    }
#line 817
    node = nodes + nodenum;
#line 818
    side = R_PointOnSide(x___0, y___1, node);
#line 819
    nodenum = (int )node->children[side];
  }
  while_break: /* CIL Label */ ;
  }
#line 822
  return (subsectors + (nodenum & -32769));
}
}
#line 830 "r_main.c"
void R_SetupFrame(player_t *player ) 
{ 
  int i ;

  {
#line 834
  viewplayer = player;
#line 835
  viewx = (player->mo)->x;
#line 836
  viewy = (player->mo)->y;
#line 837
  viewangle = (player->mo)->angle + (angle_t )viewangleoffset;
#line 838
  extralight = player->extralight;
#line 840
  viewz = player->viewz;
#line 842
  viewsin = finesine[viewangle >> 19];
#line 843
  viewcos = *(finecosine + (viewangle >> 19));
#line 845
  sscount = 0;
#line 847
  if (player->fixedcolormap) {
#line 849
    fixedcolormap = colormaps + (unsigned long )(player->fixedcolormap * 256) * sizeof(lighttable_t );
#line 853
    walllights = scalelightfixed;
#line 855
    i = 0;
    {
#line 855
    while (1) {
      while_continue: /* CIL Label */ ;
#line 855
      if (! (i < 48)) {
#line 855
        goto while_break;
      }
#line 856
      scalelightfixed[i] = fixedcolormap;
#line 855
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 859
    fixedcolormap = (lighttable_t *)0;
  }
#line 861
  framecount ++;
#line 862
  validcount ++;
#line 863
  return;
}
}
#line 870 "r_main.c"
void R_RenderPlayerView(player_t *player ) 
{ 


  {
#line 872
  R_SetupFrame(player);
#line 875
  R_ClearClipSegs();
#line 876
  R_ClearDrawSegs();
#line 877
  R_ClearPlanes();
#line 878
  R_ClearSprites();
#line 881
  NetUpdate();
#line 884
  R_RenderBSPNode(numnodes - 1);
#line 887
  NetUpdate();
#line 889
  R_DrawPlanes();
#line 892
  NetUpdate();
#line 894
  R_DrawMasked();
#line 897
  NetUpdate();
#line 898
  return;
}
}
#line 27 "r_plane.c"
static char const   rcsid___45[50]  = 
#line 27 "r_plane.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'_',      (char const   )'p', 
        (char const   )'l',      (char const   )'a',      (char const   )'n',      (char const   )'e', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'4', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )' ', 
        (char const   )'1',      (char const   )'6',      (char const   )':',      (char const   )'4', 
        (char const   )'7',      (char const   )':',      (char const   )'5',      (char const   )'5', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 129 "r_state.h"
visplane_t *floorplane  ;
#line 130 "r_state.h"
visplane_t *ceilingplane  ;
#line 35 "r_plane.h"
short *lastopening  ;
#line 40 "r_plane.h"
void (*floorfunc)(int top , int bottom )  ;
#line 43 "r_plane.h"
short floorclip[320]  ;
#line 44 "r_plane.h"
short ceilingclip[320]  ;
#line 46 "r_plane.h"
fixed_t yslope[200]  ;
#line 47 "r_plane.h"
fixed_t distscale[320]  ;
#line 45 "r_plane.c"
void (*ceilingfunc)(int top , int bottom )  ;
#line 53 "r_plane.c"
visplane_t visplanes[128]  ;
#line 54 "r_plane.c"
visplane_t *lastvisplane  ;
#line 60 "r_plane.c"
short openings[20480]  ;
#line 76 "r_plane.c"
int spanstart[200]  ;
#line 77 "r_plane.c"
int spanstop[200]  ;
#line 82 "r_plane.c"
lighttable_t **planezlight  ;
#line 83 "r_plane.c"
fixed_t planeheight  ;
#line 87 "r_plane.c"
fixed_t basexscale  ;
#line 88 "r_plane.c"
fixed_t baseyscale  ;
#line 90 "r_plane.c"
fixed_t cachedheight[200]  ;
#line 91 "r_plane.c"
fixed_t cacheddistance[200]  ;
#line 92 "r_plane.c"
fixed_t cachedxstep[200]  ;
#line 93 "r_plane.c"
fixed_t cachedystep[200]  ;
#line 101 "r_plane.c"
void R_InitPlanes(void) 
{ 


  {
#line 104
  return;
}
}
#line 120 "r_plane.c"
void R_MapPlane(int y___1 , int x1 , int x2 ) 
{ 
  angle_t angle ;
  fixed_t distance ;
  fixed_t length ;
  unsigned int index___0 ;
  fixed_t tmp ;
  fixed_t tmp___0 ;
  fixed_t tmp___1 ;
  fixed_t tmp___2 ;
  fixed_t tmp___3 ;

  {
#line 132
  if (x2 < x1) {
#line 132
    goto _L___1;
  } else
#line 132
  if (x1 < 0) {
    _L___1: /* CIL Label */ 
#line 132
    goto _L___0;
  } else
#line 132
  if (x2 >= viewwidth) {
    _L___0: /* CIL Label */ 
#line 132
    goto _L;
  } else
#line 132
  if ((unsigned int )y___1 > (unsigned int )viewheight) {
    _L: /* CIL Label */ 
#line 137
    I_Error("R_MapPlane: %i, %i at %i", x1, x2, y___1);
  }
#line 141
  if (planeheight != cachedheight[y___1]) {
#line 143
    cachedheight[y___1] = planeheight;
#line 144
    tmp = FixedMul(planeheight, yslope[y___1]);
#line 144
    cacheddistance[y___1] = tmp;
#line 144
    distance = tmp;
#line 145
    tmp___0 = FixedMul(distance, basexscale);
#line 145
    cachedxstep[y___1] = tmp___0;
#line 145
    ds_xstep = tmp___0;
#line 146
    tmp___1 = FixedMul(distance, baseyscale);
#line 146
    cachedystep[y___1] = tmp___1;
#line 146
    ds_ystep = tmp___1;
  } else {
#line 150
    distance = cacheddistance[y___1];
#line 151
    ds_xstep = cachedxstep[y___1];
#line 152
    ds_ystep = cachedystep[y___1];
  }
#line 155
  length = FixedMul(distance, distscale[x1]);
#line 156
  angle = (viewangle + xtoviewangle[x1]) >> 19;
#line 157
  tmp___2 = FixedMul(*(finecosine + angle), length);
#line 157
  ds_xfrac = viewx + tmp___2;
#line 158
  tmp___3 = FixedMul(finesine[angle], length);
#line 158
  ds_yfrac = - viewy - tmp___3;
#line 160
  if (fixedcolormap) {
#line 161
    ds_colormap = fixedcolormap;
  } else {
#line 164
    index___0 = (unsigned int )(distance >> 20);
#line 166
    if (index___0 >= 128U) {
#line 167
      index___0 = 127U;
    }
#line 169
    ds_colormap = *(planezlight + index___0);
  }
#line 172
  ds_y = y___1;
#line 173
  ds_x1 = x1;
#line 174
  ds_x2 = x2;
#line 177
  (*spanfunc)();
#line 178
  return;
}
}
#line 185 "r_plane.c"
void R_ClearPlanes(void) 
{ 
  int i ;
  angle_t angle ;
  fixed_t tmp ;

  {
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (i < viewwidth)) {
#line 191
      goto while_break;
    }
#line 193
    floorclip[i] = (short )viewheight;
#line 194
    ceilingclip[i] = (short)-1;
#line 191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  lastvisplane = visplanes;
#line 198
  lastopening = openings;
#line 201
  memset((void *)(cachedheight), 0, (size_t )sizeof(cachedheight));
#line 204
  angle = (viewangle - 1073741824U) >> 19;
#line 207
  basexscale = FixedDiv(*(finecosine + angle), centerxfrac);
#line 208
  tmp = FixedDiv(finesine[angle], centerxfrac);
#line 208
  baseyscale = - tmp;
#line 209
  return;
}
}
#line 217 "r_plane.c"
visplane_t *R_FindPlane(fixed_t height , int picnum , int lightlevel ) 
{ 
  visplane_t *check ;

  {
#line 225
  if (picnum == skyflatnum) {
#line 227
    height = 0;
#line 228
    lightlevel = 0;
  }
#line 231
  check = visplanes;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! ((unsigned long )check < (unsigned long )lastvisplane)) {
#line 231
      goto while_break;
    }
#line 233
    if (height == check->height) {
#line 233
      if (picnum == check->picnum) {
#line 233
        if (lightlevel == check->lightlevel) {
#line 237
          goto while_break;
        } else {
#line 233
          goto _L___0;
        }
      } else {
#line 233
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
#line 231
    check ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  if ((unsigned long )check < (unsigned long )lastvisplane) {
#line 243
    return (check);
  }
#line 245
  if (lastvisplane - visplanes == 128L) {
#line 246
    I_Error("R_FindPlane: no more visplanes");
  }
#line 248
  lastvisplane ++;
#line 250
  check->height = height;
#line 251
  check->picnum = picnum;
#line 252
  check->lightlevel = lightlevel;
#line 253
  check->minx = 320;
#line 254
  check->maxx = -1;
#line 256
  memset((void *)(check->top), 0xff, (size_t )sizeof(check->top));
#line 258
  return (check);
}
}
#line 265 "r_plane.c"
visplane_t *R_CheckPlane(visplane_t *pl , int start , int stop ) 
{ 
  int intrl ;
  int intrh ;
  int unionl ;
  int unionh ;
  int x___0 ;
  visplane_t *tmp ;

  {
#line 277
  if (start < pl->minx) {
#line 279
    intrl = pl->minx;
#line 280
    unionl = start;
  } else {
#line 284
    unionl = pl->minx;
#line 285
    intrl = start;
  }
#line 288
  if (stop > pl->maxx) {
#line 290
    intrh = pl->maxx;
#line 291
    unionh = stop;
  } else {
#line 295
    unionh = pl->maxx;
#line 296
    intrh = stop;
  }
#line 299
  x___0 = intrl;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! (x___0 <= intrh)) {
#line 299
      goto while_break;
    }
#line 300
    if ((int )pl->top[x___0] != 0xff) {
#line 301
      goto while_break;
    }
#line 299
    x___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  if (x___0 > intrh) {
#line 305
    pl->minx = unionl;
#line 306
    pl->maxx = unionh;
#line 309
    return (pl);
  }
#line 313
  lastvisplane->height = pl->height;
#line 314
  lastvisplane->picnum = pl->picnum;
#line 315
  lastvisplane->lightlevel = pl->lightlevel;
#line 317
  tmp = lastvisplane;
#line 317
  lastvisplane ++;
#line 317
  pl = tmp;
#line 318
  pl->minx = start;
#line 319
  pl->maxx = stop;
#line 321
  memset((void *)(pl->top), 0xff, (size_t )sizeof(pl->top));
#line 323
  return (pl);
}
}
#line 330 "r_plane.c"
void R_MakeSpans(int x___0 , int t1 , int b1 , int t2 , int b2 ) 
{ 


  {
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (t1 < t2) {
#line 338
      if (! (t1 <= b1)) {
#line 338
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 338
      goto while_break;
    }
#line 340
    R_MapPlane(t1, spanstart[t1], x___0 - 1);
#line 341
    t1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 343
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 343
    if (b1 > b2) {
#line 343
      if (! (b1 >= t1)) {
#line 343
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 343
      goto while_break___0;
    }
#line 345
    R_MapPlane(b1, spanstart[b1], x___0 - 1);
#line 346
    b1 --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 349
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 349
    if (t2 < t1) {
#line 349
      if (! (t2 <= b2)) {
#line 349
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 349
      goto while_break___1;
    }
#line 351
    spanstart[t2] = x___0;
#line 352
    t2 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 354
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 354
    if (b2 > b1) {
#line 354
      if (! (b2 >= t2)) {
#line 354
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 354
      goto while_break___2;
    }
#line 356
    spanstart[b2] = x___0;
#line 357
    b2 --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 359
  return;
}
}
#line 367 "r_plane.c"
void R_DrawPlanes(void) 
{ 
  visplane_t *pl ;
  int light ;
  int x___0 ;
  int stop ;
  int angle ;
  void *tmp ;

  {
#line 376
  if (ds_p - drawsegs > 256L) {
#line 377
    I_Error("R_DrawPlanes: drawsegs overflow (%i)", ds_p - drawsegs);
  }
#line 380
  if (lastvisplane - visplanes > 128L) {
#line 381
    I_Error("R_DrawPlanes: visplane overflow (%i)", lastvisplane - visplanes);
  }
#line 384
  if (lastopening - openings > 20480L) {
#line 385
    I_Error("R_DrawPlanes: opening overflow (%i)", lastopening - openings);
  }
#line 389
  pl = visplanes;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! ((unsigned long )pl < (unsigned long )lastvisplane)) {
#line 389
      goto while_break;
    }
#line 391
    if (pl->minx > pl->maxx) {
#line 392
      goto __Cont;
    }
#line 396
    if (pl->picnum == skyflatnum) {
#line 398
      dc_iscale = pspriteiscale >> detailshift;
#line 404
      dc_colormap = colormaps;
#line 405
      dc_texturemid = skytexturemid;
#line 406
      x___0 = pl->minx;
      {
#line 406
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 406
        if (! (x___0 <= pl->maxx)) {
#line 406
          goto while_break___0;
        }
#line 408
        dc_yl = (int )pl->top[x___0];
#line 409
        dc_yh = (int )pl->bottom[x___0];
#line 411
        if (dc_yl <= dc_yh) {
#line 413
          angle = (int )((viewangle + xtoviewangle[x___0]) >> 22);
#line 414
          dc_x = x___0;
#line 415
          dc_source = R_GetColumn(skytexture, angle);
#line 416
          (*colfunc)();
        }
#line 406
        x___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 419
      goto __Cont;
    }
#line 423
    tmp = W_CacheLumpNum(firstflat + *(flattranslation + pl->picnum), 1);
#line 423
    ds_source = (byte *)tmp;
#line 427
    planeheight = abs(pl->height - viewz);
#line 428
    light = (pl->lightlevel >> 4) + extralight;
#line 430
    if (light >= 16) {
#line 431
      light = 15;
    }
#line 433
    if (light < 0) {
#line 434
      light = 0;
    }
#line 436
    planezlight = zlight[light];
#line 438
    pl->top[pl->maxx + 1] = (byte )0xff;
#line 439
    pl->top[pl->minx - 1] = (byte )0xff;
#line 441
    stop = pl->maxx + 1;
#line 443
    x___0 = pl->minx;
    {
#line 443
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 443
      if (! (x___0 <= stop)) {
#line 443
        goto while_break___1;
      }
#line 445
      R_MakeSpans(x___0, (int )pl->top[x___0 - 1], (int )pl->bottom[x___0 - 1], (int )pl->top[x___0],
                  (int )pl->bottom[x___0]);
#line 443
      x___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 451
    if (((memblock_t *)(ds_source - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 451
      I_Error("Z_CT at r_plane.c:%i", 451);
    }
#line 451
    Z_ChangeTag2((void *)ds_source, 101);
    __Cont: /* CIL Label */ 
#line 389
    pl ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  return;
}
}
#line 25 "r_segs.c"
static char const   rcsid___46[49]  = 
#line 25 "r_segs.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'_',      (char const   )'s', 
        (char const   )'e',      (char const   )'g',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'3',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'1',      (char const   )'/', 
        (char const   )'2',      (char const   )'9',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'1',      (char const   )'9',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 118 "r_state.h"
fixed_t rw_distance  ;
#line 119 "r_state.h"
angle_t rw_normalangle  ;
#line 124 "r_state.h"
int rw_angle1  ;
#line 37 "r_bsp.h"
int rw_x  ;
#line 38 "r_bsp.h"
int rw_stopx  ;
#line 40 "r_bsp.h"
boolean segtextured  ;
#line 43 "r_bsp.h"
boolean markfloor  ;
#line 44 "r_bsp.h"
boolean markceiling  ;
#line 52 "r_segs.c"
boolean maskedtexture  ;
#line 53 "r_segs.c"
int toptexture  ;
#line 54 "r_segs.c"
int bottomtexture  ;
#line 55 "r_segs.c"
int midtexture  ;
#line 67 "r_segs.c"
angle_t rw_centerangle  ;
#line 68 "r_segs.c"
fixed_t rw_offset  ;
#line 70 "r_segs.c"
fixed_t rw_scale  ;
#line 71 "r_segs.c"
fixed_t rw_scalestep  ;
#line 72 "r_segs.c"
fixed_t rw_midtexturemid  ;
#line 73 "r_segs.c"
fixed_t rw_toptexturemid  ;
#line 74 "r_segs.c"
fixed_t rw_bottomtexturemid  ;
#line 76 "r_segs.c"
int worldtop  ;
#line 77 "r_segs.c"
int worldbottom  ;
#line 78 "r_segs.c"
int worldhigh  ;
#line 79 "r_segs.c"
int worldlow  ;
#line 81 "r_segs.c"
fixed_t pixhigh  ;
#line 82 "r_segs.c"
fixed_t pixlow  ;
#line 83 "r_segs.c"
fixed_t pixhighstep  ;
#line 84 "r_segs.c"
fixed_t pixlowstep  ;
#line 86 "r_segs.c"
fixed_t topfrac  ;
#line 87 "r_segs.c"
fixed_t topstep  ;
#line 89 "r_segs.c"
fixed_t bottomfrac  ;
#line 90 "r_segs.c"
fixed_t bottomstep  ;
#line 93 "r_segs.c"
lighttable_t **walllights  ;
#line 95 "r_segs.c"
short *maskedtexturecol  ;
#line 102 "r_segs.c"
void R_RenderMaskedSegRange(drawseg_t *ds , int x1 , int x2 ) 
{ 
  unsigned int index___0 ;
  column_t *col ;
  int lightnum ;
  int texnum ;
  fixed_t tmp ;
  byte *tmp___0 ;

  {
#line 117
  curline = ds->curline;
#line 118
  frontsector = curline->frontsector;
#line 119
  backsector = curline->backsector;
#line 120
  texnum = *(texturetranslation + (curline->sidedef)->midtexture);
#line 122
  lightnum = ((int )frontsector->lightlevel >> 4) + extralight;
#line 124
  if ((curline->v1)->y == (curline->v2)->y) {
#line 125
    lightnum --;
  } else
#line 126
  if ((curline->v1)->x == (curline->v2)->x) {
#line 127
    lightnum ++;
  }
#line 129
  if (lightnum < 0) {
#line 130
    walllights = scalelight[0];
  } else
#line 131
  if (lightnum >= 16) {
#line 132
    walllights = scalelight[15];
  } else {
#line 134
    walllights = scalelight[lightnum];
  }
#line 136
  maskedtexturecol = ds->maskedtexturecol;
#line 138
  rw_scalestep = ds->scalestep;
#line 139
  spryscale = ds->scale1 + (x1 - ds->x1) * rw_scalestep;
#line 140
  mfloorclip = ds->sprbottomclip;
#line 141
  mceilingclip = ds->sprtopclip;
#line 144
  if ((int )(curline->linedef)->flags & 16) {
#line 146
    if (frontsector->floorheight > backsector->floorheight) {
#line 146
      dc_texturemid = frontsector->floorheight;
    } else {
#line 146
      dc_texturemid = backsector->floorheight;
    }
#line 148
    dc_texturemid = (dc_texturemid + *(textureheight + texnum)) - viewz;
  } else {
#line 152
    if (frontsector->ceilingheight < backsector->ceilingheight) {
#line 152
      dc_texturemid = frontsector->ceilingheight;
    } else {
#line 152
      dc_texturemid = backsector->ceilingheight;
    }
#line 154
    dc_texturemid -= viewz;
  }
#line 156
  dc_texturemid += (curline->sidedef)->rowoffset;
#line 158
  if (fixedcolormap) {
#line 159
    dc_colormap = fixedcolormap;
  }
#line 162
  dc_x = x1;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (dc_x <= x2)) {
#line 162
      goto while_break;
    }
#line 165
    if ((int )*(maskedtexturecol + dc_x) != 0x7fff) {
#line 167
      if (! fixedcolormap) {
#line 169
        index___0 = (unsigned int )(spryscale >> 12);
#line 171
        if (index___0 >= 48U) {
#line 172
          index___0 = 47U;
        }
#line 174
        dc_colormap = *(walllights + index___0);
      }
#line 177
      tmp = FixedMul(dc_texturemid, spryscale);
#line 177
      sprtopscreen = centeryfrac - tmp;
#line 178
      dc_iscale = (fixed_t )(0xffffffffu / (unsigned int )spryscale);
#line 181
      tmp___0 = R_GetColumn(texnum, (int )*(maskedtexturecol + dc_x));
#line 181
      col = (column_t *)(tmp___0 - 3);
#line 184
      R_DrawMaskedColumn(col);
#line 185
      *(maskedtexturecol + dc_x) = (short)32767;
    }
#line 187
    spryscale += rw_scalestep;
#line 162
    dc_x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 206 "r_segs.c"
void R_RenderSegLoop(void) 
{ 
  angle_t angle ;
  unsigned int index___0 ;
  int yl ;
  int yh ;
  int mid ;
  fixed_t texturecolumn ;
  int top ;
  int bottom ;
  fixed_t tmp ;

  {
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (rw_x < rw_stopx)) {
#line 219
      goto while_break;
    }
#line 222
    yl = ((topfrac + (1 << 12)) - 1) >> 12;
#line 225
    if (yl < (int )ceilingclip[rw_x] + 1) {
#line 226
      yl = (int )ceilingclip[rw_x] + 1;
    }
#line 228
    if (markceiling) {
#line 230
      top = (int )ceilingclip[rw_x] + 1;
#line 231
      bottom = yl - 1;
#line 233
      if (bottom >= (int )floorclip[rw_x]) {
#line 234
        bottom = (int )floorclip[rw_x] - 1;
      }
#line 236
      if (top <= bottom) {
#line 238
        ceilingplane->top[rw_x] = (byte )top;
#line 239
        ceilingplane->bottom[rw_x] = (byte )bottom;
      }
    }
#line 243
    yh = bottomfrac >> 12;
#line 245
    if (yh >= (int )floorclip[rw_x]) {
#line 246
      yh = (int )floorclip[rw_x] - 1;
    }
#line 248
    if (markfloor) {
#line 250
      top = yh + 1;
#line 251
      bottom = (int )floorclip[rw_x] - 1;
#line 252
      if (top <= (int )ceilingclip[rw_x]) {
#line 253
        top = (int )ceilingclip[rw_x] + 1;
      }
#line 254
      if (top <= bottom) {
#line 256
        floorplane->top[rw_x] = (byte )top;
#line 257
        floorplane->bottom[rw_x] = (byte )bottom;
      }
    }
#line 262
    if (segtextured) {
#line 265
      angle = (rw_centerangle + xtoviewangle[rw_x]) >> 19;
#line 266
      tmp = FixedMul(finetangent[angle], rw_distance);
#line 266
      texturecolumn = rw_offset - tmp;
#line 267
      texturecolumn >>= 16;
#line 269
      index___0 = (unsigned int )(rw_scale >> 12);
#line 271
      if (index___0 >= 48U) {
#line 272
        index___0 = 47U;
      }
#line 274
      dc_colormap = *(walllights + index___0);
#line 275
      dc_x = rw_x;
#line 276
      dc_iscale = (fixed_t )(0xffffffffu / (unsigned int )rw_scale);
    }
#line 280
    if (midtexture) {
#line 283
      dc_yl = yl;
#line 284
      dc_yh = yh;
#line 285
      dc_texturemid = rw_midtexturemid;
#line 286
      dc_source = R_GetColumn(midtexture, texturecolumn);
#line 287
      (*colfunc)();
#line 288
      ceilingclip[rw_x] = (short )viewheight;
#line 289
      floorclip[rw_x] = (short)-1;
    } else {
#line 294
      if (toptexture) {
#line 297
        mid = pixhigh >> 12;
#line 298
        pixhigh += pixhighstep;
#line 300
        if (mid >= (int )floorclip[rw_x]) {
#line 301
          mid = (int )floorclip[rw_x] - 1;
        }
#line 303
        if (mid >= yl) {
#line 305
          dc_yl = yl;
#line 306
          dc_yh = mid;
#line 307
          dc_texturemid = rw_toptexturemid;
#line 308
          dc_source = R_GetColumn(toptexture, texturecolumn);
#line 309
          (*colfunc)();
#line 310
          ceilingclip[rw_x] = (short )mid;
        } else {
#line 313
          ceilingclip[rw_x] = (short )(yl - 1);
        }
      } else
#line 318
      if (markceiling) {
#line 319
        ceilingclip[rw_x] = (short )(yl - 1);
      }
#line 322
      if (bottomtexture) {
#line 325
        mid = ((pixlow + (1 << 12)) - 1) >> 12;
#line 326
        pixlow += pixlowstep;
#line 329
        if (mid <= (int )ceilingclip[rw_x]) {
#line 330
          mid = (int )ceilingclip[rw_x] + 1;
        }
#line 332
        if (mid <= yh) {
#line 334
          dc_yl = mid;
#line 335
          dc_yh = yh;
#line 336
          dc_texturemid = rw_bottomtexturemid;
#line 337
          dc_source = R_GetColumn(bottomtexture, texturecolumn);
#line 339
          (*colfunc)();
#line 340
          floorclip[rw_x] = (short )mid;
        } else {
#line 343
          floorclip[rw_x] = (short )(yh + 1);
        }
      } else
#line 348
      if (markfloor) {
#line 349
        floorclip[rw_x] = (short )(yh + 1);
      }
#line 352
      if (maskedtexture) {
#line 356
        *(maskedtexturecol + rw_x) = (short )texturecolumn;
      }
    }
#line 360
    rw_scale += rw_scalestep;
#line 361
    topfrac += topstep;
#line 362
    bottomfrac += bottomstep;
#line 219
    rw_x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  return;
}
}
#line 374 "r_segs.c"
void R_StoreWallRange(int start , int stop ) 
{ 
  fixed_t hyp ;
  fixed_t sineval ;
  angle_t distangle ;
  angle_t offsetangle ;
  fixed_t vtop ;
  int lightnum ;
  int tmp ;
  short *tmp___0 ;
  fixed_t tmp___1 ;
  fixed_t tmp___2 ;
  fixed_t tmp___3 ;
  fixed_t tmp___4 ;
  fixed_t tmp___5 ;
  fixed_t tmp___6 ;
  fixed_t tmp___7 ;
  fixed_t tmp___8 ;

  {
#line 386
  if ((unsigned long )ds_p == (unsigned long )(& drawsegs[256])) {
#line 387
    return;
  }
#line 390
  if (start >= viewwidth) {
#line 390
    goto _L;
  } else
#line 390
  if (start > stop) {
    _L: /* CIL Label */ 
#line 391
    I_Error("Bad R_RenderWallRange: %i to %i", start, stop);
  }
#line 394
  sidedef = curline->sidedef;
#line 395
  linedef = curline->linedef;
#line 398
  linedef->flags = (short )((int )linedef->flags | 256);
#line 401
  rw_normalangle = curline->angle + 1073741824U;
#line 402
  tmp = abs((int )(rw_normalangle - (angle_t )rw_angle1));
#line 402
  offsetangle = (angle_t )tmp;
#line 404
  if (offsetangle > 1073741824U) {
#line 405
    offsetangle = (angle_t )0x40000000;
  }
#line 407
  distangle = 1073741824U - offsetangle;
#line 408
  hyp = R_PointToDist((curline->v1)->x, (curline->v1)->y);
#line 409
  sineval = finesine[distangle >> 19];
#line 410
  rw_distance = FixedMul(hyp, sineval);
#line 413
  rw_x = start;
#line 413
  ds_p->x1 = rw_x;
#line 414
  ds_p->x2 = stop;
#line 415
  ds_p->curline = curline;
#line 416
  rw_stopx = stop + 1;
#line 419
  rw_scale = R_ScaleFromGlobalAngle(viewangle + xtoviewangle[start]);
#line 419
  ds_p->scale1 = rw_scale;
#line 422
  if (stop > start) {
#line 424
    ds_p->scale2 = R_ScaleFromGlobalAngle(viewangle + xtoviewangle[stop]);
#line 425
    rw_scalestep = (ds_p->scale2 - rw_scale) / (stop - start);
#line 425
    ds_p->scalestep = rw_scalestep;
  } else {
#line 445
    ds_p->scale2 = ds_p->scale1;
  }
#line 450
  worldtop = frontsector->ceilingheight - viewz;
#line 451
  worldbottom = frontsector->floorheight - viewz;
#line 453
  maskedtexture = (boolean )0;
#line 453
  bottomtexture = (int )maskedtexture;
#line 453
  toptexture = bottomtexture;
#line 453
  midtexture = toptexture;
#line 454
  ds_p->maskedtexturecol = (short *)((void *)0);
#line 456
  if (! backsector) {
#line 459
    midtexture = *(texturetranslation + sidedef->midtexture);
#line 461
    markceiling = (boolean )1;
#line 461
    markfloor = markceiling;
#line 462
    if ((int )linedef->flags & 16) {
#line 464
      vtop = frontsector->floorheight + *(textureheight + sidedef->midtexture);
#line 467
      rw_midtexturemid = vtop - viewz;
    } else {
#line 472
      rw_midtexturemid = worldtop;
    }
#line 474
    rw_midtexturemid += sidedef->rowoffset;
#line 476
    ds_p->silhouette = 3;
#line 477
    ds_p->sprtopclip = screenheightarray;
#line 478
    ds_p->sprbottomclip = negonearray;
#line 479
    ds_p->bsilheight = 0x7fffffff;
#line 480
    ds_p->tsilheight = (-0x7FFFFFFF-1);
  } else {
#line 485
    tmp___0 = (short *)((void *)0);
#line 485
    ds_p->sprbottomclip = tmp___0;
#line 485
    ds_p->sprtopclip = tmp___0;
#line 486
    ds_p->silhouette = 0;
#line 488
    if (frontsector->floorheight > backsector->floorheight) {
#line 490
      ds_p->silhouette = 1;
#line 491
      ds_p->bsilheight = frontsector->floorheight;
    } else
#line 493
    if (backsector->floorheight > viewz) {
#line 495
      ds_p->silhouette = 1;
#line 496
      ds_p->bsilheight = 0x7fffffff;
    }
#line 500
    if (frontsector->ceilingheight < backsector->ceilingheight) {
#line 502
      ds_p->silhouette |= 2;
#line 503
      ds_p->tsilheight = frontsector->ceilingheight;
    } else
#line 505
    if (backsector->ceilingheight < viewz) {
#line 507
      ds_p->silhouette |= 2;
#line 508
      ds_p->tsilheight = (-0x7FFFFFFF-1);
    }
#line 512
    if (backsector->ceilingheight <= frontsector->floorheight) {
#line 514
      ds_p->sprbottomclip = negonearray;
#line 515
      ds_p->bsilheight = 0x7fffffff;
#line 516
      ds_p->silhouette |= 1;
    }
#line 519
    if (backsector->floorheight >= frontsector->ceilingheight) {
#line 521
      ds_p->sprtopclip = screenheightarray;
#line 522
      ds_p->tsilheight = (-0x7FFFFFFF-1);
#line 523
      ds_p->silhouette |= 2;
    }
#line 526
    worldhigh = backsector->ceilingheight - viewz;
#line 527
    worldlow = backsector->floorheight - viewz;
#line 530
    if ((int )frontsector->ceilingpic == skyflatnum) {
#line 530
      if ((int )backsector->ceilingpic == skyflatnum) {
#line 533
        worldtop = worldhigh;
      } else {
#line 530
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 537
    if (worldlow != worldbottom) {
#line 537
      goto _L___2;
    } else
#line 537
    if ((int )backsector->floorpic != (int )frontsector->floorpic) {
      _L___2: /* CIL Label */ 
#line 537
      goto _L___1;
    } else
#line 537
    if ((int )backsector->lightlevel != (int )frontsector->lightlevel) {
      _L___1: /* CIL Label */ 
#line 541
      markfloor = (boolean )1;
    } else {
#line 546
      markfloor = (boolean )0;
    }
#line 550
    if (worldhigh != worldtop) {
#line 550
      goto _L___4;
    } else
#line 550
    if ((int )backsector->ceilingpic != (int )frontsector->ceilingpic) {
      _L___4: /* CIL Label */ 
#line 550
      goto _L___3;
    } else
#line 550
    if ((int )backsector->lightlevel != (int )frontsector->lightlevel) {
      _L___3: /* CIL Label */ 
#line 554
      markceiling = (boolean )1;
    } else {
#line 559
      markceiling = (boolean )0;
    }
#line 562
    if (backsector->ceilingheight <= frontsector->floorheight) {
#line 562
      goto _L___5;
    } else
#line 562
    if (backsector->floorheight >= frontsector->ceilingheight) {
      _L___5: /* CIL Label */ 
#line 566
      markfloor = (boolean )1;
#line 566
      markceiling = markfloor;
    }
#line 570
    if (worldhigh < worldtop) {
#line 573
      toptexture = *(texturetranslation + sidedef->toptexture);
#line 574
      if ((int )linedef->flags & 8) {
#line 577
        rw_toptexturemid = worldtop;
      } else {
#line 581
        vtop = backsector->ceilingheight + *(textureheight + sidedef->toptexture);
#line 586
        rw_toptexturemid = vtop - viewz;
      }
    }
#line 589
    if (worldlow > worldbottom) {
#line 592
      bottomtexture = *(texturetranslation + sidedef->bottomtexture);
#line 594
      if ((int )linedef->flags & 16) {
#line 598
        rw_bottomtexturemid = worldtop;
      } else {
#line 601
        rw_bottomtexturemid = worldlow;
      }
    }
#line 603
    rw_toptexturemid += sidedef->rowoffset;
#line 604
    rw_bottomtexturemid += sidedef->rowoffset;
#line 607
    if (sidedef->midtexture) {
#line 610
      maskedtexture = (boolean )1;
#line 611
      maskedtexturecol = lastopening - rw_x;
#line 611
      ds_p->maskedtexturecol = maskedtexturecol;
#line 612
      lastopening += rw_stopx - rw_x;
    }
  }
#line 617
  segtextured = (boolean )((unsigned int )((midtexture | toptexture) | bottomtexture) | (unsigned int )maskedtexture);
#line 619
  if (segtextured) {
#line 621
    offsetangle = rw_normalangle - (angle_t )rw_angle1;
#line 623
    if (offsetangle > 0x80000000) {
#line 624
      offsetangle = - offsetangle;
    }
#line 626
    if (offsetangle > 1073741824U) {
#line 627
      offsetangle = (angle_t )0x40000000;
    }
#line 629
    sineval = finesine[offsetangle >> 19];
#line 630
    rw_offset = FixedMul(hyp, sineval);
#line 632
    if (rw_normalangle - (angle_t )rw_angle1 < 0x80000000) {
#line 633
      rw_offset = - rw_offset;
    }
#line 635
    rw_offset += sidedef->textureoffset + curline->offset;
#line 636
    rw_centerangle = (1073741824U + viewangle) - rw_normalangle;
#line 642
    if (! fixedcolormap) {
#line 644
      lightnum = ((int )frontsector->lightlevel >> 4) + extralight;
#line 646
      if ((curline->v1)->y == (curline->v2)->y) {
#line 647
        lightnum --;
      } else
#line 648
      if ((curline->v1)->x == (curline->v2)->x) {
#line 649
        lightnum ++;
      }
#line 651
      if (lightnum < 0) {
#line 652
        walllights = scalelight[0];
      } else
#line 653
      if (lightnum >= 16) {
#line 654
        walllights = scalelight[15];
      } else {
#line 656
        walllights = scalelight[lightnum];
      }
    }
  }
#line 665
  if (frontsector->floorheight >= viewz) {
#line 668
    markfloor = (boolean )0;
  }
#line 671
  if (frontsector->ceilingheight <= viewz) {
#line 671
    if ((int )frontsector->ceilingpic != skyflatnum) {
#line 675
      markceiling = (boolean )0;
    } else {
#line 671
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ ;
  }
#line 680
  worldtop >>= 4;
#line 681
  worldbottom >>= 4;
#line 683
  tmp___1 = FixedMul(rw_scalestep, worldtop);
#line 683
  topstep = - tmp___1;
#line 684
  tmp___2 = FixedMul(worldtop, rw_scale);
#line 684
  topfrac = (centeryfrac >> 4) - tmp___2;
#line 686
  tmp___3 = FixedMul(rw_scalestep, worldbottom);
#line 686
  bottomstep = - tmp___3;
#line 687
  tmp___4 = FixedMul(worldbottom, rw_scale);
#line 687
  bottomfrac = (centeryfrac >> 4) - tmp___4;
#line 689
  if (backsector) {
#line 691
    worldhigh >>= 4;
#line 692
    worldlow >>= 4;
#line 694
    if (worldhigh < worldtop) {
#line 696
      tmp___5 = FixedMul(worldhigh, rw_scale);
#line 696
      pixhigh = (centeryfrac >> 4) - tmp___5;
#line 697
      tmp___6 = FixedMul(rw_scalestep, worldhigh);
#line 697
      pixhighstep = - tmp___6;
    }
#line 700
    if (worldlow > worldbottom) {
#line 702
      tmp___7 = FixedMul(worldlow, rw_scale);
#line 702
      pixlow = (centeryfrac >> 4) - tmp___7;
#line 703
      tmp___8 = FixedMul(rw_scalestep, worldlow);
#line 703
      pixlowstep = - tmp___8;
    }
  }
#line 708
  if (markceiling) {
#line 709
    ceilingplane = R_CheckPlane(ceilingplane, rw_x, rw_stopx - 1);
  }
#line 711
  if (markfloor) {
#line 712
    floorplane = R_CheckPlane(floorplane, rw_x, rw_stopx - 1);
  }
#line 714
  R_RenderSegLoop();
#line 718
  if (ds_p->silhouette & 2) {
#line 718
    goto _L___8;
  } else
#line 718
  if (maskedtexture) {
    _L___8: /* CIL Label */ 
#line 718
    if (! ds_p->sprtopclip) {
#line 721
      memcpy((void * __restrict  )lastopening, (void const   * __restrict  )(ceilingclip + start),
             (size_t )(2 * (rw_stopx - start)));
#line 722
      ds_p->sprtopclip = lastopening - start;
#line 723
      lastopening += rw_stopx - start;
    } else {
#line 718
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ ;
  }
#line 726
  if (ds_p->silhouette & 1) {
#line 726
    goto _L___10;
  } else
#line 726
  if (maskedtexture) {
    _L___10: /* CIL Label */ 
#line 726
    if (! ds_p->sprbottomclip) {
#line 729
      memcpy((void * __restrict  )lastopening, (void const   * __restrict  )(floorclip + start),
             (size_t )(2 * (rw_stopx - start)));
#line 730
      ds_p->sprbottomclip = lastopening - start;
#line 731
      lastopening += rw_stopx - start;
    } else {
#line 726
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ ;
  }
#line 734
  if (maskedtexture) {
#line 734
    if (! (ds_p->silhouette & 2)) {
#line 736
      ds_p->silhouette |= 2;
#line 737
      ds_p->tsilheight = (-0x7FFFFFFF-1);
    } else {
#line 734
      goto _L___11;
    }
  } else {
    _L___11: /* CIL Label */ ;
  }
#line 739
  if (maskedtexture) {
#line 739
    if (! (ds_p->silhouette & 1)) {
#line 741
      ds_p->silhouette |= 1;
#line 742
      ds_p->bsilheight = 0x7fffffff;
    } else {
#line 739
      goto _L___12;
    }
  } else {
    _L___12: /* CIL Label */ ;
  }
#line 744
  ds_p ++;
#line 745
  return;
}
}
#line 28 "r_sky.c"
static char const   rcsid___47[49]  = 
#line 28 "r_sky.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'_',      (char const   )'b', 
        (char const   )'b',      (char const   )'o',      (char const   )'x',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 37 "r_sky.h"
int skytexture  ;
#line 38 "r_sky.h"
int skytexturemid  ;
#line 47 "r_sky.c"
int skyflatnum  ;
#line 57 "r_sky.c"
void R_InitSkyMap(void) 
{ 


  {
#line 60
  skytexturemid = 100 * (1 << 16);
#line 61
  return;
}
}
#line 25 "r_things.c"
static char const   rcsid___48[51]  = 
#line 25 "r_things.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'_',      (char const   )'t', 
        (char const   )'h',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )'s',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )' ',      (char const   )'1',      (char const   )'6',      (char const   )':', 
        (char const   )'4',      (char const   )'7',      (char const   )':',      (char const   )'5', 
        (char const   )'6',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 75 "r_state.h"
int numsprites  ;
#line 76 "r_state.h"
spritedef_t *sprites  ;
#line 33 "r_things.h"
vissprite_t vissprites[128]  ;
#line 34 "r_things.h"
vissprite_t *vissprite_p  ;
#line 35 "r_things.h"
vissprite_t vsprsortedhead  ;
#line 39 "r_things.h"
short negonearray[320]  ;
#line 40 "r_things.h"
short screenheightarray[320]  ;
#line 43 "r_things.h"
short *mfloorclip  ;
#line 44 "r_things.h"
short *mceilingclip  ;
#line 45 "r_things.h"
fixed_t spryscale  ;
#line 46 "r_things.h"
fixed_t sprtopscreen  ;
#line 48 "r_things.h"
fixed_t pspritescale  ;
#line 49 "r_things.h"
fixed_t pspriteiscale  ;
#line 77 "r_things.c"
lighttable_t **spritelights  ;
#line 94 "r_things.c"
spriteframe_t sprtemp[29]  ;
#line 95 "r_things.c"
int maxframe  ;
#line 96 "r_things.c"
char *spritename  ;
#line 105 "r_things.c"
void R_InstallSpriteLump(int lump , unsigned int frame , unsigned int rotation , boolean flipped ) 
{ 
  int r ;

  {
#line 114
  if (frame >= 29U) {
#line 114
    goto _L;
  } else
#line 114
  if (rotation > 8U) {
    _L: /* CIL Label */ 
#line 115
    I_Error("R_InstallSpriteLump: Bad frame characters in lump %i", lump);
  }
#line 118
  if ((int )frame > maxframe) {
#line 119
    maxframe = (int )frame;
  }
#line 121
  if (rotation == 0U) {
#line 124
    if ((unsigned int )sprtemp[frame].rotate == 0U) {
#line 125
      I_Error("R_InitSprites: Sprite %s frame %c has multip rot=0 lump", spritename,
              65U + frame);
    }
#line 128
    if ((unsigned int )sprtemp[frame].rotate == 1U) {
#line 129
      I_Error("R_InitSprites: Sprite %s frame %c has rotations and a rot=0 lump",
              spritename, 65U + frame);
    }
#line 132
    sprtemp[frame].rotate = (boolean )0;
#line 133
    r = 0;
    {
#line 133
    while (1) {
      while_continue: /* CIL Label */ ;
#line 133
      if (! (r < 8)) {
#line 133
        goto while_break;
      }
#line 135
      sprtemp[frame].lump[r] = (short )(lump - firstspritelump);
#line 136
      sprtemp[frame].flip[r] = (byte )flipped;
#line 133
      r ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 138
    return;
  }
#line 142
  if ((unsigned int )sprtemp[frame].rotate == 0U) {
#line 143
    I_Error("R_InitSprites: Sprite %s frame %c has rotations and a rot=0 lump", spritename,
            65U + frame);
  }
#line 146
  sprtemp[frame].rotate = (boolean )1;
#line 149
  rotation --;
#line 150
  if ((int )sprtemp[frame].lump[rotation] != -1) {
#line 151
    I_Error("R_InitSprites: Sprite %s : %c : %c has two lumps mapped to it", spritename,
            65U + frame, 49U + rotation);
  }
#line 155
  sprtemp[frame].lump[rotation] = (short )(lump - firstspritelump);
#line 156
  sprtemp[frame].flip[rotation] = (byte )flipped;
#line 157
  return;
}
}
#line 177 "r_things.c"
void R_InitSpriteDefs(char **namelist ) 
{ 
  char **check ;
  int i ;
  int l___0 ;
  int intname ;
  int frame ;
  int rotation ;
  int start ;
  int end ;
  int patched ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 190
  check = namelist;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )*check != (unsigned long )((void *)0))) {
#line 191
      goto while_break;
    }
#line 192
    check ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  numsprites = (int )(check - namelist);
#line 196
  if (! numsprites) {
#line 197
    return;
  }
#line 199
  tmp = Z_Malloc((int )((unsigned long )numsprites * sizeof(*sprites)), 1, (void *)0);
#line 199
  sprites = (spritedef_t *)tmp;
#line 201
  start = firstspritelump - 1;
#line 202
  end = lastspritelump + 1;
#line 207
  i = 0;
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 207
    if (! (i < numsprites)) {
#line 207
      goto while_break___0;
    }
#line 209
    spritename = *(namelist + i);
#line 210
    memset((void *)(sprtemp), -1, (size_t )sizeof(sprtemp));
#line 212
    maxframe = -1;
#line 213
    intname = *((int *)*(namelist + i));
#line 217
    l___0 = start + 1;
    {
#line 217
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 217
      if (! (l___0 < end)) {
#line 217
        goto while_break___1;
      }
#line 219
      if (*((int *)((lumpinfo + l___0)->name)) == intname) {
#line 221
        frame = (int )(lumpinfo + l___0)->name[4] - 65;
#line 222
        rotation = (int )(lumpinfo + l___0)->name[5] - 48;
#line 224
        if (modifiedgame) {
#line 225
          patched = W_GetNumForName((lumpinfo + l___0)->name);
        } else {
#line 227
          patched = l___0;
        }
#line 229
        R_InstallSpriteLump(patched, (unsigned int )frame, (unsigned int )rotation,
                            (boolean )0);
#line 231
        if ((lumpinfo + l___0)->name[6]) {
#line 233
          frame = (int )(lumpinfo + l___0)->name[6] - 65;
#line 234
          rotation = (int )(lumpinfo + l___0)->name[7] - 48;
#line 235
          R_InstallSpriteLump(l___0, (unsigned int )frame, (unsigned int )rotation,
                              (boolean )1);
        }
      }
#line 217
      l___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 241
    if (maxframe == -1) {
#line 243
      (sprites + i)->numframes = 0;
#line 244
      goto __Cont;
    }
#line 247
    maxframe ++;
#line 249
    frame = 0;
    {
#line 249
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 249
      if (! (frame < maxframe)) {
#line 249
        goto while_break___2;
      }
      {
#line 253
      if ((int )sprtemp[frame].rotate == -1) {
#line 253
        goto case_neg_1;
      }
#line 259
      if ((int )sprtemp[frame].rotate == 0) {
#line 259
        goto case_0;
      }
#line 263
      if ((int )sprtemp[frame].rotate == 1) {
#line 263
        goto case_1;
      }
#line 251
      goto switch_break;
      case_neg_1: /* CIL Label */ 
#line 255
      I_Error("R_InitSprites: No patches found for %s frame %c", *(namelist + i),
              frame + 65);
#line 257
      goto switch_break;
      case_0: /* CIL Label */ 
#line 261
      goto switch_break;
      case_1: /* CIL Label */ 
#line 265
      rotation = 0;
      {
#line 265
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 265
        if (! (rotation < 8)) {
#line 265
          goto while_break___3;
        }
#line 266
        if ((int )sprtemp[frame].lump[rotation] == -1) {
#line 267
          I_Error("R_InitSprites: Sprite %s frame %c is missing rotations", *(namelist + i),
                  frame + 65);
        }
#line 265
        rotation ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 270
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 249
      frame ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 275
    (sprites + i)->numframes = maxframe;
#line 276
    tmp___0 = Z_Malloc((int )((unsigned long )maxframe * sizeof(spriteframe_t )),
                       1, (void *)0);
#line 276
    (sprites + i)->spriteframes = (spriteframe_t *)tmp___0;
#line 278
    memcpy((void * __restrict  )(sprites + i)->spriteframes, (void const   * __restrict  )(sprtemp),
           (size_t )((unsigned long )maxframe * sizeof(spriteframe_t )));
    __Cont: /* CIL Label */ 
#line 207
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 281
  return;
}
}
#line 291 "r_things.c"
int newvissprite  ;
#line 299 "r_things.c"
void R_InitSprites(char **namelist ) 
{ 
  int i ;

  {
#line 303
  i = 0;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (i < 320)) {
#line 303
      goto while_break;
    }
#line 305
    negonearray[i] = (short)-1;
#line 303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  R_InitSpriteDefs(namelist);
#line 309
  return;
}
}
#line 317 "r_things.c"
void R_ClearSprites(void) 
{ 


  {
#line 319
  vissprite_p = vissprites;
#line 320
  return;
}
}
#line 326 "r_things.c"
vissprite_t overflowsprite  ;
#line 328 "r_things.c"
vissprite_t *R_NewVisSprite(void) 
{ 


  {
#line 330
  if ((unsigned long )vissprite_p == (unsigned long )(& vissprites[128])) {
#line 331
    return (& overflowsprite);
  }
#line 333
  vissprite_p ++;
#line 334
  return (vissprite_p - 1);
}
}
#line 351 "r_things.c"
void R_DrawMaskedColumn(column_t *column ) 
{ 
  int topscreen ;
  int bottomscreen ;
  fixed_t basetexturemid ;

  {
#line 357
  basetexturemid = dc_texturemid;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! ((int )column->topdelta != 0xff)) {
#line 359
      goto while_break;
    }
#line 363
    topscreen = sprtopscreen + spryscale * (fixed_t )column->topdelta;
#line 364
    bottomscreen = topscreen + spryscale * (fixed_t )column->length;
#line 366
    dc_yl = ((topscreen + (1 << 16)) - 1) >> 16;
#line 367
    dc_yh = (bottomscreen - 1) >> 16;
#line 369
    if (dc_yh >= (int )*(mfloorclip + dc_x)) {
#line 370
      dc_yh = (int )*(mfloorclip + dc_x) - 1;
    }
#line 371
    if (dc_yl <= (int )*(mceilingclip + dc_x)) {
#line 372
      dc_yl = (int )*(mceilingclip + dc_x) + 1;
    }
#line 374
    if (dc_yl <= dc_yh) {
#line 376
      dc_source = (byte *)column + 3;
#line 377
      dc_texturemid = basetexturemid - ((int )column->topdelta << 16);
#line 382
      (*colfunc)();
    }
#line 384
    column = (column_t *)(((byte *)column + (int )column->length) + 4);
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  dc_texturemid = basetexturemid;
#line 388
  return;
}
}
#line 396 "r_things.c"
void R_DrawVisSprite(vissprite_t *vis , int x1 , int x2 ) 
{ 
  column_t *column ;
  int texturecolumn ;
  fixed_t frac ;
  patch_t *patch ;
  void *tmp ;
  int tmp___0 ;
  fixed_t tmp___1 ;

  {
#line 408
  tmp = W_CacheLumpNum(vis->patch + firstspritelump, 101);
#line 408
  patch = (patch_t *)tmp;
#line 410
  dc_colormap = vis->colormap;
#line 412
  if (! dc_colormap) {
#line 415
    colfunc = fuzzcolfunc;
  } else
#line 417
  if (vis->mobjflags & 201326592) {
#line 419
    colfunc = & R_DrawTranslatedColumn;
#line 420
    dc_translation = (translationtables - 256) + ((vis->mobjflags & 201326592) >> 18);
  }
#line 424
  tmp___0 = abs(vis->xiscale);
#line 424
  dc_iscale = tmp___0 >> detailshift;
#line 425
  dc_texturemid = vis->texturemid;
#line 426
  frac = vis->startfrac;
#line 427
  spryscale = vis->scale;
#line 428
  tmp___1 = FixedMul(dc_texturemid, spryscale);
#line 428
  sprtopscreen = centeryfrac - tmp___1;
#line 430
  dc_x = vis->x1;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! (dc_x <= vis->x2)) {
#line 430
      goto while_break;
    }
#line 432
    texturecolumn = frac >> 16;
#line 434
    if (texturecolumn < 0) {
#line 434
      goto _L;
    } else
#line 434
    if (texturecolumn >= (int )patch->width) {
      _L: /* CIL Label */ 
#line 435
      I_Error("R_DrawSpriteRange: bad texturecolumn");
    }
#line 437
    column = (column_t *)((byte *)patch + patch->columnofs[texturecolumn]);
#line 439
    R_DrawMaskedColumn(column);
#line 430
    dc_x ++;
#line 430
    frac += vis->xiscale;
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  colfunc = basecolfunc;
#line 443
  return;
}
}
#line 452 "r_things.c"
void R_ProjectSprite(mobj_t *thing ) 
{ 
  fixed_t tr_x ;
  fixed_t tr_y ;
  fixed_t gxt ;
  fixed_t gyt ;
  fixed_t tx ;
  fixed_t tz ;
  fixed_t xscale ;
  int x1 ;
  int x2 ;
  spritedef_t *sprdef ;
  spriteframe_t *sprframe ;
  int lump ;
  unsigned int rot ;
  boolean flip ;
  int index___0 ;
  vissprite_t *vis ;
  angle_t ang ;
  fixed_t iscale ;
  fixed_t tmp ;
  fixed_t tmp___0 ;
  int tmp___1 ;
  fixed_t tmp___2 ;
  fixed_t tmp___3 ;

  {
#line 483
  tr_x = thing->x - viewx;
#line 484
  tr_y = thing->y - viewy;
#line 486
  gxt = FixedMul(tr_x, viewcos);
#line 487
  tmp = FixedMul(tr_y, viewsin);
#line 487
  gyt = - tmp;
#line 489
  tz = gxt - gyt;
#line 492
  if (tz < (1 << 16) * 4) {
#line 493
    return;
  }
#line 495
  xscale = FixedDiv(projection, tz);
#line 497
  tmp___0 = FixedMul(tr_x, viewsin);
#line 497
  gxt = - tmp___0;
#line 498
  gyt = FixedMul(tr_y, viewcos);
#line 499
  tx = - (gyt + gxt);
#line 502
  tmp___1 = abs(tx);
#line 502
  if (tmp___1 > tz << 2) {
#line 503
    return;
  }
#line 507
  if ((unsigned int )thing->sprite >= (unsigned int )numsprites) {
#line 508
    I_Error("R_ProjectSprite: invalid sprite number %i ", (unsigned int )thing->sprite);
  }
#line 511
  sprdef = sprites + thing->sprite;
#line 513
  if ((thing->frame & 0x7fff) >= sprdef->numframes) {
#line 514
    I_Error("R_ProjectSprite: invalid sprite frame %i : %i ", (unsigned int )thing->sprite,
            thing->frame);
  }
#line 517
  sprframe = sprdef->spriteframes + (thing->frame & 0x7fff);
#line 519
  if (sprframe->rotate) {
#line 522
    ang = R_PointToAngle(thing->x, thing->y);
#line 523
    rot = ((ang - thing->angle) + 2415919104U) >> 29;
#line 524
    lump = (int )sprframe->lump[rot];
#line 525
    flip = (boolean )sprframe->flip[rot];
  } else {
#line 530
    lump = (int )sprframe->lump[0];
#line 531
    flip = (boolean )sprframe->flip[0];
  }
#line 535
  tx -= *(spriteoffset + lump);
#line 536
  tmp___2 = FixedMul(tx, xscale);
#line 536
  x1 = (centerxfrac + tmp___2) >> 16;
#line 539
  if (x1 > viewwidth) {
#line 540
    return;
  }
#line 542
  tx += *(spritewidth + lump);
#line 543
  tmp___3 = FixedMul(tx, xscale);
#line 543
  x2 = ((centerxfrac + tmp___3) >> 16) - 1;
#line 546
  if (x2 < 0) {
#line 547
    return;
  }
#line 550
  vis = R_NewVisSprite();
#line 551
  vis->mobjflags = thing->flags;
#line 552
  vis->scale = xscale << detailshift;
#line 553
  vis->gx = thing->x;
#line 554
  vis->gy = thing->y;
#line 555
  vis->gz = thing->z;
#line 556
  vis->gzt = thing->z + *(spritetopoffset + lump);
#line 557
  vis->texturemid = vis->gzt - viewz;
#line 558
  if (x1 < 0) {
#line 558
    vis->x1 = 0;
  } else {
#line 558
    vis->x1 = x1;
  }
#line 559
  if (x2 >= viewwidth) {
#line 559
    vis->x2 = viewwidth - 1;
  } else {
#line 559
    vis->x2 = x2;
  }
#line 560
  iscale = FixedDiv(1 << 16, xscale);
#line 562
  if (flip) {
#line 564
    vis->startfrac = *(spritewidth + lump) - 1;
#line 565
    vis->xiscale = - iscale;
  } else {
#line 569
    vis->startfrac = 0;
#line 570
    vis->xiscale = iscale;
  }
#line 573
  if (vis->x1 > x1) {
#line 574
    vis->startfrac += vis->xiscale * (vis->x1 - x1);
  }
#line 575
  vis->patch = lump;
#line 578
  if (thing->flags & 262144) {
#line 581
    vis->colormap = (lighttable_t *)((void *)0);
  } else
#line 583
  if (fixedcolormap) {
#line 586
    vis->colormap = fixedcolormap;
  } else
#line 588
  if (thing->frame & 0x8000) {
#line 591
    vis->colormap = colormaps;
  } else {
#line 597
    index___0 = xscale >> (12 - detailshift);
#line 599
    if (index___0 >= 48) {
#line 600
      index___0 = 47;
    }
#line 602
    vis->colormap = *(spritelights + index___0);
  }
#line 604
  return;
}
}
#line 613 "r_things.c"
void R_AddSprites(sector_t *sec ) 
{ 
  mobj_t *thing ;
  int lightnum ;

  {
#line 622
  if (sec->validcount == validcount) {
#line 623
    return;
  }
#line 626
  sec->validcount = validcount;
#line 628
  lightnum = ((int )sec->lightlevel >> 4) + extralight;
#line 630
  if (lightnum < 0) {
#line 631
    spritelights = scalelight[0];
  } else
#line 632
  if (lightnum >= 16) {
#line 633
    spritelights = scalelight[15];
  } else {
#line 635
    spritelights = scalelight[lightnum];
  }
#line 638
  thing = sec->thinglist;
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 638
    if (! thing) {
#line 638
      goto while_break;
    }
#line 639
    R_ProjectSprite(thing);
#line 638
    thing = thing->snext;
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  return;
}
}
#line 646 "r_things.c"
void R_DrawPSprite(pspdef_t *psp ) 
{ 
  fixed_t tx ;
  int x1 ;
  int x2 ;
  spritedef_t *sprdef ;
  spriteframe_t *sprframe ;
  int lump ;
  boolean flip ;
  vissprite_t *vis ;
  vissprite_t avis ;
  fixed_t tmp ;
  fixed_t tmp___0 ;

  {
#line 660
  if ((unsigned int )(psp->state)->sprite >= (unsigned int )numsprites) {
#line 661
    I_Error("R_ProjectSprite: invalid sprite number %i ", (unsigned int )(psp->state)->sprite);
  }
#line 664
  sprdef = sprites + (psp->state)->sprite;
#line 666
  if (((psp->state)->frame & 32767L) >= (long )sprdef->numframes) {
#line 667
    I_Error("R_ProjectSprite: invalid sprite frame %i : %i ", (unsigned int )(psp->state)->sprite,
            (psp->state)->frame);
  }
#line 670
  sprframe = sprdef->spriteframes + ((psp->state)->frame & 32767L);
#line 672
  lump = (int )sprframe->lump[0];
#line 673
  flip = (boolean )sprframe->flip[0];
#line 676
  tx = psp->sx - 160 * (1 << 16);
#line 678
  tx -= *(spriteoffset + lump);
#line 679
  tmp = FixedMul(tx, pspritescale);
#line 679
  x1 = (centerxfrac + tmp) >> 16;
#line 682
  if (x1 > viewwidth) {
#line 683
    return;
  }
#line 685
  tx += *(spritewidth + lump);
#line 686
  tmp___0 = FixedMul(tx, pspritescale);
#line 686
  x2 = ((centerxfrac + tmp___0) >> 16) - 1;
#line 689
  if (x2 < 0) {
#line 690
    return;
  }
#line 693
  vis = & avis;
#line 694
  vis->mobjflags = 0;
#line 695
  vis->texturemid = ((100 << 16) + (1 << 16) / 2) - (psp->sy - *(spritetopoffset + lump));
#line 696
  if (x1 < 0) {
#line 696
    vis->x1 = 0;
  } else {
#line 696
    vis->x1 = x1;
  }
#line 697
  if (x2 >= viewwidth) {
#line 697
    vis->x2 = viewwidth - 1;
  } else {
#line 697
    vis->x2 = x2;
  }
#line 698
  vis->scale = pspritescale << detailshift;
#line 700
  if (flip) {
#line 702
    vis->xiscale = - pspriteiscale;
#line 703
    vis->startfrac = *(spritewidth + lump) - 1;
  } else {
#line 707
    vis->xiscale = pspriteiscale;
#line 708
    vis->startfrac = 0;
  }
#line 711
  if (vis->x1 > x1) {
#line 712
    vis->startfrac += vis->xiscale * (vis->x1 - x1);
  }
#line 714
  vis->patch = lump;
#line 716
  if (viewplayer->powers[2] > 128) {
#line 716
    goto _L;
  } else
#line 716
  if (viewplayer->powers[2] & 8) {
    _L: /* CIL Label */ 
#line 720
    vis->colormap = (lighttable_t *)((void *)0);
  } else
#line 722
  if (fixedcolormap) {
#line 725
    vis->colormap = fixedcolormap;
  } else
#line 727
  if ((psp->state)->frame & 32768L) {
#line 730
    vis->colormap = colormaps;
  } else {
#line 735
    vis->colormap = *(spritelights + 47);
  }
#line 738
  R_DrawVisSprite(vis, vis->x1, vis->x2);
#line 739
  return;
}
}
#line 746 "r_things.c"
void R_DrawPlayerSprites(void) 
{ 
  int i ;
  int lightnum ;
  pspdef_t *psp ;

  {
#line 753
  lightnum = ((int )(((viewplayer->mo)->subsector)->sector)->lightlevel >> 4) + extralight;
#line 757
  if (lightnum < 0) {
#line 758
    spritelights = scalelight[0];
  } else
#line 759
  if (lightnum >= 16) {
#line 760
    spritelights = scalelight[15];
  } else {
#line 762
    spritelights = scalelight[lightnum];
  }
#line 765
  mfloorclip = screenheightarray;
#line 766
  mceilingclip = negonearray;
#line 769
  i = 0;
#line 769
  psp = viewplayer->psprites;
  {
#line 769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 769
    if (! (i < 2)) {
#line 769
      goto while_break;
    }
#line 773
    if (psp->state) {
#line 774
      R_DrawPSprite(psp);
    }
#line 769
    i ++;
#line 769
    psp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 776
  return;
}
}
#line 787 "r_things.c"
void R_SortVisSprites(void) 
{ 
  int i ;
  int count ;
  vissprite_t *ds ;
  vissprite_t *best ;
  vissprite_t unsorted ;
  fixed_t bestscale ;

  {
#line 796
  count = (int )(vissprite_p - vissprites);
#line 798
  unsorted.prev = & unsorted;
#line 798
  unsorted.next = unsorted.prev;
#line 800
  if (! count) {
#line 801
    return;
  }
#line 803
  ds = vissprites;
  {
#line 803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 803
    if (! ((unsigned long )ds < (unsigned long )vissprite_p)) {
#line 803
      goto while_break;
    }
#line 805
    ds->next = ds + 1;
#line 806
    ds->prev = ds - 1;
#line 803
    ds ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 809
  vissprites[0].prev = & unsorted;
#line 810
  unsorted.next = & vissprites[0];
#line 811
  (vissprite_p - 1)->next = & unsorted;
#line 812
  unsorted.prev = vissprite_p - 1;
#line 816
  vsprsortedhead.prev = & vsprsortedhead;
#line 816
  vsprsortedhead.next = vsprsortedhead.prev;
#line 817
  i = 0;
  {
#line 817
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 817
    if (! (i < count)) {
#line 817
      goto while_break___0;
    }
#line 819
    bestscale = 0x7fffffff;
#line 820
    ds = unsorted.next;
    {
#line 820
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 820
      if (! ((unsigned long )ds != (unsigned long )(& unsorted))) {
#line 820
        goto while_break___1;
      }
#line 822
      if (ds->scale < bestscale) {
#line 824
        bestscale = ds->scale;
#line 825
        best = ds;
      }
#line 820
      ds = ds->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 828
    (best->next)->prev = best->prev;
#line 829
    (best->prev)->next = best->next;
#line 830
    best->next = & vsprsortedhead;
#line 831
    best->prev = vsprsortedhead.prev;
#line 832
    (vsprsortedhead.prev)->next = best;
#line 833
    vsprsortedhead.prev = best;
#line 817
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 835
  return;
}
}
#line 842 "r_things.c"
void R_DrawSprite(vissprite_t *spr ) 
{ 
  drawseg_t *ds ;
  short clipbot[320] ;
  short cliptop[320] ;
  int x___0 ;
  int r1 ;
  int r2 ;
  fixed_t scale ;
  fixed_t lowscale ;
  int silhouette ;
  short tmp ;
  int tmp___0 ;

  {
#line 854
  x___0 = spr->x1;
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! (x___0 <= spr->x2)) {
#line 854
      goto while_break;
    }
#line 855
    tmp = (short)-2;
#line 855
    cliptop[x___0] = tmp;
#line 855
    clipbot[x___0] = tmp;
#line 854
    x___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  ds = ds_p - 1;
  {
#line 860
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 860
    if (! ((unsigned long )ds >= (unsigned long )(drawsegs))) {
#line 860
      goto while_break___0;
    }
#line 863
    if (ds->x1 > spr->x2) {
#line 863
      goto _L___1;
    } else
#line 863
    if (ds->x2 < spr->x1) {
      _L___1: /* CIL Label */ 
#line 863
      goto _L;
    } else
#line 863
    if (! ds->silhouette) {
#line 863
      if (! ds->maskedtexturecol) {
        _L: /* CIL Label */ 
#line 869
        goto __Cont;
      } else {
#line 863
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 872
    if (ds->x1 < spr->x1) {
#line 872
      r1 = spr->x1;
    } else {
#line 872
      r1 = ds->x1;
    }
#line 873
    if (ds->x2 > spr->x2) {
#line 873
      r2 = spr->x2;
    } else {
#line 873
      r2 = ds->x2;
    }
#line 875
    if (ds->scale1 > ds->scale2) {
#line 877
      lowscale = ds->scale2;
#line 878
      scale = ds->scale1;
    } else {
#line 882
      lowscale = ds->scale1;
#line 883
      scale = ds->scale2;
    }
#line 886
    if (scale < spr->scale) {
#line 886
      goto _L___2;
    } else
#line 886
    if (lowscale < spr->scale) {
#line 886
      tmp___0 = R_PointOnSegSide(spr->gx, spr->gy, ds->curline);
#line 886
      if (tmp___0) {
#line 886
        goto _L___3;
      } else {
        _L___2: /* CIL Label */ 
#line 891
        if (ds->maskedtexturecol) {
#line 892
          R_RenderMaskedSegRange(ds, r1, r2);
        }
#line 894
        goto __Cont;
      }
    } else {
      _L___3: /* CIL Label */ ;
    }
#line 899
    silhouette = ds->silhouette;
#line 901
    if (spr->gz >= ds->bsilheight) {
#line 902
      silhouette &= -2;
    }
#line 904
    if (spr->gzt <= ds->tsilheight) {
#line 905
      silhouette &= -3;
    }
#line 907
    if (silhouette == 1) {
#line 910
      x___0 = r1;
      {
#line 910
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 910
        if (! (x___0 <= r2)) {
#line 910
          goto while_break___1;
        }
#line 911
        if ((int )clipbot[x___0] == -2) {
#line 912
          clipbot[x___0] = *(ds->sprbottomclip + x___0);
        }
#line 910
        x___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 914
    if (silhouette == 2) {
#line 917
      x___0 = r1;
      {
#line 917
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 917
        if (! (x___0 <= r2)) {
#line 917
          goto while_break___2;
        }
#line 918
        if ((int )cliptop[x___0] == -2) {
#line 919
          cliptop[x___0] = *(ds->sprtopclip + x___0);
        }
#line 917
        x___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 921
    if (silhouette == 3) {
#line 924
      x___0 = r1;
      {
#line 924
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 924
        if (! (x___0 <= r2)) {
#line 924
          goto while_break___3;
        }
#line 926
        if ((int )clipbot[x___0] == -2) {
#line 927
          clipbot[x___0] = *(ds->sprbottomclip + x___0);
        }
#line 928
        if ((int )cliptop[x___0] == -2) {
#line 929
          cliptop[x___0] = *(ds->sprtopclip + x___0);
        }
#line 924
        x___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 860
    ds --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 938
  x___0 = spr->x1;
  {
#line 938
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 938
    if (! (x___0 <= spr->x2)) {
#line 938
      goto while_break___4;
    }
#line 940
    if ((int )clipbot[x___0] == -2) {
#line 941
      clipbot[x___0] = (short )viewheight;
    }
#line 943
    if ((int )cliptop[x___0] == -2) {
#line 944
      cliptop[x___0] = (short)-1;
    }
#line 938
    x___0 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 947
  mfloorclip = clipbot;
#line 948
  mceilingclip = cliptop;
#line 949
  R_DrawVisSprite(spr, spr->x1, spr->x2);
#line 950
  return;
}
}
#line 958 "r_things.c"
void R_DrawMasked(void) 
{ 
  vissprite_t *spr ;
  drawseg_t *ds ;

  {
#line 963
  R_SortVisSprites();
#line 965
  if ((unsigned long )vissprite_p > (unsigned long )(vissprites)) {
#line 968
    spr = vsprsortedhead.next;
    {
#line 968
    while (1) {
      while_continue: /* CIL Label */ ;
#line 968
      if (! ((unsigned long )spr != (unsigned long )(& vsprsortedhead))) {
#line 968
        goto while_break;
      }
#line 973
      R_DrawSprite(spr);
#line 968
      spr = spr->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 978
  ds = ds_p - 1;
  {
#line 978
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 978
    if (! ((unsigned long )ds >= (unsigned long )(drawsegs))) {
#line 978
      goto while_break___0;
    }
#line 979
    if (ds->maskedtexturecol) {
#line 980
      R_RenderMaskedSegRange(ds, ds->x1, ds->x2);
    }
#line 978
    ds --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 984
  if (! viewangleoffset) {
#line 985
    R_DrawPlayerSprites();
  }
#line 986
  return;
}
}
#line 25 "w_wad.c"
static char const   rcsid___49[48]  = 
#line 25 "w_wad.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'w',      (char const   )'_',      (char const   )'w', 
        (char const   )'a',      (char const   )'d',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'7',      (char const   )'/', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )' ',      (char const   )'1',      (char const   )'6', 
        (char const   )':',      (char const   )'4',      (char const   )'7',      (char const   )':', 
        (char const   )'5',      (char const   )'7',      (char const   )' ',      (char const   )'b', 
        (char const   )'1',      (char const   )' ',      (char const   )'E',      (char const   )'x', 
        (char const   )'p',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 67 "/usr/include/malloc.h"
extern void *( __attribute__((__leaf__)) memalign)(size_t __alignment , size_t __size )  __attribute__((__nothrow__,
__malloc__(__builtin_free,1), __malloc__, __alloc_size__(2), __alloc_align__(1))) ;
#line 77
extern void *( __attribute__((__leaf__)) pvalloc)(size_t __size )  __attribute__((__nothrow__,
__malloc__(__builtin_free,1), __malloc__)) ;
#line 114
extern struct mallinfo ( __attribute__((__leaf__)) mallinfo)(void)  __attribute__((__nothrow__,
__deprecated__)) ;
#line 117
extern struct mallinfo2 ( __attribute__((__leaf__)) mallinfo2)(void)  __attribute__((__nothrow__)) ;
#line 144
extern int ( __attribute__((__leaf__)) mallopt)(int __param , int __val )  __attribute__((__nothrow__)) ;
#line 148
extern int ( __attribute__((__leaf__)) malloc_trim)(size_t __pad )  __attribute__((__nothrow__)) ;
#line 152
extern size_t ( __attribute__((__leaf__)) malloc_usable_size)(void *__ptr )  __attribute__((__nothrow__)) ;
#line 155
extern void ( __attribute__((__leaf__)) malloc_stats)(void)  __attribute__((__nothrow__)) ;
#line 158
extern int ( __attribute__((__leaf__)) malloc_info)(int __options , FILE *__fp )  __attribute__((__nothrow__)) ;
#line 65 "w_wad.h"
void **lumpcache  ;
#line 66 "w_wad.h"
lumpinfo_t *lumpinfo  ;
#line 67 "w_wad.h"
int numlumps  ;
#line 69 "w_wad.c"
void strupr(char *s ) 
{ 
  int tmp ;

  {
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! *s) {
#line 71
      goto while_break;
    }
#line 71
    tmp = toupper((int )*s);
#line 71
    *s = (char )tmp;
#line 71
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 74 "w_wad.c"
int filelength(int handle ) 
{ 
  struct stat fileinfo ;
  int tmp ;

  {
#line 78
  tmp = fstat(handle, & fileinfo);
#line 78
  if (tmp == -1) {
#line 79
    I_Error("Error fstating");
  }
#line 81
  return ((int )fileinfo.st_size);
}
}
#line 85 "w_wad.c"
void ExtractFileBase(char *path , char *dest ) 
{ 
  char *src ;
  int length ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 93
  tmp = strlen((char const   *)path);
#line 93
  src = (path + tmp) - 1;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if ((unsigned long )src != (unsigned long )path) {
#line 96
      if ((int )*(src - 1) != 92) {
#line 96
        if (! ((int )*(src - 1) != 47)) {
#line 96
          goto _L___0;
        }
      } else {
#line 96
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 96
      goto while_break;
    }
#line 100
    src --;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  memset((void *)dest, 0, (size_t )8);
#line 105
  length = 0;
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (*src) {
#line 107
      if (! ((int )*src != 46)) {
#line 107
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 107
      goto while_break___0;
    }
#line 109
    length ++;
#line 109
    if (length == 9) {
#line 110
      I_Error("Filename base of %s >8 chars", path);
    }
#line 112
    tmp___0 = dest;
#line 112
    dest ++;
#line 112
    tmp___1 = src;
#line 112
    src ++;
#line 112
    tmp___2 = toupper((int )*tmp___1);
#line 112
    *tmp___0 = (char )tmp___2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 137 "w_wad.c"
int reloadlump  ;
#line 138 "w_wad.c"
char *reloadname  ;
#line 141 "w_wad.c"
void W_AddFile(char *filename ) 
{ 
  wadinfo_t header ;
  lumpinfo_t *lump_p ;
  unsigned int i ;
  int handle ;
  int length ;
  int startlump ;
  filelump_t *fileinfo ;
  filelump_t singleinfo ;
  int storehandle ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
#line 156
  if ((int )*(filename + 0) == 126) {
#line 158
    filename ++;
#line 159
    reloadname = filename;
#line 160
    reloadlump = numlumps;
  }
#line 163
  handle = open((char const   *)filename, 0);
#line 163
  if (handle == -1) {
#line 165
    printf((char const   * __restrict  )" couldn\'t open %s\n", filename);
#line 166
    return;
  }
#line 169
  printf((char const   * __restrict  )" adding %s\n", filename);
#line 170
  startlump = numlumps;
#line 172
  tmp___2 = strlen((char const   *)filename);
#line 172
  tmp___3 = strcasecmp((char const   *)((filename + tmp___2) - 3), (char const   *)"wad");
#line 172
  if (tmp___3) {
#line 175
    fileinfo = & singleinfo;
#line 176
    singleinfo.filepos = 0;
#line 177
    singleinfo.size = filelength(handle);
#line 178
    ExtractFileBase(filename, singleinfo.name);
#line 179
    numlumps ++;
  } else {
#line 184
    read(handle, (void *)(& header), (size_t )sizeof(header));
#line 185
    tmp___0 = strncmp((char const   *)(header.identification), (char const   *)"IWAD",
                      (size_t )4);
#line 185
    if (tmp___0) {
#line 188
      tmp = strncmp((char const   *)(header.identification), (char const   *)"PWAD",
                    (size_t )4);
#line 188
      if (tmp) {
#line 190
        I_Error("Wad file %s doesn\'t have IWAD or PWAD id\n", filename);
      }
    }
#line 196
    header.numlumps = header.numlumps;
#line 197
    header.infotableofs = header.infotableofs;
#line 198
    length = (int )((unsigned long )header.numlumps * sizeof(filelump_t ));
#line 199
    tmp___1 = __builtin_alloca((unsigned long )length);
#line 199
    fileinfo = (filelump_t *)tmp___1;
#line 200
    lseek(handle, (__off_t )header.infotableofs, 0);
#line 201
    read(handle, (void *)fileinfo, (size_t )length);
#line 202
    numlumps += header.numlumps;
  }
#line 207
  tmp___4 = realloc((void *)lumpinfo, (size_t )((unsigned long )numlumps * sizeof(lumpinfo_t )));
#line 207
  lumpinfo = (lumpinfo_t *)tmp___4;
#line 209
  if (! lumpinfo) {
#line 210
    I_Error("Couldn\'t realloc lumpinfo");
  }
#line 212
  lump_p = lumpinfo + startlump;
#line 214
  if (reloadname) {
#line 214
    storehandle = -1;
  } else {
#line 214
    storehandle = handle;
  }
#line 216
  i = (unsigned int )startlump;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (i < (unsigned int )numlumps)) {
#line 216
      goto while_break;
    }
#line 218
    lump_p->handle = storehandle;
#line 219
    lump_p->position = fileinfo->filepos;
#line 220
    lump_p->size = fileinfo->size;
#line 221
    strncpy((char * __restrict  )(lump_p->name), (char const   * __restrict  )(fileinfo->name),
            (size_t )8);
#line 216
    i ++;
#line 216
    lump_p ++;
#line 216
    fileinfo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  if (reloadname) {
#line 225
    close(handle);
  }
#line 226
  return;
}
}
#line 236 "w_wad.c"
void W_Reload(void) 
{ 
  wadinfo_t header ;
  int lumpcount ;
  lumpinfo_t *lump_p ;
  unsigned int i ;
  int handle ;
  int length ;
  filelump_t *fileinfo ;
  void *tmp ;

  {
#line 246
  if (! reloadname) {
#line 247
    return;
  }
#line 249
  handle = open((char const   *)reloadname, 0);
#line 249
  if (handle == -1) {
#line 250
    I_Error("W_Reload: couldn\'t open %s", reloadname);
  }
#line 252
  read(handle, (void *)(& header), (size_t )sizeof(header));
#line 253
  lumpcount = header.numlumps;
#line 254
  header.infotableofs = header.infotableofs;
#line 255
  length = (int )((unsigned long )lumpcount * sizeof(filelump_t ));
#line 256
  tmp = __builtin_alloca((unsigned long )length);
#line 256
  fileinfo = (filelump_t *)tmp;
#line 257
  lseek(handle, (__off_t )header.infotableofs, 0);
#line 258
  read(handle, (void *)fileinfo, (size_t )length);
#line 261
  lump_p = lumpinfo + reloadlump;
#line 263
  i = (unsigned int )reloadlump;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (i < (unsigned int )(reloadlump + lumpcount))) {
#line 263
      goto while_break;
    }
#line 267
    if (*(lumpcache + i)) {
#line 268
      Z_Free(*(lumpcache + i));
    }
#line 270
    lump_p->position = fileinfo->filepos;
#line 271
    lump_p->size = fileinfo->size;
#line 263
    i ++;
#line 263
    lump_p ++;
#line 263
    fileinfo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  close(handle);
#line 275
  return;
}
}
#line 292 "w_wad.c"
void W_InitMultipleFiles(char **filenames ) 
{ 
  int size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 297
  numlumps = 0;
#line 300
  tmp = malloc((size_t )1);
#line 300
  lumpinfo = (lumpinfo_t *)tmp;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! *filenames) {
#line 302
      goto while_break;
    }
#line 303
    W_AddFile(*filenames);
#line 302
    filenames ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  if (! numlumps) {
#line 306
    I_Error("W_InitFiles: no files found");
  }
#line 309
  size = (int )((unsigned long )numlumps * sizeof(*lumpcache));
#line 310
  tmp___0 = malloc((size_t )size);
#line 310
  lumpcache = (void **)tmp___0;
#line 312
  if (! lumpcache) {
#line 313
    I_Error("Couldn\'t allocate lumpcache");
  }
#line 315
  memset((void *)lumpcache, 0, (size_t )size);
#line 316
  return;
}
}
#line 325 "w_wad.c"
void W_InitFile(char *filename ) 
{ 
  char *names[2] ;

  {
#line 329
  names[0] = filename;
#line 330
  names[1] = (char *)((void *)0);
#line 331
  W_InitMultipleFiles(names);
#line 332
  return;
}
}
#line 339 "w_wad.c"
int W_NumLumps(void) 
{ 


  {
#line 341
  return (numlumps);
}
}
#line 351 "w_wad.c"
int W_CheckNumForName(char *name ) 
{ 
  union __anonunion_name8_951761807 name8 ;
  int v1 ;
  int v2 ;
  lumpinfo_t *lump_p ;
  lumpinfo_t *tmp ;

  {
#line 364
  strncpy((char * __restrict  )(name8.s), (char const   * __restrict  )name, (size_t )8);
#line 367
  name8.s[8] = (char)0;
#line 370
  strupr(name8.s);
#line 372
  v1 = name8.x[0];
#line 373
  v2 = name8.x[1];
#line 377
  lump_p = lumpinfo + numlumps;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    tmp = lump_p;
#line 379
    lump_p --;
#line 379
    if (! ((unsigned long )tmp != (unsigned long )lumpinfo)) {
#line 379
      goto while_break;
    }
#line 381
    if (*((int *)(lump_p->name)) == v1) {
#line 381
      if (*((int *)(& lump_p->name[4])) == v2) {
#line 384
        return ((int )(lump_p - lumpinfo));
      } else {
#line 381
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  return (-1);
}
}
#line 399 "w_wad.c"
int W_GetNumForName(char *name ) 
{ 
  int i ;

  {
#line 403
  i = W_CheckNumForName(name);
#line 405
  if (i == -1) {
#line 406
    I_Error("W_GetNumForName: %s not found!", name);
  }
#line 408
  return (i);
}
}
#line 416 "w_wad.c"
int W_LumpLength(int lump ) 
{ 


  {
#line 418
  if (lump >= numlumps) {
#line 419
    I_Error("W_LumpLength: %i >= numlumps", lump);
  }
#line 421
  return ((lumpinfo + lump)->size);
}
}
#line 431 "w_wad.c"
void W_ReadLump(int lump , void *dest ) 
{ 
  int c ;
  lumpinfo_t *l___0 ;
  int handle ;

  {
#line 440
  if (lump >= numlumps) {
#line 441
    I_Error("W_ReadLump: %i >= numlumps", lump);
  }
#line 443
  l___0 = lumpinfo + lump;
#line 447
  if (l___0->handle == -1) {
#line 450
    handle = open((char const   *)reloadname, 0);
#line 450
    if (handle == -1) {
#line 451
      I_Error("W_ReadLump: couldn\'t open %s", reloadname);
    }
  } else {
#line 454
    handle = l___0->handle;
  }
#line 456
  lseek(handle, (__off_t )l___0->position, 0);
#line 457
  c = read(handle, dest, (size_t )l___0->size);
#line 459
  if (c < l___0->size) {
#line 460
    I_Error("W_ReadLump: only read %i of %i on lump %i", c, l___0->size, lump);
  }
#line 463
  if (l___0->handle == -1) {
#line 464
    close(handle);
  }
#line 467
  return;
}
}
#line 475 "w_wad.c"
void *W_CacheLumpNum(int lump , int tag ) 
{ 
  byte *ptr ;
  int tmp ;
  void *tmp___0 ;

  {
#line 482
  if ((unsigned int )lump >= (unsigned int )numlumps) {
#line 483
    I_Error("W_CacheLumpNum: %i >= numlumps", lump);
  }
#line 485
  if (! *(lumpcache + lump)) {
#line 490
    tmp = W_LumpLength(lump);
#line 490
    tmp___0 = Z_Malloc(tmp, tag, (void *)(lumpcache + lump));
#line 490
    ptr = (byte *)tmp___0;
#line 491
    W_ReadLump(lump, *(lumpcache + lump));
  } else {
#line 496
    if (((memblock_t *)((byte *)*(lumpcache + lump) - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 496
      I_Error("Z_CT at w_wad.c:%i", 496);
    }
#line 496
    Z_ChangeTag2(*(lumpcache + lump), tag);
  }
#line 499
  return (*(lumpcache + lump));
}
}
#line 507 "w_wad.c"
void *W_CacheLumpName(char *name , int tag ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 512
  tmp = W_GetNumForName(name);
#line 512
  tmp___0 = W_CacheLumpNum(tmp, tag);
#line 512
  return (tmp___0);
}
}
#line 519 "w_wad.c"
int info[2500][10]  ;
#line 520 "w_wad.c"
int profilecount  ;
#line 522 "w_wad.c"
void W_Profile(void) 
{ 
  int i ;
  memblock_t *block ;
  void *ptr ;
  char ch ;
  FILE *f ;
  int j ;
  char name[9] ;

  {
#line 533
  i = 0;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! (i < numlumps)) {
#line 533
      goto while_break;
    }
#line 535
    ptr = *(lumpcache + i);
#line 536
    if (! ptr) {
#line 538
      ch = (char )' ';
#line 539
      goto __Cont;
    } else {
#line 543
      block = (memblock_t *)((byte *)ptr - sizeof(memblock_t ));
#line 544
      if (block->tag < 100) {
#line 545
        ch = (char )'S';
      } else {
#line 547
        ch = (char )'P';
      }
    }
#line 549
    info[i][profilecount] = (int )ch;
    __Cont: /* CIL Label */ 
#line 533
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  profilecount ++;
#line 553
  f = fopen((char const   * __restrict  )"waddump.txt", (char const   * __restrict  )"w");
#line 554
  name[8] = (char)0;
#line 556
  i = 0;
  {
#line 556
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 556
    if (! (i < numlumps)) {
#line 556
      goto while_break___0;
    }
#line 558
    memcpy((void * __restrict  )(name), (void const   * __restrict  )((lumpinfo + i)->name),
           (size_t )8);
#line 560
    j = 0;
    {
#line 560
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 560
      if (! (j < 8)) {
#line 560
        goto while_break___1;
      }
#line 561
      if (! name[j]) {
#line 562
        goto while_break___1;
      }
#line 560
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 564
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 564
      if (! (j < 8)) {
#line 564
        goto while_break___2;
      }
#line 565
      name[j] = (char )' ';
#line 564
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 567
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", name);
#line 569
    j = 0;
    {
#line 569
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 569
      if (! (j < profilecount)) {
#line 569
        goto while_break___3;
      }
#line 570
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"    %c", info[i][j]);
#line 569
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 572
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 556
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 574
  fclose(f);
#line 575
  return;
}
}
#line 24 "wi_stuff.c"
static char const   rcsid___50[51]  = 
#line 24 "wi_stuff.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'w',      (char const   )'i',      (char const   )'_', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'f', 
        (char const   )'f',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'7',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )' ',      (char const   )'2',      (char const   )'2',      (char const   )':', 
        (char const   )'4',      (char const   )'5',      (char const   )':',      (char const   )'1', 
        (char const   )'3',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 177 "wi_stuff.c"
static point_t lnodes[4][9]  = { {        {185, 164}, 
            {148, 143}, 
            {69, 122}, 
            {209, 102}, 
            {116, 89}, 
            {166, 55}, 
            {71, 56}, 
            {135, 29}, 
            {71, 24}}, 
   {        {254, 25}, 
            {97, 50}, 
            {188, 64}, 
            {128, 78}, 
            {214, 92}, 
            {133, 130}, 
            {208, 136}, 
            {148, 140}, 
            {235, 158}}, 
   {        {156, 168}, 
            {48, 154}, 
            {174, 95}, 
            {265, 75}, 
            {130, 48}, 
            {279, 23}, 
            {198, 48}, 
            {140, 25}, 
            {281, 136}}};
#line 226 "wi_stuff.c"
static anim_t___0 epsd0animinfo[10]  = 
#line 226
  {      {(animenum_t )0, 11, 3, {224, 104}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {184, 160}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {112, 136}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {72, 112}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {88, 96}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {64, 48}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {192, 40}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {136, 16}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {80, 16}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {64, 24}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}};
#line 240 "wi_stuff.c"
static anim_t___0 epsd1animinfo[9]  = 
#line 240
  {      {(animenum_t )2, 11, 1, {128, 136}, 1, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )2, 11, 1, {128, 136}, 2, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )2, 11, 1, {128, 136}, 3, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )2, 11, 1, {128, 136}, 4, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )2, 11, 1, {128, 136}, 5, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )2, 11, 1, {128, 136}, 6, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )2, 11, 1, {128, 136}, 7, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )2, 11, 3, {192, 144}, 8, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )2, 11, 1, {128, 136}, 8, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}};
#line 253 "wi_stuff.c"
static anim_t___0 epsd2animinfo[6]  = {      {(animenum_t )0, 11, 3, {104, 168}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {40, 136}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {160, 96}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {104, 80}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 11, 3, {120, 32}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}, 
        {(animenum_t )0, 8, 3, {40, 0}, 0, 0, {(patch_t *)0, (patch_t *)0, (patch_t *)0},
      0, 0, 0, 0}};
#line 263 "wi_stuff.c"
static int NUMANIMS[4]  = {      (int )(sizeof(epsd0animinfo) / sizeof(anim_t___0 )),      (int )(sizeof(epsd1animinfo) / sizeof(anim_t___0 )),      (int )(sizeof(epsd2animinfo) / sizeof(anim_t___0 ))};
#line 270 "wi_stuff.c"
static anim_t___0 *anims___0[4]  = {      epsd0animinfo,      epsd1animinfo,      epsd2animinfo};
#line 304 "wi_stuff.c"
static int acceleratestage  ;
#line 307 "wi_stuff.c"
static int me  ;
#line 310 "wi_stuff.c"
static stateenum_t state  ;
#line 313 "wi_stuff.c"
static wbstartstruct_t *wbs  ;
#line 315 "wi_stuff.c"
static wbplayerstruct_t *plrs  ;
#line 318 "wi_stuff.c"
static int cnt  ;
#line 321 "wi_stuff.c"
static int bcnt  ;
#line 324 "wi_stuff.c"
static int firstrefresh  ;
#line 326 "wi_stuff.c"
static int cnt_kills[4]  ;
#line 327 "wi_stuff.c"
static int cnt_items[4]  ;
#line 328 "wi_stuff.c"
static int cnt_secret[4]  ;
#line 329 "wi_stuff.c"
static int cnt_time  ;
#line 330 "wi_stuff.c"
static int cnt_par  ;
#line 331 "wi_stuff.c"
static int cnt_pause  ;
#line 334 "wi_stuff.c"
static int NUMCMAPS  ;
#line 342 "wi_stuff.c"
static patch_t *bg  ;
#line 345 "wi_stuff.c"
static patch_t *yah[2]  ;
#line 348 "wi_stuff.c"
static patch_t *splat  ;
#line 351 "wi_stuff.c"
static patch_t *percent  ;
#line 352 "wi_stuff.c"
static patch_t *colon  ;
#line 355 "wi_stuff.c"
static patch_t *num[10]  ;
#line 358 "wi_stuff.c"
static patch_t *wiminus  ;
#line 361 "wi_stuff.c"
static patch_t *finished  ;
#line 364 "wi_stuff.c"
static patch_t *entering  ;
#line 367 "wi_stuff.c"
static patch_t *sp_secret  ;
#line 370 "wi_stuff.c"
static patch_t *kills  ;
#line 371 "wi_stuff.c"
static patch_t *secret  ;
#line 372 "wi_stuff.c"
static patch_t *items  ;
#line 373 "wi_stuff.c"
static patch_t *frags  ;
#line 376 "wi_stuff.c"
static patch_t *time___0  ;
#line 377 "wi_stuff.c"
static patch_t *par  ;
#line 378 "wi_stuff.c"
static patch_t *sucks  ;
#line 381 "wi_stuff.c"
static patch_t *killers  ;
#line 382 "wi_stuff.c"
static patch_t *victims  ;
#line 385 "wi_stuff.c"
static patch_t *total  ;
#line 386 "wi_stuff.c"
static patch_t *star  ;
#line 387 "wi_stuff.c"
static patch_t *bstar  ;
#line 390 "wi_stuff.c"
static patch_t *p[4]  ;
#line 393 "wi_stuff.c"
static patch_t *bp[4]  ;
#line 396 "wi_stuff.c"
static patch_t **lnames  ;
#line 406 "wi_stuff.c"
void WI_slamBackground(void) 
{ 


  {
#line 408
  memcpy((void * __restrict  )screens[0], (void const   * __restrict  )screens[1],
         (size_t )64000);
#line 409
  V_MarkRect(0, 0, 320, 200);
#line 410
  return;
}
}
#line 414 "wi_stuff.c"
boolean WI_Responder(event_t *ev ) 
{ 


  {
#line 416
  return ((boolean )0);
}
}
#line 421 "wi_stuff.c"
void WI_drawLF(void) 
{ 
  int y___1 ;

  {
#line 423
  y___1 = 2;
#line 426
  V_DrawPatch((320 - (int )(*(lnames + wbs->last))->width) / 2, y___1, 0, *(lnames + wbs->last));
#line 430
  y___1 += (5 * (int )(*(lnames + wbs->last))->height) / 4;
#line 432
  V_DrawPatch((320 - (int )finished->width) / 2, y___1, 0, finished);
#line 434
  return;
}
}
#line 439 "wi_stuff.c"
void WI_drawEL(void) 
{ 
  int y___1 ;

  {
#line 441
  y___1 = 2;
#line 444
  V_DrawPatch((320 - (int )entering->width) / 2, y___1, 0, entering);
#line 448
  y___1 += (5 * (int )(*(lnames + wbs->next))->height) / 4;
#line 450
  V_DrawPatch((320 - (int )(*(lnames + wbs->next))->width) / 2, y___1, 0, *(lnames + wbs->next));
#line 453
  return;
}
}
#line 455 "wi_stuff.c"
void WI_drawOnLnode(int n , patch_t **c ) 
{ 
  int i ;
  int left ;
  int top ;
  int right ;
  int bottom ;
  boolean fits ;

  {
#line 466
  fits = (boolean )0;
#line 468
  i = 0;
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    left = lnodes[wbs->epsd][n].x - (int )(*(c + i))->leftoffset;
#line 472
    top = lnodes[wbs->epsd][n].y - (int )(*(c + i))->topoffset;
#line 473
    right = left + (int )(*(c + i))->width;
#line 474
    bottom = top + (int )(*(c + i))->height;
#line 476
    if (left >= 0) {
#line 476
      if (right < 320) {
#line 476
        if (top >= 0) {
#line 476
          if (bottom < 200) {
#line 481
            fits = (boolean )1;
          } else {
#line 476
            goto _L___1;
          }
        } else {
#line 476
          goto _L___1;
        }
      } else {
#line 476
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 485
      i ++;
    }
#line 469
    if (! fits) {
#line 469
      if (! (i != 2)) {
#line 469
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 469
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  if (fits) {
#line 489
    if (i < 2) {
#line 491
      V_DrawPatch(lnodes[wbs->epsd][n].x, lnodes[wbs->epsd][n].y, 0, *(c + i));
    } else {
#line 489
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 497
    printf((char const   * __restrict  )"Could not place patch on level %d", n + 1);
  }
#line 499
  return;
}
}
#line 503 "wi_stuff.c"
void WI_initAnimatedBack(void) 
{ 
  int i ;
  anim_t___0 *a ;
  int tmp ;
  int tmp___0 ;

  {
#line 508
  if ((unsigned int )gamemode == 2U) {
#line 509
    return;
  }
#line 511
  if (wbs->epsd > 2) {
#line 512
    return;
  }
#line 514
  i = 0;
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! (i < NUMANIMS[wbs->epsd])) {
#line 514
      goto while_break;
    }
#line 516
    a = anims___0[wbs->epsd] + i;
#line 519
    a->ctr = -1;
#line 522
    if ((unsigned int )a->type == 0U) {
#line 523
      tmp = M_Random();
#line 523
      a->nexttic = (bcnt + 1) + tmp % a->period;
    } else
#line 524
    if ((unsigned int )a->type == 1U) {
#line 525
      tmp___0 = M_Random();
#line 525
      a->nexttic = ((bcnt + 1) + a->data2) + tmp___0 % a->data1;
    } else
#line 526
    if ((unsigned int )a->type == 2U) {
#line 527
      a->nexttic = bcnt + 1;
    }
#line 514
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  return;
}
}
#line 532 "wi_stuff.c"
void WI_updateAnimatedBack(void) 
{ 
  int i ;
  anim_t___0 *a ;
  int tmp ;

  {
#line 537
  if ((unsigned int )gamemode == 2U) {
#line 538
    return;
  }
#line 540
  if (wbs->epsd > 2) {
#line 541
    return;
  }
#line 543
  i = 0;
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (! (i < NUMANIMS[wbs->epsd])) {
#line 543
      goto while_break;
    }
#line 545
    a = anims___0[wbs->epsd] + i;
#line 547
    if (bcnt == a->nexttic) {
      {
#line 551
      if ((unsigned int )a->type == 0U) {
#line 551
        goto case_0;
      }
#line 556
      if ((unsigned int )a->type == 1U) {
#line 556
        goto case_1;
      }
#line 566
      if ((unsigned int )a->type == 2U) {
#line 566
        goto case_2;
      }
#line 549
      goto switch_break;
      case_0: /* CIL Label */ 
#line 552
      (a->ctr) ++;
#line 552
      if (a->ctr >= a->nanims) {
#line 552
        a->ctr = 0;
      }
#line 553
      a->nexttic = bcnt + a->period;
#line 554
      goto switch_break;
      case_1: /* CIL Label */ 
#line 557
      (a->ctr) ++;
#line 558
      if (a->ctr == a->nanims) {
#line 560
        a->ctr = -1;
#line 561
        tmp = M_Random();
#line 561
        a->nexttic = (bcnt + a->data2) + tmp % a->data1;
      } else {
#line 563
        a->nexttic = bcnt + a->period;
      }
#line 564
      goto switch_break;
      case_2: /* CIL Label */ 
#line 568
      if ((int )state == 0) {
#line 568
        if (i == 7) {
          _L: /* CIL Label */ ;
        } else {
#line 568
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 568
      if (wbs->next == a->data1) {
#line 571
        (a->ctr) ++;
#line 572
        if (a->ctr == a->nanims) {
#line 572
          (a->ctr) --;
        }
#line 573
        a->nexttic = bcnt + a->period;
      } else {
#line 568
        goto _L;
      }
#line 575
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 543
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 581
  return;
}
}
#line 583 "wi_stuff.c"
void WI_drawAnimatedBack(void) 
{ 
  int i ;
  anim_t___0 *a ;

  {
#line 588
  if (2) {
#line 589
    return;
  }
#line 591
  if (wbs->epsd > 2) {
#line 592
    return;
  }
#line 594
  i = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (! (i < NUMANIMS[wbs->epsd])) {
#line 594
      goto while_break;
    }
#line 596
    a = anims___0[wbs->epsd] + i;
#line 598
    if (a->ctr >= 0) {
#line 599
      V_DrawPatch(a->loc.x, a->loc.y, 0, a->p[a->ctr]);
    }
#line 594
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  return;
}
}
#line 611 "wi_stuff.c"
int WI_drawNum(int x___0 , int y___1 , int n , int digits ) 
{ 
  int fontwidth ;
  int neg ;
  int temp ;
  int tmp ;

  {
#line 619
  fontwidth = (int )(num[0])->width;
#line 623
  if (digits < 0) {
#line 625
    if (! n) {
#line 628
      digits = 1;
    } else {
#line 633
      digits = 0;
#line 634
      temp = n;
      {
#line 636
      while (1) {
        while_continue: /* CIL Label */ ;
#line 636
        if (! temp) {
#line 636
          goto while_break;
        }
#line 638
        temp /= 10;
#line 639
        digits ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 644
  neg = n < 0;
#line 645
  if (neg) {
#line 646
    n = - n;
  }
#line 649
  if (n == 1994) {
#line 650
    return (0);
  }
  {
#line 653
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 653
    tmp = digits;
#line 653
    digits --;
#line 653
    if (! tmp) {
#line 653
      goto while_break___0;
    }
#line 655
    x___0 -= fontwidth;
#line 656
    V_DrawPatch(x___0, y___1, 0, num[n % 10]);
#line 657
    n /= 10;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 661
  if (neg) {
#line 662
    x___0 -= 8;
#line 662
    V_DrawPatch(x___0, y___1, 0, wiminus);
  }
#line 664
  return (x___0);
}
}
#line 668 "wi_stuff.c"
void WI_drawPercent(int x___0 , int y___1 , int p___0 ) 
{ 


  {
#line 674
  if (p___0 < 0) {
#line 675
    return;
  }
#line 677
  V_DrawPatch(x___0, y___1, 0, percent);
#line 678
  WI_drawNum(x___0, y___1, p___0, -1);
#line 679
  return;
}
}
#line 687 "wi_stuff.c"
void WI_drawTime(int x___0 , int y___1 , int t ) 
{ 
  int div___0 ;
  int n ;
  int tmp ;

  {
#line 697
  if (t < 0) {
#line 698
    return;
  }
#line 700
  if (t <= 3599) {
#line 702
    div___0 = 1;
    {
#line 704
    while (1) {
      while_continue: /* CIL Label */ ;
#line 706
      n = (t / div___0) % 60;
#line 707
      tmp = WI_drawNum(x___0, y___1, n, 2);
#line 707
      x___0 = tmp - (int )colon->width;
#line 708
      div___0 *= 60;
#line 711
      if (div___0 == 60) {
#line 711
        goto _L;
      } else
#line 711
      if (t / div___0) {
        _L: /* CIL Label */ 
#line 712
        V_DrawPatch(x___0, y___1, 0, colon);
      }
#line 704
      if (! (t / div___0)) {
#line 704
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 719
    V_DrawPatch(x___0 - (int )sucks->width, y___1, 0, sucks);
  }
#line 721
  return;
}
}
#line 726
void WI_unloadData(void) ;
#line 724 "wi_stuff.c"
void WI_End(void) 
{ 


  {
#line 727
  WI_unloadData();
#line 728
  return;
}
}
#line 730 "wi_stuff.c"
void WI_initNoState(void) 
{ 


  {
#line 732
  state = (stateenum_t )-1;
#line 733
  acceleratestage = 0;
#line 734
  cnt = 10;
#line 735
  return;
}
}
#line 737 "wi_stuff.c"
void WI_updateNoState(void) 
{ 


  {
#line 739
  WI_updateAnimatedBack();
#line 741
  cnt --;
#line 741
  if (! cnt) {
#line 743
    WI_End();
#line 744
    G_WorldDone();
  }
#line 747
  return;
}
}
#line 749 "wi_stuff.c"
static boolean snl_pointeron  =    (boolean )0;
#line 752 "wi_stuff.c"
void WI_initShowNextLoc(void) 
{ 


  {
#line 754
  state = (stateenum_t )1;
#line 755
  acceleratestage = 0;
#line 756
  cnt = 140;
#line 758
  WI_initAnimatedBack();
#line 759
  return;
}
}
#line 761 "wi_stuff.c"
void WI_updateShowNextLoc(void) 
{ 


  {
#line 763
  WI_updateAnimatedBack();
#line 765
  cnt --;
#line 765
  if (cnt) {
#line 765
    if (acceleratestage) {
      _L: /* CIL Label */ 
#line 766
      WI_initNoState();
    } else {
#line 768
      snl_pointeron = (boolean )((cnt & 31) < 20);
    }
  } else {
#line 765
    goto _L;
  }
#line 769
  return;
}
}
#line 771 "wi_stuff.c"
void WI_drawShowNextLoc(void) 
{ 
  int i ;
  int last ;

  {
#line 777
  WI_slamBackground();
#line 780
  WI_drawAnimatedBack();
#line 782
  if ((unsigned int )gamemode != 2U) {
#line 784
    if (wbs->epsd > 2) {
#line 786
      WI_drawEL();
#line 787
      return;
    }
#line 790
    if (wbs->last == 8) {
#line 790
      last = wbs->next - 1;
    } else {
#line 790
      last = wbs->last;
    }
#line 793
    i = 0;
    {
#line 793
    while (1) {
      while_continue: /* CIL Label */ ;
#line 793
      if (! (i <= last)) {
#line 793
        goto while_break;
      }
#line 794
      WI_drawOnLnode(i, & splat);
#line 793
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 797
    if (wbs->didsecret) {
#line 798
      WI_drawOnLnode(8, & splat);
    }
#line 801
    if (snl_pointeron) {
#line 802
      WI_drawOnLnode(wbs->next, yah);
    }
  }
#line 806
  if ((unsigned int )gamemode != 2U) {
#line 806
    goto _L;
  } else
#line 806
  if (wbs->next != 30) {
    _L: /* CIL Label */ 
#line 808
    WI_drawEL();
  }
#line 810
  return;
}
}
#line 812 "wi_stuff.c"
void WI_drawNoState(void) 
{ 


  {
#line 814
  snl_pointeron = (boolean )1;
#line 815
  WI_drawShowNextLoc();
#line 816
  return;
}
}
#line 818 "wi_stuff.c"
int WI_fragSum(int playernum ) 
{ 
  int i ;
  int frags___0 ;

  {
#line 821
  frags___0 = 0;
#line 823
  i = 0;
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    if (! (i < 4)) {
#line 823
      goto while_break;
    }
#line 825
    if (playeringame[i]) {
#line 825
      if (i != playernum) {
#line 828
        frags___0 += (plrs + playernum)->frags[i];
      } else {
#line 825
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 823
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 834
  frags___0 -= (plrs + playernum)->frags[playernum];
#line 838
  return (frags___0);
}
}
#line 843 "wi_stuff.c"
static int dm_state  ;
#line 844 "wi_stuff.c"
static int dm_frags[4][4]  ;
#line 845 "wi_stuff.c"
static int dm_totals[4]  ;
#line 849 "wi_stuff.c"
void WI_initDeathmatchStats(void) 
{ 
  int i ;
  int j ;

  {
#line 855
  state = (stateenum_t )0;
#line 856
  acceleratestage = 0;
#line 857
  dm_state = 1;
#line 859
  cnt_pause = 35;
#line 861
  i = 0;
  {
#line 861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 861
    if (! (i < 4)) {
#line 861
      goto while_break;
    }
#line 863
    if (playeringame[i]) {
#line 865
      j = 0;
      {
#line 865
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 865
        if (! (j < 4)) {
#line 865
          goto while_break___0;
        }
#line 866
        if (playeringame[j]) {
#line 867
          dm_frags[i][j] = 0;
        }
#line 865
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 869
      dm_totals[i] = 0;
    }
#line 861
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 873
  WI_initAnimatedBack();
#line 874
  return;
}
}
#line 878 "wi_stuff.c"
void WI_updateDeathmatchStats(void) 
{ 
  int i ;
  int j ;
  boolean stillticking ;

  {
#line 886
  WI_updateAnimatedBack();
#line 888
  if (acceleratestage) {
#line 888
    if (dm_state != 4) {
#line 890
      acceleratestage = 0;
#line 892
      i = 0;
      {
#line 892
      while (1) {
        while_continue: /* CIL Label */ ;
#line 892
        if (! (i < 4)) {
#line 892
          goto while_break;
        }
#line 894
        if (playeringame[i]) {
#line 896
          j = 0;
          {
#line 896
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 896
            if (! (j < 4)) {
#line 896
              goto while_break___0;
            }
#line 897
            if (playeringame[j]) {
#line 898
              dm_frags[i][j] = (plrs + i)->frags[j];
            }
#line 896
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 900
          dm_totals[i] = WI_fragSum(i);
        }
#line 892
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 905
      S_StartSound((void *)0, 82);
#line 906
      dm_state = 4;
    } else {
#line 888
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 910
  if (dm_state == 2) {
#line 912
    if (! (bcnt & 3)) {
#line 913
      S_StartSound((void *)0, 1);
    }
#line 915
    stillticking = (boolean )0;
#line 917
    i = 0;
    {
#line 917
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 917
      if (! (i < 4)) {
#line 917
        goto while_break___1;
      }
#line 919
      if (playeringame[i]) {
#line 921
        j = 0;
        {
#line 921
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 921
          if (! (j < 4)) {
#line 921
            goto while_break___2;
          }
#line 923
          if (playeringame[j]) {
#line 923
            if (dm_frags[i][j] != (plrs + i)->frags[j]) {
#line 926
              if ((plrs + i)->frags[j] < 0) {
#line 927
                (dm_frags[i][j]) --;
              } else {
#line 929
                (dm_frags[i][j]) ++;
              }
#line 931
              if (dm_frags[i][j] > 99) {
#line 932
                dm_frags[i][j] = 99;
              }
#line 934
              if (dm_frags[i][j] < -99) {
#line 935
                dm_frags[i][j] = -99;
              }
#line 937
              stillticking = (boolean )1;
            } else {
#line 923
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ ;
          }
#line 921
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 940
        dm_totals[i] = WI_fragSum(i);
#line 942
        if (dm_totals[i] > 99) {
#line 943
          dm_totals[i] = 99;
        }
#line 945
        if (dm_totals[i] < -99) {
#line 946
          dm_totals[i] = -99;
        }
      }
#line 917
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 950
    if (! stillticking) {
#line 952
      S_StartSound((void *)0, 82);
#line 953
      dm_state ++;
    }
  } else
#line 957
  if (dm_state == 4) {
#line 959
    if (acceleratestage) {
#line 961
      S_StartSound((void *)0, 31);
#line 963
      if ((unsigned int )gamemode == 2U) {
#line 964
        WI_initNoState();
      } else {
#line 966
        WI_initShowNextLoc();
      }
    }
  } else
#line 969
  if (dm_state & 1) {
#line 971
    cnt_pause --;
#line 971
    if (! cnt_pause) {
#line 973
      dm_state ++;
#line 974
      cnt_pause = 35;
    }
  }
#line 977
  return;
}
}
#line 981 "wi_stuff.c"
void WI_drawDeathmatchStats(void) 
{ 
  int i ;
  int j ;
  int x___0 ;
  int y___1 ;
  int w ;
  int lh ;

  {
#line 992
  lh = 33;
#line 994
  WI_slamBackground();
#line 997
  WI_drawAnimatedBack();
#line 998
  WI_drawLF();
#line 1001
  V_DrawPatch(269 - (int )total->width / 2, 45, 0, total);
#line 1006
  V_DrawPatch(10, 100, 0, killers);
#line 1007
  V_DrawPatch(5, 50, 0, victims);
#line 1010
  x___0 = 82;
#line 1011
  y___1 = 68;
#line 1013
  i = 0;
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1013
    if (! (i < 4)) {
#line 1013
      goto while_break;
    }
#line 1015
    if (playeringame[i]) {
#line 1017
      V_DrawPatch(x___0 - (int )(p[i])->width / 2, 35, 0, p[i]);
#line 1022
      V_DrawPatch(42 - (int )(p[i])->width / 2, y___1, 0, p[i]);
#line 1027
      if (i == me) {
#line 1029
        V_DrawPatch(x___0 - (int )(p[i])->width / 2, 35, 0, bstar);
#line 1034
        V_DrawPatch(42 - (int )(p[i])->width / 2, y___1, 0, star);
      }
    }
#line 1047
    x___0 += 40;
#line 1048
    y___1 += 33;
#line 1013
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1052
  y___1 = 78;
#line 1053
  w = (int )(num[0])->width;
#line 1055
  i = 0;
  {
#line 1055
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1055
    if (! (i < 4)) {
#line 1055
      goto while_break___0;
    }
#line 1057
    x___0 = 82;
#line 1059
    if (playeringame[i]) {
#line 1061
      j = 0;
      {
#line 1061
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1061
        if (! (j < 4)) {
#line 1061
          goto while_break___1;
        }
#line 1063
        if (playeringame[j]) {
#line 1064
          WI_drawNum(x___0 + w, y___1, dm_frags[i][j], 2);
        }
#line 1066
        x___0 += 40;
#line 1061
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1068
      WI_drawNum(269 + w, y___1, dm_totals[i], 2);
    }
#line 1070
    y___1 += 33;
#line 1055
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1072
  return;
}
}
#line 1074 "wi_stuff.c"
static int cnt_frags[4]  ;
#line 1075 "wi_stuff.c"
static int dofrags  ;
#line 1076 "wi_stuff.c"
static int ng_state  ;
#line 1078 "wi_stuff.c"
void WI_initNetgameStats(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1083
  state = (stateenum_t )0;
#line 1084
  acceleratestage = 0;
#line 1085
  ng_state = 1;
#line 1087
  cnt_pause = 35;
#line 1089
  i = 0;
  {
#line 1089
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1089
    if (! (i < 4)) {
#line 1089
      goto while_break;
    }
#line 1091
    if (! playeringame[i]) {
#line 1092
      goto __Cont;
    }
#line 1094
    tmp___1 = 0;
#line 1094
    cnt_frags[i] = tmp___1;
#line 1094
    tmp___0 = tmp___1;
#line 1094
    cnt_secret[i] = tmp___0;
#line 1094
    tmp = tmp___0;
#line 1094
    cnt_items[i] = tmp;
#line 1094
    cnt_kills[i] = tmp;
#line 1096
    tmp___2 = WI_fragSum(i);
#line 1096
    dofrags += tmp___2;
    __Cont: /* CIL Label */ 
#line 1089
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1099
  dofrags = ! (! dofrags);
#line 1101
  WI_initAnimatedBack();
#line 1102
  return;
}
}
#line 1106 "wi_stuff.c"
void WI_updateNetgameStats(void) 
{ 
  int i ;
  int fsum ;
  boolean stillticking ;

  {
#line 1114
  WI_updateAnimatedBack();
#line 1116
  if (acceleratestage) {
#line 1116
    if (ng_state != 10) {
#line 1118
      acceleratestage = 0;
#line 1120
      i = 0;
      {
#line 1120
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1120
        if (! (i < 4)) {
#line 1120
          goto while_break;
        }
#line 1122
        if (! playeringame[i]) {
#line 1123
          goto __Cont;
        }
#line 1125
        cnt_kills[i] = ((plrs + i)->skills * 100) / wbs->maxkills;
#line 1126
        cnt_items[i] = ((plrs + i)->sitems * 100) / wbs->maxitems;
#line 1127
        cnt_secret[i] = ((plrs + i)->ssecret * 100) / wbs->maxsecret;
#line 1129
        if (dofrags) {
#line 1130
          cnt_frags[i] = WI_fragSum(i);
        }
        __Cont: /* CIL Label */ 
#line 1120
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1132
      S_StartSound((void *)0, 82);
#line 1133
      ng_state = 10;
    } else {
#line 1116
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 1136
  if (ng_state == 2) {
#line 1138
    if (! (bcnt & 3)) {
#line 1139
      S_StartSound((void *)0, 1);
    }
#line 1141
    stillticking = (boolean )0;
#line 1143
    i = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if (! (i < 4)) {
#line 1143
        goto while_break___0;
      }
#line 1145
      if (! playeringame[i]) {
#line 1146
        goto __Cont___0;
      }
#line 1148
      cnt_kills[i] += 2;
#line 1150
      if (cnt_kills[i] >= ((plrs + i)->skills * 100) / wbs->maxkills) {
#line 1151
        cnt_kills[i] = ((plrs + i)->skills * 100) / wbs->maxkills;
      } else {
#line 1153
        stillticking = (boolean )1;
      }
      __Cont___0: /* CIL Label */ 
#line 1143
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1156
    if (! stillticking) {
#line 1158
      S_StartSound((void *)0, 82);
#line 1159
      ng_state ++;
    }
  } else
#line 1162
  if (ng_state == 4) {
#line 1164
    if (! (bcnt & 3)) {
#line 1165
      S_StartSound((void *)0, 1);
    }
#line 1167
    stillticking = (boolean )0;
#line 1169
    i = 0;
    {
#line 1169
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1169
      if (! (i < 4)) {
#line 1169
        goto while_break___1;
      }
#line 1171
      if (! playeringame[i]) {
#line 1172
        goto __Cont___1;
      }
#line 1174
      cnt_items[i] += 2;
#line 1175
      if (cnt_items[i] >= ((plrs + i)->sitems * 100) / wbs->maxitems) {
#line 1176
        cnt_items[i] = ((plrs + i)->sitems * 100) / wbs->maxitems;
      } else {
#line 1178
        stillticking = (boolean )1;
      }
      __Cont___1: /* CIL Label */ 
#line 1169
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1180
    if (! stillticking) {
#line 1182
      S_StartSound((void *)0, 82);
#line 1183
      ng_state ++;
    }
  } else
#line 1186
  if (ng_state == 6) {
#line 1188
    if (! (bcnt & 3)) {
#line 1189
      S_StartSound((void *)0, 1);
    }
#line 1191
    stillticking = (boolean )0;
#line 1193
    i = 0;
    {
#line 1193
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1193
      if (! (i < 4)) {
#line 1193
        goto while_break___2;
      }
#line 1195
      if (! playeringame[i]) {
#line 1196
        goto __Cont___2;
      }
#line 1198
      cnt_secret[i] += 2;
#line 1200
      if (cnt_secret[i] >= ((plrs + i)->ssecret * 100) / wbs->maxsecret) {
#line 1201
        cnt_secret[i] = ((plrs + i)->ssecret * 100) / wbs->maxsecret;
      } else {
#line 1203
        stillticking = (boolean )1;
      }
      __Cont___2: /* CIL Label */ 
#line 1193
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1206
    if (! stillticking) {
#line 1208
      S_StartSound((void *)0, 82);
#line 1209
      ng_state += 1 + 2 * ! dofrags;
    }
  } else
#line 1212
  if (ng_state == 8) {
#line 1214
    if (! (bcnt & 3)) {
#line 1215
      S_StartSound((void *)0, 1);
    }
#line 1217
    stillticking = (boolean )0;
#line 1219
    i = 0;
    {
#line 1219
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1219
      if (! (i < 4)) {
#line 1219
        goto while_break___3;
      }
#line 1221
      if (! playeringame[i]) {
#line 1222
        goto __Cont___3;
      }
#line 1224
      (cnt_frags[i]) ++;
#line 1226
      fsum = WI_fragSum(i);
#line 1226
      if (cnt_frags[i] >= fsum) {
#line 1227
        cnt_frags[i] = fsum;
      } else {
#line 1229
        stillticking = (boolean )1;
      }
      __Cont___3: /* CIL Label */ 
#line 1219
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1232
    if (! stillticking) {
#line 1234
      S_StartSound((void *)0, 57);
#line 1235
      ng_state ++;
    }
  } else
#line 1238
  if (ng_state == 10) {
#line 1240
    if (acceleratestage) {
#line 1242
      S_StartSound((void *)0, 3);
#line 1243
      if ((unsigned int )gamemode == 2U) {
#line 1244
        WI_initNoState();
      } else {
#line 1246
        WI_initShowNextLoc();
      }
    }
  } else
#line 1249
  if (ng_state & 1) {
#line 1251
    cnt_pause --;
#line 1251
    if (! cnt_pause) {
#line 1253
      ng_state ++;
#line 1254
      cnt_pause = 35;
    }
  }
#line 1257
  return;
}
}
#line 1261 "wi_stuff.c"
void WI_drawNetgameStats(void) 
{ 
  int i ;
  int x___0 ;
  int y___1 ;
  int pwidth ;

  {
#line 1266
  pwidth = (int )percent->width;
#line 1268
  WI_slamBackground();
#line 1271
  WI_drawAnimatedBack();
#line 1273
  WI_drawLF();
#line 1276
  V_DrawPatch((((32 + (int )star->width / 2) + 32 * ! dofrags) + 64) - (int )kills->width,
              50, 0, kills);
#line 1279
  V_DrawPatch((((32 + (int )star->width / 2) + 32 * ! dofrags) + 128) - (int )items->width,
              50, 0, items);
#line 1282
  V_DrawPatch((((32 + (int )star->width / 2) + 32 * ! dofrags) + 192) - (int )secret->width,
              50, 0, secret);
#line 1285
  if (dofrags) {
#line 1286
    V_DrawPatch((((32 + (int )star->width / 2) + 32 * ! dofrags) + 256) - (int )frags->width,
                50, 0, frags);
  }
#line 1290
  y___1 = 50 + (int )kills->height;
#line 1292
  i = 0;
  {
#line 1292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1292
    if (! (i < 4)) {
#line 1292
      goto while_break;
    }
#line 1294
    if (! playeringame[i]) {
#line 1295
      goto __Cont;
    }
#line 1297
    x___0 = (32 + (int )star->width / 2) + 32 * ! dofrags;
#line 1298
    V_DrawPatch(x___0 - (int )(p[i])->width, y___1, 0, p[i]);
#line 1300
    if (i == me) {
#line 1301
      V_DrawPatch(x___0 - (int )(p[i])->width, y___1, 0, star);
    }
#line 1303
    x___0 += 64;
#line 1304
    WI_drawPercent(x___0 - pwidth, y___1 + 10, cnt_kills[i]);
#line 1304
    x___0 += 64;
#line 1305
    WI_drawPercent(x___0 - pwidth, y___1 + 10, cnt_items[i]);
#line 1305
    x___0 += 64;
#line 1306
    WI_drawPercent(x___0 - pwidth, y___1 + 10, cnt_secret[i]);
#line 1306
    x___0 += 64;
#line 1308
    if (dofrags) {
#line 1309
      WI_drawNum(x___0, y___1 + 10, cnt_frags[i], -1);
    }
#line 1311
    y___1 += 33;
    __Cont: /* CIL Label */ 
#line 1292
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1314
  return;
}
}
#line 1316 "wi_stuff.c"
static int sp_state  ;
#line 1318 "wi_stuff.c"
void WI_initStats(void) 
{ 


  {
#line 1320
  state = (stateenum_t )0;
#line 1321
  acceleratestage = 0;
#line 1322
  sp_state = 1;
#line 1323
  cnt_secret[0] = -1;
#line 1323
  cnt_items[0] = cnt_secret[0];
#line 1323
  cnt_kills[0] = cnt_items[0];
#line 1324
  cnt_par = -1;
#line 1324
  cnt_time = cnt_par;
#line 1325
  cnt_pause = 35;
#line 1327
  WI_initAnimatedBack();
#line 1328
  return;
}
}
#line 1330 "wi_stuff.c"
void WI_updateStats(void) 
{ 


  {
#line 1333
  WI_updateAnimatedBack();
#line 1335
  if (acceleratestage) {
#line 1335
    if (sp_state != 10) {
#line 1337
      acceleratestage = 0;
#line 1338
      cnt_kills[0] = ((plrs + me)->skills * 100) / wbs->maxkills;
#line 1339
      cnt_items[0] = ((plrs + me)->sitems * 100) / wbs->maxitems;
#line 1340
      cnt_secret[0] = ((plrs + me)->ssecret * 100) / wbs->maxsecret;
#line 1341
      cnt_time = (plrs + me)->stime / 35;
#line 1342
      cnt_par = wbs->partime / 35;
#line 1343
      S_StartSound((void *)0, 82);
#line 1344
      sp_state = 10;
    } else {
#line 1335
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 1347
  if (sp_state == 2) {
#line 1349
    cnt_kills[0] += 2;
#line 1351
    if (! (bcnt & 3)) {
#line 1352
      S_StartSound((void *)0, 1);
    }
#line 1354
    if (cnt_kills[0] >= ((plrs + me)->skills * 100) / wbs->maxkills) {
#line 1356
      cnt_kills[0] = ((plrs + me)->skills * 100) / wbs->maxkills;
#line 1357
      S_StartSound((void *)0, 82);
#line 1358
      sp_state ++;
    }
  } else
#line 1361
  if (sp_state == 4) {
#line 1363
    cnt_items[0] += 2;
#line 1365
    if (! (bcnt & 3)) {
#line 1366
      S_StartSound((void *)0, 1);
    }
#line 1368
    if (cnt_items[0] >= ((plrs + me)->sitems * 100) / wbs->maxitems) {
#line 1370
      cnt_items[0] = ((plrs + me)->sitems * 100) / wbs->maxitems;
#line 1371
      S_StartSound((void *)0, 82);
#line 1372
      sp_state ++;
    }
  } else
#line 1375
  if (sp_state == 6) {
#line 1377
    cnt_secret[0] += 2;
#line 1379
    if (! (bcnt & 3)) {
#line 1380
      S_StartSound((void *)0, 1);
    }
#line 1382
    if (cnt_secret[0] >= ((plrs + me)->ssecret * 100) / wbs->maxsecret) {
#line 1384
      cnt_secret[0] = ((plrs + me)->ssecret * 100) / wbs->maxsecret;
#line 1385
      S_StartSound((void *)0, 82);
#line 1386
      sp_state ++;
    }
  } else
#line 1390
  if (sp_state == 8) {
#line 1392
    if (! (bcnt & 3)) {
#line 1393
      S_StartSound((void *)0, 1);
    }
#line 1395
    cnt_time += 3;
#line 1397
    if (cnt_time >= (plrs + me)->stime / 35) {
#line 1398
      cnt_time = (plrs + me)->stime / 35;
    }
#line 1400
    cnt_par += 3;
#line 1402
    if (cnt_par >= wbs->partime / 35) {
#line 1404
      cnt_par = wbs->partime / 35;
#line 1406
      if (cnt_time >= (plrs + me)->stime / 35) {
#line 1408
        S_StartSound((void *)0, 82);
#line 1409
        sp_state ++;
      }
    }
  } else
#line 1413
  if (sp_state == 10) {
#line 1415
    if (acceleratestage) {
#line 1417
      S_StartSound((void *)0, 3);
#line 1419
      if ((unsigned int )gamemode == 2U) {
#line 1420
        WI_initNoState();
      } else {
#line 1422
        WI_initShowNextLoc();
      }
    }
  } else
#line 1425
  if (sp_state & 1) {
#line 1427
    cnt_pause --;
#line 1427
    if (! cnt_pause) {
#line 1429
      sp_state ++;
#line 1430
      cnt_pause = 35;
    }
  }
#line 1434
  return;
}
}
#line 1436 "wi_stuff.c"
void WI_drawStats(void) 
{ 
  int lh ;

  {
#line 1441
  lh = (3 * (int )(num[0])->height) / 2;
#line 1443
  WI_slamBackground();
#line 1446
  WI_drawAnimatedBack();
#line 1448
  WI_drawLF();
#line 1450
  V_DrawPatch(50, 50, 0, kills);
#line 1451
  WI_drawPercent(270, 50, cnt_kills[0]);
#line 1453
  V_DrawPatch(50, 50 + lh, 0, items);
#line 1454
  WI_drawPercent(270, 50 + lh, cnt_items[0]);
#line 1456
  V_DrawPatch(50, 50 + 2 * lh, 0, sp_secret);
#line 1457
  WI_drawPercent(270, 50 + 2 * lh, cnt_secret[0]);
#line 1459
  V_DrawPatch(16, 168, 0, time___0);
#line 1460
  WI_drawTime(144, 168, cnt_time);
#line 1462
  if (wbs->epsd < 3) {
#line 1464
    V_DrawPatch(176, 168, 0, par);
#line 1465
    WI_drawTime(304, 168, cnt_par);
  }
#line 1468
  return;
}
}
#line 1470 "wi_stuff.c"
void WI_checkForAccelerate(void) 
{ 
  int i ;
  player_t *player ;

  {
#line 1476
  i = 0;
#line 1476
  player = players;
  {
#line 1476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1476
    if (! (i < 4)) {
#line 1476
      goto while_break;
    }
#line 1478
    if (playeringame[i]) {
#line 1480
      if ((int )player->cmd.buttons & 1) {
#line 1482
        if (! player->attackdown) {
#line 1483
          acceleratestage = 1;
        }
#line 1484
        player->attackdown = 1;
      } else {
#line 1487
        player->attackdown = 0;
      }
#line 1488
      if ((int )player->cmd.buttons & 2) {
#line 1490
        if (! player->usedown) {
#line 1491
          acceleratestage = 1;
        }
#line 1492
        player->usedown = 1;
      } else {
#line 1495
        player->usedown = 0;
      }
    }
#line 1476
    i ++;
#line 1476
    player ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1498
  return;
}
}
#line 1503 "wi_stuff.c"
void WI_Ticker(void) 
{ 


  {
#line 1506
  bcnt ++;
#line 1508
  if (bcnt == 1) {
#line 1511
    if ((unsigned int )gamemode == 2U) {
#line 1512
      S_ChangeMusic(67, 1);
    } else {
#line 1514
      S_ChangeMusic(28, 1);
    }
  }
#line 1517
  WI_checkForAccelerate();
  {
#line 1521
  if ((int )state == 0) {
#line 1521
    goto case_0;
  }
#line 1527
  if ((int )state == 1) {
#line 1527
    goto case_1;
  }
#line 1531
  if ((int )state == -1) {
#line 1531
    goto case_neg_1;
  }
#line 1519
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1522
  if (deathmatch) {
#line 1522
    WI_updateDeathmatchStats();
  } else
#line 1523
  if (netgame) {
#line 1523
    WI_updateNetgameStats();
  } else {
#line 1524
    WI_updateStats();
  }
#line 1525
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1528
  WI_updateShowNextLoc();
#line 1529
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 1532
  WI_updateNoState();
#line 1533
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1536
  return;
}
}
#line 1538 "wi_stuff.c"
void WI_loadData(void) 
{ 
  int i ;
  int j ;
  char name[9] ;
  anim_t___0 *a ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;

  {
#line 1545
  if ((unsigned int )gamemode == 2U) {
#line 1546
    strcpy((char * __restrict  )(name), (char const   * __restrict  )"INTERPIC");
  } else {
#line 1548
    sprintf((char * __restrict  )(name), (char const   * __restrict  )"WIMAP%d", wbs->epsd);
  }
#line 1550
  if ((unsigned int )gamemode == 3U) {
#line 1552
    if (wbs->epsd == 3) {
#line 1553
      strcpy((char * __restrict  )(name), (char const   * __restrict  )"INTERPIC");
    }
  }
#line 1557
  tmp = W_CacheLumpName(name, 101);
#line 1557
  bg = (patch_t *)tmp;
#line 1558
  V_DrawPatch(0, 0, 1, bg);
#line 1572
  if ((unsigned int )gamemode == 2U) {
#line 1574
    NUMCMAPS = 32;
#line 1575
    tmp___0 = Z_Malloc((int )(sizeof(patch_t *) * (unsigned long )NUMCMAPS), 1, (void *)0);
#line 1575
    lnames = (patch_t **)tmp___0;
#line 1577
    i = 0;
    {
#line 1577
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1577
      if (! (i < NUMCMAPS)) {
#line 1577
        goto while_break;
      }
#line 1579
      sprintf((char * __restrict  )(name), (char const   * __restrict  )"CWILV%2.2d",
              i);
#line 1580
      tmp___1 = W_CacheLumpName(name, 1);
#line 1580
      *(lnames + i) = (patch_t *)tmp___1;
#line 1577
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1585
    tmp___2 = Z_Malloc((int )(sizeof(patch_t *) * 9UL), 1, (void *)0);
#line 1585
    lnames = (patch_t **)tmp___2;
#line 1587
    i = 0;
    {
#line 1587
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1587
      if (! (i < 9)) {
#line 1587
        goto while_break___0;
      }
#line 1589
      sprintf((char * __restrict  )(name), (char const   * __restrict  )"WILV%d%d",
              wbs->epsd, i);
#line 1590
      tmp___3 = W_CacheLumpName(name, 1);
#line 1590
      *(lnames + i) = (patch_t *)tmp___3;
#line 1587
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1594
    tmp___4 = W_CacheLumpName("WIURH0", 1);
#line 1594
    yah[0] = (patch_t *)tmp___4;
#line 1597
    tmp___5 = W_CacheLumpName("WIURH1", 1);
#line 1597
    yah[1] = (patch_t *)tmp___5;
#line 1600
    tmp___6 = W_CacheLumpName("WISPLAT", 1);
#line 1600
    splat = (patch_t *)tmp___6;
#line 1602
    if (wbs->epsd < 3) {
#line 1604
      j = 0;
      {
#line 1604
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1604
        if (! (j < NUMANIMS[wbs->epsd])) {
#line 1604
          goto while_break___1;
        }
#line 1606
        a = anims___0[wbs->epsd] + j;
#line 1607
        i = 0;
        {
#line 1607
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1607
          if (! (i < a->nanims)) {
#line 1607
            goto while_break___2;
          }
#line 1610
          if (wbs->epsd != 1) {
#line 1610
            goto _L;
          } else
#line 1610
          if (j != 8) {
            _L: /* CIL Label */ 
#line 1613
            sprintf((char * __restrict  )(name), (char const   * __restrict  )"WIA%d%.2d%.2d",
                    wbs->epsd, j, i);
#line 1614
            tmp___7 = W_CacheLumpName(name, 1);
#line 1614
            a->p[i] = (patch_t *)tmp___7;
          } else {
#line 1619
            a->p[i] = (anims___0[1] + 4)->p[i];
          }
#line 1607
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1604
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 1627
  tmp___8 = W_CacheLumpName("WIMINUS", 1);
#line 1627
  wiminus = (patch_t *)tmp___8;
#line 1629
  i = 0;
  {
#line 1629
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1629
    if (! (i < 10)) {
#line 1629
      goto while_break___3;
    }
#line 1632
    sprintf((char * __restrict  )(name), (char const   * __restrict  )"WINUM%d", i);
#line 1633
    tmp___9 = W_CacheLumpName(name, 1);
#line 1633
    num[i] = (patch_t *)tmp___9;
#line 1629
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1637
  tmp___10 = W_CacheLumpName("WIPCNT", 1);
#line 1637
  percent = (patch_t *)tmp___10;
#line 1640
  tmp___11 = W_CacheLumpName("WIF", 1);
#line 1640
  finished = (patch_t *)tmp___11;
#line 1643
  tmp___12 = W_CacheLumpName("WIENTER", 1);
#line 1643
  entering = (patch_t *)tmp___12;
#line 1646
  tmp___13 = W_CacheLumpName("WIOSTK", 1);
#line 1646
  kills = (patch_t *)tmp___13;
#line 1649
  tmp___14 = W_CacheLumpName("WIOSTS", 1);
#line 1649
  secret = (patch_t *)tmp___14;
#line 1652
  tmp___15 = W_CacheLumpName("WISCRT2", 1);
#line 1652
  sp_secret = (patch_t *)tmp___15;
#line 1655
  if (1) {
#line 1658
    if (netgame) {
#line 1658
      if (! deathmatch) {
#line 1659
        tmp___16 = W_CacheLumpName("WIOBJ", 1);
#line 1659
        items = (patch_t *)tmp___16;
      } else {
#line 1658
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1661
      tmp___17 = W_CacheLumpName("WIOSTI", 1);
#line 1661
      items = (patch_t *)tmp___17;
    }
  } else {
#line 1663
    tmp___18 = W_CacheLumpName("WIOSTI", 1);
#line 1663
    items = (patch_t *)tmp___18;
  }
#line 1666
  tmp___19 = W_CacheLumpName("WIFRGS", 1);
#line 1666
  frags = (patch_t *)tmp___19;
#line 1669
  tmp___20 = W_CacheLumpName("WICOLON", 1);
#line 1669
  colon = (patch_t *)tmp___20;
#line 1672
  tmp___21 = W_CacheLumpName("WITIME", 1);
#line 1672
  time___0 = (patch_t *)tmp___21;
#line 1675
  tmp___22 = W_CacheLumpName("WISUCKS", 1);
#line 1675
  sucks = (patch_t *)tmp___22;
#line 1678
  tmp___23 = W_CacheLumpName("WIPAR", 1);
#line 1678
  par = (patch_t *)tmp___23;
#line 1681
  tmp___24 = W_CacheLumpName("WIKILRS", 1);
#line 1681
  killers = (patch_t *)tmp___24;
#line 1684
  tmp___25 = W_CacheLumpName("WIVCTMS", 1);
#line 1684
  victims = (patch_t *)tmp___25;
#line 1687
  tmp___26 = W_CacheLumpName("WIMSTT", 1);
#line 1687
  total = (patch_t *)tmp___26;
#line 1690
  tmp___27 = W_CacheLumpName("STFST01", 1);
#line 1690
  star = (patch_t *)tmp___27;
#line 1693
  tmp___28 = W_CacheLumpName("STFDEAD0", 1);
#line 1693
  bstar = (patch_t *)tmp___28;
#line 1695
  i = 0;
  {
#line 1695
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1695
    if (! (i < 4)) {
#line 1695
      goto while_break___4;
    }
#line 1698
    sprintf((char * __restrict  )(name), (char const   * __restrict  )"STPB%d", i);
#line 1699
    tmp___29 = W_CacheLumpName(name, 1);
#line 1699
    p[i] = (patch_t *)tmp___29;
#line 1702
    sprintf((char * __restrict  )(name), (char const   * __restrict  )"WIBP%d", i + 1);
#line 1703
    tmp___30 = W_CacheLumpName(name, 1);
#line 1703
    bp[i] = (patch_t *)tmp___30;
#line 1695
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1706
  return;
}
}
#line 1708 "wi_stuff.c"
void WI_unloadData(void) 
{ 
  int i ;
  int j ;

  {
#line 1713
  if (((memblock_t *)((byte *)wiminus - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1713
    I_Error("Z_CT at wi_stuff.c:%i", 1713);
  }
#line 1713
  Z_ChangeTag2((void *)wiminus, 101);
#line 1715
  i = 0;
  {
#line 1715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1715
    if (! (i < 10)) {
#line 1715
      goto while_break;
    }
#line 1716
    if (((memblock_t *)((byte *)num[i] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1716
      I_Error("Z_CT at wi_stuff.c:%i", 1716);
    }
#line 1716
    Z_ChangeTag2((void *)num[i], 101);
#line 1715
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1718
  if ((unsigned int )gamemode == 2U) {
#line 1720
    i = 0;
    {
#line 1720
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1720
      if (! (i < NUMCMAPS)) {
#line 1720
        goto while_break___0;
      }
#line 1721
      if (((memblock_t *)((byte *)*(lnames + i) - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1721
        I_Error("Z_CT at wi_stuff.c:%i", 1721);
      }
#line 1721
      Z_ChangeTag2((void *)*(lnames + i), 101);
#line 1720
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1725
    if (((memblock_t *)((byte *)yah[0] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1725
      I_Error("Z_CT at wi_stuff.c:%i", 1725);
    }
#line 1725
    Z_ChangeTag2((void *)yah[0], 101);
#line 1726
    if (((memblock_t *)((byte *)yah[1] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1726
      I_Error("Z_CT at wi_stuff.c:%i", 1726);
    }
#line 1726
    Z_ChangeTag2((void *)yah[1], 101);
#line 1728
    if (((memblock_t *)((byte *)splat - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1728
      I_Error("Z_CT at wi_stuff.c:%i", 1728);
    }
#line 1728
    Z_ChangeTag2((void *)splat, 101);
#line 1730
    i = 0;
    {
#line 1730
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1730
      if (! (i < 9)) {
#line 1730
        goto while_break___1;
      }
#line 1731
      if (((memblock_t *)((byte *)*(lnames + i) - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1731
        I_Error("Z_CT at wi_stuff.c:%i", 1731);
      }
#line 1731
      Z_ChangeTag2((void *)*(lnames + i), 101);
#line 1730
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1733
    if (wbs->epsd < 3) {
#line 1735
      j = 0;
      {
#line 1735
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1735
        if (! (j < NUMANIMS[wbs->epsd])) {
#line 1735
          goto while_break___2;
        }
#line 1737
        if (wbs->epsd != 1) {
#line 1737
          goto _L;
        } else
#line 1737
        if (j != 8) {
          _L: /* CIL Label */ 
#line 1738
          i = 0;
          {
#line 1738
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1738
            if (! (i < (anims___0[wbs->epsd] + j)->nanims)) {
#line 1738
              goto while_break___3;
            }
#line 1739
            if (((memblock_t *)((byte *)(anims___0[wbs->epsd] + j)->p[i] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1739
              I_Error("Z_CT at wi_stuff.c:%i", 1739);
            }
#line 1739
            Z_ChangeTag2((void *)(anims___0[wbs->epsd] + j)->p[i], 101);
#line 1738
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 1735
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 1744
  Z_Free((void *)lnames);
#line 1746
  if (((memblock_t *)((byte *)percent - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1746
    I_Error("Z_CT at wi_stuff.c:%i", 1746);
  }
#line 1746
  Z_ChangeTag2((void *)percent, 101);
#line 1747
  if (((memblock_t *)((byte *)colon - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1747
    I_Error("Z_CT at wi_stuff.c:%i", 1747);
  }
#line 1747
  Z_ChangeTag2((void *)colon, 101);
#line 1748
  if (((memblock_t *)((byte *)finished - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1748
    I_Error("Z_CT at wi_stuff.c:%i", 1748);
  }
#line 1748
  Z_ChangeTag2((void *)finished, 101);
#line 1749
  if (((memblock_t *)((byte *)entering - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1749
    I_Error("Z_CT at wi_stuff.c:%i", 1749);
  }
#line 1749
  Z_ChangeTag2((void *)entering, 101);
#line 1750
  if (((memblock_t *)((byte *)kills - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1750
    I_Error("Z_CT at wi_stuff.c:%i", 1750);
  }
#line 1750
  Z_ChangeTag2((void *)kills, 101);
#line 1751
  if (((memblock_t *)((byte *)secret - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1751
    I_Error("Z_CT at wi_stuff.c:%i", 1751);
  }
#line 1751
  Z_ChangeTag2((void *)secret, 101);
#line 1752
  if (((memblock_t *)((byte *)sp_secret - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1752
    I_Error("Z_CT at wi_stuff.c:%i", 1752);
  }
#line 1752
  Z_ChangeTag2((void *)sp_secret, 101);
#line 1753
  if (((memblock_t *)((byte *)items - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1753
    I_Error("Z_CT at wi_stuff.c:%i", 1753);
  }
#line 1753
  Z_ChangeTag2((void *)items, 101);
#line 1754
  if (((memblock_t *)((byte *)frags - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1754
    I_Error("Z_CT at wi_stuff.c:%i", 1754);
  }
#line 1754
  Z_ChangeTag2((void *)frags, 101);
#line 1755
  if (((memblock_t *)((byte *)time___0 - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1755
    I_Error("Z_CT at wi_stuff.c:%i", 1755);
  }
#line 1755
  Z_ChangeTag2((void *)time___0, 101);
#line 1756
  if (((memblock_t *)((byte *)sucks - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1756
    I_Error("Z_CT at wi_stuff.c:%i", 1756);
  }
#line 1756
  Z_ChangeTag2((void *)sucks, 101);
#line 1757
  if (((memblock_t *)((byte *)par - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1757
    I_Error("Z_CT at wi_stuff.c:%i", 1757);
  }
#line 1757
  Z_ChangeTag2((void *)par, 101);
#line 1759
  if (((memblock_t *)((byte *)victims - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1759
    I_Error("Z_CT at wi_stuff.c:%i", 1759);
  }
#line 1759
  Z_ChangeTag2((void *)victims, 101);
#line 1760
  if (((memblock_t *)((byte *)killers - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1760
    I_Error("Z_CT at wi_stuff.c:%i", 1760);
  }
#line 1760
  Z_ChangeTag2((void *)killers, 101);
#line 1761
  if (((memblock_t *)((byte *)total - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1761
    I_Error("Z_CT at wi_stuff.c:%i", 1761);
  }
#line 1761
  Z_ChangeTag2((void *)total, 101);
#line 1765
  i = 0;
  {
#line 1765
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1765
    if (! (i < 4)) {
#line 1765
      goto while_break___4;
    }
#line 1766
    if (((memblock_t *)((byte *)p[i] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1766
      I_Error("Z_CT at wi_stuff.c:%i", 1766);
    }
#line 1766
    Z_ChangeTag2((void *)p[i], 101);
#line 1765
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1768
  i = 0;
  {
#line 1768
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1768
    if (! (i < 4)) {
#line 1768
      goto while_break___5;
    }
#line 1769
    if (((memblock_t *)((byte *)bp[i] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1769
      I_Error("Z_CT at wi_stuff.c:%i", 1769);
    }
#line 1769
    Z_ChangeTag2((void *)bp[i], 101);
#line 1768
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1770
  return;
}
}
#line 1772 "wi_stuff.c"
void WI_Drawer(void) 
{ 


  {
  {
#line 1776
  if ((int )state == 0) {
#line 1776
    goto case_0;
  }
#line 1785
  if ((int )state == 1) {
#line 1785
    goto case_1;
  }
#line 1789
  if ((int )state == -1) {
#line 1789
    goto case_neg_1;
  }
#line 1774
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1777
  if (deathmatch) {
#line 1778
    WI_drawDeathmatchStats();
  } else
#line 1779
  if (netgame) {
#line 1780
    WI_drawNetgameStats();
  } else {
#line 1782
    WI_drawStats();
  }
#line 1783
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1786
  WI_drawShowNextLoc();
#line 1787
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 1790
  WI_drawNoState();
#line 1791
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1793
  return;
}
}
#line 1796 "wi_stuff.c"
void WI_initVariables(wbstartstruct_t *wbstartstruct ) 
{ 


  {
#line 1799
  wbs = wbstartstruct;
#line 1818
  acceleratestage = 0;
#line 1819
  bcnt = 0;
#line 1819
  cnt = bcnt;
#line 1820
  firstrefresh = 1;
#line 1821
  me = wbs->pnum;
#line 1822
  plrs = wbs->plyr;
#line 1824
  if (! wbs->maxkills) {
#line 1825
    wbs->maxkills = 1;
  }
#line 1827
  if (! wbs->maxitems) {
#line 1828
    wbs->maxitems = 1;
  }
#line 1830
  if (! wbs->maxsecret) {
#line 1831
    wbs->maxsecret = 1;
  }
#line 1833
  if ((unsigned int )gamemode != 3U) {
#line 1834
    if (wbs->epsd > 2) {
#line 1835
      wbs->epsd -= 3;
    }
  }
#line 1836
  return;
}
}
#line 1838 "wi_stuff.c"
void WI_Start(wbstartstruct_t *wbstartstruct ) 
{ 


  {
#line 1841
  WI_initVariables(wbstartstruct);
#line 1842
  WI_loadData();
#line 1844
  if (deathmatch) {
#line 1845
    WI_initDeathmatchStats();
  } else
#line 1846
  if (netgame) {
#line 1847
    WI_initNetgameStats();
  } else {
#line 1849
    WI_initStats();
  }
#line 1850
  return;
}
}
#line 27 "v_video.c"
static char const   rcsid___51[50]  = 
#line 27 "v_video.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'v',      (char const   )'_',      (char const   )'v', 
        (char const   )'i',      (char const   )'d',      (char const   )'e',      (char const   )'o', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )' ', 
        (char const   )'2',      (char const   )'2',      (char const   )':',      (char const   )'4', 
        (char const   )'5',      (char const   )':',      (char const   )'1',      (char const   )'3', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 47 "v_video.h"
byte *screens[5]  ;
#line 49 "v_video.h"
int dirtybox[4]  ;
#line 52 "v_video.h"
int usegamma  ;
#line 51 "v_video.c"
byte gammatable[5][256]  = { {        (byte )1,        (byte )2,        (byte )3,        (byte )4, 
            (byte )5,        (byte )6,        (byte )7,        (byte )8, 
            (byte )9,        (byte )10,        (byte )11,        (byte )12, 
            (byte )13,        (byte )14,        (byte )15,        (byte )16, 
            (byte )17,        (byte )18,        (byte )19,        (byte )20, 
            (byte )21,        (byte )22,        (byte )23,        (byte )24, 
            (byte )25,        (byte )26,        (byte )27,        (byte )28, 
            (byte )29,        (byte )30,        (byte )31,        (byte )32, 
            (byte )33,        (byte )34,        (byte )35,        (byte )36, 
            (byte )37,        (byte )38,        (byte )39,        (byte )40, 
            (byte )41,        (byte )42,        (byte )43,        (byte )44, 
            (byte )45,        (byte )46,        (byte )47,        (byte )48, 
            (byte )49,        (byte )50,        (byte )51,        (byte )52, 
            (byte )53,        (byte )54,        (byte )55,        (byte )56, 
            (byte )57,        (byte )58,        (byte )59,        (byte )60, 
            (byte )61,        (byte )62,        (byte )63,        (byte )64, 
            (byte )65,        (byte )66,        (byte )67,        (byte )68, 
            (byte )69,        (byte )70,        (byte )71,        (byte )72, 
            (byte )73,        (byte )74,        (byte )75,        (byte )76, 
            (byte )77,        (byte )78,        (byte )79,        (byte )80, 
            (byte )81,        (byte )82,        (byte )83,        (byte )84, 
            (byte )85,        (byte )86,        (byte )87,        (byte )88, 
            (byte )89,        (byte )90,        (byte )91,        (byte )92, 
            (byte )93,        (byte )94,        (byte )95,        (byte )96, 
            (byte )97,        (byte )98,        (byte )99,        (byte )100, 
            (byte )101,        (byte )102,        (byte )103,        (byte )104, 
            (byte )105,        (byte )106,        (byte )107,        (byte )108, 
            (byte )109,        (byte )110,        (byte )111,        (byte )112, 
            (byte )113,        (byte )114,        (byte )115,        (byte )116, 
            (byte )117,        (byte )118,        (byte )119,        (byte )120, 
            (byte )121,        (byte )122,        (byte )123,        (byte )124, 
            (byte )125,        (byte )126,        (byte )127,        (byte )128, 
            (byte )128,        (byte )129,        (byte )130,        (byte )131, 
            (byte )132,        (byte )133,        (byte )134,        (byte )135, 
            (byte )136,        (byte )137,        (byte )138,        (byte )139, 
            (byte )140,        (byte )141,        (byte )142,        (byte )143, 
            (byte )144,        (byte )145,        (byte )146,        (byte )147, 
            (byte )148,        (byte )149,        (byte )150,        (byte )151, 
            (byte )152,        (byte )153,        (byte )154,        (byte )155, 
            (byte )156,        (byte )157,        (byte )158,        (byte )159, 
            (byte )160,        (byte )161,        (byte )162,        (byte )163, 
            (byte )164,        (byte )165,        (byte )166,        (byte )167, 
            (byte )168,        (byte )169,        (byte )170,        (byte )171, 
            (byte )172,        (byte )173,        (byte )174,        (byte )175, 
            (byte )176,        (byte )177,        (byte )178,        (byte )179, 
            (byte )180,        (byte )181,        (byte )182,        (byte )183, 
            (byte )184,        (byte )185,        (byte )186,        (byte )187, 
            (byte )188,        (byte )189,        (byte )190,        (byte )191, 
            (byte )192,        (byte )193,        (byte )194,        (byte )195, 
            (byte )196,        (byte )197,        (byte )198,        (byte )199, 
            (byte )200,        (byte )201,        (byte )202,        (byte )203, 
            (byte )204,        (byte )205,        (byte )206,        (byte )207, 
            (byte )208,        (byte )209,        (byte )210,        (byte )211, 
            (byte )212,        (byte )213,        (byte )214,        (byte )215, 
            (byte )216,        (byte )217,        (byte )218,        (byte )219, 
            (byte )220,        (byte )221,        (byte )222,        (byte )223, 
            (byte )224,        (byte )225,        (byte )226,        (byte )227, 
            (byte )228,        (byte )229,        (byte )230,        (byte )231, 
            (byte )232,        (byte )233,        (byte )234,        (byte )235, 
            (byte )236,        (byte )237,        (byte )238,        (byte )239, 
            (byte )240,        (byte )241,        (byte )242,        (byte )243, 
            (byte )244,        (byte )245,        (byte )246,        (byte )247, 
            (byte )248,        (byte )249,        (byte )250,        (byte )251, 
            (byte )252,        (byte )253,        (byte )254,        (byte )255}, 
   {        (byte )2,        (byte )4,        (byte )5,        (byte )7, 
            (byte )8,        (byte )10,        (byte )11,        (byte )12, 
            (byte )14,        (byte )15,        (byte )16,        (byte )18, 
            (byte )19,        (byte )20,        (byte )21,        (byte )23, 
            (byte )24,        (byte )25,        (byte )26,        (byte )27, 
            (byte )29,        (byte )30,        (byte )31,        (byte )32, 
            (byte )33,        (byte )34,        (byte )36,        (byte )37, 
            (byte )38,        (byte )39,        (byte )40,        (byte )41, 
            (byte )42,        (byte )44,        (byte )45,        (byte )46, 
            (byte )47,        (byte )48,        (byte )49,        (byte )50, 
            (byte )51,        (byte )52,        (byte )54,        (byte )55, 
            (byte )56,        (byte )57,        (byte )58,        (byte )59, 
            (byte )60,        (byte )61,        (byte )62,        (byte )63, 
            (byte )64,        (byte )65,        (byte )66,        (byte )67, 
            (byte )69,        (byte )70,        (byte )71,        (byte )72, 
            (byte )73,        (byte )74,        (byte )75,        (byte )76, 
            (byte )77,        (byte )78,        (byte )79,        (byte )80, 
            (byte )81,        (byte )82,        (byte )83,        (byte )84, 
            (byte )85,        (byte )86,        (byte )87,        (byte )88, 
            (byte )89,        (byte )90,        (byte )91,        (byte )92, 
            (byte )93,        (byte )94,        (byte )95,        (byte )96, 
            (byte )97,        (byte )98,        (byte )99,        (byte )100, 
            (byte )101,        (byte )102,        (byte )103,        (byte )104, 
            (byte )105,        (byte )106,        (byte )107,        (byte )108, 
            (byte )109,        (byte )110,        (byte )111,        (byte )112, 
            (byte )113,        (byte )114,        (byte )115,        (byte )116, 
            (byte )117,        (byte )118,        (byte )119,        (byte )120, 
            (byte )121,        (byte )122,        (byte )123,        (byte )124, 
            (byte )125,        (byte )126,        (byte )127,        (byte )128, 
            (byte )129,        (byte )129,        (byte )130,        (byte )131, 
            (byte )132,        (byte )133,        (byte )134,        (byte )135, 
            (byte )136,        (byte )137,        (byte )138,        (byte )139, 
            (byte )140,        (byte )141,        (byte )142,        (byte )143, 
            (byte )144,        (byte )145,        (byte )146,        (byte )147, 
            (byte )148,        (byte )148,        (byte )149,        (byte )150, 
            (byte )151,        (byte )152,        (byte )153,        (byte )154, 
            (byte )155,        (byte )156,        (byte )157,        (byte )158, 
            (byte )159,        (byte )160,        (byte )161,        (byte )162, 
            (byte )163,        (byte )163,        (byte )164,        (byte )165, 
            (byte )166,        (byte )167,        (byte )168,        (byte )169, 
            (byte )170,        (byte )171,        (byte )172,        (byte )173, 
            (byte )174,        (byte )175,        (byte )175,        (byte )176, 
            (byte )177,        (byte )178,        (byte )179,        (byte )180, 
            (byte )181,        (byte )182,        (byte )183,        (byte )184, 
            (byte )185,        (byte )186,        (byte )186,        (byte )187, 
            (byte )188,        (byte )189,        (byte )190,        (byte )191, 
            (byte )192,        (byte )193,        (byte )194,        (byte )195, 
            (byte )196,        (byte )196,        (byte )197,        (byte )198, 
            (byte )199,        (byte )200,        (byte )201,        (byte )202, 
            (byte )203,        (byte )204,        (byte )205,        (byte )205, 
            (byte )206,        (byte )207,        (byte )208,        (byte )209, 
            (byte )210,        (byte )211,        (byte )212,        (byte )213, 
            (byte )214,        (byte )214,        (byte )215,        (byte )216, 
            (byte )217,        (byte )218,        (byte )219,        (byte )220, 
            (byte )221,        (byte )222,        (byte )222,        (byte )223, 
            (byte )224,        (byte )225,        (byte )226,        (byte )227, 
            (byte )228,        (byte )229,        (byte )230,        (byte )230, 
            (byte )231,        (byte )232,        (byte )233,        (byte )234, 
            (byte )235,        (byte )236,        (byte )237,        (byte )237, 
            (byte )238,        (byte )239,        (byte )240,        (byte )241, 
            (byte )242,        (byte )243,        (byte )244,        (byte )245, 
            (byte )245,        (byte )246,        (byte )247,        (byte )248, 
            (byte )249,        (byte )250,        (byte )251,        (byte )252, 
            (byte )252,        (byte )253,        (byte )254,        (byte )255}, 
   {        (byte )4,        (byte )7,        (byte )9,        (byte )11, 
            (byte )13,        (byte )15,        (byte )17,        (byte )19, 
            (byte )21,        (byte )22,        (byte )24,        (byte )26, 
            (byte )27,        (byte )29,        (byte )30,        (byte )32, 
            (byte )33,        (byte )35,        (byte )36,        (byte )38, 
            (byte )39,        (byte )40,        (byte )42,        (byte )43, 
            (byte )45,        (byte )46,        (byte )47,        (byte )48, 
            (byte )50,        (byte )51,        (byte )52,        (byte )54, 
            (byte )55,        (byte )56,        (byte )57,        (byte )59, 
            (byte )60,        (byte )61,        (byte )62,        (byte )63, 
            (byte )65,        (byte )66,        (byte )67,        (byte )68, 
            (byte )69,        (byte )70,        (byte )72,        (byte )73, 
            (byte )74,        (byte )75,        (byte )76,        (byte )77, 
            (byte )78,        (byte )79,        (byte )80,        (byte )82, 
            (byte )83,        (byte )84,        (byte )85,        (byte )86, 
            (byte )87,        (byte )88,        (byte )89,        (byte )90, 
            (byte )91,        (byte )92,        (byte )93,        (byte )94, 
            (byte )95,        (byte )96,        (byte )97,        (byte )98, 
            (byte )100,        (byte )101,        (byte )102,        (byte )103, 
            (byte )104,        (byte )105,        (byte )106,        (byte )107, 
            (byte )108,        (byte )109,        (byte )110,        (byte )111, 
            (byte )112,        (byte )113,        (byte )114,        (byte )114, 
            (byte )115,        (byte )116,        (byte )117,        (byte )118, 
            (byte )119,        (byte )120,        (byte )121,        (byte )122, 
            (byte )123,        (byte )124,        (byte )125,        (byte )126, 
            (byte )127,        (byte )128,        (byte )129,        (byte )130, 
            (byte )131,        (byte )132,        (byte )133,        (byte )133, 
            (byte )134,        (byte )135,        (byte )136,        (byte )137, 
            (byte )138,        (byte )139,        (byte )140,        (byte )141, 
            (byte )142,        (byte )143,        (byte )144,        (byte )144, 
            (byte )145,        (byte )146,        (byte )147,        (byte )148, 
            (byte )149,        (byte )150,        (byte )151,        (byte )152, 
            (byte )153,        (byte )153,        (byte )154,        (byte )155, 
            (byte )156,        (byte )157,        (byte )158,        (byte )159, 
            (byte )160,        (byte )160,        (byte )161,        (byte )162, 
            (byte )163,        (byte )164,        (byte )165,        (byte )166, 
            (byte )166,        (byte )167,        (byte )168,        (byte )169, 
            (byte )170,        (byte )171,        (byte )172,        (byte )172, 
            (byte )173,        (byte )174,        (byte )175,        (byte )176, 
            (byte )177,        (byte )178,        (byte )178,        (byte )179, 
            (byte )180,        (byte )181,        (byte )182,        (byte )183, 
            (byte )183,        (byte )184,        (byte )185,        (byte )186, 
            (byte )187,        (byte )188,        (byte )188,        (byte )189, 
            (byte )190,        (byte )191,        (byte )192,        (byte )193, 
            (byte )193,        (byte )194,        (byte )195,        (byte )196, 
            (byte )197,        (byte )197,        (byte )198,        (byte )199, 
            (byte )200,        (byte )201,        (byte )201,        (byte )202, 
            (byte )203,        (byte )204,        (byte )205,        (byte )206, 
            (byte )206,        (byte )207,        (byte )208,        (byte )209, 
            (byte )210,        (byte )210,        (byte )211,        (byte )212, 
            (byte )213,        (byte )213,        (byte )214,        (byte )215, 
            (byte )216,        (byte )217,        (byte )217,        (byte )218, 
            (byte )219,        (byte )220,        (byte )221,        (byte )221, 
            (byte )222,        (byte )223,        (byte )224,        (byte )224, 
            (byte )225,        (byte )226,        (byte )227,        (byte )228, 
            (byte )228,        (byte )229,        (byte )230,        (byte )231, 
            (byte )231,        (byte )232,        (byte )233,        (byte )234, 
            (byte )235,        (byte )235,        (byte )236,        (byte )237, 
            (byte )238,        (byte )238,        (byte )239,        (byte )240, 
            (byte )241,        (byte )241,        (byte )242,        (byte )243, 
            (byte )244,        (byte )244,        (byte )245,        (byte )246, 
            (byte )247,        (byte )247,        (byte )248,        (byte )249, 
            (byte )250,        (byte )251,        (byte )251,        (byte )252, 
            (byte )253,        (byte )254,        (byte )254,        (byte )255}, 
   {        (byte )8,        (byte )12,        (byte )16,        (byte )19, 
            (byte )22,        (byte )24,        (byte )27,        (byte )29, 
            (byte )31,        (byte )34,        (byte )36,        (byte )38, 
            (byte )40,        (byte )41,        (byte )43,        (byte )45, 
            (byte )47,        (byte )49,        (byte )50,        (byte )52, 
            (byte )53,        (byte )55,        (byte )57,        (byte )58, 
            (byte )60,        (byte )61,        (byte )63,        (byte )64, 
            (byte )65,        (byte )67,        (byte )68,        (byte )70, 
            (byte )71,        (byte )72,        (byte )74,        (byte )75, 
            (byte )76,        (byte )77,        (byte )79,        (byte )80, 
            (byte )81,        (byte )82,        (byte )84,        (byte )85, 
            (byte )86,        (byte )87,        (byte )88,        (byte )90, 
            (byte )91,        (byte )92,        (byte )93,        (byte )94, 
            (byte )95,        (byte )96,        (byte )98,        (byte )99, 
            (byte )100,        (byte )101,        (byte )102,        (byte )103, 
            (byte )104,        (byte )105,        (byte )106,        (byte )107, 
            (byte )108,        (byte )109,        (byte )110,        (byte )111, 
            (byte )112,        (byte )113,        (byte )114,        (byte )115, 
            (byte )116,        (byte )117,        (byte )118,        (byte )119, 
            (byte )120,        (byte )121,        (byte )122,        (byte )123, 
            (byte )124,        (byte )125,        (byte )126,        (byte )127, 
            (byte )128,        (byte )129,        (byte )130,        (byte )131, 
            (byte )132,        (byte )133,        (byte )134,        (byte )135, 
            (byte )135,        (byte )136,        (byte )137,        (byte )138, 
            (byte )139,        (byte )140,        (byte )141,        (byte )142, 
            (byte )143,        (byte )143,        (byte )144,        (byte )145, 
            (byte )146,        (byte )147,        (byte )148,        (byte )149, 
            (byte )150,        (byte )150,        (byte )151,        (byte )152, 
            (byte )153,        (byte )154,        (byte )155,        (byte )155, 
            (byte )156,        (byte )157,        (byte )158,        (byte )159, 
            (byte )160,        (byte )160,        (byte )161,        (byte )162, 
            (byte )163,        (byte )164,        (byte )165,        (byte )165, 
            (byte )166,        (byte )167,        (byte )168,        (byte )169, 
            (byte )169,        (byte )170,        (byte )171,        (byte )172, 
            (byte )173,        (byte )173,        (byte )174,        (byte )175, 
            (byte )176,        (byte )176,        (byte )177,        (byte )178, 
            (byte )179,        (byte )180,        (byte )180,        (byte )181, 
            (byte )182,        (byte )183,        (byte )183,        (byte )184, 
            (byte )185,        (byte )186,        (byte )186,        (byte )187, 
            (byte )188,        (byte )189,        (byte )189,        (byte )190, 
            (byte )191,        (byte )192,        (byte )192,        (byte )193, 
            (byte )194,        (byte )195,        (byte )195,        (byte )196, 
            (byte )197,        (byte )197,        (byte )198,        (byte )199, 
            (byte )200,        (byte )200,        (byte )201,        (byte )202, 
            (byte )202,        (byte )203,        (byte )204,        (byte )205, 
            (byte )205,        (byte )206,        (byte )207,        (byte )207, 
            (byte )208,        (byte )209,        (byte )210,        (byte )210, 
            (byte )211,        (byte )212,        (byte )212,        (byte )213, 
            (byte )214,        (byte )214,        (byte )215,        (byte )216, 
            (byte )216,        (byte )217,        (byte )218,        (byte )219, 
            (byte )219,        (byte )220,        (byte )221,        (byte )221, 
            (byte )222,        (byte )223,        (byte )223,        (byte )224, 
            (byte )225,        (byte )225,        (byte )226,        (byte )227, 
            (byte )227,        (byte )228,        (byte )229,        (byte )229, 
            (byte )230,        (byte )231,        (byte )231,        (byte )232, 
            (byte )233,        (byte )233,        (byte )234,        (byte )235, 
            (byte )235,        (byte )236,        (byte )237,        (byte )237, 
            (byte )238,        (byte )238,        (byte )239,        (byte )240, 
            (byte )240,        (byte )241,        (byte )242,        (byte )242, 
            (byte )243,        (byte )244,        (byte )244,        (byte )245, 
            (byte )246,        (byte )246,        (byte )247,        (byte )247, 
            (byte )248,        (byte )249,        (byte )249,        (byte )250, 
            (byte )251,        (byte )251,        (byte )252,        (byte )253, 
            (byte )253,        (byte )254,        (byte )254,        (byte )255}, 
   {        (byte )16,        (byte )23,        (byte )28,        (byte )32, 
            (byte )36,        (byte )39,        (byte )42,        (byte )45, 
            (byte )48,        (byte )50,        (byte )53,        (byte )55, 
            (byte )57,        (byte )60,        (byte )62,        (byte )64, 
            (byte )66,        (byte )68,        (byte )69,        (byte )71, 
            (byte )73,        (byte )75,        (byte )76,        (byte )78, 
            (byte )80,        (byte )81,        (byte )83,        (byte )84, 
            (byte )86,        (byte )87,        (byte )89,        (byte )90, 
            (byte )92,        (byte )93,        (byte )94,        (byte )96, 
            (byte )97,        (byte )98,        (byte )100,        (byte )101, 
            (byte )102,        (byte )103,        (byte )105,        (byte )106, 
            (byte )107,        (byte )108,        (byte )109,        (byte )110, 
            (byte )112,        (byte )113,        (byte )114,        (byte )115, 
            (byte )116,        (byte )117,        (byte )118,        (byte )119, 
            (byte )120,        (byte )121,        (byte )122,        (byte )123, 
            (byte )124,        (byte )125,        (byte )126,        (byte )128, 
            (byte )128,        (byte )129,        (byte )130,        (byte )131, 
            (byte )132,        (byte )133,        (byte )134,        (byte )135, 
            (byte )136,        (byte )137,        (byte )138,        (byte )139, 
            (byte )140,        (byte )141,        (byte )142,        (byte )143, 
            (byte )143,        (byte )144,        (byte )145,        (byte )146, 
            (byte )147,        (byte )148,        (byte )149,        (byte )150, 
            (byte )150,        (byte )151,        (byte )152,        (byte )153, 
            (byte )154,        (byte )155,        (byte )155,        (byte )156, 
            (byte )157,        (byte )158,        (byte )159,        (byte )159, 
            (byte )160,        (byte )161,        (byte )162,        (byte )163, 
            (byte )163,        (byte )164,        (byte )165,        (byte )166, 
            (byte )166,        (byte )167,        (byte )168,        (byte )169, 
            (byte )169,        (byte )170,        (byte )171,        (byte )172, 
            (byte )172,        (byte )173,        (byte )174,        (byte )175, 
            (byte )175,        (byte )176,        (byte )177,        (byte )177, 
            (byte )178,        (byte )179,        (byte )180,        (byte )180, 
            (byte )181,        (byte )182,        (byte )182,        (byte )183, 
            (byte )184,        (byte )184,        (byte )185,        (byte )186, 
            (byte )187,        (byte )187,        (byte )188,        (byte )189, 
            (byte )189,        (byte )190,        (byte )191,        (byte )191, 
            (byte )192,        (byte )193,        (byte )193,        (byte )194, 
            (byte )195,        (byte )195,        (byte )196,        (byte )196, 
            (byte )197,        (byte )198,        (byte )198,        (byte )199, 
            (byte )200,        (byte )200,        (byte )201,        (byte )202, 
            (byte )202,        (byte )203,        (byte )203,        (byte )204, 
            (byte )205,        (byte )205,        (byte )206,        (byte )207, 
            (byte )207,        (byte )208,        (byte )208,        (byte )209, 
            (byte )210,        (byte )210,        (byte )211,        (byte )211, 
            (byte )212,        (byte )213,        (byte )213,        (byte )214, 
            (byte )214,        (byte )215,        (byte )216,        (byte )216, 
            (byte )217,        (byte )217,        (byte )218,        (byte )219, 
            (byte )219,        (byte )220,        (byte )220,        (byte )221, 
            (byte )221,        (byte )222,        (byte )223,        (byte )223, 
            (byte )224,        (byte )224,        (byte )225,        (byte )225, 
            (byte )226,        (byte )227,        (byte )227,        (byte )228, 
            (byte )228,        (byte )229,        (byte )229,        (byte )230, 
            (byte )230,        (byte )231,        (byte )232,        (byte )232, 
            (byte )233,        (byte )233,        (byte )234,        (byte )234, 
            (byte )235,        (byte )235,        (byte )236,        (byte )236, 
            (byte )237,        (byte )237,        (byte )238,        (byte )239, 
            (byte )239,        (byte )240,        (byte )240,        (byte )241, 
            (byte )241,        (byte )242,        (byte )242,        (byte )243, 
            (byte )243,        (byte )244,        (byte )244,        (byte )245, 
            (byte )245,        (byte )246,        (byte )246,        (byte )247, 
            (byte )247,        (byte )248,        (byte )248,        (byte )249, 
            (byte )249,        (byte )250,        (byte )250,        (byte )251, 
            (byte )251,        (byte )252,        (byte )252,        (byte )253, 
            (byte )254,        (byte )254,        (byte )255,        (byte )255}};
#line 142 "v_video.c"
void V_MarkRect(int x___0 , int y___1 , int width , int height ) 
{ 


  {
#line 149
  M_AddToBox(dirtybox, x___0, y___1);
#line 150
  M_AddToBox(dirtybox, (x___0 + width) - 1, (y___1 + height) - 1);
#line 151
  return;
}
}
#line 157 "v_video.c"
void V_CopyRect(int srcx , int srcy , int srcscrn , int width , int height , int destx ,
                int desty , int destscrn ) 
{ 
  byte *src ;
  byte *dest ;

  {
#line 172
  if (srcx < 0) {
#line 172
    goto _L___7;
  } else
#line 172
  if (srcx + width > 320) {
    _L___7: /* CIL Label */ 
#line 172
    goto _L___6;
  } else
#line 172
  if (srcy < 0) {
    _L___6: /* CIL Label */ 
#line 172
    goto _L___5;
  } else
#line 172
  if (srcy + height > 200) {
    _L___5: /* CIL Label */ 
#line 172
    goto _L___4;
  } else
#line 172
  if (destx < 0) {
    _L___4: /* CIL Label */ 
#line 172
    goto _L___3;
  } else
#line 172
  if (destx + width > 320) {
    _L___3: /* CIL Label */ 
#line 172
    goto _L___2;
  } else
#line 172
  if (desty < 0) {
    _L___2: /* CIL Label */ 
#line 172
    goto _L___1;
  } else
#line 172
  if (desty + height > 200) {
    _L___1: /* CIL Label */ 
#line 172
    goto _L___0;
  } else
#line 172
  if ((unsigned int )srcscrn > 4U) {
    _L___0: /* CIL Label */ 
#line 172
    goto _L;
  } else
#line 172
  if ((unsigned int )destscrn > 4U) {
    _L: /* CIL Label */ 
#line 182
    I_Error("Bad V_CopyRect");
  }
#line 185
  V_MarkRect(destx, desty, width, height);
#line 187
  src = (screens[srcscrn] + 320 * srcy) + srcx;
#line 188
  dest = (screens[destscrn] + 320 * desty) + destx;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (height > 0)) {
#line 190
      goto while_break;
    }
#line 192
    memcpy((void * __restrict  )dest, (void const   * __restrict  )src, (size_t )width);
#line 193
    src += 320;
#line 194
    dest += 320;
#line 190
    height --;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return;
}
}
#line 203 "v_video.c"
void V_DrawPatch(int x___0 , int y___1 , int scrn , patch_t *patch ) 
{ 
  int count ;
  int col ;
  column_t *column ;
  byte *desttop ;
  byte *dest ;
  byte *source ;
  int w ;
  byte *tmp ;
  int tmp___0 ;

  {
#line 219
  y___1 -= (int )patch->topoffset;
#line 220
  x___0 -= (int )patch->leftoffset;
#line 222
  if (x___0 < 0) {
#line 222
    goto _L___2;
  } else
#line 222
  if (x___0 + (int )patch->width > 320) {
    _L___2: /* CIL Label */ 
#line 222
    goto _L___1;
  } else
#line 222
  if (y___1 < 0) {
    _L___1: /* CIL Label */ 
#line 222
    goto _L___0;
  } else
#line 222
  if (y___1 + (int )patch->height > 200) {
    _L___0: /* CIL Label */ 
#line 222
    goto _L;
  } else
#line 222
  if ((unsigned int )scrn > 4U) {
    _L: /* CIL Label */ 
#line 228
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Patch at %d,%d exceeds LFB\n",
            x___0, y___1);
#line 230
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"V_DrawPatch: bad patch (ignored)\n");
#line 231
    return;
  }
#line 235
  if (! scrn) {
#line 236
    V_MarkRect(x___0, y___1, (int )patch->width, (int )patch->height);
  }
#line 238
  col = 0;
#line 239
  desttop = (screens[scrn] + y___1 * 320) + x___0;
#line 241
  w = (int )patch->width;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (col < w)) {
#line 243
      goto while_break;
    }
#line 245
    column = (column_t *)((byte *)patch + patch->columnofs[col]);
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 248
      if (! ((int )column->topdelta != 0xff)) {
#line 248
        goto while_break___0;
      }
#line 250
      source = (byte *)column + 3;
#line 251
      dest = desttop + (int )column->topdelta * 320;
#line 252
      count = (int )column->length;
      {
#line 254
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 254
        tmp___0 = count;
#line 254
        count --;
#line 254
        if (! tmp___0) {
#line 254
          goto while_break___1;
        }
#line 256
        tmp = source;
#line 256
        source ++;
#line 256
        *dest = *tmp;
#line 257
        dest += 320;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 259
      column = (column_t *)(((byte *)column + (int )column->length) + 4);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 243
    x___0 ++;
#line 243
    col ++;
#line 243
    desttop ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return;
}
}
#line 270 "v_video.c"
void V_DrawPatchFlipped(int x___0 , int y___1 , int scrn , patch_t *patch ) 
{ 
  int count ;
  int col ;
  column_t *column ;
  byte *desttop ;
  byte *dest ;
  byte *source ;
  int w ;
  byte *tmp ;
  int tmp___0 ;

  {
#line 286
  y___1 -= (int )patch->topoffset;
#line 287
  x___0 -= (int )patch->leftoffset;
#line 289
  if (x___0 < 0) {
#line 289
    goto _L___2;
  } else
#line 289
  if (x___0 + (int )patch->width > 320) {
    _L___2: /* CIL Label */ 
#line 289
    goto _L___1;
  } else
#line 289
  if (y___1 < 0) {
    _L___1: /* CIL Label */ 
#line 289
    goto _L___0;
  } else
#line 289
  if (y___1 + (int )patch->height > 200) {
    _L___0: /* CIL Label */ 
#line 289
    goto _L;
  } else
#line 289
  if ((unsigned int )scrn > 4U) {
    _L: /* CIL Label */ 
#line 295
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Patch origin %d,%d exceeds LFB\n",
            x___0, y___1);
#line 296
    I_Error("Bad V_DrawPatch in V_DrawPatchFlipped");
  }
#line 300
  if (! scrn) {
#line 301
    V_MarkRect(x___0, y___1, (int )patch->width, (int )patch->height);
  }
#line 303
  col = 0;
#line 304
  desttop = (screens[scrn] + y___1 * 320) + x___0;
#line 306
  w = (int )patch->width;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (col < w)) {
#line 308
      goto while_break;
    }
#line 310
    column = (column_t *)((byte *)patch + patch->columnofs[(w - 1) - col]);
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (! ((int )column->topdelta != 0xff)) {
#line 313
        goto while_break___0;
      }
#line 315
      source = (byte *)column + 3;
#line 316
      dest = desttop + (int )column->topdelta * 320;
#line 317
      count = (int )column->length;
      {
#line 319
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 319
        tmp___0 = count;
#line 319
        count --;
#line 319
        if (! tmp___0) {
#line 319
          goto while_break___1;
        }
#line 321
        tmp = source;
#line 321
        source ++;
#line 321
        *dest = *tmp;
#line 322
        dest += 320;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 324
      column = (column_t *)(((byte *)column + (int )column->length) + 4);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 308
    x___0 ++;
#line 308
    col ++;
#line 308
    desttop ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  return;
}
}
#line 336 "v_video.c"
void V_DrawPatchDirect(int x___0 , int y___1 , int scrn , patch_t *patch ) 
{ 


  {
#line 343
  V_DrawPatch(x___0, y___1, scrn, patch);
#line 396
  return;
}
}
#line 404 "v_video.c"
void V_DrawBlock(int x___0 , int y___1 , int scrn , int width , int height , byte *src ) 
{ 
  byte *dest ;
  int tmp ;

  {
#line 416
  if (x___0 < 0) {
#line 416
    goto _L___2;
  } else
#line 416
  if (x___0 + width > 320) {
    _L___2: /* CIL Label */ 
#line 416
    goto _L___1;
  } else
#line 416
  if (y___1 < 0) {
    _L___1: /* CIL Label */ 
#line 416
    goto _L___0;
  } else
#line 416
  if (y___1 + height > 200) {
    _L___0: /* CIL Label */ 
#line 416
    goto _L;
  } else
#line 416
  if ((unsigned int )scrn > 4U) {
    _L: /* CIL Label */ 
#line 422
    I_Error("Bad V_DrawBlock");
  }
#line 426
  V_MarkRect(x___0, y___1, width, height);
#line 428
  dest = (screens[scrn] + y___1 * 320) + x___0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    tmp = height;
#line 430
    height --;
#line 430
    if (! tmp) {
#line 430
      goto while_break;
    }
#line 432
    memcpy((void * __restrict  )dest, (void const   * __restrict  )src, (size_t )width);
#line 433
    src += width;
#line 434
    dest += 320;
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  return;
}
}
#line 444 "v_video.c"
void V_GetBlock(int x___0 , int y___1 , int scrn , int width , int height , byte *dest ) 
{ 
  byte *src ;
  int tmp ;

  {
#line 456
  if (x___0 < 0) {
#line 456
    goto _L___2;
  } else
#line 456
  if (x___0 + width > 320) {
    _L___2: /* CIL Label */ 
#line 456
    goto _L___1;
  } else
#line 456
  if (y___1 < 0) {
    _L___1: /* CIL Label */ 
#line 456
    goto _L___0;
  } else
#line 456
  if (y___1 + height > 200) {
    _L___0: /* CIL Label */ 
#line 456
    goto _L;
  } else
#line 456
  if ((unsigned int )scrn > 4U) {
    _L: /* CIL Label */ 
#line 462
    I_Error("Bad V_DrawBlock");
  }
#line 466
  src = (screens[scrn] + y___1 * 320) + x___0;
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    tmp = height;
#line 468
    height --;
#line 468
    if (! tmp) {
#line 468
      goto while_break;
    }
#line 470
    memcpy((void * __restrict  )dest, (void const   * __restrict  )src, (size_t )width);
#line 471
    src += 320;
#line 472
    dest += width;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  return;
}
}
#line 482 "v_video.c"
void V_Init(void) 
{ 
  int i ;
  byte *base ;

  {
#line 489
  base = I_AllocLow(256000);
#line 491
  i = 0;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if (! (i < 4)) {
#line 491
      goto while_break;
    }
#line 492
    screens[i] = base + (i * 320) * 200;
#line 491
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 25 "st_lib.c"
static char const   rcsid___52[49]  = 
#line 25 "st_lib.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'t',      (char const   )'_', 
        (char const   )'l',      (char const   )'i',      (char const   )'b',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'4',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'1', 
        (char const   )'6',      (char const   )':',      (char const   )'4',      (char const   )'7', 
        (char const   )':',      (char const   )'5',      (char const   )'6',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 150 "st_lib.h"
void STlib_init(void) ;
#line 155
void STlib_initNum(st_number_t *n , int x___0 , int y___1 , patch_t **pl , int *num___0 ,
                   boolean *on , int width ) ;
#line 165
void STlib_updateNum(st_number_t *n , boolean refresh ) ;
#line 172
void STlib_initPercent(st_percent_t *p___0 , int x___0 , int y___1 , patch_t **pl ,
                       int *num___0 , boolean *on , patch_t *percent___0 ) ;
#line 183
void STlib_updatePercent(st_percent_t *per , int refresh ) ;
#line 190
void STlib_initMultIcon(st_multicon_t *i , int x___0 , int y___1 , patch_t **il ,
                        int *inum , boolean *on ) ;
#line 200
void STlib_updateMultIcon(st_multicon_t *mi , boolean refresh ) ;
#line 207
void STlib_initBinIcon(st_binicon_t *b , int x___0 , int y___1 , patch_t *i , boolean *val ,
                       boolean *on ) ;
#line 216
void STlib_updateBinIcon(st_binicon_t *bi , boolean refresh ) ;
#line 56 "st_lib.c"
patch_t *sttminus  ;
#line 58 "st_lib.c"
void STlib_init(void) 
{ 
  void *tmp ;

  {
#line 60
  tmp = W_CacheLumpName("STTMINUS", 1);
#line 60
  sttminus = (patch_t *)tmp;
#line 61
  return;
}
}
#line 65 "st_lib.c"
void STlib_initNum(st_number_t *n , int x___0 , int y___1 , patch_t **pl , int *num___0 ,
                   boolean *on , int width ) 
{ 


  {
#line 75
  n->x = x___0;
#line 76
  n->y = y___1;
#line 77
  n->oldnum = 0;
#line 78
  n->width = width;
#line 79
  n->num = num___0;
#line 80
  n->on = on;
#line 81
  n->p = pl;
#line 82
  return;
}
}
#line 90 "st_lib.c"
void STlib_drawNum(st_number_t *n , boolean refresh ) 
{ 
  int numdigits ;
  int num___0 ;
  int w ;
  int h ;
  int x___0 ;
  int neg ;
  int tmp ;

  {
#line 96
  numdigits = n->width;
#line 97
  num___0 = *(n->num);
#line 99
  w = (int )(*(n->p + 0))->width;
#line 100
  h = (int )(*(n->p + 0))->height;
#line 101
  x___0 = n->x;
#line 105
  n->oldnum = *(n->num);
#line 107
  neg = num___0 < 0;
#line 109
  if (neg) {
#line 111
    if (numdigits == 2) {
#line 111
      if (num___0 < -9) {
#line 112
        num___0 = -9;
      } else {
#line 111
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 113
    if (numdigits == 3) {
#line 113
      if (num___0 < -99) {
#line 114
        num___0 = -99;
      } else {
#line 113
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 116
    num___0 = - num___0;
  }
#line 120
  x___0 = n->x - numdigits * w;
#line 122
  if (n->y - 168 < 0) {
#line 123
    I_Error("drawNum: n->y - ST_Y < 0");
  }
#line 125
  V_CopyRect(x___0, n->y - 168, 4, w * numdigits, h, x___0, n->y, 0);
#line 128
  if (num___0 == 1994) {
#line 129
    return;
  }
#line 131
  x___0 = n->x;
#line 134
  if (! num___0) {
#line 135
    V_DrawPatch(x___0 - w, n->y, 0, *(n->p + 0));
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (num___0) {
#line 138
      tmp = numdigits;
#line 138
      numdigits --;
#line 138
      if (! tmp) {
#line 138
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 138
      goto while_break;
    }
#line 140
    x___0 -= w;
#line 141
    V_DrawPatch(x___0, n->y, 0, *(n->p + num___0 % 10));
#line 142
    num___0 /= 10;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  if (neg) {
#line 147
    V_DrawPatch(x___0 - 8, n->y, 0, sttminus);
  }
#line 148
  return;
}
}
#line 152 "st_lib.c"
void STlib_updateNum(st_number_t *n , boolean refresh ) 
{ 


  {
#line 157
  if (*(n->on)) {
#line 157
    STlib_drawNum(n, refresh);
  }
#line 158
  return;
}
}
#line 162 "st_lib.c"
void STlib_initPercent(st_percent_t *p___0 , int x___0 , int y___1 , patch_t **pl ,
                       int *num___0 , boolean *on , patch_t *percent___0 ) 
{ 


  {
#line 172
  STlib_initNum(& p___0->n, x___0, y___1, pl, num___0, on, 3);
#line 173
  p___0->p = percent___0;
#line 174
  return;
}
}
#line 179 "st_lib.c"
void STlib_updatePercent(st_percent_t *per , int refresh ) 
{ 


  {
#line 184
  if (refresh) {
#line 184
    if (*(per->n.on)) {
#line 185
      V_DrawPatch(per->n.x, per->n.y, 0, per->p);
    } else {
#line 184
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 187
  STlib_updateNum(& per->n, (boolean )refresh);
#line 188
  return;
}
}
#line 192 "st_lib.c"
void STlib_initMultIcon(st_multicon_t *i , int x___0 , int y___1 , patch_t **il ,
                        int *inum , boolean *on ) 
{ 


  {
#line 201
  i->x = x___0;
#line 202
  i->y = y___1;
#line 203
  i->oldinum = -1;
#line 204
  i->inum = inum;
#line 205
  i->on = on;
#line 206
  i->p = il;
#line 207
  return;
}
}
#line 211 "st_lib.c"
void STlib_updateMultIcon(st_multicon_t *mi , boolean refresh ) 
{ 
  int w ;
  int h ;
  int x___0 ;
  int y___1 ;

  {
#line 221
  if (*(mi->on)) {
#line 221
    if (mi->oldinum != *(mi->inum)) {
#line 221
      goto _L___1;
    } else
#line 221
    if (refresh) {
      _L___1: /* CIL Label */ 
#line 221
      if (*(mi->inum) != -1) {
#line 225
        if (mi->oldinum != -1) {
#line 227
          x___0 = mi->x - (int )(*(mi->p + mi->oldinum))->leftoffset;
#line 228
          y___1 = mi->y - (int )(*(mi->p + mi->oldinum))->topoffset;
#line 229
          w = (int )(*(mi->p + mi->oldinum))->width;
#line 230
          h = (int )(*(mi->p + mi->oldinum))->height;
#line 232
          if (y___1 - 168 < 0) {
#line 233
            I_Error("updateMultIcon: y - ST_Y < 0");
          }
#line 235
          V_CopyRect(x___0, y___1 - 168, 4, w, h, x___0, y___1, 0);
        }
#line 237
        V_DrawPatch(mi->x, mi->y, 0, *(mi->p + *(mi->inum)));
#line 238
        mi->oldinum = *(mi->inum);
      } else {
#line 221
        goto _L___0;
      }
    } else {
#line 221
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ ;
  }
#line 240
  return;
}
}
#line 244 "st_lib.c"
void STlib_initBinIcon(st_binicon_t *b , int x___0 , int y___1 , patch_t *i , boolean *val ,
                       boolean *on ) 
{ 


  {
#line 253
  b->x = x___0;
#line 254
  b->y = y___1;
#line 255
  b->oldval = 0;
#line 256
  b->val = val;
#line 257
  b->on = on;
#line 258
  b->p = i;
#line 259
  return;
}
}
#line 263 "st_lib.c"
void STlib_updateBinIcon(st_binicon_t *bi , boolean refresh ) 
{ 
  int x___0 ;
  int y___1 ;
  int w ;
  int h ;

  {
#line 273
  if (*(bi->on)) {
#line 273
    if ((unsigned int )bi->oldval != (unsigned int )*(bi->val)) {
#line 273
      goto _L___0;
    } else
#line 273
    if (refresh) {
      _L___0: /* CIL Label */ 
#line 276
      x___0 = bi->x - (int )(bi->p)->leftoffset;
#line 277
      y___1 = bi->y - (int )(bi->p)->topoffset;
#line 278
      w = (int )(bi->p)->width;
#line 279
      h = (int )(bi->p)->height;
#line 281
      if (y___1 - 168 < 0) {
#line 282
        I_Error("updateBinIcon: y - ST_Y < 0");
      }
#line 284
      if (*(bi->val)) {
#line 285
        V_DrawPatch(bi->x, bi->y, 0, bi->p);
      } else {
#line 287
        V_CopyRect(x___0, y___1 - 168, 4, w, h, x___0, y___1, 0);
      }
#line 289
      bi->oldval = (int )*(bi->val);
    } else {
#line 273
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 26 "st_stuff.c"
static char const   rcsid___53[51]  = 
#line 26 "st_stuff.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'t',      (char const   )'_', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'f', 
        (char const   )'f',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'6',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )' ',      (char const   )'2',      (char const   )'2',      (char const   )':', 
        (char const   )'4',      (char const   )'5',      (char const   )':',      (char const   )'1', 
        (char const   )'3',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 270 "st_stuff.c"
static player_t *plyr  ;
#line 273 "st_stuff.c"
static boolean st_firsttime  ;
#line 276 "st_stuff.c"
static int veryfirsttime  =    1;
#line 279 "st_stuff.c"
static int lu_palette  ;
#line 282 "st_stuff.c"
static unsigned int st_clock  ;
#line 285 "st_stuff.c"
static int st_msgcounter  =    0;
#line 288 "st_stuff.c"
static st_chatstateenum_t st_chatstate  ;
#line 291 "st_stuff.c"
static st_stateenum_t st_gamestate  ;
#line 294 "st_stuff.c"
static boolean st_statusbaron  ;
#line 297 "st_stuff.c"
static boolean st_chat  ;
#line 300 "st_stuff.c"
static boolean st_oldchat  ;
#line 303 "st_stuff.c"
static boolean st_cursoron  ;
#line 306 "st_stuff.c"
static boolean st_notdeathmatch  ;
#line 309 "st_stuff.c"
static boolean st_armson  ;
#line 312 "st_stuff.c"
static boolean st_fragson  ;
#line 315 "st_stuff.c"
static patch_t *sbar  ;
#line 318 "st_stuff.c"
static patch_t *tallnum[10]  ;
#line 321 "st_stuff.c"
static patch_t *tallpercent  ;
#line 324 "st_stuff.c"
static patch_t *shortnum[10]  ;
#line 327 "st_stuff.c"
static patch_t *keys[6]  ;
#line 330 "st_stuff.c"
static patch_t *faces[42]  ;
#line 333 "st_stuff.c"
static patch_t *faceback  ;
#line 336 "st_stuff.c"
static patch_t *armsbg  ;
#line 339 "st_stuff.c"
static patch_t *arms[6][2]  ;
#line 342 "st_stuff.c"
static st_number_t w_ready  ;
#line 345 "st_stuff.c"
static st_number_t w_frags  ;
#line 348 "st_stuff.c"
static st_percent_t w_health  ;
#line 351 "st_stuff.c"
static st_binicon_t w_armsbg  ;
#line 355 "st_stuff.c"
static st_multicon_t w_arms[6]  ;
#line 358 "st_stuff.c"
static st_multicon_t w_faces  ;
#line 361 "st_stuff.c"
static st_multicon_t w_keyboxes[3]  ;
#line 364 "st_stuff.c"
static st_percent_t w_armor  ;
#line 367 "st_stuff.c"
static st_number_t w_ammo[4]  ;
#line 370 "st_stuff.c"
static st_number_t w_maxammo[4]  ;
#line 375 "st_stuff.c"
static int st_fragscount  ;
#line 378 "st_stuff.c"
static int st_oldhealth  =    -1;
#line 381 "st_stuff.c"
static boolean oldweaponsowned[9]  ;
#line 384 "st_stuff.c"
static int st_facecount  =    0;
#line 387 "st_stuff.c"
static int st_faceindex  =    0;
#line 390 "st_stuff.c"
static int keyboxes[3]  ;
#line 393 "st_stuff.c"
static int st_randomnumber  ;
#line 400 "st_stuff.c"
unsigned char cheat_mus_seq[9]  = 
#line 400
  {      (unsigned char)178,      (unsigned char)38,      (unsigned char)182,      (unsigned char)174, 
        (unsigned char)234,      (unsigned char)1,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255};
#line 405 "st_stuff.c"
unsigned char cheat_choppers_seq[11]  = 
#line 405
  {      (unsigned char)178,      (unsigned char)38,      (unsigned char)226,      (unsigned char)50, 
        (unsigned char)246,      (unsigned char)42,      (unsigned char)42,      (unsigned char)166, 
        (unsigned char)106,      (unsigned char)234,      (unsigned char)255};
#line 410 "st_stuff.c"
unsigned char cheat_god_seq[6]  = {      (unsigned char)178,      (unsigned char)38,      (unsigned char)38,      (unsigned char)170, 
        (unsigned char)38,      (unsigned char)255};
#line 415 "st_stuff.c"
unsigned char cheat_ammo_seq[6]  = {      (unsigned char)178,      (unsigned char)38,      (unsigned char)242,      (unsigned char)102, 
        (unsigned char)162,      (unsigned char)255};
#line 420 "st_stuff.c"
unsigned char cheat_ammonokey_seq[5]  = {      (unsigned char)178,      (unsigned char)38,      (unsigned char)102,      (unsigned char)162, 
        (unsigned char)255};
#line 427 "st_stuff.c"
unsigned char cheat_noclip_seq[11]  = 
#line 427
  {      (unsigned char)178,      (unsigned char)38,      (unsigned char)234,      (unsigned char)42, 
        (unsigned char)178,      (unsigned char)234,      (unsigned char)42,      (unsigned char)246, 
        (unsigned char)42,      (unsigned char)38,      (unsigned char)255};
#line 434 "st_stuff.c"
unsigned char cheat_commercial_noclip_seq[7]  = {      (unsigned char)178,      (unsigned char)38,      (unsigned char)226,      (unsigned char)54, 
        (unsigned char)178,      (unsigned char)42,      (unsigned char)255};
#line 441 "st_stuff.c"
unsigned char cheat_powerup_seq[7][10]  = { {        (unsigned char)178,        (unsigned char)38,        (unsigned char)98,        (unsigned char)166, 
            (unsigned char)50,        (unsigned char)246,        (unsigned char)54,        (unsigned char)38, 
            (unsigned char)110,        (unsigned char)255}, 
   {        (unsigned char)178,        (unsigned char)38,        (unsigned char)98,        (unsigned char)166, 
            (unsigned char)50,        (unsigned char)246,        (unsigned char)54,        (unsigned char)38, 
            (unsigned char)234,        (unsigned char)255}, 
   {        (unsigned char)178,        (unsigned char)38,        (unsigned char)98,        (unsigned char)166, 
            (unsigned char)50,        (unsigned char)246,        (unsigned char)54,        (unsigned char)38, 
            (unsigned char)178,        (unsigned char)255}, 
   {        (unsigned char)178,        (unsigned char)38,        (unsigned char)98,        (unsigned char)166, 
            (unsigned char)50,        (unsigned char)246,        (unsigned char)54,        (unsigned char)38, 
            (unsigned char)106,        (unsigned char)255}, 
   {        (unsigned char)178,        (unsigned char)38,        (unsigned char)98,        (unsigned char)166, 
            (unsigned char)50,        (unsigned char)246,        (unsigned char)54,        (unsigned char)38, 
            (unsigned char)162,        (unsigned char)255}, 
   {        (unsigned char)178,        (unsigned char)38,        (unsigned char)98,        (unsigned char)166, 
            (unsigned char)50,        (unsigned char)246,        (unsigned char)54,        (unsigned char)38, 
            (unsigned char)54,        (unsigned char)255}, 
   {        (unsigned char)178,        (unsigned char)38,        (unsigned char)98,        (unsigned char)166, 
            (unsigned char)50,        (unsigned char)246,        (unsigned char)54,        (unsigned char)38, 
            (unsigned char)255}};
#line 453 "st_stuff.c"
unsigned char cheat_clev_seq[10]  = 
#line 453
  {      (unsigned char)178,      (unsigned char)38,      (unsigned char)226,      (unsigned char)54, 
        (unsigned char)166,      (unsigned char)110,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)255};
#line 460 "st_stuff.c"
unsigned char cheat_mypos_seq[8]  = 
#line 460
  {      (unsigned char)178,      (unsigned char)38,      (unsigned char)182,      (unsigned char)186, 
        (unsigned char)42,      (unsigned char)246,      (unsigned char)234,      (unsigned char)255};
#line 467 "st_stuff.c"
cheatseq_t cheat_mus  =    {cheat_mus_seq, (unsigned char *)0};
#line 468 "st_stuff.c"
cheatseq_t cheat_god  =    {cheat_god_seq, (unsigned char *)0};
#line 469 "st_stuff.c"
cheatseq_t cheat_ammo  =    {cheat_ammo_seq, (unsigned char *)0};
#line 470 "st_stuff.c"
cheatseq_t cheat_ammonokey  =    {cheat_ammonokey_seq, (unsigned char *)0};
#line 471 "st_stuff.c"
cheatseq_t cheat_noclip  =    {cheat_noclip_seq, (unsigned char *)0};
#line 472 "st_stuff.c"
cheatseq_t cheat_commercial_noclip  =    {cheat_commercial_noclip_seq, (unsigned char *)0};
#line 474 "st_stuff.c"
cheatseq_t cheat_powerup[7]  = {      {cheat_powerup_seq[0], (unsigned char *)0}, 
        {cheat_powerup_seq[1], (unsigned char *)0}, 
        {cheat_powerup_seq[2], (unsigned char *)0}, 
        {cheat_powerup_seq[3], (unsigned char *)0}, 
        {cheat_powerup_seq[4], (unsigned char *)0}, 
        {cheat_powerup_seq[5], (unsigned char *)0}, 
        {cheat_powerup_seq[6], (unsigned char *)0}};
#line 485 "st_stuff.c"
cheatseq_t cheat_choppers  =    {cheat_choppers_seq, (unsigned char *)0};
#line 486 "st_stuff.c"
cheatseq_t cheat_clev  =    {cheat_clev_seq, (unsigned char *)0};
#line 487 "st_stuff.c"
cheatseq_t cheat_mypos  =    {cheat_mypos_seq, (unsigned char *)0};
#line 491
char *mapnames[45] ;
#line 497
void ST_Stop(void) ;
#line 499 "st_stuff.c"
void ST_refreshBackground(void) 
{ 


  {
#line 502
  if (st_statusbaron) {
#line 504
    V_DrawPatch(0, 0, 4, sbar);
#line 506
    if (netgame) {
#line 507
      V_DrawPatch(143, 0, 4, faceback);
    }
#line 509
    V_CopyRect(0, 0, 4, 320, 32, 0, 168, 0);
  }
#line 512
  return;
}
}
#line 666 "st_stuff.c"
static char buf___0[52]  ;
#line 517 "st_stuff.c"
boolean ST_Responder(event_t *ev ) 
{ 
  int i ;
  char buf[3] ;
  int musnum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char buf___1[3] ;
  int epsd ;
  int map ;
  int tmp___9 ;

  {
#line 523
  if ((unsigned int )ev->type == 1U) {
#line 523
    if (((unsigned int )ev->data1 & 0xffff0000) == (unsigned int )((97 << 24) + (109 << 16))) {
      {
#line 528
      if (ev->data1 == (((97 << 24) + (109 << 16)) | (101 << 8))) {
#line 528
        goto case_exp;
      }
#line 533
      if (ev->data1 == (((97 << 24) + (109 << 16)) | (120 << 8))) {
#line 533
        goto case_exp___0;
      }
#line 526
      goto switch_break;
      case_exp: /* CIL Label */ 
#line 529
      st_gamestate = (st_stateenum_t )0;
#line 530
      st_firsttime = (boolean )1;
#line 531
      goto switch_break;
      case_exp___0: /* CIL Label */ 
#line 535
      st_gamestate = (st_stateenum_t )1;
#line 536
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 523
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 541
  if ((unsigned int )ev->type == 0U) {
#line 543
    if (! netgame) {
#line 549
      tmp___4 = cht_CheckCheat(& cheat_god, (char )ev->data1);
#line 549
      if (tmp___4) {
#line 551
        plyr->cheats ^= 2;
#line 552
        if (plyr->cheats & 2) {
#line 554
          if (plyr->mo) {
#line 555
            (plyr->mo)->health = 100;
          }
#line 557
          plyr->health = 100;
#line 558
          plyr->message = "Degreelessness Mode On";
        } else {
#line 561
          plyr->message = "Degreelessness Mode Off";
        }
      } else {
#line 564
        tmp___3 = cht_CheckCheat(& cheat_ammonokey, (char )ev->data1);
#line 564
        if (tmp___3) {
#line 566
          plyr->armorpoints = 200;
#line 567
          plyr->armortype = 2;
#line 569
          i = 0;
          {
#line 569
          while (1) {
            while_continue: /* CIL Label */ ;
#line 569
            if (! (i < 9)) {
#line 569
              goto while_break;
            }
#line 570
            plyr->weaponowned[i] = (boolean )1;
#line 569
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 572
          i = 0;
          {
#line 572
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 572
            if (! (i < 4)) {
#line 572
              goto while_break___0;
            }
#line 573
            plyr->ammo[i] = plyr->maxammo[i];
#line 572
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 575
          plyr->message = "Ammo (no keys) Added";
        } else {
#line 578
          tmp___2 = cht_CheckCheat(& cheat_ammo, (char )ev->data1);
#line 578
          if (tmp___2) {
#line 580
            plyr->armorpoints = 200;
#line 581
            plyr->armortype = 2;
#line 583
            i = 0;
            {
#line 583
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 583
              if (! (i < 9)) {
#line 583
                goto while_break___1;
              }
#line 584
              plyr->weaponowned[i] = (boolean )1;
#line 583
              i ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 586
            i = 0;
            {
#line 586
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 586
              if (! (i < 4)) {
#line 586
                goto while_break___2;
              }
#line 587
              plyr->ammo[i] = plyr->maxammo[i];
#line 586
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 589
            i = 0;
            {
#line 589
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 589
              if (! (i < 6)) {
#line 589
                goto while_break___3;
              }
#line 590
              plyr->cards[i] = (boolean )1;
#line 589
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 592
            plyr->message = "Very Happy Ammo Added";
          } else {
#line 595
            tmp___1 = cht_CheckCheat(& cheat_mus, (char )ev->data1);
#line 595
            if (tmp___1) {
#line 601
              plyr->message = "Music Change";
#line 602
              cht_GetParam(& cheat_mus, buf);
#line 604
              if ((unsigned int )gamemode == 2U) {
#line 606
                musnum = (((33 + ((int )buf[0] - 48) * 10) + (int )buf[1]) - 48) - 1;
#line 608
                if ((((int )buf[0] - 48) * 10 + (int )buf[1]) - 48 > 35) {
#line 609
                  plyr->message = "IMPOSSIBLE SELECTION";
                } else {
#line 611
                  S_ChangeMusic(musnum, 1);
                }
              } else {
#line 615
                musnum = (1 + ((int )buf[0] - 49) * 9) + ((int )buf[1] - 49);
#line 617
                if ((((int )buf[0] - 49) * 9 + (int )buf[1]) - 49 > 31) {
#line 618
                  plyr->message = "IMPOSSIBLE SELECTION";
                } else {
#line 620
                  S_ChangeMusic(musnum, 1);
                }
              }
            } else {
#line 625
              tmp = cht_CheckCheat(& cheat_noclip, (char )ev->data1);
#line 625
              if (tmp) {
#line 625
                goto _L;
              } else {
#line 625
                tmp___0 = cht_CheckCheat(& cheat_commercial_noclip, (char )ev->data1);
#line 625
                if (tmp___0) {
                  _L: /* CIL Label */ 
#line 628
                  plyr->cheats ^= 1;
#line 630
                  if (plyr->cheats & 1) {
#line 631
                    plyr->message = "No Clipping Mode ON";
                  } else {
#line 633
                    plyr->message = "No Clipping Mode OFF";
                  }
                }
              }
            }
          }
        }
      }
#line 636
      i = 0;
      {
#line 636
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 636
        if (! (i < 6)) {
#line 636
          goto while_break___4;
        }
#line 638
        tmp___5 = cht_CheckCheat(& cheat_powerup[i], (char )ev->data1);
#line 638
        if (tmp___5) {
#line 640
          if (! plyr->powers[i]) {
#line 641
            P_GivePower(plyr, i);
          } else
#line 642
          if (i != 1) {
#line 643
            plyr->powers[i] = 1;
          } else {
#line 645
            plyr->powers[i] = 0;
          }
#line 647
          plyr->message = "Power-up Toggled";
        }
#line 636
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 652
      tmp___8 = cht_CheckCheat(& cheat_powerup[6], (char )ev->data1);
#line 652
      if (tmp___8) {
#line 654
        plyr->message = "inVuln, Str, Inviso, Rad, Allmap, or Lite-amp";
      } else {
#line 657
        tmp___7 = cht_CheckCheat(& cheat_choppers, (char )ev->data1);
#line 657
        if (tmp___7) {
#line 659
          plyr->weaponowned[7] = (boolean )1;
#line 660
          plyr->powers[0] = 1;
#line 661
          plyr->message = "... doesn\'t suck - GM";
        } else {
#line 664
          tmp___6 = cht_CheckCheat(& cheat_mypos, (char )ev->data1);
#line 664
          if (tmp___6) {
#line 667
            sprintf((char * __restrict  )(buf___0), (char const   * __restrict  )"ang=0x%x;x,y=(0x%x,0x%x)",
                    (players[consoleplayer].mo)->angle, (players[consoleplayer].mo)->x,
                    (players[consoleplayer].mo)->y);
#line 671
            plyr->message = buf___0;
          }
        }
      }
    }
#line 676
    tmp___9 = cht_CheckCheat(& cheat_clev, (char )ev->data1);
#line 676
    if (tmp___9) {
#line 682
      cht_GetParam(& cheat_clev, buf___1);
#line 684
      if ((unsigned int )gamemode == 2U) {
#line 686
        epsd = 0;
#line 687
        map = (((int )buf___1[0] - 48) * 10 + (int )buf___1[1]) - 48;
      } else {
#line 691
        epsd = (int )buf___1[0] - 48;
#line 692
        map = (int )buf___1[1] - 48;
      }
#line 696
      if (epsd < 1) {
#line 697
        return ((boolean )0);
      }
#line 699
      if (map < 1) {
#line 700
        return ((boolean )0);
      }
#line 703
      if ((unsigned int )gamemode == 3U) {
#line 703
        if (epsd > 4) {
#line 703
          goto _L___1;
        } else
#line 703
        if (map > 9) {
          _L___1: /* CIL Label */ 
#line 705
          return ((boolean )0);
        } else {
#line 703
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
#line 707
      if ((unsigned int )gamemode == 1U) {
#line 707
        if (epsd > 3) {
#line 707
          goto _L___3;
        } else
#line 707
        if (map > 9) {
          _L___3: /* CIL Label */ 
#line 709
          return ((boolean )0);
        } else {
#line 707
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ ;
      }
#line 711
      if ((unsigned int )gamemode == 0U) {
#line 711
        if (epsd > 1) {
#line 711
          goto _L___5;
        } else
#line 711
        if (map > 9) {
          _L___5: /* CIL Label */ 
#line 713
          return ((boolean )0);
        } else {
#line 711
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ ;
      }
#line 715
      if ((unsigned int )gamemode == 2U) {
#line 715
        if (epsd > 1) {
#line 715
          goto _L___7;
        } else
#line 715
        if (map > 34) {
          _L___7: /* CIL Label */ 
#line 717
          return ((boolean )0);
        } else {
#line 715
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ ;
      }
#line 720
      plyr->message = "Changing Level...";
#line 721
      G_DeferedInitNew(gameskill, epsd, map);
    }
  }
#line 724
  return ((boolean )0);
}
}
#line 732 "st_stuff.c"
static int lastcalc  ;
#line 733
int ST_calcPainOffset(void) ;
#line 733 "st_stuff.c"
static int oldhealth  =    -1;
#line 729 "st_stuff.c"
int ST_calcPainOffset(void) 
{ 
  int health ;

  {
#line 735
  if (plyr->health > 100) {
#line 735
    health = 100;
  } else {
#line 735
    health = plyr->health;
  }
#line 737
  if (health != oldhealth) {
#line 739
    lastcalc = 8 * (((100 - health) * 5) / 101);
#line 740
    oldhealth = health;
  }
#line 742
  return (lastcalc);
}
}
#line 757
void ST_updateFaceWidget(void) ;
#line 757 "st_stuff.c"
static int lastattackdown  =    -1;
#line 758 "st_stuff.c"
static int priority  =    0;
#line 752 "st_stuff.c"
void ST_updateFaceWidget(void) 
{ 
  int i ;
  angle_t badguyangle ;
  angle_t diffang ;
  boolean doevilgrin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 761
  if (priority < 10) {
#line 764
    if (! plyr->health) {
#line 766
      priority = 9;
#line 767
      st_faceindex = 41;
#line 768
      st_facecount = 1;
    }
  }
#line 772
  if (priority < 9) {
#line 774
    if (plyr->bonuscount) {
#line 777
      doevilgrin = (boolean )0;
#line 779
      i = 0;
      {
#line 779
      while (1) {
        while_continue: /* CIL Label */ ;
#line 779
        if (! (i < 9)) {
#line 779
          goto while_break;
        }
#line 781
        if ((unsigned int )oldweaponsowned[i] != (unsigned int )plyr->weaponowned[i]) {
#line 783
          doevilgrin = (boolean )1;
#line 784
          oldweaponsowned[i] = plyr->weaponowned[i];
        }
#line 779
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 787
      if (doevilgrin) {
#line 790
        priority = 8;
#line 791
        st_facecount = 70;
#line 792
        tmp = ST_calcPainOffset();
#line 792
        st_faceindex = tmp + 6;
      }
    }
  }
#line 798
  if (priority < 8) {
#line 800
    if (plyr->damagecount) {
#line 800
      if (plyr->attacker) {
#line 800
        if ((unsigned long )plyr->attacker != (unsigned long )plyr->mo) {
#line 805
          priority = 7;
#line 807
          if (plyr->health - st_oldhealth > 20) {
#line 809
            st_facecount = 35;
#line 810
            tmp___0 = ST_calcPainOffset();
#line 810
            st_faceindex = tmp___0 + 5;
          } else {
#line 814
            badguyangle = R_PointToAngle2((plyr->mo)->x, (plyr->mo)->y, (plyr->attacker)->x,
                                          (plyr->attacker)->y);
#line 819
            if (badguyangle > (plyr->mo)->angle) {
#line 822
              diffang = badguyangle - (plyr->mo)->angle;
#line 823
              i = diffang > 0x80000000;
            } else {
#line 828
              diffang = (plyr->mo)->angle - badguyangle;
#line 829
              i = diffang <= 0x80000000;
            }
#line 833
            st_facecount = 35;
#line 834
            st_faceindex = ST_calcPainOffset();
#line 836
            if (diffang < 536870912U) {
#line 839
              st_faceindex += 7;
            } else
#line 841
            if (i) {
#line 844
              st_faceindex += 3;
            } else {
#line 849
              st_faceindex += 4;
            }
          }
        } else {
#line 800
          goto _L___0;
        }
      } else {
#line 800
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ ;
    }
  }
#line 855
  if (priority < 7) {
#line 858
    if (plyr->damagecount) {
#line 860
      if (plyr->health - st_oldhealth > 20) {
#line 862
        priority = 7;
#line 863
        st_facecount = 35;
#line 864
        tmp___1 = ST_calcPainOffset();
#line 864
        st_faceindex = tmp___1 + 5;
      } else {
#line 868
        priority = 6;
#line 869
        st_facecount = 35;
#line 870
        tmp___2 = ST_calcPainOffset();
#line 870
        st_faceindex = tmp___2 + 7;
      }
    }
  }
#line 877
  if (priority < 6) {
#line 880
    if (plyr->attackdown) {
#line 882
      if (lastattackdown == -1) {
#line 883
        lastattackdown = 70;
      } else {
#line 884
        lastattackdown --;
#line 884
        if (! lastattackdown) {
#line 886
          priority = 5;
#line 887
          tmp___3 = ST_calcPainOffset();
#line 887
          st_faceindex = tmp___3 + 7;
#line 888
          st_facecount = 1;
#line 889
          lastattackdown = 1;
        }
      }
    } else {
#line 893
      lastattackdown = -1;
    }
  }
#line 897
  if (priority < 5) {
#line 900
    if (plyr->cheats & 2) {
#line 900
      goto _L___1;
    } else
#line 900
    if (plyr->powers[0]) {
      _L___1: /* CIL Label */ 
#line 903
      priority = 4;
#line 905
      st_faceindex = 40;
#line 906
      st_facecount = 1;
    }
  }
#line 913
  if (! st_facecount) {
#line 915
    tmp___4 = ST_calcPainOffset();
#line 915
    st_faceindex = tmp___4 + st_randomnumber % 3;
#line 916
    st_facecount = 17;
#line 917
    priority = 0;
  }
#line 920
  st_facecount --;
#line 922
  return;
}
}
#line 926
void ST_updateWidgets(void) ;
#line 926 "st_stuff.c"
static int largeammo  =    1994;
#line 924 "st_stuff.c"
void ST_updateWidgets(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 932
  if ((unsigned int )weaponinfo[plyr->readyweapon].ammo == 5U) {
#line 933
    w_ready.num = & largeammo;
  } else {
#line 935
    w_ready.num = & plyr->ammo[weaponinfo[plyr->readyweapon].ammo];
  }
#line 945
  w_ready.data = (int )plyr->readyweapon;
#line 953
  i = 0;
  {
#line 953
  while (1) {
    while_continue: /* CIL Label */ ;
#line 953
    if (! (i < 3)) {
#line 953
      goto while_break;
    }
#line 955
    if (plyr->cards[i]) {
#line 955
      keyboxes[i] = i;
    } else {
#line 955
      keyboxes[i] = -1;
    }
#line 957
    if (plyr->cards[i + 3]) {
#line 958
      keyboxes[i] = i + 3;
    }
#line 953
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 962
  ST_updateFaceWidget();
#line 965
  st_notdeathmatch = (boolean )(! deathmatch);
#line 968
  if (st_statusbaron) {
#line 968
    if (! deathmatch) {
#line 968
      tmp = 1;
    } else {
#line 968
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 968
    tmp = 0;
  }
#line 968
  st_armson = (boolean )tmp;
#line 971
  if (deathmatch) {
#line 971
    if (st_statusbaron) {
#line 971
      tmp___0 = 1;
    } else {
#line 971
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 971
    tmp___0 = 0;
  }
#line 971
  st_fragson = (boolean )tmp___0;
#line 972
  st_fragscount = 0;
#line 974
  i = 0;
  {
#line 974
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 974
    if (! (i < 4)) {
#line 974
      goto while_break___0;
    }
#line 976
    if (i != consoleplayer) {
#line 977
      st_fragscount += plyr->frags[i];
    } else {
#line 979
      st_fragscount -= plyr->frags[i];
    }
#line 974
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 983
  st_msgcounter --;
#line 983
  if (! st_msgcounter) {
#line 984
    st_chat = st_oldchat;
  }
#line 986
  return;
}
}
#line 988 "st_stuff.c"
void ST_Ticker(void) 
{ 


  {
#line 991
  st_clock ++;
#line 992
  st_randomnumber = M_Random();
#line 993
  ST_updateWidgets();
#line 994
  st_oldhealth = plyr->health;
#line 996
  return;
}
}
#line 998 "st_stuff.c"
static int st_palette  =    0;
#line 1000 "st_stuff.c"
void ST_doPaletteStuff(void) 
{ 
  int palette ;
  byte *pal ;
  int cnt___0 ;
  int bzc ;
  void *tmp ;

  {
#line 1008
  cnt___0 = plyr->damagecount;
#line 1010
  if (plyr->powers[1]) {
#line 1013
    bzc = 12 - (plyr->powers[1] >> 6);
#line 1015
    if (bzc > cnt___0) {
#line 1016
      cnt___0 = bzc;
    }
  }
#line 1019
  if (cnt___0) {
#line 1021
    palette = (cnt___0 + 7) >> 3;
#line 1023
    if (palette >= 8) {
#line 1024
      palette = 7;
    }
#line 1026
    palette ++;
  } else
#line 1029
  if (plyr->bonuscount) {
#line 1031
    palette = (plyr->bonuscount + 7) >> 3;
#line 1033
    if (palette >= 4) {
#line 1034
      palette = 3;
    }
#line 1036
    palette += 9;
  } else
#line 1039
  if (plyr->powers[3] > 128) {
#line 1039
    goto _L;
  } else
#line 1039
  if (plyr->powers[3] & 8) {
    _L: /* CIL Label */ 
#line 1041
    palette = 13;
  } else {
#line 1043
    palette = 0;
  }
#line 1045
  if (palette != st_palette) {
#line 1047
    st_palette = palette;
#line 1048
    tmp = W_CacheLumpNum(lu_palette, 101);
#line 1048
    pal = (byte *)tmp + palette * 768;
#line 1049
    I_SetPalette(pal);
  }
#line 1052
  return;
}
}
#line 1054 "st_stuff.c"
void ST_drawWidgets(boolean refresh ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 1059
  if (st_statusbaron) {
#line 1059
    if (! deathmatch) {
#line 1059
      tmp = 1;
    } else {
#line 1059
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1059
    tmp = 0;
  }
#line 1059
  st_armson = (boolean )tmp;
#line 1062
  if (deathmatch) {
#line 1062
    if (st_statusbaron) {
#line 1062
      tmp___0 = 1;
    } else {
#line 1062
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1062
    tmp___0 = 0;
  }
#line 1062
  st_fragson = (boolean )tmp___0;
#line 1064
  STlib_updateNum(& w_ready, refresh);
#line 1066
  i = 0;
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1066
    if (! (i < 4)) {
#line 1066
      goto while_break;
    }
#line 1068
    STlib_updateNum(& w_ammo[i], refresh);
#line 1069
    STlib_updateNum(& w_maxammo[i], refresh);
#line 1066
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1072
  STlib_updatePercent(& w_health, (int )refresh);
#line 1073
  STlib_updatePercent(& w_armor, (int )refresh);
#line 1075
  STlib_updateBinIcon(& w_armsbg, refresh);
#line 1077
  i = 0;
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1077
    if (! (i < 6)) {
#line 1077
      goto while_break___0;
    }
#line 1078
    STlib_updateMultIcon(& w_arms[i], refresh);
#line 1077
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1080
  STlib_updateMultIcon(& w_faces, refresh);
#line 1082
  i = 0;
  {
#line 1082
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1082
    if (! (i < 3)) {
#line 1082
      goto while_break___1;
    }
#line 1083
    STlib_updateMultIcon(& w_keyboxes[i], refresh);
#line 1082
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1085
  STlib_updateNum(& w_frags, refresh);
#line 1087
  return;
}
}
#line 1089 "st_stuff.c"
void ST_doRefresh(void) 
{ 


  {
#line 1092
  st_firsttime = (boolean )0;
#line 1095
  ST_refreshBackground();
#line 1098
  ST_drawWidgets((boolean )1);
#line 1100
  return;
}
}
#line 1102 "st_stuff.c"
void ST_diffDraw(void) 
{ 


  {
#line 1105
  ST_drawWidgets((boolean )0);
#line 1106
  return;
}
}
#line 1108 "st_stuff.c"
void ST_Drawer(boolean fullscreen___0 , boolean refresh ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1111
  if (! fullscreen___0) {
#line 1111
    goto _L;
  } else
#line 1111
  if (automapactive) {
    _L: /* CIL Label */ 
#line 1111
    tmp = 1;
  } else {
#line 1111
    tmp = 0;
  }
#line 1111
  st_statusbaron = (boolean )tmp;
#line 1112
  if (st_firsttime) {
#line 1112
    goto _L___0;
  } else
#line 1112
  if (refresh) {
    _L___0: /* CIL Label */ 
#line 1112
    tmp___0 = 1;
  } else {
#line 1112
    tmp___0 = 0;
  }
#line 1112
  st_firsttime = (boolean )tmp___0;
#line 1115
  ST_doPaletteStuff();
#line 1118
  if (st_firsttime) {
#line 1118
    ST_doRefresh();
  } else {
#line 1120
    ST_diffDraw();
  }
#line 1122
  return;
}
}
#line 1124 "st_stuff.c"
void ST_loadGraphics(void) 
{ 
  int i ;
  int j ;
  int facenum ;
  char namebuf[9] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;
  void *tmp___20 ;
  int tmp___21 ;
  void *tmp___22 ;

  {
#line 1134
  i = 0;
  {
#line 1134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1134
    if (! (i < 10)) {
#line 1134
      goto while_break;
    }
#line 1136
    sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"STTNUM%d",
            i);
#line 1137
    tmp = W_CacheLumpName(namebuf, 1);
#line 1137
    tallnum[i] = (patch_t *)tmp;
#line 1139
    sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"STYSNUM%d",
            i);
#line 1140
    tmp___0 = W_CacheLumpName(namebuf, 1);
#line 1140
    shortnum[i] = (patch_t *)tmp___0;
#line 1134
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1145
  tmp___1 = W_CacheLumpName("STTPRCNT", 1);
#line 1145
  tallpercent = (patch_t *)tmp___1;
#line 1148
  i = 0;
  {
#line 1148
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1148
    if (! (i < 6)) {
#line 1148
      goto while_break___0;
    }
#line 1150
    sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"STKEYS%d",
            i);
#line 1151
    tmp___2 = W_CacheLumpName(namebuf, 1);
#line 1151
    keys[i] = (patch_t *)tmp___2;
#line 1148
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1155
  tmp___3 = W_CacheLumpName("STARMS", 1);
#line 1155
  armsbg = (patch_t *)tmp___3;
#line 1158
  i = 0;
  {
#line 1158
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1158
    if (! (i < 6)) {
#line 1158
      goto while_break___1;
    }
#line 1160
    sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"STGNUM%d",
            i + 2);
#line 1163
    tmp___4 = W_CacheLumpName(namebuf, 1);
#line 1163
    arms[i][0] = (patch_t *)tmp___4;
#line 1166
    arms[i][1] = shortnum[i + 2];
#line 1158
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1170
  sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"STFB%d", consoleplayer);
#line 1171
  tmp___5 = W_CacheLumpName(namebuf, 1);
#line 1171
  faceback = (patch_t *)tmp___5;
#line 1174
  tmp___6 = W_CacheLumpName("STBAR", 1);
#line 1174
  sbar = (patch_t *)tmp___6;
#line 1177
  facenum = 0;
#line 1178
  i = 0;
  {
#line 1178
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1178
    if (! (i < 5)) {
#line 1178
      goto while_break___2;
    }
#line 1180
    j = 0;
    {
#line 1180
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1180
      if (! (j < 3)) {
#line 1180
        goto while_break___3;
      }
#line 1182
      sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"STFST%d%d",
              i, j);
#line 1183
      tmp___7 = facenum;
#line 1183
      facenum ++;
#line 1183
      tmp___8 = W_CacheLumpName(namebuf, 1);
#line 1183
      faces[tmp___7] = (patch_t *)tmp___8;
#line 1180
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1185
    sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"STFTR%d0",
            i);
#line 1186
    tmp___9 = facenum;
#line 1186
    facenum ++;
#line 1186
    tmp___10 = W_CacheLumpName(namebuf, 1);
#line 1186
    faces[tmp___9] = (patch_t *)tmp___10;
#line 1187
    sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"STFTL%d0",
            i);
#line 1188
    tmp___11 = facenum;
#line 1188
    facenum ++;
#line 1188
    tmp___12 = W_CacheLumpName(namebuf, 1);
#line 1188
    faces[tmp___11] = (patch_t *)tmp___12;
#line 1189
    sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"STFOUCH%d",
            i);
#line 1190
    tmp___13 = facenum;
#line 1190
    facenum ++;
#line 1190
    tmp___14 = W_CacheLumpName(namebuf, 1);
#line 1190
    faces[tmp___13] = (patch_t *)tmp___14;
#line 1191
    sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"STFEVL%d",
            i);
#line 1192
    tmp___15 = facenum;
#line 1192
    facenum ++;
#line 1192
    tmp___16 = W_CacheLumpName(namebuf, 1);
#line 1192
    faces[tmp___15] = (patch_t *)tmp___16;
#line 1193
    sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"STFKILL%d",
            i);
#line 1194
    tmp___17 = facenum;
#line 1194
    facenum ++;
#line 1194
    tmp___18 = W_CacheLumpName(namebuf, 1);
#line 1194
    faces[tmp___17] = (patch_t *)tmp___18;
#line 1178
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1196
  tmp___19 = facenum;
#line 1196
  facenum ++;
#line 1196
  tmp___20 = W_CacheLumpName("STFGOD0", 1);
#line 1196
  faces[tmp___19] = (patch_t *)tmp___20;
#line 1197
  tmp___21 = facenum;
#line 1197
  facenum ++;
#line 1197
  tmp___22 = W_CacheLumpName("STFDEAD0", 1);
#line 1197
  faces[tmp___21] = (patch_t *)tmp___22;
#line 1199
  return;
}
}
#line 1201 "st_stuff.c"
void ST_loadData(void) 
{ 


  {
#line 1203
  lu_palette = W_GetNumForName("PLAYPAL");
#line 1204
  ST_loadGraphics();
#line 1205
  return;
}
}
#line 1207 "st_stuff.c"
void ST_unloadGraphics(void) 
{ 
  int i ;

  {
#line 1213
  i = 0;
  {
#line 1213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1213
    if (! (i < 10)) {
#line 1213
      goto while_break;
    }
#line 1215
    if (((memblock_t *)((byte *)tallnum[i] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1215
      I_Error("Z_CT at st_stuff.c:%i", 1215);
    }
#line 1215
    Z_ChangeTag2((void *)tallnum[i], 101);
#line 1216
    if (((memblock_t *)((byte *)shortnum[i] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1216
      I_Error("Z_CT at st_stuff.c:%i", 1216);
    }
#line 1216
    Z_ChangeTag2((void *)shortnum[i], 101);
#line 1213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1219
  if (((memblock_t *)((byte *)tallpercent - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1219
    I_Error("Z_CT at st_stuff.c:%i", 1219);
  }
#line 1219
  Z_ChangeTag2((void *)tallpercent, 101);
#line 1222
  if (((memblock_t *)((byte *)armsbg - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1222
    I_Error("Z_CT at st_stuff.c:%i", 1222);
  }
#line 1222
  Z_ChangeTag2((void *)armsbg, 101);
#line 1225
  i = 0;
  {
#line 1225
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1225
    if (! (i < 6)) {
#line 1225
      goto while_break___0;
    }
#line 1226
    if (((memblock_t *)((byte *)arms[i][0] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1226
      I_Error("Z_CT at st_stuff.c:%i", 1226);
    }
#line 1226
    Z_ChangeTag2((void *)arms[i][0], 101);
#line 1225
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1229
  i = 0;
  {
#line 1229
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1229
    if (! (i < 6)) {
#line 1229
      goto while_break___1;
    }
#line 1230
    if (((memblock_t *)((byte *)keys[i] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1230
      I_Error("Z_CT at st_stuff.c:%i", 1230);
    }
#line 1230
    Z_ChangeTag2((void *)keys[i], 101);
#line 1229
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1232
  if (((memblock_t *)((byte *)sbar - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1232
    I_Error("Z_CT at st_stuff.c:%i", 1232);
  }
#line 1232
  Z_ChangeTag2((void *)sbar, 101);
#line 1233
  if (((memblock_t *)((byte *)faceback - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1233
    I_Error("Z_CT at st_stuff.c:%i", 1233);
  }
#line 1233
  Z_ChangeTag2((void *)faceback, 101);
#line 1235
  i = 0;
  {
#line 1235
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1235
    if (! (i < 42)) {
#line 1235
      goto while_break___2;
    }
#line 1236
    if (((memblock_t *)((byte *)faces[i] - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 1236
      I_Error("Z_CT at st_stuff.c:%i", 1236);
    }
#line 1236
    Z_ChangeTag2((void *)faces[i], 101);
#line 1235
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1242
  return;
}
}
#line 1244 "st_stuff.c"
void ST_unloadData(void) 
{ 


  {
#line 1246
  ST_unloadGraphics();
#line 1247
  return;
}
}
#line 1249 "st_stuff.c"
void ST_initData(void) 
{ 
  int i ;

  {
#line 1254
  st_firsttime = (boolean )1;
#line 1255
  plyr = & players[consoleplayer];
#line 1257
  st_clock = 0U;
#line 1258
  st_chatstate = (st_chatstateenum_t )0;
#line 1259
  st_gamestate = (st_stateenum_t )1;
#line 1261
  st_statusbaron = (boolean )1;
#line 1262
  st_chat = (boolean )0;
#line 1262
  st_oldchat = st_chat;
#line 1263
  st_cursoron = (boolean )0;
#line 1265
  st_faceindex = 0;
#line 1266
  st_palette = -1;
#line 1268
  st_oldhealth = -1;
#line 1270
  i = 0;
  {
#line 1270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1270
    if (! (i < 9)) {
#line 1270
      goto while_break;
    }
#line 1271
    oldweaponsowned[i] = plyr->weaponowned[i];
#line 1270
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1273
  i = 0;
  {
#line 1273
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1273
    if (! (i < 3)) {
#line 1273
      goto while_break___0;
    }
#line 1274
    keyboxes[i] = -1;
#line 1273
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1276
  STlib_init();
#line 1278
  return;
}
}
#line 1282 "st_stuff.c"
void ST_createWidgets(void) 
{ 
  int i ;

  {
#line 1288
  STlib_initNum(& w_ready, 44, 171, tallnum, & plyr->ammo[weaponinfo[plyr->readyweapon].ammo],
                & st_statusbaron, 3);
#line 1297
  w_ready.data = (int )plyr->readyweapon;
#line 1300
  STlib_initPercent(& w_health, 90, 171, tallnum, & plyr->health, & st_statusbaron,
                    tallpercent);
#line 1309
  STlib_initBinIcon(& w_armsbg, 104, 168, armsbg, & st_notdeathmatch, & st_statusbaron);
#line 1317
  i = 0;
  {
#line 1317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1317
    if (! (i < 6)) {
#line 1317
      goto while_break;
    }
#line 1319
    STlib_initMultIcon(& w_arms[i], 111 + (i % 3) * 12, 172 + (i / 3) * 10, arms[i],
                       (int *)(& plyr->weaponowned[i + 1]), & st_armson);
#line 1317
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1327
  STlib_initNum(& w_frags, 138, 171, tallnum, & st_fragscount, & st_fragson, 2);
#line 1336
  STlib_initMultIcon(& w_faces, 143, 168, faces, & st_faceindex, & st_statusbaron);
#line 1344
  STlib_initPercent(& w_armor, 221, 171, tallnum, & plyr->armorpoints, & st_statusbaron,
                    tallpercent);
#line 1352
  STlib_initMultIcon(& w_keyboxes[0], 239, 171, keys, & keyboxes[0], & st_statusbaron);
#line 1359
  STlib_initMultIcon(& w_keyboxes[1], 239, 181, keys, & keyboxes[1], & st_statusbaron);
#line 1366
  STlib_initMultIcon(& w_keyboxes[2], 239, 191, keys, & keyboxes[2], & st_statusbaron);
#line 1374
  STlib_initNum(& w_ammo[0], 288, 173, shortnum, & plyr->ammo[0], & st_statusbaron,
                3);
#line 1382
  STlib_initNum(& w_ammo[1], 288, 179, shortnum, & plyr->ammo[1], & st_statusbaron,
                3);
#line 1390
  STlib_initNum(& w_ammo[2], 288, 191, shortnum, & plyr->ammo[2], & st_statusbaron,
                3);
#line 1398
  STlib_initNum(& w_ammo[3], 288, 185, shortnum, & plyr->ammo[3], & st_statusbaron,
                3);
#line 1407
  STlib_initNum(& w_maxammo[0], 314, 173, shortnum, & plyr->maxammo[0], & st_statusbaron,
                3);
#line 1415
  STlib_initNum(& w_maxammo[1], 314, 179, shortnum, & plyr->maxammo[1], & st_statusbaron,
                3);
#line 1423
  STlib_initNum(& w_maxammo[2], 314, 191, shortnum, & plyr->maxammo[2], & st_statusbaron,
                3);
#line 1431
  STlib_initNum(& w_maxammo[3], 314, 185, shortnum, & plyr->maxammo[3], & st_statusbaron,
                3);
#line 1439
  return;
}
}
#line 1441 "st_stuff.c"
static boolean st_stopped  =    (boolean )1;
#line 1444 "st_stuff.c"
void ST_Start(void) 
{ 


  {
#line 1447
  if (! st_stopped) {
#line 1448
    ST_Stop();
  }
#line 1450
  ST_initData();
#line 1451
  ST_createWidgets();
#line 1452
  st_stopped = (boolean )0;
#line 1454
  return;
}
}
#line 1456 "st_stuff.c"
void ST_Stop(void) 
{ 
  void *tmp ;

  {
#line 1458
  if (st_stopped) {
#line 1459
    return;
  }
#line 1461
  tmp = W_CacheLumpNum(lu_palette, 101);
#line 1461
  I_SetPalette((byte *)tmp);
#line 1463
  st_stopped = (boolean )1;
#line 1464
  return;
}
}
#line 1466 "st_stuff.c"
void ST_Init(void) 
{ 
  void *tmp ;

  {
#line 1468
  veryfirsttime = 0;
#line 1469
  ST_loadData();
#line 1470
  tmp = Z_Malloc(10240, 1, (void *)0);
#line 1470
  screens[4] = (byte *)tmp;
#line 1471
  return;
}
}
#line 23 "hu_stuff.c"
static char const   rcsid___54[51]  = 
#line 23 "hu_stuff.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'u',      (char const   )'_', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'f', 
        (char const   )'f',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'4',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )' ',      (char const   )'1',      (char const   )'6',      (char const   )':', 
        (char const   )'4',      (char const   )'7',      (char const   )':',      (char const   )'5', 
        (char const   )'2',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 100 "hu_lib.h"
void HUlib_init(void) ;
#line 107
void HUlib_clearTextLine(hu_textline_t *t ) ;
#line 109
void HUlib_initTextLine(hu_textline_t *t , int x___0 , int y___1 , patch_t **f , int sc ) ;
#line 112
boolean HUlib_addCharToTextLine(hu_textline_t *t , char ch ) ;
#line 115
boolean HUlib_delCharFromTextLine(hu_textline_t *t ) ;
#line 118
void HUlib_drawTextLine(hu_textline_t *l___0 , boolean drawcursor ) ;
#line 121
void HUlib_eraseTextLine(hu_textline_t *l___0 ) ;
#line 129
void HUlib_initSText(hu_stext_t *s , int x___0 , int y___1 , int h , patch_t **font ,
                     int startchar , boolean *on ) ;
#line 140
void HUlib_addLineToSText(hu_stext_t *s ) ;
#line 143
void HUlib_addMessageToSText(hu_stext_t *s , char *prefix , char *msg ) ;
#line 150
void HUlib_drawSText(hu_stext_t *s ) ;
#line 153
void HUlib_eraseSText(hu_stext_t *s ) ;
#line 156
void HUlib_initIText(hu_itext_t *it , int x___0 , int y___1 , patch_t **font , int startchar ,
                     boolean *on ) ;
#line 166
void HUlib_delCharFromIText(hu_itext_t *it ) ;
#line 169
void HUlib_eraseLineFromIText(hu_itext_t *it ) ;
#line 172
void HUlib_resetIText(hu_itext_t *it ) ;
#line 175
void HUlib_addPrefixToIText(hu_itext_t *it , char *str ) ;
#line 181
boolean HUlib_keyInIText(hu_itext_t *it , unsigned char ch ) ;
#line 186
void HUlib_drawIText(hu_itext_t *it ) ;
#line 189
void HUlib_eraseIText(hu_itext_t *it ) ;
#line 65 "hu_stuff.c"
char *chat_macros[10]  = 
#line 65 "hu_stuff.c"
  {      "No",      "I\'m ready to kick butt!",      "I\'m OK.",      "I\'m not looking too good!", 
        "Help!",      "You suck!",      "Next time, scumbag...",      "Come here!", 
        "I\'ll take care of it.",      "Yes"};
#line 79 "hu_stuff.c"
char *player_names[4]  = {      "Green: ",      "Indigo: ",      "Brown: ",      "Red: "};
#line 88 "hu_stuff.c"
char chat_char  ;
#line 89 "hu_stuff.c"
static player_t *plr___0  ;
#line 90 "hu_stuff.c"
patch_t *hu_font[63]  ;
#line 91 "hu_stuff.c"
static hu_textline_t w_title  ;
#line 92 "hu_stuff.c"
boolean chat_on  ;
#line 93 "hu_stuff.c"
static hu_itext_t w_chat  ;
#line 94 "hu_stuff.c"
static boolean always_off  =    (boolean )0;
#line 95 "hu_stuff.c"
static char chat_dest[4]  ;
#line 96 "hu_stuff.c"
static hu_itext_t w_inputbuffer[4]  ;
#line 98 "hu_stuff.c"
static boolean message_on  ;
#line 99 "hu_stuff.c"
boolean message_dontfuckwithme  ;
#line 100 "hu_stuff.c"
static boolean message_nottobefuckedwith  ;
#line 102 "hu_stuff.c"
static hu_stext_t w_message  ;
#line 103 "hu_stuff.c"
static int message_counter  ;
#line 108 "hu_stuff.c"
static boolean headsupactive  =    (boolean )0;
#line 115 "hu_stuff.c"
char *mapnames[45]  = 
#line 115
  {      "E1M1: Hangar",      "E1M2: Nuclear Plant",      "E1M3: Toxin Refinery",      "E1M4: Command Control", 
        "E1M5: Phobos Lab",      "E1M6: Central Processing",      "E1M7: Computer Station",      "E1M8: Phobos Anomaly", 
        "E1M9: Military Base",      "E2M1: Deimos Anomaly",      "E2M2: Containment Area",      "E2M3: Refinery", 
        "E2M4: Deimos Lab",      "E2M5: Command Center",      "E2M6: Halls of the Damned",      "E2M7: Spawning Vats", 
        "E2M8: Tower of Babel",      "E2M9: Fortress of Mystery",      "E3M1: Hell Keep",      "E3M2: Slough of Despair", 
        "E3M3: Pandemonium",      "E3M4: House of Pain",      "E3M5: Unholy Cathedral",      "E3M6: Mt. Erebus", 
        "E3M7: Limbo",      "E3M8: Dis",      "E3M9: Warrens",      "E4M1: Hell Beneath", 
        "E4M2: Perfect Hatred",      "E4M3: Sever The Wicked",      "E4M4: Unruly Evil",      "E4M5: They Will Repent", 
        "E4M6: Against Thee Wickedly",      "E4M7: And Hell Followed",      "E4M8: Unto The Cruel",      "E4M9: Fear", 
        "NEWLEVEL",      "NEWLEVEL",      "NEWLEVEL",      "NEWLEVEL", 
        "NEWLEVEL",      "NEWLEVEL",      "NEWLEVEL",      "NEWLEVEL", 
        "NEWLEVEL"};
#line 169 "hu_stuff.c"
char *mapnames2[32]  = 
#line 169
  {      "level 1: entryway",      "level 2: underhalls",      "level 3: the gantlet",      "level 4: the focus", 
        "level 5: the waste tunnels",      "level 6: the crusher",      "level 7: dead simple",      "level 8: tricks and traps", 
        "level 9: the pit",      "level 10: refueling base",      "level 11: \'o\' of destruction!",      "level 12: the factory", 
        "level 13: downtown",      "level 14: the inmost dens",      "level 15: industrial zone",      "level 16: suburbs", 
        "level 17: tenements",      "level 18: the courtyard",      "level 19: the citadel",      "level 20: gotcha!", 
        "level 21: nirvana",      "level 22: the catacombs",      "level 23: barrels o\' fun",      "level 24: the chasm", 
        "level 25: bloodfalls",      "level 26: the abandoned mines",      "level 27: monster condo",      "level 28: the spirit world", 
        "level 29: the living end",      "level 30: icon of sin",      "level 31: wolfenstein",      "level 32: grosse"};
#line 208 "hu_stuff.c"
char *mapnamesp[32]  = 
#line 208
  {      "level 1: congo",      "level 2: well of souls",      "level 3: aztec",      "level 4: caged", 
        "level 5: ghost town",      "level 6: baron\'s lair",      "level 7: caughtyard",      "level 8: realm", 
        "level 9: abattoire",      "level 10: onslaught",      "level 11: hunted",      "level 12: speed", 
        "level 13: the crypt",      "level 14: genesis",      "level 15: the twilight",      "level 16: the omen", 
        "level 17: compound",      "level 18: neurosphere",      "level 19: nme",      "level 20: the death domain", 
        "level 21: slayer",      "level 22: impossible mission",      "level 23: tombstone",      "level 24: the final frontier", 
        "level 25: the temple of darkness",      "level 26: bunker",      "level 27: anti-christ",      "level 28: the sewers", 
        "level 29: odyssey of noises",      "level 30: the gateway of hell",      "level 31: cyberden",      "level 32: go 2 it"};
#line 247 "hu_stuff.c"
char *mapnamest[32]  = 
#line 247
  {      "level 1: system control",      "level 2: human bbq",      "level 3: power control",      "level 4: wormhole", 
        "level 5: hanger",      "level 6: open season",      "level 7: prison",      "level 8: metal", 
        "level 9: stronghold",      "level 10: redemption",      "level 11: storage facility",      "level 12: crater", 
        "level 13: nukage processing",      "level 14: steel works",      "level 15: dead zone",      "level 16: deepest reaches", 
        "level 17: processing area",      "level 18: mill",      "level 19: shipping/respawning",      "level 20: central processing", 
        "level 21: administration center",      "level 22: habitat",      "level 23: lunar mining project",      "level 24: quarry", 
        "level 25: baron\'s den",      "level 26: ballistyx",      "level 27: mount pain",      "level 28: heck", 
        "level 29: river styx",      "level 30: last call",      "level 31: pharaoh",      "level 32: caribbean"};
#line 286 "hu_stuff.c"
char const   *shiftxform  ;
#line 288 "hu_stuff.c"
char const   french_shiftxform[128]  = 
#line 288
  {      (char const   )0,      (char const   )1,      (char const   )2,      (char const   )3, 
        (char const   )4,      (char const   )5,      (char const   )6,      (char const   )7, 
        (char const   )8,      (char const   )9,      (char const   )10,      (char const   )11, 
        (char const   )12,      (char const   )13,      (char const   )14,      (char const   )15, 
        (char const   )16,      (char const   )17,      (char const   )18,      (char const   )19, 
        (char const   )20,      (char const   )21,      (char const   )22,      (char const   )23, 
        (char const   )24,      (char const   )25,      (char const   )26,      (char const   )27, 
        (char const   )28,      (char const   )29,      (char const   )30,      (char const   )31, 
        (char const   )' ',      (char const   )'!',      (char const   )'\"',      (char const   )'#', 
        (char const   )'$',      (char const   )'%',      (char const   )'&',      (char const   )'\"', 
        (char const   )'(',      (char const   )')',      (char const   )'*',      (char const   )'+', 
        (char const   )'?',      (char const   )'_',      (char const   )'>',      (char const   )'?', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'/',      (char const   )'.', 
        (char const   )'<',      (char const   )'+',      (char const   )'>',      (char const   )'?', 
        (char const   )'@',      (char const   )'A',      (char const   )'B',      (char const   )'C', 
        (char const   )'D',      (char const   )'E',      (char const   )'F',      (char const   )'G', 
        (char const   )'H',      (char const   )'I',      (char const   )'J',      (char const   )'K', 
        (char const   )'L',      (char const   )'M',      (char const   )'N',      (char const   )'O', 
        (char const   )'P',      (char const   )'Q',      (char const   )'R',      (char const   )'S', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'W', 
        (char const   )'X',      (char const   )'Y',      (char const   )'Z',      (char const   )'[', 
        (char const   )'!',      (char const   )']',      (char const   )'\"',      (char const   )'_', 
        (char const   )'\'',      (char const   )'A',      (char const   )'B',      (char const   )'C', 
        (char const   )'D',      (char const   )'E',      (char const   )'F',      (char const   )'G', 
        (char const   )'H',      (char const   )'I',      (char const   )'J',      (char const   )'K', 
        (char const   )'L',      (char const   )'M',      (char const   )'N',      (char const   )'O', 
        (char const   )'P',      (char const   )'Q',      (char const   )'R',      (char const   )'S', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'W', 
        (char const   )'X',      (char const   )'Y',      (char const   )'Z',      (char const   )'{', 
        (char const   )'|',      (char const   )'}',      (char const   )'~',      (char const   )127};
#line 330 "hu_stuff.c"
char const   english_shiftxform[128]  = 
#line 330
  {      (char const   )0,      (char const   )1,      (char const   )2,      (char const   )3, 
        (char const   )4,      (char const   )5,      (char const   )6,      (char const   )7, 
        (char const   )8,      (char const   )9,      (char const   )10,      (char const   )11, 
        (char const   )12,      (char const   )13,      (char const   )14,      (char const   )15, 
        (char const   )16,      (char const   )17,      (char const   )18,      (char const   )19, 
        (char const   )20,      (char const   )21,      (char const   )22,      (char const   )23, 
        (char const   )24,      (char const   )25,      (char const   )26,      (char const   )27, 
        (char const   )28,      (char const   )29,      (char const   )30,      (char const   )31, 
        (char const   )' ',      (char const   )'!',      (char const   )'\"',      (char const   )'#', 
        (char const   )'$',      (char const   )'%',      (char const   )'&',      (char const   )'\"', 
        (char const   )'(',      (char const   )')',      (char const   )'*',      (char const   )'+', 
        (char const   )'<',      (char const   )'_',      (char const   )'>',      (char const   )'?', 
        (char const   )')',      (char const   )'!',      (char const   )'@',      (char const   )'#', 
        (char const   )'$',      (char const   )'%',      (char const   )'^',      (char const   )'&', 
        (char const   )'*',      (char const   )'(',      (char const   )':',      (char const   )':', 
        (char const   )'<',      (char const   )'+',      (char const   )'>',      (char const   )'?', 
        (char const   )'@',      (char const   )'A',      (char const   )'B',      (char const   )'C', 
        (char const   )'D',      (char const   )'E',      (char const   )'F',      (char const   )'G', 
        (char const   )'H',      (char const   )'I',      (char const   )'J',      (char const   )'K', 
        (char const   )'L',      (char const   )'M',      (char const   )'N',      (char const   )'O', 
        (char const   )'P',      (char const   )'Q',      (char const   )'R',      (char const   )'S', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'W', 
        (char const   )'X',      (char const   )'Y',      (char const   )'Z',      (char const   )'[', 
        (char const   )'!',      (char const   )']',      (char const   )'\"',      (char const   )'_', 
        (char const   )'\'',      (char const   )'A',      (char const   )'B',      (char const   )'C', 
        (char const   )'D',      (char const   )'E',      (char const   )'F',      (char const   )'G', 
        (char const   )'H',      (char const   )'I',      (char const   )'J',      (char const   )'K', 
        (char const   )'L',      (char const   )'M',      (char const   )'N',      (char const   )'O', 
        (char const   )'P',      (char const   )'Q',      (char const   )'R',      (char const   )'S', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'W', 
        (char const   )'X',      (char const   )'Y',      (char const   )'Z',      (char const   )'{', 
        (char const   )'|',      (char const   )'}',      (char const   )'~',      (char const   )127};
#line 372 "hu_stuff.c"
char frenchKeyMap[128]  = 
#line 372
  {      (char)0,      (char)1,      (char)2,      (char)3, 
        (char)4,      (char)5,      (char)6,      (char)7, 
        (char)8,      (char)9,      (char)10,      (char)11, 
        (char)12,      (char)13,      (char)14,      (char)15, 
        (char)16,      (char)17,      (char)18,      (char)19, 
        (char)20,      (char)21,      (char)22,      (char)23, 
        (char)24,      (char)25,      (char)26,      (char)27, 
        (char)28,      (char)29,      (char)30,      (char)31, 
        (char )' ',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'%', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )';',      (char )'-',      (char )':',      (char )'!', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )':',      (char )'M', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'Q',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )',',      (char )'N',      (char )'O', 
        (char )'P',      (char )'A',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'Z', 
        (char )'X',      (char )'Y',      (char )'W',      (char )'^', 
        (char )'\\',      (char )'$',      (char )'^',      (char )'_', 
        (char )'@',      (char )'Q',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )',',      (char )'N',      (char )'O', 
        (char )'P',      (char )'A',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'Z', 
        (char )'X',      (char )'Y',      (char )'W',      (char )'^', 
        (char )'\\',      (char )'$',      (char )'^',      (char)127};
#line 387 "hu_stuff.c"
char ForeignTranslation(unsigned char ch ) 
{ 
  int tmp ;

  {
#line 389
  if ((int )ch < 128) {
#line 389
    tmp = (int )frenchKeyMap[ch];
  } else {
#line 389
    tmp = (int )ch;
  }
#line 389
  return ((char )tmp);
}
}
#line 392 "hu_stuff.c"
void HU_Init(void) 
{ 
  int i ;
  int j ;
  char buffer___0[9] ;
  int tmp ;
  void *tmp___0 ;

  {
#line 399
  if (1) {
#line 400
    shiftxform = french_shiftxform;
  } else {
#line 402
    shiftxform = english_shiftxform;
  }
#line 405
  j = '!';
#line 406
  i = 0;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! (i < 63)) {
#line 406
      goto while_break;
    }
#line 408
    tmp = j;
#line 408
    j ++;
#line 408
    sprintf((char * __restrict  )(buffer___0), (char const   * __restrict  )"STCFN%.3d",
            tmp);
#line 409
    tmp___0 = W_CacheLumpName(buffer___0, 1);
#line 409
    hu_font[i] = (patch_t *)tmp___0;
#line 406
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 412
  return;
}
}
#line 414 "hu_stuff.c"
void HU_Stop(void) 
{ 


  {
#line 416
  headsupactive = (boolean )0;
#line 417
  return;
}
}
#line 419 "hu_stuff.c"
void HU_Start(void) 
{ 
  int i ;
  char *s ;
  char *tmp ;

  {
#line 425
  if (headsupactive) {
#line 426
    HU_Stop();
  }
#line 428
  plr___0 = & players[consoleplayer];
#line 429
  message_on = (boolean )0;
#line 430
  message_dontfuckwithme = (boolean )0;
#line 431
  message_nottobefuckedwith = (boolean )0;
#line 432
  chat_on = (boolean )0;
#line 435
  HUlib_initSText(& w_message, 0, 0, 1, hu_font, '!', & message_on);
#line 441
  HUlib_initTextLine(& w_title, 0, 167 - (int )(hu_font[0])->height, hu_font, '!');
  {
#line 450
  if ((unsigned int )gamemode == 3U) {
#line 450
    goto case_3;
  }
#line 450
  if ((unsigned int )gamemode == 1U) {
#line 450
    goto case_3;
  }
#line 450
  if ((unsigned int )gamemode == 0U) {
#line 450
    goto case_3;
  }
#line 464
  goto switch_default;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 451
  s = mapnames[((gameepisode - 1) * 9 + gamemap) - 1];
#line 452
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 465
  s = mapnames2[gamemap - 1];
#line 466
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (! *s) {
#line 469
      goto while_break;
    }
#line 470
    tmp = s;
#line 470
    s ++;
#line 470
    HUlib_addCharToTextLine(& w_title, *tmp);
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  HUlib_initIText(& w_chat, 0, (int )(hu_font[0])->height + 1, hu_font, '!', & chat_on);
#line 479
  i = 0;
  {
#line 479
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 479
    if (! (i < 4)) {
#line 479
      goto while_break___0;
    }
#line 480
    HUlib_initIText(& w_inputbuffer[i], 0, 0, (patch_t **)0, 0, & always_off);
#line 479
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 482
  headsupactive = (boolean )1;
#line 484
  return;
}
}
#line 486 "hu_stuff.c"
void HU_Drawer(void) 
{ 


  {
#line 489
  HUlib_drawSText(& w_message);
#line 490
  HUlib_drawIText(& w_chat);
#line 491
  if (automapactive) {
#line 492
    HUlib_drawTextLine(& w_title, (boolean )0);
  }
#line 494
  return;
}
}
#line 496 "hu_stuff.c"
void HU_Erase(void) 
{ 


  {
#line 499
  HUlib_eraseSText(& w_message);
#line 500
  HUlib_eraseIText(& w_chat);
#line 501
  HUlib_eraseTextLine(& w_title);
#line 503
  return;
}
}
#line 505 "hu_stuff.c"
void HU_Ticker(void) 
{ 
  int i ;
  int rc ;
  char c ;
  boolean tmp ;

  {
#line 512
  if (message_counter) {
#line 512
    message_counter --;
#line 512
    if (message_counter) {
#line 512
      goto _L;
    } else {
#line 514
      message_on = (boolean )0;
#line 515
      message_nottobefuckedwith = (boolean )0;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 518
  if (showMessages) {
#line 518
    goto _L___3;
  } else
#line 518
  if (message_dontfuckwithme) {
    _L___3: /* CIL Label */ 
#line 522
    if (plr___0->message) {
#line 522
      if (! message_nottobefuckedwith) {
#line 522
        goto _L___0;
      } else {
#line 522
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 522
    if (plr___0->message) {
#line 522
      if (message_dontfuckwithme) {
        _L___0: /* CIL Label */ 
#line 525
        HUlib_addMessageToSText(& w_message, (char *)0, plr___0->message);
#line 526
        plr___0->message = (char *)0;
#line 527
        message_on = (boolean )1;
#line 528
        message_counter = 140;
#line 529
        message_nottobefuckedwith = message_dontfuckwithme;
#line 530
        message_dontfuckwithme = (boolean )0;
      } else {
#line 522
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
  }
#line 536
  if (netgame) {
#line 538
    i = 0;
    {
#line 538
    while (1) {
      while_continue: /* CIL Label */ ;
#line 538
      if (! (i < 4)) {
#line 538
        goto while_break;
      }
#line 540
      if (! playeringame[i]) {
#line 541
        goto __Cont;
      }
#line 542
      if (i != consoleplayer) {
#line 542
        c = (char )players[i].cmd.chatchar;
#line 542
        if (c) {
#line 545
          if ((int )c <= 5) {
#line 546
            chat_dest[i] = c;
          } else {
#line 549
            if ((int )c >= 97) {
#line 549
              if ((int )c <= 122) {
#line 550
                c = (char )*(shiftxform + (unsigned char )c);
              } else {
#line 549
                goto _L___4;
              }
            } else {
              _L___4: /* CIL Label */ ;
            }
#line 551
            tmp = HUlib_keyInIText(& w_inputbuffer[i], (unsigned char )c);
#line 551
            rc = (int )tmp;
#line 552
            if (rc) {
#line 552
              if ((int )c == 13) {
#line 554
                if (w_inputbuffer[i].l.len) {
#line 554
                  if ((int )chat_dest[i] == consoleplayer + 1) {
#line 554
                    goto _L___6;
                  } else
#line 554
                  if ((int )chat_dest[i] == 5) {
                    _L___6: /* CIL Label */ 
#line 558
                    HUlib_addMessageToSText(& w_message, player_names[i], w_inputbuffer[i].l.l);
#line 562
                    message_nottobefuckedwith = (boolean )1;
#line 563
                    message_on = (boolean )1;
#line 564
                    message_counter = 140;
#line 565
                    if ((unsigned int )gamemode == 2U) {
#line 566
                      S_StartSound((void *)0, 108);
                    } else {
#line 568
                      S_StartSound((void *)0, 87);
                    }
                  } else {
#line 554
                    goto _L___5;
                  }
                } else {
                  _L___5: /* CIL Label */ ;
                }
#line 570
                HUlib_resetIText(& w_inputbuffer[i]);
              } else {
#line 552
                goto _L___7;
              }
            } else {
              _L___7: /* CIL Label */ ;
            }
          }
#line 573
          players[i].cmd.chatchar = (byte )0;
        } else {
#line 542
          goto _L___8;
        }
      } else {
        _L___8: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 538
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 578
  return;
}
}
#line 582 "hu_stuff.c"
static char chatchars[128]  ;
#line 583 "hu_stuff.c"
static int head  =    0;
#line 584 "hu_stuff.c"
static int tail  =    0;
#line 587 "hu_stuff.c"
void HU_queueChatChar(char c ) 
{ 


  {
#line 589
  if (((head + 1) & 127) == tail) {
#line 591
    plr___0->message = "[Message unsent]";
  } else {
#line 595
    chatchars[head] = c;
#line 596
    head = (head + 1) & 127;
  }
#line 598
  return;
}
}
#line 600 "hu_stuff.c"
char HU_dequeueChatChar(void) 
{ 
  char c ;

  {
#line 604
  if (head != tail) {
#line 606
    c = chatchars[tail];
#line 607
    tail = (tail + 1) & 127;
  } else {
#line 611
    c = (char)0;
  }
#line 614
  return (c);
}
}
#line 620 "hu_stuff.c"
static char lastmessage[81]  ;
#line 623 "hu_stuff.c"
static boolean shiftdown  =    (boolean )0;
#line 624 "hu_stuff.c"
static boolean altdown  =    (boolean )0;
#line 629 "hu_stuff.c"
static char destination_keys[4]  = {      (char )'g',      (char )'i',      (char )'b',      (char )'r'};
#line 637 "hu_stuff.c"
static int num_nobrainers  =    0;
#line 617 "hu_stuff.c"
boolean HU_Responder(event_t *ev ) 
{ 
  char *macromessage ;
  boolean eatkey ;
  unsigned char c ;
  int i ;
  int numplayers ;
  char *tmp ;
  char tmp___0 ;

  {
#line 622
  eatkey = (boolean )0;
#line 639
  numplayers = 0;
#line 640
  i = 0;
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (! (i < 4)) {
#line 640
      goto while_break;
    }
#line 641
    numplayers = (int )((unsigned int )numplayers + (unsigned int )playeringame[i]);
#line 640
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 643
  if (ev->data1 == 182) {
#line 645
    shiftdown = (boolean )((unsigned int )ev->type == 0U);
#line 646
    return ((boolean )0);
  } else
#line 648
  if (ev->data1 == 184) {
#line 648
    goto _L;
  } else
#line 648
  if (ev->data1 == 184) {
    _L: /* CIL Label */ 
#line 650
    altdown = (boolean )((unsigned int )ev->type == 0U);
#line 651
    return ((boolean )0);
  }
#line 654
  if ((unsigned int )ev->type != 0U) {
#line 655
    return ((boolean )0);
  }
#line 657
  if (! chat_on) {
#line 659
    if (ev->data1 == 13) {
#line 661
      message_on = (boolean )1;
#line 662
      message_counter = 140;
#line 663
      eatkey = (boolean )1;
    } else
#line 665
    if (netgame) {
#line 665
      if (ev->data1 == 116) {
#line 667
        chat_on = (boolean )1;
#line 667
        eatkey = chat_on;
#line 668
        HUlib_resetIText(& w_chat);
#line 669
        HU_queueChatChar((char)5);
      } else {
#line 665
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 671
    if (netgame) {
#line 671
      if (numplayers > 2) {
#line 673
        i = 0;
        {
#line 673
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 673
          if (! (i < 4)) {
#line 673
            goto while_break___0;
          }
#line 675
          if (ev->data1 == (int )destination_keys[i]) {
#line 677
            if (playeringame[i]) {
#line 677
              if (i != consoleplayer) {
#line 679
                chat_on = (boolean )1;
#line 679
                eatkey = chat_on;
#line 680
                HUlib_resetIText(& w_chat);
#line 681
                HU_queueChatChar((char )(i + 1));
#line 682
                goto while_break___0;
              } else {
#line 677
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 684
            if (i == consoleplayer) {
#line 686
              num_nobrainers ++;
#line 687
              if (num_nobrainers < 3) {
#line 688
                plr___0->message = "You mumble to yourself";
              } else
#line 689
              if (num_nobrainers < 6) {
#line 690
                plr___0->message = "Who\'s there?";
              } else
#line 691
              if (num_nobrainers < 9) {
#line 692
                plr___0->message = "You scare yourself";
              } else
#line 693
              if (num_nobrainers < 32) {
#line 694
                plr___0->message = "You start to rave";
              } else {
#line 696
                plr___0->message = "You\'ve lost it...";
              }
            }
          }
#line 673
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 671
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
  } else {
#line 704
    c = (unsigned char )ev->data1;
#line 706
    if (altdown) {
#line 708
      c = (unsigned char )((int )c - 48);
#line 709
      if ((int )c > 9) {
#line 710
        return ((boolean )0);
      }
#line 712
      macromessage = chat_macros[c];
#line 715
      HU_queueChatChar((char)13);
      {
#line 718
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 718
        if (! *macromessage) {
#line 718
          goto while_break___1;
        }
#line 719
        tmp = macromessage;
#line 719
        macromessage ++;
#line 719
        HU_queueChatChar(*tmp);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 720
      HU_queueChatChar((char)13);
#line 723
      chat_on = (boolean )0;
#line 724
      strcpy((char * __restrict  )(lastmessage), (char const   * __restrict  )chat_macros[c]);
#line 725
      plr___0->message = lastmessage;
#line 726
      eatkey = (boolean )1;
    } else {
#line 730
      if (1) {
#line 731
        tmp___0 = ForeignTranslation(c);
#line 731
        c = (unsigned char )tmp___0;
      }
#line 732
      if (shiftdown) {
#line 732
        goto _L___3;
      } else
#line 732
      if ((int )c >= 97) {
#line 732
        if ((int )c <= 122) {
          _L___3: /* CIL Label */ 
#line 733
          c = (unsigned char )*(shiftxform + c);
        } else {
#line 732
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ ;
      }
#line 734
      eatkey = HUlib_keyInIText(& w_chat, c);
#line 735
      if (eatkey) {
#line 738
        HU_queueChatChar((char )c);
      }
#line 743
      if ((int )c == 13) {
#line 745
        chat_on = (boolean )0;
#line 746
        if (w_chat.l.len) {
#line 748
          strcpy((char * __restrict  )(lastmessage), (char const   * __restrict  )(w_chat.l.l));
#line 749
          plr___0->message = lastmessage;
        }
      } else
#line 752
      if ((int )c == 27) {
#line 753
        chat_on = (boolean )0;
      }
    }
  }
#line 757
  return (eatkey);
}
}
#line 23 "hu_lib.c"
static char const   rcsid___55[49]  = 
#line 23 "hu_lib.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'u',      (char const   )'_', 
        (char const   )'l',      (char const   )'i',      (char const   )'b',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'3',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'1',      (char const   )'/', 
        (char const   )'2',      (char const   )'6',      (char const   )' ',      (char const   )'0', 
        (char const   )'7',      (char const   )':',      (char const   )'4',      (char const   )'4', 
        (char const   )':',      (char const   )'5',      (char const   )'8',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "hu_lib.c"
void HUlib_init(void) 
{ 


  {
#line 44
  return;
}
}
#line 46 "hu_lib.c"
void HUlib_clearTextLine(hu_textline_t *t ) 
{ 


  {
#line 48
  t->len = 0;
#line 49
  t->l[0] = (char)0;
#line 50
  t->needsupdate = 1;
#line 51
  return;
}
}
#line 53 "hu_lib.c"
void HUlib_initTextLine(hu_textline_t *t , int x___0 , int y___1 , patch_t **f , int sc ) 
{ 


  {
#line 61
  t->x = x___0;
#line 62
  t->y = y___1;
#line 63
  t->f = f;
#line 64
  t->sc = sc;
#line 65
  HUlib_clearTextLine(t);
#line 66
  return;
}
}
#line 68 "hu_lib.c"
boolean HUlib_addCharToTextLine(hu_textline_t *t , char ch ) 
{ 
  int tmp ;

  {
#line 74
  if (t->len == 80) {
#line 75
    return ((boolean )0);
  } else {
#line 78
    tmp = t->len;
#line 78
    (t->len) ++;
#line 78
    t->l[tmp] = ch;
#line 79
    t->l[t->len] = (char)0;
#line 80
    t->needsupdate = 4;
#line 81
    return ((boolean )1);
  }
}
}
#line 86 "hu_lib.c"
boolean HUlib_delCharFromTextLine(hu_textline_t *t ) 
{ 


  {
#line 89
  if (! t->len) {
#line 89
    return ((boolean )0);
  } else {
#line 92
    (t->len) --;
#line 92
    t->l[t->len] = (char)0;
#line 93
    t->needsupdate = 4;
#line 94
    return ((boolean )1);
  }
}
}
#line 99 "hu_lib.c"
void HUlib_drawTextLine(hu_textline_t *l___0 , boolean drawcursor ) 
{ 
  int i ;
  int w ;
  int x___0 ;
  unsigned char c ;
  int tmp ;

  {
#line 111
  x___0 = l___0->x;
#line 112
  i = 0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i < l___0->len)) {
#line 112
      goto while_break;
    }
#line 114
    tmp = toupper((int )l___0->l[i]);
#line 114
    c = (unsigned char )tmp;
#line 115
    if ((int )c != 32) {
#line 115
      if ((int )c >= l___0->sc) {
#line 115
        if ((int )c <= 95) {
#line 119
          w = (int )(*(l___0->f + ((int )c - l___0->sc)))->width;
#line 120
          if (x___0 + w > 320) {
#line 121
            goto while_break;
          }
#line 122
          V_DrawPatchDirect(x___0, l___0->y, 0, *(l___0->f + ((int )c - l___0->sc)));
#line 123
          x___0 += w;
        } else {
#line 115
          goto _L___0;
        }
      } else {
#line 115
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
#line 127
      x___0 += 4;
#line 128
      if (x___0 >= 320) {
#line 129
        goto while_break;
      }
    }
#line 112
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  if (drawcursor) {
#line 134
    if (x___0 + (int )(*(l___0->f + (95 - l___0->sc)))->width <= 320) {
#line 137
      V_DrawPatchDirect(x___0, l___0->y, 0, *(l___0->f + (95 - l___0->sc)));
    } else {
#line 134
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 148 "hu_lib.c"
static boolean lastautomapactive  =    (boolean )1;
#line 143 "hu_lib.c"
void HUlib_eraseTextLine(hu_textline_t *l___0 ) 
{ 
  int lh ;
  int y___1 ;
  int yoffset ;

  {
#line 154
  if (! automapactive) {
#line 154
    if (viewwindowx) {
#line 154
      if (l___0->needsupdate) {
#line 157
        lh = (int )(*(l___0->f + 0))->height + 1;
#line 158
        y___1 = l___0->y;
#line 158
        yoffset = y___1 * 320;
        {
#line 158
        while (1) {
          while_continue: /* CIL Label */ ;
#line 158
          if (! (y___1 < l___0->y + lh)) {
#line 158
            goto while_break;
          }
#line 160
          if (y___1 < viewwindowy) {
#line 160
            goto _L;
          } else
#line 160
          if (y___1 >= viewwindowy + viewheight) {
            _L: /* CIL Label */ 
#line 161
            R_VideoErase((unsigned int )yoffset, 320);
          } else {
#line 164
            R_VideoErase((unsigned int )yoffset, viewwindowx);
#line 165
            R_VideoErase((unsigned int )((yoffset + viewwindowx) + viewwidth), viewwindowx);
          }
#line 158
          y___1 ++;
#line 158
          yoffset += 320;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 154
        goto _L___1;
      }
    } else {
#line 154
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ ;
  }
#line 171
  lastautomapactive = automapactive;
#line 172
  if (l___0->needsupdate) {
#line 172
    (l___0->needsupdate) --;
  }
#line 174
  return;
}
}
#line 176 "hu_lib.c"
void HUlib_initSText(hu_stext_t *s , int x___0 , int y___1 , int h , patch_t **font ,
                     int startchar , boolean *on ) 
{ 
  int i ;

  {
#line 189
  s->h = h;
#line 190
  s->on = on;
#line 191
  s->laston = (boolean )1;
#line 192
  s->cl = 0;
#line 193
  i = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (i < h)) {
#line 193
      goto while_break;
    }
#line 194
    HUlib_initTextLine(& s->l[i], x___0, y___1 - i * ((int )(*(font + 0))->height + 1),
                       font, startchar);
#line 193
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return;
}
}
#line 200 "hu_lib.c"
void HUlib_addLineToSText(hu_stext_t *s ) 
{ 
  int i ;

  {
#line 206
  (s->cl) ++;
#line 206
  if (s->cl == s->h) {
#line 207
    s->cl = 0;
  }
#line 208
  HUlib_clearTextLine(& s->l[s->cl]);
#line 211
  i = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < s->h)) {
#line 211
      goto while_break;
    }
#line 212
    s->l[i].needsupdate = 4;
#line 211
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 216 "hu_lib.c"
void HUlib_addMessageToSText(hu_stext_t *s , char *prefix , char *msg ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 222
  HUlib_addLineToSText(s);
#line 223
  if (prefix) {
    {
#line 224
    while (1) {
      while_continue: /* CIL Label */ ;
#line 224
      if (! *prefix) {
#line 224
        goto while_break;
      }
#line 225
      tmp = prefix;
#line 225
      prefix ++;
#line 225
      HUlib_addCharToTextLine(& s->l[s->cl], *tmp);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 227
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 227
    if (! *msg) {
#line 227
      goto while_break___0;
    }
#line 228
    tmp___0 = msg;
#line 228
    msg ++;
#line 228
    HUlib_addCharToTextLine(& s->l[s->cl], *tmp___0);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 231 "hu_lib.c"
void HUlib_drawSText(hu_stext_t *s ) 
{ 
  int i ;
  int idx ;
  hu_textline_t *l___0 ;

  {
#line 236
  if (! *(s->on)) {
#line 237
    return;
  }
#line 240
  i = 0;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (i < s->h)) {
#line 240
      goto while_break;
    }
#line 242
    idx = s->cl - i;
#line 243
    if (idx < 0) {
#line 244
      idx += s->h;
    }
#line 246
    l___0 = & s->l[idx];
#line 249
    HUlib_drawTextLine(l___0, (boolean )0);
#line 240
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return;
}
}
#line 254 "hu_lib.c"
void HUlib_eraseSText(hu_stext_t *s ) 
{ 
  int i ;

  {
#line 259
  i = 0;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (i < s->h)) {
#line 259
      goto while_break;
    }
#line 261
    if (s->laston) {
#line 261
      if (! *(s->on)) {
#line 262
        s->l[i].needsupdate = 4;
      } else {
#line 261
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 263
    HUlib_eraseTextLine(& s->l[i]);
#line 259
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  s->laston = *(s->on);
#line 267
  return;
}
}
#line 269 "hu_lib.c"
void HUlib_initIText(hu_itext_t *it , int x___0 , int y___1 , patch_t **font , int startchar ,
                     boolean *on ) 
{ 


  {
#line 278
  it->lm = 0;
#line 279
  it->on = on;
#line 280
  it->laston = (boolean )1;
#line 281
  HUlib_initTextLine(& it->l, x___0, y___1, font, startchar);
#line 282
  return;
}
}
#line 286 "hu_lib.c"
void HUlib_delCharFromIText(hu_itext_t *it ) 
{ 


  {
#line 288
  if (it->l.len != it->lm) {
#line 289
    HUlib_delCharFromTextLine(& it->l);
  }
#line 290
  return;
}
}
#line 292 "hu_lib.c"
void HUlib_eraseLineFromIText(hu_itext_t *it ) 
{ 


  {
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (it->lm != it->l.len)) {
#line 294
      goto while_break;
    }
#line 295
    HUlib_delCharFromTextLine(& it->l);
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 299 "hu_lib.c"
void HUlib_resetIText(hu_itext_t *it ) 
{ 


  {
#line 301
  it->lm = 0;
#line 302
  HUlib_clearTextLine(& it->l);
#line 303
  return;
}
}
#line 305 "hu_lib.c"
void HUlib_addPrefixToIText(hu_itext_t *it , char *str ) 
{ 
  char *tmp ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! *str) {
#line 310
      goto while_break;
    }
#line 311
    tmp = str;
#line 311
    str ++;
#line 311
    HUlib_addCharToTextLine(& it->l, *tmp);
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  it->lm = it->l.len;
#line 313
  return;
}
}
#line 317 "hu_lib.c"
boolean HUlib_keyInIText(hu_itext_t *it , unsigned char ch ) 
{ 


  {
#line 323
  if ((int )ch >= 32) {
#line 323
    if ((int )ch <= 95) {
#line 324
      HUlib_addCharToTextLine(& it->l, (char )ch);
    } else {
#line 323
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 326
  if ((int )ch == 127) {
#line 327
    HUlib_delCharFromIText(it);
  } else
#line 329
  if ((int )ch != 13) {
#line 330
    return ((boolean )0);
  }
#line 332
  return ((boolean )1);
}
}
#line 336 "hu_lib.c"
void HUlib_drawIText(hu_itext_t *it ) 
{ 
  hu_textline_t *l___0 ;

  {
#line 339
  l___0 = & it->l;
#line 341
  if (! *(it->on)) {
#line 342
    return;
  }
#line 343
  HUlib_drawTextLine(l___0, (boolean )1);
#line 345
  return;
}
}
#line 347 "hu_lib.c"
void HUlib_eraseIText(hu_itext_t *it ) 
{ 


  {
#line 349
  if (it->laston) {
#line 349
    if (! *(it->on)) {
#line 350
      it->l.needsupdate = 4;
    } else {
#line 349
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 351
  HUlib_eraseTextLine(& it->l);
#line 352
  it->laston = *(it->on);
#line 353
  return;
}
}
#line 24 "s_sound.c"
static char const   rcsid___56[50]  = 
#line 24 "s_sound.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'_',      (char const   )'s', 
        (char const   )'o',      (char const   )'u',      (char const   )'n',      (char const   )'d', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'6', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )' ', 
        (char const   )'2',      (char const   )'2',      (char const   )':',      (char const   )'4', 
        (char const   )'5',      (char const   )':',      (char const   )'1',      (char const   )'2', 
        (char const   )' ',      (char const   )'b',      (char const   )'1',      (char const   )' ', 
        (char const   )'E',      (char const   )'x',      (char const   )'p',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 48 "s_sound.c"
char const   snd_prefixen[12]  = 
#line 48
  {      (char const   )'P',      (char const   )'P',      (char const   )'A',      (char const   )'S', 
        (char const   )'S',      (char const   )'S',      (char const   )'M',      (char const   )'M', 
        (char const   )'M',      (char const   )'S',      (char const   )'S',      (char const   )'S'};
#line 108 "s_sound.c"
static channel_t *channels___0  ;
#line 113 "s_sound.c"
int snd_SfxVolume  =    15;
#line 116 "s_sound.c"
int snd_MusicVolume  =    15;
#line 121 "s_sound.c"
static boolean mus_paused  ;
#line 124 "s_sound.c"
static musicinfo_t *mus_playing  =    (musicinfo_t *)0;
#line 129 "s_sound.c"
int numChannels  ;
#line 131 "s_sound.c"
static int nextcleanup  ;
#line 138
int S_getChannel(void *origin , sfxinfo_t *sfxinfo ) ;
#line 144
int S_AdjustSoundParams(mobj_t *listener , mobj_t *source , int *vol , int *sep ,
                        int *pitch ) ;
#line 152
void S_StopChannel(int cnum ) ;
#line 161 "s_sound.c"
void S_Init(int sfxVolume , int musicVolume ) 
{ 
  int i ;
  void *tmp ;
  int tmp___0 ;

  {
#line 167
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"S_Init: default sfx volume %d\n",
          sfxVolume);
#line 170
  I_SetChannels();
#line 172
  S_SetSfxVolume(sfxVolume);
#line 174
  S_SetMusicVolume(musicVolume);
#line 179
  tmp = Z_Malloc((int )((unsigned long )numChannels * sizeof(channel_t )), 1, (void *)0);
#line 179
  channels___0 = (channel_t *)tmp;
#line 183
  i = 0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (i < numChannels)) {
#line 183
      goto while_break;
    }
#line 184
    (channels___0 + i)->sfxinfo = (sfxinfo_t *)0;
#line 183
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  mus_paused = (boolean )0;
#line 190
  i = 1;
  {
#line 190
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 190
    if (! (i < 109)) {
#line 190
      goto while_break___0;
    }
#line 191
    tmp___0 = -1;
#line 191
    S_sfx[i].usefulness = tmp___0;
#line 191
    S_sfx[i].lumpnum = tmp___0;
#line 190
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 202 "s_sound.c"
void S_Start(void) 
{ 
  int cnum ;
  int mnum ;
  int spmus[9] ;

  {
#line 209
  cnum = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (cnum < numChannels)) {
#line 209
      goto while_break;
    }
#line 210
    if ((channels___0 + cnum)->sfxinfo) {
#line 211
      S_StopChannel(cnum);
    }
#line 209
    cnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  mus_paused = (boolean )0;
#line 216
  if ((unsigned int )gamemode == 2U) {
#line 217
    mnum = (33 + gamemap) - 1;
  } else {
#line 220
    spmus[0] = 22;
#line 220
    spmus[1] = 20;
#line 220
    spmus[2] = 21;
#line 220
    spmus[3] = 5;
#line 220
    spmus[4] = 16;
#line 220
    spmus[5] = 13;
#line 220
    spmus[6] = 15;
#line 220
    spmus[7] = 14;
#line 220
    spmus[8] = 9;
#line 235
    if (gameepisode < 4) {
#line 236
      mnum = ((1 + (gameepisode - 1) * 9) + gamemap) - 1;
    } else {
#line 238
      mnum = spmus[gamemap - 1];
    }
  }
#line 245
  S_ChangeMusic(mnum, 1);
#line 247
  nextcleanup = 15;
#line 248
  return;
}
}
#line 254 "s_sound.c"
void S_StartSoundAtVolume(void *origin_p , int sfx_id , int volume ) 
{ 
  int rc ;
  int sep ;
  int pitch ;
  int priority___0 ;
  sfxinfo_t *sfx ;
  int cnum ;
  mobj_t *origin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 268
  origin = (mobj_t *)origin_p;
#line 277
  if (sfx_id < 1) {
#line 277
    goto _L;
  } else
#line 277
  if (sfx_id > 109) {
    _L: /* CIL Label */ 
#line 278
    I_Error("Bad sfx #: %d", sfx_id);
  }
#line 280
  sfx = & S_sfx[sfx_id];
#line 283
  if (sfx->link) {
#line 285
    pitch = sfx->pitch;
#line 286
    priority___0 = sfx->priority;
#line 287
    volume += sfx->volume;
#line 289
    if (volume < 1) {
#line 290
      return;
    }
#line 292
    if (volume > snd_SfxVolume) {
#line 293
      volume = snd_SfxVolume;
    }
  } else {
#line 297
    pitch = 128;
#line 298
    priority___0 = 64;
  }
#line 304
  if (origin) {
#line 304
    if ((unsigned long )origin != (unsigned long )players[consoleplayer].mo) {
#line 306
      rc = S_AdjustSoundParams(players[consoleplayer].mo, origin, & volume, & sep,
                               & pitch);
#line 312
      if (origin->x == (players[consoleplayer].mo)->x) {
#line 312
        if (origin->y == (players[consoleplayer].mo)->y) {
#line 315
          sep = 128;
        } else {
#line 312
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
#line 318
      if (! rc) {
#line 319
        return;
      }
    } else {
#line 304
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 323
    sep = 128;
  }
#line 327
  if (sfx_id >= 10) {
#line 327
    if (sfx_id <= 13) {
#line 330
      tmp = M_Random();
#line 330
      pitch += 8 - (tmp & 15);
#line 332
      if (pitch < 0) {
#line 333
        pitch = 0;
      } else
#line 334
      if (pitch > 255) {
#line 335
        pitch = 255;
      }
    } else {
#line 327
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 337
  if (sfx_id != 32) {
#line 337
    if (sfx_id != 87) {
#line 340
      tmp___0 = M_Random();
#line 340
      pitch += 16 - (tmp___0 & 31);
#line 342
      if (pitch < 0) {
#line 343
        pitch = 0;
      } else
#line 344
      if (pitch > 255) {
#line 345
        pitch = 255;
      }
    } else {
#line 337
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ ;
  }
#line 349
  S_StopSound((void *)origin);
#line 352
  cnum = S_getChannel((void *)origin, sfx);
#line 354
  if (cnum < 0) {
#line 355
    return;
  }
#line 364
  if (sfx->lumpnum < 0) {
#line 365
    sfx->lumpnum = I_GetSfxLumpNum(sfx);
  }
#line 369
  if (! sfx->data) {
#line 371
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"S_StartSoundAtVolume: 16bit and not pre-cached - wtf?\n");
  }
#line 384
  tmp___1 = sfx->usefulness;
#line 384
  (sfx->usefulness) ++;
#line 384
  if (tmp___1 < 0) {
#line 385
    sfx->usefulness = 1;
  }
#line 389
  (channels___0 + cnum)->handle = I_StartSound(sfx_id, volume, sep, pitch, priority___0);
#line 395
  return;
}
}
#line 397 "s_sound.c"
void S_StartSound(void *origin , int sfx_id ) 
{ 


  {
#line 407
  S_StartSoundAtVolume(origin, sfx_id, snd_SfxVolume);
#line 466
  return;
}
}
#line 471 "s_sound.c"
void S_StopSound(void *origin ) 
{ 
  int cnum ;

  {
#line 476
  cnum = 0;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (cnum < numChannels)) {
#line 476
      goto while_break;
    }
#line 478
    if ((channels___0 + cnum)->sfxinfo) {
#line 478
      if ((unsigned long )(channels___0 + cnum)->origin == (unsigned long )origin) {
#line 480
        S_StopChannel(cnum);
#line 481
        goto while_break;
      } else {
#line 478
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 476
    cnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  return;
}
}
#line 497 "s_sound.c"
void S_PauseSound(void) 
{ 


  {
#line 499
  if (mus_playing) {
#line 499
    if (! mus_paused) {
#line 501
      I_PauseSong(mus_playing->handle);
#line 502
      mus_paused = (boolean )1;
    } else {
#line 499
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 504
  return;
}
}
#line 506 "s_sound.c"
void S_ResumeSound(void) 
{ 


  {
#line 508
  if (mus_playing) {
#line 508
    if (mus_paused) {
#line 510
      I_ResumeSong(mus_playing->handle);
#line 511
      mus_paused = (boolean )0;
    } else {
#line 508
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 519 "s_sound.c"
void S_UpdateSounds(void *listener_p ) 
{ 
  int audible ;
  int cnum ;
  int volume ;
  int sep ;
  int pitch ;
  sfxinfo_t *sfx ;
  channel_t *c ;
  mobj_t *listener ;
  int tmp ;

  {
#line 529
  listener = (mobj_t *)listener_p;
#line 553
  cnum = 0;
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    if (! (cnum < numChannels)) {
#line 553
      goto while_break;
    }
#line 555
    c = channels___0 + cnum;
#line 556
    sfx = c->sfxinfo;
#line 558
    if (c->sfxinfo) {
#line 560
      tmp = I_SoundIsPlaying(c->handle);
#line 560
      if (tmp) {
#line 563
        volume = snd_SfxVolume;
#line 564
        pitch = 128;
#line 565
        sep = 128;
#line 567
        if (sfx->link) {
#line 569
          pitch = sfx->pitch;
#line 570
          volume += sfx->volume;
#line 571
          if (volume < 1) {
#line 573
            S_StopChannel(cnum);
#line 574
            goto __Cont;
          } else
#line 576
          if (volume > snd_SfxVolume) {
#line 578
            volume = snd_SfxVolume;
          }
        }
#line 584
        if (c->origin) {
#line 584
          if ((unsigned long )listener_p != (unsigned long )c->origin) {
#line 586
            audible = S_AdjustSoundParams(listener, (mobj_t *)c->origin, & volume,
                                          & sep, & pitch);
#line 592
            if (! audible) {
#line 594
              S_StopChannel(cnum);
            } else {
#line 597
              I_UpdateSoundParams(c->handle, volume, sep, pitch);
            }
          } else {
#line 584
            goto _L;
          }
        } else {
          _L: /* CIL Label */ ;
        }
      } else {
#line 604
        S_StopChannel(cnum);
      }
    }
    __Cont: /* CIL Label */ 
#line 553
    cnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 613
  return;
}
}
#line 616 "s_sound.c"
void S_SetMusicVolume(int volume ) 
{ 


  {
#line 618
  if (volume < 0) {
#line 618
    goto _L;
  } else
#line 618
  if (volume > 127) {
    _L: /* CIL Label */ 
#line 620
    I_Error("Attempt to set music volume at %d", volume);
  }
#line 624
  I_SetMusicVolume(127);
#line 625
  I_SetMusicVolume(volume);
#line 626
  snd_MusicVolume = volume;
#line 627
  return;
}
}
#line 631 "s_sound.c"
void S_SetSfxVolume(int volume ) 
{ 


  {
#line 634
  if (volume < 0) {
#line 634
    goto _L;
  } else
#line 634
  if (volume > 127) {
    _L: /* CIL Label */ 
#line 635
    I_Error("Attempt to set sfx volume at %d", volume);
  }
#line 637
  snd_SfxVolume = volume;
#line 639
  return;
}
}
#line 644 "s_sound.c"
void S_StartMusic(int m_id ) 
{ 


  {
#line 646
  S_ChangeMusic(m_id, 0);
#line 647
  return;
}
}
#line 649 "s_sound.c"
void S_ChangeMusic(int musicnum , int looping___0 ) 
{ 
  musicinfo_t *music ;
  char namebuf[9] ;
  void *tmp ;

  {
#line 657
  if (musicnum <= 0) {
#line 657
    goto _L;
  } else
#line 657
  if (musicnum >= 68) {
    _L: /* CIL Label */ 
#line 660
    I_Error("Bad music number %d", musicnum);
  } else {
#line 663
    music = & S_music[musicnum];
  }
#line 665
  if ((unsigned long )mus_playing == (unsigned long )music) {
#line 666
    return;
  }
#line 669
  S_StopMusic();
#line 672
  if (! music->lumpnum) {
#line 674
    sprintf((char * __restrict  )(namebuf), (char const   * __restrict  )"d_%s", music->name);
#line 675
    music->lumpnum = W_GetNumForName(namebuf);
  }
#line 679
  tmp = W_CacheLumpNum(music->lumpnum, 3);
#line 679
  music->data = tmp;
#line 680
  music->handle = I_RegisterSong(music->data);
#line 683
  I_PlaySong(music->handle, looping___0);
#line 685
  mus_playing = music;
#line 686
  return;
}
}
#line 689 "s_sound.c"
void S_StopMusic(void) 
{ 


  {
#line 691
  if (mus_playing) {
#line 693
    if (mus_paused) {
#line 694
      I_ResumeSong(mus_playing->handle);
    }
#line 696
    I_StopSong(mus_playing->handle);
#line 697
    I_UnRegisterSong(mus_playing->handle);
#line 698
    if (((memblock_t *)((byte *)mus_playing->data - sizeof(memblock_t )))->id != 0x1d4a11) {
#line 698
      I_Error("Z_CT at s_sound.c:%i", 698);
    }
#line 698
    Z_ChangeTag2(mus_playing->data, 101);
#line 700
    mus_playing->data = (void *)0;
#line 701
    mus_playing = (musicinfo_t *)0;
  }
#line 703
  return;
}
}
#line 708 "s_sound.c"
void S_StopChannel(int cnum ) 
{ 
  int i ;
  channel_t *c ;
  int tmp ;

  {
#line 712
  c = channels___0 + cnum;
#line 714
  if (c->sfxinfo) {
#line 717
    tmp = I_SoundIsPlaying(c->handle);
#line 717
    if (tmp) {
#line 723
      I_StopSound(c->handle);
    }
#line 728
    i = 0;
    {
#line 728
    while (1) {
      while_continue: /* CIL Label */ ;
#line 728
      if (! (i < numChannels)) {
#line 728
        goto while_break;
      }
#line 730
      if (cnum != i) {
#line 730
        if ((unsigned long )c->sfxinfo == (unsigned long )(channels___0 + i)->sfxinfo) {
#line 733
          goto while_break;
        } else {
#line 730
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
#line 728
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 738
    ((c->sfxinfo)->usefulness) --;
#line 740
    c->sfxinfo = (sfxinfo_t *)0;
  }
#line 742
  return;
}
}
#line 752 "s_sound.c"
int S_AdjustSoundParams(mobj_t *listener , mobj_t *source , int *vol , int *sep ,
                        int *pitch ) 
{ 
  fixed_t approx_dist ;
  fixed_t adx ;
  fixed_t ady ;
  angle_t angle ;
  fixed_t tmp ;
  fixed_t tmp___0 ;

  {
#line 767
  adx = abs(listener->x - source->x);
#line 768
  ady = abs(listener->y - source->y);
#line 771
  if (adx < ady) {
#line 771
    tmp = adx;
  } else {
#line 771
    tmp = ady;
  }
#line 771
  approx_dist = (adx + ady) - (tmp >> 1);
#line 773
  if (gamemap != 8) {
#line 773
    if (approx_dist > 78643200) {
#line 776
      return (0);
    } else {
#line 773
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 780
  angle = R_PointToAngle2(listener->x, listener->y, source->x, source->y);
#line 785
  if (angle > listener->angle) {
#line 786
    angle -= listener->angle;
  } else {
#line 788
    angle += 0xffffffff - listener->angle;
  }
#line 790
  angle >>= 19;
#line 793
  tmp___0 = FixedMul(6291456, finesine[angle]);
#line 793
  *sep = 128 - (tmp___0 >> 16);
#line 796
  if (approx_dist < 10485760) {
#line 798
    *vol = snd_SfxVolume;
  } else
#line 800
  if (gamemap == 8) {
#line 802
    if (approx_dist > 78643200) {
#line 803
      approx_dist = 78643200;
    }
#line 805
    *vol = 15 + ((snd_SfxVolume - 15) * ((78643200 - approx_dist) >> 16)) / (68157440 >> 16);
  } else {
#line 812
    *vol = (snd_SfxVolume * ((78643200 - approx_dist) >> 16)) / (68157440 >> 16);
  }
#line 817
  return (*vol > 0);
}
}
#line 827 "s_sound.c"
int S_getChannel(void *origin , sfxinfo_t *sfxinfo ) 
{ 
  int cnum ;
  channel_t *c ;

  {
#line 838
  cnum = 0;
  {
#line 838
  while (1) {
    while_continue: /* CIL Label */ ;
#line 838
    if (! (cnum < numChannels)) {
#line 838
      goto while_break;
    }
#line 840
    if (! (channels___0 + cnum)->sfxinfo) {
#line 841
      goto while_break;
    } else
#line 842
    if (origin) {
#line 842
      if ((unsigned long )(channels___0 + cnum)->origin == (unsigned long )origin) {
#line 844
        S_StopChannel(cnum);
#line 845
        goto while_break;
      } else {
#line 842
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 838
    cnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  if (cnum == numChannels) {
#line 853
    cnum = 0;
    {
#line 853
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 853
      if (! (cnum < numChannels)) {
#line 853
        goto while_break___0;
      }
#line 854
      if (((channels___0 + cnum)->sfxinfo)->priority >= sfxinfo->priority) {
#line 854
        goto while_break___0;
      }
#line 853
      cnum ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 856
    if (cnum == numChannels) {
#line 859
      return (-1);
    } else {
#line 864
      S_StopChannel(cnum);
    }
  }
#line 868
  c = channels___0 + cnum;
#line 871
  c->sfxinfo = sfxinfo;
#line 872
  c->origin = origin;
#line 874
  return (cnum);
}
}
#line 24 "z_zone.c"
static char const   rcsid___57[49]  = 
#line 24 "z_zone.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'z',      (char const   )'_',      (char const   )'z', 
        (char const   )'o',      (char const   )'n',      (char const   )'e',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'4',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'1', 
        (char const   )'6',      (char const   )':',      (char const   )'4',      (char const   )'7', 
        (char const   )':',      (char const   )'5',      (char const   )'8',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 60 "z_zone.c"
memzone_t *mainzone  ;
#line 67 "z_zone.c"
void Z_ClearZone(memzone_t *zone ) 
{ 
  memblock_t *block ;
  struct memblock_s *tmp ;
  struct memblock_s *tmp___0 ;

  {
#line 72
  block = (memblock_t *)((byte *)zone + sizeof(memzone_t ));
#line 72
  tmp = block;
#line 72
  zone->blocklist.prev = tmp;
#line 72
  zone->blocklist.next = tmp;
#line 76
  zone->blocklist.user = (void **)((void *)zone);
#line 77
  zone->blocklist.tag = 1;
#line 78
  zone->rover = block;
#line 80
  tmp___0 = & zone->blocklist;
#line 80
  block->next = tmp___0;
#line 80
  block->prev = tmp___0;
#line 83
  block->user = (void **)((void *)0);
#line 85
  block->size = (int )((unsigned long )zone->size - sizeof(memzone_t ));
#line 86
  return;
}
}
#line 93 "z_zone.c"
void Z_Init(void) 
{ 
  memblock_t *block ;
  int size ;
  byte *tmp ;
  struct memblock_s *tmp___0 ;
  struct memblock_s *tmp___1 ;

  {
#line 98
  tmp = I_ZoneBase(& size);
#line 98
  mainzone = (memzone_t *)tmp;
#line 99
  mainzone->size = size;
#line 102
  block = (memblock_t *)((byte *)mainzone + sizeof(memzone_t ));
#line 102
  tmp___0 = block;
#line 102
  mainzone->blocklist.prev = tmp___0;
#line 102
  mainzone->blocklist.next = tmp___0;
#line 106
  mainzone->blocklist.user = (void **)((void *)mainzone);
#line 107
  mainzone->blocklist.tag = 1;
#line 108
  mainzone->rover = block;
#line 110
  tmp___1 = & mainzone->blocklist;
#line 110
  block->next = tmp___1;
#line 110
  block->prev = tmp___1;
#line 113
  block->user = (void **)((void *)0);
#line 115
  block->size = (int )((unsigned long )mainzone->size - sizeof(memzone_t ));
#line 116
  return;
}
}
#line 122 "z_zone.c"
void Z_Free(void *ptr ) 
{ 
  memblock_t *block ;
  memblock_t *other ;

  {
#line 127
  block = (memblock_t *)((byte *)ptr - sizeof(memblock_t ));
#line 129
  if (block->id != 0x1d4a11) {
#line 130
    I_Error("Z_Free: freed a pointer without ZONEID");
  }
#line 132
  if ((unsigned long )block->user > (unsigned long )((void **)0x100)) {
#line 138
    *(block->user) = (void *)0;
  }
#line 142
  block->user = (void **)((void *)0);
#line 143
  block->tag = 0;
#line 144
  block->id = 0;
#line 146
  other = block->prev;
#line 148
  if (! other->user) {
#line 151
    other->size += block->size;
#line 152
    other->next = block->next;
#line 153
    (other->next)->prev = other;
#line 155
    if ((unsigned long )block == (unsigned long )mainzone->rover) {
#line 156
      mainzone->rover = other;
    }
#line 158
    block = other;
  }
#line 161
  other = block->next;
#line 162
  if (! other->user) {
#line 165
    block->size += other->size;
#line 166
    block->next = other->next;
#line 167
    (block->next)->prev = block;
#line 169
    if ((unsigned long )other == (unsigned long )mainzone->rover) {
#line 170
      mainzone->rover = block;
    }
  }
#line 172
  return;
}
}
#line 183 "z_zone.c"
void *Z_Malloc(int size , int tag , void *user ) 
{ 
  int extra ;
  memblock_t *start ;
  memblock_t *rover ;
  memblock_t *newblock ;
  memblock_t *base ;

  {
#line 195
  size = (size + 3) & -4;
#line 203
  size = (int )((unsigned long )size + sizeof(memblock_t ));
#line 207
  base = mainzone->rover;
#line 209
  if (! (base->prev)->user) {
#line 210
    base = base->prev;
  }
#line 212
  rover = base;
#line 213
  start = base->prev;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if ((unsigned long )rover == (unsigned long )start) {
#line 220
      I_Error("Z_Malloc: failed on allocation of %i bytes", size);
    }
#line 223
    if (rover->user) {
#line 225
      if (rover->tag < 100) {
#line 229
        rover = rover->next;
#line 229
        base = rover;
      } else {
#line 236
        base = base->prev;
#line 237
        Z_Free((void *)((byte *)rover + sizeof(memblock_t )));
#line 238
        base = base->next;
#line 239
        rover = base->next;
      }
    } else {
#line 243
      rover = rover->next;
    }
#line 215
    if (base->user) {
#line 215
      goto _L;
    } else
#line 215
    if (base->size < size) {
      _L: /* CIL Label */ ;
    } else {
#line 215
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  extra = base->size - size;
#line 250
  if (extra > 64) {
#line 253
    newblock = (memblock_t *)((byte *)base + size);
#line 254
    newblock->size = extra;
#line 257
    newblock->user = (void **)((void *)0);
#line 258
    newblock->tag = 0;
#line 259
    newblock->prev = base;
#line 260
    newblock->next = base->next;
#line 261
    (newblock->next)->prev = newblock;
#line 263
    base->next = newblock;
#line 264
    base->size = size;
  }
#line 267
  if (user) {
#line 270
    base->user = (void **)user;
#line 271
    *((void **)user) = (void *)((byte *)base + sizeof(memblock_t ));
  } else {
#line 275
    if (tag >= 100) {
#line 276
      I_Error("Z_Malloc: an owner is required for purgable blocks");
    }
#line 279
    base->user = (void **)((void *)2);
  }
#line 281
  base->tag = tag;
#line 284
  mainzone->rover = base->next;
#line 286
  base->id = 0x1d4a11;
#line 288
  return ((void *)((byte *)base + sizeof(memblock_t )));
}
}
#line 296 "z_zone.c"
void Z_FreeTags(int lowtag , int hightag ) 
{ 
  memblock_t *block ;
  memblock_t *next ;

  {
#line 304
  block = mainzone->blocklist.next;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! ((unsigned long )block != (unsigned long )(& mainzone->blocklist))) {
#line 304
      goto while_break;
    }
#line 309
    next = block->next;
#line 312
    if (! block->user) {
#line 313
      goto __Cont;
    }
#line 315
    if (block->tag >= lowtag) {
#line 315
      if (block->tag <= hightag) {
#line 316
        Z_Free((void *)((byte *)block + sizeof(memblock_t )));
      } else {
#line 315
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 304
    block = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return;
}
}
#line 326 "z_zone.c"
void Z_DumpHeap(int lowtag , int hightag ) 
{ 
  memblock_t *block ;

  {
#line 333
  printf((char const   * __restrict  )"zone size: %i  location: %p\n", mainzone->size,
         mainzone);
#line 336
  printf((char const   * __restrict  )"tag range: %i to %i\n", lowtag, hightag);
#line 339
  block = mainzone->blocklist.next;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (block->tag >= lowtag) {
#line 341
      if (block->tag <= hightag) {
#line 342
        printf((char const   * __restrict  )"block:%p    size:%7i    user:%p    tag:%3i\n",
               block, block->size, block->user, block->tag);
      } else {
#line 341
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 345
    if ((unsigned long )block->next == (unsigned long )(& mainzone->blocklist)) {
#line 348
      goto while_break;
    }
#line 351
    if ((unsigned long )((byte *)block + block->size) != (unsigned long )((byte *)block->next)) {
#line 352
      printf((char const   * __restrict  )"ERROR: block size does not touch the next block\n");
    }
#line 354
    if ((unsigned long )(block->next)->prev != (unsigned long )block) {
#line 355
      printf((char const   * __restrict  )"ERROR: next block doesn\'t have proper back link\n");
    }
#line 357
    if (! block->user) {
#line 357
      if (! (block->next)->user) {
#line 358
        printf((char const   * __restrict  )"ERROR: two consecutive free blocks\n");
      } else {
#line 357
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
#line 339
    block = block->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  return;
}
}
#line 366 "z_zone.c"
void Z_FileDumpHeap(FILE *f ) 
{ 
  memblock_t *block ;

  {
#line 370
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"zone size: %i  location: %p\n",
          mainzone->size, mainzone);
#line 372
  block = mainzone->blocklist.next;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )"block:%p    size:%7i    user:%p    tag:%3i\n",
            block, block->size, block->user, block->tag);
#line 377
    if ((unsigned long )block->next == (unsigned long )(& mainzone->blocklist)) {
#line 380
      goto while_break;
    }
#line 383
    if ((unsigned long )((byte *)block + block->size) != (unsigned long )((byte *)block->next)) {
#line 384
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"ERROR: block size does not touch the next block\n");
    }
#line 386
    if ((unsigned long )(block->next)->prev != (unsigned long )block) {
#line 387
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"ERROR: next block doesn\'t have proper back link\n");
    }
#line 389
    if (! block->user) {
#line 389
      if (! (block->next)->user) {
#line 390
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"ERROR: two consecutive free blocks\n");
      } else {
#line 389
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 372
    block = block->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  return;
}
}
#line 399 "z_zone.c"
void Z_CheckHeap(void) 
{ 
  memblock_t *block ;

  {
#line 403
  block = mainzone->blocklist.next;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if ((unsigned long )block->next == (unsigned long )(& mainzone->blocklist)) {
#line 408
      goto while_break;
    }
#line 411
    if ((unsigned long )((byte *)block + block->size) != (unsigned long )((byte *)block->next)) {
#line 412
      I_Error("Z_CheckHeap: block size does not touch the next block\n");
    }
#line 414
    if ((unsigned long )(block->next)->prev != (unsigned long )block) {
#line 415
      I_Error("Z_CheckHeap: next block doesn\'t have proper back link\n");
    }
#line 417
    if (! block->user) {
#line 417
      if (! (block->next)->user) {
#line 418
        I_Error("Z_CheckHeap: two consecutive free blocks\n");
      } else {
#line 417
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 403
    block = block->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 428 "z_zone.c"
void Z_ChangeTag2(void *ptr , int tag ) 
{ 
  memblock_t *block ;

  {
#line 435
  block = (memblock_t *)((byte *)ptr - sizeof(memblock_t ));
#line 437
  if (block->id != 0x1d4a11) {
#line 438
    I_Error("Z_ChangeTag: freed a pointer without ZONEID");
  }
#line 440
  if (tag >= 100) {
#line 440
    if ((unsigned int )block->user < 256U) {
#line 441
      I_Error("Z_ChangeTag: an owner is required for purgable blocks");
    } else {
#line 440
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 443
  block->tag = tag;
#line 444
  return;
}
}
#line 451 "z_zone.c"
int Z_FreeMemory(void) 
{ 
  memblock_t *block ;
  int free___0 ;

  {
#line 456
  free___0 = 0;
#line 458
  block = mainzone->blocklist.next;
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (! ((unsigned long )block != (unsigned long )(& mainzone->blocklist))) {
#line 458
      goto while_break;
    }
#line 462
    if (! block->user) {
#line 462
      goto _L;
    } else
#line 462
    if (block->tag >= 100) {
      _L: /* CIL Label */ 
#line 463
      free___0 += block->size;
    }
#line 458
    block = block->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  return (free___0);
}
}
#line 26 "info.c"
static char const   rcsid___58[47]  = 
#line 26 "info.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'f', 
        (char const   )'o',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'3',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'7',      (char const   )'/',      (char const   )'0', 
        (char const   )'1',      (char const   )'/',      (char const   )'2',      (char const   )'6', 
        (char const   )' ',      (char const   )'0',      (char const   )'7',      (char const   )':', 
        (char const   )'4',      (char const   )'5',      (char const   )':',      (char const   )'0', 
        (char const   )'0',      (char const   )' ',      (char const   )'b',      (char const   )'1', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'p', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 40 "info.c"
char *sprnames[138]  = 
#line 40
  {      "TROO",      "SHTG",      "PUNG",      "PISG", 
        "PISF",      "SHTF",      "SHT2",      "CHGG", 
        "CHGF",      "MISG",      "MISF",      "SAWG", 
        "PLSG",      "PLSF",      "BFGG",      "BFGF", 
        "BLUD",      "PUFF",      "BAL1",      "BAL2", 
        "PLSS",      "PLSE",      "MISL",      "BFS1", 
        "BFE1",      "BFE2",      "TFOG",      "IFOG", 
        "PLAY",      "POSS",      "SPOS",      "VILE", 
        "FIRE",      "FATB",      "FBXP",      "SKEL", 
        "MANF",      "FATT",      "CPOS",      "SARG", 
        "HEAD",      "BAL7",      "BOSS",      "BOS2", 
        "SKUL",      "SPID",      "BSPI",      "APLS", 
        "APBX",      "CYBR",      "PAIN",      "SSWV", 
        "KEEN",      "BBRN",      "BOSF",      "ARM1", 
        "ARM2",      "BAR1",      "BEXP",      "FCAN", 
        "BON1",      "BON2",      "BKEY",      "RKEY", 
        "YKEY",      "BSKU",      "RSKU",      "YSKU", 
        "STIM",      "MEDI",      "SOUL",      "PINV", 
        "PSTR",      "PINS",      "MEGA",      "SUIT", 
        "PMAP",      "PVIS",      "CLIP",      "AMMO", 
        "ROCK",      "BROK",      "CELL",      "CELP", 
        "SHEL",      "SBOX",      "BPAK",      "BFUG", 
        "MGUN",      "CSAW",      "LAUN",      "PLAS", 
        "SHOT",      "SGN2",      "COLU",      "SMT2", 
        "GOR1",      "POL2",      "POL5",      "POL4", 
        "POL3",      "POL1",      "POL6",      "GOR2", 
        "GOR3",      "GOR4",      "GOR5",      "SMIT", 
        "COL1",      "COL2",      "COL3",      "COL4", 
        "CAND",      "CBRA",      "COL6",      "TRE1", 
        "TRE2",      "ELEC",      "CEYE",      "FSKU", 
        "COL5",      "TBLU",      "TGRN",      "TRED", 
        "SMBT",      "SMGT",      "SMRT",      "HDB1", 
        "HDB2",      "HDB3",      "HDB4",      "HDB5", 
        "HDB6",      "POB1",      "POB2",      "BRS1", 
        "TLMP",      "TLP2"};
#line 135 "info.c"
state_t states[967]  = 
#line 135
  {      {(spritenum_t )0, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )1, 4L, 0L, {(void (*)(void * ))(& A_Light0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )2, 0L, 1L, {(void (*)(void * ))(& A_WeaponReady)}, (statenum_t )2,
      0L, 0L}, 
        {(spritenum_t )2, 0L, 1L, {(void (*)(void * ))(& A_Lower)}, (statenum_t )3, 0L,
      0L}, 
        {(spritenum_t )2, 0L, 1L, {(void (*)(void * ))(& A_Raise)}, (statenum_t )4, 0L,
      0L}, 
        {(spritenum_t )2, 1L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )6, 0L,
      0L}, 
        {(spritenum_t )2, 2L, 4L, {(void (*)(void * ))(& A_Punch)}, (statenum_t )7, 0L,
      0L}, 
        {(spritenum_t )2, 3L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )8, 0L,
      0L}, 
        {(spritenum_t )2, 2L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )9, 0L,
      0L}, 
        {(spritenum_t )2, 1L, 5L, {(void (*)(void * ))(& A_ReFire)}, (statenum_t )2,
      0L, 0L}, 
        {(spritenum_t )3, 0L, 1L, {(void (*)(void * ))(& A_WeaponReady)}, (statenum_t )10,
      0L, 0L}, 
        {(spritenum_t )3, 0L, 1L, {(void (*)(void * ))(& A_Lower)}, (statenum_t )11,
      0L, 0L}, 
        {(spritenum_t )3, 0L, 1L, {(void (*)(void * ))(& A_Raise)}, (statenum_t )12,
      0L, 0L}, 
        {(spritenum_t )3, 0L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )14,
      0L, 0L}, 
        {(spritenum_t )3, 1L, 6L, {(void (*)(void * ))(& A_FirePistol)}, (statenum_t )15,
      0L, 0L}, 
        {(spritenum_t )3, 2L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )16,
      0L, 0L}, 
        {(spritenum_t )3, 1L, 5L, {(void (*)(void * ))(& A_ReFire)}, (statenum_t )10,
      0L, 0L}, 
        {(spritenum_t )4, 32768L, 7L, {(void (*)(void * ))(& A_Light1)}, (statenum_t )1,
      0L, 0L}, 
        {(spritenum_t )1, 0L, 1L, {(void (*)(void * ))(& A_WeaponReady)}, (statenum_t )18,
      0L, 0L}, 
        {(spritenum_t )1, 0L, 1L, {(void (*)(void * ))(& A_Lower)}, (statenum_t )19,
      0L, 0L}, 
        {(spritenum_t )1, 0L, 1L, {(void (*)(void * ))(& A_Raise)}, (statenum_t )20,
      0L, 0L}, 
        {(spritenum_t )1, 0L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )22,
      0L, 0L}, 
        {(spritenum_t )1, 0L, 7L, {(void (*)(void * ))(& A_FireShotgun)}, (statenum_t )23,
      0L, 0L}, 
        {(spritenum_t )1, 1L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )24,
      0L, 0L}, 
        {(spritenum_t )1, 2L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )25,
      0L, 0L}, 
        {(spritenum_t )1, 3L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )26,
      0L, 0L}, 
        {(spritenum_t )1, 2L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )27,
      0L, 0L}, 
        {(spritenum_t )1, 1L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )28,
      0L, 0L}, 
        {(spritenum_t )1, 0L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )29,
      0L, 0L}, 
        {(spritenum_t )1, 0L, 7L, {(void (*)(void * ))(& A_ReFire)}, (statenum_t )18,
      0L, 0L}, 
        {(spritenum_t )5, 32768L, 4L, {(void (*)(void * ))(& A_Light1)}, (statenum_t )31,
      0L, 0L}, 
        {(spritenum_t )5, 32769L, 3L, {(void (*)(void * ))(& A_Light2)}, (statenum_t )1,
      0L, 0L}, 
        {(spritenum_t )6, 0L, 1L, {(void (*)(void * ))(& A_WeaponReady)}, (statenum_t )32,
      0L, 0L}, 
        {(spritenum_t )6, 0L, 1L, {(void (*)(void * ))(& A_Lower)}, (statenum_t )33,
      0L, 0L}, 
        {(spritenum_t )6, 0L, 1L, {(void (*)(void * ))(& A_Raise)}, (statenum_t )34,
      0L, 0L}, 
        {(spritenum_t )6, 0L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )36,
      0L, 0L}, 
        {(spritenum_t )6, 0L, 7L, {(void (*)(void * ))(& A_FireShotgun2)}, (statenum_t )37,
      0L, 0L}, 
        {(spritenum_t )6, 1L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )38,
      0L, 0L}, 
        {(spritenum_t )6, 2L, 7L, {(void (*)(void * ))(& A_CheckReload)}, (statenum_t )39,
      0L, 0L}, 
        {(spritenum_t )6, 3L, 7L, {(void (*)(void * ))(& A_OpenShotgun2)}, (statenum_t )40,
      0L, 0L}, 
        {(spritenum_t )6, 4L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )41,
      0L, 0L}, 
        {(spritenum_t )6, 5L, 7L, {(void (*)(void * ))(& A_LoadShotgun2)}, (statenum_t )42,
      0L, 0L}, 
        {(spritenum_t )6, 6L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )43,
      0L, 0L}, 
        {(spritenum_t )6, 7L, 6L, {(void (*)(void * ))(& A_CloseShotgun2)}, (statenum_t )44,
      0L, 0L}, 
        {(spritenum_t )6, 0L, 5L, {(void (*)(void * ))(& A_ReFire)}, (statenum_t )32,
      0L, 0L}, 
        {(spritenum_t )6, 1L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )46,
      0L, 0L}, 
        {(spritenum_t )6, 0L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )33,
      0L, 0L}, 
        {(spritenum_t )6, 32776L, 5L, {(void (*)(void * ))(& A_Light1)}, (statenum_t )48,
      0L, 0L}, 
        {(spritenum_t )6, 32777L, 4L, {(void (*)(void * ))(& A_Light2)}, (statenum_t )1,
      0L, 0L}, 
        {(spritenum_t )7, 0L, 1L, {(void (*)(void * ))(& A_WeaponReady)}, (statenum_t )49,
      0L, 0L}, 
        {(spritenum_t )7, 0L, 1L, {(void (*)(void * ))(& A_Lower)}, (statenum_t )50,
      0L, 0L}, 
        {(spritenum_t )7, 0L, 1L, {(void (*)(void * ))(& A_Raise)}, (statenum_t )51,
      0L, 0L}, 
        {(spritenum_t )7, 0L, 4L, {(void (*)(void * ))(& A_FireCGun)}, (statenum_t )53,
      0L, 0L}, 
        {(spritenum_t )7, 1L, 4L, {(void (*)(void * ))(& A_FireCGun)}, (statenum_t )54,
      0L, 0L}, 
        {(spritenum_t )7, 1L, 0L, {(void (*)(void * ))(& A_ReFire)}, (statenum_t )49,
      0L, 0L}, 
        {(spritenum_t )8, 32768L, 5L, {(void (*)(void * ))(& A_Light1)}, (statenum_t )1,
      0L, 0L}, 
        {(spritenum_t )8, 32769L, 5L, {(void (*)(void * ))(& A_Light2)}, (statenum_t )1,
      0L, 0L}, 
        {(spritenum_t )9, 0L, 1L, {(void (*)(void * ))(& A_WeaponReady)}, (statenum_t )57,
      0L, 0L}, 
        {(spritenum_t )9, 0L, 1L, {(void (*)(void * ))(& A_Lower)}, (statenum_t )58,
      0L, 0L}, 
        {(spritenum_t )9, 0L, 1L, {(void (*)(void * ))(& A_Raise)}, (statenum_t )59,
      0L, 0L}, 
        {(spritenum_t )9, 1L, 8L, {(void (*)(void * ))(& A_GunFlash)}, (statenum_t )61,
      0L, 0L}, 
        {(spritenum_t )9, 1L, 12L, {(void (*)(void * ))(& A_FireMissile)}, (statenum_t )62,
      0L, 0L}, 
        {(spritenum_t )9, 1L, 0L, {(void (*)(void * ))(& A_ReFire)}, (statenum_t )57,
      0L, 0L}, 
        {(spritenum_t )10, 32768L, 3L, {(void (*)(void * ))(& A_Light1)}, (statenum_t )64,
      0L, 0L}, 
        {(spritenum_t )10, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )65,
      0L, 0L}, 
        {(spritenum_t )10, 32770L, 4L, {(void (*)(void * ))(& A_Light2)}, (statenum_t )66,
      0L, 0L}, 
        {(spritenum_t )10, 32771L, 4L, {(void (*)(void * ))(& A_Light2)}, (statenum_t )1,
      0L, 0L}, 
        {(spritenum_t )11, 2L, 4L, {(void (*)(void * ))(& A_WeaponReady)}, (statenum_t )68,
      0L, 0L}, 
        {(spritenum_t )11, 3L, 4L, {(void (*)(void * ))(& A_WeaponReady)}, (statenum_t )67,
      0L, 0L}, 
        {(spritenum_t )11, 2L, 1L, {(void (*)(void * ))(& A_Lower)}, (statenum_t )69,
      0L, 0L}, 
        {(spritenum_t )11, 2L, 1L, {(void (*)(void * ))(& A_Raise)}, (statenum_t )70,
      0L, 0L}, 
        {(spritenum_t )11, 0L, 4L, {(void (*)(void * ))(& A_Saw)}, (statenum_t )72, 0L,
      0L}, 
        {(spritenum_t )11, 1L, 4L, {(void (*)(void * ))(& A_Saw)}, (statenum_t )73, 0L,
      0L}, 
        {(spritenum_t )11, 1L, 0L, {(void (*)(void * ))(& A_ReFire)}, (statenum_t )67,
      0L, 0L}, 
        {(spritenum_t )12, 0L, 1L, {(void (*)(void * ))(& A_WeaponReady)}, (statenum_t )74,
      0L, 0L}, 
        {(spritenum_t )12, 0L, 1L, {(void (*)(void * ))(& A_Lower)}, (statenum_t )75,
      0L, 0L}, 
        {(spritenum_t )12, 0L, 1L, {(void (*)(void * ))(& A_Raise)}, (statenum_t )76,
      0L, 0L}, 
        {(spritenum_t )12, 0L, 3L, {(void (*)(void * ))(& A_FirePlasma)}, (statenum_t )78,
      0L, 0L}, 
        {(spritenum_t )12, 1L, 20L, {(void (*)(void * ))(& A_ReFire)}, (statenum_t )74,
      0L, 0L}, 
        {(spritenum_t )13, 32768L, 4L, {(void (*)(void * ))(& A_Light1)}, (statenum_t )1,
      0L, 0L}, 
        {(spritenum_t )13, 32769L, 4L, {(void (*)(void * ))(& A_Light1)}, (statenum_t )1,
      0L, 0L}, 
        {(spritenum_t )14, 0L, 1L, {(void (*)(void * ))(& A_WeaponReady)}, (statenum_t )81,
      0L, 0L}, 
        {(spritenum_t )14, 0L, 1L, {(void (*)(void * ))(& A_Lower)}, (statenum_t )82,
      0L, 0L}, 
        {(spritenum_t )14, 0L, 1L, {(void (*)(void * ))(& A_Raise)}, (statenum_t )83,
      0L, 0L}, 
        {(spritenum_t )14, 0L, 20L, {(void (*)(void * ))(& A_BFGsound)}, (statenum_t )85,
      0L, 0L}, 
        {(spritenum_t )14, 1L, 10L, {(void (*)(void * ))(& A_GunFlash)}, (statenum_t )86,
      0L, 0L}, 
        {(spritenum_t )14, 1L, 10L, {(void (*)(void * ))(& A_FireBFG)}, (statenum_t )87,
      0L, 0L}, 
        {(spritenum_t )14, 1L, 20L, {(void (*)(void * ))(& A_ReFire)}, (statenum_t )81,
      0L, 0L}, 
        {(spritenum_t )15, 32768L, 11L, {(void (*)(void * ))(& A_Light1)}, (statenum_t )89,
      0L, 0L}, 
        {(spritenum_t )15, 32769L, 6L, {(void (*)(void * ))(& A_Light2)}, (statenum_t )1,
      0L, 0L}, 
        {(spritenum_t )16, 2L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )91,
      0L, 0L}, 
        {(spritenum_t )16, 1L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )92,
      0L, 0L}, 
        {(spritenum_t )16, 0L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )17, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )94,
      0L, 0L}, 
        {(spritenum_t )17, 1L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )95,
      0L, 0L}, 
        {(spritenum_t )17, 2L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )96,
      0L, 0L}, 
        {(spritenum_t )17, 3L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )18, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )98,
      0L, 0L}, 
        {(spritenum_t )18, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )97,
      0L, 0L}, 
        {(spritenum_t )18, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )100,
      0L, 0L}, 
        {(spritenum_t )18, 32771L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )101,
      0L, 0L}, 
        {(spritenum_t )18, 32772L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )19, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )103,
      0L, 0L}, 
        {(spritenum_t )19, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )102,
      0L, 0L}, 
        {(spritenum_t )19, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )105,
      0L, 0L}, 
        {(spritenum_t )19, 32771L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )106,
      0L, 0L}, 
        {(spritenum_t )19, 32772L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )20, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )108,
      0L, 0L}, 
        {(spritenum_t )20, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )107,
      0L, 0L}, 
        {(spritenum_t )21, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )110,
      0L, 0L}, 
        {(spritenum_t )21, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )111,
      0L, 0L}, 
        {(spritenum_t )21, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )112,
      0L, 0L}, 
        {(spritenum_t )21, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )113,
      0L, 0L}, 
        {(spritenum_t )21, 32772L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )22, 32768L, 1L, {(void (*)(void * ))((void *)0)}, (statenum_t )114,
      0L, 0L}, 
        {(spritenum_t )23, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )116,
      0L, 0L}, 
        {(spritenum_t )23, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )115,
      0L, 0L}, 
        {(spritenum_t )24, 32768L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )118,
      0L, 0L}, 
        {(spritenum_t )24, 32769L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )119,
      0L, 0L}, 
        {(spritenum_t )24, 32770L, 8L, {(void (*)(void * ))(& A_BFGSpray)}, (statenum_t )120,
      0L, 0L}, 
        {(spritenum_t )24, 32771L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )121,
      0L, 0L}, 
        {(spritenum_t )24, 32772L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )122,
      0L, 0L}, 
        {(spritenum_t )24, 32773L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )25, 32768L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )124,
      0L, 0L}, 
        {(spritenum_t )25, 32769L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )125,
      0L, 0L}, 
        {(spritenum_t )25, 32770L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )126,
      0L, 0L}, 
        {(spritenum_t )25, 32771L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )22, 32769L, 8L, {(void (*)(void * ))(& A_Explode)}, (statenum_t )128,
      0L, 0L}, 
        {(spritenum_t )22, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )129,
      0L, 0L}, 
        {(spritenum_t )22, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )26, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )131,
      0L, 0L}, 
        {(spritenum_t )26, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )132,
      0L, 0L}, 
        {(spritenum_t )26, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )133,
      0L, 0L}, 
        {(spritenum_t )26, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )134,
      0L, 0L}, 
        {(spritenum_t )26, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )135,
      0L, 0L}, 
        {(spritenum_t )26, 32771L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )136,
      0L, 0L}, 
        {(spritenum_t )26, 32772L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )137,
      0L, 0L}, 
        {(spritenum_t )26, 32773L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )138,
      0L, 0L}, 
        {(spritenum_t )26, 32774L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )139,
      0L, 0L}, 
        {(spritenum_t )26, 32775L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )140,
      0L, 0L}, 
        {(spritenum_t )26, 32776L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )141,
      0L, 0L}, 
        {(spritenum_t )26, 32777L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )27, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )143,
      0L, 0L}, 
        {(spritenum_t )27, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )144,
      0L, 0L}, 
        {(spritenum_t )27, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )145,
      0L, 0L}, 
        {(spritenum_t )27, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )146,
      0L, 0L}, 
        {(spritenum_t )27, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )147,
      0L, 0L}, 
        {(spritenum_t )27, 32771L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )148,
      0L, 0L}, 
        {(spritenum_t )27, 32772L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )28, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )28, 0L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )151,
      0L, 0L}, 
        {(spritenum_t )28, 1L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )152,
      0L, 0L}, 
        {(spritenum_t )28, 2L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )153,
      0L, 0L}, 
        {(spritenum_t )28, 3L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )150,
      0L, 0L}, 
        {(spritenum_t )28, 4L, 12L, {(void (*)(void * ))((void *)0)}, (statenum_t )149,
      0L, 0L}, 
        {(spritenum_t )28, 32773L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )154,
      0L, 0L}, 
        {(spritenum_t )28, 6L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )157,
      0L, 0L}, 
        {(spritenum_t )28, 6L, 4L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )149,
      0L, 0L}, 
        {(spritenum_t )28, 7L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )159,
      0L, 0L}, 
        {(spritenum_t )28, 8L, 10L, {(void (*)(void * ))(& A_PlayerScream)}, (statenum_t )160,
      0L, 0L}, 
        {(spritenum_t )28, 9L, 10L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )161,
      0L, 0L}, 
        {(spritenum_t )28, 10L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )162,
      0L, 0L}, 
        {(spritenum_t )28, 11L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )163,
      0L, 0L}, 
        {(spritenum_t )28, 12L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )164,
      0L, 0L}, 
        {(spritenum_t )28, 13L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )28, 14L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )166,
      0L, 0L}, 
        {(spritenum_t )28, 15L, 5L, {(void (*)(void * ))(& A_XScream)}, (statenum_t )167,
      0L, 0L}, 
        {(spritenum_t )28, 16L, 5L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )168,
      0L, 0L}, 
        {(spritenum_t )28, 17L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )169,
      0L, 0L}, 
        {(spritenum_t )28, 18L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )170,
      0L, 0L}, 
        {(spritenum_t )28, 19L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )171,
      0L, 0L}, 
        {(spritenum_t )28, 20L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )172,
      0L, 0L}, 
        {(spritenum_t )28, 21L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )173,
      0L, 0L}, 
        {(spritenum_t )28, 22L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )29, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )175,
      0L, 0L}, 
        {(spritenum_t )29, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )174,
      0L, 0L}, 
        {(spritenum_t )29, 0L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )177,
      0L, 0L}, 
        {(spritenum_t )29, 0L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )178,
      0L, 0L}, 
        {(spritenum_t )29, 1L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )179,
      0L, 0L}, 
        {(spritenum_t )29, 1L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )180,
      0L, 0L}, 
        {(spritenum_t )29, 2L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )181,
      0L, 0L}, 
        {(spritenum_t )29, 2L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )182,
      0L, 0L}, 
        {(spritenum_t )29, 3L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )183,
      0L, 0L}, 
        {(spritenum_t )29, 3L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )176,
      0L, 0L}, 
        {(spritenum_t )29, 4L, 10L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )185,
      0L, 0L}, 
        {(spritenum_t )29, 5L, 8L, {(void (*)(void * ))(& A_PosAttack)}, (statenum_t )186,
      0L, 0L}, 
        {(spritenum_t )29, 4L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )176,
      0L, 0L}, 
        {(spritenum_t )29, 6L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )188,
      0L, 0L}, 
        {(spritenum_t )29, 6L, 3L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )176,
      0L, 0L}, 
        {(spritenum_t )29, 7L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )190,
      0L, 0L}, 
        {(spritenum_t )29, 8L, 5L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )191,
      0L, 0L}, 
        {(spritenum_t )29, 9L, 5L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )192,
      0L, 0L}, 
        {(spritenum_t )29, 10L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )193,
      0L, 0L}, 
        {(spritenum_t )29, 11L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )29, 12L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )195,
      0L, 0L}, 
        {(spritenum_t )29, 13L, 5L, {(void (*)(void * ))(& A_XScream)}, (statenum_t )196,
      0L, 0L}, 
        {(spritenum_t )29, 14L, 5L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )197,
      0L, 0L}, 
        {(spritenum_t )29, 15L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )198,
      0L, 0L}, 
        {(spritenum_t )29, 16L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )199,
      0L, 0L}, 
        {(spritenum_t )29, 17L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )200,
      0L, 0L}, 
        {(spritenum_t )29, 18L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )201,
      0L, 0L}, 
        {(spritenum_t )29, 19L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )202,
      0L, 0L}, 
        {(spritenum_t )29, 20L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )29, 10L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )204,
      0L, 0L}, 
        {(spritenum_t )29, 9L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )205,
      0L, 0L}, 
        {(spritenum_t )29, 8L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )206,
      0L, 0L}, 
        {(spritenum_t )29, 7L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )176,
      0L, 0L}, 
        {(spritenum_t )30, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )208,
      0L, 0L}, 
        {(spritenum_t )30, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )207,
      0L, 0L}, 
        {(spritenum_t )30, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )210,
      0L, 0L}, 
        {(spritenum_t )30, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )211,
      0L, 0L}, 
        {(spritenum_t )30, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )212,
      0L, 0L}, 
        {(spritenum_t )30, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )213,
      0L, 0L}, 
        {(spritenum_t )30, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )214,
      0L, 0L}, 
        {(spritenum_t )30, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )215,
      0L, 0L}, 
        {(spritenum_t )30, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )216,
      0L, 0L}, 
        {(spritenum_t )30, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )209,
      0L, 0L}, 
        {(spritenum_t )30, 4L, 10L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )218,
      0L, 0L}, 
        {(spritenum_t )30, 32773L, 10L, {(void (*)(void * ))(& A_SPosAttack)}, (statenum_t )219,
      0L, 0L}, 
        {(spritenum_t )30, 4L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )209,
      0L, 0L}, 
        {(spritenum_t )30, 6L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )221,
      0L, 0L}, 
        {(spritenum_t )30, 6L, 3L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )209,
      0L, 0L}, 
        {(spritenum_t )30, 7L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )223,
      0L, 0L}, 
        {(spritenum_t )30, 8L, 5L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )224,
      0L, 0L}, 
        {(spritenum_t )30, 9L, 5L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )225,
      0L, 0L}, 
        {(spritenum_t )30, 10L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )226,
      0L, 0L}, 
        {(spritenum_t )30, 11L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )30, 12L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )228,
      0L, 0L}, 
        {(spritenum_t )30, 13L, 5L, {(void (*)(void * ))(& A_XScream)}, (statenum_t )229,
      0L, 0L}, 
        {(spritenum_t )30, 14L, 5L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )230,
      0L, 0L}, 
        {(spritenum_t )30, 15L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )231,
      0L, 0L}, 
        {(spritenum_t )30, 16L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )232,
      0L, 0L}, 
        {(spritenum_t )30, 17L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )233,
      0L, 0L}, 
        {(spritenum_t )30, 18L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )234,
      0L, 0L}, 
        {(spritenum_t )30, 19L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )235,
      0L, 0L}, 
        {(spritenum_t )30, 20L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )30, 11L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )237,
      0L, 0L}, 
        {(spritenum_t )30, 10L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )238,
      0L, 0L}, 
        {(spritenum_t )30, 9L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )239,
      0L, 0L}, 
        {(spritenum_t )30, 8L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )240,
      0L, 0L}, 
        {(spritenum_t )30, 7L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )209,
      0L, 0L}, 
        {(spritenum_t )31, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )242,
      0L, 0L}, 
        {(spritenum_t )31, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )241,
      0L, 0L}, 
        {(spritenum_t )31, 0L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )244,
      0L, 0L}, 
        {(spritenum_t )31, 0L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )245,
      0L, 0L}, 
        {(spritenum_t )31, 1L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )246,
      0L, 0L}, 
        {(spritenum_t )31, 1L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )247,
      0L, 0L}, 
        {(spritenum_t )31, 2L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )248,
      0L, 0L}, 
        {(spritenum_t )31, 2L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )249,
      0L, 0L}, 
        {(spritenum_t )31, 3L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )250,
      0L, 0L}, 
        {(spritenum_t )31, 3L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )251,
      0L, 0L}, 
        {(spritenum_t )31, 4L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )252,
      0L, 0L}, 
        {(spritenum_t )31, 4L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )253,
      0L, 0L}, 
        {(spritenum_t )31, 5L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )254,
      0L, 0L}, 
        {(spritenum_t )31, 5L, 2L, {(void (*)(void * ))(& A_VileChase)}, (statenum_t )243,
      0L, 0L}, 
        {(spritenum_t )31, 32774L, 0L, {(void (*)(void * ))(& A_VileStart)}, (statenum_t )256,
      0L, 0L}, 
        {(spritenum_t )31, 32774L, 10L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )257,
      0L, 0L}, 
        {(spritenum_t )31, 32775L, 8L, {(void (*)(void * ))(& A_VileTarget)}, (statenum_t )258,
      0L, 0L}, 
        {(spritenum_t )31, 32776L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )259,
      0L, 0L}, 
        {(spritenum_t )31, 32777L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )260,
      0L, 0L}, 
        {(spritenum_t )31, 32778L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )261,
      0L, 0L}, 
        {(spritenum_t )31, 32779L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )262,
      0L, 0L}, 
        {(spritenum_t )31, 32780L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )263,
      0L, 0L}, 
        {(spritenum_t )31, 32781L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )264,
      0L, 0L}, 
        {(spritenum_t )31, 32782L, 8L, {(void (*)(void * ))(& A_VileAttack)}, (statenum_t )265,
      0L, 0L}, 
        {(spritenum_t )31, 32783L, 20L, {(void (*)(void * ))((void *)0)}, (statenum_t )243,
      0L, 0L}, 
        {(spritenum_t )31, 32794L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )267,
      0L, 0L}, 
        {(spritenum_t )31, 32795L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )268,
      0L, 0L}, 
        {(spritenum_t )31, 32796L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )243,
      0L, 0L}, 
        {(spritenum_t )31, 16L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )270,
      0L, 0L}, 
        {(spritenum_t )31, 16L, 5L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )243,
      0L, 0L}, 
        {(spritenum_t )31, 16L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )272,
      0L, 0L}, 
        {(spritenum_t )31, 17L, 7L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )273,
      0L, 0L}, 
        {(spritenum_t )31, 18L, 7L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )274,
      0L, 0L}, 
        {(spritenum_t )31, 19L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )275,
      0L, 0L}, 
        {(spritenum_t )31, 20L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )276,
      0L, 0L}, 
        {(spritenum_t )31, 21L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )277,
      0L, 0L}, 
        {(spritenum_t )31, 22L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )278,
      0L, 0L}, 
        {(spritenum_t )31, 23L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )279,
      0L, 0L}, 
        {(spritenum_t )31, 24L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )280,
      0L, 0L}, 
        {(spritenum_t )31, 25L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )32, 32768L, 2L, {(void (*)(void * ))(& A_StartFire)}, (statenum_t )282,
      0L, 0L}, 
        {(spritenum_t )32, 32769L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )283,
      0L, 0L}, 
        {(spritenum_t )32, 32768L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )284,
      0L, 0L}, 
        {(spritenum_t )32, 32769L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )285,
      0L, 0L}, 
        {(spritenum_t )32, 32770L, 2L, {(void (*)(void * ))(& A_FireCrackle)}, (statenum_t )286,
      0L, 0L}, 
        {(spritenum_t )32, 32769L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )287,
      0L, 0L}, 
        {(spritenum_t )32, 32770L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )288,
      0L, 0L}, 
        {(spritenum_t )32, 32769L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )289,
      0L, 0L}, 
        {(spritenum_t )32, 32770L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )290,
      0L, 0L}, 
        {(spritenum_t )32, 32771L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )291,
      0L, 0L}, 
        {(spritenum_t )32, 32770L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )292,
      0L, 0L}, 
        {(spritenum_t )32, 32771L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )293,
      0L, 0L}, 
        {(spritenum_t )32, 32770L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )294,
      0L, 0L}, 
        {(spritenum_t )32, 32771L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )295,
      0L, 0L}, 
        {(spritenum_t )32, 32772L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )296,
      0L, 0L}, 
        {(spritenum_t )32, 32771L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )297,
      0L, 0L}, 
        {(spritenum_t )32, 32772L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )298,
      0L, 0L}, 
        {(spritenum_t )32, 32771L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )299,
      0L, 0L}, 
        {(spritenum_t )32, 32772L, 2L, {(void (*)(void * ))(& A_FireCrackle)}, (statenum_t )300,
      0L, 0L}, 
        {(spritenum_t )32, 32773L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )301,
      0L, 0L}, 
        {(spritenum_t )32, 32772L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )302,
      0L, 0L}, 
        {(spritenum_t )32, 32773L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )303,
      0L, 0L}, 
        {(spritenum_t )32, 32772L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )304,
      0L, 0L}, 
        {(spritenum_t )32, 32773L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )305,
      0L, 0L}, 
        {(spritenum_t )32, 32774L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )306,
      0L, 0L}, 
        {(spritenum_t )32, 32775L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )307,
      0L, 0L}, 
        {(spritenum_t )32, 32774L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )308,
      0L, 0L}, 
        {(spritenum_t )32, 32775L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )309,
      0L, 0L}, 
        {(spritenum_t )32, 32774L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )310,
      0L, 0L}, 
        {(spritenum_t )32, 32775L, 2L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )17, 1L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )312,
      0L, 0L}, 
        {(spritenum_t )17, 2L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )313,
      0L, 0L}, 
        {(spritenum_t )17, 1L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )314,
      0L, 0L}, 
        {(spritenum_t )17, 2L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )315,
      0L, 0L}, 
        {(spritenum_t )17, 3L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )33, 32768L, 2L, {(void (*)(void * ))(& A_Tracer)}, (statenum_t )317,
      0L, 0L}, 
        {(spritenum_t )33, 32769L, 2L, {(void (*)(void * ))(& A_Tracer)}, (statenum_t )316,
      0L, 0L}, 
        {(spritenum_t )34, 32768L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )319,
      0L, 0L}, 
        {(spritenum_t )34, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )320,
      0L, 0L}, 
        {(spritenum_t )34, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )35, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )322,
      0L, 0L}, 
        {(spritenum_t )35, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )321,
      0L, 0L}, 
        {(spritenum_t )35, 0L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )324,
      0L, 0L}, 
        {(spritenum_t )35, 0L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )325,
      0L, 0L}, 
        {(spritenum_t )35, 1L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )326,
      0L, 0L}, 
        {(spritenum_t )35, 1L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )327,
      0L, 0L}, 
        {(spritenum_t )35, 2L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )328,
      0L, 0L}, 
        {(spritenum_t )35, 2L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )329,
      0L, 0L}, 
        {(spritenum_t )35, 3L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )330,
      0L, 0L}, 
        {(spritenum_t )35, 3L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )331,
      0L, 0L}, 
        {(spritenum_t )35, 4L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )332,
      0L, 0L}, 
        {(spritenum_t )35, 4L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )333,
      0L, 0L}, 
        {(spritenum_t )35, 5L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )334,
      0L, 0L}, 
        {(spritenum_t )35, 5L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )323,
      0L, 0L}, 
        {(spritenum_t )35, 6L, 0L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )336,
      0L, 0L}, 
        {(spritenum_t )35, 6L, 6L, {(void (*)(void * ))(& A_SkelWhoosh)}, (statenum_t )337,
      0L, 0L}, 
        {(spritenum_t )35, 7L, 6L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )338,
      0L, 0L}, 
        {(spritenum_t )35, 8L, 6L, {(void (*)(void * ))(& A_SkelFist)}, (statenum_t )323,
      0L, 0L}, 
        {(spritenum_t )35, 32777L, 0L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )340,
      0L, 0L}, 
        {(spritenum_t )35, 32777L, 10L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )341,
      0L, 0L}, 
        {(spritenum_t )35, 10L, 10L, {(void (*)(void * ))(& A_SkelMissile)}, (statenum_t )342,
      0L, 0L}, 
        {(spritenum_t )35, 10L, 10L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )323,
      0L, 0L}, 
        {(spritenum_t )35, 11L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )344,
      0L, 0L}, 
        {(spritenum_t )35, 11L, 5L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )323,
      0L, 0L}, 
        {(spritenum_t )35, 11L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )346,
      0L, 0L}, 
        {(spritenum_t )35, 12L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )347,
      0L, 0L}, 
        {(spritenum_t )35, 13L, 7L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )348,
      0L, 0L}, 
        {(spritenum_t )35, 14L, 7L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )349,
      0L, 0L}, 
        {(spritenum_t )35, 15L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )350,
      0L, 0L}, 
        {(spritenum_t )35, 16L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )35, 16L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )352,
      0L, 0L}, 
        {(spritenum_t )35, 15L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )353,
      0L, 0L}, 
        {(spritenum_t )35, 14L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )354,
      0L, 0L}, 
        {(spritenum_t )35, 13L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )355,
      0L, 0L}, 
        {(spritenum_t )35, 12L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )356,
      0L, 0L}, 
        {(spritenum_t )35, 11L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )323,
      0L, 0L}, 
        {(spritenum_t )36, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )358,
      0L, 0L}, 
        {(spritenum_t )36, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )357,
      0L, 0L}, 
        {(spritenum_t )22, 32769L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )360,
      0L, 0L}, 
        {(spritenum_t )22, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )361,
      0L, 0L}, 
        {(spritenum_t )22, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )37, 0L, 15L, {(void (*)(void * ))(& A_Look)}, (statenum_t )363,
      0L, 0L}, 
        {(spritenum_t )37, 1L, 15L, {(void (*)(void * ))(& A_Look)}, (statenum_t )362,
      0L, 0L}, 
        {(spritenum_t )37, 0L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )365,
      0L, 0L}, 
        {(spritenum_t )37, 0L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )366,
      0L, 0L}, 
        {(spritenum_t )37, 1L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )367,
      0L, 0L}, 
        {(spritenum_t )37, 1L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )368,
      0L, 0L}, 
        {(spritenum_t )37, 2L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )369,
      0L, 0L}, 
        {(spritenum_t )37, 2L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )370,
      0L, 0L}, 
        {(spritenum_t )37, 3L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )371,
      0L, 0L}, 
        {(spritenum_t )37, 3L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )372,
      0L, 0L}, 
        {(spritenum_t )37, 4L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )373,
      0L, 0L}, 
        {(spritenum_t )37, 4L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )374,
      0L, 0L}, 
        {(spritenum_t )37, 5L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )375,
      0L, 0L}, 
        {(spritenum_t )37, 5L, 4L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )364,
      0L, 0L}, 
        {(spritenum_t )37, 6L, 20L, {(void (*)(void * ))(& A_FatRaise)}, (statenum_t )377,
      0L, 0L}, 
        {(spritenum_t )37, 32775L, 10L, {(void (*)(void * ))(& A_FatAttack1)}, (statenum_t )378,
      0L, 0L}, 
        {(spritenum_t )37, 8L, 5L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )379,
      0L, 0L}, 
        {(spritenum_t )37, 6L, 5L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )380,
      0L, 0L}, 
        {(spritenum_t )37, 32775L, 10L, {(void (*)(void * ))(& A_FatAttack2)}, (statenum_t )381,
      0L, 0L}, 
        {(spritenum_t )37, 8L, 5L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )382,
      0L, 0L}, 
        {(spritenum_t )37, 6L, 5L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )383,
      0L, 0L}, 
        {(spritenum_t )37, 32775L, 10L, {(void (*)(void * ))(& A_FatAttack3)}, (statenum_t )384,
      0L, 0L}, 
        {(spritenum_t )37, 8L, 5L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )385,
      0L, 0L}, 
        {(spritenum_t )37, 6L, 5L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )364,
      0L, 0L}, 
        {(spritenum_t )37, 9L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )387,
      0L, 0L}, 
        {(spritenum_t )37, 9L, 3L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )364,
      0L, 0L}, 
        {(spritenum_t )37, 10L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )389,
      0L, 0L}, 
        {(spritenum_t )37, 11L, 6L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )390,
      0L, 0L}, 
        {(spritenum_t )37, 12L, 6L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )391,
      0L, 0L}, 
        {(spritenum_t )37, 13L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )392,
      0L, 0L}, 
        {(spritenum_t )37, 14L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )393,
      0L, 0L}, 
        {(spritenum_t )37, 15L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )394,
      0L, 0L}, 
        {(spritenum_t )37, 16L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )395,
      0L, 0L}, 
        {(spritenum_t )37, 17L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )396,
      0L, 0L}, 
        {(spritenum_t )37, 18L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )397,
      0L, 0L}, 
        {(spritenum_t )37, 19L, -1L, {(void (*)(void * ))(& A_BossDeath)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )37, 17L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )399,
      0L, 0L}, 
        {(spritenum_t )37, 16L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )400,
      0L, 0L}, 
        {(spritenum_t )37, 15L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )401,
      0L, 0L}, 
        {(spritenum_t )37, 14L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )402,
      0L, 0L}, 
        {(spritenum_t )37, 13L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )403,
      0L, 0L}, 
        {(spritenum_t )37, 12L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )404,
      0L, 0L}, 
        {(spritenum_t )37, 11L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )405,
      0L, 0L}, 
        {(spritenum_t )37, 10L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )364,
      0L, 0L}, 
        {(spritenum_t )38, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )407,
      0L, 0L}, 
        {(spritenum_t )38, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )406,
      0L, 0L}, 
        {(spritenum_t )38, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )409,
      0L, 0L}, 
        {(spritenum_t )38, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )410,
      0L, 0L}, 
        {(spritenum_t )38, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )411,
      0L, 0L}, 
        {(spritenum_t )38, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )412,
      0L, 0L}, 
        {(spritenum_t )38, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )413,
      0L, 0L}, 
        {(spritenum_t )38, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )414,
      0L, 0L}, 
        {(spritenum_t )38, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )415,
      0L, 0L}, 
        {(spritenum_t )38, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )408,
      0L, 0L}, 
        {(spritenum_t )38, 4L, 10L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )417,
      0L, 0L}, 
        {(spritenum_t )38, 32773L, 4L, {(void (*)(void * ))(& A_CPosAttack)}, (statenum_t )418,
      0L, 0L}, 
        {(spritenum_t )38, 32772L, 4L, {(void (*)(void * ))(& A_CPosAttack)}, (statenum_t )419,
      0L, 0L}, 
        {(spritenum_t )38, 5L, 1L, {(void (*)(void * ))(& A_CPosRefire)}, (statenum_t )417,
      0L, 0L}, 
        {(spritenum_t )38, 6L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )421,
      0L, 0L}, 
        {(spritenum_t )38, 6L, 3L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )408,
      0L, 0L}, 
        {(spritenum_t )38, 7L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )423,
      0L, 0L}, 
        {(spritenum_t )38, 8L, 5L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )424,
      0L, 0L}, 
        {(spritenum_t )38, 9L, 5L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )425,
      0L, 0L}, 
        {(spritenum_t )38, 10L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )426,
      0L, 0L}, 
        {(spritenum_t )38, 11L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )427,
      0L, 0L}, 
        {(spritenum_t )38, 12L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )428,
      0L, 0L}, 
        {(spritenum_t )38, 13L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )38, 14L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )430,
      0L, 0L}, 
        {(spritenum_t )38, 15L, 5L, {(void (*)(void * ))(& A_XScream)}, (statenum_t )431,
      0L, 0L}, 
        {(spritenum_t )38, 16L, 5L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )432,
      0L, 0L}, 
        {(spritenum_t )38, 17L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )433,
      0L, 0L}, 
        {(spritenum_t )38, 18L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )434,
      0L, 0L}, 
        {(spritenum_t )38, 19L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )38, 13L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )436,
      0L, 0L}, 
        {(spritenum_t )38, 12L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )437,
      0L, 0L}, 
        {(spritenum_t )38, 11L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )438,
      0L, 0L}, 
        {(spritenum_t )38, 10L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )439,
      0L, 0L}, 
        {(spritenum_t )38, 9L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )440,
      0L, 0L}, 
        {(spritenum_t )38, 8L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )441,
      0L, 0L}, 
        {(spritenum_t )38, 7L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )408,
      0L, 0L}, 
        {(spritenum_t )0, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )443,
      0L, 0L}, 
        {(spritenum_t )0, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )442,
      0L, 0L}, 
        {(spritenum_t )0, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )445,
      0L, 0L}, 
        {(spritenum_t )0, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )446,
      0L, 0L}, 
        {(spritenum_t )0, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )447,
      0L, 0L}, 
        {(spritenum_t )0, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )448,
      0L, 0L}, 
        {(spritenum_t )0, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )449,
      0L, 0L}, 
        {(spritenum_t )0, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )450,
      0L, 0L}, 
        {(spritenum_t )0, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )451,
      0L, 0L}, 
        {(spritenum_t )0, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )444,
      0L, 0L}, 
        {(spritenum_t )0, 4L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )453,
      0L, 0L}, 
        {(spritenum_t )0, 5L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )454,
      0L, 0L}, 
        {(spritenum_t )0, 6L, 6L, {(void (*)(void * ))(& A_TroopAttack)}, (statenum_t )444,
      0L, 0L}, 
        {(spritenum_t )0, 7L, 2L, {(void (*)(void * ))((void *)0)}, (statenum_t )456,
      0L, 0L}, 
        {(spritenum_t )0, 7L, 2L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )444,
      0L, 0L}, 
        {(spritenum_t )0, 8L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )458,
      0L, 0L}, 
        {(spritenum_t )0, 9L, 8L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )459,
      0L, 0L}, 
        {(spritenum_t )0, 10L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )460,
      0L, 0L}, 
        {(spritenum_t )0, 11L, 6L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )461,
      0L, 0L}, 
        {(spritenum_t )0, 12L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )0, 13L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )463,
      0L, 0L}, 
        {(spritenum_t )0, 14L, 5L, {(void (*)(void * ))(& A_XScream)}, (statenum_t )464,
      0L, 0L}, 
        {(spritenum_t )0, 15L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )465,
      0L, 0L}, 
        {(spritenum_t )0, 16L, 5L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )466,
      0L, 0L}, 
        {(spritenum_t )0, 17L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )467,
      0L, 0L}, 
        {(spritenum_t )0, 18L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )468,
      0L, 0L}, 
        {(spritenum_t )0, 19L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )469,
      0L, 0L}, 
        {(spritenum_t )0, 20L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )0, 12L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )471,
      0L, 0L}, 
        {(spritenum_t )0, 11L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )472,
      0L, 0L}, 
        {(spritenum_t )0, 10L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )473,
      0L, 0L}, 
        {(spritenum_t )0, 9L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )474,
      0L, 0L}, 
        {(spritenum_t )0, 8L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )444,
      0L, 0L}, 
        {(spritenum_t )39, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )476,
      0L, 0L}, 
        {(spritenum_t )39, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )475,
      0L, 0L}, 
        {(spritenum_t )39, 0L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )478,
      0L, 0L}, 
        {(spritenum_t )39, 0L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )479,
      0L, 0L}, 
        {(spritenum_t )39, 1L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )480,
      0L, 0L}, 
        {(spritenum_t )39, 1L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )481,
      0L, 0L}, 
        {(spritenum_t )39, 2L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )482,
      0L, 0L}, 
        {(spritenum_t )39, 2L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )483,
      0L, 0L}, 
        {(spritenum_t )39, 3L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )484,
      0L, 0L}, 
        {(spritenum_t )39, 3L, 2L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )477,
      0L, 0L}, 
        {(spritenum_t )39, 4L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )486,
      0L, 0L}, 
        {(spritenum_t )39, 5L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )487,
      0L, 0L}, 
        {(spritenum_t )39, 6L, 8L, {(void (*)(void * ))(& A_SargAttack)}, (statenum_t )477,
      0L, 0L}, 
        {(spritenum_t )39, 7L, 2L, {(void (*)(void * ))((void *)0)}, (statenum_t )489,
      0L, 0L}, 
        {(spritenum_t )39, 7L, 2L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )477,
      0L, 0L}, 
        {(spritenum_t )39, 8L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )491,
      0L, 0L}, 
        {(spritenum_t )39, 9L, 8L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )492,
      0L, 0L}, 
        {(spritenum_t )39, 10L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )493,
      0L, 0L}, 
        {(spritenum_t )39, 11L, 4L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )494,
      0L, 0L}, 
        {(spritenum_t )39, 12L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )495,
      0L, 0L}, 
        {(spritenum_t )39, 13L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )39, 13L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )497,
      0L, 0L}, 
        {(spritenum_t )39, 12L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )498,
      0L, 0L}, 
        {(spritenum_t )39, 11L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )499,
      0L, 0L}, 
        {(spritenum_t )39, 10L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )500,
      0L, 0L}, 
        {(spritenum_t )39, 9L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )501,
      0L, 0L}, 
        {(spritenum_t )39, 8L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )477,
      0L, 0L}, 
        {(spritenum_t )40, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )502,
      0L, 0L}, 
        {(spritenum_t )40, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )503,
      0L, 0L}, 
        {(spritenum_t )40, 1L, 5L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )505,
      0L, 0L}, 
        {(spritenum_t )40, 2L, 5L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )506,
      0L, 0L}, 
        {(spritenum_t )40, 32771L, 5L, {(void (*)(void * ))(& A_HeadAttack)}, (statenum_t )503,
      0L, 0L}, 
        {(spritenum_t )40, 4L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )508,
      0L, 0L}, 
        {(spritenum_t )40, 4L, 3L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )509,
      0L, 0L}, 
        {(spritenum_t )40, 5L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )503,
      0L, 0L}, 
        {(spritenum_t )40, 6L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )511,
      0L, 0L}, 
        {(spritenum_t )40, 7L, 8L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )512,
      0L, 0L}, 
        {(spritenum_t )40, 8L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )513,
      0L, 0L}, 
        {(spritenum_t )40, 9L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )514,
      0L, 0L}, 
        {(spritenum_t )40, 10L, 8L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )515,
      0L, 0L}, 
        {(spritenum_t )40, 11L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )40, 11L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )517,
      0L, 0L}, 
        {(spritenum_t )40, 10L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )518,
      0L, 0L}, 
        {(spritenum_t )40, 9L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )519,
      0L, 0L}, 
        {(spritenum_t )40, 8L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )520,
      0L, 0L}, 
        {(spritenum_t )40, 7L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )521,
      0L, 0L}, 
        {(spritenum_t )40, 6L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )503,
      0L, 0L}, 
        {(spritenum_t )41, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )523,
      0L, 0L}, 
        {(spritenum_t )41, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )522,
      0L, 0L}, 
        {(spritenum_t )41, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )525,
      0L, 0L}, 
        {(spritenum_t )41, 32771L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )526,
      0L, 0L}, 
        {(spritenum_t )41, 32772L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )42, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )528,
      0L, 0L}, 
        {(spritenum_t )42, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )527,
      0L, 0L}, 
        {(spritenum_t )42, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )530,
      0L, 0L}, 
        {(spritenum_t )42, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )531,
      0L, 0L}, 
        {(spritenum_t )42, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )532,
      0L, 0L}, 
        {(spritenum_t )42, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )533,
      0L, 0L}, 
        {(spritenum_t )42, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )534,
      0L, 0L}, 
        {(spritenum_t )42, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )535,
      0L, 0L}, 
        {(spritenum_t )42, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )536,
      0L, 0L}, 
        {(spritenum_t )42, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )529,
      0L, 0L}, 
        {(spritenum_t )42, 4L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )538,
      0L, 0L}, 
        {(spritenum_t )42, 5L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )539,
      0L, 0L}, 
        {(spritenum_t )42, 6L, 8L, {(void (*)(void * ))(& A_BruisAttack)}, (statenum_t )529,
      0L, 0L}, 
        {(spritenum_t )42, 7L, 2L, {(void (*)(void * ))((void *)0)}, (statenum_t )541,
      0L, 0L}, 
        {(spritenum_t )42, 7L, 2L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )529,
      0L, 0L}, 
        {(spritenum_t )42, 8L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )543,
      0L, 0L}, 
        {(spritenum_t )42, 9L, 8L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )544,
      0L, 0L}, 
        {(spritenum_t )42, 10L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )545,
      0L, 0L}, 
        {(spritenum_t )42, 11L, 8L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )546,
      0L, 0L}, 
        {(spritenum_t )42, 12L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )547,
      0L, 0L}, 
        {(spritenum_t )42, 13L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )548,
      0L, 0L}, 
        {(spritenum_t )42, 14L, -1L, {(void (*)(void * ))(& A_BossDeath)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )42, 14L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )550,
      0L, 0L}, 
        {(spritenum_t )42, 13L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )551,
      0L, 0L}, 
        {(spritenum_t )42, 12L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )552,
      0L, 0L}, 
        {(spritenum_t )42, 11L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )553,
      0L, 0L}, 
        {(spritenum_t )42, 10L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )554,
      0L, 0L}, 
        {(spritenum_t )42, 9L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )555,
      0L, 0L}, 
        {(spritenum_t )42, 8L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )529,
      0L, 0L}, 
        {(spritenum_t )43, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )557,
      0L, 0L}, 
        {(spritenum_t )43, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )556,
      0L, 0L}, 
        {(spritenum_t )43, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )559,
      0L, 0L}, 
        {(spritenum_t )43, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )560,
      0L, 0L}, 
        {(spritenum_t )43, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )561,
      0L, 0L}, 
        {(spritenum_t )43, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )562,
      0L, 0L}, 
        {(spritenum_t )43, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )563,
      0L, 0L}, 
        {(spritenum_t )43, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )564,
      0L, 0L}, 
        {(spritenum_t )43, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )565,
      0L, 0L}, 
        {(spritenum_t )43, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )558,
      0L, 0L}, 
        {(spritenum_t )43, 4L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )567,
      0L, 0L}, 
        {(spritenum_t )43, 5L, 8L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )568,
      0L, 0L}, 
        {(spritenum_t )43, 6L, 8L, {(void (*)(void * ))(& A_BruisAttack)}, (statenum_t )558,
      0L, 0L}, 
        {(spritenum_t )43, 7L, 2L, {(void (*)(void * ))((void *)0)}, (statenum_t )570,
      0L, 0L}, 
        {(spritenum_t )43, 7L, 2L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )558,
      0L, 0L}, 
        {(spritenum_t )43, 8L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )572,
      0L, 0L}, 
        {(spritenum_t )43, 9L, 8L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )573,
      0L, 0L}, 
        {(spritenum_t )43, 10L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )574,
      0L, 0L}, 
        {(spritenum_t )43, 11L, 8L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )575,
      0L, 0L}, 
        {(spritenum_t )43, 12L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )576,
      0L, 0L}, 
        {(spritenum_t )43, 13L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )577,
      0L, 0L}, 
        {(spritenum_t )43, 14L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )43, 14L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )579,
      0L, 0L}, 
        {(spritenum_t )43, 13L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )580,
      0L, 0L}, 
        {(spritenum_t )43, 12L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )581,
      0L, 0L}, 
        {(spritenum_t )43, 11L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )582,
      0L, 0L}, 
        {(spritenum_t )43, 10L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )583,
      0L, 0L}, 
        {(spritenum_t )43, 9L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )584,
      0L, 0L}, 
        {(spritenum_t )43, 8L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )558,
      0L, 0L}, 
        {(spritenum_t )44, 32768L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )586,
      0L, 0L}, 
        {(spritenum_t )44, 32769L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )585,
      0L, 0L}, 
        {(spritenum_t )44, 32768L, 6L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )588,
      0L, 0L}, 
        {(spritenum_t )44, 32769L, 6L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )587,
      0L, 0L}, 
        {(spritenum_t )44, 32770L, 10L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )590,
      0L, 0L}, 
        {(spritenum_t )44, 32771L, 4L, {(void (*)(void * ))(& A_SkullAttack)}, (statenum_t )591,
      0L, 0L}, 
        {(spritenum_t )44, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )592,
      0L, 0L}, 
        {(spritenum_t )44, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )591,
      0L, 0L}, 
        {(spritenum_t )44, 32772L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )594,
      0L, 0L}, 
        {(spritenum_t )44, 32772L, 3L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )587,
      0L, 0L}, 
        {(spritenum_t )44, 32773L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )596,
      0L, 0L}, 
        {(spritenum_t )44, 32774L, 6L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )597,
      0L, 0L}, 
        {(spritenum_t )44, 32775L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )598,
      0L, 0L}, 
        {(spritenum_t )44, 32776L, 6L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )599,
      0L, 0L}, 
        {(spritenum_t )44, 9L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )600,
      0L, 0L}, 
        {(spritenum_t )44, 10L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )45, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )602,
      0L, 0L}, 
        {(spritenum_t )45, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )601,
      0L, 0L}, 
        {(spritenum_t )45, 0L, 3L, {(void (*)(void * ))(& A_Metal)}, (statenum_t )604,
      0L, 0L}, 
        {(spritenum_t )45, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )605,
      0L, 0L}, 
        {(spritenum_t )45, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )606,
      0L, 0L}, 
        {(spritenum_t )45, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )607,
      0L, 0L}, 
        {(spritenum_t )45, 2L, 3L, {(void (*)(void * ))(& A_Metal)}, (statenum_t )608,
      0L, 0L}, 
        {(spritenum_t )45, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )609,
      0L, 0L}, 
        {(spritenum_t )45, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )610,
      0L, 0L}, 
        {(spritenum_t )45, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )611,
      0L, 0L}, 
        {(spritenum_t )45, 4L, 3L, {(void (*)(void * ))(& A_Metal)}, (statenum_t )612,
      0L, 0L}, 
        {(spritenum_t )45, 4L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )613,
      0L, 0L}, 
        {(spritenum_t )45, 5L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )614,
      0L, 0L}, 
        {(spritenum_t )45, 5L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )603,
      0L, 0L}, 
        {(spritenum_t )45, 32768L, 20L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )616,
      0L, 0L}, 
        {(spritenum_t )45, 32774L, 4L, {(void (*)(void * ))(& A_SPosAttack)}, (statenum_t )617,
      0L, 0L}, 
        {(spritenum_t )45, 32775L, 4L, {(void (*)(void * ))(& A_SPosAttack)}, (statenum_t )618,
      0L, 0L}, 
        {(spritenum_t )45, 32775L, 1L, {(void (*)(void * ))(& A_SpidRefire)}, (statenum_t )616,
      0L, 0L}, 
        {(spritenum_t )45, 8L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )620,
      0L, 0L}, 
        {(spritenum_t )45, 8L, 3L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )603,
      0L, 0L}, 
        {(spritenum_t )45, 9L, 20L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )622,
      0L, 0L}, 
        {(spritenum_t )45, 10L, 10L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )623,
      0L, 0L}, 
        {(spritenum_t )45, 11L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )624,
      0L, 0L}, 
        {(spritenum_t )45, 12L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )625,
      0L, 0L}, 
        {(spritenum_t )45, 13L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )626,
      0L, 0L}, 
        {(spritenum_t )45, 14L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )627,
      0L, 0L}, 
        {(spritenum_t )45, 15L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )628,
      0L, 0L}, 
        {(spritenum_t )45, 16L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )629,
      0L, 0L}, 
        {(spritenum_t )45, 17L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )630,
      0L, 0L}, 
        {(spritenum_t )45, 18L, 30L, {(void (*)(void * ))((void *)0)}, (statenum_t )631,
      0L, 0L}, 
        {(spritenum_t )45, 18L, -1L, {(void (*)(void * ))(& A_BossDeath)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )46, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )633,
      0L, 0L}, 
        {(spritenum_t )46, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )632,
      0L, 0L}, 
        {(spritenum_t )46, 0L, 20L, {(void (*)(void * ))((void *)0)}, (statenum_t )635,
      0L, 0L}, 
        {(spritenum_t )46, 0L, 3L, {(void (*)(void * ))(& A_BabyMetal)}, (statenum_t )636,
      0L, 0L}, 
        {(spritenum_t )46, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )637,
      0L, 0L}, 
        {(spritenum_t )46, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )638,
      0L, 0L}, 
        {(spritenum_t )46, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )639,
      0L, 0L}, 
        {(spritenum_t )46, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )640,
      0L, 0L}, 
        {(spritenum_t )46, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )641,
      0L, 0L}, 
        {(spritenum_t )46, 3L, 3L, {(void (*)(void * ))(& A_BabyMetal)}, (statenum_t )642,
      0L, 0L}, 
        {(spritenum_t )46, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )643,
      0L, 0L}, 
        {(spritenum_t )46, 4L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )644,
      0L, 0L}, 
        {(spritenum_t )46, 4L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )645,
      0L, 0L}, 
        {(spritenum_t )46, 5L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )646,
      0L, 0L}, 
        {(spritenum_t )46, 5L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )635,
      0L, 0L}, 
        {(spritenum_t )46, 32768L, 20L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )648,
      0L, 0L}, 
        {(spritenum_t )46, 32774L, 4L, {(void (*)(void * ))(& A_BspiAttack)}, (statenum_t )649,
      0L, 0L}, 
        {(spritenum_t )46, 32775L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )650,
      0L, 0L}, 
        {(spritenum_t )46, 32775L, 1L, {(void (*)(void * ))(& A_SpidRefire)}, (statenum_t )648,
      0L, 0L}, 
        {(spritenum_t )46, 8L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )652,
      0L, 0L}, 
        {(spritenum_t )46, 8L, 3L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )635,
      0L, 0L}, 
        {(spritenum_t )46, 9L, 20L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )654,
      0L, 0L}, 
        {(spritenum_t )46, 10L, 7L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )655,
      0L, 0L}, 
        {(spritenum_t )46, 11L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )656,
      0L, 0L}, 
        {(spritenum_t )46, 12L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )657,
      0L, 0L}, 
        {(spritenum_t )46, 13L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )658,
      0L, 0L}, 
        {(spritenum_t )46, 14L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )659,
      0L, 0L}, 
        {(spritenum_t )46, 15L, -1L, {(void (*)(void * ))(& A_BossDeath)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )46, 15L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )661,
      0L, 0L}, 
        {(spritenum_t )46, 14L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )662,
      0L, 0L}, 
        {(spritenum_t )46, 13L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )663,
      0L, 0L}, 
        {(spritenum_t )46, 12L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )664,
      0L, 0L}, 
        {(spritenum_t )46, 11L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )665,
      0L, 0L}, 
        {(spritenum_t )46, 10L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )666,
      0L, 0L}, 
        {(spritenum_t )46, 9L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )635,
      0L, 0L}, 
        {(spritenum_t )47, 32768L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )668,
      0L, 0L}, 
        {(spritenum_t )47, 32769L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )667,
      0L, 0L}, 
        {(spritenum_t )48, 32768L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )670,
      0L, 0L}, 
        {(spritenum_t )48, 32769L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )671,
      0L, 0L}, 
        {(spritenum_t )48, 32770L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )672,
      0L, 0L}, 
        {(spritenum_t )48, 32771L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )673,
      0L, 0L}, 
        {(spritenum_t )48, 32772L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )49, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )675,
      0L, 0L}, 
        {(spritenum_t )49, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )674,
      0L, 0L}, 
        {(spritenum_t )49, 0L, 3L, {(void (*)(void * ))(& A_Hoof)}, (statenum_t )677,
      0L, 0L}, 
        {(spritenum_t )49, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )678,
      0L, 0L}, 
        {(spritenum_t )49, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )679,
      0L, 0L}, 
        {(spritenum_t )49, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )680,
      0L, 0L}, 
        {(spritenum_t )49, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )681,
      0L, 0L}, 
        {(spritenum_t )49, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )682,
      0L, 0L}, 
        {(spritenum_t )49, 3L, 3L, {(void (*)(void * ))(& A_Metal)}, (statenum_t )683,
      0L, 0L}, 
        {(spritenum_t )49, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )676,
      0L, 0L}, 
        {(spritenum_t )49, 4L, 6L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )685,
      0L, 0L}, 
        {(spritenum_t )49, 5L, 12L, {(void (*)(void * ))(& A_CyberAttack)}, (statenum_t )686,
      0L, 0L}, 
        {(spritenum_t )49, 4L, 12L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )687,
      0L, 0L}, 
        {(spritenum_t )49, 5L, 12L, {(void (*)(void * ))(& A_CyberAttack)}, (statenum_t )688,
      0L, 0L}, 
        {(spritenum_t )49, 4L, 12L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )689,
      0L, 0L}, 
        {(spritenum_t )49, 5L, 12L, {(void (*)(void * ))(& A_CyberAttack)}, (statenum_t )676,
      0L, 0L}, 
        {(spritenum_t )49, 6L, 10L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )676,
      0L, 0L}, 
        {(spritenum_t )49, 7L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )692,
      0L, 0L}, 
        {(spritenum_t )49, 8L, 10L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )693,
      0L, 0L}, 
        {(spritenum_t )49, 9L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )694,
      0L, 0L}, 
        {(spritenum_t )49, 10L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )695,
      0L, 0L}, 
        {(spritenum_t )49, 11L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )696,
      0L, 0L}, 
        {(spritenum_t )49, 12L, 10L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )697,
      0L, 0L}, 
        {(spritenum_t )49, 13L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )698,
      0L, 0L}, 
        {(spritenum_t )49, 14L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )699,
      0L, 0L}, 
        {(spritenum_t )49, 15L, 30L, {(void (*)(void * ))((void *)0)}, (statenum_t )700,
      0L, 0L}, 
        {(spritenum_t )49, 15L, -1L, {(void (*)(void * ))(& A_BossDeath)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )50, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )701,
      0L, 0L}, 
        {(spritenum_t )50, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )703,
      0L, 0L}, 
        {(spritenum_t )50, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )704,
      0L, 0L}, 
        {(spritenum_t )50, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )705,
      0L, 0L}, 
        {(spritenum_t )50, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )706,
      0L, 0L}, 
        {(spritenum_t )50, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )707,
      0L, 0L}, 
        {(spritenum_t )50, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )702,
      0L, 0L}, 
        {(spritenum_t )50, 3L, 5L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )709,
      0L, 0L}, 
        {(spritenum_t )50, 4L, 5L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )710,
      0L, 0L}, 
        {(spritenum_t )50, 32773L, 5L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )711,
      0L, 0L}, 
        {(spritenum_t )50, 32773L, 0L, {(void (*)(void * ))(& A_PainAttack)}, (statenum_t )702,
      0L, 0L}, 
        {(spritenum_t )50, 6L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )713,
      0L, 0L}, 
        {(spritenum_t )50, 6L, 6L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )702,
      0L, 0L}, 
        {(spritenum_t )50, 32775L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )715,
      0L, 0L}, 
        {(spritenum_t )50, 32776L, 8L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )716,
      0L, 0L}, 
        {(spritenum_t )50, 32777L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )717,
      0L, 0L}, 
        {(spritenum_t )50, 32778L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )718,
      0L, 0L}, 
        {(spritenum_t )50, 32779L, 8L, {(void (*)(void * ))(& A_PainDie)}, (statenum_t )719,
      0L, 0L}, 
        {(spritenum_t )50, 32780L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )50, 12L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )721,
      0L, 0L}, 
        {(spritenum_t )50, 11L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )722,
      0L, 0L}, 
        {(spritenum_t )50, 10L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )723,
      0L, 0L}, 
        {(spritenum_t )50, 9L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )724,
      0L, 0L}, 
        {(spritenum_t )50, 8L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )725,
      0L, 0L}, 
        {(spritenum_t )50, 7L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )702,
      0L, 0L}, 
        {(spritenum_t )51, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )727,
      0L, 0L}, 
        {(spritenum_t )51, 1L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )726,
      0L, 0L}, 
        {(spritenum_t )51, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )729,
      0L, 0L}, 
        {(spritenum_t )51, 0L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )730,
      0L, 0L}, 
        {(spritenum_t )51, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )731,
      0L, 0L}, 
        {(spritenum_t )51, 1L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )732,
      0L, 0L}, 
        {(spritenum_t )51, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )733,
      0L, 0L}, 
        {(spritenum_t )51, 2L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )734,
      0L, 0L}, 
        {(spritenum_t )51, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )735,
      0L, 0L}, 
        {(spritenum_t )51, 3L, 3L, {(void (*)(void * ))(& A_Chase)}, (statenum_t )728,
      0L, 0L}, 
        {(spritenum_t )51, 4L, 10L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )737,
      0L, 0L}, 
        {(spritenum_t )51, 5L, 10L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )738,
      0L, 0L}, 
        {(spritenum_t )51, 32774L, 4L, {(void (*)(void * ))(& A_CPosAttack)}, (statenum_t )739,
      0L, 0L}, 
        {(spritenum_t )51, 5L, 6L, {(void (*)(void * ))(& A_FaceTarget)}, (statenum_t )740,
      0L, 0L}, 
        {(spritenum_t )51, 32774L, 4L, {(void (*)(void * ))(& A_CPosAttack)}, (statenum_t )741,
      0L, 0L}, 
        {(spritenum_t )51, 5L, 1L, {(void (*)(void * ))(& A_CPosRefire)}, (statenum_t )737,
      0L, 0L}, 
        {(spritenum_t )51, 7L, 3L, {(void (*)(void * ))((void *)0)}, (statenum_t )743,
      0L, 0L}, 
        {(spritenum_t )51, 7L, 3L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )728,
      0L, 0L}, 
        {(spritenum_t )51, 8L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )745,
      0L, 0L}, 
        {(spritenum_t )51, 9L, 5L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )746,
      0L, 0L}, 
        {(spritenum_t )51, 10L, 5L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )747,
      0L, 0L}, 
        {(spritenum_t )51, 11L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )748,
      0L, 0L}, 
        {(spritenum_t )51, 12L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )51, 13L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )750,
      0L, 0L}, 
        {(spritenum_t )51, 14L, 5L, {(void (*)(void * ))(& A_XScream)}, (statenum_t )751,
      0L, 0L}, 
        {(spritenum_t )51, 15L, 5L, {(void (*)(void * ))(& A_Fall)}, (statenum_t )752,
      0L, 0L}, 
        {(spritenum_t )51, 16L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )753,
      0L, 0L}, 
        {(spritenum_t )51, 17L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )754,
      0L, 0L}, 
        {(spritenum_t )51, 18L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )755,
      0L, 0L}, 
        {(spritenum_t )51, 19L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )756,
      0L, 0L}, 
        {(spritenum_t )51, 20L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )757,
      0L, 0L}, 
        {(spritenum_t )51, 21L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )51, 12L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )759,
      0L, 0L}, 
        {(spritenum_t )51, 11L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )760,
      0L, 0L}, 
        {(spritenum_t )51, 10L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )761,
      0L, 0L}, 
        {(spritenum_t )51, 9L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )762,
      0L, 0L}, 
        {(spritenum_t )51, 8L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )728,
      0L, 0L}, 
        {(spritenum_t )52, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )763,
      0L, 0L}, 
        {(spritenum_t )52, 0L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )765,
      0L, 0L}, 
        {(spritenum_t )52, 1L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )766,
      0L, 0L}, 
        {(spritenum_t )52, 2L, 6L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )767,
      0L, 0L}, 
        {(spritenum_t )52, 3L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )768,
      0L, 0L}, 
        {(spritenum_t )52, 4L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )769,
      0L, 0L}, 
        {(spritenum_t )52, 5L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )770,
      0L, 0L}, 
        {(spritenum_t )52, 6L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )771,
      0L, 0L}, 
        {(spritenum_t )52, 7L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )772,
      0L, 0L}, 
        {(spritenum_t )52, 8L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )773,
      0L, 0L}, 
        {(spritenum_t )52, 9L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )774,
      0L, 0L}, 
        {(spritenum_t )52, 10L, 6L, {(void (*)(void * ))(& A_KeenDie)}, (statenum_t )775,
      0L, 0L}, 
        {(spritenum_t )52, 11L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )52, 12L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )777,
      0L, 0L}, 
        {(spritenum_t )52, 12L, 8L, {(void (*)(void * ))(& A_Pain)}, (statenum_t )763,
      0L, 0L}, 
        {(spritenum_t )53, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )53, 1L, 36L, {(void (*)(void * ))(& A_BrainPain)}, (statenum_t )778,
      0L, 0L}, 
        {(spritenum_t )53, 0L, 100L, {(void (*)(void * ))(& A_BrainScream)}, (statenum_t )781,
      0L, 0L}, 
        {(spritenum_t )53, 0L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )782,
      0L, 0L}, 
        {(spritenum_t )53, 0L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )783,
      0L, 0L}, 
        {(spritenum_t )53, 0L, -1L, {(void (*)(void * ))(& A_BrainDie)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )51, 0L, 10L, {(void (*)(void * ))(& A_Look)}, (statenum_t )784,
      0L, 0L}, 
        {(spritenum_t )51, 0L, 181L, {(void (*)(void * ))(& A_BrainAwake)}, (statenum_t )786,
      0L, 0L}, 
        {(spritenum_t )51, 0L, 150L, {(void (*)(void * ))(& A_BrainSpit)}, (statenum_t )786,
      0L, 0L}, 
        {(spritenum_t )54, 32768L, 3L, {(void (*)(void * ))(& A_SpawnSound)}, (statenum_t )788,
      0L, 0L}, 
        {(spritenum_t )54, 32769L, 3L, {(void (*)(void * ))(& A_SpawnFly)}, (statenum_t )789,
      0L, 0L}, 
        {(spritenum_t )54, 32770L, 3L, {(void (*)(void * ))(& A_SpawnFly)}, (statenum_t )790,
      0L, 0L}, 
        {(spritenum_t )54, 32771L, 3L, {(void (*)(void * ))(& A_SpawnFly)}, (statenum_t )787,
      0L, 0L}, 
        {(spritenum_t )32, 32768L, 4L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )792,
      0L, 0L}, 
        {(spritenum_t )32, 32769L, 4L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )793,
      0L, 0L}, 
        {(spritenum_t )32, 32770L, 4L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )794,
      0L, 0L}, 
        {(spritenum_t )32, 32771L, 4L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )795,
      0L, 0L}, 
        {(spritenum_t )32, 32772L, 4L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )796,
      0L, 0L}, 
        {(spritenum_t )32, 32773L, 4L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )797,
      0L, 0L}, 
        {(spritenum_t )32, 32774L, 4L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )798,
      0L, 0L}, 
        {(spritenum_t )32, 32775L, 4L, {(void (*)(void * ))(& A_Fire)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )22, 32769L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )800,
      0L, 0L}, 
        {(spritenum_t )22, 32770L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )801,
      0L, 0L}, 
        {(spritenum_t )22, 32771L, 10L, {(void (*)(void * ))(& A_BrainExplode)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )55, 0L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )803,
      0L, 0L}, 
        {(spritenum_t )55, 32769L, 7L, {(void (*)(void * ))((void *)0)}, (statenum_t )802,
      0L, 0L}, 
        {(spritenum_t )56, 0L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )805,
      0L, 0L}, 
        {(spritenum_t )56, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )804,
      0L, 0L}, 
        {(spritenum_t )57, 0L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )807,
      0L, 0L}, 
        {(spritenum_t )57, 1L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )806,
      0L, 0L}, 
        {(spritenum_t )58, 32768L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )809,
      0L, 0L}, 
        {(spritenum_t )58, 32769L, 5L, {(void (*)(void * ))(& A_Scream)}, (statenum_t )810,
      0L, 0L}, 
        {(spritenum_t )58, 32770L, 5L, {(void (*)(void * ))((void *)0)}, (statenum_t )811,
      0L, 0L}, 
        {(spritenum_t )58, 32771L, 10L, {(void (*)(void * ))(& A_Explode)}, (statenum_t )812,
      0L, 0L}, 
        {(spritenum_t )58, 32772L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )59, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )814,
      0L, 0L}, 
        {(spritenum_t )59, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )815,
      0L, 0L}, 
        {(spritenum_t )59, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )813,
      0L, 0L}, 
        {(spritenum_t )60, 0L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )817,
      0L, 0L}, 
        {(spritenum_t )60, 1L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )818,
      0L, 0L}, 
        {(spritenum_t )60, 2L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )819,
      0L, 0L}, 
        {(spritenum_t )60, 3L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )820,
      0L, 0L}, 
        {(spritenum_t )60, 2L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )821,
      0L, 0L}, 
        {(spritenum_t )60, 1L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )816,
      0L, 0L}, 
        {(spritenum_t )61, 0L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )823,
      0L, 0L}, 
        {(spritenum_t )61, 1L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )824,
      0L, 0L}, 
        {(spritenum_t )61, 2L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )825,
      0L, 0L}, 
        {(spritenum_t )61, 3L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )826,
      0L, 0L}, 
        {(spritenum_t )61, 2L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )827,
      0L, 0L}, 
        {(spritenum_t )61, 1L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )822,
      0L, 0L}, 
        {(spritenum_t )62, 0L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )829,
      0L, 0L}, 
        {(spritenum_t )62, 32769L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )828,
      0L, 0L}, 
        {(spritenum_t )63, 0L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )831,
      0L, 0L}, 
        {(spritenum_t )63, 32769L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )830,
      0L, 0L}, 
        {(spritenum_t )64, 0L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )833,
      0L, 0L}, 
        {(spritenum_t )64, 32769L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )832,
      0L, 0L}, 
        {(spritenum_t )65, 0L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )835,
      0L, 0L}, 
        {(spritenum_t )65, 32769L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )834,
      0L, 0L}, 
        {(spritenum_t )66, 0L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )837,
      0L, 0L}, 
        {(spritenum_t )66, 32769L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )836,
      0L, 0L}, 
        {(spritenum_t )67, 0L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )839,
      0L, 0L}, 
        {(spritenum_t )67, 32769L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )838,
      0L, 0L}, 
        {(spritenum_t )68, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )69, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )70, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )843,
      0L, 0L}, 
        {(spritenum_t )70, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )844,
      0L, 0L}, 
        {(spritenum_t )70, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )845,
      0L, 0L}, 
        {(spritenum_t )70, 32771L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )846,
      0L, 0L}, 
        {(spritenum_t )70, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )847,
      0L, 0L}, 
        {(spritenum_t )70, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )842,
      0L, 0L}, 
        {(spritenum_t )71, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )849,
      0L, 0L}, 
        {(spritenum_t )71, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )850,
      0L, 0L}, 
        {(spritenum_t )71, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )851,
      0L, 0L}, 
        {(spritenum_t )71, 32771L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )848,
      0L, 0L}, 
        {(spritenum_t )72, 32768L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )73, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )854,
      0L, 0L}, 
        {(spritenum_t )73, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )855,
      0L, 0L}, 
        {(spritenum_t )73, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )856,
      0L, 0L}, 
        {(spritenum_t )73, 32771L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )853,
      0L, 0L}, 
        {(spritenum_t )74, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )858,
      0L, 0L}, 
        {(spritenum_t )74, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )859,
      0L, 0L}, 
        {(spritenum_t )74, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )860,
      0L, 0L}, 
        {(spritenum_t )74, 32771L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )857,
      0L, 0L}, 
        {(spritenum_t )75, 32768L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )76, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )863,
      0L, 0L}, 
        {(spritenum_t )76, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )864,
      0L, 0L}, 
        {(spritenum_t )76, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )865,
      0L, 0L}, 
        {(spritenum_t )76, 32771L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )866,
      0L, 0L}, 
        {(spritenum_t )76, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )867,
      0L, 0L}, 
        {(spritenum_t )76, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )862,
      0L, 0L}, 
        {(spritenum_t )77, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )869,
      0L, 0L}, 
        {(spritenum_t )77, 1L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )868,
      0L, 0L}, 
        {(spritenum_t )78, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )79, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )80, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )81, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )82, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )83, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )84, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )85, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )86, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )87, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )88, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )89, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )90, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )91, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )92, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )93, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )94, 32768L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )95, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )96, 0L, 10L, {(void (*)(void * ))((void *)0)}, (statenum_t )889,
      0L, 0L}, 
        {(spritenum_t )96, 1L, 15L, {(void (*)(void * ))((void *)0)}, (statenum_t )890,
      0L, 0L}, 
        {(spritenum_t )96, 2L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )891,
      0L, 0L}, 
        {(spritenum_t )96, 1L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )888,
      0L, 0L}, 
        {(spritenum_t )28, 13L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )28, 18L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )97, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )98, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )99, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )100, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )898,
      0L, 0L}, 
        {(spritenum_t )100, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )897,
      0L, 0L}, 
        {(spritenum_t )101, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )102, 0L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )901,
      0L, 0L}, 
        {(spritenum_t )102, 1L, 8L, {(void (*)(void * ))((void *)0)}, (statenum_t )900,
      0L, 0L}, 
        {(spritenum_t )103, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )104, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )105, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )106, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )107, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )108, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )109, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )110, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )111, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )112, 32768L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )113, 32768L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )114, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )115, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )116, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )117, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )118, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )918,
      0L, 0L}, 
        {(spritenum_t )118, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )919,
      0L, 0L}, 
        {(spritenum_t )118, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )920,
      0L, 0L}, 
        {(spritenum_t )118, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )917,
      0L, 0L}, 
        {(spritenum_t )119, 32768L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )922,
      0L, 0L}, 
        {(spritenum_t )119, 32769L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )923,
      0L, 0L}, 
        {(spritenum_t )119, 32770L, 6L, {(void (*)(void * ))((void *)0)}, (statenum_t )921,
      0L, 0L}, 
        {(spritenum_t )120, 0L, 14L, {(void (*)(void * ))((void *)0)}, (statenum_t )925,
      0L, 0L}, 
        {(spritenum_t )120, 1L, 14L, {(void (*)(void * ))((void *)0)}, (statenum_t )924,
      0L, 0L}, 
        {(spritenum_t )121, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )927,
      0L, 0L}, 
        {(spritenum_t )121, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )928,
      0L, 0L}, 
        {(spritenum_t )121, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )929,
      0L, 0L}, 
        {(spritenum_t )121, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )926,
      0L, 0L}, 
        {(spritenum_t )122, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )931,
      0L, 0L}, 
        {(spritenum_t )122, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )932,
      0L, 0L}, 
        {(spritenum_t )122, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )933,
      0L, 0L}, 
        {(spritenum_t )122, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )930,
      0L, 0L}, 
        {(spritenum_t )123, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )935,
      0L, 0L}, 
        {(spritenum_t )123, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )936,
      0L, 0L}, 
        {(spritenum_t )123, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )937,
      0L, 0L}, 
        {(spritenum_t )123, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )934,
      0L, 0L}, 
        {(spritenum_t )124, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )939,
      0L, 0L}, 
        {(spritenum_t )124, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )940,
      0L, 0L}, 
        {(spritenum_t )124, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )941,
      0L, 0L}, 
        {(spritenum_t )124, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )938,
      0L, 0L}, 
        {(spritenum_t )125, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )943,
      0L, 0L}, 
        {(spritenum_t )125, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )944,
      0L, 0L}, 
        {(spritenum_t )125, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )945,
      0L, 0L}, 
        {(spritenum_t )125, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )942,
      0L, 0L}, 
        {(spritenum_t )126, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )947,
      0L, 0L}, 
        {(spritenum_t )126, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )948,
      0L, 0L}, 
        {(spritenum_t )126, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )949,
      0L, 0L}, 
        {(spritenum_t )126, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )946,
      0L, 0L}, 
        {(spritenum_t )127, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )128, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )129, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )130, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )131, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )132, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )133, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )134, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )135, 0L, -1L, {(void (*)(void * ))((void *)0)}, (statenum_t )0,
      0L, 0L}, 
        {(spritenum_t )136, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )960,
      0L, 0L}, 
        {(spritenum_t )136, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )961,
      0L, 0L}, 
        {(spritenum_t )136, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )962,
      0L, 0L}, 
        {(spritenum_t )136, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )959,
      0L, 0L}, 
        {(spritenum_t )137, 32768L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )964,
      0L, 0L}, 
        {(spritenum_t )137, 32769L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )965,
      0L, 0L}, 
        {(spritenum_t )137, 32770L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )966,
      0L, 0L}, 
        {(spritenum_t )137, 32771L, 4L, {(void (*)(void * ))((void *)0)}, (statenum_t )963,
      0L, 0L}};
#line 1106 "info.c"
mobjinfo_t mobjinfo[137]  = 
#line 1106
  {      {-1, 149, 100, 150, 0, 0, 0, 156, 255, 25, 0, 154, 158, 165, 57, 0, 16 * (1 << 16),
      56 * (1 << 16), 100, 0, 0, 33557510, 0}, 
        {3004, 174, 20, 176, 36, 8, 1, 187, 200, 27, 0, 184, 189, 194, 59, 8, 20 * (1 << 16),
      56 * (1 << 16), 100, 0, 75, 4194310, 203}, 
        {9, 207, 30, 209, 37, 8, 0, 220, 170, 27, 0, 217, 222, 227, 60, 8, 20 * (1 << 16),
      56 * (1 << 16), 100, 0, 75, 4194310, 236}, 
        {64, 241, 700, 243, 48, 8, 0, 269, 10, 28, 0, 255, 271, 0, 71, 15, 20 * (1 << 16),
      56 * (1 << 16), 500, 0, 80, 4194310, 0}, 
        {-1, 281, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 528, 0}, 
        {66, 321, 300, 323, 106, 8, 0, 343, 100, 27, 335, 339, 345, 0, 74, 10, 20 * (1 << 16),
      56 * (1 << 16), 500, 0, 105, 4194310, 351}, 
        {-1, 316, 1000, 0, 107, 8, 0, 0, 0, 0, 0, 0, 318, 0, 82, 10 * (1 << 16), 11 * (1 << 16),
      8 * (1 << 16), 100, 10, 0, 67088, 0}, 
        {-1, 311, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 528, 0}, 
        {67, 362, 600, 364, 49, 8, 0, 386, 80, 29, 0, 376, 388, 0, 100, 8, 48 * (1 << 16),
      64 * (1 << 16), 1000, 0, 75, 4194310, 398}, 
        {-1, 357, 1000, 0, 16, 8, 0, 0, 0, 0, 0, 0, 359, 0, 17, 20 * (1 << 16), 6 * (1 << 16),
      8 * (1 << 16), 100, 8, 0, 67088, 0}, 
        {65, 406, 70, 408, 37, 8, 0, 420, 170, 27, 0, 416, 422, 429, 60, 8, 20 * (1 << 16),
      56 * (1 << 16), 100, 0, 75, 4194310, 435}, 
        {3001, 442, 60, 444, 39, 8, 0, 455, 200, 27, 452, 452, 457, 462, 62, 8, 20 * (1 << 16),
      56 * (1 << 16), 100, 0, 76, 4194310, 470}, 
        {3002, 475, 150, 477, 41, 8, 52, 488, 180, 26, 485, 0, 490, 0, 64, 10, 30 * (1 << 16),
      56 * (1 << 16), 400, 0, 77, 4194310, 496}, 
        {58, 475, 150, 477, 41, 8, 52, 488, 180, 26, 485, 0, 490, 0, 64, 10, 30 * (1 << 16),
      56 * (1 << 16), 400, 0, 77, 4456454, 496}, 
        {3005, 502, 400, 503, 42, 8, 0, 507, 128, 26, 0, 504, 510, 0, 65, 8, 31 * (1 << 16),
      56 * (1 << 16), 400, 0, 77, 4211206, 516}, 
        {3003, 527, 1000, 529, 43, 8, 0, 540, 50, 26, 537, 537, 542, 0, 67, 8, 24 * (1 << 16),
      64 * (1 << 16), 1000, 0, 77, 4194310, 549}, 
        {-1, 522, 1000, 0, 16, 8, 0, 0, 0, 0, 0, 0, 524, 0, 17, 15 * (1 << 16), 6 * (1 << 16),
      8 * (1 << 16), 100, 8, 0, 67088, 0}, 
        {69, 556, 500, 558, 47, 8, 0, 569, 50, 26, 566, 566, 571, 0, 72, 8, 24 * (1 << 16),
      64 * (1 << 16), 1000, 0, 77, 4194310, 578}, 
        {3006, 585, 100, 587, 0, 8, 51, 593, 256, 26, 0, 589, 595, 0, 17, 8, 16 * (1 << 16),
      56 * (1 << 16), 50, 3, 77, 16902, 0}, 
        {7, 601, 3000, 603, 45, 8, 2, 619, 40, 26, 0, 615, 621, 0, 69, 12, 128 * (1 << 16),
      100 * (1 << 16), 1000, 0, 77, 4194310, 0}, 
        {68, 632, 500, 634, 46, 8, 0, 651, 128, 26, 0, 647, 653, 0, 70, 12, 64 * (1 << 16),
      64 * (1 << 16), 600, 0, 78, 4194310, 660}, 
        {16, 674, 4000, 676, 44, 8, 0, 690, 20, 26, 0, 684, 691, 0, 68, 16, 40 * (1 << 16),
      110 * (1 << 16), 1000, 0, 77, 4194310, 0}, 
        {71, 701, 400, 702, 50, 8, 0, 712, 128, 30, 0, 708, 714, 0, 73, 8, 31 * (1 << 16),
      56 * (1 << 16), 400, 0, 77, 4211206, 720}, 
        {84, 726, 50, 728, 101, 8, 0, 742, 170, 27, 0, 736, 744, 749, 102, 8, 20 * (1 << 16),
      56 * (1 << 16), 100, 0, 75, 4194310, 758}, 
        {72, 763, 100, 0, 0, 8, 0, 776, 256, 103, 0, 0, 764, 0, 104, 0, 16 * (1 << 16),
      72 * (1 << 16), 10000000, 0, 0, 4195078, 0}, 
        {88, 778, 250, 0, 0, 8, 0, 779, 255, 97, 0, 0, 780, 0, 98, 0, 16 * (1 << 16),
      16 * (1 << 16), 10000000, 0, 0, 6, 0}, 
        {89, 784, 1000, 785, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 32 * (1 << 16),
      100, 0, 0, 24, 0}, 
        {87, 0, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 32 * (1 << 16),
      100, 0, 0, 24, 0}, 
        {-1, 787, 1000, 0, 94, 8, 0, 0, 0, 0, 0, 0, 0, 0, 17, 10 * (1 << 16), 6 * (1 << 16),
      32 * (1 << 16), 100, 3, 0, 71184, 0}, 
        {-1, 791, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 528, 0}, 
        {2035, 806, 20, 0, 0, 8, 0, 0, 0, 0, 0, 0, 808, 0, 82, 0, 10 * (1 << 16), 42 * (1 << 16),
      100, 0, 0, 524294, 0}, 
        {-1, 97, 1000, 0, 16, 8, 0, 0, 0, 0, 0, 0, 99, 0, 17, 10 * (1 << 16), 6 * (1 << 16),
      8 * (1 << 16), 100, 3, 0, 67088, 0}, 
        {-1, 102, 1000, 0, 16, 8, 0, 0, 0, 0, 0, 0, 104, 0, 17, 10 * (1 << 16), 6 * (1 << 16),
      8 * (1 << 16), 100, 5, 0, 67088, 0}, 
        {-1, 114, 1000, 0, 14, 8, 0, 0, 0, 0, 0, 0, 127, 0, 82, 20 * (1 << 16), 11 * (1 << 16),
      8 * (1 << 16), 100, 20, 0, 67088, 0}, 
        {-1, 107, 1000, 0, 8, 8, 0, 0, 0, 0, 0, 0, 109, 0, 17, 25 * (1 << 16), 13 * (1 << 16),
      8 * (1 << 16), 100, 5, 0, 67088, 0}, 
        {-1, 115, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 117, 0, 15, 25 * (1 << 16), 13 * (1 << 16),
      8 * (1 << 16), 100, 100, 0, 67088, 0}, 
        {-1, 667, 1000, 0, 8, 8, 0, 0, 0, 0, 0, 0, 669, 0, 17, 25 * (1 << 16), 13 * (1 << 16),
      8 * (1 << 16), 100, 5, 0, 67088, 0}, 
        {-1, 93, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 528, 0}, 
        {-1, 90, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 16, 0}, 
        {-1, 130, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 528, 0}, 
        {-1, 142, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 528, 0}, 
        {14, 0, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 24, 0}, 
        {-1, 123, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 528, 0}, 
        {2018, 802, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2019, 804, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2014, 816, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 8388609, 0}, 
        {2015, 822, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 8388609, 0}, 
        {5, 828, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 33554433, 0}, 
        {13, 830, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 33554433, 0}, 
        {6, 832, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 33554433, 0}, 
        {39, 838, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 33554433, 0}, 
        {38, 836, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 33554433, 0}, 
        {40, 834, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 33554433, 0}, 
        {2011, 840, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2012, 841, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2013, 842, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 8388609, 0}, 
        {2022, 848, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 8388609, 0}, 
        {2023, 852, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 8388609, 0}, 
        {2024, 853, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 8388609, 0}, 
        {2025, 861, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2026, 862, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 8388609, 0}, 
        {2045, 868, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 8388609, 0}, 
        {83, 857, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 8388609, 0}, 
        {2007, 870, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2048, 871, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2010, 872, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2046, 873, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2047, 874, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {17, 875, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2008, 876, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2049, 877, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {8, 878, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2006, 879, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2002, 880, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2005, 881, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2003, 882, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2004, 883, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {2001, 884, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {82, 885, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 1, 0}, 
        {85, 959, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {86, 963, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {2028, 886, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {30, 907, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {31, 908, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {32, 909, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {33, 910, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {37, 913, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {36, 924, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {41, 917, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {42, 921, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {43, 914, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {44, 926, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {45, 930, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {46, 934, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {55, 938, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {56, 942, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {57, 946, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {47, 906, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {48, 916, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {34, 911, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 0, 0}, 
        {35, 912, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {49, 888, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 68 * (1 << 16),
      100, 0, 0, 770, 0}, 
        {50, 902, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 84 * (1 << 16),
      100, 0, 0, 770, 0}, 
        {51, 903, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 84 * (1 << 16),
      100, 0, 0, 770, 0}, 
        {52, 904, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 68 * (1 << 16),
      100, 0, 0, 770, 0}, 
        {53, 905, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 52 * (1 << 16),
      100, 0, 0, 770, 0}, 
        {59, 902, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 84 * (1 << 16),
      100, 0, 0, 768, 0}, 
        {60, 904, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 68 * (1 << 16),
      100, 0, 0, 768, 0}, 
        {61, 903, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 52 * (1 << 16),
      100, 0, 0, 768, 0}, 
        {62, 905, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 52 * (1 << 16),
      100, 0, 0, 768, 0}, 
        {63, 888, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 68 * (1 << 16),
      100, 0, 0, 768, 0}, 
        {22, 515, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 0, 0}, 
        {15, 164, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 0, 0}, 
        {18, 193, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 0, 0}, 
        {21, 495, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 0, 0}, 
        {23, 600, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 0, 0}, 
        {20, 461, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 0, 0}, 
        {19, 226, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 0, 0}, 
        {10, 173, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 0, 0}, 
        {12, 173, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 0, 0}, 
        {28, 894, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {24, 895, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 0, 0}, 
        {27, 896, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {29, 897, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {25, 899, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {26, 900, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {54, 915, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {70, 813, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 2, 0}, 
        {73, 950, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 88 * (1 << 16),
      100, 0, 0, 770, 0}, 
        {74, 951, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 88 * (1 << 16),
      100, 0, 0, 770, 0}, 
        {75, 952, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 64 * (1 << 16),
      100, 0, 0, 770, 0}, 
        {76, 953, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 64 * (1 << 16),
      100, 0, 0, 770, 0}, 
        {77, 954, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 64 * (1 << 16),
      100, 0, 0, 770, 0}, 
        {78, 955, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 * (1 << 16), 64 * (1 << 16),
      100, 0, 0, 770, 0}, 
        {79, 956, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 16, 0}, 
        {80, 957, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 16, 0}, 
        {81, 958, 1000, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 * (1 << 16), 16 * (1 << 16),
      100, 0, 0, 16, 0}};
#line 26 "sounds.c"
static char const   rcsid___59[49]  = 
#line 26 "sounds.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'d',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'3',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'1',      (char const   )'/', 
        (char const   )'2',      (char const   )'9',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'4',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 37 "sounds.c"
musicinfo_t S_music[68]  = 
#line 37
  {      {(char *)0, 0, (void *)0, 0}, 
        {"e1m1", 0, (void *)0, 0}, 
        {"e1m2", 0, (void *)0, 0}, 
        {"e1m3", 0, (void *)0, 0}, 
        {"e1m4", 0, (void *)0, 0}, 
        {"e1m5", 0, (void *)0, 0}, 
        {"e1m6", 0, (void *)0, 0}, 
        {"e1m7", 0, (void *)0, 0}, 
        {"e1m8", 0, (void *)0, 0}, 
        {"e1m9", 0, (void *)0, 0}, 
        {"e2m1", 0, (void *)0, 0}, 
        {"e2m2", 0, (void *)0, 0}, 
        {"e2m3", 0, (void *)0, 0}, 
        {"e2m4", 0, (void *)0, 0}, 
        {"e2m5", 0, (void *)0, 0}, 
        {"e2m6", 0, (void *)0, 0}, 
        {"e2m7", 0, (void *)0, 0}, 
        {"e2m8", 0, (void *)0, 0}, 
        {"e2m9", 0, (void *)0, 0}, 
        {"e3m1", 0, (void *)0, 0}, 
        {"e3m2", 0, (void *)0, 0}, 
        {"e3m3", 0, (void *)0, 0}, 
        {"e3m4", 0, (void *)0, 0}, 
        {"e3m5", 0, (void *)0, 0}, 
        {"e3m6", 0, (void *)0, 0}, 
        {"e3m7", 0, (void *)0, 0}, 
        {"e3m8", 0, (void *)0, 0}, 
        {"e3m9", 0, (void *)0, 0}, 
        {"inter", 0, (void *)0, 0}, 
        {"intro", 0, (void *)0, 0}, 
        {"bunny", 0, (void *)0, 0}, 
        {"victor", 0, (void *)0, 0}, 
        {"introa", 0, (void *)0, 0}, 
        {"runnin", 0, (void *)0, 0}, 
        {"stalks", 0, (void *)0, 0}, 
        {"countd", 0, (void *)0, 0}, 
        {"betwee", 0, (void *)0, 0}, 
        {"doom", 0, (void *)0, 0}, 
        {"the_da", 0, (void *)0, 0}, 
        {"shawn", 0, (void *)0, 0}, 
        {"ddtblu", 0, (void *)0, 0}, 
        {"in_cit", 0, (void *)0, 0}, 
        {"dead", 0, (void *)0, 0}, 
        {"stlks2", 0, (void *)0, 0}, 
        {"theda2", 0, (void *)0, 0}, 
        {"doom2", 0, (void *)0, 0}, 
        {"ddtbl2", 0, (void *)0, 0}, 
        {"runni2", 0, (void *)0, 0}, 
        {"dead2", 0, (void *)0, 0}, 
        {"stlks3", 0, (void *)0, 0}, 
        {"romero", 0, (void *)0, 0}, 
        {"shawn2", 0, (void *)0, 0}, 
        {"messag", 0, (void *)0, 0}, 
        {"count2", 0, (void *)0, 0}, 
        {"ddtbl3", 0, (void *)0, 0}, 
        {"ampie", 0, (void *)0, 0}, 
        {"theda3", 0, (void *)0, 0}, 
        {"adrian", 0, (void *)0, 0}, 
        {"messg2", 0, (void *)0, 0}, 
        {"romer2", 0, (void *)0, 0}, 
        {"tense", 0, (void *)0, 0}, 
        {"shawn3", 0, (void *)0, 0}, 
        {"openin", 0, (void *)0, 0}, 
        {"evil", 0, (void *)0, 0}, 
        {"ultima", 0, (void *)0, 0}, 
        {"read_m", 0, (void *)0, 0}, 
        {"dm2ttl", 0, (void *)0, 0}, 
        {"dm2int", 0, (void *)0, 0}};
#line 114 "sounds.c"
sfxinfo_t S_sfx[109]  = 
#line 114
  {      {"none", 0, 0, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"pistol", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"shotgn", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"sgcock", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"dshtgn", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"dbopn", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"dbcls", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"dbload", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"plasma", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bfg", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"sawup", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"sawidl", 0, 118, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"sawful", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"sawhit", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"rlaunc", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"rxplod", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"firsht", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"firxpl", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"pstart", 0, 100, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"pstop", 0, 100, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"doropn", 0, 100, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"dorcls", 0, 100, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"stnmov", 0, 119, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"swtchn", 0, 78, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"swtchx", 0, 78, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"plpain", 0, 96, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"dmpain", 0, 96, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"popain", 0, 96, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"vipain", 0, 96, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"mnpain", 0, 96, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"pepain", 0, 96, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"slop", 0, 78, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"itemup", 1, 78, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"wpnup", 1, 78, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"oof", 0, 96, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"telept", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"posit1", 1, 98, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"posit2", 1, 98, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"posit3", 1, 98, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bgsit1", 1, 98, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bgsit2", 1, 98, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"sgtsit", 1, 98, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"cacsit", 1, 98, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"brssit", 1, 94, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"cybsit", 1, 92, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"spisit", 1, 90, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bspsit", 1, 90, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"kntsit", 1, 90, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"vilsit", 1, 90, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"mansit", 1, 90, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"pesit", 1, 90, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"sklatk", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"sgtatk", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"skepch", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"vilatk", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"claw", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"skeswg", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"pldeth", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"pdiehi", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"podth1", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"podth2", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"podth3", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bgdth1", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bgdth2", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"sgtdth", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"cacdth", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"skldth", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"brsdth", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"cybdth", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"spidth", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bspdth", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"vildth", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"kntdth", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"pedth", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"skedth", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"posact", 1, 120, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bgact", 1, 120, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"dmact", 1, 120, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bspact", 1, 100, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bspwlk", 1, 100, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"vilact", 1, 100, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"noway", 0, 78, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"barexp", 0, 60, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"punch", 0, 64, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"hoof", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"metal", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"chgun", 0, 64, & S_sfx[1], 150, 0, (void *)0, 0, 0}, 
        {"tink", 0, 60, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bdopn", 0, 100, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bdcls", 0, 100, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"itmbk", 0, 100, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"flame", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"flamst", 0, 32, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"getpow", 0, 60, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bospit", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"boscub", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bossit", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bospn", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"bosdth", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"manatk", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"mandth", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"sssit", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"ssdth", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"keenpn", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"keendt", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"skeact", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"skesit", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"skeatk", 0, 70, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}, 
        {"radio", 0, 60, (sfxinfo_t *)0, -1, -1, (void *)0, 0, 0}};
#line 24 "i_main.c"
static char const   rcsid___60[49]  = 
#line 24 "i_main.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'i',      (char const   )'_',      (char const   )'m', 
        (char const   )'a',      (char const   )'i',      (char const   )'n',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'4',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'7', 
        (char const   )'/',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'2',      (char const   )':',      (char const   )'4',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'b',      (char const   )'1',      (char const   )' ',      (char const   )'E', 
        (char const   )'x',      (char const   )'p',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 34 "i_main.c"
int main(int argc , char **argv ) 
{ 


  {
#line 39
  myargc = argc;
#line 40
  myargv = argv;
#line 42
  D_DoomMain();
#line 44
  return (0);
}
}
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern int ( __attribute__((__leaf__)) __sched_cpucount)(size_t___0 __setsize , cpu_set_t const   *__setp )  __attribute__((__nothrow__)) ;
#line 119
extern cpu_set_t *( __attribute__((__leaf__)) __sched_cpualloc)(size_t___0 __count )  __attribute__((__nothrow__)) ;
#line 120
extern void ( __attribute__((__leaf__)) __sched_cpufree)(cpu_set_t *__set )  __attribute__((__nothrow__)) ;
#line 54 "/usr/include/sched.h"
extern int ( __attribute__((__leaf__)) sched_setparam)(__pid_t __pid , struct sched_param  const  *__param )  __attribute__((__nothrow__)) ;
#line 58
extern int ( __attribute__((__leaf__)) sched_getparam)(__pid_t __pid , struct sched_param *__param )  __attribute__((__nothrow__)) ;
#line 61
extern int ( __attribute__((__leaf__)) sched_setscheduler)(__pid_t __pid , int __policy ,
                                                           struct sched_param  const  *__param )  __attribute__((__nothrow__)) ;
#line 65
extern int ( __attribute__((__leaf__)) sched_getscheduler)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 68
extern int ( __attribute__((__leaf__)) sched_yield)(void)  __attribute__((__nothrow__)) ;
#line 71
extern int ( __attribute__((__leaf__)) sched_get_priority_max)(int __algorithm )  __attribute__((__nothrow__)) ;
#line 74
extern int ( __attribute__((__leaf__)) sched_get_priority_min)(int __algorithm )  __attribute__((__nothrow__)) ;
#line 78
extern int ( __attribute__((__leaf__)) sched_rr_get_interval)(__pid_t __pid , struct timespec *__t )  __attribute__((__nothrow__)) ;
#line 383 "/usr/include/time.h"
extern int ( __attribute__((__nonnull__(1), __leaf__)) timespec_get)(struct timespec *__ts ,
                                                                     int __base )  __attribute__((__nothrow__)) ;
#line 202 "/usr/include/pthread.h"
extern int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                               pthread_attr_t___0 const   * __restrict  __attr ,
                                                               void *(*__start_routine)(void * ) ,
                                                               void * __restrict  __arg )  __attribute__((__nothrow__)) ;
#line 211
extern void pthread_exit(void *__retval )  __attribute__((__noreturn__)) ;
#line 219
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 269
extern int ( __attribute__((__leaf__)) pthread_detach)(pthread_t __th )  __attribute__((__nothrow__)) ;
#line 273
extern pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 276
extern int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 , pthread_t __thread2 )  __attribute__((__nothrow__,
__const__)) ;
#line 285
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t___0 *__attr )  __attribute__((__nothrow__)) ;
#line 288
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_destroy)(pthread_attr_t___0 *__attr )  __attribute__((__nothrow__)) ;
#line 292
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getdetachstate)(pthread_attr_t___0 const   *__attr ,
                                                                                      int *__detachstate )  __attribute__((__nothrow__)) ;
#line 297
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t___0 *__attr ,
                                                                                    int __detachstate )  __attribute__((__nothrow__)) ;
#line 303
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getguardsize)(pthread_attr_t___0 const   *__attr ,
                                                                                    size_t___0 *__guardsize )  __attribute__((__nothrow__)) ;
#line 308
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setguardsize)(pthread_attr_t___0 *__attr ,
                                                                                  size_t___0 __guardsize )  __attribute__((__nothrow__)) ;
#line 314
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedparam)(pthread_attr_t___0 const   * __restrict  __attr ,
                                                                                     struct sched_param * __restrict  __param )  __attribute__((__nothrow__)) ;
#line 319
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_setschedparam)(pthread_attr_t___0 * __restrict  __attr ,
                                                                                     struct sched_param  const  * __restrict  __param )  __attribute__((__nothrow__)) ;
#line 324
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedpolicy)(pthread_attr_t___0 const   * __restrict  __attr ,
                                                                                      int * __restrict  __policy )  __attribute__((__nothrow__)) ;
#line 329
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setschedpolicy)(pthread_attr_t___0 *__attr ,
                                                                                    int __policy )  __attribute__((__nothrow__)) ;
#line 333
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getinheritsched)(pthread_attr_t___0 const   * __restrict  __attr ,
                                                                                       int * __restrict  __inherit )  __attribute__((__nothrow__)) ;
#line 338
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setinheritsched)(pthread_attr_t___0 *__attr ,
                                                                                     int __inherit )  __attribute__((__nothrow__)) ;
#line 344
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getscope)(pthread_attr_t___0 const   * __restrict  __attr ,
                                                                                int * __restrict  __scope )  __attribute__((__nothrow__)) ;
#line 349
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setscope)(pthread_attr_t___0 *__attr ,
                                                                              int __scope )  __attribute__((__nothrow__)) ;
#line 353
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getstackaddr)(pthread_attr_t___0 const   * __restrict  __attr ,
                                                                                    void ** __restrict  __stackaddr )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 361
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstackaddr)(pthread_attr_t___0 *__attr ,
                                                                                  void *__stackaddr )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 366
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getstacksize)(pthread_attr_t___0 const   * __restrict  __attr ,
                                                                                    size_t___0 * __restrict  __stacksize )  __attribute__((__nothrow__)) ;
#line 373
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstacksize)(pthread_attr_t___0 *__attr ,
                                                                                  size_t___0 __stacksize )  __attribute__((__nothrow__)) ;
#line 379
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) pthread_attr_getstack)(pthread_attr_t___0 const   * __restrict  __attr ,
                                                                                  void ** __restrict  __stackaddr ,
                                                                                  size_t___0 * __restrict  __stacksize )  __attribute__((__nothrow__)) ;
#line 387
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstack)(pthread_attr_t___0 *__attr ,
                                                                              void *__stackaddr ,
                                                                              size_t___0 __stacksize )  __attribute__((__nothrow__)) ;
#line 441
extern int ( __attribute__((__nonnull__(3), __leaf__)) pthread_setschedparam)(pthread_t __target_thread ,
                                                                              int __policy ,
                                                                              struct sched_param  const  *__param )  __attribute__((__nothrow__)) ;
#line 446
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) pthread_getschedparam)(pthread_t __target_thread ,
                                                                                int * __restrict  __policy ,
                                                                                struct sched_param * __restrict  __param )  __attribute__((__nothrow__)) ;
#line 452
extern int ( __attribute__((__leaf__)) pthread_setschedprio)(pthread_t __target_thread ,
                                                             int __prio )  __attribute__((__nothrow__)) ;
#line 509
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) )  __attribute__((__goblint_stub__)) ;
#line 521
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 525
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 528
extern int pthread_cancel(pthread_t __th ) ;
#line 533
extern void pthread_testcancel(void) ;
#line 697
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 750
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__,
__noreturn__)) ;
#line 766
extern int __sigsetjmp_cancel(struct __cancel_jmp_buf_tag *__env , int __savemask )  __asm__("__sigsetjmp") __attribute__((__returns_twice__,
__nothrow__)) ;
#line 781
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t___0 *__mutex ,
                                                                           pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nothrow__)) ;
#line 786
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t___0 *__mutex )  __attribute__((__nothrow__)) ;
#line 790
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t___0 *__mutex )  __attribute__((__nothrow__)) ;
#line 794
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t___0 *__mutex )  __attribute__((__nothrow__)) ;
#line 800
extern int ( __attribute__((__nonnull__(1,2))) pthread_mutex_timedlock)(pthread_mutex_t___0 * __restrict  __mutex ,
                                                                        struct timespec  const  * __restrict  __abstime )  __attribute__((__nothrow__)) ;
#line 835
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t___0 *__mutex )  __attribute__((__nothrow__)) ;
#line 840
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutex_getprioceiling)(pthread_mutex_t___0 const   * __restrict  __mutex ,
                                                                                       int * __restrict  __prioceiling )  __attribute__((__nothrow__)) ;
#line 847
extern int ( __attribute__((__nonnull__(1,3), __leaf__)) pthread_mutex_setprioceiling)(pthread_mutex_t___0 * __restrict  __mutex ,
                                                                                       int __prioceiling ,
                                                                                       int * __restrict  __old_ceiling )  __attribute__((__nothrow__)) ;
#line 855
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_consistent)(pthread_mutex_t___0 *__mutex )  __attribute__((__nothrow__)) ;
#line 874
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_init)(pthread_mutexattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 878
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 882
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getpshared)(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                                       int * __restrict  __pshared )  __attribute__((__nothrow__)) ;
#line 888
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setpshared)(pthread_mutexattr_t *__attr ,
                                                                                     int __pshared )  __attribute__((__nothrow__)) ;
#line 894
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_gettype)(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                                    int * __restrict  __kind )  __attribute__((__nothrow__)) ;
#line 901
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                  int __kind )  __attribute__((__nothrow__)) ;
#line 906
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getprotocol)(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                                        int * __restrict  __protocol )  __attribute__((__nothrow__)) ;
#line 913
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setprotocol)(pthread_mutexattr_t *__attr ,
                                                                                      int __protocol )  __attribute__((__nothrow__)) ;
#line 918
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getprioceiling)(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                                           int * __restrict  __prioceiling )  __attribute__((__nothrow__)) ;
#line 924
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setprioceiling)(pthread_mutexattr_t *__attr ,
                                                                                         int __prioceiling )  __attribute__((__nothrow__)) ;
#line 930
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getrobust)(pthread_mutexattr_t const   *__attr ,
                                                                                      int *__robustness )  __attribute__((__nothrow__)) ;
#line 946
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setrobust)(pthread_mutexattr_t *__attr ,
                                                                                    int __robustness )  __attribute__((__nothrow__)) ;
#line 967
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_init)(pthread_rwlock_t___0 * __restrict  __rwlock ,
                                                                            pthread_rwlockattr_t const   * __restrict  __attr )  __attribute__((__nothrow__)) ;
#line 972
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_destroy)(pthread_rwlock_t___0 *__rwlock )  __attribute__((__nothrow__)) ;
#line 976
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_rdlock)(pthread_rwlock_t___0 *__rwlock )  __attribute__((__nothrow__)) ;
#line 980
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_tryrdlock)(pthread_rwlock_t___0 *__rwlock )  __attribute__((__nothrow__)) ;
#line 986
extern int ( __attribute__((__nonnull__(1,2))) pthread_rwlock_timedrdlock)(pthread_rwlock_t___0 * __restrict  __rwlock ,
                                                                           struct timespec  const  * __restrict  __abstime )  __attribute__((__nothrow__)) ;
#line 1023
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_wrlock)(pthread_rwlock_t___0 *__rwlock )  __attribute__((__nothrow__)) ;
#line 1027
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_trywrlock)(pthread_rwlock_t___0 *__rwlock )  __attribute__((__nothrow__)) ;
#line 1033
extern int ( __attribute__((__nonnull__(1,2))) pthread_rwlock_timedwrlock)(pthread_rwlock_t___0 * __restrict  __rwlock ,
                                                                           struct timespec  const  * __restrict  __abstime )  __attribute__((__nothrow__)) ;
#line 1071
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_unlock)(pthread_rwlock_t___0 *__rwlock )  __attribute__((__nothrow__)) ;
#line 1078
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_init)(pthread_rwlockattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1082
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_destroy)(pthread_rwlockattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1086
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_rwlockattr_getpshared)(pthread_rwlockattr_t const   * __restrict  __attr ,
                                                                                        int * __restrict  __pshared )  __attribute__((__nothrow__)) ;
#line 1092
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setpshared)(pthread_rwlockattr_t *__attr ,
                                                                                      int __pshared )  __attribute__((__nothrow__)) ;
#line 1097
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_rwlockattr_getkind_np)(pthread_rwlockattr_t const   * __restrict  __attr ,
                                                                                        int * __restrict  __pref )  __attribute__((__nothrow__)) ;
#line 1103
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setkind_np)(pthread_rwlockattr_t *__attr ,
                                                                                      int __pref )  __attribute__((__nothrow__)) ;
#line 1112
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                          pthread_condattr_t const   * __restrict  __cond_attr )  __attribute__((__nothrow__)) ;
#line 1117
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 1121
extern int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 1125
extern int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 1133
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t___0 * __restrict  __mutex ) ;
#line 1145
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t___0 * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
#line 1194
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_init)(pthread_condattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1198
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_destroy)(pthread_condattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1202
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_condattr_getpshared)(pthread_condattr_t const   * __restrict  __attr ,
                                                                                      int * __restrict  __pshared )  __attribute__((__nothrow__)) ;
#line 1208
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_setpshared)(pthread_condattr_t *__attr ,
                                                                                    int __pshared )  __attribute__((__nothrow__)) ;
#line 1213
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_condattr_getclock)(pthread_condattr_t const   * __restrict  __attr ,
                                                                                    __clockid_t * __restrict  __clock_id )  __attribute__((__nothrow__)) ;
#line 1219
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_setclock)(pthread_condattr_t *__attr ,
                                                                                  __clockid_t __clock_id )  __attribute__((__nothrow__)) ;
#line 1230
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_spin_init)(pthread_spinlock_t *__lock ,
                                                                          int __pshared )  __attribute__((__nothrow__)) ;
#line 1234
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_spin_destroy)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1238
extern int ( __attribute__((__nonnull__(1))) pthread_spin_lock)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1242
extern int ( __attribute__((__nonnull__(1))) pthread_spin_trylock)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1246
extern int ( __attribute__((__nonnull__(1))) pthread_spin_unlock)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1254
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrier_init)(pthread_barrier_t___0 * __restrict  __barrier ,
                                                                             pthread_barrierattr_t const   * __restrict  __attr ,
                                                                             unsigned int __count )  __attribute__((__nothrow__)) ;
#line 1260
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrier_destroy)(pthread_barrier_t___0 *__barrier )  __attribute__((__nothrow__)) ;
#line 1264
extern int ( __attribute__((__nonnull__(1))) pthread_barrier_wait)(pthread_barrier_t___0 *__barrier )  __attribute__((__nothrow__)) ;
#line 1269
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_init)(pthread_barrierattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1273
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_destroy)(pthread_barrierattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1277
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_barrierattr_getpshared)(pthread_barrierattr_t const   * __restrict  __attr ,
                                                                                         int * __restrict  __pshared )  __attribute__((__nothrow__)) ;
#line 1283
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_setpshared)(pthread_barrierattr_t *__attr ,
                                                                                       int __pshared )  __attribute__((__nothrow__)) ;
#line 1297
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_key_create)(pthread_key_t *__key ,
                                                                           void (*__destr_function)(void * ) )  __attribute__((__nothrow__)) ;
#line 1302
extern int ( __attribute__((__leaf__)) pthread_key_delete)(pthread_key_t __key )  __attribute__((__nothrow__)) ;
#line 1305
extern void *( __attribute__((__leaf__)) pthread_getspecific)(pthread_key_t __key )  __attribute__((__nothrow__)) ;
#line 1308
extern int ( __attribute__((__leaf__)) pthread_setspecific)(pthread_key_t __key ,
                                                            void const   *__pointer )  __attribute__((__nothrow__,
__access__(__none__,2))) ;
#line 1315
extern int ( __attribute__((__nonnull__(2), __leaf__)) pthread_getcpuclockid)(pthread_t __thread_id ,
                                                                              __clockid_t *__clock_id )  __attribute__((__nothrow__)) ;
#line 1332
extern int ( __attribute__((__leaf__)) pthread_atfork)(void (*__prepare)(void) , void (*__parent)(void) ,
                                                       void (*__child)(void) )  __attribute__((__nothrow__)) ;
#line 5 "/home/petter/repositories/goblint/lib/libc/stub/src/pthread.c"
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) )  __attribute__((__goblint_stub__)) ;
#line 5 "/home/petter/repositories/goblint/lib/libc/stub/src/pthread.c"
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) ) 
{ 
  int top ;

  {
#line 8
  (*init_routine)();
#line 9
  return (top);
}
}
#line 7 "/home/petter/repositories/goblint/lib/libc/stub/src/stdlib.c"
void qsort(void *ptr , size_t___0 count , size_t___0 size , int (*comp)(void const   * ,
                                                                        void const   * ) )  __attribute__((__goblint_stub__)) ;
#line 7 "/home/petter/repositories/goblint/lib/libc/stub/src/stdlib.c"
void qsort(void *ptr , size_t___0 count , size_t___0 size , int (*comp)(void const   * ,
                                                                        void const   * ) ) 
{ 
  size_t___0 i ;
  size_t___0 j ;
  size_t___0 i___0 ;
  size_t___0 j___0 ;
  int r ;
  size_t___0 k ;
  char *a ;
  char *b ;
  char c ;

  {
#line 9
  i = (size_t___0 )0;
  {
#line 9
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9
    if (! (i < count)) {
#line 9
      goto while_break;
    }
#line 10
    j = (size_t___0 )0;
    {
#line 10
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10
      if (! (j < count)) {
#line 10
        goto while_break___0;
      }
#line 11
      (*comp)((void const   *)(ptr + i * size), (void const   *)(ptr + j * size));
#line 10
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 9
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 16
  i___0 = (size_t___0 )0;
  {
#line 16
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 16
    if (! (i___0 < count)) {
#line 16
      goto while_break___1;
    }
#line 17
    j___0 = (size_t___0 )0;
    {
#line 17
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 17
      if (! (j___0 < count)) {
#line 17
        goto while_break___2;
      }
#line 19
      if (r) {
#line 21
        k = (size_t___0 )0;
        {
#line 21
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 21
          if (! (k < size)) {
#line 21
            goto while_break___3;
          }
#line 22
          a = (char *)((ptr + i___0 * size) + k);
#line 23
          b = (char *)((ptr + j___0 * size) + k);
#line 24
          c = *a;
#line 25
          *a = *b;
#line 26
          *b = c;
#line 21
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 17
      j___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 16
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 33
  return;
}
}
#line 38
void *bsearch(void const   *key , void const   *ptr , size_t___0 count , size_t___0 size ,
              int (*comp)(void const   * , void const   * ) )  __attribute__((__goblint_stub__)) ;
#line 38 "/home/petter/repositories/goblint/lib/libc/stub/src/stdlib.c"
void *bsearch(void const   *key , void const   *ptr , size_t___0 count , size_t___0 size ,
              int (*comp)(void const   * , void const   * ) ) 
{ 
  size_t___0 i ;
  void const   *a ;
  int tmp ;

  {
#line 40
  i = (size_t___0 )0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < count)) {
#line 40
      goto while_break;
    }
#line 41
    a = ptr + i * size;
#line 42
    tmp = (*comp)(key, a);
#line 42
    if (tmp == 0) {
#line 43
      return ((void *)a);
    }
#line 40
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return ((void *)0);
}
}
