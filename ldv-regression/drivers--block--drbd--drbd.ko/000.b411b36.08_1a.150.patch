1853a1854,1858
> #line 12 "include/uapi/linux/socket.h"
> struct __kernel_sockaddr_storage {
>    __kernel_sa_family_t ss_family ;
>    char __data[126U] ;
> };
2099,2104d2103
< #line 217 "include/linux/capability.h"
< struct semaphore {
<    raw_spinlock_t lock ;
<    unsigned int count ;
<    struct list_head wait_list ;
< };
5927c5926,5960
< #line 189 "include/linux/drbd.h"
---
> #line 55 "include/linux/drbd.h"
> enum drbd_io_error_p {
>     EP_PASS_ON = 0,
>     EP_CALL_HELPER = 1,
>     EP_DETACH = 2
> } ;
> #line 183
> enum drbd_conns {
>     C_STANDALONE = 0,
>     C_DISCONNECTING = 1,
>     C_UNCONNECTED = 2,
>     C_TIMEOUT = 3,
>     C_BROKEN_PIPE = 4,
>     C_NETWORK_FAILURE = 5,
>     C_PROTOCOL_ERROR = 6,
>     C_TEAR_DOWN = 7,
>     C_WF_CONNECTION = 8,
>     C_WF_REPORT_PARAMS = 9,
>     C_CONNECTED = 10,
>     C_STARTING_SYNC_S = 11,
>     C_STARTING_SYNC_T = 12,
>     C_WF_BITMAP_S = 13,
>     C_WF_BITMAP_T = 14,
>     C_WF_SYNC_UUID = 15,
>     C_SYNC_SOURCE = 16,
>     C_SYNC_TARGET = 17,
>     C_VERIFY_S = 18,
>     C_VERIFY_T = 19,
>     C_PAUSED_SYNC_S = 20,
>     C_PAUSED_SYNC_T = 21,
>     C_AHEAD = 22,
>     C_BEHIND = 23,
>     C_MASK = 31
> } ;
> #line 211
5940,5941c5973,5974
< #line 202 "include/linux/drbd.h"
< struct __anonstruct_ldv_40583_232 {
---
> #line 224 "include/linux/drbd.h"
> struct __anonstruct_ldv_40604_232 {
5955c5988
< #line 202 "include/linux/drbd.h"
---
> #line 224 "include/linux/drbd.h"
5957c5990
<    struct __anonstruct_ldv_40583_232 ldv_40583 ;
---
>    struct __anonstruct_ldv_40604_232 ldv_40604 ;
5960c5993
< #line 274
---
> #line 296
5985c6018,6019
<     SS_AFTER_LAST_ERROR = -20
---
>     SS_O_VOL_PEER_PRI = -20,
>     SS_AFTER_LAST_ERROR = -21
5987c6021
< #line 368
---
> #line 346
5989c6023
< #line 369
---
> #line 347
5991c6025
< #line 370
---
> #line 348
5993c6027
< #line 371
---
> #line 349
5995c6029
< #line 372
---
> #line 350
5997c6031
< #line 373
---
> #line 351
5999c6033
< #line 374
---
> #line 352
6001c6035
< #line 375
---
> #line 353
6003c6037
< #line 376
---
> #line 354
6005c6039
< #line 377
---
> #line 355
6425c6459
< union __anonunion_ldv_44022_241 {
---
> union __anonunion_ldv_44034_241 {
6430c6464
< union __anonunion_ldv_44026_242 {
---
> union __anonunion_ldv_44038_242 {
6438,6439c6472,6473
<    union __anonunion_ldv_44022_241 ldv_44022 ;
<    union __anonunion_ldv_44026_242 ldv_44026 ;
---
>    union __anonunion_ldv_44034_241 ldv_44034 ;
>    union __anonunion_ldv_44038_242 ldv_44038 ;
6526c6560
< union __anonunion_ldv_44473_243 {
---
> union __anonunion_ldv_44485_243 {
6542c6576
< union __anonunion_ldv_44484_244 {
---
> union __anonunion_ldv_44496_244 {
6560,6561c6594,6595
<    union __anonunion_ldv_44473_243 ldv_44473 ;
<    union __anonunion_ldv_44484_244 ldv_44484 ;
---
>    union __anonunion_ldv_44485_243 ldv_44485 ;
>    union __anonunion_ldv_44496_244 ldv_44496 ;
6974c7008
< union __anonunion_ldv_47140_253 {
---
> union __anonunion_ldv_47152_253 {
6980c7014
<    union __anonunion_ldv_47140_253 ldv_47140 ;
---
>    union __anonunion_ldv_47152_253 ldv_47152 ;
6988c7022
< union __anonunion_ldv_47155_254 {
---
> union __anonunion_ldv_47167_254 {
6993c7027
< struct __anonstruct_ldv_47160_256 {
---
> struct __anonstruct_ldv_47172_256 {
6998,6999c7032,7033
< union __anonunion_ldv_47163_255 {
<    struct __anonstruct_ldv_47160_256 ldv_47160 ;
---
> union __anonunion_ldv_47175_255 {
>    struct __anonstruct_ldv_47172_256 ldv_47172 ;
7012,7013c7046,7047
<    union __anonunion_ldv_47155_254 ldv_47155 ;
<    union __anonunion_ldv_47163_255 ldv_47163 ;
---
>    union __anonunion_ldv_47167_254 ldv_47167 ;
>    union __anonunion_ldv_47175_255 ldv_47175 ;
7070a7105
>    unsigned int lc_new_number ;
7072c7107
< #line 170 "include/linux/lru_cache.h"
---
> #line 175 "include/linux/lru_cache.h"
7076a7112
>    struct list_head to_be_changed ;
7080a7117,7118
>    unsigned int max_pending_changes ;
>    unsigned int pending_changes ;
7085c7123
<    unsigned long dirty ;
---
>    unsigned long locked ;
7088,7089d7125
<    unsigned int new_number ;
<    struct lc_element *changing_element ;
7095,7166c7131,7162
< #line 73 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct drbd_conf;
< #line 315 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_header80 {
<    u32 magic ;
<    u16 command ;
<    u16 length ;
<    u8 payload[0U] ;
< };
< #line 342 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_header95 {
<    u16 magic ;
<    u16 command ;
<    u32 length ;
<    u8 payload[0U] ;
< };
< #line 350 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< union p_header {
<    struct p_header80 h80 ;
<    struct p_header95 h95 ;
< };
< #line 355 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_data {
<    union p_header head ;
<    u64 sector ;
<    u64 block_id ;
<    u32 seq_num ;
<    u32 dp_flags ;
< };
< #line 388 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_block_ack {
<    struct p_header80 head ;
<    u64 sector ;
<    u64 block_id ;
<    u32 blksize ;
<    u32 seq_num ;
< };
< #line 404 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_block_req {
<    struct p_header80 head ;
<    u64 sector ;
<    u64 block_id ;
<    u32 blksize ;
<    u32 pad ;
< };
< #line 413 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_handshake {
<    struct p_header80 head ;
<    u32 protocol_min ;
<    u32 feature_flags ;
<    u32 protocol_max ;
<    u32 _pad ;
<    u64 reserverd[7U] ;
< };
< #line 436 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_barrier {
<    struct p_header80 head ;
<    u32 barrier ;
<    u32 pad ;
< };
< #line 443 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_barrier_ack {
<    struct p_header80 head ;
<    u32 barrier ;
<    u32 set_size ;
< };
< #line 457 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_rs_param_89 {
<    struct p_header80 head ;
<    u32 rate ;
<    char verify_alg[64U] ;
<    char csums_alg[64U] ;
---
> #line 99 "include/linux/drbd_genl.h"
> struct disk_conf {
>    char backing_dev[128U] ;
>    __u32 backing_dev_len ;
>    char meta_dev[128U] ;
>    __u32 meta_dev_len ;
>    __s32 meta_dev_idx ;
>    __u64 disk_size ;
>    __u32 max_bio_bvecs ;
>    __u32 on_io_error ;
>    __u32 fencing ;
>    __u32 resync_rate ;
>    __s32 resync_after ;
>    __u32 al_extents ;
>    __u32 c_plan_ahead ;
>    __u32 c_delay_target ;
>    __u32 c_fill_target ;
>    __u32 c_max_rate ;
>    __u32 c_min_rate ;
>    char disk_barrier ;
>    char disk_flushes ;
>    char disk_drain ;
>    char md_flushes ;
>    __u32 disk_timeout ;
>    __u32 read_balancing ;
>    char al_updates ;
> };
> #line 106 "include/linux/drbd_genl.h"
> struct res_opts {
>    char cpu_mask[32U] ;
>    __u32 cpu_mask_len ;
>    __u32 on_no_data ;
7168,7171c7164,7171
< #line 465 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_rs_param_95 {
<    struct p_header80 head ;
<    u32 rate ;
---
> #line 139 "include/linux/drbd_genl.h"
> struct net_conf {
>    char shared_secret[64U] ;
>    __u32 shared_secret_len ;
>    char cram_hmac_alg[64U] ;
>    __u32 cram_hmac_alg_len ;
>    char integrity_alg[64U] ;
>    __u32 integrity_alg_len ;
7172a7173
>    __u32 verify_alg_len ;
7174,7231c7175,7199
<    u32 c_plan_ahead ;
<    u32 c_delay_target ;
<    u32 c_fill_target ;
<    u32 c_max_rate ;
< };
< #line 481 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_protocol {
<    struct p_header80 head ;
<    u32 protocol ;
<    u32 after_sb_0p ;
<    u32 after_sb_1p ;
<    u32 after_sb_2p ;
<    u32 conn_flags ;
<    u32 two_primaries ;
<    char integrity_alg[0U] ;
< };
< #line 494 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_uuids {
<    struct p_header80 head ;
<    u64 uuid[6U] ;
< };
< #line 500 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_rs_uuid {
<    struct p_header80 head ;
<    u64 uuid ;
< };
< #line 505 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_sizes {
<    struct p_header80 head ;
<    u64 d_size ;
<    u64 u_size ;
<    u64 c_size ;
<    u32 max_bio_size ;
<    u16 queue_order_type ;
<    u16 dds_flags ;
< };
< #line 515 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_state {
<    struct p_header80 head ;
<    u32 state ;
< };
< #line 520 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_req_state {
<    struct p_header80 head ;
<    u32 mask ;
<    u32 val ;
< };
< #line 526 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_req_state_reply {
<    struct p_header80 head ;
<    u32 retcode ;
< };
< #line 548 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_block_desc {
<    struct p_header80 head ;
<    u64 sector ;
<    u32 blksize ;
<    u32 pad ;
---
>    __u32 csums_alg_len ;
>    __u32 wire_protocol ;
>    __u32 connect_int ;
>    __u32 timeout ;
>    __u32 ping_int ;
>    __u32 ping_timeo ;
>    __u32 sndbuf_size ;
>    __u32 rcvbuf_size ;
>    __u32 ko_count ;
>    __u32 max_buffers ;
>    __u32 max_epoch_size ;
>    __u32 unplug_watermark ;
>    __u32 after_sb_0p ;
>    __u32 after_sb_1p ;
>    __u32 after_sb_2p ;
>    __u32 rr_conflict ;
>    __u32 on_congestion ;
>    __u32 cong_fill ;
>    __u32 cong_extents ;
>    char two_primaries ;
>    char discard_my_data ;
>    char tcp_cork ;
>    char always_asbp ;
>    char tentative ;
>    char use_rle ;
7233,7237c7201,7233
< #line 576 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct p_delay_probe93 {
<    struct p_header80 head ;
<    u32 seq_num ;
<    u32 offset ;
---
> #line 375
> struct drbd_conf;
> #line 376
> struct drbd_tconn;
> #line 377
> enum chg_state_flags {
>     CS_HARD = 1,
>     CS_VERBOSE = 2,
>     CS_WAIT_COMPLETE = 4,
>     CS_SERIALIZE = 8,
>     CS_ORDERED = 12,
>     CS_LOCAL_ONLY = 16,
>     CS_DC_ROLE = 32,
>     CS_DC_PEER = 64,
>     CS_DC_CONN = 128,
>     CS_DC_DISK = 256,
>     CS_DC_PDSK = 512,
>     CS_DC_SUSP = 1024,
>     CS_DC_MASK = 992,
>     CS_IGN_OUTD_FAIL = 2048
> } ;
> #line 394 "include/linux/drbd_genl.h"
> struct __anonstruct_ldv_50103_260 {
>    unsigned char role : 2 ;
>    unsigned char peer : 2 ;
>    unsigned char conn : 5 ;
>    unsigned char disk : 4 ;
>    unsigned char pdsk : 4 ;
>    unsigned char _unused : 1 ;
>    unsigned char aftr_isp : 1 ;
>    unsigned char peer_isp : 1 ;
>    unsigned char user_isp : 1 ;
>    unsigned short _pad : 11 ;
7239,7258c7235,7238
< #line 621 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< union p_polymorph {
<    union p_header header ;
<    struct p_handshake handshake ;
<    struct p_data data ;
<    struct p_block_ack block_ack ;
<    struct p_barrier barrier ;
<    struct p_barrier_ack barrier_ack ;
<    struct p_rs_param_89 rs_param_89 ;
<    struct p_rs_param_95 rs_param_95 ;
<    struct p_protocol protocol ;
<    struct p_sizes sizes ;
<    struct p_uuids uuids ;
<    struct p_state state ;
<    struct p_req_state req_state ;
<    struct p_req_state_reply req_state_reply ;
<    struct p_block_req block_req ;
<    struct p_delay_probe93 delay_probe93 ;
<    struct p_rs_uuid rs_uuid ;
<    struct p_block_desc block_desc ;
---
> #line 394 "include/linux/drbd_genl.h"
> union drbd_dev_state {
>    struct __anonstruct_ldv_50103_260 ldv_50103 ;
>    unsigned int i ;
7260c7240
< #line 655
---
> #line 499 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7262,7265c7242,7245
<     None = 0,
<     Running = 1,
<     Exiting = 2,
<     Restarting = 3
---
>     NONE = 0,
>     RUNNING = 1,
>     EXITING = 2,
>     RESTARTING = 3
7267c7247
< #line 662 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 506 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7274c7254
<    struct drbd_conf *mdev ;
---
>    struct drbd_tconn *tconn ;
7275a7256
>    char name[9U] ;
7277,7279c7258,7263
< #line 683
< struct drbd_work;
< #line 686 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 534 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> union __anonunion_ldv_50388_261 {
>    struct drbd_conf *mdev ;
>    struct drbd_tconn *tconn ;
> };
> #line 534 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7282,7292c7266,7267
<    int (*cb)(struct drbd_conf * , struct drbd_work * , int  ) ;
< };
< #line 690
< struct drbd_tl_epoch;
< #line 717 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct drbd_tl_epoch {
<    struct drbd_work w ;
<    struct list_head requests ;
<    struct drbd_tl_epoch *next ;
<    unsigned int br_number ;
<    int n_writes ;
---
>    int (*cb)(struct drbd_work * , int  ) ;
>    union __anonunion_ldv_50388_261 ldv_50388 ;
7294c7269
< #line 725 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 580 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7295a7271
>    struct drbd_tconn *tconn ;
7302,7362c7278
< #line 759 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct digest_info {
<    int digest_size ;
<    void *digest ;
< };
< #line 764 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< union __anonunion_ldv_49794_259 {
<    u64 block_id ;
<    struct digest_info *digest ;
< };
< #line 764 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct drbd_epoch_entry {
<    struct drbd_work w ;
<    struct hlist_node collision ;
<    struct drbd_epoch *epoch ;
<    struct drbd_conf *mdev ;
<    struct page *pages ;
<    atomic_t pending_bios ;
<    unsigned int size ;
<    unsigned long flags ;
<    sector_t sector ;
<    union __anonunion_ldv_49794_259 ldv_49794 ;
< };
< #line 789
< enum drbd_flag {
<     CREATE_BARRIER = 0,
<     SIGNAL_ASENDER = 1,
<     SEND_PING = 2,
<     UNPLUG_REMOTE = 3,
<     MD_DIRTY = 4,
<     DISCARD_CONCURRENT = 5,
<     USE_DEGR_WFC_T = 6,
<     CLUSTER_ST_CHANGE = 7,
<     CL_ST_CHG_SUCCESS = 8,
<     CL_ST_CHG_FAIL = 9,
<     CRASHED_PRIMARY = 10,
<     CONSIDER_RESYNC = 11,
<     MD_NO_FUA = 12,
<     SUSPEND_IO = 13,
<     BITMAP_IO = 14,
<     BITMAP_IO_QUEUED = 15,
<     GO_DISKLESS = 16,
<     WAS_IO_ERROR = 17,
<     WAS_READ_ERROR = 18,
<     FORCE_DETACH = 19,
<     RESYNC_AFTER_NEG = 20,
<     NET_CONGESTED = 21,
<     CONFIG_PENDING = 22,
<     DEVICE_DYING = 23,
<     RESIZE_PENDING = 24,
<     CONN_DRY_RUN = 25,
<     GOT_PING_ACK = 26,
<     NEW_CUR_UUID = 27,
<     AL_SUSPENDED = 28,
<     AHEAD_TO_SYNC_SOURCE = 29,
<     STATE_SENT = 30,
<     CALLBACK_PENDING = 31,
<     DISCONNECT_SENT = 32,
<     DRBD_N_FLAGS = 33
< } ;
< #line 826
---
> #line 662
7364c7280
< #line 827
---
> #line 663
7376c7292
< #line 839 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 675 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7379d7294
<    struct semaphore s ;
7380a7296
>    wait_queue_head_t q_wait ;
7382c7298
< #line 905 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 736 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7384d7299
<    struct drbd_work_queue work ;
7387,7388c7302,7303
<    union p_polymorph sbuf ;
<    union p_polymorph rbuf ;
---
>    void *sbuf ;
>    void *rbuf ;
7390c7305
< #line 915 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 745 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7402,7477c7317
< #line 19 "include/linux/drbd_nl.h"
< struct disk_conf {
<    __u64 disk_size ;
<    unsigned char backing_dev[128U] ;
<    int backing_dev_len ;
<    unsigned char meta_dev[128U] ;
<    int meta_dev_len ;
<    int meta_dev_idx ;
<    int on_io_error ;
<    int fencing ;
<    unsigned char use_bmbv : 1 ;
<    unsigned char no_disk_flush : 1 ;
<    unsigned char no_md_flush : 1 ;
<    int max_bio_bvecs ;
<    unsigned char no_disk_barrier : 1 ;
<    unsigned char no_disk_drain : 1 ;
<    int disk_timeout ;
< };
< #line 39 "include/linux/drbd_nl.h"
< struct net_conf {
<    unsigned char my_addr[128U] ;
<    int my_addr_len ;
<    unsigned char peer_addr[128U] ;
<    int peer_addr_len ;
<    unsigned char shared_secret[64U] ;
<    int shared_secret_len ;
<    unsigned char cram_hmac_alg[64U] ;
<    int cram_hmac_alg_len ;
<    unsigned char integrity_alg[64U] ;
<    int integrity_alg_len ;
<    int timeout ;
<    int wire_protocol ;
<    int try_connect_int ;
<    int ping_int ;
<    int max_epoch_size ;
<    int max_buffers ;
<    int unplug_watermark ;
<    int sndbuf_size ;
<    int ko_count ;
<    int after_sb_0p ;
<    int after_sb_1p ;
<    int after_sb_2p ;
<    int rr_conflict ;
<    int ping_timeo ;
<    int rcvbuf_size ;
<    int on_congestion ;
<    int cong_fill ;
<    int cong_extents ;
<    unsigned char mind_af : 1 ;
<    unsigned char want_lose : 1 ;
<    unsigned char two_primaries : 1 ;
<    unsigned char always_asbp : 1 ;
<    unsigned char no_cork : 1 ;
<    unsigned char auto_sndbuf_size : 1 ;
<    unsigned char dry_run : 1 ;
< };
< #line 81 "include/linux/drbd_nl.h"
< struct syncer_conf {
<    int rate ;
<    int after ;
<    int al_extents ;
<    unsigned char verify_alg[64U] ;
<    int verify_alg_len ;
<    unsigned char cpu_mask[32U] ;
<    int cpu_mask_len ;
<    unsigned char csums_alg[64U] ;
<    int csums_alg_len ;
<    unsigned char use_rle : 1 ;
<    int on_no_data ;
<    int c_plan_ahead ;
<    int c_delay_target ;
<    int c_fill_target ;
<    int c_max_rate ;
<    int c_min_rate ;
< };
< #line 153 "include/linux/drbd_nl.h"
---
> #line 759 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7482c7322
<    struct disk_conf dc ;
---
>    struct disk_conf *disk_conf ;
7485c7325
< #line 950 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 772 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7490c7330
< #line 955 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 777 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7498c7338
< #line 963
---
> #line 785
7504c7344
< #line 969 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 791 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7506d7345
<    int *values ;
7508a7348,7349
>    int total ;
>    int values[0U] ;
7510,7512c7351,7368
< #line 975 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct drbd_conf {
<    unsigned long drbd_flags[1U] ;
---
> #line 815 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct __anonstruct_send_263 {
>    bool seen_any_write_yet ;
>    int current_epoch_nr ;
>    unsigned int current_epoch_writes ;
> };
> #line 815 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct drbd_tconn {
>    char *name ;
>    struct list_head all_tconn ;
>    struct kref kref ;
>    struct idr volumes ;
>    enum drbd_conns cstate ;
>    unsigned char susp : 1 ;
>    unsigned char susp_nod : 1 ;
>    unsigned char susp_fen : 1 ;
>    struct mutex cstate_mutex ;
>    unsigned long flags ;
7514,7519c7370,7376
<    struct syncer_conf sync_conf ;
<    struct drbd_backing_dev *ldev ;
<    sector_t p_size ;
<    struct request_queue *rq_queue ;
<    struct block_device *this_bdev ;
<    struct gendisk *vdisk ;
---
>    struct mutex conf_update ;
>    wait_queue_head_t ping_wait ;
>    struct res_opts res_opts ;
>    struct __kernel_sockaddr_storage my_addr ;
>    int my_addr_len ;
>    struct __kernel_sockaddr_storage peer_addr ;
>    int peer_addr_len ;
7524a7382,7416
>    spinlock_t req_lock ;
>    struct list_head transfer_log ;
>    struct crypto_hash *cram_hmac_tfm ;
>    struct crypto_hash *integrity_tfm ;
>    struct crypto_hash *peer_integrity_tfm ;
>    struct crypto_hash *csums_tfm ;
>    struct crypto_hash *verify_tfm ;
>    void *int_dig_in ;
>    void *int_dig_vv ;
>    struct drbd_epoch *current_epoch ;
>    spinlock_t epoch_lock ;
>    unsigned int epochs ;
>    enum write_ordering_e write_ordering ;
>    atomic_t current_tle_nr ;
>    unsigned int current_tle_writes ;
>    unsigned long last_reconnect_jif ;
>    struct drbd_thread receiver ;
>    struct drbd_thread worker ;
>    struct drbd_thread asender ;
>    cpumask_var_t cpu_mask ;
>    struct drbd_work_queue sender_work ;
>    struct __anonstruct_send_263 send ;
> };
> #line 893 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct drbd_conf {
>    struct drbd_tconn *tconn ;
>    int vnr ;
>    struct kref kref ;
>    unsigned long flags ;
>    struct drbd_backing_dev *ldev ;
>    sector_t p_size ;
>    struct request_queue *rq_queue ;
>    struct block_device *this_bdev ;
>    struct gendisk *vdisk ;
>    unsigned long last_reattach_jif ;
7535c7427
<    union drbd_state state ;
---
>    union drbd_dev_state state ;
7538d7429
<    wait_queue_head_t net_cnt_wait ;
7550,7558c7441,7442
<    atomic_t net_cnt ;
<    spinlock_t req_lock ;
<    struct drbd_tl_epoch *unused_spare_tle ;
<    struct drbd_tl_epoch *newest_tle ;
<    struct drbd_tl_epoch *oldest_tle ;
<    struct list_head out_of_sequence_requests ;
<    struct list_head barrier_acked_requests ;
<    struct hlist_head *tl_hash ;
<    unsigned int tl_hash_s ;
---
>    struct rb_root read_requests ;
>    struct rb_root write_requests ;
7566a7451
>    unsigned long rs_last_bcast ;
7573,7579d7457
<    struct crypto_hash *csums_tfm ;
<    struct crypto_hash *verify_tfm ;
<    unsigned long last_reattach_jif ;
<    unsigned long last_reconnect_jif ;
<    struct drbd_thread receiver ;
<    struct drbd_thread worker ;
<    struct drbd_thread asender ;
7587,7590d7464
<    struct drbd_epoch *current_epoch ;
<    spinlock_t epoch_lock ;
<    unsigned int epochs ;
<    enum write_ordering_e write_ordering ;
7596,7598d7469
<    struct hlist_head *ee_hash ;
<    unsigned int ee_hash_s ;
<    struct drbd_epoch_entry *last_write_w_barrier ;
7600d7470
<    struct hlist_head *app_reads_hash ;
7606d7475
<    struct page *md_io_tmpp ;
7615,7620d7483
<    struct crypto_hash *cram_hmac_tfm ;
<    struct crypto_hash *integrity_w_tfm ;
<    struct crypto_hash *integrity_r_tfm ;
<    void *int_dig_out ;
<    void *int_dig_in ;
<    void *int_dig_vv ;
7627d7489
<    cpumask_var_t cpu_mask ;
7630c7492,7493
<    struct mutex state_mutex ;
---
>    struct mutex own_state_mutex ;
>    struct mutex *state_mutex ;
7637c7500
<    struct fifo_buffer rs_plan_s ;
---
>    struct fifo_buffer *rs_plan_s ;
7639d7501
<    int rs_planed ;
7644,7652c7506
< #line 1212
< enum chg_state_flags {
<     CS_HARD = 1,
<     CS_VERBOSE = 2,
<     CS_WAIT_COMPLETE = 4,
<     CS_SERIALIZE = 8,
<     CS_ORDERED = 12
< } ;
< #line 1881
---
> #line 1666
7659c7513
< #line 2557 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2335 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7674c7528
< #line 894 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 925 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
7711c7565
< #line 154 "include/linux/drbd.h"
---
> #line 176 "include/linux/drbd.h"
7718,7746c7572
< #line 161
< enum drbd_conns {
<     C_STANDALONE = 0,
<     C_DISCONNECTING = 1,
<     C_UNCONNECTED = 2,
<     C_TIMEOUT = 3,
<     C_BROKEN_PIPE = 4,
<     C_NETWORK_FAILURE = 5,
<     C_PROTOCOL_ERROR = 6,
<     C_TEAR_DOWN = 7,
<     C_WF_CONNECTION = 8,
<     C_WF_REPORT_PARAMS = 9,
<     C_CONNECTED = 10,
<     C_STARTING_SYNC_S = 11,
<     C_STARTING_SYNC_T = 12,
<     C_WF_BITMAP_S = 13,
<     C_WF_BITMAP_T = 14,
<     C_WF_SYNC_UUID = 15,
<     C_SYNC_SOURCE = 16,
<     C_SYNC_TARGET = 17,
<     C_VERIFY_S = 18,
<     C_VERIFY_T = 19,
<     C_PAUSED_SYNC_S = 20,
<     C_PAUSED_SYNC_T = 21,
<     C_AHEAD = 22,
<     C_BEHIND = 23,
<     C_MASK = 31
< } ;
< #line 1341 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1153 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7755,7756c7581,7645
< #line 159 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< enum drbd_packets {
---
> #line 113 "include/linux/drbd.h"
> enum drbd_ret_code {
>     ERR_CODE_BASE = 100,
>     NO_ERROR = 101,
>     ERR_LOCAL_ADDR = 102,
>     ERR_PEER_ADDR = 103,
>     ERR_OPEN_DISK = 104,
>     ERR_OPEN_MD_DISK = 105,
>     ERR_DISK_NOT_BDEV = 107,
>     ERR_MD_NOT_BDEV = 108,
>     ERR_DISK_TOO_SMALL = 111,
>     ERR_MD_DISK_TOO_SMALL = 112,
>     ERR_BDCLAIM_DISK = 114,
>     ERR_BDCLAIM_MD_DISK = 115,
>     ERR_MD_IDX_INVALID = 116,
>     ERR_IO_MD_DISK = 118,
>     ERR_MD_INVALID = 119,
>     ERR_AUTH_ALG = 120,
>     ERR_AUTH_ALG_ND = 121,
>     ERR_NOMEM = 122,
>     ERR_DISCARD_IMPOSSIBLE = 123,
>     ERR_DISK_CONFIGURED = 124,
>     ERR_NET_CONFIGURED = 125,
>     ERR_MANDATORY_TAG = 126,
>     ERR_MINOR_INVALID = 127,
>     ERR_INTR = 129,
>     ERR_RESIZE_RESYNC = 130,
>     ERR_NO_PRIMARY = 131,
>     ERR_RESYNC_AFTER = 132,
>     ERR_RESYNC_AFTER_CYCLE = 133,
>     ERR_PAUSE_IS_SET = 134,
>     ERR_PAUSE_IS_CLEAR = 135,
>     ERR_PACKET_NR = 137,
>     ERR_NO_DISK = 138,
>     ERR_NOT_PROTO_C = 139,
>     ERR_NOMEM_BITMAP = 140,
>     ERR_INTEGRITY_ALG = 141,
>     ERR_INTEGRITY_ALG_ND = 142,
>     ERR_CPU_MASK_PARSE = 143,
>     ERR_CSUMS_ALG = 144,
>     ERR_CSUMS_ALG_ND = 145,
>     ERR_VERIFY_ALG = 146,
>     ERR_VERIFY_ALG_ND = 147,
>     ERR_CSUMS_RESYNC_RUNNING = 148,
>     ERR_VERIFY_RUNNING = 149,
>     ERR_DATA_NOT_CURRENT = 150,
>     ERR_CONNECTED = 151,
>     ERR_PERM = 152,
>     ERR_NEED_APV_93 = 153,
>     ERR_STONITH_AND_PROT_A = 154,
>     ERR_CONG_NOT_PROTO_A = 155,
>     ERR_PIC_AFTER_DEP = 156,
>     ERR_PIC_PEER_DEP = 157,
>     ERR_RES_NOT_KNOWN = 158,
>     ERR_RES_IN_USE = 159,
>     ERR_MINOR_CONFIGURED = 160,
>     ERR_MINOR_EXISTS = 161,
>     ERR_INVALID_REQUEST = 162,
>     ERR_NEED_APV_100 = 163,
>     ERR_NEED_ALLOW_TWO_PRI = 164,
>     ERR_MD_UNCLEAN = 165,
>     AFTER_LAST_ERR_CODE = 166
> } ;
> #line 169 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> enum drbd_packet {
7781c7670
<     P_DISCARD_ACK = 24,
---
>     P_SUPERSEDED = 24,
7797c7686,7689
<     P_MAX_CMD = 42,
---
>     P_CONN_ST_CHG_REQ = 42,
>     P_CONN_ST_CHG_REPLY = 43,
>     P_RETRY_WRITE = 44,
>     P_PROTOCOL_UPDATE = 45,
7800,7802c7692,7694
<     P_HAND_SHAKE_M = 65521,
<     P_HAND_SHAKE_S = 65522,
<     P_HAND_SHAKE = 65534
---
>     P_INITIAL_META = 65521,
>     P_INITIAL_DATA = 65522,
>     P_CONNECTION_FEATURES = 65534
7804c7696,7710
< #line 691 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 376 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_barrier {
>    u32 barrier ;
>    u32 pad ;
> };
> #line 543 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct drbd_interval {
>    struct rb_node rb ;
>    sector_t sector ;
>    unsigned int size ;
>    sector_t end ;
>    signed char local : 1 ;
>    signed char waiting : 1 ;
> };
> #line 547 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7807d7712
<    struct drbd_conf *mdev ;
7809,7811c7714
<    struct hlist_node collision ;
<    sector_t sector ;
<    unsigned int size ;
---
>    struct drbd_interval i ;
7815d7717
<    unsigned long rq_state ;
7816a7719,7721
>    atomic_t completion_ref ;
>    struct kref kref ;
>    unsigned int rq_state ;
7818c7723
< #line 753 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 600 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7823c7728,7748
< #line 53 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_wrappers.h"
---
> #line 606 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct digest_info {
>    int digest_size ;
>    void *digest ;
> };
> #line 611 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> union __anonunion_ldv_50490_262 {
>    u64 block_id ;
>    struct digest_info *digest ;
> };
> #line 611 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct drbd_peer_request {
>    struct drbd_work w ;
>    struct drbd_epoch *epoch ;
>    struct page *pages ;
>    atomic_t pending_bios ;
>    struct drbd_interval i ;
>    unsigned long flags ;
>    union __anonunion_ldv_50490_262 ldv_50490 ;
> };
> #line 48 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_wrappers.h"
7825,7852c7750,7778
<     created = 0,
<     to_be_send = 1,
<     to_be_submitted = 2,
<     queue_for_net_write = 3,
<     queue_for_net_read = 4,
<     queue_for_send_oos = 5,
<     send_canceled = 6,
<     send_failed = 7,
<     handed_over_to_network = 8,
<     oos_handed_to_network = 9,
<     connection_lost_while_pending = 10,
<     read_retry_remote_canceled = 11,
<     recv_acked_by_peer = 12,
<     write_acked_by_peer = 13,
<     write_acked_by_peer_and_sis = 14,
<     conflict_discarded_by_peer = 15,
<     neg_acked = 16,
<     barrier_acked = 17,
<     data_received = 18,
<     read_completed_with_error = 19,
<     read_ahead_completed_with_error = 20,
<     write_completed_with_error = 21,
<     abort_disk_io = 22,
<     completed_ok = 23,
<     resend = 24,
<     fail_frozen_disk_io = 25,
<     restart_frozen_disk_io = 26,
<     nothing = 27
---
>     CREATED = 0,
>     TO_BE_SENT = 1,
>     TO_BE_SUBMITTED = 2,
>     QUEUE_FOR_NET_WRITE = 3,
>     QUEUE_FOR_NET_READ = 4,
>     QUEUE_FOR_SEND_OOS = 5,
>     SEND_CANCELED = 6,
>     SEND_FAILED = 7,
>     HANDED_OVER_TO_NETWORK = 8,
>     OOS_HANDED_TO_NETWORK = 9,
>     CONNECTION_LOST_WHILE_PENDING = 10,
>     READ_RETRY_REMOTE_CANCELED = 11,
>     RECV_ACKED_BY_PEER = 12,
>     WRITE_ACKED_BY_PEER = 13,
>     WRITE_ACKED_BY_PEER_AND_SIS = 14,
>     CONFLICT_RESOLVED = 15,
>     POSTPONE_WRITE = 16,
>     NEG_ACKED = 17,
>     BARRIER_ACKED = 18,
>     DATA_RECEIVED = 19,
>     READ_COMPLETED_WITH_ERROR = 20,
>     READ_AHEAD_COMPLETED_WITH_ERROR = 21,
>     WRITE_COMPLETED_WITH_ERROR = 22,
>     ABORT_DISK_IO = 23,
>     COMPLETED_OK = 24,
>     RESEND = 25,
>     FAIL_FROZEN_DISK_IO = 26,
>     RESTART_FROZEN_DISK_IO = 27,
>     NOTHING = 28
7854c7780
< #line 315 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
---
> #line 261 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
7885,7891c7811
< #line 62 "include/linux/drbd.h"
< enum drbd_fencing_p {
<     FP_DONT_CARE = 0,
<     FP_RESOURCE = 1,
<     FP_STONITH = 2
< } ;
< #line 74
---
> #line 74 "include/linux/drbd.h"
7905c7825
< #line 281 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 237 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7914c7834,7944
< #line 555
---
> #line 271 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_header80 {
>    u32 magic ;
>    u16 command ;
>    u16 length ;
> };
> #line 297 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_header95 {
>    u16 magic ;
>    u16 command ;
>    u32 length ;
> };
> #line 304 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_header100 {
>    u32 magic ;
>    u16 volume ;
>    u16 command ;
>    u32 length ;
>    u32 pad ;
> };
> #line 314 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_data {
>    u64 sector ;
>    u64 block_id ;
>    u32 seq_num ;
>    u32 dp_flags ;
> };
> #line 332 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_block_ack {
>    u64 sector ;
>    u64 block_id ;
>    u32 blksize ;
>    u32 seq_num ;
> };
> #line 347 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_block_req {
>    u64 sector ;
>    u64 block_id ;
>    u32 blksize ;
>    u32 pad ;
> };
> #line 354 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_connection_features {
>    u32 protocol_min ;
>    u32 feature_flags ;
>    u32 protocol_max ;
>    u32 _pad ;
>    u64 reserved[7U] ;
> };
> #line 381 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_barrier_ack {
>    u32 barrier ;
>    u32 set_size ;
> };
> #line 400 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_rs_param_95 {
>    u32 resync_rate ;
>    char verify_alg[64U] ;
>    char csums_alg[64U] ;
>    u32 c_plan_ahead ;
>    u32 c_delay_target ;
>    u32 c_fill_target ;
>    u32 c_max_rate ;
> };
> #line 415 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_protocol {
>    u32 protocol ;
>    u32 after_sb_0p ;
>    u32 after_sb_1p ;
>    u32 after_sb_2p ;
>    u32 conn_flags ;
>    u32 two_primaries ;
>    char integrity_alg[0U] ;
> };
> #line 427 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_uuids {
>    u64 uuid[6U] ;
> };
> #line 432 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_rs_uuid {
>    u64 uuid ;
> };
> #line 436 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_sizes {
>    u64 d_size ;
>    u64 u_size ;
>    u64 c_size ;
>    u32 max_bio_size ;
>    u16 queue_order_type ;
>    u16 dds_flags ;
> };
> #line 445 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_state {
>    u32 state ;
> };
> #line 449 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_req_state {
>    u32 mask ;
>    u32 val ;
> };
> #line 454 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_req_state_reply {
>    u32 retcode ;
> };
> #line 468 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct p_block_desc {
>    u64 sector ;
>    u32 blksize ;
>    u32 pad ;
> };
> #line 474
7918c7948
< #line 559 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 478 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
7920d7949
<    struct p_header80 head ;
7924c7953
< #line 746
---
> #line 593
7931c7960
< #line 1220
---
> #line 1051
7936c7965
< #line 1589
---
> #line 1434
7955c7984,7991
< #line 350
---
> #line 350 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_vli.h"
> struct packet_info {
>    enum drbd_packet cmd ;
>    unsigned int size ;
>    unsigned int vnr ;
>    void *data ;
> };
> #line 65 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
7961c7997,8004
< #line 3703 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 661 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> struct accept_wait_data {
>    struct drbd_tconn *tconn ;
>    struct socket *s_listen ;
>    struct completion door_bell ;
>    void (*original_sk_state_change)(struct sock * ) ;
> };
> #line 4338 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
7965c8008
<    int (*function)(struct drbd_conf * , enum drbd_packets  , unsigned int  ) ;
---
>    int (*fn)(struct drbd_tconn * , struct packet_info * ) ;
7967,7969c8010
< #line 4352 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< typedef struct drbd_request *req_validator_fn(struct drbd_conf * , u64  , sector_t  );
< #line 4571 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 5215 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
7972c8013
<    int (*process)(struct drbd_conf * , struct p_header80 * ) ;
---
>    int (*fn)(struct drbd_tconn * , struct packet_info * ) ;
7976,7988c8017,8036
< #line 187 "include/linux/bio.h"
< struct bio_pair {
<    struct bio bio1 ;
<    struct bio bio2 ;
<    struct bio_vec bv1 ;
<    struct bio_vec bv2 ;
<    struct bio_integrity_payload bip1 ;
<    struct bio_integrity_payload bip2 ;
<    struct bio_vec iv1 ;
<    struct bio_vec iv2 ;
<    atomic_t cnt ;
<    int error ;
< };
---
> #line 93 "include/linux/drbd.h"
> enum drbd_on_congestion {
>     OC_BLOCK = 0,
>     OC_PULL_AHEAD = 1,
>     OC_DISCONNECT = 2
> } ;
> #line 99
> enum drbd_read_balancing {
>     RB_PREFER_LOCAL = 0,
>     RB_PREFER_REMOTE = 1,
>     RB_ROUND_ROBIN = 2,
>     RB_LEAST_PENDING = 3,
>     RB_CONGESTED_REMOTE = 4,
>     RB_32K_STRIPING = 5,
>     RB_64K_STRIPING = 6,
>     RB_128K_STRIPING = 7,
>     RB_256K_STRIPING = 8,
>     RB_512K_STRIPING = 9,
>     RB_1M_STRIPING = 10
> } ;
7991,7994c8039,8065
< #line 53 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_wrappers.h"
< struct __anonstruct_updates_260 {
<    u32 pos ;
<    u32 extent ;
---
> #line 34 "include/linux/drbd_genl_api.h"
> enum drbd_state_info_bcast_reason {
>     SIB_GET_STATUS_REPLY = 1,
>     SIB_STATE_CHANGE = 2,
>     SIB_HELPER_PRE = 3,
>     SIB_HELPER_POST = 4,
>     SIB_SYNC_PROGRESS = 5
> } ;
> #line 1598 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct __anonstruct_ldv_51330_265 {
>    char *helper_name ;
>    unsigned int helper_exit_code ;
> };
> #line 1598 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct __anonstruct_ldv_51334_266 {
>    union drbd_state os ;
>    union drbd_state ns ;
> };
> #line 1598 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> union __anonunion_ldv_51335_264 {
>    struct __anonstruct_ldv_51330_265 ldv_51330 ;
>    struct __anonstruct_ldv_51334_266 ldv_51334 ;
> };
> #line 1598 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct sib_info {
>    enum drbd_state_info_bcast_reason sib_reason ;
>    union __anonunion_ldv_51335_264 ldv_51335 ;
7997,8001c8068,8079
< struct al_transaction {
<    u32 magic ;
<    u32 tr_number ;
<    struct __anonstruct_updates_260 updates[62U] ;
<    u32 xor_sum ;
---
> struct al_transaction_on_disk {
>    __be32 magic ;
>    __be32 tr_number ;
>    __be32 crc32c ;
>    __be16 transaction_type ;
>    __be16 n_updates ;
>    __be16 context_size ;
>    __be16 context_start_slot_nr ;
>    __be32 __reserved[4U] ;
>    __be16 update_slot_nr[64U] ;
>    __be32 update_extent_nr[64U] ;
>    __be32 context[919U] ;
8003c8081
< #line 50 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 103 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
8008c8086
< #line 55 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 108 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
8011d8088
<    struct lc_element *al_ext ;
8013,8014c8090
<    unsigned int enr ;
<    unsigned int old_enr ;
---
>    int err ;
8017a8094,8095
> #line 266
> struct workqueue_struct;
8024,8036c8102,8107
< #line 56 "include/linux/drbd.h"
< enum drbd_io_error_p {
<     EP_PASS_ON = 0,
<     EP_CALL_HELPER = 1,
<     EP_DETACH = 2
< } ;
< #line 350 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_vli.h"
< struct after_state_chg_work {
<    struct drbd_work w ;
<    union drbd_state os ;
<    union drbd_state ns ;
<    enum chg_state_flags flags ;
<    struct completion *done ;
---
> #line 2204 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> struct retry_worker {
>    struct workqueue_struct *wq ;
>    struct work_struct worker ;
>    spinlock_t lock ;
>    struct list_head writes ;
8038,8047c8109
< #line 570 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< enum sanitize_state_warnings {
<     NO_WARNING = 0,
<     ABORTED_ONLINE_VERIFY = 1,
<     ABORTED_RESYNC = 2,
<     CONNECTION_LOST_NEGOTIATING = 3,
<     IMPLICITLY_UPGRADED_DISK = 4,
<     IMPLICITLY_UPGRADED_PDSK = 5
< } ;
< #line 3846 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 2847 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
8063c8125
< #line 4371 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3488 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
8068,8073d8129
< #line 32 "include/uapi/linux/types.h"
< typedef __u16 __le16;
< #line 34 "include/uapi/linux/types.h"
< typedef __u32 __le32;
< #line 36 "include/uapi/linux/types.h"
< typedef __u64 __le64;
8112,8179c8168,8173
< #line 2228 "include/net/sock.h"
< struct cb_id {
<    __u32 idx ;
<    __u32 val ;
< };
< #line 65 "include/uapi/linux/connector.h"
< struct cn_msg {
<    struct cb_id id ;
<    __u32 seq ;
<    __u32 ack ;
<    __u16 len ;
<    __u16 flags ;
<    __u8 data[0U] ;
< };
< #line 99 "include/linux/drbd.h"
< enum drbd_ret_code {
<     ERR_CODE_BASE = 100,
<     NO_ERROR = 101,
<     ERR_LOCAL_ADDR = 102,
<     ERR_PEER_ADDR = 103,
<     ERR_OPEN_DISK = 104,
<     ERR_OPEN_MD_DISK = 105,
<     ERR_DISK_NOT_BDEV = 107,
<     ERR_MD_NOT_BDEV = 108,
<     ERR_DISK_TOO_SMALL = 111,
<     ERR_MD_DISK_TOO_SMALL = 112,
<     ERR_BDCLAIM_DISK = 114,
<     ERR_BDCLAIM_MD_DISK = 115,
<     ERR_MD_IDX_INVALID = 116,
<     ERR_IO_MD_DISK = 118,
<     ERR_MD_INVALID = 119,
<     ERR_AUTH_ALG = 120,
<     ERR_AUTH_ALG_ND = 121,
<     ERR_NOMEM = 122,
<     ERR_DISCARD = 123,
<     ERR_DISK_CONFIGURED = 124,
<     ERR_NET_CONFIGURED = 125,
<     ERR_MANDATORY_TAG = 126,
<     ERR_MINOR_INVALID = 127,
<     ERR_INTR = 129,
<     ERR_RESIZE_RESYNC = 130,
<     ERR_NO_PRIMARY = 131,
<     ERR_SYNC_AFTER = 132,
<     ERR_SYNC_AFTER_CYCLE = 133,
<     ERR_PAUSE_IS_SET = 134,
<     ERR_PAUSE_IS_CLEAR = 135,
<     ERR_PACKET_NR = 137,
<     ERR_NO_DISK = 138,
<     ERR_NOT_PROTO_C = 139,
<     ERR_NOMEM_BITMAP = 140,
<     ERR_INTEGRITY_ALG = 141,
<     ERR_INTEGRITY_ALG_ND = 142,
<     ERR_CPU_MASK_PARSE = 143,
<     ERR_CSUMS_ALG = 144,
<     ERR_CSUMS_ALG_ND = 145,
<     ERR_VERIFY_ALG = 146,
<     ERR_VERIFY_ALG_ND = 147,
<     ERR_CSUMS_RESYNC_RUNNING = 148,
<     ERR_VERIFY_RUNNING = 149,
<     ERR_DATA_NOT_CURRENT = 150,
<     ERR_CONNECTED = 151,
<     ERR_PERM = 152,
<     ERR_NEED_APV_93 = 153,
<     ERR_STONITH_AND_PROT_A = 154,
<     ERR_CONG_NOT_PROTO_A = 155,
<     ERR_PIC_AFTER_DEP = 156,
<     ERR_PIC_PEER_DEP = 157,
<     AFTER_LAST_ERR_CODE = 158
---
> #line 61 "include/linux/drbd.h"
> enum drbd_fencing_p {
>     FP_NOT_AVAIL = -1,
>     FP_DONT_CARE = 0,
>     FP_RESOURCE = 1,
>     FP_STONITH = 2
8181,8186c8175,8267
< #line 323 "include/linux/drbd.h"
< struct drbd_nl_cfg_req {
<    int packet_type ;
<    unsigned int drbd_minor ;
<    int flags ;
<    unsigned short tag_list[] ;
---
> #line 56 "include/linux/prefetch.h"
> union __anonunion_ldv_49550_259 {
>    __u32 flags ;
>    __s32 ret_code ;
> };
> #line 56 "include/linux/prefetch.h"
> struct drbd_genlmsghdr {
>    __u32 minor ;
>    union __anonunion_ldv_49550_259 ldv_49550 ;
> };
> #line 42 "include/linux/drbd_genl_api.h"
> struct genlmsghdr {
>    __u8 cmd ;
>    __u8 version ;
>    __u16 reserved ;
> };
> #line 89 "include/linux/drbd_genl.h"
> struct drbd_cfg_context {
>    __u32 ctx_volume ;
>    char ctx_resource_name[128U] ;
>    __u32 ctx_resource_name_len ;
>    char ctx_my_addr[128U] ;
>    __u32 ctx_my_addr_len ;
>    char ctx_peer_addr[128U] ;
>    __u32 ctx_peer_addr_len ;
> };
> #line 144 "include/linux/drbd_genl.h"
> struct set_role_parms {
>    char assume_uptodate ;
> };
> #line 178 "include/linux/drbd_genl.h"
> struct resize_parms {
>    __u64 resize_size ;
>    char resize_force ;
>    char no_resync ;
> };
> #line 182 "include/linux/drbd_genl.h"
> struct state_info {
>    __u32 sib_reason ;
>    __u32 current_state ;
>    __u64 capacity ;
>    __u64 ed_uuid ;
>    __u32 prev_state ;
>    __u32 new_state ;
>    char uuids[32U] ;
>    __u32 uuids_len ;
>    __u32 disk_flags ;
>    __u64 bits_total ;
>    __u64 bits_oos ;
>    __u64 bits_rs_total ;
>    __u64 bits_rs_failed ;
>    char helper[32U] ;
>    __u32 helper_len ;
>    __u32 helper_exit_code ;
>    __u64 send_cnt ;
>    __u64 recv_cnt ;
>    __u64 read_cnt ;
>    __u64 writ_cnt ;
>    __u64 al_writ_cnt ;
>    __u64 bm_writ_cnt ;
>    __u32 ap_bio_cnt ;
>    __u32 ap_pending_cnt ;
>    __u32 rs_pending_cnt ;
> };
> #line 188 "include/linux/drbd_genl.h"
> struct start_ov_parms {
>    __u64 ov_start_sector ;
>    __u64 ov_stop_sector ;
> };
> #line 228 "include/linux/drbd_genl.h"
> struct new_c_uuid_parms {
>    char clear_bm ;
> };
> #line 233 "include/linux/drbd_genl.h"
> struct timeout_parms {
>    __u32 timeout_type ;
> };
> #line 237 "include/linux/drbd_genl.h"
> struct disconnect_parms {
>    char force_disconnect ;
> };
> #line 241 "include/linux/drbd_genl.h"
> struct detach_parms {
>    char force_detach ;
> };
> #line 138 "include/linux/kthread.h"
> struct genl_family;
> #line 138 "include/linux/kthread.h"
> struct genl_multicast_group {
>    struct genl_family *family ;
>    struct list_head list ;
>    char name[16U] ;
>    u32 id ;
8188,8190c8269,8311
< #line 361 "include/linux/drbd.h"
< struct drbd_nl_cfg_reply {
<    int packet_type ;
---
> #line 24 "include/net/genetlink.h"
> struct genl_ops;
> #line 25
> struct genl_info;
> #line 26 "include/net/genetlink.h"
> struct genl_family {
>    unsigned int id ;
>    unsigned int hdrsize ;
>    char name[16U] ;
>    unsigned int version ;
>    unsigned int maxattr ;
>    bool netnsok ;
>    int (*pre_doit)(struct genl_ops * , struct sk_buff * , struct genl_info * ) ;
>    void (*post_doit)(struct genl_ops * , struct sk_buff * , struct genl_info * ) ;
>    struct nlattr **attrbuf ;
>    struct list_head ops_list ;
>    struct list_head family_list ;
>    struct list_head mcast_groups ;
> };
> #line 64 "include/net/genetlink.h"
> struct genl_info {
>    u32 snd_seq ;
>    u32 snd_portid ;
>    struct nlmsghdr *nlhdr ;
>    struct genlmsghdr *genlhdr ;
>    void *userhdr ;
>    struct nlattr **attrs ;
>    struct net *_net ;
>    void *user_ptr[2U] ;
> };
> #line 98 "include/net/genetlink.h"
> struct genl_ops {
>    u8 cmd ;
>    u8 internal_flags ;
>    unsigned int flags ;
>    struct nla_policy  const  *policy ;
>    int (*doit)(struct sk_buff * , struct genl_info * ) ;
>    int (*dumpit)(struct sk_buff * , struct netlink_callback * ) ;
>    int (*done)(struct netlink_callback * ) ;
>    struct list_head ops_list ;
> };
> #line 90 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> struct drbd_config_context {
8192,8193c8313,8320
<    int ret_code ;
<    unsigned short tag_list[] ;
---
>    unsigned int volume ;
>    char *resource_name ;
>    struct nlattr *my_addr ;
>    struct nlattr *peer_addr ;
>    struct sk_buff *reply_skb ;
>    struct drbd_genlmsghdr *reply_dh ;
>    struct drbd_conf *mdev ;
>    struct drbd_tconn *tconn ;
8195,8205c8322,8327
< #line 929 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct primary {
<    unsigned char primary_force : 1 ;
< };
< #line 22 "include/linux/drbd_nl.h"
< struct detach {
<    unsigned char detach_force : 1 ;
< };
< #line 43 "include/linux/drbd_nl.h"
< struct disconnect {
<    unsigned char force : 1 ;
---
> #line 1856 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> struct crypto {
>    struct crypto_hash *verify_tfm ;
>    struct crypto_hash *csums_tfm ;
>    struct crypto_hash *cram_hmac_tfm ;
>    struct crypto_hash *integrity_tfm ;
8207,8211c8329,8333
< #line 77 "include/linux/drbd_nl.h"
< struct resize {
<    __u64 resize_size ;
<    unsigned char resize_force : 1 ;
<    unsigned char no_resync : 1 ;
---
> #line 8 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> struct rb_augment_callbacks {
>    void (*propagate)(struct rb_node * , struct rb_node * ) ;
>    void (*copy)(struct rb_node * , struct rb_node * ) ;
>    void (*rotate)(struct rb_node * , struct rb_node * ) ;
8213,8310c8335,8343
< #line 111 "include/linux/drbd_nl.h"
< struct get_state {
<    int state_i ;
< };
< #line 139 "include/linux/drbd_nl.h"
< struct start_ov {
<    __u64 start_sector ;
<    __u64 stop_sector ;
< };
< #line 148 "include/linux/drbd_nl.h"
< struct new_c_uuid {
<    unsigned char clear_bm : 1 ;
< };
< #line 35 "include/linux/drbd_tag_magic.h"
< enum drbd_tags {
<     T_primary_force = 32769,
<     T_disk_size = 16386,
<     T_backing_dev = 57347,
<     T_meta_dev = 57348,
<     T_meta_dev_idx = 8197,
<     T_on_io_error = 6,
<     T_fencing = 7,
<     T_use_bmbv = 32805,
<     T_no_disk_flush = 32821,
<     T_no_md_flush = 32822,
<     T_max_bio_bvecs = 56,
<     T_no_disk_barrier = 32825,
<     T_no_disk_drain = 32826,
<     T_disk_timeout = 89,
<     T_detach_force = 41048,
<     T_my_addr = 57352,
<     T_peer_addr = 57353,
<     T_shared_secret = 49162,
<     T_cram_hmac_alg = 49163,
<     T_integrity_alg = 49196,
<     T_timeout = 14,
<     T_wire_protocol = 8207,
<     T_try_connect_int = 16,
<     T_ping_int = 17,
<     T_max_epoch_size = 18,
<     T_max_buffers = 19,
<     T_unplug_watermark = 20,
<     T_sndbuf_size = 21,
<     T_ko_count = 22,
<     T_after_sb_0p = 24,
<     T_after_sb_1p = 25,
<     T_after_sb_2p = 26,
<     T_rr_conflict = 39,
<     T_ping_timeo = 40,
<     T_rcvbuf_size = 67,
<     T_on_congestion = 81,
<     T_cong_fill = 82,
<     T_cong_extents = 83,
<     T_mind_af = 41020,
<     T_want_lose = 32795,
<     T_two_primaries = 32796,
<     T_always_asbp = 32809,
<     T_no_cork = 32829,
<     T_auto_sndbuf_size = 41022,
<     T_dry_run = 41030,
<     T_force = 32852,
<     T_resize_size = 16413,
<     T_resize_force = 32836,
<     T_no_resync = 41029,
<     T_rate = 30,
<     T_after = 31,
<     T_al_extents = 32,
<     T_verify_alg = 49204,
<     T_cpu_mask = 49203,
<     T_csums_alg = 49216,
<     T_use_rle = 32833,
<     T_on_no_data = 75,
<     T_c_plan_ahead = 76,
<     T_c_delay_target = 77,
<     T_c_fill_target = 78,
<     T_c_max_rate = 79,
<     T_c_min_rate = 80,
<     T_state_i = 33,
<     T_uuids = 49186,
<     T_uuids_flags = 35,
<     T_use_degraded = 32804,
<     T_helper = 49190,
<     T_sync_progress = 43,
<     T_dump_ee_reason = 49197,
<     T_seen_digest = 49198,
<     T_calc_digest = 49199,
<     T_ee_sector = 16432,
<     T_ee_block_id = 16433,
<     T_ee_data = 49202,
<     T_start_sector = 16450,
<     T_stop_sector = 24666,
<     T_clear_bm = 41023
< } ;
< #line 115 "include/linux/drbd_tag_magic.h"
< struct tag {
<    char const   *name ;
<    int type_n_flags ;
<    int max_len ;
---
> #line 255 "include/linux/timer.h"
> enum hrtimer_restart;
> #line 41 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> struct after_state_chg_work {
>    struct drbd_work w ;
>    union drbd_state os ;
>    union drbd_state ns ;
>    enum chg_state_flags flags ;
>    struct completion *done ;
8312,8315c8345,8360
< #line 2310 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< struct cn_handler_struct {
<    int (*function)(struct drbd_conf * , struct drbd_nl_cfg_req * , struct drbd_nl_cfg_reply * ) ;
<    int reply_body_size ;
---
> #line 49
> enum sanitize_state_warnings {
>     NO_WARNING = 0,
>     ABORTED_ONLINE_VERIFY = 1,
>     ABORTED_RESYNC = 2,
>     CONNECTION_LOST_NEGOTIATING = 3,
>     IMPLICITLY_UPGRADED_DISK = 4,
>     IMPLICITLY_UPGRADED_PDSK = 5
> } ;
> #line 1512 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> struct after_conn_state_chg_work {
>    struct drbd_work w ;
>    enum drbd_conns oc ;
>    union drbd_state ns_min ;
>    union drbd_state ns_max ;
>    enum chg_state_flags flags ;
8344a8390,8403
> #line 121 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/bitops.h"
> __inline static void clear_bit_unlock(unsigned int nr , unsigned long volatile   *addr ) 
> { 
> 
> 
>   {
> #line 123
>   __asm__  volatile   ("": : : "memory");
> #line 124
>   clear_bit((int )nr, addr);
> #line 125
>   return;
> }
> }
8369a8429,8441
> #line 248 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/bitops.h"
> __inline static int test_and_clear_bit(int nr , unsigned long volatile   *addr ) 
> { 
>   int oldbit ;
> 
>   {
> #line 252
>   __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2,%1\n\tsbb %0,%0": "=r" (oldbit),
>                        "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
> #line 256
>   return (oldbit);
> }
> }
8710a8783,8791
> #line 333 "include/linux/lockdep.h"
> extern void lock_acquire(struct lockdep_map * , unsigned int  , int  , int  , int  ,
>                          struct lockdep_map * , unsigned long  ) ;
> #line 337
> extern void lock_release(struct lockdep_map * , int  , unsigned long  ) ;
> #line 342
> extern int lock_is_held(struct lockdep_map * ) ;
> #line 573
> extern void lockdep_rcu_suspicious(char const   * , int const    , char const   * ) ;
8788a8870,9054
> #line 163 "include/linux/rcupdate.h"
> __inline static void __rcu_read_lock(void) 
> { 
>   struct thread_info *tmp ;
> 
>   {
> #line 165
>   tmp = current_thread_info();
> #line 165
>   tmp->preempt_count = tmp->preempt_count + 1;
> #line 165
>   __asm__  volatile   ("": : : "memory");
> #line 166
>   return;
> }
> }
> #line 168 "include/linux/rcupdate.h"
> __inline static void __rcu_read_unlock(void) 
> { 
>   struct thread_info *tmp ;
> 
>   {
> #line 170
>   __asm__  volatile   ("": : : "memory");
> #line 170
>   tmp = current_thread_info();
> #line 170
>   tmp->preempt_count = tmp->preempt_count + -1;
> #line 170
>   __asm__  volatile   ("": : : "memory");
> #line 171
>   return;
> }
> }
> #line 273
> extern int rcu_is_cpu_idle(void) ;
> #line 277
> extern bool rcu_lockdep_current_cpu_online(void) ;
> #line 287 "include/linux/rcupdate.h"
> __inline static void rcu_lock_acquire(struct lockdep_map *map ) 
> { 
> 
> 
>   {
> #line 289
>   lock_acquire(map, 0U, 0, 2, 1, 0, (unsigned long )((void *)0));
> #line 291
>   return;
> }
> }
> #line 292 "include/linux/rcupdate.h"
> __inline static void rcu_lock_release(struct lockdep_map *map ) 
> { 
> 
> 
>   {
> #line 294
>   lock_release(map, 1, (unsigned long )((void *)0));
> #line 296
>   return;
> }
> }
> #line 297
> extern struct lockdep_map rcu_lock_map ;
> #line 300
> extern int debug_lockdep_rcu_enabled(void) ;
> #line 322 "include/linux/rcupdate.h"
> __inline static int rcu_read_lock_held(void) 
> { 
>   int tmp ;
>   int tmp___0 ;
>   bool tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
> 
>   {
> #line 324
>   tmp = debug_lockdep_rcu_enabled();
> #line 324
>   if (tmp == 0) {
> #line 325
>     return (1);
>   } else {
> 
>   }
> #line 326
>   tmp___0 = rcu_is_cpu_idle();
> #line 326
>   if (tmp___0 != 0) {
> #line 327
>     return (0);
>   } else {
> 
>   }
> #line 328
>   tmp___1 = rcu_lockdep_current_cpu_online();
> #line 328
>   if (tmp___1) {
> #line 328
>     tmp___2 = 0;
>   } else {
> #line 328
>     tmp___2 = 1;
>   }
> #line 328
>   if (tmp___2) {
> #line 329
>     return (0);
>   } else {
> 
>   }
> #line 330
>   tmp___3 = lock_is_held(& rcu_lock_map);
> #line 330
>   return (tmp___3);
> }
> }
> #line 732 "include/linux/rcupdate.h"
> __inline static void rcu_read_lock(void) 
> { 
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
> 
>   {
> #line 734
>   __rcu_read_lock();
> #line 736
>   rcu_lock_acquire(& rcu_lock_map);
> #line 737
>   tmp = debug_lockdep_rcu_enabled();
> #line 737
>   if (tmp != 0 && ! __warned) {
> #line 737
>     tmp___0 = rcu_is_cpu_idle();
> #line 737
>     if (tmp___0 != 0) {
> #line 737
>       __warned = 1;
> #line 737
>       lockdep_rcu_suspicious("include/linux/rcupdate.h", 738, "rcu_read_lock() used illegally while idle");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 740
>   return;
> }
> }
> #line 756 "include/linux/rcupdate.h"
> __inline static void rcu_read_unlock(void) 
> { 
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
> 
>   {
> #line 758
>   tmp = debug_lockdep_rcu_enabled();
> #line 758
>   if (tmp != 0 && ! __warned) {
> #line 758
>     tmp___0 = rcu_is_cpu_idle();
> #line 758
>     if (tmp___0 != 0) {
> #line 758
>       __warned = 1;
> #line 758
>       lockdep_rcu_suspicious("include/linux/rcupdate.h", 759, "rcu_read_unlock() used illegally while idle");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 760
>   rcu_lock_release(& rcu_lock_map);
> #line 762
>   __rcu_read_unlock();
> #line 763
>   return;
> }
> }
8913,8946d9178
< #line 16 "include/linux/uaccess.h"
< __inline static void pagefault_disable(void) 
< { 
<   struct thread_info *tmp ;
< 
<   {
< #line 18
<   tmp = current_thread_info();
< #line 18
<   tmp->preempt_count = tmp->preempt_count + 1;
< #line 23
<   __asm__  volatile   ("": : : "memory");
< #line 24
<   return;
< }
< }
< #line 26 "include/linux/uaccess.h"
< __inline static void pagefault_enable(void) 
< { 
<   struct thread_info *tmp ;
< 
<   {
< #line 32
<   __asm__  volatile   ("": : : "memory");
< #line 33
<   tmp = current_thread_info();
< #line 33
<   tmp->preempt_count = tmp->preempt_count + -1;
< #line 37
<   __asm__  volatile   ("": : : "memory");
< #line 38
<   return;
< }
< }
8954c9186
<   pagefault_disable();
---
>   __rcu_read_lock();
8968c9200
<   pagefault_enable();
---
>   __rcu_read_unlock();
8985c9217,9220
< #line 67 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 120 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_state.h"
> enum drbd_state_rv __drbd_set_state(struct drbd_conf *mdev , union drbd_state ns ,
>                                     enum chg_state_flags flags , struct completion *done ) ;
> #line 70 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
8987c9222
< #line 68
---
> #line 71
8989c9224
< #line 135
---
> #line 148
8991c9226
< #line 138 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 151 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
8998c9233
< #line 140
---
> #line 153
9000c9235
< #line 140
---
> #line 153
9002c9237
< #line 140
---
> #line 153
9004c9239
< #line 140
---
> #line 153
9007c9242
< #line 140
---
> #line 153
9011c9246
< #line 140
---
> #line 153
9014c9249
< #line 140
---
> #line 153
9018c9253
< #line 158
---
> #line 166
9020,9025c9255,9256
< #line 1149 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void drbd_set_flag(struct drbd_conf *mdev , enum drbd_flag f ) 
< { 
< 
< 
<   {
---
> #line 1066
> char *drbd_task_to_thread_name(struct drbd_tconn *tconn , struct task_struct *task ) ;
9027,9047d9257
<   set_bit((unsigned int )f, (unsigned long volatile   *)(& mdev->drbd_flags));
< #line 1152
<   return;
< }
< }
< #line 1159 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int drbd_test_flag(struct drbd_conf *mdev , enum drbd_flag f ) 
< { 
<   int tmp ;
< 
<   {
< #line 1161
<   tmp = variable_test_bit((int )f, (unsigned long const volatile   *)(& mdev->drbd_flags));
< #line 1161
<   return (tmp);
< }
< }
< #line 1243
< enum drbd_state_rv __drbd_set_state(struct drbd_conf *mdev , union drbd_state ns ,
<                                     enum chg_state_flags flags , struct completion *done ) ;
< #line 1339
9049c9259
< #line 1340
---
> #line 1152
9051c9261
< #line 1483
---
> #line 1317
9053c9263
< #line 1484
---
> #line 1318
9055c9265
< #line 1485
---
> #line 1319
9057c9267
< #line 1486
---
> #line 1320
9059c9269
< #line 1487
---
> #line 1321
9061c9271
< #line 1489
---
> #line 1323
9063c9273
< #line 1491
---
> #line 1325
9065c9275
< #line 1493
---
> #line 1327
9067c9277
< #line 1497
---
> #line 1331
9069c9279
< #line 1499
---
> #line 1333
9071c9281
< #line 1500
---
> #line 1334
9073c9283
< #line 1501
---
> #line 1335
9075c9285
< #line 1502
---
> #line 1336
9077c9287,9289
< #line 1503
---
> #line 1337
> void drbd_bm_mark_for_writeout(struct drbd_conf *mdev , int page_nr ) ;
> #line 1338
9079c9291,9293
< #line 1504
---
> #line 1339
> int drbd_bm_write_hinted(struct drbd_conf *mdev ) ;
> #line 1340
9081c9295
< #line 1505
---
> #line 1341
9083,9085c9297
< #line 1506
< unsigned long drbd_bm_ALe_set_all(struct drbd_conf *mdev , unsigned long al_enr ) ;
< #line 1508
---
> #line 1342
9087c9299
< #line 1509
---
> #line 1343
9089c9301
< #line 1510
---
> #line 1344
9091c9303
< #line 1513
---
> #line 1347
9093c9305
< #line 1515
---
> #line 1349
9095c9307
< #line 1516
---
> #line 1350
9097c9309
< #line 1517
---
> #line 1351
9099c9311
< #line 1518
---
> #line 1352
9101c9313
< #line 1521
---
> #line 1355
9103c9315
< #line 1524
---
> #line 1358
9105c9317
< #line 1527
---
> #line 1361
9107c9319
< #line 1528
---
> #line 1362
9109c9321
< #line 1562
---
> #line 1396
9111c9323
< #line 1568
---
> #line 1402
9113c9325
< #line 1570
---
> #line 1404
9115c9327
< #line 1587
---
> #line 1432
9117c9329
< #line 1612
---
> #line 1459
9120c9332
< #line 1853 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1643 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
9127c9339
< #line 1858
---
> #line 1648
9129c9341
< #line 1859
---
> #line 1649
9131c9343
< #line 1860
---
> #line 1650
9133c9345,9363
< #line 1862
---
> #line 1652
>   return (rv);
> }
> }
> #line 1655 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static union drbd_state drbd_read_state(struct drbd_conf *mdev ) 
> { 
>   union drbd_state rv ;
> 
>   {
> #line 1659
>   rv.i = mdev->state.i;
> #line 1660
>   rv.ldv_40604.susp = (mdev->tconn)->susp;
> #line 1661
>   rv.ldv_40604.susp_nod = (mdev->tconn)->susp_nod;
> #line 1662
>   rv.ldv_40604.susp_fen = (mdev->tconn)->susp_fen;
> #line 1664
9137c9367
< #line 1890 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1675 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
9140a9371,9373
>   enum drbd_io_error_p ep ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
9141a9375,9376
>   int tmp___0 ;
>   int tmp___1 ;
9146,9149c9381,9411
< #line 1894
<   switch ((mdev->ldev)->dc.on_io_error) {
<   case 0: ;
< #line 1896
---
> #line 1681
>   rcu_read_lock();
> #line 1682
>   _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 1682
>   tmp = debug_lockdep_rcu_enabled();
> #line 1682
>   if (tmp != 0 && ! __warned) {
> #line 1682
>     tmp___0 = rcu_read_lock_held();
> #line 1682
>     if (tmp___0 == 0 && 1) {
> #line 1682
>       __warned = 1;
> #line 1682
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h",
>                              1682, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1682
>   ep = (enum drbd_io_error_p )_________p1->on_io_error;
> #line 1683
>   rcu_read_unlock();
> #line 1684
>   switch ((unsigned int )ep) {
>   case 0U: ;
> #line 1686
9151,9155c9413,9417
< #line 1897
<     tmp = ___ratelimit(& drbd_ratelimit_state, "__drbd_chk_io_error_");
< #line 1897
<     if (tmp != 0) {
< #line 1898
---
> #line 1687
>     tmp___1 = ___ratelimit(& drbd_ratelimit_state, "__drbd_chk_io_error_");
> #line 1687
>     if (tmp___1 != 0) {
> #line 1688
9161,9167c9423,9429
< #line 1899
<     if ((int )mdev->state.ldv_40583.disk > 4) {
< #line 1900
<       __ns.i = mdev->state.i;
< #line 1900
<       __ns.ldv_40583.disk = 4U;
< #line 1900
---
> #line 1689
>     if ((int )mdev->state.ldv_50103.disk > 4) {
> #line 1690
>       __ns = drbd_read_state(mdev);
> #line 1690
>       __ns.ldv_40604.disk = 4U;
> #line 1690
9172,9173c9434,9435
< #line 1901
<     goto ldv_50859;
---
> #line 1691
>     goto ldv_51375;
9177,9181c9439,9443
<   case 2: ;
<   case 1: 
< #line 1926
<   drbd_set_flag(mdev, WAS_IO_ERROR);
< #line 1927
---
>   case 2U: ;
>   case 1U: 
> #line 1716
>   set_bit(12U, (unsigned long volatile   *)(& mdev->flags));
> #line 1717
9183,9184c9445,9446
< #line 1928
<     drbd_set_flag(mdev, WAS_READ_ERROR);
---
> #line 1718
>     set_bit(13U, (unsigned long volatile   *)(& mdev->flags));
9188c9450
< #line 1929
---
> #line 1719
9190,9191c9452,9453
< #line 1930
<     drbd_set_flag(mdev, FORCE_DETACH);
---
> #line 1720
>     set_bit(14U, (unsigned long volatile   *)(& mdev->flags));
9195,9201c9457,9463
< #line 1931
<   if ((int )mdev->state.ldv_40583.disk > 2) {
< #line 1932
<     __ns___0.i = mdev->state.i;
< #line 1932
<     __ns___0.ldv_40583.disk = 2U;
< #line 1932
---
> #line 1721
>   if ((int )mdev->state.ldv_50103.disk > 2) {
> #line 1722
>     __ns___0 = drbd_read_state(mdev);
> #line 1722
>     __ns___0.ldv_40604.disk = 2U;
> #line 1722
9203c9465
< #line 1933
---
> #line 1723
9209,9210c9471,9472
< #line 1936
<   goto ldv_50859;
---
> #line 1726
>   goto ldv_51375;
9212,9213c9474,9475
<   ldv_50859: ;
< #line 1939
---
>   ldv_51375: ;
> #line 1729
9217c9479
< #line 1949 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1739 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
9225c9487
< #line 1952
---
> #line 1742
9227,9229c9489,9491
< #line 1954
<     tmp = spinlock_check(& mdev->req_lock);
< #line 1954
---
> #line 1744
>     tmp = spinlock_check(& (mdev->tconn)->req_lock);
> #line 1744
9231c9493
< #line 1955
---
> #line 1745
9233,9234c9495,9496
< #line 1956
<     spin_unlock_irqrestore(& mdev->req_lock, flags);
---
> #line 1746
>     spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
9238c9500
< #line 1958
---
> #line 1748
9242c9504
< #line 1984 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1785 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
9245c9507,9511
< 
---
>   int meta_dev_idx ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
9248,9249c9514,9542
< #line 1986
<   switch (bdev->dc.meta_dev_idx) {
---
> #line 1789
>   rcu_read_lock();
> #line 1790
>   _________p1 = *((struct disk_conf * volatile  *)(& bdev->disk_conf));
> #line 1790
>   tmp = debug_lockdep_rcu_enabled();
> #line 1790
>   if (tmp != 0 && ! __warned) {
> #line 1790
>     tmp___0 = rcu_read_lock_held();
> #line 1790
>     if (tmp___0 == 0 && 1) {
> #line 1790
>       __warned = 1;
> #line 1790
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h",
>                              1790, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1790
>   meta_dev_idx = _________p1->meta_dev_idx;
> #line 1791
>   rcu_read_unlock();
> #line 1793
>   switch (meta_dev_idx) {
9252c9545
< #line 1989
---
> #line 1796
9256c9549
< #line 1992
---
> #line 1799
9261c9554
< #line 2247 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2043 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
9268c9561
< #line 2249
---
> #line 2045
9270c9563
< #line 2249
---
> #line 2045
9272c9565
< #line 2255
---
> #line 2051
9274c9567
< #line 2255
---
> #line 2051
9277c9570
<             2255);
---
>             2051);
9281c9574
< #line 2256
---
> #line 2052
9283,9285c9576,9578
< #line 2257
<     if ((unsigned int )*((unsigned char *)mdev + 2277UL) == 0U) {
< #line 2259
---
> #line 2053
>     if ((unsigned int )*((unsigned char *)mdev + 749UL) == 0U) {
> #line 2055
9290,9292c9583,9585
< #line 2260
<     if ((unsigned int )*((unsigned char *)mdev + 2277UL) == 4U) {
< #line 2262
---
> #line 2056
>     if ((unsigned int )*((unsigned char *)mdev + 749UL) == 4U) {
> #line 2058
9297c9590
< #line 2263
---
> #line 2059
9302c9595
< #line 2265
---
> #line 2061
9306c9599
< #line 2268 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2064 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
9312,9314c9605,9607
< #line 2273
<   if ((unsigned int )*((unsigned char *)mdev + 2277UL) == 0U) {
< #line 2274
---
> #line 2069
>   if ((unsigned int )*((unsigned char *)mdev + 749UL) == 0U) {
> #line 2070
9319c9612
< #line 2276
---
> #line 2072
9321,9323c9614,9616
< #line 2277
<   io_allowed = (unsigned int )mdev->state.ldv_40583.disk >= (unsigned int )mins;
< #line 2278
---
> #line 2073
>   io_allowed = (unsigned int )mdev->state.ldv_50103.disk >= (unsigned int )mins;
> #line 2074
9325c9618
< #line 2279
---
> #line 2075
9330c9623
< #line 2280
---
> #line 2076
9334c9627
< #line 2544 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2317 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
9341,9343c9634,9645
< #line 2548
<   tmp = drbd_test_flag(mdev, MD_NO_FUA);
< #line 2548
---
> #line 2321
>   if ((unsigned long )mdev->ldev == (unsigned long )((struct drbd_backing_dev *)0)) {
> #line 2322
>     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "mdev->ldev == NULL in drbd_md_flush\n");
> #line 2323
>     return;
>   } else {
> 
>   }
> #line 2326
>   tmp = constant_test_bit(7U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2326
9345c9647
< #line 2549
---
> #line 2327
9350c9652
< #line 2551
---
> #line 2329
9352c9654
< #line 2552
---
> #line 2330
9354,9356c9656,9658
< #line 2553
<     drbd_set_flag(mdev, MD_NO_FUA);
< #line 2554
---
> #line 2331
>     set_bit(7U, (unsigned long volatile   *)(& mdev->flags));
> #line 2332
9362c9664
< #line 2556
---
> #line 2334
9366c9668
< #line 123 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 123 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9371,9377c9673,9675
<   struct task_struct *tmp___3 ;
<   char *tmp___4 ;
<   struct task_struct *tmp___5 ;
<   char *tmp___6 ;
<   struct task_struct *tmp___7 ;
<   char *tmp___8 ;
<   struct task_struct *tmp___9 ;
---
>   char *tmp___0 ;
>   struct task_struct *tmp___1 ;
>   char *tmp___2 ;
9392,9398c9690
<   tmp___9 = get_current();
< #line 128
<   if ((unsigned long )tmp___9 != (unsigned long )mdev->receiver.task) {
< #line 128
<     tmp___7 = get_current();
< #line 128
<     if ((unsigned long )tmp___7 != (unsigned long )mdev->asender.task) {
---
>   tmp___0 = drbd_task_to_thread_name(mdev->tconn, b->bm_task);
9400,9419c9692
<       tmp___5 = get_current();
< #line 128
<       if ((unsigned long )tmp___5 != (unsigned long )mdev->worker.task) {
< #line 128
<         tmp___3 = get_current();
< #line 128
<         tmp___4 = (char *)(& tmp___3->comm);
<       } else {
< #line 128
<         tmp___4 = (char *)"worker";
<       }
< #line 128
<       tmp___6 = tmp___4;
<     } else {
< #line 128
<       tmp___6 = (char *)"asender";
<     }
< #line 128
<     tmp___8 = tmp___6;
<   } else {
---
>   tmp___1 = get_current();
9421,9422c9694
<     tmp___8 = (char *)"receiver";
<   }
---
>   tmp___2 = drbd_task_to_thread_name(mdev->tconn, tmp___1);
9425,9427c9697,9699
<           tmp___8, func, (unsigned long )b->bm_why != (unsigned long )((char *)0) ? b->bm_why : (char *)"?",
<           (unsigned long )b->bm_task != (unsigned long )mdev->receiver.task ? ((unsigned long )b->bm_task != (unsigned long )mdev->asender.task ? ((unsigned long )b->bm_task == (unsigned long )mdev->worker.task ? (char *)"worker" : (char *)"?") : (char *)"asender") : (char *)"receiver");
< #line 134
---
>           tmp___2, func, (unsigned long )b->bm_why != (unsigned long )((char *)0) ? b->bm_why : (char *)"?",
>           tmp___0);
> #line 132
9431c9703
< #line 138 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 134 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9437,9443c9709,9711
<   struct task_struct *tmp___3 ;
<   char *tmp___4 ;
<   struct task_struct *tmp___5 ;
<   char *tmp___6 ;
<   struct task_struct *tmp___7 ;
<   char *tmp___8 ;
<   struct task_struct *tmp___9 ;
---
>   char *tmp___0 ;
>   struct task_struct *tmp___1 ;
>   char *tmp___2 ;
9446c9714
< #line 140
---
> #line 136
9448c9716
< #line 143
---
> #line 139
9450c9718
< #line 144
---
> #line 140
9452c9720
< #line 145
---
> #line 141
9457c9725
< #line 148
---
> #line 144
9459c9727
< #line 148
---
> #line 144
9461c9729
< #line 150
---
> #line 146
9463,9495c9731,9737
< #line 151
<     tmp___9 = get_current();
< #line 151
<     if ((unsigned long )tmp___9 != (unsigned long )mdev->receiver.task) {
< #line 151
<       tmp___7 = get_current();
< #line 151
<       if ((unsigned long )tmp___7 != (unsigned long )mdev->asender.task) {
< #line 151
<         tmp___5 = get_current();
< #line 151
<         if ((unsigned long )tmp___5 != (unsigned long )mdev->worker.task) {
< #line 151
<           tmp___3 = get_current();
< #line 151
<           tmp___4 = (char *)(& tmp___3->comm);
<         } else {
< #line 151
<           tmp___4 = (char *)"worker";
<         }
< #line 151
<         tmp___6 = tmp___4;
<       } else {
< #line 151
<         tmp___6 = (char *)"asender";
<       }
< #line 151
<       tmp___8 = tmp___6;
<     } else {
< #line 151
<       tmp___8 = (char *)"receiver";
<     }
< #line 151
---
> #line 147
>     tmp___0 = drbd_task_to_thread_name(mdev->tconn, b->bm_task);
> #line 147
>     tmp___1 = get_current();
> #line 147
>     tmp___2 = drbd_task_to_thread_name(mdev->tconn, tmp___1);
> #line 147
9497,9499c9739,9741
<              tmp___8, why, (unsigned long )b->bm_why != (unsigned long )((char *)0) ? b->bm_why : (char *)"?",
<              (unsigned long )b->bm_task != (unsigned long )mdev->receiver.task ? ((unsigned long )b->bm_task != (unsigned long )mdev->asender.task ? ((unsigned long )b->bm_task == (unsigned long )mdev->worker.task ? (char *)"worker" : (char *)"?") : (char *)"asender") : (char *)"receiver");
< #line 159
---
>              tmp___2, why, (unsigned long )b->bm_why != (unsigned long )((char *)0) ? b->bm_why : (char *)"?",
>              tmp___0);
> #line 151
9504c9746
< #line 161
---
> #line 153
9506c9748
< #line 162
---
> #line 154
9511c9753
< #line 163
---
> #line 155
9513c9755
< #line 165
---
> #line 157
9515c9757
< #line 166
---
> #line 158
9517c9759
< #line 167
---
> #line 159
9521c9763
< #line 169 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 161 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9527c9769
< #line 171
---
> #line 163
9529c9771
< #line 172
---
> #line 164
9531c9773
< #line 173
---
> #line 165
9533c9775
< #line 174
---
> #line 166
9538c9780
< #line 177
---
> #line 169
9540c9782
< #line 178
---
> #line 170
9545c9787
< #line 180
---
> #line 172
9547c9789
< #line 181
---
> #line 173
9549c9791
< #line 182
---
> #line 174
9551c9793
< #line 183
---
> #line 175
9553c9795
< #line 184
---
> #line 176
9557c9799
< #line 212 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 207 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9563c9805
< #line 214
---
> #line 209
9565c9807
< #line 214
---
> #line 209
9567,9572c9809,9814
< #line 214
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"),
<                          "i" (214), "i" (12UL));
<     ldv_51130: ;
< #line 214
<     goto ldv_51130;
---
> #line 209
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"),
>                          "i" (209), "i" (12UL));
>     ldv_51692: ;
> #line 209
>     goto ldv_51692;
9576c9818
< #line 215
---
> #line 210
9578c9820
< #line 216
---
> #line 211
9582c9824
< #line 218 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 213 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9588c9830
< #line 220
---
> #line 215
9592c9834
< #line 226 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 221 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9603c9845
< #line 228
---
> #line 223
9605c9847
< #line 229
---
> #line 224
9607c9849
< #line 230
---
> #line 225
9609c9851
< #line 230
---
> #line 225
9611,9612c9853,9854
< #line 230
<     goto ldv_51140;
---
> #line 225
>     goto ldv_51702;
9616c9858
< #line 230
---
> #line 225
9618c9860
< #line 230
---
> #line 225
9620c9862
< #line 230
---
> #line 225
9622c9864
< #line 230
---
> #line 225
9624c9866
< #line 230
---
> #line 225
9626c9868
< #line 230
---
> #line 225
9628,9629c9870,9871
<   ldv_51143: 
< #line 230
---
>   ldv_51705: 
> #line 225
9631c9873
< #line 230
---
> #line 225
9633c9875
< #line 230
---
> #line 225
9635,9636c9877,9878
< #line 230
<     goto ldv_51142;
---
> #line 225
>     goto ldv_51704;
9640c9882
< #line 230
---
> #line 225
9642,9645c9884,9887
< #line 230
<   goto ldv_51143;
<   ldv_51142: 
< #line 230
---
> #line 225
>   goto ldv_51705;
>   ldv_51704: 
> #line 225
9647,9648c9889,9890
<   ldv_51140: ;
< #line 233
---
>   ldv_51702: ;
> #line 228
9652c9894
< #line 233 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 228 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9659c9901
< #line 235
---
> #line 230
9661c9903
< #line 236
---
> #line 231
9663,9667c9905,9907
< #line 237
<   clear_bit(31, (unsigned long volatile   *)addr);
< #line 238
<   __asm__  volatile   ("": : : "memory");
< #line 239
---
> #line 232
>   clear_bit_unlock(31U, (unsigned long volatile   *)addr);
> #line 233
9669c9909
< #line 240
---
> #line 234
9673c9913
< #line 244 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 238 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9679c9919
< #line 247
---
> #line 241
9681c9921
< #line 248
---
> #line 242
9683c9923
< #line 249
---
> #line 243
9687c9927
< #line 251 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 245 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9693c9933
< #line 253
---
> #line 247
9695c9935,9959
< #line 254
---
> #line 248
>   return;
> }
> }
> #line 259 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
> void drbd_bm_mark_for_writeout(struct drbd_conf *mdev , int page_nr ) 
> { 
>   struct page *page ;
> 
>   {
> #line 262
>   if ((size_t )page_nr >= (mdev->bitmap)->bm_number_of_pages) {
> #line 263
>     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "BAD: page_nr: %u, number_of_pages: %u\n",
>              page_nr, (int )(mdev->bitmap)->bm_number_of_pages);
> #line 265
>     return;
>   } else {
> 
>   }
> #line 267
>   page = *((mdev->bitmap)->bm_pages + (unsigned long )page_nr);
> #line 268
>   set_bit(27U, (unsigned long volatile   *)(& page->ldv_16348.private));
> #line 269
9699c9963
< #line 256 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 271 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9705c9969
< #line 258
---
> #line 273
9707c9971
< #line 259
---
> #line 274
9711c9975
< #line 262 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 277 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9717c9981
< #line 264
---
> #line 279
9719c9983
< #line 265
---
> #line 280
9723c9987
< #line 267 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 282 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9729c9993
< #line 269
---
> #line 284
9731c9995
< #line 270
---
> #line 285
9735c9999
< #line 272 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 287 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9741c10005
< #line 274
---
> #line 289
9743c10007
< #line 275
---
> #line 290
9747c10011
< #line 277 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 292 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9753c10017
< #line 279
---
> #line 294
9755c10019
< #line 279
---
> #line 294
9759c10023
< #line 283 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 298 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9766c10030
< #line 286
---
> #line 301
9768c10032
< #line 287
---
> #line 302
9770c10034
< #line 287
---
> #line 302
9772,9777c10036,10041
< #line 287
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"),
<                          "i" (287), "i" (12UL));
<     ldv_51177: ;
< #line 287
<     goto ldv_51177;
---
> #line 302
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"),
>                          "i" (302), "i" (12UL));
>     ldv_51744: ;
> #line 302
>     goto ldv_51744;
9781c10045
< #line 288
---
> #line 303
9785c10049
< #line 291 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 306 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9792c10056
< #line 294
---
> #line 309
9794c10058
< #line 295
---
> #line 310
9796c10060
< #line 295
---
> #line 310
9798,9803c10062,10067
< #line 295
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"),
<                          "i" (295), "i" (12UL));
<     ldv_51183: ;
< #line 295
<     goto ldv_51183;
---
> #line 310
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"),
>                          "i" (310), "i" (12UL));
>     ldv_51750: ;
> #line 310
>     goto ldv_51750;
9807c10071
< #line 296
---
> #line 311
9811c10075
< #line 299 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 314 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9818c10082
< #line 301
---
> #line 316
9820c10084
< #line 302
---
> #line 317
9822c10086
< #line 302
---
> #line 317
9826c10090
< #line 305 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 320 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9832c10096
< #line 307
---
> #line 322
9834c10098
< #line 307
---
> #line 322
9838c10102
< #line 310 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 325 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9844c10108
< #line 312
---
> #line 327
9846c10110
< #line 313
---
> #line 328
9850c10114
< #line 315 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 330 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9856c10120
< #line 317
---
> #line 332
9860c10124
< #line 340 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 355 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9866c10130
< #line 343
---
> #line 358
9868c10132
< #line 344
---
> #line 359
9873c10137
< #line 346
---
> #line 361
9875,9878c10139,10142
< #line 346
<   goto ldv_51206;
<   ldv_51205: ;
< #line 347
---
> #line 361
>   goto ldv_51773;
>   ldv_51772: ;
> #line 362
9880c10144
< #line 348
---
> #line 363
9883,9884c10147,10148
< #line 351
<     goto ldv_51204;
---
> #line 366
>     goto ldv_51771;
9888c10152
< #line 353
---
> #line 368
9890c10154
< #line 354
---
> #line 369
9892,9893c10156,10157
<   ldv_51204: 
< #line 346
---
>   ldv_51771: 
> #line 361
9895,9896c10159,10160
<   ldv_51206: ;
< #line 346
---
>   ldv_51773: ;
> #line 361
9898,9899c10162,10163
< #line 347
<     goto ldv_51205;
---
> #line 362
>     goto ldv_51772;
9904c10168
< #line 351
---
> #line 366
9908c10172
< #line 358 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 373 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9914c10178
< #line 360
---
> #line 375
9916c10180
< #line 361
---
> #line 376
9919c10183
< #line 363
---
> #line 378
9922c10186
< #line 364
---
> #line 379
9926c10190
< #line 369 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 384 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
9945c10209
< #line 371
---
> #line 386
9947c10211
< #line 373
---
> #line 388
9949c10213
< #line 374
---
> #line 389
9951c10215
< #line 376
---
> #line 391
9953c10217
< #line 376
---
> #line 391
9955c10219
< #line 376
---
> #line 391
9958c10222
< #line 376
---
> #line 391
9960,9965c10224,10229
< #line 376
<       __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"),
<                            "i" (376), "i" (12UL));
<       ldv_51223: ;
< #line 376
<       goto ldv_51223;
---
> #line 391
>       __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"),
>                            "i" (391), "i" (12UL));
>       ldv_51790: ;
> #line 391
>       goto ldv_51790;
9972c10236
< #line 377
---
> #line 392
9974c10238
< #line 377
---
> #line 392
9976c10240
< #line 377
---
> #line 392
9979c10243
< #line 377
---
> #line 392
9981,9986c10245,10250
< #line 377
<       __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"),
<                            "i" (377), "i" (12UL));
<       ldv_51224: ;
< #line 377
<       goto ldv_51224;
---
> #line 392
>       __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"),
>                            "i" (392), "i" (12UL));
>       ldv_51791: ;
> #line 392
>       goto ldv_51791;
9993c10257
< #line 379
---
> #line 394
9995c10259
< #line 380
---
> #line 395
10000c10264
< #line 387
---
> #line 402
10002c10266
< #line 388
---
> #line 403
10004c10268
< #line 388
---
> #line 403
10006c10270
< #line 389
---
> #line 404
10008c10272
< #line 390
---
> #line 405
10010c10274
< #line 390
---
> #line 405
10012c10276
< #line 390
---
> #line 405
10014c10278
< #line 393
---
> #line 408
10016c10280
< #line 394
---
> #line 409
10021c10285
< #line 395
---
> #line 410
10026c10290
< #line 398
---
> #line 413
10028c10292
< #line 399
---
> #line 414
10030,10033c10294,10297
< #line 399
<     goto ldv_51227;
<     ldv_51226: 
< #line 400
---
> #line 414
>     goto ldv_51794;
>     ldv_51793: 
> #line 415
10035c10299
< #line 399
---
> #line 414
10037,10038c10301,10302
<     ldv_51227: ;
< #line 399
---
>     ldv_51794: ;
> #line 414
10040,10041c10304,10305
< #line 400
<       goto ldv_51226;
---
> #line 415
>       goto ldv_51793;
10046,10049c10310,10313
< #line 401
<     goto ldv_51230;
<     ldv_51229: 
< #line 402
---
> #line 416
>     goto ldv_51797;
>     ldv_51796: 
> #line 417
10051c10315
< #line 403
---
> #line 418
10053c10317
< #line 404
---
> #line 419
10055c10319
< #line 405
---
> #line 420
10057c10321
< #line 406
---
> #line 421
10062c10326
< #line 410
---
> #line 425
10064c10328
< #line 411
---
> #line 426
10066c10330
< #line 401
---
> #line 416
10068,10069c10332,10333
<     ldv_51230: ;
< #line 401
---
>     ldv_51797: ;
> #line 416
10071,10072c10335,10336
< #line 402
<       goto ldv_51229;
---
> #line 417
>       goto ldv_51796;
10078c10342
< #line 414
---
> #line 429
10080,10083c10344,10347
< #line 414
<     goto ldv_51233;
<     ldv_51232: 
< #line 415
---
> #line 429
>     goto ldv_51800;
>     ldv_51799: 
> #line 430
10085c10349
< #line 414
---
> #line 429
10087,10088c10351,10352
<     ldv_51233: ;
< #line 414
---
>     ldv_51800: ;
> #line 429
10090,10091c10354,10355
< #line 415
<       goto ldv_51232;
---
> #line 430
>       goto ldv_51799;
10097c10361
< #line 421
---
> #line 436
10099c10363
< #line 422
---
> #line 437
10102c10366
< #line 424
---
> #line 439
10105c10369
< #line 426
---
> #line 441
10109c10373
< #line 433 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 448 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10121c10385
< #line 435
---
> #line 450
10123c10387
< #line 436
---
> #line 451
10125c10389
< #line 436
---
> #line 451
10127c10391
< #line 436
---
> #line 451
10129,10131c10393,10395
< #line 436
<     warn_slowpath_null("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<                        436);
---
> #line 451
>     warn_slowpath_null("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
>                        451);
10135c10399
< #line 436
---
> #line 451
10137c10401
< #line 437
---
> #line 452
10139c10403
< #line 437
---
> #line 452
10141c10405
< #line 438
---
> #line 453
10143c10407
< #line 439
---
> #line 454
10148c10412
< #line 440
---
> #line 455
10150c10414
< #line 440
---
> #line 455
10152c10416
< #line 441
---
> #line 456
10154c10418
< #line 442
---
> #line 457
10156c10420
< #line 444
---
> #line 459
10158c10422
< #line 446
---
> #line 461
10162c10426
< #line 449 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 464 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10165c10429,10430
<   int _b ;
---
>   bool _bool ;
>   int tmp ;
10168,10175c10433,10439
< #line 451
<   _b = (unsigned long )mdev->bitmap == (unsigned long )((struct drbd_bitmap *)0);
< #line 451
<   if (_b != 0) {
< #line 451
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_capacity", (char *)"!mdev->bitmap", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             451);
---
> #line 466
>   _bool = (unsigned long )mdev->bitmap != (unsigned long )((struct drbd_bitmap *)0);
> #line 466
>   if (! _bool) {
> #line 466
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"mdev->bitmap", "drbd_bm_capacity");
10179,10181c10443,10453
< #line 451
<   if (_b != 0) {
< #line 451
---
> #line 466
>   if (_bool) {
> #line 466
>     tmp = 0;
>   } else {
> #line 466
>     tmp = 1;
>   }
> #line 466
>   if (tmp) {
> #line 467
10186c10458
< #line 452
---
> #line 468
10190c10462
< #line 457 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 473 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10193c10465,10466
<   int _b ;
---
>   bool _bool ;
>   int tmp ;
10196,10203c10469,10475
< #line 459
<   _b = (unsigned long )mdev->bitmap == (unsigned long )((struct drbd_bitmap *)0);
< #line 459
<   if (_b != 0) {
< #line 459
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_cleanup", (char *)"!mdev->bitmap", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             459);
---
> #line 475
>   _bool = (unsigned long )mdev->bitmap != (unsigned long )((struct drbd_bitmap *)0);
> #line 475
>   if (! _bool) {
> #line 475
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"mdev->bitmap", "drbd_bm_cleanup");
10207,10209c10479,10489
< #line 459
<   if (_b != 0) {
< #line 459
---
> #line 475
>   if (_bool) {
> #line 475
>     tmp = 0;
>   } else {
> #line 475
>     tmp = 1;
>   }
> #line 475
>   if (tmp) {
> #line 476
10214c10494
< #line 460
---
> #line 477
10216c10496
< #line 461
---
> #line 478
10218c10498
< #line 462
---
> #line 479
10220c10500
< #line 463
---
> #line 480
10222c10502
< #line 464
---
> #line 481
10226c10506
< #line 474 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 491 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10237c10517
< #line 479
---
> #line 496
10239c10519
< #line 482
---
> #line 499
10241c10521
< #line 484
---
> #line 501
10243c10523
< #line 487
---
> #line 504
10245c10525
< #line 489
---
> #line 506
10247c10527
< #line 490
---
> #line 507
10249c10529
< #line 491
---
> #line 508
10251c10531
< #line 496
---
> #line 513
10253c10533
< #line 496
---
> #line 513
10255c10535
< #line 497
---
> #line 514
10257c10537
< #line 498
---
> #line 515
10262c10542
< #line 507
---
> #line 524
10264c10544
< #line 508
---
> #line 525
10268c10548
< #line 511 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 528 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10277c10557
< #line 518
---
> #line 535
10279c10559
< #line 520
---
> #line 537
10281c10561
< #line 523
---
> #line 540
10283c10563
< #line 525
---
> #line 542
10285c10565
< #line 526
---
> #line 543
10287c10567
< #line 527
---
> #line 544
10289c10569
< #line 532
---
> #line 549
10291c10571
< #line 533
---
> #line 550
10296c10576
< #line 541
---
> #line 558
10298c10578
< #line 542
---
> #line 559
10302c10582
< #line 546 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 563 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10316c10596
< #line 549
---
> #line 566
10318c10598
< #line 550
---
> #line 567
10320c10600
< #line 554
---
> #line 571
10322,10325c10602,10605
< #line 554
<   goto ldv_51285;
<   ldv_51284: 
< #line 555
---
> #line 571
>   goto ldv_51852;
>   ldv_51851: 
> #line 572
10327c10607
< #line 556
---
> #line 573
10329,10332c10609,10612
< #line 556
<   goto ldv_51281;
<   ldv_51280: 
< #line 557
---
> #line 573
>   goto ldv_51848;
>   ldv_51847: 
> #line 574
10334c10614
< #line 557
---
> #line 574
10336c10616
< #line 556
---
> #line 573
10338,10339c10618,10619
<   ldv_51281: ;
< #line 556
---
>   ldv_51848: ;
> #line 573
10341,10342c10621,10622
< #line 557
<     goto ldv_51280;
---
> #line 574
>     goto ldv_51847;
10346c10626
< #line 558
---
> #line 575
10348,10351c10628,10631
< #line 559
<   __might_sleep("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<                 559, 0);
< #line 559
---
> #line 576
>   __might_sleep("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
>                 576, 0);
> #line 576
10353c10633
< #line 554
---
> #line 571
10355,10356c10635,10636
<   ldv_51285: ;
< #line 554
---
>   ldv_51852: ;
> #line 571
10358,10359c10638,10639
< #line 555
<     goto ldv_51284;
---
> #line 572
>     goto ldv_51851;
10363c10643
< #line 562
---
> #line 579
10365c10645
< #line 563
---
> #line 580
10367c10647
< #line 564
---
> #line 581
10369,10372c10649,10652
< #line 564
<   goto ldv_51288;
<   ldv_51287: 
< #line 565
---
> #line 581
>   goto ldv_51855;
>   ldv_51854: 
> #line 582
10374c10654
< #line 565
---
> #line 582
10376c10656
< #line 564
---
> #line 581
10378,10379c10658,10659
<   ldv_51288: ;
< #line 564
---
>   ldv_51855: ;
> #line 581
10381,10382c10661,10662
< #line 565
<     goto ldv_51287;
---
> #line 582
>     goto ldv_51854;
10386c10666
< #line 566
---
> #line 583
10388c10668
< #line 567
---
> #line 584
10390c10670
< #line 567
---
> #line 584
10392c10672
< #line 571
---
> #line 588
10394c10674
< #line 572
---
> #line 589
10398c10678
< #line 576 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 593 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10410c10690
< #line 582
---
> #line 599
10412c10692
< #line 584
---
> #line 601
10414c10694
< #line 585
---
> #line 602
10416c10696
< #line 586
---
> #line 603
10421,10424c10701,10704
< #line 589
<   goto ldv_51305;
<   ldv_51304: 
< #line 590
---
> #line 606
>   goto ldv_51872;
>   ldv_51871: 
> #line 607
10426c10706
< #line 590
---
> #line 607
10428c10708
< #line 590
---
> #line 607
10430c10710
< #line 591
---
> #line 608
10432c10712
< #line 592
---
> #line 609
10434c10714
< #line 593
---
> #line 610
10436c10716
< #line 594
---
> #line 611
10438c10718
< #line 595
---
> #line 612
10441c10721
< #line 598
---
> #line 615
10444c10724
< #line 599
---
> #line 616
10446c10726
< #line 600
---
> #line 617
10448c10728
< #line 601
---
> #line 618
10450,10451c10730,10731
<   ldv_51305: ;
< #line 589
---
>   ldv_51872: ;
> #line 606
10453,10454c10733,10734
< #line 590
<     goto ldv_51304;
---
> #line 607
>     goto ldv_51871;
10459c10739
< #line 594
---
> #line 611
10463c10743
< #line 613 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 630 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10479,10480c10759,10760
<   int _b ;
<   unsigned long tmp ;
---
>   bool _bool ;
>   int tmp ;
10482,10483c10762,10764
<   size_t tmp___1 ;
<   sector_t tmp___2 ;
---
>   unsigned long tmp___1 ;
>   size_t tmp___2 ;
>   sector_t tmp___3 ;
10485d10765
<   int tmp___3 ;
10486a10767
>   int tmp___5 ;
10489c10770
< #line 615
---
> #line 632
10491c10772
< #line 618
---
> #line 635
10493c10774
< #line 619
---
> #line 636
10495,10502c10776,10782
< #line 622
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 622
<   if (_b != 0) {
< #line 622
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_resize", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             622);
---
> #line 639
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 639
>   if (! _bool) {
> #line 639
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "drbd_bm_resize");
10506,10508c10786,10796
< #line 622
<   if (_b != 0) {
< #line 622
---
> #line 639
>   if (_bool) {
> #line 639
>     tmp = 0;
>   } else {
> #line 639
>     tmp = 1;
>   }
> #line 639
>   if (tmp) {
> #line 640
10513c10801
< #line 624
---
> #line 642
10515c10803
< #line 626
---
> #line 644
10518c10806
< #line 629
---
> #line 647
10520c10808
< #line 630
---
> #line 648
10525c10813
< #line 632
---
> #line 650
10527c10815
< #line 634
---
> #line 652
10529c10817
< #line 635
---
> #line 653
10531c10819
< #line 636
---
> #line 654
10533c10821
< #line 637
---
> #line 655
10535c10823
< #line 638
---
> #line 656
10537c10825
< #line 639
---
> #line 657
10539,10543c10827,10835
< #line 640
<     tmp___2 = 0UL;
< #line 640
<     b->bm_dev_capacity = tmp___2;
< #line 640
---
> #line 658
>     tmp___3 = 0UL;
> #line 658
>     b->bm_dev_capacity = tmp___3;
> #line 658
>     tmp___2 = tmp___3;
> #line 658
>     b->bm_words = tmp___2;
> #line 658
10545,10547c10837,10839
< #line 640
<     b->bm_words = tmp___1;
< #line 640
---
> #line 658
>     b->bm_bits = tmp___1;
> #line 658
10549,10557c10841,10845
< #line 640
<     b->bm_bits = tmp___0;
< #line 640
<     tmp = tmp___0;
< #line 640
<     b->bm_set = tmp;
< #line 640
<     b->bm_number_of_pages = tmp;
< #line 645
---
> #line 658
>     b->bm_set = tmp___0;
> #line 658
>     b->bm_number_of_pages = tmp___0;
> #line 663
10559c10847
< #line 646
---
> #line 664
10561c10849
< #line 647
---
> #line 665
10563c10851
< #line 648
---
> #line 666
10568c10856
< #line 650
---
> #line 668
10570c10858
< #line 657
---
> #line 675
10572,10576c10860,10864
< #line 659
<   tmp___3 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 659
<   if (tmp___3 != 0) {
< #line 660
---
> #line 677
>   tmp___4 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 677
>   if (tmp___4 != 0) {
> #line 678
10578c10866
< #line 661
---
> #line 679
10580c10868
< #line 662
---
> #line 680
10582c10870
< #line 663
---
> #line 681
10585c10873
< #line 664
---
> #line 682
10588c10876
< #line 665
---
> #line 683
10590c10878
< #line 666
---
> #line 684
10598c10886
< #line 670
---
> #line 688
10600c10888
< #line 671
---
> #line 689
10602c10890
< #line 672
---
> #line 690
10604c10892
< #line 673
---
> #line 691
10606c10894
< #line 673
---
> #line 691
10608,10609c10896,10897
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<               673);
---
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
>               691);
10613c10901
< #line 674
---
> #line 692
10616,10620c10904,10908
< #line 676
<     tmp___4 = drbd_insert_fault(mdev, 7U);
< #line 676
<     if (tmp___4 != 0) {
< #line 677
---
> #line 694
>     tmp___5 = drbd_insert_fault(mdev, 7U);
> #line 694
>     if (tmp___5 != 0) {
> #line 695
10623c10911
< #line 679
---
> #line 697
10627c10915
< #line 682
---
> #line 700
10629c10917
< #line 683
---
> #line 701
10631c10919
< #line 684
---
> #line 702
10636c10924
< #line 687
---
> #line 705
10638c10926
< #line 688
---
> #line 706
10640c10928
< #line 689
---
> #line 707
10642c10930
< #line 690
---
> #line 708
10644c10932
< #line 692
---
> #line 710
10646c10934
< #line 693
---
> #line 711
10648c10936
< #line 694
---
> #line 712
10653c10941
< #line 696
---
> #line 714
10655c10943
< #line 697
---
> #line 715
10657c10945
< #line 698
---
> #line 716
10659c10947
< #line 699
---
> #line 717
10661c10949
< #line 700
---
> #line 718
10663c10951
< #line 702
---
> #line 720
10665c10953
< #line 703
---
> #line 721
10667c10955
< #line 704
---
> #line 722
10669c10957
< #line 705
---
> #line 723
10672c10960
< #line 707
---
> #line 725
10678c10966
< #line 711
---
> #line 729
10680c10968
< #line 713
---
> #line 731
10685c10973
< #line 716
---
> #line 734
10687c10975
< #line 718
---
> #line 736
10689c10977
< #line 719
---
> #line 737
10691c10979
< #line 720
---
> #line 738
10696c10984
< #line 721
---
> #line 739
10698c10986
< #line 722
---
> #line 740
10703c10991
< #line 723
---
> #line 741
10707c10995
< #line 726
---
> #line 744
10709c10997
< #line 727
---
> #line 745
10713c11001
< #line 738 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 756 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10719,10721c11007,11011
<   int _b ;
<   int _b___0 ;
<   raw_spinlock_t *tmp ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
>   raw_spinlock_t *tmp___1 ;
10724c11014
< #line 740
---
> #line 758
10726,10733c11016,11022
< #line 744
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 744
<   if (_b != 0) {
< #line 744
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "_drbd_bm_total_weight", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             744);
---
> #line 762
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 762
>   if (! _bool) {
> #line 762
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "_drbd_bm_total_weight");
10737,10739c11026,11036
< #line 744
<   if (_b != 0) {
< #line 744
---
> #line 762
>   if (_bool) {
> #line 762
>     tmp = 0;
>   } else {
> #line 762
>     tmp = 1;
>   }
> #line 762
>   if (tmp) {
> #line 763
10744,10751c11041,11047
< #line 745
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 745
<   if (_b___0 != 0) {
< #line 745
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "_drbd_bm_total_weight", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             745);
---
> #line 764
>   _bool___0 = (unsigned long )b->bm_pages != (unsigned long )((struct page **)0);
> #line 764
>   if (! _bool___0) {
> #line 764
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b->bm_pages", "_drbd_bm_total_weight");
10755,10757c11051,11061
< #line 745
<   if (_b___0 != 0) {
< #line 745
---
> #line 764
>   if (_bool___0) {
> #line 764
>     tmp___0 = 0;
>   } else {
> #line 764
>     tmp___0 = 1;
>   }
> #line 764
>   if (tmp___0) {
> #line 765
10762,10766c11066,11070
< #line 747
<   tmp = spinlock_check(& b->bm_lock);
< #line 747
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 748
---
> #line 767
>   tmp___1 = spinlock_check(& b->bm_lock);
> #line 767
>   flags = _raw_spin_lock_irqsave(tmp___1);
> #line 768
10768c11072
< #line 749
---
> #line 769
10770c11074
< #line 751
---
> #line 771
10774c11078
< #line 754 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 774 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10781c11085
< #line 758
---
> #line 778
10783c11087
< #line 758
---
> #line 778
10785c11089
< #line 759
---
> #line 779
10790c11094
< #line 760
---
> #line 780
10792c11096
< #line 761
---
> #line 781
10794c11098
< #line 762
---
> #line 782
10798c11102
< #line 765 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 785 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10802,10803c11106,11109
<   int _b ;
<   int _b___0 ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
10806c11112
< #line 767
---
> #line 787
10808,10815c11114,11120
< #line 768
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 768
<   if (_b != 0) {
< #line 768
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_words", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             768);
---
> #line 788
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 788
>   if (! _bool) {
> #line 788
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "drbd_bm_words");
10819,10821c11124,11134
< #line 768
<   if (_b != 0) {
< #line 768
---
> #line 788
>   if (_bool) {
> #line 788
>     tmp = 0;
>   } else {
> #line 788
>     tmp = 1;
>   }
> #line 788
>   if (tmp) {
> #line 789
10826,10833c11139,11145
< #line 769
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 769
<   if (_b___0 != 0) {
< #line 769
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_words", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             769);
---
> #line 790
>   _bool___0 = (unsigned long )b->bm_pages != (unsigned long )((struct page **)0);
> #line 790
>   if (! _bool___0) {
> #line 790
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b->bm_pages", "drbd_bm_words");
10837,10839c11149,11159
< #line 769
<   if (_b___0 != 0) {
< #line 769
---
> #line 790
>   if (_bool___0) {
> #line 790
>     tmp___0 = 0;
>   } else {
> #line 790
>     tmp___0 = 1;
>   }
> #line 790
>   if (tmp___0) {
> #line 791
10844c11164
< #line 771
---
> #line 793
10848c11168
< #line 774 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 796 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10852c11172,11173
<   int _b ;
---
>   bool _bool ;
>   int tmp ;
10855c11176
< #line 776
---
> #line 798
10857,10864c11178,11184
< #line 777
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 777
<   if (_b != 0) {
< #line 777
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_bits", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             777);
---
> #line 799
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 799
>   if (! _bool) {
> #line 799
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "drbd_bm_bits");
10868,10870c11188,11198
< #line 777
<   if (_b != 0) {
< #line 777
---
> #line 799
>   if (_bool) {
> #line 799
>     tmp = 0;
>   } else {
> #line 799
>     tmp = 1;
>   }
> #line 799
>   if (tmp) {
> #line 800
10875c11203
< #line 779
---
> #line 802
10879c11207
< #line 787 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 810 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
10890,10891c11218,11221
<   int _b ;
<   int _b___0 ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
10893c11223
<   long tmp ;
---
>   long tmp___1 ;
10895c11225
<   long tmp___0 ;
---
>   long tmp___2 ;
10898,10902c11228,11232
<   unsigned long *tmp___1 ;
<   unsigned long *tmp___2 ;
<   unsigned long tmp___3 ;
<   size_t tmp___4 ;
<   int tmp___5 ;
---
>   unsigned long *tmp___3 ;
>   unsigned long *tmp___4 ;
>   unsigned long tmp___5 ;
>   size_t tmp___6 ;
>   int tmp___7 ;
10905c11235
< #line 790
---
> #line 813
10907c11237
< #line 796
---
> #line 819
10909,10916c11239,11245
< #line 798
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 798
<   if (_b != 0) {
< #line 798
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_merge_lel", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             798);
---
> #line 821
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 821
>   if (! _bool) {
> #line 821
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "drbd_bm_merge_lel");
10920,10922c11249,11259
< #line 798
<   if (_b != 0) {
< #line 798
---
> #line 821
>   if (_bool) {
> #line 821
>     tmp = 0;
>   } else {
> #line 821
>     tmp = 1;
>   }
> #line 821
>   if (tmp) {
> #line 822
10927,10934c11264,11270
< #line 799
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 799
<   if (_b___0 != 0) {
< #line 799
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_merge_lel", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             799);
---
> #line 823
>   _bool___0 = (unsigned long )b->bm_pages != (unsigned long )((struct page **)0);
> #line 823
>   if (! _bool___0) {
> #line 823
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b->bm_pages", "drbd_bm_merge_lel");
10938,10940c11274,11284
< #line 799
<   if (_b___0 != 0) {
< #line 799
---
> #line 823
>   if (_bool___0) {
> #line 823
>     tmp___0 = 0;
>   } else {
> #line 823
>     tmp___0 = 1;
>   }
> #line 823
>   if (tmp___0) {
> #line 824
10945c11289
< #line 800
---
> #line 825
10947c11291
< #line 801
---
> #line 826
10952c11296
< #line 802
---
> #line 827
10954,10960c11298,11304
< #line 802
<   tmp = __builtin_expect(__ret_warn_on != 0, 0L);
< #line 802
<   if (tmp != 0L) {
< #line 802
<     warn_slowpath_null("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<                        802);
---
> #line 827
>   tmp___1 = __builtin_expect(__ret_warn_on != 0, 0L);
> #line 827
>   if (tmp___1 != 0L) {
> #line 827
>     warn_slowpath_null("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
>                        827);
10964c11308
< #line 802
---
> #line 827
10966c11310
< #line 803
---
> #line 828
10968,10974c11312,11318
< #line 803
<   tmp___0 = __builtin_expect(__ret_warn_on___0 != 0, 0L);
< #line 803
<   if (tmp___0 != 0L) {
< #line 803
<     warn_slowpath_null("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<                        803);
---
> #line 828
>   tmp___2 = __builtin_expect(__ret_warn_on___0 != 0, 0L);
> #line 828
>   if (tmp___2 != 0L) {
> #line 828
>     warn_slowpath_null("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
>                        828);
10978c11322
< #line 803
---
> #line 828
10980c11324
< #line 805
---
> #line 830
10982,10985c11326,11329
< #line 806
<   goto ldv_51394;
<   ldv_51393: 
< #line 807
---
> #line 831
>   goto ldv_51961;
>   ldv_51960: 
> #line 832
10987c11331
< #line 807
---
> #line 832
10989c11333
< #line 807
---
> #line 832
10991c11335
< #line 808
---
> #line 833
10993c11337
< #line 809
---
> #line 834
10995c11339
< #line 810
---
> #line 835
10997c11341
< #line 811
---
> #line 836
10999,11002c11343,11346
< #line 812
<   goto ldv_51391;
<   ldv_51390: 
< #line 813
---
> #line 837
>   goto ldv_51958;
>   ldv_51957: 
> #line 838
11004,11006c11348,11350
< #line 814
<   tmp___1 = buffer;
< #line 814
---
> #line 839
>   tmp___3 = buffer;
> #line 839
11008,11012c11352,11356
< #line 814
<   word = *bm | *tmp___1;
< #line 815
<   tmp___2 = bm;
< #line 815
---
> #line 839
>   word = *bm | *tmp___3;
> #line 840
>   tmp___4 = bm;
> #line 840
11014,11023c11358,11367
< #line 815
<   *tmp___2 = word;
< #line 816
<   tmp___3 = hweight_long(word);
< #line 816
<   b->bm_set = b->bm_set + (tmp___3 - bits);
<   ldv_51391: 
< #line 812
<   tmp___4 = do_now;
< #line 812
---
> #line 840
>   *tmp___4 = word;
> #line 841
>   tmp___5 = hweight_long(word);
> #line 841
>   b->bm_set = b->bm_set + (tmp___5 - bits);
>   ldv_51958: 
> #line 837
>   tmp___6 = do_now;
> #line 837
11025,11028c11369,11372
< #line 812
<   if (tmp___4 != 0UL) {
< #line 813
<     goto ldv_51390;
---
> #line 837
>   if (tmp___6 != 0UL) {
> #line 838
>     goto ldv_51957;
11032c11376
< #line 818
---
> #line 843
11034c11378
< #line 819
---
> #line 844
11036,11037c11380,11381
<   ldv_51394: ;
< #line 806
---
>   ldv_51961: ;
> #line 831
11039,11040c11383,11384
< #line 807
<     goto ldv_51393;
---
> #line 832
>     goto ldv_51960;
11045c11389
< #line 826
---
> #line 851
11047,11050c11391,11394
< #line 827
<     tmp___5 = bm_clear_surplus(b);
< #line 827
<     b->bm_set = b->bm_set - (unsigned long )tmp___5;
---
> #line 852
>     tmp___7 = bm_clear_surplus(b);
> #line 852
>     b->bm_set = b->bm_set - (unsigned long )tmp___7;
11054c11398
< #line 828
---
> #line 853
11056c11400
< #line 829
---
> #line 854
11060c11404
< #line 834 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 859 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11068,11069c11412,11415
<   int _b ;
<   int _b___0 ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
11072,11075c11418,11421
<   unsigned int tmp ;
<   unsigned long *tmp___0 ;
<   unsigned long *tmp___1 ;
<   size_t tmp___2 ;
---
>   unsigned int tmp___1 ;
>   unsigned long *tmp___2 ;
>   unsigned long *tmp___3 ;
>   size_t tmp___4 ;
11078c11424
< #line 837
---
> #line 862
11080c11426
< #line 841
---
> #line 866
11082,11089c11428,11434
< #line 843
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 843
<   if (_b != 0) {
< #line 843
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_get_lel", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             843);
---
> #line 868
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 868
>   if (! _bool) {
> #line 868
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "drbd_bm_get_lel");
11093,11095c11438,11448
< #line 843
<   if (_b != 0) {
< #line 843
---
> #line 868
>   if (_bool) {
> #line 868
>     tmp = 0;
>   } else {
> #line 868
>     tmp = 1;
>   }
> #line 868
>   if (tmp) {
> #line 869
11100,11107c11453,11459
< #line 844
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 844
<   if (_b___0 != 0) {
< #line 844
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_get_lel", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             844);
---
> #line 870
>   _bool___0 = (unsigned long )b->bm_pages != (unsigned long )((struct page **)0);
> #line 870
>   if (! _bool___0) {
> #line 870
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b->bm_pages", "drbd_bm_get_lel");
11111,11113c11463,11473
< #line 844
<   if (_b___0 != 0) {
< #line 844
---
> #line 870
>   if (_bool___0) {
> #line 870
>     tmp___0 = 0;
>   } else {
> #line 870
>     tmp___0 = 1;
>   }
> #line 870
>   if (tmp___0) {
> #line 871
11118c11478
< #line 846
---
> #line 873
11120c11480
< #line 847
---
> #line 874
11122c11482
< #line 850
---
> #line 877
11126,11129c11486,11489
< #line 855
<     goto ldv_51419;
<     ldv_51418: 
< #line 856
---
> #line 882
>     goto ldv_51986;
>     ldv_51985: 
> #line 883
11131c11491
< #line 856
---
> #line 883
11133c11493
< #line 856
---
> #line 883
11135,11139c11495,11499
< #line 857
<     tmp = bm_word_to_page_idx(b, offset);
< #line 857
<     p_addr = bm_map_pidx(b, tmp);
< #line 858
---
> #line 884
>     tmp___1 = bm_word_to_page_idx(b, offset);
> #line 884
>     p_addr = bm_map_pidx(b, tmp___1);
> #line 885
11141c11501
< #line 859
---
> #line 886
11143,11148c11503,11508
< #line 860
<     goto ldv_51416;
<     ldv_51415: 
< #line 861
<     tmp___0 = buffer;
< #line 861
---
> #line 887
>     goto ldv_51983;
>     ldv_51982: 
> #line 888
>     tmp___2 = buffer;
> #line 888
11150,11152c11510,11512
< #line 861
<     tmp___1 = bm;
< #line 861
---
> #line 888
>     tmp___3 = bm;
> #line 888
11154,11159c11514,11519
< #line 861
<     *tmp___0 = *tmp___1;
<     ldv_51416: 
< #line 860
<     tmp___2 = do_now;
< #line 860
---
> #line 888
>     *tmp___2 = *tmp___3;
>     ldv_51983: 
> #line 887
>     tmp___4 = do_now;
> #line 887
11161,11164c11521,11524
< #line 860
<     if (tmp___2 != 0UL) {
< #line 861
<       goto ldv_51415;
---
> #line 887
>     if (tmp___4 != 0UL) {
> #line 888
>       goto ldv_51982;
11168c11528
< #line 862
---
> #line 889
11170,11171c11530,11531
<     ldv_51419: ;
< #line 855
---
>     ldv_51986: ;
> #line 882
11173,11174c11533,11534
< #line 856
<       goto ldv_51418;
---
> #line 883
>       goto ldv_51985;
11180c11540
< #line 865
---
> #line 892
11182c11542
< #line 866
---
> #line 893
11186c11546
< #line 869 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 896 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11190,11191c11550,11553
<   int _b ;
<   int _b___0 ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
11194c11556
< #line 871
---
> #line 898
11196,11203c11558,11564
< #line 872
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 872
<   if (_b != 0) {
< #line 872
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_set_all", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             872);
---
> #line 899
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 899
>   if (! _bool) {
> #line 899
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "drbd_bm_set_all");
11207,11209c11568,11578
< #line 872
<   if (_b != 0) {
< #line 872
---
> #line 899
>   if (_bool) {
> #line 899
>     tmp = 0;
>   } else {
> #line 899
>     tmp = 1;
>   }
> #line 899
>   if (tmp) {
> #line 900
11214,11221c11583,11589
< #line 873
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 873
<   if (_b___0 != 0) {
< #line 873
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_set_all", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             873);
---
> #line 901
>   _bool___0 = (unsigned long )b->bm_pages != (unsigned long )((struct page **)0);
> #line 901
>   if (! _bool___0) {
> #line 901
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b->bm_pages", "drbd_bm_set_all");
11225,11227c11593,11603
< #line 873
<   if (_b___0 != 0) {
< #line 873
---
> #line 901
>   if (_bool___0) {
> #line 901
>     tmp___0 = 0;
>   } else {
> #line 901
>     tmp___0 = 1;
>   }
> #line 901
>   if (tmp___0) {
> #line 902
11232c11608
< #line 875
---
> #line 904
11234c11610
< #line 876
---
> #line 905
11236c11612
< #line 877
---
> #line 906
11238c11614
< #line 878
---
> #line 907
11240c11616
< #line 879
---
> #line 908
11242c11618
< #line 880
---
> #line 909
11246c11622
< #line 883 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 912 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11250,11251c11626,11629
<   int _b ;
<   int _b___0 ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
11254c11632
< #line 885
---
> #line 914
11256,11263c11634,11640
< #line 886
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 886
<   if (_b != 0) {
< #line 886
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_clear_all", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             886);
---
> #line 915
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 915
>   if (! _bool) {
> #line 915
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "drbd_bm_clear_all");
11267,11269c11644,11654
< #line 886
<   if (_b != 0) {
< #line 886
---
> #line 915
>   if (_bool) {
> #line 915
>     tmp = 0;
>   } else {
> #line 915
>     tmp = 1;
>   }
> #line 915
>   if (tmp) {
> #line 916
11274,11281c11659,11665
< #line 887
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 887
<   if (_b___0 != 0) {
< #line 887
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_clear_all", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             887);
---
> #line 917
>   _bool___0 = (unsigned long )b->bm_pages != (unsigned long )((struct page **)0);
> #line 917
>   if (! _bool___0) {
> #line 917
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b->bm_pages", "drbd_bm_clear_all");
11285,11287c11669,11679
< #line 887
<   if (_b___0 != 0) {
< #line 887
---
> #line 917
>   if (_bool___0) {
> #line 917
>     tmp___0 = 0;
>   } else {
> #line 917
>     tmp___0 = 1;
>   }
> #line 917
>   if (tmp___0) {
> #line 918
11292c11684
< #line 889
---
> #line 920
11294c11686
< #line 890
---
> #line 921
11296c11688
< #line 891
---
> #line 922
11298c11690
< #line 892
---
> #line 923
11300c11692
< #line 893
---
> #line 924
11304c11696
< #line 906 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 938 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11311c11703
< #line 908
---
> #line 940
11313c11705
< #line 908
---
> #line 940
11315c11707
< #line 910
---
> #line 942
11317c11709
< #line 911
---
> #line 943
11319c11711
< #line 912
---
> #line 944
11323c11715
< #line 915 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 947 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11339c11731
< #line 917
---
> #line 949
11341c11733
< #line 918
---
> #line 950
11343c11735
< #line 919
---
> #line 951
11345c11737
< #line 920
---
> #line 952
11347c11739
< #line 920
---
> #line 952
11349c11741
< #line 921
---
> #line 953
11351c11743
< #line 928
---
> #line 960
11353c11745
< #line 929
---
> #line 961
11358c11750
< #line 931
---
> #line 963
11360c11752
< #line 931
---
> #line 963
11362c11754
< #line 931
---
> #line 963
11364c11756
< #line 933
---
> #line 965
11373c11765
< #line 935
---
> #line 967
11375c11767
< #line 938
---
> #line 970
11377c11769
< #line 939
---
> #line 971
11379c11771
< #line 942
---
> #line 974
11381c11773
< #line 942
---
> #line 974
11383c11775
< #line 943
---
> #line 975
11390c11782
< #line 946
---
> #line 978
11392c11784
< #line 947
---
> #line 979
11394c11786
< #line 947
---
> #line 979
11396,11398c11788,11790
< #line 947
<     descriptor.filename = "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared";
< #line 947
---
> #line 979
>     descriptor.filename = "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared";
> #line 979
11400,11402c11792,11794
< #line 947
<     descriptor.lineno = 947U;
< #line 947
---
> #line 979
>     descriptor.lineno = 979U;
> #line 979
11404c11796
< #line 947
---
> #line 979
11406c11798
< #line 947
---
> #line 979
11408c11800
< #line 947
---
> #line 979
11415c11807
< #line 950
---
> #line 982
11417c11809
< #line 952
---
> #line 984
11419c11811
< #line 953
---
> #line 985
11424c11816
< #line 955
---
> #line 987
11426c11818
< #line 957
---
> #line 989
11428c11820
< #line 957
---
> #line 989
11430c11822
< #line 958
---
> #line 990
11432c11824
< #line 959
---
> #line 991
11434c11826
< #line 960
---
> #line 992
11439c11831
< #line 962
---
> #line 994
11443c11835
< #line 964 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 996 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11464c11856
< #line 966
---
> #line 998
11466c11858
< #line 966
---
> #line 998
11468c11860
< #line 967
---
> #line 999
11470c11862
< #line 968
---
> #line 1000
11472c11864
< #line 972
---
> #line 1004
11474c11866
< #line 974
---
> #line 1006
11476c11868
< #line 979
---
> #line 1011
11478c11870
< #line 979
---
> #line 1011
11480c11872
< #line 979
---
> #line 1011
11482c11874
< #line 979
---
> #line 1011
11484c11876
< #line 983
---
> #line 1015
11486c11878
< #line 986
---
> #line 1018
11488c11880
< #line 988
---
> #line 1020
11490c11882
< #line 990
---
> #line 1022
11492c11884
< #line 990
---
> #line 1022
11494c11886
< #line 991
---
> #line 1023
11496c11888
< #line 992
---
> #line 1024
11498c11890
< #line 993
---
> #line 1025
11500c11892
< #line 993
---
> #line 1025
11502c11894
< #line 993
---
> #line 1025
11505c11897
< #line 993
---
> #line 1025
11508c11900
< #line 994
---
> #line 1026
11510c11902
< #line 995
---
> #line 1027
11512c11904
< #line 996
---
> #line 1028
11515c11907
< #line 998
---
> #line 1030
11518c11910
< #line 1000
---
> #line 1032
11520c11912
< #line 1001
---
> #line 1033
11522c11914
< #line 1004
---
> #line 1036
11524c11916
< #line 1005
---
> #line 1037
11526c11918
< #line 1006
---
> #line 1038
11528c11920
< #line 1008
---
> #line 1040
11530c11922
< #line 1008
---
> #line 1040
11532c11924
< #line 1009
---
> #line 1041
11534c11926
< #line 1010
---
> #line 1042
11537c11929
< #line 1012
---
> #line 1044
11539c11931
< #line 1015
---
> #line 1047
11542c11934
< #line 1017
---
> #line 1049
11546c11938
< #line 1022 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1054 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11561a11954
>   int tmp___2 ;
11563,11564c11956,11957
<   long tmp___2 ;
<   int tmp___3 ;
---
>   long tmp___3 ;
>   int tmp___4 ;
11566,11567c11959
<   long tmp___4 ;
<   int tmp___5 ;
---
>   long tmp___5 ;
11570c11962,11963
<   char *tmp___8 ;
---
>   int tmp___8 ;
>   char *tmp___9 ;
11573c11966
< #line 1025
---
> #line 1057
11575c11968
< #line 1026
---
> #line 1058
11577c11970
< #line 1029
---
> #line 1061
11579c11972
< #line 1040
---
> #line 1072
11581c11974
< #line 1040
---
> #line 1072
11583c11976
< #line 1041
---
> #line 1073
11585c11978
< #line 1042
---
> #line 1074
11590c11983
< #line 1044
---
> #line 1076
11592c11985
< #line 1044
---
> #line 1076
11594c11987
< #line 1044
---
> #line 1076
11596c11989
< #line 1044
---
> #line 1076
11598c11991
< #line 1044
---
> #line 1076
11600c11993
< #line 1044
---
> #line 1076
11602c11995
< #line 1044
---
> #line 1076
11604c11997
< #line 1053
---
> #line 1085
11606c11999
< #line 1053
---
> #line 1085
11608c12001
< #line 1054
---
> #line 1086
11610c12003
< #line 1055
---
> #line 1087
11612c12005
< #line 1056
---
> #line 1088
11617c12010
< #line 1059
---
> #line 1091
11619c12012
< #line 1060
---
> #line 1092
11621c12014
< #line 1060
---
> #line 1092
11623c12016
< #line 1060
---
> #line 1092
11625,11627c12018,12020
< #line 1060
<       warn_slowpath_null("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<                          1060);
---
> #line 1092
>       warn_slowpath_null("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
>                          1092);
11631c12024
< #line 1060
---
> #line 1092
11636c12029
< #line 1062
---
> #line 1094
11638c12031
< #line 1064
---
> #line 1096
11640c12033
< #line 1067
---
> #line 1099
11642,11645c12035,12038
< #line 1067
<   goto ldv_51506;
<   ldv_51505: ;
< #line 1069
---
> #line 1099
>   goto ldv_52073;
>   ldv_52072: ;
> #line 1101
11647,11648c12040,12041
< #line 1070
<     goto ldv_51499;
---
> #line 1102
>     goto ldv_52066;
11652c12045
< #line 1071
---
> #line 1103
11654,11660c12047,12067
< #line 1072
<     if ((flags & 2U) == 0U) {
< #line 1072
<       tmp___3 = bm_test_page_unchanged(*(b->bm_pages + (unsigned long )i));
< #line 1072
<       if (tmp___3 != 0) {
< #line 1074
---
> #line 1104
>     if ((flags & 2U) != 0U) {
> #line 1104
>       tmp___2 = test_and_clear_bit(27, (unsigned long volatile   *)(& (*(b->bm_pages + (unsigned long )i))->ldv_16348.private));
> #line 1104
>       if (tmp___2 == 0) {
> #line 1107
>         goto ldv_52067;
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 1109
>     if ((flags & 4U) == 0U) {
> #line 1109
>       tmp___4 = bm_test_page_unchanged(*(b->bm_pages + (unsigned long )i));
> #line 1109
>       if (tmp___4 != 0) {
> #line 1111
11662c12069
< #line 1074
---
> #line 1111
11664,11666c12071,12073
< #line 1074
<         descriptor.filename = "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared";
< #line 1074
---
> #line 1111
>         descriptor.filename = "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared";
> #line 1111
11668,11670c12075,12077
< #line 1074
<         descriptor.lineno = 1074U;
< #line 1074
---
> #line 1111
>         descriptor.lineno = 1111U;
> #line 1111
11672,11676c12079,12083
< #line 1074
<         tmp___2 = __builtin_expect((long )descriptor.flags & 1L, 0L);
< #line 1074
<         if (tmp___2 != 0L) {
< #line 1074
---
> #line 1111
>         tmp___3 = __builtin_expect((long )descriptor.flags & 1L, 0L);
> #line 1111
>         if (tmp___3 != 0L) {
> #line 1111
11682,11683c12089,12090
< #line 1075
<         goto ldv_51502;
---
> #line 1112
>         goto ldv_52067;
11690c12097
< #line 1079
---
> #line 1116
11692,11696c12099,12103
< #line 1079
<       tmp___5 = bm_test_page_lazy_writeout(*(b->bm_pages + (unsigned long )i));
< #line 1079
<       if (tmp___5 == 0) {
< #line 1081
---
> #line 1116
>       tmp___6 = bm_test_page_lazy_writeout(*(b->bm_pages + (unsigned long )i));
> #line 1116
>       if (tmp___6 == 0) {
> #line 1118
11698c12105
< #line 1081
---
> #line 1118
11700,11702c12107,12109
< #line 1081
<         descriptor___0.filename = "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared";
< #line 1081
---
> #line 1118
>         descriptor___0.filename = "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared";
> #line 1118
11704,11706c12111,12113
< #line 1081
<         descriptor___0.lineno = 1081U;
< #line 1081
---
> #line 1118
>         descriptor___0.lineno = 1118U;
> #line 1118
11708,11712c12115,12119
< #line 1081
<         tmp___4 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
< #line 1081
<         if (tmp___4 != 0L) {
< #line 1081
---
> #line 1118
>         tmp___5 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
> #line 1118
>         if (tmp___5 != 0L) {
> #line 1118
11718,11719c12125,12126
< #line 1082
<         goto ldv_51502;
---
> #line 1119
>         goto ldv_52067;
11729c12136
< #line 1085
---
> #line 1122
11731c12138
< #line 1086
---
> #line 1123
11733c12140
< #line 1087
---
> #line 1124
11735,11738c12142,12145
< #line 1088
<   __might_sleep("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<                 1088, 0);
< #line 1088
---
> #line 1125
>   __might_sleep("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
>                 1125, 0);
> #line 1125
11740,11741c12147,12148
<   ldv_51502: 
< #line 1067
---
>   ldv_52067: 
> #line 1099
11743,11744c12150,12151
<   ldv_51506: ;
< #line 1067
---
>   ldv_52073: ;
> #line 1099
11746,11747c12153,12154
< #line 1068
<     goto ldv_51505;
---
> #line 1100
>     goto ldv_52072;
11751,11756c12158,12163
<   ldv_51499: 
< #line 1099
<   tmp___6 = atomic_dec_and_test(& ctx->in_flight);
< #line 1099
<   if (tmp___6 == 0) {
< #line 1100
---
>   ldv_52066: 
> #line 1136
>   tmp___7 = atomic_dec_and_test(& ctx->in_flight);
> #line 1136
>   if (tmp___7 == 0) {
> #line 1137
11759c12166
< #line 1102
---
> #line 1139
11762,11765c12169,12177
< #line 1104
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "bitmap %s of %u pages took %lu jiffies\n",
<             rw == 1 ? (char *)"WRITE" : (char *)"READ", count, (unsigned long )jiffies - now);
< #line 1108
---
> #line 1142
>   if (flags == 0U) {
> #line 1143
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "bitmap %s of %u pages took %lu jiffies\n",
>               rw == 1 ? (char *)"WRITE" : (char *)"READ", count, (unsigned long )jiffies - now);
>   } else {
> 
>   }
> #line 1147
11767c12179
< #line 1109
---
> #line 1148
11769c12181
< #line 1110
---
> #line 1149
11771c12183
< #line 1111
---
> #line 1150
11776,11780c12188,12192
< #line 1114
<   tmp___7 = atomic_read((atomic_t const   *)(& ctx->in_flight));
< #line 1114
<   if (tmp___7 != 0) {
< #line 1115
---
> #line 1153
>   tmp___8 = atomic_read((atomic_t const   *)(& ctx->in_flight));
> #line 1153
>   if (tmp___8 != 0) {
> #line 1154
11785c12197
< #line 1117
---
> #line 1156
11787c12199
< #line 1118
---
> #line 1157
11789c12201
< #line 1119
---
> #line 1158
11792c12204
< #line 1121
---
> #line 1160
11794c12206
< #line 1122
---
> #line 1161
11798c12210
< #line 1125
---
> #line 1164
11800,11805c12212,12222
< #line 1127
<   tmp___8 = ppsize((char *)(& ppb), (unsigned long long )(now << 2));
< #line 1127
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s (%lu bits) marked out-of-sync by on disk bit-map.\n",
<             tmp___8, now);
< #line 1130
---
> #line 1166
>   if (flags == 0U) {
> #line 1167
>     tmp___9 = ppsize((char *)(& ppb), (unsigned long long )(now << 2));
> #line 1167
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s (%lu bits) marked out-of-sync by on disk bit-map.\n",
>               tmp___9, now);
>   } else {
> 
>   }
> #line 1170
11807c12224
< #line 1131
---
> #line 1171
11811c12228
< #line 1138 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1178 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11817c12234
< #line 1140
---
> #line 1180
11819c12236
< #line 1140
---
> #line 1180
11823c12240
< #line 1149 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1189 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11829c12246
< #line 1151
---
> #line 1191
11831c12248
< #line 1151
---
> #line 1191
11835c12252
< #line 1160 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1200 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11841,11843c12258,12260
< #line 1162
<   tmp = bm_rw(mdev, 1, 2U, 0U);
< #line 1162
---
> #line 1202
>   tmp = bm_rw(mdev, 1, 4U, 0U);
> #line 1202
11847c12264
< #line 1170 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1210 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11853c12270
< #line 1172
---
> #line 1212
11855c12272
< #line 1172
---
> #line 1212
11859c12276
< #line 1186 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1226 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11865c12282
< #line 1188
---
> #line 1228
11867c12284,12296
< #line 1188
---
> #line 1228
>   return (tmp);
> }
> }
> #line 1235 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
> int drbd_bm_write_hinted(struct drbd_conf *mdev ) 
> { 
>   int tmp ;
> 
>   {
> #line 1237
>   tmp = bm_rw(mdev, 1, 3U, 0U);
> #line 1237
11871c12300
< #line 1204 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1252 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11885c12314
< #line 1209
---
> #line 1257
11887c12316
< #line 1209
---
> #line 1257
11889c12318
< #line 1210
---
> #line 1258
11891c12320
< #line 1210
---
> #line 1258
11893,11895c12322,12324
< #line 1210
<     descriptor.filename = "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared";
< #line 1210
---
> #line 1258
>     descriptor.filename = "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared";
> #line 1258
11897,11899c12326,12328
< #line 1210
<     descriptor.lineno = 1210U;
< #line 1210
---
> #line 1258
>     descriptor.lineno = 1258U;
> #line 1258
11901c12330
< #line 1210
---
> #line 1258
11903c12332
< #line 1210
---
> #line 1258
11905c12334
< #line 1210
---
> #line 1258
11911c12340
< #line 1211
---
> #line 1259
11916c12345
< #line 1214
---
> #line 1262
11918c12347
< #line 1214
---
> #line 1262
11920c12349
< #line 1215
---
> #line 1263
11922c12351
< #line 1216
---
> #line 1264
11927c12356
< #line 1218
---
> #line 1266
11929c12358
< #line 1218
---
> #line 1266
11931c12360
< #line 1218
---
> #line 1266
11933c12362
< #line 1218
---
> #line 1266
11935c12364
< #line 1218
---
> #line 1266
11937c12366
< #line 1218
---
> #line 1266
11939c12368
< #line 1218
---
> #line 1266
11941c12370
< #line 1227
---
> #line 1275
11943c12372
< #line 1227
---
> #line 1275
11945c12374
< #line 1228
---
> #line 1276
11947c12376
< #line 1229
---
> #line 1277
11949c12378
< #line 1230
---
> #line 1278
11954c12383
< #line 1233
---
> #line 1281
11956c12385
< #line 1234
---
> #line 1282
11958c12387
< #line 1236
---
> #line 1284
11960c12389
< #line 1237
---
> #line 1285
11965c12394
< #line 1241
---
> #line 1289
11967c12396
< #line 1242
---
> #line 1290
11969c12398
< #line 1242
---
> #line 1290
11971c12400
< #line 1243
---
> #line 1291
11973c12402
< #line 1244
---
> #line 1292
11977c12406
< #line 1255 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1303 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
11990c12419
< #line 1258
---
> #line 1306
11992c12421
< #line 1264
---
> #line 1312
11994c12423
< #line 1265
---
> #line 1313
11997c12426
< #line 1266
---
> #line 1314
12000,12003c12429,12432
< #line 1268
<     goto ldv_51544;
<     ldv_51543: 
< #line 1270
---
> #line 1316
>     goto ldv_52114;
>     ldv_52113: 
> #line 1318
12005c12434
< #line 1271
---
> #line 1319
12007c12436
< #line 1271
---
> #line 1319
12009c12438
< #line 1273
---
> #line 1321
12011c12440
< #line 1274
---
> #line 1322
12013c12442
< #line 1274
---
> #line 1322
12016c12445
< #line 1277
---
> #line 1325
12018c12447
< #line 1277
---
> #line 1325
12021c12450
< #line 1280
---
> #line 1328
12023c12452
< #line 1281
---
> #line 1329
12025c12454
< #line 1282
---
> #line 1330
12027c12456
< #line 1283
---
> #line 1331
12029,12030c12458,12459
< #line 1284
<         goto ldv_51541;
---
> #line 1332
>         goto ldv_52111;
12034c12463
< #line 1285
---
> #line 1333
12039c12468
< #line 1287
---
> #line 1335
12041,12042c12470,12471
<     ldv_51544: ;
< #line 1268
---
>     ldv_52114: ;
> #line 1316
12044,12045c12473,12474
< #line 1269
<       goto ldv_51543;
---
> #line 1317
>       goto ldv_52113;
12049,12050c12478,12479
<     ldv_51541: 
< #line 1289
---
>     ldv_52111: 
> #line 1337
12054c12483
< #line 1292
---
> #line 1340
12058c12487
< #line 1295 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1343 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12063,12064c12492,12495
<   int _b ;
<   int _b___0 ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
12067c12498
< #line 1298
---
> #line 1346
12069c12500
< #line 1299
---
> #line 1347
12071,12078c12502,12508
< #line 1301
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 1301
<   if (_b != 0) {
< #line 1301
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "bm_find_next", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1301);
---
> #line 1349
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 1349
>   if (! _bool) {
> #line 1349
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "bm_find_next");
12082,12084c12512,12522
< #line 1301
<   if (_b != 0) {
< #line 1301
---
> #line 1349
>   if (_bool) {
> #line 1349
>     tmp = 0;
>   } else {
> #line 1349
>     tmp = 1;
>   }
> #line 1349
>   if (tmp) {
> #line 1350
12089,12096c12527,12533
< #line 1302
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 1302
<   if (_b___0 != 0) {
< #line 1302
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "bm_find_next", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1302);
---
> #line 1351
>   _bool___0 = (unsigned long )b->bm_pages != (unsigned long )((struct page **)0);
> #line 1351
>   if (! _bool___0) {
> #line 1351
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b->bm_pages", "bm_find_next");
12100,12102c12537,12547
< #line 1302
<   if (_b___0 != 0) {
< #line 1302
---
> #line 1351
>   if (_bool___0) {
> #line 1351
>     tmp___0 = 0;
>   } else {
> #line 1351
>     tmp___0 = 1;
>   }
> #line 1351
>   if (tmp___0) {
> #line 1352
12107c12552
< #line 1304
---
> #line 1354
12109c12554
< #line 1305
---
> #line 1355
12111c12556
< #line 1306
---
> #line 1356
12116c12561
< #line 1308
---
> #line 1358
12118c12563
< #line 1310
---
> #line 1360
12120c12565
< #line 1311
---
> #line 1361
12124c12569
< #line 1314 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1364 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12130c12575
< #line 1316
---
> #line 1366
12132c12577
< #line 1316
---
> #line 1366
12136c12581
< #line 1329 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1379 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12142c12587
< #line 1332
---
> #line 1382
12144c12589
< #line 1332
---
> #line 1382
12148c12593
< #line 1335 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1385 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12154c12599
< #line 1338
---
> #line 1388
12156c12601
< #line 1338
---
> #line 1388
12160c12605
< #line 1347 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1397 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12176c12621
< #line 1350
---
> #line 1400
12178c12623
< #line 1351
---
> #line 1401
12180c12625
< #line 1353
---
> #line 1403
12182c12627
< #line 1354
---
> #line 1404
12184c12629
< #line 1355
---
> #line 1405
12186c12631
< #line 1357
---
> #line 1407
12188c12633
< #line 1358
---
> #line 1408
12191c12636
< #line 1360
---
> #line 1410
12196c12641
< #line 1362
---
> #line 1412
12198,12201c12643,12646
< #line 1362
<   goto ldv_51583;
<   ldv_51582: 
< #line 1363
---
> #line 1412
>   goto ldv_52153;
>   ldv_52152: 
> #line 1413
12203c12648
< #line 1363
---
> #line 1413
12205c12650
< #line 1364
---
> #line 1414
12207c12652
< #line 1365
---
> #line 1415
12209c12654
< #line 1366
---
> #line 1416
12214c12659
< #line 1367
---
> #line 1417
12216c12661
< #line 1368
---
> #line 1418
12219c12664
< #line 1369
---
> #line 1419
12221c12666
< #line 1370
---
> #line 1420
12226c12671
< #line 1371
---
> #line 1421
12228c12673
< #line 1372
---
> #line 1422
12230c12675
< #line 1373
---
> #line 1423
12232c12677
< #line 1374
---
> #line 1424
12237c12682
< #line 1376
---
> #line 1426
12239c12684
< #line 1377
---
> #line 1427
12241c12686
< #line 1377
---
> #line 1427
12244c12689
< #line 1379
---
> #line 1429
12246c12691
< #line 1379
---
> #line 1429
12249c12694
< #line 1362
---
> #line 1412
12251,12252c12696,12697
<   ldv_51583: ;
< #line 1362
---
>   ldv_52153: ;
> #line 1412
12254,12255c12699,12700
< #line 1363
<     goto ldv_51582;
---
> #line 1413
>     goto ldv_52152;
12260c12705
< #line 1381
---
> #line 1431
12262c12707
< #line 1382
---
> #line 1432
12267c12712
< #line 1383
---
> #line 1433
12269c12714
< #line 1384
---
> #line 1434
12272c12717
< #line 1385
---
> #line 1435
12274c12719
< #line 1386
---
> #line 1436
12279c12724
< #line 1387
---
> #line 1437
12281c12726
< #line 1388
---
> #line 1438
12283c12728
< #line 1389
---
> #line 1439
12287c12732
< #line 1396 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1446 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12294,12296c12739,12743
<   int _b ;
<   int _b___0 ;
<   raw_spinlock_t *tmp ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
>   raw_spinlock_t *tmp___1 ;
12299c12746
< #line 1400
---
> #line 1450
12301c12748
< #line 1401
---
> #line 1451
12303,12310c12750,12756
< #line 1403
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 1403
<   if (_b != 0) {
< #line 1403
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "bm_change_bits_to", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1403);
---
> #line 1453
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 1453
>   if (! _bool) {
> #line 1453
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "bm_change_bits_to");
12314,12316c12760,12770
< #line 1403
<   if (_b != 0) {
< #line 1403
---
> #line 1453
>   if (_bool) {
> #line 1453
>     tmp = 0;
>   } else {
> #line 1453
>     tmp = 1;
>   }
> #line 1453
>   if (tmp) {
> #line 1454
12321,12328c12775,12781
< #line 1404
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 1404
<   if (_b___0 != 0) {
< #line 1404
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "bm_change_bits_to", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1404);
---
> #line 1455
>   _bool___0 = (unsigned long )b->bm_pages != (unsigned long )((struct page **)0);
> #line 1455
>   if (! _bool___0) {
> #line 1455
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b->bm_pages", "bm_change_bits_to");
12332,12334c12785,12795
< #line 1404
<   if (_b___0 != 0) {
< #line 1404
---
> #line 1455
>   if (_bool___0) {
> #line 1455
>     tmp___0 = 0;
>   } else {
> #line 1455
>     tmp___0 = 1;
>   }
> #line 1455
>   if (tmp___0) {
> #line 1456
12339,12343c12800,12804
< #line 1406
<   tmp = spinlock_check(& b->bm_lock);
< #line 1406
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 1407
---
> #line 1458
>   tmp___1 = spinlock_check(& b->bm_lock);
> #line 1458
>   flags = _raw_spin_lock_irqsave(tmp___1);
> #line 1459
12345c12806
< #line 1408
---
> #line 1460
12350c12811
< #line 1410
---
> #line 1462
12352c12813
< #line 1412
---
> #line 1464
12354c12815
< #line 1413
---
> #line 1465
12358c12819
< #line 1417 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1469 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12364c12825
< #line 1419
---
> #line 1471
12366c12827
< #line 1419
---
> #line 1471
12370c12831
< #line 1423 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1475 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12376c12837
< #line 1425
---
> #line 1477
12378c12839
< #line 1425
---
> #line 1477
12382c12843
< #line 1430 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1482 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12387a12849
>   int changed ;
12393c12855,12857
< #line 1435
---
> #line 1487
>   changed = 0;
> #line 1488
12395c12859
< #line 1435
---
> #line 1488
12397c12861
< #line 1436
---
> #line 1489
12399,12402c12863,12866
< #line 1436
<   goto ldv_51622;
<   ldv_51621: 
< #line 1437
---
> #line 1489
>   goto ldv_52193;
>   ldv_52192: 
> #line 1490
12404c12868
< #line 1437
---
> #line 1490
12406c12870
< #line 1438
---
> #line 1491
12408,12410c12872,12874
< #line 1439
<   b->bm_set = b->bm_set + (unsigned long )(64 - bits);
< #line 1436
---
> #line 1492
>   changed = (64 - bits) + changed;
> #line 1489
12412,12413c12876,12877
<   ldv_51622: ;
< #line 1436
---
>   ldv_52193: ;
> #line 1489
12415,12416c12879,12880
< #line 1437
<     goto ldv_51621;
---
> #line 1490
>     goto ldv_52192;
12420c12884
< #line 1441
---
> #line 1494
12422c12886,12895
< #line 1442
---
> #line 1495
>   if (changed != 0) {
> #line 1499
>     bm_set_page_lazy_writeout(*(b->bm_pages + (unsigned long )page_nr));
> #line 1500
>     b->bm_set = b->bm_set + (unsigned long )changed;
>   } else {
> 
>   }
> #line 1502
12426c12899
< #line 1449 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1509 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12439c12912
< #line 1459
---
> #line 1519
12441c12914
< #line 1460
---
> #line 1520
12443c12916
< #line 1461
---
> #line 1521
12445c12918
< #line 1468
---
> #line 1528
12447c12920
< #line 1470
---
> #line 1530
12449c12922
< #line 1471
---
> #line 1531
12451c12924
< #line 1472
---
> #line 1532
12453c12926
< #line 1473
---
> #line 1533
12458c12931
< #line 1478
---
> #line 1538
12460c12933
< #line 1481
---
> #line 1541
12462c12935
< #line 1482
---
> #line 1542
12467c12940
< #line 1484
---
> #line 1544
12469c12942
< #line 1485
---
> #line 1545
12471c12944
< #line 1489
---
> #line 1549
12473c12946
< #line 1490
---
> #line 1550
12475c12948
< #line 1493
---
> #line 1553
12477,12480c12950,12953
< #line 1493
<   goto ldv_51639;
<   ldv_51638: 
< #line 1494
---
> #line 1553
>   goto ldv_52210;
>   ldv_52209: 
> #line 1554
12482c12955
< #line 1495
---
> #line 1555
12484,12487c12957,12960
< #line 1496
<   __might_sleep("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<                 1496, 0);
< #line 1496
---
> #line 1556
>   __might_sleep("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
>                 1556, 0);
> #line 1556
12489c12962
< #line 1497
---
> #line 1557
12491c12964
< #line 1498
---
> #line 1558
12493c12966
< #line 1493
---
> #line 1553
12495,12496c12968,12969
<   ldv_51639: ;
< #line 1493
---
>   ldv_52210: ;
> #line 1553
12498,12499c12971,12972
< #line 1494
<     goto ldv_51638;
---
> #line 1554
>     goto ldv_52209;
12503c12976
< #line 1501
---
> #line 1561
12505c12978
< #line 1509
---
> #line 1569
12507c12980
< #line 1510
---
> #line 1570
12512c12985
< #line 1517
---
> #line 1577
12514c12987
< #line 1518
---
> #line 1578
12519c12992
< #line 1519
---
> #line 1579
12521c12994
< #line 1520
---
> #line 1580
12525c12998
< #line 1529 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1589 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12532,12536c13005,13011
<   int _b ;
<   int _b___0 ;
<   raw_spinlock_t *tmp ;
<   unsigned int tmp___0 ;
<   int tmp___1 ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
>   raw_spinlock_t *tmp___1 ;
>   unsigned int tmp___2 ;
>   int tmp___3 ;
12539c13014
< #line 1532
---
> #line 1592
12541,12548c13016,13022
< #line 1536
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 1536
<   if (_b != 0) {
< #line 1536
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_test_bit", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1536);
---
> #line 1596
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 1596
>   if (! _bool) {
> #line 1596
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "drbd_bm_test_bit");
12552,12554c13026,13036
< #line 1536
<   if (_b != 0) {
< #line 1536
---
> #line 1596
>   if (_bool) {
> #line 1596
>     tmp = 0;
>   } else {
> #line 1596
>     tmp = 1;
>   }
> #line 1596
>   if (tmp) {
> #line 1597
12559,12566c13041,13047
< #line 1537
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 1537
<   if (_b___0 != 0) {
< #line 1537
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_test_bit", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1537);
---
> #line 1598
>   _bool___0 = (unsigned long )b->bm_pages != (unsigned long )((struct page **)0);
> #line 1598
>   if (! _bool___0) {
> #line 1598
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b->bm_pages", "drbd_bm_test_bit");
12570,12572c13051,13061
< #line 1537
<   if (_b___0 != 0) {
< #line 1537
---
> #line 1598
>   if (_bool___0) {
> #line 1598
>     tmp___0 = 0;
>   } else {
> #line 1598
>     tmp___0 = 1;
>   }
> #line 1598
>   if (tmp___0) {
> #line 1599
12577,12581c13066,13070
< #line 1539
<   tmp = spinlock_check(& b->bm_lock);
< #line 1539
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 1540
---
> #line 1601
>   tmp___1 = spinlock_check(& b->bm_lock);
> #line 1601
>   flags = _raw_spin_lock_irqsave(tmp___1);
> #line 1602
12583c13072
< #line 1541
---
> #line 1603
12588c13077
< #line 1542
---
> #line 1604
12590,12598c13079,13087
< #line 1543
<     tmp___0 = bm_bit_to_page_idx(b, (u64 )bitnr);
< #line 1543
<     p_addr = bm_map_pidx(b, tmp___0);
< #line 1544
<     tmp___1 = test_bit_le((int )bitnr & 32767, (void const   *)p_addr);
< #line 1544
<     i = tmp___1 != 0;
< #line 1545
---
> #line 1605
>     tmp___2 = bm_bit_to_page_idx(b, (u64 )bitnr);
> #line 1605
>     p_addr = bm_map_pidx(b, tmp___2);
> #line 1606
>     tmp___3 = test_bit_le((int )bitnr & 32767, (void const   *)p_addr);
> #line 1606
>     i = tmp___3 != 0;
> #line 1607
12601c13090
< #line 1546
---
> #line 1608
12603c13092
< #line 1547
---
> #line 1609
12606c13095
< #line 1549
---
> #line 1611
12609c13098
< #line 1550
---
> #line 1612
12612c13101
< #line 1553
---
> #line 1615
12614c13103
< #line 1554
---
> #line 1616
12618c13107
< #line 1558 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1620 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12627,12629c13116,13120
<   int _b ;
<   int _b___0 ;
<   raw_spinlock_t *tmp ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
>   raw_spinlock_t *tmp___1 ;
12631,12633c13122,13124
<   unsigned int tmp___0 ;
<   int tmp___1 ;
<   int _b___1 ;
---
>   unsigned int tmp___2 ;
>   int tmp___3 ;
>   bool _bool___1 ;
12636c13127
< #line 1561
---
> #line 1623
12638c13129
< #line 1562
---
> #line 1624
12640c13131
< #line 1564
---
> #line 1626
12642c13133
< #line 1565
---
> #line 1627
12644,12651c13135,13141
< #line 1571
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 1571
<   if (_b != 0) {
< #line 1571
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_count_bits", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1571);
---
> #line 1633
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 1633
>   if (! _bool) {
> #line 1633
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "drbd_bm_count_bits");
12655,12657c13145,13155
< #line 1571
<   if (_b != 0) {
< #line 1571
---
> #line 1633
>   if (_bool) {
> #line 1633
>     tmp = 0;
>   } else {
> #line 1633
>     tmp = 1;
>   }
> #line 1633
>   if (tmp) {
> #line 1634
12662,12669c13160,13166
< #line 1572
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 1572
<   if (_b___0 != 0) {
< #line 1572
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_count_bits", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1572);
---
> #line 1635
>   _bool___0 = (unsigned long )b->bm_pages != (unsigned long )((struct page **)0);
> #line 1635
>   if (! _bool___0) {
> #line 1635
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b->bm_pages", "drbd_bm_count_bits");
12673,12675c13170,13180
< #line 1572
<   if (_b___0 != 0) {
< #line 1572
---
> #line 1635
>   if (_bool___0) {
> #line 1635
>     tmp___0 = 0;
>   } else {
> #line 1635
>     tmp___0 = 1;
>   }
> #line 1635
>   if (tmp___0) {
> #line 1636
12680,12684c13185,13189
< #line 1574
<   tmp = spinlock_check(& b->bm_lock);
< #line 1574
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 1575
---
> #line 1638
>   tmp___1 = spinlock_check(& b->bm_lock);
> #line 1638
>   flags = _raw_spin_lock_irqsave(tmp___1);
> #line 1639
12686c13191
< #line 1576
---
> #line 1640
12691c13196
< #line 1577
---
> #line 1641
12693,12700c13198,13205
< #line 1577
<   goto ldv_51680;
<   ldv_51679: 
< #line 1578
<   tmp___0 = bm_bit_to_page_idx(b, (u64 )bitnr);
< #line 1578
<   idx = tmp___0;
< #line 1579
---
> #line 1641
>   goto ldv_52251;
>   ldv_52250: 
> #line 1642
>   tmp___2 = bm_bit_to_page_idx(b, (u64 )bitnr);
> #line 1642
>   idx = tmp___2;
> #line 1643
12702c13207
< #line 1580
---
> #line 1644
12704c13209
< #line 1581
---
> #line 1645
12706c13211
< #line 1582
---
> #line 1646
12711c13216
< #line 1583
---
> #line 1647
12716,12723c13221,13227
< #line 1585
<   _b___1 = b->bm_bits <= bitnr;
< #line 1585
<   if (_b___1 != 0) {
< #line 1585
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_count_bits", (char *)"bitnr >= b->bm_bits", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1585);
---
> #line 1649
>   _bool___1 = b->bm_bits > bitnr;
> #line 1649
>   if (! _bool___1) {
> #line 1649
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"bitnr < b->bm_bits", "drbd_bm_count_bits");
12727,12729c13231,13238
< #line 1585
<   if (_b___1 != 0) {
< #line 1586
---
> #line 1649
>   if ((int )_bool___1) {
> #line 1650
>     tmp___3 = test_bit_le((int )((unsigned int )bitnr - (page_nr << 15)), (void const   *)p_addr);
> #line 1650
>     c = (tmp___3 != 0) + c;
>   } else {
> #line 1652
12732,12736d13240
<   } else {
< #line 1588
<     tmp___1 = test_bit_le((int )((unsigned int )bitnr - (page_nr << 15)), (void const   *)p_addr);
< #line 1588
<     c = (tmp___1 != 0) + c;
12738c13242
< #line 1577
---
> #line 1641
12740,12741c13244,13245
<   ldv_51680: ;
< #line 1577
---
>   ldv_52251: ;
> #line 1641
12743,12744c13247,13248
< #line 1578
<     goto ldv_51679;
---
> #line 1642
>     goto ldv_52250;
12749c13253
< #line 1591
---
> #line 1654
12751c13255
< #line 1592
---
> #line 1655
12756c13260
< #line 1593
---
> #line 1656
12758c13262
< #line 1594
---
> #line 1657
12762c13266
< #line 1612 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
---
> #line 1675 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
12772,12774c13276,13280
<   int _b ;
<   int _b___0 ;
<   raw_spinlock_t *tmp ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
>   raw_spinlock_t *tmp___1 ;
12778,12781c13284,13287
<   unsigned int tmp___0 ;
<   unsigned long *tmp___1 ;
<   unsigned long tmp___2 ;
<   int tmp___3 ;
---
>   unsigned int tmp___2 ;
>   unsigned long *tmp___3 ;
>   unsigned long tmp___4 ;
>   int tmp___5 ;
12784c13290
< #line 1614
---
> #line 1677
12786,12793c13292,13298
< #line 1619
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 1619
<   if (_b != 0) {
< #line 1619
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_e_weight", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1619);
---
> #line 1682
>   _bool = (unsigned long )b != (unsigned long )((struct drbd_bitmap *)0);
> #line 1682
>   if (! _bool) {
> #line 1682
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b", "drbd_bm_e_weight");
12797,12799c13302,13312
< #line 1619
<   if (_b != 0) {
< #line 1619
---
> #line 1682
>   if (_bool) {
> #line 1682
>     tmp = 0;
>   } else {
> #line 1682
>     tmp = 1;
>   }
> #line 1682
>   if (tmp) {
> #line 1683
12804,12811c13317,13323
< #line 1620
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 1620
<   if (_b___0 != 0) {
< #line 1620
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_e_weight", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1620);
---
> #line 1684
>   _bool___0 = (unsigned long )b->bm_pages != (unsigned long )((struct page **)0);
> #line 1684
>   if (! _bool___0) {
> #line 1684
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"b->bm_pages", "drbd_bm_e_weight");
12815,12817c13327,13337
< #line 1620
<   if (_b___0 != 0) {
< #line 1620
---
> #line 1684
>   if (_bool___0) {
> #line 1684
>     tmp___0 = 0;
>   } else {
> #line 1684
>     tmp___0 = 1;
>   }
> #line 1684
>   if (tmp___0) {
> #line 1685
12822,12826c13342,13346
< #line 1622
<   tmp = spinlock_check(& b->bm_lock);
< #line 1622
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 1623
---
> #line 1687
>   tmp___1 = spinlock_check(& b->bm_lock);
> #line 1687
>   flags = _raw_spin_lock_irqsave(tmp___1);
> #line 1688
12828c13348
< #line 1624
---
> #line 1689
12833c13353
< #line 1626
---
> #line 1691
12835c13355
< #line 1627
---
> #line 1692
12837c13357
< #line 1627
---
> #line 1692
12839c13359
< #line 1627
---
> #line 1692
12841c13361
< #line 1628
---
> #line 1693
12843c13363
< #line 1629
---
> #line 1694
12845c13365
< #line 1630
---
> #line 1695
12847,12851c13367,13371
< #line 1631
<     tmp___0 = bm_word_to_page_idx(b, (unsigned long )s);
< #line 1631
<     p_addr = bm_map_pidx(b, tmp___0);
< #line 1632
---
> #line 1696
>     tmp___2 = bm_word_to_page_idx(b, (unsigned long )s);
> #line 1696
>     p_addr = bm_map_pidx(b, tmp___2);
> #line 1697
12853,12858c13373,13378
< #line 1633
<     goto ldv_51706;
<     ldv_51705: 
< #line 1634
<     tmp___1 = bm;
< #line 1634
---
> #line 1698
>     goto ldv_52277;
>     ldv_52276: 
> #line 1699
>     tmp___3 = bm;
> #line 1699
12860,12867c13380,13387
< #line 1634
<     tmp___2 = hweight_long(*tmp___1);
< #line 1634
<     count = (int )((unsigned int )tmp___2 + (unsigned int )count);
<     ldv_51706: 
< #line 1633
<     tmp___3 = n;
< #line 1633
---
> #line 1699
>     tmp___4 = hweight_long(*tmp___3);
> #line 1699
>     count = (int )((unsigned int )tmp___4 + (unsigned int )count);
>     ldv_52277: 
> #line 1698
>     tmp___5 = n;
> #line 1698
12869,12872c13389,13392
< #line 1633
<     if (tmp___3 != 0) {
< #line 1634
<       goto ldv_51705;
---
> #line 1698
>     if (tmp___5 != 0) {
> #line 1699
>       goto ldv_52276;
12876c13396
< #line 1635
---
> #line 1700
12879c13399
< #line 1637
---
> #line 1702
12883c13403
< #line 1639
---
> #line 1704
12885c13405
< #line 1640
---
> #line 1705
12889,13039d13408
< #line 1645 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared"
< unsigned long drbd_bm_ALe_set_all(struct drbd_conf *mdev , unsigned long al_enr ) 
< { 
<   struct drbd_bitmap *b ;
<   unsigned long *p_addr ;
<   unsigned long *bm ;
<   unsigned long weight ;
<   unsigned long s ;
<   unsigned long e ;
<   int count ;
<   int i ;
<   int do_now ;
<   int _b ;
<   int _b___0 ;
<   size_t __min1 ;
<   size_t __min2 ;
<   unsigned int tmp ;
<   unsigned long tmp___0 ;
<   int tmp___1 ;
<   int tmp___2 ;
< 
<   {
< #line 1647
<   b = mdev->bitmap;
< #line 1652
<   _b = (unsigned long )b == (unsigned long )((struct drbd_bitmap *)0);
< #line 1652
<   if (_b != 0) {
< #line 1652
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_ALe_set_all", (char *)"!b", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1652);
<   } else {
< 
<   }
< #line 1652
<   if (_b != 0) {
< #line 1652
<     return (0UL);
<   } else {
< 
<   }
< #line 1653
<   _b___0 = (unsigned long )b->bm_pages == (unsigned long )((struct page **)0);
< #line 1653
<   if (_b___0 != 0) {
< #line 1653
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_bm_ALe_set_all", (char *)"!b->bm_pages", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1653);
<   } else {
< 
<   }
< #line 1653
<   if (_b___0 != 0) {
< #line 1653
<     return (0UL);
<   } else {
< 
<   }
< #line 1655
<   spin_lock_irq(& b->bm_lock);
< #line 1656
<   if (((unsigned int )b->bm_flags & 2U) != 0U) {
< #line 1657
<     __bm_print_lock_info(mdev, "drbd_bm_ALe_set_all");
<   } else {
< 
<   }
< #line 1658
<   weight = b->bm_set;
< #line 1660
<   s = al_enr * 16UL;
< #line 1661
<   __min1 = s + 16UL;
< #line 1661
<   __min2 = b->bm_words;
< #line 1661
<   e = __min1 < __min2 ? __min1 : __min2;
< #line 1663
<   if ((e - 1UL) >> 9 != s >> 9) {
< #line 1663
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( (e-1) >> (PAGE_SHIFT - LN2_BPL + 3) == s >> (PAGE_SHIFT - LN2_BPL + 3) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_bitmap.c.prepared",
<             1664);
<   } else {
< 
<   }
< #line 1665
<   count = 0;
< #line 1666
<   if (b->bm_words > s) {
< #line 1667
<     do_now = (int )((unsigned int )e - (unsigned int )s);
< #line 1667
<     i = do_now;
< #line 1668
<     tmp = bm_word_to_page_idx(b, s);
< #line 1668
<     p_addr = bm_map_pidx(b, tmp);
< #line 1669
<     bm = p_addr + (s & 511UL);
< #line 1670
<     goto ldv_51730;
<     ldv_51729: 
< #line 1671
<     tmp___0 = hweight_long(*bm);
< #line 1671
<     count = (int )((unsigned int )tmp___0 + (unsigned int )count);
< #line 1672
<     *bm = 0xffffffffffffffffUL;
< #line 1673
<     bm = bm + 1;
<     ldv_51730: 
< #line 1670
<     tmp___1 = i;
< #line 1670
<     i = i - 1;
< #line 1670
<     if (tmp___1 != 0) {
< #line 1671
<       goto ldv_51729;
<     } else {
< 
<     }
< #line 1675
<     bm_unmap(p_addr);
< #line 1676
<     b->bm_set = b->bm_set + (unsigned long )(do_now * 64 - count);
< #line 1677
<     if (b->bm_words == e) {
< #line 1678
<       tmp___2 = bm_clear_surplus(b);
< #line 1678
<       b->bm_set = b->bm_set - (unsigned long )tmp___2;
<     } else {
< 
<     }
<   } else {
< #line 1680
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "start offset (%lu) too large in drbd_bm_ALe_set_all\n",
<             s);
<   }
< #line 1682
<   weight = b->bm_set - weight;
< #line 1683
<   spin_unlock_irq(& b->bm_lock);
< #line 1684
<   return (weight);
< }
< }
13046c13415
< #line 3 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 3 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13084c13453,13455
< #line 55 "include/linux/drbd.h"
---
> #line 110 "include/linux/idr.h"
> extern void *idr_get_next(struct idr * , int * ) ;
> #line 54 "include/linux/drbd.h"
13086c13457
< #line 303
---
> #line 326
13088c13459
< #line 304
---
> #line 327
13090c13461
< #line 305
---
> #line 328
13123c13494
< #line 255 "include/linux/lru_cache.h"
---
> #line 266 "include/linux/lru_cache.h"
13125c13496
< #line 257
---
> #line 268
13128,13144c13499,13501
< #line 61 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< unsigned int minor_count ;
< #line 157
< struct drbd_conf **minor_table ;
< #line 1174 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static struct drbd_conf *minor_to_mdev(unsigned int minor ) 
< { 
<   struct drbd_conf *mdev ;
< 
<   {
< #line 1178
<   mdev = minor < minor_count ? *(minor_table + (unsigned long )minor) : 0;
< #line 1180
<   return (mdev);
< }
< }
< #line 1575
---
> #line 167 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct idr minors ;
> #line 1418
13146c13503
< #line 1722 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1573 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
13148c13505
< #line 1723
---
> #line 1574
13150c13507
< #line 2287 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2083 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
13162,13164c13519,13521
< #line 2298
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 288U || (unsigned int )*((unsigned short *)mdev + 1138UL) == 304U) {
< #line 2299
---
> #line 2094
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 288U || (unsigned int )*((unsigned short *)mdev + 374UL) == 304U) {
> #line 2095
13167c13524
< #line 2301
---
> #line 2097
13169c13526
< #line 2301
---
> #line 2097
13172c13529
< #line 2304
---
> #line 2100
13174c13531
< #line 2310
---
> #line 2106
13176,13178c13533,13535
< #line 2311
<     tmp___0 = drbd_conn_str((enum drbd_conns )mdev->state.ldv_40583.conn);
< #line 2311
---
> #line 2107
>     tmp___0 = drbd_conn_str((enum drbd_conns )mdev->state.ldv_50103.conn);
> #line 2107
13181c13538
< #line 2314
---
> #line 2110
13184c13541
< #line 2325
---
> #line 2121
13186c13543
< #line 2326
---
> #line 2122
13188c13545
< #line 2327
---
> #line 2123
13190c13547
< #line 2328
---
> #line 2124
13192c13549
< #line 2329
---
> #line 2125
13195c13552
< #line 2331
---
> #line 2127
13199,13200c13556,13569
< #line 2417 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int is_susp(union drbd_state s ) 
---
> #line 2216 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static int drbd_suspended(struct drbd_conf *mdev ) 
> { 
>   struct drbd_tconn *tconn ;
> 
>   {
> #line 2218
>   tconn = mdev->tconn;
> #line 2220
>   return (((unsigned int )*((unsigned char *)tconn + 132UL) != 0U || (unsigned int )*((unsigned char *)tconn + 132UL) != 0U) || (unsigned int )*((unsigned char *)tconn + 132UL) != 0U);
> }
> }
> #line 2294 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static bool verify_can_do_stop_sector(struct drbd_conf *mdev ) 
13205,13206c13574,13575
< #line 2419
<   return (((unsigned int )*((unsigned char *)(& s) + 2UL) != 0U || (unsigned int )*((unsigned char *)(& s) + 2UL) != 0U) || (unsigned int )*((unsigned char *)(& s) + 2UL) != 0U);
---
> #line 2296
>   return ((bool )((mdev->tconn)->agreed_pro_version > 96 && (mdev->tconn)->agreed_pro_version != 100));
13209c13578
< #line 44 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 44 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13213c13582
< #line 49 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 49 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13218c13587
< #line 57 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 57 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13251c13620
< #line 77 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 77 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13267a13637
>   bool tmp___0 ;
13283,13284c13653,13654
<   goto ldv_51196;
<   ldv_51195: 
---
>   goto ldv_51758;
>   ldv_51757: 
13289c13659
<   ldv_51196: ;
---
>   ldv_51758: ;
13293c13663
<     goto ldv_51195;
---
>     goto ldv_51757;
13302,13303c13672,13673
<   goto ldv_51199;
<   ldv_51198: 
---
>   goto ldv_51761;
>   ldv_51760: 
13308c13678
<   ldv_51199: ;
---
>   ldv_51761: ;
13312c13682
<     goto ldv_51198;
---
>     goto ldv_51760;
13319c13689
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 288U || (unsigned int )*((unsigned short *)mdev + 1138UL) == 304U) {
---
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 288U || (unsigned int )*((unsigned short *)mdev + 374UL) == 304U) {
13410c13780
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 272U || (unsigned int )*((unsigned short *)mdev + 1138UL) == 288U) {
---
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 272U || (unsigned int )*((unsigned short *)mdev + 374UL) == 288U) {
13429c13799
<     if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 288U || (unsigned int )*((unsigned short *)mdev + 1138UL) == 304U) {
---
>     if ((unsigned int )*((unsigned short *)mdev + 374UL) == 288U || (unsigned int )*((unsigned short *)mdev + 374UL) == 304U) {
13433c13803,13805
<       if (mdev->agreed_pro_version > 96) {
---
>       tmp___0 = verify_can_do_stop_sector(mdev);
> #line 182
>       if ((int )tmp___0) {
13462c13834
< #line 199 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 199 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13479c13851
< #line 209 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 209 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13483c13855
<   int hole ;
---
>   int prev_i ;
13485a13858,13859
>   struct net_conf *nc ;
>   char wp ;
13488c13862,13864
<   int tmp___0 ;
---
>   void *tmp___0 ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
13495,13497c13871,13873
<   char const   *tmp___7 ;
<   char const   *tmp___8 ;
<   char const   *tmp___9 ;
---
>   int tmp___7 ;
>   int tmp___8 ;
>   int tmp___9 ;
13499,13500c13875,13880
<   unsigned long tmp___11 ;
<   int tmp___12 ;
---
>   char const   *tmp___11 ;
>   char const   *tmp___12 ;
>   char const   *tmp___13 ;
>   unsigned long tmp___14 ;
>   int tmp___15 ;
>   void *tmp___16 ;
13504,13505c13884,13885
<   hole = 0;
< #line 215
---
>   prev_i = -1;
> #line 217
13507c13887
< #line 215
---
> #line 217
13509c13889
< #line 215
---
> #line 217
13511c13891
< #line 221
---
> #line 223
13513,13521c13893,13894
< #line 221
<   seq_printf(seq, "version: 8.3.14 (api:%d/proto:%d-%d)\n%s\n", 88, 86, 97, tmp);
< #line 244
<   i = 0;
< #line 244
<   goto ldv_51222;
<   ldv_51221: 
< #line 245
<   mdev = minor_to_mdev((unsigned int )i);
---
> #line 223
>   seq_printf(seq, "version: 8.4.2 (api:%d/proto:%d-%d)\n%s\n", 1, 86, 101, tmp);
13523c13896,13898
<   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
---
>   rcu_read_lock();
> #line 247
>   i = 0;
13525c13900,13905
<     hole = 1;
---
>   tmp___0 = idr_get_next(& minors, & i);
> #line 247
>   mdev = (struct drbd_conf *)tmp___0;
> #line 247
>   goto ldv_51788;
>   ldv_51787: ;
13527c13907,13909
<     goto ldv_51220;
---
>   if (i + -1 != prev_i) {
> #line 249
>     seq_printf(seq, "\n");
13532,13534c13914
<   if (hole != 0) {
< #line 251
<     hole = 0;
---
>   prev_i = i;
13536,13541c13916,13918
<     seq_printf(seq, "\n");
<   } else {
< 
<   }
< #line 255
<   sn = drbd_conn_str((enum drbd_conns )mdev->state.ldv_40583.conn);
---
>   sn = drbd_conn_str((enum drbd_conns )mdev->state.ldv_50103.conn);
> #line 254
>   if (((unsigned int )*((unsigned short *)mdev + 374UL) == 0U && (unsigned int )*((unsigned char *)mdev + 749UL) == 0U) && (unsigned int )*((unsigned char *)mdev + 748UL) == 2U) {
13543,13544d13919
<   if (((unsigned int )*((unsigned short *)mdev + 1138UL) == 0U && (unsigned int )*((unsigned char *)mdev + 2277UL) == 0U) && (unsigned int )*((unsigned char *)mdev + 2276UL) == 2U) {
< #line 260
13547c13922
< #line 263
---
> #line 260
13549,13571c13924,13971
< #line 265
<     tmp___0 = atomic_read((atomic_t const   *)(& mdev->ap_bio_cnt));
< #line 265
<     tmp___1 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 265
<     tmp___2 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 265
<     tmp___3 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 265
<     tmp___4 = atomic_read((atomic_t const   *)(& mdev->local_cnt));
< #line 265
<     tmp___5 = drbd_test_flag(mdev, AL_SUSPENDED);
< #line 265
<     tmp___6 = is_susp(mdev->state);
< #line 265
<     tmp___7 = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_40583.pdsk);
< #line 265
<     tmp___8 = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_40583.disk);
< #line 265
<     tmp___9 = drbd_role_str((enum drbd_role )mdev->state.ldv_40583.peer);
< #line 265
<     tmp___10 = drbd_role_str((enum drbd_role )mdev->state.ldv_40583.role);
< #line 265
---
> #line 262
>     _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 262
>     tmp___1 = debug_lockdep_rcu_enabled();
> #line 262
>     if (tmp___1 != 0 && ! __warned) {
> #line 262
>       tmp___2 = rcu_read_lock_held();
> #line 262
>       if (tmp___2 == 0 && 1) {
> #line 262
>         __warned = 1;
> #line 262
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared",
>                                262, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 262
>     nc = _________p1;
> #line 263
>     wp = (unsigned long )nc != (unsigned long )((struct net_conf *)0) ? (char )((unsigned int )((unsigned char )nc->wire_protocol) + 64U) : 32;
> #line 264
>     tmp___3 = atomic_read((atomic_t const   *)(& mdev->ap_bio_cnt));
> #line 264
>     tmp___4 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
> #line 264
>     tmp___5 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
> #line 264
>     tmp___6 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
> #line 264
>     tmp___7 = atomic_read((atomic_t const   *)(& mdev->local_cnt));
> #line 264
>     tmp___8 = constant_test_bit(18U, (unsigned long const volatile   *)(& mdev->flags));
> #line 264
>     tmp___9 = drbd_suspended(mdev);
> #line 264
>     tmp___10 = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_50103.pdsk);
> #line 264
>     tmp___11 = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_50103.disk);
> #line 264
>     tmp___12 = drbd_role_str((enum drbd_role )mdev->state.ldv_50103.peer);
> #line 264
>     tmp___13 = drbd_role_str((enum drbd_role )mdev->state.ldv_50103.role);
> #line 264
13573,13578c13973,13976
<                i, sn, tmp___10, tmp___9, tmp___8, tmp___7, (unsigned long )mdev->net_conf != (unsigned long )((struct net_conf *)0) ? (mdev->net_conf)->wire_protocol + 64 : 32,
<                tmp___6 != 0 ? 115 : 114, (unsigned int )*((unsigned char *)mdev + 2278UL) != 0U ? 97 : 45,
<                (unsigned int )*((unsigned char *)mdev + 2278UL) != 0U ? 112 : 45,
<                (unsigned int )*((unsigned char *)mdev + 2278UL) != 0U ? 117 : 45,
<                (int )mdev->congestion_reason != 0 ? (int )mdev->congestion_reason : 45,
<                tmp___5 != 0 ? 115 : 45, mdev->send_cnt / 2U, mdev->recv_cnt / 2U,
---
>                i, sn, tmp___13, tmp___12, tmp___11, tmp___10, (int )wp, tmp___9 != 0 ? 115 : 114,
>                (unsigned int )*((unsigned char *)mdev + 750UL) != 0U ? 97 : 45, (unsigned int )*((unsigned char *)mdev + 750UL) != 0U ? 112 : 45,
>                (unsigned int )*((unsigned char *)mdev + 750UL) != 0U ? 117 : 45, (int )mdev->congestion_reason != 0 ? (int )mdev->congestion_reason : 45,
>                tmp___8 != 0 ? 115 : 45, mdev->send_cnt / 2U, mdev->recv_cnt / 2U,
13580,13584c13978,13983
<                tmp___4, tmp___2 + tmp___3, tmp___1, tmp___0, mdev->epochs, (int )write_ordering_chars[(unsigned int )mdev->write_ordering]);
< #line 296
<     tmp___11 = drbd_bm_total_weight(mdev);
< #line 296
<     seq_printf(seq, " oos:%llu\n", (unsigned long long )tmp___11 << 2);
---
>                tmp___7, tmp___5 + tmp___6, tmp___4, tmp___3, (mdev->tconn)->epochs,
>                (int )write_ordering_chars[(unsigned int )(mdev->tconn)->write_ordering]);
> #line 294
>     tmp___14 = drbd_bm_total_weight(mdev);
> #line 294
>     seq_printf(seq, " oos:%llu\n", (unsigned long long )tmp___14 << 2);
13586,13588c13985,13987
< #line 300
<   if ((((unsigned int )*((unsigned short *)mdev + 1138UL) == 256U || (unsigned int )*((unsigned short *)mdev + 1138UL) == 272U) || (unsigned int )*((unsigned short *)mdev + 1138UL) == 288U) || (unsigned int )*((unsigned short *)mdev + 1138UL) == 304U) {
< #line 304
---
> #line 298
>   if ((((unsigned int )*((unsigned short *)mdev + 374UL) == 256U || (unsigned int )*((unsigned short *)mdev + 374UL) == 272U) || (unsigned int )*((unsigned short *)mdev + 374UL) == 288U) || (unsigned int )*((unsigned short *)mdev + 374UL) == 304U) {
> #line 302
13593c13992
< #line 306
---
> #line 304
13595,13599c13994,13998
< #line 306
<     tmp___12 = _get_ldev_if_state(mdev, D_FAILED);
< #line 306
<     if (tmp___12 != 0) {
< #line 307
---
> #line 304
>     tmp___15 = _get_ldev_if_state(mdev, D_FAILED);
> #line 304
>     if (tmp___15 != 0) {
> #line 305
13601c14000
< #line 308
---
> #line 306
13603c14002
< #line 309
---
> #line 307
13611c14010
< #line 312
---
> #line 310
13613c14012
< #line 313
---
> #line 311
13615c14014
< #line 314
---
> #line 312
13623,13624c14022
<   ldv_51220: 
< #line 244
---
> #line 247
13626,13630c14024,14032
<   ldv_51222: ;
< #line 244
<   if ((unsigned int )i < minor_count) {
< #line 245
<     goto ldv_51221;
---
> #line 247
>   tmp___16 = idr_get_next(& minors, & i);
> #line 247
>   mdev = (struct drbd_conf *)tmp___16;
>   ldv_51788: ;
> #line 247
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 248
>     goto ldv_51787;
13634,13635c14036,14038
< 
< #line 320
---
> #line 317
>   rcu_read_unlock();
> #line 319
13639c14042
< #line 323 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 322 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13647c14050
< #line 325
---
> #line 324
13649c14052
< #line 325
---
> #line 324
13651c14054
< #line 326
---
> #line 325
13653c14056
< #line 326
---
> #line 325
13655c14058
< #line 326
---
> #line 325
13660c14063
< #line 327
---
> #line 326
13664c14067
< #line 330 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 329 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13670c14073
< #line 332
---
> #line 331
13672c14075
< #line 333
---
> #line 332
13674c14077
< #line 333
---
> #line 332
13678c14081
< #line 354
---
> #line 353
13680c14083
< #line 357
---
> #line 356
13682c14085
< #line 363
---
> #line 362
13684c14087
< #line 366
---
> #line 365
13686c14089
< #line 369
---
> #line 368
13688c14091
< #line 372 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 371 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13690c14093
< #line 375 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 374 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13701c14104
< #line 409
---
> #line 408
13703c14106
< #line 399
---
> #line 398
13705c14108
< #line 408
---
> #line 407
13707,13710c14110,14113
< #line 412
<   goto ldv_51258;
<   ldv_51257: 
< #line 416
---
> #line 411
>   goto ldv_51824;
>   ldv_51823: 
> #line 415
13712c14115
< #line 416
---
> #line 415
13715c14118
< #line 421
---
> #line 420
13717c14120
< #line 426
---
> #line 425
13719c14122
< #line 427
---
> #line 426
13721c14124
< #line 428
---
> #line 427
13723c14126
< #line 429
---
> #line 428
13725c14128
< #line 430
---
> #line 429
13730c14133
< #line 431
---
> #line 430
13735,13736c14138,14139
< #line 437
<   goto ldv_51254;
---
> #line 436
>   goto ldv_51820;
13738c14141
< #line 441
---
> #line 440
13740c14143
< #line 446
---
> #line 445
13742c14145
< #line 447
---
> #line 446
13744c14147
< #line 448
---
> #line 447
13749,13750c14152,14153
< #line 454
<   goto ldv_51254;
---
> #line 453
>   goto ldv_51820;
13752,13753c14155,14156
< #line 455
<   goto ldv_51254;
---
> #line 454
>   goto ldv_51820;
13755,13757c14158,14160
<   ldv_51254: ;
<   ldv_51258: 
< #line 412
---
>   ldv_51820: ;
>   ldv_51824: 
> #line 411
13759c14162
< #line 412
---
> #line 411
13761,13762c14164,14165
< #line 414
<     goto ldv_51257;
---
> #line 413
>     goto ldv_51823;
13768c14171
< #line 464
---
> #line 463
13770c14173
< #line 467
---
> #line 466
13774c14177
< #line 471 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 470 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13780c14183
< #line 476
---
> #line 475
13782c14185
< #line 476
---
> #line 475
13786c14189
< #line 479 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
---
> #line 478 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_proc.c.prepared"
13792c14195
< #line 484
---
> #line 483
13794c14197
< #line 485
---
> #line 484
13857a14261,14288
> #line 153 "include/linux/list.h"
> __inline static void list_move(struct list_head *list , struct list_head *head ) 
> { 
> 
> 
>   {
> #line 155
>   __list_del_entry(list);
> #line 156
>   list_add(list, head);
> #line 157
>   return;
> }
> }
> #line 164 "include/linux/list.h"
> __inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
> { 
> 
> 
>   {
> #line 167
>   __list_del_entry(list);
> #line 168
>   list_add_tail(list, head);
> #line 169
>   return;
> }
> }
13915,13916d14345
< #line 323
< extern int sprintf(char * , char const   *  , ...) ;
14010,14012c14439,14450
< #line 279 "include/linux/lockdep.h"
< extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
<                              int  ) ;
---
> #line 89 "include/linux/thread_info.h"
> __inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
> { 
>   int tmp ;
> 
>   {
> #line 91
>   tmp = variable_test_bit(flag, (unsigned long const volatile   *)(& ti->flags));
> #line 91
>   return (tmp);
> }
> }
14050a14489,14517
> #line 40 "include/linux/kref.h"
> __inline static void kref_get(struct kref *kref ) 
> { 
>   int __ret_warn_on ;
>   int tmp ;
>   long tmp___0 ;
> 
>   {
> #line 42
>   tmp = atomic_read((atomic_t const   *)(& kref->refcount));
> #line 42
>   __ret_warn_on = tmp == 0;
> #line 42
>   tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
> #line 42
>   if (tmp___0 != 0L) {
> #line 42
>     warn_slowpath_null("include/linux/kref.h", 42);
>   } else {
> 
>   }
> #line 42
>   __builtin_expect(__ret_warn_on != 0, 0L);
> #line 43
>   atomic_inc(& kref->refcount);
> #line 44
>   return;
> }
> }
14177,14223d14643
< #line 32 "include/linux/semaphore.h"
< __inline static void sema_init(struct semaphore *sem , int val ) 
< { 
<   struct lock_class_key __key ;
<   struct semaphore __constr_expr_0 ;
< 
<   {
< #line 35
<   __constr_expr_0.lock.raw_lock.ldv_5911.head_tail = 0U;
< #line 35
<   __constr_expr_0.lock.magic = 3735899821U;
< #line 35
<   __constr_expr_0.lock.owner_cpu = 4294967295U;
< #line 35
<   __constr_expr_0.lock.owner = 0xffffffffffffffffUL;
< #line 35
<   __constr_expr_0.lock.dep_map.key = 0;
< #line 35
<   __constr_expr_0.lock.dep_map.class_cache[0] = 0;
< #line 35
<   __constr_expr_0.lock.dep_map.class_cache[1] = 0;
< #line 35
<   __constr_expr_0.lock.dep_map.name = "(*sem).lock";
< #line 35
<   __constr_expr_0.lock.dep_map.cpu = 0;
< #line 35
<   __constr_expr_0.lock.dep_map.ip = 0UL;
< #line 35
<   __constr_expr_0.count = (unsigned int )val;
< #line 35
<   __constr_expr_0.wait_list.next = & sem->wait_list;
< #line 35
<   __constr_expr_0.wait_list.prev = & sem->wait_list;
< #line 35
<   *sem = __constr_expr_0;
< #line 36
<   lockdep_init_map(& sem->lock.dep_map, "semaphore->lock", & __key, 0);
< #line 37
<   return;
< }
< }
< #line 40
< extern int down_interruptible(struct semaphore * ) ;
< #line 42
< extern int down_trylock(struct semaphore * ) ;
< #line 44
< extern void up(struct semaphore * ) ;
14239a14660,14688
> #line 2533 "include/linux/sched.h"
> __inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
> { 
>   int tmp ;
> 
>   {
> #line 2535
>   tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
> #line 2535
>   return (tmp);
> }
> }
> #line 2559 "include/linux/sched.h"
> __inline static int signal_pending(struct task_struct *p ) 
> { 
>   int tmp ;
>   long tmp___0 ;
> 
>   {
> #line 2561
>   tmp = test_tsk_thread_flag(p, 2);
> #line 2561
>   tmp___0 = __builtin_expect(tmp != 0, 0L);
> #line 2561
>   return ((int )tmp___0);
> }
> }
> #line 104 "include/linux/idr.h"
> extern void *idr_find(struct idr * , int  ) ;
14350c14799,14802
< #line 674 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 131 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_state.h"
> enum drbd_state_rv conn_request_state(struct drbd_tconn *tconn , union drbd_state mask ,
>                                       union drbd_state val , enum chg_state_flags flags ) ;
> #line 525 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
14356c14808
< #line 680
---
> #line 531
14358c14810
< #line 681
---
> #line 532
14362,14387c14814,14817
< #line 1154 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void drbd_clear_flag(struct drbd_conf *mdev , enum drbd_flag f ) 
< { 
< 
< 
<   {
< #line 1156
<   clear_bit((int )f, (unsigned long volatile   *)(& mdev->drbd_flags));
< #line 1157
<   return;
< }
< }
< #line 1164 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int drbd_test_and_set_flag(struct drbd_conf *mdev , enum drbd_flag f ) 
< { 
<   int tmp ;
< 
<   {
< #line 1166
<   tmp = test_and_set_bit((int )f, (unsigned long volatile   *)(& mdev->drbd_flags));
< #line 1166
<   return (tmp);
< }
< }
< #line 1183 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static unsigned int mdev_to_minor(struct drbd_conf *mdev ) 
---
> #line 798
> struct fifo_buffer *fifo_alloc(int fifo_size ) ;
> #line 1037 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static struct drbd_conf *minor_to_mdev(unsigned int minor ) 
14389c14819
< 
---
>   void *tmp ;
14392,14393c14822,14825
< #line 1185
<   return (mdev->minor);
---
> #line 1039
>   tmp = idr_find(& minors, (int )minor);
> #line 1039
>   return ((struct drbd_conf *)tmp);
14396,14449c14828,14835
< #line 1196 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int drbd_get_data_sock(struct drbd_conf *mdev ) 
< { 
<   long tmp ;
< 
<   {
< #line 1198
<   mutex_lock_nested(& mdev->data.mutex, 0U);
< #line 1201
<   tmp = __builtin_expect((unsigned long )mdev->data.socket == (unsigned long )((struct socket *)0),
<                          0L);
< #line 1201
<   if (tmp != 0L) {
< #line 1202
<     mutex_unlock(& mdev->data.mutex);
< #line 1203
<     return (0);
<   } else {
< 
<   }
< #line 1205
<   return (1);
< }
< }
< #line 1208 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void drbd_put_data_sock(struct drbd_conf *mdev ) 
< { 
< 
< 
<   {
< #line 1210
<   mutex_unlock(& mdev->data.mutex);
< #line 1211
<   return;
< }
< }
< #line 1237
< void drbd_force_state(struct drbd_conf *mdev , union drbd_state mask , union drbd_state val ) ;
< #line 1249
< void _drbd_thread_stop(struct drbd_thread *thi , int restart , int wait ) ;
< #line 1251
< void drbd_thread_current_set_cpu(struct drbd_conf *mdev ) ;
< #line 1268
< int drbd_gen_and_send_sync_uuid(struct drbd_conf *mdev ) ;
< #line 1272
< int _drbd_send_cmd(struct drbd_conf *mdev , struct socket *sock , enum drbd_packets cmd ,
<                    struct p_header80 *h , size_t size , unsigned int msg_flags ) ;
< #line 1277
< int drbd_send_cmd(struct drbd_conf *mdev , int use_data_socket , enum drbd_packets cmd ,
<                   struct p_header80 *h , size_t size ) ;
< #line 1285
< int drbd_send_ack(struct drbd_conf *mdev , enum drbd_packets cmd , struct drbd_epoch_entry *e ) ;
< #line 1291
< int drbd_send_ack_ex(struct drbd_conf *mdev , enum drbd_packets cmd , sector_t sector ,
---
> #line 1068
> void drbd_thread_current_set_cpu(struct drbd_thread *thi ) ;
> #line 1087
> void drbd_gen_and_send_sync_uuid(struct drbd_conf *mdev ) ;
> #line 1094
> int drbd_send_ack(struct drbd_conf *mdev , enum drbd_packet cmd , struct drbd_peer_request *peer_req ) ;
> #line 1100
> int drbd_send_ack_ex(struct drbd_conf *mdev , enum drbd_packet cmd , sector_t sector ,
14451,14455c14837,14841
< #line 1293
< int drbd_send_oos(struct drbd_conf *mdev , struct drbd_request *req ) ;
< #line 1294
< int drbd_send_block(struct drbd_conf *mdev , enum drbd_packets cmd , struct drbd_epoch_entry *e ) ;
< #line 1296
---
> #line 1102
> int drbd_send_out_of_sync(struct drbd_conf *mdev , struct drbd_request *req ) ;
> #line 1103
> int drbd_send_block(struct drbd_conf *mdev , enum drbd_packet cmd , struct drbd_peer_request *peer_req ) ;
> #line 1105
14457c14843
< #line 1297
---
> #line 1106
14460c14846
< #line 1299
---
> #line 1108
14462,14463c14848,14849
<                             void *digest , int digest_size , enum drbd_packets cmd ) ;
< #line 1303
---
>                             void *digest , int digest_size , enum drbd_packet cmd ) ;
> #line 1111
14465c14851
< #line 1309
---
> #line 1117
14467c14853
< #line 1310
---
> #line 1118
14469c14855
< #line 1312
---
> #line 1121
14471c14857
< #line 1314
---
> #line 1123
14473c14859
< #line 1315
---
> #line 1124
14475c14861
< #line 1317
---
> #line 1126
14477c14863
< #line 1554
---
> #line 1388
14479c14865
< #line 1570 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1404 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
14481c14867,14869
< #line 1598
---
> #line 1408
> void drbd_minor_destroy(struct kref *kref ) ;
> #line 1443
14483c14871
< #line 1601
---
> #line 1446
14485,14487c14873,14877
< #line 1602
< int drbd_alter_sa(struct drbd_conf *mdev , int na ) ;
< #line 1603
---
> #line 1447
> enum drbd_ret_code drbd_resync_after_valid(struct drbd_conf *mdev , int o_minor ) ;
> #line 1448
> void drbd_resync_after_changed(struct drbd_conf *mdev ) ;
> #line 1449
14489c14879
< #line 1604
---
> #line 1450
14491c14881
< #line 1605
---
> #line 1451
14493c14883
< #line 1606
---
> #line 1452
14495c14885
< #line 1609
---
> #line 1455
14497,14499c14887,14889
< #line 1614
< void drbd_ov_oos_found(struct drbd_conf *mdev , sector_t sector , int size ) ;
< #line 1615
---
> #line 1458
> void drbd_ov_out_of_sync_found(struct drbd_conf *mdev , sector_t sector , int size ) ;
> #line 1461
14501,14502c14891,14892
< #line 1617 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void ov_oos_print(struct drbd_conf *mdev ) 
---
> #line 1463 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void ov_out_of_sync_print(struct drbd_conf *mdev ) 
14507c14897
< #line 1619
---
> #line 1465
14509c14899
< #line 1620
---
> #line 1466
14515c14905
< #line 1624
---
> #line 1470
14517c14907
< #line 1625
---
> #line 1471
14521c14911
< #line 1628
---
> #line 1474
14524,14525c14914,14915
< #line 1629
< void drbd_csum_ee(struct drbd_conf *mdev , struct crypto_hash *tfm , struct drbd_epoch_entry *e ,
---
> #line 1475
> void drbd_csum_ee(struct drbd_conf *mdev , struct crypto_hash *tfm , struct drbd_peer_request *peer_req ,
14527,14559c14917,14947
< #line 1632
< int w_read_retry_remote(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1633
< int w_e_end_data_req(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1634
< int w_e_end_rsdata_req(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1635
< int w_e_end_csum_rs_req(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1636
< int w_e_end_ov_reply(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1637
< int w_e_end_ov_req(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1638
< int w_ov_finished(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1639
< int w_resync_timer(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1641
< int w_send_write_hint(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1642
< int w_send_dblock(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1643
< int w_send_barrier(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1644
< int w_send_read_req(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1645
< int w_prev_work_done(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1647
< int w_restart_disk_io(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1648
< int w_send_oos(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1649
< int w_start_resync(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 1651
---
> #line 1478
> int w_e_end_data_req(struct drbd_work *w , int cancel ) ;
> #line 1479
> int w_e_end_rsdata_req(struct drbd_work *w , int cancel ) ;
> #line 1480
> int w_e_end_csum_rs_req(struct drbd_work *w , int cancel ) ;
> #line 1481
> int w_e_end_ov_reply(struct drbd_work *w , int cancel ) ;
> #line 1482
> int w_e_end_ov_req(struct drbd_work *w , int cancel ) ;
> #line 1483
> int w_ov_finished(struct drbd_work *w , int cancel ) ;
> #line 1484
> int w_resync_timer(struct drbd_work *w , int cancel ) ;
> #line 1485
> int w_send_write_hint(struct drbd_work *w , int cancel ) ;
> #line 1486
> int w_make_resync_request(struct drbd_work *w , int cancel ) ;
> #line 1487
> int w_send_dblock(struct drbd_work *w , int cancel ) ;
> #line 1488
> int w_send_read_req(struct drbd_work *w , int cancel ) ;
> #line 1489
> int w_prev_work_done(struct drbd_work *w , int cancel ) ;
> #line 1491
> int w_restart_disk_io(struct drbd_work *w , int cancel ) ;
> #line 1492
> int w_send_out_of_sync(struct drbd_work *w , int cancel ) ;
> #line 1493
> int w_start_resync(struct drbd_work *w , int cancel ) ;
> #line 1495
14561c14949
< #line 1652
---
> #line 1496
14563c14951
< #line 1655
---
> #line 1499
14565,14573c14953,14962
< #line 1656
< int drbd_submit_ee(struct drbd_conf *mdev , struct drbd_epoch_entry *e , unsigned int const   rw ,
<                    int const   fault_type ) ;
< #line 1659
< struct drbd_epoch_entry *drbd_alloc_ee(struct drbd_conf *mdev , u64 id , sector_t sector ,
<                                        unsigned int data_size , gfp_t gfp_mask ) ;
< #line 1664
< void drbd_free_some_ee(struct drbd_conf *mdev , struct drbd_epoch_entry *e , int is_net ) ;
< #line 1679 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1500
> int drbd_submit_peer_request(struct drbd_conf *mdev , struct drbd_peer_request *peer_req ,
>                              unsigned int const   rw , int const   fault_type ) ;
> #line 1504
> struct drbd_peer_request *drbd_alloc_peer_req(struct drbd_conf *mdev , u64 id , sector_t sector ,
>                                               unsigned int data_size , gfp_t gfp_mask ) ;
> #line 1507
> void __drbd_free_peer_req(struct drbd_conf *mdev , struct drbd_peer_request *peer_req ,
>                           int is_net ) ;
> #line 1523 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
14576a14966,14968
>   mm_segment_t oldfs ;
>   struct thread_info *tmp ;
>   char *uoptval ;
14577a14970,14972
>   struct thread_info *tmp___0 ;
>   mm_segment_t __constr_expr_0 ;
>   struct thread_info *tmp___1 ;
14580c14975,14987
< #line 1683
---
> #line 1526
>   tmp = current_thread_info();
> #line 1526
>   oldfs = tmp->addr_limit;
> #line 1530
>   uoptval = optval;
> #line 1532
>   tmp___0 = current_thread_info();
> #line 1532
>   __constr_expr_0.seg = 0xffffffffffffffffUL;
> #line 1532
>   tmp___0->addr_limit = __constr_expr_0;
> #line 1533
14582,14583c14989,14990
< #line 1684
<     err = sock_setsockopt(sock, level, optname, optval, (unsigned int )optlen);
---
> #line 1534
>     err = sock_setsockopt(sock, level, optname, uoptval, (unsigned int )optlen);
14585,14586c14992,14993
< #line 1686
<     err = (*((sock->ops)->setsockopt))(sock, level, optname, optval, (unsigned int )optlen);
---
> #line 1536
>     err = (*((sock->ops)->setsockopt))(sock, level, optname, uoptval, (unsigned int )optlen);
14588c14995,14999
< #line 1688
---
> #line 1538
>   tmp___1 = current_thread_info();
> #line 1538
>   tmp___1->addr_limit = oldfs;
> #line 1539
14592c15003
< #line 1691 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1542 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
14598c15009
< #line 1693
---
> #line 1544
14600c15011
< #line 1694
---
> #line 1545
14602c15013
< #line 1696
---
> #line 1547
14606c15017
< #line 1698 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1549 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
14612c15023
< #line 1700
---
> #line 1551
14614c15025
< #line 1701
---
> #line 1552
14616c15027
< #line 1703
---
> #line 1554
14620,14624c15031,15035
< #line 1728
< void drbd_al_begin_io(struct drbd_conf *mdev , sector_t sector ) ;
< #line 1729
< void drbd_al_complete_io(struct drbd_conf *mdev , sector_t sector ) ;
< #line 1730
---
> #line 1579
> void drbd_al_begin_io(struct drbd_conf *mdev , struct drbd_interval *i ) ;
> #line 1580
> void drbd_al_complete_io(struct drbd_conf *mdev , struct drbd_interval *i ) ;
> #line 1581
14626c15037
< #line 1732
---
> #line 1583
14628c15039
< #line 1734
---
> #line 1585
14630c15041
< #line 1735
---
> #line 1586
14632c15043
< #line 1738
---
> #line 1588
14634c15045
< #line 1739
---
> #line 1589
14637c15048
< #line 1743
---
> #line 1593
14640c15051
< #line 1820 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1621 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
14646c15057
< #line 1822
---
> #line 1623
14650,14651c15061,15062
< #line 1830 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int drbd_ee_has_active_page(struct drbd_epoch_entry *e ) 
---
> #line 1632 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static int drbd_peer_req_has_active_page(struct drbd_peer_request *peer_req ) 
14658,14663c15069,15074
< #line 1832
<   page = e->pages;
< #line 1833
<   goto ldv_50847;
<   ldv_50846: 
< #line 1834
---
> #line 1634
>   page = peer_req->pages;
> #line 1635
>   goto ldv_51370;
>   ldv_51369: 
> #line 1636
14665c15076
< #line 1834
---
> #line 1636
14667c15078
< #line 1835
---
> #line 1637
14672c15083
< #line 1833
---
> #line 1635
14674,14675c15085,15086
<   ldv_50847: ;
< #line 1833
---
>   ldv_51370: ;
> #line 1635
14677c15088
< #line 1833
---
> #line 1635
14679c15090
< #line 1833
---
> #line 1635
14681c15092
< #line 1833
---
> #line 1635
14683,14684c15094,15095
< #line 1834
<       goto ldv_50846;
---
> #line 1636
>       goto ldv_51369;
14686,14687c15097,15098
< #line 1836
<       goto ldv_50848;
---
> #line 1638
>       goto ldv_51371;
14692,14693c15103,15104
<   ldv_50848: ;
< #line 1837
---
>   ldv_51371: ;
> #line 1639
14697,14698c15108,15110
< #line 1840 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void drbd_state_lock(struct drbd_conf *mdev ) 
---
> #line 1675 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void __drbd_chk_io_error____0(struct drbd_conf *mdev , enum drbd_force_detach_flags df ,
>                                               char const   *where ) 
14699a15112,15114
>   enum drbd_io_error_p ep ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
14701,14702c15116
<   wait_queue_t __wait ;
<   struct task_struct *tmp___0 ;
---
>   int tmp___0 ;
14703a15118,15119
>   union drbd_state __ns ;
>   union drbd_state __ns___0 ;
14706,14712c15122,15139
< #line 1842
<   tmp = drbd_test_and_set_flag(mdev, CLUSTER_ST_CHANGE);
< #line 1842
<   if (tmp == 0) {
< #line 1842
<     goto ldv_50852;
<   } else {
---
> #line 1681
>   rcu_read_lock();
> #line 1682
>   _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 1682
>   tmp = debug_lockdep_rcu_enabled();
> #line 1682
>   if (tmp != 0 && ! __warned) {
> #line 1682
>     tmp___0 = rcu_read_lock_held();
> #line 1682
>     if (tmp___0 == 0 && 1) {
> #line 1682
>       __warned = 1;
> #line 1682
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h",
>                              1682, "suspicious rcu_dereference_check() usage");
>     } else {
14714,14735c15141
<   }
< #line 1842
<   tmp___0 = get_current();
< #line 1842
<   __wait.flags = 0U;
< #line 1842
<   __wait.private = (void *)tmp___0;
< #line 1842
<   __wait.func = & autoremove_wake_function;
< #line 1842
<   __wait.task_list.next = & __wait.task_list;
< #line 1842
<   __wait.task_list.prev = & __wait.task_list;
<   ldv_50855: 
< #line 1842
<   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
< #line 1842
<   tmp___1 = drbd_test_and_set_flag(mdev, CLUSTER_ST_CHANGE);
< #line 1842
<   if (tmp___1 == 0) {
< #line 1842
<     goto ldv_50854;
---
>     }
14739,14777c15145,15152
< #line 1842
<   schedule();
< #line 1842
<   goto ldv_50855;
<   ldv_50854: 
< #line 1842
<   finish_wait(& mdev->misc_wait, & __wait);
<   ldv_50852: ;
< #line 1845
<   return;
< }
< }
< #line 1846 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void drbd_state_unlock(struct drbd_conf *mdev ) 
< { 
< 
< 
<   {
< #line 1848
<   drbd_clear_flag(mdev, CLUSTER_ST_CHANGE);
< #line 1849
<   __wake_up(& mdev->misc_wait, 3U, 1, 0);
< #line 1850
<   return;
< }
< }
< #line 1890 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void __drbd_chk_io_error____0(struct drbd_conf *mdev , enum drbd_force_detach_flags df ,
<                                               char const   *where ) 
< { 
<   int tmp ;
<   union drbd_state __ns ;
<   union drbd_state __ns___0 ;
< 
<   {
< #line 1894
<   switch ((mdev->ldev)->dc.on_io_error) {
<   case 0: ;
< #line 1896
---
> #line 1682
>   ep = (enum drbd_io_error_p )_________p1->on_io_error;
> #line 1683
>   rcu_read_unlock();
> #line 1684
>   switch ((unsigned int )ep) {
>   case 0U: ;
> #line 1686
14779,14783c15154,15158
< #line 1897
<     tmp = ___ratelimit(& drbd_ratelimit_state, "__drbd_chk_io_error_");
< #line 1897
<     if (tmp != 0) {
< #line 1898
---
> #line 1687
>     tmp___1 = ___ratelimit(& drbd_ratelimit_state, "__drbd_chk_io_error_");
> #line 1687
>     if (tmp___1 != 0) {
> #line 1688
14789,14795c15164,15170
< #line 1899
<     if ((int )mdev->state.ldv_40583.disk > 4) {
< #line 1900
<       __ns.i = mdev->state.i;
< #line 1900
<       __ns.ldv_40583.disk = 4U;
< #line 1900
---
> #line 1689
>     if ((int )mdev->state.ldv_50103.disk > 4) {
> #line 1690
>       __ns = drbd_read_state(mdev);
> #line 1690
>       __ns.ldv_40604.disk = 4U;
> #line 1690
14800,14801c15175,15176
< #line 1901
<     goto ldv_50885;
---
> #line 1691
>     goto ldv_51401;
14805,14809c15180,15184
<   case 2: ;
<   case 1: 
< #line 1926
<   drbd_set_flag(mdev, WAS_IO_ERROR);
< #line 1927
---
>   case 2U: ;
>   case 1U: 
> #line 1716
>   set_bit(12U, (unsigned long volatile   *)(& mdev->flags));
> #line 1717
14811,14812c15186,15187
< #line 1928
<     drbd_set_flag(mdev, WAS_READ_ERROR);
---
> #line 1718
>     set_bit(13U, (unsigned long volatile   *)(& mdev->flags));
14816c15191
< #line 1929
---
> #line 1719
14818,14819c15193,15194
< #line 1930
<     drbd_set_flag(mdev, FORCE_DETACH);
---
> #line 1720
>     set_bit(14U, (unsigned long volatile   *)(& mdev->flags));
14823,14829c15198,15204
< #line 1931
<   if ((int )mdev->state.ldv_40583.disk > 2) {
< #line 1932
<     __ns___0.i = mdev->state.i;
< #line 1932
<     __ns___0.ldv_40583.disk = 2U;
< #line 1932
---
> #line 1721
>   if ((int )mdev->state.ldv_50103.disk > 2) {
> #line 1722
>     __ns___0 = drbd_read_state(mdev);
> #line 1722
>     __ns___0.ldv_40604.disk = 2U;
> #line 1722
14831c15206
< #line 1933
---
> #line 1723
14837,14838c15212,15213
< #line 1936
<   goto ldv_50885;
---
> #line 1726
>   goto ldv_51401;
14840,14841c15215,15216
<   ldv_50885: ;
< #line 1939
---
>   ldv_51401: ;
> #line 1729
14845c15220
< #line 1997 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1804 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
14852c15227
< #line 2000
---
> #line 1807
14854c15229
< #line 2000
---
> #line 1807
14856c15231
< #line 2000
---
> #line 1807
14859c15234
< #line 2000
---
> #line 1807
14862c15237
< #line 2000
---
> #line 1807
14866c15241
< #line 2079 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1897 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
14873c15248
< #line 2082
---
> #line 1900
14875c15250
< #line 2082
---
> #line 1900
14877c15252
< #line 2083
---
> #line 1901
14879,14881c15254
< #line 2084
<   up(& q->s);
< #line 2086
---
> #line 1902
14883c15256,15258
< #line 2087
---
> #line 1903
>   __wake_up(& q->q_wait, 3U, 1, 0);
> #line 1904
14887,14888c15262,15263
< #line 2089 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void wake_asender(struct drbd_conf *mdev ) 
---
> #line 1906 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void wake_asender(struct drbd_tconn *tconn ) 
14893,14895c15268,15270
< #line 2091
<   tmp = drbd_test_flag(mdev, SIGNAL_ASENDER);
< #line 2091
---
> #line 1908
>   tmp = constant_test_bit(3U, (unsigned long const volatile   *)(& tconn->flags));
> #line 1908
14897,14898c15272,15273
< #line 2092
<     force_sig(24, mdev->asender.task);
---
> #line 1909
>     force_sig(24, tconn->asender.task);
14902c15277
< #line 2093
---
> #line 1910
14906,14907c15281,15282
< #line 2095 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void request_ping(struct drbd_conf *mdev ) 
---
> #line 1912 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void request_ping(struct drbd_tconn *tconn ) 
14912,14916c15287,15291
< #line 2097
<   drbd_set_flag(mdev, SEND_PING);
< #line 2098
<   wake_asender(mdev);
< #line 2099
---
> #line 1914
>   set_bit(2U, (unsigned long volatile   *)(& tconn->flags));
> #line 1915
>   wake_asender(tconn);
> #line 1916
14920,14921c15295,15306
< #line 2101 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int drbd_send_short_cmd(struct drbd_conf *mdev , enum drbd_packets cmd ) 
---
> #line 1918
> void *conn_prepare_command(struct drbd_tconn *tconn , struct drbd_socket *sock ) ;
> #line 1919
> void *drbd_prepare_command(struct drbd_conf *mdev , struct drbd_socket *sock ) ;
> #line 1920
> int conn_send_command(struct drbd_tconn *tconn , struct drbd_socket *sock , enum drbd_packet cmd ,
>                       unsigned int header_size , void *data , unsigned int size ) ;
> #line 1923
> int drbd_send_command(struct drbd_conf *mdev , struct drbd_socket *sock , enum drbd_packet cmd ,
>                       unsigned int header_size , void *data , unsigned int size ) ;
> #line 1994 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void inc_rs_pending(struct drbd_conf *mdev ) 
14923,14924c15308
<   struct p_header80 h ;
<   int tmp ;
---
> 
14927,14930c15311,15314
< #line 2105
<   tmp = drbd_send_cmd(mdev, 1, cmd, & h, 8UL);
< #line 2105
<   return (tmp);
---
> #line 1996
>   atomic_inc(& mdev->rs_pending_cnt);
> #line 1997
>   return;
14933,14934c15317,15319
< #line 2120 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void drbd_thread_stop(struct drbd_thread *thi ) 
---
> #line 2000 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void _dec_rs_pending(struct drbd_conf *mdev , char const   *func ,
>                                      int line ) 
14936c15321,15322
< 
---
>   int tmp ;
>   int tmp___0 ;
14939,14941c15325,15339
< #line 2122
<   _drbd_thread_stop(thi, 0, 1);
< #line 2123
---
> #line 2002
>   atomic_dec(& mdev->rs_pending_cnt);
> #line 2003
>   tmp___0 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
> #line 2003
>   if (tmp___0 < 0) {
> #line 2003
>     tmp = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
> #line 2003
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
>             func, line, tmp);
>   } else {
> 
>   }
> #line 2004
14945,14946c15343,15344
< #line 2180 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void inc_rs_pending(struct drbd_conf *mdev ) 
---
> #line 2021 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void _dec_unacked(struct drbd_conf *mdev , char const   *func , int line ) 
14948c15346,15347
< 
---
>   int tmp ;
>   int tmp___0 ;
14951,14953c15350,15364
< #line 2182
<   atomic_inc(& mdev->rs_pending_cnt);
< #line 2183
---
> #line 2023
>   atomic_dec(& mdev->unacked_cnt);
> #line 2024
>   tmp___0 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
> #line 2024
>   if (tmp___0 < 0) {
> #line 2024
>     tmp = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
> #line 2024
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
>             func, line, tmp);
>   } else {
> 
>   }
> #line 2025
14957c15368
< #line 22 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_wrappers.h"
---
> #line 23 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_wrappers.h"
14959,14960d15369
< #line 23
< void drbd_endio_sec(struct bio *bio , int error ) ;
14962,14963c15371,15374
< void drbd_endio_pri(struct bio *bio , int error ) ;
< #line 273 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
---
> void drbd_peer_request_endio(struct bio *bio , int error ) ;
> #line 25
> void drbd_request_endio(struct bio *bio , int error ) ;
> #line 250 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
14969c15380
< #line 276
---
> #line 253
14971c15382
< #line 278
---
> #line 255
14973c15384
< #line 280
---
> #line 257
14975,14977c15386,15388
< #line 281
<   bio->bi_end_io = & drbd_endio_pri;
< #line 282
---
> #line 258
>   bio->bi_end_io = & drbd_request_endio;
> #line 259
14979c15390
< #line 283
---
> #line 260
14983c15394
< #line 326
---
> #line 273
14985c15396
< #line 328
---
> #line 275
14987,15010c15398
< #line 335 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< __inline static int _req_mod(struct drbd_request *req , enum drbd_req_event what ) 
< { 
<   struct drbd_conf *mdev ;
<   struct bio_and_error m ;
<   int rv ;
< 
<   {
< #line 337
<   mdev = req->mdev;
< #line 342
<   rv = __req_mod(req, what, & m);
< #line 343
<   if ((unsigned long )m.bio != (unsigned long )((struct bio *)0)) {
< #line 344
<     complete_master_bio(mdev, & m);
<   } else {
< 
<   }
< #line 346
<   return (rv);
< }
< }
< #line 353 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
---
> #line 304 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
15020,15024c15408,15412
< #line 357
<   mdev = req->mdev;
< #line 361
<   tmp = spinlock_check(& mdev->req_lock);
< #line 361
---
> #line 308
>   mdev = req->w.ldv_50388.mdev;
> #line 312
>   tmp = spinlock_check(& (mdev->tconn)->req_lock);
> #line 312
15026c15414
< #line 362
---
> #line 313
15028,15030c15416,15418
< #line 363
<   spin_unlock_irqrestore(& mdev->req_lock, flags);
< #line 365
---
> #line 314
>   spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
> #line 316
15032c15420
< #line 366
---
> #line 317
15037c15425
< #line 368
---
> #line 319
15041,15045c15429,15431
< #line 48 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< static int w_make_ov_request(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 49
< static int w_make_resync_request(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 77 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 48 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> static int w_make_ov_request(struct drbd_work *w , int cancel ) ;
> #line 74 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
15053c15439
< #line 82
---
> #line 79
15055c15441
< #line 83
---
> #line 80
15057,15059c15443,15445
< #line 83
<   mdev = (struct drbd_conf *)__mptr + 0xfffffffffffff060UL;
< #line 85
---
> #line 80
>   mdev = (struct drbd_conf *)__mptr + 0xfffffffffffffa38UL;
> #line 82
15061c15447
< #line 98
---
> #line 95
15063c15449
< #line 99
---
> #line 96
15065c15451
< #line 100
---
> #line 97
15067c15453
< #line 101
---
> #line 98
15069c15455
< #line 102
---
> #line 99
15071c15457
< #line 103
---
> #line 100
15075,15076c15461,15462
< #line 108 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< void drbd_endio_read_sec_final(struct drbd_epoch_entry *e ) 
---
> #line 105 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> void drbd_endio_read_sec_final(struct drbd_peer_request *peer_req ) 
15085c15471
< #line 110
---
> #line 107
15086a15473,15478
> #line 108
>   mdev = peer_req->w.ldv_50388.mdev;
> #line 110
>   tmp = spinlock_check(& (mdev->tconn)->req_lock);
> #line 110
>   flags = _raw_spin_lock_irqsave(tmp);
15088,15090c15480,15482
<   mdev = e->mdev;
< #line 113
<   if (e->ldv_49794.block_id == 0ULL) {
---
>   mdev->read_cnt = mdev->read_cnt + (peer_req->i.size >> 9);
> #line 112
>   list_del(& peer_req->w.list);
15092,15106d15483
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( e->block_id != ID_VACANT ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<             113);
<   } else {
< 
<   }
< #line 115
<   tmp = spinlock_check(& mdev->req_lock);
< #line 115
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 116
<   mdev->read_cnt = mdev->read_cnt + (e->size >> 9);
< #line 117
<   list_del(& e->w.list);
< #line 118
15108c15485
< #line 118
---
> #line 113
15110c15487
< #line 119
---
> #line 114
15115,15117c15492,15494
< #line 120
<   tmp___1 = constant_test_bit(3U, (unsigned long const volatile   *)(& e->flags));
< #line 120
---
> #line 115
>   tmp___1 = constant_test_bit(3U, (unsigned long const volatile   *)(& peer_req->flags));
> #line 115
15119c15496
< #line 121
---
> #line 116
15124,15128c15501,15505
< #line 122
<   spin_unlock_irqrestore(& mdev->req_lock, flags);
< #line 124
<   drbd_queue_work(& mdev->data.work, & e->w);
< #line 125
---
> #line 117
>   spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
> #line 119
>   drbd_queue_work(& (mdev->tconn)->sender_work, & peer_req->w);
> #line 120
15130c15507
< #line 126
---
> #line 121
15134,15135c15511,15512
< #line 130 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< static void drbd_endio_write_sec_final(struct drbd_epoch_entry *e ) 
---
> #line 125 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> static void drbd_endio_write_sec_final(struct drbd_peer_request *peer_req ) 
15139c15516
<   sector_t e_sector ;
---
>   struct drbd_interval i ;
15141c15518
<   int is_syncer_req ;
---
>   u64 block_id ;
15145,15146d15521
<   int tmp___1 ;
<   int tmp___2 ;
15149c15524
< #line 132
---
> #line 127
15151,15154c15526,15529
< #line 133
<   mdev = e->mdev;
< #line 139
<   if (e->ldv_49794.block_id == 0ULL) {
---
> #line 128
>   mdev = peer_req->w.ldv_50388.mdev;
> #line 138
>   i = peer_req->i;
15156,15170c15531,15536
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( e->block_id != ID_VACANT ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<             139);
<   } else {
< 
<   }
< #line 145
<   e_sector = e->sector;
< #line 146
<   do_al_complete_io = (int )e->flags & 1;
< #line 147
<   is_syncer_req = e->ldv_49794.block_id == 0xffffffffffffffffULL;
< #line 149
<   tmp = spinlock_check(& mdev->req_lock);
< #line 149
---
>   do_al_complete_io = (int )peer_req->flags & 1;
> #line 140
>   block_id = peer_req->ldv_50490.block_id;
> #line 142
>   tmp = spinlock_check(& (mdev->tconn)->req_lock);
> #line 142
15172,15194c15538,15548
< #line 150
<   mdev->writ_cnt = mdev->writ_cnt + (e->size >> 9);
< #line 151
<   list_del(& e->w.list);
< #line 152
<   list_add_tail(& e->w.list, & mdev->done_ee);
< #line 159
<   if (is_syncer_req != 0) {
< #line 159
<     tmp___0 = list_empty((struct list_head  const  *)(& mdev->sync_ee));
< #line 159
<     do_wake = tmp___0;
<   } else {
< #line 159
<     tmp___1 = list_empty((struct list_head  const  *)(& mdev->active_ee));
< #line 159
<     do_wake = tmp___1;
<   }
< #line 163
<   tmp___2 = constant_test_bit(3U, (unsigned long const volatile   *)(& e->flags));
< #line 163
<   if (tmp___2 != 0) {
< #line 164
---
> #line 143
>   mdev->writ_cnt = mdev->writ_cnt + (peer_req->i.size >> 9);
> #line 144
>   list_move_tail(& peer_req->w.list, & mdev->done_ee);
> #line 154
>   do_wake = list_empty((struct list_head  const  *)(block_id == 0xffffffffffffffffULL ? & mdev->sync_ee : & mdev->active_ee));
> #line 156
>   tmp___0 = constant_test_bit(3U, (unsigned long const volatile   *)(& peer_req->flags));
> #line 156
>   if (tmp___0 != 0) {
> #line 157
15199,15204c15553,15558
< #line 165
<   spin_unlock_irqrestore(& mdev->req_lock, flags);
< #line 167
<   if (is_syncer_req != 0) {
< #line 168
<     drbd_rs_complete_io(mdev, e_sector);
---
> #line 158
>   spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
> #line 160
>   if (block_id == 0xffffffffffffffffULL) {
> #line 161
>     drbd_rs_complete_io(mdev, i.sector);
15208c15562
< #line 170
---
> #line 163
15210c15564
< #line 171
---
> #line 164
15215c15569
< #line 173
---
> #line 166
15217,15218c15571,15572
< #line 174
<     drbd_al_complete_io(mdev, e_sector);
---
> #line 167
>     drbd_al_complete_io(mdev, & i);
15222,15224c15576,15578
< #line 176
<   wake_asender(mdev);
< #line 177
---
> #line 169
>   wake_asender(mdev->tconn);
> #line 170
15226c15580
< #line 178
---
> #line 171
15230,15231c15584,15585
< #line 183 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< void drbd_endio_sec(struct bio *bio , int error ) 
---
> #line 176 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> void drbd_peer_request_endio(struct bio *bio , int error ) 
15233c15587
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
15242,15246c15596,15600
< #line 185
<   e = (struct drbd_epoch_entry *)bio->bi_private;
< #line 186
<   mdev = e->mdev;
< #line 187
---
> #line 178
>   peer_req = (struct drbd_peer_request *)bio->bi_private;
> #line 179
>   mdev = peer_req->w.ldv_50388.mdev;
> #line 180
15248c15602
< #line 188
---
> #line 181
15250c15604
< #line 190
---
> #line 183
15252,15254c15606,15608
< #line 190
<     tmp = ___ratelimit(& drbd_ratelimit_state, "drbd_endio_sec");
< #line 190
---
> #line 183
>     tmp = ___ratelimit(& drbd_ratelimit_state, "drbd_peer_request_endio");
> #line 183
15256c15610
< #line 191
---
> #line 184
15258c15612
<                is_write != 0 ? (char *)"write" : (char *)"read", error, (unsigned long long )e->sector);
---
>                is_write != 0 ? (char *)"write" : (char *)"read", error, (unsigned long long )peer_req->i.sector);
15265c15619
< #line 194
---
> #line 187
15267,15269c15621,15623
< #line 195
<     tmp___0 = ___ratelimit(& drbd_ratelimit_state, "drbd_endio_sec");
< #line 195
---
> #line 188
>     tmp___0 = ___ratelimit(& drbd_ratelimit_state, "drbd_peer_request_endio");
> #line 188
15271c15625
< #line 196
---
> #line 189
15273c15627
<                is_write != 0 ? (char *)"write" : (char *)"read", (unsigned long long )e->sector);
---
>                is_write != 0 ? (char *)"write" : (char *)"read", (unsigned long long )peer_req->i.sector);
15277c15631
< #line 202
---
> #line 195
15282c15636
< #line 205
---
> #line 198
15284,15285c15638,15639
< #line 206
<     set_bit(3U, (unsigned long volatile   *)(& e->flags));
---
> #line 199
>     set_bit(3U, (unsigned long volatile   *)(& peer_req->flags));
15289c15643
< #line 208
---
> #line 201
15291,15293c15645,15647
< #line 209
<   tmp___1 = atomic_dec_and_test(& e->pending_bios);
< #line 209
---
> #line 202
>   tmp___1 = atomic_dec_and_test(& peer_req->pending_bios);
> #line 202
15295c15649
< #line 210
---
> #line 203
15297,15298c15651,15652
< #line 211
<       drbd_endio_write_sec_final(e);
---
> #line 204
>       drbd_endio_write_sec_final(peer_req);
15300,15301c15654,15655
< #line 213
<       drbd_endio_read_sec_final(e);
---
> #line 206
>       drbd_endio_read_sec_final(peer_req);
15306c15660
< #line 214
---
> #line 207
15310,15311c15664,15665
< #line 219 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< void drbd_endio_pri(struct bio *bio , int error ) 
---
> #line 212 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> void drbd_request_endio(struct bio *bio , int error ) 
15326c15680
< #line 222
---
> #line 215
15328,15330c15682,15684
< #line 223
<   mdev = req->mdev;
< #line 226
---
> #line 216
>   mdev = req->w.ldv_50388.mdev;
> #line 219
15332c15686
< #line 228
---
> #line 221
15334c15688
< #line 229
---
> #line 222
15337c15691
< #line 234
---
> #line 227
15342,15344c15696,15698
< #line 265
<   tmp___0 = __builtin_expect((req->rq_state & 8UL) != 0UL, 0L);
< #line 265
---
> #line 259
>   tmp___0 = __builtin_expect(((unsigned long )req->rq_state & 8UL) != 0UL, 0L);
> #line 259
15346,15348c15700,15702
< #line 266
<     tmp = ___ratelimit(& drbd_ratelimit_state, "drbd_endio_pri");
< #line 266
---
> #line 260
>     tmp = ___ratelimit(& drbd_ratelimit_state, "drbd_request_endio");
> #line 260
15350c15704
< #line 267
---
> #line 261
15355c15709
< #line 269
---
> #line 263
15357c15711
< #line 270
---
> #line 264
15365c15719
< #line 274
---
> #line 268
15367c15721
< #line 274
---
> #line 268
15369,15370c15723,15724
< #line 275
<     what = (int )bio->bi_rw & 1 ? write_completed_with_error : ((bio->bi_rw & 8193UL) == 0UL ? read_completed_with_error : read_ahead_completed_with_error);
---
> #line 269
>     what = (int )bio->bi_rw & 1 ? WRITE_COMPLETED_WITH_ERROR : ((bio->bi_rw & 8193UL) == 0UL ? READ_COMPLETED_WITH_ERROR : READ_AHEAD_COMPLETED_WITH_ERROR);
15372,15373c15726,15727
< #line 281
<     what = completed_ok;
---
> #line 275
>     what = COMPLETED_OK;
15375c15729
< #line 283
---
> #line 277
15377c15731
< #line 284
---
> #line 278
15379c15733
< #line 284
---
> #line 278
15381,15383c15735,15737
< #line 287
<   tmp___3 = spinlock_check(& mdev->req_lock);
< #line 287
---
> #line 281
>   tmp___3 = spinlock_check(& (mdev->tconn)->req_lock);
> #line 281
15385c15739
< #line 288
---
> #line 282
15387,15389c15741,15743
< #line 289
<   spin_unlock_irqrestore(& mdev->req_lock, flags);
< #line 290
---
> #line 283
>   spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
> #line 284
15391c15745
< #line 292
---
> #line 286
15393c15747
< #line 293
---
> #line 287
15398c15752
< #line 294
---
> #line 288
15402,15436c15756,15757
< #line 296 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_read_retry_remote(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
< { 
<   struct drbd_request *req ;
<   struct drbd_work  const  *__mptr ;
<   int tmp ;
< 
<   {
< #line 298
<   __mptr = (struct drbd_work  const  *)w;
< #line 298
<   req = (struct drbd_request *)__mptr;
< #line 304
<   spin_lock_irq(& mdev->req_lock);
< #line 305
<   if (cancel != 0 || *((unsigned int *)mdev + 569UL) != 65536U) {
< #line 306
<     _req_mod(req, read_retry_remote_canceled);
< #line 307
<     spin_unlock_irq(& mdev->req_lock);
< #line 308
<     return (1);
<   } else {
< 
<   }
< #line 310
<   spin_unlock_irq(& mdev->req_lock);
< #line 312
<   tmp = w_send_read_req(mdev, w, 0);
< #line 312
<   return (tmp);
< }
< }
< #line 315 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< void drbd_csum_ee(struct drbd_conf *mdev , struct crypto_hash *tfm , struct drbd_epoch_entry *e ,
---
> #line 290 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> void drbd_csum_ee(struct drbd_conf *mdev , struct crypto_hash *tfm , struct drbd_peer_request *peer_req ,
15446,15448c15767,15769
< #line 319
<   page = e->pages;
< #line 323
---
> #line 295
>   page = peer_req->pages;
> #line 299
15450c15771
< #line 324
---
> #line 300
15452c15773
< #line 326
---
> #line 302
15454c15775
< #line 327
---
> #line 303
15456,15459c15777,15780
< #line 329
<   goto ldv_51369;
<   ldv_51368: 
< #line 331
---
> #line 305
>   goto ldv_51886;
>   ldv_51885: 
> #line 307
15461c15782
< #line 332
---
> #line 308
15463c15784
< #line 333
---
> #line 309
15465,15466c15786,15787
<   ldv_51369: 
< #line 329
---
>   ldv_51886: 
> #line 305
15468c15789
< #line 329
---
> #line 305
15470,15471c15791,15792
< #line 330
<     goto ldv_51368;
---
> #line 306
>     goto ldv_51885;
15475,15477c15796,15798
< #line 336
<   len = e->size & 4095U;
< #line 337
---
> #line 312
>   len = peer_req->i.size & 4095U;
> #line 313
15479c15800
< #line 338
---
> #line 314
15481c15802
< #line 339
---
> #line 315
15483c15804
< #line 340
---
> #line 316
15487c15808
< #line 342 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 318 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
15497c15818
< #line 349
---
> #line 325
15499c15820
< #line 350
---
> #line 326
15501c15822
< #line 352
---
> #line 328
15503c15824
< #line 353
---
> #line 329
15505c15826
< #line 355
---
> #line 331
15507c15828
< #line 355
---
> #line 331
15509,15512c15830,15833
< #line 355
<   goto ldv_51382;
<   ldv_51381: 
< #line 356
---
> #line 331
>   goto ldv_51899;
>   ldv_51898: 
> #line 332
15514c15835
< #line 357
---
> #line 333
15516c15837
< #line 355
---
> #line 331
15518c15839
< #line 355
---
> #line 331
15520,15521c15841,15842
<   ldv_51382: ;
< #line 355
---
>   ldv_51899: ;
> #line 331
15523,15524c15844,15845
< #line 356
<     goto ldv_51381;
---
> #line 332
>     goto ldv_51898;
15528c15849
< #line 359
---
> #line 335
15530c15851
< #line 360
---
> #line 336
15534,15535c15855,15856
< #line 363 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_e_send_csum(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 339 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> static int w_e_send_csum(struct drbd_work *w , int cancel ) 
15537c15858
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
15538a15860
>   struct drbd_conf *mdev ;
15541c15863
<   int ok ;
---
>   int err ;
15550c15872
< #line 365
---
> #line 341
15552,15565c15874,15880
< #line 365
<   e = (struct drbd_epoch_entry *)__mptr;
< #line 368
<   ok = 1;
< #line 370
<   if (e->ldv_49794.block_id != 2205466966ULL) {
< #line 370
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( e->block_id == DRBD_MAGIC + 0xbeef ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<             370);
<   } else {
< 
<   }
< #line 372
---
> #line 341
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 342
>   mdev = w->ldv_50388.mdev;
> #line 345
>   err = 0;
> #line 347
15567c15882
< #line 372
---
> #line 347
15569c15884
< #line 373
---
> #line 348
15574,15576c15889,15891
< #line 375
<   tmp___0 = __builtin_expect((e->flags & 8UL) != 0UL, 1L);
< #line 375
---
> #line 350
>   tmp___0 = __builtin_expect((peer_req->flags & 8UL) != 0UL, 0L);
> #line 350
15578c15893
< #line 376
---
> #line 351
15583,15585c15898,15900
< #line 378
<   tmp___1 = crypto_hash_digestsize(mdev->csums_tfm);
< #line 378
---
> #line 353
>   tmp___1 = crypto_hash_digestsize((mdev->tconn)->csums_tfm);
> #line 353
15587c15902
< #line 379
---
> #line 354
15589c15904
< #line 380
---
> #line 355
15591,15601c15906,15916
< #line 381
<     sector = e->sector;
< #line 382
<     size = e->size;
< #line 383
<     drbd_csum_ee(mdev, mdev->csums_tfm, e, digest);
< #line 389
<     drbd_free_some_ee(mdev, e, 0);
< #line 390
<     e = 0;
< #line 391
---
> #line 356
>     sector = peer_req->i.sector;
> #line 357
>     size = peer_req->i.size;
> #line 358
>     drbd_csum_ee(mdev, (mdev->tconn)->csums_tfm, peer_req, digest);
> #line 364
>     __drbd_free_peer_req(mdev, peer_req, 0);
> #line 365
>     peer_req = 0;
> #line 366
15603,15605c15918,15920
< #line 392
<     ok = drbd_send_drequest_csum(mdev, sector, (int )size, digest, digest_size, P_CSUM_RS_REQUEST);
< #line 395
---
> #line 367
>     err = drbd_send_drequest_csum(mdev, sector, (int )size, digest, digest_size, P_CSUM_RS_REQUEST);
> #line 370
15608c15923
< #line 397
---
> #line 372
15610,15611c15925,15926
< #line 398
<     ok = 0;
---
> #line 373
>     err = -12;
15614,15617c15929,15932
< #line 402
<   if ((unsigned long )e != (unsigned long )((struct drbd_epoch_entry *)0)) {
< #line 403
<     drbd_free_some_ee(mdev, e, 0);
---
> #line 377
>   if ((unsigned long )peer_req != (unsigned long )((struct drbd_peer_request *)0)) {
> #line 378
>     __drbd_free_peer_req(mdev, peer_req, 0);
15621,15623c15936,15938
< #line 405
<   tmp___2 = __builtin_expect(ok == 0, 0L);
< #line 405
---
> #line 380
>   tmp___2 = __builtin_expect(err != 0, 0L);
> #line 380
15625c15940
< #line 406
---
> #line 381
15630,15631c15945,15946
< #line 407
<   return (ok);
---
> #line 382
>   return (err);
15634c15949
< #line 412 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 387 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
15637c15952
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
15643c15958
< #line 416
---
> #line 391
15645c15960
< #line 416
---
> #line 391
15647c15962
< #line 417
---
> #line 392
15652c15967
< #line 419
---
> #line 394
15654c15969
< #line 419
---
> #line 394
15656c15971
< #line 420
---
> #line 395
15661,15665c15976,15981
< #line 424
<   e = drbd_alloc_ee(mdev, 2205466966ULL, sector, (unsigned int )size, 514U);
< #line 425
<   if ((unsigned long )e == (unsigned long )((struct drbd_epoch_entry *)0)) {
< #line 426
---
> #line 399
>   peer_req = drbd_alloc_peer_req(mdev, 0xffffffffffffffffULL, sector, (unsigned int )size,
>                                  514U);
> #line 401
>   if ((unsigned long )peer_req == (unsigned long )((struct drbd_peer_request *)0)) {
> #line 402
15670,15678c15986,15994
< #line 428
<   e->w.cb = & w_e_send_csum;
< #line 429
<   spin_lock_irq(& mdev->req_lock);
< #line 430
<   list_add(& e->w.list, & mdev->read_ee);
< #line 431
<   spin_unlock_irq(& mdev->req_lock);
< #line 433
---
> #line 404
>   peer_req->w.cb = & w_e_send_csum;
> #line 405
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 406
>   list_add(& peer_req->w.list, & mdev->read_ee);
> #line 407
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 409
15680,15682c15996,15998
< #line 434
<   tmp___1 = drbd_submit_ee(mdev, e, 0U, 3);
< #line 434
---
> #line 410
>   tmp___1 = drbd_submit_peer_request(mdev, peer_req, 0U, 3);
> #line 410
15684c16000
< #line 435
---
> #line 411
15689,15696c16005,16012
< #line 441
<   spin_lock_irq(& mdev->req_lock);
< #line 442
<   list_del(& e->w.list);
< #line 443
<   spin_unlock_irq(& mdev->req_lock);
< #line 445
<   drbd_free_some_ee(mdev, e, 0);
---
> #line 417
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 418
>   list_del(& peer_req->w.list);
> #line 419
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 421
>   __drbd_free_peer_req(mdev, peer_req, 0);
15698c16014
< #line 447
---
> #line 423
15700c16016
< #line 448
---
> #line 424
15704,15705c16020,16021
< #line 451 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_resync_timer(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 427 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_resync_timer(struct drbd_work *w , int cancel ) 
15707c16023
< 
---
>   struct drbd_conf *mdev ;
15710,15711c16026,16029
< #line 453
<   switch ((int )mdev->state.ldv_40583.conn) {
---
> #line 429
>   mdev = w->ldv_50388.mdev;
> #line 430
>   switch ((int )mdev->state.ldv_50103.conn) {
15713,15716c16031,16034
< #line 455
<   w_make_ov_request(mdev, w, cancel);
< #line 456
<   goto ldv_51411;
---
> #line 432
>   w_make_ov_request(w, cancel);
> #line 433
>   goto ldv_51928;
15718,15721c16036,16039
< #line 458
<   w_make_resync_request(mdev, w, cancel);
< #line 459
<   goto ldv_51411;
---
> #line 435
>   w_make_resync_request(w, cancel);
> #line 436
>   goto ldv_51928;
15723,15725c16041,16043
<   ldv_51411: ;
< #line 462
<   return (1);
---
>   ldv_51928: ;
> #line 439
>   return (0);
15728c16046
< #line 465 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 442 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
15735c16053
< #line 467
---
> #line 444
15737c16055
< #line 469
---
> #line 446
15739c16057
< #line 469
---
> #line 446
15741,15742c16059,16060
< #line 470
<     drbd_queue_work(& mdev->data.work, & mdev->resync_work);
---
> #line 447
>     drbd_queue_work(& (mdev->tconn)->sender_work, & mdev->resync_work);
15746c16064
< #line 471
---
> #line 448
15750c16068
< #line 473 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 450 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
15756c16074
< #line 477
---
> #line 454
15758,15763c16076,16081
< #line 477
<   goto ldv_51423;
<   ldv_51422: 
< #line 478
<   *(fb->values + (unsigned long )i) = value;
< #line 477
---
> #line 454
>   goto ldv_51940;
>   ldv_51939: 
> #line 455
>   fb->values[i] = value;
> #line 454
15765,15766c16083,16084
<   ldv_51423: ;
< #line 477
---
>   ldv_51940: ;
> #line 454
15768,15769c16086,16087
< #line 478
<     goto ldv_51422;
---
> #line 455
>     goto ldv_51939;
15774c16092
< #line 482
---
> #line 459
15778c16096
< #line 481 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 458 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
15785,15787c16103,16105
< #line 485
<   ov = *(fb->values + (unsigned long )fb->head_index);
< #line 486
---
> #line 462
>   ov = fb->values[fb->head_index];
> #line 463
15789c16107
< #line 486
---
> #line 463
15791,15793c16109,16111
< #line 486
<   *(fb->values + (unsigned long )tmp) = value;
< #line 488
---
> #line 463
>   fb->values[tmp] = value;
> #line 465
15795c16113
< #line 489
---
> #line 466
15800c16118
< #line 491
---
> #line 468
15804c16122
< #line 494 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 471 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
15810c16128
< #line 498
---
> #line 475
15812,15817c16130,16135
< #line 498
<   goto ldv_51436;
<   ldv_51435: 
< #line 499
<   *(fb->values + (unsigned long )i) = *(fb->values + (unsigned long )i) + value;
< #line 498
---
> #line 475
>   goto ldv_51953;
>   ldv_51952: 
> #line 476
>   fb->values[i] = fb->values[i] + value;
> #line 475
15819,15820c16137,16138
<   ldv_51436: ;
< #line 498
---
>   ldv_51953: ;
> #line 475
15822,15823c16140,16141
< #line 499
<     goto ldv_51435;
---
> #line 476
>     goto ldv_51952;
15828c16146
< #line 503
---
> #line 480
15832c16150,16178
< #line 502 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 479 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> struct fifo_buffer *fifo_alloc(int fifo_size ) 
> { 
>   struct fifo_buffer *fb ;
>   void *tmp ;
> 
>   {
> #line 483
>   tmp = kzalloc(((unsigned long )fifo_size + 3UL) * 4UL, 16U);
> #line 483
>   fb = (struct fifo_buffer *)tmp;
> #line 484
>   if ((unsigned long )fb == (unsigned long )((struct fifo_buffer *)0)) {
> #line 485
>     return (0);
>   } else {
> 
>   }
> #line 487
>   fb->head_index = 0U;
> #line 488
>   fb->size = (unsigned int )fifo_size;
> #line 489
>   fb->total = 0;
> #line 491
>   return (fb);
> }
> }
> #line 494 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
15834a16181
>   struct disk_conf *dc ;
15842a16190
>   struct fifo_buffer *plan ;
15843a16192,16199
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___0 ;
>   int tmp___1 ;
>   struct fifo_buffer *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___2 ;
>   int tmp___3 ;
15846c16202
< #line 513
---
> #line 507
15848c16204
< #line 513
---
> #line 507
15850c16206
< #line 514
---
> #line 508
15852,15856c16208,16256
< #line 516
<   spin_lock(& mdev->peer_seq_lock);
< #line 518
<   steps = (int )mdev->rs_plan_s.size;
< #line 520
---
> #line 510
>   _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 510
>   tmp___0 = debug_lockdep_rcu_enabled();
> #line 510
>   if (tmp___0 != 0 && ! __warned) {
> #line 510
>     tmp___1 = rcu_read_lock_held();
> #line 510
>     if (tmp___1 == 0 && 1) {
> #line 510
>       __warned = 1;
> #line 510
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                              510, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 510
>   dc = _________p1;
> #line 511
>   _________p1___0 = *((struct fifo_buffer * volatile  *)(& mdev->rs_plan_s));
> #line 511
>   tmp___2 = debug_lockdep_rcu_enabled();
> #line 511
>   if (tmp___2 != 0 && ! __warned___0) {
> #line 511
>     tmp___3 = rcu_read_lock_held();
> #line 511
>     if (tmp___3 == 0 && 1) {
> #line 511
>       __warned___0 = 1;
> #line 511
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                              511, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 511
>   plan = _________p1___0;
> #line 513
>   steps = (int )plan->size;
> #line 515
15858,15859c16258,16259
< #line 521
<     want = (unsigned int )(((mdev->sync_conf.rate * 50) / 250) * steps);
---
> #line 516
>     want = ((dc->resync_rate * 50U) / 250U) * (__u32 )steps;
15861,15862c16261,16262
< #line 523
<     want = mdev->sync_conf.c_fill_target != 0 ? (unsigned int )mdev->sync_conf.c_fill_target : (((unsigned int )mdev->sync_conf.c_delay_target * sect_in) * 250U) / 250U;
---
> #line 518
>     want = dc->c_fill_target != 0U ? dc->c_fill_target : ((dc->c_delay_target * sect_in) * 250U) / 250U;
15863a16264,16269
> #line 522
>   correction = (int )((want - (unsigned int )mdev->rs_in_flight) - (unsigned int )plan->total);
> #line 525
>   cps = correction / steps;
> #line 526
>   fifo_add_val(plan, cps);
15865c16271
<   correction = (int )((want - (unsigned int )mdev->rs_in_flight) - (unsigned int )mdev->rs_planed);
---
>   plan->total = plan->total + cps * steps;
15867c16273
<   cps = correction / steps;
---
>   curr_corr = fifo_push(plan, 0);
15869,15878c16275,16276
<   fifo_add_val(& mdev->rs_plan_s, cps);
< #line 532
<   mdev->rs_planed = mdev->rs_planed + cps * steps;
< #line 535
<   curr_corr = fifo_push(& mdev->rs_plan_s, 0);
< #line 536
<   spin_unlock(& mdev->peer_seq_lock);
< #line 537
<   mdev->rs_planed = mdev->rs_planed - curr_corr;
< #line 539
---
>   plan->total = plan->total - curr_corr;
> #line 533
15880c16278
< #line 540
---
> #line 534
15882c16280
< #line 541
---
> #line 535
15887,15889c16285,16287
< #line 543
<   max_sect = (mdev->sync_conf.c_max_rate * 50) / 250;
< #line 544
---
> #line 537
>   max_sect = (int )((dc->c_max_rate * 50U) / 250U);
> #line 538
15891c16289
< #line 545
---
> #line 539
15896c16294
< #line 553
---
> #line 547
15900c16298
< #line 556 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 550 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
15904a16303,16310
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___0 ;
>   int tmp___1 ;
>   struct fifo_buffer *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___2 ;
>   int tmp___3 ;
15907,15909c16313,16338
< #line 559
<   if (mdev->rs_plan_s.size != 0U) {
< #line 560
---
> #line 554
>   rcu_read_lock();
> #line 555
>   _________p1___0 = *((struct fifo_buffer * volatile  *)(& mdev->rs_plan_s));
> #line 555
>   tmp___2 = debug_lockdep_rcu_enabled();
> #line 555
>   if (tmp___2 != 0 && ! __warned___0) {
> #line 555
>     tmp___3 = rcu_read_lock_held();
> #line 555
>     if (tmp___3 == 0 && 1) {
> #line 555
>       __warned___0 = 1;
> #line 555
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                              555, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 555
>   if (_________p1___0->size != 0U) {
> #line 556
15911c16340
< #line 560
---
> #line 556
15913c16342
< #line 561
---
> #line 557
15916,15918c16345,16368
< #line 563
<     mdev->c_sync_rate = mdev->sync_conf.rate;
< #line 564
---
> #line 559
>     _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 559
>     tmp___0 = debug_lockdep_rcu_enabled();
> #line 559
>     if (tmp___0 != 0 && ! __warned) {
> #line 559
>       tmp___1 = rcu_read_lock_held();
> #line 559
>       if (tmp___1 == 0 && 1) {
> #line 559
>         __warned = 1;
> #line 559
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                                559, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 559
>     mdev->c_sync_rate = (int )_________p1->resync_rate;
> #line 560
15921c16371,16373
< #line 569
---
> #line 562
>   rcu_read_unlock();
> #line 566
15925,15926c16377,16378
< #line 572 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< static int w_make_resync_request(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 569 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_make_resync_request(struct drbd_work *w , int cancel ) 
15927a16380
>   struct drbd_conf *mdev ;
15949,15952c16402,16403
<   int tmp___9 ;
<   int tmp___10 ;
<   int tmp___11 ;
<   unsigned long tmp___12 ;
---
>   int err ;
>   unsigned long tmp___9 ;
15955c16406,16408
< #line 577
---
> #line 571
>   mdev = w->ldv_50388.mdev;
> #line 574
15957c16410
< #line 577
---
> #line 574
15959c16412
< #line 581
---
> #line 578
15961c16414
< #line 583
---
> #line 580
15963c16416
< #line 583
---
> #line 580
15965,15966c16418,16419
< #line 584
<     return (1);
---
> #line 581
>     return (0);
15970c16423
< #line 586
---
> #line 583
15972c16425
< #line 588
---
> #line 585
15974,15975c16427,16428
< #line 589
<     return (1);
---
> #line 586
>     return (0);
15979c16432
< #line 592
---
> #line 589
15981c16434
< #line 592
---
> #line 589
15983c16436
< #line 597
---
> #line 594
15985,15986c16438,16439
< #line 598
<     return (1);
---
> #line 595
>     return (0);
15990c16443
< #line 601
---
> #line 598
15992c16445
< #line 601
---
> #line 598
15994c16447
< #line 602
---
> #line 599
15996c16449
< #line 603
---
> #line 600
15998c16451
< #line 604
---
> #line 601
16003c16456
< #line 606
---
> #line 603
16004a16458,16462
> #line 603
>   goto ldv_52017;
>   ldv_52016: 
> #line 605
>   mutex_lock_nested(& (mdev->tconn)->data.mutex, 0U);
16006,16007c16464,16466
<   goto ldv_51484;
<   ldv_51483: 
---
>   if ((unsigned long )(mdev->tconn)->data.socket != (unsigned long )((struct socket *)0)) {
> #line 607
>     queued = (((mdev->tconn)->data.socket)->sk)->sk_wmem_queued;
16009,16015c16468
<   mutex_lock_nested(& mdev->data.mutex, 0U);
< #line 609
<   if ((unsigned long )mdev->data.socket != (unsigned long )((struct socket *)0)) {
< #line 610
<     queued = ((mdev->data.socket)->sk)->sk_wmem_queued;
< #line 611
<     sndbuf = ((mdev->data.socket)->sk)->sk_sndbuf;
---
>     sndbuf = (((mdev->tconn)->data.socket)->sk)->sk_sndbuf;
16017c16470
< #line 613
---
> #line 610
16019c16472
< #line 614
---
> #line 611
16022,16024c16475,16477
< #line 616
<   mutex_unlock(& mdev->data.mutex);
< #line 617
---
> #line 613
>   mutex_unlock(& (mdev->tconn)->data.mutex);
> #line 614
16026c16479
< #line 618
---
> #line 615
16032c16485
< #line 621
---
> #line 618
16034c16487
< #line 622
---
> #line 619
16036c16489
< #line 624
---
> #line 621
16038c16491
< #line 625
---
> #line 622
16040c16493
< #line 626
---
> #line 623
16042,16043c16495,16496
< #line 627
<     return (1);
---
> #line 624
>     return (0);
16047c16500
< #line 630
---
> #line 627
16049c16502
< #line 632
---
> #line 629
16051c16504
< #line 632
---
> #line 629
16053c16506
< #line 634
---
> #line 631
16055c16508
< #line 635
---
> #line 632
16058c16511
< #line 632
---
> #line 629
16060c16513
< #line 632
---
> #line 629
16062c16515
< #line 634
---
> #line 631
16064c16517
< #line 635
---
> #line 632
16070c16523
< #line 637
---
> #line 634
16072c16525
< #line 639
---
> #line 636
16074c16527
< #line 639
---
> #line 636
16076c16529
< #line 639
---
> #line 636
16078c16531
< #line 640
---
> #line 637
16080c16533
< #line 641
---
> #line 638
16085c16538
< #line 651
---
> #line 648
16087c16540
< #line 652
---
> #line 649
16089,16090c16542,16543
<   ldv_51472: ;
< #line 654
---
>   ldv_52007: ;
> #line 651
16092,16093c16545,16546
< #line 655
<     goto ldv_51471;
---
> #line 652
>     goto ldv_52006;
16097c16550
< #line 658
---
> #line 655
16099,16100c16552,16553
< #line 659
<     goto ldv_51471;
---
> #line 656
>     goto ldv_52006;
16104c16557
< #line 662
---
> #line 659
16106,16107c16559,16560
< #line 663
<     goto ldv_51471;
---
> #line 660
>     goto ldv_52006;
16111c16564
< #line 669
---
> #line 666
16113c16566
< #line 669
---
> #line 666
16115,16116c16568,16569
< #line 670
<     goto ldv_51471;
---
> #line 667
>     goto ldv_52006;
16120c16573
< #line 671
---
> #line 668
16122c16575
< #line 672
---
> #line 669
16124c16577
< #line 673
---
> #line 670
16126c16579
< #line 674
---
> #line 671
16131c16584
< #line 675
---
> #line 672
16132a16586,16588
> #line 673
>   goto ldv_52007;
>   ldv_52006: ;
16134,16136d16589
<   goto ldv_51472;
<   ldv_51471: ;
< #line 679
16138c16591
< #line 680
---
> #line 677
16143c16596
< #line 684
---
> #line 681
16145c16598
< #line 685
---
> #line 682
16150,16152c16603,16605
< #line 686
<   if (mdev->agreed_pro_version > 88 && (unsigned long )mdev->csums_tfm != (unsigned long )((struct crypto_hash *)0)) {
< #line 687
---
> #line 683
>   if ((mdev->tconn)->agreed_pro_version > 88 && (unsigned long )(mdev->tconn)->csums_tfm != (unsigned long )((struct crypto_hash *)0)) {
> #line 684
16154c16607
< #line 687
---
> #line 684
16157c16610
< #line 689
---
> #line 686
16159,16160c16612,16613
< #line 690
<     return (0);
---
> #line 687
>     return (-5);
16162c16615
< #line 692
---
> #line 689
16164c16617
< #line 693
---
> #line 690
16166c16619
< #line 694
---
> #line 691
16168c16621
< #line 695
---
> #line 692
16171,16172c16624,16625
< #line 698
<     goto ldv_51476;
---
> #line 695
>     goto ldv_52011;
16174,16179c16627,16632
< #line 700
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"),
<                          "i" (700), "i" (12UL));
<     ldv_51478: ;
< #line 700
<     goto ldv_51478;
---
> #line 697
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"),
>                          "i" (697), "i" (12UL));
>     ldv_52013: ;
> #line 697
>     goto ldv_52013;
16181c16634
<     ldv_51476: ;
---
>     ldv_52011: ;
16183c16636
< #line 703
---
> #line 702
16185,16188c16638,16641
< #line 704
<     tmp___11 = drbd_send_drequest(mdev, 9, sector, size, 0xffffffffffffffffULL);
< #line 704
<     if (tmp___11 == 0) {
---
> #line 703
>     err = drbd_send_drequest(mdev, 9, sector, size, 0xffffffffffffffffULL);
> #line 705
>     if (err != 0) {
16192,16204c16645
<       atomic_dec(& mdev->rs_pending_cnt);
< #line 707
<       tmp___10 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 707
<       if (tmp___10 < 0) {
< #line 707
<         tmp___9 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 707
<         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
<                 "w_make_resync_request", 707, tmp___9);
<       } else {
< 
<       }
---
>       _dec_rs_pending(mdev, "w_make_resync_request", 707);
16208c16649
<       return (0);
---
>       return (err);
16213c16654
< #line 606
---
> #line 603
16215,16216c16656,16657
<   ldv_51484: ;
< #line 606
---
>   ldv_52017: ;
> #line 603
16218,16219c16659,16660
< #line 607
<     goto ldv_51483;
---
> #line 604
>     goto ldv_52016;
16224c16665
<   tmp___12 = drbd_bm_bits(mdev);
---
>   tmp___9 = drbd_bm_bits(mdev);
16226c16667
<   if (mdev->bm_resync_fo >= tmp___12) {
---
>   if (mdev->bm_resync_fo >= tmp___9) {
16230c16671
<     return (1);
---
>     return (0);
16242c16683
<   return (1);
---
>   return (0);
16245,16246c16686,16687
< #line 732 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< static int w_make_ov_request(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 732 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> static int w_make_ov_request(struct drbd_work *w , int cancel ) 
16247a16689
>   struct drbd_conf *mdev ;
16256c16698
<   int tmp___1 ;
---
>   bool tmp___1 ;
16263c16705,16707
< #line 736
---
> #line 734
>   mdev = w->ldv_50388.mdev;
> #line 737
16265,16266d16708
< #line 736
<   capacity = tmp;
16267a16710,16711
>   capacity = tmp;
> #line 738
16269c16713
< #line 739
---
> #line 740
16271,16272d16714
< #line 739
<   if (tmp___0 != 0L) {
16273a16716,16717
>   if (tmp___0 != 0L) {
> #line 741
16278c16722
< #line 742
---
> #line 743
16280,16281d16723
< #line 744
<   sector = mdev->ov_position;
16282a16725,16726
>   sector = mdev->ov_position;
> #line 746
16284,16286d16727
< #line 745
<   goto ldv_51504;
<   ldv_51503: ;
16288c16729,16730
<   if (sector >= capacity) {
---
>   goto ldv_52034;
>   ldv_52033: ;
16289a16732,16733
>   if (sector >= capacity) {
> #line 748
16294,16297c16738,16761
< #line 752
<   stop_sector_reached = (bool )((i > 0 && mdev->agreed_pro_version > 96) && mdev->ov_stop_sector <= sector);
< #line 755
<   if ((int )stop_sector_reached) {
---
> #line 753
>   if (i > 0) {
> #line 753
>     tmp___1 = verify_can_do_stop_sector(mdev);
> #line 753
>     if ((int )tmp___1) {
> #line 753
>       if (mdev->ov_stop_sector <= sector) {
> #line 753
>         tmp___2 = 1;
>       } else {
> #line 753
>         tmp___2 = 0;
>       }
>     } else {
> #line 753
>       tmp___2 = 0;
>     }
>   } else {
> #line 753
>     tmp___2 = 0;
>   }
> #line 753
>   stop_sector_reached = (bool )tmp___2;
16299c16763,16765
<     goto ldv_51497;
---
>   if ((int )stop_sector_reached) {
> #line 757
>     goto ldv_52030;
16303c16769
< #line 758
---
> #line 759
16305,16310c16771,16774
< #line 760
<   tmp___1 = drbd_rs_should_slow_down(mdev, sector);
< #line 760
<   if (tmp___1 != 0) {
< #line 762
<     mdev->ov_position = sector;
---
> #line 761
>   tmp___3 = drbd_rs_should_slow_down(mdev, sector);
> #line 761
>   if (tmp___3 != 0) {
16311a16776,16777
>     mdev->ov_position = sector;
> #line 764
16314,16319c16780,16783
< #line 760
<     tmp___2 = drbd_try_rs_begin_io(mdev, sector);
< #line 760
<     if (tmp___2 != 0) {
< #line 762
<       mdev->ov_position = sector;
---
> #line 761
>     tmp___4 = drbd_try_rs_begin_io(mdev, sector);
> #line 761
>     if (tmp___4 != 0) {
16320a16785,16786
>       mdev->ov_position = sector;
> #line 764
16326,16327d16791
< #line 766
<   if ((sector_t )(size >> 9) + sector > capacity) {
16328a16793,16794
>   if ((sector_t )(size >> 9) + sector > capacity) {
> #line 768
16333,16336d16798
< #line 769
<   inc_rs_pending(mdev);
< #line 770
<   tmp___5 = drbd_send_ov_request(mdev, sector, size);
16338,16344c16800
<   if (tmp___5 == 0) {
< #line 771
<     atomic_dec(& mdev->rs_pending_cnt);
< #line 771
<     tmp___4 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 771
<     if (tmp___4 < 0) {
---
>   inc_rs_pending(mdev);
16346c16802
<       tmp___3 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
---
>   tmp___5 = drbd_send_ov_request(mdev, sector, size);
16348,16352c16804
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
<               "w_make_ov_request", 771, tmp___3);
<     } else {
< 
<     }
---
>   if (tmp___5 != 0) {
16353a16806,16807
>     _dec_rs_pending(mdev, "w_make_ov_request", 772);
> #line 773
16358c16812
< #line 774
---
> #line 775
16360c16814
< #line 745
---
> #line 746
16362,16364c16816
<   ldv_51504: ;
< #line 745
<   if (i < number) {
---
>   ldv_52034: ;
16366c16818,16820
<     goto ldv_51503;
---
>   if (i < number) {
> #line 747
>     goto ldv_52033;
16370,16371c16824,16825
<   ldv_51497: 
< #line 776
---
>   ldv_52030: 
> #line 777
16374,16375d16827
< #line 779
<   mdev->rs_in_flight = mdev->rs_in_flight + (i << 3);
16377c16829
<   if (i == 0 || ! stop_sector_reached) {
---
>   mdev->rs_in_flight = mdev->rs_in_flight + (i << 3);
16378a16831,16832
>   if (i == 0 || ! stop_sector_reached) {
> #line 782
16383c16837
< #line 782
---
> #line 783
16387,16388c16841,16842
< #line 786 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< void start_resync_timer_fn(unsigned long data ) 
---
> #line 786 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_ov_finished(struct drbd_work *w , int cancel ) 
16394c16848,16850
<   mdev = (struct drbd_conf *)data;
---
>   mdev = w->ldv_50388.mdev;
> #line 789
>   kfree((void const   *)w);
16396c16852
<   drbd_queue_work(& mdev->data.work, & mdev->start_resync_work);
---
>   ov_out_of_sync_print(mdev);
16398c16854,16856
<   return;
---
>   drbd_resync_finished(mdev);
> #line 793
>   return (0);
16401,16402c16859,16860
< #line 793 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_start_resync(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 796 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> static int w_resync_finished(struct drbd_work *w , int cancel ) 
16404,16405c16862
<   int tmp ;
<   int tmp___0 ;
---
>   struct drbd_conf *mdev ;
16408,16428d16864
< #line 795
<   tmp = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 795
<   if (tmp != 0) {
< #line 796
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "w_start_resync later...\n");
< #line 797
<     mdev->start_resync_timer.expires = (unsigned long )jiffies + 25UL;
< #line 798
<     add_timer(& mdev->start_resync_timer);
< #line 799
<     return (1);
<   } else {
< #line 795
<     tmp___0 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 795
<     if (tmp___0 != 0) {
< #line 796
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "w_start_resync later...\n");
< #line 797
<       mdev->start_resync_timer.expires = (unsigned long )jiffies + 25UL;
16430c16866
<       add_timer(& mdev->start_resync_timer);
---
>   mdev = w->ldv_50388.mdev;
16432,16467d16867
<       return (1);
<     } else {
< 
<     }
<   }
< #line 802
<   drbd_start_resync(mdev, C_SYNC_SOURCE);
< #line 803
<   drbd_clear_flag(mdev, AHEAD_TO_SYNC_SOURCE);
< #line 804
<   return (1);
< }
< }
< #line 807 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_ov_finished(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
< { 
< 
< 
<   {
< #line 809
<   kfree((void const   *)w);
< #line 810
<   ov_oos_print(mdev);
< #line 811
<   drbd_resync_finished(mdev);
< #line 813
<   return (1);
< }
< }
< #line 816 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< static int w_resync_finished(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
< { 
< 
< 
<   {
< #line 818
16469c16869
< #line 820
---
> #line 801
16471,16472c16871,16872
< #line 822
<   return (1);
---
> #line 803
>   return (0);
16475c16875
< #line 825 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 806 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
16477a16878
>   struct drbd_tconn *tconn ;
16484,16493c16885,16896
< #line 827
<   drbd_clear_flag(mdev, GOT_PING_ACK);
< #line 828
<   request_ping(mdev);
< #line 829
<   tmp = drbd_test_flag(mdev, GOT_PING_ACK);
< #line 829
<   if (tmp != 0 || (int )mdev->state.ldv_40583.conn <= 9) {
< #line 829
<     goto ldv_51527;
---
> #line 808
>   tconn = mdev->tconn;
> #line 810
>   clear_bit(4, (unsigned long volatile   *)(& tconn->flags));
> #line 811
>   request_ping(tconn);
> #line 812
>   tmp = constant_test_bit(4U, (unsigned long const volatile   *)(& tconn->flags));
> #line 812
>   if (tmp != 0 || (int )mdev->state.ldv_50103.conn <= 9) {
> #line 812
>     goto ldv_52049;
16497c16900
< #line 829
---
> #line 812
16499c16902
< #line 829
---
> #line 812
16501c16904
< #line 829
---
> #line 812
16503c16906
< #line 829
---
> #line 812
16505c16908
< #line 829
---
> #line 812
16507c16910
< #line 829
---
> #line 812
16509,16517c16912,16920
<   ldv_51530: 
< #line 829
<   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
< #line 829
<   tmp___1 = drbd_test_flag(mdev, GOT_PING_ACK);
< #line 829
<   if (tmp___1 != 0 || (int )mdev->state.ldv_40583.conn <= 9) {
< #line 829
<     goto ldv_51529;
---
>   ldv_52052: 
> #line 812
>   prepare_to_wait(& tconn->ping_wait, & __wait, 2);
> #line 812
>   tmp___1 = constant_test_bit(4U, (unsigned long const volatile   *)(& tconn->flags));
> #line 812
>   if (tmp___1 != 0 || (int )mdev->state.ldv_50103.conn <= 9) {
> #line 812
>     goto ldv_52051;
16521c16924
< #line 829
---
> #line 812
16523,16529c16926,16932
< #line 829
<   goto ldv_51530;
<   ldv_51529: 
< #line 829
<   finish_wait(& mdev->misc_wait, & __wait);
<   ldv_51527: ;
< #line 832
---
> #line 812
>   goto ldv_52052;
>   ldv_52051: 
> #line 812
>   finish_wait(& tconn->ping_wait, & __wait);
>   ldv_52049: ;
> #line 815
16533c16936
< #line 833 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 816 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
16555c16958
< #line 839
---
> #line 822
16557c16960
< #line 840
---
> #line 823
16559c16962
< #line 845
---
> #line 828
16561c16964
< #line 845
---
> #line 828
16563c16966
< #line 851
---
> #line 834
16565,16567c16968,16970
< #line 852
<     tmp = kmalloc(24UL, 32U);
< #line 852
---
> #line 835
>     tmp = kmalloc(32UL, 32U);
> #line 835
16569c16972
< #line 853
---
> #line 836
16571c16974
< #line 854
---
> #line 837
16573,16575c16976,16980
< #line 855
<       drbd_queue_work(& mdev->data.work, w);
< #line 856
---
> #line 838
>       w->ldv_50388.mdev = mdev;
> #line 839
>       drbd_queue_work(& (mdev->tconn)->sender_work, w);
> #line 840
16580c16985
< #line 858
---
> #line 842
16585c16990
< #line 861
---
> #line 845
16587c16992
< #line 862
---
> #line 846
16589c16994
< #line 863
---
> #line 847
16594c16999
< #line 865
---
> #line 849
16596,16598c17001,17003
< #line 867
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 288U || (unsigned int )*((unsigned short *)mdev + 1138UL) == 304U) {
< #line 868
---
> #line 851
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 288U || (unsigned int )*((unsigned short *)mdev + 374UL) == 304U) {
> #line 852
16603c17008
< #line 870
---
> #line 854
16605c17010
< #line 871
---
> #line 855
16607c17012
< #line 873
---
> #line 857
16609c17014
< #line 873
---
> #line 857
16611c17016
< #line 874
---
> #line 858
16616c17021
< #line 876
---
> #line 860
16618,16622c17023,17027
< #line 878
<   spin_lock_irq(& mdev->req_lock);
< #line 879
<   os = mdev->state;
< #line 881
---
> #line 862
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 863
>   os = drbd_read_state(mdev);
> #line 865
16624,16626c17029,17031
< #line 885
<   if ((int )os.ldv_40583.conn <= 10) {
< #line 886
---
> #line 869
>   if ((int )os.ldv_40604.conn <= 10) {
> #line 870
16631c17036
< #line 888
---
> #line 872
16633,16635c17038,17040
< #line 889
<   ns.ldv_40583.conn = 10U;
< #line 891
---
> #line 873
>   ns.ldv_40604.conn = 10U;
> #line 875
16639c17044
< #line 895
---
> #line 879
16641c17046
< #line 897
---
> #line 881
16643c17048
< #line 898
---
> #line 882
16645c17050
< #line 899
---
> #line 883
16648c17053
< #line 901
---
> #line 885
16651c17056
< #line 904
---
> #line 888
16653c17058
< #line 904
---
> #line 888
16655,16656c17060,17061
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<                 904);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                 888);
16660c17065
< #line 906
---
> #line 890
16662c17067
< #line 907
---
> #line 891
16667,16669c17072,17074
< #line 909
<       if ((unsigned long )mdev->csums_tfm != (unsigned long )((struct crypto_hash *)0) && mdev->rs_total != 0UL) {
< #line 910
---
> #line 893
>       if ((unsigned long )(mdev->tconn)->csums_tfm != (unsigned long )((struct crypto_hash *)0) && mdev->rs_total != 0UL) {
> #line 894
16671c17076
< #line 911
---
> #line 895
16673c17078
< #line 912
---
> #line 896
16675c17080
< #line 915
---
> #line 899
16686c17091
< #line 924
---
> #line 908
16688c17093
< #line 925
---
> #line 909
16691c17096
< #line 927
---
> #line 911
16693,16696c17098,17101
< #line 928
<       ns.ldv_40583.disk = 4U;
< #line 929
<       ns.ldv_40583.pdsk = 8U;
---
> #line 912
>       ns.ldv_40604.disk = 4U;
> #line 913
>       ns.ldv_40604.pdsk = 8U;
16698,16701c17103,17106
< #line 931
<       ns.ldv_40583.disk = 8U;
< #line 932
<       ns.ldv_40583.pdsk = 4U;
---
> #line 915
>       ns.ldv_40604.disk = 8U;
> #line 916
>       ns.ldv_40604.pdsk = 4U;
16704,16708c17109,17113
< #line 935
<     ns.ldv_40583.disk = 8U;
< #line 936
<     ns.ldv_40583.pdsk = 8U;
< #line 938
---
> #line 919
>     ns.ldv_40604.disk = 8U;
> #line 920
>     ns.ldv_40604.pdsk = 8U;
> #line 922
16710c17115
< #line 939
---
> #line 923
16712c17117
< #line 941
---
> #line 925
16714,16717c17119,17122
< #line 941
<         goto ldv_51550;
<         ldv_51549: 
< #line 942
---
> #line 925
>         goto ldv_52072;
>         ldv_52071: 
> #line 926
16719c17124
< #line 941
---
> #line 925
16721,16722c17126,17127
<         ldv_51550: ;
< #line 941
---
>         ldv_52072: ;
> #line 925
16724,16725c17129,17130
< #line 942
<           goto ldv_51549;
---
> #line 926
>           goto ldv_52071;
16729c17134
< #line 943
---
> #line 927
16731c17136
< #line 944
---
> #line 928
16734c17139
< #line 946
---
> #line 930
16740c17145
< #line 950
---
> #line 934
16742c17147
< #line 953
---
> #line 937
16744c17149
< #line 954
---
> #line 938
16746c17151
< #line 955
---
> #line 939
16748c17153
< #line 959
---
> #line 943
16750,16753c17155,17158
< #line 959
<         goto ldv_51554;
<         ldv_51553: 
< #line 960
---
> #line 943
>         goto ldv_52076;
>         ldv_52075: 
> #line 944
16755c17160
< #line 959
---
> #line 943
16757,16758c17162,17163
<         ldv_51554: ;
< #line 959
---
>         ldv_52076: ;
> #line 943
16760,16761c17165,17166
< #line 960
<           goto ldv_51553;
---
> #line 944
>           goto ldv_52075;
16773c17178
< #line 965
---
> #line 949
16776,16778c17181,17183
< #line 967
<   spin_unlock_irq(& mdev->req_lock);
< #line 968
---
> #line 951
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 952
16781c17186
< #line 970
---
> #line 954
16783c17188
< #line 971
---
> #line 955
16785c17190
< #line 972
---
> #line 956
16787c17192
< #line 975
---
> #line 959
16789c17194
< #line 976
---
> #line 960
16794c17199
< #line 978
---
> #line 962
16796c17201
< #line 980
---
> #line 964
16798c17203
< #line 981
---
> #line 965
16803c17208
< #line 983
---
> #line 967
16807,16808c17212,17213
< #line 987 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< static void move_to_net_ee_or_free(struct drbd_conf *mdev , struct drbd_epoch_entry *e ) 
---
> #line 971 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> static void move_to_net_ee_or_free(struct drbd_conf *mdev , struct drbd_peer_request *peer_req ) 
16814,16816c17219,17221
< #line 989
<   tmp = drbd_ee_has_active_page(e);
< #line 989
---
> #line 973
>   tmp = drbd_peer_req_has_active_page(peer_req);
> #line 973
16818,16820c17223,17225
< #line 991
<     i = (int )(((unsigned long )e->size + 4095UL) >> 12);
< #line 992
---
> #line 975
>     i = (int )(((unsigned long )peer_req->i.size + 4095UL) >> 12);
> #line 976
16822c17227
< #line 993
---
> #line 977
16824,16830c17229,17235
< #line 994
<     spin_lock_irq(& mdev->req_lock);
< #line 995
<     list_add_tail(& e->w.list, & mdev->net_ee);
< #line 996
<     spin_unlock_irq(& mdev->req_lock);
< #line 997
---
> #line 978
>     spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 979
>     list_add_tail(& peer_req->w.list, & mdev->net_ee);
> #line 980
>     spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 981
16833,16834c17238,17239
< #line 999
<     drbd_free_some_ee(mdev, e, 0);
---
> #line 983
>     __drbd_free_peer_req(mdev, peer_req, 0);
16836c17241
< #line 1000
---
> #line 984
16840,16841c17245,17246
< #line 1008 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_e_end_data_req(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 992 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_e_end_data_req(struct drbd_work *w , int cancel ) 
16843c17248
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
16845,16846c17250,17252
<   int ok ;
<   int tmp ;
---
>   struct drbd_conf *mdev ;
>   int err ;
>   long tmp ;
16849,16853c17255
<   int tmp___2 ;
<   long tmp___3 ;
<   int tmp___4 ;
<   int tmp___5 ;
<   long tmp___6 ;
---
>   long tmp___2 ;
16856c17258
< #line 1010
---
> #line 994
16858,16881c17260,17273
< #line 1010
<   e = (struct drbd_epoch_entry *)__mptr;
< #line 1013
<   tmp___1 = __builtin_expect(cancel != 0, 0L);
< #line 1013
<   if (tmp___1 != 0L) {
< #line 1014
<     drbd_free_some_ee(mdev, e, 0);
< #line 1015
<     atomic_dec(& mdev->unacked_cnt);
< #line 1015
<     tmp___0 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1015
<     if (tmp___0 < 0) {
< #line 1015
<       tmp = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1015
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<               "w_e_end_data_req", 1015, tmp);
<     } else {
< 
<     }
< #line 1016
<     return (1);
---
> #line 994
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 995
>   mdev = w->ldv_50388.mdev;
> #line 998
>   tmp = __builtin_expect(cancel != 0, 0L);
> #line 998
>   if (tmp != 0L) {
> #line 999
>     __drbd_free_peer_req(mdev, peer_req, 0);
> #line 1000
>     _dec_unacked(mdev, "w_e_end_data_req", 1000);
> #line 1001
>     return (0);
16885,16890c17277,17282
< #line 1019
<   tmp___3 = __builtin_expect((e->flags & 8UL) == 0UL, 1L);
< #line 1019
<   if (tmp___3 != 0L) {
< #line 1020
<     ok = drbd_send_block(mdev, P_DATA_REPLY, e);
---
> #line 1004
>   tmp___1 = __builtin_expect((peer_req->flags & 8UL) == 0UL, 1L);
> #line 1004
>   if (tmp___1 != 0L) {
> #line 1005
>     err = drbd_send_block(mdev, P_DATA_REPLY, peer_req);
16892,16896c17284,17288
< #line 1022
<     tmp___2 = ___ratelimit(& drbd_ratelimit_state, "w_e_end_data_req");
< #line 1022
<     if (tmp___2 != 0) {
< #line 1023
---
> #line 1007
>     tmp___0 = ___ratelimit(& drbd_ratelimit_state, "w_e_end_data_req");
> #line 1007
>     if (tmp___0 != 0) {
> #line 1008
16898c17290
<               (unsigned long long )e->sector);
---
>               (unsigned long long )peer_req->i.sector);
16902,16917c17294,17295
< #line 1026
<     ok = drbd_send_ack(mdev, P_NEG_DREPLY, e);
<   }
< #line 1029
<   atomic_dec(& mdev->unacked_cnt);
< #line 1029
<   tmp___5 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1029
<   if (tmp___5 < 0) {
< #line 1029
<     tmp___4 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1029
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<             "w_e_end_data_req", 1029, tmp___4);
<   } else {
< 
---
> #line 1011
>     err = drbd_send_ack(mdev, P_NEG_DREPLY, peer_req);
16919,16925c17297,17305
< #line 1031
<   move_to_net_ee_or_free(mdev, e);
< #line 1033
<   tmp___6 = __builtin_expect(ok == 0, 0L);
< #line 1033
<   if (tmp___6 != 0L) {
< #line 1034
---
> #line 1014
>   _dec_unacked(mdev, "w_e_end_data_req", 1014);
> #line 1016
>   move_to_net_ee_or_free(mdev, peer_req);
> #line 1018
>   tmp___2 = __builtin_expect(err != 0, 0L);
> #line 1018
>   if (tmp___2 != 0L) {
> #line 1019
16930,16931c17310,17311
< #line 1035
<   return (ok);
---
> #line 1020
>   return (err);
16934,16935c17314,17315
< #line 1044 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_e_end_rsdata_req(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1029 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_e_end_rsdata_req(struct drbd_work *w , int cancel ) 
16937c17317
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
16939,16940c17319,17321
<   int ok ;
<   int tmp ;
---
>   struct drbd_conf *mdev ;
>   int err ;
>   long tmp ;
16942,16943c17323,17324
<   long tmp___1 ;
<   int tmp___2 ;
---
>   int tmp___1 ;
>   long tmp___2 ;
16946,16950c17327
<   int tmp___5 ;
<   long tmp___6 ;
<   int tmp___7 ;
<   int tmp___8 ;
<   long tmp___9 ;
---
>   long tmp___5 ;
16953c17330
< #line 1046
---
> #line 1031
16955,16978c17332,17345
< #line 1046
<   e = (struct drbd_epoch_entry *)__mptr;
< #line 1049
<   tmp___1 = __builtin_expect(cancel != 0, 0L);
< #line 1049
<   if (tmp___1 != 0L) {
< #line 1050
<     drbd_free_some_ee(mdev, e, 0);
< #line 1051
<     atomic_dec(& mdev->unacked_cnt);
< #line 1051
<     tmp___0 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1051
<     if (tmp___0 < 0) {
< #line 1051
<       tmp = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1051
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<               "w_e_end_rsdata_req", 1051, tmp);
<     } else {
< 
<     }
< #line 1052
<     return (1);
---
> #line 1031
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 1032
>   mdev = w->ldv_50388.mdev;
> #line 1035
>   tmp = __builtin_expect(cancel != 0, 0L);
> #line 1035
>   if (tmp != 0L) {
> #line 1036
>     __drbd_free_peer_req(mdev, peer_req, 0);
> #line 1037
>     _dec_unacked(mdev, "w_e_end_rsdata_req", 1037);
> #line 1038
>     return (0);
16982,16988c17349,17355
< #line 1055
<   tmp___2 = _get_ldev_if_state(mdev, D_FAILED);
< #line 1055
<   if (tmp___2 != 0) {
< #line 1056
<     drbd_rs_complete_io(mdev, e->sector);
< #line 1057
---
> #line 1041
>   tmp___0 = _get_ldev_if_state(mdev, D_FAILED);
> #line 1041
>   if (tmp___0 != 0) {
> #line 1042
>     drbd_rs_complete_io(mdev, peer_req->i.sector);
> #line 1043
16993,16996c17360,17363
< #line 1060
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 352U) {
< #line 1061
<     ok = drbd_send_ack(mdev, P_RS_CANCEL, e);
---
> #line 1046
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 352U) {
> #line 1047
>     err = drbd_send_ack(mdev, P_RS_CANCEL, peer_req);
16998,17006c17365,17373
< #line 1062
<     tmp___6 = __builtin_expect((e->flags & 8UL) == 0UL, 1L);
< #line 1062
<     if (tmp___6 != 0L) {
< #line 1063
<       tmp___4 = __builtin_expect((int )mdev->state.ldv_40583.pdsk > 3, 1L);
< #line 1063
<       if (tmp___4 != 0L) {
< #line 1064
---
> #line 1048
>     tmp___4 = __builtin_expect((peer_req->flags & 8UL) == 0UL, 1L);
> #line 1048
>     if (tmp___4 != 0L) {
> #line 1049
>       tmp___2 = __builtin_expect((int )mdev->state.ldv_50103.pdsk > 3, 1L);
> #line 1049
>       if (tmp___2 != 0L) {
> #line 1050
17008,17009c17375,17376
< #line 1065
<         ok = drbd_send_block(mdev, P_RS_DATA_REPLY, e);
---
> #line 1051
>         err = drbd_send_block(mdev, P_RS_DATA_REPLY, peer_req);
17011,17015c17378,17382
< #line 1067
<         tmp___3 = ___ratelimit(& drbd_ratelimit_state, "w_e_end_rsdata_req");
< #line 1067
<         if (tmp___3 != 0) {
< #line 1068
---
> #line 1053
>         tmp___1 = ___ratelimit(& drbd_ratelimit_state, "w_e_end_rsdata_req");
> #line 1053
>         if (tmp___1 != 0) {
> #line 1054
17020,17021c17387,17388
< #line 1070
<         ok = 1;
---
> #line 1056
>         err = 0;
17024,17028c17391,17395
< #line 1073
<       tmp___5 = ___ratelimit(& drbd_ratelimit_state, "w_e_end_rsdata_req");
< #line 1073
<       if (tmp___5 != 0) {
< #line 1074
---
> #line 1059
>       tmp___3 = ___ratelimit(& drbd_ratelimit_state, "w_e_end_rsdata_req");
> #line 1059
>       if (tmp___3 != 0) {
> #line 1060
17030c17397
<                 (unsigned long long )e->sector);
---
>                 (unsigned long long )peer_req->i.sector);
17034,17037c17401,17404
< #line 1077
<       ok = drbd_send_ack(mdev, P_NEG_RS_DREPLY, e);
< #line 1080
<       drbd_rs_failed_io(mdev, e->sector, (int )e->size);
---
> #line 1063
>       err = drbd_send_ack(mdev, P_NEG_RS_DREPLY, peer_req);
> #line 1066
>       drbd_rs_failed_io(mdev, peer_req->i.sector, (int )peer_req->i.size);
17040,17060c17407,17415
< #line 1083
<   atomic_dec(& mdev->unacked_cnt);
< #line 1083
<   tmp___8 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1083
<   if (tmp___8 < 0) {
< #line 1083
<     tmp___7 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1083
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<             "w_e_end_rsdata_req", 1083, tmp___7);
<   } else {
< 
<   }
< #line 1085
<   move_to_net_ee_or_free(mdev, e);
< #line 1087
<   tmp___9 = __builtin_expect(ok == 0, 0L);
< #line 1087
<   if (tmp___9 != 0L) {
< #line 1088
---
> #line 1069
>   _dec_unacked(mdev, "w_e_end_rsdata_req", 1069);
> #line 1071
>   move_to_net_ee_or_free(mdev, peer_req);
> #line 1073
>   tmp___5 = __builtin_expect(err != 0, 0L);
> #line 1073
>   if (tmp___5 != 0L) {
> #line 1074
17065,17066c17420,17421
< #line 1089
<   return (ok);
---
> #line 1075
>   return (err);
17069,17070c17424,17425
< #line 1092 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_e_end_csum_rs_req(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1078 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_e_end_csum_rs_req(struct drbd_work *w , int cancel ) 
17072c17427
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
17073a17429
>   struct drbd_conf *mdev ;
17077c17433
<   int ok ;
---
>   int err ;
17079c17435
<   int tmp ;
---
>   long tmp ;
17081c17437
<   long tmp___1 ;
---
>   unsigned int tmp___1 ;
17083,17089c17439,17441
<   unsigned int tmp___3 ;
<   int tmp___4 ;
<   int tmp___5 ;
<   long tmp___6 ;
<   int tmp___7 ;
<   int tmp___8 ;
<   long tmp___9 ;
---
>   int tmp___3 ;
>   long tmp___4 ;
>   long tmp___5 ;
17092c17444
< #line 1094
---
> #line 1080
17094,17096c17446,17450
< #line 1094
<   e = (struct drbd_epoch_entry *)__mptr;
< #line 1097
---
> #line 1080
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 1081
>   mdev = w->ldv_50388.mdev;
> #line 1084
17098c17452
< #line 1098
---
> #line 1085
17100,17121c17454,17463
< #line 1100
<   tmp___1 = __builtin_expect(cancel != 0, 0L);
< #line 1100
<   if (tmp___1 != 0L) {
< #line 1101
<     drbd_free_some_ee(mdev, e, 0);
< #line 1102
<     atomic_dec(& mdev->unacked_cnt);
< #line 1102
<     tmp___0 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1102
<     if (tmp___0 < 0) {
< #line 1102
<       tmp = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1102
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<               "w_e_end_csum_rs_req", 1102, tmp);
<     } else {
< 
<     }
< #line 1103
<     return (1);
---
> #line 1087
>   tmp = __builtin_expect(cancel != 0, 0L);
> #line 1087
>   if (tmp != 0L) {
> #line 1088
>     __drbd_free_peer_req(mdev, peer_req, 0);
> #line 1089
>     _dec_unacked(mdev, "w_e_end_csum_rs_req", 1089);
> #line 1090
>     return (0);
17125,17131c17467,17473
< #line 1106
<   tmp___2 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1106
<   if (tmp___2 != 0) {
< #line 1107
<     drbd_rs_complete_io(mdev, e->sector);
< #line 1108
---
> #line 1093
>   tmp___0 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1093
>   if (tmp___0 != 0) {
> #line 1094
>     drbd_rs_complete_io(mdev, peer_req->i.sector);
> #line 1095
17136,17148c17478,17490
< #line 1111
<   di = e->ldv_49794.digest;
< #line 1113
<   tmp___6 = __builtin_expect((e->flags & 8UL) == 0UL, 1L);
< #line 1113
<   if (tmp___6 != 0L) {
< #line 1117
<     if ((unsigned long )mdev->csums_tfm != (unsigned long )((struct crypto_hash *)0)) {
< #line 1118
<       tmp___3 = crypto_hash_digestsize(mdev->csums_tfm);
< #line 1118
<       digest_size = (int )tmp___3;
< #line 1119
---
> #line 1098
>   di = peer_req->ldv_50490.digest;
> #line 1100
>   tmp___4 = __builtin_expect((peer_req->flags & 8UL) == 0UL, 1L);
> #line 1100
>   if (tmp___4 != 0L) {
> #line 1104
>     if ((unsigned long )(mdev->tconn)->csums_tfm != (unsigned long )((struct crypto_hash *)0)) {
> #line 1105
>       tmp___1 = crypto_hash_digestsize((mdev->tconn)->csums_tfm);
> #line 1105
>       digest_size = (int )tmp___1;
> #line 1106
17150c17492
< #line 1119
---
> #line 1106
17152,17153c17494,17495
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<                 1119);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                 1106);
17157c17499
< #line 1120
---
> #line 1107
17162c17504
< #line 1122
---
> #line 1109
17164,17170c17506,17512
< #line 1123
<       drbd_csum_ee(mdev, mdev->csums_tfm, e, digest);
< #line 1124
<       tmp___4 = memcmp((void const   *)digest, (void const   *)di->digest, (size_t )digest_size);
< #line 1124
<       eq = tmp___4 == 0;
< #line 1125
---
> #line 1110
>       drbd_csum_ee(mdev, (mdev->tconn)->csums_tfm, peer_req, digest);
> #line 1111
>       tmp___2 = memcmp((void const   *)digest, (void const   *)di->digest, (size_t )digest_size);
> #line 1111
>       eq = tmp___2 == 0;
> #line 1112
17175c17517
< #line 1128
---
> #line 1115
17177,17183c17519,17525
< #line 1129
<       __drbd_set_in_sync(mdev, e->sector, (int )e->size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<                          1129U);
< #line 1131
<       mdev->rs_same_csum = mdev->rs_same_csum + (unsigned long )(e->size >> 12);
< #line 1132
<       ok = drbd_send_ack(mdev, P_RS_IS_IN_SYNC, e);
---
> #line 1116
>       __drbd_set_in_sync(mdev, peer_req->i.sector, (int )peer_req->i.size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                          1116U);
> #line 1118
>       mdev->rs_same_csum = mdev->rs_same_csum + (unsigned long )(peer_req->i.size >> 12);
> #line 1119
>       err = drbd_send_ack(mdev, P_RS_IS_IN_SYNC, peer_req);
17185c17527
< #line 1134
---
> #line 1121
17187,17191c17529,17533
< #line 1135
<       e->ldv_49794.block_id = 0xffffffffffffffffULL;
< #line 1136
<       e->flags = e->flags & 0xffffffffffffffefUL;
< #line 1137
---
> #line 1122
>       peer_req->ldv_50490.block_id = 0xffffffffffffffffULL;
> #line 1123
>       peer_req->flags = peer_req->flags & 0xffffffffffffffefUL;
> #line 1124
17193,17194c17535,17536
< #line 1138
<       ok = drbd_send_block(mdev, P_RS_DATA_REPLY, e);
---
> #line 1125
>       err = drbd_send_block(mdev, P_RS_DATA_REPLY, peer_req);
17197,17203c17539,17545
< #line 1141
<     ok = drbd_send_ack(mdev, P_NEG_RS_DREPLY, e);
< #line 1142
<     tmp___5 = ___ratelimit(& drbd_ratelimit_state, "w_e_end_csum_rs_req");
< #line 1142
<     if (tmp___5 != 0) {
< #line 1143
---
> #line 1128
>     err = drbd_send_ack(mdev, P_NEG_RS_DREPLY, peer_req);
> #line 1129
>     tmp___3 = ___ratelimit(& drbd_ratelimit_state, "w_e_end_csum_rs_req");
> #line 1129
>     if (tmp___3 != 0) {
> #line 1130
17209,17229c17551,17559
< #line 1146
<   atomic_dec(& mdev->unacked_cnt);
< #line 1146
<   tmp___8 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1146
<   if (tmp___8 < 0) {
< #line 1146
<     tmp___7 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1146
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<             "w_e_end_csum_rs_req", 1146, tmp___7);
<   } else {
< 
<   }
< #line 1147
<   move_to_net_ee_or_free(mdev, e);
< #line 1149
<   tmp___9 = __builtin_expect(ok == 0, 0L);
< #line 1149
<   if (tmp___9 != 0L) {
< #line 1150
---
> #line 1133
>   _dec_unacked(mdev, "w_e_end_csum_rs_req", 1133);
> #line 1134
>   move_to_net_ee_or_free(mdev, peer_req);
> #line 1136
>   tmp___5 = __builtin_expect(err != 0, 0L);
> #line 1136
>   if (tmp___5 != 0L) {
> #line 1137
17234,17235c17564,17565
< #line 1151
<   return (ok);
---
> #line 1138
>   return (err);
17238,17239c17568,17569
< #line 1155 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_e_end_ov_req(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1141 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_e_end_ov_req(struct drbd_work *w , int cancel ) 
17241c17571
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
17242a17573
>   struct drbd_conf *mdev ;
17247c17578
<   int ok ;
---
>   int err ;
17251,17254d17581
<   int tmp___2 ;
<   int tmp___3 ;
<   int tmp___4 ;
<   int tmp___5 ;
17257c17584
< #line 1157
---
> #line 1143
17259,17267c17586,17596
< #line 1157
<   e = (struct drbd_epoch_entry *)__mptr;
< #line 1158
<   sector = e->sector;
< #line 1159
<   size = e->size;
< #line 1162
<   ok = 1;
< #line 1164
---
> #line 1143
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 1144
>   mdev = w->ldv_50388.mdev;
> #line 1145
>   sector = peer_req->i.sector;
> #line 1146
>   size = peer_req->i.size;
> #line 1149
>   err = 0;
> #line 1151
17269c17598
< #line 1164
---
> #line 1151
17271c17600
< #line 1165
---
> #line 1152
17276,17278c17605,17607
< #line 1167
<   tmp___0 = crypto_hash_digestsize(mdev->verify_tfm);
< #line 1167
---
> #line 1154
>   tmp___0 = crypto_hash_digestsize((mdev->tconn)->verify_tfm);
> #line 1154
17280c17609
< #line 1168
---
> #line 1155
17282c17611
< #line 1169
---
> #line 1156
17284,17286c17613,17615
< #line 1170
<     ok = 0;
< #line 1171
---
> #line 1157
>     err = 1;
> #line 1158
17291,17293c17620,17622
< #line 1174
<   tmp___1 = __builtin_expect((e->flags & 8UL) == 0UL, 1L);
< #line 1174
---
> #line 1161
>   tmp___1 = __builtin_expect((peer_req->flags & 8UL) == 0UL, 1L);
> #line 1161
17295,17296c17624,17625
< #line 1175
<     drbd_csum_ee(mdev, mdev->verify_tfm, e, digest);
---
> #line 1162
>     drbd_csum_ee(mdev, (mdev->tconn)->verify_tfm, peer_req, digest);
17298c17627
< #line 1177
---
> #line 1164
17301,17305c17630,17634
< #line 1184
<   drbd_free_some_ee(mdev, e, 0);
< #line 1185
<   e = 0;
< #line 1186
---
> #line 1171
>   __drbd_free_peer_req(mdev, peer_req, 0);
> #line 1172
>   peer_req = 0;
> #line 1173
17307,17324c17636,17641
< #line 1187
<   ok = drbd_send_drequest_csum(mdev, sector, (int )size, digest, digest_size, P_OV_REPLY);
< #line 1190
<   if (ok == 0) {
< #line 1191
<     atomic_dec(& mdev->rs_pending_cnt);
< #line 1191
<     tmp___3 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 1191
<     if (tmp___3 < 0) {
< #line 1191
<       tmp___2 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 1191
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
<               "w_e_end_ov_req", 1191, tmp___2);
<     } else {
< 
<     }
---
> #line 1174
>   err = drbd_send_drequest_csum(mdev, sector, (int )size, digest, digest_size, P_OV_REPLY);
> #line 1175
>   if (err != 0) {
> #line 1176
>     _dec_rs_pending(mdev, "w_e_end_ov_req", 1176);
17328c17645
< #line 1192
---
> #line 1177
17331,17348c17648,17651
< #line 1195
<   if ((unsigned long )e != (unsigned long )((struct drbd_epoch_entry *)0)) {
< #line 1196
<     drbd_free_some_ee(mdev, e, 0);
<   } else {
< 
<   }
< #line 1197
<   atomic_dec(& mdev->unacked_cnt);
< #line 1197
<   tmp___5 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1197
<   if (tmp___5 < 0) {
< #line 1197
<     tmp___4 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1197
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<             "w_e_end_ov_req", 1197, tmp___4);
---
> #line 1180
>   if ((unsigned long )peer_req != (unsigned long )((struct drbd_peer_request *)0)) {
> #line 1181
>     __drbd_free_peer_req(mdev, peer_req, 0);
17352,17353c17655,17658
< #line 1198
<   return (ok);
---
> #line 1182
>   _dec_unacked(mdev, "w_e_end_ov_req", 1182);
> #line 1183
>   return (err);
17356,17357c17661,17662
< #line 1201 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< void drbd_ov_oos_found(struct drbd_conf *mdev , sector_t sector , int size ) 
---
> #line 1186 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> void drbd_ov_out_of_sync_found(struct drbd_conf *mdev , sector_t sector , int size ) 
17362c17667
< #line 1203
---
> #line 1188
17364c17669
< #line 1204
---
> #line 1189
17367c17672
< #line 1206
---
> #line 1191
17369c17674
< #line 1207
---
> #line 1192
17372,17375c17677,17680
< #line 1209
<   __drbd_set_out_of_sync(mdev, sector, size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<                          1209U);
< #line 1210
---
> #line 1194
>   __drbd_set_out_of_sync(mdev, sector, size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                          1194U);
> #line 1195
17379,17380c17684,17685
< #line 1212 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_e_end_ov_reply(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1197 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_e_end_ov_reply(struct drbd_work *w , int cancel ) 
17382c17687
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
17383a17689
>   struct drbd_conf *mdev ;
17389c17695
<   int ok ;
---
>   int err ;
17392c17698
<   int tmp ;
---
>   long tmp ;
17394c17700
<   long tmp___1 ;
---
>   unsigned int tmp___1 ;
17396,17400c17702,17703
<   unsigned int tmp___3 ;
<   int tmp___4 ;
<   long tmp___5 ;
<   int tmp___6 ;
<   int tmp___7 ;
---
>   long tmp___3 ;
>   bool tmp___4 ;
17403c17706
< #line 1214
---
> #line 1199
17405,17411c17708,17716
< #line 1214
<   e = (struct drbd_epoch_entry *)__mptr;
< #line 1217
<   sector = e->sector;
< #line 1218
<   size = e->size;
< #line 1220
---
> #line 1199
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 1200
>   mdev = w->ldv_50388.mdev;
> #line 1203
>   sector = peer_req->i.sector;
> #line 1204
>   size = peer_req->i.size;
> #line 1206
17413c17718
< #line 1221
---
> #line 1207
17415,17436c17720,17729
< #line 1223
<   tmp___1 = __builtin_expect(cancel != 0, 0L);
< #line 1223
<   if (tmp___1 != 0L) {
< #line 1224
<     drbd_free_some_ee(mdev, e, 0);
< #line 1225
<     atomic_dec(& mdev->unacked_cnt);
< #line 1225
<     tmp___0 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1225
<     if (tmp___0 < 0) {
< #line 1225
<       tmp = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1225
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<               "w_e_end_ov_reply", 1225, tmp);
<     } else {
< 
<     }
< #line 1226
<     return (1);
---
> #line 1209
>   tmp = __builtin_expect(cancel != 0, 0L);
> #line 1209
>   if (tmp != 0L) {
> #line 1210
>     __drbd_free_peer_req(mdev, peer_req, 0);
> #line 1211
>     _dec_unacked(mdev, "w_e_end_ov_reply", 1211);
> #line 1212
>     return (0);
17440,17446c17733,17739
< #line 1231
<   tmp___2 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1231
<   if (tmp___2 != 0) {
< #line 1232
<     drbd_rs_complete_io(mdev, e->sector);
< #line 1233
---
> #line 1217
>   tmp___0 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1217
>   if (tmp___0 != 0) {
> #line 1218
>     drbd_rs_complete_io(mdev, peer_req->i.sector);
> #line 1219
17451,17461c17744,17754
< #line 1236
<   di = e->ldv_49794.digest;
< #line 1238
<   tmp___5 = __builtin_expect((e->flags & 8UL) == 0UL, 1L);
< #line 1238
<   if (tmp___5 != 0L) {
< #line 1239
<     tmp___3 = crypto_hash_digestsize(mdev->verify_tfm);
< #line 1239
<     digest_size = (int )tmp___3;
< #line 1240
---
> #line 1222
>   di = peer_req->ldv_50490.digest;
> #line 1224
>   tmp___3 = __builtin_expect((peer_req->flags & 8UL) == 0UL, 1L);
> #line 1224
>   if (tmp___3 != 0L) {
> #line 1225
>     tmp___1 = crypto_hash_digestsize((mdev->tconn)->verify_tfm);
> #line 1225
>     digest_size = (int )tmp___1;
> #line 1226
17463c17756
< #line 1241
---
> #line 1227
17465,17467c17758,17760
< #line 1242
<       drbd_csum_ee(mdev, mdev->verify_tfm, e, digest);
< #line 1244
---
> #line 1228
>       drbd_csum_ee(mdev, (mdev->tconn)->verify_tfm, peer_req, digest);
> #line 1230
17469c17762
< #line 1244
---
> #line 1230
17471,17472c17764,17765
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<                 1244);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                 1230);
17476,17480c17769,17773
< #line 1245
<       tmp___4 = memcmp((void const   *)digest, (void const   *)di->digest, (size_t )digest_size);
< #line 1245
<       eq = tmp___4 == 0;
< #line 1246
---
> #line 1231
>       tmp___2 = memcmp((void const   *)digest, (void const   *)di->digest, (size_t )digest_size);
> #line 1231
>       eq = tmp___2 == 0;
> #line 1232
17488,17490c17781,17783
< #line 1255
<   drbd_free_some_ee(mdev, e, 0);
< #line 1256
---
> #line 1241
>   __drbd_free_peer_req(mdev, peer_req, 0);
> #line 1242
17492,17510c17785,17786
< #line 1257
<     drbd_ov_oos_found(mdev, sector, (int )size);
<   } else {
< #line 1259
<     ov_oos_print(mdev);
<   }
< #line 1261
<   ok = drbd_send_ack_ex(mdev, P_OV_RESULT, sector, (int )size, eq != 0 ? 4711ULL : 4712ULL);
< #line 1264
<   atomic_dec(& mdev->unacked_cnt);
< #line 1264
<   tmp___7 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1264
<   if (tmp___7 < 0) {
< #line 1264
<     tmp___6 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1264
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<             "w_e_end_ov_reply", 1264, tmp___6);
---
> #line 1243
>     drbd_ov_out_of_sync_found(mdev, sector, (int )size);
17512c17788,17789
< 
---
> #line 1245
>     ov_out_of_sync_print(mdev);
17514c17791,17795
< #line 1266
---
> #line 1247
>   err = drbd_send_ack_ex(mdev, P_OV_RESULT, sector, (int )size, eq != 0 ? 4711ULL : 4712ULL);
> #line 1250
>   _dec_unacked(mdev, "w_e_end_ov_reply", 1250);
> #line 1252
17516c17797
< #line 1269
---
> #line 1255
17518c17799
< #line 1270
---
> #line 1256
17523,17525c17804,17808
< #line 1272
<   stop_sector_reached = (bool )(mdev->agreed_pro_version > 96 && (sector_t )(size >> 9) + sector >= mdev->ov_stop_sector);
< #line 1275
---
> #line 1258
>   tmp___4 = verify_can_do_stop_sector(mdev);
> #line 1258
>   stop_sector_reached = (bool )((int )tmp___4 && (sector_t )(size >> 9) + sector >= mdev->ov_stop_sector);
> #line 1261
17527,17529c17810,17812
< #line 1276
<     ov_oos_print(mdev);
< #line 1277
---
> #line 1262
>     ov_out_of_sync_print(mdev);
> #line 1263
17534,17535c17817,17818
< #line 1280
<   return (ok);
---
> #line 1266
>   return (err);
17538,17539c17821,17822
< #line 1283 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_prev_work_done(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1269 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_prev_work_done(struct drbd_work *w , int cancel ) 
17545c17828
< #line 1285
---
> #line 1271
17547c17830
< #line 1285
---
> #line 1271
17549c17832
< #line 1286
---
> #line 1273
17551,17552c17834,17835
< #line 1287
<   return (1);
---
> #line 1274
>   return (0);
17555,17556c17838,17839
< #line 1290 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_send_barrier(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1282 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int drbd_send_barrier(struct drbd_tconn *tconn ) 
17558,17559d17840
<   struct drbd_tl_epoch *b ;
<   struct drbd_work  const  *__mptr ;
17561,17562c17842,17844
<   int ok ;
<   int tmp ;
---
>   struct drbd_socket *sock ;
>   void *tmp ;
>   int tmp___0 ;
17564a17847,17861
> #line 1287
>   sock = & tconn->data;
> #line 1288
>   tmp = conn_prepare_command(tconn, sock);
> #line 1288
>   p = (struct p_barrier *)tmp;
> #line 1289
>   if ((unsigned long )p == (unsigned long )((struct p_barrier *)0)) {
> #line 1290
>     return (-5);
>   } else {
> 
>   }
> #line 1291
>   p->barrier = (u32 )tconn->send.current_epoch_nr;
17566,17568c17863
<   __mptr = (struct drbd_work  const  *)w;
< #line 1292
<   b = (struct drbd_tl_epoch *)__mptr;
---
>   p->pad = 0U;
17570,17576c17865,17882
<   p = & mdev->data.sbuf.barrier;
< #line 1294
<   ok = 1;
< #line 1301
<   spin_lock_irq(& mdev->req_lock);
< #line 1302
<   if ((unsigned long )w->cb != (unsigned long )(& w_send_barrier) || (int )mdev->state.ldv_40583.conn <= 9) {
---
>   tconn->send.current_epoch_writes = 0U;
> #line 1295
>   tmp___0 = conn_send_command(tconn, sock, P_BARRIER, 8U, 0, 0U);
> #line 1295
>   return (tmp___0);
> }
> }
> #line 1298 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_send_write_hint(struct drbd_work *w , int cancel ) 
> { 
>   struct drbd_conf *mdev ;
>   struct drbd_socket *sock ;
>   void *tmp ;
>   int tmp___0 ;
> 
>   {
> #line 1300
>   mdev = w->ldv_50388.mdev;
17578c17884,17886
<     cancel = 1;
---
>   if (cancel != 0) {
> #line 1304
>     return (0);
17582,17583d17889
< #line 1304
<   spin_unlock_irq(& mdev->req_lock);
17585c17891
<   if (cancel != 0) {
---
>   sock = & (mdev->tconn)->data;
17587c17893,17897
<     return (1);
---
>   tmp = drbd_prepare_command(mdev, sock);
> #line 1306
>   if ((unsigned long )tmp == (unsigned long )((void *)0)) {
> #line 1307
>     return (-5);
17592c17902
<   tmp = drbd_get_data_sock(mdev);
---
>   tmp___0 = drbd_send_command(mdev, sock, P_UNPLUG_REMOTE, 0U, 0, 0U);
17594,17597c17904,17909
<   if (tmp == 0) {
< #line 1309
<     return (0);
<   } else {
---
>   return (tmp___0);
> }
> }
> #line 1311 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> static void re_init_if_first_write(struct drbd_tconn *tconn , unsigned int epoch ) 
> { 
17599,17601c17911,17914
<   }
< #line 1310
<   p->barrier = b->br_number;
---
> 
>   {
> #line 1313
>   if (! tconn->send.seen_any_write_yet) {
17603,17604c17916,17918
<   ok = _drbd_send_cmd(mdev, mdev->data.socket, P_BARRIER, (struct p_header80 *)p,
<                       16UL, 0U);
---
>     tconn->send.seen_any_write_yet = 1;
> #line 1315
>     tconn->send.current_epoch_nr = (int )epoch;
17606c17920,17923
<   drbd_put_data_sock(mdev);
---
>     tconn->send.current_epoch_writes = 0U;
>   } else {
> 
>   }
17608c17925
<   return (ok);
---
>   return;
17611,17612c17928,17929
< #line 1321 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_send_write_hint(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1320 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> static void maybe_send_barrier(struct drbd_tconn *tconn , unsigned int epoch ) 
17614c17931
<   int tmp ;
---
> 
17618c17935
<   if (cancel != 0) {
---
>   if (! tconn->send.seen_any_write_yet) {
17620c17937
<     return (1);
---
>     return;
17625,17627c17942,17956
<   tmp = drbd_send_short_cmd(mdev, P_UNPLUG_REMOTE);
< #line 1325
<   return (tmp);
---
>   if ((unsigned int )tconn->send.current_epoch_nr != epoch) {
> #line 1326
>     if (tconn->send.current_epoch_writes != 0U) {
> #line 1327
>       drbd_send_barrier(tconn);
>     } else {
> 
>     }
> #line 1328
>     tconn->send.current_epoch_nr = (int )epoch;
>   } else {
> 
>   }
> #line 1330
>   return;
17630,17631c17959,17960
< #line 1328 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_send_oos(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1332 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_send_out_of_sync(struct drbd_work *w , int cancel ) 
17635c17964,17966
<   int ok ;
---
>   struct drbd_conf *mdev ;
>   struct drbd_tconn *tconn ;
>   int err ;
17639c17970
< #line 1330
---
> #line 1334
17641c17972
< #line 1330
---
> #line 1334
17643c17974,17978
< #line 1333
---
> #line 1335
>   mdev = w->ldv_50388.mdev;
> #line 1336
>   tconn = mdev->tconn;
> #line 1339
17645c17980
< #line 1333
---
> #line 1339
17647,17650c17982,17985
< #line 1334
<     req_mod(req, send_canceled);
< #line 1335
<     return (1);
---
> #line 1340
>     req_mod(req, SEND_CANCELED);
> #line 1341
>     return (0);
17654,17659c17989,17996
< #line 1338
<   ok = drbd_send_oos(mdev, req);
< #line 1339
<   req_mod(req, oos_handed_to_network);
< #line 1341
<   return (ok);
---
> #line 1348
>   maybe_send_barrier(tconn, req->epoch);
> #line 1350
>   err = drbd_send_out_of_sync(mdev, req);
> #line 1351
>   req_mod(req, OOS_HANDED_TO_NETWORK);
> #line 1353
>   return (err);
17662,17663c17999,18000
< #line 1350 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_send_dblock(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1362 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_send_dblock(struct drbd_work *w , int cancel ) 
17667c18004,18006
<   int ok ;
---
>   struct drbd_conf *mdev ;
>   struct drbd_tconn *tconn ;
>   int err ;
17671c18010
< #line 1352
---
> #line 1364
17673c18012
< #line 1352
---
> #line 1364
17675c18014,18018
< #line 1355
---
> #line 1365
>   mdev = w->ldv_50388.mdev;
> #line 1366
>   tconn = mdev->tconn;
> #line 1369
17677c18020
< #line 1355
---
> #line 1369
17679,17682c18022,18025
< #line 1356
<     req_mod(req, send_canceled);
< #line 1357
<     return (1);
---
> #line 1370
>     req_mod(req, SEND_CANCELED);
> #line 1371
>     return (0);
17686,17691c18029,18040
< #line 1360
<   ok = drbd_send_dblock(mdev, req);
< #line 1361
<   req_mod(req, ok != 0 ? handed_over_to_network : send_failed);
< #line 1363
<   return (ok);
---
> #line 1374
>   re_init_if_first_write(tconn, req->epoch);
> #line 1375
>   maybe_send_barrier(tconn, req->epoch);
> #line 1376
>   tconn->send.current_epoch_writes = tconn->send.current_epoch_writes + 1U;
> #line 1378
>   err = drbd_send_dblock(mdev, req);
> #line 1379
>   req_mod(req, err != 0 ? SEND_FAILED : HANDED_OVER_TO_NETWORK);
> #line 1381
>   return (err);
17694,17695c18043,18044
< #line 1372 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_send_read_req(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1390 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_send_read_req(struct drbd_work *w , int cancel ) 
17699c18048,18050
<   int ok ;
---
>   struct drbd_conf *mdev ;
>   struct drbd_tconn *tconn ;
>   int err ;
17701,17702d18051
<   union drbd_state val ;
<   union drbd_state mask ;
17705c18054
< #line 1374
---
> #line 1392
17707c18056
< #line 1374
---
> #line 1392
17709c18058,18062
< #line 1377
---
> #line 1393
>   mdev = w->ldv_50388.mdev;
> #line 1394
>   tconn = mdev->tconn;
> #line 1397
17711c18064
< #line 1377
---
> #line 1397
17713,17738c18066,18069
< #line 1378
<     req_mod(req, send_canceled);
< #line 1379
<     return (1);
<   } else {
< 
<   }
< #line 1382
<   ok = drbd_send_drequest(mdev, 8, req->sector, (int )req->size, (u64 )req);
< #line 1385
<   if (ok == 0) {
< #line 1388
<     if ((int )mdev->state.ldv_40583.conn > 9) {
< #line 1389
<       val.i = 0U;
< #line 1389
<       val.ldv_40583.conn = 5U;
< #line 1389
<       mask.i = 0U;
< #line 1389
<       mask.ldv_40583.conn = 31U;
< #line 1389
<       drbd_force_state(mdev, mask, val);
<     } else {
< 
<     }
---
> #line 1398
>     req_mod(req, SEND_CANCELED);
> #line 1399
>     return (0);
17742,17745c18073,18080
< #line 1391
<   req_mod(req, ok != 0 ? handed_over_to_network : send_failed);
< #line 1393
<   return (ok);
---
> #line 1404
>   maybe_send_barrier(tconn, req->epoch);
> #line 1406
>   err = drbd_send_drequest(mdev, 8, req->i.sector, (int )req->i.size, (u64 )req);
> #line 1409
>   req_mod(req, err != 0 ? SEND_FAILED : HANDED_OVER_TO_NETWORK);
> #line 1411
>   return (err);
17748,17749c18083,18084
< #line 1396 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int w_restart_disk_io(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1414 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_restart_disk_io(struct drbd_work *w , int cancel ) 
17752a18088
>   struct drbd_conf *mdev ;
17755c18091
< #line 1398
---
> #line 1416
17757c18093
< #line 1398
---
> #line 1416
17759,17762c18095,18100
< #line 1400
<   if ((int )(req->master_bio)->bi_rw & 1 && (req->rq_state & 4096UL) != 0UL) {
< #line 1401
<     drbd_al_begin_io(mdev, req->sector);
---
> #line 1417
>   mdev = w->ldv_50388.mdev;
> #line 1419
>   if ((int )(req->master_bio)->bi_rw & 1 && ((unsigned long )req->rq_state & 4096UL) != 0UL) {
> #line 1420
>     drbd_al_begin_io(mdev, & req->i);
17766c18104
< #line 1407
---
> #line 1422
17768c18106
< #line 1408
---
> #line 1423
17770c18108
< #line 1409
---
> #line 1424
17772,17773c18110,18111
< #line 1411
<   return (1);
---
> #line 1426
>   return (0);
17776c18114
< #line 1414 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 1429 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
17780c18118,18124
<   int _b ;
---
>   int resync_after ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
>   bool _bool ;
>   int tmp___1 ;
17783c18127
< #line 1416
---
> #line 1431
17785,17788c18129,18132
<   ldv_51731: ;
< #line 1419
<   if (odev->sync_conf.after == -1) {
< #line 1420
---
>   ldv_52229: ;
> #line 1435
>   if ((unsigned long )odev->ldev == (unsigned long )((struct drbd_backing_dev *)0)) {
> #line 1436
17793,17802c18137,18156
< #line 1421
<   odev = minor_to_mdev((unsigned int )odev->sync_conf.after);
< #line 1422
<   _b = (unsigned long )odev == (unsigned long )((struct drbd_conf *)0);
< #line 1422
<   if (_b != 0) {
< #line 1422
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "_drbd_may_sync_now", (char *)"!odev", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<             1422);
---
> #line 1437
>   rcu_read_lock();
> #line 1438
>   _________p1 = *((struct disk_conf * volatile  *)(& (odev->ldev)->disk_conf));
> #line 1438
>   tmp = debug_lockdep_rcu_enabled();
> #line 1438
>   if (tmp != 0 && ! __warned) {
> #line 1438
>     tmp___0 = rcu_read_lock_held();
> #line 1438
>     if (tmp___0 == 0 && 1) {
> #line 1438
>       __warned = 1;
> #line 1438
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                              1438, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
17806,17808c18160,18166
< #line 1422
<   if (_b != 0) {
< #line 1422
---
> #line 1438
>   resync_after = _________p1->resync_after;
> #line 1439
>   rcu_read_unlock();
> #line 1440
>   if (resync_after == -1) {
> #line 1441
17813,17815c18171,18200
< #line 1423
<   if (((((int )odev->state.ldv_40583.conn > 15 && (int )odev->state.ldv_40583.conn <= 21) || (unsigned int )*((unsigned char *)odev + 2278UL) != 0U) || (unsigned int )*((unsigned char *)odev + 2278UL) != 0U) || (unsigned int )*((unsigned char *)odev + 2278UL) != 0U) {
< #line 1427
---
> #line 1442
>   odev = minor_to_mdev((unsigned int )resync_after);
> #line 1443
>   _bool = (unsigned long )odev != (unsigned long )((struct drbd_conf *)0);
> #line 1443
>   if (! _bool) {
> #line 1443
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"odev", "_drbd_may_sync_now");
>   } else {
> 
>   }
> #line 1443
>   if (_bool) {
> #line 1443
>     tmp___1 = 0;
>   } else {
> #line 1443
>     tmp___1 = 1;
>   }
> #line 1443
>   if (tmp___1) {
> #line 1444
>     return (1);
>   } else {
> 
>   }
> #line 1445
>   if (((((int )odev->state.ldv_50103.conn > 15 && (int )odev->state.ldv_50103.conn <= 21) || (unsigned int )*((unsigned char *)odev + 750UL) != 0U) || (unsigned int )*((unsigned char *)odev + 750UL) != 0U) || (unsigned int )*((unsigned char *)odev + 750UL) != 0U) {
> #line 1449
17820,17821c18205,18206
< #line 1428
<   goto ldv_51731;
---
> #line 1450
>   goto ldv_52229;
17824c18209
< #line 1437 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 1459 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
17829a18215
>   void *tmp ;
17831,17832c18217,18219
<   enum drbd_state_rv tmp ;
<   int tmp___0 ;
---
>   enum drbd_state_rv tmp___0 ;
>   int tmp___1 ;
>   void *tmp___2 ;
17835c18222
< #line 1440
---
> #line 1462
17837c18224,18226
< #line 1442
---
> #line 1464
>   rcu_read_lock();
> #line 1465
17839,17854c18228,18238
< #line 1442
<   goto ldv_51742;
<   ldv_51741: 
< #line 1443
<   odev = minor_to_mdev((unsigned int )i);
< #line 1444
<   if ((unsigned long )odev == (unsigned long )((struct drbd_conf *)0)) {
< #line 1445
<     goto ldv_51738;
<   } else {
< 
<   }
< #line 1446
<   if ((unsigned int )*((unsigned short *)odev + 1138UL) == 0U && (unsigned int )*((unsigned char *)odev + 2277UL) == 0U) {
< #line 1447
<     goto ldv_51738;
---
> #line 1465
>   tmp = idr_get_next(& minors, & i);
> #line 1465
>   odev = (struct drbd_conf *)tmp;
> #line 1465
>   goto ldv_52240;
>   ldv_52239: ;
> #line 1466
>   if ((unsigned int )*((unsigned short *)odev + 374UL) == 0U && (unsigned int )*((unsigned char *)odev + 749UL) == 0U) {
> #line 1467
>     goto ldv_52236;
17858,17869c18242,18253
< #line 1448
<   tmp___0 = _drbd_may_sync_now(odev);
< #line 1448
<   if (tmp___0 == 0) {
< #line 1449
<     __ns.i = odev->state.i;
< #line 1449
<     __ns.ldv_40583.aftr_isp = 1U;
< #line 1449
<     tmp = __drbd_set_state(odev, __ns, CS_HARD, 0);
< #line 1449
<     rv = ((int )tmp != 2) | rv;
---
> #line 1468
>   tmp___1 = _drbd_may_sync_now(odev);
> #line 1468
>   if (tmp___1 == 0) {
> #line 1469
>     __ns = drbd_read_state(odev);
> #line 1469
>     __ns.ldv_40604.aftr_isp = 1U;
> #line 1469
>     tmp___0 = __drbd_set_state(odev, __ns, CS_HARD, 0);
> #line 1469
>     rv = ((int )tmp___0 != 2) | rv;
17873,17874c18257,18258
<   ldv_51738: 
< #line 1442
---
>   ldv_52236: 
> #line 1465
17876,17880c18260,18268
<   ldv_51742: ;
< #line 1442
<   if ((unsigned int )i < minor_count) {
< #line 1443
<     goto ldv_51741;
---
> #line 1465
>   tmp___2 = idr_get_next(& minors, & i);
> #line 1465
>   odev = (struct drbd_conf *)tmp___2;
>   ldv_52240: ;
> #line 1465
>   if ((unsigned long )odev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1466
>     goto ldv_52239;
17884,17885c18272,18274
< 
< #line 1453
---
> #line 1472
>   rcu_read_unlock();
> #line 1474
17889c18278
< #line 1462 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 1483 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
17894a18284
>   void *tmp ;
17896,17897c18286,18288
<   enum drbd_state_rv tmp ;
<   int tmp___0 ;
---
>   enum drbd_state_rv tmp___0 ;
>   int tmp___1 ;
>   void *tmp___2 ;
17900c18291
< #line 1465
---
> #line 1486
17902c18293,18295
< #line 1467
---
> #line 1488
>   rcu_read_lock();
> #line 1489
17904,17919c18297,18307
< #line 1467
<   goto ldv_51754;
<   ldv_51753: 
< #line 1468
<   odev = minor_to_mdev((unsigned int )i);
< #line 1469
<   if ((unsigned long )odev == (unsigned long )((struct drbd_conf *)0)) {
< #line 1470
<     goto ldv_51750;
<   } else {
< 
<   }
< #line 1471
<   if ((unsigned int )*((unsigned short *)odev + 1138UL) == 0U && (unsigned int )*((unsigned char *)odev + 2277UL) == 0U) {
< #line 1472
<     goto ldv_51750;
---
> #line 1489
>   tmp = idr_get_next(& minors, & i);
> #line 1489
>   odev = (struct drbd_conf *)tmp;
> #line 1489
>   goto ldv_52252;
>   ldv_52251: ;
> #line 1490
>   if ((unsigned int )*((unsigned short *)odev + 374UL) == 0U && (unsigned int )*((unsigned char *)odev + 749UL) == 0U) {
> #line 1491
>     goto ldv_52248;
17923,17936c18311,18324
< #line 1473
<   if ((unsigned int )*((unsigned char *)odev + 2278UL) != 0U) {
< #line 1474
<     tmp___0 = _drbd_may_sync_now(odev);
< #line 1474
<     if (tmp___0 != 0) {
< #line 1475
<       __ns.i = odev->state.i;
< #line 1475
<       __ns.ldv_40583.aftr_isp = 0U;
< #line 1475
<       tmp = __drbd_set_state(odev, __ns, CS_HARD, 0);
< #line 1475
<       rv = ((int )tmp != 2) | rv;
---
> #line 1492
>   if ((unsigned int )*((unsigned char *)odev + 750UL) != 0U) {
> #line 1493
>     tmp___1 = _drbd_may_sync_now(odev);
> #line 1493
>     if (tmp___1 != 0) {
> #line 1494
>       __ns = drbd_read_state(odev);
> #line 1494
>       __ns.ldv_40604.aftr_isp = 0U;
> #line 1494
>       tmp___0 = __drbd_set_state(odev, __ns, CS_HARD, 0);
> #line 1494
>       rv = ((int )tmp___0 != 2) | rv;
17943,17944c18331,18332
<   ldv_51750: 
< #line 1467
---
>   ldv_52248: 
> #line 1489
17946,17950c18334,18342
<   ldv_51754: ;
< #line 1467
<   if ((unsigned int )i < minor_count) {
< #line 1468
<     goto ldv_51753;
---
> #line 1489
>   tmp___2 = idr_get_next(& minors, & i);
> #line 1489
>   odev = (struct drbd_conf *)tmp___2;
>   ldv_52252: ;
> #line 1489
>   if ((unsigned long )odev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1490
>     goto ldv_52251;
17954,17955c18346,18348
< 
< #line 1480
---
> #line 1499
>   rcu_read_unlock();
> #line 1500
17959c18352
< #line 1483 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 1503 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
17965c18358
< #line 1485
---
> #line 1505
17967c18360
< #line 1486
---
> #line 1506
17969c18362
< #line 1487
---
> #line 1507
17971c18364
< #line 1488
---
> #line 1508
17975c18368
< #line 1490 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 1510 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
17981c18374
< #line 1492
---
> #line 1512
17983c18376
< #line 1493
---
> #line 1513
17985c18378
< #line 1494
---
> #line 1514
17987c18380
< #line 1495
---
> #line 1515
17991,17992c18384,18385
< #line 1497 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< static int sync_after_error(struct drbd_conf *mdev , int o_minor ) 
---
> #line 1518 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> enum drbd_ret_code drbd_resync_after_valid(struct drbd_conf *mdev , int o_minor ) 
17994a18388
>   int resync_after ;
17995a18390,18393
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___0 ;
>   int tmp___1 ;
17998c18396
< #line 1501
---
> #line 1523
18000,18001c18398,18399
< #line 1502
<     return (101);
---
> #line 1524
>     return (NO_ERROR);
18005c18403
< #line 1503
---
> #line 1525
18007,18008c18405,18406
< #line 1504
<     return (132);
---
> #line 1526
>     return (ERR_RESYNC_AFTER);
18010c18408
< #line 1503
---
> #line 1525
18012c18410
< #line 1503
---
> #line 1525
18014,18015c18412,18413
< #line 1504
<       return (132);
---
> #line 1526
>       return (ERR_RESYNC_AFTER);
18020c18418
< #line 1507
---
> #line 1529
18022,18023c18420,18421
<   ldv_51767: ;
< #line 1509
---
>   ldv_52269: ;
> #line 1531
18025,18026c18423,18424
< #line 1510
<     return (133);
---
> #line 1532
>     return (ERR_RESYNC_AFTER_CYCLE);
18030,18033c18428,18447
< #line 1513
<   if (odev->sync_conf.after == -1) {
< #line 1514
<     return (101);
---
> #line 1534
>   rcu_read_lock();
> #line 1535
>   _________p1 = *((struct disk_conf * volatile  *)(& (odev->ldev)->disk_conf));
> #line 1535
>   tmp___0 = debug_lockdep_rcu_enabled();
> #line 1535
>   if (tmp___0 != 0 && ! __warned) {
> #line 1535
>     tmp___1 = rcu_read_lock_held();
> #line 1535
>     if (tmp___1 == 0 && 1) {
> #line 1535
>       __warned = 1;
> #line 1535
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                              1535, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
18037,18040c18451,18465
< #line 1517
<   odev = minor_to_mdev((unsigned int )odev->sync_conf.after);
< #line 1518
<   goto ldv_51767;
---
> #line 1535
>   resync_after = _________p1->resync_after;
> #line 1536
>   rcu_read_unlock();
> #line 1538
>   if (resync_after == -1) {
> #line 1539
>     return (NO_ERROR);
>   } else {
> 
>   }
> #line 1542
>   odev = minor_to_mdev((unsigned int )resync_after);
> #line 1543
>   goto ldv_52269;
18043,18044c18468,18469
< #line 1521 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int drbd_alter_sa(struct drbd_conf *mdev , int na ) 
---
> #line 1547 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> void drbd_resync_after_changed(struct drbd_conf *mdev ) 
18047d18471
<   int retcode ;
18051,18073c18475,18485
< #line 1526
<   _raw_write_lock_irq(& global_state_lock);
< #line 1527
<   retcode = sync_after_error(mdev, na);
< #line 1528
<   if (retcode == 101) {
< #line 1529
<     mdev->sync_conf.after = na;
<     ldv_51774: 
< #line 1531
<     changes = _drbd_pause_after(mdev);
< #line 1532
<     tmp = _drbd_resume_next(mdev);
< #line 1532
<     changes = tmp | changes;
< #line 1533
<     if (changes != 0) {
< #line 1534
<       goto ldv_51774;
<     } else {
< 
<     }
< 
---
>   ldv_52274: 
> #line 1552
>   changes = _drbd_pause_after(mdev);
> #line 1553
>   tmp = _drbd_resume_next(mdev);
> #line 1553
>   changes = tmp | changes;
> #line 1554
>   if (changes != 0) {
> #line 1555
>     goto ldv_52274;
18077,18080c18489,18491
< #line 1535
<   _raw_write_unlock_irq(& global_state_lock);
< #line 1536
<   return (retcode);
---
> 
> #line 1559
>   return;
18083c18494
< #line 1539 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 1557 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
18086c18497,18501
< 
---
>   struct fifo_buffer *plan ;
>   struct fifo_buffer *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
18089c18504
< #line 1541
---
> #line 1561
18091c18506
< #line 1542
---
> #line 1562
18093c18508
< #line 1543
---
> #line 1563
18095,18103c18510,18555
< #line 1544
<   mdev->rs_planed = 0;
< #line 1545
<   spin_lock(& mdev->peer_seq_lock);
< #line 1546
<   fifo_set(& mdev->rs_plan_s, 0);
< #line 1547
<   spin_unlock(& mdev->peer_seq_lock);
< #line 1548
---
> #line 1569
>   rcu_read_lock();
> #line 1570
>   _________p1 = *((struct fifo_buffer * volatile  *)(& mdev->rs_plan_s));
> #line 1570
>   tmp = debug_lockdep_rcu_enabled();
> #line 1570
>   if (tmp != 0 && ! __warned) {
> #line 1570
>     tmp___0 = rcu_read_lock_held();
> #line 1570
>     if (tmp___0 == 0 && 1) {
> #line 1570
>       __warned = 1;
> #line 1570
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                              1570, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1570
>   plan = _________p1;
> #line 1571
>   plan->total = 0;
> #line 1572
>   fifo_set(plan, 0);
> #line 1573
>   rcu_read_unlock();
> #line 1574
>   return;
> }
> }
> #line 1576 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> void start_resync_timer_fn(unsigned long data ) 
> { 
>   struct drbd_conf *mdev ;
> 
>   {
> #line 1578
>   mdev = (struct drbd_conf *)data;
> #line 1580
>   drbd_queue_work(& (mdev->tconn)->sender_work, & mdev->start_resync_work);
> #line 1581
18107c18559,18606
< #line 1558 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
---
> #line 1583 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int w_start_resync(struct drbd_work *w , int cancel ) 
> { 
>   struct drbd_conf *mdev ;
>   int tmp ;
>   int tmp___0 ;
> 
>   {
> #line 1585
>   mdev = w->ldv_50388.mdev;
> #line 1587
>   tmp = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
> #line 1587
>   if (tmp != 0) {
> #line 1588
>     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "w_start_resync later...\n");
> #line 1589
>     mdev->start_resync_timer.expires = (unsigned long )jiffies + 25UL;
> #line 1590
>     add_timer(& mdev->start_resync_timer);
> #line 1591
>     return (0);
>   } else {
> #line 1587
>     tmp___0 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
> #line 1587
>     if (tmp___0 != 0) {
> #line 1588
>       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "w_start_resync later...\n");
> #line 1589
>       mdev->start_resync_timer.expires = (unsigned long )jiffies + 25UL;
> #line 1590
>       add_timer(& mdev->start_resync_timer);
> #line 1591
>       return (0);
>     } else {
> 
>     }
>   }
> #line 1594
>   drbd_start_resync(mdev, C_SYNC_SOURCE);
> #line 1595
>   clear_bit(19, (unsigned long volatile   *)(& mdev->flags));
> #line 1596
>   return (0);
> }
> }
> #line 1607 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
18118c18617,18620
<   enum drbd_state_rv tmp___1 ;
---
>   struct task_struct *tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
>   enum drbd_state_rv tmp___4 ;
18120c18622
<   unsigned long tmp___2 ;
---
>   unsigned long tmp___5 ;
18123c18625,18631
<   char const   *tmp___3 ;
---
>   char const   *tmp___6 ;
>   struct net_conf *nc ;
>   int timeo ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___7 ;
>   int tmp___8 ;
18126,18128c18634,18636
< #line 1563
<   if ((int )mdev->state.ldv_40583.conn > 15 && (int )mdev->state.ldv_40583.conn <= 21) {
< #line 1564
---
> #line 1612
>   if ((int )mdev->state.ldv_50103.conn > 15 && (int )mdev->state.ldv_50103.conn <= 21) {
> #line 1613
18130c18638
< #line 1565
---
> #line 1614
18135,18175c18643,18656
< #line 1568
<   if ((unsigned int )side == 17U) {
< #line 1572
<     r = drbd_khelper(mdev, (char *)"before-resync-target");
< #line 1573
<     r = (r >> 8) & 255;
< #line 1574
<     if (r > 0) {
< #line 1575
<       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "before-resync-target handler returned %d, dropping connection.\n",
<                 r);
< #line 1577
<       val.i = 0U;
< #line 1577
<       val.ldv_40583.conn = 1U;
< #line 1577
<       mask.i = 0U;
< #line 1577
<       mask.ldv_40583.conn = 31U;
< #line 1577
<       drbd_force_state(mdev, mask, val);
< #line 1578
<       return;
<     } else {
< 
<     }
<   } else {
< #line 1581
<     r = drbd_khelper(mdev, (char *)"before-resync-source");
< #line 1582
<     r = (r >> 8) & 255;
< #line 1583
<     if (r > 0) {
< #line 1584
<       if (r == 3) {
< #line 1585
<         _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "before-resync-source handler returned %d, ignoring. Old userland tools?",
<                   r);
<       } else {
< #line 1588
<         _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "before-resync-source handler returned %d, dropping connection.\n",
---
> #line 1617
>   tmp = constant_test_bit(20U, (unsigned long const volatile   *)(& mdev->flags));
> #line 1617
>   if (tmp == 0) {
> #line 1618
>     if ((unsigned int )side == 17U) {
> #line 1622
>       r = drbd_khelper(mdev, (char *)"before-resync-target");
> #line 1623
>       r = (r >> 8) & 255;
> #line 1624
>       if (r > 0) {
> #line 1625
>         _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "before-resync-target handler returned %d, dropping connection.\n",
18177,18187c18658,18668
< #line 1590
<         val___0.i = 0U;
< #line 1590
<         val___0.ldv_40583.conn = 1U;
< #line 1590
<         mask___0.i = 0U;
< #line 1590
<         mask___0.ldv_40583.conn = 31U;
< #line 1590
<         drbd_force_state(mdev, mask___0, val___0);
< #line 1591
---
> #line 1627
>         val.i = 0U;
> #line 1627
>         val.ldv_40604.conn = 1U;
> #line 1627
>         mask.i = 0U;
> #line 1627
>         mask.ldv_40604.conn = 31U;
> #line 1627
>         conn_request_state(mdev->tconn, mask, val, CS_HARD);
> #line 1628
18188a18670,18671
>       } else {
> 
18190a18674,18702
> #line 1631
>       r = drbd_khelper(mdev, (char *)"before-resync-source");
> #line 1632
>       r = (r >> 8) & 255;
> #line 1633
>       if (r > 0) {
> #line 1634
>         if (r == 3) {
> #line 1635
>           _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "before-resync-source handler returned %d, ignoring. Old userland tools?",
>                     r);
>         } else {
> #line 1638
>           _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "before-resync-source handler returned %d, dropping connection.\n",
>                     r);
> #line 1640
>           val___0.i = 0U;
> #line 1640
>           val___0.ldv_40604.conn = 1U;
> #line 1640
>           mask___0.i = 0U;
> #line 1640
>           mask___0.ldv_40604.conn = 31U;
> #line 1640
>           conn_request_state(mdev->tconn, mask___0, val___0, CS_HARD);
> #line 1641
>           return;
>         }
>       } else {
18191a18704
>       }
18192a18706,18707
>   } else {
> 
18194,18196c18709,18734
< #line 1596
<   drbd_state_lock(mdev);
< #line 1597
---
> #line 1647
>   tmp___1 = get_current();
> #line 1647
>   if ((unsigned long )tmp___1 == (unsigned long )(mdev->tconn)->worker.task) {
> #line 1650
>     tmp___0 = mutex_trylock(mdev->state_mutex);
> #line 1650
>     if (tmp___0 == 0) {
> #line 1651
>       set_bit(20U, (unsigned long volatile   *)(& mdev->flags));
> #line 1652
>       mdev->start_resync_timer.expires = (unsigned long )jiffies + 50UL;
> #line 1653
>       add_timer(& mdev->start_resync_timer);
> #line 1654
>       return;
>     } else {
> #line 1657
>       mutex_lock_nested(mdev->state_mutex, 0U);
>     }
>   } else {
> 
>   }
> #line 1659
>   clear_bit(20, (unsigned long volatile   *)(& mdev->flags));
> #line 1661
18198,18202c18736,18740
< #line 1598
<   tmp = _get_ldev_if_state(mdev, D_NEGOTIATING);
< #line 1598
<   if (tmp == 0) {
< #line 1599
---
> #line 1662
>   tmp___2 = _get_ldev_if_state(mdev, D_NEGOTIATING);
> #line 1662
>   if (tmp___2 == 0) {
> #line 1663
18204,18206c18742,18744
< #line 1600
<     drbd_state_unlock(mdev);
< #line 1601
---
> #line 1664
>     mutex_unlock(mdev->state_mutex);
> #line 1665
18211,18219c18749,18757
< #line 1604
<   ns.i = mdev->state.i;
< #line 1606
<   tmp___0 = _drbd_may_sync_now(mdev);
< #line 1606
<   ns.ldv_40583.aftr_isp = tmp___0 == 0;
< #line 1608
<   ns.ldv_40583.conn = (unsigned char )side;
< #line 1610
---
> #line 1668
>   ns = drbd_read_state(mdev);
> #line 1670
>   tmp___3 = _drbd_may_sync_now(mdev);
> #line 1670
>   ns.ldv_40604.aftr_isp = tmp___3 == 0;
> #line 1672
>   ns.ldv_40604.conn = (unsigned char )side;
> #line 1674
18221,18222c18759,18760
< #line 1611
<     ns.ldv_40583.disk = 4U;
---
> #line 1675
>     ns.ldv_40604.disk = 4U;
18224,18225c18762,18763
< #line 1613
<     ns.ldv_40583.pdsk = 4U;
---
> #line 1677
>     ns.ldv_40604.pdsk = 4U;
18227,18235c18765,18773
< #line 1615
<   tmp___1 = __drbd_set_state(mdev, ns, CS_VERBOSE, 0);
< #line 1615
<   r = (int )tmp___1;
< #line 1616
<   ns = mdev->state;
< #line 1618
<   if ((int )ns.ldv_40583.conn <= 9) {
< #line 1619
---
> #line 1679
>   tmp___4 = __drbd_set_state(mdev, ns, CS_VERBOSE, 0);
> #line 1679
>   r = (int )tmp___4;
> #line 1680
>   ns = drbd_read_state(mdev);
> #line 1682
>   if ((int )ns.ldv_40604.conn <= 9) {
> #line 1683
18240c18778
< #line 1621
---
> #line 1685
18242,18246c18780,18784
< #line 1622
<     tmp___2 = drbd_bm_total_weight(mdev);
< #line 1622
<     tw = tmp___2;
< #line 1623
---
> #line 1686
>     tmp___5 = drbd_bm_total_weight(mdev);
> #line 1686
>     tw = tmp___5;
> #line 1687
18248c18786
< #line 1626
---
> #line 1690
18250c18788
< #line 1627
---
> #line 1691
18252c18790
< #line 1628
---
> #line 1692
18254c18792
< #line 1629
---
> #line 1693
18256c18794
< #line 1630
---
> #line 1694
18258c18796
< #line 1631
---
> #line 1695
18260c18798
< #line 1632
---
> #line 1696
18262c18800
< #line 1633
---
> #line 1697
18264,18267c18802,18805
< #line 1633
<     goto ldv_51797;
<     ldv_51796: 
< #line 1634
---
> #line 1697
>     goto ldv_52310;
>     ldv_52309: 
> #line 1698
18269c18807
< #line 1635
---
> #line 1699
18271c18809
< #line 1633
---
> #line 1697
18273,18274c18811,18812
<     ldv_51797: ;
< #line 1633
---
>     ldv_52310: ;
> #line 1697
18276,18277c18814,18815
< #line 1634
<       goto ldv_51796;
---
> #line 1698
>       goto ldv_52309;
18281c18819
< #line 1637
---
> #line 1701
18286c18824
< #line 1639
---
> #line 1703
18288c18826
< #line 1641
---
> #line 1705
18290,18292c18828,18832
< #line 1642
<     tmp___3 = drbd_conn_str((enum drbd_conns )ns.ldv_40583.conn);
< #line 1642
---
> #line 1708
>     mdev->rs_last_bcast = (unsigned long )jiffies - 250UL;
> #line 1710
>     tmp___6 = drbd_conn_str((enum drbd_conns )ns.ldv_40604.conn);
> #line 1710
18294,18295c18834,18835
<               tmp___3, mdev->rs_total << 2, mdev->rs_total);
< #line 1646
---
>               tmp___6, mdev->rs_total << 2, mdev->rs_total);
> #line 1714
18297c18837
< #line 1647
---
> #line 1715
18302,18304c18842,18844
< #line 1656
<     if ((unsigned int )side == 16U && mdev->agreed_pro_version <= 95) {
< #line 1657
---
> #line 1724
>     if ((unsigned int )side == 16U && (mdev->tconn)->agreed_pro_version <= 95) {
> #line 1725
18309,18311c18849,18851
< #line 1659
<     if (mdev->agreed_pro_version <= 94 && mdev->rs_total == 0UL) {
< #line 1670
---
> #line 1727
>     if ((mdev->tconn)->agreed_pro_version <= 94 && mdev->rs_total == 0UL) {
> #line 1738
18313,18314c18853,18883
< #line 1671
<         schedule_timeout_interruptible((long )((mdev->net_conf)->ping_int * 250 + ((mdev->net_conf)->ping_timeo * 250) / 9));
---
> #line 1742
>         rcu_read_lock();
> #line 1743
>         _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 1743
>         tmp___7 = debug_lockdep_rcu_enabled();
> #line 1743
>         if (tmp___7 != 0 && ! __warned) {
> #line 1743
>           tmp___8 = rcu_read_lock_held();
> #line 1743
>           if (tmp___8 == 0 && 1) {
> #line 1743
>             __warned = 1;
> #line 1743
>             lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                                    1743, "suspicious rcu_dereference_check() usage");
>           } else {
> 
>           }
>         } else {
> 
>         }
> #line 1743
>         nc = _________p1;
> #line 1744
>         timeo = (int )(nc->ping_int * 250U + (nc->ping_timeo * 250U) / 9U);
> #line 1745
>         rcu_read_unlock();
> #line 1746
>         schedule_timeout_interruptible((long )timeo);
18318c18887
< #line 1674
---
> #line 1748
18323c18892
< #line 1677
---
> #line 1751
18325c18894
< #line 1682
---
> #line 1756
18327c18896
< #line 1683
---
> #line 1757
18332c18901
< #line 1685
---
> #line 1759
18337c18906
< #line 1687
---
> #line 1761
18339,18341c18908,18910
< #line 1688
<   drbd_state_unlock(mdev);
< #line 1689
---
> #line 1762
>   mutex_unlock(mdev->state_mutex);
> #line 1763
18345,18346c18914,18915
< #line 1691 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
< int drbd_worker(struct drbd_thread *thi ) 
---
> #line 1769 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> bool need_to_send_barrier(struct drbd_tconn *connection ) 
18348,18354c18917,19001
<   struct drbd_conf *mdev ;
<   struct drbd_work *w ;
<   struct list_head work_list ;
<   int intr ;
<   int i ;
<   unsigned int tmp ;
<   struct task_struct *tmp___0 ;
---
>   int tmp ;
> 
>   {
> #line 1771
>   if (! connection->send.seen_any_write_yet) {
> #line 1772
>     return (0);
>   } else {
> 
>   }
> #line 1776
>   if (connection->send.current_epoch_writes == 0U) {
> #line 1777
>     return (0);
>   } else {
> 
>   }
> #line 1786
>   tmp = atomic_read((atomic_t const   *)(& connection->current_tle_nr));
> #line 1786
>   if (tmp != connection->send.current_epoch_nr + 1) {
> #line 1788
>     return (0);
>   } else {
> 
>   }
> #line 1790
>   return (1);
> }
> }
> #line 1793 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> bool dequeue_work_batch(struct drbd_work_queue *queue , struct list_head *work_list ) 
> { 
>   int tmp ;
> 
>   {
> #line 1795
>   spin_lock_irq(& queue->q_lock);
> #line 1796
>   list_splice_init(& queue->q, work_list);
> #line 1797
>   spin_unlock_irq(& queue->q_lock);
> #line 1798
>   tmp = list_empty((struct list_head  const  *)work_list);
> #line 1798
>   return (tmp == 0);
> }
> }
> #line 1801 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> bool dequeue_work_item(struct drbd_work_queue *queue , struct list_head *work_list ) 
> { 
>   int tmp ;
>   int tmp___0 ;
> 
>   {
> #line 1803
>   spin_lock_irq(& queue->q_lock);
> #line 1804
>   tmp = list_empty((struct list_head  const  *)(& queue->q));
> #line 1804
>   if (tmp == 0) {
> #line 1805
>     list_move(queue->q.next, work_list);
>   } else {
> 
>   }
> #line 1806
>   spin_unlock_irq(& queue->q_lock);
> #line 1807
>   tmp___0 = list_empty((struct list_head  const  *)work_list);
> #line 1807
>   return (tmp___0 == 0);
> }
> }
> #line 1810 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> void wait_for_work(struct drbd_tconn *connection , struct list_head *work_list ) 
> { 
>   wait_queue_t wait ;
>   struct task_struct *tmp ;
>   struct net_conf *nc ;
>   int uncork ;
>   int cork ;
>   int tmp___0 ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
18356,18364c19003,19007
<   struct task_struct *tmp___2 ;
<   int _b ;
<   enum drbd_thread_state tmp___3 ;
<   enum drbd_thread_state tmp___4 ;
<   int _b___0 ;
<   int tmp___5 ;
<   struct list_head  const  *__mptr ;
<   union drbd_state val ;
<   union drbd_state mask ;
---
>   int tmp___2 ;
>   int send_barrier ;
>   int tmp___3 ;
>   int tmp___4 ;
>   struct task_struct *tmp___5 ;
18366c19009,19011
<   enum drbd_thread_state tmp___7 ;
---
>   bool tmp___7 ;
>   struct net_conf *_________p1___0 ;
>   bool __warned___0 ;
18369,18371d19013
<   struct list_head  const  *__mptr___0 ;
<   int tmp___10 ;
<   int tmp___11 ;
18374,18404c19016,19055
< #line 1693
<   mdev = thi->mdev;
< #line 1694
<   w = 0;
< #line 1695
<   work_list.next = & work_list;
< #line 1695
<   work_list.prev = & work_list;
< #line 1696
<   intr = 0;
< #line 1698
<   tmp = mdev_to_minor(mdev);
< #line 1698
<   tmp___0 = get_current();
< #line 1698
<   sprintf((char *)(& tmp___0->comm), "drbd%d_worker", tmp);
< #line 1700
<   goto ldv_51810;
<   ldv_51820: 
< #line 1701
<   drbd_thread_current_set_cpu(mdev);
< #line 1703
<   tmp___1 = down_trylock(& mdev->data.work.s);
< #line 1703
<   if (tmp___1 != 0) {
< #line 1704
<     mutex_lock_nested(& mdev->data.mutex, 0U);
< #line 1705
<     if ((unsigned long )mdev->data.socket != (unsigned long )((struct socket *)0) && (unsigned int )*((unsigned char *)mdev->net_conf + 540UL) == 0U) {
< #line 1706
<       drbd_tcp_uncork(mdev->data.socket);
---
> #line 1812
>   tmp = get_current();
> #line 1812
>   wait.flags = 0U;
> #line 1812
>   wait.private = (void *)tmp;
> #line 1812
>   wait.func = & autoremove_wake_function;
> #line 1812
>   wait.task_list.next = & wait.task_list;
> #line 1812
>   wait.task_list.prev = & wait.task_list;
> #line 1816
>   dequeue_work_item(& connection->sender_work, work_list);
> #line 1817
>   tmp___0 = list_empty((struct list_head  const  *)work_list);
> #line 1817
>   if (tmp___0 == 0) {
> #line 1818
>     return;
>   } else {
> 
>   }
> #line 1826
>   rcu_read_lock();
> #line 1827
>   _________p1 = *((struct net_conf * volatile  *)(& connection->net_conf));
> #line 1827
>   tmp___1 = debug_lockdep_rcu_enabled();
> #line 1827
>   if (tmp___1 != 0 && ! __warned) {
> #line 1827
>     tmp___2 = rcu_read_lock_held();
> #line 1827
>     if (tmp___2 == 0 && 1) {
> #line 1827
>       __warned = 1;
> #line 1827
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                              1827, "suspicious rcu_dereference_check() usage");
18408,18417c19059,19075
< #line 1707
<     mutex_unlock(& mdev->data.mutex);
< #line 1709
<     intr = down_interruptible(& mdev->data.work.s);
< #line 1711
<     mutex_lock_nested(& mdev->data.mutex, 0U);
< #line 1712
<     if ((unsigned long )mdev->data.socket != (unsigned long )((struct socket *)0) && (unsigned int )*((unsigned char *)mdev->net_conf + 540UL) == 0U) {
< #line 1713
<       drbd_tcp_cork(mdev->data.socket);
---
>   } else {
> 
>   }
> #line 1827
>   nc = _________p1;
> #line 1828
>   uncork = (unsigned long )nc != (unsigned long )((struct net_conf *)0) ? (int )nc->tcp_cork : 0;
> #line 1829
>   rcu_read_unlock();
> #line 1830
>   if (uncork != 0) {
> #line 1831
>     mutex_lock_nested(& connection->data.mutex, 0U);
> #line 1832
>     if ((unsigned long )connection->data.socket != (unsigned long )((struct socket *)0)) {
> #line 1833
>       drbd_tcp_uncork(connection->data.socket);
18421,18422c19079,19080
< #line 1714
<     mutex_unlock(& mdev->data.mutex);
---
> #line 1834
>     mutex_unlock(& connection->data.mutex);
18426,18433c19084,19120
< #line 1717
<   if (intr != 0) {
< #line 1718
<     if (intr != -4) {
< #line 1718
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( intr == -EINTR ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<               1718);
---
>   ldv_52341: 
> #line 1839
>   prepare_to_wait(& connection->sender_work.q_wait, & wait, 1);
> #line 1840
>   spin_lock_irq(& connection->req_lock);
> #line 1841
>   spin_lock(& connection->sender_work.q_lock);
> #line 1844
>   tmp___3 = list_empty((struct list_head  const  *)(& connection->sender_work.q));
> #line 1844
>   if (tmp___3 == 0) {
> #line 1845
>     list_move(connection->sender_work.q.next, work_list);
>   } else {
> 
>   }
> #line 1846
>   spin_unlock(& connection->sender_work.q_lock);
> #line 1847
>   tmp___4 = list_empty((struct list_head  const  *)work_list);
> #line 1847
>   if (tmp___4 == 0) {
> #line 1848
>     spin_unlock_irq(& connection->req_lock);
> #line 1849
>     goto ldv_52340;
>   } else {
> #line 1847
>     tmp___5 = get_current();
> #line 1847
>     tmp___6 = signal_pending(tmp___5);
> #line 1847
>     if (tmp___6 != 0) {
> #line 1848
>       spin_unlock_irq(& connection->req_lock);
> #line 1849
>       goto ldv_52340;
18437,18450c19124,19163
< #line 1719
<     tmp___2 = get_current();
< #line 1719
<     flush_signals(tmp___2);
< #line 1720
<     tmp___3 = get_t_state(thi);
< #line 1720
<     _b = (unsigned int )tmp___3 == 1U;
< #line 1720
<     if (_b != 0) {
< #line 1720
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<               "drbd_worker", (char *)"get_t_state(thi) == Running", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<               1720);
---
>   }
> #line 1851
>   tmp___7 = need_to_send_barrier(connection);
> #line 1851
>   send_barrier = (int )tmp___7;
> #line 1852
>   spin_unlock_irq(& connection->req_lock);
> #line 1853
>   if (send_barrier != 0) {
> #line 1854
>     drbd_send_barrier(connection);
> #line 1855
>     connection->send.current_epoch_nr = connection->send.current_epoch_nr + 1;
>   } else {
> 
>   }
> #line 1857
>   schedule();
> #line 1861
>   goto ldv_52341;
>   ldv_52340: 
> #line 1862
>   finish_wait(& connection->sender_work.q_wait, & wait);
> #line 1865
>   rcu_read_lock();
> #line 1866
>   _________p1___0 = *((struct net_conf * volatile  *)(& connection->net_conf));
> #line 1866
>   tmp___8 = debug_lockdep_rcu_enabled();
> #line 1866
>   if (tmp___8 != 0 && ! __warned___0) {
> #line 1866
>     tmp___9 = rcu_read_lock_held();
> #line 1866
>     if (tmp___9 == 0 && 1) {
> #line 1866
>       __warned___0 = 1;
> #line 1866
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>                              1866, "suspicious rcu_dereference_check() usage");
18454,18457c19167,19188
< #line 1720
<     if (_b != 0) {
< #line 1721
<       goto ldv_51810;
---
>   } else {
> 
>   }
> #line 1866
>   nc = _________p1___0;
> #line 1867
>   cork = (unsigned long )nc != (unsigned long )((struct net_conf *)0) ? (int )nc->tcp_cork : 0;
> #line 1868
>   rcu_read_unlock();
> #line 1869
>   mutex_lock_nested(& connection->data.mutex, 0U);
> #line 1870
>   if ((unsigned long )connection->data.socket != (unsigned long )((struct socket *)0)) {
> #line 1871
>     if (cork != 0) {
> #line 1872
>       drbd_tcp_cork(connection->data.socket);
>     } else
> #line 1873
>     if (uncork == 0) {
> #line 1874
>       drbd_tcp_uncork(connection->data.socket);
18461,18462d19191
< #line 1722
<     goto ldv_51811;
18466,18471c19195,19246
< #line 1725
<   tmp___4 = get_t_state(thi);
< #line 1725
<   if ((unsigned int )tmp___4 != 1U) {
< #line 1726
<     goto ldv_51811;
---
> #line 1876
>   mutex_unlock(& connection->data.mutex);
> #line 1877
>   return;
> }
> }
> #line 1879 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared"
> int drbd_worker(struct drbd_thread *thi ) 
> { 
>   struct drbd_tconn *tconn ;
>   struct drbd_work *w ;
>   struct drbd_conf *mdev ;
>   struct list_head work_list ;
>   int vnr ;
>   int tmp ;
>   struct task_struct *tmp___0 ;
>   enum drbd_thread_state tmp___1 ;
>   struct task_struct *tmp___2 ;
>   int tmp___3 ;
>   enum drbd_thread_state tmp___4 ;
>   struct list_head  const  *__mptr ;
>   int tmp___5 ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   int tmp___6 ;
>   enum drbd_thread_state tmp___7 ;
>   struct list_head  const  *__mptr___0 ;
>   int tmp___8 ;
>   int tmp___9 ;
>   void *tmp___10 ;
>   void *tmp___11 ;
> 
>   {
> #line 1881
>   tconn = thi->tconn;
> #line 1882
>   w = 0;
> #line 1884
>   work_list.next = & work_list;
> #line 1884
>   work_list.prev = & work_list;
> #line 1887
>   goto ldv_52353;
>   ldv_52364: 
> #line 1888
>   drbd_thread_current_set_cpu(thi);
> #line 1892
>   tmp = list_empty((struct list_head  const  *)(& work_list));
> #line 1892
>   if (tmp != 0) {
> #line 1893
>     wait_for_work(tconn, & work_list);
18475,18488c19250,19272
< #line 1731
<   w = 0;
< #line 1732
<   spin_lock_irq(& mdev->data.work.q_lock);
< #line 1733
<   tmp___5 = list_empty((struct list_head  const  *)(& mdev->data.work.q));
< #line 1733
<   _b___0 = tmp___5 != 0;
< #line 1733
<   if (_b___0 != 0) {
< #line 1733
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_worker", (char *)"list_empty(&mdev->data.work.q)", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<             1733);
---
> #line 1895
>   tmp___2 = get_current();
> #line 1895
>   tmp___3 = signal_pending(tmp___2);
> #line 1895
>   if (tmp___3 != 0) {
> #line 1896
>     tmp___0 = get_current();
> #line 1896
>     flush_signals(tmp___0);
> #line 1897
>     tmp___1 = get_t_state(thi);
> #line 1897
>     if ((unsigned int )tmp___1 == 1U) {
> #line 1898
>       printk("\fd-con %s: Worker got an unexpected signal\n", tconn->name);
> #line 1899
>       goto ldv_52353;
>     } else {
> 
>     }
> #line 1901
>     goto ldv_52354;
18492,18497c19276,19281
< #line 1733
<   if (_b___0 != 0) {
< #line 1745
<     spin_unlock_irq(& mdev->data.work.q_lock);
< #line 1746
<     goto ldv_51810;
---
> #line 1904
>   tmp___4 = get_t_state(thi);
> #line 1904
>   if ((unsigned int )tmp___4 != 1U) {
> #line 1905
>     goto ldv_52354;
18501,18503c19285,19290
< #line 1748
<   __mptr = (struct list_head  const  *)mdev->data.work.q.next;
< #line 1748
---
> #line 1907
>   goto ldv_52357;
>   ldv_52362: 
> #line 1908
>   __mptr = (struct list_head  const  *)work_list.next;
> #line 1908
18505c19292
< #line 1749
---
> #line 1909
18507,18527c19294,19299
< #line 1750
<   spin_unlock_irq(& mdev->data.work.q_lock);
< #line 1752
<   tmp___6 = (*(w->cb))(mdev, w, (int )mdev->state.ldv_40583.conn <= 9);
< #line 1752
<   if (tmp___6 == 0) {
< #line 1754
<     if ((int )mdev->state.ldv_40583.conn > 9) {
< #line 1756
<       val.i = 0U;
< #line 1756
<       val.ldv_40583.conn = 5U;
< #line 1756
<       mask.i = 0U;
< #line 1756
<       mask.ldv_40583.conn = 31U;
< #line 1756
<       drbd_force_state(mdev, mask, val);
<     } else {
< 
<     }
---
> #line 1910
>   tmp___5 = (*(w->cb))(w, (unsigned int )tconn->cstate <= 8U);
> #line 1910
>   if (tmp___5 == 0) {
> #line 1911
>     goto ldv_52357;
18531,18537c19303,19314
<   ldv_51810: 
< #line 1700
<   tmp___7 = get_t_state(thi);
< #line 1700
<   if ((unsigned int )tmp___7 == 1U) {
< #line 1701
<     goto ldv_51820;
---
> #line 1912
>   if ((unsigned int )tconn->cstate > 8U) {
> #line 1913
>     val.i = 0U;
> #line 1913
>     val.ldv_40604.conn = 5U;
> #line 1913
>     mask.i = 0U;
> #line 1913
>     mask.ldv_40604.conn = 31U;
> #line 1913
>     conn_request_state(tconn, mask, val, CS_HARD);
18541,18549c19318,19324
<   ldv_51811: 
< #line 1759
<   tmp___8 = drbd_test_flag(mdev, DEVICE_DYING);
< #line 1759
<   if (tmp___8 == 0) {
< #line 1759
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( drbd_test_flag(mdev, DEVICE_DYING) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<             1759);
---
>   ldv_52357: 
> #line 1907
>   tmp___6 = list_empty((struct list_head  const  *)(& work_list));
> #line 1907
>   if (tmp___6 == 0) {
> #line 1908
>     goto ldv_52362;
18553,18560c19328,19335
< #line 1760
<   tmp___9 = drbd_test_flag(mdev, CONFIG_PENDING);
< #line 1760
<   if (tmp___9 == 0) {
< #line 1760
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( drbd_test_flag(mdev, CONFIG_PENDING) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<             1760);
---
> 
>   ldv_52353: 
> #line 1887
>   tmp___7 = get_t_state(thi);
> #line 1887
>   if ((unsigned int )tmp___7 == 1U) {
> #line 1888
>     goto ldv_52364;
18564,18578c19339,19344
< #line 1762
<   spin_lock_irq(& mdev->data.work.q_lock);
< #line 1763
<   i = 0;
< #line 1764
<   goto ldv_51827;
<   ldv_51826: 
< #line 1765
<   list_splice_init(& mdev->data.work.q, & work_list);
< #line 1766
<   spin_unlock_irq(& mdev->data.work.q_lock);
< #line 1768
<   goto ldv_51824;
<   ldv_51823: 
< #line 1769
---
>   ldv_52354: ;
>   ldv_52370: ;
> #line 1918
>   goto ldv_52368;
>   ldv_52367: 
> #line 1919
18580c19346
< #line 1769
---
> #line 1919
18582c19348
< #line 1770
---
> #line 1920
18584,18594c19350,19358
< #line 1771
<   (*(w->cb))(mdev, w, 1);
< #line 1772
<   i = i + 1;
<   ldv_51824: 
< #line 1768
<   tmp___10 = list_empty((struct list_head  const  *)(& work_list));
< #line 1768
<   if (tmp___10 == 0) {
< #line 1769
<     goto ldv_51823;
---
> #line 1921
>   (*(w->cb))(w, 1);
>   ldv_52368: 
> #line 1918
>   tmp___8 = list_empty((struct list_head  const  *)(& work_list));
> #line 1918
>   if (tmp___8 == 0) {
> #line 1919
>     goto ldv_52367;
18598,18606c19362,19369
< #line 1775
<   spin_lock_irq(& mdev->data.work.q_lock);
<   ldv_51827: 
< #line 1764
<   tmp___11 = list_empty((struct list_head  const  *)(& mdev->data.work.q));
< #line 1764
<   if (tmp___11 == 0) {
< #line 1765
<     goto ldv_51826;
---
> #line 1923
>   dequeue_work_batch(& tconn->sender_work, & work_list);
> #line 1924
>   tmp___9 = list_empty((struct list_head  const  *)(& work_list));
> #line 1924
>   if (tmp___9 == 0) {
> #line 1925
>     goto ldv_52370;
18610,18616c19373,19386
< #line 1777
<   sema_init(& mdev->data.work.s, 0);
< #line 1783
<   spin_unlock_irq(& mdev->data.work.q_lock);
< #line 1785
<   if ((unsigned int )*((unsigned char *)mdev + 2277UL) != 0U || (unsigned int )*((unsigned short *)mdev + 1138UL) != 0U) {
< #line 1785
---
> #line 1926
>   rcu_read_lock();
> #line 1927
>   vnr = 0;
> #line 1927
>   tmp___10 = idr_get_next(& tconn->volumes, & vnr);
> #line 1927
>   mdev = (struct drbd_conf *)tmp___10;
> #line 1927
>   goto ldv_52373;
>   ldv_52372: ;
> #line 1928
>   if ((unsigned int )*((unsigned char *)mdev + 749UL) != 0U || (unsigned int )*((unsigned short *)mdev + 374UL) != 0U) {
> #line 1928
18618,18619c19388,19389
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
<             1785);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_worker.c.prepared",
>             1928);
18623,18625c19393,19397
< #line 1788
<   drbd_thread_stop(& mdev->receiver);
< #line 1789
---
> #line 1929
>   kref_get(& mdev->kref);
> #line 1930
>   rcu_read_unlock();
> #line 1931
18627,18735c19399,19413
< #line 1791
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "worker terminated\n");
< #line 1793
<   drbd_clear_flag(mdev, DEVICE_DYING);
< #line 1794
<   drbd_clear_flag(mdev, CONFIG_PENDING);
< #line 1795
<   __wake_up(& mdev->state_wait, 3U, 1, 0);
< #line 1797
<   return (0);
< }
< }
< #line 153 "include/linux/list.h"
< __inline static void list_move(struct list_head *list , struct list_head *head ) 
< { 
< 
< 
<   {
< #line 155
<   __list_del_entry(list);
< #line 156
<   list_add(list, head);
< #line 157
<   return;
< }
< }
< #line 570 "include/linux/list.h"
< __inline static void INIT_HLIST_NODE(struct hlist_node *h ) 
< { 
< 
< 
<   {
< #line 572
<   h->next = 0;
< #line 573
<   h->pprev = 0;
< #line 574
<   return;
< }
< }
< #line 576 "include/linux/list.h"
< __inline static int hlist_unhashed(struct hlist_node  const  *h ) 
< { 
< 
< 
<   {
< #line 578
<   return ((unsigned long )h->pprev == (unsigned long )((struct hlist_node **/* const  */)0));
< }
< }
< #line 586 "include/linux/list.h"
< __inline static void __hlist_del(struct hlist_node *n ) 
< { 
<   struct hlist_node *next ;
<   struct hlist_node **pprev ;
< 
<   {
< #line 588
<   next = n->next;
< #line 589
<   pprev = n->pprev;
< #line 590
<   *pprev = next;
< #line 591
<   if ((unsigned long )next != (unsigned long )((struct hlist_node *)0)) {
< #line 592
<     next->pprev = pprev;
<   } else {
< 
<   }
< #line 593
<   return;
< }
< }
< #line 602 "include/linux/list.h"
< __inline static void hlist_del_init(struct hlist_node *n ) 
< { 
<   int tmp ;
< 
<   {
< #line 604
<   tmp = hlist_unhashed((struct hlist_node  const  *)n);
< #line 604
<   if (tmp == 0) {
< #line 605
<     __hlist_del(n);
< #line 606
<     INIT_HLIST_NODE(n);
<   } else {
< 
<   }
< #line 608
<   return;
< }
< }
< #line 610 "include/linux/list.h"
< __inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h ) 
< { 
<   struct hlist_node *first ;
< 
<   {
< #line 612
<   first = h->first;
< #line 613
<   n->next = first;
< #line 614
<   if ((unsigned long )first != (unsigned long )((struct hlist_node *)0)) {
< #line 615
<     first->pprev = & n->next;
---
> #line 1932
>   kref_put(& mdev->kref, & drbd_minor_destroy);
> #line 1933
>   rcu_read_lock();
> #line 1927
>   vnr = vnr + 1;
> #line 1927
>   tmp___11 = idr_get_next(& tconn->volumes, & vnr);
> #line 1927
>   mdev = (struct drbd_conf *)tmp___11;
>   ldv_52373: ;
> #line 1927
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1928
>     goto ldv_52372;
18739,18769c19417,19420
< #line 616
<   h->first = n;
< #line 617
<   n->pprev = & h->first;
< #line 618
<   return;
< }
< }
< #line 642 "include/linux/list.h"
< __inline static void hlist_add_fake(struct hlist_node *n ) 
< { 
< 
< 
<   {
< #line 644
<   n->pprev = & n->next;
< #line 645
<   return;
< }
< }
< #line 248 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/bitops.h"
< __inline static int test_and_clear_bit(int nr , unsigned long volatile   *addr ) 
< { 
<   int oldbit ;
< 
<   {
< #line 252
<   __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2,%1\n\tsbb %0,%0": "=r" (oldbit),
<                        "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
< #line 256
<   return (oldbit);
---
> #line 1935
>   rcu_read_unlock();
> #line 1937
>   return (0);
18934,18935c19585,19590
< #line 89 "include/linux/thread_info.h"
< __inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
---
> #line 21 "include/linux/rwlock_api_smp.h"
> extern void _raw_write_lock_bh(rwlock_t * ) ;
> #line 33
> extern void _raw_write_unlock_bh(rwlock_t * ) ;
> #line 124 "include/linux/mutex.h"
> __inline static int mutex_is_locked(struct mutex *lock ) 
18940,18943c19595,19598
< #line 91
<   tmp = variable_test_bit(flag, (unsigned long const volatile   *)(& ti->flags));
< #line 91
<   return (tmp);
---
> #line 126
>   tmp = atomic_read((atomic_t const   *)(& lock->count));
> #line 126
>   return (tmp != 1);
18946,18947d19600
< #line 136 "include/linux/mutex.h"
< extern int mutex_lock_interruptible_nested(struct mutex * , unsigned int  ) ;
18964,19034c19617,19622
< #line 245 "include/linux/timer.h"
< extern int del_timer_sync(struct timer_list * ) ;
< #line 345 "include/linux/gfp.h"
< extern unsigned long __get_free_pages(gfp_t  , unsigned int  ) ;
< #line 360
< extern void free_pages(unsigned long  , unsigned int  ) ;
< #line 464 "include/linux/module.h"
< void ldv___module_get_3(struct module *ldv_func_arg1 ) ;
< #line 4 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< void ldv_module_get(struct module *module ) ;
< #line 453 "include/linux/mm.h"
< extern void put_page(struct page * ) ;
< #line 57 "include/linux/scatterlist.h"
< __inline static void sg_assign_page___0(struct scatterlist *sg , struct page *page ) 
< { 
<   unsigned long page_link ;
<   long tmp ;
<   long tmp___0 ;
<   long tmp___1 ;
< 
<   {
< #line 59
<   page_link = sg->page_link & 3UL;
< #line 65
<   tmp = __builtin_expect(((unsigned long )page & 3UL) != 0UL, 0L);
< #line 65
<   if (tmp != 0L) {
< #line 65
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
<                          "i" (65), "i" (12UL));
<     ldv_18986: ;
< #line 65
<     goto ldv_18986;
<   } else {
< 
<   }
< #line 67
<   tmp___0 = __builtin_expect(sg->sg_magic != 2271560481UL, 0L);
< #line 67
<   if (tmp___0 != 0L) {
< #line 67
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
<                          "i" (67), "i" (12UL));
<     ldv_18987: ;
< #line 67
<     goto ldv_18987;
<   } else {
< 
<   }
< #line 68
<   tmp___1 = __builtin_expect((long )((int )sg->page_link) & 1L, 0L);
< #line 68
<   if (tmp___1 != 0L) {
< #line 68
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
<                          "i" (68), "i" (12UL));
<     ldv_18988: ;
< #line 68
<     goto ldv_18988;
<   } else {
< 
<   }
< #line 70
<   sg->page_link = page_link | (unsigned long )page;
< #line 71
<   return;
< }
< }
< #line 87 "include/linux/scatterlist.h"
< __inline static void sg_set_page___0(struct scatterlist *sg , struct page *page ,
<                                      unsigned int len , unsigned int offset ) 
---
> #line 84
> extern long wait_for_completion_interruptible_timeout(struct completion * , unsigned long  ) ;
> #line 144 "include/linux/rcupdate.h"
> extern void synchronize_sched(void) ;
> #line 173 "include/linux/rcupdate.h"
> __inline static void synchronize_rcu(void) 
19039,19045c19627,19629
< #line 90
<   sg_assign_page___0(sg, page);
< #line 91
<   sg->offset = offset;
< #line 92
<   sg->length = len;
< #line 93
---
> #line 175
>   synchronize_sched();
> #line 176
19048a19633,19636
> #line 245 "include/linux/timer.h"
> extern int del_timer_sync(struct timer_list * ) ;
> #line 453 "include/linux/mm.h"
> extern void put_page(struct page * ) ;
19058c19646
<   sg_set_page___0(sg, 0xffffea0000000000UL + (tmp >> 12), buflen, (unsigned int )((long )buf) & 4095U);
---
>   sg_set_page(sg, 0xffffea0000000000UL + (tmp >> 12), buflen, (unsigned int )((long )buf) & 4095U);
19069,19095d19656
< #line 2533 "include/linux/sched.h"
< __inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
< { 
<   int tmp ;
< 
<   {
< #line 2535
<   tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
< #line 2535
<   return (tmp);
< }
< }
< #line 2559 "include/linux/sched.h"
< __inline static int signal_pending(struct task_struct *p ) 
< { 
<   int tmp ;
<   long tmp___0 ;
< 
<   {
< #line 2561
<   tmp = test_tsk_thread_flag(p, 2);
< #line 2561
<   tmp___0 = __builtin_expect(tmp != 0, 0L);
< #line 2561
<   return ((int )tmp___0);
< }
< }
19102,19103d19662
< #line 207
< extern int sock_create_lite(int  , int  , int  , struct socket ** ) ;
19108c19667,19669
< #line 306 "include/linux/drbd.h"
---
> #line 255
> extern int kernel_accept(struct socket * , struct socket ** , int  ) ;
> #line 329 "include/linux/drbd.h"
19122,19131d19682
< #line 520 "include/linux/crypto.h"
< __inline static u32 crypto_tfm_alg_type(struct crypto_tfm *tfm ) 
< { 
< 
< 
<   {
< #line 522
<   return ((tfm->__crt_alg)->cra_flags & 15U);
< }
< }
19262c19813
< #line 249 "include/linux/lru_cache.h"
---
> #line 260 "include/linux/lru_cache.h"
19264,19388c19815,19834
< #line 223 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static char const   *cmdname(enum drbd_packets cmd ) 
< { 
<   char const   *cmdnames[43U] ;
< 
<   {
< #line 228
<   cmdnames[0] = "Data";
< #line 228
<   cmdnames[1] = "DataReply";
< #line 228
<   cmdnames[2] = "RSDataReply";
< #line 228
<   cmdnames[3] = "Barrier";
< #line 228
<   cmdnames[4] = "ReportBitMap";
< #line 228
<   cmdnames[5] = "BecomeSyncTarget";
< #line 228
<   cmdnames[6] = "BecomeSyncSource";
< #line 228
<   cmdnames[7] = "UnplugRemote";
< #line 228
<   cmdnames[8] = "DataRequest";
< #line 228
<   cmdnames[9] = "RSDataRequest";
< #line 228
<   cmdnames[10] = "SyncParam";
< #line 228
<   cmdnames[11] = "ReportProtocol";
< #line 228
<   cmdnames[12] = "ReportUUIDs";
< #line 228
<   cmdnames[13] = "ReportSizes";
< #line 228
<   cmdnames[14] = "ReportState";
< #line 228
<   cmdnames[15] = "ReportSyncUUID";
< #line 228
<   cmdnames[16] = "AuthChallenge";
< #line 228
<   cmdnames[17] = "AuthResponse";
< #line 228
<   cmdnames[18] = "StateChgRequest";
< #line 228
<   cmdnames[19] = "Ping";
< #line 228
<   cmdnames[20] = "PingAck";
< #line 228
<   cmdnames[21] = "RecvAck";
< #line 228
<   cmdnames[22] = "WriteAck";
< #line 228
<   cmdnames[23] = "RSWriteAck";
< #line 228
<   cmdnames[24] = "DiscardAck";
< #line 228
<   cmdnames[25] = "NegAck";
< #line 228
<   cmdnames[26] = "NegDReply";
< #line 228
<   cmdnames[27] = "NegRSDReply";
< #line 228
<   cmdnames[28] = "BarrierAck";
< #line 228
<   cmdnames[29] = "StateChgReply";
< #line 228
<   cmdnames[30] = "OVRequest";
< #line 228
<   cmdnames[31] = "OVReply";
< #line 228
<   cmdnames[32] = "OVResult";
< #line 228
<   cmdnames[33] = "CsumRSRequest";
< #line 228
<   cmdnames[34] = "CsumRSIsInSync";
< #line 228
<   cmdnames[35] = "SyncParam89";
< #line 228
<   cmdnames[36] = "CBitmap";
< #line 228
<   cmdnames[37] = 0;
< #line 228
<   cmdnames[38] = 0;
< #line 228
<   cmdnames[39] = "DelayProbe";
< #line 228
<   cmdnames[40] = "OutOfSync";
< #line 228
<   cmdnames[41] = 0;
< #line 228
<   cmdnames[42] = 0;
< #line 271
<   if ((unsigned int )cmd == 65521U) {
< #line 272
<     return ("HandShakeM");
<   } else {
< 
<   }
< #line 273
<   if ((unsigned int )cmd == 65522U) {
< #line 274
<     return ("HandShakeS");
<   } else {
< 
<   }
< #line 275
<   if ((unsigned int )cmd == 65534U) {
< #line 276
<     return ("HandShake");
<   } else {
< 
<   }
< #line 277
<   if ((unsigned int )cmd > 41U) {
< #line 278
<     return ("Unknown");
<   } else {
< 
<   }
< #line 279
<   return (cmdnames[(unsigned int )cmd]);
< }
< }
< #line 300
---
> #line 110 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_state.h"
> enum drbd_state_rv drbd_change_state(struct drbd_conf *mdev , enum chg_state_flags f ,
>                                      union drbd_state mask , union drbd_state val ) ;
> #line 114
> void drbd_force_state(struct drbd_conf *mdev , union drbd_state mask , union drbd_state val ) ;
> #line 116
> enum drbd_state_rv _drbd_request_state(struct drbd_conf *mdev , union drbd_state mask ,
>                                        union drbd_state val , enum chg_state_flags f ) ;
> #line 127
> enum drbd_state_rv _conn_request_state(struct drbd_tconn *tconn , union drbd_state mask ,
>                                        union drbd_state val , enum chg_state_flags flags ) ;
> #line 154
> enum drbd_role conn_highest_role(struct drbd_tconn *tconn ) ;
> #line 158
> enum drbd_disk_state conn_highest_pdsk(struct drbd_tconn *tconn ) ;
> #line 65 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> unsigned int minor_count ;
> #line 236
> char const   *cmdname(enum drbd_packet cmd ) ;
> #line 256
19390c19836
< #line 303 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 259 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
19396c19842
< #line 313
---
> #line 269
19398c19844
< #line 314
---
> #line 270
19402,19403c19848,19851
< #line 585 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static enum drbd_bitmap_code DCBP_get_code(struct p_compressed_bm *p ) 
---
> #line 313
> unsigned int drbd_header_size(struct drbd_tconn *tconn ) ;
> #line 16 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_interval.h"
> __inline static void drbd_clear_interval(struct drbd_interval *i ) 
19408,19409c19856,19859
< #line 587
<   return ((enum drbd_bitmap_code )((int )p->encoding & 15));
---
> #line 18
>   i->rb.__rb_parent_color = (unsigned long )(& i->rb);
> #line 19
>   return;
19412,19413c19862,19863
< #line 598 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int DCBP_get_start(struct p_compressed_bm *p ) 
---
> #line 21 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_interval.h"
> __inline static bool drbd_interval_empty(struct drbd_interval *i ) 
19418,19419c19868,19869
< #line 600
<   return ((int )((signed char )p->encoding) < 0);
---
> #line 23
>   return (i->rb.__rb_parent_color == (unsigned long )(& i->rb));
19422,19423c19872,19886
< #line 610 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int DCBP_get_pad_bits(struct p_compressed_bm *p ) 
---
> #line 26
> bool drbd_insert_interval(struct rb_root *root , struct drbd_interval *this ) ;
> #line 27
> bool drbd_contains_interval(struct rb_root *root , sector_t sector , struct drbd_interval *interval ) ;
> #line 29
> void drbd_remove_interval(struct rb_root *root , struct drbd_interval *this ) ;
> #line 30
> struct drbd_interval *drbd_find_overlap(struct rb_root *root , sector_t sector , unsigned int size ) ;
> #line 32
> struct drbd_interval *drbd_next_overlap(struct drbd_interval *i , sector_t sector ,
>                                         unsigned int size ) ;
> #line 546 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> int drbd_wait_misc(struct drbd_conf *mdev , struct drbd_interval *i ) ;
> #line 1042 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static unsigned int mdev_to_minor(struct drbd_conf *mdev ) 
19428,19429c19891,19892
< #line 612
<   return (((int )p->encoding >> 4) & 7);
---
> #line 1044
>   return (mdev->minor);
19432,19433c19895,19896
< #line 1169 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int drbd_test_and_clear_flag(struct drbd_conf *mdev , enum drbd_flag f ) 
---
> #line 1047 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static struct drbd_conf *vnr_to_mdev(struct drbd_tconn *tconn , int vnr ) 
19435c19898
<   int tmp ;
---
>   void *tmp ;
19438,19441c19901,19904
< #line 1171
<   tmp = test_and_clear_bit((int )f, (unsigned long volatile   *)(& mdev->drbd_flags));
< #line 1171
<   return (tmp);
---
> #line 1049
>   tmp = idr_find(& tconn->volumes, vnr);
> #line 1049
>   return ((struct drbd_conf *)tmp);
19444,19450c19907
< #line 1233
< enum drbd_state_rv drbd_change_state(struct drbd_conf *mdev , enum chg_state_flags f ,
<                                      union drbd_state mask , union drbd_state val ) ;
< #line 1239
< enum drbd_state_rv _drbd_request_state(struct drbd_conf *mdev , union drbd_state mask ,
<                                        union drbd_state val , enum chg_state_flags f ) ;
< #line 1248
---
> #line 1064
19452,19460c19909,19919
< #line 1258
< void tl_release(struct drbd_conf *mdev , unsigned int barrier_nr , unsigned int set_size ) ;
< #line 1260
< void tl_clear(struct drbd_conf *mdev ) ;
< #line 1262
< void drbd_free_sock(struct drbd_conf *mdev ) ;
< #line 1265
< int drbd_send_protocol(struct drbd_conf *mdev ) ;
< #line 1266
---
> #line 1065
> void _drbd_thread_stop(struct drbd_thread *thi , int restart , int wait ) ;
> #line 1074
> void tl_release(struct drbd_tconn *tconn , unsigned int barrier_nr , unsigned int set_size ) ;
> #line 1076
> void tl_clear(struct drbd_tconn *tconn ) ;
> #line 1077
> void drbd_free_sock(struct drbd_tconn *tconn ) ;
> #line 1084
> int drbd_send_protocol(struct drbd_tconn *tconn ) ;
> #line 1085
19462c19921
< #line 1269
---
> #line 1088
19464c19923
< #line 1271
---
> #line 1090
19466,19477c19925,19934
< #line 1280
< int drbd_send_cmd2(struct drbd_conf *mdev , enum drbd_packets cmd , char *data , size_t size ) ;
< #line 1282
< int drbd_send_sync_param(struct drbd_conf *mdev , struct syncer_conf *sc ) ;
< #line 1283
< int drbd_send_b_ack(struct drbd_conf *mdev , u32 barrier_nr , u32 set_size ) ;
< #line 1287
< int drbd_send_ack_rp(struct drbd_conf *mdev , enum drbd_packets cmd , struct p_block_req *rp ) ;
< #line 1289
< int drbd_send_ack_dp(struct drbd_conf *mdev , enum drbd_packets cmd , struct p_data *dp ,
<                      int data_size ) ;
< #line 1305
---
> #line 1091
> int drbd_send_sync_param(struct drbd_conf *mdev ) ;
> #line 1092
> void drbd_send_b_ack(struct drbd_tconn *tconn , u32 barrier_nr , u32 set_size ) ;
> #line 1096
> void drbd_send_ack_rp(struct drbd_conf *mdev , enum drbd_packet cmd , struct p_block_req *rp ) ;
> #line 1098
> void drbd_send_ack_dp(struct drbd_conf *mdev , enum drbd_packet cmd , struct p_data *dp ,
>                       int data_size ) ;
> #line 1113
19479,19481c19936,19942
< #line 1307
< int drbd_send_sr_reply(struct drbd_conf *mdev , enum drbd_state_rv retcode ) ;
< #line 1316
---
> #line 1114
> void drbd_send_sr_reply(struct drbd_conf *mdev , enum drbd_state_rv retcode ) ;
> #line 1115
> void conn_send_sr_reply(struct drbd_tconn *tconn , enum drbd_state_rv retcode ) ;
> #line 1120
> void conn_md_sync(struct drbd_tconn *tconn ) ;
> #line 1125
19483c19944
< #line 1318
---
> #line 1127
19485c19946
< #line 1319
---
> #line 1128
19487c19948
< #line 1334
---
> #line 1143
19490c19951
< #line 1337
---
> #line 1149
19492c19953
< #line 1338
---
> #line 1150
19494c19955
< #line 1536
---
> #line 1370
19496c19957
< #line 1551
---
> #line 1385
19498c19959
< #line 1552
---
> #line 1386
19500c19961
< #line 1553
---
> #line 1387
19502c19963
< #line 1588
---
> #line 1433
19504,19505c19965,19966
<                            int assume_peer_has_space ) ;
< #line 1590
---
>                            sector_t u_size , int assume_peer_has_space ) ;
> #line 1435
19507c19968
< #line 1591
---
> #line 1436
19509c19970
< #line 1592
---
> #line 1437
19511c19972
< #line 1593
---
> #line 1438
19514,19526c19975,19997
< #line 1597
< void drbd_try_outdate_peer_async(struct drbd_conf *mdev ) ;
< #line 1658
< int drbd_release_ee(struct drbd_conf *mdev , struct list_head *list ) ;
< #line 1668
< void drbd_wait_ee_list_empty(struct drbd_conf *mdev , struct list_head *head ) ;
< #line 1670
< void _drbd_wait_ee_list_empty(struct drbd_conf *mdev , struct list_head *head ) ;
< #line 1674
< void drbd_flush_workqueue(struct drbd_conf *mdev ) ;
< #line 1675
< void drbd_free_tl_hash(struct drbd_conf *mdev ) ;
< #line 1705 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1442
> void conn_try_outdate_peer_async(struct drbd_tconn *tconn ) ;
> #line 1503
> int drbd_free_peer_reqs(struct drbd_conf *mdev , struct list_head *list ) ;
> #line 1511
> struct page *drbd_alloc_pages(struct drbd_conf *mdev , unsigned int number , bool retry___0 ) ;
> #line 1514
> void conn_flush_workqueue(struct drbd_tconn *tconn ) ;
> #line 1515
> int drbd_connected(struct drbd_conf *mdev ) ;
> #line 1516 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void drbd_flush_workqueue(struct drbd_conf *mdev ) 
> { 
> 
> 
>   {
> #line 1518
>   conn_flush_workqueue(mdev->tconn);
> #line 1519
>   return;
> }
> }
> #line 1556 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
19532c20003
< #line 1707
---
> #line 1558
19534c20005
< #line 1708
---
> #line 1559
19536c20007
< #line 1710
---
> #line 1561
19540c20011
< #line 1712 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1563 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
19546c20017
< #line 1714
---
> #line 1565
19548c20019
< #line 1715
---
> #line 1566
19550c20021
< #line 1717
---
> #line 1568
19554,19556c20025,20027
< #line 1719
< void drbd_bump_write_ordering(struct drbd_conf *mdev , enum write_ordering_e wo ) ;
< #line 1731
---
> #line 1570
> void drbd_bump_write_ordering(struct drbd_tconn *tconn , enum write_ordering_e wo ) ;
> #line 1582
19558c20029
< #line 1733
---
> #line 1584
19560,19564c20031,20032
< #line 1757
< void drbd_bcast_ee(struct drbd_conf *mdev , char const   *reason , int const   dgs ,
<                    char const   *seen_hash , char const   *calc_hash , struct drbd_epoch_entry  const  *e ) ;
< #line 1830 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int drbd_ee_has_active_page___0(struct drbd_epoch_entry *e ) 
---
> #line 1632 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static int drbd_peer_req_has_active_page___0(struct drbd_peer_request *peer_req ) 
19571,19576c20039,20044
< #line 1832
<   page = e->pages;
< #line 1833
<   goto ldv_51313;
<   ldv_51312: 
< #line 1834
---
> #line 1634
>   page = peer_req->pages;
> #line 1635
>   goto ldv_51832;
>   ldv_51831: 
> #line 1636
19578c20046
< #line 1834
---
> #line 1636
19580c20048
< #line 1835
---
> #line 1637
19585c20053
< #line 1833
---
> #line 1635
19587,19588c20055,20056
<   ldv_51313: ;
< #line 1833
---
>   ldv_51832: ;
> #line 1635
19590c20058
< #line 1833
---
> #line 1635
19592c20060
< #line 1833
---
> #line 1635
19594c20062
< #line 1833
---
> #line 1635
19596,19597c20064,20065
< #line 1834
<       goto ldv_51312;
---
> #line 1636
>       goto ldv_51831;
19599,19600c20067,20068
< #line 1836
<       goto ldv_51314;
---
> #line 1638
>       goto ldv_51833;
19605,19606c20073,20074
<   ldv_51314: ;
< #line 1837
---
>   ldv_51833: ;
> #line 1639
19610,19624c20078,20079
< #line 1875 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int drbd_request_state(struct drbd_conf *mdev , union drbd_state mask ,
<                                        union drbd_state val ) 
< { 
<   enum drbd_state_rv tmp ;
< 
<   {
< #line 1879
<   tmp = _drbd_request_state(mdev, mask, val, 14);
< #line 1879
<   return ((int )tmp);
< }
< }
< #line 1968 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static sector_t drbd_md_first_sector(struct drbd_backing_dev *bdev ) 
---
> #line 1758 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static sector_t _drbd_md_first_sector(int meta_dev_idx , struct drbd_backing_dev *bdev ) 
19629,19630c20084,20085
< #line 1970
<   switch (bdev->dc.meta_dev_idx) {
---
> #line 1760
>   switch (meta_dev_idx) {
19633c20088
< #line 1973
---
> #line 1763
19637c20092
< #line 1976
---
> #line 1766
19642c20097
< #line 2011 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1818 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
19645a20101,20105
>   int meta_dev_idx ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
19648,19649c20108,20109
<   sector_t tmp___0 ;
<   sector_t tmp___1 ;
---
>   sector_t tmp___2 ;
>   sector_t tmp___3 ;
19652c20112
<   sector_t tmp___2 ;
---
>   sector_t tmp___4 ;
19657c20117
<   sector_t tmp___3 ;
---
>   sector_t tmp___5 ;
19660,19689c20120,20176
< #line 2014
<   switch (bdev->dc.meta_dev_idx) {
<   case -1: ;
<   case -3: 
< #line 2018
<   tmp___1 = drbd_get_capacity(bdev->backing_bdev);
< #line 2018
<   if (tmp___1 != 0UL) {
< #line 2018
<     __min1 = 2251799813685248UL;
< #line 2018
<     tmp___0 = drbd_md_first_sector(bdev);
< #line 2018
<     __min2 = tmp___0;
< #line 2018
<     s = __min1 < __min2 ? __min1 : __min2;
<   } else {
< #line 2018
<     s = 0UL;
<   }
< #line 2021
<   goto ldv_51392;
<   case -2: 
< #line 2023
<   __min1___0 = 2251799813685248UL;
< #line 2023
<   tmp___2 = drbd_get_capacity(bdev->backing_bdev);
< #line 2023
<   __min2___0 = tmp___2;
< #line 2023
---
> #line 1823
>   rcu_read_lock();
> #line 1824
>   _________p1 = *((struct disk_conf * volatile  *)(& bdev->disk_conf));
> #line 1824
>   tmp = debug_lockdep_rcu_enabled();
> #line 1824
>   if (tmp != 0 && ! __warned) {
> #line 1824
>     tmp___0 = rcu_read_lock_held();
> #line 1824
>     if (tmp___0 == 0 && 1) {
> #line 1824
>       __warned = 1;
> #line 1824
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h",
>                              1824, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1824
>   meta_dev_idx = _________p1->meta_dev_idx;
> #line 1825
>   rcu_read_unlock();
> #line 1827
>   switch (meta_dev_idx) {
>   case -1: ;
>   case -3: 
> #line 1831
>   tmp___3 = drbd_get_capacity(bdev->backing_bdev);
> #line 1831
>   if (tmp___3 != 0UL) {
> #line 1831
>     __min1 = 2251799813685248UL;
> #line 1831
>     tmp___2 = _drbd_md_first_sector(meta_dev_idx, bdev);
> #line 1831
>     __min2 = tmp___2;
> #line 1831
>     s = __min1 < __min2 ? __min1 : __min2;
>   } else {
> #line 1831
>     s = 0UL;
>   }
> #line 1834
>   goto ldv_51920;
>   case -2: 
> #line 1836
>   __min1___0 = 2251799813685248UL;
> #line 1836
>   tmp___4 = drbd_get_capacity(bdev->backing_bdev);
> #line 1836
>   __min2___0 = tmp___4;
> #line 1836
19691c20178
< #line 2026
---
> #line 1839
19693c20180
< #line 2026
---
> #line 1839
19695c20182
< #line 2026
---
> #line 1839
19697,19698c20184,20185
< #line 2029
<   goto ldv_51392;
---
> #line 1842
>   goto ldv_51920;
19700c20187
< #line 2031
---
> #line 1844
19702,19706c20189,20193
< #line 2031
<   tmp___3 = drbd_get_capacity(bdev->backing_bdev);
< #line 2031
<   __min2___2 = tmp___3;
< #line 2031
---
> #line 1844
>   tmp___5 = drbd_get_capacity(bdev->backing_bdev);
> #line 1844
>   __min2___2 = tmp___5;
> #line 1844
19709,19710c20196,20197
<   ldv_51392: ;
< #line 2034
---
>   ldv_51920: ;
> #line 1847
19714,19736c20201,20206
< #line 2068 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void drbd_queue_work_front(struct drbd_work_queue *q , struct drbd_work *w ) 
< { 
<   unsigned long flags ;
<   raw_spinlock_t *tmp ;
< 
<   {
< #line 2071
<   tmp = spinlock_check(& q->q_lock);
< #line 2071
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 2072
<   list_add(& w->list, & q->q);
< #line 2073
<   up(& q->s);
< #line 2075
<   spin_unlock_irqrestore(& q->q_lock, flags);
< #line 2076
<   return;
< }
< }
< #line 2108 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int drbd_send_ping(struct drbd_conf *mdev ) 
---
> #line 1927
> int drbd_send_ping(struct drbd_tconn *tconn ) ;
> #line 1928
> int drbd_send_ping_ack(struct drbd_tconn *tconn ) ;
> #line 1932 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void drbd_thread_stop(struct drbd_thread *thi ) 
19738,19739d20207
<   struct p_header80 h ;
<   int tmp ;
19741,19752d20208
<   {
< #line 2111
<   tmp = drbd_send_cmd(mdev, 0, P_PING, & h, 8UL);
< #line 2111
<   return (tmp);
< }
< }
< #line 2114 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int drbd_send_ping_ack(struct drbd_conf *mdev ) 
< { 
<   struct p_header80 h ;
<   int tmp ;
19755,19758c20211,20214
< #line 2117
<   tmp = drbd_send_cmd(mdev, 0, P_PING_ACK, & h, 8UL);
< #line 2117
<   return (tmp);
---
> #line 1934
>   _drbd_thread_stop(thi, 0, 1);
> #line 1935
>   return;
19761c20217
< #line 2199 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2015 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
19767c20223
< #line 2201
---
> #line 2017
19769,19788c20225
< #line 2202
<   return;
< }
< }
< #line 2215 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void put_net_conf(struct drbd_conf *mdev ) 
< { 
<   int tmp ;
< 
<   {
< #line 2217
<   tmp = atomic_dec_and_test(& mdev->net_cnt);
< #line 2217
<   if (tmp != 0) {
< #line 2218
<     __wake_up(& mdev->net_cnt_wait, 3U, 1, 0);
<   } else {
< 
<   }
< #line 2219
---
> #line 2018
19792,19813c20229
< #line 2227 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int get_net_conf(struct drbd_conf *mdev ) 
< { 
<   int have_net_conf ;
< 
<   {
< #line 2231
<   atomic_inc(& mdev->net_cnt);
< #line 2232
<   have_net_conf = (int )mdev->state.ldv_40583.conn > 1;
< #line 2233
<   if (have_net_conf == 0) {
< #line 2234
<     put_net_conf(mdev);
<   } else {
< 
<   }
< #line 2235
<   return (have_net_conf);
< }
< }
< #line 2493 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2300 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
19819c20235
< #line 2495
---
> #line 2302
19821c20237
< #line 2496
---
> #line 2303
19823c20239
< #line 2497
---
> #line 2304
19827,19865c20243
< #line 2500 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static int seq_cmp(u32 a , u32 b ) 
< { 
< 
< 
<   {
< #line 2507
<   return ((int )a - (int )b);
< }
< }
< #line 2516 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void update_peer_seq(struct drbd_conf *mdev , unsigned int new_seq ) 
< { 
<   unsigned int m ;
<   int tmp ;
< 
<   {
< #line 2519
<   spin_lock(& mdev->peer_seq_lock);
< #line 2520
<   tmp = seq_cmp(mdev->peer_seq, new_seq);
< #line 2520
<   m = tmp > 0 ? mdev->peer_seq : new_seq;
< #line 2521
<   mdev->peer_seq = m;
< #line 2522
<   spin_unlock(& mdev->peer_seq_lock);
< #line 2523
<   if (m == new_seq) {
< #line 2524
<     __wake_up(& mdev->seq_wait, 3U, 1, 0);
<   } else {
< 
<   }
< #line 2525
<   return;
< }
< }
< #line 11 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_wrappers.h"
---
> #line 12 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_wrappers.h"
19871,19872d20248
< #line 15
<   set_capacity(mdev->vdisk, size);
19874c20250
<   ((mdev->this_bdev)->bd_inode)->i_size = (long long )size << 9;
---
>   set_capacity(mdev->vdisk, size);
19875a20252,20253
>   ((mdev->this_bdev)->bd_inode)->i_size = (long long )size << 9;
> #line 18
19879c20257
< #line 29 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_wrappers.h"
---
> #line 30 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_wrappers.h"
19887,19888d20264
< #line 33
<   if ((unsigned long )bio->bi_bdev == (unsigned long )((struct block_device *)0)) {
19889a20266,20267
>   if ((unsigned long )bio->bi_bdev == (unsigned long )((struct block_device *)0)) {
> #line 35
19891c20269
< #line 34
---
> #line 35
19893,19894d20270
< #line 37
<     dump_stack();
19896c20272
<     bio_endio(bio, -19);
---
>     dump_stack();
19897a20274,20275
>     bio_endio(bio, -19);
> #line 40
19902c20280
< #line 42
---
> #line 43
19904,19905d20281
< #line 42
<   if (tmp___0 != 0) {
19906a20283,20284
>   if (tmp___0 != 0) {
> #line 44
19909c20287
< #line 45
---
> #line 46
19912c20290
< #line 46
---
> #line 47
19916,20054d20293
< #line 48 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_wrappers.h"
< __inline static int drbd_crypto_is_hash(struct crypto_tfm *tfm ) 
< { 
<   u32 tmp ;
< 
<   {
< #line 50
<   tmp = crypto_tfm_alg_type(tfm);
< #line 50
<   return ((tmp & 14U) == 8U);
< }
< }
< #line 232 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< __inline static struct hlist_head *ee_hash_slot(struct drbd_conf *mdev , sector_t sector ) 
< { 
<   long tmp ;
< 
<   {
< #line 234
<   tmp = __builtin_expect(mdev->ee_hash_s == 0U, 0L);
< #line 234
<   if (tmp != 0L) {
< #line 234
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"),
<                          "i" (234), "i" (12UL));
<     ldv_51668: ;
< #line 234
<     goto ldv_51668;
<   } else {
< 
<   }
< #line 235
<   return (mdev->ee_hash + (unsigned long )((unsigned int )(sector >> 8) % mdev->ee_hash_s));
< }
< }
< #line 241 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< __inline static struct hlist_head *tl_hash_slot(struct drbd_conf *mdev , sector_t sector ) 
< { 
<   long tmp ;
< 
<   {
< #line 243
<   tmp = __builtin_expect(mdev->tl_hash_s == 0U, 0L);
< #line 243
<   if (tmp != 0L) {
< #line 243
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"),
<                          "i" (243), "i" (12UL));
<     ldv_51673: ;
< #line 243
<     goto ldv_51673;
<   } else {
< 
<   }
< #line 244
<   return (mdev->tl_hash + (unsigned long )((unsigned int )(sector >> 8) % mdev->tl_hash_s));
< }
< }
< #line 249 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< static struct hlist_head *ar_hash_slot(struct drbd_conf *mdev , sector_t sector ) 
< { 
< 
< 
<   {
< #line 251
<   return (mdev->app_reads_hash + (unsigned long )((unsigned int )sector % 15U));
< }
< }
< #line 257 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< __inline static struct drbd_request *_ar_id_to_req(struct drbd_conf *mdev , u64 id ,
<                                                    sector_t sector ) 
< { 
<   struct hlist_head *slot ;
<   struct hlist_head *tmp ;
<   struct hlist_node *n ;
<   struct drbd_request *req ;
<   struct hlist_node  const  *__mptr ;
< 
<   {
< #line 260
<   tmp = ar_hash_slot(mdev, sector);
< #line 260
<   slot = tmp;
< #line 264
<   n = slot->first;
< #line 264
<   goto ldv_51690;
<   ldv_51689: ;
< #line 265
<   if ((unsigned long )req == (unsigned long )id) {
< #line 266
<     if (req->sector != sector) {
< #line 266
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( req->sector == sector ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h",
<               266);
<     } else {
< 
<     }
< #line 267
<     return (req);
<   } else {
< 
<   }
< #line 264
<   n = n->next;
<   ldv_51690: ;
< #line 264
<   if ((unsigned long )n != (unsigned long )((struct hlist_node *)0)) {
< #line 264
<     __mptr = (struct hlist_node  const  *)n;
< #line 264
<     req = (struct drbd_request *)__mptr + 0xffffffffffffffd8UL;
< #line 264
<     if (1 != 0) {
< #line 265
<       goto ldv_51689;
<     } else {
< #line 267
<       goto ldv_51691;
<     }
<   } else {
< 
<   }
<   ldv_51691: ;
< #line 270
<   return (0);
< }
< }
< #line 311 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< __inline static int overlaps(sector_t s1 , int l1 , sector_t s2 , int l2 ) 
< { 
< 
< 
<   {
< #line 313
<   return ((sector_t )(l1 >> 9) + s1 > s2 && (sector_t )(l2 >> 9) + s2 > s1);
< }
< }
20176c20415
<   ldv_51758: ;
---
>   ldv_52284: ;
20178c20417
<   goto ldv_51758;
---
>   goto ldv_52284;
20289,20294c20528,20535
< #line 65 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_do_handshake(struct drbd_conf *mdev ) ;
< #line 66
< static int drbd_do_auth(struct drbd_conf *mdev ) ;
< #line 68
< static enum finish_epoch drbd_may_finish_epoch(struct drbd_conf *mdev , struct drbd_epoch *epoch ,
---
> #line 72 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_do_features(struct drbd_tconn *tconn ) ;
> #line 73
> static int drbd_do_auth(struct drbd_tconn *tconn ) ;
> #line 74
> static int drbd_disconnected(struct drbd_conf *mdev ) ;
> #line 76
> static enum finish_epoch drbd_may_finish_epoch(struct drbd_tconn *tconn , struct drbd_epoch *epoch ,
20296,20298c20537,20539
< #line 69
< static int e_end_block(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) ;
< #line 83 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 77
> static int e_end_block(struct drbd_work *w , int cancel ) ;
> #line 91 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
20307c20548
< #line 88
---
> #line 96
20309c20550
< #line 88
---
> #line 96
20311,20316c20552,20557
< #line 88
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
<                          "i" (88), "i" (12UL));
<     ldv_51838: ;
< #line 88
<     goto ldv_51838;
---
> #line 96
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
>                          "i" (96), "i" (12UL));
>     ldv_52370: ;
> #line 96
>     goto ldv_52370;
20320c20561
< #line 89
---
> #line 97
20323c20564
< #line 89
---
> #line 97
20325,20330c20566,20571
< #line 89
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
<                          "i" (89), "i" (12UL));
<     ldv_51839: ;
< #line 89
<     goto ldv_51839;
---
> #line 97
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
>                          "i" (97), "i" (12UL));
>     ldv_52371: ;
> #line 97
>     goto ldv_52371;
20334c20575
< #line 91
---
> #line 99
20336c20577
< #line 93
---
> #line 101
20338c20579
< #line 94
---
> #line 102
20343,20346c20584,20587
< #line 96
<   goto ldv_51842;
<   ldv_51841: 
< #line 97
---
> #line 104
>   goto ldv_52374;
>   ldv_52373: 
> #line 105
20348c20589
< #line 98
---
> #line 106
20350c20591
< #line 98
---
> #line 106
20352,20353c20593,20594
< #line 99
<     goto ldv_51840;
---
> #line 107
>     goto ldv_52372;
20357c20598
< #line 100
---
> #line 108
20359c20600
< #line 102
---
> #line 110
20364c20605
< #line 103
---
> #line 111
20366,20367c20607,20608
<   ldv_51842: ;
< #line 96
---
>   ldv_52374: ;
> #line 104
20369,20370c20610,20611
< #line 97
<     goto ldv_51841;
---
> #line 105
>     goto ldv_52373;
20374,20375c20615,20616
<   ldv_51840: 
< #line 107
---
>   ldv_52372: 
> #line 115
20377c20618
< #line 109
---
> #line 117
20379c20620
< #line 110
---
> #line 118
20381c20622
< #line 111
---
> #line 119
20385c20626
< #line 117 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 125 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
20392c20633
< #line 120
---
> #line 128
20394,20397c20635,20638
< #line 121
<   goto ldv_51850;
<   ldv_51849: 
< #line 122
---
> #line 129
>   goto ldv_52382;
>   ldv_52381: 
> #line 130
20399c20640
< #line 122
---
> #line 130
20401,20402c20642,20643
<   ldv_51850: 
< #line 121
---
>   ldv_52382: 
> #line 129
20404c20645
< #line 121
---
> #line 129
20406,20407c20647,20648
< #line 122
<     goto ldv_51849;
---
> #line 130
>     goto ldv_52381;
20412c20653
< #line 123
---
> #line 131
20414c20655
< #line 124
---
> #line 132
20419c20660
< #line 125
---
> #line 133
20423c20664
< #line 128 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 136 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
20430c20671
< #line 131
---
> #line 139
20432,20435c20673,20676
< #line 132
<   goto ldv_51859;
<   ldv_51858: 
< #line 133
---
> #line 140
>   goto ldv_52391;
>   ldv_52390: 
> #line 141
20437c20678
< #line 134
---
> #line 142
20439c20680
< #line 132
---
> #line 140
20441,20442c20682,20683
<   ldv_51859: ;
< #line 132
---
>   ldv_52391: ;
> #line 140
20444c20685
< #line 132
---
> #line 140
20446c20687
< #line 132
---
> #line 140
20448,20449c20689,20690
< #line 133
<       goto ldv_51858;
---
> #line 141
>       goto ldv_52390;
20451,20452c20692,20693
< #line 135
<       goto ldv_51860;
---
> #line 143
>       goto ldv_52392;
20457,20458c20698,20699
<   ldv_51860: ;
< #line 136
---
>   ldv_52392: ;
> #line 144
20462c20703
< #line 139 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 147 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
20469c20710
< #line 144
---
> #line 152
20471c20712
< #line 145
---
> #line 153
20473c20714
< #line 145
---
> #line 153
20475,20480c20716,20721
< #line 145
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
<                          "i" (145), "i" (12UL));
<     ldv_51867: ;
< #line 145
<     goto ldv_51867;
---
> #line 153
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
>                          "i" (153), "i" (12UL));
>     ldv_52399: ;
> #line 153
>     goto ldv_52399;
20484c20725
< #line 149
---
> #line 157
20486c20727
< #line 150
---
> #line 158
20488c20729
< #line 151
---
> #line 159
20492,20493c20733,20734
< #line 153 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static struct page *drbd_pp_first_pages_or_try_alloc(struct drbd_conf *mdev , int number ) 
---
> #line 161 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static struct page *__drbd_alloc_pages(struct drbd_conf *mdev , unsigned int number ) 
20497c20738
<   int i ;
---
>   unsigned int i ;
20500c20741
< #line 155
---
> #line 164
20502c20743
< #line 156
---
> #line 165
20504,20508c20745,20749
< #line 157
<   i = 0;
< #line 161
<   if (drbd_pp_vacant >= number) {
< #line 162
---
> #line 166
>   i = 0U;
> #line 170
>   if ((unsigned int )drbd_pp_vacant >= number) {
> #line 171
20510,20512c20751,20753
< #line 163
<     page = page_chain_del(& drbd_pp_pool, number);
< #line 164
---
> #line 172
>     page = page_chain_del(& drbd_pp_pool, (int )number);
> #line 173
20514,20515c20755,20756
< #line 165
<       drbd_pp_vacant = drbd_pp_vacant - number;
---
> #line 174
>       drbd_pp_vacant = (int )((unsigned int )drbd_pp_vacant - number);
20519c20760
< #line 166
---
> #line 175
20521c20762
< #line 167
---
> #line 176
20523c20764
< #line 168
---
> #line 177
20531,20536c20772,20777
< #line 174
<   i = 0;
< #line 174
<   goto ldv_51877;
<   ldv_51876: 
< #line 175
---
> #line 183
>   i = 0U;
> #line 183
>   goto ldv_52409;
>   ldv_52408: 
> #line 184
20538c20779
< #line 176
---
> #line 185
20540,20541c20781,20782
< #line 177
<     goto ldv_51875;
---
> #line 186
>     goto ldv_52407;
20545c20786
< #line 178
---
> #line 187
20547c20788
< #line 179
---
> #line 188
20549,20552c20790,20793
< #line 174
<   i = i + 1;
<   ldv_51877: ;
< #line 174
---
> #line 183
>   i = i + 1U;
>   ldv_52409: ;
> #line 183
20554,20555c20795,20796
< #line 175
<     goto ldv_51876;
---
> #line 184
>     goto ldv_52408;
20559,20560c20800,20801
<   ldv_51875: ;
< #line 182
---
>   ldv_52407: ;
> #line 191
20562c20803
< #line 183
---
> #line 192
20567c20808
< #line 188
---
> #line 197
20569c20810
< #line 189
---
> #line 198
20571c20812
< #line 190
---
> #line 199
20573c20814
< #line 191
---
> #line 200
20575,20577c20816,20818
< #line 192
<     drbd_pp_vacant = drbd_pp_vacant + i;
< #line 193
---
> #line 201
>     drbd_pp_vacant = (int )((unsigned int )drbd_pp_vacant + i);
> #line 202
20582c20823
< #line 195
---
> #line 204
20586,20587c20827,20828
< #line 198 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static void reclaim_net_ee(struct drbd_conf *mdev , struct list_head *to_be_freed ) 
---
> #line 207 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void reclaim_finished_net_peer_reqs(struct drbd_conf *mdev , struct list_head *to_be_freed ) 
20589c20830
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
20596c20837
< #line 208
---
> #line 218
20598c20839
< #line 208
---
> #line 218
20600,20603c20841,20844
< #line 208
<   goto ldv_51889;
<   ldv_51888: 
< #line 209
---
> #line 218
>   goto ldv_52421;
>   ldv_52420: 
> #line 219
20605,20609c20846,20850
< #line 209
<   e = (struct drbd_epoch_entry *)__mptr;
< #line 210
<   tmp = drbd_ee_has_active_page___0(e);
< #line 210
---
> #line 219
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 220
>   tmp = drbd_peer_req_has_active_page___0(peer_req);
> #line 220
20611,20612c20852,20853
< #line 211
<     goto ldv_51887;
---
> #line 221
>     goto ldv_52419;
20616c20857
< #line 212
---
> #line 222
20618c20859
< #line 208
---
> #line 218
20620c20861
< #line 208
---
> #line 218
20622,20623c20863,20864
<   ldv_51889: ;
< #line 208
---
>   ldv_52421: ;
> #line 218
20625,20626c20866,20867
< #line 209
<     goto ldv_51888;
---
> #line 219
>     goto ldv_52420;
20630,20631c20871,20872
<   ldv_51887: ;
< #line 213
---
>   ldv_52419: ;
> #line 223
20635c20876
< #line 216 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 226 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
20639,20640c20880,20881
<   struct drbd_epoch_entry *e ;
<   struct drbd_epoch_entry *t ;
---
>   struct drbd_peer_request *peer_req ;
>   struct drbd_peer_request *t ;
20646c20887
< #line 218
---
> #line 228
20648c20889
< #line 218
---
> #line 228
20650,20656c20891,20897
< #line 221
<   spin_lock_irq(& mdev->req_lock);
< #line 222
<   reclaim_net_ee(mdev, & reclaimed);
< #line 223
<   spin_unlock_irq(& mdev->req_lock);
< #line 225
---
> #line 231
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 232
>   reclaim_finished_net_peer_reqs(mdev, & reclaimed);
> #line 233
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 235
20658,20671c20899,20912
< #line 225
<   e = (struct drbd_epoch_entry *)__mptr;
< #line 225
<   __mptr___0 = (struct list_head  const  *)e->w.list.next;
< #line 225
<   t = (struct drbd_epoch_entry *)__mptr___0;
< #line 225
<   goto ldv_51903;
<   ldv_51902: 
< #line 226
<   drbd_free_some_ee(mdev, e, 1);
< #line 225
<   e = t;
< #line 225
---
> #line 235
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 235
>   __mptr___0 = (struct list_head  const  *)peer_req->w.list.next;
> #line 235
>   t = (struct drbd_peer_request *)__mptr___0;
> #line 235
>   goto ldv_52435;
>   ldv_52434: 
> #line 236
>   __drbd_free_peer_req(mdev, peer_req, 1);
> #line 235
>   peer_req = t;
> #line 235
20673,20679c20914,20920
< #line 225
<   t = (struct drbd_epoch_entry *)__mptr___1;
<   ldv_51903: ;
< #line 225
<   if ((unsigned long )(& e->w.list) != (unsigned long )(& reclaimed)) {
< #line 226
<     goto ldv_51902;
---
> #line 235
>   t = (struct drbd_peer_request *)__mptr___1;
>   ldv_52435: ;
> #line 235
>   if ((unsigned long )(& peer_req->w.list) != (unsigned long )(& reclaimed)) {
> #line 236
>     goto ldv_52434;
20684c20925
< #line 230
---
> #line 240
20688,20689c20929,20930
< #line 241 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static struct page *drbd_pp_alloc(struct drbd_conf *mdev , unsigned int number , bool retry ) 
---
> #line 251 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> struct page *drbd_alloc_pages(struct drbd_conf *mdev , unsigned int number , bool retry___0 ) 
20691a20933
>   struct net_conf *nc ;
20693a20936,20938
>   int mxb ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
20696c20941
<   struct task_struct *tmp___2 ;
---
>   int tmp___2 ;
20697a20943,20944
>   struct task_struct *tmp___4 ;
>   int tmp___5 ;
20700c20947
< #line 243
---
> #line 254
20702c20949
< #line 244
---
> #line 256
20704c20951
< #line 244
---
> #line 256
20706c20953
< #line 244
---
> #line 256
20708c20955
< #line 244
---
> #line 256
20710c20957
< #line 244
---
> #line 256
20712c20959
< #line 244
---
> #line 256
20714,20719c20961,20980
< #line 248
<   tmp___0 = atomic_read((atomic_t const   *)(& mdev->pp_in_use));
< #line 248
<   if (tmp___0 < (mdev->net_conf)->max_buffers) {
< #line 249
<     page = drbd_pp_first_pages_or_try_alloc(mdev, (int )number);
---
> #line 261
>   rcu_read_lock();
> #line 262
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 262
>   tmp___0 = debug_lockdep_rcu_enabled();
> #line 262
>   if (tmp___0 != 0 && ! __warned) {
> #line 262
>     tmp___1 = rcu_read_lock_held();
> #line 262
>     if (tmp___1 == 0 && 1) {
> #line 262
>       __warned = 1;
> #line 262
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              262, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
20723,20726c20984,21002
< #line 251
<   goto ldv_51914;
<   ldv_51913: 
< #line 252
---
> #line 262
>   nc = _________p1;
> #line 263
>   mxb = (unsigned long )nc != (unsigned long )((struct net_conf *)0) ? (int )nc->max_buffers : 1000000;
> #line 264
>   rcu_read_unlock();
> #line 266
>   tmp___2 = atomic_read((atomic_t const   *)(& mdev->pp_in_use));
> #line 266
>   if (tmp___2 < mxb) {
> #line 267
>     page = __drbd_alloc_pages(mdev, number);
>   } else {
> 
>   }
> #line 269
>   goto ldv_52451;
>   ldv_52450: 
> #line 270
20728c21004
< #line 254
---
> #line 272
20730,20736c21006,21012
< #line 256
<   tmp___1 = atomic_read((atomic_t const   *)(& mdev->pp_in_use));
< #line 256
<   if (tmp___1 < (mdev->net_conf)->max_buffers) {
< #line 257
<     page = drbd_pp_first_pages_or_try_alloc(mdev, (int )number);
< #line 258
---
> #line 274
>   tmp___3 = atomic_read((atomic_t const   *)(& mdev->pp_in_use));
> #line 274
>   if (tmp___3 < mxb) {
> #line 275
>     page = __drbd_alloc_pages(mdev, number);
> #line 276
20738,20739c21014,21015
< #line 259
<       goto ldv_51912;
---
> #line 277
>       goto ldv_52449;
20746,20749c21022,21025
< #line 262
<   if (! retry) {
< #line 263
<     goto ldv_51912;
---
> #line 280
>   if (! retry___0) {
> #line 281
>     goto ldv_52449;
20753,20762c21029,21038
< #line 265
<   tmp___2 = get_current();
< #line 265
<   tmp___3 = signal_pending(tmp___2);
< #line 265
<   if (tmp___3 != 0) {
< #line 266
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "drbd_pp_alloc interrupted!\n");
< #line 267
<     goto ldv_51912;
---
> #line 283
>   tmp___4 = get_current();
> #line 283
>   tmp___5 = signal_pending(tmp___4);
> #line 283
>   if (tmp___5 != 0) {
> #line 284
>     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "drbd_alloc_pages interrupted!\n");
> #line 285
>     goto ldv_52449;
20766c21042
< #line 270
---
> #line 288
20768,20769c21044,21045
<   ldv_51914: ;
< #line 251
---
>   ldv_52451: ;
> #line 269
20771,20772c21047,21048
< #line 252
<     goto ldv_51913;
---
> #line 270
>     goto ldv_52450;
20776,20777c21052,21053
<   ldv_51912: 
< #line 272
---
>   ldv_52449: 
> #line 290
20779c21055
< #line 274
---
> #line 292
20781c21057
< #line 275
---
> #line 293
20786c21062
< #line 276
---
> #line 294
20790,20791c21066,21067
< #line 283 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static void drbd_pp_free(struct drbd_conf *mdev , struct page *page , int is_net ) 
---
> #line 301 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void drbd_free_pages(struct drbd_conf *mdev , struct page *page , int is_net ) 
20798c21074
< #line 285
---
> #line 303
20800c21076
< #line 288
---
> #line 306
20802c21078
< #line 289
---
> #line 307
20807,20809c21083,21085
< #line 291
<   if ((unsigned long )drbd_pp_vacant > (unsigned long )minor_count * 32UL) {
< #line 292
---
> #line 309
>   if ((unsigned long )drbd_pp_vacant > (unsigned long )minor_count * 256UL) {
> #line 310
20812c21088
< #line 295
---
> #line 313
20814c21090
< #line 296
---
> #line 314
20816c21092
< #line 297
---
> #line 315
20818c21094
< #line 298
---
> #line 316
20820c21096
< #line 299
---
> #line 317
20823c21099
< #line 301
---
> #line 319
20825c21101
< #line 302
---
> #line 320
20827c21103
< #line 303
---
> #line 321
20833c21109
< #line 305
---
> #line 323
20835c21111
< #line 306
---
> #line 324
20839,20841c21115,21117
< #line 323 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< struct drbd_epoch_entry *drbd_alloc_ee(struct drbd_conf *mdev , u64 id , sector_t sector ,
<                                        unsigned int data_size , gfp_t gfp_mask ) 
---
> #line 341 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> struct drbd_peer_request *drbd_alloc_peer_req(struct drbd_conf *mdev , u64 id , sector_t sector ,
>                                               unsigned int data_size , gfp_t gfp_mask ) 
20843c21119
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
20850c21126
< #line 330
---
> #line 345
20852c21128
< #line 331
---
> #line 346
20854c21130
< #line 333
---
> #line 348
20856c21132
< #line 333
---
> #line 348
20858c21134
< #line 334
---
> #line 349
20863c21139
< #line 336
---
> #line 351
20865,20869c21141,21145
< #line 336
<   e = (struct drbd_epoch_entry *)tmp___0;
< #line 337
<   if ((unsigned long )e == (unsigned long )((struct drbd_epoch_entry *)0)) {
< #line 338
---
> #line 351
>   peer_req = (struct drbd_peer_request *)tmp___0;
> #line 352
>   if ((unsigned long )peer_req == (unsigned long )((struct drbd_peer_request *)0)) {
> #line 353
20871,20872c21147,21149
< #line 339
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "alloc_ee: Allocation of an EE failed\n");
---
> #line 354
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s: allocation failed\n",
>               "drbd_alloc_peer_req");
20876c21153
< #line 340
---
> #line 355
20881c21158
< #line 343
---
> #line 358
20883,20885c21160,21162
< #line 344
<     page = drbd_pp_alloc(mdev, nr_pages, (gfp_mask & 16U) != 0U);
< #line 345
---
> #line 359
>     page = drbd_alloc_pages(mdev, nr_pages, (gfp_mask & 16U) != 0U);
> #line 360
20887c21164
< #line 346
---
> #line 361
20895,20914c21172,21195
< #line 349
<   INIT_HLIST_NODE(& e->collision);
< #line 350
<   e->epoch = 0;
< #line 351
<   e->mdev = mdev;
< #line 352
<   e->pages = page;
< #line 353
<   atomic_set(& e->pending_bios, 0);
< #line 354
<   e->size = data_size;
< #line 355
<   e->flags = 0UL;
< #line 356
<   e->sector = sector;
< #line 357
<   e->ldv_49794.block_id = id;
< #line 359
<   return (e);
---
> #line 364
>   drbd_clear_interval(& peer_req->i);
> #line 365
>   peer_req->i.size = data_size;
> #line 366
>   peer_req->i.sector = sector;
> #line 367
>   peer_req->i.local = 0;
> #line 368
>   peer_req->i.waiting = 0;
> #line 370
>   peer_req->epoch = 0;
> #line 371
>   peer_req->w.ldv_50388.mdev = mdev;
> #line 372
>   peer_req->pages = page;
> #line 373
>   atomic_set(& peer_req->pending_bios, 0);
> #line 374
>   peer_req->flags = 0UL;
> #line 379
>   peer_req->ldv_50490.block_id = id;
> #line 381
>   return (peer_req);
20916,20918c21197,21199
< #line 362
<   mempool_free((void *)e, drbd_ee_mempool);
< #line 363
---
> #line 384
>   mempool_free((void *)peer_req, drbd_ee_mempool);
> #line 385
20922,20923c21203,21205
< #line 366 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< void drbd_free_some_ee(struct drbd_conf *mdev , struct drbd_epoch_entry *e , int is_net ) 
---
> #line 388 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> void __drbd_free_peer_req(struct drbd_conf *mdev , struct drbd_peer_request *peer_req ,
>                           int is_net ) 
20926c21208,21209
<   int tmp___0 ;
---
>   bool tmp___0 ;
>   int tmp___1 ;
20929,20932c21212,21215
< #line 368
<   if ((e->flags & 16UL) != 0UL) {
< #line 369
<     kfree((void const   *)e->ldv_49794.digest);
---
> #line 391
>   if ((peer_req->flags & 16UL) != 0UL) {
> #line 392
>     kfree((void const   *)peer_req->ldv_50490.digest);
20936,20940c21219,21223
< #line 370
<   drbd_pp_free(mdev, e->pages, is_net);
< #line 371
<   tmp = atomic_read((atomic_t const   *)(& e->pending_bios));
< #line 371
---
> #line 393
>   drbd_free_pages(mdev, peer_req->pages, is_net);
> #line 394
>   tmp = atomic_read((atomic_t const   *)(& peer_req->pending_bios));
> #line 394
20942,20945c21225,21228
< #line 371
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( atomic_read(&e->pending_bios) == 0 ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             371);
---
> #line 394
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( atomic_read(&peer_req->pending_bios) == 0 ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             394);
20949,20956c21232,21247
< #line 372
<   tmp___0 = hlist_unhashed((struct hlist_node  const  *)(& e->collision));
< #line 372
<   if (tmp___0 == 0) {
< #line 372
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( hlist_unhashed(&e->collision) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             372);
---
> #line 395
>   tmp___0 = drbd_interval_empty(& peer_req->i);
> #line 395
>   if (tmp___0) {
> #line 395
>     tmp___1 = 0;
>   } else {
> #line 395
>     tmp___1 = 1;
>   }
> #line 395
>   if (tmp___1) {
> #line 395
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( drbd_interval_empty(&peer_req->i) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             395);
20960,20962c21251,21253
< #line 373
<   mempool_free((void *)e, drbd_ee_mempool);
< #line 374
---
> #line 396
>   mempool_free((void *)peer_req, drbd_ee_mempool);
> #line 397
20966,20967c21257,21258
< #line 376 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< int drbd_release_ee(struct drbd_conf *mdev , struct list_head *list ) 
---
> #line 399 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> int drbd_free_peer_reqs(struct drbd_conf *mdev , struct list_head *list ) 
20970,20971c21261,21262
<   struct drbd_epoch_entry *e ;
<   struct drbd_epoch_entry *t ;
---
>   struct drbd_peer_request *peer_req ;
>   struct drbd_peer_request *t ;
20979c21270
< #line 378
---
> #line 401
20981c21272
< #line 378
---
> #line 401
20983c21274
< #line 380
---
> #line 403
20985c21276
< #line 381
---
> #line 404
20987,20989c21278,21280
< #line 383
<   spin_lock_irq(& mdev->req_lock);
< #line 384
---
> #line 406
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 407
20991,20993c21282,21284
< #line 385
<   spin_unlock_irq(& mdev->req_lock);
< #line 387
---
> #line 408
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 410
20995,21006c21286,21297
< #line 387
<   e = (struct drbd_epoch_entry *)__mptr;
< #line 387
<   __mptr___0 = (struct list_head  const  *)e->w.list.next;
< #line 387
<   t = (struct drbd_epoch_entry *)__mptr___0;
< #line 387
<   goto ldv_51955;
<   ldv_51954: 
< #line 388
<   drbd_free_some_ee(mdev, e, is_net);
< #line 389
---
> #line 410
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 410
>   __mptr___0 = (struct list_head  const  *)peer_req->w.list.next;
> #line 410
>   t = (struct drbd_peer_request *)__mptr___0;
> #line 410
>   goto ldv_52493;
>   ldv_52492: 
> #line 411
>   __drbd_free_peer_req(mdev, peer_req, is_net);
> #line 412
21008,21010c21299,21301
< #line 387
<   e = t;
< #line 387
---
> #line 410
>   peer_req = t;
> #line 410
21012,21018c21303,21309
< #line 387
<   t = (struct drbd_epoch_entry *)__mptr___1;
<   ldv_51955: ;
< #line 387
<   if ((unsigned long )(& e->w.list) != (unsigned long )(& work_list)) {
< #line 388
<     goto ldv_51954;
---
> #line 410
>   t = (struct drbd_peer_request *)__mptr___1;
>   ldv_52493: ;
> #line 410
>   if ((unsigned long )(& peer_req->w.list) != (unsigned long )(& work_list)) {
> #line 411
>     goto ldv_52492;
21023c21314
< #line 391
---
> #line 414
21027,21028c21318,21319
< #line 404 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_process_done_ee(struct drbd_conf *mdev ) 
---
> #line 420 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_finish_peer_reqs(struct drbd_conf *mdev ) 
21032,21034c21323,21325
<   struct drbd_epoch_entry *e ;
<   struct drbd_epoch_entry *t ;
<   int ok ;
---
>   struct drbd_peer_request *peer_req ;
>   struct drbd_peer_request *t ;
>   int err ;
21040c21331
<   int tmp ;
---
>   int err2 ;
21044c21335
< #line 406
---
> #line 422
21046c21337
< #line 406
---
> #line 422
21048c21339
< #line 407
---
> #line 423
21050c21341
< #line 407
---
> #line 423
21052,21058c21343,21349
< #line 409
<   ok = (int )mdev->state.ldv_40583.conn > 8;
< #line 411
<   spin_lock_irq(& mdev->req_lock);
< #line 412
<   reclaim_net_ee(mdev, & reclaimed);
< #line 413
---
> #line 425
>   err = 0;
> #line 427
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 428
>   reclaim_finished_net_peer_reqs(mdev, & reclaimed);
> #line 429
21060,21062c21351,21353
< #line 414
<   spin_unlock_irq(& mdev->req_lock);
< #line 416
---
> #line 430
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 432
21064,21077c21355,21368
< #line 416
<   e = (struct drbd_epoch_entry *)__mptr;
< #line 416
<   __mptr___0 = (struct list_head  const  *)e->w.list.next;
< #line 416
<   t = (struct drbd_epoch_entry *)__mptr___0;
< #line 416
<   goto ldv_51972;
<   ldv_51971: 
< #line 417
<   drbd_free_some_ee(mdev, e, 1);
< #line 416
<   e = t;
< #line 416
---
> #line 432
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 432
>   __mptr___0 = (struct list_head  const  *)peer_req->w.list.next;
> #line 432
>   t = (struct drbd_peer_request *)__mptr___0;
> #line 432
>   goto ldv_52510;
>   ldv_52509: 
> #line 433
>   __drbd_free_peer_req(mdev, peer_req, 1);
> #line 432
>   peer_req = t;
> #line 432
21079,21085c21370,21376
< #line 416
<   t = (struct drbd_epoch_entry *)__mptr___1;
<   ldv_51972: ;
< #line 416
<   if ((unsigned long )(& e->w.list) != (unsigned long )(& reclaimed)) {
< #line 417
<     goto ldv_51971;
---
> #line 432
>   t = (struct drbd_peer_request *)__mptr___1;
>   ldv_52510: ;
> #line 432
>   if ((unsigned long )(& peer_req->w.list) != (unsigned long )(& reclaimed)) {
> #line 433
>     goto ldv_52509;
21089c21380
< #line 423
---
> #line 439
21091,21108c21382,21404
< #line 423
<   e = (struct drbd_epoch_entry *)__mptr___2;
< #line 423
<   __mptr___3 = (struct list_head  const  *)e->w.list.next;
< #line 423
<   t = (struct drbd_epoch_entry *)__mptr___3;
< #line 423
<   goto ldv_51981;
<   ldv_51980: 
< #line 425
<   tmp = (*(e->w.cb))(mdev, & e->w, ok == 0);
< #line 425
<   ok = tmp != 0 && ok != 0;
< #line 426
<   drbd_free_some_ee(mdev, e, 0);
< #line 423
<   e = t;
< #line 423
---
> #line 439
>   peer_req = (struct drbd_peer_request *)__mptr___2;
> #line 439
>   __mptr___3 = (struct list_head  const  *)peer_req->w.list.next;
> #line 439
>   t = (struct drbd_peer_request *)__mptr___3;
> #line 439
>   goto ldv_52520;
>   ldv_52519: 
> #line 443
>   err2 = (*(peer_req->w.cb))(& peer_req->w, err != 0);
> #line 444
>   if (err == 0) {
> #line 445
>     err = err2;
>   } else {
> 
>   }
> #line 446
>   __drbd_free_peer_req(mdev, peer_req, 0);
> #line 439
>   peer_req = t;
> #line 439
21110,21116c21406,21412
< #line 423
<   t = (struct drbd_epoch_entry *)__mptr___4;
<   ldv_51981: ;
< #line 423
<   if ((unsigned long )(& e->w.list) != (unsigned long )(& work_list)) {
< #line 424
<     goto ldv_51980;
---
> #line 439
>   t = (struct drbd_peer_request *)__mptr___4;
>   ldv_52520: ;
> #line 439
>   if ((unsigned long )(& peer_req->w.list) != (unsigned long )(& work_list)) {
> #line 440
>     goto ldv_52519;
21120c21416
< #line 428
---
> #line 448
21122,21123c21418,21419
< #line 430
<   return (ok);
---
> #line 450
>   return (err);
21126,21127c21422,21423
< #line 433 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< void _drbd_wait_ee_list_empty(struct drbd_conf *mdev , struct list_head *head ) 
---
> #line 453 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void _drbd_wait_ee_list_empty(struct drbd_conf *mdev , struct list_head *head ) 
21134c21430
< #line 435
---
> #line 456
21136c21432
< #line 435
---
> #line 456
21138c21434
< #line 435
---
> #line 456
21140c21436
< #line 435
---
> #line 456
21142c21438
< #line 435
---
> #line 456
21144c21440
< #line 435
---
> #line 456
21146,21149c21442,21445
< #line 439
<   goto ldv_51989;
<   ldv_51988: 
< #line 440
---
> #line 460
>   goto ldv_52528;
>   ldv_52527: 
> #line 461
21151,21153c21447,21449
< #line 441
<   spin_unlock_irq(& mdev->req_lock);
< #line 442
---
> #line 462
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 463
21155c21451
< #line 443
---
> #line 464
21157,21160c21453,21456
< #line 444
<   spin_lock_irq(& mdev->req_lock);
<   ldv_51989: 
< #line 439
---
> #line 465
>   spin_lock_irq(& (mdev->tconn)->req_lock);
>   ldv_52528: 
> #line 460
21162c21458
< #line 439
---
> #line 460
21164,21165c21460,21461
< #line 440
<     goto ldv_51988;
---
> #line 461
>     goto ldv_52527;
21170c21466
< #line 444
---
> #line 465
21174,21175c21470,21471
< #line 448 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< void drbd_wait_ee_list_empty(struct drbd_conf *mdev , struct list_head *head ) 
---
> #line 469 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void drbd_wait_ee_list_empty(struct drbd_conf *mdev , struct list_head *head ) 
21180,21219d21475
< #line 450
<   spin_lock_irq(& mdev->req_lock);
< #line 451
<   _drbd_wait_ee_list_empty(mdev, head);
< #line 452
<   spin_unlock_irq(& mdev->req_lock);
< #line 453
<   return;
< }
< }
< #line 457 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_accept(struct drbd_conf *mdev , char const   **what , struct socket *sock ,
<                        struct socket **newsock ) 
< { 
<   struct sock *sk ;
<   int err ;
< 
<   {
< #line 460
<   sk = sock->sk;
< #line 461
<   err = 0;
< #line 463
<   *what = "listen";
< #line 464
<   err = (*((sock->ops)->listen))(sock, 5);
< #line 465
<   if (err < 0) {
< #line 466
<     goto out;
<   } else {
< 
<   }
< #line 468
<   *what = "sock_create_lite";
< #line 469
<   err = sock_create_lite((int )sk->__sk_common.skc_family, (int )sk->sk_type, (int )sk->sk_protocol,
<                          newsock);
< #line 471
<   if (err < 0) {
21221,21224c21477,21479
<     goto out;
<   } else {
< 
<   }
---
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 473
>   _drbd_wait_ee_list_empty(mdev, head);
21226c21481
<   *what = "accept";
---
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
21228,21246c21483
<   err = (*((sock->ops)->accept))(sock, *newsock, 0);
< #line 476
<   if (err < 0) {
< #line 477
<     sock_release(*newsock);
< #line 478
<     *newsock = 0;
< #line 479
<     goto out;
<   } else {
< 
<   }
< #line 481
<   (*newsock)->ops = sock->ops;
< #line 482
<   ldv___module_get_3(((*newsock)->ops)->owner);
<   out: ;
< #line 485
<   return (err);
---
>   return;
21249,21251c21486,21487
< #line 488 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_recv_short(struct drbd_conf *mdev , struct socket *sock , void *buf ,
<                            size_t size , int flags ) 
---
> #line 477 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_recv_short(struct socket *sock , void *buf , size_t size , int flags ) 
21263c21499
< #line 492
---
> #line 480
21265c21501
< #line 492
---
> #line 480
21267c21503
< #line 496
---
> #line 484
21269c21505
< #line 496
---
> #line 484
21271c21507
< #line 496
---
> #line 484
21273c21509
< #line 496
---
> #line 484
21275c21511
< #line 496
---
> #line 484
21277c21513
< #line 496
---
> #line 484
21279c21515
< #line 496
---
> #line 484
21281c21517
< #line 503
---
> #line 491
21283c21519
< #line 503
---
> #line 491
21285c21521
< #line 504
---
> #line 492
21287c21523
< #line 504
---
> #line 492
21289c21525
< #line 504
---
> #line 492
21291c21527
< #line 505
---
> #line 493
21293c21529
< #line 506
---
> #line 494
21295c21531
< #line 506
---
> #line 494
21297c21533
< #line 508
---
> #line 496
21301,21302c21537,21538
< #line 511 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_recv(struct drbd_conf *mdev , void *buf , size_t size ) 
---
> #line 499 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_recv(struct drbd_tconn *tconn , void *buf , size_t size ) 
21304,21306d21539
<   mm_segment_t oldfs ;
<   struct kvec iov ;
<   struct msghdr msg ;
21308,21311d21540
<   struct thread_info *tmp ;
<   struct thread_info *tmp___0 ;
<   mm_segment_t __constr_expr_0 ;
<   struct thread_info *tmp___1 ;
21312a21542,21545
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
21315,21316c21548,21549
<   struct task_struct *tmp___2 ;
<   int tmp___3 ;
---
>   struct task_struct *tmp___1 ;
>   int tmp___2 ;
21321,21355c21554,21556
< #line 514
<   iov.iov_base = buf;
< #line 514
<   iov.iov_len = size;
< #line 518
<   msg.msg_name = 0;
< #line 518
<   msg.msg_namelen = 0;
< #line 518
<   msg.msg_iov = (struct iovec *)(& iov);
< #line 518
<   msg.msg_iovlen = 1UL;
< #line 518
<   msg.msg_control = 0;
< #line 518
<   msg.msg_controllen = 0UL;
< #line 518
<   msg.msg_flags = 16640U;
< #line 525
<   tmp = current_thread_info();
< #line 525
<   oldfs = tmp->addr_limit;
< #line 526
<   tmp___0 = current_thread_info();
< #line 526
<   __constr_expr_0.seg = 0xffffffffffffffffUL;
< #line 526
<   tmp___0->addr_limit = __constr_expr_0;
< #line 527
<   rv = sock_recvmsg(mdev->data.socket, & msg, size, (int )msg.msg_flags);
< #line 528
<   tmp___1 = current_thread_info();
< #line 528
<   tmp___1->addr_limit = oldfs;
< #line 530
---
> #line 503
>   rv = drbd_recv_short(tconn->data.socket, buf, size, 0);
> #line 505
21357c21558
< #line 531
---
> #line 506
21359,21360c21560,21561
< #line 532
<       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "sock was reset by peer\n");
---
> #line 507
>       printk("\016d-con %s: sock was reset by peer\n", tconn->name);
21362c21563
< #line 533
---
> #line 508
21364,21366c21565,21566
< #line 534
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "sock_recvmsg returned %d\n",
<               rv);
---
> #line 509
>       printk("\vd-con %s: sock_recvmsg returned %d\n", tconn->name, rv);
21368c21568
< #line 535
---
> #line 510
21370,21380c21570,21607
< #line 536
<       tmp___3 = drbd_test_flag(mdev, DISCONNECT_SENT);
< #line 536
<       if (tmp___3 != 0) {
< #line 538
<         __ret = (long )(((mdev->net_conf)->ping_timeo * 250) / 10);
< #line 538
<         if ((int )mdev->state.ldv_40583.conn > 9) {
< #line 538
<           tmp___2 = get_current();
< #line 538
---
> #line 511
>       tmp___2 = constant_test_bit(12U, (unsigned long const volatile   *)(& tconn->flags));
> #line 511
>       if (tmp___2 != 0) {
> #line 513
>         rcu_read_lock();
> #line 514
>         _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 514
>         tmp = debug_lockdep_rcu_enabled();
> #line 514
>         if (tmp != 0 && ! __warned) {
> #line 514
>           tmp___0 = rcu_read_lock_held();
> #line 514
>           if (tmp___0 == 0 && 1) {
> #line 514
>             __warned = 1;
> #line 514
>             lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                                    514, "suspicious rcu_dereference_check() usage");
>           } else {
> 
>           }
>         } else {
> 
>         }
> #line 514
>         t = (long )((_________p1->ping_timeo * 250U) / 10U);
> #line 515
>         rcu_read_unlock();
> #line 517
>         __ret = t;
> #line 517
>         if ((unsigned int )tconn->cstate > 8U) {
> #line 517
>           tmp___1 = get_current();
> #line 517
21382,21384c21609,21611
< #line 538
<           __wait.private = (void *)tmp___2;
< #line 538
---
> #line 517
>           __wait.private = (void *)tmp___1;
> #line 517
21386c21613
< #line 538
---
> #line 517
21388c21615
< #line 538
---
> #line 517
21390,21396c21617,21623
<           ldv_52030: 
< #line 538
<           prepare_to_wait(& mdev->state_wait, & __wait, 2);
< #line 538
<           if ((int )mdev->state.ldv_40583.conn <= 9) {
< #line 538
<             goto ldv_52029;
---
>           ldv_52558: 
> #line 517
>           prepare_to_wait(& tconn->ping_wait, & __wait, 2);
> #line 517
>           if ((unsigned int )tconn->cstate <= 8U) {
> #line 517
>             goto ldv_52557;
21400c21627
< #line 538
---
> #line 517
21402c21629
< #line 538
---
> #line 517
21404,21405c21631,21632
< #line 538
<             goto ldv_52029;
---
> #line 517
>             goto ldv_52557;
21409,21413c21636,21640
< #line 538
<           goto ldv_52030;
<           ldv_52029: 
< #line 538
<           finish_wait(& mdev->state_wait, & __wait);
---
> #line 517
>           goto ldv_52558;
>           ldv_52557: 
> #line 517
>           finish_wait(& tconn->ping_wait, & __wait);
21417c21644
< #line 538
---
> #line 517
21419c21646
< #line 540
---
> #line 519
21421c21648
< #line 541
---
> #line 520
21429,21430c21656,21657
< #line 543
<       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "sock was shut down by peer\n");
---
> #line 522
>       printk("\016d-con %s: sock was shut down by peer\n", tconn->name);
21437c21664
< #line 546
---
> #line 525
21439c21666
< #line 547
---
> #line 526
21441,21443c21668,21670
< #line 547
<     val.ldv_40583.conn = 4U;
< #line 547
---
> #line 526
>     val.ldv_40604.conn = 4U;
> #line 526
21445,21448c21672,21675
< #line 547
<     mask.ldv_40583.conn = 31U;
< #line 547
<     drbd_force_state(mdev, mask, val);
---
> #line 526
>     mask.ldv_40604.conn = 31U;
> #line 526
>     conn_request_state(tconn, mask, val, CS_HARD);
21453c21680
< #line 550
---
> #line 529
21457c21684,21739
< #line 558 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 532 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_recv_all(struct drbd_tconn *tconn , void *buf , size_t size ) 
> { 
>   int err ;
> 
>   {
> #line 536
>   err = drbd_recv(tconn, buf, size);
> #line 537
>   if ((size_t )err != size) {
> #line 538
>     if (err >= 0) {
> #line 539
>       err = -5;
>     } else {
> #line 541
>       err = 0;
>     }
>   } else {
> 
>   }
> #line 542
>   return (err);
> }
> }
> #line 545 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_recv_all_warn(struct drbd_tconn *tconn , void *buf , size_t size ) 
> { 
>   int err ;
>   struct task_struct *tmp ;
>   int tmp___0 ;
> 
>   {
> #line 549
>   err = drbd_recv_all(tconn, buf, size);
> #line 550
>   if (err != 0) {
> #line 550
>     tmp = get_current();
> #line 550
>     tmp___0 = signal_pending(tmp);
> #line 550
>     if (tmp___0 == 0) {
> #line 551
>       printk("\fd-con %s: short read (expected size %d)\n", tconn->name, (int )size);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 552
>   return (err);
> }
> }
> #line 560 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
21463c21745
< #line 562
---
> #line 564
21465c21747
< #line 563
---
> #line 565
21467c21749
< #line 564
---
> #line 566
21472c21754
< #line 566
---
> #line 568
21474c21756
< #line 567
---
> #line 569
21476c21758
< #line 568
---
> #line 570
21481c21763
< #line 570
---
> #line 572
21485,21486c21767,21768
< #line 572 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static struct socket *drbd_try_connect(struct drbd_conf *mdev ) 
---
> #line 574 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static struct socket *drbd_try_connect(struct drbd_tconn *tconn ) 
21490a21773,21774
>   struct sockaddr_in6 peer_in6 ;
>   struct net_conf *nc ;
21491a21776,21780
>   int peer_addr_len ;
>   int my_addr_len ;
>   int sndbuf_size ;
>   int rcvbuf_size ;
>   int connect_int ;
21492a21782,21783
>   struct net_conf *_________p1 ;
>   bool __warned ;
21494,21495c21785
<   long tmp___0 ;
<   size_t __len ;
---
>   int tmp___0 ;
21497a21788
>   size_t __len ;
21498a21790,21794
>   int __min1___0 ;
>   int __min2___0 ;
>   size_t __len___0 ;
>   void *__ret___0 ;
>   long tmp___1 ;
21503c21799
< #line 578
---
> #line 583
21505,21510c21801,21820
< #line 580
<   tmp = get_net_conf(mdev);
< #line 580
<   if (tmp == 0) {
< #line 581
<     return (0);
---
> #line 585
>   rcu_read_lock();
> #line 586
>   _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 586
>   tmp = debug_lockdep_rcu_enabled();
> #line 586
>   if (tmp != 0 && ! __warned) {
> #line 586
>     tmp___0 = rcu_read_lock_held();
> #line 586
>     if (tmp___0 == 0 && 1) {
> #line 586
>       __warned = 1;
> #line 586
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              586, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
21514,21518d21823
< #line 583
<   what = "sock_create_kern";
< #line 584
<   err = sock_create_kern((int )((struct sockaddr *)(& (mdev->net_conf)->my_addr))->sa_family,
<                          1, 6, & sock);
21520c21825
<   if (err < 0) {
---
>   nc = _________p1;
21522c21827
<     sock = 0;
---
>   if ((unsigned long )nc == (unsigned long )((struct net_conf *)0)) {
21524c21829,21831
<     goto out;
---
>     rcu_read_unlock();
> #line 589
>     return (0);
21529,21533c21836,21838
<   tmp___0 = (long )((mdev->net_conf)->try_connect_int * 250);
< #line 591
<   (sock->sk)->sk_sndtimeo = tmp___0;
< #line 591
<   (sock->sk)->sk_rcvtimeo = tmp___0;
---
>   sndbuf_size = (int )nc->sndbuf_size;
> #line 592
>   rcvbuf_size = (int )nc->rcvbuf_size;
21535,21538c21840,21845
<   drbd_setbufsize(sock, (unsigned int )(mdev->net_conf)->sndbuf_size, (unsigned int )(mdev->net_conf)->rcvbuf_size);
< #line 603
<   __min1 = (mdev->net_conf)->my_addr_len;
< #line 603
---
>   connect_int = (int )nc->connect_int;
> #line 594
>   rcu_read_unlock();
> #line 596
>   __min1 = tconn->my_addr_len;
> #line 596
21540,21543c21847,21852
< #line 603
<   __len = (size_t )(__min1 < __min2 ? __min1 : __min2);
< #line 603
<   __ret = __builtin_memcpy((void *)(& src_in6), (void const   *)(& (mdev->net_conf)->my_addr),
---
> #line 596
>   my_addr_len = __min1 < __min2 ? __min1 : __min2;
> #line 597
>   __len = (size_t )my_addr_len;
> #line 597
>   __ret = __builtin_memcpy((void *)(& src_in6), (void const   *)(& tconn->my_addr),
21545,21547c21854,21856
< #line 605
<   if ((unsigned int )((struct sockaddr *)(& (mdev->net_conf)->my_addr))->sa_family == 10U) {
< #line 606
---
> #line 599
>   if ((unsigned int )((struct sockaddr *)(& tconn->my_addr))->sa_family == 10U) {
> #line 600
21550c21859
< #line 608
---
> #line 602
21552a21862,21877
> #line 604
>   __min1___0 = tconn->peer_addr_len;
> #line 604
>   __min2___0 = 28;
> #line 604
>   peer_addr_len = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
> #line 605
>   __len___0 = (size_t )peer_addr_len;
> #line 605
>   __ret___0 = __builtin_memcpy((void *)(& peer_in6), (void const   *)(& tconn->peer_addr),
>                                __len___0);
> #line 607
>   what = "sock_create_kern";
> #line 608
>   err = sock_create_kern((int )((struct sockaddr *)(& src_in6))->sa_family, 1, 6,
>                          & sock);
21554,21557d21878
<   what = "bind before connect";
< #line 611
<   err = (*((sock->ops)->bind))(sock, (struct sockaddr *)(& src_in6), (mdev->net_conf)->my_addr_len);
< #line 614
21558a21880,21886
> #line 611
>     sock = 0;
> #line 612
>     goto out;
>   } else {
> 
>   }
21559a21888,21901
>   tmp___1 = (long )(connect_int * 250);
> #line 615
>   (sock->sk)->sk_sndtimeo = tmp___1;
> #line 615
>   (sock->sk)->sk_rcvtimeo = tmp___1;
> #line 617
>   drbd_setbufsize(sock, (unsigned int )sndbuf_size, (unsigned int )rcvbuf_size);
> #line 626
>   what = "bind before connect";
> #line 627
>   err = (*((sock->ops)->bind))(sock, (struct sockaddr *)(& src_in6), my_addr_len);
> #line 628
>   if (err < 0) {
> #line 629
21564c21906
< #line 619
---
> #line 633
21566c21908
< #line 620
---
> #line 634
21568,21570c21910,21912
< #line 621
<   err = (*((sock->ops)->connect))(sock, (struct sockaddr *)(& (mdev->net_conf)->peer_addr),
<                                   (mdev->net_conf)->peer_addr_len, 0);
---
> #line 635
>   err = (*((sock->ops)->connect))(sock, (struct sockaddr *)(& peer_in6), peer_addr_len,
>                                   0);
21572c21914
< #line 626
---
> #line 638
21574c21916
< #line 627
---
> #line 639
21576c21918
< #line 628
---
> #line 640
21578c21920
< #line 629
---
> #line 641
21583c21925
< #line 631
---
> #line 643
21594c21936
< #line 638
---
> #line 650
21596,21597c21938,21939
< #line 639
<     goto ldv_52069;
---
> #line 651
>     goto ldv_52622;
21599,21601c21941,21942
< #line 641
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s failed, err = %d\n",
<             what, err);
---
> #line 653
>     printk("\vd-con %s: %s failed, err = %d\n", tconn->name, what, err);
21603,21604c21944,21945
<     ldv_52069: ;
< #line 643
---
>     ldv_52622: ;
> #line 655
21606c21947
< #line 644
---
> #line 656
21608,21610c21949,21951
< #line 644
<       val.ldv_40583.conn = 1U;
< #line 644
---
> #line 656
>       val.ldv_40604.conn = 1U;
> #line 656
21612,21615c21953,21956
< #line 644
<       mask.ldv_40583.conn = 31U;
< #line 644
<       drbd_force_state(mdev, mask, val);
---
> #line 656
>       mask.ldv_40604.conn = 31U;
> #line 656
>       conn_request_state(tconn, mask, val, CS_HARD);
21622,21624c21963
< #line 646
<   put_net_conf(mdev);
< #line 647
---
> #line 659
21628,21629c21967,21992
< #line 650 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static struct socket *drbd_wait_for_connect(struct drbd_conf *mdev ) 
---
> #line 670 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void drbd_incoming_connection(struct sock *sk ) 
> { 
>   struct accept_wait_data *ad ;
>   void (*state_change)(struct sock * ) ;
> 
>   {
> #line 672
>   ad = (struct accept_wait_data *)sk->sk_user_data;
> #line 675
>   state_change = ad->original_sk_state_change;
> #line 676
>   if ((unsigned int )((unsigned char )sk->__sk_common.skc_state) == 1U) {
> #line 677
>     complete(& ad->door_bell);
>   } else {
> 
>   }
> #line 678
>   (*state_change)(sk);
> #line 679
>   return;
> }
> }
> #line 681 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int prepare_listen_socket(struct drbd_tconn *tconn , struct accept_wait_data *ad ) 
21631d21993
<   int timeo ;
21633c21995,21998
<   struct socket *s_estab ;
---
>   int sndbuf_size ;
>   int rcvbuf_size ;
>   int my_addr_len ;
>   struct sockaddr_in6 my_addr ;
21634a22000
>   struct net_conf *nc ;
21635a22002,22003
>   struct net_conf *_________p1 ;
>   bool __warned ;
21637c22005,22009
<   u32 tmp___0 ;
---
>   int tmp___0 ;
>   int __min1 ;
>   int __min2 ;
>   size_t __len ;
>   void *__ret ;
21642,21649c22014,22033
< #line 653
<   s_estab = 0;
< #line 656
<   tmp = get_net_conf(mdev);
< #line 656
<   if (tmp == 0) {
< #line 657
<     return (0);
---
> #line 689
>   rcu_read_lock();
> #line 690
>   _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 690
>   tmp = debug_lockdep_rcu_enabled();
> #line 690
>   if (tmp != 0 && ! __warned) {
> #line 690
>     tmp___0 = rcu_read_lock_held();
> #line 690
>     if (tmp___0 == 0 && 1) {
> #line 690
>       __warned = 1;
> #line 690
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              690, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
21653c22037,22065
< #line 659
---
> #line 690
>   nc = _________p1;
> #line 691
>   if ((unsigned long )nc == (unsigned long )((struct net_conf *)0)) {
> #line 692
>     rcu_read_unlock();
> #line 693
>     return (-5);
>   } else {
> 
>   }
> #line 695
>   sndbuf_size = (int )nc->sndbuf_size;
> #line 696
>   rcvbuf_size = (int )nc->rcvbuf_size;
> #line 697
>   rcu_read_unlock();
> #line 699
>   __min1 = tconn->my_addr_len;
> #line 699
>   __min2 = 28;
> #line 699
>   my_addr_len = __min1 < __min2 ? __min1 : __min2;
> #line 700
>   __len = (size_t )my_addr_len;
> #line 700
>   __ret = __builtin_memcpy((void *)(& my_addr), (void const   *)(& tconn->my_addr),
>                            __len);
> #line 702
21655,21658c22067,22070
< #line 660
<   err = sock_create_kern((int )((struct sockaddr *)(& (mdev->net_conf)->my_addr))->sa_family,
<                          1, 6, & s_listen);
< #line 662
---
> #line 703
>   err = sock_create_kern((int )((struct sockaddr *)(& my_addr))->sa_family, 1, 6,
>                          & s_listen);
> #line 705
21660c22072
< #line 663
---
> #line 706
21662c22074
< #line 664
---
> #line 707
21667,21673c22079
< #line 667
<   timeo = (mdev->net_conf)->try_connect_int * 250;
< #line 668
<   tmp___0 = random32();
< #line 668
<   timeo = ((int )tmp___0 & 1 ? timeo / 7 : - timeo / 7) + timeo;
< #line 670
---
> #line 710
21675,21681c22081,22083
< #line 671
<   (s_listen->sk)->sk_rcvtimeo = (long )timeo;
< #line 672
<   (s_listen->sk)->sk_sndtimeo = (long )timeo;
< #line 673
<   drbd_setbufsize(s_listen, (unsigned int )(mdev->net_conf)->sndbuf_size, (unsigned int )(mdev->net_conf)->rcvbuf_size);
< #line 676
---
> #line 711
>   drbd_setbufsize(s_listen, (unsigned int )sndbuf_size, (unsigned int )rcvbuf_size);
> #line 713
21683,21686c22085,22087
< #line 677
<   err = (*((s_listen->ops)->bind))(s_listen, (struct sockaddr *)(& (mdev->net_conf)->my_addr),
<                                    (mdev->net_conf)->my_addr_len);
< #line 680
---
> #line 714
>   err = (*((s_listen->ops)->bind))(s_listen, (struct sockaddr *)(& my_addr), my_addr_len);
> #line 715
21688c22089
< #line 681
---
> #line 716
21693,21694c22094,22118
< #line 683
<   err = drbd_accept(mdev, & what, s_listen, & s_estab);
---
> #line 718
>   ad->s_listen = s_listen;
> #line 719
>   _raw_write_lock_bh(& (s_listen->sk)->sk_callback_lock);
> #line 720
>   ad->original_sk_state_change = (s_listen->sk)->sk_state_change;
> #line 721
>   (s_listen->sk)->sk_state_change = & drbd_incoming_connection;
> #line 722
>   (s_listen->sk)->sk_user_data = (void *)ad;
> #line 723
>   _raw_write_unlock_bh(& (s_listen->sk)->sk_callback_lock);
> #line 725
>   what = "listen";
> #line 726
>   err = (*((s_listen->ops)->listen))(s_listen, 5);
> #line 727
>   if (err < 0) {
> #line 728
>     goto out;
>   } else {
> 
>   }
> #line 730
>   return (0);
21696c22120
< #line 686
---
> #line 732
21698c22122
< #line 687
---
> #line 733
21703c22127
< #line 688
---
> #line 734
21705c22129
< #line 689
---
> #line 735
21707,21710c22131,22133
< #line 690
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s failed, err = %d\n",
<               what, err);
< #line 691
---
> #line 736
>       printk("\vd-con %s: %s failed, err = %d\n", tconn->name, what, err);
> #line 737
21712,21714c22135,22137
< #line 691
<       val.ldv_40583.conn = 1U;
< #line 691
---
> #line 737
>       val.ldv_40604.conn = 1U;
> #line 737
21716,21719c22139,22142
< #line 691
<       mask.ldv_40583.conn = 31U;
< #line 691
<       drbd_force_state(mdev, mask, val);
---
> #line 737
>       mask.ldv_40604.conn = 31U;
> #line 737
>       conn_request_state(tconn, mask, val, CS_HARD);
21726,21729c22149,22151
< #line 694
<   put_net_conf(mdev);
< #line 696
<   return (s_estab);
---
> #line 741
>   return (-5);
> }
21730a22153,22168
> #line 744 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void unregister_state_change(struct sock *sk , struct accept_wait_data *ad ) 
> { 
> 
> 
>   {
> #line 746
>   _raw_write_lock_bh(& sk->sk_callback_lock);
> #line 747
>   sk->sk_state_change = ad->original_sk_state_change;
> #line 748
>   sk->sk_user_data = 0;
> #line 749
>   _raw_write_unlock_bh(& sk->sk_callback_lock);
> #line 750
>   return;
21732,21733c22170,22172
< #line 699 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_send_fp(struct drbd_conf *mdev , struct socket *sock , enum drbd_packets cmd ) 
---
> }
> #line 752 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static struct socket *drbd_wait_for_connect(struct drbd_tconn *tconn , struct accept_wait_data *ad ) 
21735c22174,22180
<   struct p_header80 *h ;
---
>   int timeo ;
>   int connect_int ;
>   int err ;
>   struct socket *s_estab ;
>   struct net_conf *nc ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
21736a22182,22186
>   int tmp___0 ;
>   u32 tmp___1 ;
>   long tmp___2 ;
>   union drbd_state val ;
>   union drbd_state mask ;
21739,21744c22189,22281
< #line 702
<   h = & mdev->data.sbuf.header.h80;
< #line 704
<   tmp = _drbd_send_cmd(mdev, sock, cmd, h, 8UL, 0U);
< #line 704
<   return (tmp);
---
> #line 754
>   err = 0;
> #line 755
>   s_estab = 0;
> #line 758
>   rcu_read_lock();
> #line 759
>   _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 759
>   tmp = debug_lockdep_rcu_enabled();
> #line 759
>   if (tmp != 0 && ! __warned) {
> #line 759
>     tmp___0 = rcu_read_lock_held();
> #line 759
>     if (tmp___0 == 0 && 1) {
> #line 759
>       __warned = 1;
> #line 759
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              759, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 759
>   nc = _________p1;
> #line 760
>   if ((unsigned long )nc == (unsigned long )((struct net_conf *)0)) {
> #line 761
>     rcu_read_unlock();
> #line 762
>     return (0);
>   } else {
> 
>   }
> #line 764
>   connect_int = (int )nc->connect_int;
> #line 765
>   rcu_read_unlock();
> #line 767
>   timeo = connect_int * 250;
> #line 768
>   tmp___1 = random32();
> #line 768
>   timeo = ((int )tmp___1 & 1 ? timeo / 7 : - timeo / 7) + timeo;
> #line 770
>   tmp___2 = wait_for_completion_interruptible_timeout(& ad->door_bell, (unsigned long )timeo);
> #line 770
>   err = (int )tmp___2;
> #line 771
>   if (err <= 0) {
> #line 772
>     return (0);
>   } else {
> 
>   }
> #line 774
>   err = kernel_accept(ad->s_listen, & s_estab, 0);
> #line 775
>   if (err < 0) {
> #line 776
>     if ((err != -11 && err != -4) && err != -512) {
> #line 777
>       printk("\vd-con %s: accept failed, err = %d\n", tconn->name, err);
> #line 778
>       val.i = 0U;
> #line 778
>       val.ldv_40604.conn = 1U;
> #line 778
>       mask.i = 0U;
> #line 778
>       mask.ldv_40604.conn = 31U;
> #line 778
>       conn_request_state(tconn, mask, val, CS_HARD);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 782
>   if ((unsigned long )s_estab != (unsigned long )((struct socket *)0)) {
> #line 783
>     unregister_state_change(s_estab->sk, ad);
>   } else {
> 
>   }
> #line 785
>   return (s_estab);
> }
21745a22283,22305
> #line 788
> static int decode_header(struct drbd_tconn *tconn , void *header , struct packet_info *pi ) ;
> #line 790 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int send_first_packet(struct drbd_tconn *tconn , struct drbd_socket *sock ,
>                              enum drbd_packet cmd ) 
> { 
>   void *tmp ;
>   int tmp___0 ;
> 
>   {
> #line 793
>   tmp = conn_prepare_command(tconn, sock);
> #line 793
>   if ((unsigned long )tmp == (unsigned long )((void *)0)) {
> #line 794
>     return (-5);
>   } else {
> 
>   }
> #line 795
>   tmp___0 = conn_send_command(tconn, sock, cmd, 0U, 0, 0U);
> #line 795
>   return (tmp___0);
21747,21748c22307,22309
< #line 707 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static enum drbd_packets drbd_recv_fp(struct drbd_conf *mdev , struct socket *sock ) 
---
> }
> #line 798 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_first_packet(struct drbd_tconn *tconn , struct socket *sock ) 
21750,21752c22311,22314
<   struct p_header80 *h ;
<   int rr ;
<   __u16 tmp ;
---
>   unsigned int header_size ;
>   unsigned int tmp ;
>   struct packet_info pi ;
>   int err ;
21755,21764c22317,22333
< #line 709
<   h = & mdev->data.rbuf.header.h80;
< #line 712
<   rr = drbd_recv_short(mdev, sock, (void *)h, 8UL, 0);
< #line 714
<   if (rr == 8 && h->magic == 1728214147U) {
< #line 715
<     tmp = __fswab16((int )h->command);
< #line 715
<     return ((enum drbd_packets )tmp);
---
> #line 800
>   tmp = drbd_header_size(tconn);
> #line 800
>   header_size = tmp;
> #line 804
>   err = drbd_recv_short(sock, tconn->data.rbuf, (size_t )header_size, 0);
> #line 805
>   if ((unsigned int )err != header_size) {
> #line 806
>     if (err >= 0) {
> #line 807
>       err = -5;
>     } else {
> 
>     }
> #line 808
>     return (err);
21768,21769c22337,22347
< #line 717
<   return (65535);
---
> #line 810
>   err = decode_header(tconn, tconn->data.rbuf, & pi);
> #line 811
>   if (err != 0) {
> #line 812
>     return (err);
>   } else {
> 
>   }
> #line 813
>   return ((int )pi.cmd);
21772,21773c22350,22351
< #line 725 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_socket_okay(struct drbd_conf *mdev , struct socket **sock ) 
---
> #line 820 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_socket_okay(struct socket **sock ) 
21779c22357
< #line 730
---
> #line 825
21781c22359
< #line 731
---
> #line 826
21786,21788c22364,22366
< #line 733
<   rr = drbd_recv_short(mdev, *sock, (void *)(& tb), 4UL, 66);
< #line 735
---
> #line 828
>   rr = drbd_recv_short(*sock, (void *)(& tb), 4UL, 66);
> #line 830
21790c22368
< #line 736
---
> #line 831
21793c22371
< #line 738
---
> #line 833
21795c22373
< #line 739
---
> #line 834
21797c22375
< #line 740
---
> #line 835
21802,21803c22380,22381
< #line 752 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_connect(struct drbd_conf *mdev ) 
---
> #line 840 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> int drbd_connected(struct drbd_conf *mdev ) 
21805,21808c22383,22433
<   struct socket *s ;
<   struct socket *sock ;
<   struct socket *msock ;
<   int try ;
---
>   int err ;
> 
>   {
> #line 844
>   atomic_set(& mdev->packet_seq, 0);
> #line 845
>   mdev->peer_seq = 0U;
> #line 847
>   mdev->state_mutex = (mdev->tconn)->agreed_pro_version <= 99 ? & (mdev->tconn)->cstate_mutex : & mdev->own_state_mutex;
> #line 851
>   err = drbd_send_sync_param(mdev);
> #line 852
>   if (err == 0) {
> #line 853
>     err = drbd_send_sizes(mdev, 0, 0);
>   } else {
> 
>   }
> #line 854
>   if (err == 0) {
> #line 855
>     err = drbd_send_uuids(mdev);
>   } else {
> 
>   }
> #line 856
>   if (err == 0) {
> #line 857
>     err = drbd_send_current_state(mdev);
>   } else {
> 
>   }
> #line 858
>   clear_bit(2, (unsigned long volatile   *)(& mdev->flags));
> #line 859
>   clear_bit(16, (unsigned long volatile   *)(& mdev->flags));
> #line 860
>   mod_timer(& mdev->request_timer, (unsigned long )jiffies + 250UL);
> #line 861
>   return (err);
> }
> }
> #line 872 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int conn_connect(struct drbd_tconn *tconn ) 
> { 
>   struct drbd_socket sock ;
>   struct drbd_socket msock ;
>   struct drbd_conf *mdev ;
>   struct net_conf *nc ;
>   int vnr ;
>   int timeout ;
21810a22436
>   bool discard_my_data ;
21811a22438
>   struct accept_wait_data ad ;
21814c22441,22443
<   int tmp ;
---
>   enum drbd_state_rv tmp ;
>   struct lock_class_key __key ;
>   struct lock_class_key __key___0 ;
21816,21823c22445,22456
<   enum drbd_packets tmp___1 ;
<   u32 tmp___2 ;
<   struct task_struct *tmp___3 ;
<   enum drbd_thread_state tmp___4 ;
<   struct task_struct *tmp___5 ;
<   int tmp___6 ;
<   int tmp___7 ;
<   long tmp___8 ;
---
>   struct socket *s ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
>   int fp ;
>   int tmp___4 ;
>   u32 tmp___5 ;
>   struct task_struct *tmp___6 ;
>   enum drbd_thread_state tmp___7 ;
>   struct task_struct *tmp___8 ;
21826c22459,22469
<   union drbd_state __ns ;
---
>   struct net_conf *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___11 ;
>   int tmp___12 ;
>   long tmp___13 ;
>   int tmp___14 ;
>   int tmp___15 ;
>   void *tmp___16 ;
>   void *tmp___17 ;
>   union drbd_state val___0 ;
>   union drbd_state mask___0 ;
21829,21840c22472,22484
< #line 758
<   if ((unsigned long )mdev->data.socket != (unsigned long )((struct socket *)0)) {
< #line 758
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !mdev->data.socket ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             758);
<   } else {
< 
<   }
< #line 760
<   drbd_clear_flag(mdev, DISCONNECT_SENT);
< #line 761
---
> #line 882
>   init_completion(& ad.door_bell);
> #line 882
>   ad.tconn = tconn;
> #line 882
>   ad.s_listen = 0;
> #line 882
>   ad.door_bell = ad.door_bell;
> #line 882
>   ad.original_sk_state_change = 0;
> #line 885
>   clear_bit(12, (unsigned long volatile   *)(& tconn->flags));
> #line 886
21842,21844c22486,22488
< #line 761
<   val.ldv_40583.conn = 8U;
< #line 761
---
> #line 886
>   val.ldv_40604.conn = 8U;
> #line 886
21846,21852c22490,22496
< #line 761
<   mask.ldv_40583.conn = 31U;
< #line 761
<   tmp = drbd_request_state(mdev, mask, val);
< #line 761
<   if (tmp <= 0) {
< #line 762
---
> #line 886
>   mask.ldv_40604.conn = 31U;
> #line 886
>   tmp = conn_request_state(tconn, mask, val, CS_VERBOSE);
> #line 886
>   if ((int )tmp <= 0) {
> #line 887
21857,21870c22501,22524
< #line 764
<   sock = 0;
< #line 765
<   msock = 0;
<   ldv_52129: 
< #line 768
<   try = 0;
<   ldv_52121: 
< #line 770
<   s = drbd_try_connect(mdev);
< #line 771
<   if ((unsigned long )s != (unsigned long )((struct socket *)0)) {
< #line 772
<     goto ldv_52120;
---
> #line 889
>   __mutex_init(& sock.mutex, "&sock.mutex", & __key);
> #line 890
>   sock.sbuf = tconn->data.sbuf;
> #line 891
>   sock.rbuf = tconn->data.rbuf;
> #line 892
>   sock.socket = 0;
> #line 893
>   __mutex_init(& msock.mutex, "&msock.mutex", & __key___0);
> #line 894
>   msock.sbuf = tconn->meta.sbuf;
> #line 895
>   msock.rbuf = tconn->meta.rbuf;
> #line 896
>   msock.socket = 0;
> #line 899
>   tconn->agreed_pro_version = 80;
> #line 901
>   tmp___0 = prepare_listen_socket(tconn, & ad);
> #line 901
>   if (tmp___0 != 0) {
> #line 902
>     return (0);
21872,21878d22525
< #line 771
<     try = try + 1;
< #line 771
<     if (try > 2) {
< #line 772
<       goto ldv_52120;
<     } else {
21880d22526
<     }
21882,21887c22528,22531
< #line 774
<   schedule_timeout_interruptible(25L);
< #line 775
<   goto ldv_52121;
<   ldv_52120: ;
< #line 777
---
>   ldv_52745: 
> #line 907
>   s = drbd_try_connect(tconn);
> #line 908
21889,21896c22533,22538
< #line 778
<     if ((unsigned long )sock == (unsigned long )((struct socket *)0)) {
< #line 779
<       drbd_send_fp(mdev, s, P_HAND_SHAKE_S);
< #line 780
<       sock = s;
< #line 781
<       s = 0;
---
> #line 909
>     if ((unsigned long )sock.socket == (unsigned long )((struct socket *)0)) {
> #line 910
>       sock.socket = s;
> #line 911
>       send_first_packet(tconn, & sock, P_INITIAL_DATA);
21898,21907c22540,22547
< #line 782
<     if ((unsigned long )msock == (unsigned long )((struct socket *)0)) {
< #line 783
<       drbd_clear_flag(mdev, DISCARD_CONCURRENT);
< #line 784
<       drbd_send_fp(mdev, s, P_HAND_SHAKE_M);
< #line 785
<       msock = s;
< #line 786
<       s = 0;
---
> #line 912
>     if ((unsigned long )msock.socket == (unsigned long )((struct socket *)0)) {
> #line 913
>       clear_bit(1, (unsigned long volatile   *)(& tconn->flags));
> #line 914
>       msock.socket = s;
> #line 915
>       send_first_packet(tconn, & msock, P_INITIAL_META);
21909,21911c22549,22551
< #line 788
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Logic error in drbd_connect()\n");
< #line 789
---
> #line 917
>       printk("\vd-con %s: Logic error in conn_connect()\n", tconn->name);
> #line 918
21917,21927c22557,22596
< #line 793
<   if ((unsigned long )sock != (unsigned long )((struct socket *)0) && (unsigned long )msock != (unsigned long )((struct socket *)0)) {
< #line 794
<     schedule_timeout_interruptible((long )(((mdev->net_conf)->ping_timeo * 250) / 10));
< #line 795
<     ok = drbd_socket_okay(mdev, & sock);
< #line 796
<     tmp___0 = drbd_socket_okay(mdev, & msock);
< #line 796
<     ok = tmp___0 != 0 && ok != 0;
< #line 797
---
> #line 922
>   if ((unsigned long )sock.socket != (unsigned long )((struct socket *)0) && (unsigned long )msock.socket != (unsigned long )((struct socket *)0)) {
> #line 923
>     rcu_read_lock();
> #line 924
>     _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 924
>     tmp___1 = debug_lockdep_rcu_enabled();
> #line 924
>     if (tmp___1 != 0 && ! __warned) {
> #line 924
>       tmp___2 = rcu_read_lock_held();
> #line 924
>       if (tmp___2 == 0 && 1) {
> #line 924
>         __warned = 1;
> #line 924
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                                924, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 924
>     nc = _________p1;
> #line 925
>     timeout = (int )((nc->ping_timeo * 250U) / 10U);
> #line 926
>     rcu_read_unlock();
> #line 927
>     schedule_timeout_interruptible((long )timeout);
> #line 928
>     ok = drbd_socket_okay(& sock.socket);
> #line 929
>     tmp___3 = drbd_socket_okay(& msock.socket);
> #line 929
>     ok = tmp___3 != 0 && ok != 0;
> #line 930
21929,21930c22598,22599
< #line 798
<       goto ldv_52123;
---
> #line 931
>       goto ldv_52737;
21938,21940c22607,22609
< #line 802
<   s = drbd_wait_for_connect(mdev);
< #line 803
---
> #line 935
>   s = drbd_wait_for_connect(tconn, & ad);
> #line 936
21942,21951c22611,22620
< #line 804
<     tmp___1 = drbd_recv_fp(mdev, s);
< #line 804
<     try = (int )tmp___1;
< #line 805
<     drbd_socket_okay(mdev, & sock);
< #line 806
<     drbd_socket_okay(mdev, & msock);
< #line 807
<     switch (try) {
---
> #line 937
>     tmp___4 = receive_first_packet(tconn, s);
> #line 937
>     fp = tmp___4;
> #line 938
>     drbd_socket_okay(& sock.socket);
> #line 939
>     drbd_socket_okay(& msock.socket);
> #line 940
>     switch (fp) {
21953,21958c22622,22631
< #line 809
<     if ((unsigned long )sock != (unsigned long )((struct socket *)0)) {
< #line 810
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "initial packet S crossed\n");
< #line 811
<       sock_release(sock);
---
> #line 942
>     if ((unsigned long )sock.socket != (unsigned long )((struct socket *)0)) {
> #line 943
>       printk("\fd-con %s: initial packet S crossed\n", tconn->name);
> #line 944
>       sock_release(sock.socket);
> #line 945
>       sock.socket = s;
> #line 946
>       goto randomize;
21962,21972c22635,22651
< #line 813
<     sock = s;
< #line 814
<     goto ldv_52126;
<     case 65521: ;
< #line 816
<     if ((unsigned long )msock != (unsigned long )((struct socket *)0)) {
< #line 817
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "initial packet M crossed\n");
< #line 818
<       sock_release(msock);
---
> #line 948
>     sock.socket = s;
> #line 949
>     goto ldv_52742;
>     case 65521: 
> #line 951
>     set_bit(1U, (unsigned long volatile   *)(& tconn->flags));
> #line 952
>     if ((unsigned long )msock.socket != (unsigned long )((struct socket *)0)) {
> #line 953
>       printk("\fd-con %s: initial packet M crossed\n", tconn->name);
> #line 954
>       sock_release(msock.socket);
> #line 955
>       msock.socket = s;
> #line 956
>       goto randomize;
21976,21981c22655,22658
< #line 820
<     msock = s;
< #line 821
<     drbd_set_flag(mdev, DISCARD_CONCURRENT);
< #line 822
<     goto ldv_52126;
---
> #line 958
>     msock.socket = s;
> #line 959
>     goto ldv_52742;
21983,21985c22660,22662
< #line 824
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Error receiving initial packet\n");
< #line 825
---
> #line 961
>     printk("\fd-con %s: Error receiving initial packet\n", tconn->name);
> #line 962
21987,21991c22664,22669
< #line 826
<     tmp___2 = random32();
< #line 826
<     if ((int )tmp___2 & 1) {
< #line 827
---
>     randomize: 
> #line 964
>     tmp___5 = random32();
> #line 964
>     if ((int )tmp___5 & 1) {
> #line 965
21997c22675
<     ldv_52126: ;
---
>     ldv_52742: ;
22001,22003c22679,22681
< #line 831
<   if ((int )mdev->state.ldv_40583.conn <= 1) {
< #line 832
---
> #line 969
>   if ((unsigned int )tconn->cstate <= 1U) {
> #line 970
22008,22018c22686,22696
< #line 833
<   tmp___5 = get_current();
< #line 833
<   tmp___6 = signal_pending(tmp___5);
< #line 833
<   if (tmp___6 != 0) {
< #line 834
<     tmp___3 = get_current();
< #line 834
<     flush_signals(tmp___3);
< #line 835
---
> #line 971
>   tmp___8 = get_current();
> #line 971
>   tmp___9 = signal_pending(tmp___8);
> #line 971
>   if (tmp___9 != 0) {
> #line 972
>     tmp___6 = get_current();
> #line 972
>     flush_signals(tmp___6);
> #line 973
22020,22024c22698,22702
< #line 836
<     tmp___4 = get_t_state(& mdev->receiver);
< #line 836
<     if ((unsigned int )tmp___4 == 2U) {
< #line 837
---
> #line 974
>     tmp___7 = get_t_state(& tconn->receiver);
> #line 974
>     if ((unsigned int )tmp___7 == 2U) {
> #line 975
22032,22044c22710,22720
< #line 840
<   if ((unsigned long )sock != (unsigned long )((struct socket *)0) && (unsigned long )msock != (unsigned long )((struct socket *)0)) {
< #line 841
<     ok = drbd_socket_okay(mdev, & sock);
< #line 842
<     tmp___7 = drbd_socket_okay(mdev, & msock);
< #line 842
<     ok = tmp___7 != 0 && ok != 0;
< #line 843
<     if (ok != 0) {
< #line 844
<       goto ldv_52123;
<     } else {
---
> #line 978
>   ok = drbd_socket_okay(& sock.socket);
> #line 979
>   tmp___10 = drbd_socket_okay(& msock.socket);
> #line 979
>   ok = tmp___10 != 0 && ok != 0;
> #line 980
>   if (ok == 0) {
> #line 981
>     goto ldv_52745;
>   } else {
22046c22722,22727
<     }
---
>   }
>   ldv_52737: ;
> #line 982
>   if ((unsigned long )ad.s_listen != (unsigned long )((struct socket *)0)) {
> #line 983
>     sock_release(ad.s_listen);
22050,22090c22731,22762
< #line 846
<   goto ldv_52129;
<   ldv_52123: 
< #line 848
<   (msock->sk)->__sk_common.skc_reuse = 1U;
< #line 849
<   (sock->sk)->__sk_common.skc_reuse = 1U;
< #line 851
<   (sock->sk)->sk_allocation = 16U;
< #line 852
<   (msock->sk)->sk_allocation = 16U;
< #line 854
<   (sock->sk)->sk_priority = 4U;
< #line 855
<   (msock->sk)->sk_priority = 6U;
< #line 862
<   tmp___8 = (long )(((mdev->net_conf)->ping_timeo * 1000) / 10);
< #line 862
<   (sock->sk)->sk_rcvtimeo = tmp___8;
< #line 862
<   (sock->sk)->sk_sndtimeo = tmp___8;
< #line 865
<   (msock->sk)->sk_sndtimeo = (long )(((mdev->net_conf)->timeout * 250) / 10);
< #line 866
<   (msock->sk)->sk_rcvtimeo = (long )((mdev->net_conf)->ping_int * 250);
< #line 870
<   drbd_tcp_nodelay(sock);
< #line 871
<   drbd_tcp_nodelay(msock);
< #line 873
<   mdev->data.socket = sock;
< #line 874
<   mdev->meta.socket = msock;
< #line 875
<   mdev->last_received = jiffies;
< #line 877
<   if ((unsigned long )mdev->asender.task != (unsigned long )((struct task_struct *)0)) {
< #line 877
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->asender.task == NULL ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             877);
---
> #line 985
>   ((sock.socket)->sk)->__sk_common.skc_reuse = 1U;
> #line 986
>   ((msock.socket)->sk)->__sk_common.skc_reuse = 1U;
> #line 988
>   ((sock.socket)->sk)->sk_allocation = 16U;
> #line 989
>   ((msock.socket)->sk)->sk_allocation = 16U;
> #line 991
>   ((sock.socket)->sk)->sk_priority = 4U;
> #line 992
>   ((msock.socket)->sk)->sk_priority = 6U;
> #line 999
>   rcu_read_lock();
> #line 1000
>   _________p1___0 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 1000
>   tmp___11 = debug_lockdep_rcu_enabled();
> #line 1000
>   if (tmp___11 != 0 && ! __warned___0) {
> #line 1000
>     tmp___12 = rcu_read_lock_held();
> #line 1000
>     if (tmp___12 == 0 && 1) {
> #line 1000
>       __warned___0 = 1;
> #line 1000
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              1000, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
22094,22096c22766,22796
< #line 879
<   h = drbd_do_handshake(mdev);
< #line 880
---
> #line 1000
>   nc = _________p1___0;
> #line 1002
>   tmp___13 = (long )((nc->ping_timeo * 1000U) / 10U);
> #line 1002
>   ((sock.socket)->sk)->sk_rcvtimeo = tmp___13;
> #line 1002
>   ((sock.socket)->sk)->sk_sndtimeo = tmp___13;
> #line 1005
>   ((msock.socket)->sk)->sk_rcvtimeo = (long )(nc->ping_int * 250U);
> #line 1006
>   timeout = (int )((nc->timeout * 250U) / 10U);
> #line 1007
>   discard_my_data = (int )((signed char )nc->discard_my_data) != 0;
> #line 1008
>   rcu_read_unlock();
> #line 1010
>   ((msock.socket)->sk)->sk_sndtimeo = (long )timeout;
> #line 1014
>   drbd_tcp_nodelay(sock.socket);
> #line 1015
>   drbd_tcp_nodelay(msock.socket);
> #line 1017
>   tconn->data.socket = sock.socket;
> #line 1018
>   tconn->meta.socket = msock.socket;
> #line 1019
>   tconn->last_received = jiffies;
> #line 1021
>   h = drbd_do_features(tconn);
> #line 1022
22098c22798
< #line 881
---
> #line 1023
22103,22108c22803,22808
< #line 883
<   if ((unsigned long )mdev->cram_hmac_tfm != (unsigned long )((struct crypto_hash *)0)) {
< #line 885
<     tmp___9 = drbd_do_auth(mdev);
< #line 885
<     switch (tmp___9) {
---
> #line 1025
>   if ((unsigned long )tconn->cram_hmac_tfm != (unsigned long )((struct crypto_hash *)0)) {
> #line 1027
>     tmp___14 = drbd_do_auth(tconn);
> #line 1027
>     switch (tmp___14) {
22110,22112c22810,22812
< #line 887
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Authentication of peer failed\n");
< #line 888
---
> #line 1029
>     printk("\vd-con %s: Authentication of peer failed\n", tconn->name);
> #line 1030
22115,22117c22815,22817
< #line 890
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Authentication of peer failed, trying again.\n");
< #line 891
---
> #line 1032
>     printk("\vd-con %s: Authentication of peer failed, trying again.\n", tconn->name);
> #line 1033
22123,22135c22823,22831
< #line 895
<   (sock->sk)->sk_sndtimeo = (long )(((mdev->net_conf)->timeout * 250) / 10);
< #line 896
<   (sock->sk)->sk_rcvtimeo = 9223372036854775807L;
< #line 898
<   atomic_set(& mdev->packet_seq, 0);
< #line 899
<   mdev->peer_seq = 0U;
< #line 901
<   tmp___10 = drbd_send_protocol(mdev);
< #line 901
<   if (tmp___10 == -1) {
< #line 902
---
> #line 1037
>   ((tconn->data.socket)->sk)->sk_sndtimeo = (long )timeout;
> #line 1038
>   ((tconn->data.socket)->sk)->sk_rcvtimeo = 9223372036854775807L;
> #line 1040
>   tmp___15 = drbd_send_protocol(tconn);
> #line 1040
>   if (tmp___15 == -95) {
> #line 1041
22140,22165c22836,22877
< #line 903
<   drbd_set_flag(mdev, STATE_SENT);
< #line 904
<   drbd_send_sync_param(mdev, & mdev->sync_conf);
< #line 905
<   drbd_send_sizes(mdev, 0, 0);
< #line 906
<   drbd_send_uuids(mdev);
< #line 907
<   drbd_send_current_state(mdev);
< #line 908
<   drbd_clear_flag(mdev, USE_DEGR_WFC_T);
< #line 909
<   drbd_clear_flag(mdev, RESIZE_PENDING);
< #line 911
<   spin_lock_irq(& mdev->req_lock);
< #line 912
<   __ns.i = mdev->state.i;
< #line 912
<   __ns.ldv_40583.conn = 9U;
< #line 912
<   rv = _drbd_set_state(mdev, __ns, CS_VERBOSE, 0);
< #line 913
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) != 144U) {
< #line 914
<     drbd_clear_flag(mdev, STATE_SENT);
---
> #line 1043
>   set_bit(10U, (unsigned long volatile   *)(& tconn->flags));
> #line 1045
>   rcu_read_lock();
> #line 1046
>   vnr = 0;
> #line 1046
>   tmp___16 = idr_get_next(& tconn->volumes, & vnr);
> #line 1046
>   mdev = (struct drbd_conf *)tmp___16;
> #line 1046
>   goto ldv_52752;
>   ldv_52751: 
> #line 1047
>   kref_get(& mdev->kref);
> #line 1048
>   rcu_read_unlock();
> #line 1050
>   if ((int )discard_my_data) {
> #line 1051
>     set_bit(21U, (unsigned long volatile   *)(& mdev->flags));
>   } else {
> #line 1053
>     clear_bit(21, (unsigned long volatile   *)(& mdev->flags));
>   }
> #line 1055
>   drbd_connected(mdev);
> #line 1056
>   kref_put(& mdev->kref, & drbd_minor_destroy);
> #line 1057
>   rcu_read_lock();
> #line 1046
>   vnr = vnr + 1;
> #line 1046
>   tmp___17 = idr_get_next(& tconn->volumes, & vnr);
> #line 1046
>   mdev = (struct drbd_conf *)tmp___17;
>   ldv_52752: ;
> #line 1046
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1047
>     goto ldv_52751;
22169,22171c22881,22893
< #line 915
<   spin_unlock_irq(& mdev->req_lock);
< #line 917
---
> #line 1059
>   rcu_read_unlock();
> #line 1061
>   val___0.i = 0U;
> #line 1061
>   val___0.ldv_40604.conn = 9U;
> #line 1061
>   mask___0.i = 0U;
> #line 1061
>   mask___0.ldv_40604.conn = 31U;
> #line 1061
>   rv = conn_request_state(tconn, mask___0, val___0, CS_VERBOSE);
> #line 1062
22173c22895,22897
< #line 918
---
> #line 1063
>     clear_bit(10, (unsigned long volatile   *)(& tconn->flags));
> #line 1064
22178,22183c22902,22911
< #line 920
<   drbd_thread_start(& mdev->asender);
< #line 921
<   mod_timer(& mdev->request_timer, (unsigned long )jiffies + 250UL);
< #line 923
<   return (1);
---
> #line 1067
>   drbd_thread_start(& tconn->asender);
> #line 1069
>   mutex_lock_nested(& tconn->conf_update, 0U);
> #line 1074
>   (tconn->net_conf)->discard_my_data = 0;
> #line 1075
>   mutex_unlock(& tconn->conf_update);
> #line 1077
>   return (h);
22185,22188c22913,22916
< #line 926
<   if ((unsigned long )sock != (unsigned long )((struct socket *)0)) {
< #line 927
<     sock_release(sock);
---
> #line 1080
>   if ((unsigned long )ad.s_listen != (unsigned long )((struct socket *)0)) {
> #line 1081
>     sock_release(ad.s_listen);
22192,22195c22920,22923
< #line 928
<   if ((unsigned long )msock != (unsigned long )((struct socket *)0)) {
< #line 929
<     sock_release(msock);
---
> #line 1082
>   if ((unsigned long )sock.socket != (unsigned long )((struct socket *)0)) {
> #line 1083
>     sock_release(sock.socket);
22199c22927,22934
< #line 930
---
> #line 1084
>   if ((unsigned long )msock.socket != (unsigned long )((struct socket *)0)) {
> #line 1085
>     sock_release(msock.socket);
>   } else {
> 
>   }
> #line 1086
22203,22204c22938,22939
< #line 933 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_recv_header(struct drbd_conf *mdev , enum drbd_packets *cmd , unsigned int *packet_size ) 
---
> #line 1089 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int decode_header(struct drbd_tconn *tconn , void *header , struct packet_info *pi ) 
22206,22211c22941,22947
<   union p_header *h ;
<   int r ;
<   struct task_struct *tmp ;
<   int tmp___0 ;
<   long tmp___1 ;
<   __u16 tmp___2 ;
---
>   unsigned int header_size ;
>   unsigned int tmp ;
>   struct p_header100 *h ;
>   __u16 tmp___0 ;
>   __u16 tmp___1 ;
>   __u32 tmp___2 ;
>   struct p_header95 *h___0 ;
22213,22214c22949,22951
<   __u16 tmp___4 ;
<   __u32 tmp___5 ;
---
>   __u32 tmp___4 ;
>   struct p_header80 *h___1 ;
>   __u16 tmp___5 ;
22216,22218c22953
<   __u16 tmp___7 ;
<   __u32 tmp___8 ;
<   long tmp___9 ;
---
>   __u32 tmp___7 ;
22221,22237c22956,22969
< #line 935
<   h = & mdev->data.rbuf.header;
< #line 938
<   r = drbd_recv(mdev, (void *)h, 8UL);
< #line 939
<   tmp___1 = __builtin_expect(r != 8, 0L);
< #line 939
<   if (tmp___1 != 0L) {
< #line 940
<     tmp = get_current();
< #line 940
<     tmp___0 = signal_pending(tmp);
< #line 940
<     if (tmp___0 == 0) {
< #line 941
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "short read expecting header on sock: r=%d\n",
<                r);
---
> #line 1091
>   tmp = drbd_header_size(tconn);
> #line 1091
>   header_size = tmp;
> #line 1093
>   if (header_size == 16U && *((__be32 *)header) == 552345734U) {
> #line 1095
>     h = (struct p_header100 *)header;
> #line 1096
>     if (h->pad != 0U) {
> #line 1097
>       printk("\vd-con %s: Header padding is not zero\n", tconn->name);
> #line 1098
>       return (-22);
22241,22242c22973,23014
< #line 942
<     return (0);
---
> #line 1100
>     tmp___0 = __fswab16((int )h->volume);
> #line 1100
>     pi->vnr = (unsigned int )tmp___0;
> #line 1101
>     tmp___1 = __fswab16((int )h->command);
> #line 1101
>     pi->cmd = (enum drbd_packet )tmp___1;
> #line 1102
>     tmp___2 = __fswab32(h->length);
> #line 1102
>     pi->size = tmp___2;
>   } else
> #line 1103
>   if (header_size == 8U && (unsigned int )*((__be16 *)header) == 23171U) {
> #line 1105
>     h___0 = (struct p_header95 *)header;
> #line 1106
>     tmp___3 = __fswab16((int )h___0->command);
> #line 1106
>     pi->cmd = (enum drbd_packet )tmp___3;
> #line 1107
>     tmp___4 = __fswab32(h___0->length);
> #line 1107
>     pi->size = tmp___4;
> #line 1108
>     pi->vnr = 0U;
>   } else
> #line 1109
>   if (header_size == 8U && *((__be32 *)header) == 1728214147U) {
> #line 1111
>     h___1 = (struct p_header80 *)header;
> #line 1112
>     tmp___5 = __fswab16((int )h___1->command);
> #line 1112
>     pi->cmd = (enum drbd_packet )tmp___5;
> #line 1113
>     tmp___6 = __fswab16((int )h___1->length);
> #line 1113
>     pi->size = (unsigned int )tmp___6;
> #line 1114
>     pi->vnr = 0U;
22244c23016,23022
< 
---
> #line 1116
>     tmp___7 = __fswab32(*((__be32 *)header));
> #line 1116
>     printk("\vd-con %s: Wrong magic value 0x%08x in protocol version %d\n", tconn->name,
>            tmp___7, tconn->agreed_pro_version);
> #line 1119
>     return (-22);
22246,22268c23024,23047
< #line 945
<   tmp___9 = __builtin_expect(h->h80.magic == 1728214147U, 1L);
< #line 945
<   if (tmp___9 != 0L) {
< #line 946
<     tmp___2 = __fswab16((int )h->h80.command);
< #line 946
<     *cmd = (enum drbd_packets )tmp___2;
< #line 947
<     tmp___3 = __fswab16((int )h->h80.length);
< #line 947
<     *packet_size = (unsigned int )tmp___3;
<   } else
< #line 948
<   if ((unsigned int )h->h95.magic == 23171U) {
< #line 949
<     tmp___4 = __fswab16((int )h->h95.command);
< #line 949
<     *cmd = (enum drbd_packets )tmp___4;
< #line 950
<     tmp___5 = __fswab32(h->h95.length);
< #line 950
<     *packet_size = tmp___5;
---
> #line 1121
>   pi->data = header + (unsigned long )header_size;
> #line 1122
>   return (0);
> }
> }
> #line 1125 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_recv_header(struct drbd_tconn *tconn , struct packet_info *pi ) 
> { 
>   void *buffer ;
>   int err ;
>   unsigned int tmp ;
> 
>   {
> #line 1127
>   buffer = tconn->data.rbuf;
> #line 1130
>   tmp = drbd_header_size(tconn);
> #line 1130
>   err = drbd_recv_all_warn(tconn, buffer, (size_t )tmp);
> #line 1131
>   if (err != 0) {
> #line 1132
>     return (err);
22270,22280c23049
< #line 952
<     tmp___6 = __fswab16((int )h->h80.length);
< #line 952
<     tmp___7 = __fswab16((int )h->h80.command);
< #line 952
<     tmp___8 = __fswab32(h->h80.magic);
< #line 952
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "magic?? on data m: 0x%08x c: %d l: %d\n",
<             tmp___8, (int )tmp___7, (int )tmp___6);
< #line 956
<     return (0);
---
> 
22282,22285c23051,23056
< #line 958
<   mdev->last_received = jiffies;
< #line 960
<   return (1);
---
> #line 1134
>   err = decode_header(tconn, buffer, pi);
> #line 1135
>   tconn->last_received = jiffies;
> #line 1137
>   return (err);
22288,22289c23059,23060
< #line 963 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static void drbd_flush(struct drbd_conf *mdev ) 
---
> #line 1140 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void drbd_flush(struct drbd_tconn *tconn ) 
22292c23063,23067
<   int tmp ;
---
>   struct drbd_conf *mdev ;
>   int vnr ;
>   void *tmp ;
>   int tmp___0 ;
>   void *tmp___1 ;
22295,22310c23070,23089
< #line 967
<   if ((unsigned int )mdev->write_ordering > 1U) {
< #line 967
<     tmp = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 967
<     if (tmp != 0) {
< #line 968
<       rv = blkdev_issue_flush((mdev->ldev)->backing_bdev, 16U, 0);
< #line 970
<       if (rv != 0) {
< #line 971
<         _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "local disk flush failed with status %d\n",
<                   rv);
< #line 975
<         drbd_bump_write_ordering(mdev, WO_drain_io);
<       } else {
---
> #line 1146
>   if ((unsigned int )tconn->write_ordering > 1U) {
> #line 1147
>     rcu_read_lock();
> #line 1148
>     vnr = 0;
> #line 1148
>     tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 1148
>     mdev = (struct drbd_conf *)tmp;
> #line 1148
>     goto ldv_52782;
>     ldv_52781: 
> #line 1149
>     tmp___0 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1149
>     if (tmp___0 == 0) {
> #line 1150
>       goto ldv_52779;
>     } else {
22312,22314c23091,23132
<       }
< #line 977
<       put_ldev(mdev);
---
>     }
> #line 1151
>     kref_get(& mdev->kref);
> #line 1152
>     rcu_read_unlock();
> #line 1154
>     rv = blkdev_issue_flush((mdev->ldev)->backing_bdev, 16U, 0);
> #line 1156
>     if (rv != 0) {
> #line 1157
>       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "local disk flush failed with status %d\n",
>                 rv);
> #line 1161
>       drbd_bump_write_ordering(tconn, WO_drain_io);
>     } else {
> 
>     }
> #line 1163
>     put_ldev(mdev);
> #line 1164
>     kref_put(& mdev->kref, & drbd_minor_destroy);
> #line 1166
>     rcu_read_lock();
> #line 1167
>     if (rv != 0) {
> #line 1168
>       goto ldv_52780;
>     } else {
> 
>     }
>     ldv_52779: 
> #line 1148
>     vnr = vnr + 1;
> #line 1148
>     tmp___1 = idr_get_next(& tconn->volumes, & vnr);
> #line 1148
>     mdev = (struct drbd_conf *)tmp___1;
>     ldv_52782: ;
> #line 1148
>     if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1149
>       goto ldv_52781;
22317a23136,23138
>     ldv_52780: 
> #line 1170
>     rcu_read_unlock();
22321c23142
< #line 979
---
> #line 1172
22325,22326c23146,23147
< #line 987 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static enum finish_epoch drbd_may_finish_epoch(struct drbd_conf *mdev , struct drbd_epoch *epoch ,
---
> #line 1180 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static enum finish_epoch drbd_may_finish_epoch(struct drbd_tconn *tconn , struct drbd_epoch *epoch ,
22331a23153
>   struct list_head  const  *__mptr ;
22334,22337d23155
<   int tmp___1 ;
<   struct list_head  const  *__mptr ;
<   int tmp___2 ;
<   int tmp___3 ;
22340c23158
< #line 993
---
> #line 1186
22342,22345c23160,23163
< #line 995
<   spin_lock(& mdev->epoch_lock);
<   ldv_52164: 
< #line 997
---
> #line 1188
>   spin_lock(& tconn->epoch_lock);
>   ldv_52798: 
> #line 1190
22347c23165
< #line 999
---
> #line 1192
22349c23167
< #line 1001
---
> #line 1194
22352c23170
< #line 1003
---
> #line 1196
22354,22355c23172,23173
< #line 1004
<   goto ldv_52154;
---
> #line 1197
>   goto ldv_52792;
22357c23175
< #line 1006
---
> #line 1199
22359,22360c23177,23178
< #line 1007
<   goto ldv_52154;
---
> #line 1200
>   goto ldv_52792;
22362,22363c23180,23181
< #line 1010
<   goto ldv_52154;
---
> #line 1203
>   goto ldv_52792;
22365,22366c23183,23184
<   ldv_52154: ;
< #line 1013
---
>   ldv_52792: ;
> #line 1206
22368,22376c23186,23194
< #line 1013
<     tmp___2 = atomic_read((atomic_t const   *)(& epoch->active));
< #line 1013
<     if (tmp___2 == 0) {
< #line 1013
<       tmp___3 = constant_test_bit(0U, (unsigned long const volatile   *)(& epoch->flags));
< #line 1013
<       if (tmp___3 != 0 || ((unsigned int )ev & 32U) != 0U) {
< #line 1016
---
> #line 1206
>     tmp = atomic_read((atomic_t const   *)(& epoch->active));
> #line 1206
>     if (tmp == 0) {
> #line 1206
>       tmp___0 = constant_test_bit(0U, (unsigned long const volatile   *)(& epoch->flags));
> #line 1206
>       if (tmp___0 != 0 || ((unsigned int )ev & 32U) != 0U) {
> #line 1209
22378,22404c23196,23201
< #line 1017
<           spin_unlock(& mdev->epoch_lock);
< #line 1018
<           drbd_send_b_ack(mdev, epoch->barrier_nr, (u32 )epoch_size);
< #line 1019
<           spin_lock(& mdev->epoch_lock);
<         } else {
< 
<         }
< #line 1021
<         tmp___1 = constant_test_bit(0U, (unsigned long const volatile   *)(& epoch->flags));
< #line 1021
<         if (tmp___1 != 0) {
< #line 1022
<           atomic_dec(& mdev->unacked_cnt);
< #line 1022
<           tmp___0 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1022
<           if (tmp___0 < 0) {
< #line 1022
<             tmp = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1022
<             dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<                     "drbd_may_finish_epoch", 1022, tmp);
<           } else {
< 
<           }
---
> #line 1210
>           spin_unlock(& tconn->epoch_lock);
> #line 1211
>           drbd_send_b_ack(epoch->tconn, epoch->barrier_nr, (u32 )epoch_size);
> #line 1212
>           spin_lock(& tconn->epoch_lock);
22408,22410c23205,23207
< #line 1024
<         if ((unsigned long )mdev->current_epoch != (unsigned long )epoch) {
< #line 1025
---
> #line 1221
>         if ((unsigned long )tconn->current_epoch != (unsigned long )epoch) {
> #line 1222
22412,22414c23209,23211
< #line 1025
<           next_epoch = (struct drbd_epoch *)__mptr;
< #line 1026
---
> #line 1222
>           next_epoch = (struct drbd_epoch *)__mptr + 0xfffffffffffffff8UL;
> #line 1223
22416c23213
< #line 1027
---
> #line 1224
22418,22420c23215,23217
< #line 1028
<           mdev->epochs = mdev->epochs - 1U;
< #line 1029
---
> #line 1225
>           tconn->epochs = tconn->epochs - 1U;
> #line 1226
22422c23219
< #line 1031
---
> #line 1228
22424c23221
< #line 1032
---
> #line 1229
22430c23227
< #line 1034
---
> #line 1231
22432c23229
< #line 1035
---
> #line 1232
22434c23231
< #line 1037
---
> #line 1234
22436c23233
< #line 1038
---
> #line 1235
22441,22442d23237
< #line 1039
<           __wake_up(& mdev->ee_wait, 3U, 1, 0);
22453c23248
< #line 1043
---
> #line 1239
22455,22456c23250,23251
< #line 1044
<     goto ldv_52163;
---
> #line 1240
>     goto ldv_52797;
22460c23255
< #line 1046
---
> #line 1242
22462,22467c23257,23262
< #line 1047
<   goto ldv_52164;
<   ldv_52163: 
< #line 1049
<   spin_unlock(& mdev->epoch_lock);
< #line 1051
---
> #line 1243
>   goto ldv_52798;
>   ldv_52797: 
> #line 1245
>   spin_unlock(& tconn->epoch_lock);
> #line 1247
22471,22472c23266,23267
< #line 1059 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< void drbd_bump_write_ordering(struct drbd_conf *mdev , enum write_ordering_e wo ) 
---
> #line 1255 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> void drbd_bump_write_ordering(struct drbd_tconn *tconn , enum write_ordering_e wo ) 
22473a23269,23270
>   struct disk_conf *dc ;
>   struct drbd_conf *mdev ;
22474a23272
>   int vnr ;
22477a23276,23282
>   void *tmp ;
>   int tmp___0 ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___1 ;
>   int tmp___2 ;
>   void *tmp___3 ;
22480c23285
< #line 1062
---
> #line 1261
22482c23287
< #line 1062
---
> #line 1261
22484c23289
< #line 1062
---
> #line 1261
22486,22488c23291,23293
< #line 1068
<   pwo = mdev->write_ordering;
< #line 1069
---
> #line 1267
>   pwo = tconn->write_ordering;
> #line 1268
22490c23295
< #line 1069
---
> #line 1268
22492c23297
< #line 1069
---
> #line 1268
22494,22496c23299,23344
< #line 1070
<   if ((unsigned int )wo == 2U && (unsigned int )*((unsigned char *)mdev->ldev + 444UL) != 0U) {
< #line 1071
---
> #line 1269
>   rcu_read_lock();
> #line 1270
>   vnr = 0;
> #line 1270
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 1270
>   mdev = (struct drbd_conf *)tmp;
> #line 1270
>   goto ldv_52816;
>   ldv_52815: 
> #line 1271
>   tmp___0 = _get_ldev_if_state(mdev, D_ATTACHING);
> #line 1271
>   if (tmp___0 == 0) {
> #line 1272
>     goto ldv_52811;
>   } else {
> 
>   }
> #line 1273
>   _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 1273
>   tmp___1 = debug_lockdep_rcu_enabled();
> #line 1273
>   if (tmp___1 != 0 && ! __warned) {
> #line 1273
>     tmp___2 = rcu_read_lock_held();
> #line 1273
>     if (tmp___2 == 0 && 1) {
> #line 1273
>       __warned = 1;
> #line 1273
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              1273, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1273
>   dc = _________p1;
> #line 1275
>   if ((unsigned int )wo == 2U && (int )((signed char )dc->disk_flushes) == 0) {
> #line 1276
22501,22503c23349,23351
< #line 1072
<   if ((unsigned int )wo == 1U && (unsigned int )*((unsigned char *)mdev->ldev + 452UL) != 0U) {
< #line 1073
---
> #line 1277
>   if ((unsigned int )wo == 1U && (int )((signed char )dc->disk_drain) == 0) {
> #line 1278
22508,22514c23356,23369
< #line 1074
<   mdev->write_ordering = wo;
< #line 1075
<   if ((unsigned int )mdev->write_ordering != (unsigned int )pwo || (unsigned int )wo == 2U) {
< #line 1076
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Method to ensure write ordering: %s\n",
<               write_ordering_str[(unsigned int )mdev->write_ordering]);
---
> #line 1279
>   put_ldev(mdev);
>   ldv_52811: 
> #line 1270
>   vnr = vnr + 1;
> #line 1270
>   tmp___3 = idr_get_next(& tconn->volumes, & vnr);
> #line 1270
>   mdev = (struct drbd_conf *)tmp___3;
>   ldv_52816: ;
> #line 1270
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1271
>     goto ldv_52815;
22518c23373,23384
< #line 1077
---
> #line 1281
>   rcu_read_unlock();
> #line 1282
>   tconn->write_ordering = wo;
> #line 1283
>   if ((unsigned int )tconn->write_ordering != (unsigned int )pwo || (unsigned int )wo == 2U) {
> #line 1284
>     printk("\016d-con %s: Method to ensure write ordering: %s\n", tconn->name, write_ordering_str[(unsigned int )tconn->write_ordering]);
>   } else {
> 
>   }
> #line 1285
22522,22524c23388,23390
< #line 1096 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< int drbd_submit_ee(struct drbd_conf *mdev , struct drbd_epoch_entry *e , unsigned int const   rw ,
<                    int const   fault_type ) 
---
> #line 1304 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> int drbd_submit_peer_request(struct drbd_conf *mdev , struct drbd_peer_request *peer_req ,
>                              unsigned int const   rw , int const   fault_type ) 
22541c23407
< #line 1099
---
> #line 1308
22543,22549c23409,23415
< #line 1101
<   page = e->pages;
< #line 1102
<   sector = e->sector;
< #line 1103
<   ds = e->size;
< #line 1104
---
> #line 1310
>   page = peer_req->pages;
> #line 1311
>   sector = peer_req->i.sector;
> #line 1312
>   ds = peer_req->i.size;
> #line 1313
22551c23417
< #line 1105
---
> #line 1314
22553c23419
< #line 1106
---
> #line 1315
22556c23422
< #line 1117
---
> #line 1326
22558c23424
< #line 1118
---
> #line 1327
22560c23426
< #line 1119
---
> #line 1328
22562c23428
< #line 1120
---
> #line 1329
22567c23433
< #line 1123
---
> #line 1332
22569c23435
< #line 1124
---
> #line 1333
22571c23437
< #line 1125
---
> #line 1334
22573,22577c23439,23443
< #line 1126
<   bio->bi_private = (void *)e;
< #line 1127
<   bio->bi_end_io = & drbd_endio_sec;
< #line 1129
---
> #line 1335
>   bio->bi_private = (void *)peer_req;
> #line 1336
>   bio->bi_end_io = & drbd_peer_request_endio;
> #line 1338
22579c23445
< #line 1130
---
> #line 1339
22581c23447
< #line 1131
---
> #line 1340
22583,22586c23449,23452
< #line 1133
<   goto ldv_52196;
<   ldv_52195: 
< #line 1134
---
> #line 1342
>   goto ldv_52840;
>   ldv_52839: 
> #line 1343
22588c23454
< #line 1134
---
> #line 1343
22590c23456
< #line 1134
---
> #line 1343
22592c23458
< #line 1135
---
> #line 1344
22594c23460
< #line 1135
---
> #line 1344
22596c23462
< #line 1139
---
> #line 1348
22598c23464
< #line 1140
---
> #line 1349
22601c23467
< #line 1144
---
> #line 1353
22603c23469
< #line 1145
---
> #line 1354
22608c23474
< #line 1147
---
> #line 1356
22613c23479
< #line 1149
---
> #line 1358
22615c23481
< #line 1150
---
> #line 1359
22617c23483
< #line 1151
---
> #line 1360
22619c23485
< #line 1133
---
> #line 1342
22621,22622c23487,23488
<   ldv_52196: ;
< #line 1133
---
>   ldv_52840: ;
> #line 1342
22624c23490
< #line 1133
---
> #line 1342
22626c23492
< #line 1133
---
> #line 1342
22628c23494
< #line 1133
---
> #line 1342
22630,22631c23496,23497
< #line 1134
<       goto ldv_52195;
---
> #line 1343
>       goto ldv_52839;
22633,22634c23499,23500
< #line 1136
<       goto ldv_52197;
---
> #line 1345
>       goto ldv_52841;
22639,22640c23505,23506
<   ldv_52197: ;
< #line 1153
---
>   ldv_52841: ;
> #line 1362
22642c23508
< #line 1153
---
> #line 1362
22644,22645c23510,23511
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1153);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             1362);
22649c23515
< #line 1154
---
> #line 1363
22651c23517
< #line 1154
---
> #line 1363
22653,22654c23519,23520
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1154);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             1363);
22658,22661c23524,23527
< #line 1156
<   atomic_set(& e->pending_bios, (int )n_bios);
<   ldv_52198: 
< #line 1158
---
> #line 1365
>   atomic_set(& peer_req->pending_bios, (int )n_bios);
>   ldv_52842: 
> #line 1367
22663c23529
< #line 1159
---
> #line 1368
22665c23531
< #line 1160
---
> #line 1369
22667c23533
< #line 1162
---
> #line 1371
22669c23535
< #line 1163
---
> #line 1372
22671,22672c23537,23538
< #line 1164
<     goto ldv_52198;
---
> #line 1373
>     goto ldv_52842;
22677c23543
< #line 1164
---
> #line 1373
22680,22683c23546,23549
< #line 1167
<   goto ldv_52201;
<   ldv_52200: 
< #line 1168
---
> #line 1376
>   goto ldv_52845;
>   ldv_52844: 
> #line 1377
22685c23551
< #line 1169
---
> #line 1378
22687c23553
< #line 1170
---
> #line 1379
22689,22690c23555,23556
<   ldv_52201: ;
< #line 1167
---
>   ldv_52845: ;
> #line 1376
22692,22693c23558,23559
< #line 1168
<     goto ldv_52200;
---
> #line 1377
>     goto ldv_52844;
22698c23564
< #line 1172
---
> #line 1381
22702,22703c23568,23642
< #line 1175 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_Barrier(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 1384 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void drbd_remove_epoch_entry_interval(struct drbd_conf *mdev , struct drbd_peer_request *peer_req ) 
> { 
>   struct drbd_interval *i ;
> 
>   {
> #line 1387
>   i = & peer_req->i;
> #line 1389
>   drbd_remove_interval(& mdev->write_requests, i);
> #line 1390
>   drbd_clear_interval(i);
> #line 1393
>   if ((unsigned int )*((unsigned char *)i + 48UL) != 0U) {
> #line 1394
>     __wake_up(& mdev->misc_wait, 3U, 1, 0);
>   } else {
> 
>   }
> #line 1395
>   return;
> }
> }
> #line 1397 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> void conn_wait_active_ee_empty(struct drbd_tconn *tconn ) 
> { 
>   struct drbd_conf *mdev ;
>   int vnr ;
>   void *tmp ;
>   void *tmp___0 ;
> 
>   {
> #line 1402
>   rcu_read_lock();
> #line 1403
>   vnr = 0;
> #line 1403
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 1403
>   mdev = (struct drbd_conf *)tmp;
> #line 1403
>   goto ldv_52858;
>   ldv_52857: 
> #line 1404
>   kref_get(& mdev->kref);
> #line 1405
>   rcu_read_unlock();
> #line 1406
>   drbd_wait_ee_list_empty(mdev, & mdev->active_ee);
> #line 1407
>   kref_put(& mdev->kref, & drbd_minor_destroy);
> #line 1408
>   rcu_read_lock();
> #line 1403
>   vnr = vnr + 1;
> #line 1403
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 1403
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_52858: ;
> #line 1403
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1404
>     goto ldv_52857;
>   } else {
> 
>   }
> #line 1410
>   rcu_read_unlock();
> #line 1411
>   return;
> }
> }
> #line 1413 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_Barrier(struct drbd_tconn *tconn , struct packet_info *pi ) 
22713,22717d23651
<   wait_queue_t __wait ;
<   struct task_struct *tmp___4 ;
<   int tmp___5 ;
<   int tmp___6 ;
<   int tmp___7 ;
22720,22728c23654,23662
< #line 1178
<   p = & mdev->data.rbuf.barrier;
< #line 1181
<   inc_unacked(mdev);
< #line 1183
<   (mdev->current_epoch)->barrier_nr = p->barrier;
< #line 1184
<   tmp = drbd_may_finish_epoch(mdev, mdev->current_epoch, EV_GOT_BARRIER_NR);
< #line 1184
---
> #line 1416
>   p = (struct p_barrier *)pi->data;
> #line 1422
>   (tconn->current_epoch)->barrier_nr = p->barrier;
> #line 1423
>   (tconn->current_epoch)->tconn = tconn;
> #line 1424
>   tmp = drbd_may_finish_epoch(tconn, tconn->current_epoch, EV_GOT_BARRIER_NR);
> #line 1424
22730,22731c23664,23665
< #line 1191
<   switch ((unsigned int )mdev->write_ordering) {
---
> #line 1431
>   switch ((unsigned int )tconn->write_ordering) {
22733c23667
< #line 1193
---
> #line 1433
22735,22736c23669,23670
< #line 1194
<     return (1);
---
> #line 1434
>     return (0);
22740,22742c23674,23676
< #line 1198
<   tmp___0 = kmalloc(40UL, 16U);
< #line 1198
---
> #line 1438
>   tmp___0 = kmalloc(48UL, 16U);
> #line 1438
22744c23678
< #line 1199
---
> #line 1439
22746,22747c23680,23681
< #line 1200
<     goto ldv_52212;
---
> #line 1440
>     goto ldv_52868;
22749,22750c23683,23684
< #line 1202
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Allocation of an epoch failed, slowing down\n");
---
> #line 1442
>     printk("\fd-con %s: Allocation of an epoch failed, slowing down\n", tconn->name);
22754,22760c23688,23694
< #line 1207
<   drbd_wait_ee_list_empty(mdev, & mdev->active_ee);
< #line 1208
<   drbd_flush(mdev);
< #line 1210
<   tmp___2 = atomic_read((atomic_t const   *)(& (mdev->current_epoch)->epoch_size));
< #line 1210
---
> #line 1447
>   conn_wait_active_ee_empty(tconn);
> #line 1448
>   drbd_flush(tconn);
> #line 1450
>   tmp___2 = atomic_read((atomic_t const   *)(& (tconn->current_epoch)->epoch_size));
> #line 1450
22762,22764c23696,23698
< #line 1211
<     tmp___1 = kmalloc(40UL, 16U);
< #line 1211
---
> #line 1451
>     tmp___1 = kmalloc(48UL, 16U);
> #line 1451
22766c23700
< #line 1212
---
> #line 1452
22768,22769c23702,23703
< #line 1213
<       goto ldv_52212;
---
> #line 1453
>       goto ldv_52868;
22776,22845c23710
< #line 1216
<   epoch = mdev->current_epoch;
< #line 1217
<   tmp___3 = atomic_read((atomic_t const   *)(& epoch->epoch_size));
< #line 1217
<   if (tmp___3 == 0) {
< #line 1217
<     goto ldv_52215;
<   } else {
< 
<   }
< #line 1217
<   tmp___4 = get_current();
< #line 1217
<   __wait.flags = 0U;
< #line 1217
<   __wait.private = (void *)tmp___4;
< #line 1217
<   __wait.func = & autoremove_wake_function;
< #line 1217
<   __wait.task_list.next = & __wait.task_list;
< #line 1217
<   __wait.task_list.prev = & __wait.task_list;
<   ldv_52218: 
< #line 1217
<   prepare_to_wait(& mdev->ee_wait, & __wait, 2);
< #line 1217
<   tmp___5 = atomic_read((atomic_t const   *)(& epoch->epoch_size));
< #line 1217
<   if (tmp___5 == 0) {
< #line 1217
<     goto ldv_52217;
<   } else {
< 
<   }
< #line 1217
<   schedule();
< #line 1217
<   goto ldv_52218;
<   ldv_52217: 
< #line 1217
<   finish_wait(& mdev->ee_wait, & __wait);
<   ldv_52215: 
< #line 1219
<   tmp___6 = atomic_read((atomic_t const   *)(& epoch->active));
< #line 1219
<   if (tmp___6 != 0) {
< #line 1219
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( atomic_read(&epoch->active) == 0 ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1219);
<   } else {
< 
<   }
< #line 1220
<   if (epoch->flags != 0UL) {
< #line 1220
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( epoch->flags == 0 ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1220);
<   } else {
< 
<   }
< #line 1222
<   return (1);
<   default: 
< #line 1224
<   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Strangeness in mdev->write_ordering %d\n",
<           (unsigned int )mdev->write_ordering);
< #line 1225
---
> #line 1456
22846a23712,23716
>   default: 
> #line 1458
>   printk("\vd-con %s: Strangeness in tconn->write_ordering %d\n", tconn->name, (unsigned int )tconn->write_ordering);
> #line 1459
>   return (-5);
22848,22849c23718,23719
<   ldv_52212: 
< #line 1228
---
>   ldv_52868: 
> #line 1462
22851c23721
< #line 1229
---
> #line 1463
22853c23723
< #line 1230
---
> #line 1464
22855,22866c23725,23736
< #line 1232
<   spin_lock(& mdev->epoch_lock);
< #line 1233
<   tmp___7 = atomic_read((atomic_t const   *)(& (mdev->current_epoch)->epoch_size));
< #line 1233
<   if (tmp___7 != 0) {
< #line 1234
<     list_add(& epoch->list, & (mdev->current_epoch)->list);
< #line 1235
<     mdev->current_epoch = epoch;
< #line 1236
<     mdev->epochs = mdev->epochs + 1U;
---
> #line 1466
>   spin_lock(& tconn->epoch_lock);
> #line 1467
>   tmp___3 = atomic_read((atomic_t const   *)(& (tconn->current_epoch)->epoch_size));
> #line 1467
>   if (tmp___3 != 0) {
> #line 1468
>     list_add(& epoch->list, & (tconn->current_epoch)->list);
> #line 1469
>     tconn->current_epoch = epoch;
> #line 1470
>     tconn->epochs = tconn->epochs + 1U;
22868c23738
< #line 1239
---
> #line 1473
22871,22874c23741,23744
< #line 1241
<   spin_unlock(& mdev->epoch_lock);
< #line 1243
<   return (1);
---
> #line 1475
>   spin_unlock(& tconn->epoch_lock);
> #line 1477
>   return (0);
22877,22879c23747,23749
< #line 1249 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static struct drbd_epoch_entry *read_in_block(struct drbd_conf *mdev , u64 id , sector_t sector ,
<                                               int data_size ) 
---
> #line 1483 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static struct drbd_peer_request *read_in_block(struct drbd_conf *mdev , u64 id , sector_t sector ,
>                                                int data_size ) 
22883c23753
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
22887c23757
<   int rr ;
---
>   int err ;
22892c23762,23764
<   struct task_struct *tmp___1 ;
---
>   bool _bool ;
>   int tmp___1 ;
>   bool _bool___0 ;
22894,22895d23765
<   int _b ;
<   int _b___0 ;
22901c23771
<   struct task_struct *tmp___5 ;
---
>   struct page *tmp___5 ;
22903,22904d23772
<   struct page *tmp___7 ;
<   int tmp___8 ;
22907c23775
< #line 1251
---
> #line 1486
22909c23777
< #line 1251
---
> #line 1486
22911,22919c23779,23789
< #line 1255
<   dig_in = mdev->int_dig_in;
< #line 1256
<   dig_vv = mdev->int_dig_vv;
< #line 1259
<   if (mdev->agreed_pro_version > 86 && (unsigned long )mdev->integrity_r_tfm != (unsigned long )((struct crypto_hash *)0)) {
< #line 1259
<     tmp___0 = crypto_hash_digestsize(mdev->integrity_r_tfm);
< #line 1259
---
> #line 1490
>   dig_in = (mdev->tconn)->int_dig_in;
> #line 1491
>   dig_vv = (mdev->tconn)->int_dig_vv;
> #line 1494
>   dgs = 0;
> #line 1495
>   if ((unsigned long )(mdev->tconn)->peer_integrity_tfm != (unsigned long )((struct crypto_hash *)0)) {
> #line 1496
>     tmp___0 = crypto_hash_digestsize((mdev->tconn)->peer_integrity_tfm);
> #line 1496
22921,22943c23791,23795
<   } else {
< #line 1259
<     dgs = 0;
<   }
< #line 1262
<   if (dgs != 0) {
< #line 1263
<     rr = drbd_recv(mdev, dig_in, (size_t )dgs);
< #line 1264
<     if (rr != dgs) {
< #line 1265
<       tmp___1 = get_current();
< #line 1265
<       tmp___2 = signal_pending(tmp___1);
< #line 1265
<       if (tmp___2 == 0) {
< #line 1266
<         dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "short read receiving data digest: read %d expected %d\n",
<                  rr, dgs);
<       } else {
< 
<       }
< #line 1269
---
> #line 1501
>     err = drbd_recv_all_warn(mdev->tconn, dig_in, (size_t )dgs);
> #line 1502
>     if (err != 0) {
> #line 1503
22947a23800,23801
> #line 1504
>     data_size = data_size - dgs;
22951,22960c23805,23811
< #line 1273
<   data_size = data_size - dgs;
< #line 1275
<   _b = (data_size & 511) != 0;
< #line 1275
<   if (_b != 0) {
< #line 1275
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "read_in_block", (char *)"data_size & 0x1ff", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1275);
---
> #line 1507
>   _bool = (data_size & 511) == 0;
> #line 1507
>   if (! _bool) {
> #line 1507
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"IS_ALIGNED(data_size, 512)", "read_in_block");
22964,22966c23815,23825
< #line 1275
<   if (_b != 0) {
< #line 1275
---
> #line 1507
>   if (_bool) {
> #line 1507
>     tmp___1 = 0;
>   } else {
> #line 1507
>     tmp___1 = 1;
>   }
> #line 1507
>   if (tmp___1) {
> #line 1508
22971,22978c23830,23836
< #line 1276
<   _b___0 = (unsigned int )data_size > 131072U;
< #line 1276
<   if (_b___0 != 0) {
< #line 1276
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "read_in_block", (char *)"data_size > DRBD_MAX_BIO_SIZE", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1276);
---
> #line 1509
>   _bool___0 = (unsigned int )data_size <= 1048576U;
> #line 1509
>   if (! _bool___0) {
> #line 1509
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"data_size <= DRBD_MAX_BIO_SIZE", "read_in_block");
22982,22984c23840,23850
< #line 1276
<   if (_b___0 != 0) {
< #line 1276
---
> #line 1509
>   if (_bool___0) {
> #line 1509
>     tmp___2 = 0;
>   } else {
> #line 1509
>     tmp___2 = 1;
>   }
> #line 1509
>   if (tmp___2) {
> #line 1510
22989c23855
< #line 1280
---
> #line 1514
22991c23857
< #line 1281
---
> #line 1515
22994c23860
< #line 1285
---
> #line 1519
22999,23003c23865,23869
< #line 1291
<   e = drbd_alloc_ee(mdev, id, sector, (unsigned int )data_size, 16U);
< #line 1292
<   if ((unsigned long )e == (unsigned long )((struct drbd_epoch_entry *)0)) {
< #line 1293
---
> #line 1525
>   peer_req = drbd_alloc_peer_req(mdev, id, sector, (unsigned int )data_size, 16U);
> #line 1526
>   if ((unsigned long )peer_req == (unsigned long )((struct drbd_peer_request *)0)) {
> #line 1527
23008c23874
< #line 1295
---
> #line 1529
23010,23011c23876,23877
< #line 1296
<     return (e);
---
> #line 1530
>     return (peer_req);
23015c23881
< #line 1298
---
> #line 1532
23017,23022c23883,23888
< #line 1299
<   page = e->pages;
< #line 1300
<   goto ldv_52246;
<   ldv_52245: 
< #line 1301
---
> #line 1533
>   page = peer_req->pages;
> #line 1534
>   goto ldv_52898;
>   ldv_52897: 
> #line 1535
23024c23890
< #line 1301
---
> #line 1535
23026c23892
< #line 1301
---
> #line 1535
23028c23894
< #line 1302
---
> #line 1536
23030c23896
< #line 1302
---
> #line 1536
23032,23034c23898,23900
< #line 1303
<   rr = drbd_recv(mdev, (void *)data, (size_t )len);
< #line 1304
---
> #line 1537
>   err = drbd_recv_all_warn(mdev->tconn, (void *)data, (size_t )len);
> #line 1538
23036c23902
< #line 1304
---
> #line 1538
23038c23904
< #line 1305
---
> #line 1539
23040c23906
< #line 1306
---
> #line 1540
23045c23911
< #line 1308
---
> #line 1542
23047,23063c23913,23917
< #line 1309
<   if ((unsigned int )rr != len) {
< #line 1310
<     drbd_free_some_ee(mdev, e, 0);
< #line 1311
<     tmp___5 = get_current();
< #line 1311
<     tmp___6 = signal_pending(tmp___5);
< #line 1311
<     if (tmp___6 == 0) {
< #line 1312
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "short read receiving data: read %d expected %d\n",
<                rr, len);
<     } else {
< 
<     }
< #line 1314
---
> #line 1543
>   if (err != 0) {
> #line 1544
>     __drbd_free_peer_req(mdev, peer_req, 0);
> #line 1545
23068,23070c23922,23924
< #line 1316
<   ds = ds - rr;
< #line 1300
---
> #line 1547
>   ds = (int )((unsigned int )ds - len);
> #line 1534
23072,23073c23926,23927
<   ldv_52246: ;
< #line 1300
---
>   ldv_52898: ;
> #line 1534
23075,23079c23929,23933
< #line 1300
<     tmp___7 = page_chain_next(page);
< #line 1300
<     __builtin_prefetch((void const   *)tmp___7);
< #line 1300
---
> #line 1534
>     tmp___5 = page_chain_next(page);
> #line 1534
>     __builtin_prefetch((void const   *)tmp___5);
> #line 1534
23081,23082c23935,23936
< #line 1301
<       goto ldv_52245;
---
> #line 1535
>       goto ldv_52897;
23084,23085c23938,23939
< #line 1303
<       goto ldv_52247;
---
> #line 1537
>       goto ldv_52899;
23090,23091c23944,23945
<   ldv_52247: ;
< #line 1319
---
>   ldv_52899: ;
> #line 1550
23093,23099c23947,23953
< #line 1320
<     drbd_csum_ee(mdev, mdev->integrity_r_tfm, e, dig_vv);
< #line 1321
<     tmp___8 = memcmp((void const   *)dig_in, (void const   *)dig_vv, (size_t )dgs);
< #line 1321
<     if (tmp___8 != 0) {
< #line 1322
---
> #line 1551
>     drbd_csum_ee(mdev, (mdev->tconn)->peer_integrity_tfm, peer_req, dig_vv);
> #line 1552
>     tmp___6 = memcmp((void const   *)dig_in, (void const   *)dig_vv, (size_t )dgs);
> #line 1552
>     if (tmp___6 != 0) {
> #line 1553
23102,23107c23956,23958
< #line 1324
<       drbd_bcast_ee(mdev, "digest failed", dgs, (char const   *)dig_in, (char const   *)dig_vv,
<                     (struct drbd_epoch_entry  const  *)e);
< #line 1326
<       drbd_free_some_ee(mdev, e, 0);
< #line 1327
---
> #line 1555
>       __drbd_free_peer_req(mdev, peer_req, 0);
> #line 1556
23115c23966
< #line 1330
---
> #line 1559
23117,23118c23968,23969
< #line 1331
<   return (e);
---
> #line 1560
>   return (peer_req);
23121c23972
< #line 1337 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 1566 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
23125,23126c23976
<   int rr ;
<   int rv ;
---
>   int err ;
23127a23978
>   unsigned int len ;
23130,23135d23980
<   int __min1___0 ;
<   int __min2___0 ;
<   struct task_struct *tmp ;
<   int tmp___0 ;
<   int __min1___1 ;
<   int __min2___1 ;
23138,23140c23983,23985
< #line 1340
<   rv = 1;
< #line 1343
---
> #line 1569
>   err = 0;
> #line 1572
23142,23143c23987,23988
< #line 1344
<     return (1);
---
> #line 1573
>     return (0);
23147,23149c23992,23994
< #line 1346
<   page = drbd_pp_alloc(mdev, 1U, 1);
< #line 1348
---
> #line 1575
>   page = drbd_alloc_pages(mdev, 1U, 1);
> #line 1577
23151,23154c23996,23999
< #line 1349
<   goto ldv_52267;
<   ldv_52266: 
< #line 1350
---
> #line 1578
>   goto ldv_52913;
>   ldv_52912: 
> #line 1579
23156c24001
< #line 1350
---
> #line 1579
23158,23185c24003,24010
< #line 1350
<   rr = drbd_recv(mdev, data, (size_t )(__min1 < __min2 ? __min1 : __min2));
< #line 1351
<   __min1___1 = data_size;
< #line 1351
<   __min2___1 = 4096;
< #line 1351
<   if ((__min1___1 < __min2___1 ? __min1___1 : __min2___1) != rr) {
< #line 1352
<     rv = 0;
< #line 1353
<     tmp = get_current();
< #line 1353
<     tmp___0 = signal_pending(tmp);
< #line 1353
<     if (tmp___0 == 0) {
< #line 1356
<       __min1___0 = data_size;
< #line 1356
<       __min2___0 = 4096;
< #line 1356
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "short read receiving data: read %d expected %d\n",
<                rr, __min1___0 < __min2___0 ? __min1___0 : __min2___0);
<     } else {
< 
<     }
< #line 1357
<     goto ldv_52265;
---
> #line 1579
>   len = (unsigned int )(__min1 < __min2 ? __min1 : __min2);
> #line 1581
>   err = drbd_recv_all_warn(mdev->tconn, data, (size_t )len);
> #line 1582
>   if (err != 0) {
> #line 1583
>     goto ldv_52911;
23189,23192c24014,24017
< #line 1359
<   data_size = data_size - rr;
<   ldv_52267: ;
< #line 1349
---
> #line 1584
>   data_size = (int )((unsigned int )data_size - len);
>   ldv_52913: ;
> #line 1578
23194,23195c24019,24020
< #line 1350
<     goto ldv_52266;
---
> #line 1579
>     goto ldv_52912;
23199,23200c24024,24025
<   ldv_52265: 
< #line 1361
---
>   ldv_52911: 
> #line 1586
23202,23205c24027,24030
< #line 1362
<   drbd_pp_free(mdev, page, 0);
< #line 1363
<   return (rv);
---
> #line 1587
>   drbd_free_pages(mdev, page, 0);
> #line 1588
>   return (err);
23208c24033
< #line 1366 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 1591 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
23215c24040
<   int rr ;
---
>   int err ;
23221,23222c24046,24047
<   struct task_struct *tmp___0 ;
<   int tmp___1 ;
---
>   void *mapped ;
>   void *tmp___0 ;
23225,23228c24050
<   void *tmp___2 ;
<   struct task_struct *tmp___3 ;
<   int tmp___4 ;
<   int tmp___5 ;
---
>   int tmp___1 ;
23231,23239c24053,24063
< #line 1372
<   dig_in = mdev->int_dig_in;
< #line 1373
<   dig_vv = mdev->int_dig_vv;
< #line 1375
<   if (mdev->agreed_pro_version > 86 && (unsigned long )mdev->integrity_r_tfm != (unsigned long )((struct crypto_hash *)0)) {
< #line 1375
<     tmp = crypto_hash_digestsize(mdev->integrity_r_tfm);
< #line 1375
---
> #line 1597
>   dig_in = (mdev->tconn)->int_dig_in;
> #line 1598
>   dig_vv = (mdev->tconn)->int_dig_vv;
> #line 1600
>   dgs = 0;
> #line 1601
>   if ((unsigned long )(mdev->tconn)->peer_integrity_tfm != (unsigned long )((struct crypto_hash *)0)) {
> #line 1602
>     tmp = crypto_hash_digestsize((mdev->tconn)->peer_integrity_tfm);
> #line 1602
23241,23264c24065,24070
<   } else {
< #line 1375
<     dgs = 0;
<   }
< #line 1378
<   if (dgs != 0) {
< #line 1379
<     rr = drbd_recv(mdev, dig_in, (size_t )dgs);
< #line 1380
<     if (rr != dgs) {
< #line 1381
<       tmp___0 = get_current();
< #line 1381
<       tmp___1 = signal_pending(tmp___0);
< #line 1381
<       if (tmp___1 == 0) {
< #line 1382
<         dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "short read receiving data reply digest: read %d expected %d\n",
<                  rr, dgs);
<       } else {
< 
<       }
< #line 1385
<       return (0);
---
> #line 1603
>     err = drbd_recv_all_warn(mdev->tconn, dig_in, (size_t )dgs);
> #line 1604
>     if (err != 0) {
> #line 1605
>       return (err);
23267a24074,24075
> #line 1606
>     data_size = data_size - dgs;
23271,23273c24079
< #line 1389
<   data_size = data_size - dgs;
< #line 1393
---
> #line 1611
23275c24081
< #line 1395
---
> #line 1613
23277c24083
< #line 1396
---
> #line 1614
23279c24085
< #line 1396
---
> #line 1614
23281,23282c24087,24088
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1396);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             1614);
23286c24092
< #line 1398
---
> #line 1616
23288c24094
< #line 1398
---
> #line 1616
23290,23293c24096,24103
< #line 1398
<   goto ldv_52286;
<   ldv_52285: 
< #line 1399
---
> #line 1616
>   goto ldv_52933;
>   ldv_52932: 
> #line 1617
>   tmp___0 = kmap(bvec->bv_page);
> #line 1617
>   mapped = tmp___0 + (unsigned long )bvec->bv_offset;
> #line 1618
23295c24105
< #line 1399
---
> #line 1618
23297c24107
< #line 1399
---
> #line 1618
23299,23303c24109,24111
< #line 1400
<   tmp___2 = kmap(bvec->bv_page);
< #line 1400
<   rr = drbd_recv(mdev, tmp___2 + (unsigned long )bvec->bv_offset, (size_t )expect);
< #line 1403
---
> #line 1619
>   err = drbd_recv_all_warn(mdev->tconn, mapped, (size_t )expect);
> #line 1620
23305,23320c24113,24116
< #line 1404
<   if (rr != expect) {
< #line 1405
<     tmp___3 = get_current();
< #line 1405
<     tmp___4 = signal_pending(tmp___3);
< #line 1405
<     if (tmp___4 == 0) {
< #line 1406
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "short read receiving data reply: read %d expected %d\n",
<                rr, expect);
<     } else {
< 
<     }
< #line 1409
<     return (0);
---
> #line 1621
>   if (err != 0) {
> #line 1622
>     return (err);
23324,23326c24120,24122
< #line 1411
<   data_size = data_size - rr;
< #line 1398
---
> #line 1623
>   data_size = data_size - expect;
> #line 1616
23328c24124
< #line 1398
---
> #line 1616
23330,23331c24126,24127
<   ldv_52286: ;
< #line 1398
---
>   ldv_52933: ;
> #line 1616
23333,23334c24129,24130
< #line 1399
<     goto ldv_52285;
---
> #line 1617
>     goto ldv_52932;
23339c24135
< #line 1414
---
> #line 1626
23341,23347c24137,24143
< #line 1415
<     drbd_csum_bio(mdev, mdev->integrity_r_tfm, bio, dig_vv);
< #line 1416
<     tmp___5 = memcmp((void const   *)dig_in, (void const   *)dig_vv, (size_t )dgs);
< #line 1416
<     if (tmp___5 != 0) {
< #line 1417
---
> #line 1627
>     drbd_csum_bio(mdev, (mdev->tconn)->peer_integrity_tfm, bio, dig_vv);
> #line 1628
>     tmp___1 = memcmp((void const   *)dig_in, (void const   *)dig_vv, (size_t )dgs);
> #line 1628
>     if (tmp___1 != 0) {
> #line 1629
23349,23350c24145,24146
< #line 1418
<       return (0);
---
> #line 1630
>       return (-22);
23357c24153
< #line 1422
---
> #line 1634
23359c24155
< #line 1422
---
> #line 1634
23361,23362c24157,24158
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1422);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             1634);
23366,23367c24162,24163
< #line 1423
<   return (1);
---
> #line 1635
>   return (0);
23370,23371c24166,24167
< #line 1428 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int e_end_resync_block(struct drbd_conf *mdev , struct drbd_work *w , int unused ) 
---
> #line 1642 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int e_end_resync_block(struct drbd_work *w , int unused ) 
23373c24169,24171
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
>   struct drbd_work  const  *__mptr ;
>   struct drbd_conf *mdev ;
23375,23379c24173,24176
<   int ok ;
<   int tmp ;
<   long tmp___0 ;
<   int tmp___1 ;
<   int tmp___2 ;
---
>   int err ;
>   bool tmp ;
>   int tmp___0 ;
>   long tmp___1 ;
23382,23393c24179,24192
< #line 1430
<   e = (struct drbd_epoch_entry *)w;
< #line 1431
<   sector = e->sector;
< #line 1434
<   tmp = hlist_unhashed((struct hlist_node  const  *)(& e->collision));
< #line 1434
<   if (tmp == 0) {
< #line 1434
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( hlist_unhashed(&e->collision) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1434);
---
> #line 1645
>   __mptr = (struct drbd_work  const  *)w;
> #line 1645
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 1646
>   mdev = w->ldv_50388.mdev;
> #line 1647
>   sector = peer_req->i.sector;
> #line 1650
>   tmp = drbd_interval_empty(& peer_req->i);
> #line 1650
>   if (tmp) {
> #line 1650
>     tmp___0 = 0;
23395c24194,24195
< 
---
> #line 1650
>     tmp___0 = 1;
23397,23405c24197,24202
< #line 1436
<   tmp___0 = __builtin_expect((e->flags & 8UL) == 0UL, 1L);
< #line 1436
<   if (tmp___0 != 0L) {
< #line 1437
<     __drbd_set_in_sync(mdev, sector, (int )e->size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                        1437U);
< #line 1438
<     ok = drbd_send_ack(mdev, P_RS_WRITE_ACK, e);
---
> #line 1650
>   if (tmp___0) {
> #line 1650
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( drbd_interval_empty(&peer_req->i) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             1650);
23407,23410c24204
< #line 1441
<     drbd_rs_failed_io(mdev, sector, (int )e->size);
< #line 1443
<     ok = drbd_send_ack(mdev, P_NEG_ACK, e);
---
> 
23412,23422c24206,24214
< #line 1445
<   atomic_dec(& mdev->unacked_cnt);
< #line 1445
<   tmp___2 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1445
<   if (tmp___2 < 0) {
< #line 1445
<     tmp___1 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1445
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<             "e_end_resync_block", 1445, tmp___1);
---
> #line 1652
>   tmp___1 = __builtin_expect((peer_req->flags & 8UL) == 0UL, 1L);
> #line 1652
>   if (tmp___1 != 0L) {
> #line 1653
>     __drbd_set_in_sync(mdev, sector, (int )peer_req->i.size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                        1653U);
> #line 1654
>     err = drbd_send_ack(mdev, P_RS_WRITE_ACK, peer_req);
23424c24216,24219
< 
---
> #line 1657
>     drbd_rs_failed_io(mdev, sector, (int )peer_req->i.size);
> #line 1659
>     err = drbd_send_ack(mdev, P_NEG_ACK, peer_req);
23426,23427c24221,24224
< #line 1447
<   return (ok);
---
> #line 1661
>   _dec_unacked(mdev, "e_end_resync_block", 1661);
> #line 1663
>   return (err);
23430c24227
< #line 1450 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 1666 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
23433c24230
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
23435,23436d24231
<   int tmp___0 ;
<   int tmp___1 ;
23439,23443c24234,24238
< #line 1454
<   e = read_in_block(mdev, 0xffffffffffffffffULL, sector, data_size);
< #line 1455
<   if ((unsigned long )e == (unsigned long )((struct drbd_epoch_entry *)0)) {
< #line 1456
---
> #line 1670
>   peer_req = read_in_block(mdev, 0xffffffffffffffffULL, sector, data_size);
> #line 1671
>   if ((unsigned long )peer_req == (unsigned long )((struct drbd_peer_request *)0)) {
> #line 1672
23448,23462c24243,24245
< #line 1458
<   atomic_dec(& mdev->rs_pending_cnt);
< #line 1458
<   tmp___0 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 1458
<   if (tmp___0 < 0) {
< #line 1458
<     tmp = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 1458
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
<             "recv_resync_read", 1458, tmp);
<   } else {
< 
<   }
< #line 1460
---
> #line 1674
>   _dec_rs_pending(mdev, "recv_resync_read", 1674);
> #line 1676
23464,23472c24247,24255
< #line 1464
<   e->w.cb = & e_end_resync_block;
< #line 1466
<   spin_lock_irq(& mdev->req_lock);
< #line 1467
<   list_add(& e->w.list, & mdev->sync_ee);
< #line 1468
<   spin_unlock_irq(& mdev->req_lock);
< #line 1470
---
> #line 1680
>   peer_req->w.cb = & e_end_resync_block;
> #line 1682
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 1683
>   list_add(& peer_req->w.list, & mdev->sync_ee);
> #line 1684
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 1686
23474,23479c24257,24262
< #line 1471
<   tmp___1 = drbd_submit_ee(mdev, e, 1U, 2);
< #line 1471
<   if (tmp___1 == 0) {
< #line 1472
<     return (1);
---
> #line 1687
>   tmp = drbd_submit_peer_request(mdev, peer_req, 1U, 2);
> #line 1687
>   if (tmp == 0) {
> #line 1688
>     return (0);
23483c24266
< #line 1475
---
> #line 1691
23485,23492c24268,24275
< #line 1476
<   spin_lock_irq(& mdev->req_lock);
< #line 1477
<   list_del(& e->w.list);
< #line 1478
<   spin_unlock_irq(& mdev->req_lock);
< #line 1480
<   drbd_free_some_ee(mdev, e, 0);
---
> #line 1692
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 1693
>   list_del(& peer_req->w.list);
> #line 1694
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 1696
>   __drbd_free_peer_req(mdev, peer_req, 0);
23494c24277
< #line 1482
---
> #line 1698
23496c24279,24311
< #line 1483
---
> #line 1699
>   return (-5);
> }
> }
> #line 1703 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static struct drbd_request *find_request(struct drbd_conf *mdev , struct rb_root *root ,
>                                          u64 id , sector_t sector , bool missing_ok ,
>                                          char const   *func ) 
> { 
>   struct drbd_request *req ;
>   bool tmp ;
> 
>   {
> #line 1709
>   req = (struct drbd_request *)id;
> #line 1710
>   tmp = drbd_contains_interval(root, sector, & req->i);
> #line 1710
>   if ((int )tmp && (unsigned int )*((unsigned char *)req + 88UL) != 0U) {
> #line 1711
>     return (req);
>   } else {
> 
>   }
> #line 1712
>   if (! missing_ok) {
> #line 1713
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s: failed to find request 0x%lx, sector %llus\n",
>             func, (unsigned long )id, (unsigned long long )sector);
>   } else {
> 
>   }
> #line 1716
23500,23501c24315,24316
< #line 1486 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_DataReply(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 1719 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_DataReply(struct drbd_tconn *tconn , struct packet_info *pi ) 
23502a24318
>   struct drbd_conf *mdev ;
23505c24321
<   int ok ;
---
>   int err ;
23511,23513c24327,24338
< #line 1491
<   p = & mdev->data.rbuf.data;
< #line 1493
---
> #line 1725
>   p = (struct p_data *)pi->data;
> #line 1727
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 1728
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 1729
>     return (-5);
>   } else {
> 
>   }
> #line 1731
23515c24340
< #line 1493
---
> #line 1731
23517,23523c24342,24348
< #line 1495
<   spin_lock_irq(& mdev->req_lock);
< #line 1496
<   req = _ar_id_to_req(mdev, p->block_id, sector);
< #line 1497
<   spin_unlock_irq(& mdev->req_lock);
< #line 1498
---
> #line 1733
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 1734
>   req = find_request(mdev, & mdev->read_requests, p->block_id, sector, 0, "receive_DataReply");
> #line 1735
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 1736
23526c24351
< #line 1498
---
> #line 1736
23528,23531c24353,24354
< #line 1499
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Got a corrupt block_id/sector pair(1).\n");
< #line 1500
<     return (0);
---
> #line 1737
>     return (-5);
23535,23540c24358,24363
< #line 1506
<   ok = recv_dless_read(mdev, req, sector, (int )data_size);
< #line 1508
<   if (ok != 0) {
< #line 1509
<     req_mod(req, data_received);
---
> #line 1742
>   err = recv_dless_read(mdev, req, sector, (int )pi->size);
> #line 1743
>   if (err == 0) {
> #line 1744
>     req_mod(req, DATA_RECEIVED);
23544,23545c24367,24368
< #line 1514
<   return (ok);
---
> #line 1749
>   return (err);
23548,23549c24371,24372
< #line 1517 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_RSDataReply(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 1752 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_RSDataReply(struct drbd_tconn *tconn , struct packet_info *pi ) 
23550a24374
>   struct drbd_conf *mdev ;
23552c24376
<   int ok ;
---
>   int err ;
23559,23561c24383,24394
< #line 1521
<   p = & mdev->data.rbuf.data;
< #line 1523
---
> #line 1757
>   p = (struct p_data *)pi->data;
> #line 1759
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 1760
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 1761
>     return (-5);
>   } else {
> 
>   }
> #line 1763
23563c24396
< #line 1523
---
> #line 1763
23565c24398
< #line 1524
---
> #line 1764
23567c24400
< #line 1524
---
> #line 1764
23569,23570c24402,24403
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1524);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             1764);
23574c24407
< #line 1526
---
> #line 1766
23576c24409
< #line 1526
---
> #line 1766
23578,23579c24411,24412
< #line 1530
<     ok = recv_resync_read(mdev, sector, (int )data_size);
---
> #line 1770
>     err = recv_resync_read(mdev, sector, (int )pi->size);
23581c24414
< #line 1532
---
> #line 1772
23583c24416
< #line 1532
---
> #line 1772
23585c24418
< #line 1533
---
> #line 1773
23590,23593c24423,24426
< #line 1535
<     ok = drbd_drain_block(mdev, (int )data_size);
< #line 1537
<     drbd_send_ack_dp(mdev, P_NEG_ACK, p, (int )data_size);
---
> #line 1775
>     err = drbd_drain_block(mdev, (int )pi->size);
> #line 1777
>     drbd_send_ack_dp(mdev, P_NEG_ACK, p, (int )pi->size);
23595,23598c24428,24481
< #line 1540
<   atomic_add((int )(data_size >> 9), & mdev->rs_sect_in);
< #line 1542
<   return (ok);
---
> #line 1780
>   atomic_add((int )(pi->size >> 9), & mdev->rs_sect_in);
> #line 1782
>   return (err);
> }
> }
> #line 1785 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void restart_conflicting_writes(struct drbd_conf *mdev , sector_t sector ,
>                                        int size ) 
> { 
>   struct drbd_interval *i ;
>   struct drbd_request *req ;
>   struct drbd_interval  const  *__mptr ;
> 
>   {
> #line 1791
>   i = drbd_find_overlap(& mdev->write_requests, sector, (unsigned int )size);
> #line 1791
>   goto ldv_52993;
>   ldv_52992: ;
> #line 1792
>   if ((unsigned int )*((unsigned char *)i + 48UL) == 0U) {
> #line 1793
>     goto ldv_52989;
>   } else {
> 
>   }
> #line 1794
>   __mptr = (struct drbd_interval  const  *)i;
> #line 1794
>   req = (struct drbd_request *)__mptr + 0xffffffffffffffd8UL;
> #line 1795
>   if ((int )req->rq_state & 1 || ((unsigned long )req->rq_state & 8192UL) == 0UL) {
> #line 1797
>     goto ldv_52989;
>   } else {
> 
>   }
> #line 1800
>   __req_mod(req, CONFLICT_RESOLVED, 0);
>   ldv_52989: 
> #line 1791
>   i = drbd_next_overlap(i, sector, (unsigned int )size);
>   ldv_52993: ;
> #line 1791
>   if ((unsigned long )i != (unsigned long )((struct drbd_interval *)0)) {
> #line 1792
>     goto ldv_52992;
>   } else {
> 
>   }
> 
> #line 1796
>   return;
23601,23602c24484,24485
< #line 1548 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int e_end_block(struct drbd_conf *mdev , struct drbd_work *w , int cancel ) 
---
> #line 1807 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int e_end_block(struct drbd_work *w , int cancel ) 
23604c24487,24489
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
>   struct drbd_work  const  *__mptr ;
>   struct drbd_conf *mdev ;
23606c24491
<   int ok ;
---
>   int err ;
23608,23610c24493,24495
<   int tmp ;
<   long tmp___0 ;
<   int tmp___1 ;
---
>   long tmp ;
>   bool tmp___0 ;
>   bool tmp___1 ;
23612,23613d24496
<   int tmp___3 ;
<   int tmp___4 ;
23616,23634c24499,24519
< #line 1550
<   e = (struct drbd_epoch_entry *)w;
< #line 1551
<   sector = e->sector;
< #line 1552
<   ok = 1;
< #line 1554
<   if ((mdev->net_conf)->wire_protocol == 3) {
< #line 1555
<     tmp___0 = __builtin_expect((e->flags & 8UL) == 0UL, 1L);
< #line 1555
<     if (tmp___0 != 0L) {
< #line 1556
<       pcmd = ((int )mdev->state.ldv_40583.conn > 15 && (int )mdev->state.ldv_40583.conn <= 21) && (e->flags & 2UL) != 0UL ? 23 : 22;
< #line 1560
<       tmp = drbd_send_ack(mdev, (enum drbd_packets )pcmd, e);
< #line 1560
<       ok = tmp & ok;
< #line 1561
---
> #line 1810
>   __mptr = (struct drbd_work  const  *)w;
> #line 1810
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 1811
>   mdev = w->ldv_50388.mdev;
> #line 1812
>   sector = peer_req->i.sector;
> #line 1813
>   err = 0;
> #line 1815
>   if ((peer_req->flags & 64UL) != 0UL) {
> #line 1816
>     tmp = __builtin_expect((peer_req->flags & 8UL) == 0UL, 1L);
> #line 1816
>     if (tmp != 0L) {
> #line 1817
>       pcmd = ((int )mdev->state.ldv_50103.conn > 15 && (int )mdev->state.ldv_50103.conn <= 21) && (peer_req->flags & 2UL) != 0UL ? 23 : 22;
> #line 1821
>       err = drbd_send_ack(mdev, (enum drbd_packet )pcmd, peer_req);
> #line 1822
23636,23638c24521,24523
< #line 1562
<         __drbd_set_in_sync(mdev, sector, (int )e->size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                            1562U);
---
> #line 1823
>         __drbd_set_in_sync(mdev, sector, (int )peer_req->i.size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                            1823U);
23643,23658c24528,24529
< #line 1564
<       ok = drbd_send_ack(mdev, P_NEG_ACK, e);
<     }
< #line 1568
<     atomic_dec(& mdev->unacked_cnt);
< #line 1568
<     tmp___2 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1568
<     if (tmp___2 < 0) {
< #line 1568
<       tmp___1 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1568
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<               "e_end_block", 1568, tmp___1);
<     } else {
< 
---
> #line 1825
>       err = drbd_send_ack(mdev, P_NEG_ACK, peer_req);
23659a24531,24532
> #line 1829
>     _dec_unacked(mdev, "e_end_block", 1829);
23663,23674c24536,24547
< #line 1572
<   if ((unsigned int )*((unsigned char *)mdev->net_conf + 540UL) != 0U) {
< #line 1573
<     spin_lock_irq(& mdev->req_lock);
< #line 1574
<     tmp___3 = hlist_unhashed((struct hlist_node  const  *)(& e->collision));
< #line 1574
<     if (tmp___3 != 0) {
< #line 1574
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !hlist_unhashed(&e->collision) ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               1574);
---
> #line 1833
>   if ((peer_req->flags & 128UL) != 0UL) {
> #line 1834
>     spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 1835
>     tmp___0 = drbd_interval_empty(& peer_req->i);
> #line 1835
>     if ((int )tmp___0) {
> #line 1835
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !drbd_interval_empty(&peer_req->i) ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>               1835);
23678,23681c24551,24561
< #line 1575
<     hlist_del_init(& e->collision);
< #line 1576
<     spin_unlock_irq(& mdev->req_lock);
---
> #line 1836
>     drbd_remove_epoch_entry_interval(mdev, peer_req);
> #line 1837
>     if ((peer_req->flags & 32UL) != 0UL) {
> #line 1838
>       restart_conflicting_writes(mdev, sector, (int )peer_req->i.size);
>     } else {
> 
>     }
> #line 1839
>     spin_unlock_irq(& (mdev->tconn)->req_lock);
23683,23690c24563,24578
< #line 1578
<     tmp___4 = hlist_unhashed((struct hlist_node  const  *)(& e->collision));
< #line 1578
<     if (tmp___4 == 0) {
< #line 1578
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( hlist_unhashed(&e->collision) ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               1578);
---
> #line 1841
>     tmp___1 = drbd_interval_empty(& peer_req->i);
> #line 1841
>     if (tmp___1) {
> #line 1841
>       tmp___2 = 0;
>     } else {
> #line 1841
>       tmp___2 = 1;
>     }
> #line 1841
>     if (tmp___2) {
> #line 1841
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( drbd_interval_empty(&peer_req->i) ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>               1841);
23695,23698c24583,24586
< #line 1581
<   drbd_may_finish_epoch(mdev, e->epoch, cancel != 0 ? EV_CLEANUP : EV_PUT);
< #line 1583
<   return (ok);
---
> #line 1843
>   drbd_may_finish_epoch(mdev->tconn, peer_req->epoch, cancel != 0 ? EV_CLEANUP : EV_PUT);
> #line 1845
>   return (err);
23701,23702c24589,24590
< #line 1586 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int e_send_discard_ack(struct drbd_conf *mdev , struct drbd_work *w , int unused ) 
---
> #line 1848 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int e_send_ack(struct drbd_work *w , enum drbd_packet ack ) 
23704,23705c24592,24667
<   struct drbd_epoch_entry *e ;
<   int ok ;
---
>   struct drbd_conf *mdev ;
>   struct drbd_peer_request *peer_req ;
>   struct drbd_work  const  *__mptr ;
>   int err ;
> 
>   {
> #line 1850
>   mdev = w->ldv_50388.mdev;
> #line 1852
>   __mptr = (struct drbd_work  const  *)w;
> #line 1852
>   peer_req = (struct drbd_peer_request *)__mptr;
> #line 1855
>   err = drbd_send_ack(mdev, ack, peer_req);
> #line 1856
>   _dec_unacked(mdev, "e_send_ack", 1856);
> #line 1858
>   return (err);
> }
> }
> #line 1861 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int e_send_superseded(struct drbd_work *w , int unused ) 
> { 
>   int tmp ;
> 
>   {
> #line 1863
>   tmp = e_send_ack(w, P_SUPERSEDED);
> #line 1863
>   return (tmp);
> }
> }
> #line 1866 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int e_send_retry_write(struct drbd_work *w , int unused ) 
> { 
>   struct drbd_tconn *tconn ;
>   int tmp ;
> 
>   {
> #line 1868
>   tconn = (w->ldv_50388.mdev)->tconn;
> #line 1870
>   tmp = e_send_ack(w, tconn->agreed_pro_version > 99 ? P_RETRY_WRITE : P_SUPERSEDED);
> #line 1870
>   return (tmp);
> }
> }
> #line 1874 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static bool seq_greater(u32 a , u32 b ) 
> { 
> 
> 
>   {
> #line 1881
>   return ((int )a - (int )b > 0);
> }
> }
> #line 1884 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static u32 seq_max(u32 a , u32 b ) 
> { 
>   bool tmp ;
> 
>   {
> #line 1886
>   tmp = seq_greater(a, b);
> #line 1886
>   return ((int )tmp ? a : b);
> }
> }
> #line 1889 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static bool need_peer_seq(struct drbd_conf *mdev ) 
> { 
>   struct drbd_tconn *tconn ;
>   int tp ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
23708a24671
>   int tmp___2 ;
23711,23720c24674,24695
< #line 1588
<   e = (struct drbd_epoch_entry *)w;
< #line 1589
<   ok = 1;
< #line 1591
<   if ((mdev->net_conf)->wire_protocol != 3) {
< #line 1591
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->net_conf->wire_protocol == DRBD_PROT_C ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1591);
---
> #line 1891
>   tconn = mdev->tconn;
> #line 1900
>   rcu_read_lock();
> #line 1901
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 1901
>   tmp = debug_lockdep_rcu_enabled();
> #line 1901
>   if (tmp != 0 && ! __warned) {
> #line 1901
>     tmp___0 = rcu_read_lock_held();
> #line 1901
>     if (tmp___0 == 0 && 1) {
> #line 1901
>       __warned = 1;
> #line 1901
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              1901, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
23724,23735c24699,24714
< #line 1592
<   ok = drbd_send_ack(mdev, P_DISCARD_ACK, e);
< #line 1594
<   spin_lock_irq(& mdev->req_lock);
< #line 1595
<   tmp = hlist_unhashed((struct hlist_node  const  *)(& e->collision));
< #line 1595
<   if (tmp != 0) {
< #line 1595
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !hlist_unhashed(&e->collision) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1595);
---
> #line 1901
>   tp = (int )_________p1->two_primaries;
> #line 1902
>   rcu_read_unlock();
> #line 1904
>   if (tp != 0) {
> #line 1904
>     tmp___1 = constant_test_bit(1U, (unsigned long const volatile   *)(& tconn->flags));
> #line 1904
>     if (tmp___1 != 0) {
> #line 1904
>       tmp___2 = 1;
>     } else {
> #line 1904
>       tmp___2 = 0;
>     }
23737c24716,24717
< 
---
> #line 1904
>     tmp___2 = 0;
23739,23753c24719,24748
< #line 1596
<   hlist_del_init(& e->collision);
< #line 1597
<   spin_unlock_irq(& mdev->req_lock);
< #line 1599
<   atomic_dec(& mdev->unacked_cnt);
< #line 1599
<   tmp___1 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1599
<   if (tmp___1 < 0) {
< #line 1599
<     tmp___0 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 1599
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: unacked_cnt = %d < 0 !\n",
<             "e_send_discard_ack", 1599, tmp___0);
---
> #line 1904
>   return ((bool )tmp___2);
> }
> }
> #line 1907 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void update_peer_seq(struct drbd_conf *mdev , unsigned int peer_seq ) 
> { 
>   unsigned int newest_peer_seq ;
>   bool tmp ;
> 
>   {
> #line 1911
>   tmp = need_peer_seq(mdev);
> #line 1911
>   if ((int )tmp) {
> #line 1912
>     spin_lock(& mdev->peer_seq_lock);
> #line 1913
>     newest_peer_seq = seq_max(mdev->peer_seq, peer_seq);
> #line 1914
>     mdev->peer_seq = newest_peer_seq;
> #line 1915
>     spin_unlock(& mdev->peer_seq_lock);
> #line 1917
>     if (peer_seq == newest_peer_seq) {
> #line 1918
>       __wake_up(& mdev->seq_wait, 3U, 1, 0);
>     } else {
> 
>     }
23757,23758c24752,24763
< #line 1601
<   return (ok);
---
> #line 1920
>   return;
> }
> }
> #line 1922 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> __inline static int overlaps(sector_t s1 , int l1 , sector_t s2 , int l2 ) 
> { 
> 
> 
>   {
> #line 1924
>   return ((sector_t )(l1 >> 9) + s1 > s2 && (sector_t )(l2 >> 9) + s2 > s1);
23761,23762c24766,24767
< #line 1604 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static bool overlapping_resync_write(struct drbd_conf *mdev , struct drbd_epoch_entry *data_e ) 
---
> #line 1928 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static bool overlapping_resync_write(struct drbd_conf *mdev , struct drbd_peer_request *peer_req ) 
23764c24769
<   struct drbd_epoch_entry *rs_e ;
---
>   struct drbd_peer_request *rs_req ;
23771c24776
< #line 1608
---
> #line 1931
23773,23775c24778,24780
< #line 1610
<   spin_lock_irq(& mdev->req_lock);
< #line 1611
---
> #line 1933
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 1934
23777,23784c24782,24789
< #line 1611
<   rs_e = (struct drbd_epoch_entry *)__mptr;
< #line 1611
<   goto ldv_52365;
<   ldv_52364: 
< #line 1612
<   tmp = overlaps(data_e->sector, (int )data_e->size, rs_e->sector, (int )rs_e->size);
< #line 1612
---
> #line 1934
>   rs_req = (struct drbd_peer_request *)__mptr;
> #line 1934
>   goto ldv_53065;
>   ldv_53064: 
> #line 1935
>   tmp = overlaps(peer_req->i.sector, (int )peer_req->i.size, rs_req->i.sector, (int )rs_req->i.size);
> #line 1935
23786c24791
< #line 1613
---
> #line 1937
23788,23789c24793,24794
< #line 1614
<     goto ldv_52363;
---
> #line 1938
>     goto ldv_53063;
23793,23801c24798,24806
< #line 1611
<   __mptr___0 = (struct list_head  const  *)rs_e->w.list.next;
< #line 1611
<   rs_e = (struct drbd_epoch_entry *)__mptr___0;
<   ldv_52365: ;
< #line 1611
<   if ((unsigned long )(& rs_e->w.list) != (unsigned long )(& mdev->sync_ee)) {
< #line 1612
<     goto ldv_52364;
---
> #line 1934
>   __mptr___0 = (struct list_head  const  *)rs_req->w.list.next;
> #line 1934
>   rs_req = (struct drbd_peer_request *)__mptr___0;
>   ldv_53065: ;
> #line 1934
>   if ((unsigned long )(& rs_req->w.list) != (unsigned long )(& mdev->sync_ee)) {
> #line 1935
>     goto ldv_53064;
23805,23808c24810,24813
<   ldv_52363: 
< #line 1617
<   spin_unlock_irq(& mdev->req_lock);
< #line 1619
---
>   ldv_53063: 
> #line 1941
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 1943
23812,23813c24817,24818
< #line 1643 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_wait_peer_seq(struct drbd_conf *mdev , u32 const   packet_seq ) 
---
> #line 1967 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int wait_for_and_update_peer_seq(struct drbd_conf *mdev , u32 const   peer_seq ) 
23817d24821
<   unsigned int p_seq ;
23820,23822c24824,24833
<   int tmp___0 ;
<   struct task_struct *tmp___1 ;
<   int tmp___2 ;
---
>   bool tmp___0 ;
>   int tmp___1 ;
>   bool tmp___2 ;
>   int tmp___3 ;
>   struct task_struct *tmp___4 ;
>   int tmp___5 ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___6 ;
>   int tmp___7 ;
23825c24836
< #line 1645
---
> #line 1969
23827c24838
< #line 1645
---
> #line 1969
23829c24840
< #line 1645
---
> #line 1969
23831c24842
< #line 1645
---
> #line 1969
23833c24844
< #line 1645
---
> #line 1969
23835c24846
< #line 1645
---
> #line 1969
23837,23839c24848,24865
< #line 1648
<   ret = 0;
< #line 1649
---
> #line 1973
>   tmp___0 = need_peer_seq(mdev);
> #line 1973
>   if (tmp___0) {
> #line 1973
>     tmp___1 = 0;
>   } else {
> #line 1973
>     tmp___1 = 1;
>   }
> #line 1973
>   if (tmp___1) {
> #line 1974
>     return (0);
>   } else {
> 
>   }
> #line 1976
23841,23849c24867,24885
<   ldv_52375: 
< #line 1651
<   prepare_to_wait(& mdev->seq_wait, & wait, 1);
< #line 1652
<   tmp___0 = seq_cmp(packet_seq, mdev->peer_seq + 1U);
< #line 1652
<   if (tmp___0 <= 0) {
< #line 1653
<     goto ldv_52374;
---
>   ldv_53077: 
> #line 1978
>   tmp___2 = seq_greater((unsigned int )peer_seq - 1U, mdev->peer_seq);
> #line 1978
>   if (tmp___2) {
> #line 1978
>     tmp___3 = 0;
>   } else {
> #line 1978
>     tmp___3 = 1;
>   }
> #line 1978
>   if (tmp___3) {
> #line 1979
>     mdev->peer_seq = seq_max(mdev->peer_seq, peer_seq);
> #line 1980
>     ret = 0;
> #line 1981
>     goto ldv_53073;
23853,23859c24889,24895
< #line 1654
<   tmp___1 = get_current();
< #line 1654
<   tmp___2 = signal_pending(tmp___1);
< #line 1654
<   if (tmp___2 != 0) {
< #line 1655
---
> #line 1983
>   tmp___4 = get_current();
> #line 1983
>   tmp___5 = signal_pending(tmp___4);
> #line 1983
>   if (tmp___5 != 0) {
> #line 1984
23861,23862c24897,24898
< #line 1656
<     goto ldv_52374;
---
> #line 1985
>     goto ldv_53073;
23866,23868c24902,24904
< #line 1658
<   p_seq = mdev->peer_seq;
< #line 1659
---
> #line 1987
>   prepare_to_wait(& mdev->seq_wait, & wait, 1);
> #line 1988
23870,23881c24906,24925
< #line 1660
<   timeout = schedule_timeout(7500L);
< #line 1661
<   spin_lock(& mdev->peer_seq_lock);
< #line 1662
<   if (timeout == 0L && mdev->peer_seq == p_seq) {
< #line 1663
<     ret = -110;
< #line 1664
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED waited 30 seconds for sequence update, forcing reconnect\n");
< #line 1665
<     goto ldv_52374;
---
> #line 1989
>   rcu_read_lock();
> #line 1990
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 1990
>   tmp___6 = debug_lockdep_rcu_enabled();
> #line 1990
>   if (tmp___6 != 0 && ! __warned) {
> #line 1990
>     tmp___7 = rcu_read_lock_held();
> #line 1990
>     if (tmp___7 == 0 && 1) {
> #line 1990
>       __warned = 1;
> #line 1990
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              1990, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
23885,23893c24929,24944
< #line 1667
<   goto ldv_52375;
<   ldv_52374: 
< #line 1668
<   finish_wait(& mdev->seq_wait, & wait);
< #line 1669
<   if (mdev->peer_seq + 1U == (unsigned int )packet_seq) {
< #line 1670
<     mdev->peer_seq = mdev->peer_seq + 1U;
---
> #line 1990
>   timeout = (long )((_________p1->ping_timeo * 250U) / 10U);
> #line 1991
>   rcu_read_unlock();
> #line 1992
>   timeout = schedule_timeout(timeout);
> #line 1993
>   spin_lock(& mdev->peer_seq_lock);
> #line 1994
>   if (timeout == 0L) {
> #line 1995
>     ret = -110;
> #line 1996
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Timed out waiting for missing ack packets; disconnecting\n");
> #line 1997
>     goto ldv_53073;
23897c24948,24951
< #line 1671
---
> #line 1999
>   goto ldv_53077;
>   ldv_53073: 
> #line 2000
23899c24953,24955
< #line 1672
---
> #line 2001
>   finish_wait(& mdev->seq_wait, & wait);
> #line 2002
23903c24959
< #line 1678 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 2008 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
23909c24965
< #line 1680
---
> #line 2010
23913,23914c24969,25192
< #line 1687 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_Data(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 2016 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void fail_postponed_requests(struct drbd_conf *mdev , sector_t sector , unsigned int size ) 
> { 
>   struct drbd_interval *i ;
>   struct drbd_request *req ;
>   struct bio_and_error m ;
>   struct drbd_interval  const  *__mptr ;
> 
>   {
>   repeat: 
> #line 2022
>   i = drbd_find_overlap(& mdev->write_requests, sector, size);
> #line 2022
>   goto ldv_53095;
>   ldv_53094: ;
> #line 2026
>   if ((unsigned int )*((unsigned char *)i + 48UL) == 0U) {
> #line 2027
>     goto ldv_53091;
>   } else {
> 
>   }
> #line 2028
>   __mptr = (struct drbd_interval  const  *)i;
> #line 2028
>   req = (struct drbd_request *)__mptr + 0xffffffffffffffd8UL;
> #line 2029
>   if (((unsigned long )req->rq_state & 8192UL) == 0UL) {
> #line 2030
>     goto ldv_53091;
>   } else {
> 
>   }
> #line 2031
>   req->rq_state = req->rq_state & 4294959103U;
> #line 2032
>   __req_mod(req, NEG_ACKED, & m);
> #line 2033
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 2034
>   if ((unsigned long )m.bio != (unsigned long )((struct bio *)0)) {
> #line 2035
>     complete_master_bio(mdev, & m);
>   } else {
> 
>   }
> #line 2036
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 2037
>   goto repeat;
>   ldv_53091: 
> #line 2022
>   i = drbd_next_overlap(i, sector, size);
>   ldv_53095: ;
> #line 2022
>   if ((unsigned long )i != (unsigned long )((struct drbd_interval *)0)) {
> #line 2023
>     goto ldv_53094;
>   } else {
> 
>   }
> 
> #line 2027
>   return;
> }
> }
> #line 2041 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int handle_write_conflicts(struct drbd_conf *mdev , struct drbd_peer_request *peer_req ) 
> { 
>   struct drbd_tconn *tconn ;
>   bool resolve_conflicts ;
>   int tmp ;
>   sector_t sector ;
>   unsigned int size ;
>   struct drbd_interval *i ;
>   bool equal ;
>   int err ;
>   bool superseded ;
>   struct drbd_request *req ;
>   struct drbd_interval  const  *__mptr ;
>   union drbd_state val ;
>   union drbd_state mask ;
> 
>   {
> #line 2044
>   tconn = mdev->tconn;
> #line 2045
>   tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& tconn->flags));
> #line 2045
>   resolve_conflicts = tmp != 0;
> #line 2046
>   sector = peer_req->i.sector;
> #line 2047
>   size = peer_req->i.size;
> #line 2056
>   drbd_insert_interval(& mdev->write_requests, & peer_req->i);
>   repeat: 
> #line 2059
>   i = drbd_find_overlap(& mdev->write_requests, sector, size);
> #line 2059
>   goto ldv_53120;
>   ldv_53119: ;
> #line 2060
>   if ((unsigned long )(& peer_req->i) == (unsigned long )i) {
> #line 2061
>     goto ldv_53109;
>   } else {
> 
>   }
> #line 2063
>   if ((unsigned int )*((unsigned char *)i + 48UL) == 0U) {
> #line 2069
>     err = drbd_wait_misc(mdev, i);
> #line 2070
>     if (err != 0) {
> #line 2071
>       goto out;
>     } else {
> 
>     }
> #line 2072
>     goto repeat;
>   } else {
> 
>   }
> #line 2075
>   equal = (bool )(i->sector == sector && i->size == size);
> #line 2076
>   if ((int )resolve_conflicts) {
> #line 2083
>     superseded = (bool )(i->sector <= sector && i->sector + (sector_t )(i->size >> 9) >= (sector_t )(size >> 9) + sector);
> #line 2086
>     if (! equal) {
> #line 2087
>       dev_alert((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Concurrent writes detected: local=%llus +%u, remote=%llus +%u, assuming %s came first\n",
>                 (unsigned long long )i->sector, i->size, (unsigned long long )sector,
>                 size, (int )superseded ? (char *)"local" : (char *)"remote");
>     } else {
> 
>     }
> #line 2094
>     inc_unacked(mdev);
> #line 2095
>     peer_req->w.cb = (int )superseded ? & e_send_superseded : & e_send_retry_write;
> #line 2097
>     list_add_tail(& peer_req->w.list, & mdev->done_ee);
> #line 2098
>     wake_asender(mdev->tconn);
> #line 2100
>     err = -2;
> #line 2101
>     goto out;
>   } else {
> #line 2104
>     __mptr = (struct drbd_interval  const  *)i;
> #line 2104
>     req = (struct drbd_request *)__mptr + 0xffffffffffffffd8UL;
> #line 2106
>     if (! equal) {
> #line 2107
>       dev_alert((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Concurrent writes detected: local=%llus +%u, remote=%llus +%u\n",
>                 (unsigned long long )i->sector, i->size, (unsigned long long )sector,
>                 size);
>     } else {
> 
>     }
> #line 2112
>     if ((int )req->rq_state & 1 || ((unsigned long )req->rq_state & 8192UL) == 0UL) {
> #line 2125
>       err = drbd_wait_misc(mdev, & req->i);
> #line 2126
>       if (err != 0) {
> #line 2128
>         val.i = 0U;
> #line 2128
>         val.ldv_40604.conn = 3U;
> #line 2128
>         mask.i = 0U;
> #line 2128
>         mask.ldv_40604.conn = 31U;
> #line 2128
>         _conn_request_state(mdev->tconn, mask, val, CS_HARD);
> #line 2130
>         fail_postponed_requests(mdev, sector, size);
> #line 2131
>         goto out;
>       } else {
> 
>       }
> #line 2133
>       goto repeat;
>     } else {
> 
>     }
> #line 2139
>     peer_req->flags = peer_req->flags | 32UL;
>   }
>   ldv_53109: 
> #line 2059
>   i = drbd_next_overlap(i, sector, size);
>   ldv_53120: ;
> #line 2059
>   if ((unsigned long )i != (unsigned long )((struct drbd_interval *)0)) {
> #line 2060
>     goto ldv_53119;
>   } else {
> 
>   }
> #line 2142
>   err = 0;
>   out: ;
> #line 2145
>   if (err != 0) {
> #line 2146
>     drbd_remove_epoch_entry_interval(mdev, peer_req);
>   } else {
> 
>   }
> #line 2147
>   return (err);
> }
> }
> #line 2151 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_Data(struct drbd_tconn *tconn , struct packet_info *pi ) 
23915a25194
>   struct drbd_conf *mdev ;
23917c25196
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
23918a25198,25199
>   u32 peer_seq ;
>   __u32 tmp ;
23921c25202,25204
<   __u32 tmp ;
---
>   int err ;
>   int tp ;
>   int err2 ;
23923,23928c25206,25211
<   int tmp___1 ;
<   __u64 tmp___2 ;
<   __u32 tmp___3 ;
<   unsigned long tmp___4 ;
<   int size ;
<   int discard ;
---
>   __u64 tmp___1 ;
>   __u32 tmp___2 ;
>   unsigned long tmp___3 ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___4 ;
23930,23950c25213,25214
<   wait_queue_t wait ;
<   struct task_struct *tmp___6 ;
<   struct drbd_request *i ;
<   struct hlist_node *n ;
<   struct hlist_head *slot ;
<   int first ;
<   long tmp___7 ;
<   long tmp___8 ;
<   __u32 tmp___9 ;
<   int tmp___10 ;
<   struct hlist_head *tmp___11 ;
<   int have_unacked ;
<   int have_conflict ;
<   struct task_struct *tmp___12 ;
<   struct task_struct *tmp___13 ;
<   int tmp___14 ;
<   struct hlist_node  const  *__mptr ;
<   struct task_struct *tmp___15 ;
<   int tmp___16 ;
<   bool tmp___17 ;
<   int tmp___18 ;
---
>   bool tmp___6 ;
>   int tmp___7 ;
23952,23955c25216,25222
<   struct task_struct *tmp___19 ;
<   bool tmp___20 ;
<   int tmp___21 ;
<   int tmp___22 ;
---
>   struct task_struct *tmp___8 ;
>   bool tmp___9 ;
>   int tmp___10 ;
>   struct net_conf *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___11 ;
>   int tmp___12 ;
23958,23960c25225,25231
< #line 1691
<   p = & mdev->data.rbuf.data;
< #line 1692
---
> #line 2156
>   p = (struct p_data *)pi->data;
> #line 2157
>   tmp = __fswab32(p->seq_num);
> #line 2157
>   peer_seq = tmp;
> #line 2158
23962,23973c25233,25257
< #line 1695
<   tmp___1 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1695
<   if (tmp___1 == 0) {
< #line 1696
<     spin_lock(& mdev->peer_seq_lock);
< #line 1697
<     tmp = __fswab32(p->seq_num);
< #line 1697
<     if (mdev->peer_seq + 1U == tmp) {
< #line 1698
<       mdev->peer_seq = mdev->peer_seq + 1U;
---
> #line 2162
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 2163
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 2164
>     return (-5);
>   } else {
> 
>   }
> #line 2166
>   tmp___0 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 2166
>   if (tmp___0 == 0) {
> #line 2169
>     err = wait_for_and_update_peer_seq(mdev, peer_seq);
> #line 2170
>     drbd_send_ack_dp(mdev, P_NEG_ACK, p, (int )pi->size);
> #line 2171
>     atomic_inc(& (tconn->current_epoch)->epoch_size);
> #line 2172
>     err2 = drbd_drain_block(mdev, (int )pi->size);
> #line 2173
>     if (err == 0) {
> #line 2174
>       err = err2;
23977,23986c25261,25262
< #line 1699
<     spin_unlock(& mdev->peer_seq_lock);
< #line 1701
<     drbd_send_ack_dp(mdev, P_NEG_ACK, p, (int )data_size);
< #line 1702
<     atomic_inc(& (mdev->current_epoch)->epoch_size);
< #line 1703
<     tmp___0 = drbd_drain_block(mdev, (int )data_size);
< #line 1703
<     return (tmp___0);
---
> #line 2175
>     return (err);
23990,23998c25266,25274
< #line 1711
<   tmp___2 = __fswab64(p->sector);
< #line 1711
<   sector = (sector_t )tmp___2;
< #line 1712
<   e = read_in_block(mdev, p->block_id, sector, (int )data_size);
< #line 1713
<   if ((unsigned long )e == (unsigned long )((struct drbd_epoch_entry *)0)) {
< #line 1714
---
> #line 2184
>   tmp___1 = __fswab64(p->sector);
> #line 2184
>   sector = (sector_t )tmp___1;
> #line 2185
>   peer_req = read_in_block(mdev, p->block_id, sector, (int )pi->size);
> #line 2186
>   if ((unsigned long )peer_req == (unsigned long )((struct drbd_peer_request *)0)) {
> #line 2187
24000,24001c25276,25277
< #line 1715
<     return (0);
---
> #line 2188
>     return (-5);
24005,24022c25281,25298
< #line 1718
<   e->w.cb = & e_end_block;
< #line 1720
<   tmp___3 = __fswab32(p->dp_flags);
< #line 1720
<   dp_flags = tmp___3;
< #line 1721
<   tmp___4 = wire_flags_to_bio(mdev, dp_flags);
< #line 1721
<   rw = (int )((unsigned int )tmp___4 | (unsigned int )rw);
< #line 1722
<   if ((unsigned long )e->pages == (unsigned long )((struct page *)0)) {
< #line 1723
<     if (e->size != 0U) {
< #line 1723
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( e->size == 0 ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               1723);
---
> #line 2191
>   peer_req->w.cb = & e_end_block;
> #line 2193
>   tmp___2 = __fswab32(p->dp_flags);
> #line 2193
>   dp_flags = tmp___2;
> #line 2194
>   tmp___3 = wire_flags_to_bio(mdev, dp_flags);
> #line 2194
>   rw = (int )((unsigned int )tmp___3 | (unsigned int )rw);
> #line 2195
>   if ((unsigned long )peer_req->pages == (unsigned long )((struct page *)0)) {
> #line 2196
>     if (peer_req->i.size != 0U) {
> #line 2196
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( peer_req->i.size == 0 ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>               2196);
24026c25302
< #line 1724
---
> #line 2197
24028c25304
< #line 1724
---
> #line 2197
24030,24031c25306,25307
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               1724);
---
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>               2197);
24038c25314
< #line 1727
---
> #line 2200
24040,24041c25316,25317
< #line 1728
<     e->flags = e->flags | 2UL;
---
> #line 2201
>     peer_req->flags = peer_req->flags | 2UL;
24045,24097c25321,25347
< #line 1730
<   spin_lock(& mdev->epoch_lock);
< #line 1731
<   e->epoch = mdev->current_epoch;
< #line 1732
<   atomic_inc(& (e->epoch)->epoch_size);
< #line 1733
<   atomic_inc(& (e->epoch)->active);
< #line 1734
<   spin_unlock(& mdev->epoch_lock);
< #line 1737
<   if ((unsigned int )*((unsigned char *)mdev->net_conf + 540UL) == 0U) {
< #line 1738
<     spin_lock_irq(& mdev->req_lock);
<   } else {
< #line 1742
<     size = (int const   )e->size;
< #line 1743
<     tmp___5 = drbd_test_flag(mdev, DISCARD_CONCURRENT);
< #line 1743
<     discard = tmp___5;
< #line 1744
<     tmp___6 = get_current();
< #line 1744
<     wait.flags = 0U;
< #line 1744
<     wait.private = (void *)tmp___6;
< #line 1744
<     wait.func = & autoremove_wake_function;
< #line 1744
<     wait.task_list.next = & wait.task_list;
< #line 1744
<     wait.task_list.prev = & wait.task_list;
< #line 1750
<     if ((mdev->net_conf)->wire_protocol != 3) {
< #line 1750
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->net_conf->wire_protocol == DRBD_PROT_C ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               1750);
<     } else {
< 
<     }
< #line 1751
<     tmp___7 = __builtin_expect((unsigned long )mdev->ee_hash == (unsigned long )((struct hlist_head *)0),
<                                0L);
< #line 1751
<     if (tmp___7 != 0L) {
< #line 1751
<       __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
<                            "i" (1751), "i" (12UL));
<       ldv_52397: ;
< #line 1751
<       goto ldv_52397;
---
> #line 2203
>   spin_lock(& tconn->epoch_lock);
> #line 2204
>   peer_req->epoch = tconn->current_epoch;
> #line 2205
>   atomic_inc(& (peer_req->epoch)->epoch_size);
> #line 2206
>   atomic_inc(& (peer_req->epoch)->active);
> #line 2207
>   spin_unlock(& tconn->epoch_lock);
> #line 2209
>   rcu_read_lock();
> #line 2210
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 2210
>   tmp___4 = debug_lockdep_rcu_enabled();
> #line 2210
>   if (tmp___4 != 0 && ! __warned) {
> #line 2210
>     tmp___5 = rcu_read_lock_held();
> #line 2210
>     if (tmp___5 == 0 && 1) {
> #line 2210
>       __warned = 1;
> #line 2210
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              2210, "suspicious rcu_dereference_check() usage");
24101,24112c25351
< #line 1752
<     tmp___8 = __builtin_expect((unsigned long )mdev->tl_hash == (unsigned long )((struct hlist_head *)0),
<                                0L);
< #line 1752
<     if (tmp___8 != 0L) {
< #line 1752
<       __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
<                            "i" (1752), "i" (12UL));
<       ldv_52398: ;
< #line 1752
<       goto ldv_52398;
<     } else {
---
>   } else {
24114,24121c25353,25366
<     }
< #line 1788
<     tmp___9 = __fswab32(p->seq_num);
< #line 1788
<     tmp___10 = drbd_wait_peer_seq(mdev, tmp___9);
< #line 1788
<     if (tmp___10 != 0) {
< #line 1789
---
>   }
> #line 2210
>   tp = (int )_________p1->two_primaries;
> #line 2211
>   rcu_read_unlock();
> #line 2212
>   if (tp != 0) {
> #line 2213
>     peer_req->flags = peer_req->flags | 128UL;
> #line 2214
>     err = wait_for_and_update_peer_seq(mdev, peer_seq);
> #line 2215
>     if (err != 0) {
> #line 2216
24126,24168c25371,25384
< #line 1791
<     spin_lock_irq(& mdev->req_lock);
< #line 1793
<     tmp___11 = ee_hash_slot(mdev, sector);
< #line 1793
<     hlist_add_head(& e->collision, tmp___11);
< #line 1796
<     slot = tl_hash_slot(mdev, sector);
< #line 1797
<     first = 1;
<     ldv_52409: 
< #line 1799
<     have_unacked = 0;
< #line 1800
<     have_conflict = 0;
< #line 1801
<     prepare_to_wait(& mdev->misc_wait, & wait, 1);
< #line 1803
<     n = slot->first;
< #line 1803
<     goto ldv_52406;
<     ldv_52405: 
< #line 1804
<     tmp___14 = overlaps(i->sector, (int )i->size, sector, size);
< #line 1804
<     if (tmp___14 != 0) {
< #line 1807
<       if (first != 0) {
< #line 1808
<         tmp___12 = get_current();
< #line 1808
<         tmp___13 = get_current();
< #line 1808
<         dev_alert((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s[%u] Concurrent local write detected!\tnew: %llus +%u; pending: %llus +%u\n",
<                   (char *)(& tmp___13->comm), tmp___12->pid, (unsigned long long )sector,
<                   size, (unsigned long long )i->sector, i->size);
<       } else {
< 
<       }
< #line 1813
<       if ((i->rq_state & 16UL) != 0UL) {
< #line 1814
<         have_unacked = have_unacked + 1;
---
> #line 2217
>     spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 2218
>     err = handle_write_conflicts(mdev, peer_req);
> #line 2219
>     if (err != 0) {
> #line 2220
>       spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 2221
>       if (err == -2) {
> #line 2222
>         put_ldev(mdev);
> #line 2223
>         return (0);
24172,24173c25388,25389
< #line 1815
<       have_conflict = have_conflict + 1;
---
> #line 2225
>       goto out_interrupted;
24177,24193c25393,25408
< #line 1803
<     n = n->next;
<     ldv_52406: ;
< #line 1803
<     if ((unsigned long )n != (unsigned long )((struct hlist_node *)0)) {
< #line 1803
<       __mptr = (struct hlist_node  const  *)n;
< #line 1803
<       i = (struct drbd_request *)__mptr + 0xffffffffffffffd8UL;
< #line 1803
<       if (1 != 0) {
< #line 1804
<         goto ldv_52405;
<       } else {
< #line 1806
<         goto ldv_52407;
<       }
---
>   } else {
> #line 2228
>     spin_lock_irq(& (mdev->tconn)->req_lock);
>   }
> #line 2229
>   list_add(& peer_req->w.list, & mdev->active_ee);
> #line 2230
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 2232
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 272U) {
> #line 2233
>     tmp___6 = overlapping_resync_write(mdev, peer_req);
> #line 2233
>     if (tmp___6) {
> #line 2233
>       tmp___7 = 0;
24195c25410,25411
< 
---
> #line 2233
>       tmp___7 = 1;
24197,24201c25413,25416
<     ldv_52407: ;
< #line 1819
<     if (have_conflict == 0) {
< #line 1820
<       goto ldv_52408;
---
> #line 2233
>     if (tmp___7) {
> #line 2233
>       goto ldv_53140;
24205,24225c25420,25440
< #line 1823
<     if ((first != 0 && discard != 0) && have_unacked != 0) {
< #line 1824
<       dev_alert((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Concurrent write! [DISCARD BY FLAG] sec=%llus\n",
<                 (unsigned long long )sector);
< #line 1826
<       inc_unacked(mdev);
< #line 1827
<       e->w.cb = & e_send_discard_ack;
< #line 1828
<       list_add_tail(& e->w.list, & mdev->done_ee);
< #line 1830
<       spin_unlock_irq(& mdev->req_lock);
< #line 1835
<       put_ldev(mdev);
< #line 1836
<       wake_asender(mdev);
< #line 1837
<       finish_wait(& mdev->misc_wait, & wait);
< #line 1838
<       return (1);
---
> #line 2233
>     tmp___8 = get_current();
> #line 2233
>     __wait.flags = 0U;
> #line 2233
>     __wait.private = (void *)tmp___8;
> #line 2233
>     __wait.func = & autoremove_wake_function;
> #line 2233
>     __wait.task_list.next = & __wait.task_list;
> #line 2233
>     __wait.task_list.prev = & __wait.task_list;
>     ldv_53143: 
> #line 2233
>     prepare_to_wait(& mdev->ee_wait, & __wait, 2);
> #line 2233
>     tmp___9 = overlapping_resync_write(mdev, peer_req);
> #line 2233
>     if (tmp___9) {
> #line 2233
>       tmp___10 = 0;
24227c25442,25443
< 
---
> #line 2233
>       tmp___10 = 1;
24229,24242c25445,25448
< #line 1841
<     tmp___15 = get_current();
< #line 1841
<     tmp___16 = signal_pending(tmp___15);
< #line 1841
<     if (tmp___16 != 0) {
< #line 1842
<       hlist_del_init(& e->collision);
< #line 1844
<       spin_unlock_irq(& mdev->req_lock);
< #line 1846
<       finish_wait(& mdev->misc_wait, & wait);
< #line 1847
<       goto out_interrupted;
---
> #line 2233
>     if (tmp___10) {
> #line 2233
>       goto ldv_53142;
24246,24263c25452,25481
< #line 1850
<     spin_unlock_irq(& mdev->req_lock);
< #line 1851
<     if (first != 0) {
< #line 1852
<       first = 0;
< #line 1853
<       dev_alert((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Concurrent write! [W AFTERWARDS] sec=%llus\n",
<                 (unsigned long long )sector);
<     } else
< #line 1855
<     if (discard != 0) {
< #line 1858
<       if (have_unacked != 0) {
< #line 1858
<         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( have_unacked == 0 ) in %s:%d\n",
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                 1858);
---
> #line 2233
>     schedule();
> #line 2233
>     goto ldv_53143;
>     ldv_53142: 
> #line 2233
>     finish_wait(& mdev->ee_wait, & __wait);
>     ldv_53140: ;
>   } else {
> 
>   }
> #line 2235
>   if ((mdev->tconn)->agreed_pro_version <= 99) {
> #line 2236
>     rcu_read_lock();
> #line 2237
>     _________p1___0 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 2237
>     tmp___11 = debug_lockdep_rcu_enabled();
> #line 2237
>     if (tmp___11 != 0 && ! __warned___0) {
> #line 2237
>       tmp___12 = rcu_read_lock_held();
> #line 2237
>       if (tmp___12 == 0 && 1) {
> #line 2237
>         __warned___0 = 1;
> #line 2237
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                                2237, "suspicious rcu_dereference_check() usage");
24270,24326c25488,25499
< #line 1860
<     schedule();
< #line 1861
<     spin_lock_irq(& mdev->req_lock);
< #line 1862
<     goto ldv_52409;
<     ldv_52408: 
< #line 1863
<     finish_wait(& mdev->misc_wait, & wait);
<   }
< #line 1866
<   list_add(& e->w.list, & mdev->active_ee);
< #line 1867
<   spin_unlock_irq(& mdev->req_lock);
< #line 1869
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 272U) {
< #line 1870
<     tmp___17 = overlapping_resync_write(mdev, e);
< #line 1870
<     if (tmp___17) {
< #line 1870
<       tmp___18 = 0;
<     } else {
< #line 1870
<       tmp___18 = 1;
<     }
< #line 1870
<     if (tmp___18) {
< #line 1870
<       goto ldv_52410;
<     } else {
< 
<     }
< #line 1870
<     tmp___19 = get_current();
< #line 1870
<     __wait.flags = 0U;
< #line 1870
<     __wait.private = (void *)tmp___19;
< #line 1870
<     __wait.func = & autoremove_wake_function;
< #line 1870
<     __wait.task_list.next = & __wait.task_list;
< #line 1870
<     __wait.task_list.prev = & __wait.task_list;
<     ldv_52413: 
< #line 1870
<     prepare_to_wait(& mdev->ee_wait, & __wait, 2);
< #line 1870
<     tmp___20 = overlapping_resync_write(mdev, e);
< #line 1870
<     if (tmp___20) {
< #line 1870
<       tmp___21 = 0;
<     } else {
< #line 1870
<       tmp___21 = 1;
---
> #line 2237
>     switch (_________p1___0->wire_protocol) {
>     case (__u32 )3: 
> #line 2239
>     dp_flags = dp_flags | 256U;
> #line 2240
>     goto ldv_53148;
>     case (__u32 )2: 
> #line 2242
>     dp_flags = dp_flags | 128U;
> #line 2243
>     goto ldv_53148;
24328,24332c25501,25504
< #line 1870
<     if (tmp___21) {
< #line 1870
<       goto ldv_52412;
<     } else {
---
>     ldv_53148: 
> #line 2245
>     rcu_read_unlock();
>   } else {
24334,24342c25506,25512
<     }
< #line 1870
<     schedule();
< #line 1870
<     goto ldv_52413;
<     ldv_52412: 
< #line 1870
<     finish_wait(& mdev->ee_wait, & __wait);
<     ldv_52410: ;
---
>   }
> #line 2248
>   if ((dp_flags & 256U) != 0U) {
> #line 2249
>     peer_req->flags = peer_req->flags | 64UL;
> #line 2250
>     inc_unacked(mdev);
24346,24360c25516,25521
< #line 1872
<   switch ((mdev->net_conf)->wire_protocol) {
<   case 3: 
< #line 1874
<   inc_unacked(mdev);
< #line 1877
<   goto ldv_52415;
<   case 2: 
< #line 1881
<   drbd_send_ack(mdev, P_RECV_ACK, e);
< #line 1882
<   goto ldv_52415;
<   case 1: ;
< #line 1885
<   goto ldv_52415;
---
> #line 2255
>   if ((dp_flags & 128U) != 0U) {
> #line 2258
>     drbd_send_ack(mdev, P_RECV_ACK, peer_req);
>   } else {
> 
24362,24373c25523,25533
<   ldv_52415: ;
< #line 1888
<   if ((int )mdev->state.ldv_40583.pdsk <= 3) {
< #line 1890
<     __drbd_set_out_of_sync(mdev, e->sector, (int )e->size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                            1890U);
< #line 1891
<     e->flags = e->flags | 1UL;
< #line 1892
<     e->flags = e->flags & 0xfffffffffffffffdUL;
< #line 1893
<     drbd_al_begin_io(mdev, e->sector);
---
> #line 2261
>   if ((int )mdev->state.ldv_50103.pdsk <= 3) {
> #line 2263
>     __drbd_set_out_of_sync(mdev, peer_req->i.sector, (int )peer_req->i.size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                            2263U);
> #line 2264
>     peer_req->flags = peer_req->flags | 1UL;
> #line 2265
>     peer_req->flags = peer_req->flags & 0xfffffffffffffffdUL;
> #line 2266
>     drbd_al_begin_io(mdev, & peer_req->i);
24377,24382c25537,25542
< #line 1896
<   tmp___22 = drbd_submit_ee(mdev, e, (unsigned int const   )rw, 4);
< #line 1896
<   if (tmp___22 == 0) {
< #line 1897
<     return (1);
---
> #line 2269
>   err = drbd_submit_peer_request(mdev, peer_req, (unsigned int const   )rw, 4);
> #line 2270
>   if (err == 0) {
> #line 2271
>     return (0);
24386c25546
< #line 1900
---
> #line 2274
24388,24399c25548,25559
< #line 1901
<   spin_lock_irq(& mdev->req_lock);
< #line 1902
<   list_del(& e->w.list);
< #line 1903
<   hlist_del_init(& e->collision);
< #line 1904
<   spin_unlock_irq(& mdev->req_lock);
< #line 1905
<   if ((int )e->flags & 1) {
< #line 1906
<     drbd_al_complete_io(mdev, e->sector);
---
> #line 2275
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 2276
>   list_del(& peer_req->w.list);
> #line 2277
>   drbd_remove_epoch_entry_interval(mdev, peer_req);
> #line 2278
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 2279
>   if ((int )peer_req->flags & 1) {
> #line 2280
>     drbd_al_complete_io(mdev, & peer_req->i);
24404,24406c25564,25566
< #line 1909
<   drbd_may_finish_epoch(mdev, e->epoch, EV_CLEANUP);
< #line 1910
---
> #line 2283
>   drbd_may_finish_epoch(tconn, peer_req->epoch, EV_CLEANUP);
> #line 2284
24408,24411c25568,25571
< #line 1911
<   drbd_free_some_ee(mdev, e, 0);
< #line 1912
<   return (0);
---
> #line 2285
>   __drbd_free_peer_req(mdev, peer_req, 0);
> #line 2286
>   return (err);
24414c25574
< #line 1926 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 2300 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
24423a25584,25588
>   unsigned int c_min_rate ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___0 ;
>   int tmp___1 ;
24426c25591
<   int tmp___0 ;
---
>   int tmp___2 ;
24435c25600
<   int tmp___1 ;
---
>   int tmp___3 ;
24438c25603
<   unsigned long tmp___2 ;
---
>   unsigned long tmp___4 ;
24441c25606
< #line 1928
---
> #line 2302
24443c25608
< #line 1932
---
> #line 2306
24445,24447c25610,25639
< #line 1935
<   if (mdev->sync_conf.c_min_rate == 0) {
< #line 1936
---
> #line 2309
>   rcu_read_lock();
> #line 2310
>   _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 2310
>   tmp___0 = debug_lockdep_rcu_enabled();
> #line 2310
>   if (tmp___0 != 0 && ! __warned) {
> #line 2310
>     tmp___1 = rcu_read_lock_held();
> #line 2310
>     if (tmp___1 == 0 && 1) {
> #line 2310
>       __warned = 1;
> #line 2310
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              2310, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2310
>   c_min_rate = _________p1->c_min_rate;
> #line 2311
>   rcu_read_unlock();
> #line 2314
>   if (c_min_rate == 0U) {
> #line 2315
24452c25644
< #line 1938
---
> #line 2317
24454c25646
< #line 1939
---
> #line 2318
24456c25648
< #line 1940
---
> #line 2319
24458c25650
< #line 1941
---
> #line 2320
24460c25652
< #line 1941
---
> #line 2320
24462,24466c25654,25658
< #line 1942
<     tmp___0 = constant_test_bit(2U, (unsigned long const volatile   *)(& bm_ext->flags));
< #line 1942
<     if (tmp___0 != 0) {
< #line 1943
---
> #line 2321
>     tmp___2 = constant_test_bit(2U, (unsigned long const volatile   *)(& bm_ext->flags));
> #line 2321
>     if (tmp___2 != 0) {
> #line 2322
24468c25660
< #line 1944
---
> #line 2323
24476c25668
< #line 1948
---
> #line 2327
24478c25670
< #line 1950
---
> #line 2329
24480c25672
< #line 1950
---
> #line 2329
24482,24485c25674,25677
< #line 1950
<   goto ldv_52439;
<   ldv_52438: 
< #line 1950
---
> #line 2329
>   goto ldv_53175;
>   ldv_53174: 
> #line 2329
24487c25679
< #line 1950
---
> #line 2329
24489c25681
< #line 1950
---
> #line 2329
24491,24492c25683,25684
<   ldv_52439: 
< #line 1950
---
>   ldv_53175: 
> #line 2329
24494c25686
< #line 1950
---
> #line 2329
24496,24497c25688,25689
< #line 1951
<     goto ldv_52438;
---
> #line 2330
>     goto ldv_53174;
24501c25693
< #line 1951
---
> #line 2330
24503c25695
< #line 1951
---
> #line 2330
24505,24508c25697,25700
< #line 1951
<   goto ldv_52449;
<   ldv_52448: 
< #line 1951
---
> #line 2330
>   goto ldv_53185;
>   ldv_53184: 
> #line 2330
24510c25702
< #line 1951
---
> #line 2330
24512c25704
< #line 1951
---
> #line 2330
24514,24515c25706,25707
<   ldv_52449: 
< #line 1951
---
>   ldv_53185: 
> #line 2330
24517c25709
< #line 1951
---
> #line 2330
24519,24520c25711,25712
< #line 1952
<     goto ldv_52448;
---
> #line 2331
>     goto ldv_53184;
24524,24528c25716,25720
< #line 1951
<   tmp___1 = atomic_read((atomic_t const   *)(& mdev->rs_sect_ev));
< #line 1951
<   curr_events = ((int )res + (int )res___0) - tmp___1;
< #line 1954
---
> #line 2330
>   tmp___3 = atomic_read((atomic_t const   *)(& mdev->rs_sect_ev));
> #line 2330
>   curr_events = ((int )res + (int )res___0) - tmp___3;
> #line 2333
24530c25722
< #line 1958
---
> #line 2337
24532c25724
< #line 1962
---
> #line 2341
24534,24536c25726,25728
< #line 1964
<     if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 288U || (unsigned int )*((unsigned short *)mdev + 1138UL) == 304U) {
< #line 1965
---
> #line 2343
>     if ((unsigned int )*((unsigned short *)mdev + 374UL) == 288U || (unsigned int )*((unsigned short *)mdev + 374UL) == 304U) {
> #line 2344
24539,24542c25731,25734
< #line 1967
<       tmp___2 = drbd_bm_total_weight(mdev);
< #line 1967
<       rs_left = tmp___2 - mdev->rs_failed;
---
> #line 2346
>       tmp___4 = drbd_bm_total_weight(mdev);
> #line 2346
>       rs_left = tmp___4 - mdev->rs_failed;
24544c25736
< #line 1969
---
> #line 2348
24546c25738
< #line 1970
---
> #line 2349
24548c25740
< #line 1971
---
> #line 2350
24553c25745
< #line 1972
---
> #line 2351
24555c25747
< #line 1973
---
> #line 2352
24557,24559c25749,25751
< #line 1975
<     if ((unsigned long )mdev->sync_conf.c_min_rate < dbdt) {
< #line 1976
---
> #line 2354
>     if ((unsigned long )c_min_rate < dbdt) {
> #line 2355
24567c25759
< #line 1978
---
> #line 2357
24571,24572c25763,25764
< #line 1982 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_DataRequest(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int digest_size ) 
---
> #line 2361 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_DataRequest(struct drbd_tconn *tconn , struct packet_info *pi ) 
24573a25766
>   struct drbd_conf *mdev ;
24576,24577c25769
<   sector_t tmp ;
<   struct drbd_epoch_entry *e ;
---
>   struct drbd_peer_request *peer_req ;
24583,24584c25775,25777
<   __u64 tmp___0 ;
<   __u32 tmp___1 ;
---
>   __u64 tmp ;
>   __u32 tmp___0 ;
>   int tmp___1 ;
24587c25780
<   char const   *tmp___4 ;
---
>   void *tmp___4 ;
24589,24594d25781
<   int tmp___6 ;
<   int tmp___7 ;
<   void *tmp___8 ;
<   int tmp___9 ;
<   int tmp___10 ;
<   int tmp___11 ;
24597,24601c25784,25787
<   unsigned long tmp___12 ;
<   char const   *tmp___13 ;
<   int tmp___14 ;
<   int tmp___15 ;
<   int tmp___16 ;
---
>   unsigned long tmp___6 ;
>   int tmp___7 ;
>   int tmp___8 ;
>   int tmp___9 ;
24604,24608c25790
< #line 1985
<   tmp = drbd_get_capacity(mdev->this_bdev);
< #line 1985
<   capacity = tmp;
< #line 1987
---
> #line 2367
24610,24622c25792,25815
< #line 1990
<   p = & mdev->data.rbuf.block_req;
< #line 1992
<   tmp___0 = __fswab64(p->sector);
< #line 1992
<   sector = (sector_t )tmp___0;
< #line 1993
<   tmp___1 = __fswab32(p->blksize);
< #line 1993
<   size = (int )tmp___1;
< #line 1995
<   if ((size <= 0 || (size & 511) != 0) || (unsigned int )size > 131072U) {
< #line 1996
---
> #line 2370
>   p = (struct p_block_req *)pi->data;
> #line 2372
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 2373
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 2374
>     return (-5);
>   } else {
> 
>   }
> #line 2375
>   capacity = drbd_get_capacity(mdev->this_bdev);
> #line 2377
>   tmp = __fswab64(p->sector);
> #line 2377
>   sector = (sector_t )tmp;
> #line 2378
>   tmp___0 = __fswab32(p->blksize);
> #line 2378
>   size = (int )tmp___0;
> #line 2380
>   if ((size <= 0 || (size & 511) != 0) || (unsigned int )size > 1048576U) {
> #line 2381
24624,24627c25817,25820
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             1996, (unsigned long long )sector, size);
< #line 1998
<     return (0);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             2381, (unsigned long long )sector, size);
> #line 2383
>     return (-22);
24631c25824
< #line 2000
---
> #line 2385
24633c25826
< #line 2001
---
> #line 2386
24635,24638c25828,25831
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             2001, (unsigned long long )sector, size);
< #line 2003
<     return (0);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             2386, (unsigned long long )sector, size);
> #line 2388
>     return (-22);
24642,24646c25835,25839
< #line 2006
<   tmp___7 = _get_ldev_if_state(mdev, D_UP_TO_DATE);
< #line 2006
<   if (tmp___7 == 0) {
< #line 2007
---
> #line 2391
>   tmp___3 = _get_ldev_if_state(mdev, D_UP_TO_DATE);
> #line 2391
>   if (tmp___3 == 0) {
> #line 2392
24648,24649c25841,25842
< #line 2008
<     switch ((unsigned int )cmd) {
---
> #line 2393
>     switch ((unsigned int )pi->cmd) {
24651c25844
< #line 2010
---
> #line 2395
24653,24654c25846,25847
< #line 2011
<     goto ldv_52468;
---
> #line 2396
>     goto ldv_53204;
24658c25851
< #line 2015
---
> #line 2400
24660,24661c25853,25854
< #line 2016
<     goto ldv_52468;
---
> #line 2401
>     goto ldv_53204;
24663c25856
< #line 2018
---
> #line 2403
24665,24679c25858,25860
< #line 2019
<     atomic_dec(& mdev->rs_pending_cnt);
< #line 2019
<     tmp___3 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 2019
<     if (tmp___3 < 0) {
< #line 2019
<       tmp___2 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 2019
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
<               "receive_DataRequest", 2019, tmp___2);
<     } else {
< 
<     }
< #line 2020
---
> #line 2404
>     _dec_rs_pending(mdev, "receive_DataRequest", 2404);
> #line 2405
24681,24682c25862,25863
< #line 2021
<     goto ldv_52468;
---
> #line 2406
>     goto ldv_53204;
24684,24688c25865,25870
< #line 2023
<     tmp___4 = cmdname(cmd);
< #line 2023
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "unexpected command (%s) in receive_DataRequest\n",
<             tmp___4);
---
> #line 2408
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
>                          "i" (2408), "i" (12UL));
>     ldv_53211: ;
> #line 2408
>     goto ldv_53211;
24690,24691c25872,25873
<     ldv_52468: ;
< #line 2026
---
>     ldv_53204: ;
> #line 2410
24693,24697c25875,25879
< #line 2026
<       tmp___5 = ___ratelimit(& drbd_ratelimit_state, "receive_DataRequest");
< #line 2026
<       if (tmp___5 != 0) {
< #line 2027
---
> #line 2410
>       tmp___1 = ___ratelimit(& drbd_ratelimit_state, "receive_DataRequest");
> #line 2410
>       if (tmp___1 != 0) {
> #line 2411
24705,24708c25887,25890
< #line 2031
<     tmp___6 = drbd_drain_block(mdev, (int )digest_size);
< #line 2031
<     return (tmp___6);
---
> #line 2415
>     tmp___2 = drbd_drain_block(mdev, (int )pi->size);
> #line 2415
>     return (tmp___2);
24712,24716c25894,25898
< #line 2037
<   e = drbd_alloc_ee(mdev, p->block_id, sector, (unsigned int )size, 16U);
< #line 2038
<   if ((unsigned long )e == (unsigned long )((struct drbd_epoch_entry *)0)) {
< #line 2039
---
> #line 2421
>   peer_req = drbd_alloc_peer_req(mdev, p->block_id, sector, (unsigned int )size, 16U);
> #line 2422
>   if ((unsigned long )peer_req == (unsigned long )((struct drbd_peer_request *)0)) {
> #line 2423
24718,24719c25900,25901
< #line 2040
<     return (0);
---
> #line 2424
>     return (-12);
24723,24724c25905,25906
< #line 2043
<   switch ((unsigned int )cmd) {
---
> #line 2427
>   switch ((unsigned int )pi->cmd) {
24726,24728c25908,25910
< #line 2045
<   e->w.cb = & w_e_end_data_req;
< #line 2046
---
> #line 2429
>   peer_req->w.cb = & w_e_end_data_req;
> #line 2430
24730c25912
< #line 2048
---
> #line 2432
24733,24735c25915,25917
< #line 2051
<   e->w.cb = & w_e_end_rsdata_req;
< #line 2052
---
> #line 2435
>   peer_req->w.cb = & w_e_end_rsdata_req;
> #line 2436
24737c25919
< #line 2054
---
> #line 2438
24739,24740c25921,25922
< #line 2055
<   goto ldv_52481;
---
> #line 2439
>   goto ldv_53215;
24743c25925
< #line 2059
---
> #line 2443
24745,24749c25927,25931
< #line 2060
<   tmp___8 = kmalloc((unsigned long )digest_size + 16UL, 16U);
< #line 2060
<   di = (struct digest_info *)tmp___8;
< #line 2061
---
> #line 2444
>   tmp___4 = kmalloc((unsigned long )pi->size + 16UL, 16U);
> #line 2444
>   di = (struct digest_info *)tmp___4;
> #line 2445
24751c25933
< #line 2062
---
> #line 2446
24756,24758c25938,25940
< #line 2064
<   di->digest_size = (int )digest_size;
< #line 2065
---
> #line 2448
>   di->digest_size = (int )pi->size;
> #line 2449
24760,24768c25942,25950
< #line 2067
<   e->ldv_49794.digest = di;
< #line 2068
<   e->flags = e->flags | 16UL;
< #line 2070
<   tmp___9 = drbd_recv(mdev, di->digest, (size_t )digest_size);
< #line 2070
<   if ((unsigned int )tmp___9 != digest_size) {
< #line 2071
---
> #line 2451
>   peer_req->ldv_50490.digest = di;
> #line 2452
>   peer_req->flags = peer_req->flags | 16UL;
> #line 2454
>   tmp___5 = drbd_recv_all(mdev->tconn, di->digest, (size_t )pi->size);
> #line 2454
>   if (tmp___5 != 0) {
> #line 2455
24773,24780c25955,25962
< #line 2073
<   if ((unsigned int )cmd == 33U) {
< #line 2074
<     if (mdev->agreed_pro_version <= 88) {
< #line 2074
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->agreed_pro_version >= 89 ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               2074);
---
> #line 2457
>   if ((unsigned int )pi->cmd == 33U) {
> #line 2458
>     if ((mdev->tconn)->agreed_pro_version <= 88) {
> #line 2458
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->tconn->agreed_pro_version >= 89 ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>               2458);
24784,24786c25966,25968
< #line 2075
<     e->w.cb = & w_e_end_csum_rs_req;
< #line 2077
---
> #line 2459
>     peer_req->w.cb = & w_e_end_csum_rs_req;
> #line 2461
24789,24791c25971,25973
< #line 2078
<   if ((unsigned int )cmd == 31U) {
< #line 2080
---
> #line 2462
>   if ((unsigned int )pi->cmd == 31U) {
> #line 2464
24793,24809c25975,25979
< #line 2081
<     e->w.cb = & w_e_end_ov_reply;
< #line 2082
<     atomic_dec(& mdev->rs_pending_cnt);
< #line 2082
<     tmp___11 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 2082
<     if (tmp___11 < 0) {
< #line 2082
<       tmp___10 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 2082
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
<               "receive_DataRequest", 2082, tmp___10);
<     } else {
< 
<     }
< #line 2085
---
> #line 2465
>     peer_req->w.cb = & w_e_end_ov_reply;
> #line 2466
>     _dec_rs_pending(mdev, "receive_DataRequest", 2466);
> #line 2469
24814,24815c25984,25985
< #line 2087
<   goto ldv_52481;
---
> #line 2471
>   goto ldv_53215;
24817,24819c25987,25989
< #line 2090
<   if (mdev->ov_start_sector == 0xffffffffffffffffUL && mdev->agreed_pro_version > 89) {
< #line 2092
---
> #line 2474
>   if (mdev->ov_start_sector == 0xffffffffffffffffUL && (mdev->tconn)->agreed_pro_version > 89) {
> #line 2476
24821c25991
< #line 2094
---
> #line 2478
24823c25993
< #line 2095
---
> #line 2479
24825,24829c25995,25999
< #line 2096
<     tmp___12 = drbd_bm_bits(mdev);
< #line 2096
<     mdev->ov_left = tmp___12 - (sector >> 3);
< #line 2097
---
> #line 2480
>     tmp___6 = drbd_bm_bits(mdev);
> #line 2480
>     mdev->ov_left = tmp___6 - (sector >> 3);
> #line 2481
24831c26001
< #line 2098
---
> #line 2482
24833,24836c26003,26006
< #line 2098
<     goto ldv_52493;
<     ldv_52492: 
< #line 2099
---
> #line 2482
>     goto ldv_53224;
>     ldv_53223: 
> #line 2483
24838c26008
< #line 2100
---
> #line 2484
24840c26010
< #line 2098
---
> #line 2482
24842,24843c26012,26013
<     ldv_52493: ;
< #line 2098
---
>     ldv_53224: ;
> #line 2482
24845,24846c26015,26016
< #line 2099
<       goto ldv_52492;
---
> #line 2483
>       goto ldv_53223;
24850c26020
< #line 2102
---
> #line 2486
24856,24858c26026,26028
< #line 2105
<   e->w.cb = & w_e_end_ov_req;
< #line 2106
---
> #line 2489
>   peer_req->w.cb = & w_e_end_ov_req;
> #line 2490
24860,24861c26030,26031
< #line 2107
<   goto ldv_52481;
---
> #line 2491
>   goto ldv_53215;
24863,24871c26033,26038
< #line 2110
<   tmp___13 = cmdname(cmd);
< #line 2110
<   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "unexpected command (%s) in receive_DataRequest\n",
<           tmp___13);
< #line 2112
<   fault_type = 10U;
< #line 2113
<   goto out_free_e;
---
> #line 2494
>   __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
>                        "i" (2494), "i" (12UL));
>   ldv_53227: ;
> #line 2494
>   goto ldv_53227;
24873,24880c26040,26047
<   ldv_52481: ;
< #line 2138
<   if ((unsigned int )*((unsigned char *)mdev + 2276UL) != 4U) {
< #line 2138
<     tmp___14 = drbd_rs_should_slow_down(mdev, sector);
< #line 2138
<     if (tmp___14 != 0) {
< #line 2139
---
>   ldv_53215: ;
> #line 2519
>   if ((unsigned int )*((unsigned char *)mdev + 748UL) != 4U) {
> #line 2519
>     tmp___7 = drbd_rs_should_slow_down(mdev, sector);
> #line 2519
>     if (tmp___7 != 0) {
> #line 2520
24888,24892c26055,26059
< #line 2140
<   tmp___15 = drbd_rs_begin_io(mdev, sector);
< #line 2140
<   if (tmp___15 != 0) {
< #line 2141
---
> #line 2521
>   tmp___8 = drbd_rs_begin_io(mdev, sector);
> #line 2521
>   if (tmp___8 != 0) {
> #line 2522
24898c26065
< #line 2144
---
> #line 2525
24901c26068
< #line 2147
---
> #line 2528
24903,24914c26070,26081
< #line 2148
<   spin_lock_irq(& mdev->req_lock);
< #line 2149
<   list_add_tail(& e->w.list, & mdev->read_ee);
< #line 2150
<   spin_unlock_irq(& mdev->req_lock);
< #line 2152
<   tmp___16 = drbd_submit_ee(mdev, e, 0U, (int const   )fault_type);
< #line 2152
<   if (tmp___16 == 0) {
< #line 2153
<     return (1);
---
> #line 2529
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 2530
>   list_add_tail(& peer_req->w.list, & mdev->read_ee);
> #line 2531
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 2533
>   tmp___9 = drbd_submit_peer_request(mdev, peer_req, 0U, (int const   )fault_type);
> #line 2533
>   if (tmp___9 == 0) {
> #line 2534
>     return (0);
24918c26085
< #line 2156
---
> #line 2537
24920,24925c26087,26092
< #line 2157
<   spin_lock_irq(& mdev->req_lock);
< #line 2158
<   list_del(& e->w.list);
< #line 2159
<   spin_unlock_irq(& mdev->req_lock);
---
> #line 2538
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 2539
>   list_del(& peer_req->w.list);
> #line 2540
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
24927c26094
< #line 2163
---
> #line 2544
24929,24932c26096,26099
< #line 2164
<   drbd_free_some_ee(mdev, e, 0);
< #line 2165
<   return (0);
---
> #line 2545
>   __drbd_free_peer_req(mdev, peer_req, 0);
> #line 2546
>   return (-5);
24935c26102
< #line 2168 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 2549 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
24942a26110,26112
>   enum drbd_after_sb_p after_sb_0p ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
24944a26115,26116
>   int tmp___1 ;
>   int tmp___2 ;
24947c26119
< #line 2170
---
> #line 2551
24949c26121
< #line 2173
---
> #line 2555
24951c26123
< #line 2174
---
> #line 2556
24953c26125
< #line 2176
---
> #line 2558
24955c26127
< #line 2177
---
> #line 2559
24957,24962c26129,26162
< #line 2179
<   switch ((mdev->net_conf)->after_sb_0p) {
<   case 7: ;
<   case 8: ;
<   case 9: 
< #line 2183
---
> #line 2561
>   rcu_read_lock();
> #line 2562
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 2562
>   tmp = debug_lockdep_rcu_enabled();
> #line 2562
>   if (tmp != 0 && ! __warned) {
> #line 2562
>     tmp___0 = rcu_read_lock_held();
> #line 2562
>     if (tmp___0 == 0 && 1) {
> #line 2562
>       __warned = 1;
> #line 2562
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              2562, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2562
>   after_sb_0p = (enum drbd_after_sb_p )_________p1->after_sb_0p;
> #line 2563
>   rcu_read_unlock();
> #line 2564
>   switch ((unsigned int )after_sb_0p) {
>   case 7U: ;
>   case 8U: ;
>   case 9U: ;
>   case 10U: 
> #line 2569
24964,24970c26164,26170
< #line 2184
<   goto ldv_52507;
<   case 0: ;
< #line 2186
<   goto ldv_52507;
<   case 1: ;
< #line 2188
---
> #line 2570
>   goto ldv_53244;
>   case 0U: ;
> #line 2572
>   goto ldv_53244;
>   case 1U: ;
> #line 2574
24972c26172
< #line 2189
---
> #line 2575
24974,24975c26174,26175
< #line 2190
<     goto ldv_52507;
---
> #line 2576
>     goto ldv_53244;
24979c26179
< #line 2192
---
> #line 2578
24981c26181
< #line 2193
---
> #line 2579
24983,24984c26183,26184
< #line 2194
<     goto ldv_52507;
---
> #line 2580
>     goto ldv_53244;
24988,24989c26188,26189
<   case 2: ;
< #line 2198
---
>   case 2U: ;
> #line 2584
24991c26191
< #line 2199
---
> #line 2585
24993,24994c26193,26194
< #line 2200
<     goto ldv_52507;
---
> #line 2586
>     goto ldv_53244;
24998c26198
< #line 2202
---
> #line 2588
25000c26200
< #line 2203
---
> #line 2589
25002,25003c26202,26203
< #line 2204
<     goto ldv_52507;
---
> #line 2590
>     goto ldv_53244;
25007c26207
< #line 2207
---
> #line 2593
25009,25010c26209,26210
<   case 3: ;
< #line 2210
---
>   case 3U: ;
> #line 2596
25012,25017c26212,26217
< #line 2211
<     tmp = drbd_test_flag(mdev, DISCARD_CONCURRENT);
< #line 2211
<     rv = tmp != 0 ? -1 : 1;
< #line 2213
<     goto ldv_52507;
---
> #line 2597
>     tmp___1 = constant_test_bit(1U, (unsigned long const volatile   *)(& (mdev->tconn)->flags));
> #line 2597
>     rv = tmp___1 != 0 ? -1 : 1;
> #line 2599
>     goto ldv_53244;
25019c26219
< #line 2215
---
> #line 2601
25021c26221
< #line 2215
---
> #line 2601
25023,25024c26223,26224
< #line 2215
<       goto ldv_52507;
---
> #line 2601
>       goto ldv_53244;
25028c26228
< #line 2216
---
> #line 2602
25030c26230
< #line 2216
---
> #line 2602
25032,25033c26232,26233
< #line 2216
<       goto ldv_52507;
---
> #line 2602
>       goto ldv_53244;
25038,25041c26238,26241
< #line 2218
<   if ((mdev->net_conf)->after_sb_0p == 3) {
< #line 2219
<     goto ldv_52507;
---
> #line 2604
>   if ((unsigned int )after_sb_0p == 3U) {
> #line 2605
>     goto ldv_53244;
25045,25046c26245,26246
<   case 4: ;
< #line 2221
---
>   case 4U: ;
> #line 2607
25048c26248
< #line 2222
---
> #line 2608
25051c26251
< #line 2223
---
> #line 2609
25053c26253
< #line 2224
---
> #line 2610
25056,25059c26256,26259
< #line 2227
<     tmp___0 = drbd_test_flag(mdev, DISCARD_CONCURRENT);
< #line 2227
<     rv = tmp___0 != 0 ? -1 : 1;
---
> #line 2613
>     tmp___2 = constant_test_bit(1U, (unsigned long const volatile   *)(& (mdev->tconn)->flags));
> #line 2613
>     rv = tmp___2 != 0 ? -1 : 1;
25061,25064c26261,26264
< #line 2229
<   goto ldv_52507;
<   case 5: 
< #line 2231
---
> #line 2615
>   goto ldv_53244;
>   case 5U: 
> #line 2617
25066,25069c26266,26269
< #line 2232
<   goto ldv_52507;
<   case 6: 
< #line 2234
---
> #line 2618
>   goto ldv_53244;
>   case 6U: 
> #line 2620
25072,25073c26272,26273
<   ldv_52507: ;
< #line 2237
---
>   ldv_53244: ;
> #line 2623
25077c26277
< #line 2240 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 2626 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
25081a26282,26286
>   enum drbd_after_sb_p after_sb_1p ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
25087c26292
< #line 2242
---
> #line 2628
25089,25096c26294,26329
< #line 2244
<   switch ((mdev->net_conf)->after_sb_1p) {
<   case 1: ;
<   case 2: ;
<   case 4: ;
<   case 5: ;
<   case 6: 
< #line 2250
---
> #line 2631
>   rcu_read_lock();
> #line 2632
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 2632
>   tmp = debug_lockdep_rcu_enabled();
> #line 2632
>   if (tmp != 0 && ! __warned) {
> #line 2632
>     tmp___0 = rcu_read_lock_held();
> #line 2632
>     if (tmp___0 == 0 && 1) {
> #line 2632
>       __warned = 1;
> #line 2632
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              2632, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2632
>   after_sb_1p = (enum drbd_after_sb_p )_________p1->after_sb_1p;
> #line 2633
>   rcu_read_unlock();
> #line 2634
>   switch ((unsigned int )after_sb_1p) {
>   case 1U: ;
>   case 2U: ;
>   case 4U: ;
>   case 5U: ;
>   case 6U: ;
>   case 3U: 
> #line 2641
25098,25104c26331,26337
< #line 2251
<   goto ldv_52525;
<   case 0: ;
< #line 2253
<   goto ldv_52525;
<   case 7: 
< #line 2255
---
> #line 2642
>   goto ldv_53267;
>   case 0U: ;
> #line 2644
>   goto ldv_53267;
>   case 7U: 
> #line 2646
25106,25108c26339,26341
< #line 2256
<   if (hg == -1 && (unsigned int )*((unsigned char *)mdev + 2276UL) == 2U) {
< #line 2257
---
> #line 2647
>   if (hg == -1 && (unsigned int )*((unsigned char *)mdev + 748UL) == 2U) {
> #line 2648
25113,25115c26346,26348
< #line 2258
<   if (hg == 1 && (unsigned int )*((unsigned char *)mdev + 2276UL) == 1U) {
< #line 2259
---
> #line 2649
>   if (hg == 1 && (unsigned int )*((unsigned char *)mdev + 748UL) == 1U) {
> #line 2650
25120,25123c26353,26356
< #line 2260
<   goto ldv_52525;
<   case 10: 
< #line 2262
---
> #line 2651
>   goto ldv_53267;
>   case 10U: 
> #line 2653
25125,25131c26358,26364
< #line 2263
<   goto ldv_52525;
<   case 8: ;
< #line 2265
<   return ((unsigned int )*((unsigned char *)mdev + 2276UL) == 1U ? 1 : -1);
<   case 9: 
< #line 2267
---
> #line 2654
>   goto ldv_53267;
>   case 8U: ;
> #line 2656
>   return ((unsigned int )*((unsigned char *)mdev + 748UL) == 1U ? 1 : -1);
>   case 9U: 
> #line 2658
25133,25135c26366,26368
< #line 2268
<   if (hg == -1 && (unsigned int )*((unsigned char *)mdev + 2276UL) == 1U) {
< #line 2271
---
> #line 2659
>   if (hg == -1 && (unsigned int )*((unsigned char *)mdev + 748UL) == 1U) {
> #line 2662
25137c26370
< #line 2275
---
> #line 2666
25139,25141c26372,26374
< #line 2275
<     val.ldv_40583.role = 2U;
< #line 2275
---
> #line 2666
>     val.ldv_40604.role = 2U;
> #line 2666
25143,25145c26376,26378
< #line 2275
<     mask.ldv_40583.role = 3U;
< #line 2275
---
> #line 2666
>     mask.ldv_40604.role = 3U;
> #line 2666
25147c26380
< #line 2276
---
> #line 2667
25149c26382
< #line 2277
---
> #line 2668
25152c26385
< #line 2279
---
> #line 2670
25154c26387
< #line 2280
---
> #line 2671
25158c26391
< #line 2283
---
> #line 2674
25162,25163c26395,26396
<   ldv_52525: ;
< #line 2286
---
>   ldv_53267: ;
> #line 2677
25167c26400
< #line 2289 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 2680 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
25171a26405,26409
>   enum drbd_after_sb_p after_sb_2p ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
25177c26415
< #line 2291
---
> #line 2682
25179,25188c26417,26454
< #line 2293
<   switch ((mdev->net_conf)->after_sb_2p) {
<   case 1: ;
<   case 2: ;
<   case 4: ;
<   case 5: ;
<   case 6: ;
<   case 7: ;
<   case 8: 
< #line 2301
---
> #line 2685
>   rcu_read_lock();
> #line 2686
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 2686
>   tmp = debug_lockdep_rcu_enabled();
> #line 2686
>   if (tmp != 0 && ! __warned) {
> #line 2686
>     tmp___0 = rcu_read_lock_held();
> #line 2686
>     if (tmp___0 == 0 && 1) {
> #line 2686
>       __warned = 1;
> #line 2686
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              2686, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2686
>   after_sb_2p = (enum drbd_after_sb_p )_________p1->after_sb_2p;
> #line 2687
>   rcu_read_unlock();
> #line 2688
>   switch ((unsigned int )after_sb_2p) {
>   case 1U: ;
>   case 2U: ;
>   case 4U: ;
>   case 5U: ;
>   case 6U: ;
>   case 7U: ;
>   case 8U: ;
>   case 3U: 
> #line 2697
25190,25193c26456,26459
< #line 2302
<   goto ldv_52548;
<   case 10: 
< #line 2304
---
> #line 2698
>   goto ldv_53295;
>   case 10U: 
> #line 2700
25195,25201c26461,26467
< #line 2305
<   goto ldv_52548;
<   case 0: ;
< #line 2307
<   goto ldv_52548;
<   case 9: 
< #line 2309
---
> #line 2701
>   goto ldv_53295;
>   case 0U: ;
> #line 2703
>   goto ldv_53295;
>   case 9U: 
> #line 2705
25203c26469
< #line 2310
---
> #line 2706
25205c26471
< #line 2316
---
> #line 2712
25207,25209c26473,26475
< #line 2316
<     val.ldv_40583.role = 2U;
< #line 2316
---
> #line 2712
>     val.ldv_40604.role = 2U;
> #line 2712
25211,25213c26477,26479
< #line 2316
<     mask.ldv_40583.role = 3U;
< #line 2316
---
> #line 2712
>     mask.ldv_40604.role = 3U;
> #line 2712
25215c26481
< #line 2317
---
> #line 2713
25217c26483
< #line 2318
---
> #line 2714
25220c26486
< #line 2320
---
> #line 2716
25222c26488
< #line 2321
---
> #line 2717
25226c26492
< #line 2324
---
> #line 2720
25230,25231c26496,26497
<   ldv_52548: ;
< #line 2327
---
>   ldv_53295: ;
> #line 2723
25235c26501
< #line 2330 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 2726 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
25242c26508
< #line 2333
---
> #line 2729
25244c26510
< #line 2334
---
> #line 2730
25247c26513
< #line 2335
---
> #line 2731
25252c26518
< #line 2337
---
> #line 2733
25255c26521
< #line 2338
---
> #line 2734
25259c26525
< #line 2359 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 2755 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
25275c26541
< #line 2364
---
> #line 2760
25277c26543
< #line 2365
---
> #line 2761
25279c26545
< #line 2367
---
> #line 2763
25281c26547
< #line 2368
---
> #line 2764
25283c26549
< #line 2369
---
> #line 2765
25288c26554
< #line 2371
---
> #line 2767
25290c26556
< #line 2372
---
> #line 2768
25292c26558
< #line 2374
---
> #line 2770
25297c26563
< #line 2376
---
> #line 2772
25299c26565
< #line 2377
---
> #line 2773
25301c26567
< #line 2379
---
> #line 2775
25306c26572
< #line 2381
---
> #line 2777
25308c26574
< #line 2384
---
> #line 2780
25310,25312c26576,26578
< #line 2386
<       if (mdev->agreed_pro_version <= 90) {
< #line 2387
---
> #line 2782
>       if ((mdev->tconn)->agreed_pro_version <= 90) {
> #line 2783
25317c26583
< #line 2389
---
> #line 2785
25319c26585
< #line 2391
---
> #line 2787
25321c26587
< #line 2392
---
> #line 2788
25323c26589
< #line 2393
---
> #line 2789
25325c26591
< #line 2394
---
> #line 2790
25327,25329c26593,26595
< #line 2396
<         if ((int )mdev->state.ldv_40583.disk > 2) {
< #line 2396
---
> #line 2792
>         if ((int )mdev->state.ldv_50103.disk > 2) {
> #line 2792
25331c26597
< #line 2396
---
> #line 2792
25334c26600
< #line 2396
---
> #line 2792
25337c26603
< #line 2396
---
> #line 2792
25340c26606
< #line 2398
---
> #line 2794
25343c26609
< #line 2400
---
> #line 2796
25345c26611
< #line 2401
---
> #line 2797
25348c26614
< #line 2404
---
> #line 2800
25353c26619
< #line 2407
---
> #line 2803
25355,25357c26621,26623
< #line 2409
<       if (mdev->agreed_pro_version <= 90) {
< #line 2410
---
> #line 2805
>       if ((mdev->tconn)->agreed_pro_version <= 90) {
> #line 2806
25362c26628
< #line 2412
---
> #line 2808
25364c26630
< #line 2414
---
> #line 2810
25366c26632
< #line 2416
---
> #line 2812
25368c26634
< #line 2417
---
> #line 2813
25370c26636
< #line 2418
---
> #line 2814
25372c26638
< #line 2420
---
> #line 2816
25375c26641
< #line 2421
---
> #line 2817
25378c26644
< #line 2423
---
> #line 2819
25380c26646
< #line 2424
---
> #line 2820
25383c26649
< #line 2427
---
> #line 2823
25388,25390c26654,26656
< #line 2431
<     tmp___1 = drbd_test_flag(mdev, CRASHED_PRIMARY);
< #line 2431
---
> #line 2827
>     tmp___1 = constant_test_bit(5U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2827
25392c26658
< #line 2435
---
> #line 2831
25394c26660
< #line 2437
---
> #line 2833
25397c26663
< #line 2438
---
> #line 2834
25400c26666
< #line 2439
---
> #line 2835
25403c26669
< #line 2440
---
> #line 2836
25406,25408c26672,26674
< #line 2442
<     dc = drbd_test_flag(mdev, DISCARD_CONCURRENT);
< #line 2443
---
> #line 2838
>     dc = constant_test_bit(1U, (unsigned long const volatile   *)(& (mdev->tconn)->flags));
> #line 2839
25414c26680
< #line 2447
---
> #line 2843
25416c26682
< #line 2448
---
> #line 2844
25418c26684
< #line 2449
---
> #line 2845
25420c26686
< #line 2450
---
> #line 2846
25425c26691
< #line 2452
---
> #line 2848
25427c26693
< #line 2453
---
> #line 2849
25429c26695
< #line 2454
---
> #line 2850
25431,25435c26697,26701
< #line 2455
<     if (mdev->agreed_pro_version <= 95 ? (((mdev->ldev)->md.uuid[2] ^ *(mdev->p_uuid + 3UL)) & 0xfffffffffffffffeULL) == 0ULL : peer + 281474976710656ULL == (*(mdev->p_uuid + 1UL) & 0xfffffffffffffffeULL)) {
< #line 2462
<       if (mdev->agreed_pro_version <= 90) {
< #line 2463
---
> #line 2851
>     if ((mdev->tconn)->agreed_pro_version <= 95 ? (((mdev->ldev)->md.uuid[2] ^ *(mdev->p_uuid + 3UL)) & 0xfffffffffffffffeULL) == 0ULL : peer + 281474976710656ULL == (*(mdev->p_uuid + 1UL) & 0xfffffffffffffffeULL)) {
> #line 2858
>       if ((mdev->tconn)->agreed_pro_version <= 90) {
> #line 2859
25440c26706
< #line 2465
---
> #line 2861
25442c26708
< #line 2466
---
> #line 2862
25444c26710
< #line 2468
---
> #line 2864
25446c26712
< #line 2469
---
> #line 2865
25448c26714
< #line 2471
---
> #line 2867
25456c26722
< #line 2475
---
> #line 2871
25458c26724
< #line 2476
---
> #line 2872
25460c26726
< #line 2477
---
> #line 2873
25462,25465c26728,26731
< #line 2477
<   goto ldv_52579;
<   ldv_52578: 
< #line 2478
---
> #line 2873
>   goto ldv_53326;
>   ldv_53325: 
> #line 2874
25467c26733
< #line 2479
---
> #line 2875
25469c26735
< #line 2480
---
> #line 2876
25474c26740
< #line 2477
---
> #line 2873
25476,25477c26742,26743
<   ldv_52579: ;
< #line 2477
---
>   ldv_53326: ;
> #line 2873
25479,25480c26745,26746
< #line 2478
<     goto ldv_52578;
---
> #line 2874
>     goto ldv_53325;
25484c26750
< #line 2483
---
> #line 2879
25486c26752
< #line 2484
---
> #line 2880
25488c26754
< #line 2485
---
> #line 2881
25490c26756
< #line 2486
---
> #line 2882
25492c26758
< #line 2487
---
> #line 2883
25497c26763
< #line 2489
---
> #line 2885
25499c26765
< #line 2490
---
> #line 2886
25501c26767
< #line 2491
---
> #line 2887
25503,25507c26769,26773
< #line 2492
<     if (mdev->agreed_pro_version <= 95 ? (((mdev->ldev)->md.uuid[3] ^ *(mdev->p_uuid + 2UL)) & 0xfffffffffffffffeULL) == 0ULL : self + 281474976710656ULL == ((mdev->ldev)->md.uuid[1] & 0xfffffffffffffffeULL)) {
< #line 2499
<       if (mdev->agreed_pro_version <= 90) {
< #line 2500
---
> #line 2888
>     if ((mdev->tconn)->agreed_pro_version <= 95 ? (((mdev->ldev)->md.uuid[3] ^ *(mdev->p_uuid + 2UL)) & 0xfffffffffffffffeULL) == 0ULL : self + 281474976710656ULL == ((mdev->ldev)->md.uuid[1] & 0xfffffffffffffffeULL)) {
> #line 2895
>       if ((mdev->tconn)->agreed_pro_version <= 90) {
> #line 2896
25512c26778
< #line 2502
---
> #line 2898
25514c26780
< #line 2503
---
> #line 2899
25516c26782
< #line 2505
---
> #line 2901
25518,25520c26784,26786
< #line 2506
<       if ((int )mdev->state.ldv_40583.disk > 2) {
< #line 2506
---
> #line 2902
>       if ((int )mdev->state.ldv_50103.disk > 2) {
> #line 2902
25522c26788
< #line 2506
---
> #line 2902
25525c26791
< #line 2506
---
> #line 2902
25528c26794
< #line 2506
---
> #line 2902
25531c26797
< #line 2509
---
> #line 2905
25539c26805
< #line 2514
---
> #line 2910
25541c26807
< #line 2515
---
> #line 2911
25543c26809
< #line 2516
---
> #line 2912
25545,25548c26811,26814
< #line 2516
<   goto ldv_52582;
<   ldv_52581: 
< #line 2517
---
> #line 2912
>   goto ldv_53329;
>   ldv_53328: 
> #line 2913
25550c26816
< #line 2518
---
> #line 2914
25552c26818
< #line 2519
---
> #line 2915
25557c26823
< #line 2516
---
> #line 2912
25559,25560c26825,26826
<   ldv_52582: ;
< #line 2516
---
>   ldv_53329: ;
> #line 2912
25562,25563c26828,26829
< #line 2517
<     goto ldv_52581;
---
> #line 2913
>     goto ldv_53328;
25567c26833
< #line 2522
---
> #line 2918
25569c26835
< #line 2523
---
> #line 2919
25571c26837
< #line 2524
---
> #line 2920
25573c26839
< #line 2525
---
> #line 2921
25575c26841
< #line 2526
---
> #line 2922
25580c26846
< #line 2528
---
> #line 2924
25582c26848
< #line 2529
---
> #line 2925
25584,25587c26850,26853
< #line 2529
<   goto ldv_52588;
<   ldv_52587: 
< #line 2530
---
> #line 2925
>   goto ldv_53335;
>   ldv_53334: 
> #line 2926
25589c26855
< #line 2531
---
> #line 2927
25591,25594c26857,26860
< #line 2531
<   goto ldv_52585;
<   ldv_52584: 
< #line 2532
---
> #line 2927
>   goto ldv_53332;
>   ldv_53331: 
> #line 2928
25596c26862
< #line 2533
---
> #line 2929
25598c26864
< #line 2534
---
> #line 2930
25603c26869
< #line 2531
---
> #line 2927
25605,25606c26871,26872
<   ldv_52585: ;
< #line 2531
---
>   ldv_53332: ;
> #line 2927
25608,25609c26874,26875
< #line 2532
<     goto ldv_52584;
---
> #line 2928
>     goto ldv_53331;
25613c26879
< #line 2529
---
> #line 2925
25615,25616c26881,26882
<   ldv_52588: ;
< #line 2529
---
>   ldv_53335: ;
> #line 2925
25618,25619c26884,26885
< #line 2530
<     goto ldv_52587;
---
> #line 2926
>     goto ldv_53334;
25624c26890
< #line 2538
---
> #line 2934
25628c26894
< #line 2544 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 2940 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
25632,25633d26897
<   int hg ;
<   int rule_nr ;
25635a26900,26904
>   struct net_conf *nc ;
>   int hg ;
>   int rule_nr ;
>   int rr_conflict ;
>   int tentative ;
25641a26911,26914
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___0 ;
>   int tmp___1 ;
25645a26919,26920
>   int tmp___2 ;
>   int tmp___3 ;
25650,25652c26925,26927
<   char const   *tmp___0 ;
<   int tmp___1 ;
<   int tmp___2 ;
---
>   char const   *tmp___4 ;
>   int tmp___5 ;
>   int tmp___6 ;
25655,25656c26930,26931
<   unsigned long tmp___3 ;
<   unsigned long tmp___4 ;
---
>   unsigned long tmp___7 ;
>   unsigned long tmp___8 ;
25659c26934
< #line 2548
---
> #line 2943
25661,25663c26936,26938
< #line 2551
<   mydisk = (enum drbd_disk_state )mdev->state.ldv_40583.disk;
< #line 2552
---
> #line 2948
>   mydisk = (enum drbd_disk_state )mdev->state.ldv_50103.disk;
> #line 2949
25665,25666c26940,26941
< #line 2553
<     mydisk = (enum drbd_disk_state )mdev->new_state_tmp.ldv_40583.disk;
---
> #line 2950
>     mydisk = (enum drbd_disk_state )mdev->new_state_tmp.ldv_40604.disk;
25670c26945
< #line 2555
---
> #line 2952
25672c26947
< #line 2557
---
> #line 2954
25674c26949
< #line 2558
---
> #line 2955
25677c26952
< #line 2559
---
> #line 2956
25679c26954
< #line 2562
---
> #line 2959
25681c26956
< #line 2563
---
> #line 2960
25683c26958
< #line 2565
---
> #line 2962
25686c26961
< #line 2567
---
> #line 2964
25688c26963
< #line 2568
---
> #line 2965
25690c26965
< #line 2569
---
> #line 2966
25695c26970
< #line 2571
---
> #line 2968
25697c26972
< #line 2572
---
> #line 2969
25700c26975
< #line 2573
---
> #line 2970
25705c26980
< #line 2576
---
> #line 2973
25707c26982
< #line 2578
---
> #line 2975
25709c26984
< #line 2578
---
> #line 2975
25712c26987
< #line 2578
---
> #line 2975
25714c26989
< #line 2578
---
> #line 2975
25716c26991
< #line 2578
---
> #line 2975
25718c26993
< #line 2578
---
> #line 2975
25721c26996
< #line 2578
---
> #line 2975
25725c27000
< #line 2578
---
> #line 2975
25727c27002
< #line 2579
---
> #line 2976
25729c27004
< #line 2580
---
> #line 2977
25731c27006
< #line 2581
---
> #line 2978
25736c27011
< #line 2582
---
> #line 2979
25742c27017
< #line 2586
---
> #line 2983
25744c27019
< #line 2586
---
> #line 2983
25746c27021
< #line 2586
---
> #line 2983
25748c27023
< #line 2587
---
> #line 2984
25753,25757c27028,27057
< #line 2589
<   if (hg == 100 || (hg == -100 && (unsigned int )*((unsigned char *)mdev->net_conf + 540UL) != 0U)) {
< #line 2590
<     pcount = ((unsigned int )*((unsigned char *)mdev + 2276UL) == 1U) + ((unsigned int )peer_role == 1U);
< #line 2592
---
> #line 2986
>   rcu_read_lock();
> #line 2987
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 2987
>   tmp___0 = debug_lockdep_rcu_enabled();
> #line 2987
>   if (tmp___0 != 0 && ! __warned) {
> #line 2987
>     tmp___1 = rcu_read_lock_held();
> #line 2987
>     if (tmp___1 == 0 && 1) {
> #line 2987
>       __warned = 1;
> #line 2987
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              2987, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2987
>   nc = _________p1;
> #line 2989
>   if (hg == 100 || (hg == -100 && (int )((signed char )nc->always_asbp) != 0)) {
> #line 2990
>     pcount = ((unsigned int )*((unsigned char *)mdev + 748UL) == 1U) + ((unsigned int )peer_role == 1U);
> #line 2992
25759c27059
< #line 2594
---
> #line 2994
25762c27062
< #line 2596
---
> #line 2996
25764,25765c27064,27065
< #line 2597
<     goto ldv_52611;
---
> #line 2997
>     goto ldv_53364;
25767c27067
< #line 2599
---
> #line 2999
25769,25770c27069,27070
< #line 2600
<     goto ldv_52611;
---
> #line 3000
>     goto ldv_53364;
25772c27072
< #line 2602
---
> #line 3002
25774,25775c27074,27075
< #line 2603
<     goto ldv_52611;
---
> #line 3003
>     goto ldv_53364;
25777,25778c27077,27078
<     ldv_52611: 
< #line 2605
---
>     ldv_53364: 
> #line 3005
25780c27080
< #line 2605
---
> #line 3005
25782c27082
< #line 2605
---
> #line 3005
25784c27084
< #line 2606
---
> #line 3006
25787c27087
< #line 2609
---
> #line 3009
25789c27089
< #line 2610
---
> #line 3010
25791c27091
< #line 2612
---
> #line 3012
25802c27102
< #line 2617
---
> #line 3017
25804,25806c27104,27108
< #line 2618
<     if ((unsigned int )*((unsigned char *)mdev->net_conf + 540UL) != 0U && (*(mdev->p_uuid + 5UL) & 1ULL) == 0ULL) {
< #line 2619
---
> #line 3018
>     tmp___2 = constant_test_bit(21U, (unsigned long const volatile   *)(& mdev->flags));
> #line 3018
>     if (tmp___2 != 0 && (*(mdev->p_uuid + 5UL) & 1ULL) == 0ULL) {
> #line 3019
25811,25813c27113,27117
< #line 2620
<     if ((unsigned int )*((unsigned char *)mdev->net_conf + 540UL) == 0U && (int )*(mdev->p_uuid + 5UL) & 1) {
< #line 2621
---
> #line 3020
>     tmp___3 = constant_test_bit(21U, (unsigned long const volatile   *)(& mdev->flags));
> #line 3020
>     if (tmp___3 == 0 && (int )*(mdev->p_uuid + 5UL) & 1) {
> #line 3021
25818c27122
< #line 2623
---
> #line 3023
25820c27124
< #line 2623
---
> #line 3023
25822c27126
< #line 2623
---
> #line 3023
25824c27128
< #line 2624
---
> #line 3024
25833c27137,27143
< #line 2629
---
> #line 3028
>   rr_conflict = (int )nc->rr_conflict;
> #line 3029
>   tentative = (int )nc->tentative;
> #line 3030
>   rcu_read_unlock();
> #line 3032
25835c27145
< #line 2634
---
> #line 3037
25837c27147
< #line 2635
---
> #line 3038
25839c27149
< #line 2636
---
> #line 3039
25844c27154
< #line 2639
---
> #line 3042
25846c27156
< #line 2640
---
> #line 3043
25848c27158
< #line 2641
---
> #line 3044
25853,25856c27163,27166
< #line 2644
<   if ((hg < 0 && (unsigned int )*((unsigned char *)mdev + 2276UL) == 1U) && (int )mdev->state.ldv_40583.disk > 6) {
< #line 2646
<     switch ((mdev->net_conf)->rr_conflict) {
---
> #line 3047
>   if ((hg < 0 && (unsigned int )*((unsigned char *)mdev + 748UL) == 1U) && (int )mdev->state.ldv_50103.disk > 6) {
> #line 3049
>     switch (rr_conflict) {
25858c27168
< #line 2648
---
> #line 3051
25861c27171
< #line 2651
---
> #line 3054
25863c27173
< #line 2652
---
> #line 3055
25866c27176
< #line 2654
---
> #line 3057
25872,25874c27182,27184
< #line 2659
<   if ((unsigned int )*((unsigned char *)mdev->net_conf + 540UL) != 0U) {
< #line 2659
---
> #line 3062
>   if (tentative != 0) {
> #line 3062
25877,25880c27187,27190
< #line 2659
<     tmp___1 = drbd_test_flag(mdev, CONN_DRY_RUN);
< #line 2659
<     if (tmp___1 != 0) {
---
> #line 3062
>     tmp___5 = constant_test_bit(8U, (unsigned long const volatile   *)(& (mdev->tconn)->flags));
> #line 3062
>     if (tmp___5 != 0) {
25882c27192
< #line 2660
---
> #line 3063
25884c27194
< #line 2661
---
> #line 3064
25887c27197
< #line 2663
---
> #line 3066
25889c27199
< #line 2663
---
> #line 3066
25891,25893c27201,27203
< #line 2663
<         tmp___0 = drbd_conn_str(hg > 0 ? C_SYNC_SOURCE : C_SYNC_TARGET);
< #line 2663
---
> #line 3066
>         tmp___4 = drbd_conn_str(hg > 0 ? C_SYNC_SOURCE : C_SYNC_TARGET);
> #line 3066
25895c27205
<                   tmp___0, ret___3 > 1L ? (char *)"full" : (char *)"bit-map based");
---
>                   tmp___4, ret___3 > 1L ? (char *)"full" : (char *)"bit-map based");
25897c27207
< #line 2666
---
> #line 3069
25903c27213
< #line 2669
---
> #line 3072
25905c27215
< #line 2669
---
> #line 3072
25907c27217
< #line 2669
---
> #line 3072
25909c27219
< #line 2670
---
> #line 3073
25911,25912c27221,27222
< #line 2671
<     tmp___2 = drbd_bitmap_io(mdev, & drbd_bmio_set_n_write, (char *)"set_n_write from sync_handshake",
---
> #line 3074
>     tmp___6 = drbd_bitmap_io(mdev, & drbd_bmio_set_n_write, (char *)"set_n_write from sync_handshake",
25914,25916c27224,27226
< #line 2671
<     if (tmp___2 != 0) {
< #line 2673
---
> #line 3074
>     if (tmp___6 != 0) {
> #line 3076
25924c27234
< #line 2676
---
> #line 3079
25926c27236
< #line 2677
---
> #line 3080
25929c27239
< #line 2678
---
> #line 3081
25931c27241
< #line 2679
---
> #line 3082
25934c27244
< #line 2681
---
> #line 3084
25936,25942c27246,27252
< #line 2682
<     tmp___4 = drbd_bm_total_weight(mdev);
< #line 2682
<     if (tmp___4 != 0UL) {
< #line 2683
<       tmp___3 = drbd_bm_total_weight(mdev);
< #line 2683
---
> #line 3085
>     tmp___8 = drbd_bm_total_weight(mdev);
> #line 3085
>     if (tmp___8 != 0UL) {
> #line 3086
>       tmp___7 = drbd_bm_total_weight(mdev);
> #line 3086
25944c27254
<                 tmp___3);
---
>                 tmp___7);
25949c27259
< #line 2688
---
> #line 3091
25953,25954c27263,27264
< #line 2692 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int cmp_after_sb(enum drbd_after_sb_p peer , enum drbd_after_sb_p self ) 
---
> #line 3094 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static enum drbd_after_sb_p convert_after_sb(enum drbd_after_sb_p peer ) 
25959,25969c27269,27272
< #line 2695
<   if (((unsigned int )peer == 6U && (unsigned int )self == 5U) || ((unsigned int )self == 6U && (unsigned int )peer == 5U)) {
< #line 2697
<     return (0);
<   } else {
< 
<   }
< #line 2700
<   if ((((unsigned int )peer == 6U || (unsigned int )peer == 5U) || (unsigned int )self == 6U) || (unsigned int )self == 5U) {
< #line 2702
<     return (1);
---
> #line 3097
>   if ((unsigned int )peer == 6U) {
> #line 3098
>     return (ASB_DISCARD_LOCAL);
25973,25976c27276,27279
< #line 2705
<   if ((unsigned int )peer == (unsigned int )self) {
< #line 2706
<     return (0);
---
> #line 3101
>   if ((unsigned int )peer == 5U) {
> #line 3102
>     return (ASB_DISCARD_REMOTE);
25980,25981c27283,27284
< #line 2709
<   return (1);
---
> #line 3105
>   return (peer);
25984,25985c27287,27288
< #line 2712 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_protocol(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 3108 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_protocol(struct drbd_tconn *tconn , struct packet_info *pi ) 
25987a27291,27293
>   enum drbd_after_sb_p p_after_sb_0p ;
>   enum drbd_after_sb_p p_after_sb_1p ;
>   enum drbd_after_sb_p p_after_sb_2p ;
25989,25992c27295
<   int p_after_sb_0p ;
<   int p_after_sb_1p ;
<   int p_after_sb_2p ;
<   int p_want_lose ;
---
>   int p_discard_my_data ;
25995c27298,27301
<   char p_integrity_alg[64U] ;
---
>   struct net_conf *nc ;
>   struct net_conf *old_net_conf ;
>   struct net_conf *new_net_conf ;
>   char integrity_alg[64U] ;
25996a27303,27305
>   struct crypto_hash *peer_integrity_tfm ;
>   void *int_dig_in ;
>   void *int_dig_vv ;
26002a27312,27314
>   int err ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
26005,26008c27317,27327
<   int tmp___8 ;
<   unsigned char *my_alg ;
<   int tmp___9 ;
<   int tmp___10 ;
---
>   enum drbd_after_sb_p tmp___8 ;
>   enum drbd_after_sb_p tmp___9 ;
>   enum drbd_after_sb_p tmp___10 ;
>   int tmp___11 ;
>   int hash_size ;
>   unsigned int tmp___12 ;
>   void *tmp___13 ;
>   enum drbd_after_sb_p tmp___14 ;
>   enum drbd_after_sb_p tmp___15 ;
>   enum drbd_after_sb_p tmp___16 ;
>   int tmp___17 ;
26013,26017c27332,27338
< #line 2714
<   p = & mdev->data.rbuf.protocol;
< #line 2717
<   p_integrity_alg[0] = '\000';
< #line 2717
---
> #line 3110
>   p = (struct p_protocol *)pi->data;
> #line 3113
>   new_net_conf = 0;
> #line 3114
>   integrity_alg[0] = '\000';
> #line 3114
26019c27340
< #line 2717
---
> #line 3114
26021c27342
< #line 2717
---
> #line 3114
26023c27344
< #line 2717
---
> #line 3114
26028,26030c27349,27351
< #line 2717
<     p_integrity_alg[tmp] = (char)0;
< #line 2717
---
> #line 3114
>     integrity_alg[tmp] = (char)0;
> #line 3114
26033c27354,27360
< #line 2719
---
> #line 3115
>   peer_integrity_tfm = 0;
> #line 3116
>   int_dig_in = 0;
> #line 3116
>   int_dig_vv = 0;
> #line 3118
26035c27362
< #line 2719
---
> #line 3118
26037c27364
< #line 2720
---
> #line 3119
26039,26041c27366,27368
< #line 2720
<   p_after_sb_0p = (int )tmp___1;
< #line 2721
---
> #line 3119
>   p_after_sb_0p = (enum drbd_after_sb_p )tmp___1;
> #line 3120
26043,26045c27370,27372
< #line 2721
<   p_after_sb_1p = (int )tmp___2;
< #line 2722
---
> #line 3120
>   p_after_sb_1p = (enum drbd_after_sb_p )tmp___2;
> #line 3121
26047,26049c27374,27376
< #line 2722
<   p_after_sb_2p = (int )tmp___3;
< #line 2723
---
> #line 3121
>   p_after_sb_2p = (enum drbd_after_sb_p )tmp___3;
> #line 3122
26051c27378
< #line 2723
---
> #line 3122
26053c27380
< #line 2724
---
> #line 3123
26055c27382
< #line 2724
---
> #line 3123
26057,26065c27384,27392
< #line 2725
<   p_want_lose = cf & 1;
< #line 2727
<   drbd_clear_flag(mdev, CONN_DRY_RUN);
< #line 2729
<   if ((cf & 2) != 0) {
< #line 2730
<     drbd_set_flag(mdev, CONN_DRY_RUN);
<   } else {
---
> #line 3124
>   p_discard_my_data = cf & 1;
> #line 3126
>   if (tconn->agreed_pro_version > 86) {
> #line 3129
>     if (pi->size > 64U) {
> #line 3130
>       return (-5);
>     } else {
26067,26074c27394,27401
<   }
< #line 2732
<   if ((mdev->net_conf)->wire_protocol != p_proto) {
< #line 2733
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "incompatible communication protocols\n");
< #line 2734
<     goto disconnect;
<   } else {
---
>     }
> #line 3131
>     err = drbd_recv_all(tconn, (void *)(& integrity_alg), (size_t )pi->size);
> #line 3132
>     if (err != 0) {
> #line 3133
>       return (err);
>     } else {
26076,26084c27403,27405
<   }
< #line 2737
<   tmp___6 = cmp_after_sb((enum drbd_after_sb_p )p_after_sb_0p, (enum drbd_after_sb_p )(mdev->net_conf)->after_sb_0p);
< #line 2737
<   if (tmp___6 != 0) {
< #line 2738
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "incompatible after-sb-0pri settings\n");
< #line 2739
<     goto disconnect;
---
>     }
> #line 3134
>     integrity_alg[63] = 0;
26088,26096c27409,27417
< #line 2742
<   tmp___7 = cmp_after_sb((enum drbd_after_sb_p )p_after_sb_1p, (enum drbd_after_sb_p )(mdev->net_conf)->after_sb_1p);
< #line 2742
<   if (tmp___7 != 0) {
< #line 2743
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "incompatible after-sb-1pri settings\n");
< #line 2744
<     goto disconnect;
<   } else {
---
> #line 3137
>   if ((unsigned int )pi->cmd != 45U) {
> #line 3138
>     clear_bit(8, (unsigned long volatile   *)(& tconn->flags));
> #line 3140
>     if ((cf & 2) != 0) {
> #line 3141
>       set_bit(8U, (unsigned long volatile   *)(& tconn->flags));
>     } else {
26098,26107c27419,27437
<   }
< #line 2747
<   tmp___8 = cmp_after_sb((enum drbd_after_sb_p )p_after_sb_2p, (enum drbd_after_sb_p )(mdev->net_conf)->after_sb_2p);
< #line 2747
<   if (tmp___8 != 0) {
< #line 2748
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "incompatible after-sb-2pri settings\n");
< #line 2749
<     goto disconnect;
<   } else {
---
>     }
> #line 3143
>     rcu_read_lock();
> #line 3144
>     _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 3144
>     tmp___6 = debug_lockdep_rcu_enabled();
> #line 3144
>     if (tmp___6 != 0 && ! __warned) {
> #line 3144
>       tmp___7 = rcu_read_lock_held();
> #line 3144
>       if (tmp___7 == 0 && 1) {
> #line 3144
>         __warned = 1;
> #line 3144
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                                3144, "suspicious rcu_dereference_check() usage");
>       } else {
26109,26116c27439,27440
<   }
< #line 2752
<   if (p_want_lose != 0 && (unsigned int )*((unsigned char *)mdev->net_conf + 540UL) != 0U) {
< #line 2753
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "both sides have the \'want_lose\' flag set\n");
< #line 2754
<     goto disconnect;
<   } else {
---
>       }
>     } else {
26118,26124c27442,27517
<   }
< #line 2757
<   if ((int )(mdev->net_conf)->two_primaries != p_two_primaries) {
< #line 2758
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "incompatible setting of the two-primaries options\n");
< #line 2759
<     goto disconnect;
---
>     }
> #line 3144
>     nc = _________p1;
> #line 3146
>     if ((__u32 )p_proto != nc->wire_protocol) {
> #line 3147
>       printk("\vd-con %s: incompatible %s settings\n", tconn->name, (char *)"protocol");
> #line 3148
>       goto disconnect_rcu_unlock;
>     } else {
> 
>     }
> #line 3151
>     tmp___8 = convert_after_sb(p_after_sb_0p);
> #line 3151
>     if ((unsigned int )tmp___8 != nc->after_sb_0p) {
> #line 3152
>       printk("\vd-con %s: incompatible %s settings\n", tconn->name, (char *)"after-sb-0pri");
> #line 3153
>       goto disconnect_rcu_unlock;
>     } else {
> 
>     }
> #line 3156
>     tmp___9 = convert_after_sb(p_after_sb_1p);
> #line 3156
>     if ((unsigned int )tmp___9 != nc->after_sb_1p) {
> #line 3157
>       printk("\vd-con %s: incompatible %s settings\n", tconn->name, (char *)"after-sb-1pri");
> #line 3158
>       goto disconnect_rcu_unlock;
>     } else {
> 
>     }
> #line 3161
>     tmp___10 = convert_after_sb(p_after_sb_2p);
> #line 3161
>     if ((unsigned int )tmp___10 != nc->after_sb_2p) {
> #line 3162
>       printk("\vd-con %s: incompatible %s settings\n", tconn->name, (char *)"after-sb-2pri");
> #line 3163
>       goto disconnect_rcu_unlock;
>     } else {
> 
>     }
> #line 3166
>     if (p_discard_my_data != 0 && (int )((signed char )nc->discard_my_data) != 0) {
> #line 3167
>       printk("\vd-con %s: incompatible %s settings\n", tconn->name, (char *)"discard-my-data");
> #line 3168
>       goto disconnect_rcu_unlock;
>     } else {
> 
>     }
> #line 3171
>     if ((int )nc->two_primaries != p_two_primaries) {
> #line 3172
>       printk("\vd-con %s: incompatible %s settings\n", tconn->name, (char *)"allow-two-primaries");
> #line 3173
>       goto disconnect_rcu_unlock;
>     } else {
> 
>     }
> #line 3176
>     tmp___11 = strcmp((char const   *)(& integrity_alg), (char const   *)(& nc->integrity_alg));
> #line 3176
>     if (tmp___11 != 0) {
> #line 3177
>       printk("\vd-con %s: incompatible %s settings\n", tconn->name, (char *)"data-integrity-alg");
> #line 3178
>       goto disconnect_rcu_unlock;
>     } else {
> 
>     }
> #line 3181
>     rcu_read_unlock();
26128,26137c27521,27532
< #line 2762
<   if (mdev->agreed_pro_version > 86) {
< #line 2763
<     my_alg = (unsigned char *)(& (mdev->net_conf)->integrity_alg);
< #line 2765
<     tmp___9 = drbd_recv(mdev, (void *)(& p_integrity_alg), (size_t )data_size);
< #line 2765
<     if ((unsigned int )tmp___9 != data_size) {
< #line 2766
<       return (0);
---
> #line 3184
>   if ((int )((signed char )integrity_alg[0]) != 0) {
> #line 3196
>     peer_integrity_tfm = crypto_alloc_hash((char const   *)(& integrity_alg), 0U,
>                                            128U);
> #line 3197
>     if ((unsigned long )peer_integrity_tfm == (unsigned long )((struct crypto_hash *)0)) {
> #line 3198
>       printk("\vd-con %s: peer data-integrity-alg %s not supported\n", tconn->name,
>              (char *)(& integrity_alg));
> #line 3200
>       goto disconnect;
26141,26149c27536,27549
< #line 2768
<     p_integrity_alg[63] = 0;
< #line 2769
<     tmp___10 = strcmp((char const   *)(& p_integrity_alg), (char const   *)my_alg);
< #line 2769
<     if (tmp___10 != 0) {
< #line 2770
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "incompatible setting of the data-integrity-alg\n");
< #line 2771
---
> #line 3203
>     tmp___12 = crypto_hash_digestsize(peer_integrity_tfm);
> #line 3203
>     hash_size = (int )tmp___12;
> #line 3204
>     int_dig_in = kmalloc((size_t )hash_size, 208U);
> #line 3205
>     int_dig_vv = kmalloc((size_t )hash_size, 208U);
> #line 3206
>     if ((unsigned long )int_dig_in == (unsigned long )((void *)0) || (unsigned long )int_dig_vv == (unsigned long )((void *)0)) {
> #line 3207
>       printk("\vd-con %s: Allocation of buffers for data integrity checking failed\n",
>              tconn->name);
> #line 3208
26154,26156d27553
< #line 2773
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "data-integrity-alg: %s\n",
<               (unsigned int )*my_alg != 0U ? my_alg : (unsigned char *)"<not-used>");
26160,26161c27557,27631
< #line 2777
<   return (1);
---
> #line 3212
>   tmp___13 = kmalloc(420UL, 208U);
> #line 3212
>   new_net_conf = (struct net_conf *)tmp___13;
> #line 3213
>   if ((unsigned long )new_net_conf == (unsigned long )((struct net_conf *)0)) {
> #line 3214
>     printk("\vd-con %s: Allocation of new net_conf failed\n", tconn->name);
> #line 3215
>     goto disconnect;
>   } else {
> 
>   }
> #line 3218
>   mutex_lock_nested(& tconn->data.mutex, 0U);
> #line 3219
>   mutex_lock_nested(& tconn->conf_update, 0U);
> #line 3220
>   old_net_conf = tconn->net_conf;
> #line 3221
>   *new_net_conf = *old_net_conf;
> #line 3223
>   new_net_conf->wire_protocol = (__u32 )p_proto;
> #line 3224
>   tmp___14 = convert_after_sb(p_after_sb_0p);
> #line 3224
>   new_net_conf->after_sb_0p = (__u32 )tmp___14;
> #line 3225
>   tmp___15 = convert_after_sb(p_after_sb_1p);
> #line 3225
>   new_net_conf->after_sb_1p = (__u32 )tmp___15;
> #line 3226
>   tmp___16 = convert_after_sb(p_after_sb_2p);
> #line 3226
>   new_net_conf->after_sb_2p = (__u32 )tmp___16;
> #line 3227
>   new_net_conf->two_primaries = (char )p_two_primaries;
> #line 3229
>   __asm__  volatile   ("": : : "memory");
> #line 3229
>   tconn->net_conf = new_net_conf;
> #line 3230
>   mutex_unlock(& tconn->conf_update);
> #line 3231
>   mutex_unlock(& tconn->data.mutex);
> #line 3233
>   crypto_free_hash(tconn->peer_integrity_tfm);
> #line 3234
>   kfree((void const   *)tconn->int_dig_in);
> #line 3235
>   kfree((void const   *)tconn->int_dig_vv);
> #line 3236
>   tconn->peer_integrity_tfm = peer_integrity_tfm;
> #line 3237
>   tconn->int_dig_in = int_dig_in;
> #line 3238
>   tconn->int_dig_vv = int_dig_vv;
> #line 3240
>   tmp___17 = strcmp((char const   *)(& old_net_conf->integrity_alg), (char const   *)(& integrity_alg));
> #line 3240
>   if (tmp___17 != 0) {
> #line 3241
>     printk("\016d-con %s: peer data-integrity-alg: %s\n", tconn->name, (int )((signed char )integrity_alg[0]) != 0 ? (char *)(& integrity_alg) : (char *)"(none)");
>   } else {
> 
>   }
> #line 3244
>   synchronize_rcu();
> #line 3245
>   kfree((void const   *)old_net_conf);
> #line 3246
>   return (0);
>   disconnect_rcu_unlock: 
> #line 3249
>   rcu_read_unlock();
26163c27633,27639
< #line 2780
---
> #line 3251
>   crypto_free_hash(peer_integrity_tfm);
> #line 3252
>   kfree((void const   *)int_dig_in);
> #line 3253
>   kfree((void const   *)int_dig_vv);
> #line 3254
26165,26167c27641,27643
< #line 2780
<   val.ldv_40583.conn = 1U;
< #line 2780
---
> #line 3254
>   val.ldv_40604.conn = 1U;
> #line 3254
26169,26174c27645,27650
< #line 2780
<   mask.ldv_40583.conn = 31U;
< #line 2780
<   drbd_force_state(mdev, mask, val);
< #line 2781
<   return (0);
---
> #line 3254
>   mask.ldv_40604.conn = 31U;
> #line 3254
>   conn_request_state(tconn, mask, val, CS_HARD);
> #line 3255
>   return (-5);
26177c27653
< #line 2789 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 3263 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
26184,26186d27659
<   void *tmp___1 ;
<   struct crypto_tfm *tmp___2 ;
<   int tmp___3 ;
26189c27662
< #line 2794
---
> #line 3268
26191c27664
< #line 2795
---
> #line 3269
26196c27669
< #line 2797
---
> #line 3271
26198c27671
< #line 2798
---
> #line 3272
26200c27673
< #line 2798
---
> #line 3272
26202c27675
< #line 2799
---
> #line 3273
26204c27677
< #line 2799
---
> #line 3273
26207c27680
< #line 2801
---
> #line 3275
26212,26226c27685,27724
< #line 2803
<   tmp___2 = crypto_hash_tfm(tfm);
< #line 2803
<   tmp___3 = drbd_crypto_is_hash(tmp___2);
< #line 2803
<   if (tmp___3 == 0) {
< #line 2804
<     crypto_free_hash(tfm);
< #line 2805
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "\"%s\" is not a digest (%s)\n",
<             alg, name);
< #line 2806
<     tmp___1 = ERR_PTR(-22L);
< #line 2806
<     return ((struct crypto_hash *)tmp___1);
---
> #line 3277
>   return (tfm);
> }
> }
> #line 3280 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int ignore_remaining_packet(struct drbd_tconn *tconn , struct packet_info *pi ) 
> { 
>   void *buffer ;
>   int size ;
>   int s ;
>   int __min1 ;
>   int __min2 ;
> 
>   {
> #line 3282
>   buffer = tconn->data.rbuf;
> #line 3283
>   size = (int )pi->size;
> #line 3285
>   goto ldv_53437;
>   ldv_53436: 
> #line 3286
>   __min1 = size;
> #line 3286
>   __min2 = 4096;
> #line 3286
>   s = __min1 < __min2 ? __min1 : __min2;
> #line 3287
>   s = drbd_recv(tconn, buffer, (size_t )s);
> #line 3288
>   if (s <= 0) {
> #line 3289
>     if (s < 0) {
> #line 3290
>       return (s);
>     } else {
> 
>     }
> #line 3291
>     goto ldv_53435;
26230,26231c27728,27747
< #line 2808
<   return (tfm);
---
> #line 3293
>   size = size - s;
>   ldv_53437: ;
> #line 3285
>   if (size != 0) {
> #line 3286
>     goto ldv_53436;
>   } else {
> 
>   }
>   ldv_53435: ;
> #line 3295
>   if (size != 0) {
> #line 3296
>     return (-5);
>   } else {
> 
>   }
> #line 3297
>   return (0);
26234,26235c27750,27751
< #line 2811 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_SyncParam(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int packet_size ) 
---
> #line 3311 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int config_unknown_volume(struct drbd_tconn *tconn , struct packet_info *pi ) 
26237c27753,27771
<   int ok ;
---
>   char const   *tmp ;
>   int tmp___0 ;
> 
>   {
> #line 3313
>   tmp = cmdname(pi->cmd);
> #line 3313
>   printk("\fd-con %s: %s packet received for volume %u, which is not configured locally\n",
>          tconn->name, tmp, pi->vnr);
> #line 3315
>   tmp___0 = ignore_remaining_packet(tconn, pi);
> #line 3315
>   return (tmp___0);
> }
> }
> #line 3318 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_SyncParam(struct drbd_tconn *tconn , struct packet_info *pi ) 
> { 
>   struct drbd_conf *mdev ;
26243a27778,27781
>   struct net_conf *old_net_conf ;
>   struct net_conf *new_net_conf ;
>   struct disk_conf *old_disk_conf ;
>   struct disk_conf *new_disk_conf ;
26245c27783,27784
<   int *rs_plan_s ;
---
>   struct fifo_buffer *old_plan ;
>   struct fifo_buffer *new_plan ;
26246a27786
>   int err ;
26248,26254c27788,27794
<   __u32 tmp___0 ;
<   int tmp___1 ;
<   long tmp___2 ;
<   int tmp___3 ;
<   long tmp___4 ;
<   int tmp___5 ;
<   __u32 tmp___6 ;
---
>   void *tmp___0 ;
>   __u32 tmp___1 ;
>   int tmp___2 ;
>   long tmp___3 ;
>   int tmp___4 ;
>   long tmp___5 ;
>   int tmp___6 ;
26266,26270c27806
< #line 2813
<   ok = 1;
< #line 2814
<   p = & mdev->data.rbuf.rs_param_95;
< #line 2816
---
> #line 3323
26272c27808
< #line 2817
---
> #line 3324
26274,26278c27810,27822
< #line 2818
<   apv = mdev->agreed_pro_version;
< #line 2819
<   rs_plan_s = 0;
< #line 2820
---
> #line 3325
>   new_net_conf = 0;
> #line 3326
>   old_disk_conf = 0;
> #line 3326
>   new_disk_conf = 0;
> #line 3327
>   apv = tconn->agreed_pro_version;
> #line 3328
>   old_plan = 0;
> #line 3328
>   new_plan = 0;
> #line 3329
26280,26284c27824,27839
< #line 2822
<   exp_max_sz = apv > 87 ? (apv != 88 ? (apv <= 94 ? 140U : 156U) : 76U) : 12U;
< #line 2828
<   if (packet_size > exp_max_sz) {
< #line 2829
---
> #line 3332
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 3333
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 3334
>     tmp = config_unknown_volume(tconn, pi);
> #line 3334
>     return (tmp);
>   } else {
> 
>   }
> #line 3336
>   exp_max_sz = apv > 87 ? (apv != 88 ? (apv <= 94 ? 132U : 148U) : 68U) : 4U;
> #line 3342
>   if (pi->size > exp_max_sz) {
> #line 3343
26286,26288c27841,27843
<             packet_size, exp_max_sz);
< #line 2831
<     return (0);
---
>             pi->size, exp_max_sz);
> #line 3345
>     return (-5);
26292c27847
< #line 2834
---
> #line 3348
26294c27849
< #line 2835
---
> #line 3349
26296,26297c27851,27852
< #line 2836
<     data_size = packet_size - header_size;
---
> #line 3350
>     data_size = pi->size - header_size;
26299c27854
< #line 2837
---
> #line 3351
26301c27856
< #line 2838
---
> #line 3352
26303,26305c27858,27860
< #line 2839
<     data_size = packet_size - header_size;
< #line 2840
---
> #line 3353
>     data_size = pi->size - header_size;
> #line 3354
26307c27862
< #line 2840
---
> #line 3354
26309,26310c27864,27865
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               2840);
---
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>               3354);
26315c27870
< #line 2842
---
> #line 3356
26317,26319c27872,27874
< #line 2843
<     data_size = packet_size - header_size;
< #line 2844
---
> #line 3357
>     data_size = pi->size - header_size;
> #line 3358
26321c27876
< #line 2844
---
> #line 3358
26323,26324c27878,27879
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               2844);
---
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>               3358);
26329c27884,27886
< #line 2848
---
> #line 3362
>   p = (struct p_rs_param_95 *)pi->data;
> #line 3363
26331,26336c27888,27893
< #line 2850
<   tmp = drbd_recv(mdev, (void *)(& p->head.payload), (size_t )header_size);
< #line 2850
<   if ((unsigned int )tmp != header_size) {
< #line 2851
<     return (0);
---
> #line 3365
>   err = drbd_recv_all(mdev->tconn, (void *)p, (size_t )header_size);
> #line 3366
>   if (err != 0) {
> #line 3367
>     return (err);
26340,26344c27897,27933
< #line 2853
<   tmp___0 = __fswab32(p->rate);
< #line 2853
<   mdev->sync_conf.rate = (int )tmp___0;
< #line 2855
---
> #line 3369
>   mutex_lock_nested(& (mdev->tconn)->conf_update, 0U);
> #line 3370
>   old_net_conf = (mdev->tconn)->net_conf;
> #line 3371
>   tmp___2 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 3371
>   if (tmp___2 != 0) {
> #line 3372
>     tmp___0 = kzalloc(344UL, 208U);
> #line 3372
>     new_disk_conf = (struct disk_conf *)tmp___0;
> #line 3373
>     if ((unsigned long )new_disk_conf == (unsigned long )((struct disk_conf *)0)) {
> #line 3374
>       put_ldev(mdev);
> #line 3375
>       mutex_unlock(& (mdev->tconn)->conf_update);
> #line 3376
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Allocation of new disk_conf failed\n");
> #line 3377
>       return (-12);
>     } else {
> 
>     }
> #line 3380
>     old_disk_conf = (mdev->ldev)->disk_conf;
> #line 3381
>     *new_disk_conf = *old_disk_conf;
> #line 3383
>     tmp___1 = __fswab32(p->resync_rate);
> #line 3383
>     new_disk_conf->resync_rate = tmp___1;
>   } else {
> 
>   }
> #line 3386
26346c27935
< #line 2856
---
> #line 3387
26348c27937
< #line 2857
---
> #line 3388
26350c27939
< #line 2858
---
> #line 3389
26353,26354c27942,27945
< #line 2861
<         return (0);
---
> #line 3392
>         err = -5;
> #line 3393
>         goto reconnect;
26358,26363c27949,27954
< #line 2864
<       tmp___1 = drbd_recv(mdev, (void *)(& p->verify_alg), (size_t )data_size);
< #line 2864
<       if ((unsigned int )tmp___1 != data_size) {
< #line 2865
<         return (0);
---
> #line 3396
>       err = drbd_recv_all(mdev->tconn, (void *)(& p->verify_alg), (size_t )data_size);
> #line 3397
>       if (err != 0) {
> #line 3398
>         goto reconnect;
26367c27958
< #line 2869
---
> #line 3401
26369c27960
< #line 2869
---
> #line 3401
26371,26372c27962,27963
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                 2869);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                 3401);
26376c27967
< #line 2870
---
> #line 3402
26379c27970
< #line 2875
---
> #line 3407
26381c27972
< #line 2875
---
> #line 3407
26383,26384c27974,27975
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                 2875);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                 3407);
26388c27979
< #line 2876
---
> #line 3408
26390c27981
< #line 2876
---
> #line 3408
26392,26393c27983,27984
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                 2876);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                 3408);
26397c27988
< #line 2877
---
> #line 3409
26399c27990
< #line 2878
---
> #line 3410
26402,26408c27993,27999
< #line 2881
<     tmp___3 = strcmp((char const   *)(& mdev->sync_conf.verify_alg), (char const   *)(& p->verify_alg));
< #line 2881
<     if (tmp___3 != 0) {
< #line 2882
<       if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 144U) {
< #line 2883
---
> #line 3413
>     tmp___4 = strcmp((char const   *)(& old_net_conf->verify_alg), (char const   *)(& p->verify_alg));
> #line 3413
>     if (tmp___4 != 0) {
> #line 3414
>       if ((unsigned int )*((unsigned short *)mdev + 374UL) == 144U) {
> #line 3415
26410,26411c28001,28002
<                 (unsigned char *)(& mdev->sync_conf.verify_alg), (char *)(& p->verify_alg));
< #line 2885
---
>                 (char *)(& old_net_conf->verify_alg), (char *)(& p->verify_alg));
> #line 3417
26416c28007
< #line 2887
---
> #line 3419
26420,26424c28011,28015
< #line 2889
<       tmp___2 = IS_ERR((void const   *)verify_tfm);
< #line 2889
<       if (tmp___2 != 0L) {
< #line 2890
---
> #line 3421
>       tmp___3 = IS_ERR((void const   *)verify_tfm);
> #line 3421
>       if (tmp___3 != 0L) {
> #line 3422
26426c28017
< #line 2891
---
> #line 3423
26434c28025
< #line 2895
---
> #line 3427
26436,26442c28027,28033
< #line 2895
<       tmp___5 = strcmp((char const   *)(& mdev->sync_conf.csums_alg), (char const   *)(& p->csums_alg));
< #line 2895
<       if (tmp___5 != 0) {
< #line 2896
<         if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 144U) {
< #line 2897
---
> #line 3427
>       tmp___6 = strcmp((char const   *)(& old_net_conf->csums_alg), (char const   *)(& p->csums_alg));
> #line 3427
>       if (tmp___6 != 0) {
> #line 3428
>         if ((unsigned int )*((unsigned short *)mdev + 374UL) == 144U) {
> #line 3429
26444,26445c28035,28036
<                   (unsigned char *)(& mdev->sync_conf.csums_alg), (char *)(& p->csums_alg));
< #line 2899
---
>                   (char *)(& old_net_conf->csums_alg), (char *)(& p->csums_alg));
> #line 3431
26450c28041
< #line 2901
---
> #line 3433
26454,26458c28045,28049
< #line 2903
<         tmp___4 = IS_ERR((void const   *)csums_tfm);
< #line 2903
<         if (tmp___4 != 0L) {
< #line 2904
---
> #line 3435
>         tmp___5 = IS_ERR((void const   *)csums_tfm);
> #line 3435
>         if (tmp___5 != 0L) {
> #line 3436
26460c28051
< #line 2905
---
> #line 3437
26471,26477c28062,28064
< #line 2909
<     if (apv > 94) {
< #line 2910
<       tmp___6 = __fswab32(p->rate);
< #line 2910
<       mdev->sync_conf.rate = (int )tmp___6;
< #line 2911
---
> #line 3441
>     if (apv > 94 && (unsigned long )new_disk_conf != (unsigned long )((struct disk_conf *)0)) {
> #line 3442
26479,26481c28066,28068
< #line 2911
<       mdev->sync_conf.c_plan_ahead = (int )tmp___7;
< #line 2912
---
> #line 3442
>       new_disk_conf->c_plan_ahead = tmp___7;
> #line 3443
26483,26485c28070,28072
< #line 2912
<       mdev->sync_conf.c_delay_target = (int )tmp___8;
< #line 2913
---
> #line 3443
>       new_disk_conf->c_delay_target = tmp___8;
> #line 3444
26487,26489c28074,28076
< #line 2913
<       mdev->sync_conf.c_fill_target = (int )tmp___9;
< #line 2914
---
> #line 3444
>       new_disk_conf->c_fill_target = tmp___9;
> #line 3445
26491,26503c28078,28088
< #line 2914
<       mdev->sync_conf.c_max_rate = (int )tmp___10;
< #line 2916
<       fifo_size = (mdev->sync_conf.c_plan_ahead * 250) / 250;
< #line 2917
<       if ((unsigned int )fifo_size != mdev->rs_plan_s.size && fifo_size > 0) {
< #line 2918
<         tmp___11 = kzalloc((unsigned long )fifo_size * 4UL, 16U);
< #line 2918
<         rs_plan_s = (int *)tmp___11;
< #line 2919
<         if ((unsigned long )rs_plan_s == (unsigned long )((int *)0)) {
< #line 2920
---
> #line 3445
>       new_disk_conf->c_max_rate = tmp___10;
> #line 3447
>       fifo_size = (int )((new_disk_conf->c_plan_ahead * 250U) / 250U);
> #line 3448
>       if ((unsigned int )fifo_size != (mdev->rs_plan_s)->size) {
> #line 3449
>         new_plan = fifo_alloc(fifo_size);
> #line 3450
>         if ((unsigned long )new_plan == (unsigned long )((struct fifo_buffer *)0)) {
> #line 3451
26505c28090,28092
< #line 2921
---
> #line 3452
>           put_ldev(mdev);
> #line 3453
26516,26533c28103,28115
< #line 2926
<     spin_lock(& mdev->peer_seq_lock);
< #line 2928
<     if ((unsigned long )verify_tfm != (unsigned long )((struct crypto_hash *)0)) {
< #line 2929
<       strcpy((char *)(& mdev->sync_conf.verify_alg), (char const   *)(& p->verify_alg));
< #line 2930
<       tmp___12 = strlen((char const   *)(& p->verify_alg));
< #line 2930
<       mdev->sync_conf.verify_alg_len = (int )((unsigned int )tmp___12 + 1U);
< #line 2931
<       crypto_free_hash(mdev->verify_tfm);
< #line 2932
<       mdev->verify_tfm = verify_tfm;
< #line 2933
<       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "using verify-alg: \"%s\"\n",
<                 (char *)(& p->verify_alg));
<     } else {
---
> #line 3458
>     if ((unsigned long )verify_tfm != (unsigned long )((struct crypto_hash *)0) || (unsigned long )csums_tfm != (unsigned long )((struct crypto_hash *)0)) {
> #line 3459
>       tmp___11 = kzalloc(420UL, 208U);
> #line 3459
>       new_net_conf = (struct net_conf *)tmp___11;
> #line 3460
>       if ((unsigned long )new_net_conf == (unsigned long )((struct net_conf *)0)) {
> #line 3461
>         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Allocation of new net_conf failed\n");
> #line 3462
>         goto disconnect;
>       } else {
26535,26551c28117,28135
<     }
< #line 2935
<     if ((unsigned long )csums_tfm != (unsigned long )((struct crypto_hash *)0)) {
< #line 2936
<       strcpy((char *)(& mdev->sync_conf.csums_alg), (char const   *)(& p->csums_alg));
< #line 2937
<       tmp___13 = strlen((char const   *)(& p->csums_alg));
< #line 2937
<       mdev->sync_conf.csums_alg_len = (int )((unsigned int )tmp___13 + 1U);
< #line 2938
<       crypto_free_hash(mdev->csums_tfm);
< #line 2939
<       mdev->csums_tfm = csums_tfm;
< #line 2940
<       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "using csums-alg: \"%s\"\n",
<                 (char *)(& p->csums_alg));
<     } else {
---
>       }
> #line 3465
>       *new_net_conf = *old_net_conf;
> #line 3467
>       if ((unsigned long )verify_tfm != (unsigned long )((struct crypto_hash *)0)) {
> #line 3468
>         strcpy((char *)(& new_net_conf->verify_alg), (char const   *)(& p->verify_alg));
> #line 3469
>         tmp___12 = strlen((char const   *)(& p->verify_alg));
> #line 3469
>         new_net_conf->verify_alg_len = (__u32 )tmp___12 + 1U;
> #line 3470
>         crypto_free_hash((mdev->tconn)->verify_tfm);
> #line 3471
>         (mdev->tconn)->verify_tfm = verify_tfm;
> #line 3472
>         _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "using verify-alg: \"%s\"\n",
>                   (char *)(& p->verify_alg));
>       } else {
26553,26563c28137,28159
<     }
< #line 2942
<     if ((unsigned int )fifo_size != mdev->rs_plan_s.size) {
< #line 2943
<       kfree((void const   *)mdev->rs_plan_s.values);
< #line 2944
<       mdev->rs_plan_s.values = rs_plan_s;
< #line 2945
<       mdev->rs_plan_s.size = (unsigned int )fifo_size;
< #line 2946
<       mdev->rs_planed = 0;
---
>       }
> #line 3474
>       if ((unsigned long )csums_tfm != (unsigned long )((struct crypto_hash *)0)) {
> #line 3475
>         strcpy((char *)(& new_net_conf->csums_alg), (char const   *)(& p->csums_alg));
> #line 3476
>         tmp___13 = strlen((char const   *)(& p->csums_alg));
> #line 3476
>         new_net_conf->csums_alg_len = (__u32 )tmp___13 + 1U;
> #line 3477
>         crypto_free_hash((mdev->tconn)->csums_tfm);
> #line 3478
>         (mdev->tconn)->csums_tfm = csums_tfm;
> #line 3479
>         _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "using csums-alg: \"%s\"\n",
>                   (char *)(& p->csums_alg));
>       } else {
> 
>       }
> #line 3481
>       __asm__  volatile   ("": : : "memory");
> #line 3481
>       tconn->net_conf = new_net_conf;
26567,26568d28162
< #line 2948
<     spin_unlock(& mdev->peer_seq_lock);
26572,26573c28166,28218
< #line 2951
<   return (ok);
---
> #line 3485
>   if ((unsigned long )new_disk_conf != (unsigned long )((struct disk_conf *)0)) {
> #line 3486
>     __asm__  volatile   ("": : : "memory");
> #line 3486
>     (mdev->ldev)->disk_conf = new_disk_conf;
> #line 3487
>     put_ldev(mdev);
>   } else {
> 
>   }
> #line 3490
>   if ((unsigned long )new_plan != (unsigned long )((struct fifo_buffer *)0)) {
> #line 3491
>     old_plan = mdev->rs_plan_s;
> #line 3492
>     __asm__  volatile   ("": : : "memory");
> #line 3492
>     mdev->rs_plan_s = new_plan;
>   } else {
> 
>   }
> #line 3495
>   mutex_unlock(& (mdev->tconn)->conf_update);
> #line 3496
>   synchronize_rcu();
> #line 3497
>   if ((unsigned long )new_net_conf != (unsigned long )((struct net_conf *)0)) {
> #line 3498
>     kfree((void const   *)old_net_conf);
>   } else {
> 
>   }
> #line 3499
>   kfree((void const   *)old_disk_conf);
> #line 3500
>   kfree((void const   *)old_plan);
> #line 3502
>   return (0);
>   reconnect: ;
> #line 3505
>   if ((unsigned long )new_disk_conf != (unsigned long )((struct disk_conf *)0)) {
> #line 3506
>     put_ldev(mdev);
> #line 3507
>     kfree((void const   *)new_disk_conf);
>   } else {
> 
>   }
> #line 3509
>   mutex_unlock(& (mdev->tconn)->conf_update);
> #line 3510
>   return (-5);
26575c28220,28233
< #line 2955
---
> #line 3513
>   kfree((void const   *)new_plan);
> #line 3514
>   if ((unsigned long )new_disk_conf != (unsigned long )((struct disk_conf *)0)) {
> #line 3515
>     put_ldev(mdev);
> #line 3516
>     kfree((void const   *)new_disk_conf);
>   } else {
> 
>   }
> #line 3518
>   mutex_unlock(& (mdev->tconn)->conf_update);
> #line 3521
26577c28235
< #line 2957
---
> #line 3523
26579c28237
< #line 2958
---
> #line 3524
26581,26583c28239,28241
< #line 2958
<   val.ldv_40583.conn = 1U;
< #line 2958
---
> #line 3524
>   val.ldv_40604.conn = 1U;
> #line 3524
26585,26590c28243,28248
< #line 2958
<   mask.ldv_40583.conn = 31U;
< #line 2958
<   drbd_force_state(mdev, mask, val);
< #line 2959
<   return (0);
---
> #line 3524
>   mask.ldv_40604.conn = 31U;
> #line 3524
>   conn_request_state(mdev->tconn, mask, val, CS_HARD);
> #line 3525
>   return (-5);
26593c28251
< #line 2963 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 3529 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
26600c28258
< #line 2967
---
> #line 3533
26602c28260
< #line 2968
---
> #line 3534
26607c28265
< #line 2969
---
> #line 3535
26609c28267
< #line 2970
---
> #line 3536
26611c28269
< #line 2971
---
> #line 3537
26617c28275
< #line 2973
---
> #line 3539
26621,26622c28279,28280
< #line 2975 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_sizes(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 3541 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_sizes(struct drbd_tconn *tconn , struct packet_info *pi ) 
26623a28282
>   struct drbd_conf *mdev ;
26631c28290
<   __u64 tmp ;
---
>   int tmp ;
26633,26636c28292,28298
<   union drbd_state val ;
<   union drbd_state mask ;
<   sector_t tmp___1 ;
<   unsigned long __x ;
---
>   __u64 tmp___1 ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___2 ;
>   int tmp___3 ;
>   sector_t tmp___4 ;
>   sector_t __x ;
26638c28300
<   unsigned long _min1 ;
---
>   sector_t _min1 ;
26640,26644d28301
<   unsigned long tmp___2 ;
<   unsigned long tmp___3 ;
<   union drbd_state val___0 ;
<   union drbd_state mask___0 ;
<   sector_t tmp___4 ;
26646,26654c28303,28319
<   int tmp___6 ;
<   __u16 tmp___7 ;
<   int tmp___8 ;
<   __u32 tmp___9 ;
<   sector_t tmp___10 ;
<   int tmp___11 ;
<   __u64 tmp___12 ;
<   sector_t tmp___13 ;
<   int tmp___14 ;
---
>   sector_t tmp___6 ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   sector_t tmp___7 ;
>   sector_t tmp___8 ;
>   struct disk_conf *old_disk_conf ;
>   struct disk_conf *new_disk_conf ;
>   void *tmp___9 ;
>   int tmp___10 ;
>   __u16 tmp___11 ;
>   int tmp___12 ;
>   __u32 tmp___13 ;
>   sector_t tmp___14 ;
>   int tmp___15 ;
>   __u64 tmp___16 ;
>   sector_t tmp___17 ;
>   int tmp___18 ;
26657,26659c28322,28324
< #line 2977
<   p = & mdev->data.rbuf.sizes;
< #line 2978
---
> #line 3544
>   p = (struct p_sizes *)pi->data;
> #line 3545
26661c28326
< #line 2980
---
> #line 3547
26663,26686c28328,28335
< #line 2983
<   tmp = __fswab64(p->d_size);
< #line 2983
<   p_size = (sector_t )tmp;
< #line 2984
<   tmp___0 = __fswab64(p->u_size);
< #line 2984
<   p_usize = (sector_t )tmp___0;
< #line 2986
<   if (p_size == 0UL && (unsigned int )*((unsigned char *)mdev + 2277UL) == 0U) {
< #line 2987
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "some backing storage is needed\n");
< #line 2988
<     val.i = 0U;
< #line 2988
<     val.ldv_40583.conn = 1U;
< #line 2988
<     mask.i = 0U;
< #line 2988
<     mask.ldv_40583.conn = 31U;
< #line 2988
<     drbd_force_state(mdev, mask, val);
< #line 2989
<     return (0);
---
> #line 3550
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 3551
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 3552
>     tmp = config_unknown_volume(tconn, pi);
> #line 3552
>     return (tmp);
26690c28339,28347
< #line 2994
---
> #line 3554
>   tmp___0 = __fswab64(p->d_size);
> #line 3554
>   p_size = (sector_t )tmp___0;
> #line 3555
>   tmp___1 = __fswab64(p->u_size);
> #line 3555
>   p_usize = (sector_t )tmp___1;
> #line 3559
26692,26706c28349,28390
< #line 2996
<   tmp___6 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 2996
<   if (tmp___6 != 0) {
< #line 2997
<     tmp___1 = drbd_get_max_capacity(mdev->ldev);
< #line 2997
<     warn_if_differ_considerably(mdev, "lower level device sizes", p_size, tmp___1);
< #line 2999
<     warn_if_differ_considerably(mdev, "user requested size", p_usize, (sector_t )(mdev->ldev)->dc.disk_size);
< #line 3004
<     if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 144U) {
< #line 3005
<       __x = (unsigned long )(mdev->ldev)->dc.disk_size;
< #line 3005
---
> #line 3561
>   tmp___10 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 3561
>   if (tmp___10 != 0) {
> #line 3562
>     rcu_read_lock();
> #line 3563
>     _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 3563
>     tmp___2 = debug_lockdep_rcu_enabled();
> #line 3563
>     if (tmp___2 != 0 && ! __warned) {
> #line 3563
>       tmp___3 = rcu_read_lock_held();
> #line 3563
>       if (tmp___3 == 0 && 1) {
> #line 3563
>         __warned = 1;
> #line 3563
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                                3563, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 3563
>     my_usize = (sector_t )_________p1->disk_size;
> #line 3564
>     rcu_read_unlock();
> #line 3566
>     tmp___4 = drbd_get_max_capacity(mdev->ldev);
> #line 3566
>     warn_if_differ_considerably(mdev, "lower level device sizes", p_size, tmp___4);
> #line 3568
>     warn_if_differ_considerably(mdev, "user requested size", p_usize, my_usize);
> #line 3573
>     if ((unsigned int )*((unsigned short *)mdev + 374UL) == 144U) {
> #line 3574
>       __x = my_usize;
> #line 3574
26708c28392
< #line 3005
---
> #line 3574
26710c28394
< #line 3005
---
> #line 3574
26712c28396
< #line 3005
---
> #line 3574
26714c28398
< #line 3005
---
> #line 3574
26716,26717c28400,28401
< #line 3005
<           tmp___2 = _min1 < _min2 ? _min1 : _min2;
---
> #line 3574
>           tmp___5 = _min1 < _min2 ? _min1 : _min2;
26719,26720c28403,28404
< #line 3005
<           tmp___2 = __x;
---
> #line 3574
>           tmp___5 = __x;
26722,26723c28406,28407
< #line 3005
<         tmp___3 = tmp___2;
---
> #line 3574
>         tmp___6 = tmp___5;
26725,26726c28409,28410
< #line 3005
<         tmp___3 = __y;
---
> #line 3574
>         tmp___6 = __y;
26728,26729c28412,28413
< #line 3005
<       p_usize = tmp___3;
---
> #line 3574
>       p_usize = tmp___6;
26733,26741c28417,28438
< #line 3008
<     my_usize = (sector_t )(mdev->ldev)->dc.disk_size;
< #line 3010
<     if ((mdev->ldev)->dc.disk_size != (unsigned long long )p_usize) {
< #line 3011
<       (mdev->ldev)->dc.disk_size = (__u64 )p_usize;
< #line 3012
<       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Peer sets u_size to %lu sectors\n",
<                 (unsigned long )(mdev->ldev)->dc.disk_size);
---
> #line 3578
>     tmp___7 = drbd_new_dev_size(mdev, mdev->ldev, p_usize, 0);
> #line 3578
>     tmp___8 = drbd_get_capacity(mdev->this_bdev);
> #line 3578
>     if ((tmp___7 < tmp___8 && (int )mdev->state.ldv_50103.disk > 4) && (int )mdev->state.ldv_50103.conn <= 9) {
> #line 3582
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "The peer\'s disk size is too small!\n");
> #line 3583
>       val.i = 0U;
> #line 3583
>       val.ldv_40604.conn = 1U;
> #line 3583
>       mask.i = 0U;
> #line 3583
>       mask.ldv_40604.conn = 31U;
> #line 3583
>       conn_request_state(mdev->tconn, mask, val, CS_HARD);
> #line 3584
>       put_ldev(mdev);
> #line 3585
>       return (-5);
26745,26768c28442,28481
< #line 3018
<     tmp___4 = drbd_new_dev_size(mdev, mdev->ldev, 0);
< #line 3018
<     tmp___5 = drbd_get_capacity(mdev->this_bdev);
< #line 3018
<     if ((tmp___4 < tmp___5 && (int )mdev->state.ldv_40583.disk > 4) && (int )mdev->state.ldv_40583.conn <= 9) {
< #line 3022
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "The peer\'s disk size is too small!\n");
< #line 3023
<       val___0.i = 0U;
< #line 3023
<       val___0.ldv_40583.conn = 1U;
< #line 3023
<       mask___0.i = 0U;
< #line 3023
<       mask___0.ldv_40583.conn = 31U;
< #line 3023
<       drbd_force_state(mdev, mask___0, val___0);
< #line 3024
<       (mdev->ldev)->dc.disk_size = (__u64 )my_usize;
< #line 3025
<       put_ldev(mdev);
< #line 3026
<       return (0);
---
> #line 3588
>     if (my_usize != p_usize) {
> #line 3589
>       new_disk_conf = 0;
> #line 3591
>       tmp___9 = kzalloc(344UL, 208U);
> #line 3591
>       new_disk_conf = (struct disk_conf *)tmp___9;
> #line 3592
>       if ((unsigned long )new_disk_conf == (unsigned long )((struct disk_conf *)0)) {
> #line 3593
>         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Allocation of new disk_conf failed\n");
> #line 3594
>         put_ldev(mdev);
> #line 3595
>         return (-12);
>       } else {
> 
>       }
> #line 3598
>       mutex_lock_nested(& (mdev->tconn)->conf_update, 0U);
> #line 3599
>       old_disk_conf = (mdev->ldev)->disk_conf;
> #line 3600
>       *new_disk_conf = *old_disk_conf;
> #line 3601
>       new_disk_conf->disk_size = (__u64 )p_usize;
> #line 3603
>       __asm__  volatile   ("": : : "memory");
> #line 3603
>       (mdev->ldev)->disk_conf = new_disk_conf;
> #line 3604
>       mutex_unlock(& (mdev->tconn)->conf_update);
> #line 3605
>       synchronize_rcu();
> #line 3606
>       kfree((void const   *)old_disk_conf);
> #line 3608
>       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Peer sets u_size to %lu sectors\n",
>                 my_usize);
26772c28485
< #line 3028
---
> #line 3612
26777,26785c28490,28498
< #line 3031
<   tmp___7 = __fswab16((int )p->dds_flags);
< #line 3031
<   ddsf = (enum dds_flags )tmp___7;
< #line 3032
<   tmp___8 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 3032
<   if (tmp___8 != 0) {
< #line 3033
---
> #line 3615
>   tmp___11 = __fswab16((int )p->dds_flags);
> #line 3615
>   ddsf = (enum dds_flags )tmp___11;
> #line 3616
>   tmp___12 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 3616
>   if (tmp___12 != 0) {
> #line 3617
26787c28500
< #line 3034
---
> #line 3618
26789c28502
< #line 3035
---
> #line 3619
26791,26792c28504,28505
< #line 3036
<       return (0);
---
> #line 3620
>       return (-5);
26796c28509
< #line 3037
---
> #line 3621
26799c28512
< #line 3040
---
> #line 3624
26802,26806c28515,28519
< #line 3043
<   tmp___9 = __fswab32(p->max_bio_size);
< #line 3043
<   mdev->peer_max_bio_size = tmp___9;
< #line 3044
---
> #line 3627
>   tmp___13 = __fswab32(p->max_bio_size);
> #line 3627
>   mdev->peer_max_bio_size = tmp___13;
> #line 3628
26808,26816c28521,28529
< #line 3046
<   tmp___11 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 3046
<   if (tmp___11 != 0) {
< #line 3047
<     tmp___10 = drbd_get_capacity((mdev->ldev)->backing_bdev);
< #line 3047
<     if ((mdev->ldev)->known_size != tmp___10) {
< #line 3048
---
> #line 3630
>   tmp___15 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 3630
>   if (tmp___15 != 0) {
> #line 3631
>     tmp___14 = drbd_get_capacity((mdev->ldev)->backing_bdev);
> #line 3631
>     if ((mdev->ldev)->known_size != tmp___14) {
> #line 3632
26818c28531
< #line 3049
---
> #line 3633
26823c28536
< #line 3052
---
> #line 3636
26828,26836c28541,28549
< #line 3055
<   if ((int )mdev->state.ldv_40583.conn > 9) {
< #line 3056
<     tmp___12 = __fswab64(p->c_size);
< #line 3056
<     tmp___13 = drbd_get_capacity(mdev->this_bdev);
< #line 3056
<     if (tmp___12 != (unsigned long long )tmp___13 || ldsc != 0) {
< #line 3060
---
> #line 3639
>   if ((int )mdev->state.ldv_50103.conn > 9) {
> #line 3640
>     tmp___16 = __fswab64(p->c_size);
> #line 3640
>     tmp___17 = drbd_get_capacity(mdev->this_bdev);
> #line 3640
>     if (tmp___16 != (unsigned long long )tmp___17 || ldsc != 0) {
> #line 3644
26841,26847c28554,28560
< #line 3062
<     tmp___14 = drbd_test_and_clear_flag(mdev, RESIZE_PENDING);
< #line 3062
<     if (tmp___14 != 0 || ((int )dd == 2 && (unsigned int )*((unsigned short *)mdev + 1138UL) == 160U)) {
< #line 3064
<       if ((int )mdev->state.ldv_40583.pdsk > 3 && (int )mdev->state.ldv_40583.disk > 3) {
< #line 3066
---
> #line 3646
>     tmp___18 = test_and_clear_bit(16, (unsigned long volatile   *)(& mdev->flags));
> #line 3646
>     if (tmp___18 != 0 || ((int )dd == 2 && (unsigned int )*((unsigned short *)mdev + 374UL) == 160U)) {
> #line 3648
>       if ((int )mdev->state.ldv_50103.pdsk > 3 && (int )mdev->state.ldv_50103.disk > 3) {
> #line 3650
26849c28562
< #line 3067
---
> #line 3651
26852c28565
< #line 3069
---
> #line 3653
26856,26857c28569,28570
< #line 3071
<         drbd_set_flag(mdev, RESYNC_AFTER_NEG);
---
> #line 3655
>         set_bit(15U, (unsigned long volatile   *)(& mdev->flags));
26865,26866c28578,28579
< #line 3075
<   return (1);
---
> #line 3659
>   return (0);
26869,26870c28582,28583
< #line 3078 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_uuids(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 3662 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_uuids(struct drbd_tconn *tconn , struct packet_info *pi ) 
26871a28585
>   struct drbd_conf *mdev ;
26876,26877c28590,28592
<   void *tmp ;
<   __u64 tmp___0 ;
---
>   int tmp ;
>   void *tmp___0 ;
>   __u64 tmp___1 ;
26882d28596
<   int tmp___1 ;
26884,26887c28598
<   wait_queue_t __wait ;
<   struct task_struct *tmp___3 ;
<   int tmp___4 ;
<   int tmp___5 ;
---
>   int tmp___3 ;
26890,26892c28601,28603
< #line 3080
<   p = & mdev->data.rbuf.uuids;
< #line 3082
---
> #line 3665
>   p = (struct p_uuids *)pi->data;
> #line 3667
26894,26898c28605,28620
< #line 3084
<   tmp = kmalloc(48UL, 16U);
< #line 3084
<   p_uuid = (u64 *)tmp;
< #line 3086
---
> #line 3669
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 3670
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 3671
>     tmp = config_unknown_volume(tconn, pi);
> #line 3671
>     return (tmp);
>   } else {
> 
>   }
> #line 3673
>   tmp___0 = kmalloc(48UL, 16U);
> #line 3673
>   p_uuid = (u64 *)tmp___0;
> #line 3675
26900,26907c28622,28629
< #line 3086
<   goto ldv_52726;
<   ldv_52725: 
< #line 3087
<   tmp___0 = __fswab64(p->uuid[i]);
< #line 3087
<   *(p_uuid + (unsigned long )i) = tmp___0;
< #line 3086
---
> #line 3675
>   goto ldv_53512;
>   ldv_53511: 
> #line 3676
>   tmp___1 = __fswab64(p->uuid[i]);
> #line 3676
>   *(p_uuid + (unsigned long )i) = tmp___1;
> #line 3675
26909,26910c28631,28632
<   ldv_52726: ;
< #line 3086
---
>   ldv_53512: ;
> #line 3675
26912,26913c28634,28635
< #line 3087
<     goto ldv_52725;
---
> #line 3676
>     goto ldv_53511;
26917c28639
< #line 3089
---
> #line 3678
26919c28641
< #line 3090
---
> #line 3679
26921,26923c28643,28645
< #line 3092
<   if ((((int )mdev->state.ldv_40583.conn <= 9 && (int )mdev->state.ldv_40583.disk <= 3) && (unsigned int )*((unsigned char *)mdev + 2276UL) == 1U) && ((mdev->ed_uuid ^ *p_uuid) & 0xfffffffffffffffeULL) != 0ULL) {
< #line 3096
---
> #line 3681
>   if ((((int )mdev->state.ldv_50103.conn <= 9 && (int )mdev->state.ldv_50103.disk <= 3) && (unsigned int )*((unsigned char *)mdev + 748UL) == 1U) && ((mdev->ed_uuid ^ *p_uuid) & 0xfffffffffffffffeULL) != 0ULL) {
> #line 3685
26926c28648
< #line 3098
---
> #line 3687
26928,26930c28650,28652
< #line 3098
<     val.ldv_40583.conn = 1U;
< #line 3098
---
> #line 3687
>     val.ldv_40604.conn = 1U;
> #line 3687
26932,26937c28654,28659
< #line 3098
<     mask.ldv_40583.conn = 31U;
< #line 3098
<     drbd_force_state(mdev, mask, val);
< #line 3099
<     return (0);
---
> #line 3687
>     mask.ldv_40604.conn = 31U;
> #line 3687
>     conn_request_state(mdev->tconn, mask, val, CS_HARD);
> #line 3688
>     return (-5);
26941,26947c28663,28669
< #line 3102
<   tmp___1 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 3102
<   if (tmp___1 != 0) {
< #line 3103
<     skip_initial_sync = (((unsigned int )*((unsigned short *)mdev + 1138UL) == 160U && mdev->agreed_pro_version > 89) && (mdev->ldev)->md.uuid[0] == 4ULL) && (*(p_uuid + 5UL) & 8ULL) != 0ULL;
< #line 3108
---
> #line 3691
>   tmp___2 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 3691
>   if (tmp___2 != 0) {
> #line 3692
>     skip_initial_sync = (((unsigned int )*((unsigned short *)mdev + 374UL) == 160U && (mdev->tconn)->agreed_pro_version > 89) && (mdev->ldev)->md.uuid[0] == 4ULL) && (*(p_uuid + 5UL) & 8ULL) != 0ULL;
> #line 3697
26949c28671
< #line 3109
---
> #line 3698
26951c28673
< #line 3110
---
> #line 3699
26954c28676
< #line 3113
---
> #line 3702
26956c28678
< #line 3114
---
> #line 3703
26958,26964c28680,28686
< #line 3115
<       __ns.i = mdev->state.i;
< #line 3115
<       __ns.ldv_40583.disk = 8U;
< #line 3115
<       __ns.ldv_40583.pdsk = 8U;
< #line 3115
---
> #line 3704
>       __ns = drbd_read_state(mdev);
> #line 3704
>       __ns.ldv_40604.disk = 8U;
> #line 3704
>       __ns.ldv_40604.pdsk = 8U;
> #line 3704
26966c28688
< #line 3117
---
> #line 3706
26968c28690
< #line 3118
---
> #line 3707
26973c28695
< #line 3120
---
> #line 3709
26976,26978c28698,28700
< #line 3121
<   if ((int )mdev->state.ldv_40583.disk <= 3 && (unsigned int )*((unsigned char *)mdev + 2276UL) == 1U) {
< #line 3125
---
> #line 3710
>   if ((int )mdev->state.ldv_50103.disk <= 3 && (unsigned int )*((unsigned char *)mdev + 748UL) == 1U) {
> #line 3714
26983,27029c28705,28714
< #line 3132
<   tmp___2 = drbd_test_flag(mdev, CLUSTER_ST_CHANGE);
< #line 3132
<   if (tmp___2 == 0) {
< #line 3132
<     goto ldv_52735;
<   } else {
< 
<   }
< #line 3132
<   tmp___3 = get_current();
< #line 3132
<   __wait.flags = 0U;
< #line 3132
<   __wait.private = (void *)tmp___3;
< #line 3132
<   __wait.func = & autoremove_wake_function;
< #line 3132
<   __wait.task_list.next = & __wait.task_list;
< #line 3132
<   __wait.task_list.prev = & __wait.task_list;
<   ldv_52738: 
< #line 3132
<   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
< #line 3132
<   tmp___4 = drbd_test_flag(mdev, CLUSTER_ST_CHANGE);
< #line 3132
<   if (tmp___4 == 0) {
< #line 3132
<     goto ldv_52737;
<   } else {
< 
<   }
< #line 3132
<   schedule();
< #line 3132
<   goto ldv_52738;
<   ldv_52737: 
< #line 3132
<   finish_wait(& mdev->misc_wait, & __wait);
<   ldv_52735: ;
< #line 3133
<   if ((int )mdev->state.ldv_40583.conn > 9 && (int )mdev->state.ldv_40583.disk <= 3) {
< #line 3134
<     tmp___5 = drbd_set_ed_uuid(mdev, *p_uuid);
< #line 3134
<     updated_uuids = tmp___5 | updated_uuids;
---
> #line 3721
>   mutex_lock_nested(mdev->state_mutex, 0U);
> #line 3722
>   mutex_unlock(mdev->state_mutex);
> #line 3723
>   if ((int )mdev->state.ldv_50103.conn > 9 && (int )mdev->state.ldv_50103.disk <= 3) {
> #line 3724
>     tmp___3 = drbd_set_ed_uuid(mdev, *p_uuid);
> #line 3724
>     updated_uuids = tmp___3 | updated_uuids;
27033c28718
< #line 3136
---
> #line 3726
27035c28720
< #line 3137
---
> #line 3727
27040,27041c28725,28726
< #line 3139
<   return (1);
---
> #line 3729
>   return (0);
27044c28729
< #line 3146 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 3736 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
27051c28736
< #line 3150
---
> #line 3740
27053c28738
< #line 3150
---
> #line 3740
27055c28740
< #line 3150
---
> #line 3740
27057c28742
< #line 3150
---
> #line 3740
27059c28744
< #line 3150
---
> #line 3740
27061c28746
< #line 3150
---
> #line 3740
27063c28748
< #line 3150
---
> #line 3740
27065c28750
< #line 3150
---
> #line 3740
27067c28752
< #line 3150
---
> #line 3740
27069,27071c28754,28756
< #line 3150
<   c_tab[9] = 0;
< #line 3150
---
> #line 3740
>   c_tab[9] = C_WF_REPORT_PARAMS;
> #line 3740
27073c28758
< #line 3150
---
> #line 3740
27075c28760
< #line 3150
---
> #line 3740
27077c28762
< #line 3150
---
> #line 3740
27079c28764
< #line 3150
---
> #line 3740
27081c28766
< #line 3150
---
> #line 3740
27083c28768
< #line 3150
---
> #line 3740
27085c28770
< #line 3150
---
> #line 3740
27087c28772
< #line 3150
---
> #line 3740
27089c28774
< #line 3150
---
> #line 3740
27091c28776
< #line 3150
---
> #line 3740
27093c28778
< #line 3150
---
> #line 3740
27095c28780
< #line 3150
---
> #line 3740
27097c28782
< #line 3150
---
> #line 3740
27099c28784
< #line 3150
---
> #line 3740
27101c28786
< #line 3150
---
> #line 3740
27103c28788
< #line 3150
---
> #line 3740
27105c28790
< #line 3150
---
> #line 3740
27107c28792
< #line 3150
---
> #line 3740
27109c28794
< #line 3150
---
> #line 3740
27111c28796
< #line 3150
---
> #line 3740
27113c28798
< #line 3150
---
> #line 3740
27115c28800
< #line 3160
---
> #line 3751
27117,27129c28802,28814
< #line 3162
<   ms.ldv_40583.conn = (unsigned char )c_tab[(int )ps.ldv_40583.conn];
< #line 3163
<   ms.ldv_40583.peer = ps.ldv_40583.role;
< #line 3164
<   ms.ldv_40583.role = ps.ldv_40583.peer;
< #line 3165
<   ms.ldv_40583.pdsk = ps.ldv_40583.disk;
< #line 3166
<   ms.ldv_40583.disk = ps.ldv_40583.pdsk;
< #line 3167
<   ms.ldv_40583.peer_isp = (unsigned char )((int )ps.ldv_40583.aftr_isp | (int )ps.ldv_40583.user_isp);
< #line 3169
---
> #line 3753
>   ms.ldv_40604.conn = (unsigned char )c_tab[(int )ps.ldv_40604.conn];
> #line 3754
>   ms.ldv_40604.peer = ps.ldv_40604.role;
> #line 3755
>   ms.ldv_40604.role = ps.ldv_40604.peer;
> #line 3756
>   ms.ldv_40604.pdsk = ps.ldv_40604.disk;
> #line 3757
>   ms.ldv_40604.disk = ps.ldv_40604.pdsk;
> #line 3758
>   ms.ldv_40604.peer_isp = (unsigned char )((int )ps.ldv_40604.aftr_isp | (int )ps.ldv_40604.user_isp);
> #line 3760
27133,27134c28818,28819
< #line 3172 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_req_state(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 3763 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_req_state(struct drbd_tconn *tconn , struct packet_info *pi ) 
27135a28821
>   struct drbd_conf *mdev ;
27146,27148c28832,28843
< #line 3174
<   p = & mdev->data.rbuf.req_state;
< #line 3178
---
> #line 3766
>   p = (struct p_req_state *)pi->data;
> #line 3770
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 3771
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 3772
>     return (-5);
>   } else {
> 
>   }
> #line 3774
27150c28845
< #line 3178
---
> #line 3774
27152c28847
< #line 3179
---
> #line 3775
27154c28849
< #line 3179
---
> #line 3775
27156,27158c28851,28853
< #line 3181
<   tmp___1 = drbd_test_flag(mdev, DISCARD_CONCURRENT);
< #line 3181
---
> #line 3777
>   tmp___1 = constant_test_bit(1U, (unsigned long const volatile   *)(& (mdev->tconn)->flags));
> #line 3777
27160,27162c28855,28857
< #line 3181
<     tmp___2 = drbd_test_flag(mdev, CLUSTER_ST_CHANGE);
< #line 3181
---
> #line 3777
>     tmp___2 = mutex_is_locked(mdev->state_mutex);
> #line 3777
27164c28859
< #line 3183
---
> #line 3779
27166,27167c28861,28862
< #line 3184
<       return (1);
---
> #line 3780
>       return (0);
27174c28869
< #line 3187
---
> #line 3783
27176c28871
< #line 3188
---
> #line 3784
27178c28873
< #line 3190
---
> #line 3786
27180c28875
< #line 3192
---
> #line 3787
27182c28877
< #line 3193
---
> #line 3789
27184,27185c28879,28933
< #line 3195
<   return (1);
---
> #line 3791
>   return (0);
> }
> }
> #line 3794 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_req_conn_state(struct drbd_tconn *tconn , struct packet_info *pi ) 
> { 
>   struct p_req_state *p ;
>   union drbd_state mask ;
>   union drbd_state val ;
>   enum drbd_state_rv rv ;
>   __u32 tmp ;
>   __u32 tmp___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
> 
>   {
> #line 3796
>   p = (struct p_req_state *)pi->data;
> #line 3800
>   tmp = __fswab32(p->mask);
> #line 3800
>   mask.i = tmp;
> #line 3801
>   tmp___0 = __fswab32(p->val);
> #line 3801
>   val.i = tmp___0;
> #line 3803
>   tmp___1 = constant_test_bit(1U, (unsigned long const volatile   *)(& tconn->flags));
> #line 3803
>   if (tmp___1 != 0) {
> #line 3803
>     tmp___2 = mutex_is_locked(& tconn->cstate_mutex);
> #line 3803
>     if (tmp___2 != 0) {
> #line 3805
>       conn_send_sr_reply(tconn, SS_CONCURRENT_ST_CHG);
> #line 3806
>       return (0);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 3809
>   mask = convert_state(mask);
> #line 3810
>   val = convert_state(val);
> #line 3812
>   rv = conn_request_state(tconn, mask, val, 2066);
> #line 3813
>   conn_send_sr_reply(tconn, rv);
> #line 3815
>   return (0);
27188,27189c28936,28937
< #line 3198 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_state(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 3818 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_state(struct drbd_tconn *tconn , struct packet_info *pi ) 
27190a28939
>   struct drbd_conf *mdev ;
27198,27200c28947,28950
<   __u32 tmp ;
<   char const   *tmp___0 ;
<   unsigned long tmp___1 ;
---
>   int tmp ;
>   __u32 tmp___0 ;
>   char const   *tmp___1 ;
>   unsigned long tmp___2 ;
27202,27203c28952,28953
<   int tmp___2 ;
<   enum drbd_conns tmp___3 ;
---
>   int tmp___3 ;
>   enum drbd_conns tmp___4 ;
27206c28956
<   int tmp___4 ;
---
>   int tmp___5 ;
27209c28959,28960
<   int tmp___5 ;
---
>   int tmp___6 ;
>   union drbd_state tmp___7 ;
27212,27214c28963,28965
<   int tmp___6 ;
<   int tmp___7 ;
<   enum drbd_state_rv tmp___8 ;
---
>   int tmp___8 ;
>   int tmp___9 ;
>   enum drbd_state_rv tmp___10 ;
27219,27227c28970,28989
< #line 3200
<   p = & mdev->data.rbuf.state;
< #line 3206
<   tmp = __fswab32(p->state);
< #line 3206
<   peer_state.i = tmp;
< #line 3208
<   real_peer_disk = (enum drbd_disk_state )peer_state.ldv_40583.disk;
< #line 3209
---
> #line 3821
>   p = (struct p_state *)pi->data;
> #line 3827
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 3828
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 3829
>     tmp = config_unknown_volume(tconn, pi);
> #line 3829
>     return (tmp);
>   } else {
> 
>   }
> #line 3831
>   tmp___0 = __fswab32(p->state);
> #line 3831
>   peer_state.i = tmp___0;
> #line 3833
>   real_peer_disk = (enum drbd_disk_state )peer_state.ldv_40604.disk;
> #line 3834
27229c28991
< #line 3210
---
> #line 3835
27231,27233c28993,28995
< #line 3211
<     tmp___0 = drbd_disk_str(real_peer_disk);
< #line 3211
---
> #line 3836
>     tmp___1 = drbd_disk_str(real_peer_disk);
> #line 3836
27235c28997
<               tmp___0);
---
>               tmp___1);
27239,27240c29001,29002
< #line 3214
<   spin_lock_irq(& mdev->req_lock);
---
> #line 3839
>   spin_lock_irq(& (mdev->tconn)->req_lock);
27242,27244c29004,29006
< #line 3216
<   ns = mdev->state;
< #line 3216
---
> #line 3841
>   ns = drbd_read_state(mdev);
> #line 3841
27246,27251c29008,29013
< #line 3217
<   spin_unlock_irq(& mdev->req_lock);
< #line 3222
<   if ((int )os.ldv_40583.conn <= 7) {
< #line 3223
<     return (0);
---
> #line 3842
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 3847
>   if ((int )os.ldv_40604.conn <= 7) {
> #line 3848
>     return (-104);
27255,27259c29017,29021
< #line 3231
<   if ((((*((unsigned int *)(& os) + 0UL) == 32768U || *((unsigned int *)(& os) + 0UL) == 57344U) && (unsigned int )real_peer_disk == 8U) && (int )os.ldv_40583.conn > 10) && (unsigned int )*((unsigned char *)(& os) + 1UL) == 16U) {
< #line 3240
<     if ((int )peer_state.ldv_40583.conn > 10 && (int )peer_state.ldv_40583.conn <= 15) {
< #line 3242
---
> #line 3856
>   if ((((*((unsigned int *)(& os) + 0UL) == 32768U || *((unsigned int *)(& os) + 0UL) == 57344U) && (unsigned int )real_peer_disk == 8U) && (int )os.ldv_40604.conn > 10) && (unsigned int )*((unsigned char *)(& os) + 1UL) == 16U) {
> #line 3865
>     if ((int )peer_state.ldv_40604.conn > 10 && (int )peer_state.ldv_40604.conn <= 15) {
> #line 3867
27262,27268c29024,29030
< #line 3247
<     if ((int )os.ldv_40583.conn > 15 && (unsigned int )*((unsigned short *)(& peer_state) + 0UL) == 160U) {
< #line 3249
<       tmp___1 = drbd_bm_total_weight(mdev);
< #line 3249
<       if (tmp___1 <= mdev->rs_failed) {
< #line 3250
---
> #line 3872
>     if ((int )os.ldv_40604.conn > 15 && (unsigned int )*((unsigned short *)(& peer_state) + 0UL) == 160U) {
> #line 3874
>       tmp___2 = drbd_bm_total_weight(mdev);
> #line 3874
>       if (tmp___2 <= mdev->rs_failed) {
> #line 3875
27273,27274c29035,29036
< #line 3251
<       return (1);
---
> #line 3876
>       return (0);
27281c29043
< #line 3256
---
> #line 3881
27283,27285c29045,29047
< #line 3258
<     ov_oos_print(mdev);
< #line 3259
---
> #line 3883
>     ov_out_of_sync_print(mdev);
> #line 3884
27287,27288c29049,29050
< #line 3260
<     return (1);
---
> #line 3885
>     return (0);
27292,27294c29054,29056
< #line 3268
<   if (((*((unsigned int *)(& os) + 0UL) == 65536U && (unsigned int )real_peer_disk == 4U) && (unsigned int )*((unsigned short *)(& os) + 0UL) == 160U) && (int )peer_state.ldv_40583.conn > 16) {
< #line 3270
---
> #line 3893
>   if (((*((unsigned int *)(& os) + 0UL) == 65536U && (unsigned int )real_peer_disk == 4U) && (unsigned int )*((unsigned short *)(& os) + 0UL) == 160U) && (int )peer_state.ldv_40604.conn > 16) {
> #line 3895
27299c29061
< #line 3272
---
> #line 3897
27301,27302c29063,29064
< #line 3273
<     ns.ldv_40583.conn = 10U;
---
> #line 3898
>     ns.ldv_40604.conn = 10U;
27306c29068
< #line 3275
---
> #line 3900
27308,27309c29070,29071
< #line 3276
<     ns.ldv_40583.conn = 23U;
---
> #line 3901
>     ns.ldv_40604.conn = 23U;
27313,27321c29075,29083
< #line 3278
<   if ((unsigned long )mdev->p_uuid != (unsigned long )((u64 *)0) && (int )peer_state.ldv_40583.disk > 2) {
< #line 3278
<     tmp___5 = _get_ldev_if_state(mdev, D_NEGOTIATING);
< #line 3278
<     if (tmp___5 != 0) {
< #line 3283
<       cr = (int )os.ldv_40583.conn <= 9;
< #line 3286
---
> #line 3903
>   if ((unsigned long )mdev->p_uuid != (unsigned long )((u64 *)0) && (int )peer_state.ldv_40604.disk > 2) {
> #line 3903
>     tmp___6 = _get_ldev_if_state(mdev, D_NEGOTIATING);
> #line 3903
>     if (tmp___6 != 0) {
> #line 3908
>       cr = (int )os.ldv_40604.conn <= 9;
> #line 3911
27323,27329c29085,29091
< #line 3291
<       tmp___2 = drbd_test_flag(mdev, CONSIDER_RESYNC);
< #line 3291
<       cr = tmp___2 | cr;
< #line 3294
<       cr = ((unsigned int )*((unsigned short *)(& os) + 0UL) == 160U && ((int )peer_state.ldv_40583.conn > 10 && (int )peer_state.ldv_40583.conn <= 14)) | cr;
< #line 3298
---
> #line 3916
>       tmp___3 = constant_test_bit(6U, (unsigned long const volatile   *)(& mdev->flags));
> #line 3916
>       cr = tmp___3 | cr;
> #line 3919
>       cr = ((unsigned int )*((unsigned short *)(& os) + 0UL) == 160U && ((int )peer_state.ldv_40604.conn > 10 && (int )peer_state.ldv_40604.conn <= 14)) | cr;
> #line 3923
27331,27332c29093,29094
< #line 3299
<         tmp___3 = drbd_sync_handshake(mdev, (enum drbd_role )peer_state.ldv_40583.role,
---
> #line 3924
>         tmp___4 = drbd_sync_handshake(mdev, (enum drbd_role )peer_state.ldv_40604.role,
27334,27335c29096,29097
< #line 3299
<         ns.ldv_40583.conn = (unsigned char )tmp___3;
---
> #line 3924
>         ns.ldv_40604.conn = (unsigned char )tmp___4;
27339c29101
< #line 3301
---
> #line 3926
27341c29103
< #line 3302
---
> #line 3927
27343,27347c29105,29109
< #line 3303
<         ns.ldv_40583.conn = 10U;
< #line 3304
<         if ((unsigned int )*((unsigned char *)mdev + 2277UL) == 6U) {
< #line 3305
---
> #line 3928
>         ns.ldv_40604.conn = 10U;
> #line 3929
>         if ((unsigned int )*((unsigned char *)mdev + 749UL) == 6U) {
> #line 3930
27349,27351c29111,29113
< #line 3305
<           val.ldv_40583.disk = 2U;
< #line 3305
---
> #line 3930
>           val.ldv_40604.disk = 2U;
> #line 3930
27353,27355c29115,29117
< #line 3305
<           mask.ldv_40583.disk = 15U;
< #line 3305
---
> #line 3930
>           mask.ldv_40604.disk = 15U;
> #line 3930
27358c29120
< #line 3306
---
> #line 3931
27360c29122
< #line 3307
---
> #line 3932
27362,27364c29124,29126
< #line 3308
<           peer_state.ldv_40583.disk = 0U;
< #line 3309
---
> #line 3933
>           peer_state.ldv_40604.disk = 0U;
> #line 3934
27367,27372c29129,29134
< #line 3311
<           tmp___4 = drbd_test_and_clear_flag(mdev, CONN_DRY_RUN);
< #line 3311
<           if (tmp___4 != 0) {
< #line 3312
<             return (0);
---
> #line 3936
>           tmp___5 = test_and_clear_bit(8, (unsigned long volatile   *)(& (mdev->tconn)->flags));
> #line 3936
>           if (tmp___5 != 0) {
> #line 3937
>             return (-5);
27376c29138
< #line 3313
---
> #line 3938
27378c29140
< #line 3313
---
> #line 3938
27380,27381c29142,29143
<                     (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                     3313);
---
>                     (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                     3938);
27385c29147
< #line 3314
---
> #line 3939
27387,27389c29149,29151
< #line 3314
<           val___0.ldv_40583.conn = 1U;
< #line 3314
---
> #line 3939
>           val___0.ldv_40604.conn = 1U;
> #line 3939
27391,27396c29153,29158
< #line 3314
<           mask___0.ldv_40583.conn = 31U;
< #line 3314
<           drbd_force_state(mdev, mask___0, val___0);
< #line 3315
<           return (0);
---
> #line 3939
>           mask___0.ldv_40604.conn = 31U;
> #line 3939
>           conn_request_state(mdev->tconn, mask___0, val___0, CS_HARD);
> #line 3940
>           return (-5);
27407,27411c29169,29175
< #line 3320
<   spin_lock_irq(& mdev->req_lock);
< #line 3321
<   if (mdev->state.i != os.i) {
< #line 3322
---
> #line 3945
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 3946
>   tmp___7 = drbd_read_state(mdev);
> #line 3946
>   if (os.i != tmp___7.i) {
> #line 3947
27416,27424c29180,29188
< #line 3323
<   drbd_clear_flag(mdev, CONSIDER_RESYNC);
< #line 3324
<   ns.ldv_40583.peer = peer_state.ldv_40583.role;
< #line 3325
<   ns.ldv_40583.pdsk = (unsigned char )real_peer_disk;
< #line 3326
<   ns.ldv_40583.peer_isp = (unsigned char )((int )peer_state.ldv_40583.aftr_isp | (int )peer_state.ldv_40583.user_isp);
< #line 3327
---
> #line 3948
>   clear_bit(6, (unsigned long volatile   *)(& mdev->flags));
> #line 3949
>   ns.ldv_40604.peer = peer_state.ldv_40604.role;
> #line 3950
>   ns.ldv_40604.pdsk = (unsigned char )real_peer_disk;
> #line 3951
>   ns.ldv_40604.peer_isp = (unsigned char )((int )peer_state.ldv_40604.aftr_isp | (int )peer_state.ldv_40604.user_isp);
> #line 3952
27426,27427c29190,29191
< #line 3328
<     ns.ldv_40583.disk = mdev->new_state_tmp.ldv_40583.disk;
---
> #line 3953
>     ns.ldv_40604.disk = mdev->new_state_tmp.ldv_40604.disk;
27431,27433c29195,29197
< #line 3329
<   cs_flags = (enum chg_state_flags )(((int )os.ldv_40583.conn > 9 || (int )ns.ldv_40583.conn <= 9) + 2);
< #line 3330
---
> #line 3954
>   cs_flags = (enum chg_state_flags )(((int )os.ldv_40604.conn > 9 || (int )ns.ldv_40604.conn <= 9) + 2);
> #line 3955
27435,27439c29199,29203
< #line 3330
<     tmp___6 = is_susp(ns);
< #line 3330
<     if (tmp___6 != 0) {
< #line 3330
---
> #line 3955
>     tmp___8 = drbd_suspended(mdev);
> #line 3955
>     if (tmp___8 != 0) {
> #line 3955
27441,27449c29205,29213
< #line 3330
<         if ((int )os.ldv_40583.conn <= 9) {
< #line 3330
<           tmp___7 = drbd_test_flag(mdev, NEW_CUR_UUID);
< #line 3330
<           if (tmp___7 != 0) {
< #line 3334
<             spin_unlock_irq(& mdev->req_lock);
< #line 3335
---
> #line 3955
>         if ((int )os.ldv_40604.conn <= 9) {
> #line 3955
>           tmp___9 = constant_test_bit(17U, (unsigned long const volatile   *)(& mdev->flags));
> #line 3955
>           if (tmp___9 != 0) {
> #line 3959
>             spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 3960
27451,27453c29215,29217
< #line 3336
<             tl_clear(mdev);
< #line 3337
---
> #line 3961
>             tl_clear(mdev->tconn);
> #line 3962
27455,27457c29219,29221
< #line 3338
<             drbd_clear_flag(mdev, NEW_CUR_UUID);
< #line 3339
---
> #line 3963
>             clear_bit(17, (unsigned long volatile   *)(& mdev->flags));
> #line 3964
27459,27463c29223,29227
< #line 3339
<             val___1.ldv_40583.conn = 6U;
< #line 3339
<             val___1.ldv_40583.susp = 0U;
< #line 3339
---
> #line 3964
>             val___1.ldv_40604.conn = 6U;
> #line 3964
>             val___1.ldv_40604.susp = 0U;
> #line 3964
27465,27472c29229,29236
< #line 3339
<             mask___1.ldv_40583.conn = 31U;
< #line 3339
<             mask___1.ldv_40583.susp = 1U;
< #line 3339
<             drbd_force_state(mdev, mask___1, val___1);
< #line 3340
<             return (0);
---
> #line 3964
>             mask___1.ldv_40604.conn = 31U;
> #line 3964
>             mask___1.ldv_40604.susp = 1U;
> #line 3964
>             conn_request_state(mdev->tconn, mask___1, val___1, CS_HARD);
> #line 3965
>             return (-5);
27488,27496c29252,29260
< #line 3342
<   tmp___8 = _drbd_set_state(mdev, ns, cs_flags, 0);
< #line 3342
<   rv = (int )tmp___8;
< #line 3343
<   ns = mdev->state;
< #line 3344
<   spin_unlock_irq(& mdev->req_lock);
< #line 3346
---
> #line 3967
>   tmp___10 = _drbd_set_state(mdev, ns, cs_flags, 0);
> #line 3967
>   rv = (int )tmp___10;
> #line 3968
>   ns = drbd_read_state(mdev);
> #line 3969
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 3971
27498c29262
< #line 3347
---
> #line 3972
27500,27502c29264,29266
< #line 3347
<     val___2.ldv_40583.conn = 1U;
< #line 3347
---
> #line 3972
>     val___2.ldv_40604.conn = 1U;
> #line 3972
27504,27509c29268,29273
< #line 3347
<     mask___2.ldv_40583.conn = 31U;
< #line 3347
<     drbd_force_state(mdev, mask___2, val___2);
< #line 3348
<     return (0);
---
> #line 3972
>     mask___2.ldv_40604.conn = 31U;
> #line 3972
>     conn_request_state(mdev->tconn, mask___2, val___2, CS_HARD);
> #line 3973
>     return (-5);
27513,27517c29277,29281
< #line 3351
<   if ((int )os.ldv_40583.conn > 9) {
< #line 3352
<     if (((int )ns.ldv_40583.conn > 10 && (int )peer_state.ldv_40583.conn <= 10) && (unsigned int )*((unsigned char *)(& peer_state) + 1UL) != 6U) {
< #line 3357
---
> #line 3976
>   if ((int )os.ldv_40604.conn > 9) {
> #line 3977
>     if (((int )ns.ldv_40604.conn > 10 && (int )peer_state.ldv_40604.conn <= 10) && (unsigned int )*((unsigned char *)(& peer_state) + 1UL) != 6U) {
> #line 3982
27519c29283
< #line 3358
---
> #line 3983
27527,27529c29291,29293
< #line 3362
<   (mdev->net_conf)->want_lose = 0U;
< #line 3364
---
> #line 3987
>   clear_bit(21, (unsigned long volatile   *)(& mdev->flags));
> #line 3989
27531,27532c29295,29296
< #line 3366
<   return (1);
---
> #line 3991
>   return (0);
27535,27536c29299,29300
< #line 3369 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_sync_uuid(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 3994 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_sync_uuid(struct drbd_tconn *tconn , struct packet_info *pi ) 
27537a29302
>   struct drbd_conf *mdev ;
27545,27550c29310,29317
< #line 3371
<   p = & mdev->data.rbuf.rs_uuid;
< #line 3373
<   if ((((unsigned int )*((unsigned short *)mdev + 1138UL) == 240U || (unsigned int )*((unsigned short *)mdev + 1138UL) == 368U) || (int )mdev->state.ldv_40583.conn <= 9) || (int )mdev->state.ldv_40583.disk <= 2) {
< #line 3373
<     goto ldv_52789;
---
> #line 3997
>   p = (struct p_rs_uuid *)pi->data;
> #line 3999
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 4000
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 4001
>     return (-5);
27554c29321,29328
< #line 3373
---
> #line 4003
>   if ((((unsigned int )*((unsigned short *)mdev + 374UL) == 240U || (unsigned int )*((unsigned short *)mdev + 374UL) == 368U) || (int )mdev->state.ldv_50103.conn <= 9) || (int )mdev->state.ldv_50103.disk <= 2) {
> #line 4003
>     goto ldv_53579;
>   } else {
> 
>   }
> #line 4003
27556c29330
< #line 3373
---
> #line 4003
27558c29332
< #line 3373
---
> #line 4003
27560c29334
< #line 3373
---
> #line 4003
27562c29336
< #line 3373
---
> #line 4003
27564c29338
< #line 3373
---
> #line 4003
27566,27567c29340,29341
<   ldv_52792: 
< #line 3373
---
>   ldv_53582: 
> #line 4003
27569,27572c29343,29346
< #line 3373
<   if ((((unsigned int )*((unsigned short *)mdev + 1138UL) == 240U || (unsigned int )*((unsigned short *)mdev + 1138UL) == 368U) || (int )mdev->state.ldv_40583.conn <= 9) || (int )mdev->state.ldv_40583.disk <= 2) {
< #line 3373
<     goto ldv_52791;
---
> #line 4003
>   if ((((unsigned int )*((unsigned short *)mdev + 374UL) == 240U || (unsigned int )*((unsigned short *)mdev + 374UL) == 368U) || (int )mdev->state.ldv_50103.conn <= 9) || (int )mdev->state.ldv_50103.disk <= 2) {
> #line 4003
>     goto ldv_53581;
27576c29350
< #line 3373
---
> #line 4003
27578,27581c29352,29355
< #line 3373
<   goto ldv_52792;
<   ldv_52791: 
< #line 3373
---
> #line 4003
>   goto ldv_53582;
>   ldv_53581: 
> #line 4003
27583,27584c29357,29358
<   ldv_52789: 
< #line 3383
---
>   ldv_53579: 
> #line 4013
27586c29360
< #line 3383
---
> #line 4013
27588c29362
< #line 3384
---
> #line 4014
27590c29364
< #line 3384
---
> #line 4014
27592c29366
< #line 3385
---
> #line 4015
27594c29368
< #line 3387
---
> #line 4017
27596c29370
< #line 3388
---
> #line 4018
27598c29372
< #line 3390
---
> #line 4020
27601c29375
< #line 3392
---
> #line 4022
27604,27605c29378,29379
< #line 3394
<   return (1);
---
> #line 4024
>   return (0);
27608,27610c29382,29384
< #line 3404 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_bitmap_plain(struct drbd_conf *mdev , unsigned int data_size ,
<                                 unsigned long *buffer , struct bm_xfer_ctx *c ) 
---
> #line 4034 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_bitmap_plain(struct drbd_conf *mdev , unsigned int size , unsigned long *p ,
>                                 struct bm_xfer_ctx *c ) 
27611a29386,29387
>   unsigned int data_size ;
>   unsigned int tmp ;
27619,27621c29395,29401
< #line 3407
<   __min1 = 511UL;
< #line 3407
---
> #line 4037
>   tmp = drbd_header_size(mdev->tconn);
> #line 4037
>   data_size = 4096U - tmp;
> #line 4039
>   __min1 = (unsigned long )(data_size / 8U);
> #line 4039
27623c29403
< #line 3407
---
> #line 4039
27625c29405
< #line 3408
---
> #line 4041
27627,27632c29407,29412
< #line 3411
<   if (want != data_size) {
< #line 3412
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s:want (%u) != data_size (%u)\n",
<             "receive_bitmap_plain", want, data_size);
< #line 3413
---
> #line 4044
>   if (want != size) {
> #line 4045
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s:want (%u) != size (%u)\n",
>             "receive_bitmap_plain", want, size);
> #line 4046
27637c29417
< #line 3415
---
> #line 4048
27639c29419
< #line 3416
---
> #line 4049
27644,27655c29424,29428
< #line 3417
<   err = drbd_recv(mdev, (void *)buffer, (size_t )want);
< #line 3418
<   if ((unsigned int )err != want) {
< #line 3419
<     if (err >= 0) {
< #line 3420
<       err = -5;
<     } else {
< 
<     }
< #line 3421
---
> #line 4050
>   err = drbd_recv_all(mdev->tconn, (void *)p, (size_t )want);
> #line 4051
>   if (err != 0) {
> #line 4052
27660,27662c29433,29435
< #line 3424
<   drbd_bm_merge_lel(mdev, c->word_offset, (size_t )num_words, buffer);
< #line 3426
---
> #line 4054
>   drbd_bm_merge_lel(mdev, c->word_offset, (size_t )num_words, p);
> #line 4056
27664c29437
< #line 3427
---
> #line 4057
27666c29439
< #line 3428
---
> #line 4058
27668c29441
< #line 3429
---
> #line 4059
27673c29446
< #line 3431
---
> #line 4061
27677,27678c29450,29482
< #line 3441 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int recv_bm_rle_bits(struct drbd_conf *mdev , struct p_compressed_bm *p , struct bm_xfer_ctx *c ) 
---
> #line 4064 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static enum drbd_bitmap_code dcbp_get_code(struct p_compressed_bm *p ) 
> { 
> 
> 
>   {
> #line 4066
>   return ((enum drbd_bitmap_code )((int )p->encoding & 15));
> }
> }
> #line 4069 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int dcbp_get_start(struct p_compressed_bm *p ) 
> { 
> 
> 
>   {
> #line 4071
>   return ((int )((signed char )p->encoding) < 0);
> }
> }
> #line 4074 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int dcbp_get_pad_bits(struct p_compressed_bm *p ) 
> { 
> 
> 
>   {
> #line 4076
>   return (((int )p->encoding >> 4) & 7);
> }
> }
> #line 4086 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int recv_bm_rle_bits(struct drbd_conf *mdev , struct p_compressed_bm *p , struct bm_xfer_ctx *c ,
>                             unsigned int len ) 
27686,27687d29489
<   int len ;
<   __u16 tmp___0 ;
27689c29491
<   int tmp___1 ;
---
>   int tmp___0 ;
27692c29494
<   int tmp___2 ;
---
>   int tmp___1 ;
27695c29497
< #line 3449
---
> #line 4095
27697,27709c29499,29507
< #line 3451
<   tmp___0 = __fswab16((int )p->head.length);
< #line 3451
<   len = (int )((unsigned int )tmp___0 - 1U);
< #line 3452
<   tmp___1 = DCBP_get_start(p);
< #line 3452
<   toggle = tmp___1;
< #line 3456
<   tmp___2 = DCBP_get_pad_bits(p);
< #line 3456
<   bitstream_init(& bs, (void *)(& p->code), (size_t )len, (unsigned int )tmp___2);
< #line 3458
---
> #line 4097
>   tmp___0 = dcbp_get_start(p);
> #line 4097
>   toggle = tmp___0;
> #line 4101
>   tmp___1 = dcbp_get_pad_bits(p);
> #line 4101
>   bitstream_init(& bs, (void *)(& p->code), (size_t )len, (unsigned int )tmp___1);
> #line 4103
27711c29509
< #line 3459
---
> #line 4104
27713c29511
< #line 3460
---
> #line 4105
27718c29516
< #line 3462
---
> #line 4107
27720,27723c29518,29521
< #line 3462
<   goto ldv_52822;
<   ldv_52821: 
< #line 3463
---
> #line 4107
>   goto ldv_53622;
>   ldv_53621: 
> #line 4108
27725c29523
< #line 3464
---
> #line 4109
27727c29525
< #line 3465
---
> #line 4110
27732c29530
< #line 3467
---
> #line 4112
27734c29532
< #line 3468
---
> #line 4113
27736c29534
< #line 3469
---
> #line 4114
27738c29536
< #line 3470
---
> #line 4115
27741c29539
< #line 3471
---
> #line 4116
27746c29544
< #line 3473
---
> #line 4118
27751c29549
< #line 3476
---
> #line 4121
27753c29551
< #line 3477
---
> #line 4122
27757c29555
< #line 3481
---
> #line 4126
27762c29560
< #line 3483
---
> #line 4128
27764c29562
< #line 3484
---
> #line 4129
27766c29564
< #line 3486
---
> #line 4131
27768c29566
< #line 3487
---
> #line 4132
27770c29568
< #line 3488
---
> #line 4133
27775c29573
< #line 3489
---
> #line 4134
27777c29575
< #line 3490
---
> #line 4135
27779c29577
< #line 3462
---
> #line 4107
27781c29579
< #line 3462
---
> #line 4107
27783,27784c29581,29582
<   ldv_52822: ;
< #line 3462
---
>   ldv_53622: ;
> #line 4107
27786,27787c29584,29585
< #line 3463
<     goto ldv_52821;
---
> #line 4108
>     goto ldv_53621;
27791c29589
< #line 3493
---
> #line 4138
27793c29591
< #line 3494
---
> #line 4139
27795c29593
< #line 3496
---
> #line 4141
27799,27800c29597,29599
< #line 3506 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int decode_bitmap_c(struct drbd_conf *mdev , struct p_compressed_bm *p , struct bm_xfer_ctx *c ) 
---
> #line 4151 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int decode_bitmap_c(struct drbd_conf *mdev , struct p_compressed_bm *p , struct bm_xfer_ctx *c ,
>                            unsigned int len ) 
27808,27810c29607,29609
< #line 3510
<   tmp___0 = DCBP_get_code(p);
< #line 3510
---
> #line 4156
>   tmp___0 = dcbp_get_code(p);
> #line 4156
27812,27814c29611,29613
< #line 3511
<     tmp = recv_bm_rle_bits(mdev, p, c);
< #line 3511
---
> #line 4157
>     tmp = recv_bm_rle_bits(mdev, p, c, len - 1U);
> #line 4157
27819c29618
< #line 3517
---
> #line 4163
27822c29621
< #line 3518
---
> #line 4164
27824,27826c29623,29625
< #line 3518
<   val.ldv_40583.conn = 6U;
< #line 3518
---
> #line 4164
>   val.ldv_40604.conn = 6U;
> #line 4164
27828,27832c29627,29631
< #line 3518
<   mask.ldv_40583.conn = 31U;
< #line 3518
<   drbd_force_state(mdev, mask, val);
< #line 3519
---
> #line 4164
>   mask.ldv_40604.conn = 31U;
> #line 4164
>   conn_request_state(mdev->tconn, mask, val, CS_HARD);
> #line 4165
27836c29635
< #line 3522 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 4168 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
27838a29638,29640
>   unsigned int header_size ;
>   unsigned int tmp ;
>   unsigned int data_size ;
27844,27846c29646,29654
< #line 3526
<   plain = (unsigned int )(((c->bm_words + 510UL) / 511UL + c->bm_words) + 1UL) * 8U;
< #line 3529
---
> #line 4172
>   tmp = drbd_header_size(mdev->tconn);
> #line 4172
>   header_size = tmp;
> #line 4173
>   data_size = 4096U - header_size;
> #line 4174
>   plain = (unsigned int )(((c->bm_words + (unsigned long )data_size) - 1UL) / (unsigned long )data_size + 1UL) * header_size + (unsigned int )c->bm_words * 8U;
> #line 4177
27848c29656
< #line 3533
---
> #line 4181
27850c29658
< #line 3534
---
> #line 4182
27855c29663
< #line 3537
---
> #line 4185
27857c29665
< #line 3538
---
> #line 4186
27862c29670
< #line 3541
---
> #line 4189
27864c29672
< #line 3544
---
> #line 4192
27866c29674
< #line 3545
---
> #line 4193
27871c29679
< #line 3547
---
> #line 4195
27873c29681
< #line 3548
---
> #line 4196
27877c29685
< #line 3549
---
> #line 4197
27881,27882c29689,29690
< #line 3564 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_bitmap(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 4212 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_bitmap(struct drbd_tconn *tconn , struct packet_info *pi ) 
27883a29692
>   struct drbd_conf *mdev ;
27885d29693
<   void *buffer ;
27887,27889d29694
<   int ok ;
<   struct p_header80 *h ;
<   unsigned long tmp ;
27891,27892c29696,29697
<   unsigned long tmp___0 ;
<   size_t tmp___1 ;
---
>   unsigned long tmp ;
>   size_t tmp___0 ;
27894,27897c29699,29700
<   size_t __len ;
<   void *__ret ;
<   int tmp___2 ;
<   int tmp___3 ;
---
>   unsigned int tmp___1 ;
>   unsigned int tmp___2 ;
27899d29701
<   int tmp___4 ;
27902c29704
<   char const   *tmp___5 ;
---
>   char const   *tmp___3 ;
27905,27921c29707,29712
< #line 3569
<   ok = 0;
< #line 3570
<   h = & mdev->data.rbuf.header.h80;
< #line 3572
<   drbd_bm_lock(mdev, (char *)"receive bitmap", BM_LOCKED_SET_ALLOWED);
< #line 3578
<   tmp = __get_free_pages(16U, 0U);
< #line 3578
<   buffer = (void *)tmp;
< #line 3579
<   if ((unsigned long )buffer == (unsigned long )((void *)0)) {
< #line 3580
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "failed to allocate one page buffer in %s\n",
<             "receive_bitmap");
< #line 3581
<     goto out;
---
> #line 4218
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 4219
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 4220
>     return (-5);
27925,27933c29716,29726
< #line 3584
<   tmp___0 = drbd_bm_bits(mdev);
< #line 3584
<   tmp___1 = drbd_bm_words(mdev);
< #line 3584
<   __constr_expr_0.bm_bits = tmp___0;
< #line 3584
<   __constr_expr_0.bm_words = tmp___1;
< #line 3584
---
> #line 4222
>   drbd_bm_lock(mdev, (char *)"receive bitmap", BM_LOCKED_SET_ALLOWED);
> #line 4226
>   tmp = drbd_bm_bits(mdev);
> #line 4226
>   tmp___0 = drbd_bm_words(mdev);
> #line 4226
>   __constr_expr_0.bm_bits = tmp;
> #line 4226
>   __constr_expr_0.bm_words = tmp___0;
> #line 4226
27935c29728
< #line 3584
---
> #line 4226
27937c29730
< #line 3584
---
> #line 4226
27939c29732
< #line 3584
---
> #line 4226
27941c29734
< #line 3584
---
> #line 4226
27943c29736
< #line 3584
---
> #line 4226
27945c29738
< #line 3584
---
> #line 4226
27947,27951c29740,29744
<   ldv_52859: ;
< #line 3590
<   if ((unsigned int )cmd == 4U) {
< #line 3591
<     err = receive_bitmap_plain(mdev, data_size, (unsigned long *)buffer, & c);
---
>   ldv_53655: ;
> #line 4232
>   if ((unsigned int )pi->cmd == 4U) {
> #line 4233
>     err = receive_bitmap_plain(mdev, pi->size, (unsigned long *)pi->data, & c);
27953,27957c29746,29754
< #line 3592
<   if ((unsigned int )cmd == 36U) {
< #line 3597
<     if (data_size > 4088U) {
< #line 3598
---
> #line 4234
>   if ((unsigned int )pi->cmd == 36U) {
> #line 4237
>     p = (struct p_compressed_bm *)pi->data;
> #line 4239
>     tmp___1 = drbd_header_size(tconn);
> #line 4239
>     if (pi->size > 4096U - tmp___1) {
> #line 4240
27959c29756,29758
< #line 3599
---
> #line 4241
>       err = -5;
> #line 4242
27964,27980c29763,29770
< #line 3602
<     p = (struct p_compressed_bm *)buffer;
< #line 3603
<     __len = 8UL;
< #line 3603
<     if (__len > 63UL) {
< #line 3603
<       __ret = __memcpy((void *)p, (void const   *)h, __len);
<     } else {
< #line 3603
<       __ret = __builtin_memcpy((void *)p, (void const   *)h, __len);
<     }
< #line 3604
<     tmp___2 = drbd_recv(mdev, (void *)(& p->head.payload), (size_t )data_size);
< #line 3604
<     if ((unsigned int )tmp___2 != data_size) {
< #line 3605
---
> #line 4244
>     if (pi->size <= 1U) {
> #line 4245
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ReportCBitmap packet too small (l:%u)\n",
>               pi->size);
> #line 4246
>       err = -5;
> #line 4247
27985,27990c29775,29779
< #line 3606
<     if (data_size <= 1U) {
< #line 3607
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ReportCBitmap packet too small (l:%u)\n",
<               data_size);
< #line 3608
---
> #line 4249
>     err = drbd_recv_all(mdev->tconn, (void *)p, (size_t )pi->size);
> #line 4250
>     if (err != 0) {
> #line 4251
27995,27996c29784,29785
< #line 3610
<     err = decode_bitmap_c(mdev, p, & c);
---
> #line 4252
>     err = decode_bitmap_c(mdev, p, & c, pi->size);
27998c29787
< #line 3612
---
> #line 4254
28000,28001c29789,29792
<              (unsigned int )cmd);
< #line 3613
---
>              (unsigned int )pi->cmd);
> #line 4255
>     err = -5;
> #line 4256
28004,28008c29795,29801
< #line 3616
<   c.packets[(unsigned int )cmd == 4U] = c.packets[(unsigned int )cmd == 4U] + 1U;
< #line 3617
<   c.bytes[(unsigned int )cmd == 4U] = (c.bytes[(unsigned int )cmd == 4U] + data_size) + 8U;
< #line 3619
---
> #line 4259
>   c.packets[(unsigned int )pi->cmd == 4U] = c.packets[(unsigned int )pi->cmd == 4U] + 1U;
> #line 4260
>   tmp___2 = drbd_header_size(tconn);
> #line 4260
>   c.bytes[(unsigned int )pi->cmd == 4U] = c.bytes[(unsigned int )pi->cmd == 4U] + (tmp___2 + pi->size);
> #line 4262
28010c29803
< #line 3620
---
> #line 4263
28012c29805
< #line 3621
---
> #line 4264
28017,28018c29810,29811
< #line 3622
<     goto ldv_52858;
---
> #line 4265
>     goto ldv_53654;
28022,28026c29815,29819
< #line 3624
<   tmp___3 = drbd_recv_header(mdev, & cmd, & data_size);
< #line 3624
<   if (tmp___3 == 0) {
< #line 3625
---
> #line 4267
>   err = drbd_recv_header(mdev->tconn, pi);
> #line 4268
>   if (err != 0) {
> #line 4269
28031,28034c29824,29827
< #line 3626
<   goto ldv_52859;
<   ldv_52858: 
< #line 3628
---
> #line 4270
>   goto ldv_53655;
>   ldv_53654: 
> #line 4272
28036,28044c29829,29835
< #line 3630
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 224U) {
< #line 3633
<     tmp___4 = drbd_send_bitmap(mdev);
< #line 3633
<     ok = tmp___4 == 0;
< #line 3634
<     if (ok == 0) {
< #line 3635
---
> #line 4274
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 224U) {
> #line 4277
>     err = drbd_send_bitmap(mdev);
> #line 4278
>     if (err != 0) {
> #line 4279
28049c29840
< #line 3637
---
> #line 4281
28051,28053c29842,29844
< #line 3637
<     val.ldv_40583.conn = 15U;
< #line 3637
---
> #line 4281
>     val.ldv_40604.conn = 15U;
> #line 4281
28055,28057c29846,29848
< #line 3637
<     mask.ldv_40583.conn = 31U;
< #line 3637
---
> #line 4281
>     mask.ldv_40604.conn = 31U;
> #line 4281
28059c29850
< #line 3638
---
> #line 4282
28061c29852
< #line 3638
---
> #line 4282
28063,28064c29854,29855
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               3638);
---
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>               4282);
28069,28073c29860,29864
< #line 3639
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) != 208U) {
< #line 3642
<     tmp___5 = drbd_conn_str((enum drbd_conns )mdev->state.ldv_40583.conn);
< #line 3642
---
> #line 4283
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) != 208U) {
> #line 4286
>     tmp___3 = drbd_conn_str((enum drbd_conns )mdev->state.ldv_50103.conn);
> #line 4286
28075c29866
<               tmp___5);
---
>               tmp___3);
28079,28080c29870,29871
< #line 3646
<   ok = 1;
---
> #line 4289
>   err = 0;
28082c29873
< #line 3648
---
> #line 4292
28084,28086c29875,29877
< #line 3649
<   if (ok != 0 && (unsigned int )*((unsigned short *)mdev + 1138UL) == 208U) {
< #line 3650
---
> #line 4293
>   if (err == 0 && (unsigned int )*((unsigned short *)mdev + 374UL) == 208U) {
> #line 4294
28091,28094c29882,29883
< #line 3651
<   free_pages((unsigned long )buffer, 0U);
< #line 3652
<   return (ok);
---
> #line 4295
>   return (err);
28097,28098c29886,29887
< #line 3655 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_skip(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 4298 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_skip(struct drbd_tconn *tconn , struct packet_info *pi ) 
28100,28106c29889
<   char sink[128U] ;
<   int size ;
<   int want ;
<   int r ;
<   int __min1 ;
<   int __min2 ;
<   int _b ;
---
>   int tmp ;
28109,28155c29892,29898
< #line 3661
<   dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "skipping unknown optional packet type %d, l: %d!\n",
<            (unsigned int )cmd, data_size);
< #line 3664
<   size = (int )data_size;
< #line 3665
<   goto ldv_52882;
<   ldv_52881: 
< #line 3666
<   __min1 = size;
< #line 3666
<   __min2 = 128;
< #line 3666
<   want = __min1 < __min2 ? __min1 : __min2;
< #line 3667
<   r = drbd_recv(mdev, (void *)(& sink), (size_t )want);
< #line 3668
<   _b = r <= 0;
< #line 3668
<   if (_b != 0) {
< #line 3668
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "receive_skip", (char *)"r <= 0", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             3668);
<   } else {
< 
<   }
< #line 3668
<   if (_b != 0) {
< #line 3668
<     goto ldv_52880;
<   } else {
< 
<   }
< #line 3669
<   size = size - r;
<   ldv_52882: ;
< #line 3665
<   if (size > 0) {
< #line 3666
<     goto ldv_52881;
<   } else {
< 
<   }
<   ldv_52880: ;
< #line 3671
<   return (size == 0);
---
> #line 4300
>   printk("\fd-con %s: skipping unknown optional packet type %d, l: %d!\n", tconn->name,
>          (unsigned int )pi->cmd, pi->size);
> #line 4303
>   tmp = ignore_remaining_packet(tconn, pi);
> #line 4303
>   return (tmp);
28158,28159c29901,29902
< #line 3674 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_UnplugRemote(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 4306 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_UnplugRemote(struct drbd_tconn *tconn , struct packet_info *pi ) 
28164,28167c29907,29910
< #line 3678
<   drbd_tcp_quickack(mdev->data.socket);
< #line 3680
<   return (1);
---
> #line 4310
>   drbd_tcp_quickack(tconn->data.socket);
> #line 4312
>   return (0);
28170,28171c29913,29914
< #line 3683 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int receive_out_of_sync(struct drbd_conf *mdev , enum drbd_packets cmd , unsigned int data_size ) 
---
> #line 4315 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int receive_out_of_sync(struct drbd_tconn *tconn , struct packet_info *pi ) 
28172a29916
>   struct drbd_conf *mdev ;
28179,28182c29923,29935
< #line 3685
<   p = & mdev->data.rbuf.block_desc;
< #line 3687
<   switch ((int )mdev->state.ldv_40583.conn) {
---
> #line 4318
>   p = (struct p_block_desc *)pi->data;
> #line 4320
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 4321
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 4322
>     return (-5);
>   } else {
> 
>   }
> #line 4324
>   switch ((int )mdev->state.ldv_50103.conn) {
28186,28187c29939,29940
< #line 3691
<   goto ldv_52897;
---
> #line 4328
>   goto ldv_53678;
28189,28191c29942,29944
< #line 3693
<   tmp = drbd_conn_str((enum drbd_conns )mdev->state.ldv_40583.conn);
< #line 3693
---
> #line 4330
>   tmp = drbd_conn_str((enum drbd_conns )mdev->state.ldv_50103.conn);
> #line 4330
28195,28196c29948,29949
<   ldv_52897: 
< #line 3697
---
>   ldv_53678: 
> #line 4334
28198c29951
< #line 3697
---
> #line 4334
28200,28204c29953,29957
< #line 3697
<   __drbd_set_out_of_sync(mdev, (sector_t )tmp___1, (int )tmp___0, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                          3697U);
< #line 3699
<   return (1);
---
> #line 4334
>   __drbd_set_out_of_sync(mdev, (sector_t )tmp___1, (int )tmp___0, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                          4334U);
> #line 4336
>   return (0);
28207,28214c29960,29968
< #line 3710 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static struct data_cmd drbd_cmd_handler[43U]  = 
< #line 3710
<   {      {1, 32UL, & receive_Data}, 
<         {1, 32UL, & receive_DataReply}, 
<         {1, 32UL, & receive_RSDataReply}, 
<         {0, 16UL, & receive_Barrier}, 
<         {1, 8UL, & receive_bitmap}, 
---
> #line 4345 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static struct data_cmd drbd_cmd_handler[46U]  = 
> #line 4345
>   {      {1, 24UL, & receive_Data}, 
>         {1, 24UL, & receive_DataReply}, 
>         {1, 24UL, & receive_RSDataReply}, 
>         {0, 8UL, & receive_Barrier}, 
>         {1, 0UL, & receive_bitmap}, 
>         {0, 0UL, 0}, 
28215a29970,29978
>         {0, 0UL, & receive_UnplugRemote}, 
>         {0, 24UL, & receive_DataRequest}, 
>         {0, 24UL, & receive_DataRequest}, 
>         {1, 0UL, & receive_SyncParam}, 
>         {1, 24UL, & receive_protocol}, 
>         {0, 48UL, & receive_uuids}, 
>         {0, 32UL, & receive_sizes}, 
>         {0, 4UL, & receive_state}, 
>         {0, 8UL, & receive_sync_uuid}, 
28217,28225d29979
<         {0, 8UL, & receive_UnplugRemote}, 
<         {0, 32UL, & receive_DataRequest}, 
<         {0, 32UL, & receive_DataRequest}, 
<         {1, 8UL, & receive_SyncParam}, 
<         {1, 32UL, & receive_protocol}, 
<         {0, 56UL, & receive_uuids}, 
<         {0, 40UL, & receive_sizes}, 
<         {0, 12UL, & receive_state}, 
<         {0, 16UL, & receive_sync_uuid}, 
28226a29981
>         {0, 8UL, & receive_req_state}, 
28228d29982
<         {0, 16UL, & receive_req_state}, 
28238a29993,29994
>         {0, 24UL, & receive_DataRequest}, 
>         {1, 24UL, & receive_DataRequest}, 
28240,28241c29996
<         {0, 32UL, & receive_DataRequest}, 
<         {1, 32UL, & receive_DataRequest}, 
---
>         {1, 24UL, & receive_DataRequest}, 
28243c29998,29999
<         {1, 32UL, & receive_DataRequest}, 
---
>         {1, 0UL, & receive_SyncParam}, 
>         {1, 0UL, & receive_bitmap}, 
28245,28246d30000
<         {1, 8UL, & receive_SyncParam}, 
<         {1, 8UL, & receive_bitmap}, 
28247a30002,30003
>         {0, 8UL, & receive_skip}, 
>         {0, 16UL, & receive_out_of_sync}, 
28249,28250c30005
<         {0, 16UL, & receive_skip}, 
<         {0, 24UL, & receive_out_of_sync}, 
---
>         {0, 8UL, & receive_req_conn_state}, 
28252,28258c30007,30012
<         {0, 0UL, 0}};
< #line 3745 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static void drbdd(struct drbd_conf *mdev ) 
< { 
<   union p_header *header ;
<   unsigned int packet_size ;
<   enum drbd_packets cmd ;
---
>         {0, 0UL, 0}, 
>         {1, 24UL, & receive_protocol}};
> #line 4372 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void drbdd(struct drbd_tconn *tconn ) 
> { 
>   struct packet_info pi ;
28260c30014,30015
<   int rv ;
---
>   int err ;
>   struct data_cmd *cmd ;
28262c30017
<   long tmp___0 ;
---
>   char const   *tmp___0 ;
28264,28270c30019,30022
<   char const   *tmp___2 ;
<   struct task_struct *tmp___3 ;
<   int tmp___4 ;
<   long tmp___5 ;
<   char const   *tmp___6 ;
<   long tmp___7 ;
<   enum drbd_thread_state tmp___8 ;
---
>   long tmp___2 ;
>   char const   *tmp___3 ;
>   char const   *tmp___4 ;
>   enum drbd_thread_state tmp___5 ;
28275,28286c30027,30036
< #line 3747
<   header = & mdev->data.rbuf.header;
< #line 3753
<   goto ldv_52918;
<   ldv_52917: 
< #line 3754
<   drbd_thread_current_set_cpu(mdev);
< #line 3755
<   tmp = drbd_recv_header(mdev, & cmd, & packet_size);
< #line 3755
<   if (tmp == 0) {
< #line 3756
---
> #line 4378
>   goto ldv_53698;
>   ldv_53697: 
> #line 4381
>   drbd_thread_current_set_cpu(& tconn->receiver);
> #line 4382
>   tmp = drbd_recv_header(tconn, & pi);
> #line 4382
>   if (tmp != 0) {
> #line 4383
28291,28298c30041,30053
< #line 3758
<   tmp___0 = __builtin_expect((unsigned int )cmd > 41U, 0L);
< #line 3758
<   if (tmp___0 != 0L) {
< #line 3759
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "unknown packet type %d, l: %d!\n",
<             (unsigned int )cmd, packet_size);
< #line 3760
---
> #line 4385
>   cmd = (struct data_cmd *)(& drbd_cmd_handler) + (unsigned long )pi.cmd;
> #line 4386
>   tmp___1 = __builtin_expect((unsigned int )pi.cmd > (unsigned int )P_PROTOCOL_UPDATE,
>                              0L);
> #line 4386
>   if (tmp___1 != 0L) {
> #line 4387
>     tmp___0 = cmdname(pi.cmd);
> #line 4387
>     printk("\vd-con %s: Unexpected data packet %s (0x%04x)", tconn->name, tmp___0,
>            (unsigned int )pi.cmd);
> #line 4389
28301,28304c30056,30058
< #line 3758
<     tmp___1 = __builtin_expect((unsigned long )drbd_cmd_handler[(unsigned int )cmd].function == (unsigned long )((int (*)(struct drbd_conf * ,
<                                                                                                                           enum drbd_packets  ,
<                                                                                                                           unsigned int  ))0),
---
> #line 4386
>     tmp___2 = __builtin_expect((unsigned long )cmd->fn == (unsigned long )((int (*)(struct drbd_tconn * ,
>                                                                                     struct packet_info * ))0),
28306,28311c30060,30067
< #line 3758
<     if (tmp___1 != 0L) {
< #line 3759
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "unknown packet type %d, l: %d!\n",
<               (unsigned int )cmd, packet_size);
< #line 3760
---
> #line 4386
>     if (tmp___2 != 0L) {
> #line 4387
>       tmp___0 = cmdname(pi.cmd);
> #line 4387
>       printk("\vd-con %s: Unexpected data packet %s (0x%04x)", tconn->name, tmp___0,
>              (unsigned int )pi.cmd);
> #line 4389
28317,28326c30073,30081
< #line 3763
<   shs = drbd_cmd_handler[(unsigned int )cmd].pkt_size - 8UL;
< #line 3764
<   if ((size_t )packet_size != shs && drbd_cmd_handler[(unsigned int )cmd].expect_payload == 0) {
< #line 3765
<     tmp___2 = cmdname(cmd);
< #line 3765
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "No payload expected %s l:%d\n",
<             tmp___2, packet_size);
< #line 3766
---
> #line 4392
>   shs = cmd->pkt_size;
> #line 4393
>   if ((size_t )pi.size > shs && cmd->expect_payload == 0) {
> #line 4394
>     tmp___3 = cmdname(pi.cmd);
> #line 4394
>     printk("\vd-con %s: No payload expected %s l:%d\n", tconn->name, tmp___3, pi.size);
> #line 4396
28331c30086
< #line 3769
---
> #line 4399
28333,28351c30088,30092
< #line 3770
<     rv = drbd_recv(mdev, (void *)(& header->h80.payload), shs);
< #line 3771
<     tmp___5 = __builtin_expect((size_t )rv != shs, 0L);
< #line 3771
<     if (tmp___5 != 0L) {
< #line 3772
<       tmp___3 = get_current();
< #line 3772
<       tmp___4 = signal_pending(tmp___3);
< #line 3772
<       if (tmp___4 == 0) {
< #line 3773
<         dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "short read while reading sub header: rv=%d\n",
<                  rv);
<       } else {
< 
<       }
< #line 3774
---
> #line 4400
>     err = drbd_recv_all_warn(tconn, pi.data, shs);
> #line 4401
>     if (err != 0) {
> #line 4402
28355a30097,30098
> #line 4403
>     pi.size = pi.size - (unsigned int )shs;
28359,28370c30102,30111
< #line 3778
<   rv = (*(drbd_cmd_handler[(unsigned int )cmd].function))(mdev, cmd, packet_size - (unsigned int )shs);
< #line 3780
<   tmp___7 = __builtin_expect(rv == 0, 0L);
< #line 3780
<   if (tmp___7 != 0L) {
< #line 3781
<     tmp___6 = cmdname(cmd);
< #line 3781
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "error receiving %s, l: %d!\n",
<             tmp___6, packet_size);
< #line 3783
---
> #line 4406
>   err = (*(cmd->fn))(tconn, & pi);
> #line 4407
>   if (err != 0) {
> #line 4408
>     tmp___4 = cmdname(pi.cmd);
> #line 4408
>     printk("\vd-con %s: error receiving %s, e: %d l: %d!\n", tconn->name, tmp___4,
>            err, pi.size);
> #line 4410
28375,28381c30116,30122
<   ldv_52918: 
< #line 3753
<   tmp___8 = get_t_state(& mdev->receiver);
< #line 3753
<   if ((unsigned int )tmp___8 == 1U) {
< #line 3754
<     goto ldv_52917;
---
>   ldv_53698: 
> #line 4378
>   tmp___5 = get_t_state(& tconn->receiver);
> #line 4378
>   if ((unsigned int )tmp___5 == 1U) {
> #line 4379
>     goto ldv_53697;
28386,28404c30127,30140
< #line 3787
<   if (0) {
<     err_out: 
< #line 3789
<     val.i = 0U;
< #line 3789
<     val.ldv_40583.conn = 6U;
< #line 3789
<     mask.i = 0U;
< #line 3789
<     mask.ldv_40583.conn = 31U;
< #line 3789
<     drbd_force_state(mdev, mask, val);
<   } else {
< 
<   }
< #line 3793
<   drbd_md_sync(mdev);
< #line 3794
---
> #line 4413
>   return;
>   err_out: 
> #line 4416
>   val.i = 0U;
> #line 4416
>   val.ldv_40604.conn = 6U;
> #line 4416
>   mask.i = 0U;
> #line 4416
>   mask.ldv_40604.conn = 31U;
> #line 4416
>   conn_request_state(tconn, mask, val, CS_HARD);
> #line 4418
28408,28409c30144,30145
< #line 3796 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< void drbd_flush_workqueue(struct drbd_conf *mdev ) 
---
> #line 4419 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> void conn_flush_workqueue(struct drbd_tconn *tconn ) 
28414c30150
< #line 3800
---
> #line 4423
28416c30152,30154
< #line 3801
---
> #line 4424
>   barr.w.ldv_50388.tconn = tconn;
> #line 4425
28418,28420c30156,30158
< #line 3802
<   drbd_queue_work(& mdev->data.work, & barr.w);
< #line 3803
---
> #line 4426
>   drbd_queue_work(& tconn->sender_work, & barr.w);
> #line 4427
28422c30160
< #line 3804
---
> #line 4428
28426,28427c30164,30165
< #line 3806 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< void drbd_free_tl_hash(struct drbd_conf *mdev ) 
---
> #line 4430 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static void conn_disconnect(struct drbd_tconn *tconn ) 
28429,28433c30167,30180
<   struct hlist_head *h ;
<   struct drbd_request *req ;
<   struct hlist_node *pos ;
<   struct hlist_node *n ;
<   struct hlist_node  const  *__mptr ;
---
>   struct drbd_conf *mdev ;
>   enum drbd_conns oc ;
>   int vnr ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   void *tmp ;
>   void *tmp___0 ;
>   int tmp___1 ;
>   enum drbd_role tmp___2 ;
>   enum drbd_disk_state tmp___3 ;
>   union drbd_state val___0 ;
>   union drbd_state mask___0 ;
>   union drbd_state val___1 ;
>   union drbd_state mask___1 ;
28436,28442c30183,30185
< #line 3810
<   spin_lock_irq(& mdev->req_lock);
< #line 3812
<   if ((unsigned long )mdev->tl_hash == (unsigned long )((struct hlist_head *)0) || (unsigned int )*((unsigned short *)mdev + 1138UL) != 0U) {
< #line 3813
<     spin_unlock_irq(& mdev->req_lock);
< #line 3814
---
> #line 4436
>   if ((unsigned int )tconn->cstate == 0U) {
> #line 4437
28447,28456c30190,30235
< #line 3817
<   h = mdev->ee_hash;
< #line 3817
<   goto ldv_52933;
<   ldv_52932: ;
< #line 3818
<   if ((unsigned long )h->first != (unsigned long )((struct hlist_node *)0)) {
< #line 3819
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED ee_hash[%u].first == %p, expected NULL\n",
<             (int )(((long )h - (long )mdev->ee_hash) / 8L), h->first);
---
> #line 4444
>   val.i = 0U;
> #line 4444
>   val.ldv_40604.conn = 5U;
> #line 4444
>   mask.i = 0U;
> #line 4444
>   mask.ldv_40604.conn = 31U;
> #line 4444
>   conn_request_state(tconn, mask, val, CS_HARD);
> #line 4447
>   drbd_thread_stop(& tconn->asender);
> #line 4448
>   drbd_free_sock(tconn);
> #line 4450
>   rcu_read_lock();
> #line 4451
>   vnr = 0;
> #line 4451
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 4451
>   mdev = (struct drbd_conf *)tmp;
> #line 4451
>   goto ldv_53719;
>   ldv_53718: 
> #line 4452
>   kref_get(& mdev->kref);
> #line 4453
>   rcu_read_unlock();
> #line 4454
>   drbd_disconnected(mdev);
> #line 4455
>   kref_put(& mdev->kref, & drbd_minor_destroy);
> #line 4456
>   rcu_read_lock();
> #line 4451
>   vnr = vnr + 1;
> #line 4451
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 4451
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_53719: ;
> #line 4451
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 4452
>     goto ldv_53718;
28460,28466c30239,30247
< #line 3817
<   h = h + 1;
<   ldv_52933: ;
< #line 3817
<   if ((unsigned long )(mdev->ee_hash + (unsigned long )mdev->ee_hash_s) > (unsigned long )h) {
< #line 3818
<     goto ldv_52932;
---
> #line 4458
>   rcu_read_unlock();
> #line 4460
>   tmp___1 = list_empty((struct list_head  const  *)(& (tconn->current_epoch)->list));
> #line 4460
>   if (tmp___1 == 0) {
> #line 4461
>     printk("\vd-con %s: ASSERTION FAILED: tconn->current_epoch->list not empty\n",
>            tconn->name);
28470,28510c30251,30266
< #line 3821
<   kfree((void const   *)mdev->ee_hash);
< #line 3822
<   mdev->ee_hash = 0;
< #line 3823
<   mdev->ee_hash_s = 0U;
< #line 3828
<   h = mdev->tl_hash;
< #line 3828
<   goto ldv_52946;
<   ldv_52945: 
< #line 3831
<   pos = h->first;
< #line 3831
<   goto ldv_52943;
<   ldv_52942: 
< #line 3832
<   hlist_del_init(& req->collision);
< #line 3833
<   hlist_add_fake(& req->collision);
< #line 3831
<   pos = n;
<   ldv_52943: ;
< #line 3831
<   if ((unsigned long )pos != (unsigned long )((struct hlist_node *)0)) {
< #line 3831
<     n = pos->next;
< #line 3831
<     if (1 != 0) {
< #line 3831
<       __mptr = (struct hlist_node  const  *)pos;
< #line 3831
<       req = (struct drbd_request *)__mptr + 0xffffffffffffffd8UL;
< #line 3831
<       if (1 != 0) {
< #line 3832
<         goto ldv_52942;
<       } else {
< #line 3834
<         goto ldv_52944;
<       }
---
> #line 4463
>   atomic_set(& (tconn->current_epoch)->epoch_size, 0);
> #line 4464
>   tconn->send.seen_any_write_yet = 0;
> #line 4466
>   printk("\016d-con %s: Connection closed\n", tconn->name);
> #line 4468
>   tmp___2 = conn_highest_role(tconn);
> #line 4468
>   if ((unsigned int )tmp___2 == 1U) {
> #line 4468
>     tmp___3 = conn_highest_pdsk(tconn);
> #line 4468
>     if ((unsigned int )tmp___3 > 5U) {
> #line 4469
>       conn_try_outdate_peer_async(tconn);
28512,28513c30268
< #line 3834
<       goto ldv_52944;
---
> 
28518,28525c30273,30288
<   ldv_52944: 
< #line 3828
<   h = h + 1;
<   ldv_52946: ;
< #line 3828
<   if ((unsigned long )(mdev->tl_hash + (unsigned long )mdev->tl_hash_s) > (unsigned long )h) {
< #line 3829
<     goto ldv_52945;
---
> #line 4471
>   spin_lock_irq(& tconn->req_lock);
> #line 4472
>   oc = tconn->cstate;
> #line 4473
>   if ((unsigned int )oc > 1U) {
> #line 4474
>     val___0.i = 0U;
> #line 4474
>     val___0.ldv_40604.conn = 2U;
> #line 4474
>     mask___0.i = 0U;
> #line 4474
>     mask___0.ldv_40604.conn = 31U;
> #line 4474
>     _conn_request_state(tconn, mask___0, val___0, CS_VERBOSE);
28529,28537c30292,30309
< #line 3837
<   kfree((void const   *)mdev->tl_hash);
< #line 3838
<   mdev->tl_hash = 0;
< #line 3839
<   mdev->tl_hash_s = 0U;
< #line 3840
<   spin_unlock_irq(& mdev->req_lock);
< #line 3841
---
> #line 4476
>   spin_unlock_irq(& tconn->req_lock);
> #line 4478
>   if ((unsigned int )oc == 1U) {
> #line 4479
>     val___1.i = 0U;
> #line 4479
>     val___1.ldv_40604.conn = 0U;
> #line 4479
>     mask___1.i = 0U;
> #line 4479
>     mask___1.ldv_40604.conn = 31U;
> #line 4479
>     conn_request_state(tconn, mask___1, val___1, 3);
>   } else {
> 
>   }
> #line 4481
28541,28542c30313,30314
< #line 3843 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static void drbd_disconnect(struct drbd_conf *mdev ) 
---
> #line 4482 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_disconnected(struct drbd_conf *mdev ) 
28544,28547d30315
<   enum drbd_fencing_p fp ;
<   union drbd_state os ;
<   union drbd_state ns ;
<   int rv ;
28549,28550d30316
<   union drbd_state val ;
<   union drbd_state mask ;
28553,28554d30318
<   enum drbd_state_rv tmp___1 ;
<   int tmp___2 ;
28556c30320,30322
<   struct task_struct *tmp___3 ;
---
>   struct task_struct *tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
28558,28559d30323
<   union drbd_state val___0 ;
<   union drbd_state mask___0 ;
28561,28562c30325
<   wait_queue_t __wait___0 ;
<   struct task_struct *tmp___6 ;
---
>   int tmp___6 ;
28566,28571d30328
<   int tmp___10 ;
<   int tmp___11 ;
<   int tmp___12 ;
<   int tmp___13 ;
<   int tmp___14 ;
<   int tmp___15 ;
28574,28599c30331,30333
< #line 3847
<   rv = 0;
< #line 3850
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 0U) {
< #line 3851
<     return;
<   } else {
< 
<   }
< #line 3858
<   val.i = 0U;
< #line 3858
<   val.ldv_40583.conn = 5U;
< #line 3858
<   mask.i = 0U;
< #line 3858
<   mask.ldv_40583.conn = 31U;
< #line 3858
<   drbd_force_state(mdev, mask, val);
< #line 3861
<   drbd_thread_stop(& mdev->asender);
< #line 3862
<   drbd_free_sock(mdev);
< #line 3865
<   spin_lock_irq(& mdev->req_lock);
< #line 3866
---
> #line 4487
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 4488
28601c30335
< #line 3867
---
> #line 4489
28603c30337
< #line 3868
---
> #line 4490
28605,28607c30339,30341
< #line 3869
<   spin_unlock_irq(& mdev->req_lock);
< #line 3881
---
> #line 4491
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 4503
28609c30343
< #line 3882
---
> #line 4504
28611c30345
< #line 3883
---
> #line 4505
28613c30347
< #line 3884
---
> #line 4506
28615c30349
< #line 3885
---
> #line 4507
28617c30351
< #line 3888
---
> #line 4509
28619c30353
< #line 3889
---
> #line 4510
28621c30355
< #line 3894
---
> #line 4515
28623,28625c30357,30363
< #line 3898
<   drbd_process_done_ee(mdev);
< #line 3900
---
> #line 4517
>   drbd_finish_peer_reqs(mdev);
> #line 4522
>   drbd_flush_workqueue(mdev);
> #line 4526
>   drbd_rs_cancel_all(mdev);
> #line 4528
28627c30365
< #line 3901
---
> #line 4529
28629,28631c30367,30369
< #line 3903
<   tmp = is_susp(mdev->state);
< #line 3903
---
> #line 4531
>   tmp = drbd_suspended(mdev);
> #line 4531
28633,28634c30371,30372
< #line 3904
<     tl_clear(mdev);
---
> #line 4532
>     tl_clear(mdev->tconn);
28638,28640c30376
< #line 3906
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Connection closed\n");
< #line 3908
---
> #line 4534
28642,28750c30378,30383
< #line 3910
<   fp = FP_DONT_CARE;
< #line 3911
<   tmp___0 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 3911
<   if (tmp___0 != 0) {
< #line 3912
<     fp = (enum drbd_fencing_p )(mdev->ldev)->dc.fencing;
< #line 3913
<     put_ldev(mdev);
<   } else {
< 
<   }
< #line 3916
<   if (((unsigned int )*((unsigned char *)mdev + 2276UL) == 1U && (unsigned int )fp != 0U) && (int )mdev->state.ldv_40583.pdsk > 5) {
< #line 3917
<     drbd_try_outdate_peer_async(mdev);
<   } else {
< 
<   }
< #line 3919
<   spin_lock_irq(& mdev->req_lock);
< #line 3920
<   os = mdev->state;
< #line 3921
<   if ((int )os.ldv_40583.conn > 1) {
< #line 3923
<     ns = os;
< #line 3924
<     ns.ldv_40583.conn = 2U;
< #line 3925
<     tmp___1 = _drbd_set_state(mdev, ns, CS_VERBOSE, 0);
< #line 3925
<     rv = (int )tmp___1;
<   } else {
< 
<   }
< #line 3927
<   spin_unlock_irq(& mdev->req_lock);
< #line 3929
<   if ((unsigned int )*((unsigned short *)(& os) + 0UL) == 16U) {
< #line 3930
<     tmp___2 = atomic_read((atomic_t const   *)(& mdev->net_cnt));
< #line 3930
<     if (tmp___2 == 0) {
< #line 3930
<       goto ldv_52960;
<     } else {
< 
<     }
< #line 3930
<     tmp___3 = get_current();
< #line 3930
<     __wait.flags = 0U;
< #line 3930
<     __wait.private = (void *)tmp___3;
< #line 3930
<     __wait.func = & autoremove_wake_function;
< #line 3930
<     __wait.task_list.next = & __wait.task_list;
< #line 3930
<     __wait.task_list.prev = & __wait.task_list;
<     ldv_52963: 
< #line 3930
<     prepare_to_wait(& mdev->net_cnt_wait, & __wait, 2);
< #line 3930
<     tmp___4 = atomic_read((atomic_t const   *)(& mdev->net_cnt));
< #line 3930
<     if (tmp___4 == 0) {
< #line 3930
<       goto ldv_52962;
<     } else {
< 
<     }
< #line 3930
<     schedule();
< #line 3930
<     goto ldv_52963;
<     ldv_52962: 
< #line 3930
<     finish_wait(& mdev->net_cnt_wait, & __wait);
<     ldv_52960: 
< #line 3932
<     crypto_free_hash(mdev->cram_hmac_tfm);
< #line 3933
<     mdev->cram_hmac_tfm = 0;
< #line 3935
<     kfree((void const   *)mdev->net_conf);
< #line 3936
<     mdev->net_conf = 0;
< #line 3937
<     val___0.i = 0U;
< #line 3937
<     val___0.ldv_40583.conn = 0U;
< #line 3937
<     mask___0.i = 0U;
< #line 3937
<     mask___0.ldv_40583.conn = 31U;
< #line 3937
<     drbd_request_state(mdev, mask___0, val___0);
<   } else {
< 
<   }
< #line 3942
<   tmp___5 = drbd_test_flag(mdev, BITMAP_IO);
< #line 3942
<   if (tmp___5 == 0) {
< #line 3942
<     goto ldv_52968;
---
> #line 4538
>   tmp___0 = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 4538
>   if (tmp___0 == 0) {
> #line 4538
>     goto ldv_53733;
28754,28774c30387,30407
< #line 3942
<   tmp___6 = get_current();
< #line 3942
<   __wait___0.flags = 0U;
< #line 3942
<   __wait___0.private = (void *)tmp___6;
< #line 3942
<   __wait___0.func = & autoremove_wake_function;
< #line 3942
<   __wait___0.task_list.next = & __wait___0.task_list;
< #line 3942
<   __wait___0.task_list.prev = & __wait___0.task_list;
<   ldv_52971: 
< #line 3942
<   prepare_to_wait(& mdev->misc_wait, & __wait___0, 2);
< #line 3942
<   tmp___7 = drbd_test_flag(mdev, BITMAP_IO);
< #line 3942
<   if (tmp___7 == 0) {
< #line 3942
<     goto ldv_52970;
---
> #line 4538
>   tmp___1 = get_current();
> #line 4538
>   __wait.flags = 0U;
> #line 4538
>   __wait.private = (void *)tmp___1;
> #line 4538
>   __wait.func = & autoremove_wake_function;
> #line 4538
>   __wait.task_list.next = & __wait.task_list;
> #line 4538
>   __wait.task_list.prev = & __wait.task_list;
>   ldv_53736: 
> #line 4538
>   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
> #line 4538
>   tmp___2 = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 4538
>   if (tmp___2 == 0) {
> #line 4538
>     goto ldv_53735;
28778c30411
< #line 3942
---
> #line 4538
28780,28790c30413,30423
< #line 3942
<   goto ldv_52971;
<   ldv_52970: 
< #line 3942
<   finish_wait(& mdev->misc_wait, & __wait___0);
<   ldv_52968: 
< #line 3951
<   tmp___8 = drbd_release_ee(mdev, & mdev->net_ee);
< #line 3951
<   i = (unsigned int )tmp___8;
< #line 3952
---
> #line 4538
>   goto ldv_53736;
>   ldv_53735: 
> #line 4538
>   finish_wait(& mdev->misc_wait, & __wait);
>   ldv_53733: 
> #line 4547
>   tmp___3 = drbd_free_peer_reqs(mdev, & mdev->net_ee);
> #line 4547
>   i = (unsigned int )tmp___3;
> #line 4548
28792c30425
< #line 3953
---
> #line 4549
28798,28802c30431,30435
< #line 3954
<   tmp___9 = atomic_read((atomic_t const   *)(& mdev->pp_in_use_by_net));
< #line 3954
<   i = (unsigned int )tmp___9;
< #line 3955
---
> #line 4550
>   tmp___4 = atomic_read((atomic_t const   *)(& mdev->pp_in_use_by_net));
> #line 4550
>   i = (unsigned int )tmp___4;
> #line 4551
28804c30437
< #line 3956
---
> #line 4552
28810,28814c30443,30447
< #line 3957
<   tmp___10 = atomic_read((atomic_t const   *)(& mdev->pp_in_use));
< #line 3957
<   i = (unsigned int )tmp___10;
< #line 3958
---
> #line 4553
>   tmp___5 = atomic_read((atomic_t const   *)(& mdev->pp_in_use));
> #line 4553
>   i = (unsigned int )tmp___5;
> #line 4554
28816c30449
< #line 3959
---
> #line 4555
28822,28826c30455,30459
< #line 3961
<   tmp___11 = list_empty((struct list_head  const  *)(& mdev->read_ee));
< #line 3961
<   if (tmp___11 == 0) {
< #line 3961
---
> #line 4557
>   tmp___6 = list_empty((struct list_head  const  *)(& mdev->read_ee));
> #line 4557
>   if (tmp___6 == 0) {
> #line 4557
28828,28829c30461,30462
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             3961);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             4557);
28833,28837c30466,30470
< #line 3962
<   tmp___12 = list_empty((struct list_head  const  *)(& mdev->active_ee));
< #line 3962
<   if (tmp___12 == 0) {
< #line 3962
---
> #line 4558
>   tmp___7 = list_empty((struct list_head  const  *)(& mdev->active_ee));
> #line 4558
>   if (tmp___7 == 0) {
> #line 4558
28839,28840c30472,30473
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             3962);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             4558);
28844,28848c30477,30481
< #line 3963
<   tmp___13 = list_empty((struct list_head  const  *)(& mdev->sync_ee));
< #line 3963
<   if (tmp___13 == 0) {
< #line 3963
---
> #line 4559
>   tmp___8 = list_empty((struct list_head  const  *)(& mdev->sync_ee));
> #line 4559
>   if (tmp___8 == 0) {
> #line 4559
28850,28851c30483,30484
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             3963);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             4559);
28855,28859c30488,30492
< #line 3964
<   tmp___14 = list_empty((struct list_head  const  *)(& mdev->done_ee));
< #line 3964
<   if (tmp___14 == 0) {
< #line 3964
---
> #line 4560
>   tmp___9 = list_empty((struct list_head  const  *)(& mdev->done_ee));
> #line 4560
>   if (tmp___9 == 0) {
> #line 4560
28861,28875c30494,30495
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             3964);
<   } else {
< 
<   }
< #line 3967
<   atomic_set(& (mdev->current_epoch)->epoch_size, 0);
< #line 3968
<   tmp___15 = list_empty((struct list_head  const  *)(& (mdev->current_epoch)->list));
< #line 3968
<   if (tmp___15 == 0) {
< #line 3968
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( list_empty(&mdev->current_epoch->list) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             3968);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             4560);
28879,28880c30499,30500
< #line 3969
<   return;
---
> #line 4562
>   return (0);
28883,28884c30503,30504
< #line 3980 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_send_handshake(struct drbd_conf *mdev ) 
---
> #line 4574 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_send_features(struct drbd_tconn *tconn ) 
28886,28888c30506,30509
<   struct p_handshake *p ;
<   int ok ;
<   int tmp ;
---
>   struct drbd_socket *sock ;
>   struct p_connection_features *p ;
>   void *tmp ;
>   int tmp___0 ;
28891,28909c30512,30521
< #line 3983
<   p = & mdev->data.sbuf.handshake;
< #line 3986
<   tmp = mutex_lock_interruptible_nested(& mdev->data.mutex, 0U);
< #line 3986
<   if (tmp != 0) {
< #line 3987
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "interrupted during initial handshake\n");
< #line 3988
<     return (0);
<   } else {
< 
<   }
< #line 3991
<   if ((unsigned long )mdev->data.socket == (unsigned long )((struct socket *)0)) {
< #line 3992
<     mutex_unlock(& mdev->data.mutex);
< #line 3993
<     return (0);
---
> #line 4579
>   sock = & tconn->data;
> #line 4580
>   tmp = conn_prepare_command(tconn, sock);
> #line 4580
>   p = (struct p_connection_features *)tmp;
> #line 4581
>   if ((unsigned long )p == (unsigned long )((struct p_connection_features *)0)) {
> #line 4582
>     return (-5);
28913,28915c30525,30527
< #line 3996
<   memset((void *)p, 0, 80UL);
< #line 3997
---
> #line 4583
>   memset((void *)p, 0, 72UL);
> #line 4584
28917,28925c30529,30534
< #line 3998
<   p->protocol_max = 1627389952U;
< #line 3999
<   ok = _drbd_send_cmd(mdev, mdev->data.socket, P_HAND_SHAKE, (struct p_header80 *)p,
<                       80UL, 0U);
< #line 4001
<   mutex_unlock(& mdev->data.mutex);
< #line 4002
<   return (ok);
---
> #line 4585
>   p->protocol_max = 1694498816U;
> #line 4586
>   tmp___0 = conn_send_command(tconn, sock, P_CONNECTION_FEATURES, 72U, 0, 0U);
> #line 4586
>   return (tmp___0);
28928,28929c30537,30538
< #line 4012 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_do_handshake(struct drbd_conf *mdev ) 
---
> #line 4596 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_do_features(struct drbd_tconn *tconn ) 
28931c30540
<   struct p_handshake *p ;
---
>   struct p_connection_features *p ;
28933,28935c30542,30543
<   unsigned int length ;
<   enum drbd_packets cmd ;
<   int rv ;
---
>   struct packet_info pi ;
>   int err ;
28937,28940c30545,30546
<   struct task_struct *tmp___0 ;
<   int tmp___1 ;
<   __u32 tmp___2 ;
<   __u32 tmp___3 ;
---
>   __u32 tmp___0 ;
>   __u32 tmp___1 ;
28945,28947c30551
< #line 4015
<   p = & mdev->data.rbuf.handshake;
< #line 4016
---
> #line 4600
28949,28953c30553,30557
< #line 4021
<   rv = drbd_send_handshake(mdev);
< #line 4022
<   if (rv == 0) {
< #line 4023
---
> #line 4604
>   err = drbd_send_features(tconn);
> #line 4605
>   if (err != 0) {
> #line 4606
28958,28962c30562,30566
< #line 4025
<   rv = drbd_recv_header(mdev, & cmd, & length);
< #line 4026
<   if (rv == 0) {
< #line 4027
---
> #line 4608
>   err = drbd_recv_header(tconn, & pi);
> #line 4609
>   if (err != 0) {
> #line 4610
28967,28974c30571,30578
< #line 4029
<   if ((unsigned int )cmd != 65534U) {
< #line 4030
<     tmp = cmdname(cmd);
< #line 4030
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "expected HandShake packet, received: %s (0x%04x)\n",
<             tmp, (unsigned int )cmd);
< #line 4032
---
> #line 4612
>   if ((unsigned int )pi.cmd != 65534U) {
> #line 4613
>     tmp = cmdname(pi.cmd);
> #line 4613
>     printk("\vd-con %s: expected ConnectionFeatures packet, received: %s (0x%04x)\n",
>            tconn->name, tmp, (unsigned int )pi.cmd);
> #line 4615
28979,28984c30583,30588
< #line 4035
<   if ((unsigned int )expect != length) {
< #line 4036
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "expected HandShake length: %u, received: %u\n",
<             expect, length);
< #line 4038
---
> #line 4618
>   if (pi.size != (unsigned int )expect) {
> #line 4619
>     printk("\vd-con %s: expected ConnectionFeatures length: %u, received: %u\n", tconn->name,
>            expect, pi.size);
> #line 4621
28989,29005c30593,30599
< #line 4041
<   rv = drbd_recv(mdev, (void *)(& p->head.payload), (size_t )expect);
< #line 4043
<   if (rv != expect) {
< #line 4044
<     tmp___0 = get_current();
< #line 4044
<     tmp___1 = signal_pending(tmp___0);
< #line 4044
<     if (tmp___1 == 0) {
< #line 4045
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "short read receiving handshake packet: l=%u\n",
<                rv);
<     } else {
< 
<     }
< #line 4046
---
> #line 4624
>   p = (struct p_connection_features *)pi.data;
> #line 4625
>   err = drbd_recv_all_warn(tconn, (void *)p, (size_t )expect);
> #line 4626
>   if (err != 0) {
> #line 4627
29010,29018c30604,30612
< #line 4049
<   tmp___2 = __fswab32(p->protocol_min);
< #line 4049
<   p->protocol_min = tmp___2;
< #line 4050
<   tmp___3 = __fswab32(p->protocol_max);
< #line 4050
<   p->protocol_max = tmp___3;
< #line 4051
---
> #line 4629
>   tmp___0 = __fswab32(p->protocol_min);
> #line 4629
>   p->protocol_min = tmp___0;
> #line 4630
>   tmp___1 = __fswab32(p->protocol_max);
> #line 4630
>   p->protocol_max = tmp___1;
> #line 4631
29020c30614
< #line 4052
---
> #line 4632
29025,29027c30619,30621
< #line 4054
<   if (p->protocol_min > 97U || p->protocol_max <= 85U) {
< #line 4056
---
> #line 4634
>   if (p->protocol_min > 101U || p->protocol_max <= 85U) {
> #line 4636
29032,29034c30626,30628
< #line 4058
<   __min1 = 97;
< #line 4058
---
> #line 4638
>   __min1 = 101;
> #line 4638
29036,29041c30630,30635
< #line 4058
<   mdev->agreed_pro_version = __min1 < __min2 ? __min1 : __min2;
< #line 4060
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Handshake successful: Agreed network protocol version %d\n",
<             mdev->agreed_pro_version);
< #line 4063
---
> #line 4638
>   tconn->agreed_pro_version = __min1 < __min2 ? __min1 : __min2;
> #line 4640
>   printk("\016d-con %s: Handshake successful: Agreed network protocol version %d\n",
>          tconn->name, tconn->agreed_pro_version);
> #line 4643
29044,29047c30638,30641
< #line 4066
<   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "incompatible DRBD dialects: I support %d-%d, peer supports %d-%d\n",
<           86, 97, p->protocol_min, p->protocol_max);
< #line 4070
---
> #line 4646
>   printk("\vd-con %s: incompatible DRBD dialects: I support %d-%d, peer supports %d-%d\n",
>          tconn->name, 86, 101, p->protocol_min, p->protocol_max);
> #line 4650
29051,29052c30645,30646
< #line 4089 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int drbd_do_auth(struct drbd_conf *mdev ) 
---
> #line 4669 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int drbd_do_auth(struct drbd_tconn *tconn ) 
29053a30648
>   struct drbd_socket *sock ;
29060c30655
<   size_t tmp ;
---
>   char secret[64U] ;
29063,29064c30658,30660
<   enum drbd_packets cmd ;
<   unsigned int length ;
---
>   struct packet_info pi ;
>   struct net_conf *nc ;
>   int err ;
29066,29068c30662,30669
<   char const   *tmp___0 ;
<   void *tmp___1 ;
<   struct task_struct *tmp___2 ;
---
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
>   size_t tmp___1 ;
>   size_t __len ;
>   void *__ret ;
>   void *tmp___2 ;
29070,29075c30671,30678
<   void *tmp___4 ;
<   char const   *tmp___5 ;
<   struct task_struct *tmp___6 ;
<   int tmp___7 ;
<   void *tmp___8 ;
<   int tmp___9 ;
---
>   char const   *tmp___4 ;
>   void *tmp___5 ;
>   void *tmp___6 ;
>   void *tmp___7 ;
>   int tmp___8 ;
>   char const   *tmp___9 ;
>   void *tmp___10 ;
>   int tmp___11 ;
29078c30681
< #line 4093
---
> #line 4674
29080c30683
< #line 4094
---
> #line 4675
29082c30685
< #line 4095
---
> #line 4676
29084,29090c30687,30725
< #line 4096
<   tmp = strlen((char const   *)(& (mdev->net_conf)->shared_secret));
< #line 4096
<   key_len = (unsigned int )tmp;
< #line 4103
<   desc.tfm = mdev->cram_hmac_tfm;
< #line 4104
---
> #line 4687
>   rcu_read_lock();
> #line 4688
>   _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 4688
>   tmp = debug_lockdep_rcu_enabled();
> #line 4688
>   if (tmp != 0 && ! __warned) {
> #line 4688
>     tmp___0 = rcu_read_lock_held();
> #line 4688
>     if (tmp___0 == 0 && 1) {
> #line 4688
>       __warned = 1;
> #line 4688
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              4688, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 4688
>   nc = _________p1;
> #line 4689
>   tmp___1 = strlen((char const   *)(& nc->shared_secret));
> #line 4689
>   key_len = (unsigned int )tmp___1;
> #line 4690
>   __len = (size_t )key_len;
> #line 4690
>   __ret = __builtin_memcpy((void *)(& secret), (void const   *)(& nc->shared_secret),
>                            __len);
> #line 4691
>   rcu_read_unlock();
> #line 4693
>   desc.tfm = tconn->cram_hmac_tfm;
> #line 4694
29092,29095c30727,30729
< #line 4106
<   rv = crypto_hash_setkey(mdev->cram_hmac_tfm, (u8 const   *)(& (mdev->net_conf)->shared_secret),
<                           key_len);
< #line 4108
---
> #line 4696
>   rv = crypto_hash_setkey(tconn->cram_hmac_tfm, (u8 const   *)(& secret), key_len);
> #line 4697
29097,29100c30731,30733
< #line 4109
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "crypto_hash_setkey() failed with %d\n",
<             rv);
< #line 4110
---
> #line 4698
>     printk("\vd-con %s: crypto_hash_setkey() failed with %d\n", tconn->name, rv);
> #line 4699
29102c30735
< #line 4111
---
> #line 4700
29107c30740
< #line 4114
---
> #line 4703
29109,29113c30742,30750
< #line 4116
<   rv = drbd_send_cmd2(mdev, P_AUTH_CHALLENGE, (char *)(& my_challenge), 64UL);
< #line 4117
<   if (rv == 0) {
< #line 4118
---
> #line 4705
>   sock = & tconn->data;
> #line 4706
>   tmp___2 = conn_prepare_command(tconn, sock);
> #line 4706
>   if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
> #line 4707
>     rv = 0;
> #line 4708
29118,29120c30755,30760
< #line 4120
<   rv = drbd_recv_header(mdev, & cmd, & length);
< #line 4121
---
> #line 4710
>   tmp___3 = conn_send_command(tconn, sock, P_AUTH_CHALLENGE, 0U, (void *)(& my_challenge),
>                               64U);
> #line 4710
>   rv = tmp___3 == 0;
> #line 4712
29122c30762,30773
< #line 4122
---
> #line 4713
>     goto fail;
>   } else {
> 
>   }
> #line 4715
>   err = drbd_recv_header(tconn, & pi);
> #line 4716
>   if (err != 0) {
> #line 4717
>     rv = 0;
> #line 4718
29127,29134c30778,30785
< #line 4124
<   if ((unsigned int )cmd != 16U) {
< #line 4125
<     tmp___0 = cmdname(cmd);
< #line 4125
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "expected AuthChallenge packet, received: %s (0x%04x)\n",
<             tmp___0, (unsigned int )cmd);
< #line 4127
---
> #line 4721
>   if ((unsigned int )pi.cmd != 16U) {
> #line 4722
>     tmp___4 = cmdname(pi.cmd);
> #line 4722
>     printk("\vd-con %s: expected AuthChallenge packet, received: %s (0x%04x)\n", tconn->name,
>            tmp___4, (unsigned int )pi.cmd);
> #line 4724
29136c30787
< #line 4128
---
> #line 4725
29141,29145c30792,30796
< #line 4131
<   if (length > 128U) {
< #line 4132
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "expected AuthChallenge payload too big.\n");
< #line 4133
---
> #line 4728
>   if (pi.size > 128U) {
> #line 4729
>     printk("\vd-con %s: expected AuthChallenge payload too big.\n", tconn->name);
> #line 4730
29147c30798
< #line 4134
---
> #line 4731
29152,29156c30803,30807
< #line 4137
<   tmp___1 = kmalloc((size_t )length, 16U);
< #line 4137
<   peers_ch = (char *)tmp___1;
< #line 4138
---
> #line 4734
>   tmp___5 = kmalloc((size_t )pi.size, 16U);
> #line 4734
>   peers_ch = (char *)tmp___5;
> #line 4735
29158,29160c30809,30811
< #line 4139
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "kmalloc of peers_ch failed\n");
< #line 4140
---
> #line 4736
>     printk("\vd-con %s: kmalloc of peers_ch failed\n", tconn->name);
> #line 4737
29162c30813
< #line 4141
---
> #line 4738
29167,29183c30818,30822
< #line 4144
<   rv = drbd_recv(mdev, (void *)peers_ch, (size_t )length);
< #line 4146
<   if ((unsigned int )rv != length) {
< #line 4147
<     tmp___2 = get_current();
< #line 4147
<     tmp___3 = signal_pending(tmp___2);
< #line 4147
<     if (tmp___3 == 0) {
< #line 4148
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "short read AuthChallenge: l=%u\n",
<                rv);
<     } else {
< 
<     }
< #line 4149
---
> #line 4741
>   err = drbd_recv_all_warn(tconn, (void *)peers_ch, (size_t )pi.size);
> #line 4742
>   if (err != 0) {
> #line 4743
29185c30824
< #line 4150
---
> #line 4744
29190,29196c30829,30835
< #line 4153
<   resp_size = crypto_hash_digestsize(mdev->cram_hmac_tfm);
< #line 4154
<   tmp___4 = kmalloc((size_t )resp_size, 16U);
< #line 4154
<   response = (char *)tmp___4;
< #line 4155
---
> #line 4747
>   resp_size = crypto_hash_digestsize(tconn->cram_hmac_tfm);
> #line 4748
>   tmp___6 = kmalloc((size_t )resp_size, 16U);
> #line 4748
>   response = (char *)tmp___6;
> #line 4749
29198,29200c30837,30839
< #line 4156
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "kmalloc of response failed\n");
< #line 4157
---
> #line 4750
>     printk("\vd-con %s: kmalloc of response failed\n", tconn->name);
> #line 4751
29202c30841
< #line 4158
---
> #line 4752
29207c30846
< #line 4161
---
> #line 4755
29209,29211c30848,30850
< #line 4162
<   sg_set_buf(& sg, (void const   *)peers_ch, length);
< #line 4164
---
> #line 4756
>   sg_set_buf(& sg, (void const   *)peers_ch, pi.size);
> #line 4758
29213c30852
< #line 4165
---
> #line 4759
29215,29218c30854,30856
< #line 4166
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "crypto_hash_digest() failed with %d\n",
<             rv);
< #line 4167
---
> #line 4760
>     printk("\vd-con %s: crypto_hash_digest() failed with %d\n", tconn->name, rv);
> #line 4761
29220c30858
< #line 4168
---
> #line 4762
29225,29229c30863,30869
< #line 4171
<   rv = drbd_send_cmd2(mdev, P_AUTH_RESPONSE, response, (size_t )resp_size);
< #line 4172
<   if (rv == 0) {
< #line 4173
---
> #line 4765
>   tmp___7 = conn_prepare_command(tconn, sock);
> #line 4765
>   if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
> #line 4766
>     rv = 0;
> #line 4767
29234,29236c30874,30879
< #line 4175
<   rv = drbd_recv_header(mdev, & cmd, & length);
< #line 4176
---
> #line 4769
>   tmp___8 = conn_send_command(tconn, sock, P_AUTH_RESPONSE, 0U, (void *)response,
>                               resp_size);
> #line 4769
>   rv = tmp___8 == 0;
> #line 4771
29238c30881
< #line 4177
---
> #line 4772
29243,29250c30886,30890
< #line 4179
<   if ((unsigned int )cmd != 17U) {
< #line 4180
<     tmp___5 = cmdname(cmd);
< #line 4180
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "expected AuthResponse packet, received: %s (0x%04x)\n",
<             tmp___5, (unsigned int )cmd);
< #line 4182
---
> #line 4774
>   err = drbd_recv_header(tconn, & pi);
> #line 4775
>   if (err != 0) {
> #line 4776
29252c30892
< #line 4183
---
> #line 4777
29257,29261c30897,30904
< #line 4186
<   if (length != resp_size) {
< #line 4187
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "expected AuthResponse payload of wrong size\n");
< #line 4188
---
> #line 4780
>   if ((unsigned int )pi.cmd != 17U) {
> #line 4781
>     tmp___9 = cmdname(pi.cmd);
> #line 4781
>     printk("\vd-con %s: expected AuthResponse packet, received: %s (0x%04x)\n", tconn->name,
>            tmp___9, (unsigned int )pi.cmd);
> #line 4783
29263c30906
< #line 4189
---
> #line 4784
29268,29281c30911,30919
< #line 4192
<   rv = drbd_recv(mdev, (void *)response, (size_t )resp_size);
< #line 4194
<   if ((unsigned int )rv != resp_size) {
< #line 4195
<     tmp___6 = get_current();
< #line 4195
<     tmp___7 = signal_pending(tmp___6);
< #line 4195
<     if (tmp___7 == 0) {
< #line 4196
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "short read receiving AuthResponse: l=%u\n",
<                rv);
<     } else {
---
> #line 4787
>   if (pi.size != resp_size) {
> #line 4788
>     printk("\vd-con %s: expected AuthResponse payload of wrong size\n", tconn->name);
> #line 4789
>     rv = 0;
> #line 4790
>     goto fail;
>   } else {
29283,29284c30921,30926
<     }
< #line 4197
---
>   }
> #line 4793
>   err = drbd_recv_all_warn(tconn, (void *)response, (size_t )resp_size);
> #line 4794
>   if (err != 0) {
> #line 4795
29286c30928
< #line 4198
---
> #line 4796
29291,29295c30933,30937
< #line 4201
<   tmp___8 = kmalloc((size_t )resp_size, 16U);
< #line 4201
<   right_response = (char *)tmp___8;
< #line 4202
---
> #line 4799
>   tmp___10 = kmalloc((size_t )resp_size, 16U);
> #line 4799
>   right_response = (char *)tmp___10;
> #line 4800
29297,29299c30939,30941
< #line 4203
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "kmalloc of right_response failed\n");
< #line 4204
---
> #line 4801
>     printk("\vd-con %s: kmalloc of right_response failed\n", tconn->name);
> #line 4802
29301c30943
< #line 4205
---
> #line 4803
29306c30948
< #line 4208
---
> #line 4806
29308c30950
< #line 4210
---
> #line 4808
29310c30952
< #line 4211
---
> #line 4809
29312,29315c30954,30956
< #line 4212
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "crypto_hash_digest() failed with %d\n",
<             rv);
< #line 4213
---
> #line 4810
>     printk("\vd-con %s: crypto_hash_digest() failed with %d\n", tconn->name, rv);
> #line 4811
29317c30958
< #line 4214
---
> #line 4812
29322,29326c30963,30967
< #line 4217
<   tmp___9 = memcmp((void const   *)response, (void const   *)right_response, (size_t )resp_size);
< #line 4217
<   rv = tmp___9 == 0;
< #line 4219
---
> #line 4815
>   tmp___11 = memcmp((void const   *)response, (void const   *)right_response, (size_t )resp_size);
> #line 4815
>   rv = tmp___11 == 0;
> #line 4817
29328,29330c30969,30971
< #line 4220
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Peer authenticated using %d bytes of \'%s\' HMAC\n",
<               resp_size, (unsigned char *)(& (mdev->net_conf)->cram_hmac_alg));
---
> #line 4818
>     printk("\016d-con %s: Peer authenticated using %d bytes HMAC\n", tconn->name,
>            resp_size);
29332c30973
< #line 4223
---
> #line 4821
29336c30977
< #line 4226
---
> #line 4824
29338c30979
< #line 4227
---
> #line 4825
29340c30981
< #line 4228
---
> #line 4826
29342c30983
< #line 4230
---
> #line 4828
29346c30987
< #line 4234 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 4832 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
29349,29351c30990
<   struct drbd_conf *mdev ;
<   unsigned int minor ;
<   unsigned int tmp ;
---
>   struct drbd_tconn *tconn ;
29353d30991
<   struct task_struct *tmp___0 ;
29356d30993
<   int tmp___1 ;
29359,29374c30996,31003
< #line 4236
<   mdev = thi->mdev;
< #line 4237
<   tmp = mdev_to_minor(mdev);
< #line 4237
<   minor = tmp;
< #line 4240
<   tmp___0 = get_current();
< #line 4240
<   sprintf((char *)(& tmp___0->comm), "drbd%d_receiver", minor);
< #line 4242
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "receiver (re)started\n");
<   ldv_53014: 
< #line 4245
<   h = drbd_connect(mdev);
< #line 4246
---
> #line 4834
>   tconn = thi->tconn;
> #line 4837
>   printk("\016d-con %s: receiver (re)started\n", tconn->name);
>   ldv_53786: 
> #line 4840
>   h = conn_connect(tconn);
> #line 4841
29376,29378c31005,31007
< #line 4247
<     drbd_disconnect(mdev);
< #line 4248
---
> #line 4842
>     conn_disconnect(tconn);
> #line 4843
29383c31012
< #line 4250
---
> #line 4845
29385,29387c31014,31016
< #line 4251
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Discarding network configuration.\n");
< #line 4252
---
> #line 4846
>     printk("\fd-con %s: Discarding network configuration.\n", tconn->name);
> #line 4847
29389,29391c31018,31020
< #line 4252
<     val.ldv_40583.conn = 1U;
< #line 4252
---
> #line 4847
>     val.ldv_40604.conn = 1U;
> #line 4847
29393,29396c31022,31025
< #line 4252
<     mask.ldv_40583.conn = 31U;
< #line 4252
<     drbd_force_state(mdev, mask, val);
---
> #line 4847
>     mask.ldv_40604.conn = 31U;
> #line 4847
>     conn_request_state(tconn, mask, val, CS_HARD);
29400c31029
< #line 4254
---
> #line 4849
29402,29403c31031,31032
< #line 4255
<     goto ldv_53014;
---
> #line 4850
>     goto ldv_53786;
29408c31037
< #line 4256
---
> #line 4851
29410,29420c31039,31040
< #line 4257
<     tmp___1 = get_net_conf(mdev);
< #line 4257
<     if (tmp___1 != 0) {
< #line 4258
<       drbdd(mdev);
< #line 4259
<       put_net_conf(mdev);
<     } else {
< 
<     }
---
> #line 4852
>     drbdd(tconn);
29424,29428c31044,31048
< #line 4263
<   drbd_disconnect(mdev);
< #line 4265
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "receiver terminated\n");
< #line 4266
---
> #line 4854
>   conn_disconnect(tconn);
> #line 4856
>   printk("\016d-con %s: receiver terminated\n", tconn->name);
> #line 4857
29432,29433c31052,31053
< #line 4271 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int got_RqSReply(struct drbd_conf *mdev , struct p_header80 *h ) 
---
> #line 4862 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_conn_RqSReply(struct drbd_tconn *tconn , struct packet_info *pi ) 
29441,29443c31061,31063
< #line 4273
<   p = (struct p_req_state_reply *)h;
< #line 4275
---
> #line 4864
>   p = (struct p_req_state_reply *)pi->data;
> #line 4865
29445c31065
< #line 4275
---
> #line 4865
29447c31067
< #line 4277
---
> #line 4867
29449,29450c31069,31070
< #line 4278
<     drbd_set_flag(mdev, CL_ST_CHG_SUCCESS);
---
> #line 4868
>     set_bit(6U, (unsigned long volatile   *)(& tconn->flags));
29452,29454c31072,31074
< #line 4280
<     drbd_set_flag(mdev, CL_ST_CHG_FAIL);
< #line 4281
---
> #line 4870
>     set_bit(7U, (unsigned long volatile   *)(& tconn->flags));
> #line 4871
29456c31076,31142
< #line 4281
---
> #line 4871
>     printk("\vd-con %s: Requested state change failed by peer: %s (%d)\n", tconn->name,
>            tmp___0, retcode);
>   }
> #line 4874
>   __wake_up(& tconn->ping_wait, 3U, 1, 0);
> #line 4876
>   return (0);
> }
> }
> #line 4879 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_RqSReply(struct drbd_tconn *tconn , struct packet_info *pi ) 
> { 
>   struct drbd_conf *mdev ;
>   struct p_req_state_reply *p ;
>   int retcode ;
>   __u32 tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   char const   *tmp___2 ;
> 
>   {
> #line 4882
>   p = (struct p_req_state_reply *)pi->data;
> #line 4883
>   tmp = __fswab32(p->retcode);
> #line 4883
>   retcode = (int )tmp;
> #line 4885
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 4886
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 4887
>     return (-5);
>   } else {
> 
>   }
> #line 4889
>   tmp___1 = constant_test_bit(5U, (unsigned long const volatile   *)(& tconn->flags));
> #line 4889
>   if (tmp___1 != 0) {
> #line 4890
>     if (tconn->agreed_pro_version > 99) {
> #line 4890
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( tconn->agreed_pro_version < 100 ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>               4890);
>     } else {
> 
>     }
> #line 4891
>     tmp___0 = got_conn_RqSReply(tconn, pi);
> #line 4891
>     return (tmp___0);
>   } else {
> 
>   }
> #line 4894
>   if (retcode > 0) {
> #line 4895
>     set_bit(3U, (unsigned long volatile   *)(& mdev->flags));
>   } else {
> #line 4897
>     set_bit(4U, (unsigned long volatile   *)(& mdev->flags));
> #line 4898
>     tmp___2 = drbd_set_st_err_str((enum drbd_state_rv )retcode);
> #line 4898
29458c31144
<             tmp___0, retcode);
---
>             tmp___2, retcode);
29460c31146
< #line 4284
---
> #line 4901
29462,29463c31148,31149
< #line 4286
<   return (1);
---
> #line 4903
>   return (0);
29466,29467c31152,31153
< #line 4289 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int got_Ping(struct drbd_conf *mdev , struct p_header80 *h ) 
---
> #line 4906 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_Ping(struct drbd_tconn *tconn , struct packet_info *pi ) 
29472,29474c31158,31160
< #line 4291
<   tmp = drbd_send_ping_ack(mdev);
< #line 4291
---
> #line 4908
>   tmp = drbd_send_ping_ack(tconn);
> #line 4908
29478,29479c31164,31165
< #line 4295 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int got_PingAck(struct drbd_conf *mdev , struct p_header80 *h ) 
---
> #line 4912 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_PingAck(struct drbd_tconn *tconn , struct packet_info *pi ) 
29484,29488c31170,31174
< #line 4298
<   ((mdev->meta.socket)->sk)->sk_rcvtimeo = (long )((mdev->net_conf)->ping_int * 250);
< #line 4299
<   tmp = drbd_test_and_set_flag(mdev, GOT_PING_ACK);
< #line 4299
---
> #line 4915
>   ((tconn->meta.socket)->sk)->sk_rcvtimeo = (long )((tconn->net_conf)->ping_int * 250U);
> #line 4916
>   tmp = test_and_set_bit(4, (unsigned long volatile   *)(& tconn->flags));
> #line 4916
29490,29491c31176,31177
< #line 4300
<     __wake_up(& mdev->misc_wait, 3U, 1, 0);
---
> #line 4917
>     __wake_up(& tconn->ping_wait, 3U, 1, 0);
29495,29496c31181,31182
< #line 4302
<   return (1);
---
> #line 4919
>   return (0);
29499,29500c31185,31186
< #line 4305 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int got_IsInSync(struct drbd_conf *mdev , struct p_header80 *h ) 
---
> #line 4922 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_IsInSync(struct drbd_tconn *tconn , struct packet_info *pi ) 
29501a31188
>   struct drbd_conf *mdev ;
29509,29510d31195
<   int tmp___3 ;
<   int tmp___4 ;
29513,29515c31198,31200
< #line 4307
<   p = (struct p_block_ack *)h;
< #line 4308
---
> #line 4925
>   p = (struct p_block_ack *)pi->data;
> #line 4926
29517c31202
< #line 4308
---
> #line 4926
29519c31204
< #line 4309
---
> #line 4927
29521c31206
< #line 4309
---
> #line 4927
29523,29528c31208,31222
< #line 4311
<   if (mdev->agreed_pro_version <= 88) {
< #line 4311
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->agreed_pro_version >= 89 ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             4311);
---
> #line 4929
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 4930
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 4931
>     return (-5);
>   } else {
> 
>   }
> #line 4933
>   if ((mdev->tconn)->agreed_pro_version <= 88) {
> #line 4933
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->tconn->agreed_pro_version >= 89 ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>             4933);
29532c31226
< #line 4313
---
> #line 4935
29534c31228
< #line 4313
---
> #line 4935
29536c31230
< #line 4315
---
> #line 4937
29538c31232
< #line 4315
---
> #line 4937
29540c31234
< #line 4316
---
> #line 4938
29542,29545c31236,31239
< #line 4317
<     __drbd_set_in_sync(mdev, sector, blksize, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                        4317U);
< #line 4319
---
> #line 4939
>     __drbd_set_in_sync(mdev, sector, blksize, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                        4939U);
> #line 4941
29547c31241
< #line 4320
---
> #line 4942
29552,29566c31246,31248
< #line 4322
<   atomic_dec(& mdev->rs_pending_cnt);
< #line 4322
<   tmp___4 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 4322
<   if (tmp___4 < 0) {
< #line 4322
<     tmp___3 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 4322
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
<             "got_IsInSync", 4322, tmp___3);
<   } else {
< 
<   }
< #line 4323
---
> #line 4944
>   _dec_rs_pending(mdev, "got_IsInSync", 4944);
> #line 4945
29568,29629c31250
< #line 4325
<   return (1);
< }
< }
< #line 4330 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static struct drbd_request *_ack_id_to_req(struct drbd_conf *mdev , u64 id , sector_t sector ) 
< { 
<   struct hlist_head *slot ;
<   struct hlist_head *tmp ;
<   struct hlist_node *n ;
<   struct drbd_request *req ;
<   struct hlist_node  const  *__mptr ;
< 
<   {
< #line 4333
<   tmp = tl_hash_slot(mdev, sector);
< #line 4333
<   slot = tmp;
< #line 4337
<   n = slot->first;
< #line 4337
<   goto ldv_53054;
<   ldv_53053: ;
< #line 4338
<   if ((unsigned long )req == (unsigned long )id) {
< #line 4339
<     if (req->sector != sector) {
< #line 4340
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "_ack_id_to_req: found req %p but it has wrong sector (%llus versus %llus)\n",
<               req, (unsigned long long )req->sector, (unsigned long long )sector);
< #line 4344
<       goto ldv_53052;
<     } else {
< 
<     }
< #line 4346
<     return (req);
<   } else {
< 
<   }
< #line 4337
<   n = n->next;
<   ldv_53054: ;
< #line 4337
<   if ((unsigned long )n != (unsigned long )((struct hlist_node *)0)) {
< #line 4337
<     __mptr = (struct hlist_node  const  *)n;
< #line 4337
<     req = (struct drbd_request *)__mptr + 0xffffffffffffffd8UL;
< #line 4337
<     if (1 != 0) {
< #line 4338
<       goto ldv_53053;
<     } else {
< #line 4340
<       goto ldv_53052;
<     }
<   } else {
< 
<   }
<   ldv_53052: ;
< #line 4349
---
> #line 4947
29633c31254
< #line 4355 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 4951 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
29635,29636c31256,31257
<                                          req_validator_fn *validator , char const   *func ,
<                                          enum drbd_req_event what ) 
---
>                                          struct rb_root *root , char const   *func ,
>                                          enum drbd_req_event what , bool missing_ok ) 
29643,29647c31264,31268
< #line 4362
<   spin_lock_irq(& mdev->req_lock);
< #line 4363
<   req = (*validator)(mdev, id, sector);
< #line 4364
---
> #line 4958
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 4959
>   req = find_request(mdev, root, id, sector, (int )missing_ok, func);
> #line 4960
29650c31271
< #line 4364
---
> #line 4960
29652,29658c31273,31276
< #line 4365
<     spin_unlock_irq(& mdev->req_lock);
< #line 4367
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s: failed to find req %p, sector %llus\n",
<             func, (void *)id, (unsigned long long )sector);
< #line 4369
<     return (0);
---
> #line 4961
>     spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 4962
>     return (-5);
29662c31280
< #line 4371
---
> #line 4964
29664,29666c31282,31284
< #line 4372
<   spin_unlock_irq(& mdev->req_lock);
< #line 4374
---
> #line 4965
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 4967
29668c31286
< #line 4375
---
> #line 4968
29673,29674c31291,31292
< #line 4376
<   return (1);
---
> #line 4969
>   return (0);
29677,29678c31295,31296
< #line 4379 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int got_BlockAck(struct drbd_conf *mdev , struct p_header80 *h ) 
---
> #line 4972 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_BlockAck(struct drbd_tconn *tconn , struct packet_info *pi ) 
29679a31298
>   struct drbd_conf *mdev ;
29688,29690d31306
<   int tmp___3 ;
<   __u16 tmp___4 ;
<   int tmp___5 ;
29693,29695c31309,31311
< #line 4381
<   p = (struct p_block_ack *)h;
< #line 4382
---
> #line 4975
>   p = (struct p_block_ack *)pi->data;
> #line 4976
29697c31313
< #line 4382
---
> #line 4976
29699c31315
< #line 4383
---
> #line 4977
29701c31317
< #line 4383
---
> #line 4977
29703,29769c31319,31324
< #line 4386
<   tmp___1 = __fswab32(p->seq_num);
< #line 4386
<   update_peer_seq(mdev, tmp___1);
< #line 4388
<   if (p->block_id == 0xffffffffffffffffULL) {
< #line 4389
<     __drbd_set_in_sync(mdev, sector, blksize, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                        4389U);
< #line 4390
<     atomic_dec(& mdev->rs_pending_cnt);
< #line 4390
<     tmp___3 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 4390
<     if (tmp___3 < 0) {
< #line 4390
<       tmp___2 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 4390
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
<               "got_BlockAck", 4390, tmp___2);
<     } else {
< 
<     }
< #line 4391
<     return (1);
<   } else {
< 
<   }
< #line 4393
<   tmp___4 = __fswab16((int )h->command);
< #line 4393
<   switch ((int )tmp___4) {
<   case 23: ;
< #line 4395
<   if ((mdev->net_conf)->wire_protocol != 3) {
< #line 4395
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->net_conf->wire_protocol == DRBD_PROT_C ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             4395);
<   } else {
< 
<   }
< #line 4396
<   what = write_acked_by_peer_and_sis;
< #line 4397
<   goto ldv_53082;
<   case 22: ;
< #line 4399
<   if ((mdev->net_conf)->wire_protocol != 3) {
< #line 4399
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->net_conf->wire_protocol == DRBD_PROT_C ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             4399);
<   } else {
< 
<   }
< #line 4400
<   what = write_acked_by_peer;
< #line 4401
<   goto ldv_53082;
<   case 21: ;
< #line 4403
<   if ((mdev->net_conf)->wire_protocol != 2) {
< #line 4403
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->net_conf->wire_protocol == DRBD_PROT_B ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             4403);
---
> #line 4980
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 4981
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 4982
>     return (-5);
29773,29783c31328,31340
< #line 4404
<   what = recv_acked_by_peer;
< #line 4405
<   goto ldv_53082;
<   case 24: ;
< #line 4407
<   if ((mdev->net_conf)->wire_protocol != 3) {
< #line 4407
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->net_conf->wire_protocol == DRBD_PROT_C ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             4407);
---
> #line 4984
>   tmp___1 = __fswab32(p->seq_num);
> #line 4984
>   update_peer_seq(mdev, tmp___1);
> #line 4986
>   if (p->block_id == 0xffffffffffffffffULL) {
> #line 4987
>     __drbd_set_in_sync(mdev, sector, blksize, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                        4987U);
> #line 4988
>     _dec_rs_pending(mdev, "got_BlockAck", 4988);
> #line 4989
>     return (0);
29787,29804c31344,31384
< #line 4408
<   what = conflict_discarded_by_peer;
< #line 4409
<   goto ldv_53082;
<   default: 
< #line 4411
<   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( 0 ) in %s:%d\n",
<           (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<           4411);
< #line 4412
<   return (0);
<   }
<   ldv_53082: 
< #line 4415
<   tmp___5 = validate_req_change_req_state(mdev, p->block_id, sector, & _ack_id_to_req,
<                                           "got_BlockAck", what);
< #line 4415
<   return (tmp___5);
---
> #line 4991
>   switch ((unsigned int )pi->cmd) {
>   case 23U: 
> #line 4993
>   what = WRITE_ACKED_BY_PEER_AND_SIS;
> #line 4994
>   goto ldv_53840;
>   case 22U: 
> #line 4996
>   what = WRITE_ACKED_BY_PEER;
> #line 4997
>   goto ldv_53840;
>   case 21U: 
> #line 4999
>   what = RECV_ACKED_BY_PEER;
> #line 5000
>   goto ldv_53840;
>   case 24U: 
> #line 5002
>   what = CONFLICT_RESOLVED;
> #line 5003
>   goto ldv_53840;
>   case 44U: 
> #line 5005
>   what = POSTPONE_WRITE;
> #line 5006
>   goto ldv_53840;
>   default: 
> #line 5008
>   __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
>                        "i" (5008), "i" (12UL));
>   ldv_53846: ;
> #line 5008
>   goto ldv_53846;
>   }
>   ldv_53840: 
> #line 5011
>   tmp___2 = validate_req_change_req_state(mdev, p->block_id, sector, & mdev->write_requests,
>                                           "got_BlockAck", what, 0);
> #line 5011
>   return (tmp___2);
29807,29808c31387,31388
< #line 4419 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int got_NegAck(struct drbd_conf *mdev , struct p_header80 *h ) 
---
> #line 5016 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_NegAck(struct drbd_tconn *tconn , struct packet_info *pi ) 
29809a31390
>   struct drbd_conf *mdev ;
29815,29816c31396
<   struct drbd_request *req ;
<   struct bio_and_error m ;
---
>   int err ;
29818,29819d31397
<   int tmp___2 ;
<   int tmp___3 ;
29822,29824c31400,31402
< #line 4421
<   p = (struct p_block_ack *)h;
< #line 4422
---
> #line 5019
>   p = (struct p_block_ack *)pi->data;
> #line 5020
29826c31404
< #line 4422
---
> #line 5020
29828c31406
< #line 4423
---
> #line 5021
29830c31408
< #line 4423
---
> #line 5021
29832c31410,31419
< #line 4427
---
> #line 5024
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 5025
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 5026
>     return (-5);
>   } else {
> 
>   }
> #line 5028
29834c31421
< #line 4427
---
> #line 5028
29836c31423
< #line 4429
---
> #line 5030
29838,29852c31425,31427
< #line 4430
<     atomic_dec(& mdev->rs_pending_cnt);
< #line 4430
<     tmp___3 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 4430
<     if (tmp___3 < 0) {
< #line 4430
<       tmp___2 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 4430
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
<               "got_NegAck", 4430, tmp___2);
<     } else {
< 
<     }
< #line 4431
---
> #line 5031
>     _dec_rs_pending(mdev, "got_NegAck", 5031);
> #line 5032
29854,29880c31429,31430
< #line 4432
<     return (1);
<   } else {
< 
<   }
< #line 4435
<   spin_lock_irq(& mdev->req_lock);
< #line 4436
<   req = _ack_id_to_req(mdev, p->block_id, sector);
< #line 4437
<   if ((unsigned long )req == (unsigned long )((struct drbd_request *)0)) {
< #line 4438
<     spin_unlock_irq(& mdev->req_lock);
< #line 4439
<     if ((mdev->net_conf)->wire_protocol == 1 || (mdev->net_conf)->wire_protocol == 2) {
< #line 4447
<       __drbd_set_out_of_sync(mdev, sector, size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<                              4447U);
< #line 4448
<       return (1);
<     } else {
< #line 4450
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s: failed to find req %p, sector %llus\n",
<               "got_NegAck", (void *)p->block_id, (unsigned long long )sector);
< #line 4452
<       return (0);
<     }
---
> #line 5033
>     return (0);
29884,29891c31434,31441
< #line 4455
<   __req_mod(req, neg_acked, & m);
< #line 4456
<   spin_unlock_irq(& mdev->req_lock);
< #line 4458
<   if ((unsigned long )m.bio != (unsigned long )((struct bio *)0)) {
< #line 4459
<     complete_master_bio(mdev, & m);
---
> #line 5036
>   err = validate_req_change_req_state(mdev, p->block_id, sector, & mdev->write_requests,
>                                       "got_NegAck", NEG_ACKED, 1);
> #line 5039
>   if (err != 0) {
> #line 5045
>     __drbd_set_out_of_sync(mdev, sector, size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                            5045U);
29895,29896c31445,31446
< #line 4460
<   return (1);
---
> #line 5047
>   return (0);
29899,29900c31449,31450
< #line 4463 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int got_NegDReply(struct drbd_conf *mdev , struct p_header80 *h ) 
---
> #line 5050 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_NegDReply(struct drbd_tconn *tconn , struct packet_info *pi ) 
29901a31452
>   struct drbd_conf *mdev ;
29910,29912c31461,31463
< #line 4465
<   p = (struct p_block_ack *)h;
< #line 4466
---
> #line 5053
>   p = (struct p_block_ack *)pi->data;
> #line 5054
29914c31465
< #line 4466
---
> #line 5054
29916c31467,31476
< #line 4468
---
> #line 5056
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 5057
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 5058
>     return (-5);
>   } else {
> 
>   }
> #line 5060
29918c31478
< #line 4468
---
> #line 5060
29920c31480
< #line 4469
---
> #line 5062
29922,29923c31482,31483
< #line 4469
<   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Got NegDReply; Sector %llus, len %u; Fail original request.\n",
---
> #line 5062
>   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Got NegDReply; Sector %llus, len %u.\n",
29925,29928c31485,31488
< #line 4472
<   tmp___2 = validate_req_change_req_state(mdev, p->block_id, sector, & _ar_id_to_req,
<                                           "got_NegDReply", neg_acked);
< #line 4472
---
> #line 5065
>   tmp___2 = validate_req_change_req_state(mdev, p->block_id, sector, & mdev->read_requests,
>                                           "got_NegDReply", NEG_ACKED, 0);
> #line 5065
29932,29933c31492,31493
< #line 4476 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int got_NegRSDReply(struct drbd_conf *mdev , struct p_header80 *h ) 
---
> #line 5070 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_NegRSDReply(struct drbd_tconn *tconn , struct packet_info *pi ) 
29934a31495
>   struct drbd_conf *mdev ;
29942,29944d31502
<   int tmp___3 ;
<   __u16 tmp___4 ;
<   int tmp___5 ;
29947,29949c31505,31516
< #line 4480
<   p = (struct p_block_ack *)h;
< #line 4482
---
> #line 5075
>   p = (struct p_block_ack *)pi->data;
> #line 5077
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 5078
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 5079
>     return (-5);
>   } else {
> 
>   }
> #line 5081
29951c31518
< #line 4482
---
> #line 5081
29953c31520
< #line 4483
---
> #line 5082
29955c31522
< #line 4483
---
> #line 5082
29957c31524
< #line 4485
---
> #line 5084
29959c31526
< #line 4485
---
> #line 5084
29961,29979c31528,31534
< #line 4487
<   atomic_dec(& mdev->rs_pending_cnt);
< #line 4487
<   tmp___3 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 4487
<   if (tmp___3 < 0) {
< #line 4487
<     tmp___2 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 4487
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
<             "got_NegRSDReply", 4487, tmp___2);
<   } else {
< 
<   }
< #line 4489
<   tmp___5 = _get_ldev_if_state(mdev, D_FAILED);
< #line 4489
<   if (tmp___5 != 0) {
< #line 4490
---
> #line 5086
>   _dec_rs_pending(mdev, "got_NegRSDReply", 5086);
> #line 5088
>   tmp___2 = _get_ldev_if_state(mdev, D_FAILED);
> #line 5088
>   if (tmp___2 != 0) {
> #line 5089
29981,29986c31536,31539
< #line 4491
<     tmp___4 = __fswab16((int )h->command);
< #line 4491
<     switch ((int )tmp___4) {
<     case 27: 
< #line 4493
---
> #line 5090
>     switch ((unsigned int )pi->cmd) {
>     case 27U: 
> #line 5092
29988,29990c31541,31543
<     case 41: ;
< #line 4495
<     goto ldv_53120;
---
>     case 41U: ;
> #line 5094
>     goto ldv_53876;
29992,29999c31545,31550
< #line 4497
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( 0 ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             4497);
< #line 4498
<     put_ldev(mdev);
< #line 4499
<     return (0);
---
> #line 5096
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"),
>                          "i" (5096), "i" (12UL));
>     ldv_53878: ;
> #line 5096
>     goto ldv_53878;
30001,30002c31552,31553
<     ldv_53120: 
< #line 4501
---
>     ldv_53876: 
> #line 5098
30007,30008c31558,31559
< #line 4504
<   return (1);
---
> #line 5101
>   return (0);
30011,30012c31562,31563
< #line 4507 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int got_BarrierAck(struct drbd_conf *mdev , struct p_header80 *h ) 
---
> #line 5104 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_BarrierAck(struct drbd_tconn *tconn , struct packet_info *pi ) 
30014a31566,31567
>   struct drbd_conf *mdev ;
>   int vnr ;
30016c31569
<   int tmp___0 ;
---
>   void *tmp___0 ;
30017a31571,31572
>   int tmp___2 ;
>   void *tmp___3 ;
30020,30022c31575,31577
< #line 4509
<   p = (struct p_barrier_ack *)h;
< #line 4511
---
> #line 5106
>   p = (struct p_barrier_ack *)pi->data;
> #line 5110
30024,30036c31579,31602
< #line 4511
<   tl_release(mdev, p->barrier, tmp);
< #line 4513
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 352U) {
< #line 4513
<     tmp___0 = atomic_read((atomic_t const   *)(& mdev->ap_in_flight));
< #line 4513
<     if (tmp___0 == 0) {
< #line 4513
<       tmp___1 = drbd_test_and_set_flag(mdev, AHEAD_TO_SYNC_SOURCE);
< #line 4513
<       if (tmp___1 == 0) {
< #line 4516
---
> #line 5110
>   tl_release(tconn, p->barrier, tmp);
> #line 5112
>   rcu_read_lock();
> #line 5113
>   vnr = 0;
> #line 5113
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 5113
>   mdev = (struct drbd_conf *)tmp___0;
> #line 5113
>   goto ldv_53887;
>   ldv_53886: ;
> #line 5114
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 352U) {
> #line 5114
>     tmp___1 = atomic_read((atomic_t const   *)(& mdev->ap_in_flight));
> #line 5114
>     if (tmp___1 == 0) {
> #line 5114
>       tmp___2 = test_and_set_bit(19, (unsigned long volatile   *)(& mdev->flags));
> #line 5114
>       if (tmp___2 == 0) {
> #line 5117
30038c31604
< #line 4517
---
> #line 5118
30049,30050c31615,31632
< #line 4520
<   return (1);
---
> #line 5113
>   vnr = vnr + 1;
> #line 5113
>   tmp___3 = idr_get_next(& tconn->volumes, & vnr);
> #line 5113
>   mdev = (struct drbd_conf *)tmp___3;
>   ldv_53887: ;
> #line 5113
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 5114
>     goto ldv_53886;
>   } else {
> 
>   }
> #line 5121
>   rcu_read_unlock();
> #line 5123
>   return (0);
30053,30054c31635,31636
< #line 4523 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int got_OVResult(struct drbd_conf *mdev , struct p_header80 *h ) 
---
> #line 5126 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_OVResult(struct drbd_tconn *tconn , struct packet_info *pi ) 
30055a31638
>   struct drbd_conf *mdev ;
30065,30067c31648
<   int tmp___4 ;
<   int tmp___5 ;
<   void *tmp___6 ;
---
>   void *tmp___4 ;
30070,30072c31651,31662
< #line 4525
<   p = (struct p_block_ack *)h;
< #line 4530
---
> #line 5129
>   p = (struct p_block_ack *)pi->data;
> #line 5134
>   mdev = vnr_to_mdev(tconn, (int )pi->vnr);
> #line 5135
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 5136
>     return (-5);
>   } else {
> 
>   }
> #line 5138
30074c31664
< #line 4530
---
> #line 5138
30076c31666
< #line 4531
---
> #line 5139
30078c31668
< #line 4531
---
> #line 5139
30080c31670
< #line 4533
---
> #line 5141
30082c31672
< #line 4533
---
> #line 5141
30084c31674
< #line 4535
---
> #line 5143
30086c31676
< #line 4535
---
> #line 5143
30088,30089c31678,31679
< #line 4536
<     drbd_ov_oos_found(mdev, sector, size);
---
> #line 5144
>     drbd_ov_out_of_sync_found(mdev, sector, size);
30091,30092c31681,31682
< #line 4538
<     ov_oos_print(mdev);
---
> #line 5146
>     ov_out_of_sync_print(mdev);
30094c31684
< #line 4540
---
> #line 5148
30096c31686
< #line 4540
---
> #line 5148
30098,30099c31688,31689
< #line 4541
<     return (1);
---
> #line 5149
>     return (0);
30103c31693
< #line 4543
---
> #line 5151
30105,30119c31695,31697
< #line 4544
<   atomic_dec(& mdev->rs_pending_cnt);
< #line 4544
<   tmp___5 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 4544
<   if (tmp___5 < 0) {
< #line 4544
<     tmp___4 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
< #line 4544
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: rs_pending_cnt = %d < 0 !\n",
<             "got_OVResult", 4544, tmp___4);
<   } else {
< 
<   }
< #line 4546
---
> #line 5152
>   _dec_rs_pending(mdev, "got_OVResult", 5152);
> #line 5154
30121c31699
< #line 4549
---
> #line 5157
30123c31701
< #line 4550
---
> #line 5158
30128c31706
< #line 4552
---
> #line 5160
30130,30134c31708,31712
< #line 4553
<     tmp___6 = kmalloc(24UL, 16U);
< #line 4553
<     w = (struct drbd_work *)tmp___6;
< #line 4554
---
> #line 5161
>     tmp___4 = kmalloc(32UL, 16U);
> #line 5161
>     w = (struct drbd_work *)tmp___4;
> #line 5162
30136c31714
< #line 4555
---
> #line 5163
30138,30139c31716,31719
< #line 4556
<       drbd_queue_work_front(& mdev->data.work, w);
---
> #line 5164
>       w->ldv_50388.mdev = mdev;
> #line 5165
>       drbd_queue_work(& (mdev->tconn)->sender_work, w);
30141c31721
< #line 4558
---
> #line 5167
30143,30145c31723,31725
< #line 4559
<       ov_oos_print(mdev);
< #line 4560
---
> #line 5168
>       ov_out_of_sync_print(mdev);
> #line 5169
30151c31731
< #line 4563
---
> #line 5172
30153,30154c31733,31734
< #line 4564
<   return (1);
---
> #line 5173
>   return (0);
30157,30158c31737,31738
< #line 4567 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static int got_skip(struct drbd_conf *mdev , struct p_header80 *h ) 
---
> #line 5176 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int got_skip(struct drbd_tconn *tconn , struct packet_info *pi ) 
30163,30164c31743,31744
< #line 4569
<   return (1);
---
> #line 5178
>   return (0);
30167,30168c31747,31748
< #line 4577 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< static struct asender_cmd *get_asender_cmd(int cmd ) 
---
> #line 5181 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static int tconn_finish_peer_reqs(struct drbd_tconn *tconn ) 
30170c31750,31759
<   struct asender_cmd asender_tbl[43U] ;
---
>   struct drbd_conf *mdev ;
>   int vnr ;
>   int not_empty ;
>   struct task_struct *tmp ;
>   void *tmp___0 ;
>   int tmp___1 ;
>   void *tmp___2 ;
>   void *tmp___3 ;
>   int tmp___4 ;
>   void *tmp___5 ;
30173,30349c31762,31861
< #line 4579
<   asender_tbl[0].pkt_size = 0UL;
< #line 4579
<   asender_tbl[0].process = 0;
< #line 4579
<   asender_tbl[1].pkt_size = 0UL;
< #line 4579
<   asender_tbl[1].process = 0;
< #line 4579
<   asender_tbl[2].pkt_size = 0UL;
< #line 4579
<   asender_tbl[2].process = 0;
< #line 4579
<   asender_tbl[3].pkt_size = 0UL;
< #line 4579
<   asender_tbl[3].process = 0;
< #line 4579
<   asender_tbl[4].pkt_size = 0UL;
< #line 4579
<   asender_tbl[4].process = 0;
< #line 4579
<   asender_tbl[5].pkt_size = 0UL;
< #line 4579
<   asender_tbl[5].process = 0;
< #line 4579
<   asender_tbl[6].pkt_size = 0UL;
< #line 4579
<   asender_tbl[6].process = 0;
< #line 4579
<   asender_tbl[7].pkt_size = 0UL;
< #line 4579
<   asender_tbl[7].process = 0;
< #line 4579
<   asender_tbl[8].pkt_size = 0UL;
< #line 4579
<   asender_tbl[8].process = 0;
< #line 4579
<   asender_tbl[9].pkt_size = 0UL;
< #line 4579
<   asender_tbl[9].process = 0;
< #line 4579
<   asender_tbl[10].pkt_size = 0UL;
< #line 4579
<   asender_tbl[10].process = 0;
< #line 4579
<   asender_tbl[11].pkt_size = 0UL;
< #line 4579
<   asender_tbl[11].process = 0;
< #line 4579
<   asender_tbl[12].pkt_size = 0UL;
< #line 4579
<   asender_tbl[12].process = 0;
< #line 4579
<   asender_tbl[13].pkt_size = 0UL;
< #line 4579
<   asender_tbl[13].process = 0;
< #line 4579
<   asender_tbl[14].pkt_size = 0UL;
< #line 4579
<   asender_tbl[14].process = 0;
< #line 4579
<   asender_tbl[15].pkt_size = 0UL;
< #line 4579
<   asender_tbl[15].process = 0;
< #line 4579
<   asender_tbl[16].pkt_size = 0UL;
< #line 4579
<   asender_tbl[16].process = 0;
< #line 4579
<   asender_tbl[17].pkt_size = 0UL;
< #line 4579
<   asender_tbl[17].process = 0;
< #line 4579
<   asender_tbl[18].pkt_size = 0UL;
< #line 4579
<   asender_tbl[18].process = 0;
< #line 4579
<   asender_tbl[19].pkt_size = 8UL;
< #line 4579
<   asender_tbl[19].process = & got_Ping;
< #line 4579
<   asender_tbl[20].pkt_size = 8UL;
< #line 4579
<   asender_tbl[20].process = & got_PingAck;
< #line 4579
<   asender_tbl[21].pkt_size = 32UL;
< #line 4579
<   asender_tbl[21].process = & got_BlockAck;
< #line 4579
<   asender_tbl[22].pkt_size = 32UL;
< #line 4579
<   asender_tbl[22].process = & got_BlockAck;
< #line 4579
<   asender_tbl[23].pkt_size = 32UL;
< #line 4579
<   asender_tbl[23].process = & got_BlockAck;
< #line 4579
<   asender_tbl[24].pkt_size = 32UL;
< #line 4579
<   asender_tbl[24].process = & got_BlockAck;
< #line 4579
<   asender_tbl[25].pkt_size = 32UL;
< #line 4579
<   asender_tbl[25].process = & got_NegAck;
< #line 4579
<   asender_tbl[26].pkt_size = 32UL;
< #line 4579
<   asender_tbl[26].process = & got_NegDReply;
< #line 4579
<   asender_tbl[27].pkt_size = 32UL;
< #line 4579
<   asender_tbl[27].process = & got_NegRSDReply;
< #line 4579
<   asender_tbl[28].pkt_size = 16UL;
< #line 4579
<   asender_tbl[28].process = & got_BarrierAck;
< #line 4579
<   asender_tbl[29].pkt_size = 12UL;
< #line 4579
<   asender_tbl[29].process = & got_RqSReply;
< #line 4579
<   asender_tbl[30].pkt_size = 0UL;
< #line 4579
<   asender_tbl[30].process = 0;
< #line 4579
<   asender_tbl[31].pkt_size = 0UL;
< #line 4579
<   asender_tbl[31].process = 0;
< #line 4579
<   asender_tbl[32].pkt_size = 32UL;
< #line 4579
<   asender_tbl[32].process = & got_OVResult;
< #line 4579
<   asender_tbl[33].pkt_size = 0UL;
< #line 4579
<   asender_tbl[33].process = 0;
< #line 4579
<   asender_tbl[34].pkt_size = 32UL;
< #line 4579
<   asender_tbl[34].process = & got_IsInSync;
< #line 4579
<   asender_tbl[35].pkt_size = 0UL;
< #line 4579
<   asender_tbl[35].process = 0;
< #line 4579
<   asender_tbl[36].pkt_size = 0UL;
< #line 4579
<   asender_tbl[36].process = 0;
< #line 4579
<   asender_tbl[37].pkt_size = 0UL;
< #line 4579
<   asender_tbl[37].process = 0;
< #line 4579
<   asender_tbl[38].pkt_size = 0UL;
< #line 4579
<   asender_tbl[38].process = 0;
< #line 4579
<   asender_tbl[39].pkt_size = 16UL;
< #line 4579
<   asender_tbl[39].process = & got_skip;
< #line 4579
<   asender_tbl[40].pkt_size = 0UL;
< #line 4579
<   asender_tbl[40].process = 0;
< #line 4579
<   asender_tbl[41].pkt_size = 32UL;
< #line 4579
<   asender_tbl[41].process = & got_NegRSDReply;
< #line 4579
<   asender_tbl[42].pkt_size = 0UL;
< #line 4579
<   asender_tbl[42].process = 0;
< #line 4600
<   if (cmd > 42 || (unsigned long )asender_tbl[cmd].process == (unsigned long )((int (*)(struct drbd_conf * ,
<                                                                                         struct p_header80 * ))0)) {
< #line 4601
<     return (0);
---
> #line 5184
>   not_empty = 0;
>   ldv_53915: 
> #line 5187
>   clear_bit(3, (unsigned long volatile   *)(& tconn->flags));
> #line 5188
>   tmp = get_current();
> #line 5188
>   flush_signals(tmp);
> #line 5190
>   rcu_read_lock();
> #line 5191
>   vnr = 0;
> #line 5191
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 5191
>   mdev = (struct drbd_conf *)tmp___0;
> #line 5191
>   goto ldv_53910;
>   ldv_53909: 
> #line 5192
>   kref_get(& mdev->kref);
> #line 5193
>   rcu_read_unlock();
> #line 5194
>   tmp___1 = drbd_finish_peer_reqs(mdev);
> #line 5194
>   if (tmp___1 != 0) {
> #line 5195
>     kref_put(& mdev->kref, & drbd_minor_destroy);
> #line 5196
>     return (1);
>   } else {
> 
>   }
> #line 5198
>   kref_put(& mdev->kref, & drbd_minor_destroy);
> #line 5199
>   rcu_read_lock();
> #line 5191
>   vnr = vnr + 1;
> #line 5191
>   tmp___2 = idr_get_next(& tconn->volumes, & vnr);
> #line 5191
>   mdev = (struct drbd_conf *)tmp___2;
>   ldv_53910: ;
> #line 5191
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 5192
>     goto ldv_53909;
>   } else {
> 
>   }
> #line 5201
>   set_bit(3U, (unsigned long volatile   *)(& tconn->flags));
> #line 5203
>   spin_lock_irq(& tconn->req_lock);
> #line 5204
>   vnr = 0;
> #line 5204
>   tmp___3 = idr_get_next(& tconn->volumes, & vnr);
> #line 5204
>   mdev = (struct drbd_conf *)tmp___3;
> #line 5204
>   goto ldv_53914;
>   ldv_53913: 
> #line 5205
>   tmp___4 = list_empty((struct list_head  const  *)(& mdev->done_ee));
> #line 5205
>   not_empty = tmp___4 == 0;
> #line 5206
>   if (not_empty != 0) {
> #line 5207
>     goto ldv_53912;
>   } else {
> 
>   }
> #line 5204
>   vnr = vnr + 1;
> #line 5204
>   tmp___5 = idr_get_next(& tconn->volumes, & vnr);
> #line 5204
>   mdev = (struct drbd_conf *)tmp___5;
>   ldv_53914: ;
> #line 5204
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 5205
>     goto ldv_53913;
>   } else {
> 
>   }
>   ldv_53912: 
> #line 5209
>   spin_unlock_irq(& tconn->req_lock);
> #line 5210
>   rcu_read_unlock();
> #line 5211
>   if (not_empty != 0) {
> #line 5212
>     goto ldv_53915;
30353,30354c31865,31867
< #line 4602
<   return ((struct asender_cmd *)(& asender_tbl) + (unsigned long )cmd);
---
> 
> #line 5213
>   return (0);
30357c31870,31918
< #line 4605 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 5221 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
> static struct asender_cmd asender_tbl[45U]  = 
> #line 5221
>   {      {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, & got_Ping}, 
>         {0UL, & got_PingAck}, 
>         {24UL, & got_BlockAck}, 
>         {24UL, & got_BlockAck}, 
>         {24UL, & got_BlockAck}, 
>         {24UL, & got_BlockAck}, 
>         {24UL, & got_NegAck}, 
>         {24UL, & got_NegDReply}, 
>         {24UL, & got_NegRSDReply}, 
>         {8UL, & got_BarrierAck}, 
>         {4UL, & got_RqSReply}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {24UL, & got_OVResult}, 
>         {0UL, 0}, 
>         {24UL, & got_IsInSync}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {0UL, 0}, 
>         {8UL, & got_skip}, 
>         {0UL, 0}, 
>         {24UL, & got_NegRSDReply}, 
>         {0UL, 0}, 
>         {4UL, & got_conn_RqSReply}, 
>         {24UL, & got_BlockAck}};
> #line 5241 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
30360,30361c31921
<   struct drbd_conf *mdev ;
<   struct p_header80 *h ;
---
>   struct drbd_tconn *tconn ;
30362a31923
>   struct packet_info pi ;
30364d31924
<   int len ;
30367,30369c31927
<   int expect ;
<   int empty ;
<   int ping_timeout_active ;
---
>   unsigned int header_size ;
30370a31929,31934
>   int expect ;
>   bool ping_timeout_active ;
>   struct net_conf *nc ;
>   int ping_timeo ;
>   int tcp_cork ;
>   int ping_int ;
30373,30374c31937,31939
<   struct task_struct *tmp___2 ;
<   int _b ;
---
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___2 ;
30378,30382c31943,31946
<   struct task_struct *tmp___6 ;
<   int tmp___7 ;
<   struct task_struct *tmp___8 ;
<   int tmp___9 ;
<   struct task_struct *tmp___10 ;
---
>   int tmp___6 ;
>   struct task_struct *tmp___7 ;
>   int tmp___8 ;
>   struct task_struct *tmp___9 ;
30383a31948,31951
>   struct net_conf *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___10 ;
>   int tmp___11 ;
30386,30402c31954,31961
<   struct task_struct *tmp___11 ;
<   int tmp___12 ;
<   long tmp___13 ;
<   __u16 tmp___14 ;
<   __u16 tmp___15 ;
<   __u32 tmp___16 ;
<   long tmp___17 ;
<   __u16 tmp___18 ;
<   __u16 tmp___19 ;
<   __u16 tmp___20 ;
<   __u16 tmp___21 ;
<   __u32 tmp___22 ;
<   long tmp___23 ;
<   int _b___0 ;
<   int tmp___24 ;
<   struct asender_cmd *tmp___25 ;
<   enum drbd_thread_state tmp___26 ;
---
>   struct task_struct *tmp___12 ;
>   int tmp___13 ;
>   long tmp___14 ;
>   int tmp___15 ;
>   char const   *tmp___16 ;
>   bool err ;
>   int tmp___17 ;
>   enum drbd_thread_state tmp___18 ;
30409,30413c31968,31970
< #line 4607
<   mdev = thi->mdev;
< #line 4608
<   h = & mdev->meta.rbuf.header.h80;
< #line 4609
---
> #line 5243
>   tconn = thi->tconn;
> #line 5244
30415,30417c31972,31974
< #line 4612
<   buf = (void *)h;
< #line 4613
---
> #line 5247
>   buf = tconn->meta.rbuf;
> #line 5248
30419,30421c31976,31982
< #line 4614
<   expect = 8;
< #line 4616
---
> #line 5249
>   tmp = drbd_header_size(tconn);
> #line 5249
>   header_size = tmp;
> #line 5250
>   expect = (int )header_size;
> #line 5251
30423,30425c31984
< #line 4618
<   tmp = mdev_to_minor(mdev);
< #line 4618
---
> #line 5255
30427,30429c31986,31988
< #line 4618
<   sprintf((char *)(& tmp___0->comm), "drbd%d_asender", tmp);
< #line 4620
---
> #line 5255
>   tmp___0->policy = 2U;
> #line 5256
30431,30455c31990,32013
< #line 4620
<   tmp___1->policy = 2U;
< #line 4621
<   tmp___2 = get_current();
< #line 4621
<   tmp___2->rt_priority = 2U;
< #line 4623
<   goto ldv_53171;
<   ldv_53188: 
< #line 4624
<   drbd_thread_current_set_cpu(mdev);
< #line 4625
<   tmp___4 = drbd_test_and_clear_flag(mdev, SEND_PING);
< #line 4625
<   if (tmp___4 != 0) {
< #line 4626
<     tmp___3 = drbd_send_ping(mdev);
< #line 4626
<     _b = tmp___3 == 0;
< #line 4626
<     if (_b != 0) {
< #line 4626
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<               "drbd_asender", (char *)"!drbd_send_ping(mdev)", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               4626);
---
> #line 5256
>   tmp___1->rt_priority = 2U;
> #line 5258
>   goto ldv_53943;
>   ldv_53964: 
> #line 5259
>   drbd_thread_current_set_cpu(thi);
> #line 5261
>   rcu_read_lock();
> #line 5262
>   _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 5262
>   tmp___2 = debug_lockdep_rcu_enabled();
> #line 5262
>   if (tmp___2 != 0 && ! __warned) {
> #line 5262
>     tmp___3 = rcu_read_lock_held();
> #line 5262
>     if (tmp___3 == 0 && 1) {
> #line 5262
>       __warned = 1;
> #line 5262
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                              5262, "suspicious rcu_dereference_check() usage");
30459,30470c32017
< #line 4626
<     if (_b != 0) {
< #line 4626
<       goto reconnect;
<     } else {
< 
<     }
< #line 4627
<     ((mdev->meta.socket)->sk)->sk_rcvtimeo = (long )(((mdev->net_conf)->ping_timeo * 250) / 10);
< #line 4629
<     ping_timeout_active = 1;
<   } else {
---
>   } else {
30473,30480c32020,32041
< #line 4634
<   if ((unsigned int )*((unsigned char *)mdev->net_conf + 540UL) == 0U) {
< #line 4634
<     tmp___5 = atomic_read((atomic_t const   *)(& mdev->unacked_cnt));
< #line 4634
<     if (tmp___5 > 3) {
< #line 4636
<       drbd_tcp_cork(mdev->meta.socket);
---
> #line 5262
>   nc = _________p1;
> #line 5263
>   ping_timeo = (int )nc->ping_timeo;
> #line 5264
>   tcp_cork = (int )nc->tcp_cork;
> #line 5265
>   ping_int = (int )nc->ping_int;
> #line 5266
>   rcu_read_unlock();
> #line 5268
>   tmp___5 = test_and_clear_bit(2, (unsigned long volatile   *)(& tconn->flags));
> #line 5268
>   if (tmp___5 != 0) {
> #line 5269
>     tmp___4 = drbd_send_ping(tconn);
> #line 5269
>     if (tmp___4 != 0) {
> #line 5270
>       printk("\vd-con %s: drbd_send_ping has failed\n", tconn->name);
> #line 5271
>       goto reconnect;
30483a32045,32048
> #line 5273
>     ((tconn->meta.socket)->sk)->sk_rcvtimeo = (long )((ping_timeo * 250) / 10);
> #line 5274
>     ping_timeout_active = 1;
30487,30499c32052,32055
<   ldv_53170: 
< #line 4638
<   drbd_clear_flag(mdev, SIGNAL_ASENDER);
< #line 4639
<   tmp___6 = get_current();
< #line 4639
<   flush_signals(tmp___6);
< #line 4640
<   tmp___7 = drbd_process_done_ee(mdev);
< #line 4640
<   if (tmp___7 == 0) {
< #line 4641
<     goto reconnect;
---
> #line 5279
>   if (tcp_cork != 0) {
> #line 5280
>     drbd_tcp_cork(tconn->meta.socket);
30503,30514c32059,32066
< #line 4643
<   drbd_set_flag(mdev, SIGNAL_ASENDER);
< #line 4644
<   spin_lock_irq(& mdev->req_lock);
< #line 4645
<   empty = list_empty((struct list_head  const  *)(& mdev->done_ee));
< #line 4646
<   spin_unlock_irq(& mdev->req_lock);
< #line 4650
<   if (empty != 0) {
< #line 4651
<     goto ldv_53169;
---
> #line 5281
>   tmp___6 = tconn_finish_peer_reqs(tconn);
> #line 5281
>   if (tmp___6 != 0) {
> #line 5282
>     printk("\vd-con %s: tconn_finish_peer_reqs() failed\n", tconn->name);
> #line 5283
>     goto reconnect;
30518,30524c32070,32073
< #line 4652
<   goto ldv_53170;
<   ldv_53169: ;
< #line 4654
<   if ((unsigned int )*((unsigned char *)mdev->net_conf + 540UL) == 0U) {
< #line 4655
<     drbd_tcp_uncork(mdev->meta.socket);
---
> #line 5286
>   if (tcp_cork != 0) {
> #line 5287
>     drbd_tcp_uncork(tconn->meta.socket);
30528,30535c32077,32084
< #line 4658
<   tmp___8 = get_current();
< #line 4658
<   tmp___9 = signal_pending(tmp___8);
< #line 4658
<   if (tmp___9 != 0) {
< #line 4659
<     goto ldv_53171;
---
> #line 5290
>   tmp___7 = get_current();
> #line 5290
>   tmp___8 = signal_pending(tmp___7);
> #line 5290
>   if (tmp___8 != 0) {
> #line 5291
>     goto ldv_53943;
30539,30552c32088,32100
< #line 4661
<   rv = drbd_recv_short(mdev, mdev->meta.socket, buf, (size_t )(expect - received),
<                        0);
< #line 4663
<   drbd_clear_flag(mdev, SIGNAL_ASENDER);
< #line 4665
<   tmp___10 = get_current();
< #line 4665
<   flush_signals(tmp___10);
< #line 4677
<   tmp___13 = __builtin_expect(rv > 0, 1L);
< #line 4677
<   if (tmp___13 != 0L) {
< #line 4678
---
> #line 5293
>   rv = drbd_recv_short(tconn->meta.socket, buf, (size_t )(expect - received), 0);
> #line 5294
>   clear_bit(3, (unsigned long volatile   *)(& tconn->flags));
> #line 5296
>   tmp___9 = get_current();
> #line 5296
>   flush_signals(tmp___9);
> #line 5308
>   tmp___14 = __builtin_expect(rv > 0, 1L);
> #line 5308
>   if (tmp___14 != 0L) {
> #line 5309
30554c32102
< #line 4679
---
> #line 5310
30557c32105
< #line 4680
---
> #line 5311
30559,30569c32107,32144
< #line 4681
<     tmp___12 = drbd_test_flag(mdev, DISCONNECT_SENT);
< #line 4681
<     if (tmp___12 != 0) {
< #line 4683
<       __ret = (long )(((mdev->net_conf)->ping_timeo * 250) / 10);
< #line 4683
<       if ((int )mdev->state.ldv_40583.conn > 9) {
< #line 4683
<         tmp___11 = get_current();
< #line 4683
---
> #line 5312
>     tmp___13 = constant_test_bit(12U, (unsigned long const volatile   *)(& tconn->flags));
> #line 5312
>     if (tmp___13 != 0) {
> #line 5314
>       rcu_read_lock();
> #line 5315
>       _________p1___0 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 5315
>       tmp___10 = debug_lockdep_rcu_enabled();
> #line 5315
>       if (tmp___10 != 0 && ! __warned___0) {
> #line 5315
>         tmp___11 = rcu_read_lock_held();
> #line 5315
>         if (tmp___11 == 0 && 1) {
> #line 5315
>           __warned___0 = 1;
> #line 5315
>           lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
>                                  5315, "suspicious rcu_dereference_check() usage");
>         } else {
> 
>         }
>       } else {
> 
>       }
> #line 5315
>       t = (long )((_________p1___0->ping_timeo * 250U) / 10U);
> #line 5316
>       rcu_read_unlock();
> #line 5318
>       __ret = t;
> #line 5318
>       if ((unsigned int )tconn->cstate > 8U) {
> #line 5318
>         tmp___12 = get_current();
> #line 5318
30571,30573c32146,32148
< #line 4683
<         __wait.private = (void *)tmp___11;
< #line 4683
---
> #line 5318
>         __wait.private = (void *)tmp___12;
> #line 5318
30575c32150
< #line 4683
---
> #line 5318
30577c32152
< #line 4683
---
> #line 5318
30579,30585c32154,32160
<         ldv_53176: 
< #line 4683
<         prepare_to_wait(& mdev->state_wait, & __wait, 2);
< #line 4683
<         if ((int )mdev->state.ldv_40583.conn <= 9) {
< #line 4683
<           goto ldv_53175;
---
>         ldv_53951: 
> #line 5318
>         prepare_to_wait(& tconn->ping_wait, & __wait, 2);
> #line 5318
>         if ((unsigned int )tconn->cstate <= 8U) {
> #line 5318
>           goto ldv_53950;
30589c32164
< #line 4683
---
> #line 5318
30591c32166
< #line 4683
---
> #line 5318
30593,30594c32168,32169
< #line 4683
<           goto ldv_53175;
---
> #line 5318
>           goto ldv_53950;
30598,30602c32173,32177
< #line 4683
<         goto ldv_53176;
<         ldv_53175: 
< #line 4683
<         finish_wait(& mdev->state_wait, & __wait);
---
> #line 5318
>         goto ldv_53951;
>         ldv_53950: 
> #line 5318
>         finish_wait(& tconn->ping_wait, & __wait);
30606c32181
< #line 4683
---
> #line 5318
30608c32183
< #line 4685
---
> #line 5321
30610,30611c32185,32186
< #line 4686
<         goto ldv_53178;
---
> #line 5322
>         goto ldv_53953;
30618,30620c32193,32195
< #line 4688
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "meta connection shut down by peer.\n");
< #line 4689
---
> #line 5324
>     printk("\vd-con %s: meta connection shut down by peer.\n", tconn->name);
> #line 5325
30623c32198
< #line 4690
---
> #line 5326
30625,30628c32200,32203
< #line 4693
<     if ((1 != 0 && 1 != 0) && (long )((unsigned long )jiffies - (unsigned long )((mdev->meta.socket)->sk)->sk_rcvtimeo) - (long )mdev->last_received < 0L) {
< #line 4695
<       goto ldv_53171;
---
> #line 5329
>     if ((1 != 0 && 1 != 0) && (long )((unsigned long )jiffies - (unsigned long )((tconn->meta.socket)->sk)->sk_rcvtimeo) - (long )tconn->last_received < 0L) {
> #line 5331
>       goto ldv_53943;
30632,30636c32207,32211
< #line 4696
<     if (ping_timeout_active != 0) {
< #line 4697
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "PingAck did not arrive in time.\n");
< #line 4698
---
> #line 5332
>     if ((int )ping_timeout_active) {
> #line 5333
>       printk("\vd-con %s: PingAck did not arrive in time.\n", tconn->name);
> #line 5334
30641,30644c32216,32219
< #line 4700
<     drbd_set_flag(mdev, SEND_PING);
< #line 4701
<     goto ldv_53171;
---
> #line 5336
>     set_bit(2U, (unsigned long volatile   *)(& tconn->flags));
> #line 5337
>     goto ldv_53943;
30646c32221
< #line 4702
---
> #line 5338
30648,30649c32223,32224
< #line 4703
<     goto ldv_53171;
---
> #line 5339
>     goto ldv_53943;
30651,30654c32226,32228
< #line 4705
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "sock_recvmsg returned %d\n",
<             rv);
< #line 4706
---
> #line 5341
>     printk("\vd-con %s: sock_recvmsg returned %d\n", tconn->name, rv);
> #line 5342
30657c32231
< #line 4709
---
> #line 5345
30659,30672c32233,32237
< #line 4710
<     tmp___17 = __builtin_expect(h->magic != 1728214147U, 0L);
< #line 4710
<     if (tmp___17 != 0L) {
< #line 4711
<       tmp___14 = __fswab16((int )h->length);
< #line 4711
<       tmp___15 = __fswab16((int )h->command);
< #line 4711
<       tmp___16 = __fswab32(h->magic);
< #line 4711
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "magic?? on meta m: 0x%08x c: %d l: %d\n",
<               tmp___16, (int )tmp___15, (int )tmp___14);
< #line 4715
---
> #line 5346
>     tmp___15 = decode_header(tconn, tconn->meta.rbuf, & pi);
> #line 5346
>     if (tmp___15 != 0) {
> #line 5347
30677,30699c32242,32252
< #line 4717
<     tmp___18 = __fswab16((int )h->command);
< #line 4717
<     cmd = get_asender_cmd((int )tmp___18);
< #line 4718
<     tmp___19 = __fswab16((int )h->length);
< #line 4718
<     len = (int )tmp___19;
< #line 4719
<     tmp___23 = __builtin_expect((unsigned long )cmd == (unsigned long )((struct asender_cmd *)0),
<                                 0L);
< #line 4719
<     if (tmp___23 != 0L) {
< #line 4720
<       tmp___20 = __fswab16((int )h->length);
< #line 4720
<       tmp___21 = __fswab16((int )h->command);
< #line 4720
<       tmp___22 = __fswab32(h->magic);
< #line 4720
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "unknown command?? on meta m: 0x%08x c: %d l: %d\n",
<               tmp___22, (int )tmp___21, (int )tmp___20);
< #line 4724
---
> #line 5348
>     cmd = (struct asender_cmd *)(& asender_tbl) + (unsigned long )pi.cmd;
> #line 5349
>     if ((unsigned int )pi.cmd > (unsigned int )P_RETRY_WRITE || (unsigned long )cmd->fn == (unsigned long )((int (*)(struct drbd_tconn * ,
>                                                                                                                      struct packet_info * ))0)) {
> #line 5350
>       tmp___16 = cmdname(pi.cmd);
> #line 5350
>       printk("\vd-con %s: Unexpected meta packet %s (0x%04x)\n", tconn->name, tmp___16,
>              (unsigned int )pi.cmd);
> #line 5352
30704,30719c32257,32264
< #line 4726
<     expect = (int )cmd->pkt_size;
< #line 4727
<     _b___0 = (unsigned long )len != (unsigned long )expect - 8UL;
< #line 4727
<     if (_b___0 != 0) {
< #line 4727
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<               "drbd_asender", (char *)"len != expect-sizeof(struct p_header80)", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               4727);
<     } else {
< 
<     }
< #line 4727
<     if (_b___0 != 0) {
< #line 4728
---
> #line 5354
>     expect = (int )((unsigned int )cmd->pkt_size + header_size);
> #line 5355
>     if (pi.size != (unsigned int )expect - header_size) {
> #line 5356
>       printk("\vd-con %s: Wrong packet size on meta (c: %d, l: %d)\n", tconn->name,
>              (unsigned int )pi.cmd, pi.size);
> #line 5358
30727c32272
< #line 4730
---
> #line 5361
30729,30744c32274,32282
< #line 4731
<     mdev->last_received = jiffies;
< #line 4732
<     if ((unsigned long )cmd == (unsigned long )((struct asender_cmd *)0)) {
< #line 4732
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( cmd != NULL ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<               4732);
<     } else {
< 
<     }
< #line 4733
<     tmp___24 = (*(cmd->process))(mdev, h);
< #line 4733
<     if (tmp___24 == 0) {
< #line 4734
---
> #line 5364
>     tmp___17 = (*(cmd->fn))(tconn, & pi);
> #line 5364
>     err = tmp___17 != 0;
> #line 5365
>     if ((int )err) {
> #line 5366
>       printk("\vd-con %s: %pf failed\n", tconn->name, cmd->fn);
> #line 5367
30749,30753c32287,32293
< #line 4738
<     tmp___25 = get_asender_cmd(20);
< #line 4738
<     if ((unsigned long )tmp___25 == (unsigned long )cmd) {
< #line 4739
---
> #line 5370
>     tconn->last_received = jiffies;
> #line 5372
>     if ((unsigned long )cmd == (unsigned long )((struct asender_cmd *)(& asender_tbl) + 20UL)) {
> #line 5374
>       ((tconn->meta.socket)->sk)->sk_rcvtimeo = (long )(ping_int * 250);
> #line 5375
30758,30760c32298,32300
< #line 4741
<     buf = (void *)h;
< #line 4742
---
> #line 5378
>     buf = tconn->meta.rbuf;
> #line 5379
30762,30764c32302,32304
< #line 4743
<     expect = 8;
< #line 4744
---
> #line 5380
>     expect = (int )header_size;
> #line 5381
30769,30775c32309,32315
<   ldv_53171: 
< #line 4623
<   tmp___26 = get_t_state(thi);
< #line 4623
<   if ((unsigned int )tmp___26 == 1U) {
< #line 4624
<     goto ldv_53188;
---
>   ldv_53943: 
> #line 5258
>   tmp___18 = get_t_state(thi);
> #line 5258
>   if ((unsigned int )tmp___18 == 1U) {
> #line 5259
>     goto ldv_53964;
30779,30780c32319,32320
<   ldv_53178: ;
< #line 4748
---
>   ldv_53953: ;
> #line 5385
30783c32323
< #line 4750
---
> #line 5387
30785,30787c32325,32327
< #line 4750
<     val.ldv_40583.conn = 5U;
< #line 4750
---
> #line 5387
>     val.ldv_40604.conn = 5U;
> #line 5387
30789,30794c32329,32334
< #line 4750
<     mask.ldv_40583.conn = 31U;
< #line 4750
<     drbd_force_state(mdev, mask, val);
< #line 4751
<     drbd_md_sync(mdev);
---
> #line 5387
>     mask.ldv_40604.conn = 31U;
> #line 5387
>     conn_request_state(tconn, mask, val, CS_HARD);
> #line 5388
>     conn_md_sync(tconn);
30798c32338
< #line 4753
---
> #line 5390
30801c32341
< #line 4755
---
> #line 5392
30803,30805c32343,32345
< #line 4755
<     val___0.ldv_40583.conn = 1U;
< #line 4755
---
> #line 5392
>     val___0.ldv_40604.conn = 1U;
> #line 5392
30807,30823c32347,32350
< #line 4755
<     mask___0.ldv_40583.conn = 31U;
< #line 4755
<     drbd_force_state(mdev, mask___0, val___0);
< #line 4756
<     drbd_md_sync(mdev);
<   } else {
< 
<   }
< #line 4758
<   drbd_clear_flag(mdev, SIGNAL_ASENDER);
< #line 4760
<   if ((int )mdev->state.ldv_40583.conn > 9) {
< #line 4760
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->state.conn < C_CONNECTED ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared",
<             4760);
---
> #line 5392
>     mask___0.ldv_40604.conn = 31U;
> #line 5392
>     conn_request_state(tconn, mask___0, val___0, CS_HARD);
30827,30829c32354,32358
< #line 4761
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "asender terminated\n");
< #line 4763
---
> #line 5394
>   clear_bit(3, (unsigned long volatile   *)(& tconn->flags));
> #line 5396
>   printk("\016d-con %s: asender terminated\n", tconn->name);
> #line 5398
30833c32362
< #line 4803 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
---
> #line 5438 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
30840c32369
< #line 4815
---
> #line 5450
30842c32371
< #line 4824
---
> #line 5459
30844,30847c32373,32376
< #line 4826
<   goto ldv_53216;
<   ldv_53215: 
< #line 4829
---
> #line 5461
>   goto ldv_53992;
>   ldv_53991: 
> #line 5464
30849c32378
< #line 4829
---
> #line 5464
30852,30853c32381,32382
< #line 4831
<   goto ldv_53214;
---
> #line 5466
>   goto ldv_53990;
30855,30857c32384,32386
<   ldv_53214: ;
<   ldv_53216: 
< #line 4826
---
>   ldv_53990: ;
>   ldv_53992: 
> #line 5461
30859c32388
< #line 4826
---
> #line 5461
30861,30862c32390,32391
< #line 4827
<     goto ldv_53215;
---
> #line 5462
>     goto ldv_53991;
30868c32397
< #line 4840
---
> #line 5475
30870,30919c32399
< #line 4843
<   return;
< }
< }
< #line 4847 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_receiver.c.prepared"
< void ldv___module_get_3(struct module *ldv_func_arg1 ) 
< { 
< 
< 
<   {
< #line 4852
<   ldv_module_get(ldv_func_arg1);
< #line 4853
<   return;
< }
< }
< #line 595 "include/linux/list.h"
< __inline static void hlist_del(struct hlist_node *n ) 
< { 
< 
< 
<   {
< #line 597
<   __hlist_del(n);
< #line 598
<   n->next = 0xdead000000100100UL;
< #line 599
<   n->pprev = 0xdead000000200200UL;
< #line 600
<   return;
< }
< }
< #line 333 "include/linux/lockdep.h"
< extern void lock_acquire(struct lockdep_map * , unsigned int  , int  , int  , int  ,
<                          struct lockdep_map * , unsigned long  ) ;
< #line 337
< extern void lock_release(struct lockdep_map * , int  , unsigned long  ) ;
< #line 573
< extern void lockdep_rcu_suspicious(char const   * , int const    , char const   * ) ;
< #line 273 "include/linux/rcupdate.h"
< extern int rcu_is_cpu_idle(void) ;
< #line 287 "include/linux/rcupdate.h"
< __inline static void rcu_lock_acquire(struct lockdep_map *map ) 
< { 
< 
< 
<   {
< #line 289
<   lock_acquire(map, 0U, 0, 2, 1, 0, (unsigned long )((void *)0));
< #line 291
---
> #line 5478
30923,30924c32403,32404
< #line 292 "include/linux/rcupdate.h"
< __inline static void rcu_lock_release(struct lockdep_map *map ) 
---
> #line 307 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/bitops.h"
> __inline static int test_and_change_bit(int nr , unsigned long volatile   *addr ) 
30926c32406
< 
---
>   int oldbit ;
30929,30932c32409,32413
< #line 294
<   lock_release(map, 1, (unsigned long )((void *)0));
< #line 296
<   return;
---
> #line 311
>   __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btc %2,%1\n\tsbb %0,%0": "=r" (oldbit),
>                        "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
> #line 315
>   return (oldbit);
30935,30940c32416,32421
< #line 297
< extern struct lockdep_map rcu_lock_map ;
< #line 300
< extern int debug_lockdep_rcu_enabled(void) ;
< #line 732 "include/linux/rcupdate.h"
< __inline static void rcu_read_lock(void) 
---
> #line 39 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/smp.h"
> extern int cpu_number ;
> #line 173 "include/linux/percpu.h"
> extern void __bad_size_call_parameter(void) ;
> #line 31 "include/linux/kref.h"
> __inline static void kref_init(struct kref *kref ) 
30942,30966d32422
<   bool __warned ;
<   int tmp ;
<   int tmp___0 ;
< 
<   {
< #line 734
<   pagefault_disable();
< #line 736
<   rcu_lock_acquire(& rcu_lock_map);
< #line 737
<   tmp = debug_lockdep_rcu_enabled();
< #line 737
<   if (tmp != 0 && ! __warned) {
< #line 737
<     tmp___0 = rcu_is_cpu_idle();
< #line 737
<     if (tmp___0 != 0) {
< #line 737
<       __warned = 1;
< #line 737
<       lockdep_rcu_suspicious("include/linux/rcupdate.h", 738, "rcu_read_lock() used illegally while idle");
<     } else {
< 
<     }
<   } else {
30968,30978d32423
<   }
< #line 740
<   return;
< }
< }
< #line 756 "include/linux/rcupdate.h"
< __inline static void rcu_read_unlock(void) 
< { 
<   bool __warned ;
<   int tmp ;
<   int tmp___0 ;
30981,31003c32426,32428
< #line 758
<   tmp = debug_lockdep_rcu_enabled();
< #line 758
<   if (tmp != 0 && ! __warned) {
< #line 758
<     tmp___0 = rcu_is_cpu_idle();
< #line 758
<     if (tmp___0 != 0) {
< #line 758
<       __warned = 1;
< #line 758
<       lockdep_rcu_suspicious("include/linux/rcupdate.h", 759, "rcu_read_unlock() used illegally while idle");
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 760
<   rcu_lock_release(& rcu_lock_map);
< #line 762
<   pagefault_enable();
< #line 763
---
> #line 33
>   atomic_set(& kref->refcount, 1);
> #line 34
31007,31010d32431
< #line 39 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/smp.h"
< extern int cpu_number ;
< #line 173 "include/linux/percpu.h"
< extern void __bad_size_call_parameter(void) ;
31089,31097c32510,32522
< #line 209 "include/linux/bio.h"
< extern struct bio_pair *bio_split(struct bio * , int  ) ;
< #line 210
< extern void bio_pair_release(struct bio_pair * ) ;
< #line 63 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< bool allow_oos ;
< #line 1261
< void _tl_add_barrier(struct drbd_conf *mdev , struct drbd_tl_epoch *new ) ;
< #line 1535
---
> #line 282 "include/linux/backing-dev.h"
> __inline static int bdi_read_congested(struct backing_dev_info *bdi ) 
> { 
>   int tmp ;
> 
>   {
> #line 284
>   tmp = bdi_congested(bdi, 8);
> #line 284
>   return (tmp);
> }
> }
> #line 1369 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
31099c32524,32526
< #line 1578
---
> #line 1421
> void __drbd_make_request(struct drbd_conf *mdev , struct bio *bio , unsigned long start_time ) ;
> #line 1422
31101c32528
< #line 1580
---
> #line 1424
31103c32530
< #line 2157 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1969 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
31109c32536
< #line 2159
---
> #line 1971
31111c32538,32572
< #line 2160
---
> #line 1972
>   return;
> }
> }
> #line 1981 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void _dec_ap_pending(struct drbd_conf *mdev , char const   *func ,
>                                      int line ) 
> { 
>   int tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
> 
>   {
> #line 1983
>   tmp = atomic_dec_and_test(& mdev->ap_pending_cnt);
> #line 1983
>   if (tmp != 0) {
> #line 1984
>     __wake_up(& mdev->misc_wait, 3U, 1, 0);
>   } else {
> 
>   }
> #line 1985
>   tmp___1 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
> #line 1985
>   if (tmp___1 < 0) {
> #line 1985
>     tmp___0 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
> #line 1985
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: ap_pending_cnt = %d < 0 !\n",
>             func, line, tmp___0);
>   } else {
> 
>   }
> #line 1986
31115c32576
< #line 2337 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2133 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
31117a32579
>   struct net_conf *nc ;
31118a32581,32582
>   struct net_conf *_________p1 ;
>   bool __warned ;
31119a32584
>   int tmp___0 ;
31122,31131c32587,32606
< #line 2339
<   mxb = 1000000;
< #line 2340
<   tmp = get_net_conf(mdev);
< #line 2340
<   if (tmp != 0) {
< #line 2341
<     mxb = (mdev->net_conf)->max_buffers;
< #line 2342
<     put_net_conf(mdev);
---
> #line 2138
>   rcu_read_lock();
> #line 2139
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 2139
>   tmp = debug_lockdep_rcu_enabled();
> #line 2139
>   if (tmp != 0 && ! __warned) {
> #line 2139
>     tmp___0 = rcu_read_lock_held();
> #line 2139
>     if (tmp___0 == 0 && 1) {
> #line 2139
>       __warned = 1;
> #line 2139
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h",
>                              2139, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
31135c32610,32616
< #line 2344
---
> #line 2139
>   nc = _________p1;
> #line 2140
>   mxb = (unsigned long )nc != (unsigned long )((struct net_conf *)0) ? (int )nc->max_buffers : 1000000;
> #line 2141
>   rcu_read_unlock();
> #line 2143
31139c32620
< #line 2347 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2146 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
31142c32623
<   union drbd_state s ;
---
>   union drbd_dev_state s ;
31145c32626
< #line 2349
---
> #line 2148
31147,31148c32628,32629
< #line 2354
<   switch ((unsigned int )s.ldv_40583.conn) {
---
> #line 2153
>   switch ((unsigned int )s.ldv_50103.conn) {
31170,31171c32651,32652
< #line 2379
<   goto ldv_51031;
---
> #line 2178
>   goto ldv_51604;
31173,31175c32654,32656
< #line 2383
<   if (mdev->agreed_pro_version <= 95) {
< #line 2384
---
> #line 2182
>   if ((mdev->tconn)->agreed_pro_version <= 95) {
> #line 2183
31180,31181c32661,32662
< #line 2385
<   goto ldv_51031;
---
> #line 2184
>   goto ldv_51604;
31185c32666
< #line 2392
---
> #line 2191
31188,31190c32669,32671
<   ldv_51031: ;
< #line 2395
<   switch ((unsigned int )s.ldv_40583.disk) {
---
>   ldv_51604: ;
> #line 2194
>   switch ((unsigned int )s.ldv_50103.disk) {
31197,31198c32678,32679
< #line 2403
<   goto ldv_51042;
---
> #line 2202
>   goto ldv_51615;
31203c32684
< #line 2411
---
> #line 2210
31206,31207c32687,32688
<   ldv_51042: ;
< #line 2414
---
>   ldv_51615: ;
> #line 2213
31211c32692
< #line 2422 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2223 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
31223c32704
< #line 2424
---
> #line 2225
31225c32706
< #line 2424
---
> #line 2225
31227,31229c32708,32710
< #line 2426
<   tmp___0 = is_susp(mdev->state);
< #line 2426
---
> #line 2227
>   tmp___0 = drbd_suspended(mdev);
> #line 2227
31231c32712
< #line 2427
---
> #line 2228
31236,31238c32717,32719
< #line 2428
<   tmp___1 = drbd_test_flag(mdev, SUSPEND_IO);
< #line 2428
---
> #line 2229
>   tmp___1 = constant_test_bit(8U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2229
31240c32721
< #line 2429
---
> #line 2230
31245c32726
< #line 2436
---
> #line 2237
31247c32728
< #line 2436
---
> #line 2237
31249c32730
< #line 2437
---
> #line 2238
31254c32735
< #line 2441
---
> #line 2242
31256c32737
< #line 2441
---
> #line 2242
31258c32739
< #line 2442
---
> #line 2243
31263,31265c32744,32746
< #line 2443
<   tmp___4 = drbd_test_flag(mdev, BITMAP_IO);
< #line 2443
---
> #line 2244
>   tmp___4 = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2244
31267c32748
< #line 2444
---
> #line 2245
31272c32753
< #line 2445
---
> #line 2246
31276,31277c32757,32758
< #line 2448 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static bool inc_ap_bio_cond(struct drbd_conf *mdev , int count ) 
---
> #line 2249 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static bool inc_ap_bio_cond(struct drbd_conf *mdev ) 
31282c32763
< #line 2450
---
> #line 2251
31284,31286c32765,32767
< #line 2452
<   spin_lock_irq(& mdev->req_lock);
< #line 2453
---
> #line 2253
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 2254
31288c32769
< #line 2454
---
> #line 2255
31290,31291c32771,32772
< #line 2455
<     atomic_add(count, & mdev->ap_bio_cnt);
---
> #line 2256
>     atomic_inc(& mdev->ap_bio_cnt);
31295,31297c32776,32778
< #line 2456
<   spin_unlock_irq(& mdev->req_lock);
< #line 2458
---
> #line 2257
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 2259
31301,31302c32782,32783
< #line 2461 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void inc_ap_bio(struct drbd_conf *mdev , int count ) 
---
> #line 2262 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void inc_ap_bio(struct drbd_conf *mdev ) 
31310,31312c32791,32793
< #line 2471
<   tmp = inc_ap_bio_cond(mdev, count);
< #line 2471
---
> #line 2272
>   tmp = inc_ap_bio_cond(mdev);
> #line 2272
31314,31315c32795,32796
< #line 2471
<     goto ldv_51063;
---
> #line 2272
>     goto ldv_51635;
31319c32800
< #line 2471
---
> #line 2272
31321c32802
< #line 2471
---
> #line 2272
31323c32804
< #line 2471
---
> #line 2272
31325c32806
< #line 2471
---
> #line 2272
31327c32808
< #line 2471
---
> #line 2272
31329c32810
< #line 2471
---
> #line 2272
31331,31332c32812,32813
<   ldv_51066: 
< #line 2471
---
>   ldv_51638: 
> #line 2272
31334,31336c32815,32817
< #line 2471
<   tmp___1 = inc_ap_bio_cond(mdev, count);
< #line 2471
---
> #line 2272
>   tmp___1 = inc_ap_bio_cond(mdev);
> #line 2272
31338,31339c32819,32820
< #line 2471
<     goto ldv_51065;
---
> #line 2272
>     goto ldv_51637;
31343c32824
< #line 2471
---
> #line 2272
31345,31348c32826,32829
< #line 2471
<   goto ldv_51066;
<   ldv_51065: 
< #line 2471
---
> #line 2272
>   goto ldv_51638;
>   ldv_51637: 
> #line 2272
31350,31351c32831,32832
<   ldv_51063: ;
< #line 2474
---
>   ldv_51635: ;
> #line 2275
31355c32836
< #line 2474 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2275 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
31366c32847
< #line 2476
---
> #line 2277
31368c32849
< #line 2476
---
> #line 2277
31370c32851
< #line 2477
---
> #line 2278
31372c32853
< #line 2477
---
> #line 2278
31374c32855
< #line 2479
---
> #line 2280
31376c32857
< #line 2479
---
> #line 2280
31379c32860
<             2479);
---
>             2280);
31383c32864
< #line 2481
---
> #line 2282
31385,31387c32866,32868
< #line 2481
<     tmp___2 = drbd_test_flag(mdev, BITMAP_IO);
< #line 2481
---
> #line 2282
>     tmp___2 = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2282
31389,31391c32870,32872
< #line 2482
<       tmp___1 = drbd_test_and_set_flag(mdev, BITMAP_IO_QUEUED);
< #line 2482
---
> #line 2283
>       tmp___1 = test_and_set_bit(10, (unsigned long volatile   *)(& mdev->flags));
> #line 2283
31393,31394c32874,32875
< #line 2483
<         drbd_queue_work(& mdev->data.work, & mdev->bm_io_work.w);
---
> #line 2284
>         drbd_queue_work(& (mdev->tconn)->sender_work, & mdev->bm_io_work.w);
31404c32885
< #line 2489
---
> #line 2290
31406c32887
< #line 2490
---
> #line 2291
31411c32892
< #line 2491
---
> #line 2292
31415,31472c32896,32903
< #line 232 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< __inline static struct hlist_head *ee_hash_slot___0(struct drbd_conf *mdev , sector_t sector ) 
< { 
<   long tmp ;
< 
<   {
< #line 234
<   tmp = __builtin_expect(mdev->ee_hash_s == 0U, 0L);
< #line 234
<   if (tmp != 0L) {
< #line 234
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"),
<                          "i" (234), "i" (12UL));
<     ldv_51176: ;
< #line 234
<     goto ldv_51176;
<   } else {
< 
<   }
< #line 235
<   return (mdev->ee_hash + (unsigned long )((unsigned int )(sector >> 8) % mdev->ee_hash_s));
< }
< }
< #line 241 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< __inline static struct hlist_head *tl_hash_slot___0(struct drbd_conf *mdev , sector_t sector ) 
< { 
<   long tmp ;
< 
<   {
< #line 243
<   tmp = __builtin_expect(mdev->tl_hash_s == 0U, 0L);
< #line 243
<   if (tmp != 0L) {
< #line 243
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"),
<                          "i" (243), "i" (12UL));
<     ldv_51181: ;
< #line 243
<     goto ldv_51181;
<   } else {
< 
<   }
< #line 244
<   return (mdev->tl_hash + (unsigned long )((unsigned int )(sector >> 8) % mdev->tl_hash_s));
< }
< }
< #line 249 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< static struct hlist_head *ar_hash_slot___0(struct drbd_conf *mdev , sector_t sector ) 
< { 
< 
< 
<   {
< #line 251
<   return (mdev->app_reads_hash + (unsigned long )((unsigned int )sector % 15U));
< }
< }
< #line 285 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< __inline static struct drbd_request *drbd_req_new(struct drbd_conf *mdev , struct bio *bio_src ) 
---
> #line 270 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
> void drbd_req_destroy(struct kref *kref ) ;
> #line 277
> void request_timer_fn(unsigned long data ) ;
> #line 282
> void drbd_restart_request(struct drbd_request *req ) ;
> #line 286 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
> __inline static int _req_mod(struct drbd_request *req , enum drbd_req_event what ) 
31474,31476c32905,32907
<   struct drbd_request *req ;
<   void *tmp ;
<   long tmp___0 ;
---
>   struct drbd_conf *mdev ;
>   struct bio_and_error m ;
>   int rv ;
31480,31489c32911
<   tmp = mempool_alloc(drbd_request_mempool, 16U);
< #line 288
<   req = (struct drbd_request *)tmp;
< #line 290
<   tmp___0 = __builtin_expect((unsigned long )req != (unsigned long )((struct drbd_request *)0),
<                              1L);
< #line 290
<   if (tmp___0 != 0L) {
< #line 291
<     drbd_req_make_private_bio(req, bio_src);
---
>   mdev = req->w.ldv_50388.mdev;
31491c32913
<     req->rq_state = (int )bio_src->bi_rw & 1 ? 2048UL : 0UL;
---
>   rv = __req_mod(req, what, & m);
31493c32915
<     req->mdev = mdev;
---
>   if ((unsigned long )m.bio != (unsigned long )((struct bio *)0)) {
31495,31507c32917
<     req->master_bio = bio_src;
< #line 296
<     req->epoch = 0U;
< #line 297
<     req->sector = bio_src->bi_sector;
< #line 298
<     req->size = bio_src->bi_size;
< #line 299
<     INIT_HLIST_NODE(& req->collision);
< #line 300
<     INIT_LIST_HEAD(& req->tl_requests);
< #line 301
<     INIT_LIST_HEAD(& req->w.list);
---
>     complete_master_bio(mdev, & m);
31511,31512c32921,32922
< #line 303
<   return (req);
---
> #line 297
>   return (rv);
31515,31516c32925,32926
< #line 306 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< __inline static void drbd_req_free(struct drbd_request *req ) 
---
> #line 322 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
> __inline static bool drbd_should_do_remote(union drbd_dev_state s ) 
31521,31526d32930
< #line 308
<   mempool_free((void *)req, drbd_request_mempool);
< #line 309
<   return;
< }
< }
31528,31538c32932
< void _req_may_be_done(struct drbd_request *req , struct bio_and_error *m ) ;
< #line 330
< void request_timer_fn(unsigned long data ) ;
< #line 371 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< __inline static bool drbd_should_do_remote(union drbd_state s ) 
< { 
< 
< 
<   {
< #line 373
<   return ((bool )(*((unsigned int *)(& s) + 0UL) == 65536U || (((int )s.ldv_40583.pdsk > 3 && (int )s.ldv_40583.conn > 13) && (int )s.ldv_40583.conn <= 21)));
---
>   return ((bool )(*((unsigned int *)(& s) + 0UL) == 65536U || (((int )s.ldv_50103.pdsk > 3 && (int )s.ldv_50103.conn > 13) && (int )s.ldv_50103.conn <= 21)));
31541,31542c32935,32936
< #line 381 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< __inline static bool drbd_should_send_oos(union drbd_state s ) 
---
> #line 332 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
> __inline static bool drbd_should_send_out_of_sync(union drbd_dev_state s ) 
31547c32941
< #line 383
---
> #line 334
31551c32945,32947
< #line 42 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
---
> #line 41 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static bool drbd_may_do_local_read(struct drbd_conf *mdev , sector_t sector , int size ) ;
> #line 44 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
31577,31578d32972
< #line 44
<   rw = (int const   )bio->bi_rw & (int const   )1;
31579a32974,32975
>   rw = (int const   )bio->bi_rw & (int const   )1;
> #line 48
31581c32977
< #line 46
---
> #line 48
31583c32979
< #line 46
---
> #line 48
31585c32981
< #line 46
---
> #line 48
31587c32983
< #line 46
---
> #line 48
31589c32985
< #line 46
---
> #line 48
31592c32988
< #line 46
---
> #line 48
31595c32991
< #line 46
---
> #line 48
31597,31598c32993,32994
< #line 46
<   goto ldv_51273;
---
> #line 48
>   goto ldv_51807;
31600c32996
< #line 46
---
> #line 48
31602,31603c32998,32999
< #line 46
<   goto ldv_51273;
---
> #line 48
>   goto ldv_51807;
31605c33001
< #line 46
---
> #line 48
31607,31608c33003,33004
< #line 46
<   goto ldv_51273;
---
> #line 48
>   goto ldv_51807;
31610c33006
< #line 46
---
> #line 48
31612,31613c33008,33009
< #line 46
<   goto ldv_51273;
---
> #line 48
>   goto ldv_51807;
31615c33011
< #line 46
---
> #line 48
31618,31619c33014,33015
<   ldv_51273: 
< #line 46
---
>   ldv_51807: 
> #line 48
31621,31622c33017,33018
< #line 46
<   goto ldv_51279;
---
> #line 48
>   goto ldv_51813;
31624c33020
< #line 46
---
> #line 48
31627c33023
< #line 46
---
> #line 48
31629,31630c33025,33026
< #line 46
<   goto ldv_51283;
---
> #line 48
>   goto ldv_51817;
31632c33028
< #line 46
---
> #line 48
31634,31635c33030,33031
< #line 46
<   goto ldv_51283;
---
> #line 48
>   goto ldv_51817;
31637c33033
< #line 46
---
> #line 48
31639,31640c33035,33036
< #line 46
<   goto ldv_51283;
---
> #line 48
>   goto ldv_51817;
31642c33038
< #line 46
---
> #line 48
31644,31645c33040,33041
< #line 46
<   goto ldv_51283;
---
> #line 48
>   goto ldv_51817;
31647c33043
< #line 46
---
> #line 48
31650,31651c33046,33047
<   ldv_51283: 
< #line 46
---
>   ldv_51817: 
> #line 48
31653,31654c33049,33050
< #line 46
<   goto ldv_51279;
---
> #line 48
>   goto ldv_51813;
31656c33052
< #line 46
---
> #line 48
31659c33055
< #line 46
---
> #line 48
31661,31662c33057,33058
< #line 46
<   goto ldv_51292;
---
> #line 48
>   goto ldv_51826;
31664c33060
< #line 46
---
> #line 48
31666,31667c33062,33063
< #line 46
<   goto ldv_51292;
---
> #line 48
>   goto ldv_51826;
31669c33065
< #line 46
---
> #line 48
31671,31672c33067,33068
< #line 46
<   goto ldv_51292;
---
> #line 48
>   goto ldv_51826;
31674c33070
< #line 46
---
> #line 48
31676,31677c33072,33073
< #line 46
<   goto ldv_51292;
---
> #line 48
>   goto ldv_51826;
31679c33075
< #line 46
---
> #line 48
31682,31683c33078,33079
<   ldv_51292: 
< #line 46
---
>   ldv_51826: 
> #line 48
31685,31686c33081,33082
< #line 46
<   goto ldv_51279;
---
> #line 48
>   goto ldv_51813;
31688c33084
< #line 46
---
> #line 48
31691c33087
< #line 46
---
> #line 48
31693,31694c33089,33090
< #line 46
<   goto ldv_51301;
---
> #line 48
>   goto ldv_51835;
31696c33092
< #line 46
---
> #line 48
31698,31699c33094,33095
< #line 46
<   goto ldv_51301;
---
> #line 48
>   goto ldv_51835;
31701c33097
< #line 46
---
> #line 48
31703,31704c33099,33100
< #line 46
<   goto ldv_51301;
---
> #line 48
>   goto ldv_51835;
31706c33102
< #line 46
---
> #line 48
31708,31709c33104,33105
< #line 46
<   goto ldv_51301;
---
> #line 48
>   goto ldv_51835;
31711c33107
< #line 46
---
> #line 48
31714,31715c33110,33111
<   ldv_51301: 
< #line 46
---
>   ldv_51835: 
> #line 48
31717,31718c33113,33114
< #line 46
<   goto ldv_51279;
---
> #line 48
>   goto ldv_51813;
31720c33116
< #line 46
---
> #line 48
31722,31723c33118,33119
< #line 46
<   goto ldv_51279;
---
> #line 48
>   goto ldv_51813;
31725,31726c33121,33122
<   ldv_51279: 
< #line 46
---
>   ldv_51813: 
> #line 48
31728c33124
< #line 47
---
> #line 49
31730c33126
< #line 48
---
> #line 50
31732c33128
< #line 48
---
> #line 50
31734c33130
< #line 48
---
> #line 50
31736c33132
< #line 48
---
> #line 50
31738c33134
< #line 48
---
> #line 50
31740c33136
< #line 48
---
> #line 50
31742c33138
< #line 48
---
> #line 50
31744c33140
< #line 48
---
> #line 50
31749c33145
< #line 49
---
> #line 51
31751c33147
< #line 49
---
> #line 51
31753c33149
< #line 49
---
> #line 51
31755c33151
< #line 49
---
> #line 51
31757c33153
< #line 49
---
> #line 51
31759c33155
< #line 49
---
> #line 51
31761c33157
< #line 49
---
> #line 51
31763c33159
< #line 49
---
> #line 51
31768c33164
< #line 50
---
> #line 54
31770c33166
< #line 51
---
> #line 55
31772c33168
< #line 51
---
> #line 55
31774c33170
< #line 51
---
> #line 55
31776c33172
< #line 51
---
> #line 55
31778c33174
< #line 51
---
> #line 55
31780c33176
< #line 52
---
> #line 56
31784c33180
< #line 55 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
---
> #line 59 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
31805c33201
< #line 57
---
> #line 61
31807c33203
< #line 58
---
> #line 62
31809c33205
< #line 60
---
> #line 64
31811c33207
< #line 60
---
> #line 64
31813c33209
< #line 60
---
> #line 64
31815c33211
< #line 60
---
> #line 64
31817c33213
< #line 60
---
> #line 64
31819c33215
< #line 60
---
> #line 64
31822c33218
< #line 60
---
> #line 64
31825c33221
< #line 60
---
> #line 64
31827,31828c33223,33224
< #line 60
<   goto ldv_51339;
---
> #line 64
>   goto ldv_51873;
31830c33226
< #line 60
---
> #line 64
31832,31833c33228,33229
< #line 60
<   goto ldv_51339;
---
> #line 64
>   goto ldv_51873;
31835c33231
< #line 60
---
> #line 64
31837,31838c33233,33234
< #line 60
<   goto ldv_51339;
---
> #line 64
>   goto ldv_51873;
31840c33236
< #line 60
---
> #line 64
31842,31843c33238,33239
< #line 60
<   goto ldv_51339;
---
> #line 64
>   goto ldv_51873;
31845c33241
< #line 60
---
> #line 64
31848,31849c33244,33245
<   ldv_51339: 
< #line 60
---
>   ldv_51873: 
> #line 64
31851,31852c33247,33248
< #line 60
<   goto ldv_51345;
---
> #line 64
>   goto ldv_51879;
31854c33250
< #line 60
---
> #line 64
31857c33253
< #line 60
---
> #line 64
31859,31860c33255,33256
< #line 60
<   goto ldv_51349;
---
> #line 64
>   goto ldv_51883;
31862c33258
< #line 60
---
> #line 64
31864,31865c33260,33261
< #line 60
<   goto ldv_51349;
---
> #line 64
>   goto ldv_51883;
31867c33263
< #line 60
---
> #line 64
31869,31870c33265,33266
< #line 60
<   goto ldv_51349;
---
> #line 64
>   goto ldv_51883;
31872c33268
< #line 60
---
> #line 64
31874,31875c33270,33271
< #line 60
<   goto ldv_51349;
---
> #line 64
>   goto ldv_51883;
31877c33273
< #line 60
---
> #line 64
31880,31881c33276,33277
<   ldv_51349: 
< #line 60
---
>   ldv_51883: 
> #line 64
31883,31884c33279,33280
< #line 60
<   goto ldv_51345;
---
> #line 64
>   goto ldv_51879;
31886c33282
< #line 60
---
> #line 64
31889c33285
< #line 60
---
> #line 64
31891,31892c33287,33288
< #line 60
<   goto ldv_51358;
---
> #line 64
>   goto ldv_51892;
31894c33290
< #line 60
---
> #line 64
31896,31897c33292,33293
< #line 60
<   goto ldv_51358;
---
> #line 64
>   goto ldv_51892;
31899c33295
< #line 60
---
> #line 64
31901,31902c33297,33298
< #line 60
<   goto ldv_51358;
---
> #line 64
>   goto ldv_51892;
31904c33300
< #line 60
---
> #line 64
31906,31907c33302,33303
< #line 60
<   goto ldv_51358;
---
> #line 64
>   goto ldv_51892;
31909c33305
< #line 60
---
> #line 64
31912,31913c33308,33309
<   ldv_51358: 
< #line 60
---
>   ldv_51892: 
> #line 64
31915,31916c33311,33312
< #line 60
<   goto ldv_51345;
---
> #line 64
>   goto ldv_51879;
31918c33314
< #line 60
---
> #line 64
31921c33317
< #line 60
---
> #line 64
31923,31924c33319,33320
< #line 60
<   goto ldv_51367;
---
> #line 64
>   goto ldv_51901;
31926c33322
< #line 60
---
> #line 64
31928,31929c33324,33325
< #line 60
<   goto ldv_51367;
---
> #line 64
>   goto ldv_51901;
31931c33327
< #line 60
---
> #line 64
31933,31934c33329,33330
< #line 60
<   goto ldv_51367;
---
> #line 64
>   goto ldv_51901;
31936c33332
< #line 60
---
> #line 64
31938,31939c33334,33335
< #line 60
<   goto ldv_51367;
---
> #line 64
>   goto ldv_51901;
31941c33337
< #line 60
---
> #line 64
31944,31945c33340,33341
<   ldv_51367: 
< #line 60
---
>   ldv_51901: 
> #line 64
31947,31948c33343,33344
< #line 60
<   goto ldv_51345;
---
> #line 64
>   goto ldv_51879;
31950c33346
< #line 60
---
> #line 64
31952,31953c33348,33349
< #line 60
<   goto ldv_51345;
---
> #line 64
>   goto ldv_51879;
31955,31956c33351,33352
<   ldv_51345: 
< #line 60
---
>   ldv_51879: 
> #line 64
31958c33354
< #line 61
---
> #line 65
31960c33356
< #line 61
---
> #line 65
31962c33358
< #line 61
---
> #line 65
31964c33360
< #line 61
---
> #line 65
31966c33362
< #line 61
---
> #line 65
31968c33364
< #line 61
---
> #line 65
31970c33366
< #line 61
---
> #line 65
31972c33368
< #line 61
---
> #line 65
31977c33373
< #line 62
---
> #line 66
31979c33375
< #line 63
---
> #line 67
31981c33377
< #line 64
---
> #line 68
31983c33379
< #line 64
---
> #line 68
31985c33381
< #line 64
---
> #line 68
31987c33383
< #line 64
---
> #line 68
31989c33385
< #line 64
---
> #line 68
31991c33387
< #line 65
---
> #line 69
31995,31996c33391,33392
< #line 67 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
< static void _req_is_done(struct drbd_conf *mdev , struct drbd_request *req , int const   rw ) 
---
> #line 71 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static struct drbd_request *drbd_req_new(struct drbd_conf *mdev , struct bio *bio_src ) 
31998,32000c33394,33395
<   unsigned long s ;
<   int tmp ;
<   int tmp___0 ;
---
>   struct drbd_request *req ;
>   void *tmp ;
32003,32004c33398,33401
< #line 69
<   s = req->rq_state;
---
> #line 76
>   tmp = mempool_alloc(drbd_request_mempool, 16U);
> #line 76
>   req = (struct drbd_request *)tmp;
32006c33403,33412
<   list_del(& req->tl_requests);
---
>   if ((unsigned long )req == (unsigned long )((struct drbd_request *)0)) {
> #line 78
>     return (0);
>   } else {
> 
>   }
> #line 80
>   drbd_req_make_private_bio(req, bio_src);
> #line 81
>   req->rq_state = (int )bio_src->bi_rw & 1 ? 2048U : 0U;
32008c33414,33420
<   if ((int )rw == 1) {
---
>   req->w.ldv_50388.mdev = mdev;
> #line 83
>   req->master_bio = bio_src;
> #line 84
>   req->epoch = 0U;
> #line 86
>   drbd_clear_interval(& req->i);
32010c33422
<     if ((s & 256UL) == 0UL || (s & 4UL) == 0UL) {
---
>   req->i.sector = bio_src->bi_sector;
32012,32016c33424,33426
<       __drbd_set_out_of_sync(mdev, req->sector, (int )req->size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<                              88U);
<     } else {
< 
<     }
---
>   req->i.size = bio_src->bi_size;
> #line 89
>   req->i.local = -1;
32018,32022c33428,33451
<     if (((s & 256UL) != 0UL && (s & 4UL) != 0UL) && (s & 512UL) != 0UL) {
< #line 91
<       __drbd_set_in_sync(mdev, req->sector, (int )req->size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<                          91U);
<     } else {
---
>   req->i.waiting = 0;
> #line 92
>   INIT_LIST_HEAD(& req->tl_requests);
> #line 93
>   INIT_LIST_HEAD(& req->w.list);
> #line 96
>   atomic_set(& req->completion_ref, 1);
> #line 98
>   kref_init(& req->kref);
> #line 99
>   return (req);
> }
> }
> #line 102 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> void drbd_req_destroy(struct kref *kref ) 
> { 
>   struct drbd_request *req ;
>   struct kref  const  *__mptr ;
>   struct drbd_conf *mdev ;
>   unsigned int s ;
>   int tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
32024,32026c33453
<     }
< #line 103
<     if ((s & 15UL) != 0UL) {
---
>   {
32028c33455
<       tmp___0 = _get_ldev_if_state(mdev, D_FAILED);
---
>   __mptr = (struct kref  const  *)kref;
32030c33457
<       if (tmp___0 != 0) {
---
>   req = (struct drbd_request *)__mptr + 0xffffffffffffff74UL;
32032c33459
<         if ((s & 4096UL) != 0UL) {
---
>   mdev = req->w.ldv_50388.mdev;
32034,32035c33461,33503
<           drbd_al_complete_io(mdev, req->sector);
<         } else {
---
>   s = req->rq_state;
> #line 108
>   if ((unsigned long )req->master_bio != (unsigned long )((struct bio *)0) && ((unsigned long )s & 8192UL) == 0UL) {
> #line 112
>     tmp = atomic_read((atomic_t const   *)(& req->completion_ref));
> #line 112
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "drbd_req_destroy: Logic BUG rq_state = 0x%x, completion_ref = %d\n",
>             s, tmp);
> #line 114
>     return;
>   } else {
> #line 108
>     tmp___0 = atomic_read((atomic_t const   *)(& req->completion_ref));
> #line 108
>     if (tmp___0 != 0) {
> #line 112
>       tmp = atomic_read((atomic_t const   *)(& req->completion_ref));
> #line 112
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "drbd_req_destroy: Logic BUG rq_state = 0x%x, completion_ref = %d\n",
>               s, tmp);
> #line 114
>       return;
>     } else
> #line 108
>     if ((int )s & 1) {
> #line 112
>       tmp = atomic_read((atomic_t const   *)(& req->completion_ref));
> #line 112
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "drbd_req_destroy: Logic BUG rq_state = 0x%x, completion_ref = %d\n",
>               s, tmp);
> #line 114
>       return;
>     } else
> #line 108
>     if (((unsigned long )s & 1008UL) != 0UL && ((unsigned long )s & 128UL) == 0UL) {
> #line 112
>       tmp = atomic_read((atomic_t const   *)(& req->completion_ref));
> #line 112
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "drbd_req_destroy: Logic BUG rq_state = 0x%x, completion_ref = %d\n",
>               s, tmp);
> #line 114
>       return;
>     } else {
32037,32038c33505,33540
<         }
< #line 107
---
>     }
>   }
> #line 123
>   list_del_init(& req->tl_requests);
> #line 128
>   if (((unsigned long )s & 2048UL) != 0UL) {
> #line 140
>     if (((unsigned long )s & 9215UL) != 8192UL) {
> #line 141
>       if (((unsigned long )s & 256UL) == 0UL || ((unsigned long )s & 4UL) == 0UL) {
> #line 142
>         __drbd_set_out_of_sync(mdev, req->i.sector, (int )req->i.size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>                                142U);
>       } else {
> 
>       }
> #line 144
>       if ((((unsigned long )s & 256UL) != 0UL && ((unsigned long )s & 4UL) != 0UL) && ((unsigned long )s & 512UL) != 0UL) {
> #line 145
>         __drbd_set_in_sync(mdev, req->i.sector, (int )req->i.size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>                            145U);
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 158
>     if (((unsigned long )s & 4096UL) != 0UL) {
> #line 159
>       tmp___2 = _get_ldev_if_state(mdev, D_FAILED);
> #line 159
>       if (tmp___2 != 0) {
> #line 160
>         drbd_al_complete_io(mdev, & req->i);
> #line 161
32041,32047c33543,33549
< #line 108
<         tmp = ___ratelimit(& drbd_ratelimit_state, "_req_is_done");
< #line 108
<         if (tmp != 0) {
< #line 109
<           dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Should have called drbd_al_complete_io(, %llu), but my Disk seems to have failed :(\n",
<                    (unsigned long long )req->sector);
---
> #line 162
>         tmp___1 = ___ratelimit(& drbd_ratelimit_state, "drbd_req_destroy");
> #line 162
>         if (tmp___1 != 0) {
> #line 163
>           dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Should have called drbd_al_complete_io(, %llu, %u), but my Disk seems to have failed :(\n",
>                    (unsigned long long )req->i.sector, req->i.size);
32058,32060c33560,33562
< #line 116
<   drbd_req_free(req);
< #line 117
---
> #line 170
>   mempool_free((void *)req, drbd_request_mempool);
> #line 171
32064,32065c33566,33567
< #line 119 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
< static void queue_barrier(struct drbd_conf *mdev ) 
---
> #line 173 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static void wake_all_senders(struct drbd_tconn *tconn ) 
32067,32068d33568
<   struct drbd_tl_epoch *b ;
<   int tmp ;
32070,32077d33569
<   {
< #line 128
<   tmp = drbd_test_flag(mdev, CREATE_BARRIER);
< #line 128
<   if (tmp != 0) {
< #line 129
<     return;
<   } else {
32079,32090c33571,33574
<   }
< #line 131
<   b = mdev->newest_tle;
< #line 132
<   b->w.cb = & w_send_barrier;
< #line 137
<   inc_ap_pending(mdev);
< #line 138
<   drbd_queue_work(& mdev->data.work, & b->w);
< #line 139
<   drbd_set_flag(mdev, CREATE_BARRIER);
< #line 140
---
>   {
> #line 174
>   __wake_up(& tconn->sender_work.q_wait, 3U, 1, 0);
> #line 175
32094,32095c33578,33579
< #line 142 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
< static void _about_to_complete_local_write(struct drbd_conf *mdev , struct drbd_request *req ) 
---
> #line 178 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static void start_new_tl_epoch(struct drbd_tconn *tconn ) 
32097,32116d33580
<   unsigned long s ;
<   struct drbd_request *i ;
<   struct drbd_epoch_entry *e ;
<   struct hlist_node *n ;
<   struct hlist_head *slot ;
<   sector_t sector ;
<   int size ;
<   int tmp ;
<   struct hlist_node  const  *__mptr ;
<   int tmp___0 ;
<   struct hlist_node  const  *__mptr___0 ;
< 
<   {
< #line 145
<   s = req->rq_state;
< #line 157
<   if (((int )mdev->state.ldv_40583.conn > 9 && (s & 64UL) != 0UL) && req->epoch == (mdev->newest_tle)->br_number) {
< #line 160
<     queue_barrier(mdev);
<   } else {
32118,32199d33581
<   }
< #line 165
<   if ((s & 128UL) != 0UL && (unsigned long )mdev->ee_hash != (unsigned long )((struct hlist_head *)0)) {
< #line 166
<     sector = req->sector;
< #line 167
<     size = (int const   )req->size;
< #line 173
<     slot = tl_hash_slot___0(mdev, sector);
< #line 174
<     n = slot->first;
< #line 174
<     goto ldv_51411;
<     ldv_51410: 
< #line 175
<     tmp = overlaps(sector, size, i->sector, (int )i->size);
< #line 175
<     if (tmp != 0) {
< #line 176
<       dev_alert((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "LOGIC BUG: completed: %p %llus +%u; other: %p %llus +%u\n",
<                 req, (unsigned long long )sector, size, i, (unsigned long long )i->sector,
<                 i->size);
<     } else {
< 
<     }
< #line 174
<     n = n->next;
<     ldv_51411: ;
< #line 174
<     if ((unsigned long )n != (unsigned long )((struct hlist_node *)0)) {
< #line 174
<       __mptr = (struct hlist_node  const  *)n;
< #line 174
<       i = (struct drbd_request *)__mptr + 0xffffffffffffffd8UL;
< #line 174
<       if (1 != 0) {
< #line 175
<         goto ldv_51410;
<       } else {
< #line 177
<         goto ldv_51412;
<       }
<     } else {
< 
<     }
<     ldv_51412: 
< #line 197
<     slot = ee_hash_slot___0(mdev, req->sector);
< #line 198
<     n = slot->first;
< #line 198
<     goto ldv_51418;
<     ldv_51417: 
< #line 199
<     tmp___0 = overlaps(sector, size, e->sector, (int )e->size);
< #line 199
<     if (tmp___0 != 0) {
< #line 200
<       __wake_up(& mdev->misc_wait, 3U, 1, 0);
< #line 201
<       goto ldv_51416;
<     } else {
< 
<     }
< #line 198
<     n = n->next;
<     ldv_51418: ;
< #line 198
<     if ((unsigned long )n != (unsigned long )((struct hlist_node *)0)) {
< #line 198
<       __mptr___0 = (struct hlist_node  const  *)n;
< #line 198
<       e = (struct drbd_epoch_entry *)__mptr___0 + 0xffffffffffffffe8UL;
< #line 198
<       if (1 != 0) {
< #line 199
<         goto ldv_51417;
<       } else {
< #line 201
<         goto ldv_51416;
<       }
<     } else {
32201,32202c33583,33587
<     }
<     ldv_51416: ;
---
>   {
> #line 181
>   if (tconn->current_tle_writes == 0U) {
> #line 182
>     return;
32206c33591,33597
< #line 204
---
> #line 184
>   tconn->current_tle_writes = 0U;
> #line 185
>   atomic_inc(& tconn->current_tle_nr);
> #line 186
>   wake_all_senders(tconn);
> #line 187
32210c33601
< #line 208 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
---
> #line 189 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
32216c33607
< #line 211
---
> #line 192
32218c33609
< #line 212
---
> #line 193
32220c33611
< #line 213
---
> #line 194
32224,32225c33615,33616
< #line 221 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
< void _req_may_be_done(struct drbd_request *req , struct bio_and_error *m ) 
---
> #line 197 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static void drbd_remove_request_interval(struct rb_root *root , struct drbd_request *req ) 
32227c33618,33642
<   unsigned long s ;
---
>   struct drbd_conf *mdev ;
>   struct drbd_interval *i ;
> 
>   {
> #line 200
>   mdev = req->w.ldv_50388.mdev;
> #line 201
>   i = & req->i;
> #line 203
>   drbd_remove_interval(root, i);
> #line 206
>   if ((unsigned int )*((unsigned char *)i + 48UL) != 0U) {
> #line 207
>     __wake_up(& mdev->misc_wait, 3U, 1, 0);
>   } else {
> 
>   }
> #line 208
>   return;
> }
> }
> #line 217 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static void drbd_req_complete(struct drbd_request *req , struct bio_and_error *m ) 
> { 
>   unsigned int s ;
32230d33644
<   int ok ;
32231a33646
>   int ok ;
32233c33648,33652
<   int tmp___0 ;
---
>   struct rb_root *root ;
>   bool tmp___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
32236c33655
< #line 223
---
> #line 219
32238,32241c33657,33660
< #line 224
<   mdev = req->mdev;
< #line 225
<   rw = (req->rq_state & 2048UL) != 0UL;
---
> #line 220
>   mdev = req->w.ldv_50388.mdev;
> #line 233
>   if (((((int )s & 1 && ((unsigned long )s & 8UL) == 0UL) || ((unsigned long )s & 32UL) != 0UL) || ((unsigned long )s & 16UL) != 0UL) || ((unsigned long )s & 16384UL) != 0UL) {
32243c33662,33663
<   if ((s & 32UL) != 0UL) {
---
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "drbd_req_complete: Logic BUG rq_state = 0x%x\n",
>             s);
32249,32255d33668
< #line 238
<   if ((s & 16UL) != 0UL) {
< #line 239
<     return;
<   } else {
< 
<   }
32257c33670
<   if ((int )s & 1 && (s & 8UL) == 0UL) {
---
>   if ((unsigned long )req->master_bio == (unsigned long )((struct bio *)0)) {
32258a33672,33673
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "drbd_req_complete: Logic BUG, master_bio == NULL!\n");
> #line 242
32263,32264c33678,33685
< #line 243
<   if ((unsigned long )req->master_bio != (unsigned long )((struct bio *)0)) {
---
> #line 245
>   rw = (int )(req->master_bio)->bi_rw & 8193;
> #line 260
>   ok = ((unsigned long )s & 4UL) != 0UL || ((unsigned long )s & 256UL) != 0UL;
> #line 261
>   tmp = PTR_ERR((void const   *)req->private_bio);
> #line 261
>   error = (int )tmp;
32266,32274c33687,33702
<     ok = (s & 4UL) != 0UL || (s & 256UL) != 0UL;
< #line 266
<     tmp = PTR_ERR((void const   *)req->private_bio);
< #line 266
<     error = (int )tmp;
< #line 270
<     tmp___0 = hlist_unhashed((struct hlist_node  const  *)(& req->collision));
< #line 270
<     if (tmp___0 == 0) {
---
>   tmp___0 = drbd_interval_empty(& req->i);
> #line 265
>   if (tmp___0) {
> #line 265
>     tmp___1 = 0;
>   } else {
> #line 265
>     tmp___1 = 1;
>   }
> #line 265
>   if (tmp___1) {
> #line 268
>     if (rw == 1) {
> #line 269
>       root = & mdev->write_requests;
>     } else {
32276,32279c33704,33708
<       hlist_del(& req->collision);
<     } else
< #line 273
<     if ((s & 880UL) != 0UL) {
---
>       root = & mdev->read_requests;
>     }
> #line 272
>     drbd_remove_request_interval(root, req);
>   } else
32280a33710,33713
>   if (((unsigned long )s & 8192UL) == 0UL) {
> #line 274
>     if (((unsigned long )s & 880UL) != 0UL) {
> #line 274
32282,32283c33715,33716
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<               273);
---
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>               274);
32287,32290c33720,33730
< #line 276
<     if (rw == 1) {
< #line 277
<       _about_to_complete_local_write(mdev, req);
---
>   } else {
> 
>   }
> #line 283
>   if (rw == 1) {
> #line 283
>     tmp___2 = atomic_read((atomic_t const   *)(& (mdev->tconn)->current_tle_nr));
> #line 283
>     if (req->epoch == (unsigned int )tmp___2) {
> #line 285
>       start_new_tl_epoch(mdev->tconn);
32294,32301d33733
< #line 280
<     _drbd_end_io_acct(mdev, req);
< #line 282
<     m->error = ok == 0 ? (error != 0 ? error : -5) : 0;
< #line 283
<     m->bio = req->master_bio;
< #line 284
<     req->master_bio = 0;
32305,32306d33736
< #line 287
<   if ((int )s & 1) {
32308c33738,33749
<     return;
---
>   _drbd_end_io_acct(mdev, req);
> #line 304
>   if (ok == 0 && rw == 0) {
> #line 304
>     tmp___3 = list_empty((struct list_head  const  *)(& req->tl_requests));
> #line 304
>     if (tmp___3 == 0) {
> #line 305
>       req->rq_state = req->rq_state | 8192U;
>     } else {
> 
>     }
32312,32315c33753,33760
< #line 290
<   if ((s & 1008UL) == 0UL || (s & 128UL) != 0UL) {
< #line 295
<     _req_is_done(mdev, req, rw);
---
> #line 307
>   if (((unsigned long )req->rq_state & 8192UL) == 0UL) {
> #line 308
>     m->error = ok == 0 ? (error != 0 ? error : -5) : 0;
> #line 309
>     m->bio = req->master_bio;
> #line 310
>     req->master_bio = 0;
32319c33764
< #line 296
---
> #line 312
32323,32324c33768,33770
< #line 301 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
< static void _req_may_be_done_not_susp(struct drbd_request *req , struct bio_and_error *m ) 
---
> #line 314 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static int drbd_req_put_completion_ref(struct drbd_request *req , struct bio_and_error *m ,
>                                        int put ) 
32330,32334c33776,33789
< #line 303
<   mdev = req->mdev;
< #line 305
<   tmp = is_susp(mdev->state);
< #line 305
---
> #line 316
>   mdev = req->w.ldv_50388.mdev;
> #line 317
>   if ((unsigned long )m == (unsigned long )((struct bio_and_error *)0) && ((unsigned long )req->rq_state & 8192UL) == 0UL) {
> #line 317
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( m || (req->rq_state & RQ_POSTPONED) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             317);
>   } else {
> 
>   }
> #line 319
>   tmp = atomic_sub_and_test(put, & req->completion_ref);
> #line 319
32336,32337c33791,33792
< #line 306
<     _req_may_be_done(req, m);
---
> #line 320
>     return (0);
32341,32342c33796,33808
< #line 307
<   return;
---
> #line 322
>   drbd_req_complete(req, m);
> #line 324
>   if (((unsigned long )req->rq_state & 8192UL) != 0UL) {
> #line 327
>     drbd_restart_request(req);
> #line 328
>     return (0);
>   } else {
> 
>   }
> #line 331
>   return (1);
32345,32346c33811,33813
< #line 332 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
< static int _req_conflicts(struct drbd_request *req ) 
---
> #line 336 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static void mod_rq_state(struct drbd_request *req , struct bio_and_error *m , int clear ,
>                          int set ) 
32349,32354c33816,33818
<   sector_t sector ;
<   int size ;
<   struct drbd_request *i ;
<   struct drbd_epoch_entry *e ;
<   struct hlist_node *n ;
<   struct hlist_head *slot ;
---
>   unsigned int s ;
>   int c_put ;
>   int k_put ;
32355a33820,33821
>   int at_least ;
>   int refcount ;
32357,32367c33823
<   int _b ;
<   long tmp___1 ;
<   struct task_struct *tmp___2 ;
<   struct task_struct *tmp___3 ;
<   int tmp___4 ;
<   struct hlist_node  const  *__mptr ;
<   long tmp___5 ;
<   struct task_struct *tmp___6 ;
<   struct task_struct *tmp___7 ;
<   int tmp___8 ;
<   struct hlist_node  const  *__mptr___0 ;
---
>   int tmp___1 ;
32370,32379c33826,33831
< #line 334
<   mdev = req->mdev;
< #line 335
<   sector = req->sector;
< #line 336
<   size = (int const   )req->size;
< #line 342
<   tmp = hlist_unhashed((struct hlist_node  const  *)(& req->collision));
< #line 342
<   if (tmp == 0) {
---
> #line 339
>   mdev = req->w.ldv_50388.mdev;
> #line 340
>   s = req->rq_state;
> #line 341
>   c_put = 0;
32381,32386c33833
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( hlist_unhashed(&req->collision) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             342);
<   } else {
< 
<   }
---
>   k_put = 0;
32388c33835
<   tmp___0 = get_net_conf(mdev);
---
>   tmp = drbd_suspended(mdev);
32390c33837
<   if (tmp___0 == 0) {
---
>   if (tmp != 0 && ((unsigned long )(s | (unsigned int )clear) & 16384UL) == 0UL) {
32392c33839
<     return (0);
---
>     set = set | 16384;
32396,32403c33843,33850
< #line 348
<   _b = mdev->tl_hash_s == 0U;
< #line 348
<   if (_b != 0) {
< #line 348
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "_req_conflicts", (char *)"mdev->tl_hash_s == 0", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             348);
---
> #line 349
>   req->rq_state = req->rq_state & (unsigned int )(~ clear);
> #line 350
>   req->rq_state = req->rq_state | (unsigned int )set;
> #line 353
>   if (req->rq_state == s) {
> #line 354
>     return;
32407,32410c33854,33857
< #line 348
<   if (_b != 0) {
< #line 349
<     goto out_no_conflict;
---
> #line 358
>   if (((unsigned long )s & 1UL) == 0UL && set & 1) {
> #line 359
>     atomic_inc(& req->completion_ref);
32414,32424c33861,33866
< #line 350
<   tmp___1 = __builtin_expect((unsigned long )mdev->tl_hash == (unsigned long )((struct hlist_head *)0),
<                              0L);
< #line 350
<   if (tmp___1 != 0L) {
< #line 350
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"),
<                          "i" (350), "i" (12UL));
<     ldv_51451: ;
< #line 350
<     goto ldv_51451;
---
> #line 361
>   if (((unsigned long )s & 16UL) == 0UL && ((unsigned long )set & 16UL) != 0UL) {
> #line 362
>     inc_ap_pending(mdev);
> #line 363
>     atomic_inc(& req->completion_ref);
32428,32448c33870,33873
< #line 353
<   slot = tl_hash_slot___0(mdev, sector);
< #line 354
<   n = slot->first;
< #line 354
<   goto ldv_51457;
<   ldv_51456: 
< #line 355
<   tmp___4 = overlaps(i->sector, (int )i->size, sector, size);
< #line 355
<   if (tmp___4 != 0) {
< #line 356
<     tmp___2 = get_current();
< #line 356
<     tmp___3 = get_current();
< #line 356
<     dev_alert((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s[%u] Concurrent local write detected! [DISCARD L] new: %llus +%u; pending: %llus +%u\n",
<               (char *)(& tmp___3->comm), tmp___2->pid, (unsigned long long )sector,
<               size, (unsigned long long )i->sector, i->size);
< #line 362
<     goto out_conflict;
---
> #line 366
>   if (((unsigned long )s & 32UL) == 0UL && ((unsigned long )set & 32UL) != 0UL) {
> #line 367
>     atomic_inc(& req->completion_ref);
32452,32464c33877,33912
< #line 354
<   n = n->next;
<   ldv_51457: ;
< #line 354
<   if ((unsigned long )n != (unsigned long )((struct hlist_node *)0)) {
< #line 354
<     __mptr = (struct hlist_node  const  *)n;
< #line 354
<     i = (struct drbd_request *)__mptr + 0xffffffffffffffd8UL;
< #line 354
<     if (1 != 0) {
< #line 355
<       goto ldv_51456;
---
> #line 369
>   if (((unsigned long )s & 131072UL) == 0UL && ((unsigned long )set & 131072UL) != 0UL) {
> #line 370
>     kref_get(& req->kref);
>   } else {
> 
>   }
> #line 372
>   if (((unsigned long )s & 64UL) == 0UL && ((unsigned long )set & 64UL) != 0UL) {
> #line 373
>     atomic_add((int )(req->i.size >> 9), & mdev->ap_in_flight);
>   } else {
> 
>   }
> #line 375
>   if (((unsigned long )s & 16384UL) == 0UL && ((unsigned long )set & 16384UL) != 0UL) {
> #line 376
>     atomic_inc(& req->completion_ref);
>   } else {
> 
>   }
> #line 380
>   if (((unsigned long )s & 16384UL) != 0UL && ((unsigned long )clear & 16384UL) != 0UL) {
> #line 381
>     c_put = c_put + 1;
>   } else {
> 
>   }
> #line 383
>   if (((unsigned long )s & 8UL) == 0UL && ((unsigned long )set & 8UL) != 0UL) {
> #line 384
>     if (((unsigned long )req->rq_state & 1UL) == 0UL) {
> #line 384
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( req->rq_state & RQ_LOCAL_PENDING ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>               384);
32466,32467c33914
< #line 357
<       goto ldv_51458;
---
> 
32468a33916,33919
> #line 387
>     kref_get(& req->kref);
> #line 388
>     c_put = c_put + 1;
32472,32485c33923,33928
<   ldv_51458: ;
< #line 366
<   if (mdev->ee_hash_s != 0U) {
< #line 368
<     tmp___5 = __builtin_expect((unsigned long )mdev->ee_hash == (unsigned long )((struct hlist_head *)0),
<                                0L);
< #line 368
<     if (tmp___5 != 0L) {
< #line 368
<       __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"),
<                            "i" (368), "i" (12UL));
<       ldv_51459: ;
< #line 368
<       goto ldv_51459;
---
> #line 391
>   if ((int )s & 1 && clear & 1) {
> #line 392
>     if (((unsigned long )req->rq_state & 8UL) != 0UL) {
> #line 393
>       k_put = k_put + 1;
32487c33930,33931
< 
---
> #line 395
>       c_put = c_put + 1;
32489,32509c33933,33957
< #line 371
<     slot = ee_hash_slot___0(mdev, sector);
< #line 372
<     n = slot->first;
< #line 372
<     goto ldv_51464;
<     ldv_51463: 
< #line 373
<     tmp___8 = overlaps(e->sector, (int )e->size, sector, size);
< #line 373
<     if (tmp___8 != 0) {
< #line 374
<       tmp___6 = get_current();
< #line 374
<       tmp___7 = get_current();
< #line 374
<       dev_alert((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s[%u] Concurrent remote write detected! [DISCARD L] new: %llus +%u; pending: %llus +%u\n",
<                 (char *)(& tmp___7->comm), tmp___6->pid, (unsigned long long )sector,
<                 size, (unsigned long long )e->sector, e->size);
< #line 380
<       goto out_conflict;
---
>   } else {
> 
>   }
> #line 398
>   if (((unsigned long )s & 16UL) != 0UL && ((unsigned long )clear & 16UL) != 0UL) {
> #line 399
>     _dec_ap_pending(mdev, "mod_rq_state", 399);
> #line 400
>     c_put = c_put + 1;
>   } else {
> 
>   }
> #line 403
>   if (((unsigned long )s & 32UL) != 0UL && ((unsigned long )clear & 32UL) != 0UL) {
> #line 404
>     c_put = c_put + 1;
>   } else {
> 
>   }
> #line 406
>   if ((((unsigned long )s & 131072UL) != 0UL && ((unsigned long )s & 128UL) == 0UL) && ((unsigned long )set & 128UL) != 0UL) {
> #line 407
>     if (((unsigned long )req->rq_state & 64UL) != 0UL) {
> #line 408
>       atomic_sub((int )(req->i.size >> 9), & mdev->ap_in_flight);
32513,32529c33961,33978
< #line 372
<     n = n->next;
<     ldv_51464: ;
< #line 372
<     if ((unsigned long )n != (unsigned long )((struct hlist_node *)0)) {
< #line 372
<       __mptr___0 = (struct hlist_node  const  *)n;
< #line 372
<       e = (struct drbd_epoch_entry *)__mptr___0 + 0xffffffffffffffe8UL;
< #line 372
<       if (1 != 0) {
< #line 373
<         goto ldv_51463;
<       } else {
< #line 375
<         goto ldv_51465;
<       }
---
> #line 409
>     k_put = k_put + 1;
>   } else {
> 
>   }
> #line 414
>   if (k_put != 0 || c_put != 0) {
> #line 417
>     at_least = (c_put != 0) + k_put;
> #line 418
>     tmp___0 = atomic_read((atomic_t const   *)(& req->kref.refcount));
> #line 418
>     refcount = tmp___0;
> #line 419
>     if (refcount < at_least) {
> #line 420
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "mod_rq_state: Logic BUG: %x -> %x: refcount = %d, should be >= %d\n",
>               s, req->rq_state, refcount, at_least);
32533d33981
<     ldv_51465: ;
32537,32546c33985,34009
<   out_no_conflict: 
< #line 389
<   put_net_conf(mdev);
< #line 390
<   return (0);
<   out_conflict: 
< #line 393
<   put_net_conf(mdev);
< #line 394
<   return (1);
---
> #line 426
>   if ((unsigned int )*((unsigned char *)req + 88UL) != 0U) {
> #line 427
>     __wake_up(& mdev->misc_wait, 3U, 1, 0);
>   } else {
> 
>   }
> #line 429
>   if (c_put != 0) {
> #line 430
>     tmp___1 = drbd_req_put_completion_ref(req, m, c_put);
> #line 430
>     k_put = tmp___1 + k_put;
>   } else {
> 
>   }
> #line 431
>   if (k_put != 0) {
> #line 432
>     kref_sub(& req->kref, (unsigned int )k_put, & drbd_req_destroy);
>   } else {
> 
>   }
> #line 433
>   return;
32549c34012
< #line 397 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
---
> #line 435 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
32557c34020
< #line 401
---
> #line 439
32559,32561c34022,34024
< #line 401
<   if (tmp != 0) {
< #line 402
---
> #line 439
>   if (tmp == 0) {
> #line 440
32566c34029
< #line 404
---
> #line 442
32568c34031
< #line 404
---
> #line 442
32570,32572c34033,34035
<            (req->rq_state & 2048UL) != 0UL ? (char *)"WRITE" : (char *)"READ", (unsigned long long )req->sector,
<            req->size >> 9, tmp___0);
< #line 409
---
>            ((unsigned long )req->rq_state & 2048UL) != 0UL ? (char *)"WRITE" : (char *)"READ",
>            (unsigned long long )req->i.sector, req->i.size >> 9, tmp___0);
> #line 447
32576c34039
< #line 423 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
---
> #line 461 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
32579a34043,34044
>   struct net_conf *nc ;
>   int p ;
32581,32583c34046,34050
<   struct hlist_head *tmp ;
<   struct hlist_head *tmp___0 ;
<   int tmp___1 ;
---
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
>   bool tmp___1 ;
32585c34052
<   int tmp___3 ;
---
>   bool tmp___3 ;
32586a34054,34055
>   struct net_conf *_________p1___0 ;
>   bool __warned___0 ;
32589,32598d34057
<   int tmp___7 ;
<   int tmp___8 ;
<   int tmp___9 ;
<   int tmp___10 ;
<   int tmp___11 ;
<   int tmp___12 ;
<   int tmp___13 ;
<   int tmp___14 ;
<   int tmp___15 ;
<   int tmp___16 ;
32601,32603c34060,34062
< #line 426
<   mdev = req->mdev;
< #line 427
---
> #line 464
>   mdev = req->w.ldv_50388.mdev;
> #line 466
32605,32607c34064,34071
< #line 428
<   m->bio = 0;
< #line 430
---
> #line 468
>   if ((unsigned long )m != (unsigned long )((struct bio_and_error *)0)) {
> #line 469
>     m->bio = 0;
>   } else {
> 
>   }
> #line 471
32610c34074
< #line 432
---
> #line 473
32612,32615c34076,34079
<           (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<           432);
< #line 433
<   goto ldv_51480;
---
>           (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>           473);
> #line 474
>   goto ldv_51994;
32617,32619c34081,34083
< #line 444
<   if ((req->rq_state & 1008UL) != 0UL) {
< #line 444
---
> #line 485
>   if (((unsigned long )req->rq_state & 1008UL) != 0UL) {
> #line 485
32621,32622c34085,34086
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             444);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             485);
32626,32639c34090,34107
< #line 445
<   req->rq_state = req->rq_state | 16UL;
< #line 446
<   inc_ap_pending(mdev);
< #line 447
<   goto ldv_51480;
<   case 2U: ;
< #line 451
<   if ((req->rq_state & 15UL) != 0UL) {
< #line 451
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !(req->rq_state & RQ_LOCAL_MASK) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             451);
<   } else {
---
> #line 486
>   rcu_read_lock();
> #line 487
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 487
>   tmp = debug_lockdep_rcu_enabled();
> #line 487
>   if (tmp != 0 && ! __warned) {
> #line 487
>     tmp___0 = rcu_read_lock_held();
> #line 487
>     if (tmp___0 == 0 && 1) {
> #line 487
>       __warned = 1;
> #line 487
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>                              487, "suspicious rcu_dereference_check() usage");
>     } else {
32641,32669c34109
<   }
< #line 452
<   req->rq_state = req->rq_state | 1UL;
< #line 453
<   goto ldv_51480;
<   case 23U: ;
< #line 456
<   if ((req->rq_state & 2048UL) != 0UL) {
< #line 457
<     mdev->writ_cnt = mdev->writ_cnt + (req->size >> 9);
<   } else {
< #line 459
<     mdev->read_cnt = mdev->read_cnt + (req->size >> 9);
<   }
< #line 461
<   req->rq_state = req->rq_state | 6UL;
< #line 462
<   req->rq_state = req->rq_state & 0xfffffffffffffffeUL;
< #line 464
<   _req_may_be_done_not_susp(req, m);
< #line 465
<   goto ldv_51480;
<   case 22U: 
< #line 468
<   req->rq_state = req->rq_state | 8UL;
< #line 469
<   if ((req->rq_state & 2048UL) != 0UL) {
< #line 470
<     _req_may_be_done_not_susp(req, m);
---
>     }
32671,32672c34111
< #line 472
<     goto goto_queue_for_net_read;
---
> 
32674,32691d34112
< #line 473
<   goto ldv_51480;
<   case 21U: 
< #line 476
<   req->rq_state = req->rq_state | 2UL;
< #line 477
<   req->rq_state = req->rq_state & 0xfffffffffffffffeUL;
< #line 479
<   drbd_report_io_error(mdev, req);
< #line 480
<   __drbd_chk_io_error_(mdev, DRBD_WRITE_ERROR, "__req_mod");
< #line 481
<   _req_may_be_done_not_susp(req, m);
< #line 482
<   goto ldv_51480;
<   case 20U: 
< #line 486
<   req->rq_state = req->rq_state | 2UL;
32693c34114
<   req->rq_state = req->rq_state & 0xfffffffffffffffeUL;
---
>   nc = _________p1;
32695c34116
<   _req_may_be_done_not_susp(req, m);
---
>   p = (int )nc->wire_protocol;
32697,32701c34118,34122
<   goto ldv_51480;
<   case 19U: 
< #line 492
<   __drbd_set_out_of_sync(mdev, req->sector, (int )req->size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<                          492U);
---
>   rcu_read_unlock();
> #line 490
>   req->rq_state = req->rq_state | (p != 3 ? (p == 2 ? 32768U : 0U) : 65536U);
> #line 493
>   mod_rq_state(req, m, 0, 16);
32703,32707c34124,34125
<   req->rq_state = req->rq_state | 2UL;
< #line 495
<   req->rq_state = req->rq_state & 0xfffffffffffffffeUL;
< #line 497
<   if ((req->rq_state & 8UL) != 0UL) {
---
>   goto ldv_51994;
>   case 2U: ;
32709,32711c34127,34131
<     _req_may_be_done(req, m);
< #line 499
<     goto ldv_51480;
---
>   if (((unsigned long )req->rq_state & 15UL) != 0UL) {
> #line 498
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !(req->rq_state & RQ_LOCAL_MASK) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             498);
32715,32716c34135,34139
< #line 502
<   drbd_report_io_error(mdev, req);
---
> #line 499
>   mod_rq_state(req, m, 0, 1);
> #line 500
>   goto ldv_51994;
>   case 24U: ;
32718,32725c34141,34143
<   __drbd_chk_io_error_(mdev, DRBD_READ_ERROR, "__req_mod");
<   goto_queue_for_net_read: ;
< #line 507
<   if ((req->rq_state & 1008UL) != 0UL) {
< #line 507
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !(req->rq_state & RQ_NET_MASK) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             507);
---
>   if (((unsigned long )req->rq_state & 2048UL) != 0UL) {
> #line 504
>     mdev->writ_cnt = mdev->writ_cnt + (req->i.size >> 9);
32727c34145,34146
< 
---
> #line 506
>     mdev->read_cnt = mdev->read_cnt + (req->i.size >> 9);
32729,32732c34148,34152
< #line 511
<   if (*((unsigned int *)mdev + 569UL) != 65536U) {
< #line 512
<     _req_may_be_done_not_susp(req, m);
---
> #line 508
>   mod_rq_state(req, m, 1, 6);
> #line 510
>   goto ldv_51994;
>   case 23U: 
32734,32737c34154,34157
<     goto ldv_51480;
<   } else {
< 
<   }
---
>   mod_rq_state(req, m, 0, 8);
> #line 514
>   goto ldv_51994;
>   case 22U: 
32739c34159
<   req->rq_state = req->rq_state | 16UL;
---
>   drbd_report_io_error(mdev, req);
32741c34161,34178
<   inc_ap_pending(mdev);
---
>   __drbd_chk_io_error_(mdev, DRBD_WRITE_ERROR, "__req_mod");
> #line 519
>   mod_rq_state(req, m, 1, 2);
> #line 520
>   goto ldv_51994;
>   case 20U: 
> #line 523
>   __drbd_set_out_of_sync(mdev, req->i.sector, (int )req->i.size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>                          523U);
> #line 524
>   drbd_report_io_error(mdev, req);
> #line 525
>   __drbd_chk_io_error_(mdev, DRBD_READ_ERROR, "__req_mod");
>   case 21U: 
> #line 529
>   mod_rq_state(req, m, 1, 2);
> #line 530
>   goto ldv_51994;
32743,32751c34180,34205
< #line 531
<   tmp = ar_hash_slot___0(mdev, req->sector);
< #line 531
<   hlist_add_head(& req->collision, tmp);
< #line 533
<   drbd_set_flag(mdev, UNPLUG_REMOTE);
< #line 535
<   if ((req->rq_state & 16UL) == 0UL) {
< #line 535
---
> #line 543
>   tmp___1 = drbd_interval_empty(& req->i);
> #line 543
>   if (tmp___1) {
> #line 543
>     tmp___2 = 0;
>   } else {
> #line 543
>     tmp___2 = 1;
>   }
> #line 543
>   if (tmp___2) {
> #line 543
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( drbd_interval_empty(&req->i) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             543);
>   } else {
> 
>   }
> #line 544
>   drbd_insert_interval(& mdev->read_requests, & req->i);
> #line 546
>   set_bit(0U, (unsigned long volatile   *)(& mdev->flags));
> #line 548
>   if (((unsigned long )req->rq_state & 16UL) == 0UL) {
> #line 548
32753,32754c34207,34208
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             535);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             548);
32758,32765c34212,34228
< #line 536
<   req->rq_state = req->rq_state | 32UL;
< #line 537
<   req->w.cb = (req->rq_state & 15UL) != 0UL ? & w_read_retry_remote : & w_send_read_req;
< #line 540
<   drbd_queue_work(& mdev->data.work, & req->w);
< #line 541
<   goto ldv_51480;
---
> #line 549
>   if (((unsigned long )req->rq_state & 15UL) != 0UL) {
> #line 549
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( (req->rq_state & RQ_LOCAL_MASK) == 0 ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             549);
>   } else {
> 
>   }
> #line 550
>   mod_rq_state(req, m, 0, 32);
> #line 551
>   req->w.cb = & w_send_read_req;
> #line 552
>   drbd_queue_work(& (mdev->tconn)->sender_work, & req->w);
> #line 553
>   goto ldv_51994;
32767,32780c34230,34245
< #line 547
<   tmp___0 = tl_hash_slot___0(mdev, req->sector);
< #line 547
<   hlist_add_head(& req->collision, tmp___0);
< #line 567
<   drbd_set_flag(mdev, UNPLUG_REMOTE);
< #line 571
<   tmp___1 = drbd_test_flag(mdev, CREATE_BARRIER);
< #line 571
<   if (tmp___1 != 0) {
< #line 571
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( drbd_test_flag(mdev, CREATE_BARRIER) == 0 ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             571);
---
> #line 561
>   tmp___3 = drbd_interval_empty(& req->i);
> #line 561
>   if (tmp___3) {
> #line 561
>     tmp___4 = 0;
>   } else {
> #line 561
>     tmp___4 = 1;
>   }
> #line 561
>   if (tmp___4) {
> #line 561
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( drbd_interval_empty(&req->i) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             561);
32784,32790c34249,34255
< #line 573
<   req->epoch = (mdev->newest_tle)->br_number;
< #line 576
<   (mdev->newest_tle)->n_writes = (mdev->newest_tle)->n_writes + 1;
< #line 579
<   if ((req->rq_state & 16UL) == 0UL) {
< #line 579
---
> #line 562
>   drbd_insert_interval(& mdev->write_requests, & req->i);
> #line 581
>   set_bit(0U, (unsigned long volatile   *)(& mdev->flags));
> #line 584
>   if (((unsigned long )req->rq_state & 16UL) == 0UL) {
> #line 584
32792,32793c34257,34258
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             579);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             584);
32797,32802d34261
< #line 580
<   req->rq_state = req->rq_state | 32UL;
< #line 581
<   req->w.cb = & w_send_dblock;
< #line 582
<   drbd_queue_work(& mdev->data.work, & req->w);
32804c34263
<   if ((mdev->newest_tle)->n_writes >= (mdev->net_conf)->max_epoch_size) {
---
>   mod_rq_state(req, m, 0, 131104);
32806c34265,34287
<     queue_barrier(mdev);
---
>   req->w.cb = & w_send_dblock;
> #line 587
>   drbd_queue_work(& (mdev->tconn)->sender_work, & req->w);
> #line 590
>   rcu_read_lock();
> #line 591
>   _________p1___0 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 591
>   tmp___5 = debug_lockdep_rcu_enabled();
> #line 591
>   if (tmp___5 != 0 && ! __warned___0) {
> #line 591
>     tmp___6 = rcu_read_lock_held();
> #line 591
>     if (tmp___6 == 0 && 1) {
> #line 591
>       __warned___0 = 1;
> #line 591
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>                              591, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
32810,32812d34290
< #line 588
<   goto ldv_51480;
<   case 5U: 
32814c34292
<   req->rq_state = req->rq_state | 32UL;
---
>   nc = _________p1___0;
32816c34294
<   req->w.cb = & w_send_oos;
---
>   p = (int )nc->max_epoch_size;
32818c34296
<   drbd_queue_work(& mdev->data.work, & req->w);
---
>   rcu_read_unlock();
32820c34298,34314
<   goto ldv_51480;
---
>   if ((mdev->tconn)->current_tle_writes >= (unsigned int )p) {
> #line 595
>     start_new_tl_epoch(mdev->tconn);
>   } else {
> 
>   }
> #line 597
>   goto ldv_51994;
>   case 5U: 
> #line 600
>   mod_rq_state(req, m, 0, 32);
> #line 601
>   req->w.cb = & w_send_out_of_sync;
> #line 602
>   drbd_queue_work(& (mdev->tconn)->sender_work, & req->w);
> #line 603
>   goto ldv_51994;
32824,32832d34317
< #line 601
<   req->rq_state = req->rq_state & 0xffffffffffffffdfUL;
< #line 604
<   _req_may_be_done_not_susp(req, m);
< #line 605
<   goto ldv_51480;
<   case 8U: ;
< #line 609
<   if ((int )(req->master_bio)->bi_rw & 1) {
32834,32864c34319,34324
<     atomic_add((int )(req->size >> 9), & mdev->ap_in_flight);
<   } else {
< 
<   }
< #line 612
<   if ((int )(req->master_bio)->bi_rw & 1 && (mdev->net_conf)->wire_protocol == 1) {
< #line 616
<     if ((req->rq_state & 16UL) != 0UL) {
< #line 617
<       tmp___2 = atomic_dec_and_test(& mdev->ap_pending_cnt);
< #line 617
<       if (tmp___2 != 0) {
< #line 617
<         __wake_up(& mdev->misc_wait, 3U, 1, 0);
<       } else {
< 
<       }
< #line 617
<       tmp___4 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 617
<       if (tmp___4 < 0) {
< #line 617
<         tmp___3 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 617
<         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: ap_pending_cnt = %d < 0 !\n",
<                 "__req_mod", 617, tmp___3);
<       } else {
< 
<       }
< #line 618
<       req->rq_state = req->rq_state & 0xffffffffffffffefUL;
---
>   mod_rq_state(req, m, 32, 0);
> #line 611
>   goto ldv_51994;
>   case 8U: ;
> #line 615
>   if ((int )(req->master_bio)->bi_rw & 1 && ((unsigned long )req->rq_state & 98304UL) == 0UL) {
32866c34326,34328
<       req->rq_state = req->rq_state | 256UL;
---
>     if (((unsigned long )req->rq_state & 16UL) != 0UL) {
> #line 620
>       mod_rq_state(req, m, 16, 256);
32873,32874d34334
< #line 625
<   req->rq_state = req->rq_state & 0xffffffffffffffdfUL;
32876c34336
<   req->rq_state = req->rq_state | 64UL;
---
>   mod_rq_state(req, m, 32, 64);
32878,32880c34338
<   _req_may_be_done_not_susp(req, m);
< #line 628
<   goto ldv_51480;
---
>   goto ldv_51994;
32881a34340,34341
> #line 632
>   mod_rq_state(req, m, 32, 128);
32883,32924c34343,34355
<   req->rq_state = req->rq_state & 0xffffffffffffffdfUL;
< #line 634
<   req->rq_state = req->rq_state | 128UL;
< #line 635
<   _req_may_be_done_not_susp(req, m);
< #line 636
<   goto ldv_51480;
<   case 10U: ;
< #line 641
<   if ((req->rq_state & 16UL) != 0UL) {
< #line 642
<     tmp___5 = atomic_dec_and_test(& mdev->ap_pending_cnt);
< #line 642
<     if (tmp___5 != 0) {
< #line 642
<       __wake_up(& mdev->misc_wait, 3U, 1, 0);
<     } else {
< 
<     }
< #line 642
<     tmp___7 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 642
<     if (tmp___7 < 0) {
< #line 642
<       tmp___6 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 642
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: ap_pending_cnt = %d < 0 !\n",
<               "__req_mod", 642, tmp___6);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 643
<   req->rq_state = req->rq_state & 0xfffffffffffffeefUL;
< #line 644
<   req->rq_state = req->rq_state | 128UL;
< #line 645
<   if ((req->rq_state & 64UL) != 0UL && (req->rq_state & 2048UL) != 0UL) {
< #line 646
<     atomic_sub((int )(req->size >> 9), & mdev->ap_in_flight);
---
>   goto ldv_51994;
>   case 10U: 
> #line 637
>   mod_rq_state(req, m, 16656, 128);
> #line 640
>   goto ldv_51994;
>   case 15U: ;
> #line 650
>   if (((unsigned long )req->rq_state & 16UL) == 0UL) {
> #line 650
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( req->rq_state & RQ_NET_PENDING ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             650);
32928,32929d34358
< #line 650
<   if ((req->rq_state & 32UL) == 0UL) {
32931c34360,34364
<     _req_may_be_done(req, m);
---
>   if (((unsigned long )req->rq_state & 65536UL) == 0UL) {
> #line 651
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( req->rq_state & RQ_EXP_WRITE_ACK ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             651);
32936,32937c34369,34375
<   goto ldv_51480;
<   case 15U: ;
---
>   mod_rq_state(req, m, 16, 384);
> #line 653
>   goto ldv_51994;
>   case 14U: 
> #line 656
>   req->rq_state = req->rq_state | 512U;
>   case 13U: ;
32939,32942c34377,34381
<   if ((unsigned int )what == 15U) {
< #line 659
<     dev_alert((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Got DiscardAck packet %llus +%u! DRBD is not a random data generator!\n",
<               (unsigned long long )req->sector, req->size);
---
>   if (((unsigned long )req->rq_state & 65536UL) == 0UL) {
> #line 658
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( req->rq_state & RQ_EXP_WRITE_ACK ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             658);
32946,32949c34385,34387
< #line 662
<   req->rq_state = req->rq_state | 128UL;
<   case 14U: ;
<   case 13U: ;
---
> #line 664
>   goto ack_common;
>   case 12U: ;
32951,32953c34389,34393
<   if ((unsigned int )what == 14U) {
< #line 667
<     req->rq_state = req->rq_state | 512UL;
---
>   if (((unsigned long )req->rq_state & 32768UL) == 0UL) {
> #line 666
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( req->rq_state & RQ_EXP_RECEIVE_ACK ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             666);
32957,32962c34397,34400
<   case 12U: 
< #line 677
<   req->rq_state = req->rq_state | 256UL;
< #line 678
<   if ((req->rq_state & 16UL) == 0UL) {
< #line 678
---
>   ack_common: ;
> #line 671
>   if (((unsigned long )req->rq_state & 16UL) == 0UL) {
> #line 671
32964,32965c34402,34403
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             678);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             671);
32969,32974c34407,34417
< #line 679
<   tmp___8 = atomic_dec_and_test(& mdev->ap_pending_cnt);
< #line 679
<   if (tmp___8 != 0) {
< #line 679
<     __wake_up(& mdev->misc_wait, 3U, 1, 0);
---
> #line 672
>   mod_rq_state(req, m, 16, 256);
> #line 673
>   goto ldv_51994;
>   case 16U: ;
> #line 676
>   if (((unsigned long )req->rq_state & 65536UL) == 0UL) {
> #line 676
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( req->rq_state & RQ_EXP_WRITE_ACK ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             676);
32978,32986c34421,34426
< #line 679
<   tmp___10 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 679
<   if (tmp___10 < 0) {
< #line 679
<     tmp___9 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 679
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: ap_pending_cnt = %d < 0 !\n",
<             "__req_mod", 679, tmp___9);
---
> #line 681
>   if (((unsigned long )req->rq_state & 16UL) == 0UL) {
> #line 681
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( req->rq_state & RQ_NET_PENDING ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             681);
32990,32993d34429
< #line 680
<   atomic_sub((int )(req->size >> 9), & mdev->ap_in_flight);
< #line 681
<   req->rq_state = req->rq_state & 0xffffffffffffffefUL;
32995c34431
<   _req_may_be_done_not_susp(req, m);
---
>   req->rq_state = req->rq_state | 8192U;
32997,33023c34433,34435
<   goto ldv_51480;
<   case 16U: ;
< #line 687
<   if ((req->rq_state & 16UL) != 0UL) {
< #line 688
<     tmp___11 = atomic_dec_and_test(& mdev->ap_pending_cnt);
< #line 688
<     if (tmp___11 != 0) {
< #line 688
<       __wake_up(& mdev->misc_wait, 3U, 1, 0);
<     } else {
< 
<     }
< #line 688
<     tmp___13 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 688
<     if (tmp___13 < 0) {
< #line 688
<       tmp___12 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 688
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: ap_pending_cnt = %d < 0 !\n",
<               "__req_mod", 688, tmp___12);
<     } else {
< 
<     }
< #line 689
<     atomic_sub((int )(req->size >> 9), & mdev->ap_in_flight);
---
>   if ((unsigned int )*((unsigned char *)req + 88UL) != 0U) {
> #line 684
>     __wake_up(& mdev->misc_wait, 3U, 1, 0);
33026a34439,34441
> #line 688
>   goto ldv_51994;
>   case 17U: 
33028,33032c34443,34448
<   req->rq_state = req->rq_state & 0xfffffffffffffeefUL;
< #line 693
<   req->rq_state = req->rq_state | 128UL;
< #line 694
<   _req_may_be_done_not_susp(req, m);
---
>   mod_rq_state(req, m, 272, 0);
> #line 692
>   goto ldv_51994;
>   case 26U: ;
> #line 695
>   if (((unsigned long )req->rq_state & 2UL) == 0UL) {
33034,33039c34450
<   goto ldv_51480;
<   case 25U: ;
< #line 699
<   if ((req->rq_state & 2UL) == 0UL) {
< #line 700
<     goto ldv_51480;
---
>     goto ldv_51994;
33042a34454,34460
> #line 697
>   mod_rq_state(req, m, 16384, 0);
> #line 698
>   goto ldv_51994;
>   case 27U: ;
> #line 701
>   if (((unsigned long )req->rq_state & 2UL) == 0UL) {
33044,33051c34462
<   _req_may_be_done(req, m);
< #line 703
<   goto ldv_51480;
<   case 26U: ;
< #line 706
<   if ((req->rq_state & 2UL) == 0UL) {
< #line 707
<     goto ldv_51480;
---
>     goto ldv_51994;
33055,33057c34466,34468
< #line 709
<   req->rq_state = req->rq_state & 0xfffffffffffffffdUL;
< #line 711
---
> #line 704
>   mod_rq_state(req, m, 16386, 1);
> #line 708
33059c34470
< #line 712
---
> #line 709
33061c34472
< #line 713
---
> #line 710
33066c34477
< #line 715
---
> #line 712
33068c34479
< #line 716
---
> #line 713
33070,33082c34481,34492
< #line 717
<   drbd_queue_work(& mdev->data.work, & req->w);
< #line 718
<   goto ldv_51480;
<   case 24U: ;
< #line 722
<   if ((req->rq_state & 2048UL) == 0UL && (unsigned long )req->w.cb == (unsigned long )((int (*)(struct drbd_conf * ,
<                                                                                                 struct drbd_work * ,
<                                                                                                 int  ))0)) {
< #line 723
<     _req_may_be_done(req, m);
< #line 724
<     goto ldv_51480;
---
> #line 714
>   drbd_queue_work(& (mdev->tconn)->sender_work, & req->w);
> #line 715
>   goto ldv_51994;
>   case 25U: ;
> #line 719
>   if (((unsigned long )req->rq_state & 2048UL) == 0UL && (unsigned long )req->w.cb == (unsigned long )((int (*)(struct drbd_work * ,
>                                                                                                                 int  ))0)) {
> #line 720
>     mod_rq_state(req, m, 16384, 0);
> #line 721
>     goto ldv_51994;
33086,33091c34496,34497
< #line 731
<   if ((req->rq_state & 256UL) == 0UL) {
< #line 732
<     if ((unsigned long )req->w.cb != (unsigned long )((int (*)(struct drbd_conf * ,
<                                                                struct drbd_work * ,
<                                                                int  ))0)) {
---
> #line 729
>   if (((unsigned long )req->rq_state & 256UL) == 0UL) {
33093c34499
<       drbd_queue_work(& mdev->data.work, & req->w);
---
>     mod_rq_state(req, m, 16384, 48);
33095c34501,34506
<       rv = (req->rq_state & 2048UL) != 0UL ? 1 : 2;
---
>     if ((unsigned long )req->w.cb != (unsigned long )((int (*)(struct drbd_work * ,
>                                                                int  ))0)) {
> #line 735
>       drbd_queue_work(& (mdev->tconn)->sender_work, & req->w);
> #line 736
>       rv = ((unsigned long )req->rq_state & 2048UL) != 0UL ? 1 : 2;
33099,33108c34510,34511
< #line 736
<     goto ldv_51480;
<   } else {
< 
<   }
<   case 17U: ;
< #line 741
<   if ((req->rq_state & 2048UL) == 0UL) {
< #line 742
<     goto ldv_51480;
---
> #line 738
>     goto ldv_51994;
33111a34515
>   case 18U: ;
33113,33117c34517,34519
<   if ((req->rq_state & 16UL) != 0UL) {
< #line 748
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "FIXME (barrier_acked but pending)\n");
< #line 749
<     list_move(& req->tl_requests, & mdev->out_of_sequence_requests);
---
>   if (((unsigned long )req->rq_state & 2048UL) == 0UL) {
> #line 745
>     goto ldv_51994;
33120a34523,34524
> #line 747
>   if (((unsigned long )req->rq_state & 16UL) != 0UL) {
33122,33131c34526
<   if ((req->rq_state & 1008UL) != 0UL) {
< #line 752
<     req->rq_state = req->rq_state | 128UL;
< #line 753
<     if ((mdev->net_conf)->wire_protocol == 1) {
< #line 754
<       atomic_sub((int )(req->size >> 9), & mdev->ap_in_flight);
<     } else {
< 
<     }
---
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "FIXME (BARRIER_ACKED but pending)\n");
33135,33136d34529
< #line 756
<   _req_may_be_done(req, m);
33138,33142c34531,34537
<   goto ldv_51480;
<   case 18U: ;
< #line 760
<   if ((req->rq_state & 16UL) == 0UL) {
< #line 760
---
>   mod_rq_state(req, m, 16384, ((unsigned long )req->rq_state & 1008UL) != 0UL ? 128 : 0);
> #line 759
>   goto ldv_51994;
>   case 19U: ;
> #line 762
>   if (((unsigned long )req->rq_state & 16UL) == 0UL) {
> #line 762
33144,33166c34539,34540
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             760);
<   } else {
< 
<   }
< #line 761
<   tmp___14 = atomic_dec_and_test(& mdev->ap_pending_cnt);
< #line 761
<   if (tmp___14 != 0) {
< #line 761
<     __wake_up(& mdev->misc_wait, 3U, 1, 0);
<   } else {
< 
<   }
< #line 761
<   tmp___16 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 761
<   if (tmp___16 < 0) {
< #line 761
<     tmp___15 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 761
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: ap_pending_cnt = %d < 0 !\n",
<             "__req_mod", 761, tmp___15);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             762);
33170,33171d34543
< #line 762
<   req->rq_state = req->rq_state & 0xffffffffffffffefUL;
33173c34545
<   req->rq_state = req->rq_state | 384UL;
---
>   mod_rq_state(req, m, 16, 384);
33175,33177c34547
<   _req_may_be_done_not_susp(req, m);
< #line 765
<   goto ldv_51480;
---
>   goto ldv_51994;
33179,33180c34549,34550
<   ldv_51480: ;
< #line 768
---
>   ldv_51994: ;
> #line 767
33184,33185c34554,34555
< #line 778 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
< static int drbd_may_do_local_read(struct drbd_conf *mdev , sector_t sector , int size ) 
---
> #line 777 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static bool drbd_may_do_local_read(struct drbd_conf *mdev , sector_t sector , int size ) 
33193a34564,34565
> #line 782
>   if ((unsigned int )*((unsigned char *)mdev + 749UL) == 16U) {
33195,33196d34566
<   if ((unsigned int )*((unsigned char *)mdev + 2277UL) == 16U) {
< #line 784
33200a34571,34572
> #line 784
>   if ((unsigned int )*((unsigned char *)mdev + 749UL) != 8U) {
33202,33203d34573
<   if ((int )mdev->state.ldv_40583.disk > 4) {
< #line 786
33207a34578,34579
> #line 786
>   esector = ((sector_t )(size >> 9) + sector) - 1UL;
33209,33215d34580
<   if ((int )mdev->state.ldv_40583.disk <= 3) {
< #line 788
<     return (0);
<   } else {
< 
<   }
< #line 790
33217,33219c34582
< #line 791
<   esector = ((sector_t )(size >> 9) + sector) - 1UL;
< #line 793
---
> #line 788
33221c34584
< #line 793
---
> #line 788
33223,33224c34586,34587
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             793);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             788);
33228c34591
< #line 794
---
> #line 789
33230c34593
< #line 794
---
> #line 789
33232,33233c34595,34596
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             794);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             789);
33237c34600
< #line 796
---
> #line 791
33239c34602
< #line 797
---
> #line 792
33241c34604
< #line 799
---
> #line 794
33243c34606
< #line 799
---
> #line 794
33247,33248c34610,34612
< #line 802 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
< static void maybe_pull_ahead(struct drbd_conf *mdev ) 
---
> #line 797 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static bool remote_due_to_read_balancing(struct drbd_conf *mdev , sector_t sector ,
>                                          enum drbd_read_balancing rbm ) 
33250c34614,34615
<   int congested ;
---
>   struct backing_dev_info *bdi ;
>   int stripe_shift ;
33253,33254c34618,34620
<   union drbd_state __ns ;
<   union drbd_state __ns___0 ;
---
>   int tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
33257,33273c34623,34646
< #line 804
<   congested = 0;
< #line 811
<   tmp = _get_ldev_if_state(mdev, D_UP_TO_DATE);
< #line 811
<   if (tmp == 0) {
< #line 812
<     return;
<   } else {
< 
<   }
< #line 814
<   if ((mdev->net_conf)->cong_fill != 0) {
< #line 814
<     tmp___0 = atomic_read((atomic_t const   *)(& mdev->ap_in_flight));
< #line 814
<     if (tmp___0 >= (mdev->net_conf)->cong_fill) {
---
> #line 803
>   switch ((unsigned int )rbm) {
>   case 4U: 
> #line 805
>   bdi = & ((((mdev->ldev)->backing_bdev)->bd_disk)->queue)->backing_dev_info;
> #line 806
>   tmp = bdi_read_congested(bdi);
> #line 806
>   return (tmp != 0);
>   case 3U: 
> #line 808
>   tmp___0 = atomic_read((atomic_t const   *)(& mdev->local_cnt));
> #line 808
>   tmp___1 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
> #line 808
>   tmp___2 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
> #line 808
>   return (tmp___0 > tmp___1 + tmp___2);
>   case 5U: ;
>   case 6U: ;
>   case 7U: ;
>   case 8U: ;
>   case 9U: ;
>   case 10U: 
33275c34648
<       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Congestion-fill threshold reached\n");
---
>   stripe_shift = (int )((unsigned int )rbm + 10U);
33277,33285c34650,34656
<       congested = 1;
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 820
<   if ((mdev->act_log)->used >= (unsigned int )(mdev->net_conf)->cong_extents) {
---
>   return (((sector >> (stripe_shift + -9)) & 1UL) != 0UL);
>   case 2U: 
> #line 819
>   tmp___3 = test_and_change_bit(22, (unsigned long volatile   *)(& mdev->flags));
> #line 819
>   return (tmp___3 != 0);
>   case 1U: ;
33287,33314c34658,34662
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Congestion-extents threshold reached\n");
< #line 822
<     congested = 1;
<   } else {
< 
<   }
< #line 825
<   if (congested != 0) {
< #line 826
<     queue_barrier(mdev);
< #line 828
<     if ((mdev->net_conf)->on_congestion == 1) {
< #line 829
<       __ns.i = mdev->state.i;
< #line 829
<       __ns.ldv_40583.conn = 22U;
< #line 829
<       _drbd_set_state(mdev, __ns, 0, 0);
<     } else {
< #line 831
<       __ns___0.i = mdev->state.i;
< #line 831
<       __ns___0.ldv_40583.conn = 1U;
< #line 831
<       _drbd_set_state(mdev, __ns___0, 0, 0);
<     }
<   } else {
< 
---
>   return (1);
>   case 0U: ;
>   default: ;
> #line 824
>   return (0);
33316,33319d34663
< #line 833
<   put_ldev(mdev);
< #line 834
<   return;
33322,33323c34666,34667
< #line 836 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
< static int drbd_make_request_common(struct drbd_conf *mdev , struct bio *bio , unsigned long start_time ) 
---
> #line 837 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static void complete_conflicting_writes(struct drbd_request *req ) 
33325,33326c34669,34672
<   int rw ;
<   int size ;
---
>   wait_queue_t wait ;
>   struct task_struct *tmp ;
>   struct drbd_conf *mdev ;
>   struct drbd_interval *i ;
33328,33363c34674
<   struct drbd_tl_epoch *b ;
<   struct drbd_request *req ;
<   int local ;
<   int remote ;
<   int send_oos ;
<   int err ;
<   int ret ;
<   union drbd_state s ;
<   long tmp ;
<   int tmp___0 ;
<   int tmp___1 ;
<   bool tmp___2 ;
<   int tmp___3 ;
<   bool tmp___4 ;
<   int tmp___5 ;
<   int tmp___6 ;
<   int tmp___7 ;
<   void *tmp___8 ;
<   int tmp___9 ;
<   int tmp___10 ;
<   bool tmp___11 ;
<   bool tmp___12 ;
<   int tmp___13 ;
<   int tmp___14 ;
<   int tmp___15 ;
<   int tmp___16 ;
<   int tmp___17 ;
<   long tmp___18 ;
<   int tmp___19 ;
<   long tmp___20 ;
<   bool tmp___21 ;
<   int tmp___22 ;
<   int tmp___23 ;
<   int tmp___24 ;
<   int tmp___25 ;
<   int tmp___26 ;
---
>   int size ;
33366,33367d34676
< #line 838
<   rw = (int const   )bio->bi_rw & (int const   )8193;
33369c34678,34688
<   size = (int const   )bio->bi_size;
---
>   tmp = get_current();
> #line 839
>   wait.flags = 0U;
> #line 839
>   wait.private = (void *)tmp;
> #line 839
>   wait.func = & autoremove_wake_function;
> #line 839
>   wait.task_list.next = & wait.task_list;
> #line 839
>   wait.task_list.prev = & wait.task_list;
33371,33373c34690,34692
<   sector = bio->bi_sector;
< #line 841
<   b = 0;
---
>   mdev = req->w.ldv_50388.mdev;
> #line 842
>   sector = req->i.sector;
33375,33377c34694
<   send_oos = 0;
< #line 844
<   err = -5;
---
>   size = (int )req->i.size;
33379,33381c34696,34704
<   ret = 0;
< #line 849
<   req = drbd_req_new(mdev, bio);
---
>   i = drbd_find_overlap(& mdev->write_requests, sector, (unsigned int )size);
> #line 846
>   if ((unsigned long )i == (unsigned long )((struct drbd_interval *)0)) {
> #line 847
>     return;
>   } else {
> 
>   }
>   ldv_52067: 
33383c34706
<   if ((unsigned long )req == (unsigned long )((struct drbd_request *)0)) {
---
>   prepare_to_wait(& mdev->misc_wait, & wait, 2);
33385,33391c34708,34712
<     dec_ap_bio(mdev);
< #line 854
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "could not kmalloc() req\n");
< #line 855
<     bio_endio(bio, -12);
< #line 856
<     return (0);
---
>   i = drbd_find_overlap(& mdev->write_requests, sector, (unsigned int )size);
> #line 852
>   if ((unsigned long )i == (unsigned long )((struct drbd_interval *)0)) {
> #line 853
>     goto ldv_52066;
33394a34716,34721
> #line 855
>   i->waiting = -1;
> #line 856
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 857
>   schedule();
33396c34723,34726
<   req->start_time = start_time;
---
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 859
>   goto ldv_52067;
>   ldv_52066: 
33398c34728
<   local = _get_ldev_if_state(mdev, D_INCONSISTENT);
---
>   finish_wait(& mdev->misc_wait, & wait);
33400,33405c34730,34747
<   if (local == 0) {
< #line 862
<     bio_put(req->private_bio);
< #line 863
<     req->private_bio = 0;
<   } else {
---
>   return;
> }
> }
> #line 864 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static void maybe_pull_ahead(struct drbd_conf *mdev ) 
> { 
>   struct drbd_tconn *tconn ;
>   struct net_conf *nc ;
>   bool congested ;
>   enum drbd_on_congestion on_congestion ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
>   union drbd_state __ns ;
>   union drbd_state __ns___0 ;
33407,33413c34749,34753
<   }
< #line 865
<   if (rw == 1) {
< #line 869
<     tmp = __builtin_expect(size == 0, 0L);
< #line 869
<     if (tmp != 0L) {
---
>   {
> #line 866
>   tconn = mdev->tconn;
> #line 868
>   congested = 0;
33415c34755
<       if ((bio->bi_rw & 4096UL) == 0UL) {
---
>   _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
33417,33424c34757,34768
<         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( bio->bi_rw & REQ_FLUSH ) in %s:%d\n",
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<                 871);
<       } else {
< 
<       }
< #line 872
<       remote = 0;
---
>   tmp = debug_lockdep_rcu_enabled();
> #line 871
>   if (tmp != 0 && ! __warned) {
> #line 871
>     tmp___0 = rcu_read_lock_held();
> #line 871
>     if (tmp___0 == 0 && 1) {
> #line 871
>       __warned = 1;
> #line 871
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>                              871, "suspicious rcu_dereference_check() usage");
33426,33427c34770
< #line 874
<       remote = 1;
---
> 
33430,33444d34772
< #line 877
<     if (local != 0) {
< #line 878
<       tmp___0 = drbd_may_do_local_read(mdev, sector, size);
< #line 878
<       if (tmp___0 == 0) {
< #line 884
<         local = 0;
< #line 885
<         bio_put(req->private_bio);
< #line 886
<         req->private_bio = 0;
< #line 887
<         put_ldev(mdev);
<       } else {
33446,33447c34774,34783
<       }
<     } else {
---
>   }
> #line 871
>   nc = _________p1;
> #line 872
>   on_congestion = (unsigned long )nc != (unsigned long )((struct net_conf *)0) ? (enum drbd_on_congestion )nc->on_congestion : OC_BLOCK;
> #line 873
>   if ((unsigned int )on_congestion == 0U || tconn->agreed_pro_version <= 95) {
> #line 875
>     return;
>   } else {
33449,33451d34784
<     }
< #line 890
<     remote = local == 0 && (int )mdev->state.ldv_40583.pdsk > 7;
33453,33458c34786,34791
< #line 901
<   if ((rw == 8192 && (int )mdev->state.ldv_40583.disk > 3) && local == 0) {
< #line 902
<     err = -11;
< #line 903
<     goto fail_and_free_req;
---
> #line 881
>   tmp___1 = _get_ldev_if_state(mdev, D_UP_TO_DATE);
> #line 881
>   if (tmp___1 == 0) {
> #line 882
>     return;
33462,33471c34795,34804
< #line 913
<   if ((rw == 1 && local != 0) && size != 0) {
< #line 913
<     tmp___1 = drbd_test_flag(mdev, AL_SUSPENDED);
< #line 913
<     if (tmp___1 == 0) {
< #line 915
<       req->rq_state = req->rq_state | 4096UL;
< #line 916
<       drbd_al_begin_io(mdev, sector);
---
> #line 884
>   if (nc->cong_fill != 0U) {
> #line 884
>     tmp___2 = atomic_read((atomic_t const   *)(& mdev->ap_in_flight));
> #line 884
>     if ((__u32 )tmp___2 >= nc->cong_fill) {
> #line 886
>       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Congestion-fill threshold reached\n");
> #line 887
>       congested = 1;
33478,33491c34811,34816
< #line 919
<   s = mdev->state;
< #line 920
<   if (remote != 0) {
< #line 920
<     tmp___2 = drbd_should_do_remote(s);
< #line 920
<     if ((int )tmp___2) {
< #line 920
<       tmp___3 = 1;
<     } else {
< #line 920
<       tmp___3 = 0;
<     }
---
> #line 890
>   if ((mdev->act_log)->used >= nc->cong_extents) {
> #line 891
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Congestion-extents threshold reached\n");
> #line 892
>     congested = 1;
33493,33494c34818
< #line 920
<     tmp___3 = 0;
---
> 
33496,33505c34820,34831
< #line 920
<   remote = tmp___3;
< #line 921
<   if (rw == 1) {
< #line 921
<     tmp___4 = drbd_should_send_oos(s);
< #line 921
<     if ((int )tmp___4) {
< #line 921
<       tmp___5 = 1;
---
> #line 895
>   if ((int )congested) {
> #line 897
>     start_new_tl_epoch(mdev->tconn);
> #line 899
>     if ((unsigned int )on_congestion == 1U) {
> #line 900
>       __ns = drbd_read_state(mdev);
> #line 900
>       __ns.ldv_40604.conn = 22U;
> #line 900
>       _drbd_set_state(mdev, __ns, 0, 0);
33507,33508c34833,34838
< #line 921
<       tmp___5 = 0;
---
> #line 902
>       __ns___0 = drbd_read_state(mdev);
> #line 902
>       __ns___0.ldv_40604.conn = 1U;
> #line 902
>       _drbd_set_state(mdev, __ns___0, 0, 0);
33511,33512c34841
< #line 921
<     tmp___5 = 0;
---
> 
33513a34843,34864
> #line 904
>   put_ldev(mdev);
> #line 905
>   return;
> }
> }
> #line 916 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static bool do_remote_read(struct drbd_request *req ) 
> { 
>   struct drbd_conf *mdev ;
>   enum drbd_read_balancing rbm ;
>   bool tmp ;
>   int tmp___0 ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___1 ;
>   int tmp___2 ;
>   bool tmp___3 ;
> 
>   {
> #line 918
>   mdev = req->w.ldv_50388.mdev;
33515c34866
<   send_oos = tmp___5;
---
>   if ((unsigned long )req->private_bio != (unsigned long )((struct bio *)0)) {
33517c34868
<   if (remote != 0 && send_oos != 0) {
---
>     tmp = drbd_may_do_local_read(mdev, req->i.sector, (int )req->i.size);
33519,33528c34870,34878
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !(remote && send_oos) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             922);
<   } else {
< 
<   }
< #line 924
<   if (local == 0 && remote == 0) {
< #line 924
<     tmp___7 = is_susp(mdev->state);
---
>     if (tmp) {
> #line 922
>       tmp___0 = 0;
>     } else {
> #line 922
>       tmp___0 = 1;
>     }
> #line 922
>     if (tmp___0) {
33530c34880
<     if (tmp___7 == 0) {
---
>       bio_put(req->private_bio);
33532,33534c34882
<       tmp___6 = ___ratelimit(& drbd_ratelimit_state, "drbd_make_request_common");
< #line 925
<       if (tmp___6 != 0) {
---
>       req->private_bio = 0;
33536,33542c34884
<         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "IO ERROR: neither local nor remote data, sector %llu+%u\n",
<                 (unsigned long long )req->sector, req->size >> 9);
<       } else {
< 
<       }
< #line 928
<       goto fail_free_complete;
---
>       put_ldev(mdev);
33549,33568c34891,34895
< #line 937
<   if ((rw == 1 && (remote != 0 || send_oos != 0)) && (unsigned long )mdev->unused_spare_tle == (unsigned long )((struct drbd_tl_epoch *)0)) {
< #line 937
<     tmp___9 = drbd_test_flag(mdev, CREATE_BARRIER);
< #line 937
<     if (tmp___9 != 0) {
<       allocate_barrier: 
< #line 941
<       tmp___8 = kmalloc(56UL, 16U);
< #line 941
<       b = (struct drbd_tl_epoch *)tmp___8;
< #line 942
<       if ((unsigned long )b == (unsigned long )((struct drbd_tl_epoch *)0)) {
< #line 943
<         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Failed to alloc barrier.\n");
< #line 944
<         err = -12;
< #line 945
<         goto fail_free_complete;
<       } else {
---
> #line 930
>   if (*((unsigned int *)mdev + 187UL) != 65536U) {
> #line 931
>     return (0);
>   } else {
33570c34897,34921
<       }
---
>   }
> #line 933
>   if ((unsigned long )req->private_bio == (unsigned long )((struct bio *)0)) {
> #line 934
>     return (1);
>   } else {
> 
>   }
> #line 939
>   rcu_read_lock();
> #line 940
>   _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 940
>   tmp___1 = debug_lockdep_rcu_enabled();
> #line 940
>   if (tmp___1 != 0 && ! __warned) {
> #line 940
>     tmp___2 = rcu_read_lock_held();
> #line 940
>     if (tmp___2 == 0 && 1) {
> #line 940
>       __warned = 1;
> #line 940
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>                              940, "suspicious rcu_dereference_check() usage");
33577,33588c34928,34935
< #line 950
<   spin_lock_irq(& mdev->req_lock);
< #line 952
<   tmp___10 = is_susp(mdev->state);
< #line 952
<   if (tmp___10 != 0) {
< #line 957
<     ret = 1;
< #line 958
<     spin_unlock_irq(& mdev->req_lock);
< #line 959
<     goto fail_free_complete;
---
> #line 940
>   rbm = (enum drbd_read_balancing )_________p1->read_balancing;
> #line 941
>   rcu_read_unlock();
> #line 943
>   if ((unsigned int )rbm == 0U && (unsigned long )req->private_bio != (unsigned long )((struct bio *)0)) {
> #line 944
>     return (0);
33592,33621c34939,34950
< #line 962
<   if (remote != 0 || send_oos != 0) {
< #line 963
<     tmp___11 = drbd_should_do_remote(mdev->state);
< #line 963
<     remote = (int )tmp___11;
< #line 964
<     if (rw == 1) {
< #line 964
<       tmp___12 = drbd_should_send_oos(mdev->state);
< #line 964
<       if ((int )tmp___12) {
< #line 964
<         tmp___13 = 1;
<       } else {
< #line 964
<         tmp___13 = 0;
<       }
<     } else {
< #line 964
<       tmp___13 = 0;
<     }
< #line 964
<     send_oos = tmp___13;
< #line 965
<     if (remote != 0 && send_oos != 0) {
< #line 965
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !(remote && send_oos) ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<               965);
---
> #line 946
>   tmp___3 = remote_due_to_read_balancing(mdev, req->i.sector, rbm);
> #line 946
>   if ((int )tmp___3) {
> #line 947
>     if ((unsigned long )req->private_bio != (unsigned long )((struct bio *)0)) {
> #line 948
>       bio_put(req->private_bio);
> #line 949
>       req->private_bio = 0;
> #line 950
>       put_ldev(mdev);
33624a34954,34979
> #line 952
>     return (1);
>   } else {
> 
>   }
> #line 955
>   return (0);
> }
> }
> #line 961 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static int drbd_process_write_request(struct drbd_request *req ) 
> { 
>   struct drbd_conf *mdev ;
>   int remote ;
>   int send_oos ;
>   bool tmp ;
>   bool tmp___0 ;
>   bool tmp___1 ;
>   long tmp___2 ;
>   int tmp___3 ;
> 
>   {
> #line 963
>   mdev = req->w.ldv_50388.mdev;
> #line 966
>   rcu_read_lock();
33626c34981,34983
<     if (remote == 0 && send_oos == 0) {
---
>   tmp = drbd_should_do_remote(mdev->state);
> #line 967
>   remote = (int )tmp;
33628,33631c34985
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "lost connection while grabbing the req_lock!\n");
<     } else {
< 
<     }
---
>   if (remote != 0) {
33633c34987
<     if (local == 0 && remote == 0) {
---
>     maybe_pull_ahead(mdev);
33635,33642c34989,34991
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "IO ERROR: neither local nor remote disk\n");
< #line 971
<       spin_unlock_irq(& mdev->req_lock);
< #line 972
<       goto fail_free_complete;
<     } else {
< 
<     }
---
>     tmp___0 = drbd_should_do_remote(mdev->state);
> #line 970
>     remote = (int )tmp___0;
33646,33652c34995,35011
< #line 976
<   if ((unsigned long )b != (unsigned long )((struct drbd_tl_epoch *)0) && (unsigned long )mdev->unused_spare_tle == (unsigned long )((struct drbd_tl_epoch *)0)) {
< #line 977
<     mdev->unused_spare_tle = b;
< #line 978
<     b = 0;
<   } else {
---
> #line 972
>   tmp___1 = drbd_should_send_out_of_sync(mdev->state);
> #line 972
>   send_oos = (int )tmp___1;
> #line 973
>   rcu_read_unlock();
> #line 981
>   tmp___2 = __builtin_expect(req->i.size == 0U, 0L);
> #line 981
>   if (tmp___2 != 0L) {
> #line 983
>     if (((req->master_bio)->bi_rw & 4096UL) == 0UL) {
> #line 983
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( req->master_bio->bi_rw & REQ_FLUSH ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>               983);
>     } else {
33654,33660c35013,35015
<   }
< #line 980
<   if ((rw == 1 && (remote != 0 || send_oos != 0)) && (unsigned long )mdev->unused_spare_tle == (unsigned long )((struct drbd_tl_epoch *)0)) {
< #line 980
<     tmp___14 = drbd_test_flag(mdev, CREATE_BARRIER);
< #line 980
<     if (tmp___14 != 0) {
---
>     }
> #line 984
>     if (remote != 0) {
33662,33664c35017
<       spin_unlock_irq(& mdev->req_lock);
< #line 986
<       goto allocate_barrier;
---
>       start_new_tl_epoch(mdev->tconn);
33667a35021,35022
> #line 986
>     return (0);
33671,33701c35026,35029
< #line 991
<   _drbd_start_io_acct(mdev, req, bio);
< #line 1003
<   if ((remote != 0 || send_oos != 0) && (unsigned long )mdev->unused_spare_tle != (unsigned long )((struct drbd_tl_epoch *)0)) {
< #line 1003
<     tmp___16 = drbd_test_and_clear_flag(mdev, CREATE_BARRIER);
< #line 1003
<     if (tmp___16 != 0) {
< #line 1005
<       _tl_add_barrier(mdev, mdev->unused_spare_tle);
< #line 1006
<       mdev->unused_spare_tle = 0;
<     } else {
< #line 1003
<       goto _L;
<     }
<   } else
<   _L: /* CIL Label */ 
< #line 1008
<   if (remote != 0 && rw == 1) {
< #line 1008
<     tmp___15 = drbd_test_flag(mdev, CREATE_BARRIER);
< #line 1008
<     if (tmp___15 != 0) {
< #line 1008
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !(remote && rw == WRITE && drbd_test_flag(mdev, CREATE_BARRIER)) ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<               1009);
<     } else {
< 
<     }
---
> #line 989
>   if (remote == 0 && send_oos == 0) {
> #line 990
>     return (0);
33705,33708c35033,35038
< #line 1027
<   if (remote != 0) {
< #line 1028
<     _req_mod(req, to_be_send);
---
> #line 992
>   if (remote != 0 && send_oos != 0) {
> #line 992
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !(remote && send_oos) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             992);
33712,33715c35042,35047
< #line 1029
<   if (local != 0) {
< #line 1030
<     _req_mod(req, to_be_submitted);
---
> #line 994
>   if (remote != 0) {
> #line 995
>     _req_mod(req, TO_BE_SENT);
> #line 996
>     _req_mod(req, QUEUE_FOR_NET_WRITE);
33716a35049,35056
> #line 997
>     tmp___3 = __drbd_set_out_of_sync(mdev, req->i.sector, (int )req->i.size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>                                      997U);
> #line 997
>     if (tmp___3 != 0) {
> #line 998
>       _req_mod(req, QUEUE_FOR_SEND_OOS);
>     } else {
33717a35058
>     }
33719,33727c35060,35071
< #line 1035
<   if (rw == 1) {
< #line 1035
<     tmp___17 = _req_conflicts(req);
< #line 1035
<     if (tmp___17 != 0) {
< #line 1036
<       goto fail_conflicting;
<     } else {
---
> #line 1000
>   return (remote);
> }
> }
> #line 1004 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> static void drbd_submit_req_private_bio(struct drbd_request *req ) 
> { 
>   struct drbd_conf *mdev ;
>   struct bio *bio ;
>   int rw ;
>   int tmp ;
>   int tmp___0 ;
33728a35073,35094
>   {
> #line 1006
>   mdev = req->w.ldv_50388.mdev;
> #line 1007
>   bio = req->private_bio;
> #line 1008
>   rw = (int const   )bio->bi_rw & (int const   )8193;
> #line 1010
>   bio->bi_bdev = (mdev->ldev)->backing_bdev;
> #line 1017
>   tmp___0 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1017
>   if (tmp___0 != 0) {
> #line 1018
>     tmp = drbd_insert_fault(mdev, rw != 1 ? (rw == 0 ? 5U : 6U) : 4U);
> #line 1018
>     if (tmp != 0) {
> #line 1022
>       bio_endio(bio, -5);
>     } else {
> #line 1024
>       generic_make_request(bio);
33729a35096,35097
> #line 1025
>     put_ldev(mdev);
33731c35099,35100
< 
---
> #line 1027
>     bio_endio(bio, -5);
33732a35102,35136
> #line 1028
>   return;
> }
> }
> #line 1030 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> void __drbd_make_request(struct drbd_conf *mdev , struct bio *bio , unsigned long start_time ) 
> { 
>   int rw ;
>   struct bio_and_error m ;
>   struct drbd_request *req ;
>   bool no_remote ;
>   int tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   bool tmp___2 ;
>   int tmp___3 ;
>   int tmp___4 ;
>   long tmp___5 ;
>   int tmp___6 ;
>   int tmp___7 ;
>   int tmp___8 ;
> 
>   {
> #line 1032
>   rw = (int const   )bio->bi_rw & (int const   )8193;
> #line 1033
>   m.bio = 0;
> #line 1033
>   m.error = 0;
> #line 1035
>   no_remote = 0;
> #line 1038
>   req = drbd_req_new(mdev, bio);
> #line 1039
>   if ((unsigned long )req == (unsigned long )((struct drbd_request *)0)) {
33734,33738c35138,35144
<   tmp___18 = __builtin_expect(size != 0, 1L);
< #line 1040
<   if (tmp___18 != 0L) {
< #line 1041
<     list_add_tail(& req->tl_requests, & (mdev->newest_tle)->requests);
---
>     dec_ap_bio(mdev);
> #line 1043
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "could not kmalloc() req\n");
> #line 1044
>     bio_endio(bio, -12);
> #line 1045
>     return;
33742,33743c35148,35153
< #line 1045
<   if (remote != 0) {
---
> #line 1047
>   req->start_time = start_time;
> #line 1049
>   tmp = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1049
>   if (tmp == 0) {
33745c35155,35157
<     _req_mod(req, rw == 1 ? queue_for_net_write : queue_for_net_read);
---
>     bio_put(req->private_bio);
> #line 1051
>     req->private_bio = 0;
33749,33757c35161,35170
< #line 1054
<   if (send_oos != 0) {
< #line 1054
<     tmp___19 = __drbd_set_out_of_sync(mdev, sector, size, "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<                                       1054U);
< #line 1054
<     if (tmp___19 != 0) {
< #line 1055
<       _req_mod(req, queue_for_send_oos);
---
> #line 1061
>   if ((rw == 1 && (unsigned long )req->private_bio != (unsigned long )((struct bio *)0)) && req->i.size != 0U) {
> #line 1061
>     tmp___0 = constant_test_bit(18U, (unsigned long const volatile   *)(& mdev->flags));
> #line 1061
>     if (tmp___0 == 0) {
> #line 1063
>       req->rq_state = req->rq_state | 4096U;
> #line 1064
>       drbd_al_begin_io(mdev, & req->i);
33764,33778d35176
< #line 1057
<   if ((remote != 0 && (mdev->net_conf)->on_congestion != 0) && mdev->agreed_pro_version > 95) {
< #line 1059
<     maybe_pull_ahead(mdev);
<   } else {
< 
<   }
< #line 1064
<   tmp___20 = __builtin_expect((bio->bi_rw & 4096UL) != 0UL, 0L);
< #line 1064
<   if (tmp___20 != 0L && (mdev->newest_tle)->n_writes != 0) {
< #line 1064
<     tmp___21 = drbd_should_do_remote(mdev->state);
< #line 1064
<     if ((int )tmp___21) {
33780,33783c35178,35182
<       queue_barrier(mdev);
<     } else {
< 
<     }
---
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 1068
>   if (rw == 1) {
> #line 1072
>     complete_conflicting_writes(req);
33787,33796c35186,35191
< #line 1069
<   spin_unlock_irq(& mdev->req_lock);
< #line 1070
<   kfree((void const   *)b);
< #line 1072
<   if (local != 0) {
< #line 1073
<     (req->private_bio)->bi_bdev = (mdev->ldev)->backing_bdev;
< #line 1080
<     tmp___23 = _get_ldev_if_state(mdev, D_INCONSISTENT);
---
> #line 1077
>   tmp___1 = drbd_suspended(mdev);
> #line 1077
>   if (tmp___1 != 0) {
> #line 1079
>     req->rq_state = req->rq_state | 8192U;
33798c35193
<     if (tmp___23 != 0) {
---
>     if ((unsigned long )req->private_bio != (unsigned long )((struct bio *)0)) {
33800,33809c35195,35198
<       tmp___22 = drbd_insert_fault(mdev, rw != 1 ? (rw == 0 ? 5U : 6U) : 4U);
< #line 1081
<       if (tmp___22 != 0) {
< #line 1084
<         bio_endio(req->private_bio, -5);
<       } else {
< #line 1086
<         generic_make_request(req->private_bio);
<       }
< #line 1087
---
>       bio_put(req->private_bio);
> #line 1082
>       req->private_bio = 0;
> #line 1083
33812,33813c35201
< #line 1089
<       bio_endio(req->private_bio, -5);
---
> 
33814a35203,35204
> #line 1085
>     goto out;
33818,33832c35208,35225
< #line 1092
<   return (0);
<   fail_conflicting: 
< #line 1101
<   _drbd_end_io_acct(mdev, req);
< #line 1102
<   spin_unlock_irq(& mdev->req_lock);
< #line 1103
<   if (remote != 0) {
< #line 1104
<     tmp___24 = atomic_dec_and_test(& mdev->ap_pending_cnt);
< #line 1104
<     if (tmp___24 != 0) {
< #line 1104
<       __wake_up(& mdev->misc_wait, 3U, 1, 0);
---
> #line 1089
>   _drbd_start_io_acct(mdev, req, bio);
> #line 1094
>   if (rw != 1) {
> #line 1095
>     tmp___2 = do_remote_read(req);
> #line 1095
>     if (tmp___2) {
> #line 1095
>       tmp___3 = 0;
>     } else {
> #line 1095
>       tmp___3 = 1;
>     }
> #line 1095
>     if (tmp___3 && (unsigned long )req->private_bio == (unsigned long )((struct bio *)0)) {
> #line 1096
>       goto nodata;
33835a35229,35235
>   } else {
> 
>   }
> #line 1100
>   tmp___4 = atomic_read((atomic_t const   *)(& (mdev->tconn)->current_tle_nr));
> #line 1100
>   req->epoch = (unsigned int )tmp___4;
33837,33841c35237
<     tmp___26 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 1104
<     if (tmp___26 < 0) {
< #line 1104
<       tmp___25 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
---
>   tmp___5 = __builtin_expect(req->i.size != 0U, 1L);
33843,33844c35239,35243
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: ap_pending_cnt = %d < 0 !\n",
<               "drbd_make_request_common", 1104, tmp___25);
---
>   if (tmp___5 != 0L) {
> #line 1105
>     if (rw == 1) {
> #line 1106
>       (mdev->tconn)->current_tle_writes = (mdev->tconn)->current_tle_writes + 1U;
33847a35247,35248
> #line 1108
>     list_add_tail(& req->tl_requests, & (mdev->tconn)->transfer_log);
33851,33855d35251
< #line 1107
<   err = 0;
<   fail_free_complete: ;
< #line 1110
<   if ((req->rq_state & 4096UL) != 0UL) {
33857,33861c35253,35257
<     drbd_al_complete_io(mdev, sector);
<   } else {
< 
<   }
<   fail_and_free_req: ;
---
>   if (rw == 1) {
> #line 1112
>     tmp___6 = drbd_process_write_request(req);
> #line 1112
>     if (tmp___6 == 0) {
33863,33872c35259,35262
<   if (local != 0) {
< #line 1114
<     bio_put(req->private_bio);
< #line 1115
<     req->private_bio = 0;
< #line 1116
<     put_ldev(mdev);
<   } else {
< 
<   }
---
>       no_remote = 1;
>     } else
> #line 1117
>     if ((unsigned long )req->private_bio == (unsigned long )((struct bio *)0)) {
33874c35264
<   if (ret == 0) {
---
>       _req_mod(req, TO_BE_SENT);
33876c35266,35270
<     bio_endio(bio, err);
---
>       _req_mod(req, QUEUE_FOR_NET_READ);
>     } else {
> #line 1121
>       no_remote = 1;
>     }
33880,33910c35274,35294
< #line 1121
<   drbd_req_free(req);
< #line 1122
<   dec_ap_bio(mdev);
< #line 1123
<   kfree((void const   *)b);
< #line 1125
<   return (ret);
< }
< }
< #line 1133 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
< static int drbd_fail_request_early(struct drbd_conf *mdev , int is_write ) 
< { 
<   struct task_struct *tmp ;
<   struct task_struct *tmp___0 ;
<   int tmp___1 ;
< 
<   {
< #line 1135
<   if ((unsigned int )*((unsigned char *)mdev + 2276UL) != 1U && (! allow_oos || is_write != 0)) {
< #line 1137
<     tmp___1 = ___ratelimit(& drbd_ratelimit_state, "drbd_fail_request_early");
< #line 1137
<     if (tmp___1 != 0) {
< #line 1138
<       tmp = get_current();
< #line 1138
<       tmp___0 = get_current();
< #line 1138
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Process %s[%u] tried to %s; since we are not in Primary state, we cannot allow this\n",
<               (char *)(& tmp___0->comm), tmp->pid, is_write != 0 ? (char *)"WRITE" : (char *)"READ");
---
> #line 1124
>   if ((unsigned long )req->private_bio != (unsigned long )((struct bio *)0)) {
> #line 1126
>     _req_mod(req, TO_BE_SUBMITTED);
> #line 1128
>     spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 1129
>     drbd_submit_req_private_bio(req);
> #line 1130
>     spin_lock_irq(& (mdev->tconn)->req_lock);
>   } else
> #line 1131
>   if ((int )no_remote) {
>     nodata: 
> #line 1133
>     tmp___7 = ___ratelimit(& drbd_ratelimit_state, "__drbd_make_request");
> #line 1133
>     if (tmp___7 != 0) {
> #line 1134
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "IO ERROR: neither local nor remote data, sector %llu+%u\n",
>               (unsigned long long )req->i.sector, req->i.size >> 9);
33914,33915c35298,35316
< #line 1144
<     return (1);
---
>   } else {
> 
>   }
>   out: 
> #line 1141
>   tmp___8 = drbd_req_put_completion_ref(req, & m, 1);
> #line 1141
>   if (tmp___8 != 0) {
> #line 1142
>     kref_put(& req->kref, & drbd_req_destroy);
>   } else {
> 
>   }
> #line 1143
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 1145
>   if ((unsigned long )m.bio != (unsigned long )((struct bio *)0)) {
> #line 1146
>     complete_master_bio(mdev, & m);
33920c35321
<   return (0);
---
>   return;
33923c35324
< #line 1150 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
---
> #line 1150 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
33926,33927d35326
<   unsigned int s_enr ;
<   unsigned int e_enr ;
33930,33939d35328
<   int tmp ;
<   int tmp___0 ;
<   long tmp___1 ;
<   struct bio_pair *bp ;
<   sector_t sect ;
<   int sps ;
<   int mask ;
<   sector_t first_sectors ;
<   int tmp___2 ;
<   int tmp___3 ;
33942c35331
< #line 1153
---
> #line 1152
33944,33955c35333
< #line 1156
<   tmp = drbd_fail_request_early(mdev, (int )bio->bi_rw & 1);
< #line 1156
<   if (tmp != 0) {
< #line 1157
<     bio_endio(bio, -1);
< #line 1158
<     return;
<   } else {
< 
<   }
< #line 1161
---
> #line 1155
33957c35335
< #line 1166
---
> #line 1160
33959,33998c35337,35340
< #line 1166
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( (bio->bi_size & 0x1ff) == 0 ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<             1166);
<   } else {
< 
<   }
< #line 1170
<   s_enr = (unsigned int )(bio->bi_sector >> 8);
< #line 1171
<   e_enr = bio->bi_size != 0U ? (unsigned int )(((bio->bi_sector + (sector_t )(bio->bi_size >> 9)) - 1UL) >> 8) : s_enr;
< #line 1173
<   tmp___1 = __builtin_expect(s_enr == e_enr, 1L);
< #line 1173
<   if (tmp___1 != 0L) {
<     ldv_51578: 
< #line 1175
<     inc_ap_bio(mdev, 1);
< #line 1176
<     tmp___0 = drbd_make_request_common(mdev, bio, start_time);
< #line 1176
<     if (tmp___0 != 0) {
< #line 1177
<       goto ldv_51578;
<     } else {
< 
<     }
< 
< #line 1177
<     return;
<   } else {
< 
<   }
< #line 1182
<   if (((unsigned int )bio->bi_vcnt != 1U || (unsigned int )bio->bi_idx != 0U) || bio->bi_size > 131072U) {
< #line 1184
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "bio would need to, but cannot, be split: (vcnt=%u,idx=%u,size=%u,sector=%llu)\n",
<             (int )bio->bi_vcnt, (int )bio->bi_idx, bio->bi_size, (unsigned long long )bio->bi_sector);
< #line 1188
<     bio_endio(bio, -22);
---
> #line 1160
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( IS_ALIGNED(bio->bi_size, 512) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>             1160);
34000,34049d35341
< #line 1200
<     sect = bio->bi_sector;
< #line 1201
<     sps = 256;
< #line 1202
<     mask = sps + -1;
< #line 1203
<     first_sectors = (unsigned long )sps - ((unsigned long )mask & sect);
< #line 1204
<     bp = bio_split(bio, (int )first_sectors);
< #line 1211
<     inc_ap_bio(mdev, 3);
< #line 1213
<     if (s_enr + 1U != e_enr) {
< #line 1213
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( e_enr == s_enr + 1 ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
<               1213);
<     } else {
< 
<     }
< #line 1215
<     goto ldv_51586;
<     ldv_51585: 
< #line 1216
<     inc_ap_bio(mdev, 1);
<     ldv_51586: 
< #line 1215
<     tmp___2 = drbd_make_request_common(mdev, & bp->bio1, start_time);
< #line 1215
<     if (tmp___2 != 0) {
< #line 1216
<       goto ldv_51585;
<     } else {
< 
<     }
< 
< #line 1218
<     goto ldv_51589;
<     ldv_51588: 
< #line 1219
<     inc_ap_bio(mdev, 1);
<     ldv_51589: 
< #line 1218
<     tmp___3 = drbd_make_request_common(mdev, & bp->bio2, start_time);
< #line 1218
<     if (tmp___3 != 0) {
< #line 1219
<       goto ldv_51588;
<     } else {
34051,34055d35342
<     }
< #line 1221
<     dec_ap_bio(mdev);
< #line 1223
<     bio_pair_release(bp);
34057c35344,35348
< #line 1225
---
> #line 1162
>   inc_ap_bio(mdev);
> #line 1163
>   __drbd_make_request(mdev, bio, start_time);
> #line 1164
34061c35352
< #line 1240 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
---
> #line 1178 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
34065d35355
<   unsigned int bio_offset ;
34075c35365
< #line 1242
---
> #line 1180
34077,34079c35367
< #line 1243
<   bio_offset = (unsigned int )bvm->bi_sector << 9;
< #line 1245
---
> #line 1181
34081,34119c35369,35388
< #line 1248
<   limit = (int )(131072U - ((bio_offset & 131071U) + bio_size));
< #line 1250
<   if (limit < 0) {
< #line 1251
<     limit = 0;
<   } else {
< 
<   }
< #line 1252
<   if (bio_size == 0U) {
< #line 1253
<     if ((unsigned int )limit <= bvec->bv_len) {
< #line 1254
<       limit = (int )bvec->bv_len;
<     } else
< #line 1255
<     if (limit != 0) {
< #line 1255
<       tmp = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1255
<       if (tmp != 0) {
< #line 1256
<         b = (((mdev->ldev)->backing_bdev)->bd_disk)->queue;
< #line 1258
<         if ((unsigned long )b->merge_bvec_fn != (unsigned long )((merge_bvec_fn *)0)) {
< #line 1259
<           backing_limit = (*(b->merge_bvec_fn))(b, bvm, bvec);
< #line 1260
<           _min1 = limit;
< #line 1260
<           _min2 = backing_limit;
< #line 1260
<           limit = _min1 < _min2 ? _min1 : _min2;
<         } else {
< 
<         }
< #line 1262
<         put_ldev(mdev);
---
> #line 1182
>   limit = 1048576;
> #line 1185
>   if (bio_size != 0U) {
> #line 1185
>     tmp = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1185
>     if (tmp != 0) {
> #line 1186
>       b = (((mdev->ldev)->backing_bdev)->bd_disk)->queue;
> #line 1188
>       if ((unsigned long )b->merge_bvec_fn != (unsigned long )((merge_bvec_fn *)0)) {
> #line 1189
>         backing_limit = (*(b->merge_bvec_fn))(b, bvm, bvec);
> #line 1190
>         _min1 = limit;
> #line 1190
>         _min2 = backing_limit;
> #line 1190
>         limit = _min1 < _min2 ? _min1 : _min2;
34122a35392,35393
> #line 1192
>       put_ldev(mdev);
34129c35400
< #line 1264
---
> #line 1194
34133c35404,35446
< #line 1267 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
---
> #line 1197 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
> struct drbd_request *find_oldest_request(struct drbd_tconn *tconn ) 
> { 
>   struct drbd_request *r ;
>   struct list_head  const  *__mptr ;
>   int tmp ;
>   struct list_head  const  *__mptr___0 ;
> 
>   {
> #line 1202
>   __mptr = (struct list_head  const  *)tconn->transfer_log.next;
> #line 1202
>   r = (struct drbd_request *)__mptr + 0xffffffffffffff98UL;
> #line 1202
>   goto ldv_52142;
>   ldv_52141: 
> #line 1203
>   tmp = atomic_read((atomic_t const   *)(& r->completion_ref));
> #line 1203
>   if (tmp != 0) {
> #line 1204
>     return (r);
>   } else {
> 
>   }
> #line 1202
>   __mptr___0 = (struct list_head  const  *)r->tl_requests.next;
> #line 1202
>   r = (struct drbd_request *)__mptr___0 + 0xffffffffffffff98UL;
>   ldv_52142: ;
> #line 1202
>   if ((unsigned long )(& r->tl_requests) != (unsigned long )(& tconn->transfer_log)) {
> #line 1203
>     goto ldv_52141;
>   } else {
> 
>   }
> 
> #line 1206
>   return (0);
> }
> }
> #line 1209 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared"
34136a35450
>   struct drbd_tconn *tconn ;
34138c35452
<   struct list_head *le ;
---
>   struct net_conf *nc ;
34143a35458,35459
>   struct net_conf *_________p1 ;
>   bool __warned ;
34145a35462,35466
>   struct disk_conf *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
34150,34153c35471,35472
<   unsigned long tmp___1 ;
<   unsigned long tmp___2 ;
<   int tmp___3 ;
<   struct list_head  const  *__mptr ;
---
>   unsigned long tmp___4 ;
>   unsigned long tmp___5 ;
34157c35476
< #line 1269
---
> #line 1211
34159c35478,35480
< #line 1272
---
> #line 1212
>   tconn = mdev->tconn;
> #line 1215
34161c35482
< #line 1272
---
> #line 1215
34163,34170c35484,35500
< #line 1275
<   tmp = get_net_conf(mdev);
< #line 1275
<   if (tmp != 0) {
< #line 1276
<     if ((int )mdev->state.ldv_40583.conn > 8) {
< #line 1277
<       ent = (unsigned long )((((mdev->net_conf)->timeout * 250) / 10) * (mdev->net_conf)->ko_count);
---
> #line 1218
>   rcu_read_lock();
> #line 1219
>   _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 1219
>   tmp = debug_lockdep_rcu_enabled();
> #line 1219
>   if (tmp != 0 && ! __warned) {
> #line 1219
>     tmp___0 = rcu_read_lock_held();
> #line 1219
>     if (tmp___0 == 0 && 1) {
> #line 1219
>       __warned = 1;
> #line 1219
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>                              1219, "suspicious rcu_dereference_check() usage");
34174,34175d35503
< #line 1279
<     put_net_conf(mdev);
34179,34185c35507,35543
< #line 1281
<   tmp___0 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1281
<   if (tmp___0 != 0) {
< #line 1282
<     dt = (unsigned long )(((mdev->ldev)->dc.disk_timeout * 250) / 10);
< #line 1283
---
> #line 1219
>   nc = _________p1;
> #line 1220
>   if ((unsigned long )nc != (unsigned long )((struct net_conf *)0) && (int )mdev->state.ldv_50103.conn > 8) {
> #line 1221
>     ent = (unsigned long )(((nc->timeout * 250U) / 10U) * nc->ko_count);
>   } else {
> 
>   }
> #line 1223
>   tmp___3 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1223
>   if (tmp___3 != 0) {
> #line 1224
>     _________p1___0 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 1224
>     tmp___1 = debug_lockdep_rcu_enabled();
> #line 1224
>     if (tmp___1 != 0 && ! __warned___0) {
> #line 1224
>       tmp___2 = rcu_read_lock_held();
> #line 1224
>       if (tmp___2 == 0 && 1) {
> #line 1224
>         __warned___0 = 1;
> #line 1224
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_req.c.prepared",
>                                1224, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 1224
>     dt = (unsigned long )((_________p1___0->disk_timeout * 250U) / 10U);
> #line 1225
34190c35548,35550
< #line 1285
---
> #line 1227
>   rcu_read_unlock();
> #line 1229
34192c35552
< #line 1285
---
> #line 1229
34194c35554
< #line 1285
---
> #line 1229
34196c35556
< #line 1285
---
> #line 1229
34198c35558
< #line 1285
---
> #line 1229
34200c35560
< #line 1285
---
> #line 1229
34202,34203c35562,35563
< #line 1285
<       tmp___1 = _min1 < _min2 ? _min1 : _min2;
---
> #line 1229
>       tmp___4 = _min1 < _min2 ? _min1 : _min2;
34205,34206c35565,35566
< #line 1285
<       tmp___1 = __x;
---
> #line 1229
>       tmp___4 = __x;
34208,34209c35568,35569
< #line 1285
<     tmp___2 = tmp___1;
---
> #line 1229
>     tmp___5 = tmp___4;
34211,34212c35571,35572
< #line 1285
<     tmp___2 = __y;
---
> #line 1229
>     tmp___5 = __y;
34214,34216c35574,35576
< #line 1285
<   et = tmp___2;
< #line 1287
---
> #line 1229
>   et = tmp___5;
> #line 1231
34218c35578
< #line 1288
---
> #line 1232
34223c35583
< #line 1290
---
> #line 1234
34225,34235c35585,35593
< #line 1292
<   spin_lock_irq(& mdev->req_lock);
< #line 1293
<   le = & (mdev->oldest_tle)->requests;
< #line 1294
<   tmp___3 = list_empty((struct list_head  const  *)le);
< #line 1294
<   if (tmp___3 != 0) {
< #line 1295
<     spin_unlock_irq(& mdev->req_lock);
< #line 1296
---
> #line 1236
>   spin_lock_irq(& tconn->req_lock);
> #line 1237
>   req = find_oldest_request(tconn);
> #line 1238
>   if ((unsigned long )req == (unsigned long )((struct drbd_request *)0)) {
> #line 1239
>     spin_unlock_irq(& tconn->req_lock);
> #line 1240
34237c35595
< #line 1297
---
> #line 1241
34242,34250c35600,35602
< #line 1300
<   le = le->prev;
< #line 1301
<   __mptr = (struct list_head  const  *)le;
< #line 1301
<   req = (struct drbd_request *)__mptr + 0xffffffffffffffb8UL;
< #line 1321
<   if (((ent != 0UL && (req->rq_state & 16UL) != 0UL) && ((1 != 0 && 1 != 0) && (long )(req->start_time + ent) - (long )now < 0L)) && (((1 == 0 || 1 == 0) || (long )now - (long )mdev->last_reconnect_jif < 0L) || ((1 == 0 || 1 == 0) || (long )(mdev->last_reconnect_jif + ent) - (long )now < 0L))) {
< #line 1322
---
> #line 1262
>   if (((ent != 0UL && ((unsigned long )req->rq_state & 16UL) != 0UL) && ((1 != 0 && 1 != 0) && (long )(req->start_time + ent) - (long )now < 0L)) && (((1 == 0 || 1 == 0) || (long )now - (long )tconn->last_reconnect_jif < 0L) || ((1 == 0 || 1 == 0) || (long )(tconn->last_reconnect_jif + ent) - (long )now < 0L))) {
> #line 1263
34252,34256c35604,35608
< #line 1323
<     __ns.i = mdev->state.i;
< #line 1323
<     __ns.ldv_40583.conn = 3U;
< #line 1323
---
> #line 1264
>     __ns = drbd_read_state(mdev);
> #line 1264
>     __ns.ldv_40604.conn = 3U;
> #line 1264
34261,34263c35613,35615
< #line 1327
<   if (((dt != 0UL && (int )req->rq_state & 1) && ((1 != 0 && 1 != 0) && (long )(req->start_time + dt) - (long )now < 0L)) && (((1 == 0 || 1 == 0) || (long )now - (long )mdev->last_reattach_jif < 0L) || ((1 == 0 || 1 == 0) || (long )(mdev->last_reattach_jif + dt) - (long )now < 0L))) {
< #line 1328
---
> #line 1268
>   if ((((dt != 0UL && (int )req->rq_state & 1) && (unsigned long )req->w.ldv_50388.mdev == (unsigned long )mdev) && ((1 != 0 && 1 != 0) && (long )(req->start_time + dt) - (long )now < 0L)) && (((1 == 0 || 1 == 0) || (long )now - (long )mdev->last_reattach_jif < 0L) || ((1 == 0 || 1 == 0) || (long )(mdev->last_reattach_jif + dt) - (long )now < 0L))) {
> #line 1269
34265c35617
< #line 1329
---
> #line 1270
34270c35622
< #line 1331
---
> #line 1272
34272,34274c35624,35626
< #line 1332
<   spin_unlock_irq(& mdev->req_lock);
< #line 1333
---
> #line 1273
>   spin_unlock_irq(& tconn->req_lock);
> #line 1274
34276c35628
< #line 1334
---
> #line 1275
34341,34342c35693,35720
< #line 787 "include/linux/blkdev.h"
< __inline static struct request_queue *bdev_get_queue(struct block_device *bdev ) 
---
> #line 6 "include/linux/crc32c.h"
> extern u32 crc32c(u32  , void const   * , unsigned int  ) ;
> #line 254 "include/linux/lru_cache.h"
> extern void lc_reset(struct lru_cache * ) ;
> #line 257
> extern void lc_del(struct lru_cache * , struct lc_element * ) ;
> #line 259
> extern struct lc_element *lc_try_get(struct lru_cache * , unsigned int  ) ;
> #line 261
> extern struct lc_element *lc_get(struct lru_cache * , unsigned int  ) ;
> #line 262
> extern unsigned int lc_put(struct lru_cache * , struct lc_element * ) ;
> #line 263
> extern void lc_committed(struct lru_cache * ) ;
> #line 279 "include/linux/lru_cache.h"
> __inline static int lc_try_lock_for_transaction(struct lru_cache *lc ) 
> { 
>   int tmp ;
> 
>   {
> #line 281
>   tmp = test_and_set_bit(2, (unsigned long volatile   *)(& lc->flags));
> #line 281
>   return (tmp == 0);
> }
> }
> #line 299 "include/linux/lru_cache.h"
> __inline static void lc_unlock(struct lru_cache *lc ) 
34347,34348c35725,35730
< #line 789
<   return ((bdev->bd_disk)->queue);
---
> #line 301
>   clear_bit(1, (unsigned long volatile   *)(& lc->flags));
> #line 302
>   clear_bit_unlock(2U, (unsigned long volatile   *)(& lc->flags));
> #line 303
>   return;
34351,34352c35733,35748
< #line 1098 "include/linux/blkdev.h"
< __inline static unsigned short queue_logical_block_size(struct request_queue *q ) 
---
> #line 305
> extern bool lc_is_used(struct lru_cache * , unsigned int  ) ;
> #line 310
> extern struct lc_element *lc_element_by_index(struct lru_cache * , unsigned int  ) ;
> #line 1454 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> void *drbd_md_get_buffer(struct drbd_conf *mdev ) ;
> #line 1456
> int drbd_md_sync_page_io(struct drbd_conf *mdev , struct drbd_backing_dev *bdev ,
>                          sector_t sector , int rw ) ;
> #line 1597
> void drbd_al_shrink(struct drbd_conf *mdev ) ;
> #line 1614
> void drbd_bcast_event(struct drbd_conf *mdev , struct sib_info  const  *sib ) ;
> #line 1675 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void __drbd_chk_io_error____2(struct drbd_conf *mdev , enum drbd_force_detach_flags df ,
>                                               char const   *where ) 
34354c35750,35757
<   int retval ;
---
>   enum drbd_io_error_p ep ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   union drbd_state __ns ;
>   union drbd_state __ns___0 ;
34357,34362c35760,35779
< #line 1100
<   retval = 512;
< #line 1102
<   if ((unsigned long )q != (unsigned long )((struct request_queue *)0) && (unsigned int )q->limits.logical_block_size != 0U) {
< #line 1103
<     retval = (int )q->limits.logical_block_size;
---
> #line 1681
>   rcu_read_lock();
> #line 1682
>   _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 1682
>   tmp = debug_lockdep_rcu_enabled();
> #line 1682
>   if (tmp != 0 && ! __warned) {
> #line 1682
>     tmp___0 = rcu_read_lock_held();
> #line 1682
>     if (tmp___0 == 0 && 1) {
> #line 1682
>       __warned = 1;
> #line 1682
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h",
>                              1682, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
34366,34367c35783,35855
< #line 1105
<   return ((unsigned short )retval);
---
> #line 1682
>   ep = (enum drbd_io_error_p )_________p1->on_io_error;
> #line 1683
>   rcu_read_unlock();
> #line 1684
>   switch ((unsigned int )ep) {
>   case 0U: ;
> #line 1686
>   if ((unsigned int )df == 0U || (unsigned int )df == 1U) {
> #line 1687
>     tmp___1 = ___ratelimit(& drbd_ratelimit_state, "__drbd_chk_io_error_");
> #line 1687
>     if (tmp___1 != 0) {
> #line 1688
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Local IO failed in %s.\n",
>               where);
>     } else {
> 
>     }
> #line 1689
>     if ((int )mdev->state.ldv_50103.disk > 4) {
> #line 1690
>       __ns = drbd_read_state(mdev);
> #line 1690
>       __ns.ldv_40604.disk = 4U;
> #line 1690
>       _drbd_set_state(mdev, __ns, CS_HARD, 0);
>     } else {
> 
>     }
> #line 1691
>     goto ldv_51379;
>   } else {
> 
>   }
>   case 2U: ;
>   case 1U: 
> #line 1716
>   set_bit(12U, (unsigned long volatile   *)(& mdev->flags));
> #line 1717
>   if ((unsigned int )df == 0U) {
> #line 1718
>     set_bit(13U, (unsigned long volatile   *)(& mdev->flags));
>   } else {
> 
>   }
> #line 1719
>   if ((unsigned int )df == 3U) {
> #line 1720
>     set_bit(14U, (unsigned long volatile   *)(& mdev->flags));
>   } else {
> 
>   }
> #line 1721
>   if ((int )mdev->state.ldv_50103.disk > 2) {
> #line 1722
>     __ns___0 = drbd_read_state(mdev);
> #line 1722
>     __ns___0.ldv_40604.disk = 2U;
> #line 1722
>     _drbd_set_state(mdev, __ns___0, CS_HARD, 0);
> #line 1723
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Local IO failed in %s. Detaching...\n",
>             where);
>   } else {
> 
>   }
> #line 1726
>   goto ldv_51379;
>   }
>   ldv_51379: ;
> #line 1729
>   return;
34370,34371c35858,35860
< #line 1108 "include/linux/blkdev.h"
< __inline static unsigned short bdev_logical_block_size(struct block_device *bdev ) 
---
> #line 1739 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void drbd_chk_io_error____0(struct drbd_conf *mdev , int error , enum drbd_force_detach_flags forcedetach ,
>                                             char const   *where ) 
34373,34374c35862,35863
<   struct request_queue *tmp ;
<   unsigned short tmp___0 ;
---
>   unsigned long flags ;
>   raw_spinlock_t *tmp ;
34377,34382c35866,35880
< #line 1110
<   tmp = bdev_get_queue(bdev);
< #line 1110
<   tmp___0 = queue_logical_block_size(tmp);
< #line 1110
<   return (tmp___0);
---
> #line 1742
>   if (error != 0) {
> #line 1744
>     tmp = spinlock_check(& (mdev->tconn)->req_lock);
> #line 1744
>     flags = _raw_spin_lock_irqsave(tmp);
> #line 1745
>     __drbd_chk_io_error____2(mdev, forcedetach, where);
> #line 1746
>     spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
>   } else {
> 
>   }
> #line 1748
>   return;
34385,34400c35883,35884
< #line 243 "include/linux/lru_cache.h"
< extern void lc_reset(struct lru_cache * ) ;
< #line 245
< extern void lc_set(struct lru_cache * , unsigned int  , int  ) ;
< #line 246
< extern void lc_del(struct lru_cache * , struct lc_element * ) ;
< #line 248
< extern struct lc_element *lc_try_get(struct lru_cache * , unsigned int  ) ;
< #line 250
< extern struct lc_element *lc_get(struct lru_cache * , unsigned int  ) ;
< #line 251
< extern unsigned int lc_put(struct lru_cache * , struct lc_element * ) ;
< #line 252
< extern void lc_changed(struct lru_cache * , struct lc_element * ) ;
< #line 267 "include/linux/lru_cache.h"
< __inline static int lc_try_lock(struct lru_cache *lc ) 
---
> #line 1770 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static sector_t drbd_md_first_sector(struct drbd_backing_dev *bdev ) 
34401a35886,35888
>   int meta_dev_idx ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
34402a35890,35891
>   int tmp___0 ;
>   sector_t tmp___1 ;
34405,34413c35894,35911
< #line 269
<   tmp = test_and_set_bit(1, (unsigned long volatile   *)(& lc->flags));
< #line 269
<   return (tmp == 0);
< }
< }
< #line 276 "include/linux/lru_cache.h"
< __inline static void lc_unlock(struct lru_cache *lc ) 
< { 
---
> #line 1774
>   rcu_read_lock();
> #line 1775
>   _________p1 = *((struct disk_conf * volatile  *)(& bdev->disk_conf));
> #line 1775
>   tmp = debug_lockdep_rcu_enabled();
> #line 1775
>   if (tmp != 0 && ! __warned) {
> #line 1775
>     tmp___0 = rcu_read_lock_held();
> #line 1775
>     if (tmp___0 == 0 && 1) {
> #line 1775
>       __warned = 1;
> #line 1775
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h",
>                              1775, "suspicious rcu_dereference_check() usage");
>     } else {
34414a35913,35914
>     }
>   } else {
34416,34422c35916,35924
<   {
< #line 278
<   clear_bit(1, (unsigned long volatile   *)(& lc->flags));
< #line 279
<   __asm__  volatile   ("": : : "memory");
< #line 280
<   return;
---
>   }
> #line 1775
>   meta_dev_idx = _________p1->meta_dev_idx;
> #line 1776
>   rcu_read_unlock();
> #line 1778
>   tmp___1 = _drbd_md_first_sector(meta_dev_idx, bdev);
> #line 1778
>   return (tmp___1);
34425,34426c35927,35928
< #line 282 "include/linux/lru_cache.h"
< __inline static int lc_is_used(struct lru_cache *lc , unsigned int enr ) 
---
> #line 1887 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void drbd_queue_work_front(struct drbd_work_queue *q , struct drbd_work *w ) 
34428,34429c35930,35931
<   struct lc_element *e ;
<   struct lc_element *tmp ;
---
>   unsigned long flags ;
>   raw_spinlock_t *tmp ;
34432,34437c35934,35945
< #line 284
<   tmp = lc_find(lc, enr);
< #line 284
<   e = tmp;
< #line 285
<   return ((unsigned long )e != (unsigned long )((struct lc_element *)0) && e->refcnt != 0U);
---
> #line 1890
>   tmp = spinlock_check(& q->q_lock);
> #line 1890
>   flags = _raw_spin_lock_irqsave(tmp);
> #line 1891
>   list_add(& w->list, & q->q);
> #line 1892
>   spin_unlock_irqrestore(& q->q_lock, flags);
> #line 1893
>   __wake_up(& q->q_wait, 3U, 1, 0);
> #line 1894
>   return;
34440,34459c35948,35950
< #line 291
< extern struct lc_element *lc_element_by_index(struct lru_cache * , unsigned int  ) ;
< #line 292
< extern unsigned int lc_index_of(struct lru_cache * , struct lc_element * ) ;
< #line 1608 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< void *drbd_md_get_buffer(struct drbd_conf *mdev ) ;
< #line 1610
< int drbd_md_sync_page_io(struct drbd_conf *mdev , struct drbd_backing_dev *bdev ,
<                          sector_t sector , int rw ) ;
< #line 1737
< int drbd_al_read_log(struct drbd_conf *mdev , struct drbd_backing_dev *bdev ) ;
< #line 1747
< void drbd_al_apply_to_bm(struct drbd_conf *mdev ) ;
< #line 1748
< void drbd_al_shrink(struct drbd_conf *mdev ) ;
< #line 1756
< void drbd_bcast_sync_progress(struct drbd_conf *mdev ) ;
< #line 73 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
< int w_al_write_transaction(struct drbd_conf *mdev , struct drbd_work *w , int unused ) ;
< #line 75 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 115 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
> static int al_write_transaction(struct drbd_conf *mdev ) ;
> #line 117 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
34469c35960
< #line 79
---
> #line 121
34471,34474c35962,35965
< #line 79
<   if (r == 0 || (int )mdev->state.ldv_40583.disk <= 2) {
< #line 79
<     goto ldv_51159;
---
> #line 121
>   if (r == 0 || (int )mdev->state.ldv_50103.disk <= 2) {
> #line 121
>     goto ldv_51720;
34478c35969
< #line 79
---
> #line 121
34480c35971
< #line 79
---
> #line 121
34482c35973
< #line 79
---
> #line 121
34484c35975
< #line 79
---
> #line 121
34486c35977
< #line 79
---
> #line 121
34488c35979
< #line 79
---
> #line 121
34490,34491c35981,35982
<   ldv_51162: 
< #line 79
---
>   ldv_51723: 
> #line 121
34493c35984
< #line 79
---
> #line 121
34495,34498c35986,35989
< #line 79
<   if (r == 0 || (int )mdev->state.ldv_40583.disk <= 2) {
< #line 79
<     goto ldv_51161;
---
> #line 121
>   if (r == 0 || (int )mdev->state.ldv_50103.disk <= 2) {
> #line 121
>     goto ldv_51722;
34502c35993
< #line 79
---
> #line 121
34504,34507c35995,35998
< #line 79
<   goto ldv_51162;
<   ldv_51161: 
< #line 79
---
> #line 121
>   goto ldv_51723;
>   ldv_51722: 
> #line 121
34509,34510c36000,36001
<   ldv_51159: ;
< #line 83
---
>   ldv_51720: ;
> #line 125
34512c36003
< #line 83
---
> #line 125
34514c36005
< #line 83
---
> #line 125
34517c36008
< #line 83
---
> #line 125
34520c36011
< #line 83
---
> #line 125
34524c36015
< #line 86 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 128 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
34530c36021
< #line 88
---
> #line 130
34532c36023
< #line 88
---
> #line 130
34534c36025
< #line 89
---
> #line 131
34539c36030
< #line 90
---
> #line 132
34543c36034
< #line 92 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 134 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
34547a36039,36042
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
34550,34552c36045,36047
<   struct task_struct *tmp ;
<   int tmp___0 ;
<   int tmp___1 ;
---
>   struct task_struct *tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
34555,34557c36050,36079
< #line 95
<   dt = (long )((bdev->dc.disk_timeout * 250) / 10);
< #line 96
---
> #line 139
>   rcu_read_lock();
> #line 140
>   _________p1 = *((struct disk_conf * volatile  *)(& bdev->disk_conf));
> #line 140
>   tmp = debug_lockdep_rcu_enabled();
> #line 140
>   if (tmp != 0 && ! __warned) {
> #line 140
>     tmp___0 = rcu_read_lock_held();
> #line 140
>     if (tmp___0 == 0 && 1) {
> #line 140
>       __warned = 1;
> #line 140
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>                              140, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 140
>   dt = (long )_________p1->disk_timeout;
> #line 141
>   rcu_read_unlock();
> #line 142
>   dt = (dt * 250L) / 10L;
> #line 143
34559c36081
< #line 97
---
> #line 144
34564c36086
< #line 99
---
> #line 146
34566c36088
< #line 99
---
> #line 146
34568,34574c36090,36096
< #line 99
<     tmp___1 = drbd_test_flag(mdev, FORCE_DETACH);
< #line 99
<     if (tmp___1 == 0) {
< #line 99
<       tmp = get_current();
< #line 99
---
> #line 146
>     tmp___3 = constant_test_bit(14U, (unsigned long const volatile   *)(& mdev->flags));
> #line 146
>     if (tmp___3 == 0) {
> #line 146
>       tmp___1 = get_current();
> #line 146
34576,34578c36098,36100
< #line 99
<       __wait.private = (void *)tmp;
< #line 99
---
> #line 146
>       __wait.private = (void *)tmp___1;
> #line 146
34580c36102
< #line 99
---
> #line 146
34582c36104
< #line 99
---
> #line 146
34584,34585c36106,36107
<       ldv_51175: 
< #line 99
---
>       ldv_51739: 
> #line 146
34587c36109
< #line 99
---
> #line 146
34589,34590c36111,36112
< #line 99
<         goto ldv_51174;
---
> #line 146
>         goto ldv_51738;
34592,34597c36114,36119
< #line 99
<         tmp___0 = drbd_test_flag(mdev, FORCE_DETACH);
< #line 99
<         if (tmp___0 != 0) {
< #line 99
<           goto ldv_51174;
---
> #line 146
>         tmp___2 = constant_test_bit(14U, (unsigned long const volatile   *)(& mdev->flags));
> #line 146
>         if (tmp___2 != 0) {
> #line 146
>           goto ldv_51738;
34602c36124
< #line 99
---
> #line 146
34604c36126
< #line 99
---
> #line 146
34606,34607c36128,36129
< #line 99
<         goto ldv_51174;
---
> #line 146
>         goto ldv_51738;
34611,34614c36133,36136
< #line 99
<       goto ldv_51175;
<       ldv_51174: 
< #line 99
---
> #line 146
>       goto ldv_51739;
>       ldv_51738: 
> #line 146
34622c36144
< #line 99
---
> #line 146
34624c36146
< #line 101
---
> #line 148
34626c36148
< #line 102
---
> #line 149
34628,34629c36150,36151
< #line 103
<     drbd_chk_io_error_(mdev, 1, DRBD_FORCE_DETACH, "wait_until_done_or_force_detached");
---
> #line 150
>     drbd_chk_io_error____0(mdev, 1, DRBD_FORCE_DETACH, "wait_until_done_or_force_detached");
34633c36155
< #line 105
---
> #line 152
34637c36159
< #line 107 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 154 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
34642c36164
<   int ok ;
---
>   int err ;
34649c36171
< #line 115
---
> #line 162
34651c36173
< #line 116
---
> #line 163
34653c36175
< #line 118
---
> #line 165
34655,34657c36177,36179
< #line 118
<     tmp = drbd_test_flag(mdev, MD_NO_FUA);
< #line 118
---
> #line 165
>     tmp = constant_test_bit(7U, (unsigned long const volatile   *)(& mdev->flags));
> #line 165
34659c36181
< #line 119
---
> #line 166
34667c36189
< #line 120
---
> #line 167
34669c36191
< #line 122
---
> #line 169
34671c36193
< #line 123
---
> #line 170
34673c36195
< #line 124
---
> #line 171
34675c36197,36199
< #line 125
---
> #line 172
>   err = -5;
> #line 173
34677,34681c36201,36203
< #line 125
<   ok = tmp___0 == size;
< #line 126
<   if (ok == 0) {
< #line 127
---
> #line 173
>   if (tmp___0 != size) {
> #line 174
34686c36208
< #line 128
---
> #line 175
34688c36210
< #line 129
---
> #line 176
34690c36212
< #line 130
---
> #line 177
34692c36214
< #line 132
---
> #line 179
34694c36216
< #line 132
---
> #line 179
34696c36218
< #line 133
---
> #line 180
34698,34700c36220,36222
< #line 134
<     ok = 0;
< #line 135
---
> #line 181
>     err = -19;
> #line 182
34705c36227
< #line 138
---
> #line 185
34707c36229
< #line 139
---
> #line 186
34709c36231
< #line 140
---
> #line 187
34711c36233
< #line 140
---
> #line 187
34713c36235
< #line 141
---
> #line 188
34716c36238
< #line 143
---
> #line 190
34719c36241
< #line 144
---
> #line 191
34721,34722c36243,36249
< #line 145
<   ok = (int )bio->bi_flags & 1 && mdev->md_io.error == 0;
---
> #line 192
>   if ((int )bio->bi_flags & 1) {
> #line 193
>     err = mdev->md_io.error;
>   } else {
> 
>   }
34724c36251
< #line 148
---
> #line 196
34726,34727c36253,36254
< #line 149
<   return (ok);
---
> #line 197
>   return (err);
34730c36257
< #line 152 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 200 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
34734,34737c36261
<   int logical_block_size ;
<   int mask ;
<   int ok ;
<   int offset ;
---
>   int err ;
34741,34748c36265,36269
<   unsigned short tmp___1 ;
<   void *p ;
<   void *tmp___2 ;
<   void *hp ;
<   void *tmp___3 ;
<   long tmp___4 ;
<   size_t __len ;
<   void *__ret ;
---
>   struct _ddebug descriptor ;
>   struct task_struct *tmp___1 ;
>   struct task_struct *tmp___2 ;
>   long tmp___3 ;
>   struct task_struct *tmp___4 ;
34750c36271
<   struct task_struct *tmp___6 ;
---
>   sector_t tmp___6 ;
34752,34759d36272
<   sector_t tmp___8 ;
<   long tmp___9 ;
<   void *p___0 ;
<   void *tmp___10 ;
<   void *hp___0 ;
<   void *tmp___11 ;
<   size_t __len___0 ;
<   void *__ret___0 ;
34762,34764c36275
< #line 156
<   offset = 0;
< #line 157
---
> #line 204
34766c36277
< #line 159
---
> #line 206
34768c36279
< #line 159
---
> #line 206
34770c36281
< #line 159
---
> #line 206
34772,34773c36283,36284
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             159);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>             206);
34777c36288
< #line 161
---
> #line 208
34780c36291
< #line 161
---
> #line 208
34782,34798c36293,36298
< #line 161
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"),
<                          "i" (161), "i" (12UL));
<     ldv_51200: ;
< #line 161
<     goto ldv_51200;
<   } else {
< 
<   }
< #line 163
<   tmp___1 = bdev_logical_block_size(bdev->md_bdev);
< #line 163
<   logical_block_size = (int )tmp___1;
< #line 164
<   if (logical_block_size == 0) {
< #line 165
<     logical_block_size = 512;
---
> #line 208
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"),
>                          "i" (208), "i" (12UL));
>     ldv_51761: ;
> #line 208
>     goto ldv_51761;
34802,34867c36302,36326
< #line 168
<   if (logical_block_size != 512) {
< #line 169
<     mask = logical_block_size / 512 + -1;
< #line 170
<     if ((mask != 1 && mask != 3) && mask != 7) {
< #line 170
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mask == 1 || mask == 3 || mask == 7 ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<               170);
<     } else {
< 
<     }
< #line 171
<     if ((mask + 1) * 512 != logical_block_size) {
< #line 171
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( logical_block_size == (mask+1) * MD_SECTOR_SIZE ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<               171);
<     } else {
< 
<     }
< #line 172
<     offset = (int )((unsigned int )sector & (unsigned int )mask);
< #line 173
<     sector = (sector_t )(~ mask) & sector;
< #line 174
<     iop = mdev->md_io_tmpp;
< #line 176
<     if (rw & 1) {
< #line 179
<       tmp___2 = lowmem_page_address((struct page  const  *)mdev->md_io_page);
< #line 179
<       p = tmp___2;
< #line 180
<       tmp___3 = lowmem_page_address((struct page  const  *)mdev->md_io_tmpp);
< #line 180
<       hp = tmp___3;
< #line 182
<       ok = _drbd_md_sync_page_io(mdev, bdev, iop, sector, 0, logical_block_size);
< #line 185
<       tmp___4 = __builtin_expect(ok == 0, 0L);
< #line 185
<       if (tmp___4 != 0L) {
< #line 186
<         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "drbd_md_sync_page_io(,%llus,READ [logical_block_size!=512]) failed!\n",
<                 (unsigned long long )sector);
< #line 189
<         return (0);
<       } else {
< 
<       }
< #line 192
<       __len = 512UL;
< #line 192
<       if (__len > 63UL) {
< #line 192
<         __ret = __memcpy(hp + (unsigned long )(offset * 512), (void const   *)p, __len);
<       } else {
< #line 192
<         __ret = __builtin_memcpy(hp + (unsigned long )(offset * 512), (void const   *)p,
<                                  __len);
<       }
<     } else {
< 
<     }
---
> #line 210
>   descriptor.modname = "drbd";
> #line 210
>   descriptor.function = "drbd_md_sync_page_io";
> #line 210
>   descriptor.filename = "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared";
> #line 210
>   descriptor.format = "meta_data io: %s [%d]:%s(,%llus,%s)\n";
> #line 210
>   descriptor.lineno = 212U;
> #line 210
>   descriptor.flags = 0U;
> #line 210
>   tmp___3 = __builtin_expect((long )descriptor.flags & 1L, 0L);
> #line 210
>   if (tmp___3 != 0L) {
> #line 210
>     tmp___1 = get_current();
> #line 210
>     tmp___2 = get_current();
> #line 210
>     __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (mdev->vdisk)->part0.__dev),
>                       "meta_data io: %s [%d]:%s(,%llus,%s)\n", (char *)(& tmp___2->comm),
>                       tmp___1->pid, "drbd_md_sync_page_io", (unsigned long long )sector,
>                       rw & 1 ? (char *)"WRITE" : (char *)"READ");
34871,34875c36330,36336
< #line 196
<   tmp___7 = drbd_md_first_sector(bdev);
< #line 196
<   if (tmp___7 > sector) {
< #line 198
---
> #line 214
>   tmp___6 = drbd_md_first_sector(bdev);
> #line 214
>   if (tmp___6 > sector) {
> #line 216
>     tmp___4 = get_current();
> #line 216
34877,34879c36338
< #line 198
<     tmp___6 = get_current();
< #line 198
---
> #line 216
34881c36340
<               (char *)(& tmp___6->comm), tmp___5->pid, "drbd_md_sync_page_io", (unsigned long long )sector,
---
>               (char *)(& tmp___5->comm), tmp___4->pid, "drbd_md_sync_page_io", (unsigned long long )sector,
34884,34888c36343,36349
< #line 196
<     tmp___8 = drbd_md_last_sector(bdev);
< #line 196
<     if (tmp___8 < sector) {
< #line 198
---
> #line 214
>     tmp___7 = drbd_md_last_sector(bdev);
> #line 214
>     if (sector + 7UL > tmp___7) {
> #line 216
>       tmp___4 = get_current();
> #line 216
34890,34892c36351
< #line 198
<       tmp___6 = get_current();
< #line 198
---
> #line 216
34894c36353
<                 (char *)(& tmp___6->comm), tmp___5->pid, "drbd_md_sync_page_io", (unsigned long long )sector,
---
>                 (char *)(& tmp___5->comm), tmp___4->pid, "drbd_md_sync_page_io", (unsigned long long )sector,
34900,34935c36359,36366
< #line 202
<   ok = _drbd_md_sync_page_io(mdev, bdev, iop, sector, rw, logical_block_size);
< #line 203
<   tmp___9 = __builtin_expect(ok == 0, 0L);
< #line 203
<   if (tmp___9 != 0L) {
< #line 204
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "drbd_md_sync_page_io(,%llus,%s) failed!\n",
<             (unsigned long long )sector, rw & 1 ? (char *)"WRITE" : (char *)"READ");
< #line 206
<     return (0);
<   } else {
< 
<   }
< #line 209
<   if (logical_block_size != 512 && (rw & 1) == 0) {
< #line 210
<     tmp___10 = lowmem_page_address((struct page  const  *)mdev->md_io_page);
< #line 210
<     p___0 = tmp___10;
< #line 211
<     tmp___11 = lowmem_page_address((struct page  const  *)mdev->md_io_tmpp);
< #line 211
<     hp___0 = tmp___11;
< #line 213
<     __len___0 = 512UL;
< #line 213
<     if (__len___0 > 63UL) {
< #line 213
<       __ret___0 = __memcpy(p___0, (void const   *)hp___0 + (unsigned long )(offset * 512),
<                            __len___0);
<     } else {
< #line 213
<       __ret___0 = __builtin_memcpy(p___0, (void const   *)hp___0 + (unsigned long )(offset * 512),
<                                    __len___0);
<     }
---
> #line 220
>   err = _drbd_md_sync_page_io(mdev, bdev, iop, sector, rw, 4096);
> #line 221
>   if (err != 0) {
> #line 222
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "drbd_md_sync_page_io(,%llus,%s) failed with error %d\n",
>             (unsigned long long )sector, rw & 1 ? (char *)"WRITE" : (char *)"READ",
>             err);
34939,34940c36370,36371
< #line 216
<   return (ok);
---
> #line 225
>   return (err);
34943c36374
< #line 219 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 228 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
34948d36378
<   unsigned long al_flags ;
34957,34959c36387
< #line 223
<   al_flags = 0UL;
< #line 226
---
> #line 234
34961c36389
< #line 227
---
> #line 235
34963c36391
< #line 228
---
> #line 236
34966c36394
< #line 228
---
> #line 236
34968c36396
< #line 229
---
> #line 237
34970c36398
< #line 229
---
> #line 237
34972c36400
< #line 230
---
> #line 238
34974c36402
< #line 230
---
> #line 238
34976c36404
< #line 231
---
> #line 239
34978c36406
< #line 231
---
> #line 239
34980c36408
< #line 232
---
> #line 240
34982c36410
< #line 233
---
> #line 241
34984c36412
< #line 234
---
> #line 242
34989c36417
< #line 235
---
> #line 243
34997c36425
< #line 238
---
> #line 246
34999,35001c36427
< #line 239
<   al_flags = (mdev->act_log)->flags;
< #line 240
---
> #line 247
35003c36429
< #line 251
---
> #line 248
35007,35008c36433,36434
< #line 254 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
< void drbd_al_begin_io(struct drbd_conf *mdev , sector_t sector ) 
---
> #line 251 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
> void drbd_al_begin_io(struct drbd_conf *mdev , struct drbd_interval *i ) 
35009a36436,36437
>   unsigned int first ;
>   unsigned int last ;
35011,35012c36439
<   struct lc_element *al_ext ;
<   struct update_al_work al_work ;
---
>   bool locked ;
35013a36441
>   struct lc_element *tmp___0 ;
35015c36443,36453
<   struct task_struct *tmp___0 ;
---
>   struct task_struct *tmp___1 ;
>   struct lc_element *tmp___2 ;
>   int tmp___3 ;
>   wait_queue_t __wait___0 ;
>   struct task_struct *tmp___4 ;
>   int tmp___5 ;
>   bool write_al_updates ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___6 ;
>   int tmp___7 ;
35017a36456,36457
> #line 255
>   first = (unsigned int )(i->sector >> 13);
35019,35027c36459,36467
<   enr = (unsigned int )(sector >> 13);
< #line 260
<   tmp = atomic_read((atomic_t const   *)(& mdev->local_cnt));
< #line 260
<   if (tmp <= 0) {
< #line 260
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( atomic_read(&mdev->local_cnt) > 0 ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             260);
---
>   last = i->size != 0U ? (unsigned int )(((i->sector + (sector_t )(i->size >> 9)) - 1UL) >> 13) : first;
> #line 258
>   locked = 0;
> #line 261
>   if (first > last) {
> #line 261
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( first <= last ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>             261);
35032c36472
<   al_ext = _al_get(mdev, enr);
---
>   tmp = atomic_read((atomic_t const   *)(& mdev->local_cnt));
35034c36474
<   if ((unsigned long )al_ext != (unsigned long )((struct lc_element *)0)) {
---
>   if (tmp <= 0) {
35036c36476,36478
<     goto ldv_51230;
---
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( atomic_read(&mdev->local_cnt) > 0 ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>             262);
35040,35042c36482,36498
< #line 262
<   tmp___0 = get_current();
< #line 262
---
> #line 264
>   enr = first;
> #line 264
>   goto ldv_51787;
>   ldv_51786: 
> #line 265
>   tmp___0 = _al_get(mdev, enr);
> #line 265
>   if ((unsigned long )tmp___0 != (unsigned long )((struct lc_element *)0)) {
> #line 265
>     goto ldv_51782;
>   } else {
> 
>   }
> #line 265
>   tmp___1 = get_current();
> #line 265
35044,35046c36500,36502
< #line 262
<   __wait.private = (void *)tmp___0;
< #line 262
---
> #line 265
>   __wait.private = (void *)tmp___1;
> #line 265
35048c36504
< #line 262
---
> #line 265
35050c36506
< #line 262
---
> #line 265
35052,35053c36508,36509
<   ldv_51233: 
< #line 262
---
>   ldv_51785: 
> #line 265
35055,35060c36511,36516
< #line 262
<   al_ext = _al_get(mdev, enr);
< #line 262
<   if ((unsigned long )al_ext != (unsigned long )((struct lc_element *)0)) {
< #line 262
<     goto ldv_51232;
---
> #line 265
>   tmp___2 = _al_get(mdev, enr);
> #line 265
>   if ((unsigned long )tmp___2 != (unsigned long )((struct lc_element *)0)) {
> #line 265
>     goto ldv_51784;
35064c36520
< #line 262
---
> #line 265
35066,35069c36522,36525
< #line 262
<   goto ldv_51233;
<   ldv_51232: 
< #line 262
---
> #line 265
>   goto ldv_51785;
>   ldv_51784: 
> #line 265
35071c36527
<   ldv_51230: ;
---
>   ldv_51782: 
35073,35079c36529,36595
<   if (al_ext->lc_number != enr) {
< #line 271
<     init_completion(& al_work.event);
< #line 272
<     al_work.al_ext = al_ext;
< #line 273
<     al_work.enr = enr;
---
>   enr = enr + 1U;
>   ldv_51787: ;
> #line 264
>   if (enr <= last) {
> #line 265
>     goto ldv_51786;
>   } else {
> 
>   }
> 
> #line 270
>   if ((mdev->act_log)->pending_changes == 0U) {
> #line 270
>     goto ldv_51789;
>   } else {
> #line 270
>     tmp___3 = lc_try_lock_for_transaction(mdev->act_log);
> #line 270
>     locked = tmp___3 != 0;
> #line 270
>     if ((int )locked) {
> #line 270
>       goto ldv_51789;
>     } else {
> 
>     }
>   }
> #line 270
>   tmp___4 = get_current();
> #line 270
>   __wait___0.flags = 0U;
> #line 270
>   __wait___0.private = (void *)tmp___4;
> #line 270
>   __wait___0.func = & autoremove_wake_function;
> #line 270
>   __wait___0.task_list.next = & __wait___0.task_list;
> #line 270
>   __wait___0.task_list.prev = & __wait___0.task_list;
>   ldv_51792: 
> #line 270
>   prepare_to_wait(& mdev->al_wait, & __wait___0, 2);
> #line 270
>   if ((mdev->act_log)->pending_changes == 0U) {
> #line 270
>     goto ldv_51791;
>   } else {
> #line 270
>     tmp___5 = lc_try_lock_for_transaction(mdev->act_log);
> #line 270
>     locked = tmp___5 != 0;
> #line 270
>     if ((int )locked) {
> #line 270
>       goto ldv_51791;
>     } else {
> 
>     }
>   }
> #line 270
>   schedule();
> #line 270
>   goto ldv_51792;
>   ldv_51791: 
> #line 270
>   finish_wait(& mdev->al_wait, & __wait___0);
>   ldv_51789: ;
35081,35095c36597
<     al_work.old_enr = al_ext->lc_number;
< #line 275
<     al_work.w.cb = & w_al_write_transaction;
< #line 276
<     drbd_queue_work_front(& mdev->data.work, & al_work.w);
< #line 277
<     wait_for_completion(& al_work.event);
< #line 279
<     mdev->al_writ_cnt = mdev->al_writ_cnt + 1U;
< #line 281
<     spin_lock_irq(& mdev->al_lock);
< #line 282
<     lc_changed(mdev->act_log, al_ext);
< #line 283
<     spin_unlock_irq(& mdev->al_lock);
---
>   if ((int )locked) {
35096a36599,36647
>     if ((mdev->act_log)->pending_changes != 0U) {
> #line 287
>       rcu_read_lock();
> #line 288
>       _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 288
>       tmp___6 = debug_lockdep_rcu_enabled();
> #line 288
>       if (tmp___6 != 0 && ! __warned) {
> #line 288
>         tmp___7 = rcu_read_lock_held();
> #line 288
>         if (tmp___7 == 0 && 1) {
> #line 288
>           __warned = 1;
> #line 288
>           lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>                                  288, "suspicious rcu_dereference_check() usage");
>         } else {
> 
>         }
>       } else {
> 
>       }
> #line 288
>       write_al_updates = (int )((signed char )_________p1->al_updates) != 0;
> #line 289
>       rcu_read_unlock();
> #line 291
>       if ((int )write_al_updates) {
> #line 292
>         al_write_transaction(mdev);
> #line 293
>         mdev->al_writ_cnt = mdev->al_writ_cnt + 1U;
>       } else {
> 
>       }
> #line 296
>       spin_lock_irq(& mdev->al_lock);
> #line 301
>       lc_committed(mdev->act_log);
> #line 302
>       spin_unlock_irq(& mdev->al_lock);
>     } else {
> 
>     }
> #line 304
>     lc_unlock(mdev->act_log);
> #line 305
35101c36652
< #line 286
---
> #line 307
35105,35106c36656,36657
< #line 288 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
< void drbd_al_complete_io(struct drbd_conf *mdev , sector_t sector ) 
---
> #line 309 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
> void drbd_al_complete_io(struct drbd_conf *mdev , struct drbd_interval *i ) 
35107a36659,36660
>   unsigned int first ;
>   unsigned int last ;
35112d36664
<   unsigned int tmp___0 ;
35115,35117c36667,36680
< #line 290
<   enr = (unsigned int )(sector >> 13);
< #line 294
---
> #line 313
>   first = (unsigned int )(i->sector >> 13);
> #line 314
>   last = i->size != 0U ? (unsigned int )(((i->sector + (sector_t )(i->size >> 9)) - 1UL) >> 13) : first;
> #line 319
>   if (first > last) {
> #line 319
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( first <= last ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>             319);
>   } else {
> 
>   }
> #line 320
35119c36682
< #line 294
---
> #line 320
35121c36684,36689
< #line 296
---
> #line 322
>   enr = first;
> #line 322
>   goto ldv_51811;
>   ldv_51810: 
> #line 323
35123c36691
< #line 298
---
> #line 324
35125,35127c36693
< #line 299
<     spin_unlock_irqrestore(& mdev->al_lock, flags);
< #line 300
---
> #line 325
35130,35131c36696,36697
< #line 301
<     return;
---
> #line 326
>     goto ldv_51809;
35135,35140c36701,36710
< #line 304
<   tmp___0 = lc_put(mdev->act_log, extent);
< #line 304
<   if (tmp___0 == 0U) {
< #line 305
<     __wake_up(& mdev->al_wait, 3U, 1, 0);
---
> #line 328
>   lc_put(mdev->act_log, extent);
>   ldv_51809: 
> #line 322
>   enr = enr + 1U;
>   ldv_51811: ;
> #line 322
>   if (enr <= last) {
> #line 323
>     goto ldv_51810;
35144c36714
< #line 307
---
> #line 330
35146c36716,36718
< #line 308
---
> #line 331
>   __wake_up(& mdev->al_wait, 3U, 1, 0);
> #line 332
35150c36722
< #line 319 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 343 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
35156c36728
< #line 321
---
> #line 345
35160c36732
< #line 328 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 352 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
35166c36738
< #line 330
---
> #line 354
35170,35171c36742,36743
< #line 338 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
< int w_al_write_transaction(struct drbd_conf *mdev , struct drbd_work *w , int unused ) 
---
> #line 362 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
> static int _al_write_transaction(struct drbd_conf *mdev ) 
35173,35178c36745,36746
<   struct update_al_work *aw ;
<   struct drbd_work  const  *__mptr ;
<   struct lc_element *updated ;
<   unsigned int new_enr ;
<   unsigned int evicted ;
<   struct al_transaction *buffer ;
---
>   struct al_transaction_on_disk *buffer ;
>   struct lc_element *e ;
35181d36748
<   int n ;
35184c36751,36752
<   u32 xor_sum ;
---
>   unsigned int crc ;
>   int err ;
35187,35193c36755,36766
<   unsigned int tmp___1 ;
<   char const   *tmp___2 ;
<   void *tmp___3 ;
<   __u32 tmp___4 ;
<   unsigned int tmp___5 ;
<   __u32 tmp___6 ;
<   __u32 tmp___7 ;
---
>   char const   *tmp___1 ;
>   void *tmp___2 ;
>   __u32 tmp___3 ;
>   struct list_head  const  *__mptr ;
>   __u16 tmp___4 ;
>   __u32 tmp___5 ;
>   unsigned int tmp___6 ;
>   struct list_head  const  *__mptr___0 ;
>   long tmp___7 ;
>   __u16 tmp___8 ;
>   __u16 tmp___9 ;
>   __u16 tmp___10 ;
35197,35201c36770,36774
<   struct lc_element *tmp___8 ;
<   __u32 tmp___9 ;
<   __u32 tmp___10 ;
<   __u32 tmp___11 ;
<   int tmp___12 ;
---
>   struct lc_element *tmp___11 ;
>   __u32 tmp___12 ;
>   __u32 tmp___13 ;
>   int tmp___14 ;
>   int tmp___15 ;
35204,35216c36777,36781
< #line 340
<   __mptr = (struct drbd_work  const  *)w;
< #line 340
<   aw = (struct update_al_work *)__mptr;
< #line 341
<   updated = aw->al_ext;
< #line 342
<   new_enr = aw->enr;
< #line 343
<   evicted = aw->old_enr;
< #line 348
<   xor_sum = 0U;
< #line 350
---
> #line 369
>   crc = 0U;
> #line 370
>   err = 0;
> #line 372
35218,35249d36782
< #line 350
<   if (tmp___0 == 0) {
< #line 351
<     tmp = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_40583.disk);
< #line 351
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "disk is %s, cannot start al transaction (-%d +%d)\n",
<             tmp, evicted, new_enr);
< #line 354
<     complete(& ((struct update_al_work *)w)->event);
< #line 355
<     return (1);
<   } else {
< 
<   }
< #line 363
<   if ((int )mdev->state.ldv_40583.conn <= 9 && evicted != 4294967295U) {
< #line 364
<     tmp___1 = al_extent_to_bm_page(evicted);
< #line 364
<     drbd_bm_write_page(mdev, tmp___1);
<   } else {
< 
<   }
< #line 367
<   if ((int )mdev->state.ldv_40583.disk <= 3) {
< #line 368
<     tmp___2 = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_40583.disk);
< #line 368
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "disk is %s, cannot write al transaction (-%d +%d)\n",
<             tmp___2, evicted, new_enr);
< #line 371
<     complete(& ((struct update_al_work *)w)->event);
35251c36784
<     put_ldev(mdev);
---
>   if (tmp___0 == 0) {
35253c36786,36791
<     return (1);
---
>     tmp = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_50103.disk);
> #line 373
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "disk is %s, cannot start al transaction\n",
>             tmp);
> #line 375
>     return (-5);
35257,35264d36794
< #line 376
<   tmp___3 = drbd_md_get_buffer(mdev);
< #line 376
<   buffer = (struct al_transaction *)tmp___3;
< #line 377
<   if ((unsigned long )buffer == (unsigned long )((struct al_transaction *)0)) {
< #line 378
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "disk failed while waiting for md_io buffer\n");
35266c36796
<     complete(& ((struct update_al_work *)w)->event);
---
>   if ((int )mdev->state.ldv_50103.disk <= 3) {
35267a36798,36802
>     tmp___1 = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_50103.disk);
> #line 380
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "disk is %s, cannot write al transaction\n",
>             tmp___1);
> #line 383
35269,35270c36804,36805
< #line 381
<     return (1);
---
> #line 384
>     return (-5);
35274,35279d36808
< #line 384
<   buffer->magic = 1728214147U;
< #line 385
<   tmp___4 = __fswab32(mdev->al_tr_number);
< #line 385
<   buffer->tr_number = tmp___4;
35281c36810
<   tmp___5 = lc_index_of(mdev->act_log, updated);
---
>   tmp___2 = drbd_md_get_buffer(mdev);
35283,35285c36812,36814
<   n = (int )tmp___5;
< #line 389
<   tmp___6 = __fswab32((__u32 )n);
---
>   buffer = (struct al_transaction_on_disk *)tmp___2;
> #line 388
>   if ((unsigned long )buffer == (unsigned long )((struct al_transaction_on_disk *)0)) {
35287,35289c36816
<   buffer->updates[0].pos = tmp___6;
< #line 390
<   tmp___7 = __fswab32(new_enr);
---
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "disk failed while waiting for md_io buffer\n");
35291,35297c36818,36823
<   buffer->updates[0].extent = tmp___7;
< #line 392
<   xor_sum = xor_sum ^ new_enr;
< #line 394
<   __min1 = 61;
< #line 394
<   __min2 = (int )((mdev->act_log)->nr_elements - (unsigned int )mdev->al_tr_cycle);
---
>     put_ldev(mdev);
> #line 391
>     return (-19);
>   } else {
> 
>   }
35299c36825,36827
<   mx = __min1 < __min2 ? __min1 : __min2;
---
>   memset((void *)buffer, 0, 4096UL);
> #line 395
>   buffer->magic = 2724580201U;
35301c36829
<   i = 0;
---
>   tmp___3 = __fswab32(mdev->al_tr_number);
35303,35306c36831
<   goto ldv_51273;
<   ldv_51272: 
< #line 397
<   idx = (unsigned int )(mdev->al_tr_cycle + i);
---
>   buffer->tr_number = tmp___3;
35308,35334c36833
<   tmp___8 = lc_element_by_index(mdev->act_log, idx);
< #line 398
<   extent_nr = tmp___8->lc_number;
< #line 399
<   tmp___9 = __fswab32(idx);
< #line 399
<   buffer->updates[i + 1].pos = tmp___9;
< #line 400
<   tmp___10 = __fswab32(extent_nr);
< #line 400
<   buffer->updates[i + 1].extent = tmp___10;
< #line 401
<   xor_sum = xor_sum ^ extent_nr;
< #line 396
<   i = i + 1;
<   ldv_51273: ;
< #line 396
<   if (i < mx) {
< #line 397
<     goto ldv_51272;
<   } else {
< 
<   }
< 
< #line 403
<   goto ldv_51276;
<   ldv_51275: 
---
>   i = 0;
35336c36835
<   buffer->updates[i + 1].pos = 4294967295U;
---
>   spin_lock_irq(& mdev->al_lock);
35338c36837,36842
<   buffer->updates[i + 1].extent = 4294967295U;
---
>   __mptr = (struct list_head  const  *)(mdev->act_log)->to_be_changed.next;
> #line 405
>   e = (struct lc_element *)__mptr + 0xfffffffffffffff0UL;
> #line 405
>   goto ldv_51836;
>   ldv_51835: ;
35340,35347c36844,36848
<   xor_sum = ~ xor_sum;
< #line 403
<   i = i + 1;
<   ldv_51276: ;
< #line 403
<   if (i <= 60) {
< #line 404
<     goto ldv_51275;
---
>   if (i == 64) {
> #line 407
>     i = i + 1;
> #line 408
>     goto ldv_51834;
35351,35354d36851
< #line 408
<   mdev->al_tr_cycle = mdev->al_tr_cycle + 61;
< #line 409
<   if ((unsigned int )mdev->al_tr_cycle >= (mdev->act_log)->nr_elements) {
35356c36853,36865
<     mdev->al_tr_cycle = 0;
---
>   tmp___4 = __fswab16((int )((__u16 )e->lc_index));
> #line 410
>   buffer->update_slot_nr[i] = tmp___4;
> #line 411
>   tmp___5 = __fswab32(e->lc_new_number);
> #line 411
>   buffer->update_extent_nr[i] = tmp___5;
> #line 412
>   if (e->lc_number != 4294967295U) {
> #line 413
>     tmp___6 = al_extent_to_bm_page(e->lc_number);
> #line 413
>     drbd_bm_mark_for_writeout(mdev, (int )tmp___6);
35360,35367c36869,36883
< #line 412
<   tmp___11 = __fswab32(xor_sum);
< #line 412
<   buffer->xor_sum = tmp___11;
< #line 414
<   sector = (sector_t )(((mdev->ldev)->md.md_offset + (u64 )(mdev->ldev)->md.al_offset) + (u64 )mdev->al_tr_pos);
< #line 417
<   tmp___12 = drbd_md_sync_page_io(mdev, mdev->ldev, sector, 1);
---
> #line 415
>   i = i + 1;
> #line 405
>   __mptr___0 = (struct list_head  const  *)e->list.next;
> #line 405
>   e = (struct lc_element *)__mptr___0 + 0xfffffffffffffff0UL;
>   ldv_51836: ;
> #line 405
>   if ((unsigned long )(& e->list) != (unsigned long )(& (mdev->act_log)->to_be_changed)) {
> #line 406
>     goto ldv_51835;
>   } else {
> 
>   }
>   ldv_51834: 
35369c36885,36893
<   if (tmp___12 == 0) {
---
>   spin_unlock_irq(& mdev->al_lock);
> #line 418
>   tmp___7 = __builtin_expect(i > 64, 0L);
> #line 418
>   if (tmp___7 != 0L) {
> #line 418
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"),
>                          "i" (418), "i" (12UL));
>     ldv_51837: ;
35371c36895
<     drbd_chk_io_error_(mdev, 1, DRBD_META_IO_ERROR, "w_al_write_transaction");
---
>     goto ldv_51837;
35376c36900
<   mdev->al_tr_pos = mdev->al_tr_pos + 1;
---
>   tmp___8 = __fswab16((int )((__u16 )i));
35378c36902,36905
<   if ((unsigned int )mdev->al_tr_pos > (mdev->act_log)->nr_elements / 61U + ((mdev->act_log)->nr_elements % 61U != 0U ? 1U : 0U)) {
---
>   buffer->n_updates = tmp___8;
> #line 421
>   goto ldv_51839;
>   ldv_51838: 
35380,35389c36907,36916
<     mdev->al_tr_pos = 0;
<   } else {
< 
<   }
< #line 424
<   if (mdev->al_tr_pos > 63) {
< #line 424
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->al_tr_pos < MD_AL_MAX_SIZE ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             424);
---
>   buffer->update_slot_nr[i] = 65535U;
> #line 423
>   buffer->update_extent_nr[i] = 4294967295U;
> #line 421
>   i = i + 1;
>   ldv_51839: ;
> #line 421
>   if (i <= 63) {
> #line 422
>     goto ldv_51838;
35393,35394c36920,36923
< #line 425
<   mdev->al_tr_number = mdev->al_tr_number + 1U;
---
> #line 426
>   tmp___9 = __fswab16((int )((__u16 )(mdev->act_log)->nr_elements));
> #line 426
>   buffer->context_size = tmp___9;
35396c36925,36927
<   drbd_md_put_buffer(mdev);
---
>   tmp___10 = __fswab16((int )((__u16 )mdev->al_tr_cycle));
> #line 427
>   buffer->context_start_slot_nr = tmp___10;
35398,35400c36929,36938
<   complete(& ((struct update_al_work *)w)->event);
< #line 430
<   put_ldev(mdev);
---
>   __min1 = 919;
> #line 429
>   __min2 = (int )((mdev->act_log)->nr_elements - (unsigned int )mdev->al_tr_cycle);
> #line 429
>   mx = __min1 < __min2 ? __min1 : __min2;
> #line 431
>   i = 0;
> #line 431
>   goto ldv_51846;
>   ldv_51845: 
35402,35416c36940,36956
<   return (1);
< }
< }
< #line 444 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
< static int drbd_al_read_tr(struct drbd_conf *mdev , struct drbd_backing_dev *bdev ,
<                            struct al_transaction *b , int index ) 
< { 
<   sector_t sector ;
<   int rv ;
<   int i ;
<   u32 xor_sum ;
<   int tmp ;
<   __u32 tmp___0 ;
<   __u32 tmp___1 ;
<   __u32 tmp___2 ;
---
>   idx = (unsigned int )(mdev->al_tr_cycle + i);
> #line 433
>   tmp___11 = lc_element_by_index(mdev->act_log, idx);
> #line 433
>   extent_nr = tmp___11->lc_number;
> #line 434
>   tmp___12 = __fswab32(extent_nr);
> #line 434
>   buffer->context[i] = tmp___12;
> #line 431
>   i = i + 1;
>   ldv_51846: ;
> #line 431
>   if (i < mx) {
> #line 432
>     goto ldv_51845;
>   } else {
35418c36958,36995
<   {
---
>   }
> 
> #line 436
>   goto ldv_51849;
>   ldv_51848: 
> #line 437
>   buffer->context[i] = 4294967295U;
> #line 436
>   i = i + 1;
>   ldv_51849: ;
> #line 436
>   if (i <= 918) {
> #line 437
>     goto ldv_51848;
>   } else {
> 
>   }
> #line 439
>   mdev->al_tr_cycle = mdev->al_tr_cycle + 919;
> #line 440
>   if ((unsigned int )mdev->al_tr_cycle >= (mdev->act_log)->nr_elements) {
> #line 441
>     mdev->al_tr_cycle = 0;
>   } else {
> 
>   }
> #line 443
>   sector = (sector_t )(((mdev->ldev)->md.md_offset + (u64 )(mdev->ldev)->md.al_offset) + (u64 )(mdev->al_tr_pos * 8));
> #line 447
>   crc = crc32c(0U, (void const   *)buffer, 4096U);
> #line 448
>   tmp___13 = __fswab32(crc);
> #line 448
>   buffer->crc32c = tmp___13;
> #line 450
>   tmp___15 = drbd_bm_write_hinted(mdev);
> #line 450
>   if (tmp___15 != 0) {
35420c36997,36998
<   xor_sum = 0U;
---
>     err = -5;
>   } else {
35422,35426c37000,37007
<   sector = (sector_t )((bdev->md.md_offset + (u64 )bdev->md.al_offset) + (u64 )index);
< #line 457
<   tmp = drbd_md_sync_page_io(mdev, bdev, sector, 0);
< #line 457
<   if (tmp == 0) {
---
>     tmp___14 = drbd_md_sync_page_io(mdev, mdev->ldev, sector, 1);
> #line 453
>     if (tmp___14 != 0) {
> #line 454
>       err = -5;
> #line 455
>       drbd_chk_io_error____0(mdev, 1, DRBD_META_IO_ERROR, "_al_write_transaction");
>     } else {
35428,35430c37009,37012
<     return (-1);
<   } else {
< 
---
>       mdev->al_tr_pos = (mdev->al_tr_pos + 1) % 8;
> #line 459
>       mdev->al_tr_number = mdev->al_tr_number + 1U;
>     }
35432,35447d37013
< #line 460
<   tmp___0 = __fswab32(b->magic);
< #line 460
<   rv = tmp___0 == 2205418087U;
< #line 462
<   i = 0;
< #line 462
<   goto ldv_51290;
<   ldv_51289: 
< #line 463
<   tmp___1 = __fswab32(b->updates[i].extent);
< #line 463
<   xor_sum = tmp___1 ^ xor_sum;
< #line 462
<   i = i + 1;
<   ldv_51290: ;
35449c37015
<   if (i <= 61) {
---
>   drbd_md_put_buffer(mdev);
35451,35452c37017,37028
<     goto ldv_51289;
<   } else {
---
>   put_ldev(mdev);
> #line 465
>   return (err);
> }
> }
> #line 469 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
> static int w_al_write_transaction(struct drbd_work *w , int unused ) 
> { 
>   struct update_al_work *aw ;
>   struct drbd_work  const  *__mptr ;
>   struct drbd_conf *mdev ;
>   int err ;
35454,35460c37030,37044
<   }
< #line 464
<   tmp___2 = __fswab32(b->xor_sum);
< #line 464
<   rv = (tmp___2 == xor_sum) & rv;
< #line 466
<   return (rv);
---
>   {
> #line 471
>   __mptr = (struct drbd_work  const  *)w;
> #line 471
>   aw = (struct update_al_work *)__mptr;
> #line 472
>   mdev = w->ldv_50388.mdev;
> #line 475
>   err = _al_write_transaction(mdev);
> #line 476
>   aw->err = err;
> #line 477
>   complete(& aw->event);
> #line 479
>   return (err != -5 ? err : 0);
35463,35464c37047,37048
< #line 476 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
< int drbd_al_read_log(struct drbd_conf *mdev , struct drbd_backing_dev *bdev ) 
---
> #line 485 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
> static int al_write_transaction(struct drbd_conf *mdev ) 
35466,35487c37050,37052
<   struct al_transaction *buffer ;
<   int i ;
<   int rv ;
<   int mx ;
<   int active_extents ;
<   int transactions ;
<   int found_valid ;
<   int from ;
<   int to ;
<   u32 from_tnr ;
<   u32 to_tnr ;
<   u32 cnr ;
<   void *tmp ;
<   __u32 tmp___0 ;
<   int j ;
<   int pos ;
<   unsigned int extent_nr ;
<   unsigned int trn ;
<   int _b ;
<   __u32 tmp___1 ;
<   __u32 tmp___2 ;
<   __u32 tmp___3 ;
---
>   struct update_al_work al_work ;
>   int tmp ;
>   struct task_struct *tmp___0 ;
35490,35513c37055,37062
< #line 482
<   active_extents = 0;
< #line 483
<   transactions = 0;
< #line 484
<   found_valid = 0;
< #line 485
<   from = 0;
< #line 486
<   to = 0;
< #line 487
<   from_tnr = 0U;
< #line 488
<   to_tnr = 0U;
< #line 491
<   mx = (int )((mdev->act_log)->nr_elements / 61U + ((mdev->act_log)->nr_elements % 61U != 0U ? 1U : 0U));
< #line 496
<   tmp = drbd_md_get_buffer(mdev);
< #line 496
<   buffer = (struct al_transaction *)tmp;
< #line 497
<   if ((unsigned long )buffer == (unsigned long )((struct al_transaction *)0)) {
< #line 498
<     return (0);
---
> #line 489
>   tmp___0 = get_current();
> #line 489
>   if ((unsigned long )tmp___0 == (unsigned long )(mdev->tconn)->worker.task) {
> #line 490
>     tmp = _al_write_transaction(mdev);
> #line 490
>     return (tmp);
35517,35528c37066,37084
< #line 501
<   i = 0;
< #line 501
<   goto ldv_51310;
<   ldv_51309: 
< #line 502
<   rv = drbd_al_read_tr(mdev, bdev, buffer, i);
< #line 503
<   if (rv == 0) {
< #line 504
<     goto ldv_51308;
<   } else {
---
> #line 492
>   init_completion(& al_work.event);
> #line 493
>   al_work.w.cb = & w_al_write_transaction;
> #line 494
>   al_work.w.ldv_50388.mdev = mdev;
> #line 495
>   drbd_queue_work_front(& (mdev->tconn)->sender_work, & al_work.w);
> #line 496
>   wait_for_completion(& al_work.event);
> #line 498
>   return (al_work.err);
> }
> }
> #line 501 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
> static int _try_lc_del(struct drbd_conf *mdev , struct lc_element *al_ext ) 
> { 
>   int rv ;
>   long tmp ;
35530c37086
<   }
---
>   {
35532c37088
<   if (rv == -1) {
---
>   spin_lock_irq(& mdev->al_lock);
35534c37090
<     drbd_md_put_buffer(mdev);
---
>   rv = al_ext->refcnt == 0U;
35536c37092,37096
<     return (0);
---
>   tmp = __builtin_expect(rv != 0, 1L);
> #line 507
>   if (tmp != 0L) {
> #line 508
>     lc_del(mdev->act_log, al_ext);
35541,35545c37101
<   tmp___0 = __fswab32(buffer->tr_number);
< #line 509
<   cnr = tmp___0;
< #line 511
<   found_valid = found_valid + 1;
---
>   spin_unlock_irq(& mdev->al_lock);
35547,35594c37103,37115
<   if (found_valid == 1) {
< #line 512
<     from = i;
< #line 513
<     to = i;
< #line 514
<     from_tnr = cnr;
< #line 515
<     to_tnr = cnr;
< #line 516
<     goto ldv_51308;
<   } else {
< 
<   }
< #line 518
<   if ((int )cnr - (int )from_tnr < 0) {
< #line 519
<     if (((from_tnr - cnr) + (u32 )i) - (u32 )from != (u32 )(mx + 1)) {
< #line 519
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( from_tnr - cnr + i - from == mx+1 ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<               519);
<     } else {
< 
<     }
< #line 520
<     from = i;
< #line 521
<     from_tnr = cnr;
<   } else {
< 
<   }
< #line 523
<   if ((int )cnr - (int )to_tnr > 0) {
< #line 524
<     if (cnr - to_tnr != (u32 )(i - to)) {
< #line 524
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( cnr - to_tnr == i - to ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<               524);
<     } else {
< 
<     }
< #line 525
<     to = i;
< #line 526
<     to_tnr = cnr;
<   } else {
---
>   return (rv);
> }
> }
> #line 523 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
> void drbd_al_shrink(struct drbd_conf *mdev ) 
> { 
>   struct lc_element *al_ext ;
>   int i ;
>   int tmp ;
>   int tmp___0 ;
>   wait_queue_t __wait ;
>   struct task_struct *tmp___1 ;
>   int tmp___2 ;
35596,35604c37117,37125
<   }
<   ldv_51308: 
< #line 501
<   i = i + 1;
<   ldv_51310: ;
< #line 501
<   if (i <= mx) {
< #line 502
<     goto ldv_51309;
---
>   {
> #line 528
>   tmp = constant_test_bit(2U, (unsigned long const volatile   *)(& (mdev->act_log)->flags));
> #line 528
>   if (tmp == 0) {
> #line 528
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( test_bit(__LC_LOCKED, &mdev->act_log->flags) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>             528);
35608d37128
< 
35610c37130,37133
<   if (found_valid == 0) {
---
>   i = 0;
> #line 530
>   goto ldv_51881;
>   ldv_51880: 
35612c37135
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "No usable activity log found.\n");
---
>   al_ext = lc_element_by_index(mdev->act_log, (unsigned int )i);
35614c37137
<     drbd_md_put_buffer(mdev);
---
>   if (al_ext->lc_number == 4294967295U) {
35616,35632c37139
<     return (1);
<   } else {
< 
<   }
< #line 538
<   i = from;
<   ldv_51325: 
< #line 544
<   rv = drbd_al_read_tr(mdev, bdev, buffer, i);
< #line 545
<   _b = rv == 0;
< #line 545
<   if (_b != 0) {
< #line 545
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_al_read_log", (char *)"rv == 0", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             545);
---
>     goto ldv_51875;
35636,35639c37143,37148
< #line 545
<   if (_b != 0) {
< #line 545
<     goto cancel;
---
> #line 534
>   tmp___0 = _try_lc_del(mdev, al_ext);
> #line 534
>   if (tmp___0 != 0) {
> #line 534
>     goto ldv_51876;
35643,35941c37152
< #line 546
<   if (rv == -1) {
< #line 547
<     drbd_md_put_buffer(mdev);
< #line 548
<     return (0);
<   } else {
< 
<   }
< #line 551
<   tmp___1 = __fswab32(buffer->tr_number);
< #line 551
<   trn = tmp___1;
< #line 553
<   spin_lock_irq(& mdev->al_lock);
< #line 559
<   j = 61;
< #line 559
<   goto ldv_51322;
<   ldv_51321: 
< #line 560
<   tmp___2 = __fswab32(buffer->updates[j].pos);
< #line 560
<   pos = (int )tmp___2;
< #line 561
<   tmp___3 = __fswab32(buffer->updates[j].extent);
< #line 561
<   extent_nr = tmp___3;
< #line 563
<   if (extent_nr == 4294967295U) {
< #line 564
<     goto ldv_51320;
<   } else {
< 
<   }
< #line 566
<   lc_set(mdev->act_log, extent_nr, pos);
< #line 567
<   active_extents = active_extents + 1;
<   ldv_51320: 
< #line 559
<   j = j - 1;
<   ldv_51322: ;
< #line 559
<   if (j >= 0) {
< #line 560
<     goto ldv_51321;
<   } else {
< 
<   }
< #line 569
<   spin_unlock_irq(& mdev->al_lock);
< #line 571
<   transactions = transactions + 1;
<   cancel: ;
< #line 574
<   if (i == to) {
< #line 575
<     goto ldv_51324;
<   } else {
< 
<   }
< #line 576
<   i = i + 1;
< #line 577
<   if (i > mx) {
< #line 578
<     i = 0;
<   } else {
< 
<   }
< #line 579
<   goto ldv_51325;
<   ldv_51324: 
< #line 581
<   mdev->al_tr_number = to_tnr + 1U;
< #line 582
<   mdev->al_tr_pos = to;
< #line 583
<   mdev->al_tr_pos = mdev->al_tr_pos + 1;
< #line 583
<   if ((unsigned int )mdev->al_tr_pos > (mdev->act_log)->nr_elements / 61U + ((mdev->act_log)->nr_elements % 61U != 0U ? 1U : 0U)) {
< #line 585
<     mdev->al_tr_pos = 0;
<   } else {
< 
<   }
< #line 588
<   drbd_md_put_buffer(mdev);
< #line 590
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Found %d transactions (%d active extents) in activity log.\n",
<             transactions, active_extents);
< #line 593
<   return (1);
< }
< }
< #line 600 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
< void drbd_al_apply_to_bm(struct drbd_conf *mdev ) 
< { 
<   unsigned int enr ;
<   unsigned long add ;
<   char ppb[10U] ;
<   int i ;
<   int tmp ;
<   int tmp___0 ;
<   wait_queue_t __wait ;
<   struct task_struct *tmp___1 ;
<   int tmp___2 ;
<   struct lc_element *tmp___3 ;
<   unsigned long tmp___4 ;
<   struct _ddebug descriptor ;
<   long tmp___5 ;
<   char *tmp___6 ;
< 
<   {
< #line 603
<   add = 0UL;
< #line 607
<   tmp___0 = lc_try_lock(mdev->act_log);
< #line 607
<   if (tmp___0 != 0) {
< #line 607
<     goto ldv_51334;
<   } else {
< 
<   }
< #line 607
<   tmp___1 = get_current();
< #line 607
<   __wait.flags = 0U;
< #line 607
<   __wait.private = (void *)tmp___1;
< #line 607
<   __wait.func = & autoremove_wake_function;
< #line 607
<   __wait.task_list.next = & __wait.task_list;
< #line 607
<   __wait.task_list.prev = & __wait.task_list;
<   ldv_51337: 
< #line 607
<   prepare_to_wait(& mdev->al_wait, & __wait, 2);
< #line 607
<   tmp___2 = lc_try_lock(mdev->act_log);
< #line 607
<   if (tmp___2 != 0) {
< #line 607
<     goto ldv_51336;
<   } else {
< 
<   }
< #line 607
<   schedule();
< #line 607
<   goto ldv_51337;
<   ldv_51336: 
< #line 607
<   finish_wait(& mdev->al_wait, & __wait);
<   ldv_51334: 
< #line 609
<   i = 0;
< #line 609
<   goto ldv_51342;
<   ldv_51341: 
< #line 610
<   tmp___3 = lc_element_by_index(mdev->act_log, (unsigned int )i);
< #line 610
<   enr = tmp___3->lc_number;
< #line 611
<   if (enr == 4294967295U) {
< #line 612
<     goto ldv_51338;
<   } else {
< 
<   }
< #line 613
<   tmp___4 = drbd_bm_ALe_set_all(mdev, (unsigned long )enr);
< #line 613
<   tmp = (int )tmp___4;
< #line 614
<   descriptor.modname = "drbd";
< #line 614
<   descriptor.function = "drbd_al_apply_to_bm";
< #line 614
<   descriptor.filename = "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared";
< #line 614
<   descriptor.format = "AL: set %d bits in extent %u\n";
< #line 614
<   descriptor.lineno = 614U;
< #line 614
<   descriptor.flags = 0U;
< #line 614
<   tmp___5 = __builtin_expect((long )descriptor.flags & 1L, 0L);
< #line 614
<   if (tmp___5 != 0L) {
< #line 614
<     __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (mdev->vdisk)->part0.__dev),
<                       "AL: set %d bits in extent %u\n", tmp, enr);
<   } else {
< 
<   }
< #line 615
<   add = (unsigned long )tmp + add;
<   ldv_51338: 
< #line 609
<   i = i + 1;
<   ldv_51342: ;
< #line 609
<   if ((unsigned int )i < (mdev->act_log)->nr_elements) {
< #line 610
<     goto ldv_51341;
<   } else {
< 
<   }
< #line 618
<   lc_unlock(mdev->act_log);
< #line 619
<   __wake_up(& mdev->al_wait, 3U, 1, 0);
< #line 621
<   tmp___6 = ppsize((char *)(& ppb), (unsigned long long )(add << 2));
< #line 621
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Marked additional %s as out-of-sync based on AL.\n",
<             tmp___6);
< #line 622
<   return;
< }
< }
< #line 625 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
< static int _try_lc_del(struct drbd_conf *mdev , struct lc_element *al_ext ) 
< { 
<   int rv ;
<   long tmp ;
< 
<   {
< #line 629
<   spin_lock_irq(& mdev->al_lock);
< #line 630
<   rv = al_ext->refcnt == 0U;
< #line 631
<   tmp = __builtin_expect(rv != 0, 1L);
< #line 631
<   if (tmp != 0L) {
< #line 632
<     lc_del(mdev->act_log, al_ext);
<   } else {
< 
<   }
< #line 633
<   spin_unlock_irq(& mdev->al_lock);
< #line 635
<   return (rv);
< }
< }
< #line 647 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
< void drbd_al_shrink(struct drbd_conf *mdev ) 
< { 
<   struct lc_element *al_ext ;
<   int i ;
<   int tmp ;
<   int tmp___0 ;
<   wait_queue_t __wait ;
<   struct task_struct *tmp___1 ;
<   int tmp___2 ;
< 
<   {
< #line 652
<   tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& (mdev->act_log)->flags));
< #line 652
<   if (tmp == 0) {
< #line 652
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( test_bit(__LC_DIRTY, &mdev->act_log->flags) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             652);
<   } else {
< 
<   }
< #line 654
<   i = 0;
< #line 654
<   goto ldv_51360;
<   ldv_51359: 
< #line 655
<   al_ext = lc_element_by_index(mdev->act_log, (unsigned int )i);
< #line 656
<   if (al_ext->lc_number == 4294967295U) {
< #line 657
<     goto ldv_51354;
<   } else {
< 
<   }
< #line 658
<   tmp___0 = _try_lc_del(mdev, al_ext);
< #line 658
<   if (tmp___0 != 0) {
< #line 658
<     goto ldv_51355;
<   } else {
< 
<   }
< #line 658
---
> #line 534
35943c37154
< #line 658
---
> #line 534
35945c37156
< #line 658
---
> #line 534
35947c37158
< #line 658
---
> #line 534
35949c37160
< #line 658
---
> #line 534
35951c37162
< #line 658
---
> #line 534
35953,35954c37164,37165
<   ldv_51358: 
< #line 658
---
>   ldv_51879: 
> #line 534
35956c37167
< #line 658
---
> #line 534
35958c37169
< #line 658
---
> #line 534
35960,35961c37171,37172
< #line 658
<     goto ldv_51357;
---
> #line 534
>     goto ldv_51878;
35965c37176
< #line 658
---
> #line 534
35967,35970c37178,37181
< #line 658
<   goto ldv_51358;
<   ldv_51357: 
< #line 658
---
> #line 534
>   goto ldv_51879;
>   ldv_51878: 
> #line 534
35972,35974c37183,37185
<   ldv_51355: ;
<   ldv_51354: 
< #line 654
---
>   ldv_51876: ;
>   ldv_51875: 
> #line 530
35976,35977c37187,37188
<   ldv_51360: ;
< #line 654
---
>   ldv_51881: ;
> #line 530
35979,35980c37190,37191
< #line 655
<     goto ldv_51359;
---
> #line 531
>     goto ldv_51880;
35984c37195
< #line 661
---
> #line 537
35986c37197
< #line 662
---
> #line 538
35990,35991c37201,37202
< #line 664 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
< static int w_update_odbm(struct drbd_conf *mdev , struct drbd_work *w , int unused ) 
---
> #line 540 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
> static int w_update_odbm(struct drbd_work *w , int unused ) 
35994a37206,37207
>   struct drbd_conf *mdev ;
>   struct sib_info sib ;
36001c37214
< #line 666
---
> #line 542
36003c37216
< #line 666
---
> #line 542
36005c37218,37226
< #line 668
---
> #line 543
>   mdev = w->ldv_50388.mdev;
> #line 544
>   sib.sib_reason = SIB_SYNC_PROGRESS;
> #line 544
>   sib.ldv_51335.ldv_51330.helper_name = 0;
> #line 544
>   sib.ldv_51335.ldv_51330.helper_exit_code = 0U;
> #line 546
36007c37228
< #line 668
---
> #line 546
36009c37230
< #line 669
---
> #line 547
36011c37232
< #line 669
---
> #line 547
36013c37234
< #line 670
---
> #line 548
36018c37239
< #line 671
---
> #line 549
36020,36021c37241,37242
< #line 672
<     return (1);
---
> #line 550
>     return (0);
36025c37246
< #line 675
---
> #line 553
36027c37248
< #line 675
---
> #line 553
36029c37250
< #line 676
---
> #line 554
36031c37252
< #line 678
---
> #line 556
36033c37254
< #line 680
---
> #line 558
36035c37256
< #line 680
---
> #line 558
36037,36038c37258,37259
< #line 681
<     switch ((int )mdev->state.ldv_40583.conn) {
---
> #line 559
>     switch ((int )mdev->state.ldv_50103.conn) {
36043c37264
< #line 684
---
> #line 562
36046,36047c37267,37268
< #line 687
<     goto ldv_51376;
---
> #line 565
>     goto ldv_51898;
36049c37270
<     ldv_51376: ;
---
>     ldv_51898: ;
36053,36056c37274,37277
< #line 690
<   drbd_bcast_sync_progress(mdev);
< #line 692
<   return (1);
---
> #line 568
>   drbd_bcast_event(mdev, (struct sib_info  const  *)(& sib));
> #line 570
>   return (0);
36059c37280
< #line 702 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 580 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
36075c37296
< #line 710
---
> #line 588
36077c37298
< #line 710
---
> #line 588
36079c37300
< #line 710
---
> #line 588
36081,36082c37302,37303
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             710);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>             588);
36086c37307
< #line 714
---
> #line 592
36088c37309
< #line 716
---
> #line 594
36090c37311
< #line 717
---
> #line 595
36092c37313
< #line 718
---
> #line 596
36094c37315
< #line 718
---
> #line 596
36096c37317
< #line 719
---
> #line 597
36098c37319
< #line 720
---
> #line 598
36100c37321
< #line 721
---
> #line 599
36103c37324
< #line 723
---
> #line 601
36106c37327
< #line 724
---
> #line 602
36108,36110c37329,37331
< #line 725
<         tmp___0 = drbd_conn_str((enum drbd_conns )mdev->state.ldv_40583.conn);
< #line 725
---
> #line 603
>         tmp___0 = drbd_conn_str((enum drbd_conns )mdev->state.ldv_50103.conn);
> #line 603
36114c37335
< #line 738
---
> #line 616
36120c37341
< #line 747
---
> #line 625
36122c37343
< #line 747
---
> #line 625
36124c37345
< #line 748
---
> #line 626
36126c37347
< #line 749
---
> #line 627
36129c37350
< #line 753
---
> #line 631
36134c37355
< #line 755
---
> #line 633
36136c37357
< #line 756
---
> #line 634
36142c37363
< #line 760
---
> #line 638
36144c37365
< #line 761
---
> #line 639
36146,36147c37367,37368
< #line 762
<       lc_changed(mdev->resync, & ext->lce);
---
> #line 642
>       lc_committed(mdev->resync);
36149c37370
< #line 764
---
> #line 644
36151c37372
< #line 767
---
> #line 647
36153c37374
< #line 768
---
> #line 648
36155,36157c37376,37378
< #line 770
<       tmp___2 = kmalloc(32UL, 32U);
< #line 770
---
> #line 650
>       tmp___2 = kmalloc(40UL, 32U);
> #line 650
36159c37380
< #line 771
---
> #line 651
36161c37382
< #line 772
---
> #line 652
36163c37384
< #line 773
---
> #line 653
36165,36166c37386,37389
< #line 774
<         drbd_queue_work_front(& mdev->data.work, & udw->w);
---
> #line 654
>         udw->w.ldv_50388.mdev = mdev;
> #line 655
>         drbd_queue_work_front(& (mdev->tconn)->sender_work, & udw->w);
36168c37391
< #line 776
---
> #line 657
36175c37398
< #line 780
---
> #line 661
36179c37402
< #line 784
---
> #line 665
36183c37406
< #line 787 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 668 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
36191c37414
< #line 789
---
> #line 670
36193c37416
< #line 790
---
> #line 671
36195c37418
< #line 791
---
> #line 672
36197c37420
< #line 792
---
> #line 673
36199,36201c37422,37424
< #line 793
<     if ((mdev->rs_mark_left[mdev->rs_last_mark] != still_to_go && (unsigned int )*((unsigned short *)mdev + 1138UL) != 336U) && (unsigned int )*((unsigned short *)mdev + 1138UL) != 320U) {
< #line 796
---
> #line 674
>     if ((mdev->rs_mark_left[mdev->rs_last_mark] != still_to_go && (unsigned int )*((unsigned short *)mdev + 374UL) != 336U) && (unsigned int )*((unsigned short *)mdev + 374UL) != 320U) {
> #line 677
36203c37426
< #line 797
---
> #line 678
36205c37428
< #line 798
---
> #line 679
36213c37436
< #line 800
---
> #line 681
36217c37440
< #line 810 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 691 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
36229,36232c37452,37455
<   int _b ;
<   int _b___0 ;
<   long tmp ;
<   long tmp___0 ;
---
>   int tmp ;
>   bool _bool ;
>   int tmp___0 ;
>   bool _bool___0 ;
36234,36235c37457,37458
<   unsigned long tmp___2 ;
<   raw_spinlock_t *tmp___3 ;
---
>   long tmp___2 ;
>   long tmp___3 ;
36236a37460,37461
>   unsigned long tmp___5 ;
>   raw_spinlock_t *tmp___6 ;
36239c37464
< #line 815
---
> #line 696
36241c37466
< #line 817
---
> #line 698
36243,36245c37468,37470
< #line 820
<   if ((size <= 0 || (size & 511) != 0) || (unsigned int )size > 131072U) {
< #line 821
---
> #line 701
>   if ((size <= 0 || (size & 511) != 0) || (unsigned int )size > 1048576U) {
> #line 702
36248c37473
< #line 823
---
> #line 704
36253c37478,37487
< #line 825
---
> #line 707
>   tmp = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 707
>   if (tmp == 0) {
> #line 708
>     return;
>   } else {
> 
>   }
> #line 710
36255c37489
< #line 826
---
> #line 711
36257,36264c37491,37497
< #line 828
<   _b = sector >= nr_sectors;
< #line 828
<   if (_b != 0) {
< #line 828
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "__drbd_set_in_sync", (char *)"sector >= nr_sectors", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             828);
---
> #line 713
>   _bool = sector < nr_sectors;
> #line 713
>   if (! _bool) {
> #line 713
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"sector < nr_sectors", "__drbd_set_in_sync");
36268,36271c37501,37512
< #line 828
<   if (_b != 0) {
< #line 828
<     return;
---
> #line 713
>   if (_bool) {
> #line 713
>     tmp___0 = 0;
>   } else {
> #line 713
>     tmp___0 = 1;
>   }
> #line 713
>   if (tmp___0) {
> #line 714
>     goto out;
36275,36282c37516,37522
< #line 829
<   _b___0 = esector >= nr_sectors;
< #line 829
<   if (_b___0 != 0) {
< #line 829
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "__drbd_set_in_sync", (char *)"esector >= nr_sectors", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             829);
---
> #line 715
>   _bool___0 = esector < nr_sectors;
> #line 715
>   if (! _bool___0) {
> #line 715
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"esector < nr_sectors", "__drbd_set_in_sync");
36286,36288c37526,37536
< #line 829
<   if (_b___0 != 0) {
< #line 829
---
> #line 715
>   if (_bool___0) {
> #line 715
>     tmp___1 = 0;
>   } else {
> #line 715
>     tmp___1 = 1;
>   }
> #line 715
>   if (tmp___1) {
> #line 716
36293c37541
< #line 831
---
> #line 718
36295,36300c37543,37548
< #line 836
<   tmp = __builtin_expect(esector <= 6UL, 0L);
< #line 836
<   if (tmp != 0L) {
< #line 837
<     return;
---
> #line 723
>   tmp___2 = __builtin_expect(esector <= 6UL, 0L);
> #line 723
>   if (tmp___2 != 0L) {
> #line 724
>     goto out;
36304,36308c37552,37556
< #line 838
<   tmp___0 = __builtin_expect(nr_sectors - 1UL == esector, 0L);
< #line 838
<   if (tmp___0 != 0L) {
< #line 839
---
> #line 725
>   tmp___3 = __builtin_expect(nr_sectors - 1UL == esector, 0L);
> #line 725
>   if (tmp___3 != 0L) {
> #line 726
36311c37559
< #line 841
---
> #line 728
36314c37562
< #line 842
---
> #line 729
36316c37564
< #line 844
---
> #line 731
36318,36319c37566,37567
< #line 845
<     return;
---
> #line 732
>     goto out;
36323,36327c37571,37575
< #line 851
<   tmp___1 = drbd_bm_clear_bits(mdev, sbnr, ebnr);
< #line 851
<   count = (unsigned long )tmp___1;
< #line 852
---
> #line 738
>   tmp___4 = drbd_bm_clear_bits(mdev, sbnr, ebnr);
> #line 738
>   count = (unsigned long )tmp___4;
> #line 739
36329,36351c37577,37590
< #line 852
<     tmp___4 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 852
<     if (tmp___4 != 0) {
< #line 853
<       tmp___2 = drbd_bm_total_weight(mdev);
< #line 853
<       drbd_advance_rs_marks(mdev, tmp___2);
< #line 854
<       tmp___3 = spinlock_check(& mdev->al_lock);
< #line 854
<       flags = _raw_spin_lock_irqsave(tmp___3);
< #line 855
<       drbd_try_clear_on_disk_bm(mdev, sector, (int )count, 1);
< #line 856
<       spin_unlock_irqrestore(& mdev->al_lock, flags);
< #line 860
<       wake_up = 1;
< #line 861
<       put_ldev(mdev);
<     } else {
< 
<     }
---
> #line 740
>     tmp___5 = drbd_bm_total_weight(mdev);
> #line 740
>     drbd_advance_rs_marks(mdev, tmp___5);
> #line 741
>     tmp___6 = spinlock_check(& mdev->al_lock);
> #line 741
>     flags = _raw_spin_lock_irqsave(tmp___6);
> #line 742
>     drbd_try_clear_on_disk_bm(mdev, sector, (int )count, 1);
> #line 743
>     spin_unlock_irqrestore(& mdev->al_lock, flags);
> #line 747
>     wake_up = 1;
36355c37594,37597
< #line 863
---
>   out: 
> #line 750
>   put_ldev(mdev);
> #line 751
36357c37599
< #line 864
---
> #line 752
36362c37604
< #line 865
---
> #line 753
36366c37608
< #line 875 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 763 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
36372d37613
<   unsigned long lbnr ;
36380,36382c37621,37623
<   int _b ;
<   int _b___0 ;
<   raw_spinlock_t *tmp___0 ;
---
>   bool _bool ;
>   int tmp___0 ;
>   bool _bool___0 ;
36383a37625,37626
>   raw_spinlock_t *tmp___2 ;
>   int tmp___3 ;
36388c37631
< #line 880
---
> #line 768
36390c37633
< #line 884
---
> #line 772
36392c37635
< #line 885
---
> #line 773
36397,36399c37640,37642
< #line 887
<   if ((size < 0 || (size & 511) != 0) || (unsigned int )size > 131072U) {
< #line 888
---
> #line 775
>   if ((size < 0 || (size & 511) != 0) || (unsigned int )size > 1048576U) {
> #line 776
36402c37645
< #line 890
---
> #line 778
36407c37650
< #line 893
---
> #line 781
36409c37652
< #line 893
---
> #line 781
36411c37654
< #line 894
---
> #line 782
36416c37659
< #line 896
---
> #line 784
36418c37661
< #line 897
---
> #line 785
36420,36427c37663,37669
< #line 899
<   _b = sector >= nr_sectors;
< #line 899
<   if (_b != 0) {
< #line 899
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "__drbd_set_out_of_sync", (char *)"sector >= nr_sectors", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             899);
---
> #line 787
>   _bool = sector < nr_sectors;
> #line 787
>   if (! _bool) {
> #line 787
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"sector < nr_sectors", "__drbd_set_out_of_sync");
36431,36433c37673,37683
< #line 899
<   if (_b != 0) {
< #line 900
---
> #line 787
>   if (_bool) {
> #line 787
>     tmp___0 = 0;
>   } else {
> #line 787
>     tmp___0 = 1;
>   }
> #line 787
>   if (tmp___0) {
> #line 788
36438,36445c37688,37694
< #line 901
<   _b___0 = esector >= nr_sectors;
< #line 901
<   if (_b___0 != 0) {
< #line 901
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "__drbd_set_out_of_sync", (char *)"esector >= nr_sectors", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             901);
---
> #line 789
>   _bool___0 = esector < nr_sectors;
> #line 789
>   if (! _bool___0) {
> #line 789
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"esector < nr_sectors", "__drbd_set_out_of_sync");
36449,36451c37698,37708
< #line 901
<   if (_b___0 != 0) {
< #line 902
---
> #line 789
>   if (_bool___0) {
> #line 789
>     tmp___1 = 0;
>   } else {
> #line 789
>     tmp___1 = 1;
>   }
> #line 789
>   if (tmp___1) {
> #line 790
36456,36458c37713
< #line 904
<   lbnr = (nr_sectors - 1UL) >> 3;
< #line 908
---
> #line 794
36460c37715
< #line 909
---
> #line 795
36462,36470c37717,37725
< #line 913
<   tmp___0 = spinlock_check(& mdev->al_lock);
< #line 913
<   flags = _raw_spin_lock_irqsave(tmp___0);
< #line 914
<   tmp___1 = drbd_bm_set_bits(mdev, sbnr, ebnr);
< #line 914
<   count = (unsigned int )tmp___1;
< #line 916
---
> #line 799
>   tmp___2 = spinlock_check(& mdev->al_lock);
> #line 799
>   flags = _raw_spin_lock_irqsave(tmp___2);
> #line 800
>   tmp___3 = drbd_bm_set_bits(mdev, sbnr, ebnr);
> #line 800
>   count = (unsigned int )tmp___3;
> #line 802
36472c37727
< #line 917
---
> #line 803
36474c37729
< #line 918
---
> #line 804
36476c37731
< #line 919
---
> #line 805
36478c37733
< #line 919
---
> #line 805
36480c37735
< #line 919
---
> #line 805
36485c37740
< #line 920
---
> #line 806
36488c37743
< #line 923
---
> #line 809
36490c37745
< #line 925
---
> #line 811
36494c37749
< #line 929 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 815 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
36505c37760
< #line 933
---
> #line 819
36507c37762
< #line 936
---
> #line 822
36509c37764
< #line 937
---
> #line 823
36511c37766
< #line 938
---
> #line 824
36513c37768
< #line 939
---
> #line 825
36518c37773
< #line 941
---
> #line 827
36520c37775
< #line 942
---
> #line 828
36522c37777
< #line 942
---
> #line 828
36524c37779
< #line 942
---
> #line 828
36527c37782
< #line 942
---
> #line 828
36530c37785
< #line 943
---
> #line 829
36532c37787
< #line 944
---
> #line 830
36534c37789
< #line 945
---
> #line 831
36536c37791
< #line 946
---
> #line 832
36538,36540c37793,37795
< #line 947
<       lc_changed(mdev->resync, & bm_ext->lce);
< #line 948
---
> #line 833
>       lc_committed(mdev->resync);
> #line 834
36545c37800
< #line 950
---
> #line 836
36547c37802
< #line 951
---
> #line 837
36552c37807
< #line 952
---
> #line 838
36557c37812
< #line 954
---
> #line 840
36559c37814
< #line 955
---
> #line 841
36561c37816
< #line 956
---
> #line 842
36563c37818
< #line 957
---
> #line 843
36568c37823
< #line 959
---
> #line 845
36570,36572c37825,37827
< #line 960
<     if ((rs_flags & 4UL) != 0UL) {
< #line 961
---
> #line 846
>     if ((rs_flags & 8UL) != 0UL) {
> #line 847
36577,36579c37832,37834
< #line 963
<     tmp = __builtin_expect((rs_flags & 2UL) != 0UL, 0L);
< #line 963
---
> #line 849
>     tmp = __builtin_expect((rs_flags & 4UL) != 0UL, 0L);
> #line 849
36581,36586c37836,37841
< #line 963
<       __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"),
<                            "i" (963), "i" (12UL));
<       ldv_51463: ;
< #line 963
<       goto ldv_51463;
---
> #line 849
>       __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"),
>                            "i" (849), "i" (12UL));
>       ldv_51985: ;
> #line 849
>       goto ldv_51985;
36593c37848
< #line 966
---
> #line 852
36597c37852
< #line 969 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 855 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
36600d37854
<   struct lc_element *al_ext ;
36602c37856
<   long tmp ;
---
>   bool tmp ;
36605,36607c37859
< #line 972
<   rv = 0;
< #line 974
---
> #line 859
36609,36631c37861,37865
< #line 975
<   tmp = __builtin_expect((mdev->act_log)->new_number == enr, 0L);
< #line 975
<   if (tmp != 0L) {
< #line 976
<     rv = 1;
<   } else {
< #line 978
<     al_ext = lc_find(mdev->act_log, enr);
< #line 979
<     if ((unsigned long )al_ext != (unsigned long )((struct lc_element *)0)) {
< #line 980
<       if (al_ext->refcnt != 0U) {
< #line 981
<         rv = 1;
<       } else {
< 
<       }
<     } else {
< 
<     }
<   }
< #line 984
---
> #line 860
>   tmp = lc_is_used(mdev->act_log, enr);
> #line 860
>   rv = (int )tmp;
> #line 861
36633c37867
< #line 991
---
> #line 863
36637c37871
< #line 1001 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 873 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
36665c37899
< #line 1003
---
> #line 875
36667c37901
< #line 1006
---
> #line 878
36670c37904
< #line 1010
---
> #line 882
36672c37906
< #line 1010
---
> #line 882
36674c37908
< #line 1010
---
> #line 882
36676c37910
< #line 1010
---
> #line 882
36678c37912
< #line 1010
---
> #line 882
36680c37914
< #line 1010
---
> #line 882
36682c37916
< #line 1010
---
> #line 882
36684c37918
< #line 1010
---
> #line 882
36686c37920
< #line 1010
---
> #line 882
36688,36689c37922,37923
<     ldv_51484: 
< #line 1010
---
>     ldv_52005: 
> #line 882
36691c37925
< #line 1010
---
> #line 882
36693c37927
< #line 1010
---
> #line 882
36695,36696c37929,37930
< #line 1010
<       goto ldv_51482;
---
> #line 882
>       goto ldv_52003;
36700c37934
< #line 1010
---
> #line 882
36702c37936
< #line 1010
---
> #line 882
36704c37938
< #line 1010
---
> #line 882
36706c37940
< #line 1010
---
> #line 882
36708,36709c37942,37943
< #line 1010
<       goto ldv_51483;
---
> #line 882
>       goto ldv_52004;
36713c37947
< #line 1010
---
> #line 882
36715,36721c37949,37955
< #line 1010
<     goto ldv_51482;
<     ldv_51483: ;
< #line 1010
<     goto ldv_51484;
<     ldv_51482: 
< #line 1010
---
> #line 882
>     goto ldv_52003;
>     ldv_52004: ;
> #line 882
>     goto ldv_52005;
>     ldv_52003: 
> #line 882
36726c37960
< #line 1010
---
> #line 882
36728c37962
< #line 1012
---
> #line 884
36730c37964
< #line 1013
---
> #line 885
36735c37969
< #line 1015
---
> #line 887
36737c37971
< #line 1015
---
> #line 887
36739c37973
< #line 1016
---
> #line 888
36744c37978
< #line 1018
---
> #line 890
36746,36749c37980,37983
< #line 1018
<   goto ldv_51493;
<   ldv_51492: 
< #line 1019
---
> #line 890
>   goto ldv_52014;
>   ldv_52013: 
> #line 891
36751c37985
< #line 1019
---
> #line 891
36753c37987
< #line 1019
---
> #line 891
36755c37989
< #line 1019
---
> #line 891
36757c37991
< #line 1019
---
> #line 891
36759c37993
< #line 1019
---
> #line 891
36761c37995
< #line 1019
---
> #line 891
36763c37997
< #line 1019
---
> #line 891
36765c37999
< #line 1019
---
> #line 891
36767c38001
< #line 1019
---
> #line 891
36769c38003
< #line 1019
---
> #line 891
36771,36772c38005,38006
<       ldv_51490: 
< #line 1019
---
>       ldv_52011: 
> #line 891
36774c38008
< #line 1019
---
> #line 891
36776c38010
< #line 1019
---
> #line 891
36778,36779c38012,38013
< #line 1019
<         goto ldv_51488;
---
> #line 891
>         goto ldv_52009;
36781c38015
< #line 1019
---
> #line 891
36783c38017
< #line 1019
---
> #line 891
36785,36786c38019,38020
< #line 1019
<           goto ldv_51488;
---
> #line 891
>           goto ldv_52009;
36791c38025
< #line 1019
---
> #line 891
36793c38027
< #line 1019
---
> #line 891
36795c38029
< #line 1019
---
> #line 891
36797c38031
< #line 1019
---
> #line 891
36799,36800c38033,38034
< #line 1019
<         goto ldv_51489;
---
> #line 891
>         goto ldv_52010;
36804c38038
< #line 1019
---
> #line 891
36806,36812c38040,38046
< #line 1019
<       goto ldv_51488;
<       ldv_51489: ;
< #line 1019
<       goto ldv_51490;
<       ldv_51488: 
< #line 1019
---
> #line 891
>       goto ldv_52009;
>       ldv_52010: ;
> #line 891
>       goto ldv_52011;
>       ldv_52009: 
> #line 891
36820c38054
< #line 1019
---
> #line 891
36822c38056
< #line 1023
---
> #line 895
36824c38058
< #line 1023
---
> #line 895
36827c38061
< #line 1023
---
> #line 895
36829c38063
< #line 1023
---
> #line 895
36832c38066
< #line 1024
---
> #line 896
36834c38068
< #line 1025
---
> #line 897
36836c38070
< #line 1025
---
> #line 897
36838c38072
< #line 1026
---
> #line 898
36840c38074
< #line 1027
---
> #line 899
36842c38076
< #line 1028
---
> #line 900
36847c38081
< #line 1030
---
> #line 902
36849c38083
< #line 1031
---
> #line 903
36851c38085
< #line 1032
---
> #line 904
36856c38090
< #line 1033
---
> #line 905
36858c38092
< #line 1033
---
> #line 905
36860c38094
< #line 1034
---
> #line 906
36865c38099
< #line 1035
---
> #line 907
36867c38101
< #line 1035
---
> #line 907
36869c38103
< #line 1035
---
> #line 907
36871c38105
< #line 1036
---
> #line 908
36879c38113
< #line 1038
---
> #line 910
36885c38119
< #line 1018
---
> #line 890
36887,36888c38121,38122
<   ldv_51493: ;
< #line 1018
---
>   ldv_52014: ;
> #line 890
36890,36891c38124,38125
< #line 1019
<     goto ldv_51492;
---
> #line 891
>     goto ldv_52013;
36895c38129
< #line 1041
---
> #line 913
36897c38131
< #line 1042
---
> #line 914
36901c38135
< #line 1054 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 926 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
36920,36921c38154
<   long tmp___6 ;
<   int tmp___7 ;
---
>   bool tmp___6 ;
36924c38157
< #line 1056
---
> #line 928
36926c38159
< #line 1057
---
> #line 929
36928c38161
< #line 1062
---
> #line 934
36930c38163
< #line 1063
---
> #line 935
36932c38165
< #line 1077
---
> #line 949
36934c38167
< #line 1078
---
> #line 950
36936c38169
< #line 1078
---
> #line 950
36938c38171
< #line 1078
---
> #line 950
36941c38174
< #line 1078
---
> #line 950
36944c38177
< #line 1079
---
> #line 951
36946c38179
< #line 1080
---
> #line 952
36948c38181
< #line 1080
---
> #line 952
36950c38183
< #line 1080
---
> #line 952
36952,36953c38185,38186
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<                 1080);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>                 952);
36957c38190
< #line 1081
---
> #line 953
36959c38192
< #line 1081
---
> #line 953
36961c38194
< #line 1081
---
> #line 953
36963,36964c38196,38197
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<                 1081);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>                 953);
36968c38201
< #line 1082
---
> #line 954
36970c38203
< #line 1083
---
> #line 955
36972c38205
< #line 1084
---
> #line 956
36974c38207
< #line 1084
---
> #line 956
36976c38209
< #line 1085
---
> #line 957
36981c38214
< #line 1086
---
> #line 958
36984c38217
< #line 1088
---
> #line 960
36990c38223
< #line 1092
---
> #line 964
36992c38225
< #line 1093
---
> #line 965
36994c38227
< #line 1093
---
> #line 965
36996c38229
< #line 1093
---
> #line 965
36999c38232
< #line 1093
---
> #line 965
37002c38235
< #line 1094
---
> #line 966
37004c38237
< #line 1095
---
> #line 967
37006c38239
< #line 1095
---
> #line 967
37008c38241
< #line 1096
---
> #line 968
37013c38246
< #line 1097
---
> #line 969
37015c38248
< #line 1097
---
> #line 969
37017c38250
< #line 1098
---
> #line 970
37020c38253
< #line 1104
---
> #line 976
37022c38255
< #line 1105
---
> #line 977
37024c38257
< #line 1105
---
> #line 977
37026,37027c38259,38260
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<                 1105);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>                 977);
37032c38265
< #line 1107
---
> #line 979
37035c38268
< #line 1110
---
> #line 982
37037c38270
< #line 1111
---
> #line 983
37042c38275
< #line 1113
---
> #line 985
37044c38277
< #line 1114
---
> #line 986
37046c38279
< #line 1114
---
> #line 986
37048c38281
< #line 1114
---
> #line 986
37051c38284
< #line 1114
---
> #line 986
37054c38287
< #line 1115
---
> #line 987
37056c38289
< #line 1116
---
> #line 988
37058,37060c38291,38293
< #line 1117
<       if ((rs_flags & 4UL) != 0UL) {
< #line 1118
---
> #line 989
>       if ((rs_flags & 8UL) != 0UL) {
> #line 990
37065,37067c38298,38300
< #line 1120
<       tmp___4 = __builtin_expect((rs_flags & 2UL) != 0UL, 0L);
< #line 1120
---
> #line 992
>       tmp___4 = __builtin_expect((rs_flags & 4UL) != 0UL, 0L);
> #line 992
37069,37074c38302,38307
< #line 1120
<         __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"),
<                              "i" (1120), "i" (12UL));
<         ldv_51514: ;
< #line 1120
<         goto ldv_51514;
---
> #line 992
>         __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"),
>                              "i" (992), "i" (12UL));
>         ldv_52035: ;
> #line 992
>         goto ldv_52035;
37078c38311
< #line 1121
---
> #line 993
37083c38316
< #line 1123
---
> #line 995
37085c38318
< #line 1124
---
> #line 996
37087c38320
< #line 1125
---
> #line 997
37089,37091c38322,38324
< #line 1126
<       lc_changed(mdev->resync, & bm_ext->lce);
< #line 1127
---
> #line 998
>       lc_committed(mdev->resync);
> #line 999
37093c38326
< #line 1128
---
> #line 1000
37095c38328
< #line 1128
---
> #line 1000
37097c38330
< #line 1128
---
> #line 1000
37099,37100c38332,38333
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<                 1128);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>                 1000);
37107c38340
< #line 1130
---
> #line 1002
37109c38342
< #line 1131
---
> #line 1003
37111c38344
< #line 1131
---
> #line 1003
37113,37114c38346,38347
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<               1131);
---
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>               1003);
37118c38351
< #line 1132
---
> #line 1004
37120c38353
< #line 1133
---
> #line 1005
37124c38357
< #line 1136
---
> #line 1008
37126,37143c38359,38366
< #line 1136
<   goto ldv_51516;
<   ldv_51515: 
< #line 1137
<   tmp___6 = __builtin_expect(al_enr + (unsigned int )i == (mdev->act_log)->new_number,
<                              0L);
< #line 1137
<   if (tmp___6 != 0L) {
< #line 1138
<     goto try_again;
<   } else {
< 
<   }
< #line 1139
<   tmp___7 = lc_is_used(mdev->act_log, al_enr + (unsigned int )i);
< #line 1139
<   if (tmp___7 != 0) {
< #line 1140
---
> #line 1008
>   goto ldv_52037;
>   ldv_52036: 
> #line 1009
>   tmp___6 = lc_is_used(mdev->act_log, al_enr + (unsigned int )i);
> #line 1009
>   if ((int )tmp___6) {
> #line 1010
37148c38371
< #line 1136
---
> #line 1008
37150,37151c38373,38374
<   ldv_51516: ;
< #line 1136
---
>   ldv_52037: ;
> #line 1008
37153,37154c38376,38377
< #line 1137
<     goto ldv_51515;
---
> #line 1009
>     goto ldv_52036;
37158c38381
< #line 1142
---
> #line 1012
37161c38384
< #line 1144
---
> #line 1014
37163c38386
< #line 1145
---
> #line 1015
37165c38388
< #line 1146
---
> #line 1016
37168c38391
< #line 1149
---
> #line 1019
37170c38393
< #line 1150
---
> #line 1020
37175c38398
< #line 1151
---
> #line 1021
37177c38400
< #line 1152
---
> #line 1022
37181c38404
< #line 1155 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 1025 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
37194c38417
< #line 1157
---
> #line 1027
37196c38419
< #line 1162
---
> #line 1032
37198c38421
< #line 1162
---
> #line 1032
37200c38423
< #line 1163
---
> #line 1033
37202c38425
< #line 1164
---
> #line 1034
37204c38427
< #line 1164
---
> #line 1034
37206c38429
< #line 1164
---
> #line 1034
37209c38432
< #line 1164
---
> #line 1034
37212c38435
< #line 1165
---
> #line 1035
37214c38437
< #line 1166
---
> #line 1036
37216c38439
< #line 1167
---
> #line 1037
37218c38441
< #line 1167
---
> #line 1037
37220c38443
< #line 1168
---
> #line 1038
37225c38448
< #line 1169
---
> #line 1039
37230c38453
< #line 1172
---
> #line 1042
37232c38455
< #line 1173
---
> #line 1043
37234c38457
< #line 1174
---
> #line 1044
37237c38460
< #line 1177
---
> #line 1047
37242c38465
< #line 1180
---
> #line 1050
37244c38467
< #line 1180
---
> #line 1050
37246c38469
< #line 1181
---
> #line 1051
37248c38471
< #line 1182
---
> #line 1052
37250c38473
< #line 1183
---
> #line 1053
37255c38478
< #line 1186
---
> #line 1056
37257c38480
< #line 1187
---
> #line 1057
37261c38484
< #line 1193 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 1063 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
37267c38490
< #line 1195
---
> #line 1065
37269c38492
< #line 1197
---
> #line 1067
37271c38494
< #line 1197
---
> #line 1067
37273c38496
< #line 1198
---
> #line 1068
37275c38498
< #line 1199
---
> #line 1069
37280c38503
< #line 1201
---
> #line 1071
37282c38505
< #line 1202
---
> #line 1072
37284c38507
< #line 1203
---
> #line 1073
37286c38509
< #line 1204
---
> #line 1074
37288c38511
< #line 1205
---
> #line 1075
37292c38515
< #line 1214 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 1084 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
37306c38529
< #line 1220
---
> #line 1090
37308c38531
< #line 1222
---
> #line 1092
37310c38533
< #line 1222
---
> #line 1092
37312c38535
< #line 1224
---
> #line 1094
37314,37317c38537,38540
< #line 1224
<     goto ldv_51545;
<     ldv_51544: 
< #line 1225
---
> #line 1094
>     goto ldv_52066;
>     ldv_52065: 
> #line 1095
37319c38542
< #line 1226
---
> #line 1096
37321c38544
< #line 1226
---
> #line 1096
37323c38546
< #line 1227
---
> #line 1097
37325,37326c38548,38549
< #line 1228
<       goto ldv_51543;
---
> #line 1098
>       goto ldv_52064;
37330c38553
< #line 1229
---
> #line 1099
37332c38555
< #line 1230
---
> #line 1100
37335c38558
< #line 1233
---
> #line 1103
37337c38560
< #line 1233
---
> #line 1103
37339c38562
< #line 1233
---
> #line 1103
37341,37342c38564,38565
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<                 1233);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>                 1103);
37346c38569
< #line 1234
---
> #line 1104
37348c38571
< #line 1234
---
> #line 1104
37350c38573
< #line 1234
---
> #line 1104
37352,37353c38575,38576
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<                 1234);
---
>                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>                 1104);
37357c38580
< #line 1235
---
> #line 1105
37359c38582
< #line 1236
---
> #line 1106
37361c38584
< #line 1237
---
> #line 1107
37366c38589
< #line 1239
---
> #line 1109
37368c38591
< #line 1240
---
> #line 1110
37371c38594
< #line 1242
---
> #line 1112
37373c38596
< #line 1243
---
> #line 1113
37375c38598
< #line 1244
---
> #line 1114
37380c38603
< #line 1246
---
> #line 1116
37382c38605
< #line 1246
---
> #line 1116
37384c38607
< #line 1246
---
> #line 1116
37386,37387c38609,38610
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<               1246);
---
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>               1116);
37391c38614
< #line 1247
---
> #line 1117
37393c38616
< #line 1247
---
> #line 1117
37395c38618
< #line 1247
---
> #line 1117
37397,37398c38620,38621
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<               1247);
---
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>               1117);
37402c38625
< #line 1248
---
> #line 1118
37404,37405c38627,38628
<     ldv_51543: 
< #line 1224
---
>     ldv_52064: 
> #line 1094
37407,37408c38630,38631
<     ldv_51545: ;
< #line 1224
---
>     ldv_52066: ;
> #line 1094
37410,37411c38633,38634
< #line 1225
<       goto ldv_51544;
---
> #line 1095
>       goto ldv_52065;
37416c38639
< #line 1250
---
> #line 1120
37418c38641
< #line 1250
---
> #line 1120
37420,37421c38643,38644
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<               1250);
---
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
>               1120);
37425c38648
< #line 1251
---
> #line 1121
37430c38653
< #line 1253
---
> #line 1123
37432c38655
< #line 1254
---
> #line 1124
37434c38657
< #line 1256
---
> #line 1126
37438c38661
< #line 1265 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
---
> #line 1135 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
37448,37453c38671,38678
<   int _b ;
<   int _b___0 ;
<   long tmp ;
<   long tmp___0 ;
<   int tmp___1 ;
<   int tmp___2 ;
---
>   bool _bool ;
>   int tmp ;
>   bool _bool___0 ;
>   int tmp___0 ;
>   long tmp___1 ;
>   long tmp___2 ;
>   int tmp___3 ;
>   int tmp___4 ;
37456c38681
< #line 1271
---
> #line 1141
37458,37460c38683,38685
< #line 1273
<   if ((size <= 0 || (size & 511) != 0) || (unsigned int )size > 131072U) {
< #line 1274
---
> #line 1143
>   if ((size <= 0 || (size & 511) != 0) || (unsigned int )size > 1048576U) {
> #line 1144
37463c38688
< #line 1276
---
> #line 1146
37468c38693
< #line 1278
---
> #line 1148
37470c38695
< #line 1279
---
> #line 1149
37472,37479c38697,38703
< #line 1281
<   _b = sector >= nr_sectors;
< #line 1281
<   if (_b != 0) {
< #line 1281
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_rs_failed_io", (char *)"sector >= nr_sectors", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             1281);
---
> #line 1151
>   _bool = sector < nr_sectors;
> #line 1151
>   if (! _bool) {
> #line 1151
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"sector < nr_sectors", "drbd_rs_failed_io");
37483,37485c38707,38717
< #line 1281
<   if (_b != 0) {
< #line 1281
---
> #line 1151
>   if (_bool) {
> #line 1151
>     tmp = 0;
>   } else {
> #line 1151
>     tmp = 1;
>   }
> #line 1151
>   if (tmp) {
> #line 1152
37490,37497c38722,38728
< #line 1282
<   _b___0 = esector >= nr_sectors;
< #line 1282
<   if (_b___0 != 0) {
< #line 1282
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_rs_failed_io", (char *)"esector >= nr_sectors", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared",
<             1282);
---
> #line 1153
>   _bool___0 = esector < nr_sectors;
> #line 1153
>   if (! _bool___0) {
> #line 1153
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"esector < nr_sectors", "drbd_rs_failed_io");
37501,37503c38732,38742
< #line 1282
<   if (_b___0 != 0) {
< #line 1282
---
> #line 1153
>   if (_bool___0) {
> #line 1153
>     tmp___0 = 0;
>   } else {
> #line 1153
>     tmp___0 = 1;
>   }
> #line 1153
>   if (tmp___0) {
> #line 1154
37508c38747
< #line 1284
---
> #line 1156
37510,37514c38749,38753
< #line 1289
<   tmp = __builtin_expect(esector <= 6UL, 0L);
< #line 1289
<   if (tmp != 0L) {
< #line 1290
---
> #line 1161
>   tmp___1 = __builtin_expect(esector <= 6UL, 0L);
> #line 1161
>   if (tmp___1 != 0L) {
> #line 1162
37519,37523c38758,38762
< #line 1291
<   tmp___0 = __builtin_expect(nr_sectors - 1UL == esector, 0L);
< #line 1291
<   if (tmp___0 != 0L) {
< #line 1292
---
> #line 1163
>   tmp___2 = __builtin_expect(nr_sectors - 1UL == esector, 0L);
> #line 1163
>   if (tmp___2 != 0L) {
> #line 1164
37526c38765
< #line 1294
---
> #line 1166
37529c38768
< #line 1295
---
> #line 1167
37531c38770
< #line 1297
---
> #line 1169
37533c38772
< #line 1298
---
> #line 1170
37538c38777
< #line 1304
---
> #line 1176
37540,37544c38779,38783
< #line 1305
<   tmp___1 = drbd_bm_count_bits(mdev, sbnr, ebnr);
< #line 1305
<   count = (unsigned long )tmp___1;
< #line 1306
---
> #line 1177
>   tmp___3 = drbd_bm_count_bits(mdev, sbnr, ebnr);
> #line 1177
>   count = (unsigned long )tmp___3;
> #line 1178
37546c38785
< #line 1307
---
> #line 1179
37548,37552c38787,38791
< #line 1309
<     tmp___2 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1309
<     if (tmp___2 != 0) {
< #line 1310
---
> #line 1181
>     tmp___4 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1181
>     if (tmp___4 != 0) {
> #line 1182
37554c38793
< #line 1311
---
> #line 1183
37559c38798
< #line 1316
---
> #line 1188
37564c38803
< #line 1318
---
> #line 1190
37566c38805
< #line 1319
---
> #line 1191
37568c38807
< #line 1320
---
> #line 1192
37573c38812
< #line 1321
---
> #line 1193
37577,37578c38816,38817
< #line 292 "include/linux/list.h"
< __inline static void list_splice(struct list_head  const  *list , struct list_head *head ) 
---
> #line 1232 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_actlog.c.prepared"
> void ldv_main5_sequence_infinite_withcheck_stateful(void) 
37580a38820
>   int tmp___0 ;
37583,37588c38823,38845
< #line 295
<   tmp = list_empty(list);
< #line 295
<   if (tmp == 0) {
< #line 296
<     __list_splice(list, head, head->next);
---
> #line 1244
>   LDV_IN_INTERRUPT = 1;
> #line 1253
>   ldv_initialize();
> #line 1255
>   goto ldv_52104;
>   ldv_52103: 
> #line 1258
>   tmp = nondet_int();
> #line 1258
>   switch (tmp) {
>   default: ;
> #line 1260
>   goto ldv_52102;
>   }
>   ldv_52102: ;
>   ldv_52104: 
> #line 1255
>   tmp___0 = nondet_int();
> #line 1255
>   if (tmp___0 != 0) {
> #line 1256
>     goto ldv_52103;
37592c38849,38853
< #line 297
---
> 
> 
> #line 1269
>   ldv_check_final_state();
> #line 1272
37606c38867,38877
< #line 113 "include/linux/bitmap.h"
---
> #line 323 "include/linux/kernel.h"
> extern int sprintf(char * , char const   *  , ...) ;
> #line 326
> extern int snprintf(char * , size_t  , char const   *  , ...) ;
> #line 23 "include/linux/string.h"
> extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
> #line 115
> extern char *kstrdup(char const   * , gfp_t  ) ;
> #line 93 "include/linux/bitmap.h"
> extern int __bitmap_equal(unsigned long const   * , unsigned long const   * , int  ) ;
> #line 113
37607a38879,38881
> #line 125
> extern int __bitmap_parse(char const   * , unsigned int  , int  , unsigned long * ,
>                           int  ) ;
37626a38901,38932
> #line 179 "include/linux/bitmap.h"
> __inline static void bitmap_copy(unsigned long *dst , unsigned long const   *src ,
>                                  int nbits ) 
> { 
>   int len ;
>   size_t __len ;
>   void *__ret ;
> 
>   {
> #line 185
>   len = (int )((unsigned int )(((unsigned long )nbits + 63UL) / 64UL) * 8U);
> #line 186
>   __len = (size_t )len;
> #line 186
>   __ret = __builtin_memcpy((void *)dst, (void const   *)src, __len);
> #line 189
>   return;
> }
> }
> #line 233 "include/linux/bitmap.h"
> __inline static int bitmap_equal(unsigned long const   *src1 , unsigned long const   *src2 ,
>                                  int nbits ) 
> { 
>   int tmp ;
> 
>   {
> #line 239
>   tmp = __bitmap_equal(src1, src2, nbits);
> #line 239
>   return (tmp);
> }
> }
37638a38945,38957
> #line 301 "include/linux/bitmap.h"
> __inline static int bitmap_parse(char const   *buf , unsigned int buflen , unsigned long *maskp ,
>                                  int nmaskbits ) 
> { 
>   int tmp ;
> 
>   {
> #line 304
>   tmp = __bitmap_parse(buf, buflen, 0, maskp, nmaskbits);
> #line 304
>   return (tmp);
> }
> }
37666a38986,38998
> #line 404 "include/linux/cpumask.h"
> __inline static bool cpumask_equal(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
> { 
>   int tmp ;
> 
>   {
> #line 407
>   tmp = bitmap_equal((unsigned long const   *)(& src1p->bits), (unsigned long const   *)(& src2p->bits),
>                      nr_cpu_ids);
> #line 407
>   return (tmp != 0);
> }
> }
37678a39011,39023
> #line 495 "include/linux/cpumask.h"
> __inline static void cpumask_copy(struct cpumask *dstp , struct cpumask  const  *srcp ) 
> { 
> 
> 
>   {
> #line 498
>   bitmap_copy((unsigned long *)(& dstp->bits), (unsigned long const   *)(& srcp->bits),
>               nr_cpu_ids);
> #line 499
>   return;
> }
> }
37682a39028,39030
> #line 279 "include/linux/lockdep.h"
> extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
>                              int  ) ;
37684a39033,39034
> #line 92 "include/linux/completion.h"
> extern void complete_all(struct completion * ) ;
37689a39040,39053
> #line 164 "include/linux/workqueue.h"
> extern void __init_work(struct work_struct * , int  ) ;
> #line 328
> extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
>                                                       int  , struct lock_class_key * ,
>                                                       char const   *  , ...) ;
> #line 390
> extern void destroy_workqueue(struct workqueue_struct * ) ;
> #line 394
> extern bool queue_work(struct workqueue_struct * , struct work_struct * ) ;
> #line 345 "include/linux/gfp.h"
> extern unsigned long __get_free_pages(gfp_t  , unsigned int  ) ;
> #line 360
> extern void free_pages(unsigned long  , unsigned int  ) ;
37691c39055
< bool ldv_try_module_get_5(struct module *ldv_func_arg1 ) ;
---
> bool ldv_try_module_get_4(struct module *ldv_func_arg1 ) ;
37693c39057
< void ldv_module_put_4(struct module *ldv_func_arg1 ) ;
---
> void ldv_module_put_3(struct module *ldv_func_arg1 ) ;
37695c39059,39073
< void ldv_module_put_6(struct module *ldv_func_arg1 ) ;
---
> void ldv_module_put_5(struct module *ldv_func_arg1 ) ;
> #line 43 "include/linux/rculist.h"
> extern void __list_add_rcu(struct list_head * , struct list_head * , struct list_head * ) ;
> #line 84 "include/linux/rculist.h"
> __inline static void list_add_tail_rcu(struct list_head *new , struct list_head *head ) 
> { 
> 
> 
>   {
> #line 87
>   __list_add_rcu(new, head->prev, head);
> #line 88
>   return;
> }
> }
37737a39116,39125
> #line 105 "include/linux/idr.h"
> extern int idr_pre_get(struct idr * , gfp_t  ) ;
> #line 107
> extern int idr_get_new_above(struct idr * , void * , int  , int * ) ;
> #line 112
> extern void idr_remove(struct idr * , int  ) ;
> #line 114
> extern void idr_destroy(struct idr * ) ;
> #line 115
> extern void idr_init(struct idr * ) ;
37745c39133,39135
< #line 410 "include/linux/genhd.h"
---
> #line 409 "include/linux/genhd.h"
> extern void add_disk(struct gendisk * ) ;
> #line 410
37777c39167,39169
< #line 213 "include/linux/bio.h"
---
> #line 212 "include/linux/bio.h"
> extern struct bio_set *bioset_create(unsigned int  , unsigned int  ) ;
> #line 213
37779c39171,39181
< #line 895 "include/linux/blkdev.h"
---
> #line 787 "include/linux/blkdev.h"
> __inline static struct request_queue *bdev_get_queue(struct block_device *bdev ) 
> { 
> 
> 
>   {
> #line 789
>   return ((bdev->bd_disk)->queue);
> }
> }
> #line 895
37793c39195
< #line 244 "include/linux/lru_cache.h"
---
> #line 255 "include/linux/lru_cache.h"
37795c39197,39203
< #line 62 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 22 "include/linux/genl_magic_struct.h"
> int drbd_genl_register(void) ;
> #line 23
> void drbd_genl_unregister(void) ;
> #line 134 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_state.h"
> void drbd_resume_al(struct drbd_conf *mdev ) ;
> #line 66 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37797,37800d39204
< #line 63 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< bool allow_oos  ;
< #line 64
< unsigned int cn_idx ;
37801a39206,39207
> bool allow_oos  ;
> #line 70 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37803c39209
< #line 68 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 71 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37805c39211
< #line 69 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 72 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37807c39213
< #line 72
---
> #line 75
37809,37873c39215,39219
< #line 157 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< struct drbd_conf **minor_table  ;
< #line 591 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void DCBP_set_code(struct p_compressed_bm *p , enum drbd_bitmap_code code ) 
< { 
<   long tmp ;
< 
<   {
< #line 593
<   tmp = __builtin_expect(((unsigned int )code & 4294967280U) != 0U, 0L);
< #line 593
<   if (tmp != 0L) {
< #line 593
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"),
<                          "i" (593), "i" (12UL));
<     ldv_49899: ;
< #line 593
<     goto ldv_49899;
<   } else {
< 
<   }
< #line 594
<   p->encoding = ((unsigned int )p->encoding & 240U) | (unsigned int )((u8 )code);
< #line 595
<   return;
< }
< }
< #line 604 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void DCBP_set_start(struct p_compressed_bm *p , int set ) 
< { 
< 
< 
<   {
< #line 606
<   p->encoding = (u8 )(((int )((signed char )p->encoding) & 127) | (set != 0 ? -128 : 0));
< #line 607
<   return;
< }
< }
< #line 616 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void DCBP_set_pad_bits(struct p_compressed_bm *p , int n ) 
< { 
<   long tmp ;
< 
<   {
< #line 618
<   tmp = __builtin_expect((n & -8) != 0, 0L);
< #line 618
<   if (tmp != 0L) {
< #line 618
<     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"),
<                          "i" (618), "i" (12UL));
<     ldv_49914: ;
< #line 618
<     goto ldv_49914;
<   } else {
< 
<   }
< #line 619
<   p->encoding = (u8 )(((int )((signed char )p->encoding) & -128) | (int )((signed char )(n << 4)));
< #line 620
<   return;
< }
< }
< #line 1232
---
> #line 167 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct idr minors  ;
> #line 168 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> struct list_head drbd_tconns  ;
> #line 1063
37875,37883c39221,39224
< #line 1246
< void print_st_err(struct drbd_conf *mdev , union drbd_state os , union drbd_state ns ,
<                   enum drbd_state_rv err ) ;
< #line 1252
< void drbd_calc_cpu_mask(struct drbd_conf *mdev ) ;
< #line 1257
< void drbd_free_resources(struct drbd_conf *mdev ) ;
< #line 1263
< int drbd_send(struct drbd_conf *mdev , struct socket *sock , void *buf , size_t size ,
---
> #line 1069
> void drbd_calc_cpu_mask(struct drbd_tconn *tconn ) ;
> #line 1078
> int drbd_send(struct drbd_tconn *tconn , struct socket *sock , void *buf , size_t size ,
37885c39226,39231
< #line 1267
---
> #line 1080
> int drbd_send_all(struct drbd_tconn *tconn , struct socket *sock , void *buffer ,
>                   size_t size , unsigned int msg_flags ) ;
> #line 1083
> int __drbd_send_protocol(struct drbd_tconn *tconn , enum drbd_packet cmd ) ;
> #line 1086
37887c39233
< #line 1270
---
> #line 1089
37889,37891c39235
< #line 1306
< int _drbd_send_bitmap(struct drbd_conf *mdev ) ;
< #line 1308
---
> #line 1116
37893c39237
< #line 1313
---
> #line 1122
37895c39239
< #line 1320
---
> #line 1129
37897c39241
< #line 1321
---
> #line 1130
37899c39243
< #line 1322
---
> #line 1131
37901c39245
< #line 1324
---
> #line 1133
37903c39247
< #line 1330
---
> #line 1139
37906c39250,39253
< #line 1531 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1146
> int drbd_bitmap_io_from_worker(struct drbd_conf *mdev , int (*io_fn)(struct drbd_conf * ) ,
>                                char *why , enum bm_flag flags ) ;
> #line 1365 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37908c39255
< #line 1532 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1366 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37910c39257
< #line 1533 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1367 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37912c39259
< #line 1534 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1368 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37914c39261
< #line 1535 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1369 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37916c39263
< #line 1536 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1370 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37918c39265
< #line 1551 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1385 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37920c39267
< #line 1552 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1386 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37922c39269
< #line 1553 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1387 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37924c39271
< #line 1554 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1388 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37926c39273
< #line 1562 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1396 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37928c39275
< #line 1566 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1400 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37930,37934c39277,39295
< #line 1572
< struct drbd_conf *drbd_new_device(unsigned int minor ) ;
< #line 1573
< void drbd_free_mdev(struct drbd_conf *mdev ) ;
< #line 1575 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1406
> int conn_lowest_minor(struct drbd_tconn *tconn ) ;
> #line 1407
> enum drbd_ret_code conn_new_minor(struct drbd_tconn *tconn , unsigned int minor ,
>                                   int vnr ) ;
> #line 1410
> int set_resource_options(struct drbd_tconn *tconn , struct res_opts *res_opts ) ;
> #line 1411
> struct drbd_tconn *conn_create(char const   *name , struct res_opts *res_opts ) ;
> #line 1412
> void conn_destroy(struct kref *kref ) ;
> #line 1413
> struct drbd_tconn *conn_get_by_name(char const   *name ) ;
> #line 1414
> struct drbd_tconn *conn_get_by_addrs(void *my_addr , int my_addr_len , void *peer_addr ,
>                                      int peer_addr_len ) ;
> #line 1416
> void conn_free_crypto(struct drbd_tconn *tconn ) ;
> #line 1418 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
37936c39297,39299
< #line 1585
---
> #line 1429
> int drbd_msg_put_info(char const   *info ) ;
> #line 1430
37938c39301
< #line 1586
---
> #line 1431
37940,37947c39303,39305
< #line 1753
< void drbd_nl_cleanup(void) ;
< #line 1754
< int drbd_nl_init(void) ;
< #line 1755
< void drbd_bcast_state(struct drbd_conf *mdev , union drbd_state state ) ;
< #line 1840 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void drbd_state_lock___0(struct drbd_conf *mdev ) 
---
> #line 1675 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void __drbd_chk_io_error____3(struct drbd_conf *mdev , enum drbd_force_detach_flags df ,
>                                               char const   *where ) 
37948a39307,39309
>   enum drbd_io_error_p ep ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
37950,37951c39311
<   wait_queue_t __wait ;
<   struct task_struct *tmp___0 ;
---
>   int tmp___0 ;
37952a39313,39314
>   union drbd_state __ns ;
>   union drbd_state __ns___0 ;
37955,37961c39317,39334
< #line 1842
<   tmp = drbd_test_and_set_flag(mdev, CLUSTER_ST_CHANGE);
< #line 1842
<   if (tmp == 0) {
< #line 1842
<     goto ldv_51040;
<   } else {
---
> #line 1681
>   rcu_read_lock();
> #line 1682
>   _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 1682
>   tmp = debug_lockdep_rcu_enabled();
> #line 1682
>   if (tmp != 0 && ! __warned) {
> #line 1682
>     tmp___0 = rcu_read_lock_held();
> #line 1682
>     if (tmp___0 == 0 && 1) {
> #line 1682
>       __warned = 1;
> #line 1682
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h",
>                              1682, "suspicious rcu_dereference_check() usage");
>     } else {
37963,37984c39336
<   }
< #line 1842
<   tmp___0 = get_current();
< #line 1842
<   __wait.flags = 0U;
< #line 1842
<   __wait.private = (void *)tmp___0;
< #line 1842
<   __wait.func = & autoremove_wake_function;
< #line 1842
<   __wait.task_list.next = & __wait.task_list;
< #line 1842
<   __wait.task_list.prev = & __wait.task_list;
<   ldv_51043: 
< #line 1842
<   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
< #line 1842
<   tmp___1 = drbd_test_and_set_flag(mdev, CLUSTER_ST_CHANGE);
< #line 1842
<   if (tmp___1 == 0) {
< #line 1842
<     goto ldv_51042;
---
>     }
37988,38012c39340,39347
< #line 1842
<   schedule();
< #line 1842
<   goto ldv_51043;
<   ldv_51042: 
< #line 1842
<   finish_wait(& mdev->misc_wait, & __wait);
<   ldv_51040: ;
< #line 1845
<   return;
< }
< }
< #line 1890 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void __drbd_chk_io_error____3(struct drbd_conf *mdev , enum drbd_force_detach_flags df ,
<                                               char const   *where ) 
< { 
<   int tmp ;
<   union drbd_state __ns ;
<   union drbd_state __ns___0 ;
< 
<   {
< #line 1894
<   switch ((mdev->ldev)->dc.on_io_error) {
<   case 0: ;
< #line 1896
---
> #line 1682
>   ep = (enum drbd_io_error_p )_________p1->on_io_error;
> #line 1683
>   rcu_read_unlock();
> #line 1684
>   switch ((unsigned int )ep) {
>   case 0U: ;
> #line 1686
38014,38018c39349,39353
< #line 1897
<     tmp = ___ratelimit(& drbd_ratelimit_state, "__drbd_chk_io_error_");
< #line 1897
<     if (tmp != 0) {
< #line 1898
---
> #line 1687
>     tmp___1 = ___ratelimit(& drbd_ratelimit_state, "__drbd_chk_io_error_");
> #line 1687
>     if (tmp___1 != 0) {
> #line 1688
38024,38030c39359,39365
< #line 1899
<     if ((int )mdev->state.ldv_40583.disk > 4) {
< #line 1900
<       __ns.i = mdev->state.i;
< #line 1900
<       __ns.ldv_40583.disk = 4U;
< #line 1900
---
> #line 1689
>     if ((int )mdev->state.ldv_50103.disk > 4) {
> #line 1690
>       __ns = drbd_read_state(mdev);
> #line 1690
>       __ns.ldv_40604.disk = 4U;
> #line 1690
38035,38036c39370,39371
< #line 1901
<     goto ldv_51073;
---
> #line 1691
>     goto ldv_51589;
38040,38044c39375,39379
<   case 2: ;
<   case 1: 
< #line 1926
<   drbd_set_flag(mdev, WAS_IO_ERROR);
< #line 1927
---
>   case 2U: ;
>   case 1U: 
> #line 1716
>   set_bit(12U, (unsigned long volatile   *)(& mdev->flags));
> #line 1717
38046,38047c39381,39382
< #line 1928
<     drbd_set_flag(mdev, WAS_READ_ERROR);
---
> #line 1718
>     set_bit(13U, (unsigned long volatile   *)(& mdev->flags));
38051c39386
< #line 1929
---
> #line 1719
38053,38054c39388,39389
< #line 1930
<     drbd_set_flag(mdev, FORCE_DETACH);
---
> #line 1720
>     set_bit(14U, (unsigned long volatile   *)(& mdev->flags));
38058,38064c39393,39399
< #line 1931
<   if ((int )mdev->state.ldv_40583.disk > 2) {
< #line 1932
<     __ns___0.i = mdev->state.i;
< #line 1932
<     __ns___0.ldv_40583.disk = 2U;
< #line 1932
---
> #line 1721
>   if ((int )mdev->state.ldv_50103.disk > 2) {
> #line 1722
>     __ns___0 = drbd_read_state(mdev);
> #line 1722
>     __ns___0.ldv_40604.disk = 2U;
> #line 1722
38066c39401
< #line 1933
---
> #line 1723
38072,38073c39407,39408
< #line 1936
<   goto ldv_51073;
---
> #line 1726
>   goto ldv_51589;
38075,38076c39410,39411
<   ldv_51073: ;
< #line 1939
---
>   ldv_51589: ;
> #line 1729
38080c39415
< #line 1949 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1739 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
38088c39423
< #line 1952
---
> #line 1742
38090,38092c39425,39427
< #line 1954
<     tmp = spinlock_check(& mdev->req_lock);
< #line 1954
---
> #line 1744
>     tmp = spinlock_check(& (mdev->tconn)->req_lock);
> #line 1744
38094c39429
< #line 1955
---
> #line 1745
38096,38097c39431,39432
< #line 1956
<     spin_unlock_irqrestore(& mdev->req_lock, flags);
---
> #line 1746
>     spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
38101c39436
< #line 1958
---
> #line 1748
38105c39440
< #line 2011 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1818 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
38108a39444,39448
>   int meta_dev_idx ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
38111,38112c39451,39452
<   sector_t tmp___0 ;
<   sector_t tmp___1 ;
---
>   sector_t tmp___2 ;
>   sector_t tmp___3 ;
38115c39455
<   sector_t tmp___2 ;
---
>   sector_t tmp___4 ;
38120c39460
<   sector_t tmp___3 ;
---
>   sector_t tmp___5 ;
38123,38124c39463,39491
< #line 2014
<   switch (bdev->dc.meta_dev_idx) {
---
> #line 1823
>   rcu_read_lock();
> #line 1824
>   _________p1 = *((struct disk_conf * volatile  *)(& bdev->disk_conf));
> #line 1824
>   tmp = debug_lockdep_rcu_enabled();
> #line 1824
>   if (tmp != 0 && ! __warned) {
> #line 1824
>     tmp___0 = rcu_read_lock_held();
> #line 1824
>     if (tmp___0 == 0 && 1) {
> #line 1824
>       __warned = 1;
> #line 1824
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h",
>                              1824, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1824
>   meta_dev_idx = _________p1->meta_dev_idx;
> #line 1825
>   rcu_read_unlock();
> #line 1827
>   switch (meta_dev_idx) {
38127,38131c39494,39498
< #line 2018
<   tmp___1 = drbd_get_capacity(bdev->backing_bdev);
< #line 2018
<   if (tmp___1 != 0UL) {
< #line 2018
---
> #line 1831
>   tmp___3 = drbd_get_capacity(bdev->backing_bdev);
> #line 1831
>   if (tmp___3 != 0UL) {
> #line 1831
38133,38137c39500,39504
< #line 2018
<     tmp___0 = drbd_md_first_sector(bdev);
< #line 2018
<     __min2 = tmp___0;
< #line 2018
---
> #line 1831
>     tmp___2 = _drbd_md_first_sector(meta_dev_idx, bdev);
> #line 1831
>     __min2 = tmp___2;
> #line 1831
38140c39507
< #line 2018
---
> #line 1831
38143,38144c39510,39511
< #line 2021
<   goto ldv_51114;
---
> #line 1834
>   goto ldv_51646;
38146c39513
< #line 2023
---
> #line 1836
38148,38152c39515,39519
< #line 2023
<   tmp___2 = drbd_get_capacity(bdev->backing_bdev);
< #line 2023
<   __min2___0 = tmp___2;
< #line 2023
---
> #line 1836
>   tmp___4 = drbd_get_capacity(bdev->backing_bdev);
> #line 1836
>   __min2___0 = tmp___4;
> #line 1836
38154c39521
< #line 2026
---
> #line 1839
38156c39523
< #line 2026
---
> #line 1839
38158c39525
< #line 2026
---
> #line 1839
38160,38161c39527,39528
< #line 2029
<   goto ldv_51114;
---
> #line 1842
>   goto ldv_51646;
38163c39530
< #line 2031
---
> #line 1844
38165,38169c39532,39536
< #line 2031
<   tmp___3 = drbd_get_capacity(bdev->backing_bdev);
< #line 2031
<   __min2___2 = tmp___3;
< #line 2031
---
> #line 1844
>   tmp___5 = drbd_get_capacity(bdev->backing_bdev);
> #line 1844
>   __min2___2 = tmp___5;
> #line 1844
38172,38173c39539,39540
<   ldv_51114: ;
< #line 2034
---
>   ldv_51646: ;
> #line 1847
38177c39544
< #line 2042 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1855 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
38179a39547,39549
>   int meta_dev_idx ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
38181c39551,39553
<   sector_t tmp___0 ;
---
>   int tmp___0 ;
>   int tmp___1 ;
>   sector_t tmp___2 ;
38184,38185c39556,39584
< #line 2045
<   switch (bdev->dc.meta_dev_idx) {
---
> #line 1860
>   rcu_read_lock();
> #line 1861
>   _________p1 = *((struct disk_conf * volatile  *)(& bdev->disk_conf));
> #line 1861
>   tmp = debug_lockdep_rcu_enabled();
> #line 1861
>   if (tmp != 0 && ! __warned) {
> #line 1861
>     tmp___0 = rcu_read_lock_held();
> #line 1861
>     if (tmp___0 == 0 && 1) {
> #line 1861
>       __warned = 1;
> #line 1861
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h",
>                              1861, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1861
>   meta_dev_idx = _________p1->meta_dev_idx;
> #line 1862
>   rcu_read_unlock();
> #line 1864
>   switch (meta_dev_idx) {
38187,38188c39586,39587
< #line 2047
<   return ((unsigned long )bdev->dc.meta_dev_idx * 262144UL);
---
> #line 1866
>   return ((unsigned long )meta_dev_idx * 262144UL);
38191c39590
< #line 2053
---
> #line 1872
38193,38197c39592,39596
< #line 2054
<     tmp = ___ratelimit(& drbd_ratelimit_state, "drbd_md_ss__");
< #line 2054
<     if (tmp != 0) {
< #line 2055
---
> #line 1873
>     tmp___1 = ___ratelimit(& drbd_ratelimit_state, "drbd_md_ss__");
> #line 1873
>     if (tmp___1 != 0) {
> #line 1874
38199c39598
< #line 2056
---
> #line 1875
38204c39603
< #line 2058
---
> #line 1877
38209,38212c39608,39611
< #line 2060
<   tmp___0 = drbd_get_capacity(bdev->backing_bdev);
< #line 2060
<   return ((sector_t )(((unsigned long long )tmp___0 & 0xfffffffffffffff8ULL) - 8ULL));
---
> #line 1879
>   tmp___2 = drbd_get_capacity(bdev->backing_bdev);
> #line 1879
>   return ((sector_t )(((unsigned long long )tmp___2 & 0xfffffffffffffff8ULL) - 8ULL));
38214c39613
< #line 2063
---
> #line 1882
38219,38243c39618,39622
< #line 2125 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void drbd_thread_stop_nowait(struct drbd_thread *thi ) 
< { 
< 
< 
<   {
< #line 2127
<   _drbd_thread_stop(thi, 0, 0);
< #line 2128
<   return;
< }
< }
< #line 2130 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void drbd_thread_restart_nowait(struct drbd_thread *thi ) 
< { 
< 
< 
<   {
< #line 2132
<   _drbd_thread_stop(thi, 1, 0);
< #line 2133
<   return;
< }
< }
< #line 2347 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 1929
> int drbd_send_state_req(struct drbd_conf *mdev , union drbd_state mask , union drbd_state val ) ;
> #line 1930
> int conn_send_state_req(struct drbd_tconn *tconn , union drbd_state mask , union drbd_state val ) ;
> #line 2146 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
38246c39625
<   union drbd_state s ;
---
>   union drbd_dev_state s ;
38249c39628
< #line 2349
---
> #line 2148
38251,38252c39630,39631
< #line 2354
<   switch ((unsigned int )s.ldv_40583.conn) {
---
> #line 2153
>   switch ((unsigned int )s.ldv_50103.conn) {
38274,38275c39653,39654
< #line 2379
<   goto ldv_51245;
---
> #line 2178
>   goto ldv_51818;
38277,38279c39656,39658
< #line 2383
<   if (mdev->agreed_pro_version <= 95) {
< #line 2384
---
> #line 2182
>   if ((mdev->tconn)->agreed_pro_version <= 95) {
> #line 2183
38284,38285c39663,39664
< #line 2385
<   goto ldv_51245;
---
> #line 2184
>   goto ldv_51818;
38289c39668
< #line 2392
---
> #line 2191
38292,38294c39671,39673
<   ldv_51245: ;
< #line 2395
<   switch ((unsigned int )s.ldv_40583.disk) {
---
>   ldv_51818: ;
> #line 2194
>   switch ((unsigned int )s.ldv_50103.disk) {
38301,38302c39680,39681
< #line 2403
<   goto ldv_51256;
---
> #line 2202
>   goto ldv_51829;
38307c39686
< #line 2411
---
> #line 2210
38310,38311c39689,39690
<   ldv_51256: ;
< #line 2414
---
>   ldv_51829: ;
> #line 2213
38315c39694
< #line 2422 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2223 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
38327c39706
< #line 2424
---
> #line 2225
38329c39708
< #line 2424
---
> #line 2225
38331,38333c39710,39712
< #line 2426
<   tmp___0 = is_susp(mdev->state);
< #line 2426
---
> #line 2227
>   tmp___0 = drbd_suspended(mdev);
> #line 2227
38335c39714
< #line 2427
---
> #line 2228
38340,38342c39719,39721
< #line 2428
<   tmp___1 = drbd_test_flag(mdev, SUSPEND_IO);
< #line 2428
---
> #line 2229
>   tmp___1 = constant_test_bit(8U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2229
38344c39723
< #line 2429
---
> #line 2230
38349c39728
< #line 2436
---
> #line 2237
38351c39730
< #line 2436
---
> #line 2237
38353c39732
< #line 2437
---
> #line 2238
38358c39737
< #line 2441
---
> #line 2242
38360c39739
< #line 2441
---
> #line 2242
38362c39741
< #line 2442
---
> #line 2243
38367,38369c39746,39748
< #line 2443
<   tmp___4 = drbd_test_flag(mdev, BITMAP_IO);
< #line 2443
---
> #line 2244
>   tmp___4 = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2244
38371c39750
< #line 2444
---
> #line 2245
38376c39755
< #line 2445
---
> #line 2246
38380,38381c39759,39760
< #line 2527 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< __inline static void drbd_update_congested(struct drbd_conf *mdev ) 
---
> #line 2249 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static bool inc_ap_bio_cond___0(struct drbd_conf *mdev ) 
38383c39762
<   struct sock *sk ;
---
>   bool rv ;
38386,38391c39765,39774
< #line 2529
<   sk = (mdev->data.socket)->sk;
< #line 2530
<   if (sk->sk_wmem_queued > (sk->sk_sndbuf * 4) / 5) {
< #line 2531
<     drbd_set_flag(mdev, NET_CONGESTED);
---
> #line 2251
>   rv = 0;
> #line 2253
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 2254
>   rv = may_inc_ap_bio___0(mdev);
> #line 2255
>   if ((int )rv) {
> #line 2256
>     atomic_inc(& mdev->ap_bio_cnt);
38395c39778,39834
< #line 2532
---
> #line 2257
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 2259
>   return (rv);
> }
> }
> #line 2262 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void inc_ap_bio___0(struct drbd_conf *mdev ) 
> { 
>   bool tmp ;
>   wait_queue_t __wait ;
>   struct task_struct *tmp___0 ;
>   bool tmp___1 ;
> 
>   {
> #line 2272
>   tmp = inc_ap_bio_cond___0(mdev);
> #line 2272
>   if ((int )tmp) {
> #line 2272
>     goto ldv_51849;
>   } else {
> 
>   }
> #line 2272
>   tmp___0 = get_current();
> #line 2272
>   __wait.flags = 0U;
> #line 2272
>   __wait.private = (void *)tmp___0;
> #line 2272
>   __wait.func = & autoremove_wake_function;
> #line 2272
>   __wait.task_list.next = & __wait.task_list;
> #line 2272
>   __wait.task_list.prev = & __wait.task_list;
>   ldv_51852: 
> #line 2272
>   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
> #line 2272
>   tmp___1 = inc_ap_bio_cond___0(mdev);
> #line 2272
>   if ((int )tmp___1) {
> #line 2272
>     goto ldv_51851;
>   } else {
> 
>   }
> #line 2272
>   schedule();
> #line 2272
>   goto ldv_51852;
>   ldv_51851: 
> #line 2272
>   finish_wait(& mdev->misc_wait, & __wait);
>   ldv_51849: ;
> #line 2275
38399c39838
< #line 2534 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
> #line 2307 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
38405c39844
< #line 2541
---
> #line 2314
38409,38410c39848,39851
< #line 331 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
< void tl_restart(struct drbd_conf *mdev , enum drbd_req_event what ) ;
---
> #line 278 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_req.h"
> void tl_restart(struct drbd_tconn *tconn , enum drbd_req_event what ) ;
> #line 279
> void _tl_restart(struct drbd_tconn *tconn , enum drbd_req_event what ) ;
38654,38655c40095,40096
<   goto ldv_51510;
<   ldv_51509: 
---
>   goto ldv_52040;
>   ldv_52039: 
38664c40105
<   ldv_51510: ;
---
>   ldv_52040: ;
38668c40109
<     goto ldv_51509;
---
>     goto ldv_52039;
38706c40147
< #line 75 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 67 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
38711c40152
< #line 80
---
> #line 72
38713c40154
< #line 81
---
> #line 73
38715c40156
< #line 82
---
> #line 74
38717,38724c40158,40160
< #line 83
< static int w_after_state_ch(struct drbd_conf *mdev , struct drbd_work *w , int unused ) ;
< #line 84
< static void after_state_ch(struct drbd_conf *mdev , union drbd_state os , union drbd_state ns ,
<                            enum chg_state_flags flags ) ;
< #line 86
< static int w_md_sync(struct drbd_conf *mdev , struct drbd_work *w , int unused ) ;
< #line 87
---
> #line 75
> static int w_md_sync(struct drbd_work *w , int unused ) ;
> #line 76
38726,38732c40162,40166
< #line 88
< static int w_bitmap_io(struct drbd_conf *mdev , struct drbd_work *w , int unused ) ;
< #line 89
< static int w_go_diskless(struct drbd_conf *mdev , struct drbd_work *w , int unused ) ;
< #line 90
< static void _tl_clear(struct drbd_conf *mdev ) ;
< #line 115 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 77
> static int w_bitmap_io(struct drbd_work *w , int unused ) ;
> #line 78
> static int w_go_diskless(struct drbd_work *w , int unused ) ;
> #line 102 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
38734c40168
< #line 128 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 115 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
38736,38738c40170
< #line 131 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< unsigned int cn_idx  =    8U;
< #line 136 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 122 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
38740c40172
< #line 136
---
> #line 122
38745c40177
< #line 165 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 152 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
38749c40181
< #line 167 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 154 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
38751c40183
< #line 167
---
> #line 154
38753c40185
< #line 173 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 160 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
38755a40188
>   struct bio *bio ;
38757d40189
<   struct bio *tmp___0 ;
38760c40192
< #line 175
---
> #line 164
38762c40194
< #line 176
---
> #line 165
38764c40196
< #line 176
---
> #line 165
38769,38772c40201,40211
< #line 178
<   tmp___0 = bio_alloc_bioset(gfp_mask, 1, drbd_md_io_bio_set);
< #line 178
<   return (tmp___0);
---
> #line 167
>   bio = bio_alloc_bioset(gfp_mask, 1, drbd_md_io_bio_set);
> #line 168
>   if ((unsigned long )bio == (unsigned long )((struct bio *)0)) {
> #line 169
>     return (0);
>   } else {
> 
>   }
> #line 170
>   return (bio);
38775,38776c40214,40215
< #line 210 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static int tl_init(struct drbd_conf *mdev ) 
---
> #line 202 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void tl_release(struct drbd_tconn *tconn , unsigned int barrier_nr , unsigned int set_size ) 
38778,38779c40217,40229
<   struct drbd_tl_epoch *b ;
<   void *tmp ;
---
>   struct drbd_request *r ;
>   struct drbd_request *req ;
>   int expect_epoch ;
>   int expect_size ;
>   struct list_head  const  *__mptr ;
>   unsigned int s ;
>   struct list_head  const  *__mptr___0 ;
>   struct list_head  const  *__mptr___1 ;
>   struct list_head  const  *__mptr___2 ;
>   struct list_head  const  *__mptr___3 ;
>   struct list_head  const  *__mptr___4 ;
>   union drbd_state val ;
>   union drbd_state mask ;
38781a40232,40246
> #line 206
>   req = 0;
> #line 207
>   expect_epoch = 0;
> #line 208
>   expect_size = 0;
> #line 210
>   spin_lock_irq(& tconn->req_lock);
> #line 214
>   __mptr = (struct list_head  const  *)tconn->transfer_log.next;
> #line 214
>   r = (struct drbd_request *)__mptr + 0xffffffffffffff98UL;
> #line 214
>   goto ldv_52236;
>   ldv_52235: 
38783,38785c40248
<   tmp = kmalloc(56UL, 208U);
< #line 215
<   b = (struct drbd_tl_epoch *)tmp;
---
>   s = r->rq_state;
38787c40250
<   if ((unsigned long )b == (unsigned long )((struct drbd_tl_epoch *)0)) {
---
>   if ((unsigned long )req == (unsigned long )((struct drbd_request *)0)) {
38789,38792c40252
<     return (0);
<   } else {
< 
<   }
---
>     if (((unsigned long )s & 2048UL) == 0UL) {
38794c40254,40257
<   INIT_LIST_HEAD(& b->requests);
---
>       goto ldv_52233;
>     } else {
> 
>     }
38796c40259
<   INIT_LIST_HEAD(& b->w.list);
---
>     if (((unsigned long )s & 1008UL) == 0UL) {
38798c40261,40264
<   b->next = 0;
---
>       goto ldv_52233;
>     } else {
> 
>     }
38800c40266
<   b->br_number = 4711U;
---
>     if (((unsigned long )s & 128UL) != 0UL) {
38802c40268,40271
<   b->n_writes = 0;
---
>       goto ldv_52233;
>     } else {
> 
>     }
38804c40273,40275
<   b->w.cb = 0;
---
>     req = r;
> #line 224
>     expect_epoch = (int )req->epoch;
38806,38808c40277,40278
<   mdev->oldest_tle = b;
< #line 226
<   mdev->newest_tle = b;
---
>     expect_size = expect_size + 1;
>   } else {
38810c40280
<   INIT_LIST_HEAD(& mdev->out_of_sequence_requests);
---
>     if (r->epoch != (unsigned int )expect_epoch) {
38812c40282,40287
<   INIT_LIST_HEAD(& mdev->barrier_acked_requests);
---
>       goto ldv_52234;
>     } else {
> 
>     }
> #line 229
>     if (((unsigned long )s & 2048UL) == 0UL) {
38814,38824c40289,40290
<   mdev->tl_hash = 0;
< #line 231
<   mdev->tl_hash_s = 0U;
< #line 233
<   return (1);
< }
< }
< #line 236 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void tl_cleanup(struct drbd_conf *mdev ) 
< { 
<   int tmp ;
---
>       goto ldv_52233;
>     } else {
38826,38832c40292,40305
<   {
< #line 238
<   if ((unsigned long )mdev->oldest_tle != (unsigned long )mdev->newest_tle) {
< #line 238
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->oldest_tle == mdev->newest_tle ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             238);
---
>     }
> #line 233
>     expect_size = expect_size + 1;
>   }
>   ldv_52233: 
> #line 214
>   __mptr___0 = (struct list_head  const  *)r->tl_requests.next;
> #line 214
>   r = (struct drbd_request *)__mptr___0 + 0xffffffffffffff98UL;
>   ldv_52236: ;
> #line 214
>   if ((unsigned long )(& r->tl_requests) != (unsigned long )(& tconn->transfer_log)) {
> #line 215
>     goto ldv_52235;
38835a40309,40311
>   ldv_52234: ;
> #line 238
>   if ((unsigned long )req == (unsigned long )((struct drbd_request *)0)) {
38837,38843c40313,40316
<   tmp = list_empty((struct list_head  const  *)(& mdev->out_of_sequence_requests));
< #line 239
<   if (tmp == 0) {
< #line 239
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( list_empty(&mdev->out_of_sequence_requests) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             239);
---
>     printk("\vd-con %s: BAD! BarrierAck #%u received, but no epoch in tl!?\n", tconn->name,
>            barrier_nr);
> #line 241
>     goto bail;
38847,38852d40319
< #line 240
<   kfree((void const   *)mdev->oldest_tle);
< #line 241
<   mdev->oldest_tle = 0;
< #line 242
<   kfree((void const   *)mdev->unused_spare_tle);
38854c40321
<   mdev->unused_spare_tle = 0;
---
>   if ((unsigned int )expect_epoch != barrier_nr) {
38856,38858c40323,40324
<   kfree((void const   *)mdev->tl_hash);
< #line 245
<   mdev->tl_hash = 0;
---
>     printk("\vd-con %s: BAD! BarrierAck #%u received, expected #%u!\n", tconn->name,
>            barrier_nr, expect_epoch);
38860,38868c40326,40327
<   mdev->tl_hash_s = 0U;
< #line 247
<   return;
< }
< }
< #line 256 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void _tl_add_barrier(struct drbd_conf *mdev , struct drbd_tl_epoch *new ) 
< { 
<   struct drbd_tl_epoch *newest_before ;
---
>     goto bail;
>   } else {
38870c40329,40346
<   {
---
>   }
> #line 249
>   if ((unsigned int )expect_size != set_size) {
> #line 250
>     printk("\vd-con %s: BAD! BarrierAck #%u received with n_writes=%u, expected n_writes=%u!\n",
>            tconn->name, barrier_nr, set_size, expect_size);
> #line 252
>     goto bail;
>   } else {
> 
>   }
> #line 259
>   __mptr___1 = (struct list_head  const  *)tconn->transfer_log.next;
> #line 259
>   req = (struct drbd_request *)__mptr___1 + 0xffffffffffffff98UL;
> #line 259
>   goto ldv_52244;
>   ldv_52243: ;
38872c40348
<   INIT_LIST_HEAD(& new->requests);
---
>   if (req->epoch == (unsigned int )expect_epoch) {
38874c40350,40366
<   INIT_LIST_HEAD(& new->w.list);
---
>     goto ldv_52242;
>   } else {
> 
>   }
> #line 259
>   __mptr___2 = (struct list_head  const  *)req->tl_requests.next;
> #line 259
>   req = (struct drbd_request *)__mptr___2 + 0xffffffffffffff98UL;
>   ldv_52244: ;
> #line 259
>   if ((unsigned long )(& req->tl_requests) != (unsigned long )(& tconn->transfer_log)) {
> #line 260
>     goto ldv_52243;
>   } else {
> 
>   }
>   ldv_52242: 
38876c40368,40373
<   new->w.cb = 0;
---
>   __mptr___3 = (struct list_head  const  *)req->tl_requests.next;
> #line 262
>   r = (struct drbd_request *)__mptr___3 + 0xffffffffffffff98UL;
> #line 262
>   goto ldv_52251;
>   ldv_52250: ;
38878c40375
<   new->next = 0;
---
>   if (req->epoch != (unsigned int )expect_epoch) {
38880,38890c40377,40393
<   new->n_writes = 0;
< #line 266
<   newest_before = mdev->newest_tle;
< #line 267
<   new->br_number = newest_before->br_number + 1U;
< #line 268
<   if ((unsigned long )mdev->newest_tle != (unsigned long )new) {
< #line 269
<     (mdev->newest_tle)->next = new;
< #line 270
<     mdev->newest_tle = new;
---
>     goto ldv_52249;
>   } else {
> 
>   }
> #line 265
>   _req_mod(req, BARRIER_ACKED);
> #line 262
>   req = r;
> #line 262
>   __mptr___4 = (struct list_head  const  *)r->tl_requests.next;
> #line 262
>   r = (struct drbd_request *)__mptr___4 + 0xffffffffffffff98UL;
>   ldv_52251: ;
> #line 262
>   if ((unsigned long )(& req->tl_requests) != (unsigned long )(& tconn->transfer_log)) {
> #line 263
>     goto ldv_52250;
38893a40397,40402
>   ldv_52249: 
> #line 267
>   spin_unlock_irq(& tconn->req_lock);
> #line 269
>   return;
>   bail: 
38894a40404,40415
>   spin_unlock_irq(& tconn->req_lock);
> #line 273
>   val.i = 0U;
> #line 273
>   val.ldv_40604.conn = 6U;
> #line 273
>   mask.i = 0U;
> #line 273
>   mask.ldv_40604.conn = 31U;
> #line 273
>   conn_request_state(tconn, mask, val, CS_HARD);
> #line 275
38898,38899c40419,40420
< #line 284 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void tl_release(struct drbd_conf *mdev , unsigned int barrier_nr , unsigned int set_size ) 
---
> #line 286 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void _tl_restart(struct drbd_tconn *tconn , enum drbd_req_event what ) 
38901,38904c40422
<   struct drbd_tl_epoch *b ;
<   struct drbd_tl_epoch *nob ;
<   struct list_head *le ;
<   struct list_head *tle ;
---
>   struct drbd_request *req ;
38907,38912c40425,40426
<   int tmp ;
<   int tmp___0 ;
<   int tmp___1 ;
<   int tmp___2 ;
<   union drbd_state val ;
<   union drbd_state mask ;
---
>   struct list_head  const  *__mptr___0 ;
>   struct list_head  const  *__mptr___1 ;
38914a40429,40439
> #line 290
>   __mptr = (struct list_head  const  *)tconn->transfer_log.next;
> #line 290
>   req = (struct drbd_request *)__mptr + 0xffffffffffffff98UL;
> #line 290
>   __mptr___0 = (struct list_head  const  *)req->tl_requests.next;
> #line 290
>   r = (struct drbd_request *)__mptr___0 + 0xffffffffffffff98UL;
> #line 290
>   goto ldv_52269;
>   ldv_52268: 
38916,38925c40441,40452
<   spin_lock_irq(& mdev->req_lock);
< #line 293
<   b = mdev->oldest_tle;
< #line 296
<   if ((unsigned long )b == (unsigned long )((struct drbd_tl_epoch *)0)) {
< #line 297
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "BAD! BarrierAck #%u received, but no epoch in tl!?\n",
<             barrier_nr);
< #line 299
<     goto bail;
---
>   _req_mod(req, what);
> #line 290
>   req = r;
> #line 290
>   __mptr___1 = (struct list_head  const  *)r->tl_requests.next;
> #line 290
>   r = (struct drbd_request *)__mptr___1 + 0xffffffffffffff98UL;
>   ldv_52269: ;
> #line 290
>   if ((unsigned long )(& req->tl_requests) != (unsigned long )(& tconn->transfer_log)) {
> #line 291
>     goto ldv_52268;
38929,38936d40455
< #line 301
<   if (b->br_number != barrier_nr) {
< #line 302
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "BAD! BarrierAck #%u received, expected #%u!\n",
<             barrier_nr, b->br_number);
< #line 304
<     goto bail;
<   } else {
38938,38946c40457,40463
<   }
< #line 306
<   if ((unsigned int )b->n_writes != set_size) {
< #line 307
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "BAD! BarrierAck #%u received with n_writes=%u, expected n_writes=%u!\n",
<             barrier_nr, set_size, b->n_writes);
< #line 309
<     goto bail;
<   } else {
---
> #line 295
>   return;
> }
> }
> #line 294 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void tl_restart(struct drbd_tconn *tconn , enum drbd_req_event what ) 
> { 
38948,38971d40464
<   }
< #line 313
<   le = b->requests.next;
< #line 313
<   tle = le->next;
< #line 313
<   goto ldv_51745;
<   ldv_51744: 
< #line 314
<   __mptr = (struct list_head  const  *)le;
< #line 314
<   r = (struct drbd_request *)__mptr + 0xffffffffffffffb8UL;
< #line 315
<   _req_mod(r, barrier_acked);
< #line 313
<   le = tle;
< #line 313
<   tle = le->next;
<   ldv_51745: ;
< #line 313
<   if ((unsigned long )(& b->requests) != (unsigned long )le) {
< #line 314
<     goto ldv_51744;
<   } else {
38973,38988c40466,40479
<   }
< #line 330
<   list_splice_init(& b->requests, & mdev->barrier_acked_requests);
< #line 332
<   nob = b->next;
< #line 333
<   tmp = drbd_test_and_clear_flag(mdev, CREATE_BARRIER);
< #line 333
<   if (tmp != 0) {
< #line 334
<     _tl_add_barrier(mdev, b);
< #line 335
<     if ((unsigned long )nob != (unsigned long )((struct drbd_tl_epoch *)0)) {
< #line 336
<       mdev->oldest_tle = nob;
<     } else {
---
>   {
> #line 296
>   spin_lock_irq(& tconn->req_lock);
> #line 297
>   _tl_restart(tconn, what);
> #line 298
>   spin_unlock_irq(& tconn->req_lock);
> #line 299
>   return;
> }
> }
> #line 309 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void tl_clear(struct drbd_tconn *tconn ) 
> { 
38990c40481,40518
<     }
---
> 
>   {
> #line 311
>   tl_restart(tconn, CONNECTION_LOST_WHILE_PENDING);
> #line 312
>   return;
> }
> }
> #line 318 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void tl_abort_disk_io(struct drbd_conf *mdev ) 
> { 
>   struct drbd_tconn *tconn ;
>   struct drbd_request *req ;
>   struct drbd_request *r ;
>   struct list_head  const  *__mptr ;
>   struct list_head  const  *__mptr___0 ;
>   struct list_head  const  *__mptr___1 ;
> 
>   {
> #line 320
>   tconn = mdev->tconn;
> #line 323
>   spin_lock_irq(& tconn->req_lock);
> #line 324
>   __mptr = (struct list_head  const  *)tconn->transfer_log.next;
> #line 324
>   req = (struct drbd_request *)__mptr + 0xffffffffffffff98UL;
> #line 324
>   __mptr___0 = (struct list_head  const  *)req->tl_requests.next;
> #line 324
>   r = (struct drbd_request *)__mptr___0 + 0xffffffffffffff98UL;
> #line 324
>   goto ldv_52292;
>   ldv_52291: ;
> #line 325
>   if (((unsigned long )req->rq_state & 1UL) == 0UL) {
> #line 326
>     goto ldv_52290;
38992,38998d40519
< #line 340
<     if ((unsigned long )nob == (unsigned long )((struct drbd_tl_epoch *)0)) {
< #line 340
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( nob != NULL ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<               340);
<     } else {
39000,39004d40520
<     }
< #line 341
<     mdev->oldest_tle = nob;
< #line 342
<     kfree((void const   *)b);
39006,39013c40522,40525
< #line 345
<   spin_unlock_irq(& mdev->req_lock);
< #line 346
<   tmp___0 = atomic_dec_and_test(& mdev->ap_pending_cnt);
< #line 346
<   if (tmp___0 != 0) {
< #line 346
<     __wake_up(& mdev->misc_wait, 3U, 1, 0);
---
> #line 327
>   if ((unsigned long )req->w.ldv_50388.mdev != (unsigned long )mdev) {
> #line 328
>     goto ldv_52290;
39017,39025c40529,40542
< #line 346
<   tmp___2 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 346
<   if (tmp___2 < 0) {
< #line 346
<     tmp___1 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 346
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: ap_pending_cnt = %d < 0 !\n",
<             "tl_release", 346, tmp___1);
---
> #line 329
>   _req_mod(req, ABORT_DISK_IO);
>   ldv_52290: 
> #line 324
>   req = r;
> #line 324
>   __mptr___1 = (struct list_head  const  *)r->tl_requests.next;
> #line 324
>   r = (struct drbd_request *)__mptr___1 + 0xffffffffffffff98UL;
>   ldv_52292: ;
> #line 324
>   if ((unsigned long )(& req->tl_requests) != (unsigned long )(& tconn->transfer_log)) {
> #line 325
>     goto ldv_52291;
39029,39044c40546,40548
< #line 348
<   return;
<   bail: 
< #line 351
<   spin_unlock_irq(& mdev->req_lock);
< #line 352
<   val.i = 0U;
< #line 352
<   val.ldv_40583.conn = 6U;
< #line 352
<   mask.i = 0U;
< #line 352
<   mask.ldv_40583.conn = 31U;
< #line 352
<   drbd_force_state(mdev, mask, val);
< #line 354
---
> #line 331
>   spin_unlock_irq(& tconn->req_lock);
> #line 332
39048,39049c40552,40553
< #line 364 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void _tl_restart(struct drbd_conf *mdev , enum drbd_req_event what ) 
---
> #line 334 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int drbd_thread_setup(void *arg ) 
39051,39065c40555,40561
<   struct drbd_tl_epoch *b ;
<   struct drbd_tl_epoch *tmp ;
<   struct drbd_tl_epoch **pn ;
<   struct list_head *le ;
<   struct list_head *tle ;
<   struct list_head carry_reads ;
<   struct drbd_request *req ;
<   int rv ;
<   int n_writes ;
<   int n_reads ;
<   struct list_head  const  *__mptr ;
<   int tmp___0 ;
<   int tmp___1 ;
<   int tmp___2 ;
<   struct list_head  const  *__mptr___0 ;
---
>   struct drbd_thread *thi ;
>   struct drbd_tconn *tconn ;
>   unsigned long flags ;
>   int retval ;
>   struct task_struct *tmp ;
>   raw_spinlock_t *tmp___0 ;
>   struct task_struct *tmp___1 ;
39068,39069c40564,40601
< #line 371
<   b = mdev->oldest_tle;
---
> #line 336
>   thi = (struct drbd_thread *)arg;
> #line 337
>   tconn = thi->tconn;
> #line 341
>   tmp = get_current();
> #line 341
>   snprintf((char *)(& tmp->comm), 16UL, "drbd_%c_%s", (int )thi->name[0], (thi->tconn)->name);
>   restart: 
> #line 345
>   retval = (*(thi->function))(thi);
> #line 347
>   tmp___0 = spinlock_check(& thi->t_lock);
> #line 347
>   flags = _raw_spin_lock_irqsave(tmp___0);
> #line 359
>   if ((unsigned int )thi->t_state == 3U) {
> #line 360
>     printk("\016d-con %s: Restarting %s thread\n", tconn->name, (char *)(& thi->name));
> #line 361
>     thi->t_state = RUNNING;
> #line 362
>     spin_unlock_irqrestore(& thi->t_lock, flags);
> #line 363
>     goto restart;
>   } else {
> 
>   }
> #line 366
>   thi->task = 0;
> #line 367
>   thi->t_state = NONE;
> #line 368
>   __asm__  volatile   ("mfence": : : "memory");
> #line 369
>   complete_all(& thi->stop);
> #line 370
>   spin_unlock_irqrestore(& thi->t_lock, flags);
39071,39078c40603,40605
<   pn = & mdev->oldest_tle;
< #line 373
<   goto ldv_51780;
<   ldv_51779: 
< #line 374
<   n_writes = 0;
< #line 375
<   n_reads = 0;
---
>   tmp___1 = get_current();
> #line 372
>   printk("\016d-con %s: Terminating %s\n", tconn->name, (char *)(& tmp___1->comm));
39080,39102c40607
<   INIT_LIST_HEAD(& carry_reads);
< #line 377
<   le = b->requests.next;
< #line 377
<   tle = le->next;
< #line 377
<   goto ldv_51772;
<   ldv_51771: 
< #line 378
<   __mptr = (struct list_head  const  *)le;
< #line 378
<   req = (struct drbd_request *)__mptr + 0xffffffffffffffb8UL;
< #line 379
<   rv = _req_mod(req, what);
< #line 381
<   n_writes = (rv & 1) + n_writes;
< #line 382
<   n_reads = ((rv & 2) >> 1) + n_reads;
< #line 377
<   le = tle;
< #line 377
<   tle = le->next;
<   ldv_51772: ;
---
>   kref_put(& tconn->kref, & conn_destroy);
39104c40609
<   if ((unsigned long )(& b->requests) != (unsigned long )le) {
---
>   ldv_module_put_3(& __this_module);
39106,39107c40611,40618
<     goto ldv_51771;
<   } else {
---
>   return (retval);
> }
> }
> #line 381 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static void drbd_thread_init(struct drbd_tconn *tconn , struct drbd_thread *thi ,
>                              int (*func)(struct drbd_thread * ) , char *name ) 
> { 
>   struct lock_class_key __key ;
39109c40620,40622
<   }
---
>   {
> #line 384
>   spinlock_check(& thi->t_lock);
39111c40624,40626
<   tmp = b->next;
---
>   __raw_spin_lock_init(& thi->t_lock.ldv_6135.rlock, "&(&thi->t_lock)->rlock", & __key);
> #line 385
>   thi->task = 0;
39113c40628
<   if (n_writes != 0) {
---
>   thi->t_state = NONE;
39115c40630
<     if ((unsigned int )what == 24U) {
---
>   thi->function = func;
39117c40632
<       b->n_writes = n_writes;
---
>   thi->tconn = tconn;
39119,39121c40634
<       if ((unsigned long )b->w.cb == (unsigned long )((int (*)(struct drbd_conf * ,
<                                                                struct drbd_work * ,
<                                                                int  ))0)) {
---
>   strncpy((char *)(& thi->name), (char const   *)name, 9UL);
39123,39133c40636,40654
<         b->w.cb = & w_send_barrier;
< #line 391
<         inc_ap_pending(mdev);
< #line 392
<         drbd_set_flag(mdev, CREATE_BARRIER);
<       } else {
< 
<       }
< #line 395
<       drbd_queue_work(& mdev->data.work, & b->w);
<     } else {
---
>   return;
> }
> }
> #line 392 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_thread_start(struct drbd_thread *thi ) 
> { 
>   struct drbd_tconn *tconn ;
>   struct task_struct *nt ;
>   unsigned long flags ;
>   raw_spinlock_t *tmp ;
>   struct task_struct *tmp___0 ;
>   struct task_struct *tmp___1 ;
>   bool tmp___2 ;
>   int tmp___3 ;
>   struct task_struct *tmp___4 ;
>   long tmp___5 ;
>   raw_spinlock_t *tmp___6 ;
>   struct task_struct *tmp___7 ;
>   struct task_struct *tmp___8 ;
39135,39140c40656,40658
<     }
< #line 397
<     pn = & b->next;
<   } else {
< #line 399
<     if (n_reads != 0) {
---
>   {
> #line 394
>   tconn = thi->tconn;
39142,39147c40660,40672
<       list_add(& carry_reads, & b->requests);
<     } else {
< 
<     }
< #line 403
<     list_del(& b->requests);
---
>   tmp = spinlock_check(& thi->t_lock);
> #line 400
>   flags = _raw_spin_lock_irqsave(tmp);
> #line 402
>   switch ((unsigned int )thi->t_state) {
>   case 0U: 
> #line 404
>   tmp___0 = get_current();
> #line 404
>   tmp___1 = get_current();
> #line 404
>   printk("\016d-con %s: Starting %s thread (from %s [%d])\n", tconn->name, (char *)(& thi->name),
>          (char *)(& tmp___1->comm), tmp___0->pid);
39149,39166c40674,40684
<     if ((unsigned long )b->w.cb != (unsigned long )((int (*)(struct drbd_conf * ,
<                                                              struct drbd_work * ,
<                                                              int  ))0)) {
< #line 409
<       tmp___0 = atomic_dec_and_test(& mdev->ap_pending_cnt);
< #line 409
<       if (tmp___0 != 0) {
< #line 409
<         __wake_up(& mdev->misc_wait, 3U, 1, 0);
<       } else {
< 
<       }
< #line 409
<       tmp___2 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 409
<       if (tmp___2 < 0) {
< #line 409
<         tmp___1 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
---
>   tmp___2 = ldv_try_module_get_4(& __this_module);
> #line 408
>   if (tmp___2) {
> #line 408
>     tmp___3 = 0;
>   } else {
> #line 408
>     tmp___3 = 1;
>   }
> #line 408
>   if (tmp___3) {
39168,39175c40686,40688
<         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "in %s:%d: ap_pending_cnt = %d < 0 !\n",
<                 "_tl_restart", 409, tmp___1);
<       } else {
< 
<       }
<     } else {
< 
<     }
---
>     printk("\vd-con %s: Failed to get module reference in drbd_thread_start\n", tconn->name);
> #line 410
>     spin_unlock_irqrestore(& thi->t_lock, flags);
39177,39184c40690,40691
<     if ((unsigned long )mdev->newest_tle == (unsigned long )b) {
< #line 413
<       if ((unsigned long )tmp != (unsigned long )((struct drbd_tl_epoch *)0)) {
< #line 413
<         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( tmp == NULL ) in %s:%d\n",
<                 (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<                 413);
<       } else {
---
>     return (0);
>   } else {
39186c40693
<       }
---
>   }
39188,39190c40695
<       INIT_LIST_HEAD(& b->requests);
< #line 415
<       list_splice((struct list_head  const  *)(& carry_reads), & b->requests);
---
>   kref_get(& (thi->tconn)->kref);
39192c40697
<       INIT_LIST_HEAD(& b->w.list);
---
>   init_completion(& thi->stop);
39194c40699
<       b->w.cb = 0;
---
>   thi->reset_cpu_mask = 1;
39196c40701
<       b->br_number = random32();
---
>   thi->t_state = RUNNING;
39198,39200c40703,40707
<       b->n_writes = 0;
< #line 421
<       *pn = b;
---
>   spin_unlock_irqrestore(& thi->t_lock, flags);
> #line 420
>   tmp___4 = get_current();
> #line 420
>   flush_signals(tmp___4);
39202,39207c40709,40710
<       goto ldv_51778;
<     } else {
< 
<     }
< #line 424
<     *pn = tmp;
---
>   nt = kthread_create_on_node(& drbd_thread_setup, (void *)thi, -1, "drbd_%c_%s",
>                               (int )thi->name[0], (thi->tconn)->name);
39209,39212c40712,40716
<     kfree((void const   *)b);
<   }
< #line 427
<   b = tmp;
---
>   tmp___5 = IS_ERR((void const   *)nt);
> #line 425
>   if (tmp___5 != 0L) {
> #line 426
>     printk("\vd-con %s: Couldn\'t start thread\n", tconn->name);
39214,39219c40718,40722
<   list_splice((struct list_head  const  *)(& carry_reads), & b->requests);
<   ldv_51780: ;
< #line 373
<   if ((unsigned long )b != (unsigned long )((struct drbd_tl_epoch *)0)) {
< #line 374
<     goto ldv_51779;
---
>     kref_put(& tconn->kref, & conn_destroy);
> #line 429
>     ldv_module_put_5(& __this_module);
> #line 430
>     return (0);
39223,39227c40726,40731
<   ldv_51778: 
< #line 434
<   le = mdev->barrier_acked_requests.next;
< #line 434
<   tle = le->next;
---
> #line 432
>   tmp___6 = spinlock_check(& thi->t_lock);
> #line 432
>   flags = _raw_spin_lock_irqsave(tmp___6);
> #line 433
>   thi->task = nt;
39229,39232c40733
<   goto ldv_51784;
<   ldv_51783: 
< #line 435
<   __mptr___0 = (struct list_head  const  *)le;
---
>   thi->t_state = RUNNING;
39234c40735
<   req = (struct drbd_request *)__mptr___0 + 0xffffffffffffffb8UL;
---
>   spin_unlock_irqrestore(& thi->t_lock, flags);
39236,39249c40737,40740
<   _req_mod(req, what);
< #line 434
<   le = tle;
< #line 434
<   tle = le->next;
<   ldv_51784: ;
< #line 434
<   if ((unsigned long )(& mdev->barrier_acked_requests) != (unsigned long )le) {
< #line 435
<     goto ldv_51783;
<   } else {
< 
<   }
< 
---
>   wake_up_process(nt);
> #line 437
>   goto ldv_52328;
>   case 2U: 
39251,39267c40742,40760
<   return;
< }
< }
< #line 449 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void tl_clear(struct drbd_conf *mdev ) 
< { 
< 
< 
<   {
< #line 451
<   spin_lock_irq(& mdev->req_lock);
< #line 452
<   _tl_clear(mdev);
< #line 453
<   spin_unlock_irq(& mdev->req_lock);
< #line 454
<   return;
---
>   thi->t_state = RESTARTING;
> #line 440
>   tmp___7 = get_current();
> #line 440
>   tmp___8 = get_current();
> #line 440
>   printk("\016d-con %s: Restarting %s thread (from %s [%d])\n", tconn->name, (char *)(& thi->name),
>          (char *)(& tmp___8->comm), tmp___7->pid);
>   case 1U: ;
>   case 3U: ;
>   default: 
> #line 446
>   spin_unlock_irqrestore(& thi->t_lock, flags);
> #line 447
>   goto ldv_52328;
>   }
>   ldv_52328: ;
> #line 450
>   return (1);
39270,39271c40763,40764
< #line 456 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void _tl_clear(struct drbd_conf *mdev ) 
---
> #line 454 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void _drbd_thread_stop(struct drbd_thread *thi , int restart , int wait ) 
39273,39277c40766,40769
<   struct list_head *le ;
<   struct list_head *tle ;
<   struct drbd_request *r ;
<   int tmp ;
<   struct list_head  const  *__mptr ;
---
>   unsigned long flags ;
>   enum drbd_thread_state ns ;
>   raw_spinlock_t *tmp ;
>   struct task_struct *tmp___0 ;
39279a40772,40773
> #line 458
>   ns = restart != 0 ? RESTARTING : EXITING;
39281,39285c40775,40779
<   _tl_restart(mdev, connection_lost_while_pending);
< #line 464
<   tmp = list_empty((struct list_head  const  *)(& mdev->out_of_sequence_requests));
< #line 464
<   if (tmp == 0) {
---
>   tmp = spinlock_check(& thi->t_lock);
> #line 461
>   flags = _raw_spin_lock_irqsave(tmp);
> #line 463
>   if ((unsigned int )thi->t_state == 0U) {
39287,39290c40781,40786
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( list_empty(&mdev->out_of_sequence_requests) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             464);
<   } else {
---
>     spin_unlock_irqrestore(& thi->t_lock, flags);
> #line 465
>     if (restart != 0) {
> #line 466
>       drbd_thread_start(thi);
>     } else {
39292,39310c40788
<   }
< #line 467
<   le = mdev->out_of_sequence_requests.next;
< #line 467
<   tle = le->next;
< #line 467
<   goto ldv_51798;
<   ldv_51797: 
< #line 468
<   __mptr = (struct list_head  const  *)le;
< #line 468
<   r = (struct drbd_request *)__mptr + 0xffffffffffffffb8UL;
< #line 471
<   _req_mod(r, connection_lost_while_pending);
< #line 467
<   le = tle;
< #line 467
<   tle = le->next;
<   ldv_51798: ;
---
>     }
39312,39314c40790
<   if ((unsigned long )(& mdev->out_of_sequence_requests) != (unsigned long )le) {
< #line 468
<     goto ldv_51797;
---
>     return;
39318,39319c40794,40806
< #line 475
<   drbd_clear_flag(mdev, CREATE_BARRIER);
---
> #line 470
>   if ((unsigned int )thi->t_state != (unsigned int )ns) {
> #line 471
>     if ((unsigned long )thi->task == (unsigned long )((struct task_struct *)0)) {
> #line 472
>       spin_unlock_irqrestore(& thi->t_lock, flags);
> #line 473
>       return;
>     } else {
> 
>     }
> #line 476
>     thi->t_state = ns;
39321c40808
<   memset((void *)mdev->app_reads_hash, 0, 120UL);
---
>     __asm__  volatile   ("mfence": : : "memory");
39323,39328c40810,40817
<   return;
< }
< }
< #line 481 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void tl_restart(struct drbd_conf *mdev , enum drbd_req_event what ) 
< { 
---
>     init_completion(& thi->stop);
> #line 479
>     tmp___0 = get_current();
> #line 479
>     if ((unsigned long )thi->task != (unsigned long )tmp___0) {
> #line 480
>       force_sig(1, thi->task);
>     } else {
39329a40819,40820
>     }
>   } else {
39331c40822
<   {
---
>   }
39333,39335c40824
<   spin_lock_irq(& mdev->req_lock);
< #line 484
<   _tl_restart(mdev, what);
---
>   spin_unlock_irqrestore(& thi->t_lock, flags);
39337c40826
<   spin_unlock_irq(& mdev->req_lock);
---
>   if (wait != 0) {
39338a40828,40832
>     wait_for_completion(& thi->stop);
>   } else {
> 
>   }
> #line 487
39342,39343c40836,40837
< #line 492 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void tl_abort_disk_io(struct drbd_conf *mdev ) 
---
> #line 489 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static struct drbd_thread *drbd_task_to_thread(struct drbd_tconn *tconn , struct task_struct *task ) 
39345,39350c40839
<   struct drbd_tl_epoch *b ;
<   struct list_head *le ;
<   struct list_head *tle ;
<   struct drbd_request *req ;
<   struct list_head  const  *__mptr ;
<   struct list_head  const  *__mptr___0 ;
---
>   struct drbd_thread *thi ;
39353,39375c40842,40852
< #line 498
<   spin_lock_irq(& mdev->req_lock);
< #line 499
<   b = mdev->oldest_tle;
< #line 500
<   goto ldv_51818;
<   ldv_51817: 
< #line 501
<   le = b->requests.next;
< #line 501
<   tle = le->next;
< #line 501
<   goto ldv_51815;
<   ldv_51814: 
< #line 502
<   __mptr = (struct list_head  const  *)le;
< #line 502
<   req = (struct drbd_request *)__mptr + 0xffffffffffffffb8UL;
< #line 503
<   if ((req->rq_state & 1UL) == 0UL) {
< #line 504
<     goto ldv_51813;
<   } else {
---
> #line 491
>   thi = (unsigned long )tconn->receiver.task == (unsigned long )task ? & tconn->receiver : ((unsigned long )tconn->asender.task == (unsigned long )task ? & tconn->asender : ((unsigned long )tconn->worker.task == (unsigned long )task ? & tconn->worker : 0));
> #line 496
>   return (thi);
> }
> }
> #line 499 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> char *drbd_task_to_thread_name(struct drbd_tconn *tconn , struct task_struct *task ) 
> { 
>   struct drbd_thread *thi ;
>   struct drbd_thread *tmp ;
39377,39382c40854
<   }
< #line 505
<   _req_mod(req, abort_disk_io);
<   ldv_51813: 
< #line 501
<   le = tle;
---
>   {
39384,39385c40856
<   tle = le->next;
<   ldv_51815: ;
---
>   tmp = drbd_task_to_thread(tconn, task);
39387c40858
<   if ((unsigned long )(& b->requests) != (unsigned long )le) {
---
>   thi = tmp;
39389,39400c40860,40870
<     goto ldv_51814;
<   } else {
< 
<   }
< #line 507
<   b = b->next;
<   ldv_51818: ;
< #line 500
<   if ((unsigned long )b != (unsigned long )((struct drbd_tl_epoch *)0)) {
< #line 501
<     goto ldv_51817;
<   } else {
---
>   return ((unsigned long )thi != (unsigned long )((struct drbd_thread *)0) ? (char *)(& thi->name) : (char *)(& task->comm));
> }
> }
> #line 505 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int conn_lowest_minor(struct drbd_tconn *tconn ) 
> { 
>   struct drbd_conf *mdev ;
>   int vnr ;
>   int m ;
>   void *tmp ;
>   unsigned int tmp___0 ;
39402,39406c40872,40874
<   }
< #line 510
<   le = mdev->barrier_acked_requests.next;
< #line 510
<   tle = le->next;
---
>   {
> #line 508
>   vnr = 0;
39408,39409c40876
<   goto ldv_51824;
<   ldv_51823: 
---
>   rcu_read_lock();
39411c40878
<   __mptr___0 = (struct list_head  const  *)le;
---
>   tmp = idr_get_next(& tconn->volumes, & vnr);
39413c40880,40887
<   req = (struct drbd_request *)__mptr___0 + 0xffffffffffffffb8UL;
---
>   mdev = (struct drbd_conf *)tmp;
> #line 512
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 512
>     tmp___0 = mdev_to_minor(mdev);
> #line 512
>     m = (int )tmp___0;
>   } else {
39415c40889,40890
<   if ((req->rq_state & 1UL) == 0UL) {
---
>     m = -1;
>   }
39417c40892,40914
<     goto ldv_51822;
---
>   rcu_read_unlock();
> #line 515
>   return (m);
> }
> }
> #line 526 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void drbd_calc_cpu_mask(struct drbd_tconn *tconn ) 
> { 
>   int ord ;
>   int cpu ;
>   unsigned int tmp ;
>   int tmp___0 ;
>   unsigned int tmp___1 ;
>   int tmp___2 ;
>   unsigned int tmp___3 ;
> 
>   {
> #line 531
>   tmp = cpumask_weight((struct cpumask  const  *)tconn->cpu_mask);
> #line 531
>   if (tmp != 0U) {
> #line 532
>     return;
39421,39432c40918,40938
< #line 514
<   _req_mod(req, abort_disk_io);
<   ldv_51822: 
< #line 510
<   le = tle;
< #line 510
<   tle = le->next;
<   ldv_51824: ;
< #line 510
<   if ((unsigned long )(& mdev->barrier_acked_requests) != (unsigned long )le) {
< #line 511
<     goto ldv_51823;
---
> #line 534
>   tmp___0 = conn_lowest_minor(tconn);
> #line 534
>   tmp___1 = cpumask_weight(cpu_online_mask);
> #line 534
>   ord = (int )((unsigned int )tmp___0 % tmp___1);
> #line 535
>   cpu = -1;
> #line 535
>   goto ldv_52365;
>   ldv_52364: 
> #line 536
>   tmp___2 = ord;
> #line 536
>   ord = ord - 1;
> #line 536
>   if (tmp___2 == 0) {
> #line 537
>     cpumask_set_cpu((unsigned int )cpu, tconn->cpu_mask);
> #line 538
>     return;
39436,39438c40942,40956
< #line 517
<   spin_unlock_irq(& mdev->req_lock);
< #line 518
---
>   ldv_52365: 
> #line 535
>   tmp___3 = cpumask_next(cpu, cpu_online_mask);
> #line 535
>   cpu = (int )tmp___3;
> #line 535
>   if (cpu < nr_cpu_ids) {
> #line 536
>     goto ldv_52364;
>   } else {
> 
>   }
> #line 542
>   cpumask_setall(tconn->cpu_mask);
> #line 543
39442,39443c40960,40961
< #line 526 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static int cl_wide_st_chg(struct drbd_conf *mdev , union drbd_state os , union drbd_state ns ) 
---
> #line 553 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void drbd_thread_current_set_cpu(struct drbd_thread *thi ) 
39445c40963,40964
< 
---
>   struct task_struct *p ;
>   struct task_struct *tmp ;
39448,39449c40967,40983
< #line 529
<   return (((((int )os.ldv_40583.conn > 9 && (int )ns.ldv_40583.conn > 9) && (((((unsigned int )*((unsigned char *)(& os) + 0UL) != 1U && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U) || ((unsigned int )*((unsigned short *)(& os) + 0UL) != 192U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 192U)) || ((unsigned int )*((unsigned short *)(& os) + 0UL) != 176U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 176U)) || ((unsigned int )*((unsigned char *)(& os) + 1UL) != 4U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 4U))) || ((int )os.ldv_40583.conn > 9 && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 16U)) || ((unsigned int )*((unsigned short *)(& os) + 0UL) == 160U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U));
---
> #line 555
>   tmp = get_current();
> #line 555
>   p = tmp;
> #line 557
>   if (thi->reset_cpu_mask == 0) {
> #line 558
>     return;
>   } else {
> 
>   }
> #line 559
>   thi->reset_cpu_mask = 0;
> #line 560
>   set_cpus_allowed_ptr(p, (struct cpumask  const  *)(thi->tconn)->cpu_mask);
> #line 561
>   return;
39452,39454c40986,40987
< #line 539 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< enum drbd_state_rv drbd_change_state(struct drbd_conf *mdev , enum chg_state_flags f ,
<                                      union drbd_state mask , union drbd_state val ) 
---
> #line 571 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> unsigned int drbd_header_size(struct drbd_tconn *tconn ) 
39456,39460c40989
<   unsigned long flags ;
<   union drbd_state os ;
<   union drbd_state ns ;
<   enum drbd_state_rv rv ;
<   raw_spinlock_t *tmp ;
---
> 
39463,39478c40992,40999
< #line 546
<   tmp = spinlock_check(& mdev->req_lock);
< #line 546
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 547
<   os = mdev->state;
< #line 548
<   ns.i = (os.i & ~ mask.i) | val.i;
< #line 549
<   rv = _drbd_set_state(mdev, ns, f, 0);
< #line 550
<   ns = mdev->state;
< #line 551
<   spin_unlock_irqrestore(& mdev->req_lock, flags);
< #line 553
<   return (rv);
---
> #line 573
>   if (tconn->agreed_pro_version > 99) {
> #line 575
>     return (16U);
>   } else {
> #line 580
>     return (8U);
>   }
39481,39482c41002,41004
< #line 562 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void drbd_force_state(struct drbd_conf *mdev , union drbd_state mask , union drbd_state val ) 
---
> #line 584 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static unsigned int prepare_header80(struct p_header80 *h , enum drbd_packet cmd ,
>                                      int size ) 
39484c41006,41007
< 
---
>   __u16 tmp ;
>   __u16 tmp___0 ;
39487,39490c41010,41021
< #line 565
<   drbd_change_state(mdev, CS_HARD, mask, val);
< #line 566
<   return;
---
> #line 586
>   h->magic = 1728214147U;
> #line 587
>   tmp = __fswab16((int )((__u16 )cmd));
> #line 587
>   h->command = tmp;
> #line 588
>   tmp___0 = __fswab16((int )((__u16 )size));
> #line 588
>   h->length = tmp___0;
> #line 589
>   return (8U);
39493,39505c41024,41026
< #line 568
< static enum drbd_state_rv is_valid_state(struct drbd_conf *mdev , union drbd_state ns ) ;
< #line 569
< static enum drbd_state_rv is_valid_state_transition(struct drbd_conf *mdev , union drbd_state ns ,
<                                                     union drbd_state os ) ;
< #line 580
< static union drbd_state sanitize_state(struct drbd_conf *mdev , union drbd_state os ,
<                                        union drbd_state ns , enum sanitize_state_warnings *warn ) ;
< #line 582
< int drbd_send_state_req(struct drbd_conf *mdev , union drbd_state mask , union drbd_state val ) ;
< #line 586 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static enum drbd_state_rv _req_st_cond(struct drbd_conf *mdev , union drbd_state mask ,
<                                        union drbd_state val ) 
---
> #line 592 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static unsigned int prepare_header95(struct p_header95 *h , enum drbd_packet cmd ,
>                                      int size ) 
39507,39514c41028,41029
<   union drbd_state os ;
<   union drbd_state ns ;
<   unsigned long flags ;
<   enum drbd_state_rv rv ;
<   int tmp ;
<   int tmp___0 ;
<   raw_spinlock_t *tmp___1 ;
<   int tmp___2 ;
---
>   __u16 tmp ;
>   __u32 tmp___0 ;
39517,39520d41031
< #line 593
<   tmp = drbd_test_and_clear_flag(mdev, CL_ST_CHG_SUCCESS);
< #line 593
<   if (tmp != 0) {
39522,39525c41033,41037
<     return (SS_CW_SUCCESS);
<   } else {
< 
<   }
---
>   h->magic = 23171U;
> #line 595
>   tmp = __fswab16((int )((__u16 )cmd));
> #line 595
>   h->command = tmp;
39527c41039
<   tmp___0 = drbd_test_and_clear_flag(mdev, CL_ST_CHG_FAIL);
---
>   tmp___0 = __fswab32((__u32 )size);
39529c41041
<   if (tmp___0 != 0) {
---
>   h->length = tmp___0;
39531,39532c41043,41052
<     return (SS_CW_FAILED_BY_PEER);
<   } else {
---
>   return (8U);
> }
> }
> #line 600 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static unsigned int prepare_header100(struct p_header100 *h , enum drbd_packet cmd ,
>                                       int size , int vnr ) 
> { 
>   __u16 tmp ;
>   __u16 tmp___0 ;
>   __u32 tmp___1 ;
39534,39544c41054
<   }
< #line 599
<   rv = SS_UNKNOWN_ERROR;
< #line 600
<   tmp___1 = spinlock_check(& mdev->req_lock);
< #line 600
<   flags = _raw_spin_lock_irqsave(tmp___1);
< #line 601
<   os = mdev->state;
< #line 602
<   ns.i = (os.i & ~ mask.i) | val.i;
---
>   {
39546c41056,41060
<   ns = sanitize_state(mdev, os, ns, 0);
---
>   h->magic = 552345734U;
> #line 604
>   tmp = __fswab16((int )((__u16 )vnr));
> #line 604
>   h->volume = tmp;
39548c41062
<   tmp___2 = cl_wide_st_chg(mdev, os, ns);
---
>   tmp___0 = __fswab16((int )((__u16 )cmd));
39550c41064
<   if (tmp___2 == 0) {
---
>   h->command = tmp___0;
39552,39555c41066,41068
<     rv = SS_CW_NO_NEED;
<   } else {
< 
<   }
---
>   tmp___1 = __fswab32((__u32 )size);
> #line 606
>   h->length = tmp___1;
39557c41070
<   if ((int )rv == 0) {
---
>   h->pad = 0U;
39559,39568c41072,41081
<     rv = is_valid_state(mdev, ns);
< #line 609
<     if ((int )rv == 1) {
< #line 610
<       rv = is_valid_state_transition(mdev, ns, os);
< #line 611
<       if ((int )rv == 1) {
< #line 612
<         rv = SS_UNKNOWN_ERROR;
<       } else {
---
>   return (16U);
> }
> }
> #line 611 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static unsigned int prepare_header(struct drbd_tconn *tconn , int vnr , void *buffer ,
>                                    enum drbd_packet cmd , int size ) 
> { 
>   unsigned int tmp ;
>   unsigned int tmp___0 ;
>   unsigned int tmp___1 ;
39570,39571c41083,41108
<       }
<     } else {
---
>   {
> #line 614
>   if (tconn->agreed_pro_version > 99) {
> #line 615
>     tmp = prepare_header100((struct p_header100 *)buffer, cmd, size, vnr);
> #line 615
>     return (tmp);
>   } else
> #line 616
>   if (tconn->agreed_pro_version > 94 && (unsigned int )size > 32768U) {
> #line 618
>     tmp___0 = prepare_header95((struct p_header95 *)buffer, cmd, size);
> #line 618
>     return (tmp___0);
>   } else {
> #line 620
>     tmp___1 = prepare_header80((struct p_header80 *)buffer, cmd, size);
> #line 620
>     return (tmp___1);
>   }
> }
> }
> #line 623 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static void *__conn_prepare_command(struct drbd_tconn *tconn , struct drbd_socket *sock ) 
> { 
>   unsigned int tmp ;
39573c41110,41114
<     }
---
>   {
> #line 626
>   if ((unsigned long )sock->socket == (unsigned long )((struct socket *)0)) {
> #line 627
>     return (0);
39577,39580c41118,41121
< #line 615
<   spin_unlock_irqrestore(& mdev->req_lock, flags);
< #line 617
<   return (rv);
---
> #line 628
>   tmp = drbd_header_size(tconn);
> #line 628
>   return (sock->sbuf + (unsigned long )tmp);
39583,39585c41124,41125
< #line 631 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static enum drbd_state_rv drbd_req_state(struct drbd_conf *mdev , union drbd_state mask ,
<                                          union drbd_state val , enum chg_state_flags f ) 
---
> #line 631 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void *conn_prepare_command(struct drbd_tconn *tconn , struct drbd_socket *sock ) 
39587,39598c41127
<   struct completion done ;
<   unsigned long flags ;
<   union drbd_state os ;
<   union drbd_state ns ;
<   enum drbd_state_rv rv ;
<   raw_spinlock_t *tmp ;
<   int tmp___0 ;
<   wait_queue_t __wait ;
<   struct task_struct *tmp___1 ;
<   raw_spinlock_t *tmp___2 ;
<   int tmp___3 ;
<   struct task_struct *tmp___4 ;
---
>   void *p ;
39601,39606c41130,41137
< #line 639
<   init_completion(& done);
< #line 641
<   if (((unsigned int )f & 8U) != 0U) {
< #line 642
<     mutex_lock_nested(& mdev->state_mutex, 0U);
---
> #line 635
>   mutex_lock_nested(& sock->mutex, 0U);
> #line 636
>   p = __conn_prepare_command(tconn, sock);
> #line 637
>   if ((unsigned long )p == (unsigned long )((void *)0)) {
> #line 638
>     mutex_unlock(& sock->mutex);
39610,39641c41141,41148
< #line 644
<   tmp = spinlock_check(& mdev->req_lock);
< #line 644
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 645
<   os = mdev->state;
< #line 646
<   ns.i = (os.i & ~ mask.i) | val.i;
< #line 647
<   ns = sanitize_state(mdev, os, ns, 0);
< #line 649
<   tmp___3 = cl_wide_st_chg(mdev, os, ns);
< #line 649
<   if (tmp___3 != 0) {
< #line 650
<     rv = is_valid_state(mdev, ns);
< #line 651
<     if ((int )rv == 1) {
< #line 652
<       rv = is_valid_state_transition(mdev, ns, os);
<     } else {
< 
<     }
< #line 653
<     spin_unlock_irqrestore(& mdev->req_lock, flags);
< #line 655
<     if ((int )rv <= 0) {
< #line 656
<       if (((unsigned int )f & 2U) != 0U) {
< #line 657
<         print_st_err(mdev, os, ns, (int )rv);
<       } else {
---
> #line 640
>   return (p);
> }
> }
> #line 643 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void *drbd_prepare_command(struct drbd_conf *mdev , struct drbd_socket *sock ) 
> { 
>   void *tmp ;
39643,39646c41150,41164
<       }
< #line 658
<       goto abort;
<     } else {
---
>   {
> #line 645
>   tmp = conn_prepare_command(mdev->tconn, sock);
> #line 645
>   return (tmp);
> }
> }
> #line 648 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int __send_command(struct drbd_tconn *tconn , int vnr , struct drbd_socket *sock ,
>                           enum drbd_packet cmd , unsigned int header_size , void *data ,
>                           unsigned int size ) 
> { 
>   int msg_flags ;
>   int err ;
>   unsigned int tmp ;
39648,39654c41166
<     }
< #line 661
<     drbd_state_lock___0(mdev);
< #line 662
<     tmp___0 = drbd_send_state_req(mdev, mask, val);
< #line 662
<     if (tmp___0 == 0) {
---
>   {
39656,39658c41168
<       drbd_state_unlock(mdev);
< #line 664
<       rv = SS_CW_FAILED_BY_PEER;
---
>   msg_flags = (unsigned long )data != (unsigned long )((void *)0) ? 32768 : 0;
39660,39665c41170,41172
<       if (((unsigned int )f & 2U) != 0U) {
< #line 666
<         print_st_err(mdev, os, ns, (int )rv);
<       } else {
< 
<       }
---
>   tmp = prepare_header(tconn, vnr, sock->sbuf, cmd, (int )(header_size + size));
> #line 665
>   header_size = tmp + header_size;
39667,39670c41174,41176
<       goto abort;
<     } else {
< 
<     }
---
>   err = drbd_send_all(tconn, sock->socket, sock->sbuf, (size_t )header_size, (unsigned int )msg_flags);
> #line 669
>   if ((unsigned long )data != (unsigned long )((void *)0) && err == 0) {
39672,39684c41178,41179
<     if ((unsigned int )*((unsigned short *)(& mask) + 0UL) == 496U && (unsigned int )*((unsigned short *)(& val) + 0UL) == 16U) {
< #line 671
<       drbd_set_flag(mdev, DISCONNECT_SENT);
<     } else {
< 
<     }
< #line 673
<     rv = _req_st_cond(mdev, mask, val);
< #line 673
<     if ((int )rv != 0) {
< #line 673
<       goto ldv_51899;
<     } else {
---
>     err = drbd_send_all(tconn, sock->socket, data, (size_t )size, 0U);
>   } else {
39686,39708c41181,41191
<     }
< #line 673
<     tmp___1 = get_current();
< #line 673
<     __wait.flags = 0U;
< #line 673
<     __wait.private = (void *)tmp___1;
< #line 673
<     __wait.func = & autoremove_wake_function;
< #line 673
<     __wait.task_list.next = & __wait.task_list;
< #line 673
<     __wait.task_list.prev = & __wait.task_list;
<     ldv_51902: 
< #line 673
<     prepare_to_wait(& mdev->state_wait, & __wait, 2);
< #line 673
<     rv = _req_st_cond(mdev, mask, val);
< #line 673
<     if ((int )rv != 0) {
< #line 673
<       goto ldv_51901;
<     } else {
---
>   }
> #line 671
>   return (err);
> }
> }
> #line 674 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int __conn_send_command(struct drbd_tconn *tconn , struct drbd_socket *sock ,
>                                enum drbd_packet cmd , unsigned int header_size , void *data ,
>                                unsigned int size ) 
> { 
>   int tmp ;
39710,39722c41193
<     }
< #line 673
<     schedule();
< #line 673
<     goto ldv_51902;
<     ldv_51901: 
< #line 673
<     finish_wait(& mdev->state_wait, & __wait);
<     ldv_51899: ;
< #line 676
<     if ((int )rv <= 0) {
< #line 677
<       drbd_state_unlock(mdev);
---
>   {
39724,39732c41195,41204
<       if (((unsigned int )f & 2U) != 0U) {
< #line 679
<         print_st_err(mdev, os, ns, (int )rv);
<       } else {
< 
<       }
< #line 680
<       goto abort;
<     } else {
---
>   tmp = __send_command(tconn, 0, sock, cmd, header_size, data, size);
> #line 678
>   return (tmp);
> }
> }
> #line 681 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int conn_send_command(struct drbd_tconn *tconn , struct drbd_socket *sock , enum drbd_packet cmd ,
>                       unsigned int header_size , void *data , unsigned int size ) 
> { 
>   int err ;
39734,39747c41206,41208
<     }
< #line 682
<     tmp___2 = spinlock_check(& mdev->req_lock);
< #line 682
<     flags = _raw_spin_lock_irqsave(tmp___2);
< #line 683
<     os = mdev->state;
< #line 684
<     ns.i = (os.i & ~ mask.i) | val.i;
< #line 685
<     rv = _drbd_set_state(mdev, ns, f, & done);
< #line 686
<     drbd_state_unlock(mdev);
<   } else {
---
>   {
> #line 687
>   err = __conn_send_command(tconn, sock, cmd, header_size, data, size);
39749,39768c41210,41219
<     rv = _drbd_set_state(mdev, ns, f, & done);
<   }
< #line 691
<   spin_unlock_irqrestore(& mdev->req_lock, flags);
< #line 693
<   if (((unsigned int )f & 4U) != 0U && (int )rv == 1) {
< #line 694
<     tmp___4 = get_current();
< #line 694
<     if ((unsigned long )tmp___4 == (unsigned long )mdev->worker.task) {
< #line 694
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( current != mdev->worker.task ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<               694);
<     } else {
< 
<     }
< #line 695
<     wait_for_completion(& done);
<   } else {
---
>   mutex_unlock(& sock->mutex);
> #line 689
>   return (err);
> }
> }
> #line 692 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_command(struct drbd_conf *mdev , struct drbd_socket *sock , enum drbd_packet cmd ,
>                       unsigned int header_size , void *data , unsigned int size ) 
> { 
>   int err ;
39770,39773c41221,41223
<   }
<   abort: ;
< #line 699
<   if (((unsigned int )f & 8U) != 0U) {
---
>   {
> #line 698
>   err = __send_command(mdev->tconn, mdev->vnr, sock, cmd, header_size, data, size);
39775,39780c41225,41227
<     mutex_unlock(& mdev->state_mutex);
<   } else {
< 
<   }
< #line 702
<   return (rv);
---
>   mutex_unlock(& sock->mutex);
> #line 701
>   return (err);
39783,39785c41230,41231
< #line 716 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< enum drbd_state_rv _drbd_request_state(struct drbd_conf *mdev , union drbd_state mask ,
<                                        union drbd_state val , enum chg_state_flags f ) 
---
> #line 704 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_ping(struct drbd_tconn *tconn ) 
39787,39789c41233,41235
<   enum drbd_state_rv rv ;
<   wait_queue_t __wait ;
<   struct task_struct *tmp ;
---
>   struct drbd_socket *sock ;
>   void *tmp ;
>   int tmp___0 ;
39792,39797c41238,41245
< #line 721
<   rv = drbd_req_state(mdev, mask, val, f);
< #line 721
<   if ((int )rv != -18) {
< #line 721
<     goto ldv_51913;
---
> #line 708
>   sock = & tconn->meta;
> #line 709
>   tmp = conn_prepare_command(tconn, sock);
> #line 709
>   if ((unsigned long )tmp == (unsigned long )((void *)0)) {
> #line 710
>     return (-5);
39801,39821c41249,41270
< #line 721
<   tmp = get_current();
< #line 721
<   __wait.flags = 0U;
< #line 721
<   __wait.private = (void *)tmp;
< #line 721
<   __wait.func = & autoremove_wake_function;
< #line 721
<   __wait.task_list.next = & __wait.task_list;
< #line 721
<   __wait.task_list.prev = & __wait.task_list;
<   ldv_51916: 
< #line 721
<   prepare_to_wait(& mdev->state_wait, & __wait, 2);
< #line 721
<   rv = drbd_req_state(mdev, mask, val, f);
< #line 721
<   if ((int )rv != -18) {
< #line 721
<     goto ldv_51915;
---
> #line 711
>   tmp___0 = conn_send_command(tconn, sock, P_PING, 0U, 0, 0U);
> #line 711
>   return (tmp___0);
> }
> }
> #line 714 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_ping_ack(struct drbd_tconn *tconn ) 
> { 
>   struct drbd_socket *sock ;
>   void *tmp ;
>   int tmp___0 ;
> 
>   {
> #line 718
>   sock = & tconn->meta;
> #line 719
>   tmp = conn_prepare_command(tconn, sock);
> #line 719
>   if ((unsigned long )tmp == (unsigned long )((void *)0)) {
> #line 720
>     return (-5);
39826,39829c41275
<   schedule();
< #line 721
<   goto ldv_51916;
<   ldv_51915: 
---
>   tmp___0 = conn_send_command(tconn, sock, P_PING_ACK, 0U, 0, 0U);
39831,39834c41277
<   finish_wait(& mdev->state_wait, & __wait);
<   ldv_51913: ;
< #line 724
<   return (rv);
---
>   return (tmp___0);
39837,39838c41280,41281
< #line 727 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void print_st(struct drbd_conf *mdev , char *name , union drbd_state ns ) 
---
> #line 724 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_sync_param(struct drbd_conf *mdev ) 
39840,39845c41283,41302
<   int tmp ;
<   char const   *tmp___0 ;
<   char const   *tmp___1 ;
<   char const   *tmp___2 ;
<   char const   *tmp___3 ;
<   char const   *tmp___4 ;
---
>   struct drbd_socket *sock ;
>   struct p_rs_param_95 *p ;
>   int size ;
>   int apv ;
>   enum drbd_packet cmd ;
>   struct net_conf *nc ;
>   struct disk_conf *dc ;
>   void *tmp ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___0 ;
>   int tmp___1 ;
>   size_t tmp___2 ;
>   int tmp___3 ;
>   struct disk_conf *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___4 ;
>   int tmp___5 ;
>   int tmp___6 ;
>   int tmp___7 ;
39849,39864c41306,41321
<   tmp = is_susp(ns);
< #line 729
<   tmp___0 = drbd_disk_str((enum drbd_disk_state )ns.ldv_40583.pdsk);
< #line 729
<   tmp___1 = drbd_disk_str((enum drbd_disk_state )ns.ldv_40583.disk);
< #line 729
<   tmp___2 = drbd_role_str((enum drbd_role )ns.ldv_40583.peer);
< #line 729
<   tmp___3 = drbd_role_str((enum drbd_role )ns.ldv_40583.role);
< #line 729
<   tmp___4 = drbd_conn_str((enum drbd_conns )ns.ldv_40583.conn);
< #line 729
<   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), " %s = { cs:%s ro:%s/%s ds:%s/%s %c%c%c%c }\n",
<           name, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp != 0 ? 115 : 114,
<           (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U ? 97 : 45, (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U ? 112 : 45,
<           (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U ? 117 : 45);
---
>   apv = (mdev->tconn)->agreed_pro_version;
> #line 734
>   sock = & (mdev->tconn)->data;
> #line 735
>   tmp = drbd_prepare_command(mdev, sock);
> #line 735
>   p = (struct p_rs_param_95 *)tmp;
> #line 736
>   if ((unsigned long )p == (unsigned long )((struct p_rs_param_95 *)0)) {
> #line 737
>     return (-5);
>   } else {
> 
>   }
> #line 739
>   rcu_read_lock();
39866,39873c41323,41337
<   return;
< }
< }
< #line 743 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void print_st_err(struct drbd_conf *mdev , union drbd_state os , union drbd_state ns ,
<                   enum drbd_state_rv err ) 
< { 
<   char const   *tmp ;
---
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 740
>   tmp___0 = debug_lockdep_rcu_enabled();
> #line 740
>   if (tmp___0 != 0 && ! __warned) {
> #line 740
>     tmp___1 = rcu_read_lock_held();
> #line 740
>     if (tmp___1 == 0 && 1) {
> #line 740
>       __warned = 1;
> #line 740
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>                              740, "suspicious rcu_dereference_check() usage");
>     } else {
39875,39879c41339
<   {
< #line 746
<   if ((int )err == -18) {
< #line 747
<     return;
---
>     }
39882a41343,41362
> #line 740
>   nc = _________p1;
> #line 742
>   if (apv > 87) {
> #line 742
>     if (apv == 88) {
> #line 742
>       tmp___2 = strlen((char const   *)(& nc->verify_alg));
> #line 742
>       tmp___3 = (int )((unsigned int )tmp___2 + 5U);
>     } else {
> #line 742
>       tmp___3 = apv <= 94 ? 132 : 148;
>     }
> #line 742
>     size = tmp___3;
>   } else {
> #line 742
>     size = 4;
>   }
39884,39891c41364
<   tmp = drbd_set_st_err_str(err);
< #line 748
<   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "State change failed: %s\n",
<           tmp);
< #line 749
<   print_st(mdev, (char *)" state", os);
< #line 750
<   print_st(mdev, (char *)"wanted", ns);
---
>   cmd = apv > 88 ? P_SYNC_PARAM89 : P_SYNC_PARAM;
39893,39902c41366,41386
<   return;
< }
< }
< #line 760 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static enum drbd_state_rv is_valid_state(struct drbd_conf *mdev , union drbd_state ns ) 
< { 
<   enum drbd_fencing_p fp ;
<   enum drbd_state_rv rv ;
<   int tmp ;
<   int tmp___0 ;
---
>   memset((void *)(& p->verify_alg), 0, 128UL);
> #line 753
>   tmp___6 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 753
>   if (tmp___6 != 0) {
> #line 754
>     _________p1___0 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 754
>     tmp___4 = debug_lockdep_rcu_enabled();
> #line 754
>     if (tmp___4 != 0 && ! __warned___0) {
> #line 754
>       tmp___5 = rcu_read_lock_held();
> #line 754
>       if (tmp___5 == 0 && 1) {
> #line 754
>         __warned___0 = 1;
> #line 754
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>                                754, "suspicious rcu_dereference_check() usage");
>       } else {
39904c41388,41412
<   {
---
>       }
>     } else {
> 
>     }
> #line 754
>     dc = _________p1___0;
> #line 755
>     p->resync_rate = __fswab32(dc->resync_rate);
> #line 756
>     p->c_plan_ahead = __fswab32(dc->c_plan_ahead);
> #line 757
>     p->c_delay_target = __fswab32(dc->c_delay_target);
> #line 758
>     p->c_fill_target = __fswab32(dc->c_fill_target);
> #line 759
>     p->c_max_rate = __fswab32(dc->c_max_rate);
> #line 760
>     put_ldev(mdev);
>   } else {
> #line 762
>     p->resync_rate = 4194304000U;
> #line 763
>     p->c_plan_ahead = 335544320U;
> #line 764
>     p->c_delay_target = 167772160U;
39906,39912c41414,41417
<   rv = 1;
< #line 767
<   fp = FP_DONT_CARE;
< #line 768
<   tmp = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 768
<   if (tmp != 0) {
---
>     p->c_fill_target = 1677721600U;
> #line 766
>     p->c_max_rate = 9437440U;
>   }
39914c41419
<     fp = (enum drbd_fencing_p )(mdev->ldev)->dc.fencing;
---
>   if (apv > 87) {
39916c41421
<     put_ldev(mdev);
---
>     strcpy((char *)(& p->verify_alg), (char const   *)(& nc->verify_alg));
39920,39932c41425,41428
< #line 773
<   tmp___0 = get_net_conf(mdev);
< #line 773
<   if (tmp___0 != 0) {
< #line 774
<     if (((unsigned int )*((unsigned char *)mdev->net_conf + 540UL) == 0U && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U) && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 4U) {
< #line 776
<       rv = SS_TWO_PRIMARIES;
<     } else {
< 
<     }
< #line 777
<     put_net_conf(mdev);
---
> #line 771
>   if (apv > 88) {
> #line 772
>     strcpy((char *)(& p->csums_alg), (char const   *)(& nc->csums_alg));
39936,39937c41432,41456
< #line 780
<   if ((int )rv <= 0) {
---
> #line 773
>   rcu_read_unlock();
> #line 775
>   tmp___7 = drbd_send_command(mdev, sock, cmd, (unsigned int )size, 0, 0U);
> #line 775
>   return (tmp___7);
> }
> }
> #line 778 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int __drbd_send_protocol(struct drbd_tconn *tconn , enum drbd_packet cmd ) 
> { 
>   struct drbd_socket *sock ;
>   struct p_protocol *p ;
>   struct net_conf *nc ;
>   int size ;
>   int cf ;
>   void *tmp ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___0 ;
>   int tmp___1 ;
>   size_t tmp___2 ;
>   __u32 tmp___3 ;
>   __u32 tmp___4 ;
>   int tmp___5 ;
39939,39944c41458
<   } else
< #line 782
<   if ((unsigned int )*((unsigned char *)(& ns) + 0UL) == 2U && mdev->open_cnt != 0) {
< #line 783
<     rv = SS_DEVICE_IN_USE;
<   } else
---
>   {
39946c41460
<   if (((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U && (int )ns.ldv_40583.conn <= 9) && (int )ns.ldv_40583.disk <= 7) {
---
>   sock = & tconn->data;
39948,39949c41462,41466
<     rv = SS_NO_UP_TO_DATE_DISK;
<   } else
---
>   tmp = __conn_prepare_command(tconn, sock);
> #line 786
>   p = (struct p_protocol *)tmp;
> #line 787
>   if ((unsigned long )p == (unsigned long )((struct p_protocol *)0)) {
39951c41468,41471
<   if ((((unsigned int )fp != 0U && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U) && (int )ns.ldv_40583.conn <= 9) && (int )ns.ldv_40583.pdsk > 5) {
---
>     return (-5);
>   } else {
> 
>   }
39953,39956c41473,41496
<     rv = SS_PRIMARY_NOP;
<   } else
< #line 792
<   if (((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U && (int )ns.ldv_40583.disk <= 4) && (int )ns.ldv_40583.pdsk <= 4) {
---
>   rcu_read_lock();
> #line 791
>   _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 791
>   tmp___0 = debug_lockdep_rcu_enabled();
> #line 791
>   if (tmp___0 != 0 && ! __warned) {
> #line 791
>     tmp___1 = rcu_read_lock_held();
> #line 791
>     if (tmp___1 == 0 && 1) {
> #line 791
>       __warned = 1;
> #line 791
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>                              791, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 791
>   nc = _________p1;
39958,39959c41498,41500
<     rv = SS_NO_UP_TO_DATE_DISK;
<   } else
---
>   if ((int )((signed char )nc->tentative) != 0 && tconn->agreed_pro_version <= 91) {
> #line 794
>     rcu_read_unlock();
39961c41502
<   if ((int )ns.ldv_40583.conn > 10 && (int )ns.ldv_40583.disk <= 3) {
---
>     mutex_unlock(& sock->mutex);
39963,39969c41504,41511
<     rv = SS_NO_LOCAL_DISK;
<   } else
< #line 798
<   if ((int )ns.ldv_40583.conn > 10 && (int )ns.ldv_40583.pdsk <= 3) {
< #line 799
<     rv = SS_NO_REMOTE_DISK;
<   } else
---
>     printk("\vd-con %s: --dry-run is not supported by peer", tconn->name);
> #line 797
>     return (-95);
>   } else {
> 
>   }
> #line 800
>   size = 24;
39971c41513
<   if (((int )ns.ldv_40583.conn > 10 && (int )ns.ldv_40583.disk <= 7) && (int )ns.ldv_40583.pdsk <= 7) {
---
>   if (tconn->agreed_pro_version > 86) {
39973,39974c41515,41520
<     rv = SS_NO_UP_TO_DATE_DISK;
<   } else
---
>     tmp___2 = strlen((char const   *)(& nc->integrity_alg));
> #line 802
>     size = (int )(((unsigned int )tmp___2 + (unsigned int )size) + 1U);
>   } else {
> 
>   }
39976c41522,41532
<   if (((((unsigned int )*((unsigned short *)(& ns) + 0UL) == 160U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 208U) || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 256U) || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 320U) && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 10U) {
---
>   p->protocol = __fswab32(nc->wire_protocol);
> #line 805
>   p->after_sb_0p = __fswab32(nc->after_sb_0p);
> #line 806
>   p->after_sb_1p = __fswab32(nc->after_sb_1p);
> #line 807
>   p->after_sb_2p = __fswab32(nc->after_sb_2p);
> #line 808
>   tmp___3 = __fswab32((__u32 )nc->two_primaries);
> #line 808
>   p->two_primaries = tmp___3;
39978,39979c41534,41536
<     rv = SS_CONNECTED_OUTDATES;
<   } else
---
>   cf = 0;
> #line 810
>   if ((int )((signed char )nc->discard_my_data) != 0) {
39981c41538,41543
<   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 304U) && (unsigned int )mdev->sync_conf.verify_alg[0] == 0U) {
---
>     cf = cf | 1;
>   } else {
> 
>   }
> #line 812
>   if ((int )((signed char )nc->tentative) != 0) {
39983,39986c41545,41554
<     rv = SS_NO_VERIFY_ALG;
<   } else
< #line 815
<   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 304U) && mdev->agreed_pro_version <= 87) {
---
>     cf = cf | 2;
>   } else {
> 
>   }
> #line 814
>   tmp___4 = __fswab32((__u32 )cf);
> #line 814
>   p->conn_flags = tmp___4;
> #line 816
>   if (tconn->agreed_pro_version > 86) {
39988,39993c41556
<     rv = SS_NOT_SUPPORTED;
<   } else
< #line 819
<   if ((int )ns.ldv_40583.conn > 9 && *((unsigned int *)(& ns) + 0UL) == 49152U) {
< #line 820
<     rv = SS_CONNECTED_OUTDATES;
---
>     strcpy((char *)(& p->integrity_alg), (char const   *)(& nc->integrity_alg));
39997,39998c41560,41565
< #line 822
<   return (rv);
---
> #line 818
>   rcu_read_unlock();
> #line 820
>   tmp___5 = __conn_send_command(tconn, sock, cmd, (unsigned int )size, 0, 0U);
> #line 820
>   return (tmp___5);
40001,40003c41568,41569
< #line 832 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static enum drbd_state_rv is_valid_state_transition(struct drbd_conf *mdev , union drbd_state ns ,
<                                                     union drbd_state os ) 
---
> #line 823 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_protocol(struct drbd_tconn *tconn ) 
40005,40006c41571
<   enum drbd_state_rv rv ;
<   int tmp ;
---
>   int err ;
40009,40015c41574,41600
< #line 835
<   rv = 1;
< #line 837
<   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 192U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 176U) && (int )os.ldv_40583.conn > 10) {
< #line 839
<     rv = SS_RESYNC_RUNNING;
<   } else {
---
> #line 827
>   mutex_lock_nested(& tconn->data.mutex, 0U);
> #line 828
>   err = __drbd_send_protocol(tconn, P_PROTOCOL);
> #line 829
>   mutex_unlock(& tconn->data.mutex);
> #line 831
>   return (err);
> }
> }
> #line 834 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int _drbd_send_uuids(struct drbd_conf *mdev , u64 uuid_flags ) 
> { 
>   struct drbd_socket *sock ;
>   struct p_uuids *p ;
>   int i ;
>   int tmp ;
>   void *tmp___0 ;
>   __u64 tmp___1 ;
>   __u64 tmp___2 ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___3 ;
>   int tmp___4 ;
>   int tmp___5 ;
>   __u64 tmp___6 ;
>   int tmp___7 ;
40017c41602,41606
<   }
---
>   {
> #line 840
>   tmp = _get_ldev_if_state(mdev, D_NEGOTIATING);
> #line 840
>   if (tmp == 0) {
40019,40021c41608
<   if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 16U && (unsigned int )*((unsigned short *)(& os) + 0UL) == 0U) {
< #line 842
<     rv = SS_ALREADY_STANDALONE;
---
>     return (0);
40024a41612,41613
> #line 843
>   sock = & (mdev->tconn)->data;
40026c41615,41617
<   if ((int )ns.ldv_40583.disk > 1 && (unsigned int )*((unsigned char *)(& os) + 1UL) == 0U) {
---
>   tmp___0 = drbd_prepare_command(mdev, sock);
> #line 844
>   p = (struct p_uuids *)tmp___0;
40028,40031c41619,41621
<     rv = SS_IS_DISKLESS;
<   } else {
< 
<   }
---
>   if ((unsigned long )p == (unsigned long )((struct p_uuids *)0)) {
> #line 846
>     put_ldev(mdev);
40033,40035c41623
<   if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 128U && (int )os.ldv_40583.conn <= 1) {
< #line 848
<     rv = SS_NO_NET_CONFIG;
---
>     return (-5);
40038a41627,41628
> #line 849
>   spin_lock_irq(& (mdev->ldev)->md.uuid_lock);
40040c41630,41633
<   if (((unsigned int )*((unsigned char *)(& ns) + 1UL) == 10U && (int )os.ldv_40583.disk <= 4) && (unsigned int )*((unsigned char *)(& os) + 1UL) != 2U) {
---
>   i = 0;
> #line 850
>   goto ldv_52495;
>   ldv_52494: ;
40042c41635,41639
<     rv = SS_LOWER_THAN_OUTDATED;
---
>   if ((unsigned long )mdev->ldev != (unsigned long )((struct drbd_backing_dev *)0)) {
> #line 851
>     tmp___1 = __fswab64((mdev->ldev)->md.uuid[i]);
> #line 851
>     p->uuid[i] = tmp___1;
40044c41641,41642
< 
---
> #line 851
>     p->uuid[i] = 0ULL;
40046,40049c41644,41650
< #line 853
<   if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 16U && (unsigned int )*((unsigned short *)(& os) + 0UL) == 32U) {
< #line 854
<     rv = SS_IN_TRANSIENT_STATE;
---
> #line 850
>   i = i + 1;
>   ldv_52495: ;
> #line 850
>   if (i <= 3) {
> #line 851
>     goto ldv_52494;
40052a41654,41661
> #line 852
>   spin_unlock_irq(& (mdev->ldev)->md.uuid_lock);
> #line 854
>   mdev->comm_bm_set = drbd_bm_total_weight(mdev);
> #line 855
>   tmp___2 = __fswab64((__u64 )mdev->comm_bm_set);
> #line 855
>   p->uuid[4] = tmp___2;
40054c41663
<   if ((int )ns.ldv_40583.conn == (int )os.ldv_40583.conn && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 144U) {
---
>   rcu_read_lock();
40056c41665,41681
<     rv = SS_IN_TRANSIENT_STATE;
---
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 857
>   tmp___3 = debug_lockdep_rcu_enabled();
> #line 857
>   if (tmp___3 != 0 && ! __warned) {
> #line 857
>     tmp___4 = rcu_read_lock_held();
> #line 857
>     if (tmp___4 == 0 && 1) {
> #line 857
>       __warned = 1;
> #line 857
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>                              857, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
40059a41685,41694
> #line 857
>   uuid_flags = ((int )((signed char )_________p1->discard_my_data) != 0 ? 1ULL : 0ULL) | uuid_flags;
> #line 858
>   rcu_read_unlock();
> #line 859
>   tmp___5 = constant_test_bit(5U, (unsigned long const volatile   *)(& mdev->flags));
> #line 859
>   uuid_flags = (tmp___5 != 0 ? 2ULL : 0ULL) | uuid_flags;
> #line 860
>   uuid_flags = ((unsigned int )*((unsigned char *)mdev + 745UL) == 8U ? 4ULL : 0ULL) | uuid_flags;
40061c41696
<   tmp = drbd_test_flag(mdev, STATE_SENT);
---
>   tmp___6 = __fswab64(uuid_flags);
40063c41698,41700
<   if (tmp != 0 && ((unsigned int )*((unsigned short *)(& os) + 0UL) != 144U && ((unsigned int )*((unsigned short *)(& ns) + 0UL) != 144U || (unsigned int )*((unsigned short *)(& os) + 0UL) != 128U))) {
---
>   p->uuid[5] = tmp___6;
> #line 863
>   put_ldev(mdev);
40065,40073c41702,41710
<     rv = SS_IN_TRANSIENT_STATE;
<   } else {
< 
<   }
< #line 866
<   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 304U) && (int )os.ldv_40583.conn <= 9) {
< #line 867
<     rv = SS_NEED_CONNECTION;
<   } else {
---
>   tmp___7 = drbd_send_command(mdev, sock, P_UUIDS, 48U, 0, 0U);
> #line 864
>   return (tmp___7);
> }
> }
> #line 867 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_uuids(struct drbd_conf *mdev ) 
> { 
>   int tmp ;
40075c41712
<   }
---
>   {
40077,40080c41714,41722
<   if ((((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 304U) && (int )ns.ldv_40583.conn != (int )os.ldv_40583.conn) && (int )os.ldv_40583.conn > 10) {
< #line 871
<     rv = SS_RESYNC_RUNNING;
<   } else {
---
>   tmp = _drbd_send_uuids(mdev, 0ULL);
> #line 869
>   return (tmp);
> }
> }
> #line 872 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_uuids_skip_initial_sync(struct drbd_conf *mdev ) 
> { 
>   int tmp ;
40082,40087c41724,41735
<   }
< #line 873
<   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 176U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 192U) && (int )os.ldv_40583.conn <= 9) {
< #line 875
<     rv = SS_NEED_CONNECTION;
<   } else {
---
>   {
> #line 874
>   tmp = _drbd_send_uuids(mdev, 8ULL);
> #line 874
>   return (tmp);
> }
> }
> #line 877 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void drbd_print_uuids(struct drbd_conf *mdev , char const   *text ) 
> { 
>   u64 *uuid ;
>   int tmp ;
40089,40091c41737
<   }
< #line 877
<   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 272U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 256U) && (int )os.ldv_40583.conn <= 8) {
---
>   {
40093c41739,41748
<     rv = SS_NEED_CONNECTION;
---
>   tmp = _get_ldev_if_state(mdev, D_NEGOTIATING);
> #line 879
>   if (tmp != 0) {
> #line 880
>     uuid = (u64 *)(& (mdev->ldev)->md.uuid);
> #line 881
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s %016llX:%016llX:%016llX:%016llX\n",
>               text, *uuid, *(uuid + 1UL), *(uuid + 2UL), *(uuid + 3UL));
> #line 887
>     put_ldev(mdev);
40095c41750,41752
< 
---
> #line 889
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s effective data uuid: %016llX\n",
>               text, mdev->ed_uuid);
40097,40098c41754,41755
< #line 881
<   return (rv);
---
> #line 890
>   return;
40101,40102c41758,41759
< #line 884 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void print_sanitize_warnings(struct drbd_conf *mdev , enum sanitize_state_warnings warn ) 
---
> #line 895 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void drbd_gen_and_send_sync_uuid(struct drbd_conf *mdev ) 
40104c41761,41765
<   char const   *msg_table[6U] ;
---
>   struct drbd_socket *sock ;
>   struct p_rs_uuid *p ;
>   u64 uuid ;
>   void *tmp ;
>   __u64 tmp___0 ;
40107,40122c41768,41773
< #line 886
<   msg_table[0] = "";
< #line 886
<   msg_table[1] = "Online-verify aborted.";
< #line 886
<   msg_table[2] = "Resync aborted.";
< #line 886
<   msg_table[3] = "Connection lost while negotiating, no data!";
< #line 886
<   msg_table[4] = "Implicitly upgraded disk";
< #line 886
<   msg_table[5] = "Implicitly upgraded pdsk";
< #line 895
<   if ((unsigned int )warn != 0U) {
< #line 896
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s\n", msg_table[(unsigned int )warn]);
---
> #line 901
>   if ((unsigned int )*((unsigned char *)mdev + 749UL) != 16U) {
> #line 901
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->state.disk == D_UP_TO_DATE ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             901);
40126c41777,41810
< #line 897
---
> #line 903
>   uuid = (mdev->ldev)->md.uuid[1];
> #line 904
>   if (uuid != 0ULL && uuid != 4ULL) {
> #line 905
>     uuid = uuid + 281474976710656ULL;
>   } else {
> #line 907
>     get_random_bytes((void *)(& uuid), 8);
>   }
> #line 908
>   drbd_uuid_set(mdev, 1, uuid);
> #line 909
>   drbd_print_uuids(mdev, "updated sync UUID");
> #line 910
>   drbd_md_sync(mdev);
> #line 912
>   sock = & (mdev->tconn)->data;
> #line 913
>   tmp = drbd_prepare_command(mdev, sock);
> #line 913
>   p = (struct p_rs_uuid *)tmp;
> #line 914
>   if ((unsigned long )p != (unsigned long )((struct p_rs_uuid *)0)) {
> #line 915
>     tmp___0 = __fswab64(uuid);
> #line 915
>     p->uuid = tmp___0;
> #line 916
>     drbd_send_command(mdev, sock, P_SYNC_UUID, 8U, 0, 0U);
>   } else {
> 
>   }
> #line 918
40130,40132c41814,41815
< #line 909 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static union drbd_state sanitize_state(struct drbd_conf *mdev , union drbd_state os ,
<                                        union drbd_state ns , enum sanitize_state_warnings *warn ) 
---
> #line 920 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_sizes(struct drbd_conf *mdev , int trigger_reply , enum dds_flags flags ) 
40134,40138c41817,41824
<   enum drbd_fencing_p fp ;
<   enum drbd_disk_state disk_min ;
<   enum drbd_disk_state disk_max ;
<   enum drbd_disk_state pdsk_min ;
<   enum drbd_disk_state pdsk_max ;
---
>   struct drbd_socket *sock ;
>   struct p_sizes *p ;
>   sector_t d_size ;
>   sector_t u_size ;
>   int q_order_type ;
>   unsigned int max_bio_size ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
40140a41827,41844
>   unsigned int tmp___1 ;
>   unsigned int _min1 ;
>   unsigned int _min2 ;
>   int tmp___2 ;
>   void *tmp___3 ;
>   unsigned int _min1___0 ;
>   unsigned int _min2___0 ;
>   unsigned int _min1___1 ;
>   unsigned int _min2___1 ;
>   __u64 tmp___4 ;
>   __u64 tmp___5 ;
>   sector_t tmp___6 ;
>   __u64 tmp___7 ;
>   __u64 tmp___8 ;
>   __u32 tmp___9 ;
>   __u16 tmp___10 ;
>   __u16 tmp___11 ;
>   int tmp___12 ;
40143,40147c41847,41857
< #line 915
<   if ((unsigned long )warn != (unsigned long )((enum sanitize_state_warnings *)0)) {
< #line 916
<     *warn = NO_WARNING;
<   } else {
---
> #line 928
>   tmp___2 = _get_ldev_if_state(mdev, D_NEGOTIATING);
> #line 928
>   if (tmp___2 != 0) {
> #line 929
>     if ((unsigned long )(mdev->ldev)->backing_bdev == (unsigned long )((struct block_device *)0)) {
> #line 929
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->ldev->backing_bdev ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>               929);
>     } else {
40149,40160c41859,41879
<   }
< #line 918
<   fp = FP_DONT_CARE;
< #line 919
<   tmp = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 919
<   if (tmp != 0) {
< #line 920
<     fp = (enum drbd_fencing_p )(mdev->ldev)->dc.fencing;
< #line 921
<     put_ldev(mdev);
<   } else {
---
>     }
> #line 930
>     d_size = drbd_get_max_capacity___0(mdev->ldev);
> #line 931
>     rcu_read_lock();
> #line 932
>     _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 932
>     tmp = debug_lockdep_rcu_enabled();
> #line 932
>     if (tmp != 0 && ! __warned) {
> #line 932
>       tmp___0 = rcu_read_lock_held();
> #line 932
>       if (tmp___0 == 0 && 1) {
> #line 932
>         __warned = 1;
> #line 932
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>                                932, "suspicious rcu_dereference_check() usage");
>       } else {
40162,40167c41881,41882
<   }
< #line 925
<   if (((int )ns.ldv_40583.conn > 2 && (int )ns.ldv_40583.conn <= 7) && (int )os.ldv_40583.conn <= 1) {
< #line 927
<     ns.ldv_40583.conn = os.ldv_40583.conn;
<   } else {
---
>       }
>     } else {
40169,40171c41884,41886
<   }
< #line 931
<   if (((((int )os.ldv_40583.conn > 2 && (int )os.ldv_40583.conn <= 7) && (unsigned int )*((unsigned short *)(& ns) + 0UL) != 32U) && (unsigned int )*((unsigned short *)(& ns) + 0UL) != 16U) && (int )ns.ldv_40583.conn <= 10) {
---
>     }
> #line 932
>     u_size = (sector_t )_________p1->disk_size;
40173,40176c41888,41894
<     ns.ldv_40583.conn = os.ldv_40583.conn;
<   } else {
< 
<   }
---
>     rcu_read_unlock();
> #line 934
>     q_order_type = drbd_queue_order_type(mdev);
> #line 935
>     tmp___1 = queue_max_hw_sectors((((mdev->ldev)->backing_bdev)->bd_disk)->queue);
> #line 935
>     max_bio_size = tmp___1 << 9;
40178c41896,41900
<   if ((unsigned int )*((unsigned char *)(& ns) + 1UL) == 4U && (unsigned int )*((unsigned char *)(& os) + 1UL) == 0U) {
---
>     _min1 = max_bio_size;
> #line 936
>     _min2 = 1048576U;
> #line 936
>     max_bio_size = _min1 < _min2 ? _min1 : _min2;
40180c41902
<     ns.ldv_40583.disk = 0U;
---
>     put_ldev(mdev);
40182,40183c41904,41905
< 
<   }
---
> #line 939
>     d_size = 0UL;
40185c41907
<   if ((unsigned int )*((unsigned short *)(& os) + 0UL) == 16U && (unsigned int )*((unsigned short *)(& ns) + 0UL) != 0U) {
---
>     u_size = 0UL;
40187,40189c41909,41911
<     ns.ldv_40583.conn = os.ldv_40583.conn;
<   } else {
< 
---
>     q_order_type = 0;
> #line 942
>     max_bio_size = 1048576U;
40191,40194d41912
< #line 943
<   if ((int )ns.ldv_40583.conn <= 9) {
< #line 944
<     ns.ldv_40583.peer_isp = 0U;
40196c41914,41916
<     ns.ldv_40583.peer = 0U;
---
>   sock = & (mdev->tconn)->data;
> #line 946
>   tmp___3 = drbd_prepare_command(mdev, sock);
40198c41918
<     if ((int )ns.ldv_40583.pdsk > 6 || (int )ns.ldv_40583.pdsk <= 3) {
---
>   p = (struct p_sizes *)tmp___3;
40200,40203c41920,41922
<       ns.ldv_40583.pdsk = 6U;
<     } else {
< 
<     }
---
>   if ((unsigned long )p == (unsigned long )((struct p_sizes *)0)) {
> #line 948
>     return (-5);
40206a41926,41927
> #line 950
>   if ((mdev->tconn)->agreed_pro_version <= 94) {
40208c41929,41934
<   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 0U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 0U) && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 2U) {
---
>     _min1___0 = max_bio_size;
> #line 951
>     _min2___0 = 32768U;
> #line 951
>     max_bio_size = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
>   } else
40210c41936,41942
<     ns.ldv_40583.aftr_isp = 0U;
---
>   if ((mdev->tconn)->agreed_pro_version <= 99) {
> #line 953
>     _min1___1 = max_bio_size;
> #line 953
>     _min2___1 = 131072U;
> #line 953
>     max_bio_size = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
40215c41947,41953
<   if (((int )os.ldv_40583.conn > 10 && (int )ns.ldv_40583.conn > 10) && ((int )ns.ldv_40583.disk <= 2 || (int )ns.ldv_40583.pdsk <= 2)) {
---
>   tmp___4 = __fswab64((__u64 )d_size);
> #line 955
>   p->d_size = tmp___4;
> #line 956
>   tmp___5 = __fswab64((__u64 )u_size);
> #line 956
>   p->u_size = tmp___5;
40217,40224c41955,41959
<     if ((unsigned long )warn != (unsigned long )((enum sanitize_state_warnings *)0)) {
< #line 958
<       *warn = (unsigned int )*((unsigned short *)(& os) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& os) + 0UL) == 304U ? ABORTED_ONLINE_VERIFY : ABORTED_RESYNC;
<     } else {
< 
<     }
< #line 960
<     ns.ldv_40583.conn = 10U;
---
>   if (trigger_reply == 0) {
> #line 957
>     tmp___6 = drbd_get_capacity(mdev->this_bdev);
> #line 957
>     tmp___7 = (__u64 )tmp___6;
40226c41961,41962
< 
---
> #line 957
>     tmp___7 = 0ULL;
40228,40245c41964,41993
< #line 964
<   if ((int )ns.ldv_40583.conn <= 9 && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 6U) {
< #line 964
<     tmp___0 = _get_ldev_if_state(mdev, D_NEGOTIATING);
< #line 964
<     if (tmp___0 != 0) {
< #line 966
<       if (mdev->ed_uuid == (mdev->ldev)->md.uuid[0]) {
< #line 967
<         ns.ldv_40583.disk = mdev->new_state_tmp.ldv_40583.disk;
< #line 968
<         ns.ldv_40583.pdsk = mdev->new_state_tmp.ldv_40583.pdsk;
<       } else {
< #line 970
<         if ((unsigned long )warn != (unsigned long )((enum sanitize_state_warnings *)0)) {
< #line 971
<           *warn = CONNECTION_LOST_NEGOTIATING;
<         } else {
---
> #line 957
>   tmp___8 = __fswab64(tmp___7);
> #line 957
>   p->c_size = tmp___8;
> #line 958
>   tmp___9 = __fswab32(max_bio_size);
> #line 958
>   p->max_bio_size = tmp___9;
> #line 959
>   tmp___10 = __fswab16((int )((__u16 )q_order_type));
> #line 959
>   p->queue_order_type = tmp___10;
> #line 960
>   tmp___11 = __fswab16((int )((__u16 )flags));
> #line 960
>   p->dds_flags = tmp___11;
> #line 961
>   tmp___12 = drbd_send_command(mdev, sock, P_SIZES, 32U, 0, 0U);
> #line 961
>   return (tmp___12);
> }
> }
> #line 968 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_current_state(struct drbd_conf *mdev ) 
> { 
>   struct drbd_socket *sock ;
>   struct p_state *p ;
>   void *tmp ;
>   __u32 tmp___0 ;
>   int tmp___1 ;
40247,40249c41995
<         }
< #line 972
<         ns.ldv_40583.disk = 0U;
---
>   {
40251,40252c41997,42001
<         ns.ldv_40583.pdsk = 6U;
<       }
---
>   sock = & (mdev->tconn)->data;
> #line 974
>   tmp = drbd_prepare_command(mdev, sock);
> #line 974
>   p = (struct p_state *)tmp;
40254,40257c42003,42005
<       put_ldev(mdev);
<     } else {
< 
<     }
---
>   if ((unsigned long )p == (unsigned long )((struct p_state *)0)) {
> #line 976
>     return (-5);
40261,40277c42009,42026
< #line 979
<   if ((int )ns.ldv_40583.conn > 9 && (int )ns.ldv_40583.conn <= 21) {
< #line 980
<     if ((unsigned int )*((unsigned char *)(& ns) + 1UL) == 14U || (unsigned int )*((unsigned char *)(& ns) + 1UL) == 10U) {
< #line 981
<       ns.ldv_40583.disk = 8U;
<     } else {
< 
<     }
< #line 982
<     if (*((unsigned int *)(& ns) + 0UL) == 57344U || *((unsigned int *)(& ns) + 0UL) == 40960U) {
< #line 983
<       ns.ldv_40583.pdsk = 8U;
<     } else {
< 
<     }
<   } else {
---
> #line 977
>   tmp___0 = __fswab32(mdev->state.i);
> #line 977
>   p->state = tmp___0;
> #line 978
>   tmp___1 = drbd_send_command(mdev, sock, P_STATE, 4U, 0, 0U);
> #line 978
>   return (tmp___1);
> }
> }
> #line 991 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_state(struct drbd_conf *mdev , union drbd_state state ) 
> { 
>   struct drbd_socket *sock ;
>   struct p_state *p ;
>   void *tmp ;
>   __u32 tmp___0 ;
>   int tmp___1 ;
40279,40294c42028,42030
<   }
< #line 987
<   disk_min = D_DISKLESS;
< #line 988
<   disk_max = D_UP_TO_DATE;
< #line 989
<   pdsk_min = D_INCONSISTENT;
< #line 990
<   pdsk_max = D_UNKNOWN;
< #line 991
<   switch ((unsigned int )ns.ldv_40583.conn) {
<   case 14U: ;
<   case 21U: ;
<   case 12U: ;
<   case 15U: ;
<   case 23U: 
---
>   {
> #line 996
>   sock = & (mdev->tconn)->data;
40296c42032,42034
<   disk_min = D_INCONSISTENT;
---
>   tmp = drbd_prepare_command(mdev, sock);
> #line 997
>   p = (struct p_state *)tmp;
40298c42036
<   disk_max = D_OUTDATED;
---
>   if ((unsigned long )p == (unsigned long )((struct p_state *)0)) {
40300c42038,42041
<   pdsk_min = D_UP_TO_DATE;
---
>     return (-5);
>   } else {
> 
>   }
40302c42043,42045
<   pdsk_max = D_UP_TO_DATE;
---
>   tmp___0 = __fswab32(state.i);
> #line 1000
>   p->state = tmp___0;
40304,40317c42047,42064
<   goto ldv_51961;
<   case 18U: ;
<   case 19U: 
< #line 1004
<   disk_min = D_UP_TO_DATE;
< #line 1005
<   disk_max = D_UP_TO_DATE;
< #line 1006
<   pdsk_min = D_UP_TO_DATE;
< #line 1007
<   pdsk_max = D_UP_TO_DATE;
< #line 1008
<   goto ldv_51961;
<   case 10U: 
---
>   tmp___1 = drbd_send_command(mdev, sock, P_STATE, 4U, 0, 0U);
> #line 1001
>   return (tmp___1);
> }
> }
> #line 1004 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_state_req(struct drbd_conf *mdev , union drbd_state mask , union drbd_state val ) 
> { 
>   struct drbd_socket *sock ;
>   struct p_req_state *p ;
>   void *tmp ;
>   __u32 tmp___0 ;
>   __u32 tmp___1 ;
>   int tmp___2 ;
> 
>   {
> #line 1009
>   sock = & (mdev->tconn)->data;
40319c42066,42068
<   disk_min = D_DISKLESS;
---
>   tmp = drbd_prepare_command(mdev, sock);
> #line 1010
>   p = (struct p_req_state *)tmp;
40321c42070
<   disk_max = D_UP_TO_DATE;
---
>   if ((unsigned long )p == (unsigned long )((struct p_req_state *)0)) {
40323c42072,42075
<   pdsk_min = D_DISKLESS;
---
>     return (-5);
>   } else {
> 
>   }
40325c42077,42079
<   pdsk_max = D_UP_TO_DATE;
---
>   tmp___0 = __fswab32(mask.i);
> #line 1013
>   p->mask = tmp___0;
40327,40342c42081,42103
<   goto ldv_51961;
<   case 13U: ;
<   case 20U: ;
<   case 11U: ;
<   case 22U: 
< #line 1019
<   disk_min = D_UP_TO_DATE;
< #line 1020
<   disk_max = D_UP_TO_DATE;
< #line 1021
<   pdsk_min = D_INCONSISTENT;
< #line 1022
<   pdsk_max = D_CONSISTENT;
< #line 1023
<   goto ldv_51961;
<   case 17U: 
---
>   tmp___1 = __fswab32(val.i);
> #line 1014
>   p->val = tmp___1;
> #line 1015
>   tmp___2 = drbd_send_command(mdev, sock, P_STATE_CHG_REQ, 8U, 0, 0U);
> #line 1015
>   return (tmp___2);
> }
> }
> #line 1018 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int conn_send_state_req(struct drbd_tconn *tconn , union drbd_state mask , union drbd_state val ) 
> { 
>   enum drbd_packet cmd ;
>   struct drbd_socket *sock ;
>   struct p_req_state *p ;
>   void *tmp ;
>   __u32 tmp___0 ;
>   __u32 tmp___1 ;
>   int tmp___2 ;
> 
>   {
> #line 1024
>   cmd = tconn->agreed_pro_version <= 99 ? P_STATE_CHG_REQ : P_CONN_ST_CHG_REQ;
40344c42105
<   disk_min = D_INCONSISTENT;
---
>   sock = & tconn->data;
40346c42107,42109
<   disk_max = D_INCONSISTENT;
---
>   tmp = conn_prepare_command(tconn, sock);
> #line 1026
>   p = (struct p_req_state *)tmp;
40348c42111
<   pdsk_min = D_UP_TO_DATE;
---
>   if ((unsigned long )p == (unsigned long )((struct p_req_state *)0)) {
40350c42113,42116
<   pdsk_max = D_UP_TO_DATE;
---
>     return (-5);
>   } else {
> 
>   }
40352,40353c42118,42124
<   goto ldv_51961;
<   case 16U: 
---
>   tmp___0 = __fswab32(mask.i);
> #line 1029
>   p->mask = tmp___0;
> #line 1030
>   tmp___1 = __fswab32(val.i);
> #line 1030
>   p->val = tmp___1;
40355,40382c42126,42153
<   disk_min = D_UP_TO_DATE;
< #line 1032
<   disk_max = D_UP_TO_DATE;
< #line 1033
<   pdsk_min = D_INCONSISTENT;
< #line 1034
<   pdsk_max = D_INCONSISTENT;
< #line 1035
<   goto ldv_51961;
<   case 0U: ;
<   case 1U: ;
<   case 2U: ;
<   case 3U: ;
<   case 4U: ;
<   case 5U: ;
<   case 6U: ;
<   case 7U: ;
<   case 8U: ;
<   case 9U: ;
<   case 31U: ;
< #line 1047
<   goto ldv_51961;
<   }
<   ldv_51961: ;
< #line 1049
<   if ((unsigned int )ns.ldv_40583.disk > (unsigned int )disk_max) {
< #line 1050
<     ns.ldv_40583.disk = (unsigned char )disk_max;
---
>   tmp___2 = conn_send_command(tconn, sock, cmd, 8U, 0, 0U);
> #line 1031
>   return (tmp___2);
> }
> }
> #line 1034 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void drbd_send_sr_reply(struct drbd_conf *mdev , enum drbd_state_rv retcode ) 
> { 
>   struct drbd_socket *sock ;
>   struct p_req_state_reply *p ;
>   void *tmp ;
>   __u32 tmp___0 ;
> 
>   {
> #line 1039
>   sock = & (mdev->tconn)->meta;
> #line 1040
>   tmp = drbd_prepare_command(mdev, sock);
> #line 1040
>   p = (struct p_req_state_reply *)tmp;
> #line 1041
>   if ((unsigned long )p != (unsigned long )((struct p_req_state_reply *)0)) {
> #line 1042
>     tmp___0 = __fswab32((__u32 )retcode);
> #line 1042
>     p->retcode = tmp___0;
> #line 1043
>     drbd_send_command(mdev, sock, P_STATE_CHG_REPLY, 4U, 0, 0U);
40386,40387c42157,42172
< #line 1052
<   if ((unsigned int )ns.ldv_40583.disk < (unsigned int )disk_min) {
---
> #line 1045
>   return;
> }
> }
> #line 1047 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void conn_send_sr_reply(struct drbd_tconn *tconn , enum drbd_state_rv retcode ) 
> { 
>   struct drbd_socket *sock ;
>   struct p_req_state_reply *p ;
>   enum drbd_packet cmd ;
>   void *tmp ;
>   __u32 tmp___0 ;
> 
>   {
> #line 1051
>   cmd = tconn->agreed_pro_version <= 99 ? P_STATE_CHG_REPLY : P_CONN_ST_CHG_REPLY;
40389c42174
<     if ((unsigned long )warn != (unsigned long )((enum sanitize_state_warnings *)0)) {
---
>   sock = & tconn->meta;
40391,40394c42176,42178
<       *warn = IMPLICITLY_UPGRADED_DISK;
<     } else {
< 
<     }
---
>   tmp = conn_prepare_command(tconn, sock);
> #line 1054
>   p = (struct p_req_state_reply *)tmp;
40396,40399c42180,42184
<     ns.ldv_40583.disk = (unsigned char )disk_min;
<   } else {
< 
<   }
---
>   if ((unsigned long )p != (unsigned long )((struct p_req_state_reply *)0)) {
> #line 1056
>     tmp___0 = __fswab32((__u32 )retcode);
> #line 1056
>     p->retcode = tmp___0;
40401,40403c42186
<   if ((unsigned int )ns.ldv_40583.pdsk > (unsigned int )pdsk_max) {
< #line 1058
<     ns.ldv_40583.pdsk = (unsigned char )pdsk_max;
---
>     conn_send_command(tconn, sock, cmd, 4U, 0, 0U);
40407,40413c42190,42197
< #line 1060
<   if ((unsigned int )ns.ldv_40583.pdsk < (unsigned int )pdsk_min) {
< #line 1061
<     if ((unsigned long )warn != (unsigned long )((enum sanitize_state_warnings *)0)) {
< #line 1062
<       *warn = IMPLICITLY_UPGRADED_PDSK;
<     } else {
---
> #line 1059
>   return;
> }
> }
> #line 1061 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static void dcbp_set_code(struct p_compressed_bm *p , enum drbd_bitmap_code code ) 
> { 
>   long tmp ;
40415c42199,42203
<     }
---
>   {
> #line 1063
>   tmp = __builtin_expect(((unsigned int )code & 4294967280U) != 0U, 0L);
> #line 1063
>   if (tmp != 0L) {
40417c42205,42209
<     ns.ldv_40583.pdsk = (unsigned char )pdsk_min;
---
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"),
>                          "i" (1063), "i" (12UL));
>     ldv_52583: ;
> #line 1063
>     goto ldv_52583;
40421,40422c42213,42224
< #line 1066
<   if (((unsigned int )fp == 2U && (((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U && (int )ns.ldv_40583.conn <= 9) && (int )ns.ldv_40583.pdsk > 5)) && (((unsigned int )*((unsigned char *)(& os) + 0UL) != 1U || (int )os.ldv_40583.conn > 9) || (int )os.ldv_40583.pdsk <= 5)) {
---
> #line 1064
>   p->encoding = ((unsigned int )p->encoding & 240U) | (unsigned int )((u8 )code);
> #line 1065
>   return;
> }
> }
> #line 1067 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static void dcbp_set_start(struct p_compressed_bm *p , int set ) 
> { 
> 
> 
>   {
40424,40425c42226,42234
<     ns.ldv_40583.susp_fen = 1U;
<   } else {
---
>   p->encoding = (u8 )(((int )((signed char )p->encoding) & 127) | (set != 0 ? -128 : 0));
> #line 1070
>   return;
> }
> }
> #line 1072 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static void dcbp_set_pad_bits(struct p_compressed_bm *p , int n ) 
> { 
>   long tmp ;
40427,40429c42236,42244
<   }
< #line 1071
<   if ((mdev->sync_conf.on_no_data == 1 && (((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U && (int )ns.ldv_40583.disk <= 7) && (int )ns.ldv_40583.pdsk <= 7)) && (((unsigned int )*((unsigned char *)(& os) + 0UL) != 1U || (int )os.ldv_40583.disk > 7) || (int )os.ldv_40583.pdsk > 7)) {
---
>   {
> #line 1074
>   tmp = __builtin_expect((n & -8) != 0, 0L);
> #line 1074
>   if (tmp != 0L) {
> #line 1074
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"),
>                          "i" (1074), "i" (12UL));
>     ldv_52592: ;
40431c42246
<     ns.ldv_40583.susp_nod = 1U;
---
>     goto ldv_52592;
40434a42250,42251
> #line 1075
>   p->encoding = (u8 )(((int )((signed char )p->encoding) & -128) | (int )((signed char )(n << 4)));
40436,40441c42253,42273
<   if (((unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U || (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U) || (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U) {
< #line 1077
<     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 256U) {
< #line 1078
<       ns.ldv_40583.conn = 20U;
<     } else {
---
>   return;
> }
> }
> #line 1078 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int fill_bitmap_rle_bits(struct drbd_conf *mdev , struct p_compressed_bm *p , unsigned int size ,
>                          struct bm_xfer_ctx *c ) 
> { 
>   struct bitstream bs ;
>   unsigned long plain_bits ;
>   unsigned long tmp ;
>   unsigned long rl ;
>   unsigned int len ;
>   unsigned int toggle ;
>   int bits ;
>   int use_rle ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___0 ;
>   int tmp___1 ;
>   unsigned long tmp___2 ;
>   unsigned long tmp___3 ;
40443,40447c42275,42292
<     }
< #line 1079
<     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 272U) {
< #line 1080
<       ns.ldv_40583.conn = 21U;
---
>   {
> #line 1092
>   rcu_read_lock();
> #line 1093
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 1093
>   tmp___0 = debug_lockdep_rcu_enabled();
> #line 1093
>   if (tmp___0 != 0 && ! __warned) {
> #line 1093
>     tmp___1 = rcu_read_lock_held();
> #line 1093
>     if (tmp___1 == 0 && 1) {
> #line 1093
>       __warned = 1;
> #line 1093
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>                              1093, "suspicious rcu_dereference_check() usage");
40452,40463d42296
< #line 1082
<     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 320U) {
< #line 1083
<       ns.ldv_40583.conn = 16U;
<     } else {
< 
<     }
< #line 1084
<     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 336U) {
< #line 1085
<       ns.ldv_40583.conn = 17U;
<     } else {
40465d42297
<     }
40467,40476c42299,42300
< #line 1088
<   return (ns);
< }
< }
< #line 1092 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void set_ov_position(struct drbd_conf *mdev , enum drbd_conns cs ) 
< { 
<   unsigned long bit ;
< 
<   {
---
> #line 1093
>   use_rle = (int )_________p1->use_rle;
40478c42302
<   if (mdev->agreed_pro_version <= 89) {
---
>   rcu_read_unlock();
40480c42304,42306
<     mdev->ov_start_sector = 0UL;
---
>   if (use_rle == 0 || (mdev->tconn)->agreed_pro_version <= 89) {
> #line 1096
>     return (0);
40484,40487d42309
< #line 1096
<   mdev->rs_total = drbd_bm_bits(mdev);
< #line 1097
<   mdev->ov_position = 0UL;
40489,42911c42311,42313
<   if ((unsigned int )cs == 19U) {
< #line 1104
<     mdev->ov_start_sector = 0xffffffffffffffffUL;
<   } else {
< #line 1106
<     bit = mdev->ov_start_sector >> 3;
< #line 1107
<     if (mdev->rs_total <= bit) {
< #line 1108
<       mdev->ov_start_sector = (mdev->rs_total - 1UL) << 3;
< #line 1110
<       mdev->rs_total = 1UL;
<     } else {
< #line 1112
<       mdev->rs_total = mdev->rs_total - bit;
<     }
< #line 1113
<     mdev->ov_position = mdev->ov_start_sector;
<   }
< #line 1115
<   mdev->ov_left = mdev->rs_total;
< #line 1116
<   return;
< }
< }
< #line 1118 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void drbd_resume_al(struct drbd_conf *mdev ) 
< { 
<   int tmp ;
< 
<   {
< #line 1120
<   tmp = drbd_test_and_clear_flag(mdev, AL_SUSPENDED);
< #line 1120
<   if (tmp != 0) {
< #line 1121
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Resumed AL updates\n");
<   } else {
< 
<   }
< #line 1122
<   return;
< }
< }
< #line 1134 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< enum drbd_state_rv __drbd_set_state(struct drbd_conf *mdev , union drbd_state ns ,
<                                     enum chg_state_flags flags , struct completion *done ) 
< { 
<   union drbd_state os ;
<   enum drbd_state_rv rv ;
<   enum sanitize_state_warnings ssw ;
<   struct after_state_chg_work *ascw ;
<   enum drbd_state_rv tmp ;
<   char *pbp ;
<   char pb[300U] ;
<   char const   *tmp___0 ;
<   char const   *tmp___1 ;
<   int tmp___2 ;
<   char const   *tmp___3 ;
<   char const   *tmp___4 ;
<   int tmp___5 ;
<   char const   *tmp___6 ;
<   char const   *tmp___7 ;
<   int tmp___8 ;
<   char const   *tmp___9 ;
<   char const   *tmp___10 ;
<   int tmp___11 ;
<   char const   *tmp___12 ;
<   char const   *tmp___13 ;
<   int tmp___14 ;
<   int tmp___15 ;
<   int tmp___16 ;
<   int tmp___17 ;
<   int tmp___18 ;
<   int tmp___19 ;
<   int tmp___20 ;
<   int tmp___21 ;
<   int tmp___22 ;
<   int tmp___23 ;
<   unsigned long tmp___24 ;
<   unsigned long now ;
<   int i ;
<   u32 mdf ;
<   int tmp___25 ;
<   int tmp___26 ;
<   void *tmp___27 ;
< 
<   {
< #line 1138
<   rv = 1;
< #line 1142
<   os = mdev->state;
< #line 1144
<   ns = sanitize_state(mdev, os, ns, & ssw);
< #line 1146
<   if (ns.i == os.i) {
< #line 1147
<     return (SS_NOTHING_TO_DO);
<   } else {
< 
<   }
< #line 1149
<   if (((unsigned int )flags & 1U) == 0U) {
< #line 1153
<     rv = is_valid_state(mdev, ns);
< #line 1154
<     if ((int )rv <= 0) {
< #line 1158
<       tmp = is_valid_state(mdev, os);
< #line 1158
<       if ((int )tmp == (int )rv) {
< #line 1159
<         rv = is_valid_state_transition(mdev, ns, os);
<       } else {
< #line 1161
<         rv = is_valid_state_transition(mdev, ns, os);
<       }
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1164
<   if ((int )rv <= 0) {
< #line 1165
<     if (((unsigned int )flags & 2U) != 0U) {
< #line 1166
<       print_st_err(mdev, os, ns, rv);
<     } else {
< 
<     }
< #line 1167
<     return (rv);
<   } else {
< 
<   }
< #line 1170
<   print_sanitize_warnings(mdev, ssw);
< #line 1174
<   pbp = (char *)(& pb);
< #line 1175
<   *pbp = 0;
< #line 1176
<   if ((int )ns.ldv_40583.role != (int )os.ldv_40583.role) {
< #line 1177
<     tmp___0 = drbd_role_str((enum drbd_role )ns.ldv_40583.role);
< #line 1177
<     tmp___1 = drbd_role_str((enum drbd_role )os.ldv_40583.role);
< #line 1177
<     tmp___2 = sprintf(pbp, "role( %s -> %s ) ", tmp___1, tmp___0);
< #line 1177
<     pbp = pbp + (unsigned long )tmp___2;
<   } else {
< 
<   }
< #line 1180
<   if ((int )ns.ldv_40583.peer != (int )os.ldv_40583.peer) {
< #line 1181
<     tmp___3 = drbd_role_str((enum drbd_role )ns.ldv_40583.peer);
< #line 1181
<     tmp___4 = drbd_role_str((enum drbd_role )os.ldv_40583.peer);
< #line 1181
<     tmp___5 = sprintf(pbp, "peer( %s -> %s ) ", tmp___4, tmp___3);
< #line 1181
<     pbp = pbp + (unsigned long )tmp___5;
<   } else {
< 
<   }
< #line 1184
<   if ((int )ns.ldv_40583.conn != (int )os.ldv_40583.conn) {
< #line 1185
<     tmp___6 = drbd_conn_str((enum drbd_conns )ns.ldv_40583.conn);
< #line 1185
<     tmp___7 = drbd_conn_str((enum drbd_conns )os.ldv_40583.conn);
< #line 1185
<     tmp___8 = sprintf(pbp, "conn( %s -> %s ) ", tmp___7, tmp___6);
< #line 1185
<     pbp = pbp + (unsigned long )tmp___8;
<   } else {
< 
<   }
< #line 1188
<   if ((int )ns.ldv_40583.disk != (int )os.ldv_40583.disk) {
< #line 1189
<     tmp___9 = drbd_disk_str((enum drbd_disk_state )ns.ldv_40583.disk);
< #line 1189
<     tmp___10 = drbd_disk_str((enum drbd_disk_state )os.ldv_40583.disk);
< #line 1189
<     tmp___11 = sprintf(pbp, "disk( %s -> %s ) ", tmp___10, tmp___9);
< #line 1189
<     pbp = pbp + (unsigned long )tmp___11;
<   } else {
< 
<   }
< #line 1192
<   if ((int )ns.ldv_40583.pdsk != (int )os.ldv_40583.pdsk) {
< #line 1193
<     tmp___12 = drbd_disk_str((enum drbd_disk_state )ns.ldv_40583.pdsk);
< #line 1193
<     tmp___13 = drbd_disk_str((enum drbd_disk_state )os.ldv_40583.pdsk);
< #line 1193
<     tmp___14 = sprintf(pbp, "pdsk( %s -> %s ) ", tmp___13, tmp___12);
< #line 1193
<     pbp = pbp + (unsigned long )tmp___14;
<   } else {
< 
<   }
< #line 1196
<   tmp___18 = is_susp(ns);
< #line 1196
<   tmp___19 = is_susp(os);
< #line 1196
<   if (tmp___18 != tmp___19) {
< #line 1197
<     tmp___15 = is_susp(ns);
< #line 1197
<     tmp___16 = is_susp(os);
< #line 1197
<     tmp___17 = sprintf(pbp, "susp( %d -> %d ) ", tmp___16, tmp___15);
< #line 1197
<     pbp = pbp + (unsigned long )tmp___17;
<   } else {
< 
<   }
< #line 1200
<   if ((int )ns.ldv_40583.aftr_isp != (int )os.ldv_40583.aftr_isp) {
< #line 1201
<     tmp___20 = sprintf(pbp, "aftr_isp( %d -> %d ) ", (int )os.ldv_40583.aftr_isp,
<                        (int )ns.ldv_40583.aftr_isp);
< #line 1201
<     pbp = pbp + (unsigned long )tmp___20;
<   } else {
< 
<   }
< #line 1204
<   if ((int )ns.ldv_40583.peer_isp != (int )os.ldv_40583.peer_isp) {
< #line 1205
<     tmp___21 = sprintf(pbp, "peer_isp( %d -> %d ) ", (int )os.ldv_40583.peer_isp,
<                        (int )ns.ldv_40583.peer_isp);
< #line 1205
<     pbp = pbp + (unsigned long )tmp___21;
<   } else {
< 
<   }
< #line 1208
<   if ((int )ns.ldv_40583.user_isp != (int )os.ldv_40583.user_isp) {
< #line 1209
<     tmp___22 = sprintf(pbp, "user_isp( %d -> %d ) ", (int )os.ldv_40583.user_isp,
<                        (int )ns.ldv_40583.user_isp);
< #line 1209
<     pbp = pbp + (unsigned long )tmp___22;
<   } else {
< 
<   }
< #line 1212
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s\n", (char *)(& pb));
< #line 1223
<   if (((unsigned int )*((unsigned char *)(& ns) + 1UL) == 0U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 0U) && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 2U) {
< #line 1223
<     tmp___23 = drbd_test_and_set_flag(mdev, CONFIG_PENDING);
< #line 1223
<     if (tmp___23 == 0) {
< #line 1227
<       drbd_set_flag(mdev, DEVICE_DYING);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1233
<   if (((unsigned int )*((unsigned char *)(& os) + 1UL) != 4U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 4U) || ((unsigned int )*((unsigned char *)(& os) + 1UL) != 0U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 0U)) {
< #line 1235
<     atomic_inc(& mdev->local_cnt);
<   } else {
< 
<   }
< #line 1237
<   mdev->state = ns;
< #line 1239
<   if ((unsigned int )*((unsigned char *)(& os) + 1UL) == 2U && (int )ns.ldv_40583.disk > 2) {
< #line 1240
<     drbd_print_uuids(mdev, "attached to UUIDs");
<   } else {
< 
<   }
< #line 1242
<   __wake_up(& mdev->misc_wait, 3U, 1, 0);
< #line 1243
<   __wake_up(& mdev->state_wait, 3U, 1, 0);
< #line 1247
<   if (((unsigned int )*((unsigned short *)(& os) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& os) + 0UL) == 304U) && (int )ns.ldv_40583.conn <= 10) {
< #line 1249
<     tmp___24 = drbd_bm_bits(mdev);
< #line 1249
<     mdev->ov_start_sector = (tmp___24 - mdev->ov_left) << 3;
< #line 1251
<     if (mdev->ov_left != 0UL) {
< #line 1252
<       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Online Verify reached sector %llu\n",
<                 (unsigned long long )mdev->ov_start_sector);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1256
<   if (((unsigned int )*((unsigned short *)(& os) + 0UL) == 336U || (unsigned int )*((unsigned short *)(& os) + 0UL) == 320U) && ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 272U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 256U)) {
< #line 1258
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Syncer continues.\n");
< #line 1259
<     mdev->rs_paused = mdev->rs_paused + (unsigned long )((long )jiffies - (long )mdev->rs_mark_time[mdev->rs_last_mark]);
< #line 1261
<     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 272U) {
< #line 1262
<       mod_timer(& mdev->resync_timer, jiffies);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1265
<   if (((unsigned int )*((unsigned short *)(& os) + 0UL) == 272U || (unsigned int )*((unsigned short *)(& os) + 0UL) == 256U) && ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 336U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 320U)) {
< #line 1267
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Resync suspended\n");
< #line 1268
<     mdev->rs_mark_time[mdev->rs_last_mark] = jiffies;
<   } else {
< 
<   }
< #line 1271
<   if ((unsigned int )*((unsigned short *)(& os) + 0UL) == 160U && ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 304U)) {
< #line 1273
<     now = jiffies;
< #line 1276
<     set_ov_position(mdev, (enum drbd_conns )ns.ldv_40583.conn);
< #line 1277
<     mdev->rs_start = now;
< #line 1278
<     mdev->rs_last_events = 0;
< #line 1279
<     mdev->rs_last_sect_ev = 0;
< #line 1280
<     mdev->ov_last_oos_size = 0UL;
< #line 1281
<     mdev->ov_last_oos_start = 0UL;
< #line 1283
<     i = 0;
< #line 1283
<     goto ldv_52005;
<     ldv_52004: 
< #line 1284
<     mdev->rs_mark_left[i] = mdev->ov_left;
< #line 1285
<     mdev->rs_mark_time[i] = now;
< #line 1283
<     i = i + 1;
<     ldv_52005: ;
< #line 1283
<     if (i <= 7) {
< #line 1284
<       goto ldv_52004;
<     } else {
< 
<     }
< #line 1288
<     drbd_rs_controller_reset(mdev);
< #line 1290
<     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U) {
< #line 1291
<       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Starting Online Verify from sector %llu\n",
<                 (unsigned long long )mdev->ov_position);
< #line 1293
<       mod_timer(& mdev->resync_timer, jiffies);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1297
<   tmp___26 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1297
<   if (tmp___26 != 0) {
< #line 1298
<     mdf = (mdev->ldev)->md.flags & 4294967176U;
< #line 1302
<     tmp___25 = drbd_test_flag(mdev, CRASHED_PRIMARY);
< #line 1302
<     if (tmp___25 != 0) {
< #line 1303
<       mdf = mdf | 64U;
<     } else {
< 
<     }
< #line 1304
<     if ((unsigned int )*((unsigned char *)mdev + 2276UL) == 1U || ((int )mdev->state.ldv_40583.pdsk <= 3 && (unsigned int )*((unsigned char *)mdev + 2276UL) == 4U)) {
< #line 1306
<       mdf = mdf | 2U;
<     } else {
< 
<     }
< #line 1307
<     if ((int )mdev->state.ldv_40583.conn > 9) {
< #line 1308
<       mdf = mdf | 4U;
<     } else {
< 
<     }
< #line 1309
<     if ((int )mdev->state.ldv_40583.disk > 4) {
< #line 1310
<       mdf = mdf | 1U;
<     } else {
< 
<     }
< #line 1311
<     if ((int )mdev->state.ldv_40583.disk > 5) {
< #line 1312
<       mdf = mdf | 16U;
<     } else {
< 
<     }
< #line 1313
<     if ((int )mdev->state.ldv_40583.pdsk <= 5 && (int )mdev->state.ldv_40583.pdsk > 3) {
< #line 1314
<       mdf = mdf | 32U;
<     } else {
< 
<     }
< #line 1315
<     if ((mdev->ldev)->md.flags != mdf) {
< #line 1316
<       (mdev->ldev)->md.flags = mdf;
< #line 1317
<       drbd_md_mark_dirty(mdev);
<     } else {
< 
<     }
< #line 1319
<     if ((int )os.ldv_40583.disk <= 6 && (int )ns.ldv_40583.disk > 6) {
< #line 1320
<       drbd_set_ed_uuid(mdev, (mdev->ldev)->md.uuid[0]);
<     } else {
< 
<     }
< #line 1321
<     put_ldev(mdev);
<   } else {
< 
<   }
< #line 1325
<   if ((((unsigned int )*((unsigned char *)(& os) + 1UL) == 8U && *((unsigned int *)(& os) + 0UL) == 32768U) && (unsigned int )*((unsigned char *)(& os) + 0UL) == 8U) && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 4U) {
< #line 1327
<     drbd_set_flag(mdev, CONSIDER_RESYNC);
<   } else {
< 
<   }
< #line 1330
<   if ((unsigned int )*((unsigned short *)(& os) + 0UL) != 16U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 16U) {
< #line 1331
<     drbd_thread_stop_nowait(& mdev->receiver);
<   } else {
< 
<   }
< #line 1334
<   if ((unsigned int )*((unsigned short *)(& os) + 0UL) != 0U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 0U) {
< #line 1335
<     drbd_thread_stop_nowait(& mdev->receiver);
<   } else {
< 
<   }
< #line 1338
<   if (((int )os.ldv_40583.conn > 8 && (int )ns.ldv_40583.conn <= 7) && (int )ns.ldv_40583.conn > 2) {
< #line 1340
<     drbd_thread_restart_nowait(& mdev->receiver);
<   } else {
< 
<   }
< #line 1343
<   if ((int )os.ldv_40583.conn <= 9 && (int )ns.ldv_40583.conn > 9) {
< #line 1344
<     drbd_resume_al(mdev);
<   } else {
< 
<   }
< #line 1349
<   if ((unsigned int )*((unsigned short *)(& os) + 0UL) != 144U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 144U) {
< #line 1350
<     mdev->last_reconnect_jif = jiffies;
<   } else {
< 
<   }
< #line 1351
<   if (((unsigned int )*((unsigned char *)(& os) + 1UL) == 2U || (unsigned int )*((unsigned char *)(& os) + 1UL) == 6U) && (int )ns.ldv_40583.disk > 3) {
< #line 1353
<     mdev->last_reattach_jif = jiffies;
<   } else {
< 
<   }
< #line 1355
<   tmp___27 = kmalloc(48UL, 32U);
< #line 1355
<   ascw = (struct after_state_chg_work *)tmp___27;
< #line 1356
<   if ((unsigned long )ascw != (unsigned long )((struct after_state_chg_work *)0)) {
< #line 1357
<     ascw->os = os;
< #line 1358
<     ascw->ns = ns;
< #line 1359
<     ascw->flags = flags;
< #line 1360
<     ascw->w.cb = & w_after_state_ch;
< #line 1361
<     ascw->done = done;
< #line 1362
<     drbd_queue_work(& mdev->data.work, & ascw->w);
<   } else {
< #line 1364
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Could not kmalloc an ascw\n");
<   }
< #line 1367
<   return (rv);
< }
< }
< #line 1370 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static int w_after_state_ch(struct drbd_conf *mdev , struct drbd_work *w , int unused ) 
< { 
<   struct after_state_chg_work *ascw ;
<   struct drbd_work  const  *__mptr ;
< 
<   {
< #line 1373
<   __mptr = (struct drbd_work  const  *)w;
< #line 1373
<   ascw = (struct after_state_chg_work *)__mptr;
< #line 1374
<   after_state_ch(mdev, ascw->os, ascw->ns, ascw->flags);
< #line 1375
<   if (((unsigned int )ascw->flags & 4U) != 0U) {
< #line 1376
<     if ((unsigned long )ascw->done == (unsigned long )((struct completion *)0)) {
< #line 1376
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( ascw->done != NULL ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<               1376);
<     } else {
< 
<     }
< #line 1377
<     complete(ascw->done);
<   } else {
< 
<   }
< #line 1379
<   kfree((void const   *)ascw);
< #line 1381
<   return (1);
< }
< }
< #line 1384 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void abw_start_sync(struct drbd_conf *mdev , int rv ) 
< { 
<   union drbd_state val ;
<   union drbd_state mask ;
<   union drbd_state val___0 ;
<   union drbd_state mask___0 ;
< 
<   {
< #line 1386
<   if (rv != 0) {
< #line 1387
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Writing the bitmap failed not starting resync.\n");
< #line 1388
<     val.i = 0U;
< #line 1388
<     val.ldv_40583.conn = 10U;
< #line 1388
<     mask.i = 0U;
< #line 1388
<     mask.ldv_40583.conn = 31U;
< #line 1388
<     _drbd_request_state(mdev, mask, val, CS_VERBOSE);
< #line 1389
<     return;
<   } else {
< 
<   }
< #line 1392
<   switch ((int )mdev->state.ldv_40583.conn) {
<   case 12: 
< #line 1394
<   val___0.i = 0U;
< #line 1394
<   val___0.ldv_40583.conn = 15U;
< #line 1394
<   mask___0.i = 0U;
< #line 1394
<   mask___0.ldv_40583.conn = 31U;
< #line 1394
<   _drbd_request_state(mdev, mask___0, val___0, CS_VERBOSE);
< #line 1395
<   goto ldv_52029;
<   case 11: 
< #line 1397
<   drbd_start_resync(mdev, C_SYNC_SOURCE);
< #line 1398
<   goto ldv_52029;
<   }
<   ldv_52029: ;
< #line 1401
<   return;
< }
< }
< #line 1402 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_bitmap_io_from_worker(struct drbd_conf *mdev , int (*io_fn)(struct drbd_conf * ) ,
<                                char *why , enum bm_flag flags ) 
< { 
<   int rv ;
<   struct task_struct *tmp ;
< 
<   {
< #line 1408
<   tmp = get_current();
< #line 1408
<   if ((unsigned long )tmp != (unsigned long )mdev->worker.task) {
< #line 1408
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( current == mdev->worker.task ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             1408);
<   } else {
< 
<   }
< #line 1411
<   drbd_set_flag(mdev, SUSPEND_IO);
< #line 1413
<   drbd_bm_lock(mdev, why, flags);
< #line 1414
<   rv = (*io_fn)(mdev);
< #line 1415
<   drbd_bm_unlock(mdev);
< #line 1417
<   drbd_resume_io(mdev);
< #line 1419
<   return (rv);
< }
< }
< #line 1429 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void after_state_ch(struct drbd_conf *mdev , union drbd_state os , union drbd_state ns ,
<                            enum chg_state_flags flags ) 
< { 
<   enum drbd_fencing_p fp ;
<   enum drbd_req_event what ;
<   union drbd_state nsm ;
<   int tmp ;
<   int tmp___0 ;
<   union drbd_state __ns ;
<   int tmp___1 ;
<   int tmp___2 ;
<   int tmp___3 ;
<   int tmp___4 ;
<   int tmp___5 ;
<   enum drbd_io_error_p eh ;
<   int tmp___6 ;
<   int tmp___7 ;
<   char const   *tmp___8 ;
<   char const   *tmp___9 ;
<   int tmp___10 ;
<   int tmp___11 ;
<   int tmp___12 ;
<   int tmp___13 ;
< 
<   {
< #line 1433
<   what = nothing;
< #line 1434
<   nsm.i = 4294967295U;
< #line 1436
<   if ((unsigned int )*((unsigned short *)(& os) + 0UL) != 160U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 160U) {
< #line 1437
<     drbd_clear_flag(mdev, CRASHED_PRIMARY);
< #line 1438
<     if ((unsigned long )mdev->p_uuid != (unsigned long )((u64 *)0)) {
< #line 1439
<       *(mdev->p_uuid + 5UL) = *(mdev->p_uuid + 5UL) & 0xfffffffffffffffdULL;
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1442
<   fp = FP_DONT_CARE;
< #line 1443
<   tmp = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1443
<   if (tmp != 0) {
< #line 1444
<     fp = (enum drbd_fencing_p )(mdev->ldev)->dc.fencing;
< #line 1445
<     put_ldev(mdev);
<   } else {
< 
<   }
< #line 1449
<   drbd_bcast_state(mdev, ns);
< #line 1451
<   if ((((unsigned int )*((unsigned char *)(& os) + 0UL) != 1U || (int )os.ldv_40583.disk > 7) || (int )os.ldv_40583.pdsk > 7) && (((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U && (int )ns.ldv_40583.disk <= 7) && (int )ns.ldv_40583.pdsk <= 7)) {
< #line 1453
<     drbd_khelper(mdev, (char *)"pri-on-incon-degr");
<   } else {
< 
<   }
< #line 1458
<   if ((int )os.ldv_40583.disk <= 3 && (int )ns.ldv_40583.disk > 3) {
< #line 1459
<     mod_timer(& mdev->request_timer, (unsigned long )jiffies + 250UL);
<   } else {
< 
<   }
< #line 1461
<   nsm.i = 4294967295U;
< #line 1462
<   if ((unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U) {
< #line 1463
<     if ((int )os.ldv_40583.conn <= 9 && (int )ns.ldv_40583.conn > 9) {
< #line 1464
<       what = resend;
<     } else {
< 
<     }
< #line 1466
<     if (((unsigned int )*((unsigned char *)(& os) + 1UL) == 2U || (unsigned int )*((unsigned char *)(& os) + 1UL) == 6U) && (int )ns.ldv_40583.disk > 3) {
< #line 1468
<       what = restart_frozen_disk_io;
<     } else {
< 
<     }
< #line 1470
<     if ((unsigned int )what != 27U) {
< #line 1471
<       nsm.ldv_40583.susp_nod = 0U;
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1474
<   if ((unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U) {
< #line 1476
<     if ((int )os.ldv_40583.pdsk > 5 && (int )ns.ldv_40583.pdsk <= 5) {
< #line 1477
<       tmp___0 = drbd_test_flag(mdev, NEW_CUR_UUID);
< #line 1477
<       if (tmp___0 != 0) {
< #line 1478
<         drbd_uuid_new_current(mdev);
< #line 1479
<         drbd_clear_flag(mdev, NEW_CUR_UUID);
<       } else {
< 
<       }
< #line 1481
<       spin_lock_irq(& mdev->req_lock);
< #line 1482
<       _tl_clear(mdev);
< #line 1483
<       __ns.i = mdev->state.i;
< #line 1483
<       __ns.ldv_40583.susp_fen = 0U;
< #line 1483
<       _drbd_set_state(mdev, __ns, CS_VERBOSE, 0);
< #line 1484
<       spin_unlock_irq(& mdev->req_lock);
<     } else {
< 
<     }
< #line 1487
<     if ((int )os.ldv_40583.conn <= 9 && (int )ns.ldv_40583.conn > 9) {
< #line 1488
<       drbd_clear_flag(mdev, NEW_CUR_UUID);
< #line 1489
<       what = resend;
< #line 1490
<       nsm.ldv_40583.susp_fen = 0U;
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1494
<   if ((unsigned int )what != 27U) {
< #line 1495
<     spin_lock_irq(& mdev->req_lock);
< #line 1496
<     _tl_restart(mdev, what);
< #line 1497
<     nsm.i = nsm.i & mdev->state.i;
< #line 1498
<     _drbd_set_state(mdev, nsm, CS_VERBOSE, 0);
< #line 1499
<     spin_unlock_irq(& mdev->req_lock);
<   } else {
< 
<   }
< #line 1506
<   if ((((unsigned int )*((unsigned short *)(& os) + 0UL) != 256U && (unsigned int )*((unsigned short *)(& os) + 0UL) != 320U) && ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 256U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 320U)) && mdev->agreed_pro_version > 95) {
< #line 1506
<     tmp___1 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1506
<     if (tmp___1 != 0) {
< #line 1509
<       drbd_gen_and_send_sync_uuid(mdev);
< #line 1510
<       put_ldev(mdev);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1514
<   if (*((unsigned int *)(& os) + 0UL) == 0U && (int )ns.ldv_40583.pdsk > 0) {
< #line 1517
<     mdev->rs_total = 0UL;
< #line 1518
<     mdev->rs_failed = 0UL;
< #line 1519
<     atomic_set(& mdev->rs_pending_cnt, 0);
< #line 1520
<     drbd_rs_cancel_all(mdev);
< #line 1522
<     drbd_send_uuids(mdev);
< #line 1523
<     drbd_send_state(mdev, ns);
<   } else {
< 
<   }
< #line 1528
<   if (((unsigned int )*((unsigned short *)(& os) + 0UL) != 208U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 208U) && (unsigned int )*((unsigned short *)mdev + 1138UL) == 208U) {
< #line 1530
<     drbd_queue_bitmap_io(mdev, & drbd_send_bitmap, 0, (char *)"send_bitmap (WFBitMapS)",
<                          BM_LOCKED_TEST_ALLOWED);
<   } else {
< 
<   }
< #line 1535
<   if ((((int )os.ldv_40583.pdsk > 3 && *((unsigned int *)(& os) + 0UL) != 49152U) && *((unsigned int *)(& os) + 0UL) != 40960U) && (((int )ns.ldv_40583.pdsk <= 3 || *((unsigned int *)(& ns) + 0UL) == 49152U) || *((unsigned int *)(& ns) + 0UL) == 40960U)) {
< #line 1541
<     tmp___3 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1541
<     if (tmp___3 != 0) {
< #line 1542
<       if ((((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U || (unsigned int )*((unsigned char *)(& ns) + 0UL) == 4U) && (mdev->ldev)->md.uuid[1] == 0ULL) && (int )ns.ldv_40583.disk > 7) {
< #line 1544
<         tmp___2 = is_susp(mdev->state);
< #line 1544
<         if (tmp___2 != 0) {
< #line 1545
<           drbd_set_flag(mdev, NEW_CUR_UUID);
<         } else {
< #line 1547
<           drbd_uuid_new_current(mdev);
< #line 1548
<           drbd_send_uuids(mdev);
<         }
<       } else {
< 
<       }
< #line 1551
<       put_ldev(mdev);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1555
<   if ((int )ns.ldv_40583.pdsk <= 3) {
< #line 1555
<     tmp___4 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1555
<     if (tmp___4 != 0) {
< #line 1556
<       if ((((unsigned int )*((unsigned char *)(& os) + 0UL) == 8U && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 4U) && (mdev->ldev)->md.uuid[1] == 0ULL) && (int )ns.ldv_40583.disk > 7) {
< #line 1558
<         drbd_uuid_new_current(mdev);
< #line 1559
<         drbd_send_uuids(mdev);
<       } else {
< 
<       }
< #line 1562
<       if ((unsigned int )*((unsigned char *)(& os) + 0UL) == 4U && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 8U) {
< #line 1566
<         drbd_bitmap_io_from_worker(mdev, & drbd_bm_write, (char *)"demote diskless peer",
<                                    BM_LOCKED_SET_ALLOWED);
<       } else {
< 
<       }
< #line 1568
<       put_ldev(mdev);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1574
<   if (((unsigned int )*((unsigned char *)(& os) + 0UL) == 1U && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 2U) && (int )mdev->state.ldv_40583.conn <= 10) {
< #line 1574
<     tmp___5 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1574
<     if (tmp___5 != 0) {
< #line 1578
<       drbd_bitmap_io_from_worker(mdev, & drbd_bm_write, (char *)"demote", BM_LOCKED_TEST_ALLOWED);
< #line 1580
<       put_ldev(mdev);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1584
<   if (((int )ns.ldv_40583.conn > 9 && (unsigned int )*((unsigned char *)(& os) + 1UL) == 2U) && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 6U) {
< #line 1586
<     drbd_send_sizes(mdev, 0, 0);
< #line 1587
<     drbd_send_uuids(mdev);
< #line 1588
<     drbd_send_state(mdev, ns);
<   } else {
< 
<   }
< #line 1592
<   if ((int )ns.ldv_40583.conn > 9 && ((int )os.ldv_40583.aftr_isp != (int )ns.ldv_40583.aftr_isp || (int )os.ldv_40583.user_isp != (int )ns.ldv_40583.user_isp)) {
< #line 1595
<     drbd_send_state(mdev, ns);
<   } else {
< 
<   }
< #line 1598
<   if ((((unsigned int )*((unsigned char *)(& os) + 2UL) == 0U && (unsigned int )*((unsigned char *)(& os) + 2UL) == 0U) && (unsigned int )*((unsigned char *)(& os) + 2UL) == 0U) && (((unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U || (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U) || (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U)) {
< #line 1600
<     suspend_other_sg(mdev);
<   } else {
< 
<   }
< #line 1604
<   if ((unsigned int )*((unsigned short *)(& os) + 0UL) == 144U && (int )ns.ldv_40583.conn > 9) {
< #line 1605
<     drbd_send_state(mdev, ns);
<   } else {
< 
<   }
< #line 1607
<   if ((unsigned int )*((unsigned short *)(& os) + 0UL) != 352U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 352U) {
< #line 1608
<     drbd_send_state(mdev, ns);
<   } else {
< 
<   }
< #line 1611
<   if (((unsigned int )*((unsigned short *)(& os) + 0UL) != 192U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 192U) || ((unsigned int )*((unsigned short *)(& os) + 0UL) != 176U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 176U)) {
< #line 1614
<     drbd_queue_bitmap_io(mdev, & drbd_bmio_set_n_write, & abw_start_sync, (char *)"set_n_write from StartingSync",
<                          BM_LOCKED_TEST_ALLOWED);
<   } else {
< 
<   }
< #line 1619
<   if ((((int )os.ldv_40583.conn <= 9 && (int )ns.ldv_40583.conn <= 9) && (int )os.ldv_40583.disk > 4) && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 8U) {
< #line 1622
<     drbd_queue_bitmap_io(mdev, & drbd_bmio_set_n_write, 0, (char *)"set_n_write from invalidate",
<                          BM_LOCKED_MASK);
<   } else {
< 
<   }
< #line 1627
<   if ((unsigned int )*((unsigned char *)(& os) + 1UL) != 4U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 4U) {
< #line 1632
<     if ((unsigned long )mdev->ldev != (unsigned long )((struct drbd_backing_dev *)0)) {
< #line 1633
<       eh = (enum drbd_io_error_p )(mdev->ldev)->dc.on_io_error;
< #line 1641
<       if ((unsigned int )eh == 1U) {
< #line 1641
<         tmp___6 = drbd_test_flag(mdev, WAS_IO_ERROR);
< #line 1641
<         if (tmp___6 != 0) {
< #line 1642
<           drbd_khelper(mdev, (char *)"local-io-error");
<         } else {
< 
<         }
<       } else {
< 
<       }
< #line 1657
<       tmp___7 = drbd_test_flag(mdev, FORCE_DETACH);
< #line 1657
<       if (tmp___7 != 0) {
< #line 1658
<         tl_abort_disk_io(mdev);
<       } else {
< 
<       }
< #line 1663
<       if ((unsigned int )*((unsigned char *)mdev + 2277UL) != 4U) {
< #line 1664
<         tmp___8 = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_40583.disk);
< #line 1664
<         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: disk is %s during detach\n",
<                 tmp___8);
<       } else {
< 
<       }
< #line 1668
<       if ((int )ns.ldv_40583.conn > 9) {
< #line 1669
<         drbd_send_state(mdev, ns);
<       } else {
< 
<       }
< #line 1671
<       drbd_rs_cancel_all(mdev);
< #line 1676
<       drbd_md_sync(mdev);
<     } else {
< 
<     }
< #line 1678
<     put_ldev(mdev);
<   } else {
< 
<   }
< #line 1684
<   if ((unsigned int )*((unsigned char *)(& os) + 1UL) != 0U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 0U) {
< #line 1687
<     if ((unsigned int )*((unsigned char *)mdev + 2277UL) != 0U) {
< #line 1688
<       tmp___9 = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_40583.disk);
< #line 1688
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: disk is %s while going diskless\n",
<               tmp___9);
<     } else {
< 
<     }
< #line 1692
<     if ((int )ns.ldv_40583.conn > 9) {
< #line 1693
<       drbd_send_state(mdev, ns);
<     } else {
< 
<     }
< #line 1697
<     put_ldev(mdev);
<   } else {
< 
<   }
< #line 1701
<   if (((unsigned int )*((unsigned char *)(& os) + 1UL) == 16U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 8U) && (int )ns.ldv_40583.conn > 9) {
< #line 1702
<     drbd_send_state(mdev, ns);
<   } else {
< 
<   }
< #line 1705
<   if ((int )ns.ldv_40583.disk > 3 && (int )ns.ldv_40583.pdsk > 3) {
< #line 1705
<     tmp___10 = drbd_test_and_clear_flag(mdev, RESYNC_AFTER_NEG);
< #line 1705
<     if (tmp___10 != 0) {
< #line 1707
<       if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 160U) {
< #line 1708
<         resync_after_online_grow(mdev);
<       } else {
< 
<       }
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1712
<   if ((((int )os.ldv_40583.conn > 10 && (int )ns.ldv_40583.conn <= 10) || ((unsigned int )*((unsigned char *)(& os) + 2UL) != 0U && (unsigned int )*((unsigned char *)(& ns) + 2UL) == 0U)) || ((unsigned int )*((unsigned char *)(& os) + 2UL) != 0U && (unsigned int )*((unsigned char *)(& ns) + 2UL) == 0U)) {
< #line 1715
<     resume_next_sg(mdev);
<   } else {
< 
<   }
< #line 1719
<   if (((int )os.ldv_40583.disk <= 7 && (int )os.ldv_40583.conn > 15) && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 160U) {
< #line 1720
<     drbd_send_state(mdev, ns);
<   } else {
< 
<   }
< #line 1725
<   if (((unsigned int )*((unsigned short *)(& os) + 0UL) == 288U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 160U) && mdev->agreed_pro_version > 96) {
< #line 1727
<     drbd_send_state(mdev, ns);
<   } else {
< 
<   }
< #line 1730
<   if ((unsigned int )*((unsigned short *)(& os) + 0UL) == 144U && (unsigned int )*((unsigned short *)(& ns) + 0UL) != 144U) {
< #line 1731
<     drbd_clear_flag(mdev, STATE_SENT);
< #line 1732
<     __wake_up(& mdev->state_wait, 3U, 1, 0);
<   } else {
< 
<   }
< #line 1742
<   if ((int )os.ldv_40583.conn > 10 && (int )ns.ldv_40583.conn <= 10) {
< #line 1742
<     tmp___11 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1742
<     if (tmp___11 != 0) {
< #line 1743
<       drbd_queue_bitmap_io(mdev, & drbd_bm_write_copy_pages, 0, (char *)"write from resync_finished",
<                            BM_IS_LOCKED);
< #line 1745
<       put_ldev(mdev);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1749
<   if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 0U) {
< #line 1749
<     tmp___12 = is_susp(ns);
< #line 1749
<     if (tmp___12 == 0) {
< #line 1749
<       if ((unsigned long )mdev->tl_hash != (unsigned long )((struct hlist_head *)0)) {
< #line 1750
<         drbd_free_tl_hash(mdev);
<       } else {
< 
<       }
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1753
<   if ((unsigned int )*((unsigned short *)(& os) + 0UL) == 0U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 32U) {
< #line 1754
<     drbd_thread_start(& mdev->receiver);
<   } else {
< 
<   }
< #line 1758
<   if (((unsigned int )*((unsigned char *)(& ns) + 1UL) == 0U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 0U) && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 2U) {
< #line 1761
<     if ((int )os.ldv_40583.aftr_isp != (int )ns.ldv_40583.aftr_isp) {
< #line 1762
<       resume_next_sg(mdev);
<     } else {
< 
<     }
< #line 1764
<     tmp___13 = drbd_test_flag(mdev, DEVICE_DYING);
< #line 1764
<     if (tmp___13 != 0) {
< #line 1765
<       drbd_thread_stop_nowait(& mdev->worker);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1768
<   drbd_md_sync(mdev);
< #line 1769
<   return;
< }
< }
< #line 1772 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static int drbd_thread_setup(void *arg ) 
< { 
<   struct drbd_thread *thi ;
<   struct drbd_conf *mdev ;
<   unsigned long flags ;
<   int retval ;
<   raw_spinlock_t *tmp ;
<   struct task_struct *tmp___0 ;
<   struct task_struct *tmp___1 ;
< 
<   {
< #line 1774
<   thi = (struct drbd_thread *)arg;
< #line 1775
<   mdev = thi->mdev;
<   restart: 
< #line 1780
<   retval = (*(thi->function))(thi);
< #line 1782
<   tmp = spinlock_check(& thi->t_lock);
< #line 1782
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 1794
<   if ((unsigned int )thi->t_state == 3U) {
< #line 1795
<     tmp___0 = get_current();
< #line 1795
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Restarting %s\n",
<               (char *)(& tmp___0->comm));
< #line 1796
<     thi->t_state = Running;
< #line 1797
<     spin_unlock_irqrestore(& thi->t_lock, flags);
< #line 1798
<     goto restart;
<   } else {
< 
<   }
< #line 1801
<   thi->task = 0;
< #line 1802
<   thi->t_state = None;
< #line 1803
<   __asm__  volatile   ("mfence": : : "memory");
< #line 1804
<   complete(& thi->stop);
< #line 1805
<   spin_unlock_irqrestore(& thi->t_lock, flags);
< #line 1807
<   tmp___1 = get_current();
< #line 1807
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Terminating %s\n",
<             (char *)(& tmp___1->comm));
< #line 1810
<   ldv_module_put_4(& __this_module);
< #line 1811
<   return (retval);
< }
< }
< #line 1814 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void drbd_thread_init(struct drbd_conf *mdev , struct drbd_thread *thi , int (*func)(struct drbd_thread * ) ) 
< { 
<   struct lock_class_key __key ;
< 
<   {
< #line 1817
<   spinlock_check(& thi->t_lock);
< #line 1817
<   __raw_spin_lock_init(& thi->t_lock.ldv_6135.rlock, "&(&thi->t_lock)->rlock", & __key);
< #line 1818
<   thi->task = 0;
< #line 1819
<   thi->t_state = None;
< #line 1820
<   thi->function = func;
< #line 1821
<   thi->mdev = mdev;
< #line 1822
<   return;
< }
< }
< #line 1824 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_thread_start(struct drbd_thread *thi ) 
< { 
<   struct drbd_conf *mdev ;
<   struct task_struct *nt ;
<   unsigned long flags ;
<   char const   *me ;
<   raw_spinlock_t *tmp ;
<   struct task_struct *tmp___0 ;
<   struct task_struct *tmp___1 ;
<   bool tmp___2 ;
<   int tmp___3 ;
<   struct task_struct *tmp___4 ;
<   unsigned int tmp___5 ;
<   long tmp___6 ;
<   raw_spinlock_t *tmp___7 ;
<   struct task_struct *tmp___8 ;
<   struct task_struct *tmp___9 ;
< 
<   {
< #line 1826
<   mdev = thi->mdev;
< #line 1830
<   me = (unsigned long )(& mdev->receiver) != (unsigned long )thi ? ((unsigned long )(& mdev->asender) != (unsigned long )thi ? ((unsigned long )(& mdev->worker) == (unsigned long )thi ? "worker" : "NONSENSE") : "asender") : "receiver";
< #line 1837
<   tmp = spinlock_check(& thi->t_lock);
< #line 1837
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 1839
<   switch ((unsigned int )thi->t_state) {
<   case 0U: 
< #line 1841
<   tmp___0 = get_current();
< #line 1841
<   tmp___1 = get_current();
< #line 1841
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Starting %s thread (from %s [%d])\n",
<             me, (char *)(& tmp___1->comm), tmp___0->pid);
< #line 1845
<   tmp___2 = ldv_try_module_get_5(& __this_module);
< #line 1845
<   if (tmp___2) {
< #line 1845
<     tmp___3 = 0;
<   } else {
< #line 1845
<     tmp___3 = 1;
<   }
< #line 1845
<   if (tmp___3) {
< #line 1846
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Failed to get module reference in drbd_thread_start\n");
< #line 1847
<     spin_unlock_irqrestore(& thi->t_lock, flags);
< #line 1848
<     return (0);
<   } else {
< 
<   }
< #line 1851
<   init_completion(& thi->stop);
< #line 1852
<   if ((unsigned long )thi->task != (unsigned long )((struct task_struct *)0)) {
< #line 1852
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( thi->task == NULL ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             1852);
<   } else {
< 
<   }
< #line 1853
<   thi->reset_cpu_mask = 1;
< #line 1854
<   thi->t_state = Running;
< #line 1855
<   spin_unlock_irqrestore(& thi->t_lock, flags);
< #line 1856
<   tmp___4 = get_current();
< #line 1856
<   flush_signals(tmp___4);
< #line 1858
<   tmp___5 = mdev_to_minor(mdev);
< #line 1858
<   nt = kthread_create_on_node(& drbd_thread_setup, (void *)thi, -1, "drbd%d_%s", tmp___5,
<                               me);
< #line 1861
<   tmp___6 = IS_ERR((void const   *)nt);
< #line 1861
<   if (tmp___6 != 0L) {
< #line 1862
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Couldn\'t start thread\n");
< #line 1864
<     ldv_module_put_6(& __this_module);
< #line 1865
<     return (0);
<   } else {
< 
<   }
< #line 1867
<   tmp___7 = spinlock_check(& thi->t_lock);
< #line 1867
<   flags = _raw_spin_lock_irqsave(tmp___7);
< #line 1868
<   thi->task = nt;
< #line 1869
<   thi->t_state = Running;
< #line 1870
<   spin_unlock_irqrestore(& thi->t_lock, flags);
< #line 1871
<   wake_up_process(nt);
< #line 1872
<   goto ldv_52084;
<   case 2U: 
< #line 1874
<   thi->t_state = Restarting;
< #line 1875
<   tmp___8 = get_current();
< #line 1875
<   tmp___9 = get_current();
< #line 1875
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Restarting %s thread (from %s [%d])\n",
<             me, (char *)(& tmp___9->comm), tmp___8->pid);
<   case 1U: ;
<   case 3U: ;
<   default: 
< #line 1881
<   spin_unlock_irqrestore(& thi->t_lock, flags);
< #line 1882
<   goto ldv_52084;
<   }
<   ldv_52084: ;
< #line 1885
<   return (1);
< }
< }
< #line 1889 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void _drbd_thread_stop(struct drbd_thread *thi , int restart , int wait ) 
< { 
<   unsigned long flags ;
<   enum drbd_thread_state ns ;
<   raw_spinlock_t *tmp ;
<   struct task_struct *tmp___0 ;
< 
<   {
< #line 1893
<   ns = restart != 0 ? Restarting : Exiting;
< #line 1896
<   tmp = spinlock_check(& thi->t_lock);
< #line 1896
<   flags = _raw_spin_lock_irqsave(tmp);
< #line 1898
<   if ((unsigned int )thi->t_state == 0U) {
< #line 1899
<     spin_unlock_irqrestore(& thi->t_lock, flags);
< #line 1900
<     if (restart != 0) {
< #line 1901
<       drbd_thread_start(thi);
<     } else {
< 
<     }
< #line 1902
<     return;
<   } else {
< 
<   }
< #line 1905
<   if ((unsigned int )thi->t_state != (unsigned int )ns) {
< #line 1906
<     if ((unsigned long )thi->task == (unsigned long )((struct task_struct *)0)) {
< #line 1907
<       spin_unlock_irqrestore(& thi->t_lock, flags);
< #line 1908
<       return;
<     } else {
< 
<     }
< #line 1911
<     thi->t_state = ns;
< #line 1912
<     __asm__  volatile   ("mfence": : : "memory");
< #line 1913
<     init_completion(& thi->stop);
< #line 1914
<     tmp___0 = get_current();
< #line 1914
<     if ((unsigned long )thi->task != (unsigned long )tmp___0) {
< #line 1915
<       force_sig(1, thi->task);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1919
<   spin_unlock_irqrestore(& thi->t_lock, flags);
< #line 1921
<   if (wait != 0) {
< #line 1922
<     wait_for_completion(& thi->stop);
<   } else {
< 
<   }
< #line 1923
<   return;
< }
< }
< #line 1933 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void drbd_calc_cpu_mask(struct drbd_conf *mdev ) 
< { 
<   int ord ;
<   int cpu ;
<   unsigned int tmp ;
<   unsigned int tmp___0 ;
<   unsigned int tmp___1 ;
<   int tmp___2 ;
<   unsigned int tmp___3 ;
< 
<   {
< #line 1938
<   tmp = cpumask_weight((struct cpumask  const  *)mdev->cpu_mask);
< #line 1938
<   if (tmp != 0U) {
< #line 1939
<     return;
<   } else {
< 
<   }
< #line 1941
<   tmp___0 = mdev_to_minor(mdev);
< #line 1941
<   tmp___1 = cpumask_weight(cpu_online_mask);
< #line 1941
<   ord = (int )(tmp___0 % tmp___1);
< #line 1942
<   cpu = -1;
< #line 1942
<   goto ldv_52105;
<   ldv_52104: 
< #line 1943
<   tmp___2 = ord;
< #line 1943
<   ord = ord - 1;
< #line 1943
<   if (tmp___2 == 0) {
< #line 1944
<     cpumask_set_cpu((unsigned int )cpu, mdev->cpu_mask);
< #line 1945
<     return;
<   } else {
< 
<   }
<   ldv_52105: 
< #line 1942
<   tmp___3 = cpumask_next(cpu, cpu_online_mask);
< #line 1942
<   cpu = (int )tmp___3;
< #line 1942
<   if (cpu < nr_cpu_ids) {
< #line 1943
<     goto ldv_52104;
<   } else {
< 
<   }
< #line 1949
<   cpumask_setall(mdev->cpu_mask);
< #line 1950
<   return;
< }
< }
< #line 1959 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void drbd_thread_current_set_cpu(struct drbd_conf *mdev ) 
< { 
<   struct task_struct *p ;
<   struct task_struct *tmp ;
<   struct drbd_thread *thi ;
<   int _b ;
< 
<   {
< #line 1961
<   tmp = get_current();
< #line 1961
<   p = tmp;
< #line 1962
<   thi = (unsigned long )mdev->asender.task == (unsigned long )p ? & mdev->asender : ((unsigned long )mdev->receiver.task == (unsigned long )p ? & mdev->receiver : ((unsigned long )mdev->worker.task == (unsigned long )p ? & mdev->worker : 0));
< #line 1967
<   _b = (unsigned long )thi == (unsigned long )((struct drbd_thread *)0);
< #line 1967
<   if (_b != 0) {
< #line 1967
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_thread_current_set_cpu", (char *)"thi == NULL", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             1967);
<   } else {
< 
<   }
< #line 1967
<   if (_b != 0) {
< #line 1968
<     return;
<   } else {
< 
<   }
< #line 1969
<   if (thi->reset_cpu_mask == 0) {
< #line 1970
<     return;
<   } else {
< 
<   }
< #line 1971
<   thi->reset_cpu_mask = 0;
< #line 1972
<   set_cpus_allowed_ptr(p, (struct cpumask  const  *)mdev->cpu_mask);
< #line 1973
<   return;
< }
< }
< #line 1977 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int _drbd_send_cmd(struct drbd_conf *mdev , struct socket *sock , enum drbd_packets cmd ,
<                    struct p_header80 *h , size_t size , unsigned int msg_flags ) 
< { 
<   int sent ;
<   int ok ;
<   int _b ;
<   int _b___0 ;
<   __u16 tmp ;
<   __u16 tmp___0 ;
<   char const   *tmp___1 ;
<   struct task_struct *tmp___2 ;
<   int tmp___3 ;
< 
<   {
< #line 1983
<   _b = (unsigned long )h == (unsigned long )((struct p_header80 *)0);
< #line 1983
<   if (_b != 0) {
< #line 1983
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "_drbd_send_cmd", (char *)"!h", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             1983);
<   } else {
< 
<   }
< #line 1983
<   if (_b != 0) {
< #line 1983
<     return (0);
<   } else {
< 
<   }
< #line 1984
<   _b___0 = size == 0UL;
< #line 1984
<   if (_b___0 != 0) {
< #line 1984
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "_drbd_send_cmd", (char *)"!size", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             1984);
<   } else {
< 
<   }
< #line 1984
<   if (_b___0 != 0) {
< #line 1984
<     return (0);
<   } else {
< 
<   }
< #line 1986
<   h->magic = 1728214147U;
< #line 1987
<   tmp = __fswab16((int )((__u16 )cmd));
< #line 1987
<   h->command = tmp;
< #line 1988
<   tmp___0 = __fswab16((int )((unsigned int )((__u16 )size) - 8U));
< #line 1988
<   h->length = tmp___0;
< #line 1990
<   sent = drbd_send(mdev, sock, (void *)h, size, msg_flags);
< #line 1992
<   ok = (size_t )sent == size;
< #line 1993
<   if (ok == 0) {
< #line 1993
<     tmp___2 = get_current();
< #line 1993
<     tmp___3 = signal_pending(tmp___2);
< #line 1993
<     if (tmp___3 == 0) {
< #line 1994
<       tmp___1 = cmdname(cmd);
< #line 1994
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "short sent %s size=%d sent=%d\n",
<                tmp___1, (int )size, sent);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1996
<   return (ok);
< }
< }
< #line 2002 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_cmd(struct drbd_conf *mdev , int use_data_socket , enum drbd_packets cmd ,
<                   struct p_header80 *h , size_t size ) 
< { 
<   int ok ;
<   struct socket *sock ;
<   long tmp ;
< 
<   {
< #line 2005
<   ok = 0;
< #line 2008
<   if (use_data_socket != 0) {
< #line 2009
<     mutex_lock_nested(& mdev->data.mutex, 0U);
< #line 2010
<     sock = mdev->data.socket;
<   } else {
< #line 2012
<     mutex_lock_nested(& mdev->meta.mutex, 0U);
< #line 2013
<     sock = mdev->meta.socket;
<   }
< #line 2018
<   tmp = __builtin_expect((unsigned long )sock != (unsigned long )((struct socket *)0),
<                          1L);
< #line 2018
<   if (tmp != 0L) {
< #line 2019
<     ok = _drbd_send_cmd(mdev, sock, cmd, h, size, 0U);
<   } else {
< 
<   }
< #line 2021
<   if (use_data_socket != 0) {
< #line 2022
<     mutex_unlock(& mdev->data.mutex);
<   } else {
< #line 2024
<     mutex_unlock(& mdev->meta.mutex);
<   }
< #line 2025
<   return (ok);
< }
< }
< #line 2028 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_cmd2(struct drbd_conf *mdev , enum drbd_packets cmd , char *data , size_t size ) 
< { 
<   struct p_header80 h ;
<   int ok ;
<   __u16 tmp ;
<   __u16 tmp___0 ;
<   int tmp___1 ;
<   int tmp___2 ;
<   int tmp___3 ;
<   int tmp___4 ;
< 
<   {
< #line 2034
<   h.magic = 1728214147U;
< #line 2035
<   tmp = __fswab16((int )((__u16 )cmd));
< #line 2035
<   h.command = tmp;
< #line 2036
<   tmp___0 = __fswab16((int )((__u16 )size));
< #line 2036
<   h.length = tmp___0;
< #line 2038
<   tmp___1 = drbd_get_data_sock(mdev);
< #line 2038
<   if (tmp___1 == 0) {
< #line 2039
<     return (0);
<   } else {
< 
<   }
< #line 2041
<   tmp___2 = drbd_send(mdev, mdev->data.socket, (void *)(& h), 8UL, 0U);
< #line 2041
<   ok = tmp___2 == 8;
< #line 2043
<   if (ok != 0) {
< #line 2043
<     tmp___3 = drbd_send(mdev, mdev->data.socket, (void *)data, size, 0U);
< #line 2043
<     if ((size_t )tmp___3 == size) {
< #line 2043
<       tmp___4 = 1;
<     } else {
< #line 2043
<       tmp___4 = 0;
<     }
<   } else {
< #line 2043
<     tmp___4 = 0;
<   }
< #line 2043
<   ok = tmp___4;
< #line 2046
<   drbd_put_data_sock(mdev);
< #line 2048
<   return (ok);
< }
< }
< #line 2051 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_sync_param(struct drbd_conf *mdev , struct syncer_conf *sc ) 
< { 
<   struct p_rs_param_95 *p ;
<   struct socket *sock ;
<   int size ;
<   int rv ;
<   int apv ;
<   size_t tmp ;
<   int tmp___0 ;
<   enum drbd_packets cmd ;
<   __u32 tmp___1 ;
<   __u32 tmp___2 ;
<   __u32 tmp___3 ;
<   __u32 tmp___4 ;
<   __u32 tmp___5 ;
<   long tmp___6 ;
< 
<   {
< #line 2056
<   apv = mdev->agreed_pro_version;
< #line 2058
<   if (apv > 87) {
< #line 2058
<     if (apv == 88) {
< #line 2058
<       tmp = strlen((char const   *)(& mdev->sync_conf.verify_alg));
< #line 2058
<       tmp___0 = (int )((unsigned int )tmp + 13U);
<     } else {
< #line 2058
<       tmp___0 = apv <= 94 ? 140 : 156;
<     }
< #line 2058
<     size = tmp___0;
<   } else {
< #line 2058
<     size = 12;
<   }
< #line 2067
<   mutex_lock_nested(& mdev->data.mutex, 0U);
< #line 2068
<   sock = mdev->data.socket;
< #line 2070
<   tmp___6 = __builtin_expect((unsigned long )sock != (unsigned long )((struct socket *)0),
<                              1L);
< #line 2070
<   if (tmp___6 != 0L) {
< #line 2071
<     cmd = apv > 88 ? P_SYNC_PARAM89 : P_SYNC_PARAM;
< #line 2073
<     p = & mdev->data.sbuf.rs_param_95;
< #line 2076
<     memset((void *)(& p->verify_alg), 0, 128UL);
< #line 2078
<     tmp___1 = __fswab32((__u32 )sc->rate);
< #line 2078
<     p->rate = tmp___1;
< #line 2079
<     tmp___2 = __fswab32((__u32 )sc->c_plan_ahead);
< #line 2079
<     p->c_plan_ahead = tmp___2;
< #line 2080
<     tmp___3 = __fswab32((__u32 )sc->c_delay_target);
< #line 2080
<     p->c_delay_target = tmp___3;
< #line 2081
<     tmp___4 = __fswab32((__u32 )sc->c_fill_target);
< #line 2081
<     p->c_fill_target = tmp___4;
< #line 2082
<     tmp___5 = __fswab32((__u32 )sc->c_max_rate);
< #line 2082
<     p->c_max_rate = tmp___5;
< #line 2084
<     if (apv > 87) {
< #line 2085
<       strcpy((char *)(& p->verify_alg), (char const   *)(& mdev->sync_conf.verify_alg));
<     } else {
< 
<     }
< #line 2086
<     if (apv > 88) {
< #line 2087
<       strcpy((char *)(& p->csums_alg), (char const   *)(& mdev->sync_conf.csums_alg));
<     } else {
< 
<     }
< #line 2089
<     rv = _drbd_send_cmd(mdev, sock, cmd, & p->head, (size_t )size, 0U);
<   } else {
< #line 2091
<     rv = 0;
<   }
< #line 2093
<   mutex_unlock(& mdev->data.mutex);
< #line 2095
<   return (rv);
< }
< }
< #line 2098 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_protocol(struct drbd_conf *mdev ) 
< { 
<   struct p_protocol *p ;
<   int size ;
<   int cf ;
<   int rv ;
<   size_t tmp ;
<   void *tmp___0 ;
<   __u32 tmp___1 ;
<   __u32 tmp___2 ;
<   __u32 tmp___3 ;
<   __u32 tmp___4 ;
<   __u32 tmp___5 ;
<   __u32 tmp___6 ;
< 
<   {
< #line 2103
<   size = 32;
< #line 2105
<   if (mdev->agreed_pro_version > 86) {
< #line 2106
<     tmp = strlen((char const   *)(& (mdev->net_conf)->integrity_alg));
< #line 2106
<     size = (int )(((unsigned int )tmp + (unsigned int )size) + 1U);
<   } else {
< 
<   }
< #line 2110
<   tmp___0 = kmalloc((size_t )size, 16U);
< #line 2110
<   p = (struct p_protocol *)tmp___0;
< #line 2111
<   if ((unsigned long )p == (unsigned long )((struct p_protocol *)0)) {
< #line 2112
<     return (0);
<   } else {
< 
<   }
< #line 2114
<   tmp___1 = __fswab32((__u32 )(mdev->net_conf)->wire_protocol);
< #line 2114
<   p->protocol = tmp___1;
< #line 2115
<   tmp___2 = __fswab32((__u32 )(mdev->net_conf)->after_sb_0p);
< #line 2115
<   p->after_sb_0p = tmp___2;
< #line 2116
<   tmp___3 = __fswab32((__u32 )(mdev->net_conf)->after_sb_1p);
< #line 2116
<   p->after_sb_1p = tmp___3;
< #line 2117
<   tmp___4 = __fswab32((__u32 )(mdev->net_conf)->after_sb_2p);
< #line 2117
<   p->after_sb_2p = tmp___4;
< #line 2118
<   tmp___5 = __fswab32((__u32 )(mdev->net_conf)->two_primaries);
< #line 2118
<   p->two_primaries = tmp___5;
< #line 2120
<   cf = 0;
< #line 2121
<   if ((unsigned int )*((unsigned char *)mdev->net_conf + 540UL) != 0U) {
< #line 2122
<     cf = cf | 1;
<   } else {
< 
<   }
< #line 2123
<   if ((unsigned int )*((unsigned char *)mdev->net_conf + 540UL) != 0U) {
< #line 2124
<     if (mdev->agreed_pro_version > 91) {
< #line 2125
<       cf = cf | 2;
<     } else {
< #line 2127
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "--dry-run is not supported by peer");
< #line 2128
<       kfree((void const   *)p);
< #line 2129
<       return (-1);
<     }
<   } else {
< 
<   }
< #line 2132
<   tmp___6 = __fswab32((__u32 )cf);
< #line 2132
<   p->conn_flags = tmp___6;
< #line 2134
<   if (mdev->agreed_pro_version > 86) {
< #line 2135
<     strcpy((char *)(& p->integrity_alg), (char const   *)(& (mdev->net_conf)->integrity_alg));
<   } else {
< 
<   }
< #line 2137
<   rv = drbd_send_cmd(mdev, 1, P_PROTOCOL, (struct p_header80 *)p, (size_t )size);
< #line 2139
<   kfree((void const   *)p);
< #line 2140
<   return (rv);
< }
< }
< #line 2143 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int _drbd_send_uuids(struct drbd_conf *mdev , u64 uuid_flags ) 
< { 
<   struct p_uuids p ;
<   int i ;
<   int tmp ;
<   __u64 tmp___0 ;
<   __u64 tmp___1 ;
<   int tmp___2 ;
<   __u64 tmp___3 ;
<   int tmp___4 ;
< 
<   {
< #line 2148
<   tmp = _get_ldev_if_state(mdev, D_NEGOTIATING);
< #line 2148
<   if (tmp == 0) {
< #line 2149
<     return (1);
<   } else {
< 
<   }
< #line 2151
<   spin_lock_irq(& (mdev->ldev)->md.uuid_lock);
< #line 2152
<   i = 0;
< #line 2152
<   goto ldv_52171;
<   ldv_52170: ;
< #line 2153
<   if ((unsigned long )mdev->ldev != (unsigned long )((struct drbd_backing_dev *)0)) {
< #line 2153
<     tmp___0 = __fswab64((mdev->ldev)->md.uuid[i]);
< #line 2153
<     p.uuid[i] = tmp___0;
<   } else {
< #line 2153
<     p.uuid[i] = 0ULL;
<   }
< #line 2152
<   i = i + 1;
<   ldv_52171: ;
< #line 2152
<   if (i <= 3) {
< #line 2153
<     goto ldv_52170;
<   } else {
< 
<   }
< #line 2154
<   spin_unlock_irq(& (mdev->ldev)->md.uuid_lock);
< #line 2156
<   mdev->comm_bm_set = drbd_bm_total_weight(mdev);
< #line 2157
<   tmp___1 = __fswab64((__u64 )mdev->comm_bm_set);
< #line 2157
<   p.uuid[4] = tmp___1;
< #line 2158
<   uuid_flags = ((unsigned int )*((unsigned char *)mdev->net_conf + 540UL) != 0U ? 1ULL : 0ULL) | uuid_flags;
< #line 2159
<   tmp___2 = drbd_test_flag(mdev, CRASHED_PRIMARY);
< #line 2159
<   uuid_flags = (tmp___2 != 0 ? 2ULL : 0ULL) | uuid_flags;
< #line 2160
<   uuid_flags = ((unsigned int )*((unsigned char *)mdev + 2273UL) == 8U ? 4ULL : 0ULL) | uuid_flags;
< #line 2161
<   tmp___3 = __fswab64(uuid_flags);
< #line 2161
<   p.uuid[5] = tmp___3;
< #line 2163
<   put_ldev(mdev);
< #line 2165
<   tmp___4 = drbd_send_cmd(mdev, 1, P_UUIDS, (struct p_header80 *)(& p), 56UL);
< #line 2165
<   return (tmp___4);
< }
< }
< #line 2169 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_uuids(struct drbd_conf *mdev ) 
< { 
<   int tmp ;
< 
<   {
< #line 2171
<   tmp = _drbd_send_uuids(mdev, 0ULL);
< #line 2171
<   return (tmp);
< }
< }
< #line 2174 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_uuids_skip_initial_sync(struct drbd_conf *mdev ) 
< { 
<   int tmp ;
< 
<   {
< #line 2176
<   tmp = _drbd_send_uuids(mdev, 8ULL);
< #line 2176
<   return (tmp);
< }
< }
< #line 2179 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void drbd_print_uuids(struct drbd_conf *mdev , char const   *text ) 
< { 
<   u64 *uuid ;
<   int tmp ;
< 
<   {
< #line 2181
<   tmp = _get_ldev_if_state(mdev, D_NEGOTIATING);
< #line 2181
<   if (tmp != 0) {
< #line 2182
<     uuid = (u64 *)(& (mdev->ldev)->md.uuid);
< #line 2183
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s %016llX:%016llX:%016llX:%016llX\n",
<               text, *uuid, *(uuid + 1UL), *(uuid + 2UL), *(uuid + 3UL));
< #line 2189
<     put_ldev(mdev);
<   } else {
< #line 2191
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s effective data uuid: %016llX\n",
<               text, mdev->ed_uuid);
<   }
< #line 2192
<   return;
< }
< }
< #line 2197 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_gen_and_send_sync_uuid(struct drbd_conf *mdev ) 
< { 
<   struct p_rs_uuid p ;
<   u64 uuid ;
<   __u64 tmp ;
<   int tmp___0 ;
< 
<   {
< #line 2202
<   if ((unsigned int )*((unsigned char *)mdev + 2277UL) != 16U) {
< #line 2202
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->state.disk == D_UP_TO_DATE ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             2202);
<   } else {
< 
<   }
< #line 2204
<   uuid = (mdev->ldev)->md.uuid[1];
< #line 2205
<   if (uuid != 0ULL && uuid != 4ULL) {
< #line 2206
<     uuid = uuid + 281474976710656ULL;
<   } else {
< #line 2208
<     get_random_bytes((void *)(& uuid), 8);
<   }
< #line 2209
<   drbd_uuid_set(mdev, 1, uuid);
< #line 2210
<   drbd_print_uuids(mdev, "updated sync UUID");
< #line 2211
<   drbd_md_sync(mdev);
< #line 2212
<   tmp = __fswab64(uuid);
< #line 2212
<   p.uuid = tmp;
< #line 2214
<   tmp___0 = drbd_send_cmd(mdev, 1, P_SYNC_UUID, (struct p_header80 *)(& p), 16UL);
< #line 2214
<   return (tmp___0);
< }
< }
< #line 2218 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_sizes(struct drbd_conf *mdev , int trigger_reply , enum dds_flags flags ) 
< { 
<   struct p_sizes p ;
<   sector_t d_size ;
<   sector_t u_size ;
<   int q_order_type ;
<   unsigned int max_bio_size ;
<   int ok ;
<   unsigned int tmp ;
<   unsigned int _min1 ;
<   unsigned int _min2 ;
<   int tmp___0 ;
<   unsigned int _min1___0 ;
<   unsigned int _min2___0 ;
<   __u64 tmp___1 ;
<   __u64 tmp___2 ;
<   sector_t tmp___3 ;
<   __u64 tmp___4 ;
<   __u64 tmp___5 ;
<   __u32 tmp___6 ;
<   __u16 tmp___7 ;
<   __u16 tmp___8 ;
< 
<   {
< #line 2226
<   tmp___0 = _get_ldev_if_state(mdev, D_NEGOTIATING);
< #line 2226
<   if (tmp___0 != 0) {
< #line 2227
<     if ((unsigned long )(mdev->ldev)->backing_bdev == (unsigned long )((struct block_device *)0)) {
< #line 2227
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->ldev->backing_bdev ) in %s:%d\n",
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<               2227);
<     } else {
< 
<     }
< #line 2228
<     d_size = drbd_get_max_capacity___0(mdev->ldev);
< #line 2229
<     u_size = (sector_t )(mdev->ldev)->dc.disk_size;
< #line 2230
<     q_order_type = drbd_queue_order_type(mdev);
< #line 2231
<     tmp = queue_max_hw_sectors((((mdev->ldev)->backing_bdev)->bd_disk)->queue);
< #line 2231
<     max_bio_size = tmp << 9;
< #line 2232
<     _min1 = max_bio_size;
< #line 2232
<     _min2 = 131072U;
< #line 2232
<     max_bio_size = _min1 < _min2 ? _min1 : _min2;
< #line 2233
<     put_ldev(mdev);
<   } else {
< #line 2235
<     d_size = 0UL;
< #line 2236
<     u_size = 0UL;
< #line 2237
<     q_order_type = 0;
< #line 2238
<     max_bio_size = 131072U;
<   }
< #line 2242
<   if (mdev->agreed_pro_version <= 94) {
< #line 2243
<     _min1___0 = max_bio_size;
< #line 2243
<     _min2___0 = 32768U;
< #line 2243
<     max_bio_size = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
<   } else {
< 
<   }
< #line 2245
<   tmp___1 = __fswab64((__u64 )d_size);
< #line 2245
<   p.d_size = tmp___1;
< #line 2246
<   tmp___2 = __fswab64((__u64 )u_size);
< #line 2246
<   p.u_size = tmp___2;
< #line 2247
<   if (trigger_reply == 0) {
< #line 2247
<     tmp___3 = drbd_get_capacity(mdev->this_bdev);
< #line 2247
<     tmp___4 = (__u64 )tmp___3;
<   } else {
< #line 2247
<     tmp___4 = 0ULL;
<   }
< #line 2247
<   tmp___5 = __fswab64(tmp___4);
< #line 2247
<   p.c_size = tmp___5;
< #line 2248
<   tmp___6 = __fswab32(max_bio_size);
< #line 2248
<   p.max_bio_size = tmp___6;
< #line 2249
<   tmp___7 = __fswab16((int )((__u16 )q_order_type));
< #line 2249
<   p.queue_order_type = tmp___7;
< #line 2250
<   tmp___8 = __fswab16((int )((__u16 )flags));
< #line 2250
<   p.dds_flags = tmp___8;
< #line 2252
<   ok = drbd_send_cmd(mdev, 1, P_SIZES, (struct p_header80 *)(& p), 40UL);
< #line 2254
<   return (ok);
< }
< }
< #line 2261 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_current_state(struct drbd_conf *mdev ) 
< { 
<   struct socket *sock ;
<   struct p_state p ;
<   int ok ;
<   __u32 tmp ;
<   long tmp___0 ;
< 
<   {
< #line 2265
<   ok = 0;
< #line 2269
<   drbd_state_lock___0(mdev);
< #line 2271
<   mutex_lock_nested(& mdev->data.mutex, 0U);
< #line 2273
<   tmp = __fswab32(mdev->state.i);
< #line 2273
<   p.state = tmp;
< #line 2274
<   sock = mdev->data.socket;
< #line 2276
<   tmp___0 = __builtin_expect((unsigned long )sock != (unsigned long )((struct socket *)0),
<                              1L);
< #line 2276
<   if (tmp___0 != 0L) {
< #line 2277
<     ok = _drbd_send_cmd(mdev, sock, P_STATE, (struct p_header80 *)(& p), 12UL, 0U);
<   } else {
< 
<   }
< #line 2281
<   mutex_unlock(& mdev->data.mutex);
< #line 2283
<   drbd_state_unlock(mdev);
< #line 2284
<   return (ok);
< }
< }
< #line 2297 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_state(struct drbd_conf *mdev , union drbd_state state ) 
< { 
<   struct socket *sock ;
<   struct p_state p ;
<   int ok ;
<   __u32 tmp ;
<   long tmp___0 ;
< 
<   {
< #line 2301
<   ok = 0;
< #line 2303
<   mutex_lock_nested(& mdev->data.mutex, 0U);
< #line 2305
<   tmp = __fswab32(state.i);
< #line 2305
<   p.state = tmp;
< #line 2306
<   sock = mdev->data.socket;
< #line 2308
<   tmp___0 = __builtin_expect((unsigned long )sock != (unsigned long )((struct socket *)0),
<                              1L);
< #line 2308
<   if (tmp___0 != 0L) {
< #line 2309
<     ok = _drbd_send_cmd(mdev, sock, P_STATE, (struct p_header80 *)(& p), 12UL, 0U);
<   } else {
< 
<   }
< #line 2313
<   mutex_unlock(& mdev->data.mutex);
< #line 2315
<   return (ok);
< }
< }
< #line 2318 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_state_req(struct drbd_conf *mdev , union drbd_state mask , union drbd_state val ) 
< { 
<   struct p_req_state p ;
<   __u32 tmp ;
<   __u32 tmp___0 ;
<   int tmp___1 ;
< 
<   {
< #line 2323
<   tmp = __fswab32(mask.i);
< #line 2323
<   p.mask = tmp;
< #line 2324
<   tmp___0 = __fswab32(val.i);
< #line 2324
<   p.val = tmp___0;
< #line 2326
<   tmp___1 = drbd_send_cmd(mdev, 1, P_STATE_CHG_REQ, (struct p_header80 *)(& p), 16UL);
< #line 2326
<   return (tmp___1);
< }
< }
< #line 2330 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_sr_reply(struct drbd_conf *mdev , enum drbd_state_rv retcode ) 
< { 
<   struct p_req_state_reply p ;
<   __u32 tmp ;
<   int tmp___0 ;
< 
<   {
< #line 2334
<   tmp = __fswab32((__u32 )retcode);
< #line 2334
<   p.retcode = tmp;
< #line 2336
<   tmp___0 = drbd_send_cmd(mdev, 0, P_STATE_CHG_REPLY, (struct p_header80 *)(& p),
<                           12UL);
< #line 2336
<   return (tmp___0);
< }
< }
< #line 2340 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int fill_bitmap_rle_bits(struct drbd_conf *mdev , struct p_compressed_bm *p , struct bm_xfer_ctx *c ) 
< { 
<   struct bitstream bs ;
<   unsigned long plain_bits ;
<   unsigned long tmp ;
<   unsigned long rl ;
<   unsigned int len ;
<   unsigned int toggle ;
<   int bits ;
<   unsigned long tmp___0 ;
<   unsigned long tmp___1 ;
< 
<   {
< #line 2353
<   if ((unsigned int )*((unsigned char *)mdev + 200UL) == 0U || mdev->agreed_pro_version <= 89) {
< #line 2355
<     return (0);
<   } else {
< 
<   }
< #line 2357
<   if (c->bit_offset >= c->bm_bits) {
< #line 2358
<     return (0);
---
>   if (c->bit_offset >= c->bm_bits) {
> #line 1099
>     return (0);
42915,42919c42317,42321
< #line 2361
<   bitstream_init(& bs, (void *)(& p->code), 4087UL, 0U);
< #line 2362
<   memset((void *)(& p->code), 0, 4087UL);
< #line 2364
---
> #line 1102
>   bitstream_init(& bs, (void *)(& p->code), (size_t )size, 0U);
> #line 1103
>   memset((void *)(& p->code), 0, (size_t )size);
> #line 1105
42921c42323
< #line 2369
---
> #line 1110
42923,42924c42325,42326
<   ldv_52244: ;
< #line 2374
---
>   ldv_52612: ;
> #line 1115
42926,42929c42328,42331
< #line 2374
<     tmp___0 = _drbd_bm_find_next_zero(mdev, c->bit_offset);
< #line 2374
<     tmp = tmp___0;
---
> #line 1115
>     tmp___2 = _drbd_bm_find_next_zero(mdev, c->bit_offset);
> #line 1115
>     tmp = tmp___2;
42931,42934c42333,42336
< #line 2374
<     tmp___1 = _drbd_bm_find_next(mdev, c->bit_offset);
< #line 2374
<     tmp = tmp___1;
---
> #line 1115
>     tmp___3 = _drbd_bm_find_next(mdev, c->bit_offset);
> #line 1115
>     tmp = tmp___3;
42936c42338
< #line 2376
---
> #line 1117
42938c42340
< #line 2377
---
> #line 1118
42943c42345
< #line 2378
---
> #line 1119
42945c42347
< #line 2380
---
> #line 1121
42947c42349
< #line 2381
---
> #line 1122
42949,42951c42351,42353
< #line 2384
<       DCBP_set_start(p, 1);
< #line 2386
---
> #line 1125
>       dcbp_set_start(p, 1);
> #line 1127
42953,42954c42355,42356
< #line 2387
<       goto ldv_52242;
---
> #line 1128
>       goto ldv_52610;
42958,42959c42360,42361
< #line 2389
<     DCBP_set_start(p, 0);
---
> #line 1130
>     dcbp_set_start(p, 0);
42963c42365
< #line 2394
---
> #line 1135
42965c42367
< #line 2395
---
> #line 1136
42968c42370
< #line 2397
---
> #line 1138
42973c42375
< #line 2400
---
> #line 1141
42975c42377
< #line 2401
---
> #line 1142
42977,42978c42379,42380
< #line 2402
<     goto ldv_52243;
---
> #line 1143
>     goto ldv_52611;
42982c42384
< #line 2403
---
> #line 1144
42984c42386
< #line 2404
---
> #line 1145
42987c42389
< #line 2405
---
> #line 1146
42992c42394
< #line 2408
---
> #line 1149
42994c42396
< #line 2409
---
> #line 1150
42996c42398
< #line 2410
---
> #line 1151
42998,42999c42400,42401
<   ldv_52242: ;
< #line 2411
---
>   ldv_52610: ;
> #line 1152
43001,43002c42403,42404
< #line 2412
<     goto ldv_52244;
---
> #line 1153
>     goto ldv_52612;
43006,43007c42408,42409
<   ldv_52243: 
< #line 2413
---
>   ldv_52611: 
> #line 1154
43009c42411
< #line 2415
---
> #line 1156
43011c42413
< #line 2418
---
> #line 1159
43013c42415
< #line 2419
---
> #line 1160
43015c42417
< #line 2420
---
> #line 1161
43017c42419
< #line 2421
---
> #line 1162
43022c42424
< #line 2426
---
> #line 1167
43024,43026c42426,42428
< #line 2429
<   DCBP_set_pad_bits(p, (int )(- bs.cur.bit) & 7);
< #line 2431
---
> #line 1170
>   dcbp_set_pad_bits(p, (int )(- bs.cur.bit) & 7);
> #line 1172
43030,43032c42432,42433
< #line 2441 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static int send_bitmap_rle_or_plain(struct drbd_conf *mdev , struct p_header80 *h ,
<                                     struct bm_xfer_ctx *c ) 
---
> #line 1182 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int send_bitmap_rle_or_plain(struct drbd_conf *mdev , struct bm_xfer_ctx *c ) 
43033a42435,42437
>   struct drbd_socket *sock ;
>   unsigned int header_size ;
>   unsigned int tmp ;
43035d42438
<   unsigned long num_words ;
43037c42440,42443
<   int ok ;
---
>   int err ;
>   unsigned int data_size ;
>   unsigned long num_words ;
>   unsigned long *p___0 ;
43042,43046c42448,42458
< #line 2444
<   p = (struct p_compressed_bm *)h;
< #line 2449
<   len = fill_bitmap_rle_bits(mdev, p, c);
< #line 2451
---
> #line 1184
>   sock = & (mdev->tconn)->data;
> #line 1185
>   tmp = drbd_header_size(mdev->tconn);
> #line 1185
>   header_size = tmp;
> #line 1186
>   p = (struct p_compressed_bm *)sock->sbuf + (unsigned long )header_size;
> #line 1189
>   len = fill_bitmap_rle_bits(mdev, p, 4095U - header_size, c);
> #line 1191
43048c42460
< #line 2452
---
> #line 1192
43053c42465
< #line 2454
---
> #line 1194
43055,43060c42467,42472
< #line 2455
<     DCBP_set_code(p, RLE_VLI_Bits);
< #line 2456
<     ok = _drbd_send_cmd(mdev, mdev->data.socket, P_COMPRESSED_BITMAP, h, (unsigned long )len + 9UL,
<                         0U);
< #line 2459
---
> #line 1195
>     dcbp_set_code(p, RLE_VLI_Bits);
> #line 1196
>     err = __send_command(mdev->tconn, mdev->vnr, sock, P_COMPRESSED_BITMAP, (unsigned int )len + 1U,
>                          0, 0U);
> #line 1199
43062,43064c42474,42476
< #line 2460
<     c->bytes[0] = (c->bytes[0] + (unsigned int )len) + 9U;
< #line 2462
---
> #line 1200
>     c->bytes[0] = (c->bytes[0] + (header_size + (unsigned int )len)) + 1U;
> #line 1202
43066c42478
< #line 2463
---
> #line 1203
43072,43074c42484,42490
< #line 2467
<     __min1 = 511UL;
< #line 2467
---
> #line 1209
>     p___0 = (unsigned long *)sock->sbuf + (unsigned long )header_size;
> #line 1211
>     data_size = 4096U - header_size;
> #line 1212
>     __min1 = (unsigned long )(data_size / 8U);
> #line 1212
43076c42492
< #line 2467
---
> #line 1212
43078c42494
< #line 2468
---
> #line 1214
43080c42496
< #line 2469
---
> #line 1215
43082,43083c42498,42499
< #line 2470
<       drbd_bm_get_lel(mdev, c->word_offset, num_words, (unsigned long *)(& h->payload));
---
> #line 1216
>       drbd_bm_get_lel(mdev, c->word_offset, num_words, p___0);
43087,43090c42503,42506
< #line 2471
<     ok = _drbd_send_cmd(mdev, mdev->data.socket, P_BITMAP, h, (unsigned long )len + 8UL,
<                         0U);
< #line 2473
---
> #line 1217
>     err = __send_command(mdev->tconn, mdev->vnr, sock, P_BITMAP, (unsigned int )len,
>                          0, 0U);
> #line 1218
43092c42508
< #line 2474
---
> #line 1219
43094c42510
< #line 2476
---
> #line 1221
43096,43098c42512,42514
< #line 2477
<     c->bytes[1] = (c->bytes[1] + (unsigned int )len) + 8U;
< #line 2479
---
> #line 1222
>     c->bytes[1] = c->bytes[1] + (header_size + (unsigned int )len);
> #line 1224
43100c42516
< #line 2480
---
> #line 1225
43106,43108c42522,42524
< #line 2482
<   if (ok != 0) {
< #line 2483
---
> #line 1227
>   if (err == 0) {
> #line 1228
43110c42526
< #line 2484
---
> #line 1229
43112c42528
< #line 2485
---
> #line 1230
43115c42531
< #line 2487
---
> #line 1232
43121c42537
< #line 2489
---
> #line 1234
43125,43126c42541,42542
< #line 2493 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int _drbd_send_bitmap(struct drbd_conf *mdev ) 
---
> #line 1238 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int _drbd_send_bitmap(struct drbd_conf *mdev ) 
43129d42544
<   struct p_header80 *p ;
43131,43132c42546,42547
<   int _b ;
<   unsigned long tmp ;
---
>   bool _bool ;
>   int tmp ;
43141,43148c42556,42562
< #line 2499
<   _b = (unsigned long )mdev->bitmap == (unsigned long )((struct drbd_bitmap *)0);
< #line 2499
<   if (_b != 0) {
< #line 2499
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "_drbd_send_bitmap", (char *)"!mdev->bitmap", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             2499);
---
> #line 1243
>   _bool = (unsigned long )mdev->bitmap != (unsigned long )((struct drbd_bitmap *)0);
> #line 1243
>   if (! _bool) {
> #line 1243
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"mdev->bitmap", "_drbd_send_bitmap");
43152,43155c42566,42569
< #line 2499
<   if (_b != 0) {
< #line 2499
<     return (0);
---
> #line 1243
>   if (_bool) {
> #line 1243
>     tmp = 0;
43157c42571,42572
< 
---
> #line 1243
>     tmp = 1;
43159,43168c42574,42576
< #line 2503
<   tmp = __get_free_pages(16U, 0U);
< #line 2503
<   p = (struct p_header80 *)tmp;
< #line 2504
<   if ((unsigned long )p == (unsigned long )((struct p_header80 *)0)) {
< #line 2505
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "failed to allocate one page buffer in %s\n",
<             "_drbd_send_bitmap");
< #line 2506
---
> #line 1243
>   if (tmp) {
> #line 1244
43173c42581
< #line 2509
---
> #line 1246
43175c42583
< #line 2509
---
> #line 1246
43177c42585
< #line 2510
---
> #line 1247
43179c42587
< #line 2510
---
> #line 1247
43181c42589
< #line 2511
---
> #line 1248
43183c42591
< #line 2512
---
> #line 1249
43185c42593
< #line 2513
---
> #line 1250
43187c42595
< #line 2513
---
> #line 1250
43189c42597
< #line 2517
---
> #line 1254
43192c42600
< #line 2519
---
> #line 1256
43194c42602
< #line 2520
---
> #line 1257
43200c42608
< #line 2523
---
> #line 1260
43205c42613
< #line 2526
---
> #line 1263
43207c42615
< #line 2526
---
> #line 1263
43209c42617
< #line 2526
---
> #line 1263
43211c42619
< #line 2526
---
> #line 1263
43213c42621
< #line 2526
---
> #line 1263
43215c42623
< #line 2526
---
> #line 1263
43217c42625
< #line 2526
---
> #line 1263
43219c42627
< #line 2526
---
> #line 1263
43221c42629
< #line 2526
---
> #line 1263
43223c42631
< #line 2526
---
> #line 1263
43225c42633
< #line 2526
---
> #line 1263
43227,43230c42635,42638
<   ldv_52267: 
< #line 2532
<   err = send_bitmap_rle_or_plain(mdev, p, & c);
< #line 2533
---
>   ldv_52637: 
> #line 1269
>   err = send_bitmap_rle_or_plain(mdev, & c);
> #line 1270
43232,43233c42640,42641
< #line 2534
<     goto ldv_52267;
---
> #line 1271
>     goto ldv_52637;
43237,43239c42645,42646
< #line 2535
<   free_pages((unsigned long )p, 0U);
< #line 2536
---
> 
> #line 1272
43243c42650
< #line 2539 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1275 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
43245a42653
>   struct drbd_socket *sock ;
43248d42655
<   int tmp___0 ;
43251,43256c42658,42669
< #line 2543
<   tmp = drbd_get_data_sock(mdev);
< #line 2543
<   if (tmp == 0) {
< #line 2544
<     return (-1);
---
> #line 1277
>   sock = & (mdev->tconn)->data;
> #line 1278
>   err = -1;
> #line 1280
>   mutex_lock_nested(& sock->mutex, 0U);
> #line 1281
>   if ((unsigned long )sock->socket != (unsigned long )((struct socket *)0)) {
> #line 1282
>     tmp = _drbd_send_bitmap(mdev);
> #line 1282
>     err = tmp == 0;
43260,43266c42673,42675
< #line 2545
<   tmp___0 = _drbd_send_bitmap(mdev);
< #line 2545
<   err = tmp___0 == 0;
< #line 2546
<   drbd_put_data_sock(mdev);
< #line 2547
---
> #line 1283
>   mutex_unlock(& sock->mutex);
> #line 1284
43270,43271c42679,42680
< #line 2550 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_b_ack(struct drbd_conf *mdev , u32 barrier_nr , u32 set_size ) 
---
> #line 1287 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void drbd_send_b_ack(struct drbd_tconn *tconn , u32 barrier_nr , u32 set_size ) 
43273,43275c42682,42685
<   int ok ;
<   struct p_barrier_ack p ;
<   __u32 tmp ;
---
>   struct drbd_socket *sock ;
>   struct p_barrier_ack *p ;
>   void *tmp ;
>   __u32 tmp___0 ;
43278,43287c42688,42691
< #line 2555
<   p.barrier = barrier_nr;
< #line 2556
<   tmp = __fswab32(set_size);
< #line 2556
<   p.set_size = tmp;
< #line 2558
<   if ((int )mdev->state.ldv_40583.conn <= 9) {
< #line 2559
<     return (0);
---
> #line 1292
>   if ((unsigned int )tconn->cstate <= 8U) {
> #line 1293
>     return;
43291,43294c42695,42717
< #line 2560
<   ok = drbd_send_cmd(mdev, 0, P_BARRIER_ACK, (struct p_header80 *)(& p), 16UL);
< #line 2562
<   return (ok);
---
> #line 1295
>   sock = & tconn->meta;
> #line 1296
>   tmp = conn_prepare_command(tconn, sock);
> #line 1296
>   p = (struct p_barrier_ack *)tmp;
> #line 1297
>   if ((unsigned long )p == (unsigned long )((struct p_barrier_ack *)0)) {
> #line 1298
>     return;
>   } else {
> 
>   }
> #line 1299
>   p->barrier = barrier_nr;
> #line 1300
>   tmp___0 = __fswab32(set_size);
> #line 1300
>   p->set_size = tmp___0;
> #line 1301
>   conn_send_command(tconn, sock, P_BARRIER_ACK, 8U, 0, 0U);
> #line 1302
>   return;
43297,43298c42720,42721
< #line 2573 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static int _drbd_send_ack(struct drbd_conf *mdev , enum drbd_packets cmd , u64 sector ,
---
> #line 1312 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int _drbd_send_ack(struct drbd_conf *mdev , enum drbd_packet cmd , u64 sector ,
43301,43304c42724,42729
<   int ok ;
<   struct p_block_ack p ;
<   int tmp ;
<   __u32 tmp___0 ;
---
>   struct drbd_socket *sock ;
>   struct p_block_ack *p ;
>   void *tmp ;
>   int tmp___0 ;
>   __u32 tmp___1 ;
>   int tmp___2 ;
43307,43322c42732,42735
< #line 2581
<   p.sector = sector;
< #line 2582
<   p.block_id = block_id;
< #line 2583
<   p.blksize = blksize;
< #line 2584
<   tmp = atomic_add_return(1, & mdev->packet_seq);
< #line 2584
<   tmp___0 = __fswab32((__u32 )tmp);
< #line 2584
<   p.seq_num = tmp___0;
< #line 2586
<   if ((unsigned long )mdev->meta.socket == (unsigned long )((struct socket *)0) || (int )mdev->state.ldv_40583.conn <= 9) {
< #line 2587
<     return (0);
---
> #line 1318
>   if ((int )mdev->state.ldv_50103.conn <= 9) {
> #line 1319
>     return (-5);
43326,43329c42739,42767
< #line 2588
<   ok = drbd_send_cmd(mdev, 0, cmd, (struct p_header80 *)(& p), 32UL);
< #line 2590
<   return (ok);
---
> #line 1321
>   sock = & (mdev->tconn)->meta;
> #line 1322
>   tmp = drbd_prepare_command(mdev, sock);
> #line 1322
>   p = (struct p_block_ack *)tmp;
> #line 1323
>   if ((unsigned long )p == (unsigned long )((struct p_block_ack *)0)) {
> #line 1324
>     return (-5);
>   } else {
> 
>   }
> #line 1325
>   p->sector = sector;
> #line 1326
>   p->block_id = block_id;
> #line 1327
>   p->blksize = blksize;
> #line 1328
>   tmp___0 = atomic_add_return(1, & mdev->packet_seq);
> #line 1328
>   tmp___1 = __fswab32((__u32 )tmp___0);
> #line 1328
>   p->seq_num = tmp___1;
> #line 1329
>   tmp___2 = drbd_send_command(mdev, sock, cmd, 24U, 0, 0U);
> #line 1329
>   return (tmp___2);
43332,43334c42770,42772
< #line 2596 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_ack_dp(struct drbd_conf *mdev , enum drbd_packets cmd , struct p_data *dp ,
<                      int data_size ) 
---
> #line 1335 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void drbd_send_ack_dp(struct drbd_conf *mdev , enum drbd_packet cmd , struct p_data *dp ,
>                       int data_size ) 
43337,43339c42775
<   unsigned int tmp___0 ;
<   __u32 tmp___1 ;
<   int tmp___2 ;
---
>   __u32 tmp___0 ;
43342,43347c42778,42783
< #line 2599
<   if (mdev->agreed_pro_version > 86 && (unsigned long )mdev->integrity_r_tfm != (unsigned long )((struct crypto_hash *)0)) {
< #line 2599
<     tmp = crypto_hash_digestsize(mdev->integrity_r_tfm);
< #line 2599
<     tmp___0 = tmp;
---
> #line 1338
>   if ((unsigned long )(mdev->tconn)->peer_integrity_tfm != (unsigned long )((struct crypto_hash *)0)) {
> #line 1339
>     tmp = crypto_hash_digestsize((mdev->tconn)->peer_integrity_tfm);
> #line 1339
>     data_size = (int )((unsigned int )data_size - tmp);
43349,43350c42785
< #line 2599
<     tmp___0 = 0U;
---
> 
43352,43359c42787,42792
< #line 2599
<   data_size = (int )((unsigned int )data_size - tmp___0);
< #line 2601
<   tmp___1 = __fswab32((__u32 )data_size);
< #line 2601
<   tmp___2 = _drbd_send_ack(mdev, cmd, dp->sector, tmp___1, dp->block_id);
< #line 2601
<   return (tmp___2);
---
> #line 1340
>   tmp___0 = __fswab32((__u32 )data_size);
> #line 1340
>   _drbd_send_ack(mdev, cmd, dp->sector, tmp___0, dp->block_id);
> #line 1342
>   return;
43362,43363c42795,42796
< #line 2605 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_ack_rp(struct drbd_conf *mdev , enum drbd_packets cmd , struct p_block_req *rp ) 
---
> #line 1344 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void drbd_send_ack_rp(struct drbd_conf *mdev , enum drbd_packet cmd , struct p_block_req *rp ) 
43365c42798
<   int tmp ;
---
> 
43368,43371c42801,42804
< #line 2608
<   tmp = _drbd_send_ack(mdev, cmd, rp->sector, rp->blksize, rp->block_id);
< #line 2608
<   return (tmp);
---
> #line 1347
>   _drbd_send_ack(mdev, cmd, rp->sector, rp->blksize, rp->block_id);
> #line 1348
>   return;
43374,43375c42807,42808
< #line 2617 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_ack(struct drbd_conf *mdev , enum drbd_packets cmd , struct drbd_epoch_entry *e ) 
---
> #line 1356 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_ack(struct drbd_conf *mdev , enum drbd_packet cmd , struct drbd_peer_request *peer_req ) 
43382,43388c42815,42821
< #line 2620
<   tmp = __fswab32(e->size);
< #line 2620
<   tmp___0 = __fswab64((__u64 )e->sector);
< #line 2620
<   tmp___1 = _drbd_send_ack(mdev, cmd, tmp___0, tmp, e->ldv_49794.block_id);
< #line 2620
---
> #line 1359
>   tmp = __fswab32(peer_req->i.size);
> #line 1359
>   tmp___0 = __fswab64((__u64 )peer_req->i.sector);
> #line 1359
>   tmp___1 = _drbd_send_ack(mdev, cmd, tmp___0, tmp, peer_req->ldv_50490.block_id);
> #line 1359
43392,43393c42825,42826
< #line 2628 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_ack_ex(struct drbd_conf *mdev , enum drbd_packets cmd , sector_t sector ,
---
> #line 1367 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_ack_ex(struct drbd_conf *mdev , enum drbd_packet cmd , sector_t sector ,
43402c42835
< #line 2631
---
> #line 1370
43404c42837
< #line 2631
---
> #line 1370
43406c42839
< #line 2631
---
> #line 1370
43408c42841
< #line 2631
---
> #line 1370
43410c42843
< #line 2631
---
> #line 1370
43414c42847
< #line 2637 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1376 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
43418,43421c42851,42856
<   int ok ;
<   struct p_block_req p ;
<   __u64 tmp ;
<   __u32 tmp___0 ;
---
>   struct drbd_socket *sock ;
>   struct p_block_req *p ;
>   void *tmp ;
>   __u64 tmp___0 ;
>   __u32 tmp___1 ;
>   int tmp___2 ;
43424,43438c42859,42885
< #line 2643
<   tmp = __fswab64((__u64 )sector);
< #line 2643
<   p.sector = tmp;
< #line 2644
<   p.block_id = block_id;
< #line 2645
<   tmp___0 = __fswab32((__u32 )size);
< #line 2645
<   p.blksize = tmp___0;
< #line 2647
<   ok = drbd_send_cmd(mdev, 1, (enum drbd_packets )cmd, (struct p_header80 *)(& p),
<                      32UL);
< #line 2649
<   return (ok);
---
> #line 1382
>   sock = & (mdev->tconn)->data;
> #line 1383
>   tmp = drbd_prepare_command(mdev, sock);
> #line 1383
>   p = (struct p_block_req *)tmp;
> #line 1384
>   if ((unsigned long )p == (unsigned long )((struct p_block_req *)0)) {
> #line 1385
>     return (-5);
>   } else {
> 
>   }
> #line 1386
>   tmp___0 = __fswab64((__u64 )sector);
> #line 1386
>   p->sector = tmp___0;
> #line 1387
>   p->block_id = block_id;
> #line 1388
>   tmp___1 = __fswab32((__u32 )size);
> #line 1388
>   p->blksize = tmp___1;
> #line 1389
>   tmp___2 = drbd_send_command(mdev, sock, (enum drbd_packet )cmd, 24U, 0, 0U);
> #line 1389
>   return (tmp___2);
43441c42888
< #line 2652 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1392 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
43443c42890
<                             void *digest , int digest_size , enum drbd_packets cmd ) 
---
>                             void *digest , int digest_size , enum drbd_packet cmd ) 
43445,43453c42892,42897
<   int ok ;
<   struct p_block_req p ;
<   __u64 tmp ;
<   __u32 tmp___0 ;
<   __u16 tmp___1 ;
<   __u16 tmp___2 ;
<   int tmp___3 ;
<   int tmp___4 ;
<   int tmp___5 ;
---
>   struct drbd_socket *sock ;
>   struct p_block_req *p ;
>   void *tmp ;
>   __u64 tmp___0 ;
>   __u32 tmp___1 ;
>   int tmp___2 ;
43456,43493c42900,42909
< #line 2660
<   tmp = __fswab64((__u64 )sector);
< #line 2660
<   p.sector = tmp;
< #line 2661
<   p.block_id = 1728263026ULL;
< #line 2662
<   tmp___0 = __fswab32((__u32 )size);
< #line 2662
<   p.blksize = tmp___0;
< #line 2664
<   p.head.magic = 1728214147U;
< #line 2665
<   tmp___1 = __fswab16((int )((__u16 )cmd));
< #line 2665
<   p.head.command = tmp___1;
< #line 2666
<   tmp___2 = __fswab16((int )((unsigned int )((__u16 )digest_size) + 24U));
< #line 2666
<   p.head.length = tmp___2;
< #line 2668
<   mutex_lock_nested(& mdev->data.mutex, 0U);
< #line 2670
<   tmp___3 = drbd_send(mdev, mdev->data.socket, (void *)(& p), 32UL, 0U);
< #line 2670
<   ok = tmp___3 == 32;
< #line 2671
<   if (ok != 0) {
< #line 2671
<     tmp___4 = drbd_send(mdev, mdev->data.socket, digest, (size_t )digest_size, 0U);
< #line 2671
<     if (tmp___4 == digest_size) {
< #line 2671
<       tmp___5 = 1;
<     } else {
< #line 2671
<       tmp___5 = 0;
<     }
---
> #line 1400
>   sock = & (mdev->tconn)->data;
> #line 1401
>   tmp = drbd_prepare_command(mdev, sock);
> #line 1401
>   p = (struct p_block_req *)tmp;
> #line 1402
>   if ((unsigned long )p == (unsigned long )((struct p_block_req *)0)) {
> #line 1403
>     return (-5);
43495,43496c42911
< #line 2671
<     tmp___5 = 0;
---
> 
43498,43503c42913,42926
< #line 2671
<   ok = tmp___5;
< #line 2673
<   mutex_unlock(& mdev->data.mutex);
< #line 2675
<   return (ok);
---
> #line 1404
>   tmp___0 = __fswab64((__u64 )sector);
> #line 1404
>   p->sector = tmp___0;
> #line 1405
>   p->block_id = 0xffffffffffffffffULL;
> #line 1406
>   tmp___1 = __fswab32((__u32 )size);
> #line 1406
>   p->blksize = tmp___1;
> #line 1407
>   tmp___2 = drbd_send_command(mdev, sock, cmd, 24U, digest, (unsigned int )digest_size);
> #line 1407
>   return (tmp___2);
43506c42929
< #line 2678 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1411 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
43509,43512c42932,42937
<   int ok ;
<   struct p_block_req p ;
<   __u64 tmp ;
<   __u32 tmp___0 ;
---
>   struct drbd_socket *sock ;
>   struct p_block_req *p ;
>   void *tmp ;
>   __u64 tmp___0 ;
>   __u32 tmp___1 ;
>   int tmp___2 ;
43515,43528c42940,42966
< #line 2683
<   tmp = __fswab64((__u64 )sector);
< #line 2683
<   p.sector = tmp;
< #line 2684
<   p.block_id = 1728261953ULL;
< #line 2685
<   tmp___0 = __fswab32((__u32 )size);
< #line 2685
<   p.blksize = tmp___0;
< #line 2687
<   ok = drbd_send_cmd(mdev, 1, P_OV_REQUEST, (struct p_header80 *)(& p), 32UL);
< #line 2689
<   return (ok);
---
> #line 1416
>   sock = & (mdev->tconn)->data;
> #line 1417
>   tmp = drbd_prepare_command(mdev, sock);
> #line 1417
>   p = (struct p_block_req *)tmp;
> #line 1418
>   if ((unsigned long )p == (unsigned long )((struct p_block_req *)0)) {
> #line 1419
>     return (-5);
>   } else {
> 
>   }
> #line 1420
>   tmp___0 = __fswab64((__u64 )sector);
> #line 1420
>   p->sector = tmp___0;
> #line 1421
>   p->block_id = 0xffffffffffffffffULL;
> #line 1422
>   tmp___1 = __fswab32((__u32 )size);
> #line 1422
>   p->blksize = tmp___1;
> #line 1423
>   tmp___2 = drbd_send_command(mdev, sock, P_OV_REQUEST, 24U, 0, 0U);
> #line 1423
>   return (tmp___2);
43531,43532c42969,42970
< #line 2696 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static int we_should_drop_the_connection(struct drbd_conf *mdev , struct socket *sock ) 
---
> #line 1430 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int we_should_drop_the_connection(struct drbd_tconn *tconn , struct socket *sock ) 
43541,43543c42979,42981
< #line 2701
<   if ((unsigned long )mdev->meta.socket == (unsigned long )sock || (unsigned long )mdev->asender.task == (unsigned long )((struct task_struct *)0)) {
< #line 2701
---
> #line 1435
>   if ((unsigned long )tconn->meta.socket == (unsigned long )sock || (unsigned long )tconn->asender.task == (unsigned long )((struct task_struct *)0)) {
> #line 1435
43546,43548c42984,42986
< #line 2701
<     tmp = get_t_state(& mdev->asender);
< #line 2701
---
> #line 1435
>     tmp = get_t_state(& tconn->asender);
> #line 1435
43550c42988
< #line 2701
---
> #line 1435
43553,43555c42991,42993
< #line 2701
<     if ((int )mdev->state.ldv_40583.conn <= 9) {
< #line 2701
---
> #line 1435
>     if ((unsigned int )tconn->cstate <= 8U) {
> #line 1435
43558c42996
< #line 2701
---
> #line 1435
43562c43000
< #line 2701
---
> #line 1435
43564c43002
< #line 2706
---
> #line 1440
43566c43004
< #line 2707
---
> #line 1441
43571,43575c43009,43013
< #line 2709
<   mdev->ko_count = mdev->ko_count - 1U;
< #line 2709
<   drop_it = mdev->ko_count == 0U;
< #line 2710
---
> #line 1443
>   tconn->ko_count = tconn->ko_count - 1U;
> #line 1443
>   drop_it = tconn->ko_count == 0U;
> #line 1444
43577c43015
< #line 2711
---
> #line 1445
43579c43017
< #line 2711
---
> #line 1445
43581,43585c43019,43023
< #line 2711
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "[%s/%d] sock_sendmsg time expired, ko = %u\n",
<             (char *)(& tmp___2->comm), tmp___1->pid, mdev->ko_count);
< #line 2713
<     request_ping(mdev);
---
> #line 1445
>     printk("\vd-con %s: [%s/%d] sock_sendmsg time expired, ko = %u\n", tconn->name,
>            (char *)(& tmp___2->comm), tmp___1->pid, tconn->ko_count);
> #line 1447
>     request_ping(tconn);
43589c43027
< #line 2716
---
> #line 1450
43593c43031,43050
< #line 2740 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1453 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static void drbd_update_congested(struct drbd_tconn *tconn ) 
> { 
>   struct sock *sk ;
> 
>   {
> #line 1455
>   sk = (tconn->data.socket)->sk;
> #line 1456
>   if (sk->sk_wmem_queued > (sk->sk_sndbuf * 4) / 5) {
> #line 1457
>     set_bit(0U, (unsigned long volatile   *)(& tconn->flags));
>   } else {
> 
>   }
> #line 1458
>   return;
> }
> }
> #line 1481 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
43597c43054,43056
<   int sent ;
---
>   struct socket *socket ;
>   void *addr ;
>   int err ;
43599d43057
<   int tmp___0 ;
43602c43060,43062
< #line 2743
---
> #line 1488
>   socket = (mdev->tconn)->data.socket;
> #line 1489
43604,43609c43064,43068
< #line 2743
<   tmp___0 = drbd_send(mdev, mdev->data.socket, tmp + (unsigned long )offset, size,
<                       msg_flags);
< #line 2743
<   sent = tmp___0;
< #line 2744
---
> #line 1489
>   addr = tmp + (unsigned long )offset;
> #line 1490
>   err = drbd_send_all(mdev->tconn, socket, addr, size, msg_flags);
> #line 1491
43611,43613c43070,43072
< #line 2745
<   if ((size_t )sent == size) {
< #line 2746
---
> #line 1492
>   if (err == 0) {
> #line 1493
43618,43619c43077,43078
< #line 2747
<   return ((size_t )sent == size);
---
> #line 1494
>   return (err);
43622c43081
< #line 2750 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1497 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
43625a43085
>   struct socket *socket ;
43628,43629d43087
<   int sent ;
<   int ok ;
43630a43089
>   int err ;
43635a43095
>   int sent ;
43639d43098
<   long tmp___7 ;
43642c43101,43103
< #line 2753
---
> #line 1500
>   socket = (mdev->tconn)->data.socket;
> #line 1501
43644c43105
< #line 2753
---
> #line 1501
43646c43107
< #line 2755
---
> #line 1502
43648c43109,43111
< #line 2763
---
> #line 1503
>   err = -5;
> #line 1511
43650c43113
< #line 2764
---
> #line 1512
43652c43115
< #line 2764
---
> #line 1512
43655c43118
< #line 2763
---
> #line 1511
43657c43120
< #line 2763
---
> #line 1511
43659c43122
< #line 2764
---
> #line 1512
43661c43124
< #line 2764
---
> #line 1512
43664c43127
< #line 2763
---
> #line 1511
43666c43129
< #line 2763
---
> #line 1511
43668c43131
< #line 2764
---
> #line 1512
43670c43133
< #line 2764
---
> #line 1512
43677c43140
< #line 2766
---
> #line 1514
43679,43681c43142,43144
< #line 2767
<   drbd_update_congested(mdev);
< #line 2768
---
> #line 1515
>   drbd_update_congested(mdev->tconn);
> #line 1516
43683c43146
< #line 2768
---
> #line 1516
43685c43148
< #line 2768
---
> #line 1516
43687,43691c43150,43153
<   ldv_52366: 
< #line 2770
<   tmp___4 = (*(((mdev->data.socket)->ops)->sendpage))(mdev->data.socket, page, offset,
<                                                       (size_t )len, (int )msg_flags);
< #line 2770
---
>   ldv_52744: 
> #line 1520
>   tmp___4 = (*((socket->ops)->sendpage))(socket, page, offset, (size_t )len, (int )msg_flags);
> #line 1520
43693,43700c43155,43169
< #line 2773
<   if (sent == -11) {
< #line 2774
<     tmp___5 = we_should_drop_the_connection(mdev, mdev->data.socket);
< #line 2774
<     if (tmp___5 != 0) {
< #line 2776
<       goto ldv_52363;
---
> #line 1521
>   if (sent <= 0) {
> #line 1522
>     if (sent == -11) {
> #line 1523
>       tmp___5 = we_should_drop_the_connection(mdev->tconn, socket);
> #line 1523
>       if (tmp___5 != 0) {
> #line 1524
>         goto ldv_52741;
>       } else {
> 
>       }
> #line 1525
>       goto ldv_52742;
43702,43705d43170
< #line 2778
<       goto ldv_52364;
<     }
<   } else {
43707,43710c43172,43173
<   }
< #line 2780
<   if (sent <= 0) {
< #line 2781
---
>     }
> #line 1527
43713,43714c43176,43184
< #line 2783
<     goto ldv_52363;
---
> #line 1529
>     if (sent < 0) {
> #line 1530
>       err = sent;
>     } else {
> 
>     }
> #line 1531
>     goto ldv_52741;
43718c43188
< #line 2785
---
> #line 1533
43720c43190
< #line 2786
---
> #line 1534
43722,43723c43192,43193
<   ldv_52364: ;
< #line 2787
---
>   ldv_52742: ;
> #line 1535
43725,43726c43195,43196
< #line 2788
<     goto ldv_52366;
---
> #line 1536
>     goto ldv_52744;
43730,43731c43200,43201
<   ldv_52363: 
< #line 2788
---
>   ldv_52741: 
> #line 1536
43733c43203
< #line 2788
---
> #line 1536
43735,43743c43205,43211
< #line 2789
<   drbd_clear_flag(mdev, NET_CONGESTED);
< #line 2791
<   ok = len == 0;
< #line 2792
<   tmp___7 = __builtin_expect(ok != 0, 1L);
< #line 2792
<   if (tmp___7 != 0L) {
< #line 2793
---
> #line 1537
>   clear_bit(0, (unsigned long volatile   *)(& (mdev->tconn)->flags));
> #line 1539
>   if (len == 0) {
> #line 1540
>     err = 0;
> #line 1541
43748,43749c43216,43217
< #line 2794
<   return (ok);
---
> #line 1543
>   return (err);
43752c43220
< #line 2797 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1546 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
43757c43225
<   int tmp ;
---
>   int err ;
43760c43228
< #line 2802
---
> #line 1551
43762c43230
< #line 2802
---
> #line 1551
43764,43768c43232,43236
< #line 2802
<   goto ldv_52374;
<   ldv_52373: 
< #line 2803
<   tmp = _drbd_no_send_page(mdev, bvec->bv_page, (int )bvec->bv_offset, (size_t )bvec->bv_len,
---
> #line 1551
>   goto ldv_52753;
>   ldv_52752: 
> #line 1554
>   err = _drbd_no_send_page(mdev, bvec->bv_page, (int )bvec->bv_offset, (size_t )bvec->bv_len,
43770,43773c43238,43241
< #line 2803
<   if (tmp == 0) {
< #line 2806
<     return (0);
---
> #line 1557
>   if (err != 0) {
> #line 1558
>     return (err);
43777c43245
< #line 2802
---
> #line 1551
43779c43247
< #line 2802
---
> #line 1551
43781,43782c43249,43250
<   ldv_52374: ;
< #line 2802
---
>   ldv_52753: ;
> #line 1551
43784,43785c43252,43253
< #line 2803
<     goto ldv_52373;
---
> #line 1552
>     goto ldv_52752;
43790,43791c43258,43259
< #line 2808
<   return (1);
---
> #line 1560
>   return (0);
43794c43262
< #line 2811 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1563 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
43799c43267
<   int tmp ;
---
>   int err ;
43802c43270
< #line 2816
---
> #line 1568
43804c43272
< #line 2816
---
> #line 1568
43806,43810c43274,43278
< #line 2816
<   goto ldv_52383;
<   ldv_52382: 
< #line 2817
<   tmp = _drbd_send_page(mdev, bvec->bv_page, (int )bvec->bv_offset, (size_t )bvec->bv_len,
---
> #line 1568
>   goto ldv_52763;
>   ldv_52762: 
> #line 1571
>   err = _drbd_send_page(mdev, bvec->bv_page, (int )bvec->bv_offset, (size_t )bvec->bv_len,
43812,43815c43280,43283
< #line 2817
<   if (tmp == 0) {
< #line 2820
<     return (0);
---
> #line 1574
>   if (err != 0) {
> #line 1575
>     return (err);
43819c43287
< #line 2816
---
> #line 1568
43821c43289
< #line 2816
---
> #line 1568
43823,43824c43291,43292
<   ldv_52383: ;
< #line 2816
---
>   ldv_52763: ;
> #line 1568
43826,43827c43294,43295
< #line 2817
<     goto ldv_52382;
---
> #line 1569
>     goto ldv_52762;
43832,43833c43300,43301
< #line 2822
<   return (1);
---
> #line 1577
>   return (0);
43836,43837c43304,43305
< #line 2825 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static int _drbd_send_zc_ee(struct drbd_conf *mdev , struct drbd_epoch_entry *e ) 
---
> #line 1580 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int _drbd_send_zc_ee(struct drbd_conf *mdev , struct drbd_peer_request *peer_req ) 
43840a43309
>   int err ;
43845,43846c43314
<   int tmp___0 ;
<   struct page *tmp___1 ;
---
>   struct page *tmp___0 ;
43849,43856c43317,43324
< #line 2827
<   page = e->pages;
< #line 2828
<   len = e->size;
< #line 2830
<   goto ldv_52397;
<   ldv_52396: 
< #line 2831
---
> #line 1583
>   page = peer_req->pages;
> #line 1584
>   len = peer_req->i.size;
> #line 1588
>   goto ldv_52778;
>   ldv_52777: 
> #line 1589
43858c43326
< #line 2831
---
> #line 1589
43860c43328
< #line 2831
---
> #line 1589
43862c43330
< #line 2832
---
> #line 1591
43864,43869c43332,43337
< #line 2832
<   tmp___0 = _drbd_send_page(mdev, page, 0, (size_t )l, (unsigned long )tmp != (unsigned long )((struct page *)0) ? 32768U : 0U);
< #line 2832
<   if (tmp___0 == 0) {
< #line 2834
<     return (0);
---
> #line 1591
>   err = _drbd_send_page(mdev, page, 0, (size_t )l, (unsigned long )tmp != (unsigned long )((struct page *)0) ? 32768U : 0U);
> #line 1593
>   if (err != 0) {
> #line 1594
>     return (err);
43873c43341
< #line 2835
---
> #line 1595
43875c43343
< #line 2830
---
> #line 1588
43877,43878c43345,43346
<   ldv_52397: ;
< #line 2830
---
>   ldv_52778: ;
> #line 1588
43880,43884c43348,43352
< #line 2830
<     tmp___1 = page_chain_next(page);
< #line 2830
<     __builtin_prefetch((void const   *)tmp___1);
< #line 2830
---
> #line 1588
>     tmp___0 = page_chain_next(page);
> #line 1588
>     __builtin_prefetch((void const   *)tmp___0);
> #line 1588
43886,43887c43354,43355
< #line 2831
<       goto ldv_52396;
---
> #line 1589
>       goto ldv_52777;
43889,43890c43357,43358
< #line 2833
<       goto ldv_52398;
---
> #line 1591
>       goto ldv_52779;
43895,43897c43363,43365
<   ldv_52398: ;
< #line 2837
<   return (1);
---
>   ldv_52779: ;
> #line 1597
>   return (0);
43900c43368
< #line 2840 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1600 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
43906,43908c43374,43376
< #line 2842
<   if (mdev->agreed_pro_version > 94) {
< #line 2843
---
> #line 1602
>   if ((mdev->tconn)->agreed_pro_version > 94) {
> #line 1603
43911c43379
< #line 2848
---
> #line 1608
43916c43384
< #line 2854 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1614 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
43919,43920c43387,43388
<   int ok ;
<   struct p_data p ;
---
>   struct drbd_socket *sock ;
>   struct p_data *p ;
43922d43389
<   void *dgb ;
43924c43391,43392
<   int tmp ;
---
>   int err ;
>   void *tmp ;
43926,43933c43394,43397
<   __u16 tmp___1 ;
<   __u32 tmp___2 ;
<   __u64 tmp___3 ;
<   int tmp___4 ;
<   __u32 tmp___5 ;
<   __u32 tmp___6 ;
<   int tmp___7 ;
<   int tmp___8 ;
---
>   __u64 tmp___1 ;
>   int tmp___2 ;
>   __u32 tmp___3 ;
>   __u32 tmp___4 ;
43935c43399
<   int tmp___9 ;
---
>   int tmp___5 ;
43938,43940c43402
< #line 2856
<   ok = 1;
< #line 2858
---
> #line 1618
43942,43955c43404,43414
< #line 2862
<   tmp = drbd_get_data_sock(mdev);
< #line 2862
<   if (tmp == 0) {
< #line 2863
<     return (0);
<   } else {
< 
<   }
< #line 2865
<   if (mdev->agreed_pro_version > 86 && (unsigned long )mdev->integrity_w_tfm != (unsigned long )((struct crypto_hash *)0)) {
< #line 2865
<     tmp___0 = crypto_hash_digestsize(mdev->integrity_w_tfm);
< #line 2865
---
> #line 1622
>   sock = & (mdev->tconn)->data;
> #line 1623
>   tmp = drbd_prepare_command(mdev, sock);
> #line 1623
>   p = (struct p_data *)tmp;
> #line 1624
>   if ((unsigned long )(mdev->tconn)->integrity_tfm != (unsigned long )((struct crypto_hash *)0)) {
> #line 1624
>     tmp___0 = crypto_hash_digestsize((mdev->tconn)->integrity_tfm);
> #line 1624
43958c43417
< #line 2865
---
> #line 1624
43961,43970c43420,43423
< #line 2868
<   if (req->size <= 32768U) {
< #line 2869
<     p.head.h80.magic = 1728214147U;
< #line 2870
<     p.head.h80.command = 0U;
< #line 2871
<     tmp___1 = __fswab16((int )((unsigned int )((int )((__u16 )dgs) + (int )((__u16 )req->size)) + 24U));
< #line 2871
<     p.head.h80.length = tmp___1;
---
> #line 1626
>   if ((unsigned long )p == (unsigned long )((struct p_data *)0)) {
> #line 1627
>     return (-5);
43972,43979c43425
< #line 2874
<     p.head.h95.magic = 23171U;
< #line 2875
<     p.head.h95.command = 0U;
< #line 2876
<     tmp___2 = __fswab32((req->size + (__u32 )dgs) + 24U);
< #line 2876
<     p.head.h95.length = tmp___2;
---
> 
43981,43993c43427,43439
< #line 2880
<   tmp___3 = __fswab64((__u64 )req->sector);
< #line 2880
<   p.sector = tmp___3;
< #line 2881
<   p.block_id = (u64 )req;
< #line 2882
<   tmp___4 = atomic_add_return(1, & mdev->packet_seq);
< #line 2882
<   tmp___5 = __fswab32((__u32 )tmp___4);
< #line 2882
<   p.seq_num = tmp___5;
< #line 2884
---
> #line 1628
>   tmp___1 = __fswab64((__u64 )req->i.sector);
> #line 1628
>   p->sector = tmp___1;
> #line 1629
>   p->block_id = (u64 )req;
> #line 1630
>   tmp___2 = atomic_add_return(1, & mdev->packet_seq);
> #line 1630
>   tmp___3 = __fswab32((__u32 )tmp___2);
> #line 1630
>   p->seq_num = tmp___3;
> #line 1631
43995,43997c43441,43443
< #line 2886
<   if ((int )mdev->state.ldv_40583.conn > 15 && (int )mdev->state.ldv_40583.conn <= 21) {
< #line 2888
---
> #line 1632
>   if ((int )mdev->state.ldv_50103.conn > 15 && (int )mdev->state.ldv_50103.conn <= 21) {
> #line 1634
44002,44021c43448,43463
< #line 2890
<   tmp___6 = __fswab32(dp_flags);
< #line 2890
<   p.dp_flags = tmp___6;
< #line 2891
<   drbd_set_flag(mdev, UNPLUG_REMOTE);
< #line 2892
<   tmp___7 = drbd_send(mdev, mdev->data.socket, (void *)(& p), 32UL, dgs != 0 ? 32768U : 0U);
< #line 2892
<   ok = tmp___7 == 32;
< #line 2894
<   if (ok != 0 && dgs != 0) {
< #line 2895
<     dgb = mdev->int_dig_out;
< #line 2896
<     drbd_csum_bio(mdev, mdev->integrity_w_tfm, req->master_bio, dgb);
< #line 2897
<     tmp___8 = drbd_send(mdev, mdev->data.socket, dgb, (size_t )dgs, 0U);
< #line 2897
<     ok = tmp___8 == dgs;
---
> #line 1635
>   if ((mdev->tconn)->agreed_pro_version > 99) {
> #line 1636
>     if (((unsigned long )req->rq_state & 32768UL) != 0UL) {
> #line 1637
>       dp_flags = dp_flags | 128U;
>     } else {
> 
>     }
> #line 1638
>     if (((unsigned long )req->rq_state & 65536UL) != 0UL) {
> #line 1639
>       dp_flags = dp_flags | 256U;
>     } else {
> 
>     }
44025,44030c43467,43486
< #line 2899
<   if (ok != 0) {
< #line 2911
<     if ((mdev->net_conf)->wire_protocol == 1 || dgs != 0) {
< #line 2912
<       ok = _drbd_send_bio(mdev, req->master_bio);
---
> #line 1641
>   tmp___4 = __fswab32(dp_flags);
> #line 1641
>   p->dp_flags = tmp___4;
> #line 1642
>   if (dgs != 0) {
> #line 1643
>     drbd_csum_bio(mdev, (mdev->tconn)->integrity_tfm, req->master_bio, (void *)p + 1U);
>   } else {
> 
>   }
> #line 1644
>   err = __send_command(mdev->tconn, mdev->vnr, sock, P_DATA, (unsigned int )dgs + 24U,
>                        0, req->i.size);
> #line 1645
>   if (err == 0) {
> #line 1657
>     if (((unsigned long )req->rq_state & 98304UL) == 0UL || dgs != 0) {
> #line 1658
>       err = _drbd_send_bio(mdev, req->master_bio);
44032,44033c43488,43489
< #line 2914
<       ok = _drbd_send_zc_bio(mdev, req->master_bio);
---
> #line 1660
>       err = _drbd_send_zc_bio(mdev, req->master_bio);
44035c43491
< #line 2917
---
> #line 1663
44037,44044c43493,43499
< #line 2921
<       drbd_csum_bio(mdev, mdev->integrity_w_tfm, req->master_bio, (void *)(& digest));
< #line 2922
<       tmp___9 = memcmp((void const   *)mdev->int_dig_out, (void const   *)(& digest),
<                        (size_t )dgs);
< #line 2922
<       if (tmp___9 != 0) {
< #line 2923
---
> #line 1667
>       drbd_csum_bio(mdev, (mdev->tconn)->integrity_tfm, req->master_bio, (void *)(& digest));
> #line 1668
>       tmp___5 = memcmp((void const   *)p + 1U, (void const   *)(& digest), (size_t )dgs);
> #line 1668
>       if (tmp___5 != 0) {
> #line 1669
44046c43501
<                  (unsigned long long )req->sector, req->size);
---
>                  (unsigned long long )req->i.sector, req->i.size);
44056,44059c43511,43514
< #line 2932
<   drbd_put_data_sock(mdev);
< #line 2934
<   return (ok);
---
> #line 1677
>   mutex_unlock(& sock->mutex);
> #line 1679
>   return (err);
44062,44063c43517,43518
< #line 2941 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_block(struct drbd_conf *mdev , enum drbd_packets cmd , struct drbd_epoch_entry *e ) 
---
> #line 1686 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_block(struct drbd_conf *mdev , enum drbd_packet cmd , struct drbd_peer_request *peer_req ) 
44065,44067c43520,43522
<   int ok ;
<   struct p_data p ;
<   void *dgb ;
---
>   struct drbd_socket *sock ;
>   struct p_data *p ;
>   int err ;
44069,44077c43524,43526
<   unsigned int tmp ;
<   __u16 tmp___0 ;
<   __u16 tmp___1 ;
<   __u16 tmp___2 ;
<   __u32 tmp___3 ;
<   __u64 tmp___4 ;
<   int tmp___5 ;
<   int tmp___6 ;
<   int tmp___7 ;
---
>   void *tmp ;
>   unsigned int tmp___0 ;
>   __u64 tmp___1 ;
44080,44085c43529,43540
< #line 2949
<   if (mdev->agreed_pro_version > 86 && (unsigned long )mdev->integrity_w_tfm != (unsigned long )((struct crypto_hash *)0)) {
< #line 2949
<     tmp = crypto_hash_digestsize(mdev->integrity_w_tfm);
< #line 2949
<     dgs = (int )tmp;
---
> #line 1694
>   sock = & (mdev->tconn)->data;
> #line 1695
>   tmp = drbd_prepare_command(mdev, sock);
> #line 1695
>   p = (struct p_data *)tmp;
> #line 1697
>   if ((unsigned long )(mdev->tconn)->integrity_tfm != (unsigned long )((struct crypto_hash *)0)) {
> #line 1697
>     tmp___0 = crypto_hash_digestsize((mdev->tconn)->integrity_tfm);
> #line 1697
>     dgs = (int )tmp___0;
44087c43542
< #line 2949
---
> #line 1697
44090,44125c43545,43548
< #line 2952
<   if (e->size <= 32768U) {
< #line 2953
<     p.head.h80.magic = 1728214147U;
< #line 2954
<     tmp___0 = __fswab16((int )((__u16 )cmd));
< #line 2954
<     p.head.h80.command = tmp___0;
< #line 2955
<     tmp___1 = __fswab16((int )((unsigned int )((int )((__u16 )dgs) + (int )((__u16 )e->size)) + 24U));
< #line 2955
<     p.head.h80.length = tmp___1;
<   } else {
< #line 2958
<     p.head.h95.magic = 23171U;
< #line 2959
<     tmp___2 = __fswab16((int )((__u16 )cmd));
< #line 2959
<     p.head.h95.command = tmp___2;
< #line 2960
<     tmp___3 = __fswab32((e->size + (__u32 )dgs) + 24U);
< #line 2960
<     p.head.h95.length = tmp___3;
<   }
< #line 2964
<   tmp___4 = __fswab64((__u64 )e->sector);
< #line 2964
<   p.sector = tmp___4;
< #line 2965
<   p.block_id = e->ldv_49794.block_id;
< #line 2972
<   tmp___5 = drbd_get_data_sock(mdev);
< #line 2972
<   if (tmp___5 == 0) {
< #line 2973
<     return (0);
---
> #line 1699
>   if ((unsigned long )p == (unsigned long )((struct p_data *)0)) {
> #line 1700
>     return (-5);
44129,44142c43552,43565
< #line 2975
<   tmp___6 = drbd_send(mdev, mdev->data.socket, (void *)(& p), 32UL, dgs != 0 ? 32768U : 0U);
< #line 2975
<   ok = tmp___6 == 32;
< #line 2976
<   if (ok != 0 && dgs != 0) {
< #line 2977
<     dgb = mdev->int_dig_out;
< #line 2978
<     drbd_csum_ee(mdev, mdev->integrity_w_tfm, e, dgb);
< #line 2979
<     tmp___7 = drbd_send(mdev, mdev->data.socket, dgb, (size_t )dgs, 0U);
< #line 2979
<     ok = tmp___7 == dgs;
---
> #line 1701
>   tmp___1 = __fswab64((__u64 )peer_req->i.sector);
> #line 1701
>   p->sector = tmp___1;
> #line 1702
>   p->block_id = peer_req->ldv_50490.block_id;
> #line 1703
>   p->seq_num = 0U;
> #line 1704
>   p->dp_flags = 0U;
> #line 1705
>   if (dgs != 0) {
> #line 1706
>     drbd_csum_ee(mdev, (mdev->tconn)->integrity_tfm, peer_req, (void *)p + 1U);
44146,44149c43569,43575
< #line 2981
<   if (ok != 0) {
< #line 2982
<     ok = _drbd_send_zc_ee(mdev, e);
---
> #line 1707
>   err = __send_command(mdev->tconn, mdev->vnr, sock, cmd, (unsigned int )dgs + 24U,
>                        0, peer_req->i.size);
> #line 1708
>   if (err == 0) {
> #line 1709
>     err = _drbd_send_zc_ee(mdev, peer_req);
44153,44156c43579,43582
< #line 2984
<   drbd_put_data_sock(mdev);
< #line 2986
<   return (ok);
---
> #line 1710
>   mutex_unlock(& sock->mutex);
> #line 1712
>   return (err);
44159,44160c43585,43586
< #line 2989 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send_oos(struct drbd_conf *mdev , struct drbd_request *req ) 
---
> #line 1715 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_out_of_sync(struct drbd_conf *mdev , struct drbd_request *req ) 
44162,44165c43588,43593
<   struct p_block_desc p ;
<   __u64 tmp ;
<   __u32 tmp___0 ;
<   int tmp___1 ;
---
>   struct drbd_socket *sock ;
>   struct p_block_desc *p ;
>   void *tmp ;
>   __u64 tmp___0 ;
>   __u32 tmp___1 ;
>   int tmp___2 ;
44168,44179c43596,43620
< #line 2993
<   tmp = __fswab64((__u64 )req->sector);
< #line 2993
<   p.sector = tmp;
< #line 2994
<   tmp___0 = __fswab32(req->size);
< #line 2994
<   p.blksize = tmp___0;
< #line 2996
<   tmp___1 = drbd_send_cmd(mdev, 1, P_OUT_OF_SYNC, & p.head, 24UL);
< #line 2996
<   return (tmp___1);
---
> #line 1720
>   sock = & (mdev->tconn)->data;
> #line 1721
>   tmp = drbd_prepare_command(mdev, sock);
> #line 1721
>   p = (struct p_block_desc *)tmp;
> #line 1722
>   if ((unsigned long )p == (unsigned long )((struct p_block_desc *)0)) {
> #line 1723
>     return (-5);
>   } else {
> 
>   }
> #line 1724
>   tmp___0 = __fswab64((__u64 )req->i.sector);
> #line 1724
>   p->sector = tmp___0;
> #line 1725
>   tmp___1 = __fswab32(req->i.size);
> #line 1725
>   p->blksize = tmp___1;
> #line 1726
>   tmp___2 = drbd_send_command(mdev, sock, P_OUT_OF_SYNC, 16U, 0, 0U);
> #line 1726
>   return (tmp___2);
44182,44183c43623,43624
< #line 3015 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< int drbd_send(struct drbd_conf *mdev , struct socket *sock , void *buf , size_t size ,
---
> #line 1745 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send(struct drbd_tconn *tconn , struct socket *sock , void *buf , size_t size ,
44189a43631,43632
>   struct net_conf *_________p1 ;
>   bool __warned ;
44191c43634,43636
<   struct task_struct *tmp___0 ;
---
>   int tmp___0 ;
>   int tmp___1 ;
>   struct task_struct *tmp___2 ;
44198c43643
< #line 3020
---
> #line 1750
44200c43645
< #line 3022
---
> #line 1752
44202,44203c43647,43648
< #line 3023
<     return (-1000);
---
> #line 1753
>     return (-53);
44207c43652
< #line 3027
---
> #line 1757
44209c43654
< #line 3028
---
> #line 1758
44211c43656
< #line 3030
---
> #line 1760
44213c43658
< #line 3031
---
> #line 1761
44215c43660
< #line 3032
---
> #line 1762
44217c43662
< #line 3033
---
> #line 1763
44219c43664
< #line 3034
---
> #line 1764
44221,44226c43666,43696
< #line 3036
<   if ((unsigned long )mdev->data.socket == (unsigned long )sock) {
< #line 3037
<     mdev->ko_count = (unsigned int )(mdev->net_conf)->ko_count;
< #line 3038
<     drbd_update_congested(mdev);
---
> #line 1766
>   if ((unsigned long )tconn->data.socket == (unsigned long )sock) {
> #line 1767
>     rcu_read_lock();
> #line 1768
>     _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 1768
>     tmp = debug_lockdep_rcu_enabled();
> #line 1768
>     if (tmp != 0 && ! __warned) {
> #line 1768
>       tmp___0 = rcu_read_lock_held();
> #line 1768
>       if (tmp___0 == 0 && 1) {
> #line 1768
>         __warned = 1;
> #line 1768
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>                                1768, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 1768
>     tconn->ko_count = _________p1->ko_count;
> #line 1769
>     rcu_read_unlock();
> #line 1770
>     drbd_update_congested(tconn);
44230,44231c43700,43701
<   ldv_52440: 
< #line 3050
---
>   ldv_52825: 
> #line 1782
44233c43703
< #line 3051
---
> #line 1783
44235,44240c43705,43710
< #line 3052
<     tmp = we_should_drop_the_connection(mdev, sock);
< #line 3052
<     if (tmp != 0) {
< #line 3053
<       goto ldv_52438;
---
> #line 1784
>     tmp___1 = we_should_drop_the_connection(tconn, sock);
> #line 1784
>     if (tmp___1 != 0) {
> #line 1785
>       goto ldv_52823;
44242,44243c43712,43713
< #line 3055
<       goto ldv_52439;
---
> #line 1787
>       goto ldv_52824;
44248,44257c43718
< #line 3057
<   if (rv == 0) {
< #line 3057
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( rv != 0 ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3057);
<   } else {
< 
<   }
< #line 3058
---
> #line 1789
44259,44263c43720,43724
< #line 3059
<     tmp___0 = get_current();
< #line 3059
<     flush_signals(tmp___0);
< #line 3060
---
> #line 1790
>     tmp___2 = get_current();
> #line 1790
>     flush_signals(tmp___2);
> #line 1791
44268c43729
< #line 3062
---
> #line 1793
44270,44271c43731,43732
< #line 3063
<     goto ldv_52438;
---
> #line 1794
>     goto ldv_52823;
44275c43736
< #line 3064
---
> #line 1795
44277c43738
< #line 3065
---
> #line 1796
44279c43740
< #line 3066
---
> #line 1797
44281,44282c43742,43743
<   ldv_52439: ;
< #line 3067
---
>   ldv_52824: ;
> #line 1798
44284,44285c43745,43746
< #line 3068
<     goto ldv_52440;
---
> #line 1799
>     goto ldv_52825;
44289,44293c43750,43754
<   ldv_52438: ;
< #line 3069
<   if ((unsigned long )mdev->data.socket == (unsigned long )sock) {
< #line 3070
<     drbd_clear_flag(mdev, NET_CONGESTED);
---
>   ldv_52823: ;
> #line 1800
>   if ((unsigned long )tconn->data.socket == (unsigned long )sock) {
> #line 1801
>     clear_bit(0, (unsigned long volatile   *)(& tconn->flags));
44297c43758
< #line 3072
---
> #line 1803
44299c43760
< #line 3073
---
> #line 1804
44301,44305c43762,43765
< #line 3074
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s_sendmsg returned %d\n",
<               (unsigned long )mdev->meta.socket == (unsigned long )sock ? (char *)"msock" : (char *)"sock",
<               rv);
< #line 3077
---
> #line 1805
>       printk("\vd-con %s: %s_sendmsg returned %d\n", tconn->name, (unsigned long )tconn->meta.socket == (unsigned long )sock ? (char *)"msock" : (char *)"sock",
>              rv);
> #line 1808
44307,44309c43767,43769
< #line 3077
<       val.ldv_40583.conn = 4U;
< #line 3077
---
> #line 1808
>       val.ldv_40604.conn = 4U;
> #line 1808
44311,44314c43771,43774
< #line 3077
<       mask.ldv_40583.conn = 31U;
< #line 3077
<       drbd_force_state(mdev, mask, val);
---
> #line 1808
>       mask.ldv_40604.conn = 31U;
> #line 1808
>       conn_request_state(tconn, mask, val, CS_HARD);
44316c43776
< #line 3079
---
> #line 1810
44318,44320c43778,43780
< #line 3079
<       val___0.ldv_40583.conn = 3U;
< #line 3079
---
> #line 1810
>       val___0.ldv_40604.conn = 3U;
> #line 1810
44322,44325c43782,43785
< #line 3079
<       mask___0.ldv_40583.conn = 31U;
< #line 3079
<       drbd_force_state(mdev, mask___0, val___0);
---
> #line 1810
>       mask___0.ldv_40604.conn = 31U;
> #line 1810
>       conn_request_state(tconn, mask___0, val___0, CS_HARD);
44330c43790
< #line 3082
---
> #line 1813
44334c43794,43821
< #line 3085 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1821 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_send_all(struct drbd_tconn *tconn , struct socket *sock , void *buffer ,
>                   size_t size , unsigned int msg_flags ) 
> { 
>   int err ;
> 
>   {
> #line 1826
>   err = drbd_send(tconn, sock, buffer, size, msg_flags);
> #line 1827
>   if (err < 0) {
> #line 1828
>     return (err);
>   } else {
> 
>   }
> #line 1829
>   if ((size_t )err != size) {
> #line 1830
>     return (-5);
>   } else {
> 
>   }
> #line 1831
>   return (0);
> }
> }
> #line 1834 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
44343c43830
< #line 3087
---
> #line 1836
44345c43832
< #line 3089
---
> #line 1838
44347c43834
< #line 3091
---
> #line 1840
44349,44351c43836,43838
< #line 3092
<   tmp = spinlock_check(& mdev->req_lock);
< #line 3092
---
> #line 1841
>   tmp = spinlock_check(& (mdev->tconn)->req_lock);
> #line 1841
44353,44355c43840,43842
< #line 3096
<   if ((unsigned int )*((unsigned char *)mdev + 2276UL) != 1U) {
< #line 3097
---
> #line 1845
>   if ((unsigned int )*((unsigned char *)mdev + 748UL) != 1U) {
> #line 1846
44357c43844
< #line 3098
---
> #line 1847
44360c43847
< #line 3099
---
> #line 1848
44362c43849
< #line 3100
---
> #line 1849
44370c43857
< #line 3103
---
> #line 1852
44372c43859
< #line 3104
---
> #line 1853
44377,44379c43864,43866
< #line 3105
<   spin_unlock_irqrestore(& mdev->req_lock, flags);
< #line 3106
---
> #line 1854
>   spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
> #line 1855
44381c43868
< #line 3108
---
> #line 1857
44385c43872
< #line 3111 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1860 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
44391c43878
< #line 3113
---
> #line 1862
44393c43880
< #line 3114
---
> #line 1863
44395c43882
< #line 3115
---
> #line 1864
44397c43884
< #line 3116
---
> #line 1865
44399c43886
< #line 3117
---
> #line 1866
44403c43890
< #line 3120 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1869 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
44406,44407c43893
<   struct syncer_conf __constr_expr_0 ;
<   union drbd_state __constr_expr_1 ;
---
>   union drbd_dev_state __constr_expr_0 ;
44410,44784c43896,43918
< #line 3124
<   __constr_expr_0.rate = 250;
< #line 3124
<   __constr_expr_0.after = -1;
< #line 3124
<   __constr_expr_0.al_extents = 127;
< #line 3124
<   __constr_expr_0.verify_alg[0] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[1] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[2] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[3] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[4] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[5] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[6] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[7] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[8] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[9] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[10] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[11] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[12] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[13] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[14] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[15] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[16] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[17] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[18] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[19] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[20] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[21] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[22] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[23] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[24] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[25] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[26] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[27] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[28] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[29] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[30] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[31] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[32] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[33] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[34] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[35] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[36] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[37] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[38] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[39] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[40] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[41] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[42] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[43] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[44] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[45] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[46] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[47] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[48] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[49] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[50] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[51] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[52] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[53] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[54] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[55] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[56] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[57] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[58] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[59] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[60] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[61] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[62] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg[63] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.verify_alg_len = 0;
< #line 3124
<   __constr_expr_0.cpu_mask[0] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[1] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[2] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[3] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[4] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[5] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[6] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[7] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[8] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[9] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[10] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[11] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[12] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[13] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[14] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[15] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[16] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[17] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[18] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[19] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[20] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[21] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[22] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[23] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[24] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[25] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[26] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[27] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[28] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[29] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[30] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask[31] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.cpu_mask_len = 0;
< #line 3124
<   __constr_expr_0.csums_alg[0] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[1] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[2] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[3] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[4] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[5] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[6] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[7] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[8] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[9] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[10] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[11] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[12] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[13] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[14] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[15] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[16] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[17] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[18] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[19] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[20] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[21] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[22] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[23] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[24] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[25] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[26] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[27] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[28] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[29] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[30] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[31] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[32] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[33] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[34] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[35] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[36] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[37] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[38] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[39] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[40] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[41] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[42] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[43] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[44] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[45] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[46] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[47] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[48] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[49] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[50] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[51] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[52] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[53] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[54] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[55] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[56] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[57] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[58] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[59] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[60] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[61] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[62] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg[63] = (unsigned char)0;
< #line 3124
<   __constr_expr_0.csums_alg_len = 0;
< #line 3124
<   __constr_expr_0.use_rle = 0U;
< #line 3124
<   __constr_expr_0.on_no_data = 0;
< #line 3124
<   __constr_expr_0.c_plan_ahead = 0;
< #line 3124
<   __constr_expr_0.c_delay_target = 10;
< #line 3124
<   __constr_expr_0.c_fill_target = 0;
< #line 3124
<   __constr_expr_0.c_max_rate = 102400;
< #line 3124
<   __constr_expr_0.c_min_rate = 4096;
< #line 3124
<   mdev->sync_conf = __constr_expr_0;
< #line 3142
<   __constr_expr_1.ldv_40583.role = 2U;
< #line 3142
<   __constr_expr_1.ldv_40583.peer = 0U;
< #line 3142
<   __constr_expr_1.ldv_40583.conn = 0U;
< #line 3142
<   __constr_expr_1.ldv_40583.disk = 0U;
< #line 3142
<   __constr_expr_1.ldv_40583.pdsk = 6U;
< #line 3142
<   __constr_expr_1.ldv_40583.susp = 0U;
< #line 3142
<   __constr_expr_1.ldv_40583.aftr_isp = (unsigned char)0;
< #line 3142
<   __constr_expr_1.ldv_40583.peer_isp = (unsigned char)0;
< #line 3142
<   __constr_expr_1.ldv_40583.user_isp = (unsigned char)0;
< #line 3142
<   __constr_expr_1.ldv_40583.susp_nod = 0U;
< #line 3142
<   __constr_expr_1.ldv_40583.susp_fen = 0U;
< #line 3142
<   __constr_expr_1.ldv_40583._pad = (unsigned short)0;
< #line 3142
<   mdev->state = __constr_expr_1;
< #line 3143
---
> #line 1873
>   __constr_expr_0.ldv_50103.role = 2U;
> #line 1873
>   __constr_expr_0.ldv_50103.peer = 0U;
> #line 1873
>   __constr_expr_0.ldv_50103.conn = 0U;
> #line 1873
>   __constr_expr_0.ldv_50103.disk = 0U;
> #line 1873
>   __constr_expr_0.ldv_50103.pdsk = 6U;
> #line 1873
>   __constr_expr_0.ldv_50103._unused = (unsigned char)0;
> #line 1873
>   __constr_expr_0.ldv_50103.aftr_isp = (unsigned char)0;
> #line 1873
>   __constr_expr_0.ldv_50103.peer_isp = (unsigned char)0;
> #line 1873
>   __constr_expr_0.ldv_50103.user_isp = (unsigned char)0;
> #line 1873
>   __constr_expr_0.ldv_50103._pad = (unsigned short)0;
> #line 1873
>   mdev->state = __constr_expr_0;
> #line 1874
44788c43922
< #line 3154 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1882 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
44803,44809d43936
<   struct lock_class_key __key___11 ;
<   struct lock_class_key __key___12 ;
<   struct lock_class_key __key___13 ;
<   struct lock_class_key __key___14 ;
<   struct lock_class_key __key___15 ;
<   struct lock_class_key __key___16 ;
<   struct lock_class_key __key___17 ;
44812c43939
< #line 3159
---
> #line 1887
44814c43941
< #line 3161
---
> #line 1889
44816c43943
< #line 3162
---
> #line 1890
44818c43945
< #line 3163
---
> #line 1891
44820c43947
< #line 3164
---
> #line 1892
44822c43949
< #line 3165
---
> #line 1893
44824,44830c43951
< #line 3166
<   atomic_set(& mdev->net_cnt, 0);
< #line 3167
<   atomic_set(& mdev->packet_seq, 0);
< #line 3168
<   atomic_set(& mdev->pp_in_use, 0);
< #line 3169
---
> #line 1894
44832c43953
< #line 3170
---
> #line 1895
44834c43955
< #line 3171
---
> #line 1896
44836c43957
< #line 3172
---
> #line 1897
44838c43959
< #line 3173
---
> #line 1898
44840,44860c43961,43965
< #line 3175
<   __mutex_init(& mdev->data.mutex, "&mdev->data.mutex", & __key);
< #line 3176
<   __mutex_init(& mdev->meta.mutex, "&mdev->meta.mutex", & __key___0);
< #line 3177
<   sema_init(& mdev->data.work.s, 0);
< #line 3178
<   sema_init(& mdev->meta.work.s, 0);
< #line 3179
<   __mutex_init(& mdev->state_mutex, "&mdev->state_mutex", & __key___1);
< #line 3181
<   spinlock_check(& mdev->data.work.q_lock);
< #line 3181
<   __raw_spin_lock_init(& mdev->data.work.q_lock.ldv_6135.rlock, "&(&mdev->data.work.q_lock)->rlock",
<                        & __key___2);
< #line 3182
<   spinlock_check(& mdev->meta.work.q_lock);
< #line 3182
<   __raw_spin_lock_init(& mdev->meta.work.q_lock.ldv_6135.rlock, "&(&mdev->meta.work.q_lock)->rlock",
<                        & __key___3);
< #line 3184
---
> #line 1900
>   __mutex_init(& mdev->own_state_mutex, "&mdev->own_state_mutex", & __key);
> #line 1901
>   mdev->state_mutex = & mdev->own_state_mutex;
> #line 1903
44862c43967
< #line 3184
---
> #line 1903
44864,44870c43969,43970
<                        & __key___4);
< #line 3185
<   spinlock_check(& mdev->req_lock);
< #line 3185
<   __raw_spin_lock_init(& mdev->req_lock.ldv_6135.rlock, "&(&mdev->req_lock)->rlock",
<                        & __key___5);
< #line 3186
---
>                        & __key___0);
> #line 1904
44872c43972
< #line 3186
---
> #line 1904
44874,44880c43974,43975
<                        & __key___6);
< #line 3187
<   spinlock_check(& mdev->epoch_lock);
< #line 3187
<   __raw_spin_lock_init(& mdev->epoch_lock.ldv_6135.rlock, "&(&mdev->epoch_lock)->rlock",
<                        & __key___7);
< #line 3189
---
>                        & __key___1);
> #line 1906
44882c43977
< #line 3190
---
> #line 1907
44884c43979
< #line 3191
---
> #line 1908
44886c43981
< #line 3192
---
> #line 1909
44888c43983
< #line 3193
---
> #line 1910
44890c43985
< #line 3194
---
> #line 1911
44892,44896c43987
< #line 3195
<   INIT_LIST_HEAD(& mdev->data.work.q);
< #line 3196
<   INIT_LIST_HEAD(& mdev->meta.work.q);
< #line 3197
---
> #line 1912
44898c43989
< #line 3198
---
> #line 1913
44900c43991
< #line 3199
---
> #line 1914
44902c43993
< #line 3200
---
> #line 1915
44904c43995
< #line 3201
---
> #line 1916
44906c43997
< #line 3202
---
> #line 1917
44908c43999
< #line 3204
---
> #line 1919
44910c44001
< #line 3205
---
> #line 1920
44912c44003
< #line 3206
---
> #line 1921
44914c44005
< #line 3207
---
> #line 1922
44916c44007
< #line 3208
---
> #line 1923
44918c44009
< #line 3209
---
> #line 1924
44920,44928c44011,44031
< #line 3210
<   init_timer_key(& mdev->resync_timer, 0U, "(&mdev->resync_timer)", & __key___8);
< #line 3211
<   init_timer_key(& mdev->md_sync_timer, 0U, "(&mdev->md_sync_timer)", & __key___9);
< #line 3212
<   init_timer_key(& mdev->start_resync_timer, 0U, "(&mdev->start_resync_timer)", & __key___10);
< #line 3213
<   init_timer_key(& mdev->request_timer, 0U, "(&mdev->request_timer)", & __key___11);
< #line 3214
---
> #line 1926
>   mdev->resync_work.ldv_50388.mdev = mdev;
> #line 1927
>   mdev->unplug_work.ldv_50388.mdev = mdev;
> #line 1928
>   mdev->go_diskless.ldv_50388.mdev = mdev;
> #line 1929
>   mdev->md_sync_work.ldv_50388.mdev = mdev;
> #line 1930
>   mdev->bm_io_work.w.ldv_50388.mdev = mdev;
> #line 1931
>   mdev->start_resync_work.ldv_50388.mdev = mdev;
> #line 1933
>   init_timer_key(& mdev->resync_timer, 0U, "(&mdev->resync_timer)", & __key___2);
> #line 1934
>   init_timer_key(& mdev->md_sync_timer, 0U, "(&mdev->md_sync_timer)", & __key___3);
> #line 1935
>   init_timer_key(& mdev->start_resync_timer, 0U, "(&mdev->start_resync_timer)", & __key___4);
> #line 1936
>   init_timer_key(& mdev->request_timer, 0U, "(&mdev->request_timer)", & __key___5);
> #line 1937
44930c44033
< #line 3215
---
> #line 1938
44932c44035
< #line 3216
---
> #line 1939
44934c44037
< #line 3217
---
> #line 1940
44936c44039
< #line 3218
---
> #line 1941
44938c44041
< #line 3219
---
> #line 1942
44940c44043
< #line 3220
---
> #line 1943
44942c44045
< #line 3221
---
> #line 1944
44944,44966c44047,44057
< #line 3223
<   __init_waitqueue_head(& mdev->misc_wait, "&mdev->misc_wait", & __key___12);
< #line 3224
<   __init_waitqueue_head(& mdev->state_wait, "&mdev->state_wait", & __key___13);
< #line 3225
<   __init_waitqueue_head(& mdev->net_cnt_wait, "&mdev->net_cnt_wait", & __key___14);
< #line 3226
<   __init_waitqueue_head(& mdev->ee_wait, "&mdev->ee_wait", & __key___15);
< #line 3227
<   __init_waitqueue_head(& mdev->al_wait, "&mdev->al_wait", & __key___16);
< #line 3228
<   __init_waitqueue_head(& mdev->seq_wait, "&mdev->seq_wait", & __key___17);
< #line 3230
<   drbd_thread_init(mdev, & mdev->receiver, & drbdd_init);
< #line 3231
<   drbd_thread_init(mdev, & mdev->worker, & drbd_worker);
< #line 3232
<   drbd_thread_init(mdev, & mdev->asender, & drbd_asender);
< #line 3234
<   mdev->agreed_pro_version = 97;
< #line 3235
<   mdev->write_ordering = WO_bdev_flush;
< #line 3236
---
> #line 1946
>   __init_waitqueue_head(& mdev->misc_wait, "&mdev->misc_wait", & __key___6);
> #line 1947
>   __init_waitqueue_head(& mdev->state_wait, "&mdev->state_wait", & __key___7);
> #line 1948
>   __init_waitqueue_head(& mdev->ee_wait, "&mdev->ee_wait", & __key___8);
> #line 1949
>   __init_waitqueue_head(& mdev->al_wait, "&mdev->al_wait", & __key___9);
> #line 1950
>   __init_waitqueue_head(& mdev->seq_wait, "&mdev->seq_wait", & __key___10);
> #line 1952
44968c44059
< #line 3237
---
> #line 1953
44970c44061
< #line 3238
---
> #line 1954
44972c44063
< #line 3239
---
> #line 1955
44976c44067
< #line 3241 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 1957 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
44980,44981c44071,44072
<   int tmp ;
<   int tmp___0 ;
---
>   unsigned int tmp ;
>   unsigned int tmp___0 ;
44985,44987c44076,44078
<   unsigned int tmp___4 ;
<   unsigned int tmp___5 ;
<   sector_t tmp___6 ;
---
>   sector_t tmp___4 ;
>   unsigned long tmp___5 ;
>   unsigned long tmp___6 ;
44989,44990c44080,44081
<   unsigned long tmp___8 ;
<   unsigned long tmp___9 ;
---
>   int tmp___8 ;
>   int tmp___9 ;
44999,45001d44089
<   int tmp___18 ;
<   int tmp___19 ;
<   int tmp___20 ;
45004,45006c44092,44094
< #line 3244
<   if ((unsigned int )mdev->receiver.t_state != 0U) {
< #line 3245
---
> #line 1960
>   if ((unsigned int )(mdev->tconn)->receiver.t_state != 0U) {
> #line 1961
45008,45020c44096
<             (unsigned int )mdev->receiver.t_state);
<   } else {
< 
<   }
< #line 3249
<   tmp___0 = atomic_read((atomic_t const   *)(& (mdev->current_epoch)->epoch_size));
< #line 3249
<   if (tmp___0 != 0) {
< #line 3250
<     tmp = atomic_read((atomic_t const   *)(& (mdev->current_epoch)->epoch_size));
< #line 3250
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "epoch_size:%d\n",
<             tmp);
---
>             (unsigned int )(mdev->tconn)->receiver.t_state);
45024,45036c44100,44104
< #line 3251
<   tmp___9 = 0UL;
< #line 3251
<   mdev->rs_failed = tmp___9;
< #line 3251
<   tmp___8 = tmp___9;
< #line 3251
<   mdev->rs_total = tmp___8;
< #line 3251
<   tmp___7 = tmp___8;
< #line 3251
<   mdev->rs_start = tmp___7;
< #line 3251
---
> #line 1964
>   tmp___7 = 0UL;
> #line 1964
>   mdev->rs_failed = tmp___7;
> #line 1964
45038,45044c44106,44112
< #line 3251
<   mdev->p_size = tmp___6;
< #line 3251
<   tmp___5 = (unsigned int )tmp___6;
< #line 3251
<   mdev->writ_cnt = tmp___5;
< #line 3251
---
> #line 1964
>   mdev->rs_total = tmp___6;
> #line 1964
>   tmp___5 = tmp___6;
> #line 1964
>   mdev->rs_start = tmp___5;
> #line 1964
45046,45052c44114,44120
< #line 3251
<   mdev->send_cnt = tmp___4;
< #line 3251
<   tmp___3 = tmp___4;
< #line 3251
<   mdev->recv_cnt = tmp___3;
< #line 3251
---
> #line 1964
>   mdev->p_size = tmp___4;
> #line 1964
>   tmp___3 = (unsigned int )tmp___4;
> #line 1964
>   mdev->writ_cnt = tmp___3;
> #line 1964
45054,45056c44122,44124
< #line 3251
<   mdev->read_cnt = tmp___2;
< #line 3251
---
> #line 1964
>   mdev->send_cnt = tmp___2;
> #line 1964
45058,45062c44126,44138
< #line 3251
<   mdev->bm_writ_cnt = tmp___1;
< #line 3251
<   mdev->al_writ_cnt = tmp___1;
< #line 3261
---
> #line 1964
>   mdev->recv_cnt = tmp___1;
> #line 1964
>   tmp___0 = tmp___1;
> #line 1964
>   mdev->read_cnt = tmp___0;
> #line 1964
>   tmp = tmp___0;
> #line 1964
>   mdev->bm_writ_cnt = tmp;
> #line 1964
>   mdev->al_writ_cnt = tmp;
> #line 1974
45064c44140
< #line 3262
---
> #line 1975
45066c44142
< #line 3263
---
> #line 1976
45068,45071c44144,44147
< #line 3263
<   goto ldv_52496;
<   ldv_52495: 
< #line 3264
---
> #line 1976
>   goto ldv_52881;
>   ldv_52880: 
> #line 1977
45073c44149
< #line 3265
---
> #line 1978
45075c44151
< #line 3263
---
> #line 1976
45077,45078c44153,44154
<   ldv_52496: ;
< #line 3263
---
>   ldv_52881: ;
> #line 1976
45080,45081c44156,44157
< #line 3264
<     goto ldv_52495;
---
> #line 1977
>     goto ldv_52880;
45086,45091c44162,44167
< #line 3267
<   if ((unsigned long )mdev->net_conf != (unsigned long )((struct net_conf *)0)) {
< #line 3267
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->net_conf == NULL ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3267);
---
> #line 1980
>   if ((unsigned long )(mdev->tconn)->net_conf != (unsigned long )((struct net_conf *)0)) {
> #line 1980
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->tconn->net_conf == NULL ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             1980);
45095c44171
< #line 3269
---
> #line 1982
45097c44173
< #line 3270
---
> #line 1983
45099c44175
< #line 3272
---
> #line 1985
45101c44177
< #line 3273
---
> #line 1986
45106,45114c44182,44192
< #line 3276
<   drbd_free_resources(mdev);
< #line 3277
<   drbd_clear_flag(mdev, AL_SUSPENDED);
< #line 3283
<   tmp___10 = list_empty((struct list_head  const  *)(& mdev->active_ee));
< #line 3283
<   if (tmp___10 == 0) {
< #line 3283
---
> #line 1989
>   drbd_free_bc(mdev->ldev);
> #line 1990
>   mdev->ldev = 0;
> #line 1992
>   clear_bit(18, (unsigned long volatile   *)(& mdev->flags));
> #line 1994
>   tmp___8 = list_empty((struct list_head  const  *)(& mdev->active_ee));
> #line 1994
>   if (tmp___8 == 0) {
> #line 1994
45116,45117c44194,44195
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3283);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             1994);
45121,45125c44199,44203
< #line 3284
<   tmp___11 = list_empty((struct list_head  const  *)(& mdev->sync_ee));
< #line 3284
<   if (tmp___11 == 0) {
< #line 3284
---
> #line 1995
>   tmp___9 = list_empty((struct list_head  const  *)(& mdev->sync_ee));
> #line 1995
>   if (tmp___9 == 0) {
> #line 1995
45127,45128c44205,44206
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3284);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             1995);
45132,45136c44210,44214
< #line 3285
<   tmp___12 = list_empty((struct list_head  const  *)(& mdev->done_ee));
< #line 3285
<   if (tmp___12 == 0) {
< #line 3285
---
> #line 1996
>   tmp___10 = list_empty((struct list_head  const  *)(& mdev->done_ee));
> #line 1996
>   if (tmp___10 == 0) {
> #line 1996
45138,45139c44216,44217
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3285);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             1996);
45143,45147c44221,44225
< #line 3286
<   tmp___13 = list_empty((struct list_head  const  *)(& mdev->read_ee));
< #line 3286
<   if (tmp___13 == 0) {
< #line 3286
---
> #line 1997
>   tmp___11 = list_empty((struct list_head  const  *)(& mdev->read_ee));
> #line 1997
>   if (tmp___11 == 0) {
> #line 1997
45149,45150c44227,44228
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3286);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             1997);
45154,45158c44232,44236
< #line 3287
<   tmp___14 = list_empty((struct list_head  const  *)(& mdev->net_ee));
< #line 3287
<   if (tmp___14 == 0) {
< #line 3287
---
> #line 1998
>   tmp___12 = list_empty((struct list_head  const  *)(& mdev->net_ee));
> #line 1998
>   if (tmp___12 == 0) {
> #line 1998
45160,45161c44238,44239
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3287);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             1998);
45165,45169c44243,44247
< #line 3288
<   tmp___15 = list_empty((struct list_head  const  *)(& mdev->resync_reads));
< #line 3288
<   if (tmp___15 == 0) {
< #line 3288
---
> #line 1999
>   tmp___13 = list_empty((struct list_head  const  *)(& mdev->resync_reads));
> #line 1999
>   if (tmp___13 == 0) {
> #line 1999
45171,45183c44249,44250
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3288);
<   } else {
< 
<   }
< #line 3289
<   tmp___16 = list_empty((struct list_head  const  *)(& mdev->data.work.q));
< #line 3289
<   if (tmp___16 == 0) {
< #line 3289
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( list_empty(&mdev->data.work.q) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3289);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             1999);
45187,45194c44254,44261
< #line 3290
<   tmp___17 = list_empty((struct list_head  const  *)(& mdev->meta.work.q));
< #line 3290
<   if (tmp___17 == 0) {
< #line 3290
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( list_empty(&mdev->meta.work.q) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3290);
---
> #line 2000
>   tmp___14 = list_empty((struct list_head  const  *)(& (mdev->tconn)->sender_work.q));
> #line 2000
>   if (tmp___14 == 0) {
> #line 2000
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( list_empty(&mdev->tconn->sender_work.q) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             2000);
45198,45202c44265,44269
< #line 3291
<   tmp___18 = list_empty((struct list_head  const  *)(& mdev->resync_work.list));
< #line 3291
<   if (tmp___18 == 0) {
< #line 3291
---
> #line 2001
>   tmp___15 = list_empty((struct list_head  const  *)(& mdev->resync_work.list));
> #line 2001
>   if (tmp___15 == 0) {
> #line 2001
45204,45205c44271,44272
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3291);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             2001);
45209,45213c44276,44280
< #line 3292
<   tmp___19 = list_empty((struct list_head  const  *)(& mdev->unplug_work.list));
< #line 3292
<   if (tmp___19 == 0) {
< #line 3292
---
> #line 2002
>   tmp___16 = list_empty((struct list_head  const  *)(& mdev->unplug_work.list));
> #line 2002
>   if (tmp___16 == 0) {
> #line 2002
45215,45216c44282,44283
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3292);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             2002);
45220,45224c44287,44291
< #line 3293
<   tmp___20 = list_empty((struct list_head  const  *)(& mdev->go_diskless.list));
< #line 3293
<   if (tmp___20 == 0) {
< #line 3293
---
> #line 2003
>   tmp___17 = list_empty((struct list_head  const  *)(& mdev->go_diskless.list));
> #line 2003
>   if (tmp___17 == 0) {
> #line 2003
45226,45227c44293,44294
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3293);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             2003);
45231c44298
< #line 3295
---
> #line 2005
45233c44300
< #line 3296
---
> #line 2006
45237c44304
< #line 3299 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 2009 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
45243,45246c44310,44313
< #line 3303
<   goto ldv_52503;
<   ldv_52502: 
< #line 3304
---
> #line 2013
>   goto ldv_52888;
>   ldv_52887: 
> #line 2014
45248c44315
< #line 3305
---
> #line 2015
45250c44317
< #line 3306
---
> #line 2016
45252c44319
< #line 3307
---
> #line 2017
45254,45255c44321,44322
<   ldv_52503: ;
< #line 3303
---
>   ldv_52888: ;
> #line 2013
45257,45258c44324,44325
< #line 3304
<     goto ldv_52502;
---
> #line 2014
>     goto ldv_52887;
45263c44330
< #line 3312
---
> #line 2022
45265c44332
< #line 3313
---
> #line 2023
45270c44337
< #line 3314
---
> #line 2024
45272c44339
< #line 3315
---
> #line 2025
45277c44344
< #line 3316
---
> #line 2026
45279c44346
< #line 3317
---
> #line 2027
45284c44351
< #line 3318
---
> #line 2028
45286c44353
< #line 3319
---
> #line 2029
45291c44358
< #line 3320
---
> #line 2030
45293c44360
< #line 3321
---
> #line 2031
45298c44365
< #line 3322
---
> #line 2032
45300c44367
< #line 3323
---
> #line 2033
45305c44372
< #line 3324
---
> #line 2034
45307c44374
< #line 3325
---
> #line 2035
45312c44379
< #line 3326
---
> #line 2036
45314c44381
< #line 3327
---
> #line 2037
45319c44386
< #line 3329
---
> #line 2039
45321c44388
< #line 3330
---
> #line 2040
45323c44390
< #line 3331
---
> #line 2041
45325c44392
< #line 3332
---
> #line 2042
45327c44394
< #line 3333
---
> #line 2043
45329c44396
< #line 3334
---
> #line 2044
45331c44398
< #line 3335
---
> #line 2045
45333c44400
< #line 3336
---
> #line 2046
45335c44402
< #line 3338
---
> #line 2048
45339c44406
< #line 3341 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 2051 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
45348,45350c44415,44417
< #line 3344
<   number = (int const   )(minor_count * 32U);
< #line 3348
---
> #line 2054
>   number = (int const   )(minor_count * 256U);
> #line 2058
45352c44419
< #line 3349
---
> #line 2059
45354c44421
< #line 3350
---
> #line 2060
45356c44423
< #line 3351
---
> #line 2061
45358c44425
< #line 3352
---
> #line 2062
45360c44427
< #line 3353
---
> #line 2063
45362c44429
< #line 3354
---
> #line 2064
45364c44431
< #line 3355
---
> #line 2065
45366,45368c44433,44435
< #line 3358
<   drbd_request_cache = kmem_cache_create("drbd_req", 112UL, 0UL, 0UL, 0);
< #line 3360
---
> #line 2068
>   drbd_request_cache = kmem_cache_create("drbd_req", 152UL, 0UL, 0UL, 0);
> #line 2070
45370c44437
< #line 3361
---
> #line 2071
45375,45377c44442,44444
< #line 3363
<   drbd_ee_cache = kmem_cache_create("drbd_ee", 96UL, 0UL, 0UL, 0);
< #line 3365
---
> #line 2073
>   drbd_ee_cache = kmem_cache_create("drbd_ee", 128UL, 0UL, 0UL, 0);
> #line 2075
45379c44446
< #line 3366
---
> #line 2076
45384c44451
< #line 3368
---
> #line 2078
45386c44453
< #line 3370
---
> #line 2080
45388c44455
< #line 3371
---
> #line 2081
45393c44460
< #line 3373
---
> #line 2083
45395c44462
< #line 3375
---
> #line 2085
45397c44464,44473
< #line 3376
---
> #line 2086
>     goto Enomem;
>   } else {
> 
>   }
> #line 2089
>   drbd_md_io_bio_set = bioset_create(128U, 0U);
> #line 2090
>   if ((unsigned long )drbd_md_io_bio_set == (unsigned long )((struct bio_set *)0)) {
> #line 2091
45402c44478
< #line 3385
---
> #line 2093
45404c44480
< #line 3386
---
> #line 2094
45406c44482
< #line 3387
---
> #line 2095
45411c44487
< #line 3389
---
> #line 2097
45414c44490
< #line 3391
---
> #line 2099
45416c44492
< #line 3392
---
> #line 2100
45421c44497
< #line 3394
---
> #line 2102
45424c44500
< #line 3396
---
> #line 2104
45426c44502
< #line 3397
---
> #line 2105
45431c44507
< #line 3400
---
> #line 2108
45433c44509
< #line 3400
---
> #line 2108
45435c44511
< #line 3402
---
> #line 2110
45437,45440c44513,44516
< #line 3402
<   goto ldv_52514;
<   ldv_52513: 
< #line 3403
---
> #line 2110
>   goto ldv_52899;
>   ldv_52898: 
> #line 2111
45442c44518
< #line 3404
---
> #line 2112
45444c44520
< #line 3405
---
> #line 2113
45449c44525
< #line 3406
---
> #line 2114
45451c44527
< #line 3407
---
> #line 2115
45453c44529
< #line 3402
---
> #line 2110
45455,45456c44531,44532
<   ldv_52514: ;
< #line 3402
---
>   ldv_52899: ;
> #line 2110
45458,45459c44534,44535
< #line 3403
<     goto ldv_52513;
---
> #line 2111
>     goto ldv_52898;
45463c44539
< #line 3409
---
> #line 2117
45465c44541
< #line 3411
---
> #line 2119
45468c44544
< #line 3414
---
> #line 2122
45470c44546
< #line 3415
---
> #line 2123
45474c44550
< #line 3418 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 2126 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
45480c44556
< #line 3425
---
> #line 2133
45484c44560
< #line 3428 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 2136 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
45486,45487c44562,44563
< #line 3432 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void drbd_release_ee_lists(struct drbd_conf *mdev ) 
---
> #line 2140 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static void drbd_release_all_peer_reqs(struct drbd_conf *mdev ) 
45492,45494c44568,44570
< #line 3436
<   rr = drbd_release_ee(mdev, & mdev->active_ee);
< #line 3437
---
> #line 2144
>   rr = drbd_free_peer_reqs(mdev, & mdev->active_ee);
> #line 2145
45496c44572
< #line 3438
---
> #line 2146
45502,45504c44578,44580
< #line 3440
<   rr = drbd_release_ee(mdev, & mdev->sync_ee);
< #line 3441
---
> #line 2148
>   rr = drbd_free_peer_reqs(mdev, & mdev->sync_ee);
> #line 2149
45506c44582
< #line 3442
---
> #line 2150
45512,45514c44588,44590
< #line 3444
<   rr = drbd_release_ee(mdev, & mdev->read_ee);
< #line 3445
---
> #line 2152
>   rr = drbd_free_peer_reqs(mdev, & mdev->read_ee);
> #line 2153
45516c44592
< #line 3446
---
> #line 2154
45522,45524c44598,44600
< #line 3448
<   rr = drbd_release_ee(mdev, & mdev->done_ee);
< #line 3449
---
> #line 2156
>   rr = drbd_free_peer_reqs(mdev, & mdev->done_ee);
> #line 2157
45526c44602
< #line 3450
---
> #line 2158
45532,45534c44608,44610
< #line 3452
<   rr = drbd_release_ee(mdev, & mdev->net_ee);
< #line 3453
---
> #line 2160
>   rr = drbd_free_peer_reqs(mdev, & mdev->net_ee);
> #line 2161
45536c44612
< #line 3454
---
> #line 2162
45542c44618
< #line 3455
---
> #line 2163
45546,45547c44622,44623
< #line 3459 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static void drbd_delete_device(unsigned int minor ) 
---
> #line 2166 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void drbd_minor_destroy(struct kref *kref ) 
45550,45553c44626,44627
<   struct drbd_conf *tmp ;
<   struct list_head *lp ;
<   int _b ;
<   int tmp___0 ;
---
>   struct kref  const  *__mptr ;
>   struct drbd_tconn *tconn ;
45556,45563c44630,44643
< #line 3461
<   tmp = minor_to_mdev(minor);
< #line 3461
<   mdev = tmp;
< #line 3463
<   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
< #line 3464
<     return;
---
> #line 2168
>   __mptr = (struct kref  const  *)kref;
> #line 2168
>   mdev = (struct drbd_conf *)__mptr + 0xfffffffffffffff4UL;
> #line 2169
>   tconn = mdev->tconn;
> #line 2171
>   del_timer_sync(& mdev->request_timer);
> #line 2174
>   if (mdev->open_cnt != 0) {
> #line 2174
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->open_cnt == 0 ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             2174);
45567,45574c44647,44650
< #line 3466
<   del_timer_sync(& mdev->request_timer);
< #line 3469
<   if (mdev->open_cnt != 0) {
< #line 3470
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "open_cnt = %d in %s:%u",
<             mdev->open_cnt, (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3471);
---
> #line 2180
>   if ((unsigned long )mdev->this_bdev != (unsigned long )((struct block_device *)0)) {
> #line 2181
>     bdput(mdev->this_bdev);
45578,45587c44654,44669
< #line 3473
<   tmp___0 = list_empty((struct list_head  const  *)(& mdev->data.work.q));
< #line 3473
<   _b = tmp___0 == 0;
< #line 3473
<   if (_b != 0) {
< #line 3473
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_delete_device", (char *)"!list_empty(&mdev->data.work.q)", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3473);
---
> #line 2183
>   drbd_free_bc(mdev->ldev);
> #line 2184
>   mdev->ldev = 0;
> #line 2186
>   drbd_release_all_peer_reqs(mdev);
> #line 2188
>   lc_destroy(mdev->act_log);
> #line 2189
>   lc_destroy(mdev->resync);
> #line 2191
>   kfree((void const   *)mdev->p_uuid);
> #line 2194
>   if ((unsigned long )mdev->bitmap != (unsigned long )((struct drbd_bitmap *)0)) {
> #line 2195
>     drbd_bm_cleanup(mdev);
45591,45607c44673,44765
< #line 3473
<   if (_b != 0) {
< #line 3475
<     lp = mdev->data.work.q.next;
< #line 3475
<     goto ldv_52535;
<     ldv_52534: 
< #line 3476
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "lp = %p\n",
<             lp);
< #line 3475
<     lp = lp->next;
<     ldv_52535: ;
< #line 3475
<     if ((unsigned long )(& mdev->data.work.q) != (unsigned long )lp) {
< #line 3476
<       goto ldv_52534;
---
> #line 2196
>   __free_pages(mdev->md_io_page, 0U);
> #line 2197
>   put_disk(mdev->vdisk);
> #line 2198
>   blk_cleanup_queue(mdev->rq_queue);
> #line 2199
>   kfree((void const   *)mdev->rs_plan_s);
> #line 2200
>   kfree((void const   *)mdev);
> #line 2202
>   kref_put(& tconn->kref, & conn_destroy);
> #line 2203
>   return;
> }
> }
> #line 2214 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static struct retry_worker retry  ;
> #line 2216 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static void do_retry(struct work_struct *ws ) 
> { 
>   struct retry_worker *retry___0 ;
>   struct work_struct  const  *__mptr ;
>   struct list_head writes ;
>   struct drbd_request *req ;
>   struct drbd_request *tmp ;
>   struct list_head  const  *__mptr___0 ;
>   struct list_head  const  *__mptr___1 ;
>   struct drbd_conf *mdev ;
>   struct bio *bio ;
>   unsigned long start_time ;
>   bool expected ;
>   bool _bool ;
>   int tmp___0 ;
>   bool _bool___0 ;
>   bool _bool___1 ;
>   int tmp___1 ;
>   int tmp___2 ;
>   struct list_head  const  *__mptr___2 ;
> 
>   {
> #line 2218
>   __mptr = (struct work_struct  const  *)ws;
> #line 2218
>   retry___0 = (struct retry_worker *)__mptr + 0xfffffffffffffff8UL;
> #line 2219
>   writes.next = & writes;
> #line 2219
>   writes.prev = & writes;
> #line 2222
>   spin_lock_irq(& retry___0->lock);
> #line 2223
>   list_splice_init(& retry___0->writes, & writes);
> #line 2224
>   spin_unlock_irq(& retry___0->lock);
> #line 2226
>   __mptr___0 = (struct list_head  const  *)writes.next;
> #line 2226
>   req = (struct drbd_request *)__mptr___0 + 0xffffffffffffff98UL;
> #line 2226
>   __mptr___1 = (struct list_head  const  *)req->tl_requests.next;
> #line 2226
>   tmp = (struct drbd_request *)__mptr___1 + 0xffffffffffffff98UL;
> #line 2226
>   goto ldv_52951;
>   ldv_52950: 
> #line 2227
>   mdev = req->w.ldv_50388.mdev;
> #line 2228
>   bio = req->master_bio;
> #line 2229
>   start_time = req->start_time;
> #line 2233
>   tmp___0 = atomic_read((atomic_t const   *)(& req->completion_ref));
> #line 2233
>   _bool = tmp___0 == 0;
> #line 2233
>   if (! _bool) {
> #line 2233
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"atomic_read(&req->completion_ref) == 0", "do_retry");
>   } else {
> 
>   }
> #line 2235
>   if ((int )_bool) {
> #line 2234
>     _bool___0 = ((unsigned long )req->rq_state & 8192UL) != 0UL;
> #line 2234
>     if (! _bool___0) {
> #line 2234
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>               (char *)"req->rq_state & RQ_POSTPONED", "do_retry");
45610a44769,44779
> #line 2235
>     if ((int )_bool___0) {
> #line 2235
>       _bool___1 = (bool )(((unsigned long )req->rq_state & 1UL) == 0UL || ((unsigned long )req->rq_state & 8UL) != 0UL);
> #line 2235
>       if (! _bool___1) {
> #line 2235
>         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>                 (char *)"(req->rq_state & RQ_LOCAL_PENDING) == 0 || (req->rq_state & RQ_LOCAL_ABORTED) != 0",
>                 "do_retry");
>       } else {
45611a44781,44806
>       }
> #line 2235
>       if ((int )_bool___1) {
> #line 2235
>         tmp___1 = 1;
>       } else {
> #line 2235
>         tmp___1 = 0;
>       }
>     } else {
> #line 2235
>       tmp___1 = 0;
>     }
>   } else {
> #line 2235
>     tmp___1 = 0;
>   }
> #line 2235
>   expected = (bool )tmp___1;
> #line 2238
>   if (! expected) {
> #line 2239
>     tmp___2 = atomic_read((atomic_t const   *)(& req->completion_ref));
> #line 2239
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "req=%p completion_ref=%d rq_state=%x\n",
>             req, tmp___2, req->rq_state);
45615,45620c44810,44826
< #line 3481
<   del_gendisk(mdev->vdisk);
< #line 3486
<   if ((unsigned long )mdev->this_bdev != (unsigned long )((struct block_device *)0)) {
< #line 3487
<     bdput(mdev->this_bdev);
---
> #line 2248
>   kref_put(& req->kref, & drbd_req_destroy);
> #line 2263
>   inc_ap_bio___0(mdev);
> #line 2264
>   __drbd_make_request(mdev, bio, start_time);
> #line 2226
>   req = tmp;
> #line 2226
>   __mptr___2 = (struct list_head  const  *)tmp->tl_requests.next;
> #line 2226
>   tmp = (struct drbd_request *)__mptr___2 + 0xffffffffffffff98UL;
>   ldv_52951: ;
> #line 2226
>   if ((unsigned long )(& req->tl_requests) != (unsigned long )(& writes)) {
> #line 2227
>     goto ldv_52950;
45624,45644c44830,44854
< #line 3489
<   drbd_free_resources(mdev);
< #line 3491
<   drbd_release_ee_lists(mdev);
< #line 3494
<   kfree((void const   *)mdev->ee_hash);
< #line 3500
<   lc_destroy(mdev->act_log);
< #line 3501
<   lc_destroy(mdev->resync);
< #line 3503
<   kfree((void const   *)mdev->p_uuid);
< #line 3506
<   kfree((void const   *)mdev->int_dig_out);
< #line 3507
<   kfree((void const   *)mdev->int_dig_in);
< #line 3508
<   kfree((void const   *)mdev->int_dig_vv);
< #line 3513
<   drbd_free_mdev(mdev);
< #line 3514
---
> 
> #line 2231
>   return;
> }
> }
> #line 2268 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void drbd_restart_request(struct drbd_request *req ) 
> { 
>   unsigned long flags ;
>   raw_spinlock_t *tmp ;
> 
>   {
> #line 2271
>   tmp = spinlock_check(& retry.lock);
> #line 2271
>   flags = _raw_spin_lock_irqsave(tmp);
> #line 2272
>   list_move_tail(& req->tl_requests, & retry.writes);
> #line 2273
>   spin_unlock_irqrestore(& retry.lock, flags);
> #line 2278
>   dec_ap_bio(req->w.ldv_50388.mdev);
> #line 2280
>   queue_work(retry.wq, & retry.worker);
> #line 2281
45648c44858
< #line 3516 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 2284 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
45652c44862,44870
<   unsigned int tmp ;
---
>   struct drbd_conf *mdev ;
>   struct drbd_tconn *tconn ;
>   struct drbd_tconn *tmp ;
>   void *tmp___0 ;
>   unsigned int tmp___1 ;
>   void *tmp___2 ;
>   struct list_head  const  *__mptr ;
>   struct list_head  const  *__mptr___0 ;
>   struct list_head  const  *__mptr___1 ;
45655c44873
< #line 3520
---
> #line 2290
45657c44875
< #line 3530
---
> #line 2300
45659c44877
< #line 3531
---
> #line 2301
45664,45684c44882,44886
< #line 3533
<   drbd_nl_cleanup();
< #line 3535
<   if ((unsigned long )minor_table != (unsigned long )((struct drbd_conf **)0)) {
< #line 3536
<     i = minor_count;
< #line 3537
<     goto ldv_52542;
<     ldv_52541: 
< #line 3538
<     drbd_delete_device(i);
<     ldv_52542: 
< #line 3537
<     tmp = i;
< #line 3537
<     i = i - 1U;
< #line 3537
<     if (tmp != 0U) {
< #line 3538
<       goto ldv_52541;
<     } else {
---
> #line 2303
>   if ((unsigned long )retry.wq != (unsigned long )((struct workqueue_struct *)0)) {
> #line 2304
>     destroy_workqueue(retry.wq);
>   } else {
45686,45688c44888,44920
<     }
< #line 3539
<     drbd_destroy_mempools();
---
>   }
> #line 2306
>   drbd_genl_unregister();
> #line 2308
>   i = 0U;
> #line 2308
>   tmp___0 = idr_get_next(& minors, (int *)(& i));
> #line 2308
>   mdev = (struct drbd_conf *)tmp___0;
> #line 2308
>   goto ldv_52968;
>   ldv_52967: 
> #line 2309
>   tmp___1 = mdev_to_minor(mdev);
> #line 2309
>   idr_remove(& minors, (int )tmp___1);
> #line 2310
>   idr_remove(& (mdev->tconn)->volumes, mdev->vnr);
> #line 2311
>   del_gendisk(mdev->vdisk);
> #line 2313
>   kref_put(& mdev->kref, & drbd_minor_destroy);
> #line 2308
>   i = i + 1U;
> #line 2308
>   tmp___2 = idr_get_next(& minors, (int *)(& i));
> #line 2308
>   mdev = (struct drbd_conf *)tmp___2;
>   ldv_52968: ;
> #line 2308
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 2309
>     goto ldv_52967;
45692,45694c44924,44955
< #line 3542
<   kfree((void const   *)minor_table);
< #line 3544
---
> #line 2317
>   __mptr = (struct list_head  const  *)drbd_tconns.next;
> #line 2317
>   tconn = (struct drbd_tconn *)__mptr + 0xfffffffffffffff8UL;
> #line 2317
>   __mptr___0 = (struct list_head  const  *)tconn->all_tconn.next;
> #line 2317
>   tmp = (struct drbd_tconn *)__mptr___0 + 0xfffffffffffffff8UL;
> #line 2317
>   goto ldv_52977;
>   ldv_52976: 
> #line 2318
>   list_del(& tconn->all_tconn);
> #line 2320
>   kref_put(& tconn->kref, & conn_destroy);
> #line 2317
>   tconn = tmp;
> #line 2317
>   __mptr___1 = (struct list_head  const  *)tmp->all_tconn.next;
> #line 2317
>   tmp = (struct drbd_tconn *)__mptr___1 + 0xfffffffffffffff8UL;
>   ldv_52977: ;
> #line 2317
>   if ((unsigned long )(& tconn->all_tconn) != (unsigned long )(& drbd_tconns)) {
> #line 2318
>     goto ldv_52976;
>   } else {
> 
>   }
> #line 2323
>   drbd_destroy_mempools();
> #line 2324
45696c44957,44959
< #line 3546
---
> #line 2326
>   idr_destroy(& minors);
> #line 2328
45698c44961
< #line 3547
---
> #line 2329
45702c44965
< #line 3556 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 2338 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
45717c44980
< #line 3558
---
> #line 2340
45719c44982
< #line 3560
---
> #line 2342
45721c44984
< #line 3561
---
> #line 2343
45723c44986
< #line 3563
---
> #line 2345
45725c44988
< #line 3563
---
> #line 2345
45727c44990
< #line 3563
---
> #line 2345
45730c44993
< #line 3563
---
> #line 2345
45733c44996
< #line 3563
---
> #line 2345
45735c44998
< #line 3565
---
> #line 2347
45737c45000
< #line 3566
---
> #line 2348
45739c45002
< #line 3567
---
> #line 2349
45744,45746c45007,45009
< #line 3570
<   tmp___2 = drbd_test_flag(mdev, CALLBACK_PENDING);
< #line 3570
---
> #line 2352
>   tmp___2 = constant_test_bit(11U, (unsigned long const volatile   *)(& (mdev->tconn)->flags));
> #line 2352
45748c45011
< #line 3571
---
> #line 2353
45750c45013
< #line 3577
---
> #line 2359
45752c45015
< #line 3577
---
> #line 2359
45754c45017
< #line 3578
---
> #line 2360
45757c45020
< #line 3580
---
> #line 2362
45760c45023
< #line 3581
---
> #line 2363
45762c45025
< #line 3582
---
> #line 2364
45764c45027
< #line 3583
---
> #line 2365
45769c45032
< #line 3586
---
> #line 2368
45771c45034
< #line 3586
---
> #line 2368
45773c45036
< #line 3587
---
> #line 2369
45775c45038
< #line 3588
---
> #line 2370
45777c45040
< #line 3589
---
> #line 2371
45779c45042
< #line 3590
---
> #line 2372
45781c45044
< #line 3591
---
> #line 2373
45789c45052
< #line 3594
---
> #line 2376
45791,45793c45054,45056
< #line 3594
<     tmp___4 = drbd_test_flag(mdev, NET_CONGESTED);
< #line 3594
---
> #line 2376
>     tmp___4 = constant_test_bit(0U, (unsigned long const volatile   *)(& (mdev->tconn)->flags));
> #line 2376
45795c45058
< #line 3595
---
> #line 2377
45797c45060
< #line 3596
---
> #line 2378
45806c45069
< #line 3600
---
> #line 2382
45808c45071
< #line 3601
---
> #line 2383
45812,45813c45075,45076
< #line 3604 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< struct drbd_conf *drbd_new_device(unsigned int minor ) 
---
> #line 2386 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static void drbd_init_workqueue(struct drbd_work_queue *wq ) 
45815,45819c45078,45107
<   struct drbd_conf *mdev ;
<   struct gendisk *disk ;
<   struct request_queue *q ;
<   void *tmp ;
<   bool tmp___0 ;
---
>   struct lock_class_key __key ;
>   struct lock_class_key __key___0 ;
> 
>   {
> #line 2388
>   spinlock_check(& wq->q_lock);
> #line 2388
>   __raw_spin_lock_init(& wq->q_lock.ldv_6135.rlock, "&(&wq->q_lock)->rlock", & __key);
> #line 2389
>   INIT_LIST_HEAD(& wq->q);
> #line 2390
>   __init_waitqueue_head(& wq->q_wait, "&wq->q_wait", & __key___0);
> #line 2392
>   return;
> }
> }
> #line 2393 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> struct drbd_tconn *conn_get_by_name(char const   *name ) 
> { 
>   struct drbd_tconn *tconn ;
>   struct list_head *__ptr ;
>   struct list_head  const  *__mptr ;
>   struct list_head *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
>   struct list_head *__ptr___0 ;
>   struct list_head  const  *__mptr___0 ;
>   struct list_head *_________p1___0 ;
>   bool __warned___0 ;
45821,45824d45108
<   int tmp___2 ;
<   int tmp___3 ;
<   void *tmp___4 ;
<   void *tmp___5 ;
45827,45833c45111,45113
< #line 3611
<   tmp = kzalloc(4736UL, 208U);
< #line 3611
<   mdev = (struct drbd_conf *)tmp;
< #line 3612
<   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
< #line 3613
---
> #line 2397
>   if ((unsigned long )name == (unsigned long )((char const   *)0) || (int )((signed char )*name) == 0) {
> #line 2398
45838,45843c45118,45129
< #line 3614
<   tmp___0 = zalloc_cpumask_var(& mdev->cpu_mask, 208U);
< #line 3614
<   if (tmp___0) {
< #line 3614
<     tmp___1 = 0;
---
> #line 2400
>   rcu_read_lock();
> #line 2401
>   __ptr = drbd_tconns.next;
> #line 2401
>   _________p1 = *((struct list_head * volatile  *)(& __ptr));
> #line 2401
>   tmp = debug_lockdep_rcu_enabled();
> #line 2401
>   if (tmp != 0 && ! __warned) {
> #line 2401
>     rcu_read_lock_held();
45845,45846c45131
< #line 3614
<     tmp___1 = 1;
---
> 
45848,45851c45133,45147
< #line 3614
<   if (tmp___1) {
< #line 3615
<     goto out_no_cpumask;
---
> #line 2401
>   __mptr = (struct list_head  const  *)_________p1;
> #line 2401
>   tconn = (struct drbd_tconn *)__mptr + 0xfffffffffffffff8UL;
> #line 2401
>   goto ldv_53013;
>   ldv_53012: 
> #line 2402
>   tmp___0 = strcmp((char const   *)tconn->name, name);
> #line 2402
>   if (tmp___0 == 0) {
> #line 2403
>     kref_get(& tconn->kref);
> #line 2404
>     goto found;
45855,45864c45151,45160
< #line 3617
<   mdev->minor = minor;
< #line 3619
<   drbd_init_set_defaults(mdev);
< #line 3621
<   q = blk_alloc_queue(208U);
< #line 3622
<   if ((unsigned long )q == (unsigned long )((struct request_queue *)0)) {
< #line 3623
<     goto out_no_q;
---
> #line 2401
>   __ptr___0 = tconn->all_tconn.next;
> #line 2401
>   _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
> #line 2401
>   tmp___1 = debug_lockdep_rcu_enabled();
> #line 2401
>   if (tmp___1 != 0 && ! __warned___0) {
> #line 2401
>     rcu_read_lock_held();
45868,45877c45164,45172
< #line 3624
<   mdev->rq_queue = q;
< #line 3625
<   q->queuedata = (void *)mdev;
< #line 3627
<   disk = alloc_disk(1);
< #line 3628
<   if ((unsigned long )disk == (unsigned long )((struct gendisk *)0)) {
< #line 3629
<     goto out_no_disk;
---
> #line 2401
>   __mptr___0 = (struct list_head  const  *)_________p1___0;
> #line 2401
>   tconn = (struct drbd_tconn *)__mptr___0 + 0xfffffffffffffff8UL;
>   ldv_53013: ;
> #line 2401
>   if ((unsigned long )(& tconn->all_tconn) != (unsigned long )(& drbd_tconns)) {
> #line 2402
>     goto ldv_53012;
45881,45922c45176,45215
< #line 3630
<   mdev->vdisk = disk;
< #line 3632
<   set_disk_ro(disk, 1);
< #line 3634
<   disk->queue = q;
< #line 3635
<   disk->major = 147;
< #line 3636
<   disk->first_minor = (int )minor;
< #line 3637
<   disk->fops = & drbd_ops;
< #line 3638
<   sprintf((char *)(& disk->disk_name), "drbd%d", minor);
< #line 3639
<   disk->private_data = (void *)mdev;
< #line 3641
<   mdev->this_bdev = bdget(minor | 154140672U);
< #line 3643
<   (mdev->this_bdev)->bd_contains = mdev->this_bdev;
< #line 3645
<   q->backing_dev_info.congested_fn = & drbd_congested;
< #line 3646
<   q->backing_dev_info.congested_data = (void *)mdev;
< #line 3648
<   blk_queue_make_request(q, & drbd_make_request);
< #line 3649
<   blk_queue_flush(q, 6144U);
< #line 3652
<   blk_queue_max_hw_sectors(q, 16U);
< #line 3653
<   blk_queue_bounce_limit(q, 0xffffffffffffffffULL);
< #line 3654
<   blk_queue_merge_bvec(q, & drbd_merge_bvec);
< #line 3655
<   q->queue_lock = & mdev->req_lock;
< #line 3657
<   mdev->md_io_page = alloc_pages(208U, 0U);
< #line 3658
<   if ((unsigned long )mdev->md_io_page == (unsigned long )((struct page *)0)) {
< #line 3659
<     goto out_no_io_page;
---
> #line 2407
>   tconn = 0;
>   found: 
> #line 2409
>   rcu_read_unlock();
> #line 2410
>   return (tconn);
> }
> }
> #line 2413 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> struct drbd_tconn *conn_get_by_addrs(void *my_addr , int my_addr_len , void *peer_addr ,
>                                      int peer_addr_len ) 
> { 
>   struct drbd_tconn *tconn ;
>   struct list_head *__ptr ;
>   struct list_head  const  *__mptr ;
>   struct list_head *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   struct list_head *__ptr___0 ;
>   struct list_head  const  *__mptr___0 ;
>   struct list_head *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___2 ;
> 
>   {
> #line 2418
>   rcu_read_lock();
> #line 2419
>   __ptr = drbd_tconns.next;
> #line 2419
>   _________p1 = *((struct list_head * volatile  *)(& __ptr));
> #line 2419
>   tmp = debug_lockdep_rcu_enabled();
> #line 2419
>   if (tmp != 0 && ! __warned) {
> #line 2419
>     rcu_read_lock_held();
45926,45931c45219,45247
< #line 3661
<   tmp___2 = drbd_bm_init(mdev);
< #line 3661
<   if (tmp___2 != 0) {
< #line 3662
<     goto out_no_bitmap;
---
> #line 2419
>   __mptr = (struct list_head  const  *)_________p1;
> #line 2419
>   tconn = (struct drbd_tconn *)__mptr + 0xfffffffffffffff8UL;
> #line 2419
>   goto ldv_53038;
>   ldv_53037: ;
> #line 2420
>   if (tconn->my_addr_len == my_addr_len && tconn->peer_addr_len == peer_addr_len) {
> #line 2420
>     tmp___0 = memcmp((void const   *)(& tconn->my_addr), (void const   *)my_addr,
>                      (size_t )my_addr_len);
> #line 2420
>     if (tmp___0 == 0) {
> #line 2420
>       tmp___1 = memcmp((void const   *)(& tconn->peer_addr), (void const   *)peer_addr,
>                        (size_t )peer_addr_len);
> #line 2420
>       if (tmp___1 == 0) {
> #line 2424
>         kref_get(& tconn->kref);
> #line 2425
>         goto found;
>       } else {
> 
>       }
>     } else {
> 
>     }
45935,45940c45251,45260
< #line 3664
<   tmp___3 = tl_init(mdev);
< #line 3664
<   if (tmp___3 == 0) {
< #line 3665
<     goto out_no_tl;
---
> #line 2419
>   __ptr___0 = tconn->all_tconn.next;
> #line 2419
>   _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
> #line 2419
>   tmp___2 = debug_lockdep_rcu_enabled();
> #line 2419
>   if (tmp___2 != 0 && ! __warned___0) {
> #line 2419
>     rcu_read_lock_held();
45944,45951c45264,45272
< #line 3667
<   tmp___4 = kzalloc(120UL, 208U);
< #line 3667
<   mdev->app_reads_hash = (struct hlist_head *)tmp___4;
< #line 3668
<   if ((unsigned long )mdev->app_reads_hash == (unsigned long )((struct hlist_head *)0)) {
< #line 3669
<     goto out_no_app_reads;
---
> #line 2419
>   __mptr___0 = (struct list_head  const  *)_________p1___0;
> #line 2419
>   tconn = (struct drbd_tconn *)__mptr___0 + 0xfffffffffffffff8UL;
>   ldv_53038: ;
> #line 2419
>   if ((unsigned long )(& tconn->all_tconn) != (unsigned long )(& drbd_tconns)) {
> #line 2420
>     goto ldv_53037;
45955,45962c45276,45299
< #line 3671
<   tmp___5 = kzalloc(40UL, 208U);
< #line 3671
<   mdev->current_epoch = (struct drbd_epoch *)tmp___5;
< #line 3672
<   if ((unsigned long )mdev->current_epoch == (unsigned long )((struct drbd_epoch *)0)) {
< #line 3673
<     goto out_no_epoch;
---
> #line 2428
>   tconn = 0;
>   found: 
> #line 2430
>   rcu_read_unlock();
> #line 2431
>   return (tconn);
> }
> }
> #line 2434 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int drbd_alloc_socket(struct drbd_socket *socket ) 
> { 
>   unsigned long tmp ;
>   unsigned long tmp___0 ;
> 
>   {
> #line 2436
>   tmp = __get_free_pages(208U, 0U);
> #line 2436
>   socket->rbuf = (void *)tmp;
> #line 2437
>   if ((unsigned long )socket->rbuf == (unsigned long )((void *)0)) {
> #line 2438
>     return (-12);
45966,45996c45303,45314
< #line 3675
<   INIT_LIST_HEAD(& (mdev->current_epoch)->list);
< #line 3676
<   mdev->epochs = 1U;
< #line 3678
<   return (mdev);
<   out_no_epoch: 
< #line 3683
<   kfree((void const   *)mdev->app_reads_hash);
<   out_no_app_reads: 
< #line 3685
<   tl_cleanup(mdev);
<   out_no_tl: 
< #line 3687
<   drbd_bm_cleanup(mdev);
<   out_no_bitmap: 
< #line 3689
<   __free_pages(mdev->md_io_page, 0U);
<   out_no_io_page: 
< #line 3691
<   put_disk(disk);
<   out_no_disk: 
< #line 3693
<   blk_cleanup_queue(q);
<   out_no_q: 
< #line 3695
<   free_cpumask_var(mdev->cpu_mask);
<   out_no_cpumask: 
< #line 3697
<   kfree((void const   *)mdev);
< #line 3698
---
> #line 2439
>   tmp___0 = __get_free_pages(208U, 0U);
> #line 2439
>   socket->sbuf = (void *)tmp___0;
> #line 2440
>   if ((unsigned long )socket->sbuf == (unsigned long )((void *)0)) {
> #line 2441
>     return (-12);
>   } else {
> 
>   }
> #line 2442
46000,46001c45318,45319
< #line 3703 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void drbd_free_mdev(struct drbd_conf *mdev ) 
---
> #line 2445 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static void drbd_free_socket(struct drbd_socket *socket ) 
46006,46015c45324,45396
< #line 3705
<   kfree((void const   *)mdev->current_epoch);
< #line 3706
<   kfree((void const   *)mdev->app_reads_hash);
< #line 3707
<   tl_cleanup(mdev);
< #line 3708
<   if ((unsigned long )mdev->bitmap != (unsigned long )((struct drbd_bitmap *)0)) {
< #line 3709
<     drbd_bm_cleanup(mdev);
---
> #line 2447
>   free_pages((unsigned long )socket->sbuf, 0U);
> #line 2448
>   free_pages((unsigned long )socket->rbuf, 0U);
> #line 2449
>   return;
> }
> }
> #line 2451 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void conn_free_crypto(struct drbd_tconn *tconn ) 
> { 
> 
> 
>   {
> #line 2453
>   drbd_free_sock(tconn);
> #line 2455
>   crypto_free_hash(tconn->csums_tfm);
> #line 2456
>   crypto_free_hash(tconn->verify_tfm);
> #line 2457
>   crypto_free_hash(tconn->cram_hmac_tfm);
> #line 2458
>   crypto_free_hash(tconn->integrity_tfm);
> #line 2459
>   crypto_free_hash(tconn->peer_integrity_tfm);
> #line 2460
>   kfree((void const   *)tconn->int_dig_in);
> #line 2461
>   kfree((void const   *)tconn->int_dig_vv);
> #line 2463
>   tconn->csums_tfm = 0;
> #line 2464
>   tconn->verify_tfm = 0;
> #line 2465
>   tconn->cram_hmac_tfm = 0;
> #line 2466
>   tconn->integrity_tfm = 0;
> #line 2467
>   tconn->peer_integrity_tfm = 0;
> #line 2468
>   tconn->int_dig_in = 0;
> #line 2469
>   tconn->int_dig_vv = 0;
> #line 2470
>   return;
> }
> }
> #line 2472 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int set_resource_options(struct drbd_tconn *tconn , struct res_opts *res_opts ) 
> { 
>   cpumask_var_t new_cpu_mask ;
>   int err ;
>   bool tmp ;
>   int tmp___0 ;
>   bool tmp___1 ;
>   int tmp___2 ;
> 
>   {
> #line 2477
>   tmp = zalloc_cpumask_var(& new_cpu_mask, 208U);
> #line 2477
>   if (tmp) {
> #line 2477
>     tmp___0 = 0;
>   } else {
> #line 2477
>     tmp___0 = 1;
>   }
> #line 2477
>   if (tmp___0) {
> #line 2478
>     return (-12);
46019c45400,45888
< #line 3710
---
> #line 2485
>   if (nr_cpu_ids > 1 && (int )((signed char )res_opts->cpu_mask[0]) != 0) {
> #line 2487
>     err = bitmap_parse((char const   *)(& res_opts->cpu_mask), 32U, (unsigned long *)(& new_cpu_mask->bits),
>                        nr_cpu_ids);
> #line 2489
>     if (err != 0) {
> #line 2490
>       printk("\fd-con %s: bitmap_parse() failed with %d\n", tconn->name, err);
> #line 2492
>       goto fail;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2495
>   tconn->res_opts = *res_opts;
> #line 2496
>   tmp___1 = cpumask_equal((struct cpumask  const  *)tconn->cpu_mask, (struct cpumask  const  *)new_cpu_mask);
> #line 2496
>   if (tmp___1) {
> #line 2496
>     tmp___2 = 0;
>   } else {
> #line 2496
>     tmp___2 = 1;
>   }
> #line 2496
>   if (tmp___2) {
> #line 2497
>     cpumask_copy(tconn->cpu_mask, (struct cpumask  const  *)new_cpu_mask);
> #line 2498
>     drbd_calc_cpu_mask(tconn);
> #line 2499
>     tconn->receiver.reset_cpu_mask = 1;
> #line 2500
>     tconn->asender.reset_cpu_mask = 1;
> #line 2501
>     tconn->worker.reset_cpu_mask = 1;
>   } else {
> 
>   }
> #line 2503
>   err = 0;
>   fail: 
> #line 2506
>   free_cpumask_var(new_cpu_mask);
> #line 2507
>   return (err);
> }
> }
> #line 2512 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> struct drbd_tconn *conn_create(char const   *name , struct res_opts *res_opts ) 
> { 
>   struct drbd_tconn *tconn ;
>   void *tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   bool tmp___2 ;
>   int tmp___3 ;
>   int tmp___4 ;
>   void *tmp___5 ;
>   struct lock_class_key __key ;
>   struct lock_class_key __key___0 ;
>   struct lock_class_key __key___1 ;
>   struct lock_class_key __key___2 ;
>   struct lock_class_key __key___3 ;
>   struct lock_class_key __key___4 ;
>   struct lock_class_key __key___5 ;
> 
>   {
> #line 2516
>   tmp = kzalloc(2392UL, 208U);
> #line 2516
>   tconn = (struct drbd_tconn *)tmp;
> #line 2517
>   if ((unsigned long )tconn == (unsigned long )((struct drbd_tconn *)0)) {
> #line 2518
>     return (0);
>   } else {
> 
>   }
> #line 2520
>   tconn->name = kstrdup(name, 208U);
> #line 2521
>   if ((unsigned long )tconn->name == (unsigned long )((char *)0)) {
> #line 2522
>     goto fail;
>   } else {
> 
>   }
> #line 2524
>   tmp___0 = drbd_alloc_socket(& tconn->data);
> #line 2524
>   if (tmp___0 != 0) {
> #line 2525
>     goto fail;
>   } else {
> 
>   }
> #line 2526
>   tmp___1 = drbd_alloc_socket(& tconn->meta);
> #line 2526
>   if (tmp___1 != 0) {
> #line 2527
>     goto fail;
>   } else {
> 
>   }
> #line 2529
>   tmp___2 = zalloc_cpumask_var(& tconn->cpu_mask, 208U);
> #line 2529
>   if (tmp___2) {
> #line 2529
>     tmp___3 = 0;
>   } else {
> #line 2529
>     tmp___3 = 1;
>   }
> #line 2529
>   if (tmp___3) {
> #line 2530
>     goto fail;
>   } else {
> 
>   }
> #line 2532
>   tmp___4 = set_resource_options(tconn, res_opts);
> #line 2532
>   if (tmp___4 != 0) {
> #line 2533
>     goto fail;
>   } else {
> 
>   }
> #line 2535
>   tmp___5 = kzalloc(48UL, 208U);
> #line 2535
>   tconn->current_epoch = (struct drbd_epoch *)tmp___5;
> #line 2536
>   if ((unsigned long )tconn->current_epoch == (unsigned long )((struct drbd_epoch *)0)) {
> #line 2537
>     goto fail;
>   } else {
> 
>   }
> #line 2539
>   INIT_LIST_HEAD(& tconn->transfer_log);
> #line 2541
>   INIT_LIST_HEAD(& (tconn->current_epoch)->list);
> #line 2542
>   tconn->epochs = 1U;
> #line 2543
>   spinlock_check(& tconn->epoch_lock);
> #line 2543
>   __raw_spin_lock_init(& tconn->epoch_lock.ldv_6135.rlock, "&(&tconn->epoch_lock)->rlock",
>                        & __key);
> #line 2544
>   tconn->write_ordering = WO_bdev_flush;
> #line 2546
>   tconn->send.seen_any_write_yet = 0;
> #line 2547
>   tconn->send.current_epoch_nr = 0;
> #line 2548
>   tconn->send.current_epoch_writes = 0U;
> #line 2550
>   tconn->cstate = C_STANDALONE;
> #line 2551
>   __mutex_init(& tconn->cstate_mutex, "&tconn->cstate_mutex", & __key___0);
> #line 2552
>   spinlock_check(& tconn->req_lock);
> #line 2552
>   __raw_spin_lock_init(& tconn->req_lock.ldv_6135.rlock, "&(&tconn->req_lock)->rlock",
>                        & __key___1);
> #line 2553
>   __mutex_init(& tconn->conf_update, "&tconn->conf_update", & __key___2);
> #line 2554
>   __init_waitqueue_head(& tconn->ping_wait, "&tconn->ping_wait", & __key___3);
> #line 2555
>   idr_init(& tconn->volumes);
> #line 2557
>   drbd_init_workqueue(& tconn->sender_work);
> #line 2558
>   __mutex_init(& tconn->data.mutex, "&tconn->data.mutex", & __key___4);
> #line 2559
>   __mutex_init(& tconn->meta.mutex, "&tconn->meta.mutex", & __key___5);
> #line 2561
>   drbd_thread_init(tconn, & tconn->receiver, & drbdd_init, (char *)"receiver");
> #line 2562
>   drbd_thread_init(tconn, & tconn->worker, & drbd_worker, (char *)"worker");
> #line 2563
>   drbd_thread_init(tconn, & tconn->asender, & drbd_asender, (char *)"asender");
> #line 2565
>   kref_init(& tconn->kref);
> #line 2566
>   list_add_tail_rcu(& tconn->all_tconn, & drbd_tconns);
> #line 2568
>   return (tconn);
>   fail: 
> #line 2571
>   kfree((void const   *)tconn->current_epoch);
> #line 2572
>   free_cpumask_var(tconn->cpu_mask);
> #line 2573
>   drbd_free_socket(& tconn->meta);
> #line 2574
>   drbd_free_socket(& tconn->data);
> #line 2575
>   kfree((void const   *)tconn->name);
> #line 2576
>   kfree((void const   *)tconn);
> #line 2578
>   return (0);
> }
> }
> #line 2581 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void conn_destroy(struct kref *kref ) 
> { 
>   struct drbd_tconn *tconn ;
>   struct kref  const  *__mptr ;
>   int tmp ;
>   int tmp___0 ;
> 
>   {
> #line 2583
>   __mptr = (struct kref  const  *)kref;
> #line 2583
>   tconn = (struct drbd_tconn *)__mptr + 0xffffffffffffffe8UL;
> #line 2585
>   tmp___0 = atomic_read((atomic_t const   *)(& (tconn->current_epoch)->epoch_size));
> #line 2585
>   if (tmp___0 != 0) {
> #line 2586
>     tmp = atomic_read((atomic_t const   *)(& (tconn->current_epoch)->epoch_size));
> #line 2586
>     printk("\vd-con %s: epoch_size:%d\n", tconn->name, tmp);
>   } else {
> 
>   }
> #line 2587
>   kfree((void const   *)tconn->current_epoch);
> #line 2589
>   idr_destroy(& tconn->volumes);
> #line 2591
>   free_cpumask_var(tconn->cpu_mask);
> #line 2592
>   drbd_free_socket(& tconn->meta);
> #line 2593
>   drbd_free_socket(& tconn->data);
> #line 2594
>   kfree((void const   *)tconn->name);
> #line 2595
>   kfree((void const   *)tconn->int_dig_in);
> #line 2596
>   kfree((void const   *)tconn->int_dig_vv);
> #line 2597
>   kfree((void const   *)tconn);
> #line 2598
>   return;
> }
> }
> #line 2600 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> enum drbd_ret_code conn_new_minor(struct drbd_tconn *tconn , unsigned int minor ,
>                                   int vnr ) 
> { 
>   struct drbd_conf *mdev ;
>   struct gendisk *disk ;
>   struct request_queue *q ;
>   int vnr_got ;
>   int minor_got ;
>   enum drbd_ret_code err ;
>   void *tmp ;
>   int tmp___0 ;
>   struct rb_root __constr_expr_0 ;
>   struct rb_root __constr_expr_1 ;
>   int tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
>   int tmp___4 ;
> 
>   {
> #line 2605
>   vnr_got = vnr;
> #line 2606
>   minor_got = (int )minor;
> #line 2607
>   err = ERR_NOMEM;
> #line 2609
>   mdev = minor_to_mdev(minor);
> #line 2610
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 2611
>     return (ERR_MINOR_EXISTS);
>   } else {
> 
>   }
> #line 2614
>   tmp = kzalloc(2160UL, 208U);
> #line 2614
>   mdev = (struct drbd_conf *)tmp;
> #line 2615
>   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 2616
>     return (ERR_NOMEM);
>   } else {
> 
>   }
> #line 2618
>   kref_get(& tconn->kref);
> #line 2619
>   mdev->tconn = tconn;
> #line 2621
>   mdev->minor = minor;
> #line 2622
>   mdev->vnr = vnr;
> #line 2624
>   drbd_init_set_defaults(mdev);
> #line 2626
>   q = blk_alloc_queue(208U);
> #line 2627
>   if ((unsigned long )q == (unsigned long )((struct request_queue *)0)) {
> #line 2628
>     goto out_no_q;
>   } else {
> 
>   }
> #line 2629
>   mdev->rq_queue = q;
> #line 2630
>   q->queuedata = (void *)mdev;
> #line 2632
>   disk = alloc_disk(1);
> #line 2633
>   if ((unsigned long )disk == (unsigned long )((struct gendisk *)0)) {
> #line 2634
>     goto out_no_disk;
>   } else {
> 
>   }
> #line 2635
>   mdev->vdisk = disk;
> #line 2637
>   set_disk_ro(disk, 1);
> #line 2639
>   disk->queue = q;
> #line 2640
>   disk->major = 147;
> #line 2641
>   disk->first_minor = (int )minor;
> #line 2642
>   disk->fops = & drbd_ops;
> #line 2643
>   sprintf((char *)(& disk->disk_name), "drbd%d", minor);
> #line 2644
>   disk->private_data = (void *)mdev;
> #line 2646
>   mdev->this_bdev = bdget(minor | 154140672U);
> #line 2648
>   (mdev->this_bdev)->bd_contains = mdev->this_bdev;
> #line 2650
>   q->backing_dev_info.congested_fn = & drbd_congested;
> #line 2651
>   q->backing_dev_info.congested_data = (void *)mdev;
> #line 2653
>   blk_queue_make_request(q, & drbd_make_request);
> #line 2654
>   blk_queue_flush(q, 6144U);
> #line 2657
>   blk_queue_max_hw_sectors(q, 16U);
> #line 2658
>   blk_queue_bounce_limit(q, 0xffffffffffffffffULL);
> #line 2659
>   blk_queue_merge_bvec(q, & drbd_merge_bvec);
> #line 2660
>   q->queue_lock = & (mdev->tconn)->req_lock;
> #line 2662
>   mdev->md_io_page = alloc_pages(208U, 0U);
> #line 2663
>   if ((unsigned long )mdev->md_io_page == (unsigned long )((struct page *)0)) {
> #line 2664
>     goto out_no_io_page;
>   } else {
> 
>   }
> #line 2666
>   tmp___0 = drbd_bm_init(mdev);
> #line 2666
>   if (tmp___0 != 0) {
> #line 2667
>     goto out_no_bitmap;
>   } else {
> 
>   }
> #line 2668
>   __constr_expr_0.rb_node = 0;
> #line 2668
>   mdev->read_requests = __constr_expr_0;
> #line 2669
>   __constr_expr_1.rb_node = 0;
> #line 2669
>   mdev->write_requests = __constr_expr_1;
> #line 2671
>   tmp___1 = idr_pre_get(& minors, 208U);
> #line 2671
>   if (tmp___1 == 0) {
> #line 2672
>     goto out_no_minor_idr;
>   } else {
> 
>   }
> #line 2673
>   tmp___2 = idr_get_new_above(& minors, (void *)mdev, (int )minor, & minor_got);
> #line 2673
>   if (tmp___2 != 0) {
> #line 2674
>     goto out_no_minor_idr;
>   } else {
> 
>   }
> #line 2675
>   if ((unsigned int )minor_got != minor) {
> #line 2676
>     err = ERR_MINOR_EXISTS;
> #line 2677
>     drbd_msg_put_info("requested minor exists already");
> #line 2678
>     goto out_idr_remove_minor;
>   } else {
> 
>   }
> #line 2681
>   tmp___3 = idr_pre_get(& tconn->volumes, 208U);
> #line 2681
>   if (tmp___3 == 0) {
> #line 2682
>     goto out_idr_remove_minor;
>   } else {
> 
>   }
> #line 2683
>   tmp___4 = idr_get_new_above(& tconn->volumes, (void *)mdev, vnr, & vnr_got);
> #line 2683
>   if (tmp___4 != 0) {
> #line 2684
>     goto out_idr_remove_minor;
>   } else {
> 
>   }
> #line 2685
>   if (vnr_got != vnr) {
> #line 2686
>     err = ERR_INVALID_REQUEST;
> #line 2687
>     drbd_msg_put_info("requested volume exists already");
> #line 2688
>     goto out_idr_remove_vol;
>   } else {
> 
>   }
> #line 2690
>   add_disk(disk);
> #line 2691
>   kref_init(& mdev->kref);
> #line 2694
>   mdev->state.ldv_50103.conn = (unsigned char )tconn->cstate;
> #line 2695
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 144U) {
> #line 2696
>     drbd_connected(mdev);
>   } else {
> 
>   }
> #line 2698
>   return (NO_ERROR);
>   out_idr_remove_vol: 
> #line 2701
>   idr_remove(& tconn->volumes, vnr_got);
>   out_idr_remove_minor: 
> #line 2703
>   idr_remove(& minors, minor_got);
> #line 2704
>   synchronize_rcu();
>   out_no_minor_idr: 
> #line 2706
>   drbd_bm_cleanup(mdev);
>   out_no_bitmap: 
> #line 2708
46021,46029c45890,45897
< #line 3711
<   put_disk(mdev->vdisk);
< #line 3712
<   blk_cleanup_queue(mdev->rq_queue);
< #line 3713
<   free_cpumask_var(mdev->cpu_mask);
< #line 3714
<   drbd_free_tl_hash(mdev);
< #line 3715
---
>   out_no_io_page: 
> #line 2710
>   put_disk(disk);
>   out_no_disk: 
> #line 2712
>   blk_cleanup_queue(q);
>   out_no_q: 
> #line 2714
46031,46032c45899,45902
< #line 3716
<   return;
---
> #line 2715
>   kref_put(& tconn->kref, & conn_destroy);
> #line 2716
>   return (err);
46035c45905
< #line 3719 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 2719 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46040d45909
<   void *tmp ;
46041a45911,45916
>   struct lock_class_key __key___1 ;
>   char const   *__lock_name ;
>   struct workqueue_struct *tmp ;
>   struct lock_class_key __key___2 ;
>   atomic_long_t __constr_expr_0 ;
>   struct lock_class_key __key___3 ;
46045,46047c45920,45922
< #line 3730
<   if (minor_count == 0U || minor_count > 256U) {
< #line 3731
---
> #line 2723
>   if (minor_count == 0U || minor_count > 255U) {
> #line 2724
46049c45924
< #line 3734
---
> #line 2727
46054,46056c45929,45931
< #line 3740
<   err = drbd_nl_init();
< #line 3741
---
> #line 2733
>   err = register_blkdev(147U, "drbd");
> #line 2734
46058c45933,45935
< #line 3742
---
> #line 2735
>     printk("\vdrbd: unable to register block device major %d\n", 147);
> #line 2738
46063,46065c45940,45942
< #line 3744
<   err = register_blkdev(147U, "drbd");
< #line 3745
---
> #line 2741
>   err = drbd_genl_register();
> #line 2742
46067,46070c45944,45947
< #line 3746
<     printk("\vdrbd: unable to register block device major %d\n", 147);
< #line 3749
<     return (err);
---
> #line 2743
>     printk("\vdrbd: unable to register generic netlink family\n");
> #line 2744
>     goto fail;
46074c45951
< #line 3752
---
> #line 2748
46076c45953
< #line 3757
---
> #line 2753
46078c45955
< #line 3759
---
> #line 2755
46080c45957
< #line 3761
---
> #line 2757
46082,46093c45959,45961
< #line 3762
<   tmp = kzalloc((unsigned long )minor_count * 8UL, 208U);
< #line 3762
<   minor_table = (struct drbd_conf **)tmp;
< #line 3764
<   if ((unsigned long )minor_table == (unsigned long )((struct drbd_conf **)0)) {
< #line 3765
<     goto Enomem;
<   } else {
< 
<   }
< #line 3767
---
> #line 2758
>   idr_init(& minors);
> #line 2760
46095c45963
< #line 3768
---
> #line 2761
46097,46098c45965,45966
< #line 3769
<     goto Enomem;
---
> #line 2762
>     goto fail;
46102c45970
< #line 3771
---
> #line 2764
46104c45972
< #line 3772
---
> #line 2765
46106c45974
< #line 3773
---
> #line 2766
46108,46109c45976,45977
< #line 3774
<     goto Enomem;
---
> #line 2767
>     goto fail;
46113c45981
< #line 3777
---
> #line 2770
46115,46118c45983,46020
< #line 3779
<   printk("\016drbd: initialized. Version: 8.3.14 (api:%d/proto:%d-%d)\n", 88, 86,
<          97);
< #line 3782
---
> #line 2771
>   INIT_LIST_HEAD(& drbd_tconns);
> #line 2773
>   __lock_name = "drbd-reissue";
> #line 2773
>   tmp = __alloc_workqueue_key("drbd-reissue", 10U, 1, & __key___1, __lock_name);
> #line 2773
>   retry.wq = tmp;
> #line 2774
>   if ((unsigned long )retry.wq == (unsigned long )((struct workqueue_struct *)0)) {
> #line 2775
>     printk("\vdrbd: unable to create retry workqueue\n");
> #line 2776
>     goto fail;
>   } else {
> 
>   }
> #line 2778
>   __init_work(& retry.worker, 0);
> #line 2778
>   __constr_expr_0.counter = 4195328L;
> #line 2778
>   retry.worker.data = __constr_expr_0;
> #line 2778
>   lockdep_init_map(& retry.worker.lockdep_map, "(&retry.worker)", & __key___2, 0);
> #line 2778
>   INIT_LIST_HEAD(& retry.worker.entry);
> #line 2778
>   retry.worker.func = & do_retry;
> #line 2779
>   spinlock_check(& retry.lock);
> #line 2779
>   __raw_spin_lock_init(& retry.lock.ldv_6135.rlock, "&(&retry.lock)->rlock", & __key___3);
> #line 2780
>   INIT_LIST_HEAD(& retry.writes);
> #line 2782
>   printk("\016drbd: initialized. Version: 8.4.2 (api:%d/proto:%d-%d)\n", 1, 86, 101);
> #line 2785
46120c46022
< #line 3782
---
> #line 2785
46122c46024
< #line 3783
---
> #line 2786
46124,46126c46026
< #line 3785
<   printk("\016drbd: minor_table @ 0x%p\n", minor_table);
< #line 3787
---
> #line 2789
46128,46129c46028,46029
<   Enomem: 
< #line 3790
---
>   fail: 
> #line 2792
46131c46031
< #line 3791
---
> #line 2793
46133c46033
< #line 3793
---
> #line 2795
46136c46036
< #line 3795
---
> #line 2797
46139c46039
< #line 3796
---
> #line 2798
46143c46043
< #line 3799 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 2801 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46149c46049
< #line 3801
---
> #line 2803
46151c46051
< #line 3802
---
> #line 2804
46156c46056
< #line 3804
---
> #line 2806
46158c46058
< #line 3805
---
> #line 2807
46160c46060
< #line 3807
---
> #line 2809
46162c46062
< #line 3808
---
> #line 2810
46166,46167c46066,46067
< #line 3810 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void drbd_free_sock(struct drbd_conf *mdev ) 
---
> #line 2812 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void drbd_free_sock(struct drbd_tconn *tconn ) 
46172,46183c46072,46083
< #line 3812
<   if ((unsigned long )mdev->data.socket != (unsigned long )((struct socket *)0)) {
< #line 3813
<     mutex_lock_nested(& mdev->data.mutex, 0U);
< #line 3814
<     kernel_sock_shutdown(mdev->data.socket, SHUT_RDWR);
< #line 3815
<     sock_release(mdev->data.socket);
< #line 3816
<     mdev->data.socket = 0;
< #line 3817
<     mutex_unlock(& mdev->data.mutex);
---
> #line 2814
>   if ((unsigned long )tconn->data.socket != (unsigned long )((struct socket *)0)) {
> #line 2815
>     mutex_lock_nested(& tconn->data.mutex, 0U);
> #line 2816
>     kernel_sock_shutdown(tconn->data.socket, SHUT_RDWR);
> #line 2817
>     sock_release(tconn->data.socket);
> #line 2818
>     tconn->data.socket = 0;
> #line 2819
>     mutex_unlock(& tconn->data.mutex);
46187,46198c46087,46098
< #line 3819
<   if ((unsigned long )mdev->meta.socket != (unsigned long )((struct socket *)0)) {
< #line 3820
<     mutex_lock_nested(& mdev->meta.mutex, 0U);
< #line 3821
<     kernel_sock_shutdown(mdev->meta.socket, SHUT_RDWR);
< #line 3822
<     sock_release(mdev->meta.socket);
< #line 3823
<     mdev->meta.socket = 0;
< #line 3824
<     mutex_unlock(& mdev->meta.mutex);
---
> #line 2821
>   if ((unsigned long )tconn->meta.socket != (unsigned long )((struct socket *)0)) {
> #line 2822
>     mutex_lock_nested(& tconn->meta.mutex, 0U);
> #line 2823
>     kernel_sock_shutdown(tconn->meta.socket, SHUT_RDWR);
> #line 2824
>     sock_release(tconn->meta.socket);
> #line 2825
>     tconn->meta.socket = 0;
> #line 2826
>     mutex_unlock(& tconn->meta.mutex);
46202c46102
< #line 3826
---
> #line 2828
46206,46207c46106,46107
< #line 3829 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void drbd_free_resources(struct drbd_conf *mdev ) 
---
> #line 2832 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void conn_md_sync(struct drbd_tconn *tconn ) 
46209c46109,46112
< 
---
>   struct drbd_conf *mdev ;
>   int vnr ;
>   void *tmp ;
>   void *tmp___0 ;
46212,46238c46115,46152
< #line 3831
<   crypto_free_hash(mdev->csums_tfm);
< #line 3832
<   mdev->csums_tfm = 0;
< #line 3833
<   crypto_free_hash(mdev->verify_tfm);
< #line 3834
<   mdev->verify_tfm = 0;
< #line 3835
<   crypto_free_hash(mdev->cram_hmac_tfm);
< #line 3836
<   mdev->cram_hmac_tfm = 0;
< #line 3837
<   crypto_free_hash(mdev->integrity_w_tfm);
< #line 3838
<   mdev->integrity_w_tfm = 0;
< #line 3839
<   crypto_free_hash(mdev->integrity_r_tfm);
< #line 3840
<   mdev->integrity_r_tfm = 0;
< #line 3842
<   drbd_free_sock(mdev);
< #line 3844
<   drbd_free_bc(mdev->ldev);
< #line 3844
<   mdev->ldev = 0;
< #line 3845
---
> #line 2837
>   rcu_read_lock();
> #line 2838
>   vnr = 0;
> #line 2838
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 2838
>   mdev = (struct drbd_conf *)tmp;
> #line 2838
>   goto ldv_53120;
>   ldv_53119: 
> #line 2839
>   kref_get(& mdev->kref);
> #line 2840
>   rcu_read_unlock();
> #line 2841
>   drbd_md_sync(mdev);
> #line 2842
>   kref_put(& mdev->kref, & drbd_minor_destroy);
> #line 2843
>   rcu_read_lock();
> #line 2838
>   vnr = vnr + 1;
> #line 2838
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 2838
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_53120: ;
> #line 2838
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 2839
>     goto ldv_53119;
>   } else {
> 
>   }
> #line 2845
>   rcu_read_unlock();
> #line 2846
46242c46156
< #line 3873 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 2870 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46266c46180
< #line 3879
---
> #line 2876
46268,46270c46182,46184
< #line 3881
<   tmp = drbd_test_and_clear_flag(mdev, MD_DIRTY);
< #line 3881
---
> #line 2878
>   tmp = test_and_clear_bit(1, (unsigned long volatile   *)(& mdev->flags));
> #line 2878
46272c46186
< #line 3882
---
> #line 2879
46277c46191
< #line 3886
---
> #line 2883
46279c46193
< #line 3886
---
> #line 2883
46281c46195
< #line 3887
---
> #line 2884
46286c46200
< #line 3889
---
> #line 2886
46288c46202
< #line 3889
---
> #line 2886
46290c46204
< #line 3890
---
> #line 2887
46292c46206
< #line 3891
---
> #line 2888
46297c46211
< #line 3893
---
> #line 2890
46299c46213
< #line 3895
---
> #line 2892
46301c46215
< #line 3895
---
> #line 2892
46303c46217
< #line 3895
---
> #line 2892
46305c46219
< #line 3896
---
> #line 2893
46307,46310c46221,46224
< #line 3896
<   goto ldv_52608;
<   ldv_52607: 
< #line 3897
---
> #line 2893
>   goto ldv_53144;
>   ldv_53143: 
> #line 2894
46312c46226
< #line 3897
---
> #line 2894
46314c46228
< #line 3896
---
> #line 2893
46316,46317c46230,46231
<   ldv_52608: ;
< #line 3896
---
>   ldv_53144: ;
> #line 2893
46319,46320c46233,46234
< #line 3897
<     goto ldv_52607;
---
> #line 2894
>     goto ldv_53143;
46324c46238
< #line 3898
---
> #line 2895
46326c46240
< #line 3898
---
> #line 2895
46328,46330c46242,46244
< #line 3899
<   buffer->magic = 1795323011U;
< #line 3901
---
> #line 2896
>   buffer->magic = 1812100227U;
> #line 2898
46332c46246
< #line 3901
---
> #line 2898
46334c46248
< #line 3902
---
> #line 2899
46336c46250
< #line 3902
---
> #line 2899
46338c46252
< #line 3903
---
> #line 2900
46340c46254
< #line 3903
---
> #line 2900
46342c46256
< #line 3904
---
> #line 2901
46344c46258
< #line 3905
---
> #line 2902
46346c46260
< #line 3905
---
> #line 2902
46348c46262
< #line 3907
---
> #line 2904
46350c46264
< #line 3907
---
> #line 2904
46352c46266
< #line 3908
---
> #line 2905
46354c46268
< #line 3908
---
> #line 2905
46356c46270
< #line 3910
---
> #line 2907
46358c46272
< #line 3910
---
> #line 2907
46360c46274
< #line 3910
---
> #line 2907
46362,46363c46276,46277
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             3910);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             2907);
46367c46281
< #line 3911
---
> #line 2908
46369c46283
< #line 3913
---
> #line 2910
46371,46373c46285,46287
< #line 3913
<   if (tmp___13 == 0) {
< #line 3915
---
> #line 2910
>   if (tmp___13 != 0) {
> #line 2912
46375c46289
< #line 3916
---
> #line 2913
46380c46294
< #line 3921
---
> #line 2918
46382c46296
< #line 3921
---
> #line 2918
46384c46298
< #line 3923
---
> #line 2920
46387c46301
< #line 3925
---
> #line 2922
46389c46303
< #line 3926
---
> #line 2923
46393c46307
< #line 3936 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 2933 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46396a46311,46312
>   u32 magic ;
>   u32 flags ;
46411c46327
<   __u64 tmp___11 ;
---
>   __u32 tmp___11 ;
46413c46329
<   __u32 tmp___13 ;
---
>   __u64 tmp___13 ;
46422c46338
< #line 3939
---
> #line 2937
46424c46340
< #line 3941
---
> #line 2939
46426c46342
< #line 3941
---
> #line 2939
46428c46344
< #line 3942
---
> #line 2940
46433c46349
< #line 3944
---
> #line 2942
46435c46351
< #line 3944
---
> #line 2942
46437c46353
< #line 3945
---
> #line 2943
46439c46355
< #line 3946
---
> #line 2944
46444c46360
< #line 3948
---
> #line 2946
46446,46448c46362,46364
< #line 3948
<   if (tmp___1 == 0) {
< #line 3951
---
> #line 2946
>   if (tmp___1 != 0) {
> #line 2949
46450c46366
< #line 3952
---
> #line 2950
46452c46368
< #line 3953
---
> #line 2951
46457c46373
< #line 3956
---
> #line 2954
46459,46463c46375,46402
< #line 3956
<   if (tmp___2 != 2205418091U) {
< #line 3957
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Error while reading metadata, magic not found.\n");
< #line 3958
---
> #line 2954
>   magic = tmp___2;
> #line 2955
>   tmp___3 = __fswab32(buffer->flags);
> #line 2955
>   flags = tmp___3;
> #line 2956
>   if (magic == 2205418092U || (magic == 2205418091U && (flags & 128U) == 0U)) {
> #line 2959
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Found unclean meta data. Did you \"drbdadm apply-al\"?\n");
> #line 2960
>     rv = 165;
> #line 2961
>     goto err;
>   } else {
> 
>   }
> #line 2963
>   if (magic != 2205418091U) {
> #line 2964
>     if (magic == 2205418090U) {
> #line 2965
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Found old (0.7) meta data magic. Did you \"drbdadm create-md\"?\n");
>     } else {
> #line 2967
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Meta data magic not found. Did you \"drbdadm create-md\"?\n");
>     }
> #line 2968
46465c46404
< #line 3959
---
> #line 2969
46470,46476c46409,46415
< #line 3961
<   tmp___4 = __fswab32(buffer->al_offset);
< #line 3961
<   if (tmp___4 != (unsigned int )bdev->md.al_offset) {
< #line 3962
<     tmp___3 = __fswab32(buffer->al_offset);
< #line 3962
---
> #line 2971
>   tmp___5 = __fswab32(buffer->al_offset);
> #line 2971
>   if (tmp___5 != (unsigned int )bdev->md.al_offset) {
> #line 2972
>     tmp___4 = __fswab32(buffer->al_offset);
> #line 2972
46478,46479c46417,46418
<             tmp___3, bdev->md.al_offset);
< #line 3964
---
>             tmp___4, bdev->md.al_offset);
> #line 2974
46481c46420
< #line 3965
---
> #line 2975
46486,46492c46425,46431
< #line 3967
<   tmp___6 = __fswab32(buffer->bm_offset);
< #line 3967
<   if (tmp___6 != (unsigned int )bdev->md.bm_offset) {
< #line 3968
<     tmp___5 = __fswab32(buffer->bm_offset);
< #line 3968
---
> #line 2977
>   tmp___7 = __fswab32(buffer->bm_offset);
> #line 2977
>   if (tmp___7 != (unsigned int )bdev->md.bm_offset) {
> #line 2978
>     tmp___6 = __fswab32(buffer->bm_offset);
> #line 2978
46494,46495c46433,46434
<             tmp___5, bdev->md.bm_offset);
< #line 3970
---
>             tmp___6, bdev->md.bm_offset);
> #line 2980
46497c46436
< #line 3971
---
> #line 2981
46502,46508c46441,46447
< #line 3973
<   tmp___8 = __fswab32(buffer->md_size_sect);
< #line 3973
<   if (tmp___8 != bdev->md.md_size_sect) {
< #line 3974
<     tmp___7 = __fswab32(buffer->md_size_sect);
< #line 3974
---
> #line 2983
>   tmp___9 = __fswab32(buffer->md_size_sect);
> #line 2983
>   if (tmp___9 != bdev->md.md_size_sect) {
> #line 2984
>     tmp___8 = __fswab32(buffer->md_size_sect);
> #line 2984
46510,46511c46449,46450
<             tmp___7, bdev->md.md_size_sect);
< #line 3976
---
>             tmp___8, bdev->md.md_size_sect);
> #line 2986
46513c46452
< #line 3977
---
> #line 2987
46518,46524c46457,46463
< #line 3980
<   tmp___10 = __fswab32(buffer->bm_bytes_per_bit);
< #line 3980
<   if (tmp___10 != 4096U) {
< #line 3981
<     tmp___9 = __fswab32(buffer->bm_bytes_per_bit);
< #line 3981
---
> #line 2990
>   tmp___11 = __fswab32(buffer->bm_bytes_per_bit);
> #line 2990
>   if (tmp___11 != 4096U) {
> #line 2991
>     tmp___10 = __fswab32(buffer->bm_bytes_per_bit);
> #line 2991
46526,46527c46465,46466
<             tmp___9, 4096);
< #line 3983
---
>             tmp___10, 4096);
> #line 2993
46529c46468
< #line 3984
---
> #line 2994
46534,46538c46473,46477
< #line 3987
<   tmp___11 = __fswab64(buffer->la_size);
< #line 3987
<   bdev->md.la_size_sect = tmp___11;
< #line 3988
---
> #line 2997
>   tmp___12 = __fswab64(buffer->la_size);
> #line 2997
>   bdev->md.la_size_sect = tmp___12;
> #line 2998
46540,46547c46479,46486
< #line 3988
<   goto ldv_52621;
<   ldv_52620: 
< #line 3989
<   tmp___12 = __fswab64(buffer->uuid[i]);
< #line 3989
<   bdev->md.uuid[i] = tmp___12;
< #line 3988
---
> #line 2998
>   goto ldv_53159;
>   ldv_53158: 
> #line 2999
>   tmp___13 = __fswab64(buffer->uuid[i]);
> #line 2999
>   bdev->md.uuid[i] = tmp___13;
> #line 2998
46549,46550c46488,46489
<   ldv_52621: ;
< #line 3988
---
>   ldv_53159: ;
> #line 2998
46552,46553c46491,46492
< #line 3989
<     goto ldv_52620;
---
> #line 2999
>     goto ldv_53158;
46557,46565c46496,46500
< #line 3990
<   tmp___13 = __fswab32(buffer->flags);
< #line 3990
<   bdev->md.flags = tmp___13;
< #line 3991
<   tmp___14 = __fswab32(buffer->al_nr_extents);
< #line 3991
<   mdev->sync_conf.al_extents = (int )tmp___14;
< #line 3992
---
> #line 3000
>   tmp___14 = __fswab32(buffer->flags);
> #line 3000
>   bdev->md.flags = tmp___14;
> #line 3001
46567c46502
< #line 3992
---
> #line 3001
46569,46573c46504,46508
< #line 3994
<   spin_lock_irq(& mdev->req_lock);
< #line 3995
<   if ((int )mdev->state.ldv_40583.conn <= 9) {
< #line 3997
---
> #line 3003
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 3004
>   if ((int )mdev->state.ldv_50103.conn <= 9) {
> #line 3006
46575c46510
< #line 3997
---
> #line 3006
46577c46512
< #line 3998
---
> #line 3007
46579c46514
< #line 3998
---
> #line 3007
46581c46516
< #line 3998
---
> #line 3007
46583c46518
< #line 3999
---
> #line 3008
46588,46596c46523,46524
< #line 4001
<   spin_unlock_irq(& mdev->req_lock);
< #line 4003
<   if (mdev->sync_conf.al_extents <= 6) {
< #line 4004
<     mdev->sync_conf.al_extents = 127;
<   } else {
< 
<   }
---
> #line 3010
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
46598c46526
< #line 4007
---
> #line 3013
46601c46529
< #line 4009
---
> #line 3015
46603c46531
< #line 4011
---
> #line 3017
46607c46535
< #line 4032 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3038 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46613,46615c46541,46543
< #line 4034
<   tmp = drbd_test_and_set_flag(mdev, MD_DIRTY);
< #line 4034
---
> #line 3040
>   tmp = test_and_set_bit(1, (unsigned long volatile   *)(& mdev->flags));
> #line 3040
46617c46545
< #line 4035
---
> #line 3041
46622c46550
< #line 4036
---
> #line 3042
46626c46554
< #line 4039 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3045 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46632c46560
< #line 4043
---
> #line 3049
46634,46637c46562,46565
< #line 4043
<   goto ldv_52635;
<   ldv_52634: 
< #line 4044
---
> #line 3049
>   goto ldv_53173;
>   ldv_53172: 
> #line 3050
46639c46567
< #line 4043
---
> #line 3049
46641,46642c46569,46570
<   ldv_52635: ;
< #line 4043
---
>   ldv_53173: ;
> #line 3049
46644,46645c46572,46573
< #line 4044
<     goto ldv_52634;
---
> #line 3050
>     goto ldv_53172;
46650c46578
< #line 4048
---
> #line 3054
46654c46582
< #line 4047 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3053 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46660c46588
< #line 4049
---
> #line 3055
46662,46664c46590,46592
< #line 4050
<     if ((unsigned int )*((unsigned char *)mdev + 2276UL) == 1U) {
< #line 4051
---
> #line 3056
>     if ((unsigned int )*((unsigned char *)mdev + 748UL) == 1U) {
> #line 3057
46667c46595
< #line 4053
---
> #line 3059
46670c46598
< #line 4055
---
> #line 3061
46675c46603
< #line 4058
---
> #line 3064
46677c46605
< #line 4059
---
> #line 3065
46679c46607
< #line 4060
---
> #line 3066
46683c46611
< #line 4062 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3068 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46690c46618
< #line 4065
---
> #line 3071
46692c46620
< #line 4065
---
> #line 3071
46694c46622
< #line 4066
---
> #line 3072
46696c46624
< #line 4067
---
> #line 3073
46698c46626
< #line 4068
---
> #line 3074
46702c46630
< #line 4070 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3076 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46709c46637
< #line 4073
---
> #line 3079
46711c46639
< #line 4073
---
> #line 3079
46713c46641
< #line 4074
---
> #line 3080
46715c46643
< #line 4075
---
> #line 3081
46717c46645
< #line 4076
---
> #line 3082
46722c46650
< #line 4078
---
> #line 3084
46724c46652
< #line 4079
---
> #line 3085
46726c46654
< #line 4080
---
> #line 3086
46730c46658
< #line 4089 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3095 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46737c46665
< #line 4094
---
> #line 3100
46739c46667
< #line 4096
---
> #line 3102
46741c46669
< #line 4097
---
> #line 3103
46743c46671
< #line 4099
---
> #line 3105
46745c46673
< #line 4100
---
> #line 3106
46751c46679
< #line 4102
---
> #line 3108
46753c46681
< #line 4103
---
> #line 3109
46755c46683
< #line 4104
---
> #line 3110
46757c46685
< #line 4106
---
> #line 3112
46759c46687
< #line 4108
---
> #line 3114
46761c46689
< #line 4109
---
> #line 3115
46765c46693
< #line 4111 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3117 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46773c46701
< #line 4114
---
> #line 3120
46775c46703
< #line 4115
---
> #line 3121
46780c46708
< #line 4117
---
> #line 3123
46782c46710
< #line 4117
---
> #line 3123
46784c46712
< #line 4118
---
> #line 3124
46786c46714
< #line 4119
---
> #line 3125
46788c46716
< #line 4120
---
> #line 3126
46790c46718
< #line 4121
---
> #line 3127
46793c46721
< #line 4123
---
> #line 3129
46795c46723
< #line 4124
---
> #line 3130
46797c46725
< #line 4125
---
> #line 3131
46803c46731
< #line 4127
---
> #line 3133
46806c46734
< #line 4129
---
> #line 3135
46808c46736
< #line 4131
---
> #line 3137
46810c46738
< #line 4132
---
> #line 3138
46814c46742
< #line 4140 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3146 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46821c46749
< #line 4142
---
> #line 3148
46823c46751
< #line 4144
---
> #line 3150
46825c46753
< #line 4144
---
> #line 3150
46827c46755
< #line 4145
---
> #line 3151
46829c46757
< #line 4146
---
> #line 3152
46831c46759
< #line 4147
---
> #line 3153
46833c46761
< #line 4149
---
> #line 3155
46835c46763
< #line 4151
---
> #line 3157
46837c46765
< #line 4152
---
> #line 3158
46839c46767
< #line 4153
---
> #line 3159
46844c46772
< #line 4156
---
> #line 3162
46849c46777
< #line 4159
---
> #line 3165
46853c46781
< #line 4168 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3174 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46860c46788
< #line 4170
---
> #line 3176
46862c46790
< #line 4172
---
> #line 3178
46864c46792
< #line 4173
---
> #line 3179
46866c46794
< #line 4173
---
> #line 3179
46868c46796
< #line 4174
---
> #line 3180
46870c46798
< #line 4175
---
> #line 3181
46872c46800
< #line 4176
---
> #line 3182
46877c46805
< #line 4179
---
> #line 3185
46881,46882c46809,46810
< #line 4182 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static int w_bitmap_io(struct drbd_conf *mdev , struct drbd_work *w , int unused ) 
---
> #line 3188 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int w_bitmap_io(struct drbd_work *w , int unused ) 
46885a46814
>   struct drbd_conf *mdev ;
46891c46820
< #line 4184
---
> #line 3190
46893c46822
< #line 4184
---
> #line 3190
46895c46824,46826
< #line 4185
---
> #line 3191
>   mdev = w->ldv_50388.mdev;
> #line 3192
46897c46828
< #line 4187
---
> #line 3194
46899c46830
< #line 4187
---
> #line 3194
46901c46832
< #line 4187
---
> #line 3194
46903,46904c46834,46835
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             4187);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             3194);
46908c46839
< #line 4189
---
> #line 3196
46910c46841
< #line 4189
---
> #line 3196
46912c46843
< #line 4190
---
> #line 3197
46914c46845
< #line 4191
---
> #line 3198
46916c46847
< #line 4192
---
> #line 3199
46918c46849
< #line 4193
---
> #line 3200
46923,46927c46854,46856
< #line 4196
<   drbd_clear_flag(mdev, BITMAP_IO);
< #line 4197
<   __asm__  volatile   ("": : : "memory");
< #line 4198
---
> #line 3203
>   clear_bit_unlock(9U, (unsigned long volatile   *)(& mdev->flags));
> #line 3204
46929c46858
< #line 4200
---
> #line 3206
46932c46861
< #line 4201
---
> #line 3207
46937,46939c46866,46868
< #line 4203
<   drbd_clear_flag(mdev, BITMAP_IO_QUEUED);
< #line 4204
---
> #line 3209
>   clear_bit(10, (unsigned long volatile   *)(& mdev->flags));
> #line 3210
46941c46870
< #line 4205
---
> #line 3211
46943,46944c46872,46873
< #line 4207
<   return (1);
---
> #line 3213
>   return (0);
46947c46876
< #line 4210 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3216 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
46953c46882
< #line 4212
---
> #line 3218
46955c46884
< #line 4213
---
> #line 3219
46957c46886
< #line 4214
---
> #line 3220
46959c46888
< #line 4215
---
> #line 3221
46961c46890
< #line 4216
---
> #line 3222
46963c46892
< #line 4216
---
> #line 3222
46965,46976c46894,46896
< #line 4220
<   if ((unsigned long )mdev->md_io_tmpp != (unsigned long )((struct page *)0)) {
< #line 4221
<     __free_pages(mdev->md_io_tmpp, 0U);
< #line 4222
<     mdev->md_io_tmpp = 0;
<   } else {
< 
<   }
< #line 4224
<   drbd_clear_flag(mdev, GO_DISKLESS);
< #line 4225
---
> #line 3226
>   clear_bit(11, (unsigned long volatile   *)(& mdev->flags));
> #line 3227
46980,46981c46900,46901
< #line 4227 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static int w_go_diskless(struct drbd_conf *mdev , struct drbd_work *w , int unused ) 
---
> #line 3229 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int w_go_diskless(struct drbd_work *w , int unused ) 
46982a46903
>   struct drbd_conf *mdev ;
46989,46991c46910,46914
< #line 4229
<   if ((unsigned int )*((unsigned char *)mdev + 2277UL) != 4U) {
< #line 4229
---
> #line 3231
>   mdev = w->ldv_50388.mdev;
> #line 3233
>   if ((unsigned int )*((unsigned char *)mdev + 749UL) != 4U) {
> #line 3233
46993,46994c46916,46917
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             4229);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             3233);
46998,47000c46921,46923
< #line 4244
<   if ((unsigned long )mdev->bitmap != (unsigned long )((struct drbd_bitmap *)0)) {
< #line 4245
---
> #line 3252
>   if ((unsigned long )mdev->bitmap != (unsigned long )((struct drbd_bitmap *)0) && (unsigned long )mdev->ldev != (unsigned long )((struct drbd_backing_dev *)0)) {
> #line 3253
47003c46926
< #line 4245
---
> #line 3253
47005,47007c46928,46930
< #line 4247
<       tmp = drbd_test_flag(mdev, WAS_READ_ERROR);
< #line 4247
---
> #line 3255
>       tmp = constant_test_bit(13U, (unsigned long const volatile   *)(& mdev->flags));
> #line 3255
47009c46932
< #line 4248
---
> #line 3256
47011c46934
< #line 4249
---
> #line 3257
47022c46945
< #line 4254
---
> #line 3262
47024,47026c46947,46949
< #line 4254
<   val.ldv_40583.disk = 0U;
< #line 4254
---
> #line 3262
>   val.ldv_40604.disk = 0U;
> #line 3262
47028,47030c46951,46953
< #line 4254
<   mask.ldv_40583.disk = 15U;
< #line 4254
---
> #line 3262
>   mask.ldv_40604.disk = 15U;
> #line 3262
47032,47033c46955,46956
< #line 4255
<   return (1);
---
> #line 3263
>   return (0);
47036c46959
< #line 4258 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3266 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47042,47044c46965,46967
< #line 4260
<   if ((unsigned int )*((unsigned char *)mdev + 2277UL) != 4U) {
< #line 4260
---
> #line 3268
>   if ((unsigned int )*((unsigned char *)mdev + 749UL) != 4U) {
> #line 3268
47046,47047c46969,46970
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             4260);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             3268);
47051,47053c46974,46976
< #line 4261
<   tmp = drbd_test_and_set_flag(mdev, GO_DISKLESS);
< #line 4261
---
> #line 3269
>   tmp = test_and_set_bit(11, (unsigned long volatile   *)(& mdev->flags));
> #line 3269
47055,47056c46978,46979
< #line 4262
<     drbd_queue_work(& mdev->data.work, & mdev->go_diskless);
---
> #line 3270
>     drbd_queue_work(& (mdev->tconn)->sender_work, & mdev->go_diskless);
47060c46983
< #line 4263
---
> #line 3271
47064c46987
< #line 4277 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3285 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47076c46999
< #line 4282
---
> #line 3290
47078,47083c47001,47006
< #line 4282
<   if ((unsigned long )tmp != (unsigned long )mdev->worker.task) {
< #line 4282
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( current == mdev->worker.task ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             4282);
---
> #line 3290
>   if ((unsigned long )tmp != (unsigned long )(mdev->tconn)->worker.task) {
> #line 3290
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( current == mdev->tconn->worker.task ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             3290);
47087,47089c47010,47012
< #line 4284
<   tmp___0 = drbd_test_flag(mdev, BITMAP_IO_QUEUED);
< #line 4284
---
> #line 3292
>   tmp___0 = constant_test_bit(10U, (unsigned long const volatile   *)(& mdev->flags));
> #line 3292
47091,47094c47014,47017
< #line 4284
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !drbd_test_flag(mdev, BITMAP_IO_QUEUED) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             4284);
---
> #line 3292
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !test_bit(BITMAP_IO_QUEUED, &mdev->flags) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             3292);
47098,47100c47021,47023
< #line 4285
<   tmp___1 = drbd_test_flag(mdev, BITMAP_IO);
< #line 4285
---
> #line 3293
>   tmp___1 = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 3293
47102,47105c47025,47028
< #line 4285
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !drbd_test_flag(mdev, BITMAP_IO) ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             4285);
---
> #line 3293
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( !test_bit(BITMAP_IO, &mdev->flags) ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             3293);
47109c47032
< #line 4286
---
> #line 3294
47111c47034
< #line 4286
---
> #line 3294
47113c47036
< #line 4286
---
> #line 3294
47115,47116c47038,47039
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             4286);
---
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             3294);
47120c47043
< #line 4287
---
> #line 3295
47122c47045
< #line 4288
---
> #line 3296
47128c47051
< #line 4291
---
> #line 3299
47130c47053
< #line 4292
---
> #line 3300
47132c47055
< #line 4293
---
> #line 3301
47134c47057
< #line 4294
---
> #line 3302
47136,47140c47059,47063
< #line 4296
<   spin_lock_irq(& mdev->req_lock);
< #line 4297
<   drbd_set_flag(mdev, BITMAP_IO);
< #line 4298
---
> #line 3304
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 3305
>   set_bit(9U, (unsigned long volatile   *)(& mdev->flags));
> #line 3306
47142c47065
< #line 4298
---
> #line 3306
47144,47146c47067,47069
< #line 4299
<     tmp___3 = drbd_test_and_set_flag(mdev, BITMAP_IO_QUEUED);
< #line 4299
---
> #line 3307
>     tmp___3 = test_and_set_bit(10, (unsigned long volatile   *)(& mdev->flags));
> #line 3307
47148,47149c47071,47072
< #line 4300
<       drbd_queue_work(& mdev->data.work, & mdev->bm_io_work.w);
---
> #line 3308
>       drbd_queue_work(& (mdev->tconn)->sender_work, & mdev->bm_io_work.w);
47156,47158c47079,47081
< #line 4302
<   spin_unlock_irq(& mdev->req_lock);
< #line 4303
---
> #line 3310
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 3311
47162c47085
< #line 4314 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3322 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47170c47093
< #line 4319
---
> #line 3327
47172,47177c47095,47100
< #line 4319
<   if ((unsigned long )tmp == (unsigned long )mdev->worker.task) {
< #line 4319
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( current != mdev->worker.task ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
<             4319);
---
> #line 3327
>   if ((unsigned long )tmp == (unsigned long )(mdev->tconn)->worker.task) {
> #line 3327
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( current != mdev->tconn->worker.task ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>             3327);
47181c47104
< #line 4321
---
> #line 3329
47183c47106
< #line 4322
---
> #line 3330
47188c47111
< #line 4324
---
> #line 3332
47190c47113
< #line 4325
---
> #line 3333
47192c47115
< #line 4326
---
> #line 3334
47194c47117
< #line 4328
---
> #line 3336
47196c47119
< #line 4329
---
> #line 3337
47201c47124
< #line 4331
---
> #line 3339
47205c47128
< #line 4334 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3342 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47211c47134
< #line 4336
---
> #line 3344
47213c47136
< #line 4337
---
> #line 3345
47215c47138
< #line 4338
---
> #line 3346
47220c47143
< #line 4340
---
> #line 3348
47224c47147
< #line 4342 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3350 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47230c47153
< #line 4344
---
> #line 3352
47232c47155
< #line 4345
---
> #line 3353
47234c47157
< #line 4346
---
> #line 3354
47239c47162
< #line 4348
---
> #line 3356
47243c47166
< #line 4349 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3357 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47249c47172
< #line 4351
---
> #line 3359
47253c47176
< #line 4354 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3362 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47256a47180
>   int tmp ;
47259c47183
< #line 4356
---
> #line 3364
47261,47263c47185,47194
< #line 4358
<   drbd_queue_work_front(& mdev->data.work, & mdev->md_sync_work);
< #line 4359
---
> #line 3367
>   tmp = list_empty((struct list_head  const  *)(& mdev->md_sync_work.list));
> #line 3367
>   if (tmp != 0) {
> #line 3368
>     drbd_queue_work_front(& (mdev->tconn)->sender_work, & mdev->md_sync_work);
>   } else {
> 
>   }
> #line 3369
47267,47268c47198,47199
< #line 4361 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< static int w_md_sync(struct drbd_conf *mdev , struct drbd_work *w , int unused ) 
---
> #line 3371 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> static int w_md_sync(struct drbd_work *w , int unused ) 
47270c47201
< 
---
>   struct drbd_conf *mdev ;
47273c47204,47206
< #line 4363
---
> #line 3373
>   mdev = w->ldv_50388.mdev;
> #line 3375
47275c47208
< #line 4368
---
> #line 3380
47277,47278c47210,47440
< #line 4369
<   return (1);
---
> #line 3381
>   return (0);
> }
> }
> #line 3384 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> char const   *cmdname(enum drbd_packet cmd ) 
> { 
>   char const   *cmdnames[46U] ;
> 
>   {
> #line 3389
>   cmdnames[0] = "Data";
> #line 3389
>   cmdnames[1] = "DataReply";
> #line 3389
>   cmdnames[2] = "RSDataReply";
> #line 3389
>   cmdnames[3] = "Barrier";
> #line 3389
>   cmdnames[4] = "ReportBitMap";
> #line 3389
>   cmdnames[5] = "BecomeSyncTarget";
> #line 3389
>   cmdnames[6] = "BecomeSyncSource";
> #line 3389
>   cmdnames[7] = "UnplugRemote";
> #line 3389
>   cmdnames[8] = "DataRequest";
> #line 3389
>   cmdnames[9] = "RSDataRequest";
> #line 3389
>   cmdnames[10] = "SyncParam";
> #line 3389
>   cmdnames[11] = "ReportProtocol";
> #line 3389
>   cmdnames[12] = "ReportUUIDs";
> #line 3389
>   cmdnames[13] = "ReportSizes";
> #line 3389
>   cmdnames[14] = "ReportState";
> #line 3389
>   cmdnames[15] = "ReportSyncUUID";
> #line 3389
>   cmdnames[16] = "AuthChallenge";
> #line 3389
>   cmdnames[17] = "AuthResponse";
> #line 3389
>   cmdnames[18] = "StateChgRequest";
> #line 3389
>   cmdnames[19] = "Ping";
> #line 3389
>   cmdnames[20] = "PingAck";
> #line 3389
>   cmdnames[21] = "RecvAck";
> #line 3389
>   cmdnames[22] = "WriteAck";
> #line 3389
>   cmdnames[23] = "RSWriteAck";
> #line 3389
>   cmdnames[24] = "Superseded";
> #line 3389
>   cmdnames[25] = "NegAck";
> #line 3389
>   cmdnames[26] = "NegDReply";
> #line 3389
>   cmdnames[27] = "NegRSDReply";
> #line 3389
>   cmdnames[28] = "BarrierAck";
> #line 3389
>   cmdnames[29] = "StateChgReply";
> #line 3389
>   cmdnames[30] = "OVRequest";
> #line 3389
>   cmdnames[31] = "OVReply";
> #line 3389
>   cmdnames[32] = "OVResult";
> #line 3389
>   cmdnames[33] = "CsumRSRequest";
> #line 3389
>   cmdnames[34] = "CsumRSIsInSync";
> #line 3389
>   cmdnames[35] = "SyncParam89";
> #line 3389
>   cmdnames[36] = "CBitmap";
> #line 3389
>   cmdnames[37] = 0;
> #line 3389
>   cmdnames[38] = 0;
> #line 3389
>   cmdnames[39] = "DelayProbe";
> #line 3389
>   cmdnames[40] = "OutOfSync";
> #line 3389
>   cmdnames[41] = "RSCancel";
> #line 3389
>   cmdnames[42] = "conn_st_chg_req";
> #line 3389
>   cmdnames[43] = "conn_st_chg_reply";
> #line 3389
>   cmdnames[44] = "retry_write";
> #line 3389
>   cmdnames[45] = "protocol_update";
> #line 3443
>   if ((unsigned int )cmd == 65521U) {
> #line 3444
>     return ("InitialMeta");
>   } else {
> 
>   }
> #line 3445
>   if ((unsigned int )cmd == 65522U) {
> #line 3446
>     return ("InitialData");
>   } else {
> 
>   }
> #line 3447
>   if ((unsigned int )cmd == 65534U) {
> #line 3448
>     return ("ConnectionFeatures");
>   } else {
> 
>   }
> #line 3449
>   if ((unsigned int )cmd > (unsigned int )P_PROTOCOL_UPDATE) {
> #line 3450
>     return ("Unknown");
>   } else {
> 
>   }
> #line 3451
>   return (cmdnames[(unsigned int )cmd]);
> }
> }
> #line 3460 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> int drbd_wait_misc(struct drbd_conf *mdev , struct drbd_interval *i ) 
> { 
>   struct net_conf *nc ;
>   wait_queue_t wait ;
>   struct task_struct *tmp ;
>   long timeout ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___0 ;
>   int tmp___1 ;
>   struct task_struct *tmp___2 ;
>   int tmp___3 ;
> 
>   {
> #line 3463
>   tmp = get_current();
> #line 3463
>   wait.flags = 0U;
> #line 3463
>   wait.private = (void *)tmp;
> #line 3463
>   wait.func = & autoremove_wake_function;
> #line 3463
>   wait.task_list.next = & wait.task_list;
> #line 3463
>   wait.task_list.prev = & wait.task_list;
> #line 3466
>   rcu_read_lock();
> #line 3467
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 3467
>   tmp___0 = debug_lockdep_rcu_enabled();
> #line 3467
>   if (tmp___0 != 0 && ! __warned) {
> #line 3467
>     tmp___1 = rcu_read_lock_held();
> #line 3467
>     if (tmp___1 == 0 && 1) {
> #line 3467
>       __warned = 1;
> #line 3467
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared",
>                              3467, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 3467
>   nc = _________p1;
> #line 3468
>   if ((unsigned long )nc == (unsigned long )((struct net_conf *)0)) {
> #line 3469
>     rcu_read_unlock();
> #line 3470
>     return (-110);
>   } else {
> 
>   }
> #line 3472
>   timeout = nc->ko_count != 0U ? (long )(((nc->timeout * 250U) / 10U) * nc->ko_count) : 9223372036854775807L;
> #line 3473
>   rcu_read_unlock();
> #line 3476
>   i->waiting = -1;
> #line 3477
>   prepare_to_wait(& mdev->misc_wait, & wait, 1);
> #line 3478
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 3479
>   timeout = schedule_timeout(timeout);
> #line 3480
>   finish_wait(& mdev->misc_wait, & wait);
> #line 3481
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 3482
>   if (timeout == 0L || (int )mdev->state.ldv_50103.conn <= 9) {
> #line 3483
>     return (-110);
>   } else {
> 
>   }
> #line 3484
>   tmp___2 = get_current();
> #line 3484
>   tmp___3 = signal_pending(tmp___2);
> #line 3484
>   if (tmp___3 != 0) {
> #line 3485
>     return (-512);
>   } else {
> 
>   }
> #line 3486
>   return (0);
47281c47443
< #line 4389 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3506 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47289c47451
< #line 4393
---
> #line 3510
47291c47453
< #line 4393
---
> #line 3510
47293c47455
< #line 4393
---
> #line 3510
47295c47457
< #line 4394
---
> #line 3511
47297c47459
< #line 4395
---
> #line 3512
47299c47461
< #line 4396
---
> #line 3513
47304c47466
< #line 4398
---
> #line 3515
47306c47468
< #line 4399
---
> #line 3516
47308c47470
< #line 4399
---
> #line 3516
47312c47474
< #line 4403 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3520 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47318c47480
< #line 4404
---
> #line 3521
47320c47482
< #line 4404
---
> #line 3521
47322c47484
< #line 4404
---
> #line 3521
47324c47486
< #line 4404
---
> #line 3521
47326c47488
< #line 4404
---
> #line 3521
47328c47490
< #line 4404
---
> #line 3521
47330c47492
< #line 4404
---
> #line 3521
47332c47494
< #line 4404
---
> #line 3521
47334c47496
< #line 4404
---
> #line 3521
47336c47498
< #line 4404
---
> #line 3521
47338c47500
< #line 4417
---
> #line 3534
47342c47504
< #line 4421 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3538 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47354c47516
< #line 4423
---
> #line 3540
47356c47518
< #line 4423
---
> #line 3540
47358c47520
< #line 4425
---
> #line 3542
47360c47522
< #line 4425
---
> #line 3542
47363c47525
< #line 4425
---
> #line 3542
47365c47527
< #line 4425
---
> #line 3542
47368c47530
< #line 4425
---
> #line 3542
47370c47532
< #line 4425
---
> #line 3542
47372c47534
< #line 4425
---
> #line 3542
47375c47537
< #line 4425
---
> #line 3542
47379c47541
< #line 4425
---
> #line 3542
47383c47545
< #line 4425
---
> #line 3542
47385c47547
< #line 4430
---
> #line 3547
47387c47549
< #line 4431
---
> #line 3548
47389c47551
< #line 4433
---
> #line 3550
47391c47553
< #line 4433
---
> #line 3550
47393c47555
< #line 4434
---
> #line 3551
47395c47557
< #line 4434
---
> #line 3551
47404c47566
< #line 4438
---
> #line 3555
47408c47570
< #line 4442 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3559 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47415c47577
< #line 4447
---
> #line 3564
47417c47579
< #line 4447
---
> #line 3564
47419c47581
< #line 4447
---
> #line 3564
47421c47583
< #line 4447
---
> #line 3564
47423c47585
< #line 4447
---
> #line 3564
47428c47590
< #line 4447
---
> #line 3564
47430c47592
< #line 4447
---
> #line 3564
47433c47595
< #line 4449
---
> #line 3566
47435c47597
< #line 4451
---
> #line 3568
47440c47602
< #line 4457
---
> #line 3574
47444c47606
< #line 4505 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
---
> #line 3622 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
47455c47617
<   unsigned long var_md_sync_timer_fn_110_p0 ;
---
>   unsigned long var_md_sync_timer_fn_120_p0 ;
47462c47624
< #line 4704
---
> #line 3811
47464c47626
< #line 4661
---
> #line 3770
47466c47628
< #line 4670
---
> #line 3779
47468c47630
< #line 4686
---
> #line 3793
47470c47632
< #line 4687
---
> #line 3794
47472c47634
< #line 4687
---
> #line 3794
47474c47636
< #line 4688
---
> #line 3795
47479,47482c47641,47644
< #line 4711
<   goto ldv_52832;
<   ldv_52831: 
< #line 4715
---
> #line 3818
>   goto ldv_53386;
>   ldv_53385: 
> #line 3822
47484c47646
< #line 4715
---
> #line 3822
47487c47649
< #line 4720
---
> #line 3827
47489c47651
< #line 4733
---
> #line 3840
47491c47653
< #line 4734
---
> #line 3841
47493c47655
< #line 4735
---
> #line 3842
47495c47657
< #line 4736
---
> #line 3843
47497c47659
< #line 4737
---
> #line 3844
47502c47664
< #line 4758
---
> #line 3863
47507,47508c47669,47670
< #line 4764
<   goto ldv_52826;
---
> #line 3869
>   goto ldv_53380;
47510c47672
< #line 4768
---
> #line 3873
47512c47674
< #line 4781
---
> #line 3886
47514c47676
< #line 4782
---
> #line 3887
47516c47678
< #line 4803
---
> #line 3906
47521,47522c47683,47684
< #line 4809
<   goto ldv_52826;
---
> #line 3912
>   goto ldv_53380;
47524c47686
< #line 4828
---
> #line 3929
47526c47688
< #line 4829
---
> #line 3930
47528,47529c47690,47691
< #line 4854
<   goto ldv_52826;
---
> #line 3955
>   goto ldv_53380;
47531c47693
< #line 4879
---
> #line 3978
47533,47536c47695,47698
< #line 4880
<   md_sync_timer_fn(var_md_sync_timer_fn_110_p0);
< #line 4899
<   goto ldv_52826;
---
> #line 3979
>   md_sync_timer_fn(var_md_sync_timer_fn_120_p0);
> #line 3998
>   goto ldv_53380;
47538,47539c47700,47701
< #line 4900
<   goto ldv_52826;
---
> #line 3999
>   goto ldv_53380;
47541,47543c47703,47705
<   ldv_52826: ;
<   ldv_52832: 
< #line 4711
---
>   ldv_53380: ;
>   ldv_53386: 
> #line 3818
47545c47707
< #line 4711
---
> #line 3818
47547,47548c47709,47710
< #line 4713
<     goto ldv_52831;
---
> #line 3820
>     goto ldv_53385;
47554c47716
< #line 4922
---
> #line 4019
47556c47718
< #line 4923
---
> #line 4020
47559c47721
< #line 4944
---
> #line 4041
47561c47723
< #line 4947
---
> #line 4044
47565,47566c47727,47728
< #line 4951 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void ldv_module_put_4(struct module *ldv_func_arg1 ) 
---
> #line 4048 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void ldv_module_put_3(struct module *ldv_func_arg1 ) 
47571c47733
< #line 4956
---
> #line 4053
47573c47735
< #line 4957
---
> #line 4054
47577,47578c47739,47740
< #line 4959 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< bool ldv_try_module_get_5(struct module *ldv_func_arg1 ) 
---
> #line 4056 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> bool ldv_try_module_get_4(struct module *ldv_func_arg1 ) 
47583c47745
< #line 4964
---
> #line 4061
47585c47747
< #line 4964
---
> #line 4061
47589,47590c47751,47752
< #line 4967 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
< void ldv_module_put_6(struct module *ldv_func_arg1 ) 
---
> #line 4064 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_main.c.prepared"
> void ldv_module_put_5(struct module *ldv_func_arg1 ) 
47595c47757
< #line 4972
---
> #line 4069
47597c47759
< #line 4973
---
> #line 4070
47601c47763
< #line 35 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
---
> #line 35 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
47603c47765
< #line 35 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
---
> #line 35 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
47610c47772
< #line 62 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
---
> #line 62 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
47612c47774
< #line 68 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
---
> #line 68 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
47618,47619c47780,47781
< #line 80 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
< static char const   *drbd_state_sw_errors[20U]  = 
---
> #line 80 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
> static char const   *drbd_state_sw_errors[21U]  = 
47625,47626c47787,47789
<         "Disk state is lower than outdated",      "Peer does not support protocol",      "In transient state, retry after next state change",      "Concurrent state changes detected and aborted"};
< #line 101 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
---
>         "Disk state is lower than outdated",      "Peer does not support protocol",      "In transient state, retry after next state change",      "Concurrent state changes detected and aborted", 
>         "Other vol primary on peer not allowed by config"};
> #line 102 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
47632c47795
< #line 104
---
> #line 105
47636c47799
< #line 107 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
---
> #line 108 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
47642c47805
< #line 109
---
> #line 110
47646c47809
< #line 112 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
---
> #line 113 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
47652c47815
< #line 114
---
> #line 115
47656c47819
< #line 117 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
---
> #line 118 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_strings.c.prepared"
47662,47663c47825,47844
< #line 119
<   return ((int )err >= -19 ? ((int )err < 0 ? drbd_state_sw_errors[- ((int )err)] : "TOO_LARGE") : "TOO_SMALL");
---
> #line 120
>   return ((int )err >= -20 ? ((int )err < 0 ? drbd_state_sw_errors[- ((int )err)] : "TOO_LARGE") : "TOO_SMALL");
> }
> }
> #line 53 "include/linux/string.h"
> extern char *strchr(char const   * , int  ) ;
> #line 70 "include/linux/kmod.h"
> extern int call_usermodehelper_fns(char * , char ** , char ** , int  , int (*)(struct subprocess_info * ,
>                                                                                struct cred * ) ,
>                                    void (*)(struct subprocess_info * ) , void * ) ;
> #line 75 "include/linux/kmod.h"
> __inline static int call_usermodehelper(char *path , char **argv , char **envp , int wait ) 
> { 
>   int tmp ;
> 
>   {
> #line 77
>   tmp = call_usermodehelper_fns(path, argv, envp, wait, 0, 0, 0);
> #line 77
>   return (tmp);
47666,47667c47847,47850
< #line 47 "include/uapi/linux/byteorder/little_endian.h"
< __inline static __u64 __le64_to_cpup(__le64 const   *p ) 
---
> #line 207 "include/linux/kobject.h"
> extern int kobject_uevent(struct kobject * , enum kobject_action  ) ;
> #line 114 "include/linux/rculist.h"
> __inline static void list_del_rcu(struct list_head *entry ) 
47672,47673c47855,47880
< #line 49
<   return ((__u64 )*p);
---
> #line 116
>   __list_del_entry(entry);
> #line 117
>   entry->prev = 0xdead000000200200UL;
> #line 118
>   return;
> }
> }
> #line 210 "include/linux/capability.h"
> extern bool capable(int  ) ;
> #line 2093 "include/linux/fs.h"
> extern struct block_device *blkdev_get_by_path(char const   * , fmode_t  , void * ) ;
> #line 568 "include/linux/skbuff.h"
> extern void kfree_skb(struct sk_buff * ) ;
> #line 577
> extern struct sk_buff *__alloc_skb(unsigned int  , gfp_t  , int  , int  ) ;
> #line 580 "include/linux/skbuff.h"
> __inline static struct sk_buff *alloc_skb(unsigned int size , gfp_t priority ) 
> { 
>   struct sk_buff *tmp ;
> 
>   {
> #line 583
>   tmp = __alloc_skb(size, priority, 0, -1);
> #line 583
>   return (tmp);
47676,47677c47883,47884
< #line 55 "include/uapi/linux/byteorder/little_endian.h"
< __inline static __u32 __le32_to_cpup(__le32 const   *p ) 
---
> #line 1295 "include/linux/skbuff.h"
> __inline static unsigned char *skb_tail_pointer(struct sk_buff  const  *skb ) 
47682,47683c47889,47890
< #line 57
<   return ((__u32 )*p);
---
> #line 1297
>   return ((unsigned char *)skb->head + (unsigned long )skb->tail);
47686,47687c47893,47898
< #line 63 "include/uapi/linux/byteorder/little_endian.h"
< __inline static __u16 __le16_to_cpup(__le16 const   *p ) 
---
> #line 1644
> extern void skb_trim(struct sk_buff * , unsigned int  ) ;
> #line 7 "include/linux/seq_file_net.h"
> extern struct net init_net ;
> #line 238 "include/net/net_namespace.h"
> __inline static struct net *read_pnet(struct net * const  *pnet ) 
47692,47693c47903,47904
< #line 65
<   return ((__u16 )*p);
---
> #line 240
>   return ((struct net *)*pnet);
47696,47705c47907,47908
< #line 326 "include/linux/kernel.h"
< extern int snprintf(char * , size_t  , char const   *  , ...) ;
< #line 93 "include/linux/bitmap.h"
< extern int __bitmap_equal(unsigned long const   * , unsigned long const   * , int  ) ;
< #line 125
< extern int __bitmap_parse(char const   * , unsigned int  , int  , unsigned long * ,
<                           int  ) ;
< #line 179 "include/linux/bitmap.h"
< __inline static void bitmap_copy(unsigned long *dst , unsigned long const   *src ,
<                                  int nbits ) 
---
> #line 13 "include/linux/netlink.h"
> __inline static struct nlmsghdr *nlmsg_hdr(struct sk_buff  const  *skb ) 
47707,47709c47910
<   int len ;
<   size_t __len ;
<   void *__ret ;
---
> 
47712,47718c47913,48043
< #line 185
<   len = (int )((unsigned int )(((unsigned long )nbits + 63UL) / 64UL) * 8U);
< #line 186
<   __len = (size_t )len;
< #line 186
<   __ret = __builtin_memcpy((void *)dst, (void const   *)src, __len);
< #line 189
---
> #line 15
>   return ((struct nlmsghdr *)skb->data);
> }
> }
> #line 60
> extern int netlink_unicast(struct sock * , struct sk_buff * , __u32  , int  ) ;
> #line 61
> extern int netlink_broadcast(struct sock * , struct sk_buff * , __u32  , __u32  ,
>                              gfp_t  ) ;
> #line 242 "include/net/netlink.h"
> extern struct nlattr *nla_find(struct nlattr  const  * , int  , int  ) ;
> #line 244
> extern size_t nla_strlcpy(char * , struct nlattr  const  * , size_t  ) ;
> #line 246
> extern int nla_memcpy(void * , struct nlattr  const  * , int  ) ;
> #line 260
> extern int nla_put(struct sk_buff * , int  , int  , void const   * ) ;
> #line 262
> extern int nla_put_nohdr(struct sk_buff * , int  , void const   * ) ;
> #line 275 "include/net/netlink.h"
> __inline static int nlmsg_msg_size(int payload ) 
> { 
> 
> 
>   {
> #line 277
>   return (payload + 16);
> }
> }
> #line 284 "include/net/netlink.h"
> __inline static int nlmsg_total_size(int payload ) 
> { 
>   int tmp ;
> 
>   {
> #line 286
>   tmp = nlmsg_msg_size(payload);
> #line 286
>   return ((int )((unsigned int )tmp + 3U) & -4);
> }
> }
> #line 302 "include/net/netlink.h"
> __inline static void *nlmsg_data(struct nlmsghdr  const  *nlh ) 
> { 
> 
> 
>   {
> #line 304
>   return ((void *)nlh + 16U);
> }
> }
> #line 311 "include/net/netlink.h"
> __inline static int nlmsg_len(struct nlmsghdr  const  *nlh ) 
> { 
> 
> 
>   {
> #line 313
>   return ((int )((unsigned int )nlh->nlmsg_len - 16U));
> }
> }
> #line 321 "include/net/netlink.h"
> __inline static struct nlattr *nlmsg_attrdata(struct nlmsghdr  const  *nlh , int hdrlen ) 
> { 
>   unsigned char *data ;
>   void *tmp ;
> 
>   {
> #line 324
>   tmp = nlmsg_data(nlh);
> #line 324
>   data = (unsigned char *)tmp;
> #line 325
>   return ((struct nlattr *)(data + ((unsigned long )((unsigned int )hdrlen + 3U) & 4294967292UL)));
> }
> }
> #line 333 "include/net/netlink.h"
> __inline static int nlmsg_attrlen(struct nlmsghdr  const  *nlh , int hdrlen ) 
> { 
>   int tmp ;
> 
>   {
> #line 335
>   tmp = nlmsg_len(nlh);
> #line 335
>   return ((int )((unsigned int )tmp - (((unsigned int )hdrlen + 3U) & 4294967292U)));
> }
> }
> #line 493 "include/net/netlink.h"
> __inline static struct sk_buff *nlmsg_new(size_t payload , gfp_t flags ) 
> { 
>   int tmp ;
>   struct sk_buff *tmp___0 ;
> 
>   {
> #line 495
>   tmp = nlmsg_total_size((int )payload);
> #line 495
>   tmp___0 = alloc_skb((unsigned int )tmp, flags);
> #line 495
>   return (tmp___0);
> }
> }
> #line 509 "include/net/netlink.h"
> __inline static int nlmsg_end(struct sk_buff *skb , struct nlmsghdr *nlh ) 
> { 
>   unsigned char *tmp ;
> 
>   {
> #line 511
>   tmp = skb_tail_pointer((struct sk_buff  const  *)skb);
> #line 511
>   nlh->nlmsg_len = (__u32 )((long )tmp) - (__u32 )((long )nlh);
> #line 513
>   return ((int )skb->len);
> }
> }
> #line 534 "include/net/netlink.h"
> __inline static void nlmsg_trim(struct sk_buff *skb , void const   *mark ) 
> { 
> 
> 
>   {
> #line 536
>   if ((unsigned long )mark != (unsigned long )((void const   *)0)) {
> #line 537
>     skb_trim(skb, (unsigned int )((long )mark) - (unsigned int )((long )skb->data));
>   } else {
> 
>   }
> #line 538
47722,47724c48047,48133
< #line 233 "include/linux/bitmap.h"
< __inline static int bitmap_equal(unsigned long const   *src1 , unsigned long const   *src2 ,
<                                  int nbits ) 
---
> #line 548 "include/net/netlink.h"
> __inline static void nlmsg_cancel(struct sk_buff *skb , struct nlmsghdr *nlh ) 
> { 
> 
> 
>   {
> #line 550
>   nlmsg_trim(skb, (void const   *)nlh);
> #line 551
>   return;
> }
> }
> #line 557 "include/net/netlink.h"
> __inline static void nlmsg_free(struct sk_buff *skb ) 
> { 
> 
> 
>   {
> #line 559
>   kfree_skb(skb);
> #line 560
>   return;
> }
> }
> #line 570 "include/net/netlink.h"
> __inline static int nlmsg_multicast(struct sock *sk , struct sk_buff *skb , u32 portid ,
>                                     unsigned int group , gfp_t flags ) 
> { 
>   int err ;
> 
>   {
> #line 575
>   ((struct netlink_skb_parms *)(& skb->cb))->dst_group = group;
> #line 577
>   err = netlink_broadcast(sk, skb, portid, group, flags);
> #line 578
>   if (err > 0) {
> #line 579
>     err = 0;
>   } else {
> 
>   }
> #line 581
>   return (err);
> }
> }
> #line 590 "include/net/netlink.h"
> __inline static int nlmsg_unicast(struct sock *sk , struct sk_buff *skb , u32 portid ) 
> { 
>   int err ;
> 
>   {
> #line 594
>   err = netlink_unicast(sk, skb, portid, 64);
> #line 595
>   if (err > 0) {
> #line 596
>     err = 0;
>   } else {
> 
>   }
> #line 598
>   return (err);
> }
> }
> #line 681 "include/net/netlink.h"
> __inline static void *nla_data(struct nlattr  const  *nla ) 
> { 
> 
> 
>   {
> #line 683
>   return ((void *)nla + 4U);
> }
> }
> #line 690 "include/net/netlink.h"
> __inline static int nla_len(struct nlattr  const  *nla ) 
> { 
> 
> 
>   {
> #line 692
>   return ((int )nla->nla_len + -4);
> }
> }
> #line 758 "include/net/netlink.h"
> __inline static int nla_put_u8(struct sk_buff *skb , int attrtype , u8 value ) 
47729,47731c48138,48140
< #line 239
<   tmp = __bitmap_equal(src1, src2, nbits);
< #line 239
---
> #line 760
>   tmp = nla_put(skb, attrtype, 1, (void const   *)(& value));
> #line 760
47735,47737c48144,48145
< #line 301 "include/linux/bitmap.h"
< __inline static int bitmap_parse(char const   *buf , unsigned int buflen , unsigned long *maskp ,
<                                  int nmaskbits ) 
---
> #line 813 "include/net/netlink.h"
> __inline static int nla_put_u32(struct sk_buff *skb , int attrtype , u32 value ) 
47742,47744c48150,48152
< #line 304
<   tmp = __bitmap_parse(buf, buflen, 0, maskp, nmaskbits);
< #line 304
---
> #line 815
>   tmp = nla_put(skb, attrtype, 4, (void const   *)(& value));
> #line 815
47748,47749c48156,48157
< #line 404 "include/linux/cpumask.h"
< __inline static bool cpumask_equal(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
---
> #line 857 "include/net/netlink.h"
> __inline static int nla_put_u64(struct sk_buff *skb , int attrtype , u64 value ) 
47754,47758c48162,48165
< #line 407
<   tmp = bitmap_equal((unsigned long const   *)(& src1p->bits), (unsigned long const   *)(& src2p->bits),
<                      nr_cpu_ids);
< #line 407
<   return (tmp != 0);
---
> #line 859
>   tmp = nla_put(skb, attrtype, 8, (void const   *)(& value));
> #line 859
>   return (tmp);
47761,47762c48168,48184
< #line 495 "include/linux/cpumask.h"
< __inline static void cpumask_copy(struct cpumask *dstp , struct cpumask  const  *srcp ) 
---
> #line 945 "include/net/netlink.h"
> __inline static int nla_put_string(struct sk_buff *skb , int attrtype , char const   *str ) 
> { 
>   size_t tmp ;
>   int tmp___0 ;
> 
>   {
> #line 948
>   tmp = strlen(str);
> #line 948
>   tmp___0 = nla_put(skb, attrtype, (int )((unsigned int )tmp + 1U), (void const   *)str);
> #line 948
>   return (tmp___0);
> }
> }
> #line 978 "include/net/netlink.h"
> __inline static u32 nla_get_u32(struct nlattr  const  *nla ) 
47763a48186
>   void *tmp ;
47764a48188,48198
>   {
> #line 980
>   tmp = nla_data(nla);
> #line 980
>   return (*((u32 *)tmp));
> }
> }
> #line 1023 "include/net/netlink.h"
> __inline static u8 nla_get_u8(struct nlattr  const  *nla ) 
> { 
>   void *tmp ;
47767,47771c48201,48204
< #line 498
<   bitmap_copy((unsigned long *)(& dstp->bits), (unsigned long const   *)(& srcp->bits),
<               nr_cpu_ids);
< #line 499
<   return;
---
> #line 1025
>   tmp = nla_data(nla);
> #line 1025
>   return (*((u8 *)tmp));
47774,47779c48207,48208
< #line 70 "include/linux/kmod.h"
< extern int call_usermodehelper_fns(char * , char ** , char ** , int  , int (*)(struct subprocess_info * ,
<                                                                                struct cred * ) ,
<                                    void (*)(struct subprocess_info * ) , void * ) ;
< #line 75 "include/linux/kmod.h"
< __inline static int call_usermodehelper(char *path , char **argv , char **envp , int wait ) 
---
> #line 1032 "include/net/netlink.h"
> __inline static u64 nla_get_u64(struct nlattr  const  *nla ) 
47781c48210
<   int tmp ;
---
>   u64 tmp ;
47784,47786c48213,48215
< #line 77
<   tmp = call_usermodehelper_fns(path, argv, envp, wait, 0, 0, 0);
< #line 77
---
> #line 1036
>   nla_memcpy((void *)(& tmp), nla, 8);
> #line 1038
47790,47810c48219,48269
< #line 207 "include/linux/kobject.h"
< extern int kobject_uevent(struct kobject * , enum kobject_action  ) ;
< #line 468 "include/linux/module.h"
< bool ldv_try_module_get_7(struct module *ldv_func_arg1 ) ;
< #line 474
< void ldv_module_put_8(struct module *ldv_func_arg1 ) ;
< #line 478
< void ldv_module_put_9(struct module *ldv_func_arg1 ) ;
< #line 210 "include/linux/capability.h"
< extern bool capable(int  ) ;
< #line 2093 "include/linux/fs.h"
< extern struct block_device *blkdev_get_by_path(char const   * , fmode_t  , void * ) ;
< #line 71 "include/linux/connector.h"
< extern int cn_add_callback(struct cb_id * , char const   * , void (*)(struct cn_msg * ,
<                                                                       struct netlink_skb_parms * ) ) ;
< #line 73
< extern void cn_del_callback(struct cb_id * ) ;
< #line 74
< extern int cn_netlink_send(struct cn_msg * , u32  , gfp_t  ) ;
< #line 409 "include/linux/genhd.h"
< extern void add_disk(struct gendisk * ) ;
---
> #line 1123 "include/net/netlink.h"
> __inline static struct nlattr *nla_nest_start(struct sk_buff *skb , int attrtype ) 
> { 
>   struct nlattr *start ;
>   unsigned char *tmp ;
>   int tmp___0 ;
> 
>   {
> #line 1125
>   tmp = skb_tail_pointer((struct sk_buff  const  *)skb);
> #line 1125
>   start = (struct nlattr *)tmp;
> #line 1127
>   tmp___0 = nla_put(skb, attrtype, 0, 0);
> #line 1127
>   if (tmp___0 < 0) {
> #line 1128
>     return (0);
>   } else {
> 
>   }
> #line 1130
>   return (start);
> }
> }
> #line 1143 "include/net/netlink.h"
> __inline static int nla_nest_end(struct sk_buff *skb , struct nlattr *start ) 
> { 
>   unsigned char *tmp ;
> 
>   {
> #line 1145
>   tmp = skb_tail_pointer((struct sk_buff  const  *)skb);
> #line 1145
>   start->nla_len = (int )((__u16 )((long )tmp)) - (int )((__u16 )((long )start));
> #line 1146
>   return ((int )skb->len);
> }
> }
> #line 1157 "include/net/netlink.h"
> __inline static void nla_nest_cancel(struct sk_buff *skb , struct nlattr *start ) 
> { 
> 
> 
>   {
> #line 1159
>   nlmsg_trim(skb, (void const   *)start);
> #line 1160
>   return;
> }
> }
47819c48278
< #line 241 "include/linux/lru_cache.h"
---
> #line 251 "include/linux/lru_cache.h"
47821,47824c48280,48304
<                                    size_t  , size_t  ) ;
< #line 1596 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
< enum drbd_disk_state drbd_try_outdate_peer(struct drbd_conf *mdev ) ;
< #line 2011 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
---
>                                    unsigned int  , size_t  , size_t  ) ;
> #line 293
> extern int lc_try_lock(struct lru_cache * ) ;
> #line 135 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_state.h"
> bool conn_all_vols_unconf(struct drbd_tconn *tconn ) ;
> #line 147 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_state.h"
> __inline static int drbd_request_state(struct drbd_conf *mdev , union drbd_state mask ,
>                                        union drbd_state val ) 
> { 
>   enum drbd_state_rv tmp ;
> 
>   {
> #line 151
>   tmp = _drbd_request_state(mdev, mask, val, 14);
> #line 151
>   return ((int )tmp);
> }
> }
> #line 155
> enum drbd_role conn_highest_peer(struct drbd_tconn *tconn ) ;
> #line 156
> enum drbd_disk_state conn_highest_disk(struct drbd_tconn *tconn ) ;
> #line 1441 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> bool conn_try_outdate_peer(struct drbd_tconn *tconn ) ;
> #line 1818 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
47827a48308,48312
>   int meta_dev_idx ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
47830,47831c48315,48316
<   sector_t tmp___0 ;
<   sector_t tmp___1 ;
---
>   sector_t tmp___2 ;
>   sector_t tmp___3 ;
47834c48319
<   sector_t tmp___2 ;
---
>   sector_t tmp___4 ;
47839c48324
<   sector_t tmp___3 ;
---
>   sector_t tmp___5 ;
47842,47843c48327,48355
< #line 2014
<   switch (bdev->dc.meta_dev_idx) {
---
> #line 1823
>   rcu_read_lock();
> #line 1824
>   _________p1 = *((struct disk_conf * volatile  *)(& bdev->disk_conf));
> #line 1824
>   tmp = debug_lockdep_rcu_enabled();
> #line 1824
>   if (tmp != 0 && ! __warned) {
> #line 1824
>     tmp___0 = rcu_read_lock_held();
> #line 1824
>     if (tmp___0 == 0 && 1) {
> #line 1824
>       __warned = 1;
> #line 1824
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h",
>                              1824, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1824
>   meta_dev_idx = _________p1->meta_dev_idx;
> #line 1825
>   rcu_read_unlock();
> #line 1827
>   switch (meta_dev_idx) {
47846,47850c48358,48362
< #line 2018
<   tmp___1 = drbd_get_capacity(bdev->backing_bdev);
< #line 2018
<   if (tmp___1 != 0UL) {
< #line 2018
---
> #line 1831
>   tmp___3 = drbd_get_capacity(bdev->backing_bdev);
> #line 1831
>   if (tmp___3 != 0UL) {
> #line 1831
47852,47856c48364,48368
< #line 2018
<     tmp___0 = drbd_md_first_sector(bdev);
< #line 2018
<     __min2 = tmp___0;
< #line 2018
---
> #line 1831
>     tmp___2 = _drbd_md_first_sector(meta_dev_idx, bdev);
> #line 1831
>     __min2 = tmp___2;
> #line 1831
47859c48371
< #line 2018
---
> #line 1831
47862,47863c48374,48375
< #line 2021
<   goto ldv_50987;
---
> #line 1834
>   goto ldv_51507;
47865c48377
< #line 2023
---
> #line 1836
47867,47871c48379,48383
< #line 2023
<   tmp___2 = drbd_get_capacity(bdev->backing_bdev);
< #line 2023
<   __min2___0 = tmp___2;
< #line 2023
---
> #line 1836
>   tmp___4 = drbd_get_capacity(bdev->backing_bdev);
> #line 1836
>   __min2___0 = tmp___4;
> #line 1836
47873c48385
< #line 2026
---
> #line 1839
47875c48387
< #line 2026
---
> #line 1839
47877c48389
< #line 2026
---
> #line 1839
47879,47880c48391,48392
< #line 2029
<   goto ldv_50987;
---
> #line 1842
>   goto ldv_51507;
47882c48394
< #line 2031
---
> #line 1844
47884,47888c48396,48400
< #line 2031
<   tmp___3 = drbd_get_capacity(bdev->backing_bdev);
< #line 2031
<   __min2___2 = tmp___3;
< #line 2031
---
> #line 1844
>   tmp___5 = drbd_get_capacity(bdev->backing_bdev);
> #line 1844
>   __min2___2 = tmp___5;
> #line 1844
47891,47892c48403,48404
<   ldv_50987: ;
< #line 2034
---
>   ldv_51507: ;
> #line 1847
47896,47897c48408,48409
< #line 7 "include/linux/unaligned/access_ok.h"
< __inline static u16 get_unaligned_le16(void const   *p ) 
---
> #line 89 "include/net/genetlink.h"
> __inline static struct net *genl_info_net(struct genl_info *info ) 
47899c48411
<   __u16 tmp ;
---
>   struct net *tmp ;
47902,47904c48414,48416
< #line 9
<   tmp = __le16_to_cpup((__le16 const   *)p);
< #line 9
---
> #line 91
>   tmp = read_pnet((struct net * const  *)(& info->_net));
> #line 91
47908,47909c48420,48432
< #line 12 "include/linux/unaligned/access_ok.h"
< __inline static u32 get_unaligned_le32(void const   *p ) 
---
> #line 124
> extern int genl_register_family_with_ops(struct genl_family * , struct genl_ops * ,
>                                          size_t  ) ;
> #line 126
> extern int genl_unregister_family(struct genl_family * ) ;
> #line 129
> extern int genl_register_mc_group(struct genl_family * , struct genl_multicast_group * ) ;
> #line 136
> extern void *genlmsg_put(struct sk_buff * , u32  , u32  , struct genl_family * , int  ,
>                          u8  ) ;
> #line 181 "include/net/genetlink.h"
> __inline static void *genlmsg_put_reply(struct sk_buff *skb , struct genl_info *info ,
>                                         struct genl_family *family , int flags , u8 cmd ) 
47911c48434
<   __u32 tmp ;
---
>   void *tmp ;
47914,47916c48437,48439
< #line 14
<   tmp = __le32_to_cpup((__le32 const   *)p);
< #line 14
---
> #line 186
>   tmp = genlmsg_put(skb, info->snd_portid, info->snd_seq, family, flags, (int )cmd);
> #line 186
47920,47921c48443,48444
< #line 17 "include/linux/unaligned/access_ok.h"
< __inline static u64 get_unaligned_le64(void const   *p ) 
---
> #line 195 "include/net/genetlink.h"
> __inline static int genlmsg_end(struct sk_buff *skb , void *hdr ) 
47923c48446
<   __u64 tmp ;
---
>   int tmp ;
47926,47928c48449,48451
< #line 19
<   tmp = __le64_to_cpup((__le64 const   *)p);
< #line 19
---
> #line 197
>   tmp = nlmsg_end(skb, (struct nlmsghdr *)hdr + 0xffffffffffffffecUL);
> #line 197
47932,47933c48455,48456
< #line 37 "include/linux/unaligned/access_ok.h"
< __inline static void put_unaligned_le16(u16 val , void *p ) 
---
> #line 205 "include/net/genetlink.h"
> __inline static void genlmsg_cancel(struct sk_buff *skb , void *hdr ) 
47938,47940c48461,48468
< #line 39
<   *((__le16 *)p) = val;
< #line 40
---
> #line 207
>   if ((unsigned long )hdr != (unsigned long )((void *)0)) {
> #line 208
>     nlmsg_cancel(skb, (struct nlmsghdr *)hdr + 0xffffffffffffffecUL);
>   } else {
> 
>   }
> #line 209
47944,47945c48472,48487
< #line 42 "include/linux/unaligned/access_ok.h"
< __inline static void put_unaligned_le32(u32 val , void *p ) 
---
> #line 219 "include/net/genetlink.h"
> __inline static int genlmsg_multicast_netns(struct net *net , struct sk_buff *skb ,
>                                             u32 portid , unsigned int group , gfp_t flags ) 
> { 
>   int tmp ;
> 
>   {
> #line 222
>   tmp = nlmsg_multicast(net->genl_sock, skb, portid, group, flags);
> #line 222
>   return (tmp);
> }
> }
> #line 232 "include/net/genetlink.h"
> __inline static int genlmsg_multicast(struct sk_buff *skb , u32 portid , unsigned int group ,
>                                       gfp_t flags ) 
47946a48489
>   int tmp ;
47947a48491,48501
>   {
> #line 235
>   tmp = genlmsg_multicast_netns(& init_net, skb, portid, group, flags);
> #line 235
>   return (tmp);
> }
> }
> #line 255 "include/net/genetlink.h"
> __inline static int genlmsg_unicast(struct net *net , struct sk_buff *skb , u32 portid ) 
> { 
>   int tmp ;
47950,47953c48504,48522
< #line 44
<   *((__le32 *)p) = val;
< #line 45
<   return;
---
> #line 257
>   tmp = nlmsg_unicast(net->genl_sock, skb, portid);
> #line 257
>   return (tmp);
> }
> }
> #line 265 "include/net/genetlink.h"
> __inline static int genlmsg_reply(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct net *tmp ;
>   int tmp___0 ;
> 
>   {
> #line 267
>   tmp = genl_info_net(info);
> #line 267
>   tmp___0 = genlmsg_unicast(tmp, skb, info->snd_portid);
> #line 267
>   return (tmp___0);
47956,47957c48525,48526
< #line 47 "include/linux/unaligned/access_ok.h"
< __inline static void put_unaligned_le64(u64 val , void *p ) 
---
> #line 274 "include/net/genetlink.h"
> __inline static void *genlmsg_data(struct genlmsghdr  const  *gnlh ) 
47962,47965c48531,48532
< #line 49
<   *((__le64 *)p) = val;
< #line 50
<   return;
---
> #line 276
>   return ((void *)gnlh + 4U);
47968,48083c48535,48538
< #line 8 "include/linux/unaligned/generic.h"
< extern void __bad_unaligned_access_size(void) ;
< #line 76 "include/linux/drbd_tag_magic.h"
< static struct tag  const  tag_descriptions[91U]  = 
< #line 76 "include/linux/drbd_tag_magic.h"
<   {      {0, 0, 0}, 
<         {"primary_force", 32768, 4}, 
<         {"disk_size", 16384, 8}, 
<         {"backing_dev", 57344, 128}, 
<         {"meta_dev", 57344, 128}, 
<         {"meta_dev_idx", 8192, 4}, 
<         {"on_io_error", 0, 4}, 
<         {"fencing", 0, 4}, 
<         {"my_addr", 57344, 128}, 
<         {"peer_addr", 57344, 128}, 
<         {"shared_secret", 49152, 64}, 
<         {"cram_hmac_alg", 49152, 64}, 
<         {0, 0, 0}, 
<         {0, 0, 0}, 
<         {"timeout", 0, 4}, 
<         {"wire_protocol", 8192, 4}, 
<         {"try_connect_int", 0, 4}, 
<         {"ping_int", 0, 4}, 
<         {"max_epoch_size", 0, 4}, 
<         {"max_buffers", 0, 4}, 
<         {"unplug_watermark", 0, 4}, 
<         {"sndbuf_size", 0, 4}, 
<         {"ko_count", 0, 4}, 
<         {0, 0, 0}, 
<         {"after_sb_0p", 0, 4}, 
<         {"after_sb_1p", 0, 4}, 
<         {"after_sb_2p", 0, 4}, 
<         {"want_lose", 32768, 4}, 
<         {"two_primaries", 32768, 4}, 
<         {"resize_size", 16384, 8}, 
<         {"rate", 0, 4}, 
<         {"after", 0, 4}, 
<         {"al_extents", 0, 4}, 
<         {"state_i", 0, 4}, 
<         {"uuids", 49152, 32}, 
<         {"uuids_flags", 0, 4}, 
<         {"use_degraded", 32768, 4}, 
<         {"use_bmbv", 32768, 4}, 
<         {"helper", 49152, 32}, 
<         {"rr_conflict", 0, 4}, 
<         {"ping_timeo", 0, 4}, 
<         {"always_asbp", 32768, 4}, 
<         {0, 0, 0}, 
<         {"sync_progress", 0, 4}, 
<         {"integrity_alg", 49152, 64}, 
<         {"dump_ee_reason", 49152, 32}, 
<         {"seen_digest", 49152, 64}, 
<         {"calc_digest", 49152, 64}, 
<         {"ee_sector", 16384, 8}, 
<         {"ee_block_id", 16384, 8}, 
<         {"ee_data", 49152, 32768}, 
<         {"cpu_mask", 49152, 32}, 
<         {"verify_alg", 49152, 64}, 
<         {"no_disk_flush", 32768, 4}, 
<         {"no_md_flush", 32768, 4}, 
<         {0, 0, 0}, 
<         {"max_bio_bvecs", 0, 4}, 
<         {"no_disk_barrier", 32768, 4}, 
<         {"no_disk_drain", 32768, 4}, 
<         {0, 0, 0}, 
<         {"mind_af", 40960, 4}, 
<         {"no_cork", 32768, 4}, 
<         {"auto_sndbuf_size", 40960, 4}, 
<         {"clear_bm", 40960, 4}, 
<         {"csums_alg", 49152, 64}, 
<         {"use_rle", 32768, 4}, 
<         {"start_sector", 16384, 8}, 
<         {"rcvbuf_size", 0, 4}, 
<         {"resize_force", 32768, 4}, 
<         {"no_resync", 40960, 4}, 
<         {"dry_run", 40960, 4}, 
<         {0, 0, 0}, 
<         {0, 0, 0}, 
<         {0, 0, 0}, 
<         {0, 0, 0}, 
<         {"on_no_data", 0, 4}, 
<         {"c_plan_ahead", 0, 4}, 
<         {"c_delay_target", 0, 4}, 
<         {"c_fill_target", 0, 4}, 
<         {"c_max_rate", 0, 4}, 
<         {"c_min_rate", 0, 4}, 
<         {"on_congestion", 0, 4}, 
<         {"cong_fill", 0, 4}, 
<         {"cong_extents", 0, 4}, 
<         {"force", 32768, 4}, 
<         {0, 0, 0}, 
<         {0, 0, 0}, 
<         {0, 0, 0}, 
<         {"detach_force", 40960, 4}, 
<         {"disk_timeout", 0, 4}, 
<         {"stop_sector", 24576, 8}};
< #line 52 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static unsigned short *tl_add_blob(unsigned short *tl , enum drbd_tags tag , void const   *data ,
<                                    int len ) ;
< #line 53
< static unsigned short *tl_add_str(unsigned short *tl , enum drbd_tags tag , char const   *str ) ;
< #line 54
< static unsigned short *tl_add_int(unsigned short *tl , enum drbd_tags tag , void const   *val ) ;
< #line 57 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static char *drbd_m_holder  =    (char *)"Hands off! this is DRBD\'s meta data device.";
< #line 16 "include/linux/drbd_nl.h"
< static int primary_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct primary *arg ) ;
< #line 16 "include/linux/drbd_nl.h"
< static int primary_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct primary *arg ) 
< { 
<   int tag ;
<   int dlen ;
<   unsigned short *tmp ;
<   u16 tmp___0 ;
<   unsigned short *tmp___1 ;
<   u16 tmp___2 ;
---
> #line 294 "include/net/genetlink.h"
> __inline static int genlmsg_msg_size(int payload ) 
> { 
> 
48086,48111c48541,48762
< #line 14
<   goto ldv_51787;
<   ldv_51786: 
< #line 14
<   tmp = tags;
< #line 14
<   tags = tags + 1;
< #line 14
<   tmp___0 = get_unaligned_le16((void const   *)tmp);
< #line 14
<   dlen = (int )tmp___0;
< #line 14
<   switch (tag & 8191) {
<   case 1: 
< #line 14
<   arg->primary_force = (int )((signed char )*((char *)tags)) != 0;
< #line 14
<   goto ldv_51784;
<   default: ;
< #line 14
<   if ((tag & 8192) != 0) {
< #line 14
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Unknown tag: %d\n",
<             tag & 8191);
< #line 14
<     return (0);
---
> #line 296
>   return ((int )((unsigned int )payload + 4U));
> }
> }
> #line 303 "include/net/genetlink.h"
> __inline static int genlmsg_total_size(int payload ) 
> { 
>   int tmp ;
> 
>   {
> #line 305
>   tmp = genlmsg_msg_size(payload);
> #line 305
>   return ((int )((unsigned int )tmp + 3U) & -4);
> }
> }
> #line 313 "include/net/genetlink.h"
> __inline static struct sk_buff *genlmsg_new(size_t payload , gfp_t flags ) 
> { 
>   int tmp ;
>   struct sk_buff *tmp___0 ;
> 
>   {
> #line 315
>   tmp = genlmsg_total_size((int )payload);
> #line 315
>   tmp___0 = nlmsg_new((size_t )tmp, flags);
> #line 315
>   return (tmp___0);
> }
> }
> #line 54 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_add_minor(struct sk_buff *skb , struct genl_info *info ) ;
> #line 55
> int drbd_adm_delete_minor(struct sk_buff *skb , struct genl_info *info ) ;
> #line 57
> int drbd_adm_new_resource(struct sk_buff *skb , struct genl_info *info ) ;
> #line 58
> int drbd_adm_del_resource(struct sk_buff *skb , struct genl_info *info ) ;
> #line 59
> int drbd_adm_down(struct sk_buff *skb , struct genl_info *info ) ;
> #line 61
> int drbd_adm_set_role(struct sk_buff *skb , struct genl_info *info ) ;
> #line 62
> int drbd_adm_attach(struct sk_buff *skb , struct genl_info *info ) ;
> #line 63
> int drbd_adm_disk_opts(struct sk_buff *skb , struct genl_info *info ) ;
> #line 64
> int drbd_adm_detach(struct sk_buff *skb , struct genl_info *info ) ;
> #line 65
> int drbd_adm_connect(struct sk_buff *skb , struct genl_info *info ) ;
> #line 66
> int drbd_adm_net_opts(struct sk_buff *skb , struct genl_info *info ) ;
> #line 67
> int drbd_adm_resize(struct sk_buff *skb , struct genl_info *info ) ;
> #line 68
> int drbd_adm_start_ov(struct sk_buff *skb , struct genl_info *info ) ;
> #line 69
> int drbd_adm_new_c_uuid(struct sk_buff *skb , struct genl_info *info ) ;
> #line 70
> int drbd_adm_disconnect(struct sk_buff *skb , struct genl_info *info ) ;
> #line 71
> int drbd_adm_invalidate(struct sk_buff *skb , struct genl_info *info ) ;
> #line 72
> int drbd_adm_invalidate_peer(struct sk_buff *skb , struct genl_info *info ) ;
> #line 73
> int drbd_adm_pause_sync(struct sk_buff *skb , struct genl_info *info ) ;
> #line 74
> int drbd_adm_resume_sync(struct sk_buff *skb , struct genl_info *info ) ;
> #line 75
> int drbd_adm_suspend_io(struct sk_buff *skb , struct genl_info *info ) ;
> #line 76
> int drbd_adm_resume_io(struct sk_buff *skb , struct genl_info *info ) ;
> #line 77
> int drbd_adm_outdate(struct sk_buff *skb , struct genl_info *info ) ;
> #line 78
> int drbd_adm_resource_opts(struct sk_buff *skb , struct genl_info *info ) ;
> #line 79
> int drbd_adm_get_status(struct sk_buff *skb , struct genl_info *info ) ;
> #line 80
> int drbd_adm_get_timeout_type(struct sk_buff *skb , struct genl_info *info ) ;
> #line 82
> int drbd_adm_get_status_all(struct sk_buff *skb , struct netlink_callback *cb ) ;
> #line 4 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_nla.h"
> int drbd_nla_parse_nested(struct nlattr **tb , int maxtype , struct nlattr *nla ,
>                           struct nla_policy  const  *policy ) ;
> #line 6
> struct nlattr *drbd_nla_find_nested(int maxtype , struct nlattr *nla , int attrtype ) ;
> #line 24 "include/linux/genl_magic_func.h"
> static struct nla_policy drbd_tla_nl_policy[14U]  = 
> #line 24 "include/linux/genl_magic_func.h"
>   {      {(unsigned short)0, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}, 
>         {8U, (unsigned short)0}};
> #line 102 "include/linux/drbd_genl.h"
> static struct nla_policy drbd_cfg_context_nl_policy[5U]  = {      {(unsigned short)0, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {10U, 127U}, 
>         {11U, 128U}, 
>         {11U, 128U}};
> #line 135 "include/linux/drbd_genl.h"
> static struct nla_policy disk_conf_nl_policy[24U]  = 
> #line 135
>   {      {(unsigned short)0, (unsigned short)0}, 
>         {10U, 127U}, 
>         {10U, 127U}, 
>         {3U, (unsigned short)0}, 
>         {4U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {1U, (unsigned short)0}, 
>         {1U, (unsigned short)0}, 
>         {1U, (unsigned short)0}, 
>         {1U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {(unsigned short)0, (unsigned short)0}, 
>         {1U, (unsigned short)0}};
> #line 140 "include/linux/drbd_genl.h"
> static struct nla_policy res_opts_nl_policy[3U]  = {      {(unsigned short)0, (unsigned short)0}, 
>         {10U, 31U}, 
>         {3U, (unsigned short)0}};
> #line 174 "include/linux/drbd_genl.h"
> static struct nla_policy net_conf_nl_policy[30U]  = 
> #line 174
>   {      {(unsigned short)0, (unsigned short)0}, 
>         {10U, 63U}, 
>         {10U, 63U}, 
>         {10U, 63U}, 
>         {10U, 63U}, 
>         {10U, 63U}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {3U, (unsigned short)0}, 
>         {1U, (unsigned short)0}, 
>         {1U, (unsigned short)0}, 
>         {1U, (unsigned short)0}, 
>         {1U, (unsigned short)0}, 
>         {1U, (unsigned short)0}, 
>         {1U, (unsigned short)0}};
> #line 178 "include/linux/drbd_genl.h"
> static struct nla_policy set_role_parms_nl_policy[2U]  = {      {(unsigned short)0, (unsigned short)0}, 
>         {1U, (unsigned short)0}};
> #line 184 "include/linux/drbd_genl.h"
> static struct nla_policy resize_parms_nl_policy[4U]  = {      {(unsigned short)0, (unsigned short)0}, 
>         {4U, (unsigned short)0}, 
>         {1U, (unsigned short)0}, 
>         {1U, (unsigned short)0}};
> #line 229 "include/linux/drbd_genl.h"
> static struct nla_policy start_ov_parms_nl_policy[3U]  = {      {(unsigned short)0, (unsigned short)0}, 
>         {4U, (unsigned short)0}, 
>         {4U, (unsigned short)0}};
> #line 233 "include/linux/drbd_genl.h"
> static struct nla_policy new_c_uuid_parms_nl_policy[2U]  = {      {(unsigned short)0, (unsigned short)0}, 
>         {1U, (unsigned short)0}};
> #line 241 "include/linux/drbd_genl.h"
> static struct nla_policy disconnect_parms_nl_policy[2U]  = {      {(unsigned short)0, (unsigned short)0}, 
>         {1U, (unsigned short)0}};
> #line 245 "include/linux/drbd_genl.h"
> static struct nla_policy detach_parms_nl_policy[2U]  = {      {(unsigned short)0, (unsigned short)0}, 
>         {1U, (unsigned short)0}};
> #line 132 "include/linux/genl_magic_func.h"
> static struct nlattr *nested_attr_tb[128U]  ;
> #line 102 "include/linux/drbd_genl.h"
> static int __drbd_cfg_context_from_attrs(struct drbd_cfg_context *s , struct genl_info *info ,
>                                          bool exclude_invariants ) 
> { 
>   int maxtype ;
>   struct nlattr *tla ;
>   struct nlattr **ntb ;
>   struct nlattr *nla ;
>   int err ;
>   size_t tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
> 
>   {
> #line 97
>   maxtype = 4;
> #line 97
>   tla = *(info->attrs + 2UL);
> #line 97
>   ntb = (struct nlattr **)(& nested_attr_tb);
> #line 97
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 97
>     return (-42);
48114a48766,48773
> #line 97
>   err = drbd_nla_parse_nested(ntb, maxtype, tla, (struct nla_policy  const  *)(& drbd_cfg_context_nl_policy));
> #line 97
>   if (err != 0) {
> #line 97
>     return (err);
>   } else {
> 
48116,48131c48775,48785
<   ldv_51784: 
< #line 14
<   tags = tags + (unsigned long )dlen;
<   ldv_51787: 
< #line 14
<   tmp___1 = tags;
< #line 14
<   tags = tags + 1;
< #line 14
<   tmp___2 = get_unaligned_le16((void const   *)tmp___1);
< #line 14
<   tag = (int )tmp___2;
< #line 14
<   if (tag != 0) {
< #line 15
<     goto ldv_51786;
---
> #line 97
>   nla = *(ntb + 1UL);
> #line 97
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 97
>     if ((unsigned long )s != (unsigned long )((struct drbd_cfg_context *)0)) {
> #line 97
>       s->ctx_volume = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
48134a48789,48800
> #line 97
>   nla = *(ntb + 2UL);
> #line 97
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 97
>     if ((unsigned long )s != (unsigned long )((struct drbd_cfg_context *)0)) {
> #line 97
>       tmp = nla_strlcpy((char *)(& s->ctx_resource_name), (struct nlattr  const  *)nla,
>                         128UL);
> #line 97
>       s->ctx_resource_name_len = (__u32 )tmp;
>     } else {
48136,48137c48802,48841
< #line 14
<   return (1);
---
>     }
>   } else {
> 
>   }
> #line 97
>   nla = *(ntb + 3UL);
> #line 97
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 97
>     if ((unsigned long )s != (unsigned long )((struct drbd_cfg_context *)0)) {
> #line 97
>       tmp___0 = nla_memcpy((void *)(& s->ctx_my_addr), (struct nlattr  const  *)nla,
>                            128);
> #line 97
>       s->ctx_my_addr_len = (__u32 )tmp___0;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 97
>   nla = *(ntb + 4UL);
> #line 97
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 97
>     if ((unsigned long )s != (unsigned long )((struct drbd_cfg_context *)0)) {
> #line 97
>       tmp___1 = nla_memcpy((void *)(& s->ctx_peer_addr), (struct nlattr  const  *)nla,
>                            128);
> #line 97
>       s->ctx_peer_addr_len = (__u32 )tmp___1;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 97
>   return (0);
48140,48156c48844,48865
< #line 35
< static int disk_conf_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct disk_conf *arg ) ;
< #line 35 "include/linux/drbd_nl.h"
< static int disk_conf_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct disk_conf *arg ) 
< { 
<   int tag ;
<   int dlen ;
<   unsigned short *tmp ;
<   u16 tmp___0 ;
<   size_t __len ;
<   size_t __min1 ;
<   size_t __min2 ;
<   void *__ret ;
<   size_t __len___0 ;
<   size_t __min1___0 ;
<   size_t __min2___0 ;
<   void *__ret___0 ;
---
> #line 102 "include/linux/drbd_genl.h"
> static int drbd_cfg_context_from_attrs(struct drbd_cfg_context *s , struct genl_info *info ) 
> { 
>   int tmp ;
> 
>   {
> #line 97
>   tmp = __drbd_cfg_context_from_attrs(s, info, 0);
> #line 97
>   return (tmp);
> }
> }
> #line 135 "include/linux/drbd_genl.h"
> static int __disk_conf_from_attrs(struct disk_conf *s , struct genl_info *info , bool exclude_invariants ) 
> { 
>   int maxtype ;
>   struct nlattr *tla ;
>   struct nlattr **ntb ;
>   struct nlattr *nla ;
>   int err ;
>   size_t tmp ;
>   size_t tmp___0 ;
48159,48163c48868,48872
<   u32 tmp___3 ;
<   u32 tmp___4 ;
<   u32 tmp___5 ;
<   unsigned short *tmp___6 ;
<   u16 tmp___7 ;
---
>   u8 tmp___3 ;
>   u8 tmp___4 ;
>   u8 tmp___5 ;
>   u8 tmp___6 ;
>   u8 tmp___7 ;
48166,48191c48875,48884
< #line 20
<   goto ldv_51849;
<   ldv_51848: 
< #line 20
<   tmp = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   tmp___0 = get_unaligned_le16((void const   *)tmp);
< #line 20
<   dlen = (int )tmp___0;
< #line 20
<   switch (tag & 8191) {
<   case 2: 
< #line 20
<   arg->disk_size = get_unaligned_le64((void const   *)tags);
< #line 20
<   goto ldv_51816;
<   case 3: ;
< #line 20
<   if (dlen > 128) {
< #line 20
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "arg too long: %s (%u wanted, max len: %u bytes)\n",
<             (char *)"backing_dev", dlen, 128U);
< #line 20
<     return (0);
---
> #line 104
>   maxtype = 23;
> #line 104
>   tla = *(info->attrs + 3UL);
> #line 104
>   ntb = (struct nlattr **)(& nested_attr_tb);
> #line 104
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 104
>     return (-42);
48195,48214c48888,48893
< #line 20
<   arg->backing_dev_len = dlen;
< #line 20
<   __min1 = (size_t )dlen;
< #line 20
<   __min2 = 128UL;
< #line 20
<   __len = __min1 < __min2 ? __min1 : __min2;
< #line 20
<   __ret = __builtin_memcpy((void *)(& arg->backing_dev), (void const   *)tags, __len);
< #line 20
<   goto ldv_51816;
<   case 4: ;
< #line 20
<   if (dlen > 128) {
< #line 20
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "arg too long: %s (%u wanted, max len: %u bytes)\n",
<             (char *)"meta_dev", dlen, 128U);
< #line 20
<     return (0);
---
> #line 104
>   err = drbd_nla_parse_nested(ntb, maxtype, tla, (struct nla_policy  const  *)(& disk_conf_nl_policy));
> #line 104
>   if (err != 0) {
> #line 104
>     return (err);
48218,48297c48897,49014
< #line 20
<   arg->meta_dev_len = dlen;
< #line 20
<   __min1___0 = (size_t )dlen;
< #line 20
<   __min2___0 = 128UL;
< #line 20
<   __len___0 = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
< #line 20
<   __ret___0 = __builtin_memcpy((void *)(& arg->meta_dev), (void const   *)tags, __len___0);
< #line 20
<   goto ldv_51816;
<   case 5: 
< #line 20
<   tmp___1 = get_unaligned_le32((void const   *)tags);
< #line 20
<   arg->meta_dev_idx = (int )tmp___1;
< #line 20
<   goto ldv_51816;
<   case 6: 
< #line 20
<   tmp___2 = get_unaligned_le32((void const   *)tags);
< #line 20
<   arg->on_io_error = (int )tmp___2;
< #line 20
<   goto ldv_51816;
<   case 7: 
< #line 20
<   tmp___3 = get_unaligned_le32((void const   *)tags);
< #line 20
<   arg->fencing = (int )tmp___3;
< #line 20
<   goto ldv_51816;
<   case 37: 
< #line 20
<   arg->use_bmbv = (int )((signed char )*((char *)tags)) != 0;
< #line 20
<   goto ldv_51816;
<   case 53: 
< #line 20
<   arg->no_disk_flush = (int )((signed char )*((char *)tags)) != 0;
< #line 20
<   goto ldv_51816;
<   case 54: 
< #line 20
<   arg->no_md_flush = (int )((signed char )*((char *)tags)) != 0;
< #line 20
<   goto ldv_51816;
<   case 56: 
< #line 20
<   tmp___4 = get_unaligned_le32((void const   *)tags);
< #line 20
<   arg->max_bio_bvecs = (int )tmp___4;
< #line 20
<   goto ldv_51816;
<   case 57: 
< #line 20
<   arg->no_disk_barrier = (int )((signed char )*((char *)tags)) != 0;
< #line 20
<   goto ldv_51816;
<   case 58: 
< #line 20
<   arg->no_disk_drain = (int )((signed char )*((char *)tags)) != 0;
< #line 20
<   goto ldv_51816;
<   case 89: 
< #line 20
<   tmp___5 = get_unaligned_le32((void const   *)tags);
< #line 20
<   arg->disk_timeout = (int )tmp___5;
< #line 20
<   goto ldv_51816;
<   default: ;
< #line 20
<   if ((tag & 8192) != 0) {
< #line 20
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Unknown tag: %d\n",
<             tag & 8191);
< #line 20
<     return (0);
---
> #line 104
>   nla = *(ntb + 1UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((int )exclude_invariants) {
> #line 104
>       printk("\016<< must not change invariant attr: %s\n", (char *)"backing_dev");
> #line 104
>       return (-17);
>     } else {
> 
>     }
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       tmp = nla_strlcpy((char *)(& s->backing_dev), (struct nlattr  const  *)nla,
>                         128UL);
> #line 104
>       s->backing_dev_len = (__u32 )tmp;
>     } else {
> 
>     }
>   } else
> #line 104
>   if ((int )exclude_invariants) {
> 
>   } else {
> #line 104
>     printk("\016<< missing attr: %s\n", (char *)"backing_dev");
> #line 104
>     return (-42);
>   }
> #line 104
>   nla = *(ntb + 2UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((int )exclude_invariants) {
> #line 104
>       printk("\016<< must not change invariant attr: %s\n", (char *)"meta_dev");
> #line 104
>       return (-17);
>     } else {
> 
>     }
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       tmp___0 = nla_strlcpy((char *)(& s->meta_dev), (struct nlattr  const  *)nla,
>                             128UL);
> #line 104
>       s->meta_dev_len = (__u32 )tmp___0;
>     } else {
> 
>     }
>   } else
> #line 104
>   if ((int )exclude_invariants) {
> 
>   } else {
> #line 104
>     printk("\016<< missing attr: %s\n", (char *)"meta_dev");
> #line 104
>     return (-42);
>   }
> #line 104
>   nla = *(ntb + 3UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((int )exclude_invariants) {
> #line 104
>       printk("\016<< must not change invariant attr: %s\n", (char *)"meta_dev_idx");
> #line 104
>       return (-17);
>     } else {
> 
>     }
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       tmp___1 = nla_get_u32((struct nlattr  const  *)nla);
> #line 104
>       s->meta_dev_idx = (__s32 )tmp___1;
>     } else {
> 
>     }
>   } else
> #line 104
>   if ((int )exclude_invariants) {
> 
>   } else {
> #line 104
>     printk("\016<< missing attr: %s\n", (char *)"meta_dev_idx");
> #line 104
>     return (-42);
>   }
> #line 104
>   nla = *(ntb + 4UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((int )exclude_invariants) {
> #line 104
>       printk("\016<< must not change invariant attr: %s\n", (char *)"disk_size");
> #line 104
>       return (-17);
>     } else {
> 
>     }
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->disk_size = nla_get_u64((struct nlattr  const  *)nla);
>     } else {
> 
>     }
48300a49018,49039
> #line 104
>   nla = *(ntb + 5UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((int )exclude_invariants) {
> #line 104
>       printk("\016<< must not change invariant attr: %s\n", (char *)"max_bio_bvecs");
> #line 104
>       return (-17);
>     } else {
> 
>     }
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->max_bio_bvecs = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
48302,48317c49041,49051
<   ldv_51816: 
< #line 20
<   tags = tags + (unsigned long )dlen;
<   ldv_51849: 
< #line 20
<   tmp___6 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   tmp___7 = get_unaligned_le16((void const   *)tmp___6);
< #line 20
<   tag = (int )tmp___7;
< #line 20
<   if (tag != 0) {
< #line 21
<     goto ldv_51848;
---
> #line 104
>   nla = *(ntb + 6UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->on_io_error = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
48320a49055,49063
> #line 104
>   nla = *(ntb + 7UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->fencing = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
48322,48323c49065,49292
< #line 20
<   return (1);
---
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 8UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->resync_rate = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 9UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       tmp___2 = nla_get_u32((struct nlattr  const  *)nla);
> #line 104
>       s->resync_after = (__s32 )tmp___2;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 10UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->al_extents = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 11UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->c_plan_ahead = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 12UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->c_delay_target = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 13UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->c_fill_target = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 14UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->c_max_rate = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 15UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->c_min_rate = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 16UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       tmp___3 = nla_get_u8((struct nlattr  const  *)nla);
> #line 104
>       s->disk_barrier = (char )tmp___3;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 17UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       tmp___4 = nla_get_u8((struct nlattr  const  *)nla);
> #line 104
>       s->disk_flushes = (char )tmp___4;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 18UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       tmp___5 = nla_get_u8((struct nlattr  const  *)nla);
> #line 104
>       s->disk_drain = (char )tmp___5;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 19UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       tmp___6 = nla_get_u8((struct nlattr  const  *)nla);
> #line 104
>       s->md_flushes = (char )tmp___6;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 20UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->disk_timeout = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 21UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       s->read_balancing = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   nla = *(ntb + 23UL);
> #line 104
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     if ((unsigned long )s != (unsigned long )((struct disk_conf *)0)) {
> #line 104
>       tmp___7 = nla_get_u8((struct nlattr  const  *)nla);
> #line 104
>       s->al_updates = (char )tmp___7;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 104
>   return (0);
48326,48336c49295,49298
< #line 39
< static int detach_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct detach *arg ) ;
< #line 39 "include/linux/drbd_nl.h"
< static int detach_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct detach *arg ) 
< { 
<   int tag ;
<   int dlen ;
<   unsigned short *tmp ;
<   u16 tmp___0 ;
<   unsigned short *tmp___1 ;
<   u16 tmp___2 ;
---
> #line 135 "include/linux/drbd_genl.h"
> static int disk_conf_from_attrs(struct disk_conf *s , struct genl_info *info ) 
> { 
>   int tmp ;
48339,48364c49301,49339
< #line 37
<   goto ldv_51866;
<   ldv_51865: 
< #line 37
<   tmp = tags;
< #line 37
<   tags = tags + 1;
< #line 37
<   tmp___0 = get_unaligned_le16((void const   *)tmp);
< #line 37
<   dlen = (int )tmp___0;
< #line 37
<   switch (tag & 8191) {
<   case 88: 
< #line 37
<   arg->detach_force = (int )((signed char )*((char *)tags)) != 0;
< #line 37
<   goto ldv_51863;
<   default: ;
< #line 37
<   if ((tag & 8192) != 0) {
< #line 37
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Unknown tag: %d\n",
<             tag & 8191);
< #line 37
<     return (0);
---
> #line 104
>   tmp = __disk_conf_from_attrs(s, info, 0);
> #line 104
>   return (tmp);
> }
> }
> #line 135 "include/linux/drbd_genl.h"
> static int disk_conf_from_attrs_for_change(struct disk_conf *s , struct genl_info *info ) 
> { 
>   int tmp ;
> 
>   {
> #line 104
>   tmp = __disk_conf_from_attrs(s, info, 1);
> #line 104
>   return (tmp);
> }
> }
> #line 140 "include/linux/drbd_genl.h"
> static int __res_opts_from_attrs(struct res_opts *s , struct genl_info *info , bool exclude_invariants ) 
> { 
>   int maxtype ;
>   struct nlattr *tla ;
>   struct nlattr **ntb ;
>   struct nlattr *nla ;
>   int err ;
>   size_t tmp ;
> 
>   {
> #line 137
>   maxtype = 2;
> #line 137
>   tla = *(info->attrs + 4UL);
> #line 137
>   ntb = (struct nlattr **)(& nested_attr_tb);
> #line 137
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 137
>     return (-42);
48367a49343,49350
> #line 137
>   err = drbd_nla_parse_nested(ntb, maxtype, tla, (struct nla_policy  const  *)(& res_opts_nl_policy));
> #line 137
>   if (err != 0) {
> #line 137
>     return (err);
>   } else {
> 
48369,48384c49352,49364
<   ldv_51863: 
< #line 37
<   tags = tags + (unsigned long )dlen;
<   ldv_51866: 
< #line 37
<   tmp___1 = tags;
< #line 37
<   tags = tags + 1;
< #line 37
<   tmp___2 = get_unaligned_le16((void const   *)tmp___1);
< #line 37
<   tag = (int )tmp___2;
< #line 37
<   if (tag != 0) {
< #line 38
<     goto ldv_51865;
---
> #line 137
>   nla = *(ntb + 1UL);
> #line 137
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 137
>     if ((unsigned long )s != (unsigned long )((struct res_opts *)0)) {
> #line 137
>       tmp = nla_strlcpy((char *)(& s->cpu_mask), (struct nlattr  const  *)nla, 32UL);
> #line 137
>       s->cpu_mask_len = (__u32 )tmp;
>     } else {
> 
>     }
48387a49368,49376
> #line 137
>   nla = *(ntb + 2UL);
> #line 137
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 137
>     if ((unsigned long )s != (unsigned long )((struct res_opts *)0)) {
> #line 137
>       s->on_no_data = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
48389,48390c49378,49383
< #line 37
<   return (1);
---
>     }
>   } else {
> 
>   }
> #line 137
>   return (0);
48393,48441c49386,49389
< #line 73
< static int net_conf_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct net_conf *arg ) ;
< #line 73 "include/linux/drbd_nl.h"
< static int net_conf_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct net_conf *arg ) 
< { 
<   int tag ;
<   int dlen ;
<   unsigned short *tmp ;
<   u16 tmp___0 ;
<   size_t __len ;
<   size_t __min1 ;
<   size_t __min2 ;
<   void *__ret ;
<   size_t __len___0 ;
<   size_t __min1___0 ;
<   size_t __min2___0 ;
<   void *__ret___0 ;
<   size_t __len___1 ;
<   size_t __min1___1 ;
<   size_t __min2___1 ;
<   void *__ret___1 ;
<   size_t __len___2 ;
<   size_t __min1___2 ;
<   size_t __min2___2 ;
<   void *__ret___2 ;
<   size_t __len___3 ;
<   size_t __min1___3 ;
<   size_t __min2___3 ;
<   void *__ret___3 ;
<   u32 tmp___1 ;
<   u32 tmp___2 ;
<   u32 tmp___3 ;
<   u32 tmp___4 ;
<   u32 tmp___5 ;
<   u32 tmp___6 ;
<   u32 tmp___7 ;
<   u32 tmp___8 ;
<   u32 tmp___9 ;
<   u32 tmp___10 ;
<   u32 tmp___11 ;
<   u32 tmp___12 ;
<   u32 tmp___13 ;
<   u32 tmp___14 ;
<   u32 tmp___15 ;
<   u32 tmp___16 ;
<   u32 tmp___17 ;
<   u32 tmp___18 ;
<   unsigned short *tmp___19 ;
<   u16 tmp___20 ;
---
> #line 140 "include/linux/drbd_genl.h"
> static int res_opts_from_attrs(struct res_opts *s , struct genl_info *info ) 
> { 
>   int tmp ;
48444,48464c49392,49428
< #line 41
<   goto ldv_51957;
<   ldv_51956: 
< #line 41
<   tmp = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   tmp___0 = get_unaligned_le16((void const   *)tmp);
< #line 41
<   dlen = (int )tmp___0;
< #line 41
<   switch (tag & 8191) {
<   case 8: ;
< #line 41
<   if (dlen > 128) {
< #line 41
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "arg too long: %s (%u wanted, max len: %u bytes)\n",
<             (char *)"my_addr", dlen, 128U);
< #line 41
<     return (0);
---
> #line 137
>   tmp = __res_opts_from_attrs(s, info, 0);
> #line 137
>   return (tmp);
> }
> }
> #line 174 "include/linux/drbd_genl.h"
> static int __net_conf_from_attrs(struct net_conf *s , struct genl_info *info , bool exclude_invariants ) 
> { 
>   int maxtype ;
>   struct nlattr *tla ;
>   struct nlattr **ntb ;
>   struct nlattr *nla ;
>   int err ;
>   size_t tmp ;
>   size_t tmp___0 ;
>   size_t tmp___1 ;
>   size_t tmp___2 ;
>   size_t tmp___3 ;
>   u8 tmp___4 ;
>   u8 tmp___5 ;
>   u8 tmp___6 ;
>   u8 tmp___7 ;
>   u8 tmp___8 ;
>   u8 tmp___9 ;
> 
>   {
> #line 142
>   maxtype = 29;
> #line 142
>   tla = *(info->attrs + 5UL);
> #line 142
>   ntb = (struct nlattr **)(& nested_attr_tb);
> #line 142
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 142
>     return (-42);
48468,48487c49432,49437
< #line 41
<   arg->my_addr_len = dlen;
< #line 41
<   __min1 = (size_t )dlen;
< #line 41
<   __min2 = 128UL;
< #line 41
<   __len = __min1 < __min2 ? __min1 : __min2;
< #line 41
<   __ret = __builtin_memcpy((void *)(& arg->my_addr), (void const   *)tags, __len);
< #line 41
<   goto ldv_51889;
<   case 9: ;
< #line 41
<   if (dlen > 128) {
< #line 41
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "arg too long: %s (%u wanted, max len: %u bytes)\n",
<             (char *)"peer_addr", dlen, 128U);
< #line 41
<     return (0);
---
> #line 142
>   err = drbd_nla_parse_nested(ntb, maxtype, tla, (struct nla_policy  const  *)(& net_conf_nl_policy));
> #line 142
>   if (err != 0) {
> #line 142
>     return (err);
48491,48510c49441,49454
< #line 41
<   arg->peer_addr_len = dlen;
< #line 41
<   __min1___0 = (size_t )dlen;
< #line 41
<   __min2___0 = 128UL;
< #line 41
<   __len___0 = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
< #line 41
<   __ret___0 = __builtin_memcpy((void *)(& arg->peer_addr), (void const   *)tags, __len___0);
< #line 41
<   goto ldv_51889;
<   case 10: ;
< #line 41
<   if (dlen > 64) {
< #line 41
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "arg too long: %s (%u wanted, max len: %u bytes)\n",
<             (char *)"shared_secret", dlen, 64U);
< #line 41
<     return (0);
---
> #line 142
>   nla = *(ntb + 1UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       tmp = nla_strlcpy((char *)(& s->shared_secret), (struct nlattr  const  *)nla,
>                         64UL);
> #line 142
>       s->shared_secret_len = (__u32 )tmp;
>     } else {
> 
>     }
48514,48534c49458,49471
< #line 41
<   arg->shared_secret_len = dlen;
< #line 41
<   __min1___1 = (size_t )dlen;
< #line 41
<   __min2___1 = 64UL;
< #line 41
<   __len___1 = __min1___1 < __min2___1 ? __min1___1 : __min2___1;
< #line 41
<   __ret___1 = __builtin_memcpy((void *)(& arg->shared_secret), (void const   *)tags,
<                                __len___1);
< #line 41
<   goto ldv_51889;
<   case 11: ;
< #line 41
<   if (dlen > 64) {
< #line 41
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "arg too long: %s (%u wanted, max len: %u bytes)\n",
<             (char *)"cram_hmac_alg", dlen, 64U);
< #line 41
<     return (0);
---
> #line 142
>   nla = *(ntb + 2UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       tmp___0 = nla_strlcpy((char *)(& s->cram_hmac_alg), (struct nlattr  const  *)nla,
>                             64UL);
> #line 142
>       s->cram_hmac_alg_len = (__u32 )tmp___0;
>     } else {
> 
>     }
48538,48558c49475,49488
< #line 41
<   arg->cram_hmac_alg_len = dlen;
< #line 41
<   __min1___2 = (size_t )dlen;
< #line 41
<   __min2___2 = 64UL;
< #line 41
<   __len___2 = __min1___2 < __min2___2 ? __min1___2 : __min2___2;
< #line 41
<   __ret___2 = __builtin_memcpy((void *)(& arg->cram_hmac_alg), (void const   *)tags,
<                                __len___2);
< #line 41
<   goto ldv_51889;
<   case 44: ;
< #line 41
<   if (dlen > 64) {
< #line 41
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "arg too long: %s (%u wanted, max len: %u bytes)\n",
<             (char *)"integrity_alg", dlen, 64U);
< #line 41
<     return (0);
---
> #line 142
>   nla = *(ntb + 3UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       tmp___1 = nla_strlcpy((char *)(& s->integrity_alg), (struct nlattr  const  *)nla,
>                             64UL);
> #line 142
>       s->integrity_alg_len = (__u32 )tmp___1;
>     } else {
> 
>     }
48562,48743c49492,49505
< #line 41
<   arg->integrity_alg_len = dlen;
< #line 41
<   __min1___3 = (size_t )dlen;
< #line 41
<   __min2___3 = 64UL;
< #line 41
<   __len___3 = __min1___3 < __min2___3 ? __min1___3 : __min2___3;
< #line 41
<   __ret___3 = __builtin_memcpy((void *)(& arg->integrity_alg), (void const   *)tags,
<                                __len___3);
< #line 41
<   goto ldv_51889;
<   case 14: 
< #line 41
<   tmp___1 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->timeout = (int )tmp___1;
< #line 41
<   goto ldv_51889;
<   case 15: 
< #line 41
<   tmp___2 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->wire_protocol = (int )tmp___2;
< #line 41
<   goto ldv_51889;
<   case 16: 
< #line 41
<   tmp___3 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->try_connect_int = (int )tmp___3;
< #line 41
<   goto ldv_51889;
<   case 17: 
< #line 41
<   tmp___4 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->ping_int = (int )tmp___4;
< #line 41
<   goto ldv_51889;
<   case 18: 
< #line 41
<   tmp___5 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->max_epoch_size = (int )tmp___5;
< #line 41
<   goto ldv_51889;
<   case 19: 
< #line 41
<   tmp___6 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->max_buffers = (int )tmp___6;
< #line 41
<   goto ldv_51889;
<   case 20: 
< #line 41
<   tmp___7 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->unplug_watermark = (int )tmp___7;
< #line 41
<   goto ldv_51889;
<   case 21: 
< #line 41
<   tmp___8 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->sndbuf_size = (int )tmp___8;
< #line 41
<   goto ldv_51889;
<   case 22: 
< #line 41
<   tmp___9 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->ko_count = (int )tmp___9;
< #line 41
<   goto ldv_51889;
<   case 24: 
< #line 41
<   tmp___10 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->after_sb_0p = (int )tmp___10;
< #line 41
<   goto ldv_51889;
<   case 25: 
< #line 41
<   tmp___11 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->after_sb_1p = (int )tmp___11;
< #line 41
<   goto ldv_51889;
<   case 26: 
< #line 41
<   tmp___12 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->after_sb_2p = (int )tmp___12;
< #line 41
<   goto ldv_51889;
<   case 39: 
< #line 41
<   tmp___13 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->rr_conflict = (int )tmp___13;
< #line 41
<   goto ldv_51889;
<   case 40: 
< #line 41
<   tmp___14 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->ping_timeo = (int )tmp___14;
< #line 41
<   goto ldv_51889;
<   case 67: 
< #line 41
<   tmp___15 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->rcvbuf_size = (int )tmp___15;
< #line 41
<   goto ldv_51889;
<   case 81: 
< #line 41
<   tmp___16 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->on_congestion = (int )tmp___16;
< #line 41
<   goto ldv_51889;
<   case 82: 
< #line 41
<   tmp___17 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->cong_fill = (int )tmp___17;
< #line 41
<   goto ldv_51889;
<   case 83: 
< #line 41
<   tmp___18 = get_unaligned_le32((void const   *)tags);
< #line 41
<   arg->cong_extents = (int )tmp___18;
< #line 41
<   goto ldv_51889;
<   case 60: 
< #line 41
<   arg->mind_af = (int )((signed char )*((char *)tags)) != 0;
< #line 41
<   goto ldv_51889;
<   case 27: 
< #line 41
<   arg->want_lose = (int )((signed char )*((char *)tags)) != 0;
< #line 41
<   goto ldv_51889;
<   case 28: 
< #line 41
<   arg->two_primaries = (int )((signed char )*((char *)tags)) != 0;
< #line 41
<   goto ldv_51889;
<   case 41: 
< #line 41
<   arg->always_asbp = (int )((signed char )*((char *)tags)) != 0;
< #line 41
<   goto ldv_51889;
<   case 61: 
< #line 41
<   arg->no_cork = (int )((signed char )*((char *)tags)) != 0;
< #line 41
<   goto ldv_51889;
<   case 62: 
< #line 41
<   arg->auto_sndbuf_size = (int )((signed char )*((char *)tags)) != 0;
< #line 41
<   goto ldv_51889;
<   case 70: 
< #line 41
<   arg->dry_run = (int )((signed char )*((char *)tags)) != 0;
< #line 41
<   goto ldv_51889;
<   default: ;
< #line 41
<   if ((tag & 8192) != 0) {
< #line 41
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Unknown tag: %d\n",
<             tag & 8191);
< #line 41
<     return (0);
---
> #line 142
>   nla = *(ntb + 4UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       tmp___2 = nla_strlcpy((char *)(& s->verify_alg), (struct nlattr  const  *)nla,
>                             64UL);
> #line 142
>       s->verify_alg_len = (__u32 )tmp___2;
>     } else {
> 
>     }
48746a49509,49524
> #line 142
>   nla = *(ntb + 5UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       tmp___3 = nla_strlcpy((char *)(& s->csums_alg), (struct nlattr  const  *)nla,
>                             64UL);
> #line 142
>       s->csums_alg_len = (__u32 )tmp___3;
>     } else {
> 
>     }
>   } else {
> 
48748,48763c49526,49536
<   ldv_51889: 
< #line 41
<   tags = tags + (unsigned long )dlen;
<   ldv_51957: 
< #line 41
<   tmp___19 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   tmp___20 = get_unaligned_le16((void const   *)tmp___19);
< #line 41
<   tag = (int )tmp___20;
< #line 41
<   if (tag != 0) {
< #line 42
<     goto ldv_51956;
---
> #line 142
>   nla = *(ntb + 6UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->wire_protocol = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
48766a49540,49548
> #line 142
>   nla = *(ntb + 7UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->connect_int = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
48768,48782c49550,49551
< #line 41
<   return (1);
< }
< }
< #line 77
< static int disconnect_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct disconnect *arg ) ;
< #line 77 "include/linux/drbd_nl.h"
< static int disconnect_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct disconnect *arg ) 
< { 
<   int tag ;
<   int dlen ;
<   unsigned short *tmp ;
<   u16 tmp___0 ;
<   unsigned short *tmp___1 ;
<   u16 tmp___2 ;
---
>     }
>   } else {
48784,48810c49553,49578
<   {
< #line 75
<   goto ldv_51974;
<   ldv_51973: 
< #line 75
<   tmp = tags;
< #line 75
<   tags = tags + 1;
< #line 75
<   tmp___0 = get_unaligned_le16((void const   *)tmp);
< #line 75
<   dlen = (int )tmp___0;
< #line 75
<   switch (tag & 8191) {
<   case 84: 
< #line 75
<   arg->force = (int )((signed char )*((char *)tags)) != 0;
< #line 75
<   goto ldv_51971;
<   default: ;
< #line 75
<   if ((tag & 8192) != 0) {
< #line 75
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Unknown tag: %d\n",
<             tag & 8191);
< #line 75
<     return (0);
---
>   }
> #line 142
>   nla = *(ntb + 8UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->timeout = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 9UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->ping_int = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
48813a49582,49594
> #line 142
>   nla = *(ntb + 10UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->ping_timeo = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
48815,48830c49596,49606
<   ldv_51971: 
< #line 75
<   tags = tags + (unsigned long )dlen;
<   ldv_51974: 
< #line 75
<   tmp___1 = tags;
< #line 75
<   tags = tags + 1;
< #line 75
<   tmp___2 = get_unaligned_le16((void const   *)tmp___1);
< #line 75
<   tag = (int )tmp___2;
< #line 75
<   if (tag != 0) {
< #line 76
<     goto ldv_51973;
---
> #line 142
>   nla = *(ntb + 11UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->sndbuf_size = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
48833a49610,49618
> #line 142
>   nla = *(ntb + 12UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->rcvbuf_size = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
48835,48836c49620,49893
< #line 75
<   return (1);
---
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 13UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->ko_count = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 14UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->max_buffers = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 15UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->max_epoch_size = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 16UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->unplug_watermark = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 17UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->after_sb_0p = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 18UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->after_sb_1p = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 19UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->after_sb_2p = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 20UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->rr_conflict = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 21UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->on_congestion = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 22UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->cong_fill = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 23UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       s->cong_extents = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 24UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       tmp___4 = nla_get_u8((struct nlattr  const  *)nla);
> #line 142
>       s->two_primaries = (char )tmp___4;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 25UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((int )exclude_invariants) {
> #line 142
>       printk("\016<< must not change invariant attr: %s\n", (char *)"discard_my_data");
> #line 142
>       return (-17);
>     } else {
> 
>     }
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       tmp___5 = nla_get_u8((struct nlattr  const  *)nla);
> #line 142
>       s->discard_my_data = (char )tmp___5;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 26UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       tmp___6 = nla_get_u8((struct nlattr  const  *)nla);
> #line 142
>       s->tcp_cork = (char )tmp___6;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 27UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       tmp___7 = nla_get_u8((struct nlattr  const  *)nla);
> #line 142
>       s->always_asbp = (char )tmp___7;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 28UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((int )exclude_invariants) {
> #line 142
>       printk("\016<< must not change invariant attr: %s\n", (char *)"tentative");
> #line 142
>       return (-17);
>     } else {
> 
>     }
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       tmp___8 = nla_get_u8((struct nlattr  const  *)nla);
> #line 142
>       s->tentative = (char )tmp___8;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   nla = *(ntb + 29UL);
> #line 142
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     if ((unsigned long )s != (unsigned long )((struct net_conf *)0)) {
> #line 142
>       tmp___9 = nla_get_u8((struct nlattr  const  *)nla);
> #line 142
>       s->use_rle = (char )tmp___9;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 142
>   return (0);
48839,48849c49896,49899
< #line 83
< static int resize_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct resize *arg ) ;
< #line 83 "include/linux/drbd_nl.h"
< static int resize_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct resize *arg ) 
< { 
<   int tag ;
<   int dlen ;
<   unsigned short *tmp ;
<   u16 tmp___0 ;
<   unsigned short *tmp___1 ;
<   u16 tmp___2 ;
---
> #line 174 "include/linux/drbd_genl.h"
> static int net_conf_from_attrs(struct net_conf *s , struct genl_info *info ) 
> { 
>   int tmp ;
48852,48887c49902,49941
< #line 79
<   goto ldv_51993;
<   ldv_51992: 
< #line 79
<   tmp = tags;
< #line 79
<   tags = tags + 1;
< #line 79
<   tmp___0 = get_unaligned_le16((void const   *)tmp);
< #line 79
<   dlen = (int )tmp___0;
< #line 79
<   switch (tag & 8191) {
<   case 29: 
< #line 79
<   arg->resize_size = get_unaligned_le64((void const   *)tags);
< #line 79
<   goto ldv_51988;
<   case 68: 
< #line 79
<   arg->resize_force = (int )((signed char )*((char *)tags)) != 0;
< #line 79
<   goto ldv_51988;
<   case 69: 
< #line 79
<   arg->no_resync = (int )((signed char )*((char *)tags)) != 0;
< #line 79
<   goto ldv_51988;
<   default: ;
< #line 79
<   if ((tag & 8192) != 0) {
< #line 79
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Unknown tag: %d\n",
<             tag & 8191);
< #line 79
<     return (0);
---
> #line 142
>   tmp = __net_conf_from_attrs(s, info, 0);
> #line 142
>   return (tmp);
> }
> }
> #line 174 "include/linux/drbd_genl.h"
> static int net_conf_from_attrs_for_change(struct net_conf *s , struct genl_info *info ) 
> { 
>   int tmp ;
> 
>   {
> #line 142
>   tmp = __net_conf_from_attrs(s, info, 1);
> #line 142
>   return (tmp);
> }
> }
> #line 178 "include/linux/drbd_genl.h"
> static int __set_role_parms_from_attrs(struct set_role_parms *s , struct genl_info *info ,
>                                        bool exclude_invariants ) 
> { 
>   int maxtype ;
>   struct nlattr *tla ;
>   struct nlattr **ntb ;
>   struct nlattr *nla ;
>   int err ;
>   u8 tmp ;
> 
>   {
> #line 176
>   maxtype = 1;
> #line 176
>   tla = *(info->attrs + 6UL);
> #line 176
>   ntb = (struct nlattr **)(& nested_attr_tb);
> #line 176
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 176
>     return (-42);
48890a49945,49952
> #line 176
>   err = drbd_nla_parse_nested(ntb, maxtype, tla, (struct nla_policy  const  *)(& set_role_parms_nl_policy));
> #line 176
>   if (err != 0) {
> #line 176
>     return (err);
>   } else {
> 
48892,48907c49954,49966
<   ldv_51988: 
< #line 79
<   tags = tags + (unsigned long )dlen;
<   ldv_51993: 
< #line 79
<   tmp___1 = tags;
< #line 79
<   tags = tags + 1;
< #line 79
<   tmp___2 = get_unaligned_le16((void const   *)tmp___1);
< #line 79
<   tag = (int )tmp___2;
< #line 79
<   if (tag != 0) {
< #line 80
<     goto ldv_51992;
---
> #line 176
>   nla = *(ntb + 1UL);
> #line 176
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 176
>     if ((unsigned long )s != (unsigned long )((struct set_role_parms *)0)) {
> #line 176
>       tmp = nla_get_u8((struct nlattr  const  *)nla);
> #line 176
>       s->assume_uptodate = (char )tmp;
>     } else {
> 
>     }
48910a49970,49977
> #line 176
>   return (0);
> }
> }
> #line 178 "include/linux/drbd_genl.h"
> static int set_role_parms_from_attrs(struct set_role_parms *s , struct genl_info *info ) 
> { 
>   int tmp ;
48912,48913c49979,49983
< #line 79
<   return (1);
---
>   {
> #line 176
>   tmp = __set_role_parms_from_attrs(s, info, 0);
> #line 176
>   return (tmp);
48916,48947c49986,49996
< #line 104
< static int syncer_conf_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct syncer_conf *arg ) ;
< #line 104 "include/linux/drbd_nl.h"
< static int syncer_conf_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct syncer_conf *arg ) 
< { 
<   int tag ;
<   int dlen ;
<   unsigned short *tmp ;
<   u16 tmp___0 ;
<   u32 tmp___1 ;
<   u32 tmp___2 ;
<   u32 tmp___3 ;
<   size_t __len ;
<   size_t __min1 ;
<   size_t __min2 ;
<   void *__ret ;
<   size_t __len___0 ;
<   size_t __min1___0 ;
<   size_t __min2___0 ;
<   void *__ret___0 ;
<   size_t __len___1 ;
<   size_t __min1___1 ;
<   size_t __min2___1 ;
<   void *__ret___1 ;
<   u32 tmp___4 ;
<   u32 tmp___5 ;
<   u32 tmp___6 ;
<   u32 tmp___7 ;
<   u32 tmp___8 ;
<   u32 tmp___9 ;
<   unsigned short *tmp___10 ;
<   u16 tmp___11 ;
---
> #line 184 "include/linux/drbd_genl.h"
> static int __resize_parms_from_attrs(struct resize_parms *s , struct genl_info *info ,
>                                      bool exclude_invariants ) 
> { 
>   int maxtype ;
>   struct nlattr *tla ;
>   struct nlattr **ntb ;
>   struct nlattr *nla ;
>   int err ;
>   u8 tmp ;
>   u8 tmp___0 ;
48950,48991c49999,50008
< #line 85
<   goto ldv_52049;
<   ldv_52048: 
< #line 85
<   tmp = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   tmp___0 = get_unaligned_le16((void const   *)tmp);
< #line 85
<   dlen = (int )tmp___0;
< #line 85
<   switch (tag & 8191) {
<   case 30: 
< #line 85
<   tmp___1 = get_unaligned_le32((void const   *)tags);
< #line 85
<   arg->rate = (int )tmp___1;
< #line 85
<   goto ldv_52007;
<   case 31: 
< #line 85
<   tmp___2 = get_unaligned_le32((void const   *)tags);
< #line 85
<   arg->after = (int )tmp___2;
< #line 85
<   goto ldv_52007;
<   case 32: 
< #line 85
<   tmp___3 = get_unaligned_le32((void const   *)tags);
< #line 85
<   arg->al_extents = (int )tmp___3;
< #line 85
<   goto ldv_52007;
<   case 52: ;
< #line 85
<   if (dlen > 64) {
< #line 85
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "arg too long: %s (%u wanted, max len: %u bytes)\n",
<             (char *)"verify_alg", dlen, 64U);
< #line 85
<     return (0);
---
> #line 180
>   maxtype = 3;
> #line 180
>   tla = *(info->attrs + 7UL);
> #line 180
>   ntb = (struct nlattr **)(& nested_attr_tb);
> #line 180
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 180
>     return (-42);
48995,49014c50012,50017
< #line 85
<   arg->verify_alg_len = dlen;
< #line 85
<   __min1 = (size_t )dlen;
< #line 85
<   __min2 = 64UL;
< #line 85
<   __len = __min1 < __min2 ? __min1 : __min2;
< #line 85
<   __ret = __builtin_memcpy((void *)(& arg->verify_alg), (void const   *)tags, __len);
< #line 85
<   goto ldv_52007;
<   case 51: ;
< #line 85
<   if (dlen > 32) {
< #line 85
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "arg too long: %s (%u wanted, max len: %u bytes)\n",
<             (char *)"cpu_mask", dlen, 32U);
< #line 85
<     return (0);
---
> #line 180
>   err = drbd_nla_parse_nested(ntb, maxtype, tla, (struct nla_policy  const  *)(& resize_parms_nl_policy));
> #line 180
>   if (err != 0) {
> #line 180
>     return (err);
49018,49037c50021,50031
< #line 85
<   arg->cpu_mask_len = dlen;
< #line 85
<   __min1___0 = (size_t )dlen;
< #line 85
<   __min2___0 = 32UL;
< #line 85
<   __len___0 = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
< #line 85
<   __ret___0 = __builtin_memcpy((void *)(& arg->cpu_mask), (void const   *)tags, __len___0);
< #line 85
<   goto ldv_52007;
<   case 64: ;
< #line 85
<   if (dlen > 64) {
< #line 85
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "arg too long: %s (%u wanted, max len: %u bytes)\n",
<             (char *)"csums_alg", dlen, 64U);
< #line 85
<     return (0);
---
> #line 180
>   nla = *(ntb + 1UL);
> #line 180
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 180
>     if ((unsigned long )s != (unsigned long )((struct resize_parms *)0)) {
> #line 180
>       s->resize_size = nla_get_u64((struct nlattr  const  *)nla);
>     } else {
> 
>     }
49041,49107c50035,50047
< #line 85
<   arg->csums_alg_len = dlen;
< #line 85
<   __min1___1 = (size_t )dlen;
< #line 85
<   __min2___1 = 64UL;
< #line 85
<   __len___1 = __min1___1 < __min2___1 ? __min1___1 : __min2___1;
< #line 85
<   __ret___1 = __builtin_memcpy((void *)(& arg->csums_alg), (void const   *)tags, __len___1);
< #line 85
<   goto ldv_52007;
<   case 65: 
< #line 85
<   arg->use_rle = (int )((signed char )*((char *)tags)) != 0;
< #line 85
<   goto ldv_52007;
<   case 75: 
< #line 85
<   tmp___4 = get_unaligned_le32((void const   *)tags);
< #line 85
<   arg->on_no_data = (int )tmp___4;
< #line 85
<   goto ldv_52007;
<   case 76: 
< #line 85
<   tmp___5 = get_unaligned_le32((void const   *)tags);
< #line 85
<   arg->c_plan_ahead = (int )tmp___5;
< #line 85
<   goto ldv_52007;
<   case 77: 
< #line 85
<   tmp___6 = get_unaligned_le32((void const   *)tags);
< #line 85
<   arg->c_delay_target = (int )tmp___6;
< #line 85
<   goto ldv_52007;
<   case 78: 
< #line 85
<   tmp___7 = get_unaligned_le32((void const   *)tags);
< #line 85
<   arg->c_fill_target = (int )tmp___7;
< #line 85
<   goto ldv_52007;
<   case 79: 
< #line 85
<   tmp___8 = get_unaligned_le32((void const   *)tags);
< #line 85
<   arg->c_max_rate = (int )tmp___8;
< #line 85
<   goto ldv_52007;
<   case 80: 
< #line 85
<   tmp___9 = get_unaligned_le32((void const   *)tags);
< #line 85
<   arg->c_min_rate = (int )tmp___9;
< #line 85
<   goto ldv_52007;
<   default: ;
< #line 85
<   if ((tag & 8192) != 0) {
< #line 85
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Unknown tag: %d\n",
<             tag & 8191);
< #line 85
<     return (0);
---
> #line 180
>   nla = *(ntb + 2UL);
> #line 180
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 180
>     if ((unsigned long )s != (unsigned long )((struct resize_parms *)0)) {
> #line 180
>       tmp = nla_get_u8((struct nlattr  const  *)nla);
> #line 180
>       s->resize_force = (char )tmp;
>     } else {
> 
>     }
49111,49127c50051,50063
<   }
<   ldv_52007: 
< #line 85
<   tags = tags + (unsigned long )dlen;
<   ldv_52049: 
< #line 85
<   tmp___10 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   tmp___11 = get_unaligned_le16((void const   *)tmp___10);
< #line 85
<   tag = (int )tmp___11;
< #line 85
<   if (tag != 0) {
< #line 86
<     goto ldv_52048;
---
> #line 180
>   nla = *(ntb + 3UL);
> #line 180
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 180
>     if ((unsigned long )s != (unsigned long )((struct resize_parms *)0)) {
> #line 180
>       tmp___0 = nla_get_u8((struct nlattr  const  *)nla);
> #line 180
>       s->no_resync = (char )tmp___0;
>     } else {
> 
>     }
49130a50067,50074
> #line 180
>   return (0);
> }
> }
> #line 184 "include/linux/drbd_genl.h"
> static int resize_parms_from_attrs(struct resize_parms *s , struct genl_info *info ) 
> { 
>   int tmp ;
49132,49133c50076,50080
< #line 85
<   return (1);
---
>   {
> #line 180
>   tmp = __resize_parms_from_attrs(s, info, 0);
> #line 180
>   return (tmp);
49136,49146c50083,50091
< #line 149
< static int start_ov_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct start_ov *arg ) ;
< #line 149 "include/linux/drbd_nl.h"
< static int start_ov_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct start_ov *arg ) 
< { 
<   int tag ;
<   int dlen ;
<   unsigned short *tmp ;
<   u16 tmp___0 ;
<   unsigned short *tmp___1 ;
<   u16 tmp___2 ;
---
> #line 229 "include/linux/drbd_genl.h"
> static int __start_ov_parms_from_attrs(struct start_ov_parms *s , struct genl_info *info ,
>                                        bool exclude_invariants ) 
> { 
>   int maxtype ;
>   struct nlattr *tla ;
>   struct nlattr **ntb ;
>   struct nlattr *nla ;
>   int err ;
49149,49179c50094,50112
< #line 146
<   goto ldv_52349;
<   ldv_52348: 
< #line 146
<   tmp = tags;
< #line 146
<   tags = tags + 1;
< #line 146
<   tmp___0 = get_unaligned_le16((void const   *)tmp);
< #line 146
<   dlen = (int )tmp___0;
< #line 146
<   switch (tag & 8191) {
<   case 66: 
< #line 146
<   arg->start_sector = get_unaligned_le64((void const   *)tags);
< #line 146
<   goto ldv_52345;
<   case 90: 
< #line 146
<   arg->stop_sector = get_unaligned_le64((void const   *)tags);
< #line 146
<   goto ldv_52345;
<   default: ;
< #line 146
<   if ((tag & 8192) != 0) {
< #line 146
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Unknown tag: %d\n",
<             tag & 8191);
< #line 146
<     return (0);
---
> #line 226
>   maxtype = 2;
> #line 226
>   tla = *(info->attrs + 9UL);
> #line 226
>   ntb = (struct nlattr **)(& nested_attr_tb);
> #line 226
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 226
>     return (-42);
>   } else {
> 
>   }
> #line 226
>   err = drbd_nla_parse_nested(ntb, maxtype, tla, (struct nla_policy  const  *)(& start_ov_parms_nl_policy));
> #line 226
>   if (err != 0) {
> #line 226
>     return (err);
49182a50116,50128
> #line 226
>   nla = *(ntb + 1UL);
> #line 226
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 226
>     if ((unsigned long )s != (unsigned long )((struct start_ov_parms *)0)) {
> #line 226
>       s->ov_start_sector = nla_get_u64((struct nlattr  const  *)nla);
>     } else {
> 
>     }
>   } else {
> 
49184,49199c50130,50140
<   ldv_52345: 
< #line 146
<   tags = tags + (unsigned long )dlen;
<   ldv_52349: 
< #line 146
<   tmp___1 = tags;
< #line 146
<   tags = tags + 1;
< #line 146
<   tmp___2 = get_unaligned_le16((void const   *)tmp___1);
< #line 146
<   tag = (int )tmp___2;
< #line 146
<   if (tag != 0) {
< #line 147
<     goto ldv_52348;
---
> #line 226
>   nla = *(ntb + 2UL);
> #line 226
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 226
>     if ((unsigned long )s != (unsigned long )((struct start_ov_parms *)0)) {
> #line 226
>       s->ov_stop_sector = nla_get_u64((struct nlattr  const  *)nla);
>     } else {
> 
>     }
49202a50144,50151
> #line 226
>   return (0);
> }
> }
> #line 229 "include/linux/drbd_genl.h"
> static int start_ov_parms_from_attrs(struct start_ov_parms *s , struct genl_info *info ) 
> { 
>   int tmp ;
49204,49205c50153,50157
< #line 146
<   return (1);
---
>   {
> #line 226
>   tmp = __start_ov_parms_from_attrs(s, info, 0);
> #line 226
>   return (tmp);
49208,49218c50160,50169
< #line 153
< static int new_c_uuid_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct new_c_uuid *arg ) ;
< #line 153 "include/linux/drbd_nl.h"
< static int new_c_uuid_from_tags(struct drbd_conf *mdev , unsigned short *tags , struct new_c_uuid *arg ) 
< { 
<   int tag ;
<   int dlen ;
<   unsigned short *tmp ;
<   u16 tmp___0 ;
<   unsigned short *tmp___1 ;
<   u16 tmp___2 ;
---
> #line 233 "include/linux/drbd_genl.h"
> static int __new_c_uuid_parms_from_attrs(struct new_c_uuid_parms *s , struct genl_info *info ,
>                                          bool exclude_invariants ) 
> { 
>   int maxtype ;
>   struct nlattr *tla ;
>   struct nlattr **ntb ;
>   struct nlattr *nla ;
>   int err ;
>   u8 tmp ;
49221,49246c50172,50181
< #line 151
<   goto ldv_52366;
<   ldv_52365: 
< #line 151
<   tmp = tags;
< #line 151
<   tags = tags + 1;
< #line 151
<   tmp___0 = get_unaligned_le16((void const   *)tmp);
< #line 151
<   dlen = (int )tmp___0;
< #line 151
<   switch (tag & 8191) {
<   case 63: 
< #line 151
<   arg->clear_bm = (int )((signed char )*((char *)tags)) != 0;
< #line 151
<   goto ldv_52363;
<   default: ;
< #line 151
<   if ((tag & 8192) != 0) {
< #line 151
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Unknown tag: %d\n",
<             tag & 8191);
< #line 151
<     return (0);
---
> #line 231
>   maxtype = 1;
> #line 231
>   tla = *(info->attrs + 10UL);
> #line 231
>   ntb = (struct nlattr **)(& nested_attr_tb);
> #line 231
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 231
>     return (-42);
49249a50185,50192
> #line 231
>   err = drbd_nla_parse_nested(ntb, maxtype, tla, (struct nla_policy  const  *)(& new_c_uuid_parms_nl_policy));
> #line 231
>   if (err != 0) {
> #line 231
>     return (err);
>   } else {
> 
49251,49266c50194,50206
<   ldv_52363: 
< #line 151
<   tags = tags + (unsigned long )dlen;
<   ldv_52366: 
< #line 151
<   tmp___1 = tags;
< #line 151
<   tags = tags + 1;
< #line 151
<   tmp___2 = get_unaligned_le16((void const   *)tmp___1);
< #line 151
<   tag = (int )tmp___2;
< #line 151
<   if (tag != 0) {
< #line 152
<     goto ldv_52365;
---
> #line 231
>   nla = *(ntb + 1UL);
> #line 231
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 231
>     if ((unsigned long )s != (unsigned long )((struct new_c_uuid_parms *)0)) {
> #line 231
>       tmp = nla_get_u8((struct nlattr  const  *)nla);
> #line 231
>       s->clear_bm = (char )tmp;
>     } else {
> 
>     }
49269a50210,50217
> #line 231
>   return (0);
> }
> }
> #line 233 "include/linux/drbd_genl.h"
> static int new_c_uuid_parms_from_attrs(struct new_c_uuid_parms *s , struct genl_info *info ) 
> { 
>   int tmp ;
49271,49272c50219,50223
< #line 151
<   return (1);
---
>   {
> #line 231
>   tmp = __new_c_uuid_parms_from_attrs(s, info, 0);
> #line 231
>   return (tmp);
49275,49343c50226,50235
< #line 35
< static unsigned short *disk_conf_to_tags(struct drbd_conf *mdev , struct disk_conf *arg ,
<                                          unsigned short *tags ) ;
< #line 35 "include/linux/drbd_nl.h"
< static unsigned short *disk_conf_to_tags(struct drbd_conf *mdev , struct disk_conf *arg ,
<                                          unsigned short *tags ) 
< { 
<   void *__gu_p ;
<   unsigned short *tmp ;
<   void *__gu_p___0 ;
<   unsigned short *tmp___0 ;
<   void *__gu_p___1 ;
<   void *__gu_p___2 ;
<   unsigned short *tmp___1 ;
<   void *__gu_p___3 ;
<   unsigned short *tmp___2 ;
<   size_t __len ;
<   void *__ret ;
<   void *__gu_p___4 ;
<   unsigned short *tmp___3 ;
<   void *__gu_p___5 ;
<   unsigned short *tmp___4 ;
<   size_t __len___0 ;
<   void *__ret___0 ;
<   void *__gu_p___6 ;
<   unsigned short *tmp___5 ;
<   void *__gu_p___7 ;
<   unsigned short *tmp___6 ;
<   void *__gu_p___8 ;
<   void *__gu_p___9 ;
<   unsigned short *tmp___7 ;
<   void *__gu_p___10 ;
<   unsigned short *tmp___8 ;
<   void *__gu_p___11 ;
<   void *__gu_p___12 ;
<   unsigned short *tmp___9 ;
<   void *__gu_p___13 ;
<   unsigned short *tmp___10 ;
<   void *__gu_p___14 ;
<   void *__gu_p___15 ;
<   unsigned short *tmp___11 ;
<   void *__gu_p___16 ;
<   unsigned short *tmp___12 ;
<   void *__gu_p___17 ;
<   unsigned short *tmp___13 ;
<   void *__gu_p___18 ;
<   unsigned short *tmp___14 ;
<   void *__gu_p___19 ;
<   unsigned short *tmp___15 ;
<   void *__gu_p___20 ;
<   unsigned short *tmp___16 ;
<   void *__gu_p___21 ;
<   unsigned short *tmp___17 ;
<   void *__gu_p___22 ;
<   unsigned short *tmp___18 ;
<   void *__gu_p___23 ;
<   void *__gu_p___24 ;
<   unsigned short *tmp___19 ;
<   void *__gu_p___25 ;
<   unsigned short *tmp___20 ;
<   void *__gu_p___26 ;
<   unsigned short *tmp___21 ;
<   void *__gu_p___27 ;
<   unsigned short *tmp___22 ;
<   void *__gu_p___28 ;
<   unsigned short *tmp___23 ;
<   void *__gu_p___29 ;
<   unsigned short *tmp___24 ;
<   void *__gu_p___30 ;
---
> #line 241 "include/linux/drbd_genl.h"
> static int __disconnect_parms_from_attrs(struct disconnect_parms *s , struct genl_info *info ,
>                                          bool exclude_invariants ) 
> { 
>   int maxtype ;
>   struct nlattr *tla ;
>   struct nlattr **ntb ;
>   struct nlattr *nla ;
>   int err ;
>   u8 tmp ;
49346,49378c50238,50249
< #line 20
<   tmp = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p = (void *)tmp;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p) = 2U;
< #line 20
<   goto ldv_52411;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(16386, __gu_p);
< #line 20
<   goto ldv_52411;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(16386U, __gu_p);
< #line 20
<   goto ldv_52411;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(16386ULL, __gu_p);
< #line 20
<   goto ldv_52411;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52411;
---
> #line 239
>   maxtype = 1;
> #line 239
>   tla = *(info->attrs + 12UL);
> #line 239
>   ntb = (struct nlattr **)(& nested_attr_tb);
> #line 239
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 239
>     return (-42);
>   } else {
> 
49380,49413c50251,50258
<   ldv_52411: 
< #line 20
<   tmp___0 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___0 = (void *)tmp___0;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___0) = 8U;
< #line 20
<   goto ldv_52418;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(8, __gu_p___0);
< #line 20
<   goto ldv_52418;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(8U, __gu_p___0);
< #line 20
<   goto ldv_52418;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(8ULL, __gu_p___0);
< #line 20
<   goto ldv_52418;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52418;
---
> #line 239
>   err = drbd_nla_parse_nested(ntb, maxtype, tla, (struct nla_policy  const  *)(& disconnect_parms_nl_policy));
> #line 239
>   if (err != 0) {
> #line 239
>     return (err);
>   } else {
> 
49415,49444c50260,50274
<   ldv_52418: 
< #line 20
<   __gu_p___1 = (void *)tags;
< #line 20
<   switch (8UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___1) = (unsigned char )arg->disk_size;
< #line 20
<   goto ldv_52425;
<   case 2UL: 
< #line 20
<   put_unaligned_le16((int )((unsigned short )arg->disk_size), __gu_p___1);
< #line 20
<   goto ldv_52425;
<   case 4UL: 
< #line 20
<   put_unaligned_le32((unsigned int )arg->disk_size, __gu_p___1);
< #line 20
<   goto ldv_52425;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(arg->disk_size, __gu_p___1);
< #line 20
<   goto ldv_52425;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52425;
---
> #line 239
>   nla = *(ntb + 1UL);
> #line 239
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 239
>     if ((unsigned long )s != (unsigned long )((struct disconnect_parms *)0)) {
> #line 239
>       tmp = nla_get_u8((struct nlattr  const  *)nla);
> #line 239
>       s->force_disconnect = (char )tmp;
>     } else {
> 
>     }
>   } else {
> 
49446,49481c50276,50315
<   ldv_52425: 
< #line 20
<   tags = tags + 8U;
< #line 20
<   tmp___1 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___2 = (void *)tmp___1;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___2) = 3U;
< #line 20
<   goto ldv_52432;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(57347, __gu_p___2);
< #line 20
<   goto ldv_52432;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(57347U, __gu_p___2);
< #line 20
<   goto ldv_52432;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(57347ULL, __gu_p___2);
< #line 20
<   goto ldv_52432;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52432;
---
> #line 239
>   return (0);
> }
> }
> #line 241 "include/linux/drbd_genl.h"
> static int disconnect_parms_from_attrs(struct disconnect_parms *s , struct genl_info *info ) 
> { 
>   int tmp ;
> 
>   {
> #line 239
>   tmp = __disconnect_parms_from_attrs(s, info, 0);
> #line 239
>   return (tmp);
> }
> }
> #line 245 "include/linux/drbd_genl.h"
> static int __detach_parms_from_attrs(struct detach_parms *s , struct genl_info *info ,
>                                      bool exclude_invariants ) 
> { 
>   int maxtype ;
>   struct nlattr *tla ;
>   struct nlattr **ntb ;
>   struct nlattr *nla ;
>   int err ;
>   u8 tmp ;
> 
>   {
> #line 243
>   maxtype = 1;
> #line 243
>   tla = *(info->attrs + 13UL);
> #line 243
>   ntb = (struct nlattr **)(& nested_attr_tb);
> #line 243
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 243
>     return (-42);
>   } else {
> 
49483,49516c50317,50324
<   ldv_52432: 
< #line 20
<   tmp___2 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___3 = (void *)tmp___2;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___3) = (unsigned char )arg->backing_dev_len;
< #line 20
<   goto ldv_52439;
<   case 2UL: 
< #line 20
<   put_unaligned_le16((int )((unsigned short )arg->backing_dev_len), __gu_p___3);
< #line 20
<   goto ldv_52439;
<   case 4UL: 
< #line 20
<   put_unaligned_le32((unsigned int )arg->backing_dev_len, __gu_p___3);
< #line 20
<   goto ldv_52439;
<   case 8UL: 
< #line 20
<   put_unaligned_le64((unsigned long long )arg->backing_dev_len, __gu_p___3);
< #line 20
<   goto ldv_52439;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52439;
---
> #line 243
>   err = drbd_nla_parse_nested(ntb, maxtype, tla, (struct nla_policy  const  *)(& detach_parms_nl_policy));
> #line 243
>   if (err != 0) {
> #line 243
>     return (err);
>   } else {
> 
49518,49557c50326,50340
<   ldv_52439: 
< #line 20
<   __len = (size_t )arg->backing_dev_len;
< #line 20
<   __ret = __builtin_memcpy((void *)tags, (void const   *)(& arg->backing_dev), __len);
< #line 20
<   tags = tags + (unsigned long )arg->backing_dev_len;
< #line 20
<   tmp___3 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___4 = (void *)tmp___3;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___4) = 4U;
< #line 20
<   goto ldv_52449;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(57348, __gu_p___4);
< #line 20
<   goto ldv_52449;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(57348U, __gu_p___4);
< #line 20
<   goto ldv_52449;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(57348ULL, __gu_p___4);
< #line 20
<   goto ldv_52449;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52449;
---
> #line 243
>   nla = *(ntb + 1UL);
> #line 243
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 243
>     if ((unsigned long )s != (unsigned long )((struct detach_parms *)0)) {
> #line 243
>       tmp = nla_get_u8((struct nlattr  const  *)nla);
> #line 243
>       s->force_detach = (char )tmp;
>     } else {
> 
>     }
>   } else {
> 
49559,49592c50342,50446
<   ldv_52449: 
< #line 20
<   tmp___4 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___5 = (void *)tmp___4;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___5) = (unsigned char )arg->meta_dev_len;
< #line 20
<   goto ldv_52456;
<   case 2UL: 
< #line 20
<   put_unaligned_le16((int )((unsigned short )arg->meta_dev_len), __gu_p___5);
< #line 20
<   goto ldv_52456;
<   case 4UL: 
< #line 20
<   put_unaligned_le32((unsigned int )arg->meta_dev_len, __gu_p___5);
< #line 20
<   goto ldv_52456;
<   case 8UL: 
< #line 20
<   put_unaligned_le64((unsigned long long )arg->meta_dev_len, __gu_p___5);
< #line 20
<   goto ldv_52456;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52456;
---
> #line 243
>   return (0);
> }
> }
> #line 245 "include/linux/drbd_genl.h"
> static int detach_parms_from_attrs(struct detach_parms *s , struct genl_info *info ) 
> { 
>   int tmp ;
> 
>   {
> #line 243
>   tmp = __detach_parms_from_attrs(s, info, 0);
> #line 243
>   return (tmp);
> }
> }
> #line 221 "include/linux/genl_magic_func.h"
> char const   *drbd_genl_cmd_to_str(__u8 cmd ) 
> { 
> 
> 
>   {
> #line 223
>   switch ((int )cmd) {
>   case 2: ;
> #line 263 "include/linux/drbd_genl.h"
>   return ("DRBD_ADM_GET_STATUS");
>   case 5: ;
> #line 277
>   return ("DRBD_ADM_NEW_MINOR");
>   case 6: ;
> #line 279
>   return ("DRBD_ADM_DEL_MINOR");
>   case 7: ;
> #line 283
>   return ("DRBD_ADM_NEW_RESOURCE");
>   case 8: ;
> #line 285
>   return ("DRBD_ADM_DEL_RESOURCE");
>   case 9: ;
> #line 288
>   return ("DRBD_ADM_RESOURCE_OPTS");
>   case 10: ;
> #line 294
>   return ("DRBD_ADM_CONNECT");
>   case 29: ;
> #line 301
>   return ("DRBD_ADM_CHG_NET_OPTS");
>   case 11: ;
> #line 308
>   return ("DRBD_ADM_DISCONNECT");
>   case 12: ;
> #line 311
>   return ("DRBD_ADM_ATTACH");
>   case 28: ;
> #line 317
>   return ("DRBD_ADM_CHG_DISK_OPTS");
>   case 13: ;
> #line 323
>   return ("DRBD_ADM_RESIZE");
>   case 14: ;
> #line 330
>   return ("DRBD_ADM_PRIMARY");
>   case 15: ;
> #line 337
>   return ("DRBD_ADM_SECONDARY");
>   case 16: ;
> #line 344
>   return ("DRBD_ADM_NEW_C_UUID");
>   case 17: ;
> #line 351
>   return ("DRBD_ADM_START_OV");
>   case 18: ;
> #line 357
>   return ("DRBD_ADM_DETACH");
>   case 19: ;
> #line 361
>   return ("DRBD_ADM_INVALIDATE");
>   case 20: ;
> #line 363
>   return ("DRBD_ADM_INVAL_PEER");
>   case 21: ;
> #line 365
>   return ("DRBD_ADM_PAUSE_SYNC");
>   case 22: ;
> #line 367
>   return ("DRBD_ADM_RESUME_SYNC");
>   case 23: ;
> #line 369
>   return ("DRBD_ADM_SUSPEND_IO");
>   case 24: ;
> #line 371
>   return ("DRBD_ADM_RESUME_IO");
>   case 25: ;
> #line 373
>   return ("DRBD_ADM_OUTDATE");
>   case 26: ;
> #line 375
>   return ("DRBD_ADM_GET_TIMEOUT_TYPE");
>   case 27: ;
> #line 377
>   return ("DRBD_ADM_DOWN");
>   default: ;
> #line 229 "include/linux/genl_magic_func.h"
>   return ("unknown");
49594,49633c50448,50527
<   ldv_52456: 
< #line 20
<   __len___0 = (size_t )arg->meta_dev_len;
< #line 20
<   __ret___0 = __builtin_memcpy((void *)tags, (void const   *)(& arg->meta_dev), __len___0);
< #line 20
<   tags = tags + (unsigned long )arg->meta_dev_len;
< #line 20
<   tmp___5 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___6 = (void *)tmp___5;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___6) = 5U;
< #line 20
<   goto ldv_52466;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(8197, __gu_p___6);
< #line 20
<   goto ldv_52466;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(8197U, __gu_p___6);
< #line 20
<   goto ldv_52466;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(8197ULL, __gu_p___6);
< #line 20
<   goto ldv_52466;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52466;
---
> }
> }
> #line 249 "include/linux/genl_magic_func.h"
> static struct genl_ops drbd_genl_ops[26U]  = 
> #line 249
>   {      {2U, (unsigned char)0, 0U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_get_status, & drbd_adm_get_status_all, 0, {0, 0}}, 
>         {5U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_add_minor, 0, 0, {0, 0}}, 
>         {6U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_delete_minor, 0, 0, {0, 0}}, 
>         {7U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_new_resource, 0, 0, {0, 0}}, 
>         {8U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_del_resource, 0, 0, {0, 0}}, 
>         {9U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_resource_opts, 0, 0, {0, 0}}, 
>         {10U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_connect, 0, 0, {0, 0}}, 
>         {29U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_net_opts, 0, 0, {0, 0}}, 
>         {11U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_disconnect, 0, 0, {0, 0}}, 
>         {12U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_attach, 0, 0, {0, 0}}, 
>         {28U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_disk_opts, 0, 0, {0, 0}}, 
>         {13U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_resize, 0, 0, {0, 0}}, 
>         {14U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_set_role, 0, 0, {0, 0}}, 
>         {15U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_set_role, 0, 0, {0, 0}}, 
>         {16U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_new_c_uuid, 0, 0, {0, 0}}, 
>         {17U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_start_ov, 0, 0, {0, 0}}, 
>         {18U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_detach, 0, 0, {0, 0}}, 
>         {19U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_invalidate, 0, 0, {0, 0}}, 
>         {20U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_invalidate_peer, 0, 0, {0, 0}}, 
>         {21U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_pause_sync, 0, 0, {0, 0}}, 
>         {22U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_resume_sync, 0, 0, {0, 0}}, 
>         {23U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_suspend_io, 0, 0, {0, 0}}, 
>         {24U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_resume_io, 0, 0, {0, 0}}, 
>         {25U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_outdate, 0, 0, {0, 0}}, 
>         {26U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_get_timeout_type, 0, 0, {0, 0}}, 
>         {27U, (unsigned char)0, 1U, (struct nla_policy  const  *)(& drbd_tla_nl_policy),
>       & drbd_adm_down, 0, 0, {0, 0}}};
> #line 262 "include/linux/genl_magic_func.h"
> static struct genl_family drbd_genl_family  = 
> #line 262
>      {0U, 8U, {'d', 'r', 'b', 'd', '\000'}, 1U, 13U, (_Bool)0, 0, 0, 0, {0, 0}, {0,
>                                                                                0},
>     {0, 0}};
> #line 250 "include/linux/drbd_genl.h"
> static struct genl_multicast_group drbd_mcg_events  =    {0, {0, 0}, {'e', 'v', 'e', 'n', 't', 's', '\000'}, 0U};
> #line 250 "include/linux/drbd_genl.h"
> static int drbd_genl_multicast_events(struct sk_buff *skb , gfp_t flags ) 
> { 
>   unsigned int group_id ;
>   int tmp ;
> 
>   {
> #line 250
>   group_id = drbd_mcg_events.id;
> #line 250
>   if (group_id == 0U) {
> #line 250
>     return (-22);
>   } else {
> 
49635,49668c50529,50552
<   ldv_52466: 
< #line 20
<   tmp___6 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___7 = (void *)tmp___6;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___7) = 4U;
< #line 20
<   goto ldv_52473;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(4, __gu_p___7);
< #line 20
<   goto ldv_52473;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(4U, __gu_p___7);
< #line 20
<   goto ldv_52473;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(4ULL, __gu_p___7);
< #line 20
<   goto ldv_52473;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52473;
---
> #line 250
>   tmp = genlmsg_multicast(skb, 0U, group_id, flags);
> #line 250
>   return (tmp);
> }
> }
> #line 294 "include/linux/genl_magic_func.h"
> int drbd_genl_register(void) 
> { 
>   int err ;
>   int tmp ;
> 
>   {
> #line 296
>   tmp = genl_register_family_with_ops(& drbd_genl_family, (struct genl_ops *)(& drbd_genl_ops),
>                                       26UL);
> #line 296
>   err = tmp;
> #line 298
>   if (err != 0) {
> #line 299
>     return (err);
>   } else {
> 
49670,49699c50554,50562
<   ldv_52473: 
< #line 20
<   __gu_p___8 = (void *)tags;
< #line 20
<   switch (4UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___8) = (unsigned char )arg->meta_dev_idx;
< #line 20
<   goto ldv_52480;
<   case 2UL: 
< #line 20
<   put_unaligned_le16((int )((unsigned short )arg->meta_dev_idx), __gu_p___8);
< #line 20
<   goto ldv_52480;
<   case 4UL: 
< #line 20
<   put_unaligned_le32((unsigned int )arg->meta_dev_idx, __gu_p___8);
< #line 20
<   goto ldv_52480;
<   case 8UL: 
< #line 20
<   put_unaligned_le64((unsigned long long )arg->meta_dev_idx, __gu_p___8);
< #line 20
<   goto ldv_52480;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52480;
---
> #line 250 "include/linux/drbd_genl.h"
>   err = genl_register_mc_group(& drbd_genl_family, & drbd_mcg_events);
> #line 250
>   if (err != 0) {
> #line 250
>     goto fail;
>   } else {
> #line 250
>     printk("\016%s: mcg %s: %u\n", (char *)"events", (char *)"drbd", drbd_mcg_events.id);
49701,49736c50564,50627
<   ldv_52480: 
< #line 20
<   tags = tags + 4U;
< #line 20
<   tmp___7 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___9 = (void *)tmp___7;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___9) = 6U;
< #line 20
<   goto ldv_52487;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(6, __gu_p___9);
< #line 20
<   goto ldv_52487;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(6U, __gu_p___9);
< #line 20
<   goto ldv_52487;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(6ULL, __gu_p___9);
< #line 20
<   goto ldv_52487;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52487;
---
> #line 315 "include/linux/genl_magic_func.h"
>   return (0);
>   fail: 
> #line 317
>   genl_unregister_family(& drbd_genl_family);
> #line 318
>   return (err);
> }
> }
> #line 321 "include/linux/genl_magic_func.h"
> void drbd_genl_unregister(void) 
> { 
> 
> 
>   {
> #line 323
>   genl_unregister_family(& drbd_genl_family);
> #line 324
>   return;
> }
> }
> #line 135 "include/linux/drbd_genl.h"
> static int disk_conf_to_skb(struct sk_buff *skb , struct disk_conf *s , bool const   exclude_sensitive ) 
> { 
>   struct nlattr *tla ;
>   struct nlattr *tmp ;
>   int __min1 ;
>   int __min2 ;
>   int tmp___0 ;
>   int __min1___0 ;
>   int __min2___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
>   int tmp___4 ;
>   int tmp___5 ;
>   int tmp___6 ;
>   int tmp___7 ;
>   int tmp___8 ;
>   int tmp___9 ;
>   int tmp___10 ;
>   int tmp___11 ;
>   int tmp___12 ;
>   int tmp___13 ;
>   int tmp___14 ;
>   int tmp___15 ;
>   int tmp___16 ;
>   int tmp___17 ;
>   int tmp___18 ;
>   int tmp___19 ;
>   int tmp___20 ;
>   int tmp___21 ;
> 
>   {
> #line 104
>   tmp = nla_nest_start(skb, 3);
> #line 104
>   tla = tmp;
> #line 104
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
49738,49771c50629,50640
<   ldv_52487: 
< #line 20
<   tmp___8 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___10 = (void *)tmp___8;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___10) = 4U;
< #line 20
<   goto ldv_52494;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(4, __gu_p___10);
< #line 20
<   goto ldv_52494;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(4U, __gu_p___10);
< #line 20
<   goto ldv_52494;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(4ULL, __gu_p___10);
< #line 20
<   goto ldv_52494;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52494;
---
> #line 104
>   __min1 = 128;
> #line 104
>   __min2 = (int )(s->backing_dev_len + 1U);
> #line 104
>   tmp___0 = nla_put(skb, 1, __min1 < __min2 ? __min1 : __min2, (void const   *)(& s->backing_dev));
> #line 104
>   if (tmp___0 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
49773,49802c50642,50653
<   ldv_52494: 
< #line 20
<   __gu_p___11 = (void *)tags;
< #line 20
<   switch (4UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___11) = (unsigned char )arg->on_io_error;
< #line 20
<   goto ldv_52501;
<   case 2UL: 
< #line 20
<   put_unaligned_le16((int )((unsigned short )arg->on_io_error), __gu_p___11);
< #line 20
<   goto ldv_52501;
<   case 4UL: 
< #line 20
<   put_unaligned_le32((unsigned int )arg->on_io_error, __gu_p___11);
< #line 20
<   goto ldv_52501;
<   case 8UL: 
< #line 20
<   put_unaligned_le64((unsigned long long )arg->on_io_error, __gu_p___11);
< #line 20
<   goto ldv_52501;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52501;
---
> #line 104
>   __min1___0 = 128;
> #line 104
>   __min2___0 = (int )(s->meta_dev_len + 1U);
> #line 104
>   tmp___1 = nla_put(skb, 2, __min1___0 < __min2___0 ? __min1___0 : __min2___0, (void const   *)(& s->meta_dev));
> #line 104
>   if (tmp___1 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
49804,49839c50655,50662
<   ldv_52501: 
< #line 20
<   tags = tags + 4U;
< #line 20
<   tmp___9 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___12 = (void *)tmp___9;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___12) = 7U;
< #line 20
<   goto ldv_52508;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(7, __gu_p___12);
< #line 20
<   goto ldv_52508;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(7U, __gu_p___12);
< #line 20
<   goto ldv_52508;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(7ULL, __gu_p___12);
< #line 20
<   goto ldv_52508;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52508;
---
> #line 104
>   tmp___2 = nla_put_u32(skb, 3, (u32 )s->meta_dev_idx);
> #line 104
>   if (tmp___2 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
49841,49874c50664,50671
<   ldv_52508: 
< #line 20
<   tmp___10 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___13 = (void *)tmp___10;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___13) = 4U;
< #line 20
<   goto ldv_52515;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(4, __gu_p___13);
< #line 20
<   goto ldv_52515;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(4U, __gu_p___13);
< #line 20
<   goto ldv_52515;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(4ULL, __gu_p___13);
< #line 20
<   goto ldv_52515;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52515;
---
> #line 104
>   tmp___3 = nla_put_u64(skb, 4, s->disk_size);
> #line 104
>   if (tmp___3 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
49876,49905c50673,50680
<   ldv_52515: 
< #line 20
<   __gu_p___14 = (void *)tags;
< #line 20
<   switch (4UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___14) = (unsigned char )arg->fencing;
< #line 20
<   goto ldv_52522;
<   case 2UL: 
< #line 20
<   put_unaligned_le16((int )((unsigned short )arg->fencing), __gu_p___14);
< #line 20
<   goto ldv_52522;
<   case 4UL: 
< #line 20
<   put_unaligned_le32((unsigned int )arg->fencing, __gu_p___14);
< #line 20
<   goto ldv_52522;
<   case 8UL: 
< #line 20
<   put_unaligned_le64((unsigned long long )arg->fencing, __gu_p___14);
< #line 20
<   goto ldv_52522;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52522;
---
> #line 104
>   tmp___4 = nla_put_u32(skb, 5, s->max_bio_bvecs);
> #line 104
>   if (tmp___4 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
49907,49942c50682,50689
<   ldv_52522: 
< #line 20
<   tags = tags + 4U;
< #line 20
<   tmp___11 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___15 = (void *)tmp___11;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___15) = 37U;
< #line 20
<   goto ldv_52529;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(32805, __gu_p___15);
< #line 20
<   goto ldv_52529;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(32805U, __gu_p___15);
< #line 20
<   goto ldv_52529;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(32805ULL, __gu_p___15);
< #line 20
<   goto ldv_52529;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52529;
---
> #line 104
>   tmp___5 = nla_put_u32(skb, 6, s->on_io_error);
> #line 104
>   if (tmp___5 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
49944,49977c50691,50698
<   ldv_52529: 
< #line 20
<   tmp___12 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___16 = (void *)tmp___12;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___16) = 1U;
< #line 20
<   goto ldv_52536;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(1, __gu_p___16);
< #line 20
<   goto ldv_52536;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(1U, __gu_p___16);
< #line 20
<   goto ldv_52536;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(1ULL, __gu_p___16);
< #line 20
<   goto ldv_52536;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52536;
---
> #line 104
>   tmp___6 = nla_put_u32(skb, 7, s->fencing);
> #line 104
>   if (tmp___6 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
49979,50016c50700,50707
<   ldv_52536: 
< #line 20
<   *((char *)tags) = (char )arg->use_bmbv;
< #line 20
<   tags = tags + 1U;
< #line 20
<   tmp___13 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___17 = (void *)tmp___13;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___17) = 53U;
< #line 20
<   goto ldv_52543;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(32821, __gu_p___17);
< #line 20
<   goto ldv_52543;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(32821U, __gu_p___17);
< #line 20
<   goto ldv_52543;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(32821ULL, __gu_p___17);
< #line 20
<   goto ldv_52543;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52543;
---
> #line 104
>   tmp___7 = nla_put_u32(skb, 8, s->resync_rate);
> #line 104
>   if (tmp___7 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50018,50051c50709,50716
<   ldv_52543: 
< #line 20
<   tmp___14 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___18 = (void *)tmp___14;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___18) = 1U;
< #line 20
<   goto ldv_52550;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(1, __gu_p___18);
< #line 20
<   goto ldv_52550;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(1U, __gu_p___18);
< #line 20
<   goto ldv_52550;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(1ULL, __gu_p___18);
< #line 20
<   goto ldv_52550;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52550;
---
> #line 104
>   tmp___8 = nla_put_u32(skb, 9, (u32 )s->resync_after);
> #line 104
>   if (tmp___8 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50053,50090c50718,50725
<   ldv_52550: 
< #line 20
<   *((char *)tags) = (char )arg->no_disk_flush;
< #line 20
<   tags = tags + 1U;
< #line 20
<   tmp___15 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___19 = (void *)tmp___15;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___19) = 54U;
< #line 20
<   goto ldv_52557;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(32822, __gu_p___19);
< #line 20
<   goto ldv_52557;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(32822U, __gu_p___19);
< #line 20
<   goto ldv_52557;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(32822ULL, __gu_p___19);
< #line 20
<   goto ldv_52557;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52557;
---
> #line 104
>   tmp___9 = nla_put_u32(skb, 10, s->al_extents);
> #line 104
>   if (tmp___9 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50092,50125c50727,50734
<   ldv_52557: 
< #line 20
<   tmp___16 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___20 = (void *)tmp___16;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___20) = 1U;
< #line 20
<   goto ldv_52564;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(1, __gu_p___20);
< #line 20
<   goto ldv_52564;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(1U, __gu_p___20);
< #line 20
<   goto ldv_52564;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(1ULL, __gu_p___20);
< #line 20
<   goto ldv_52564;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52564;
---
> #line 104
>   tmp___10 = nla_put_u32(skb, 11, s->c_plan_ahead);
> #line 104
>   if (tmp___10 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50127,50164c50736,50743
<   ldv_52564: 
< #line 20
<   *((char *)tags) = (char )arg->no_md_flush;
< #line 20
<   tags = tags + 1U;
< #line 20
<   tmp___17 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___21 = (void *)tmp___17;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___21) = 56U;
< #line 20
<   goto ldv_52571;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(56, __gu_p___21);
< #line 20
<   goto ldv_52571;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(56U, __gu_p___21);
< #line 20
<   goto ldv_52571;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(56ULL, __gu_p___21);
< #line 20
<   goto ldv_52571;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52571;
---
> #line 104
>   tmp___11 = nla_put_u32(skb, 12, s->c_delay_target);
> #line 104
>   if (tmp___11 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50166,50199c50745,50752
<   ldv_52571: 
< #line 20
<   tmp___18 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___22 = (void *)tmp___18;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___22) = 4U;
< #line 20
<   goto ldv_52578;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(4, __gu_p___22);
< #line 20
<   goto ldv_52578;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(4U, __gu_p___22);
< #line 20
<   goto ldv_52578;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(4ULL, __gu_p___22);
< #line 20
<   goto ldv_52578;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52578;
---
> #line 104
>   tmp___12 = nla_put_u32(skb, 13, s->c_fill_target);
> #line 104
>   if (tmp___12 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50201,50230c50754,50761
<   ldv_52578: 
< #line 20
<   __gu_p___23 = (void *)tags;
< #line 20
<   switch (4UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___23) = (unsigned char )arg->max_bio_bvecs;
< #line 20
<   goto ldv_52585;
<   case 2UL: 
< #line 20
<   put_unaligned_le16((int )((unsigned short )arg->max_bio_bvecs), __gu_p___23);
< #line 20
<   goto ldv_52585;
<   case 4UL: 
< #line 20
<   put_unaligned_le32((unsigned int )arg->max_bio_bvecs, __gu_p___23);
< #line 20
<   goto ldv_52585;
<   case 8UL: 
< #line 20
<   put_unaligned_le64((unsigned long long )arg->max_bio_bvecs, __gu_p___23);
< #line 20
<   goto ldv_52585;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52585;
---
> #line 104
>   tmp___13 = nla_put_u32(skb, 14, s->c_max_rate);
> #line 104
>   if (tmp___13 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50232,50267c50763,50770
<   ldv_52585: 
< #line 20
<   tags = tags + 4U;
< #line 20
<   tmp___19 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___24 = (void *)tmp___19;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___24) = 57U;
< #line 20
<   goto ldv_52592;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(32825, __gu_p___24);
< #line 20
<   goto ldv_52592;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(32825U, __gu_p___24);
< #line 20
<   goto ldv_52592;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(32825ULL, __gu_p___24);
< #line 20
<   goto ldv_52592;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52592;
---
> #line 104
>   tmp___14 = nla_put_u32(skb, 15, s->c_min_rate);
> #line 104
>   if (tmp___14 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50269,50302c50772,50779
<   ldv_52592: 
< #line 20
<   tmp___20 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___25 = (void *)tmp___20;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___25) = 1U;
< #line 20
<   goto ldv_52599;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(1, __gu_p___25);
< #line 20
<   goto ldv_52599;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(1U, __gu_p___25);
< #line 20
<   goto ldv_52599;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(1ULL, __gu_p___25);
< #line 20
<   goto ldv_52599;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52599;
---
> #line 104
>   tmp___15 = nla_put_u8(skb, 16, (int )((u8 )s->disk_barrier));
> #line 104
>   if (tmp___15 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50304,50341c50781,50788
<   ldv_52599: 
< #line 20
<   *((char *)tags) = (char )arg->no_disk_barrier;
< #line 20
<   tags = tags + 1U;
< #line 20
<   tmp___21 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___26 = (void *)tmp___21;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___26) = 58U;
< #line 20
<   goto ldv_52606;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(32826, __gu_p___26);
< #line 20
<   goto ldv_52606;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(32826U, __gu_p___26);
< #line 20
<   goto ldv_52606;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(32826ULL, __gu_p___26);
< #line 20
<   goto ldv_52606;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52606;
---
> #line 104
>   tmp___16 = nla_put_u8(skb, 17, (int )((u8 )s->disk_flushes));
> #line 104
>   if (tmp___16 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50343,50376c50790,50797
<   ldv_52606: 
< #line 20
<   tmp___22 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___27 = (void *)tmp___22;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___27) = 1U;
< #line 20
<   goto ldv_52613;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(1, __gu_p___27);
< #line 20
<   goto ldv_52613;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(1U, __gu_p___27);
< #line 20
<   goto ldv_52613;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(1ULL, __gu_p___27);
< #line 20
<   goto ldv_52613;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52613;
---
> #line 104
>   tmp___17 = nla_put_u8(skb, 18, (int )((u8 )s->disk_drain));
> #line 104
>   if (tmp___17 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50378,50415c50799,50806
<   ldv_52613: 
< #line 20
<   *((char *)tags) = (char )arg->no_disk_drain;
< #line 20
<   tags = tags + 1U;
< #line 20
<   tmp___23 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___28 = (void *)tmp___23;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___28) = 89U;
< #line 20
<   goto ldv_52620;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(89, __gu_p___28);
< #line 20
<   goto ldv_52620;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(89U, __gu_p___28);
< #line 20
<   goto ldv_52620;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(89ULL, __gu_p___28);
< #line 20
<   goto ldv_52620;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52620;
---
> #line 104
>   tmp___18 = nla_put_u8(skb, 19, (int )((u8 )s->md_flushes));
> #line 104
>   if (tmp___18 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50417,50450c50808,50815
<   ldv_52620: 
< #line 20
<   tmp___24 = tags;
< #line 20
<   tags = tags + 1;
< #line 20
<   __gu_p___29 = (void *)tmp___24;
< #line 20
<   switch (2UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___29) = 4U;
< #line 20
<   goto ldv_52627;
<   case 2UL: 
< #line 20
<   put_unaligned_le16(4, __gu_p___29);
< #line 20
<   goto ldv_52627;
<   case 4UL: 
< #line 20
<   put_unaligned_le32(4U, __gu_p___29);
< #line 20
<   goto ldv_52627;
<   case 8UL: 
< #line 20
<   put_unaligned_le64(4ULL, __gu_p___29);
< #line 20
<   goto ldv_52627;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52627;
---
> #line 104
>   tmp___19 = nla_put_u32(skb, 20, s->disk_timeout);
> #line 104
>   if (tmp___19 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50452,50481c50817,50824
<   ldv_52627: 
< #line 20
<   __gu_p___30 = (void *)tags;
< #line 20
<   switch (4UL) {
<   case 1UL: 
< #line 20
<   *((u8 *)__gu_p___30) = (unsigned char )arg->disk_timeout;
< #line 20
<   goto ldv_52634;
<   case 2UL: 
< #line 20
<   put_unaligned_le16((int )((unsigned short )arg->disk_timeout), __gu_p___30);
< #line 20
<   goto ldv_52634;
<   case 4UL: 
< #line 20
<   put_unaligned_le32((unsigned int )arg->disk_timeout, __gu_p___30);
< #line 20
<   goto ldv_52634;
<   case 8UL: 
< #line 20
<   put_unaligned_le64((unsigned long long )arg->disk_timeout, __gu_p___30);
< #line 20
<   goto ldv_52634;
<   default: 
< #line 20
<   __bad_unaligned_access_size();
< #line 20
<   goto ldv_52634;
---
> #line 104
>   tmp___20 = nla_put_u32(skb, 21, s->read_balancing);
> #line 104
>   if (tmp___20 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
50483,50487c50826,50848
<   ldv_52634: 
< #line 20
<   tags = tags + 4U;
< #line 20
<   return (tags);
---
> #line 104
>   tmp___21 = nla_put_u8(skb, 23, (int )((u8 )s->al_updates));
> #line 104
>   if (tmp___21 != 0) {
> #line 104
>     goto nla_put_failure;
>   } else {
> 
>   }
> #line 104
>   nla_nest_end(skb, tla);
> #line 104
>   return (0);
>   nla_put_failure: ;
> #line 104
>   if ((unsigned long )tla != (unsigned long )((struct nlattr *)0)) {
> #line 104
>     nla_nest_cancel(skb, tla);
>   } else {
> 
>   }
> #line 104
>   return (-90);
50490,50644c50851,50859
< #line 73
< static unsigned short *net_conf_to_tags(struct drbd_conf *mdev , struct net_conf *arg ,
<                                         unsigned short *tags ) ;
< #line 73 "include/linux/drbd_nl.h"
< static unsigned short *net_conf_to_tags(struct drbd_conf *mdev , struct net_conf *arg ,
<                                         unsigned short *tags ) 
< { 
<   void *__gu_p ;
<   unsigned short *tmp ;
<   void *__gu_p___0 ;
<   unsigned short *tmp___0 ;
<   size_t __len ;
<   void *__ret ;
<   void *__gu_p___1 ;
<   unsigned short *tmp___1 ;
<   void *__gu_p___2 ;
<   unsigned short *tmp___2 ;
<   size_t __len___0 ;
<   void *__ret___0 ;
<   void *__gu_p___3 ;
<   unsigned short *tmp___3 ;
<   void *__gu_p___4 ;
<   unsigned short *tmp___4 ;
<   size_t __len___1 ;
<   void *__ret___1 ;
<   void *__gu_p___5 ;
<   unsigned short *tmp___5 ;
<   void *__gu_p___6 ;
<   unsigned short *tmp___6 ;
<   size_t __len___2 ;
<   void *__ret___2 ;
<   void *__gu_p___7 ;
<   unsigned short *tmp___7 ;
<   void *__gu_p___8 ;
<   unsigned short *tmp___8 ;
<   size_t __len___3 ;
<   void *__ret___3 ;
<   void *__gu_p___9 ;
<   unsigned short *tmp___9 ;
<   void *__gu_p___10 ;
<   unsigned short *tmp___10 ;
<   void *__gu_p___11 ;
<   void *__gu_p___12 ;
<   unsigned short *tmp___11 ;
<   void *__gu_p___13 ;
<   unsigned short *tmp___12 ;
<   void *__gu_p___14 ;
<   void *__gu_p___15 ;
<   unsigned short *tmp___13 ;
<   void *__gu_p___16 ;
<   unsigned short *tmp___14 ;
<   void *__gu_p___17 ;
<   void *__gu_p___18 ;
<   unsigned short *tmp___15 ;
<   void *__gu_p___19 ;
<   unsigned short *tmp___16 ;
<   void *__gu_p___20 ;
<   void *__gu_p___21 ;
<   unsigned short *tmp___17 ;
<   void *__gu_p___22 ;
<   unsigned short *tmp___18 ;
<   void *__gu_p___23 ;
<   void *__gu_p___24 ;
<   unsigned short *tmp___19 ;
<   void *__gu_p___25 ;
<   unsigned short *tmp___20 ;
<   void *__gu_p___26 ;
<   void *__gu_p___27 ;
<   unsigned short *tmp___21 ;
<   void *__gu_p___28 ;
<   unsigned short *tmp___22 ;
<   void *__gu_p___29 ;
<   void *__gu_p___30 ;
<   unsigned short *tmp___23 ;
<   void *__gu_p___31 ;
<   unsigned short *tmp___24 ;
<   void *__gu_p___32 ;
<   void *__gu_p___33 ;
<   unsigned short *tmp___25 ;
<   void *__gu_p___34 ;
<   unsigned short *tmp___26 ;
<   void *__gu_p___35 ;
<   void *__gu_p___36 ;
<   unsigned short *tmp___27 ;
<   void *__gu_p___37 ;
<   unsigned short *tmp___28 ;
<   void *__gu_p___38 ;
<   void *__gu_p___39 ;
<   unsigned short *tmp___29 ;
<   void *__gu_p___40 ;
<   unsigned short *tmp___30 ;
<   void *__gu_p___41 ;
<   void *__gu_p___42 ;
<   unsigned short *tmp___31 ;
<   void *__gu_p___43 ;
<   unsigned short *tmp___32 ;
<   void *__gu_p___44 ;
<   void *__gu_p___45 ;
<   unsigned short *tmp___33 ;
<   void *__gu_p___46 ;
<   unsigned short *tmp___34 ;
<   void *__gu_p___47 ;
<   void *__gu_p___48 ;
<   unsigned short *tmp___35 ;
<   void *__gu_p___49 ;
<   unsigned short *tmp___36 ;
<   void *__gu_p___50 ;
<   void *__gu_p___51 ;
<   unsigned short *tmp___37 ;
<   void *__gu_p___52 ;
<   unsigned short *tmp___38 ;
<   void *__gu_p___53 ;
<   void *__gu_p___54 ;
<   unsigned short *tmp___39 ;
<   void *__gu_p___55 ;
<   unsigned short *tmp___40 ;
<   void *__gu_p___56 ;
<   void *__gu_p___57 ;
<   unsigned short *tmp___41 ;
<   void *__gu_p___58 ;
<   unsigned short *tmp___42 ;
<   void *__gu_p___59 ;
<   void *__gu_p___60 ;
<   unsigned short *tmp___43 ;
<   void *__gu_p___61 ;
<   unsigned short *tmp___44 ;
<   void *__gu_p___62 ;
<   void *__gu_p___63 ;
<   unsigned short *tmp___45 ;
<   void *__gu_p___64 ;
<   unsigned short *tmp___46 ;
<   void *__gu_p___65 ;
<   unsigned short *tmp___47 ;
<   void *__gu_p___66 ;
<   unsigned short *tmp___48 ;
<   void *__gu_p___67 ;
<   unsigned short *tmp___49 ;
<   void *__gu_p___68 ;
<   unsigned short *tmp___50 ;
<   void *__gu_p___69 ;
<   unsigned short *tmp___51 ;
<   void *__gu_p___70 ;
<   unsigned short *tmp___52 ;
<   void *__gu_p___71 ;
<   unsigned short *tmp___53 ;
<   void *__gu_p___72 ;
<   unsigned short *tmp___54 ;
<   void *__gu_p___73 ;
<   unsigned short *tmp___55 ;
<   void *__gu_p___74 ;
<   unsigned short *tmp___56 ;
<   void *__gu_p___75 ;
<   unsigned short *tmp___57 ;
<   void *__gu_p___76 ;
<   unsigned short *tmp___58 ;
---
> #line 140 "include/linux/drbd_genl.h"
> static int res_opts_to_skb(struct sk_buff *skb , struct res_opts *s , bool const   exclude_sensitive ) 
> { 
>   struct nlattr *tla ;
>   struct nlattr *tmp ;
>   int __min1 ;
>   int __min2 ;
>   int tmp___0 ;
>   int tmp___1 ;
50647,52092c50862,50871
< #line 41
<   tmp = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p = (void *)tmp;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p) = 8U;
< #line 41
<   goto ldv_52673;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(57352, __gu_p);
< #line 41
<   goto ldv_52673;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(57352U, __gu_p);
< #line 41
<   goto ldv_52673;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(57352ULL, __gu_p);
< #line 41
<   goto ldv_52673;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52673;
<   }
<   ldv_52673: 
< #line 41
<   tmp___0 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___0 = (void *)tmp___0;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___0) = (unsigned char )arg->my_addr_len;
< #line 41
<   goto ldv_52680;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->my_addr_len), __gu_p___0);
< #line 41
<   goto ldv_52680;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->my_addr_len, __gu_p___0);
< #line 41
<   goto ldv_52680;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->my_addr_len, __gu_p___0);
< #line 41
<   goto ldv_52680;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52680;
<   }
<   ldv_52680: 
< #line 41
<   __len = (size_t )arg->my_addr_len;
< #line 41
<   __ret = __builtin_memcpy((void *)tags, (void const   *)(& arg->my_addr), __len);
< #line 41
<   tags = tags + (unsigned long )arg->my_addr_len;
< #line 41
<   tmp___1 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___1 = (void *)tmp___1;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___1) = 9U;
< #line 41
<   goto ldv_52690;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(57353, __gu_p___1);
< #line 41
<   goto ldv_52690;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(57353U, __gu_p___1);
< #line 41
<   goto ldv_52690;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(57353ULL, __gu_p___1);
< #line 41
<   goto ldv_52690;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52690;
<   }
<   ldv_52690: 
< #line 41
<   tmp___2 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___2 = (void *)tmp___2;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___2) = (unsigned char )arg->peer_addr_len;
< #line 41
<   goto ldv_52697;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->peer_addr_len), __gu_p___2);
< #line 41
<   goto ldv_52697;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->peer_addr_len, __gu_p___2);
< #line 41
<   goto ldv_52697;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->peer_addr_len, __gu_p___2);
< #line 41
<   goto ldv_52697;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52697;
<   }
<   ldv_52697: 
< #line 41
<   __len___0 = (size_t )arg->peer_addr_len;
< #line 41
<   __ret___0 = __builtin_memcpy((void *)tags, (void const   *)(& arg->peer_addr), __len___0);
< #line 41
<   tags = tags + (unsigned long )arg->peer_addr_len;
< #line 41
<   tmp___3 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___3 = (void *)tmp___3;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___3) = 10U;
< #line 41
<   goto ldv_52707;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(49162, __gu_p___3);
< #line 41
<   goto ldv_52707;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(49162U, __gu_p___3);
< #line 41
<   goto ldv_52707;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(49162ULL, __gu_p___3);
< #line 41
<   goto ldv_52707;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52707;
<   }
<   ldv_52707: 
< #line 41
<   tmp___4 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___4 = (void *)tmp___4;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___4) = (unsigned char )arg->shared_secret_len;
< #line 41
<   goto ldv_52714;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->shared_secret_len), __gu_p___4);
< #line 41
<   goto ldv_52714;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->shared_secret_len, __gu_p___4);
< #line 41
<   goto ldv_52714;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->shared_secret_len, __gu_p___4);
< #line 41
<   goto ldv_52714;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52714;
<   }
<   ldv_52714: 
< #line 41
<   __len___1 = (size_t )arg->shared_secret_len;
< #line 41
<   __ret___1 = __builtin_memcpy((void *)tags, (void const   *)(& arg->shared_secret),
<                                __len___1);
< #line 41
<   tags = tags + (unsigned long )arg->shared_secret_len;
< #line 41
<   tmp___5 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___5 = (void *)tmp___5;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___5) = 11U;
< #line 41
<   goto ldv_52724;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(49163, __gu_p___5);
< #line 41
<   goto ldv_52724;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(49163U, __gu_p___5);
< #line 41
<   goto ldv_52724;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(49163ULL, __gu_p___5);
< #line 41
<   goto ldv_52724;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52724;
<   }
<   ldv_52724: 
< #line 41
<   tmp___6 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___6 = (void *)tmp___6;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___6) = (unsigned char )arg->cram_hmac_alg_len;
< #line 41
<   goto ldv_52731;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->cram_hmac_alg_len), __gu_p___6);
< #line 41
<   goto ldv_52731;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->cram_hmac_alg_len, __gu_p___6);
< #line 41
<   goto ldv_52731;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->cram_hmac_alg_len, __gu_p___6);
< #line 41
<   goto ldv_52731;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52731;
<   }
<   ldv_52731: 
< #line 41
<   __len___2 = (size_t )arg->cram_hmac_alg_len;
< #line 41
<   __ret___2 = __builtin_memcpy((void *)tags, (void const   *)(& arg->cram_hmac_alg),
<                                __len___2);
< #line 41
<   tags = tags + (unsigned long )arg->cram_hmac_alg_len;
< #line 41
<   tmp___7 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___7 = (void *)tmp___7;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___7) = 44U;
< #line 41
<   goto ldv_52741;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(49196, __gu_p___7);
< #line 41
<   goto ldv_52741;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(49196U, __gu_p___7);
< #line 41
<   goto ldv_52741;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(49196ULL, __gu_p___7);
< #line 41
<   goto ldv_52741;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52741;
<   }
<   ldv_52741: 
< #line 41
<   tmp___8 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___8 = (void *)tmp___8;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___8) = (unsigned char )arg->integrity_alg_len;
< #line 41
<   goto ldv_52748;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->integrity_alg_len), __gu_p___8);
< #line 41
<   goto ldv_52748;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->integrity_alg_len, __gu_p___8);
< #line 41
<   goto ldv_52748;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->integrity_alg_len, __gu_p___8);
< #line 41
<   goto ldv_52748;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52748;
<   }
<   ldv_52748: 
< #line 41
<   __len___3 = (size_t )arg->integrity_alg_len;
< #line 41
<   __ret___3 = __builtin_memcpy((void *)tags, (void const   *)(& arg->integrity_alg),
<                                __len___3);
< #line 41
<   tags = tags + (unsigned long )arg->integrity_alg_len;
< #line 41
<   tmp___9 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___9 = (void *)tmp___9;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___9) = 14U;
< #line 41
<   goto ldv_52758;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(14, __gu_p___9);
< #line 41
<   goto ldv_52758;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(14U, __gu_p___9);
< #line 41
<   goto ldv_52758;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(14ULL, __gu_p___9);
< #line 41
<   goto ldv_52758;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52758;
<   }
<   ldv_52758: 
< #line 41
<   tmp___10 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___10 = (void *)tmp___10;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___10) = 4U;
< #line 41
<   goto ldv_52765;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___10);
< #line 41
<   goto ldv_52765;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___10);
< #line 41
<   goto ldv_52765;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___10);
< #line 41
<   goto ldv_52765;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52765;
<   }
<   ldv_52765: 
< #line 41
<   __gu_p___11 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___11) = (unsigned char )arg->timeout;
< #line 41
<   goto ldv_52772;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->timeout), __gu_p___11);
< #line 41
<   goto ldv_52772;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->timeout, __gu_p___11);
< #line 41
<   goto ldv_52772;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->timeout, __gu_p___11);
< #line 41
<   goto ldv_52772;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52772;
<   }
<   ldv_52772: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___11 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___12 = (void *)tmp___11;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___12) = 15U;
< #line 41
<   goto ldv_52779;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(8207, __gu_p___12);
< #line 41
<   goto ldv_52779;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(8207U, __gu_p___12);
< #line 41
<   goto ldv_52779;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(8207ULL, __gu_p___12);
< #line 41
<   goto ldv_52779;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52779;
<   }
<   ldv_52779: 
< #line 41
<   tmp___12 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___13 = (void *)tmp___12;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___13) = 4U;
< #line 41
<   goto ldv_52786;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___13);
< #line 41
<   goto ldv_52786;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___13);
< #line 41
<   goto ldv_52786;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___13);
< #line 41
<   goto ldv_52786;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52786;
<   }
<   ldv_52786: 
< #line 41
<   __gu_p___14 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___14) = (unsigned char )arg->wire_protocol;
< #line 41
<   goto ldv_52793;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->wire_protocol), __gu_p___14);
< #line 41
<   goto ldv_52793;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->wire_protocol, __gu_p___14);
< #line 41
<   goto ldv_52793;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->wire_protocol, __gu_p___14);
< #line 41
<   goto ldv_52793;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52793;
<   }
<   ldv_52793: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___13 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___15 = (void *)tmp___13;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___15) = 16U;
< #line 41
<   goto ldv_52800;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(16, __gu_p___15);
< #line 41
<   goto ldv_52800;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(16U, __gu_p___15);
< #line 41
<   goto ldv_52800;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(16ULL, __gu_p___15);
< #line 41
<   goto ldv_52800;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52800;
<   }
<   ldv_52800: 
< #line 41
<   tmp___14 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___16 = (void *)tmp___14;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___16) = 4U;
< #line 41
<   goto ldv_52807;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___16);
< #line 41
<   goto ldv_52807;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___16);
< #line 41
<   goto ldv_52807;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___16);
< #line 41
<   goto ldv_52807;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52807;
<   }
<   ldv_52807: 
< #line 41
<   __gu_p___17 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___17) = (unsigned char )arg->try_connect_int;
< #line 41
<   goto ldv_52814;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->try_connect_int), __gu_p___17);
< #line 41
<   goto ldv_52814;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->try_connect_int, __gu_p___17);
< #line 41
<   goto ldv_52814;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->try_connect_int, __gu_p___17);
< #line 41
<   goto ldv_52814;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52814;
<   }
<   ldv_52814: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___15 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___18 = (void *)tmp___15;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___18) = 17U;
< #line 41
<   goto ldv_52821;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(17, __gu_p___18);
< #line 41
<   goto ldv_52821;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(17U, __gu_p___18);
< #line 41
<   goto ldv_52821;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(17ULL, __gu_p___18);
< #line 41
<   goto ldv_52821;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52821;
<   }
<   ldv_52821: 
< #line 41
<   tmp___16 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___19 = (void *)tmp___16;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___19) = 4U;
< #line 41
<   goto ldv_52828;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___19);
< #line 41
<   goto ldv_52828;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___19);
< #line 41
<   goto ldv_52828;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___19);
< #line 41
<   goto ldv_52828;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52828;
<   }
<   ldv_52828: 
< #line 41
<   __gu_p___20 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___20) = (unsigned char )arg->ping_int;
< #line 41
<   goto ldv_52835;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->ping_int), __gu_p___20);
< #line 41
<   goto ldv_52835;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->ping_int, __gu_p___20);
< #line 41
<   goto ldv_52835;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->ping_int, __gu_p___20);
< #line 41
<   goto ldv_52835;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52835;
<   }
<   ldv_52835: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___17 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___21 = (void *)tmp___17;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___21) = 18U;
< #line 41
<   goto ldv_52842;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(18, __gu_p___21);
< #line 41
<   goto ldv_52842;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(18U, __gu_p___21);
< #line 41
<   goto ldv_52842;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(18ULL, __gu_p___21);
< #line 41
<   goto ldv_52842;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52842;
<   }
<   ldv_52842: 
< #line 41
<   tmp___18 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___22 = (void *)tmp___18;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___22) = 4U;
< #line 41
<   goto ldv_52849;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___22);
< #line 41
<   goto ldv_52849;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___22);
< #line 41
<   goto ldv_52849;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___22);
< #line 41
<   goto ldv_52849;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52849;
<   }
<   ldv_52849: 
< #line 41
<   __gu_p___23 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___23) = (unsigned char )arg->max_epoch_size;
< #line 41
<   goto ldv_52856;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->max_epoch_size), __gu_p___23);
< #line 41
<   goto ldv_52856;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->max_epoch_size, __gu_p___23);
< #line 41
<   goto ldv_52856;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->max_epoch_size, __gu_p___23);
< #line 41
<   goto ldv_52856;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52856;
<   }
<   ldv_52856: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___19 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___24 = (void *)tmp___19;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___24) = 19U;
< #line 41
<   goto ldv_52863;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(19, __gu_p___24);
< #line 41
<   goto ldv_52863;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(19U, __gu_p___24);
< #line 41
<   goto ldv_52863;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(19ULL, __gu_p___24);
< #line 41
<   goto ldv_52863;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52863;
<   }
<   ldv_52863: 
< #line 41
<   tmp___20 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___25 = (void *)tmp___20;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___25) = 4U;
< #line 41
<   goto ldv_52870;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___25);
< #line 41
<   goto ldv_52870;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___25);
< #line 41
<   goto ldv_52870;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___25);
< #line 41
<   goto ldv_52870;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52870;
<   }
<   ldv_52870: 
< #line 41
<   __gu_p___26 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___26) = (unsigned char )arg->max_buffers;
< #line 41
<   goto ldv_52877;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->max_buffers), __gu_p___26);
< #line 41
<   goto ldv_52877;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->max_buffers, __gu_p___26);
< #line 41
<   goto ldv_52877;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->max_buffers, __gu_p___26);
< #line 41
<   goto ldv_52877;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52877;
<   }
<   ldv_52877: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___21 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___27 = (void *)tmp___21;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___27) = 20U;
< #line 41
<   goto ldv_52884;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(20, __gu_p___27);
< #line 41
<   goto ldv_52884;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(20U, __gu_p___27);
< #line 41
<   goto ldv_52884;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(20ULL, __gu_p___27);
< #line 41
<   goto ldv_52884;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52884;
<   }
<   ldv_52884: 
< #line 41
<   tmp___22 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___28 = (void *)tmp___22;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___28) = 4U;
< #line 41
<   goto ldv_52891;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___28);
< #line 41
<   goto ldv_52891;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___28);
< #line 41
<   goto ldv_52891;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___28);
< #line 41
<   goto ldv_52891;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52891;
<   }
<   ldv_52891: 
< #line 41
<   __gu_p___29 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___29) = (unsigned char )arg->unplug_watermark;
< #line 41
<   goto ldv_52898;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->unplug_watermark), __gu_p___29);
< #line 41
<   goto ldv_52898;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->unplug_watermark, __gu_p___29);
< #line 41
<   goto ldv_52898;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->unplug_watermark, __gu_p___29);
< #line 41
<   goto ldv_52898;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52898;
<   }
<   ldv_52898: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___23 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___30 = (void *)tmp___23;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___30) = 21U;
< #line 41
<   goto ldv_52905;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(21, __gu_p___30);
< #line 41
<   goto ldv_52905;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(21U, __gu_p___30);
< #line 41
<   goto ldv_52905;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(21ULL, __gu_p___30);
< #line 41
<   goto ldv_52905;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52905;
<   }
<   ldv_52905: 
< #line 41
<   tmp___24 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___31 = (void *)tmp___24;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___31) = 4U;
< #line 41
<   goto ldv_52912;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___31);
< #line 41
<   goto ldv_52912;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___31);
< #line 41
<   goto ldv_52912;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___31);
< #line 41
<   goto ldv_52912;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52912;
<   }
<   ldv_52912: 
< #line 41
<   __gu_p___32 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___32) = (unsigned char )arg->sndbuf_size;
< #line 41
<   goto ldv_52919;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->sndbuf_size), __gu_p___32);
< #line 41
<   goto ldv_52919;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->sndbuf_size, __gu_p___32);
< #line 41
<   goto ldv_52919;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->sndbuf_size, __gu_p___32);
< #line 41
<   goto ldv_52919;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52919;
<   }
<   ldv_52919: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___25 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___33 = (void *)tmp___25;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___33) = 22U;
< #line 41
<   goto ldv_52926;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(22, __gu_p___33);
< #line 41
<   goto ldv_52926;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(22U, __gu_p___33);
< #line 41
<   goto ldv_52926;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(22ULL, __gu_p___33);
< #line 41
<   goto ldv_52926;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52926;
<   }
<   ldv_52926: 
< #line 41
<   tmp___26 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___34 = (void *)tmp___26;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___34) = 4U;
< #line 41
<   goto ldv_52933;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___34);
< #line 41
<   goto ldv_52933;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___34);
< #line 41
<   goto ldv_52933;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___34);
< #line 41
<   goto ldv_52933;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52933;
<   }
<   ldv_52933: 
< #line 41
<   __gu_p___35 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___35) = (unsigned char )arg->ko_count;
< #line 41
<   goto ldv_52940;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->ko_count), __gu_p___35);
< #line 41
<   goto ldv_52940;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->ko_count, __gu_p___35);
< #line 41
<   goto ldv_52940;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->ko_count, __gu_p___35);
< #line 41
<   goto ldv_52940;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52940;
<   }
<   ldv_52940: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___27 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___36 = (void *)tmp___27;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___36) = 24U;
< #line 41
<   goto ldv_52947;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(24, __gu_p___36);
< #line 41
<   goto ldv_52947;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(24U, __gu_p___36);
< #line 41
<   goto ldv_52947;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(24ULL, __gu_p___36);
< #line 41
<   goto ldv_52947;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52947;
<   }
<   ldv_52947: 
< #line 41
<   tmp___28 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___37 = (void *)tmp___28;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___37) = 4U;
< #line 41
<   goto ldv_52954;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___37);
< #line 41
<   goto ldv_52954;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___37);
< #line 41
<   goto ldv_52954;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___37);
< #line 41
<   goto ldv_52954;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52954;
<   }
<   ldv_52954: 
< #line 41
<   __gu_p___38 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___38) = (unsigned char )arg->after_sb_0p;
< #line 41
<   goto ldv_52961;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->after_sb_0p), __gu_p___38);
< #line 41
<   goto ldv_52961;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->after_sb_0p, __gu_p___38);
< #line 41
<   goto ldv_52961;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->after_sb_0p, __gu_p___38);
< #line 41
<   goto ldv_52961;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52961;
<   }
<   ldv_52961: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___29 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___39 = (void *)tmp___29;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___39) = 25U;
< #line 41
<   goto ldv_52968;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(25, __gu_p___39);
< #line 41
<   goto ldv_52968;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(25U, __gu_p___39);
< #line 41
<   goto ldv_52968;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(25ULL, __gu_p___39);
< #line 41
<   goto ldv_52968;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52968;
---
> #line 137
>   tmp = nla_nest_start(skb, 4);
> #line 137
>   tla = tmp;
> #line 137
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 137
>     goto nla_put_failure;
>   } else {
> 
52094,52127c50873,50884
<   ldv_52968: 
< #line 41
<   tmp___30 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___40 = (void *)tmp___30;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___40) = 4U;
< #line 41
<   goto ldv_52975;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___40);
< #line 41
<   goto ldv_52975;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___40);
< #line 41
<   goto ldv_52975;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___40);
< #line 41
<   goto ldv_52975;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52975;
---
> #line 137
>   __min1 = 32;
> #line 137
>   __min2 = (int )(s->cpu_mask_len + 1U);
> #line 137
>   tmp___0 = nla_put(skb, 1, __min1 < __min2 ? __min1 : __min2, (void const   *)(& s->cpu_mask));
> #line 137
>   if (tmp___0 != 0) {
> #line 137
>     goto nla_put_failure;
>   } else {
> 
52129,52158c50886,50893
<   ldv_52975: 
< #line 41
<   __gu_p___41 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___41) = (unsigned char )arg->after_sb_1p;
< #line 41
<   goto ldv_52982;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->after_sb_1p), __gu_p___41);
< #line 41
<   goto ldv_52982;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->after_sb_1p, __gu_p___41);
< #line 41
<   goto ldv_52982;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->after_sb_1p, __gu_p___41);
< #line 41
<   goto ldv_52982;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52982;
---
> #line 137
>   tmp___1 = nla_put_u32(skb, 2, s->on_no_data);
> #line 137
>   if (tmp___1 != 0) {
> #line 137
>     goto nla_put_failure;
>   } else {
> 
52160,52195c50895,50905
<   ldv_52982: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___31 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___42 = (void *)tmp___31;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___42) = 26U;
< #line 41
<   goto ldv_52989;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(26, __gu_p___42);
< #line 41
<   goto ldv_52989;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(26U, __gu_p___42);
< #line 41
<   goto ldv_52989;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(26ULL, __gu_p___42);
< #line 41
<   goto ldv_52989;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52989;
---
> #line 137
>   nla_nest_end(skb, tla);
> #line 137
>   return (0);
>   nla_put_failure: ;
> #line 137
>   if ((unsigned long )tla != (unsigned long )((struct nlattr *)0)) {
> #line 137
>     nla_nest_cancel(skb, tla);
>   } else {
> 
52197,52230c50907,50966
<   ldv_52989: 
< #line 41
<   tmp___32 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___43 = (void *)tmp___32;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___43) = 4U;
< #line 41
<   goto ldv_52996;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___43);
< #line 41
<   goto ldv_52996;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___43);
< #line 41
<   goto ldv_52996;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___43);
< #line 41
<   goto ldv_52996;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_52996;
---
> #line 137
>   return (-90);
> }
> }
> #line 174 "include/linux/drbd_genl.h"
> static int net_conf_to_skb(struct sk_buff *skb , struct net_conf *s , bool const   exclude_sensitive ) 
> { 
>   struct nlattr *tla ;
>   struct nlattr *tmp ;
>   int __min1 ;
>   int __min2 ;
>   int tmp___0 ;
>   int __min1___0 ;
>   int __min2___0 ;
>   int tmp___1 ;
>   int __min1___1 ;
>   int __min2___1 ;
>   int tmp___2 ;
>   int __min1___2 ;
>   int __min2___2 ;
>   int tmp___3 ;
>   int __min1___3 ;
>   int __min2___3 ;
>   int tmp___4 ;
>   int tmp___5 ;
>   int tmp___6 ;
>   int tmp___7 ;
>   int tmp___8 ;
>   int tmp___9 ;
>   int tmp___10 ;
>   int tmp___11 ;
>   int tmp___12 ;
>   int tmp___13 ;
>   int tmp___14 ;
>   int tmp___15 ;
>   int tmp___16 ;
>   int tmp___17 ;
>   int tmp___18 ;
>   int tmp___19 ;
>   int tmp___20 ;
>   int tmp___21 ;
>   int tmp___22 ;
>   int tmp___23 ;
>   int tmp___24 ;
>   int tmp___25 ;
>   int tmp___26 ;
>   int tmp___27 ;
>   int tmp___28 ;
> 
>   {
> #line 142
>   tmp = nla_nest_start(skb, 5);
> #line 142
>   tla = tmp;
> #line 142
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52232,52261c50968,50984
<   ldv_52996: 
< #line 41
<   __gu_p___44 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___44) = (unsigned char )arg->after_sb_2p;
< #line 41
<   goto ldv_53003;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->after_sb_2p), __gu_p___44);
< #line 41
<   goto ldv_53003;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->after_sb_2p, __gu_p___44);
< #line 41
<   goto ldv_53003;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->after_sb_2p, __gu_p___44);
< #line 41
<   goto ldv_53003;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53003;
---
> #line 142
>   if (! ((_Bool )exclude_sensitive)) {
> #line 142
>     __min1 = 64;
> #line 142
>     __min2 = (int )(s->shared_secret_len + 1U);
> #line 142
>     tmp___0 = nla_put(skb, 1, __min1 < __min2 ? __min1 : __min2, (void const   *)(& s->shared_secret));
> #line 142
>     if (tmp___0 != 0) {
> #line 142
>       goto nla_put_failure;
>     } else {
> 
>     }
>   } else {
> 
52263,52298c50986,50997
<   ldv_53003: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___33 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___45 = (void *)tmp___33;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___45) = 39U;
< #line 41
<   goto ldv_53010;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(39, __gu_p___45);
< #line 41
<   goto ldv_53010;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(39U, __gu_p___45);
< #line 41
<   goto ldv_53010;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(39ULL, __gu_p___45);
< #line 41
<   goto ldv_53010;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53010;
---
> #line 142
>   __min1___0 = 64;
> #line 142
>   __min2___0 = (int )(s->cram_hmac_alg_len + 1U);
> #line 142
>   tmp___1 = nla_put(skb, 2, __min1___0 < __min2___0 ? __min1___0 : __min2___0, (void const   *)(& s->cram_hmac_alg));
> #line 142
>   if (tmp___1 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52300,52333c50999,51010
<   ldv_53010: 
< #line 41
<   tmp___34 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___46 = (void *)tmp___34;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___46) = 4U;
< #line 41
<   goto ldv_53017;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___46);
< #line 41
<   goto ldv_53017;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___46);
< #line 41
<   goto ldv_53017;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___46);
< #line 41
<   goto ldv_53017;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53017;
---
> #line 142
>   __min1___1 = 64;
> #line 142
>   __min2___1 = (int )(s->integrity_alg_len + 1U);
> #line 142
>   tmp___2 = nla_put(skb, 3, __min1___1 < __min2___1 ? __min1___1 : __min2___1, (void const   *)(& s->integrity_alg));
> #line 142
>   if (tmp___2 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52335,52364c51012,51023
<   ldv_53017: 
< #line 41
<   __gu_p___47 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___47) = (unsigned char )arg->rr_conflict;
< #line 41
<   goto ldv_53024;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->rr_conflict), __gu_p___47);
< #line 41
<   goto ldv_53024;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->rr_conflict, __gu_p___47);
< #line 41
<   goto ldv_53024;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->rr_conflict, __gu_p___47);
< #line 41
<   goto ldv_53024;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53024;
---
> #line 142
>   __min1___2 = 64;
> #line 142
>   __min2___2 = (int )(s->verify_alg_len + 1U);
> #line 142
>   tmp___3 = nla_put(skb, 4, __min1___2 < __min2___2 ? __min1___2 : __min2___2, (void const   *)(& s->verify_alg));
> #line 142
>   if (tmp___3 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52366,52401c51025,51036
<   ldv_53024: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___35 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___48 = (void *)tmp___35;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___48) = 40U;
< #line 41
<   goto ldv_53031;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(40, __gu_p___48);
< #line 41
<   goto ldv_53031;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(40U, __gu_p___48);
< #line 41
<   goto ldv_53031;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(40ULL, __gu_p___48);
< #line 41
<   goto ldv_53031;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53031;
---
> #line 142
>   __min1___3 = 64;
> #line 142
>   __min2___3 = (int )(s->csums_alg_len + 1U);
> #line 142
>   tmp___4 = nla_put(skb, 5, __min1___3 < __min2___3 ? __min1___3 : __min2___3, (void const   *)(& s->csums_alg));
> #line 142
>   if (tmp___4 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52403,52436c51038,51045
<   ldv_53031: 
< #line 41
<   tmp___36 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___49 = (void *)tmp___36;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___49) = 4U;
< #line 41
<   goto ldv_53038;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___49);
< #line 41
<   goto ldv_53038;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___49);
< #line 41
<   goto ldv_53038;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___49);
< #line 41
<   goto ldv_53038;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53038;
---
> #line 142
>   tmp___5 = nla_put_u32(skb, 6, s->wire_protocol);
> #line 142
>   if (tmp___5 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52438,52467c51047,51054
<   ldv_53038: 
< #line 41
<   __gu_p___50 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___50) = (unsigned char )arg->ping_timeo;
< #line 41
<   goto ldv_53045;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->ping_timeo), __gu_p___50);
< #line 41
<   goto ldv_53045;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->ping_timeo, __gu_p___50);
< #line 41
<   goto ldv_53045;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->ping_timeo, __gu_p___50);
< #line 41
<   goto ldv_53045;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53045;
---
> #line 142
>   tmp___6 = nla_put_u32(skb, 7, s->connect_int);
> #line 142
>   if (tmp___6 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52469,52504c51056,51063
<   ldv_53045: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___37 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___51 = (void *)tmp___37;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___51) = 67U;
< #line 41
<   goto ldv_53052;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(67, __gu_p___51);
< #line 41
<   goto ldv_53052;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(67U, __gu_p___51);
< #line 41
<   goto ldv_53052;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(67ULL, __gu_p___51);
< #line 41
<   goto ldv_53052;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53052;
---
> #line 142
>   tmp___7 = nla_put_u32(skb, 8, s->timeout);
> #line 142
>   if (tmp___7 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52506,52539c51065,51072
<   ldv_53052: 
< #line 41
<   tmp___38 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___52 = (void *)tmp___38;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___52) = 4U;
< #line 41
<   goto ldv_53059;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___52);
< #line 41
<   goto ldv_53059;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___52);
< #line 41
<   goto ldv_53059;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___52);
< #line 41
<   goto ldv_53059;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53059;
---
> #line 142
>   tmp___8 = nla_put_u32(skb, 9, s->ping_int);
> #line 142
>   if (tmp___8 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52541,52570c51074,51081
<   ldv_53059: 
< #line 41
<   __gu_p___53 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___53) = (unsigned char )arg->rcvbuf_size;
< #line 41
<   goto ldv_53066;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->rcvbuf_size), __gu_p___53);
< #line 41
<   goto ldv_53066;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->rcvbuf_size, __gu_p___53);
< #line 41
<   goto ldv_53066;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->rcvbuf_size, __gu_p___53);
< #line 41
<   goto ldv_53066;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53066;
---
> #line 142
>   tmp___9 = nla_put_u32(skb, 10, s->ping_timeo);
> #line 142
>   if (tmp___9 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52572,52607c51083,51090
<   ldv_53066: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___39 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___54 = (void *)tmp___39;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___54) = 81U;
< #line 41
<   goto ldv_53073;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(81, __gu_p___54);
< #line 41
<   goto ldv_53073;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(81U, __gu_p___54);
< #line 41
<   goto ldv_53073;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(81ULL, __gu_p___54);
< #line 41
<   goto ldv_53073;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53073;
---
> #line 142
>   tmp___10 = nla_put_u32(skb, 11, s->sndbuf_size);
> #line 142
>   if (tmp___10 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52609,52642c51092,51099
<   ldv_53073: 
< #line 41
<   tmp___40 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___55 = (void *)tmp___40;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___55) = 4U;
< #line 41
<   goto ldv_53080;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___55);
< #line 41
<   goto ldv_53080;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___55);
< #line 41
<   goto ldv_53080;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___55);
< #line 41
<   goto ldv_53080;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53080;
---
> #line 142
>   tmp___11 = nla_put_u32(skb, 12, s->rcvbuf_size);
> #line 142
>   if (tmp___11 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52644,52673c51101,51108
<   ldv_53080: 
< #line 41
<   __gu_p___56 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___56) = (unsigned char )arg->on_congestion;
< #line 41
<   goto ldv_53087;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->on_congestion), __gu_p___56);
< #line 41
<   goto ldv_53087;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->on_congestion, __gu_p___56);
< #line 41
<   goto ldv_53087;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->on_congestion, __gu_p___56);
< #line 41
<   goto ldv_53087;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53087;
---
> #line 142
>   tmp___12 = nla_put_u32(skb, 13, s->ko_count);
> #line 142
>   if (tmp___12 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52675,52710c51110,51117
<   ldv_53087: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___41 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___57 = (void *)tmp___41;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___57) = 82U;
< #line 41
<   goto ldv_53094;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(82, __gu_p___57);
< #line 41
<   goto ldv_53094;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(82U, __gu_p___57);
< #line 41
<   goto ldv_53094;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(82ULL, __gu_p___57);
< #line 41
<   goto ldv_53094;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53094;
---
> #line 142
>   tmp___13 = nla_put_u32(skb, 14, s->max_buffers);
> #line 142
>   if (tmp___13 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52712,52745c51119,51126
<   ldv_53094: 
< #line 41
<   tmp___42 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___58 = (void *)tmp___42;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___58) = 4U;
< #line 41
<   goto ldv_53101;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___58);
< #line 41
<   goto ldv_53101;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___58);
< #line 41
<   goto ldv_53101;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___58);
< #line 41
<   goto ldv_53101;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53101;
---
> #line 142
>   tmp___14 = nla_put_u32(skb, 15, s->max_epoch_size);
> #line 142
>   if (tmp___14 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52747,52776c51128,51135
<   ldv_53101: 
< #line 41
<   __gu_p___59 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___59) = (unsigned char )arg->cong_fill;
< #line 41
<   goto ldv_53108;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->cong_fill), __gu_p___59);
< #line 41
<   goto ldv_53108;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->cong_fill, __gu_p___59);
< #line 41
<   goto ldv_53108;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->cong_fill, __gu_p___59);
< #line 41
<   goto ldv_53108;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53108;
---
> #line 142
>   tmp___15 = nla_put_u32(skb, 16, s->unplug_watermark);
> #line 142
>   if (tmp___15 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52778,52813c51137,51144
<   ldv_53108: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___43 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___60 = (void *)tmp___43;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___60) = 83U;
< #line 41
<   goto ldv_53115;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(83, __gu_p___60);
< #line 41
<   goto ldv_53115;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(83U, __gu_p___60);
< #line 41
<   goto ldv_53115;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(83ULL, __gu_p___60);
< #line 41
<   goto ldv_53115;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53115;
---
> #line 142
>   tmp___16 = nla_put_u32(skb, 17, s->after_sb_0p);
> #line 142
>   if (tmp___16 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52815,52848c51146,51153
<   ldv_53115: 
< #line 41
<   tmp___44 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___61 = (void *)tmp___44;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___61) = 4U;
< #line 41
<   goto ldv_53122;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(4, __gu_p___61);
< #line 41
<   goto ldv_53122;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(4U, __gu_p___61);
< #line 41
<   goto ldv_53122;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(4ULL, __gu_p___61);
< #line 41
<   goto ldv_53122;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53122;
---
> #line 142
>   tmp___17 = nla_put_u32(skb, 18, s->after_sb_1p);
> #line 142
>   if (tmp___17 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52850,52879c51155,51162
<   ldv_53122: 
< #line 41
<   __gu_p___62 = (void *)tags;
< #line 41
<   switch (4UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___62) = (unsigned char )arg->cong_extents;
< #line 41
<   goto ldv_53129;
<   case 2UL: 
< #line 41
<   put_unaligned_le16((int )((unsigned short )arg->cong_extents), __gu_p___62);
< #line 41
<   goto ldv_53129;
<   case 4UL: 
< #line 41
<   put_unaligned_le32((unsigned int )arg->cong_extents, __gu_p___62);
< #line 41
<   goto ldv_53129;
<   case 8UL: 
< #line 41
<   put_unaligned_le64((unsigned long long )arg->cong_extents, __gu_p___62);
< #line 41
<   goto ldv_53129;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53129;
---
> #line 142
>   tmp___18 = nla_put_u32(skb, 19, s->after_sb_2p);
> #line 142
>   if (tmp___18 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52881,52916c51164,51171
<   ldv_53129: 
< #line 41
<   tags = tags + 4U;
< #line 41
<   tmp___45 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___63 = (void *)tmp___45;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___63) = 60U;
< #line 41
<   goto ldv_53136;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(41020, __gu_p___63);
< #line 41
<   goto ldv_53136;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(41020U, __gu_p___63);
< #line 41
<   goto ldv_53136;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(41020ULL, __gu_p___63);
< #line 41
<   goto ldv_53136;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53136;
---
> #line 142
>   tmp___19 = nla_put_u32(skb, 20, s->rr_conflict);
> #line 142
>   if (tmp___19 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52918,52951c51173,51180
<   ldv_53136: 
< #line 41
<   tmp___46 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___64 = (void *)tmp___46;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___64) = 1U;
< #line 41
<   goto ldv_53143;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(1, __gu_p___64);
< #line 41
<   goto ldv_53143;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(1U, __gu_p___64);
< #line 41
<   goto ldv_53143;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(1ULL, __gu_p___64);
< #line 41
<   goto ldv_53143;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53143;
---
> #line 142
>   tmp___20 = nla_put_u32(skb, 21, s->on_congestion);
> #line 142
>   if (tmp___20 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52953,52990c51182,51189
<   ldv_53143: 
< #line 41
<   *((char *)tags) = (char )arg->mind_af;
< #line 41
<   tags = tags + 1U;
< #line 41
<   tmp___47 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___65 = (void *)tmp___47;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___65) = 27U;
< #line 41
<   goto ldv_53150;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(32795, __gu_p___65);
< #line 41
<   goto ldv_53150;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(32795U, __gu_p___65);
< #line 41
<   goto ldv_53150;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(32795ULL, __gu_p___65);
< #line 41
<   goto ldv_53150;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53150;
---
> #line 142
>   tmp___21 = nla_put_u32(skb, 22, s->cong_fill);
> #line 142
>   if (tmp___21 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
52992,53025c51191,51198
<   ldv_53150: 
< #line 41
<   tmp___48 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___66 = (void *)tmp___48;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___66) = 1U;
< #line 41
<   goto ldv_53157;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(1, __gu_p___66);
< #line 41
<   goto ldv_53157;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(1U, __gu_p___66);
< #line 41
<   goto ldv_53157;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(1ULL, __gu_p___66);
< #line 41
<   goto ldv_53157;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53157;
---
> #line 142
>   tmp___22 = nla_put_u32(skb, 23, s->cong_extents);
> #line 142
>   if (tmp___22 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
53027,53064c51200,51207
<   ldv_53157: 
< #line 41
<   *((char *)tags) = (char )arg->want_lose;
< #line 41
<   tags = tags + 1U;
< #line 41
<   tmp___49 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___67 = (void *)tmp___49;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___67) = 28U;
< #line 41
<   goto ldv_53164;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(32796, __gu_p___67);
< #line 41
<   goto ldv_53164;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(32796U, __gu_p___67);
< #line 41
<   goto ldv_53164;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(32796ULL, __gu_p___67);
< #line 41
<   goto ldv_53164;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53164;
---
> #line 142
>   tmp___23 = nla_put_u8(skb, 24, (int )((u8 )s->two_primaries));
> #line 142
>   if (tmp___23 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
53066,53099c51209,51216
<   ldv_53164: 
< #line 41
<   tmp___50 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___68 = (void *)tmp___50;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___68) = 1U;
< #line 41
<   goto ldv_53171;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(1, __gu_p___68);
< #line 41
<   goto ldv_53171;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(1U, __gu_p___68);
< #line 41
<   goto ldv_53171;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(1ULL, __gu_p___68);
< #line 41
<   goto ldv_53171;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53171;
---
> #line 142
>   tmp___24 = nla_put_u8(skb, 25, (int )((u8 )s->discard_my_data));
> #line 142
>   if (tmp___24 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
53101,53138c51218,51225
<   ldv_53171: 
< #line 41
<   *((char *)tags) = (char )arg->two_primaries;
< #line 41
<   tags = tags + 1U;
< #line 41
<   tmp___51 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___69 = (void *)tmp___51;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___69) = 41U;
< #line 41
<   goto ldv_53178;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(32809, __gu_p___69);
< #line 41
<   goto ldv_53178;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(32809U, __gu_p___69);
< #line 41
<   goto ldv_53178;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(32809ULL, __gu_p___69);
< #line 41
<   goto ldv_53178;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53178;
---
> #line 142
>   tmp___25 = nla_put_u8(skb, 26, (int )((u8 )s->tcp_cork));
> #line 142
>   if (tmp___25 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
53140,53173c51227,51234
<   ldv_53178: 
< #line 41
<   tmp___52 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___70 = (void *)tmp___52;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___70) = 1U;
< #line 41
<   goto ldv_53185;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(1, __gu_p___70);
< #line 41
<   goto ldv_53185;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(1U, __gu_p___70);
< #line 41
<   goto ldv_53185;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(1ULL, __gu_p___70);
< #line 41
<   goto ldv_53185;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53185;
---
> #line 142
>   tmp___26 = nla_put_u8(skb, 27, (int )((u8 )s->always_asbp));
> #line 142
>   if (tmp___26 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
53175,53212c51236,51243
<   ldv_53185: 
< #line 41
<   *((char *)tags) = (char )arg->always_asbp;
< #line 41
<   tags = tags + 1U;
< #line 41
<   tmp___53 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___71 = (void *)tmp___53;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___71) = 61U;
< #line 41
<   goto ldv_53192;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(32829, __gu_p___71);
< #line 41
<   goto ldv_53192;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(32829U, __gu_p___71);
< #line 41
<   goto ldv_53192;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(32829ULL, __gu_p___71);
< #line 41
<   goto ldv_53192;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53192;
---
> #line 142
>   tmp___27 = nla_put_u8(skb, 28, (int )((u8 )s->tentative));
> #line 142
>   if (tmp___27 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
53214,53247c51245,51252
<   ldv_53192: 
< #line 41
<   tmp___54 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___72 = (void *)tmp___54;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___72) = 1U;
< #line 41
<   goto ldv_53199;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(1, __gu_p___72);
< #line 41
<   goto ldv_53199;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(1U, __gu_p___72);
< #line 41
<   goto ldv_53199;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(1ULL, __gu_p___72);
< #line 41
<   goto ldv_53199;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53199;
---
> #line 142
>   tmp___28 = nla_put_u8(skb, 29, (int )((u8 )s->use_rle));
> #line 142
>   if (tmp___28 != 0) {
> #line 142
>     goto nla_put_failure;
>   } else {
> 
53249,53286c51254,51264
<   ldv_53199: 
< #line 41
<   *((char *)tags) = (char )arg->no_cork;
< #line 41
<   tags = tags + 1U;
< #line 41
<   tmp___55 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___73 = (void *)tmp___55;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___73) = 62U;
< #line 41
<   goto ldv_53206;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(41022, __gu_p___73);
< #line 41
<   goto ldv_53206;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(41022U, __gu_p___73);
< #line 41
<   goto ldv_53206;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(41022ULL, __gu_p___73);
< #line 41
<   goto ldv_53206;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53206;
---
> #line 142
>   nla_nest_end(skb, tla);
> #line 142
>   return (0);
>   nla_put_failure: ;
> #line 142
>   if ((unsigned long )tla != (unsigned long )((struct nlattr *)0)) {
> #line 142
>     nla_nest_cancel(skb, tla);
>   } else {
> 
53288,53321c51266,51287
<   ldv_53206: 
< #line 41
<   tmp___56 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___74 = (void *)tmp___56;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___74) = 1U;
< #line 41
<   goto ldv_53213;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(1, __gu_p___74);
< #line 41
<   goto ldv_53213;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(1U, __gu_p___74);
< #line 41
<   goto ldv_53213;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(1ULL, __gu_p___74);
< #line 41
<   goto ldv_53213;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53213;
---
> #line 142
>   return (-90);
> }
> }
> #line 237 "include/linux/drbd_genl.h"
> static int timeout_parms_to_skb(struct sk_buff *skb , struct timeout_parms *s , bool const   exclude_sensitive ) 
> { 
>   struct nlattr *tla ;
>   struct nlattr *tmp ;
>   int tmp___0 ;
> 
>   {
> #line 235
>   tmp = nla_nest_start(skb, 11);
> #line 235
>   tla = tmp;
> #line 235
>   if ((unsigned long )tla == (unsigned long )((struct nlattr *)0)) {
> #line 235
>     goto nla_put_failure;
>   } else {
> 
53323,53360c51289,51296
<   ldv_53213: 
< #line 41
<   *((char *)tags) = (char )arg->auto_sndbuf_size;
< #line 41
<   tags = tags + 1U;
< #line 41
<   tmp___57 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___75 = (void *)tmp___57;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___75) = 70U;
< #line 41
<   goto ldv_53220;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(41030, __gu_p___75);
< #line 41
<   goto ldv_53220;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(41030U, __gu_p___75);
< #line 41
<   goto ldv_53220;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(41030ULL, __gu_p___75);
< #line 41
<   goto ldv_53220;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53220;
---
> #line 235
>   tmp___0 = nla_put_u32(skb, 1, s->timeout_type);
> #line 235
>   if (tmp___0 != 0) {
> #line 235
>     goto nla_put_failure;
>   } else {
> 
53362,53395c51298,51308
<   ldv_53220: 
< #line 41
<   tmp___58 = tags;
< #line 41
<   tags = tags + 1;
< #line 41
<   __gu_p___76 = (void *)tmp___58;
< #line 41
<   switch (2UL) {
<   case 1UL: 
< #line 41
<   *((u8 *)__gu_p___76) = 1U;
< #line 41
<   goto ldv_53227;
<   case 2UL: 
< #line 41
<   put_unaligned_le16(1, __gu_p___76);
< #line 41
<   goto ldv_53227;
<   case 4UL: 
< #line 41
<   put_unaligned_le32(1U, __gu_p___76);
< #line 41
<   goto ldv_53227;
<   case 8UL: 
< #line 41
<   put_unaligned_le64(1ULL, __gu_p___76);
< #line 41
<   goto ldv_53227;
<   default: 
< #line 41
<   __bad_unaligned_access_size();
< #line 41
<   goto ldv_53227;
---
> #line 235
>   nla_nest_end(skb, tla);
> #line 235
>   return (0);
>   nla_put_failure: ;
> #line 235
>   if ((unsigned long )tla != (unsigned long )((struct nlattr *)0)) {
> #line 235
>     nla_nest_cancel(skb, tla);
>   } else {
> 
53397,53403c51310,51323
<   ldv_53227: 
< #line 41
<   *((char *)tags) = (char )arg->dry_run;
< #line 41
<   tags = tags + 1U;
< #line 41
<   return (tags);
---
> #line 235
>   return (-90);
> }
> }
> #line 237 "include/linux/drbd_genl.h"
> __inline static int timeout_parms_to_priv_skb(struct sk_buff *skb , struct timeout_parms *s ) 
> { 
>   int tmp ;
> 
>   {
> #line 235
>   tmp = timeout_parms_to_skb(skb, s, 0);
> #line 235
>   return (tmp);
53405a51326,51333
> #line 135
> static void set_disk_conf_defaults(struct disk_conf *x ) ;
> #line 135 "include/linux/drbd_genl.h"
> static void set_disk_conf_defaults(struct disk_conf *x ) 
> { 
> 
> 
>   {
53407,53479c51335,51377
< static unsigned short *syncer_conf_to_tags(struct drbd_conf *mdev , struct syncer_conf *arg ,
<                                            unsigned short *tags ) ;
< #line 104 "include/linux/drbd_nl.h"
< static unsigned short *syncer_conf_to_tags(struct drbd_conf *mdev , struct syncer_conf *arg ,
<                                            unsigned short *tags ) 
< { 
<   void *__gu_p ;
<   unsigned short *tmp ;
<   void *__gu_p___0 ;
<   unsigned short *tmp___0 ;
<   void *__gu_p___1 ;
<   void *__gu_p___2 ;
<   unsigned short *tmp___1 ;
<   void *__gu_p___3 ;
<   unsigned short *tmp___2 ;
<   void *__gu_p___4 ;
<   void *__gu_p___5 ;
<   unsigned short *tmp___3 ;
<   void *__gu_p___6 ;
<   unsigned short *tmp___4 ;
<   void *__gu_p___7 ;
<   void *__gu_p___8 ;
<   unsigned short *tmp___5 ;
<   void *__gu_p___9 ;
<   unsigned short *tmp___6 ;
<   size_t __len ;
<   void *__ret ;
<   void *__gu_p___10 ;
<   unsigned short *tmp___7 ;
<   void *__gu_p___11 ;
<   unsigned short *tmp___8 ;
<   size_t __len___0 ;
<   void *__ret___0 ;
<   void *__gu_p___12 ;
<   unsigned short *tmp___9 ;
<   void *__gu_p___13 ;
<   unsigned short *tmp___10 ;
<   size_t __len___1 ;
<   void *__ret___1 ;
<   void *__gu_p___14 ;
<   unsigned short *tmp___11 ;
<   void *__gu_p___15 ;
<   unsigned short *tmp___12 ;
<   void *__gu_p___16 ;
<   unsigned short *tmp___13 ;
<   void *__gu_p___17 ;
<   unsigned short *tmp___14 ;
<   void *__gu_p___18 ;
<   void *__gu_p___19 ;
<   unsigned short *tmp___15 ;
<   void *__gu_p___20 ;
<   unsigned short *tmp___16 ;
<   void *__gu_p___21 ;
<   void *__gu_p___22 ;
<   unsigned short *tmp___17 ;
<   void *__gu_p___23 ;
<   unsigned short *tmp___18 ;
<   void *__gu_p___24 ;
<   void *__gu_p___25 ;
<   unsigned short *tmp___19 ;
<   void *__gu_p___26 ;
<   unsigned short *tmp___20 ;
<   void *__gu_p___27 ;
<   void *__gu_p___28 ;
<   unsigned short *tmp___21 ;
<   void *__gu_p___29 ;
<   unsigned short *tmp___22 ;
<   void *__gu_p___30 ;
<   void *__gu_p___31 ;
<   unsigned short *tmp___23 ;
<   void *__gu_p___32 ;
<   unsigned short *tmp___24 ;
<   void *__gu_p___33 ;
---
>   x->on_io_error = 2U;
> #line 104
>   x->fencing = 0U;
> #line 104
>   x->resync_rate = 250U;
> #line 104
>   x->resync_after = -1;
> #line 104
>   x->al_extents = 1237U;
> #line 104
>   x->c_plan_ahead = 20U;
> #line 104
>   x->c_delay_target = 10U;
> #line 104
>   x->c_fill_target = 100U;
> #line 104
>   x->c_max_rate = 102400U;
> #line 104
>   x->c_min_rate = 250U;
> #line 104
>   x->disk_barrier = 0;
> #line 104
>   x->disk_flushes = 1;
> #line 104
>   x->disk_drain = 1;
> #line 104
>   x->md_flushes = 1;
> #line 104
>   x->disk_timeout = 0U;
> #line 104
>   x->read_balancing = 0U;
> #line 104
>   x->al_updates = 1;
> #line 105
>   return;
> }
> }
> #line 140
> static void set_res_opts_defaults(struct res_opts *x ) ;
> #line 140 "include/linux/drbd_genl.h"
> static void set_res_opts_defaults(struct res_opts *x ) 
> { 
> 
53482,54228c51380,51494
< #line 85
<   tmp = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p = (void *)tmp;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p) = 30U;
< #line 85
<   goto ldv_53324;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(30, __gu_p);
< #line 85
<   goto ldv_53324;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(30U, __gu_p);
< #line 85
<   goto ldv_53324;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(30ULL, __gu_p);
< #line 85
<   goto ldv_53324;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53324;
<   }
<   ldv_53324: 
< #line 85
<   tmp___0 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___0 = (void *)tmp___0;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___0) = 4U;
< #line 85
<   goto ldv_53331;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(4, __gu_p___0);
< #line 85
<   goto ldv_53331;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(4U, __gu_p___0);
< #line 85
<   goto ldv_53331;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(4ULL, __gu_p___0);
< #line 85
<   goto ldv_53331;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53331;
<   }
<   ldv_53331: 
< #line 85
<   __gu_p___1 = (void *)tags;
< #line 85
<   switch (4UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___1) = (unsigned char )arg->rate;
< #line 85
<   goto ldv_53338;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->rate), __gu_p___1);
< #line 85
<   goto ldv_53338;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->rate, __gu_p___1);
< #line 85
<   goto ldv_53338;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->rate, __gu_p___1);
< #line 85
<   goto ldv_53338;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53338;
<   }
<   ldv_53338: 
< #line 85
<   tags = tags + 4U;
< #line 85
<   tmp___1 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___2 = (void *)tmp___1;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___2) = 31U;
< #line 85
<   goto ldv_53345;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(31, __gu_p___2);
< #line 85
<   goto ldv_53345;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(31U, __gu_p___2);
< #line 85
<   goto ldv_53345;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(31ULL, __gu_p___2);
< #line 85
<   goto ldv_53345;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53345;
<   }
<   ldv_53345: 
< #line 85
<   tmp___2 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___3 = (void *)tmp___2;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___3) = 4U;
< #line 85
<   goto ldv_53352;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(4, __gu_p___3);
< #line 85
<   goto ldv_53352;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(4U, __gu_p___3);
< #line 85
<   goto ldv_53352;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(4ULL, __gu_p___3);
< #line 85
<   goto ldv_53352;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53352;
<   }
<   ldv_53352: 
< #line 85
<   __gu_p___4 = (void *)tags;
< #line 85
<   switch (4UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___4) = (unsigned char )arg->after;
< #line 85
<   goto ldv_53359;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->after), __gu_p___4);
< #line 85
<   goto ldv_53359;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->after, __gu_p___4);
< #line 85
<   goto ldv_53359;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->after, __gu_p___4);
< #line 85
<   goto ldv_53359;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53359;
<   }
<   ldv_53359: 
< #line 85
<   tags = tags + 4U;
< #line 85
<   tmp___3 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___5 = (void *)tmp___3;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___5) = 32U;
< #line 85
<   goto ldv_53366;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(32, __gu_p___5);
< #line 85
<   goto ldv_53366;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(32U, __gu_p___5);
< #line 85
<   goto ldv_53366;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(32ULL, __gu_p___5);
< #line 85
<   goto ldv_53366;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53366;
<   }
<   ldv_53366: 
< #line 85
<   tmp___4 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___6 = (void *)tmp___4;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___6) = 4U;
< #line 85
<   goto ldv_53373;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(4, __gu_p___6);
< #line 85
<   goto ldv_53373;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(4U, __gu_p___6);
< #line 85
<   goto ldv_53373;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(4ULL, __gu_p___6);
< #line 85
<   goto ldv_53373;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53373;
<   }
<   ldv_53373: 
< #line 85
<   __gu_p___7 = (void *)tags;
< #line 85
<   switch (4UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___7) = (unsigned char )arg->al_extents;
< #line 85
<   goto ldv_53380;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->al_extents), __gu_p___7);
< #line 85
<   goto ldv_53380;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->al_extents, __gu_p___7);
< #line 85
<   goto ldv_53380;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->al_extents, __gu_p___7);
< #line 85
<   goto ldv_53380;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53380;
<   }
<   ldv_53380: 
< #line 85
<   tags = tags + 4U;
< #line 85
<   tmp___5 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___8 = (void *)tmp___5;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___8) = 52U;
< #line 85
<   goto ldv_53387;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(49204, __gu_p___8);
< #line 85
<   goto ldv_53387;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(49204U, __gu_p___8);
< #line 85
<   goto ldv_53387;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(49204ULL, __gu_p___8);
< #line 85
<   goto ldv_53387;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53387;
<   }
<   ldv_53387: 
< #line 85
<   tmp___6 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___9 = (void *)tmp___6;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___9) = (unsigned char )arg->verify_alg_len;
< #line 85
<   goto ldv_53394;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->verify_alg_len), __gu_p___9);
< #line 85
<   goto ldv_53394;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->verify_alg_len, __gu_p___9);
< #line 85
<   goto ldv_53394;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->verify_alg_len, __gu_p___9);
< #line 85
<   goto ldv_53394;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53394;
<   }
<   ldv_53394: 
< #line 85
<   __len = (size_t )arg->verify_alg_len;
< #line 85
<   __ret = __builtin_memcpy((void *)tags, (void const   *)(& arg->verify_alg), __len);
< #line 85
<   tags = tags + (unsigned long )arg->verify_alg_len;
< #line 85
<   tmp___7 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___10 = (void *)tmp___7;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___10) = 51U;
< #line 85
<   goto ldv_53404;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(49203, __gu_p___10);
< #line 85
<   goto ldv_53404;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(49203U, __gu_p___10);
< #line 85
<   goto ldv_53404;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(49203ULL, __gu_p___10);
< #line 85
<   goto ldv_53404;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53404;
<   }
<   ldv_53404: 
< #line 85
<   tmp___8 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___11 = (void *)tmp___8;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___11) = (unsigned char )arg->cpu_mask_len;
< #line 85
<   goto ldv_53411;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->cpu_mask_len), __gu_p___11);
< #line 85
<   goto ldv_53411;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->cpu_mask_len, __gu_p___11);
< #line 85
<   goto ldv_53411;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->cpu_mask_len, __gu_p___11);
< #line 85
<   goto ldv_53411;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53411;
<   }
<   ldv_53411: 
< #line 85
<   __len___0 = (size_t )arg->cpu_mask_len;
< #line 85
<   __ret___0 = __builtin_memcpy((void *)tags, (void const   *)(& arg->cpu_mask), __len___0);
< #line 85
<   tags = tags + (unsigned long )arg->cpu_mask_len;
< #line 85
<   tmp___9 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___12 = (void *)tmp___9;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___12) = 64U;
< #line 85
<   goto ldv_53421;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(49216, __gu_p___12);
< #line 85
<   goto ldv_53421;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(49216U, __gu_p___12);
< #line 85
<   goto ldv_53421;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(49216ULL, __gu_p___12);
< #line 85
<   goto ldv_53421;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53421;
<   }
<   ldv_53421: 
< #line 85
<   tmp___10 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___13 = (void *)tmp___10;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___13) = (unsigned char )arg->csums_alg_len;
< #line 85
<   goto ldv_53428;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->csums_alg_len), __gu_p___13);
< #line 85
<   goto ldv_53428;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->csums_alg_len, __gu_p___13);
< #line 85
<   goto ldv_53428;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->csums_alg_len, __gu_p___13);
< #line 85
<   goto ldv_53428;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53428;
<   }
<   ldv_53428: 
< #line 85
<   __len___1 = (size_t )arg->csums_alg_len;
< #line 85
<   __ret___1 = __builtin_memcpy((void *)tags, (void const   *)(& arg->csums_alg), __len___1);
< #line 85
<   tags = tags + (unsigned long )arg->csums_alg_len;
< #line 85
<   tmp___11 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___14 = (void *)tmp___11;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___14) = 65U;
< #line 85
<   goto ldv_53438;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(32833, __gu_p___14);
< #line 85
<   goto ldv_53438;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(32833U, __gu_p___14);
< #line 85
<   goto ldv_53438;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(32833ULL, __gu_p___14);
< #line 85
<   goto ldv_53438;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53438;
<   }
<   ldv_53438: 
< #line 85
<   tmp___12 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___15 = (void *)tmp___12;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___15) = 1U;
< #line 85
<   goto ldv_53445;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(1, __gu_p___15);
< #line 85
<   goto ldv_53445;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(1U, __gu_p___15);
< #line 85
<   goto ldv_53445;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(1ULL, __gu_p___15);
< #line 85
<   goto ldv_53445;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53445;
<   }
<   ldv_53445: 
< #line 85
<   *((char *)tags) = (char )arg->use_rle;
< #line 85
<   tags = tags + 1U;
< #line 85
<   tmp___13 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___16 = (void *)tmp___13;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___16) = 75U;
< #line 85
<   goto ldv_53452;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(75, __gu_p___16);
< #line 85
<   goto ldv_53452;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(75U, __gu_p___16);
< #line 85
<   goto ldv_53452;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(75ULL, __gu_p___16);
< #line 85
<   goto ldv_53452;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53452;
<   }
<   ldv_53452: 
< #line 85
<   tmp___14 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___17 = (void *)tmp___14;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___17) = 4U;
< #line 85
<   goto ldv_53459;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(4, __gu_p___17);
< #line 85
<   goto ldv_53459;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(4U, __gu_p___17);
< #line 85
<   goto ldv_53459;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(4ULL, __gu_p___17);
< #line 85
<   goto ldv_53459;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53459;
<   }
<   ldv_53459: 
< #line 85
<   __gu_p___18 = (void *)tags;
< #line 85
<   switch (4UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___18) = (unsigned char )arg->on_no_data;
< #line 85
<   goto ldv_53466;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->on_no_data), __gu_p___18);
< #line 85
<   goto ldv_53466;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->on_no_data, __gu_p___18);
< #line 85
<   goto ldv_53466;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->on_no_data, __gu_p___18);
< #line 85
<   goto ldv_53466;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53466;
<   }
<   ldv_53466: 
< #line 85
<   tags = tags + 4U;
< #line 85
<   tmp___15 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___19 = (void *)tmp___15;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___19) = 76U;
< #line 85
<   goto ldv_53473;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(76, __gu_p___19);
< #line 85
<   goto ldv_53473;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(76U, __gu_p___19);
< #line 85
<   goto ldv_53473;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(76ULL, __gu_p___19);
< #line 85
<   goto ldv_53473;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53473;
---
> #line 137
>   memset((void *)(& x->cpu_mask), 0, 32UL);
> #line 137
>   x->cpu_mask_len = 0U;
> #line 137
>   x->on_no_data = 0U;
> #line 138
>   return;
> }
> }
> #line 174
> static void set_net_conf_defaults(struct net_conf *x ) ;
> #line 174 "include/linux/drbd_genl.h"
> static void set_net_conf_defaults(struct net_conf *x ) 
> { 
> 
> 
>   {
> #line 142
>   memset((void *)(& x->shared_secret), 0, 64UL);
> #line 142
>   x->shared_secret_len = 0U;
> #line 142
>   memset((void *)(& x->cram_hmac_alg), 0, 64UL);
> #line 142
>   x->cram_hmac_alg_len = 0U;
> #line 142
>   memset((void *)(& x->integrity_alg), 0, 64UL);
> #line 142
>   x->integrity_alg_len = 0U;
> #line 142
>   memset((void *)(& x->verify_alg), 0, 64UL);
> #line 142
>   x->verify_alg_len = 0U;
> #line 142
>   memset((void *)(& x->csums_alg), 0, 64UL);
> #line 142
>   x->csums_alg_len = 0U;
> #line 142
>   x->wire_protocol = 3U;
> #line 142
>   x->connect_int = 10U;
> #line 142
>   x->timeout = 60U;
> #line 142
>   x->ping_int = 10U;
> #line 142
>   x->ping_timeo = 5U;
> #line 142
>   x->sndbuf_size = 0U;
> #line 142
>   x->rcvbuf_size = 0U;
> #line 142
>   x->ko_count = 7U;
> #line 142
>   x->max_buffers = 2048U;
> #line 142
>   x->max_epoch_size = 2048U;
> #line 142
>   x->unplug_watermark = 128U;
> #line 142
>   x->after_sb_0p = 0U;
> #line 142
>   x->after_sb_1p = 0U;
> #line 142
>   x->after_sb_2p = 0U;
> #line 142
>   x->rr_conflict = 0U;
> #line 142
>   x->on_congestion = 0U;
> #line 142
>   x->cong_fill = 0U;
> #line 142
>   x->cong_extents = 1237U;
> #line 142
>   x->two_primaries = 0;
> #line 142
>   x->tcp_cork = 1;
> #line 142
>   x->always_asbp = 0;
> #line 142
>   x->use_rle = 1;
> #line 143
>   return;
> }
> }
> #line 89 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static char *drbd_m_holder  =    (char *)"Hands off! this is DRBD\'s meta data device.";
> #line 114 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static struct drbd_config_context adm_ctx  ;
> #line 116 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static void drbd_adm_send_reply(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct nlmsghdr *tmp ;
>   void *tmp___0 ;
>   void *tmp___1 ;
>   int tmp___2 ;
> 
>   {
> #line 118
>   tmp = nlmsg_hdr((struct sk_buff  const  *)skb);
> #line 118
>   tmp___0 = nlmsg_data((struct nlmsghdr  const  *)tmp);
> #line 118
>   tmp___1 = genlmsg_data((struct genlmsghdr  const  *)tmp___0);
> #line 118
>   genlmsg_end(skb, tmp___1);
> #line 119
>   tmp___2 = genlmsg_reply(skb, info);
> #line 119
>   if (tmp___2 != 0) {
> #line 120
>     printk("\vdrbd: error sending genl reply\n");
>   } else {
> 
54230,54263c51496,51517
<   ldv_53473: 
< #line 85
<   tmp___16 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___20 = (void *)tmp___16;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___20) = 4U;
< #line 85
<   goto ldv_53480;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(4, __gu_p___20);
< #line 85
<   goto ldv_53480;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(4U, __gu_p___20);
< #line 85
<   goto ldv_53480;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(4ULL, __gu_p___20);
< #line 85
<   goto ldv_53480;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53480;
---
> #line 121
>   return;
> }
> }
> #line 125 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_msg_put_info(char const   *info ) 
> { 
>   struct sk_buff *skb ;
>   struct nlattr *nla ;
>   int err ;
> 
>   {
> #line 127
>   skb = adm_ctx.reply_skb;
> #line 129
>   err = -90;
> #line 131
>   if ((unsigned long )info == (unsigned long )((char const   *)0) || (int )((signed char )*info) == 0) {
> #line 132
>     return (0);
>   } else {
> 
54265,54294c51519,51526
<   ldv_53480: 
< #line 85
<   __gu_p___21 = (void *)tags;
< #line 85
<   switch (4UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___21) = (unsigned char )arg->c_plan_ahead;
< #line 85
<   goto ldv_53487;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->c_plan_ahead), __gu_p___21);
< #line 85
<   goto ldv_53487;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->c_plan_ahead, __gu_p___21);
< #line 85
<   goto ldv_53487;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->c_plan_ahead, __gu_p___21);
< #line 85
<   goto ldv_53487;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53487;
---
> #line 134
>   nla = nla_nest_start(skb, 1);
> #line 135
>   if ((unsigned long )nla == (unsigned long )((struct nlattr *)0)) {
> #line 136
>     return (err);
>   } else {
> 
54296,54331c51528,51538
<   ldv_53487: 
< #line 85
<   tags = tags + 4U;
< #line 85
<   tmp___17 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___22 = (void *)tmp___17;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___22) = 77U;
< #line 85
<   goto ldv_53494;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(77, __gu_p___22);
< #line 85
<   goto ldv_53494;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(77U, __gu_p___22);
< #line 85
<   goto ldv_53494;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(77ULL, __gu_p___22);
< #line 85
<   goto ldv_53494;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53494;
---
> #line 138
>   err = nla_put_string(skb, 16385, info);
> #line 139
>   if (err != 0) {
> #line 140
>     nla_nest_cancel(skb, nla);
> #line 141
>     return (err);
>   } else {
> #line 143
>     nla_nest_end(skb, nla);
54333,54366c51540,51589
<   ldv_53494: 
< #line 85
<   tmp___18 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___23 = (void *)tmp___18;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___23) = 4U;
< #line 85
<   goto ldv_53501;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(4, __gu_p___23);
< #line 85
<   goto ldv_53501;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(4U, __gu_p___23);
< #line 85
<   goto ldv_53501;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(4ULL, __gu_p___23);
< #line 85
<   goto ldv_53501;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53501;
---
> #line 144
>   return (0);
> }
> }
> #line 155 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static int drbd_adm_prepare(struct sk_buff *skb , struct genl_info *info , unsigned int flags ) 
> { 
>   struct drbd_genlmsghdr *d_in ;
>   u8 cmd ;
>   int err ;
>   bool tmp ;
>   int tmp___0 ;
>   void *tmp___1 ;
>   struct nlattr *nla ;
>   void *tmp___2 ;
>   int tmp___3 ;
>   int tmp___4 ;
>   int tmp___5 ;
>   void *tmp___6 ;
>   int tmp___7 ;
>   void *tmp___8 ;
> 
>   {
> #line 158
>   d_in = (struct drbd_genlmsghdr *)info->userhdr;
> #line 159
>   cmd = (info->genlhdr)->cmd;
> #line 162
>   memset((void *)(& adm_ctx), 0, 64UL);
> #line 165
>   if ((unsigned int )cmd != 2U) {
> #line 165
>     tmp = capable(12);
> #line 165
>     if (tmp) {
> #line 165
>       tmp___0 = 0;
>     } else {
> #line 165
>       tmp___0 = 1;
>     }
> #line 165
>     if (tmp___0) {
> #line 166
>       return (-1);
>     } else {
> 
>     }
>   } else {
> 
54368,54397c51591,51600
<   ldv_53501: 
< #line 85
<   __gu_p___24 = (void *)tags;
< #line 85
<   switch (4UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___24) = (unsigned char )arg->c_delay_target;
< #line 85
<   goto ldv_53508;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->c_delay_target), __gu_p___24);
< #line 85
<   goto ldv_53508;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->c_delay_target, __gu_p___24);
< #line 85
<   goto ldv_53508;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->c_delay_target, __gu_p___24);
< #line 85
<   goto ldv_53508;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53508;
---
> #line 168
>   adm_ctx.reply_skb = genlmsg_new(3776UL, 208U);
> #line 169
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 170
>     err = -12;
> #line 171
>     goto fail;
>   } else {
> 
54399,54434c51602,51613
<   ldv_53508: 
< #line 85
<   tags = tags + 4U;
< #line 85
<   tmp___19 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___25 = (void *)tmp___19;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___25) = 78U;
< #line 85
<   goto ldv_53515;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(78, __gu_p___25);
< #line 85
<   goto ldv_53515;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(78U, __gu_p___25);
< #line 85
<   goto ldv_53515;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(78ULL, __gu_p___25);
< #line 85
<   goto ldv_53515;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53515;
---
> #line 174
>   tmp___1 = genlmsg_put_reply(adm_ctx.reply_skb, info, & drbd_genl_family, 0, (int )cmd);
> #line 174
>   adm_ctx.reply_dh = (struct drbd_genlmsghdr *)tmp___1;
> #line 178
>   if ((unsigned long )adm_ctx.reply_dh == (unsigned long )((struct drbd_genlmsghdr *)0)) {
> #line 179
>     err = -12;
> #line 180
>     goto fail;
>   } else {
> 
54436,54469c51615,51699
<   ldv_53515: 
< #line 85
<   tmp___20 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___26 = (void *)tmp___20;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___26) = 4U;
< #line 85
<   goto ldv_53522;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(4, __gu_p___26);
< #line 85
<   goto ldv_53522;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(4U, __gu_p___26);
< #line 85
<   goto ldv_53522;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(4ULL, __gu_p___26);
< #line 85
<   goto ldv_53522;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53522;
---
> #line 183
>   (adm_ctx.reply_dh)->minor = d_in->minor;
> #line 184
>   (adm_ctx.reply_dh)->ldv_49550.ret_code = 101;
> #line 186
>   adm_ctx.volume = 4294967295U;
> #line 187
>   if ((unsigned long )*(info->attrs + 2UL) != (unsigned long )((struct nlattr *)0)) {
> #line 190
>     err = drbd_cfg_context_from_attrs(0, info);
> #line 191
>     if (err != 0) {
> #line 192
>       goto fail;
>     } else {
> 
>     }
> #line 196
>     err = nla_put_nohdr(adm_ctx.reply_skb, (int )(*(info->attrs + 2UL))->nla_len,
>                         (void const   *)*(info->attrs + 2UL));
> #line 199
>     if (err != 0) {
> #line 200
>       goto fail;
>     } else {
> 
>     }
> #line 203
>     nla = nested_attr_tb[1];
> #line 204
>     if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 205
>       adm_ctx.volume = nla_get_u32((struct nlattr  const  *)nla);
>     } else {
> 
>     }
> #line 206
>     nla = nested_attr_tb[2];
> #line 207
>     if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 208
>       tmp___2 = nla_data((struct nlattr  const  *)nla);
> #line 208
>       adm_ctx.resource_name = (char *)tmp___2;
>     } else {
> 
>     }
> #line 209
>     adm_ctx.my_addr = nested_attr_tb[3];
> #line 210
>     adm_ctx.peer_addr = nested_attr_tb[4];
> #line 211
>     if ((unsigned long )adm_ctx.my_addr != (unsigned long )((struct nlattr *)0)) {
> #line 211
>       tmp___3 = nla_len((struct nlattr  const  *)adm_ctx.my_addr);
> #line 211
>       if ((unsigned int )tmp___3 > 128U) {
> #line 215
>         err = -22;
> #line 216
>         goto fail;
>       } else {
> #line 211
>         goto _L;
>       }
>     } else
>     _L: /* CIL Label */ 
> #line 211
>     if ((unsigned long )adm_ctx.peer_addr != (unsigned long )((struct nlattr *)0)) {
> #line 211
>       tmp___4 = nla_len((struct nlattr  const  *)adm_ctx.peer_addr);
> #line 211
>       if ((unsigned int )tmp___4 > 128U) {
> #line 215
>         err = -22;
> #line 216
>         goto fail;
>       } else {
> 
>       }
>     } else {
> 
>     }
>   } else {
> 
54471,54500c51701,51714
<   ldv_53522: 
< #line 85
<   __gu_p___27 = (void *)tags;
< #line 85
<   switch (4UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___27) = (unsigned char )arg->c_fill_target;
< #line 85
<   goto ldv_53529;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->c_fill_target), __gu_p___27);
< #line 85
<   goto ldv_53529;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->c_fill_target, __gu_p___27);
< #line 85
<   goto ldv_53529;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->c_fill_target, __gu_p___27);
< #line 85
<   goto ldv_53529;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53529;
---
> #line 220
>   adm_ctx.minor = d_in->minor;
> #line 221
>   adm_ctx.mdev = minor_to_mdev(d_in->minor);
> #line 222
>   adm_ctx.tconn = conn_get_by_name((char const   *)adm_ctx.resource_name);
> #line 224
>   if ((unsigned long )adm_ctx.mdev == (unsigned long )((struct drbd_conf *)0) && (int )flags & 1) {
> #line 225
>     drbd_msg_put_info("unknown minor");
> #line 226
>     return (127);
>   } else {
> 
54502,54537c51716,51723
<   ldv_53529: 
< #line 85
<   tags = tags + 4U;
< #line 85
<   tmp___21 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___28 = (void *)tmp___21;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___28) = 79U;
< #line 85
<   goto ldv_53536;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(79, __gu_p___28);
< #line 85
<   goto ldv_53536;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(79U, __gu_p___28);
< #line 85
<   goto ldv_53536;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(79ULL, __gu_p___28);
< #line 85
<   goto ldv_53536;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53536;
---
> #line 228
>   if ((unsigned long )adm_ctx.tconn == (unsigned long )((struct drbd_tconn *)0) && (flags & 2U) != 0U) {
> #line 229
>     drbd_msg_put_info("unknown resource");
> #line 230
>     return (162);
>   } else {
> 
54539,54572c51725,51770
<   ldv_53536: 
< #line 85
<   tmp___22 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___29 = (void *)tmp___22;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___29) = 4U;
< #line 85
<   goto ldv_53543;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(4, __gu_p___29);
< #line 85
<   goto ldv_53543;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(4U, __gu_p___29);
< #line 85
<   goto ldv_53543;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(4ULL, __gu_p___29);
< #line 85
<   goto ldv_53543;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53543;
---
> #line 233
>   if ((flags & 4U) != 0U) {
> #line 234
>     if ((unsigned long )adm_ctx.tconn != (unsigned long )((struct drbd_tconn *)0) && (flags & 2U) == 0U) {
> #line 235
>       drbd_msg_put_info("no resource name expected");
> #line 236
>       return (162);
>     } else {
> 
>     }
> #line 238
>     if ((unsigned long )adm_ctx.mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 239
>       drbd_msg_put_info("no minor number expected");
> #line 240
>       return (162);
>     } else {
> 
>     }
> #line 242
>     if ((unsigned long )adm_ctx.my_addr != (unsigned long )((struct nlattr *)0) && (unsigned long )adm_ctx.peer_addr != (unsigned long )((struct nlattr *)0)) {
> #line 243
>       tmp___5 = nla_len((struct nlattr  const  *)adm_ctx.peer_addr);
> #line 243
>       tmp___6 = nla_data((struct nlattr  const  *)adm_ctx.peer_addr);
> #line 243
>       tmp___7 = nla_len((struct nlattr  const  *)adm_ctx.my_addr);
> #line 243
>       tmp___8 = nla_data((struct nlattr  const  *)adm_ctx.my_addr);
> #line 243
>       adm_ctx.tconn = conn_get_by_addrs(tmp___8, tmp___7, tmp___6, tmp___5);
>     } else {
> 
>     }
> #line 247
>     if ((unsigned long )adm_ctx.tconn == (unsigned long )((struct drbd_tconn *)0)) {
> #line 248
>       drbd_msg_put_info("unknown connection");
> #line 249
>       return (162);
>     } else {
> 
>     }
>   } else {
> 
54574,54603c51772,51782
<   ldv_53543: 
< #line 85
<   __gu_p___30 = (void *)tags;
< #line 85
<   switch (4UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___30) = (unsigned char )arg->c_max_rate;
< #line 85
<   goto ldv_53550;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->c_max_rate), __gu_p___30);
< #line 85
<   goto ldv_53550;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->c_max_rate, __gu_p___30);
< #line 85
<   goto ldv_53550;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->c_max_rate, __gu_p___30);
< #line 85
<   goto ldv_53550;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53550;
---
> #line 254
>   if (((unsigned long )adm_ctx.mdev != (unsigned long )((struct drbd_conf *)0) && (unsigned long )adm_ctx.tconn != (unsigned long )((struct drbd_tconn *)0)) && (unsigned long )(adm_ctx.mdev)->tconn != (unsigned long )adm_ctx.tconn) {
> #line 256
>     printk("\frequest: minor=%u, resource=%s; but that minor belongs to connection %s\n",
>            adm_ctx.minor, adm_ctx.resource_name, ((adm_ctx.mdev)->tconn)->name);
> #line 259
>     drbd_msg_put_info("minor exists in different resource");
> #line 260
>     return (162);
>   } else {
> 
54605,54640c51784,51794
<   ldv_53550: 
< #line 85
<   tags = tags + 4U;
< #line 85
<   tmp___23 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___31 = (void *)tmp___23;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___31) = 80U;
< #line 85
<   goto ldv_53557;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(80, __gu_p___31);
< #line 85
<   goto ldv_53557;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(80U, __gu_p___31);
< #line 85
<   goto ldv_53557;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(80ULL, __gu_p___31);
< #line 85
<   goto ldv_53557;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53557;
---
> #line 262
>   if (((unsigned long )adm_ctx.mdev != (unsigned long )((struct drbd_conf *)0) && adm_ctx.volume != 4294967295U) && adm_ctx.volume != (unsigned int )(adm_ctx.mdev)->vnr) {
> #line 265
>     printk("\frequest: minor=%u, volume=%u; but that minor is volume %u in %s\n",
>            adm_ctx.minor, adm_ctx.volume, (adm_ctx.mdev)->vnr, ((adm_ctx.mdev)->tconn)->name);
> #line 268
>     drbd_msg_put_info("minor exists as different volume");
> #line 269
>     return (162);
>   } else {
> 
54642,54675c51796,51820
<   ldv_53557: 
< #line 85
<   tmp___24 = tags;
< #line 85
<   tags = tags + 1;
< #line 85
<   __gu_p___32 = (void *)tmp___24;
< #line 85
<   switch (2UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___32) = 4U;
< #line 85
<   goto ldv_53564;
<   case 2UL: 
< #line 85
<   put_unaligned_le16(4, __gu_p___32);
< #line 85
<   goto ldv_53564;
<   case 4UL: 
< #line 85
<   put_unaligned_le32(4U, __gu_p___32);
< #line 85
<   goto ldv_53564;
<   case 8UL: 
< #line 85
<   put_unaligned_le64(4ULL, __gu_p___32);
< #line 85
<   goto ldv_53564;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53564;
---
> #line 272
>   return (101);
>   fail: 
> #line 275
>   nlmsg_free(adm_ctx.reply_skb);
> #line 276
>   adm_ctx.reply_skb = 0;
> #line 277
>   return (err);
> }
> }
> #line 280 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static int drbd_adm_finish(struct genl_info *info , int retcode ) 
> { 
> 
> 
>   {
> #line 282
>   if ((unsigned long )adm_ctx.tconn != (unsigned long )((struct drbd_tconn *)0)) {
> #line 283
>     kref_put(& (adm_ctx.tconn)->kref, & conn_destroy);
> #line 284
>     adm_ctx.tconn = 0;
>   } else {
> 
54677,54706c51822,51827
<   ldv_53564: 
< #line 85
<   __gu_p___33 = (void *)tags;
< #line 85
<   switch (4UL) {
<   case 1UL: 
< #line 85
<   *((u8 *)__gu_p___33) = (unsigned char )arg->c_min_rate;
< #line 85
<   goto ldv_53571;
<   case 2UL: 
< #line 85
<   put_unaligned_le16((int )((unsigned short )arg->c_min_rate), __gu_p___33);
< #line 85
<   goto ldv_53571;
<   case 4UL: 
< #line 85
<   put_unaligned_le32((unsigned int )arg->c_min_rate, __gu_p___33);
< #line 85
<   goto ldv_53571;
<   case 8UL: 
< #line 85
<   put_unaligned_le64((unsigned long long )arg->c_min_rate, __gu_p___33);
< #line 85
<   goto ldv_53571;
<   default: 
< #line 85
<   __bad_unaligned_access_size();
< #line 85
<   goto ldv_53571;
---
> #line 287
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 288
>     return (-12);
>   } else {
> 
54708,54712c51829,51834
<   ldv_53571: 
< #line 85
<   tags = tags + 4U;
< #line 85
<   return (tags);
---
> #line 290
>   (adm_ctx.reply_dh)->ldv_49550.ret_code = retcode;
> #line 291
>   drbd_adm_send_reply(adm_ctx.reply_skb, info);
> #line 292
>   return (0);
54715,54726c51837,51840
< #line 116
< static unsigned short *get_state_to_tags(struct drbd_conf *mdev , struct get_state *arg ,
<                                          unsigned short *tags ) ;
< #line 116 "include/linux/drbd_nl.h"
< static unsigned short *get_state_to_tags(struct drbd_conf *mdev , struct get_state *arg ,
<                                          unsigned short *tags ) 
< { 
<   void *__gu_p ;
<   unsigned short *tmp ;
<   void *__gu_p___0 ;
<   unsigned short *tmp___0 ;
<   void *__gu_p___1 ;
---
> #line 295 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static void setup_khelper_env(struct drbd_tconn *tconn , char **envp ) 
> { 
>   char *afs ;
54729,54796c51843,51848
< #line 114
<   tmp = tags;
< #line 114
<   tags = tags + 1;
< #line 114
<   __gu_p = (void *)tmp;
< #line 114
<   switch (2UL) {
<   case 1UL: 
< #line 114
<   *((u8 *)__gu_p) = 33U;
< #line 114
<   goto ldv_53659;
<   case 2UL: 
< #line 114
<   put_unaligned_le16(33, __gu_p);
< #line 114
<   goto ldv_53659;
<   case 4UL: 
< #line 114
<   put_unaligned_le32(33U, __gu_p);
< #line 114
<   goto ldv_53659;
<   case 8UL: 
< #line 114
<   put_unaligned_le64(33ULL, __gu_p);
< #line 114
<   goto ldv_53659;
<   default: 
< #line 114
<   __bad_unaligned_access_size();
< #line 114
<   goto ldv_53659;
<   }
<   ldv_53659: 
< #line 114
<   tmp___0 = tags;
< #line 114
<   tags = tags + 1;
< #line 114
<   __gu_p___0 = (void *)tmp___0;
< #line 114
<   switch (2UL) {
<   case 1UL: 
< #line 114
<   *((u8 *)__gu_p___0) = 4U;
< #line 114
<   goto ldv_53666;
<   case 2UL: 
< #line 114
<   put_unaligned_le16(4, __gu_p___0);
< #line 114
<   goto ldv_53666;
<   case 4UL: 
< #line 114
<   put_unaligned_le32(4U, __gu_p___0);
< #line 114
<   goto ldv_53666;
<   case 8UL: 
< #line 114
<   put_unaligned_le64(4ULL, __gu_p___0);
< #line 114
<   goto ldv_53666;
<   default: 
< #line 114
<   __bad_unaligned_access_size();
< #line 114
<   goto ldv_53666;
---
> #line 300
>   if (tconn->my_addr_len == 0 || tconn->peer_addr_len == 0) {
> #line 301
>     return;
>   } else {
> 
54798,54822c51850,51865
<   ldv_53666: 
< #line 114
<   __gu_p___1 = (void *)tags;
< #line 114
<   switch (4UL) {
<   case 1UL: 
< #line 114
<   *((u8 *)__gu_p___1) = (unsigned char )arg->state_i;
< #line 114
<   goto ldv_53673;
<   case 2UL: 
< #line 114
<   put_unaligned_le16((int )((unsigned short )arg->state_i), __gu_p___1);
< #line 114
<   goto ldv_53673;
<   case 4UL: 
< #line 114
<   put_unaligned_le32((unsigned int )arg->state_i, __gu_p___1);
< #line 114
<   goto ldv_53673;
<   case 8UL: 
< #line 114
<   put_unaligned_le64((unsigned long long )arg->state_i, __gu_p___1);
< #line 114
<   goto ldv_53673;
---
> #line 303
>   switch ((int )((struct sockaddr *)(& tconn->peer_addr))->sa_family) {
>   case 10: 
> #line 305
>   afs = (char *)"ipv6";
> #line 306
>   snprintf(*(envp + 4UL), 60UL, "DRBD_PEER_ADDRESS=%pI6", & ((struct sockaddr_in6 *)(& tconn->peer_addr))->sin6_addr);
> #line 308
>   goto ldv_52883;
>   case 2: 
> #line 310
>   afs = (char *)"ipv4";
> #line 311
>   snprintf(*(envp + 4UL), 60UL, "DRBD_PEER_ADDRESS=%pI4", & ((struct sockaddr_in *)(& tconn->peer_addr))->sin_addr);
> #line 313
>   goto ldv_52883;
54824,54827c51867,51870
< #line 114
<   __bad_unaligned_access_size();
< #line 114
<   goto ldv_53673;
---
> #line 315
>   afs = (char *)"ssocks";
> #line 316
>   snprintf(*(envp + 4UL), 60UL, "DRBD_PEER_ADDRESS=%pI4", & ((struct sockaddr_in *)(& tconn->peer_addr))->sin_addr);
54829,54833c51872,51876
<   ldv_53673: 
< #line 114
<   tags = tags + 4U;
< #line 114
<   return (tags);
---
>   ldv_52883: 
> #line 319
>   snprintf(*(envp + 3UL), 20UL, "DRBD_PEER_AF=%s", afs);
> #line 320
>   return;
54836,54840c51879
< #line 142 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void drbd_bcast_ev_helper(struct drbd_conf *mdev , char *helper_name ) ;
< #line 143
< void drbd_nl_send_reply(struct cn_msg *req , int ret_code ) ;
< #line 145 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
---
> #line 322 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
54843a51883,51884
>   char __constr_expr_0[20] ;
>   char __constr_expr_1[60] ;
54845,54847d51885
<   char af[20U] ;
<   char ad[60U] ;
<   char *afs ;
54848a51887,51888
>   struct drbd_tconn *tconn ;
>   struct sib_info sib ;
54852,54853c51892
<   int tmp___1 ;
<   struct task_struct *tmp___2 ;
---
>   struct task_struct *tmp___1 ;
54856c51895,52055
< #line 147
---
> #line 324
>   __constr_expr_0[0] = (char)0;
> #line 324
>   __constr_expr_0[1] = (char)0;
> #line 324
>   __constr_expr_0[2] = (char)0;
> #line 324
>   __constr_expr_0[3] = (char)0;
> #line 324
>   __constr_expr_0[4] = (char)0;
> #line 324
>   __constr_expr_0[5] = (char)0;
> #line 324
>   __constr_expr_0[6] = (char)0;
> #line 324
>   __constr_expr_0[7] = (char)0;
> #line 324
>   __constr_expr_0[8] = (char)0;
> #line 324
>   __constr_expr_0[9] = (char)0;
> #line 324
>   __constr_expr_0[10] = (char)0;
> #line 324
>   __constr_expr_0[11] = (char)0;
> #line 324
>   __constr_expr_0[12] = (char)0;
> #line 324
>   __constr_expr_0[13] = (char)0;
> #line 324
>   __constr_expr_0[14] = (char)0;
> #line 324
>   __constr_expr_0[15] = (char)0;
> #line 324
>   __constr_expr_0[16] = (char)0;
> #line 324
>   __constr_expr_0[17] = (char)0;
> #line 324
>   __constr_expr_0[18] = (char)0;
> #line 324
>   __constr_expr_0[19] = (char)0;
> #line 324
>   __constr_expr_1[0] = (char)0;
> #line 324
>   __constr_expr_1[1] = (char)0;
> #line 324
>   __constr_expr_1[2] = (char)0;
> #line 324
>   __constr_expr_1[3] = (char)0;
> #line 324
>   __constr_expr_1[4] = (char)0;
> #line 324
>   __constr_expr_1[5] = (char)0;
> #line 324
>   __constr_expr_1[6] = (char)0;
> #line 324
>   __constr_expr_1[7] = (char)0;
> #line 324
>   __constr_expr_1[8] = (char)0;
> #line 324
>   __constr_expr_1[9] = (char)0;
> #line 324
>   __constr_expr_1[10] = (char)0;
> #line 324
>   __constr_expr_1[11] = (char)0;
> #line 324
>   __constr_expr_1[12] = (char)0;
> #line 324
>   __constr_expr_1[13] = (char)0;
> #line 324
>   __constr_expr_1[14] = (char)0;
> #line 324
>   __constr_expr_1[15] = (char)0;
> #line 324
>   __constr_expr_1[16] = (char)0;
> #line 324
>   __constr_expr_1[17] = (char)0;
> #line 324
>   __constr_expr_1[18] = (char)0;
> #line 324
>   __constr_expr_1[19] = (char)0;
> #line 324
>   __constr_expr_1[20] = (char)0;
> #line 324
>   __constr_expr_1[21] = (char)0;
> #line 324
>   __constr_expr_1[22] = (char)0;
> #line 324
>   __constr_expr_1[23] = (char)0;
> #line 324
>   __constr_expr_1[24] = (char)0;
> #line 324
>   __constr_expr_1[25] = (char)0;
> #line 324
>   __constr_expr_1[26] = (char)0;
> #line 324
>   __constr_expr_1[27] = (char)0;
> #line 324
>   __constr_expr_1[28] = (char)0;
> #line 324
>   __constr_expr_1[29] = (char)0;
> #line 324
>   __constr_expr_1[30] = (char)0;
> #line 324
>   __constr_expr_1[31] = (char)0;
> #line 324
>   __constr_expr_1[32] = (char)0;
> #line 324
>   __constr_expr_1[33] = (char)0;
> #line 324
>   __constr_expr_1[34] = (char)0;
> #line 324
>   __constr_expr_1[35] = (char)0;
> #line 324
>   __constr_expr_1[36] = (char)0;
> #line 324
>   __constr_expr_1[37] = (char)0;
> #line 324
>   __constr_expr_1[38] = (char)0;
> #line 324
>   __constr_expr_1[39] = (char)0;
> #line 324
>   __constr_expr_1[40] = (char)0;
> #line 324
>   __constr_expr_1[41] = (char)0;
> #line 324
>   __constr_expr_1[42] = (char)0;
> #line 324
>   __constr_expr_1[43] = (char)0;
> #line 324
>   __constr_expr_1[44] = (char)0;
> #line 324
>   __constr_expr_1[45] = (char)0;
> #line 324
>   __constr_expr_1[46] = (char)0;
> #line 324
>   __constr_expr_1[47] = (char)0;
> #line 324
>   __constr_expr_1[48] = (char)0;
> #line 324
>   __constr_expr_1[49] = (char)0;
> #line 324
>   __constr_expr_1[50] = (char)0;
> #line 324
>   __constr_expr_1[51] = (char)0;
> #line 324
>   __constr_expr_1[52] = (char)0;
> #line 324
>   __constr_expr_1[53] = (char)0;
> #line 324
>   __constr_expr_1[54] = (char)0;
> #line 324
>   __constr_expr_1[55] = (char)0;
> #line 324
>   __constr_expr_1[56] = (char)0;
> #line 324
>   __constr_expr_1[57] = (char)0;
> #line 324
>   __constr_expr_1[58] = (char)0;
> #line 324
>   __constr_expr_1[59] = (char)0;
> #line 324
54858c52057
< #line 147
---
> #line 324
54860c52059
< #line 147
---
> #line 324
54862,54866c52061,52065
< #line 147
<   envp[3] = 0;
< #line 147
<   envp[4] = 0;
< #line 147
---
> #line 324
>   envp[3] = (char *)(& __constr_expr_0);
> #line 324
>   envp[4] = (char *)(& __constr_expr_1);
> #line 324
54868c52067
< #line 155
---
> #line 331
54870c52069
< #line 155
---
> #line 331
54872c52071
< #line 155
---
> #line 331
54874c52073
< #line 155
---
> #line 331
54876c52075,52077
< #line 158
---
> #line 332
>   tconn = mdev->tconn;
> #line 336
54878,54881c52079,52082
< #line 158
<   if ((unsigned long )tmp == (unsigned long )mdev->worker.task) {
< #line 159
<     drbd_set_flag(mdev, CALLBACK_PENDING);
---
> #line 336
>   if ((unsigned long )tmp == (unsigned long )tconn->worker.task) {
> #line 337
>     set_bit(11U, (unsigned long volatile   *)(& tconn->flags));
54885c52086
< #line 161
---
> #line 339
54887c52088
< #line 161
---
> #line 339
54889,54927c52090,52092
< #line 163
<   tmp___1 = get_net_conf(mdev);
< #line 163
<   if (tmp___1 != 0) {
< #line 164
<     switch ((int )((struct sockaddr *)(& (mdev->net_conf)->peer_addr))->sa_family) {
<     case 10: 
< #line 166
<     afs = (char *)"ipv6";
< #line 167
<     snprintf((char *)(& ad), 60UL, "DRBD_PEER_ADDRESS=%pI6", & ((struct sockaddr_in6 *)(& (mdev->net_conf)->peer_addr))->sin6_addr);
< #line 169
<     goto ldv_54015;
<     case 2: 
< #line 171
<     afs = (char *)"ipv4";
< #line 172
<     snprintf((char *)(& ad), 60UL, "DRBD_PEER_ADDRESS=%pI4", & ((struct sockaddr_in *)(& (mdev->net_conf)->peer_addr))->sin_addr);
< #line 174
<     goto ldv_54015;
<     default: 
< #line 176
<     afs = (char *)"ssocks";
< #line 177
<     snprintf((char *)(& ad), 60UL, "DRBD_PEER_ADDRESS=%pI4", & ((struct sockaddr_in *)(& (mdev->net_conf)->peer_addr))->sin_addr);
<     }
<     ldv_54015: 
< #line 180
<     snprintf((char *)(& af), 20UL, "DRBD_PEER_AF=%s", afs);
< #line 181
<     envp[3] = (char *)(& af);
< #line 182
<     envp[4] = (char *)(& ad);
< #line 183
<     put_net_conf(mdev);
<   } else {
< 
<   }
< #line 188
---
> #line 340
>   setup_khelper_env(tconn, (char **)(& envp));
> #line 344
54929c52094
< #line 190
---
> #line 346
54932,54934c52097,52103
< #line 192
<   drbd_bcast_ev_helper(mdev, cmd);
< #line 193
---
> #line 347
>   sib.sib_reason = SIB_HELPER_PRE;
> #line 348
>   sib.ldv_51335.ldv_51330.helper_name = cmd;
> #line 349
>   drbd_bcast_event(mdev, (struct sib_info  const  *)(& sib));
> #line 350
54937c52106
< #line 194
---
> #line 351
54939c52108
< #line 195
---
> #line 352
54943c52112
< #line 199
---
> #line 356
54948,54953c52117,52128
< #line 203
<   tmp___2 = get_current();
< #line 203
<   if ((unsigned long )tmp___2 == (unsigned long )mdev->worker.task) {
< #line 204
<     drbd_clear_flag(mdev, CALLBACK_PENDING);
---
> #line 359
>   sib.sib_reason = SIB_HELPER_POST;
> #line 360
>   sib.ldv_51335.ldv_51330.helper_exit_code = (unsigned int )ret;
> #line 361
>   drbd_bcast_event(mdev, (struct sib_info  const  *)(& sib));
> #line 363
>   tmp___1 = get_current();
> #line 363
>   if ((unsigned long )tmp___1 == (unsigned long )tconn->worker.task) {
> #line 364
>     clear_bit(11, (unsigned long volatile   *)(& tconn->flags));
54957c52132
< #line 206
---
> #line 366
54959c52134
< #line 207
---
> #line 367
54964c52139
< #line 209
---
> #line 369
54968,54969c52143,52144
< #line 212 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< enum drbd_disk_state drbd_try_outdate_peer(struct drbd_conf *mdev ) 
---
> #line 372 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int conn_khelper(struct drbd_tconn *tconn , char *cmd ) 
54971,54979c52146,52150
<   char *ex_to_string ;
<   int r ;
<   enum drbd_disk_state nps ;
<   enum drbd_fencing_p fp ;
<   int tmp ;
<   union drbd_state val ;
<   union drbd_state mask ;
<   union drbd_state val___0 ;
<   union drbd_state mask___0 ;
---
>   char *envp[6U] ;
>   char __constr_expr_0[20] ;
>   char __constr_expr_1[60] ;
>   char *argv[4U] ;
>   int ret ;
54982,54987c52153,52356
< #line 219
<   if (*((unsigned int *)mdev + 569UL) != 49152U) {
< #line 219
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->state.pdsk == D_UNKNOWN ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
<             219);
---
> #line 374
>   __constr_expr_0[0] = (char)0;
> #line 374
>   __constr_expr_0[1] = (char)0;
> #line 374
>   __constr_expr_0[2] = (char)0;
> #line 374
>   __constr_expr_0[3] = (char)0;
> #line 374
>   __constr_expr_0[4] = (char)0;
> #line 374
>   __constr_expr_0[5] = (char)0;
> #line 374
>   __constr_expr_0[6] = (char)0;
> #line 374
>   __constr_expr_0[7] = (char)0;
> #line 374
>   __constr_expr_0[8] = (char)0;
> #line 374
>   __constr_expr_0[9] = (char)0;
> #line 374
>   __constr_expr_0[10] = (char)0;
> #line 374
>   __constr_expr_0[11] = (char)0;
> #line 374
>   __constr_expr_0[12] = (char)0;
> #line 374
>   __constr_expr_0[13] = (char)0;
> #line 374
>   __constr_expr_0[14] = (char)0;
> #line 374
>   __constr_expr_0[15] = (char)0;
> #line 374
>   __constr_expr_0[16] = (char)0;
> #line 374
>   __constr_expr_0[17] = (char)0;
> #line 374
>   __constr_expr_0[18] = (char)0;
> #line 374
>   __constr_expr_0[19] = (char)0;
> #line 374
>   __constr_expr_1[0] = (char)0;
> #line 374
>   __constr_expr_1[1] = (char)0;
> #line 374
>   __constr_expr_1[2] = (char)0;
> #line 374
>   __constr_expr_1[3] = (char)0;
> #line 374
>   __constr_expr_1[4] = (char)0;
> #line 374
>   __constr_expr_1[5] = (char)0;
> #line 374
>   __constr_expr_1[6] = (char)0;
> #line 374
>   __constr_expr_1[7] = (char)0;
> #line 374
>   __constr_expr_1[8] = (char)0;
> #line 374
>   __constr_expr_1[9] = (char)0;
> #line 374
>   __constr_expr_1[10] = (char)0;
> #line 374
>   __constr_expr_1[11] = (char)0;
> #line 374
>   __constr_expr_1[12] = (char)0;
> #line 374
>   __constr_expr_1[13] = (char)0;
> #line 374
>   __constr_expr_1[14] = (char)0;
> #line 374
>   __constr_expr_1[15] = (char)0;
> #line 374
>   __constr_expr_1[16] = (char)0;
> #line 374
>   __constr_expr_1[17] = (char)0;
> #line 374
>   __constr_expr_1[18] = (char)0;
> #line 374
>   __constr_expr_1[19] = (char)0;
> #line 374
>   __constr_expr_1[20] = (char)0;
> #line 374
>   __constr_expr_1[21] = (char)0;
> #line 374
>   __constr_expr_1[22] = (char)0;
> #line 374
>   __constr_expr_1[23] = (char)0;
> #line 374
>   __constr_expr_1[24] = (char)0;
> #line 374
>   __constr_expr_1[25] = (char)0;
> #line 374
>   __constr_expr_1[26] = (char)0;
> #line 374
>   __constr_expr_1[27] = (char)0;
> #line 374
>   __constr_expr_1[28] = (char)0;
> #line 374
>   __constr_expr_1[29] = (char)0;
> #line 374
>   __constr_expr_1[30] = (char)0;
> #line 374
>   __constr_expr_1[31] = (char)0;
> #line 374
>   __constr_expr_1[32] = (char)0;
> #line 374
>   __constr_expr_1[33] = (char)0;
> #line 374
>   __constr_expr_1[34] = (char)0;
> #line 374
>   __constr_expr_1[35] = (char)0;
> #line 374
>   __constr_expr_1[36] = (char)0;
> #line 374
>   __constr_expr_1[37] = (char)0;
> #line 374
>   __constr_expr_1[38] = (char)0;
> #line 374
>   __constr_expr_1[39] = (char)0;
> #line 374
>   __constr_expr_1[40] = (char)0;
> #line 374
>   __constr_expr_1[41] = (char)0;
> #line 374
>   __constr_expr_1[42] = (char)0;
> #line 374
>   __constr_expr_1[43] = (char)0;
> #line 374
>   __constr_expr_1[44] = (char)0;
> #line 374
>   __constr_expr_1[45] = (char)0;
> #line 374
>   __constr_expr_1[46] = (char)0;
> #line 374
>   __constr_expr_1[47] = (char)0;
> #line 374
>   __constr_expr_1[48] = (char)0;
> #line 374
>   __constr_expr_1[49] = (char)0;
> #line 374
>   __constr_expr_1[50] = (char)0;
> #line 374
>   __constr_expr_1[51] = (char)0;
> #line 374
>   __constr_expr_1[52] = (char)0;
> #line 374
>   __constr_expr_1[53] = (char)0;
> #line 374
>   __constr_expr_1[54] = (char)0;
> #line 374
>   __constr_expr_1[55] = (char)0;
> #line 374
>   __constr_expr_1[56] = (char)0;
> #line 374
>   __constr_expr_1[57] = (char)0;
> #line 374
>   __constr_expr_1[58] = (char)0;
> #line 374
>   __constr_expr_1[59] = (char)0;
> #line 374
>   envp[0] = (char *)"HOME=/";
> #line 374
>   envp[1] = (char *)"TERM=linux";
> #line 374
>   envp[2] = (char *)"PATH=/sbin:/usr/sbin:/bin:/usr/bin";
> #line 374
>   envp[3] = (char *)(& __constr_expr_0);
> #line 374
>   envp[4] = (char *)(& __constr_expr_1);
> #line 374
>   envp[5] = 0;
> #line 380
>   argv[0] = (char *)(& usermode_helper);
> #line 380
>   argv[1] = cmd;
> #line 380
>   argv[2] = tconn->name;
> #line 380
>   argv[3] = 0;
> #line 383
>   setup_khelper_env(tconn, (char **)(& envp));
> #line 384
>   conn_md_sync(tconn);
> #line 386
>   printk("\016d-con %s: helper command: %s %s %s\n", tconn->name, (char *)(& usermode_helper),
>          cmd, tconn->name);
> #line 389
>   ret = call_usermodehelper((char *)(& usermode_helper), (char **)(& argv), (char **)(& envp),
>                             2);
> #line 390
>   if (ret != 0) {
> #line 391
>     printk("\fd-con %s: helper command: %s %s %s exit code %u (0x%x)\n", tconn->name,
>            (char *)(& usermode_helper), cmd, tconn->name, (ret >> 8) & 255, ret);
>   } else {
> #line 395
>     printk("\016d-con %s: helper command: %s %s %s exit code %u (0x%x)\n", tconn->name,
>            (char *)(& usermode_helper), cmd, tconn->name, (ret >> 8) & 255, ret);
>   }
> #line 400
>   if (ret < 0) {
> #line 401
>     ret = 0;
54991,54997c52360,52425
< #line 221
<   tmp = _get_ldev_if_state(mdev, D_CONSISTENT);
< #line 221
<   if (tmp != 0) {
< #line 222
<     fp = (enum drbd_fencing_p )(mdev->ldev)->dc.fencing;
< #line 223
---
> #line 403
>   return (ret);
> }
> }
> #line 406 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static enum drbd_fencing_p highest_fencing_policy(struct drbd_tconn *tconn ) 
> { 
>   enum drbd_fencing_p fp ;
>   struct drbd_conf *mdev ;
>   int vnr ;
>   void *tmp ;
>   enum drbd_fencing_p __max1 ;
>   enum drbd_fencing_p __max2 ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
>   void *tmp___3 ;
> 
>   {
> #line 408
>   fp = -1;
> #line 412
>   rcu_read_lock();
> #line 413
>   vnr = 0;
> #line 413
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 413
>   mdev = (struct drbd_conf *)tmp;
> #line 413
>   goto ldv_52920;
>   ldv_52919: 
> #line 414
>   tmp___2 = _get_ldev_if_state(mdev, D_CONSISTENT);
> #line 414
>   if (tmp___2 != 0) {
> #line 415
>     __max1 = fp;
> #line 415
>     _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 415
>     tmp___0 = debug_lockdep_rcu_enabled();
> #line 415
>     if (tmp___0 != 0 && ! __warned) {
> #line 415
>       tmp___1 = rcu_read_lock_held();
> #line 415
>       if (tmp___1 == 0 && 1) {
> #line 415
>         __warned = 1;
> #line 415
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                                416, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 415
>     __max2 = (enum drbd_fencing_p )_________p1->fencing;
> #line 415
>     fp = (enum drbd_fencing_p )((int )__max1 > (int )__max2 ? (int )__max1 : (int )__max2);
> #line 417
55000,55005c52428
< #line 225
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Not fencing peer, I\'m not even Consistent myself.\n");
< #line 226
<     nps = (enum drbd_disk_state )mdev->state.ldv_40583.pdsk;
< #line 227
<     goto out;
---
> 
55007,55009c52430,52536
< #line 230
<   r = drbd_khelper(mdev, (char *)"fence-peer");
< #line 232
---
> #line 413
>   vnr = vnr + 1;
> #line 413
>   tmp___3 = idr_get_next(& tconn->volumes, & vnr);
> #line 413
>   mdev = (struct drbd_conf *)tmp___3;
>   ldv_52920: ;
> #line 413
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 414
>     goto ldv_52919;
>   } else {
> 
>   }
> #line 420
>   rcu_read_unlock();
> #line 422
>   return (fp);
> }
> }
> #line 425 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> bool conn_try_outdate_peer(struct drbd_tconn *tconn ) 
> { 
>   union drbd_state mask ;
>   union drbd_state val ;
>   enum drbd_fencing_p fp ;
>   char *ex_to_string ;
>   int r ;
>   enum drbd_disk_state tmp ;
>   int tmp___0 ;
>   enum drbd_disk_state tmp___1 ;
> 
>   {
> #line 427
>   mask.ldv_40604.role = (unsigned char)0;
> #line 427
>   mask.ldv_40604.peer = (unsigned char)0;
> #line 427
>   mask.ldv_40604.conn = (unsigned char)0;
> #line 427
>   mask.ldv_40604.disk = (unsigned char)0;
> #line 427
>   mask.ldv_40604.pdsk = (unsigned char)0;
> #line 427
>   mask.ldv_40604.susp = (unsigned char)0;
> #line 427
>   mask.ldv_40604.aftr_isp = (unsigned char)0;
> #line 427
>   mask.ldv_40604.peer_isp = (unsigned char)0;
> #line 427
>   mask.ldv_40604.user_isp = (unsigned char)0;
> #line 427
>   mask.ldv_40604.susp_nod = (unsigned char)0;
> #line 427
>   mask.ldv_40604.susp_fen = (unsigned char)0;
> #line 427
>   mask.ldv_40604._pad = (unsigned short)0;
> #line 428
>   val.ldv_40604.role = (unsigned char)0;
> #line 428
>   val.ldv_40604.peer = (unsigned char)0;
> #line 428
>   val.ldv_40604.conn = (unsigned char)0;
> #line 428
>   val.ldv_40604.disk = (unsigned char)0;
> #line 428
>   val.ldv_40604.pdsk = (unsigned char)0;
> #line 428
>   val.ldv_40604.susp = (unsigned char)0;
> #line 428
>   val.ldv_40604.aftr_isp = (unsigned char)0;
> #line 428
>   val.ldv_40604.peer_isp = (unsigned char)0;
> #line 428
>   val.ldv_40604.user_isp = (unsigned char)0;
> #line 428
>   val.ldv_40604.susp_nod = (unsigned char)0;
> #line 428
>   val.ldv_40604.susp_fen = (unsigned char)0;
> #line 428
>   val.ldv_40604._pad = (unsigned short)0;
> #line 433
>   if ((unsigned int )tconn->cstate > 8U) {
> #line 434
>     printk("\vd-con %s: Expected cstate < C_WF_REPORT_PARAMS\n", tconn->name);
> #line 435
>     return (0);
>   } else {
> 
>   }
> #line 438
>   fp = highest_fencing_policy(tconn);
> #line 439
>   switch ((int )fp) {
>   case -1: 
> #line 441
>   printk("\fd-con %s: Not fencing peer, I\'m not even Consistent myself.\n", tconn->name);
> #line 442
>   goto out;
>   case 0: ;
> #line 444
>   return (1);
>   default: ;
>   }
> #line 448
>   r = conn_khelper(tconn, (char *)"fence-peer");
> #line 450
55012c52539
< #line 234
---
> #line 452
55014,55017c52541,52546
< #line 235
<   nps = D_INCONSISTENT;
< #line 236
<   goto ldv_54027;
---
> #line 453
>   mask.ldv_40604.pdsk = 15U;
> #line 454
>   val.ldv_40604.pdsk = 4U;
> #line 455
>   goto ldv_52935;
55019c52548
< #line 238
---
> #line 457
55021,55028c52550,52561
< #line 239
<   nps = D_OUTDATED;
< #line 240
<   goto ldv_54027;
<   case 5: ;
< #line 242
<   if ((unsigned int )*((unsigned char *)mdev + 2277UL) == 16U) {
< #line 244
---
> #line 458
>   mask.ldv_40604.pdsk = 15U;
> #line 459
>   val.ldv_40604.pdsk = 5U;
> #line 460
>   goto ldv_52935;
>   case 5: 
> #line 462
>   tmp = conn_highest_disk(tconn);
> #line 462
>   if ((unsigned int )tmp == 8U) {
> #line 464
55030,55031c52563,52566
< #line 245
<     nps = D_OUTDATED;
---
> #line 465
>     mask.ldv_40604.pdsk = 15U;
> #line 466
>     val.ldv_40604.pdsk = 5U;
55033c52568
< #line 247
---
> #line 468
55035,55036d52569
< #line 248
<     nps = (enum drbd_disk_state )mdev->state.ldv_40583.pdsk;
55038,55039c52571,52572
< #line 250
<   goto ldv_54027;
---
> #line 470
>   goto ldv_52935;
55041c52574
< #line 254
---
> #line 474
55043,55058c52576,52583
< #line 255
<   dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Peer is primary, outdating myself.\n");
< #line 256
<   nps = D_UNKNOWN;
< #line 257
<   val.i = 0U;
< #line 257
<   val.ldv_40583.disk = 5U;
< #line 257
<   mask.i = 0U;
< #line 257
<   mask.ldv_40583.disk = 15U;
< #line 257
<   _drbd_request_state(mdev, mask, val, CS_WAIT_COMPLETE);
< #line 258
<   goto ldv_54027;
---
> #line 475
>   printk("\fd-con %s: Peer is primary, outdating myself.\n", tconn->name);
> #line 476
>   mask.ldv_40604.disk = 15U;
> #line 477
>   val.ldv_40604.disk = 5U;
> #line 478
>   goto ldv_52935;
55060,55063c52585,52588
< #line 260
<   if ((unsigned int )fp != 2U) {
< #line 261
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "fence-peer() = 7 && fencing != Stonith !!!\n");
---
> #line 480
>   if ((int )fp != 2) {
> #line 481
>     printk("\vd-con %s: fence-peer() = 7 && fencing != Stonith !!!\n", tconn->name);
55067c52592
< #line 262
---
> #line 482
55069,55072c52594,52599
< #line 263
<   nps = D_OUTDATED;
< #line 264
<   goto ldv_54027;
---
> #line 483
>   mask.ldv_40604.pdsk = 15U;
> #line 484
>   val.ldv_40604.pdsk = 5U;
> #line 485
>   goto ldv_52935;
55074,55080c52601,52604
< #line 267
<   nps = D_UNKNOWN;
< #line 268
<   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "fence-peer helper broken, returned %d\n",
<           (r >> 8) & 255);
< #line 269
<   return (nps);
---
> #line 488
>   printk("\vd-con %s: fence-peer helper broken, returned %d\n", tconn->name, (r >> 8) & 255);
> #line 489
>   return (0);
55082,55098c52606,52623
<   ldv_54027: 
< #line 272
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "fence-peer helper returned %d (%s)\n",
<             (r >> 8) & 255, ex_to_string);
<   out: ;
< #line 276
<   if ((unsigned int )*((unsigned char *)mdev + 2278UL) != 0U && (unsigned int )nps > 5U) {
< #line 279
<     val___0.i = 0U;
< #line 279
<     val___0.ldv_40583.susp_fen = 0U;
< #line 279
<     mask___0.i = 0U;
< #line 279
<     mask___0.ldv_40583.susp_fen = 1U;
< #line 279
<     _drbd_request_state(mdev, mask___0, val___0, CS_VERBOSE);
---
>   ldv_52935: 
> #line 492
>   printk("\016d-con %s: fence-peer helper returned %d (%s)\n", tconn->name, (r >> 8) & 255,
>          ex_to_string);
>   out: 
> #line 501
>   spin_lock_irq(& tconn->req_lock);
> #line 502
>   if ((unsigned int )tconn->cstate <= 8U) {
> #line 502
>     tmp___0 = constant_test_bit(10U, (unsigned long const volatile   *)(& tconn->flags));
> #line 502
>     if (tmp___0 == 0) {
> #line 503
>       _conn_request_state(tconn, mask, val, CS_VERBOSE);
>     } else {
> 
>     }
55102,55103c52627,52632
< #line 282
<   return (nps);
---
> #line 504
>   spin_unlock_irq(& tconn->req_lock);
> #line 506
>   tmp___1 = conn_highest_pdsk(tconn);
> #line 506
>   return ((unsigned int )tmp___1 <= 5U);
55106c52635
< #line 285 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
---
> #line 509 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
55109,55112c52638
<   struct drbd_conf *mdev ;
<   enum drbd_disk_state nps ;
<   union drbd_state ns ;
<   int tmp ;
---
>   struct drbd_tconn *tconn ;
55115,55141c52641,52647
< #line 287
<   mdev = (struct drbd_conf *)data;
< #line 291
<   nps = drbd_try_outdate_peer(mdev);
< #line 304
<   spin_lock_irq(& mdev->req_lock);
< #line 305
<   ns = mdev->state;
< #line 306
<   if ((int )ns.ldv_40583.conn <= 8) {
< #line 306
<     tmp = drbd_test_flag(mdev, STATE_SENT);
< #line 306
<     if (tmp == 0) {
< #line 307
<       ns.ldv_40583.pdsk = (unsigned char )nps;
< #line 308
<       _drbd_set_state(mdev, ns, CS_VERBOSE, 0);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 310
<   spin_unlock_irq(& mdev->req_lock);
< #line 312
---
> #line 511
>   tconn = (struct drbd_tconn *)data;
> #line 513
>   conn_try_outdate_peer(tconn);
> #line 515
>   kref_put(& tconn->kref, & conn_destroy);
> #line 516
55145,55146c52651,52652
< #line 315 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void drbd_try_outdate_peer_async(struct drbd_conf *mdev ) 
---
> #line 519 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> void conn_try_outdate_peer_async(struct drbd_tconn *tconn ) 
55150,55151c52656,52657
<   unsigned int tmp ;
<   struct task_struct *tmp___0 ;
---
>   struct task_struct *tmp ;
>   long tmp___0 ;
55153d52658
<   long tmp___2 ;
55156,55167c52661,52671
< #line 319
<   tmp = mdev_to_minor(mdev);
< #line 319
<   tmp___0 = kthread_create_on_node(& _try_outdate_peer_async, (void *)mdev, -1, "drbd%d_a_helper",
<                                    tmp);
< #line 319
<   __k = tmp___0;
< #line 319
<   tmp___1 = IS_ERR((void const   *)__k);
< #line 319
<   if (tmp___1 == 0L) {
< #line 319
---
> #line 523
>   kref_get(& tconn->kref);
> #line 524
>   tmp = kthread_create_on_node(& _try_outdate_peer_async, (void *)tconn, -1, "drbd_async_h");
> #line 524
>   __k = tmp;
> #line 524
>   tmp___0 = IS_ERR((void const   *)__k);
> #line 524
>   if (tmp___0 == 0L) {
> #line 524
55172c52676
< #line 319
---
> #line 524
55174,55179c52678,52685
< #line 320
<   tmp___2 = IS_ERR((void const   *)opa);
< #line 320
<   if (tmp___2 != 0L) {
< #line 321
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "out of mem, failed to invoke fence-peer helper\n");
---
> #line 525
>   tmp___1 = IS_ERR((void const   *)opa);
> #line 525
>   if (tmp___1 != 0L) {
> #line 526
>     printk("\vd-con %s: out of mem, failed to invoke fence-peer helper\n", tconn->name);
> #line 527
>     kref_put(& tconn->kref, & conn_destroy);
55183c52689
< #line 322
---
> #line 529
55187c52693
< #line 325 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
---
> #line 532 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
55192a52699
>   struct net_conf *nc ;
55197,55201c52704,52709
<   enum drbd_disk_state nps ;
<   int tmp ;
<   int tmp___0 ;
<   wait_queue_t __wait ;
<   struct task_struct *tmp___1 ;
---
>   bool tmp ;
>   bool tmp___0 ;
>   int tmp___1 ;
>   int timeo ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
55205a52714,52718
>   wait_queue_t __wait ;
>   struct task_struct *tmp___6 ;
>   int tmp___7 ;
>   int tmp___8 ;
>   int tmp___9 ;
55208c52721
< #line 327
---
> #line 534
55210c52723
< #line 328
---
> #line 535
55212c52725
< #line 329
---
> #line 537
55214c52727
< #line 330
---
> #line 538
55216c52729
< #line 334
---
> #line 541
55218,55219c52731,52732
< #line 335
<     request_ping(mdev);
---
> #line 542
>     request_ping(mdev->tconn);
55223,55225c52736,52738
< #line 337
<   mutex_lock_nested(& mdev->state_mutex, 0U);
< #line 339
---
> #line 544
>   mutex_lock_nested(mdev->state_mutex, 0U);
> #line 546
55227,55229c52740,52742
< #line 339
<   mask.ldv_40583.role = 3U;
< #line 340
---
> #line 546
>   mask.ldv_40604.role = 3U;
> #line 547
55231,55236c52744,52749
< #line 340
<   val.ldv_40583.role = (unsigned char )new_role;
< #line 342
<   goto ldv_54065;
<   ldv_54068: 
< #line 343
---
> #line 547
>   val.ldv_40604.role = (unsigned char )new_role;
> #line 549
>   goto ldv_52963;
>   ldv_52970: 
> #line 550
55238c52751
< #line 347
---
> #line 554
55240,55245c52753,52758
< #line 348
<     val.ldv_40583.pdsk = 0U;
< #line 349
<     mask.ldv_40583.pdsk = 0U;
< #line 350
<     goto ldv_54065;
---
> #line 555
>     val.ldv_40604.pdsk = 0U;
> #line 556
>     mask.ldv_40604.pdsk = 0U;
> #line 557
>     goto ldv_52963;
55249,55255c52762,52768
< #line 353
<   if (((int )rv == -2 && force != 0) && ((int )mdev->state.ldv_40583.disk <= 7 && (int )mdev->state.ldv_40583.disk > 3)) {
< #line 356
<     mask.ldv_40583.disk = 15U;
< #line 357
<     val.ldv_40583.disk = 8U;
< #line 358
---
> #line 560
>   if (((int )rv == -2 && force != 0) && ((int )mdev->state.ldv_50103.disk <= 7 && (int )mdev->state.ldv_50103.disk > 3)) {
> #line 563
>     mask.ldv_40604.disk = 15U;
> #line 564
>     val.ldv_40604.disk = 8U;
> #line 565
55257,55258c52770,52771
< #line 359
<     goto ldv_54065;
---
> #line 566
>     goto ldv_52963;
55262,55266c52775,52779
< #line 362
<   if (((int )rv == -2 && (unsigned int )*((unsigned char *)mdev + 2277UL) == 14U) && *((unsigned int *)(& mask) + 0UL) == 0U) {
< #line 364
<     if (*((unsigned int *)mdev + 569UL) != 49152U) {
< #line 364
---
> #line 569
>   if (((int )rv == -2 && (unsigned int )*((unsigned char *)mdev + 749UL) == 14U) && *((unsigned int *)(& mask) + 0UL) == 0U) {
> #line 571
>     if (*((unsigned int *)mdev + 187UL) != 49152U) {
> #line 571
55268,55269c52781,52782
<               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
<               364);
---
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>               571);
55273,55280c52786,52793
< #line 365
<     nps = drbd_try_outdate_peer(mdev);
< #line 367
<     if ((unsigned int )nps == 5U || (unsigned int )nps == 4U) {
< #line 368
<       val.ldv_40583.disk = 8U;
< #line 369
<       mask.ldv_40583.disk = 15U;
---
> #line 573
>     tmp = conn_try_outdate_peer(mdev->tconn);
> #line 573
>     if ((int )tmp) {
> #line 574
>       val.ldv_40604.disk = 8U;
> #line 575
>       mask.ldv_40604.disk = 15U;
55284,55289c52797,52798
< #line 372
<     val.ldv_40583.pdsk = (unsigned char )nps;
< #line 373
<     mask.ldv_40583.pdsk = 15U;
< #line 375
<     goto ldv_54065;
---
> #line 577
>     goto ldv_52963;
55293c52802
< #line 378
---
> #line 580
55295,55296c52804,52805
< #line 379
<     goto fail;
---
> #line 581
>     goto out;
55300c52809
< #line 380
---
> #line 582
55302,55306c52811,52823
< #line 381
<     nps = drbd_try_outdate_peer(mdev);
< #line 383
<     if (force != 0 && (unsigned int )nps > 5U) {
< #line 384
---
> #line 583
>     tmp___0 = conn_try_outdate_peer(mdev->tconn);
> #line 583
>     if (tmp___0) {
> #line 583
>       tmp___1 = 0;
>     } else {
> #line 583
>       tmp___1 = 1;
>     }
> #line 583
>     if (tmp___1 && force != 0) {
> #line 584
55308,55309c52825,52828
< #line 385
<       nps = D_OUTDATED;
---
> #line 585
>       mask.ldv_40604.pdsk = 15U;
> #line 586
>       val.ldv_40604.pdsk = 5U;
55313,55318c52832,52833
< #line 388
<     mask.ldv_40583.pdsk = 15U;
< #line 389
<     val.ldv_40583.pdsk = (unsigned char )nps;
< #line 391
<     goto ldv_54065;
---
> #line 589
>     goto ldv_52963;
55322c52837
< #line 393
---
> #line 591
55324,55326c52839,52870
< #line 396
<     schedule_timeout_interruptible((long )((((mdev->net_conf)->ping_timeo + 1) * 250) / 10));
< #line 397
---
> #line 595
>     rcu_read_lock();
> #line 596
>     _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 596
>     tmp___2 = debug_lockdep_rcu_enabled();
> #line 596
>     if (tmp___2 != 0 && ! __warned) {
> #line 596
>       tmp___3 = rcu_read_lock_held();
> #line 596
>       if (tmp___3 == 0 && 1) {
> #line 596
>         __warned = 1;
> #line 596
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                                596, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 596
>     nc = _________p1;
> #line 597
>     timeo = (unsigned long )nc != (unsigned long )((struct net_conf *)0) ? (int )(((nc->ping_timeo + 1U) * 250U) / 10U) : 1;
> #line 598
>     rcu_read_unlock();
> #line 599
>     schedule_timeout_interruptible((long )timeo);
> #line 600
55328c52872
< #line 398
---
> #line 601
55333,55334c52877,52878
< #line 399
<     goto ldv_54065;
---
> #line 602
>     goto ldv_52963;
55338c52882
< #line 401
---
> #line 604
55340c52884
< #line 402
---
> #line 605
55342c52886
< #line 404
---
> #line 607
55344,55345c52888,52889
< #line 405
<       goto fail;
---
> #line 608
>       goto out;
55352,55357c52896,52901
< #line 407
<   goto ldv_54067;
<   ldv_54065: 
< #line 342
<   tmp = try;
< #line 342
---
> #line 610
>   goto ldv_52969;
>   ldv_52963: 
> #line 549
>   tmp___4 = try;
> #line 549
55359,55362c52903,52906
< #line 342
<   if (tmp < max_tries) {
< #line 343
<     goto ldv_54068;
---
> #line 549
>   if (tmp___4 < max_tries) {
> #line 550
>     goto ldv_52970;
55366,55367c52910,52911
<   ldv_54067: ;
< #line 410
---
>   ldv_52969: ;
> #line 613
55369,55370c52913,52914
< #line 411
<     goto fail;
---
> #line 614
>     goto out;
55374c52918
< #line 413
---
> #line 616
55376c52920
< #line 414
---
> #line 617
55381,55386c52925,52930
< #line 417
<   tmp___0 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 417
<   if (tmp___0 == 0) {
< #line 417
<     goto ldv_54069;
---
> #line 620
>   tmp___5 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
> #line 620
>   if (tmp___5 == 0) {
> #line 620
>     goto ldv_52971;
55390,55392c52934,52936
< #line 417
<   tmp___1 = get_current();
< #line 417
---
> #line 620
>   tmp___6 = get_current();
> #line 620
55394,55396c52938,52940
< #line 417
<   __wait.private = (void *)tmp___1;
< #line 417
---
> #line 620
>   __wait.private = (void *)tmp___6;
> #line 620
55398c52942
< #line 417
---
> #line 620
55400c52944
< #line 417
---
> #line 620
55402,55403c52946,52947
<   ldv_54072: 
< #line 417
---
>   ldv_52974: 
> #line 620
55405,55410c52949,52954
< #line 417
<   tmp___2 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 417
<   if (tmp___2 == 0) {
< #line 417
<     goto ldv_54071;
---
> #line 620
>   tmp___7 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
> #line 620
>   if (tmp___7 == 0) {
> #line 620
>     goto ldv_52973;
55414c52958
< #line 417
---
> #line 620
55416,55419c52960,52963
< #line 417
<   goto ldv_54072;
<   ldv_54071: 
< #line 417
---
> #line 620
>   goto ldv_52974;
>   ldv_52973: 
> #line 620
55421,55422c52965,52966
<   ldv_54069: ;
< #line 419
---
>   ldv_52971: ;
> #line 624
55424c52968
< #line 420
---
> #line 625
55426,55430c52970,52974
< #line 421
<     tmp___3 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 421
<     if (tmp___3 != 0) {
< #line 422
---
> #line 626
>     tmp___8 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 626
>     if (tmp___8 != 0) {
> #line 627
55432c52976
< #line 423
---
> #line 628
55438,55445c52982,52989
< #line 426
<     tmp___4 = get_net_conf(mdev);
< #line 426
<     if (tmp___4 != 0) {
< #line 427
<       (mdev->net_conf)->want_lose = 0U;
< #line 428
<       put_net_conf(mdev);
---
> #line 631
>     mutex_lock_nested(& (mdev->tconn)->conf_update, 0U);
> #line 632
>     nc = (mdev->tconn)->net_conf;
> #line 633
>     if ((unsigned long )nc != (unsigned long )((struct net_conf *)0)) {
> #line 634
>       nc->discard_my_data = 0;
55449c52993,52995
< #line 430
---
> #line 635
>     mutex_unlock(& (mdev->tconn)->conf_update);
> #line 637
55451,55457c52997,53003
< #line 431
<     tmp___5 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 431
<     if (tmp___5 != 0) {
< #line 432
<       if ((((int )mdev->state.ldv_40583.conn <= 9 || (int )mdev->state.ldv_40583.pdsk <= 2) && (mdev->ldev)->md.uuid[1] == 0ULL) || forced != 0) {
< #line 435
---
> #line 638
>     tmp___9 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 638
>     if (tmp___9 != 0) {
> #line 639
>       if ((((int )mdev->state.ldv_50103.conn <= 9 || (int )mdev->state.ldv_50103.pdsk <= 2) && (mdev->ldev)->md.uuid[1] == 0ULL) || forced != 0) {
> #line 642
55462c53008
< #line 437
---
> #line 644
55464c53010
< #line 438
---
> #line 645
55470,55472c53016,53018
< #line 445
<   if ((int )mdev->state.ldv_40583.conn > 8) {
< #line 447
---
> #line 652
>   if ((int )mdev->state.ldv_50103.conn > 8) {
> #line 654
55474c53020
< #line 448
---
> #line 655
55479c53025
< #line 449
---
> #line 656
55484c53030
< #line 452
---
> #line 659
55486c53032
< #line 454
---
> #line 661
55488,55491c53034,53037
<   fail: 
< #line 456
<   mutex_unlock(& mdev->state_mutex);
< #line 457
---
>   out: 
> #line 663
>   mutex_unlock(mdev->state_mutex);
> #line 664
55495,55496c53041,53042
< #line 460 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static struct drbd_conf *ensure_mdev(int minor , int create ) 
---
> #line 667 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static char const   *from_attrs_err_to_txt(int err ) 
55498,55499c53044
<   struct drbd_conf *mdev ;
<   struct gendisk *disk ;
---
> 
55502,55505c53047,53070
< #line 464
<   if ((unsigned int )minor >= minor_count) {
< #line 465
<     return (0);
---
> #line 669
>   return (err != -42 ? (err != -95 ? (err == -17 ? "can not change invariant setting" : "invalid attribute value") : "unknown mandatory attribute") : "required attribute missing");
> }
> }
> #line 675 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_set_role(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct set_role_parms parms ;
>   int err ;
>   enum drbd_ret_code retcode ;
>   int tmp ;
>   char const   *tmp___0 ;
>   enum drbd_state_rv tmp___1 ;
>   enum drbd_state_rv tmp___2 ;
> 
>   {
> #line 681
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 681
>   retcode = (enum drbd_ret_code )tmp;
> #line 682
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 683
>     return ((int )retcode);
55509,55527c53074,53078
< #line 467
<   mdev = minor_to_mdev((unsigned int )minor);
< #line 469
<   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0) && create != 0) {
< #line 470
<     disk = 0;
< #line 471
<     mdev = drbd_new_device((unsigned int )minor);
< #line 473
<     spin_lock_irq(& drbd_pp_lock);
< #line 474
<     if ((unsigned long )*(minor_table + (unsigned long )minor) == (unsigned long )((struct drbd_conf *)0)) {
< #line 475
<       *(minor_table + (unsigned long )minor) = mdev;
< #line 476
<       disk = mdev->vdisk;
< #line 477
<       mdev = 0;
<     } else {
---
> #line 684
>   if ((unsigned int )retcode != 101U) {
> #line 685
>     goto out;
>   } else {
55529,55535c53080,53096
<     }
< #line 479
<     spin_unlock_irq(& drbd_pp_lock);
< #line 481
<     if ((unsigned long )disk != (unsigned long )((struct gendisk *)0)) {
< #line 484
<       add_disk(disk);
---
>   }
> #line 687
>   memset((void *)(& parms), 0, 1UL);
> #line 688
>   if ((unsigned long )*(info->attrs + 6UL) != (unsigned long )((struct nlattr *)0)) {
> #line 689
>     err = set_role_parms_from_attrs(& parms, info);
> #line 690
>     if (err != 0) {
> #line 691
>       retcode = ERR_MANDATORY_TAG;
> #line 692
>       tmp___0 = from_attrs_err_to_txt(err);
> #line 692
>       drbd_msg_put_info(tmp___0);
> #line 693
>       goto out;
55537,55538c53098
< #line 486
<       drbd_free_mdev(mdev);
---
> 
55540,55541d53099
< #line 488
<     mdev = minor_to_mdev((unsigned int )minor);
55545,55567c53103,53108
< #line 491
<   return (mdev);
< }
< }
< #line 494 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_primary(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                            struct drbd_nl_cfg_reply *reply ) 
< { 
<   struct primary primary_args ;
<   int tmp ;
<   enum drbd_state_rv tmp___0 ;
< 
<   {
< #line 499
<   memset((void *)(& primary_args), 0, 4UL);
< #line 500
<   tmp = primary_from_tags(mdev, (unsigned short *)(& nlp->tag_list), & primary_args);
< #line 500
<   if (tmp == 0) {
< #line 501
<     reply->ret_code = 126;
< #line 502
<     return (0);
---
> #line 697
>   if ((unsigned int )(info->genlhdr)->cmd == 14U) {
> #line 698
>     tmp___1 = drbd_set_role(adm_ctx.mdev, R_PRIMARY, (int )parms.assume_uptodate);
> #line 698
>     retcode = (enum drbd_ret_code )tmp___1;
55569c53110,53113
< 
---
> #line 700
>     tmp___2 = drbd_set_role(adm_ctx.mdev, R_SECONDARY, 0);
> #line 700
>     retcode = (enum drbd_ret_code )tmp___2;
55571,55590c53115,53118
< #line 505
<   tmp___0 = drbd_set_role(mdev, R_PRIMARY, (int )primary_args.primary_force);
< #line 505
<   reply->ret_code = (int )tmp___0;
< #line 508
<   return (0);
< }
< }
< #line 511 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_secondary(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                              struct drbd_nl_cfg_reply *reply ) 
< { 
<   enum drbd_state_rv tmp ;
< 
<   {
< #line 514
<   tmp = drbd_set_role(mdev, R_SECONDARY, 0);
< #line 514
<   reply->ret_code = (int )tmp;
< #line 516
---
>   out: 
> #line 702
>   drbd_adm_finish(info, (int )retcode);
> #line 703
55594c53122
< #line 521 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
---
> #line 708 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
55598,55599c53126,53130
<   sector_t tmp ;
<   sector_t tmp___0 ;
---
>   int meta_dev_idx ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
55600a53132,53133
>   sector_t tmp___2 ;
>   sector_t tmp___3 ;
55603c53136
< #line 524
---
> #line 711
55605,55606c53138,53164
< #line 525
<   switch (bdev->dc.meta_dev_idx) {
---
> #line 714
>   rcu_read_lock();
> #line 715
>   _________p1 = *((struct disk_conf * volatile  *)(& bdev->disk_conf));
> #line 715
>   tmp = debug_lockdep_rcu_enabled();
> #line 715
>   if (tmp != 0 && ! __warned) {
> #line 715
>     tmp___0 = rcu_read_lock_held();
> #line 715
>     if (tmp___0 == 0 && 1) {
> #line 715
>       __warned = 1;
> #line 715
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                              715, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 715
>   meta_dev_idx = _________p1->meta_dev_idx;
> #line 717
>   switch (meta_dev_idx) {
55608c53166
< #line 528
---
> #line 720
55610,55614c53168,53172
< #line 529
<   tmp = drbd_md_ss__(mdev, bdev);
< #line 529
<   bdev->md.md_offset = (u64 )tmp;
< #line 530
---
> #line 721
>   tmp___1 = drbd_md_ss__(mdev, bdev);
> #line 721
>   bdev->md.md_offset = (u64 )tmp___1;
> #line 722
55616c53174
< #line 531
---
> #line 723
55618,55619c53176,53177
< #line 532
<   goto ldv_54096;
---
> #line 724
>   goto ldv_52996;
55621,55625c53179,53183
< #line 535
<   tmp___0 = drbd_get_capacity(bdev->md_bdev);
< #line 535
<   bdev->md.md_size_sect = (u32 )tmp___0;
< #line 536
---
> #line 727
>   tmp___2 = drbd_get_capacity(bdev->md_bdev);
> #line 727
>   bdev->md.md_size_sect = (u32 )tmp___2;
> #line 728
55627c53185
< #line 537
---
> #line 729
55629c53187
< #line 538
---
> #line 730
55631,55632c53189,53190
< #line 539
<   goto ldv_54096;
---
> #line 731
>   goto ldv_52996;
55635,55639c53193,53197
< #line 542
<   tmp___1 = drbd_md_ss__(mdev, bdev);
< #line 542
<   bdev->md.md_offset = (u64 )tmp___1;
< #line 544
---
> #line 734
>   tmp___3 = drbd_md_ss__(mdev, bdev);
> #line 734
>   bdev->md.md_offset = (u64 )tmp___3;
> #line 736
55641c53199
< #line 546
---
> #line 738
55643c53201
< #line 547
---
> #line 739
55645c53203
< #line 548
---
> #line 740
55647c53205
< #line 549
---
> #line 741
55649c53207
< #line 553
---
> #line 745
55651c53209
< #line 555
---
> #line 747
55653c53211
< #line 557
---
> #line 749
55655,55656c53213,53214
< #line 558
<   goto ldv_54096;
---
> #line 750
>   goto ldv_52996;
55658,55659c53216,53219
<   ldv_54096: ;
< #line 561
---
>   ldv_52996: 
> #line 752
>   rcu_read_unlock();
> #line 753
55663c53223
< #line 563 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
---
> #line 756 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
55670c53230
< #line 567
---
> #line 760
55672c53232
< #line 567
---
> #line 760
55674c53234
< #line 567
---
> #line 760
55676c53236
< #line 567
---
> #line 760
55678c53238
< #line 567
---
> #line 760
55680c53240
< #line 567
---
> #line 760
55682c53242
< #line 568
---
> #line 761
55684,55687c53244,53247
< #line 569
<   goto ldv_54107;
<   ldv_54106: 
< #line 571
---
> #line 762
>   goto ldv_53007;
>   ldv_53006: 
> #line 764
55689c53249
< #line 572
---
> #line 765
55691,55692c53251,53252
<   ldv_54107: ;
< #line 569
---
>   ldv_53007: ;
> #line 762
55694,55695c53254,53255
< #line 570
<     goto ldv_54106;
---
> #line 763
>     goto ldv_53006;
55699c53259
< #line 574
---
> #line 767
55701c53261
< #line 576
---
> #line 769
55705c53265
< #line 592 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
---
> #line 791 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
55715,55719c53275,53279
< #line 594
<   drbd_set_flag(mdev, SUSPEND_IO);
< #line 595
<   tmp = is_susp(mdev->state);
< #line 595
---
> #line 793
>   set_bit(8U, (unsigned long volatile   *)(& mdev->flags));
> #line 794
>   tmp = drbd_suspended(mdev);
> #line 794
55721c53281
< #line 596
---
> #line 795
55726c53286
< #line 597
---
> #line 796
55728c53288
< #line 597
---
> #line 796
55730,55731c53290,53291
< #line 597
<     goto ldv_54112;
---
> #line 796
>     goto ldv_53012;
55735c53295
< #line 597
---
> #line 796
55737c53297
< #line 597
---
> #line 796
55739c53299
< #line 597
---
> #line 796
55741c53301
< #line 597
---
> #line 796
55743c53303
< #line 597
---
> #line 796
55745c53305
< #line 597
---
> #line 796
55747,55748c53307,53308
<   ldv_54115: 
< #line 597
---
>   ldv_53015: 
> #line 796
55750c53310
< #line 597
---
> #line 796
55752c53312
< #line 597
---
> #line 796
55754,55755c53314,53315
< #line 597
<     goto ldv_54114;
---
> #line 796
>     goto ldv_53014;
55759c53319
< #line 597
---
> #line 796
55761,55764c53321,53324
< #line 597
<   goto ldv_54115;
<   ldv_54114: 
< #line 597
---
> #line 796
>   goto ldv_53015;
>   ldv_53014: 
> #line 796
55766,55767c53326,53327
<   ldv_54112: ;
< #line 600
---
>   ldv_53012: ;
> #line 799
55771c53331
< #line 600 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
---
> #line 799 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
55777,55779c53337,53339
< #line 602
<   drbd_clear_flag(mdev, SUSPEND_IO);
< #line 603
---
> #line 801
>   clear_bit(8, (unsigned long volatile   *)(& mdev->flags));
> #line 802
55781c53341
< #line 604
---
> #line 803
55785c53345
< #line 613 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
---
> #line 812 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
55790a53351
>   sector_t u_size ;
55799a53361,53364
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___2 ;
>   int tmp___3 ;
55801,55805c53366,53368
<   sector_t tmp___2 ;
<   long tmp___3 ;
<   char *tmp___4 ;
<   sector_t tmp___5 ;
<   sector_t tmp___6 ;
---
>   sector_t tmp___4 ;
>   long tmp___5 ;
>   char *tmp___6 ;
55806a53370,53371
>   sector_t tmp___8 ;
>   sector_t tmp___9 ;
55810c53375
< #line 621
---
> #line 820
55812c53377
< #line 632
---
> #line 831
55814c53379
< #line 635
---
> #line 834
55816c53381
< #line 635
---
> #line 834
55818,55819c53383,53384
< #line 635
<     goto ldv_54131;
---
> #line 834
>     goto ldv_53032;
55823c53388
< #line 635
---
> #line 834
55825c53390
< #line 635
---
> #line 834
55827c53392
< #line 635
---
> #line 834
55829c53394
< #line 635
---
> #line 834
55831c53396
< #line 635
---
> #line 834
55833c53398
< #line 635
---
> #line 834
55835,55836c53400,53401
<   ldv_54134: 
< #line 635
---
>   ldv_53035: 
> #line 834
55838c53403
< #line 635
---
> #line 834
55840c53405
< #line 635
---
> #line 834
55842,55843c53407,53408
< #line 635
<     goto ldv_54133;
---
> #line 834
>     goto ldv_53034;
55847c53412
< #line 635
---
> #line 834
55849,55852c53414,53417
< #line 635
<   goto ldv_54134;
<   ldv_54133: 
< #line 635
---
> #line 834
>   goto ldv_53035;
>   ldv_53034: 
> #line 834
55854,55855c53419,53420
<   ldv_54131: 
< #line 637
---
>   ldv_53032: 
> #line 836
55857c53422
< #line 638
---
> #line 837
55859c53424
< #line 639
---
> #line 838
55861c53426
< #line 642
---
> #line 841
55863,55869c53428,53461
< #line 644
<   size = drbd_new_dev_size(mdev, mdev->ldev, (int )flags & 1);
< #line 646
<   tmp___5 = drbd_get_capacity(mdev->this_bdev);
< #line 646
<   if (tmp___5 != size) {
< #line 646
---
> #line 843
>   rcu_read_lock();
> #line 844
>   _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 844
>   tmp___2 = debug_lockdep_rcu_enabled();
> #line 844
>   if (tmp___2 != 0 && ! __warned) {
> #line 844
>     tmp___3 = rcu_read_lock_held();
> #line 844
>     if (tmp___3 == 0 && 1) {
> #line 844
>       __warned = 1;
> #line 844
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                              844, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 844
>   u_size = (sector_t )_________p1->disk_size;
> #line 845
>   rcu_read_unlock();
> #line 846
>   size = drbd_new_dev_size(mdev, mdev->ldev, u_size, (int )flags & 1);
> #line 848
>   tmp___7 = drbd_get_capacity(mdev->this_bdev);
> #line 848
>   if (tmp___7 != size) {
> #line 848
55872,55875c53464,53467
< #line 646
<     tmp___6 = drbd_bm_capacity(mdev);
< #line 646
<     if (tmp___6 != size) {
---
> #line 848
>     tmp___8 = drbd_bm_capacity(mdev);
> #line 848
>     if (tmp___8 != size) {
55877c53469
< #line 649
---
> #line 851
55879,55887c53471,53479
< #line 650
<       tmp___3 = __builtin_expect(err != 0, 0L);
< #line 650
<       if (tmp___3 != 0L) {
< #line 652
<         tmp___2 = drbd_bm_capacity(mdev);
< #line 652
<         size = tmp___2 >> 1;
< #line 653
---
> #line 852
>       tmp___5 = __builtin_expect(err != 0, 0L);
> #line 852
>       if (tmp___5 != 0L) {
> #line 854
>         tmp___4 = drbd_bm_capacity(mdev);
> #line 854
>         size = tmp___4 >> 1;
> #line 855
55889c53481
< #line 654
---
> #line 856
55892c53484
< #line 657
---
> #line 859
55896c53488
< #line 661
---
> #line 863
55901c53493
< #line 664
---
> #line 866
55903c53495
< #line 665
---
> #line 867
55905,55907c53497,53499
< #line 666
<       tmp___4 = ppsize((char *)(& ppb), (unsigned long long )(size >> 1));
< #line 666
---
> #line 868
>       tmp___6 = ppsize((char *)(& ppb), (unsigned long long )(size >> 1));
> #line 868
55909c53501
<                 tmp___4, (unsigned long long )size >> 1);
---
>                 tmp___6, (unsigned long long )size >> 1);
55914c53506
< #line 669
---
> #line 871
55916c53508
< #line 670
---
> #line 872
55921c53513
< #line 672
---
> #line 874
55923,55927c53515,53519
< #line 674
<   tmp___7 = drbd_md_first_sector(mdev->ldev);
< #line 674
<   md_moved = tmp___7 != prev_first_sect || (sector_t )(mdev->ldev)->md.md_size_sect != prev_size;
< #line 677
---
> #line 876
>   tmp___9 = drbd_md_first_sector(mdev->ldev);
> #line 876
>   md_moved = tmp___9 != prev_first_sect || (sector_t )(mdev->ldev)->md.md_size_sect != prev_size;
> #line 879
55929c53521
< #line 680
---
> #line 882
55931c53523
< #line 681
---
> #line 883
55934c53526
< #line 685
---
> #line 887
55937c53529
< #line 687
---
> #line 889
55939c53531
< #line 688
---
> #line 890
55941c53533
< #line 689
---
> #line 891
55946c53538
< #line 691
---
> #line 893
55951c53543
< #line 694
---
> #line 896
55953c53545
< #line 695
---
> #line 897
55958c53550
< #line 696
---
> #line 898
55960c53552
< #line 697
---
> #line 899
55966c53558
< #line 699
---
> #line 901
55968c53560
< #line 700
---
> #line 902
55970c53562
< #line 701
---
> #line 903
55972c53564
< #line 703
---
> #line 905
55976c53568
< #line 707 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
---
> #line 909 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
55978c53570
<                            int assume_peer_has_space ) 
---
>                            sector_t u_size , int assume_peer_has_space ) 
55983d53574
<   sector_t u_size ;
55989c53580
< #line 709
---
> #line 912
55991c53582
< #line 710
---
> #line 913
55993,55995c53584
< #line 712
<   u_size = (sector_t )bdev->dc.disk_size;
< #line 713
---
> #line 915
55997c53586
< #line 715
---
> #line 917
55999,56001c53588,53590
< #line 717
<   if ((int )mdev->state.ldv_40583.conn <= 9 && assume_peer_has_space != 0) {
< #line 718
---
> #line 919
>   if ((int )mdev->state.ldv_50103.conn <= 9 && assume_peer_has_space != 0) {
> #line 920
56003c53592
< #line 719
---
> #line 921
56008c53597
< #line 722
---
> #line 924
56010c53599
< #line 723
---
> #line 925
56012c53601
< #line 723
---
> #line 925
56014c53603
< #line 723
---
> #line 925
56017c53606
< #line 725
---
> #line 927
56019c53608
< #line 726
---
> #line 928
56021c53610
< #line 727
---
> #line 929
56023c53612
< #line 728
---
> #line 930
56028c53617
< #line 729
---
> #line 931
56030c53619
< #line 730
---
> #line 932
56036c53625
< #line 732
---
> #line 934
56038c53627
< #line 733
---
> #line 935
56043c53632
< #line 734
---
> #line 936
56045c53634
< #line 735
---
> #line 937
56051c53640
< #line 739
---
> #line 941
56053c53642
< #line 740
---
> #line 942
56058c53647
< #line 742
---
> #line 944
56060c53649
< #line 743
---
> #line 945
56062c53651
< #line 744
---
> #line 946
56066c53655
< #line 747
---
> #line 949
56072c53661
< #line 750
---
> #line 952
56076,56077c53665,53666
< #line 761 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_check_al_size(struct drbd_conf *mdev ) 
---
> #line 963 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static int drbd_check_al_size(struct drbd_conf *mdev , struct disk_conf *dc ) 
56084d53672
<   int _b ;
56087,56107c53675,53677
< #line 768
<   _b = mdev->sync_conf.al_extents <= 6;
< #line 768
<   if (_b != 0) {
< #line 768
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_check_al_size", (char *)"mdev->sync_conf.al_extents < 7", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
<             768);
<   } else {
< 
<   }
< #line 768
<   if (_b != 0) {
< #line 769
<     mdev->sync_conf.al_extents = 127;
<   } else {
< 
<   }
< #line 771
<   if ((unsigned long )mdev->act_log != (unsigned long )((struct lru_cache *)0) && (mdev->act_log)->nr_elements == (unsigned int )mdev->sync_conf.al_extents) {
< #line 773
---
> #line 970
>   if ((unsigned long )mdev->act_log != (unsigned long )((struct lru_cache *)0) && (mdev->act_log)->nr_elements == dc->al_extents) {
> #line 972
56112c53682
< #line 775
---
> #line 974
56114c53684
< #line 776
---
> #line 975
56116,56119c53686,53688
< #line 777
<   n = lc_create("act_log", drbd_al_ext_cache, (unsigned int )mdev->sync_conf.al_extents,
<                 48UL, 0UL);
< #line 780
---
> #line 976
>   n = lc_create("act_log", drbd_al_ext_cache, 64U, dc->al_extents, 48UL, 0UL);
> #line 979
56121c53690
< #line 781
---
> #line 980
56123c53692
< #line 782
---
> #line 981
56128c53697
< #line 784
---
> #line 983
56130c53699
< #line 785
---
> #line 984
56132c53701
< #line 786
---
> #line 985
56134,56137c53703,53706
< #line 786
<     goto ldv_54163;
<     ldv_54162: 
< #line 787
---
> #line 985
>     goto ldv_53065;
>     ldv_53064: 
> #line 986
56139c53708
< #line 788
---
> #line 987
56141c53710
< #line 789
---
> #line 988
56147c53716
< #line 791
---
> #line 990
56149c53718
< #line 786
---
> #line 985
56151,56152c53720,53721
<     ldv_54163: ;
< #line 786
---
>     ldv_53065: ;
> #line 985
56154,56155c53723,53724
< #line 787
<       goto ldv_54162;
---
> #line 986
>       goto ldv_53064;
56163c53732
< #line 794
---
> #line 993
56165c53734
< #line 795
---
> #line 994
56170c53739
< #line 796
---
> #line 995
56172c53741
< #line 797
---
> #line 996
56174c53743
< #line 798
---
> #line 997
56176c53745
< #line 799
---
> #line 998
56178c53747
< #line 800
---
> #line 999
56181c53750
< #line 802
---
> #line 1001
56183c53752
< #line 803
---
> #line 1002
56188c53757
< #line 805
---
> #line 1004
56190c53759
< #line 806
---
> #line 1005
56194c53763
< #line 809 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
---
> #line 1008 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
56203a53773,53774
>   struct disk_conf *_________p1 ;
>   bool __warned ;
56205d53775
<   struct request_queue *b___0 ;
56206a53777,53779
>   int tmp___2 ;
>   struct request_queue *b___0 ;
>   int tmp___3 ;
56209c53782
< #line 811
---
> #line 1010
56211c53784
< #line 812
---
> #line 1011
56213c53786
< #line 813
---
> #line 1012
56215,56219c53788,53792
< #line 815
<   tmp___0 = _get_ldev_if_state(mdev, D_ATTACHING);
< #line 815
<   if (tmp___0 != 0) {
< #line 816
---
> #line 1014
>   tmp___2 = _get_ldev_if_state(mdev, D_ATTACHING);
> #line 1014
>   if (tmp___2 != 0) {
> #line 1015
56221c53794
< #line 818
---
> #line 1017
56223c53796
< #line 818
---
> #line 1017
56225c53798
< #line 818
---
> #line 1017
56227c53800
< #line 818
---
> #line 1017
56229,56231c53802,53829
< #line 819
<     max_segments = (unsigned int )(mdev->ldev)->dc.max_bio_bvecs;
< #line 820
---
> #line 1018
>     rcu_read_lock();
> #line 1019
>     _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 1019
>     tmp___0 = debug_lockdep_rcu_enabled();
> #line 1019
>     if (tmp___0 != 0 && ! __warned) {
> #line 1019
>       tmp___1 = rcu_read_lock_held();
> #line 1019
>       if (tmp___1 == 0 && 1) {
> #line 1019
>         __warned = 1;
> #line 1019
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                                1019, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 1019
>     max_segments = _________p1->max_bio_bvecs;
> #line 1020
>     rcu_read_unlock();
> #line 1021
56236c53834
< #line 823
---
> #line 1024
56238c53836
< #line 824
---
> #line 1025
56240c53838
< #line 826
---
> #line 1027
56242c53840
< #line 827
---
> #line 1028
56244,56248c53842,53846
< #line 829
<   tmp___1 = _get_ldev_if_state(mdev, D_ATTACHING);
< #line 829
<   if (tmp___1 != 0) {
< #line 830
---
> #line 1030
>   tmp___3 = _get_ldev_if_state(mdev, D_ATTACHING);
> #line 1030
>   if (tmp___3 != 0) {
> #line 1031
56250c53848
< #line 832
---
> #line 1033
56252c53850
< #line 834
---
> #line 1035
56254c53852
< #line 835
---
> #line 1036
56257c53855
< #line 838
---
> #line 1039
56262,56263c53860,62053
< #line 840
<     put_ldev(mdev);
---
> #line 1041
>     put_ldev(mdev);
>   } else {
> 
>   }
> #line 1043
>   return;
> }
> }
> #line 1045 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> void drbd_reconsider_max_bio_size(struct drbd_conf *mdev ) 
> { 
>   unsigned int now ;
>   unsigned int new ;
>   unsigned int local ;
>   unsigned int peer ;
>   unsigned int tmp ;
>   unsigned int tmp___0 ;
>   int tmp___1 ;
>   unsigned int _min1 ;
>   unsigned int _min2 ;
>   unsigned int _min1___0 ;
>   unsigned int _min2___0 ;
>   unsigned int _min1___1 ;
>   unsigned int _min2___1 ;
> 
>   {
> #line 1049
>   tmp = queue_max_hw_sectors(mdev->rq_queue);
> #line 1049
>   now = tmp << 9;
> #line 1050
>   local = mdev->local_max_bio_size;
> #line 1051
>   peer = mdev->peer_max_bio_size;
> #line 1053
>   tmp___1 = _get_ldev_if_state(mdev, D_ATTACHING);
> #line 1053
>   if (tmp___1 != 0) {
> #line 1054
>     tmp___0 = queue_max_hw_sectors((((mdev->ldev)->backing_bdev)->bd_disk)->queue);
> #line 1054
>     local = tmp___0 << 9;
> #line 1055
>     mdev->local_max_bio_size = local;
> #line 1056
>     put_ldev(mdev);
>   } else {
> 
>   }
> #line 1058
>   _min1 = local;
> #line 1058
>   _min2 = 1048576U;
> #line 1058
>   local = _min1 < _min2 ? _min1 : _min2;
> #line 1063
>   if ((int )mdev->state.ldv_50103.conn > 9) {
> #line 1064
>     if ((mdev->tconn)->agreed_pro_version <= 93) {
> #line 1065
>       _min1___0 = mdev->peer_max_bio_size;
> #line 1065
>       _min2___0 = 32768U;
> #line 1065
>       peer = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
>     } else
> #line 1067
>     if ((mdev->tconn)->agreed_pro_version == 94) {
> #line 1068
>       peer = 32768U;
>     } else
> #line 1069
>     if ((mdev->tconn)->agreed_pro_version <= 99) {
> #line 1070
>       peer = 131072U;
>     } else {
> #line 1072
>       peer = 1048576U;
>     }
>   } else {
> 
>   }
> #line 1075
>   _min1___1 = local;
> #line 1075
>   _min2___1 = peer;
> #line 1075
>   new = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
> #line 1077
>   if ((unsigned int )*((unsigned char *)mdev + 748UL) == 1U && new < now) {
> #line 1078
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED new < now; (%u < %u)\n",
>             new, now);
>   } else {
> 
>   }
> #line 1080
>   if (new != now) {
> #line 1081
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "max BIO size = %u\n",
>               new);
>   } else {
> 
>   }
> #line 1083
>   drbd_setup_queue_param(mdev, new);
> #line 1084
>   return;
> }
> }
> #line 1087 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static void conn_reconfig_start(struct drbd_tconn *tconn ) 
> { 
> 
> 
>   {
> #line 1089
>   drbd_thread_start(& tconn->worker);
> #line 1090
>   conn_flush_workqueue(tconn);
> #line 1091
>   return;
> }
> }
> #line 1094 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static void conn_reconfig_done(struct drbd_tconn *tconn ) 
> { 
>   bool stop_threads ;
>   bool tmp ;
> 
>   {
> #line 1097
>   spin_lock_irq(& tconn->req_lock);
> #line 1098
>   tmp = conn_all_vols_unconf(tconn);
> #line 1098
>   stop_threads = (bool )((int )tmp && (unsigned int )tconn->cstate == 0U);
> #line 1100
>   spin_unlock_irq(& tconn->req_lock);
> #line 1101
>   if ((int )stop_threads) {
> #line 1104
>     drbd_thread_stop(& tconn->receiver);
> #line 1105
>     drbd_thread_stop(& tconn->worker);
>   } else {
> 
>   }
> #line 1107
>   return;
> }
> }
> #line 1110 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static void drbd_suspend_al(struct drbd_conf *mdev ) 
> { 
>   int s ;
>   int tmp ;
>   int tmp___0 ;
> 
>   {
> #line 1112
>   s = 0;
> #line 1114
>   tmp = lc_try_lock(mdev->act_log);
> #line 1114
>   if (tmp == 0) {
> #line 1115
>     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Failed to lock al in drbd_suspend_al()\n");
> #line 1116
>     return;
>   } else {
> 
>   }
> #line 1119
>   drbd_al_shrink(mdev);
> #line 1120
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 1121
>   if ((int )mdev->state.ldv_50103.conn <= 9) {
> #line 1122
>     tmp___0 = test_and_set_bit(18, (unsigned long volatile   *)(& mdev->flags));
> #line 1122
>     s = tmp___0 == 0;
>   } else {
> 
>   }
> #line 1123
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 1124
>   lc_unlock(mdev->act_log);
> #line 1126
>   if (s != 0) {
> #line 1127
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Suspended AL updates\n");
>   } else {
> 
>   }
> #line 1128
>   return;
> }
> }
> #line 1131 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static bool should_set_defaults(struct genl_info *info ) 
> { 
>   unsigned int flags ;
> 
>   {
> #line 1133
>   flags = ((struct drbd_genlmsghdr *)info->userhdr)->ldv_49550.flags;
> #line 1134
>   return (((int )flags & 1) != 0);
> }
> }
> #line 1137 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static void enforce_disk_conf_limits(struct disk_conf *dc ) 
> { 
> 
> 
>   {
> #line 1139
>   if (dc->al_extents <= 6U) {
> #line 1140
>     dc->al_extents = 7U;
>   } else {
> 
>   }
> #line 1141
>   if (dc->al_extents > 6433U) {
> #line 1142
>     dc->al_extents = 6433U;
>   } else {
> 
>   }
> #line 1144
>   if (dc->c_plan_ahead > 300U) {
> #line 1145
>     dc->c_plan_ahead = 300U;
>   } else {
> 
>   }
> #line 1146
>   return;
> }
> }
> #line 1148 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_disk_opts(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   enum drbd_ret_code retcode ;
>   struct drbd_conf *mdev ;
>   struct disk_conf *new_disk_conf ;
>   struct disk_conf *old_disk_conf ;
>   struct fifo_buffer *old_plan ;
>   struct fifo_buffer *new_plan ;
>   int err ;
>   int fifo_size ;
>   int tmp ;
>   int tmp___0 ;
>   void *tmp___1 ;
>   bool tmp___2 ;
>   char const   *tmp___3 ;
>   bool _bool ;
>   int tmp___4 ;
>   int tmp___5 ;
>   wait_queue_t __wait ;
>   struct task_struct *tmp___6 ;
>   int tmp___7 ;
> 
>   {
> #line 1153
>   old_plan = 0;
> #line 1153
>   new_plan = 0;
> #line 1156
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 1156
>   retcode = (enum drbd_ret_code )tmp;
> #line 1157
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 1158
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 1159
>   if ((unsigned int )retcode != 101U) {
> #line 1160
>     goto out;
>   } else {
> 
>   }
> #line 1162
>   mdev = adm_ctx.mdev;
> #line 1166
>   tmp___0 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1166
>   if (tmp___0 == 0) {
> #line 1167
>     retcode = ERR_NO_DISK;
> #line 1168
>     goto out;
>   } else {
> 
>   }
> #line 1171
>   tmp___1 = kmalloc(344UL, 208U);
> #line 1171
>   new_disk_conf = (struct disk_conf *)tmp___1;
> #line 1172
>   if ((unsigned long )new_disk_conf == (unsigned long )((struct disk_conf *)0)) {
> #line 1173
>     retcode = ERR_NOMEM;
> #line 1174
>     goto fail;
>   } else {
> 
>   }
> #line 1177
>   mutex_lock_nested(& (mdev->tconn)->conf_update, 0U);
> #line 1178
>   old_disk_conf = (mdev->ldev)->disk_conf;
> #line 1179
>   *new_disk_conf = *old_disk_conf;
> #line 1180
>   tmp___2 = should_set_defaults(info);
> #line 1180
>   if ((int )tmp___2) {
> #line 1181
>     set_disk_conf_defaults(new_disk_conf);
>   } else {
> 
>   }
> #line 1183
>   err = disk_conf_from_attrs_for_change(new_disk_conf, info);
> #line 1184
>   if (err != 0 && err != -42) {
> #line 1185
>     retcode = ERR_MANDATORY_TAG;
> #line 1186
>     tmp___3 = from_attrs_err_to_txt(err);
> #line 1186
>     drbd_msg_put_info(tmp___3);
>   } else {
> 
>   }
> #line 1189
>   _bool = new_disk_conf->resync_rate != 0U;
> #line 1189
>   if (! _bool) {
> #line 1189
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERTION %s FAILED in %s\n",
>             (char *)"new_disk_conf->resync_rate >= 1", "drbd_adm_disk_opts");
>   } else {
> 
>   }
> #line 1189
>   if (_bool) {
> #line 1189
>     tmp___4 = 0;
>   } else {
> #line 1189
>     tmp___4 = 1;
>   }
> #line 1189
>   if (tmp___4) {
> #line 1190
>     new_disk_conf->resync_rate = 1U;
>   } else {
> 
>   }
> #line 1192
>   enforce_disk_conf_limits(new_disk_conf);
> #line 1194
>   fifo_size = (int )((new_disk_conf->c_plan_ahead * 250U) / 250U);
> #line 1195
>   if ((unsigned int )fifo_size != (mdev->rs_plan_s)->size) {
> #line 1196
>     new_plan = fifo_alloc(fifo_size);
> #line 1197
>     if ((unsigned long )new_plan == (unsigned long )((struct fifo_buffer *)0)) {
> #line 1198
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "kmalloc of fifo_buffer failed");
> #line 1199
>       retcode = ERR_NOMEM;
> #line 1200
>       goto fail_unlock;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1204
>   drbd_suspend_io(mdev);
> #line 1205
>   tmp___5 = lc_try_lock(mdev->act_log);
> #line 1205
>   if (tmp___5 != 0) {
> #line 1205
>     goto ldv_53134;
>   } else {
> 
>   }
> #line 1205
>   tmp___6 = get_current();
> #line 1205
>   __wait.flags = 0U;
> #line 1205
>   __wait.private = (void *)tmp___6;
> #line 1205
>   __wait.func = & autoremove_wake_function;
> #line 1205
>   __wait.task_list.next = & __wait.task_list;
> #line 1205
>   __wait.task_list.prev = & __wait.task_list;
>   ldv_53137: 
> #line 1205
>   prepare_to_wait(& mdev->al_wait, & __wait, 2);
> #line 1205
>   tmp___7 = lc_try_lock(mdev->act_log);
> #line 1205
>   if (tmp___7 != 0) {
> #line 1205
>     goto ldv_53136;
>   } else {
> 
>   }
> #line 1205
>   schedule();
> #line 1205
>   goto ldv_53137;
>   ldv_53136: 
> #line 1205
>   finish_wait(& mdev->al_wait, & __wait);
>   ldv_53134: 
> #line 1206
>   drbd_al_shrink(mdev);
> #line 1207
>   err = drbd_check_al_size(mdev, new_disk_conf);
> #line 1208
>   lc_unlock(mdev->act_log);
> #line 1209
>   __wake_up(& mdev->al_wait, 3U, 1, 0);
> #line 1210
>   drbd_resume_io(mdev);
> #line 1212
>   if (err != 0) {
> #line 1213
>     retcode = ERR_NOMEM;
> #line 1214
>     goto fail_unlock;
>   } else {
> 
>   }
> #line 1217
>   _raw_write_lock_irq(& global_state_lock);
> #line 1218
>   retcode = drbd_resync_after_valid(mdev, new_disk_conf->resync_after);
> #line 1219
>   if ((unsigned int )retcode == 101U) {
> #line 1220
>     __asm__  volatile   ("": : : "memory");
> #line 1220
>     (mdev->ldev)->disk_conf = new_disk_conf;
> #line 1221
>     drbd_resync_after_changed(mdev);
>   } else {
> 
>   }
> #line 1223
>   _raw_write_unlock_irq(& global_state_lock);
> #line 1225
>   if ((unsigned int )retcode != 101U) {
> #line 1226
>     goto fail_unlock;
>   } else {
> 
>   }
> #line 1228
>   if ((unsigned long )new_plan != (unsigned long )((struct fifo_buffer *)0)) {
> #line 1229
>     old_plan = mdev->rs_plan_s;
> #line 1230
>     __asm__  volatile   ("": : : "memory");
> #line 1230
>     mdev->rs_plan_s = new_plan;
>   } else {
> 
>   }
> #line 1233
>   mutex_unlock(& (mdev->tconn)->conf_update);
> #line 1235
>   if ((int )((signed char )new_disk_conf->al_updates) != 0) {
> #line 1236
>     (mdev->ldev)->md.flags = (mdev->ldev)->md.flags & 4294967039U;
>   } else {
> #line 1238
>     (mdev->ldev)->md.flags = (mdev->ldev)->md.flags | 256U;
>   }
> #line 1240
>   drbd_bump_write_ordering(mdev->tconn, WO_bdev_flush);
> #line 1242
>   drbd_md_sync(mdev);
> #line 1244
>   if ((int )mdev->state.ldv_50103.conn > 9) {
> #line 1245
>     drbd_send_sync_param(mdev);
>   } else {
> 
>   }
> #line 1247
>   synchronize_rcu();
> #line 1248
>   kfree((void const   *)old_disk_conf);
> #line 1249
>   kfree((void const   *)old_plan);
> #line 1250
>   mod_timer(& mdev->request_timer, (unsigned long )jiffies + 250UL);
> #line 1251
>   goto success;
>   fail_unlock: 
> #line 1254
>   mutex_unlock(& (mdev->tconn)->conf_update);
>   fail: 
> #line 1256
>   kfree((void const   *)new_disk_conf);
> #line 1257
>   kfree((void const   *)new_plan);
>   success: 
> #line 1259
>   put_ldev(mdev);
>   out: 
> #line 1261
>   drbd_adm_finish(info, (int )retcode);
> #line 1262
>   return (0);
> }
> }
> #line 1265 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_attach(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct drbd_conf *mdev ;
>   int err ;
>   enum drbd_ret_code retcode ;
>   enum determine_dev_size dd ;
>   sector_t max_possible_sectors ;
>   sector_t min_md_device_sectors ;
>   struct drbd_backing_dev *nbc ;
>   struct disk_conf *new_disk_conf ;
>   struct block_device *bdev ;
>   struct lru_cache *resync_lru ;
>   struct fifo_buffer *new_plan ;
>   union drbd_state ns ;
>   union drbd_state os ;
>   enum drbd_state_rv rv ;
>   struct net_conf *nc ;
>   int tmp ;
>   int tmp___0 ;
>   wait_queue_t __wait ;
>   struct task_struct *tmp___1 ;
>   int tmp___2 ;
>   void *tmp___3 ;
>   struct lock_class_key __key ;
>   void *tmp___4 ;
>   char const   *tmp___5 ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp___6 ;
>   int tmp___7 ;
>   long tmp___8 ;
>   long tmp___9 ;
>   long tmp___10 ;
>   long tmp___11 ;
>   sector_t tmp___12 ;
>   sector_t tmp___13 ;
>   sector_t tmp___14 ;
>   sector_t tmp___15 ;
>   sector_t tmp___16 ;
>   int tmp___17 ;
>   int tmp___18 ;
>   wait_queue_t __wait___0 ;
>   struct task_struct *tmp___19 ;
>   int tmp___20 ;
>   int tmp___21 ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   int tmp___22 ;
>   int tmp___23 ;
>   int tmp___24 ;
>   int tmp___25 ;
>   int tmp___26 ;
>   sector_t tmp___27 ;
>   int tmp___28 ;
>   int tmp___29 ;
>   int tmp___30 ;
>   int tmp___31 ;
>   int tmp___32 ;
>   int tmp___33 ;
>   int tmp___34 ;
>   int tmp___35 ;
>   int tmp___36 ;
>   unsigned long tmp___37 ;
>   unsigned long tmp___38 ;
>   int tmp___39 ;
>   int tmp___40 ;
>   int tmp___41 ;
>   struct disk_conf *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___42 ;
>   int tmp___43 ;
>   struct disk_conf *_________p1___1 ;
>   bool __warned___1 ;
>   int tmp___44 ;
>   int tmp___45 ;
>   union drbd_state val___0 ;
>   union drbd_state mask___0 ;
> 
>   {
> #line 1273
>   nbc = 0;
> #line 1274
>   new_disk_conf = 0;
> #line 1276
>   resync_lru = 0;
> #line 1277
>   new_plan = 0;
> #line 1282
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 1282
>   retcode = (enum drbd_ret_code )tmp;
> #line 1283
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 1284
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 1285
>   if ((unsigned int )retcode != 101U) {
> #line 1286
>     goto finish;
>   } else {
> 
>   }
> #line 1288
>   mdev = adm_ctx.mdev;
> #line 1289
>   conn_reconfig_start(mdev->tconn);
> #line 1292
>   if ((int )mdev->state.ldv_50103.disk > 0) {
> #line 1293
>     retcode = ERR_DISK_CONFIGURED;
> #line 1294
>     goto fail;
>   } else {
> 
>   }
> #line 1300
>   tmp___0 = atomic_read((atomic_t const   *)(& mdev->local_cnt));
> #line 1300
>   if (tmp___0 == 0) {
> #line 1300
>     goto ldv_53160;
>   } else {
> 
>   }
> #line 1300
>   tmp___1 = get_current();
> #line 1300
>   __wait.flags = 0U;
> #line 1300
>   __wait.private = (void *)tmp___1;
> #line 1300
>   __wait.func = & autoremove_wake_function;
> #line 1300
>   __wait.task_list.next = & __wait.task_list;
> #line 1300
>   __wait.task_list.prev = & __wait.task_list;
>   ldv_53163: 
> #line 1300
>   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
> #line 1300
>   tmp___2 = atomic_read((atomic_t const   *)(& mdev->local_cnt));
> #line 1300
>   if (tmp___2 == 0) {
> #line 1300
>     goto ldv_53162;
>   } else {
> 
>   }
> #line 1300
>   schedule();
> #line 1300
>   goto ldv_53163;
>   ldv_53162: 
> #line 1300
>   finish_wait(& mdev->misc_wait, & __wait);
>   ldv_53160: 
> #line 1303
>   clear_bit(14, (unsigned long volatile   *)(& mdev->flags));
> #line 1304
>   clear_bit(12, (unsigned long volatile   *)(& mdev->flags));
> #line 1305
>   clear_bit(13, (unsigned long volatile   *)(& mdev->flags));
> #line 1308
>   mdev->rs_total = 0UL;
> #line 1309
>   mdev->rs_failed = 0UL;
> #line 1310
>   atomic_set(& mdev->rs_pending_cnt, 0);
> #line 1313
>   tmp___3 = kzalloc(176UL, 208U);
> #line 1313
>   nbc = (struct drbd_backing_dev *)tmp___3;
> #line 1314
>   if ((unsigned long )nbc == (unsigned long )((struct drbd_backing_dev *)0)) {
> #line 1315
>     retcode = ERR_NOMEM;
> #line 1316
>     goto fail;
>   } else {
> 
>   }
> #line 1318
>   spinlock_check(& nbc->md.uuid_lock);
> #line 1318
>   __raw_spin_lock_init(& nbc->md.uuid_lock.ldv_6135.rlock, "&(&nbc->md.uuid_lock)->rlock",
>                        & __key);
> #line 1320
>   tmp___4 = kzalloc(344UL, 208U);
> #line 1320
>   new_disk_conf = (struct disk_conf *)tmp___4;
> #line 1321
>   if ((unsigned long )new_disk_conf == (unsigned long )((struct disk_conf *)0)) {
> #line 1322
>     retcode = ERR_NOMEM;
> #line 1323
>     goto fail;
>   } else {
> 
>   }
> #line 1325
>   nbc->disk_conf = new_disk_conf;
> #line 1327
>   set_disk_conf_defaults(new_disk_conf);
> #line 1328
>   err = disk_conf_from_attrs(new_disk_conf, info);
> #line 1329
>   if (err != 0) {
> #line 1330
>     retcode = ERR_MANDATORY_TAG;
> #line 1331
>     tmp___5 = from_attrs_err_to_txt(err);
> #line 1331
>     drbd_msg_put_info(tmp___5);
> #line 1332
>     goto fail;
>   } else {
> 
>   }
> #line 1335
>   enforce_disk_conf_limits(new_disk_conf);
> #line 1337
>   new_plan = fifo_alloc((int )((new_disk_conf->c_plan_ahead * 250U) / 250U));
> #line 1338
>   if ((unsigned long )new_plan == (unsigned long )((struct fifo_buffer *)0)) {
> #line 1339
>     retcode = ERR_NOMEM;
> #line 1340
>     goto fail;
>   } else {
> 
>   }
> #line 1343
>   if (new_disk_conf->meta_dev_idx < -3) {
> #line 1344
>     retcode = ERR_MD_IDX_INVALID;
> #line 1345
>     goto fail;
>   } else {
> 
>   }
> #line 1348
>   rcu_read_lock();
> #line 1349
>   _________p1 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 1349
>   tmp___6 = debug_lockdep_rcu_enabled();
> #line 1349
>   if (tmp___6 != 0 && ! __warned) {
> #line 1349
>     tmp___7 = rcu_read_lock_held();
> #line 1349
>     if (tmp___7 == 0 && 1) {
> #line 1349
>       __warned = 1;
> #line 1349
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                              1349, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1349
>   nc = _________p1;
> #line 1350
>   if ((unsigned long )nc != (unsigned long )((struct net_conf *)0)) {
> #line 1351
>     if (new_disk_conf->fencing == 2U && nc->wire_protocol == 1U) {
> #line 1352
>       rcu_read_unlock();
> #line 1353
>       retcode = ERR_STONITH_AND_PROT_A;
> #line 1354
>       goto fail;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1357
>   rcu_read_unlock();
> #line 1359
>   bdev = blkdev_get_by_path((char const   *)(& new_disk_conf->backing_dev), 131U,
>                             (void *)mdev);
> #line 1361
>   tmp___9 = IS_ERR((void const   *)bdev);
> #line 1361
>   if (tmp___9 != 0L) {
> #line 1362
>     tmp___8 = PTR_ERR((void const   *)bdev);
> #line 1362
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "open(\"%s\") failed with %ld\n",
>             (char *)(& new_disk_conf->backing_dev), tmp___8);
> #line 1364
>     retcode = ERR_OPEN_DISK;
> #line 1365
>     goto fail;
>   } else {
> 
>   }
> #line 1367
>   nbc->backing_bdev = bdev;
> #line 1377
>   bdev = blkdev_get_by_path((char const   *)(& new_disk_conf->meta_dev), 131U, new_disk_conf->meta_dev_idx < 0 ? (void *)mdev : (void *)drbd_m_holder);
> #line 1381
>   tmp___11 = IS_ERR((void const   *)bdev);
> #line 1381
>   if (tmp___11 != 0L) {
> #line 1382
>     tmp___10 = PTR_ERR((void const   *)bdev);
> #line 1382
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "open(\"%s\") failed with %ld\n",
>             (char *)(& new_disk_conf->meta_dev), tmp___10);
> #line 1384
>     retcode = ERR_OPEN_MD_DISK;
> #line 1385
>     goto fail;
>   } else {
> 
>   }
> #line 1387
>   nbc->md_bdev = bdev;
> #line 1389
>   if (((unsigned long )nbc->backing_bdev == (unsigned long )nbc->md_bdev) ^ (int )((_Bool )(new_disk_conf->meta_dev_idx == -1 || new_disk_conf->meta_dev_idx == -3))) {
> #line 1392
>     retcode = ERR_MD_IDX_INVALID;
> #line 1393
>     goto fail;
>   } else {
> 
>   }
> #line 1396
>   resync_lru = lc_create("resync", drbd_bm_ext_cache, 1U, 61U, 64UL, 16UL);
> #line 1399
>   if ((unsigned long )resync_lru == (unsigned long )((struct lru_cache *)0)) {
> #line 1400
>     retcode = ERR_NOMEM;
> #line 1401
>     goto fail;
>   } else {
> 
>   }
> #line 1405
>   drbd_md_set_sector_offsets(mdev, nbc);
> #line 1407
>   tmp___13 = drbd_get_max_capacity___1(nbc);
> #line 1407
>   if ((unsigned long long )tmp___13 < new_disk_conf->disk_size) {
> #line 1408
>     tmp___12 = drbd_get_max_capacity___1(nbc);
> #line 1408
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "max capacity %llu smaller than disk size %llu\n",
>             (unsigned long long )tmp___12, new_disk_conf->disk_size);
> #line 1411
>     retcode = ERR_DISK_TOO_SMALL;
> #line 1412
>     goto fail;
>   } else {
> 
>   }
> #line 1415
>   if (new_disk_conf->meta_dev_idx < 0) {
> #line 1416
>     max_possible_sectors = 2251799813685248UL;
> #line 1418
>     min_md_device_sectors = 2048UL;
>   } else {
> #line 1420
>     max_possible_sectors = 8587575296UL;
> #line 1421
>     min_md_device_sectors = (unsigned long )(new_disk_conf->meta_dev_idx + 1) * 262144UL;
>   }
> #line 1424
>   tmp___14 = drbd_get_capacity(nbc->md_bdev);
> #line 1424
>   if (tmp___14 < min_md_device_sectors) {
> #line 1425
>     retcode = ERR_MD_DISK_TOO_SMALL;
> #line 1426
>     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "refusing attach: md-device too small, at least %llu sectors needed for this meta-disk type\n",
>              (unsigned long long )min_md_device_sectors);
> #line 1429
>     goto fail;
>   } else {
> 
>   }
> #line 1434
>   tmp___15 = drbd_get_max_capacity___1(nbc);
> #line 1434
>   tmp___16 = drbd_get_capacity(mdev->this_bdev);
> #line 1434
>   if (tmp___15 < tmp___16) {
> #line 1436
>     retcode = ERR_DISK_TOO_SMALL;
> #line 1437
>     goto fail;
>   } else {
> 
>   }
> #line 1440
>   nbc->known_size = drbd_get_capacity(nbc->backing_bdev);
> #line 1442
>   if (nbc->known_size > max_possible_sectors) {
> #line 1443
>     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "==> truncating very big lower level device to currently maximum possible %llu sectors <==\n",
>              (unsigned long long )max_possible_sectors);
> #line 1446
>     if (new_disk_conf->meta_dev_idx >= 0) {
> #line 1447
>       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "==>> using internal or flexible meta data may help <<==\n");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1451
>   drbd_suspend_io(mdev);
> #line 1459
>   tmp___17 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
> #line 1459
>   if (tmp___17 == 0) {
> #line 1459
>     goto ldv_53168;
>   } else {
> #line 1459
>     tmp___18 = drbd_suspended(mdev);
> #line 1459
>     if (tmp___18 != 0) {
> #line 1459
>       goto ldv_53168;
>     } else {
> 
>     }
>   }
> #line 1459
>   tmp___19 = get_current();
> #line 1459
>   __wait___0.flags = 0U;
> #line 1459
>   __wait___0.private = (void *)tmp___19;
> #line 1459
>   __wait___0.func = & autoremove_wake_function;
> #line 1459
>   __wait___0.task_list.next = & __wait___0.task_list;
> #line 1459
>   __wait___0.task_list.prev = & __wait___0.task_list;
>   ldv_53171: 
> #line 1459
>   prepare_to_wait(& mdev->misc_wait, & __wait___0, 2);
> #line 1459
>   tmp___20 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
> #line 1459
>   if (tmp___20 == 0) {
> #line 1459
>     goto ldv_53170;
>   } else {
> #line 1459
>     tmp___21 = drbd_suspended(mdev);
> #line 1459
>     if (tmp___21 != 0) {
> #line 1459
>       goto ldv_53170;
>     } else {
> 
>     }
>   }
> #line 1459
>   schedule();
> #line 1459
>   goto ldv_53171;
>   ldv_53170: 
> #line 1459
>   finish_wait(& mdev->misc_wait, & __wait___0);
>   ldv_53168: 
> #line 1461
>   drbd_flush_workqueue(mdev);
> #line 1463
>   val.i = 0U;
> #line 1463
>   val.ldv_40604.disk = 1U;
> #line 1463
>   mask.i = 0U;
> #line 1463
>   mask.ldv_40604.disk = 15U;
> #line 1463
>   rv = _drbd_request_state(mdev, mask, val, CS_VERBOSE);
> #line 1464
>   retcode = (enum drbd_ret_code )rv;
> #line 1465
>   drbd_resume_io(mdev);
> #line 1466
>   if ((int )rv <= 0) {
> #line 1467
>     goto fail;
>   } else {
> 
>   }
> #line 1469
>   tmp___22 = _get_ldev_if_state(mdev, D_ATTACHING);
> #line 1469
>   if (tmp___22 == 0) {
> #line 1470
>     goto force_diskless;
>   } else {
> 
>   }
> #line 1472
>   drbd_md_set_sector_offsets(mdev, nbc);
> #line 1474
>   if ((unsigned long )mdev->bitmap == (unsigned long )((struct drbd_bitmap *)0)) {
> #line 1475
>     tmp___23 = drbd_bm_init(mdev);
> #line 1475
>     if (tmp___23 != 0) {
> #line 1476
>       retcode = ERR_NOMEM;
> #line 1477
>       goto force_diskless_dec;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1481
>   tmp___24 = drbd_md_read(mdev, nbc);
> #line 1481
>   retcode = (enum drbd_ret_code )tmp___24;
> #line 1482
>   if ((unsigned int )retcode != 101U) {
> #line 1483
>     goto force_diskless_dec;
>   } else {
> 
>   }
> #line 1485
>   if (((int )mdev->state.ldv_50103.conn <= 9 && (unsigned int )*((unsigned char *)mdev + 748UL) == 1U) && ((mdev->ed_uuid ^ nbc->md.uuid[0]) & 0xfffffffffffffffeULL) != 0ULL) {
> #line 1488
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Can only attach to data with current UUID=%016llX\n",
>             mdev->ed_uuid);
> #line 1490
>     retcode = ERR_DATA_NOT_CURRENT;
> #line 1491
>     goto force_diskless_dec;
>   } else {
> 
>   }
> #line 1495
>   tmp___25 = drbd_check_al_size(mdev, new_disk_conf);
> #line 1495
>   if (tmp___25 != 0) {
> #line 1496
>     retcode = ERR_NOMEM;
> #line 1497
>     goto force_diskless_dec;
>   } else {
> 
>   }
> #line 1501
>   tmp___26 = drbd_md_test_flag(nbc, 1);
> #line 1501
>   if (tmp___26 != 0) {
> #line 1501
>     tmp___27 = drbd_new_dev_size(mdev, nbc, (sector_t )(nbc->disk_conf)->disk_size,
>                                  0);
> #line 1501
>     if ((unsigned long long )tmp___27 < nbc->md.la_size_sect) {
> #line 1503
>       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "refusing to truncate a consistent device\n");
> #line 1504
>       retcode = ERR_DISK_TOO_SMALL;
> #line 1505
>       goto force_diskless_dec;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1510
>   if ((int )((signed char )new_disk_conf->md_flushes) != 0) {
> #line 1511
>     clear_bit(7, (unsigned long volatile   *)(& mdev->flags));
>   } else {
> #line 1513
>     set_bit(7U, (unsigned long volatile   *)(& mdev->flags));
>   }
> #line 1519
>   if ((unsigned long )mdev->ldev != (unsigned long )((struct drbd_backing_dev *)0)) {
> #line 1519
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->ldev == NULL ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>             1519);
>   } else {
> 
>   }
> #line 1520
>   mdev->ldev = nbc;
> #line 1521
>   mdev->resync = resync_lru;
> #line 1522
>   mdev->rs_plan_s = new_plan;
> #line 1523
>   nbc = 0;
> #line 1524
>   resync_lru = 0;
> #line 1525
>   new_disk_conf = 0;
> #line 1526
>   new_plan = 0;
> #line 1528
>   drbd_bump_write_ordering(mdev->tconn, WO_bdev_flush);
> #line 1530
>   tmp___28 = drbd_md_test_flag(mdev->ldev, 64);
> #line 1530
>   if (tmp___28 != 0) {
> #line 1531
>     set_bit(5U, (unsigned long volatile   *)(& mdev->flags));
>   } else {
> #line 1533
>     clear_bit(5, (unsigned long volatile   *)(& mdev->flags));
>   }
> #line 1535
>   tmp___29 = drbd_md_test_flag(mdev->ldev, 2);
> #line 1535
>   if (tmp___29 != 0 && ((unsigned int )*((unsigned char *)mdev + 748UL) != 1U || (unsigned int )*((unsigned char *)mdev->tconn + 132UL) == 0U)) {
> #line 1537
>     set_bit(5U, (unsigned long volatile   *)(& mdev->flags));
>   } else {
> 
>   }
> #line 1539
>   mdev->send_cnt = 0U;
> #line 1540
>   mdev->recv_cnt = 0U;
> #line 1541
>   mdev->read_cnt = 0U;
> #line 1542
>   mdev->writ_cnt = 0U;
> #line 1544
>   drbd_reconsider_max_bio_size(mdev);
> #line 1560
>   clear_bit(2, (unsigned long volatile   *)(& mdev->flags));
> #line 1561
>   if ((unsigned int )*((unsigned char *)mdev + 748UL) != 1U) {
> #line 1561
>     tmp___30 = drbd_md_test_flag(mdev->ldev, 2);
> #line 1561
>     if (tmp___30 != 0) {
> #line 1561
>       tmp___31 = drbd_md_test_flag(mdev->ldev, 4);
> #line 1561
>       if (tmp___31 == 0) {
> #line 1564
>         set_bit(2U, (unsigned long volatile   *)(& mdev->flags));
>       } else {
> 
>       }
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1566
>   dd = drbd_determine_dev_size(mdev, 0);
> #line 1567
>   if ((int )dd == -1) {
> #line 1568
>     retcode = ERR_NOMEM_BITMAP;
> #line 1569
>     goto force_diskless_dec;
>   } else
> #line 1570
>   if ((int )dd == 2) {
> #line 1571
>     set_bit(15U, (unsigned long volatile   *)(& mdev->flags));
>   } else {
> 
>   }
> #line 1573
>   tmp___34 = drbd_md_test_flag(mdev->ldev, 8);
> #line 1573
>   if (tmp___34 != 0) {
> #line 1573
>     goto _L;
>   } else {
> #line 1573
>     tmp___35 = constant_test_bit(5U, (unsigned long const volatile   *)(& mdev->flags));
> #line 1573
>     if (tmp___35 != 0) {
> #line 1573
>       tmp___36 = drbd_md_test_flag(mdev->ldev, 256);
> #line 1573
>       if (tmp___36 != 0) {
>         _L: /* CIL Label */ 
> #line 1576
>         _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Assuming that all blocks are out of sync (aka FullSync)\n");
> #line 1578
>         tmp___32 = drbd_bitmap_io(mdev, & drbd_bmio_set_n_write, (char *)"set_n_write from attaching",
>                                   BM_LOCKED_MASK);
> #line 1578
>         if (tmp___32 != 0) {
> #line 1580
>           retcode = ERR_IO_MD_DISK;
> #line 1581
>           goto force_diskless_dec;
>         } else {
> 
>         }
>       } else {
> #line 1573
>         goto _L___0;
>       }
>     } else {
>       _L___0: /* CIL Label */ 
> #line 1584
>       tmp___33 = drbd_bitmap_io(mdev, & drbd_bm_read, (char *)"read from attaching",
>                                 BM_LOCKED_MASK);
> #line 1584
>       if (tmp___33 != 0) {
> #line 1586
>         retcode = ERR_IO_MD_DISK;
> #line 1587
>         goto force_diskless_dec;
>       } else {
> 
>       }
>     }
>   }
> #line 1591
>   tmp___37 = _drbd_bm_total_weight(mdev);
> #line 1591
>   tmp___38 = drbd_bm_bits(mdev);
> #line 1591
>   if (tmp___37 == tmp___38) {
> #line 1592
>     drbd_suspend_al(mdev);
>   } else {
> 
>   }
> #line 1594
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 1595
>   os = drbd_read_state(mdev);
> #line 1596
>   ns = os;
> #line 1602
>   tmp___40 = drbd_md_test_flag(mdev->ldev, 1);
> #line 1602
>   if (tmp___40 != 0) {
> #line 1603
>     tmp___39 = drbd_md_test_flag(mdev->ldev, 16);
> #line 1603
>     if (tmp___39 != 0) {
> #line 1604
>       ns.ldv_40604.disk = 7U;
>     } else {
> #line 1606
>       ns.ldv_40604.disk = 5U;
>     }
>   } else {
> #line 1608
>     ns.ldv_40604.disk = 4U;
>   }
> #line 1611
>   tmp___41 = drbd_md_test_flag(mdev->ldev, 32);
> #line 1611
>   if (tmp___41 != 0) {
> #line 1612
>     ns.ldv_40604.pdsk = 5U;
>   } else {
> 
>   }
> #line 1614
>   rcu_read_lock();
> #line 1616
>   if ((unsigned int )*((unsigned char *)(& ns) + 1UL) == 14U) {
> #line 1616
>     if (*((unsigned int *)(& ns) + 0UL) == 40960U) {
> #line 1617
>       ns.ldv_40604.disk = 8U;
>     } else {
> #line 1616
>       _________p1___0 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 1616
>       tmp___42 = debug_lockdep_rcu_enabled();
> #line 1616
>       if (tmp___42 != 0 && ! __warned___0) {
> #line 1616
>         tmp___43 = rcu_read_lock_held();
> #line 1616
>         if (tmp___43 == 0 && 1) {
> #line 1616
>           __warned___0 = 1;
> #line 1616
>           lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                                  1616, "suspicious rcu_dereference_check() usage");
>         } else {
> 
>         }
>       } else {
> 
>       }
> #line 1616
>       if (_________p1___0->fencing == 0U) {
> #line 1617
>         ns.ldv_40604.disk = 8U;
>       } else {
> 
>       }
>     }
>   } else {
> 
>   }
> #line 1624
>   _________p1___1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 1624
>   tmp___44 = debug_lockdep_rcu_enabled();
> #line 1624
>   if (tmp___44 != 0 && ! __warned___1) {
> #line 1624
>     tmp___45 = rcu_read_lock_held();
> #line 1624
>     if (tmp___45 == 0 && 1) {
> #line 1624
>       __warned___1 = 1;
> #line 1624
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                              1624, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1624
>   if ((int )((signed char )_________p1___1->al_updates) != 0) {
> #line 1625
>     (mdev->ldev)->md.flags = (mdev->ldev)->md.flags & 4294967039U;
>   } else {
> #line 1627
>     (mdev->ldev)->md.flags = (mdev->ldev)->md.flags | 256U;
>   }
> #line 1629
>   rcu_read_unlock();
> #line 1633
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 160U) {
> #line 1634
>     mdev->new_state_tmp.i = ns.i;
> #line 1635
>     ns.i = os.i;
> #line 1636
>     ns.ldv_40604.disk = 3U;
> #line 1641
>     kfree((void const   *)mdev->p_uuid);
> #line 1642
>     mdev->p_uuid = 0;
>   } else {
> 
>   }
> #line 1645
>   rv = _drbd_set_state(mdev, ns, CS_VERBOSE, 0);
> #line 1646
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 1648
>   if ((int )rv <= 0) {
> #line 1649
>     goto force_diskless_dec;
>   } else {
> 
>   }
> #line 1651
>   mod_timer(& mdev->request_timer, (unsigned long )jiffies + 250UL);
> #line 1653
>   if ((unsigned int )*((unsigned char *)mdev + 748UL) == 1U) {
> #line 1654
>     (mdev->ldev)->md.uuid[0] = (mdev->ldev)->md.uuid[0] | 1ULL;
>   } else {
> #line 1656
>     (mdev->ldev)->md.uuid[0] = (mdev->ldev)->md.uuid[0] & 0xfffffffffffffffeULL;
>   }
> #line 1658
>   drbd_md_mark_dirty(mdev);
> #line 1659
>   drbd_md_sync(mdev);
> #line 1661
>   kobject_uevent(& (mdev->vdisk)->part0.__dev.kobj, KOBJ_CHANGE);
> #line 1662
>   put_ldev(mdev);
> #line 1663
>   conn_reconfig_done(mdev->tconn);
> #line 1664
>   drbd_adm_finish(info, (int )retcode);
> #line 1665
>   return (0);
>   force_diskless_dec: 
> #line 1668
>   put_ldev(mdev);
>   force_diskless: 
> #line 1670
>   val___0.i = 0U;
> #line 1670
>   val___0.ldv_40604.disk = 0U;
> #line 1670
>   mask___0.i = 0U;
> #line 1670
>   mask___0.ldv_40604.disk = 15U;
> #line 1670
>   drbd_force_state(mdev, mask___0, val___0);
> #line 1671
>   drbd_md_sync(mdev);
>   fail: 
> #line 1673
>   conn_reconfig_done(mdev->tconn);
> #line 1674
>   if ((unsigned long )nbc != (unsigned long )((struct drbd_backing_dev *)0)) {
> #line 1675
>     if ((unsigned long )nbc->backing_bdev != (unsigned long )((struct block_device *)0)) {
> #line 1676
>       blkdev_put(nbc->backing_bdev, 131U);
>     } else {
> 
>     }
> #line 1678
>     if ((unsigned long )nbc->md_bdev != (unsigned long )((struct block_device *)0)) {
> #line 1679
>       blkdev_put(nbc->md_bdev, 131U);
>     } else {
> 
>     }
> #line 1681
>     kfree((void const   *)nbc);
>   } else {
> 
>   }
> #line 1683
>   kfree((void const   *)new_disk_conf);
> #line 1684
>   lc_destroy(resync_lru);
> #line 1685
>   kfree((void const   *)new_plan);
>   finish: 
> #line 1688
>   drbd_adm_finish(info, (int )retcode);
> #line 1689
>   return (0);
> }
> }
> #line 1692 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static int adm_detach(struct drbd_conf *mdev , int force ) 
> { 
>   enum drbd_state_rv retcode ;
>   int ret ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   union drbd_state val___0 ;
>   union drbd_state mask___0 ;
>   int tmp ;
>   int __ret ;
>   wait_queue_t __wait ;
>   struct task_struct *tmp___0 ;
>   struct task_struct *tmp___1 ;
>   int tmp___2 ;
> 
>   {
> #line 1697
>   if (force != 0) {
> #line 1698
>     set_bit(14U, (unsigned long volatile   *)(& mdev->flags));
> #line 1699
>     val.i = 0U;
> #line 1699
>     val.ldv_40604.disk = 2U;
> #line 1699
>     mask.i = 0U;
> #line 1699
>     mask.ldv_40604.disk = 15U;
> #line 1699
>     drbd_force_state(mdev, mask, val);
> #line 1700
>     retcode = SS_SUCCESS;
> #line 1701
>     goto out;
>   } else {
> 
>   }
> #line 1704
>   drbd_suspend_io(mdev);
> #line 1705
>   drbd_md_get_buffer(mdev);
> #line 1706
>   val___0.i = 0U;
> #line 1706
>   val___0.ldv_40604.disk = 2U;
> #line 1706
>   mask___0.i = 0U;
> #line 1706
>   mask___0.ldv_40604.disk = 15U;
> #line 1706
>   tmp = drbd_request_state(mdev, mask___0, val___0);
> #line 1706
>   retcode = (enum drbd_state_rv )tmp;
> #line 1707
>   drbd_md_put_buffer(mdev);
> #line 1709
>   __ret = 0;
> #line 1709
>   if ((unsigned int )*((unsigned char *)mdev + 749UL) == 4U) {
> #line 1709
>     tmp___0 = get_current();
> #line 1709
>     __wait.flags = 0U;
> #line 1709
>     __wait.private = (void *)tmp___0;
> #line 1709
>     __wait.func = & autoremove_wake_function;
> #line 1709
>     __wait.task_list.next = & __wait.task_list;
> #line 1709
>     __wait.task_list.prev = & __wait.task_list;
>     ldv_53207: 
> #line 1709
>     prepare_to_wait(& mdev->misc_wait, & __wait, 1);
> #line 1709
>     if ((unsigned int )*((unsigned char *)mdev + 749UL) != 4U) {
> #line 1709
>       goto ldv_53205;
>     } else {
> 
>     }
> #line 1709
>     tmp___1 = get_current();
> #line 1709
>     tmp___2 = signal_pending(tmp___1);
> #line 1709
>     if (tmp___2 == 0) {
> #line 1709
>       schedule();
> #line 1709
>       goto ldv_53206;
>     } else {
> 
>     }
> #line 1709
>     __ret = -512;
> #line 1709
>     goto ldv_53205;
>     ldv_53206: ;
> #line 1709
>     goto ldv_53207;
>     ldv_53205: 
> #line 1709
>     finish_wait(& mdev->misc_wait, & __wait);
>   } else {
> 
>   }
> #line 1709
>   ret = __ret;
> #line 1711
>   drbd_resume_io(mdev);
> #line 1712
>   if ((int )retcode == -11) {
> #line 1713
>     retcode = SS_NOTHING_TO_DO;
>   } else {
> 
>   }
> #line 1714
>   if (ret != 0) {
> #line 1715
>     retcode = 129;
>   } else {
> 
>   }
>   out: ;
> #line 1717
>   return ((int )retcode);
> }
> }
> #line 1725 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_detach(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   enum drbd_ret_code retcode ;
>   struct detach_parms parms ;
>   int err ;
>   int tmp ;
>   char const   *tmp___0 ;
>   int tmp___1 ;
> 
>   {
> #line 1728
>   parms.force_detach = (char)0;
> #line 1731
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 1731
>   retcode = (enum drbd_ret_code )tmp;
> #line 1732
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 1733
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 1734
>   if ((unsigned int )retcode != 101U) {
> #line 1735
>     goto out;
>   } else {
> 
>   }
> #line 1737
>   if ((unsigned long )*(info->attrs + 13UL) != (unsigned long )((struct nlattr *)0)) {
> #line 1738
>     err = detach_parms_from_attrs(& parms, info);
> #line 1739
>     if (err != 0) {
> #line 1740
>       retcode = ERR_MANDATORY_TAG;
> #line 1741
>       tmp___0 = from_attrs_err_to_txt(err);
> #line 1741
>       drbd_msg_put_info(tmp___0);
> #line 1742
>       goto out;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1746
>   tmp___1 = adm_detach(adm_ctx.mdev, (int )parms.force_detach);
> #line 1746
>   retcode = (enum drbd_ret_code )tmp___1;
>   out: 
> #line 1748
>   drbd_adm_finish(info, (int )retcode);
> #line 1749
>   return (0);
> }
> }
> #line 1752 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static bool conn_resync_running(struct drbd_tconn *tconn ) 
> { 
>   struct drbd_conf *mdev ;
>   bool rv ;
>   int vnr ;
>   void *tmp ;
>   void *tmp___0 ;
> 
>   {
> #line 1755
>   rv = 0;
> #line 1758
>   rcu_read_lock();
> #line 1759
>   vnr = 0;
> #line 1759
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 1759
>   mdev = (struct drbd_conf *)tmp;
> #line 1759
>   goto ldv_53225;
>   ldv_53224: ;
> #line 1760
>   if ((((unsigned int )*((unsigned short *)mdev + 374UL) == 256U || (unsigned int )*((unsigned short *)mdev + 374UL) == 272U) || (unsigned int )*((unsigned short *)mdev + 374UL) == 320U) || (unsigned int )*((unsigned short *)mdev + 374UL) == 336U) {
> #line 1764
>     rv = 1;
> #line 1765
>     goto ldv_53223;
>   } else {
> 
>   }
> #line 1759
>   vnr = vnr + 1;
> #line 1759
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 1759
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_53225: ;
> #line 1759
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1760
>     goto ldv_53224;
>   } else {
> 
>   }
>   ldv_53223: 
> #line 1768
>   rcu_read_unlock();
> #line 1770
>   return (rv);
> }
> }
> #line 1773 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static bool conn_ov_running(struct drbd_tconn *tconn ) 
> { 
>   struct drbd_conf *mdev ;
>   bool rv ;
>   int vnr ;
>   void *tmp ;
>   void *tmp___0 ;
> 
>   {
> #line 1776
>   rv = 0;
> #line 1779
>   rcu_read_lock();
> #line 1780
>   vnr = 0;
> #line 1780
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 1780
>   mdev = (struct drbd_conf *)tmp;
> #line 1780
>   goto ldv_53234;
>   ldv_53233: ;
> #line 1781
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 288U || (unsigned int )*((unsigned short *)mdev + 374UL) == 304U) {
> #line 1783
>     rv = 1;
> #line 1784
>     goto ldv_53232;
>   } else {
> 
>   }
> #line 1780
>   vnr = vnr + 1;
> #line 1780
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 1780
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_53234: ;
> #line 1780
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1781
>     goto ldv_53233;
>   } else {
> 
>   }
>   ldv_53232: 
> #line 1787
>   rcu_read_unlock();
> #line 1789
>   return (rv);
> }
> }
> #line 1793 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static enum drbd_ret_code _check_net_options(struct drbd_tconn *tconn , struct net_conf *old_conf ,
>                                              struct net_conf *new_conf ) 
> { 
>   struct drbd_conf *mdev ;
>   int i ;
>   int tmp ;
>   enum drbd_role tmp___0 ;
>   enum drbd_role tmp___1 ;
>   void *tmp___2 ;
>   enum drbd_fencing_p fp ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___3 ;
>   int tmp___4 ;
>   int tmp___5 ;
>   void *tmp___6 ;
> 
>   {
> #line 1798
>   if (((unsigned long )old_conf != (unsigned long )((struct net_conf *)0) && (unsigned int )tconn->cstate == 9U) && tconn->agreed_pro_version <= 99) {
> #line 1799
>     if (new_conf->wire_protocol != old_conf->wire_protocol) {
> #line 1800
>       return (ERR_NEED_APV_100);
>     } else {
> 
>     }
> #line 1802
>     if ((int )((signed char )new_conf->two_primaries) != (int )((signed char )old_conf->two_primaries)) {
> #line 1803
>       return (ERR_NEED_APV_100);
>     } else {
> 
>     }
> #line 1805
>     tmp = strcmp((char const   *)(& new_conf->integrity_alg), (char const   *)(& old_conf->integrity_alg));
> #line 1805
>     if (tmp != 0) {
> #line 1806
>       return (ERR_NEED_APV_100);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1809
>   if ((int )((signed char )new_conf->two_primaries) == 0) {
> #line 1809
>     tmp___0 = conn_highest_role(tconn);
> #line 1809
>     if ((unsigned int )tmp___0 == 1U) {
> #line 1809
>       tmp___1 = conn_highest_peer(tconn);
> #line 1809
>       if ((unsigned int )tmp___1 == 1U) {
> #line 1812
>         return (ERR_NEED_ALLOW_TWO_PRI);
>       } else {
> 
>       }
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1814
>   if ((int )((signed char )new_conf->two_primaries) != 0 && new_conf->wire_protocol != 3U) {
> #line 1816
>     return (ERR_NOT_PROTO_C);
>   } else {
> 
>   }
> #line 1818
>   i = 0;
> #line 1818
>   tmp___2 = idr_get_next(& tconn->volumes, & i);
> #line 1818
>   mdev = (struct drbd_conf *)tmp___2;
> #line 1818
>   goto ldv_53247;
>   ldv_53246: 
> #line 1819
>   tmp___5 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1819
>   if (tmp___5 != 0) {
> #line 1820
>     _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 1820
>     tmp___3 = debug_lockdep_rcu_enabled();
> #line 1820
>     if (tmp___3 != 0 && ! __warned) {
> #line 1820
>       tmp___4 = rcu_read_lock_held();
> #line 1820
>       if (tmp___4 == 0 && 1) {
> #line 1820
>         __warned = 1;
> #line 1820
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                                1820, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 1820
>     fp = (enum drbd_fencing_p )_________p1->fencing;
> #line 1821
>     put_ldev(mdev);
> #line 1822
>     if (new_conf->wire_protocol == 1U && (int )fp == 2) {
> #line 1823
>       return (ERR_STONITH_AND_PROT_A);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1825
>   if ((unsigned int )*((unsigned char *)mdev + 748UL) == 1U && (int )((signed char )new_conf->discard_my_data) != 0) {
> #line 1826
>     return (ERR_DISCARD_IMPOSSIBLE);
>   } else {
> 
>   }
> #line 1818
>   i = i + 1;
> #line 1818
>   tmp___6 = idr_get_next(& tconn->volumes, & i);
> #line 1818
>   mdev = (struct drbd_conf *)tmp___6;
>   ldv_53247: ;
> #line 1818
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1819
>     goto ldv_53246;
>   } else {
> 
>   }
> 
> #line 1829
>   if (new_conf->on_congestion != 0U && new_conf->wire_protocol != 1U) {
> #line 1830
>     return (ERR_CONG_NOT_PROTO_A);
>   } else {
> 
>   }
> #line 1832
>   return (NO_ERROR);
> }
> }
> #line 1836 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static enum drbd_ret_code check_net_options(struct drbd_tconn *tconn , struct net_conf *new_conf ) 
> { 
>   enum drbd_ret_code rv ;
>   struct drbd_conf *mdev ;
>   int i ;
>   struct net_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
>   void *tmp___1 ;
>   int tmp___2 ;
>   void *tmp___3 ;
> 
>   {
> #line 1842
>   rcu_read_lock();
> #line 1843
>   _________p1 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 1843
>   tmp = debug_lockdep_rcu_enabled();
> #line 1843
>   if (tmp != 0 && ! __warned) {
> #line 1843
>     tmp___0 = rcu_read_lock_held();
> #line 1843
>     if (tmp___0 == 0 && 1) {
> #line 1843
>       __warned = 1;
> #line 1843
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                              1843, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1843
>   rv = _check_net_options(tconn, _________p1, new_conf);
> #line 1844
>   rcu_read_unlock();
> #line 1847
>   i = 0;
> #line 1847
>   tmp___1 = idr_get_next(& tconn->volumes, & i);
> #line 1847
>   mdev = (struct drbd_conf *)tmp___1;
> #line 1847
>   goto ldv_53260;
>   ldv_53259: ;
> #line 1848
>   if ((unsigned long )mdev->bitmap == (unsigned long )((struct drbd_bitmap *)0)) {
> #line 1849
>     tmp___2 = drbd_bm_init(mdev);
> #line 1849
>     if (tmp___2 != 0) {
> #line 1850
>       return (ERR_NOMEM);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1847
>   i = i + 1;
> #line 1847
>   tmp___3 = idr_get_next(& tconn->volumes, & i);
> #line 1847
>   mdev = (struct drbd_conf *)tmp___3;
>   ldv_53260: ;
> #line 1847
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1848
>     goto ldv_53259;
>   } else {
> 
>   }
> 
> #line 1854
>   return (rv);
> }
> }
> #line 1865 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static int alloc_hash(struct crypto_hash **tfm , char *tfm_name , int err_alg ) 
> { 
>   long tmp ;
> 
>   {
> #line 1867
>   if ((int )((signed char )*tfm_name) == 0) {
> #line 1868
>     return (101);
>   } else {
> 
>   }
> #line 1870
>   *tfm = crypto_alloc_hash((char const   *)tfm_name, 0U, 128U);
> #line 1871
>   tmp = IS_ERR((void const   *)*tfm);
> #line 1871
>   if (tmp != 0L) {
> #line 1872
>     *tfm = 0;
> #line 1873
>     return (err_alg);
>   } else {
> 
>   }
> #line 1876
>   return (101);
> }
> }
> #line 1880 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static enum drbd_ret_code alloc_crypto(struct crypto *crypto , struct net_conf *new_conf ) 
> { 
>   char hmac_name[64U] ;
>   enum drbd_ret_code rv ;
>   int tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
> 
>   {
> #line 1885
>   tmp = alloc_hash(& crypto->csums_tfm, (char *)(& new_conf->csums_alg), 144);
> #line 1885
>   rv = (enum drbd_ret_code )tmp;
> #line 1887
>   if ((unsigned int )rv != 101U) {
> #line 1888
>     return (rv);
>   } else {
> 
>   }
> #line 1889
>   tmp___0 = alloc_hash(& crypto->verify_tfm, (char *)(& new_conf->verify_alg), 146);
> #line 1889
>   rv = (enum drbd_ret_code )tmp___0;
> #line 1891
>   if ((unsigned int )rv != 101U) {
> #line 1892
>     return (rv);
>   } else {
> 
>   }
> #line 1893
>   tmp___1 = alloc_hash(& crypto->integrity_tfm, (char *)(& new_conf->integrity_alg),
>                        141);
> #line 1893
>   rv = (enum drbd_ret_code )tmp___1;
> #line 1895
>   if ((unsigned int )rv != 101U) {
> #line 1896
>     return (rv);
>   } else {
> 
>   }
> #line 1897
>   if ((int )((signed char )new_conf->cram_hmac_alg[0]) != 0) {
> #line 1898
>     snprintf((char *)(& hmac_name), 64UL, "hmac(%s)", (char *)(& new_conf->cram_hmac_alg));
> #line 1901
>     tmp___2 = alloc_hash(& crypto->cram_hmac_tfm, (char *)(& hmac_name), 120);
> #line 1901
>     rv = (enum drbd_ret_code )tmp___2;
>   } else {
> 
>   }
> #line 1905
>   return (rv);
> }
> }
> #line 1908 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static void free_crypto(struct crypto *crypto ) 
> { 
> 
> 
>   {
> #line 1910
>   crypto_free_hash(crypto->cram_hmac_tfm);
> #line 1911
>   crypto_free_hash(crypto->integrity_tfm);
> #line 1912
>   crypto_free_hash(crypto->csums_tfm);
> #line 1913
>   crypto_free_hash(crypto->verify_tfm);
> #line 1914
>   return;
> }
> }
> #line 1916 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_net_opts(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   enum drbd_ret_code retcode ;
>   struct drbd_tconn *tconn ;
>   struct net_conf *old_conf ;
>   struct net_conf *new_conf ;
>   int err ;
>   int ovr ;
>   int rsr ;
>   struct crypto crypto ;
>   int tmp ;
>   void *tmp___0 ;
>   bool tmp___1 ;
>   char const   *tmp___2 ;
>   bool tmp___3 ;
>   int tmp___4 ;
>   bool tmp___5 ;
>   int tmp___6 ;
>   int tmp___7 ;
>   struct drbd_conf *tmp___8 ;
> 
>   {
> #line 1920
>   new_conf = 0;
> #line 1924
>   crypto.verify_tfm = 0;
> #line 1924
>   crypto.csums_tfm = 0;
> #line 1924
>   crypto.cram_hmac_tfm = 0;
> #line 1924
>   crypto.integrity_tfm = 0;
> #line 1926
>   tmp = drbd_adm_prepare(skb, info, 4U);
> #line 1926
>   retcode = (enum drbd_ret_code )tmp;
> #line 1927
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 1928
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 1929
>   if ((unsigned int )retcode != 101U) {
> #line 1930
>     goto out;
>   } else {
> 
>   }
> #line 1932
>   tconn = adm_ctx.tconn;
> #line 1934
>   tmp___0 = kzalloc(420UL, 208U);
> #line 1934
>   new_conf = (struct net_conf *)tmp___0;
> #line 1935
>   if ((unsigned long )new_conf == (unsigned long )((struct net_conf *)0)) {
> #line 1936
>     retcode = ERR_NOMEM;
> #line 1937
>     goto out;
>   } else {
> 
>   }
> #line 1940
>   conn_reconfig_start(tconn);
> #line 1942
>   mutex_lock_nested(& tconn->data.mutex, 0U);
> #line 1943
>   mutex_lock_nested(& tconn->conf_update, 0U);
> #line 1944
>   old_conf = tconn->net_conf;
> #line 1946
>   if ((unsigned long )old_conf == (unsigned long )((struct net_conf *)0)) {
> #line 1947
>     drbd_msg_put_info("net conf missing, try connect");
> #line 1948
>     retcode = ERR_INVALID_REQUEST;
> #line 1949
>     goto fail;
>   } else {
> 
>   }
> #line 1952
>   *new_conf = *old_conf;
> #line 1953
>   tmp___1 = should_set_defaults(info);
> #line 1953
>   if ((int )tmp___1) {
> #line 1954
>     set_net_conf_defaults(new_conf);
>   } else {
> 
>   }
> #line 1956
>   err = net_conf_from_attrs_for_change(new_conf, info);
> #line 1957
>   if (err != 0 && err != -42) {
> #line 1958
>     retcode = ERR_MANDATORY_TAG;
> #line 1959
>     tmp___2 = from_attrs_err_to_txt(err);
> #line 1959
>     drbd_msg_put_info(tmp___2);
> #line 1960
>     goto fail;
>   } else {
> 
>   }
> #line 1963
>   retcode = check_net_options(tconn, new_conf);
> #line 1964
>   if ((unsigned int )retcode != 101U) {
> #line 1965
>     goto fail;
>   } else {
> 
>   }
> #line 1968
>   tmp___3 = conn_resync_running(tconn);
> #line 1968
>   rsr = (int )tmp___3;
> #line 1969
>   if (rsr != 0) {
> #line 1969
>     tmp___4 = strcmp((char const   *)(& new_conf->csums_alg), (char const   *)(& old_conf->csums_alg));
> #line 1969
>     if (tmp___4 != 0) {
> #line 1970
>       retcode = ERR_CSUMS_RESYNC_RUNNING;
> #line 1971
>       goto fail;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1975
>   tmp___5 = conn_ov_running(tconn);
> #line 1975
>   ovr = (int )tmp___5;
> #line 1976
>   if (ovr != 0) {
> #line 1976
>     tmp___6 = strcmp((char const   *)(& new_conf->verify_alg), (char const   *)(& old_conf->verify_alg));
> #line 1976
>     if (tmp___6 != 0) {
> #line 1977
>       retcode = ERR_VERIFY_RUNNING;
> #line 1978
>       goto fail;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 1981
>   retcode = alloc_crypto(& crypto, new_conf);
> #line 1982
>   if ((unsigned int )retcode != 101U) {
> #line 1983
>     goto fail;
>   } else {
> 
>   }
> #line 1985
>   __asm__  volatile   ("": : : "memory");
> #line 1985
>   tconn->net_conf = new_conf;
> #line 1987
>   if (rsr == 0) {
> #line 1988
>     crypto_free_hash(tconn->csums_tfm);
> #line 1989
>     tconn->csums_tfm = crypto.csums_tfm;
> #line 1990
>     crypto.csums_tfm = 0;
>   } else {
> 
>   }
> #line 1992
>   if (ovr == 0) {
> #line 1993
>     crypto_free_hash(tconn->verify_tfm);
> #line 1994
>     tconn->verify_tfm = crypto.verify_tfm;
> #line 1995
>     crypto.verify_tfm = 0;
>   } else {
> 
>   }
> #line 1998
>   crypto_free_hash(tconn->integrity_tfm);
> #line 1999
>   tconn->integrity_tfm = crypto.integrity_tfm;
> #line 2000
>   if ((unsigned int )tconn->cstate > 8U && tconn->agreed_pro_version > 99) {
> #line 2002
>     __drbd_send_protocol(tconn, P_PROTOCOL_UPDATE);
>   } else {
> 
>   }
> #line 2004
>   crypto_free_hash(tconn->cram_hmac_tfm);
> #line 2005
>   tconn->cram_hmac_tfm = crypto.cram_hmac_tfm;
> #line 2007
>   mutex_unlock(& tconn->conf_update);
> #line 2008
>   mutex_unlock(& tconn->data.mutex);
> #line 2009
>   synchronize_rcu();
> #line 2010
>   kfree((void const   *)old_conf);
> #line 2012
>   if ((unsigned int )tconn->cstate > 8U) {
> #line 2013
>     tmp___7 = conn_lowest_minor(tconn);
> #line 2013
>     tmp___8 = minor_to_mdev((unsigned int )tmp___7);
> #line 2013
>     drbd_send_sync_param(tmp___8);
>   } else {
> 
>   }
> #line 2015
>   goto done;
>   fail: 
> #line 2018
>   mutex_unlock(& tconn->conf_update);
> #line 2019
>   mutex_unlock(& tconn->data.mutex);
> #line 2020
>   free_crypto(& crypto);
> #line 2021
>   kfree((void const   *)new_conf);
>   done: 
> #line 2023
>   conn_reconfig_done(tconn);
>   out: 
> #line 2025
>   drbd_adm_finish(info, (int )retcode);
> #line 2026
>   return (0);
> }
> }
> #line 2029 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_connect(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct drbd_conf *mdev ;
>   struct net_conf *old_conf ;
>   struct net_conf *new_conf ;
>   struct crypto crypto ;
>   struct drbd_tconn *tconn ;
>   enum drbd_ret_code retcode ;
>   int i ;
>   int err ;
>   int tmp ;
>   struct list_head  const  *__mptr ;
>   int tmp___0 ;
>   void *tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
>   void *tmp___4 ;
>   int tmp___5 ;
>   struct list_head  const  *__mptr___0 ;
>   void *tmp___6 ;
>   char const   *tmp___7 ;
>   size_t __len ;
>   void *__ret ;
>   void *tmp___9 ;
>   size_t __len___0 ;
>   void *__ret___0 ;
>   void *tmp___11 ;
>   void *tmp___12 ;
>   void *tmp___13 ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   enum drbd_state_rv tmp___14 ;
> 
>   {
> #line 2032
>   new_conf = 0;
> #line 2033
>   crypto.verify_tfm = 0;
> #line 2033
>   crypto.csums_tfm = 0;
> #line 2033
>   crypto.cram_hmac_tfm = 0;
> #line 2033
>   crypto.integrity_tfm = 0;
> #line 2039
>   tmp = drbd_adm_prepare(skb, info, 2U);
> #line 2039
>   retcode = (enum drbd_ret_code )tmp;
> #line 2041
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2042
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 2043
>   if ((unsigned int )retcode != 101U) {
> #line 2044
>     goto out;
>   } else {
> 
>   }
> #line 2045
>   if ((unsigned long )adm_ctx.my_addr == (unsigned long )((struct nlattr *)0) || (unsigned long )adm_ctx.peer_addr == (unsigned long )((struct nlattr *)0)) {
> #line 2046
>     drbd_msg_put_info("connection endpoint(s) missing");
> #line 2047
>     retcode = ERR_INVALID_REQUEST;
> #line 2048
>     goto out;
>   } else {
> 
>   }
> #line 2054
>   __mptr = (struct list_head  const  *)drbd_tconns.next;
> #line 2054
>   tconn = (struct drbd_tconn *)__mptr + 0xfffffffffffffff8UL;
> #line 2054
>   goto ldv_53314;
>   ldv_53313: 
> #line 2055
>   tmp___0 = nla_len((struct nlattr  const  *)adm_ctx.my_addr);
> #line 2055
>   if (tmp___0 == tconn->my_addr_len) {
> #line 2055
>     tmp___1 = nla_data((struct nlattr  const  *)adm_ctx.my_addr);
> #line 2055
>     tmp___2 = memcmp((void const   *)tmp___1, (void const   *)(& tconn->my_addr),
>                      (size_t )tconn->my_addr_len);
> #line 2055
>     if (tmp___2 == 0) {
> #line 2057
>       retcode = ERR_LOCAL_ADDR;
> #line 2058
>       goto out;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2061
>   tmp___3 = nla_len((struct nlattr  const  *)adm_ctx.peer_addr);
> #line 2061
>   if (tmp___3 == tconn->peer_addr_len) {
> #line 2061
>     tmp___4 = nla_data((struct nlattr  const  *)adm_ctx.peer_addr);
> #line 2061
>     tmp___5 = memcmp((void const   *)tmp___4, (void const   *)(& tconn->peer_addr),
>                      (size_t )tconn->peer_addr_len);
> #line 2061
>     if (tmp___5 == 0) {
> #line 2063
>       retcode = ERR_PEER_ADDR;
> #line 2064
>       goto out;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2054
>   __mptr___0 = (struct list_head  const  *)tconn->all_tconn.next;
> #line 2054
>   tconn = (struct drbd_tconn *)__mptr___0 + 0xfffffffffffffff8UL;
>   ldv_53314: ;
> #line 2054
>   if ((unsigned long )(& tconn->all_tconn) != (unsigned long )(& drbd_tconns)) {
> #line 2055
>     goto ldv_53313;
>   } else {
> 
>   }
> #line 2068
>   tconn = adm_ctx.tconn;
> #line 2069
>   conn_reconfig_start(tconn);
> #line 2071
>   if ((unsigned int )tconn->cstate != 0U) {
> #line 2072
>     retcode = ERR_NET_CONFIGURED;
> #line 2073
>     goto fail;
>   } else {
> 
>   }
> #line 2077
>   tmp___6 = kzalloc(420UL, 208U);
> #line 2077
>   new_conf = (struct net_conf *)tmp___6;
> #line 2078
>   if ((unsigned long )new_conf == (unsigned long )((struct net_conf *)0)) {
> #line 2079
>     retcode = ERR_NOMEM;
> #line 2080
>     goto fail;
>   } else {
> 
>   }
> #line 2083
>   set_net_conf_defaults(new_conf);
> #line 2085
>   err = net_conf_from_attrs(new_conf, info);
> #line 2086
>   if (err != 0 && err != -42) {
> #line 2087
>     retcode = ERR_MANDATORY_TAG;
> #line 2088
>     tmp___7 = from_attrs_err_to_txt(err);
> #line 2088
>     drbd_msg_put_info(tmp___7);
> #line 2089
>     goto fail;
>   } else {
> 
>   }
> #line 2092
>   retcode = check_net_options(tconn, new_conf);
> #line 2093
>   if ((unsigned int )retcode != 101U) {
> #line 2094
>     goto fail;
>   } else {
> 
>   }
> #line 2096
>   retcode = alloc_crypto(& crypto, new_conf);
> #line 2097
>   if ((unsigned int )retcode != 101U) {
> #line 2098
>     goto fail;
>   } else {
> 
>   }
> #line 2100
>   *((char *)(& new_conf->shared_secret) + 63UL) = 0;
> #line 2102
>   conn_flush_workqueue(tconn);
> #line 2104
>   mutex_lock_nested(& tconn->conf_update, 0U);
> #line 2105
>   old_conf = tconn->net_conf;
> #line 2106
>   if ((unsigned long )old_conf != (unsigned long )((struct net_conf *)0)) {
> #line 2107
>     retcode = ERR_NET_CONFIGURED;
> #line 2108
>     mutex_unlock(& tconn->conf_update);
> #line 2109
>     goto fail;
>   } else {
> 
>   }
> #line 2111
>   __asm__  volatile   ("": : : "memory");
> #line 2111
>   tconn->net_conf = new_conf;
> #line 2113
>   conn_free_crypto(tconn);
> #line 2114
>   tconn->cram_hmac_tfm = crypto.cram_hmac_tfm;
> #line 2115
>   tconn->integrity_tfm = crypto.integrity_tfm;
> #line 2116
>   tconn->csums_tfm = crypto.csums_tfm;
> #line 2117
>   tconn->verify_tfm = crypto.verify_tfm;
> #line 2119
>   tconn->my_addr_len = nla_len((struct nlattr  const  *)adm_ctx.my_addr);
> #line 2120
>   __len = (size_t )tconn->my_addr_len;
> #line 2120
>   tmp___9 = nla_data((struct nlattr  const  *)adm_ctx.my_addr);
> #line 2120
>   __ret = __builtin_memcpy((void *)(& tconn->my_addr), (void const   *)tmp___9, __len);
> #line 2121
>   tconn->peer_addr_len = nla_len((struct nlattr  const  *)adm_ctx.peer_addr);
> #line 2122
>   __len___0 = (size_t )tconn->peer_addr_len;
> #line 2122
>   tmp___11 = nla_data((struct nlattr  const  *)adm_ctx.peer_addr);
> #line 2122
>   __ret___0 = __builtin_memcpy((void *)(& tconn->peer_addr), (void const   *)tmp___11,
>                                __len___0);
> #line 2124
>   mutex_unlock(& tconn->conf_update);
> #line 2126
>   rcu_read_lock();
> #line 2127
>   i = 0;
> #line 2127
>   tmp___12 = idr_get_next(& tconn->volumes, & i);
> #line 2127
>   mdev = (struct drbd_conf *)tmp___12;
> #line 2127
>   goto ldv_53324;
>   ldv_53323: 
> #line 2128
>   mdev->send_cnt = 0U;
> #line 2129
>   mdev->recv_cnt = 0U;
> #line 2127
>   i = i + 1;
> #line 2127
>   tmp___13 = idr_get_next(& tconn->volumes, & i);
> #line 2127
>   mdev = (struct drbd_conf *)tmp___13;
>   ldv_53324: ;
> #line 2127
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 2128
>     goto ldv_53323;
>   } else {
> 
>   }
> #line 2131
>   rcu_read_unlock();
> #line 2133
>   val.i = 0U;
> #line 2133
>   val.ldv_40604.conn = 2U;
> #line 2133
>   mask.i = 0U;
> #line 2133
>   mask.ldv_40604.conn = 31U;
> #line 2133
>   tmp___14 = conn_request_state(tconn, mask, val, CS_VERBOSE);
> #line 2133
>   retcode = (enum drbd_ret_code )tmp___14;
> #line 2135
>   conn_reconfig_done(tconn);
> #line 2136
>   drbd_adm_finish(info, (int )retcode);
> #line 2137
>   return (0);
>   fail: 
> #line 2140
>   free_crypto(& crypto);
> #line 2141
>   kfree((void const   *)new_conf);
> #line 2143
>   conn_reconfig_done(tconn);
>   out: 
> #line 2145
>   drbd_adm_finish(info, (int )retcode);
> #line 2146
>   return (0);
> }
> }
> #line 2149 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static enum drbd_state_rv conn_try_disconnect(struct drbd_tconn *tconn , bool force ) 
> { 
>   enum drbd_state_rv rv ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   union drbd_state val___0 ;
>   union drbd_state mask___0 ;
>   union drbd_state val___1 ;
>   union drbd_state mask___1 ;
>   union drbd_state val___2 ;
>   union drbd_state mask___2 ;
>   enum drbd_state_rv rv2 ;
>   union drbd_state val___3 ;
>   union drbd_state mask___3 ;
> 
>   {
> #line 2153
>   val.i = 0U;
> #line 2153
>   val.ldv_40604.conn = 1U;
> #line 2153
>   mask.i = 0U;
> #line 2153
>   mask.ldv_40604.conn = 31U;
> #line 2153
>   rv = conn_request_state(tconn, mask, val, (enum chg_state_flags )force);
> #line 2156
>   switch ((int )rv) {
>   case 2: ;
> #line 2158
>   goto ldv_53340;
>   case -9: ;
> #line 2160
>   return (SS_SUCCESS);
>   case -7: 
> #line 2164
>   val___0.i = 0U;
> #line 2164
>   val___0.ldv_40604.conn = 1U;
> #line 2164
>   val___0.ldv_40604.pdsk = 5U;
> #line 2163
>   mask___0.i = 0U;
> #line 2163
>   mask___0.ldv_40604.conn = 31U;
> #line 2164
>   mask___0.ldv_40604.pdsk = 15U;
> #line 2164
>   rv = conn_request_state(tconn, mask___0, val___0, CS_VERBOSE);
> #line 2165
>   goto ldv_53340;
>   case -10: 
> #line 2169
>   val___1.i = 0U;
> #line 2169
>   val___1.ldv_40604.conn = 1U;
> #line 2169
>   val___1.ldv_40604.disk = 5U;
> #line 2168
>   mask___1.i = 0U;
> #line 2168
>   mask___1.ldv_40604.conn = 31U;
> #line 2169
>   mask___1.ldv_40604.disk = 15U;
> #line 2169
>   rv = conn_request_state(tconn, mask___1, val___1, 0);
> #line 2170
>   if ((int )rv == -11 || (int )rv == -16) {
> #line 2171
>     val___2.i = 0U;
> #line 2171
>     val___2.ldv_40604.conn = 1U;
> #line 2171
>     mask___2.i = 0U;
> #line 2171
>     mask___2.ldv_40604.conn = 31U;
> #line 2171
>     rv = conn_request_state(tconn, mask___2, val___2, CS_HARD);
>   } else {
> 
>   }
> #line 2174
>   goto ldv_53340;
>   default: ;
>   }
>   ldv_53340: ;
> #line 2179
>   if ((int )rv > 0) {
> #line 2185
>     drbd_thread_stop(& (adm_ctx.tconn)->receiver);
> #line 2193
>     val___3.i = 0U;
> #line 2193
>     val___3.ldv_40604.conn = 0U;
> #line 2193
>     mask___3.i = 0U;
> #line 2193
>     mask___3.ldv_40604.conn = 31U;
> #line 2193
>     rv2 = conn_request_state(tconn, mask___3, val___3, 3);
> #line 2195
>     if ((int )rv2 <= 0) {
> #line 2196
>       printk("\vd-con %s: unexpected rv2=%d in conn_try_disconnect()\n", tconn->name,
>              (int )rv2);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2200
>   return (rv);
> }
> }
> #line 2203 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_disconnect(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct disconnect_parms parms ;
>   struct drbd_tconn *tconn ;
>   enum drbd_state_rv rv ;
>   enum drbd_ret_code retcode ;
>   int err ;
>   int tmp ;
>   char const   *tmp___0 ;
> 
>   {
> #line 2211
>   tmp = drbd_adm_prepare(skb, info, 4U);
> #line 2211
>   retcode = (enum drbd_ret_code )tmp;
> #line 2212
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2213
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 2214
>   if ((unsigned int )retcode != 101U) {
> #line 2215
>     goto fail;
>   } else {
> 
>   }
> #line 2217
>   tconn = adm_ctx.tconn;
> #line 2218
>   memset((void *)(& parms), 0, 1UL);
> #line 2219
>   if ((unsigned long )*(info->attrs + 12UL) != (unsigned long )((struct nlattr *)0)) {
> #line 2220
>     err = disconnect_parms_from_attrs(& parms, info);
> #line 2221
>     if (err != 0) {
> #line 2222
>       retcode = ERR_MANDATORY_TAG;
> #line 2223
>       tmp___0 = from_attrs_err_to_txt(err);
> #line 2223
>       drbd_msg_put_info(tmp___0);
> #line 2224
>       goto fail;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2228
>   rv = conn_try_disconnect(tconn, (int )((signed char )parms.force_disconnect) != 0);
> #line 2229
>   if ((int )rv <= 0) {
> #line 2230
>     retcode = (enum drbd_ret_code )rv;
>   } else {
> #line 2232
>     retcode = NO_ERROR;
>   }
>   fail: 
> #line 2234
>   drbd_adm_finish(info, (int )retcode);
> #line 2235
>   return (0);
> }
> }
> #line 2238 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> void resync_after_online_grow(struct drbd_conf *mdev ) 
> { 
>   int iass ;
>   union drbd_state val ;
>   union drbd_state mask ;
> 
>   {
> #line 2242
>   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Resync of new storage after online grow\n");
> #line 2243
>   if ((int )mdev->state.ldv_50103.role != (int )mdev->state.ldv_50103.peer) {
> #line 2244
>     iass = (unsigned int )*((unsigned char *)mdev + 748UL) == 1U;
>   } else {
> #line 2246
>     iass = constant_test_bit(1U, (unsigned long const volatile   *)(& (mdev->tconn)->flags));
>   }
> #line 2248
>   if (iass != 0) {
> #line 2249
>     drbd_start_resync(mdev, C_SYNC_SOURCE);
>   } else {
> #line 2251
>     val.i = 0U;
> #line 2251
>     val.ldv_40604.conn = 15U;
> #line 2251
>     mask.i = 0U;
> #line 2251
>     mask.ldv_40604.conn = 31U;
> #line 2251
>     _drbd_request_state(mdev, mask, val, 10);
>   }
> #line 2253
>   return;
> }
> }
> #line 2254 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_resize(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct disk_conf *old_disk_conf ;
>   struct disk_conf *new_disk_conf ;
>   struct resize_parms rs ;
>   struct drbd_conf *mdev ;
>   enum drbd_ret_code retcode ;
>   enum determine_dev_size dd ;
>   enum dds_flags ddsf ;
>   sector_t u_size ;
>   int err ;
>   int tmp ;
>   char const   *tmp___0 ;
>   int tmp___1 ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___2 ;
>   int tmp___3 ;
>   void *tmp___4 ;
>   sector_t tmp___5 ;
> 
>   {
> #line 2256
>   new_disk_conf = 0;
> #line 2265
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 2265
>   retcode = (enum drbd_ret_code )tmp;
> #line 2266
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2267
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 2268
>   if ((unsigned int )retcode != 101U) {
> #line 2269
>     goto fail;
>   } else {
> 
>   }
> #line 2271
>   memset((void *)(& rs), 0, 16UL);
> #line 2272
>   if ((unsigned long )*(info->attrs + 7UL) != (unsigned long )((struct nlattr *)0)) {
> #line 2273
>     err = resize_parms_from_attrs(& rs, info);
> #line 2274
>     if (err != 0) {
> #line 2275
>       retcode = ERR_MANDATORY_TAG;
> #line 2276
>       tmp___0 = from_attrs_err_to_txt(err);
> #line 2276
>       drbd_msg_put_info(tmp___0);
> #line 2277
>       goto fail;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2281
>   mdev = adm_ctx.mdev;
> #line 2282
>   if ((int )mdev->state.ldv_50103.conn > 10) {
> #line 2283
>     retcode = ERR_RESIZE_RESYNC;
> #line 2284
>     goto fail;
>   } else {
> 
>   }
> #line 2287
>   if ((unsigned int )*((unsigned char *)mdev + 748UL) == 2U && (unsigned int )*((unsigned char *)mdev + 748UL) == 8U) {
> #line 2289
>     retcode = ERR_NO_PRIMARY;
> #line 2290
>     goto fail;
>   } else {
> 
>   }
> #line 2293
>   tmp___1 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 2293
>   if (tmp___1 == 0) {
> #line 2294
>     retcode = ERR_NO_DISK;
> #line 2295
>     goto fail;
>   } else {
> 
>   }
> #line 2298
>   if ((int )((signed char )rs.no_resync) != 0 && (mdev->tconn)->agreed_pro_version <= 92) {
> #line 2299
>     retcode = ERR_NEED_APV_93;
> #line 2300
>     goto fail_ldev;
>   } else {
> 
>   }
> #line 2303
>   rcu_read_lock();
> #line 2304
>   _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 2304
>   tmp___2 = debug_lockdep_rcu_enabled();
> #line 2304
>   if (tmp___2 != 0 && ! __warned) {
> #line 2304
>     tmp___3 = rcu_read_lock_held();
> #line 2304
>     if (tmp___3 == 0 && 1) {
> #line 2304
>       __warned = 1;
> #line 2304
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                              2304, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2304
>   u_size = (sector_t )_________p1->disk_size;
> #line 2305
>   rcu_read_unlock();
> #line 2306
>   if ((unsigned long )rs.resize_size != u_size) {
> #line 2307
>     tmp___4 = kmalloc(344UL, 208U);
> #line 2307
>     new_disk_conf = (struct disk_conf *)tmp___4;
> #line 2308
>     if ((unsigned long )new_disk_conf == (unsigned long )((struct disk_conf *)0)) {
> #line 2309
>       retcode = ERR_NOMEM;
> #line 2310
>       goto fail_ldev;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2314
>   tmp___5 = drbd_get_capacity((mdev->ldev)->backing_bdev);
> #line 2314
>   if ((mdev->ldev)->known_size != tmp___5) {
> #line 2315
>     (mdev->ldev)->known_size = drbd_get_capacity((mdev->ldev)->backing_bdev);
>   } else {
> 
>   }
> #line 2317
>   if ((unsigned long )new_disk_conf != (unsigned long )((struct disk_conf *)0)) {
> #line 2318
>     mutex_lock_nested(& (mdev->tconn)->conf_update, 0U);
> #line 2319
>     old_disk_conf = (mdev->ldev)->disk_conf;
> #line 2320
>     *new_disk_conf = *old_disk_conf;
> #line 2321
>     new_disk_conf->disk_size = rs.resize_size;
> #line 2322
>     __asm__  volatile   ("": : : "memory");
> #line 2322
>     (mdev->ldev)->disk_conf = new_disk_conf;
> #line 2323
>     mutex_unlock(& (mdev->tconn)->conf_update);
> #line 2324
>     synchronize_rcu();
> #line 2325
>     kfree((void const   *)old_disk_conf);
>   } else {
> 
>   }
> #line 2328
>   ddsf = (enum dds_flags )(((int )((signed char )rs.resize_force) != 0) | ((int )((signed char )rs.no_resync) != 0 ? 2 : 0));
> #line 2329
>   dd = drbd_determine_dev_size(mdev, ddsf);
> #line 2330
>   drbd_md_sync(mdev);
> #line 2331
>   put_ldev(mdev);
> #line 2332
>   if ((int )dd == -1) {
> #line 2333
>     retcode = ERR_NOMEM_BITMAP;
> #line 2334
>     goto fail;
>   } else {
> 
>   }
> #line 2337
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 160U) {
> #line 2338
>     if ((int )dd == 2) {
> #line 2339
>       set_bit(16U, (unsigned long volatile   *)(& mdev->flags));
>     } else {
> 
>     }
> #line 2341
>     drbd_send_uuids(mdev);
> #line 2342
>     drbd_send_sizes(mdev, 1, ddsf);
>   } else {
> 
>   }
>   fail: 
> #line 2346
>   drbd_adm_finish(info, (int )retcode);
> #line 2347
>   return (0);
>   fail_ldev: 
> #line 2350
>   put_ldev(mdev);
> #line 2351
>   goto fail;
> }
> }
> #line 2354 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_resource_opts(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   enum drbd_ret_code retcode ;
>   struct drbd_tconn *tconn ;
>   struct res_opts res_opts ;
>   int err ;
>   int tmp ;
>   bool tmp___0 ;
>   char const   *tmp___1 ;
> 
>   {
> #line 2361
>   tmp = drbd_adm_prepare(skb, info, 2U);
> #line 2361
>   retcode = (enum drbd_ret_code )tmp;
> #line 2362
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2363
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 2364
>   if ((unsigned int )retcode != 101U) {
> #line 2365
>     goto fail;
>   } else {
> 
>   }
> #line 2366
>   tconn = adm_ctx.tconn;
> #line 2368
>   res_opts = tconn->res_opts;
> #line 2369
>   tmp___0 = should_set_defaults(info);
> #line 2369
>   if ((int )tmp___0) {
> #line 2370
>     set_res_opts_defaults(& res_opts);
>   } else {
> 
>   }
> #line 2372
>   err = res_opts_from_attrs(& res_opts, info);
> #line 2373
>   if (err != 0 && err != -42) {
> #line 2374
>     retcode = ERR_MANDATORY_TAG;
> #line 2375
>     tmp___1 = from_attrs_err_to_txt(err);
> #line 2375
>     drbd_msg_put_info(tmp___1);
> #line 2376
>     goto fail;
>   } else {
> 
>   }
> #line 2379
>   err = set_resource_options(tconn, & res_opts);
> #line 2380
>   if (err != 0) {
> #line 2381
>     retcode = ERR_INVALID_REQUEST;
> #line 2382
>     if (err == -12) {
> #line 2383
>       retcode = ERR_NOMEM;
>     } else {
> 
>     }
>   } else {
> 
>   }
>   fail: 
> #line 2387
>   drbd_adm_finish(info, (int )retcode);
> #line 2388
>   return (0);
> }
> }
> #line 2391 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_invalidate(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct drbd_conf *mdev ;
>   int retcode ;
>   int tmp ;
>   wait_queue_t __wait ;
>   struct task_struct *tmp___0 ;
>   int tmp___1 ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   enum drbd_state_rv tmp___2 ;
>   union drbd_state val___0 ;
>   union drbd_state mask___0 ;
>   union drbd_state __ns ;
>   enum drbd_state_rv tmp___3 ;
>   union drbd_state val___1 ;
>   union drbd_state mask___1 ;
> 
>   {
> #line 2396
>   retcode = drbd_adm_prepare(skb, info, 1U);
> #line 2397
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2398
>     return (retcode);
>   } else {
> 
>   }
> #line 2399
>   if (retcode != 101) {
> #line 2400
>     goto out;
>   } else {
> 
>   }
> #line 2402
>   mdev = adm_ctx.mdev;
> #line 2407
>   drbd_suspend_io(mdev);
> #line 2408
>   tmp = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2408
>   if (tmp == 0) {
> #line 2408
>     goto ldv_53414;
>   } else {
> 
>   }
> #line 2408
>   tmp___0 = get_current();
> #line 2408
>   __wait.flags = 0U;
> #line 2408
>   __wait.private = (void *)tmp___0;
> #line 2408
>   __wait.func = & autoremove_wake_function;
> #line 2408
>   __wait.task_list.next = & __wait.task_list;
> #line 2408
>   __wait.task_list.prev = & __wait.task_list;
>   ldv_53417: 
> #line 2408
>   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
> #line 2408
>   tmp___1 = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2408
>   if (tmp___1 == 0) {
> #line 2408
>     goto ldv_53416;
>   } else {
> 
>   }
> #line 2408
>   schedule();
> #line 2408
>   goto ldv_53417;
>   ldv_53416: 
> #line 2408
>   finish_wait(& mdev->misc_wait, & __wait);
>   ldv_53414: 
> #line 2409
>   drbd_flush_workqueue(mdev);
> #line 2411
>   val.i = 0U;
> #line 2411
>   val.ldv_40604.conn = 12U;
> #line 2411
>   mask.i = 0U;
> #line 2411
>   mask.ldv_40604.conn = 31U;
> #line 2411
>   tmp___2 = _drbd_request_state(mdev, mask, val, CS_ORDERED);
> #line 2411
>   retcode = (int )tmp___2;
> #line 2413
>   if (retcode <= 0 && retcode != -15) {
> #line 2414
>     val___0.i = 0U;
> #line 2414
>     val___0.ldv_40604.conn = 12U;
> #line 2414
>     mask___0.i = 0U;
> #line 2414
>     mask___0.ldv_40604.conn = 31U;
> #line 2414
>     retcode = drbd_request_state(mdev, mask___0, val___0);
>   } else {
> 
>   }
> #line 2416
>   goto ldv_53434;
>   ldv_53433: 
> #line 2417
>   spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 2418
>   if ((int )mdev->state.ldv_50103.conn <= 9) {
> #line 2419
>     __ns = drbd_read_state(mdev);
> #line 2419
>     __ns.ldv_40604.disk = 4U;
> #line 2419
>     tmp___3 = _drbd_set_state(mdev, __ns, CS_VERBOSE, 0);
> #line 2419
>     retcode = (int )tmp___3;
>   } else {
> 
>   }
> #line 2420
>   spin_unlock_irq(& (mdev->tconn)->req_lock);
> #line 2422
>   if (retcode != -15) {
> #line 2423
>     goto ldv_53428;
>   } else {
> 
>   }
> #line 2425
>   val___1.i = 0U;
> #line 2425
>   val___1.ldv_40604.conn = 12U;
> #line 2425
>   mask___1.i = 0U;
> #line 2425
>   mask___1.ldv_40604.conn = 31U;
> #line 2425
>   retcode = drbd_request_state(mdev, mask___1, val___1);
>   ldv_53434: ;
> #line 2416
>   if (retcode == -15) {
> #line 2417
>     goto ldv_53433;
>   } else {
> 
>   }
>   ldv_53428: 
> #line 2427
>   drbd_resume_io(mdev);
>   out: 
> #line 2430
>   drbd_adm_finish(info, retcode);
> #line 2431
>   return (0);
> }
> }
> #line 2434 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static int drbd_adm_simple_request_state(struct sk_buff *skb , struct genl_info *info ,
>                                          union drbd_state mask , union drbd_state val ) 
> { 
>   enum drbd_ret_code retcode ;
>   int tmp ;
>   int tmp___0 ;
> 
>   {
> #line 2439
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 2439
>   retcode = (enum drbd_ret_code )tmp;
> #line 2440
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2441
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 2442
>   if ((unsigned int )retcode != 101U) {
> #line 2443
>     goto out;
>   } else {
> 
>   }
> #line 2445
>   tmp___0 = drbd_request_state(adm_ctx.mdev, mask, val);
> #line 2445
>   retcode = (enum drbd_ret_code )tmp___0;
>   out: 
> #line 2447
>   drbd_adm_finish(info, (int )retcode);
> #line 2448
>   return (0);
> }
> }
> #line 2451 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static int drbd_bmio_set_susp_al(struct drbd_conf *mdev ) 
> { 
>   int rv ;
> 
>   {
> #line 2455
>   rv = drbd_bmio_set_n_write(mdev);
> #line 2456
>   drbd_suspend_al(mdev);
> #line 2457
>   return (rv);
> }
> }
> #line 2460 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_invalidate_peer(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   int retcode ;
>   struct drbd_conf *mdev ;
>   int tmp ;
>   wait_queue_t __wait ;
>   struct task_struct *tmp___0 ;
>   int tmp___1 ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   enum drbd_state_rv tmp___2 ;
>   union drbd_state val___0 ;
>   union drbd_state mask___0 ;
>   int tmp___3 ;
>   union drbd_state val___1 ;
>   union drbd_state mask___1 ;
> 
>   {
> #line 2465
>   retcode = drbd_adm_prepare(skb, info, 1U);
> #line 2466
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2467
>     return (retcode);
>   } else {
> 
>   }
> #line 2468
>   if (retcode != 101) {
> #line 2469
>     goto out;
>   } else {
> 
>   }
> #line 2471
>   mdev = adm_ctx.mdev;
> #line 2476
>   drbd_suspend_io(mdev);
> #line 2477
>   tmp = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2477
>   if (tmp == 0) {
> #line 2477
>     goto ldv_53454;
>   } else {
> 
>   }
> #line 2477
>   tmp___0 = get_current();
> #line 2477
>   __wait.flags = 0U;
> #line 2477
>   __wait.private = (void *)tmp___0;
> #line 2477
>   __wait.func = & autoremove_wake_function;
> #line 2477
>   __wait.task_list.next = & __wait.task_list;
> #line 2477
>   __wait.task_list.prev = & __wait.task_list;
>   ldv_53457: 
> #line 2477
>   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
> #line 2477
>   tmp___1 = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2477
>   if (tmp___1 == 0) {
> #line 2477
>     goto ldv_53456;
>   } else {
> 
>   }
> #line 2477
>   schedule();
> #line 2477
>   goto ldv_53457;
>   ldv_53456: 
> #line 2477
>   finish_wait(& mdev->misc_wait, & __wait);
>   ldv_53454: 
> #line 2478
>   drbd_flush_workqueue(mdev);
> #line 2480
>   val.i = 0U;
> #line 2480
>   val.ldv_40604.conn = 11U;
> #line 2480
>   mask.i = 0U;
> #line 2480
>   mask.ldv_40604.conn = 31U;
> #line 2480
>   tmp___2 = _drbd_request_state(mdev, mask, val, CS_ORDERED);
> #line 2480
>   retcode = (int )tmp___2;
> #line 2481
>   if (retcode <= 0) {
> #line 2482
>     if (retcode == -15 && (unsigned int )*((unsigned char *)mdev + 748UL) == 1U) {
> #line 2485
>       val___0.i = 0U;
> #line 2485
>       val___0.ldv_40604.pdsk = 4U;
> #line 2485
>       mask___0.i = 0U;
> #line 2485
>       mask___0.ldv_40604.pdsk = 15U;
> #line 2485
>       retcode = drbd_request_state(mdev, mask___0, val___0);
> #line 2486
>       if (retcode > 0) {
> #line 2487
>         tmp___3 = drbd_bitmap_io(mdev, & drbd_bmio_set_susp_al, (char *)"set_n_write from invalidate_peer",
>                                  BM_LOCKED_SET_ALLOWED);
> #line 2487
>         if (tmp___3 != 0) {
> #line 2490
>           retcode = 118;
>         } else {
> 
>         }
>       } else {
> 
>       }
>     } else {
> #line 2493
>       val___1.i = 0U;
> #line 2493
>       val___1.ldv_40604.conn = 11U;
> #line 2493
>       mask___1.i = 0U;
> #line 2493
>       mask___1.ldv_40604.conn = 31U;
> #line 2493
>       retcode = drbd_request_state(mdev, mask___1, val___1);
>     }
>   } else {
> 
>   }
> #line 2495
>   drbd_resume_io(mdev);
>   out: 
> #line 2498
>   drbd_adm_finish(info, retcode);
> #line 2499
>   return (0);
> }
> }
> #line 2502 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_pause_sync(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   enum drbd_ret_code retcode ;
>   int tmp ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   int tmp___0 ;
> 
>   {
> #line 2506
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 2506
>   retcode = (enum drbd_ret_code )tmp;
> #line 2507
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2508
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 2509
>   if ((unsigned int )retcode != 101U) {
> #line 2510
>     goto out;
>   } else {
> 
>   }
> #line 2512
>   val.i = 0U;
> #line 2512
>   val.ldv_40604.user_isp = 1U;
> #line 2512
>   mask.i = 0U;
> #line 2512
>   mask.ldv_40604.user_isp = 1U;
> #line 2512
>   tmp___0 = drbd_request_state(adm_ctx.mdev, mask, val);
> #line 2512
>   if (tmp___0 == 2) {
> #line 2513
>     retcode = ERR_PAUSE_IS_SET;
>   } else {
> 
>   }
>   out: 
> #line 2515
>   drbd_adm_finish(info, (int )retcode);
> #line 2516
>   return (0);
> }
> }
> #line 2519 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_resume_sync(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   union drbd_dev_state s ;
>   enum drbd_ret_code retcode ;
>   int tmp ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   int tmp___0 ;
> 
>   {
> #line 2524
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 2524
>   retcode = (enum drbd_ret_code )tmp;
> #line 2525
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2526
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 2527
>   if ((unsigned int )retcode != 101U) {
> #line 2528
>     goto out;
>   } else {
> 
>   }
> #line 2530
>   val.i = 0U;
> #line 2530
>   val.ldv_40604.user_isp = 0U;
> #line 2530
>   mask.i = 0U;
> #line 2530
>   mask.ldv_40604.user_isp = 1U;
> #line 2530
>   tmp___0 = drbd_request_state(adm_ctx.mdev, mask, val);
> #line 2530
>   if (tmp___0 == 2) {
> #line 2531
>     s = (adm_ctx.mdev)->state;
> #line 2532
>     if ((unsigned int )*((unsigned short *)(& s) + 0UL) == 320U || (unsigned int )*((unsigned short *)(& s) + 0UL) == 336U) {
> #line 2533
>       retcode = (unsigned int )*((unsigned char *)(& s) + 2UL) == 0U ? ((unsigned int )*((unsigned char *)(& s) + 2UL) != 0U ? ERR_PIC_PEER_DEP : ERR_PAUSE_IS_CLEAR) : ERR_PIC_AFTER_DEP;
>     } else {
> #line 2536
>       retcode = ERR_PAUSE_IS_CLEAR;
>     }
>   } else {
> 
>   }
>   out: 
> #line 2541
>   drbd_adm_finish(info, (int )retcode);
> #line 2542
>   return (0);
> }
> }
> #line 2545 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_suspend_io(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   union drbd_state val ;
>   union drbd_state mask ;
>   int tmp ;
> 
>   {
> #line 2547
>   val.i = 0U;
> #line 2547
>   val.ldv_40604.susp = 1U;
> #line 2547
>   mask.i = 0U;
> #line 2547
>   mask.ldv_40604.susp = 1U;
> #line 2547
>   tmp = drbd_adm_simple_request_state(skb, info, mask, val);
> #line 2547
>   return (tmp);
> }
> }
> #line 2550 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_resume_io(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct drbd_conf *mdev ;
>   int retcode ;
>   int tmp ;
>   union drbd_state val ;
>   union drbd_state mask ;
> 
>   {
> #line 2555
>   retcode = drbd_adm_prepare(skb, info, 1U);
> #line 2556
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2557
>     return (retcode);
>   } else {
> 
>   }
> #line 2558
>   if (retcode != 101) {
> #line 2559
>     goto out;
>   } else {
> 
>   }
> #line 2561
>   mdev = adm_ctx.mdev;
> #line 2562
>   tmp = constant_test_bit(17U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2562
>   if (tmp != 0) {
> #line 2563
>     drbd_uuid_new_current(mdev);
> #line 2564
>     clear_bit(17, (unsigned long volatile   *)(& mdev->flags));
>   } else {
> 
>   }
> #line 2566
>   drbd_suspend_io(mdev);
> #line 2567
>   val.i = 0U;
> #line 2567
>   val.ldv_40604.susp = 0U;
> #line 2567
>   val.ldv_40604.susp_nod = 0U;
> #line 2567
>   val.ldv_40604.susp_fen = 0U;
> #line 2567
>   mask.i = 0U;
> #line 2567
>   mask.ldv_40604.susp = 1U;
> #line 2567
>   mask.ldv_40604.susp_nod = 1U;
> #line 2567
>   mask.ldv_40604.susp_fen = 1U;
> #line 2567
>   retcode = drbd_request_state(mdev, mask, val);
> #line 2568
>   if (retcode == 1) {
> #line 2569
>     if ((int )mdev->state.ldv_50103.conn <= 9) {
> #line 2570
>       tl_clear(mdev->tconn);
>     } else {
> 
>     }
> #line 2571
>     if ((unsigned int )*((unsigned char *)mdev + 749UL) == 0U || (unsigned int )*((unsigned char *)mdev + 749UL) == 4U) {
> #line 2572
>       tl_restart(mdev->tconn, FAIL_FROZEN_DISK_IO);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2574
>   drbd_resume_io(mdev);
>   out: 
> #line 2577
>   drbd_adm_finish(info, retcode);
> #line 2578
>   return (0);
> }
> }
> #line 2581 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_outdate(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   union drbd_state val ;
>   union drbd_state mask ;
>   int tmp ;
> 
>   {
> #line 2583
>   val.i = 0U;
> #line 2583
>   val.ldv_40604.disk = 5U;
> #line 2583
>   mask.i = 0U;
> #line 2583
>   mask.ldv_40604.disk = 15U;
> #line 2583
>   tmp = drbd_adm_simple_request_state(skb, info, mask, val);
> #line 2583
>   return (tmp);
> }
> }
> #line 2586 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int nla_put_drbd_cfg_context(struct sk_buff *skb , struct drbd_tconn *tconn , unsigned int vnr ) 
> { 
>   struct nlattr *nla ;
>   int tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
> 
>   {
> #line 2589
>   nla = nla_nest_start(skb, 2);
> #line 2590
>   if ((unsigned long )nla == (unsigned long )((struct nlattr *)0)) {
> #line 2591
>     goto nla_put_failure;
>   } else {
> 
>   }
> #line 2592
>   if (vnr != 4294967295U) {
> #line 2592
>     tmp = nla_put_u32(skb, 16385, vnr);
> #line 2592
>     if (tmp != 0) {
> #line 2594
>       goto nla_put_failure;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2595
>   tmp___0 = nla_put_string(skb, 16386, (char const   *)tconn->name);
> #line 2595
>   if (tmp___0 != 0) {
> #line 2596
>     goto nla_put_failure;
>   } else {
> 
>   }
> #line 2597
>   if (tconn->my_addr_len != 0) {
> #line 2597
>     tmp___1 = nla_put(skb, 16387, tconn->my_addr_len, (void const   *)(& tconn->my_addr));
> #line 2597
>     if (tmp___1 != 0) {
> #line 2599
>       goto nla_put_failure;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2600
>   if (tconn->peer_addr_len != 0) {
> #line 2600
>     tmp___2 = nla_put(skb, 16388, tconn->peer_addr_len, (void const   *)(& tconn->peer_addr));
> #line 2600
>     if (tmp___2 != 0) {
> #line 2602
>       goto nla_put_failure;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2603
>   nla_nest_end(skb, nla);
> #line 2604
>   return (0);
>   nla_put_failure: ;
> #line 2607
>   if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
> #line 2608
>     nla_nest_cancel(skb, nla);
>   } else {
> 
>   }
> #line 2609
>   return (-90);
> }
> }
> #line 2612 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int nla_put_status_info(struct sk_buff *skb , struct drbd_conf *mdev , struct sib_info  const  *sib ) 
> { 
>   struct state_info *si ;
>   struct net_conf *nc ;
>   struct nlattr *nla ;
>   int got_ldev ;
>   int err ;
>   int exclude_sensitive ;
>   bool tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___4 ;
>   int tmp___5 ;
>   int tmp___6 ;
>   struct net_conf *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___7 ;
>   int tmp___8 ;
>   int tmp___9 ;
>   int tmp___10 ;
>   int tmp___11 ;
>   sector_t tmp___12 ;
>   int tmp___13 ;
>   int tmp___14 ;
>   int tmp___15 ;
>   int tmp___16 ;
>   int tmp___17 ;
>   int tmp___18 ;
>   int tmp___19 ;
>   int tmp___20 ;
>   int tmp___21 ;
>   int tmp___22 ;
>   int tmp___23 ;
>   int tmp___24 ;
>   int tmp___25 ;
>   int err___0 ;
>   int tmp___26 ;
>   unsigned long tmp___27 ;
>   int tmp___28 ;
>   unsigned long tmp___29 ;
>   int tmp___30 ;
>   int tmp___31 ;
>   int tmp___32 ;
>   int tmp___33 ;
>   int tmp___34 ;
>   int tmp___35 ;
>   int tmp___36 ;
> 
>   {
> #line 2615
>   si = 0;
> #line 2619
>   err = 0;
> #line 2633
>   if ((unsigned long )sib != (unsigned long )((struct sib_info  const  *)0)) {
> #line 2633
>     tmp___1 = 1;
>   } else {
> #line 2633
>     tmp = capable(21);
> #line 2633
>     if (tmp) {
> #line 2633
>       tmp___0 = 0;
>     } else {
> #line 2633
>       tmp___0 = 1;
>     }
> #line 2633
>     if (tmp___0) {
> #line 2633
>       tmp___1 = 1;
>     } else {
> #line 2633
>       tmp___1 = 0;
>     }
>   }
> #line 2633
>   exclude_sensitive = tmp___1;
> #line 2635
>   got_ldev = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 2639
>   tmp___2 = nla_put_drbd_cfg_context(skb, mdev->tconn, (unsigned int )mdev->vnr);
> #line 2639
>   if (tmp___2 != 0) {
> #line 2640
>     goto nla_put_failure;
>   } else {
> 
>   }
> #line 2642
>   tmp___3 = res_opts_to_skb(skb, & (mdev->tconn)->res_opts, exclude_sensitive != 0);
> #line 2642
>   if (tmp___3 != 0) {
> #line 2643
>     goto nla_put_failure;
>   } else {
> 
>   }
> #line 2645
>   rcu_read_lock();
> #line 2646
>   if (got_ldev != 0) {
> #line 2647
>     _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 2647
>     tmp___4 = debug_lockdep_rcu_enabled();
> #line 2647
>     if (tmp___4 != 0 && ! __warned) {
> #line 2647
>       tmp___5 = rcu_read_lock_held();
> #line 2647
>       if (tmp___5 == 0 && 1) {
> #line 2647
>         __warned = 1;
> #line 2647
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                                2647, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 2647
>     tmp___6 = disk_conf_to_skb(skb, _________p1, exclude_sensitive != 0);
> #line 2647
>     if (tmp___6 != 0) {
> #line 2648
>       goto nla_put_failure;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2650
>   _________p1___0 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 2650
>   tmp___7 = debug_lockdep_rcu_enabled();
> #line 2650
>   if (tmp___7 != 0 && ! __warned___0) {
> #line 2650
>     tmp___8 = rcu_read_lock_held();
> #line 2650
>     if (tmp___8 == 0 && 1) {
> #line 2650
>       __warned___0 = 1;
> #line 2650
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                              2650, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2650
>   nc = _________p1___0;
> #line 2651
>   if ((unsigned long )nc != (unsigned long )((struct net_conf *)0)) {
> #line 2652
>     err = net_conf_to_skb(skb, nc, exclude_sensitive != 0);
>   } else {
> 
>   }
> #line 2653
>   rcu_read_unlock();
> #line 2654
>   if (err != 0) {
> #line 2655
>     goto nla_put_failure;
>   } else {
> 
>   }
> #line 2657
>   nla = nla_nest_start(skb, 8);
> #line 2658
>   if ((unsigned long )nla == (unsigned long )((struct nlattr *)0)) {
> #line 2659
>     goto nla_put_failure;
>   } else {
> 
>   }
> #line 2660
>   tmp___9 = nla_put_u32(skb, 16385, (unsigned long )sib != (unsigned long )((struct sib_info  const  *)0) ? (unsigned int )sib->sib_reason : 1U);
> #line 2660
>   if (tmp___9 != 0) {
> #line 2673
>     goto nla_put_failure;
>   } else {
> #line 2660
>     tmp___10 = nla_put_u32(skb, 2, mdev->state.i);
> #line 2660
>     if (tmp___10 != 0) {
> #line 2673
>       goto nla_put_failure;
>     } else {
> #line 2660
>       tmp___11 = nla_put_u64(skb, 16388, mdev->ed_uuid);
> #line 2660
>       if (tmp___11 != 0) {
> #line 2673
>         goto nla_put_failure;
>       } else {
> #line 2660
>         tmp___12 = drbd_get_capacity(mdev->this_bdev);
> #line 2660
>         tmp___13 = nla_put_u64(skb, 16387, (u64 )tmp___12);
> #line 2660
>         if (tmp___13 != 0) {
> #line 2673
>           goto nla_put_failure;
>         } else {
> #line 2660
>           tmp___14 = nla_put_u64(skb, 15, (u64 )mdev->send_cnt);
> #line 2660
>           if (tmp___14 != 0) {
> #line 2673
>             goto nla_put_failure;
>           } else {
> #line 2660
>             tmp___15 = nla_put_u64(skb, 16, (u64 )mdev->recv_cnt);
> #line 2660
>             if (tmp___15 != 0) {
> #line 2673
>               goto nla_put_failure;
>             } else {
> #line 2660
>               tmp___16 = nla_put_u64(skb, 17, (u64 )mdev->read_cnt);
> #line 2660
>               if (tmp___16 != 0) {
> #line 2673
>                 goto nla_put_failure;
>               } else {
> #line 2660
>                 tmp___17 = nla_put_u64(skb, 18, (u64 )mdev->writ_cnt);
> #line 2660
>                 if (tmp___17 != 0) {
> #line 2673
>                   goto nla_put_failure;
>                 } else {
> #line 2660
>                   tmp___18 = nla_put_u64(skb, 19, (u64 )mdev->al_writ_cnt);
> #line 2660
>                   if (tmp___18 != 0) {
> #line 2673
>                     goto nla_put_failure;
>                   } else {
> #line 2660
>                     tmp___19 = nla_put_u64(skb, 20, (u64 )mdev->bm_writ_cnt);
> #line 2660
>                     if (tmp___19 != 0) {
> #line 2673
>                       goto nla_put_failure;
>                     } else {
> #line 2660
>                       tmp___20 = atomic_read((atomic_t const   *)(& mdev->ap_bio_cnt));
> #line 2660
>                       tmp___21 = nla_put_u32(skb, 21, (u32 )tmp___20);
> #line 2660
>                       if (tmp___21 != 0) {
> #line 2673
>                         goto nla_put_failure;
>                       } else {
> #line 2660
>                         tmp___22 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
> #line 2660
>                         tmp___23 = nla_put_u32(skb, 22, (u32 )tmp___22);
> #line 2660
>                         if (tmp___23 != 0) {
> #line 2673
>                           goto nla_put_failure;
>                         } else {
> #line 2660
>                           tmp___24 = atomic_read((atomic_t const   *)(& mdev->rs_pending_cnt));
> #line 2660
>                           tmp___25 = nla_put_u32(skb, 23, (u32 )tmp___24);
> #line 2660
>                           if (tmp___25 != 0) {
> #line 2673
>                             goto nla_put_failure;
>                           } else {
> 
>                           }
>                         }
>                       }
>                     }
>                   }
>                 }
>               }
>             }
>           }
>         }
>       }
>     }
>   }
> #line 2675
>   if (got_ldev != 0) {
> #line 2678
>     spin_lock_irq(& (mdev->ldev)->md.uuid_lock);
> #line 2679
>     err___0 = nla_put(skb, 16391, 32, (void const   *)(& (mdev->ldev)->md.uuid));
> #line 2680
>     spin_unlock_irq(& (mdev->ldev)->md.uuid_lock);
> #line 2682
>     if (err___0 != 0) {
> #line 2683
>       goto nla_put_failure;
>     } else {
> 
>     }
> #line 2685
>     tmp___26 = nla_put_u32(skb, 16392, (mdev->ldev)->md.flags);
> #line 2685
>     if (tmp___26 != 0) {
> #line 2688
>       goto nla_put_failure;
>     } else {
> #line 2685
>       tmp___27 = drbd_bm_bits(mdev);
> #line 2685
>       tmp___28 = nla_put_u64(skb, 16393, (u64 )tmp___27);
> #line 2685
>       if (tmp___28 != 0) {
> #line 2688
>         goto nla_put_failure;
>       } else {
> #line 2685
>         tmp___29 = drbd_bm_total_weight(mdev);
> #line 2685
>         tmp___30 = nla_put_u64(skb, 16394, (u64 )tmp___29);
> #line 2685
>         if (tmp___30 != 0) {
> #line 2688
>           goto nla_put_failure;
>         } else {
> 
>         }
>       }
>     }
> #line 2689
>     if ((int )mdev->state.ldv_50103.conn > 15 && (int )mdev->state.ldv_50103.conn <= 21) {
> #line 2691
>       tmp___31 = nla_put_u64(skb, 16395, (u64 )mdev->rs_total);
> #line 2691
>       if (tmp___31 != 0) {
> #line 2693
>         goto nla_put_failure;
>       } else {
> #line 2691
>         tmp___32 = nla_put_u64(skb, 16396, (u64 )mdev->rs_failed);
> #line 2691
>         if (tmp___32 != 0) {
> #line 2693
>           goto nla_put_failure;
>         } else {
> 
>         }
>       }
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2697
>   if ((unsigned long )sib != (unsigned long )((struct sib_info  const  *)0)) {
> #line 2698
>     switch ((unsigned int )sib->sib_reason) {
>     case 5U: ;
>     case 1U: ;
> #line 2701
>     goto ldv_53546;
>     case 2U: 
> #line 2703
>     tmp___33 = nla_put_u32(skb, 16389, sib->ldv_51335.ldv_51334.os.i);
> #line 2703
>     if (tmp___33 != 0) {
> #line 2705
>       goto nla_put_failure;
>     } else {
> #line 2703
>       tmp___34 = nla_put_u32(skb, 16390, sib->ldv_51335.ldv_51334.ns.i);
> #line 2703
>       if (tmp___34 != 0) {
> #line 2705
>         goto nla_put_failure;
>       } else {
> 
>       }
>     }
> #line 2706
>     goto ldv_53546;
>     case 4U: 
> #line 2708
>     tmp___35 = nla_put_u32(skb, 16398, sib->ldv_51335.ldv_51330.helper_exit_code);
> #line 2708
>     if (tmp___35 != 0) {
> #line 2710
>       goto nla_put_failure;
>     } else {
> 
>     }
>     case 3U: 
> #line 2713
>     tmp___36 = nla_put_string(skb, 16397, (char const   *)sib->ldv_51335.ldv_51330.helper_name);
> #line 2713
>     if (tmp___36 != 0) {
> #line 2714
>       goto nla_put_failure;
>     } else {
> 
>     }
> #line 2715
>     goto ldv_53546;
>     }
>     ldv_53546: ;
>   } else {
> 
>   }
> #line 2718
>   nla_nest_end(skb, nla);
> #line 2720
>   if (0) {
>     nla_put_failure: 
> #line 2722
>     err = -90;
>   } else {
> 
>   }
> #line 2723
>   if (got_ldev != 0) {
> #line 2724
>     put_ldev(mdev);
>   } else {
> 
>   }
> #line 2725
>   return (err);
> }
> }
> #line 2728 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_get_status(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   enum drbd_ret_code retcode ;
>   int err ;
>   int tmp ;
> 
>   {
> #line 2733
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 2733
>   retcode = (enum drbd_ret_code )tmp;
> #line 2734
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2735
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 2736
>   if ((unsigned int )retcode != 101U) {
> #line 2737
>     goto out;
>   } else {
> 
>   }
> #line 2739
>   err = nla_put_status_info(adm_ctx.reply_skb, adm_ctx.mdev, 0);
> #line 2740
>   if (err != 0) {
> #line 2741
>     nlmsg_free(adm_ctx.reply_skb);
> #line 2742
>     return (err);
>   } else {
> 
>   }
>   out: 
> #line 2745
>   drbd_adm_finish(info, (int )retcode);
> #line 2746
>   return (0);
> }
> }
> #line 2749 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int get_one_status(struct sk_buff *skb , struct netlink_callback *cb ) 
> { 
>   struct drbd_conf *mdev ;
>   struct drbd_genlmsghdr *dh ;
>   struct drbd_tconn *pos ;
>   struct drbd_tconn *tconn ;
>   struct drbd_tconn *tmp ;
>   unsigned int volume ;
>   struct list_head *__ptr ;
>   struct list_head  const  *__mptr ;
>   struct list_head *_________p1 ;
>   bool __warned ;
>   int tmp___0 ;
>   struct list_head *__ptr___0 ;
>   struct list_head  const  *__mptr___0 ;
>   struct list_head *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___1 ;
>   void *tmp___2 ;
>   struct list_head *__ptr___1 ;
>   struct list_head  const  *__mptr___1 ;
>   struct list_head *_________p1___1 ;
>   bool __warned___1 ;
>   int tmp___3 ;
>   void *tmp___4 ;
>   struct net_conf *nc ;
>   int tmp___5 ;
>   struct net_conf *_________p1___2 ;
>   bool __warned___2 ;
>   int tmp___6 ;
>   int tmp___7 ;
>   int tmp___8 ;
>   int tmp___9 ;
> 
>   {
> #line 2753
>   pos = (struct drbd_tconn *)cb->args[0];
> #line 2754
>   tconn = 0;
> #line 2756
>   volume = (unsigned int )cb->args[1];
> #line 2779
>   rcu_read_lock();
> #line 2781
>   __ptr = drbd_tconns.next;
> #line 2781
>   _________p1 = *((struct list_head * volatile  *)(& __ptr));
> #line 2781
>   tmp___0 = debug_lockdep_rcu_enabled();
> #line 2781
>   if (tmp___0 != 0 && ! __warned) {
> #line 2781
>     rcu_read_lock_held();
>   } else {
> 
>   }
> #line 2781
>   __mptr = (struct list_head  const  *)_________p1;
> #line 2781
>   tmp = (struct drbd_tconn *)__mptr + 0xfffffffffffffff8UL;
> #line 2781
>   goto ldv_53583;
>   ldv_53582: ;
> #line 2782
>   if ((unsigned long )pos == (unsigned long )((struct drbd_tconn *)0)) {
> #line 2784
>     pos = tmp;
> #line 2785
>     tconn = pos;
> #line 2786
>     goto ldv_53581;
>   } else {
> 
>   }
> #line 2788
>   if ((unsigned long )tmp == (unsigned long )pos) {
> #line 2789
>     tconn = pos;
> #line 2790
>     goto ldv_53581;
>   } else {
> 
>   }
> #line 2781
>   __ptr___0 = tmp->all_tconn.next;
> #line 2781
>   _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
> #line 2781
>   tmp___1 = debug_lockdep_rcu_enabled();
> #line 2781
>   if (tmp___1 != 0 && ! __warned___0) {
> #line 2781
>     rcu_read_lock_held();
>   } else {
> 
>   }
> #line 2781
>   __mptr___0 = (struct list_head  const  *)_________p1___0;
> #line 2781
>   tmp = (struct drbd_tconn *)__mptr___0 + 0xfffffffffffffff8UL;
>   ldv_53583: ;
> #line 2781
>   if ((unsigned long )(& tmp->all_tconn) != (unsigned long )(& drbd_tconns)) {
> #line 2782
>     goto ldv_53582;
>   } else {
> 
>   }
>   ldv_53581: ;
> #line 2793
>   if ((unsigned long )tconn != (unsigned long )((struct drbd_tconn *)0)) {
>     next_tconn: 
> #line 2795
>     tmp___2 = idr_get_next(& tconn->volumes, (int *)(& volume));
> #line 2795
>     mdev = (struct drbd_conf *)tmp___2;
> #line 2796
>     if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 2799
>       __ptr___1 = tconn->all_tconn.next;
> #line 2799
>       _________p1___1 = *((struct list_head * volatile  *)(& __ptr___1));
> #line 2799
>       tmp___3 = debug_lockdep_rcu_enabled();
> #line 2799
>       if (tmp___3 != 0 && ! __warned___1) {
> #line 2799
>         rcu_read_lock_held();
>       } else {
> 
>       }
> #line 2799
>       __mptr___1 = (struct list_head  const  *)_________p1___1;
> #line 2799
>       pos = (struct drbd_tconn *)__mptr___1 + 0xfffffffffffffff8UL;
> #line 2802
>       if (volume != 0U) {
> #line 2806
>         if ((unsigned long )(& pos->all_tconn) == (unsigned long )(& drbd_tconns) || cb->args[2] != 0L) {
> #line 2807
>           goto out;
>         } else {
> 
>         }
> #line 2808
>         volume = 0U;
> #line 2809
>         tconn = pos;
> #line 2810
>         goto next_tconn;
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 2814
>     tmp___4 = genlmsg_put(skb, ((struct netlink_skb_parms *)(& (cb->skb)->cb))->portid,
>                           (cb->nlh)->nlmsg_seq, & drbd_genl_family, 2, 2);
> #line 2814
>     dh = (struct drbd_genlmsghdr *)tmp___4;
> #line 2817
>     if ((unsigned long )dh == (unsigned long )((struct drbd_genlmsghdr *)0)) {
> #line 2818
>       goto out;
>     } else {
> 
>     }
> #line 2820
>     if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
> #line 2825
>       dh->minor = 4294967295U;
> #line 2826
>       dh->ldv_49550.ret_code = 101;
> #line 2827
>       tmp___5 = nla_put_drbd_cfg_context(skb, tconn, 4294967295U);
> #line 2827
>       if (tmp___5 != 0) {
> #line 2828
>         goto cancel;
>       } else {
> 
>       }
> #line 2829
>       _________p1___2 = *((struct net_conf * volatile  *)(& tconn->net_conf));
> #line 2829
>       tmp___6 = debug_lockdep_rcu_enabled();
> #line 2829
>       if (tmp___6 != 0 && ! __warned___2) {
> #line 2829
>         tmp___7 = rcu_read_lock_held();
> #line 2829
>         if (tmp___7 == 0 && 1) {
> #line 2829
>           __warned___2 = 1;
> #line 2829
>           lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>                                  2829, "suspicious rcu_dereference_check() usage");
>         } else {
> 
>         }
>       } else {
> 
>       }
> #line 2829
>       nc = _________p1___2;
> #line 2830
>       if ((unsigned long )nc != (unsigned long )((struct net_conf *)0)) {
> #line 2830
>         tmp___8 = net_conf_to_skb(skb, nc, 1);
> #line 2830
>         if (tmp___8 != 0) {
> #line 2831
>           goto cancel;
>         } else {
> 
>         }
>       } else {
> 
>       }
> #line 2832
>       goto done;
>     } else {
> 
>     }
> #line 2835
>     if ((unsigned int )mdev->vnr != volume) {
> #line 2835
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->vnr == volume ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>               2835);
>     } else {
> 
>     }
> #line 2836
>     if ((unsigned long )mdev->tconn != (unsigned long )tconn) {
> #line 2836
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->tconn == tconn ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
>               2836);
>     } else {
> 
>     }
> #line 2838
>     dh->minor = mdev_to_minor(mdev);
> #line 2839
>     dh->ldv_49550.ret_code = 101;
> #line 2841
>     tmp___9 = nla_put_status_info(skb, mdev, 0);
> #line 2841
>     if (tmp___9 != 0) {
>       cancel: 
> #line 2843
>       genlmsg_cancel(skb, (void *)dh);
> #line 2844
>       goto out;
>     } else {
> 
>     }
>     done: 
> #line 2847
>     genlmsg_end(skb, (void *)dh);
>   } else {
> 
>   }
>   out: 
> #line 2851
>   rcu_read_unlock();
> #line 2853
>   cb->args[0] = (long )pos;
> #line 2854
>   cb->args[1] = (unsigned long )pos == (unsigned long )tconn ? (long )(volume + 1U) : 0L;
> #line 2858
>   return ((int )skb->len);
> }
> }
> #line 2871 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_get_status_all(struct sk_buff *skb , struct netlink_callback *cb ) 
> { 
>   unsigned int hdrlen ;
>   struct nlattr *nla ;
>   char const   *resource_name ;
>   struct drbd_tconn *tconn ;
>   int maxtype ;
>   int tmp ;
>   struct nlattr *tmp___0 ;
>   long tmp___1 ;
>   long tmp___2 ;
>   void *tmp___3 ;
>   int tmp___4 ;
> 
>   {
> #line 2873
>   hdrlen = 12U;
> #line 2880
>   if (cb->args[0] != 0L) {
> #line 2883
>     if (cb->args[2] != 0L && cb->args[2] != cb->args[0]) {
> #line 2884
>       return (0);
>     } else {
> 
>     }
> #line 2885
>     goto dump;
>   } else {
> 
>   }
> #line 2890
>   tmp = nlmsg_attrlen(cb->nlh, (int )hdrlen);
> #line 2890
>   tmp___0 = nlmsg_attrdata(cb->nlh, (int )hdrlen);
> #line 2890
>   nla = nla_find((struct nlattr  const  *)tmp___0, tmp, 2);
> #line 2895
>   if ((unsigned long )nla == (unsigned long )((struct nlattr *)0)) {
> #line 2896
>     goto dump;
>   } else {
> 
>   }
> #line 2897
>   maxtype = 4;
> #line 2898
>   nla = drbd_nla_find_nested(maxtype, nla, 2);
> #line 2899
>   tmp___2 = IS_ERR((void const   *)nla);
> #line 2899
>   if (tmp___2 != 0L) {
> #line 2900
>     tmp___1 = PTR_ERR((void const   *)nla);
> #line 2900
>     return ((int )tmp___1);
>   } else {
> 
>   }
> #line 2902
>   if ((unsigned long )nla == (unsigned long )((struct nlattr *)0)) {
> #line 2903
>     return (-22);
>   } else {
> 
>   }
> #line 2904
>   tmp___3 = nla_data((struct nlattr  const  *)nla);
> #line 2904
>   resource_name = (char const   *)tmp___3;
> #line 2905
>   tconn = conn_get_by_name(resource_name);
> #line 2907
>   if ((unsigned long )tconn == (unsigned long )((struct drbd_tconn *)0)) {
> #line 2908
>     return (-19);
>   } else {
> 
>   }
> #line 2910
>   kref_put(& tconn->kref, & conn_destroy);
> #line 2914
>   cb->args[0] = (long )tconn;
> #line 2916
>   cb->args[2] = (long )tconn;
>   dump: 
> #line 2919
>   tmp___4 = get_one_status(skb, cb);
> #line 2919
>   return (tmp___4);
> }
> }
> #line 2922 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_get_timeout_type(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   enum drbd_ret_code retcode ;
>   struct timeout_parms tp ;
>   int err ;
>   int tmp ;
>   int tmp___0 ;
> 
>   {
> #line 2928
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 2928
>   retcode = (enum drbd_ret_code )tmp;
> #line 2929
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2930
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 2931
>   if ((unsigned int )retcode != 101U) {
> #line 2932
>     goto out;
>   } else {
> 
>   }
> #line 2934
>   if (*((unsigned int *)adm_ctx.mdev + 187UL) != 40960U) {
> #line 2934
>     tmp___0 = constant_test_bit(2U, (unsigned long const volatile   *)(& (adm_ctx.mdev)->flags));
> #line 2934
>     tp.timeout_type = tmp___0 != 0;
>   } else {
> #line 2934
>     tp.timeout_type = 2U;
>   }
> #line 2939
>   err = timeout_parms_to_priv_skb(adm_ctx.reply_skb, & tp);
> #line 2940
>   if (err != 0) {
> #line 2941
>     nlmsg_free(adm_ctx.reply_skb);
> #line 2942
>     return (err);
>   } else {
> 
>   }
>   out: 
> #line 2945
>   drbd_adm_finish(info, (int )retcode);
> #line 2946
>   return (0);
> }
> }
> #line 2949 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_start_ov(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct drbd_conf *mdev ;
>   enum drbd_ret_code retcode ;
>   struct start_ov_parms parms ;
>   int tmp ;
>   int err ;
>   int tmp___0 ;
>   char const   *tmp___1 ;
>   int tmp___2 ;
>   wait_queue_t __wait ;
>   struct task_struct *tmp___3 ;
>   int tmp___4 ;
>   union drbd_state val ;
>   union drbd_state mask ;
>   int tmp___5 ;
> 
>   {
> #line 2955
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 2955
>   retcode = (enum drbd_ret_code )tmp;
> #line 2956
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 2957
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 2958
>   if ((unsigned int )retcode != 101U) {
> #line 2959
>     goto out;
>   } else {
> 
>   }
> #line 2961
>   mdev = adm_ctx.mdev;
> #line 2964
>   parms.ov_start_sector = (__u64 )mdev->ov_start_sector;
> #line 2965
>   parms.ov_stop_sector = 0xffffffffffffffffULL;
> #line 2966
>   if ((unsigned long )*(info->attrs + 9UL) != (unsigned long )((struct nlattr *)0)) {
> #line 2967
>     tmp___0 = start_ov_parms_from_attrs(& parms, info);
> #line 2967
>     err = tmp___0;
> #line 2968
>     if (err != 0) {
> #line 2969
>       retcode = ERR_MANDATORY_TAG;
> #line 2970
>       tmp___1 = from_attrs_err_to_txt(err);
> #line 2970
>       drbd_msg_put_info(tmp___1);
> #line 2971
>       goto out;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 2975
>   mdev->ov_start_sector = (sector_t )parms.ov_start_sector & 0xfffffffffffffff8UL;
> #line 2976
>   mdev->ov_stop_sector = (sector_t )parms.ov_stop_sector;
> #line 2980
>   drbd_suspend_io(mdev);
> #line 2981
>   tmp___2 = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2981
>   if (tmp___2 == 0) {
> #line 2981
>     goto ldv_53628;
>   } else {
> 
>   }
> #line 2981
>   tmp___3 = get_current();
> #line 2981
>   __wait.flags = 0U;
> #line 2981
>   __wait.private = (void *)tmp___3;
> #line 2981
>   __wait.func = & autoremove_wake_function;
> #line 2981
>   __wait.task_list.next = & __wait.task_list;
> #line 2981
>   __wait.task_list.prev = & __wait.task_list;
>   ldv_53631: 
> #line 2981
>   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
> #line 2981
>   tmp___4 = constant_test_bit(9U, (unsigned long const volatile   *)(& mdev->flags));
> #line 2981
>   if (tmp___4 == 0) {
> #line 2981
>     goto ldv_53630;
>   } else {
> 
>   }
> #line 2981
>   schedule();
> #line 2981
>   goto ldv_53631;
>   ldv_53630: 
> #line 2981
>   finish_wait(& mdev->misc_wait, & __wait);
>   ldv_53628: 
> #line 2982
>   val.i = 0U;
> #line 2982
>   val.ldv_40604.conn = 18U;
> #line 2982
>   mask.i = 0U;
> #line 2982
>   mask.ldv_40604.conn = 31U;
> #line 2982
>   tmp___5 = drbd_request_state(mdev, mask, val);
> #line 2982
>   retcode = (enum drbd_ret_code )tmp___5;
> #line 2983
>   drbd_resume_io(mdev);
>   out: 
> #line 2985
>   drbd_adm_finish(info, (int )retcode);
> #line 2986
>   return (0);
> }
> }
> #line 2990 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_new_c_uuid(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct drbd_conf *mdev ;
>   enum drbd_ret_code retcode ;
>   int skip_initial_sync ;
>   int err ;
>   struct new_c_uuid_parms args ;
>   int tmp ;
>   char const   *tmp___0 ;
>   int tmp___1 ;
>   union drbd_state __ns ;
> 
>   {
> #line 2994
>   skip_initial_sync = 0;
> #line 2998
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 2998
>   retcode = (enum drbd_ret_code )tmp;
> #line 2999
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 3000
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 3001
>   if ((unsigned int )retcode != 101U) {
> #line 3002
>     goto out_nolock;
>   } else {
> 
>   }
> #line 3004
>   mdev = adm_ctx.mdev;
> #line 3005
>   memset((void *)(& args), 0, 1UL);
> #line 3006
>   if ((unsigned long )*(info->attrs + 10UL) != (unsigned long )((struct nlattr *)0)) {
> #line 3007
>     err = new_c_uuid_parms_from_attrs(& args, info);
> #line 3008
>     if (err != 0) {
> #line 3009
>       retcode = ERR_MANDATORY_TAG;
> #line 3010
>       tmp___0 = from_attrs_err_to_txt(err);
> #line 3010
>       drbd_msg_put_info(tmp___0);
> #line 3011
>       goto out_nolock;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 3015
>   mutex_lock_nested(mdev->state_mutex, 0U);
> #line 3017
>   tmp___1 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 3017
>   if (tmp___1 == 0) {
> #line 3018
>     retcode = ERR_NO_DISK;
> #line 3019
>     goto out;
>   } else {
> 
>   }
> #line 3023
>   if ((((unsigned int )*((unsigned short *)mdev + 374UL) == 160U && (mdev->tconn)->agreed_pro_version > 89) && (mdev->ldev)->md.uuid[0] == 4ULL) && (int )((signed char )args.clear_bm) != 0) {
> #line 3025
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Preparing to skip initial sync\n");
> #line 3026
>     skip_initial_sync = 1;
>   } else
> #line 3027
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) != 0U) {
> #line 3028
>     retcode = ERR_CONNECTED;
> #line 3029
>     goto out_dec;
>   } else {
> 
>   }
> #line 3032
>   drbd_uuid_set(mdev, 1, 0ULL);
> #line 3033
>   drbd_uuid_new_current(mdev);
> #line 3035
>   if ((int )((signed char )args.clear_bm) != 0) {
> #line 3036
>     err = drbd_bitmap_io(mdev, & drbd_bmio_clear_n_write, (char *)"clear_n_write from new_c_uuid",
>                          BM_LOCKED_MASK);
> #line 3038
>     if (err != 0) {
> #line 3039
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Writing bitmap failed with %d\n",
>               err);
> #line 3040
>       retcode = ERR_IO_MD_DISK;
>     } else {
> 
>     }
> #line 3042
>     if (skip_initial_sync != 0) {
> #line 3043
>       drbd_send_uuids_skip_initial_sync(mdev);
> #line 3044
>       _drbd_uuid_set(mdev, 1, 0ULL);
> #line 3045
>       drbd_print_uuids(mdev, "cleared bitmap UUID");
> #line 3046
>       spin_lock_irq(& (mdev->tconn)->req_lock);
> #line 3047
>       __ns = drbd_read_state(mdev);
> #line 3047
>       __ns.ldv_40604.disk = 8U;
> #line 3047
>       __ns.ldv_40604.pdsk = 8U;
> #line 3047
>       _drbd_set_state(mdev, __ns, CS_VERBOSE, 0);
> #line 3049
>       spin_unlock_irq(& (mdev->tconn)->req_lock);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 3053
>   drbd_md_sync(mdev);
>   out_dec: 
> #line 3055
>   put_ldev(mdev);
>   out: 
> #line 3057
>   mutex_unlock(mdev->state_mutex);
>   out_nolock: 
> #line 3059
>   drbd_adm_finish(info, (int )retcode);
> #line 3060
>   return (0);
> }
> }
> #line 3064 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static enum drbd_ret_code drbd_check_resource_name(char const   *name ) 
> { 
>   char *tmp ;
> 
>   {
> #line 3066
>   if ((unsigned long )name == (unsigned long )((char const   *)0) || (int )((signed char )*name) == 0) {
> #line 3067
>     drbd_msg_put_info("resource name missing");
> #line 3068
>     return (ERR_MANDATORY_TAG);
>   } else {
> 
>   }
> #line 3072
>   tmp = strchr(name, 47);
> #line 3072
>   if ((unsigned long )tmp != (unsigned long )((char *)0)) {
> #line 3073
>     drbd_msg_put_info("invalid resource name");
> #line 3074
>     return (ERR_INVALID_REQUEST);
>   } else {
> 
>   }
> #line 3076
>   return (NO_ERROR);
> }
> }
> #line 3079 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_new_resource(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   enum drbd_ret_code retcode ;
>   struct res_opts res_opts ;
>   int err ;
>   int tmp ;
>   char const   *tmp___0 ;
>   struct drbd_tconn *tmp___1 ;
> 
>   {
> #line 3085
>   tmp = drbd_adm_prepare(skb, info, 0U);
> #line 3085
>   retcode = (enum drbd_ret_code )tmp;
> #line 3086
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 3087
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 3088
>   if ((unsigned int )retcode != 101U) {
> #line 3089
>     goto out;
>   } else {
> 
>   }
> #line 3091
>   set_res_opts_defaults(& res_opts);
> #line 3092
>   err = res_opts_from_attrs(& res_opts, info);
> #line 3093
>   if (err != 0 && err != -42) {
> #line 3094
>     retcode = ERR_MANDATORY_TAG;
> #line 3095
>     tmp___0 = from_attrs_err_to_txt(err);
> #line 3095
>     drbd_msg_put_info(tmp___0);
> #line 3096
>     goto out;
>   } else {
> 
>   }
> #line 3099
>   retcode = drbd_check_resource_name((char const   *)adm_ctx.resource_name);
> #line 3100
>   if ((unsigned int )retcode != 101U) {
> #line 3101
>     goto out;
>   } else {
> 
>   }
> #line 3103
>   if ((unsigned long )adm_ctx.tconn != (unsigned long )((struct drbd_tconn *)0)) {
> #line 3104
>     if (((int )(info->nlhdr)->nlmsg_flags & 512) != 0) {
> #line 3105
>       retcode = ERR_INVALID_REQUEST;
> #line 3106
>       drbd_msg_put_info("resource exists");
>     } else {
> 
>     }
> #line 3109
>     goto out;
>   } else {
> 
>   }
> #line 3112
>   tmp___1 = conn_create((char const   *)adm_ctx.resource_name, & res_opts);
> #line 3112
>   if ((unsigned long )tmp___1 == (unsigned long )((struct drbd_tconn *)0)) {
> #line 3113
>     retcode = ERR_NOMEM;
>   } else {
> 
>   }
>   out: 
> #line 3115
>   drbd_adm_finish(info, (int )retcode);
> #line 3116
>   return (0);
> }
> }
> #line 3119 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_add_minor(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   struct drbd_genlmsghdr *dh ;
>   enum drbd_ret_code retcode ;
>   int tmp ;
> 
>   {
> #line 3121
>   dh = (struct drbd_genlmsghdr *)info->userhdr;
> #line 3124
>   tmp = drbd_adm_prepare(skb, info, 2U);
> #line 3124
>   retcode = (enum drbd_ret_code )tmp;
> #line 3125
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 3126
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 3127
>   if ((unsigned int )retcode != 101U) {
> #line 3128
>     goto out;
>   } else {
> 
>   }
> #line 3130
>   if (dh->minor > 1048575U) {
> #line 3131
>     drbd_msg_put_info("requested minor out of range");
> #line 3132
>     retcode = ERR_INVALID_REQUEST;
> #line 3133
>     goto out;
>   } else {
> 
>   }
> #line 3135
>   if (adm_ctx.volume > 65535U) {
> #line 3136
>     drbd_msg_put_info("requested volume id out of range");
> #line 3137
>     retcode = ERR_INVALID_REQUEST;
> #line 3138
>     goto out;
>   } else {
> 
>   }
> #line 3143
>   if ((unsigned long )adm_ctx.mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 3144
>     if (((int )(info->nlhdr)->nlmsg_flags & 512) != 0) {
> #line 3145
>       retcode = ERR_MINOR_EXISTS;
>     } else {
> 
>     }
> #line 3147
>     goto out;
>   } else {
> 
>   }
> #line 3150
>   retcode = conn_new_minor(adm_ctx.tconn, dh->minor, (int )adm_ctx.volume);
>   out: 
> #line 3152
>   drbd_adm_finish(info, (int )retcode);
> #line 3153
>   return (0);
> }
> }
> #line 3156 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> static enum drbd_ret_code adm_delete_minor(struct drbd_conf *mdev ) 
> { 
>   union drbd_state val ;
>   union drbd_state mask ;
>   unsigned int tmp ;
> 
>   {
> #line 3158
>   if ((unsigned int )*((unsigned char *)mdev + 749UL) == 0U && (unsigned int )*((unsigned char *)mdev + 748UL) == 2U) {
> #line 3163
>     val.i = 0U;
> #line 3163
>     val.ldv_40604.conn = 9U;
> #line 3163
>     mask.i = 0U;
> #line 3163
>     mask.ldv_40604.conn = 31U;
> #line 3163
>     _drbd_request_state(mdev, mask, val, 6);
> #line 3165
>     idr_remove(& (mdev->tconn)->volumes, mdev->vnr);
> #line 3166
>     tmp = mdev_to_minor(mdev);
> #line 3166
>     idr_remove(& minors, (int )tmp);
> #line 3167
>     del_gendisk(mdev->vdisk);
> #line 3168
>     synchronize_rcu();
> #line 3169
>     kref_put(& mdev->kref, & drbd_minor_destroy);
> #line 3170
>     return (NO_ERROR);
>   } else {
> #line 3172
>     return (ERR_MINOR_CONFIGURED);
>   }
> }
> }
> #line 3175 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_delete_minor(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   enum drbd_ret_code retcode ;
>   int tmp ;
> 
>   {
> #line 3179
>   tmp = drbd_adm_prepare(skb, info, 1U);
> #line 3179
>   retcode = (enum drbd_ret_code )tmp;
> #line 3180
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 3181
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 3182
>   if ((unsigned int )retcode != 101U) {
> #line 3183
>     goto out;
>   } else {
> 
>   }
> #line 3185
>   retcode = adm_delete_minor(adm_ctx.mdev);
>   out: 
> #line 3187
>   drbd_adm_finish(info, (int )retcode);
> #line 3188
>   return (0);
> }
> }
> #line 3191 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_down(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   int retcode ;
>   struct drbd_conf *mdev ;
>   unsigned int i ;
>   void *tmp ;
>   enum drbd_state_rv tmp___0 ;
>   void *tmp___1 ;
>   enum drbd_state_rv tmp___2 ;
>   void *tmp___3 ;
>   void *tmp___4 ;
>   void *tmp___5 ;
>   enum drbd_ret_code tmp___6 ;
>   void *tmp___7 ;
>   int tmp___8 ;
> 
>   {
> #line 3197
>   retcode = drbd_adm_prepare(skb, info, 0U);
> #line 3198
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 3199
>     return (retcode);
>   } else {
> 
>   }
> #line 3200
>   if (retcode != 101) {
> #line 3201
>     goto out;
>   } else {
> 
>   }
> #line 3203
>   if ((unsigned long )adm_ctx.tconn == (unsigned long )((struct drbd_tconn *)0)) {
> #line 3204
>     retcode = 158;
> #line 3205
>     goto out;
>   } else {
> 
>   }
> #line 3209
>   i = 0U;
> #line 3209
>   tmp = idr_get_next(& (adm_ctx.tconn)->volumes, (int *)(& i));
> #line 3209
>   mdev = (struct drbd_conf *)tmp;
> #line 3209
>   goto ldv_53690;
>   ldv_53689: 
> #line 3210
>   tmp___0 = drbd_set_role(mdev, R_SECONDARY, 0);
> #line 3210
>   retcode = (int )tmp___0;
> #line 3211
>   if (retcode <= 0) {
> #line 3212
>     drbd_msg_put_info("failed to demote");
> #line 3213
>     goto out;
>   } else {
> 
>   }
> #line 3209
>   i = i + 1U;
> #line 3209
>   tmp___1 = idr_get_next(& (adm_ctx.tconn)->volumes, (int *)(& i));
> #line 3209
>   mdev = (struct drbd_conf *)tmp___1;
>   ldv_53690: ;
> #line 3209
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 3210
>     goto ldv_53689;
>   } else {
> 
>   }
> #line 3217
>   tmp___2 = conn_try_disconnect(adm_ctx.tconn, 0);
> #line 3217
>   retcode = (int )tmp___2;
> #line 3218
>   if (retcode <= 0) {
> #line 3219
>     drbd_msg_put_info("failed to disconnect");
> #line 3220
>     goto out;
>   } else {
> 
>   }
> #line 3224
>   i = 0U;
> #line 3224
>   tmp___3 = idr_get_next(& (adm_ctx.tconn)->volumes, (int *)(& i));
> #line 3224
>   mdev = (struct drbd_conf *)tmp___3;
> #line 3224
>   goto ldv_53693;
>   ldv_53692: 
> #line 3225
>   retcode = adm_detach(mdev, 0);
> #line 3226
>   if (retcode <= 0 || retcode > 101) {
> #line 3227
>     drbd_msg_put_info("failed to detach");
> #line 3228
>     goto out;
>   } else {
> 
>   }
> #line 3224
>   i = i + 1U;
> #line 3224
>   tmp___4 = idr_get_next(& (adm_ctx.tconn)->volumes, (int *)(& i));
> #line 3224
>   mdev = (struct drbd_conf *)tmp___4;
>   ldv_53693: ;
> #line 3224
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 3225
>     goto ldv_53692;
>   } else {
> 
>   }
> #line 3235
>   drbd_thread_stop(& (adm_ctx.tconn)->worker);
> #line 3240
>   i = 0U;
> #line 3240
>   tmp___5 = idr_get_next(& (adm_ctx.tconn)->volumes, (int *)(& i));
> #line 3240
>   mdev = (struct drbd_conf *)tmp___5;
> #line 3240
>   goto ldv_53696;
>   ldv_53695: 
> #line 3241
>   tmp___6 = adm_delete_minor(mdev);
> #line 3241
>   retcode = (int )tmp___6;
> #line 3242
>   if (retcode != 101) {
> #line 3244
>     drbd_msg_put_info("failed to delete volume");
> #line 3245
>     goto out;
>   } else {
> 
>   }
> #line 3240
>   i = i + 1U;
> #line 3240
>   tmp___7 = idr_get_next(& (adm_ctx.tconn)->volumes, (int *)(& i));
> #line 3240
>   mdev = (struct drbd_conf *)tmp___7;
>   ldv_53696: ;
> #line 3240
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 3241
>     goto ldv_53695;
>   } else {
> 
>   }
> #line 3250
>   tmp___8 = conn_lowest_minor(adm_ctx.tconn);
> #line 3250
>   if (tmp___8 < 0) {
> #line 3251
>     list_del_rcu(& (adm_ctx.tconn)->all_tconn);
> #line 3252
>     synchronize_rcu();
> #line 3253
>     kref_put(& (adm_ctx.tconn)->kref, & conn_destroy);
> #line 3255
>     retcode = 101;
>   } else {
> #line 3258
>     retcode = 159;
> #line 3259
>     drbd_msg_put_info("failed to delete connection");
>   }
> #line 3261
>   goto out;
>   out: 
> #line 3263
>   drbd_adm_finish(info, retcode);
> #line 3264
>   return (0);
> }
> }
> #line 3267 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> int drbd_adm_del_resource(struct sk_buff *skb , struct genl_info *info ) 
> { 
>   enum drbd_ret_code retcode ;
>   int tmp ;
>   int tmp___0 ;
> 
>   {
> #line 3271
>   tmp = drbd_adm_prepare(skb, info, 2U);
> #line 3271
>   retcode = (enum drbd_ret_code )tmp;
> #line 3272
>   if ((unsigned long )adm_ctx.reply_skb == (unsigned long )((struct sk_buff *)0)) {
> #line 3273
>     return ((int )retcode);
>   } else {
> 
>   }
> #line 3274
>   if ((unsigned int )retcode != 101U) {
> #line 3275
>     goto out;
>   } else {
> 
>   }
> #line 3277
>   tmp___0 = conn_lowest_minor(adm_ctx.tconn);
> #line 3277
>   if (tmp___0 < 0) {
> #line 3278
>     list_del_rcu(& (adm_ctx.tconn)->all_tconn);
> #line 3279
>     synchronize_rcu();
> #line 3280
>     kref_put(& (adm_ctx.tconn)->kref, & conn_destroy);
> #line 3282
>     retcode = NO_ERROR;
>   } else {
> #line 3284
>     retcode = ERR_RES_IN_USE;
>   }
> #line 3287
>   if ((unsigned int )retcode == 101U) {
> #line 3288
>     drbd_thread_stop(& (adm_ctx.tconn)->worker);
>   } else {
> 
>   }
>   out: 
> #line 3290
>   drbd_adm_finish(info, (int )retcode);
> #line 3291
>   return (0);
> }
> }
> #line 3294 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
> void drbd_bcast_event(struct drbd_conf *mdev , struct sib_info  const  *sib ) 
> { 
>   atomic_t drbd_genl_seq ;
>   struct sk_buff *msg ;
>   struct drbd_genlmsghdr *d_out ;
>   unsigned int seq ;
>   int err ;
>   int tmp ;
>   void *tmp___0 ;
>   int tmp___1 ;
> 
>   {
> #line 3296
>   drbd_genl_seq.counter = 2;
> #line 3300
>   err = -12;
> #line 3303
>   if ((unsigned int )sib->sib_reason == 5U && ((1 != 0 && 1 != 0) && (long )(mdev->rs_last_bcast + 250UL) - (long )jiffies < 0L)) {
> #line 3304
>     mdev->rs_last_bcast = jiffies;
>   } else {
> #line 3306
>     return;
>   }
> #line 3308
>   tmp = atomic_add_return(1, & drbd_genl_seq);
> #line 3308
>   seq = (unsigned int )tmp;
> #line 3309
>   msg = genlmsg_new(3776UL, 16U);
> #line 3310
>   if ((unsigned long )msg == (unsigned long )((struct sk_buff *)0)) {
> #line 3311
>     goto failed;
>   } else {
> 
>   }
> #line 3313
>   err = -90;
> #line 3314
>   tmp___0 = genlmsg_put(msg, 0U, seq, & drbd_genl_family, 0, 1);
> #line 3314
>   d_out = (struct drbd_genlmsghdr *)tmp___0;
> #line 3315
>   if ((unsigned long )d_out == (unsigned long )((struct drbd_genlmsghdr *)0)) {
> #line 3316
>     goto nla_put_failure;
>   } else {
> 
>   }
> #line 3317
>   d_out->minor = mdev_to_minor(mdev);
> #line 3318
>   d_out->ldv_49550.ret_code = 101;
> #line 3320
>   tmp___1 = nla_put_status_info(msg, mdev, sib);
> #line 3320
>   if (tmp___1 != 0) {
> #line 3321
>     goto nla_put_failure;
>   } else {
> 
>   }
> #line 3322
>   genlmsg_end(msg, (void *)d_out);
> #line 3323
>   err = drbd_genl_multicast_events(msg, 0U);
> #line 3325
>   if (err != 0 && err != -3) {
> #line 3326
>     goto failed;
>   } else {
> 
>   }
> #line 3328
>   return;
>   nla_put_failure: 
> #line 3331
>   nlmsg_free(msg);
>   failed: 
> #line 3333
>   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Error %d while broadcasting event. Event seq:%u sib_reason:%u\n",
>           err, seq, (unsigned int )sib->sib_reason);
> #line 3336
>   return;
> }
> }
> #line 66 "include/linux/rbtree.h"
> extern struct rb_node *rb_next(struct rb_node  const  * ) ;
> #line 75 "include/linux/rbtree.h"
> __inline static void rb_link_node(struct rb_node *node , struct rb_node *parent ,
>                                   struct rb_node **rb_link ) 
> { 
>   struct rb_node *tmp ;
> 
>   {
> #line 78
>   node->__rb_parent_color = (unsigned long )parent;
> #line 79
>   tmp = 0;
> #line 79
>   node->rb_right = tmp;
> #line 79
>   node->rb_left = tmp;
> #line 81
>   *rb_link = node;
> #line 82
>   return;
> }
> }
> #line 44 "include/linux/rbtree_augmented.h"
> extern void __rb_insert_augmented(struct rb_node * , struct rb_root * , void (*)(struct rb_node * ,
>                                                                                  struct rb_node * ) ) ;
> #line 47 "include/linux/rbtree_augmented.h"
> __inline static void rb_insert_augmented(struct rb_node *node , struct rb_root *root ,
>                                          struct rb_augment_callbacks  const  *augment ) 
> { 
> 
> 
>   {
> #line 50
>   __rb_insert_augmented(node, root, augment->rotate);
> #line 51
>   return;
> }
> }
> #line 99 "include/linux/rbtree_augmented.h"
> __inline static void rb_set_parent(struct rb_node *rb , struct rb_node *p ) 
> { 
> 
> 
>   {
> #line 101
>   rb->__rb_parent_color = (rb->__rb_parent_color & 1UL) | (unsigned long )p;
> #line 102
>   return;
> }
> }
> #line 104 "include/linux/rbtree_augmented.h"
> __inline static void rb_set_parent_color(struct rb_node *rb , struct rb_node *p ,
>                                          int color ) 
> { 
> 
> 
>   {
> #line 107
>   rb->__rb_parent_color = (unsigned long )color | (unsigned long )p;
> #line 108
>   return;
> }
> }
> #line 111 "include/linux/rbtree_augmented.h"
> __inline static void __rb_change_child(struct rb_node *old , struct rb_node *new ,
>                                        struct rb_node *parent , struct rb_root *root ) 
> { 
> 
> 
>   {
> #line 114
>   if ((unsigned long )parent != (unsigned long )((struct rb_node *)0)) {
> #line 115
>     if ((unsigned long )parent->rb_left == (unsigned long )old) {
> #line 116
>       parent->rb_left = new;
>     } else {
> #line 118
>       parent->rb_right = new;
>     }
>   } else {
> #line 120
>     root->rb_node = new;
>   }
> #line 121
>   return;
> }
> }
> #line 123
> extern void __rb_erase_color(struct rb_node * , struct rb_root * , void (*)(struct rb_node * ,
>                                                                             struct rb_node * ) ) ;
> #line 127 "include/linux/rbtree_augmented.h"
> __inline static void rb_erase_augmented(struct rb_node *node , struct rb_root *root ,
>                                         struct rb_augment_callbacks  const  *augment ) 
> { 
>   struct rb_node *child ;
>   struct rb_node *tmp ;
>   struct rb_node *parent ;
>   struct rb_node *rebalance ;
>   unsigned long pc ;
>   struct rb_node *successor ;
>   struct rb_node *child2 ;
>   unsigned long pc2 ;
> 
>   {
> #line 130
>   child = node->rb_right;
> #line 130
>   tmp = node->rb_left;
> #line 134
>   if ((unsigned long )tmp == (unsigned long )((struct rb_node *)0)) {
> #line 142
>     pc = node->__rb_parent_color;
> #line 143
>     parent = (struct rb_node *)(pc & 0xfffffffffffffffcUL);
> #line 144
>     __rb_change_child(node, child, parent, root);
> #line 145
>     if ((unsigned long )child != (unsigned long )((struct rb_node *)0)) {
> #line 146
>       child->__rb_parent_color = pc;
> #line 147
>       rebalance = 0;
>     } else {
> #line 149
>       rebalance = (int )pc & 1 ? parent : 0;
>     }
> #line 150
>     tmp = parent;
>   } else
> #line 151
>   if ((unsigned long )child == (unsigned long )((struct rb_node *)0)) {
> #line 153
>     pc = node->__rb_parent_color;
> #line 153
>     tmp->__rb_parent_color = pc;
> #line 154
>     parent = (struct rb_node *)(pc & 0xfffffffffffffffcUL);
> #line 155
>     __rb_change_child(node, tmp, parent, root);
> #line 156
>     rebalance = 0;
> #line 157
>     tmp = parent;
>   } else {
> #line 159
>     successor = child;
> #line 160
>     tmp = child->rb_left;
> #line 161
>     if ((unsigned long )tmp == (unsigned long )((struct rb_node *)0)) {
> #line 171
>       parent = successor;
> #line 172
>       child2 = successor->rb_right;
> #line 173
>       (*(augment->copy))(node, successor);
>     } else {
>       ldv_14079: 
> #line 190
>       parent = successor;
> #line 191
>       successor = tmp;
> #line 192
>       tmp = tmp->rb_left;
> #line 193
>       if ((unsigned long )tmp != (unsigned long )((struct rb_node *)0)) {
> #line 194
>         goto ldv_14079;
>       } else {
> 
>       }
> #line 194
>       child2 = successor->rb_right;
> #line 194
>       parent->rb_left = child2;
> #line 195
>       successor->rb_right = child;
> #line 196
>       rb_set_parent(child, successor);
> #line 197
>       (*(augment->copy))(node, successor);
> #line 198
>       (*(augment->propagate))(parent, successor);
>     }
> #line 201
>     tmp = node->rb_left;
> #line 201
>     successor->rb_left = tmp;
> #line 202
>     rb_set_parent(tmp, successor);
> #line 204
>     pc = node->__rb_parent_color;
> #line 205
>     tmp = (struct rb_node *)(pc & 0xfffffffffffffffcUL);
> #line 206
>     __rb_change_child(node, successor, tmp, root);
> #line 207
>     if ((unsigned long )child2 != (unsigned long )((struct rb_node *)0)) {
> #line 208
>       successor->__rb_parent_color = pc;
> #line 209
>       rb_set_parent_color(child2, parent, 1);
> #line 210
>       rebalance = 0;
>     } else {
> #line 212
>       pc2 = successor->__rb_parent_color;
> #line 213
>       successor->__rb_parent_color = pc;
> #line 214
>       rebalance = (int )pc2 & 1 ? parent : 0;
>     }
> #line 216
>     tmp = successor;
>   }
> #line 219
>   (*(augment->propagate))(tmp, 0);
> #line 220
>   if ((unsigned long )rebalance != (unsigned long )((struct rb_node *)0)) {
> #line 221
>     __rb_erase_color(rebalance, root, augment->rotate);
>   } else {
> 
>   }
> #line 222
>   return;
> }
> }
> #line 16 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> __inline static sector_t interval_end(struct rb_node *node ) 
> { 
>   struct drbd_interval *this ;
>   struct rb_node  const  *__mptr ;
> 
>   {
> #line 18
>   __mptr = (struct rb_node  const  *)node;
> #line 18
>   this = (struct drbd_interval *)__mptr;
> #line 19
>   return (this->end);
> }
> }
> #line 30 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> __inline static sector_t compute_subtree_last(struct drbd_interval *node ) 
> { 
>   sector_t max ;
>   sector_t left ;
>   sector_t tmp ;
>   sector_t right ;
>   sector_t tmp___0 ;
> 
>   {
> #line 32
>   max = node->sector + (sector_t )(node->size >> 9);
> #line 34
>   if ((unsigned long )node->rb.rb_left != (unsigned long )((struct rb_node *)0)) {
> #line 35
>     tmp = interval_end(node->rb.rb_left);
> #line 35
>     left = tmp;
> #line 36
>     if (left > max) {
> #line 37
>       max = left;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 39
>   if ((unsigned long )node->rb.rb_right != (unsigned long )((struct rb_node *)0)) {
> #line 40
>     tmp___0 = interval_end(node->rb.rb_right);
> #line 40
>     right = tmp___0;
> #line 41
>     if (right > max) {
> #line 42
>       max = right;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 44
>   return (max);
> }
> }
> #line 47 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> static void augment_propagate(struct rb_node *rb , struct rb_node *stop ) 
> { 
>   struct drbd_interval *node ;
>   struct rb_node  const  *__mptr ;
>   sector_t subtree_last ;
>   sector_t tmp ;
> 
>   {
> #line 49
>   goto ldv_14135;
>   ldv_14134: 
> #line 50
>   __mptr = (struct rb_node  const  *)rb;
> #line 50
>   node = (struct drbd_interval *)__mptr;
> #line 51
>   tmp = compute_subtree_last(node);
> #line 51
>   subtree_last = tmp;
> #line 52
>   if (node->end == subtree_last) {
> #line 53
>     goto ldv_14133;
>   } else {
> 
>   }
> #line 54
>   node->end = subtree_last;
> #line 55
>   rb = (struct rb_node *)(node->rb.__rb_parent_color & 0xfffffffffffffffcUL);
>   ldv_14135: ;
> #line 49
>   if ((unsigned long )rb != (unsigned long )stop) {
> #line 50
>     goto ldv_14134;
>   } else {
> 
>   }
>   ldv_14133: ;
> #line 54
>   return;
> }
> }
> #line 59 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> static void augment_copy(struct rb_node *rb_old , struct rb_node *rb_new ) 
> { 
>   struct drbd_interval *old ;
>   struct rb_node  const  *__mptr ;
>   struct drbd_interval *new ;
>   struct rb_node  const  *__mptr___0 ;
> 
>   {
> #line 61
>   __mptr = (struct rb_node  const  *)rb_old;
> #line 61
>   old = (struct drbd_interval *)__mptr;
> #line 62
>   __mptr___0 = (struct rb_node  const  *)rb_new;
> #line 62
>   new = (struct drbd_interval *)__mptr___0;
> #line 64
>   new->end = old->end;
> #line 65
>   return;
> }
> }
> #line 67 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> static void augment_rotate(struct rb_node *rb_old , struct rb_node *rb_new ) 
> { 
>   struct drbd_interval *old ;
>   struct rb_node  const  *__mptr ;
>   struct drbd_interval *new ;
>   struct rb_node  const  *__mptr___0 ;
> 
>   {
> #line 69
>   __mptr = (struct rb_node  const  *)rb_old;
> #line 69
>   old = (struct drbd_interval *)__mptr;
> #line 70
>   __mptr___0 = (struct rb_node  const  *)rb_new;
> #line 70
>   new = (struct drbd_interval *)__mptr___0;
> #line 72
>   new->end = old->end;
> #line 73
>   old->end = compute_subtree_last(old);
> #line 74
>   return;
> }
> }
> #line 76 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> static struct rb_augment_callbacks  const  augment_callbacks  =    {& augment_propagate, & augment_copy, & augment_rotate};
> #line 86 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> bool drbd_insert_interval(struct rb_root *root , struct drbd_interval *this ) 
> { 
>   struct rb_node **new ;
>   struct rb_node *parent ;
>   long tmp ;
>   struct drbd_interval *here ;
>   struct rb_node  const  *__mptr ;
> 
>   {
> #line 88
>   new = & root->rb_node;
> #line 88
>   parent = 0;
> #line 90
>   tmp = __builtin_expect((this->size & 511U) != 0U, 0L);
> #line 90
>   if (tmp != 0L) {
> #line 90
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"),
>                          "i" (90), "i" (12UL));
>     ldv_14163: ;
> #line 90
>     goto ldv_14163;
>   } else {
> 
>   }
> #line 92
>   goto ldv_14168;
>   ldv_14167: 
> #line 94
>   __mptr = (struct rb_node  const  *)*new;
> #line 94
>   here = (struct drbd_interval *)__mptr;
> #line 96
>   parent = *new;
> #line 97
>   if (this->sector < here->sector) {
> #line 98
>     new = & (*new)->rb_left;
>   } else
> #line 99
>   if (this->sector > here->sector) {
> #line 100
>     new = & (*new)->rb_right;
>   } else
> #line 101
>   if ((unsigned long )this < (unsigned long )here) {
> #line 102
>     new = & (*new)->rb_left;
>   } else
> #line 103
>   if ((unsigned long )this > (unsigned long )here) {
> #line 104
>     new = & (*new)->rb_right;
>   } else {
> #line 106
>     return (0);
>   }
>   ldv_14168: ;
> #line 92
>   if ((unsigned long )*new != (unsigned long )((struct rb_node *)0)) {
> #line 93
>     goto ldv_14167;
>   } else {
> 
>   }
> #line 109
>   rb_link_node(& this->rb, parent, new);
> #line 110
>   rb_insert_augmented(& this->rb, root, & augment_callbacks);
> #line 111
>   return (1);
> }
> }
> #line 125 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> bool drbd_contains_interval(struct rb_root *root , sector_t sector , struct drbd_interval *interval ) 
> { 
>   struct rb_node *node ;
>   struct drbd_interval *here ;
>   struct rb_node  const  *__mptr ;
> 
>   {
> #line 128
>   node = root->rb_node;
> #line 130
>   goto ldv_14180;
>   ldv_14179: 
> #line 132
>   __mptr = (struct rb_node  const  *)node;
> #line 132
>   here = (struct drbd_interval *)__mptr;
> #line 134
>   if (here->sector > sector) {
> #line 135
>     node = node->rb_left;
>   } else
> #line 136
>   if (here->sector < sector) {
> #line 137
>     node = node->rb_right;
>   } else
> #line 138
>   if ((unsigned long )interval < (unsigned long )here) {
> #line 139
>     node = node->rb_left;
>   } else
> #line 140
>   if ((unsigned long )interval > (unsigned long )here) {
> #line 141
>     node = node->rb_right;
>   } else {
> #line 143
>     return (1);
>   }
>   ldv_14180: ;
> #line 130
>   if ((unsigned long )node != (unsigned long )((struct rb_node *)0)) {
> #line 131
>     goto ldv_14179;
>   } else {
> 
>   }
> 
> #line 145
>   return (0);
> }
> }
> #line 152 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> void drbd_remove_interval(struct rb_root *root , struct drbd_interval *this ) 
> { 
> 
> 
>   {
> #line 154
>   rb_erase_augmented(& this->rb, root, & augment_callbacks);
> #line 155
>   return;
> }
> }
> #line 169 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> struct drbd_interval *drbd_find_overlap(struct rb_root *root , sector_t sector , unsigned int size ) 
> { 
>   struct rb_node *node ;
>   struct drbd_interval *overlap ;
>   sector_t end ;
>   long tmp ;
>   struct drbd_interval *here ;
>   struct rb_node  const  *__mptr ;
>   sector_t tmp___0 ;
> 
>   {
> #line 171
>   node = root->rb_node;
> #line 172
>   overlap = 0;
> #line 173
>   end = (sector_t )(size >> 9) + sector;
> #line 175
>   tmp = __builtin_expect((size & 511U) != 0U, 0L);
> #line 175
>   if (tmp != 0L) {
> #line 175
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"),
>                          "i" (175), "i" (12UL));
>     ldv_14194: ;
> #line 175
>     goto ldv_14194;
>   } else {
> 
>   }
> #line 177
>   goto ldv_14200;
>   ldv_14199: 
> #line 179
>   __mptr = (struct rb_node  const  *)node;
> #line 179
>   here = (struct drbd_interval *)__mptr;
> #line 181
>   if ((unsigned long )node->rb_left != (unsigned long )((struct rb_node *)0)) {
> #line 181
>     tmp___0 = interval_end(node->rb_left);
> #line 181
>     if (tmp___0 > sector) {
> #line 184
>       node = node->rb_left;
>     } else {
> #line 181
>       goto _L;
>     }
>   } else
>   _L: /* CIL Label */ 
> #line 185
>   if (here->sector < end && here->sector + (sector_t )(here->size >> 9) > sector) {
> #line 187
>     overlap = here;
> #line 188
>     goto ldv_14198;
>   } else
> #line 189
>   if (here->sector <= sector) {
> #line 191
>     node = node->rb_right;
>   } else {
> #line 193
>     goto ldv_14198;
>   }
>   ldv_14200: ;
> #line 177
>   if ((unsigned long )node != (unsigned long )((struct rb_node *)0)) {
> #line 178
>     goto ldv_14199;
>   } else {
> 
>   }
>   ldv_14198: ;
> #line 195
>   return (overlap);
> }
> }
> #line 199 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_interval.c.prepared"
> struct drbd_interval *drbd_next_overlap(struct drbd_interval *i , sector_t sector ,
>                                         unsigned int size ) 
> { 
>   sector_t end ;
>   struct rb_node *node ;
>   struct rb_node  const  *__mptr ;
> 
>   {
> #line 201
>   end = (sector_t )(size >> 9) + sector;
>   ldv_14210: 
> #line 205
>   node = rb_next((struct rb_node  const  *)(& i->rb));
> #line 206
>   if ((unsigned long )node == (unsigned long )((struct rb_node *)0)) {
> #line 207
>     return (0);
>   } else {
> 
>   }
> #line 208
>   __mptr = (struct rb_node  const  *)node;
> #line 208
>   i = (struct drbd_interval *)__mptr;
> #line 209
>   if (i->sector >= end) {
> #line 210
>     return (0);
>   } else {
> 
>   }
> #line 211
>   if (i->sector + (sector_t )(i->size >> 9) > sector) {
> #line 212
>     return (i);
>   } else {
> 
>   }
> #line 213
>   goto ldv_14210;
> }
> }
> #line 13 "include/linux/wait.h"
> extern int default_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
> #line 81 "include/linux/wait.h"
> __inline static void init_waitqueue_entry(wait_queue_t *q , struct task_struct *p ) 
> { 
> 
> 
>   {
> #line 83
>   q->flags = 0U;
> #line 84
>   q->private = (void *)p;
> #line 85
>   q->func = & default_wake_function;
> #line 86
>   return;
> }
> }
> #line 101
> extern void add_wait_queue(wait_queue_head_t * , wait_queue_t * ) ;
> #line 103
> extern void remove_wait_queue(wait_queue_head_t * , wait_queue_t * ) ;
> #line 123 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_state.h"
> void print_st_err(struct drbd_conf *mdev , union drbd_state os , union drbd_state ns ,
>                   enum drbd_state_rv err ) ;
> #line 157
> enum drbd_disk_state conn_lowest_disk(struct drbd_tconn *tconn ) ;
> #line 159
> enum drbd_conns conn_lowest_conn(struct drbd_tconn *tconn ) ;
> #line 1937 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void drbd_thread_stop_nowait(struct drbd_thread *thi ) 
> { 
> 
> 
>   {
> #line 1939
>   _drbd_thread_stop(thi, 0, 0);
> #line 1940
>   return;
> }
> }
> #line 1942 "/work/ldvuser/novikov/inst/current/envs/linux/linux/drivers/block/drbd/drbd_int.h"
> __inline static void drbd_thread_restart_nowait(struct drbd_thread *thi ) 
> { 
> 
> 
>   {
> #line 1944
>   _drbd_thread_stop(thi, 1, 0);
> #line 1945
>   return;
> }
> }
> #line 59 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static int w_after_state_ch(struct drbd_work *w , int unused ) ;
> #line 60
> static void after_state_ch(struct drbd_conf *mdev , union drbd_state os , union drbd_state ns ,
>                            enum chg_state_flags flags ) ;
> #line 62
> static enum drbd_state_rv is_valid_state(struct drbd_conf *mdev , union drbd_state ns ) ;
> #line 63
> static enum drbd_state_rv is_valid_soft_transition(union drbd_state os , union drbd_state ns ,
>                                                    struct drbd_tconn *tconn ) ;
> #line 64
> static enum drbd_state_rv is_valid_transition(union drbd_state os , union drbd_state ns ) ;
> #line 65
> static union drbd_state sanitize_state(struct drbd_conf *mdev , union drbd_state ns ,
>                                        enum sanitize_state_warnings *warn ) ;
> #line 68 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> __inline static bool is_susp(union drbd_state s ) 
> { 
> 
> 
>   {
> #line 70
>   return ((bool )(((unsigned int )*((unsigned char *)(& s) + 2UL) != 0U || (unsigned int )*((unsigned char *)(& s) + 2UL) != 0U) || (unsigned int )*((unsigned char *)(& s) + 2UL) != 0U));
> }
> }
> #line 73 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> bool conn_all_vols_unconf(struct drbd_tconn *tconn ) 
> { 
>   struct drbd_conf *mdev ;
>   bool rv ;
>   int vnr ;
>   void *tmp ;
>   void *tmp___0 ;
> 
>   {
> #line 76
>   rv = 1;
> #line 79
>   rcu_read_lock();
> #line 80
>   vnr = 0;
> #line 80
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 80
>   mdev = (struct drbd_conf *)tmp;
> #line 80
>   goto ldv_51839;
>   ldv_51838: ;
> #line 81
>   if (((unsigned int )*((unsigned char *)mdev + 749UL) != 0U || (unsigned int )*((unsigned short *)mdev + 374UL) != 0U) || (unsigned int )*((unsigned char *)mdev + 748UL) != 2U) {
> #line 84
>     rv = 0;
> #line 85
>     goto ldv_51837;
>   } else {
> 
>   }
> #line 80
>   vnr = vnr + 1;
> #line 80
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 80
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_51839: ;
> #line 80
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 81
>     goto ldv_51838;
>   } else {
> 
>   }
>   ldv_51837: 
> #line 88
>   rcu_read_unlock();
> #line 90
>   return (rv);
> }
> }
> #line 95 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static enum drbd_role max_role(enum drbd_role role1 , enum drbd_role role2 ) 
> { 
> 
> 
>   {
> #line 97
>   if ((unsigned int )role1 == 1U || (unsigned int )role2 == 1U) {
> #line 98
>     return (R_PRIMARY);
>   } else {
> 
>   }
> #line 99
>   if ((unsigned int )role1 == 2U || (unsigned int )role2 == 2U) {
> #line 100
>     return (R_SECONDARY);
>   } else {
> 
>   }
> #line 101
>   return (R_UNKNOWN);
> }
> }
> #line 103 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static enum drbd_role min_role(enum drbd_role role1 , enum drbd_role role2 ) 
> { 
> 
> 
>   {
> #line 105
>   if ((unsigned int )role1 == 0U || (unsigned int )role2 == 0U) {
> #line 106
>     return (R_UNKNOWN);
>   } else {
> 
>   }
> #line 107
>   if ((unsigned int )role1 == 2U || (unsigned int )role2 == 2U) {
> #line 108
>     return (R_SECONDARY);
>   } else {
> 
>   }
> #line 109
>   return (R_PRIMARY);
> }
> }
> #line 112 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> enum drbd_role conn_highest_role(struct drbd_tconn *tconn ) 
> { 
>   enum drbd_role role ;
>   struct drbd_conf *mdev ;
>   int vnr ;
>   void *tmp ;
>   void *tmp___0 ;
> 
>   {
> #line 114
>   role = R_UNKNOWN;
> #line 118
>   rcu_read_lock();
> #line 119
>   vnr = 0;
> #line 119
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 119
>   mdev = (struct drbd_conf *)tmp;
> #line 119
>   goto ldv_51855;
>   ldv_51854: 
> #line 120
>   role = max_role(role, (enum drbd_role )mdev->state.ldv_50103.role);
> #line 119
>   vnr = vnr + 1;
> #line 119
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 119
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_51855: ;
> #line 119
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 120
>     goto ldv_51854;
>   } else {
> 
>   }
> #line 121
>   rcu_read_unlock();
> #line 123
>   return (role);
> }
> }
> #line 126 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> enum drbd_role conn_highest_peer(struct drbd_tconn *tconn ) 
> { 
>   enum drbd_role peer ;
>   struct drbd_conf *mdev ;
>   int vnr ;
>   void *tmp ;
>   void *tmp___0 ;
> 
>   {
> #line 128
>   peer = R_UNKNOWN;
> #line 132
>   rcu_read_lock();
> #line 133
>   vnr = 0;
> #line 133
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 133
>   mdev = (struct drbd_conf *)tmp;
> #line 133
>   goto ldv_51864;
>   ldv_51863: 
> #line 134
>   peer = max_role(peer, (enum drbd_role )mdev->state.ldv_50103.peer);
> #line 133
>   vnr = vnr + 1;
> #line 133
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 133
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_51864: ;
> #line 133
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 134
>     goto ldv_51863;
>   } else {
> 
>   }
> #line 135
>   rcu_read_unlock();
> #line 137
>   return (peer);
> }
> }
> #line 140 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> enum drbd_disk_state conn_highest_disk(struct drbd_tconn *tconn ) 
> { 
>   enum drbd_disk_state ds ;
>   struct drbd_conf *mdev ;
>   int vnr ;
>   void *tmp ;
>   enum drbd_disk_state __max1 ;
>   enum drbd_disk_state __max2 ;
>   void *tmp___0 ;
> 
>   {
> #line 142
>   ds = D_DISKLESS;
> #line 146
>   rcu_read_lock();
> #line 147
>   vnr = 0;
> #line 147
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 147
>   mdev = (struct drbd_conf *)tmp;
> #line 147
>   goto ldv_51876;
>   ldv_51875: 
> #line 148
>   __max1 = ds;
> #line 148
>   __max2 = (enum drbd_disk_state )mdev->state.ldv_50103.disk;
> #line 148
>   ds = (enum drbd_disk_state )((unsigned int )__max1 > (unsigned int )__max2 ? (unsigned int )__max1 : (unsigned int )__max2);
> #line 147
>   vnr = vnr + 1;
> #line 147
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 147
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_51876: ;
> #line 147
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 148
>     goto ldv_51875;
>   } else {
> 
>   }
> #line 149
>   rcu_read_unlock();
> #line 151
>   return (ds);
> }
> }
> #line 154 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> enum drbd_disk_state conn_lowest_disk(struct drbd_tconn *tconn ) 
> { 
>   enum drbd_disk_state ds ;
>   struct drbd_conf *mdev ;
>   int vnr ;
>   void *tmp ;
>   enum drbd_disk_state __min1 ;
>   enum drbd_disk_state __min2 ;
>   void *tmp___0 ;
> 
>   {
> #line 156
>   ds = D_MASK;
> #line 160
>   rcu_read_lock();
> #line 161
>   vnr = 0;
> #line 161
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 161
>   mdev = (struct drbd_conf *)tmp;
> #line 161
>   goto ldv_51888;
>   ldv_51887: 
> #line 162
>   __min1 = ds;
> #line 162
>   __min2 = (enum drbd_disk_state )mdev->state.ldv_50103.disk;
> #line 162
>   ds = (enum drbd_disk_state )((unsigned int )__min1 < (unsigned int )__min2 ? (unsigned int )__min1 : (unsigned int )__min2);
> #line 161
>   vnr = vnr + 1;
> #line 161
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 161
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_51888: ;
> #line 161
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 162
>     goto ldv_51887;
>   } else {
> 
>   }
> #line 163
>   rcu_read_unlock();
> #line 165
>   return (ds);
> }
> }
> #line 168 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> enum drbd_disk_state conn_highest_pdsk(struct drbd_tconn *tconn ) 
> { 
>   enum drbd_disk_state ds ;
>   struct drbd_conf *mdev ;
>   int vnr ;
>   void *tmp ;
>   enum drbd_disk_state __max1 ;
>   enum drbd_disk_state __max2 ;
>   void *tmp___0 ;
> 
>   {
> #line 170
>   ds = D_DISKLESS;
> #line 174
>   rcu_read_lock();
> #line 175
>   vnr = 0;
> #line 175
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 175
>   mdev = (struct drbd_conf *)tmp;
> #line 175
>   goto ldv_51900;
>   ldv_51899: 
> #line 176
>   __max1 = ds;
> #line 176
>   __max2 = (enum drbd_disk_state )mdev->state.ldv_50103.pdsk;
> #line 176
>   ds = (enum drbd_disk_state )((unsigned int )__max1 > (unsigned int )__max2 ? (unsigned int )__max1 : (unsigned int )__max2);
> #line 175
>   vnr = vnr + 1;
> #line 175
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 175
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_51900: ;
> #line 175
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 176
>     goto ldv_51899;
>   } else {
> 
>   }
> #line 177
>   rcu_read_unlock();
> #line 179
>   return (ds);
> }
> }
> #line 182 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> enum drbd_conns conn_lowest_conn(struct drbd_tconn *tconn ) 
> { 
>   enum drbd_conns conn ;
>   struct drbd_conf *mdev ;
>   int vnr ;
>   void *tmp ;
>   enum drbd_conns __min1 ;
>   enum drbd_conns __min2 ;
>   void *tmp___0 ;
> 
>   {
> #line 184
>   conn = C_MASK;
> #line 188
>   rcu_read_lock();
> #line 189
>   vnr = 0;
> #line 189
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 189
>   mdev = (struct drbd_conf *)tmp;
> #line 189
>   goto ldv_51912;
>   ldv_51911: 
> #line 190
>   __min1 = conn;
> #line 190
>   __min2 = (enum drbd_conns )mdev->state.ldv_50103.conn;
> #line 190
>   conn = (enum drbd_conns )((unsigned int )__min1 < (unsigned int )__min2 ? (unsigned int )__min1 : (unsigned int )__min2);
> #line 189
>   vnr = vnr + 1;
> #line 189
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 189
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_51912: ;
> #line 189
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 190
>     goto ldv_51911;
>   } else {
> 
>   }
> #line 191
>   rcu_read_unlock();
> #line 193
>   return (conn);
> }
> }
> #line 196 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static bool no_peer_wf_report_params(struct drbd_tconn *tconn ) 
> { 
>   struct drbd_conf *mdev ;
>   int vnr ;
>   bool rv ;
>   void *tmp ;
>   void *tmp___0 ;
> 
>   {
> #line 200
>   rv = 1;
> #line 202
>   rcu_read_lock();
> #line 203
>   vnr = 0;
> #line 203
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 203
>   mdev = (struct drbd_conf *)tmp;
> #line 203
>   goto ldv_51922;
>   ldv_51921: ;
> #line 204
>   if ((unsigned int )*((unsigned short *)mdev + 374UL) == 144U) {
> #line 205
>     rv = 0;
> #line 206
>     goto ldv_51920;
>   } else {
> 
>   }
> #line 203
>   vnr = vnr + 1;
> #line 203
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 203
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_51922: ;
> #line 203
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 204
>     goto ldv_51921;
>   } else {
> 
>   }
>   ldv_51920: 
> #line 208
>   rcu_read_unlock();
> #line 210
>   return (rv);
> }
> }
> #line 220 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static int cl_wide_st_chg(struct drbd_conf *mdev , union drbd_state os , union drbd_state ns ) 
> { 
> 
> 
>   {
> #line 223
>   return ((((((int )os.ldv_40604.conn > 9 && (int )ns.ldv_40604.conn > 9) && (((((unsigned int )*((unsigned char *)(& os) + 0UL) != 1U && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U) || ((unsigned int )*((unsigned short *)(& os) + 0UL) != 192U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 192U)) || ((unsigned int )*((unsigned short *)(& os) + 0UL) != 176U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 176U)) || ((unsigned int )*((unsigned char *)(& os) + 1UL) != 4U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 4U))) || ((int )os.ldv_40604.conn > 9 && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 16U)) || ((unsigned int )*((unsigned short *)(& os) + 0UL) == 160U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U)) || ((unsigned int )*((unsigned short *)(& os) + 0UL) == 160U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 144U));
> }
> }
> #line 234 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static union drbd_state apply_mask_val(union drbd_state os , union drbd_state mask ,
>                                        union drbd_state val ) 
> { 
>   union drbd_state ns ;
> 
>   {
> #line 237
>   ns.i = (os.i & ~ mask.i) | val.i;
> #line 238
>   return (ns);
> }
> }
> #line 242 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> enum drbd_state_rv drbd_change_state(struct drbd_conf *mdev , enum chg_state_flags f ,
>                                      union drbd_state mask , union drbd_state val ) 
> { 
>   unsigned long flags ;
>   union drbd_state ns ;
>   enum drbd_state_rv rv ;
>   raw_spinlock_t *tmp ;
>   union drbd_state tmp___0 ;
> 
>   {
> #line 249
>   tmp = spinlock_check(& (mdev->tconn)->req_lock);
> #line 249
>   flags = _raw_spin_lock_irqsave(tmp);
> #line 250
>   tmp___0 = drbd_read_state(mdev);
> #line 250
>   ns = apply_mask_val(tmp___0, mask, val);
> #line 251
>   rv = _drbd_set_state(mdev, ns, f, 0);
> #line 252
>   spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
> #line 254
>   return (rv);
> }
> }
> #line 263 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> void drbd_force_state(struct drbd_conf *mdev , union drbd_state mask , union drbd_state val ) 
> { 
> 
> 
>   {
> #line 266
>   drbd_change_state(mdev, CS_HARD, mask, val);
> #line 267
>   return;
> }
> }
> #line 270 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static enum drbd_state_rv _req_st_cond(struct drbd_conf *mdev , union drbd_state mask ,
>                                        union drbd_state val ) 
> { 
>   union drbd_state os ;
>   union drbd_state ns ;
>   unsigned long flags ;
>   enum drbd_state_rv rv ;
>   int tmp ;
>   int tmp___0 ;
>   raw_spinlock_t *tmp___1 ;
>   union drbd_state tmp___2 ;
>   int tmp___3 ;
> 
>   {
> #line 277
>   tmp = test_and_clear_bit(3, (unsigned long volatile   *)(& mdev->flags));
> #line 277
>   if (tmp != 0) {
> #line 278
>     return (SS_CW_SUCCESS);
>   } else {
> 
>   }
> #line 280
>   tmp___0 = test_and_clear_bit(4, (unsigned long volatile   *)(& mdev->flags));
> #line 280
>   if (tmp___0 != 0) {
> #line 281
>     return (SS_CW_FAILED_BY_PEER);
>   } else {
> 
>   }
> #line 283
>   tmp___1 = spinlock_check(& (mdev->tconn)->req_lock);
> #line 283
>   flags = _raw_spin_lock_irqsave(tmp___1);
> #line 284
>   os = drbd_read_state(mdev);
> #line 285
>   tmp___2 = apply_mask_val(os, mask, val);
> #line 285
>   ns = sanitize_state(mdev, tmp___2, 0);
> #line 286
>   rv = is_valid_transition(os, ns);
> #line 287
>   if ((int )rv > 0) {
> #line 288
>     rv = SS_UNKNOWN_ERROR;
>   } else {
> 
>   }
> #line 290
>   tmp___3 = cl_wide_st_chg(mdev, os, ns);
> #line 290
>   if (tmp___3 == 0) {
> #line 291
>     rv = SS_CW_NO_NEED;
>   } else {
> 
>   }
> #line 292
>   if ((int )rv == 0) {
> #line 293
>     rv = is_valid_state(mdev, ns);
> #line 294
>     if ((int )rv > 0) {
> #line 295
>       rv = is_valid_soft_transition(os, ns, mdev->tconn);
> #line 296
>       if ((int )rv > 0) {
> #line 297
>         rv = SS_UNKNOWN_ERROR;
>       } else {
> 
>       }
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 300
>   spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
> #line 302
>   return (rv);
> }
> }
> #line 316 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static enum drbd_state_rv drbd_req_state(struct drbd_conf *mdev , union drbd_state mask ,
>                                          union drbd_state val , enum chg_state_flags f ) 
> { 
>   struct completion done ;
>   unsigned long flags ;
>   union drbd_state os ;
>   union drbd_state ns ;
>   enum drbd_state_rv rv ;
>   raw_spinlock_t *tmp ;
>   union drbd_state tmp___0 ;
>   int tmp___1 ;
>   wait_queue_t __wait ;
>   struct task_struct *tmp___2 ;
>   raw_spinlock_t *tmp___3 ;
>   union drbd_state tmp___4 ;
>   int tmp___5 ;
>   struct task_struct *tmp___6 ;
> 
>   {
> #line 324
>   init_completion(& done);
> #line 326
>   if (((unsigned int )f & 8U) != 0U) {
> #line 327
>     mutex_lock_nested(mdev->state_mutex, 0U);
>   } else {
> 
>   }
> #line 329
>   tmp = spinlock_check(& (mdev->tconn)->req_lock);
> #line 329
>   flags = _raw_spin_lock_irqsave(tmp);
> #line 330
>   os = drbd_read_state(mdev);
> #line 331
>   tmp___0 = apply_mask_val(os, mask, val);
> #line 331
>   ns = sanitize_state(mdev, tmp___0, 0);
> #line 332
>   rv = is_valid_transition(os, ns);
> #line 333
>   if ((int )rv <= 0) {
> #line 334
>     spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
> #line 335
>     goto abort;
>   } else {
> 
>   }
> #line 338
>   tmp___5 = cl_wide_st_chg(mdev, os, ns);
> #line 338
>   if (tmp___5 != 0) {
> #line 339
>     rv = is_valid_state(mdev, ns);
> #line 340
>     if ((int )rv == 1) {
> #line 341
>       rv = is_valid_soft_transition(os, ns, mdev->tconn);
>     } else {
> 
>     }
> #line 342
>     spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
> #line 344
>     if ((int )rv <= 0) {
> #line 345
>       if (((unsigned int )f & 2U) != 0U) {
> #line 346
>         print_st_err(mdev, os, ns, (int )rv);
>       } else {
> 
>       }
> #line 347
>       goto abort;
>     } else {
> 
>     }
> #line 350
>     tmp___1 = drbd_send_state_req(mdev, mask, val);
> #line 350
>     if (tmp___1 != 0) {
> #line 351
>       rv = SS_CW_FAILED_BY_PEER;
> #line 352
>       if (((unsigned int )f & 2U) != 0U) {
> #line 353
>         print_st_err(mdev, os, ns, (int )rv);
>       } else {
> 
>       }
> #line 354
>       goto abort;
>     } else {
> 
>     }
> #line 357
>     rv = _req_st_cond(mdev, mask, val);
> #line 357
>     if ((int )rv != 0) {
> #line 357
>       goto ldv_51978;
>     } else {
> 
>     }
> #line 357
>     tmp___2 = get_current();
> #line 357
>     __wait.flags = 0U;
> #line 357
>     __wait.private = (void *)tmp___2;
> #line 357
>     __wait.func = & autoremove_wake_function;
> #line 357
>     __wait.task_list.next = & __wait.task_list;
> #line 357
>     __wait.task_list.prev = & __wait.task_list;
>     ldv_51981: 
> #line 357
>     prepare_to_wait(& mdev->state_wait, & __wait, 2);
> #line 357
>     rv = _req_st_cond(mdev, mask, val);
> #line 357
>     if ((int )rv != 0) {
> #line 357
>       goto ldv_51980;
>     } else {
> 
>     }
> #line 357
>     schedule();
> #line 357
>     goto ldv_51981;
>     ldv_51980: 
> #line 357
>     finish_wait(& mdev->state_wait, & __wait);
>     ldv_51978: ;
> #line 360
>     if ((int )rv <= 0) {
> #line 361
>       if (((unsigned int )f & 2U) != 0U) {
> #line 362
>         print_st_err(mdev, os, ns, (int )rv);
>       } else {
> 
>       }
> #line 363
>       goto abort;
>     } else {
> 
>     }
> #line 365
>     tmp___3 = spinlock_check(& (mdev->tconn)->req_lock);
> #line 365
>     flags = _raw_spin_lock_irqsave(tmp___3);
> #line 366
>     tmp___4 = drbd_read_state(mdev);
> #line 366
>     ns = apply_mask_val(tmp___4, mask, val);
> #line 367
>     rv = _drbd_set_state(mdev, ns, f, & done);
>   } else {
> #line 369
>     rv = _drbd_set_state(mdev, ns, f, & done);
>   }
> #line 372
>   spin_unlock_irqrestore(& (mdev->tconn)->req_lock, flags);
> #line 374
>   if (((unsigned int )f & 4U) != 0U && (int )rv == 1) {
> #line 375
>     tmp___6 = get_current();
> #line 375
>     if ((unsigned long )tmp___6 == (unsigned long )(mdev->tconn)->worker.task) {
> #line 375
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( current != mdev->tconn->worker.task ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared",
>               375);
>     } else {
> 
>     }
> #line 376
>     wait_for_completion(& done);
>   } else {
> 
>   }
>   abort: ;
> #line 380
>   if (((unsigned int )f & 8U) != 0U) {
> #line 381
>     mutex_unlock(mdev->state_mutex);
>   } else {
> 
>   }
> #line 383
>   return (rv);
> }
> }
> #line 397 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> enum drbd_state_rv _drbd_request_state(struct drbd_conf *mdev , union drbd_state mask ,
>                                        union drbd_state val , enum chg_state_flags f ) 
> { 
>   enum drbd_state_rv rv ;
>   wait_queue_t __wait ;
>   struct task_struct *tmp ;
> 
>   {
> #line 402
>   rv = drbd_req_state(mdev, mask, val, f);
> #line 402
>   if ((int )rv != -18) {
> #line 402
>     goto ldv_51992;
>   } else {
> 
>   }
> #line 402
>   tmp = get_current();
> #line 402
>   __wait.flags = 0U;
> #line 402
>   __wait.private = (void *)tmp;
> #line 402
>   __wait.func = & autoremove_wake_function;
> #line 402
>   __wait.task_list.next = & __wait.task_list;
> #line 402
>   __wait.task_list.prev = & __wait.task_list;
>   ldv_51995: 
> #line 402
>   prepare_to_wait(& mdev->state_wait, & __wait, 2);
> #line 402
>   rv = drbd_req_state(mdev, mask, val, f);
> #line 402
>   if ((int )rv != -18) {
> #line 402
>     goto ldv_51994;
>   } else {
> 
>   }
> #line 402
>   schedule();
> #line 402
>   goto ldv_51995;
>   ldv_51994: 
> #line 402
>   finish_wait(& mdev->state_wait, & __wait);
>   ldv_51992: ;
> #line 405
>   return (rv);
> }
> }
> #line 408 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static void print_st(struct drbd_conf *mdev , char *name , union drbd_state ns ) 
> { 
>   bool tmp ;
>   char const   *tmp___0 ;
>   char const   *tmp___1 ;
>   char const   *tmp___2 ;
>   char const   *tmp___3 ;
>   char const   *tmp___4 ;
> 
>   {
> #line 410
>   tmp = is_susp(ns);
> #line 410
>   tmp___0 = drbd_disk_str((enum drbd_disk_state )ns.ldv_40604.pdsk);
> #line 410
>   tmp___1 = drbd_disk_str((enum drbd_disk_state )ns.ldv_40604.disk);
> #line 410
>   tmp___2 = drbd_role_str((enum drbd_role )ns.ldv_40604.peer);
> #line 410
>   tmp___3 = drbd_role_str((enum drbd_role )ns.ldv_40604.role);
> #line 410
>   tmp___4 = drbd_conn_str((enum drbd_conns )ns.ldv_40604.conn);
> #line 410
>   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), " %s = { cs:%s ro:%s/%s ds:%s/%s %c%c%c%c%c%c }\n",
>           name, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, (int )tmp ? 115 : 114,
>           (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U ? 97 : 45, (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U ? 112 : 45,
>           (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U ? 117 : 45, (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U ? 70 : 45,
>           (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U ? 78 : 45);
> #line 423
>   return;
> }
> }
> #line 426 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> void print_st_err(struct drbd_conf *mdev , union drbd_state os , union drbd_state ns ,
>                   enum drbd_state_rv err ) 
> { 
>   char const   *tmp ;
> 
>   {
> #line 429
>   if ((int )err == -18) {
> #line 430
>     return;
>   } else {
> 
>   }
> #line 431
>   tmp = drbd_set_st_err_str(err);
> #line 431
>   dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "State change failed: %s\n",
>           tmp);
> #line 432
>   print_st(mdev, (char *)" state", os);
> #line 433
>   print_st(mdev, (char *)"wanted", ns);
> #line 434
>   return;
> }
> }
> #line 436 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static long print_state_change(char *pb , union drbd_state os , union drbd_state ns ,
>                                enum chg_state_flags flags ) 
> { 
>   char *pbp ;
>   char const   *tmp ;
>   char const   *tmp___0 ;
>   int tmp___1 ;
>   char const   *tmp___2 ;
>   char const   *tmp___3 ;
>   int tmp___4 ;
>   char const   *tmp___5 ;
>   char const   *tmp___6 ;
>   int tmp___7 ;
>   char const   *tmp___8 ;
>   char const   *tmp___9 ;
>   int tmp___10 ;
>   char const   *tmp___11 ;
>   char const   *tmp___12 ;
>   int tmp___13 ;
> 
>   {
> #line 440
>   pbp = pb;
> #line 441
>   *pbp = 0;
> #line 443
>   if ((int )ns.ldv_40604.role != (int )os.ldv_40604.role && ((unsigned int )flags & 32U) != 0U) {
> #line 444
>     tmp = drbd_role_str((enum drbd_role )ns.ldv_40604.role);
> #line 444
>     tmp___0 = drbd_role_str((enum drbd_role )os.ldv_40604.role);
> #line 444
>     tmp___1 = sprintf(pbp, "role( %s -> %s ) ", tmp___0, tmp);
> #line 444
>     pbp = pbp + (unsigned long )tmp___1;
>   } else {
> 
>   }
> #line 447
>   if ((int )ns.ldv_40604.peer != (int )os.ldv_40604.peer && ((unsigned int )flags & 64U) != 0U) {
> #line 448
>     tmp___2 = drbd_role_str((enum drbd_role )ns.ldv_40604.peer);
> #line 448
>     tmp___3 = drbd_role_str((enum drbd_role )os.ldv_40604.peer);
> #line 448
>     tmp___4 = sprintf(pbp, "peer( %s -> %s ) ", tmp___3, tmp___2);
> #line 448
>     pbp = pbp + (unsigned long )tmp___4;
>   } else {
> 
>   }
> #line 451
>   if ((int )ns.ldv_40604.conn != (int )os.ldv_40604.conn && ((unsigned int )flags & 128U) != 0U) {
> #line 452
>     tmp___5 = drbd_conn_str((enum drbd_conns )ns.ldv_40604.conn);
> #line 452
>     tmp___6 = drbd_conn_str((enum drbd_conns )os.ldv_40604.conn);
> #line 452
>     tmp___7 = sprintf(pbp, "conn( %s -> %s ) ", tmp___6, tmp___5);
> #line 452
>     pbp = pbp + (unsigned long )tmp___7;
>   } else {
> 
>   }
> #line 455
>   if ((int )ns.ldv_40604.disk != (int )os.ldv_40604.disk && ((unsigned int )flags & 256U) != 0U) {
> #line 456
>     tmp___8 = drbd_disk_str((enum drbd_disk_state )ns.ldv_40604.disk);
> #line 456
>     tmp___9 = drbd_disk_str((enum drbd_disk_state )os.ldv_40604.disk);
> #line 456
>     tmp___10 = sprintf(pbp, "disk( %s -> %s ) ", tmp___9, tmp___8);
> #line 456
>     pbp = pbp + (unsigned long )tmp___10;
>   } else {
> 
>   }
> #line 459
>   if ((int )ns.ldv_40604.pdsk != (int )os.ldv_40604.pdsk && ((unsigned int )flags & 512U) != 0U) {
> #line 460
>     tmp___11 = drbd_disk_str((enum drbd_disk_state )ns.ldv_40604.pdsk);
> #line 460
>     tmp___12 = drbd_disk_str((enum drbd_disk_state )os.ldv_40604.pdsk);
> #line 460
>     tmp___13 = sprintf(pbp, "pdsk( %s -> %s ) ", tmp___12, tmp___11);
> #line 460
>     pbp = pbp + (unsigned long )tmp___13;
>   } else {
> 
>   }
> #line 464
>   return ((long )pbp - (long )pb);
> }
> }
> #line 467 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static void drbd_pr_state_change(struct drbd_conf *mdev , union drbd_state os , union drbd_state ns ,
>                                  enum chg_state_flags flags ) 
> { 
>   char pb[300U] ;
>   char *pbp ;
>   long tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
> 
>   {
> #line 471
>   pbp = (char *)(& pb);
> #line 473
>   tmp = print_state_change(pbp, os, ns, (enum chg_state_flags )((unsigned int )flags ^ 992U));
> #line 473
>   pbp = pbp + (unsigned long )tmp;
> #line 475
>   if ((int )ns.ldv_40604.aftr_isp != (int )os.ldv_40604.aftr_isp) {
> #line 476
>     tmp___0 = sprintf(pbp, "aftr_isp( %d -> %d ) ", (int )os.ldv_40604.aftr_isp, (int )ns.ldv_40604.aftr_isp);
> #line 476
>     pbp = pbp + (unsigned long )tmp___0;
>   } else {
> 
>   }
> #line 479
>   if ((int )ns.ldv_40604.peer_isp != (int )os.ldv_40604.peer_isp) {
> #line 480
>     tmp___1 = sprintf(pbp, "peer_isp( %d -> %d ) ", (int )os.ldv_40604.peer_isp, (int )ns.ldv_40604.peer_isp);
> #line 480
>     pbp = pbp + (unsigned long )tmp___1;
>   } else {
> 
>   }
> #line 483
>   if ((int )ns.ldv_40604.user_isp != (int )os.ldv_40604.user_isp) {
> #line 484
>     tmp___2 = sprintf(pbp, "user_isp( %d -> %d ) ", (int )os.ldv_40604.user_isp, (int )ns.ldv_40604.user_isp);
> #line 484
>     pbp = pbp + (unsigned long )tmp___2;
>   } else {
> 
>   }
> #line 488
>   if ((unsigned long )((char *)(& pb)) != (unsigned long )pbp) {
> #line 489
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s\n", (char *)(& pb));
>   } else {
> 
>   }
> #line 490
>   return;
> }
> }
> #line 492 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static void conn_pr_state_change(struct drbd_tconn *tconn , union drbd_state os ,
>                                  union drbd_state ns , enum chg_state_flags flags ) 
> { 
>   char pb[300U] ;
>   char *pbp ;
>   long tmp ;
>   bool tmp___0 ;
>   bool tmp___1 ;
>   int tmp___2 ;
>   bool tmp___3 ;
>   bool tmp___4 ;
> 
>   {
> #line 496
>   pbp = (char *)(& pb);
> #line 498
>   tmp = print_state_change(pbp, os, ns, flags);
> #line 498
>   pbp = pbp + (unsigned long )tmp;
> #line 500
>   tmp___3 = is_susp(ns);
> #line 500
>   tmp___4 = is_susp(os);
> #line 500
>   if ((int )tmp___3 != (int )tmp___4 && ((unsigned int )flags & 1024U) != 0U) {
> #line 501
>     tmp___0 = is_susp(ns);
> #line 501
>     tmp___1 = is_susp(os);
> #line 501
>     tmp___2 = sprintf(pbp, "susp( %d -> %d ) ", (int )tmp___1, (int )tmp___0);
> #line 501
>     pbp = pbp + (unsigned long )tmp___2;
>   } else {
> 
>   }
> #line 505
>   if ((unsigned long )((char *)(& pb)) != (unsigned long )pbp) {
> #line 506
>     printk("\016d-con %s: %s\n", tconn->name, (char *)(& pb));
>   } else {
> 
>   }
> #line 507
>   return;
> }
> }
> #line 516 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static enum drbd_state_rv is_valid_state(struct drbd_conf *mdev , union drbd_state ns ) 
> { 
>   enum drbd_fencing_p fp ;
>   enum drbd_state_rv rv ;
>   struct net_conf *nc ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   struct net_conf *_________p1___0 ;
>   bool __warned___0 ;
>   int tmp___2 ;
>   int tmp___3 ;
>   enum drbd_role tmp___4 ;
> 
>   {
> #line 521
>   rv = 1;
> #line 524
>   rcu_read_lock();
> #line 525
>   fp = FP_DONT_CARE;
> #line 526
>   tmp___1 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 526
>   if (tmp___1 != 0) {
> #line 527
>     _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 527
>     tmp = debug_lockdep_rcu_enabled();
> #line 527
>     if (tmp != 0 && ! __warned) {
> #line 527
>       tmp___0 = rcu_read_lock_held();
> #line 527
>       if (tmp___0 == 0 && 1) {
> #line 527
>         __warned = 1;
> #line 527
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared",
>                                527, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 527
>     fp = (enum drbd_fencing_p )_________p1->fencing;
> #line 528
>     put_ldev(mdev);
>   } else {
> 
>   }
> #line 531
>   _________p1___0 = *((struct net_conf * volatile  *)(& (mdev->tconn)->net_conf));
> #line 531
>   tmp___2 = debug_lockdep_rcu_enabled();
> #line 531
>   if (tmp___2 != 0 && ! __warned___0) {
> #line 531
>     tmp___3 = rcu_read_lock_held();
> #line 531
>     if (tmp___3 == 0 && 1) {
> #line 531
>       __warned___0 = 1;
> #line 531
>       lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared",
>                              531, "suspicious rcu_dereference_check() usage");
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 531
>   nc = _________p1___0;
> #line 532
>   if ((unsigned long )nc != (unsigned long )((struct net_conf *)0)) {
> #line 533
>     if ((int )((signed char )nc->two_primaries) == 0 && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U) {
> #line 534
>       if ((unsigned int )*((unsigned char *)(& ns) + 0UL) == 4U) {
> #line 535
>         rv = SS_TWO_PRIMARIES;
>       } else {
> #line 536
>         tmp___4 = conn_highest_peer(mdev->tconn);
> #line 536
>         if ((unsigned int )tmp___4 == 1U) {
> #line 537
>           rv = SS_O_VOL_PEER_PRI;
>         } else {
> 
>         }
>       }
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 541
>   if ((int )rv <= 0) {
> 
>   } else
> #line 543
>   if ((unsigned int )*((unsigned char *)(& ns) + 0UL) == 2U && mdev->open_cnt != 0) {
> #line 544
>     rv = SS_DEVICE_IN_USE;
>   } else
> #line 546
>   if (((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U && (int )ns.ldv_40604.conn <= 9) && (int )ns.ldv_40604.disk <= 7) {
> #line 547
>     rv = SS_NO_UP_TO_DATE_DISK;
>   } else
> #line 549
>   if ((((int )fp > 0 && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U) && (int )ns.ldv_40604.conn <= 9) && (int )ns.ldv_40604.pdsk > 5) {
> #line 551
>     rv = SS_PRIMARY_NOP;
>   } else
> #line 553
>   if (((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U && (int )ns.ldv_40604.disk <= 4) && (int )ns.ldv_40604.pdsk <= 4) {
> #line 554
>     rv = SS_NO_UP_TO_DATE_DISK;
>   } else
> #line 556
>   if ((int )ns.ldv_40604.conn > 10 && (int )ns.ldv_40604.disk <= 3) {
> #line 557
>     rv = SS_NO_LOCAL_DISK;
>   } else
> #line 559
>   if ((int )ns.ldv_40604.conn > 10 && (int )ns.ldv_40604.pdsk <= 3) {
> #line 560
>     rv = SS_NO_REMOTE_DISK;
>   } else
> #line 562
>   if (((int )ns.ldv_40604.conn > 10 && (int )ns.ldv_40604.disk <= 7) && (int )ns.ldv_40604.pdsk <= 7) {
> #line 563
>     rv = SS_NO_UP_TO_DATE_DISK;
>   } else
> #line 565
>   if (((((unsigned int )*((unsigned short *)(& ns) + 0UL) == 160U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 208U) || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 256U) || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 320U) && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 10U) {
> #line 570
>     rv = SS_CONNECTED_OUTDATES;
>   } else
> #line 572
>   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 304U) && (int )((signed char )nc->verify_alg[0]) == 0) {
> #line 574
>     rv = SS_NO_VERIFY_ALG;
>   } else
> #line 576
>   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 304U) && (mdev->tconn)->agreed_pro_version <= 87) {
> #line 578
>     rv = SS_NOT_SUPPORTED;
>   } else
> #line 580
>   if ((int )ns.ldv_40604.conn > 9 && *((unsigned int *)(& ns) + 0UL) == 49152U) {
> #line 581
>     rv = SS_CONNECTED_OUTDATES;
>   } else {
> 
>   }
> #line 583
>   rcu_read_unlock();
> #line 585
>   return (rv);
> }
> }
> #line 597 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static enum drbd_state_rv is_valid_soft_transition(union drbd_state os , union drbd_state ns ,
>                                                    struct drbd_tconn *tconn ) 
> { 
>   enum drbd_state_rv rv ;
>   int tmp ;
> 
>   {
> #line 599
>   rv = 1;
> #line 601
>   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 192U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 176U) && (int )os.ldv_40604.conn > 10) {
> #line 603
>     rv = SS_RESYNC_RUNNING;
>   } else {
> 
>   }
> #line 605
>   if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 16U && (unsigned int )*((unsigned short *)(& os) + 0UL) == 0U) {
> #line 606
>     rv = SS_ALREADY_STANDALONE;
>   } else {
> 
>   }
> #line 608
>   if ((int )ns.ldv_40604.disk > 1 && (unsigned int )*((unsigned char *)(& os) + 1UL) == 0U) {
> #line 609
>     rv = SS_IS_DISKLESS;
>   } else {
> 
>   }
> #line 611
>   if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 128U && (int )os.ldv_40604.conn <= 1) {
> #line 612
>     rv = SS_NO_NET_CONFIG;
>   } else {
> 
>   }
> #line 614
>   if (((unsigned int )*((unsigned char *)(& ns) + 1UL) == 10U && (int )os.ldv_40604.disk <= 4) && (unsigned int )*((unsigned char *)(& os) + 1UL) != 2U) {
> #line 615
>     rv = SS_LOWER_THAN_OUTDATED;
>   } else {
> 
>   }
> #line 617
>   if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 16U && (unsigned int )*((unsigned short *)(& os) + 0UL) == 32U) {
> #line 618
>     rv = SS_IN_TRANSIENT_STATE;
>   } else {
> 
>   }
> #line 625
>   tmp = constant_test_bit(10U, (unsigned long const volatile   *)(& tconn->flags));
> #line 625
>   if (tmp != 0 && ((unsigned int )*((unsigned short *)(& os) + 0UL) != 144U && ((unsigned int )*((unsigned short *)(& ns) + 0UL) != 144U || (unsigned int )*((unsigned short *)(& os) + 0UL) != 128U))) {
> #line 628
>     rv = SS_IN_TRANSIENT_STATE;
>   } else {
> 
>   }
> #line 630
>   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 304U) && (int )os.ldv_40604.conn <= 9) {
> #line 631
>     rv = SS_NEED_CONNECTION;
>   } else {
> 
>   }
> #line 633
>   if ((((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 304U) && (int )ns.ldv_40604.conn != (int )os.ldv_40604.conn) && (int )os.ldv_40604.conn > 10) {
> #line 635
>     rv = SS_RESYNC_RUNNING;
>   } else {
> 
>   }
> #line 637
>   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 176U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 192U) && (int )os.ldv_40604.conn <= 9) {
> #line 639
>     rv = SS_NEED_CONNECTION;
>   } else {
> 
>   }
> #line 641
>   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 272U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 256U) && (int )os.ldv_40604.conn <= 8) {
> #line 643
>     rv = SS_NEED_CONNECTION;
>   } else {
> 
>   }
> #line 645
>   return (rv);
> }
> }
> #line 649 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static enum drbd_state_rv is_valid_conn_transition(enum drbd_conns oc , enum drbd_conns nc ) 
> { 
> 
> 
>   {
> #line 652
>   if ((unsigned int )oc == (unsigned int )nc) {
> #line 653
>     return (SS_NOTHING_TO_DO);
>   } else {
> 
>   }
> #line 656
>   if ((unsigned int )oc == 0U && (unsigned int )nc == 1U) {
> #line 657
>     return (SS_ALREADY_STANDALONE);
>   } else {
> 
>   }
> #line 660
>   if ((unsigned int )oc == 0U && (unsigned int )nc != 2U) {
> #line 661
>     return (SS_NEED_CONNECTION);
>   } else {
> 
>   }
> #line 665
>   if ((unsigned int )oc <= 8U && (unsigned int )nc > 9U) {
> #line 666
>     return (SS_NEED_CONNECTION);
>   } else {
> 
>   }
> #line 669
>   if ((((unsigned int )oc > 2U && (unsigned int )oc <= 7U) && (unsigned int )nc != 2U) && (unsigned int )nc != 1U) {
> #line 670
>     return (SS_IN_TRANSIENT_STATE);
>   } else {
> 
>   }
> #line 673
>   if ((unsigned int )oc == 1U && (unsigned int )nc != 0U) {
> #line 674
>     return (SS_IN_TRANSIENT_STATE);
>   } else {
> 
>   }
> #line 676
>   return (SS_SUCCESS);
> }
> }
> #line 689 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static enum drbd_state_rv is_valid_transition(union drbd_state os , union drbd_state ns ) 
> { 
>   enum drbd_state_rv rv ;
> 
>   {
> #line 693
>   rv = is_valid_conn_transition((enum drbd_conns )os.ldv_40604.conn, (enum drbd_conns )ns.ldv_40604.conn);
> #line 696
>   if ((unsigned int )*((unsigned char *)(& ns) + 1UL) == 4U && (unsigned int )*((unsigned char *)(& os) + 1UL) == 0U) {
> #line 697
>     rv = SS_IS_DISKLESS;
>   } else {
> 
>   }
> #line 699
>   return (rv);
> }
> }
> #line 702 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static void print_sanitize_warnings(struct drbd_conf *mdev , enum sanitize_state_warnings warn ) 
> { 
>   char const   *msg_table[6U] ;
> 
>   {
> #line 704
>   msg_table[0] = "";
> #line 704
>   msg_table[1] = "Online-verify aborted.";
> #line 704
>   msg_table[2] = "Resync aborted.";
> #line 704
>   msg_table[3] = "Connection lost while negotiating, no data!";
> #line 704
>   msg_table[4] = "Implicitly upgraded disk";
> #line 704
>   msg_table[5] = "Implicitly upgraded pdsk";
> #line 713
>   if ((unsigned int )warn != 0U) {
> #line 714
>     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "%s\n", msg_table[(unsigned int )warn]);
>   } else {
> 
>   }
> #line 715
>   return;
> }
> }
> #line 727 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static union drbd_state sanitize_state(struct drbd_conf *mdev , union drbd_state ns ,
>                                        enum sanitize_state_warnings *warn ) 
> { 
>   enum drbd_fencing_p fp ;
>   enum drbd_disk_state disk_min ;
>   enum drbd_disk_state disk_max ;
>   enum drbd_disk_state pdsk_min ;
>   enum drbd_disk_state pdsk_max ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
> 
>   {
> #line 733
>   if ((unsigned long )warn != (unsigned long )((enum sanitize_state_warnings *)0)) {
> #line 734
>     *warn = NO_WARNING;
>   } else {
> 
>   }
> #line 736
>   fp = FP_DONT_CARE;
> #line 737
>   tmp___1 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 737
>   if (tmp___1 != 0) {
> #line 738
>     rcu_read_lock();
> #line 739
>     _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 739
>     tmp = debug_lockdep_rcu_enabled();
> #line 739
>     if (tmp != 0 && ! __warned) {
> #line 739
>       tmp___0 = rcu_read_lock_held();
> #line 739
>       if (tmp___0 == 0 && 1) {
> #line 739
>         __warned = 1;
> #line 739
>         lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared",
>                                739, "suspicious rcu_dereference_check() usage");
>       } else {
> 
>       }
>     } else {
> 
>     }
> #line 739
>     fp = (enum drbd_fencing_p )_________p1->fencing;
> #line 740
>     rcu_read_unlock();
> #line 741
>     put_ldev(mdev);
>   } else {
> 
>   }
> #line 745
>   if ((int )ns.ldv_40604.conn <= 9) {
> #line 746
>     ns.ldv_40604.peer_isp = 0U;
> #line 747
>     ns.ldv_40604.peer = 0U;
> #line 748
>     if ((int )ns.ldv_40604.pdsk > 6 || (int )ns.ldv_40604.pdsk <= 3) {
> #line 749
>       ns.ldv_40604.pdsk = 6U;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 753
>   if (((unsigned int )*((unsigned short *)(& ns) + 0UL) == 0U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 0U) && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 2U) {
> #line 754
>     ns.ldv_40604.aftr_isp = 0U;
>   } else {
> 
>   }
> #line 758
>   if ((int )ns.ldv_40604.conn > 10 && ((int )ns.ldv_40604.disk <= 2 || (int )ns.ldv_40604.pdsk <= 2)) {
> #line 759
>     if ((unsigned long )warn != (unsigned long )((enum sanitize_state_warnings *)0)) {
> #line 760
>       *warn = (unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 304U ? ABORTED_ONLINE_VERIFY : ABORTED_RESYNC;
>     } else {
> 
>     }
> #line 762
>     ns.ldv_40604.conn = 10U;
>   } else {
> 
>   }
> #line 766
>   if ((int )ns.ldv_40604.conn <= 9 && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 6U) {
> #line 766
>     tmp___2 = _get_ldev_if_state(mdev, D_NEGOTIATING);
> #line 766
>     if (tmp___2 != 0) {
> #line 768
>       if (mdev->ed_uuid == (mdev->ldev)->md.uuid[0]) {
> #line 769
>         ns.ldv_40604.disk = mdev->new_state_tmp.ldv_40604.disk;
> #line 770
>         ns.ldv_40604.pdsk = mdev->new_state_tmp.ldv_40604.pdsk;
>       } else {
> #line 772
>         if ((unsigned long )warn != (unsigned long )((enum sanitize_state_warnings *)0)) {
> #line 773
>           *warn = CONNECTION_LOST_NEGOTIATING;
>         } else {
> 
>         }
> #line 774
>         ns.ldv_40604.disk = 0U;
> #line 775
>         ns.ldv_40604.pdsk = 6U;
>       }
> #line 777
>       put_ldev(mdev);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 781
>   if ((int )ns.ldv_40604.conn > 9 && (int )ns.ldv_40604.conn <= 21) {
> #line 782
>     if ((unsigned int )*((unsigned char *)(& ns) + 1UL) == 14U || (unsigned int )*((unsigned char *)(& ns) + 1UL) == 10U) {
> #line 783
>       ns.ldv_40604.disk = 8U;
>     } else {
> 
>     }
> #line 784
>     if (*((unsigned int *)(& ns) + 0UL) == 57344U || *((unsigned int *)(& ns) + 0UL) == 40960U) {
> #line 785
>       ns.ldv_40604.pdsk = 8U;
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 789
>   disk_min = D_DISKLESS;
> #line 790
>   disk_max = D_UP_TO_DATE;
> #line 791
>   pdsk_min = D_INCONSISTENT;
> #line 792
>   pdsk_max = D_UNKNOWN;
> #line 793
>   switch ((unsigned int )ns.ldv_40604.conn) {
>   case 14U: ;
>   case 21U: ;
>   case 12U: ;
>   case 15U: ;
>   case 23U: 
> #line 799
>   disk_min = D_INCONSISTENT;
> #line 800
>   disk_max = D_OUTDATED;
> #line 801
>   pdsk_min = D_UP_TO_DATE;
> #line 802
>   pdsk_max = D_UP_TO_DATE;
> #line 803
>   goto ldv_52081;
>   case 18U: ;
>   case 19U: 
> #line 806
>   disk_min = D_UP_TO_DATE;
> #line 807
>   disk_max = D_UP_TO_DATE;
> #line 808
>   pdsk_min = D_UP_TO_DATE;
> #line 809
>   pdsk_max = D_UP_TO_DATE;
> #line 810
>   goto ldv_52081;
>   case 10U: 
> #line 812
>   disk_min = D_DISKLESS;
> #line 813
>   disk_max = D_UP_TO_DATE;
> #line 814
>   pdsk_min = D_DISKLESS;
> #line 815
>   pdsk_max = D_UP_TO_DATE;
> #line 816
>   goto ldv_52081;
>   case 13U: ;
>   case 20U: ;
>   case 11U: ;
>   case 22U: 
> #line 821
>   disk_min = D_UP_TO_DATE;
> #line 822
>   disk_max = D_UP_TO_DATE;
> #line 823
>   pdsk_min = D_INCONSISTENT;
> #line 824
>   pdsk_max = D_CONSISTENT;
> #line 825
>   goto ldv_52081;
>   case 17U: 
> #line 827
>   disk_min = D_INCONSISTENT;
> #line 828
>   disk_max = D_INCONSISTENT;
> #line 829
>   pdsk_min = D_UP_TO_DATE;
> #line 830
>   pdsk_max = D_UP_TO_DATE;
> #line 831
>   goto ldv_52081;
>   case 16U: 
> #line 833
>   disk_min = D_UP_TO_DATE;
> #line 834
>   disk_max = D_UP_TO_DATE;
> #line 835
>   pdsk_min = D_INCONSISTENT;
> #line 836
>   pdsk_max = D_INCONSISTENT;
> #line 837
>   goto ldv_52081;
>   case 0U: ;
>   case 1U: ;
>   case 2U: ;
>   case 3U: ;
>   case 4U: ;
>   case 5U: ;
>   case 6U: ;
>   case 7U: ;
>   case 8U: ;
>   case 9U: ;
>   case 31U: ;
> #line 849
>   goto ldv_52081;
>   }
>   ldv_52081: ;
> #line 851
>   if ((unsigned int )ns.ldv_40604.disk > (unsigned int )disk_max) {
> #line 852
>     ns.ldv_40604.disk = (unsigned char )disk_max;
>   } else {
> 
>   }
> #line 854
>   if ((unsigned int )ns.ldv_40604.disk < (unsigned int )disk_min) {
> #line 855
>     if ((unsigned long )warn != (unsigned long )((enum sanitize_state_warnings *)0)) {
> #line 856
>       *warn = IMPLICITLY_UPGRADED_DISK;
>     } else {
> 
>     }
> #line 857
>     ns.ldv_40604.disk = (unsigned char )disk_min;
56267,56308c62057,62060
< #line 842
<   return;
< }
< }
< #line 844 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void drbd_reconsider_max_bio_size(struct drbd_conf *mdev ) 
< { 
<   unsigned int now ;
<   unsigned int new ;
<   unsigned int local ;
<   unsigned int peer ;
<   unsigned int tmp ;
<   unsigned int tmp___0 ;
<   int tmp___1 ;
<   unsigned int _min1 ;
<   unsigned int _min2 ;
<   unsigned int _min1___0 ;
<   unsigned int _min2___0 ;
<   unsigned int _min1___1 ;
<   unsigned int _min2___1 ;
< 
<   {
< #line 848
<   tmp = queue_max_hw_sectors(mdev->rq_queue);
< #line 848
<   now = tmp << 9;
< #line 849
<   local = mdev->local_max_bio_size;
< #line 850
<   peer = mdev->peer_max_bio_size;
< #line 852
<   tmp___1 = _get_ldev_if_state(mdev, D_ATTACHING);
< #line 852
<   if (tmp___1 != 0) {
< #line 853
<     tmp___0 = queue_max_hw_sectors((((mdev->ldev)->backing_bdev)->bd_disk)->queue);
< #line 853
<     local = tmp___0 << 9;
< #line 854
<     mdev->local_max_bio_size = local;
< #line 855
<     put_ldev(mdev);
---
> #line 859
>   if ((unsigned int )ns.ldv_40604.pdsk > (unsigned int )pdsk_max) {
> #line 860
>     ns.ldv_40604.pdsk = (unsigned char )pdsk_max;
56312,56317d62063
< #line 857
<   _min1 = local;
< #line 857
<   _min2 = 131072U;
< #line 857
<   local = _min1 < _min2 ? _min1 : _min2;
56319c62065
<   if ((int )mdev->state.ldv_40583.conn > 9) {
---
>   if ((unsigned int )ns.ldv_40604.pdsk < (unsigned int )pdsk_min) {
56321,56325c62067
<     if (mdev->agreed_pro_version <= 93) {
< #line 864
<       _min1___0 = mdev->peer_max_bio_size;
< #line 864
<       _min2___0 = 32768U;
---
>     if ((unsigned long )warn != (unsigned long )((enum sanitize_state_warnings *)0)) {
56327,56332c62069
<       peer = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
<     } else
< #line 866
<     if (mdev->agreed_pro_version == 94) {
< #line 867
<       peer = 32768U;
---
>       *warn = IMPLICITLY_UPGRADED_PDSK;
56334,56335c62071
< #line 869
<       peer = 131072U;
---
> 
56336a62073,62081
> #line 865
>     ns.ldv_40604.pdsk = (unsigned char )pdsk_min;
>   } else {
> 
>   }
> #line 868
>   if ((int )fp == 2 && (((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U && (int )ns.ldv_40604.conn <= 9) && (int )ns.ldv_40604.pdsk > 5)) {
> #line 870
>     ns.ldv_40604.susp_fen = 1U;
56341,56345c62086
<   _min1___1 = local;
< #line 872
<   _min2___1 = peer;
< #line 872
<   new = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
---
>   if ((mdev->tconn)->res_opts.on_no_data == 1U && (((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U && (int )ns.ldv_40604.disk <= 7) && (int )ns.ldv_40604.pdsk <= 7)) {
56347,56350c62088
<   if ((unsigned int )*((unsigned char *)mdev + 2276UL) == 1U && new < now) {
< #line 875
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED new < now; (%u < %u)\n",
<             new, now);
---
>     ns.ldv_40604.susp_nod = 1U;
56353a62092,62093
> #line 876
>   if (((unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U || (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U) || (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U) {
56355c62095
<   if (new != now) {
---
>     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 256U) {
56357,56358c62097,62107
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "max BIO size = %u\n",
<               new);
---
>       ns.ldv_40604.conn = 20U;
>     } else {
> 
>     }
> #line 879
>     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 272U) {
> #line 880
>       ns.ldv_40604.conn = 21U;
>     } else {
> 
>     }
56359a62109,62120
> #line 882
>     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 320U) {
> #line 883
>       ns.ldv_40604.conn = 16U;
>     } else {
> 
>     }
> #line 884
>     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 336U) {
> #line 885
>       ns.ldv_40604.conn = 17U;
>     } else {
56360a62122
>     }
56362,56365c62124,62125
< #line 880
<   drbd_setup_queue_param(mdev, new);
< #line 881
<   return;
---
> #line 888
>   return (ns);
56368,56369c62128,62129
< #line 890 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static void drbd_reconfig_start(struct drbd_conf *mdev ) 
---
> #line 891 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> void drbd_resume_al(struct drbd_conf *mdev ) 
56372,56378d62131
<   wait_queue_t __wait ;
<   struct task_struct *tmp___0 ;
<   int tmp___1 ;
<   int tmp___2 ;
<   wait_queue_t __wait___0 ;
<   struct task_struct *tmp___3 ;
<   int tmp___4 ;
56381,56443d62133
< #line 892
<   tmp = drbd_test_and_set_flag(mdev, CONFIG_PENDING);
< #line 892
<   if (tmp == 0) {
< #line 892
<     goto ldv_54196;
<   } else {
< 
<   }
< #line 892
<   tmp___0 = get_current();
< #line 892
<   __wait.flags = 0U;
< #line 892
<   __wait.private = (void *)tmp___0;
< #line 892
<   __wait.func = & autoremove_wake_function;
< #line 892
<   __wait.task_list.next = & __wait.task_list;
< #line 892
<   __wait.task_list.prev = & __wait.task_list;
<   ldv_54199: 
< #line 892
<   prepare_to_wait(& mdev->state_wait, & __wait, 2);
< #line 892
<   tmp___1 = drbd_test_and_set_flag(mdev, CONFIG_PENDING);
< #line 892
<   if (tmp___1 == 0) {
< #line 892
<     goto ldv_54198;
<   } else {
< 
<   }
< #line 892
<   schedule();
< #line 892
<   goto ldv_54199;
<   ldv_54198: 
< #line 892
<   finish_wait(& mdev->state_wait, & __wait);
<   ldv_54196: 
< #line 893
<   tmp___2 = drbd_test_flag(mdev, DEVICE_DYING);
< #line 893
<   if (tmp___2 == 0) {
< #line 893
<     goto ldv_54200;
<   } else {
< 
<   }
< #line 893
<   tmp___3 = get_current();
< #line 893
<   __wait___0.flags = 0U;
< #line 893
<   __wait___0.private = (void *)tmp___3;
< #line 893
<   __wait___0.func = & autoremove_wake_function;
< #line 893
<   __wait___0.task_list.next = & __wait___0.task_list;
< #line 893
<   __wait___0.task_list.prev = & __wait___0.task_list;
<   ldv_54203: 
56445c62135
<   prepare_to_wait(& mdev->state_wait, & __wait___0, 2);
---
>   tmp = test_and_clear_bit(18, (unsigned long volatile   *)(& mdev->flags));
56447,56451c62137,62139
<   tmp___4 = drbd_test_flag(mdev, DEVICE_DYING);
< #line 893
<   if (tmp___4 == 0) {
< #line 893
<     goto ldv_54202;
---
>   if (tmp != 0) {
> #line 894
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Resumed AL updates\n");
56455,56464d62142
< #line 893
<   schedule();
< #line 893
<   goto ldv_54203;
<   ldv_54202: 
< #line 893
<   finish_wait(& mdev->state_wait, & __wait___0);
<   ldv_54200: 
< #line 894
<   drbd_thread_start(& mdev->worker);
56466,56467d62143
<   drbd_flush_workqueue(mdev);
< #line 896
56471,56472c62147,62148
< #line 901 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static void drbd_reconfig_done(struct drbd_conf *mdev ) 
---
> #line 898 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static void set_ov_position(struct drbd_conf *mdev , enum drbd_conns cs ) 
56474c62150
< 
---
>   unsigned long bit ;
56476a62153,62161
> #line 900
>   if ((mdev->tconn)->agreed_pro_version <= 89) {
> #line 901
>     mdev->ov_start_sector = 0UL;
>   } else {
> 
>   }
> #line 902
>   mdev->rs_total = drbd_bm_bits(mdev);
56478c62163
<   spin_lock_irq(& mdev->req_lock);
---
>   mdev->ov_position = 0UL;
56480,56485c62165
<   if (((unsigned int )*((unsigned char *)mdev + 2277UL) == 0U && (unsigned int )*((unsigned short *)mdev + 1138UL) == 0U) && (unsigned int )*((unsigned char *)mdev + 2276UL) == 2U) {
< #line 907
<     drbd_set_flag(mdev, DEVICE_DYING);
< #line 908
<     drbd_thread_stop_nowait(& mdev->worker);
<   } else {
---
>   if ((unsigned int )cs == 19U) {
56487,56490c62167,62168
<     drbd_clear_flag(mdev, CONFIG_PENDING);
<   }
< #line 911
<   spin_unlock_irq(& mdev->req_lock);
---
>     mdev->ov_start_sector = 0xffffffffffffffffUL;
>   } else {
56492c62170
<   __wake_up(& mdev->state_wait, 3U, 1, 0);
---
>     bit = mdev->ov_start_sector >> 3;
56494,56504c62172,62177
<   return;
< }
< }
< #line 916 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static void drbd_suspend_al(struct drbd_conf *mdev ) 
< { 
<   int s ;
<   int tmp ;
<   int tmp___0 ;
< 
<   {
---
>     if (mdev->rs_total <= bit) {
> #line 914
>       mdev->ov_start_sector = (mdev->rs_total - 1UL) << 3;
> #line 916
>       mdev->rs_total = 1UL;
>     } else {
56506,56510c62179,62183
<   s = 0;
< #line 920
<   tmp = lc_try_lock(mdev->act_log);
< #line 920
<   if (tmp != 0) {
---
>       mdev->rs_total = mdev->rs_total - bit;
>     }
> #line 919
>     mdev->ov_position = mdev->ov_start_sector;
>   }
56512c62185
<     drbd_al_shrink(mdev);
---
>   mdev->ov_left = mdev->rs_total;
56514,56541d62186
<     lc_unlock(mdev->act_log);
<   } else {
< #line 924
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Failed to lock al in drbd_suspend_al()\n");
< #line 925
<     return;
<   }
< #line 928
<   spin_lock_irq(& mdev->req_lock);
< #line 929
<   if ((int )mdev->state.ldv_40583.conn <= 9) {
< #line 930
<     tmp___0 = drbd_test_and_set_flag(mdev, AL_SUSPENDED);
< #line 930
<     s = tmp___0 == 0;
<   } else {
< 
<   }
< #line 932
<   spin_unlock_irq(& mdev->req_lock);
< #line 934
<   if (s != 0) {
< #line 935
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Suspended AL updates\n");
<   } else {
< 
<   }
< #line 936
56545,56547c62190,62192
< #line 940 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_disk_conf(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                              struct drbd_nl_cfg_reply *reply ) 
---
> #line 934 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> enum drbd_state_rv __drbd_set_state(struct drbd_conf *mdev , union drbd_state ns ,
>                                     enum chg_state_flags flags , struct completion *done ) 
56549,56556d62193
<   enum drbd_ret_code retcode ;
<   enum determine_dev_size dd ;
<   sector_t max_possible_sectors ;
<   sector_t min_md_device_sectors ;
<   struct drbd_backing_dev *nbc ;
<   struct block_device *bdev ;
<   struct lru_cache *resync_lru ;
<   union drbd_state ns ;
56559,56566c62196,62204
<   int cp_discovered ;
<   int logical_block_size ;
<   int tmp ;
<   wait_queue_t __wait ;
<   struct task_struct *tmp___0 ;
<   int tmp___1 ;
<   void *tmp___2 ;
<   struct lock_class_key __key ;
---
>   enum sanitize_state_warnings ssw ;
>   struct after_state_chg_work *ascw ;
>   enum drbd_state_rv tmp ;
>   bool tmp___0 ;
>   unsigned long tmp___1 ;
>   unsigned long now ;
>   int i ;
>   u32 mdf ;
>   int tmp___2 ;
56568,56611c62206
<   int prot ;
<   int tmp___4 ;
<   long tmp___5 ;
<   long tmp___6 ;
<   long tmp___7 ;
<   long tmp___8 ;
<   sector_t tmp___9 ;
<   sector_t tmp___10 ;
<   sector_t tmp___11 ;
<   sector_t tmp___12 ;
<   sector_t tmp___13 ;
<   int tmp___14 ;
<   int tmp___15 ;
<   wait_queue_t __wait___0 ;
<   struct task_struct *tmp___16 ;
<   int tmp___17 ;
<   int tmp___18 ;
<   union drbd_state val ;
<   union drbd_state mask ;
<   int tmp___19 ;
<   unsigned short tmp___20 ;
<   struct page *page ;
<   struct page *tmp___21 ;
<   int tmp___22 ;
<   int tmp___23 ;
<   int tmp___24 ;
<   int tmp___25 ;
<   sector_t tmp___26 ;
<   int tmp___27 ;
<   int tmp___28 ;
<   int tmp___29 ;
<   int tmp___30 ;
<   int tmp___31 ;
<   int tmp___32 ;
<   int tmp___33 ;
<   int tmp___34 ;
<   int tmp___35 ;
<   unsigned long tmp___36 ;
<   unsigned long tmp___37 ;
<   int tmp___38 ;
<   int tmp___39 ;
<   int tmp___40 ;
<   union drbd_state val___0 ;
<   union drbd_state mask___0 ;
---
>   void *tmp___4 ;
56614,56627c62209,62218
< #line 947
<   nbc = 0;
< #line 949
<   resync_lru = 0;
< #line 952
<   cp_discovered = 0;
< #line 955
<   drbd_reconfig_start(mdev);
< #line 958
<   if ((int )mdev->state.ldv_40583.disk > 0) {
< #line 959
<     retcode = ERR_DISK_CONFIGURED;
< #line 960
<     goto fail;
---
> #line 938
>   rv = 1;
> #line 942
>   os = drbd_read_state(mdev);
> #line 944
>   ns = sanitize_state(mdev, ns, & ssw);
> #line 945
>   if (ns.i == os.i) {
> #line 946
>     return (SS_NOTHING_TO_DO);
56631,56636c62222,62227
< #line 966
<   tmp = atomic_read((atomic_t const   *)(& mdev->local_cnt));
< #line 966
<   if (tmp == 0) {
< #line 966
<     goto ldv_54229;
---
> #line 948
>   rv = is_valid_transition(os, ns);
> #line 949
>   if ((int )rv <= 0) {
> #line 950
>     return (rv);
56640,56660c62231,62249
< #line 966
<   tmp___0 = get_current();
< #line 966
<   __wait.flags = 0U;
< #line 966
<   __wait.private = (void *)tmp___0;
< #line 966
<   __wait.func = & autoremove_wake_function;
< #line 966
<   __wait.task_list.next = & __wait.task_list;
< #line 966
<   __wait.task_list.prev = & __wait.task_list;
<   ldv_54232: 
< #line 966
<   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
< #line 966
<   tmp___1 = atomic_read((atomic_t const   *)(& mdev->local_cnt));
< #line 966
<   if (tmp___1 == 0) {
< #line 966
<     goto ldv_54231;
---
> #line 952
>   if (((unsigned int )flags & 1U) == 0U) {
> #line 956
>     rv = is_valid_state(mdev, ns);
> #line 957
>     if ((int )rv <= 0) {
> #line 961
>       tmp = is_valid_state(mdev, os);
> #line 961
>       if ((int )tmp == (int )rv) {
> #line 962
>         rv = is_valid_soft_transition(os, ns, mdev->tconn);
>       } else {
> #line 964
>         rv = is_valid_soft_transition(os, ns, mdev->tconn);
>       }
>     } else {
> 
>     }
56664,56671c62253,62256
< #line 966
<   schedule();
< #line 966
<   goto ldv_54232;
<   ldv_54231: 
< #line 966
<   finish_wait(& mdev->misc_wait, & __wait);
<   ldv_54229: 
---
> #line 967
>   if ((int )rv <= 0) {
> #line 968
>     if (((unsigned int )flags & 2U) != 0U) {
56673c62258,62261
<   drbd_clear_flag(mdev, FORCE_DETACH);
---
>       print_st_err(mdev, os, ns, rv);
>     } else {
> 
>     }
56675,56679c62263,62268
<   drbd_clear_flag(mdev, WAS_IO_ERROR);
< #line 971
<   drbd_clear_flag(mdev, WAS_READ_ERROR);
< #line 974
<   mdev->rs_total = 0UL;
---
>     return (rv);
>   } else {
> 
>   }
> #line 973
>   print_sanitize_warnings(mdev, ssw);
56681,56687c62270
<   mdev->rs_failed = 0UL;
< #line 976
<   atomic_set(& mdev->rs_pending_cnt, 0);
< #line 979
<   tmp___2 = kzalloc(472UL, 208U);
< #line 979
<   nbc = (struct drbd_backing_dev *)tmp___2;
---
>   drbd_pr_state_change(mdev, os, ns, flags);
56689c62272
<   if ((unsigned long )nbc == (unsigned long )((struct drbd_backing_dev *)0)) {
---
>   if (((unsigned int )flags & 1024U) == 0U) {
56691,56693c62274
<     retcode = ERR_NOMEM;
< #line 982
<     goto fail;
---
>     conn_pr_state_change(mdev->tconn, os, ns, (enum chg_state_flags )(((unsigned int )flags & 4294965279U) | 1024U));
56697,56700d62277
< #line 985
<   nbc->dc.disk_size = 0ULL;
< #line 986
<   nbc->dc.on_io_error = 0;
56702,56711c62279,62286
<   nbc->dc.fencing = 0;
< #line 988
<   nbc->dc.max_bio_bvecs = 0;
< #line 990
<   spinlock_check(& nbc->md.uuid_lock);
< #line 990
<   __raw_spin_lock_init(& nbc->md.uuid_lock.ldv_6135.rlock, "&(&nbc->md.uuid_lock)->rlock",
<                        & __key);
< #line 992
<   tmp___3 = disk_conf_from_tags(mdev, (unsigned short *)(& nlp->tag_list), & nbc->dc);
---
>   if (((unsigned int )*((unsigned char *)(& os) + 1UL) != 4U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 4U) || ((unsigned int )*((unsigned char *)(& os) + 1UL) != 0U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 0U)) {
> #line 989
>     atomic_inc(& mdev->local_cnt);
>   } else {
> 
>   }
> #line 991
>   mdev->state.i = ns.i;
56713c62288
<   if (tmp___3 == 0) {
---
>   (mdev->tconn)->susp = ns.ldv_40604.susp;
56715c62290
<     retcode = ERR_MANDATORY_TAG;
---
>   (mdev->tconn)->susp_nod = ns.ldv_40604.susp_nod;
56717c62292,62296
<     goto fail;
---
>   (mdev->tconn)->susp_fen = ns.ldv_40604.susp_fen;
> #line 996
>   if ((unsigned int )*((unsigned char *)(& os) + 1UL) == 2U && (int )ns.ldv_40604.disk > 2) {
> #line 997
>     drbd_print_uuids(mdev, "attached to UUIDs");
56721,56726c62300,62310
< #line 997
<   if (nbc->dc.meta_dev_idx < -3) {
< #line 998
<     retcode = ERR_MD_IDX_INVALID;
< #line 999
<     goto fail;
---
> #line 1000
>   if ((unsigned int )*((unsigned short *)(& os) + 0UL) == 144U && (unsigned int )*((unsigned short *)(& ns) + 0UL) != 144U) {
> #line 1000
>     tmp___0 = no_peer_wf_report_params(mdev->tconn);
> #line 1000
>     if ((int )tmp___0) {
> #line 1002
>       clear_bit(10, (unsigned long volatile   *)(& (mdev->tconn)->flags));
>     } else {
> 
>     }
56730,56735d62313
< #line 1002
<   tmp___4 = get_net_conf(mdev);
< #line 1002
<   if (tmp___4 != 0) {
< #line 1003
<     prot = (mdev->net_conf)->wire_protocol;
56737c62315
<     put_net_conf(mdev);
---
>   __wake_up(& mdev->misc_wait, 3U, 1, 0);
56739c62317
<     if (nbc->dc.fencing == 2 && prot == 1) {
---
>   __wake_up(& mdev->state_wait, 3U, 1, 0);
56741,56743c62319,62330
<       retcode = ERR_STONITH_AND_PROT_A;
< #line 1007
<       goto fail;
---
>   __wake_up(& (mdev->tconn)->ping_wait, 3U, 1, 0);
> #line 1010
>   if (((unsigned int )*((unsigned short *)(& os) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& os) + 0UL) == 304U) && (int )ns.ldv_40604.conn <= 10) {
> #line 1012
>     tmp___1 = drbd_bm_bits(mdev);
> #line 1012
>     mdev->ov_start_sector = (tmp___1 - mdev->ov_left) << 3;
> #line 1014
>     if (mdev->ov_left != 0UL) {
> #line 1015
>       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Online Verify reached sector %llu\n",
>                 (unsigned long long )mdev->ov_start_sector);
56750,56764c62337,62349
< #line 1011
<   bdev = blkdev_get_by_path((char const   *)(& nbc->dc.backing_dev), 131U, (void *)mdev);
< #line 1013
<   tmp___6 = IS_ERR((void const   *)bdev);
< #line 1013
<   if (tmp___6 != 0L) {
< #line 1014
<     tmp___5 = PTR_ERR((void const   *)bdev);
< #line 1014
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "open(\"%s\") failed with %ld\n",
<             (unsigned char *)(& nbc->dc.backing_dev), tmp___5);
< #line 1016
<     retcode = ERR_OPEN_DISK;
< #line 1017
<     goto fail;
---
> #line 1019
>   if (((unsigned int )*((unsigned short *)(& os) + 0UL) == 336U || (unsigned int )*((unsigned short *)(& os) + 0UL) == 320U) && ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 272U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 256U)) {
> #line 1021
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Syncer continues.\n");
> #line 1022
>     mdev->rs_paused = mdev->rs_paused + (unsigned long )((long )jiffies - (long )mdev->rs_mark_time[mdev->rs_last_mark]);
> #line 1024
>     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 272U) {
> #line 1025
>       mod_timer(& mdev->resync_timer, jiffies);
>     } else {
> 
>     }
56768,56784c62353,62358
< #line 1019
<   nbc->backing_bdev = bdev;
< #line 1029
<   bdev = blkdev_get_by_path((char const   *)(& nbc->dc.meta_dev), 131U, nbc->dc.meta_dev_idx < 0 ? (void *)mdev : (void *)drbd_m_holder);
< #line 1033
<   tmp___8 = IS_ERR((void const   *)bdev);
< #line 1033
<   if (tmp___8 != 0L) {
< #line 1034
<     tmp___7 = PTR_ERR((void const   *)bdev);
< #line 1034
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "open(\"%s\") failed with %ld\n",
<             (unsigned char *)(& nbc->dc.meta_dev), tmp___7);
< #line 1036
<     retcode = ERR_OPEN_MD_DISK;
< #line 1037
<     goto fail;
---
> #line 1028
>   if (((unsigned int )*((unsigned short *)(& os) + 0UL) == 272U || (unsigned int )*((unsigned short *)(& os) + 0UL) == 256U) && ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 336U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 320U)) {
> #line 1030
>     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Resync suspended\n");
> #line 1031
>     mdev->rs_mark_time[mdev->rs_last_mark] = jiffies;
56787a62362,62365
> #line 1034
>   if ((unsigned int )*((unsigned short *)(& os) + 0UL) == 160U && ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 304U)) {
> #line 1036
>     now = jiffies;
56789c62367,62369
<   nbc->md_bdev = bdev;
---
>     set_ov_position(mdev, (enum drbd_conns )ns.ldv_40604.conn);
> #line 1040
>     mdev->rs_start = now;
56791c62371,62375
<   if (((unsigned long )nbc->backing_bdev == (unsigned long )nbc->md_bdev) ^ (int )((_Bool )(nbc->dc.meta_dev_idx == -1 || nbc->dc.meta_dev_idx == -3))) {
---
>     mdev->rs_last_events = 0;
> #line 1042
>     mdev->rs_last_sect_ev = 0;
> #line 1043
>     mdev->ov_last_oos_size = 0UL;
56793,56798c62377,62384
<     retcode = ERR_MD_IDX_INVALID;
< #line 1045
<     goto fail;
<   } else {
< 
<   }
---
>     mdev->ov_last_oos_start = 0UL;
> #line 1046
>     i = 0;
> #line 1046
>     goto ldv_52123;
>     ldv_52122: 
> #line 1047
>     mdev->rs_mark_left[i] = mdev->ov_left;
56800c62386,62396
<   resync_lru = lc_create("resync", drbd_bm_ext_cache, 61U, 64UL, 16UL);
---
>     mdev->rs_mark_time[i] = now;
> #line 1046
>     i = i + 1;
>     ldv_52123: ;
> #line 1046
>     if (i <= 7) {
> #line 1047
>       goto ldv_52122;
>     } else {
> 
>     }
56802,56804c62398
<   if ((unsigned long )resync_lru == (unsigned long )((struct lru_cache *)0)) {
< #line 1052
<     retcode = ERR_NOMEM;
---
>     drbd_rs_controller_reset(mdev);
56806c62400,62408
<     goto fail;
---
>     if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 288U) {
> #line 1054
>       _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Starting Online Verify from sector %llu\n",
>                 (unsigned long long )mdev->ov_position);
> #line 1056
>       mod_timer(& mdev->resync_timer, jiffies);
>     } else {
> 
>     }
56810,56815d62411
< #line 1057
<   drbd_md_set_sector_offsets(mdev, nbc);
< #line 1059
<   tmp___10 = drbd_get_max_capacity___1(nbc);
< #line 1059
<   if ((unsigned long long )tmp___10 < nbc->dc.disk_size) {
56817c62413
<     tmp___9 = drbd_get_max_capacity___1(nbc);
---
>   tmp___3 = _get_ldev_if_state(mdev, D_INCONSISTENT);
56819,56827c62415,62423
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "max capacity %llu smaller than disk size %llu\n",
<             (unsigned long long )tmp___9, nbc->dc.disk_size);
< #line 1063
<     retcode = ERR_DISK_TOO_SMALL;
< #line 1064
<     goto fail;
<   } else {
< 
<   }
---
>   if (tmp___3 != 0) {
> #line 1061
>     mdf = (mdev->ldev)->md.flags & 4294967176U;
> #line 1065
>     mdf = mdf & 4294967167U;
> #line 1066
>     tmp___2 = constant_test_bit(5U, (unsigned long const volatile   *)(& mdev->flags));
> #line 1066
>     if (tmp___2 != 0) {
56829c62425,62428
<   if (nbc->dc.meta_dev_idx < 0) {
---
>       mdf = mdf | 64U;
>     } else {
> 
>     }
56831c62430
<     max_possible_sectors = 2251799813685248UL;
---
>     if ((unsigned int )*((unsigned char *)mdev + 748UL) == 1U || ((int )mdev->state.ldv_50103.pdsk <= 3 && (unsigned int )*((unsigned char *)mdev + 748UL) == 4U)) {
56833,56834c62432,62437
<     min_md_device_sectors = 2048UL;
<   } else {
---
>       mdf = mdf | 2U;
>     } else {
> 
>     }
> #line 1071
>     if ((int )mdev->state.ldv_50103.conn > 9) {
56836c62439,62442
<     max_possible_sectors = 8587575296UL;
---
>       mdf = mdf | 4U;
>     } else {
> 
>     }
56838,56841c62444,62451
<     min_md_device_sectors = (unsigned long )(nbc->dc.meta_dev_idx + 1) * 262144UL;
<   }
< #line 1076
<   tmp___11 = drbd_get_capacity(nbc->md_bdev);
---
>     if ((int )mdev->state.ldv_50103.disk > 4) {
> #line 1074
>       mdf = mdf | 1U;
>     } else {
> 
>     }
> #line 1075
>     if ((int )mdev->state.ldv_50103.disk > 5) {
56843c62453,62456
<   if (tmp___11 < min_md_device_sectors) {
---
>       mdf = mdf | 16U;
>     } else {
> 
>     }
56845c62458
<     retcode = ERR_MD_DISK_TOO_SMALL;
---
>     if ((int )mdev->state.ldv_50103.pdsk <= 5 && (int )mdev->state.ldv_50103.pdsk > 3) {
56847,56848c62460,62467
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "refusing attach: md-device too small, at least %llu sectors needed for this meta-disk type\n",
<              (unsigned long long )min_md_device_sectors);
---
>       mdf = mdf | 32U;
>     } else {
> 
>     }
> #line 1079
>     if ((mdev->ldev)->md.flags != mdf) {
> #line 1080
>       (mdev->ldev)->md.flags = mdf;
56850c62469,62481
<     goto fail;
---
>       drbd_md_mark_dirty(mdev);
>     } else {
> 
>     }
> #line 1083
>     if ((int )os.ldv_40604.disk <= 6 && (int )ns.ldv_40604.disk > 6) {
> #line 1084
>       drbd_set_ed_uuid(mdev, (mdev->ldev)->md.uuid[0]);
>     } else {
> 
>     }
> #line 1085
>     put_ldev(mdev);
56854,56861d62484
< #line 1086
<   tmp___12 = drbd_get_max_capacity___1(nbc);
< #line 1086
<   tmp___13 = drbd_get_capacity(mdev->this_bdev);
< #line 1086
<   if (tmp___12 < tmp___13) {
< #line 1088
<     retcode = ERR_DISK_TOO_SMALL;
56863c62486,62488
<     goto fail;
---
>   if ((((unsigned int )*((unsigned char *)(& os) + 1UL) == 8U && *((unsigned int *)(& os) + 0UL) == 32768U) && (unsigned int )*((unsigned char *)(& os) + 0UL) == 8U) && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 4U) {
> #line 1091
>     set_bit(6U, (unsigned long volatile   *)(& mdev->flags));
56867,56868d62491
< #line 1092
<   nbc->known_size = drbd_get_capacity(nbc->backing_bdev);
56870c62493
<   if (nbc->known_size > max_possible_sectors) {
---
>   if ((unsigned int )*((unsigned short *)(& os) + 0UL) != 16U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 16U) {
56872,56880c62495
<     dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "==> truncating very big lower level device to currently maximum possible %llu sectors <==\n",
<              (unsigned long long )max_possible_sectors);
< #line 1098
<     if (nbc->dc.meta_dev_idx >= 0) {
< #line 1099
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "==>> using internal or flexible meta data may help <<==\n");
<     } else {
< 
<     }
---
>     drbd_thread_stop_nowait(& (mdev->tconn)->receiver);
56884,56891c62499,62502
< #line 1103
<   drbd_suspend_io(mdev);
< #line 1105
<   tmp___14 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 1105
<   if (tmp___14 == 0) {
< #line 1105
<     goto ldv_54235;
---
> #line 1098
>   if ((unsigned int )*((unsigned short *)(& os) + 0UL) != 0U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 0U) {
> #line 1099
>     drbd_thread_stop_nowait(& (mdev->tconn)->receiver);
56893,56899d62503
< #line 1105
<     tmp___15 = is_susp(mdev->state);
< #line 1105
<     if (tmp___15 != 0) {
< #line 1105
<       goto ldv_54235;
<     } else {
56901d62504
<     }
56903,56923c62506,62509
< #line 1105
<   tmp___16 = get_current();
< #line 1105
<   __wait___0.flags = 0U;
< #line 1105
<   __wait___0.private = (void *)tmp___16;
< #line 1105
<   __wait___0.func = & autoremove_wake_function;
< #line 1105
<   __wait___0.task_list.next = & __wait___0.task_list;
< #line 1105
<   __wait___0.task_list.prev = & __wait___0.task_list;
<   ldv_54238: 
< #line 1105
<   prepare_to_wait(& mdev->misc_wait, & __wait___0, 2);
< #line 1105
<   tmp___17 = atomic_read((atomic_t const   *)(& mdev->ap_pending_cnt));
< #line 1105
<   if (tmp___17 == 0) {
< #line 1105
<     goto ldv_54237;
---
> #line 1102
>   if (((int )os.ldv_40604.conn > 8 && (int )ns.ldv_40604.conn <= 7) && (int )ns.ldv_40604.conn > 2) {
> #line 1104
>     drbd_thread_restart_nowait(& (mdev->tconn)->receiver);
56925,56931d62510
< #line 1105
<     tmp___18 = is_susp(mdev->state);
< #line 1105
<     if (tmp___18 != 0) {
< #line 1105
<       goto ldv_54237;
<     } else {
56933d62511
<     }
56935,56942d62512
< #line 1105
<   schedule();
< #line 1105
<   goto ldv_54238;
<   ldv_54237: 
< #line 1105
<   finish_wait(& mdev->misc_wait, & __wait___0);
<   ldv_54235: 
56944,56962c62514,62516
<   drbd_flush_workqueue(mdev);
< #line 1109
<   val.i = 0U;
< #line 1109
<   val.ldv_40583.disk = 1U;
< #line 1109
<   mask.i = 0U;
< #line 1109
<   mask.ldv_40583.disk = 15U;
< #line 1109
<   rv = _drbd_request_state(mdev, mask, val, CS_VERBOSE);
< #line 1110
<   retcode = (enum drbd_ret_code )rv;
< #line 1111
<   drbd_resume_io(mdev);
< #line 1112
<   if ((int )rv <= 0) {
< #line 1113
<     goto fail;
---
>   if ((int )os.ldv_40604.conn <= 9 && (int )ns.ldv_40604.conn > 9) {
> #line 1108
>     drbd_resume_al(mdev);
56965a62520,62521
> #line 1113
>   if (((unsigned int )*((unsigned char *)(& os) + 1UL) == 2U || (unsigned int )*((unsigned char *)(& os) + 1UL) == 6U) && (int )ns.ldv_40604.disk > 3) {
56967,56971c62523
<   tmp___19 = _get_ldev_if_state(mdev, D_ATTACHING);
< #line 1115
<   if (tmp___19 == 0) {
< #line 1116
<     goto force_diskless;
---
>     mdev->last_reattach_jif = jiffies;
56974a62527,62530
> #line 1117
>   tmp___4 = kmalloc(56UL, 32U);
> #line 1117
>   ascw = (struct after_state_chg_work *)tmp___4;
56976,56978c62532,62536
<   drbd_md_set_sector_offsets(mdev, nbc);
< #line 1121
<   tmp___20 = bdev_logical_block_size(nbc->md_bdev);
---
>   if ((unsigned long )ascw != (unsigned long )((struct after_state_chg_work *)0)) {
> #line 1119
>     ascw->os = os;
> #line 1120
>     ascw->ns = ns;
56980c62538
<   logical_block_size = (int )tmp___20;
---
>     ascw->flags = flags;
56982c62540
<   if (logical_block_size == 0) {
---
>     ascw->w.cb = & w_after_state_ch;
56984,56987c62542,62544
<     logical_block_size = 512;
<   } else {
< 
<   }
---
>     ascw->w.ldv_50388.mdev = mdev;
> #line 1124
>     ascw->done = done;
56989,57012c62546
<   if (logical_block_size != 512) {
< #line 1126
<     if ((unsigned long )mdev->md_io_tmpp == (unsigned long )((struct page *)0)) {
< #line 1127
<       tmp___21 = alloc_pages(16U, 0U);
< #line 1127
<       page = tmp___21;
< #line 1128
<       if ((unsigned long )page == (unsigned long )((struct page *)0)) {
< #line 1129
<         goto force_diskless_dec;
<       } else {
< 
<       }
< #line 1131
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Meta data\'s bdev logical_block_size = %d != %d\n",
<                logical_block_size, 512);
< #line 1133
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Workaround engaged (has performance impact).\n");
< #line 1135
<       mdev->md_io_tmpp = page;
<     } else {
< 
<     }
---
>     drbd_queue_work(& (mdev->tconn)->sender_work, & ascw->w);
57014c62548,62549
< 
---
> #line 1127
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Could not kmalloc an ascw\n");
57015a62551,62568
> #line 1130
>   return (rv);
> }
> }
> #line 1133 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static int w_after_state_ch(struct drbd_work *w , int unused ) 
> { 
>   struct after_state_chg_work *ascw ;
>   struct drbd_work  const  *__mptr ;
>   struct drbd_conf *mdev ;
> 
>   {
> #line 1136
>   __mptr = (struct drbd_work  const  *)w;
> #line 1136
>   ascw = (struct after_state_chg_work *)__mptr;
> #line 1137
>   mdev = w->ldv_50388.mdev;
57017,57019c62570
<   if ((unsigned long )mdev->bitmap == (unsigned long )((struct drbd_bitmap *)0)) {
< #line 1140
<     tmp___22 = drbd_bm_init(mdev);
---
>   after_state_ch(mdev, ascw->os, ascw->ns, ascw->flags);
57021c62572
<     if (tmp___22 != 0) {
---
>   if (((unsigned int )ascw->flags & 4U) != 0U) {
57023,57025c62574,62578
<       retcode = ERR_NOMEM;
< #line 1142
<       goto force_diskless_dec;
---
>     if ((unsigned long )ascw->done == (unsigned long )((struct completion *)0)) {
> #line 1141
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( ascw->done != NULL ) in %s:%d\n",
>               (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared",
>               1141);
57028a62582,62583
> #line 1142
>     complete(ascw->done);
57031a62587,62588
> #line 1144
>   kfree((void const   *)ascw);
57033,57040c62590,62599
<   tmp___23 = drbd_md_read(mdev, nbc);
< #line 1146
<   retcode = (enum drbd_ret_code )tmp___23;
< #line 1147
<   if ((unsigned int )retcode != 101U) {
< #line 1148
<     goto force_diskless_dec;
<   } else {
---
>   return (0);
> }
> }
> #line 1149 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static void abw_start_sync(struct drbd_conf *mdev , int rv ) 
> { 
>   union drbd_state val ;
>   union drbd_state mask ;
>   union drbd_state val___0 ;
>   union drbd_state mask___0 ;
57042,57044c62601,62605
<   }
< #line 1150
<   if (((int )mdev->state.ldv_40583.conn <= 9 && (unsigned int )*((unsigned char *)mdev + 2276UL) == 1U) && ((mdev->ed_uuid ^ nbc->md.uuid[0]) & 0xfffffffffffffffeULL) != 0ULL) {
---
>   {
> #line 1151
>   if (rv != 0) {
> #line 1152
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Writing the bitmap failed not starting resync.\n");
57046,57051c62607,62617
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Can only attach to data with current UUID=%016llX\n",
<             mdev->ed_uuid);
< #line 1155
<     retcode = ERR_DATA_NOT_CURRENT;
< #line 1156
<     goto force_diskless_dec;
---
>     val.i = 0U;
> #line 1153
>     val.ldv_40604.conn = 10U;
> #line 1153
>     mask.i = 0U;
> #line 1153
>     mask.ldv_40604.conn = 31U;
> #line 1153
>     _drbd_request_state(mdev, mask, val, CS_VERBOSE);
> #line 1154
>     return;
57054a62621,62633
> #line 1157
>   switch ((int )mdev->state.ldv_50103.conn) {
>   case 12: 
> #line 1159
>   val___0.i = 0U;
> #line 1159
>   val___0.ldv_40604.conn = 15U;
> #line 1159
>   mask___0.i = 0U;
> #line 1159
>   mask___0.ldv_40604.conn = 31U;
> #line 1159
>   _drbd_request_state(mdev, mask___0, val___0, CS_VERBOSE);
57056,57060c62635,62636
<   tmp___24 = drbd_check_al_size(mdev);
< #line 1160
<   if (tmp___24 != 0) {
< #line 1161
<     retcode = ERR_NOMEM;
---
>   goto ldv_52147;
>   case 11: 
57062,57064c62638,62640
<     goto force_diskless_dec;
<   } else {
< 
---
>   drbd_start_resync(mdev, C_SYNC_SOURCE);
> #line 1163
>   goto ldv_52147;
57065a62642
>   ldv_52147: ;
57067,57083c62644,62652
<   tmp___25 = drbd_md_test_flag(nbc, 1);
< #line 1166
<   if (tmp___25 != 0) {
< #line 1166
<     tmp___26 = drbd_new_dev_size(mdev, nbc, 0);
< #line 1166
<     if ((unsigned long long )tmp___26 < nbc->md.la_size_sect) {
< #line 1168
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "refusing to truncate a consistent device\n");
< #line 1169
<       retcode = ERR_DISK_TOO_SMALL;
< #line 1170
<       goto force_diskless_dec;
<     } else {
< 
<     }
<   } else {
---
>   return;
> }
> }
> #line 1167 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> int drbd_bitmap_io_from_worker(struct drbd_conf *mdev , int (*io_fn)(struct drbd_conf * ) ,
>                                char *why , enum bm_flag flags ) 
> { 
>   int rv ;
>   struct task_struct *tmp ;
57085c62654
<   }
---
>   {
57087c62656
<   tmp___27 = drbd_al_read_log(mdev, nbc);
---
>   tmp = get_current();
57089,57093c62658,62662
<   if (tmp___27 == 0) {
< #line 1174
<     retcode = ERR_IO_MD_DISK;
< #line 1175
<     goto force_diskless_dec;
---
>   if ((unsigned long )tmp != (unsigned long )(mdev->tconn)->worker.task) {
> #line 1173
>     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( current == mdev->tconn->worker.task ) in %s:%d\n",
>             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared",
>             1173);
57096a62666,62671
> #line 1176
>   set_bit(8U, (unsigned long volatile   *)(& mdev->flags));
> #line 1178
>   drbd_bm_lock(mdev, why, flags);
> #line 1179
>   rv = (*io_fn)(mdev);
57098,57111c62673,62715
<   if ((unsigned int )*((unsigned char *)nbc + 444UL) != 0U) {
< #line 1181
<     drbd_set_flag(mdev, MD_NO_FUA);
<   } else {
< #line 1183
<     drbd_clear_flag(mdev, MD_NO_FUA);
<   }
< #line 1189
<   if ((unsigned long )mdev->ldev != (unsigned long )((struct drbd_backing_dev *)0)) {
< #line 1189
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT( mdev->ldev == NULL ) in %s:%d\n",
<             (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
<             1189);
<   } else {
---
>   drbd_bm_unlock(mdev);
> #line 1182
>   drbd_resume_io(mdev);
> #line 1184
>   return (rv);
> }
> }
> #line 1194 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static void after_state_ch(struct drbd_conf *mdev , union drbd_state os , union drbd_state ns ,
>                            enum chg_state_flags flags ) 
> { 
>   struct sib_info sib ;
>   struct drbd_tconn *tconn ;
>   enum drbd_req_event what ;
>   enum drbd_conns tmp ;
>   enum drbd_disk_state tmp___0 ;
>   union drbd_state __constr_expr_0 ;
>   union drbd_state __constr_expr_1 ;
>   struct drbd_tconn *tconn___0 ;
>   struct drbd_conf *odev ;
>   int vnr ;
>   void *tmp___1 ;
>   void *tmp___2 ;
>   union drbd_state __constr_expr_2 ;
>   union drbd_state __constr_expr_3 ;
>   enum drbd_conns tmp___3 ;
>   int tmp___4 ;
>   int tmp___5 ;
>   int tmp___6 ;
>   int tmp___7 ;
>   int tmp___8 ;
>   enum drbd_io_error_p eh ;
>   int was_io_error ;
>   struct disk_conf *_________p1 ;
>   bool __warned ;
>   int tmp___9 ;
>   int tmp___10 ;
>   int tmp___11 ;
>   char const   *tmp___12 ;
>   char const   *tmp___13 ;
>   int tmp___14 ;
>   bool tmp___15 ;
>   int tmp___16 ;
57113,57129c62717
<   }
< #line 1190
<   mdev->ldev = nbc;
< #line 1191
<   mdev->resync = resync_lru;
< #line 1192
<   nbc = 0;
< #line 1193
<   resync_lru = 0;
< #line 1195
<   mdev->write_ordering = WO_bdev_flush;
< #line 1196
<   drbd_bump_write_ordering(mdev, WO_bdev_flush);
< #line 1198
<   tmp___28 = drbd_md_test_flag(mdev->ldev, 64);
< #line 1198
<   if (tmp___28 != 0) {
---
>   {
57131,57132c62719,62721
<     drbd_set_flag(mdev, CRASHED_PRIMARY);
<   } else {
---
>   sib.sib_reason = SIB_STATE_CHANGE;
> #line 1200
>   sib.ldv_51335.ldv_51334.os = os;
57134,57135c62723
<     drbd_clear_flag(mdev, CRASHED_PRIMARY);
<   }
---
>   sib.ldv_51335.ldv_51334.ns = ns;
57137,57139c62725,62727
<   tmp___29 = drbd_md_test_flag(mdev->ldev, 2);
< #line 1203
<   if (tmp___29 != 0 && ((unsigned int )*((unsigned char *)mdev + 2276UL) != 1U || (unsigned int )*((unsigned char *)mdev + 2278UL) == 0U)) {
---
>   if ((unsigned int )*((unsigned short *)(& os) + 0UL) != 160U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 160U) {
> #line 1204
>     clear_bit(5, (unsigned long volatile   *)(& mdev->flags));
57141c62729
<     drbd_set_flag(mdev, CRASHED_PRIMARY);
---
>     if ((unsigned long )mdev->p_uuid != (unsigned long )((u64 *)0)) {
57143c62731,62734
<     cp_discovered = 1;
---
>       *(mdev->p_uuid + 5UL) = *(mdev->p_uuid + 5UL) & 0xfffffffffffffffdULL;
>     } else {
> 
>     }
57147,57148d62737
< #line 1209
<   mdev->send_cnt = 0U;
57150,57152c62739
<   mdev->recv_cnt = 0U;
< #line 1211
<   mdev->read_cnt = 0U;
---
>   drbd_bcast_event(mdev, (struct sib_info  const  *)(& sib));
57154c62741
<   mdev->writ_cnt = 0U;
---
>   if ((((unsigned int )*((unsigned char *)(& os) + 0UL) != 1U || (int )os.ldv_40604.disk > 7) || (int )os.ldv_40604.pdsk > 7) && (((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U && (int )ns.ldv_40604.disk <= 7) && (int )ns.ldv_40604.pdsk <= 7)) {
57156,57170c62743,62762
<   drbd_reconsider_max_bio_size(mdev);
< #line 1230
<   drbd_clear_flag(mdev, USE_DEGR_WFC_T);
< #line 1231
<   if ((unsigned int )*((unsigned char *)mdev + 2276UL) != 1U) {
< #line 1231
<     tmp___30 = drbd_md_test_flag(mdev->ldev, 2);
< #line 1231
<     if (tmp___30 != 0) {
< #line 1231
<       tmp___31 = drbd_md_test_flag(mdev->ldev, 4);
< #line 1231
<       if (tmp___31 == 0) {
< #line 1234
<         drbd_set_flag(mdev, USE_DEGR_WFC_T);
---
>     drbd_khelper(mdev, (char *)"pri-on-incon-degr");
>   } else {
> 
>   }
> #line 1219
>   if ((unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U) {
> #line 1220
>     tconn = mdev->tconn;
> #line 1221
>     what = NOTHING;
> #line 1223
>     spin_lock_irq(& tconn->req_lock);
> #line 1224
>     if ((int )os.ldv_40604.conn <= 9) {
> #line 1224
>       tmp = conn_lowest_conn(tconn);
> #line 1224
>       if ((unsigned int )tmp > 9U) {
> #line 1225
>         what = RESEND;
57177c62769,62777
<   } else {
---
> #line 1227
>     if ((unsigned int )*((unsigned char *)(& os) + 1UL) == 2U || (unsigned int )*((unsigned char *)(& os) + 1UL) == 6U) {
> #line 1227
>       tmp___0 = conn_lowest_disk(tconn);
> #line 1227
>       if ((unsigned int )tmp___0 > 3U) {
> #line 1229
>         what = RESTART_FROZEN_DISK_IO;
>       } else {
57179,57193c62779,62780
<   }
< #line 1236
<   dd = drbd_determine_dev_size(mdev, 0);
< #line 1237
<   if ((int )dd == -1) {
< #line 1238
<     retcode = ERR_NOMEM_BITMAP;
< #line 1239
<     goto force_diskless_dec;
<   } else
< #line 1240
<   if ((int )dd == 2) {
< #line 1241
<     drbd_set_flag(mdev, RESYNC_AFTER_NEG);
<   } else {
---
>       }
>     } else {
57195,57210c62782,62836
<   }
< #line 1243
<   tmp___34 = drbd_md_test_flag(mdev->ldev, 8);
< #line 1243
<   if (tmp___34 != 0) {
< #line 1244
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Assuming that all blocks are out of sync (aka FullSync)\n");
< #line 1246
<     tmp___32 = drbd_bitmap_io(mdev, & drbd_bmio_set_n_write, (char *)"set_n_write from attaching",
<                               BM_LOCKED_MASK);
< #line 1246
<     if (tmp___32 != 0) {
< #line 1248
<       retcode = ERR_IO_MD_DISK;
< #line 1249
<       goto force_diskless_dec;
---
>     }
> #line 1231
>     if ((unsigned int )*((unsigned char *)tconn + 132UL) != 0U && (unsigned int )what != 28U) {
> #line 1232
>       _tl_restart(tconn, what);
> #line 1233
>       __constr_expr_0.ldv_40604.role = (unsigned char)0;
> #line 1233
>       __constr_expr_0.ldv_40604.peer = (unsigned char)0;
> #line 1233
>       __constr_expr_0.ldv_40604.conn = (unsigned char)0;
> #line 1233
>       __constr_expr_0.ldv_40604.disk = (unsigned char)0;
> #line 1233
>       __constr_expr_0.ldv_40604.pdsk = (unsigned char)0;
> #line 1233
>       __constr_expr_0.ldv_40604.susp = (unsigned char)0;
> #line 1233
>       __constr_expr_0.ldv_40604.aftr_isp = (unsigned char)0;
> #line 1233
>       __constr_expr_0.ldv_40604.peer_isp = (unsigned char)0;
> #line 1233
>       __constr_expr_0.ldv_40604.user_isp = (unsigned char)0;
> #line 1233
>       __constr_expr_0.ldv_40604.susp_nod = 0U;
> #line 1233
>       __constr_expr_0.ldv_40604.susp_fen = (unsigned char)0;
> #line 1233
>       __constr_expr_0.ldv_40604._pad = (unsigned short)0;
> #line 1233
>       __constr_expr_1.ldv_40604.role = (unsigned char)0;
> #line 1233
>       __constr_expr_1.ldv_40604.peer = (unsigned char)0;
> #line 1233
>       __constr_expr_1.ldv_40604.conn = (unsigned char)0;
> #line 1233
>       __constr_expr_1.ldv_40604.disk = (unsigned char)0;
> #line 1233
>       __constr_expr_1.ldv_40604.pdsk = (unsigned char)0;
> #line 1233
>       __constr_expr_1.ldv_40604.susp = (unsigned char)0;
> #line 1233
>       __constr_expr_1.ldv_40604.aftr_isp = (unsigned char)0;
> #line 1233
>       __constr_expr_1.ldv_40604.peer_isp = (unsigned char)0;
> #line 1233
>       __constr_expr_1.ldv_40604.user_isp = (unsigned char)0;
> #line 1233
>       __constr_expr_1.ldv_40604.susp_nod = 1U;
> #line 1233
>       __constr_expr_1.ldv_40604.susp_fen = (unsigned char)0;
> #line 1233
>       __constr_expr_1.ldv_40604._pad = (unsigned short)0;
> #line 1233
>       _conn_request_state(tconn, __constr_expr_1, __constr_expr_0, CS_VERBOSE);
57213a62840,62841
> #line 1238
>     spin_unlock_irq(& tconn->req_lock);
57214a62843,62867
> 
>   }
> #line 1241
>   if ((unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U) {
> #line 1242
>     tconn___0 = mdev->tconn;
> #line 1244
>     spin_lock_irq(& tconn___0->req_lock);
> #line 1245
>     if ((unsigned int )*((unsigned char *)tconn___0 + 132UL) != 0U) {
> #line 1245
>       tmp___3 = conn_lowest_conn(tconn___0);
> #line 1245
>       if ((unsigned int )tmp___3 > 9U) {
> #line 1250
>         rcu_read_lock();
> #line 1251
>         vnr = 0;
> #line 1251
>         tmp___1 = idr_get_next(& tconn___0->volumes, & vnr);
> #line 1251
>         odev = (struct drbd_conf *)tmp___1;
> #line 1251
>         goto ldv_52172;
>         ldv_52171: 
57216,57217c62869,62878
<     tmp___33 = drbd_bitmap_io(mdev, & drbd_bm_read, (char *)"read from attaching",
<                               BM_LOCKED_MASK);
---
>         clear_bit(17, (unsigned long volatile   *)(& odev->flags));
> #line 1251
>         vnr = vnr + 1;
> #line 1251
>         tmp___2 = idr_get_next(& tconn___0->volumes, & vnr);
> #line 1251
>         odev = (struct drbd_conf *)tmp___2;
>         ldv_52172: ;
> #line 1251
>         if ((unsigned long )odev != (unsigned long )((struct drbd_conf *)0)) {
57219c62880,62885
<     if (tmp___33 < 0) {
---
>           goto ldv_52171;
>         } else {
> 
>         }
> #line 1253
>         rcu_read_unlock();
57221c62887
<       retcode = ERR_IO_MD_DISK;
---
>         _tl_restart(tconn___0, RESEND);
57223,57224c62889,62938
<       goto force_diskless_dec;
<     } else {
---
>         __constr_expr_2.ldv_40604.role = (unsigned char)0;
> #line 1255
>         __constr_expr_2.ldv_40604.peer = (unsigned char)0;
> #line 1255
>         __constr_expr_2.ldv_40604.conn = (unsigned char)0;
> #line 1255
>         __constr_expr_2.ldv_40604.disk = (unsigned char)0;
> #line 1255
>         __constr_expr_2.ldv_40604.pdsk = (unsigned char)0;
> #line 1255
>         __constr_expr_2.ldv_40604.susp = (unsigned char)0;
> #line 1255
>         __constr_expr_2.ldv_40604.aftr_isp = (unsigned char)0;
> #line 1255
>         __constr_expr_2.ldv_40604.peer_isp = (unsigned char)0;
> #line 1255
>         __constr_expr_2.ldv_40604.user_isp = (unsigned char)0;
> #line 1255
>         __constr_expr_2.ldv_40604.susp_nod = (unsigned char)0;
> #line 1255
>         __constr_expr_2.ldv_40604.susp_fen = 0U;
> #line 1255
>         __constr_expr_2.ldv_40604._pad = (unsigned short)0;
> #line 1255
>         __constr_expr_3.ldv_40604.role = (unsigned char)0;
> #line 1255
>         __constr_expr_3.ldv_40604.peer = (unsigned char)0;
> #line 1255
>         __constr_expr_3.ldv_40604.conn = (unsigned char)0;
> #line 1255
>         __constr_expr_3.ldv_40604.disk = (unsigned char)0;
> #line 1255
>         __constr_expr_3.ldv_40604.pdsk = (unsigned char)0;
> #line 1255
>         __constr_expr_3.ldv_40604.susp = (unsigned char)0;
> #line 1255
>         __constr_expr_3.ldv_40604.aftr_isp = (unsigned char)0;
> #line 1255
>         __constr_expr_3.ldv_40604.peer_isp = (unsigned char)0;
> #line 1255
>         __constr_expr_3.ldv_40604.user_isp = (unsigned char)0;
> #line 1255
>         __constr_expr_3.ldv_40604.susp_nod = (unsigned char)0;
> #line 1255
>         __constr_expr_3.ldv_40604.susp_fen = 1U;
> #line 1255
>         __constr_expr_3.ldv_40604._pad = (unsigned short)0;
> #line 1255
>         _conn_request_state(tconn___0, __constr_expr_3, __constr_expr_2, CS_VERBOSE);
>       } else {
57226,57240c62940
<     }
<   }
< #line 1259
<   if (cp_discovered != 0) {
< #line 1260
<     drbd_al_apply_to_bm(mdev);
< #line 1261
<     tmp___35 = drbd_bitmap_io(mdev, & drbd_bm_write, (char *)"crashed primary apply AL",
<                               BM_LOCKED_MASK);
< #line 1261
<     if (tmp___35 != 0) {
< #line 1263
<       retcode = ERR_IO_MD_DISK;
< #line 1264
<       goto force_diskless_dec;
---
>       }
57243a62944,62945
> #line 1260
>     spin_unlock_irq(& tconn___0->req_lock);
57247,57254c62949,62961
< #line 1268
<   tmp___36 = _drbd_bm_total_weight(mdev);
< #line 1268
<   tmp___37 = drbd_bm_bits(mdev);
< #line 1268
<   if (tmp___36 == tmp___37) {
< #line 1269
<     drbd_suspend_al(mdev);
---
> #line 1267
>   if ((((unsigned int )*((unsigned short *)(& os) + 0UL) != 256U && (unsigned int )*((unsigned short *)(& os) + 0UL) != 320U) && ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 256U || (unsigned int )*((unsigned short *)(& ns) + 0UL) == 320U)) && (mdev->tconn)->agreed_pro_version > 95) {
> #line 1267
>     tmp___4 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1267
>     if (tmp___4 != 0) {
> #line 1270
>       drbd_gen_and_send_sync_uuid(mdev);
> #line 1271
>       put_ldev(mdev);
>     } else {
> 
>     }
57258,57265c62965,62966
< #line 1271
<   spin_lock_irq(& mdev->req_lock);
< #line 1272
<   os = mdev->state;
< #line 1273
<   ns.i = os.i;
< #line 1279
<   tmp___39 = drbd_md_test_flag(mdev->ldev, 1);
---
> #line 1275
>   if ((*((unsigned int *)(& os) + 0UL) == 0U && (int )ns.ldv_40604.pdsk > 0) && *((unsigned int *)(& ns) + 0UL) != 49152U) {
57267,57269c62968
<   if (tmp___39 != 0) {
< #line 1280
<     tmp___38 = drbd_md_test_flag(mdev->ldev, 16);
---
>     mdev->rs_total = 0UL;
57271c62970
<     if (tmp___38 != 0) {
---
>     mdev->rs_failed = 0UL;
57273,57278c62972,62976
<       ns.ldv_40583.disk = 7U;
<     } else {
< #line 1283
<       ns.ldv_40583.disk = 5U;
<     }
<   } else {
---
>     atomic_set(& mdev->rs_pending_cnt, 0);
> #line 1282
>     drbd_rs_cancel_all(mdev);
> #line 1284
>     drbd_send_uuids(mdev);
57280,57287c62978
<     ns.ldv_40583.disk = 4U;
<   }
< #line 1288
<   tmp___40 = drbd_md_test_flag(mdev->ldev, 32);
< #line 1288
<   if (tmp___40 != 0) {
< #line 1289
<     ns.ldv_40583.pdsk = 5U;
---
>     drbd_send_state(mdev, ns);
57291,57294c62982,62986
< #line 1291
<   if ((unsigned int )*((unsigned char *)(& ns) + 1UL) == 14U && (*((unsigned int *)(& ns) + 0UL) == 40960U || (mdev->ldev)->dc.fencing == 0)) {
< #line 1293
<     ns.ldv_40583.disk = 8U;
---
> #line 1290
>   if (((unsigned int )*((unsigned short *)(& os) + 0UL) != 208U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 208U) && (unsigned int )*((unsigned short *)mdev + 374UL) == 208U) {
> #line 1292
>     drbd_queue_bitmap_io(mdev, & drbd_send_bitmap, 0, (char *)"send_bitmap (WFBitMapS)",
>                          BM_LOCKED_TEST_ALLOWED);
57298,57299c62990,62991
< #line 1302
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 160U) {
---
> #line 1297
>   if ((((int )os.ldv_40604.pdsk > 3 && *((unsigned int *)(& os) + 0UL) != 49152U) && *((unsigned int *)(& os) + 0UL) != 40960U) && (((int )ns.ldv_40604.pdsk <= 3 || *((unsigned int *)(& ns) + 0UL) == 49152U) || *((unsigned int *)(& ns) + 0UL) == 40960U)) {
57301c62993,62995
<     mdev->new_state_tmp.i = ns.i;
---
>     tmp___6 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1303
>     if (tmp___6 != 0) {
57303,57305c62997,63006
<     ns.i = os.i;
< #line 1305
<     ns.ldv_40583.disk = 3U;
---
>       if ((((unsigned int )*((unsigned char *)(& ns) + 0UL) == 1U || (unsigned int )*((unsigned char *)(& ns) + 0UL) == 4U) && (mdev->ldev)->md.uuid[1] == 0ULL) && (int )ns.ldv_40604.disk > 7) {
> #line 1306
>         tmp___5 = drbd_suspended(mdev);
> #line 1306
>         if (tmp___5 != 0) {
> #line 1307
>           set_bit(17U, (unsigned long volatile   *)(& mdev->flags));
>         } else {
> #line 1309
>           drbd_uuid_new_current(mdev);
57307,57310c63008,63010
<     kfree((void const   *)mdev->p_uuid);
< #line 1311
<     mdev->p_uuid = 0;
<   } else {
---
>           drbd_send_uuids(mdev);
>         }
>       } else {
57312,57322c63012,63017
<   }
< #line 1314
<   rv = _drbd_set_state(mdev, ns, CS_VERBOSE, 0);
< #line 1315
<   ns = mdev->state;
< #line 1316
<   spin_unlock_irq(& mdev->req_lock);
< #line 1318
<   if ((int )rv <= 0) {
< #line 1319
<     goto force_diskless_dec;
---
>       }
> #line 1313
>       put_ldev(mdev);
>     } else {
> 
>     }
57325a63021,63030
> #line 1317
>   if ((int )ns.ldv_40604.pdsk <= 3) {
> #line 1317
>     tmp___7 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1317
>     if (tmp___7 != 0) {
> #line 1318
>       if ((((unsigned int )*((unsigned char *)(& os) + 0UL) == 8U && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 4U) && (mdev->ldev)->md.uuid[1] == 0ULL) && (int )ns.ldv_40604.disk > 7) {
> #line 1320
>         drbd_uuid_new_current(mdev);
57327,57330c63032,63035
<   if ((unsigned int )*((unsigned char *)mdev + 2276UL) == 1U) {
< #line 1322
<     (mdev->ldev)->md.uuid[0] = (mdev->ldev)->md.uuid[0] | 1ULL;
<   } else {
---
>         drbd_send_uuids(mdev);
>       } else {
> 
>       }
57332,57339c63037,63043
<     (mdev->ldev)->md.uuid[0] = (mdev->ldev)->md.uuid[0] & 0xfffffffffffffffeULL;
<   }
< #line 1326
<   drbd_md_mark_dirty(mdev);
< #line 1327
<   drbd_md_sync(mdev);
< #line 1329
<   kobject_uevent(& (mdev->vdisk)->part0.__dev.kobj, KOBJ_CHANGE);
---
>       if ((unsigned int )*((unsigned char *)(& os) + 0UL) == 4U && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 8U) {
> #line 1328
>         drbd_bitmap_io_from_worker(mdev, & drbd_bm_write, (char *)"demote diskless peer",
>                                    BM_LOCKED_SET_ALLOWED);
>       } else {
> 
>       }
57341,57370c63045
<   put_ldev(mdev);
< #line 1331
<   reply->ret_code = (int )retcode;
< #line 1332
<   drbd_reconfig_done(mdev);
< #line 1333
<   return (0);
<   force_diskless_dec: 
< #line 1336
<   put_ldev(mdev);
<   force_diskless: 
< #line 1338
<   val___0.i = 0U;
< #line 1338
<   val___0.ldv_40583.disk = 2U;
< #line 1338
<   mask___0.i = 0U;
< #line 1338
<   mask___0.ldv_40583.disk = 15U;
< #line 1338
<   drbd_force_state(mdev, mask___0, val___0);
< #line 1339
<   drbd_md_sync(mdev);
<   fail: ;
< #line 1341
<   if ((unsigned long )nbc != (unsigned long )((struct drbd_backing_dev *)0)) {
< #line 1342
<     if ((unsigned long )nbc->backing_bdev != (unsigned long )((struct block_device *)0)) {
< #line 1343
<       blkdev_put(nbc->backing_bdev, 131U);
---
>       put_ldev(mdev);
57374,57377c63049,63061
< #line 1345
<     if ((unsigned long )nbc->md_bdev != (unsigned long )((struct block_device *)0)) {
< #line 1346
<       blkdev_put(nbc->md_bdev, 131U);
---
>   } else {
> 
>   }
> #line 1336
>   if (((unsigned int )*((unsigned char *)(& os) + 0UL) == 1U && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 2U) && (int )mdev->state.ldv_50103.conn <= 10) {
> #line 1336
>     tmp___8 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1336
>     if (tmp___8 != 0) {
> #line 1340
>       drbd_bitmap_io_from_worker(mdev, & drbd_bm_write, (char *)"demote", BM_LOCKED_TEST_ALLOWED);
> #line 1342
>       put_ldev(mdev);
57381,57382d63064
< #line 1348
<     kfree((void const   *)nbc);
57385a63068,63073
> #line 1346
>   if (((int )ns.ldv_40604.conn > 9 && (unsigned int )*((unsigned char *)(& os) + 1UL) == 2U) && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 6U) {
> #line 1348
>     drbd_send_sizes(mdev, 0, 0);
> #line 1349
>     drbd_send_uuids(mdev);
57387,57391c63075,63078
<   lc_destroy(resync_lru);
< #line 1352
<   reply->ret_code = (int )retcode;
< #line 1353
<   drbd_reconfig_done(mdev);
---
>     drbd_send_state(mdev, ns);
>   } else {
> 
>   }
57393,57412c63080,63083
<   return (0);
< }
< }
< #line 1362 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_detach(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp , struct drbd_nl_cfg_reply *reply ) 
< { 
<   enum drbd_ret_code retcode ;
<   int ret ;
<   struct detach dt ;
<   int tmp ;
<   union drbd_state val ;
<   union drbd_state mask ;
<   union drbd_state val___0 ;
<   union drbd_state mask___0 ;
<   int tmp___0 ;
<   int __ret ;
<   wait_queue_t __wait ;
<   struct task_struct *tmp___1 ;
<   struct task_struct *tmp___2 ;
<   int tmp___3 ;
---
>   if ((int )ns.ldv_40604.conn > 9 && ((int )os.ldv_40604.aftr_isp != (int )ns.ldv_40604.aftr_isp || (int )os.ldv_40604.user_isp != (int )ns.ldv_40604.user_isp)) {
> #line 1357
>     drbd_send_state(mdev, ns);
>   } else {
57414c63085,63094
<   {
---
>   }
> #line 1360
>   if ((((unsigned int )*((unsigned char *)(& os) + 2UL) == 0U && (unsigned int )*((unsigned char *)(& os) + 2UL) == 0U) && (unsigned int )*((unsigned char *)(& os) + 2UL) == 0U) && (((unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U || (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U) || (unsigned int )*((unsigned char *)(& ns) + 2UL) != 0U)) {
> #line 1362
>     suspend_other_sg(mdev);
>   } else {
> 
>   }
> #line 1366
>   if ((unsigned int )*((unsigned short *)(& os) + 0UL) == 144U && (int )ns.ldv_40604.conn > 9) {
57416,57418c63096,63099
<   dt.detach_force = (unsigned char)0;
< #line 1369
<   tmp = detach_from_tags(mdev, (unsigned short *)(& nlp->tag_list), & dt);
---
>     drbd_send_state(mdev, ns);
>   } else {
> 
>   }
57420c63101
<   if (tmp == 0) {
---
>   if ((unsigned int )*((unsigned short *)(& os) + 0UL) != 352U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 352U) {
57422,57424c63103
<     reply->ret_code = 126;
< #line 1371
<     goto out;
---
>     drbd_send_state(mdev, ns);
57428,57439c63107,63108
< #line 1374
<   if ((unsigned int )*((unsigned char *)(& dt) + 0UL) != 0U) {
< #line 1375
<     drbd_set_flag(mdev, FORCE_DETACH);
< #line 1376
<     val.i = 0U;
< #line 1376
<     val.ldv_40583.disk = 2U;
< #line 1376
<     mask.i = 0U;
< #line 1376
<     mask.ldv_40583.disk = 15U;
---
> #line 1373
>   if (((unsigned int )*((unsigned short *)(& os) + 0UL) != 192U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 192U) || ((unsigned int )*((unsigned short *)(& os) + 0UL) != 176U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 176U)) {
57441,57445c63110,63111
<     drbd_force_state(mdev, mask, val);
< #line 1377
<     reply->ret_code = 1;
< #line 1378
<     goto out;
---
>     drbd_queue_bitmap_io(mdev, & drbd_bmio_set_n_write, & abw_start_sync, (char *)"set_n_write from StartingSync",
>                          BM_LOCKED_TEST_ALLOWED);
57450,57464c63116
<   drbd_suspend_io(mdev);
< #line 1382
<   drbd_md_get_buffer(mdev);
< #line 1383
<   val___0.i = 0U;
< #line 1383
<   val___0.ldv_40583.disk = 2U;
< #line 1383
<   mask___0.i = 0U;
< #line 1383
<   mask___0.ldv_40583.disk = 15U;
< #line 1383
<   tmp___0 = drbd_request_state(mdev, mask___0, val___0);
< #line 1383
<   retcode = (enum drbd_ret_code )tmp___0;
---
>   if ((((int )os.ldv_40604.conn <= 9 && (int )ns.ldv_40604.conn <= 9) && (int )os.ldv_40604.disk > 4) && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 8U) {
57466,57515c63118,63119
<   drbd_md_put_buffer(mdev);
< #line 1386
<   __ret = 0;
< #line 1386
<   if ((unsigned int )*((unsigned char *)mdev + 2277UL) == 4U) {
< #line 1386
<     tmp___1 = get_current();
< #line 1386
<     __wait.flags = 0U;
< #line 1386
<     __wait.private = (void *)tmp___1;
< #line 1386
<     __wait.func = & autoremove_wake_function;
< #line 1386
<     __wait.task_list.next = & __wait.task_list;
< #line 1386
<     __wait.task_list.prev = & __wait.task_list;
<     ldv_54271: 
< #line 1386
<     prepare_to_wait(& mdev->misc_wait, & __wait, 1);
< #line 1386
<     if ((unsigned int )*((unsigned char *)mdev + 2277UL) != 4U) {
< #line 1386
<       goto ldv_54269;
<     } else {
< 
<     }
< #line 1386
<     tmp___2 = get_current();
< #line 1386
<     tmp___3 = signal_pending(tmp___2);
< #line 1386
<     if (tmp___3 == 0) {
< #line 1386
<       schedule();
< #line 1386
<       goto ldv_54270;
<     } else {
< 
<     }
< #line 1386
<     __ret = -512;
< #line 1386
<     goto ldv_54269;
<     ldv_54270: ;
< #line 1386
<     goto ldv_54271;
<     ldv_54269: 
< #line 1386
<     finish_wait(& mdev->misc_wait, & __wait);
---
>     drbd_queue_bitmap_io(mdev, & drbd_bmio_set_n_write, 0, (char *)"set_n_write from invalidate",
>                          BM_LOCKED_MASK);
57519,57522c63123,63124
< #line 1386
<   ret = __ret;
< #line 1388
<   drbd_resume_io(mdev);
---
> #line 1389
>   if ((unsigned int )*((unsigned char *)(& os) + 1UL) != 4U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 4U) {
57524c63126
<   if ((long )retcode == 4294967285L) {
---
>     eh = EP_PASS_ON;
57526,57539c63128
<     retcode = 2;
<   } else {
< 
<   }
< #line 1392
<   if (ret != 0) {
< #line 1393
<     retcode = ERR_INTR;
<   } else {
< 
<   }
< #line 1394
<   reply->ret_code = (int )retcode;
<   out: ;
---
>     was_io_error = 0;
57541,57584c63130,63148
<   return (0);
< }
< }
< #line 1399 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_net_conf(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                             struct drbd_nl_cfg_reply *reply ) 
< { 
<   int i ;
<   int ns ;
<   enum drbd_ret_code retcode ;
<   struct net_conf *new_conf ;
<   struct crypto_hash *tfm ;
<   struct crypto_hash *integrity_w_tfm ;
<   struct crypto_hash *integrity_r_tfm ;
<   struct hlist_head *new_tl_hash ;
<   struct hlist_head *new_ee_hash ;
<   struct drbd_conf *odev ;
<   char hmac_name[64U] ;
<   void *int_dig_out ;
<   void *int_dig_in ;
<   void *int_dig_vv ;
<   struct sockaddr *new_my_addr ;
<   struct sockaddr *new_peer_addr ;
<   struct sockaddr *taken_addr ;
<   void *tmp ;
<   int tmp___0 ;
<   enum drbd_fencing_p fp ;
<   int tmp___1 ;
<   int tmp___2 ;
<   int tmp___3 ;
<   int tmp___4 ;
<   long tmp___5 ;
<   struct crypto_tfm *tmp___6 ;
<   int tmp___7 ;
<   long tmp___8 ;
<   struct crypto_tfm *tmp___9 ;
<   int tmp___10 ;
<   long tmp___11 ;
<   void *tmp___12 ;
<   void *tmp___13 ;
<   unsigned int tmp___14 ;
<   int tmp___15 ;
<   union drbd_state __ns ;
<   enum drbd_state_rv tmp___16 ;
---
>     if ((unsigned long )mdev->ldev != (unsigned long )((struct drbd_backing_dev *)0)) {
> #line 1397
>       rcu_read_lock();
> #line 1398
>       _________p1 = *((struct disk_conf * volatile  *)(& (mdev->ldev)->disk_conf));
> #line 1398
>       tmp___9 = debug_lockdep_rcu_enabled();
> #line 1398
>       if (tmp___9 != 0 && ! __warned) {
> #line 1398
>         tmp___10 = rcu_read_lock_held();
> #line 1398
>         if (tmp___10 == 0 && 1) {
> #line 1398
>           __warned = 1;
> #line 1398
>           lockdep_rcu_suspicious("/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared",
>                                  1398, "suspicious rcu_dereference_check() usage");
>         } else {
57586c63150,63161
<   {
---
>         }
>       } else {
> 
>       }
> #line 1398
>       eh = (enum drbd_io_error_p )_________p1->on_io_error;
> #line 1399
>       rcu_read_unlock();
> #line 1401
>       was_io_error = test_and_clear_bit(12, (unsigned long volatile   *)(& mdev->flags));
> #line 1403
>       if (was_io_error != 0 && (unsigned int )eh == 1U) {
57588,57606c63163,63168
<   new_conf = 0;
< #line 1405
<   tfm = 0;
< #line 1406
<   integrity_w_tfm = 0;
< #line 1407
<   integrity_r_tfm = 0;
< #line 1408
<   new_tl_hash = 0;
< #line 1409
<   new_ee_hash = 0;
< #line 1412
<   int_dig_out = 0;
< #line 1413
<   int_dig_in = 0;
< #line 1414
<   int_dig_vv = 0;
< #line 1417
<   drbd_reconfig_start(mdev);
---
>         drbd_khelper(mdev, (char *)"local-io-error");
>       } else {
> 
>       }
> #line 1419
>       tmp___11 = test_and_clear_bit(14, (unsigned long volatile   *)(& mdev->flags));
57608c63170
<   if ((int )mdev->state.ldv_40583.conn > 0) {
---
>       if (tmp___11 != 0) {
57610,57613c63172,63173
<     retcode = ERR_NET_CONFIGURED;
< #line 1421
<     goto fail;
<   } else {
---
>         tl_abort_disk_io(mdev);
>       } else {
57615,57617c63175
<   }
< #line 1425
<   tmp = kzalloc(544UL, 208U);
---
>       }
57619c63177
<   new_conf = (struct net_conf *)tmp;
---
>       if ((unsigned int )*((unsigned char *)mdev + 749UL) != 4U) {
57621,57626c63179,63183
<   if ((unsigned long )new_conf == (unsigned long )((struct net_conf *)0)) {
< #line 1427
<     retcode = ERR_NOMEM;
< #line 1428
<     goto fail;
<   } else {
---
>         tmp___12 = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_50103.disk);
> #line 1426
>         dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: disk is %s during detach\n",
>                 tmp___12);
>       } else {
57628c63185,63187
<   }
---
>       }
> #line 1430
>       if ((int )ns.ldv_40604.conn > 9) {
57630,57632c63189,63192
<   new_conf->timeout = 60;
< #line 1432
<   new_conf->try_connect_int = 10;
---
>         drbd_send_state(mdev, ns);
>       } else {
> 
>       }
57634,57642c63194
<   new_conf->ping_int = 10;
< #line 1434
<   new_conf->max_epoch_size = 2048;
< #line 1435
<   new_conf->max_buffers = 2048;
< #line 1436
<   new_conf->unplug_watermark = 128;
< #line 1437
<   new_conf->sndbuf_size = 0;
---
>       drbd_rs_cancel_all(mdev);
57644,57646c63196,63199
<   new_conf->rcvbuf_size = 0;
< #line 1439
<   new_conf->ko_count = 0;
---
>       drbd_md_sync(mdev);
>     } else {
> 
>     }
57648,57674c63201
<   new_conf->after_sb_0p = 0;
< #line 1441
<   new_conf->after_sb_1p = 0;
< #line 1442
<   new_conf->after_sb_2p = 0;
< #line 1443
<   new_conf->want_lose = 0U;
< #line 1444
<   new_conf->two_primaries = 0U;
< #line 1445
<   new_conf->wire_protocol = 3;
< #line 1446
<   new_conf->ping_timeo = 5;
< #line 1447
<   new_conf->rr_conflict = 0;
< #line 1448
<   new_conf->on_congestion = 0;
< #line 1449
<   new_conf->cong_extents = 127;
< #line 1451
<   tmp___0 = net_conf_from_tags(mdev, (unsigned short *)(& nlp->tag_list), new_conf);
< #line 1451
<   if (tmp___0 == 0) {
< #line 1452
<     retcode = ERR_MANDATORY_TAG;
< #line 1453
<     goto fail;
---
>     put_ldev(mdev);
57678,57679c63205,63223
< #line 1456
<   if ((unsigned int )*((unsigned char *)new_conf + 540UL) != 0U && new_conf->wire_protocol != 3) {
---
> #line 1446
>   if ((unsigned int )*((unsigned char *)(& os) + 1UL) != 0U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 0U) {
> #line 1449
>     if ((unsigned int )*((unsigned char *)mdev + 749UL) != 0U) {
> #line 1450
>       tmp___13 = drbd_disk_str((enum drbd_disk_state )mdev->state.ldv_50103.disk);
> #line 1450
>       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: disk is %s while going diskless\n",
>               tmp___13);
>     } else {
> 
>     }
> #line 1454
>     if ((int )ns.ldv_40604.conn > 9) {
> #line 1455
>       drbd_send_state(mdev, ns);
>     } else {
> 
>     }
57681,57683c63225
<     retcode = ERR_NOT_PROTO_C;
< #line 1459
<     goto fail;
---
>     put_ldev(mdev);
57688,57690c63230
<   tmp___1 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1462
<   if (tmp___1 != 0) {
---
>   if (((unsigned int )*((unsigned char *)(& os) + 1UL) == 16U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 8U) && (int )ns.ldv_40604.conn > 9) {
57692,57696c63232,63235
<     fp = (enum drbd_fencing_p )(mdev->ldev)->dc.fencing;
< #line 1464
<     put_ldev(mdev);
< #line 1465
<     if (new_conf->wire_protocol == 1 && (unsigned int )fp == 2U) {
---
>     drbd_send_state(mdev, ns);
>   } else {
> 
>   }
57698,57700c63237,63248
<       retcode = ERR_STONITH_AND_PROT_A;
< #line 1467
<       goto fail;
---
>   if ((int )ns.ldv_40604.disk > 3 && (int )ns.ldv_40604.pdsk > 3) {
> #line 1466
>     tmp___14 = test_and_clear_bit(15, (unsigned long volatile   *)(& mdev->flags));
> #line 1466
>     if (tmp___14 != 0) {
> #line 1468
>       if ((unsigned int )*((unsigned short *)(& ns) + 0UL) == 160U) {
> #line 1469
>         resync_after_online_grow(mdev);
>       } else {
> 
>       }
57707,57710d63254
< #line 1471
<   if (new_conf->on_congestion != 0 && new_conf->wire_protocol != 1) {
< #line 1472
<     retcode = ERR_CONG_NOT_PROTO_A;
57712,57715c63256
<     goto fail;
<   } else {
< 
<   }
---
>   if ((((int )os.ldv_40604.conn > 10 && (int )ns.ldv_40604.conn <= 10) || ((unsigned int )*((unsigned char *)(& os) + 2UL) != 0U && (unsigned int )*((unsigned char *)(& ns) + 2UL) == 0U)) || ((unsigned int )*((unsigned char *)(& os) + 2UL) != 0U && (unsigned int )*((unsigned char *)(& ns) + 2UL) == 0U)) {
57717,57721c63258
<   if ((unsigned int )*((unsigned char *)mdev + 2276UL) == 1U && (unsigned int )*((unsigned char *)new_conf + 540UL) != 0U) {
< #line 1477
<     retcode = ERR_DISCARD;
< #line 1478
<     goto fail;
---
>     resume_next_sg(mdev);
57724a63262,63263
> #line 1480
>   if (((int )os.ldv_40604.disk <= 7 && (int )os.ldv_40604.conn > 15) && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 160U) {
57726,57741c63265
<   retcode = NO_ERROR;
< #line 1483
<   new_my_addr = (struct sockaddr *)(& new_conf->my_addr);
< #line 1484
<   new_peer_addr = (struct sockaddr *)(& new_conf->peer_addr);
< #line 1485
<   i = 0;
< #line 1485
<   goto ldv_54299;
<   ldv_54298: 
< #line 1486
<   odev = minor_to_mdev((unsigned int )i);
< #line 1487
<   if ((unsigned long )odev == (unsigned long )((struct drbd_conf *)0) || (unsigned long )odev == (unsigned long )mdev) {
< #line 1488
<     goto ldv_54297;
---
>     drbd_send_state(mdev, ns);
57745,57761c63269,63276
< #line 1489
<   tmp___4 = get_net_conf(odev);
< #line 1489
<   if (tmp___4 != 0) {
< #line 1490
<     taken_addr = (struct sockaddr *)(& (odev->net_conf)->my_addr);
< #line 1491
<     if (new_conf->my_addr_len == (odev->net_conf)->my_addr_len) {
< #line 1491
<       tmp___2 = memcmp((void const   *)new_my_addr, (void const   *)taken_addr, (size_t )new_conf->my_addr_len);
< #line 1491
<       if (tmp___2 == 0) {
< #line 1493
<         retcode = ERR_LOCAL_ADDR;
<       } else {
< 
<       }
---
> #line 1486
>   if ((unsigned int )*((unsigned short *)(& os) + 0UL) == 288U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 160U) {
> #line 1486
>     tmp___15 = verify_can_do_stop_sector(mdev);
> #line 1486
>     if ((int )tmp___15) {
> #line 1488
>       drbd_send_state(mdev, ns);
57765,57779c63280
< #line 1495
<     taken_addr = (struct sockaddr *)(& (odev->net_conf)->peer_addr);
< #line 1496
<     if (new_conf->peer_addr_len == (odev->net_conf)->peer_addr_len) {
< #line 1496
<       tmp___3 = memcmp((void const   *)new_peer_addr, (void const   *)taken_addr,
<                        (size_t )new_conf->peer_addr_len);
< #line 1496
<       if (tmp___3 == 0) {
< #line 1498
<         retcode = ERR_PEER_ADDR;
<       } else {
< 
<       }
<     } else {
---
>   } else {
57781c63282,63291
<     }
---
>   }
> #line 1497
>   if ((int )os.ldv_40604.conn > 10 && (int )ns.ldv_40604.conn <= 10) {
> #line 1497
>     tmp___16 = _get_ldev_if_state(mdev, D_INCONSISTENT);
> #line 1497
>     if (tmp___16 != 0) {
> #line 1498
>       drbd_queue_bitmap_io(mdev, & drbd_bm_write_copy_pages, 0, (char *)"write from resync_finished",
>                            BM_IS_LOCKED);
57783,57787c63293
<     put_net_conf(odev);
< #line 1501
<     if ((unsigned int )retcode != 101U) {
< #line 1502
<       goto fail;
---
>       put_ldev(mdev);
57794,57805c63300,63301
<   ldv_54297: 
< #line 1485
<   i = i + 1;
<   ldv_54299: ;
< #line 1485
<   if ((unsigned int )i < minor_count) {
< #line 1486
<     goto ldv_54298;
<   } else {
< 
<   }
< 
---
> #line 1503
>   if (((unsigned int )*((unsigned char *)(& ns) + 1UL) == 0U && (unsigned int )*((unsigned short *)(& ns) + 0UL) == 0U) && (unsigned int )*((unsigned char *)(& ns) + 0UL) == 2U) {
57807c63303
<   if ((unsigned int )new_conf->cram_hmac_alg[0] != 0U) {
---
>     if ((int )os.ldv_40604.aftr_isp != (int )ns.ldv_40604.aftr_isp) {
57809,57834c63305
<     snprintf((char *)(& hmac_name), 64UL, "hmac(%s)", (unsigned char *)(& new_conf->cram_hmac_alg));
< #line 1509
<     tfm = crypto_alloc_hash((char const   *)(& hmac_name), 0U, 128U);
< #line 1510
<     tmp___5 = IS_ERR((void const   *)tfm);
< #line 1510
<     if (tmp___5 != 0L) {
< #line 1511
<       tfm = 0;
< #line 1512
<       retcode = ERR_AUTH_ALG;
< #line 1513
<       goto fail;
<     } else {
< 
<     }
< #line 1516
<     tmp___6 = crypto_hash_tfm(tfm);
< #line 1516
<     tmp___7 = drbd_crypto_is_hash(tmp___6);
< #line 1516
<     if (tmp___7 == 0) {
< #line 1517
<       retcode = ERR_AUTH_ALG_ND;
< #line 1518
<       goto fail;
---
>       resume_next_sg(mdev);
57841,57845c63312,63335
< #line 1522
<   if ((unsigned int )new_conf->integrity_alg[0] != 0U) {
< #line 1523
<     integrity_w_tfm = crypto_alloc_hash((char const   *)(& new_conf->integrity_alg),
<                                         0U, 128U);
---
> #line 1510
>   drbd_md_sync(mdev);
> #line 1511
>   return;
> }
> }
> #line 1521 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static int w_after_conn_state_ch(struct drbd_work *w , int unused ) 
> { 
>   struct after_conn_state_chg_work *acscw ;
>   struct drbd_work  const  *__mptr ;
>   struct drbd_tconn *tconn ;
>   enum drbd_conns oc ;
>   union drbd_state ns_max ;
>   struct drbd_conf *mdev ;
>   int vnr ;
>   struct net_conf *old_conf ;
>   void *tmp ;
>   int tmp___0 ;
>   void *tmp___1 ;
>   union drbd_state __constr_expr_0 ;
>   union drbd_state __constr_expr_1 ;
> 
>   {
57847c63337
<     tmp___8 = IS_ERR((void const   *)integrity_w_tfm);
---
>   __mptr = (struct drbd_work  const  *)w;
57849c63339
<     if (tmp___8 != 0L) {
---
>   acscw = (struct after_conn_state_chg_work *)__mptr;
57851c63341
<       integrity_w_tfm = 0;
---
>   tconn = w->ldv_50388.tconn;
57853c63343
<       retcode = ERR_INTEGRITY_ALG;
---
>   oc = acscw->oc;
57855,57864c63345
<       goto fail;
<     } else {
< 
<     }
< #line 1530
<     tmp___9 = crypto_hash_tfm(integrity_w_tfm);
< #line 1530
<     tmp___10 = drbd_crypto_is_hash(tmp___9);
< #line 1530
<     if (tmp___10 == 0) {
---
>   ns_max = acscw->ns_max;
57866,57871c63347,63349
<       retcode = ERR_INTEGRITY_ALG_ND;
< #line 1532
<       goto fail;
<     } else {
< 
<     }
---
>   kfree((void const   *)acscw);
> #line 1534
>   if ((unsigned int )oc == 0U && (unsigned int )*((unsigned short *)(& ns_max) + 0UL) == 32U) {
57873,57887c63351
<     integrity_r_tfm = crypto_alloc_hash((char const   *)(& new_conf->integrity_alg),
<                                         0U, 128U);
< #line 1536
<     tmp___11 = IS_ERR((void const   *)integrity_r_tfm);
< #line 1536
<     if (tmp___11 != 0L) {
< #line 1537
<       integrity_r_tfm = 0;
< #line 1538
<       retcode = ERR_INTEGRITY_ALG;
< #line 1539
<       goto fail;
<     } else {
< 
<     }
---
>     drbd_thread_start(& tconn->receiver);
57890a63355,63362
> #line 1537
>   if ((unsigned int )oc == 1U && (unsigned int )*((unsigned short *)(& ns_max) + 0UL) == 0U) {
> #line 1540
>     mutex_lock_nested(& tconn->conf_update, 0U);
> #line 1541
>     old_conf = tconn->net_conf;
> #line 1542
>     tconn->my_addr_len = 0;
57892c63364
<   ns = new_conf->max_epoch_size / 8;
---
>     tconn->peer_addr_len = 0;
57894,57896c63366,63368
<   if (mdev->tl_hash_s != (unsigned int )ns) {
< #line 1545
<     tmp___12 = kzalloc((unsigned long )ns * 8UL, 208U);
---
>     __asm__  volatile   ("": : : "memory");
> #line 1544
>     tconn->net_conf = 0;
57898c63370
<     new_tl_hash = (struct hlist_head *)tmp___12;
---
>     conn_free_crypto(tconn);
57900,57902c63372
<     if ((unsigned long )new_tl_hash == (unsigned long )((struct hlist_head *)0)) {
< #line 1547
<       retcode = ERR_NOMEM;
---
>     mutex_unlock(& tconn->conf_update);
57904,57907c63374,63376
<       goto fail;
<     } else {
< 
<     }
---
>     synchronize_rcu();
> #line 1549
>     kfree((void const   *)old_conf);
57912,57916c63381
<   ns = new_conf->max_buffers / 8;
< #line 1553
<   if ((unsigned int )*((unsigned char *)new_conf + 540UL) != 0U && mdev->ee_hash_s != (unsigned int )ns) {
< #line 1554
<     tmp___13 = kzalloc((unsigned long )ns * 8UL, 208U);
---
>   if ((unsigned int )*((unsigned char *)(& ns_max) + 2UL) != 0U) {
57918c63383
<     new_ee_hash = (struct hlist_head *)tmp___13;
---
>     if ((int )ns_max.ldv_40604.pdsk <= 5) {
57920c63385
<     if ((unsigned long )new_ee_hash == (unsigned long )((struct hlist_head *)0)) {
---
>       rcu_read_lock();
57922c63387,63394
<       retcode = ERR_NOMEM;
---
>       vnr = 0;
> #line 1556
>       tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 1556
>       mdev = (struct drbd_conf *)tmp;
> #line 1556
>       goto ldv_52201;
>       ldv_52200: 
57924,57925c63396,63403
<       goto fail;
<     } else {
---
>       tmp___0 = constant_test_bit(17U, (unsigned long const volatile   *)(& mdev->flags));
> #line 1557
>       if (tmp___0 != 0) {
> #line 1558
>         drbd_uuid_new_current(mdev);
> #line 1559
>         clear_bit(17, (unsigned long volatile   *)(& mdev->flags));
>       } else {
57927,57928c63405,63417
<     }
<   } else {
---
>       }
> #line 1556
>       vnr = vnr + 1;
> #line 1556
>       tmp___1 = idr_get_next(& tconn->volumes, & vnr);
> #line 1556
>       mdev = (struct drbd_conf *)tmp___1;
>       ldv_52201: ;
> #line 1556
>       if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1557
>         goto ldv_52200;
>       } else {
57930,57932c63419,63421
<   }
< #line 1561
<   *((char *)(& new_conf->shared_secret) + 63UL) = 0;
---
>       }
> #line 1562
>       rcu_read_unlock();
57934c63423
<   if ((unsigned long )integrity_w_tfm != (unsigned long )((struct crypto_hash *)0)) {
---
>       spin_lock_irq(& tconn->req_lock);
57936,57938c63425
<     tmp___14 = crypto_hash_digestsize(integrity_w_tfm);
< #line 1564
<     i = (int )tmp___14;
---
>       _tl_restart(tconn, CONNECTION_LOST_WHILE_PENDING);
57940,57968c63427,63477
<     int_dig_out = kmalloc((size_t )i, 208U);
< #line 1566
<     if ((unsigned long )int_dig_out == (unsigned long )((void *)0)) {
< #line 1567
<       retcode = ERR_NOMEM;
< #line 1568
<       goto fail;
<     } else {
< 
<     }
< #line 1570
<     int_dig_in = kmalloc((size_t )i, 208U);
< #line 1571
<     if ((unsigned long )int_dig_in == (unsigned long )((void *)0)) {
< #line 1572
<       retcode = ERR_NOMEM;
< #line 1573
<       goto fail;
<     } else {
< 
<     }
< #line 1575
<     int_dig_vv = kmalloc((size_t )i, 208U);
< #line 1576
<     if ((unsigned long )int_dig_vv == (unsigned long )((void *)0)) {
< #line 1577
<       retcode = ERR_NOMEM;
< #line 1578
<       goto fail;
---
>       __constr_expr_0.ldv_40604.role = (unsigned char)0;
> #line 1565
>       __constr_expr_0.ldv_40604.peer = (unsigned char)0;
> #line 1565
>       __constr_expr_0.ldv_40604.conn = (unsigned char)0;
> #line 1565
>       __constr_expr_0.ldv_40604.disk = (unsigned char)0;
> #line 1565
>       __constr_expr_0.ldv_40604.pdsk = (unsigned char)0;
> #line 1565
>       __constr_expr_0.ldv_40604.susp = (unsigned char)0;
> #line 1565
>       __constr_expr_0.ldv_40604.aftr_isp = (unsigned char)0;
> #line 1565
>       __constr_expr_0.ldv_40604.peer_isp = (unsigned char)0;
> #line 1565
>       __constr_expr_0.ldv_40604.user_isp = (unsigned char)0;
> #line 1565
>       __constr_expr_0.ldv_40604.susp_nod = (unsigned char)0;
> #line 1565
>       __constr_expr_0.ldv_40604.susp_fen = 0U;
> #line 1565
>       __constr_expr_0.ldv_40604._pad = (unsigned short)0;
> #line 1565
>       __constr_expr_1.ldv_40604.role = (unsigned char)0;
> #line 1565
>       __constr_expr_1.ldv_40604.peer = (unsigned char)0;
> #line 1565
>       __constr_expr_1.ldv_40604.conn = (unsigned char)0;
> #line 1565
>       __constr_expr_1.ldv_40604.disk = (unsigned char)0;
> #line 1565
>       __constr_expr_1.ldv_40604.pdsk = (unsigned char)0;
> #line 1565
>       __constr_expr_1.ldv_40604.susp = (unsigned char)0;
> #line 1565
>       __constr_expr_1.ldv_40604.aftr_isp = (unsigned char)0;
> #line 1565
>       __constr_expr_1.ldv_40604.peer_isp = (unsigned char)0;
> #line 1565
>       __constr_expr_1.ldv_40604.user_isp = (unsigned char)0;
> #line 1565
>       __constr_expr_1.ldv_40604.susp_nod = (unsigned char)0;
> #line 1565
>       __constr_expr_1.ldv_40604.susp_fen = 1U;
> #line 1565
>       __constr_expr_1.ldv_40604._pad = (unsigned short)0;
> #line 1565
>       _conn_request_state(tconn, __constr_expr_1, __constr_expr_0, CS_VERBOSE);
> #line 1569
>       spin_unlock_irq(& tconn->req_lock);
57975,57978c63484,63506
< #line 1582
<   if ((unsigned long )mdev->bitmap == (unsigned long )((struct drbd_bitmap *)0)) {
< #line 1583
<     tmp___15 = drbd_bm_init(mdev);
---
> #line 1572
>   kref_put(& tconn->kref, & conn_destroy);
> #line 1574
>   conn_md_sync(tconn);
> #line 1576
>   return (0);
> }
> }
> #line 1579 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> void conn_old_common_state(struct drbd_tconn *tconn , union drbd_state *pcs , enum chg_state_flags *pf ) 
> { 
>   enum chg_state_flags flags ;
>   struct drbd_conf *mdev ;
>   int vnr ;
>   int first_vol ;
>   union drbd_dev_state os ;
>   union drbd_dev_state cs ;
>   void *tmp ;
>   void *tmp___0 ;
> 
>   {
> #line 1581
>   flags = 4294967295L;
57980c63508
<     if (tmp___15 != 0) {
---
>   first_vol = 1;
57982,57996c63510,63528
<       retcode = ERR_NOMEM;
< #line 1585
<       goto fail;
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1589
<   drbd_flush_workqueue(mdev);
< #line 1590
<   spin_lock_irq(& mdev->req_lock);
< #line 1591
<   if ((unsigned long )mdev->net_conf != (unsigned long )((struct net_conf *)0)) {
---
>   cs.ldv_50103.role = 2U;
> #line 1584
>   cs.ldv_50103.peer = 0U;
> #line 1584
>   cs.ldv_50103.conn = (unsigned char )tconn->cstate;
> #line 1584
>   cs.ldv_50103.disk = 0U;
> #line 1584
>   cs.ldv_50103.pdsk = 6U;
> #line 1584
>   cs.ldv_50103._unused = (unsigned char)0;
> #line 1584
>   cs.ldv_50103.aftr_isp = (unsigned char)0;
> #line 1584
>   cs.ldv_50103.peer_isp = (unsigned char)0;
> #line 1584
>   cs.ldv_50103.user_isp = (unsigned char)0;
> #line 1584
>   cs.ldv_50103._pad = (unsigned short)0;
57998c63530,63532
<     retcode = ERR_NET_CONFIGURED;
---
>   rcu_read_lock();
> #line 1593
>   vnr = 0;
58000c63534,63539
<     spin_unlock_irq(& mdev->req_lock);
---
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 1593
>   mdev = (struct drbd_conf *)tmp;
> #line 1593
>   goto ldv_52218;
>   ldv_52217: 
58002,58005c63541
<     goto fail;
<   } else {
< 
<   }
---
>   os = mdev->state;
58007c63543,63545
<   mdev->net_conf = new_conf;
---
>   if (first_vol != 0) {
> #line 1597
>     cs = os;
58009c63547
<   mdev->send_cnt = 0U;
---
>     first_vol = 0;
58011,58013c63549,63552
<   mdev->recv_cnt = 0U;
< #line 1601
<   if ((unsigned long )new_tl_hash != (unsigned long )((struct hlist_head *)0)) {
---
>     goto ldv_52216;
>   } else {
> 
>   }
58015c63554
<     kfree((void const   *)mdev->tl_hash);
---
>   if ((int )cs.ldv_50103.role != (int )os.ldv_50103.role) {
58017,58019c63556,63563
<     mdev->tl_hash_s = (unsigned int )((mdev->net_conf)->max_epoch_size / 8);
< #line 1604
<     mdev->tl_hash = new_tl_hash;
---
>     flags = (enum chg_state_flags )((unsigned int )flags & 4294967263U);
>   } else {
> 
>   }
> #line 1605
>   if ((int )cs.ldv_50103.peer != (int )os.ldv_50103.peer) {
> #line 1606
>     flags = (enum chg_state_flags )((unsigned int )flags & 4294967231U);
58023,58024d63566
< #line 1607
<   if ((unsigned long )new_ee_hash != (unsigned long )((struct hlist_head *)0)) {
58026c63568
<     kfree((void const   *)mdev->ee_hash);
---
>   if ((int )cs.ldv_50103.conn != (int )os.ldv_50103.conn) {
58028,58030c63570,63577
<     mdev->ee_hash_s = (unsigned int )((mdev->net_conf)->max_buffers / 8);
< #line 1610
<     mdev->ee_hash = new_ee_hash;
---
>     flags = (enum chg_state_flags )((unsigned int )flags & 4294967167U);
>   } else {
> 
>   }
> #line 1611
>   if ((int )cs.ldv_50103.disk != (int )os.ldv_50103.disk) {
> #line 1612
>     flags = (enum chg_state_flags )((unsigned int )flags & 4294967039U);
58034,58035d63580
< #line 1613
<   crypto_free_hash(mdev->cram_hmac_tfm);
58037,58039c63582,63602
<   mdev->cram_hmac_tfm = tfm;
< #line 1616
<   crypto_free_hash(mdev->integrity_w_tfm);
---
>   if ((int )cs.ldv_50103.pdsk != (int )os.ldv_50103.pdsk) {
> #line 1615
>     flags = (enum chg_state_flags )((unsigned int )flags & 4294966783U);
>   } else {
> 
>   }
>   ldv_52216: 
> #line 1593
>   vnr = vnr + 1;
> #line 1593
>   tmp___0 = idr_get_next(& tconn->volumes, & vnr);
> #line 1593
>   mdev = (struct drbd_conf *)tmp___0;
>   ldv_52218: ;
> #line 1593
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1594
>     goto ldv_52217;
>   } else {
> 
>   }
58041c63604
<   mdev->integrity_w_tfm = integrity_w_tfm;
---
>   rcu_read_unlock();
58043c63606
<   crypto_free_hash(mdev->integrity_r_tfm);
---
>   *pf = (enum chg_state_flags )((unsigned int )*pf | 992U);
58045c63608,63610
<   mdev->integrity_r_tfm = integrity_r_tfm;
---
>   *pf = (enum chg_state_flags )((unsigned int )*pf & (unsigned int )flags);
> #line 1621
>   pcs->i = cs.i;
58047,58063c63612,63629
<   kfree((void const   *)mdev->int_dig_out);
< #line 1623
<   kfree((void const   *)mdev->int_dig_in);
< #line 1624
<   kfree((void const   *)mdev->int_dig_vv);
< #line 1625
<   mdev->int_dig_out = int_dig_out;
< #line 1626
<   mdev->int_dig_in = int_dig_in;
< #line 1627
<   mdev->int_dig_vv = int_dig_vv;
< #line 1628
<   __ns.i = mdev->state.i;
< #line 1628
<   __ns.ldv_40583.conn = 2U;
< #line 1628
<   tmp___16 = _drbd_set_state(mdev, __ns, CS_VERBOSE, 0);
---
>   return;
> }
> }
> #line 1625 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static enum drbd_state_rv conn_is_valid_transition(struct drbd_tconn *tconn , union drbd_state mask ,
>                                                    union drbd_state val , enum chg_state_flags flags ) 
> { 
>   enum drbd_state_rv rv ;
>   union drbd_state ns ;
>   union drbd_state os ;
>   struct drbd_conf *mdev ;
>   int vnr ;
>   void *tmp ;
>   union drbd_state tmp___0 ;
>   enum drbd_state_rv tmp___1 ;
>   void *tmp___2 ;
> 
>   {
58065,58071c63631
<   retcode = (enum drbd_ret_code )tmp___16;
< #line 1629
<   spin_unlock_irq(& mdev->req_lock);
< #line 1631
<   kobject_uevent(& (mdev->vdisk)->part0.__dev.kobj, KOBJ_CHANGE);
< #line 1632
<   reply->ret_code = (int )retcode;
---
>   rv = 1;
58073c63633
<   drbd_reconfig_done(mdev);
---
>   rcu_read_lock();
58075,58078c63635,63648
<   return (0);
<   fail: 
< #line 1637
<   kfree((void const   *)int_dig_out);
---
>   vnr = 0;
> #line 1634
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 1634
>   mdev = (struct drbd_conf *)tmp;
> #line 1634
>   goto ldv_52234;
>   ldv_52233: 
> #line 1635
>   os = drbd_read_state(mdev);
> #line 1636
>   tmp___0 = apply_mask_val(os, mask, val);
> #line 1636
>   ns = sanitize_state(mdev, tmp___0, 0);
58080c63650
<   kfree((void const   *)int_dig_in);
---
>   if ((((unsigned int )flags & 2048U) != 0U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 10U) && (int )os.ldv_40604.disk <= 4) {
58082,58084c63652,63655
<   kfree((void const   *)int_dig_vv);
< #line 1640
<   crypto_free_hash(tfm);
---
>     ns.ldv_40604.disk = os.ldv_40604.disk;
>   } else {
> 
>   }
58086c63657
<   crypto_free_hash(integrity_w_tfm);
---
>   if (ns.i == os.i) {
58088,58090c63659,63662
<   crypto_free_hash(integrity_r_tfm);
< #line 1643
<   kfree((void const   *)new_tl_hash);
---
>     goto ldv_52231;
>   } else {
> 
>   }
58092c63664
<   kfree((void const   *)new_ee_hash);
---
>   rv = is_valid_transition(os, ns);
58094,58096c63666,63671
<   kfree((void const   *)new_conf);
< #line 1647
<   reply->ret_code = (int )retcode;
---
>   if ((int )rv <= 0) {
> #line 1646
>     goto ldv_52232;
>   } else {
> 
>   }
58098c63673
<   drbd_reconfig_done(mdev);
---
>   if (((unsigned int )flags & 1U) == 0U) {
58100,58125c63675,63688
<   return (0);
< }
< }
< #line 1652 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_disconnect(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                               struct drbd_nl_cfg_reply *reply ) 
< { 
<   int retcode ;
<   struct disconnect dc ;
<   int tmp ;
<   union drbd_state __ns ;
<   union drbd_state val ;
<   union drbd_state mask ;
<   enum drbd_state_rv tmp___0 ;
<   union drbd_state val___0 ;
<   union drbd_state mask___0 ;
<   union drbd_state val___1 ;
<   union drbd_state mask___1 ;
<   enum drbd_state_rv tmp___1 ;
<   union drbd_state val___2 ;
<   union drbd_state mask___2 ;
<   int __ret ;
<   wait_queue_t __wait ;
<   struct task_struct *tmp___2 ;
<   struct task_struct *tmp___3 ;
<   int tmp___4 ;
---
>     rv = is_valid_state(mdev, ns);
> #line 1650
>     if ((int )rv <= 0) {
> #line 1651
>       tmp___1 = is_valid_state(mdev, os);
> #line 1651
>       if ((int )tmp___1 == (int )rv) {
> #line 1652
>         rv = is_valid_soft_transition(os, ns, tconn);
>       } else {
> #line 1654
>         rv = is_valid_soft_transition(os, ns, tconn);
>       }
>     } else {
58127,58137c63690
<   {
< #line 1658
<   memset((void *)(& dc), 0, 4UL);
< #line 1659
<   tmp = disconnect_from_tags(mdev, (unsigned short *)(& nlp->tag_list), & dc);
< #line 1659
<   if (tmp == 0) {
< #line 1660
<     retcode = 126;
< #line 1661
<     goto fail;
---
>     }
58141,58153c63694,63698
< #line 1664
<   if ((unsigned int )*((unsigned char *)(& dc) + 0UL) != 0U) {
< #line 1665
<     spin_lock_irq(& mdev->req_lock);
< #line 1666
<     if ((int )mdev->state.ldv_40583.conn > 7) {
< #line 1667
<       __ns.i = mdev->state.i;
< #line 1667
<       __ns.ldv_40583.conn = 1U;
< #line 1667
<       _drbd_set_state(mdev, __ns, CS_HARD, 0);
<     } else {
---
> #line 1656
>   if ((int )rv <= 0) {
> #line 1657
>     goto ldv_52232;
>   } else {
58155,58159c63700,63722
<     }
< #line 1668
<     spin_unlock_irq(& mdev->req_lock);
< #line 1669
<     goto done;
---
>   }
>   ldv_52231: 
> #line 1634
>   vnr = vnr + 1;
> #line 1634
>   tmp___2 = idr_get_next(& tconn->volumes, & vnr);
> #line 1634
>   mdev = (struct drbd_conf *)tmp___2;
>   ldv_52234: ;
> #line 1634
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1635
>     goto ldv_52233;
>   } else {
> 
>   }
>   ldv_52232: 
> #line 1659
>   rcu_read_unlock();
> #line 1661
>   if ((int )rv <= 0 && ((unsigned int )flags & 2U) != 0U) {
> #line 1662
>     print_st_err(mdev, os, ns, rv);
58162a63726,63786
> #line 1664
>   return (rv);
> }
> }
> #line 1668 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> void conn_set_state(struct drbd_tconn *tconn , union drbd_state mask , union drbd_state val ,
>                     union drbd_state *pns_min , union drbd_state *pns_max , enum chg_state_flags flags ) 
> { 
>   union drbd_state ns ;
>   union drbd_state os ;
>   union drbd_state ns_max ;
>   union drbd_state ns_min ;
>   struct drbd_conf *mdev ;
>   enum drbd_state_rv rv ;
>   int vnr ;
>   int number_of_volumes ;
>   void *tmp ;
>   enum drbd_role tmp___0 ;
>   enum drbd_role tmp___1 ;
>   enum drbd_conns __max1 ;
>   enum drbd_conns __max2 ;
>   enum drbd_disk_state __max1___0 ;
>   enum drbd_disk_state __max2___0 ;
>   enum drbd_disk_state __max1___1 ;
>   enum drbd_disk_state __max2___1 ;
>   enum drbd_role tmp___2 ;
>   enum drbd_role tmp___3 ;
>   enum drbd_conns __min1 ;
>   enum drbd_conns __min2 ;
>   enum drbd_disk_state __min1___0 ;
>   enum drbd_disk_state __min2___0 ;
>   enum drbd_disk_state __min1___1 ;
>   enum drbd_disk_state __min2___1 ;
>   void *tmp___4 ;
>   union drbd_state __constr_expr_0 ;
> 
>   {
> #line 1671
>   ns_max.ldv_40604.role = (unsigned char)0;
> #line 1671
>   ns_max.ldv_40604.peer = (unsigned char)0;
> #line 1671
>   ns_max.ldv_40604.conn = (unsigned char)0;
> #line 1671
>   ns_max.ldv_40604.disk = (unsigned char)0;
> #line 1671
>   ns_max.ldv_40604.pdsk = (unsigned char)0;
> #line 1671
>   ns_max.ldv_40604.susp = (unsigned char)0;
> #line 1671
>   ns_max.ldv_40604.aftr_isp = (unsigned char)0;
> #line 1671
>   ns_max.ldv_40604.peer_isp = (unsigned char)0;
> #line 1671
>   ns_max.ldv_40604.user_isp = (unsigned char)0;
> #line 1671
>   ns_max.ldv_40604.susp_nod = (unsigned char)0;
> #line 1671
>   ns_max.ldv_40604.susp_fen = (unsigned char)0;
> #line 1671
>   ns_max.ldv_40604._pad = (unsigned short)0;
58164c63788
<   val.i = 0U;
---
>   ns_min.ldv_40604.role = 3U;
58166c63790
<   val.ldv_40583.conn = 1U;
---
>   ns_min.ldv_40604.peer = 3U;
58168c63792
<   mask.i = 0U;
---
>   ns_min.ldv_40604.conn = val.ldv_40604.conn;
58170c63794
<   mask.ldv_40583.conn = 31U;
---
>   ns_min.ldv_40604.disk = 15U;
58172c63796
<   tmp___0 = _drbd_request_state(mdev, mask, val, CS_ORDERED);
---
>   ns_min.ldv_40604.pdsk = 15U;
58174,58198c63798,63810
<   retcode = (int )tmp___0;
< #line 1674
<   if (retcode == 2) {
< #line 1675
<     goto done;
<   } else
< #line 1676
<   if (retcode == -9) {
< #line 1677
<     goto done;
<   } else
< #line 1678
<   if (retcode == -7) {
< #line 1681
<     val___0.i = 0U;
< #line 1681
<     val___0.ldv_40583.conn = 1U;
< #line 1681
<     val___0.ldv_40583.pdsk = 5U;
< #line 1680
<     mask___0.i = 0U;
< #line 1680
<     mask___0.ldv_40583.conn = 31U;
< #line 1681
<     mask___0.ldv_40583.pdsk = 15U;
---
>   ns_min.ldv_40604.susp = (unsigned char)0;
> #line 1672
>   ns_min.ldv_40604.aftr_isp = (unsigned char)0;
> #line 1672
>   ns_min.ldv_40604.peer_isp = (unsigned char)0;
> #line 1672
>   ns_min.ldv_40604.user_isp = (unsigned char)0;
> #line 1672
>   ns_min.ldv_40604.susp_nod = (unsigned char)0;
> #line 1672
>   ns_min.ldv_40604.susp_fen = (unsigned char)0;
> #line 1672
>   ns_min.ldv_40604._pad = (unsigned short)0;
58200,58219c63812,63814
<     retcode = drbd_request_state(mdev, mask___0, val___0);
<   } else
< #line 1682
<   if (retcode == -10) {
< #line 1685
<     val___1.i = 0U;
< #line 1685
<     val___1.ldv_40583.conn = 1U;
< #line 1685
<     val___1.ldv_40583.disk = 5U;
< #line 1684
<     mask___1.i = 0U;
< #line 1684
<     mask___1.ldv_40583.conn = 31U;
< #line 1685
<     mask___1.ldv_40583.disk = 15U;
< #line 1685
<     tmp___1 = _drbd_request_state(mdev, mask___1, val___1, CS_ORDERED);
< #line 1685
<     retcode = (int )tmp___1;
---
>   number_of_volumes = 0;
> #line 1683
>   if ((unsigned int )*((unsigned short *)(& mask) + 0UL) == 496U) {
58221,58227c63816
<     if (retcode == -11 || retcode == -16) {
< #line 1688
<       val___2.i = 0U;
< #line 1688
<       val___2.ldv_40583.conn = 1U;
< #line 1688
<       mask___2.i = 0U;
---
>     if ((unsigned int )tconn->cstate != 9U && (unsigned int )*((unsigned short *)(& val) + 0UL) == 144U) {
58229,58233c63818
<       mask___2.ldv_40583.conn = 31U;
< #line 1688
<       drbd_force_state(mdev, mask___2, val___2);
< #line 1689
<       retcode = 1;
---
>       tconn->last_reconnect_jif = jiffies;
58236a63822,63823
> #line 1690
>     tconn->cstate = (enum drbd_conns )val.ldv_40604.conn;
58241c63828
<   if (retcode <= 0) {
---
>   rcu_read_lock();
58243,58298c63830,63839
<     goto fail;
<   } else {
< 
<   }
< #line 1696
<   __ret = 0;
< #line 1696
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 16U) {
< #line 1696
<     tmp___2 = get_current();
< #line 1696
<     __wait.flags = 0U;
< #line 1696
<     __wait.private = (void *)tmp___2;
< #line 1696
<     __wait.func = & autoremove_wake_function;
< #line 1696
<     __wait.task_list.next = & __wait.task_list;
< #line 1696
<     __wait.task_list.prev = & __wait.task_list;
<     ldv_54334: 
< #line 1696
<     prepare_to_wait(& mdev->state_wait, & __wait, 1);
< #line 1696
<     if ((unsigned int )*((unsigned short *)mdev + 1138UL) != 16U) {
< #line 1696
<       goto ldv_54332;
<     } else {
< 
<     }
< #line 1696
<     tmp___3 = get_current();
< #line 1696
<     tmp___4 = signal_pending(tmp___3);
< #line 1696
<     if (tmp___4 == 0) {
< #line 1696
<       schedule();
< #line 1696
<       goto ldv_54333;
<     } else {
< 
<     }
< #line 1696
<     __ret = -512;
< #line 1696
<     goto ldv_54332;
<     ldv_54333: ;
< #line 1696
<     goto ldv_54334;
<     ldv_54332: 
< #line 1696
<     finish_wait(& mdev->state_wait, & __wait);
<   } else {
< 
<   }
---
>   vnr = 0;
> #line 1694
>   tmp = idr_get_next(& tconn->volumes, & vnr);
> #line 1694
>   mdev = (struct drbd_conf *)tmp;
> #line 1694
>   goto ldv_52271;
>   ldv_52270: 
> #line 1695
>   number_of_volumes = number_of_volumes + 1;
58300c63841,63845
<   if (__ret != 0) {
---
>   os = drbd_read_state(mdev);
> #line 1697
>   ns = apply_mask_val(os, mask, val);
> #line 1698
>   ns = sanitize_state(mdev, ns, 0);
58302c63847
<     retcode = 129;
---
>   if ((((unsigned int )flags & 2048U) != 0U && (unsigned int )*((unsigned char *)(& ns) + 1UL) == 10U) && (int )os.ldv_40604.disk <= 4) {
58304c63849
<     goto fail;
---
>     ns.ldv_40604.disk = os.ldv_40604.disk;
58308c63853,63856
<   done: 
---
> #line 1703
>   rv = __drbd_set_state(mdev, ns, flags, 0);
> #line 1704
>   if ((int )rv <= 0) {
58310,58311c63858,63865
<   retcode = 101;
<   fail: 
---
>     __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"),
>                          "i" (1705), "i" (12UL));
>     ldv_52251: ;
> #line 1705
>     goto ldv_52251;
>   } else {
> 
>   }
58313c63867
<   drbd_md_sync(mdev);
---
>   ns.i = mdev->state.i;
58315c63869,63871
<   reply->ret_code = retcode;
---
>   tmp___0 = max_role((enum drbd_role )ns.ldv_40604.role, (enum drbd_role )ns_max.ldv_40604.role);
> #line 1708
>   ns_max.ldv_40604.role = (unsigned char )tmp___0;
58317,58327c63873,63901
<   return (0);
< }
< }
< #line 1712 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void resync_after_online_grow(struct drbd_conf *mdev ) 
< { 
<   int iass ;
<   union drbd_state val ;
<   union drbd_state mask ;
< 
<   {
---
>   tmp___1 = max_role((enum drbd_role )ns.ldv_40604.peer, (enum drbd_role )ns_max.ldv_40604.peer);
> #line 1709
>   ns_max.ldv_40604.peer = (unsigned char )tmp___1;
> #line 1710
>   __max1 = (enum drbd_conns )ns.ldv_40604.conn;
> #line 1710
>   __max2 = (enum drbd_conns )ns_max.ldv_40604.conn;
> #line 1710
>   ns_max.ldv_40604.conn = (unsigned char )((unsigned int )__max1 > (unsigned int )__max2 ? (unsigned int )__max1 : (unsigned int )__max2);
> #line 1711
>   __max1___0 = (enum drbd_disk_state )ns.ldv_40604.disk;
> #line 1711
>   __max2___0 = (enum drbd_disk_state )ns_max.ldv_40604.disk;
> #line 1711
>   ns_max.ldv_40604.disk = (unsigned char )((unsigned int )__max1___0 > (unsigned int )__max2___0 ? (unsigned int )__max1___0 : (unsigned int )__max2___0);
> #line 1712
>   __max1___1 = (enum drbd_disk_state )ns.ldv_40604.pdsk;
> #line 1712
>   __max2___1 = (enum drbd_disk_state )ns_max.ldv_40604.pdsk;
> #line 1712
>   ns_max.ldv_40604.pdsk = (unsigned char )((unsigned int )__max1___1 > (unsigned int )__max2___1 ? (unsigned int )__max1___1 : (unsigned int )__max2___1);
> #line 1714
>   tmp___2 = min_role((enum drbd_role )ns.ldv_40604.role, (enum drbd_role )ns_min.ldv_40604.role);
> #line 1714
>   ns_min.ldv_40604.role = (unsigned char )tmp___2;
> #line 1715
>   tmp___3 = min_role((enum drbd_role )ns.ldv_40604.peer, (enum drbd_role )ns_min.ldv_40604.peer);
> #line 1715
>   ns_min.ldv_40604.peer = (unsigned char )tmp___3;
58329c63903,63907
<   _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Resync of new storage after online grow\n");
---
>   __min1 = (enum drbd_conns )ns.ldv_40604.conn;
> #line 1716
>   __min2 = (enum drbd_conns )ns_min.ldv_40604.conn;
> #line 1716
>   ns_min.ldv_40604.conn = (unsigned char )((unsigned int )__min1 < (unsigned int )__min2 ? (unsigned int )__min1 : (unsigned int )__min2);
58331c63909,63917
<   if ((int )mdev->state.ldv_40583.role != (int )mdev->state.ldv_40583.peer) {
---
>   __min1___0 = (enum drbd_disk_state )ns.ldv_40604.disk;
> #line 1717
>   __min2___0 = (enum drbd_disk_state )ns_min.ldv_40604.disk;
> #line 1717
>   ns_min.ldv_40604.disk = (unsigned char )((unsigned int )__min1___0 < (unsigned int )__min2___0 ? (unsigned int )__min1___0 : (unsigned int )__min2___0);
> #line 1718
>   __min1___1 = (enum drbd_disk_state )ns.ldv_40604.pdsk;
> #line 1718
>   __min2___1 = (enum drbd_disk_state )ns_min.ldv_40604.pdsk;
58333c63919,63930
<     iass = (unsigned int )*((unsigned char *)mdev + 2276UL) == 1U;
---
>   ns_min.ldv_40604.pdsk = (unsigned char )((unsigned int )__min1___1 < (unsigned int )__min2___1 ? (unsigned int )__min1___1 : (unsigned int )__min2___1);
> #line 1694
>   vnr = vnr + 1;
> #line 1694
>   tmp___4 = idr_get_next(& tconn->volumes, & vnr);
> #line 1694
>   mdev = (struct drbd_conf *)tmp___4;
>   ldv_52271: ;
> #line 1694
>   if ((unsigned long )mdev != (unsigned long )((struct drbd_conf *)0)) {
> #line 1695
>     goto ldv_52270;
58335,58336c63932
< #line 1720
<     iass = drbd_test_flag(mdev, DISCARD_CONCURRENT);
---
> 
58337a63934,63935
> #line 1720
>   rcu_read_unlock();
58339c63937
<   if (iass != 0) {
---
>   if (number_of_volumes == 0) {
58341c63939,63965
<     drbd_start_resync(mdev, C_SYNC_SOURCE);
---
>     __constr_expr_0.ldv_40604.role = 2U;
> #line 1723
>     __constr_expr_0.ldv_40604.peer = 0U;
> #line 1723
>     __constr_expr_0.ldv_40604.conn = val.ldv_40604.conn;
> #line 1723
>     __constr_expr_0.ldv_40604.disk = 0U;
> #line 1723
>     __constr_expr_0.ldv_40604.pdsk = 6U;
> #line 1723
>     __constr_expr_0.ldv_40604.susp = (unsigned char)0;
> #line 1723
>     __constr_expr_0.ldv_40604.aftr_isp = (unsigned char)0;
> #line 1723
>     __constr_expr_0.ldv_40604.peer_isp = (unsigned char)0;
> #line 1723
>     __constr_expr_0.ldv_40604.user_isp = (unsigned char)0;
> #line 1723
>     __constr_expr_0.ldv_40604.susp_nod = (unsigned char)0;
> #line 1723
>     __constr_expr_0.ldv_40604.susp_fen = (unsigned char)0;
> #line 1723
>     __constr_expr_0.ldv_40604._pad = (unsigned short)0;
> #line 1723
>     ns_max = __constr_expr_0;
> #line 1723
>     ns_min = ns_max;
58343,58352c63967
< #line 1725
<     val.i = 0U;
< #line 1725
<     val.ldv_40583.conn = 15U;
< #line 1725
<     mask.i = 0U;
< #line 1725
<     mask.ldv_40583.conn = 31U;
< #line 1725
<     _drbd_request_state(mdev, mask, val, 10);
---
> 
58354c63969,63985
< #line 1727
---
> #line 1732
>   ns_max.ldv_40604.susp = tconn->susp;
> #line 1732
>   ns_min.ldv_40604.susp = ns_max.ldv_40604.susp;
> #line 1733
>   ns_max.ldv_40604.susp_nod = tconn->susp_nod;
> #line 1733
>   ns_min.ldv_40604.susp_nod = ns_max.ldv_40604.susp_nod;
> #line 1734
>   ns_max.ldv_40604.susp_fen = tconn->susp_fen;
> #line 1734
>   ns_min.ldv_40604.susp_fen = ns_max.ldv_40604.susp_fen;
> #line 1736
>   *pns_min = ns_min;
> #line 1737
>   *pns_max = ns_max;
> #line 1738
58358,58359c63989,63991
< #line 1728 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_resize(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp , struct drbd_nl_cfg_reply *reply ) 
---
> #line 1741 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> static enum drbd_state_rv _conn_rq_cond(struct drbd_tconn *tconn , union drbd_state mask ,
>                                         union drbd_state val ) 
58361,58364c63993
<   struct resize rs ;
<   int retcode ;
<   enum determine_dev_size dd ;
<   enum dds_flags ddsf ;
---
>   enum drbd_state_rv rv ;
58367d63995
<   sector_t tmp___1 ;
58370,58390c63998,64003
< #line 1732
<   retcode = 101;
< #line 1736
<   memset((void *)(& rs), 0, 16UL);
< #line 1737
<   tmp = resize_from_tags(mdev, (unsigned short *)(& nlp->tag_list), & rs);
< #line 1737
<   if (tmp == 0) {
< #line 1738
<     retcode = 126;
< #line 1739
<     goto fail;
<   } else {
< 
<   }
< #line 1742
<   if ((int )mdev->state.ldv_40583.conn > 10) {
< #line 1743
<     retcode = 130;
< #line 1744
<     goto fail;
---
> #line 1745
>   tmp = test_and_clear_bit(6, (unsigned long volatile   *)(& tconn->flags));
> #line 1745
>   if (tmp != 0) {
> #line 1746
>     return (SS_CW_SUCCESS);
58394,58395c64007,64010
< #line 1747
<   if ((unsigned int )*((unsigned char *)mdev + 2276UL) == 2U && (unsigned int )*((unsigned char *)mdev + 2276UL) == 8U) {
---
> #line 1748
>   tmp___0 = test_and_clear_bit(7, (unsigned long volatile   *)(& tconn->flags));
> #line 1748
>   if (tmp___0 != 0) {
58397,58399c64012
<     retcode = 131;
< #line 1750
<     goto fail;
---
>     return (SS_CW_FAILED_BY_PEER);
58402a64016,64017
> #line 1751
>   rv = (unsigned int )tconn->cstate != 9U ? SS_CW_NO_NEED : SS_UNKNOWN_ERROR;
58404,58406c64019
<   tmp___0 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1753
<   if (tmp___0 == 0) {
---
>   if ((int )rv == 0) {
58408,58410c64021
<     retcode = 138;
< #line 1755
<     goto fail;
---
>     rv = conn_is_valid_transition(tconn, mask, val, 0);
58414,58419c64025,64028
< #line 1758
<   if ((unsigned int )*((unsigned char *)(& rs) + 8UL) != 0U && mdev->agreed_pro_version <= 92) {
< #line 1759
<     retcode = 153;
< #line 1760
<     goto fail_ldev;
---
> #line 1756
>   if ((int )rv == 1) {
> #line 1757
>     rv = SS_UNKNOWN_ERROR;
58423,58429c64032,64059
< #line 1763
<   tmp___1 = drbd_get_capacity((mdev->ldev)->backing_bdev);
< #line 1763
<   if ((mdev->ldev)->known_size != tmp___1) {
< #line 1764
<     (mdev->ldev)->known_size = drbd_get_capacity((mdev->ldev)->backing_bdev);
<   } else {
---
> #line 1759
>   return (rv);
> }
> }
> #line 1763 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> enum drbd_state_rv _conn_request_state(struct drbd_tconn *tconn , union drbd_state mask ,
>                                        union drbd_state val , enum chg_state_flags flags ) 
> { 
>   enum drbd_state_rv rv ;
>   struct after_conn_state_chg_work *acscw ;
>   enum drbd_conns oc ;
>   union drbd_state ns_max ;
>   union drbd_state ns_min ;
>   union drbd_state os ;
>   bool have_mutex ;
>   int tmp ;
>   wait_queue_t __wait ;
>   struct task_struct *tmp___0 ;
>   long volatile   __ret ;
>   struct task_struct *tmp___1 ;
>   struct task_struct *tmp___2 ;
>   struct task_struct *tmp___3 ;
>   struct task_struct *tmp___4 ;
>   struct task_struct *tmp___5 ;
>   void *tmp___6 ;
>   char const   *tmp___7 ;
>   char const   *tmp___8 ;
>   char const   *tmp___9 ;
58431c64061
<   }
---
>   {
58433,58435c64063
<   (mdev->ldev)->dc.disk_size = rs.resize_size;
< #line 1767
<   ddsf = (enum dds_flags )(((unsigned int )*((unsigned char *)(& rs) + 8UL) != 0U) | ((int )*((unsigned char *)(& rs) + 8UL) & 2));
---
>   rv = 1;
58437,58439c64065
<   dd = drbd_determine_dev_size(mdev, ddsf);
< #line 1769
<   drbd_md_sync(mdev);
---
>   oc = tconn->cstate;
58441,58443c64067
<   put_ldev(mdev);
< #line 1771
<   if ((int )dd == -1) {
---
>   have_mutex = 0;
58445c64069
<     retcode = 140;
---
>   if ((unsigned int )*((unsigned short *)(& mask) + 0UL) != 0U) {
58447c64071,64078
<     goto fail;
---
>     rv = is_valid_conn_transition(oc, (enum drbd_conns )val.ldv_40604.conn);
> #line 1774
>     if ((int )rv <= 0) {
> #line 1775
>       goto abort;
>     } else {
> 
>     }
58451,58454d64081
< #line 1776
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) == 160U) {
< #line 1777
<     if ((int )dd == 2) {
58456,58459c64083,64085
<       drbd_set_flag(mdev, RESIZE_PENDING);
<     } else {
< 
<     }
---
>   rv = conn_is_valid_transition(tconn, mask, val, flags);
> #line 1779
>   if ((int )rv <= 0) {
58461,58463c64087
<     drbd_send_uuids(mdev);
< #line 1781
<     drbd_send_sizes(mdev, 1, ddsf);
---
>     goto abort;
58467,58472c64091,64094
<   fail: 
< #line 1785
<   reply->ret_code = retcode;
< #line 1786
<   return (0);
<   fail_ldev: 
---
> #line 1782
>   if (((unsigned int )oc == 9U && (unsigned int )*((unsigned short *)(& val) + 0UL) == 16U) && ((unsigned int )flags & 17U) == 0U) {
> #line 1788
>     spin_unlock_irq(& tconn->req_lock);
58474c64096
<   put_ldev(mdev);
---
>     mutex_lock_nested(& tconn->cstate_mutex, 0U);
58476,58517c64098,64106
<   goto fail;
< }
< }
< #line 1793 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_syncer_conf(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                                struct drbd_nl_cfg_reply *reply ) 
< { 
<   int retcode ;
<   int err ;
<   int ovr ;
<   int rsr ;
<   struct crypto_hash *verify_tfm ;
<   struct crypto_hash *csums_tfm ;
<   struct syncer_conf sc ;
<   cpumask_var_t new_cpu_mask ;
<   int *rs_plan_s ;
<   int fifo_size ;
<   bool tmp ;
<   int tmp___0 ;
<   size_t __len ;
<   void *__ret ;
<   int tmp___1 ;
<   int tmp___2 ;
<   long tmp___3 ;
<   struct crypto_tfm *tmp___4 ;
<   int tmp___5 ;
<   int tmp___6 ;
<   long tmp___7 ;
<   struct crypto_tfm *tmp___8 ;
<   int tmp___9 ;
<   int _b ;
<   int _b___0 ;
<   void *tmp___10 ;
<   int tmp___11 ;
<   wait_queue_t __wait ;
<   struct task_struct *tmp___12 ;
<   int tmp___13 ;
<   int tmp___14 ;
<   bool tmp___15 ;
<   int tmp___16 ;
< 
<   {
---
>     have_mutex = 1;
> #line 1792
>     set_bit(5U, (unsigned long volatile   *)(& tconn->flags));
> #line 1793
>     tmp = conn_send_state_req(tconn, mask, val);
> #line 1793
>     if (tmp != 0) {
> #line 1795
>       clear_bit(5, (unsigned long volatile   *)(& tconn->flags));
58519,58686c64108,64110
<   retcode = 101;
< #line 1800
<   verify_tfm = 0;
< #line 1801
<   csums_tfm = 0;
< #line 1804
<   rs_plan_s = 0;
< #line 1807
<   tmp = zalloc_cpumask_var(& new_cpu_mask, 208U);
< #line 1807
<   if (tmp) {
< #line 1807
<     tmp___0 = 0;
<   } else {
< #line 1807
<     tmp___0 = 1;
<   }
< #line 1807
<   if (tmp___0) {
< #line 1808
<     retcode = 122;
< #line 1809
<     goto fail;
<   } else {
< 
<   }
< #line 1812
<   if ((nlp->flags & 2) != 0) {
< #line 1813
<     memset((void *)(& sc), 0, 212UL);
< #line 1814
<     sc.rate = 250;
< #line 1815
<     sc.after = -1;
< #line 1816
<     sc.al_extents = 127;
< #line 1817
<     sc.on_no_data = 0;
< #line 1818
<     sc.c_plan_ahead = 0;
< #line 1819
<     sc.c_delay_target = 10;
< #line 1820
<     sc.c_fill_target = 0;
< #line 1821
<     sc.c_max_rate = 102400;
< #line 1822
<     sc.c_min_rate = 4096;
<   } else {
< #line 1824
<     __len = 212UL;
< #line 1824
<     if (__len > 63UL) {
< #line 1824
<       __ret = __memcpy((void *)(& sc), (void const   *)(& mdev->sync_conf), __len);
<     } else {
< #line 1824
<       __ret = __builtin_memcpy((void *)(& sc), (void const   *)(& mdev->sync_conf),
<                                __len);
<     }
<   }
< #line 1826
<   tmp___1 = syncer_conf_from_tags(mdev, (unsigned short *)(& nlp->tag_list), & sc);
< #line 1826
<   if (tmp___1 == 0) {
< #line 1827
<     retcode = 126;
< #line 1828
<     goto fail;
<   } else {
< 
<   }
< #line 1832
<   rsr = (((unsigned int )*((unsigned short *)mdev + 1138UL) == 256U || (unsigned int )*((unsigned short *)mdev + 1138UL) == 272U) || (unsigned int )*((unsigned short *)mdev + 1138UL) == 320U) || (unsigned int )*((unsigned short *)mdev + 1138UL) == 336U;
< #line 1837
<   if (rsr != 0) {
< #line 1837
<     tmp___2 = strcmp((char const   *)(& sc.csums_alg), (char const   *)(& mdev->sync_conf.csums_alg));
< #line 1837
<     if (tmp___2 != 0) {
< #line 1838
<       retcode = 148;
< #line 1839
<       goto fail;
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1842
<   if (rsr == 0 && (unsigned int )sc.csums_alg[0] != 0U) {
< #line 1843
<     csums_tfm = crypto_alloc_hash((char const   *)(& sc.csums_alg), 0U, 128U);
< #line 1844
<     tmp___3 = IS_ERR((void const   *)csums_tfm);
< #line 1844
<     if (tmp___3 != 0L) {
< #line 1845
<       csums_tfm = 0;
< #line 1846
<       retcode = 144;
< #line 1847
<       goto fail;
<     } else {
< 
<     }
< #line 1850
<     tmp___4 = crypto_hash_tfm(csums_tfm);
< #line 1850
<     tmp___5 = drbd_crypto_is_hash(tmp___4);
< #line 1850
<     if (tmp___5 == 0) {
< #line 1851
<       retcode = 145;
< #line 1852
<       goto fail;
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1857
<   ovr = (unsigned int )*((unsigned short *)mdev + 1138UL) == 288U || (unsigned int )*((unsigned short *)mdev + 1138UL) == 304U;
< #line 1859
<   if (ovr != 0) {
< #line 1860
<     tmp___6 = strcmp((char const   *)(& sc.verify_alg), (char const   *)(& mdev->sync_conf.verify_alg));
< #line 1860
<     if (tmp___6 != 0) {
< #line 1861
<       retcode = 149;
< #line 1862
<       goto fail;
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 1866
<   if (ovr == 0 && (unsigned int )sc.verify_alg[0] != 0U) {
< #line 1867
<     verify_tfm = crypto_alloc_hash((char const   *)(& sc.verify_alg), 0U, 128U);
< #line 1868
<     tmp___7 = IS_ERR((void const   *)verify_tfm);
< #line 1868
<     if (tmp___7 != 0L) {
< #line 1869
<       verify_tfm = 0;
< #line 1870
<       retcode = 146;
< #line 1871
<       goto fail;
<     } else {
< 
<     }
< #line 1874
<     tmp___8 = crypto_hash_tfm(verify_tfm);
< #line 1874
<     tmp___9 = drbd_crypto_is_hash(tmp___8);
< #line 1874
<     if (tmp___9 == 0) {
< #line 1875
<       retcode = 147;
< #line 1876
<       goto fail;
---
>       rv = SS_CW_FAILED_BY_PEER;
> #line 1798
>       goto abort_unlocked;
58690,58706c64114,64117
<   } else {
< 
<   }
< #line 1881
<   if (nr_cpu_ids > 1 && (unsigned int )sc.cpu_mask[0] != 0U) {
< #line 1882
<     err = bitmap_parse((char const   *)(& sc.cpu_mask), 32U, (unsigned long *)(& new_cpu_mask->bits),
<                        nr_cpu_ids);
< #line 1884
<     if (err != 0) {
< #line 1885
<       dev_warn((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "bitmap_parse() failed with %d\n",
<                err);
< #line 1886
<       retcode = 143;
< #line 1887
<       goto fail;
---
> #line 1801
>     if ((unsigned int )*((unsigned short *)(& val) + 0UL) == 16U) {
> #line 1802
>       set_bit(12U, (unsigned long volatile   *)(& tconn->flags));
58710,58790c64121,64128
<   } else {
< 
<   }
< #line 1891
<   _b = sc.rate <= 0;
< #line 1891
<   if (_b != 0) {
< #line 1891
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_nl_syncer_conf", (char *)"sc.rate < 1", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
<             1891);
<   } else {
< 
<   }
< #line 1891
<   if (_b != 0) {
< #line 1891
<     sc.rate = 1;
<   } else {
< 
<   }
< #line 1892
<   _b___0 = sc.al_extents <= 6;
< #line 1892
<   if (_b___0 != 0) {
< #line 1892
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "ASSERT FAILED: %s: (%s) in %s:%d\n",
<             "drbd_nl_syncer_conf", (char *)"sc.al_extents < 7", (char *)"/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared",
<             1892);
<   } else {
< 
<   }
< #line 1892
<   if (_b___0 != 0) {
< #line 1892
<     sc.al_extents = 127;
<   } else {
< 
<   }
< #line 1894
<   if (sc.al_extents > 3843) {
< #line 1895
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "sc.al_extents > %d\n",
<             3843);
< #line 1896
<     sc.al_extents = 3843;
<   } else {
< 
<   }
< #line 1903
<   if (sc.after >= 0) {
< #line 1904
<     ensure_mdev(sc.after, 1);
<   } else {
< 
<   }
< #line 1909
<   retcode = drbd_alter_sa(mdev, sc.after);
< #line 1910
<   if (retcode != 101) {
< #line 1911
<     goto fail;
<   } else {
< 
<   }
< #line 1913
<   fifo_size = (sc.c_plan_ahead * 250) / 250;
< #line 1914
<   if ((unsigned int )fifo_size != mdev->rs_plan_s.size && fifo_size > 0) {
< #line 1915
<     tmp___10 = kzalloc((unsigned long )fifo_size * 4UL, 208U);
< #line 1915
<     rs_plan_s = (int *)tmp___10;
< #line 1916
<     if ((unsigned long )rs_plan_s == (unsigned long )((int *)0)) {
< #line 1917
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "kmalloc of fifo_buffer failed");
< #line 1918
<       retcode = 122;
< #line 1919
<       goto fail;
---
> #line 1807
>     spin_lock_irq(& tconn->req_lock);
> #line 1808
>     rv = _conn_rq_cond(tconn, mask, val);
> #line 1808
>     if ((int )rv != 0) {
> #line 1808
>       goto ldv_52295;
58794,58851c64132,64177
<   } else {
< 
<   }
< #line 1925
<   spin_lock(& mdev->peer_seq_lock);
< #line 1926
<   mdev->sync_conf = sc;
< #line 1928
<   if (rsr == 0) {
< #line 1929
<     crypto_free_hash(mdev->csums_tfm);
< #line 1930
<     mdev->csums_tfm = csums_tfm;
< #line 1931
<     csums_tfm = 0;
<   } else {
< 
<   }
< #line 1934
<   if (ovr == 0) {
< #line 1935
<     crypto_free_hash(mdev->verify_tfm);
< #line 1936
<     mdev->verify_tfm = verify_tfm;
< #line 1937
<     verify_tfm = 0;
<   } else {
< 
<   }
< #line 1940
<   if ((unsigned int )fifo_size != mdev->rs_plan_s.size) {
< #line 1941
<     kfree((void const   *)mdev->rs_plan_s.values);
< #line 1942
<     mdev->rs_plan_s.values = rs_plan_s;
< #line 1943
<     mdev->rs_plan_s.size = (unsigned int )fifo_size;
< #line 1944
<     mdev->rs_planed = 0;
< #line 1945
<     rs_plan_s = 0;
<   } else {
< 
<   }
< #line 1948
<   spin_unlock(& mdev->peer_seq_lock);
< #line 1950
<   tmp___14 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 1950
<   if (tmp___14 != 0) {
< #line 1951
<     tmp___11 = lc_try_lock(mdev->act_log);
< #line 1951
<     if (tmp___11 != 0) {
< #line 1951
<       goto ldv_54379;
<     } else {
< 
---
> #line 1808
>     tmp___0 = get_current();
> #line 1808
>     init_waitqueue_entry(& __wait, tmp___0);
> #line 1808
>     add_wait_queue(& tconn->ping_wait, & __wait);
>     ldv_52306: 
> #line 1808
>     __ret = 2L;
> #line 1808
>     switch (8UL) {
>     case 1UL: 
> #line 1808
>     tmp___1 = get_current();
> #line 1808
>     __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___1->state): : "memory",
>                          "cc");
> #line 1808
>     goto ldv_52299;
>     case 2UL: 
> #line 1808
>     tmp___2 = get_current();
> #line 1808
>     __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
>                          "cc");
> #line 1808
>     goto ldv_52299;
>     case 4UL: 
> #line 1808
>     tmp___3 = get_current();
> #line 1808
>     __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
>                          "cc");
> #line 1808
>     goto ldv_52299;
>     case 8UL: 
> #line 1808
>     tmp___4 = get_current();
> #line 1808
>     __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
>                          "cc");
> #line 1808
>     goto ldv_52299;
>     default: 
> #line 1808
>     __xchg_wrong_size();
58853,58873c64179,64185
< #line 1951
<     tmp___12 = get_current();
< #line 1951
<     __wait.flags = 0U;
< #line 1951
<     __wait.private = (void *)tmp___12;
< #line 1951
<     __wait.func = & autoremove_wake_function;
< #line 1951
<     __wait.task_list.next = & __wait.task_list;
< #line 1951
<     __wait.task_list.prev = & __wait.task_list;
<     ldv_54382: 
< #line 1951
<     prepare_to_wait(& mdev->al_wait, & __wait, 2);
< #line 1951
<     tmp___13 = lc_try_lock(mdev->act_log);
< #line 1951
<     if (tmp___13 != 0) {
< #line 1951
<       goto ldv_54381;
---
>     ldv_52299: 
> #line 1808
>     rv = _conn_rq_cond(tconn, mask, val);
> #line 1808
>     if ((int )rv != 0) {
> #line 1808
>       goto ldv_52305;
58877c64189,64191
< #line 1951
---
> #line 1808
>     spin_unlock_irq(& tconn->req_lock);
> #line 1808
58879,58902c64193,64210
< #line 1951
<     goto ldv_54382;
<     ldv_54381: 
< #line 1951
<     finish_wait(& mdev->al_wait, & __wait);
<     ldv_54379: 
< #line 1952
<     drbd_al_shrink(mdev);
< #line 1953
<     err = drbd_check_al_size(mdev);
< #line 1954
<     lc_unlock(mdev->act_log);
< #line 1955
<     __wake_up(& mdev->al_wait, 3U, 1, 0);
< #line 1957
<     put_ldev(mdev);
< #line 1958
<     drbd_md_sync(mdev);
< #line 1960
<     if (err != 0) {
< #line 1961
<       retcode = 122;
< #line 1962
<       goto fail;
---
> #line 1808
>     spin_lock_irq(& tconn->req_lock);
> #line 1808
>     goto ldv_52306;
>     ldv_52305: 
> #line 1808
>     tmp___5 = get_current();
> #line 1808
>     tmp___5->state = 0L;
> #line 1808
>     remove_wait_queue(& tconn->ping_wait, & __wait);
>     ldv_52295: 
> #line 1812
>     clear_bit(5, (unsigned long volatile   *)(& tconn->flags));
> #line 1813
>     if ((int )rv <= 0) {
> #line 1814
>       goto abort;
58909,59064c64217,64246
< #line 1966
<   if ((int )mdev->state.ldv_40583.conn > 9) {
< #line 1967
<     drbd_send_sync_param(mdev, & sc);
<   } else {
< 
<   }
< #line 1969
<   tmp___15 = cpumask_equal((struct cpumask  const  *)mdev->cpu_mask, (struct cpumask  const  *)new_cpu_mask);
< #line 1969
<   if (tmp___15) {
< #line 1969
<     tmp___16 = 0;
<   } else {
< #line 1969
<     tmp___16 = 1;
<   }
< #line 1969
<   if (tmp___16) {
< #line 1970
<     cpumask_copy(mdev->cpu_mask, (struct cpumask  const  *)new_cpu_mask);
< #line 1971
<     drbd_calc_cpu_mask(mdev);
< #line 1972
<     mdev->receiver.reset_cpu_mask = 1;
< #line 1973
<     mdev->asender.reset_cpu_mask = 1;
< #line 1974
<     mdev->worker.reset_cpu_mask = 1;
<   } else {
< 
<   }
< #line 1977
<   kobject_uevent(& (mdev->vdisk)->part0.__dev.kobj, KOBJ_CHANGE);
<   fail: 
< #line 1979
<   kfree((void const   *)rs_plan_s);
< #line 1980
<   free_cpumask_var(new_cpu_mask);
< #line 1981
<   crypto_free_hash(csums_tfm);
< #line 1982
<   crypto_free_hash(verify_tfm);
< #line 1983
<   reply->ret_code = retcode;
< #line 1984
<   return (0);
< }
< }
< #line 1987 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_invalidate(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                               struct drbd_nl_cfg_reply *reply ) 
< { 
<   int retcode ;
<   int tmp ;
<   wait_queue_t __wait ;
<   struct task_struct *tmp___0 ;
<   int tmp___1 ;
<   union drbd_state val ;
<   union drbd_state mask ;
<   enum drbd_state_rv tmp___2 ;
<   union drbd_state val___0 ;
<   union drbd_state mask___0 ;
<   union drbd_state __ns ;
<   enum drbd_state_rv tmp___3 ;
<   union drbd_state val___1 ;
<   union drbd_state mask___1 ;
< 
<   {
< #line 1995
<   drbd_suspend_io(mdev);
< #line 1996
<   tmp = drbd_test_flag(mdev, BITMAP_IO);
< #line 1996
<   if (tmp == 0) {
< #line 1996
<     goto ldv_54389;
<   } else {
< 
<   }
< #line 1996
<   tmp___0 = get_current();
< #line 1996
<   __wait.flags = 0U;
< #line 1996
<   __wait.private = (void *)tmp___0;
< #line 1996
<   __wait.func = & autoremove_wake_function;
< #line 1996
<   __wait.task_list.next = & __wait.task_list;
< #line 1996
<   __wait.task_list.prev = & __wait.task_list;
<   ldv_54392: 
< #line 1996
<   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
< #line 1996
<   tmp___1 = drbd_test_flag(mdev, BITMAP_IO);
< #line 1996
<   if (tmp___1 == 0) {
< #line 1996
<     goto ldv_54391;
<   } else {
< 
<   }
< #line 1996
<   schedule();
< #line 1996
<   goto ldv_54392;
<   ldv_54391: 
< #line 1996
<   finish_wait(& mdev->misc_wait, & __wait);
<   ldv_54389: 
< #line 1997
<   drbd_flush_workqueue(mdev);
< #line 1999
<   val.i = 0U;
< #line 1999
<   val.ldv_40583.conn = 12U;
< #line 1999
<   mask.i = 0U;
< #line 1999
<   mask.ldv_40583.conn = 31U;
< #line 1999
<   tmp___2 = _drbd_request_state(mdev, mask, val, CS_ORDERED);
< #line 1999
<   retcode = (int )tmp___2;
< #line 2001
<   if (retcode <= 0 && retcode != -15) {
< #line 2002
<     val___0.i = 0U;
< #line 2002
<     val___0.ldv_40583.conn = 12U;
< #line 2002
<     mask___0.i = 0U;
< #line 2002
<     mask___0.ldv_40583.conn = 31U;
< #line 2002
<     retcode = drbd_request_state(mdev, mask___0, val___0);
<   } else {
< 
<   }
< #line 2004
<   goto ldv_54409;
<   ldv_54408: 
< #line 2005
<   spin_lock_irq(& mdev->req_lock);
< #line 2006
<   if ((int )mdev->state.ldv_40583.conn <= 9) {
< #line 2007
<     __ns.i = mdev->state.i;
< #line 2007
<     __ns.ldv_40583.disk = 4U;
< #line 2007
<     tmp___3 = _drbd_set_state(mdev, __ns, CS_VERBOSE, 0);
< #line 2007
<     retcode = (int )tmp___3;
---
> #line 1817
>   conn_old_common_state(tconn, & os, & flags);
> #line 1818
>   flags = (enum chg_state_flags )((unsigned int )flags | 1024U);
> #line 1819
>   conn_set_state(tconn, mask, val, & ns_min, & ns_max, flags);
> #line 1820
>   conn_pr_state_change(tconn, os, ns_max, flags);
> #line 1822
>   tmp___6 = kmalloc(48UL, 32U);
> #line 1822
>   acscw = (struct after_conn_state_chg_work *)tmp___6;
> #line 1823
>   if ((unsigned long )acscw != (unsigned long )((struct after_conn_state_chg_work *)0)) {
> #line 1824
>     acscw->oc = (enum drbd_conns )os.ldv_40604.conn;
> #line 1825
>     acscw->ns_min = ns_min;
> #line 1826
>     acscw->ns_max = ns_max;
> #line 1827
>     acscw->flags = flags;
> #line 1828
>     acscw->w.cb = & w_after_conn_state_ch;
> #line 1829
>     kref_get(& tconn->kref);
> #line 1830
>     acscw->w.ldv_50388.tconn = tconn;
> #line 1831
>     drbd_queue_work(& tconn->sender_work, & acscw->w);
59066c64248,64249
< 
---
> #line 1833
>     printk("\vd-con %s: Could not kmalloc an acscw\n", tconn->name);
59068,59073c64251,64260
< #line 2008
<   spin_unlock_irq(& mdev->req_lock);
< #line 2010
<   if (retcode != -15) {
< #line 2011
<     goto ldv_54403;
---
>   abort: ;
> #line 1837
>   if ((int )have_mutex) {
> #line 1840
>     spin_unlock_irq(& tconn->req_lock);
>     abort_unlocked: 
> #line 1842
>     mutex_unlock(& tconn->cstate_mutex);
> #line 1843
>     spin_lock_irq(& tconn->req_lock);
59077,59091c64264,64277
< #line 2013
<   val___1.i = 0U;
< #line 2013
<   val___1.ldv_40583.conn = 12U;
< #line 2013
<   mask___1.i = 0U;
< #line 2013
<   mask___1.ldv_40583.conn = 31U;
< #line 2013
<   retcode = drbd_request_state(mdev, mask___1, val___1);
<   ldv_54409: ;
< #line 2004
<   if (retcode == -15) {
< #line 2005
<     goto ldv_54408;
---
> #line 1845
>   if ((int )rv <= 0 && ((unsigned int )flags & 2U) != 0U) {
> #line 1846
>     tmp___7 = drbd_set_st_err_str(rv);
> #line 1846
>     printk("\vd-con %s: State change failed: %s\n", tconn->name, tmp___7);
> #line 1847
>     printk("\vd-con %s:  mask = 0x%x val = 0x%x\n", tconn->name, mask.i, val.i);
> #line 1848
>     tmp___8 = drbd_conn_str((enum drbd_conns )val.ldv_40604.conn);
> #line 1848
>     tmp___9 = drbd_conn_str(oc);
> #line 1848
>     printk("\vd-con %s:  old_conn:%s wanted_conn:%s\n", tconn->name, tmp___9, tmp___8);
59095,59114c64281
<   ldv_54403: 
< #line 2015
<   drbd_resume_io(mdev);
< #line 2017
<   reply->ret_code = retcode;
< #line 2018
<   return (0);
< }
< }
< #line 2021 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_bmio_set_susp_al(struct drbd_conf *mdev ) 
< { 
<   int rv ;
< 
<   {
< #line 2025
<   rv = drbd_bmio_set_n_write(mdev);
< #line 2026
<   drbd_suspend_al(mdev);
< #line 2027
---
> #line 1850
59118,59248c64285,64287
< #line 2030 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_invalidate_peer(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                                    struct drbd_nl_cfg_reply *reply ) 
< { 
<   int retcode ;
<   int tmp ;
<   wait_queue_t __wait ;
<   struct task_struct *tmp___0 ;
<   int tmp___1 ;
<   union drbd_state val ;
<   union drbd_state mask ;
<   enum drbd_state_rv tmp___2 ;
<   union drbd_state val___0 ;
<   union drbd_state mask___0 ;
<   int tmp___3 ;
<   union drbd_state val___1 ;
<   union drbd_state mask___1 ;
< 
<   {
< #line 2038
<   drbd_suspend_io(mdev);
< #line 2039
<   tmp = drbd_test_flag(mdev, BITMAP_IO);
< #line 2039
<   if (tmp == 0) {
< #line 2039
<     goto ldv_54420;
<   } else {
< 
<   }
< #line 2039
<   tmp___0 = get_current();
< #line 2039
<   __wait.flags = 0U;
< #line 2039
<   __wait.private = (void *)tmp___0;
< #line 2039
<   __wait.func = & autoremove_wake_function;
< #line 2039
<   __wait.task_list.next = & __wait.task_list;
< #line 2039
<   __wait.task_list.prev = & __wait.task_list;
<   ldv_54423: 
< #line 2039
<   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
< #line 2039
<   tmp___1 = drbd_test_flag(mdev, BITMAP_IO);
< #line 2039
<   if (tmp___1 == 0) {
< #line 2039
<     goto ldv_54422;
<   } else {
< 
<   }
< #line 2039
<   schedule();
< #line 2039
<   goto ldv_54423;
<   ldv_54422: 
< #line 2039
<   finish_wait(& mdev->misc_wait, & __wait);
<   ldv_54420: 
< #line 2040
<   drbd_flush_workqueue(mdev);
< #line 2042
<   val.i = 0U;
< #line 2042
<   val.ldv_40583.conn = 11U;
< #line 2042
<   mask.i = 0U;
< #line 2042
<   mask.ldv_40583.conn = 31U;
< #line 2042
<   tmp___2 = _drbd_request_state(mdev, mask, val, CS_ORDERED);
< #line 2042
<   retcode = (int )tmp___2;
< #line 2044
<   if (retcode <= 0) {
< #line 2045
<     if (retcode == -15 && (unsigned int )*((unsigned char *)mdev + 2276UL) == 1U) {
< #line 2048
<       val___0.i = 0U;
< #line 2048
<       val___0.ldv_40583.pdsk = 4U;
< #line 2048
<       mask___0.i = 0U;
< #line 2048
<       mask___0.ldv_40583.pdsk = 15U;
< #line 2048
<       retcode = drbd_request_state(mdev, mask___0, val___0);
< #line 2049
<       if (retcode > 0) {
< #line 2050
<         tmp___3 = drbd_bitmap_io(mdev, & drbd_bmio_set_susp_al, (char *)"set_n_write from invalidate_peer",
<                                  BM_LOCKED_SET_ALLOWED);
< #line 2050
<         if (tmp___3 != 0) {
< #line 2053
<           retcode = 118;
<         } else {
< 
<         }
<       } else {
< 
<       }
<     } else {
< #line 2056
<       val___1.i = 0U;
< #line 2056
<       val___1.ldv_40583.conn = 11U;
< #line 2056
<       mask___1.i = 0U;
< #line 2056
<       mask___1.ldv_40583.conn = 31U;
< #line 2056
<       retcode = drbd_request_state(mdev, mask___1, val___1);
<     }
<   } else {
< 
<   }
< #line 2058
<   drbd_resume_io(mdev);
< #line 2060
<   reply->ret_code = retcode;
< #line 2061
<   return (0);
< }
< }
< #line 2064 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_pause_sync(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                               struct drbd_nl_cfg_reply *reply ) 
---
> #line 1854 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_state.c.prepared"
> enum drbd_state_rv conn_request_state(struct drbd_tconn *tconn , union drbd_state mask ,
>                                       union drbd_state val , enum chg_state_flags flags ) 
59250,59253c64289
<   int retcode ;
<   union drbd_state val ;
<   union drbd_state mask ;
<   int tmp ;
---
>   enum drbd_state_rv rv ;
59256,59278c64292,64299
< #line 2067
<   retcode = 101;
< #line 2069
<   val.i = 0U;
< #line 2069
<   val.ldv_40583.user_isp = 1U;
< #line 2069
<   mask.i = 0U;
< #line 2069
<   mask.ldv_40583.user_isp = 1U;
< #line 2069
<   tmp = drbd_request_state(mdev, mask, val);
< #line 2069
<   if (tmp == 2) {
< #line 2070
<     retcode = 134;
<   } else {
< 
<   }
< #line 2072
<   reply->ret_code = retcode;
< #line 2073
<   return (0);
---
> #line 1859
>   spin_lock_irq(& tconn->req_lock);
> #line 1860
>   rv = _conn_request_state(tconn, mask, val, flags);
> #line 1861
>   spin_unlock_irq(& tconn->req_lock);
> #line 1863
>   return (rv);
59281,59283c64302,64305
< #line 2076 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_resume_sync(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                                struct drbd_nl_cfg_reply *reply ) 
---
> #line 238 "include/net/netlink.h"
> extern int nla_parse(struct nlattr ** , int  , struct nlattr  const  * , int  , struct nla_policy  const  * ) ;
> #line 672 "include/net/netlink.h"
> __inline static int nla_type(struct nlattr  const  *nla ) 
59285,59316d64306
<   int retcode ;
<   union drbd_state s ;
<   union drbd_state val ;
<   union drbd_state mask ;
<   int tmp ;
< 
<   {
< #line 2079
<   retcode = 101;
< #line 2082
<   val.i = 0U;
< #line 2082
<   val.ldv_40583.user_isp = 0U;
< #line 2082
<   mask.i = 0U;
< #line 2082
<   mask.ldv_40583.user_isp = 1U;
< #line 2082
<   tmp = drbd_request_state(mdev, mask, val);
< #line 2082
<   if (tmp == 2) {
< #line 2083
<     s = mdev->state;
< #line 2084
<     if ((unsigned int )*((unsigned short *)(& s) + 0UL) == 320U || (unsigned int )*((unsigned short *)(& s) + 0UL) == 336U) {
< #line 2085
<       retcode = (unsigned int )*((unsigned char *)(& s) + 2UL) == 0U ? ((unsigned int )*((unsigned char *)(& s) + 2UL) != 0U ? 157 : 135) : 156;
<     } else {
< #line 2088
<       retcode = 135;
<     }
<   } else {
59318,59330d64307
<   }
< #line 2092
<   reply->ret_code = retcode;
< #line 2093
<   return (0);
< }
< }
< #line 2096 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_suspend_io(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                               struct drbd_nl_cfg_reply *reply ) 
< { 
<   union drbd_state val ;
<   union drbd_state mask ;
59333,59344c64310,64311
< #line 2099
<   val.i = 0U;
< #line 2099
<   val.ldv_40583.susp = 1U;
< #line 2099
<   mask.i = 0U;
< #line 2099
<   mask.ldv_40583.susp = 1U;
< #line 2099
<   reply->ret_code = drbd_request_state(mdev, mask, val);
< #line 2101
<   return (0);
---
> #line 674
>   return ((int )nla->nla_type & -49153);
59347,59349c64314,64315
< #line 2104 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_resume_io(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                              struct drbd_nl_cfg_reply *reply ) 
---
> #line 700 "include/net/netlink.h"
> __inline static int nla_ok(struct nlattr  const  *nla , int remaining ) 
59351,59403d64316
<   int tmp ;
<   union drbd_state val ;
<   union drbd_state mask ;
< 
<   {
< #line 2107
<   tmp = drbd_test_flag(mdev, NEW_CUR_UUID);
< #line 2107
<   if (tmp != 0) {
< #line 2108
<     drbd_uuid_new_current(mdev);
< #line 2109
<     drbd_clear_flag(mdev, NEW_CUR_UUID);
<   } else {
< 
<   }
< #line 2111
<   drbd_suspend_io(mdev);
< #line 2112
<   val.i = 0U;
< #line 2112
<   val.ldv_40583.susp = 0U;
< #line 2112
<   val.ldv_40583.susp_nod = 0U;
< #line 2112
<   val.ldv_40583.susp_fen = 0U;
< #line 2112
<   mask.i = 0U;
< #line 2112
<   mask.ldv_40583.susp = 1U;
< #line 2112
<   mask.ldv_40583.susp_nod = 1U;
< #line 2112
<   mask.ldv_40583.susp_fen = 1U;
< #line 2112
<   reply->ret_code = drbd_request_state(mdev, mask, val);
< #line 2113
<   if (reply->ret_code == 1) {
< #line 2114
<     if ((int )mdev->state.ldv_40583.conn <= 9) {
< #line 2115
<       tl_clear(mdev);
<     } else {
< 
<     }
< #line 2116
<     if ((unsigned int )*((unsigned char *)mdev + 2277UL) == 0U || (unsigned int )*((unsigned char *)mdev + 2277UL) == 4U) {
< #line 2117
<       tl_restart(mdev, fail_frozen_disk_io);
<     } else {
< 
<     }
<   } else {
59405,59417d64317
<   }
< #line 2119
<   drbd_resume_io(mdev);
< #line 2121
<   return (0);
< }
< }
< #line 2124 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_outdate(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                            struct drbd_nl_cfg_reply *reply ) 
< { 
<   union drbd_state val ;
<   union drbd_state mask ;
59420,59431c64320,64321
< #line 2127
<   val.i = 0U;
< #line 2127
<   val.ldv_40583.disk = 5U;
< #line 2127
<   mask.i = 0U;
< #line 2127
<   mask.ldv_40583.disk = 15U;
< #line 2127
<   reply->ret_code = drbd_request_state(mdev, mask, val);
< #line 2128
<   return (0);
---
> #line 702
>   return ((remaining > 3 && (unsigned int )((unsigned short )nla->nla_len) > 3U) && (int )nla->nla_len <= remaining);
59434,59436c64324,64325
< #line 2131 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_get_config(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                               struct drbd_nl_cfg_reply *reply ) 
---
> #line 715 "include/net/netlink.h"
> __inline static struct nlattr *nla_next(struct nlattr  const  *nla , int *remaining ) 
59438,59442c64327
<   unsigned short *tl ;
<   int tmp ;
<   int tmp___0 ;
<   void *__gu_p ;
<   unsigned short *tmp___1 ;
---
>   int totlen ;
59445,59507c64330,64335
< #line 2136
<   tl = (unsigned short *)(& reply->tag_list);
< #line 2138
<   tmp = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 2138
<   if (tmp != 0) {
< #line 2139
<     tl = disk_conf_to_tags(mdev, & (mdev->ldev)->dc, tl);
< #line 2140
<     put_ldev(mdev);
<   } else {
< 
<   }
< #line 2143
<   tmp___0 = get_net_conf(mdev);
< #line 2143
<   if (tmp___0 != 0) {
< #line 2144
<     tl = net_conf_to_tags(mdev, mdev->net_conf, tl);
< #line 2145
<     put_net_conf(mdev);
<   } else {
< 
<   }
< #line 2147
<   tl = syncer_conf_to_tags(mdev, & mdev->sync_conf, tl);
< #line 2149
<   tmp___1 = tl;
< #line 2149
<   tl = tl + 1;
< #line 2149
<   __gu_p = (void *)tmp___1;
< #line 2149
<   switch (2UL) {
<   case 1UL: 
< #line 2149
<   *((u8 *)__gu_p) = 0U;
< #line 2149
<   goto ldv_54492;
<   case 2UL: 
< #line 2149
<   put_unaligned_le16(0, __gu_p);
< #line 2149
<   goto ldv_54492;
<   case 4UL: 
< #line 2149
<   put_unaligned_le32(0U, __gu_p);
< #line 2149
<   goto ldv_54492;
<   case 8UL: 
< #line 2149
<   put_unaligned_le64(0ULL, __gu_p);
< #line 2149
<   goto ldv_54492;
<   default: 
< #line 2149
<   __bad_unaligned_access_size();
< #line 2149
<   goto ldv_54492;
<   }
<   ldv_54492: ;
< #line 2151
<   return ((int )((unsigned int )((long )tl) - (unsigned int )((long )(& reply->tag_list))));
---
> #line 717
>   totlen = ((int )nla->nla_len + 3) & -4;
> #line 719
>   *remaining = *remaining - totlen;
> #line 720
>   return ((struct nlattr *)nla + (unsigned long )totlen);
59510,59512c64338,64339
< #line 2154 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_get_state(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                              struct drbd_nl_cfg_reply *reply ) 
---
> #line 731 "include/net/netlink.h"
> __inline static struct nlattr *nla_find_nested(struct nlattr  const  *nla , int attrtype ) 
59514,59517d64340
<   unsigned short *tl ;
<   union drbd_state s ;
<   unsigned long rs_left ;
<   unsigned int res ;
59519,59595c64342,64343
<   void *__gu_p ;
<   unsigned short *tmp___0 ;
< 
<   {
< #line 2157
<   tl = (unsigned short *)(& reply->tag_list);
< #line 2158
<   s = mdev->state;
< #line 2162
<   tl = get_state_to_tags(mdev, (struct get_state *)(& s), tl);
< #line 2165
<   if ((int )s.ldv_40583.conn > 15 && (int )s.ldv_40583.conn <= 21) {
< #line 2166
<     tmp = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 2166
<     if (tmp != 0) {
< #line 2167
<       drbd_get_syncer_progress(mdev, & rs_left, & res);
< #line 2168
<       tl = tl_add_int(tl, T_sync_progress, (void const   *)(& res));
< #line 2169
<       put_ldev(mdev);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 2172
<   tmp___0 = tl;
< #line 2172
<   tl = tl + 1;
< #line 2172
<   __gu_p = (void *)tmp___0;
< #line 2172
<   switch (2UL) {
<   case 1UL: 
< #line 2172
<   *((u8 *)__gu_p) = 0U;
< #line 2172
<   goto ldv_54508;
<   case 2UL: 
< #line 2172
<   put_unaligned_le16(0, __gu_p);
< #line 2172
<   goto ldv_54508;
<   case 4UL: 
< #line 2172
<   put_unaligned_le32(0U, __gu_p);
< #line 2172
<   goto ldv_54508;
<   case 8UL: 
< #line 2172
<   put_unaligned_le64(0ULL, __gu_p);
< #line 2172
<   goto ldv_54508;
<   default: 
< #line 2172
<   __bad_unaligned_access_size();
< #line 2172
<   goto ldv_54508;
<   }
<   ldv_54508: ;
< #line 2174
<   return ((int )((unsigned int )((long )tl) - (unsigned int )((long )(& reply->tag_list))));
< }
< }
< #line 2177 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_get_uuids(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                              struct drbd_nl_cfg_reply *reply ) 
< { 
<   unsigned short *tl ;
<   unsigned long flags ;
<   raw_spinlock_t *tmp ;
<   int tmp___0 ;
<   void *__gu_p ;
<   unsigned short *tmp___1 ;
---
>   void *tmp___0 ;
>   struct nlattr *tmp___1 ;
59598,59655c64346,64353
< #line 2182
<   tl = (unsigned short *)(& reply->tag_list);
< #line 2184
<   tmp___0 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 2184
<   if (tmp___0 != 0) {
< #line 2186
<     tmp = spinlock_check(& (mdev->ldev)->md.uuid_lock);
< #line 2186
<     flags = _raw_spin_lock_irqsave(tmp);
< #line 2187
<     tl = tl_add_blob(tl, T_uuids, (void const   *)(& (mdev->ldev)->md.uuid), 32);
< #line 2188
<     tl = tl_add_int(tl, T_uuids_flags, (void const   *)(& (mdev->ldev)->md.flags));
< #line 2189
<     spin_unlock_irqrestore(& (mdev->ldev)->md.uuid_lock, flags);
< #line 2190
<     put_ldev(mdev);
<   } else {
< 
<   }
< #line 2192
<   tmp___1 = tl;
< #line 2192
<   tl = tl + 1;
< #line 2192
<   __gu_p = (void *)tmp___1;
< #line 2192
<   switch (2UL) {
<   case 1UL: 
< #line 2192
<   *((u8 *)__gu_p) = 0U;
< #line 2192
<   goto ldv_54525;
<   case 2UL: 
< #line 2192
<   put_unaligned_le16(0, __gu_p);
< #line 2192
<   goto ldv_54525;
<   case 4UL: 
< #line 2192
<   put_unaligned_le32(0U, __gu_p);
< #line 2192
<   goto ldv_54525;
<   case 8UL: 
< #line 2192
<   put_unaligned_le64(0ULL, __gu_p);
< #line 2192
<   goto ldv_54525;
<   default: 
< #line 2192
<   __bad_unaligned_access_size();
< #line 2192
<   goto ldv_54525;
<   }
<   ldv_54525: ;
< #line 2194
<   return ((int )((unsigned int )((long )tl) - (unsigned int )((long )(& reply->tag_list))));
---
> #line 733
>   tmp = nla_len(nla);
> #line 733
>   tmp___0 = nla_data(nla);
> #line 733
>   tmp___1 = nla_find((struct nlattr  const  *)tmp___0, tmp, attrtype);
> #line 733
>   return (tmp___1);
59658,59660c64356,64358
< #line 2203 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_get_timeout_flag(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                                     struct drbd_nl_cfg_reply *reply ) 
---
> #line 745 "include/net/netlink.h"
> __inline static int nla_parse_nested(struct nlattr **tb , int maxtype , struct nlattr  const  *nla ,
>                                      struct nla_policy  const  *policy ) 
59662,59663d64359
<   unsigned short *tl ;
<   char rv ;
59665,59666c64361,64362
<   void *__gu_p ;
<   unsigned short *tmp___0 ;
---
>   void *tmp___0 ;
>   int tmp___1 ;
59669,59719c64365,64372
< #line 2209
<   tl = (unsigned short *)(& reply->tag_list);
< #line 2211
<   if (*((unsigned int *)mdev + 569UL) != 40960U) {
< #line 2211
<     tmp = drbd_test_flag(mdev, USE_DEGR_WFC_T);
< #line 2211
<     rv = tmp != 0;
<   } else {
< #line 2211
<     rv = 2;
<   }
< #line 2214
<   tl = tl_add_blob(tl, T_use_degraded, (void const   *)(& rv), 1);
< #line 2215
<   tmp___0 = tl;
< #line 2215
<   tl = tl + 1;
< #line 2215
<   __gu_p = (void *)tmp___0;
< #line 2215
<   switch (2UL) {
<   case 1UL: 
< #line 2215
<   *((u8 *)__gu_p) = 0U;
< #line 2215
<   goto ldv_54539;
<   case 2UL: 
< #line 2215
<   put_unaligned_le16(0, __gu_p);
< #line 2215
<   goto ldv_54539;
<   case 4UL: 
< #line 2215
<   put_unaligned_le32(0U, __gu_p);
< #line 2215
<   goto ldv_54539;
<   case 8UL: 
< #line 2215
<   put_unaligned_le64(0ULL, __gu_p);
< #line 2215
<   goto ldv_54539;
<   default: 
< #line 2215
<   __bad_unaligned_access_size();
< #line 2215
<   goto ldv_54539;
<   }
<   ldv_54539: ;
< #line 2217
<   return ((int )((unsigned int )((long )tl) - (unsigned int )((long )(& reply->tag_list))));
---
> #line 749
>   tmp = nla_len(nla);
> #line 749
>   tmp___0 = nla_data(nla);
> #line 749
>   tmp___1 = nla_parse(tb, maxtype, (struct nlattr  const  *)tmp___0, tmp, policy);
> #line 749
>   return (tmp___1);
59722,59724c64375,64376
< #line 2220 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_start_ov(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                             struct drbd_nl_cfg_reply *reply ) 
---
> #line 14 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nla.c.prepared"
> static int drbd_nla_check_mandatory(int maxtype , struct nlattr *nla ) 
59726,59727c64378,64380
<   struct start_ov args ;
<   int tmp ;
---
>   struct nlattr *head ;
>   void *tmp ;
>   int len ;
59729,59730c64382,64383
<   wait_queue_t __wait ;
<   struct task_struct *tmp___1 ;
---
>   int rem ;
>   int tmp___1 ;
59732,59824d64384
<   union drbd_state val ;
<   union drbd_state mask ;
< 
<   {
< #line 2224
<   args.start_sector = (unsigned long long )mdev->ov_start_sector;
< #line 2224
<   args.stop_sector = 0xffffffffffffffffULL;
< #line 2229
<   tmp = start_ov_from_tags(mdev, (unsigned short *)(& nlp->tag_list), & args);
< #line 2229
<   if (tmp == 0) {
< #line 2230
<     reply->ret_code = 126;
< #line 2231
<     return (0);
<   } else {
< 
<   }
< #line 2236
<   drbd_suspend_io(mdev);
< #line 2237
<   tmp___0 = drbd_test_flag(mdev, BITMAP_IO);
< #line 2237
<   if (tmp___0 == 0) {
< #line 2237
<     goto ldv_54550;
<   } else {
< 
<   }
< #line 2237
<   tmp___1 = get_current();
< #line 2237
<   __wait.flags = 0U;
< #line 2237
<   __wait.private = (void *)tmp___1;
< #line 2237
<   __wait.func = & autoremove_wake_function;
< #line 2237
<   __wait.task_list.next = & __wait.task_list;
< #line 2237
<   __wait.task_list.prev = & __wait.task_list;
<   ldv_54553: 
< #line 2237
<   prepare_to_wait(& mdev->misc_wait, & __wait, 2);
< #line 2237
<   tmp___2 = drbd_test_flag(mdev, BITMAP_IO);
< #line 2237
<   if (tmp___2 == 0) {
< #line 2237
<     goto ldv_54552;
<   } else {
< 
<   }
< #line 2237
<   schedule();
< #line 2237
<   goto ldv_54553;
<   ldv_54552: 
< #line 2237
<   finish_wait(& mdev->misc_wait, & __wait);
<   ldv_54550: 
< #line 2240
<   mdev->ov_start_sector = (sector_t )args.start_sector & 0xfffffffffffffff8UL;
< #line 2241
<   mdev->ov_stop_sector = (sector_t )args.stop_sector;
< #line 2242
<   val.i = 0U;
< #line 2242
<   val.ldv_40583.conn = 18U;
< #line 2242
<   mask.i = 0U;
< #line 2242
<   mask.ldv_40583.conn = 31U;
< #line 2242
<   reply->ret_code = drbd_request_state(mdev, mask, val);
< #line 2243
<   drbd_resume_io(mdev);
< #line 2244
<   return (0);
< }
< }
< #line 2248 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static int drbd_nl_new_c_uuid(struct drbd_conf *mdev , struct drbd_nl_cfg_req *nlp ,
<                               struct drbd_nl_cfg_reply *reply ) 
< { 
<   int retcode ;
<   int skip_initial_sync ;
<   int err ;
<   struct new_c_uuid args ;
<   int tmp ;
<   int tmp___0 ;
<   union drbd_state __ns ;
59827,59911c64387,64411
< #line 2251
<   retcode = 101;
< #line 2252
<   skip_initial_sync = 0;
< #line 2257
<   memset((void *)(& args), 0, 4UL);
< #line 2258
<   tmp = new_c_uuid_from_tags(mdev, (unsigned short *)(& nlp->tag_list), & args);
< #line 2258
<   if (tmp == 0) {
< #line 2259
<     reply->ret_code = 126;
< #line 2260
<     return (0);
<   } else {
< 
<   }
< #line 2263
<   mutex_lock_nested(& mdev->state_mutex, 0U);
< #line 2265
<   tmp___0 = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 2265
<   if (tmp___0 == 0) {
< #line 2266
<     retcode = 138;
< #line 2267
<     goto out;
<   } else {
< 
<   }
< #line 2271
<   if ((((unsigned int )*((unsigned short *)mdev + 1138UL) == 160U && mdev->agreed_pro_version > 89) && (mdev->ldev)->md.uuid[0] == 4ULL) && (unsigned int )*((unsigned char *)(& args) + 0UL) != 0U) {
< #line 2273
<     _dev_info((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Preparing to skip initial sync\n");
< #line 2274
<     skip_initial_sync = 1;
<   } else
< #line 2275
<   if ((unsigned int )*((unsigned short *)mdev + 1138UL) != 0U) {
< #line 2276
<     retcode = 151;
< #line 2277
<     goto out_dec;
<   } else {
< 
<   }
< #line 2280
<   drbd_uuid_set(mdev, 1, 0ULL);
< #line 2281
<   drbd_uuid_new_current(mdev);
< #line 2283
<   if ((unsigned int )*((unsigned char *)(& args) + 0UL) != 0U) {
< #line 2284
<     err = drbd_bitmap_io(mdev, & drbd_bmio_clear_n_write, (char *)"clear_n_write from new_c_uuid",
<                          BM_LOCKED_MASK);
< #line 2286
<     if (err != 0) {
< #line 2287
<       dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "Writing bitmap failed with %d\n",
<               err);
< #line 2288
<       retcode = 118;
<     } else {
< 
<     }
< #line 2290
<     if (skip_initial_sync != 0) {
< #line 2291
<       drbd_send_uuids_skip_initial_sync(mdev);
< #line 2292
<       _drbd_uuid_set(mdev, 1, 0ULL);
< #line 2293
<       drbd_print_uuids(mdev, "cleared bitmap UUID");
< #line 2294
<       spin_lock_irq(& mdev->req_lock);
< #line 2295
<       __ns.i = mdev->state.i;
< #line 2295
<       __ns.ldv_40583.disk = 8U;
< #line 2295
<       __ns.ldv_40583.pdsk = 8U;
< #line 2295
<       _drbd_set_state(mdev, __ns, CS_VERBOSE, 0);
< #line 2297
<       spin_unlock_irq(& mdev->req_lock);
---
> #line 16
>   tmp = nla_data((struct nlattr  const  *)nla);
> #line 16
>   head = (struct nlattr *)tmp;
> #line 17
>   tmp___0 = nla_len((struct nlattr  const  *)nla);
> #line 17
>   len = tmp___0;
> #line 28
>   nla = head;
> #line 28
>   rem = len;
> #line 28
>   goto ldv_51705;
>   ldv_51704: ;
> #line 29
>   if (((int )nla->nla_type & 16384) != 0) {
> #line 30
>     nla->nla_type = (unsigned int )nla->nla_type & 49151U;
> #line 31
>     tmp___1 = nla_type((struct nlattr  const  *)nla);
> #line 31
>     if (tmp___1 > maxtype) {
> #line 32
>       return (-95);
59918,60805c64418,64426
< #line 2301
<   drbd_md_sync(mdev);
<   out_dec: 
< #line 2303
<   put_ldev(mdev);
<   out: 
< #line 2305
<   mutex_unlock(& mdev->state_mutex);
< #line 2307
<   reply->ret_code = retcode;
< #line 2308
<   return (0);
< }
< }
< #line 2318 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static struct cn_handler_struct cnd_table[27U]  = 
< #line 2318
<   {      {0, 0}, 
<         {& drbd_nl_primary, 0}, 
<         {& drbd_nl_secondary, 0}, 
<         {& drbd_nl_disk_conf, 0}, 
<         {& drbd_nl_detach, 0}, 
<         {& drbd_nl_net_conf, 0}, 
<         {& drbd_nl_disconnect, 0}, 
<         {& drbd_nl_resize, 0}, 
<         {& drbd_nl_syncer_conf, 0}, 
<         {& drbd_nl_invalidate, 0}, 
<         {& drbd_nl_invalidate_peer, 0}, 
<         {& drbd_nl_pause_sync, 0}, 
<         {& drbd_nl_resume_sync, 0}, 
<         {& drbd_nl_suspend_io, 0}, 
<         {& drbd_nl_resume_io, 0}, 
<         {& drbd_nl_outdate, 0}, 
<         {& drbd_nl_get_config, 1320}, 
<         {& drbd_nl_get_state, 16}, 
<         {& drbd_nl_get_uuids, 48}, 
<         {& drbd_nl_get_timeout_flag, 8}, 
<         {0, 0}, 
<         {0, 0}, 
<         {0, 0}, 
<         {0, 0}, 
<         {0, 0}, 
<         {& drbd_nl_start_ov, 0}, 
<         {& drbd_nl_new_c_uuid, 0}};
< #line 2349 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static void drbd_connector_callback(struct cn_msg *req , struct netlink_skb_parms *nsp ) 
< { 
<   struct drbd_nl_cfg_req *nlp ;
<   struct cn_handler_struct *cm ;
<   struct cn_msg *cn_reply ;
<   struct drbd_nl_cfg_reply *reply ;
<   struct drbd_conf *mdev ;
<   int retcode ;
<   int rr ;
<   int reply_size ;
<   bool tmp ;
<   int tmp___0 ;
<   bool tmp___1 ;
<   int tmp___2 ;
<   void *tmp___3 ;
< 
<   {
< #line 2351
<   nlp = (struct drbd_nl_cfg_req *)(& req->data);
< #line 2357
<   reply_size = 34;
< #line 2361
<   tmp = ldv_try_module_get_7(& __this_module);
< #line 2361
<   if (tmp) {
< #line 2361
<     tmp___0 = 0;
<   } else {
< #line 2361
<     tmp___0 = 1;
<   }
< #line 2361
<   if (tmp___0) {
< #line 2362
<     printk("\vdrbd: try_module_get() failed!\n");
< #line 2363
<     return;
<   } else {
< 
<   }
< #line 2366
<   tmp___1 = capable(21);
< #line 2366
<   if (tmp___1) {
< #line 2366
<     tmp___2 = 0;
<   } else {
< #line 2366
<     tmp___2 = 1;
<   }
< #line 2366
<   if (tmp___2) {
< #line 2367
<     retcode = 152;
< #line 2368
<     goto fail;
<   } else {
< 
<   }
< #line 2371
<   mdev = ensure_mdev((int )nlp->drbd_minor, nlp->flags & 1);
< #line 2373
<   if ((unsigned long )mdev == (unsigned long )((struct drbd_conf *)0)) {
< #line 2374
<     retcode = 127;
< #line 2375
<     goto fail;
<   } else {
< 
<   }
< #line 2378
<   if (nlp->packet_type > 27 || nlp->packet_type == 27) {
< #line 2380
<     retcode = 137;
< #line 2381
<     goto fail;
<   } else {
< 
<   }
< #line 2384
<   cm = (struct cn_handler_struct *)(& cnd_table) + (unsigned long )nlp->packet_type;
< #line 2387
<   if ((unsigned long )cm->function == (unsigned long )((int (*)(struct drbd_conf * ,
<                                                                 struct drbd_nl_cfg_req * ,
<                                                                 struct drbd_nl_cfg_reply * ))0)) {
< #line 2388
<     retcode = 137;
< #line 2389
<     goto fail;
<   } else {
< 
<   }
< #line 2392
<   reply_size = cm->reply_body_size + reply_size;
< #line 2395
<   tmp___3 = kzalloc((size_t )reply_size, 208U);
< #line 2395
<   cn_reply = (struct cn_msg *)tmp___3;
< #line 2396
<   if ((unsigned long )cn_reply == (unsigned long )((struct cn_msg *)0)) {
< #line 2397
<     retcode = 122;
< #line 2398
<     goto fail;
<   } else {
< 
<   }
< #line 2400
<   reply = (struct drbd_nl_cfg_reply *)(& cn_reply->data);
< #line 2402
<   reply->packet_type = cm->reply_body_size != 0 ? nlp->packet_type : 27;
< #line 2404
<   reply->minor = nlp->drbd_minor;
< #line 2405
<   reply->ret_code = 101;
< #line 2408
<   rr = (*(cm->function))(mdev, nlp, reply);
< #line 2410
<   cn_reply->id = req->id;
< #line 2411
<   cn_reply->seq = req->seq;
< #line 2412
<   cn_reply->ack = req->ack + 1U;
< #line 2413
<   cn_reply->len = (unsigned int )((__u16 )rr) + 12U;
< #line 2414
<   cn_reply->flags = 0U;
< #line 2416
<   rr = cn_netlink_send(cn_reply, 8U, 208U);
< #line 2417
<   if (rr != 0 && rr != -3) {
< #line 2418
<     printk("\016drbd: cn_netlink_send()=%d\n", rr);
<   } else {
< 
<   }
< #line 2420
<   kfree((void const   *)cn_reply);
< #line 2421
<   ldv_module_put_8(& __this_module);
< #line 2422
<   return;
<   fail: 
< #line 2424
<   drbd_nl_send_reply(req, retcode);
< #line 2425
<   ldv_module_put_9(& __this_module);
< #line 2426
<   return;
< }
< }
< #line 2428 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static atomic_t drbd_nl_seq  =    {2};
< #line 2431 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static unsigned short *__tl_add_blob(unsigned short *tl , enum drbd_tags tag , void const   *data ,
<                                      unsigned short len , int nul_terminated ) 
< { 
<   unsigned short l ;
<   void *__gu_p ;
<   unsigned short *tmp ;
<   void *__gu_p___0 ;
<   unsigned short *tmp___0 ;
<   size_t __len ;
<   void *__ret ;
< 
<   {
< #line 2434
<   l = (unsigned short )tag_descriptions[(unsigned int )tag & 8191U].max_len;
< #line 2435
<   len = (int )len < (int )l ? len : l;
< #line 2436
<   tmp = tl;
< #line 2436
<   tl = tl + 1;
< #line 2436
<   __gu_p = (void *)tmp;
< #line 2436
<   switch (2UL) {
<   case 1UL: 
< #line 2436
<   *((u8 *)__gu_p) = (unsigned char )tag;
< #line 2436
<   goto ldv_54602;
<   case 2UL: 
< #line 2436
<   put_unaligned_le16((int )((unsigned short )tag), __gu_p);
< #line 2436
<   goto ldv_54602;
<   case 4UL: 
< #line 2436
<   put_unaligned_le32((unsigned int )tag, __gu_p);
< #line 2436
<   goto ldv_54602;
<   case 8UL: 
< #line 2436
<   put_unaligned_le64((unsigned long long )tag, __gu_p);
< #line 2436
<   goto ldv_54602;
<   default: 
< #line 2436
<   __bad_unaligned_access_size();
< #line 2436
<   goto ldv_54602;
<   }
<   ldv_54602: 
< #line 2437
<   tmp___0 = tl;
< #line 2437
<   tl = tl + 1;
< #line 2437
<   __gu_p___0 = (void *)tmp___0;
< #line 2437
<   switch (2UL) {
<   case 1UL: 
< #line 2437
<   *((u8 *)__gu_p___0) = (unsigned char )len;
< #line 2437
<   goto ldv_54609;
<   case 2UL: 
< #line 2437
<   put_unaligned_le16((int )len, __gu_p___0);
< #line 2437
<   goto ldv_54609;
<   case 4UL: 
< #line 2437
<   put_unaligned_le32((unsigned int )len, __gu_p___0);
< #line 2437
<   goto ldv_54609;
<   case 8UL: 
< #line 2437
<   put_unaligned_le64((unsigned long long )len, __gu_p___0);
< #line 2437
<   goto ldv_54609;
<   default: 
< #line 2437
<   __bad_unaligned_access_size();
< #line 2437
<   goto ldv_54609;
<   }
<   ldv_54609: 
< #line 2438
<   __len = (size_t )len;
< #line 2438
<   __ret = __builtin_memcpy((void *)tl, data, __len);
< #line 2439
<   tl = tl + (unsigned long )len;
< #line 2440
<   if (nul_terminated != 0) {
< #line 2441
<     *((char *)tl + 0xffffffffffffffffUL) = 0;
<   } else {
< 
<   }
< #line 2442
<   return (tl);
< }
< }
< #line 2446 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static unsigned short *tl_add_blob(unsigned short *tl , enum drbd_tags tag , void const   *data ,
<                                    int len ) 
< { 
<   unsigned short *tmp ;
< 
<   {
< #line 2448
<   tmp = __tl_add_blob(tl, tag, data, (int )((unsigned short )len), 0);
< #line 2448
<   return (tmp);
< }
< }
< #line 2452 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static unsigned short *tl_add_str(unsigned short *tl , enum drbd_tags tag , char const   *str ) 
< { 
<   size_t tmp ;
<   unsigned short *tmp___0 ;
< 
<   {
< #line 2454
<   tmp = strlen(str);
< #line 2454
<   tmp___0 = __tl_add_blob(tl, tag, (void const   *)str, (int )((unsigned int )((unsigned short )tmp) + 1U),
<                           0);
< #line 2454
<   return (tmp___0);
< }
< }
< #line 2458 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< static unsigned short *tl_add_int(unsigned short *tl , enum drbd_tags tag , void const   *val ) 
< { 
<   void *__gu_p ;
<   unsigned short *tmp ;
<   void *__gu_p___0 ;
<   unsigned short *tmp___0 ;
<   void *__gu_p___1 ;
<   void *__gu_p___2 ;
<   unsigned short *tmp___1 ;
<   void *__gu_p___3 ;
< 
<   {
< #line 2460
<   tmp = tl;
< #line 2460
<   tl = tl + 1;
< #line 2460
<   __gu_p = (void *)tmp;
< #line 2460
<   switch (2UL) {
<   case 1UL: 
< #line 2460
<   *((u8 *)__gu_p) = (unsigned char )tag;
< #line 2460
<   goto ldv_54635;
<   case 2UL: 
< #line 2460
<   put_unaligned_le16((int )((unsigned short )tag), __gu_p);
< #line 2460
<   goto ldv_54635;
<   case 4UL: 
< #line 2460
<   put_unaligned_le32((unsigned int )tag, __gu_p);
< #line 2460
<   goto ldv_54635;
<   case 8UL: 
< #line 2460
<   put_unaligned_le64((unsigned long long )tag, __gu_p);
< #line 2460
<   goto ldv_54635;
<   default: 
< #line 2460
<   __bad_unaligned_access_size();
< #line 2460
<   goto ldv_54635;
<   }
<   ldv_54635: ;
< #line 2461
<   switch ((unsigned int )tag & 49152U) {
<   case 0U: 
< #line 2463
<   tmp___0 = tl;
< #line 2463
<   tl = tl + 1;
< #line 2463
<   __gu_p___0 = (void *)tmp___0;
< #line 2463
<   switch (2UL) {
<   case 1UL: 
< #line 2463
<   *((u8 *)__gu_p___0) = 4U;
< #line 2463
<   goto ldv_54643;
<   case 2UL: 
< #line 2463
<   put_unaligned_le16(4, __gu_p___0);
< #line 2463
<   goto ldv_54643;
<   case 4UL: 
< #line 2463
<   put_unaligned_le32(4U, __gu_p___0);
< #line 2463
<   goto ldv_54643;
<   case 8UL: 
< #line 2463
<   put_unaligned_le64(4ULL, __gu_p___0);
< #line 2463
<   goto ldv_54643;
<   default: 
< #line 2463
<   __bad_unaligned_access_size();
< #line 2463
<   goto ldv_54643;
<   }
<   ldv_54643: 
< #line 2464
<   __gu_p___1 = (void *)tl;
< #line 2464
<   switch (4UL) {
<   case 1UL: 
< #line 2464
<   *((u8 *)__gu_p___1) = (unsigned char )*((int *)val);
< #line 2464
<   goto ldv_54650;
<   case 2UL: 
< #line 2464
<   put_unaligned_le16((int )((unsigned short )*((int *)val)), __gu_p___1);
< #line 2464
<   goto ldv_54650;
<   case 4UL: 
< #line 2464
<   put_unaligned_le32((unsigned int )*((int *)val), __gu_p___1);
< #line 2464
<   goto ldv_54650;
<   case 8UL: 
< #line 2464
<   put_unaligned_le64((unsigned long long )*((int *)val), __gu_p___1);
< #line 2464
<   goto ldv_54650;
<   default: 
< #line 2464
<   __bad_unaligned_access_size();
< #line 2464
<   goto ldv_54650;
<   }
<   ldv_54650: 
< #line 2465
<   tl = tl + 4U;
< #line 2466
<   goto ldv_54655;
<   case 16384U: 
< #line 2468
<   tmp___1 = tl;
< #line 2468
<   tl = tl + 1;
< #line 2468
<   __gu_p___2 = (void *)tmp___1;
< #line 2468
<   switch (2UL) {
<   case 1UL: 
< #line 2468
<   *((u8 *)__gu_p___2) = 8U;
< #line 2468
<   goto ldv_54659;
<   case 2UL: 
< #line 2468
<   put_unaligned_le16(8, __gu_p___2);
< #line 2468
<   goto ldv_54659;
<   case 4UL: 
< #line 2468
<   put_unaligned_le32(8U, __gu_p___2);
< #line 2468
<   goto ldv_54659;
<   case 8UL: 
< #line 2468
<   put_unaligned_le64(8ULL, __gu_p___2);
< #line 2468
<   goto ldv_54659;
<   default: 
< #line 2468
<   __bad_unaligned_access_size();
< #line 2468
<   goto ldv_54659;
<   }
<   ldv_54659: 
< #line 2469
<   __gu_p___3 = (void *)tl;
< #line 2469
<   switch (8UL) {
<   case 1UL: 
< #line 2469
<   *((u8 *)__gu_p___3) = (unsigned char )*((u64 *)val);
< #line 2469
<   goto ldv_54666;
<   case 2UL: 
< #line 2469
<   put_unaligned_le16((int )((unsigned short )*((u64 *)val)), __gu_p___3);
< #line 2469
<   goto ldv_54666;
<   case 4UL: 
< #line 2469
<   put_unaligned_le32((unsigned int )*((u64 *)val), __gu_p___3);
< #line 2469
<   goto ldv_54666;
<   case 8UL: 
< #line 2469
<   put_unaligned_le64(*((u64 *)val), __gu_p___3);
< #line 2469
<   goto ldv_54666;
<   default: 
< #line 2469
<   __bad_unaligned_access_size();
< #line 2469
<   goto ldv_54666;
<   }
<   ldv_54666: 
< #line 2470
<   tl = tl + 8U;
< #line 2471
<   goto ldv_54655;
<   default: ;
<   }
<   ldv_54655: ;
< #line 2476
<   return (tl);
< }
< }
< #line 2479 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void drbd_bcast_state(struct drbd_conf *mdev , union drbd_state state ) 
< { 
<   char buffer[42U] ;
<   struct cn_msg *cn_reply ;
<   struct drbd_nl_cfg_reply *reply ;
<   unsigned short *tl ;
<   void *__gu_p ;
<   unsigned short *tmp ;
<   int tmp___0 ;
< 
<   {
< #line 2485
<   cn_reply = (struct cn_msg *)(& buffer);
< #line 2486
<   reply = (struct drbd_nl_cfg_reply *)(& cn_reply->data);
< #line 2488
<   tl = (unsigned short *)(& reply->tag_list);
< #line 2492
<   tl = get_state_to_tags(mdev, (struct get_state *)(& state), tl);
< #line 2494
<   tmp = tl;
< #line 2494
<   tl = tl + 1;
< #line 2494
<   __gu_p = (void *)tmp;
< #line 2494
<   switch (2UL) {
<   case 1UL: 
< #line 2494
<   *((u8 *)__gu_p) = 0U;
< #line 2494
<   goto ldv_54682;
<   case 2UL: 
< #line 2494
<   put_unaligned_le16(0, __gu_p);
< #line 2494
<   goto ldv_54682;
<   case 4UL: 
< #line 2494
<   put_unaligned_le32(0U, __gu_p);
< #line 2494
<   goto ldv_54682;
<   case 8UL: 
< #line 2494
<   put_unaligned_le64(0ULL, __gu_p);
< #line 2494
<   goto ldv_54682;
<   default: 
< #line 2494
<   __bad_unaligned_access_size();
< #line 2494
<   goto ldv_54682;
<   }
<   ldv_54682: 
< #line 2496
<   cn_reply->id.idx = 8U;
< #line 2497
<   cn_reply->id.val = 1U;
< #line 2499
<   tmp___0 = atomic_add_return(1, & drbd_nl_seq);
< #line 2499
<   cn_reply->seq = (__u32 )tmp___0;
< #line 2500
<   cn_reply->ack = 0U;
< #line 2501
<   cn_reply->len = (unsigned int )((int )((__u16 )((long )tl)) - (int )((__u16 )((long )(& reply->tag_list)))) + 12U;
< #line 2503
<   cn_reply->flags = 0U;
< #line 2505
<   reply->packet_type = 17;
< #line 2506
<   reply->minor = mdev_to_minor(mdev);
< #line 2507
<   reply->ret_code = 101;
< #line 2509
<   cn_netlink_send(cn_reply, 8U, 16U);
< #line 2510
<   return;
< }
< }
< #line 2512 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void drbd_bcast_ev_helper(struct drbd_conf *mdev , char *helper_name ) 
< { 
<   char buffer[74U] ;
<   struct cn_msg *cn_reply ;
<   struct drbd_nl_cfg_reply *reply ;
<   unsigned short *tl ;
<   void *__gu_p ;
<   unsigned short *tmp ;
<   int tmp___0 ;
< 
<   {
< #line 2518
<   cn_reply = (struct cn_msg *)(& buffer);
< #line 2519
<   reply = (struct drbd_nl_cfg_reply *)(& cn_reply->data);
< #line 2521
<   tl = (unsigned short *)(& reply->tag_list);
< #line 2525
<   tl = tl_add_str(tl, T_helper, (char const   *)helper_name);
< #line 2526
<   tmp = tl;
< #line 2526
<   tl = tl + 1;
< #line 2526
<   __gu_p = (void *)tmp;
< #line 2526
<   switch (2UL) {
<   case 1UL: 
< #line 2526
<   *((u8 *)__gu_p) = 0U;
< #line 2526
<   goto ldv_54697;
<   case 2UL: 
< #line 2526
<   put_unaligned_le16(0, __gu_p);
< #line 2526
<   goto ldv_54697;
<   case 4UL: 
< #line 2526
<   put_unaligned_le32(0U, __gu_p);
< #line 2526
<   goto ldv_54697;
<   case 8UL: 
< #line 2526
<   put_unaligned_le64(0ULL, __gu_p);
< #line 2526
<   goto ldv_54697;
<   default: 
< #line 2526
<   __bad_unaligned_access_size();
< #line 2526
<   goto ldv_54697;
<   }
<   ldv_54697: 
< #line 2528
<   cn_reply->id.idx = 8U;
< #line 2529
<   cn_reply->id.val = 1U;
< #line 2531
<   tmp___0 = atomic_add_return(1, & drbd_nl_seq);
< #line 2531
<   cn_reply->seq = (__u32 )tmp___0;
< #line 2532
<   cn_reply->ack = 0U;
< #line 2533
<   cn_reply->len = (unsigned int )((int )((__u16 )((long )tl)) - (int )((__u16 )((long )(& reply->tag_list)))) + 12U;
< #line 2535
<   cn_reply->flags = 0U;
< #line 2537
<   reply->packet_type = 20;
< #line 2538
<   reply->minor = mdev_to_minor(mdev);
< #line 2539
<   reply->ret_code = 101;
< #line 2541
<   cn_netlink_send(cn_reply, 8U, 16U);
< #line 2542
<   return;
< }
< }
< #line 2544 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void drbd_bcast_ee(struct drbd_conf *mdev , char const   *reason , int const   dgs ,
<                    char const   *seen_hash , char const   *calc_hash , struct drbd_epoch_entry  const  *e ) 
< { 
<   struct cn_msg *cn_reply ;
<   struct drbd_nl_cfg_reply *reply ;
<   unsigned short *tl ;
<   struct page *page ;
<   unsigned int len ;
<   void *tmp ;
<   unsigned int __min1 ;
<   unsigned int __min2 ;
<   void *__gu_p ;
<   unsigned short *tmp___0 ;
<   void *__gu_p___0 ;
<   unsigned short *tmp___1 ;
<   void *d ;
<   void *tmp___2 ;
<   unsigned int l ;
<   unsigned int __min1___0 ;
<   unsigned int __min2___0 ;
<   size_t __len ;
<   void *__ret ;
<   struct page *tmp___3 ;
<   void *__gu_p___1 ;
<   unsigned short *tmp___4 ;
<   int tmp___5 ;
< 
<   {
< #line 2555
<   if ((unsigned long )e == (unsigned long )((struct drbd_epoch_entry  const  *)0)) {
< #line 2556
<     return;
<   } else {
< 
<   }
< #line 2557
<   if ((unsigned long )reason == (unsigned long )((char const   *)0) || (int )((signed char )*reason) == 0) {
< #line 2558
<     return;
<   } else {
< 
<   }
< #line 2566
<   tmp = kzalloc(33026UL, 16U);
< #line 2566
<   cn_reply = (struct cn_msg *)tmp;
< #line 2573
<   if ((unsigned long )cn_reply == (unsigned long )((struct cn_msg *)0)) {
< #line 2574
<     dev_err((struct device  const  *)(& (mdev->vdisk)->part0.__dev), "could not kmalloc buffer for drbd_bcast_ee, sector %llu, size %u\n",
<             (unsigned long long )e->sector, e->size);
< #line 2576
<     return;
<   } else {
< 
<   }
< #line 2579
<   reply = (struct drbd_nl_cfg_reply *)(& cn_reply->data);
< #line 2580
<   tl = (unsigned short *)(& reply->tag_list);
< #line 2582
<   tl = tl_add_str(tl, T_dump_ee_reason, reason);
< #line 2583
<   tl = tl_add_blob(tl, T_seen_digest, (void const   *)seen_hash, dgs);
< #line 2584
<   tl = tl_add_blob(tl, T_calc_digest, (void const   *)calc_hash, dgs);
< #line 2585
<   tl = tl_add_int(tl, T_ee_sector, (void const   *)(& e->sector));
< #line 2586
<   tl = tl_add_int(tl, T_ee_block_id, (void const   *)(& e->ldv_49794.block_id));
< #line 2589
<   __min1 = e->size;
< #line 2589
<   __min2 = 32768U;
< #line 2589
<   len = __min1 < __min2 ? __min1 : __min2;
< #line 2590
<   tmp___0 = tl;
< #line 2590
<   tl = tl + 1;
< #line 2590
<   __gu_p = (void *)tmp___0;
< #line 2590
<   switch (2UL) {
<   case 1UL: 
< #line 2590
<   *((u8 *)__gu_p) = 50U;
< #line 2590
<   goto ldv_54720;
<   case 2UL: 
< #line 2590
<   put_unaligned_le16(49202, __gu_p);
< #line 2590
<   goto ldv_54720;
<   case 4UL: 
< #line 2590
<   put_unaligned_le32(49202U, __gu_p);
< #line 2590
<   goto ldv_54720;
<   case 8UL: 
< #line 2590
<   put_unaligned_le64(49202ULL, __gu_p);
< #line 2590
<   goto ldv_54720;
<   default: 
< #line 2590
<   __bad_unaligned_access_size();
< #line 2590
<   goto ldv_54720;
<   }
<   ldv_54720: 
< #line 2591
<   tmp___1 = tl;
< #line 2591
<   tl = tl + 1;
< #line 2591
<   __gu_p___0 = (void *)tmp___1;
< #line 2591
<   switch (2UL) {
<   case 1UL: 
< #line 2591
<   *((u8 *)__gu_p___0) = (unsigned char )len;
< #line 2591
<   goto ldv_54727;
<   case 2UL: 
< #line 2591
<   put_unaligned_le16((int )((unsigned short )len), __gu_p___0);
< #line 2591
<   goto ldv_54727;
<   case 4UL: 
< #line 2591
<   put_unaligned_le32(len, __gu_p___0);
< #line 2591
<   goto ldv_54727;
<   case 8UL: 
< #line 2591
<   put_unaligned_le64((unsigned long long )len, __gu_p___0);
< #line 2591
<   goto ldv_54727;
<   default: 
< #line 2591
<   __bad_unaligned_access_size();
< #line 2591
<   goto ldv_54727;
<   }
<   ldv_54727: 
< #line 2593
<   page = e->pages;
< #line 2594
<   goto ldv_54743;
<   ldv_54742: 
< #line 2595
<   tmp___2 = kmap_atomic(page);
< #line 2595
<   d = tmp___2;
< #line 2596
<   __min1___0 = len;
< #line 2596
<   __min2___0 = 4096U;
< #line 2596
<   l = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
< #line 2597
<   __len = (size_t )l;
< #line 2597
<   __ret = __builtin_memcpy((void *)tl, (void const   *)d, __len);
< #line 2598
<   __kunmap_atomic(d);
< #line 2599
<   tl = tl + (unsigned long )l;
< #line 2600
<   len = len - l;
< #line 2601
<   if (len == 0U) {
< #line 2602
<     goto ldv_54741;
<   } else {
< 
<   }
< #line 2594
<   page = page_chain_next(page);
<   ldv_54743: ;
< #line 2594
<   if ((unsigned long )page != (unsigned long )((struct page *)0)) {
< #line 2594
<     tmp___3 = page_chain_next(page);
< #line 2594
<     __builtin_prefetch((void const   *)tmp___3);
< #line 2594
<     if (1 != 0) {
< #line 2595
<       goto ldv_54742;
<     } else {
< #line 2597
<       goto ldv_54741;
<     }
---
> #line 28
>   nla = nla_next((struct nlattr  const  *)nla, & rem);
>   ldv_51705: 
> #line 28
>   tmp___2 = nla_ok((struct nlattr  const  *)nla, rem);
> #line 28
>   if (tmp___2 != 0) {
> #line 29
>     goto ldv_51704;
60809,60900d64429
<   ldv_54741: 
< #line 2604
<   tmp___4 = tl;
< #line 2604
<   tl = tl + 1;
< #line 2604
<   __gu_p___1 = (void *)tmp___4;
< #line 2604
<   switch (2UL) {
<   case 1UL: 
< #line 2604
<   *((u8 *)__gu_p___1) = 0U;
< #line 2604
<   goto ldv_54746;
<   case 2UL: 
< #line 2604
<   put_unaligned_le16(0, __gu_p___1);
< #line 2604
<   goto ldv_54746;
<   case 4UL: 
< #line 2604
<   put_unaligned_le32(0U, __gu_p___1);
< #line 2604
<   goto ldv_54746;
<   case 8UL: 
< #line 2604
<   put_unaligned_le64(0ULL, __gu_p___1);
< #line 2604
<   goto ldv_54746;
<   default: 
< #line 2604
<   __bad_unaligned_access_size();
< #line 2604
<   goto ldv_54746;
<   }
<   ldv_54746: 
< #line 2606
<   cn_reply->id.idx = 8U;
< #line 2607
<   cn_reply->id.val = 1U;
< #line 2609
<   tmp___5 = atomic_add_return(1, & drbd_nl_seq);
< #line 2609
<   cn_reply->seq = (__u32 )tmp___5;
< #line 2610
<   cn_reply->ack = 0U;
< #line 2611
<   cn_reply->len = (unsigned int )((int )((__u16 )((long )tl)) - (int )((__u16 )((long )(& reply->tag_list)))) + 12U;
< #line 2613
<   cn_reply->flags = 0U;
< #line 2615
<   reply->packet_type = 24;
< #line 2616
<   reply->minor = mdev_to_minor(mdev);
< #line 2617
<   reply->ret_code = 101;
< #line 2619
<   cn_netlink_send(cn_reply, 8U, 16U);
< #line 2620
<   kfree((void const   *)cn_reply);
< #line 2621
<   return;
< }
< }
< #line 2623 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void drbd_bcast_sync_progress(struct drbd_conf *mdev ) 
< { 
<   char buffer[42U] ;
<   struct cn_msg *cn_reply ;
<   struct drbd_nl_cfg_reply *reply ;
<   unsigned short *tl ;
<   unsigned long rs_left ;
<   unsigned int res ;
<   int tmp ;
<   void *__gu_p ;
<   unsigned short *tmp___0 ;
<   int tmp___1 ;
< 
<   {
< #line 2629
<   cn_reply = (struct cn_msg *)(& buffer);
< #line 2630
<   reply = (struct drbd_nl_cfg_reply *)(& cn_reply->data);
< #line 2632
<   tl = (unsigned short *)(& reply->tag_list);
< #line 2637
<   tmp = _get_ldev_if_state(mdev, D_INCONSISTENT);
< #line 2637
<   if (tmp == 0) {
< #line 2638
<     return;
<   } else {
60902,60967c64431,64432
<   }
< #line 2639
<   drbd_get_syncer_progress(mdev, & rs_left, & res);
< #line 2640
<   put_ldev(mdev);
< #line 2642
<   tl = tl_add_int(tl, T_sync_progress, (void const   *)(& res));
< #line 2643
<   tmp___0 = tl;
< #line 2643
<   tl = tl + 1;
< #line 2643
<   __gu_p = (void *)tmp___0;
< #line 2643
<   switch (2UL) {
<   case 1UL: 
< #line 2643
<   *((u8 *)__gu_p) = 0U;
< #line 2643
<   goto ldv_54762;
<   case 2UL: 
< #line 2643
<   put_unaligned_le16(0, __gu_p);
< #line 2643
<   goto ldv_54762;
<   case 4UL: 
< #line 2643
<   put_unaligned_le32(0U, __gu_p);
< #line 2643
<   goto ldv_54762;
<   case 8UL: 
< #line 2643
<   put_unaligned_le64(0ULL, __gu_p);
< #line 2643
<   goto ldv_54762;
<   default: 
< #line 2643
<   __bad_unaligned_access_size();
< #line 2643
<   goto ldv_54762;
<   }
<   ldv_54762: 
< #line 2645
<   cn_reply->id.idx = 8U;
< #line 2646
<   cn_reply->id.val = 1U;
< #line 2648
<   tmp___1 = atomic_add_return(1, & drbd_nl_seq);
< #line 2648
<   cn_reply->seq = (__u32 )tmp___1;
< #line 2649
<   cn_reply->ack = 0U;
< #line 2650
<   cn_reply->len = (unsigned int )((int )((__u16 )((long )tl)) - (int )((__u16 )((long )(& reply->tag_list)))) + 12U;
< #line 2652
<   cn_reply->flags = 0U;
< #line 2654
<   reply->packet_type = 23;
< #line 2655
<   reply->minor = mdev_to_minor(mdev);
< #line 2656
<   reply->ret_code = 101;
< #line 2658
<   cn_netlink_send(cn_reply, 8U, 16U);
< #line 2659
<   return;
---
> #line 35
>   return (0);
60970,60971c64435,64437
< #line 2661 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< int drbd_nl_init(void) 
---
> #line 38 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nla.c.prepared"
> int drbd_nla_parse_nested(struct nlattr **tb , int maxtype , struct nlattr *nla ,
>                           struct nla_policy  const  *policy ) 
60973d64438
<   struct cb_id cn_id_drbd ;
60975,60976d64439
<   int try ;
<   int tmp ;
60979,60988c64442,64444
< #line 2664
<   try = 10;
< #line 2666
<   cn_id_drbd.val = 1U;
<   ldv_54774: 
< #line 2668
<   cn_id_drbd.idx = cn_idx;
< #line 2669
<   err = cn_add_callback(& cn_id_drbd, "cn_drbd", & drbd_connector_callback);
< #line 2670
---
> #line 43
>   err = drbd_nla_check_mandatory(maxtype, nla);
> #line 44
60990,61074c64446,64447
< #line 2671
<     goto ldv_54773;
<   } else {
< 
<   }
< #line 2672
<   cn_idx = cn_idx + 6977U;
< #line 2673
<   tmp = try;
< #line 2673
<   try = try - 1;
< #line 2673
<   if (tmp != 0) {
< #line 2674
<     goto ldv_54774;
<   } else {
< 
<   }
<   ldv_54773: ;
< #line 2675
<   if (err != 0) {
< #line 2676
<     printk("\vdrbd: cn_drbd failed to register\n");
< #line 2677
<     return (err);
<   } else {
< 
<   }
< #line 2680
<   return (0);
< }
< }
< #line 2683 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void drbd_nl_cleanup(void) 
< { 
<   struct cb_id cn_id_drbd ;
< 
<   {
< #line 2687
<   cn_id_drbd.idx = cn_idx;
< #line 2688
<   cn_id_drbd.val = 1U;
< #line 2690
<   cn_del_callback(& cn_id_drbd);
< #line 2691
<   return;
< }
< }
< #line 2693 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void drbd_nl_send_reply(struct cn_msg *req , int ret_code ) 
< { 
<   char buffer[32U] ;
<   struct cn_msg *cn_reply ;
<   struct drbd_nl_cfg_reply *reply ;
<   int rr ;
< 
<   {
< #line 2696
<   cn_reply = (struct cn_msg *)(& buffer);
< #line 2697
<   reply = (struct drbd_nl_cfg_reply *)(& cn_reply->data);
< #line 2701
<   memset((void *)(& buffer), 0, 32UL);
< #line 2702
<   cn_reply->id = req->id;
< #line 2704
<   cn_reply->seq = req->seq;
< #line 2705
<   cn_reply->ack = req->ack + 1U;
< #line 2706
<   cn_reply->len = 12U;
< #line 2707
<   cn_reply->flags = 0U;
< #line 2709
<   reply->packet_type = 27;
< #line 2710
<   reply->minor = ((struct drbd_nl_cfg_req *)(& req->data))->drbd_minor;
< #line 2711
<   reply->ret_code = ret_code;
< #line 2713
<   rr = cn_netlink_send(cn_reply, 8U, 16U);
< #line 2714
<   if (rr != 0 && rr != -3) {
< #line 2715
<     printk("\016drbd: cn_netlink_send()=%d\n", rr);
---
> #line 45
>     err = nla_parse_nested(tb, maxtype, (struct nlattr  const  *)nla, policy);
61078,61079c64451,64452
< #line 2716
<   return;
---
> #line 47
>   return (err);
61082,61083c64455,64456
< #line 2756 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void ldv_main8_sequence_infinite_withcheck_stateful(void) 
---
> #line 50 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nla.c.prepared"
> struct nlattr *drbd_nla_find_nested(int maxtype , struct nlattr *nla , int attrtype ) 
61085,61086c64458,64460
<   int tmp ;
<   int tmp___0 ;
---
>   int err ;
>   void *tmp ;
>   struct nlattr *tmp___0 ;
61089,61111c64463,64470
< #line 2768
<   LDV_IN_INTERRUPT = 1;
< #line 2777
<   ldv_initialize();
< #line 2779
<   goto ldv_54806;
<   ldv_54805: 
< #line 2782
<   tmp = nondet_int();
< #line 2782
<   switch (tmp) {
<   default: ;
< #line 2784
<   goto ldv_54804;
<   }
<   ldv_54804: ;
<   ldv_54806: 
< #line 2779
<   tmp___0 = nondet_int();
< #line 2779
<   if (tmp___0 != 0) {
< #line 2780
<     goto ldv_54805;
---
> #line 58
>   err = drbd_nla_check_mandatory(maxtype, nla);
> #line 59
>   if (err != 0) {
> #line 60
>     tmp = ERR_PTR((long )err);
> #line 60
>     return ((struct nlattr *)tmp);
61115,61156c64474,64477
< 
< 
< #line 2793
<   ldv_check_final_state();
< #line 2796
<   return;
< }
< }
< #line 2800 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< bool ldv_try_module_get_7(struct module *ldv_func_arg1 ) 
< { 
<   int tmp ;
< 
<   {
< #line 2805
<   tmp = ldv_try_module_get(ldv_func_arg1);
< #line 2805
<   return (tmp != 0);
< }
< }
< #line 2808 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void ldv_module_put_8(struct module *ldv_func_arg1 ) 
< { 
< 
< 
<   {
< #line 2813
<   ldv_module_put(ldv_func_arg1);
< #line 2814
<   return;
< }
< }
< #line 2816 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/dscv/ri/08_1a/drivers/block/drbd/drbd_nl.c.prepared"
< void ldv_module_put_9(struct module *ldv_func_arg1 ) 
< { 
< 
< 
<   {
< #line 2821
<   ldv_module_put(ldv_func_arg1);
< #line 2822
<   return;
---
> #line 61
>   tmp___0 = nla_find_nested((struct nlattr  const  *)nla, attrtype);
> #line 61
>   return (tmp___0);
61182c64503
< #line 6 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
---
> #line 6 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
61184c64505
< #line 9 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
---
> #line 9 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
61201c64522
< #line 19 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
---
> #line 19 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
61228c64549
< #line 44 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
---
> #line 44 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
61252c64573
< #line 56 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
---
> #line 56 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
61265c64586
< #line 64 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
---
> #line 64 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
61275c64596
< #line 71 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/20/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
---
> #line 71 "/work/ldvuser/novikov/work/current--X--drivers/block/drbd/drbd.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/23/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
