78,79c78,79
< #line 192 "include/linux/types.h"
< struct __anonstruct_atomic_t_6 {
---
> #line 190 "include/linux/types.h"
> struct __anonstruct_atomic_t_7 {
82,85c82,85
< #line 192 "include/linux/types.h"
< typedef struct __anonstruct_atomic_t_6 atomic_t;
< #line 197 "include/linux/types.h"
< struct __anonstruct_atomic64_t_7 {
---
> #line 190 "include/linux/types.h"
> typedef struct __anonstruct_atomic_t_7 atomic_t;
> #line 195 "include/linux/types.h"
> struct __anonstruct_atomic64_t_8 {
88,90c88,90
< #line 197 "include/linux/types.h"
< typedef struct __anonstruct_atomic64_t_7 atomic64_t;
< #line 59 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/alternative.h"
---
> #line 195 "include/linux/types.h"
> typedef struct __anonstruct_atomic64_t_8 atomic64_t;
> #line 60 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/alternative.h"
92c92
< #line 44 "include/linux/dynamic_debug.h"
---
> #line 10 "include/asm-generic/bug.h"
99c99
< #line 111 "include/linux/kernel.h"
---
> #line 117 "include/linux/kernel.h"
101c101
< #line 210
---
> #line 211
103c103
< #line 679
---
> #line 7 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
105c105
< #line 213 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/segment.h"
---
> #line 98 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/ptrace.h"
133c133
< #line 285
---
> #line 290
135c135
< #line 298
---
> #line 307
137c137
< #line 319 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/paravirt_types.h"
---
> #line 321 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/paravirt_types.h"
139c139
< #line 301 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/ds.h"
---
> #line 10 "include/linux/personality.h"
141c141
< #line 90 "include/linux/personality.h"
---
> #line 91
143c143
< #line 90 "include/linux/personality.h"
---
> #line 91 "include/linux/personality.h"
160,161c160,161
< #line 627 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
< struct __anonstruct_mm_segment_t_24 {
---
> #line 625 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> struct __anonstruct_mm_segment_t_31 {
164,166c164,166
< #line 627 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
< typedef struct __anonstruct_mm_segment_t_24 mm_segment_t;
< #line 56 "include/linux/prefetch.h"
---
> #line 625 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> typedef struct __anonstruct_mm_segment_t_31 mm_segment_t;
> #line 19 "include/linux/list.h"
171c171
< #line 327 "include/linux/list.h"
---
> #line 540
173c173
< #line 327 "include/linux/list.h"
---
> #line 540 "include/linux/list.h"
177c177
< #line 543 "include/linux/list.h"
---
> #line 544 "include/linux/list.h"
182c182
< #line 112 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/stat.h"
---
> #line 12 "include/linux/thread_info.h"
184c184
< #line 113
---
> #line 13
186,187c186,187
< #line 114 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/stat.h"
< struct __anonstruct_ldv_5060_26 {
---
> #line 18 "include/linux/thread_info.h"
> struct __anonstruct____missing_field_name_33 {
193,194c193,194
< #line 114 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/stat.h"
< struct __anonstruct_futex_27 {
---
> #line 18 "include/linux/thread_info.h"
> struct __anonstruct_futex_34 {
202,203c202,203
< #line 114 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/stat.h"
< struct __anonstruct_nanosleep_28 {
---
> #line 18 "include/linux/thread_info.h"
> struct __anonstruct_nanosleep_35 {
209c209
< #line 114
---
> #line 18
211,212c211,212
< #line 114 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/stat.h"
< struct __anonstruct_poll_29 {
---
> #line 18 "include/linux/thread_info.h"
> struct __anonstruct_poll_36 {
219,224c219,224
< #line 114 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/stat.h"
< union __anonunion_ldv_5083_25 {
<    struct __anonstruct_ldv_5060_26 ldv_5060 ;
<    struct __anonstruct_futex_27 futex ;
<    struct __anonstruct_nanosleep_28 nanosleep ;
<    struct __anonstruct_poll_29 poll ;
---
> #line 18 "include/linux/thread_info.h"
> union __anonunion____missing_field_name_32 {
>    struct __anonstruct____missing_field_name_33 __annonCompField16 ;
>    struct __anonstruct_futex_34 futex ;
>    struct __anonstruct_nanosleep_35 nanosleep ;
>    struct __anonstruct_poll_36 poll ;
226c226
< #line 114 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/stat.h"
---
> #line 18 "include/linux/thread_info.h"
229c229
<    union __anonunion_ldv_5083_25 ldv_5083 ;
---
>    union __anonunion____missing_field_name_32 __annonCompField17 ;
233c233
< #line 131 "include/asm-generic/atomic-long.h"
---
> #line 26 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/thread_info.h"
246c246
< #line 8 "include/linux/bottom_half.h"
---
> #line 8 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/spinlock_types.h"
250c250
< #line 10 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/spinlock_types.h"
---
> #line 8 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/spinlock_types.h"
252,253c252,253
< #line 16 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/spinlock_types.h"
< struct __anonstruct_raw_rwlock_t_30 {
---
> #line 14 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/spinlock_types.h"
> struct __anonstruct_raw_rwlock_t_37 {
256,258c256,258
< #line 16 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/spinlock_types.h"
< typedef struct __anonstruct_raw_rwlock_t_30 raw_rwlock_t;
< #line 17
---
> #line 14 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/spinlock_types.h"
> typedef struct __anonstruct_raw_rwlock_t_37 raw_rwlock_t;
> #line 13 "include/linux/lockdep.h"
260c260
< #line 56 "include/linux/debug_locks.h"
---
> #line 9 "include/linux/stacktrace.h"
267c267
< #line 24 "include/linux/stacktrace.h"
---
> #line 35 "include/linux/lockdep.h"
270,271c270,271
< };
< #line 38 "include/linux/lockdep.h"
---
> } __attribute__((__packed__)) ;
> #line 39 "include/linux/lockdep.h"
273c273
<    struct lockdep_subclass_key subkeys[8U] ;
---
>    struct lockdep_subclass_key subkeys[8UL] ;
275c275
< #line 42 "include/linux/lockdep.h"
---
> #line 48 "include/linux/lockdep.h"
283c283
<    struct stack_trace usage_traces[13U] ;
---
>    struct stack_trace usage_traces[1 + 3 * 4] ;
290,291c290,291
<    unsigned long contention_point[4U] ;
<    unsigned long contending_point[4U] ;
---
>    unsigned long contention_point[4] ;
>    unsigned long contending_point[4] ;
293c293
< #line 127 "include/linux/lockdep.h"
---
> #line 133 "include/linux/lockdep.h"
301,302c301,302
< #line 32 "include/linux/spinlock_types.h"
< struct __anonstruct_spinlock_t_31 {
---
> #line 20 "include/linux/spinlock_types.h"
> struct __anonstruct_spinlock_t_38 {
309,312c309,312
< #line 32 "include/linux/spinlock_types.h"
< typedef struct __anonstruct_spinlock_t_31 spinlock_t;
< #line 48 "include/linux/spinlock_types.h"
< struct __anonstruct_rwlock_t_32 {
---
> #line 20 "include/linux/spinlock_types.h"
> typedef struct __anonstruct_spinlock_t_38 spinlock_t;
> #line 36 "include/linux/spinlock_types.h"
> struct __anonstruct_rwlock_t_39 {
319,321c319,321
< #line 48 "include/linux/spinlock_types.h"
< typedef struct __anonstruct_rwlock_t_32 rwlock_t;
< #line 169 "include/linux/seqlock.h"
---
> #line 36 "include/linux/spinlock_types.h"
> typedef struct __anonstruct_rwlock_t_39 rwlock_t;
> #line 14 "include/linux/time.h"
326c326
< #line 267 "include/linux/time.h"
---
> #line 62 "include/linux/stat.h"
342c342
< #line 49 "include/linux/wait.h"
---
> #line 50 "include/linux/wait.h"
349c349
< #line 643 "include/linux/mmzone.h"
---
> #line 48 "include/linux/mutex.h"
359c359
< #line 154 "include/linux/mutex.h"
---
> #line 17 "include/linux/rwsem.h"
361c361
< #line 156 "include/linux/mutex.h"
---
> #line 31 "include/linux/rwsem-spinlock.h"
368c368
< #line 165 "include/linux/ioport.h"
---
> #line 167 "include/linux/ioport.h"
370c370
< #line 85 "include/linux/debugobjects.h"
---
> #line 10 "include/linux/timer.h"
372c372
< #line 86 "include/linux/debugobjects.h"
---
> #line 12 "include/linux/timer.h"
380c380
<    char start_comm[16U] ;
---
>    char start_comm[16] ;
384c384
< #line 253 "include/linux/timer.h"
---
> #line 16 "include/linux/workqueue.h"
386c386
< #line 18 "include/linux/workqueue.h"
---
> #line 25 "include/linux/workqueue.h"
390c390
<    void (*func)(struct work_struct * ) ;
---
>    void (*func)(struct work_struct *work ) ;
393c393
< #line 36 "include/linux/pm.h"
---
> #line 43 "include/linux/pm.h"
397c397
< #line 45 "include/linux/pm.h"
---
> #line 43 "include/linux/pm.h"
399c399
< #line 46 "include/linux/pm.h"
---
> #line 196 "include/linux/pm.h"
401,417c401,417
<    int (*prepare)(struct device * ) ;
<    void (*complete)(struct device * ) ;
<    int (*suspend)(struct device * ) ;
<    int (*resume)(struct device * ) ;
<    int (*freeze)(struct device * ) ;
<    int (*thaw)(struct device * ) ;
<    int (*poweroff)(struct device * ) ;
<    int (*restore)(struct device * ) ;
<    int (*suspend_noirq)(struct device * ) ;
<    int (*resume_noirq)(struct device * ) ;
<    int (*freeze_noirq)(struct device * ) ;
<    int (*thaw_noirq)(struct device * ) ;
<    int (*poweroff_noirq)(struct device * ) ;
<    int (*restore_noirq)(struct device * ) ;
<    int (*runtime_suspend)(struct device * ) ;
<    int (*runtime_resume)(struct device * ) ;
<    int (*runtime_idle)(struct device * ) ;
---
>    int (*prepare)(struct device *dev ) ;
>    void (*complete)(struct device *dev ) ;
>    int (*suspend)(struct device *dev ) ;
>    int (*resume)(struct device *dev ) ;
>    int (*freeze)(struct device *dev ) ;
>    int (*thaw)(struct device *dev ) ;
>    int (*poweroff)(struct device *dev ) ;
>    int (*restore)(struct device *dev ) ;
>    int (*suspend_noirq)(struct device *dev ) ;
>    int (*resume_noirq)(struct device *dev ) ;
>    int (*freeze_noirq)(struct device *dev ) ;
>    int (*thaw_noirq)(struct device *dev ) ;
>    int (*poweroff_noirq)(struct device *dev ) ;
>    int (*restore_noirq)(struct device *dev ) ;
>    int (*runtime_suspend)(struct device *dev ) ;
>    int (*runtime_resume)(struct device *dev ) ;
>    int (*runtime_idle)(struct device *dev ) ;
419c419
< #line 215
---
> #line 351
429c429
< #line 225
---
> #line 384
436c436
< #line 232
---
> #line 403
443c443
< #line 239 "include/linux/pm.h"
---
> #line 410 "include/linux/pm.h"
446,447c446,447
<    unsigned char can_wakeup : 1 ;
<    unsigned char should_wakeup : 1 ;
---
>    unsigned int can_wakeup : 1 ;
>    unsigned int should_wakeup : 1 ;
457,461c457,461
<    unsigned char disable_depth : 3 ;
<    unsigned char ignore_children : 1 ;
<    unsigned char idle_notification : 1 ;
<    unsigned char request_pending : 1 ;
<    unsigned char deferred_resume : 1 ;
---
>    unsigned int disable_depth : 3 ;
>    unsigned int ignore_children : 1 ;
>    unsigned int idle_notification : 1 ;
>    unsigned int request_pending : 1 ;
>    unsigned int deferred_resume : 1 ;
466c466
< #line 49 "include/linux/topology.h"
---
> #line 10 "include/linux/gfp.h"
476c476
< #line 180 "include/linux/elf.h"
---
> #line 181 "include/linux/elf.h"
485c485
< #line 188 "include/linux/elf.h"
---
> #line 181 "include/linux/elf.h"
487c487
< #line 406
---
> #line 20 "include/linux/sysfs.h"
489c489
< #line 407 "include/linux/elf.h"
---
> #line 28 "include/linux/sysfs.h"
495c495
< #line 33 "include/linux/sysfs.h"
---
> #line 34 "include/linux/sysfs.h"
501c501
< #line 75 "include/linux/sysfs.h"
---
> #line 77 "include/linux/sysfs.h"
506c506
< #line 81
---
> #line 82
508c508
< #line 131 "include/linux/sysfs.h"
---
> #line 20 "include/linux/kref.h"
512c512
< #line 48 "include/linux/kobject.h"
---
> #line 59 "include/linux/kobject.h"
514c514
< #line 48
---
> #line 59
516c516
< #line 48 "include/linux/kobject.h"
---
> #line 59 "include/linux/kobject.h"
525,529c525,529
<    unsigned char state_initialized : 1 ;
<    unsigned char state_in_sysfs : 1 ;
<    unsigned char state_add_uevent_sent : 1 ;
<    unsigned char state_remove_uevent_sent : 1 ;
<    unsigned char uevent_suppress : 1 ;
---
>    unsigned int state_initialized : 1 ;
>    unsigned int state_in_sysfs : 1 ;
>    unsigned int state_add_uevent_sent : 1 ;
>    unsigned int state_remove_uevent_sent : 1 ;
>    unsigned int uevent_suppress : 1 ;
531c531
< #line 106 "include/linux/kobject.h"
---
> #line 107 "include/linux/kobject.h"
533c533
<    void (*release)(struct kobject * ) ;
---
>    void (*release)(struct kobject *kobj ) ;
537c537
< #line 112 "include/linux/kobject.h"
---
> #line 113 "include/linux/kobject.h"
539c539
<    char *envp[32U] ;
---
>    char *envp[32] ;
541c541
<    char buf[2048U] ;
---
>    char buf[2048] ;
544c544
< #line 119 "include/linux/kobject.h"
---
> #line 120 "include/linux/kobject.h"
546,548c546,548
<    int (*filter)(struct kset * , struct kobject * ) ;
<    char const   *(*name)(struct kset * , struct kobject * ) ;
<    int (*uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
---
>    int (*filter)(struct kset *kset , struct kobject *kobj ) ;
>    char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
>    int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
550c550
< #line 136 "include/linux/kobject.h"
---
> #line 154 "include/linux/kobject.h"
557c557
< #line 210
---
> #line 32 "include/linux/moduleparam.h"
559c559
< #line 38 "include/linux/moduleparam.h"
---
> #line 43
561c561
< #line 38
---
> #line 43
563,564c563,564
< #line 38 "include/linux/moduleparam.h"
< union __anonunion_ldv_10102_109 {
---
> #line 43 "include/linux/moduleparam.h"
> union __anonunion____missing_field_name_118 {
569c569
< #line 38 "include/linux/moduleparam.h"
---
> #line 43 "include/linux/moduleparam.h"
574,576c574,576
<    int (*set)(char const   * , struct kernel_param * ) ;
<    int (*get)(char * , struct kernel_param * ) ;
<    union __anonunion_ldv_10102_109 ldv_10102 ;
---
>    int (*set)(char const   *val , struct kernel_param *kp ) ;
>    int (*get)(char *buffer , struct kernel_param *kp ) ;
>    union __anonunion____missing_field_name_118 __annonCompField18 ;
578c578
< #line 55 "include/linux/moduleparam.h"
---
> #line 57 "include/linux/moduleparam.h"
583c583
< #line 61 "include/linux/moduleparam.h"
---
> #line 63 "include/linux/moduleparam.h"
587,588c587,588
<    int (*set)(char const   * , struct kernel_param * ) ;
<    int (*get)(char * , struct kernel_param * ) ;
---
>    int (*set)(char const   *val , struct kernel_param *kp ) ;
>    int (*get)(char *buffer , struct kernel_param *kp ) ;
592c592
< #line 91 "include/linux/completion.h"
---
> #line 49 "include/linux/rcupdate.h"
595c595
<    void (*func)(struct rcu_head * ) ;
---
>    void (*func)(struct rcu_head *head ) ;
597c597
< #line 306 "include/linux/rcupdate.h"
---
> #line 21 "include/linux/tracepoint.h"
599c599
< #line 307 "include/linux/rcupdate.h"
---
> #line 23 "include/linux/tracepoint.h"
606,607c606,629
< };
< #line 79 "include/linux/kmemleak.h"
---
> } __attribute__((__aligned__(32))) ;
> #line 16 "include/linux/slub_def.h"
> enum stat_item {
>     ALLOC_FASTPATH = 0,
>     ALLOC_SLOWPATH = 1,
>     FREE_FASTPATH = 2,
>     FREE_SLOWPATH = 3,
>     FREE_FROZEN = 4,
>     FREE_ADD_PARTIAL = 5,
>     FREE_REMOVE_PARTIAL = 6,
>     ALLOC_FROM_PARTIAL = 7,
>     ALLOC_SLAB = 8,
>     ALLOC_REFILL = 9,
>     FREE_SLAB = 10,
>     CPUSLAB_FLUSH = 11,
>     DEACTIVATE_FULL = 12,
>     DEACTIVATE_EMPTY = 13,
>     DEACTIVATE_TO_HEAD = 14,
>     DEACTIVATE_TO_TAIL = 15,
>     DEACTIVATE_REMOTE_FREES = 16,
>     ORDER_FALLBACK = 17,
>     NR_SLUB_STAT_ITEMS = 18
> } ;
> #line 37 "include/linux/slub_def.h"
614c636
<    unsigned int stat[18U] ;
---
>    unsigned int stat[NR_SLUB_STAT_ITEMS] ;
616c638
< #line 46 "include/linux/slub_def.h"
---
> #line 48 "include/linux/slub_def.h"
625c647
< #line 57 "include/linux/slub_def.h"
---
> #line 64 "include/linux/slub_def.h"
629c651
< #line 67 "include/linux/slub_def.h"
---
> #line 71 "include/linux/slub_def.h"
649,650c671,672
<    struct kmem_cache_node *node[512U] ;
<    struct kmem_cache_cpu *cpu_slab[4096U] ;
---
>    struct kmem_cache_node *node[1 << 9] ;
>    struct kmem_cache_cpu *cpu_slab[4096] ;
652c674
< #line 155 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/local.h"
---
> #line 8 "include/asm-generic/module.h"
656c678
< #line 100 "include/trace/events/module.h"
---
> #line 35 "include/linux/module.h"
661c683
< #line 46 "include/linux/module.h"
---
> #line 49 "include/linux/module.h"
666c688
<                     size_t  ) ;
---
>                     size_t count ) ;
671c693
< #line 58
---
> #line 59
673c695
< #line 58 "include/linux/module.h"
---
> #line 59 "include/linux/module.h"
680c702
< #line 70
---
> #line 72
682c704
< #line 179
---
> #line 227
688c710
< #line 185
---
> #line 234
690c712
< #line 185
---
> #line 234
692c714
< #line 185
---
> #line 234
694c716
< #line 185 "include/linux/module.h"
---
> #line 234 "include/linux/module.h"
698c720
<    char name[56U] ;
---
>    char name[64UL - sizeof(unsigned long )] ;
757c779
<    ctor_fn_t (**ctors)(void) ;
---
>    ctor_fn_t *ctors ;
760c782
< #line 542
---
> #line 665
762c784
< #line 15 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 10 "include/linux/irqreturn.h"
770c792
< #line 32 "include/linux/input.h"
---
> #line 43 "include/linux/input.h"
777c799
< #line 58 "include/linux/input.h"
---
> #line 788 "include/linux/input.h"
782c804
< #line 792 "include/linux/input.h"
---
> #line 798 "include/linux/input.h"
787c809
< #line 802 "include/linux/input.h"
---
> #line 815 "include/linux/input.h"
794c816
< #line 821 "include/linux/input.h"
---
> #line 827 "include/linux/input.h"
799c821
< #line 831 "include/linux/input.h"
---
> #line 838 "include/linux/input.h"
805c827
< #line 843 "include/linux/input.h"
---
> #line 854 "include/linux/input.h"
814c836
< #line 864 "include/linux/input.h"
---
> #line 883 "include/linux/input.h"
825c847
< #line 895 "include/linux/input.h"
---
> #line 904 "include/linux/input.h"
830,831c852,853
< #line 908 "include/linux/input.h"
< union __anonunion_u_112 {
---
> #line 932 "include/linux/input.h"
> union __anonunion_u_125 {
835c857
<    struct ff_condition_effect condition[2U] ;
---
>    struct ff_condition_effect condition[2] ;
838c860
< #line 908 "include/linux/input.h"
---
> #line 932 "include/linux/input.h"
845c867
<    union __anonunion_u_112 u ;
---
>    union __anonunion_u_125 u ;
847c869
< #line 947
---
> #line 19 "include/linux/klist.h"
849c871
< #line 37 "include/linux/klist.h"
---
> #line 39 "include/linux/klist.h"
855c877
< #line 67 "include/linux/klist.h"
---
> #line 16 "include/linux/semaphore.h"
861c883
< #line 48 "include/linux/semaphore.h"
---
> #line 4 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/device.h"
863c885
< #line 48 "include/linux/semaphore.h"
---
> #line 4 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/device.h"
869c891
< #line 17 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/device.h"
---
> #line 30 "include/linux/device.h"
871c893
< #line 18
---
> #line 32
873c895
< #line 19
---
> #line 33
875c897
< #line 20
---
> #line 34
877c899
< #line 21
---
> #line 35
879c901
< #line 22
---
> #line 36
881c903
< #line 23 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/device.h"
---
> #line 38 "include/linux/device.h"
884,885c906,907
<    ssize_t (*show)(struct bus_type * , char * ) ;
<    ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
---
>    ssize_t (*show)(struct bus_type *bus , char *buf ) ;
>    ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
887c909
< #line 50 "include/linux/device.h"
---
> #line 51
889c911
< #line 50
---
> #line 51
891c913
< #line 50 "include/linux/device.h"
---
> #line 51 "include/linux/device.h"
897,903c919,925
<    int (*match)(struct device * , struct device_driver * ) ;
<    int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
<    int (*probe)(struct device * ) ;
<    int (*remove)(struct device * ) ;
<    void (*shutdown)(struct device * ) ;
<    int (*suspend)(struct device * , pm_message_t  ) ;
<    int (*resume)(struct device * ) ;
---
>    int (*match)(struct device *dev , struct device_driver *drv ) ;
>    int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
>    int (*probe)(struct device *dev ) ;
>    int (*remove)(struct device *dev ) ;
>    void (*shutdown)(struct device *dev ) ;
>    int (*suspend)(struct device *dev , pm_message_t state ) ;
>    int (*resume)(struct device *dev ) ;
907c929
< #line 121 "include/linux/device.h"
---
> #line 122 "include/linux/device.h"
913,917c935,939
<    int (*probe)(struct device * ) ;
<    int (*remove)(struct device * ) ;
<    void (*shutdown)(struct device * ) ;
<    int (*suspend)(struct device * , pm_message_t  ) ;
<    int (*resume)(struct device * ) ;
---
>    int (*probe)(struct device *dev ) ;
>    int (*remove)(struct device *dev ) ;
>    void (*shutdown)(struct device *dev ) ;
>    int (*suspend)(struct device *dev , pm_message_t state ) ;
>    int (*resume)(struct device *dev ) ;
922c944
< #line 151 "include/linux/device.h"
---
> #line 155 "include/linux/device.h"
925,926c947,948
<    ssize_t (*show)(struct device_driver * , char * ) ;
<    ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
---
>    ssize_t (*show)(struct device_driver *driver , char *buf ) ;
>    ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
928c950
< #line 181
---
> #line 187
930c952
< #line 181 "include/linux/device.h"
---
> #line 187 "include/linux/device.h"
937,942c959,964
<    int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
<    char *(*devnode)(struct device * , mode_t * ) ;
<    void (*class_release)(struct class * ) ;
<    void (*dev_release)(struct device * ) ;
<    int (*suspend)(struct device * , pm_message_t  ) ;
<    int (*resume)(struct device * ) ;
---
>    int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
>    char *(*devnode)(struct device *dev , mode_t *mode ) ;
>    void (*class_release)(struct class *class ) ;
>    void (*dev_release)(struct device *dev ) ;
>    int (*suspend)(struct device *dev , pm_message_t state ) ;
>    int (*resume)(struct device *dev ) ;
946c968
< #line 208
---
> #line 209
948c970
< #line 247 "include/linux/device.h"
---
> #line 250 "include/linux/device.h"
951,952c973,974
<    ssize_t (*show)(struct class * , char * ) ;
<    ssize_t (*store)(struct class * , char const   * , size_t  ) ;
---
>    ssize_t (*show)(struct class *class , char *buf ) ;
>    ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
954c976
< #line 279 "include/linux/device.h"
---
> #line 297 "include/linux/device.h"
958,960c980,982
<    int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
<    char *(*devnode)(struct device * , mode_t * ) ;
<    void (*release)(struct device * ) ;
---
>    int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
>    char *(*devnode)(struct device *dev , mode_t *mode ) ;
>    void (*release)(struct device *dev ) ;
963c985
< #line 306 "include/linux/device.h"
---
> #line 308 "include/linux/device.h"
966,968c988,990
<    ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
<    ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
<                     size_t  ) ;
---
>    ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
>    ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
>                     size_t count ) ;
970c992
< #line 367 "include/linux/device.h"
---
> #line 368 "include/linux/device.h"
975c997
< #line 376
---
> #line 377
977c999
< #line 376 "include/linux/device.h"
---
> #line 377 "include/linux/device.h"
1002c1024
<    void (*release)(struct device * ) ;
---
>    void (*release)(struct device *dev ) ;
1004c1026
< #line 394 "include/linux/rculist.h"
---
> #line 11 "include/linux/dcache.h"
1006c1028
< #line 395
---
> #line 12
1008c1030
< #line 396
---
> #line 13
1010c1032
< #line 397 "include/linux/rculist.h"
---
> #line 33 "include/linux/dcache.h"
1016c1038
< #line 77 "include/linux/dcache.h"
---
> #line 89
1018,1019c1040,1041
< #line 77 "include/linux/dcache.h"
< union __anonunion_d_u_113 {
---
> #line 89 "include/linux/dcache.h"
> union __anonunion_d_u_126 {
1023c1045
< #line 77
---
> #line 89
1025c1047
< #line 77
---
> #line 89
1027c1049
< #line 77 "include/linux/dcache.h"
---
> #line 89 "include/linux/dcache.h"
1038c1060
<    union __anonunion_d_u_113 d_u ;
---
>    union __anonunion_d_u_126 d_u ;
1045c1067
<    unsigned char d_iname[32U] ;
---
>    unsigned char d_iname[32] ;
1047c1069
< #line 126 "include/linux/dcache.h"
---
> #line 134 "include/linux/dcache.h"
1057c1079
< #line 382 "include/linux/dcache.h"
---
> #line 7 "include/linux/path.h"
1062c1084
< #line 55 "include/linux/radix-tree.h"
---
> #line 61 "include/linux/radix-tree.h"
1064c1086
< #line 55 "include/linux/radix-tree.h"
---
> #line 61 "include/linux/radix-tree.h"
1070c1092
< #line 193
---
> #line 14 "include/linux/prio_tree.h"
1072c1094
< #line 19 "include/linux/prio_tree.h"
---
> #line 20 "include/linux/prio_tree.h"
1080c1102
< #line 27 "include/linux/prio_tree.h"
---
> #line 28 "include/linux/prio_tree.h"
1086c1108
< #line 111
---
> #line 6 "include/linux/pid.h"
1093c1115
< #line 118
---
> #line 50
1095c1117
< #line 118 "include/linux/prio_tree.h"
---
> #line 50 "include/linux/pid.h"
1101c1123
< #line 56 "include/linux/pid.h"
---
> #line 57 "include/linux/pid.h"
1105c1127
<    struct hlist_head tasks[3U] ;
---
>    struct hlist_head tasks[PIDTYPE_MAX] ;
1107c1129
<    struct upid numbers[1U] ;
---
>    struct upid numbers[1] ;
1109c1131
< #line 570 "include/linux/capability.h"
---
> #line 16 "include/linux/fiemap.h"
1114c1136
<    __u64 fe_reserved64[2U] ;
---
>    __u64 fe_reserved64[2] ;
1116c1138
<    __u32 fe_reserved[3U] ;
---
>    __u32 fe_reserved[3] ;
1118c1140
< #line 38 "include/linux/fiemap.h"
---
> #line 384 "include/linux/fs.h"
1120c1142
< #line 40
---
> #line 386
1122c1144
< #line 41
---
> #line 388
1124c1146
< #line 42
---
> #line 389
1126c1148
< #line 43
---
> #line 390
1128c1150
< #line 44
---
> #line 391
1130c1152
< #line 45
---
> #line 394
1132c1154
< #line 413 "include/linux/fs.h"
---
> #line 446 "include/linux/fs.h"
1144c1166
< #line 472 "include/linux/fs.h"
---
> #line 106 "include/linux/quota.h"
1156c1178
< #line 117 "include/linux/quota.h"
---
> #line 127 "include/linux/quota.h"
1163c1185
< #line 150 "include/linux/quota.h"
---
> #line 50 "include/linux/dqblk_xfs.h"
1186c1208
<    char d_padding4[8U] ;
---
>    char d_padding4[8] ;
1188c1210
< #line 75 "include/linux/dqblk_xfs.h"
---
> #line 137 "include/linux/dqblk_xfs.h"
1194c1216
< #line 141 "include/linux/dqblk_xfs.h"
---
> #line 137 "include/linux/dqblk_xfs.h"
1196c1218
< #line 142 "include/linux/dqblk_xfs.h"
---
> #line 143 "include/linux/dqblk_xfs.h"
1210c1232
< #line 156
---
> #line 17 "include/linux/dqblk_qtree.h"
1216c1238
< #line 186 "include/linux/quota.h"
---
> #line 197 "include/linux/quota.h"
1228c1250
< #line 208
---
> #line 212
1230c1252
< #line 209 "include/linux/quota.h"
---
> #line 214 "include/linux/quota.h"
1242c1264
< #line 251 "include/linux/quota.h"
---
> #line 264 "include/linux/quota.h"
1258c1280
< #line 279 "include/linux/quota.h"
---
> #line 284 "include/linux/quota.h"
1260,1266c1282,1288
<    int (*check_quota_file)(struct super_block * , int  ) ;
<    int (*read_file_info)(struct super_block * , int  ) ;
<    int (*write_file_info)(struct super_block * , int  ) ;
<    int (*free_file_info)(struct super_block * , int  ) ;
<    int (*read_dqblk)(struct dquot * ) ;
<    int (*commit_dqblk)(struct dquot * ) ;
<    int (*release_dqblk)(struct dquot * ) ;
---
>    int (*check_quota_file)(struct super_block *sb , int type ) ;
>    int (*read_file_info)(struct super_block *sb , int type ) ;
>    int (*write_file_info)(struct super_block *sb , int type ) ;
>    int (*free_file_info)(struct super_block *sb , int type ) ;
>    int (*read_dqblk)(struct dquot *dquot ) ;
>    int (*commit_dqblk)(struct dquot *dquot ) ;
>    int (*release_dqblk)(struct dquot *dquot ) ;
1268c1290
< #line 293 "include/linux/quota.h"
---
> #line 295 "include/linux/quota.h"
1289c1311
< #line 319 "include/linux/quota.h"
---
> #line 321 "include/linux/quota.h"
1303c1325
< #line 334 "include/linux/quota.h"
---
> #line 335 "include/linux/quota.h"
1310c1332
< #line 378 "include/linux/quota.h"
---
> #line 379 "include/linux/quota.h"
1316,1318c1338,1340
<    struct inode *files[2U] ;
<    struct mem_dqinfo info[2U] ;
<    struct quota_format_ops *ops[2U] ;
---
>    struct inode *files[2] ;
>    struct mem_dqinfo info[2] ;
>    struct quota_format_ops *ops[2] ;
1320c1342
< #line 401
---
> #line 510 "include/linux/fs.h"
1322c1344
< #line 402
---
> #line 511
1324,1325c1346,1347
< #line 562 "include/linux/fs.h"
< union __anonunion_arg_116 {
---
> #line 554 "include/linux/fs.h"
> union __anonunion_arg_133 {
1329,1330c1351,1352
< #line 562 "include/linux/fs.h"
< struct __anonstruct_read_descriptor_t_115 {
---
> #line 554 "include/linux/fs.h"
> struct __anonstruct_read_descriptor_t_132 {
1333c1355
<    union __anonunion_arg_116 arg ;
---
>    union __anonunion_arg_133 arg ;
1336,1338c1358,1360
< #line 562 "include/linux/fs.h"
< typedef struct __anonstruct_read_descriptor_t_115 read_descriptor_t;
< #line 565 "include/linux/fs.h"
---
> #line 554 "include/linux/fs.h"
> typedef struct __anonstruct_read_descriptor_t_132 read_descriptor_t;
> #line 567 "include/linux/fs.h"
1340c1362
<    int (*writepage)(struct page * , struct writeback_control * ) ;
---
>    int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
1344,1350c1366,1373
<    int (*set_page_dirty)(struct page * ) ;
<    int (*readpages)(struct file * , struct address_space * , struct list_head * ,
<                     unsigned int  ) ;
<    int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
<                       unsigned int  , struct page ** , void ** ) ;
<    int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
<                     unsigned int  , struct page * , void * ) ;
---
>    int (*set_page_dirty)(struct page *page ) ;
>    int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
>                     unsigned int nr_pages ) ;
>    int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
>                       unsigned int len , unsigned int flags , struct page **pagep ,
>                       void **fsdata ) ;
>    int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
>                     unsigned int copied , struct page *page , void *fsdata ) ;
1354,1355c1377,1378
<    ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
<                         unsigned long  ) ;
---
>    ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
>                         unsigned long nr_segs ) ;
1362c1385
< #line 614
---
> #line 617
1364c1387
< #line 615 "include/linux/fs.h"
---
> #line 618 "include/linux/fs.h"
1382,1383c1405,1406
< };
< #line 636
---
> } __attribute__((__aligned__(sizeof(long )))) ;
> #line 642
1385c1408
< #line 636
---
> #line 642
1387c1410
< #line 636 "include/linux/fs.h"
---
> #line 642 "include/linux/fs.h"
1409c1432
< #line 704
---
> #line 716
1411c1434
< #line 705
---
> #line 719
1413c1436
< #line 705
---
> #line 719
1415c1438
< #line 705
---
> #line 719
1417c1440
< #line 705
---
> #line 719
1419,1420c1442,1443
< #line 705 "include/linux/fs.h"
< union __anonunion_ldv_14490_117 {
---
> #line 719 "include/linux/fs.h"
> union __anonunion____missing_field_name_134 {
1425c1448
< #line 705 "include/linux/fs.h"
---
> #line 719 "include/linux/fs.h"
1455c1478
<    struct dquot *i_dquot[2U] ;
---
>    struct dquot *i_dquot[2] ;
1457c1480
<    union __anonunion_ldv_14490_117 ldv_14490 ;
---
>    union __anonunion____missing_field_name_134 __annonCompField19 ;
1472c1495
< #line 873 "include/linux/fs.h"
---
> #line 874 "include/linux/fs.h"
1481c1504
< #line 881 "include/linux/fs.h"
---
> #line 885 "include/linux/fs.h"
1490,1491c1513,1514
< #line 904 "include/linux/fs.h"
< union __anonunion_f_u_118 {
---
> #line 908 "include/linux/fs.h"
> union __anonunion_f_u_135 {
1495c1518
< #line 904 "include/linux/fs.h"
---
> #line 908 "include/linux/fs.h"
1497c1520
<    union __anonunion_f_u_118 f_u ;
---
>    union __anonunion_f_u_135 f_u ;
1519c1542
< #line 1028 "include/linux/fs.h"
---
> #line 1029 "include/linux/fs.h"
1524c1547
< #line 1033 "include/linux/fs.h"
---
> #line 1034 "include/linux/fs.h"
1535c1558
< #line 163 "include/linux/nfs.h"
---
> #line 8 "include/linux/nfs_fs_i.h"
1537c1560
< #line 164 "include/linux/nfs.h"
---
> #line 13 "include/linux/nfs_fs_i.h"
1543c1566
< #line 18 "include/linux/nfs_fs_i.h"
---
> #line 19
1545c1568
< #line 19 "include/linux/nfs_fs_i.h"
---
> #line 20 "include/linux/nfs_fs_i.h"
1549c1572
< #line 23
---
> #line 1056 "include/linux/fs.h"
1551,1552c1574,1575
< #line 23 "include/linux/nfs_fs_i.h"
< struct __anonstruct_afs_120 {
---
> #line 1056 "include/linux/fs.h"
> struct __anonstruct_afs_137 {
1556,1557c1579,1580
< #line 23 "include/linux/nfs_fs_i.h"
< union __anonunion_fl_u_119 {
---
> #line 1056 "include/linux/fs.h"
> union __anonunion_fl_u_136 {
1560c1583
<    struct __anonstruct_afs_120 afs ;
---
>    struct __anonstruct_afs_137 afs ;
1562c1585
< #line 23 "include/linux/nfs_fs_i.h"
---
> #line 1056 "include/linux/fs.h"
1580c1603
<    union __anonunion_fl_u_119 fl_u ;
---
>    union __anonunion_fl_u_136 fl_u ;
1582c1605
< #line 1136 "include/linux/fs.h"
---
> #line 1281 "include/linux/fs.h"
1589c1612
< #line 1313
---
> #line 1316
1591c1614
< #line 1313
---
> #line 1316
1593c1616
< #line 1313
---
> #line 1316
1595c1618
< #line 1313
---
> #line 1316
1597c1620
< #line 1313 "include/linux/fs.h"
---
> #line 1316 "include/linux/fs.h"
1632c1655
<    char s_id[32U] ;
---
>    char s_id[32] ;
1640c1663
< #line 1431 "include/linux/fs.h"
---
> #line 1435 "include/linux/fs.h"
1647c1670
< #line 1470 "include/linux/fs.h"
---
> #line 1482 "include/linux/fs.h"
1665c1688
<    int (*flush)(struct file * , fl_owner_t  ) ;
---
>    int (*flush)(struct file * , fl_owner_t id ) ;
1667,1668c1690,1691
<    int (*fsync)(struct file * , struct dentry * , int  ) ;
<    int (*aio_fsync)(struct kiocb * , int  ) ;
---
>    int (*fsync)(struct file * , struct dentry * , int datasync ) ;
>    int (*aio_fsync)(struct kiocb * , int datasync ) ;
1683c1706
< #line 1510 "include/linux/fs.h"
---
> #line 1511 "include/linux/fs.h"
1701c1724
<    int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
---
>    int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
1707,1708c1730,1731
<    long (*fallocate)(struct inode * , int  , loff_t  , loff_t  ) ;
<    int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
---
>    long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
>    int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
1710c1733
< #line 1553 "include/linux/fs.h"
---
> #line 1555 "include/linux/fs.h"
1712c1735
<    struct inode *(*alloc_inode)(struct super_block * ) ;
---
>    struct inode *(*alloc_inode)(struct super_block *sb ) ;
1720c1743
<    int (*sync_fs)(struct super_block * , int  ) ;
---
>    int (*sync_fs)(struct super_block *sb , int wait ) ;
1734c1757
< #line 1737 "include/linux/fs.h"
---
> #line 1738 "include/linux/fs.h"
1752c1775
< #line 205 "include/linux/mod_devicetable.h"
---
> #line 209 "include/linux/mod_devicetable.h"
1759c1782
< #line 269 "include/linux/mod_devicetable.h"
---
> #line 312 "include/linux/mod_devicetable.h"
1766,1774c1789,1797
<    kernel_ulong_t evbit[1U] ;
<    kernel_ulong_t keybit[12U] ;
<    kernel_ulong_t relbit[1U] ;
<    kernel_ulong_t absbit[1U] ;
<    kernel_ulong_t mscbit[1U] ;
<    kernel_ulong_t ledbit[1U] ;
<    kernel_ulong_t sndbit[1U] ;
<    kernel_ulong_t ffbit[2U] ;
<    kernel_ulong_t swbit[1U] ;
---
>    kernel_ulong_t evbit[31 / 64 + 1] ;
>    kernel_ulong_t keybit[767 / 64 + 1] ;
>    kernel_ulong_t relbit[15 / 64 + 1] ;
>    kernel_ulong_t absbit[63 / 64 + 1] ;
>    kernel_ulong_t mscbit[7 / 64 + 1] ;
>    kernel_ulong_t ledbit[15 / 64 + 1] ;
>    kernel_ulong_t sndbit[7 / 64 + 1] ;
>    kernel_ulong_t ffbit[127 / 64 + 1] ;
>    kernel_ulong_t swbit[15 / 64 + 1] ;
1777c1800
< #line 475
---
> #line 1072 "include/linux/input.h"
1779c1802
< #line 475
---
> #line 1072
1781c1804
< #line 475 "include/linux/mod_devicetable.h"
---
> #line 1072 "include/linux/input.h"
1787,1795c1810,1818
<    unsigned long evbit[1U] ;
<    unsigned long keybit[12U] ;
<    unsigned long relbit[1U] ;
<    unsigned long absbit[1U] ;
<    unsigned long mscbit[1U] ;
<    unsigned long ledbit[1U] ;
<    unsigned long sndbit[1U] ;
<    unsigned long ffbit[2U] ;
<    unsigned long swbit[1U] ;
---
>    unsigned long evbit[(((unsigned long )(31 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    unsigned long keybit[(((unsigned long )(767 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    unsigned long relbit[(((unsigned long )(15 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    unsigned long absbit[(((unsigned long )(63 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    unsigned long mscbit[(((unsigned long )(7 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    unsigned long ledbit[(((unsigned long )(15 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    unsigned long sndbit[(((unsigned long )(7 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    unsigned long ffbit[(((unsigned long )(127 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    unsigned long swbit[(((unsigned long )(15 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
1799,1800c1822,1823
<    int (*setkeycode)(struct input_dev * , int  , int  ) ;
<    int (*getkeycode)(struct input_dev * , int  , int * ) ;
---
>    int (*setkeycode)(struct input_dev *dev , int scancode , int keycode ) ;
>    int (*getkeycode)(struct input_dev *dev , int scancode , int *keycode ) ;
1805,1819c1828,1842
<    int abs[64U] ;
<    int rep[2U] ;
<    unsigned long key[12U] ;
<    unsigned long led[1U] ;
<    unsigned long snd[1U] ;
<    unsigned long sw[1U] ;
<    int absmax[64U] ;
<    int absmin[64U] ;
<    int absfuzz[64U] ;
<    int absflat[64U] ;
<    int absres[64U] ;
<    int (*open)(struct input_dev * ) ;
<    void (*close)(struct input_dev * ) ;
<    int (*flush)(struct input_dev * , struct file * ) ;
<    int (*event)(struct input_dev * , unsigned int  , unsigned int  , int  ) ;
---
>    int abs[63 + 1] ;
>    int rep[1 + 1] ;
>    unsigned long key[(((unsigned long )(767 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    unsigned long led[(((unsigned long )(15 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    unsigned long snd[(((unsigned long )(7 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    unsigned long sw[(((unsigned long )(15 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
>    int absmax[63 + 1] ;
>    int absmin[63 + 1] ;
>    int absfuzz[63 + 1] ;
>    int absflat[63 + 1] ;
>    int absres[63 + 1] ;
>    int (*open)(struct input_dev *dev ) ;
>    void (*close)(struct input_dev *dev ) ;
>    int (*flush)(struct input_dev *dev , struct file *file ) ;
>    int (*event)(struct input_dev *dev , unsigned int type , unsigned int code , int value ) ;
1829c1852
< #line 1133 "include/linux/input.h"
---
> #line 1216 "include/linux/input.h"
1832,1835c1855,1859
<    void (*event)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
<    int (*connect)(struct input_handler * , struct input_dev * , struct input_device_id  const  * ) ;
<    void (*disconnect)(struct input_handle * ) ;
<    void (*start)(struct input_handle * ) ;
---
>    void (*event)(struct input_handle *handle , unsigned int type , unsigned int code ,
>                  int value ) ;
>    int (*connect)(struct input_handler *handler , struct input_dev *dev , struct input_device_id  const  *id ) ;
>    void (*disconnect)(struct input_handle *handle ) ;
>    void (*start)(struct input_handle *handle ) ;
1844c1868
< #line 1235 "include/linux/input.h"
---
> #line 1248 "include/linux/input.h"
1854c1878
< #line 1357 "include/linux/input.h"
---
> #line 1381 "include/linux/input.h"
1856,1860c1880,1884
<    int (*upload)(struct input_dev * , struct ff_effect * , struct ff_effect * ) ;
<    int (*erase)(struct input_dev * , int  ) ;
<    int (*playback)(struct input_dev * , int  , int  ) ;
<    void (*set_gain)(struct input_dev * , u16  ) ;
<    void (*set_autocenter)(struct input_dev * , u16  ) ;
---
>    int (*upload)(struct input_dev *dev , struct ff_effect *effect , struct ff_effect *old ) ;
>    int (*erase)(struct input_dev *dev , int effect_id ) ;
>    int (*playback)(struct input_dev *dev , int effect_id , int value ) ;
>    void (*set_gain)(struct input_dev *dev , u16 gain ) ;
>    void (*set_autocenter)(struct input_dev *dev , u16 magnitude ) ;
1863c1887
<    unsigned long ffbit[2U] ;
---
>    unsigned long ffbit[(((unsigned long )(127 + 1) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
1869c1893
< #line 1412
---
> #line 26 "include/linux/serio.h"
1871c1895
< #line 1412 "include/linux/input.h"
---
> #line 26 "include/linux/serio.h"
1874,1875c1898,1899
<    char name[32U] ;
<    char phys[32U] ;
---
>    char name[32] ;
>    char phys[32] ;
1893c1917
< #line 55 "include/linux/serio.h"
---
> #line 57 "include/linux/serio.h"
1901c1925
<    int (*connect)(struct serio * , struct serio_driver * ) ;
---
>    int (*connect)(struct serio * , struct serio_driver *drv ) ;
1907c1931
< #line 107 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 115 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
1911c1935
<    unsigned char buf[15U] ;
---
>    unsigned char buf[15] ;
1916,1917c1940,3418
<    char name[64U] ;
<    char phys[32U] ;
---
>    char name[64] ;
>    char phys[32] ;
> };
> #line 29 "include/asm-generic/int-ll64.h"
> typedef long long __s64;
> #line 43 "include/asm-generic/int-ll64.h"
> typedef unsigned char u8;
> #line 51 "include/asm-generic/int-ll64.h"
> typedef long long s64;
> #line 14 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/types.h"
> typedef u64 dma_addr_t;
> #line 14 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/posix_types_64.h"
> typedef int __kernel_pid_t;
> #line 23 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/posix_types_64.h"
> typedef long __kernel_clock_t;
> #line 24 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/posix_types_64.h"
> typedef int __kernel_timer_t;
> #line 26 "include/linux/types.h"
> typedef __kernel_pid_t pid_t;
> #line 107 "include/linux/types.h"
> typedef __s32 int32_t;
> #line 113 "include/linux/types.h"
> typedef __u32 uint32_t;
> #line 168 "include/linux/types.h"
> typedef __u16 __le16;
> #line 116 "include/linux/kernel.h"
> struct completion;
> #line 8 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> struct mm_struct;
> #line 141 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/vm86.h"
> struct kernel_vm86_regs {
>    struct pt_regs pt ;
>    unsigned short es ;
>    unsigned short __esh ;
>    unsigned short ds ;
>    unsigned short __dsh ;
>    unsigned short fs ;
>    unsigned short __fsh ;
>    unsigned short gs ;
>    unsigned short __gsh ;
> };
> #line 11 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/math_emu.h"
> union __anonunion____missing_field_name_10 {
>    struct pt_regs *regs ;
>    struct kernel_vm86_regs *vm86 ;
> };
> #line 11 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/math_emu.h"
> struct math_emu_info {
>    long ___orig_eip ;
>    union __anonunion____missing_field_name_10 __annonCompField4 ;
> };
> #line 13 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/pgtable_64_types.h"
> typedef unsigned long pgdval_t;
> #line 14 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/pgtable_64_types.h"
> typedef unsigned long pgprotval_t;
> #line 187 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/pgtable_types.h"
> struct pgprot {
>    pgprotval_t pgprot ;
> };
> #line 187 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/pgtable_types.h"
> typedef struct pgprot pgprot_t;
> #line 189 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/pgtable_types.h"
> struct __anonstruct_pgd_t_13 {
>    pgdval_t pgd ;
> };
> #line 189 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/pgtable_types.h"
> typedef struct __anonstruct_pgd_t_13 pgd_t;
> #line 22 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/desc_defs.h"
> struct __anonstruct____missing_field_name_18 {
>    unsigned int a ;
>    unsigned int b ;
> };
> #line 22 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/desc_defs.h"
> struct __anonstruct____missing_field_name_19 {
>    u16 limit0 ;
>    u16 base0 ;
>    unsigned int base1 : 8 ;
>    unsigned int type : 4 ;
>    unsigned int s : 1 ;
>    unsigned int dpl : 2 ;
>    unsigned int p : 1 ;
>    unsigned int limit : 4 ;
>    unsigned int avl : 1 ;
>    unsigned int l : 1 ;
>    unsigned int d : 1 ;
>    unsigned int g : 1 ;
>    unsigned int base2 : 8 ;
> };
> #line 22 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/desc_defs.h"
> union __anonunion____missing_field_name_17 {
>    struct __anonstruct____missing_field_name_18 __annonCompField6 ;
>    struct __anonstruct____missing_field_name_19 __annonCompField7 ;
> };
> #line 22 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/desc_defs.h"
> struct desc_struct {
>    union __anonunion____missing_field_name_17 __annonCompField8 ;
> } __attribute__((__packed__)) ;
> #line 46 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/paravirt_types.h"
> struct thread_struct;
> #line 52
> struct cpumask;
> #line 13 "include/linux/cpumask.h"
> struct cpumask {
>    unsigned long bits[((4096UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
> };
> #line 13 "include/linux/cpumask.h"
> typedef struct cpumask cpumask_t;
> #line 286 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> struct i387_fsave_struct {
>    u32 cwd ;
>    u32 swd ;
>    u32 twd ;
>    u32 fip ;
>    u32 fcs ;
>    u32 foo ;
>    u32 fos ;
>    u32 st_space[20] ;
>    u32 status ;
> };
> #line 302 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> struct __anonstruct____missing_field_name_27 {
>    u64 rip ;
>    u64 rdp ;
> };
> #line 302 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> struct __anonstruct____missing_field_name_28 {
>    u32 fip ;
>    u32 fcs ;
>    u32 foo ;
>    u32 fos ;
> };
> #line 302 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> union __anonunion____missing_field_name_26 {
>    struct __anonstruct____missing_field_name_27 __annonCompField11 ;
>    struct __anonstruct____missing_field_name_28 __annonCompField12 ;
> };
> #line 302 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> union __anonunion____missing_field_name_29 {
>    u32 padding1[12] ;
>    u32 sw_reserved[12] ;
> };
> #line 302 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> struct i387_fxsave_struct {
>    u16 cwd ;
>    u16 swd ;
>    u16 twd ;
>    u16 fop ;
>    union __anonunion____missing_field_name_26 __annonCompField13 ;
>    u32 mxcsr ;
>    u32 mxcsr_mask ;
>    u32 st_space[32] ;
>    u32 xmm_space[64] ;
>    u32 padding[12] ;
>    union __anonunion____missing_field_name_29 __annonCompField14 ;
> } __attribute__((__aligned__(16))) ;
> #line 337 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> struct i387_soft_struct {
>    u32 cwd ;
>    u32 swd ;
>    u32 twd ;
>    u32 fip ;
>    u32 fcs ;
>    u32 foo ;
>    u32 fos ;
>    u32 st_space[20] ;
>    u8 ftop ;
>    u8 changed ;
>    u8 lookahead ;
>    u8 no_update ;
>    u8 rm ;
>    u8 alimit ;
>    struct math_emu_info *info ;
>    u32 entry_eip ;
> };
> #line 357 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> struct ymmh_struct {
>    u32 ymmh_space[64] ;
> };
> #line 362 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> struct xsave_hdr_struct {
>    u64 xstate_bv ;
>    u64 reserved1[2] ;
>    u64 reserved2[5] ;
> } __attribute__((__packed__)) ;
> #line 368 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> struct xsave_struct {
>    struct i387_fxsave_struct i387 ;
>    struct xsave_hdr_struct xsave_hdr ;
>    struct ymmh_struct ymmh ;
> } __attribute__((__packed__, __aligned__(64))) ;
> #line 375 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> union thread_xstate {
>    struct i387_fsave_struct fsave ;
>    struct i387_fxsave_struct fxsave ;
>    struct i387_soft_struct soft ;
>    struct xsave_struct xsave ;
> };
> #line 425
> struct ds_context;
> #line 425 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
> struct thread_struct {
>    struct desc_struct tls_array[3] ;
>    unsigned long sp0 ;
>    unsigned long sp ;
>    unsigned long usersp ;
>    unsigned short es ;
>    unsigned short ds ;
>    unsigned short fsindex ;
>    unsigned short gsindex ;
>    unsigned long fs ;
>    unsigned long gs ;
>    unsigned long debugreg0 ;
>    unsigned long debugreg1 ;
>    unsigned long debugreg2 ;
>    unsigned long debugreg3 ;
>    unsigned long debugreg6 ;
>    unsigned long debugreg7 ;
>    unsigned long cr2 ;
>    unsigned long trap_no ;
>    unsigned long error_code ;
>    union thread_xstate *xstate ;
>    unsigned long *io_bitmap_ptr ;
>    unsigned long iopl ;
>    unsigned int io_bitmap_max ;
>    unsigned long debugctlmsr ;
>    struct ds_context *ds_ctx ;
> };
> #line 179 "include/linux/lockdep.h"
> struct held_lock {
>    u64 prev_chain_key ;
>    unsigned long acquire_ip ;
>    struct lockdep_map *instance ;
>    struct lockdep_map *nest_lock ;
>    u64 waittime_stamp ;
>    u64 holdtime_stamp ;
>    unsigned int class_idx : 13 ;
>    unsigned int irq_context : 2 ;
>    unsigned int trylock : 1 ;
>    unsigned int read : 2 ;
>    unsigned int check : 2 ;
>    unsigned int hardirqs_off : 1 ;
>    unsigned int references : 11 ;
> };
> #line 28 "include/linux/wait.h"
> struct __wait_queue;
> #line 28 "include/linux/wait.h"
> typedef struct __wait_queue wait_queue_t;
> #line 32 "include/linux/wait.h"
> struct __wait_queue {
>    unsigned int flags ;
>    void *private ;
>    int (*func)(wait_queue_t *wait , unsigned int mode , int flags , void *key ) ;
>    struct list_head task_list ;
> };
> #line 98 "include/linux/nodemask.h"
> struct __anonstruct_nodemask_t_41 {
>    unsigned long bits[(((unsigned long )(1 << 9) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
> };
> #line 98 "include/linux/nodemask.h"
> typedef struct __anonstruct_nodemask_t_41 nodemask_t;
> #line 69 "include/linux/mutex.h"
> struct mutex_waiter {
>    struct list_head list ;
>    struct task_struct *task ;
>    void *magic ;
> };
> #line 46 "include/linux/ktime.h"
> union ktime {
>    s64 tv64 ;
> };
> #line 59 "include/linux/ktime.h"
> typedef union ktime ktime_t;
> #line 240 "include/linux/timer.h"
> struct hrtimer;
> #line 241
> enum hrtimer_restart;
> #line 39 "include/linux/workqueue.h"
> struct delayed_work {
>    struct work_struct work ;
>    struct timer_list timer ;
> };
> #line 11 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/mmu.h"
> struct __anonstruct_mm_context_t_108 {
>    void *ldt ;
>    int size ;
>    struct mutex lock ;
>    void *vdso ;
> };
> #line 11 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/mmu.h"
> typedef struct __anonstruct_mm_context_t_108 mm_context_t;
> #line 45 "include/linux/kmod.h"
> struct key;
> #line 25 "include/linux/completion.h"
> struct completion {
>    unsigned int done ;
>    wait_queue_head_t wait ;
> };
> #line 217 "include/linux/usb/ch9.h"
> struct usb_device_descriptor {
>    __u8 bLength ;
>    __u8 bDescriptorType ;
>    __le16 bcdUSB ;
>    __u8 bDeviceClass ;
>    __u8 bDeviceSubClass ;
>    __u8 bDeviceProtocol ;
>    __u8 bMaxPacketSize0 ;
>    __le16 idVendor ;
>    __le16 idProduct ;
>    __le16 bcdDevice ;
>    __u8 iManufacturer ;
>    __u8 iProduct ;
>    __u8 iSerialNumber ;
>    __u8 bNumConfigurations ;
> } __attribute__((__packed__)) ;
> #line 273 "include/linux/usb/ch9.h"
> struct usb_config_descriptor {
>    __u8 bLength ;
>    __u8 bDescriptorType ;
>    __le16 wTotalLength ;
>    __u8 bNumInterfaces ;
>    __u8 bConfigurationValue ;
>    __u8 iConfiguration ;
>    __u8 bmAttributes ;
>    __u8 bMaxPower ;
> } __attribute__((__packed__)) ;
> #line 310 "include/linux/usb/ch9.h"
> struct usb_interface_descriptor {
>    __u8 bLength ;
>    __u8 bDescriptorType ;
>    __u8 bInterfaceNumber ;
>    __u8 bAlternateSetting ;
>    __u8 bNumEndpoints ;
>    __u8 bInterfaceClass ;
>    __u8 bInterfaceSubClass ;
>    __u8 bInterfaceProtocol ;
>    __u8 iInterface ;
> } __attribute__((__packed__)) ;
> #line 328 "include/linux/usb/ch9.h"
> struct usb_endpoint_descriptor {
>    __u8 bLength ;
>    __u8 bDescriptorType ;
>    __u8 bEndpointAddress ;
>    __u8 bmAttributes ;
>    __le16 wMaxPacketSize ;
>    __u8 bInterval ;
>    __u8 bRefresh ;
>    __u8 bSynchAddress ;
> } __attribute__((__packed__)) ;
> #line 549 "include/linux/usb/ch9.h"
> struct usb_ss_ep_comp_descriptor {
>    __u8 bLength ;
>    __u8 bDescriptorType ;
>    __u8 bMaxBurst ;
>    __u8 bmAttributes ;
>    __u16 wBytesPerInterval ;
> } __attribute__((__packed__)) ;
> #line 606 "include/linux/usb/ch9.h"
> struct usb_interface_assoc_descriptor {
>    __u8 bLength ;
>    __u8 bDescriptorType ;
>    __u8 bFirstInterface ;
>    __u8 bInterfaceCount ;
>    __u8 bFunctionClass ;
>    __u8 bFunctionSubClass ;
>    __u8 bFunctionProtocol ;
>    __u8 iFunction ;
> } __attribute__((__packed__)) ;
> #line 774
> enum usb_device_speed {
>     USB_SPEED_UNKNOWN = 0,
>     USB_SPEED_LOW = 1,
>     USB_SPEED_FULL = 2,
>     USB_SPEED_HIGH = 3,
>     USB_SPEED_VARIABLE = 4,
>     USB_SPEED_SUPER = 5
> } ;
> #line 782
> enum usb_device_state {
>     USB_STATE_NOTATTACHED = 0,
>     USB_STATE_ATTACHED = 1,
>     USB_STATE_POWERED = 2,
>     USB_STATE_RECONNECTING = 3,
>     USB_STATE_UNAUTHENTICATED = 4,
>     USB_STATE_DEFAULT = 5,
>     USB_STATE_ADDRESS = 6,
>     USB_STATE_CONFIGURED = 7,
>     USB_STATE_SUSPENDED = 8
> } ;
> #line 83 "include/linux/irq.h"
> struct proc_dir_entry;
> #line 175
> struct irqaction;
> #line 100 "include/linux/rbtree.h"
> struct rb_node {
>    unsigned long rb_parent_color ;
>    struct rb_node *rb_right ;
>    struct rb_node *rb_left ;
> } __attribute__((__aligned__(sizeof(long )))) ;
> #line 110 "include/linux/rbtree.h"
> struct rb_root {
>    struct rb_node *rb_node ;
> };
> #line 27 "include/linux/hrtimer.h"
> struct hrtimer_clock_base;
> #line 28
> struct hrtimer_cpu_base;
> #line 44
> enum hrtimer_restart {
>     HRTIMER_NORESTART = 0,
>     HRTIMER_RESTART = 1
> } ;
> #line 103 "include/linux/hrtimer.h"
> struct hrtimer {
>    struct rb_node node ;
>    ktime_t _expires ;
>    ktime_t _softexpires ;
>    enum hrtimer_restart (*function)(struct hrtimer * ) ;
>    struct hrtimer_clock_base *base ;
>    unsigned long state ;
>    int start_pid ;
>    void *start_site ;
>    char start_comm[16] ;
> };
> #line 141 "include/linux/hrtimer.h"
> struct hrtimer_clock_base {
>    struct hrtimer_cpu_base *cpu_base ;
>    clockid_t index ;
>    struct rb_root active ;
>    struct rb_node *first ;
>    ktime_t resolution ;
>    ktime_t (*get_time)(void) ;
>    ktime_t softirq_time ;
>    ktime_t offset ;
> };
> #line 170 "include/linux/hrtimer.h"
> struct hrtimer_cpu_base {
>    spinlock_t lock ;
>    struct hrtimer_clock_base clock_base[2] ;
>    ktime_t expires_next ;
>    int hres_active ;
>    unsigned long nr_events ;
> };
> #line 95 "include/linux/interrupt.h"
> struct irqaction {
>    irqreturn_t (*handler)(int  , void * ) ;
>    unsigned long flags ;
>    char const   *name ;
>    void *dev_id ;
>    struct irqaction *next ;
>    int irq ;
>    struct proc_dir_entry *dir ;
>    irqreturn_t (*thread_fn)(int  , void * ) ;
>    struct task_struct *thread ;
>    unsigned long thread_flags ;
> };
> #line 14 "include/linux/prio_tree.h"
> struct raw_prio_tree_node {
>    struct prio_tree_node *left ;
>    struct prio_tree_node *right ;
>    struct prio_tree_node *parent ;
> };
> #line 69 "include/linux/pid.h"
> struct pid_link {
>    struct hlist_node node ;
>    struct pid *pid ;
> };
> #line 99 "include/linux/capability.h"
> struct kernel_cap_struct {
>    __u32 cap[2] ;
> };
> #line 99 "include/linux/capability.h"
> typedef struct kernel_cap_struct kernel_cap_t;
> #line 2197 "include/linux/fs.h"
> struct bio;
> #line 28 "include/linux/mm_types.h"
> typedef atomic_long_t mm_counter_t;
> #line 40 "include/linux/mm_types.h"
> struct __anonstruct____missing_field_name_141 {
>    u16 inuse ;
>    u16 objects ;
> };
> #line 40 "include/linux/mm_types.h"
> union __anonunion____missing_field_name_140 {
>    atomic_t _mapcount ;
>    struct __anonstruct____missing_field_name_141 __annonCompField20 ;
> };
> #line 40 "include/linux/mm_types.h"
> struct __anonstruct____missing_field_name_143 {
>    unsigned long private ;
>    struct address_space *mapping ;
> };
> #line 40 "include/linux/mm_types.h"
> union __anonunion____missing_field_name_142 {
>    struct __anonstruct____missing_field_name_143 __annonCompField22 ;
>    spinlock_t ptl ;
>    struct kmem_cache *slab ;
>    struct page *first_page ;
> };
> #line 40 "include/linux/mm_types.h"
> union __anonunion____missing_field_name_144 {
>    unsigned long index ;
>    void *freelist ;
> };
> #line 40 "include/linux/mm_types.h"
> struct page {
>    unsigned long flags ;
>    atomic_t _count ;
>    union __anonunion____missing_field_name_140 __annonCompField21 ;
>    union __anonunion____missing_field_name_142 __annonCompField23 ;
>    union __anonunion____missing_field_name_144 __annonCompField24 ;
>    struct list_head lru ;
> };
> #line 134 "include/linux/mm_types.h"
> struct __anonstruct_vm_set_146 {
>    struct list_head list ;
>    void *parent ;
>    struct vm_area_struct *head ;
> };
> #line 134 "include/linux/mm_types.h"
> union __anonunion_shared_145 {
>    struct __anonstruct_vm_set_146 vm_set ;
>    struct raw_prio_tree_node prio_tree_node ;
> };
> #line 134
> struct anon_vma;
> #line 134
> struct vm_operations_struct;
> #line 134
> struct mempolicy;
> #line 134 "include/linux/mm_types.h"
> struct vm_area_struct {
>    struct mm_struct *vm_mm ;
>    unsigned long vm_start ;
>    unsigned long vm_end ;
>    struct vm_area_struct *vm_next ;
>    pgprot_t vm_page_prot ;
>    unsigned long vm_flags ;
>    struct rb_node vm_rb ;
>    union __anonunion_shared_145 shared ;
>    struct list_head anon_vma_node ;
>    struct anon_vma *anon_vma ;
>    struct vm_operations_struct  const  *vm_ops ;
>    unsigned long vm_pgoff ;
>    struct file *vm_file ;
>    void *vm_private_data ;
>    unsigned long vm_truncate_count ;
>    struct mempolicy *vm_policy ;
> };
> #line 191 "include/linux/mm_types.h"
> struct core_thread {
>    struct task_struct *task ;
>    struct core_thread *next ;
> };
> #line 196 "include/linux/mm_types.h"
> struct core_state {
>    atomic_t nr_threads ;
>    struct core_thread dumper ;
>    struct completion startup ;
> };
> #line 202
> struct linux_binfmt;
> #line 202
> struct mmu_notifier_mm;
> #line 202 "include/linux/mm_types.h"
> struct mm_struct {
>    struct vm_area_struct *mmap ;
>    struct rb_root mm_rb ;
>    struct vm_area_struct *mmap_cache ;
>    unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
>                                       unsigned long pgoff , unsigned long flags ) ;
>    void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
>    unsigned long mmap_base ;
>    unsigned long task_size ;
>    unsigned long cached_hole_size ;
>    unsigned long free_area_cache ;
>    pgd_t *pgd ;
>    atomic_t mm_users ;
>    atomic_t mm_count ;
>    int map_count ;
>    struct rw_semaphore mmap_sem ;
>    spinlock_t page_table_lock ;
>    struct list_head mmlist ;
>    mm_counter_t _file_rss ;
>    mm_counter_t _anon_rss ;
>    unsigned long hiwater_rss ;
>    unsigned long hiwater_vm ;
>    unsigned long total_vm ;
>    unsigned long locked_vm ;
>    unsigned long shared_vm ;
>    unsigned long exec_vm ;
>    unsigned long stack_vm ;
>    unsigned long reserved_vm ;
>    unsigned long def_flags ;
>    unsigned long nr_ptes ;
>    unsigned long start_code ;
>    unsigned long end_code ;
>    unsigned long start_data ;
>    unsigned long end_data ;
>    unsigned long start_brk ;
>    unsigned long brk ;
>    unsigned long start_stack ;
>    unsigned long arg_start ;
>    unsigned long arg_end ;
>    unsigned long env_start ;
>    unsigned long env_end ;
>    unsigned long saved_auxv[2 * ((2 + 19) + 1)] ;
>    struct linux_binfmt *binfmt ;
>    cpumask_t cpu_vm_mask ;
>    mm_context_t context ;
>    unsigned int faultstamp ;
>    unsigned int token_priority ;
>    unsigned int last_interval ;
>    unsigned long flags ;
>    struct core_state *core_state ;
>    spinlock_t ioctx_lock ;
>    struct hlist_head ioctx_list ;
>    struct task_struct *owner ;
>    struct file *exe_file ;
>    unsigned long num_exe_file_vmas ;
>    struct mmu_notifier_mm *mmu_notifier_mm ;
> };
> #line 7 "include/asm-generic/cputime.h"
> typedef unsigned long cputime_t;
> #line 117 "include/linux/sem.h"
> struct sem_undo_list;
> #line 130 "include/linux/sem.h"
> struct sem_undo_list {
>    atomic_t refcnt ;
>    spinlock_t lock ;
>    struct list_head list_proc ;
> };
> #line 136 "include/linux/sem.h"
> struct sysv_sem {
>    struct sem_undo_list *undo_list ;
> };
> #line 10 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/signal.h"
> struct siginfo;
> #line 30 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/signal.h"
> struct __anonstruct_sigset_t_147 {
>    unsigned long sig[64 / 64] ;
> };
> #line 30 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/signal.h"
> typedef struct __anonstruct_sigset_t_147 sigset_t;
> #line 17 "include/asm-generic/signal-defs.h"
> typedef void __signalfn_t(int  );
> #line 18 "include/asm-generic/signal-defs.h"
> typedef __signalfn_t *__sighandler_t;
> #line 20 "include/asm-generic/signal-defs.h"
> typedef void __restorefn_t(void);
> #line 21 "include/asm-generic/signal-defs.h"
> typedef __restorefn_t *__sigrestore_t;
> #line 167 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/signal.h"
> struct sigaction {
>    __sighandler_t sa_handler ;
>    unsigned long sa_flags ;
>    __sigrestore_t sa_restorer ;
>    sigset_t sa_mask ;
> };
> #line 174 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/signal.h"
> struct k_sigaction {
>    struct sigaction sa ;
> };
> #line 7 "include/asm-generic/siginfo.h"
> union sigval {
>    int sival_int ;
>    void *sival_ptr ;
> };
> #line 7 "include/asm-generic/siginfo.h"
> typedef union sigval sigval_t;
> #line 40 "include/asm-generic/siginfo.h"
> struct __anonstruct__kill_149 {
>    __kernel_pid_t _pid ;
>    __kernel_uid32_t _uid ;
> };
> #line 40 "include/asm-generic/siginfo.h"
> struct __anonstruct__timer_150 {
>    __kernel_timer_t _tid ;
>    int _overrun ;
>    char _pad[sizeof(__kernel_uid32_t ) - sizeof(int )] ;
>    sigval_t _sigval ;
>    int _sys_private ;
> };
> #line 40 "include/asm-generic/siginfo.h"
> struct __anonstruct__rt_151 {
>    __kernel_pid_t _pid ;
>    __kernel_uid32_t _uid ;
>    sigval_t _sigval ;
> };
> #line 40 "include/asm-generic/siginfo.h"
> struct __anonstruct__sigchld_152 {
>    __kernel_pid_t _pid ;
>    __kernel_uid32_t _uid ;
>    int _status ;
>    __kernel_clock_t _utime ;
>    __kernel_clock_t _stime ;
> };
> #line 40 "include/asm-generic/siginfo.h"
> struct __anonstruct__sigfault_153 {
>    void *_addr ;
>    short _addr_lsb ;
> };
> #line 40 "include/asm-generic/siginfo.h"
> struct __anonstruct__sigpoll_154 {
>    long _band ;
>    int _fd ;
> };
> #line 40 "include/asm-generic/siginfo.h"
> union __anonunion__sifields_148 {
>    int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
>    struct __anonstruct__kill_149 _kill ;
>    struct __anonstruct__timer_150 _timer ;
>    struct __anonstruct__rt_151 _rt ;
>    struct __anonstruct__sigchld_152 _sigchld ;
>    struct __anonstruct__sigfault_153 _sigfault ;
>    struct __anonstruct__sigpoll_154 _sigpoll ;
> };
> #line 40 "include/asm-generic/siginfo.h"
> struct siginfo {
>    int si_signo ;
>    int si_errno ;
>    int si_code ;
>    union __anonunion__sifields_148 _sifields ;
> };
> #line 40 "include/asm-generic/siginfo.h"
> typedef struct siginfo siginfo_t;
> #line 14 "include/linux/signal.h"
> struct user_struct;
> #line 24 "include/linux/signal.h"
> struct sigpending {
>    struct list_head list ;
>    sigset_t signal ;
> };
> #line 97 "include/linux/proportions.h"
> struct prop_local_single {
>    unsigned long events ;
>    unsigned long period ;
>    int shift ;
>    spinlock_t lock ;
> };
> #line 10 "include/linux/seccomp.h"
> struct __anonstruct_seccomp_t_157 {
>    int mode ;
> };
> #line 10 "include/linux/seccomp.h"
> typedef struct __anonstruct_seccomp_t_157 seccomp_t;
> #line 80 "include/linux/plist.h"
> struct plist_head {
>    struct list_head prio_list ;
>    struct list_head node_list ;
>    spinlock_t *lock ;
> };
> #line 88 "include/linux/plist.h"
> struct plist_node {
>    int prio ;
>    struct plist_head plist ;
> };
> #line 38 "include/linux/rtmutex.h"
> struct rt_mutex_waiter;
> #line 43 "include/linux/resource.h"
> struct rlimit {
>    unsigned long rlim_cur ;
>    unsigned long rlim_max ;
> };
> #line 11 "include/linux/task_io_accounting.h"
> struct task_io_accounting {
>    u64 rchar ;
>    u64 wchar ;
>    u64 syscr ;
>    u64 syscw ;
>    u64 read_bytes ;
>    u64 write_bytes ;
>    u64 cancelled_write_bytes ;
> };
> #line 18 "include/linux/latencytop.h"
> struct latency_record {
>    unsigned long backtrace[12] ;
>    unsigned int count ;
>    unsigned long time ;
>    unsigned long max ;
> };
> #line 947 "include/linux/sysctl.h"
> struct nsproxy;
> #line 29 "include/linux/key.h"
> typedef int32_t key_serial_t;
> #line 32 "include/linux/key.h"
> typedef uint32_t key_perm_t;
> #line 76
> struct signal_struct;
> #line 79
> struct key_type;
> #line 81
> struct keyring_list;
> #line 124
> struct key_user;
> #line 124 "include/linux/key.h"
> union __anonunion____missing_field_name_212 {
>    time_t expiry ;
>    time_t revoked_at ;
> };
> #line 124 "include/linux/key.h"
> union __anonunion_type_data_213 {
>    struct list_head link ;
>    unsigned long x[2] ;
>    void *p[2] ;
> };
> #line 124 "include/linux/key.h"
> union __anonunion_payload_214 {
>    unsigned long value ;
>    void *data ;
>    struct keyring_list *subscriptions ;
> };
> #line 124 "include/linux/key.h"
> struct key {
>    atomic_t usage ;
>    key_serial_t serial ;
>    struct rb_node serial_node ;
>    struct key_type *type ;
>    struct rw_semaphore sem ;
>    struct key_user *user ;
>    void *security ;
>    union __anonunion____missing_field_name_212 __annonCompField25 ;
>    uid_t uid ;
>    gid_t gid ;
>    key_perm_t perm ;
>    unsigned short quotalen ;
>    unsigned short datalen ;
>    unsigned long flags ;
>    char *description ;
>    union __anonunion_type_data_213 type_data ;
>    union __anonunion_payload_214 payload ;
> };
> #line 18 "include/linux/selinux.h"
> struct audit_context;
> #line 31 "include/linux/cred.h"
> struct group_info {
>    atomic_t usage ;
>    int ngroups ;
>    int nblocks ;
>    gid_t small_block[32] ;
>    gid_t *blocks[0] ;
> };
> #line 83 "include/linux/cred.h"
> struct thread_group_cred {
>    atomic_t usage ;
>    pid_t tgid ;
>    spinlock_t lock ;
>    struct key *session_keyring ;
>    struct key *process_keyring ;
>    struct rcu_head rcu ;
> };
> #line 116 "include/linux/cred.h"
> struct cred {
>    atomic_t usage ;
>    atomic_t subscribers ;
>    void *put_addr ;
>    unsigned int magic ;
>    uid_t uid ;
>    gid_t gid ;
>    uid_t suid ;
>    gid_t sgid ;
>    uid_t euid ;
>    gid_t egid ;
>    uid_t fsuid ;
>    gid_t fsgid ;
>    unsigned int securebits ;
>    kernel_cap_t cap_inheritable ;
>    kernel_cap_t cap_permitted ;
>    kernel_cap_t cap_effective ;
>    kernel_cap_t cap_bset ;
>    unsigned char jit_keyring ;
>    struct key *thread_keyring ;
>    struct key *request_key_auth ;
>    struct thread_group_cred *tgcred ;
>    void *security ;
>    struct user_struct *user ;
>    struct group_info *group_info ;
>    struct rcu_head rcu ;
> };
> #line 98 "include/linux/sched.h"
> struct futex_pi_state;
> #line 99
> struct robust_list_head;
> #line 101
> struct fs_struct;
> #line 102
> struct bts_context;
> #line 103
> struct perf_event_context;
> #line 153
> struct cfs_rq;
> #line 154
> struct task_group;
> #line 357
> struct user_namespace;
> #line 58 "include/linux/aio_abi.h"
> struct io_event {
>    __u64 data ;
>    __u64 obj ;
>    __s64 res ;
>    __s64 res2 ;
> };
> #line 16 "include/linux/uio.h"
> struct iovec {
>    void *iov_base ;
>    __kernel_size_t iov_len ;
> };
> #line 15 "include/linux/aio.h"
> struct kioctx;
> #line 87 "include/linux/aio.h"
> union __anonunion_ki_obj_216 {
>    void *user ;
>    struct task_struct *tsk ;
> };
> #line 87
> struct eventfd_ctx;
> #line 87 "include/linux/aio.h"
> struct kiocb {
>    struct list_head ki_run_list ;
>    unsigned long ki_flags ;
>    int ki_users ;
>    unsigned int ki_key ;
>    struct file *ki_filp ;
>    struct kioctx *ki_ctx ;
>    int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
>    ssize_t (*ki_retry)(struct kiocb * ) ;
>    void (*ki_dtor)(struct kiocb * ) ;
>    union __anonunion_ki_obj_216 ki_obj ;
>    __u64 ki_user_data ;
>    wait_queue_t ki_wait ;
>    loff_t ki_pos ;
>    void *private ;
>    unsigned short ki_opcode ;
>    size_t ki_nbytes ;
>    char *ki_buf ;
>    size_t ki_left ;
>    struct iovec ki_inline_vec ;
>    struct iovec *ki_iovec ;
>    unsigned long ki_nr_segs ;
>    unsigned long ki_cur_seg ;
>    struct list_head ki_list ;
>    struct eventfd_ctx *ki_eventfd ;
> };
> #line 167 "include/linux/aio.h"
> struct aio_ring_info {
>    unsigned long mmap_base ;
>    unsigned long mmap_size ;
>    struct page **ring_pages ;
>    spinlock_t ring_lock ;
>    long nr_pages ;
>    unsigned int nr ;
>    unsigned int tail ;
>    struct page *internal_pages[8] ;
> };
> #line 180 "include/linux/aio.h"
> struct kioctx {
>    atomic_t users ;
>    int dead ;
>    struct mm_struct *mm ;
>    unsigned long user_id ;
>    struct hlist_node list ;
>    wait_queue_head_t wait ;
>    spinlock_t ctx_lock ;
>    int reqs_active ;
>    struct list_head active_reqs ;
>    struct list_head run_list ;
>    unsigned int max_reqs ;
>    struct aio_ring_info ring_info ;
>    struct delayed_work wq ;
>    struct rcu_head rcu_head ;
> };
> #line 481 "include/linux/sched.h"
> struct sighand_struct {
>    atomic_t count ;
>    struct k_sigaction action[64] ;
>    spinlock_t siglock ;
>    wait_queue_head_t signalfd_wqh ;
> };
> #line 488 "include/linux/sched.h"
> struct pacct_struct {
>    int ac_flag ;
>    long ac_exitcode ;
>    unsigned long ac_mem ;
>    cputime_t ac_utime ;
>    cputime_t ac_stime ;
>    unsigned long ac_minflt ;
>    unsigned long ac_majflt ;
> };
> #line 496 "include/linux/sched.h"
> struct cpu_itimer {
>    cputime_t expires ;
>    cputime_t incr ;
>    u32 error ;
>    u32 incr_error ;
> };
> #line 514 "include/linux/sched.h"
> struct task_cputime {
>    cputime_t utime ;
>    cputime_t stime ;
>    unsigned long long sum_exec_runtime ;
> };
> #line 550 "include/linux/sched.h"
> struct thread_group_cputimer {
>    struct task_cputime cputime ;
>    int running ;
>    spinlock_t lock ;
> };
> #line 563
> struct tty_struct;
> #line 563
> struct taskstats;
> #line 563
> struct tty_audit_buf;
> #line 563 "include/linux/sched.h"
> struct signal_struct {
>    atomic_t count ;
>    atomic_t live ;
>    wait_queue_head_t wait_chldexit ;
>    struct task_struct *curr_target ;
>    struct sigpending shared_pending ;
>    int group_exit_code ;
>    int notify_count ;
>    struct task_struct *group_exit_task ;
>    int group_stop_count ;
>    unsigned int flags ;
>    struct list_head posix_timers ;
>    struct hrtimer real_timer ;
>    struct pid *leader_pid ;
>    ktime_t it_real_incr ;
>    struct cpu_itimer it[2] ;
>    struct thread_group_cputimer cputimer ;
>    struct task_cputime cputime_expires ;
>    struct list_head cpu_timers[3] ;
>    struct pid *tty_old_pgrp ;
>    int leader ;
>    struct tty_struct *tty ;
>    cputime_t utime ;
>    cputime_t stime ;
>    cputime_t cutime ;
>    cputime_t cstime ;
>    cputime_t gtime ;
>    cputime_t cgtime ;
>    unsigned long nvcsw ;
>    unsigned long nivcsw ;
>    unsigned long cnvcsw ;
>    unsigned long cnivcsw ;
>    unsigned long min_flt ;
>    unsigned long maj_flt ;
>    unsigned long cmin_flt ;
>    unsigned long cmaj_flt ;
>    unsigned long inblock ;
>    unsigned long oublock ;
>    unsigned long cinblock ;
>    unsigned long coublock ;
>    unsigned long maxrss ;
>    unsigned long cmaxrss ;
>    struct task_io_accounting ioac ;
>    unsigned long long sum_sched_runtime ;
>    struct rlimit rlim[16] ;
>    struct pacct_struct pacct ;
>    struct taskstats *stats ;
>    unsigned int audit_tty ;
>    struct tty_audit_buf *tty_audit_buf ;
>    int oom_adj ;
> };
> #line 701 "include/linux/sched.h"
> struct user_struct {
>    atomic_t __count ;
>    atomic_t processes ;
>    atomic_t files ;
>    atomic_t sigpending ;
>    atomic_t inotify_watches ;
>    atomic_t inotify_devs ;
>    atomic_t epoll_watches ;
>    unsigned long mq_bytes ;
>    unsigned long locked_shm ;
>    struct key *uid_keyring ;
>    struct key *session_keyring ;
>    struct hlist_node uidhash_node ;
>    uid_t uid ;
>    struct user_namespace *user_ns ;
>    struct task_group *tg ;
>    struct kobject kobj ;
>    struct delayed_work work ;
>    atomic_long_t locked_vm ;
> };
> #line 751
> struct reclaim_state;
> #line 754 "include/linux/sched.h"
> struct sched_info {
>    unsigned long pcount ;
>    unsigned long long run_delay ;
>    unsigned long long last_arrival ;
>    unsigned long long last_queued ;
>    unsigned int bkl_count ;
> };
> #line 770 "include/linux/sched.h"
> struct task_delay_info {
>    spinlock_t lock ;
>    unsigned int flags ;
>    struct timespec blkio_start ;
>    struct timespec blkio_end ;
>    u64 blkio_delay ;
>    u64 swapin_delay ;
>    u32 blkio_count ;
>    u32 swapin_count ;
>    struct timespec freepages_start ;
>    struct timespec freepages_end ;
>    u64 freepages_delay ;
>    u32 freepages_count ;
> };
> #line 815
> enum cpu_idle_type {
>     CPU_IDLE = 0,
>     CPU_NOT_IDLE = 1,
>     CPU_NEWLY_IDLE = 2,
>     CPU_MAX_IDLE_TYPES = 3
> } ;
> #line 892 "include/linux/sched.h"
> struct sched_group {
>    struct sched_group *next ;
>    unsigned int cpu_power ;
>    unsigned long cpumask[0] ;
> };
> #line 919
> enum sched_domain_level {
>     SD_LV_NONE = 0,
>     SD_LV_SIBLING = 1,
>     SD_LV_MC = 2,
>     SD_LV_CPU = 3,
>     SD_LV_NODE = 4,
>     SD_LV_ALLNODES = 5,
>     SD_LV_MAX = 6
> } ;
> #line 937 "include/linux/sched.h"
> struct sched_domain {
>    struct sched_domain *parent ;
>    struct sched_domain *child ;
>    struct sched_group *groups ;
>    unsigned long min_interval ;
>    unsigned long max_interval ;
>    unsigned int busy_factor ;
>    unsigned int imbalance_pct ;
>    unsigned int cache_nice_tries ;
>    unsigned int busy_idx ;
>    unsigned int idle_idx ;
>    unsigned int newidle_idx ;
>    unsigned int wake_idx ;
>    unsigned int forkexec_idx ;
>    unsigned int smt_gain ;
>    int flags ;
>    enum sched_domain_level level ;
>    unsigned long last_balance ;
>    unsigned int balance_interval ;
>    unsigned int nr_balance_failed ;
>    u64 last_update ;
>    unsigned int lb_count[CPU_MAX_IDLE_TYPES] ;
>    unsigned int lb_failed[CPU_MAX_IDLE_TYPES] ;
>    unsigned int lb_balanced[CPU_MAX_IDLE_TYPES] ;
>    unsigned int lb_imbalance[CPU_MAX_IDLE_TYPES] ;
>    unsigned int lb_gained[CPU_MAX_IDLE_TYPES] ;
>    unsigned int lb_hot_gained[CPU_MAX_IDLE_TYPES] ;
>    unsigned int lb_nobusyg[CPU_MAX_IDLE_TYPES] ;
>    unsigned int lb_nobusyq[CPU_MAX_IDLE_TYPES] ;
>    unsigned int alb_count ;
>    unsigned int alb_failed ;
>    unsigned int alb_pushed ;
>    unsigned int sbe_count ;
>    unsigned int sbe_balanced ;
>    unsigned int sbe_pushed ;
>    unsigned int sbf_count ;
>    unsigned int sbf_balanced ;
>    unsigned int sbf_pushed ;
>    unsigned int ttwu_wake_remote ;
>    unsigned int ttwu_move_affine ;
>    unsigned int ttwu_move_balance ;
>    char *name ;
>    unsigned long span[0] ;
> };
> #line 1043
> struct io_context;
> #line 1057
> struct rq;
> #line 1066 "include/linux/sched.h"
> struct sched_class {
>    struct sched_class  const  *next ;
>    void (*enqueue_task)(struct rq *rq , struct task_struct *p , int wakeup ) ;
>    void (*dequeue_task)(struct rq *rq , struct task_struct *p , int sleep ) ;
>    void (*yield_task)(struct rq *rq ) ;
>    void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int flags ) ;
>    struct task_struct *(*pick_next_task)(struct rq *rq ) ;
>    void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
>    int (*select_task_rq)(struct task_struct *p , int sd_flag , int flags ) ;
>    unsigned long (*load_balance)(struct rq *this_rq , int this_cpu , struct rq *busiest ,
>                                  unsigned long max_load_move , struct sched_domain *sd ,
>                                  enum cpu_idle_type idle , int *all_pinned , int *this_best_prio ) ;
>    int (*move_one_task)(struct rq *this_rq , int this_cpu , struct rq *busiest , struct sched_domain *sd ,
>                         enum cpu_idle_type idle ) ;
>    void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
>    void (*post_schedule)(struct rq *this_rq ) ;
>    void (*task_wake_up)(struct rq *this_rq , struct task_struct *task ) ;
>    void (*set_cpus_allowed)(struct task_struct *p , struct cpumask  const  *newmask ) ;
>    void (*rq_online)(struct rq *rq ) ;
>    void (*rq_offline)(struct rq *rq ) ;
>    void (*set_curr_task)(struct rq *rq ) ;
>    void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
>    void (*task_new)(struct rq *rq , struct task_struct *p ) ;
>    void (*switched_from)(struct rq *this_rq , struct task_struct *task , int running ) ;
>    void (*switched_to)(struct rq *this_rq , struct task_struct *task , int running ) ;
>    void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ,
>                         int running ) ;
>    unsigned int (*get_rr_interval)(struct task_struct *task ) ;
>    void (*moved_group)(struct task_struct *p ) ;
> };
> #line 1118 "include/linux/sched.h"
> struct load_weight {
>    unsigned long weight ;
>    unsigned long inv_weight ;
> };
> #line 1132 "include/linux/sched.h"
> struct sched_entity {
>    struct load_weight load ;
>    struct rb_node run_node ;
>    struct list_head group_node ;
>    unsigned int on_rq ;
>    u64 exec_start ;
>    u64 sum_exec_runtime ;
>    u64 vruntime ;
>    u64 prev_sum_exec_runtime ;
>    u64 last_wakeup ;
>    u64 avg_overlap ;
>    u64 nr_migrations ;
>    u64 start_runtime ;
>    u64 avg_wakeup ;
>    u64 avg_running ;
>    u64 wait_start ;
>    u64 wait_max ;
>    u64 wait_count ;
>    u64 wait_sum ;
>    u64 iowait_count ;
>    u64 iowait_sum ;
>    u64 sleep_start ;
>    u64 sleep_max ;
>    s64 sum_sleep_runtime ;
>    u64 block_start ;
>    u64 block_max ;
>    u64 exec_max ;
>    u64 slice_max ;
>    u64 nr_migrations_cold ;
>    u64 nr_failed_migrations_affine ;
>    u64 nr_failed_migrations_running ;
>    u64 nr_failed_migrations_hot ;
>    u64 nr_forced_migrations ;
>    u64 nr_forced2_migrations ;
>    u64 nr_wakeups ;
>    u64 nr_wakeups_sync ;
>    u64 nr_wakeups_migrate ;
>    u64 nr_wakeups_local ;
>    u64 nr_wakeups_remote ;
>    u64 nr_wakeups_affine ;
>    u64 nr_wakeups_affine_attempts ;
>    u64 nr_wakeups_passive ;
>    u64 nr_wakeups_idle ;
>    struct sched_entity *parent ;
>    struct cfs_rq *cfs_rq ;
>    struct cfs_rq *my_q ;
> };
> #line 1197
> struct rt_rq;
> #line 1197 "include/linux/sched.h"
> struct sched_rt_entity {
>    struct list_head run_list ;
>    unsigned long timeout ;
>    unsigned int time_slice ;
>    int nr_cpus_allowed ;
>    struct sched_rt_entity *back ;
>    struct sched_rt_entity *parent ;
>    struct rt_rq *rt_rq ;
>    struct rt_rq *my_q ;
> };
> #line 1215
> struct css_set;
> #line 1215
> struct compat_robust_list_head;
> #line 1215
> struct ftrace_ret_stack;
> #line 1215 "include/linux/sched.h"
> struct task_struct {
>    long volatile   state ;
>    void *stack ;
>    atomic_t usage ;
>    unsigned int flags ;
>    unsigned int ptrace ;
>    int lock_depth ;
>    int prio ;
>    int static_prio ;
>    int normal_prio ;
>    unsigned int rt_priority ;
>    struct sched_class  const  *sched_class ;
>    struct sched_entity se ;
>    struct sched_rt_entity rt ;
>    struct hlist_head preempt_notifiers ;
>    unsigned char fpu_counter ;
>    unsigned int btrace_seq ;
>    unsigned int policy ;
>    cpumask_t cpus_allowed ;
>    struct sched_info sched_info ;
>    struct list_head tasks ;
>    struct plist_node pushable_tasks ;
>    struct mm_struct *mm ;
>    struct mm_struct *active_mm ;
>    int exit_state ;
>    int exit_code ;
>    int exit_signal ;
>    int pdeath_signal ;
>    unsigned int personality ;
>    unsigned int did_exec : 1 ;
>    unsigned int in_execve : 1 ;
>    unsigned int in_iowait : 1 ;
>    unsigned int sched_reset_on_fork : 1 ;
>    pid_t pid ;
>    pid_t tgid ;
>    unsigned long stack_canary ;
>    struct task_struct *real_parent ;
>    struct task_struct *parent ;
>    struct list_head children ;
>    struct list_head sibling ;
>    struct task_struct *group_leader ;
>    struct list_head ptraced ;
>    struct list_head ptrace_entry ;
>    struct bts_context *bts ;
>    struct pid_link pids[PIDTYPE_MAX] ;
>    struct list_head thread_group ;
>    struct completion *vfork_done ;
>    int *set_child_tid ;
>    int *clear_child_tid ;
>    cputime_t utime ;
>    cputime_t stime ;
>    cputime_t utimescaled ;
>    cputime_t stimescaled ;
>    cputime_t gtime ;
>    cputime_t prev_utime ;
>    cputime_t prev_stime ;
>    unsigned long nvcsw ;
>    unsigned long nivcsw ;
>    struct timespec start_time ;
>    struct timespec real_start_time ;
>    unsigned long min_flt ;
>    unsigned long maj_flt ;
>    struct task_cputime cputime_expires ;
>    struct list_head cpu_timers[3] ;
>    struct cred  const  *real_cred ;
>    struct cred  const  *cred ;
>    struct mutex cred_guard_mutex ;
>    struct cred *replacement_session_keyring ;
>    char comm[16] ;
>    int link_count ;
>    int total_link_count ;
>    struct sysv_sem sysvsem ;
>    unsigned long last_switch_count ;
>    struct thread_struct thread ;
>    struct fs_struct *fs ;
>    struct files_struct *files ;
>    struct nsproxy *nsproxy ;
>    struct signal_struct *signal ;
>    struct sighand_struct *sighand ;
>    sigset_t blocked ;
>    sigset_t real_blocked ;
>    sigset_t saved_sigmask ;
>    struct sigpending pending ;
>    unsigned long sas_ss_sp ;
>    size_t sas_ss_size ;
>    int (*notifier)(void *priv ) ;
>    void *notifier_data ;
>    sigset_t *notifier_mask ;
>    struct audit_context *audit_context ;
>    uid_t loginuid ;
>    unsigned int sessionid ;
>    seccomp_t seccomp ;
>    u32 parent_exec_id ;
>    u32 self_exec_id ;
>    spinlock_t alloc_lock ;
>    struct irqaction *irqaction ;
>    spinlock_t pi_lock ;
>    struct plist_head pi_waiters ;
>    struct rt_mutex_waiter *pi_blocked_on ;
>    struct mutex_waiter *blocked_on ;
>    unsigned int irq_events ;
>    int hardirqs_enabled ;
>    unsigned long hardirq_enable_ip ;
>    unsigned int hardirq_enable_event ;
>    unsigned long hardirq_disable_ip ;
>    unsigned int hardirq_disable_event ;
>    int softirqs_enabled ;
>    unsigned long softirq_disable_ip ;
>    unsigned int softirq_disable_event ;
>    unsigned long softirq_enable_ip ;
>    unsigned int softirq_enable_event ;
>    int hardirq_context ;
>    int softirq_context ;
>    u64 curr_chain_key ;
>    int lockdep_depth ;
>    unsigned int lockdep_recursion ;
>    struct held_lock held_locks[48UL] ;
>    gfp_t lockdep_reclaim_gfp ;
>    void *journal_info ;
>    struct bio *bio_list ;
>    struct bio **bio_tail ;
>    struct reclaim_state *reclaim_state ;
>    struct backing_dev_info *backing_dev_info ;
>    struct io_context *io_context ;
>    unsigned long ptrace_message ;
>    siginfo_t *last_siginfo ;
>    struct task_io_accounting ioac ;
>    u64 acct_rss_mem1 ;
>    u64 acct_vm_mem1 ;
>    cputime_t acct_timexpd ;
>    nodemask_t mems_allowed ;
>    int cpuset_mem_spread_rotor ;
>    struct css_set *cgroups ;
>    struct list_head cg_list ;
>    struct robust_list_head *robust_list ;
>    struct compat_robust_list_head *compat_robust_list ;
>    struct list_head pi_state_list ;
>    struct futex_pi_state *pi_state_cache ;
>    struct perf_event_context *perf_event_ctxp ;
>    struct mutex perf_event_mutex ;
>    struct list_head perf_event_list ;
>    struct mempolicy *mempolicy ;
>    short il_next ;
>    atomic_t fs_excl ;
>    struct rcu_head rcu ;
>    struct pipe_inode_info *splice_pipe ;
>    struct task_delay_info *delays ;
>    int make_it_fail ;
>    struct prop_local_single dirties ;
>    int latency_record_count ;
>    struct latency_record latency_record[32] ;
>    unsigned long timer_slack_ns ;
>    unsigned long default_timer_slack_ns ;
>    struct list_head *scm_work_list ;
>    int curr_ret_stack ;
>    struct ftrace_ret_stack *ret_stack ;
>    unsigned long long ftrace_timestamp ;
>    atomic_t trace_overrun ;
>    atomic_t tracing_graph_pause ;
>    unsigned long trace ;
>    unsigned long trace_recursion ;
>    unsigned long stack_start ;
> };
> #line 24 "include/linux/usb.h"
> struct usb_device;
> #line 26
> struct wusb_dev;
> #line 46
> struct ep_device;
> #line 55 "include/linux/usb.h"
> struct usb_host_ss_ep_comp {
>    struct usb_ss_ep_comp_descriptor desc ;
>    unsigned char *extra ;
>    int extralen ;
> };
> #line 76 "include/linux/usb.h"
> struct usb_host_endpoint {
>    struct usb_endpoint_descriptor desc ;
>    struct list_head urb_list ;
>    void *hcpriv ;
>    struct ep_device *ep_dev ;
>    struct usb_host_ss_ep_comp *ss_ep_comp ;
>    unsigned char *extra ;
>    int extralen ;
>    int enabled ;
> };
> #line 89 "include/linux/usb.h"
> struct usb_host_interface {
>    struct usb_interface_descriptor desc ;
>    struct usb_host_endpoint *endpoint ;
>    char *string ;
>    unsigned char *extra ;
>    int extralen ;
1919,1922c3420,3425
< #line 14 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/43_1a/common-model/ldv_common_model.c"
< enum __anonenum_121 {
<     LDV_SPIN_UNLOCKED = 0,
<     LDV_SPIN_LOCKED = 1
---
> #line 102
> enum usb_interface_condition {
>     USB_INTERFACE_UNBOUND = 0,
>     USB_INTERFACE_BINDING = 1,
>     USB_INTERFACE_BOUND = 2,
>     USB_INTERFACE_UNBINDING = 3
1923a3427,3616
> #line 171 "include/linux/usb.h"
> struct usb_interface {
>    struct usb_host_interface *altsetting ;
>    struct usb_host_interface *cur_altsetting ;
>    unsigned int num_altsetting ;
>    struct usb_interface_assoc_descriptor *intf_assoc ;
>    int minor ;
>    enum usb_interface_condition condition ;
>    unsigned int is_active : 1 ;
>    unsigned int sysfs_files_created : 1 ;
>    unsigned int ep_devs_created : 1 ;
>    unsigned int unregistering : 1 ;
>    unsigned int needs_remote_wakeup : 1 ;
>    unsigned int needs_altsetting0 : 1 ;
>    unsigned int needs_binding : 1 ;
>    unsigned int reset_running : 1 ;
>    struct device dev ;
>    struct device *usb_dev ;
>    atomic_t pm_usage_cnt ;
>    struct work_struct reset_ws ;
> };
> #line 236 "include/linux/usb.h"
> struct usb_interface_cache {
>    unsigned int num_altsetting ;
>    struct kref ref ;
>    struct usb_host_interface altsetting[0] ;
> };
> #line 288 "include/linux/usb.h"
> struct usb_host_config {
>    struct usb_config_descriptor desc ;
>    char *string ;
>    struct usb_interface_assoc_descriptor *intf_assoc[32 / 2] ;
>    struct usb_interface *interface[32] ;
>    struct usb_interface_cache *intf_cache[32] ;
>    unsigned char *extra ;
>    int extralen ;
> };
> #line 319 "include/linux/usb.h"
> struct usb_devmap {
>    unsigned long devicemap[128UL / (8UL * sizeof(unsigned long ))] ;
> };
> #line 326
> struct mon_bus;
> #line 326 "include/linux/usb.h"
> struct usb_bus {
>    struct device *controller ;
>    int busnum ;
>    char const   *bus_name ;
>    u8 uses_dma ;
>    u8 otg_port ;
>    unsigned int is_b_host : 1 ;
>    unsigned int b_hnp_enable : 1 ;
>    int devnum_next ;
>    struct usb_devmap devmap ;
>    struct usb_device *root_hub ;
>    struct list_head bus_list ;
>    int bandwidth_allocated ;
>    int bandwidth_int_reqs ;
>    int bandwidth_isoc_reqs ;
>    struct dentry *usbfs_dentry ;
>    struct mon_bus *mon_bus ;
>    int monitored ;
> };
> #line 375
> struct usb_tt;
> #line 445 "include/linux/usb.h"
> struct usb_device {
>    int devnum ;
>    char devpath[16] ;
>    u32 route ;
>    enum usb_device_state state ;
>    enum usb_device_speed speed ;
>    struct usb_tt *tt ;
>    int ttport ;
>    unsigned int toggle[2] ;
>    struct usb_device *parent ;
>    struct usb_bus *bus ;
>    struct usb_host_endpoint ep0 ;
>    struct device dev ;
>    struct usb_device_descriptor descriptor ;
>    struct usb_host_config *config ;
>    struct usb_host_config *actconfig ;
>    struct usb_host_endpoint *ep_in[16] ;
>    struct usb_host_endpoint *ep_out[16] ;
>    char **rawdescriptors ;
>    unsigned short bus_mA ;
>    u8 portnum ;
>    u8 level ;
>    unsigned int can_submit : 1 ;
>    unsigned int discon_suspended : 1 ;
>    unsigned int persist_enabled : 1 ;
>    unsigned int have_langid : 1 ;
>    unsigned int authorized : 1 ;
>    unsigned int authenticated : 1 ;
>    unsigned int wusb : 1 ;
>    int string_langid ;
>    char *product ;
>    char *manufacturer ;
>    char *serial ;
>    struct list_head filelist ;
>    struct device *usb_classdev ;
>    struct dentry *usbfs_dentry ;
>    int maxchild ;
>    struct usb_device *children[31] ;
>    int pm_usage_cnt ;
>    u32 quirks ;
>    atomic_t urbnum ;
>    unsigned long active_duration ;
>    struct delayed_work autosuspend ;
>    struct work_struct autoresume ;
>    struct mutex pm_mutex ;
>    unsigned long last_busy ;
>    int autosuspend_delay ;
>    unsigned long connect_time ;
>    unsigned int auto_pm : 1 ;
>    unsigned int do_remote_wakeup : 1 ;
>    unsigned int reset_resume : 1 ;
>    unsigned int autosuspend_disabled : 1 ;
>    unsigned int autoresume_disabled : 1 ;
>    unsigned int skip_sys_resume : 1 ;
>    struct wusb_dev *wusb_dev ;
>    int slot_id ;
> };
> #line 990 "include/linux/usb.h"
> struct usb_iso_packet_descriptor {
>    unsigned int offset ;
>    unsigned int length ;
>    unsigned int actual_length ;
>    int status ;
> };
> #line 997
> struct urb;
> #line 999 "include/linux/usb.h"
> struct usb_anchor {
>    struct list_head urb_list ;
>    wait_queue_head_t wait ;
>    spinlock_t lock ;
>    unsigned int poisoned : 1 ;
> };
> #line 1193
> struct usb_sg_request;
> #line 1193 "include/linux/usb.h"
> struct urb {
>    struct kref kref ;
>    void *hcpriv ;
>    atomic_t use_count ;
>    atomic_t reject ;
>    int unlinked ;
>    struct list_head urb_list ;
>    struct list_head anchor_list ;
>    struct usb_anchor *anchor ;
>    struct usb_device *dev ;
>    struct usb_host_endpoint *ep ;
>    unsigned int pipe ;
>    int status ;
>    unsigned int transfer_flags ;
>    void *transfer_buffer ;
>    dma_addr_t transfer_dma ;
>    struct usb_sg_request *sg ;
>    int num_sgs ;
>    u32 transfer_buffer_length ;
>    u32 actual_length ;
>    unsigned char *setup_packet ;
>    dma_addr_t setup_dma ;
>    int start_frame ;
>    int number_of_packets ;
>    int interval ;
>    int error_count ;
>    void *context ;
>    void (*complete)(struct urb * ) ;
>    struct usb_iso_packet_descriptor iso_frame_desc[0] ;
> };
> #line 1390
> struct scatterlist;
> #line 1456 "include/linux/usb.h"
> struct usb_sg_request {
>    int status ;
>    size_t bytes ;
>    spinlock_t lock ;
>    struct usb_device *dev ;
>    int pipe ;
>    struct scatterlist *sg ;
>    int nents ;
>    int entries ;
>    struct urb **urbs ;
>    int count ;
>    struct completion complete ;
> };
> #line 1 "<compiler builtins>"
> long __builtin_expect(long exp , long c ) ;
1935a3629,3630
> #line 21 "include/linux/log2.h"
> extern  __attribute__((__noreturn__)) int ____ilog2_NaN(void)  __attribute__((__const__)) ;
1937c3632,3633
< extern int snprintf(char * , size_t  , char const   *  , ...) ;
---
> extern int ( /* format attribute */  snprintf)(char *buf , size_t size , char const   *fmt 
>                                                , ...) ;
1939c3635,3639
< extern int printk(char const   *  , ...) ;
---
> extern int ( /* format attribute */  printk)(char const   *fmt  , ...) ;
> #line 11 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/delay.h"
> extern void __bad_udelay(void) ;
> #line 16
> extern void __const_udelay(unsigned long xloops ) ;
1941c3641
< extern void *memmove(void * , void const   * , size_t  ) ;
---
> extern void *memmove(void *dest , void const   *src , size_t count ) ;
1946,1951c3646,3694
< #line 16 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/delay.h"
< extern void __const_udelay(unsigned long  ) ;
< #line 318 "include/linux/gfp.h"
< extern unsigned long __get_free_pages(gfp_t  , unsigned int  ) ;
< #line 321
< unsigned long ldv___get_free_pages_2(gfp_t ldv_func_arg1 , unsigned int ldv_func_arg2 ) ;
---
> #line 9 "include/asm-generic/getorder.h"
> __inline static int get_order(unsigned long size )  __attribute__((__const__)) ;
> #line 9 "include/asm-generic/getorder.h"
> __inline static int get_order(unsigned long size ) 
> { 
>   int order ;
> 
>   {
> #line 13
>   size = (size - 1UL) >> (12 - 1);
> #line 14
>   order = -1;
> #line 15
>   while (1) {
> #line 16
>     size = size >> 1;
> #line 17
>     order = order + 1;
> #line 15
>     if (size) {
> 
>     } else {
> #line 15
>       break;
>     }
>   }
> #line 19
>   return (order);
> }
> }
> #line 314 "include/linux/gfp.h"
> extern unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
> #line 201 "include/linux/rcupdate.h"
> __inline static void rcu_read_lock_sched_notrace(void)  __attribute__((__no_instrument_function__)) ;
> #line 201 "include/linux/rcupdate.h"
> __inline static void rcu_read_lock_sched_notrace(void) 
> { 
> 
> 
>   {
> #line 203
>   while (1) {
> #line 203
>     break;
>   }
> #line 205
>   return;
> }
> }
1954,1960c3697,4647
< #line 217 "include/linux/slub_def.h"
< extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
< #line 220
< void *ldv_kmem_cache_alloc_7(struct kmem_cache *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
< #line 317 "include/linux/slab.h"
< __inline static void *kzalloc(size_t size , gfp_t flags ) ;
< #line 88 "include/linux/module.h"
---
> #line 47 "include/trace/events/kmem.h"
> extern struct tracepoint __tracepoint_kmalloc ;
> #line 47 "include/trace/events/kmem.h"
> __inline static void trace_kmalloc(unsigned long call_site , void const   *ptr , size_t bytes_req ,
>                                    size_t bytes_alloc , gfp_t gfp_flags ) 
> { 
>   void **it_func ;
>   void **_________p1 ;
>   long tmp ;
> 
>   {
> #line 47
>   tmp = __builtin_expect(! (! __tracepoint_kmalloc.state), 0);
> #line 47
>   if (tmp) {
> #line 47
>     while (1) {
> #line 47
>       rcu_read_lock_sched_notrace();
> #line 47
>       _________p1 = *((void ** volatile  *)(& __tracepoint_kmalloc.funcs));
> #line 47
>       while (1) {
> #line 47
>         break;
>       }
> #line 47
>       it_func = _________p1;
> #line 47
>       if (it_func) {
> #line 47
>         while (1) {
> #line 47
>           (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
>                        size_t bytes_alloc , gfp_t gfp_flags ))*it_func))(call_site,
>                                                                          ptr, bytes_req,
>                                                                          bytes_alloc,
>                                                                          gfp_flags);
> #line 47
>           it_func = it_func + 1;
> #line 47
>           if (*it_func) {
> 
>           } else {
> #line 47
>             break;
>           }
>         }
>       } else {
> 
>       }
> #line 47
>       rcu_read_lock_sched_notrace();
> #line 47
>       break;
>     }
>   } else {
> 
>   }
> #line 47
>   return;
> }
> }
> #line 27 "include/linux/kmemleak.h"
> extern void ( __attribute__((__noinline__)) kmemleak_alloc)(void const   *ptr , size_t size ,
>                                                             int min_count , gfp_t gfp )  __attribute__((__section__(".ref.text"))) ;
> #line 142 "include/linux/slub_def.h"
> extern struct kmem_cache kmalloc_caches[12 + 2] ;
> #line 148 "include/linux/slub_def.h"
> __inline static int ( __attribute__((__always_inline__)) kmalloc_index)(size_t size ) 
> { 
>   int tmp ;
>   int tmp___0 ;
>   int tmp___1 ;
>   int tmp___2 ;
>   int tmp___3 ;
>   int tmp___4 ;
>   int tmp___5 ;
>   int tmp___6 ;
>   int tmp___7 ;
>   int tmp___8 ;
>   int tmp___9 ;
>   int tmp___10 ;
>   int tmp___11 ;
>   int tmp___12 ;
>   int tmp___13 ;
>   int tmp___14 ;
>   int tmp___15 ;
>   int tmp___16 ;
>   int tmp___17 ;
>   int tmp___18 ;
>   int tmp___19 ;
>   int tmp___20 ;
>   int tmp___21 ;
>   int tmp___22 ;
>   int tmp___23 ;
>   int tmp___24 ;
>   int tmp___25 ;
>   int tmp___26 ;
>   int tmp___27 ;
>   int tmp___28 ;
>   int tmp___29 ;
>   int tmp___30 ;
>   int tmp___31 ;
>   int tmp___32 ;
>   int tmp___33 ;
>   int tmp___34 ;
>   int tmp___35 ;
>   int tmp___36 ;
>   int tmp___37 ;
>   int tmp___38 ;
>   int tmp___39 ;
>   int tmp___40 ;
>   int tmp___41 ;
>   int tmp___42 ;
>   int tmp___43 ;
>   int tmp___44 ;
>   int tmp___45 ;
>   int tmp___46 ;
>   int tmp___47 ;
>   int tmp___48 ;
>   int tmp___49 ;
>   int tmp___50 ;
>   int tmp___51 ;
>   int tmp___52 ;
>   int tmp___53 ;
>   int tmp___54 ;
>   int tmp___55 ;
>   int tmp___56 ;
>   int tmp___57 ;
>   int tmp___58 ;
>   int tmp___59 ;
>   int tmp___60 ;
>   int tmp___61 ;
>   int tmp___62 ;
>   int tmp___63 ;
>   int tmp___64 ;
>   int tmp___65 ;
> 
>   {
> #line 150
>   if (! size) {
> #line 151
>     return (0);
>   } else {
> 
>   }
> #line 153
>   if (size <= (size_t )8) {
> #line 154
>     if (8 < 1) {
> #line 154
>       tmp = ____ilog2_NaN();
> #line 154
>       tmp___65 = tmp;
>     } else {
> #line 154
>       if (8ULL & (1ULL << 63)) {
> #line 154
>         tmp___64 = 63;
>       } else {
> #line 154
>         if (8ULL & (1ULL << 62)) {
> #line 154
>           tmp___63 = 62;
>         } else {
> #line 154
>           if (8ULL & (1ULL << 61)) {
> #line 154
>             tmp___62 = 61;
>           } else {
> #line 154
>             if (8ULL & (1ULL << 60)) {
> #line 154
>               tmp___61 = 60;
>             } else {
> #line 154
>               if (8ULL & (1ULL << 59)) {
> #line 154
>                 tmp___60 = 59;
>               } else {
> #line 154
>                 if (8ULL & (1ULL << 58)) {
> #line 154
>                   tmp___59 = 58;
>                 } else {
> #line 154
>                   if (8ULL & (1ULL << 57)) {
> #line 154
>                     tmp___58 = 57;
>                   } else {
> #line 154
>                     if (8ULL & (1ULL << 56)) {
> #line 154
>                       tmp___57 = 56;
>                     } else {
> #line 154
>                       if (8ULL & (1ULL << 55)) {
> #line 154
>                         tmp___56 = 55;
>                       } else {
> #line 154
>                         if (8ULL & (1ULL << 54)) {
> #line 154
>                           tmp___55 = 54;
>                         } else {
> #line 154
>                           if (8ULL & (1ULL << 53)) {
> #line 154
>                             tmp___54 = 53;
>                           } else {
> #line 154
>                             if (8ULL & (1ULL << 52)) {
> #line 154
>                               tmp___53 = 52;
>                             } else {
> #line 154
>                               if (8ULL & (1ULL << 51)) {
> #line 154
>                                 tmp___52 = 51;
>                               } else {
> #line 154
>                                 if (8ULL & (1ULL << 50)) {
> #line 154
>                                   tmp___51 = 50;
>                                 } else {
> #line 154
>                                   if (8ULL & (1ULL << 49)) {
> #line 154
>                                     tmp___50 = 49;
>                                   } else {
> #line 154
>                                     if (8ULL & (1ULL << 48)) {
> #line 154
>                                       tmp___49 = 48;
>                                     } else {
> #line 154
>                                       if (8ULL & (1ULL << 47)) {
> #line 154
>                                         tmp___48 = 47;
>                                       } else {
> #line 154
>                                         if (8ULL & (1ULL << 46)) {
> #line 154
>                                           tmp___47 = 46;
>                                         } else {
> #line 154
>                                           if (8ULL & (1ULL << 45)) {
> #line 154
>                                             tmp___46 = 45;
>                                           } else {
> #line 154
>                                             if (8ULL & (1ULL << 44)) {
> #line 154
>                                               tmp___45 = 44;
>                                             } else {
> #line 154
>                                               if (8ULL & (1ULL << 43)) {
> #line 154
>                                                 tmp___44 = 43;
>                                               } else {
> #line 154
>                                                 if (8ULL & (1ULL << 42)) {
> #line 154
>                                                   tmp___43 = 42;
>                                                 } else {
> #line 154
>                                                   if (8ULL & (1ULL << 41)) {
> #line 154
>                                                     tmp___42 = 41;
>                                                   } else {
> #line 154
>                                                     if (8ULL & (1ULL << 40)) {
> #line 154
>                                                       tmp___41 = 40;
>                                                     } else {
> #line 154
>                                                       if (8ULL & (1ULL << 39)) {
> #line 154
>                                                         tmp___40 = 39;
>                                                       } else {
> #line 154
>                                                         if (8ULL & (1ULL << 38)) {
> #line 154
>                                                           tmp___39 = 38;
>                                                         } else {
> #line 154
>                                                           if (8ULL & (1ULL << 37)) {
> #line 154
>                                                             tmp___38 = 37;
>                                                           } else {
> #line 154
>                                                             if (8ULL & (1ULL << 36)) {
> #line 154
>                                                               tmp___37 = 36;
>                                                             } else {
> #line 154
>                                                               if (8ULL & (1ULL << 35)) {
> #line 154
>                                                                 tmp___36 = 35;
>                                                               } else {
> #line 154
>                                                                 if (8ULL & (1ULL << 34)) {
> #line 154
>                                                                   tmp___35 = 34;
>                                                                 } else {
> #line 154
>                                                                   if (8ULL & (1ULL << 33)) {
> #line 154
>                                                                     tmp___34 = 33;
>                                                                   } else {
> #line 154
>                                                                     if (8ULL & (1ULL << 32)) {
> #line 154
>                                                                       tmp___33 = 32;
>                                                                     } else {
> #line 154
>                                                                       if (8ULL & (1ULL << 31)) {
> #line 154
>                                                                         tmp___32 = 31;
>                                                                       } else {
> #line 154
>                                                                         if (8ULL & (1ULL << 30)) {
> #line 154
>                                                                           tmp___31 = 30;
>                                                                         } else {
> #line 154
>                                                                           if (8ULL & (1ULL << 29)) {
> #line 154
>                                                                             tmp___30 = 29;
>                                                                           } else {
> #line 154
>                                                                             if (8ULL & (1ULL << 28)) {
> #line 154
>                                                                               tmp___29 = 28;
>                                                                             } else {
> #line 154
>                                                                               if (8ULL & (1ULL << 27)) {
> #line 154
>                                                                                 tmp___28 = 27;
>                                                                               } else {
> #line 154
>                                                                                 if (8ULL & (1ULL << 26)) {
> #line 154
>                                                                                   tmp___27 = 26;
>                                                                                 } else {
> #line 154
>                                                                                   if (8ULL & (1ULL << 25)) {
> #line 154
>                                                                                     tmp___26 = 25;
>                                                                                   } else {
> #line 154
>                                                                                     if (8ULL & (1ULL << 24)) {
> #line 154
>                                                                                       tmp___25 = 24;
>                                                                                     } else {
> #line 154
>                                                                                       if (8ULL & (1ULL << 23)) {
> #line 154
>                                                                                         tmp___24 = 23;
>                                                                                       } else {
> #line 154
>                                                                                         if (8ULL & (1ULL << 22)) {
> #line 154
>                                                                                           tmp___23 = 22;
>                                                                                         } else {
> #line 154
>                                                                                           if (8ULL & (1ULL << 21)) {
> #line 154
>                                                                                             tmp___22 = 21;
>                                                                                           } else {
> #line 154
>                                                                                             if (8ULL & (1ULL << 20)) {
> #line 154
>                                                                                               tmp___21 = 20;
>                                                                                             } else {
> #line 154
>                                                                                               if (8ULL & (1ULL << 19)) {
> #line 154
>                                                                                                 tmp___20 = 19;
>                                                                                               } else {
> #line 154
>                                                                                                 if (8ULL & (1ULL << 18)) {
> #line 154
>                                                                                                   tmp___19 = 18;
>                                                                                                 } else {
> #line 154
>                                                                                                   if (8ULL & (1ULL << 17)) {
> #line 154
>                                                                                                     tmp___18 = 17;
>                                                                                                   } else {
> #line 154
>                                                                                                     if (8ULL & (1ULL << 16)) {
> #line 154
>                                                                                                       tmp___17 = 16;
>                                                                                                     } else {
> #line 154
>                                                                                                       if (8ULL & (1ULL << 15)) {
> #line 154
>                                                                                                         tmp___16 = 15;
>                                                                                                       } else {
> #line 154
>                                                                                                         if (8ULL & (1ULL << 14)) {
> #line 154
>                                                                                                           tmp___15 = 14;
>                                                                                                         } else {
> #line 154
>                                                                                                           if (8ULL & (1ULL << 13)) {
> #line 154
>                                                                                                             tmp___14 = 13;
>                                                                                                           } else {
> #line 154
>                                                                                                             if (8ULL & (1ULL << 12)) {
> #line 154
>                                                                                                               tmp___13 = 12;
>                                                                                                             } else {
> #line 154
>                                                                                                               if (8ULL & (1ULL << 11)) {
> #line 154
>                                                                                                                 tmp___12 = 11;
>                                                                                                               } else {
> #line 154
>                                                                                                                 if (8ULL & (1ULL << 10)) {
> #line 154
>                                                                                                                   tmp___11 = 10;
>                                                                                                                 } else {
> #line 154
>                                                                                                                   if (8ULL & (1ULL << 9)) {
> #line 154
>                                                                                                                     tmp___10 = 9;
>                                                                                                                   } else {
> #line 154
>                                                                                                                     if (8ULL & (1ULL << 8)) {
> #line 154
>                                                                                                                       tmp___9 = 8;
>                                                                                                                     } else {
> #line 154
>                                                                                                                       if (8ULL & (1ULL << 7)) {
> #line 154
>                                                                                                                         tmp___8 = 7;
>                                                                                                                       } else {
> #line 154
>                                                                                                                         if (8ULL & (1ULL << 6)) {
> #line 154
>                                                                                                                           tmp___7 = 6;
>                                                                                                                         } else {
> #line 154
>                                                                                                                           if (8ULL & (1ULL << 5)) {
> #line 154
>                                                                                                                             tmp___6 = 5;
>                                                                                                                           } else {
> #line 154
>                                                                                                                             if (8ULL & (1ULL << 4)) {
> #line 154
>                                                                                                                               tmp___5 = 4;
>                                                                                                                             } else {
> #line 154
>                                                                                                                               if (8ULL & (1ULL << 3)) {
> #line 154
>                                                                                                                                 tmp___4 = 3;
>                                                                                                                               } else {
> #line 154
>                                                                                                                                 if (8ULL & (1ULL << 2)) {
> #line 154
>                                                                                                                                   tmp___3 = 2;
>                                                                                                                                 } else {
> #line 154
>                                                                                                                                   if (8ULL & (1ULL << 1)) {
> #line 154
>                                                                                                                                     tmp___2 = 1;
>                                                                                                                                   } else {
> #line 154
>                                                                                                                                     if (8ULL & (1ULL << 0)) {
> #line 154
>                                                                                                                                       tmp___1 = 0;
>                                                                                                                                     } else {
> #line 154
>                                                                                                                                       tmp___0 = ____ilog2_NaN();
> #line 154
>                                                                                                                                       tmp___1 = tmp___0;
>                                                                                                                                     }
> #line 154
>                                                                                                                                     tmp___2 = tmp___1;
>                                                                                                                                   }
> #line 154
>                                                                                                                                   tmp___3 = tmp___2;
>                                                                                                                                 }
> #line 154
>                                                                                                                                 tmp___4 = tmp___3;
>                                                                                                                               }
> #line 154
>                                                                                                                               tmp___5 = tmp___4;
>                                                                                                                             }
> #line 154
>                                                                                                                             tmp___6 = tmp___5;
>                                                                                                                           }
> #line 154
>                                                                                                                           tmp___7 = tmp___6;
>                                                                                                                         }
> #line 154
>                                                                                                                         tmp___8 = tmp___7;
>                                                                                                                       }
> #line 154
>                                                                                                                       tmp___9 = tmp___8;
>                                                                                                                     }
> #line 154
>                                                                                                                     tmp___10 = tmp___9;
>                                                                                                                   }
> #line 154
>                                                                                                                   tmp___11 = tmp___10;
>                                                                                                                 }
> #line 154
>                                                                                                                 tmp___12 = tmp___11;
>                                                                                                               }
> #line 154
>                                                                                                               tmp___13 = tmp___12;
>                                                                                                             }
> #line 154
>                                                                                                             tmp___14 = tmp___13;
>                                                                                                           }
> #line 154
>                                                                                                           tmp___15 = tmp___14;
>                                                                                                         }
> #line 154
>                                                                                                         tmp___16 = tmp___15;
>                                                                                                       }
> #line 154
>                                                                                                       tmp___17 = tmp___16;
>                                                                                                     }
> #line 154
>                                                                                                     tmp___18 = tmp___17;
>                                                                                                   }
> #line 154
>                                                                                                   tmp___19 = tmp___18;
>                                                                                                 }
> #line 154
>                                                                                                 tmp___20 = tmp___19;
>                                                                                               }
> #line 154
>                                                                                               tmp___21 = tmp___20;
>                                                                                             }
> #line 154
>                                                                                             tmp___22 = tmp___21;
>                                                                                           }
> #line 154
>                                                                                           tmp___23 = tmp___22;
>                                                                                         }
> #line 154
>                                                                                         tmp___24 = tmp___23;
>                                                                                       }
> #line 154
>                                                                                       tmp___25 = tmp___24;
>                                                                                     }
> #line 154
>                                                                                     tmp___26 = tmp___25;
>                                                                                   }
> #line 154
>                                                                                   tmp___27 = tmp___26;
>                                                                                 }
> #line 154
>                                                                                 tmp___28 = tmp___27;
>                                                                               }
> #line 154
>                                                                               tmp___29 = tmp___28;
>                                                                             }
> #line 154
>                                                                             tmp___30 = tmp___29;
>                                                                           }
> #line 154
>                                                                           tmp___31 = tmp___30;
>                                                                         }
> #line 154
>                                                                         tmp___32 = tmp___31;
>                                                                       }
> #line 154
>                                                                       tmp___33 = tmp___32;
>                                                                     }
> #line 154
>                                                                     tmp___34 = tmp___33;
>                                                                   }
> #line 154
>                                                                   tmp___35 = tmp___34;
>                                                                 }
> #line 154
>                                                                 tmp___36 = tmp___35;
>                                                               }
> #line 154
>                                                               tmp___37 = tmp___36;
>                                                             }
> #line 154
>                                                             tmp___38 = tmp___37;
>                                                           }
> #line 154
>                                                           tmp___39 = tmp___38;
>                                                         }
> #line 154
>                                                         tmp___40 = tmp___39;
>                                                       }
> #line 154
>                                                       tmp___41 = tmp___40;
>                                                     }
> #line 154
>                                                     tmp___42 = tmp___41;
>                                                   }
> #line 154
>                                                   tmp___43 = tmp___42;
>                                                 }
> #line 154
>                                                 tmp___44 = tmp___43;
>                                               }
> #line 154
>                                               tmp___45 = tmp___44;
>                                             }
> #line 154
>                                             tmp___46 = tmp___45;
>                                           }
> #line 154
>                                           tmp___47 = tmp___46;
>                                         }
> #line 154
>                                         tmp___48 = tmp___47;
>                                       }
> #line 154
>                                       tmp___49 = tmp___48;
>                                     }
> #line 154
>                                     tmp___50 = tmp___49;
>                                   }
> #line 154
>                                   tmp___51 = tmp___50;
>                                 }
> #line 154
>                                 tmp___52 = tmp___51;
>                               }
> #line 154
>                               tmp___53 = tmp___52;
>                             }
> #line 154
>                             tmp___54 = tmp___53;
>                           }
> #line 154
>                           tmp___55 = tmp___54;
>                         }
> #line 154
>                         tmp___56 = tmp___55;
>                       }
> #line 154
>                       tmp___57 = tmp___56;
>                     }
> #line 154
>                     tmp___58 = tmp___57;
>                   }
> #line 154
>                   tmp___59 = tmp___58;
>                 }
> #line 154
>                 tmp___60 = tmp___59;
>               }
> #line 154
>               tmp___61 = tmp___60;
>             }
> #line 154
>             tmp___62 = tmp___61;
>           }
> #line 154
>           tmp___63 = tmp___62;
>         }
> #line 154
>         tmp___64 = tmp___63;
>       }
> #line 154
>       tmp___65 = tmp___64;
>     }
> #line 154
>     return (tmp___65);
>   } else {
> 
>   }
> #line 156
>   if ((8 <= 32 && size > (size_t )64) && size <= (size_t )96) {
> #line 157
>     return (1);
>   } else {
> 
>   }
> #line 158
>   if ((8 <= 64 && size > (size_t )128) && size <= (size_t )192) {
> #line 159
>     return (2);
>   } else {
> 
>   }
> #line 160
>   if (size <= (size_t )8) {
> #line 160
>     return (3);
>   } else {
> 
>   }
> #line 161
>   if (size <= (size_t )16) {
> #line 161
>     return (4);
>   } else {
> 
>   }
> #line 162
>   if (size <= (size_t )32) {
> #line 162
>     return (5);
>   } else {
> 
>   }
> #line 163
>   if (size <= (size_t )64) {
> #line 163
>     return (6);
>   } else {
> 
>   }
> #line 164
>   if (size <= (size_t )128) {
> #line 164
>     return (7);
>   } else {
> 
>   }
> #line 165
>   if (size <= (size_t )256) {
> #line 165
>     return (8);
>   } else {
> 
>   }
> #line 166
>   if (size <= (size_t )512) {
> #line 166
>     return (9);
>   } else {
> 
>   }
> #line 167
>   if (size <= (size_t )1024) {
> #line 167
>     return (10);
>   } else {
> 
>   }
> #line 168
>   if (size <= (size_t )(2 * 1024)) {
> #line 168
>     return (11);
>   } else {
> 
>   }
> #line 169
>   if (size <= (size_t )(4 * 1024)) {
> #line 169
>     return (12);
>   } else {
> 
>   }
> #line 174
>   if (size <= (size_t )(8 * 1024)) {
> #line 174
>     return (13);
>   } else {
> 
>   }
> #line 175
>   if (size <= (size_t )(16 * 1024)) {
> #line 175
>     return (14);
>   } else {
> 
>   }
> #line 176
>   if (size <= (size_t )(32 * 1024)) {
> #line 176
>     return (15);
>   } else {
> 
>   }
> #line 177
>   if (size <= (size_t )(64 * 1024)) {
> #line 177
>     return (16);
>   } else {
> 
>   }
> #line 178
>   if (size <= (size_t )(128 * 1024)) {
> #line 178
>     return (17);
>   } else {
> 
>   }
> #line 179
>   if (size <= (size_t )(256 * 1024)) {
> #line 179
>     return (18);
>   } else {
> 
>   }
> #line 180
>   if (size <= (size_t )(512 * 1024)) {
> #line 180
>     return (19);
>   } else {
> 
>   }
> #line 181
>   if (size <= (size_t )(1024 * 1024)) {
> #line 181
>     return (20);
>   } else {
> 
>   }
> #line 182
>   if (size <= (size_t )((2 * 1024) * 1024)) {
> #line 182
>     return (21);
>   } else {
> 
>   }
> #line 183
>   return (-1);
> }
> }
> #line 200 "include/linux/slub_def.h"
> __inline static struct kmem_cache *( __attribute__((__always_inline__)) kmalloc_slab)(size_t size ) 
> { 
>   int index ;
>   int tmp ;
> 
>   {
> #line 202
>   tmp = kmalloc_index(size);
> #line 202
>   index = tmp;
> #line 204
>   if (index == 0) {
> #line 205
>     return ((void *)0);
>   } else {
> 
>   }
> #line 207
>   return (& kmalloc_caches[index]);
> }
> }
> #line 218
> extern void *__kmalloc(size_t size , gfp_t flags ) ;
> #line 221
> extern void *kmem_cache_alloc_notrace(struct kmem_cache *s , gfp_t gfpflags ) ;
> #line 230 "include/linux/slub_def.h"
> __inline static void *( __attribute__((__always_inline__)) kmalloc_large)(size_t size ,
>                                                                           gfp_t flags ) 
> { 
>   unsigned int order ;
>   int tmp ;
>   void *ret ;
>   unsigned long tmp___0 ;
> 
>   {
> #line 232
>   tmp = get_order(size);
> #line 232
>   order = tmp;
> #line 233
>   tmp___0 = __get_free_pages(flags | 16384U, order);
> #line 233
>   ret = (void *)tmp___0;
> #line 235
>   kmemleak_alloc(ret, size, 1, flags);
> #line 236
>   trace_kmalloc((unsigned long )((void *)0), ret, size, (1UL << 12) << order, flags);
> #line 238
>   return (ret);
> }
> }
> #line 241 "include/linux/slub_def.h"
> __inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
>                                                                     gfp_t flags ) 
> { 
>   void *ret ;
>   void *tmp ;
>   struct kmem_cache *s ;
>   struct kmem_cache *tmp___0 ;
>   void *tmp___1 ;
> 
>   {
> #line 245
>   if (0) {
> #line 246
>     if (size > 2UL * (1UL << 12)) {
> #line 247
>       tmp = kmalloc_large(size, flags);
> #line 247
>       return (tmp);
>     } else {
> 
>     }
> #line 249
>     if (! (flags & 1U)) {
> #line 250
>       tmp___0 = kmalloc_slab(size);
> #line 250
>       s = tmp___0;
> #line 252
>       if (! s) {
> #line 253
>         return ((void *)16);
>       } else {
> 
>       }
> #line 255
>       ret = kmem_cache_alloc_notrace(s, flags);
> #line 257
>       trace_kmalloc((unsigned long )((void *)0), ret, size, s->size, flags);
> #line 259
>       return (ret);
>     } else {
> 
>     }
>   } else {
> 
>   }
> #line 262
>   tmp___1 = __kmalloc(size, flags);
> #line 262
>   return (tmp___1);
> }
> }
> #line 313 "include/linux/slab.h"
> __inline static void *kzalloc(size_t size , gfp_t flags ) 
> { 
>   void *tmp ;
> 
>   {
> #line 315
>   tmp = kmalloc(size, flags | 32768U);
> #line 315
>   return (tmp);
> }
> }
> #line 68 "include/linux/module.h"
> int init_module(void) ;
> #line 69
> void cleanup_module(void) ;
> #line 88
1962,1963d4648
< #line 11 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
< void ldv_check_alloc_flags(gfp_t flags ) ;
1965c4650
< extern void *dev_get_drvdata(struct device  const  * ) ;
---
> extern void *dev_get_drvdata(struct device  const  *dev ) ;
1967c4652
< extern void dev_set_drvdata(struct device * , void * ) ;
---
> extern void dev_set_drvdata(struct device *dev , void *data ) ;
1971c4656
< extern void input_free_device(struct input_dev * ) ;
---
> extern void input_free_device(struct input_dev *dev ) ;
1973c4658
< extern int input_register_device(struct input_dev * ) ;
---
> extern int ( __attribute__((__warn_unused_result__)) input_register_device)(struct input_dev * ) ;
1977c4662,4663
< extern void input_event(struct input_dev * , unsigned int  , unsigned int  , int  ) ;
---
> extern void input_event(struct input_dev *dev , unsigned int type , unsigned int code ,
>                         int value ) ;
1986c4672
<   input_event(dev, 1U, code, value != 0);
---
>   input_event(dev, 1, code, ! (! value));
1999c4685
<   input_event(dev, 2U, code, value);
---
>   input_event(dev, 2, code, value);
2012c4698
<   input_event(dev, 3U, code, value);
---
>   input_event(dev, 3, code, value);
2024c4710
<   input_event(dev, 0U, 0U, 0);
---
>   input_event(dev, 0, 0, 0);
2051c4737
< extern int serio_open(struct serio * , struct serio_driver * ) ;
---
> extern int serio_open(struct serio *serio , struct serio_driver *drv ) ;
2053c4739
< extern void serio_close(struct serio * ) ;
---
> extern void serio_close(struct serio *serio ) ;
2055c4741,4742
< extern int __serio_register_driver(struct serio_driver * , struct module * , char const   * ) ;
---
> extern int __serio_register_driver(struct serio_driver *drv , struct module *owner ,
>                                    char const   *mod_name ) ;
2057c4744
< __inline static int serio_register_driver(struct serio_driver *drv ) 
---
> __inline static int ( __attribute__((__warn_unused_result__)) serio_register_driver)(struct serio_driver *drv ) 
2069c4756
< extern void serio_unregister_driver(struct serio_driver * ) ;
---
> extern void serio_unregister_driver(struct serio_driver *drv ) ;
2077c4764
<   if ((unsigned long )serio->write != (unsigned long )((int (*)(struct serio * , unsigned char  ))0)) {
---
>   if (serio->write) {
2079c4766
<     tmp = (*(serio->write))(serio, (int )data);
---
>     tmp = (*(serio->write))(serio, data);
2095c4782
<   tmp = dev_get_drvdata((struct device  const  *)(& serio->dev));
---
>   tmp = dev_get_drvdata(& serio->dev);
2112c4799,4842
< #line 142 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 90 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
> static char const   __mod_author90[45]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
> #line 90 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
>   {      'a',      'u',      't',      'h', 
>         'o',      'r',      '=',      'J', 
>         'a',      'n',      '-',      'B', 
>         'e',      'n',      'e',      'd', 
>         'i',      'c',      't',      ' ', 
>         'G',      'l',      'a',      'w', 
>         ' ',      '<',      'j',      'b', 
>         'g',      'l',      'a',      'w', 
>         '@',      'l',      'u',      'g', 
>         '-',      'o',      'w',      'l', 
>         '.',      'd',      'e',      '>', 
>         '\000'};
> #line 91 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
> static char const   __mod_description91[69]  __attribute__((__used__, __unused__,
> __section__(".modinfo")))  = 
> #line 91
>   {      'd',      'e',      's',      'c', 
>         'r',      'i',      'p',      't', 
>         'i',      'o',      'n',      '=', 
>         'D',      'r',      'i',      'v', 
>         'e',      'r',      ' ',      'f', 
>         'o',      'r',      ' ',      'D', 
>         'E',      'C',      ' ',      'V', 
>         'S',      'X',      'X',      'X', 
>         '-',      'A',      'A',      ' ', 
>         'a',      'n',      'd',      ' ', 
>         '-',      'G',      'A',      ' ', 
>         'm',      'i',      'c',      'e', 
>         ' ',      'a',      'n',      'd', 
>         ' ',      'V',      'S',      'X', 
>         'X',      'X',      '-',      'A', 
>         'B',      ' ',      't',      'a', 
>         'b',      'l',      'e',      't', 
>         '\000'};
> #line 92 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
> static char const   __mod_license92[12]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
> #line 92
>   {      'l',      'i',      'c',      'e', 
>         'n',      's',      'e',      '=', 
>         'G',      'P',      'L',      '\000'};
> #line 128 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2118,2127c4848,4856
< #line 144
<   if ((int )mouse->count <= num) {
< #line 145
<     mouse->count = 0U;
<   } else {
< #line 147
<     memmove((void *)(& mouse->buf), (void const   *)(& mouse->buf) + ((unsigned long )num + 0xffffffffffffffffUL),
<             (size_t )(15 - num));
< #line 148
<     mouse->count = (int )mouse->count - (int )((unsigned char )num);
---
> #line 130
>   if (num >= (int )mouse->count) {
> #line 131
>     mouse->count = 0;
>   } else {
> #line 133
>     memmove(mouse->buf, (mouse->buf + num) - 1, 15 - num);
> #line 134
>     mouse->count = (int )mouse->count - num;
2129c4858
< #line 150
---
> #line 136
2133c4862
< #line 152 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 138 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2139,2144c4868,4872
< #line 154
<   if ((unsigned int )mouse->count == 15U) {
< #line 155
<     printk("<3>%s on %s: Dropping a byte of full buffer.\n", (char *)(& mouse->name),
<            (char *)(& mouse->phys));
< #line 157
---
> #line 140
>   if ((int )mouse->count == 15) {
> #line 141
>     printk("<3>%s on %s: Dropping a byte of full buffer.\n", mouse->name, mouse->phys);
> #line 143
2149c4877,4882
< #line 162
---
> #line 146
>   while (1) {
> #line 146
>     break;
>   }
> #line 148
2151c4884
< #line 162
---
> #line 148
2153,2155c4886,4888
< #line 162
<   mouse->buf[(int )tmp] = byte;
< #line 163
---
> #line 148
>   mouse->buf[tmp] = byte;
> #line 149
2159c4892
< #line 165 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 151 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2165c4898
< #line 167
---
> #line 153
2168,2171c4901,4904
< #line 169
<   strlcpy((char *)(& mouse->name), "DEC VSXXX-AA/-GA mouse", 64UL);
< #line 171
<   goto ldv_16986;
---
> #line 155
>   strlcpy(mouse->name, "DEC VSXXX-AA/-GA mouse", sizeof(mouse->name));
> #line 157
>   break;
2173,2176c4906,4909
< #line 174
<   strlcpy((char *)(& mouse->name), "DEC VSXXX-AB digitizer", 64UL);
< #line 176
<   goto ldv_16986;
---
> #line 160
>   strlcpy(mouse->name, "DEC VSXXX-AB digitizer", sizeof(mouse->name));
> #line 162
>   break;
2178,2182c4911,4915
< #line 179
<   snprintf((char *)(& mouse->name), 64UL, "unknown DEC pointer device (type = 0x%02x)",
<            (int )mouse->type);
< #line 182
<   goto ldv_16986;
---
> #line 165
>   snprintf(mouse->name, sizeof(mouse->name), "unknown DEC pointer device (type = 0x%02x)",
>            mouse->type);
> #line 168
>   break;
2184,2188c4917,4920
<   ldv_16986: 
< #line 185
<   printk("<6>Found %s version 0x%02x from country 0x%02x on port %s\n", (char *)(& mouse->name),
<          (int )mouse->version, (int )mouse->country, (char *)(& mouse->phys));
< #line 188
---
> #line 171
>   printk("<6>Found %s version 0x%02x from country 0x%02x on port %s\n", mouse->name,
>          mouse->version, mouse->country, mouse->phys);
> #line 174
2192c4924
< #line 193 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 179 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2198,2200c4930,4937
< #line 198
<   if ((int )((signed char )mouse->buf[0]) >= 0) {
< #line 200
---
> #line 184
>   if (! (((int )mouse->buf[0] & 128) == 128)) {
> #line 185
>     while (1) {
> #line 185
>       break;
>     }
> #line 186
2205c4942
< #line 204
---
> #line 190
2207,2216c4944,4947
< #line 204
<   goto ldv_16995;
<   ldv_16994: ;
< #line 205
<   if ((int )((signed char )mouse->buf[i]) < 0) {
< #line 206
<     printk("<3>Need to drop %d bytes of a broken packet.\n", i + -1);
< #line 211
<     return (i + -1);
<   } else {
---
> #line 190
>   while (1) {
> #line 190
>     if (i < packet_len) {
2218,2226c4949,4964
<   }
< #line 204
<   i = i + 1;
<   ldv_16995: ;
< #line 204
<   if (i < packet_len) {
< #line 205
<     goto ldv_16994;
<   } else {
---
>     } else {
> #line 190
>       break;
>     }
> #line 191
>     if (((int )mouse->buf[i] & 128) == 128) {
> #line 192
>       printk("<3>Need to drop %d bytes of a broken packet.\n", i - 1);
> #line 195
>       while (1) {
> #line 195
>         break;
>       }
> #line 197
>       return (i - 1);
>     } else {
2227a4966,4968
>     }
> #line 190
>     i = i + 1;
2229,2230c4970
< 
< #line 215
---
> #line 201
2234c4974
< #line 218 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 204 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2241c4981
< #line 221
---
> #line 207
2245c4985
< #line 224 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 210 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2257c4997
< #line 226
---
> #line 212
2259,2260c4999,5008
< #line 227
<   buf = (unsigned char *)(& mouse->buf);
---
> #line 213
>   buf = mouse->buf;
> #line 230
>   dx = (int )*(buf + 1) & 127;
> #line 231
>   dx = dx * (((int )*(buf + 0) >> 4) & 1 ? 1 : -1);
> #line 237
>   dy = (int )*(buf + 2) & 127;
> #line 238
>   dy = dy * (((int )*(buf + 0) >> 3) & 1 ? -1 : 1);
2262c5010
<   dx = (int )*(buf + 1UL) & 127;
---
>   left = (int )*(buf + 0) & 4;
2264,2268c5012,5023
<   dx = (((int )*buf >> 4) & 1 ? 1 : -1) * dx;
< #line 251
<   dy = (int )*(buf + 2UL) & 127;
< #line 252
<   dy = (((int )*buf >> 3) & 1 ? -1 : 1) * dy;
---
>   middle = (int )*(buf + 0) & 2;
> #line 246
>   right = (int )*(buf + 0) & 1;
> #line 248
>   vsxxxaa_drop_bytes(mouse, 3);
> #line 250
>   while (1) {
> #line 250
>     break;
>   }
> #line 257
>   input_report_key(dev, 272, left);
2270c5025
<   left = (int )*buf & 4;
---
>   input_report_key(dev, 274, middle);
2272c5027
<   middle = (int )*buf & 2;
---
>   input_report_key(dev, 273, right);
2274c5029,5031
<   right = (int )*buf & 1;
---
>   input_report_key(dev, 330, 0);
> #line 261
>   input_report_rel(dev, 0, dx);
2276,2289c5033,5034
<   vsxxxaa_drop_bytes(mouse, 3);
< #line 271
<   input_report_key(dev, 272U, left);
< #line 272
<   input_report_key(dev, 274U, middle);
< #line 273
<   input_report_key(dev, 273U, right);
< #line 274
<   input_report_key(dev, 330U, 0);
< #line 275
<   input_report_rel(dev, 0U, dx);
< #line 276
<   input_report_rel(dev, 1U, dy);
< #line 277
---
>   input_report_rel(dev, 1, dy);
> #line 263
2291c5036
< #line 278
---
> #line 264
2295c5040
< #line 280 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 266 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2308c5053
< #line 282
---
> #line 268
2310,2316c5055,5061
< #line 283
<   buf = (unsigned char *)(& mouse->buf);
< #line 301
<   x = (((int )*(buf + 2UL) & 63) << 6) | ((int )*(buf + 1UL) & 63);
< #line 302
<   y = (((int )*(buf + 4UL) & 63) << 6) | ((int )*(buf + 3UL) & 63);
< #line 303
---
> #line 269
>   buf = mouse->buf;
> #line 287
>   x = (((int )*(buf + 2) & 63) << 6) | ((int )*(buf + 1) & 63);
> #line 288
>   y = (((int )*(buf + 4) & 63) << 6) | ((int )*(buf + 3) & 63);
> #line 289
2318,2319c5063,5077
< #line 308
<   left = (int )*buf & 2;
---
> #line 294
>   left = (int )*(buf + 0) & 2;
> #line 295
>   middle = (int )*(buf + 0) & 4;
> #line 296
>   right = (int )*(buf + 0) & 8;
> #line 297
>   touch = (int )*(buf + 0) & 16;
> #line 299
>   vsxxxaa_drop_bytes(mouse, 5);
> #line 301
>   while (1) {
> #line 301
>     break;
>   }
2321c5079
<   middle = (int )*buf & 4;
---
>   input_report_key(dev, 272, left);
2323c5081
<   right = (int )*buf & 8;
---
>   input_report_key(dev, 274, middle);
2325c5083,5085
<   touch = (int )*buf & 16;
---
>   input_report_key(dev, 273, right);
> #line 312
>   input_report_key(dev, 330, touch);
2327,2340c5087,5090
<   vsxxxaa_drop_bytes(mouse, 5);
< #line 323
<   input_report_key(dev, 272U, left);
< #line 324
<   input_report_key(dev, 274U, middle);
< #line 325
<   input_report_key(dev, 273U, right);
< #line 326
<   input_report_key(dev, 330U, touch);
< #line 327
<   input_report_abs(dev, 0U, x);
< #line 328
<   input_report_abs(dev, 1U, y);
< #line 329
---
>   input_report_abs(dev, 0, x);
> #line 314
>   input_report_abs(dev, 1, y);
> #line 315
2342c5092
< #line 330
---
> #line 316
2346c5096
< #line 332 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 318 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2361c5111
< #line 334
---
> #line 320
2363,2364c5113,5128
< #line 335
<   buf = (unsigned char *)(& mouse->buf);
---
> #line 321
>   buf = mouse->buf;
> #line 343
>   mouse->version = (int )*(buf + 0) & 15;
> #line 344
>   mouse->country = ((int )*(buf + 1) >> 4) & 7;
> #line 345
>   mouse->type = (int )*(buf + 1) & 15;
> #line 346
>   error = (int )*(buf + 2) & 127;
> #line 353
>   left = (int )*(buf + 0) & 4;
> #line 354
>   middle = (int )*(buf + 0) & 2;
> #line 355
>   right = (int )*(buf + 0) & 1;
2366c5130
<   mouse->version = (unsigned int )*buf & 15U;
---
>   vsxxxaa_drop_bytes(mouse, 4);
2368,2370c5132
<   mouse->country = (unsigned int )((int )*(buf + 1UL) >> 4) & 7U;
< #line 359
<   mouse->type = (unsigned int )*(buf + 1UL) & 15U;
---
>   vsxxxaa_detection_done(mouse);
2372,2374c5134,5144
<   error = (unsigned int )*(buf + 2UL) & 127U;
< #line 367
<   left = (int )*buf & 4;
---
>   if ((int )error <= 31) {
> #line 362
>     input_report_key(dev, 272, left);
> #line 363
>     input_report_key(dev, 274, middle);
> #line 364
>     input_report_key(dev, 273, right);
> #line 365
>     input_report_key(dev, 330, 0);
> #line 366
>     input_sync(dev);
2376c5146
<   middle = (int )*buf & 2;
---
>     if ((int )error != 0) {
2378,2399c5148,5149
<   right = (int )*buf & 1;
< #line 371
<   vsxxxaa_drop_bytes(mouse, 4);
< #line 372
<   vsxxxaa_detection_done(mouse);
< #line 374
<   if ((unsigned int )error <= 31U) {
< #line 376
<     input_report_key(dev, 272U, left);
< #line 377
<     input_report_key(dev, 274U, middle);
< #line 378
<     input_report_key(dev, 273U, right);
< #line 379
<     input_report_key(dev, 330U, 0);
< #line 380
<     input_sync(dev);
< #line 382
<     if ((unsigned int )error != 0U) {
< #line 383
<       printk("<6>Your %s on %s reports error=0x%02x\n", (char *)(& mouse->name), (char *)(& mouse->phys),
<              (int )error);
---
>       printk("<6>Your %s on %s reports error=0x%02x\n", mouse->name, mouse->phys,
>              error);
2406c5156
< #line 392
---
> #line 378
2408,2426c5158,5170
<          (char *)(& mouse->name), (char *)(& mouse->phys));
< #line 396
<   serio_write(mouse->serio, 83);
< #line 397
<   __ms = 50UL;
< #line 397
<   goto ldv_17034;
<   ldv_17033: 
< #line 397
<   __const_udelay(4295000UL);
<   ldv_17034: 
< #line 397
<   tmp = __ms;
< #line 397
<   __ms = __ms - 1UL;
< #line 397
<   if (tmp != 0UL) {
< #line 398
<     goto ldv_17033;
---
>          mouse->name, mouse->phys);
> #line 382
>   serio_write(mouse->serio, 'S');
> #line 383
>   if (50 <= 5) {
> #line 383
>     if (50 * 1000 > 20000) {
> #line 383
>       __bad_udelay();
>     } else {
> #line 383
>       __const_udelay((unsigned long )(50 * 1000) * 4295UL);
>     }
2427a5172,5181
> #line 383
>     __ms = 50;
> #line 383
>     while (1) {
> #line 383
>       tmp = __ms;
> #line 383
>       __ms = __ms - 1UL;
> #line 383
>       if (tmp) {
2428a5183,5195
>       } else {
> #line 383
>         break;
>       }
> #line 383
>       if (1000 > 20000) {
> #line 383
>         __bad_udelay();
>       } else {
> #line 383
>         __const_udelay(1000UL * 4295UL);
>       }
>     }
2430,2447c5197,5208
< #line 398
<   serio_write(mouse->serio, 82);
< #line 399
<   __ms___0 = 50UL;
< #line 399
<   goto ldv_17038;
<   ldv_17037: 
< #line 399
<   __const_udelay(4295000UL);
<   ldv_17038: 
< #line 399
<   tmp___0 = __ms___0;
< #line 399
<   __ms___0 = __ms___0 - 1UL;
< #line 399
<   if (tmp___0 != 0UL) {
< #line 400
<     goto ldv_17037;
---
> #line 384
>   serio_write(mouse->serio, 'R');
> #line 385
>   if (50 <= 5) {
> #line 385
>     if (50 * 1000 > 20000) {
> #line 385
>       __bad_udelay();
>     } else {
> #line 385
>       __const_udelay((unsigned long )(50 * 1000) * 4295UL);
>     }
2448a5210,5219
> #line 385
>     __ms___0 = 50;
> #line 385
>     while (1) {
> #line 385
>       tmp___0 = __ms___0;
> #line 385
>       __ms___0 = __ms___0 - 1UL;
> #line 385
>       if (tmp___0) {
2449a5221,5233
>       } else {
> #line 385
>         break;
>       }
> #line 385
>       if (1000 > 20000) {
> #line 385
>         __bad_udelay();
>       } else {
> #line 385
>         __const_udelay(1000UL * 4295UL);
>       }
>     }
2451,2453c5235,5237
< #line 400
<   serio_write(mouse->serio, 76);
< #line 401
---
> #line 386
>   serio_write(mouse->serio, 'L');
> #line 387
2457c5241
< #line 403 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 389 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2466a5251,5254
> #line 391
>   buf = mouse->buf;
> #line 397
>   while (1) {
2468,2496c5256,5258
<   buf = (unsigned char *)(& mouse->buf);
<   ldv_17049: ;
< #line 419
<   goto ldv_17046;
<   ldv_17045: 
< #line 420
<   printk("<3>%s on %s: Dropping a byte to regain sync with mouse data stream...\n",
<          (char *)(& mouse->name), (char *)(& mouse->phys));
< #line 423
<   vsxxxaa_drop_bytes(mouse, 1);
<   ldv_17046: ;
< #line 419
<   if ((unsigned int )mouse->count != 0U && (int )((signed char )*buf) >= 0) {
< #line 420
<     goto ldv_17045;
<   } else {
< 
<   }
< #line 430
<   tmp___1 = vsxxxaa_smells_like_packet(mouse, 128, 3UL);
< #line 430
<   if (tmp___1 != 0) {
< #line 432
<     stray_bytes = vsxxxaa_check_packet(mouse, 3);
< #line 433
<     if (stray_bytes == 0) {
< #line 434
<       vsxxxaa_handle_REL_packet(mouse);
<     } else {
---
>     while (1) {
> #line 405
>       if ((int )mouse->count > 0 && ! (((int )*(buf + 0) & 128) == 128)) {
2497a5260,5268
>       } else {
> #line 405
>         break;
>       }
> #line 406
>       printk("<3>%s on %s: Dropping a byte to regain sync with mouse data stream...\n",
>              mouse->name, mouse->phys);
> #line 409
>       vsxxxaa_drop_bytes(mouse, 1);
2499,2509c5270,5279
<   } else {
< #line 436
<     tmp___0 = vsxxxaa_smells_like_packet(mouse, 192, 5UL);
< #line 436
<     if (tmp___0 != 0) {
< #line 439
<       stray_bytes = vsxxxaa_check_packet(mouse, 5);
< #line 440
<       if (stray_bytes == 0) {
< #line 441
<         vsxxxaa_handle_ABS_packet(mouse);
---
> #line 416
>     tmp___1 = vsxxxaa_smells_like_packet(mouse, 128, 3);
> #line 416
>     if (tmp___1) {
> #line 418
>       stray_bytes = vsxxxaa_check_packet(mouse, 3);
> #line 419
>       if (! stray_bytes) {
> #line 420
>         vsxxxaa_handle_REL_packet(mouse);
2514,2523c5284,5293
< #line 443
<       tmp = vsxxxaa_smells_like_packet(mouse, 160, 4UL);
< #line 443
<       if (tmp != 0) {
< #line 446
<         stray_bytes = vsxxxaa_check_packet(mouse, 4);
< #line 447
<         if (stray_bytes == 0) {
< #line 448
<           vsxxxaa_handle_POR_packet(mouse);
---
> #line 422
>       tmp___0 = vsxxxaa_smells_like_packet(mouse, 192, 5);
> #line 422
>       if (tmp___0) {
> #line 425
>         stray_bytes = vsxxxaa_check_packet(mouse, 5);
> #line 426
>         if (! stray_bytes) {
> #line 427
>           vsxxxaa_handle_ABS_packet(mouse);
2528,2529c5298,5314
< #line 451
<         goto ldv_17048;
---
> #line 429
>         tmp = vsxxxaa_smells_like_packet(mouse, 160, 4);
> #line 429
>         if (tmp) {
> #line 432
>           stray_bytes = vsxxxaa_check_packet(mouse, 4);
> #line 433
>           if (! stray_bytes) {
> #line 434
>             vsxxxaa_handle_POR_packet(mouse);
>           } else {
> 
>           }
>         } else {
> #line 437
>           break;
>         }
2532,2539c5317,5323
<   }
< #line 454
<   if (stray_bytes > 0) {
< #line 455
<     printk("<3>Dropping %d bytes now...\n", stray_bytes);
< #line 457
<     vsxxxaa_drop_bytes(mouse, stray_bytes);
<   } else {
---
> #line 440
>     if (stray_bytes > 0) {
> #line 441
>       printk("<3>Dropping %d bytes now...\n", stray_bytes);
> #line 443
>       vsxxxaa_drop_bytes(mouse, stray_bytes);
>     } else {
2540a5325
>     }
2542,2545c5327
< #line 460
<   goto ldv_17049;
<   ldv_17048: ;
< #line 462
---
> #line 447
2549c5331
< #line 463 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 449 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2556c5338
< #line 466
---
> #line 452
2558,2562c5340,5344
< #line 466
<   mouse = (struct vsxxxaa *)tmp;
< #line 468
<   vsxxxaa_queue_byte(mouse, (int )data);
< #line 469
---
> #line 452
>   mouse = tmp;
> #line 454
>   vsxxxaa_queue_byte(mouse, data);
> #line 455
2564c5346
< #line 471
---
> #line 457
2568c5350
< #line 474 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 460 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2575c5357
< #line 476
---
> #line 462
2577,2579c5359,5361
< #line 476
<   mouse = (struct vsxxxaa *)tmp;
< #line 478
---
> #line 462
>   mouse = tmp;
> #line 464
2581,2583c5363,5365
< #line 479
<   serio_set_drvdata(serio, 0);
< #line 480
---
> #line 465
>   serio_set_drvdata(serio, (void *)0);
> #line 466
2585,2587c5367,5369
< #line 481
<   kfree((void const   *)mouse);
< #line 482
---
> #line 467
>   kfree(mouse);
> #line 468
2591c5373
< #line 484 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 470 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2600c5382
< #line 488
---
> #line 474
2602,2606c5384,5388
< #line 490
<   tmp = kzalloc(136UL, 208U);
< #line 490
<   mouse = (struct vsxxxaa *)tmp;
< #line 491
---
> #line 476
>   tmp = kzalloc(sizeof(struct vsxxxaa ), (16U | 64U) | 128U);
> #line 476
>   mouse = tmp;
> #line 477
2608,2610c5390,5392
< #line 492
<   if ((unsigned long )mouse == (unsigned long )((struct vsxxxaa *)0) || (unsigned long )input_dev == (unsigned long )((struct input_dev *)0)) {
< #line 493
---
> #line 478
>   if (! mouse || ! input_dev) {
> #line 479
2615c5397
< #line 495
---
> #line 481
2617c5399
< #line 496
---
> #line 482
2618a5401,5422
> #line 483
>   strlcat(mouse->name, "DEC VSXXX-AA/-GA mouse or VSXXX-AB digitizer", sizeof(mouse->name));
> #line 485
>   snprintf(mouse->phys, sizeof(mouse->phys), "%s/input0", serio->phys);
> #line 487
>   input_dev->name = mouse->name;
> #line 488
>   input_dev->phys = mouse->phys;
> #line 489
>   input_dev->id.bustype = 19;
> #line 490
>   input_dev->dev.parent = & serio->dev;
> #line 492
>   __set_bit(1, input_dev->evbit);
> #line 493
>   __set_bit(2, input_dev->evbit);
> #line 494
>   __set_bit(3, input_dev->evbit);
> #line 495
>   __set_bit(272, input_dev->keybit);
> #line 496
>   __set_bit(274, input_dev->keybit);
2620,2621c5424,5426
<   strlcat((char *)(& mouse->name), "DEC VSXXX-AA/-GA mouse or VSXXX-AB digitizer",
<           64UL);
---
>   __set_bit(273, input_dev->keybit);
> #line 498
>   __set_bit(330, input_dev->keybit);
2623c5428,5430
<   snprintf((char *)(& mouse->phys), 32UL, "%s/input0", (char *)(& serio->phys));
---
>   __set_bit(0, input_dev->relbit);
> #line 500
>   __set_bit(1, input_dev->relbit);
2625c5432
<   input_dev->name = (char const   *)(& mouse->name);
---
>   input_set_abs_params(input_dev, 0, 0, 1023, 0, 0);
2627,2629c5434
<   input_dev->phys = (char const   *)(& mouse->phys);
< #line 503
<   input_dev->id.bustype = 19U;
---
>   input_set_abs_params(input_dev, 1, 0, 1023, 0, 0);
2631c5436
<   input_dev->dev.parent = & serio->dev;
---
>   serio_set_drvdata(serio, mouse);
2633c5438
<   __set_bit(1, (unsigned long volatile   *)(& input_dev->evbit));
---
>   err = serio_open(serio, drv);
2635c5440
<   __set_bit(2, (unsigned long volatile   *)(& input_dev->evbit));
---
>   if (err) {
2637,2660d5441
<   __set_bit(3, (unsigned long volatile   *)(& input_dev->evbit));
< #line 509
<   __set_bit(272, (unsigned long volatile   *)(& input_dev->keybit));
< #line 510
<   __set_bit(274, (unsigned long volatile   *)(& input_dev->keybit));
< #line 511
<   __set_bit(273, (unsigned long volatile   *)(& input_dev->keybit));
< #line 512
<   __set_bit(330, (unsigned long volatile   *)(& input_dev->keybit));
< #line 513
<   __set_bit(0, (unsigned long volatile   *)(& input_dev->relbit));
< #line 514
<   __set_bit(1, (unsigned long volatile   *)(& input_dev->relbit));
< #line 515
<   input_set_abs_params(input_dev, 0, 0, 1023, 0, 0);
< #line 516
<   input_set_abs_params(input_dev, 1, 0, 1023, 0, 0);
< #line 518
<   serio_set_drvdata(serio, (void *)mouse);
< #line 520
<   err = serio_open(serio, drv);
< #line 521
<   if (err != 0) {
< #line 522
2665,2667c5446,5448
< #line 528
<   serio_write(serio, 84);
< #line 530
---
> #line 514
>   serio_write(serio, 'T');
> #line 516
2669,2671c5450,5452
< #line 531
<   if (err != 0) {
< #line 532
---
> #line 517
>   if (err) {
> #line 518
2676c5457
< #line 534
---
> #line 520
2679c5460
< #line 536
---
> #line 522
2682,2683c5463,5464
< #line 537
<   serio_set_drvdata(serio, 0);
---
> #line 523
>   serio_set_drvdata(serio, (void *)0);
2685c5466
< #line 538
---
> #line 524
2687,2689c5468,5470
< #line 539
<   kfree((void const   *)mouse);
< #line 540
---
> #line 525
>   kfree(mouse);
> #line 526
2693,2698c5474,5480
< #line 543 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
< static struct serio_device_id vsxxaa_serio_ids[2U]  = {      {2U, 255U, 255U, 8U}, 
<         {0U, (unsigned char)0, (unsigned char)0, (unsigned char)0}};
< #line 553 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
< struct serio_device_id  const  __mod_serio_device_table  ;
< #line 555 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 529 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
> static struct serio_device_id vsxxaa_serio_ids[2]  = {      {2, 255, 255, 8}, 
>         {0, (unsigned char)0, (unsigned char)0, (unsigned char)0}};
> #line 539
> extern struct serio_device_id  const  __mod_serio_device_table  __attribute__((__unused__,
> __alias__("vsxxaa_serio_ids"))) ;
> #line 541 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2700,2701c5482,5483
< #line 555
<      {0, (char *)"Driver for DEC VSXXX-AA and -GA mice and VSXXX-AB tablet", (struct serio_device_id *)(& vsxxaa_serio_ids),
---
> #line 541
>      {0, "Driver for DEC VSXXX-AA and -GA mice and VSXXX-AB tablet", vsxxaa_serio_ids,
2704c5486,5488
< #line 566 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 552
> static int vsxxxaa_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
> #line 552 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2710c5494
< #line 568
---
> #line 554
2712c5496
< #line 568
---
> #line 554
2716c5500,5502
< #line 571 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 557
> static void vsxxxaa_exit(void)  __attribute__((__section__(".exit.text"))) ;
> #line 557 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2722c5508
< #line 573
---
> #line 559
2724c5510
< #line 574
---
> #line 560
2728,2732c5514,5542
< #line 596
< extern void ldv_check_final_state(void) ;
< #line 599
< extern void ldv_check_return_value(int  ) ;
< #line 605
---
> #line 562 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
> int init_module(void) 
> { 
>   int tmp ;
> 
>   {
> #line 562
>   tmp = vsxxxaa_init();
> #line 562
>   return (tmp);
> }
> }
> #line 563 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
> void cleanup_module(void) 
> { 
> 
> 
>   {
> #line 563
>   vsxxxaa_exit();
> #line 563
>   return;
> }
> }
> #line 582
> void ldv_check_final_state(void) ;
> #line 585
> extern void ldv_check_return_value(int res ) ;
> #line 591
2734c5544
< #line 608
---
> #line 594
2736c5546
< #line 611
---
> #line 597
2738c5548
< #line 614 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 600 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2740c5550,5552
< #line 617 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
---
> #line 636 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
> static int res_vsxxxaa_connect_11  ;
> #line 603 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/input/mouse/vsxxxaa.c"
2745d5556
<   int res_vsxxxaa_connect_11 ;
2748d5558
<   int ldv_s_vsxxxaa_drv_serio_driver ;
2749a5560
>   int ldv_s_vsxxxaa_drv_serio_driver ;
2754,2756c5565
< #line 741
<   ldv_s_vsxxxaa_drv_serio_driver = 0;
< #line 704
---
> #line 690
2758c5567
< #line 713
---
> #line 699
2760c5569
< #line 738
---
> #line 724
2762c5571
< #line 739
---
> #line 725
2764,2766c5573,5575
< #line 739
<   if (tmp != 0) {
< #line 740
---
> #line 725
>   if (tmp) {
> #line 726
2771,2791c5580,5587
< #line 745
<   goto ldv_17119;
<   ldv_17118: 
< #line 749
<   tmp___0 = nondet_int();
< #line 749
<   switch (tmp___0) {
<   case 0: ;
< #line 754
<   if (ldv_s_vsxxxaa_drv_serio_driver == 0) {
< #line 778
<     ldv_handler_precall();
< #line 779
<     res_vsxxxaa_connect_11 = vsxxxaa_connect(var_group1, var_group2);
< #line 780
<     ldv_check_return_value(res_vsxxxaa_connect_11);
< #line 781
<     if (res_vsxxxaa_connect_11 != 0) {
< #line 782
<       goto ldv_module_exit;
<     } else {
---
> #line 727
>   ldv_s_vsxxxaa_drv_serio_driver = 0;
> #line 731
>   while (1) {
> #line 731
>     tmp___1 = nondet_int();
> #line 731
>     if (tmp___1 || ! (ldv_s_vsxxxaa_drv_serio_driver == 0)) {
2792a5589,5591
>     } else {
> #line 731
>       break;
2794,2796c5593,5610
< #line 783
<     ldv_s_vsxxxaa_drv_serio_driver = ldv_s_vsxxxaa_drv_serio_driver + 1;
<   } else {
---
> #line 735
>     tmp___0 = nondet_int();
> #line 735
>     switch (tmp___0) {
>     case 0: 
> #line 740
>     if (ldv_s_vsxxxaa_drv_serio_driver == 0) {
> #line 764
>       ldv_handler_precall();
> #line 765
>       res_vsxxxaa_connect_11 = vsxxxaa_connect(var_group1, var_group2);
> #line 766
>       ldv_check_return_value(res_vsxxxaa_connect_11);
> #line 767
>       if (res_vsxxxaa_connect_11) {
> #line 768
>         goto ldv_module_exit;
>       } else {
2798,2810c5612,5615
<   }
< #line 789
<   goto ldv_17114;
<   case 1: ;
< #line 793
<   if (ldv_s_vsxxxaa_drv_serio_driver == 1) {
< #line 817
<     ldv_handler_precall();
< #line 818
<     vsxxxaa_disconnect(var_group1);
< #line 819
<     ldv_s_vsxxxaa_drv_serio_driver = 0;
<   } else {
---
>       }
> #line 769
>       ldv_s_vsxxxaa_drv_serio_driver = ldv_s_vsxxxaa_drv_serio_driver + 1;
>     } else {
2812,2834c5617,5629
<   }
< #line 825
<   goto ldv_17114;
<   case 2: 
< #line 853
<   ldv_handler_precall();
< #line 854
<   vsxxxaa_interrupt(var_group1, (int )var_vsxxxaa_interrupt_9_p1, var_vsxxxaa_interrupt_9_p2);
< #line 861
<   goto ldv_17114;
<   default: ;
< #line 862
<   goto ldv_17114;
<   }
<   ldv_17114: ;
<   ldv_17119: 
< #line 745
<   tmp___1 = nondet_int();
< #line 745
<   if (tmp___1 != 0 || ldv_s_vsxxxaa_drv_serio_driver != 0) {
< #line 747
<     goto ldv_17118;
<   } else {
---
>     }
> #line 775
>     break;
>     case 1: 
> #line 779
>     if (ldv_s_vsxxxaa_drv_serio_driver == 1) {
> #line 803
>       ldv_handler_precall();
> #line 804
>       vsxxxaa_disconnect(var_group1);
> #line 805
>       ldv_s_vsxxxaa_drv_serio_driver = 0;
>     } else {
2835a5631,5644
>     }
> #line 811
>     break;
>     case 2: 
> #line 839
>     ldv_handler_precall();
> #line 840
>     vsxxxaa_interrupt(var_group1, var_vsxxxaa_interrupt_9_p1, var_vsxxxaa_interrupt_9_p2);
> #line 847
>     break;
>     default: 
> #line 848
>     break;
>     }
2837d5645
< 
2839c5647
< #line 893
---
> #line 879
2841c5649
< #line 894
---
> #line 880
2844c5652
< #line 897
---
> #line 883
2846c5654
< #line 900
---
> #line 886
2850,2879c5658,5663
< #line 915 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
< unsigned long ldv___get_free_pages_2(gfp_t ldv_func_arg1 , unsigned int ldv_func_arg2 ) 
< { 
<   unsigned long tmp ;
< 
<   {
< #line 921
<   ldv_check_alloc_flags(ldv_func_arg1);
< #line 923
<   tmp = __get_free_pages(ldv_func_arg1, ldv_func_arg2);
< #line 923
<   return (tmp);
< }
< }
< #line 970 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
< void *ldv_kmem_cache_alloc_7(struct kmem_cache *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
< { 
< 
< 
<   {
< #line 976
<   ldv_check_alloc_flags(ldv_func_arg2);
< #line 978
<   kmem_cache_alloc(ldv_func_arg1, ldv_func_arg2);
< #line 979
<   return ((void *)0);
< }
< }
< #line 981 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/43_1a/drivers/input/mouse/vsxxxaa.c.prepared"
< __inline static void *kzalloc(size_t size , gfp_t flags ) 
---
> #line 1334 "include/linux/usb.h"
> struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags ) ;
> #line 1335
> void usb_free_urb(struct urb *urb ) ;
> #line 10 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
> __inline static void ldv_error(void) 
2884,2887c5668,5670
< #line 987
<   ldv_check_alloc_flags(flags);
< #line 988
<   return ((void *)0);
---
>   LDV_ERROR: reach_error();
> #line 12
>   goto LDV_ERROR;
2890,2893c5673,5674
< #line 1 "<compiler builtins>"
< long __builtin_expect(long exp , long c ) ;
< #line 10 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
< __inline static void ldv_error(void) 
---
> #line 20 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
> __inline static void ldv_stop(void) 
2898,2900c5679,5681
<   LDV_ERROR: reach_error();
< #line 12
<   goto LDV_ERROR;
---
>   LDV_STOP: 
> #line 21
>   goto LDV_STOP;
2903,2904c5684,5685
< #line 25
< extern int ldv_undef_int(void) ;
---
> #line 26
> extern void *ldv_undef_ptr(void) ;
2915,2918c5696,5702
< #line 21 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/43_1a/common-model/ldv_common_model.c"
< int ldv_spin  =    LDV_SPIN_UNLOCKED;
< #line 25 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/43_1a/common-model/ldv_common_model.c"
< void ldv_check_alloc_flags(gfp_t flags ) 
---
> #line 12 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/68_1/common-model/ldv_common_model.c"
> int ldv_urb_state  =    0;
> #line 14 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/68_1/common-model/ldv_common_model.c"
> int ldv_coherent_state  =    0;
> #line 45 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/68_1/common-model/ldv_common_model.c"
> void *usb_alloc_coherent(struct usb_device *dev , size_t size , gfp_t mem_flags ,
>                          dma_addr_t *dma ) 
2920c5704,5705
< 
---
>   void *arbitrary_memory ;
>   void *tmp ;
2923,2924c5708,5718
< #line 28
<   if (ldv_spin == LDV_SPIN_UNLOCKED || flags == 32U) {
---
> #line 47
>   while (1) {
> #line 47
>     tmp = ldv_undef_ptr();
> #line 47
>     arbitrary_memory = tmp;
> #line 47
>     if (! arbitrary_memory) {
> #line 47
>       return ((void *)0);
>     } else {
2926,2928c5720,5726
<   } else {
< #line 28
<     ldv_error();
---
>     }
> #line 47
>     ldv_coherent_state = ldv_coherent_state + 1;
> #line 47
>     return (arbitrary_memory);
> #line 47
>     break;
2930,2931c5728,5729
< #line 29
<   return;
---
> #line 48
>   return ((void *)0);
2934,2937c5732,5733
< #line 31
< extern struct page *ldv_some_page(void) ;
< #line 34 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/43_1a/common-model/ldv_common_model.c"
< struct page *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
---
> #line 51 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/68_1/common-model/ldv_common_model.c"
> void usb_free_coherent(struct usb_device *dev , size_t size , void *addr , dma_addr_t dma ) 
2939c5735
<   struct page *tmp ;
---
> 
2942,2943c5738,5741
< #line 37
<   if (ldv_spin == LDV_SPIN_UNLOCKED || flags == 32U) {
---
> #line 53
>   while (1) {
> #line 53
>     if ((unsigned long )addr != (unsigned long )((void *)0)) {
2945,2947c5743,5762
<   } else {
< #line 37
<     ldv_error();
---
>     } else {
> #line 53
>       ldv_stop();
>     }
> #line 53
>     if (addr) {
> #line 53
>       if (ldv_coherent_state >= 1) {
> 
>       } else {
> #line 53
>         ldv_error();
>       }
> #line 53
>       ldv_coherent_state = ldv_coherent_state - 1;
>     } else {
> 
>     }
> #line 53
>     break;
2949,2952c5764,5765
< #line 39
<   tmp = ldv_some_page();
< #line 39
<   return (tmp);
---
> #line 54
>   return;
2955,2956c5768,5769
< #line 43 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/43_1a/common-model/ldv_common_model.c"
< void ldv_check_alloc_nonatomic(void) 
---
> #line 57 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/68_1/common-model/ldv_common_model.c"
> struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags ) 
2958c5771,5772
< 
---
>   void *arbitrary_memory ;
>   void *tmp ;
2961,2962c5775,5785
< #line 46
<   if (ldv_spin == LDV_SPIN_UNLOCKED) {
---
> #line 58
>   while (1) {
> #line 58
>     tmp = ldv_undef_ptr();
> #line 58
>     arbitrary_memory = tmp;
> #line 58
>     if (! arbitrary_memory) {
> #line 58
>       return ((void *)0);
>     } else {
2964,2966c5787,5793
<   } else {
< #line 46
<     ldv_error();
---
>     }
> #line 58
>     ldv_urb_state = ldv_urb_state + 1;
> #line 58
>     return (arbitrary_memory);
> #line 58
>     break;
2968,2969c5795,5796
< #line 47
<   return;
---
> #line 59
>   return ((struct urb *)0);
2972,2973c5799,5800
< #line 50 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/43_1a/common-model/ldv_common_model.c"
< void ldv_spin_lock(void) 
---
> #line 62 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/68_1/common-model/ldv_common_model.c"
> void usb_free_urb(struct urb *urb ) 
2978,2986c5805,5808
< #line 53
<   ldv_spin = LDV_SPIN_LOCKED;
< #line 54
<   return;
< }
< }
< #line 57 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/43_1a/common-model/ldv_common_model.c"
< void ldv_spin_unlock(void) 
< { 
---
> #line 63
>   while (1) {
> #line 63
>     if ((unsigned long )urb != (unsigned long )((struct urb *)0)) {
2987a5810,5817
>     } else {
> #line 63
>       ldv_stop();
>     }
> #line 63
>     if (urb) {
> #line 63
>       if (ldv_urb_state >= 1) {
2989,2992c5819,5831
<   {
< #line 60
<   ldv_spin = LDV_SPIN_UNLOCKED;
< #line 61
---
>       } else {
> #line 63
>         ldv_error();
>       }
> #line 63
>       ldv_urb_state = ldv_urb_state - 1;
>     } else {
> 
>     }
> #line 63
>     break;
>   }
> #line 64
2996,2997c5835,5836
< #line 64 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--43_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/43_1a/common-model/ldv_common_model.c"
< int ldv_spin_trylock(void) 
---
> #line 67 "/work/ldvuser/novikov/work/current--X--drivers/input/mouse/vsxxxaa.ko--X--defaultlinux--X--68_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/68_1/common-model/ldv_common_model.c"
> void ldv_check_final_state(void) 
2999c5838
<   int is_lock ;
---
> 
3003c5842,5847
<   is_lock = ldv_undef_int();
---
>   if (ldv_urb_state == 0) {
> 
>   } else {
> #line 69
>     ldv_error();
>   }
3005,3007c5849,5850
<   if (is_lock) {
< #line 74
<     return (0);
---
>   if (ldv_coherent_state == 0) {
> 
3009,3012c5852,5853
< #line 79
<     ldv_spin = LDV_SPIN_LOCKED;
< #line 81
<     return (1);
---
> #line 71
>     ldv_error();
3013a5855,5856
> #line 72
>   return;
