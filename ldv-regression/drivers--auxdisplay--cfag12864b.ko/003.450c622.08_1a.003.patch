30c30
< #line 23 "include/linux/types.h"
---
> #line 26 "include/linux/types.h"
32c32
< #line 31 "include/linux/types.h"
---
> #line 34 "include/linux/types.h"
34c34,36
< #line 59 "include/linux/types.h"
---
> #line 37 "include/linux/types.h"
> typedef _Bool bool;
> #line 62 "include/linux/types.h"
36c38
< #line 64 "include/linux/types.h"
---
> #line 67 "include/linux/types.h"
38c40
< #line 179 "include/linux/types.h"
---
> #line 201 "include/linux/types.h"
40c42
< #line 192 "include/linux/types.h"
---
> #line 214 "include/linux/types.h"
42c44
<    int volatile   counter ;
---
>    int counter ;
44c46
< #line 192 "include/linux/types.h"
---
> #line 214 "include/linux/types.h"
46c48
< #line 197 "include/linux/types.h"
---
> #line 219 "include/linux/types.h"
48c50
<    long volatile   counter ;
---
>    long counter ;
50c52
< #line 197 "include/linux/types.h"
---
> #line 219 "include/linux/types.h"
52c54,59
< #line 206
---
> #line 220 "include/linux/types.h"
> struct list_head {
>    struct list_head *next ;
>    struct list_head *prev ;
> };
> #line 240
54c61
< #line 54 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/page_types.h"
---
> #line 59 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/page_types.h"
78c85
< #line 138 "include/linux/init.h"
---
> #line 145 "include/linux/init.h"
80c87
< #line 59 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/alternative.h"
---
> #line 22 "include/linux/bitops.h"
82c89
< #line 44 "include/linux/dynamic_debug.h"
---
> #line 50 "include/linux/dynamic_debug.h"
89c96
< #line 277 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/pgtable_types.h"
---
> #line 280 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/pgtable_types.h"
91c98
< #line 315 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/paravirt_types.h"
---
> #line 320 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/paravirt_types.h"
93c100
< #line 301 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/ds.h"
---
> #line 271 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/msr.h"
112c119
< #line 424 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
---
> #line 421 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
114c121
< #line 629 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
---
> #line 622 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
118c125
< #line 629 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
---
> #line 622 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/processor.h"
120,124d126
< #line 56 "include/linux/prefetch.h"
< struct list_head {
<    struct list_head *next ;
<    struct list_head *prev ;
< };
130,137c132
< struct __anonstruct_ldv_5158_26 {
<    unsigned long arg0 ;
<    unsigned long arg1 ;
<    unsigned long arg2 ;
<    unsigned long arg3 ;
< };
< #line 114 "/work/ldvuser/novikov/inst/current/envs/linux/linux/arch/x86/include/asm/stat.h"
< struct __anonstruct_futex_27 {
---
> struct __anonstruct_futex_26 {
146c141
< struct __anonstruct_nanosleep_28 {
---
> struct __anonstruct_nanosleep_27 {
155c150
< struct __anonstruct_poll_29 {
---
> struct __anonstruct_poll_28 {
163,167c158,161
< union __anonunion_ldv_5181_25 {
<    struct __anonstruct_ldv_5158_26 ldv_5158 ;
<    struct __anonstruct_futex_27 futex ;
<    struct __anonstruct_nanosleep_28 nanosleep ;
<    struct __anonstruct_poll_29 poll ;
---
> union __anonunion_ldv_5373_25 {
>    struct __anonstruct_futex_26 futex ;
>    struct __anonstruct_nanosleep_27 nanosleep ;
>    struct __anonstruct_poll_28 poll ;
172c166
<    union __anonunion_ldv_5181_25 ldv_5181 ;
---
>    union __anonunion_ldv_5373_25 ldv_5373 ;
197c191
< #line 56 "include/linux/debug_locks.h"
---
> #line 55 "include/linux/debug_locks.h"
204c198
< #line 24 "include/linux/stacktrace.h"
---
> #line 26 "include/linux/stacktrace.h"
208c202
< #line 42 "include/linux/lockdep.h"
---
> #line 53 "include/linux/lockdep.h"
212c206
< #line 46 "include/linux/lockdep.h"
---
> #line 59 "include/linux/lockdep.h"
230c224
< #line 131 "include/linux/lockdep.h"
---
> #line 144 "include/linux/lockdep.h"
233c227
<    struct lock_class *class_cache ;
---
>    struct lock_class *class_cache[2U] ;
238c232
< #line 543 "include/linux/lockdep.h"
---
> #line 549 "include/linux/lockdep.h"
247c241
< struct __anonstruct_ldv_5734_32 {
---
> struct __anonstruct_ldv_5955_31 {
252c246
< union __anonunion_ldv_5735_31 {
---
> union __anonunion_ldv_5956_30 {
254c248
<    struct __anonstruct_ldv_5734_32 ldv_5734 ;
---
>    struct __anonstruct_ldv_5955_31 ldv_5955 ;
258c252
<    union __anonunion_ldv_5735_31 ldv_5735 ;
---
>    union __anonunion_ldv_5956_30 ldv_5956 ;
262c256
< #line 169 "include/linux/seqlock.h"
---
> #line 235 "include/linux/seqlock.h"
267c261
< #line 632 "include/linux/mmzone.h"
---
> #line 645 "include/linux/mmzone.h"
277c271
< #line 85 "include/linux/debugobjects.h"
---
> #line 99 "include/linux/debugobjects.h"
279c273
< #line 86 "include/linux/debugobjects.h"
---
> #line 100 "include/linux/debugobjects.h"
282a277
>    struct tvec_base *base ;
285c280,281
<    struct tvec_base *base ;
---
>    int slack ;
>    int start_pid ;
288d283
<    int start_pid ;
291c286
< #line 252 "include/linux/timer.h"
---
> #line 301 "include/linux/timer.h"
293c288
< #line 253
---
> #line 302
295c290
< #line 18 "include/linux/workqueue.h"
---
> #line 45 "include/linux/workqueue.h"
302c297
< #line 36 "include/linux/workqueue.h"
---
> #line 86 "include/linux/workqueue.h"
326c321,323
< #line 442
---
> #line 443
> struct sock;
> #line 444
328c325,338
< #line 443 "include/linux/elf.h"
---
> #line 445
> enum kobj_ns_type {
>     KOBJ_NS_TYPE_NONE = 0,
>     KOBJ_NS_TYPE_NET = 1,
>     KOBJ_NS_TYPES = 2
> } ;
> #line 451 "include/linux/elf.h"
> struct kobj_ns_type_operations {
>    enum kobj_ns_type type ;
>    void const   *(*current_ns)(void) ;
>    void const   *(*netlink_ns)(struct sock * ) ;
>    void const   *(*initial_ns)(void) ;
> };
> #line 55 "include/linux/kobject_ns.h"
331d340
<    struct module *owner ;
336c345
< #line 101 "include/linux/sysfs.h"
---
> #line 98 "include/linux/sysfs.h"
341c350
< #line 119
---
> #line 116
343c352
< #line 176 "include/linux/sysfs.h"
---
> #line 185 "include/linux/sysfs.h"
347c356
< #line 48 "include/linux/kobject.h"
---
> #line 49 "include/linux/kobject.h"
349c358
< #line 48
---
> #line 49
351c360
< #line 48 "include/linux/kobject.h"
---
> #line 49 "include/linux/kobject.h"
366c375
< #line 106 "include/linux/kobject.h"
---
> #line 109 "include/linux/kobject.h"
370a380,381
>    struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
>    void const   *(*namespace)(struct kobject * ) ;
372c383
< #line 112 "include/linux/kobject.h"
---
> #line 117 "include/linux/kobject.h"
379c390
< #line 119 "include/linux/kobject.h"
---
> #line 124 "include/linux/kobject.h"
385c396
< #line 136 "include/linux/kobject.h"
---
> #line 141 "include/linux/kobject.h"
392c403
< #line 210
---
> #line 219
394c405,411
< #line 38 "include/linux/moduleparam.h"
---
> #line 220 "include/linux/kobject.h"
> struct kernel_param_ops {
>    int (*set)(char const   * , struct kernel_param  const  * ) ;
>    int (*get)(char * , struct kernel_param  const  * ) ;
>    void (*free)(void * ) ;
> };
> #line 44 "include/linux/moduleparam.h"
396c413
< #line 38
---
> #line 44
398,399c415,416
< #line 38 "include/linux/moduleparam.h"
< union __anonunion_ldv_10604_110 {
---
> #line 44 "include/linux/moduleparam.h"
> union __anonunion_ldv_11805_124 {
404c421
< #line 38 "include/linux/moduleparam.h"
---
> #line 44 "include/linux/moduleparam.h"
406a424
>    struct kernel_param_ops  const  *ops ;
409,411c427
<    int (*set)(char const   * , struct kernel_param * ) ;
<    int (*get)(char * , struct kernel_param * ) ;
<    union __anonunion_ldv_10604_110 ldv_10604 ;
---
>    union __anonunion_ldv_11805_124 ldv_11805 ;
413c429
< #line 54 "include/linux/moduleparam.h"
---
> #line 59 "include/linux/moduleparam.h"
418c434
< #line 60 "include/linux/moduleparam.h"
---
> #line 65 "include/linux/moduleparam.h"
422,423c438
<    int (*set)(char const   * , struct kernel_param * ) ;
<    int (*get)(char * , struct kernel_param * ) ;
---
>    struct kernel_param_ops  const  *ops ;
427c442
< #line 455 "include/linux/rcupdate.h"
---
> #line 778 "include/linux/rcupdate.h"
429c444,449
< #line 456 "include/linux/rcupdate.h"
---
> #line 779 "include/linux/rcupdate.h"
> struct tracepoint_func {
>    void *func ;
>    void *data ;
> };
> #line 29 "include/linux/tracepoint.h"
435,478c455
<    void **funcs ;
< };
< #line 117 "include/linux/kmemleak.h"
< struct kmem_cache_cpu {
<    void **freelist ;
<    struct page *page ;
<    int node ;
<    unsigned int stat[18U] ;
< };
< #line 44 "include/linux/slub_def.h"
< struct kmem_cache_node {
<    spinlock_t list_lock ;
<    unsigned long nr_partial ;
<    struct list_head partial ;
<    atomic_long_t nr_slabs ;
<    atomic_long_t total_objects ;
<    struct list_head full ;
< };
< #line 55 "include/linux/slub_def.h"
< struct kmem_cache_order_objects {
<    unsigned long x ;
< };
< #line 65 "include/linux/slub_def.h"
< struct kmem_cache {
<    struct kmem_cache_cpu *cpu_slab ;
<    unsigned long flags ;
<    int size ;
<    int objsize ;
<    int offset ;
<    struct kmem_cache_order_objects oo ;
<    struct kmem_cache_node local_node ;
<    struct kmem_cache_order_objects max ;
<    struct kmem_cache_order_objects min ;
<    gfp_t allocflags ;
<    int refcount ;
<    void (*ctor)(void * ) ;
<    int inuse ;
<    int align ;
<    unsigned long min_partial ;
<    char const   *name ;
<    struct list_head list ;
<    struct kobject kobj ;
<    int remote_node_defrag_ratio ;
<    struct kmem_cache_node *node[512U] ;
---
>    struct tracepoint_func *funcs ;
480c457
< #line 243 "include/linux/percpu.h"
---
> #line 84 "include/linux/tracepoint.h"
484c461
< #line 92 "include/trace/events/module.h"
---
> #line 127 "include/trace/events/module.h"
499c476
< #line 60
---
> #line 66
501c478
< #line 60 "include/linux/module.h"
---
> #line 66 "include/linux/module.h"
508c485
< #line 72
---
> #line 78
510c487
< #line 182
---
> #line 217
516c493
< #line 188 "include/linux/module.h"
---
> #line 223 "include/linux/module.h"
518c495,496
<    int count ;
---
>    unsigned int incs ;
>    unsigned int decs ;
520c498
< #line 370
---
> #line 416
522c500
< #line 370
---
> #line 416
524c502
< #line 370
---
> #line 416
526c504
< #line 370 "include/linux/module.h"
---
> #line 416 "include/linux/module.h"
561a540,541
>    unsigned int init_ro_size ;
>    unsigned int core_ro_size ;
575a556
>    unsigned int percpu_size ;
577c558
<    struct tracepoint *tracepoints ;
---
>    struct tracepoint * const  *tracepoints_ptrs ;
581c562
<    struct ftrace_event_call *trace_events ;
---
>    struct ftrace_event_call **trace_events ;
585c566,567
<    struct list_head modules_which_use_me ;
---
>    struct list_head source_list ;
>    struct list_head target_list ;
592c574,618
< #line 627 "include/linux/device.h"
---
> #line 118 "include/linux/kmemleak.h"
> struct kmem_cache_cpu {
>    void **freelist ;
>    unsigned long tid ;
>    struct page *page ;
>    int node ;
>    unsigned int stat[19U] ;
> };
> #line 48 "include/linux/slub_def.h"
> struct kmem_cache_node {
>    spinlock_t list_lock ;
>    unsigned long nr_partial ;
>    struct list_head partial ;
>    atomic_long_t nr_slabs ;
>    atomic_long_t total_objects ;
>    struct list_head full ;
> };
> #line 59 "include/linux/slub_def.h"
> struct kmem_cache_order_objects {
>    unsigned long x ;
> };
> #line 69 "include/linux/slub_def.h"
> struct kmem_cache {
>    struct kmem_cache_cpu *cpu_slab ;
>    unsigned long flags ;
>    unsigned long min_partial ;
>    int size ;
>    int objsize ;
>    int offset ;
>    struct kmem_cache_order_objects oo ;
>    struct kmem_cache_order_objects max ;
>    struct kmem_cache_order_objects min ;
>    gfp_t allocflags ;
>    int refcount ;
>    void (*ctor)(void * ) ;
>    int inuse ;
>    int align ;
>    int reserved ;
>    char const   *name ;
>    struct list_head list ;
>    struct kobject kobj ;
>    int remote_node_defrag_ratio ;
>    struct kmem_cache_node *node[1024U] ;
> };
> #line 760 "include/linux/device.h"
599,600d624
< #line 1
< long __builtin_expect(long exp , long c ) ;
608c632
<   __asm__  volatile   (".section .smp_locks,\"a\"\n .balign 8 \n .quad 661f\n.previous\n661:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
---
>   __asm__  volatile   (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
613c637
< #line 251 "include/linux/kernel.h"
---
> #line 99 "include/linux/printk.h"
619,650c643
< #line 9 "include/asm-generic/getorder.h"
< __inline static int get_order(unsigned long size ) 
< { 
<   int order ;
< 
<   {
< #line 13
<   size = (size - 1UL) >> 11;
< #line 14
<   order = -1;
<   ldv_4329: 
< #line 16
<   size = size >> 1;
< #line 17
<   order = order + 1;
< #line 18
<   if (size != 0UL) {
< #line 19
<     goto ldv_4329;
<   } else {
< 
<   }
< 
< #line 19
<   return (order);
< }
< }
< #line 10 "include/linux/debug_locks.h"
< extern int debug_locks ;
< #line 542 "include/linux/lockdep.h"
< extern void lockdep_rcu_dereference(char const   * , int const    ) ;
< #line 126 "include/linux/mutex.h"
---
> #line 134 "include/linux/mutex.h"
652c645
< #line 152
---
> #line 160
654c647
< #line 30 "include/linux/timer.h"
---
> #line 36 "include/linux/timer.h"
656c649
< #line 230
---
> #line 280
658,662c651,655
< #line 184 "include/linux/workqueue.h"
< extern struct workqueue_struct *__create_workqueue_key(char const   * , int  , int  ,
<                                                        int  , struct lock_class_key * ,
<                                                        char const   * ) ;
< #line 214
---
> #line 300 "include/linux/workqueue.h"
> extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
>                                                       int  , struct lock_class_key * ,
>                                                       char const   * ) ;
> #line 347
664c657
< #line 219
---
> #line 352
667c660
< #line 224
---
> #line 357
669,670c662,663
< #line 250 "include/linux/workqueue.h"
< __inline static int cancel_delayed_work(struct delayed_work *work ) 
---
> #line 390 "include/linux/workqueue.h"
> __inline static bool cancel_delayed_work(struct delayed_work *work ) 
672c665,666
<   int ret ;
---
>   bool ret ;
>   int tmp ;
675,679c669,675
< #line 254
<   ret = del_timer_sync(& work->timer);
< #line 255
<   if (ret != 0) {
< #line 256
---
> #line 394
>   tmp = del_timer_sync(& work->timer);
> #line 394
>   ret = tmp != 0;
> #line 395
>   if ((int )ret) {
> #line 396
684c680
< #line 257
---
> #line 397
688,690c684
< #line 316 "include/linux/gfp.h"
< extern unsigned long __get_free_pages(gfp_t  , unsigned int  ) ;
< #line 317
---
> #line 352 "include/linux/gfp.h"
692c686
< #line 329
---
> #line 364
694,746c688
< #line 69 "include/linux/rcupdate.h"
< extern int rcu_scheduler_active ;
< #line 104 "include/linux/rcupdate.h"
< __inline static int debug_lockdep_rcu_enabled(void) 
< { 
<   long tmp ;
<   long tmp___0 ;
<   int tmp___1 ;
< 
<   {
< #line 106
<   tmp = __builtin_expect(rcu_scheduler_active != 0, 1L);
< #line 106
<   if (tmp != 0L) {
< #line 106
<     tmp___0 = __builtin_expect(debug_locks != 0, 1L);
< #line 106
<     if (tmp___0 != 0L) {
< #line 106
<       tmp___1 = 1;
<     } else {
< #line 106
<       tmp___1 = 0;
<     }
<   } else {
< #line 106
<     tmp___1 = 0;
<   }
< #line 106
<   return (tmp___1);
< }
< }
< #line 155 "include/linux/rcupdate.h"
< __inline static int rcu_read_lock_sched_held(void) 
< { 
< 
< 
<   {
< #line 157
<   return (1);
< }
< }
< #line 323 "include/linux/rcupdate.h"
< __inline static void rcu_read_lock_sched_notrace(void) 
< { 
< 
< 
<   {
< #line 327
<   return;
< }
< }
< #line 143 "include/linux/slab.h"
---
> #line 141 "include/linux/slab.h"
748,1024c690
< #line 87 "include/trace/events/kmem.h"
< extern struct tracepoint __tracepoint_kmalloc ;
< #line 87 "include/trace/events/kmem.h"
< __inline static void trace_kmalloc(unsigned long call_site , void const   *ptr , size_t bytes_req ,
<                                    size_t bytes_alloc , gfp_t gfp_flags ) 
< { 
<   void **it_func ;
<   int tmp ;
<   int tmp___0 ;
<   void **_________p1 ;
<   long tmp___1 ;
< 
<   {
< #line 81
<   tmp___1 = __builtin_expect(__tracepoint_kmalloc.state != 0, 0L);
< #line 81
<   if (tmp___1 != 0L) {
< #line 81
<     rcu_read_lock_sched_notrace();
< #line 81
<     tmp = debug_lockdep_rcu_enabled();
< #line 81
<     if (tmp != 0) {
< #line 81
<       tmp___0 = rcu_read_lock_sched_held();
< #line 81
<       if (tmp___0 == 0) {
< #line 81
<         lockdep_rcu_dereference("include/trace/events/kmem.h", 87);
<       } else {
< 
<       }
<     } else {
< 
<     }
< #line 81
<     _________p1 = *((void ** volatile  *)(& __tracepoint_kmalloc.funcs));
< #line 81
<     it_func = _________p1;
< #line 81
<     if ((unsigned long )it_func != (unsigned long )((void **)0)) {
<       ldv_10944: 
< #line 81
<       (*((void (*)(unsigned long  , void const   * , size_t  , size_t  , gfp_t  ))*it_func))(call_site,
<                                                                                              ptr,
<                                                                                              bytes_req,
<                                                                                              bytes_alloc,
<                                                                                              gfp_flags);
< #line 81
<       it_func = it_func + 1;
< #line 81
<       if ((unsigned long )*it_func != (unsigned long )((void *)0)) {
< #line 82
<         goto ldv_10944;
<       } else {
< 
<       }
< 
<     } else {
< 
<     }
< #line 81
<     rcu_read_lock_sched_notrace();
<   } else {
< 
<   }
< #line 83
<   return;
< }
< }
< #line 62 "include/linux/kmemleak.h"
< __inline static void kmemleak_alloc(void const   *ptr , size_t size , int min_count ,
<                                     gfp_t gfp ) 
< { 
< 
< 
<   {
< #line 64
<   return;
< }
< }
< #line 146 "include/linux/slub_def.h"
< extern struct kmem_cache kmalloc_caches[22U] ;
< #line 152 "include/linux/slub_def.h"
< __inline static int kmalloc_index(size_t size ) 
< { 
< 
< 
<   {
< #line 154
<   if (size == 0UL) {
< #line 155
<     return (0);
<   } else {
< 
<   }
< #line 157
<   if (size <= 8UL) {
< #line 158
<     return (3);
<   } else {
< 
<   }
< #line 160
<   if (size > 64UL && size <= 96UL) {
< #line 161
<     return (1);
<   } else {
< 
<   }
< #line 162
<   if (size > 128UL && size <= 192UL) {
< #line 163
<     return (2);
<   } else {
< 
<   }
< #line 164
<   if (size <= 8UL) {
< #line 164
<     return (3);
<   } else {
< 
<   }
< #line 165
<   if (size <= 16UL) {
< #line 165
<     return (4);
<   } else {
< 
<   }
< #line 166
<   if (size <= 32UL) {
< #line 166
<     return (5);
<   } else {
< 
<   }
< #line 167
<   if (size <= 64UL) {
< #line 167
<     return (6);
<   } else {
< 
<   }
< #line 168
<   if (size <= 128UL) {
< #line 168
<     return (7);
<   } else {
< 
<   }
< #line 169
<   if (size <= 256UL) {
< #line 169
<     return (8);
<   } else {
< 
<   }
< #line 170
<   if (size <= 512UL) {
< #line 170
<     return (9);
<   } else {
< 
<   }
< #line 171
<   if (size <= 1024UL) {
< #line 171
<     return (10);
<   } else {
< 
<   }
< #line 172
<   if (size <= 2048UL) {
< #line 172
<     return (11);
<   } else {
< 
<   }
< #line 173
<   if (size <= 4096UL) {
< #line 173
<     return (12);
<   } else {
< 
<   }
< #line 178
<   if (size <= 8192UL) {
< #line 178
<     return (13);
<   } else {
< 
<   }
< #line 179
<   if (size <= 16384UL) {
< #line 179
<     return (14);
<   } else {
< 
<   }
< #line 180
<   if (size <= 32768UL) {
< #line 180
<     return (15);
<   } else {
< 
<   }
< #line 181
<   if (size <= 65536UL) {
< #line 181
<     return (16);
<   } else {
< 
<   }
< #line 182
<   if (size <= 131072UL) {
< #line 182
<     return (17);
<   } else {
< 
<   }
< #line 183
<   if (size <= 262144UL) {
< #line 183
<     return (18);
<   } else {
< 
<   }
< #line 184
<   if (size <= 524288UL) {
< #line 184
<     return (19);
<   } else {
< 
<   }
< #line 185
<   if (size <= 1048576UL) {
< #line 185
<     return (20);
<   } else {
< 
<   }
< #line 186
<   if (size <= 2097152UL) {
< #line 186
<     return (21);
<   } else {
< 
<   }
< #line 187
<   return (-1);
< }
< }
< #line 204 "include/linux/slub_def.h"
< __inline static struct kmem_cache *kmalloc_slab(size_t size ) 
< { 
<   int index ;
<   int tmp ;
< 
<   {
< #line 206
<   tmp = kmalloc_index(size);
< #line 206
<   index = tmp;
< #line 208
<   if (index == 0) {
< #line 209
<     return (0);
<   } else {
< 
<   }
< #line 211
<   return ((struct kmem_cache *)(& kmalloc_caches) + (unsigned long )index);
< }
< }
< #line 215
---
> #line 221 "include/linux/slub_def.h"
1026,1054c692
< #line 218
< extern void *kmem_cache_alloc_notrace(struct kmem_cache * , gfp_t  ) ;
< #line 227 "include/linux/slub_def.h"
< __inline static void *kmalloc_large(size_t size , gfp_t flags ) 
< { 
<   unsigned int order ;
<   int tmp ;
<   void *ret ;
<   unsigned long tmp___0 ;
< 
<   {
< #line 229
<   tmp = get_order(size);
< #line 229
<   order = (unsigned int )tmp;
< #line 230
<   tmp___0 = __get_free_pages(flags | 16384U, order);
< #line 230
<   ret = (void *)tmp___0;
< #line 232
<   kmemleak_alloc((void const   *)ret, size, 1, flags);
< #line 233
<   trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, 4096UL << (int )order,
<                 flags);
< #line 235
<   return (ret);
< }
< }
< #line 238 "include/linux/slub_def.h"
---
> #line 255 "include/linux/slub_def.h"
1057,1061c695
<   void *ret ;
<   void *tmp ;
<   struct kmem_cache *s ;
<   struct kmem_cache *tmp___0 ;
<   void *tmp___1 ;
---
>   void *tmp___2 ;
1064,1104c698,701
< #line 242
<   if (0) {
< #line 243
<     if (size > 8192UL) {
< #line 244
<       tmp = kmalloc_large(size, flags);
< #line 244
<       return (tmp);
<     } else {
< 
<     }
< #line 246
<     if ((flags & 1U) == 0U) {
< #line 247
<       tmp___0 = kmalloc_slab(size);
< #line 247
<       s = tmp___0;
< #line 249
<       if ((unsigned long )s == (unsigned long )((struct kmem_cache *)0)) {
< #line 250
<         return (16);
<       } else {
< 
<       }
< #line 252
<       ret = kmem_cache_alloc_notrace(s, flags);
< #line 254
<       trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, (size_t )s->size,
<                     flags);
< #line 256
<       return (ret);
<     } else {
< 
<     }
<   } else {
< 
<   }
< #line 259
<   tmp___1 = __kmalloc(size, flags);
< #line 259
<   return (tmp___1);
---
> #line 270
>   tmp___2 = __kmalloc(size, flags);
> #line 270
>   return (tmp___2);
1417,1418c1014,1015
<   goto ldv_16328;
<   ldv_16327: 
---
>   goto ldv_17412;
>   ldv_17411: 
1426,1427c1023,1024
<   goto ldv_16325;
<   ldv_16324: 
---
>   goto ldv_17409;
>   ldv_17408: 
1432c1029
<   ldv_16325: ;
---
>   ldv_17409: ;
1436c1033
<     goto ldv_16324;
---
>     goto ldv_17408;
1442c1039
<   ldv_16328: ;
---
>   ldv_17412: ;
1446c1043
<     goto ldv_16327;
---
>     goto ldv_17411;
1458c1055
< static struct mutex cfag12864b_mutex  =    {{1}, {{{{0U}, 3735899821U, 4294967295U, 0xffffffffffffffffUL, {0, 0, "cfag12864b_mutex.wait_lock",
---
> static struct mutex cfag12864b_mutex  =    {{1}, {{{{0U}, 3735899821U, 4294967295U, 0xffffffffffffffffUL, {0, {0, 0}, "cfag12864b_mutex.wait_lock",
1461c1058
<     0, 0, (void *)(& cfag12864b_mutex), {0, 0, "cfag12864b_mutex", 0, 0UL}};
---
>     0, 0, (void *)(& cfag12864b_mutex), {0, {0, 0}, "cfag12864b_mutex", 0, 0UL}};
1469,1481c1066,1086
< static struct delayed_work cfag12864b_work  =    {{{2L}, {& cfag12864b_work.work.entry, & cfag12864b_work.work.entry}, & cfag12864b_update,
<      {(struct lock_class_key *)(& cfag12864b_work.work), 0, "(cfag12864b_work).work",
<       0, 0UL}}, {{0, 1953723489}, 0UL, 0, 0UL, & boot_tvec_bases, 0, {(char)0, (char)0,
<                                                                       (char)0, (char)0,
<                                                                       (char)0, (char)0,
<                                                                       (char)0, (char)0,
<                                                                       (char)0, (char)0,
<                                                                       (char)0, (char)0,
<                                                                       (char)0, (char)0,
<                                                                       (char)0, (char)0},
<                  0, {(struct lock_class_key *)"/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/08_1a/drivers/auxdisplay/cfag12864b.c.prepared:235",
<                      0, "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/08_1a/drivers/auxdisplay/cfag12864b.c.prepared:235",
<                      0, 0UL}}};
---
> static struct delayed_work cfag12864b_work  =    {{{2097680L}, {& cfag12864b_work.work.entry, & cfag12864b_work.work.entry}, & cfag12864b_update,
>      {(struct lock_class_key *)(& cfag12864b_work.work), {0, 0}, "(cfag12864b_work).work",
>       0, 0UL}}, {{0, 1953723489}, 0UL, & boot_tvec_bases, 0, 0UL, -1, 0, 0, {(char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0,
>                                                                              (char)0},
>                  {(struct lock_class_key *)"/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/08_1a/drivers/auxdisplay/cfag12864b.c.prepared:235",
>                   {0, 0}, "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--08_1a--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/08_1a/drivers/auxdisplay/cfag12864b.c.prepared:235",
>                   0, 0UL}}};
1576,1577c1181,1182
<     goto ldv_16370;
<     ldv_16369: 
---
>     goto ldv_17454;
>     ldv_17453: 
1585,1586c1190,1191
<     goto ldv_16367;
<     ldv_16366: 
---
>     goto ldv_17451;
>     ldv_17450: 
1598,1599c1203,1204
<     goto ldv_16364;
<     ldv_16363: 
---
>     goto ldv_17448;
>     ldv_17447: 
1605,1606c1210,1211
<     goto ldv_16361;
<     ldv_16360: ;
---
>     goto ldv_17445;
>     ldv_17444: ;
1616c1221
<     ldv_16361: ;
---
>     ldv_17445: ;
1620c1225
<       goto ldv_16360;
---
>       goto ldv_17444;
1628c1233
<     ldv_16364: ;
---
>     ldv_17448: ;
1632c1237
<       goto ldv_16363;
---
>       goto ldv_17447;
1638c1243
<     ldv_16367: ;
---
>     ldv_17451: ;
1642c1247
<       goto ldv_16366;
---
>       goto ldv_17450;
1648c1253
<     ldv_16370: ;
---
>     ldv_17454: ;
1652c1257
<       goto ldv_16369;
---
>       goto ldv_17453;
1752c1357
<   tmp___2 = __create_workqueue_key("cfag12864b", 1, 0, 0, & __key, __lock_name);
---
>   tmp___2 = __alloc_workqueue_key("cfag12864b", 10U, 1, & __key, __lock_name);
1835,1836c1440,1441
<   goto ldv_16455;
<   ldv_16454: 
---
>   goto ldv_17539;
>   ldv_17538: 
1843c1448
<   goto ldv_16453;
---
>   goto ldv_17537;
1845,1846c1450,1451
<   ldv_16453: ;
<   ldv_16455: 
---
>   ldv_17537: ;
>   ldv_17539: 
1852c1457
<     goto ldv_16454;
---
>     goto ldv_17538;
1867a1473,1474
> #line 1 "<compiler builtins>"
> long __builtin_expect(long exp , long c ) ;
