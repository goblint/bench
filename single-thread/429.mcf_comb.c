/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

typedef unsigned long __darwin_size_t;
typedef __darwin_size_t size_t;
typedef long flow_t;
typedef long cost_t;
struct node;
typedef struct node *node_p;
struct arc;
typedef struct arc *arc_p;
struct node {
   cost_t potential ;
   int orientation ;
   node_p child ;
   node_p pred ;
   node_p sibling ;
   node_p sibling_prev ;
   arc_p basic_arc ;
   arc_p firstout ;
   arc_p firstin ;
   arc_p arc_tmp ;
   flow_t flow ;
   long depth ;
   int number ;
   int time ;
};
struct arc {
   cost_t cost ;
   node_p tail ;
   node_p head ;
   int ident ;
   arc_p nextout ;
   arc_p nextin ;
   flow_t flow ;
   cost_t org_cost ;
};
struct network {
   char inputfile[200] ;
   char clustfile[200] ;
   long n ;
   long n_trips ;
   long max_m ;
   long m ;
   long m_org ;
   long m_impl ;
   long max_residual_new_m ;
   long max_new_m ;
   long primal_unbounded ;
   long dual_unbounded ;
   long perturbed ;
   long feasible ;
   long eps ;
   long opt_tol ;
   long feas_tol ;
   long pert_val ;
   long bigM ;
   double optcost ;
   cost_t ignore_impl ;
   node_p nodes ;
   node_p stop_nodes ;
   arc_p arcs ;
   arc_p stop_arcs ;
   arc_p dummy_arcs ;
   arc_p stop_dummy ;
   long iterations ;
   long bound_exchanges ;
   long checksum ;
};
typedef struct network network_t;
typedef long long __int64_t;
typedef __int64_t __darwin_off_t;
typedef __darwin_off_t fpos_t;
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
struct __sFILEX;
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   void *_cookie ;
   int (*_close)(void * ) ;
   int (*_read)(void * , char * , int  ) ;
   fpos_t (*_seek)(void * , fpos_t  , int  ) ;
   int (*_write)(void * , char const   * , int  ) ;
   struct __sbuf _ub ;
   struct __sFILEX *_extra ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   fpos_t _offset ;
};
typedef struct __sFILE FILE;
typedef struct node node_t;
typedef struct arc arc_t;
struct basket {
   arc_t *a ;
   cost_t cost ;
   cost_t abs_cost ;
};
typedef struct basket BASKET;
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-fPlfu_VD.i","-O3")
extern int ( /* format attribute */  printf)(char const   *  , ...) ;
extern  __attribute__((__noreturn__)) void exit(int  ) ;
__inline static void *__inline_memset_chk(void *__dest , int __val , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memset_chk(__dest, __val, __len, tmp);
  return (tmp___0);
}
}
__inline static char *__inline_strcpy_chk(char *__dest , char const   *__src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcpy_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
double flow_cost(network_t *net___0 ) ;
long getfree(network_t *net___0 ) ;
long read_min(network_t *net___0 ) ;
long write_circulations(char *outfile , network_t *net___0 ) ;
long primal_start_artificial(network_t *net___0 ) ;
long primal_net_simplex(network_t *net___0 ) ;
long price_out_impl(network_t *net___0 ) ;
long suspend_impl(network_t *net___0 , cost_t threshold , long all ) ;
network_t net  ;
long global_opt(void) 
{ 
  long new_arcs ;
  long residual_nb_it ;
  double tmp ;

  {
  new_arcs = -1L;
  if (net.n_trips <= 15000L) {
    residual_nb_it = 5L;
  } else {
    residual_nb_it = 5L;
  }
  while (new_arcs) {
    printf("active arcs                : %ld\n", net.m);
    primal_net_simplex(& net);
    printf("simplex iterations         : %ld\n", net.iterations);
    tmp = flow_cost(& net);
    printf("objective value            : %0.0f\n", tmp);
    if (! residual_nb_it) {
      break;
    }
    if (net.m_impl) {
      new_arcs = suspend_impl(& net, (cost_t )-1, 0L);
      if (new_arcs) {
        printf("erased arcs                : %ld\n", new_arcs);
      }
    }
    new_arcs = price_out_impl(& net);
    if (new_arcs) {
      printf("new implicit arcs          : %ld\n", new_arcs);
    }
    if (new_arcs < 0L) {
      printf("not enough memory, exit(-1)\n");
      exit(-1);
    }
    residual_nb_it --;
  }
  printf("checksum                   : %ld\n", net.checksum);
  return (0L);
}
}
int main(int argc , char **argv ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (argc < 2) {
    return (-1);
  }
  printf("\nMCF SPEC CPU2006 version 1.10\n");
  printf("Copyright (c) 1998-2000 Zuse Institut Berlin (ZIB)\n");
  printf("Copyright (c) 2000-2002 Andreas Loebel & ZIB\n");
  printf("Copyright (c) 2003-2005 Andreas Loebel\n");
  printf("\n");
  tmp___0 = __builtin_object_size((void *)(& net), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(& net), 0);
    __builtin___memset_chk((void *)(& net), 0, sizeof(network_t ), tmp);
  } else {
    __inline_memset_chk((void *)(& net), 0, sizeof(network_t ));
  }
  net.bigM = (long )1.0e7;
  tmp___2 = __builtin_object_size((void *)(net.inputfile), 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)(net.inputfile), 1);
    __builtin___strcpy_chk(net.inputfile, (char const   *)*(argv + 1), tmp___1);
  } else {
    __inline_strcpy_chk(net.inputfile, (char const   *)*(argv + 1));
  }
  tmp___3 = read_min(& net);
  if (tmp___3) {
    printf("read error, exit\n");
    getfree(& net);
    return (-1);
  }
  printf("nodes                      : %ld\n", net.n_trips);
  primal_start_artificial(& net);
  global_opt();
  printf("done\n");
  tmp___4 = write_circulations((char *)"mcf.out", & net);
  if (tmp___4) {
    getfree(& net);
    return (-1);
  }
  getfree(& net);
  return (0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-zCdfTYwJ.i","-O3")
extern FILE *__stderrp ;
extern int ( /* format attribute */  fprintf)(FILE * , char const   *  , ...) ;
extern void free(void * ) ;
void refresh_neighbour_lists(network_t *net___0 ) ;
long refresh_potential(network_t *net___0 ) ;
double flow_org_cost(network_t *net___0 ) ;
long primal_feasible(network_t *net___0 ) ;
long dual_feasible(network_t *net___0 ) ;
void refresh_neighbour_lists(network_t *net___0 ) 
{ 
  node_t *node ;
  arc_t *arc ;
  void *stop ;

  {
  node = net___0->nodes;
  stop = (void *)net___0->stop_nodes;
  while ((unsigned long )node < (unsigned long )((node_t *)stop)) {
    node->firstin = (arc_t *)((void *)0);
    node->firstout = (arc_t *)((void *)0);
    node ++;
  }
  arc = net___0->arcs;
  stop = (void *)net___0->stop_arcs;
  while ((unsigned long )arc < (unsigned long )((arc_t *)stop)) {
    arc->nextout = (arc->tail)->firstout;
    (arc->tail)->firstout = arc;
    arc->nextin = (arc->head)->firstin;
    (arc->head)->firstin = arc;
    arc ++;
  }
  return;
}
}
long refresh_potential(network_t *net___0 ) 
{ 
  node_t *node ;
  node_t *tmp ;
  node_t *root ;
  long checksum ;

  {
  root = net___0->nodes;
  checksum = 0L;
  root->potential = -100000000L;
  node = root->child;
  tmp = node;
  while ((unsigned long )node != (unsigned long )root) {
    while (node) {
      if (node->orientation == 1) {
        node->potential = (node->basic_arc)->cost + (node->pred)->potential;
      } else {
        node->potential = (node->pred)->potential - (node->basic_arc)->cost;
        checksum ++;
      }
      tmp = node;
      node = node->child;
    }
    node = tmp;
    while (node->pred) {
      tmp = node->sibling;
      if (tmp) {
        node = tmp;
        break;
      } else {
        node = node->pred;
      }
    }
  }
  return (checksum);
}
}
double flow_cost(network_t *net___0 ) 
{ 
  arc_t *arc ;
  node_t *node ;
  void *stop ;
  long fleet ;
  cost_t operational_cost ;

  {
  fleet = 0L;
  operational_cost = (cost_t )0;
  stop = (void *)net___0->stop_arcs;
  arc = net___0->arcs;
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
    if (arc->ident == 2) {
      arc->flow = (flow_t )1;
    } else {
      arc->flow = (flow_t )0;
    }
    arc ++;
  }
  stop = (void *)net___0->stop_nodes;
  node = net___0->nodes;
  node ++;
  while ((unsigned long )node != (unsigned long )((node_t *)stop)) {
    (node->basic_arc)->flow = node->flow;
    node ++;
  }
  stop = (void *)net___0->stop_arcs;
  arc = net___0->arcs;
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
    if (arc->flow) {
      if ((arc->tail)->number < 0) {
        if (! ((arc->head)->number > 0)) {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (! (arc->tail)->number) {
        operational_cost += arc->cost - net___0->bigM;
        fleet ++;
      } else {
        operational_cost += arc->cost;
      }
    }
    arc ++;
  }
  return ((double )fleet * (double )net___0->bigM + (double )operational_cost);
}
}
double flow_org_cost(network_t *net___0 ) 
{ 
  arc_t *arc ;
  node_t *node ;
  void *stop ;
  long fleet ;
  cost_t operational_cost ;

  {
  fleet = 0L;
  operational_cost = (cost_t )0;
  stop = (void *)net___0->stop_arcs;
  arc = net___0->arcs;
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
    if (arc->ident == 2) {
      arc->flow = (flow_t )1;
    } else {
      arc->flow = (flow_t )0;
    }
    arc ++;
  }
  stop = (void *)net___0->stop_nodes;
  node = net___0->nodes;
  node ++;
  while ((unsigned long )node != (unsigned long )((node_t *)stop)) {
    (node->basic_arc)->flow = node->flow;
    node ++;
  }
  stop = (void *)net___0->stop_arcs;
  arc = net___0->arcs;
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
    if (arc->flow) {
      if ((arc->tail)->number < 0) {
        if (! ((arc->head)->number > 0)) {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (! (arc->tail)->number) {
        operational_cost += arc->org_cost - net___0->bigM;
        fleet ++;
      } else {
        operational_cost += arc->org_cost;
      }
    }
    arc ++;
  }
  return ((double )fleet * (double )net___0->bigM + (double )operational_cost);
}
}
long primal_feasible(network_t *net___0 ) 
{ 
  void *stop ;
  node_t *node ;
  arc_t *dummy ;
  arc_t *stop_dummy ;
  arc_t *arc ;
  flow_t flow ;
  flow_t tmp ;

  {
  dummy = net___0->dummy_arcs;
  stop_dummy = net___0->stop_dummy;
  node = net___0->nodes;
  stop = (void *)net___0->stop_nodes;
  node ++;
  while ((unsigned long )node < (unsigned long )((node_t *)stop)) {
    arc = node->basic_arc;
    flow = node->flow;
    if ((unsigned long )arc >= (unsigned long )dummy) {
      if ((unsigned long )arc < (unsigned long )stop_dummy) {
        if (flow >= 0L) {
          tmp = flow;
        } else {
          tmp = - flow;
        }
        if (tmp > net___0->feas_tol) {
          printf("PRIMAL NETWORK SIMPLEX: ");
          printf("artificial arc with nonzero flow, node %d (%ld)\n", node->number,
                 flow);
        }
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (flow < - net___0->feas_tol) {
      printf("PRIMAL NETWORK SIMPLEX: ");
      printf("basis primal infeasible (%ld)\n", flow);
      net___0->feasible = 0L;
      return (1L);
    } else
    if (flow - 1L > net___0->feas_tol) {
      printf("PRIMAL NETWORK SIMPLEX: ");
      printf("basis primal infeasible (%ld)\n", flow);
      net___0->feasible = 0L;
      return (1L);
    }
    node ++;
  }
  net___0->feasible = 1L;
  return (0L);
}
}
long dual_feasible(network_t *net___0 ) 
{ 
  arc_t *arc ;
  arc_t *stop ;
  cost_t red_cost ;

  {
  stop = net___0->stop_arcs;
  arc = net___0->arcs;
  while ((unsigned long )arc < (unsigned long )stop) {
    red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
    switch (arc->ident) {
    case 1: 
    case 0: 
    if (red_cost < - net___0->feas_tol) {
      goto DUAL_INFEAS;
    }
    break;
    case 2: 
    if (red_cost > net___0->feas_tol) {
      goto DUAL_INFEAS;
    }
    break;
    default: 
    break;
    }
    arc ++;
  }
  return (0L);
  DUAL_INFEAS: 
  fprintf(__stderrp, "DUAL NETWORK SIMPLEX: ");
  fprintf(__stderrp, "basis dual infeasible\n");
  return (1L);
}
}
long getfree(network_t *net___0 ) 
{ 
  node_p tmp ;
  arc_p tmp___0 ;
  arc_p tmp___1 ;

  {
  if (net___0->nodes) {
    free((void *)net___0->nodes);
  }
  if (net___0->arcs) {
    free((void *)net___0->arcs);
  }
  if (net___0->dummy_arcs) {
    free((void *)net___0->dummy_arcs);
  }
  tmp = (node_p )((void *)0);
  net___0->stop_nodes = tmp;
  net___0->nodes = tmp;
  tmp___0 = (arc_p )((void *)0);
  net___0->stop_arcs = tmp___0;
  net___0->arcs = tmp___0;
  tmp___1 = (arc_p )((void *)0);
  net___0->stop_dummy = tmp___1;
  net___0->dummy_arcs = tmp___1;
  return (0L);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Gbg42EJ8.i","-O3")
extern int fclose(FILE * ) ;
extern char *fgets(char * , int  , FILE * ) ;
extern FILE *fopen(char const   * , char const   * )  __asm__("_fopen")  ;
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
extern void *calloc(size_t  , size_t  ) ;
long read_min(network_t *net___0 ) 
{ 
  FILE *in ;
  char instring[201] ;
  long t ;
  long h ;
  long c ;
  long i ;
  arc_t *arc ;
  node_t *node ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  cost_t tmp___4 ;
  cost_t tmp___5 ;
  cost_t tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  in = (FILE *)((void *)0);
  in = fopen((char const   *)(net___0->inputfile), "r");
  if ((unsigned long )in == (unsigned long )((void *)0)) {
    return (-1L);
  }
  fgets(instring, 200, in);
  tmp = sscanf((char const   *)(instring), "%ld %ld", & t, & h);
  if (tmp != 2) {
    return (-1L);
  }
  net___0->n_trips = t;
  net___0->m_org = h;
  net___0->n = (t + t) + 1L;
  net___0->m = ((t + t) + t) + h;
  if (net___0->n_trips <= 15000L) {
    net___0->max_m = net___0->m;
    net___0->max_new_m = 3000000L;
  } else {
    net___0->max_m = 27328512L;
    net___0->max_new_m = 28900000L;
  }
  net___0->max_residual_new_m = net___0->max_m - net___0->m;
  tmp___0 = calloc((size_t )(net___0->n + 1L), sizeof(node_t ));
  net___0->nodes = (node_t *)tmp___0;
  tmp___1 = calloc((size_t )net___0->n, sizeof(arc_t ));
  net___0->dummy_arcs = (arc_t *)tmp___1;
  tmp___2 = calloc((size_t )net___0->max_m, sizeof(arc_t ));
  net___0->arcs = (arc_t *)tmp___2;
  if (net___0->nodes) {
    if (net___0->arcs) {
      if (! net___0->dummy_arcs) {
        printf("read_min(): not enough memory\n");
        getfree(net___0);
        return (-1L);
      }
    } else {
      printf("read_min(): not enough memory\n");
      getfree(net___0);
      return (-1L);
    }
  } else {
    printf("read_min(): not enough memory\n");
    getfree(net___0);
    return (-1L);
  }
  net___0->stop_nodes = (net___0->nodes + net___0->n) + 1;
  net___0->stop_arcs = net___0->arcs + net___0->m;
  net___0->stop_dummy = net___0->dummy_arcs + net___0->n;
  node = net___0->nodes;
  arc = net___0->arcs;
  i = 1L;
  while (i <= net___0->n_trips) {
    fgets(instring, 200, in);
    tmp___3 = sscanf((char const   *)(instring), "%ld %ld", & t, & h);
    if (tmp___3 != 2) {
      return (-1L);
    } else
    if (t > h) {
      return (-1L);
    }
    (node + i)->number = (int )(- i);
    (node + i)->flow = (flow_t )-1;
    (node + (i + net___0->n_trips))->number = (int )i;
    (node + (i + net___0->n_trips))->flow = (flow_t )1;
    (node + i)->time = (int )t;
    (node + (i + net___0->n_trips))->time = (int )h;
    arc->tail = node + net___0->n;
    arc->head = node + i;
    tmp___4 = net___0->bigM + 15L;
    arc->cost = tmp___4;
    arc->org_cost = tmp___4;
    arc->nextout = (arc->tail)->firstout;
    (arc->tail)->firstout = arc;
    arc->nextin = (arc->head)->firstin;
    (arc->head)->firstin = arc;
    arc ++;
    arc->tail = node + (i + net___0->n_trips);
    arc->head = node + net___0->n;
    tmp___5 = (cost_t )15;
    arc->cost = tmp___5;
    arc->org_cost = tmp___5;
    arc->nextout = (arc->tail)->firstout;
    (arc->tail)->firstout = arc;
    arc->nextin = (arc->head)->firstin;
    (arc->head)->firstin = arc;
    arc ++;
    arc->tail = node + i;
    arc->head = node + (i + net___0->n_trips);
    if (net___0->bigM > (long )1.0e7) {
      tmp___7 = net___0->bigM;
    } else {
      tmp___7 = (long )1.0e7;
    }
    tmp___6 = 2L * tmp___7;
    arc->cost = tmp___6;
    arc->org_cost = tmp___6;
    arc->nextout = (arc->tail)->firstout;
    (arc->tail)->firstout = arc;
    arc->nextin = (arc->head)->firstin;
    (arc->head)->firstin = arc;
    arc ++;
    i ++;
  }
  if (i != net___0->n_trips + 1L) {
    return (-1L);
  }
  i = 0L;
  while (i < net___0->m_org) {
    fgets(instring, 200, in);
    tmp___8 = sscanf((char const   *)(instring), "%ld %ld %ld", & t, & h, & c);
    if (tmp___8 != 3) {
      return (-1L);
    }
    arc->tail = node + (t + net___0->n_trips);
    arc->head = node + h;
    arc->org_cost = c;
    arc->cost = c;
    arc->nextout = (arc->tail)->firstout;
    (arc->tail)->firstout = arc;
    arc->nextin = (arc->head)->firstin;
    (arc->head)->firstin = arc;
    i ++;
    arc ++;
  }
  if ((unsigned long )net___0->stop_arcs != (unsigned long )arc) {
    net___0->stop_arcs = arc;
    arc = net___0->arcs;
    net___0->m = 0L;
    while ((unsigned long )arc < (unsigned long )net___0->stop_arcs) {
      (net___0->m) ++;
      arc ++;
    }
    net___0->m_org = net___0->m;
  }
  fclose(in);
  net___0->clustfile[0] = (char)0;
  i = 1L;
  while (i <= net___0->n_trips) {
    if (net___0->bigM > (long )1.0e7) {
      tmp___9 = net___0->bigM;
    } else {
      tmp___9 = (long )1.0e7;
    }
    (net___0->arcs + (3L * i - 1L))->cost = -2L * tmp___9;
    if (net___0->bigM > (long )1.0e7) {
      tmp___10 = net___0->bigM;
    } else {
      tmp___10 = (long )1.0e7;
    }
    (net___0->arcs + (3L * i - 1L))->org_cost = -2L * tmp___10;
    i ++;
  }
  return (0L);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-i7Q9E_aJ.i","-O3")
extern FILE *__stdoutp ;
extern int fflush(FILE * ) ;
extern void *realloc(void * , size_t  ) ;
long resize_prob(network_t *net___0 ) 
{ 
  arc_t *arc ;
  node_t *node ;
  node_t *stop ;
  node_t *root ;
  size_t off ;
  void *tmp ;

  {
  net___0->max_m += net___0->max_new_m;
  net___0->max_residual_new_m += net___0->max_new_m;
  tmp = realloc((void *)net___0->arcs, (unsigned long )net___0->max_m * sizeof(arc_t ));
  arc = (arc_t *)tmp;
  if (! arc) {
    printf("network %s: not enough memory\n", net___0->inputfile);
    fflush(__stdoutp);
    return (-1L);
  }
  off = (size_t )arc - (size_t )net___0->arcs;
  net___0->arcs = arc;
  net___0->stop_arcs = arc + net___0->m;
  node = net___0->nodes;
  root = node;
  node ++;
  stop = (node_t *)((void *)net___0->stop_nodes);
  while ((unsigned long )node < (unsigned long )stop) {
    if ((unsigned long )node->pred != (unsigned long )root) {
      node->basic_arc = (arc_t *)((size_t )node->basic_arc + off);
    }
    node ++;
  }
  return (0L);
}
}
void insert_new_arc(arc_t *new , long newpos , node_t *tail , node_t *head , cost_t cost ,
                    cost_t red_cost ) 
{ 
  long pos ;

  {
  (new + newpos)->tail = tail;
  (new + newpos)->head = head;
  (new + newpos)->org_cost = cost;
  (new + newpos)->cost = cost;
  (new + newpos)->flow = red_cost;
  pos = newpos + 1L;
  while (1) {
    if (pos - 1L) {
      if (! (red_cost > (new + (pos / 2L - 1L))->flow)) {
        break;
      }
    } else {
      break;
    }
    (new + (pos - 1L))->tail = (new + (pos / 2L - 1L))->tail;
    (new + (pos - 1L))->head = (new + (pos / 2L - 1L))->head;
    (new + (pos - 1L))->cost = (new + (pos / 2L - 1L))->cost;
    (new + (pos - 1L))->org_cost = (new + (pos / 2L - 1L))->cost;
    (new + (pos - 1L))->flow = (new + (pos / 2L - 1L))->flow;
    pos /= 2L;
    (new + (pos - 1L))->tail = tail;
    (new + (pos - 1L))->head = head;
    (new + (pos - 1L))->cost = cost;
    (new + (pos - 1L))->org_cost = cost;
    (new + (pos - 1L))->flow = red_cost;
  }
  return;
}
}
void replace_weaker_arc(network_t *net___0 , arc_t *new , node_t *tail , node_t *head ,
                        cost_t cost , cost_t red_cost ) 
{ 
  long pos ;
  long cmp ;

  {
  (new + 0)->tail = tail;
  (new + 0)->head = head;
  (new + 0)->org_cost = cost;
  (new + 0)->cost = cost;
  (new + 0)->flow = red_cost;
  pos = 1L;
  if ((new + 1)->flow > (new + 2)->flow) {
    cmp = 2L;
  } else {
    cmp = 3L;
  }
  while (1) {
    if (cmp <= net___0->max_residual_new_m) {
      if (! (red_cost < (new + (cmp - 1L))->flow)) {
        break;
      }
    } else {
      break;
    }
    (new + (pos - 1L))->tail = (new + (cmp - 1L))->tail;
    (new + (pos - 1L))->head = (new + (cmp - 1L))->head;
    (new + (pos - 1L))->cost = (new + (cmp - 1L))->cost;
    (new + (pos - 1L))->org_cost = (new + (cmp - 1L))->cost;
    (new + (pos - 1L))->flow = (new + (cmp - 1L))->flow;
    (new + (cmp - 1L))->tail = tail;
    (new + (cmp - 1L))->head = head;
    (new + (cmp - 1L))->cost = cost;
    (new + (cmp - 1L))->org_cost = cost;
    (new + (cmp - 1L))->flow = red_cost;
    pos = cmp;
    cmp *= 2L;
    if (cmp + 1L <= net___0->max_residual_new_m) {
      if ((new + (cmp - 1L))->flow < (new + cmp)->flow) {
        cmp ++;
      }
    }
  }
  return;
}
}
long price_out_impl(network_t *net___0 ) 
{ 
  long i ;
  long trips ;
  long new_arcs ;
  long resized ;
  long latest ;
  long min_impl_duration ;
  register cost_t bigM ;
  register cost_t head_potential ;
  register cost_t arc_cost ;
  register cost_t red_cost ;
  register cost_t bigM_minus_min_impl_duration ;
  register arc_t *arcout ;
  register arc_t *arcin ;
  register arc_t *arcnew ;
  register arc_t *stop ;
  register arc_t *first_of_sparse_list ;
  register node_t *tail ;
  register node_t *head ;
  long tmp ;

  {
  new_arcs = 0L;
  resized = 0L;
  min_impl_duration = 15L;
  bigM = net___0->bigM;
  arc_cost = (cost_t )30;
  bigM_minus_min_impl_duration = bigM - min_impl_duration;
  if (net___0->n_trips <= 15000L) {
    if (net___0->m + net___0->max_new_m > net___0->max_m) {
      if ((net___0->n_trips * net___0->n_trips) / 2L + net___0->m > net___0->max_m) {
        resized = 1L;
        tmp = resize_prob(net___0);
        if (tmp) {
          return (-1L);
        }
        refresh_neighbour_lists(net___0);
      }
    }
  }
  arcnew = net___0->stop_arcs;
  trips = net___0->n_trips;
  arcout = net___0->arcs;
  i = 0L;
  while (1) {
    if (i < trips) {
      if (! ((arcout + 1)->ident == -1)) {
        break;
      }
    } else {
      break;
    }
    i ++;
    arcout += 3;
  }
  first_of_sparse_list = (arc_t *)((void *)0);
  while (i < trips) {
    if ((arcout + 1)->ident != -1) {
      (((arcout->head)->firstout)->head)->arc_tmp = first_of_sparse_list;
      first_of_sparse_list = arcout + 1;
    }
    if (arcout->ident == -1) {
      goto __Cont;
    }
    head = arcout->head;
    latest = ((cost_t )head->time - arcout->org_cost) + bigM_minus_min_impl_duration;
    head_potential = head->potential;
    arcin = (first_of_sparse_list->tail)->arc_tmp;
    while (arcin) {
      tail = arcin->tail;
      if ((cost_t )tail->time + arcin->org_cost > latest) {
        arcin = tail->arc_tmp;
        continue;
      }
      red_cost = (arc_cost - tail->potential) + head->potential;
      if (red_cost < 0L) {
        if (new_arcs < net___0->max_residual_new_m) {
          insert_new_arc(arcnew, new_arcs, tail, head, arc_cost, red_cost);
          new_arcs ++;
        } else
        if ((arcnew + 0)->flow > red_cost) {
          replace_weaker_arc(net___0, arcnew, tail, head, arc_cost, red_cost);
        }
      }
      arcin = tail->arc_tmp;
    }
    __Cont: /* CIL Label */ 
    i ++;
    arcout += 3;
  }
  if (new_arcs) {
    arcnew = net___0->stop_arcs;
    net___0->stop_arcs += new_arcs;
    stop = (arc_t *)((void *)net___0->stop_arcs);
    if (resized) {
      while ((unsigned long )arcnew != (unsigned long )stop) {
        arcnew->flow = (flow_t )0;
        arcnew->ident = 1;
        arcnew ++;
      }
    } else {
      while ((unsigned long )arcnew != (unsigned long )stop) {
        arcnew->flow = (flow_t )0;
        arcnew->ident = 1;
        arcnew->nextout = (arcnew->tail)->firstout;
        (arcnew->tail)->firstout = arcnew;
        arcnew->nextin = (arcnew->head)->firstin;
        (arcnew->head)->firstin = arcnew;
        arcnew ++;
      }
    }
    net___0->m += new_arcs;
    net___0->m_impl += new_arcs;
    net___0->max_residual_new_m -= new_arcs;
  }
  return (new_arcs);
}
}
long suspend_impl(network_t *net___0 , cost_t threshold , long all ) 
{ 
  long susp ;
  cost_t red_cost ;
  arc_t *new_arc ;
  arc_t *arc ;
  void *stop ;

  {
  if (all) {
    susp = net___0->m_impl;
  } else {
    stop = (void *)net___0->stop_arcs;
    new_arc = net___0->arcs + (net___0->m - net___0->m_impl);
    susp = 0L;
    arc = new_arc;
    while ((unsigned long )arc < (unsigned long )((arc_t *)stop)) {
      if (arc->ident == 1) {
        red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
      } else {
        red_cost = (cost_t )-2;
        if (arc->ident == 0) {
          if ((unsigned long )(arc->tail)->basic_arc == (unsigned long )arc) {
            (arc->tail)->basic_arc = new_arc;
          } else {
            (arc->head)->basic_arc = new_arc;
          }
        }
      }
      if (red_cost > threshold) {
        susp ++;
      } else {
        *new_arc = *arc;
        new_arc ++;
      }
      arc ++;
    }
  }
  if (susp) {
    net___0->m -= susp;
    net___0->m_impl -= susp;
    net___0->stop_arcs -= susp;
    net___0->max_residual_new_m += susp;
    refresh_neighbour_lists(net___0);
  }
  return (susp);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-z_MZR695.i","-O3")
long primal_start_artificial(network_t *net___0 ) 
{ 
  node_t *node ;
  node_t *root ;
  arc_t *arc ;
  void *stop ;

  {
  node = net___0->nodes;
  root = node;
  node ++;
  root->basic_arc = (arc_p )((void *)0);
  root->pred = (node_p )((void *)0);
  root->child = node;
  root->sibling = (node_p )((void *)0);
  root->sibling_prev = (node_p )((void *)0);
  root->depth = net___0->n + 1L;
  root->orientation = 0;
  root->potential = -100000000L;
  root->flow = (flow_t )0;
  stop = (void *)net___0->stop_arcs;
  arc = net___0->arcs;
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
    if (arc->ident != -1) {
      arc->ident = 1;
    }
    arc ++;
  }
  arc = net___0->dummy_arcs;
  stop = (void *)net___0->stop_nodes;
  while ((unsigned long )node != (unsigned long )((node_t *)stop)) {
    node->basic_arc = arc;
    node->pred = root;
    node->child = (node_p )((void *)0);
    node->sibling = node + 1;
    node->sibling_prev = node - 1;
    node->depth = 1L;
    arc->cost = 100000000L;
    arc->ident = 0;
    node->orientation = 1;
    node->potential = (cost_t )0;
    arc->tail = node;
    arc->head = root;
    node->flow = (flow_t )0;
    arc ++;
    node ++;
  }
  node --;
  root ++;
  node->sibling = (node_p )((void *)0);
  root->sibling_prev = (node_p )((void *)0);
  return (0L);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-bTi0FtDw.i","-O3")
long write_circulations(char *outfile , network_t *net___0 ) 
{ 
  FILE *out ;
  arc_t *block ;
  arc_t *arc ;
  arc_t *arc2 ;
  arc_t *first_impl ;

  {
  out = (FILE *)((void *)0);
  first_impl = net___0->stop_arcs - net___0->m_impl;
  out = fopen((char const   *)outfile, "w");
  if ((unsigned long )out == (unsigned long )((void *)0)) {
    return (-1L);
  }
  refresh_neighbour_lists(net___0);
  block = (net___0->nodes + net___0->n)->firstout;
  while (block) {
    if (block->flow) {
      fprintf(out, "()\n");
      arc = block;
      while (arc) {
        if ((unsigned long )arc >= (unsigned long )first_impl) {
          fprintf(out, "***\n");
        }
        fprintf(out, "%d\n", - (arc->head)->number);
        arc2 = (arc->head + net___0->n_trips)->firstout;
        while (arc2) {
          if (arc2->flow) {
            break;
          }
          arc2 = arc2->nextout;
        }
        if (! arc2) {
          fclose(out);
          return (-1L);
        }
        if ((arc2->head)->number) {
          arc = arc2;
        } else {
          arc = (arc_t *)((void *)0);
        }
      }
    }
    block = block->nextout;
  }
  fclose(out);
  return (0L);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-J2UTPXtA.i","-O3")
void update_tree(long cycle_ori , long new_orientation , flow_t delta , flow_t new_flow ,
                 node_t *iplus , node_t *jplus , node_t *iminus , node_t *jminus ,
                 node_t *w , arc_t *bea , cost_t sigma , flow_t feas_tol ) ;
void update_tree(long cycle_ori , long new_orientation , flow_t delta , flow_t new_flow ,
                 node_t *iplus , node_t *jplus , node_t *iminus , node_t *jminus ,
                 node_t *w , arc_t *bea , cost_t sigma , flow_t feas_tol ) 
{ 
  arc_t *basic_arc_temp ;
  arc_t *new_basic_arc ;
  node_t *father ;
  node_t *temp ;
  node_t *new_pred ;
  long orientation_temp ;
  long depth_temp ;
  long depth_iminus ;
  long new_depth ;
  flow_t flow_temp ;
  cost_t tmp ;

  {
  if ((unsigned long )bea->tail == (unsigned long )jplus) {
    if (sigma < 0L) {
      goto _L;
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if ((unsigned long )bea->tail == (unsigned long )iplus) {
    if (sigma > 0L) {
      _L: /* CIL Label */ 
      if (sigma >= 0L) {
        sigma = sigma;
      } else {
        sigma = - sigma;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (sigma >= 0L) {
      tmp = sigma;
    } else {
      tmp = - sigma;
    }
    sigma = - tmp;
  }
  father = iminus;
  father->potential += sigma;
  RECURSION: 
  temp = father->child;
  if (temp) {
    ITERATION: 
    temp->potential += sigma;
    father = temp;
    goto RECURSION;
  }
  TEST: 
  if ((unsigned long )father == (unsigned long )iminus) {
    goto CONTINUE;
  }
  temp = father->sibling;
  if (temp) {
    goto ITERATION;
  }
  father = father->pred;
  goto TEST;
  CONTINUE: 
  temp = iplus;
  father = temp->pred;
  depth_iminus = iminus->depth;
  new_depth = depth_iminus;
  new_pred = jplus;
  new_basic_arc = bea;
  while ((unsigned long )temp != (unsigned long )jminus) {
    if (temp->sibling) {
      (temp->sibling)->sibling_prev = temp->sibling_prev;
    }
    if (temp->sibling_prev) {
      (temp->sibling_prev)->sibling = temp->sibling;
    } else {
      father->child = temp->sibling;
    }
    temp->pred = new_pred;
    temp->sibling = new_pred->child;
    if (temp->sibling) {
      (temp->sibling)->sibling_prev = temp;
    }
    new_pred->child = temp;
    temp->sibling_prev = (node_p )0;
    orientation_temp = (long )(! temp->orientation);
    if (orientation_temp == cycle_ori) {
      flow_temp = temp->flow + delta;
    } else {
      flow_temp = temp->flow - delta;
    }
    basic_arc_temp = temp->basic_arc;
    depth_temp = temp->depth;
    temp->orientation = (int )new_orientation;
    temp->flow = new_flow;
    temp->basic_arc = new_basic_arc;
    temp->depth = new_depth;
    new_pred = temp;
    new_orientation = orientation_temp;
    new_flow = flow_temp;
    new_basic_arc = basic_arc_temp;
    new_depth = depth_iminus - depth_temp;
    temp = father;
    father = temp->pred;
  }
  if (delta > feas_tol) {
    temp = jminus;
    while ((unsigned long )temp != (unsigned long )w) {
      temp->depth -= depth_iminus;
      if ((long )temp->orientation != cycle_ori) {
        temp->flow += delta;
      } else {
        temp->flow -= delta;
      }
      temp = temp->pred;
    }
    temp = jplus;
    while ((unsigned long )temp != (unsigned long )w) {
      temp->depth += depth_iminus;
      if ((long )temp->orientation == cycle_ori) {
        temp->flow += delta;
      } else {
        temp->flow -= delta;
      }
      temp = temp->pred;
    }
  } else {
    temp = jminus;
    while ((unsigned long )temp != (unsigned long )w) {
      temp->depth -= depth_iminus;
      temp = temp->pred;
    }
    temp = jplus;
    while ((unsigned long )temp != (unsigned long )w) {
      temp->depth += depth_iminus;
      temp = temp->pred;
    }
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-uKJfr66A.i","-O3")
node_t *primal_iminus(flow_t *delta , long *xchange , node_t *iplus , node_t *jplus ,
                      node_t **w ) ;
node_t *primal_iminus(flow_t *delta , long *xchange , node_t *iplus , node_t *jplus ,
                      node_t **w ) 
{ 
  node_t *iminus ;

  {
  iminus = (node_t *)((void *)0);
  while ((unsigned long )iplus != (unsigned long )jplus) {
    if (iplus->depth < jplus->depth) {
      if (iplus->orientation) {
        if (*delta > iplus->flow) {
          iminus = iplus;
          *delta = iplus->flow;
          *xchange = 0L;
        }
      } else
      if ((iplus->pred)->pred) {
        if (*delta > 1L - iplus->flow) {
          iminus = iplus;
          *delta = 1L - iplus->flow;
          *xchange = 0L;
        }
      }
      iplus = iplus->pred;
    } else {
      if (! jplus->orientation) {
        if (*delta >= jplus->flow) {
          iminus = jplus;
          *delta = jplus->flow;
          *xchange = 1L;
        }
      } else
      if ((jplus->pred)->pred) {
        if (*delta >= 1L - jplus->flow) {
          iminus = jplus;
          *delta = 1L - jplus->flow;
          *xchange = 1L;
        }
      }
      jplus = jplus->pred;
    }
  }
  *w = iplus;
  return (iminus);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-YW0w8M8s.i","-O3")
void primal_update_flow(node_t *iplus , node_t *jplus , node_t *w ) ;
void primal_update_flow(node_t *iplus , node_t *jplus , node_t *w ) 
{ 


  {
  while ((unsigned long )iplus != (unsigned long )w) {
    if (iplus->orientation) {
      iplus->flow = (flow_t )0;
    } else {
      iplus->flow = (flow_t )1;
    }
    iplus = iplus->pred;
  }
  while ((unsigned long )jplus != (unsigned long )w) {
    if (jplus->orientation) {
      jplus->flow = (flow_t )1;
    } else {
      jplus->flow = (flow_t )0;
    }
    jplus = jplus->pred;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-uaG6HwB2.i","-O3")
arc_t *primal_bea_mpp(long m , arc_t *arcs , arc_t *stop_arcs , cost_t *red_cost_of_bea ) ;
long primal_net_simplex(network_t *net___0 ) 
{ 
  flow_t delta ;
  flow_t new_flow ;
  long opt ;
  long xchange ;
  long new_orientation ;
  node_t *iplus ;
  node_t *jplus ;
  node_t *iminus ;
  node_t *jminus ;
  node_t *w ;
  arc_t *bea ;
  arc_t *bla ;
  arc_t *arcs ;
  arc_t *stop_arcs ;
  node_t *temp ;
  long m ;
  long new_set ;
  cost_t red_cost_of_bea ;
  long *iterations ;
  long *bound_exchanges ;
  long *checksum ;
  long tmp ;
  long tmp___0 ;

  {
  opt = 0L;
  arcs = net___0->arcs;
  stop_arcs = net___0->stop_arcs;
  m = net___0->m;
  iterations = & net___0->iterations;
  bound_exchanges = & net___0->bound_exchanges;
  checksum = & net___0->checksum;
  while (! opt) {
    bea = primal_bea_mpp(m, arcs, stop_arcs, & red_cost_of_bea);
    if (bea) {
      (*iterations) ++;
      if (red_cost_of_bea > 0L) {
        iplus = bea->head;
        jplus = bea->tail;
      } else {
        iplus = bea->tail;
        jplus = bea->head;
      }
      delta = (flow_t )1;
      iminus = primal_iminus(& delta, & xchange, iplus, jplus, & w);
      if (! iminus) {
        (*bound_exchanges) ++;
        if (bea->ident == 2) {
          bea->ident = 1;
        } else {
          bea->ident = 2;
        }
        if (delta) {
          primal_update_flow(iplus, jplus, w);
        }
      } else {
        if (xchange) {
          temp = jplus;
          jplus = iplus;
          iplus = temp;
        }
        jminus = iminus->pred;
        bla = iminus->basic_arc;
        if (xchange != (long )iminus->orientation) {
          new_set = 1L;
        } else {
          new_set = 2L;
        }
        if (red_cost_of_bea > 0L) {
          new_flow = 1L - delta;
        } else {
          new_flow = delta;
        }
        if ((unsigned long )bea->tail == (unsigned long )iplus) {
          new_orientation = 1L;
        } else {
          new_orientation = 0L;
        }
        update_tree((long )(! xchange), new_orientation, delta, new_flow, iplus, jplus,
                    iminus, jminus, w, bea, red_cost_of_bea, net___0->feas_tol);
        bea->ident = 0;
        bla->ident = (int )new_set;
        if (! ((*iterations - 1L) % 200L)) {
          tmp = refresh_potential(net___0);
          *checksum += tmp;
        }
      }
    } else {
      opt = 1L;
    }
  }
  tmp___0 = refresh_potential(net___0);
  *checksum += tmp___0;
  primal_feasible(net___0);
  dual_feasible(net___0);
  return (0L);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-3grE2evL.i","-O3")
int bea_is_dual_infeasible(arc_t *arc , cost_t red_cost ) 
{ 
  int tmp ;

  {
  if (red_cost < 0L) {
    if (arc->ident == 1) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (red_cost > 0L) {
    if (arc->ident == 2) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static long basket_size  ;
static BASKET basket[351]  ;
static BASKET *perm[351]  ;
void sort_basket(long min , long max ) 
{ 
  long l ;
  long r ;
  cost_t cut ;
  BASKET *xchange ;

  {
  l = min;
  r = max;
  cut = (perm[(l + r) / 2L])->abs_cost;
  while (1) {
    while ((perm[l])->abs_cost > cut) {
      l ++;
    }
    while (cut > (perm[r])->abs_cost) {
      r --;
    }
    if (l < r) {
      xchange = perm[l];
      perm[l] = perm[r];
      perm[r] = xchange;
    }
    if (l <= r) {
      l ++;
      r --;
    }
    if (! (l <= r)) {
      break;
    }
  }
  if (min < r) {
    sort_basket(min, r);
  }
  if (l < max) {
    if (l <= 50L) {
      sort_basket(l, max);
    }
  }
  return;
}
}
static long nr_group  ;
static long group_pos  ;
static long initialize  =    1L;
arc_t *primal_bea_mpp(long m , arc_t *arcs , arc_t *stop_arcs , cost_t *red_cost_of_bea ) 
{ 
  long i ;
  long next ;
  long old_group_pos ;
  arc_t *arc ;
  cost_t red_cost ;
  int tmp ;

  {
  if (initialize) {
    i = 1L;
    while (i < 351L) {
      perm[i] = & basket[i];
      i ++;
    }
    nr_group = (m - 1L) / 300L + 1L;
    group_pos = 0L;
    basket_size = 0L;
    initialize = 0L;
  } else {
    i = 2L;
    next = 0L;
    while (1) {
      if (i <= 50L) {
        if (! (i <= basket_size)) {
          break;
        }
      } else {
        break;
      }
      arc = (perm[i])->a;
      red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
      if (red_cost < 0L) {
        if (arc->ident == 1) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (red_cost > 0L) {
        if (arc->ident == 2) {
          _L: /* CIL Label */ 
          next ++;
          (perm[next])->a = arc;
          (perm[next])->cost = red_cost;
          if (red_cost >= 0L) {
            (perm[next])->abs_cost = red_cost;
          } else {
            (perm[next])->abs_cost = - red_cost;
          }
        }
      }
      i ++;
    }
    basket_size = next;
  }
  old_group_pos = group_pos;
  NEXT: 
  arc = arcs + group_pos;
  while ((unsigned long )arc < (unsigned long )stop_arcs) {
    if (arc->ident > 0) {
      red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
      tmp = bea_is_dual_infeasible(arc, red_cost);
      if (tmp) {
        basket_size ++;
        (perm[basket_size])->a = arc;
        (perm[basket_size])->cost = red_cost;
        if (red_cost >= 0L) {
          (perm[basket_size])->abs_cost = red_cost;
        } else {
          (perm[basket_size])->abs_cost = - red_cost;
        }
      }
    }
    arc += nr_group;
  }
  group_pos ++;
  if (group_pos == nr_group) {
    group_pos = 0L;
  }
  if (basket_size < 50L) {
    if (group_pos != old_group_pos) {
      goto NEXT;
    }
  }
  if (basket_size == 0L) {
    initialize = 1L;
    *red_cost_of_bea = (cost_t )0;
    return ((arc_t *)((void *)0));
  }
  sort_basket(1L, basket_size);
  *red_cost_of_bea = (perm[1])->cost;
  return ((perm[1])->a);
}
}
