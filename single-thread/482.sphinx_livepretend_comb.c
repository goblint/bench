/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

typedef long long __int64_t;
typedef unsigned long __darwin_size_t;
typedef __int64_t __darwin_off_t;
typedef __darwin_size_t size_t;
typedef __darwin_off_t fpos_t;
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
struct __sFILEX;
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   void *_cookie ;
   int (*_close)(void * ) ;
   int (*_read)(void * , char * , int  ) ;
   fpos_t (*_seek)(void * , fpos_t  , int  ) ;
   int (*_write)(void * , char const   * , int  ) ;
   struct __sbuf _ub ;
   struct __sFILEX *_extra ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   fpos_t _offset ;
};
typedef struct __sFILE FILE;
typedef int int32;
typedef short int16;
typedef char int8;
typedef unsigned int uint32;
typedef unsigned short uint16;
typedef unsigned char uint8;
typedef float float32;
typedef double float64;
union anytype_s {
   void *ptr ;
   int32 int32 ;
   uint32 uint32 ;
   float32 float32 ;
   float64 float64 ;
};
typedef union anytype_s anytype_t;
struct gnode_s {
   anytype_t data ;
   struct gnode_s *next ;
};
typedef struct gnode_s gnode_t;
typedef gnode_t *glist_t;
struct hash_entry_s {
   char const   *key ;
   int32 len ;
   int32 val ;
   struct hash_entry_s *next ;
};
typedef struct hash_entry_s hash_entry_t;
struct __anonstruct_hash_table_t_13 {
   hash_entry_t *table ;
   int32 size ;
   uint8 nocase ;
};
typedef struct __anonstruct_hash_table_t_13 hash_table_t;
struct __anonstruct_ptmr_t_15 {
   char const   *name ;
   float64 t_cpu ;
   float64 t_elapsed ;
   float64 t_tot_cpu ;
   float64 t_tot_elapsed ;
   float64 start_cpu ;
   float64 start_elapsed ;
};
typedef struct __anonstruct_ptmr_t_15 ptmr_t;
struct feat_s {
   char *name ;
   int32 cepsize ;
   int32 cepsize_used ;
   int32 n_stream ;
   int32 *stream_len ;
   int32 window_size ;
   int32 cmn ;
   int32 varnorm ;
   int32 agc ;
   void (*compute_feat)(struct feat_s *fcb , float32 **input , float32 **feat ) ;
};
typedef struct feat_s feat_t;
struct __anonstruct_partialhyp_t_16 {
   int32 ascr ;
   int32 lscr ;
   char *word ;
   int32 sf ;
   int32 ef ;
};
typedef struct __anonstruct_partialhyp_t_16 partialhyp_t;
struct __anonstruct_mgau_t_17 {
   int32 n_comp ;
   float32 **mean ;
   float32 **var ;
   float32 *lrd ;
   int32 *mixw ;
};
typedef struct __anonstruct_mgau_t_17 mgau_t;
struct __anonstruct_mgau_model_t_18 {
   int32 n_mgau ;
   int32 max_comp ;
   int32 veclen ;
   mgau_t *mgau ;
   float64 distfloor ;
   int32 frm_sen_eval ;
   int32 frm_gau_eval ;
   int32 gau_type ;
};
typedef struct __anonstruct_mgau_model_t_18 mgau_model_t;
typedef int8 s3cipid_t;
typedef int32 s3pid_t;
typedef s3pid_t s3ssid_t;
typedef int32 s3tmatid_t;
typedef int32 s3wid_t;
typedef uint16 s3lmwid_t;
typedef int16 s3frmid_t;
typedef int16 s3senid_t;
enum __anonenum_word_posn_t_19 {
    WORD_POSN_BEGIN = 0,
    WORD_POSN_END = 1,
    WORD_POSN_SINGLE = 2,
    WORD_POSN_INTERNAL = 3,
    WORD_POSN_UNDEFINED = 4
} ;
typedef enum __anonenum_word_posn_t_19 word_posn_t;
struct __anonstruct_ciphone_t_20 {
   char *name ;
   int32 filler ;
};
typedef struct __anonstruct_ciphone_t_20 ciphone_t;
struct __anonstruct_phone_t_21 {
   s3ssid_t ssid ;
   s3tmatid_t tmat ;
   s3cipid_t ci ;
   s3cipid_t lc ;
   s3cipid_t rc ;
   word_posn_t wpos ;
};
typedef struct __anonstruct_phone_t_21 phone_t;
struct ph_rc_s {
   s3cipid_t rc ;
   s3pid_t pid ;
   struct ph_rc_s *next ;
};
typedef struct ph_rc_s ph_rc_t;
struct ph_lc_s {
   s3cipid_t lc ;
   ph_rc_t *rclist ;
   struct ph_lc_s *next ;
};
typedef struct ph_lc_s ph_lc_t;
struct __anonstruct_mdef_t_22 {
   int32 n_ciphone ;
   int32 n_phone ;
   int32 n_emit_state ;
   int32 n_ci_sen ;
   int32 n_sen ;
   int32 n_tmat ;
   hash_table_t *ciphone_ht ;
   ciphone_t *ciphone ;
   phone_t *phone ;
   s3senid_t **sseq ;
   int32 n_sseq ;
   s3senid_t *cd2cisen ;
   s3cipid_t *sen2cimap ;
   int32 *ciphone2n_cd_sen ;
   s3cipid_t sil ;
   ph_lc_t ***wpos_ci_lclist ;
};
typedef struct __anonstruct_mdef_t_22 mdef_t;
struct __anonstruct_dictword_t_23 {
   char *word ;
   s3cipid_t *ciphone ;
   int32 pronlen ;
   s3wid_t alt ;
   s3wid_t basewid ;
   int32 n_comp ;
   s3wid_t *comp ;
};
typedef struct __anonstruct_dictword_t_23 dictword_t;
struct __anonstruct_dict_t_24 {
   mdef_t *mdef ;
   hash_table_t *pht ;
   char **ciphone_str ;
   int32 n_ciphone ;
   dictword_t *word ;
   hash_table_t *ht ;
   int32 max_words ;
   int32 n_word ;
   int32 filler_start ;
   int32 filler_end ;
   s3wid_t *comp_head ;
   s3wid_t startwid ;
   s3wid_t finishwid ;
   s3wid_t silwid ;
};
typedef struct __anonstruct_dict_t_24 dict_t;
struct __anonstruct_dict2pid_t_25 {
   s3ssid_t **internal ;
   s3ssid_t ***ldiph_lc ;
   s3ssid_t **single_lc ;
   s3senid_t **comstate ;
   s3senid_t **comsseq ;
   int32 *comwt ;
   int32 n_comstate ;
   int32 n_comsseq ;
};
typedef struct __anonstruct_dict2pid_t_25 dict2pid_t;
struct __anonstruct_fillpen_t_26 {
   dict_t *dict ;
   int32 *prob ;
   float64 lw ;
   float64 wip ;
};
typedef struct __anonstruct_fillpen_t_26 fillpen_t;
struct lmclass_word_s {
   char *word ;
   int32 dictwid ;
   int32 LOGprob ;
   struct lmclass_word_s *next ;
};
typedef struct lmclass_word_s *lmclass_word_t;
struct lmclass_s {
   char *name ;
   lmclass_word_t wordlist ;
   struct lmclass_s *next ;
};
typedef struct lmclass_s *lmclass_t;
union __anonunion_lmlog_t_27 {
   float32 f ;
   int32 l ;
};
typedef union __anonunion_lmlog_t_27 lmlog_t;
struct __anonstruct_ug_t_28 {
   s3wid_t dictwid ;
   lmlog_t prob ;
   lmlog_t bowt ;
   int32 firstbg ;
};
typedef struct __anonstruct_ug_t_28 ug_t;
struct __anonstruct_bg_t_29 {
   s3lmwid_t wid ;
   uint16 probid ;
   uint16 bowtid ;
   uint16 firsttg ;
};
typedef struct __anonstruct_bg_t_29 bg_t;
struct __anonstruct_tg_t_30 {
   s3lmwid_t wid ;
   uint16 probid ;
};
typedef struct __anonstruct_tg_t_30 tg_t;
struct __anonstruct_membg_t_31 {
   bg_t *bg ;
   int32 used ;
};
typedef struct __anonstruct_membg_t_31 membg_t;
struct tginfo_s {
   s3lmwid_t w1 ;
   int32 n_tg ;
   tg_t *tg ;
   int32 bowt ;
   int32 used ;
   struct tginfo_s *next ;
};
typedef struct tginfo_s tginfo_t;
struct __anonstruct_lm_tgcache_entry_t_32 {
   s3lmwid_t lwid[3] ;
   int32 lscr ;
};
typedef struct __anonstruct_lm_tgcache_entry_t_32 lm_tgcache_entry_t;
struct lm_s {
   int32 n_ug ;
   int32 n_bg ;
   int32 n_tg ;
   int32 max_ug ;
   char **wordstr ;
   s3lmwid_t startlwid ;
   s3lmwid_t finishlwid ;
   int32 log_bg_seg_sz ;
   int32 bg_seg_sz ;
   ug_t *ug ;
   bg_t *bg ;
   tg_t *tg ;
   membg_t *membg ;
   tginfo_t **tginfo ;
   lmlog_t *bgprob ;
   lmlog_t *tgprob ;
   lmlog_t *tgbowt ;
   int32 *tg_segbase ;
   int32 n_bgprob ;
   int32 n_tgprob ;
   int32 n_tgbowt ;
   FILE *fp ;
   int32 byteswap ;
   int32 bgoff ;
   int32 tgoff ;
   float32 lw ;
   int32 wip ;
   lm_tgcache_entry_t *tgcache ;
   int32 n_bg_fill ;
   int32 n_bg_inmem ;
   int32 n_bg_score ;
   int32 n_bg_bo ;
   int32 n_tg_fill ;
   int32 n_tg_inmem ;
   int32 n_tg_score ;
   int32 n_tg_bo ;
   int32 n_tgcache_hit ;
   int32 access_type ;
   s3lmwid_t *dict2lmwid ;
   int32 dict_size ;
   lmclass_t *lmclass ;
   int32 n_lmclass ;
   int32 *inclass_ugscore ;
};
typedef struct lm_s lm_t;
struct lmset_s {
   char *name ;
   lm_t *lm ;
};
typedef struct lmset_s lmset_t;
struct __anonstruct_tmat_t_34 {
   int32 ***tp ;
   int32 n_tmat ;
   int32 n_state ;
};
typedef struct __anonstruct_tmat_t_34 tmat_t;
struct __anonstruct_arraysize_t_35 {
   int32 r ;
   int32 c ;
};
typedef struct __anonstruct_arraysize_t_35 arraysize_t;
struct __anonstruct_vector_gautbl_t_38 {
   int32 n_gau ;
   int32 veclen ;
   float32 **mean ;
   float32 **var ;
   float32 *lrd ;
   float64 distfloor ;
};
typedef struct __anonstruct_vector_gautbl_t_38 vector_gautbl_t;
struct __anonstruct_subvq_t_39 {
   arraysize_t origsize ;
   int32 n_sv ;
   int32 vqsize ;
   int32 **featdim ;
   vector_gautbl_t *gautbl ;
   int32 ***map ;
   float32 *subvec ;
   int32 **vqdist ;
   int32 *gauscore ;
   int32 *mgau_sl ;
};
typedef struct __anonstruct_subvq_t_39 subvq_t;
struct gs_s {
   int32 n_mgau ;
   int32 n_feat ;
   int32 n_code ;
   int32 n_density ;
   int32 n_featlen ;
   int32 n_mbyte ;
   float32 **codeword ;
   uint32 ***codemap ;
   FILE *fp ;
   int32 *mgau_sl ;
};
typedef struct gs_s gs_t;
struct __anonstruct_kbcore_t_40 {
   feat_t *fcb ;
   mdef_t *mdef ;
   dict_t *dict ;
   dict2pid_t *dict2pid ;
   lm_t *lm ;
   lmset_t *lmset ;
   fillpen_t *fillpen ;
   s3lmwid_t *dict2lmwid ;
   mgau_model_t *mgau ;
   subvq_t *svq ;
   gs_t *gs ;
   tmat_t *tmat ;
   int32 n_lm ;
   int32 n_alloclm ;
};
typedef struct __anonstruct_kbcore_t_40 kbcore_t;
struct __anonstruct_hmm_state_t_41 {
   int32 score ;
   int32 history ;
};
typedef struct __anonstruct_hmm_state_t_41 hmm_state_t;
struct __anonstruct_hmm_t_42 {
   hmm_state_t *state ;
   hmm_state_t in ;
   hmm_state_t out ;
   int32 **tp ;
   int32 bestscore ;
};
typedef struct __anonstruct_hmm_t_42 hmm_t;
struct __anonstruct_hyp_t_43 {
   int32 id ;
   int32 vhid ;
   int32 sf ;
   int32 ef ;
   int32 ascr ;
   int32 lscr ;
   int32 type ;
};
typedef struct __anonstruct_hyp_t_43 hyp_t;
struct __anonstruct_lm3g_45 {
   s3lmwid_t lwid[2] ;
};
union __anonunion_vh_lmstate_t_44 {
   struct __anonstruct_lm3g_45 lm3g ;
};
typedef union __anonunion_vh_lmstate_t_44 vh_lmstate_t;
struct __anonstruct_vithist_entry_t_46 {
   s3wid_t wid ;
   s3frmid_t sf ;
   s3frmid_t ef ;
   int32 ascr ;
   int32 lscr ;
   int32 score ;
   int32 pred ;
   int32 type ;
   int32 valid ;
   vh_lmstate_t lmstate ;
};
typedef struct __anonstruct_vithist_entry_t_46 vithist_entry_t;
struct __anonstruct_vh_lms2vh_t_47 {
   int32 state ;
   int32 vhid ;
   vithist_entry_t *ve ;
   glist_t children ;
};
typedef struct __anonstruct_vh_lms2vh_t_47 vh_lms2vh_t;
struct __anonstruct_vithist_t_48 {
   vithist_entry_t **entry ;
   int32 *frame_start ;
   int32 n_entry ;
   int32 n_frm ;
   int32 bghist ;
   int32 wbeam ;
   int32 *bestscore ;
   int32 *bestvh ;
   vh_lms2vh_t **lms2vh_root ;
   glist_t lwidlist ;
};
typedef struct __anonstruct_vithist_t_48 vithist_t;
struct __anonstruct_ascr_t_49 {
   int32 *sen ;
   int32 *comsen ;
};
typedef struct __anonstruct_ascr_t_49 ascr_t;
struct __anonstruct_lextree_node_t_50 {
   hmm_t hmm ;
   glist_t children ;
   int32 wid ;
   int32 prob ;
   int32 ssid ;
   s3ssid_t *ssid_lc ;
   s3cipid_t ci ;
   int8 composite ;
   s3frmid_t frame ;
};
typedef struct __anonstruct_lextree_node_t_50 lextree_node_t;
struct __anonstruct_lextree_lcroot_t_51 {
   s3cipid_t lc ;
   glist_t root ;
};
typedef struct __anonstruct_lextree_lcroot_t_51 lextree_lcroot_t;
struct __anonstruct_lextree_t_52 {
   int32 type ;
   glist_t root ;
   lextree_lcroot_t *lcroot ;
   int32 n_lc ;
   int32 n_node ;
   lextree_node_t **active ;
   lextree_node_t **next_active ;
   int32 n_active ;
   int32 n_next_active ;
   int32 best ;
   int32 wbest ;
};
typedef struct __anonstruct_lextree_t_52 lextree_t;
struct __anonstruct_beam_t_53 {
   int32 subvq ;
   int32 hmm ;
   int32 ptrans ;
   int32 word ;
};
typedef struct __anonstruct_beam_t_53 beam_t;
struct __anonstruct_kb_t_54 {
   kbcore_t *kbcore ;
   int32 n_lextree ;
   lextree_t **ugtree ;
   lextree_t **ugtreeMulti ;
   lextree_t **fillertree ;
   int32 n_lextrans ;
   vithist_t *vithist ;
   float32 ***feat ;
   int32 nfr ;
   int32 *ssid_active ;
   int32 *comssid_active ;
   int32 *sen_active ;
   int32 *rec_sen_active ;
   int32 rec_bstcid ;
   int32 rec_bst_senscr ;
   int32 **cache_ci_senscr ;
   int32 *cache_best_list ;
   int32 *phn_heur_list ;
   int32 skip_count ;
   int32 bestscore ;
   int32 bestwordscore ;
   ascr_t *ascr ;
   beam_t *beam ;
   int32 ds_ratio ;
   int32 cond_ds ;
   int32 gs4gs ;
   int32 svq4svq ;
   int32 ci_pbeam ;
   int32 pl_window ;
   int32 pl_window_start ;
   int32 pl_window_effective ;
   int32 pl_beam ;
   int32 wend_beam ;
   char *uttid ;
   int32 utt_hmm_eval ;
   int32 utt_sen_eval ;
   int32 utt_gau_eval ;
   int32 *hmm_hist ;
   int32 hmm_hist_bins ;
   int32 hmm_hist_binsize ;
   ptmr_t tm_sen ;
   ptmr_t tm_srch ;
   ptmr_t tm_ovrhd ;
   int32 tot_fr ;
   float64 tot_sen_eval ;
   float64 tot_gau_eval ;
   float64 tot_hmm_eval ;
   float64 tot_wd_exit ;
   FILE *matchfp ;
   FILE *matchsegfp ;
   hyp_t **hyp_segs ;
   int32 hyp_seglen ;
   char *hyp_str ;
   int32 hyp_strlen ;
};
typedef struct __anonstruct_kb_t_54 kb_t;
typedef int32 argtype_t;
struct __anonstruct_arg_t_12 {
   char *name ;
   argtype_t type ;
   char *deflt ;
   char *doc ;
};
typedef struct __anonstruct_arg_t_12 arg_t;
struct __anonstruct_param_t_54 {
   float SAMPLING_RATE ;
   int32 FRAME_RATE ;
   float WINDOW_LENGTH ;
   int32 FB_TYPE ;
   int32 NUM_CEPSTRA ;
   int32 NUM_FILTERS ;
   int32 FFT_SIZE ;
   float LOWER_FILT_FREQ ;
   float UPPER_FILT_FREQ ;
   float PRE_EMPHASIS_ALPHA ;
   char *wavfile ;
   char *cepfile ;
   char *ctlfile ;
   char *wavdir ;
   char *cepdir ;
   char *wavext ;
   char *cepext ;
   int32 input_format ;
   int32 is_batch ;
   int32 is_single ;
   int32 blocksize ;
   int32 verbose ;
   int32 doublebw ;
};
typedef struct __anonstruct_param_t_54 param_t;
struct __anonstruct_melfb_t_55 {
   float sampling_rate ;
   int32 num_cepstra ;
   int32 num_filters ;
   int32 fft_size ;
   float lower_filt_freq ;
   float upper_filt_freq ;
   float **filter_coeffs ;
   float **mel_cosine ;
   float *left_apex ;
   int32 *width ;
   int32 doublewide ;
};
typedef struct __anonstruct_melfb_t_55 melfb_t;
struct __anonstruct_fe_t_56 {
   float SAMPLING_RATE ;
   int32 FRAME_RATE ;
   int32 FRAME_SHIFT ;
   float WINDOW_LENGTH ;
   int32 FRAME_SIZE ;
   int32 FFT_SIZE ;
   int32 FB_TYPE ;
   int32 NUM_CEPSTRA ;
   float PRE_EMPHASIS_ALPHA ;
   int16 *OVERFLOW_SAMPS ;
   int32 NUM_OVERFLOW_SAMPS ;
   melfb_t *MEL_FB ;
   int32 START_FLAG ;
   int16 PRIOR ;
   double *HAMMING_WINDOW ;
};
typedef struct __anonstruct_fe_t_56 fe_t;
struct mylist_s {
   char **freelist ;
   struct mylist_s *next ;
   int32 elemsize ;
   int32 blocksize ;
   int32 blk_alloc ;
};
typedef struct mylist_s mylist_t;
struct argval_s {
   anytype_t val ;
   void const   *ptr ;
};
typedef struct argval_s argval_t;
typedef float32 *vector_t;
typedef __builtin_va_list __darwin_va_list;
typedef __darwin_va_list va_list;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef unsigned long long __uint64_t;
typedef long __darwin_time_t;
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint64_t __darwin_ino64_t;
typedef __uint16_t __darwin_mode_t;
typedef __uint32_t __darwin_uid_t;
typedef __darwin_off_t off_t;
typedef __darwin_uid_t uid_t;
typedef __darwin_dev_t dev_t;
typedef __darwin_mode_t mode_t;
typedef __darwin_gid_t gid_t;
struct timespec {
   __darwin_time_t tv_sec ;
   long tv_nsec ;
};
typedef __darwin_blkcnt_t blkcnt_t;
typedef __darwin_blksize_t blksize_t;
typedef __uint16_t nlink_t;
struct stat {
   dev_t st_dev ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   __darwin_ino64_t st_ino ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   struct timespec st_atimespec ;
   struct timespec st_mtimespec ;
   struct timespec st_ctimespec ;
   struct timespec st_birthtimespec ;
   off_t st_size ;
   blkcnt_t st_blocks ;
   blksize_t st_blksize ;
   __uint32_t st_flags ;
   __uint32_t st_gen ;
   __int32_t st_lspare ;
   __int64_t st_qspare[2] ;
};
#pragma pack(4)
#pragma pack()
typedef uint32 *bitvec_t;
typedef void *heap_t;
struct heap_s {
   void *data ;
   int32 val ;
   int32 nl ;
   int32 nr ;
   struct heap_s *l ;
   struct heap_s *r ;
};
typedef struct heap_s heapnode_t;
struct __anonstruct_wordprob_t_32 {
   s3wid_t wid ;
   int32 prob ;
};
typedef struct __anonstruct_wordprob_t_32 wordprob_t;
struct lmclass_set_s {
   lmclass_t lmclass_list ;
};
typedef struct lmclass_set_s *lmclass_set_t;
struct __anonstruct_complex_19 {
   double r ;
   double i ;
};
typedef struct __anonstruct_complex_19 complex;
struct __anonstruct_pctr_t_8 {
   char const   *name ;
   int32 count ;
};
typedef struct __anonstruct_pctr_t_8 pctr_t;
typedef int __darwin_ct_rune_t;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
struct __anonstruct__RuneEntry_8 {
   __darwin_rune_t __min ;
   __darwin_rune_t __max ;
   __darwin_rune_t __map ;
   __uint32_t *__types ;
};
typedef struct __anonstruct__RuneEntry_8 _RuneEntry;
struct __anonstruct__RuneRange_9 {
   int __nranges ;
   _RuneEntry *__ranges ;
};
typedef struct __anonstruct__RuneRange_9 _RuneRange;
struct __anonstruct__RuneCharClass_10 {
   char __name[14] ;
   __uint32_t __mask ;
};
typedef struct __anonstruct__RuneCharClass_10 _RuneCharClass;
struct __anonstruct__RuneLocale_11 {
   char __magic[8] ;
   char __encoding[32] ;
   __darwin_rune_t (*__sgetrune)(char const   * , __darwin_size_t  , char const   ** ) ;
   int (*__sputrune)(__darwin_rune_t  , char * , __darwin_size_t  , char ** ) ;
   __darwin_rune_t __invalid_rune ;
   __uint32_t __runetype[1 << 8] ;
   __darwin_rune_t __maplower[1 << 8] ;
   __darwin_rune_t __mapupper[1 << 8] ;
   _RuneRange __runetype_ext ;
   _RuneRange __maplower_ext ;
   _RuneRange __mapupper_ext ;
   void *__variable ;
   int __variable_len ;
   int __ncharclasses ;
   _RuneCharClass *__charclasses ;
};
typedef struct __anonstruct__RuneLocale_11 _RuneLocale;
typedef __uint64_t rlim_t;
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
struct __anonstruct_dagnode_t_46 {
   s3wid_t wid ;
   int32 fef ;
   int32 lef ;
   int32 seqid ;
   glist_t velist ;
};
typedef struct __anonstruct_dagnode_t_46 dagnode_t;
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-H9XZxL9j.i","-O3")
extern FILE *__stdoutp ;
extern int fclose(FILE * ) ;
extern int fflush(FILE * ) ;
extern FILE *fopen(char const   * , char const   * )  __asm__("_fopen")  ;
extern int ( /* format attribute */  fprintf)(FILE * , char const   *  , ...) ;
extern size_t fread(void * , size_t  , size_t  , FILE * ) ;
extern int ( /* format attribute */  fscanf)(FILE * , char const   *  , ...) ;
extern void *calloc(size_t  , size_t  ) ;
extern void *malloc(size_t  ) ;
extern size_t strlen(char const   * ) ;
__inline static char *__inline_strcpy_chk(char *__dest , char const   *__src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcpy_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
void _E__pr_header(char const   *f , long ln , char const   *msg ) ;
void _E__pr_info_header(char const   *f , long ln , char const   *msg ) ;
void _E__pr_info(char const   *fmt  , ...) ;
void _E__die_error(char const   *fmt  , ...) ;
void live_utt_summary(void) ;
void live_utt_set_uttid(char *uttname ) ;
void live_initialize_decoder(char *live_args ) ;
int32 live_utt_decode_block(int16 *samples , int32 nsamples , int32 live_endutt ,
                            partialhyp_t **ohyp ) ;
void parse_args_file(char *live_args ) ;
int32 logs3(float64 p ) ;
kb_t *kb ;
double beams[1000][4]  ;
int main(int argc , char **argv ) 
{ 
  short *samps[10000] ;
  char *uttid[10000] ;
  int uttsize[10000] ;
  int iutt ;
  int nutt ;
  int i ;
  int buflen ;
  int endutt ;
  int blksize ;
  int nhypwds ;
  int nsamp ;
  char *argsfile ;
  char *ctlfile ;
  char *indir ;
  char filename[512] ;
  char cepfile[516] ;
  int filesize ;
  partialhyp_t *parthyp___0 ;
  FILE *fp ;
  FILE *sfp ;
  int ib ;
  int nbeams ;
  FILE *beamsfp ;
  int tmp ;
  short *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
  beamsfp = fopen("beams.dat", "r");
  if ((unsigned long )beamsfp == (unsigned long )((void *)0)) {
    _E__pr_header("spec_main_live_pretend.c", 104L, "FATAL_ERROR");
    _E__die_error("Can\'t find beams.dat\n");
  }
  ib = 0;
  while (1) {
    if (ib < 1000) {
      tmp = fscanf(beamsfp, "%lg%lg%lg%lg", & beams[ib][0], & beams[ib][1], & beams[ib][2],
                   & beams[ib][3]);
      if (! (tmp != -1)) {
        break;
      }
    } else {
      break;
    }
    ib ++;
  }
  nbeams = ib;
  if (nbeams < 1) {
    _E__pr_header("spec_main_live_pretend.c", 117L, "FATAL_ERROR");
    _E__die_error("Not enough beams %d\n", nbeams);
  }
  fclose(beamsfp);
  _E__pr_info_header("spec_main_live_pretend.c", 120L, "INFO");
  _E__pr_info("Processing %d beamsets\n", nbeams);
  if (argc != 4) {
    argsfile = (char *)((void *)0);
    parse_args_file(argsfile);
    _E__pr_header("spec_main_live_pretend.c", 127L, "FATAL_ERROR");
    _E__die_error("\nUSAGE: %s <ctlfile> <inrawdir> <argsfile>\n", *(argv + 0));
  }
  ctlfile = *(argv + 1);
  indir = *(argv + 2);
  argsfile = *(argv + 3);
  blksize = 2000;
  fp = fopen((char const   *)ctlfile, "r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    _E__pr_header("spec_main_live_pretend.c", 132L, "FATAL_ERROR");
    _E__die_error("Unable to read %s\n", ctlfile);
  }
  live_initialize_decoder(argsfile);
  iutt = 0;
  while (1) {
    if (iutt < 10000) {
      tmp___10 = fscanf(fp, "%s%d", filename, & filesize);
      if (! (tmp___10 != -1)) {
        break;
      }
    } else {
      break;
    }
    if (filesize <= 0) {
      _E__pr_header("spec_main_live_pretend.c", 140L, "FATAL_ERROR");
      _E__die_error("Filesize claimed to be %d for %s\n", filesize, filename);
    } else
    if ((unsigned long )filesize % sizeof(short ) != 0UL) {
      _E__pr_header("spec_main_live_pretend.c", 140L, "FATAL_ERROR");
      _E__die_error("Filesize claimed to be %d for %s\n", filesize, filename);
    }
    uttsize[iutt] = (int )((unsigned long )filesize / sizeof(short ));
    tmp___1 = calloc((size_t )uttsize[iutt], sizeof(short ));
    tmp___0 = (short *)tmp___1;
    samps[iutt] = tmp___0;
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      _E__pr_header("spec_main_live_pretend.c", 144L, "FATAL_ERROR");
      _E__die_error("Can\'t allocate %d bytes for file %s\n", filesize, filename);
    }
    tmp___4 = strlen((char const   *)(filename));
    tmp___5 = malloc(1UL + tmp___4);
    tmp___3 = (char *)tmp___5;
    uttid[iutt] = tmp___3;
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      _E__pr_header("spec_main_live_pretend.c", 147L, "FATAL_ERROR");
      tmp___2 = strlen((char const   *)(filename));
      _E__die_error("Can\'t allocate %d bytes for uttid %s", 1UL + tmp___2, filename);
    }
    tmp___7 = __builtin_object_size((void *)uttid[iutt], 0);
    if (tmp___7 != 0xffffffffffffffffUL) {
      tmp___6 = __builtin_object_size((void *)uttid[iutt], 1);
      __builtin___strcpy_chk(uttid[iutt], (char const   *)(filename), tmp___6);
    } else {
      __inline_strcpy_chk(uttid[iutt], (char const   *)(filename));
    }
    tmp___8 = __builtin_object_size((void *)(cepfile), 1);
    __builtin___sprintf_chk(cepfile, 0, tmp___8, "%s/%s.raw", indir, filename);
    sfp = fopen((char const   *)(cepfile), "rb");
    if ((unsigned long )sfp == (unsigned long )((void *)0)) {
      _E__pr_header("spec_main_live_pretend.c", 152L, "FATAL_ERROR");
      _E__die_error("Unable to read %s\n", cepfile);
    }
    tmp___9 = fread((void *)samps[iutt], sizeof(short ), (size_t )uttsize[iutt], sfp);
    nsamp = (int )tmp___9;
    if (nsamp != uttsize[iutt]) {
      _E__pr_header("spec_main_live_pretend.c", 156L, "FATAL_ERROR");
      _E__die_error("Only read %d, expected %d in %s\n", nsamp, uttsize[iutt], filename);
    }
    fprintf(__stdoutp, "%d samples in %s will be decoded in blocks of %d\n", nsamp,
            cepfile, blksize);
    fflush(__stdoutp);
    fclose(sfp);
    iutt ++;
  }
  nutt = iutt;
  ib = 0;
  while (ib < nbeams) {
    (kb->beam)->hmm = logs3(beams[ib][0]);
    (kb->beam)->ptrans = logs3(beams[ib][1]);
    (kb->beam)->word = logs3(beams[ib][2]);
    (kb->beam)->subvq = logs3(beams[ib][3]);
    _E__pr_info_header("spec_main_live_pretend.c", 172L, "INFO");
    _E__pr_info("Beam= %d, PBeam= %d, WBeam= %d, SVQBeam= %d\n", (kb->beam)->hmm,
                (kb->beam)->ptrans, (kb->beam)->word, (kb->beam)->subvq);
    iutt = 0;
    while (iutt < nutt) {
      live_utt_set_uttid(uttid[iutt]);
      i = 0;
      while (i < uttsize[iutt]) {
        if (i + blksize < uttsize[iutt]) {
          buflen = blksize;
        } else {
          buflen = uttsize[iutt] - i;
        }
        if (i + blksize <= uttsize[iutt] - 1) {
          endutt = 0;
        } else {
          endutt = 1;
        }
        nhypwds = live_utt_decode_block(samps[iutt] + i, buflen, endutt, & parthyp___0);
        i += blksize;
      }
      iutt ++;
    }
    ib ++;
  }
  live_utt_summary();
  return (0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-qpp2KDpT.i","-O3")
extern FILE *__stderrp ;
extern char *fgets(char * , int  , FILE * ) ;
extern void rewind(FILE * ) ;
extern void free(void * ) ;
extern char *strtok(char * , char const   * ) ;
void *__ckd_calloc__(size_t n_elem , size_t elem_size , char const   *caller_file ,
                     int caller_line ) ;
void **__ckd_calloc_2d__(int32 d1 , int32 d2 , int32 elemsize , char const   *caller_file ,
                         int32 caller_line ) ;
void ckd_free_2d(void **ptr ) ;
int32 cmd_ln_parse(arg_t *defn , int32 argc , char **argv ) ;
void cmd_ln_print_help(FILE *fp , arg_t *defn ) ;
void cmd_ln_free(void) ;
void parse_args_free(void) ;
static arg_t arg[77]  = 
  {      {(char *)"-logbase", 4, (char *)"1.0003", (char *)"Base in which all log-likelihoods calculated"}, 
        {(char *)"-feat",
      8, (char *)"1s_c_d_dd", (char *)"Feature type: Must be s3_1x39 / s2_4x / cep_dcep[,%d] / cep[,%d] / %d,%d,...,%d"}, 
        {(char *)"-gs",
      8, (char *)((void *)0), (char *)"Gaussian Selection Mapping."}, 
        {(char *)"-ds", 2, (char *)"1", (char *)"Ratio of Down-sampling the frame computation."}, 
        {(char *)"-cond_ds",
      2, (char *)"0", (char *)"Conditional Down-sampling, override normal down sampling."}, 
        {(char *)"-gs4gs",
      2, (char *)"1", (char *)"A flag that specified whether the input GS map will be used for Gaussian Selection. If it is disabled, the map will only provide information to other modules."}, 
        {(char *)"-svq4svq",
      2, (char *)"0", (char *)"A flag that specified whether the input SVQ will be used as approximate scores of the Gaussians"}, 
        {(char *)"-ci_pbeam",
      4, (char *)"1e-80", (char *)"CI phone beam for CI-based GMM Selection. Good number should be [0(widest) .. 1(narrowest)]"}, 
        {(char *)"-wend_beam",
      4, (char *)"1.0e-80", (char *)"Beam selecting word-final HMMs exiting in each frame [0(widest) .. 1(narrowest)]"}, 
        {(char *)"-pl_window",
      2, (char *)"1", (char *)"Window size (actually window size-1) of phoneme look-ahead."}, 
        {(char *)"-pheurtype",
      2, (char *)"0", (char *)"0 = bypass, 1= sum of max, 2 = sum of avg, 3 = sum of 1st senones only"}, 
        {(char *)"-pl_beam",
      4, (char *)"1.0e-80", (char *)"Beam for phoneme look-ahead. [0(widest) .. 1(narrowest)]"}, 
        {(char *)"-ctl",
      8, (char *)((void *)0), (char *)"Control file listing utterances to be processed"}, 
        {(char *)"-ctl_lm",
      8, (char *)((void *)0), (char *)"Control file that list the corresponding LMs"}, 
        {(char *)"-beam",
      6, (char *)"1.0e-55", (char *)"Beam selecting active HMMs (relative to best) in each frame [0(widest)..1(narrowest)]"}, 
        {(char *)"-pbeam",
      6, (char *)"1.0e-50", (char *)"Beam selecting HMMs transitioning to successors in each frame [0(widest)..1(narrowest)]"}, 
        {(char *)"-wbeam",
      6, (char *)"1.0e-35", (char *)"Beam selecting word-final HMMs exiting in each frame [0(widest)..1(narrowest)]"}, 
        {(char *)"-lminmemory",
      2, (char *)"0", (char *)"Load language model into memory (default: use disk cache for lm"}, 
        {(char *)"-log3table",
      2, (char *)"1", (char *)"Determines whether to use the log3 table or to compute the values at run time."}, 
        {(char *)"-vqeval",
      2, (char *)"3", (char *)"How many vectors should be analyzed by VQ when building the shortlist. It speeds up the decoder, but at a cost."}, 
        {(char *)"-senmgau",
      8, (char *)".cont.", (char *)"Senone to mixture-gaussian mapping file (or .semi. or .cont.)"}, 
        {(char *)"-cmn",
      8, (char *)"current", (char *)"Cepstral mean normalization scheme (default: Cep -= mean-over-current-sentence(Cep))"}, 
        {(char *)"-varnorm",
      8, (char *)"no", (char *)"Variance normalize each utterance (yes/no; only applicable if CMN is also performed)"}, 
        {(char *)"-agc",
      8, (char *)"max", (char *)"Automatic gain control for c0 (\'max\' or \'none\'); (max: c0 -= max-over-current-sentence(c0))"}, 
        {(char *)"-mdef",
      9, (char *)((void *)0), (char *)"Model definition input file"}, 
        {(char *)"-dict", 9, (char *)((void *)0), (char *)"Pronunciation dictionary input file"}, 
        {(char *)"-fdict",
      9, (char *)((void *)0), (char *)"Filler word pronunciation dictionary input file"}, 
        {(char *)"-lm",
      9, (char *)((void *)0), (char *)"Word trigram language model input file"}, 
        {(char *)"-fillpen", 8, (char *)((void *)0), (char *)"Filler word probabilities input file"}, 
        {(char *)"-silprob",
      4, (char *)"0.1", (char *)"Default silence word probability"}, 
        {(char *)"-fillprob", 4, (char *)"0.1", (char *)"Default non-silence filler word probability"}, 
        {(char *)"-lw",
      4, (char *)"8.5", (char *)"Language weight"}, 
        {(char *)"-wip", 4, (char *)"0.7", (char *)"Word insertion penalty"}, 
        {(char *)"-uw", 4, (char *)"0.7", (char *)"Unigram weight"}, 
        {(char *)"-mean", 9, (char *)((void *)0), (char *)"Mixture gaussian means input file"}, 
        {(char *)"-var",
      9, (char *)((void *)0), (char *)"Mixture gaussian variances input file"}, 
        {(char *)"-varfloor", 4, (char *)"0.0001", (char *)"Mixture gaussian variance floor (applied to data from -var file)"}, 
        {(char *)"-mixw",
      9, (char *)((void *)0), (char *)"Senone mixture weights input file"}, 
        {(char *)"-mixwfloor", 4, (char *)"0.0000001", (char *)"Senone mixture weights floor (applied to data from -mixw file)"}, 
        {(char *)"-subvq",
      8, (char *)((void *)0), (char *)"Sub-vector quantized form of acoustic model"}, 
        {(char *)"-tmat",
      9, (char *)((void *)0), (char *)"HMM state transition matrix input file"}, 
        {(char *)"-tmatfloor", 4, (char *)"0.0001", (char *)"HMM state transition probability floor (applied to -tmat file)"}, 
        {(char *)"-Nlextree",
      2, (char *)"3", (char *)"No. of lextrees to be instantiated; entries into them staggered in time"}, 
        {(char *)"-epl",
      2, (char *)"3", (char *)"Entries Per Lextree; #successive entries into one lextree before lextree-entries shifted to the next"}, 
        {(char *)"-subvqbeam",
      6, (char *)"3.0e-3", (char *)"Beam selecting best components within each mixture Gaussian [0(widest)..1(narrowest)]"}, 
        {(char *)"-utt",
      8, (char *)((void *)0), (char *)"Utterance file to be processed (-ctlcount argument times)"}, 
        {(char *)"-ctloffset",
      2, (char *)"0", (char *)"No. of utterances at the beginning of -ctl file to be skipped"}, 
        {(char *)"-ctlcount",
      2, (char *)"1000000000", (char *)"No. of utterances to be processed (after skipping -ctloffset entries)"}, 
        {(char *)"-cepdir",
      8, (char *)((void *)0), (char *)"Input cepstrum files directory (prefixed to filespecs in control file)"}, 
        {(char *)"-bptbldir",
      8, (char *)((void *)0), (char *)"Directory in which to dump word Viterbi back pointer table (for debugging)"}, 
        {(char *)"-outlatdir",
      8, (char *)((void *)0), (char *)"Directory in which to dump word lattices"}, 
        {(char *)"-outlatoldfmt",
      2, (char *)"1", (char *)"Whether to dump lattices in old format"}, 
        {(char *)"-latext", 8, (char *)"lat.gz", (char *)"Filename extension for lattice files (gzip compressed, by default)"}, 
        {(char *)"-hmmdump",
      2, (char *)"0", (char *)"Whether to dump active HMM details to stderr (for debugging)"}, 
        {(char *)"-lextreedump",
      2, (char *)"0", (char *)"Whether to dump the lextree structure to stderr (for debugging)"}, 
        {(char *)"-maxwpf",
      2, (char *)"20", (char *)"Max no. of distinct word exits to maintain at each frame"}, 
        {(char *)"-maxhistpf",
      2, (char *)"100", (char *)"Max no. of histories to maintain at each frame"}, 
        {(char *)"-bghist",
      2, (char *)"0", (char *)"Bigram-mode: If TRUE only one BP entry/frame; else one per LM state"}, 
        {(char *)"-maxhmmpf",
      2, (char *)"20000", (char *)"Max no. of active HMMs to maintain at each frame; approx."}, 
        {(char *)"-hmmhistbinsize",
      2, (char *)"5000", (char *)"Performance histogram: #frames vs #HMMs active; #HMMs/bin in this histogram"}, 
        {(char *)"-ptranskip",
      2, (char *)"0", (char *)"Use wbeam for phone transitions every so many frames (if >= 1)"}, 
        {(char *)"-hyp",
      8, (char *)((void *)0), (char *)"Recognition result file, with only words"}, 
        {(char *)"-hypseg",
      8, (char *)((void *)0), (char *)"Recognition result file, with word segmentations and scores"}, 
        {(char *)"-treeugprob",
      2, (char *)"1", (char *)"If TRUE (non-0), Use unigram probs in lextree"}, 
        {(char *)"-maxhyplen", 2, (char *)"1000", (char *)"Maximum number of words in a partial hypothesis (for block decoding)"}, 
        {(char *)"-maxcepvecs",
      2, (char *)"256", (char *)"Maximum number of cepstral vectors that can be obtained from a single sample buffer"}, 
        {(char *)"-samprate",
      2, (char *)"8000", (char *)"Sampling rate (only 8K and 16K currently supported)"}, 
        {(char *)"-nfilt",
      2, (char *)"31", (char *)"Number of mel filters"}, 
        {(char *)"-lowerf", 4, (char *)"200", (char *)"Lower edge of filters"}, 
        {(char *)"-upperf", 4, (char *)"3500", (char *)"Upper edge of filters"}, 
        {(char *)"-alpha", 4, (char *)"0.97", (char *)"alpha for pre-emphasis window"}, 
        {(char *)"-frate",
      2, (char *)"100", (char *)"frame rate"}, 
        {(char *)"-nfft", 2, (char *)"256", (char *)"no. pts for FFT"}, 
        {(char *)"-wlen", 4, (char *)"0.0256", (char *)"window length"}, 
        {(char *)"-lmdumpdir", 8, (char *)((void *)0), (char *)"The directory for dumping the DMP file. "}, 
        {(char *)"-lmctlfn",
      8, (char *)((void *)0), (char *)"Control file for language model\n"}, 
        {(char *)((void *)0), 2, (char *)((void *)0), (char *)((void *)0)}};
static char **liveargs  =    (char **)((void *)0);
static int32 nliveargs  ;
void parse_args_file(char *live_args ) 
{ 
  int32 nargs ;
  int32 maxarglen ;
  char *argline ;
  char *targ ;
  FILE *fp ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  void **tmp___5 ;
  int32 tmp___6 ;
  int32 tmp___10 ;
  char *tmp___14 ;

  {
  if ((unsigned long )live_args == (unsigned long )((void *)0)) {
    cmd_ln_print_help(__stderrp, arg);
    return;
  }
  fp = fopen((char const   *)live_args, "r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    _E__pr_header("parse_args_file.c", 388L, "FATAL_ERROR");
    _E__die_error("Unable to open arguments file %s for reading\n", live_args);
  }
  tmp = __ckd_calloc__((size_t )10000, sizeof(char ), "parse_args_file.c", 390);
  argline = (char *)tmp;
  nargs = 1;
  maxarglen = 0;
  while (1) {
    tmp___4 = fgets(argline, 10000, fp);
    if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
      break;
    }
    targ = strtok(argline, " \t\n");
    if ((unsigned long )targ == (unsigned long )((void *)0)) {
      continue;
    }
    tmp___1 = strlen((char const   *)targ);
    if ((int32 )tmp___1 > maxarglen) {
      tmp___0 = strlen((char const   *)targ);
      maxarglen = (int32 )tmp___0;
    }
    nargs ++;
    while (1) {
      targ = strtok((char *)((void *)0), " \t\n");
      if (! ((unsigned long )targ != (unsigned long )((void *)0))) {
        break;
      }
      tmp___3 = strlen((char const   *)targ);
      if ((int32 )tmp___3 > maxarglen) {
        tmp___2 = strlen((char const   *)targ);
        maxarglen = (int32 )tmp___2;
      }
      nargs ++;
    }
  }
  rewind(fp);
  nliveargs = nargs;
  tmp___5 = __ckd_calloc_2d__(nargs, maxarglen + 1, (int32 )sizeof(char ), "parse_args_file.c",
                              407);
  liveargs = (char **)tmp___5;
  nargs = 1;
  while (1) {
    tmp___14 = fgets(argline, 10000, fp);
    if (! ((unsigned long )tmp___14 != (unsigned long )((void *)0))) {
      break;
    }
    targ = strtok(argline, " \t\n");
    if ((unsigned long )targ == (unsigned long )((void *)0)) {
      continue;
    }
    tmp___6 = nargs;
    nargs ++;
    __inline_strcpy_chk(*(liveargs + tmp___6), (char const   *)targ);
    while (1) {
      targ = strtok((char *)((void *)0), " \t\n");
      if (! ((unsigned long )targ != (unsigned long )((void *)0))) {
        break;
      }
      tmp___10 = nargs;
      nargs ++;
      __inline_strcpy_chk(*(liveargs + tmp___10), (char const   *)targ);
    }
  }
  fclose(fp);
  free((void *)argline);
  cmd_ln_parse(arg, nliveargs, liveargs);
  return;
}
}
void parse_args_free(void) 
{ 


  {
  cmd_ln_free();
  ckd_free_2d((void **)liveargs);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-el1OsxsQ.i","-O3")
extern char *strdup(char const   * ) ;
void ckd_free(void *ptr ) ;
void const   *cmd_ln_access(char *name ) ;
void glist_free(glist_t g ) ;
void unlimit(void) ;
float32 ***feat_array_alloc(feat_t *fcb , int32 nfr ) ;
int32 feat_s2mfc2feat_block(feat_t *fcb , float32 **uttcep , int32 nfr , int32 beginutt ,
                            int32 endutt , float32 ***ofeat ) ;
int32 vithist_utt_end(vithist_t *vh , kbcore_t *kbc ) ;
int32 vithist_partialutt_end(vithist_t *vh , kbcore_t *kbc ) ;
glist_t vithist_backtrace(vithist_t *vh , int32 id ) ;
void kb_init(kb_t *kb___0 ) ;
void kb_free(kb_t *kb___0 ) ;
void utt_begin(kb_t *kb___0 ) ;
void utt_end(kb_t *kb___0 ) ;
void utt_decode_block(float ***block_feat , int32 block_nfeatvec , int32 *curfrm ,
                      kb_t *kb___0 , int32 maxwpf___0 , int32 maxhistpf___0 , int32 maxhmmpf___0 ,
                      int32 ptranskip___0 , FILE *hmmdumpfp___0 ) ;
fe_t *fe_init(param_t *P ) ;
int fe_start_utt(fe_t *FE ) ;
int fe_end_utt(fe_t *FE , float *cepvector ) ;
int fe_close(fe_t *FE ) ;
int fe_process_utt(fe_t *FE , int16 *spch , int nsamps , float32 ***cep_block ) ;
int32 live_get_partialhyp(int32 endutt ) ;
int32 live_free_memory(void) ;
static fe_t *fe  ;
kb_t *kb  ;
static kbcore_t *kbcore  ;
static FILE *hmmdumpfp  ;
static int32 maxwpf  ;
static int32 maxhistpf  ;
static int32 maxhmmpf  ;
static int32 ptranskip  ;
static partialhyp_t *parthyp  =    (partialhyp_t *)((void *)0);
static float32 *dummyframe  ;
static kb_t live_kb  ;
void live_initialize_decoder(char *live_args ) 
{ 
  int32 maxcepvecs ;
  int32 maxhyplen ;
  int32 samprate ;
  int32 ceplen ;
  param_t *fe_param ;
  void *tmp ;
  void const   *tmp___1 ;
  void const   *tmp___2 ;
  void const   *tmp___3 ;
  void const   *tmp___4 ;
  void const   *tmp___5 ;
  void const   *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void const   *tmp___9 ;
  void const   *tmp___10 ;
  void const   *tmp___11 ;
  void const   *tmp___12 ;
  void const   *tmp___13 ;
  void const   *tmp___14 ;
  void const   *tmp___15 ;
  void const   *tmp___16 ;
  void const   *tmp___17 ;
  void *tmp___18 ;

  {
  parse_args_file(live_args);
  unlimit();
  kb_init(& live_kb);
  kb = & live_kb;
  kbcore = kb->kbcore;
  tmp = __ckd_calloc__((size_t )1000, sizeof(char ), "live.c", 93);
  kb->uttid = (char *)tmp;
  tmp___1 = cmd_ln_access((char *)"-hmmdump");
  if (*((int32 *)tmp___1)) {
    hmmdumpfp = __stderrp;
  } else {
    hmmdumpfp = (FILE *)((void *)0);
  }
  tmp___2 = cmd_ln_access((char *)"-maxwpf");
  maxwpf = *((int32 *)tmp___2);
  tmp___3 = cmd_ln_access((char *)"-maxhistpf");
  maxhistpf = *((int32 *)tmp___3);
  tmp___4 = cmd_ln_access((char *)"-maxhmmpf");
  maxhmmpf = *((int32 *)tmp___4);
  tmp___5 = cmd_ln_access((char *)"-ptranskip");
  ptranskip = *((int32 *)tmp___5);
  tmp___6 = cmd_ln_access((char *)"-maxhyplen");
  maxhyplen = *((int32 *)tmp___6);
  if (! parthyp) {
    tmp___7 = __ckd_calloc__((size_t )maxhyplen, sizeof(partialhyp_t ), "live.c",
                             102);
    parthyp = (partialhyp_t *)tmp___7;
  }
  tmp___8 = __ckd_calloc__((size_t )1, sizeof(param_t ), "live.c", 104);
  fe_param = (param_t *)tmp___8;
  tmp___9 = cmd_ln_access((char *)"-samprate");
  samprate = *((int32 *)tmp___9);
  if (samprate != 8000) {
    if (samprate != 16000) {
      _E__pr_header("live.c", 107L, "FATAL_ERROR");
      _E__die_error("Sampling rate %s not supported. Must be 8000 or 16000\n", samprate);
    }
  }
  fe_param->SAMPLING_RATE = (float32 )samprate;
  tmp___10 = cmd_ln_access((char *)"-lowerf");
  fe_param->LOWER_FILT_FREQ = *((float32 *)tmp___10);
  tmp___11 = cmd_ln_access((char *)"-upperf");
  fe_param->UPPER_FILT_FREQ = *((float32 *)tmp___11);
  tmp___12 = cmd_ln_access((char *)"-nfilt");
  fe_param->NUM_FILTERS = *((int32 *)tmp___12);
  tmp___13 = cmd_ln_access((char *)"-frate");
  fe_param->FRAME_RATE = *((int32 *)tmp___13);
  tmp___14 = cmd_ln_access((char *)"-alpha");
  fe_param->PRE_EMPHASIS_ALPHA = *((float32 *)tmp___14);
  tmp___15 = cmd_ln_access((char *)"-nfft");
  fe_param->FFT_SIZE = *((int32 *)tmp___15);
  tmp___16 = cmd_ln_access((char *)"-wlen");
  fe_param->WINDOW_LENGTH = *((float32 *)tmp___16);
  fe_param->doublebw = 0;
  fe = fe_init(fe_param);
  if (! fe) {
    _E__pr_header("live.c", 127L, "FATAL_ERROR");
    _E__die_error("Front end initialization fe_init() failed\n");
  }
  tmp___17 = cmd_ln_access((char *)"-maxcepvecs");
  maxcepvecs = *((int32 *)tmp___17);
  ceplen = (kbcore->fcb)->cepsize;
  tmp___18 = __ckd_calloc__((size_t )ceplen, sizeof(float32 ), "live.c", 132);
  dummyframe = (float32 *)tmp___18;
  return;
}
}
int32 live_free_memory(void) 
{ 


  {
  parse_args_free();
  fe_close(fe);
  ckd_free((void *)kb->uttid);
  kb_free(kb);
  ckd_free((void *)dummyframe);
  ckd_free((void *)parthyp);
  return (0);
}
}
int32 live_get_partialhyp(int32 endutt ) 
{ 
  int32 id ;
  int32 nwds ;
  glist_t hyp ;
  gnode_t *gn ;
  hyp_t *h ;
  dict_t *dict ;

  {
  dict = (kb->kbcore)->dict;
  if (endutt) {
    id = vithist_utt_end(kb->vithist, kb->kbcore);
  } else {
    id = vithist_partialutt_end(kb->vithist, kb->kbcore);
  }
  if (id > 0) {
    hyp = vithist_backtrace(kb->vithist, id);
    gn = hyp;
    nwds = 0;
    while (gn) {
      h = (hyp_t *)gn->data.ptr;
      if ((unsigned long )(parthyp + nwds)->word != (unsigned long )((void *)0)) {
        ckd_free((void *)(parthyp + nwds)->word);
        (parthyp + nwds)->word = (char *)((void *)0);
      }
      (parthyp + nwds)->word = strdup((char const   *)(dict->word + h->id)->word);
      (parthyp + nwds)->sf = h->sf;
      (parthyp + nwds)->ef = h->ef;
      (parthyp + nwds)->ascr = h->ascr;
      (parthyp + nwds)->lscr = h->lscr;
      gn = gn->next;
      nwds ++;
    }
    if ((unsigned long )(parthyp + nwds)->word != (unsigned long )((void *)0)) {
      ckd_free((void *)(parthyp + nwds)->word);
      (parthyp + nwds)->word = (char *)((void *)0);
    }
    gn = hyp;
    while (1) {
      if (gn) {
        if (! gn->next) {
          break;
        }
      } else {
        break;
      }
      h = (hyp_t *)gn->data.ptr;
      ckd_free((void *)h);
      gn = gn->next;
    }
    glist_free(hyp);
  } else {
    nwds = 0;
    if ((unsigned long )(parthyp + nwds)->word != (unsigned long )((void *)0)) {
      ckd_free((void *)(parthyp + nwds)->word);
      (parthyp + nwds)->word = (char *)((void *)0);
    }
  }
  return (nwds);
}
}
void live_utt_set_uttid(char *uttname ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size((void *)kb->uttid, 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)kb->uttid, 1);
    __builtin___strcpy_chk(kb->uttid, (char const   *)uttname, tmp);
  } else {
    __inline_strcpy_chk(kb->uttid, (char const   *)uttname);
  }
  return;
}
}
static int32 live_begin_new_utt  =    1;
static int32 frmno  ;
static float32 ***live_feat  =    (float32 ***)((void *)0);
int32 live_utt_decode_block(int16 *samples , int32 nsamples , int32 live_endutt ,
                            partialhyp_t **ohyp ) 
{ 
  int32 live_nfr ;
  int32 live_nfeatvec ;
  int32 nwds ;
  float32 **mfcbuf ;

  {
  nwds = 0;
  if ((unsigned long )live_feat == (unsigned long )((void *)0)) {
    live_feat = feat_array_alloc(kbcore->fcb, 256);
  }
  if (live_begin_new_utt) {
    fe_start_utt(fe);
    utt_begin(kb);
    frmno = 0;
    kb->nfr = 0;
    kb->utt_hmm_eval = 0;
    kb->utt_sen_eval = 0;
    kb->utt_gau_eval = 0;
    live_begin_new_utt = 0;
  }
  mfcbuf = (float32 **)((void *)0);
  live_nfr = fe_process_utt(fe, samples, nsamples, & mfcbuf);
  if (live_endutt) {
    fe_end_utt(fe, dummyframe);
  }
  if (live_nfr > 0) {
    live_nfeatvec = feat_s2mfc2feat_block(kbcore->fcb, mfcbuf, live_nfr, live_begin_new_utt,
                                          live_endutt, live_feat);
    utt_decode_block(live_feat, live_nfeatvec, & frmno, kb, maxwpf, maxhistpf, maxhmmpf,
                     ptranskip, hmmdumpfp);
    nwds = live_get_partialhyp(live_endutt);
    *ohyp = parthyp;
  }
  if (live_endutt) {
    live_begin_new_utt = 1;
    kb->tot_fr += kb->nfr;
    utt_end(kb);
  } else {
    live_begin_new_utt = 0;
  }
  if (live_nfr > 0) {
    ckd_free_2d((void **)mfcbuf);
  }
  return (nwds);
}
}
long tot_considered ;
FILE *confp ;
int confp_open ;
void live_utt_summary(void) 
{ 


  {
  _E__pr_info_header("live.c", 354L, "INFO");
  _E__pr_info("SUMMARY:  %d fr;  %d sen, %d gau/fr, %.2f xCPU [%.2f xOvrhd];  %d hmm/fr, %d wd/fr, %.2f xCPU;  \n",
              kb->tot_fr, (int32 )(kb->tot_sen_eval / (float64 )kb->tot_fr), (int32 )(kb->tot_gau_eval / (float64 )kb->tot_fr),
              0.0, 0.0, (int32 )(kb->tot_hmm_eval / (float64 )kb->tot_fr), (int32 )(kb->tot_wd_exit / (float64 )kb->tot_fr),
              0.0);
  if (confp_open) {
    fclose(confp);
  }
  confp = fopen("total_considered.out", "w");
  if ((unsigned long )confp == (unsigned long )((void *)0)) {
    _E__pr_header("live.c", 365L, "FATAL_ERROR");
    _E__die_error("fopen considered_total.out failed\n");
  }
  fprintf(confp, "%22d grand total considered\n", tot_considered);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-2zWAPIfN.i","-O3")
void agc_max(float **mfc , int32 n_frame ) ;
void agc_max(float **mfc , int32 n_frame ) 
{ 
  float32 maxc0 ;
  int32 i ;

  {
  maxc0 = *(*(mfc + 0) + 0);
  i = 1;
  while (i < n_frame) {
    if (*(*(mfc + i) + 0) > maxc0) {
      maxc0 = *(*(mfc + i) + 0);
    }
    i ++;
  }
  i = 0;
  while (i < n_frame) {
    *(*(mfc + i) + 0) -= maxc0;
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-MkKM1VGV.i","-O3")
void ptmr_start(ptmr_t *tm ) ;
void ptmr_stop(ptmr_t *tm ) ;
int32 mgau_eval(mgau_model_t *g , int32 m , int32 *active , float32 *x___0 ) ;
void subvq_gautbl_eval_logs3(subvq_t *vq , float32 *feat ) ;
int32 subvq_mgau_shortlist(subvq_t *vq , int32 m , int32 n , int32 beam ) ;
int32 subvq_mgau_eval(mgau_model_t *g , subvq_t *vq , int32 m , int32 n , int32 *active ) ;
int32 gc_compute_closest_cw(gs_t *gs , float32 *feat ) ;
int32 gs_mgau_shortlist(gs_t *gs , int m , int n , float32 *feat , int bst_codeid ) ;
int32 approx_isskip(int32 frame , int32 ds_ratio , int32 cond_ds , int32 isSameBestIdx ,
                    int32 *skip_count ) ;
int32 approx_cont_mgau_frame_eval(mgau_model_t *g , gs_t *gs , subvq_t *svq , int32 svq_beam ,
                                  float32 *feat , int32 *sen_active , int32 *senscr ,
                                  int32 *cache_ci_senscr , kb_t *kb___0 , int32 frame ) ;
void approx_cont_mgau_ci_eval(mgau_model_t *g , float32 *feat , int32 *ci_senscr ,
                              kb_t *kb___0 ) ;
int32 most_recent_best_cid  =    -1;
int32 approx_isskip(int32 frame , int32 ds_ratio , int32 cond_ds , int32 isSameBestIdx ,
                    int32 *skip_count ) 
{ 
  int32 *tmp ;

  {
  if (cond_ds > 0) {
    if (isSameBestIdx) {
      if (*skip_count < ds_ratio - 1) {
        tmp = skip_count;
        skip_count ++;
        return (1);
      } else {
        *skip_count = 0;
        return (0);
      }
    } else {
      return (0);
    }
  }
  if (frame % ds_ratio == 0) {
    return (0);
  } else {
    return (1);
  }
}
}
int32 approx_mgau_eval(gs_t *gs , subvq_t *svq , mgau_model_t *g , kb_t *kb___0 ,
                       int32 s___0 , int32 *senscr , float32 *feat , int32 best_cid ,
                       int32 svq_beam ) 
{ 
  int32 ng ;
  int32 *mgau_sl ;

  {
  ng = 0;
  if (gs) {
    if (kb___0->gs4gs) {
      ng = gs_mgau_shortlist(gs, s___0, (g->mgau + s___0)->n_comp, feat, best_cid);
      mgau_sl = gs->mgau_sl;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (svq) {
    ng = subvq_mgau_shortlist(svq, s___0, (g->mgau + s___0)->n_comp, svq_beam);
    mgau_sl = svq->mgau_sl;
  } else {
    ng = (g->mgau + s___0)->n_comp;
    mgau_sl = (int32 *)((void *)0);
  }
  if (ng == 0) {
    mgau_sl = (int32 *)((void *)0);
    ng = (g->mgau + s___0)->n_comp;
  }
  if (svq) {
    if (kb___0->svq4svq) {
      *(senscr + s___0) = subvq_mgau_eval(g, svq, s___0, (g->mgau + s___0)->n_comp,
                                          mgau_sl);
    } else {
      *(senscr + s___0) = mgau_eval(g, s___0, mgau_sl, feat);
    }
  } else {
    *(senscr + s___0) = mgau_eval(g, s___0, mgau_sl, feat);
  }
  if (*(senscr + s___0) < -939424096) {
    if (! ((unsigned long )mgau_sl == (unsigned long )((void *)0))) {
      mgau_sl = (int32 *)((void *)0);
      ng += (g->mgau + s___0)->n_comp;
      if (svq) {
        if (kb___0->svq4svq) {
          *(senscr + s___0) = subvq_mgau_eval(g, svq, s___0, (g->mgau + s___0)->n_comp,
                                              (int32 *)((void *)0));
        } else {
          *(senscr + s___0) = mgau_eval(g, s___0, (int32 *)((void *)0), feat);
        }
      } else {
        *(senscr + s___0) = mgau_eval(g, s___0, (int32 *)((void *)0), feat);
      }
    }
  }
  return (ng);
}
}
void approx_cont_mgau_ci_eval(mgau_model_t *g , float32 *feat , int32 *ci_senscr ,
                              kb_t *kb___0 ) 
{ 
  int32 s___0 ;
  mdef_t *mdef ;
  s3senid_t *cd2cisen ;

  {
  mdef = (kb___0->kbcore)->mdef;
  cd2cisen = mdef->cd2cisen;
  s___0 = 0;
  while (s___0 == (int32 )*(cd2cisen + s___0)) {
    *(ci_senscr + s___0) = mgau_eval(g, s___0, (int32 *)((void *)0), feat);
    s___0 ++;
  }
  return;
}
}
int32 approx_cont_mgau_frame_eval(mgau_model_t *g , gs_t *gs , subvq_t *svq , int32 svq_beam ,
                                  float32 *feat , int32 *sen_active , int32 *senscr ,
                                  int32 *cache_ci_senscr , kb_t *kb___0 , int32 frame ) 
{ 
  int32 s___0 ;
  int32 t ;
  int32 best ;
  int32 ns ;
  int32 ng ;
  int32 best_cid ;
  int32 is_skip ;
  int32 is_compute ;
  int32 pbest ;
  int32 is_ciphone ;
  mdef_t *mdef ;
  s3senid_t *cd2cisen ;
  int tmp ;
  int32 tmp___0 ;
  int32 tmp___1 ;

  {
  best = (int32 )2147483648U;
  pbest = (int32 )2147483648U;
  ns = 0;
  ng = 0;
  best_cid = -1;
  ptmr_start(& kb___0->tm_ovrhd);
  if (gs) {
    best_cid = gc_compute_closest_cw(gs, feat);
  }
  if (svq) {
    subvq_gautbl_eval_logs3(svq, feat);
  }
  ptmr_stop(& kb___0->tm_ovrhd);
  is_skip = approx_isskip(frame, kb___0->ds_ratio, kb___0->cond_ds, kb___0->rec_bstcid == best_cid,
                          & kb___0->skip_count);
  kb___0->rec_bstcid = best_cid;
  mdef = (kb___0->kbcore)->mdef;
  cd2cisen = mdef->cd2cisen;
  s___0 = 0;
  while (s___0 < g->n_mgau) {
    if (! sen_active) {
      tmp = 1;
    } else
    if (*(sen_active + s___0)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    is_compute = tmp;
    is_ciphone = s___0 == (int32 )*(cd2cisen + s___0);
    if (! is_skip) {
      if (is_ciphone) {
        *(senscr + s___0) = *(cache_ci_senscr + s___0);
        if (pbest < *(senscr + s___0)) {
          pbest = *(senscr + s___0);
        }
        if (best < *(senscr + s___0)) {
          best = *(senscr + s___0);
        }
        *(sen_active + s___0) = 1;
        ng += (g->mgau + s___0)->n_comp;
        ns ++;
      } else
      if (is_compute) {
        if (pbest - *(senscr + *(cd2cisen + s___0)) < kb___0->ci_pbeam) {
          tmp___0 = approx_mgau_eval(gs, svq, g, kb___0, s___0, senscr, feat, best_cid,
                                     svq_beam);
          ng += tmp___0;
          ns ++;
        } else {
          *(senscr + s___0) = *(senscr + *(cd2cisen + s___0));
        }
        if (best < *(senscr + s___0)) {
          best = *(senscr + s___0);
        }
      }
      *(kb___0->rec_sen_active + s___0) = *(sen_active + s___0);
    } else
    if (is_compute) {
      if (*(kb___0->rec_sen_active + s___0)) {
        *(senscr + s___0) = *(senscr + s___0);
      } else {
        *(kb___0->rec_sen_active + s___0) = 1;
        tmp___1 = approx_mgau_eval(gs, svq, g, kb___0, s___0, senscr, feat, best_cid,
                                   svq_beam);
        ng += tmp___1;
        ns ++;
        if (*(senscr + s___0) > kb___0->rec_bst_senscr) {
          _E__pr_info_header("approx_cont_mgau.c", 328L, "INFO");
          _E__pr_info("Re-normalizing the previous score\n");
          t = 0;
          while (t < g->n_mgau) {
            if (*(kb___0->rec_sen_active + t)) {
              if (t != s___0) {
                *(senscr + t) -= *(senscr + s___0) - kb___0->rec_bst_senscr;
              }
            }
            t ++;
          }
          kb___0->rec_bst_senscr = *(senscr + s___0);
        }
        *(senscr + s___0) -= kb___0->rec_bst_senscr;
      }
    }
    s___0 ++;
  }
  if (! is_skip) {
    s___0 = 0;
    while (s___0 < g->n_mgau) {
      if (*(sen_active + s___0)) {
        *(senscr + s___0) -= best;
      }
      s___0 ++;
    }
  }
  g->frm_sen_eval = ns;
  g->frm_gau_eval = ng;
  return (best);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-_ANcoJff.i","-O3")
ascr_t *ascr_init(int32 n_sen , int32 n_comsen ) ;
ascr_t *ascr_init(int32 n_sen , int32 n_comsen ) 
{ 
  ascr_t *ascr ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = __ckd_calloc__((size_t )1, sizeof(ascr_t ), "ascr.c", 60);
  ascr = (ascr_t *)tmp;
  tmp___0 = __ckd_calloc__((size_t )(n_sen + n_comsen), sizeof(int32 ), "ascr.c",
                           61);
  ascr->sen = (int32 *)tmp___0;
  ascr->comsen = ascr->sen + n_sen;
  return (ascr);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-kyU9Qu_0.i","-O3")
beam_t *beam_init(float64 svq , float64 hmm , float64 ptr , float64 wd ) ;
beam_t *beam_init(float64 svq , float64 hmm , float64 ptr , float64 wd ) 
{ 
  beam_t *beam ;
  void *tmp ;

  {
  tmp = __ckd_calloc__((size_t )1, sizeof(beam_t ), "beam.c", 61);
  beam = (beam_t *)tmp;
  beam->subvq = logs3(svq);
  beam->hmm = logs3(hmm);
  beam->ptrans = logs3(ptr);
  beam->word = logs3(wd);
  return (beam);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-4tCF6v3L.i","-O3")
extern size_t fwrite(void const   * , size_t  , size_t  , FILE * )  __asm__("_fwrite")  ;
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
extern int strcmp(char const   * , char const   * ) ;
char *__ckd_salloc__(char const   *orig , char const   *caller_file , int32 caller_line ) ;
void _E__pr_warn(char const   *fmt  , ...) ;
int32 bio_readhdr(FILE *fp , char ***argname , char ***argval___0 , int32 *swap ) ;
int32 bio_writehdr_version(FILE *fp , char *version ) ;
void bio_hdrarg_free(char **argname , char **argval___0 ) ;
int32 bio_fread(void *buf , int32 el_sz , int32 n_el , FILE *fp , int32 swap , uint32 *chksum ) ;
int32 bio_fread_1d(void **buf , int32 el_sz , int32 *n_el , FILE *fp , int32 sw ,
                   uint32 *ck ) ;
void bio_verify_chksum(FILE *fp , int32 byteswap , uint32 chksum ) ;
static void bcomment_read(FILE *fp ) 
{ 
  char iline[16384] ;
  int tmp ;
  char *tmp___0 ;

  {
  while (1) {
    tmp___0 = fgets(iline, (int )sizeof(iline), fp);
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
      break;
    }
    tmp = strcmp((char const   *)(iline), "*end_comment*\n");
    if (tmp == 0) {
      return;
    }
  }
  _E__pr_header("bio.c", 71L, "FATAL_ERROR");
  _E__die_error("Missing %s marker\n", "*end_comment*\n");
  return;
}
}
static int32 swap_check(FILE *fp ) 
{ 
  uint32 magic ;
  size_t tmp ;

  {
  tmp = fread((void *)(& magic), sizeof(uint32 ), (size_t )1, fp);
  if (tmp != 1UL) {
    _E__pr_header("bio.c", 80L, "ERROR");
    _E__pr_warn("Cannot read BYTEORDER MAGIC NO.\n");
    return (-1);
  }
  if (magic != 287454020U) {
    magic = (((255U & (magic >> 24)) | (65280U & (magic >> 8))) | (16711680U & (magic << 8))) | (4278190080U & (magic << 24));
    if (magic == 287454020U) {
      return (1);
    }
    magic = (((255U & (magic >> 24)) | (65280U & (magic >> 8))) | (16711680U & (magic << 8))) | (4278190080U & (magic << 24));
    _E__pr_header("bio.c", 92L, "ERROR");
    _E__pr_warn("Bad BYTEORDER MAGIC NO: %08x, expecting %08x\n", magic, 287454020);
    return (-1);
  }
  return (0);
}
}
void bio_hdrarg_free(char **argname , char **argval___0 ) 
{ 
  int32 i ;

  {
  i = 0;
  while (*(argname + i)) {
    ckd_free((void *)*(argname + i));
    ckd_free((void *)*(argval___0 + i));
    i ++;
  }
  ckd_free((void *)argname);
  ckd_free((void *)argval___0);
  return;
}
}
int32 bio_writehdr_version(FILE *fp , char *version ) 
{ 
  uint32 b ;

  {
  fprintf(fp, "s3\n");
  fprintf(fp, "version %s\n", version);
  fprintf(fp, "endhdr\n");
  fflush(fp);
  b = (uint32 )287454020;
  fwrite((void const   *)(& b), sizeof(uint32 ), (size_t )1, fp);
  fflush(fp);
  return (0);
}
}
int32 bio_readhdr(FILE *fp , char ***argname , char ***argval___0 , int32 *swap ) 
{ 
  char line[16384] ;
  char word[4096] ;
  int32 i ;
  int32 l ;
  int32 lineno ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int32 tmp___7 ;

  {
  tmp = __ckd_calloc__((size_t )33, sizeof(char *), "bio.c", 137);
  *argname = (char **)tmp;
  tmp___0 = __ckd_calloc__((size_t )32, sizeof(char *), "bio.c", 138);
  *argval___0 = (char **)tmp___0;
  lineno = 0;
  tmp___1 = fgets(line, (int )sizeof(line), fp);
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    _E__pr_header("bio.c", 142L, "FATAL_ERROR");
    _E__die_error("Premature EOF, line %d\n", lineno);
  }
  lineno ++;
  if ((int )line[0] == 115) {
    if ((int )line[1] == 51) {
      if ((int )line[2] == 10) {
        i = 0;
        while (1) {
          tmp___2 = fgets(line, (int )sizeof(line), fp);
          if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
            _E__pr_header("bio.c", 149L, "FATAL_ERROR");
            _E__die_error("Premature EOF, line %d\n", lineno);
          }
          lineno ++;
          tmp___3 = sscanf((char const   *)(line), "%s%n", word, & l);
          if (tmp___3 != 1) {
            _E__pr_header("bio.c", 153L, "FATAL_ERROR");
            _E__die_error("Header format error, line %d\n", lineno);
          }
          tmp___4 = strcmp((char const   *)(word), "endhdr");
          if (tmp___4 == 0) {
            break;
          }
          if ((int )word[0] == 35) {
            goto __Cont;
          }
          if (i >= 32) {
            _E__pr_header("bio.c", 160L, "FATAL_ERROR");
            _E__die_error("Max arg-value limit(%d) exceeded; increase BIO_HDRARG_MAX\n",
                          32);
          }
          *(*argname + i) = __ckd_salloc__((char const   *)(word), "bio.c", 163);
          tmp___5 = sscanf((char const   *)(line + l), "%s", word);
          if (tmp___5 != 1) {
            _E__pr_header("bio.c", 165L, "FATAL_ERROR");
            _E__die_error("Header format error, line %d\n", lineno);
          }
          *(*argval___0 + i) = __ckd_salloc__((char const   *)(word), "bio.c", 166);
          i ++;
          __Cont: /* CIL Label */ ;
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    tmp___6 = sscanf((char const   *)(line), "%s", word);
    if (tmp___6 != 1) {
      _E__pr_header("bio.c", 172L, "FATAL_ERROR");
      _E__die_error("Header format error, line %d\n", lineno);
    }
    *(*argname + 0) = __ckd_salloc__("version", "bio.c", 174);
    *(*argval___0 + 0) = __ckd_salloc__((char const   *)(word), "bio.c", 175);
    i = 1;
    bcomment_read(fp);
  }
  *(*argname + i) = (char *)((void *)0);
  tmp___7 = swap_check(fp);
  *swap = tmp___7;
  if (tmp___7 < 0) {
    _E__pr_header("bio.c", 183L, "FATAL_ERROR");
    _E__die_error("swap_check failed\n");
  }
  return (0);
}
}
static uint32 chksum_accum(void *buf , int32 el_sz , int32 n_el , uint32 sum___0 ) 
{ 
  int32 i ;
  uint8 *i8 ;
  uint16 *i16 ;
  uint32 *i32 ;

  {
  switch (el_sz) {
  case 1: 
  i8 = (uint8 *)buf;
  i = 0;
  while (i < n_el) {
    sum___0 = ((sum___0 << 5) | (sum___0 >> 27)) + (unsigned int )*(i8 + i);
    i ++;
  }
  break;
  case 2: 
  i16 = (uint16 *)buf;
  i = 0;
  while (i < n_el) {
    sum___0 = ((sum___0 << 10) | (sum___0 >> 22)) + (unsigned int )*(i16 + i);
    i ++;
  }
  break;
  case 4: 
  i32 = (uint32 *)buf;
  i = 0;
  while (i < n_el) {
    sum___0 = ((sum___0 << 20) | (sum___0 >> 12)) + *(i32 + i);
    i ++;
  }
  break;
  default: 
  _E__pr_header("bio.c", 213L, "FATAL_ERROR");
  _E__die_error("Unsupported elemsize for checksum: %d\n", el_sz);
  break;
  }
  return (sum___0);
}
}
static void swap_buf(void *buf , int32 el_sz , int32 n_el ) 
{ 
  int32 i ;
  uint16 *buf16 ;
  uint32 *buf32 ;

  {
  switch (el_sz) {
  case 1: 
  break;
  case 2: 
  buf16 = (uint16 *)buf;
  i = 0;
  while (i < n_el) {
    *(buf16 + i) = (uint16 )((255 & ((int )*(buf16 + i) >> 8)) | (65280 & ((int )*(buf16 + i) << 8)));
    i ++;
  }
  break;
  case 4: 
  buf32 = (uint32 *)buf;
  i = 0;
  while (i < n_el) {
    *(buf32 + i) = (((255U & (*(buf32 + i) >> 24)) | (65280U & (*(buf32 + i) >> 8))) | (16711680U & (*(buf32 + i) << 8))) | (4278190080U & (*(buf32 + i) << 24));
    i ++;
  }
  break;
  default: 
  _E__pr_header("bio.c", 241L, "FATAL_ERROR");
  _E__die_error("Unsupported elemsize for byteswapping: %d\n", el_sz);
  break;
  }
  return;
}
}
int32 bio_fread(void *buf , int32 el_sz , int32 n_el , FILE *fp , int32 swap , uint32 *chksum ) 
{ 
  size_t tmp ;

  {
  tmp = fread(buf, (size_t )el_sz, (size_t )n_el, fp);
  if (tmp != (size_t )n_el) {
    return (-1);
  }
  if (swap) {
    swap_buf(buf, el_sz, n_el);
  }
  if (chksum) {
    *chksum = chksum_accum(buf, el_sz, n_el, *chksum);
  }
  return (n_el);
}
}
int32 bio_fread_1d(void **buf , int32 el_sz , int32 *n_el , FILE *fp , int32 sw ,
                   uint32 *ck ) 
{ 
  int32 tmp ;
  void *tmp___0 ;
  int32 tmp___1 ;

  {
  if (el_sz != 1) {
    if (el_sz != 2) {
      if (el_sz != 4) {
        _E__pr_header("bio.c", 265L, "FATAL_ERROR");
        _E__die_error("Unsupported elemsize: %d\n", el_sz);
      }
    }
  }
  tmp = bio_fread((void *)n_el, (int32 )sizeof(int32 ), 1, fp, sw, ck);
  if (tmp != 1) {
    _E__pr_header("bio.c", 269L, "FATAL_ERROR");
    _E__die_error("fread(arraysize) failed\n");
  }
  if (*n_el <= 0) {
    _E__pr_header("bio.c", 271L, "FATAL_ERROR");
    _E__die_error("Bad arraysize: %d\n", *n_el);
  }
  tmp___0 = __ckd_calloc__((size_t )*n_el, (size_t )el_sz, "bio.c", 274);
  *buf = tmp___0;
  tmp___1 = bio_fread(*buf, el_sz, *n_el, fp, sw, ck);
  if (tmp___1 != *n_el) {
    _E__pr_header("bio.c", 278L, "FATAL_ERROR");
    _E__die_error("fread(arraydata) failed\n");
  }
  return (*n_el);
}
}
void bio_verify_chksum(FILE *fp , int32 byteswap , uint32 chksum ) 
{ 
  uint32 file_chksum ;
  size_t tmp ;

  {
  tmp = fread((void *)(& file_chksum), sizeof(uint32 ), (size_t )1, fp);
  if (tmp != 1UL) {
    _E__pr_header("bio.c", 289L, "FATAL_ERROR");
    _E__die_error("fread(chksum) failed\n");
  }
  if (byteswap) {
    file_chksum = (((255U & (file_chksum >> 24)) | (65280U & (file_chksum >> 8))) | (16711680U & (file_chksum << 8))) | (4278190080U & (file_chksum << 24));
  }
  if (file_chksum != chksum) {
    _E__pr_header("bio.c", 293L, "FATAL_ERROR");
    _E__die_error("Checksum error; file-checksum %08x, computed %08x\n", file_chksum,
                  chksum);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-EJl4xEfc.i","-O3")
void ucase(char *cp ) ;
void lcase(char *cp ) ;
int32 strcmp_nocase(char const   *str1 , char const   *str2 ) ;
void lcase(char *cp ) 
{ 


  {
  while (*cp) {
    if ((int )*cp >= 65) {
      if ((int )*cp <= 90) {
        *cp = (char )((int )*cp + 32);
      } else {
        *cp = *cp;
      }
    } else {
      *cp = *cp;
    }
    cp ++;
  }
  return;
}
}
void ucase(char *cp ) 
{ 


  {
  while (*cp) {
    if ((int )*cp >= 97) {
      if ((int )*cp <= 122) {
        *cp = (char )((int )*cp - 32);
      } else {
        *cp = *cp;
      }
    } else {
      *cp = *cp;
    }
    cp ++;
  }
  return;
}
}
int32 strcmp_nocase(char const   *str1 , char const   *str2 ) 
{ 
  char c1 ;
  char c2 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  while (1) {
    tmp = str1;
    str1 ++;
    c1 = (char )*tmp;
    if ((int )c1 >= 97) {
      if ((int )c1 <= 122) {
        c1 = (char )((int )c1 - 32);
      } else {
        c1 = c1;
      }
    } else {
      c1 = c1;
    }
    tmp___0 = str2;
    str2 ++;
    c2 = (char )*tmp___0;
    if ((int )c2 >= 97) {
      if ((int )c2 <= 122) {
        c2 = (char )((int )c2 - 32);
      } else {
        c2 = c2;
      }
    } else {
      c2 = c2;
    }
    if ((int )c1 != (int )c2) {
      return ((int )c1 - (int )c2);
    }
    if ((int )c1 == 0) {
      return (0);
    }
  }
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-CTAMTfNr.i","-O3")
extern void *realloc(void * , size_t  ) ;
void *__ckd_malloc__(size_t size , char const   *caller_file , int caller_line ) ;
void *__ckd_realloc__(void *ptr , size_t new_size , char const   *caller_file , int caller_line ) ;
void ***__ckd_calloc_3d__(int32 d1 , int32 d2 , int32 d3 , int32 elemsize , char const   *caller_file ,
                          int32 caller_line ) ;
void ckd_free_3d(void ***ptr ) ;
char *__mymalloc__(int32 elemsize , char *caller_file , int32 caller_line ) ;
void __myfree__(char *elem , int32 elemsize , char *caller_file , int32 caller_line ) ;
void *__ckd_calloc__(size_t n_elem , size_t elem_size , char const   *caller_file ,
                     int caller_line ) 
{ 
  void *mem ;

  {
  mem = calloc(n_elem, elem_size);
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
    _E__pr_header("ckd_alloc.c", 95L, "FATAL_ERROR");
    _E__die_error("calloc(%d,%d) failed from %s(%d)\n", n_elem, elem_size, caller_file,
                  caller_line);
  }
  return (mem);
}
}
void *__ckd_malloc__(size_t size , char const   *caller_file , int caller_line ) 
{ 
  void *mem ;

  {
  mem = malloc(size);
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
    _E__pr_header("ckd_alloc.c", 109L, "FATAL_ERROR");
    _E__die_error("malloc(%d) failed from %s(%d)\n", size, caller_file, caller_line);
  }
  return (mem);
}
}
void *__ckd_realloc__(void *ptr , size_t new_size , char const   *caller_file , int caller_line ) 
{ 
  void *mem ;

  {
  mem = realloc(ptr, new_size);
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
    _E__pr_header("ckd_alloc.c", 121L, "FATAL_ERROR");
    _E__die_error("realloc(%d) failed from %s(%d)\n", new_size, caller_file, caller_line);
  }
  return (mem);
}
}
char *__ckd_salloc__(char const   *orig , char const   *caller_file , int32 caller_line ) 
{ 
  int32 len ;
  char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  tmp = strlen(orig);
  len = (int32 )(tmp + 1UL);
  tmp___0 = __ckd_malloc__((size_t )len, caller_file, caller_line);
  buf = (char *)tmp___0;
  tmp___2 = __builtin_object_size((void *)buf, 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)buf, 1);
    __builtin___strcpy_chk(buf, orig, tmp___1);
  } else {
    __inline_strcpy_chk(buf, orig);
  }
  return (buf);
}
}
void **__ckd_calloc_2d__(int32 d1 , int32 d2 , int32 elemsize , char const   *caller_file ,
                         int32 caller_line ) 
{ 
  char **ref ;
  char *mem ;
  int32 i ;
  int32 offset ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = __ckd_calloc__((size_t )(d1 * d2), (size_t )elemsize, caller_file, caller_line);
  mem = (char *)tmp;
  tmp___0 = __ckd_malloc__((unsigned long )d1 * sizeof(void *), caller_file, caller_line);
  ref = (char **)tmp___0;
  i = 0;
  offset = 0;
  while (i < d1) {
    *(ref + i) = mem + offset;
    i ++;
    offset += d2 * elemsize;
  }
  return ((void **)ref);
}
}
void ckd_free(void *ptr ) 
{ 


  {
  if (ptr) {
    free(ptr);
  }
  return;
}
}
void ckd_free_2d(void **ptr ) 
{ 


  {
  if (ptr) {
    ckd_free(*(ptr + 0));
  }
  ckd_free((void *)ptr);
  return;
}
}
void ***__ckd_calloc_3d__(int32 d1 , int32 d2 , int32 d3 , int32 elemsize , char const   *caller_file ,
                          int32 caller_line ) 
{ 
  char ***ref1 ;
  char **ref2 ;
  char *mem ;
  int32 i ;
  int32 j ;
  int32 offset ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = __ckd_calloc__((size_t )((d1 * d2) * d3), (size_t )elemsize, caller_file,
                       caller_line);
  mem = (char *)tmp;
  tmp___0 = __ckd_malloc__((unsigned long )d1 * sizeof(void **), caller_file, caller_line);
  ref1 = (char ***)tmp___0;
  tmp___1 = __ckd_malloc__((unsigned long )(d1 * d2) * sizeof(void *), caller_file,
                           caller_line);
  ref2 = (char **)tmp___1;
  i = 0;
  offset = 0;
  while (i < d1) {
    *(ref1 + i) = ref2 + offset;
    i ++;
    offset += d2;
  }
  offset = 0;
  i = 0;
  while (i < d1) {
    j = 0;
    while (j < d2) {
      *(*(ref1 + i) + j) = mem + offset;
      offset += d3 * elemsize;
      j ++;
    }
    i ++;
  }
  return ((void ***)ref1);
}
}
void ckd_free_3d(void ***ptr ) 
{ 


  {
  if (ptr) {
    if (*(ptr + 0)) {
      ckd_free(*(*(ptr + 0) + 0));
    }
  }
  if (ptr) {
    ckd_free((void *)*(ptr + 0));
  }
  ckd_free((void *)ptr);
  return;
}
}
static mylist_t *head  =    (mylist_t *)((void *)0);
char *__mymalloc__(int32 elemsize , char *caller_file , int32 caller_line ) 
{ 
  char *cp ;
  int32 j ;
  char **cpp ;
  mylist_t *prev ;
  mylist_t *list ;
  void *tmp ;
  char **tmp___0 ;
  void *tmp___1 ;

  {
  prev = (mylist_t *)((void *)0);
  list = head;
  while (1) {
    if (list) {
      if (! (list->elemsize != elemsize)) {
        break;
      }
    } else {
      break;
    }
    prev = list;
    list = list->next;
  }
  if (! list) {
    if ((unsigned long )elemsize % sizeof(void *) != 0UL) {
      _E__pr_header("ckd_alloc.c", 236L, "FATAL_ERROR");
      _E__die_error("List item size (%d) not multiple of sizeof(void *)\n", elemsize);
    }
    tmp = __ckd_calloc__((size_t )1, sizeof(mylist_t ), "ckd_alloc.c", 238);
    list = (mylist_t *)tmp;
    list->freelist = (char **)((void *)0);
    list->elemsize = elemsize;
    list->blocksize = 50;
    list->blk_alloc = (1 << 18) / (list->blocksize * elemsize);
    list->next = head;
    head = list;
  } else
  if (prev) {
    prev->next = list->next;
    list->next = head;
    head = list;
  }
  if ((unsigned long )list->freelist == (unsigned long )((void *)0)) {
    if (list->blk_alloc == 0) {
      list->blocksize <<= 1;
      list->blk_alloc = (1 << 18) / (list->blocksize * elemsize);
      if (list->blk_alloc <= 0) {
        list->blk_alloc = 1879048192;
      }
    }
    tmp___1 = __ckd_calloc__((size_t )list->blocksize, (size_t )elemsize, (char const   *)caller_file,
                             caller_line);
    tmp___0 = (char **)tmp___1;
    list->freelist = tmp___0;
    cpp = tmp___0;
    cp = (char *)cpp;
    j = list->blocksize - 1;
    while (j > 0) {
      cp += elemsize;
      *cpp = cp;
      cpp = (char **)cp;
      j --;
    }
    *cpp = (char *)((void *)0);
    (list->blk_alloc) --;
  }
  cp = (char *)list->freelist;
  list->freelist = (char **)*(list->freelist);
  return (cp);
}
}
void __myfree__(char *elem , int32 elemsize , char *caller_file , int32 caller_line ) 
{ 
  char **cpp ;
  mylist_t *prev ;
  mylist_t *list ;

  {
  prev = (mylist_t *)((void *)0);
  list = head;
  while (1) {
    if (list) {
      if (! (list->elemsize != elemsize)) {
        break;
      }
    } else {
      break;
    }
    prev = list;
    list = list->next;
  }
  if (! list) {
    _E__pr_header("ckd_alloc.c", 302L, "FATAL_ERROR");
    _E__die_error("Unknown list item size: %d; called from %s(%d)\n", elemsize, caller_file,
                  caller_line);
  } else
  if (prev) {
    prev->next = list->next;
    list->next = head;
    head = list;
  }
  cpp = (char **)elem;
  *cpp = (char *)list->freelist;
  list->freelist = cpp;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-LeKDiaD2.i","-O3")
extern  __attribute__((__noreturn__)) void exit(int  ) ;
extern void qsort(void * , size_t  , size_t  , int (*)(void const   * , void const   * ) ) ;
hash_table_t *hash_new(int32 size , int32 casearg ) ;
void hash_free(hash_table_t *h ) ;
int32 hash_enter(hash_table_t *h , char const   *key , int32 val ) ;
int32 hash_lookup(hash_table_t *h , char const   *key , int32 *val ) ;
static argval_t *argval  =    (argval_t *)((void *)0);
static hash_table_t *ht  ;
static int32 arg_strlen(arg_t *defn , int32 *namelen , int32 *deflen ) 
{ 
  int32 i ;
  int32 l ;
  int32 tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  tmp = 0;
  *deflen = tmp;
  *namelen = tmp;
  i = 0;
  while ((defn + i)->name) {
    tmp___0 = strlen((char const   *)(defn + i)->name);
    l = (int32 )tmp___0;
    if (*namelen < l) {
      *namelen = l;
    }
    if ((defn + i)->deflt) {
      tmp___1 = strlen((char const   *)(defn + i)->deflt);
      l = (int32 )tmp___1;
      if (*deflen < l) {
        *deflen = l;
      }
    }
    i ++;
  }
  return (i);
}
}
static arg_t *tmp_defn  ;
static int32 cmp_name(void const   *a , void const   *b ) 
{ 
  int32 tmp ;

  {
  tmp = strcmp_nocase((char const   *)(tmp_defn + *((int32 *)a))->name, (char const   *)(tmp_defn + *((int32 *)b))->name);
  return (tmp);
}
}
static int32 *arg_sort(arg_t *defn , int32 n ) 
{ 
  int32 *pos ;
  int32 i ;
  void *tmp ;

  {
  tmp = __ckd_calloc__((size_t )n, sizeof(int32 ), "cmd_ln.c", 145);
  pos = (int32 *)tmp;
  i = 0;
  while (i < n) {
    *(pos + i) = i;
    i ++;
  }
  tmp_defn = defn;
  qsort((void *)pos, (size_t )n, sizeof(int32 ), & cmp_name);
  tmp_defn = (arg_t *)((void *)0);
  return (pos);
}
}
static int32 arg_str2val(argval_t *v , argtype_t t , char *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! str) {
    v->ptr = (void const   *)((void *)0);
  } else {
    switch (t) {
    case 3: 
    case 2: 
    tmp = sscanf((char const   *)str, "%d", & v->val.int32);
    if (tmp != 1) {
      return (-1);
    }
    v->ptr = (void const   *)((void *)(& v->val.int32));
    break;
    case 5: 
    case 4: 
    tmp___0 = sscanf((char const   *)str, "%f", & v->val.float32);
    if (tmp___0 != 1) {
      return (-1);
    }
    v->ptr = (void const   *)((void *)(& v->val.float32));
    break;
    case 7: 
    case 6: 
    tmp___1 = sscanf((char const   *)str, "%lf", & v->val.float64);
    if (tmp___1 != 1) {
      return (-1);
    }
    v->ptr = (void const   *)((void *)(& v->val.float64));
    break;
    case 9: 
    case 8: 
    v->ptr = (void const   *)((void *)str);
    break;
    default: 
    _E__pr_header("cmd_ln.c", 184L, "FATAL_ERROR");
    _E__die_error("Unknown argument type: %d\n", t);
    }
  }
  return (0);
}
}
static void arg_dump(FILE *fp , arg_t *defn , int32 doc ) 
{ 
  int32 *pos ;
  int32 i ;
  int32 j ;
  int32 l ;
  int32 n ;
  int32 namelen ;
  int32 deflen ;
  void const   *vp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  n = arg_strlen(defn, & namelen, & deflen);
  namelen = (int32 )((unsigned int )namelen & 4294967288U);
  deflen = (int32 )((unsigned int )deflen & 4294967288U);
  fprintf(fp, "[NAME]");
  l = 6;
  while (l < namelen) {
    fprintf(fp, "\t");
    l += 8;
  }
  fprintf(fp, "\t[DEFLT]");
  l = 6;
  while (l < deflen) {
    fprintf(fp, "\t");
    l += 8;
  }
  fprintf(fp, "\t[VALUE]\n");
  pos = arg_sort(defn, n);
  i = 0;
  while (i < n) {
    j = *(pos + i);
    fprintf(fp, "%s", (defn + j)->name);
    tmp = strlen((char const   *)(defn + j)->name);
    l = (int32 )tmp;
    while (l < namelen) {
      fprintf(fp, "\t");
      l += 8;
    }
    fprintf(fp, "\t");
    if ((defn + j)->deflt) {
      fprintf(fp, "%s", (defn + j)->deflt);
      tmp___0 = strlen((char const   *)(defn + j)->deflt);
      l = (int32 )tmp___0;
    } else {
      l = 0;
    }
    while (l < deflen) {
      fprintf(fp, "\t");
      l += 8;
    }
    fprintf(fp, "\t");
    if (doc) {
      if ((defn + j)->doc) {
        fprintf(fp, "%s", (defn + j)->doc);
      }
    } else {
      vp = cmd_ln_access((defn + j)->name);
      if (vp) {
        switch ((defn + j)->type) {
        case 3: 
        case 2: 
        fprintf(fp, "%d", *((int32 *)vp));
        break;
        case 5: 
        case 4: 
        fprintf(fp, "%e", (double )*((float32 *)vp));
        break;
        case 7: 
        case 6: 
        fprintf(fp, "%e", *((float64 *)vp));
        break;
        case 9: 
        case 8: 
        fprintf(fp, "%s", (char *)vp);
        break;
        default: 
        _E__pr_header("cmd_ln.c", 254L, "FATAL_ERROR");
        _E__die_error("Unknown argument type: %d\n", (defn + j)->type);
        }
      }
    }
    fprintf(fp, "\n");
    i ++;
  }
  ckd_free((void *)pos);
  fprintf(fp, "\n");
  fflush(fp);
  return;
}
}
int32 cmd_ln_parse(arg_t *defn , int32 argc , char **argv ) 
{ 
  int32 i ;
  int32 j ;
  int32 n ;
  void *tmp ;
  int32 tmp___0 ;
  int32 tmp___1 ;
  int32 tmp___2 ;
  int32 tmp___3 ;

  {
  if (argval) {
    _E__pr_header("cmd_ln.c", 273L, "FATAL_ERROR");
    _E__die_error("Multiple sets of argument definitions not supported\n");
  }
  _E__pr_info_header("cmd_ln.c", 276L, "INFO");
  _E__pr_info("Parsing command line:\n");
  n = 0;
  while ((defn + n)->name) {
    n ++;
  }
  ht = hash_new(n, 0);
  tmp = __ckd_calloc__((size_t )n, sizeof(argval_t ), "cmd_ln.c", 292);
  argval = (argval_t *)tmp;
  i = 0;
  while (i < n) {
    tmp___0 = hash_enter(ht, (char const   *)(defn + i)->name, i);
    if (tmp___0 != i) {
      _E__pr_header("cmd_ln.c", 298L, "FATAL_ERROR");
      _E__die_error("Duplicate argument name: %s\n", (defn + i)->name);
    }
    i ++;
  }
  j = 1;
  while (j < argc) {
    tmp___1 = hash_lookup(ht, (char const   *)*(argv + j), & i);
    if (tmp___1 < 0) {
      _E__pr_header("cmd_ln.c", 304L, "ERROR");
      _E__pr_warn("Unknown argument: %s\n", *(argv + j));
      cmd_ln_print_help(__stderrp, defn);
      exit(-1);
    }
    if ((argval + i)->ptr) {
      _E__pr_header("cmd_ln.c", 311L, "FATAL_ERROR");
      _E__die_error("Multiple occurrences of argument %s\n", *(argv + j));
    }
    if (j + 1 >= argc) {
      _E__pr_header("cmd_ln.c", 314L, "ERROR");
      _E__pr_warn("Argument value for \'%s\' missing\n", *(argv + j));
      cmd_ln_print_help(__stderrp, defn);
      exit(-1);
    }
    tmp___2 = arg_str2val(argval + i, (defn + i)->type, *(argv + (j + 1)));
    if (tmp___2 < 0) {
      _E__pr_header("cmd_ln.c", 321L, "ERROR");
      _E__pr_warn("Bad argument value for %s: %s\n", *(argv + j), *(argv + (j + 1)));
      cmd_ln_print_help(__stderrp, defn);
      exit(-1);
    }
    j += 2;
  }
  i = 0;
  while (i < n) {
    if (! (argval + i)->ptr) {
      tmp___3 = arg_str2val(argval + i, (defn + i)->type, (defn + i)->deflt);
      if (tmp___3 < 0) {
        _E__pr_header("cmd_ln.c", 333L, "FATAL_ERROR");
        _E__die_error("Bad default argument value for %s: %s\n", (defn + i)->name,
                      (defn + i)->deflt);
      }
    }
    i ++;
  }
  j = 0;
  i = 0;
  while (i < n) {
    if ((defn + i)->type & 1) {
      if (! (argval + i)->ptr) {
        _E__pr_header("cmd_ln.c", 342L, "ERROR");
        _E__pr_warn("Missing required argument %s\n", (defn + i)->name);
        j ++;
      }
    }
    i ++;
  }
  if (j > 0) {
    cmd_ln_print_help(__stderrp, defn);
    exit(-1);
  }
  return (0);
}
}
void cmd_ln_print_help(FILE *fp , arg_t *defn ) 
{ 


  {
  fprintf(fp, "Arguments list definition:\n");
  arg_dump(fp, defn, 1);
  return;
}
}
void const   *cmd_ln_access(char *name ) 
{ 
  int32 i ;
  int32 tmp ;

  {
  if (! argval) {
    _E__pr_header("cmd_ln.c", 373L, "FATAL_ERROR");
    _E__die_error("cmd_ln_access invoked before cmd_ln_parse\n");
  }
  tmp = hash_lookup(ht, (char const   *)name, & i);
  if (tmp < 0) {
    _E__pr_header("cmd_ln.c", 376L, "FATAL_ERROR");
    _E__die_error("Unknown argument: %s\n", name);
  }
  return ((argval + i)->ptr);
}
}
void cmd_ln_free(void) 
{ 


  {
  hash_free(ht);
  ckd_free((void *)argval);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-8OPJ6GCJ.i","-O3")
extern double sqrt(double  ) ;
void cmn(float32 **mfc , int32 varnorm , int32 n_frame , int32 veclen ) ;
void cmn_free(void) ;
static float32 *cmn_mean  =    (float32 *)((void *)0);
static float32 *cmn_var  =    (float32 *)((void *)0);
void cmn(float32 **mfc , int32 varnorm , int32 n_frame , int32 veclen ) 
{ 
  float32 *mfcp ;
  float32 t ;
  int32 i ;
  int32 f ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;

  {
  if (n_frame <= 0) {
    return;
  } else
  if (veclen <= 0) {
    return;
  }
  if ((unsigned long )cmn_mean == (unsigned long )((void *)0)) {
    tmp = __ckd_calloc__((size_t )veclen, sizeof(float32 ), "cmn.c", 83);
    cmn_mean = (float32 *)tmp;
  }
  i = 0;
  while (i < veclen) {
    *(cmn_mean + i) = (float32 )0.0;
    i ++;
  }
  f = 0;
  while (f < n_frame) {
    mfcp = *(mfc + f);
    i = 0;
    while (i < veclen) {
      *(cmn_mean + i) += *(mfcp + i);
      i ++;
    }
    f ++;
  }
  i = 0;
  while (i < veclen) {
    *(cmn_mean + i) /= (float32 )n_frame;
    i ++;
  }
  if (! varnorm) {
    f = 0;
    while (f < n_frame) {
      mfcp = *(mfc + f);
      i = 0;
      while (i < veclen) {
        *(mfcp + i) -= *(cmn_mean + i);
        i ++;
      }
      f ++;
    }
  } else {
    if ((unsigned long )cmn_var == (unsigned long )((void *)0)) {
      tmp___0 = __ckd_calloc__((size_t )veclen, sizeof(float32 ), "cmn.c", 106);
      cmn_var = (float32 *)tmp___0;
    }
    i = 0;
    while (i < veclen) {
      *(cmn_var + i) = (float32 )0.0;
      i ++;
    }
    f = 0;
    while (f < n_frame) {
      mfcp = *(mfc + f);
      i = 0;
      while (i < veclen) {
        t = *(mfcp + i) - *(cmn_mean + i);
        *(cmn_var + i) += t * t;
        i ++;
      }
      f ++;
    }
    i = 0;
    while (i < veclen) {
      tmp___1 = sqrt((float64 )n_frame / (float64 )*(cmn_var + i));
      *(cmn_var + i) = (float32 )tmp___1;
      i ++;
    }
    f = 0;
    while (f < n_frame) {
      mfcp = *(mfc + f);
      i = 0;
      while (i < veclen) {
        *(mfcp + i) = (*(mfcp + i) - *(cmn_mean + i)) * *(cmn_var + i);
        i ++;
      }
      f ++;
    }
  }
  return;
}
}
void cmn_free(void) 
{ 


  {
  ckd_free((void *)cmn_var);
  ckd_free((void *)cmn_mean);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-4r5yyP_4.i","-O3")
void cmn_prior(float32 **incep , int32 varnorm , int32 nfr , int32 ceplen , int32 endutt ) ;
static float32 *cur_mean  =    (float32 *)((void *)0);
static float32 *sum  =    (float32 *)((void *)0);
static int32 nframe  ;
static int32 initialize  =    1;
void cmn_prior(float32 **incep , int32 varnorm , int32 nfr , int32 ceplen , int32 endutt ) 
{ 
  float32 sf ;
  int32 i ;
  int32 j ;
  void *tmp ;
  void *tmp___0 ;

  {
  if (varnorm) {
    _E__pr_header("cmn_prior.c", 61L, "FATAL_ERROR");
    _E__die_error("Variance normalization not implemented in live mode decode\n");
  }
  if (initialize) {
    tmp = __ckd_calloc__((size_t )ceplen, sizeof(float32 ), "cmn_prior.c", 64);
    cur_mean = (float32 *)tmp;
    *(cur_mean + 0) = (float32 )12.0;
    tmp___0 = __ckd_calloc__((size_t )ceplen, sizeof(float32 ), "cmn_prior.c", 69);
    sum = (float32 *)tmp___0;
    nframe = 0;
    initialize = 0;
    _E__pr_info_header("cmn_prior.c", 72L, "INFO");
    _E__pr_info("mean[0]= %.2f, mean[1..%d]= 0.0\n", (double )*(cur_mean + 0), ceplen - 1);
  }
  if (nfr <= 0) {
    return;
  }
  i = 0;
  while (i < nfr) {
    j = 0;
    while (j < ceplen) {
      *(sum + j) += *(*(incep + i) + j);
      *(*(incep + i) + j) -= *(cur_mean + j);
      j ++;
    }
    nframe ++;
    i ++;
  }
  if (nframe > 800) {
    sf = (float32 )(1.0 / (double )nframe);
    i = 0;
    while (i < ceplen) {
      *(cur_mean + i) = *(sum + i) * sf;
      i ++;
    }
    if (nframe >= 800) {
      sf = (float32 )500 * sf;
      i = 0;
      while (i < ceplen) {
        *(sum + i) *= sf;
        i ++;
      }
      nframe = 500;
    }
  }
  if (endutt) {
    sf = (float32 )(1.0 / (double )nframe);
    i = 0;
    while (i < ceplen) {
      *(cur_mean + i) = *(sum + i) * sf;
      i ++;
    }
    if (nframe > 800) {
      sf = (float32 )500 * sf;
      i = 0;
      while (i < ceplen) {
        *(sum + i) *= sf;
        i ++;
      }
      nframe = 500;
    }
  }
  return;
}
}
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-CvWy6lr4.i","-O3")
__inline static void *__inline_memcpy_chk(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
extern double log(double  ) ;
FILE *_myfopen(char *file , char *mode , char *pgm , int32 line ) ;
void vector_nz_floor(float32 *vec , int32 len , float64 flr ) ;
float64 vector_sum_norm(float32 *vec , int32 len ) ;
int32 vector_is_zero(float32 *vec , int32 len ) ;
int32 logs3_add(int32 logp , int32 logq ) ;
float64 log_to_logs3_factor(void) ;
float64 logs3_to_log(int32 logs3p ) ;
mgau_model_t *mgau_init(char *meanfile , char *varfile , float64 varfloor , char *mixwfile ,
                        float64 mixwfloor , int32 precomp , char *senmgau ) ;
int32 mgau_var_nzvec_floor(mgau_model_t *g , float64 floor___0 ) ;
int32 mgau_comp_eval(mgau_model_t *g , int32 s___0 , float32 *x___0 , int32 *score ) ;
void mgau_free(mgau_model_t *g ) ;
long considered  =    0L;
static int32 mgau_file_read(mgau_model_t *g , char *file_name , int32 type ) 
{ 
  char tmp ;
  FILE *fp ;
  int32 i ;
  int32 k___0 ;
  int32 n ;
  int32 n_mgau ;
  int32 n_feat ;
  int32 n_density ;
  int32 *veclen ;
  int32 blk ;
  int32 byteswap ;
  int32 chksum_present ;
  float32 *buf ;
  float32 **pbuf ;
  char **argname ;
  char **argval___0 ;
  uint32 chksum ;
  float64 f ;
  int32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int32 tmp___4 ;
  int32 tmp___5 ;
  int32 tmp___6 ;
  void *tmp___7 ;
  int32 tmp___8 ;
  int32 tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int32 tmp___16 ;
  size_t tmp___17 ;

  {
  _E__pr_info_header("cont_mgau.c", 96L, "INFO");
  _E__pr_info("Reading mixture gaussian file \'%s\'\n", file_name);
  fp = _myfopen(file_name, (char *)"rb", (char *)"cont_mgau.c", 98);
  tmp___0 = bio_readhdr(fp, & argname, & argval___0, & byteswap);
  if (tmp___0 < 0) {
    _E__pr_header("cont_mgau.c", 102L, "FATAL_ERROR");
    _E__die_error("bio_readhdr(%s) failed\n", file_name);
  }
  chksum_present = 0;
  i = 0;
  while (*(argname + i)) {
    tmp___3 = strcmp((char const   *)*(argname + i), "version");
    if (tmp___3 == 0) {
      tmp___1 = strcmp((char const   *)*(argval___0 + i), "1.0");
      if (tmp___1 != 0) {
        _E__pr_header("cont_mgau.c", 109L, "WARNING");
        _E__pr_warn("Version mismatch(%s): %s, expecting %s\n", file_name, *(argval___0 + i),
                    "1.0");
      }
    } else {
      tmp___2 = strcmp((char const   *)*(argname + i), "chksum0");
      if (tmp___2 == 0) {
        chksum_present = 1;
      }
    }
    i ++;
  }
  bio_hdrarg_free(argname, argval___0);
  argval___0 = (char **)((void *)0);
  argname = argval___0;
  chksum = (uint32 )0;
  tmp___4 = bio_fread((void *)(& n_mgau), (int32 )sizeof(int32 ), 1, fp, byteswap,
                      & chksum);
  if (tmp___4 != 1) {
    _E__pr_header("cont_mgau.c", 122L, "FATAL_ERROR");
    _E__die_error("fread(%s) (#codebooks) failed\n", file_name);
  }
  if (n_mgau >= 32766) {
    _E__pr_header("cont_mgau.c", 124L, "FATAL_ERROR");
    _E__die_error("%s: #Mixture Gaussians (%d) exceeds limit(%d) enforced by MGAUID type\n",
                  file_name, n_mgau, 32766);
  }
  tmp___5 = bio_fread((void *)(& n_feat), (int32 )sizeof(int32 ), 1, fp, byteswap,
                      & chksum);
  if (tmp___5 != 1) {
    _E__pr_header("cont_mgau.c", 130L, "FATAL_ERROR");
    _E__die_error("fread(%s) (#features) failed\n", file_name);
  }
  if (g->gau_type == 10001) {
    if (n_feat != 1) {
      _E__pr_header("cont_mgau.c", 134L, "FATAL_ERROR");
      _E__die_error("#Features streams(%d) != 1 in continuous HMM\n", n_feat);
    }
  } else
  if (g->gau_type == 10002) {
    if (n_feat != 4) {
      _E__pr_header("cont_mgau.c", 137L, "FATAL_ERROR");
      _E__die_error("#Features streams(%d) != 1 in semi-continuous HMM\n", n_feat);
    }
  }
  tmp___6 = bio_fread((void *)(& n_density), (int32 )sizeof(int32 ), 1, fp, byteswap,
                      & chksum);
  if (tmp___6 != 1) {
    _E__pr_header("cont_mgau.c", 142L, "FATAL_ERROR");
    _E__die_error("fread(%s) (#density/codebook) failed\n", file_name);
  }
  tmp___7 = __ckd_calloc__((size_t )n_feat, sizeof(uint32 ), "cont_mgau.c", 146);
  veclen = (int32 *)tmp___7;
  tmp___8 = bio_fread((void *)veclen, (int32 )sizeof(int32 ), n_feat, fp, byteswap,
                      & chksum);
  if (tmp___8 != n_feat) {
    _E__pr_header("cont_mgau.c", 149L, "FATAL_ERROR");
    _E__die_error("fread(%s) (feature-lengths) failed\n", file_name);
  }
  i = 0;
  blk = 0;
  while (i < n_feat) {
    blk += *(veclen + i);
    i ++;
  }
  tmp___9 = bio_fread((void *)(& n), (int32 )sizeof(int32 ), 1, fp, byteswap, & chksum);
  if (tmp___9 != 1) {
    _E__pr_header("cont_mgau.c", 159L, "FATAL_ERROR");
    _E__die_error("fread(%s) (total #floats) failed\n", file_name);
  }
  if (n != (n_mgau * n_density) * blk) {
    _E__pr_header("cont_mgau.c", 162L, "FATAL_ERROR");
    _E__die_error("%s: #float32s(%d) doesn\'t match dimensions: %d x %d x %d\n", file_name,
                  n, n_mgau, n_density, blk);
  }
  if (g->gau_type == 10002) {
    _E__pr_header("cont_mgau.c", 167L, "FATAL_ERROR");
    _E__die_error("Currently S2 semi-continous HMM is not supported\n");
  }
  if (type == 1) {
    g->n_mgau = n_mgau;
    g->max_comp = n_density;
    g->veclen = blk;
    tmp___10 = __ckd_calloc__((size_t )n_mgau, sizeof(mgau_t ), "cont_mgau.c", 175);
    g->mgau = (mgau_t *)tmp___10;
    tmp___11 = __ckd_calloc__((size_t )n, sizeof(float ), "cont_mgau.c", 177);
    buf = (float32 *)tmp___11;
    tmp___12 = __ckd_calloc__((size_t )(n_mgau * n_density), sizeof(float32 *), "cont_mgau.c",
                              178);
    pbuf = (float32 **)tmp___12;
    i = 0;
    while (i < n_mgau) {
      (g->mgau + i)->n_comp = n_density;
      (g->mgau + i)->mean = pbuf;
      k___0 = 0;
      while (k___0 < n_density) {
        *((g->mgau + i)->mean + k___0) = buf;
        buf += blk;
        k___0 ++;
      }
      pbuf += n_density;
      i ++;
    }
    buf = *((g->mgau + 0)->mean + 0);
  } else {
    if (g->n_mgau != n_mgau) {
      _E__pr_header("cont_mgau.c", 198L, "FATAL_ERROR");
      _E__die_error("#Mixtures(%d) doesn\'t match that of means(%d)\n", n_mgau, g->n_mgau);
    }
    if (g->max_comp != n_density) {
      _E__pr_header("cont_mgau.c", 200L, "FATAL_ERROR");
      _E__die_error("#Components(%d) doesn\'t match that of means(%d)\n", n_density,
                    g->max_comp);
    }
    if (g->veclen != blk) {
      _E__pr_header("cont_mgau.c", 202L, "FATAL_ERROR");
      _E__die_error("#Vector length(%d) doesn\'t match that of means(%d)\n", blk,
                    g->veclen);
    }
    tmp___13 = __ckd_calloc__((size_t )n, sizeof(float32 ), "cont_mgau.c", 204);
    buf = (float32 *)tmp___13;
    tmp___14 = __ckd_calloc__((size_t )(n_mgau * n_density), sizeof(float32 *), "cont_mgau.c",
                              205);
    pbuf = (float32 **)tmp___14;
    i = 0;
    while (i < n_mgau) {
      if ((g->mgau + i)->n_comp != n_density) {
        _E__pr_header("cont_mgau.c", 210L, "FATAL_ERROR");
        _E__die_error("Mixture %d: #Components(%d) doesn\'t match that of means(%d)\n",
                      i, n_density, (g->mgau + i)->n_comp);
      }
      (g->mgau + i)->var = pbuf;
      k___0 = 0;
      while (k___0 < n_density) {
        *((g->mgau + i)->var + k___0) = buf;
        buf += blk;
        k___0 ++;
      }
      pbuf += n_density;
      i ++;
    }
    tmp___15 = __ckd_calloc__((size_t )(n_mgau * n_density), sizeof(float32 ), "cont_mgau.c",
                              224);
    buf = (float32 *)tmp___15;
    i = 0;
    while (i < n_mgau) {
      (g->mgau + i)->lrd = buf;
      buf += n_density;
      i ++;
    }
    buf = *((g->mgau + 0)->var + 0);
  }
  tmp___16 = bio_fread((void *)buf, (int32 )sizeof(float32 ), n, fp, byteswap, & chksum);
  if (tmp___16 != n) {
    _E__pr_header("cont_mgau.c", 236L, "FATAL_ERROR");
    _E__die_error("fread(%s) (densitydata) failed\n", file_name);
  }
  f = log_to_logs3_factor();
  if (chksum_present) {
    bio_verify_chksum(fp, byteswap, chksum);
  }
  tmp___17 = fread((void *)(& tmp), (size_t )1, (size_t )1, fp);
  if (tmp___17 == 1UL) {
    _E__pr_header("cont_mgau.c", 244L, "FATAL_ERROR");
    _E__die_error("%s: More data than expected\n", file_name);
  }
  fclose(fp);
  _E__pr_info_header("cont_mgau.c", 248L, "INFO");
  _E__pr_info("%d mixture Gaussians, %d components, %d streams, veclen %d\n", n_mgau,
              n_density, n_feat, blk);
  return (0);
}
}
static int32 mgau_mixw_read(mgau_model_t *g , char *file_name , float64 mixwfloor ) 
{ 
  char **argname ;
  char **argval___0 ;
  char eofchk ;
  FILE *fp ;
  int32 byteswap ;
  int32 chksum_present ;
  uint32 chksum ;
  int32 *buf ;
  float32 *pdf ;
  int32 i ;
  int32 j ;
  int32 n ;
  int32 n_mgau ;
  int32 n_feat ;
  int32 n_comp ;
  int32 n_err ;
  int32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int32 tmp___3 ;
  int32 tmp___4 ;
  int32 tmp___5 ;
  int32 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int32 tmp___9 ;
  int32 tmp___10 ;
  int32 tmp___11 ;
  size_t tmp___12 ;

  {
  _E__pr_info_header("cont_mgau.c", 269L, "INFO");
  _E__pr_info("Reading mixture weights file \'%s\'\n", file_name);
  fp = _myfopen(file_name, (char *)"rb", (char *)"cont_mgau.c", 271);
  tmp = bio_readhdr(fp, & argname, & argval___0, & byteswap);
  if (tmp < 0) {
    _E__pr_header("cont_mgau.c", 275L, "FATAL_ERROR");
    _E__die_error("bio_readhdr(%s) failed\n", file_name);
  }
  chksum_present = 0;
  i = 0;
  while (*(argname + i)) {
    tmp___2 = strcmp((char const   *)*(argname + i), "version");
    if (tmp___2 == 0) {
      tmp___0 = strcmp((char const   *)*(argval___0 + i), "1.0");
      if (tmp___0 != 0) {
        _E__pr_header("cont_mgau.c", 282L, "WARNING");
        _E__pr_warn("Version mismatch(%s): %s, expecting %s\n", file_name, *(argval___0 + i),
                    "1.0");
      }
    } else {
      tmp___1 = strcmp((char const   *)*(argname + i), "chksum0");
      if (tmp___1 == 0) {
        chksum_present = 1;
      }
    }
    i ++;
  }
  bio_hdrarg_free(argname, argval___0);
  argval___0 = (char **)((void *)0);
  argname = argval___0;
  chksum = (uint32 )0;
  tmp___3 = bio_fread((void *)(& n_mgau), (int32 )sizeof(int32 ), 1, fp, byteswap,
                      & chksum);
  if (tmp___3 != 1) {
    _E__pr_header("cont_mgau.c", 298L, "FATAL_ERROR");
    _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
  } else {
    tmp___4 = bio_fread((void *)(& n_feat), (int32 )sizeof(int32 ), 1, fp, byteswap,
                        & chksum);
    if (tmp___4 != 1) {
      _E__pr_header("cont_mgau.c", 298L, "FATAL_ERROR");
      _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
    } else {
      tmp___5 = bio_fread((void *)(& n_comp), (int32 )sizeof(int32 ), 1, fp, byteswap,
                          & chksum);
      if (tmp___5 != 1) {
        _E__pr_header("cont_mgau.c", 298L, "FATAL_ERROR");
        _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
      } else {
        tmp___6 = bio_fread((void *)(& n), (int32 )sizeof(int32 ), 1, fp, byteswap,
                            & chksum);
        if (tmp___6 != 1) {
          _E__pr_header("cont_mgau.c", 298L, "FATAL_ERROR");
          _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
        }
      }
    }
  }
  if (g->gau_type == 10001) {
    if (n_feat != 1) {
      _E__pr_header("cont_mgau.c", 302L, "FATAL_ERROR");
      _E__die_error("#Features streams(%d) != 1 in continuous HMM\n", n_feat);
    }
  } else
  if (g->gau_type == 10002) {
    if (n_feat != 4) {
      _E__pr_header("cont_mgau.c", 305L, "FATAL_ERROR");
      _E__die_error("#Features streams(%d) != 4 in semi-continuous HMM\n", n_feat);
    }
  } else {
    _E__pr_header("cont_mgau.c", 307L, "FATAL_ERROR");
    _E__die_error("How can this happen? Someone must have moved this part of the code somewhere! Not my fault! ARCHAN at 20040504 :-)\n");
  }
  if (n != n_mgau * n_comp) {
    _E__pr_header("cont_mgau.c", 311L, "FATAL_ERROR");
    _E__die_error("%s: #float32s(%d) doesn\'t match header dimensions: %d x %d\n",
                  file_name, i, n_mgau, n_comp);
  }
  if (n_mgau != g->n_mgau) {
    _E__pr_header("cont_mgau.c", 315L, "FATAL_ERROR");
    _E__die_error("%s: #Mixture Gaussians(%d) doesn\'t match mean/var parameters(%d)\n",
                  n_mgau, g->n_mgau);
  }
  tmp___7 = __ckd_calloc__((size_t )(n_mgau * n_comp), sizeof(int32 ), "cont_mgau.c",
                           318);
  buf = (int32 *)tmp___7;
  i = 0;
  while (i < n_mgau) {
    if (n_comp != (g->mgau + i)->n_comp) {
      _E__pr_header("cont_mgau.c", 321L, "FATAL_ERROR");
      _E__die_error("Mixture %d: #Weights(%d) doesn\'t match #Gaussian components(%d)\n",
                    i, n_comp, (g->mgau + i)->n_comp);
    }
    (g->mgau + i)->mixw = buf;
    buf += (g->mgau + i)->n_comp;
    i ++;
  }
  tmp___8 = __ckd_calloc__((size_t )n_comp, sizeof(float32 ), "cont_mgau.c", 329);
  pdf = (float32 *)tmp___8;
  n_err = 0;
  i = 0;
  while (i < n_mgau) {
    tmp___9 = bio_fread((void *)pdf, (int32 )sizeof(float32 ), n_comp, fp, byteswap,
                        & chksum);
    if (tmp___9 != n_comp) {
      _E__pr_header("cont_mgau.c", 335L, "FATAL_ERROR");
      _E__die_error("bio_fread(%s) (arraydata) failed\n", file_name);
    }
    tmp___11 = vector_is_zero(pdf, n_comp);
    if (tmp___11) {
      n_err ++;
      j = 0;
      while (j < n_comp) {
        *((g->mgau + i)->mixw + j) = (int32 )3355443200U;
        j ++;
      }
    } else {
      vector_nz_floor(pdf, n_comp, mixwfloor);
      vector_sum_norm(pdf, n_comp);
      j = 0;
      while (j < n_comp) {
        if ((double )*(pdf + j) != 0.0) {
          tmp___10 = logs3((float64 )*(pdf + j));
          *((g->mgau + i)->mixw + j) = tmp___10;
        } else {
          *((g->mgau + i)->mixw + j) = (int32 )3355443200U;
        }
        j ++;
      }
    }
    i ++;
  }
  ckd_free((void *)pdf);
  if (chksum_present) {
    bio_verify_chksum(fp, byteswap, chksum);
  }
  tmp___12 = fread((void *)(& eofchk), (size_t )1, (size_t )1, fp);
  if (tmp___12 == 1UL) {
    _E__pr_header("cont_mgau.c", 358L, "FATAL_ERROR");
    _E__die_error("More data than expected in %s\n", file_name);
  }
  fclose(fp);
  _E__pr_info_header("cont_mgau.c", 362L, "INFO");
  _E__pr_info("Read %d x %d mixture weights\n", n_mgau, n_comp);
  return (0);
}
}
static void mgau_uninit_compact(mgau_model_t *g ) 
{ 
  int32 m ;
  int32 c ;
  int32 c2 ;
  int32 n ;
  int32 nm ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int32 tmp___3 ;

  {
  _E__pr_info_header("cont_mgau.c", 378L, "INFO");
  _E__pr_info("Removing uninitialized Gaussian densities\n");
  n = 0;
  nm = 0;
  m = 0;
  while (m < g->n_mgau) {
    c = 0;
    c2 = 0;
    while (c < (g->mgau + m)->n_comp) {
      tmp___3 = vector_is_zero(*((g->mgau + m)->var + c), g->veclen);
      if (tmp___3) {
        n ++;
      } else {
        if (c2 != c) {
          tmp___0 = __builtin_object_size((void *)*((g->mgau + m)->mean + c2), 0);
          if (tmp___0 != 0xffffffffffffffffUL) {
            tmp = __builtin_object_size((void *)*((g->mgau + m)->mean + c2), 0);
            __builtin___memcpy_chk((void *)*((g->mgau + m)->mean + c2), (void const   *)*((g->mgau + m)->mean + c),
                                   (unsigned long )g->veclen * sizeof(float32 ), tmp);
          } else {
            __inline_memcpy_chk((void *)*((g->mgau + m)->mean + c2), (void const   *)*((g->mgau + m)->mean + c),
                                (unsigned long )g->veclen * sizeof(float32 ));
          }
          tmp___2 = __builtin_object_size((void *)*((g->mgau + m)->var + c2), 0);
          if (tmp___2 != 0xffffffffffffffffUL) {
            tmp___1 = __builtin_object_size((void *)*((g->mgau + m)->var + c2), 0);
            __builtin___memcpy_chk((void *)*((g->mgau + m)->var + c2), (void const   *)*((g->mgau + m)->var + c),
                                   (unsigned long )g->veclen * sizeof(float32 ), tmp___1);
          } else {
            __inline_memcpy_chk((void *)*((g->mgau + m)->var + c2), (void const   *)*((g->mgau + m)->var + c),
                                (unsigned long )g->veclen * sizeof(float32 ));
          }
          *((g->mgau + m)->mixw + c2) = *((g->mgau + m)->mixw + c);
        }
        c2 ++;
      }
      c ++;
    }
    (g->mgau + m)->n_comp = c2;
    if (c2 == 0) {
      fprintf(__stdoutp, " %d", m);
      nm ++;
    }
    m ++;
  }
  if (nm > 0) {
    fprintf(__stdoutp, "\n");
  }
  if (nm > 0) {
    _E__pr_info_header("cont_mgau.c", 408L, "INFO");
    _E__pr_info("%d densities removed (%d mixtures removed entirely)\n", n, nm);
  } else
  if (n > 0) {
    _E__pr_info_header("cont_mgau.c", 408L, "INFO");
    _E__pr_info("%d densities removed (%d mixtures removed entirely)\n", n, nm);
  }
  return;
}
}
static void mgau_var_floor(mgau_model_t *g , float64 floor___0 ) 
{ 
  int32 m ;
  int32 c ;
  int32 i ;
  int32 n ;

  {
  _E__pr_info_header("cont_mgau.c", 416L, "INFO");
  _E__pr_info("Applying variance floor\n");
  n = 0;
  m = 0;
  while (m < g->n_mgau) {
    c = 0;
    while (c < (g->mgau + m)->n_comp) {
      i = 0;
      while (i < g->veclen) {
        if ((float64 )*(*((g->mgau + m)->var + c) + i) < floor___0) {
          *(*((g->mgau + m)->var + c) + i) = (float32 )floor___0;
          n ++;
        }
        i ++;
      }
      c ++;
    }
    m ++;
  }
  _E__pr_info_header("cont_mgau.c", 428L, "INFO");
  _E__pr_info("%d variance values floored\n", n);
  return;
}
}
int32 mgau_var_nzvec_floor(mgau_model_t *g , float64 floor___0 ) 
{ 
  int32 m ;
  int32 c ;
  int32 i ;
  int32 n ;
  int32 l ;
  float32 *var ;
  int32 tmp ;

  {
  _E__pr_info_header("cont_mgau.c", 437L, "INFO");
  _E__pr_info("Applying variance floor to non-zero variance vectors\n");
  l = g->veclen;
  n = 0;
  m = 0;
  while (m < g->n_mgau) {
    c = 0;
    while (c < (g->mgau + m)->n_comp) {
      var = *((g->mgau + m)->var + c);
      tmp = vector_is_zero(var, l);
      if (! tmp) {
        i = 0;
        while (i < l) {
          if ((float64 )*(var + i) < floor___0) {
            *(var + i) = (float32 )floor___0;
            n ++;
          }
          i ++;
        }
      }
      c ++;
    }
    m ++;
  }
  _E__pr_info_header("cont_mgau.c", 457L, "INFO");
  _E__pr_info("%d variance values floored\n", n);
  return (n);
}
}
static int32 mgau_precomp(mgau_model_t *g ) 
{ 
  int32 m ;
  int32 c ;
  int32 i ;
  float64 lrd ;
  float64 f ;
  double tmp ;
  double tmp___0 ;

  {
  f = log_to_logs3_factor();
  _E__pr_info_header("cont_mgau.c", 474L, "INFO");
  _E__pr_info("Precomputing Mahalanobis distance invariants\n");
  m = 0;
  while (m < g->n_mgau) {
    c = 0;
    while (c < (g->mgau + m)->n_comp) {
      lrd = 0.0;
      i = 0;
      while (i < g->veclen) {
        tmp = log((double )*(*((g->mgau + m)->var + c) + i));
        lrd += tmp;
        *(*((g->mgau + m)->var + c) + i) = (float32 )(1.0 / ((double )*(*((g->mgau + m)->var + c) + i) * 2.0));
        i ++;
      }
      tmp___0 = log(2.0 * 3.14159265358979323846264338327950288);
      lrd += (double )g->veclen * tmp___0;
      *((g->mgau + m)->lrd + c) = (float32 )(- 0.5 * lrd);
      c ++;
    }
    m ++;
  }
  return (0);
}
}
mgau_model_t *mgau_init(char *meanfile , char *varfile , float64 varfloor , char *mixwfile ,
                        float64 mixwfloor , int32 precomp , char *senmgau ) 
{ 
  mgau_model_t *g ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = __ckd_calloc__((size_t )1, sizeof(mgau_model_t ), "cont_mgau.c", 509);
  g = (mgau_model_t *)tmp;
  tmp___1 = strcmp((char const   *)senmgau, ".cont.");
  if (tmp___1 == 0) {
    g->gau_type = 10001;
  } else {
    tmp___0 = strcmp((char const   *)senmgau, ".semi.");
    if (tmp___0 == 0) {
      g->gau_type = 10002;
    } else {
      _E__pr_header("cont_mgau.c", 516L, "FATAL_ERROR");
      _E__die_error("Feature should be either .semi. or .cont.");
    }
  }
  mgau_file_read(g, meanfile, 1);
  mgau_file_read(g, varfile, 2);
  mgau_mixw_read(g, mixwfile, mixwfloor);
  mgau_uninit_compact(g);
  if (varfloor > 0.0) {
    mgau_var_floor(g, varfloor);
  }
  if (precomp) {
    mgau_precomp(g);
  }
  g->distfloor = logs3_to_log((int32 )3355443200U);
  return (g);
}
}
int32 mgau_comp_eval(mgau_model_t *g , int32 s___0 , float32 *x___0 , int32 *score ) 
{ 
  mgau_t *mgau ;
  int32 veclen ;
  float32 *m ;
  float32 *v ;
  float64 dval ;
  float64 diff ;
  float64 f ;
  int32 bs___0 ;
  int32 i ;
  int32 c ;

  {
  veclen = g->veclen;
  mgau = g->mgau + s___0;
  f = log_to_logs3_factor();
  bs___0 = (int32 )2147483648U;
  c = 0;
  while (c < mgau->n_comp) {
    m = *(mgau->mean + c);
    v = *(mgau->var + c);
    dval = (float64 )*(mgau->lrd + c);
    i = 0;
    while (i < veclen) {
      diff = (float64 )(*(x___0 + i) - *(m + i));
      dval -= (diff * diff) * (float64 )*(v + i);
      i ++;
    }
    if (dval < g->distfloor) {
      dval = g->distfloor;
    }
    *(score + c) = (int32 )(f * dval);
    if (*(score + c) > bs___0) {
      bs___0 = *(score + c);
    }
    c ++;
  }
  return (bs___0);
}
}
int32 mgau_eval(mgau_model_t *g , int32 m , int32 *active , float32 *x___0 ) 
{ 
  mgau_t *mgau ;
  int32 veclen ;
  int32 score ;
  float32 *m1 ;
  float32 *m2 ;
  float32 *v1 ;
  float32 *v2 ;
  float64 dval1 ;
  float64 dval2 ;
  float64 diff1 ;
  float64 diff2 ;
  float64 f ;
  int32 i ;
  int32 j ;
  int32 c ;

  {
  veclen = g->veclen;
  mgau = g->mgau + m;
  f = log_to_logs3_factor();
  score = (int32 )3355443200U;
  if (! active) {
    c = 0;
    while (c < mgau->n_comp - 1) {
      m1 = *(mgau->mean + c);
      m2 = *(mgau->mean + (c + 1));
      v1 = *(mgau->var + c);
      v2 = *(mgau->var + (c + 1));
      dval1 = (float64 )*(mgau->lrd + c);
      dval2 = (float64 )*(mgau->lrd + (c + 1));
      i = 0;
      while (i < veclen) {
        diff1 = (float64 )(*(x___0 + i) - *(m1 + i));
        dval1 -= (diff1 * diff1) * (float64 )*(v1 + i);
        diff2 = (float64 )(*(x___0 + i) - *(m2 + i));
        dval2 -= (diff2 * diff2) * (float64 )*(v2 + i);
        i ++;
      }
      if (dval1 < g->distfloor) {
        dval1 = g->distfloor;
      }
      if (dval2 < g->distfloor) {
        dval2 = g->distfloor;
      }
      score = logs3_add(score, (int32 )(f * dval1) + *(mgau->mixw + c));
      score = logs3_add(score, (int32 )(f * dval2) + *(mgau->mixw + (c + 1)));
      c += 2;
    }
    if (c < mgau->n_comp) {
      m1 = *(mgau->mean + c);
      v1 = *(mgau->var + c);
      dval1 = (float64 )*(mgau->lrd + c);
      i = 0;
      while (i < veclen) {
        diff1 = (float64 )(*(x___0 + i) - *(m1 + i));
        dval1 -= (diff1 * diff1) * (float64 )*(v1 + i);
        i ++;
      }
      if (dval1 < g->distfloor) {
        dval1 = g->distfloor;
      }
      score = logs3_add(score, (int32 )(f * dval1) + *(mgau->mixw + c));
    }
  } else {
    j = 0;
    while (*(active + j) >= 0) {
      considered ++;
      c = *(active + j);
      m1 = *(mgau->mean + c);
      v1 = *(mgau->var + c);
      dval1 = (float64 )*(mgau->lrd + c);
      i = 0;
      while (i < veclen) {
        diff1 = (float64 )(*(x___0 + i) - *(m1 + i));
        dval1 -= (diff1 * diff1) * (float64 )*(v1 + i);
        i ++;
      }
      if (dval1 < g->distfloor) {
        dval1 = g->distfloor;
      }
      score = logs3_add(score, (int32 )(f * dval1) + *(mgau->mixw + c));
      j ++;
    }
  }
  return (score);
}
}
void mgau_free(mgau_model_t *g ) 
{ 


  {
  if (g) {
    if ((g->mgau + 0)->mean) {
      ckd_free((void *)(g->mgau + 0)->mean);
    }
    if ((g->mgau + 0)->var) {
      ckd_free((void *)(g->mgau + 0)->var);
    }
    if ((g->mgau + 0)->lrd) {
      ckd_free((void *)(g->mgau + 0)->lrd);
    }
    if ((g->mgau + 0)->mixw) {
      ckd_free((void *)(g->mgau + 0)->mixw);
    }
    if (g->mgau) {
      ckd_free((void *)g->mgau);
    }
    ckd_free((void *)g);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-zDhiohau.i","-O3")
void _E__fatal_sys_error(char const   *fmt  , ...) ;
int32 str2words(char *line , char **ptr , int32 max_ptr ) ;
s3cipid_t mdef_ciphone_id(mdef_t *m , char *ci ) ;
char const   *mdef_ciphone_str(mdef_t *m , s3cipid_t id ) ;
dict_t *dict_init(mdef_t *mdef , char *dictfile , char *fillerfile , char comp_sep ) ;
s3wid_t dict_wordid(dict_t *d , char *word ) ;
int32 dict_filler_word(dict_t *d , s3wid_t w___0 ) ;
s3wid_t dict_add_word(dict_t *d , char *word , s3cipid_t *p , int32 np ) ;
s3wid_t dict_wids2compwid(dict_t *d , s3wid_t *wid , int32 len ) ;
char const   *dict_ciphone_str(dict_t *d , s3wid_t wid , int32 pos ) ;
s3wid_t _dict_basewid(dict_t *d , s3wid_t w___0 ) ;
char *_dict_wordstr(dict_t *d , s3wid_t wid ) ;
s3wid_t _dict_nextalt(dict_t *d , s3wid_t wid ) ;
int32 dict_word2basestr(char *word ) ;
void dict_free(dict_t *d ) ;
static s3cipid_t dict_ciphone_id(dict_t *d , char *str ) 
{ 
  int32 id ;
  s3cipid_t tmp ;
  int32 tmp___0 ;
  char *tmp___1 ;
  int32 tmp___2 ;
  int32 tmp___3 ;

  {
  if (d->mdef) {
    tmp = mdef_ciphone_id(d->mdef, str);
    return (tmp);
  } else {
    tmp___3 = hash_lookup(d->pht, (char const   *)str, & id);
    if (tmp___3 < 0) {
      tmp___0 = d->n_ciphone;
      (d->n_ciphone) ++;
      id = tmp___0;
      if (id >= 127) {
        _E__pr_header("dict.c", 81L, "FATAL_ERROR");
        _E__die_error("Too many CIphones in dictionary; increase MAX_S3CIPID\n");
      }
      tmp___1 = __ckd_salloc__((char const   *)str, "dict.c", 82);
      *(d->ciphone_str + id) = tmp___1;
      tmp___2 = hash_enter(d->pht, (char const   *)*(d->ciphone_str + id), id);
      if (tmp___2 != id) {
        _E__pr_header("dict.c", 85L, "FATAL_ERROR");
        _E__die_error("hash_enter(local-phonetable, %s) failed\n", str);
      }
    }
    return ((s3cipid_t )id);
  }
}
}
char const   *dict_ciphone_str(dict_t *d , s3wid_t wid , int32 pos ) 
{ 
  char const   *tmp ;

  {
  if (d->mdef) {
    tmp = mdef_ciphone_str(d->mdef, *((d->word + wid)->ciphone + pos));
    return (tmp);
  } else {
    return ((char const   *)*(d->ciphone_str + (int )*((d->word + wid)->ciphone + pos)));
  }
}
}
s3wid_t dict_add_word(dict_t *d , char *word , s3cipid_t *p , int32 np ) 
{ 
  int32 w___0 ;
  int32 len ;
  dictword_t *wordp ;
  s3wid_t newwid ;
  char *tmp ;
  int32 tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  int32 tmp___4 ;
  int32 tmp___5 ;

  {
  if (d->n_word >= d->max_words) {
    _E__pr_header("dict.c", 112L, "ERROR");
    _E__pr_warn("Dictionary full; add(%s) failed\n", word);
    return (-1);
  }
  wordp = d->word + d->n_word;
  tmp = __ckd_salloc__((char const   *)word, "dict.c", 117);
  wordp->word = tmp;
  tmp___0 = hash_enter(d->ht, (char const   *)wordp->word, d->n_word);
  if (tmp___0 != d->n_word) {
    ckd_free((void *)wordp->word);
    return (-1);
  }
  if (p) {
    if (np > 0) {
      tmp___1 = __ckd_malloc__((unsigned long )np * sizeof(s3cipid_t ), "dict.c",
                               127);
      wordp->ciphone = (s3cipid_t *)tmp___1;
      tmp___3 = __builtin_object_size((void *)wordp->ciphone, 0);
      if (tmp___3 != 0xffffffffffffffffUL) {
        tmp___2 = __builtin_object_size((void *)wordp->ciphone, 0);
        __builtin___memcpy_chk((void *)wordp->ciphone, (void const   *)p, (unsigned long )np * sizeof(s3cipid_t ),
                               tmp___2);
      } else {
        __inline_memcpy_chk((void *)wordp->ciphone, (void const   *)p, (unsigned long )np * sizeof(s3cipid_t ));
      }
      wordp->pronlen = np;
    } else {
      wordp->ciphone = (s3cipid_t *)((void *)0);
      wordp->pronlen = 0;
    }
  } else {
    wordp->ciphone = (s3cipid_t *)((void *)0);
    wordp->pronlen = 0;
  }
  wordp->alt = -1;
  wordp->basewid = d->n_word;
  wordp->n_comp = 0;
  wordp->comp = (s3wid_t *)((void *)0);
  len = dict_word2basestr(word);
  if (len > 0) {
    tmp___4 = hash_lookup(d->ht, (char const   *)word, & w___0);
    if (tmp___4 < 0) {
      *(word + len) = (char )'(';
      _E__pr_header("dict.c", 144L, "FATAL_ERROR");
      _E__die_error("Missing base word for: %s\n", word);
    } else {
      *(word + len) = (char )'(';
    }
    wordp->basewid = w___0;
    wordp->alt = (d->word + w___0)->alt;
    (d->word + w___0)->alt = d->n_word;
  }
  tmp___5 = d->n_word;
  (d->n_word) ++;
  newwid = tmp___5;
  return (newwid);
}
}
static int32 dict_read(FILE *fp , dict_t *d ) 
{ 
  char line[16384] ;
  char **wptr ;
  s3cipid_t p[4096] ;
  int32 lineno ;
  int32 nwd ;
  s3wid_t w___0 ;
  int32 i ;
  int32 maxwd ;
  void *tmp ;
  char *tmp___0 ;

  {
  maxwd = 4092;
  tmp = __ckd_calloc__((size_t )maxwd, sizeof(char *), "dict.c", 169);
  wptr = (char **)tmp;
  lineno = 0;
  while (1) {
    tmp___0 = fgets(line, (int )sizeof(line), fp);
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
      break;
    }
    lineno ++;
    if ((int )line[0] == 35) {
      continue;
    }
    nwd = str2words(line, wptr, maxwd);
    if (nwd < 0) {
      _E__pr_header("dict.c", 178L, "FATAL_ERROR");
      _E__die_error("str2words(%s) failed; Increase maxwd from %d\n", line, maxwd);
    }
    if (nwd == 0) {
      continue;
    }
    if (nwd == 1) {
      _E__pr_header("dict.c", 184L, "ERROR");
      _E__pr_warn("Line %d: No pronunciation for word %s; ignored\n", lineno, *(wptr + 0));
      continue;
    }
    i = 1;
    while (i < nwd) {
      p[i - 1] = dict_ciphone_id(d, *(wptr + i));
      if ((int )p[i - 1] < 0) {
        _E__pr_header("dict.c", 192L, "ERROR");
        _E__pr_warn("Line %d: Bad ciphone: %s; word %s ignored\n", lineno, *(wptr + i),
                    *(wptr + 0));
        break;
      }
      i ++;
    }
    if (i == nwd) {
      w___0 = dict_add_word(d, *(wptr + 0), p, nwd - 1);
      if (w___0 < 0) {
        _E__pr_header("dict.c", 201L, "ERROR");
        _E__pr_warn("Line %d: dict_add_word (%s) failed (duplicate?); ignored\n",
                    lineno, *(wptr + 0));
      }
    }
  }
  ckd_free((void *)wptr);
  return (0);
}
}
static s3wid_t *dict_comp_head(dict_t *d ) 
{ 
  int32 w___0 ;
  s3wid_t *comp_head ;
  void *tmp ;

  {
  tmp = __ckd_calloc__((size_t )d->n_word, sizeof(s3wid_t ), "dict.c", 217);
  comp_head = (s3wid_t *)tmp;
  w___0 = 0;
  while (w___0 < d->n_word) {
    *(comp_head + w___0) = -1;
    w___0 ++;
  }
  w___0 = 0;
  while (w___0 < d->n_word) {
    if ((d->word + w___0)->n_comp > 0) {
      *(comp_head + w___0) = *(comp_head + *((d->word + w___0)->comp + 0));
      *(comp_head + *((d->word + w___0)->comp + 0)) = w___0;
    }
    w___0 ++;
  }
  return (comp_head);
}
}
static int32 dict_build_comp(dict_t *d , char sep ) 
{ 
  char wd[4096] ;
  int32 w___0 ;
  int32 cwid ;
  dictword_t *wordp ;
  int32 nc ;
  int32 i ;
  int32 j ;
  int32 l ;
  int32 n ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int32 tmp___2 ;
  void *tmp___3 ;

  {
  nc = 0;
  w___0 = 0;
  while (w___0 < d->n_word) {
    wordp = d->word + (d->word + w___0)->basewid;
    tmp___0 = __builtin_object_size((void *)(wd), 0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)(wd), 1);
      __builtin___strcpy_chk(wd, (char const   *)wordp->word, tmp);
    } else {
      __inline_strcpy_chk(wd, (char const   *)wordp->word);
    }
    tmp___1 = strlen((char const   *)(wd));
    l = (int32 )tmp___1;
    if ((int )wd[0] == (int )sep) {
      _E__pr_header("dict.c", 253L, "FATAL_ERROR");
      _E__die_error("Bad compound word %s: leading or trailing separator\n", wordp->word);
    } else
    if ((int )wd[l - 1] == (int )sep) {
      _E__pr_header("dict.c", 253L, "FATAL_ERROR");
      _E__die_error("Bad compound word %s: leading or trailing separator\n", wordp->word);
    }
    n = 1;
    i = 1;
    while (i < l - 1) {
      if ((int )wd[i] == (int )sep) {
        n ++;
      }
      i ++;
    }
    if (n == 1) {
      goto __Cont;
    }
    nc ++;
    if (w___0 == d->startwid) {
      _E__pr_header("dict.c", 265L, "FATAL_ERROR");
      _E__die_error("Compound special/filler word (%s) not allowed\n", wordp->word);
    } else
    if (w___0 == d->finishwid) {
      _E__pr_header("dict.c", 265L, "FATAL_ERROR");
      _E__die_error("Compound special/filler word (%s) not allowed\n", wordp->word);
    } else {
      tmp___2 = dict_filler_word(d, w___0);
      if (tmp___2) {
        _E__pr_header("dict.c", 265L, "FATAL_ERROR");
        _E__die_error("Compound special/filler word (%s) not allowed\n", wordp->word);
      }
    }
    wordp->n_comp = n;
    tmp___3 = __ckd_calloc__((size_t )n, sizeof(s3wid_t ), "dict.c", 269);
    wordp->comp = (s3wid_t *)tmp___3;
    n = 0;
    i = 0;
    while (i < l) {
      j = i;
      while (1) {
        if (i < l) {
          if (! ((int )wd[i] != (int )sep)) {
            break;
          }
        } else {
          break;
        }
        i ++;
      }
      if (j == i) {
        _E__pr_header("dict.c", 276L, "FATAL_ERROR");
        _E__die_error("Bad compound word %s: successive separators\n", wordp->word);
      }
      wd[i] = (char )'\000';
      cwid = dict_wordid(d, wd + j);
      if (cwid < 0) {
        _E__pr_header("dict.c", 281L, "FATAL_ERROR");
        _E__die_error("Component word %s of %s not in dictionary\n", wd + j, wordp->word);
      }
      *(wordp->comp + n) = cwid;
      n ++;
      i ++;
    }
    __Cont: /* CIL Label */ 
    w___0 ++;
  }
  if (nc > 0) {
    d->comp_head = dict_comp_head(d);
  }
  return (nc);
}
}
dict_t *dict_init(mdef_t *mdef , char *dictfile , char *fillerfile , char comp_sep ) 
{ 
  FILE *fp ;
  FILE *fp2 ;
  int32 n ;
  char line[1024] ;
  dict_t *d ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  if (! dictfile) {
    _E__pr_header("dict.c", 302L, "FATAL_ERROR");
    _E__die_error("No dictionary file\n");
  }
  fp = fopen((char const   *)dictfile, "r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    _E__pr_header("dict.c", 310L, "SYSTEM_ERROR");
    _E__fatal_sys_error("fopen(%s,r) failed\n", dictfile);
  }
  n = 0;
  while (1) {
    tmp = fgets(line, (int )sizeof(line), fp);
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
      break;
    }
    if ((int )line[0] != 35) {
      n ++;
    }
  }
  rewind(fp);
  fp2 = (FILE *)((void *)0);
  if (fillerfile) {
    fp2 = fopen((char const   *)fillerfile, "r");
    if ((unsigned long )fp2 == (unsigned long )((void *)0)) {
      _E__pr_header("dict.c", 321L, "SYSTEM_ERROR");
      _E__fatal_sys_error("fopen(%s,r) failed\n", fillerfile);
    }
    while (1) {
      tmp___0 = fgets(line, (int )sizeof(line), fp2);
      if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
        break;
      }
      if ((int )line[0] != 35) {
        n ++;
      }
    }
    rewind(fp2);
  }
  tmp___1 = __ckd_calloc__((size_t )1, sizeof(dict_t ), "dict.c", 334);
  d = (dict_t *)tmp___1;
  if (n + 1024 < 2147483646) {
    d->max_words = n + 1024;
  } else {
    d->max_words = 2147483646;
  }
  if (n >= 2147483646) {
    _E__pr_header("dict.c", 337L, "FATAL_ERROR");
    _E__die_error("#Words in dictionaries (%d) exceeds limit (%d)\n", n, 2147483646);
  }
  tmp___2 = __ckd_calloc__((size_t )d->max_words, sizeof(dictword_t ), "dict.c", 339);
  d->word = (dictword_t *)tmp___2;
  d->n_word = 0;
  d->mdef = mdef;
  if (mdef) {
    d->pht = (hash_table_t *)((void *)0);
    d->ciphone_str = (char **)((void *)0);
  } else {
    d->pht = hash_new(128, 1);
    tmp___3 = __ckd_calloc__((size_t )128, sizeof(char *), "dict.c", 347);
    d->ciphone_str = (char **)tmp___3;
  }
  d->n_ciphone = 0;
  d->ht = hash_new(d->max_words, 1);
  d->comp_head = (s3wid_t *)((void *)0);
  _E__pr_info_header("dict.c", 358L, "INFO");
  _E__pr_info("Reading main dictionary: %s\n", dictfile);
  dict_read(fp, d);
  fclose(fp);
  _E__pr_info_header("dict.c", 361L, "INFO");
  _E__pr_info("%d words read\n", d->n_word);
  d->filler_start = d->n_word;
  if (fillerfile) {
    _E__pr_info_header("dict.c", 366L, "INFO");
    _E__pr_info("Reading filler dictionary: %s\n", fillerfile);
    dict_read(fp2, d);
    fclose(fp2);
    _E__pr_info_header("dict.c", 369L, "INFO");
    _E__pr_info("%d words read\n", d->n_word - d->filler_start);
  }
  d->filler_end = d->n_word - 1;
  d->startwid = dict_wordid(d, (char *)"<s>");
  d->finishwid = dict_wordid(d, (char *)"</s>");
  d->silwid = dict_wordid(d, (char *)"<sil>");
  if (comp_sep) {
    _E__pr_info_header("dict.c", 388L, "INFO");
    _E__pr_info("Building compound words (separator = \'%c\')\n", (int )comp_sep);
    n = dict_build_comp(d, comp_sep);
    _E__pr_info_header("dict.c", 390L, "INFO");
    _E__pr_info("%d compound words\n", n);
  }
  return (d);
}
}
s3wid_t dict_wordid(dict_t *d , char *word ) 
{ 
  int32 w___0 ;
  int32 tmp ;

  {
  tmp = hash_lookup(d->ht, (char const   *)word, & w___0);
  if (tmp < 0) {
    return (-1);
  }
  return (w___0);
}
}
s3wid_t _dict_basewid(dict_t *d , s3wid_t w___0 ) 
{ 


  {
  return ((d->word + w___0)->basewid);
}
}
char *_dict_wordstr(dict_t *d , s3wid_t wid ) 
{ 


  {
  return ((d->word + wid)->word);
}
}
s3wid_t _dict_nextalt(dict_t *d , s3wid_t wid ) 
{ 


  {
  return ((d->word + wid)->alt);
}
}
int32 dict_filler_word(dict_t *d , s3wid_t w___0 ) 
{ 


  {
  w___0 = (d->word + w___0)->basewid;
  if (w___0 == d->startwid) {
    return (0);
  } else
  if (w___0 == d->finishwid) {
    return (0);
  }
  if (w___0 >= d->filler_start) {
    if (w___0 <= d->filler_end) {
      return (1);
    }
  }
  return (0);
}
}
s3wid_t dict_wids2compwid(dict_t *d , s3wid_t *wid , int32 len ) 
{ 
  s3wid_t w___0 ;
  int32 i ;

  {
  if (! d->comp_head) {
    return (-1);
  }
  w___0 = *(d->comp_head + *(wid + 0));
  while (w___0 >= 0) {
    if ((d->word + w___0)->n_comp == len) {
      i = 0;
      while (1) {
        if (i < len) {
          if (! (*((d->word + w___0)->comp + i) == *(wid + i))) {
            break;
          }
        } else {
          break;
        }
        i ++;
      }
      if (i == len) {
        return ((d->word + w___0)->basewid);
      }
    }
    w___0 = *(d->comp_head + w___0);
  }
  return (-1);
}
}
int32 dict_word2basestr(char *word ) 
{ 
  int32 i ;
  int32 len ;
  size_t tmp ;

  {
  tmp = strlen((char const   *)word);
  len = (int32 )tmp;
  if ((int )*(word + (len - 1)) == 41) {
    i = len - 2;
    while (1) {
      if (i > 0) {
        if (! ((int )*(word + i) != 40)) {
          break;
        }
      } else {
        break;
      }
      i --;
    }
    if (i > 0) {
      *(word + i) = (char )'\000';
      return (i);
    }
  }
  return (-1);
}
}
void dict_free(dict_t *d ) 
{ 
  int i ;
  dictword_t *word ;

  {
  if (d) {
    i = 0;
    while (i < d->n_word) {
      word = d->word + i;
      if (word->word) {
        ckd_free((void *)word->word);
      }
      if (word->ciphone) {
        ckd_free((void *)word->ciphone);
      }
      if (word->comp) {
        ckd_free((void *)word->comp);
      }
      i ++;
    }
    if (d->word) {
      ckd_free((void *)d->word);
    }
    i = 0;
    while (i < d->n_ciphone) {
      if (*(d->ciphone_str + i)) {
        ckd_free((void *)*(d->ciphone_str + i));
      }
      i ++;
    }
    if (d->comp_head) {
      ckd_free((void *)d->comp_head);
    }
    if (d->ciphone_str) {
      ckd_free((void *)d->ciphone_str);
    }
    if (d->pht) {
      hash_free(d->pht);
    }
    if (d->ht) {
      hash_free(d->ht);
    }
    ckd_free((void *)d);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-r5Xi1jyB.i","-O3")
glist_t glist_add_int32(glist_t g , int32 val ) ;
int32 glist_chkdup_int32(glist_t g , int32 val ) ;
int32 glist_count(glist_t g ) ;
int32 hash_enter_bkey(hash_table_t *h , char const   *key , int32 len , int32 val ) ;
glist_t hash_tolist(hash_table_t *h , int32 *count ) ;
s3pid_t mdef_phone_id(mdef_t *m , s3cipid_t ci , s3cipid_t lc , s3cipid_t rc , word_posn_t wpos ) ;
s3pid_t mdef_phone_id_nearest(mdef_t *m , s3cipid_t b , s3cipid_t l , s3cipid_t r ,
                              word_posn_t pos ) ;
dict2pid_t *dict2pid_build(mdef_t *mdef , dict_t *dict ) ;
void dict2pid_comsenscr(dict2pid_t *d2p , int32 *senscr , int32 *comsenscr ) ;
void dict2pid_comsseq2sen_active(dict2pid_t *d2p , mdef_t *mdef , int32 *comssid ,
                                 int32 *sen ) ;
void dict2pid_dump(FILE *fp , dict2pid_t *d2p , mdef_t *mdef , dict_t *dict ) ;
static glist_t ldiph_comsseq(mdef_t *mdef , int32 b , int32 r ) 
{ 
  int32 l ;
  int32 p ;
  int32 ssid ;
  glist_t g ;
  int32 tmp ;

  {
  g = (glist_t )((void *)0);
  l = 0;
  while (l < mdef->n_ciphone) {
    p = mdef_phone_id(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r, (word_posn_t )0);
    if (p >= 0) {
      ssid = (mdef->phone + p)->ssid;
      tmp = glist_chkdup_int32(g, ssid);
      if (! tmp) {
        g = glist_add_int32(g, ssid);
      }
    }
    l ++;
  }
  if (! g) {
    g = glist_add_int32(g, (mdef->phone + b)->ssid);
  }
  return (g);
}
}
static glist_t rdiph_comsseq(mdef_t *mdef , int32 b , int32 l ) 
{ 
  int32 r ;
  int32 p ;
  int32 ssid ;
  glist_t g ;
  int32 tmp ;

  {
  g = (glist_t )((void *)0);
  r = 0;
  while (r < mdef->n_ciphone) {
    p = mdef_phone_id(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r, (word_posn_t )1);
    if (p >= 0) {
      ssid = (mdef->phone + p)->ssid;
      tmp = glist_chkdup_int32(g, ssid);
      if (! tmp) {
        g = glist_add_int32(g, ssid);
      }
    }
    r ++;
  }
  if (! g) {
    g = glist_add_int32(g, (mdef->phone + b)->ssid);
  }
  return (g);
}
}
static glist_t single_comsseq(mdef_t *mdef , int32 b ) 
{ 
  int32 l ;
  int32 r ;
  int32 p ;
  int32 ssid ;
  glist_t g ;
  int32 tmp ;

  {
  g = (glist_t )((void *)0);
  l = 0;
  while (l < mdef->n_ciphone) {
    r = 0;
    while (r < mdef->n_ciphone) {
      p = mdef_phone_id(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r, (word_posn_t )2);
      if (p >= 0) {
        ssid = (mdef->phone + p)->ssid;
        tmp = glist_chkdup_int32(g, ssid);
        if (! tmp) {
          g = glist_add_int32(g, ssid);
        }
      }
      r ++;
    }
    l ++;
  }
  if (! g) {
    g = glist_add_int32(g, (mdef->phone + b)->ssid);
  }
  return (g);
}
}
static glist_t single_lc_comsseq(mdef_t *mdef , int32 b , int32 l ) 
{ 
  int32 r ;
  int32 p ;
  int32 ssid ;
  glist_t g ;
  int32 tmp ;

  {
  g = (glist_t )((void *)0);
  r = 0;
  while (r < mdef->n_ciphone) {
    p = mdef_phone_id(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r, (word_posn_t )2);
    if (p >= 0) {
      ssid = (mdef->phone + p)->ssid;
      tmp = glist_chkdup_int32(g, ssid);
      if (! tmp) {
        g = glist_add_int32(g, ssid);
      }
    }
    r ++;
  }
  if (! g) {
    g = glist_add_int32(g, (mdef->phone + b)->ssid);
  }
  return (g);
}
}
static s3ssid_t ssidlist2comsseq(glist_t g , mdef_t *mdef , dict2pid_t *dict2pid ,
                                 hash_table_t *hs , hash_table_t *hp ) 
{ 
  int32 i ;
  int32 j ;
  int32 n ;
  int32 s___0 ;
  int32 ssid ;
  s3senid_t **sen ;
  s3senid_t *comsenid ;
  gnode_t *gn ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  n = glist_count(g);
  if (n <= 0) {
    _E__pr_header("dict2pid.c", 184L, "FATAL_ERROR");
    _E__die_error("Panic: length(ssidlist)= %d\n", n);
  }
  tmp = __ckd_calloc__((size_t )mdef->n_emit_state, sizeof(s3senid_t *), "dict2pid.c",
                       187);
  sen = (s3senid_t **)tmp;
  i = 0;
  while (i < mdef->n_emit_state) {
    tmp___0 = __ckd_calloc__((size_t )(n + 1), sizeof(s3senid_t ), "dict2pid.c", 189);
    *(sen + i) = (s3senid_t *)tmp___0;
    *(*(sen + i) + 0) = (s3senid_t )-1;
    i ++;
  }
  tmp___1 = __ckd_calloc__((size_t )mdef->n_emit_state, sizeof(s3senid_t ), "dict2pid.c",
                           193);
  comsenid = (s3senid_t *)tmp___1;
  gn = g;
  while (gn) {
    ssid = gn->data.int32;
    i = 0;
    while (i < mdef->n_emit_state) {
      s___0 = (int32 )*(*(mdef->sseq + ssid) + i);
      j = 0;
      while (1) {
        if ((int )*(*(sen + i) + j) >= 0) {
          if (! ((int )*(*(sen + i) + j) != s___0)) {
            break;
          }
        } else {
          break;
        }
        j ++;
      }
      if ((int )*(*(sen + i) + j) < 0) {
        *(*(sen + i) + j) = (s3senid_t )s___0;
        *(*(sen + i) + (j + 1)) = (s3senid_t )-1;
      }
      i ++;
    }
    gn = gn->next;
  }
  i = 0;
  while (i < mdef->n_emit_state) {
    j = 0;
    while ((int )*(*(sen + i) + j) >= 0) {
      j ++;
    }
    j = hash_enter_bkey(hs, (char const   *)((char *)*(sen + i)), (int32 )((unsigned long )j * sizeof(s3senid_t )),
                        dict2pid->n_comstate);
    if (j == dict2pid->n_comstate) {
      (dict2pid->n_comstate) ++;
    } else {
      ckd_free((void *)*(sen + i));
    }
    *(comsenid + i) = (s3senid_t )j;
    i ++;
  }
  ckd_free((void *)sen);
  j = hash_enter_bkey(hp, (char const   *)((char *)comsenid), (int32 )((unsigned long )mdef->n_emit_state * sizeof(s3senid_t )),
                      dict2pid->n_comsseq);
  if (j == dict2pid->n_comsseq) {
    (dict2pid->n_comsseq) ++;
    if (dict2pid->n_comsseq >= 32766) {
      _E__pr_header("dict2pid.c", 231L, "FATAL_ERROR");
      _E__die_error("#Composite sseq limit(%d) reached; increase MAX_S3SENID\n", dict2pid->n_comsseq);
    }
  } else {
    ckd_free((void *)comsenid);
  }
  return (j);
}
}
dict2pid_t *dict2pid_build(mdef_t *mdef , dict_t *dict ) 
{ 
  dict2pid_t *dict2pid ;
  s3ssid_t *internal ;
  s3ssid_t **ldiph ;
  s3ssid_t **rdiph ;
  s3ssid_t *single ;
  int32 pronlen ;
  hash_table_t *hs ;
  hash_table_t *hp ;
  glist_t g ;
  gnode_t *gn ;
  s3senid_t *sen ;
  hash_entry_t *he ;
  int32 *cslen ;
  int32 i ;
  int32 j ;
  int32 b ;
  int32 l ;
  int32 r ;
  int32 w___0 ;
  int32 n ;
  int32 p ;
  void *tmp ;
  void *tmp___0 ;
  void ***tmp___1 ;
  void **tmp___2 ;
  void *tmp___3 ;
  void **tmp___4 ;
  void **tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int32 tmp___12 ;

  {
  _E__pr_info_header("dict2pid.c", 254L, "INFO");
  _E__pr_info("Building PID tables for dictionary\n");
  tmp = __ckd_calloc__((size_t )1, sizeof(dict2pid_t ), "dict2pid.c", 256);
  dict2pid = (dict2pid_t *)tmp;
  tmp___0 = __ckd_calloc__((size_t )dict->n_word, sizeof(s3ssid_t *), "dict2pid.c",
                           257);
  dict2pid->internal = (s3ssid_t **)tmp___0;
  tmp___1 = __ckd_calloc_3d__(mdef->n_ciphone, mdef->n_ciphone, mdef->n_ciphone, (int32 )sizeof(s3ssid_t ),
                              "dict2pid.c", 261);
  dict2pid->ldiph_lc = (s3ssid_t ***)tmp___1;
  tmp___2 = __ckd_calloc_2d__(mdef->n_ciphone, mdef->n_ciphone, (int32 )sizeof(s3ssid_t ),
                              "dict2pid.c", 264);
  dict2pid->single_lc = (s3ssid_t **)tmp___2;
  dict2pid->n_comstate = 0;
  dict2pid->n_comsseq = 0;
  hs = hash_new((mdef->n_ciphone * mdef->n_ciphone) * mdef->n_emit_state, 0);
  hp = hash_new(mdef->n_ciphone * mdef->n_ciphone, 0);
  w___0 = 0;
  n = 0;
  while (w___0 < dict->n_word) {
    pronlen = (dict->word + w___0)->pronlen;
    if (pronlen < 0) {
      _E__pr_header("dict2pid.c", 274L, "FATAL_ERROR");
      _E__die_error("Pronunciation-length(%s)= %d\n", (dict->word + w___0)->word,
                    pronlen);
    }
    n += pronlen;
    w___0 ++;
  }
  tmp___3 = __ckd_calloc__((size_t )n, sizeof(s3ssid_t ), "dict2pid.c", 278);
  internal = (s3ssid_t *)tmp___3;
  tmp___4 = __ckd_calloc_2d__(mdef->n_ciphone, mdef->n_ciphone, (int32 )sizeof(s3ssid_t ),
                              "dict2pid.c", 281);
  ldiph = (s3ssid_t **)tmp___4;
  tmp___5 = __ckd_calloc_2d__(mdef->n_ciphone, mdef->n_ciphone, (int32 )sizeof(s3ssid_t ),
                              "dict2pid.c", 282);
  rdiph = (s3ssid_t **)tmp___5;
  tmp___6 = __ckd_calloc__((size_t )mdef->n_ciphone, sizeof(s3ssid_t ), "dict2pid.c",
                           283);
  single = (s3ssid_t *)tmp___6;
  b = 0;
  while (b < mdef->n_ciphone) {
    l = 0;
    while (l < mdef->n_ciphone) {
      r = 0;
      while (r < mdef->n_ciphone) {
        *(*(*(dict2pid->ldiph_lc + b) + r) + l) = -1;
        r ++;
      }
      *(*(dict2pid->single_lc + b) + l) = -1;
      *(*(ldiph + b) + l) = -1;
      *(*(rdiph + b) + l) = -1;
      l ++;
    }
    *(single + b) = -1;
    b ++;
  }
  w___0 = 0;
  while (w___0 < dict->n_word) {
    *(dict2pid->internal + w___0) = internal;
    pronlen = (dict->word + w___0)->pronlen;
    if (pronlen >= 2) {
      b = (int32 )*((dict->word + w___0)->ciphone + 0);
      r = (int32 )*((dict->word + w___0)->ciphone + 1);
      if (*(*(ldiph + b) + r) < 0) {
        g = ldiph_comsseq(mdef, b, r);
        *(*(ldiph + b) + r) = ssidlist2comsseq(g, mdef, dict2pid, hs, hp);
        glist_free(g);
        l = 0;
        while (l < mdef->n_ciphone) {
          p = mdef_phone_id_nearest(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r,
                                    (word_posn_t )0);
          *(*(*(dict2pid->ldiph_lc + b) + r) + l) = (mdef->phone + p)->ssid;
          l ++;
        }
      }
      *(internal + 0) = *(*(ldiph + b) + r);
      i = 1;
      while (i < pronlen - 1) {
        l = b;
        b = r;
        r = (int32 )*((dict->word + w___0)->ciphone + (i + 1));
        p = mdef_phone_id_nearest(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r,
                                  (word_posn_t )3);
        *(internal + i) = (mdef->phone + p)->ssid;
        i ++;
      }
      l = b;
      b = r;
      if (*(*(rdiph + b) + l) < 0) {
        g = rdiph_comsseq(mdef, b, l);
        *(*(rdiph + b) + l) = ssidlist2comsseq(g, mdef, dict2pid, hs, hp);
        glist_free(g);
      }
      *(internal + (pronlen - 1)) = *(*(rdiph + b) + l);
    } else
    if (pronlen == 1) {
      b = (int32 )*((dict->word + w___0)->ciphone + 0);
      if (*(single + b) < 0) {
        g = single_comsseq(mdef, b);
        *(single + b) = ssidlist2comsseq(g, mdef, dict2pid, hs, hp);
        glist_free(g);
        l = 0;
        while (l < mdef->n_ciphone) {
          g = single_lc_comsseq(mdef, b, l);
          *(*(dict2pid->single_lc + b) + l) = ssidlist2comsseq(g, mdef, dict2pid,
                                                               hs, hp);
          glist_free(g);
          l ++;
        }
      }
      *(internal + 0) = *(single + b);
    }
    internal += pronlen;
    w___0 ++;
  }
  ckd_free_2d((void **)ldiph);
  ckd_free_2d((void **)rdiph);
  ckd_free((void *)single);
  tmp___7 = __ckd_calloc__((size_t )dict2pid->n_comstate, sizeof(int32 ), "dict2pid.c",
                           357);
  cslen = (int32 *)tmp___7;
  g = hash_tolist(hs, & n);
  n = 0;
  gn = g;
  while (gn) {
    he = (hash_entry_t *)gn->data.ptr;
    sen = (s3senid_t *)he->key;
    i = 0;
    while ((int )*(sen + i) >= 0) {
      i ++;
    }
    *(cslen + he->val) = i + 1;
    n += i + 1;
    gn = gn->next;
  }
  tmp___8 = __ckd_calloc__((size_t )dict2pid->n_comstate, sizeof(s3senid_t *), "dict2pid.c",
                           370);
  dict2pid->comstate = (s3senid_t **)tmp___8;
  tmp___9 = __ckd_calloc__((size_t )n, sizeof(s3senid_t ), "dict2pid.c", 371);
  sen = (s3senid_t *)tmp___9;
  i = 0;
  while (i < dict2pid->n_comstate) {
    *(dict2pid->comstate + i) = sen;
    sen += *(cslen + i);
    i ++;
  }
  gn = g;
  while (gn) {
    he = (hash_entry_t *)gn->data.ptr;
    sen = (s3senid_t *)he->key;
    i = he->val;
    j = 0;
    while (j < *(cslen + i)) {
      *(*(dict2pid->comstate + i) + j) = *(sen + j);
      j ++;
    }
    ckd_free((void *)sen);
    gn = gn->next;
  }
  ckd_free((void *)cslen);
  glist_free(g);
  hash_free(hs);
  tmp___10 = __ckd_calloc__((size_t )dict2pid->n_comsseq, sizeof(s3senid_t *), "dict2pid.c",
                            394);
  dict2pid->comsseq = (s3senid_t **)tmp___10;
  g = hash_tolist(hp, & n);
  gn = g;
  while (gn) {
    he = (hash_entry_t *)gn->data.ptr;
    i = he->val;
    *(dict2pid->comsseq + i) = (s3senid_t *)he->key;
    gn = gn->next;
  }
  glist_free(g);
  hash_free(hp);
  tmp___11 = __ckd_calloc__((size_t )dict2pid->n_comstate, sizeof(int32 ), "dict2pid.c",
                            408);
  dict2pid->comwt = (int32 *)tmp___11;
  i = 0;
  while (i < dict2pid->n_comstate) {
    sen = *(dict2pid->comstate + i);
    j = 0;
    while ((int )*(sen + j) >= 0) {
      j ++;
    }
    tmp___12 = logs3((float64 )j);
    *(dict2pid->comwt + i) = - tmp___12;
    i ++;
  }
  _E__pr_info_header("dict2pid.c", 422L, "INFO");
  _E__pr_info("%d composite states; %d composite sseq\n", dict2pid->n_comstate, dict2pid->n_comsseq);
  return (dict2pid);
}
}
void dict2pid_comsenscr(dict2pid_t *d2p , int32 *senscr , int32 *comsenscr ) 
{ 
  int32 i ;
  int32 j ;
  int32 best ;
  s3senid_t *comstate ;
  s3senid_t k___0 ;

  {
  i = 0;
  while (i < d2p->n_comstate) {
    comstate = *(d2p->comstate + i);
    best = *(senscr + *(comstate + 0));
    j = 1;
    while (1) {
      k___0 = *(comstate + j);
      if ((int )k___0 < 0) {
        break;
      }
      if (best < *(senscr + k___0)) {
        best = *(senscr + k___0);
      }
      j ++;
    }
    *(comsenscr + i) = best + *(d2p->comwt + i);
    i ++;
  }
  return;
}
}
void dict2pid_comsseq2sen_active(dict2pid_t *d2p , mdef_t *mdef , int32 *comssid ,
                                 int32 *sen ) 
{ 
  int32 ss ;
  int32 cs ;
  int32 i ;
  int32 j ;
  s3senid_t *csp ;
  s3senid_t *sp ;

  {
  ss = 0;
  while (ss < d2p->n_comsseq) {
    if (*(comssid + ss)) {
      csp = *(d2p->comsseq + ss);
      i = 0;
      while (i < mdef->n_emit_state) {
        cs = (int32 )*(csp + i);
        sp = *(d2p->comstate + cs);
        j = 0;
        while ((int )*(sp + j) >= 0) {
          *(sen + *(sp + j)) = 1;
          j ++;
        }
        i ++;
      }
    }
    ss ++;
  }
  return;
}
}
void dict2pid_dump(FILE *fp , dict2pid_t *d2p , mdef_t *mdef , dict_t *dict ) 
{ 
  int32 w___0 ;
  int32 p ;
  int32 pronlen ;
  int32 i ;
  int32 j ;
  int32 b ;
  int32 l ;
  int32 r ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  fprintf(fp, "# INTERNAL (wd comssid ssid ssid ... ssid comssid)\n");
  w___0 = 0;
  while (w___0 < dict->n_word) {
    fprintf(fp, "%30s ", (dict->word + w___0)->word);
    pronlen = (dict->word + w___0)->pronlen;
    p = 0;
    while (p < pronlen) {
      fprintf(fp, " %5d", *(*(d2p->internal + w___0) + p));
      p ++;
    }
    fprintf(fp, "\n");
    w___0 ++;
  }
  fprintf(fp, "#\n");
  fprintf(fp, "# LDIPH_LC (b r l ssid)\n");
  b = 0;
  while (b < mdef->n_ciphone) {
    r = 0;
    while (r < mdef->n_ciphone) {
      l = 0;
      while (l < mdef->n_ciphone) {
        if (*(*(*(d2p->ldiph_lc + b) + r) + l) >= 0) {
          tmp = mdef_ciphone_str(mdef, (s3cipid_t )l);
          tmp___0 = mdef_ciphone_str(mdef, (s3cipid_t )r);
          tmp___1 = mdef_ciphone_str(mdef, (s3cipid_t )b);
          fprintf(fp, "%6s %6s %6s %5d\n", tmp___1, tmp___0, tmp, *(*(*(d2p->ldiph_lc + b) + r) + l));
        }
        l ++;
      }
      r ++;
    }
    b ++;
  }
  fprintf(fp, "#\n");
  fprintf(fp, "# SINGLE_LC (b l comssid)\n");
  b = 0;
  while (b < mdef->n_ciphone) {
    l = 0;
    while (l < mdef->n_ciphone) {
      if (*(*(d2p->single_lc + b) + l) >= 0) {
        tmp___2 = mdef_ciphone_str(mdef, (s3cipid_t )l);
        tmp___3 = mdef_ciphone_str(mdef, (s3cipid_t )b);
        fprintf(fp, "%6s %6s %5d\n", tmp___3, tmp___2, *(*(d2p->single_lc + b) + l));
      }
      l ++;
    }
    b ++;
  }
  fprintf(fp, "#\n");
  fprintf(fp, "# SSEQ %d (senid senid ...)\n", mdef->n_sseq);
  i = 0;
  while (i < mdef->n_sseq) {
    fprintf(fp, "%5d ", i);
    j = 0;
    while (j < mdef->n_emit_state) {
      fprintf(fp, " %5d", (int )*(*(mdef->sseq + i) + j));
      j ++;
    }
    fprintf(fp, "\n");
    i ++;
  }
  fprintf(fp, "#\n");
  fprintf(fp, "# COMSSEQ %d (comstate comstate ...)\n", d2p->n_comsseq);
  i = 0;
  while (i < d2p->n_comsseq) {
    fprintf(fp, "%5d ", i);
    j = 0;
    while (j < mdef->n_emit_state) {
      fprintf(fp, " %5d", (int )*(*(d2p->comsseq + i) + j));
      j ++;
    }
    fprintf(fp, "\n");
    i ++;
  }
  fprintf(fp, "#\n");
  fprintf(fp, "# COMSTATE %d (senid senid ...)\n", d2p->n_comstate);
  i = 0;
  while (i < d2p->n_comstate) {
    fprintf(fp, "%5d ", i);
    j = 0;
    while ((int )*(*(d2p->comstate + i) + j) >= 0) {
      fprintf(fp, " %5d", (int )*(*(d2p->comstate + i) + j));
      j ++;
    }
    fprintf(fp, "\n");
    i ++;
  }
  fprintf(fp, "#\n");
  fprintf(fp, "# END\n");
  fflush(fp);
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-9a0v4mXn.i","-O3")
extern void perror(char const   * ) ;
extern int putc(int  , FILE * ) ;
extern int ( /* format attribute */  vfprintf)(FILE * , char const   * , va_list  ) ;
extern  __attribute__((__noreturn__)) void abort(void) ;
extern int *__error(void) ;
void _E__abort_error(char const   *fmt  , ...) ;
void _E__sys_error(char const   *fmt  , ...) ;
void _E__pr_header(char const   *f , long ln , char const   *msg ) 
{ 


  {
  fflush(__stderrp);
  fprintf(__stderrp, "%s: \"%s\", line %ld: ", msg, f, ln);
  return;
}
}
void _E__pr_info_header(char const   *f , long ln , char const   *msg ) 
{ 


  {
  fprintf(__stdoutp, "%s: %s(%ld): ", msg, f, ln);
  return;
}
}
void _E__pr_warn(char const   *fmt  , ...) 
{ 
  va_list pvar ;

  {
  __builtin_va_start(pvar, fmt);
  vfprintf(__stderrp, fmt, pvar);
  __builtin_va_end(pvar);
  fflush(__stderrp);
  return;
}
}
void _E__pr_info(char const   *fmt  , ...) 
{ 
  va_list pvar ;

  {
  __builtin_va_start(pvar, fmt);
  vfprintf(__stdoutp, fmt, pvar);
  __builtin_va_end(pvar);
  return;
}
}
void _E__die_error(char const   *fmt  , ...) 
{ 
  va_list pvar ;

  {
  __builtin_va_start(pvar, fmt);
  vfprintf(__stderrp, fmt, pvar);
  fflush(__stderrp);
  __builtin_va_end(pvar);
  fflush(__stderrp);
  exit(-1);
}
}
void _E__fatal_sys_error(char const   *fmt  , ...) 
{ 
  va_list pvar ;
  int *tmp ;

  {
  __builtin_va_start(pvar, fmt);
  vfprintf(__stderrp, fmt, pvar);
  __builtin_va_end(pvar);
  putc(';', __stderrp);
  putc(' ', __stderrp);
  perror("");
  fflush(__stderrp);
  tmp = __error();
  exit(*tmp);
}
}
void _E__sys_error(char const   *fmt  , ...) 
{ 
  va_list pvar ;

  {
  __builtin_va_start(pvar, fmt);
  vfprintf(__stderrp, fmt, pvar);
  __builtin_va_end(pvar);
  putc(';', __stderrp);
  putc(' ', __stderrp);
  perror("");
  fflush(__stderrp);
  return;
}
}
void _E__abort_error(char const   *fmt  , ...) 
{ 
  va_list pvar ;

  {
  __builtin_va_start(pvar, fmt);
  vfprintf(__stderrp, fmt, pvar);
  __builtin_va_end(pvar);
  fflush(__stderrp);
  abort();
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Czpttrby.i","-O3")
extern int fseek(FILE * , long  , int  ) ;
extern int strncmp(char const   * , char const   * , size_t  ) ;
int32 fread_retry(void *pointer , int32 size , int32 num_items , FILE *stream ) ;
int32 stat_retry(char *file , struct stat *statbuf ) ;
int32 feat_readfile(feat_t *fcb , char *file , int32 sf , int32 ef , float32 ***feat ,
                    int32 maxfr ) ;
int32 feat_writefile(feat_t *fcb , char *file , float32 ***feat , int32 nfr ) ;
int32 feat_s2mfc_read(char *file , int32 sf , int32 ef , float32 **mfc , int32 maxfr ) ;
float32 **feat_vector_alloc(feat_t *fcb ) ;
feat_t *feat_init(char *type , char *cmn___0 , char *varnorm , char *agc ) ;
void feat_print(feat_t *fcb , float32 ***feat , int32 nfr , FILE *fp ) ;
int32 feat_s2mfc2feat(feat_t *fcb , char *file , char *dir , int32 sf , int32 ef ,
                      float32 ***feat , int32 maxfr ) ;
void feat_free(feat_t *f ) ;
int32 feat_readfile(feat_t *fcb , char *file , int32 sf , int32 ef , float32 ***feat ,
                    int32 maxfr ) 
{ 
  FILE *fp ;
  int32 i ;
  int32 l ;
  int32 k___0 ;
  int32 nfr ;
  int32 byteswap ;
  int32 chksum_present ;
  uint32 chksum ;
  char **argname ;
  char **argval___0 ;
  int32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int32 tmp___3 ;
  int32 tmp___4 ;
  int32 tmp___5 ;
  int32 tmp___6 ;

  {
  _E__pr_info_header("feat.c", 127L, "INFO");
  _E__pr_info("Reading feature file: \'%s\'[%d..%d]\n", file, sf, ef);
  if (ef <= sf) {
    _E__pr_header("feat.c", 131L, "ERROR");
    _E__pr_warn("%s: End frame (%d) <= Start frame (%d)\n", file, ef, sf);
    return (-1);
  }
  fp = fopen((char const   *)file, "rb");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    _E__pr_header("feat.c", 136L, "ERROR");
    _E__pr_warn("fopen(%s,rb) failed\n", file);
    return (-1);
  }
  tmp = bio_readhdr(fp, & argname, & argval___0, & byteswap);
  if (tmp < 0) {
    _E__pr_header("feat.c", 142L, "ERROR");
    _E__pr_warn("bio_readhdr(%s) failed\n", file);
    fclose(fp);
    return (-1);
  }
  chksum_present = 0;
  i = 0;
  while (*(argname + i)) {
    tmp___2 = strcmp((char const   *)*(argname + i), "version");
    if (tmp___2 == 0) {
      tmp___0 = strcmp((char const   *)*(argval___0 + i), "1.0");
      if (tmp___0 != 0) {
        _E__pr_header("feat.c", 152L, "WARNING");
        _E__pr_warn("%s: Version mismatch: %s, expecting %s\n", file, *(argval___0 + i),
                    "1.0");
      }
    } else {
      tmp___1 = strcmp((char const   *)*(argname + i), "chksum0");
      if (tmp___1 == 0) {
        chksum_present = 1;
      }
    }
    i ++;
  }
  bio_hdrarg_free(argname, argval___0);
  argval___0 = (char **)((void *)0);
  argname = argval___0;
  chksum = (uint32 )0;
  tmp___3 = bio_fread((void *)(& nfr), (int32 )sizeof(int32 ), 1, fp, byteswap, & chksum);
  if (tmp___3 != 1) {
    _E__pr_header("feat.c", 166L, "ERROR");
    _E__pr_warn("%s: fread(#frames) failed\n", file);
    fclose(fp);
    return (-1);
  }
  tmp___4 = bio_fread((void *)(& l), (int32 )sizeof(int32 ), 1, fp, byteswap, & chksum);
  if (tmp___4 != 1) {
    _E__pr_header("feat.c", 174L, "ERROR");
    _E__pr_warn("%s: Missing or bad #feature streams\n", file);
    fclose(fp);
    return (-1);
  } else
  if (l != fcb->n_stream) {
    _E__pr_header("feat.c", 174L, "ERROR");
    _E__pr_warn("%s: Missing or bad #feature streams\n", file);
    fclose(fp);
    return (-1);
  }
  k___0 = 0;
  i = 0;
  while (i < fcb->n_stream) {
    tmp___5 = bio_fread((void *)(& l), (int32 )sizeof(int32 ), 1, fp, byteswap, & chksum);
    if (tmp___5 != 1) {
      _E__pr_header("feat.c", 184L, "ERROR");
      _E__pr_warn("%s: Missing or bad feature stream size\n", file);
      fclose(fp);
      return (-1);
    } else
    if (l != *(fcb->stream_len + i)) {
      _E__pr_header("feat.c", 184L, "ERROR");
      _E__pr_warn("%s: Missing or bad feature stream size\n", file);
      fclose(fp);
      return (-1);
    }
    k___0 += l;
    i ++;
  }
  if (sf > 0) {
    if (sf >= nfr) {
      _E__pr_header("feat.c", 194L, "ERROR");
      _E__pr_warn("%s: Start frame (%d) beyond file size (%d)\n", file, sf, nfr);
      fclose(fp);
      return (-1);
    }
    nfr -= sf;
  }
  if ((ef - sf) + 1 < nfr) {
    nfr = (ef - sf) + 1;
  }
  if (nfr > maxfr) {
    _E__pr_header("feat.c", 205L, "ERROR");
    _E__pr_warn("%s: Feature buffer size(%d frames) < actual #frames(%d)\n", file,
                maxfr, nfr);
    fclose(fp);
    return (-1);
  }
  if (sf > 0) {
    fseek(fp, (long )((unsigned long )(sf * k___0) * sizeof(float32 )), 1);
  }
  tmp___6 = bio_fread((void *)*(*(feat + 0) + 0), (int32 )sizeof(float32 ), nfr * k___0,
                      fp, byteswap, & chksum);
  if (tmp___6 != nfr * k___0) {
    _E__pr_header("feat.c", 215L, "ERROR");
    _E__pr_warn("%s: fread(%dx%d) (feature data) failed\n", file, nfr, k___0);
    fclose(fp);
    return (-1);
  }
  fclose(fp);
  return (nfr);
}
}
int32 feat_writefile(feat_t *fcb , char *file , float32 ***feat , int32 nfr ) 
{ 
  FILE *fp ;
  int32 i ;
  int32 k___0 ;
  size_t tmp ;

  {
  _E__pr_info_header("feat.c", 231L, "INFO");
  _E__pr_info("Writing feature file: \'%s\'\n", file);
  fp = fopen((char const   *)file, "wb");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    _E__pr_header("feat.c", 235L, "ERROR");
    _E__pr_warn("fopen(%s,wb) failed\n", file);
    return (-1);
  }
  bio_writehdr_version(fp, (char *)"1.0");
  fwrite((void const   *)(& nfr), sizeof(int32 ), (size_t )1, fp);
  fwrite((void const   *)(& fcb->n_stream), sizeof(int32 ), (size_t )1, fp);
  k___0 = 0;
  i = 0;
  while (i < fcb->n_stream) {
    fwrite((void const   *)(fcb->stream_len + i), sizeof(int32 ), (size_t )1, fp);
    k___0 += *(fcb->stream_len + i);
    i ++;
  }
  tmp = fwrite((void const   *)*(*(feat + 0) + 0), sizeof(float32 ), (size_t )(nfr * k___0),
               fp);
  if ((int32 )tmp != nfr * k___0) {
    _E__pr_header("feat.c", 252L, "ERROR");
    _E__pr_warn("%s: fwrite(%dx%d feature data) failed\n", file, nfr, k___0);
    fclose(fp);
    return (-1);
  }
  fclose(fp);
  return (0);
}
}
int32 feat_s2mfc_read(char *file , int32 sf , int32 ef , float32 **mfc , int32 maxfr ) 
{ 
  FILE *fp ;
  int32 n_float32 ;
  struct stat statbuf ;
  int32 i ;
  int32 n ;
  int32 byterev ;
  int32 cepsize ;
  int32 tmp ;
  int32 tmp___0 ;
  int32 tmp___1 ;

  {
  if (ef < 0) {
    ef = 2147418112;
  }
  _E__pr_info_header("feat.c", 277L, "INFO");
  _E__pr_info("Reading mfc file: \'%s\'[%d..%d]\n", file, sf, ef);
  if (ef <= sf) {
    _E__pr_header("feat.c", 279L, "ERROR");
    _E__pr_warn("%s: End frame (%d) <= Start frame (%d)\n", file, ef, sf);
    return (-1);
  }
  cepsize = 13;
  tmp = stat_retry(file, & statbuf);
  if (tmp < 0) {
    _E__pr_header("feat.c", 287L, "ERROR");
    _E__pr_warn("stat_retry/fopen(%s) failed\n", file);
    return (-1);
  } else {
    fp = fopen((char const   *)file, "rb");
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      _E__pr_header("feat.c", 287L, "ERROR");
      _E__pr_warn("stat_retry/fopen(%s) failed\n", file);
      return (-1);
    }
  }
  tmp___0 = fread_retry((void *)(& n_float32), (int32 )sizeof(int32 ), 1, fp);
  if (tmp___0 != 1) {
    _E__pr_header("feat.c", 293L, "ERROR");
    _E__pr_warn("%s: fread(#floats) failed\n", file);
    fclose(fp);
    return (-1);
  }
  byterev = 0;
  if ((int32 )((unsigned long )n_float32 * sizeof(float32 ) + 4UL) != (int32 )statbuf.st_size) {
    n = n_float32;
    n = (int32 )((unsigned int )(((255 & (n >> 24)) | (65280 & (n >> 8))) | (16711680 & (n << 8))) | (4278190080U & (unsigned int )(n << 24)));
    if ((int32 )((unsigned long )n * sizeof(float32 ) + 4UL) != (int32 )statbuf.st_size) {
      _E__pr_header("feat.c", 305L, "ERROR");
      _E__pr_warn("%s: Header size field: %d(%08x); filesize: %d(%08x)\n", file, n_float32,
                  n_float32, statbuf.st_size, statbuf.st_size);
      fclose(fp);
      return (-1);
    }
    n_float32 = n;
    byterev = 1;
  }
  if (n_float32 <= 0) {
    _E__pr_header("feat.c", 315L, "ERROR");
    _E__pr_warn("%s: Header size field (#floats) = %d\n", file, n_float32);
    fclose(fp);
    return (-1);
  }
  n = n_float32 / cepsize;
  if (n * cepsize != n_float32) {
    _E__pr_header("feat.c", 323L, "ERROR");
    _E__pr_warn("Header size field: %d; not multiple of %d\n", n_float32, cepsize);
    fclose(fp);
    return (-1);
  }
  if (sf > 0) {
    if (sf >= n) {
      _E__pr_header("feat.c", 331L, "ERROR");
      _E__pr_warn("%s: Start frame (%d) beyond file size (%d)\n", file, sf, n);
      fclose(fp);
      return (-1);
    }
    n -= sf;
  }
  if ((ef - sf) + 1 < n) {
    n = (ef - sf) + 1;
  }
  if (n > maxfr) {
    _E__pr_header("feat.c", 342L, "ERROR");
    _E__pr_warn("%s: MFC buffer size(%d frames) < actual #frames(%d)\n", file, maxfr,
                n);
    fclose(fp);
    return (-1);
  }
  if (sf > 0) {
    fseek(fp, (long )((unsigned long )(sf * cepsize) * sizeof(float32 )), 1);
  }
  n_float32 = n * cepsize;
  tmp___1 = fread_retry((void *)*(mfc + 0), (int32 )sizeof(float32 ), n_float32, fp);
  if (tmp___1 != n_float32) {
    _E__pr_header("feat.c", 352L, "ERROR");
    _E__pr_warn("%s: fread(%dx%d) (MFC data) failed\n", file, n, cepsize);
    fclose(fp);
    return (-1);
  }
  if (byterev) {
    i = 0;
    while (i < n_float32) {
      *((int32 *)(*(mfc + 0) + i)) = (int32 )((unsigned int )(((255 & (*((int32 *)(*(mfc + 0) + i)) >> 24)) | (65280 & (*((int32 *)(*(mfc + 0) + i)) >> 8))) | (16711680 & (*((int32 *)(*(mfc + 0) + i)) << 8))) | (4278190080U & (unsigned int )(*((int32 *)(*(mfc + 0) + i)) << 24)));
      i ++;
    }
  }
  fclose(fp);
  return (n);
}
}
static int32 feat_stream_len_sum(feat_t *fcb ) 
{ 
  int32 i ;
  int32 k___0 ;

  {
  k___0 = 0;
  i = 0;
  while (i < fcb->n_stream) {
    k___0 += *(fcb->stream_len + i);
    i ++;
  }
  return (k___0);
}
}
float32 **feat_vector_alloc(feat_t *fcb ) 
{ 
  int32 i ;
  int32 k___0 ;
  float32 *data ;
  float32 **feat ;
  void *tmp ;
  void *tmp___0 ;

  {
  k___0 = feat_stream_len_sum(fcb);
  if (k___0 <= 0) {
    _E__pr_header("feat.c", 386L, "ERROR");
    _E__pr_warn("Sum(feature stream lengths) = %d\n", k___0);
    return ((float32 **)((void *)0));
  }
  tmp = __ckd_calloc__((size_t )fcb->n_stream, sizeof(float32 *), "feat.c", 391);
  feat = (float32 **)tmp;
  tmp___0 = __ckd_calloc__((size_t )k___0, sizeof(float32 ), "feat.c", 392);
  data = (float32 *)tmp___0;
  i = 0;
  while (i < fcb->n_stream) {
    *(feat + i) = data;
    data += *(fcb->stream_len + i);
    i ++;
  }
  return (feat);
}
}
float32 ***feat_array_alloc(feat_t *fcb , int32 nfr ) 
{ 
  int32 i ;
  int32 j ;
  int32 k___0 ;
  float32 *data ;
  float32 ***feat ;
  void **tmp ;
  void *tmp___0 ;

  {
  k___0 = feat_stream_len_sum(fcb);
  if (k___0 <= 0) {
    _E__pr_header("feat.c", 412L, "ERROR");
    _E__pr_warn("Sum(feature stream lengths) = %d\n", k___0);
    return ((float32 ***)((void *)0));
  }
  tmp = __ckd_calloc_2d__(nfr, fcb->n_stream, (int32 )sizeof(float32 *), "feat.c",
                          417);
  feat = (float32 ***)tmp;
  tmp___0 = __ckd_calloc__((size_t )(nfr * k___0), sizeof(float32 ), "feat.c", 418);
  data = (float32 *)tmp___0;
  i = 0;
  while (i < nfr) {
    j = 0;
    while (j < fcb->n_stream) {
      *(*(feat + i) + j) = data;
      data += *(fcb->stream_len + j);
      j ++;
    }
    i ++;
  }
  return (feat);
}
}
static void feat_s2_4x_cep2feat(feat_t *fcb , float32 **mfc , float32 **feat ) 
{ 
  float32 *f ;
  float32 *w___0 ;
  float32 *_w ;
  float32 *w1 ;
  float32 *w_1 ;
  float32 *_w1 ;
  float32 *_w_1 ;
  float32 d1 ;
  float32 d2 ;
  int32 i ;
  int32 j ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size((void *)*(feat + 0), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)*(feat + 0), 0);
    __builtin___memcpy_chk((void *)*(feat + 0), (void const   *)(*(mfc + 0) + 1),
                           (unsigned long )(fcb->cepsize - 1) * sizeof(float32 ),
                           tmp);
  } else {
    __inline_memcpy_chk((void *)*(feat + 0), (void const   *)(*(mfc + 0) + 1), (unsigned long )(fcb->cepsize - 1) * sizeof(float32 ));
  }
  w___0 = *(mfc + 2) + 1;
  _w = *(mfc + -2) + 1;
  f = *(feat + 1);
  i = 0;
  while (i < fcb->cepsize - 1) {
    *(f + i) = *(w___0 + i) - *(_w + i);
    i ++;
  }
  w___0 = *(mfc + 4) + 1;
  _w = *(mfc + -4) + 1;
  j = 0;
  while (j < fcb->cepsize - 1) {
    *(f + i) = *(w___0 + j) - *(_w + j);
    i ++;
    j ++;
  }
  w1 = *(mfc + 3) + 1;
  _w1 = *(mfc + -1) + 1;
  w_1 = *(mfc + 1) + 1;
  _w_1 = *(mfc + -3) + 1;
  f = *(feat + 3);
  i = 0;
  while (i < fcb->cepsize - 1) {
    d1 = *(w1 + i) - *(_w1 + i);
    d2 = *(w_1 + i) - *(_w_1 + i);
    *(f + i) = d1 - d2;
    i ++;
  }
  f = *(feat + 2);
  *(f + 0) = *(*(mfc + 0) + 0);
  *(f + 1) = *(*(mfc + 2) + 0) - *(*(mfc + -2) + 0);
  d1 = *(*(mfc + 3) + 0) - *(*(mfc + -1) + 0);
  d2 = *(*(mfc + 1) + 0) - *(*(mfc + -3) + 0);
  *(f + 2) = d1 - d2;
  return;
}
}
static void feat_s3_1x39_cep2feat(feat_t *fcb , float32 **mfc , float32 **feat ) 
{ 
  float32 *f ;
  float32 *w___0 ;
  float32 *_w ;
  float32 *w1 ;
  float32 *w_1 ;
  float32 *_w1 ;
  float32 *_w_1 ;
  float32 d1 ;
  float32 d2 ;
  int32 i ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size((void *)*(feat + 0), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)*(feat + 0), 0);
    __builtin___memcpy_chk((void *)*(feat + 0), (void const   *)(*(mfc + 0) + 1),
                           (unsigned long )(fcb->cepsize - 1) * sizeof(float32 ),
                           tmp);
  } else {
    __inline_memcpy_chk((void *)*(feat + 0), (void const   *)(*(mfc + 0) + 1), (unsigned long )(fcb->cepsize - 1) * sizeof(float32 ));
  }
  f = (*(feat + 0) + fcb->cepsize) - 1;
  w___0 = *(mfc + 2) + 1;
  _w = *(mfc + -2) + 1;
  i = 0;
  while (i < fcb->cepsize - 1) {
    *(f + i) = *(w___0 + i) - *(_w + i);
    i ++;
  }
  f += fcb->cepsize - 1;
  *(f + 0) = *(*(mfc + 0) + 0);
  *(f + 1) = *(*(mfc + 2) + 0) - *(*(mfc + -2) + 0);
  d1 = *(*(mfc + 3) + 0) - *(*(mfc + -1) + 0);
  d2 = *(*(mfc + 1) + 0) - *(*(mfc + -3) + 0);
  *(f + 2) = d1 - d2;
  f += 3;
  w1 = *(mfc + 3) + 1;
  _w1 = *(mfc + -1) + 1;
  w_1 = *(mfc + 1) + 1;
  _w_1 = *(mfc + -3) + 1;
  i = 0;
  while (i < fcb->cepsize - 1) {
    d1 = *(w1 + i) - *(_w1 + i);
    d2 = *(w_1 + i) - *(_w_1 + i);
    *(f + i) = d1 - d2;
    i ++;
  }
  return;
}
}
static void feat_s3_cep(feat_t *fcb , float32 **mfc , float32 **feat ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size((void *)*(feat + 0), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)*(feat + 0), 0);
    __builtin___memcpy_chk((void *)*(feat + 0), (void const   *)*(mfc + 0), (unsigned long )fcb->cepsize_used * sizeof(float32 ),
                           tmp);
  } else {
    __inline_memcpy_chk((void *)*(feat + 0), (void const   *)*(mfc + 0), (unsigned long )fcb->cepsize_used * sizeof(float32 ));
  }
  return;
}
}
static void feat_s3_cep_dcep(feat_t *fcb , float32 **mfc , float32 **feat ) 
{ 
  float32 *f ;
  float32 *w___0 ;
  float32 *_w ;
  int32 i ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size((void *)*(feat + 0), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)*(feat + 0), 0);
    __builtin___memcpy_chk((void *)*(feat + 0), (void const   *)*(mfc + 0), (unsigned long )fcb->cepsize_used * sizeof(float32 ),
                           tmp);
  } else {
    __inline_memcpy_chk((void *)*(feat + 0), (void const   *)*(mfc + 0), (unsigned long )fcb->cepsize_used * sizeof(float32 ));
  }
  f = *(feat + 0) + fcb->cepsize_used;
  w___0 = *(mfc + 2);
  _w = *(mfc + -2);
  i = 0;
  while (i < fcb->cepsize_used) {
    *(f + i) = *(w___0 + i) - *(_w + i);
    i ++;
  }
  return;
}
}
void feat_1s_c_d_dd_cep2feat(feat_t *fcb , float32 **mfc , float32 **feat ) 
{ 
  float32 *f ;
  float32 *w___0 ;
  float32 *_w ;
  float32 *w1 ;
  float32 *w_1 ;
  float32 *_w1 ;
  float32 *_w_1 ;
  float32 d1 ;
  float32 d2 ;
  int32 i ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size((void *)*(feat + 0), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)*(feat + 0), 0);
    __builtin___memcpy_chk((void *)*(feat + 0), (void const   *)*(mfc + 0), (unsigned long )fcb->cepsize * sizeof(float32 ),
                           tmp);
  } else {
    __inline_memcpy_chk((void *)*(feat + 0), (void const   *)*(mfc + 0), (unsigned long )fcb->cepsize * sizeof(float32 ));
  }
  f = *(feat + 0) + fcb->cepsize;
  w___0 = *(mfc + 2);
  _w = *(mfc + -2);
  i = 0;
  while (i < fcb->cepsize) {
    *(f + i) = *(w___0 + i) - *(_w + i);
    i ++;
  }
  f += fcb->cepsize;
  w1 = *(mfc + 3);
  _w1 = *(mfc + -1);
  w_1 = *(mfc + 1);
  _w_1 = *(mfc + -3);
  i = 0;
  while (i < fcb->cepsize) {
    d1 = *(w1 + i) - *(_w1 + i);
    d2 = *(w_1 + i) - *(_w_1 + i);
    *(f + i) = d1 - d2;
    i ++;
  }
  return;
}
}
feat_t *feat_init(char *type , char *cmn___0 , char *varnorm , char *agc ) 
{ 
  feat_t *fcb ;
  int32 i ;
  int32 l ;
  int32 k___0 ;
  char wd[16384] ;
  char *strp ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  _E__pr_info_header("feat.c", 642L, "INFO");
  _E__pr_info("Initializing feature stream to type: \'%s\', CMN=\'%s\', VARNORM=\'%s\', AGC=\'%s\'\n",
              type, cmn___0, varnorm, agc);
  tmp = __ckd_calloc__((size_t )1, sizeof(feat_t ), "feat.c", 645);
  fcb = (feat_t *)tmp;
  tmp___0 = __ckd_salloc__((char const   *)type, "feat.c", 647);
  fcb->name = tmp___0;
  tmp___16 = strcmp((char const   *)type, "s2_4x");
  if (tmp___16 == 0) {
    fcb->cepsize = 13;
    fcb->cepsize_used = 13;
    fcb->n_stream = 4;
    tmp___1 = __ckd_calloc__((size_t )4, sizeof(int32 ), "feat.c", 653);
    fcb->stream_len = (int32 *)tmp___1;
    *(fcb->stream_len + 0) = 12;
    *(fcb->stream_len + 1) = 24;
    *(fcb->stream_len + 2) = 3;
    *(fcb->stream_len + 3) = 12;
    fcb->window_size = 4;
    fcb->compute_feat = & feat_s2_4x_cep2feat;
  } else {
    tmp___15 = strcmp((char const   *)type, "s3_1x39");
    if (tmp___15 == 0) {
      fcb->cepsize = 13;
      fcb->cepsize_used = 13;
      fcb->n_stream = 1;
      tmp___2 = __ckd_calloc__((size_t )1, sizeof(int32 ), "feat.c", 665);
      fcb->stream_len = (int32 *)tmp___2;
      *(fcb->stream_len + 0) = 39;
      fcb->window_size = 3;
      fcb->compute_feat = & feat_s3_1x39_cep2feat;
    } else {
      tmp___14 = strcmp((char const   *)type, "1s_c_d_dd");
      if (tmp___14 == 0) {
        fcb->cepsize = 13;
        fcb->cepsize_used = 13;
        fcb->n_stream = 1;
        tmp___3 = __ckd_calloc__((size_t )1, sizeof(int32 ), "feat.c", 673);
        fcb->stream_len = (int32 *)tmp___3;
        *(fcb->stream_len + 0) = 39;
        fcb->window_size = 3;
        fcb->compute_feat = & feat_1s_c_d_dd_cep2feat;
      } else {
        tmp___13 = strncmp((char const   *)type, "cep_dcep", (size_t )8);
        if (tmp___13 == 0) {
          fcb->cepsize = 13;
          if ((int )*(type + 8) == 44) {
            tmp___4 = sscanf((char const   *)(type + 9), "%d%n", & fcb->cepsize_used,
                             & l);
            if (tmp___4 != 1) {
              _E__pr_header("feat.c", 686L, "FATAL_ERROR");
              _E__die_error("Bad feature type argument: \'%s\'\n", type);
            } else
            if ((int )*(type + (l + 9)) != 0) {
              _E__pr_header("feat.c", 686L, "FATAL_ERROR");
              _E__die_error("Bad feature type argument: \'%s\'\n", type);
            } else
            if (fcb->cepsize_used <= 0) {
              _E__pr_header("feat.c", 686L, "FATAL_ERROR");
              _E__die_error("Bad feature type argument: \'%s\'\n", type);
            } else
            if (fcb->cepsize_used > fcb->cepsize) {
              _E__pr_header("feat.c", 686L, "FATAL_ERROR");
              _E__die_error("Bad feature type argument: \'%s\'\n", type);
            }
          } else {
            fcb->cepsize_used = 13;
          }
          fcb->n_stream = 1;
          tmp___5 = __ckd_calloc__((size_t )1, sizeof(int32 ), "feat.c", 690);
          fcb->stream_len = (int32 *)tmp___5;
          *(fcb->stream_len + 0) = fcb->cepsize_used * 2;
          fcb->window_size = 2;
          fcb->compute_feat = & feat_s3_cep_dcep;
        } else {
          tmp___12 = strncmp((char const   *)type, "cep", (size_t )3);
          if (tmp___12 == 0) {
            fcb->cepsize = 13;
            if ((int )*(type + 3) == 44) {
              tmp___6 = sscanf((char const   *)(type + 4), "%d%n", & fcb->cepsize_used,
                               & l);
              if (tmp___6 != 1) {
                _E__pr_header("feat.c", 703L, "FATAL_ERROR");
                _E__die_error("Bad feature type argument: \'%s\'\n", type);
              } else
              if ((int )*(type + (l + 4)) != 0) {
                _E__pr_header("feat.c", 703L, "FATAL_ERROR");
                _E__die_error("Bad feature type argument: \'%s\'\n", type);
              } else
              if (fcb->cepsize_used <= 0) {
                _E__pr_header("feat.c", 703L, "FATAL_ERROR");
                _E__die_error("Bad feature type argument: \'%s\'\n", type);
              } else
              if (fcb->cepsize_used > fcb->cepsize) {
                _E__pr_header("feat.c", 703L, "FATAL_ERROR");
                _E__die_error("Bad feature type argument: \'%s\'\n", type);
              }
            } else {
              fcb->cepsize_used = 13;
            }
            fcb->n_stream = 1;
            tmp___7 = __ckd_calloc__((size_t )1, sizeof(int32 ), "feat.c", 707);
            fcb->stream_len = (int32 *)tmp___7;
            *(fcb->stream_len + 0) = fcb->cepsize_used;
            fcb->window_size = 0;
            fcb->compute_feat = & feat_s3_cep;
          } else {
            tmp___8 = strlen((char const   *)type);
            l = (int32 )tmp___8;
            k___0 = 0;
            i = 1;
            while (i < l - 1) {
              if ((int )*(type + i) == 44) {
                *(type + i) = (char )' ';
                k___0 ++;
              }
              i ++;
            }
            k___0 ++;
            fcb->n_stream = k___0;
            tmp___9 = __ckd_calloc__((size_t )k___0, sizeof(int32 ), "feat.c", 725);
            fcb->stream_len = (int32 *)tmp___9;
            strp = type;
            i = 0;
            while (1) {
              tmp___11 = sscanf((char const   *)strp, "%s%n", wd, & l);
              if (! (tmp___11 == 1)) {
                break;
              }
              strp += l;
              if (i >= fcb->n_stream) {
                _E__pr_header("feat.c", 734L, "FATAL_ERROR");
                _E__die_error("Bad feature type argument\n");
              } else {
                tmp___10 = sscanf((char const   *)(wd), "%d", fcb->stream_len + i);
                if (tmp___10 != 1) {
                  _E__pr_header("feat.c", 734L, "FATAL_ERROR");
                  _E__die_error("Bad feature type argument\n");
                } else
                if (*(fcb->stream_len + i) <= 0) {
                  _E__pr_header("feat.c", 734L, "FATAL_ERROR");
                  _E__die_error("Bad feature type argument\n");
                }
              }
              i ++;
            }
            if (i != fcb->n_stream) {
              _E__pr_header("feat.c", 738L, "FATAL_ERROR");
              _E__die_error("Bad feature type argument\n");
            }
            fcb->cepsize = -1;
            fcb->cepsize_used = -1;
            fcb->window_size = 0;
            fcb->compute_feat = (void (*)(struct feat_s *fcb , float32 **input , float32 **feat ))((void *)0);
          }
        }
      }
    }
  }
  tmp___18 = strcmp((char const   *)cmn___0, "current");
  if (tmp___18 == 0) {
    fcb->cmn = 1;
  } else {
    tmp___17 = strcmp((char const   *)cmn___0, "none");
    if (tmp___17 == 0) {
      fcb->cmn = 0;
    } else {
      _E__pr_header("feat.c", 752L, "FATAL_ERROR");
      _E__die_error("Unsupported CMN type \'%s\'\n", cmn___0);
    }
  }
  tmp___20 = strcmp((char const   *)varnorm, "yes");
  if (tmp___20 == 0) {
    fcb->varnorm = 1;
  } else {
    tmp___19 = strcmp((char const   *)varnorm, "no");
    if (tmp___19 == 0) {
      fcb->varnorm = 0;
    } else {
      _E__pr_header("feat.c", 759L, "FATAL_ERROR");
      _E__die_error("Unsupported VARNORM type \'%s\'\n", varnorm);
    }
  }
  tmp___22 = strcmp((char const   *)agc, "max");
  if (tmp___22 == 0) {
    fcb->agc = 1;
  } else {
    tmp___21 = strcmp((char const   *)agc, "none");
    if (tmp___21 == 0) {
      fcb->agc = 0;
    } else {
      _E__pr_header("feat.c", 766L, "FATAL_ERROR");
      _E__die_error("Unsupported AGC type \'%s\'\n", agc);
    }
  }
  return (fcb);
}
}
void feat_print(feat_t *fcb , float32 ***feat , int32 nfr , FILE *fp ) 
{ 
  int32 i ;
  int32 j ;
  int32 k___0 ;

  {
  i = 0;
  while (i < nfr) {
    fprintf(fp, "%8d:", i);
    j = 0;
    while (j < fcb->n_stream) {
      fprintf(fp, "\t%2d:", j);
      k___0 = 0;
      while (k___0 < *(fcb->stream_len + j)) {
        fprintf(fp, " %8.4f", (double )*(*(*(feat + i) + j) + k___0));
        k___0 ++;
      }
      fprintf(fp, "\n");
      j ++;
    }
    i ++;
  }
  fflush(fp);
  return;
}
}
int32 feat_s2mfc2feat(feat_t *fcb , char *file , char *dir , int32 sf , int32 ef ,
                      float32 ***feat , int32 maxfr ) 
{ 
  char path[16384] ;
  int32 win ;
  int32 nfr ;
  int32 i ;
  int32 k___0 ;
  float32 **mfc ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  void **tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;

  {
  if (fcb->cepsize <= 0) {
    _E__pr_header("feat.c", 802L, "ERROR");
    _E__pr_warn("Bad cepsize: %d\n", fcb->cepsize);
    return (-1);
  }
  tmp = strlen((char const   *)file);
  k___0 = (int32 )tmp;
  if (k___0 > 4) {
    tmp___5 = strcmp((char const   *)((file + k___0) - 4), ".mfc");
    if (tmp___5 == 0) {
      if (dir) {
        if ((int )*(file + 0) != 47) {
          tmp___0 = __builtin_object_size((void *)(path), 1);
          __builtin___sprintf_chk(path, 0, tmp___0, "%s/%s", dir, file);
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        tmp___2 = __builtin_object_size((void *)(path), 0);
        if (tmp___2 != 0xffffffffffffffffUL) {
          tmp___1 = __builtin_object_size((void *)(path), 1);
          __builtin___strcpy_chk(path, (char const   *)file, tmp___1);
        } else {
          __inline_strcpy_chk(path, (char const   *)file);
        }
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (dir) {
    if ((int )*(file + 0) != 47) {
      tmp___3 = __builtin_object_size((void *)(path), 1);
      __builtin___sprintf_chk(path, 0, tmp___3, "%s/%s.mfc", dir, file);
    } else {
      tmp___4 = __builtin_object_size((void *)(path), 1);
      __builtin___sprintf_chk(path, 0, tmp___4, "%s.mfc", file);
    }
  } else {
    tmp___4 = __builtin_object_size((void *)(path), 1);
    __builtin___sprintf_chk(path, 0, tmp___4, "%s.mfc", file);
  }
  win = fcb->window_size;
  if (ef < 0) {
    ef = 2147418112 - win;
  }
  sf -= win;
  ef += win;
  tmp___6 = __ckd_calloc_2d__(15000, fcb->cepsize, (int32 )sizeof(float32 ), "feat.c",
                              829);
  mfc = (float32 **)tmp___6;
  if (sf < 0) {
    nfr = feat_s2mfc_read(path, 0, ef, mfc - sf, (15000 + sf) - win);
  } else {
    nfr = feat_s2mfc_read(path, sf, ef, mfc, 15000 - win);
  }
  if (nfr < 0) {
    ckd_free_2d((void **)mfc);
    return (-1);
  }
  if (nfr < 2 * win + 1) {
    _E__pr_header("feat.c", 853L, "ERROR");
    _E__pr_warn("%s: MFC file/segment too short to compute features: %d frames\n",
                file, nfr);
    ckd_free_2d((void **)mfc);
    return (-1);
  }
  if (sf < 0) {
    i = 0;
    while (i < - sf) {
      tmp___8 = __builtin_object_size((void *)*(mfc + i), 0);
      if (tmp___8 != 0xffffffffffffffffUL) {
        tmp___7 = __builtin_object_size((void *)*(mfc + i), 0);
        __builtin___memcpy_chk((void *)*(mfc + i), (void const   *)*(mfc + ((i - sf) + 1)),
                               (unsigned long )fcb->cepsize * sizeof(float32 ), tmp___7);
      } else {
        __inline_memcpy_chk((void *)*(mfc + i), (void const   *)*(mfc + ((i - sf) + 1)),
                            (unsigned long )fcb->cepsize * sizeof(float32 ));
      }
      i ++;
    }
    nfr -= sf;
  }
  k___0 = (ef - sf) + 1;
  if (nfr < k___0) {
    k___0 -= nfr;
    if (k___0 > win) {
      k___0 = win;
    }
    i = 0;
    while (i < k___0) {
      tmp___10 = __builtin_object_size((void *)*(mfc + (nfr + i)), 0);
      if (tmp___10 != 0xffffffffffffffffUL) {
        tmp___9 = __builtin_object_size((void *)*(mfc + (nfr + i)), 0);
        __builtin___memcpy_chk((void *)*(mfc + (nfr + i)), (void const   *)*(mfc + (((nfr + i) - 1) - k___0)),
                               (unsigned long )fcb->cepsize * sizeof(float32 ), tmp___9);
      } else {
        __inline_memcpy_chk((void *)*(mfc + (nfr + i)), (void const   *)*(mfc + (((nfr + i) - 1) - k___0)),
                            (unsigned long )fcb->cepsize * sizeof(float32 ));
      }
      i ++;
    }
    nfr += k___0;
  }
  if (nfr - win * 2 > maxfr) {
    _E__pr_header("feat.c", 879L, "ERROR");
    _E__pr_warn("%s: Feature buffer size(%d frames) < required(%d)\n", maxfr, nfr - win * 2);
    ckd_free_2d((void **)mfc);
    return (-1);
  }
  if (fcb->cmn) {
    _E__pr_info_header("feat.c", 885L, "INFO");
    _E__pr_info("CMN\n");
    cmn(mfc, fcb->varnorm, nfr, fcb->cepsize);
  }
  if (fcb->agc) {
    _E__pr_info_header("feat.c", 889L, "INFO");
    _E__pr_info("AGC\n");
    agc_max(mfc, nfr);
  }
  i = win;
  while (i < nfr - win) {
    (*(fcb->compute_feat))(fcb, mfc + i, *(feat + (i - win)));
    i ++;
  }
  ckd_free_2d((void **)mfc);
  return (nfr - win * 2);
}
}
static float32 **cepbuf  =    (float32 **)((void *)0);
static float32 **tmpcepbuf  =    (float32 **)((void *)0);
static int32 bufpos  ;
static int32 curpos  ;
int32 feat_s2mfc2feat_block(feat_t *fcb , float32 **uttcep , int32 nfr , int32 beginutt ,
                            int32 endutt , float32 ***ofeat ) 
{ 
  int32 win ;
  int32 cepsize ;
  int32 i ;
  int32 j ;
  int32 nfeatvec ;
  int32 residualvecs ;
  int32 tmppos ;
  void **tmp ;
  void **tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int32 tmp___5 ;
  int32 tmp___9 ;
  int16 tpos ;
  int32 tmp___13 ;
  unsigned long tmp___17 ;
  unsigned long tmp___18 ;

  {
  win = fcb->window_size;
  if (fcb->cepsize <= 0) {
    _E__pr_header("feat.c", 964L, "FATAL_ERROR");
    _E__die_error("Bad cepsize: %d\n", fcb->cepsize);
  }
  cepsize = fcb->cepsize;
  if ((unsigned long )cepbuf == (unsigned long )((void *)0)) {
    tmp = __ckd_calloc_2d__(256, cepsize, (int32 )sizeof(float32 ), "feat.c", 968);
    cepbuf = (float32 **)tmp;
    if (! cepbuf) {
      _E__pr_header("feat.c", 969L, "FATAL_ERROR");
      _E__die_error("Unable to allocate cepbuf ckd_calloc_2d(%ld,%d,%d)\n", 256, cepsize,
                    sizeof(float32 ));
    }
    beginutt = 1;
    _E__pr_info_header("feat.c", 971L, "INFO");
    _E__pr_info("Feature buffers initialized to %d vectors\n", 256);
  }
  if ((unsigned long )tmpcepbuf == (unsigned long )((void *)0)) {
    tmp___0 = __ckd_calloc_2d__(2 * win + 1, cepsize, (int32 )sizeof(float32 ), "feat.c",
                                975);
    tmpcepbuf = (float32 **)tmp___0;
    if (! tmpcepbuf) {
      _E__pr_header("feat.c", 976L, "FATAL_ERROR");
      _E__die_error("Unable to allocate tmpcepbuf ckd_calloc_2d(%ld,%d,%d)\n", 2 * win + 1,
                    cepsize, sizeof(float32 ));
    }
  }
  if (fcb->cmn) {
    cmn_prior(uttcep, fcb->varnorm, nfr, fcb->cepsize, endutt);
  }
  residualvecs = 0;
  if (beginutt) {
    i = 0;
    while (i < win) {
      if (nfr >= win + 1) {
        tmp___2 = __builtin_object_size((void *)*(cepbuf + i), 0);
        if (tmp___2 != 0xffffffffffffffffUL) {
          tmp___1 = __builtin_object_size((void *)*(cepbuf + i), 0);
          __builtin___memcpy_chk((void *)*(cepbuf + i), (void const   *)*(uttcep + (i + 1)),
                                 (unsigned long )cepsize * sizeof(float32 ), tmp___1);
        } else {
          __inline_memcpy_chk((void *)*(cepbuf + i), (void const   *)*(uttcep + (i + 1)),
                              (unsigned long )cepsize * sizeof(float32 ));
        }
      } else {
        tmp___4 = __builtin_object_size((void *)*(cepbuf + i), 0);
        if (tmp___4 != 0xffffffffffffffffUL) {
          tmp___3 = __builtin_object_size((void *)*(cepbuf + i), 0);
          __builtin___memcpy_chk((void *)*(cepbuf + i), (void const   *)*(uttcep + 0),
                                 (unsigned long )cepsize * sizeof(float32 ), tmp___3);
        } else {
          __inline_memcpy_chk((void *)*(cepbuf + i), (void const   *)*(uttcep + 0),
                              (unsigned long )cepsize * sizeof(float32 ));
        }
      }
      i ++;
    }
    bufpos = win;
    bufpos %= 256;
    curpos = bufpos;
    residualvecs -= win;
  }
  i = 0;
  while (i < nfr) {
    tmp___5 = bufpos;
    bufpos ++;
    __inline_memcpy_chk((void *)*(cepbuf + tmp___5), (void const   *)*(uttcep + i),
                        (unsigned long )cepsize * sizeof(float32 ));
    bufpos %= 256;
    i ++;
  }
  if (endutt) {
    if (nfr > 0) {
      i = 0;
      while (i < win) {
        tmp___9 = bufpos;
        bufpos ++;
        __inline_memcpy_chk((void *)*(cepbuf + tmp___9), (void const   *)*(uttcep + (nfr - 1)),
                            (unsigned long )cepsize * sizeof(float32 ));
        bufpos %= 256;
        i ++;
      }
    } else {
      tpos = (int16 )(bufpos - 1);
      tpos = (int16 )((int )tpos % 256);
      i = 0;
      while (i < win) {
        tmp___13 = bufpos;
        bufpos ++;
        __inline_memcpy_chk((void *)*(cepbuf + tmp___13), (void const   *)*(cepbuf + tpos),
                            (unsigned long )cepsize * sizeof(float32 ));
        bufpos %= 256;
        i ++;
      }
    }
    residualvecs += win;
  }
  nfeatvec = 0;
  nfr += residualvecs;
  i = 0;
  while (i < nfr) {
    if (curpos < win) {
      goto _L;
    } else
    if (curpos > (256 - win) - 1) {
      _L: /* CIL Label */ 
      j = - win;
      while (j <= win) {
        tmppos = ((j + curpos) + 256) % 256;
        tmp___18 = __builtin_object_size((void *)*(tmpcepbuf + (win + j)), 0);
        if (tmp___18 != 0xffffffffffffffffUL) {
          tmp___17 = __builtin_object_size((void *)*(tmpcepbuf + (win + j)), 0);
          __builtin___memcpy_chk((void *)*(tmpcepbuf + (win + j)), (void const   *)*(cepbuf + tmppos),
                                 (unsigned long )cepsize * sizeof(float32 ), tmp___17);
        } else {
          __inline_memcpy_chk((void *)*(tmpcepbuf + (win + j)), (void const   *)*(cepbuf + tmppos),
                              (unsigned long )cepsize * sizeof(float32 ));
        }
        j ++;
      }
      (*(fcb->compute_feat))(fcb, tmpcepbuf + win, *(ofeat + i));
    } else {
      (*(fcb->compute_feat))(fcb, cepbuf + curpos, *(ofeat + i));
    }
    curpos ++;
    curpos %= 256;
    i ++;
    nfeatvec ++;
  }
  return (nfeatvec);
}
}
void feat_free(feat_t *f ) 
{ 


  {
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-2HQEnP6e.i","-O3")
fillpen_t *fillpen_init(dict_t *dict , char *file , float64 silprob , float64 fillprob ,
                        float64 lw , float64 wip ) ;
int32 fillpen(fillpen_t *f , s3wid_t w___0 ) ;
void fillpen_free(fillpen_t *f ) ;
fillpen_t *fillpen_init(dict_t *dict , char *file , float64 silprob , float64 fillprob ,
                        float64 lw , float64 wip ) 
{ 
  s3wid_t w___0 ;
  s3wid_t bw ;
  float64 prob ;
  FILE *fp ;
  char line[1024] ;
  char wd[1024] ;
  int32 k___0 ;
  fillpen_t *_fillpen ;
  void *tmp ;
  void *tmp___0 ;
  int32 tmp___1 ;
  int32 tmp___2 ;
  int32 tmp___3 ;
  int32 tmp___4 ;
  int32 tmp___5 ;
  int32 tmp___6 ;
  char *tmp___7 ;

  {
  tmp = __ckd_calloc__((size_t )1, sizeof(fillpen_t ), "fillpen.c", 78);
  _fillpen = (fillpen_t *)tmp;
  _fillpen->dict = dict;
  _fillpen->lw = lw;
  _fillpen->wip = wip;
  if (dict->filler_end >= dict->filler_start) {
    tmp___0 = __ckd_calloc__((size_t )((dict->filler_end - dict->filler_start) + 1),
                             sizeof(int32 ), "fillpen.c", 85);
    _fillpen->prob = (int32 *)tmp___0;
  } else {
    _fillpen->prob = (int32 *)((void *)0);
  }
  prob = fillprob;
  w___0 = dict->filler_start;
  while (w___0 <= dict->filler_end) {
    tmp___1 = logs3(prob);
    tmp___2 = logs3(wip);
    *(_fillpen->prob + (w___0 - dict->filler_start)) = (int32 )((float64 )tmp___1 * lw + (float64 )tmp___2);
    w___0 ++;
  }
  w___0 = dict_wordid(dict, (char *)"<sil>");
  if (w___0 < 0) {
    _E__pr_header("fillpen.c", 100L, "FATAL_ERROR");
    _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
  } else
  if (w___0 < dict->filler_start) {
    _E__pr_header("fillpen.c", 100L, "FATAL_ERROR");
    _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
  } else
  if (w___0 > dict->filler_end) {
    _E__pr_header("fillpen.c", 100L, "FATAL_ERROR");
    _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
  }
  prob = silprob;
  tmp___3 = logs3(prob);
  tmp___4 = logs3(wip);
  *(_fillpen->prob + (w___0 - dict->filler_start)) = (int32 )((float64 )tmp___3 * lw + (float64 )tmp___4);
  if (! file) {
    return (_fillpen);
  }
  _E__pr_info_header("fillpen.c", 111L, "INFO");
  _E__pr_info("Reading filler penalty file: %s\n", file);
  fp = fopen((char const   *)file, "r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    _E__pr_header("fillpen.c", 113L, "FATAL_ERROR");
    _E__die_error("fopen(%s,r) failed\n", file);
  }
  while (1) {
    tmp___7 = fgets(line, (int )sizeof(line), fp);
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
      break;
    }
    if ((int )line[0] == 35) {
      continue;
    }
    k___0 = sscanf((char const   *)(line), "%s %lf", wd, & prob);
    if (k___0 != 0) {
      if (k___0 != 2) {
        _E__pr_header("fillpen.c", 120L, "FATAL_ERROR");
        _E__die_error("Bad input line: %s\n", line);
      }
    }
    w___0 = dict_wordid(dict, wd);
    if (w___0 < 0) {
      _E__pr_header("fillpen.c", 123L, "FATAL_ERROR");
      _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
    } else
    if (w___0 < dict->filler_start) {
      _E__pr_header("fillpen.c", 123L, "FATAL_ERROR");
      _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
    } else
    if (w___0 > dict->filler_end) {
      _E__pr_header("fillpen.c", 123L, "FATAL_ERROR");
      _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
    }
    tmp___5 = logs3(prob);
    tmp___6 = logs3(wip);
    *(_fillpen->prob + (w___0 - dict->filler_start)) = (int32 )((float64 )tmp___5 * lw + (float64 )tmp___6);
  }
  fclose(fp);
  w___0 = dict->filler_start;
  while (w___0 <= dict->filler_end) {
    bw = (dict->word + w___0)->basewid;
    if (bw != w___0) {
      *(_fillpen->prob + (w___0 - dict->filler_start)) = *(_fillpen->prob + (bw - dict->filler_start));
    }
    w___0 ++;
  }
  return (_fillpen);
}
}
int32 fillpen(fillpen_t *f , s3wid_t w___0 ) 
{ 


  {
  return (*(f->prob + (w___0 - (f->dict)->filler_start)));
}
}
void fillpen_free(fillpen_t *f ) 
{ 


  {
  if (f) {
    if (f->prob) {
      ckd_free((void *)f->prob);
    }
    ckd_free((void *)f);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Lvs4EOFM.i","-O3")
glist_t glist_add_ptr(glist_t g , void *ptr ) ;
glist_t glist_add_uint32(glist_t g , uint32 val ) ;
glist_t glist_add_float32(glist_t g , float32 val ) ;
glist_t glist_add_float64(glist_t g , float64 val ) ;
int32 glist_chkdup_ptr(glist_t g , void *val ) ;
int32 glist_chkdup_uint32(glist_t g , uint32 val ) ;
int32 glist_chkdup_float32(glist_t g , float32 val ) ;
int32 glist_chkdup_float64(glist_t g , float64 val ) ;
glist_t glist_reverse(glist_t g ) ;
void glist_apply_ptr(glist_t g , void (*func)(void * ) ) ;
void glist_apply_int32(glist_t g , void (*func)(int32  ) ) ;
void glist_apply_uint32(glist_t g , void (*func)(uint32  ) ) ;
void glist_apply_float32(glist_t g , void (*func)(float32  ) ) ;
void glist_apply_float64(glist_t g , void (*func)(float64  ) ) ;
void glist_myfree(glist_t g , int32 datasize ) ;
gnode_t *glist_tail(glist_t g ) ;
glist_t glist_add_ptr(glist_t g , void *ptr ) 
{ 
  gnode_t *gn ;
  char *tmp ;

  {
  tmp = __mymalloc__((int32 )sizeof(gnode_t ), (char *)"glist.c", 69);
  gn = (gnode_t *)tmp;
  gn->data.ptr = ptr;
  gn->next = g;
  return (gn);
}
}
glist_t glist_add_int32(glist_t g , int32 val ) 
{ 
  gnode_t *gn ;
  char *tmp ;

  {
  tmp = __mymalloc__((int32 )sizeof(gnode_t ), (char *)"glist.c", 80);
  gn = (gnode_t *)tmp;
  gn->data.int32 = val;
  gn->next = g;
  return (gn);
}
}
glist_t glist_add_uint32(glist_t g , uint32 val ) 
{ 
  gnode_t *gn ;
  char *tmp ;

  {
  tmp = __mymalloc__((int32 )sizeof(gnode_t ), (char *)"glist.c", 91);
  gn = (gnode_t *)tmp;
  gn->data.uint32 = val;
  gn->next = g;
  return (gn);
}
}
glist_t glist_add_float32(glist_t g , float32 val ) 
{ 
  gnode_t *gn ;
  char *tmp ;

  {
  tmp = __mymalloc__((int32 )sizeof(gnode_t ), (char *)"glist.c", 102);
  gn = (gnode_t *)tmp;
  gn->data.float32 = val;
  gn->next = g;
  return (gn);
}
}
glist_t glist_add_float64(glist_t g , float64 val ) 
{ 
  gnode_t *gn ;
  char *tmp ;

  {
  tmp = __mymalloc__((int32 )sizeof(gnode_t ), (char *)"glist.c", 113);
  gn = (gnode_t *)tmp;
  gn->data.float64 = val;
  gn->next = g;
  return (gn);
}
}
int32 glist_chkdup_ptr(glist_t g , void *val ) 
{ 
  gnode_t *gn ;

  {
  gn = g;
  while (gn) {
    if ((unsigned long )gn->data.ptr == (unsigned long )val) {
      return (1);
    }
    gn = gn->next;
  }
  return (0);
}
}
int32 glist_chkdup_int32(glist_t g , int32 val ) 
{ 
  gnode_t *gn ;

  {
  gn = g;
  while (gn) {
    if (gn->data.int32 == val) {
      return (1);
    }
    gn = gn->next;
  }
  return (0);
}
}
int32 glist_chkdup_uint32(glist_t g , uint32 val ) 
{ 
  gnode_t *gn ;

  {
  gn = g;
  while (gn) {
    if (gn->data.uint32 == val) {
      return (1);
    }
    gn = gn->next;
  }
  return (0);
}
}
int32 glist_chkdup_float32(glist_t g , float32 val ) 
{ 
  gnode_t *gn ;

  {
  gn = g;
  while (gn) {
    if (gn->data.float32 == val) {
      return (1);
    }
    gn = gn->next;
  }
  return (0);
}
}
int32 glist_chkdup_float64(glist_t g , float64 val ) 
{ 
  gnode_t *gn ;

  {
  gn = g;
  while (gn) {
    if (gn->data.float64 == val) {
      return (1);
    }
    gn = gn->next;
  }
  return (0);
}
}
void glist_apply_ptr(glist_t g , void (*func)(void * ) ) 
{ 
  gnode_t *gn ;

  {
  gn = g;
  while (gn) {
    (*func)(gn->data.ptr);
    gn = gn->next;
  }
  return;
}
}
void glist_apply_int32(glist_t g , void (*func)(int32  ) ) 
{ 
  gnode_t *gn ;

  {
  gn = g;
  while (gn) {
    (*func)(gn->data.int32);
    gn = gn->next;
  }
  return;
}
}
void glist_apply_uint32(glist_t g , void (*func)(uint32  ) ) 
{ 
  gnode_t *gn ;

  {
  gn = g;
  while (gn) {
    (*func)(gn->data.uint32);
    gn = gn->next;
  }
  return;
}
}
void glist_apply_float32(glist_t g , void (*func)(float32  ) ) 
{ 
  gnode_t *gn ;

  {
  gn = g;
  while (gn) {
    (*func)(gn->data.float32);
    gn = gn->next;
  }
  return;
}
}
void glist_apply_float64(glist_t g , void (*func)(float64  ) ) 
{ 
  gnode_t *gn ;

  {
  gn = g;
  while (gn) {
    (*func)(gn->data.float64);
    gn = gn->next;
  }
  return;
}
}
void glist_free(glist_t g ) 
{ 
  gnode_t *gn ;

  {
  while (g) {
    gn = g;
    g = gn->next;
    __myfree__((char *)gn, (int32 )sizeof(gnode_t ), (char *)"glist.c", 232);
  }
  return;
}
}
void glist_myfree(glist_t g , int32 datasize ) 
{ 
  gnode_t *gn ;

  {
  while (g) {
    gn = g;
    g = gn->next;
    __myfree__((char *)gn->data.ptr, datasize, (char *)"glist.c", 244);
    __myfree__((char *)gn, (int32 )sizeof(gnode_t ), (char *)"glist.c", 245);
  }
  return;
}
}
int32 glist_count(glist_t g ) 
{ 
  gnode_t *gn ;
  int32 n ;

  {
  gn = g;
  n = 0;
  while (gn) {
    gn = gn->next;
    n ++;
  }
  return (n);
}
}
gnode_t *glist_tail(glist_t g ) 
{ 
  gnode_t *gn ;

  {
  if (! g) {
    return ((gnode_t *)((void *)0));
  }
  gn = g;
  while (gn->next) {
    gn = gn->next;
  }
  return (gn);
}
}
glist_t glist_reverse(glist_t g ) 
{ 
  gnode_t *gn ;
  gnode_t *nextgn ;
  gnode_t *rev ;

  {
  rev = (gnode_t *)((void *)0);
  gn = g;
  while (gn) {
    nextgn = gn->next;
    gn->next = rev;
    rev = gn;
    gn = nextgn;
  }
  return (rev);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-ru96inBr.i","-O3")
extern int ( /* format attribute */  printf)(char const   *  , ...) ;
int gs_display(char *file , gs_t *gs ) ;
gs_t *gs_read(char *file ) ;
int gs_free(gs_t *gs ) ;
int32 gs_fread_int32(gs_t *gs ) 
{ 
  int32 val ;
  size_t tmp ;

  {
  tmp = fread((void *)(& val), sizeof(int32 ), (size_t )1, gs->fp);
  if (tmp != 1UL) {
    _E__pr_header("gs.c", 63L, "FATAL_ERROR");
    _E__die_error("fread failed\n");
  }
  return (val);
}
}
float32 gs_fread_float32(gs_t *gs ) 
{ 
  float32 val ;
  size_t tmp ;

  {
  tmp = fread((void *)(& val), sizeof(float32 ), (size_t )1, gs->fp);
  if (tmp != 1UL) {
    _E__pr_header("gs.c", 71L, "FATAL_ERROR");
    _E__die_error("fread failed\n");
  }
  return (val);
}
}
void gs_fread_bitvec_t(bitvec_t val , gs_t *gs ) 
{ 
  size_t tmp ;

  {
  tmp = fread((void *)val, (size_t )gs->n_mbyte, (size_t )1, gs->fp);
  if (tmp != 1UL) {
    _E__pr_header("gs.c", 78L, "FATAL_ERROR");
    _E__die_error("fread failed\n");
  }
  return;
}
}
int gs_display(char *file , gs_t *gs ) 
{ 
  int32 i ;
  int32 code_id ;
  int32 m_id ;
  int32 s_id ;
  int32 c_id ;
  float32 tmp ;
  bitvec_t bv___0 ;
  void *tmp___0 ;
  FILE *tmp___1 ;
  void *tmp___2 ;

  {
  _E__pr_info_header("gs.c", 89L, "INFO");
  _E__pr_info("Reading gaussian selector map: %s\n", file);
  tmp___0 = __ckd_calloc__((size_t )1, sizeof(gs_t ), "gs.c", 90);
  gs = (gs_t *)tmp___0;
  tmp___1 = fopen((char const   *)file, "rb");
  gs->fp = tmp___1;
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    _E__pr_header("gs.c", 93L, "FATAL_ERROR");
    _E__die_error("fopen(%s,rb) failed\n", file);
  }
  gs->n_mgau = gs_fread_int32(gs);
  _E__pr_info_header("gs.c", 97L, "INFO");
  _E__pr_info("The number of mixtures of gaussian: %d\n", gs->n_mgau);
  gs->n_feat = gs_fread_int32(gs);
  _E__pr_info_header("gs.c", 99L, "INFO");
  _E__pr_info("The number of features stream: %d\n", gs->n_feat);
  gs->n_density = gs_fread_int32(gs);
  _E__pr_info_header("gs.c", 101L, "INFO");
  _E__pr_info("The number of density: %d\n", gs->n_density);
  gs->n_code = gs_fread_int32(gs);
  _E__pr_info_header("gs.c", 103L, "INFO");
  _E__pr_info("The number of code word: %d\n", gs->n_code);
  gs->n_featlen = gs_fread_int32(gs);
  _E__pr_info_header("gs.c", 105L, "INFO");
  _E__pr_info("The feature length: %d\n", gs->n_featlen);
  gs->n_mbyte = (int32 )((unsigned long )((gs->n_density + 31) >> 5) * sizeof(uint32 ));
  _E__pr_info_header("gs.c", 108L, "INFO");
  _E__pr_info("The number of byte to read: %d\n", gs->n_mbyte);
  tmp___2 = __ckd_calloc__((size_t )((gs->n_density + 31) >> 5), sizeof(uint32 ),
                           "gs.c", 111);
  bv___0 = (bitvec_t )tmp___2;
  code_id = 0;
  while (code_id < gs->n_code) {
    printf("Code idx: %d\n", code_id);
    c_id = 0;
    while (c_id < gs->n_featlen) {
      tmp = gs_fread_float32(gs);
      printf("%f ", (double )tmp);
      c_id ++;
    }
    printf("\n");
    m_id = 0;
    while (m_id < gs->n_mgau) {
      s_id = 0;
      while (s_id < gs->n_feat) {
        gs_fread_bitvec_t(bv___0, gs);
        printf("%d %d ", m_id, s_id);
        i = 0;
        while (i < gs->n_density) {
          if (*(bv___0 + (i >> 5)) & (unsigned int )(1 << (i & 31))) {
            printf("%d ", i);
          }
          i ++;
        }
        printf("\n");
        s_id ++;
      }
      m_id ++;
    }
    code_id ++;
  }
  printf("\n");
  gs_free(gs);
  return (1);
}
}
gs_t *gs_read(char *file ) 
{ 
  int32 code_id ;
  int32 m_id ;
  int32 s_id ;
  int32 c_id ;
  bitvec_t bv___0 ;
  gs_t *gs ;
  void *tmp ;
  FILE *tmp___0 ;
  void *tmp___1 ;
  void **tmp___2 ;
  void ***tmp___3 ;
  void *tmp___4 ;

  {
  _E__pr_info_header("gs.c", 159L, "INFO");
  _E__pr_info("Reading gaussian selector map: %s\n", file);
  tmp = __ckd_calloc__((size_t )1, sizeof(gs_t ), "gs.c", 160);
  gs = (gs_t *)tmp;
  if ((unsigned long )gs == (unsigned long )((void *)0)) {
    _E__pr_header("gs.c", 162L, "FATAL_ERROR");
    _E__die_error("Cannot allocate gs\n");
  }
  tmp___0 = fopen((char const   *)file, "rb");
  gs->fp = tmp___0;
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    _E__pr_header("gs.c", 165L, "FATAL_ERROR");
    _E__die_error("gs_read(%s,rb) failed\n", file);
  }
  gs->n_mgau = gs_fread_int32(gs);
  _E__pr_info_header("gs.c", 169L, "INFO");
  _E__pr_info("The number of mixtures of gaussian: %d\n", gs->n_mgau);
  gs->n_feat = gs_fread_int32(gs);
  _E__pr_info_header("gs.c", 171L, "INFO");
  _E__pr_info("The number of features stream: %d\n", gs->n_feat);
  gs->n_density = gs_fread_int32(gs);
  _E__pr_info_header("gs.c", 173L, "INFO");
  _E__pr_info("The number of density: %d\n", gs->n_density);
  gs->n_code = gs_fread_int32(gs);
  _E__pr_info_header("gs.c", 175L, "INFO");
  _E__pr_info("The number of code word: %d\n", gs->n_code);
  gs->n_featlen = gs_fread_int32(gs);
  _E__pr_info_header("gs.c", 177L, "INFO");
  _E__pr_info("The feature length: %d\n", gs->n_featlen);
  gs->n_mbyte = (int32 )((unsigned long )((gs->n_density + 31) >> 5) * sizeof(uint32 ));
  _E__pr_info_header("gs.c", 180L, "INFO");
  _E__pr_info("The number of byte to read: %d\n", gs->n_mbyte);
  tmp___1 = __ckd_calloc__((size_t )((gs->n_density + 31) >> 5), sizeof(uint32 ),
                           "gs.c", 183);
  bv___0 = (bitvec_t )tmp___1;
  tmp___2 = __ckd_calloc_2d__(gs->n_code, gs->n_featlen, (int32 )sizeof(float32 ),
                              "gs.c", 188);
  gs->codeword = (float32 **)tmp___2;
  tmp___3 = __ckd_calloc_3d__(gs->n_mgau, gs->n_feat, gs->n_code, (int32 )sizeof(uint32 ),
                              "gs.c", 191);
  gs->codemap = (uint32 ***)tmp___3;
  tmp___4 = __ckd_calloc__((size_t )(gs->n_density + 1), sizeof(int32 ), "gs.c", 192);
  gs->mgau_sl = (int32 *)tmp___4;
  code_id = 0;
  while (code_id < gs->n_code) {
    c_id = 0;
    while (c_id < gs->n_featlen) {
      *(*(gs->codeword + code_id) + c_id) = gs_fread_float32(gs);
      c_id ++;
    }
    m_id = 0;
    while (m_id < gs->n_mgau) {
      s_id = 0;
      while (s_id < gs->n_feat) {
        gs_fread_bitvec_t(bv___0, gs);
        *(*(*(gs->codemap + m_id) + s_id) + code_id) = *bv___0;
        s_id ++;
      }
      m_id ++;
    }
    code_id ++;
  }
  return (gs);
}
}
int32 gc_compute_closest_cw(gs_t *gs , float32 *feat ) 
{ 
  int32 codeid ;
  int32 bst_codeid ;
  float64 diff1 ;
  float64 diff2 ;
  float64 tmp1 ;
  float64 tmp2 ;
  float64 min ;
  int32 cid ;
  float64 min_density ;

  {
  min_density = logs3_to_log((int32 )3355443200U);
  bst_codeid = 0;
  min = 1.8e+307;
  codeid = 0;
  while (codeid < gs->n_code) {
    tmp1 = (float64 )0;
    tmp2 = (float64 )0;
    cid = 0;
    while (cid < gs->n_featlen) {
      diff1 = (float64 )(*(feat + cid) - *(*(gs->codeword + codeid) + cid));
      tmp1 += diff1 * diff1;
      diff2 = (float64 )(*(feat + cid) - *(*(gs->codeword + (codeid + 1)) + cid));
      tmp2 += diff2 * diff2;
      cid ++;
    }
    if (tmp1 < min) {
      min = tmp1;
      bst_codeid = codeid;
    }
    if (tmp2 < min) {
      min = tmp2;
      bst_codeid = codeid + 1;
    }
    codeid += 2;
  }
  return (bst_codeid);
}
}
int32 gs_mgau_shortlist(gs_t *gs , int m , int n , float32 *feat , int bst_codeid ) 
{ 
  uint32 map ;
  int32 bit_id ;
  int32 nc ;
  int32 tmp ;
  int32 tmp___0 ;

  {
  nc = 0;
  map = (uint32 )0;
  map = *(*(*(gs->codemap + m) + 0) + bst_codeid);
  bit_id = 0;
  while (bit_id < n) {
    if (map & (unsigned int )(1 << bit_id)) {
      tmp = nc;
      nc ++;
      *(gs->mgau_sl + tmp) = bit_id;
    }
    bit_id ++;
  }
  *(gs->mgau_sl + nc) = -1;
  if (nc == 0) {
    bit_id = 0;
    while (bit_id < n) {
      tmp___0 = nc;
      nc ++;
      *(gs->mgau_sl + tmp___0) = bit_id;
      bit_id ++;
    }
    *(gs->mgau_sl + nc) = -1;
  }
  if (nc == 0) {
    _E__pr_info_header("gs.c", 287L, "INFO");
    _E__pr_info("No active gaussian found in senone %d, with num. component = %d\n",
                m, n);
  }
  return (nc);
}
}
int32 gs_delete(char *file ) 
{ 


  {
  return (1);
}
}
int gs_free(gs_t *gs ) 
{ 


  {
  fclose(gs->fp);
  free((void *)gs);
  return (1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-9oTDycId.i","-O3")
int32 hash_lookup_bkey(hash_table_t *h , char const   *key , int32 len , int32 *val ) ;
static int32 prime[46]  = 
  {      101,      211,      307,      401, 
        503,      601,      701,      809, 
        907,      1009,      1201,      1601, 
        2003,      2411,      3001,      4001, 
        5003,      6007,      7001,      8009, 
        9001,      10007,      12007,      16001, 
        20011,      24001,      30011,      40009, 
        50021,      60013,      70001,      80021, 
        90001,      100003,      120011,      160001, 
        200003,      240007,      300007,      400009, 
        500009,      600011,      700001,      800011, 
        900001,      -1};
static int32 prime_size(int32 size ) 
{ 
  int32 i ;

  {
  i = 0;
  while (1) {
    if (prime[i] > 0) {
      if (! (prime[i] < size)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  if (prime[i] <= 0) {
    _E__pr_header("hash.c", 115L, "WARNING");
    _E__pr_warn("Very large hash table requested (%d entries)\n", size);
    i --;
  }
  return (prime[i]);
}
}
hash_table_t *hash_new(int32 size , int32 casearg ) 
{ 
  hash_table_t *h ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = __ckd_calloc__((size_t )1, sizeof(hash_table_t ), "hash.c", 126);
  h = (hash_table_t *)tmp;
  h->size = prime_size(size + (size >> 1));
  h->nocase = (uint8 )(casearg == 1);
  tmp___0 = __ckd_calloc__((size_t )h->size, sizeof(hash_entry_t ), "hash.c", 129);
  h->table = (hash_entry_t *)tmp___0;
  return (h);
}
}
static uint32 key2hash(hash_table_t *h , char const   *key ) 
{ 
  register char const   *cp ;
  register char c ;
  register int32 s___0 ;
  register uint32 hash ;

  {
  hash = (uint32 )0;
  s___0 = 0;
  if (h->nocase) {
    cp = key;
    while (*cp) {
      c = (char )*cp;
      if ((int )c >= 97) {
        if ((int )c <= 122) {
          c = (char )((int )c - 32);
        } else {
          c = c;
        }
      } else {
        c = c;
      }
      hash += (uint32 )((int )c << s___0);
      s___0 += 5;
      if (s___0 >= 25) {
        s___0 -= 24;
      }
      cp ++;
    }
  } else {
    cp = key;
    while (*cp) {
      hash += (uint32 )((int const   )*cp << s___0);
      s___0 += 5;
      if (s___0 >= 25) {
        s___0 -= 24;
      }
      cp ++;
    }
  }
  return (hash % (unsigned int )h->size);
}
}
static char *makekey(uint8 *data , int32 len , char *key ) 
{ 
  int32 i ;
  int32 j ;
  void *tmp ;

  {
  if (! key) {
    tmp = __ckd_calloc__((size_t )(len * 2 + 1), sizeof(char ), "hash.c", 177);
    key = (char *)tmp;
  }
  i = 0;
  j = 0;
  while (i < len) {
    *(key + j) = (char )(65 + ((int )*(data + i) & 15));
    *(key + (j + 1)) = (char )(74 + (((int )*(data + i) >> 4) & 15));
    i ++;
    j += 2;
  }
  *(key + j) = (char )'\000';
  return (key);
}
}
static int32 keycmp_nocase(hash_entry_t *entry , char const   *key ) 
{ 
  char c1 ;
  char c2 ;
  int32 i ;
  char const   *str ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  str = entry->key;
  i = 0;
  while (i < entry->len) {
    tmp = str;
    str ++;
    c1 = (char )*tmp;
    if ((int )c1 >= 97) {
      if ((int )c1 <= 122) {
        c1 = (char )((int )c1 - 32);
      } else {
        c1 = c1;
      }
    } else {
      c1 = c1;
    }
    tmp___0 = key;
    key ++;
    c2 = (char )*tmp___0;
    if ((int )c2 >= 97) {
      if ((int )c2 <= 122) {
        c2 = (char )((int )c2 - 32);
      } else {
        c2 = c2;
      }
    } else {
      c2 = c2;
    }
    if ((int )c1 != (int )c2) {
      return ((int )c1 - (int )c2);
    }
    i ++;
  }
  return (0);
}
}
static int32 keycmp_case(hash_entry_t *entry , char const   *key ) 
{ 
  char c1 ;
  char c2 ;
  int32 i ;
  char const   *str ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  str = entry->key;
  i = 0;
  while (i < entry->len) {
    tmp = str;
    str ++;
    c1 = (char )*tmp;
    tmp___0 = key;
    key ++;
    c2 = (char )*tmp___0;
    if ((int )c1 != (int )c2) {
      return ((int )c1 - (int )c2);
    }
    i ++;
  }
  return (0);
}
}
static int32 lookup(hash_table_t *h , uint32 hash , char const   *key , int32 len ,
                    int32 *val ) 
{ 
  hash_entry_t *entry ;
  int32 tmp ;
  int32 tmp___0 ;

  {
  entry = h->table + hash;
  if ((unsigned long )entry->key == (unsigned long )((void *)0)) {
    return (-1);
  }
  if (h->nocase) {
    while (1) {
      if (entry) {
        if (! (entry->len != len)) {
          tmp = keycmp_nocase(entry, key);
          if (! (tmp != 0)) {
            break;
          }
        }
      } else {
        break;
      }
      entry = entry->next;
    }
  } else {
    while (1) {
      if (entry) {
        if (! (entry->len != len)) {
          tmp___0 = keycmp_case(entry, key);
          if (! (tmp___0 != 0)) {
            break;
          }
        }
      } else {
        break;
      }
      entry = entry->next;
    }
  }
  if (entry) {
    *val = entry->val;
    return (0);
  } else {
    return (-1);
  }
}
}
int32 hash_lookup(hash_table_t *h , char const   *key , int32 *val ) 
{ 
  uint32 hash ;
  int32 len ;
  size_t tmp ;
  int32 tmp___0 ;

  {
  hash = key2hash(h, key);
  tmp = strlen(key);
  len = (int32 )tmp;
  tmp___0 = lookup(h, hash, key, len, val);
  return (tmp___0);
}
}
int32 hash_lookup_bkey(hash_table_t *h , char const   *key , int32 len , int32 *val ) 
{ 
  uint32 hash ;
  char *str ;
  int32 tmp ;

  {
  str = makekey((uint8 *)key, len, (char *)((void *)0));
  hash = key2hash(h, (char const   *)str);
  ckd_free((void *)str);
  tmp = lookup(h, hash, key, len, val);
  return (tmp);
}
}
static int32 enter(hash_table_t *h , uint32 hash , char const   *key , int32 len ,
                   int32 val ) 
{ 
  int32 old ;
  hash_entry_t *cur ;
  hash_entry_t *new ;
  int32 tmp ;
  void *tmp___0 ;

  {
  tmp = lookup(h, hash, key, len, & old);
  if (tmp == 0) {
    return (old);
  }
  cur = h->table + hash;
  if ((unsigned long )cur->key == (unsigned long )((void *)0)) {
    cur->key = key;
    cur->len = len;
    cur->val = val;
  } else {
    tmp___0 = __ckd_calloc__((size_t )1, sizeof(hash_entry_t ), "hash.c", 299);
    new = (hash_entry_t *)tmp___0;
    new->key = key;
    new->len = len;
    new->val = val;
    new->next = cur->next;
    cur->next = new;
  }
  return (val);
}
}
int32 hash_enter(hash_table_t *h , char const   *key , int32 val ) 
{ 
  uint32 hash ;
  int32 len ;
  size_t tmp ;
  int32 tmp___0 ;

  {
  hash = key2hash(h, key);
  tmp = strlen(key);
  len = (int32 )tmp;
  tmp___0 = enter(h, hash, key, len, val);
  return (tmp___0);
}
}
int32 hash_enter_bkey(hash_table_t *h , char const   *key , int32 len , int32 val ) 
{ 
  uint32 hash ;
  char *str ;
  int32 tmp ;

  {
  str = makekey((uint8 *)key, len, (char *)((void *)0));
  hash = key2hash(h, (char const   *)str);
  ckd_free((void *)str);
  tmp = enter(h, hash, key, len, val);
  return (tmp);
}
}
glist_t hash_tolist(hash_table_t *h , int32 *count ) 
{ 
  glist_t g ;
  hash_entry_t *e ;
  int32 i ;
  int32 j ;

  {
  g = (glist_t )((void *)0);
  j = 0;
  i = 0;
  while (i < h->size) {
    e = h->table + i;
    if ((unsigned long )e->key != (unsigned long )((void *)0)) {
      g = glist_add_ptr(g, (void *)e);
      j ++;
      e = e->next;
      while (e) {
        g = glist_add_ptr(g, (void *)e);
        j ++;
        e = e->next;
      }
    }
    i ++;
  }
  *count = j;
  return (g);
}
}
void hash_free(hash_table_t *h ) 
{ 
  hash_entry_t *e ;
  hash_entry_t *e2 ;
  int32 i ;

  {
  i = 0;
  while (i < h->size) {
    e = (h->table + i)->next;
    while (e) {
      e2 = e->next;
      ckd_free((void *)e);
      e = e2;
    }
    i ++;
  }
  ckd_free((void *)h->table);
  ckd_free((void *)h);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-_RBTH2Z7.i","-O3")
heap_t heap_new(void) ;
int32 heap_insert(heap_t heap , void *data , int32 val ) ;
int32 heap_top(heap_t heap , void **data , int32 *val ) ;
int32 heap_pop(heap_t heap , void **data , int32 *val ) ;
int32 heap_destroy(heap_t heap ) ;
heap_t heap_new(void) 
{ 
  heapnode_t **h ;
  void *tmp ;

  {
  tmp = __ckd_calloc__((size_t )1, sizeof(heapnode_t *), "heap.c", 97);
  h = (heapnode_t **)tmp;
  *h = (heapnode_t *)((void *)0);
  return ((heap_t )h);
}
}
static heapnode_t *subheap_insert(heapnode_t *root , void *data , int32 val ) 
{ 
  heapnode_t *h ;
  void *tmpdata ;
  int32 tmpval ;
  char *tmp ;
  struct heap_s *tmp___0 ;
  int32 tmp___1 ;

  {
  if (! root) {
    tmp = __mymalloc__((int32 )sizeof(heapnode_t ), (char *)"heap.c", 111);
    h = (heapnode_t *)tmp;
    h->data = data;
    h->val = val;
    tmp___0 = (struct heap_s *)((void *)0);
    h->r = tmp___0;
    h->l = tmp___0;
    tmp___1 = 0;
    h->nr = tmp___1;
    h->nl = tmp___1;
    return (h);
  }
  if (root->val > val) {
    tmpdata = root->data;
    tmpval = root->val;
    root->data = data;
    root->val = val;
    data = tmpdata;
    val = tmpval;
  }
  if (root->nl > root->nr) {
    root->r = subheap_insert(root->r, data, val);
    (root->nr) ++;
  } else {
    root->l = subheap_insert(root->l, data, val);
    (root->nl) ++;
  }
  return (root);
}
}
int32 heap_insert(heap_t heap , void *data , int32 val ) 
{ 
  heapnode_t **hp ;

  {
  hp = (heapnode_t **)heap;
  *hp = subheap_insert(*hp, data, val);
  return (0);
}
}
static heapnode_t *subheap_pop(heapnode_t *root ) 
{ 
  heapnode_t *l ;
  heapnode_t *r ;

  {
  l = root->l;
  r = root->r;
  if (! l) {
    if (! r) {
      __myfree__((char *)root, (int32 )sizeof(heapnode_t ), (char *)"heap.c", 164);
      return ((heapnode_t *)((void *)0));
    } else {
      root->data = r->data;
      root->val = r->val;
      root->r = subheap_pop(r);
      (root->nr) --;
    }
  } else
  if (! r) {
    root->data = l->data;
    root->val = l->val;
    root->l = subheap_pop(l);
    (root->nl) --;
  } else
  if (l->val < r->val) {
    root->data = l->data;
    root->val = l->val;
    root->l = subheap_pop(l);
    (root->nl) --;
  } else {
    root->data = r->data;
    root->val = r->val;
    root->r = subheap_pop(r);
    (root->nr) --;
  }
  return (root);
}
}
int32 heap_pop(heap_t heap , void **data , int32 *val ) 
{ 
  heapnode_t **hp ;
  heapnode_t *h ;

  {
  hp = (heapnode_t **)heap;
  h = *hp;
  if (! h) {
    return (0);
  }
  *data = h->data;
  *val = h->val;
  *hp = subheap_pop(h);
  return (1);
}
}
int32 heap_top(heap_t heap , void **data , int32 *val ) 
{ 
  heapnode_t **hp ;
  heapnode_t *h ;

  {
  hp = (heapnode_t **)heap;
  h = *hp;
  if (! h) {
    return (0);
  }
  *data = h->data;
  *val = h->val;
  return (1);
}
}
int32 heap_destroy(heap_t heap ) 
{ 
  void *data ;
  int32 val ;
  int32 tmp ;

  {
  while (1) {
    tmp = heap_pop(heap, & data, & val);
    if (! (tmp > 0)) {
      break;
    }
  }
  ckd_free((void *)((char *)heap));
  return (0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-tN9Oelil.i","-O3")
void hmm_clear(hmm_t *h , int32 n_state ) ;
int32 hmm_vit_eval_5st(hmm_t *hmm , s3senid_t *senid , int32 *senscr ) ;
int32 hmm_vit_eval_3st(hmm_t *hmm , s3senid_t *senid , int32 *senscr ) ;
int32 hmm_dump_vit_eval(hmm_t *hmm , int32 n_state , s3senid_t *senid , int32 *senscr ,
                        FILE *fp ) ;
void hmm_dump(hmm_t *hmm , int32 n_state , s3senid_t *senid , int32 *senscr , FILE *fp ) ;
static int32 NO_UFLOW_ADD(int32 a , int32 b ) ;
void hmm_dump(hmm_t *hmm , int32 n_state , s3senid_t *senid , int32 *senscr , FILE *fp ) 
{ 
  int32 i ;

  {
  fprintf(fp, " %11d    ", hmm->in.score);
  i = 0;
  while (i < n_state) {
    fprintf(fp, " %11d", (hmm->state + i)->score);
    i ++;
  }
  fprintf(fp, "     %11d\n", hmm->out.score);
  fprintf(fp, " %11d    ", hmm->in.history);
  i = 0;
  while (i < n_state) {
    fprintf(fp, " %11d", (hmm->state + i)->history);
    i ++;
  }
  fprintf(fp, "     %11d\n", hmm->out.history);
  if (senid) {
    fprintf(fp, " %-11s    ", "senid");
    i = 0;
    while (i < n_state) {
      fprintf(fp, " %11d", (int )*(senid + i));
      i ++;
    }
    fprintf(fp, "\n");
    if (senscr) {
      fprintf(fp, " %-11s    ", "senscr");
      i = 0;
      while (i < n_state) {
        fprintf(fp, " %11d", *(senscr + *(senid + i)));
        i ++;
      }
      fprintf(fp, "\n");
    }
  }
  fflush(fp);
  return;
}
}
void hmm_clear(hmm_t *h , int32 n_state ) 
{ 
  int32 i ;

  {
  h->in.score = (int32 )3355443200U;
  h->in.history = -1;
  i = 0;
  while (i < n_state) {
    (h->state + i)->score = (int32 )3355443200U;
    (h->state + i)->history = -1;
    i ++;
  }
  h->out.score = (int32 )3355443200U;
  h->out.history = -1;
  h->bestscore = (int32 )3355443200U;
  return;
}
}
static int32 NO_UFLOW_ADD(int32 a , int32 b ) 
{ 
  int c ;

  {
  c = a + b;
  if (c > 0) {
    if (a < 0) {
      if (b < 0) {
        c = (int32 )2147483648U;
      } else {
        c = c;
      }
    } else {
      c = c;
    }
  } else {
    c = c;
  }
  return (c);
}
}
int32 hmm_vit_eval_5st(hmm_t *hmm , s3senid_t *senid , int32 *senscr ) 
{ 
  int32 s0 ;
  int32 s1 ;
  int32 s2 ;
  int32 s3 ;
  int32 s4 ;
  int32 best ;
  int32 *tp ;

  {
  tp = *(hmm->tp + 0);
  s4 = NO_UFLOW_ADD((hmm->state + 4)->score, *(tp + 28));
  s3 = NO_UFLOW_ADD((hmm->state + 3)->score, *(tp + 22));
  s2 = NO_UFLOW_ADD((hmm->state + 2)->score, *(tp + 16));
  if (s4 < s3) {
    if (s3 >= s2) {
      s4 = s3;
      (hmm->state + 4)->history = (hmm->state + 3)->history;
    } else {
      s4 = s2;
      (hmm->state + 4)->history = (hmm->state + 2)->history;
    }
  } else
  if (s4 < s2) {
    s4 = s2;
    (hmm->state + 4)->history = (hmm->state + 2)->history;
  }
  s4 = NO_UFLOW_ADD(s4, *(senscr + *(senid + 4)));
  (hmm->state + 4)->score = s4;
  s3 = NO_UFLOW_ADD((hmm->state + 3)->score, *(tp + 21));
  s2 = NO_UFLOW_ADD((hmm->state + 2)->score, *(tp + 15));
  s1 = NO_UFLOW_ADD((hmm->state + 1)->score, *(tp + 9));
  if (s3 < s2) {
    if (s2 >= s1) {
      s3 = s2;
      (hmm->state + 3)->history = (hmm->state + 2)->history;
    } else {
      s3 = s1;
      (hmm->state + 3)->history = (hmm->state + 1)->history;
    }
  } else
  if (s3 < s1) {
    s3 = s1;
    (hmm->state + 3)->history = (hmm->state + 1)->history;
  }
  s3 = NO_UFLOW_ADD(s3, *(senscr + *(senid + 3)));
  (hmm->state + 3)->score = s3;
  if (s4 > s3) {
    best = s4;
  } else {
    best = s3;
  }
  s4 = NO_UFLOW_ADD(s4, *(tp + 29));
  s3 = NO_UFLOW_ADD(s3, *(tp + 23));
  if (s4 < s3) {
    hmm->out.score = s3;
    hmm->out.history = (hmm->state + 3)->history;
  } else {
    hmm->out.score = s4;
    hmm->out.history = (hmm->state + 4)->history;
  }
  s2 = NO_UFLOW_ADD((hmm->state + 2)->score, *(tp + 14));
  s1 = NO_UFLOW_ADD((hmm->state + 1)->score, *(tp + 8));
  s0 = NO_UFLOW_ADD((hmm->state + 0)->score, *(tp + 2));
  if (s2 < s1) {
    if (s1 >= s0) {
      s2 = s1;
      (hmm->state + 2)->history = (hmm->state + 1)->history;
    } else {
      s2 = s0;
      (hmm->state + 2)->history = (hmm->state + 0)->history;
    }
  } else
  if (s2 < s0) {
    s2 = s0;
    (hmm->state + 2)->history = (hmm->state + 0)->history;
  }
  s2 = NO_UFLOW_ADD(s2, *(senscr + *(senid + 2)));
  (hmm->state + 2)->score = s2;
  if (best < s2) {
    best = s2;
  }
  s1 = NO_UFLOW_ADD((hmm->state + 1)->score, *(tp + 7));
  s0 = NO_UFLOW_ADD((hmm->state + 0)->score, *(tp + 1));
  if (s1 < s0) {
    s1 = s0;
    (hmm->state + 1)->history = (hmm->state + 0)->history;
  }
  s1 = NO_UFLOW_ADD(s1, *(senscr + *(senid + 1)));
  (hmm->state + 1)->score = s1;
  if (best < s1) {
    best = s1;
  }
  s0 = NO_UFLOW_ADD((hmm->state + 0)->score, *(tp + 0));
  if (s0 < hmm->in.score) {
    s0 = hmm->in.score;
    (hmm->state + 0)->history = hmm->in.history;
  }
  s0 = NO_UFLOW_ADD(s0, *(senscr + *(senid + 0)));
  (hmm->state + 0)->score = s0;
  if (best < s0) {
    best = s0;
  }
  hmm->in.score = (int32 )3355443200U;
  hmm->bestscore = best;
  return (best);
}
}
int32 hmm_vit_eval_3st(hmm_t *hmm , s3senid_t *senid , int32 *senscr ) 
{ 
  int32 s0 ;
  int32 s1 ;
  int32 s2 ;
  int32 best ;
  int32 *tp ;

  {
  tp = *(hmm->tp + 0);
  s2 = NO_UFLOW_ADD((hmm->state + 2)->score, *(tp + 10));
  s1 = NO_UFLOW_ADD((hmm->state + 1)->score, *(tp + 6));
  if (*(tp + 2) > -939524096) {
    s0 = NO_UFLOW_ADD((hmm->state + 0)->score, *(tp + 2));
    if (s2 < s1) {
      if (s1 >= s0) {
        s2 = s1;
        (hmm->state + 2)->history = (hmm->state + 1)->history;
      } else {
        s2 = s0;
        (hmm->state + 2)->history = (hmm->state + 0)->history;
      }
    } else
    if (s2 < s0) {
      s2 = s0;
      (hmm->state + 2)->history = (hmm->state + 0)->history;
    }
  } else
  if (s2 < s1) {
    s2 = s1;
    (hmm->state + 2)->history = (hmm->state + 1)->history;
  }
  s2 = NO_UFLOW_ADD(s2, *(senscr + *(senid + 2)));
  (hmm->state + 2)->score = s2;
  s1 = NO_UFLOW_ADD((hmm->state + 1)->score, *(tp + 5));
  s0 = NO_UFLOW_ADD((hmm->state + 0)->score, *(tp + 1));
  if (s1 < s0) {
    s1 = s0;
    (hmm->state + 1)->history = (hmm->state + 0)->history;
  }
  s1 = NO_UFLOW_ADD(s1, *(senscr + *(senid + 1)));
  (hmm->state + 1)->score = s1;
  if (s2 > s1) {
    best = s2;
  } else {
    best = s1;
  }
  s2 = NO_UFLOW_ADD(s2, *(tp + 11));
  if (*(tp + 7) > -939524096) {
    s1 = NO_UFLOW_ADD(s1, *(tp + 7));
    if (s2 < s1) {
      hmm->out.score = s1;
      hmm->out.history = (hmm->state + 1)->history;
    } else {
      hmm->out.score = s2;
      hmm->out.history = (hmm->state + 2)->history;
    }
  } else {
    hmm->out.score = s2;
    hmm->out.history = (hmm->state + 2)->history;
  }
  s0 = NO_UFLOW_ADD((hmm->state + 0)->score, *(tp + 0));
  if (s0 < hmm->in.score) {
    s0 = hmm->in.score;
    (hmm->state + 0)->history = hmm->in.history;
  }
  s0 = NO_UFLOW_ADD(s0, *(senscr + *(senid + 0)));
  (hmm->state + 0)->score = s0;
  if (best < s0) {
    best = s0;
  }
  hmm->in.score = (int32 )3355443200U;
  hmm->bestscore = best;
  return (best);
}
}
int32 hmm_dump_vit_eval(hmm_t *hmm , int32 n_state , s3senid_t *senid , int32 *senscr ,
                        FILE *fp ) 
{ 
  int32 bs___0 ;

  {
  bs___0 = 0;
  if (fp) {
    hmm_dump(hmm, n_state, senid, senscr, fp);
  }
  if (n_state == 5) {
    bs___0 = hmm_vit_eval_5st(hmm, senid, senscr);
  } else
  if (n_state == 3) {
    bs___0 = hmm_vit_eval_3st(hmm, senid, senscr);
  } else {
    _E__pr_header("hmm.c", 427L, "FATAL_ERROR");
    _E__die_error("#States= %d unsupported\n", n_state);
  }
  if (fp) {
    hmm_dump(hmm, n_state, senid, senscr, fp);
  }
  return (bs___0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-lTN2BxuK.i","-O3")
extern int pclose(FILE * ) ;
extern FILE *popen(char const   * , char const   * )  __asm__("_popen")  ;
extern unsigned int sleep(unsigned int  )  __asm__("_sleep")  ;
extern int stat(char const   * , struct stat * )  __asm__("_stat$INODE64")  ;
FILE *fopen_comp(char *file , char *mode , int32 *ispipe ) ;
void fclose_comp(FILE *fp , int32 ispipe ) ;
FILE *fopen_compchk(char *file , int32 *ispipe ) ;
int32 stat_mtime(char *file ) ;
FILE *fopen_comp(char *file , char *mode , int32 *ispipe ) 
{ 
  char command[16384] ;
  FILE *fp ;
  int32 k___0 ;
  int32 isgz ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  tmp = strlen((char const   *)file);
  k___0 = (int32 )tmp;
  *ispipe = 0;
  isgz = 0;
  if (k___0 > 2) {
    tmp___2 = strcmp((char const   *)((file + k___0) - 2), ".Z");
    if (tmp___2 == 0) {
      *ispipe = 1;
    } else {
      tmp___3 = strcmp((char const   *)((file + k___0) - 2), ".z");
      if (tmp___3 == 0) {
        *ispipe = 1;
      } else {
        goto _L;
      }
    }
  } else
  _L: /* CIL Label */ 
  if (k___0 > 3) {
    tmp___0 = strcmp((char const   *)((file + k___0) - 3), ".gz");
    if (tmp___0 == 0) {
      *ispipe = 1;
      isgz = 1;
    } else {
      tmp___1 = strcmp((char const   *)((file + k___0) - 3), ".GZ");
      if (tmp___1 == 0) {
        *ispipe = 1;
        isgz = 1;
      }
    }
  }
  if (*ispipe) {
    tmp___9 = strcmp((char const   *)mode, "r");
    if (tmp___9 == 0) {
      if (isgz) {
        tmp___4 = __builtin_object_size((void *)(command), 1);
        __builtin___sprintf_chk(command, 0, tmp___4, "gunzip -c %s", file);
      } else {
        tmp___5 = __builtin_object_size((void *)(command), 1);
        __builtin___sprintf_chk(command, 0, tmp___5, "zcat %s", file);
      }
      fp = popen((char const   *)(command), (char const   *)mode);
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
        _E__pr_header("io.c", 117L, "SYSTEM_ERROR");
        _E__sys_error("popen (%s,%s) failed\n", command, mode);
        return ((FILE *)((void *)0));
      }
    } else {
      tmp___8 = strcmp((char const   *)mode, "w");
      if (tmp___8 == 0) {
        if (isgz) {
          tmp___6 = __builtin_object_size((void *)(command), 1);
          __builtin___sprintf_chk(command, 0, tmp___6, "gzip > %s", file);
        } else {
          tmp___7 = __builtin_object_size((void *)(command), 1);
          __builtin___sprintf_chk(command, 0, tmp___7, "compress -c > %s", file);
        }
        fp = popen((char const   *)(command), (char const   *)mode);
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          _E__pr_header("io.c", 127L, "SYSTEM_ERROR");
          _E__sys_error("popen (%s,%s) failed\n", command, mode);
          return ((FILE *)((void *)0));
        }
      } else {
        _E__pr_header("io.c", 131L, "ERROR");
        _E__pr_warn("fopen_comp not implemented for mode = %s\n", mode);
        return ((FILE *)((void *)0));
      }
    }
  } else {
    fp = fopen((char const   *)file, (char const   *)mode);
  }
  return (fp);
}
}
void fclose_comp(FILE *fp , int32 ispipe ) 
{ 


  {
  if (ispipe) {
    pclose(fp);
  } else {
    fclose(fp);
  }
  return;
}
}
FILE *fopen_compchk(char *file , int32 *ispipe ) 
{ 
  char tmpfile___0[16384] ;
  int32 k___0 ;
  int32 isgz ;
  struct stat statbuf ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  FILE *tmp___14 ;

  {
  tmp = strlen((char const   *)file);
  k___0 = (int32 )tmp;
  *ispipe = 0;
  isgz = 0;
  if (k___0 > 2) {
    tmp___2 = strcmp((char const   *)((file + k___0) - 2), ".Z");
    if (tmp___2 == 0) {
      *ispipe = 1;
    } else {
      tmp___3 = strcmp((char const   *)((file + k___0) - 2), ".z");
      if (tmp___3 == 0) {
        *ispipe = 1;
      } else {
        goto _L;
      }
    }
  } else
  _L: /* CIL Label */ 
  if (k___0 > 3) {
    tmp___0 = strcmp((char const   *)((file + k___0) - 3), ".gz");
    if (tmp___0 == 0) {
      *ispipe = 1;
      isgz = 1;
    } else {
      tmp___1 = strcmp((char const   *)((file + k___0) - 3), ".GZ");
      if (tmp___1 == 0) {
        *ispipe = 1;
        isgz = 1;
      }
    }
  }
  tmp___5 = __builtin_object_size((void *)(tmpfile___0), 0);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___4 = __builtin_object_size((void *)(tmpfile___0), 1);
    __builtin___strcpy_chk(tmpfile___0, (char const   *)file, tmp___4);
  } else {
    __inline_strcpy_chk(tmpfile___0, (char const   *)file);
  }
  tmp___13 = stat((char const   *)(tmpfile___0), & statbuf);
  if (tmp___13 != 0) {
    _E__pr_header("io.c", 185L, "SYSTEM_ERROR");
    _E__sys_error("stat(%s) failed\n", tmpfile___0);
    if (*ispipe) {
      if (isgz) {
        tmpfile___0[k___0 - 3] = (char )'\000';
      } else {
        tmpfile___0[k___0 - 2] = (char )'\000';
      }
      tmp___6 = stat((char const   *)(tmpfile___0), & statbuf);
      if (tmp___6 != 0) {
        return ((FILE *)((void *)0));
      }
    } else {
      tmp___8 = __builtin_object_size((void *)(tmpfile___0 + k___0), 0);
      if (tmp___8 != 0xffffffffffffffffUL) {
        tmp___7 = __builtin_object_size((void *)(tmpfile___0 + k___0), 1);
        __builtin___strcpy_chk(tmpfile___0 + k___0, ".gz", tmp___7);
      } else {
        __inline_strcpy_chk(tmpfile___0 + k___0, ".gz");
      }
      tmp___12 = stat((char const   *)(tmpfile___0), & statbuf);
      if (tmp___12 != 0) {
        tmp___10 = __builtin_object_size((void *)(tmpfile___0 + k___0), 0);
        if (tmp___10 != 0xffffffffffffffffUL) {
          tmp___9 = __builtin_object_size((void *)(tmpfile___0 + k___0), 1);
          __builtin___strcpy_chk(tmpfile___0 + k___0, ".Z", tmp___9);
        } else {
          __inline_strcpy_chk(tmpfile___0 + k___0, ".Z");
        }
        tmp___11 = stat((char const   *)(tmpfile___0), & statbuf);
        if (tmp___11 != 0) {
          return ((FILE *)((void *)0));
        }
      }
    }
    _E__pr_header("io.c", 208L, "WARNING");
    _E__pr_warn("Using %s instead of %s\n", tmpfile___0, file);
  }
  tmp___14 = fopen_comp(tmpfile___0, (char *)"r", ispipe);
  return (tmp___14);
}
}
int32 fread_retry(void *pointer , int32 size , int32 num_items , FILE *stream ) 
{ 
  char *data ;
  uint32 n_items_read ;
  uint32 n_items_rem ;
  uint32 n_retry_rem ;
  int32 loc ;
  size_t tmp ;

  {
  n_retry_rem = (uint32 )60;
  data = (char *)pointer;
  loc = 0;
  n_items_rem = (uint32 )num_items;
  while (1) {
    tmp = fread((void *)(data + loc), (size_t )size, (size_t )n_items_rem, stream);
    n_items_read = (uint32 )tmp;
    n_items_rem -= n_items_read;
    if (n_items_rem > 0U) {
      if (n_retry_rem == 0U) {
        return (-1);
      }
      if (n_retry_rem == 60U) {
        _E__pr_header("io.c", 243L, "SYSTEM_ERROR");
        _E__sys_error("fread() failed; retrying...\n");
      }
      n_retry_rem --;
      loc = (int32 )((uint32 )loc + n_items_read * (uint32 )size);
      sleep(1U);
    }
    if (! (n_items_rem > 0U)) {
      break;
    }
  }
  return (num_items);
}
}
int32 stat_retry(char *file , struct stat *statbuf ) 
{ 
  int32 i ;
  int tmp ;

  {
  i = 0;
  while (i < 10) {
    tmp = stat((char const   *)file, statbuf);
    if (tmp == 0) {
      return (0);
    }
    if (i == 0) {
      _E__pr_header("io.c", 270L, "SYSTEM_ERROR");
      _E__sys_error("stat(%s) failed; retrying...\n", file);
    }
    sleep(10U);
    i ++;
  }
  return (-1);
}
}
int32 stat_mtime(char *file ) 
{ 
  struct stat statbuf ;
  int tmp ;

  {
  tmp = stat((char const   *)file, & statbuf);
  if (tmp != 0) {
    return (-1);
  }
  return ((int32 )statbuf.st_mtimespec.tv_sec);
}
}
FILE *_myfopen(char *file , char *mode , char *pgm , int32 line ) 
{ 
  FILE *fp ;
  int *tmp ;

  {
  fp = fopen((char const   *)file, (char const   *)mode);
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    fflush(__stdoutp);
    fprintf(__stderrp, "FATAL_ERROR: \"%s\", line %d: fopen(%s,%s) failed; ", pgm,
            line, file, mode);
    perror("");
    fflush(__stderrp);
    tmp = __error();
    exit(*tmp);
  }
  return (fp);
}
}
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-cK9eSRi5.i","-O3")
__inline static void *__inline_memset_chk(void *__dest , int __val , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memset_chk(__dest, __val, __len, tmp);
  return (tmp___0);
}
}
void ptmr_init(ptmr_t *tm ) ;
int32 lm_ug_wordprob(lm_t *lm , dict_t *dict , int32 th , wordprob_t *wp ) ;
int32 wid_wordprob2alt(dict_t *dict , wordprob_t *wp , int32 n ) ;
int32 tmat_chk_1skip(tmat_t *tmat ) ;
kbcore_t *kbcore_init(float64 logbase , char *feattype , char *cmn___0 , char *varnorm ,
                      char *agc , char *mdeffile , char *dictfile , char *fdictfile ,
                      char *compsep , char *lmfile , char *lmctlfile , char *lmdumpdir ,
                      char *fillpenfile , char *senmgau , float64 silprob , float64 fillprob ,
                      float64 langwt , float64 inspen , float64 uw , char *meanfile ,
                      char *varfile , float64 varfloor , char *mixwfile , float64 mixwfloor ,
                      char *subvqfile , char *gsfile , char *tmatfile , float64 tmatfloor ) ;
void kbcore_free(kbcore_t *kbcore___0 ) ;
vithist_t *vithist_init(kbcore_t *kbc , int32 wbeam , int32 bghist ) ;
lextree_t *lextree_build(kbcore_t *kbc , wordprob_t *wordprob , int32 n_word , s3cipid_t *lc ) ;
void lextree_active_swap(lextree_t *lextree ) ;
void lextree_dump(lextree_t *lextree , dict_t *dict , FILE *fp ) ;
void kb_lextree_active_swap(kb_t *kb___0 ) ;
void kb_freehyps(kb_t *kb___0 ) ;
void kb_setlm(char *lmname , kb_t *kb___0 ) ;
void kb_init(kb_t *kb___0 ) 
{ 
  kbcore_t *kbcore___0 ;
  mdef_t *mdef ;
  dict_t *dict ;
  dict2pid_t *d2p ;
  lm_t *lm ;
  lmset_t *lmset ;
  s3cipid_t sil ;
  s3cipid_t ci ;
  s3wid_t w___0 ;
  int32 i ;
  int32 n ;
  int32 n_lc ;
  wordprob_t *wp ;
  s3cipid_t *lc ;
  bitvec_t lc_active ;
  char *str ;
  int32 cisencnt ;
  int32 j ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  void const   *tmp___1 ;
  void const   *tmp___2 ;
  void const   *tmp___3 ;
  void const   *tmp___4 ;
  void const   *tmp___5 ;
  void const   *tmp___6 ;
  void const   *tmp___7 ;
  void const   *tmp___8 ;
  void const   *tmp___9 ;
  void const   *tmp___10 ;
  void const   *tmp___11 ;
  void const   *tmp___12 ;
  void const   *tmp___13 ;
  void const   *tmp___14 ;
  void const   *tmp___15 ;
  void const   *tmp___16 ;
  void const   *tmp___17 ;
  void const   *tmp___18 ;
  void const   *tmp___19 ;
  void const   *tmp___20 ;
  void const   *tmp___21 ;
  void const   *tmp___22 ;
  void const   *tmp___23 ;
  void const   *tmp___24 ;
  void const   *tmp___25 ;
  void const   *tmp___26 ;
  void const   *tmp___27 ;
  int32 tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  int32 tmp___35 ;
  void const   *tmp___36 ;
  void *tmp___37 ;
  void *tmp___38 ;
  void *tmp___39 ;
  void const   *tmp___40 ;
  void const   *tmp___41 ;
  void *tmp___42 ;
  int32 tmp___43 ;
  void *tmp___44 ;
  void const   *tmp___45 ;
  void const   *tmp___46 ;
  void const   *tmp___47 ;
  void const   *tmp___48 ;
  void const   *tmp___49 ;
  void const   *tmp___50 ;
  void const   *tmp___51 ;
  void const   *tmp___52 ;
  void const   *tmp___53 ;
  void const   *tmp___54 ;
  int32 tmp___55 ;
  void const   *tmp___56 ;
  int32 tmp___57 ;
  void const   *tmp___58 ;
  void const   *tmp___59 ;
  void **tmp___60 ;
  void *tmp___61 ;
  void *tmp___62 ;
  float32 ***tmp___63 ;
  void const   *tmp___64 ;
  void const   *tmp___65 ;
  void *tmp___66 ;
  void const   *tmp___67 ;
  FILE *tmp___68 ;
  void const   *tmp___69 ;
  FILE *tmp___70 ;

  {
  tmp___0 = __builtin_object_size((void *)kb___0, 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)kb___0, 0);
    __builtin___memset_chk((void *)kb___0, 0, sizeof(*kb___0), tmp);
  } else {
    __inline_memset_chk((void *)kb___0, 0, sizeof(*kb___0));
  }
  kb___0->kbcore = (kbcore_t *)((void *)0);
  tmp___1 = cmd_ln_access((char *)"-tmatfloor");
  tmp___2 = cmd_ln_access((char *)"-tmat");
  tmp___3 = cmd_ln_access((char *)"-gs");
  tmp___4 = cmd_ln_access((char *)"-subvq");
  tmp___5 = cmd_ln_access((char *)"-mixwfloor");
  tmp___6 = cmd_ln_access((char *)"-mixw");
  tmp___7 = cmd_ln_access((char *)"-varfloor");
  tmp___8 = cmd_ln_access((char *)"-var");
  tmp___9 = cmd_ln_access((char *)"-mean");
  tmp___10 = cmd_ln_access((char *)"-uw");
  tmp___11 = cmd_ln_access((char *)"-wip");
  tmp___12 = cmd_ln_access((char *)"-lw");
  tmp___13 = cmd_ln_access((char *)"-fillprob");
  tmp___14 = cmd_ln_access((char *)"-silprob");
  tmp___15 = cmd_ln_access((char *)"-senmgau");
  tmp___16 = cmd_ln_access((char *)"-fillpen");
  tmp___17 = cmd_ln_access((char *)"-lmdumpdir");
  tmp___18 = cmd_ln_access((char *)"-lmctlfn");
  tmp___19 = cmd_ln_access((char *)"-lm");
  tmp___20 = cmd_ln_access((char *)"-fdict");
  tmp___21 = cmd_ln_access((char *)"-dict");
  tmp___22 = cmd_ln_access((char *)"-mdef");
  tmp___23 = cmd_ln_access((char *)"-agc");
  tmp___24 = cmd_ln_access((char *)"-varnorm");
  tmp___25 = cmd_ln_access((char *)"-cmn");
  tmp___26 = cmd_ln_access((char *)"-feat");
  tmp___27 = cmd_ln_access((char *)"-logbase");
  kb___0->kbcore = kbcore_init((float64 )*((float32 *)tmp___27), (char *)tmp___26,
                               (char *)tmp___25, (char *)tmp___24, (char *)tmp___23,
                               (char *)tmp___22, (char *)tmp___21, (char *)tmp___20,
                               (char *)"", (char *)tmp___19, (char *)tmp___18, (char *)tmp___17,
                               (char *)tmp___16, (char *)tmp___15, (float64 )*((float32 *)tmp___14),
                               (float64 )*((float32 *)tmp___13), (float64 )*((float32 *)tmp___12),
                               (float64 )*((float32 *)tmp___11), (float64 )*((float32 *)tmp___10),
                               (char *)tmp___9, (char *)tmp___8, (float64 )*((float32 *)tmp___7),
                               (char *)tmp___6, (float64 )*((float32 *)tmp___5), (char *)tmp___4,
                               (char *)tmp___3, (char *)tmp___2, (float64 )*((float32 *)tmp___1));
  if ((unsigned long )kb___0->kbcore == (unsigned long )((void *)0)) {
    _E__pr_header("kb.c", 117L, "FATAL_ERROR");
    _E__die_error("Initialization of kb failed\n");
  }
  kbcore___0 = kb___0->kbcore;
  mdef = kbcore___0->mdef;
  dict = kbcore___0->dict;
  lm = kbcore___0->lm;
  lmset = kbcore___0->lmset;
  d2p = kbcore___0->dict2pid;
  if (dict->startwid < 0) {
    _E__pr_header("kb.c", 129L, "FATAL_ERROR");
    _E__die_error("%s or %s not in dictionary\n", "<s>", "</s>");
  } else
  if (dict->finishwid < 0) {
    _E__pr_header("kb.c", 129L, "FATAL_ERROR");
    _E__die_error("%s or %s not in dictionary\n", "<s>", "</s>");
  }
  if (lmset) {
    i = 0;
    while (i < kbcore___0->n_lm) {
      if ((int )((lmset + i)->lm)->startlwid == 65535) {
        _E__pr_header("kb.c", 134L, "FATAL_ERROR");
        _E__die_error("%s or %s not in LM %s\n", "<s>", "</s>", (lmset + i)->name);
      } else
      if ((int )((lmset + i)->lm)->finishlwid == 65535) {
        _E__pr_header("kb.c", 134L, "FATAL_ERROR");
        _E__die_error("%s or %s not in LM %s\n", "<s>", "</s>", (lmset + i)->name);
      }
      i ++;
    }
  } else
  if (lm) {
    if ((int )lm->startlwid == 65535) {
      _E__pr_header("kb.c", 138L, "FATAL_ERROR");
      _E__die_error("%s or %s not in LM\n", "<s>", "</s>");
    } else
    if ((int )lm->finishlwid == 65535) {
      _E__pr_header("kb.c", 138L, "FATAL_ERROR");
      _E__die_error("%s or %s not in LM\n", "<s>", "</s>");
    }
  }
  tmp___28 = tmat_chk_1skip(kbcore___0->tmat);
  if (tmp___28 < 0) {
    _E__pr_header("kb.c", 144L, "FATAL_ERROR");
    _E__die_error("Tmat contains arcs skipping more than 1 state\n");
  }
  if (lmset) {
    i = 0;
    while (i < kbcore___0->n_lm) {
      (((lmset + i)->lm)->ug + ((lmset + i)->lm)->startlwid)->dictwid = -1;
      (((lmset + i)->lm)->ug + ((lmset + i)->lm)->finishlwid)->dictwid = -1;
      w___0 = dict->startwid;
      while (w___0 >= 0) {
        *(((lmset + i)->lm)->dict2lmwid + w___0) = (s3lmwid_t )65535;
        w___0 = (dict->word + w___0)->alt;
      }
      w___0 = dict->finishwid;
      while (w___0 >= 0) {
        *(((lmset + i)->lm)->dict2lmwid + w___0) = (s3lmwid_t )65535;
        w___0 = (dict->word + w___0)->alt;
      }
      i ++;
    }
  } else
  if (lm) {
    (lm->ug + lm->startlwid)->dictwid = -1;
    (lm->ug + lm->finishlwid)->dictwid = -1;
    w___0 = dict->startwid;
    while (w___0 >= 0) {
      *(kbcore___0->dict2lmwid + w___0) = (s3lmwid_t )65535;
      w___0 = (dict->word + w___0)->alt;
    }
    w___0 = dict->finishwid;
    while (w___0 >= 0) {
      *(kbcore___0->dict2lmwid + w___0) = (s3lmwid_t )65535;
      w___0 = (dict->word + w___0)->alt;
    }
  }
  sil = (kbcore___0->mdef)->sil;
  if ((int )sil < 0) {
    _E__pr_header("kb.c", 173L, "FATAL_ERROR");
    _E__die_error("Silence phone \'%s\' not in mdef\n", "SIL");
  }
  tmp___29 = __ckd_calloc__((size_t )mdef->n_sen, sizeof(int32 ), "kb.c", 176);
  kb___0->sen_active = (int32 *)tmp___29;
  tmp___30 = __ckd_calloc__((size_t )mdef->n_sen, sizeof(int32 ), "kb.c", 177);
  kb___0->rec_sen_active = (int32 *)tmp___30;
  tmp___31 = __ckd_calloc__((size_t )mdef->n_sseq, sizeof(int32 ), "kb.c", 178);
  kb___0->ssid_active = (int32 *)tmp___31;
  tmp___32 = __ckd_calloc__((size_t )d2p->n_comsseq, sizeof(int32 ), "kb.c", 179);
  kb___0->comssid_active = (int32 *)tmp___32;
  tmp___33 = __ckd_calloc__((size_t )(mdef->n_ciphone + 1), sizeof(s3cipid_t ), "kb.c",
                            182);
  lc = (s3cipid_t *)tmp___33;
  tmp___34 = __ckd_calloc__((size_t )((mdef->n_ciphone + 31) >> 5), sizeof(uint32 ),
                            "kb.c", 183);
  lc_active = (bitvec_t )tmp___34;
  w___0 = 0;
  while (w___0 < dict->n_word) {
    ci = *((dict->word + w___0)->ciphone + ((dict->word + w___0)->pronlen - 1));
    if (! (mdef->ciphone + (int )ci)->filler) {
      *(lc_active + ((int )ci >> 5)) |= (unsigned int )(1 << ((int )ci & 31));
    }
    w___0 ++;
  }
  ci = mdef->sil;
  *(lc_active + ((int )ci >> 5)) |= (unsigned int )(1 << ((int )ci & 31));
  ci = (s3cipid_t )0;
  n_lc = 0;
  while ((int )ci < mdef->n_ciphone) {
    if (*(lc_active + ((int )ci >> 5)) & (unsigned int )(1 << ((int )ci & 31))) {
      tmp___35 = n_lc;
      n_lc ++;
      *(lc + tmp___35) = ci;
    }
    ci = (s3cipid_t )((int )ci + 1);
  }
  *(lc + n_lc) = (s3cipid_t )-1;
  _E__pr_info_header("kb.c", 197L, "INFO");
  _E__pr_info("Building lextrees\n");
  tmp___36 = cmd_ln_access((char *)"-Nlextree");
  kb___0->n_lextree = *((int32 *)tmp___36);
  if (kb___0->n_lextree < 1) {
    _E__pr_header("kb.c", 201L, "ERROR");
    _E__pr_warn("No. of ugtrees specified: %d; will instantiate 1 ugtree\n", kb___0->n_lextree);
    kb___0->n_lextree = 1;
  }
  tmp___37 = __ckd_calloc__((size_t )dict->n_word, sizeof(wordprob_t ), "kb.c", 208);
  wp = (wordprob_t *)tmp___37;
  if (lmset) {
    tmp___38 = __ckd_calloc__((size_t )(kbcore___0->n_lm * kb___0->n_lextree), sizeof(lextree_t *),
                              "kb.c", 212);
    kb___0->ugtreeMulti = (lextree_t **)tmp___38;
    tmp___39 = __ckd_calloc__((size_t )kb___0->n_lextree, sizeof(lextree_t *), "kb.c",
                              214);
    kb___0->ugtree = (lextree_t **)tmp___39;
    i = 0;
    while (i < kbcore___0->n_lm) {
      _E__pr_info_header("kb.c", 217L, "INFO");
      _E__pr_info("Creating Unigram Table for lm %d name %s\n", i, (lmset + i)->name);
      n = 0;
      j = 0;
      while (j < dict->n_word) {
        (wp + j)->wid = -1;
        (wp + j)->prob = -1;
        j ++;
      }
      n = lm_ug_wordprob((lmset + i)->lm, dict, (int32 )2147483648U, wp);
      _E__pr_info_header("kb.c", 224L, "INFO");
      _E__pr_info("Size of word table after unigram + words in class: %d.\n", n);
      if (n < 1) {
        _E__pr_header("kb.c", 226L, "FATAL_ERROR");
        _E__die_error("%d active words in %s\n", n, (lmset + i)->name);
      }
      n = wid_wordprob2alt(dict, wp, n);
      _E__pr_info_header("kb.c", 228L, "INFO");
      _E__pr_info("Size of word table after adding alternative prons: %d.\n", n);
      tmp___40 = cmd_ln_access((char *)"-treeugprob");
      if (*((int32 *)tmp___40) == 0) {
        i = 0;
        while (i < n) {
          (wp + i)->prob = -1;
          i ++;
        }
      }
      j = 0;
      while (j < kb___0->n_lextree) {
        *(kb___0->ugtreeMulti + (i * kb___0->n_lextree + j)) = lextree_build(kbcore___0,
                                                                             wp, n,
                                                                             lc);
        (*(kb___0->ugtreeMulti + (i * kb___0->n_lextree + j)))->type = 0;
        _E__pr_info_header("kb.c", 237L, "INFO");
        _E__pr_info("Lextrees (%d) for lm %d name %s, %d nodes(ug)\n", kb___0->n_lextree,
                    i, (lmset + i)->name, (*(kb___0->ugtreeMulti + (i * kb___0->n_lextree + j)))->n_node);
        j ++;
      }
      i ++;
    }
  } else
  if (lm) {
    _E__pr_info_header("kb.c", 243L, "INFO");
    _E__pr_info("Creating Unigram Table\n");
    n = 0;
    n = lm_ug_wordprob(lm, dict, (int32 )2147483648U, wp);
    _E__pr_info_header("kb.c", 246L, "INFO");
    _E__pr_info("Size of word table after unigram + words in class: %d\n", n);
    if (n < 1) {
      _E__pr_header("kb.c", 248L, "FATAL_ERROR");
      _E__die_error("%d active words\n", n);
    }
    n = wid_wordprob2alt(dict, wp, n);
    tmp___41 = cmd_ln_access((char *)"-treeugprob");
    if (*((int32 *)tmp___41) == 0) {
      i = 0;
      while (i < n) {
        (wp + i)->prob = -1;
        i ++;
      }
    }
    tmp___42 = __ckd_calloc__((size_t )kb___0->n_lextree, sizeof(lextree_t *), "kb.c",
                              258);
    kb___0->ugtree = (lextree_t **)tmp___42;
    i = 0;
    while (i < kb___0->n_lextree) {
      *(kb___0->ugtree + i) = lextree_build(kbcore___0, wp, n, lc);
      (*(kb___0->ugtree + i))->type = 0;
      i ++;
    }
    _E__pr_info_header("kb.c", 263L, "INFO");
    _E__pr_info("Lextrees(%d), %d nodes(ug)\n", kb___0->n_lextree, (*(kb___0->ugtree + 0))->n_node);
  }
  n = 0;
  i = dict->filler_start;
  while (i <= dict->filler_end) {
    tmp___43 = dict_filler_word(dict, i);
    if (tmp___43) {
      (wp + n)->wid = i;
      (wp + n)->prob = fillpen(kbcore___0->fillpen, i);
      n ++;
    }
    i ++;
  }
  tmp___44 = __ckd_calloc__((size_t )kb___0->n_lextree, sizeof(lextree_t *), "kb.c",
                            281);
  kb___0->fillertree = (lextree_t **)tmp___44;
  i = 0;
  while (i < kb___0->n_lextree) {
    *(kb___0->fillertree + i) = lextree_build(kbcore___0, wp, n, (s3cipid_t *)((void *)0));
    (*(kb___0->fillertree + i))->type = -1;
    i ++;
  }
  ckd_free((void *)wp);
  ckd_free((void *)lc);
  ckd_free((void *)((char *)lc_active));
  _E__pr_info_header("kb.c", 291L, "INFO");
  _E__pr_info("Lextrees(%d), %d nodes(filler)\n", kb___0->n_lextree, (*(kb___0->fillertree + 0))->n_node);
  tmp___45 = cmd_ln_access((char *)"-lextreedump");
  if (*((int32 *)tmp___45)) {
    if (lmset) {
      _E__pr_header("kb.c", 298L, "FATAL_ERROR");
      _E__die_error("Currently, doesn\'t support -lextreedump for multiple-LMs\n");
    }
    i = 0;
    while (i < kb___0->n_lextree) {
      fprintf(__stderrp, "UGTREE %d\n", i);
      lextree_dump(*(kb___0->ugtree + i), dict, __stderrp);
      i ++;
    }
    i = 0;
    while (i < kb___0->n_lextree) {
      fprintf(__stderrp, "FILLERTREE %d\n", i);
      lextree_dump(*(kb___0->fillertree + i), dict, __stderrp);
      i ++;
    }
    fflush(__stderrp);
  }
  kb___0->ascr = ascr_init((kbcore___0->mgau)->n_mgau, (kbcore___0->dict2pid)->n_comstate);
  tmp___46 = cmd_ln_access((char *)"-wbeam");
  tmp___47 = cmd_ln_access((char *)"-pbeam");
  tmp___48 = cmd_ln_access((char *)"-beam");
  tmp___49 = cmd_ln_access((char *)"-subvqbeam");
  kb___0->beam = beam_init(*((float64 *)tmp___49), *((float64 *)tmp___48), *((float64 *)tmp___47),
                           *((float64 *)tmp___46));
  _E__pr_info_header("kb.c", 317L, "INFO");
  _E__pr_info("Beam= %d, PBeam= %d, WBeam= %d, SVQBeam= %d\n", (kb___0->beam)->hmm,
              (kb___0->beam)->ptrans, (kb___0->beam)->word, (kb___0->beam)->subvq);
  tmp___50 = cmd_ln_access((char *)"-ds");
  kb___0->ds_ratio = *((int32 *)tmp___50);
  _E__pr_info_header("kb.c", 322L, "INFO");
  _E__pr_info("Down Sampling Ratio = %d\n", kb___0->ds_ratio);
  kb___0->rec_bstcid = -1;
  kb___0->skip_count = 0;
  tmp___51 = cmd_ln_access((char *)"-cond_ds");
  kb___0->cond_ds = *((int32 *)tmp___51);
  _E__pr_info_header("kb.c", 328L, "INFO");
  _E__pr_info("Conditional Down Sampling Parameter = %d\n", kb___0->cond_ds);
  if (kb___0->cond_ds > 0) {
    if ((unsigned long )(kb___0->kbcore)->gs == (unsigned long )((void *)0)) {
      _E__pr_header("kb.c", 330L, "FATAL_ERROR");
      _E__die_error("Conditional Down Sampling require the use of Gaussian Selection map\n");
    }
  }
  tmp___52 = cmd_ln_access((char *)"-gs4gs");
  kb___0->gs4gs = *((int32 *)tmp___52);
  _E__pr_info_header("kb.c", 333L, "INFO");
  _E__pr_info("GS map would be used for Gaussian Selection? = %d\n", kb___0->gs4gs);
  tmp___53 = cmd_ln_access((char *)"-svq4svq");
  kb___0->svq4svq = *((int32 *)tmp___53);
  _E__pr_info_header("kb.c", 336L, "INFO");
  _E__pr_info("SVQ would be used as Gaussian Score ?= %d\n", kb___0->svq4svq);
  tmp___54 = cmd_ln_access((char *)"-ci_pbeam");
  tmp___55 = logs3((float64 )*((float32 *)tmp___54));
  kb___0->ci_pbeam = -1 * tmp___55;
  _E__pr_info_header("kb.c", 339L, "INFO");
  _E__pr_info("CI phone beam to prune the number of parent CI phones in CI-base GMM Selection = %d\n",
              kb___0->ci_pbeam);
  if (kb___0->ci_pbeam > 10000000) {
    _E__pr_info_header("kb.c", 341L, "INFO");
    _E__pr_info("Virtually no CI phone beam is applied now. (ci_pbeam>1000000)\n");
  }
  tmp___56 = cmd_ln_access((char *)"-wend_beam");
  tmp___57 = logs3((float64 )*((float32 *)tmp___56));
  kb___0->wend_beam = -1 * tmp___57;
  _E__pr_info_header("kb.c", 345L, "INFO");
  _E__pr_info("Word-end pruning beam: %d\n", kb___0->wend_beam);
  tmp___58 = cmd_ln_access((char *)"-pl_window");
  kb___0->pl_window = *((int32 *)tmp___58);
  _E__pr_info_header("kb.c", 348L, "INFO");
  _E__pr_info("Phoneme look-ahead window size = %d\n", kb___0->pl_window);
  kb___0->pl_window_start = 0;
  tmp___59 = cmd_ln_access((char *)"-pl_beam");
  kb___0->pl_beam = logs3((float64 )*((float32 *)tmp___59));
  _E__pr_info_header("kb.c", 353L, "INFO");
  _E__pr_info("Phoneme look-ahead beam = %d\n", kb___0->pl_beam);
  cisencnt = 0;
  while (cisencnt == (int32 )*(mdef->cd2cisen + cisencnt)) {
    cisencnt ++;
  }
  tmp___60 = __ckd_calloc_2d__(kb___0->pl_window, cisencnt, (int32 )sizeof(int32 ),
                               "kb.c", 358);
  kb___0->cache_ci_senscr = (int32 **)tmp___60;
  tmp___61 = __ckd_calloc__((size_t )kb___0->pl_window, sizeof(int32 ), "kb.c", 359);
  kb___0->cache_best_list = (int32 *)tmp___61;
  tmp___62 = __ckd_calloc__((size_t )mdef->n_ciphone, sizeof(int32 ), "kb.c", 360);
  kb___0->phn_heur_list = (int32 *)tmp___62;
  tmp___63 = feat_array_alloc(kbcore___0->fcb, 15000);
  kb___0->feat = tmp___63;
  if ((unsigned long )tmp___63 == (unsigned long )((void *)0)) {
    _E__pr_header("kb.c", 364L, "FATAL_ERROR");
    _E__die_error("feat_array_alloc() failed\n");
  }
  tmp___64 = cmd_ln_access((char *)"-bghist");
  kb___0->vithist = vithist_init(kbcore___0, (kb___0->beam)->word, *((int32 *)tmp___64));
  ptmr_init(& kb___0->tm_sen);
  ptmr_init(& kb___0->tm_srch);
  ptmr_init(& kb___0->tm_ovrhd);
  kb___0->tot_fr = 0;
  kb___0->tot_sen_eval = 0.0;
  kb___0->tot_gau_eval = 0.0;
  kb___0->tot_hmm_eval = 0.0;
  kb___0->tot_wd_exit = 0.0;
  tmp___65 = cmd_ln_access((char *)"-hmmhistbinsize");
  kb___0->hmm_hist_binsize = *((int32 *)tmp___65);
  if (lmset) {
    n = ((*(kb___0->ugtreeMulti + 0))->n_node + (*(kb___0->fillertree + 0))->n_node) * kb___0->n_lextree;
  } else {
    n = ((*(kb___0->ugtree + 0))->n_node + (*(kb___0->fillertree + 0))->n_node) * kb___0->n_lextree;
  }
  n /= kb___0->hmm_hist_binsize;
  kb___0->hmm_hist_bins = n + 1;
  tmp___66 = __ckd_calloc__((size_t )(n + 1), sizeof(int32 ), "kb.c", 386);
  kb___0->hmm_hist = (int32 *)tmp___66;
  tmp___67 = cmd_ln_access((char *)"-hypseg");
  str = (char *)tmp___67;
  kb___0->matchsegfp = (FILE *)((void *)0);
  if (str) {
    tmp___68 = fopen((char const   *)str, "w");
    kb___0->matchsegfp = tmp___68;
    if ((unsigned long )tmp___68 == (unsigned long )((void *)0)) {
      _E__pr_header("kb.c", 397L, "ERROR");
      _E__pr_warn("fopen(%s,w) failed; use FWDXCT: from std logfile\n", str);
    }
  }
  tmp___69 = cmd_ln_access((char *)"-hyp");
  str = (char *)tmp___69;
  kb___0->matchfp = (FILE *)((void *)0);
  if (str) {
    tmp___70 = fopen((char const   *)str, "w");
    kb___0->matchfp = tmp___70;
    if ((unsigned long )tmp___70 == (unsigned long )((void *)0)) {
      _E__pr_header("kb.c", 408L, "ERROR");
      _E__pr_warn("fopen(%s,w) failed; use FWDXCT: from std logfile\n", str);
    }
  }
  return;
}
}
void kb_setlm(char *lmname , kb_t *kb___0 ) 
{ 
  lmset_t *lms ;
  kbcore_t *kbc ;
  int i ;
  int j ;
  int n ;
  int tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
  kbc = (kbcore_t *)((void *)0);
  kbc = kb___0->kbcore;
  lms = kbc->lmset;
  _E__pr_info_header("kb.c", 424L, "INFO");
  _E__pr_info("Inside kb_setlm\n");
  kbc->lm = (lm_t *)((void *)0);
  j = 0;
  while (j < kb___0->n_lextree) {
    *(kb___0->ugtree + j) = (lextree_t *)((void *)0);
    j ++;
  }
  _E__pr_info_header("kb.c", 430L, "INFO");
  _E__pr_info("Inside kb_setlm\n");
  if ((unsigned long )lms != (unsigned long )((void *)0)) {
    goto _L;
  } else {
    tmp___0 = cmd_ln_access((char *)"-lmctlfn");
    if ((char *)tmp___0) {
      _L: /* CIL Label */ 
      i = 0;
      while (i < kbc->n_lm) {
        tmp = strcmp((char const   *)lmname, (char const   *)(lms + i)->name);
        if (! tmp) {
          kbc->lm = (lms + i)->lm;
          j = 0;
          while (j < kb___0->n_lextree) {
            *(kb___0->ugtree + j) = *(kb___0->ugtreeMulti + (i * kb___0->n_lextree + j));
            j ++;
          }
          break;
        }
        i ++;
      }
      if ((unsigned long )kbc->lm == (unsigned long )((void *)0)) {
        _E__pr_header("kb.c", 445L, "ERROR");
        _E__pr_warn("LM name %s cannot be found! Fall back to use base LM model\n",
                    lmname);
        kbc->lm = (lms + 0)->lm;
        j = 0;
        while (j < kb___0->n_lextree) {
          *(kb___0->ugtree + j) = *(kb___0->ugtreeMulti + j);
          j ++;
        }
      }
    }
  }
  _E__pr_info_header("kb.c", 453L, "INFO");
  _E__pr_info("Current LM name %s.\n", (lms + i)->name);
  n = ((*(kb___0->ugtree + 0))->n_node + (*(kb___0->fillertree + 0))->n_node) * kb___0->n_lextree;
  n /= kb___0->hmm_hist_binsize;
  kb___0->hmm_hist_bins = n + 1;
  tmp___1 = __ckd_realloc__((void *)kb___0->hmm_hist, (unsigned long )(n + 1) * sizeof(int32 ),
                            "kb.c", 466);
  kb___0->hmm_hist = (int32 *)tmp___1;
  _E__pr_info_header("kb.c", 468L, "INFO");
  _E__pr_info("Current LM name %s\n", (lms + i)->name);
  _E__pr_info_header("kb.c", 469L, "INFO");
  _E__pr_info("LM ug size %d\n", (kbc->lm)->n_ug);
  _E__pr_info_header("kb.c", 470L, "INFO");
  _E__pr_info("LM bg size %d\n", (kbc->lm)->n_bg);
  _E__pr_info_header("kb.c", 471L, "INFO");
  _E__pr_info("LM tg size %d\n", (kbc->lm)->n_tg);
  _E__pr_info_header("kb.c", 472L, "INFO");
  _E__pr_info("HMM history bin size %d\n", n + 1);
  j = 0;
  while (j < kb___0->n_lextree) {
    _E__pr_info_header("kb.c", 475L, "INFO");
    _E__pr_info("Lextrees(%d), %d nodes(ug)\n", kb___0->n_lextree, (*(kb___0->ugtree + j))->n_node);
    j ++;
  }
  return;
}
}
void kb_lextree_active_swap(kb_t *kb___0 ) 
{ 
  int32 i ;

  {
  i = 0;
  while (i < kb___0->n_lextree) {
    lextree_active_swap(*(kb___0->ugtree + i));
    lextree_active_swap(*(kb___0->fillertree + i));
    i ++;
  }
  return;
}
}
void kb_freehyps(kb_t *kb___0 ) 
{ 
  int i ;

  {
  i = 0;
  if (kb___0->hyp_segs) {
    while (i < kb___0->hyp_seglen) {
      if (*(kb___0->hyp_segs + i)) {
        ckd_free((void *)*(kb___0->hyp_segs + i));
      }
      i ++;
    }
    ckd_free((void *)kb___0->hyp_segs);
    kb___0->hyp_seglen = 0;
  }
  if (kb___0->hyp_str) {
    ckd_free((void *)kb___0->hyp_str);
    kb___0->hyp_strlen = 0;
  }
  return;
}
}
void kb_free(kb_t *kb___0 ) 
{ 
  vithist_t *vithist ;

  {
  vithist = kb___0->vithist;
  if (kb___0->sen_active) {
    ckd_free((void *)kb___0->sen_active);
  }
  if (kb___0->ssid_active) {
    ckd_free((void *)kb___0->ssid_active);
  }
  if (kb___0->comssid_active) {
    ckd_free((void *)kb___0->comssid_active);
  }
  if (kb___0->fillertree) {
    ckd_free((void *)kb___0->fillertree);
  }
  if (kb___0->hmm_hist) {
    ckd_free((void *)kb___0->hmm_hist);
  }
  if (vithist) {
    ckd_free((void *)vithist->entry);
    ckd_free((void *)vithist->frame_start);
    ckd_free((void *)vithist->bestscore);
    ckd_free((void *)vithist->bestvh);
    ckd_free((void *)vithist->lms2vh_root);
    ckd_free((void *)kb___0->vithist);
  }
  kbcore_free(kb___0->kbcore);
  if (kb___0->feat) {
    ckd_free((void *)*(*(kb___0->feat + 0) + 0));
    ckd_free_2d((void **)kb___0->feat);
  }
  if (kb___0->cache_ci_senscr) {
    ckd_free_2d((void **)kb___0->cache_ci_senscr);
  }
  if (kb___0->cache_best_list) {
    ckd_free((void *)kb___0->cache_best_list);
  }
  if (kb___0->phn_heur_list) {
    ckd_free((void *)kb___0->phn_heur_list);
  }
  if (kb___0->matchsegfp) {
    fclose(kb___0->matchsegfp);
  }
  if (kb___0->matchfp) {
    fclose(kb___0->matchfp);
  }
  kb_freehyps(kb___0);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-ZqcB_g1N.i","-O3")
mdef_t *mdef_init(char *mdeffile ) ;
void mdef_free(mdef_t *m ) ;
lm_t *lm_read(char *file , float64 lw , float64 wip , float64 uw ) ;
lmset_t *lm_read_ctl(char *ctlfile , dict_t *dict , float64 lw , float64 wip , float64 uw ,
                     char *lmdumpdir , int32 *n_lm , int32 *n_alloclm , int32 dict_size ) ;
void lm_free(lm_t *lm ) ;
s3lmwid_t *wid_dict_lm_map(dict_t *dict , lm_t *lm , int32 lw ) ;
tmat_t *tmat_init(char *file_name , float64 tpfloor ) ;
void tmat_free(tmat_t *t ) ;
int32 logs3_init(float64 base ) ;
void logs_free(void) ;
subvq_t *subvq_init(char *file , float64 varfloor , int32 max_sv , mgau_model_t *g ) ;
void subvq_free(subvq_t *s___0 ) ;
kbcore_t *kbcore_init(float64 logbase , char *feattype , char *cmn___0 , char *varnorm ,
                      char *agc , char *mdeffile , char *dictfile , char *fdictfile ,
                      char *compsep , char *lmfile , char *lmctlfile , char *lmdumpdir ,
                      char *fillpenfile , char *senmgau , float64 silprob , float64 fillprob ,
                      float64 langwt , float64 inspen , float64 uw , char *meanfile ,
                      char *varfile , float64 varfloor , char *mixwfile , float64 mixwfloor ,
                      char *subvqfile , char *gsfile , char *tmatfile , float64 tmatfloor ) 
{ 
  kbcore_t *kb___0 ;
  int i ;
  void *tmp ;
  feat_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  mdef_t *tmp___3 ;
  char const   *tmp___4 ;
  dict_t *tmp___5 ;
  lm_t *tmp___6 ;
  fillpen_t *tmp___7 ;
  s3lmwid_t *tmp___8 ;
  s3lmwid_t *tmp___9 ;
  subvq_t *tmp___10 ;
  gs_t *tmp___11 ;
  tmat_t *tmp___12 ;

  {
  _E__pr_info_header("kbcore.c", 95L, "INFO");
  _E__pr_info("Initializing core models:\n");
  tmp = __ckd_calloc__((size_t )1, sizeof(kbcore_t ), "kbcore.c", 97);
  kb___0 = (kbcore_t *)tmp;
  kb___0->fcb = (feat_t *)((void *)0);
  kb___0->mdef = (mdef_t *)((void *)0);
  kb___0->dict = (dict_t *)((void *)0);
  kb___0->dict2pid = (dict2pid_t *)((void *)0);
  kb___0->lm = (lm_t *)((void *)0);
  kb___0->fillpen = (fillpen_t *)((void *)0);
  kb___0->dict2lmwid = (s3lmwid_t *)((void *)0);
  kb___0->mgau = (mgau_model_t *)((void *)0);
  kb___0->svq = (subvq_t *)((void *)0);
  kb___0->tmat = (tmat_t *)((void *)0);
  kb___0->n_lm = 0;
  kb___0->n_alloclm = 0;
  logs3_init(logbase);
  if (! feattype) {
    _E__pr_header("kbcore.c", 115L, "FATAL_ERROR");
    _E__die_error("Please specified the feature type\n");
  }
  if (feattype) {
    tmp___0 = feat_init(feattype, cmn___0, varnorm, agc);
    kb___0->fcb = tmp___0;
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      _E__pr_header("kbcore.c", 119L, "FATAL_ERROR");
      _E__die_error("feat_init(%s) failed\n", feattype);
    }
    tmp___2 = strcmp((char const   *)senmgau, ".cont.");
    if (tmp___2 == 0) {
      if ((kb___0->fcb)->n_stream != 1) {
        _E__pr_header("kbcore.c", 123L, "FATAL_ERROR");
        _E__die_error("#Feature streams(%d) in the feature for continuous HMM!= 1\n",
                      (kb___0->fcb)->n_stream);
      }
    } else {
      tmp___1 = strcmp((char const   *)senmgau, ".semi.");
      if (tmp___1 == 0) {
        if ((kb___0->fcb)->n_stream != 4) {
          _E__pr_header("kbcore.c", 126L, "FATAL_ERROR");
          _E__die_error("#Feature streams(%d) in the feature for semi-continuous HMM!= 4\n",
                        (kb___0->fcb)->n_stream);
        }
      } else {
        _E__pr_header("kbcore.c", 128L, "FATAL_ERROR");
        _E__die_error("Feature should be either .semi. or .cont.");
      }
    }
  }
  if (mdeffile) {
    tmp___3 = mdef_init(mdeffile);
    kb___0->mdef = tmp___3;
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      _E__pr_header("kbcore.c", 134L, "FATAL_ERROR");
      _E__die_error("mdef_init(%s) failed\n", mdeffile);
    }
  }
  if (dictfile) {
    if (! compsep) {
      compsep = (char *)"";
    } else
    if ((int )*(compsep + 0) != 0) {
      if ((int )*(compsep + 1) != 0) {
        _E__pr_header("kbcore.c", 141L, "FATAL_ERROR");
        _E__die_error("Compound word separator(%s) must be empty or single character string\n",
                      compsep);
      }
    }
    tmp___5 = dict_init(kb___0->mdef, dictfile, fdictfile, *(compsep + 0));
    kb___0->dict = tmp___5;
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
      _E__pr_header("kbcore.c", 145L, "FATAL_ERROR");
      if (fdictfile) {
        tmp___4 = (char const   *)fdictfile;
      } else {
        tmp___4 = "";
      }
      _E__die_error("dict_init(%s,%s,%s) failed\n", dictfile, tmp___4, compsep);
    }
  }
  if (lmfile) {
    if (lmctlfile) {
      _E__pr_header("kbcore.c", 151L, "FATAL_ERROR");
      _E__die_error("Please only specify either -lmfile or -lmctlfile\n");
    }
  }
  if (! lmfile) {
    if (! lmctlfile) {
      _E__pr_header("kbcore.c", 154L, "FATAL_ERROR");
      _E__die_error("Please specify either one of -lmfile or -lmctlfile\n");
    }
  }
  if (lmfile) {
    tmp___6 = lm_read(lmfile, langwt, inspen, uw);
    kb___0->lm = tmp___6;
    if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
      _E__pr_header("kbcore.c", 158L, "FATAL_ERROR");
      _E__die_error("lm_read(%s, %e, %e, %e) failed\n", lmfile, langwt, inspen, uw);
    }
  }
  if (lmctlfile) {
    _E__pr_info_header("kbcore.c", 162L, "INFO");
    _E__pr_info("Reading LM ctl file\n");
    kb___0->lmset = lm_read_ctl(lmctlfile, kb___0->dict, langwt, uw, inspen, lmdumpdir,
                                & kb___0->n_lm, & kb___0->n_alloclm, (kb___0->dict)->n_word);
    _E__pr_info_header("kbcore.c", 165L, "INFO");
    _E__pr_info("kb->lmset[0].name %s\n", (kb___0->lmset + 0)->name);
    if ((unsigned long )kb___0->lmset == (unsigned long )((void *)0)) {
      _E__pr_header("kbcore.c", 167L, "FATAL_ERROR");
      _E__die_error("lm_read_ctl(%s,%e,%e,%e) failed\n:", lmctlfile, langwt, inspen,
                    uw);
    }
  }
  if (fillpenfile) {
    goto _L;
  } else
  if (lmfile) {
    if (kb___0->dict) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (lmctlfile) {
    if (kb___0->dict) {
      _L: /* CIL Label */ 
      if (! kb___0->dict) {
        _E__pr_header("kbcore.c", 173L, "FATAL_ERROR");
        _E__die_error("No dictionary for associating filler penalty file(%s)\n", fillpenfile);
      }
      tmp___7 = fillpen_init(kb___0->dict, fillpenfile, silprob, fillprob, langwt,
                             inspen);
      kb___0->fillpen = tmp___7;
      if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
        _E__pr_header("kbcore.c", 177L, "FATAL_ERROR");
        _E__die_error("fillpen_init(%s) failed\n", fillpenfile);
      }
    }
  }
  if (kb___0->dict) {
    if (kb___0->lm) {
      tmp___8 = wid_dict_lm_map(kb___0->dict, kb___0->lm, (int32 )langwt);
      kb___0->dict2lmwid = tmp___8;
      if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
        _E__pr_header("kbcore.c", 184L, "FATAL_ERROR");
        _E__die_error("Dict/LM word-id mapping failed\n");
      }
    }
  }
  if (kb___0->dict) {
    if (kb___0->lmset) {
      i = 0;
      while (i < kb___0->n_lm) {
        tmp___9 = wid_dict_lm_map(kb___0->dict, (kb___0->lmset + i)->lm, (int32 )langwt);
        ((kb___0->lmset + i)->lm)->dict2lmwid = tmp___9;
        if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
          _E__pr_header("kbcore.c", 189L, "FATAL_ERROR");
          _E__die_error("Dict/LM word-id mapping failed for LM index %d, named %s\n",
                        i, (kb___0->lmset + i)->name);
        }
        i ++;
      }
    }
  }
  if (meanfile) {
    if (! varfile) {
      _E__pr_header("kbcore.c", 194L, "FATAL_ERROR");
      _E__die_error("Varfile or mixwfile not specified along with meanfile(%s)\n",
                    meanfile);
    } else
    if (! mixwfile) {
      _E__pr_header("kbcore.c", 194L, "FATAL_ERROR");
      _E__die_error("Varfile or mixwfile not specified along with meanfile(%s)\n",
                    meanfile);
    }
    kb___0->mgau = mgau_init(meanfile, varfile, varfloor, mixwfile, mixwfloor, 1,
                             senmgau);
    if ((unsigned long )kb___0->mgau == (unsigned long )((void *)0)) {
      _E__pr_header("kbcore.c", 197L, "FATAL_ERROR");
      _E__die_error("gauden_init(%s, %s, %e) failed\n", meanfile, varfile, varfloor);
    }
    if (subvqfile) {
      tmp___10 = subvq_init(subvqfile, varfloor, -1, kb___0->mgau);
      kb___0->svq = tmp___10;
      if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
        _E__pr_header("kbcore.c", 201L, "FATAL_ERROR");
        _E__die_error("subvq_init (%s, %e, -1) failed\n", subvqfile, varfloor);
      }
    }
    if (gsfile) {
      tmp___11 = gs_read(gsfile);
      kb___0->gs = tmp___11;
      if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
        _E__pr_header("kbcore.c", 207L, "FATAL_ERROR");
        _E__die_error("gs_read(%s) failed\n", gsfile);
      }
      _E__pr_info_header("kbcore.c", 209L, "INFO");
      _E__pr_info("After reading the number of senones: %d\n", (kb___0->gs)->n_mgau);
    }
  }
  if (tmatfile) {
    tmp___12 = tmat_init(tmatfile, tmatfloor);
    kb___0->tmat = tmp___12;
    if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
      _E__pr_header("kbcore.c", 216L, "FATAL_ERROR");
      _E__die_error("tmat_init (%s, %e) failed\n", tmatfile, tmatfloor);
    }
  }
  if (kb___0->mdef) {
    if (kb___0->dict) {
      kb___0->dict2pid = dict2pid_build(kb___0->mdef, kb___0->dict);
    }
  }
  _E__pr_info_header("kbcore.c", 225L, "INFO");
  _E__pr_info("Verifying models consistency:\n");
  if (kb___0->fcb) {
    if (kb___0->mgau) {
      if (*((kb___0->fcb)->stream_len + 0) != (kb___0->mgau)->veclen) {
        _E__pr_header("kbcore.c", 230L, "FATAL_ERROR");
        _E__die_error("Feature streamlen(%d) != mgau streamlen(%d)\n", *((kb___0->fcb)->stream_len + 0),
                      (kb___0->mgau)->veclen);
      }
    }
  }
  if (kb___0->mdef) {
    if (kb___0->mgau) {
      if ((kb___0->mdef)->n_sen != (kb___0->mgau)->n_mgau) {
        _E__pr_header("kbcore.c", 237L, "FATAL_ERROR");
        _E__die_error("Mdef #senones(%d) != mgau #senones(%d)\n", (kb___0->mdef)->n_sen,
                      (kb___0->mgau)->n_mgau);
      }
    }
  }
  if (kb___0->mdef) {
    if (kb___0->tmat) {
      if ((kb___0->mdef)->n_tmat != (kb___0->tmat)->n_tmat) {
        _E__pr_header("kbcore.c", 244L, "FATAL_ERROR");
        _E__die_error("Mdef #tmat(%d) != tmatfile(%d)\n", (kb___0->mdef)->n_tmat,
                      (kb___0->tmat)->n_tmat);
      }
      if ((kb___0->mdef)->n_emit_state != (kb___0->tmat)->n_state) {
        _E__pr_header("kbcore.c", 246L, "FATAL_ERROR");
        _E__die_error("Mdef #states(%d) != tmat #states(%d)\n", (kb___0->mdef)->n_emit_state,
                      (kb___0->tmat)->n_state);
      }
    }
  }
  return (kb___0);
}
}
void kbcore_free(kbcore_t *kbcore___0 ) 
{ 
  feat_t *fcb ;
  mdef_t *mdef ;
  dict_t *dict ;
  dict2pid_t *dict2pid ;
  lm_t *lm ;

  {
  fcb = kbcore___0->fcb;
  mdef = kbcore___0->mdef;
  dict = kbcore___0->dict;
  dict2pid = kbcore___0->dict2pid;
  lm = kbcore___0->lm;
  lm_free(lm);
  dict_free(dict);
  ckd_free((void *)dict2pid->comwt);
  ckd_free((void *)dict2pid->comsseq);
  ckd_free((void *)dict2pid->comstate);
  ckd_free_2d((void **)((void *)dict2pid->single_lc));
  ckd_free_3d((void ***)dict2pid->ldiph_lc);
  ckd_free((void *)dict2pid->internal);
  mdef_free(mdef);
  fillpen_free(kbcore___0->fillpen);
  tmat_free(kbcore___0->tmat);
  subvq_free(kbcore___0->svq);
  mgau_free(kbcore___0->mgau);
  if (fcb) {
    ckd_free((void *)fcb->name);
    ckd_free((void *)fcb->stream_len);
    ckd_free((void *)fcb);
  }
  logs_free();
  feat_free(kbcore___0->fcb);
  ckd_free((void *)kbcore___0);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-c3SATjWB.i","-O3")
void vithist_rescore(vithist_t *vh , kbcore_t *kbc , s3wid_t wid , int32 ef , int32 score ,
                     int32 pred , int32 type ) ;
void lextree_free(lextree_t *lextree ) ;
void lextree_utt_end(lextree_t *l , kbcore_t *kbc ) ;
void lextree_enter(lextree_t *lextree , s3cipid_t lc , int32 cf , int32 inscore ,
                   int32 inhist , int32 thresh ) ;
void lextree_ssid_active(lextree_t *lextree , int32 *ssid , int32 *comssid ) ;
void lextree_ci_active(lextree_t *lextree , bitvec_t ci_active ) ;
int32 lextree_hmm_eval(lextree_t *lextree , kbcore_t *kbc , ascr_t *ascr , int32 frm ,
                       FILE *fp ) ;
void lextree_hmm_propagate(lextree_t *lextree , kbcore_t *kbc , vithist_t *vh , int32 cf ,
                           int32 th , int32 pth , int32 wth , int32 *phn_heur_list ,
                           int32 heur_beam , int32 heur_type ) ;
void lextree_hmm_histbin(lextree_t *lextree , int32 bestscr , int32 *bin , int32 nbin ,
                         int32 bw ) ;
static lextree_node_t *lextree_node_alloc(int32 wid , int32 prob , int32 comp , int32 ssid ,
                                          int32 n_state , int32 ci ) 
{ 
  lextree_node_t *ln ;
  char *tmp ;
  void *tmp___0 ;

  {
  tmp = __mymalloc__((int32 )sizeof(lextree_node_t ), (char *)"lextree.c", 76);
  ln = (lextree_node_t *)tmp;
  ln->children = (glist_t )((void *)0);
  ln->wid = wid;
  ln->prob = prob;
  ln->ssid = ssid;
  ln->ci = (s3cipid_t )ci;
  ln->composite = (int8 )comp;
  ln->frame = (s3frmid_t )-1;
  tmp___0 = __ckd_calloc__((size_t )n_state, sizeof(hmm_state_t ), "lextree.c", 84);
  ln->hmm.state = (hmm_state_t *)tmp___0;
  hmm_clear(& ln->hmm, n_state);
  return (ln);
}
}
lextree_t *lextree_build(kbcore_t *kbc , wordprob_t *wordprob , int32 n_word , s3cipid_t *lc ) 
{ 
  mdef_t *mdef ;
  dict_t *dict ;
  tmat_t *tmat ;
  dict2pid_t *d2p ;
  s3ssid_t *ldiph_lc ;
  lextree_t *lextree ;
  lextree_lcroot_t *lcroot ;
  int32 n_lc ;
  int32 n_node ;
  int32 n_ci ;
  int32 n_sseq ;
  int32 pronlen ;
  int32 ssid ;
  int32 prob ;
  int32 ci ;
  int32 rc ;
  int32 wid ;
  int32 np ;
  int32 n_st ;
  lextree_node_t *ln ;
  lextree_node_t **parent ;
  lextree_node_t **ssid2ln ;
  gnode_t *gn ;
  bitvec_t *ssid_lc ;
  int32 i ;
  int32 j ;
  int32 k___0 ;
  int32 p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int32 tmp___6 ;
  int32 tmp___7 ;
  int32 tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  ln = (lextree_node_t *)0;
  gn = (gnode_t *)0;
  mdef = kbc->mdef;
  dict = kbc->dict;
  tmat = kbc->tmat;
  d2p = kbc->dict2pid;
  n_ci = mdef->n_ciphone;
  n_sseq = mdef->n_sseq;
  n_st = mdef->n_emit_state;
  tmp = __ckd_calloc__((size_t )1, sizeof(lextree_t ), "lextree.c", 115);
  lextree = (lextree_t *)tmp;
  lextree->root = (glist_t )((void *)0);
  tmp___0 = __ckd_calloc__((size_t )n_sseq, sizeof(lextree_node_t *), "lextree.c",
                           119);
  ssid2ln = (lextree_node_t **)tmp___0;
  tmp___1 = __ckd_calloc__((size_t )n_sseq, sizeof(bitvec_t ), "lextree.c", 122);
  ssid_lc = (bitvec_t *)tmp___1;
  i = 0;
  while (i < n_sseq) {
    tmp___2 = __ckd_calloc__((size_t )((n_ci + 31) >> 5), sizeof(uint32 ), "lextree.c",
                             124);
    *(ssid_lc + i) = (bitvec_t )tmp___2;
    i ++;
  }
  n_node = 0;
  n_lc = 0;
  lcroot = (lextree_lcroot_t *)((void *)0);
  if (! lc) {
    lextree->n_lc = 0;
    lextree->lcroot = (lextree_lcroot_t *)((void *)0);
    tmp___3 = __ckd_calloc__((size_t )1, sizeof(lextree_node_t *), "lextree.c", 135);
    parent = (lextree_node_t **)tmp___3;
  } else {
    n_lc = 0;
    while ((int )*(lc + n_lc) >= 0) {
      n_lc ++;
    }
    lextree->n_lc = n_lc;
    tmp___4 = __ckd_calloc__((size_t )n_lc, sizeof(lextree_lcroot_t ), "lextree.c",
                             141);
    lcroot = (lextree_lcroot_t *)tmp___4;
    lextree->lcroot = lcroot;
    i = 0;
    while (i < n_lc) {
      (lcroot + i)->lc = *(lc + i);
      (lcroot + i)->root = (glist_t )((void *)0);
      i ++;
    }
    tmp___5 = __ckd_calloc__((size_t )n_lc, sizeof(lextree_node_t *), "lextree.c",
                             149);
    parent = (lextree_node_t **)tmp___5;
  }
  i = 0;
  while (i < n_word) {
    wid = (wordprob + i)->wid;
    prob = (wordprob + i)->prob;
    pronlen = (dict->word + wid)->pronlen;
    if (pronlen == 1) {
      ci = (int32 )*((dict->word + wid)->ciphone + 0);
      if (! lc) {
        ln = lextree_node_alloc(wid, prob, 1, *(*(d2p->internal + wid) + 0), n_st,
                                (int32 )*((dict->word + wid)->ciphone + 0));
        ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
        lextree->root = glist_add_ptr(lextree->root, (void *)ln);
        n_node ++;
      } else {
        np = 0;
        j = 0;
        while (j < n_lc) {
          ssid = *(*(d2p->single_lc + ci) + (int )*(lc + j));
          k___0 = 0;
          while (1) {
            if (k___0 < np) {
              if (! ((*(parent + k___0))->ssid != ssid)) {
                break;
              }
            } else {
              break;
            }
            k___0 ++;
          }
          if (k___0 >= np) {
            ln = lextree_node_alloc(wid, prob, 1, ssid, n_st, ci);
            ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
            lextree->root = glist_add_ptr(lextree->root, (void *)ln);
            n_node ++;
            (lcroot + j)->root = glist_add_ptr((lcroot + j)->root, (void *)ln);
            tmp___6 = np;
            np ++;
            *(parent + tmp___6) = ln;
          } else {
            (lcroot + j)->root = glist_add_ptr((lcroot + j)->root, (void *)*(parent + k___0));
          }
          j ++;
        }
      }
    } else {
      if (! lc) {
        ssid = *(*(d2p->internal + wid) + 0);
        ci = (int32 )*((dict->word + wid)->ciphone + 0);
        gn = lextree->root;
        while (gn) {
          ln = (lextree_node_t *)gn->data.ptr;
          if (ln->ssid == ssid) {
            if (ln->composite) {
              if (ln->wid < 0) {
                break;
              }
            }
          }
          gn = gn->next;
        }
        if (! gn) {
          ln = lextree_node_alloc(-1, prob, 1, ssid, n_st, ci);
          ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
          lextree->root = glist_add_ptr(lextree->root, (void *)ln);
          n_node ++;
        } else
        if (ln->prob < prob) {
          ln->prob = prob;
        }
        *(parent + 0) = ln;
        np = 1;
      } else {
        ci = (int32 )*((dict->word + wid)->ciphone + 0);
        rc = (int32 )*((dict->word + wid)->ciphone + 1);
        ldiph_lc = *(*(d2p->ldiph_lc + ci) + rc);
        np = 0;
        j = 0;
        while (j < n_lc) {
          ssid = *(ldiph_lc + (int )*(lc + j));
          ln = *(ssid2ln + ssid);
          if (! ln) {
            ln = lextree_node_alloc(-1, prob, 0, ssid, n_st, ci);
            ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
            lextree->root = glist_add_ptr(lextree->root, (void *)ln);
            n_node ++;
            *(ssid2ln + ssid) = ln;
          } else
          if (ln->prob < prob) {
            ln->prob = prob;
          }
          if (! (*(*(ssid_lc + ssid) + ((int )*(lc + j) >> 5)) & (unsigned int )(1 << ((int )*(lc + j) & 31)))) {
            (lcroot + j)->root = glist_add_ptr((lcroot + j)->root, (void *)ln);
            *(*(ssid_lc + ssid) + ((int )*(lc + j) >> 5)) |= (unsigned int )(1 << ((int )*(lc + j) & 31));
          }
          k___0 = 0;
          while (1) {
            if (k___0 < np) {
              if (! ((*(parent + k___0))->ssid != ssid)) {
                break;
              }
            } else {
              break;
            }
            k___0 ++;
          }
          if (k___0 >= np) {
            tmp___7 = np;
            np ++;
            *(parent + tmp___7) = ln;
          }
          j ++;
        }
      }
      p = 1;
      while (p < pronlen - 1) {
        ssid = *(*(d2p->internal + wid) + p);
        ci = (int32 )*((dict->word + wid)->ciphone + p);
        j = 0;
        while (j < np) {
          gn = (*(parent + j))->children;
          while (gn) {
            ln = (lextree_node_t *)gn->data.ptr;
            if (ln->ssid == ssid) {
              if (! ln->composite) {
                break;
              }
            }
            gn = gn->next;
          }
          if (gn) {
            break;
          }
          j ++;
        }
        if (! gn) {
          ln = lextree_node_alloc(-1, prob, 0, ssid, n_st, ci);
          ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
          j = 0;
          while (j < np) {
            (*(parent + j))->children = glist_add_ptr((*(parent + j))->children, (void *)ln);
            j ++;
          }
          n_node ++;
        } else {
          if (ln->prob < prob) {
            ln->prob = prob;
          }
          k___0 = j;
          j = 0;
          while (j < k___0) {
            (*(parent + j))->children = glist_add_ptr((*(parent + j))->children, (void *)ln);
            j ++;
          }
          j = k___0 + 1;
          while (j < np) {
            tmp___8 = glist_chkdup_ptr((*(parent + j))->children, (void *)ln);
            if (! tmp___8) {
              (*(parent + j))->children = glist_add_ptr((*(parent + j))->children,
                                                        (void *)ln);
            }
            j ++;
          }
        }
        *(parent + 0) = ln;
        np = 1;
        p ++;
      }
      ssid = *(*(d2p->internal + wid) + p);
      ci = (int32 )*((dict->word + wid)->ciphone + p);
      ln = lextree_node_alloc(wid, prob, 1, ssid, n_st, ci);
      ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
      j = 0;
      while (j < np) {
        (*(parent + j))->children = glist_add_ptr((*(parent + j))->children, (void *)ln);
        j ++;
      }
      n_node ++;
    }
    i ++;
  }
  lextree->n_node = n_node;
  tmp___9 = __ckd_calloc__((size_t )n_node, sizeof(lextree_node_t *), "lextree.c",
                           329);
  lextree->active = (lextree_node_t **)tmp___9;
  tmp___10 = __ckd_calloc__((size_t )n_node, sizeof(lextree_node_t *), "lextree.c",
                            330);
  lextree->next_active = (lextree_node_t **)tmp___10;
  lextree->n_active = 0;
  lextree->n_next_active = 0;
  ckd_free((void *)ssid2ln);
  i = 0;
  while (i < n_sseq) {
    ckd_free((void *)((char *)*(ssid_lc + i)));
    i ++;
  }
  ckd_free((void *)ssid_lc);
  ckd_free((void *)parent);
  return (lextree);
}
}
static int32 lextree_subtree_free(lextree_node_t *ln , int32 level ) 
{ 
  gnode_t *gn ;
  lextree_node_t *ln2 ;
  int32 k___0 ;
  int32 tmp ;

  {
  k___0 = 0;
  gn = ln->children;
  while (gn) {
    ln2 = (lextree_node_t *)gn->data.ptr;
    tmp = lextree_subtree_free(ln2, level + 1);
    k___0 += tmp;
    gn = gn->next;
  }
  glist_free(ln->children);
  ln->children = (glist_t )((void *)0);
  if (level != 1) {
    __myfree__((char *)((void *)ln), (int32 )sizeof(lextree_node_t ), (char *)"lextree.c",
               362);
    k___0 ++;
  } else {
    (ln->ssid) --;
    if (ln->ssid == 0) {
      __myfree__((char *)((void *)ln), (int32 )sizeof(lextree_node_t ), (char *)"lextree.c",
                 362);
      k___0 ++;
    }
  }
  return (k___0);
}
}
void lextree_free(lextree_t *lextree ) 
{ 
  gnode_t *gn ;
  gnode_t *gn2 ;
  lextree_node_t *ln ;
  lextree_node_t *ln2 ;
  int32 i ;
  int32 k___0 ;
  int32 tmp ;

  {
  if (lextree->n_lc > 0) {
    i = 0;
    while (i < lextree->n_lc) {
      glist_free((lextree->lcroot + i)->root);
      i ++;
    }
    ckd_free((void *)lextree->lcroot);
  }
  gn = lextree->root;
  while (gn) {
    ln = (lextree_node_t *)gn->data.ptr;
    gn2 = ln->children;
    while (gn2) {
      ln2 = (lextree_node_t *)gn2->data.ptr;
      if ((int )ln2->composite >= 0) {
        ln2->composite = (int8 )-1;
        ln2->ssid = 1;
      } else {
        (ln2->ssid) ++;
      }
      gn2 = gn2->next;
    }
    gn = gn->next;
  }
  k___0 = 0;
  gn = lextree->root;
  while (gn) {
    ln = (lextree_node_t *)gn->data.ptr;
    tmp = lextree_subtree_free(ln, 0);
    k___0 += tmp;
    gn = gn->next;
  }
  glist_free(lextree->root);
  ckd_free((void *)lextree->active);
  ckd_free((void *)lextree->next_active);
  if (k___0 != lextree->n_node) {
    _E__pr_header("lextree.c", 413L, "ERROR");
    _E__pr_warn("#Nodes allocated(%d) != #nodes freed(%d)\n", lextree->n_node, k___0);
  }
  ckd_free((void *)lextree);
  return;
}
}
void lextree_ci_active(lextree_t *lextree , bitvec_t ci_active ) 
{ 
  lextree_node_t **list ;
  lextree_node_t *ln ;
  int32 i ;

  {
  list = lextree->active;
  i = 0;
  while (i < lextree->n_active) {
    ln = *(list + i);
    *(ci_active + ((int )ln->ci >> 5)) |= (unsigned int )(1 << ((int )ln->ci & 31));
    i ++;
  }
  return;
}
}
void lextree_ssid_active(lextree_t *lextree , int32 *ssid , int32 *comssid ) 
{ 
  lextree_node_t **list ;
  lextree_node_t *ln ;
  int32 i ;

  {
  list = lextree->active;
  i = 0;
  while (i < lextree->n_active) {
    ln = *(list + i);
    if (ln->composite) {
      *(comssid + ln->ssid) = 1;
    } else {
      *(ssid + ln->ssid) = 1;
    }
    i ++;
  }
  return;
}
}
void lextree_utt_end(lextree_t *l , kbcore_t *kbc ) 
{ 
  mdef_t *mdef ;
  lextree_node_t *ln ;
  int32 i ;

  {
  mdef = kbc->mdef;
  i = 0;
  while (i < l->n_active) {
    ln = *(l->active + i);
    ln->frame = (s3frmid_t )-1;
    hmm_clear(& ln->hmm, mdef->n_emit_state);
    i ++;
  }
  l->n_active = 0;
  l->n_next_active = 0;
  return;
}
}
static void lextree_node_print(lextree_node_t *ln , dict_t *dict , FILE *fp ) 
{ 


  {
  fprintf(fp, "wid(%d)pr(%d)com(%d)ss(%d)", ln->wid, ln->prob, (int )ln->composite,
          ln->ssid);
  if (ln->wid >= 0) {
    fprintf(fp, "%s", (dict->word + ln->wid)->word);
  }
  fprintf(fp, "\n");
  return;
}
}
static void lextree_subtree_print(lextree_node_t *ln , int32 level , dict_t *dict ,
                                  FILE *fp ) 
{ 
  int32 i ;
  gnode_t *gn ;

  {
  i = 0;
  while (i < level) {
    fprintf(fp, "    ");
    i ++;
  }
  lextree_node_print(ln, dict, fp);
  gn = ln->children;
  while (gn) {
    ln = (lextree_node_t *)gn->data.ptr;
    lextree_subtree_print(ln, level + 1, dict, fp);
    gn = gn->next;
  }
  return;
}
}
void lextree_dump(lextree_t *lextree , dict_t *dict , FILE *fp ) 
{ 
  gnode_t *gn ;
  lextree_node_t *ln ;
  int32 i ;

  {
  gn = lextree->root;
  while (gn) {
    ln = (lextree_node_t *)gn->data.ptr;
    lextree_subtree_print(ln, 0, dict, fp);
    gn = gn->next;
  }
  if (lextree->n_lc > 0) {
    i = 0;
    while (i < lextree->n_lc) {
      fprintf(fp, "lcroot %d\n", (int )(lextree->lcroot + i)->lc);
      gn = (lextree->lcroot + i)->root;
      while (gn) {
        ln = (lextree_node_t *)gn->data.ptr;
        lextree_node_print(ln, dict, fp);
        gn = gn->next;
      }
      i ++;
    }
  }
  return;
}
}
void lextree_enter(lextree_t *lextree , s3cipid_t lc , int32 cf , int32 inscore ,
                   int32 inhist , int32 thresh ) 
{ 
  glist_t root ;
  gnode_t *gn ;
  lextree_node_t *ln ;
  int32 nf ;
  int32 scr ;
  int32 i ;
  int32 n ;
  hmm_t *hmm ;
  int32 tmp ;

  {
  nf = cf + 1;
  if (lextree->n_lc == 0) {
    root = lextree->root;
  } else {
    i = 0;
    while (1) {
      if (i < lextree->n_lc) {
        if (! ((int )(lextree->lcroot + i)->lc != (int )lc)) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
    root = (lextree->lcroot + i)->root;
  }
  n = lextree->n_next_active;
  gn = root;
  while (gn) {
    ln = (lextree_node_t *)gn->data.ptr;
    hmm = & ln->hmm;
    scr = inscore + ln->prob;
    if (scr >= thresh) {
      if (hmm->in.score < scr) {
        hmm->in.score = scr;
        hmm->in.history = inhist;
        if ((int )ln->frame != nf) {
          ln->frame = (s3frmid_t )nf;
          tmp = n;
          n ++;
          *(lextree->next_active + tmp) = ln;
        }
      }
    }
    gn = gn->next;
  }
  lextree->n_next_active = n;
  return;
}
}
void lextree_active_swap(lextree_t *lextree ) 
{ 
  lextree_node_t **t ;

  {
  t = lextree->active;
  lextree->active = lextree->next_active;
  lextree->next_active = t;
  lextree->n_active = lextree->n_next_active;
  lextree->n_next_active = 0;
  return;
}
}
int32 lextree_hmm_eval(lextree_t *lextree , kbcore_t *kbc , ascr_t *ascr , int32 frm ,
                       FILE *fp ) 
{ 
  int32 best ;
  int32 wbest ;
  int32 n_st ;
  int32 i ;
  int32 k___0 ;
  lextree_node_t **list ;
  lextree_node_t *ln ;
  mdef_t *mdef ;
  dict2pid_t *d2p ;

  {
  mdef = kbc->mdef;
  d2p = kbc->dict2pid;
  n_st = mdef->n_emit_state;
  list = lextree->active;
  best = (int32 )2147483648U;
  wbest = (int32 )2147483648U;
  if (fp) {
    i = 0;
    while (i < lextree->n_active) {
      ln = *(list + i);
      lextree_node_print(ln, kbc->dict, fp);
      if (! ln->composite) {
        k___0 = hmm_dump_vit_eval(& ln->hmm, n_st, *(mdef->sseq + ln->ssid), ascr->sen,
                                  fp);
      } else {
        k___0 = hmm_dump_vit_eval(& ln->hmm, n_st, *(d2p->comsseq + ln->ssid), ascr->comsen,
                                  fp);
      }
      if (best < k___0) {
        best = k___0;
      }
      if (ln->wid >= 0) {
        if (wbest < k___0) {
          wbest = k___0;
        }
      }
      i ++;
    }
  } else
  if (n_st == 3) {
    i = 0;
    while (i < lextree->n_active) {
      ln = *(list + i);
      if (! ln->composite) {
        k___0 = hmm_vit_eval_3st(& ln->hmm, *(mdef->sseq + ln->ssid), ascr->sen);
      } else {
        k___0 = hmm_vit_eval_3st(& ln->hmm, *(d2p->comsseq + ln->ssid), ascr->comsen);
      }
      if (best < k___0) {
        best = k___0;
      }
      if (ln->wid >= 0) {
        if (wbest < k___0) {
          wbest = k___0;
        }
      }
      i ++;
    }
  } else
  if (n_st == 5) {
    i = 0;
    while (i < lextree->n_active) {
      ln = *(list + i);
      if (! ln->composite) {
        k___0 = hmm_vit_eval_5st(& ln->hmm, *(mdef->sseq + ln->ssid), ascr->sen);
      } else {
        k___0 = hmm_vit_eval_5st(& ln->hmm, *(d2p->comsseq + ln->ssid), ascr->comsen);
      }
      if (best < k___0) {
        best = k___0;
      }
      if (ln->wid >= 0) {
        if (wbest < k___0) {
          wbest = k___0;
        }
      }
      i ++;
    }
  } else {
    _E__pr_header("lextree.c", 656L, "FATAL_ERROR");
    _E__die_error("#State= %d unsupported\n", n_st);
  }
  lextree->best = best;
  lextree->wbest = wbest;
  if (fp) {
    fprintf(fp, "Fr %d  #active %d  best %d  wbest %d\n", frm, lextree->n_active,
            best, wbest);
    fflush(fp);
  }
  return (best);
}
}
void lextree_hmm_histbin(lextree_t *lextree , int32 bestscr , int32 *bin , int32 nbin ,
                         int32 bw ) 
{ 
  lextree_node_t **list ;
  lextree_node_t *ln ;
  hmm_t *hmm ;
  int32 i ;
  int32 k___0 ;
  glist_t *binln ;
  gnode_t *gn ;
  void *tmp ;
  int32 tmp___0 ;

  {
  tmp = __ckd_calloc__((size_t )nbin, sizeof(glist_t ), "lextree.c", 680);
  binln = (glist_t *)tmp;
  list = lextree->active;
  i = 0;
  while (i < lextree->n_active) {
    ln = *(list + i);
    hmm = & ln->hmm;
    k___0 = (bestscr - hmm->bestscore) / bw;
    if (k___0 >= nbin) {
      k___0 = nbin - 1;
    }
    (*(bin + k___0)) ++;
    *(binln + k___0) = glist_add_ptr(*(binln + k___0), (void *)ln);
    i ++;
  }
  k___0 = 0;
  i = 0;
  while (i < nbin) {
    gn = *(binln + i);
    while (gn) {
      ln = (lextree_node_t *)gn->data.ptr;
      tmp___0 = k___0;
      k___0 ++;
      *(list + tmp___0) = ln;
      gn = gn->next;
    }
    glist_free(*(binln + i));
    i ++;
  }
  ckd_free((void *)binln);
  return;
}
}
static int32 maxNewHeurScore  =    (int32 )2147483648U;
static int32 lastfrm  =    -1;
void lextree_hmm_propagate(lextree_t *lextree , kbcore_t *kbc , vithist_t *vh , int32 cf ,
                           int32 th , int32 pth , int32 wth , int32 *phn_heur_list ,
                           int32 heur_beam , int32 heur_type ) 
{ 
  mdef_t *mdef ;
  int32 nf ;
  int32 newscore ;
  int32 newHeurScore ;
  lextree_node_t **list ;
  lextree_node_t *ln ;
  lextree_node_t *ln2 ;
  hmm_t *hmm ;
  hmm_t *hmm2 ;
  gnode_t *gn ;
  int32 i ;
  int32 n ;
  int32 hth ;
  int32 tmp ;
  int32 tmp___0 ;

  {
  mdef = kbc->mdef;
  nf = cf + 1;
  list = lextree->active;
  n = lextree->n_next_active;
  i = 0;
  while (i < lextree->n_active) {
    ln = *(list + i);
    hmm = & ln->hmm;
    if ((int )ln->frame < nf) {
      if (hmm->bestscore >= th) {
        ln->frame = (s3frmid_t )nf;
        tmp = n;
        n ++;
        *(lextree->next_active + tmp) = ln;
      } else {
        ln->frame = (s3frmid_t )-1;
        hmm_clear(hmm, mdef->n_emit_state);
      }
    }
    if (ln->wid < 0) {
      if (hmm->out.score < pth) {
        goto __Cont;
      }
      if (heur_type > 0) {
        if (cf != lastfrm) {
          lastfrm = cf;
          maxNewHeurScore = (int32 )2147483648U;
        }
        gn = ln->children;
        while (gn) {
          ln2 = (lextree_node_t *)gn->data.ptr;
          newHeurScore = (hmm->out.score + (ln2->prob - ln->prob)) + *(phn_heur_list + (int32 )ln2->ci);
          if (maxNewHeurScore < newHeurScore) {
            maxNewHeurScore = newHeurScore;
          }
          gn = gn->next;
        }
        hth = maxNewHeurScore + heur_beam;
      }
      gn = ln->children;
      while (gn) {
        ln2 = (lextree_node_t *)gn->data.ptr;
        hmm2 = & ln2->hmm;
        newscore = hmm->out.score + (ln2->prob - ln->prob);
        newHeurScore = newscore + *(phn_heur_list + (int32 )ln2->ci);
        if (heur_type == 0) {
          goto _L;
        } else
        if (heur_type > 0) {
          if (newHeurScore >= hth) {
            _L: /* CIL Label */ 
            if (newscore >= th) {
              if (hmm2->in.score < newscore) {
                hmm2->in.score = newscore;
                hmm2->in.history = hmm->out.history;
                if ((int )ln2->frame != nf) {
                  ln2->frame = (s3frmid_t )nf;
                  tmp___0 = n;
                  n ++;
                  *(lextree->next_active + tmp___0) = ln2;
                }
              }
            }
          }
        }
        gn = gn->next;
      }
    } else {
      if (hmm->out.score < wth) {
        goto __Cont;
      }
      if (hmm->out.history == -1) {
        _E__pr_header("lextree.c", 805L, "ERROR");
        _E__pr_warn("Hmm->out.history equals to -1 with score %d and active idx %d, lextree->type\n",
                    hmm->out.score, i, lextree->type);
      }
      vithist_rescore(vh, kbc, ln->wid, cf, hmm->out.score - ln->prob, hmm->out.history,
                      lextree->type);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  lextree->n_next_active = n;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-PH0qrc83.i","-O3")
extern long ftell(FILE * ) ;
lmclass_set_t lmclass_newset(void) ;
lmclass_set_t lmclass_loadfile(lmclass_set_t lmclass_set , char *file ) ;
lmclass_t lmclass_get_lmclass(lmclass_set_t set , char *name ) ;
int32 lmclass_get_nclass(lmclass_set_t set ) ;
void lmclass_set_dictwid(lmclass_word_t w___0 , int32 dictwid ) ;
int32 lm_get_classid(lm_t *model , char *name ) ;
int32 lm_tglist(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 , tg_t **tgptr , int32 *bowt ) ;
int32 lm_bglist(lm_t *lm , s3lmwid_t w1 , bg_t **bgptr , int32 *bowt ) ;
int32 lm_uglist(lm_t *lm , ug_t **ugptr ) ;
int32 lm_ug_score(lm_t *lm , s3lmwid_t lwid , s3wid_t wid ) ;
int32 lm_bg_score(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 , s3wid_t w2 ) ;
int32 lm_tg_score(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 , s3lmwid_t lw3 , s3wid_t w3 ) ;
void lm_set_param(lm_t *lm , float64 lw , float64 wip ) ;
s3lmwid_t lm_wid(lm_t *lm , char *word ) ;
void lm_cache_reset(lm_t *lm ) ;
void lm_cache_stats_dump(lm_t *lm ) ;
int32 log10_to_logs3(float64 log10p ) ;
static char *darpa_hdr  =    (char *)"Darpa Trigram LM";
static int LM_IN_MEMORY  =    0;
static lm_t *lm_read_dump(char *file , float64 lw , float64 wip , float64 uw , int32 n_lmclass_used ,
                          lmclass_t *lmclass , int32 dict_size ) ;
int32 lm_get_classid(lm_t *model , char *name ) 
{ 
  int32 i ;
  int tmp ;

  {
  if (! model->lmclass) {
    return (-1);
  }
  i = 0;
  while (i < model->n_lmclass) {
    tmp = strcmp((char const   *)(*(model->lmclass + i))->name, (char const   *)name);
    if (tmp == 0) {
      return (i + 16777216);
    }
    i ++;
  }
  return (-1);
}
}
int32 lm_delete(lm_t *lm , lmset_t *lmset ) 
{ 


  {
  _E__pr_info_header("lm.c", 151L, "INFO");
  _E__pr_info("Warning, lm_delete is currently empty, no memory is deleted\n");
  return (0);
}
}
static void lm_uw(lm_t *lm , float64 uw ) 
{ 
  int32 i ;
  int32 loguw ;
  int32 loguw_ ;
  int32 loguniform ;
  int32 p1 ;
  int32 p2 ;
  int tmp ;

  {
  loguw = logs3(uw);
  loguw_ = logs3(1.0 - uw);
  loguniform = logs3(1.0 / (double )(lm->n_ug - 1));
  i = 0;
  while (i < lm->n_ug) {
    tmp = strcmp((char const   *)*(lm->wordstr + i), "<s>");
    if (tmp != 0) {
      p1 = (lm->ug + i)->prob.l + loguw;
      p2 = loguniform + loguw_;
      (lm->ug + i)->prob.l = logs3_add(p1, p2);
    }
    i ++;
  }
  return;
}
}
static void lm2logs3(lm_t *lm , float64 uw ) 
{ 
  int32 i ;

  {
  i = 0;
  while (i < lm->n_ug) {
    (lm->ug + i)->prob.l = log10_to_logs3((float64 )(lm->ug + i)->prob.f);
    (lm->ug + i)->bowt.l = log10_to_logs3((float64 )(lm->ug + i)->bowt.f);
    i ++;
  }
  lm_uw(lm, uw);
  i = 0;
  while (i < lm->n_bgprob) {
    (lm->bgprob + i)->l = log10_to_logs3((float64 )(lm->bgprob + i)->f);
    i ++;
  }
  if (lm->n_tg > 0) {
    i = 0;
    while (i < lm->n_tgprob) {
      (lm->tgprob + i)->l = log10_to_logs3((float64 )(lm->tgprob + i)->f);
      i ++;
    }
    i = 0;
    while (i < lm->n_tgbowt) {
      (lm->tgbowt + i)->l = log10_to_logs3((float64 )(lm->tgbowt + i)->f);
      i ++;
    }
  }
  return;
}
}
void lm_set_param(lm_t *lm , float64 lw , float64 wip ) 
{ 
  int32 i ;
  int32 iwip ;
  float64 f ;

  {
  if (lw <= 0.0) {
    _E__pr_header("lm.c", 207L, "FATAL_ERROR");
    _E__die_error("lw = %e\n", lw);
  }
  if (wip <= 0.0) {
    _E__pr_header("lm.c", 209L, "FATAL_ERROR");
    _E__die_error("wip = %e\n", wip);
  }
  iwip = logs3(wip);
  f = lw / (float64 )lm->lw;
  i = 0;
  while (i < lm->n_ug) {
    (lm->ug + i)->prob.l = (int32 )((float64 )((lm->ug + i)->prob.l - lm->wip) * f) + iwip;
    (lm->ug + i)->bowt.l = (int32 )((float64 )(lm->ug + i)->bowt.l * f);
    i ++;
  }
  i = 0;
  while (i < lm->n_bgprob) {
    (lm->bgprob + i)->l = (int32 )((float64 )((lm->bgprob + i)->l - lm->wip) * f) + iwip;
    i ++;
  }
  if (lm->n_tg > 0) {
    i = 0;
    while (i < lm->n_tgprob) {
      (lm->tgprob + i)->l = (int32 )((float64 )((lm->tgprob + i)->l - lm->wip) * f) + iwip;
      i ++;
    }
    i = 0;
    while (i < lm->n_tgbowt) {
      (lm->tgbowt + i)->l = (int32 )((float64 )(lm->tgbowt + i)->l * f);
      i ++;
    }
  }
  lm->lw = (float32 )lw;
  lm->wip = iwip;
  return;
}
}
static int32 lm_fread_int32(lm_t *lm ) 
{ 
  int32 val ;
  size_t tmp ;

  {
  tmp = fread((void *)(& val), sizeof(int32 ), (size_t )1, lm->fp);
  if (tmp != 1UL) {
    _E__pr_header("lm.c", 242L, "FATAL_ERROR");
    _E__die_error("fread failed\n");
  }
  if (lm->byteswap) {
    val = (int32 )((unsigned int )(((255 & (val >> 24)) | (65280 & (val >> 8))) | (16711680 & (val << 8))) | (4278190080U & (unsigned int )(val << 24)));
  }
  return (val);
}
}
lmset_t *lm_read_ctl(char *ctlfile , dict_t *dict , float64 lw , float64 wip , float64 uw ,
                     char *lmdumpdir , int32 *n_lm , int32 *n_alloclm , int32 dict_size ) 
{ 
  FILE *ctlfp ;
  FILE *tmp ;
  char lmfile[4096] ;
  char lmname[4096] ;
  char str[4096] ;
  lmclass_set_t lmclass_set ;
  lmclass_t *lmclass ;
  lmclass_t cl ;
  int32 n_lmclass ;
  int32 n_lmclass_used ;
  int32 i ;
  lm_t *lm ;
  lmset_t *lmset ;
  void const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  lmclass_word_t w___0 ;
  int32 wid ;
  void *tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  lm_t *tmp___17 ;
  void *tmp___18 ;
  lm_t *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;

  {
  lmset = (lmset_t *)((void *)0);
  tmp = (FILE *)((void *)0);
  lmclass_set = lmclass_newset();
  _E__pr_info_header("lm.c", 291L, "INFO");
  _E__pr_info("Reading LM control file \'%s\'\n", ctlfile);
  tmp___0 = cmd_ln_access((char *)"-lminmemory");
  if (*((int32 *)tmp___0)) {
    LM_IN_MEMORY = 1;
  } else {
    LM_IN_MEMORY = 0;
  }
  ctlfp = _myfopen(ctlfile, (char *)"r", (char *)"lm.c", 299);
  tmp___6 = fscanf(ctlfp, "%s", str);
  if (tmp___6 == 1) {
    tmp___5 = strcmp((char const   *)(str), "{");
    if (tmp___5 == 0) {
      while (1) {
        tmp___1 = fscanf(ctlfp, "%s", str);
        if (tmp___1 == 1) {
          tmp___2 = strcmp((char const   *)(str), "}");
          if (! (tmp___2 != 0)) {
            break;
          }
        } else {
          break;
        }
        lmclass_set = lmclass_loadfile(lmclass_set, str);
      }
      tmp___3 = strcmp((char const   *)(str), "}");
      if (tmp___3 != 0) {
        _E__pr_header("lm.c", 308L, "FATAL_ERROR");
        _E__die_error("Unexpected EOF(%s)\n", ctlfile);
      }
      tmp___4 = fscanf(ctlfp, "%s", str);
      if (tmp___4 != 1) {
        str[0] = (char )'\000';
      }
    }
  } else {
    str[0] = (char )'\000';
  }
  cl = lmclass_set->lmclass_list;
  while ((unsigned long )cl != (unsigned long )((void *)0)) {
    w___0 = cl->wordlist;
    while ((unsigned long )w___0 != (unsigned long )((void *)0)) {
      wid = dict_wordid(dict, w___0->word);
      lmclass_set_dictwid(w___0, wid);
      w___0 = w___0->next;
    }
    cl = cl->next;
  }
  n_lmclass = lmclass_get_nclass(lmclass_set);
  tmp___7 = __ckd_calloc__((size_t )n_lmclass, sizeof(lmclass_t ), "lm.c", 350);
  lmclass = (lmclass_t *)tmp___7;
  _E__pr_info_header("lm.c", 352L, "INFO");
  _E__pr_info("Number of LM class specified %d in file %s\n", n_lmclass, ctlfile);
  while ((int )str[0] != 0) {
    tmp___9 = __builtin_object_size((void *)(lmfile), 0);
    if (tmp___9 != 0xffffffffffffffffUL) {
      tmp___8 = __builtin_object_size((void *)(lmfile), 1);
      __builtin___strcpy_chk(lmfile, (char const   *)(str), tmp___8);
    } else {
      __inline_strcpy_chk(lmfile, (char const   *)(str));
    }
    tmp___10 = fscanf(ctlfp, "%s", lmname);
    if (tmp___10 != 1) {
      _E__pr_header("lm.c", 358L, "FATAL_ERROR");
      _E__die_error("LMname missing after LMFileName \'%s\'\n", lmfile);
    }
    n_lmclass_used = 0;
    tmp___16 = fscanf(ctlfp, "%s", str);
    if (tmp___16 == 1) {
      tmp___15 = strcmp((char const   *)(str), "{");
      if (tmp___15 == 0) {
        while (1) {
          tmp___11 = fscanf(ctlfp, "%s", str);
          if (tmp___11 == 1) {
            tmp___12 = strcmp((char const   *)(str), "}");
            if (! (tmp___12 != 0)) {
              break;
            }
          } else {
            break;
          }
          if (n_lmclass_used >= n_lmclass) {
            _E__pr_header("lm.c", 367L, "FATAL_ERROR");
            _E__die_error("Too many LM classes specified for \'%s\'\n", lmfile);
          }
          *(lmclass + n_lmclass_used) = lmclass_get_lmclass(lmclass_set, str);
          if (! ((unsigned long )*(lmclass + n_lmclass_used) != (unsigned long )((void *)0))) {
            _E__pr_header("lm.c", 374L, "FATAL_ERROR");
            _E__die_error("LM class \'%s\' not found\n", str);
          }
          n_lmclass_used ++;
        }
        tmp___13 = strcmp((char const   *)(str), "}");
        if (tmp___13 != 0) {
          _E__pr_header("lm.c", 378L, "FATAL_ERROR");
          _E__die_error("Unexpected EOF(%s)\n", ctlfile);
        }
        tmp___14 = fscanf(ctlfp, "%s", str);
        if (tmp___14 != 1) {
          str[0] = (char )'\000';
        }
      }
    } else {
      str[0] = (char )'\000';
    }
    if (n_lmclass_used > 0) {
      tmp___17 = lm_read_dump(lmfile, lw, wip, uw, n_lmclass_used, lmclass, dict_size);
      lm = tmp___17;
      tmp___18 = __ckd_calloc__((size_t )100003, sizeof(lm_tgcache_entry_t ), "lm.c",
                                399);
      lm->tgcache = (lm_tgcache_entry_t *)tmp___18;
      i = 0;
      while (i < 100003) {
        (lm->tgcache + i)->lwid[0] = (s3lmwid_t )65535;
        i ++;
      }
    } else {
      tmp___19 = lm_read_dump(lmfile, lw, wip, uw, 0, (lmclass_t *)((void *)0), dict_size);
      lm = tmp___19;
      tmp___20 = __ckd_calloc__((size_t )100003, sizeof(lm_tgcache_entry_t ), "lm.c",
                                410);
      lm->tgcache = (lm_tgcache_entry_t *)tmp___20;
      i = 0;
      while (i < 100003) {
        (lm->tgcache + i)->lwid[0] = (s3lmwid_t )65535;
        i ++;
      }
    }
    if (*n_lm == *n_alloclm) {
      tmp___21 = __ckd_realloc__((void *)lmset, (unsigned long )(*n_alloclm + 16) * sizeof(lmset_t ),
                                 "lm.c", 416);
      lmset = (lmset_t *)tmp___21;
      *n_alloclm += 16;
    }
    (lmset + *n_lm)->name = __ckd_salloc__((char const   *)(lmname), "lm.c", 419);
    (lmset + *n_lm)->lm = lm;
    (*n_lm) ++;
  }
  _E__pr_info_header("lm.c", 424L, "INFO");
  _E__pr_info("No. of LM set allocated %d, no. of LM %d \n", *n_alloclm, *n_lm);
  fclose(ctlfp);
  return (lmset);
}
}
static int32 lm_build_lmclass_info(lm_t *lm , float64 lw , float64 uw , float64 wip ,
                                   int32 n_lmclass_used , lmclass_t *lmclass ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  if (n_lmclass_used > 0) {
    tmp = __ckd_calloc__((size_t )n_lmclass_used, sizeof(lmclass_t ), "lm.c", 436);
    lm->lmclass = (lmclass_t *)tmp;
    i = 0;
    while (i < n_lmclass_used) {
      *(lm->lmclass + i) = *(lmclass + i);
      i ++;
    }
  } else {
    lm->lmclass = (lmclass_t *)((void *)0);
  }
  lm->n_lmclass = n_lmclass_used;
  tmp___0 = __ckd_calloc__((size_t )lm->dict_size, sizeof(int32 ), "lm.c", 443);
  lm->inclass_ugscore = (int32 *)tmp___0;
  _E__pr_info_header("lm.c", 445L, "INFO");
  _E__pr_info("LM->inclass_ugscore size %d\n", lm->dict_size);
  _E__pr_info_header("lm.c", 446L, "INFO");
  _E__pr_info("Number of class used %d\n", n_lmclass_used);
  return (1);
}
}
static lm_t *lm_read_dump(char *file , float64 lw , float64 wip , float64 uw , int32 n_lmclass_used ,
                          lmclass_t *lmclass , int32 dict_size ) 
{ 
  lm_t *lm ;
  int32 i ;
  int32 j ;
  int32 k___0 ;
  int32 vn ;
  char str[1024] ;
  char *tmp_word_str ;
  s3lmwid_t startwid ;
  s3lmwid_t endwid ;
  void *tmp ;
  FILE *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  void *tmp___13 ;
  long tmp___14 ;
  void *tmp___15 ;
  long tmp___16 ;
  void *tmp___17 ;
  long tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  void *tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  void *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  size_t tmp___34 ;

  {
  tmp = __ckd_calloc__((size_t )1, sizeof(lm_t ), "lm.c", 464);
  lm = (lm_t *)tmp;
  lm->dict_size = dict_size;
  tmp___0 = fopen((char const   *)file, "rb");
  lm->fp = tmp___0;
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    _E__pr_header("lm.c", 468L, "SYSTEM_ERROR");
    _E__fatal_sys_error("fopen(%s,rb) failed\n", file);
  }
  tmp___1 = fread((void *)(& k___0), sizeof(int32 ), (size_t )1, lm->fp);
  if (tmp___1 != 1UL) {
    _E__pr_header("lm.c", 472L, "FATAL_ERROR");
    _E__die_error("fread(%s) failed\n", file);
  }
  tmp___3 = strlen((char const   *)darpa_hdr);
  if ((size_t )k___0 == tmp___3 + 1UL) {
    lm->byteswap = 0;
  } else {
    k___0 = (int32 )((unsigned int )(((255 & (k___0 >> 24)) | (65280 & (k___0 >> 8))) | (16711680 & (k___0 << 8))) | (4278190080U & (unsigned int )(k___0 << 24)));
    tmp___2 = strlen((char const   *)darpa_hdr);
    if ((size_t )k___0 == tmp___2 + 1UL) {
      lm->byteswap = 1;
    } else {
      k___0 = (int32 )((unsigned int )(((255 & (k___0 >> 24)) | (65280 & (k___0 >> 8))) | (16711680 & (k___0 << 8))) | (4278190080U & (unsigned int )(k___0 << 24)));
      _E__pr_header("lm.c", 481L, "FATAL_ERROR");
      _E__die_error("Bad magic number: %d(%08x), not an LM dumpfile??\n", k___0, k___0);
    }
  }
  tmp___4 = fread((void *)(str), sizeof(char ), (size_t )k___0, lm->fp);
  if (tmp___4 != (size_t )k___0) {
    _E__pr_header("lm.c", 487L, "FATAL_ERROR");
    _E__die_error("fread(%s) failed\n", file);
  }
  tmp___5 = strncmp((char const   *)(str), (char const   *)darpa_hdr, (size_t )k___0);
  if (tmp___5 != 0) {
    _E__pr_header("lm.c", 489L, "FATAL_ERROR");
    _E__die_error("Bad header\n");
  }
  k___0 = lm_fread_int32(lm);
  if (k___0 < 1) {
    _E__pr_header("lm.c", 494L, "FATAL_ERROR");
    _E__die_error("Bad original filename size: %d\n", k___0);
  } else
  if (k___0 > 1024) {
    _E__pr_header("lm.c", 494L, "FATAL_ERROR");
    _E__die_error("Bad original filename size: %d\n", k___0);
  }
  tmp___6 = fread((void *)(str), sizeof(char ), (size_t )k___0, lm->fp);
  if (tmp___6 != (size_t )k___0) {
    _E__pr_header("lm.c", 496L, "FATAL_ERROR");
    _E__die_error("fread(%s) failed\n", file);
  }
  vn = lm_fread_int32(lm);
  if (vn <= 0) {
    k___0 = lm_fread_int32(lm);
    while (1) {
      k___0 = lm_fread_int32(lm);
      if (k___0 == 0) {
        break;
      }
      tmp___7 = fread((void *)(str), sizeof(char ), (size_t )k___0, lm->fp);
      if (tmp___7 != (size_t )k___0) {
        _E__pr_header("lm.c", 509L, "FATAL_ERROR");
        _E__die_error("fread(%s) failed\n", file);
      }
    }
    if (vn <= -2) {
      k___0 = lm_fread_int32(lm);
      if (k___0 < 1) {
        _E__pr_header("lm.c", 516L, "FATAL_ERROR");
        _E__die_error("log2(bg_seg_sz) outside range 1..15\n", k___0);
      } else
      if (k___0 > 15) {
        _E__pr_header("lm.c", 516L, "FATAL_ERROR");
        _E__die_error("log2(bg_seg_sz) outside range 1..15\n", k___0);
      }
      lm->log_bg_seg_sz = k___0;
    } else {
      lm->log_bg_seg_sz = 9;
    }
    lm->n_ug = lm_fread_int32(lm);
  } else {
    lm->n_ug = vn;
    lm->log_bg_seg_sz = 9;
  }
  if (lm->n_ug <= 0) {
    _E__pr_header("lm.c", 529L, "FATAL_ERROR");
    _E__die_error("Bad #ug: %d (must be >0, <%d\n", lm->n_ug, (uint32 )65534);
  } else
  if ((uint32 )lm->n_ug >= 65534U) {
    _E__pr_header("lm.c", 529L, "FATAL_ERROR");
    _E__die_error("Bad #ug: %d (must be >0, <%d\n", lm->n_ug, (uint32 )65534);
  }
  lm->bg_seg_sz = 1 << lm->log_bg_seg_sz;
  lm->n_bg = lm_fread_int32(lm);
  if (lm->n_bg < 0) {
    _E__pr_header("lm.c", 536L, "FATAL_ERROR");
    _E__die_error("Bad #bigrams: %d\n", lm->n_bg);
  }
  lm->n_tg = lm_fread_int32(lm);
  if (lm->n_tg < 0) {
    _E__pr_header("lm.c", 541L, "FATAL_ERROR");
    _E__die_error("Bad #trigrams: %d\n", lm->n_tg);
  }
  tmp___8 = __ckd_calloc__((size_t )(lm->n_ug + 1), sizeof(ug_t ), "lm.c", 544);
  lm->ug = (ug_t *)tmp___8;
  tmp___9 = fread((void *)lm->ug, sizeof(ug_t ), (size_t )(lm->n_ug + 1), lm->fp);
  if (tmp___9 != (size_t )(lm->n_ug + 1)) {
    _E__pr_header("lm.c", 546L, "FATAL_ERROR");
    _E__die_error("fread(%s) failed\n", file);
  }
  if (lm->byteswap) {
    i = 0;
    while (i <= lm->n_ug) {
      (lm->ug + i)->prob.l = (int32 )((unsigned int )(((255 & ((lm->ug + i)->prob.l >> 24)) | (65280 & ((lm->ug + i)->prob.l >> 8))) | (16711680 & ((lm->ug + i)->prob.l << 8))) | (4278190080U & (unsigned int )((lm->ug + i)->prob.l << 24)));
      (lm->ug + i)->bowt.l = (int32 )((unsigned int )(((255 & ((lm->ug + i)->bowt.l >> 24)) | (65280 & ((lm->ug + i)->bowt.l >> 8))) | (16711680 & ((lm->ug + i)->bowt.l << 8))) | (4278190080U & (unsigned int )((lm->ug + i)->bowt.l << 24)));
      (lm->ug + i)->firstbg = (int32 )((unsigned int )(((255 & ((lm->ug + i)->firstbg >> 24)) | (65280 & ((lm->ug + i)->firstbg >> 8))) | (16711680 & ((lm->ug + i)->firstbg << 8))) | (4278190080U & (unsigned int )((lm->ug + i)->firstbg << 24)));
      i ++;
    }
  }
  _E__pr_info_header("lm.c", 553L, "INFO");
  _E__pr_info("%8d ug\n", lm->n_ug);
  if (LM_IN_MEMORY) {
    tmp___10 = __ckd_calloc__((size_t )(lm->n_bg + 1), sizeof(bg_t ), "lm.c", 557);
    lm->bg = (bg_t *)tmp___10;
    tmp___11 = __ckd_calloc__((size_t )(lm->n_tg + 1), sizeof(tg_t ), "lm.c", 558);
    lm->tg = (tg_t *)tmp___11;
    if (lm->n_bg > 0) {
      tmp___12 = ftell(lm->fp);
      lm->bgoff = (int32 )tmp___12;
      fread((void *)lm->bg, (size_t )(lm->n_bg + 1), sizeof(bg_t ), lm->fp);
      _E__pr_info_header("lm.c", 563L, "INFO");
      _E__pr_info("Read %8d bigrams [in memory]\n", lm->n_bg);
      tmp___13 = __ckd_calloc__((size_t )lm->n_ug, sizeof(membg_t ), "lm.c", 565);
      lm->membg = (membg_t *)tmp___13;
    }
    if (lm->n_tg > 0) {
      tmp___14 = ftell(lm->fp);
      lm->tgoff = (int32 )tmp___14;
      fread((void *)lm->tg, (size_t )lm->n_tg, sizeof(tg_t ), lm->fp);
      _E__pr_info_header("lm.c", 571L, "INFO");
      _E__pr_info("Read %8d trigrams [in memory]\n", lm->n_tg);
      tmp___15 = __ckd_calloc__((size_t )lm->n_ug, sizeof(tginfo_t *), "lm.c", 573);
      lm->tginfo = (tginfo_t **)tmp___15;
    }
  } else {
    lm->bg = (bg_t *)((void *)0);
    lm->tg = (tg_t *)((void *)0);
    if (lm->n_bg > 0) {
      tmp___16 = ftell(lm->fp);
      lm->bgoff = (int32 )tmp___16;
      fseek(lm->fp, (long )((unsigned long )(lm->n_bg + 1) * sizeof(bg_t )), 1);
      _E__pr_info_header("lm.c", 583L, "INFO");
      _E__pr_info("%8d bigrams [on disk]\n", lm->n_bg);
      tmp___17 = __ckd_calloc__((size_t )lm->n_ug, sizeof(membg_t ), "lm.c", 584);
      lm->membg = (membg_t *)tmp___17;
    }
    if (lm->n_tg > 0) {
      tmp___18 = ftell(lm->fp);
      lm->tgoff = (int32 )tmp___18;
      fseek(lm->fp, (long )((unsigned long )lm->n_tg * sizeof(tg_t )), 1);
      _E__pr_info_header("lm.c", 591L, "INFO");
      _E__pr_info("%8d trigrams [on disk]\n", lm->n_tg);
      tmp___19 = __ckd_calloc__((size_t )lm->n_ug, sizeof(tginfo_t *), "lm.c", 593);
      lm->tginfo = (tginfo_t **)tmp___19;
    }
  }
  if (lm->n_bg > 0) {
    lm->n_bgprob = lm_fread_int32(lm);
    if (lm->n_bgprob <= 0) {
      _E__pr_header("lm.c", 601L, "FATAL_ERROR");
      _E__die_error("Bad bigram prob table size: %d\n", lm->n_bgprob);
    } else
    if (lm->n_bgprob > 65536) {
      _E__pr_header("lm.c", 601L, "FATAL_ERROR");
      _E__die_error("Bad bigram prob table size: %d\n", lm->n_bgprob);
    }
    tmp___20 = __ckd_calloc__((size_t )lm->n_bgprob, sizeof(lmlog_t ), "lm.c", 604);
    lm->bgprob = (lmlog_t *)tmp___20;
    tmp___21 = fread((void *)lm->bgprob, sizeof(lmlog_t ), (size_t )lm->n_bgprob,
                     lm->fp);
    if (tmp___21 != (size_t )lm->n_bgprob) {
      _E__pr_header("lm.c", 607L, "FATAL_ERROR");
      _E__die_error("fread(%s) failed\n", file);
    }
    if (lm->byteswap) {
      i = 0;
      while (i < lm->n_bgprob) {
        (lm->bgprob + i)->l = (int32 )((unsigned int )(((255 & ((lm->bgprob + i)->l >> 24)) | (65280 & ((lm->bgprob + i)->l >> 8))) | (16711680 & ((lm->bgprob + i)->l << 8))) | (4278190080U & (unsigned int )((lm->bgprob + i)->l << 24)));
        i ++;
      }
    }
    _E__pr_info_header("lm.c", 613L, "INFO");
    _E__pr_info("%8d bigram prob entries\n", lm->n_bgprob);
  }
  if (lm->n_tg > 0) {
    lm->n_tgbowt = lm_fread_int32(lm);
    if (lm->n_tgbowt <= 0) {
      _E__pr_header("lm.c", 620L, "FATAL_ERROR");
      _E__die_error("Bad trigram bowt table size: %d\n", lm->n_tgbowt);
    } else
    if (lm->n_tgbowt > 65536) {
      _E__pr_header("lm.c", 620L, "FATAL_ERROR");
      _E__die_error("Bad trigram bowt table size: %d\n", lm->n_tgbowt);
    }
    tmp___22 = __ckd_calloc__((size_t )lm->n_tgbowt, sizeof(lmlog_t ), "lm.c", 623);
    lm->tgbowt = (lmlog_t *)tmp___22;
    tmp___23 = fread((void *)lm->tgbowt, sizeof(lmlog_t ), (size_t )lm->n_tgbowt,
                     lm->fp);
    if (tmp___23 != (size_t )lm->n_tgbowt) {
      _E__pr_header("lm.c", 626L, "FATAL_ERROR");
      _E__die_error("fread(%s) failed\n", file);
    }
    if (lm->byteswap) {
      i = 0;
      while (i < lm->n_tgbowt) {
        (lm->tgbowt + i)->l = (int32 )((unsigned int )(((255 & ((lm->tgbowt + i)->l >> 24)) | (65280 & ((lm->tgbowt + i)->l >> 8))) | (16711680 & ((lm->tgbowt + i)->l << 8))) | (4278190080U & (unsigned int )((lm->tgbowt + i)->l << 24)));
        i ++;
      }
    }
    _E__pr_info_header("lm.c", 631L, "INFO");
    _E__pr_info("%8d trigram bowt entries\n", lm->n_tgbowt);
    lm->n_tgprob = lm_fread_int32(lm);
    if (lm->n_tgprob <= 0) {
      _E__pr_header("lm.c", 636L, "FATAL_ERROR");
      _E__die_error("Bad trigram bowt table size: %d\n", lm->n_tgprob);
    } else
    if (lm->n_tgprob > 65536) {
      _E__pr_header("lm.c", 636L, "FATAL_ERROR");
      _E__die_error("Bad trigram bowt table size: %d\n", lm->n_tgprob);
    }
    tmp___24 = __ckd_calloc__((size_t )lm->n_tgprob, sizeof(lmlog_t ), "lm.c", 639);
    lm->tgprob = (lmlog_t *)tmp___24;
    tmp___25 = fread((void *)lm->tgprob, sizeof(lmlog_t ), (size_t )lm->n_tgprob,
                     lm->fp);
    if (tmp___25 != (size_t )lm->n_tgprob) {
      _E__pr_header("lm.c", 642L, "FATAL_ERROR");
      _E__die_error("fread(%s) failed\n", file);
    }
    if (lm->byteswap) {
      i = 0;
      while (i < lm->n_tgprob) {
        (lm->tgprob + i)->l = (int32 )((unsigned int )(((255 & ((lm->tgprob + i)->l >> 24)) | (65280 & ((lm->tgprob + i)->l >> 8))) | (16711680 & ((lm->tgprob + i)->l << 8))) | (4278190080U & (unsigned int )((lm->tgprob + i)->l << 24)));
        i ++;
      }
    }
    _E__pr_info_header("lm.c", 647L, "INFO");
    _E__pr_info("%8d trigram prob entries\n", lm->n_tgprob);
    k___0 = lm_fread_int32(lm);
    if (k___0 != (lm->n_bg + 1) / lm->bg_seg_sz + 1) {
      _E__pr_header("lm.c", 652L, "FATAL_ERROR");
      _E__die_error("Bad trigram seg table size: %d\n", k___0);
    }
    tmp___26 = __ckd_calloc__((size_t )k___0, sizeof(int32 ), "lm.c", 655);
    lm->tg_segbase = (int32 *)tmp___26;
    tmp___27 = fread((void *)lm->tg_segbase, sizeof(int32 ), (size_t )k___0, lm->fp);
    if (tmp___27 != (size_t )k___0) {
      _E__pr_header("lm.c", 657L, "FATAL_ERROR");
      _E__die_error("fread(%s) failed\n", file);
    }
    if (lm->byteswap) {
      i = 0;
      while (i < k___0) {
        *(lm->tg_segbase + i) = (int32 )((unsigned int )(((255 & (*(lm->tg_segbase + i) >> 24)) | (65280 & (*(lm->tg_segbase + i) >> 8))) | (16711680 & (*(lm->tg_segbase + i) << 8))) | (4278190080U & (unsigned int )(*(lm->tg_segbase + i) << 24)));
        i ++;
      }
    }
    _E__pr_info_header("lm.c", 662L, "INFO");
    _E__pr_info("%8d trigram segtable entries (%d segsize)\n", k___0, lm->bg_seg_sz);
  }
  k___0 = lm_fread_int32(lm);
  if (k___0 <= 0) {
    _E__pr_header("lm.c", 668L, "FATAL_ERROR");
    _E__die_error("Bad wordstrings size: %d\n", k___0);
  }
  tmp___28 = __ckd_calloc__((size_t )k___0, sizeof(char ), "lm.c", 670);
  tmp_word_str = (char *)tmp___28;
  tmp___29 = fread((void *)tmp_word_str, sizeof(char ), (size_t )k___0, lm->fp);
  if (tmp___29 != (size_t )k___0) {
    _E__pr_header("lm.c", 672L, "FATAL_ERROR");
    _E__die_error("fread(%s) failed\n", file);
  }
  i = 0;
  j = 0;
  while (i < k___0) {
    if ((int )*(tmp_word_str + i) == 0) {
      j ++;
    }
    i ++;
  }
  if (j != lm->n_ug) {
    _E__pr_header("lm.c", 679L, "FATAL_ERROR");
    _E__die_error("Bad #words: %d\n", j);
  }
  endwid = (s3lmwid_t )65535;
  startwid = endwid;
  tmp___30 = __ckd_calloc__((size_t )lm->n_ug, sizeof(char *), "lm.c", 683);
  lm->wordstr = (char **)tmp___30;
  j = 0;
  i = 0;
  while (i < lm->n_ug) {
    tmp___32 = strcmp((char const   *)(tmp_word_str + j), "<s>");
    if (tmp___32 == 0) {
      startwid = (s3lmwid_t )i;
    } else {
      tmp___31 = strcmp((char const   *)(tmp_word_str + j), "</s>");
      if (tmp___31 == 0) {
        endwid = (s3lmwid_t )i;
      }
    }
    tmp___33 = __ckd_salloc__((char const   *)(tmp_word_str + j), "lm.c", 691);
    *(lm->wordstr + i) = tmp___33;
    tmp___34 = strlen((char const   *)(tmp_word_str + j));
    j = (int32 )((size_t )j + (tmp___34 + 1UL));
    i ++;
  }
  free((void *)tmp_word_str);
  _E__pr_info_header("lm.c", 696L, "INFO");
  _E__pr_info("%8d word strings\n", i);
  if ((int )startwid != 65535) {
    (lm->ug + startwid)->prob.f = (float32 )(- 99.0);
    lm->startlwid = startwid;
  }
  if ((int )endwid != 65535) {
    (lm->ug + endwid)->bowt.f = (float32 )(- 99.0);
    lm->finishlwid = endwid;
  }
  if (n_lmclass_used > 0) {
    lm_build_lmclass_info(lm, lw, uw, wip, n_lmclass_used, lmclass);
  }
  lm2logs3(lm, uw);
  lm->lw = (float32 )1.0;
  lm->wip = 0;
  lm_set_param(lm, lw, wip);
  return (lm);
}
}
lm_t *lm_read(char *file , float64 lw , float64 wip , float64 uw ) 
{ 
  int32 i ;
  int32 u ;
  lm_t *lm ;
  int32 tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
  if (! file) {
    _E__pr_header("lm.c", 731L, "FATAL_ERROR");
    _E__die_error("No LM file\n");
  }
  if (lw <= 0.0) {
    _E__pr_header("lm.c", 733L, "FATAL_ERROR");
    _E__die_error("lw = %e\n", lw);
  }
  if (wip <= 0.0) {
    _E__pr_header("lm.c", 735L, "FATAL_ERROR");
    _E__die_error("wip = %e\n", wip);
  }
  if (uw < 0.0) {
    _E__pr_header("lm.c", 737L, "FATAL_ERROR");
    _E__die_error("uw = %e\n", uw);
  } else
  if (uw > 1.0) {
    _E__pr_header("lm.c", 737L, "FATAL_ERROR");
    _E__die_error("uw = %e\n", uw);
  }
  _E__pr_info_header("lm.c", 739L, "INFO");
  tmp = logs3(wip);
  _E__pr_info("LM read(\'%s\', lw= %.2f, wip= %d, uw= %.2f)\n", file, lw, tmp, uw);
  tmp___0 = cmd_ln_access((char *)"-lminmemory");
  if (*((int32 *)tmp___0)) {
    LM_IN_MEMORY = 1;
  } else {
    LM_IN_MEMORY = 0;
  }
  lm = lm_read_dump(file, lw, wip, uw, 0, (lmclass_t *)((void *)0), 0);
  u = 0;
  while (u < lm->n_ug) {
    (lm->ug + u)->dictwid = -1;
    u ++;
  }
  tmp___1 = __ckd_calloc__((size_t )100003, sizeof(lm_tgcache_entry_t ), "lm.c", 752);
  lm->tgcache = (lm_tgcache_entry_t *)tmp___1;
  i = 0;
  while (i < 100003) {
    (lm->tgcache + i)->lwid[0] = (s3lmwid_t )65535;
    i ++;
  }
  return (lm);
}
}
void lm_cache_reset(lm_t *lm ) 
{ 
  int32 i ;
  int32 n_bgfree ;
  int32 n_tgfree ;
  tginfo_t *tginfo ;
  tginfo_t *next_tginfo ;
  tginfo_t *prev_tginfo ;

  {
  n_tgfree = 0;
  n_bgfree = n_tgfree;
  if (LM_IN_MEMORY) {
    return;
  }
  if (lm->n_bg > 0) {
    if (! lm->bg) {
      i = 0;
      while (i < lm->n_ug) {
        if ((lm->membg + i)->bg) {
          if (! (lm->membg + i)->used) {
            lm->n_bg_inmem -= (lm->ug + (i + 1))->firstbg - (lm->ug + i)->firstbg;
            free((void *)(lm->membg + i)->bg);
            (lm->membg + i)->bg = (bg_t *)((void *)0);
            n_bgfree ++;
          }
        }
        (lm->membg + i)->used = 0;
        i ++;
      }
    }
  }
  if (lm->n_tg > 0) {
    i = 0;
    while (i < lm->n_ug) {
      prev_tginfo = (tginfo_t *)((void *)0);
      tginfo = *(lm->tginfo + i);
      while (tginfo) {
        next_tginfo = tginfo->next;
        if (! tginfo->used) {
          if (! lm->tg) {
            if (tginfo->tg) {
              lm->n_tg_inmem -= tginfo->n_tg;
              free((void *)tginfo->tg);
              n_tgfree ++;
            }
          }
          free((void *)tginfo);
          if (prev_tginfo) {
            prev_tginfo->next = next_tginfo;
          } else {
            *(lm->tginfo + i) = next_tginfo;
          }
        } else {
          tginfo->used = 0;
          prev_tginfo = tginfo;
        }
        tginfo = next_tginfo;
      }
      i ++;
    }
  }
  if (n_tgfree > 0) {
    _E__pr_info_header("lm.c", 815L, "INFO");
    _E__pr_info("%d tg frees, %d in mem; %d bg frees, %d in mem\n", n_tgfree, lm->n_tg_inmem,
                n_bgfree, lm->n_bg_inmem);
  } else
  if (n_bgfree > 0) {
    _E__pr_info_header("lm.c", 815L, "INFO");
    _E__pr_info("%d tg frees, %d in mem; %d bg frees, %d in mem\n", n_tgfree, lm->n_tg_inmem,
                n_bgfree, lm->n_bg_inmem);
  }
  return;
}
}
void lm_cache_stats_dump(lm_t *lm ) 
{ 


  {
  _E__pr_info_header("lm.c", 823L, "INFO");
  _E__pr_info("%9d tg(), %9d tgcache, %8d bo; %5d fills, %8d in mem (%.1f%%)\n", lm->n_tg_score,
              lm->n_tgcache_hit, lm->n_tg_bo, lm->n_tg_fill, lm->n_tg_inmem, ((double )lm->n_tg_inmem * 100.0) / (double )(lm->n_tg + 1));
  _E__pr_info_header("lm.c", 826L, "INFO");
  _E__pr_info("%8d bg(), %8d bo; %5d fills, %8d in mem (%.1f%%)\n", lm->n_bg_score,
              lm->n_bg_bo, lm->n_bg_fill, lm->n_bg_inmem, ((double )lm->n_bg_inmem * 100.0) / (double )(lm->n_bg + 1));
  lm->n_tgcache_hit = 0;
  lm->n_tg_fill = 0;
  lm->n_tg_score = 0;
  lm->n_tg_bo = 0;
  lm->n_bg_fill = 0;
  lm->n_bg_score = 0;
  lm->n_bg_bo = 0;
  return;
}
}
int32 lm_ug_score(lm_t *lm , s3lmwid_t lwid , s3wid_t wid ) 
{ 


  {
  if ((int )lwid == 65535) {
    _E__pr_header("lm.c", 843L, "FATAL_ERROR");
    _E__die_error("Bad argument (%d) to lm_ug_score\n", (int )lwid);
  } else
  if (wid >= lm->n_ug) {
    _E__pr_header("lm.c", 843L, "FATAL_ERROR");
    _E__die_error("Bad argument (%d) to lm_ug_score\n", (int )lwid);
  }
  lm->access_type = 1;
  if (lm->inclass_ugscore) {
    return ((lm->ug + lwid)->prob.l + *(lm->inclass_ugscore + wid));
  } else {
    return ((lm->ug + lwid)->prob.l);
  }
}
}
int32 lm_uglist(lm_t *lm , ug_t **ugptr ) 
{ 


  {
  *ugptr = lm->ug;
  return (lm->n_ug);
}
}
int32 lm_ug_wordprob(lm_t *lm , dict_t *dict , int32 th , wordprob_t *wp ) 
{ 
  int32 i ;
  int32 j ;
  int32 n ;
  int32 p ;
  s3wid_t w___0 ;
  s3wid_t dictid ;
  lmclass_t lmclass ;
  lmclass_word_t lm_cw ;

  {
  n = lm->n_ug;
  i = 0;
  j = 0;
  while (i < n) {
    w___0 = (lm->ug + i)->dictwid;
    if (w___0 >= 0) {
      if (w___0 < 16777216) {
        p = (lm->ug + i)->prob.l;
        if (p >= th) {
          (wp + j)->wid = w___0;
          (wp + j)->prob = p;
          j ++;
        }
      } else {
        lmclass = *(lm->lmclass + (w___0 - 16777216));
        lm_cw = lmclass->wordlist;
        while ((unsigned long )lm_cw != (unsigned long )((void *)0)) {
          dictid = lm_cw->dictwid;
          if (dictid != (dict->word + dictid)->basewid) {
            dictid = (dict->word + dictid)->basewid;
          }
          p = (lm->ug + i)->prob.l + *(lm->inclass_ugscore + dictid);
          if (p >= th) {
            (wp + j)->wid = dictid;
            (wp + j)->prob = (lm->ug + i)->prob.l;
            j ++;
          }
          lm_cw = lm_cw->next;
        }
      }
    }
    i ++;
  }
  return (j);
}
}
static void load_bg(lm_t *lm , s3lmwid_t lw1 ) 
{ 
  int32 i ;
  int32 n ;
  int32 b ;
  bg_t *bg ;
  bg_t *tmp ;
  bg_t *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  b = (lm->ug + lw1)->firstbg;
  n = (lm->ug + ((int )lw1 + 1))->firstbg - b;
  if (LM_IN_MEMORY) {
    tmp = lm->bg + b;
    (lm->membg + lw1)->bg = tmp;
    bg = tmp;
  } else {
    tmp___1 = __ckd_calloc__((size_t )(n + 1), sizeof(bg_t ), "lm.c", 919);
    tmp___0 = (bg_t *)tmp___1;
    (lm->membg + lw1)->bg = tmp___0;
    bg = tmp___0;
    tmp___2 = fseek(lm->fp, (long )((unsigned long )lm->bgoff + (unsigned long )b * sizeof(bg_t )),
                    0);
    if (tmp___2 < 0) {
      _E__pr_header("lm.c", 922L, "SYSTEM_ERROR");
      _E__fatal_sys_error("fseek failed\n");
    }
    tmp___3 = fread((void *)bg, sizeof(bg_t ), (size_t )(n + 1), lm->fp);
    if (tmp___3 != (size_t )(n + 1)) {
      _E__pr_header("lm.c", 926L, "FATAL_ERROR");
      _E__die_error("fread failed\n");
    }
    if (lm->byteswap) {
      i = 0;
      while (i <= n) {
        (bg + i)->wid = (s3lmwid_t )((255 & ((int )(bg + i)->wid >> 8)) | (65280 & ((int )(bg + i)->wid << 8)));
        (bg + i)->probid = (uint16 )((255 & ((int )(bg + i)->probid >> 8)) | (65280 & ((int )(bg + i)->probid << 8)));
        (bg + i)->bowtid = (uint16 )((255 & ((int )(bg + i)->bowtid >> 8)) | (65280 & ((int )(bg + i)->bowtid << 8)));
        (bg + i)->firsttg = (uint16 )((255 & ((int )(bg + i)->firsttg >> 8)) | (65280 & ((int )(bg + i)->firsttg << 8)));
        i ++;
      }
    }
  }
  (lm->n_bg_fill) ++;
  lm->n_bg_inmem += n;
  return;
}
}
static int32 find_bg(bg_t *bg , int32 n , s3lmwid_t w___0 ) 
{ 
  int32 i ;
  int32 b ;
  int32 e ;
  int32 tmp ;

  {
  b = 0;
  e = n;
  while (e - b > 16) {
    i = (b + e) >> 1;
    if ((int )(bg + i)->wid < (int )w___0) {
      b = i + 1;
    } else
    if ((int )(bg + i)->wid > (int )w___0) {
      e = i;
    } else {
      return (i);
    }
  }
  i = b;
  while (1) {
    if (i < e) {
      if (! ((int )(bg + i)->wid != (int )w___0)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  if (i < e) {
    tmp = i;
  } else {
    tmp = -1;
  }
  return (tmp);
}
}
int32 lm_bglist(lm_t *lm , s3lmwid_t w1 , bg_t **bgptr , int32 *bowt ) 
{ 
  int32 n ;

  {
  if ((int )w1 == 65535) {
    _E__pr_header("lm.c", 972L, "FATAL_ERROR");
    _E__die_error("Bad w1 argument (%d) to lm_bglist\n", (int )w1);
  } else
  if ((int )w1 >= lm->n_ug) {
    _E__pr_header("lm.c", 972L, "FATAL_ERROR");
    _E__die_error("Bad w1 argument (%d) to lm_bglist\n", (int )w1);
  }
  if (lm->n_bg > 0) {
    n = (lm->ug + ((int )w1 + 1))->firstbg - (lm->ug + w1)->firstbg;
  } else {
    n = 0;
  }
  if (n > 0) {
    if (! (lm->membg + w1)->bg) {
      load_bg(lm, w1);
    }
    (lm->membg + w1)->used = 1;
    *bgptr = (lm->membg + w1)->bg;
    *bowt = (lm->ug + w1)->bowt.l;
  } else {
    *bgptr = (bg_t *)((void *)0);
    *bowt = 0;
  }
  return (n);
}
}
int32 lm_bg_score(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 , s3wid_t w2 ) 
{ 
  int32 i ;
  int32 n ;
  int32 score ;
  bg_t *bg ;
  int32 tmp ;

  {
  bg = (bg_t *)0;
  if (lm->n_bg == 0) {
    tmp = lm_ug_score(lm, lw2, w2);
    return (tmp);
  } else
  if ((int )lw1 == 65535) {
    tmp = lm_ug_score(lm, lw2, w2);
    return (tmp);
  }
  (lm->n_bg_score) ++;
  if ((int )lw2 == 65535) {
    _E__pr_header("lm.c", 1038L, "FATAL_ERROR");
    _E__die_error("Bad lw2 argument (%d) to lm_bg_score\n", (int )lw2);
  } else
  if ((int )lw2 >= lm->n_ug) {
    _E__pr_header("lm.c", 1038L, "FATAL_ERROR");
    _E__die_error("Bad lw2 argument (%d) to lm_bg_score\n", (int )lw2);
  }
  n = (lm->ug + ((int )lw1 + 1))->firstbg - (lm->ug + lw1)->firstbg;
  if (n > 0) {
    if (! (lm->membg + lw1)->bg) {
      load_bg(lm, lw1);
    }
    (lm->membg + lw1)->used = 1;
    bg = (lm->membg + lw1)->bg;
    i = find_bg(bg, n, lw2);
  } else {
    i = -1;
  }
  if (i >= 0) {
    score = (lm->bgprob + (bg + i)->probid)->l;
    if (lm->inclass_ugscore) {
      score += *(lm->inclass_ugscore + w2);
    }
    lm->access_type = 2;
  } else {
    (lm->n_bg_bo) ++;
    lm->access_type = 1;
    score = (lm->ug + lw1)->bowt.l + (lm->ug + lw2)->prob.l;
  }
  return (score);
}
}
static void load_tg(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 ) 
{ 
  int32 i ;
  int32 n ;
  int32 b ;
  int32 t ;
  bg_t *bg ;
  tg_t *tg ;
  tginfo_t *tginfo ;
  void *tmp ;
  int32 tmp___0 ;
  tg_t *tmp___1 ;
  tg_t *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  t = -1;
  tmp = __ckd_malloc__(sizeof(tginfo_t ), "lm.c", 1087);
  tginfo = (tginfo_t *)tmp;
  tginfo->w1 = lw1;
  tginfo->tg = (tg_t *)((void *)0);
  tginfo->next = *(lm->tginfo + lw2);
  *(lm->tginfo + lw2) = tginfo;
  b = (lm->ug + lw1)->firstbg;
  n = (lm->ug + ((int )lw1 + 1))->firstbg - b;
  if (n > 0) {
    if (! (lm->membg + lw1)->bg) {
      load_bg(lm, lw1);
    }
    (lm->membg + lw1)->used = 1;
    bg = (lm->membg + lw1)->bg;
  }
  if (n > 0) {
    i = find_bg(bg, n, lw2);
    if (i >= 0) {
      tginfo->bowt = (lm->tgbowt + (bg + i)->bowtid)->l;
      b += i;
      t = *(lm->tg_segbase + (b >> lm->log_bg_seg_sz));
      t += (int32 )(bg + i)->firsttg;
      n = *(lm->tg_segbase + ((b + 1) >> lm->log_bg_seg_sz));
      n += (int32 )(bg + (i + 1))->firsttg;
      n -= t;
      tginfo->n_tg = n;
    } else {
      tginfo->bowt = 0;
      tmp___0 = 0;
      tginfo->n_tg = tmp___0;
      n = tmp___0;
    }
  } else {
    tginfo->bowt = 0;
    tmp___0 = 0;
    tginfo->n_tg = tmp___0;
    n = tmp___0;
  }
  if (LM_IN_MEMORY) {
    if (n > 0) {
      tmp___1 = lm->tg + t;
      tginfo->tg = tmp___1;
      tg = tmp___1;
    }
  } else
  if (n > 0) {
    tmp___3 = __ckd_calloc__((size_t )n, sizeof(tg_t ), "lm.c", 1140);
    tmp___2 = (tg_t *)tmp___3;
    tginfo->tg = tmp___2;
    tg = tmp___2;
    tmp___4 = fseek(lm->fp, (long )((unsigned long )lm->tgoff + (unsigned long )t * sizeof(tg_t )),
                    0);
    if (tmp___4 < 0) {
      _E__pr_header("lm.c", 1142L, "SYSTEM_ERROR");
      _E__fatal_sys_error("fseek failed\n");
    }
    tmp___5 = fread((void *)tg, sizeof(tg_t ), (size_t )n, lm->fp);
    if (tmp___5 != (size_t )n) {
      _E__pr_header("lm.c", 1145L, "FATAL_ERROR");
      _E__die_error("fread(tg, %d at %d) failed\n", n, lm->tgoff);
    }
    if (lm->byteswap) {
      i = 0;
      while (i < n) {
        (tg + i)->wid = (s3lmwid_t )((255 & ((int )(tg + i)->wid >> 8)) | (65280 & ((int )(tg + i)->wid << 8)));
        (tg + i)->probid = (uint16 )((255 & ((int )(tg + i)->probid >> 8)) | (65280 & ((int )(tg + i)->probid << 8)));
        i ++;
      }
    }
  }
  (lm->n_tg_fill) ++;
  lm->n_tg_inmem += n;
  return;
}
}
static int32 find_tg(tg_t *tg , int32 n , s3lmwid_t w___0 ) 
{ 
  int32 i ;
  int32 b ;
  int32 e ;
  int32 tmp ;

  {
  b = 0;
  e = n;
  while (e - b > 16) {
    i = (b + e) >> 1;
    if ((int )(tg + i)->wid < (int )w___0) {
      b = i + 1;
    } else
    if ((int )(tg + i)->wid > (int )w___0) {
      e = i;
    } else {
      return (i);
    }
  }
  i = b;
  while (1) {
    if (i < e) {
      if (! ((int )(tg + i)->wid != (int )w___0)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  if (i < e) {
    tmp = i;
  } else {
    tmp = -1;
  }
  return (tmp);
}
}
int32 lm_tglist(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 , tg_t **tgptr , int32 *bowt ) 
{ 
  tginfo_t *tginfo ;
  tginfo_t *prev_tginfo ;

  {
  if (lm->n_tg <= 0) {
    *tgptr = (tg_t *)((void *)0);
    *bowt = 0;
    return (0);
  }
  if ((int )lw1 == 65535) {
    _E__pr_header("lm.c", 1192L, "FATAL_ERROR");
    _E__die_error("Bad lw1 argument (%d) to lm_tglist\n", (int )lw1);
  } else
  if ((int )lw1 >= lm->n_ug) {
    _E__pr_header("lm.c", 1192L, "FATAL_ERROR");
    _E__die_error("Bad lw1 argument (%d) to lm_tglist\n", (int )lw1);
  }
  if ((int )lw2 == 65535) {
    _E__pr_header("lm.c", 1194L, "FATAL_ERROR");
    _E__die_error("Bad lw2 argument (%d) to lm_tglist\n", (int )lw2);
  } else
  if ((int )lw2 >= lm->n_ug) {
    _E__pr_header("lm.c", 1194L, "FATAL_ERROR");
    _E__die_error("Bad lw2 argument (%d) to lm_tglist\n", (int )lw2);
  }
  prev_tginfo = (tginfo_t *)((void *)0);
  tginfo = *(lm->tginfo + lw2);
  while (tginfo) {
    if ((int )tginfo->w1 == (int )lw1) {
      break;
    }
    prev_tginfo = tginfo;
    tginfo = tginfo->next;
  }
  if (! tginfo) {
    load_tg(lm, lw1, lw2);
    tginfo = *(lm->tginfo + lw2);
  } else
  if (prev_tginfo) {
    prev_tginfo->next = tginfo->next;
    tginfo->next = *(lm->tginfo + lw2);
    *(lm->tginfo + lw2) = tginfo;
  }
  tginfo->used = 1;
  *tgptr = tginfo->tg;
  *bowt = tginfo->bowt;
  return (tginfo->n_tg);
}
}
int32 lm_tg_score(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 , s3lmwid_t lw3 , s3wid_t w3 ) 
{ 
  int32 i ;
  int32 h ;
  int32 n ;
  int32 score ;
  tg_t *tg ;
  tginfo_t *tginfo ;
  tginfo_t *prev_tginfo ;
  int32 tmp ;
  int32 tmp___0 ;

  {
  if (lm->n_tg == 0) {
    tmp = lm_bg_score(lm, lw2, lw3, w3);
    return (tmp);
  } else
  if ((int )lw1 == 65535) {
    tmp = lm_bg_score(lm, lw2, lw3, w3);
    return (tmp);
  }
  (lm->n_tg_score) ++;
  if ((int )lw1 == 65535) {
    _E__pr_header("lm.c", 1241L, "FATAL_ERROR");
    _E__die_error("Bad lw1 argument (%d) to lm_tg_score\n", (int )lw1);
  } else
  if ((int )lw1 >= lm->n_ug) {
    _E__pr_header("lm.c", 1241L, "FATAL_ERROR");
    _E__die_error("Bad lw1 argument (%d) to lm_tg_score\n", (int )lw1);
  }
  if ((int )lw2 == 65535) {
    _E__pr_header("lm.c", 1243L, "FATAL_ERROR");
    _E__die_error("Bad lw2 argument (%d) to lm_tg_score\n", (int )lw2);
  } else
  if ((int )lw2 >= lm->n_ug) {
    _E__pr_header("lm.c", 1243L, "FATAL_ERROR");
    _E__die_error("Bad lw2 argument (%d) to lm_tg_score\n", (int )lw2);
  }
  if ((int )lw3 == 65535) {
    _E__pr_header("lm.c", 1245L, "FATAL_ERROR");
    _E__die_error("Bad lw3 argument (%d) to lm_tg_score\n", (int )lw3);
  } else
  if ((int )lw3 >= lm->n_ug) {
    _E__pr_header("lm.c", 1245L, "FATAL_ERROR");
    _E__die_error("Bad lw3 argument (%d) to lm_tg_score\n", (int )lw3);
  }
  h = ((((int )lw1 & 1023) << 21) + (((int )lw2 & 1023) << 11)) + ((int )lw3 & 2047);
  h %= 100003;
  if ((int )(lm->tgcache + h)->lwid[0] == (int )lw1) {
    if ((int )(lm->tgcache + h)->lwid[1] == (int )lw2) {
      if ((int )(lm->tgcache + h)->lwid[2] == (int )lw3) {
        (lm->n_tgcache_hit) ++;
        return ((lm->tgcache + h)->lscr);
      }
    }
  }
  prev_tginfo = (tginfo_t *)((void *)0);
  tginfo = *(lm->tginfo + lw2);
  while (tginfo) {
    if ((int )tginfo->w1 == (int )lw1) {
      break;
    }
    prev_tginfo = tginfo;
    tginfo = tginfo->next;
  }
  if (! tginfo) {
    load_tg(lm, lw1, lw2);
    tginfo = *(lm->tginfo + lw2);
  } else
  if (prev_tginfo) {
    prev_tginfo->next = tginfo->next;
    tginfo->next = *(lm->tginfo + lw2);
    *(lm->tginfo + lw2) = tginfo;
  }
  tginfo->used = 1;
  n = tginfo->n_tg;
  tg = tginfo->tg;
  i = find_tg(tg, n, lw3);
  if (i >= 0) {
    score = (lm->tgprob + (tg + i)->probid)->l;
    if (lm->inclass_ugscore) {
      score += *(lm->inclass_ugscore + w3);
    }
    lm->access_type = 3;
  } else {
    (lm->n_tg_bo) ++;
    tmp___0 = lm_bg_score(lm, lw2, lw3, w3);
    score = tginfo->bowt + tmp___0;
  }
  (lm->tgcache + h)->lwid[0] = lw1;
  (lm->tgcache + h)->lwid[1] = lw2;
  (lm->tgcache + h)->lwid[2] = lw3;
  (lm->tgcache + h)->lscr = score;
  return (score);
}
}
s3lmwid_t lm_wid(lm_t *lm , char *word ) 
{ 
  int32 i ;
  int tmp ;

  {
  i = 0;
  while (i < lm->n_ug) {
    tmp = strcmp((char const   *)*(lm->wordstr + i), (char const   *)word);
    if (tmp == 0) {
      return ((s3lmwid_t )i);
    }
    i ++;
  }
  return ((s3lmwid_t )65535);
}
}
void lm_free(lm_t *lm ) 
{ 
  int i ;

  {
  i = 0;
  while (i < lm->n_ug) {
    ckd_free((void *)*(lm->wordstr + i));
    i ++;
  }
  ckd_free((void *)lm->membg);
  ckd_free((void *)lm->wordstr);
  ckd_free((void *)lm->tgcache);
  ckd_free((void *)lm->tg_segbase);
  ckd_free((void *)lm->tgprob);
  ckd_free((void *)lm->tgbowt);
  ckd_free((void *)lm->bgprob);
  ckd_free((void *)lm->tginfo);
  ckd_free((void *)lm->ug);
  ckd_free((void *)lm);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-6OfHx63E.i","-O3")
void lmclass_dump(lmclass_t cl , FILE *fp ) ;
void lmclass_set_dump(lmclass_set_t set , FILE *fp ) ;
void lmclass_dump(lmclass_t cl , FILE *fp ) 
{ 
  lmclass_word_t w___0 ;

  {
  fprintf(fp, "LMCLASS %s\n", cl->name);
  w___0 = cl->wordlist;
  while (w___0) {
    fprintf(fp, "    %s\t%d\n", w___0->word, w___0->LOGprob);
    w___0 = w___0->next;
  }
  fprintf(fp, "END %s\n", cl->name);
  fflush(fp);
  return;
}
}
void lmclass_set_dump(lmclass_set_t set , FILE *fp ) 
{ 
  lmclass_t cl ;

  {
  cl = set->lmclass_list;
  while (cl) {
    lmclass_dump(cl, fp);
    cl = cl->next;
  }
  return;
}
}
lmclass_set_t lmclass_newset(void) 
{ 
  lmclass_set_t set ;
  void *tmp ;

  {
  tmp = __ckd_calloc__((size_t )1, sizeof(struct lmclass_set_s ), "lmclass.c", 86);
  set = (lmclass_set_t )tmp;
  set->lmclass_list = (lmclass_t )((void *)0);
  return (set);
}
}
static lmclass_set_t lmclass_add(lmclass_set_t set , lmclass_t new ) 
{ 
  lmclass_t cl ;
  lmclass_t prev ;
  int tmp ;

  {
  prev = (lmclass_t )((void *)0);
  cl = set->lmclass_list;
  while (1) {
    if (cl) {
      tmp = strcmp((char const   *)cl->name, (char const   *)new->name);
      if (! (tmp != 0)) {
        break;
      }
    } else {
      break;
    }
    prev = cl;
    cl = cl->next;
  }
  if (cl) {
    return ((lmclass_set_t )((void *)0));
  }
  if (prev) {
    prev->next = new;
  } else {
    set->lmclass_list = new;
  }
  new->next = (struct lmclass_s *)((void *)0);
  return (set);
}
}
static lmclass_t lmclass_addword(lmclass_t class , lmclass_word_t new ) 
{ 
  lmclass_word_t w___0 ;
  lmclass_word_t prev ;
  int tmp ;

  {
  prev = (lmclass_word_t )((void *)0);
  w___0 = class->wordlist;
  while (1) {
    if (w___0) {
      tmp = strcmp((char const   *)w___0->word, (char const   *)new->word);
      if (! (tmp != 0)) {
        break;
      }
    } else {
      break;
    }
    prev = w___0;
    w___0 = w___0->next;
  }
  if (w___0) {
    return ((lmclass_t )((void *)0));
  }
  if (prev) {
    prev->next = new;
  } else {
    class->wordlist = new;
  }
  new->next = (struct lmclass_word_s *)((void *)0);
  return (class);
}
}
lmclass_set_t lmclass_loadfile(lmclass_set_t lmclass_set , char *file ) 
{ 
  FILE *fp ;
  char line[16384] ;
  char *word[4096] ;
  char *_eof ;
  int32 lineno ;
  int32 nwd ;
  lmclass_t lmclass ;
  lmclass_word_t lmclass_word ;
  float SUMp ;
  float p ;
  int32 n_implicit_prob ;
  int32 n_word ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int32 LOGp ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int32 LOGp___0 ;

  {
  _E__pr_info_header("lmclass.c", 150L, "INFO");
  _E__pr_info("Reading LM Class file \'%s\'\n", file);
  fp = _myfopen(file, (char *)"r", (char *)"lmclass.c", 151);
  lineno = 0;
  while (1) {
    while (1) {
      _eof = fgets(line, (int )sizeof(line), fp);
      if ((unsigned long )_eof != (unsigned long )((void *)0)) {
        if (! ((int )line[0] == 35)) {
          nwd = str2words(line, word, 4096);
          if (! (nwd == 0)) {
            break;
          }
        }
      } else {
        break;
      }
      lineno ++;
    }
    if (! _eof) {
      break;
    }
    lineno ++;
    if (nwd < 0) {
      _E__pr_header("lmclass.c", 166L, "FATAL_ERROR");
      _E__die_error("Line %d: Line too long:\n\t%s\n", lineno, line);
    }
    if (nwd != 2) {
      _E__pr_header("lmclass.c", 169L, "FATAL_ERROR");
      _E__die_error("Line %d: Expecting LMCLASS <classname>\n", lineno);
    } else {
      tmp = strcmp((char const   *)word[0], "LMCLASS");
      if (tmp != 0) {
        _E__pr_header("lmclass.c", 169L, "FATAL_ERROR");
        _E__die_error("Line %d: Expecting LMCLASS <classname>\n", lineno);
      }
    }
    if ((int )*(word[1] + 0) != 91) {
      _E__pr_header("lmclass.c", 172L, "WARNING");
      _E__pr_warn("Line %d: LM class name(%s) not enclosed in []\n", lineno, word[1]);
    } else {
      tmp___0 = strlen((char const   *)word[1]);
      if ((int )*(word[1] + (tmp___0 - 1UL)) != 93) {
        _E__pr_header("lmclass.c", 172L, "WARNING");
        _E__pr_warn("Line %d: LM class name(%s) not enclosed in []\n", lineno, word[1]);
      }
    }
    tmp___1 = __ckd_calloc__((size_t )1, sizeof(struct lmclass_s ), "lmclass.c", 176);
    lmclass = (lmclass_t )tmp___1;
    lmclass->name = __ckd_salloc__((char const   *)word[1], "lmclass.c", 177);
    lmclass->wordlist = (lmclass_word_t )((void *)0);
    lmclass_set = lmclass_add(lmclass_set, lmclass);
    if ((unsigned long )lmclass_set == (unsigned long )((void *)0)) {
      _E__pr_header("lmclass.c", 183L, "FATAL_ERROR");
      _E__die_error("Line %d: lmclass_add(%s) failed (duplicate?)\n", lineno, word[1]);
    }
    SUMp = (float )0.0;
    n_implicit_prob = 0;
    n_word = 0;
    while (1) {
      LOGp = 0;
      while (1) {
        _eof = fgets(line, (int )sizeof(line), fp);
        if ((unsigned long )_eof != (unsigned long )((void *)0)) {
          if (! ((int )line[0] == 35)) {
            nwd = str2words(line, word, 4096);
            if (! (nwd == 0)) {
              break;
            }
          }
        } else {
          break;
        }
        lineno ++;
      }
      if (! _eof) {
        _E__pr_header("lmclass.c", 197L, "FATAL_ERROR");
        _E__die_error("Premature EOF(%s)\n", file);
      }
      lineno ++;
      if (nwd != 1) {
        if (nwd != 2) {
          _E__pr_header("lmclass.c", 201L, "FATAL_ERROR");
          _E__die_error("Line %d: Syntax error\n", lineno);
        }
      }
      if (nwd == 2) {
        tmp___2 = strcmp((char const   *)word[0], "END");
        if (tmp___2 == 0) {
          tmp___3 = strcmp((char const   *)word[1], (char const   *)lmclass->name);
          if (tmp___3 == 0) {
            break;
          }
        }
      }
      if (nwd == 2) {
        tmp___4 = sscanf((char const   *)word[1], "%e", & p);
        if (tmp___4 == 1) {
          if ((double )p <= 0.0) {
            _E__pr_header("lmclass.c", 211L, "FATAL_ERROR");
            _E__die_error("Line %d: Prob(%s) out of range (0,1)\n", lineno, word[1]);
          } else
          if ((double )p >= 1.0) {
            _E__pr_header("lmclass.c", 211L, "FATAL_ERROR");
            _E__die_error("Line %d: Prob(%s) out of range (0,1)\n", lineno, word[1]);
          }
          LOGp = logs3((float64 )p);
          SUMp += p;
        } else {
          _E__pr_header("lmclass.c", 216L, "FATAL_ERROR");
          _E__die_error("Line %d: Syntax error\n", lineno);
        }
      } else {
        LOGp = 32001;
        n_implicit_prob ++;
      }
      tmp___5 = __ckd_calloc__((size_t )1, sizeof(struct lmclass_word_s ), "lmclass.c",
                               223);
      lmclass_word = (lmclass_word_t )tmp___5;
      lmclass_word->word = __ckd_salloc__((char const   *)word[0], "lmclass.c", 224);
      lmclass_word->dictwid = -1;
      lmclass_word->LOGprob = LOGp;
      lmclass = lmclass_addword(lmclass, lmclass_word);
      if ((unsigned long )lmclass == (unsigned long )((void *)0)) {
        _E__pr_header("lmclass.c", 230L, "FATAL_ERROR");
        _E__die_error("Line %d: lmclass_addword(%s) failed (duplicate?)\n", lineno,
                      word[0]);
      }
      n_word ++;
    }
    if (n_implicit_prob > 0) {
      if ((double )SUMp >= 1.0) {
        _E__pr_header("lmclass.c", 239L, "FATAL_ERROR");
        _E__die_error("Sum(prob)(LMClass %s) = %e\n", lmclass->name, (double )SUMp);
      }
      p = (float )((1.0 - (double )SUMp) / (double )((float )n_implicit_prob));
      LOGp___0 = logs3((float64 )p);
      lmclass_word = lmclass->wordlist;
      while (lmclass_word) {
        if (lmclass_word->LOGprob == 32001) {
          lmclass_word->LOGprob = LOGp___0;
        }
        lmclass_word = lmclass_word->next;
      }
    } else
    if ((double )SUMp >= 1.1) {
      _E__pr_info_header("lmclass.c", 253L, "INFO");
      _E__pr_info("Sum(prob)(LMClass %s) = %e\n", lmclass->name, (double )SUMp);
    } else
    if ((double )SUMp <= 0.9) {
      _E__pr_info_header("lmclass.c", 253L, "INFO");
      _E__pr_info("Sum(prob)(LMClass %s) = %e\n", lmclass->name, (double )SUMp);
    }
    _E__pr_info_header("lmclass.c", 256L, "INFO");
    _E__pr_info("Loaded LM Class \'%s\'; %d words\n", lmclass->name, n_word);
  }
  fclose(fp);
  return (lmclass_set);
}
}
void lmclass_set_dictwid(lmclass_word_t w___0 , int32 dictwid ) 
{ 


  {
  w___0->dictwid = dictwid;
  return;
}
}
lmclass_t lmclass_get_lmclass(lmclass_set_t set , char *name ) 
{ 
  lmclass_t cl ;
  int tmp ;

  {
  cl = set->lmclass_list;
  while (1) {
    if (cl) {
      tmp = strcmp((char const   *)cl->name, (char const   *)name);
      if (! (tmp != 0)) {
        break;
      }
    } else {
      break;
    }
    cl = cl->next;
  }
  return (cl);
}
}
int32 lmclass_get_nclass(lmclass_set_t set ) 
{ 
  lmclass_t cl ;
  int32 n ;

  {
  n = 0;
  cl = set->lmclass_list;
  while (cl) {
    cl = cl->next;
    n ++;
  }
  return (n);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-aJTfPKJc.i","-O3")
extern double exp(double  ) ;
extern double log10(double  ) ;
extern double pow(double  , double  ) ;
int32 log_to_logs3(float64 logp ) ;
float64 logs3_to_p(int32 logs3p ) ;
static int USE_LOG3_ADD_TABLE  =    1;
static float64 F  =    (float64 )0;
static float64 B  ;
static float64 logB  ;
static float64 invlogB  ;
static float64 invlog10B  ;
static uint16 *add_tbl  =    (uint16 *)((void *)0);
static int32 add_tbl_size  ;
int32 logs3_init(float64 base ) 
{ 
  int32 i ;
  int32 k___0 ;
  float64 d ;
  float64 t ;
  float64 f ;
  void const   *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  void *tmp___3 ;
  double tmp___4 ;

  {
  tmp = cmd_ln_access((char *)"-log3table");
  USE_LOG3_ADD_TABLE = *((int32 *)tmp);
  _E__pr_info_header("logs3.c", 99L, "INFO");
  _E__pr_info("Initializing logbase: %e (add table: %d)\n", base, USE_LOG3_ADD_TABLE);
  if (base <= 1.0) {
    _E__pr_header("logs3.c", 102L, "FATAL_ERROR");
    _E__die_error("Illegal logbase: %e; must be > 1.0\n", base);
  }
  if (add_tbl) {
    if (B == base) {
      _E__pr_header("logs3.c", 106L, "WARNING");
      _E__pr_warn("logs3_init() already done\n");
    } else {
      _E__pr_header("logs3.c", 108L, "FATAL_ERROR");
      _E__die_error("logs3_init() already done with base %e\n", B);
    }
  }
  B = base;
  logB = log(base);
  invlogB = 1.0 / logB;
  tmp___0 = log10(base);
  invlog10B = 1.0 / tmp___0;
  tmp___1 = log(2.0);
  k___0 = (int32 )(tmp___1 * invlogB + 0.5);
  if (k___0 > 65535) {
    _E__pr_header("logs3.c", 120L, "ERROR");
    _E__pr_warn("Logbase too small: %e; needs int32 addtable[]\n", base);
    return (-1);
  }
  d = 1.0;
  f = 1.0 / B;
  F = 1.0 / B;
  i = 0;
  while (1) {
    tmp___2 = log(1.0 + d);
    t = tmp___2 * invlogB;
    k___0 = (int32 )(t + 0.5);
    if (k___0 == 0) {
      break;
    }
    d *= f;
    i ++;
  }
  add_tbl_size = i + 1;
  tmp___3 = __ckd_calloc__((size_t )(i + 1), sizeof(uint16 ), "logs3.c", 145);
  add_tbl = (uint16 *)tmp___3;
  d = 1.0;
  i = 0;
  while (1) {
    tmp___4 = log(1.0 + d);
    t = tmp___4 * invlogB;
    k___0 = (int32 )(t + 0.5);
    *(add_tbl + i) = (uint16 )k___0;
    if (k___0 == 0) {
      break;
    }
    d *= f;
    i ++;
  }
  _E__pr_info_header("logs3.c", 161L, "INFO");
  _E__pr_info("Log-Add table size = %d\n", add_tbl_size);
  return (0);
}
}
int32 logs3_add(int32 logp , int32 logq ) 
{ 
  int32 d ;
  int32 r ;
  double tmp ;
  double tmp___0 ;

  {
  if (logp > logq) {
    d = logp - logq;
    r = logp;
  } else {
    d = logq - logp;
    r = logq;
  }
  if (d < add_tbl_size) {
    if (USE_LOG3_ADD_TABLE) {
      r += (int32 )*(add_tbl + d);
    } else {
      tmp = pow(F, (double )d);
      tmp___0 = log(1.0 + tmp);
      r = (int32 )((double )r + (0.5 + tmp___0 * invlogB));
    }
  }
  return (r);
}
}
int32 logs3(float64 p ) 
{ 
  double tmp ;

  {
  if (! add_tbl) {
    _E__pr_header("logs3.c", 200L, "FATAL_ERROR");
    _E__die_error("logs3 module not initialized\n");
  }
  if (p <= 0.0) {
    return ((int32 )3355443200U);
  }
  tmp = log(p);
  return ((int32 )(tmp * invlogB));
}
}
int32 log_to_logs3(float64 logp ) 
{ 


  {
  if (! add_tbl) {
    _E__pr_header("logs3.c", 216L, "FATAL_ERROR");
    _E__die_error("logs3 module not initialized\n");
  }
  return ((int32 )(logp * invlogB));
}
}
float64 log_to_logs3_factor(void) 
{ 


  {
  return (invlogB);
}
}
float64 logs3_to_log(int32 logs3p ) 
{ 


  {
  if (! add_tbl) {
    _E__pr_header("logs3.c", 231L, "FATAL_ERROR");
    _E__die_error("logs3 module not initialized\n");
  }
  return ((float64 )logs3p * logB);
}
}
float64 logs3_to_p(int32 logs3p ) 
{ 
  double tmp ;

  {
  tmp = exp((float64 )logs3p * logB);
  return (tmp);
}
}
int32 log10_to_logs3(float64 log10p ) 
{ 


  {
  if (! add_tbl) {
    _E__pr_header("logs3.c", 246L, "FATAL_ERROR");
    _E__die_error("logs3 module not initialized\n");
  }
  return ((int32 )(log10p * invlog10B));
}
}
void logs_free(void) 
{ 


  {
  if (add_tbl) {
    ckd_free((void *)add_tbl);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-jNuTdvTI.i","-O3")
int32 mdef_is_ciphone(mdef_t *m , s3pid_t p ) ;
int32 mdef_phone_str(mdef_t *m , s3pid_t pid , char *buf ) ;
int32 mdef_phone_components(mdef_t *m , s3pid_t p , s3cipid_t *b , s3cipid_t *l ,
                            s3cipid_t *r , word_posn_t *pos ) ;
void mdef_sseq2sen_active(mdef_t *mdef , int32 *sseq , int32 *sen ) ;
void mdef_dump(FILE *fp , mdef_t *m ) ;
void mdef_free_recursive_lc(ph_lc_t *lc ) ;
void mdef_free_recursive_rc(ph_rc_t *rc ) ;
void mdef_dump(FILE *fp , mdef_t *m ) 
{ 
  int32 i ;
  int32 j ;
  int32 ssid ;
  char buf[1024] ;

  {
  fprintf(fp, "%d ciphone\n", m->n_ciphone);
  fprintf(fp, "%d phone\n", m->n_phone);
  fprintf(fp, "%d emitstate\n", m->n_emit_state);
  fprintf(fp, "%d cisen\n", m->n_ci_sen);
  fprintf(fp, "%d sen\n", m->n_sen);
  fprintf(fp, "%d tmat\n", m->n_tmat);
  i = 0;
  while (i < m->n_phone) {
    mdef_phone_str(m, i, buf);
    ssid = (m->phone + i)->ssid;
    fprintf(fp, "%3d %5d", (m->phone + i)->tmat, ssid);
    j = 0;
    while (j < m->n_emit_state) {
      fprintf(fp, " %5d", (int )*(*(m->sseq + ssid) + j));
      j ++;
    }
    fprintf(fp, "\t");
    j = 0;
    while (j < m->n_emit_state) {
      fprintf(fp, " %3d", (int )*(m->cd2cisen + *(*(m->sseq + ssid) + j)));
      j ++;
    }
    fprintf(fp, "\t%s\n", buf);
    i ++;
  }
  fflush(fp);
  return;
}
}
static void ciphone_add(mdef_t *m , char *ci , s3pid_t p ) 
{ 
  char *tmp ;
  int32 tmp___0 ;

  {
  tmp = __ckd_salloc__((char const   *)ci, "mdef.c", 138);
  (m->ciphone + p)->name = tmp;
  tmp___0 = hash_enter(m->ciphone_ht, (char const   *)(m->ciphone + p)->name, p);
  if (tmp___0 != p) {
    _E__pr_header("mdef.c", 140L, "FATAL_ERROR");
    _E__die_error("hash_enter(%s) failed; duplicate CIphone?\n", (m->ciphone + p)->name);
  }
  return;
}
}
static ph_lc_t *find_ph_lc(ph_lc_t *lclist , s3cipid_t lc ) 
{ 
  ph_lc_t *lcptr ;

  {
  lcptr = lclist;
  while (1) {
    if (lcptr) {
      if (! ((int )lcptr->lc != (int )lc)) {
        break;
      }
    } else {
      break;
    }
    lcptr = lcptr->next;
  }
  return (lcptr);
}
}
static ph_rc_t *find_ph_rc(ph_rc_t *rclist , s3cipid_t rc ) 
{ 
  ph_rc_t *rcptr ;

  {
  rcptr = rclist;
  while (1) {
    if (rcptr) {
      if (! ((int )rcptr->rc != (int )rc)) {
        break;
      }
    } else {
      break;
    }
    rcptr = rcptr->next;
  }
  return (rcptr);
}
}
static void triphone_add(mdef_t *m , s3cipid_t ci , s3cipid_t lc , s3cipid_t rc ,
                         word_posn_t wpos , s3pid_t p ) 
{ 
  ph_lc_t *lcptr ;
  ph_rc_t *rcptr ;
  void *tmp ;
  char buf[4096] ;
  void *tmp___0 ;

  {
  (m->phone + p)->ci = ci;
  (m->phone + p)->lc = lc;
  (m->phone + p)->rc = rc;
  (m->phone + p)->wpos = wpos;
  if (p >= m->n_ciphone) {
    lcptr = find_ph_lc(*(*(m->wpos_ci_lclist + wpos) + (int )ci), lc);
    if ((unsigned long )lcptr == (unsigned long )((void *)0)) {
      tmp = __ckd_calloc__((size_t )1, sizeof(ph_lc_t ), "mdef.c", 182);
      lcptr = (ph_lc_t *)tmp;
      lcptr->lc = lc;
      lcptr->next = *(*(m->wpos_ci_lclist + wpos) + (int )ci);
      *(*(m->wpos_ci_lclist + wpos) + (int )ci) = lcptr;
    }
    rcptr = find_ph_rc(lcptr->rclist, rc);
    if ((unsigned long )rcptr != (unsigned long )((void *)0)) {
      mdef_phone_str(m, rcptr->pid, buf);
      _E__pr_header("mdef.c", 191L, "FATAL_ERROR");
      _E__die_error("Duplicate triphone: %s\n", buf);
    }
    tmp___0 = __ckd_calloc__((size_t )1, sizeof(ph_rc_t ), "mdef.c", 194);
    rcptr = (ph_rc_t *)tmp___0;
    rcptr->rc = rc;
    rcptr->pid = p;
    rcptr->next = lcptr->rclist;
    lcptr->rclist = rcptr;
  }
  return;
}
}
s3cipid_t mdef_ciphone_id(mdef_t *m , char *ci ) 
{ 
  int32 id ;
  int32 tmp ;

  {
  tmp = hash_lookup(m->ciphone_ht, (char const   *)ci, & id);
  if (tmp < 0) {
    return ((s3cipid_t )-1);
  }
  return ((s3cipid_t )id);
}
}
char const   *mdef_ciphone_str(mdef_t *m , s3cipid_t id ) 
{ 


  {
  return ((char const   *)(m->ciphone + (int )id)->name);
}
}
int32 mdef_phone_str(mdef_t *m , s3pid_t pid , char *buf ) 
{ 
  char *wpos_name ;
  char const   *tmp ;
  unsigned long tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  unsigned long tmp___4 ;

  {
  wpos_name = (char *)"besiu";
  *(buf + 0) = (char )'\000';
  if (pid < m->n_ciphone) {
    tmp = mdef_ciphone_str(m, (s3cipid_t )pid);
    tmp___0 = __builtin_object_size((void *)buf, 1);
    __builtin___sprintf_chk(buf, 0, tmp___0, "%s", tmp);
  } else {
    tmp___1 = mdef_ciphone_str(m, (m->phone + pid)->rc);
    tmp___2 = mdef_ciphone_str(m, (m->phone + pid)->lc);
    tmp___3 = mdef_ciphone_str(m, (m->phone + pid)->ci);
    tmp___4 = __builtin_object_size((void *)buf, 1);
    __builtin___sprintf_chk(buf, 0, tmp___4, "(%s,%s,%s,%c)", tmp___3, tmp___2, tmp___1,
                            (int )*(wpos_name + (m->phone + pid)->wpos));
  }
  return (0);
}
}
s3pid_t mdef_phone_id(mdef_t *m , s3cipid_t ci , s3cipid_t lc , s3cipid_t rc , word_posn_t wpos ) 
{ 
  ph_lc_t *lcptr ;
  ph_rc_t *rcptr ;
  s3cipid_t newl ;
  s3cipid_t newr ;
  s3pid_t tmp ;

  {
  lcptr = find_ph_lc(*(*(m->wpos_ci_lclist + wpos) + (int )ci), lc);
  if ((unsigned long )lcptr == (unsigned long )((void *)0)) {
    goto _L;
  } else {
    rcptr = find_ph_rc(lcptr->rclist, rc);
    if ((unsigned long )rcptr == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      if ((int )m->sil < 0) {
        return (-1);
      }
      if ((m->ciphone + (int )lc)->filler) {
        newl = m->sil;
      } else {
        newl = lc;
      }
      if ((m->ciphone + (int )rc)->filler) {
        newr = m->sil;
      } else {
        newr = rc;
      }
      if ((int )newl == (int )lc) {
        if ((int )newr == (int )rc) {
          return (-1);
        }
      }
      tmp = mdef_phone_id(m, ci, newl, newr, wpos);
      return (tmp);
    }
  }
  return (rcptr->pid);
}
}
s3pid_t mdef_phone_id_nearest(mdef_t *m , s3cipid_t b , s3cipid_t l , s3cipid_t r ,
                              word_posn_t pos ) 
{ 
  word_posn_t tmppos ;
  s3pid_t p ;
  s3cipid_t newl ;
  s3cipid_t newr ;
  char *wpos_name ;

  {
  if ((int )l < 0) {
    return ((s3pid_t )b);
  } else
  if ((int )r < 0) {
    return ((s3pid_t )b);
  }
  p = mdef_phone_id(m, b, l, r, pos);
  if (p >= 0) {
    return (p);
  }
  tmppos = (word_posn_t )0;
  while ((unsigned int )tmppos < 4U) {
    if ((unsigned int )tmppos != (unsigned int )pos) {
      p = mdef_phone_id(m, b, l, r, tmppos);
      if (p >= 0) {
        return (p);
      }
    }
    tmppos = (word_posn_t )((unsigned int )tmppos + 1U);
  }
  if ((int )m->sil >= 0) {
    if ((m->ciphone + (int )l)->filler) {
      newl = m->sil;
    } else {
      newl = l;
    }
    if ((m->ciphone + (int )r)->filler) {
      newr = m->sil;
    } else {
      newr = r;
    }
    if ((int )newl != (int )l) {
      goto _L;
    } else
    if ((int )newr != (int )r) {
      _L: /* CIL Label */ 
      p = mdef_phone_id(m, b, newl, newr, pos);
      if (p >= 0) {
        return (p);
      }
      tmppos = (word_posn_t )0;
      while ((unsigned int )tmppos < 4U) {
        if ((unsigned int )tmppos != (unsigned int )pos) {
          p = mdef_phone_id(m, b, newl, newr, tmppos);
          if (p >= 0) {
            return (p);
          }
        }
        tmppos = (word_posn_t )((unsigned int )tmppos + 1U);
      }
    }
  }
  if (m->n_phone > m->n_ciphone) {
    if (! (m->ciphone + (int )b)->filler) {
      wpos_name = (char *)"besiu";
    }
  }
  return ((s3pid_t )b);
}
}
int32 mdef_phone_components(mdef_t *m , s3pid_t p , s3cipid_t *b , s3cipid_t *l ,
                            s3cipid_t *r , word_posn_t *pos ) 
{ 


  {
  *b = (m->phone + p)->ci;
  *l = (m->phone + p)->lc;
  *r = (m->phone + p)->rc;
  *pos = (m->phone + p)->wpos;
  return (0);
}
}
int32 mdef_is_ciphone(mdef_t *m , s3pid_t p ) 
{ 
  int tmp ;

  {
  if (p < m->n_ciphone) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static void parse_tmat_senmap(mdef_t *m , char *line , int32 off , s3pid_t p ) 
{ 
  int32 wlen ;
  int32 n ;
  int32 s___0 ;
  char word[1024] ;
  char *lp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  lp = line + off;
  tmp = sscanf((char const   *)lp, "%d%n", & n, & wlen);
  if (tmp != 1) {
    _E__pr_header("mdef.c", 381L, "FATAL_ERROR");
    _E__die_error("Missing or bad transition matrix id: %s\n", line);
  } else
  if (n < 0) {
    _E__pr_header("mdef.c", 381L, "FATAL_ERROR");
    _E__die_error("Missing or bad transition matrix id: %s\n", line);
  }
  (m->phone + p)->tmat = n;
  if (m->n_tmat <= n) {
    _E__pr_header("mdef.c", 384L, "FATAL_ERROR");
    _E__die_error("tmat-id(%d) > #tmat in header(%d): %s\n", n, m->n_tmat, line);
  }
  lp += wlen;
  n = 0;
  while (n < m->n_emit_state) {
    tmp___0 = sscanf((char const   *)lp, "%d%n", & s___0, & wlen);
    if (tmp___0 != 1) {
      _E__pr_header("mdef.c", 390L, "FATAL_ERROR");
      _E__die_error("Missing or bad state[%d]->senone mapping: %s\n", n, line);
    } else
    if (s___0 < 0) {
      _E__pr_header("mdef.c", 390L, "FATAL_ERROR");
      _E__die_error("Missing or bad state[%d]->senone mapping: %s\n", n, line);
    }
    if (p < m->n_ciphone) {
      if (m->n_ci_sen <= s___0) {
        _E__pr_header("mdef.c", 392L, "FATAL_ERROR");
        _E__die_error("CI-senone-id(%d) > #CI-senones(%d): %s\n", s___0, m->n_ci_sen,
                      line);
      }
    }
    if (m->n_sen <= s___0) {
      _E__pr_header("mdef.c", 394L, "FATAL_ERROR");
      _E__die_error("Senone-id(%d) > #senones(%d): %s\n", s___0, m->n_sen, line);
    }
    *(*(m->sseq + p) + n) = (s3senid_t )s___0;
    lp += wlen;
    n ++;
  }
  tmp___1 = sscanf((char const   *)lp, "%s%n", word, & wlen);
  if (tmp___1 != 1) {
    _E__pr_header("mdef.c", 402L, "FATAL_ERROR");
    _E__die_error("Missing non-emitting state spec: %s\n", line);
  } else {
    tmp___2 = strcmp((char const   *)(word), "N");
    if (tmp___2 != 0) {
      _E__pr_header("mdef.c", 402L, "FATAL_ERROR");
      _E__die_error("Missing non-emitting state spec: %s\n", line);
    }
  }
  lp += wlen;
  tmp___3 = sscanf((char const   *)lp, "%s%n", word, & wlen);
  if (tmp___3 == 1) {
    _E__pr_header("mdef.c", 407L, "FATAL_ERROR");
    _E__die_error("Non-empty beyond non-emitting final state: %s\n", line);
  }
  return;
}
}
static void parse_base_line(mdef_t *m , char *line , s3pid_t p ) 
{ 
  int32 wlen ;
  int32 n ;
  char word[1024] ;
  char *lp ;
  s3cipid_t ci ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  lp = line;
  tmp = sscanf((char const   *)lp, "%s%n", word, & wlen);
  if (tmp != 1) {
    _E__pr_header("mdef.c", 421L, "FATAL_ERROR");
    _E__die_error("Missing base phone name: %s\n", line);
  }
  lp += wlen;
  ci = mdef_ciphone_id(m, word);
  if ((int )ci >= 0) {
    _E__pr_header("mdef.c", 427L, "FATAL_ERROR");
    _E__die_error("Duplicate base phone: %s\n", line);
  }
  ciphone_add(m, word, p);
  ci = (s3cipid_t )p;
  n = 0;
  while (n < 3) {
    tmp___0 = sscanf((char const   *)lp, "%s%n", word, & wlen);
    if (tmp___0 != 1) {
      _E__pr_header("mdef.c", 436L, "FATAL_ERROR");
      _E__die_error("Bad context info for base phone: %s\n", line);
    } else {
      tmp___1 = strcmp((char const   *)(word), "-");
      if (tmp___1 != 0) {
        _E__pr_header("mdef.c", 436L, "FATAL_ERROR");
        _E__die_error("Bad context info for base phone: %s\n", line);
      }
    }
    lp += wlen;
    n ++;
  }
  tmp___2 = sscanf((char const   *)lp, "%s%n", word, & wlen);
  if (tmp___2 != 1) {
    _E__pr_header("mdef.c", 442L, "FATAL_ERROR");
    _E__die_error("Missing filler atribute field: %s\n", line);
  }
  lp += wlen;
  tmp___4 = strcmp((char const   *)(word), "filler");
  if (tmp___4 == 0) {
    (m->ciphone + (int )ci)->filler = 1;
  } else {
    tmp___3 = strcmp((char const   *)(word), "n/a");
    if (tmp___3 == 0) {
      (m->ciphone + (int )ci)->filler = 0;
    } else {
      _E__pr_header("mdef.c", 449L, "FATAL_ERROR");
      _E__die_error("Bad filler attribute field: %s\n", line);
    }
  }
  triphone_add(m, ci, (s3cipid_t )-1, (s3cipid_t )-1, (word_posn_t )4, p);
  parse_tmat_senmap(m, line, (int32 )(lp - line), p);
  return;
}
}
static void parse_tri_line(mdef_t *m , char *line , s3pid_t p ) 
{ 
  int32 wlen ;
  char word[1024] ;
  char *lp ;
  s3cipid_t ci ;
  s3cipid_t lc ;
  s3cipid_t rc ;
  word_posn_t wpos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  wpos = (word_posn_t )0;
  lp = line;
  tmp = sscanf((char const   *)lp, "%s%n", word, & wlen);
  if (tmp != 1) {
    _E__pr_header("mdef.c", 469L, "FATAL_ERROR");
    _E__die_error("Missing base phone name: %s\n", line);
  }
  lp += wlen;
  ci = mdef_ciphone_id(m, word);
  if ((int )ci < 0) {
    _E__pr_header("mdef.c", 474L, "FATAL_ERROR");
    _E__die_error("Unknown base phone: %s\n", line);
  }
  tmp___0 = sscanf((char const   *)lp, "%s%n", word, & wlen);
  if (tmp___0 != 1) {
    _E__pr_header("mdef.c", 478L, "FATAL_ERROR");
    _E__die_error("Missing left context: %s\n", line);
  }
  lp += wlen;
  lc = mdef_ciphone_id(m, word);
  if ((int )lc < 0) {
    _E__pr_header("mdef.c", 482L, "FATAL_ERROR");
    _E__die_error("Unknown left context: %s\n", line);
  }
  tmp___1 = sscanf((char const   *)lp, "%s%n", word, & wlen);
  if (tmp___1 != 1) {
    _E__pr_header("mdef.c", 486L, "FATAL_ERROR");
    _E__die_error("Missing right context: %s\n", line);
  }
  lp += wlen;
  rc = mdef_ciphone_id(m, word);
  if ((int )rc < 0) {
    _E__pr_header("mdef.c", 490L, "FATAL_ERROR");
    _E__die_error("Unknown right  context: %s\n", line);
  }
  tmp___2 = sscanf((char const   *)lp, "%s%n", word, & wlen);
  if (tmp___2 != 1) {
    _E__pr_header("mdef.c", 494L, "FATAL_ERROR");
    _E__die_error("Missing or bad word-position spec: %s\n", line);
  } else
  if ((int )word[1] != 0) {
    _E__pr_header("mdef.c", 494L, "FATAL_ERROR");
    _E__die_error("Missing or bad word-position spec: %s\n", line);
  }
  lp += wlen;
  switch ((int )word[0]) {
  case 98: 
  wpos = (word_posn_t )0;
  break;
  case 101: 
  wpos = (word_posn_t )1;
  break;
  case 115: 
  wpos = (word_posn_t )2;
  break;
  case 105: 
  wpos = (word_posn_t )3;
  break;
  default: 
  _E__pr_header("mdef.c", 501L, "FATAL_ERROR");
  _E__die_error("Bad word-position spec: %s\n", line);
  }
  tmp___3 = sscanf((char const   *)lp, "%s%n", word, & wlen);
  if (tmp___3 != 1) {
    _E__pr_header("mdef.c", 506L, "FATAL_ERROR");
    _E__die_error("Missing filler attribute field: %s\n", line);
  }
  lp += wlen;
  tmp___4 = strcmp((char const   *)(word), "filler");
  if (tmp___4 == 0) {
    if (! (m->ciphone + (int )ci)->filler) {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___5 = strcmp((char const   *)(word), "n/a");
    if (tmp___5 == 0) {
      if (! (! (m->ciphone + (int )ci)->filler)) {
        _E__pr_header("mdef.c", 512L, "FATAL_ERROR");
        _E__die_error("Bad filler attribute field: %s\n", line);
      }
    } else {
      _E__pr_header("mdef.c", 512L, "FATAL_ERROR");
      _E__die_error("Bad filler attribute field: %s\n", line);
    }
  }
  triphone_add(m, ci, lc, rc, wpos, p);
  parse_tmat_senmap(m, line, (int32 )(lp - line), p);
  return;
}
}
static void sseq_compress(mdef_t *m ) 
{ 
  hash_table_t *h ;
  s3senid_t **sseq ;
  int32 n_sseq ;
  int32 p ;
  int32 j ;
  int32 k___0 ;
  glist_t g ;
  gnode_t *gn ;
  hash_entry_t *he ;
  void **tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  k___0 = (int32 )((unsigned long )m->n_emit_state * sizeof(s3senid_t ));
  h = hash_new(m->n_phone, 0);
  n_sseq = 0;
  p = 0;
  while (p < m->n_phone) {
    j = hash_enter_bkey(h, (char const   *)((char *)*(m->sseq + p)), k___0, n_sseq);
    if (j == n_sseq) {
      n_sseq ++;
    }
    (m->phone + p)->ssid = j;
    p ++;
  }
  tmp = __ckd_calloc_2d__(n_sseq, m->n_emit_state, (int32 )sizeof(s3senid_t ), "mdef.c",
                          546);
  sseq = (s3senid_t **)tmp;
  g = hash_tolist(h, & j);
  gn = g;
  while (gn) {
    he = (hash_entry_t *)gn->data.ptr;
    j = he->val;
    tmp___1 = __builtin_object_size((void *)*(sseq + j), 0);
    if (tmp___1 != 0xffffffffffffffffUL) {
      tmp___0 = __builtin_object_size((void *)*(sseq + j), 0);
      __builtin___memcpy_chk((void *)*(sseq + j), (void const   *)he->key, (unsigned long )k___0,
                             tmp___0);
    } else {
      __inline_memcpy_chk((void *)*(sseq + j), (void const   *)he->key, (size_t )k___0);
    }
    gn = gn->next;
  }
  glist_free(g);
  ckd_free_2d((void **)m->sseq);
  m->sseq = sseq;
  m->n_sseq = n_sseq;
  hash_free(h);
  return;
}
}
static int32 noncomment_line(char *line , int32 size , FILE *fp ) 
{ 
  char *tmp ;

  {
  while (1) {
    tmp = fgets(line, size, fp);
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
      break;
    }
    if ((int )*(line + 0) != 35) {
      return (0);
    }
  }
  return (-1);
}
}
mdef_t *mdef_init(char *mdeffile ) 
{ 
  FILE *fp ;
  int32 n_ci ;
  int32 n_tri ;
  int32 n_map ;
  int32 n ;
  char tag[1024] ;
  char buf[1024] ;
  s3senid_t **senmap ;
  s3pid_t p ;
  int32 s___0 ;
  int32 ci ;
  int32 cd ;
  mdef_t *m ;
  int32 *cdsen_start ;
  int32 *cdsen_end ;
  void *tmp ;
  int32 tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void **tmp___13 ;
  void **tmp___14 ;
  int32 tmp___15 ;
  int32 tmp___16 ;
  int32 tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;

  {
  if (! mdeffile) {
    _E__pr_header("mdef.c", 592L, "FATAL_ERROR");
    _E__die_error("No mdef-file\n");
  }
  _E__pr_info_header("mdef.c", 594L, "INFO");
  _E__pr_info("Reading model definition: %s\n", mdeffile);
  tmp = __ckd_calloc__((size_t )1, sizeof(mdef_t ), "mdef.c", 596);
  m = (mdef_t *)tmp;
  fp = fopen((char const   *)mdeffile, "r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    _E__pr_header("mdef.c", 599L, "SYSTEM_ERROR");
    _E__fatal_sys_error("fopen(%s,r) failed\n", mdeffile);
  }
  tmp___0 = noncomment_line(buf, (int32 )sizeof(buf), fp);
  if (tmp___0 < 0) {
    _E__pr_header("mdef.c", 602L, "FATAL_ERROR");
    _E__die_error("Empty file: %s\n", mdeffile);
  }
  tmp___1 = strlen("0.3");
  tmp___2 = strncmp((char const   *)(buf), "0.3", tmp___1);
  if (tmp___2 != 0) {
    _E__pr_header("mdef.c", 605L, "FATAL_ERROR");
    _E__die_error("Version error: Expecing %s, but read %s\n", "0.3", buf);
  }
  n_ci = -1;
  n_tri = -1;
  n_map = -1;
  m->n_ci_sen = -1;
  m->n_sen = -1;
  m->n_tmat = -1;
  while (1) {
    tmp___3 = noncomment_line(buf, (int32 )sizeof(buf), fp);
    if (tmp___3 < 0) {
      _E__pr_header("mdef.c", 616L, "FATAL_ERROR");
      _E__die_error("Incomplete header\n");
    }
    tmp___4 = sscanf((char const   *)(buf), "%d %s", & n, tag);
    if (tmp___4 != 2) {
      _E__pr_header("mdef.c", 619L, "FATAL_ERROR");
      _E__die_error("Error in header: %s\n", buf);
    } else
    if (n < 0) {
      _E__pr_header("mdef.c", 619L, "FATAL_ERROR");
      _E__die_error("Error in header: %s\n", buf);
    }
    tmp___10 = strcmp((char const   *)(tag), "n_base");
    if (tmp___10 == 0) {
      n_ci = n;
    } else {
      tmp___9 = strcmp((char const   *)(tag), "n_tri");
      if (tmp___9 == 0) {
        n_tri = n;
      } else {
        tmp___8 = strcmp((char const   *)(tag), "n_state_map");
        if (tmp___8 == 0) {
          n_map = n;
        } else {
          tmp___7 = strcmp((char const   *)(tag), "n_tied_ci_state");
          if (tmp___7 == 0) {
            m->n_ci_sen = n;
          } else {
            tmp___6 = strcmp((char const   *)(tag), "n_tied_state");
            if (tmp___6 == 0) {
              m->n_sen = n;
            } else {
              tmp___5 = strcmp((char const   *)(tag), "n_tied_tmat");
              if (tmp___5 == 0) {
                m->n_tmat = n;
              } else {
                _E__pr_header("mdef.c", 634L, "FATAL_ERROR");
                _E__die_error("Unknown header line: %s\n", buf);
              }
            }
          }
        }
      }
    }
    if (! (n_ci < 0)) {
      if (! (n_tri < 0)) {
        if (! (n_map < 0)) {
          if (! (m->n_ci_sen < 0)) {
            if (! (m->n_sen < 0)) {
              if (! (m->n_tmat < 0)) {
                break;
              }
            }
          }
        }
      }
    }
  }
  if (n_ci == 0) {
    _E__pr_header("mdef.c", 639L, "FATAL_ERROR");
    _E__die_error("%s: Error in header\n", mdeffile);
  } else
  if (m->n_ci_sen == 0) {
    _E__pr_header("mdef.c", 639L, "FATAL_ERROR");
    _E__die_error("%s: Error in header\n", mdeffile);
  } else
  if (m->n_tmat == 0) {
    _E__pr_header("mdef.c", 639L, "FATAL_ERROR");
    _E__die_error("%s: Error in header\n", mdeffile);
  } else
  if (m->n_ci_sen > m->n_sen) {
    _E__pr_header("mdef.c", 639L, "FATAL_ERROR");
    _E__die_error("%s: Error in header\n", mdeffile);
  }
  if (n_ci >= 127) {
    _E__pr_header("mdef.c", 643L, "FATAL_ERROR");
    _E__die_error("%s: #CI phones (%d) exceeds limit (%d)\n", mdeffile, n_ci, 127);
  }
  if (n_ci + n_tri >= 2147483646) {
    _E__pr_header("mdef.c", 645L, "FATAL_ERROR");
    _E__die_error("%s: #Phones (%d) exceeds limit (%d)\n", mdeffile, n_ci + n_tri,
                  2147483646);
  }
  if (m->n_sen >= 32766) {
    _E__pr_header("mdef.c", 647L, "FATAL_ERROR");
    _E__die_error("%s: #senones (%d) exceeds limit (%d)\n", mdeffile, m->n_sen, (int )((int16 )32766));
  }
  if (m->n_tmat >= 2147483646) {
    _E__pr_header("mdef.c", 649L, "FATAL_ERROR");
    _E__die_error("%s: #tmats (%d) exceeds limit (%d)\n", mdeffile, m->n_tmat, 2147483646);
  }
  m->n_emit_state = n_map / (n_ci + n_tri) - 1;
  if ((m->n_emit_state + 1) * (n_ci + n_tri) != n_map) {
    _E__pr_header("mdef.c", 653L, "FATAL_ERROR");
    _E__die_error("Header error: n_state_map not a multiple of n_ci*n_tri\n");
  }
  m->n_ciphone = n_ci;
  m->ciphone_ht = hash_new(n_ci, 1);
  tmp___11 = __ckd_calloc__((size_t )n_ci, sizeof(ciphone_t ), "mdef.c", 658);
  m->ciphone = (ciphone_t *)tmp___11;
  m->n_phone = n_ci + n_tri;
  tmp___12 = __ckd_calloc__((size_t )m->n_phone, sizeof(phone_t ), "mdef.c", 666);
  m->phone = (phone_t *)tmp___12;
  tmp___13 = __ckd_calloc_2d__(m->n_phone, m->n_emit_state, (int32 )sizeof(s3senid_t ),
                               "mdef.c", 669);
  senmap = (s3senid_t **)tmp___13;
  m->sseq = senmap;
  tmp___14 = __ckd_calloc_2d__(4, m->n_ciphone, (int32 )sizeof(ph_lc_t *), "mdef.c",
                               673);
  m->wpos_ci_lclist = (ph_lc_t ***)tmp___14;
  p = 0;
  while (p < n_ci) {
    tmp___15 = noncomment_line(buf, (int32 )sizeof(buf), fp);
    if (tmp___15 < 0) {
      _E__pr_header("mdef.c", 683L, "FATAL_ERROR");
      _E__die_error("Premature EOF reading CIphone %d\n", p);
    }
    parse_base_line(m, buf, p);
    p ++;
  }
  m->sil = mdef_ciphone_id(m, (char *)"SIL");
  while (p < m->n_phone) {
    tmp___16 = noncomment_line(buf, (int32 )sizeof(buf), fp);
    if (tmp___16 < 0) {
      _E__pr_header("mdef.c", 691L, "FATAL_ERROR");
      _E__die_error("Premature EOF reading phone %d\n", p);
    }
    parse_tri_line(m, buf, p);
    p ++;
  }
  tmp___17 = noncomment_line(buf, (int32 )sizeof(buf), fp);
  if (tmp___17 >= 0) {
    _E__pr_header("mdef.c", 696L, "ERROR");
    _E__pr_warn("Non-empty file beyond expected #phones (%d)\n", m->n_phone);
  }
  if (m->n_ciphone * m->n_emit_state != m->n_ci_sen) {
    _E__pr_header("mdef.c", 700L, "FATAL_ERROR");
    _E__die_error("#CI-senones(%d) != #CI-phone(%d) x #emitting-states(%d)\n", m->n_ci_sen,
                  m->n_ciphone, m->n_emit_state);
  }
  tmp___18 = __ckd_calloc__((size_t )m->n_sen, sizeof(s3senid_t ), "mdef.c", 702);
  m->cd2cisen = (s3senid_t *)tmp___18;
  tmp___19 = __ckd_calloc__((size_t )m->n_sen, sizeof(s3cipid_t ), "mdef.c", 704);
  m->sen2cimap = (s3cipid_t *)tmp___19;
  s___0 = 0;
  while (s___0 < m->n_sen) {
    *(m->sen2cimap + s___0) = (s3cipid_t )-1;
    s___0 ++;
  }
  s___0 = 0;
  while (s___0 < m->n_ci_sen) {
    *(m->cd2cisen + s___0) = (s3senid_t )s___0;
    *(m->sen2cimap + s___0) = (s3cipid_t )(s___0 / m->n_emit_state);
    s___0 ++;
  }
  p = n_ci;
  while (p < m->n_phone) {
    s___0 = 0;
    while (s___0 < m->n_emit_state) {
      cd = (int32 )*(*(m->sseq + p) + s___0);
      ci = (int32 )*(*(m->sseq + (int )(m->phone + p)->ci) + s___0);
      *(m->cd2cisen + cd) = (s3senid_t )ci;
      *(m->sen2cimap + cd) = (m->phone + p)->ci;
      s___0 ++;
    }
    p ++;
  }
  tmp___20 = __ckd_calloc__((size_t )m->n_ciphone, sizeof(int32 ), "mdef.c", 726);
  cdsen_start = (int32 *)tmp___20;
  tmp___21 = __ckd_calloc__((size_t )m->n_ciphone, sizeof(int32 ), "mdef.c", 728);
  cdsen_end = (int32 *)tmp___21;
  s___0 = m->n_ci_sen;
  while (s___0 < m->n_sen) {
    if ((int )*(m->sen2cimap + s___0) < 0) {
      goto __Cont;
    }
    if (! *(cdsen_start + (int )*(m->sen2cimap + s___0))) {
      *(cdsen_start + (int )*(m->sen2cimap + s___0)) = s___0;
    }
    *(cdsen_end + (int )*(m->sen2cimap + s___0)) = s___0;
    __Cont: /* CIL Label */ 
    s___0 ++;
  }
  s___0 = m->n_ci_sen;
  while (s___0 < m->n_sen) {
    if ((int )*(m->sen2cimap + s___0) >= 0) {
      goto __Cont___0;
    }
    p = 0;
    while (p < m->n_ciphone) {
      if (s___0 > *(cdsen_start + p)) {
        if (s___0 < *(cdsen_end + p)) {
          break;
        }
      }
      p ++;
    }
    if (p >= m->n_ciphone) {
      _E__pr_header("mdef.c", 750L, "FATAL_ERROR");
      _E__die_error("Unreferenced senone %d; cannot determine parent CIphone\n", s___0);
    }
    *(m->sen2cimap + s___0) = (s3cipid_t )p;
    __Cont___0: /* CIL Label */ 
    s___0 ++;
  }
  tmp___22 = __ckd_calloc__((size_t )m->n_ciphone, sizeof(int32 ), "mdef.c", 755);
  m->ciphone2n_cd_sen = (int32 *)tmp___22;
  n = 0;
  p = 0;
  while (p < m->n_ciphone) {
    if (*(cdsen_start + p) > 0) {
      *(m->ciphone2n_cd_sen + p) = (*(cdsen_end + p) - *(cdsen_start + p)) + 1;
      n += *(m->ciphone2n_cd_sen + p);
    }
    p ++;
  }
  n += m->n_ci_sen;
  ckd_free((void *)cdsen_start);
  ckd_free((void *)cdsen_end);
  sseq_compress(m);
  _E__pr_info_header("mdef.c", 771L, "INFO");
  _E__pr_info("%d CI-phone, %d CD-phone, %d emitstate/phone, %d CI-sen, %d Sen, %d Sen-Seq\n",
              m->n_ciphone, m->n_phone - m->n_ciphone, m->n_emit_state, m->n_ci_sen,
              m->n_sen, m->n_sseq);
  fclose(fp);
  return (m);
}
}
void mdef_sseq2sen_active(mdef_t *mdef , int32 *sseq , int32 *sen ) 
{ 
  int32 ss ;
  int32 i ;
  s3senid_t *sp ;

  {
  ss = 0;
  while (ss < mdef->n_sseq) {
    if (*(sseq + ss)) {
      sp = *(mdef->sseq + ss);
      i = 0;
      while (i < mdef->n_emit_state) {
        *(sen + *(sp + i)) = 1;
        i ++;
      }
    }
    ss ++;
  }
  return;
}
}
void mdef_free_recursive_lc(ph_lc_t *lc ) 
{ 


  {
  if ((unsigned long )lc == (unsigned long )((void *)0)) {
    return;
  }
  if (lc->rclist) {
    mdef_free_recursive_rc(lc->rclist);
  }
  if (lc->next) {
    mdef_free_recursive_lc(lc->next);
  }
  ckd_free((void *)lc);
  return;
}
}
void mdef_free_recursive_rc(ph_rc_t *rc ) 
{ 


  {
  if ((unsigned long )rc == (unsigned long )((void *)0)) {
    return;
  }
  if (rc->next) {
    mdef_free_recursive_rc(rc->next);
  }
  ckd_free((void *)rc);
  return;
}
}
void mdef_free(mdef_t *m ) 
{ 
  int i ;
  int j ;

  {
  if (m) {
    if (m->ciphone2n_cd_sen) {
      ckd_free((void *)m->ciphone2n_cd_sen);
    }
    if (m->sen2cimap) {
      ckd_free((void *)m->sen2cimap);
    }
    if (m->cd2cisen) {
      ckd_free((void *)m->cd2cisen);
    }
    i = 0;
    while (i < 4) {
      j = 0;
      while (j < m->n_ciphone) {
        if (*(*(m->wpos_ci_lclist + i) + j)) {
          mdef_free_recursive_lc((*(*(m->wpos_ci_lclist + i) + j))->next);
          mdef_free_recursive_rc((*(*(m->wpos_ci_lclist + i) + j))->rclist);
        }
        j ++;
      }
      i ++;
    }
    i = 0;
    while (i < 4) {
      j = 0;
      while (j < m->n_ciphone) {
        if (*(*(m->wpos_ci_lclist + i) + j)) {
          ckd_free((void *)*(*(m->wpos_ci_lclist + i) + j));
        }
        j ++;
      }
      i ++;
    }
    if (m->wpos_ci_lclist) {
      ckd_free_2d((void **)((void *)m->wpos_ci_lclist));
    }
    if (m->sseq) {
      ckd_free_2d((void **)((void *)m->sseq));
    }
    if (m->phone) {
      ckd_free((void *)m->phone);
    }
    if (m->ciphone_ht) {
      hash_free(m->ciphone_ht);
    }
    i = 0;
    while (i < m->n_ciphone) {
      if ((m->ciphone + i)->name) {
        ckd_free((void *)(m->ciphone + i)->name);
      }
      i ++;
    }
    if (m->ciphone) {
      ckd_free((void *)m->ciphone);
    }
    ckd_free((void *)m);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-5B648HMc.i","-O3")
int fe_build_melfilters(melfb_t *MEL_FB ) ;
int fe_compute_melcosine(melfb_t *MEL_FB ) ;
void fe_pre_emphasis(int16 *in , double *out , int len , float factor , int16 prior ) ;
void fe_hamming_window(double *in , double *window , int in_len ) ;
void fe_frame_to_fea(fe_t *FE , double *in , double *fea ) ;
void fe_short_to_double(int16 *in , double *out , int len ) ;
char **fe_create_2d(int d1 , int d2 , int elem_size ) ;
void fe_free_2d(void **arr ) ;
void fe_parse_general_params(param_t *P , fe_t *FE ) ;
void fe_parse_melfb_params(param_t *P , melfb_t *MEL ) ;
void fe_create_hamming(double *in , int in_len ) ;
fe_t *fe_init(param_t *P ) 
{ 
  fe_t *FE ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  melfb_t *tmp___2 ;
  void *tmp___3 ;

  {
  tmp = calloc((size_t )1, sizeof(fe_t ));
  FE = (fe_t *)tmp;
  if ((unsigned long )FE == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "memory alloc failed in fe_init()\n...exiting\n");
    return ((fe_t *)((void *)0));
  }
  fe_parse_general_params(P, FE);
  FE->FRAME_SHIFT = (int )((double )(FE->SAMPLING_RATE / (float )FE->FRAME_RATE) + 0.5);
  FE->FRAME_SIZE = (int )((double )(FE->WINDOW_LENGTH * FE->SAMPLING_RATE) + 0.5);
  FE->PRIOR = (int16 )0;
  tmp___0 = calloc((size_t )FE->FRAME_SIZE, sizeof(int16 ));
  FE->OVERFLOW_SAMPS = (int16 *)tmp___0;
  tmp___1 = calloc((size_t )FE->FRAME_SIZE, sizeof(double ));
  FE->HAMMING_WINDOW = (double *)tmp___1;
  if ((unsigned long )FE->OVERFLOW_SAMPS == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "memory alloc failed in fe_init()\n...exiting\n");
    return ((fe_t *)((void *)0));
  } else
  if ((unsigned long )FE->HAMMING_WINDOW == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "memory alloc failed in fe_init()\n...exiting\n");
    return ((fe_t *)((void *)0));
  }
  fe_create_hamming(FE->HAMMING_WINDOW, FE->FRAME_SIZE);
  if (FE->FB_TYPE == 1) {
    tmp___3 = calloc((size_t )1, sizeof(melfb_t ));
    tmp___2 = (melfb_t *)tmp___3;
    FE->MEL_FB = tmp___2;
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      fprintf(__stderrp, "memory alloc failed in fe_init()\n...exiting\n");
      return ((fe_t *)((void *)0));
    }
    fe_parse_melfb_params(P, FE->MEL_FB);
    fe_build_melfilters(FE->MEL_FB);
    fe_compute_melcosine(FE->MEL_FB);
  } else {
    fprintf(__stderrp, "MEL SCALE IS CURRENTLY THE ONLY IMPLEMENTATION!\n");
    return ((fe_t *)((void *)0));
  }
  return (FE);
}
}
int fe_start_utt(fe_t *FE ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  FE->NUM_OVERFLOW_SAMPS = 0;
  tmp___0 = __builtin_object_size((void *)FE->OVERFLOW_SAMPS, 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)FE->OVERFLOW_SAMPS, 0);
    __builtin___memset_chk((void *)FE->OVERFLOW_SAMPS, 0, (unsigned long )FE->FRAME_SIZE * sizeof(int16 ),
                           tmp);
  } else {
    __inline_memset_chk((void *)FE->OVERFLOW_SAMPS, 0, (unsigned long )FE->FRAME_SIZE * sizeof(int16 ));
  }
  FE->START_FLAG = 1;
  FE->PRIOR = (int16 )0;
  return (0);
}
}
int fe_process_utt(fe_t *FE , int16 *spch , int nsamps , float32 ***cep_block ) 
{ 
  int frame_start ;
  int frame_count ;
  int whichframe ;
  int i ;
  int spbuf_len ;
  int offset ;
  double *spbuf ;
  double *fr_data ;
  double *fr_fea ;
  int16 *tmp_spch ;
  float32 **cep ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  char **tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;

  {
  frame_count = 0;
  whichframe = 0;
  offset = 0;
  tmp_spch = spch;
  cep = (float32 **)((void *)0);
  if (nsamps + FE->NUM_OVERFLOW_SAMPS >= FE->FRAME_SIZE) {
    if (FE->NUM_OVERFLOW_SAMPS > 0) {
      tmp = malloc(sizeof(int16 ) * (unsigned long )(FE->NUM_OVERFLOW_SAMPS + nsamps));
      tmp_spch = (int16 *)tmp;
      if ((unsigned long )tmp_spch == (unsigned long )((void *)0)) {
        fprintf(__stderrp, "memory alloc failed in fe_process_utt()\n...exiting\n");
        exit(0);
      }
      tmp___1 = __builtin_object_size((void *)tmp_spch, 0);
      if (tmp___1 != 0xffffffffffffffffUL) {
        tmp___0 = __builtin_object_size((void *)tmp_spch, 0);
        __builtin___memcpy_chk((void *)tmp_spch, (void const   *)FE->OVERFLOW_SAMPS,
                               (unsigned long )FE->NUM_OVERFLOW_SAMPS * sizeof(int16 ),
                               tmp___0);
      } else {
        __inline_memcpy_chk((void *)tmp_spch, (void const   *)FE->OVERFLOW_SAMPS,
                            (unsigned long )FE->NUM_OVERFLOW_SAMPS * sizeof(int16 ));
      }
      tmp___3 = __builtin_object_size((void *)(tmp_spch + FE->NUM_OVERFLOW_SAMPS),
                                      0);
      if (tmp___3 != 0xffffffffffffffffUL) {
        tmp___2 = __builtin_object_size((void *)(tmp_spch + FE->NUM_OVERFLOW_SAMPS),
                                        0);
        __builtin___memcpy_chk((void *)(tmp_spch + FE->NUM_OVERFLOW_SAMPS), (void const   *)spch,
                               (unsigned long )nsamps * sizeof(int16 ), tmp___2);
      } else {
        __inline_memcpy_chk((void *)(tmp_spch + FE->NUM_OVERFLOW_SAMPS), (void const   *)spch,
                            (unsigned long )nsamps * sizeof(int16 ));
      }
      nsamps += FE->NUM_OVERFLOW_SAMPS;
      FE->NUM_OVERFLOW_SAMPS = 0;
    }
    frame_count = 0;
    frame_start = 0;
    while (frame_start + FE->FRAME_SIZE <= nsamps) {
      frame_count ++;
      frame_start += FE->FRAME_SHIFT;
    }
    tmp___4 = fe_create_2d(frame_count + 1, FE->NUM_CEPSTRA, (int )sizeof(float32 ));
    cep = (float32 **)tmp___4;
    if ((unsigned long )cep == (unsigned long )((void *)0)) {
      fprintf(__stderrp, "memory alloc for cep failed in fe_process_utt()\n\tfe_create_2d(%ld,%d,%d)\n...exiting\n",
              (long )(frame_count + 1), FE->NUM_CEPSTRA, sizeof(float32 ));
      exit(0);
    }
    spbuf_len = (frame_count - 1) * FE->FRAME_SHIFT + FE->FRAME_SIZE;
    tmp___5 = calloc((size_t )spbuf_len, sizeof(double ));
    spbuf = (double *)tmp___5;
    if ((unsigned long )spbuf == (unsigned long )((void *)0)) {
      fprintf(__stderrp, "memory alloc failed in fe_process_utt()\n...exiting\n");
      exit(0);
    }
    if ((double )FE->PRE_EMPHASIS_ALPHA != 0.0) {
      fe_pre_emphasis(tmp_spch, spbuf, spbuf_len, FE->PRE_EMPHASIS_ALPHA, FE->PRIOR);
    } else {
      fe_short_to_double(tmp_spch, spbuf, spbuf_len);
    }
    tmp___6 = calloc((size_t )FE->FRAME_SIZE, sizeof(double ));
    fr_data = (double *)tmp___6;
    tmp___7 = calloc((size_t )FE->NUM_CEPSTRA, sizeof(double ));
    fr_fea = (double *)tmp___7;
    if ((unsigned long )fr_data == (unsigned long )((void *)0)) {
      fprintf(__stderrp, "memory alloc failed in fe_process_utt()\n...exiting\n");
      exit(0);
    } else
    if ((unsigned long )fr_fea == (unsigned long )((void *)0)) {
      fprintf(__stderrp, "memory alloc failed in fe_process_utt()\n...exiting\n");
      exit(0);
    }
    whichframe = 0;
    while (whichframe < frame_count) {
      i = 0;
      while (i < FE->FRAME_SIZE) {
        *(fr_data + i) = *(spbuf + (whichframe * FE->FRAME_SHIFT + i));
        i ++;
      }
      fe_hamming_window(fr_data, FE->HAMMING_WINDOW, FE->FRAME_SIZE);
      fe_frame_to_fea(FE, fr_data, fr_fea);
      i = 0;
      while (i < FE->NUM_CEPSTRA) {
        *(*(cep + whichframe) + i) = (float32 )*(fr_fea + i);
        i ++;
      }
      whichframe ++;
    }
    if (spbuf_len < nsamps) {
      offset = frame_count * FE->FRAME_SHIFT;
      tmp___9 = __builtin_object_size((void *)FE->OVERFLOW_SAMPS, 0);
      if (tmp___9 != 0xffffffffffffffffUL) {
        tmp___8 = __builtin_object_size((void *)FE->OVERFLOW_SAMPS, 0);
        __builtin___memcpy_chk((void *)FE->OVERFLOW_SAMPS, (void const   *)(tmp_spch + offset),
                               (unsigned long )(nsamps - offset) * sizeof(int16 ),
                               tmp___8);
      } else {
        __inline_memcpy_chk((void *)FE->OVERFLOW_SAMPS, (void const   *)(tmp_spch + offset),
                            (unsigned long )(nsamps - offset) * sizeof(int16 ));
      }
      FE->NUM_OVERFLOW_SAMPS = nsamps - offset;
      FE->PRIOR = *(tmp_spch + (offset - 1));
    }
    if ((unsigned long )spch != (unsigned long )tmp_spch) {
      free((void *)tmp_spch);
    }
    free((void *)spbuf);
    free((void *)fr_data);
    free((void *)fr_fea);
  } else {
    tmp___11 = __builtin_object_size((void *)(FE->OVERFLOW_SAMPS + FE->NUM_OVERFLOW_SAMPS),
                                     0);
    if (tmp___11 != 0xffffffffffffffffUL) {
      tmp___10 = __builtin_object_size((void *)(FE->OVERFLOW_SAMPS + FE->NUM_OVERFLOW_SAMPS),
                                       0);
      __builtin___memcpy_chk((void *)(FE->OVERFLOW_SAMPS + FE->NUM_OVERFLOW_SAMPS),
                             (void const   *)tmp_spch, (unsigned long )nsamps * sizeof(int16 ),
                             tmp___10);
    } else {
      __inline_memcpy_chk((void *)(FE->OVERFLOW_SAMPS + FE->NUM_OVERFLOW_SAMPS), (void const   *)tmp_spch,
                          (unsigned long )nsamps * sizeof(int16 ));
    }
    FE->NUM_OVERFLOW_SAMPS += nsamps;
    frame_count = 0;
  }
  *cep_block = cep;
  return (frame_count);
}
}
int fe_end_utt(fe_t *FE , float *cepvector ) 
{ 
  int pad_len ;
  int frame_count ;
  int i ;
  double *spbuf ;
  double *fr_fea ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  pad_len = 0;
  frame_count = 0;
  fr_fea = (double *)((void *)0);
  if (FE->NUM_OVERFLOW_SAMPS > 0) {
    pad_len = FE->FRAME_SIZE - FE->NUM_OVERFLOW_SAMPS;
    tmp___0 = __builtin_object_size((void *)(FE->OVERFLOW_SAMPS + FE->NUM_OVERFLOW_SAMPS),
                                    0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)(FE->OVERFLOW_SAMPS + FE->NUM_OVERFLOW_SAMPS),
                                  0);
      __builtin___memset_chk((void *)(FE->OVERFLOW_SAMPS + FE->NUM_OVERFLOW_SAMPS),
                             0, (unsigned long )pad_len * sizeof(int16 ), tmp);
    } else {
      __inline_memset_chk((void *)(FE->OVERFLOW_SAMPS + FE->NUM_OVERFLOW_SAMPS), 0,
                          (unsigned long )pad_len * sizeof(int16 ));
    }
    FE->NUM_OVERFLOW_SAMPS += pad_len;
    tmp___1 = calloc((size_t )FE->FRAME_SIZE, sizeof(double ));
    spbuf = (double *)tmp___1;
    if ((unsigned long )spbuf == (unsigned long )((void *)0)) {
      fprintf(__stderrp, "memory alloc failed in fe_end_utt()\n...exiting\n");
      exit(0);
    }
    if ((double )FE->PRE_EMPHASIS_ALPHA != 0.0) {
      fe_pre_emphasis(FE->OVERFLOW_SAMPS, spbuf, FE->FRAME_SIZE, FE->PRE_EMPHASIS_ALPHA,
                      FE->PRIOR);
    } else {
      fe_short_to_double(FE->OVERFLOW_SAMPS, spbuf, FE->FRAME_SIZE);
    }
    tmp___2 = calloc((size_t )FE->NUM_CEPSTRA, sizeof(double ));
    fr_fea = (double *)tmp___2;
    if ((unsigned long )fr_fea == (unsigned long )((void *)0)) {
      fprintf(__stderrp, "memory alloc failed in fe_end_utt()\n...exiting\n");
      exit(0);
    }
    fe_hamming_window(spbuf, FE->HAMMING_WINDOW, FE->FRAME_SIZE);
    fe_frame_to_fea(FE, spbuf, fr_fea);
    i = 0;
    while (i < FE->NUM_CEPSTRA) {
      *(cepvector + i) = (float32 )*(fr_fea + i);
      i ++;
    }
    frame_count = 1;
    free((void *)fr_fea);
    free((void *)spbuf);
  } else {
    frame_count = 0;
    cepvector = (float *)((void *)0);
  }
  FE->NUM_OVERFLOW_SAMPS = 0;
  FE->START_FLAG = 0;
  return (frame_count);
}
}
int fe_close(fe_t *FE ) 
{ 


  {
  if (FE->FB_TYPE == 1) {
    fe_free_2d((void **)((void *)(FE->MEL_FB)->filter_coeffs));
    fe_free_2d((void **)((void *)(FE->MEL_FB)->mel_cosine));
    free((void *)(FE->MEL_FB)->left_apex);
    free((void *)(FE->MEL_FB)->width);
    free((void *)FE->MEL_FB);
  } else {
    fprintf(__stderrp, "MEL SCALE IS CURRENTLY THE ONLY IMPLEMENTATION!\n");
  }
  free((void *)FE->OVERFLOW_SAMPS);
  free((void *)FE);
  return (0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-KFq1NR3i.i","-O3")
extern double cos(double  ) ;
extern double sin(double  ) ;
float fe_mel(float x___0 ) ;
float fe_melinv(float x___0 ) ;
void fe_spec_magnitude(double *data , int data_len , double *spec , int fftsize ) ;
void fe_mel_spec(fe_t *FE , double *spec , double *mfspec ) ;
void fe_mel_cep(fe_t *FE , double *mfspec , double *mfcep ) ;
int fe_fft(complex *in , complex *out , int N , int invert ) ;
void fe_print_current(fe_t *FE ) ;
int fe_build_melfilters(melfb_t *MEL_FB ) 
{ 
  int i ;
  int whichfilt ;
  int start_pt ;
  float leftfr ;
  float centerfr ;
  float rightfr ;
  float fwidth ;
  float height ;
  float *filt_edge ;
  float melmax ;
  float melmin ;
  float dmelbw ;
  float freq ;
  float dfreq ;
  float leftslope ;
  float rightslope ;
  char **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  tmp = fe_create_2d(MEL_FB->num_filters, MEL_FB->fft_size, (int )sizeof(float ));
  MEL_FB->filter_coeffs = (float **)tmp;
  tmp___0 = calloc((size_t )MEL_FB->num_filters, sizeof(float ));
  MEL_FB->left_apex = (float *)tmp___0;
  tmp___1 = calloc((size_t )MEL_FB->num_filters, sizeof(int ));
  MEL_FB->width = (int *)tmp___1;
  if (MEL_FB->doublewide == 1) {
    tmp___2 = calloc((size_t )(MEL_FB->num_filters + 4), sizeof(float32 ));
    filt_edge = (float32 *)tmp___2;
  } else {
    tmp___3 = calloc((size_t )(MEL_FB->num_filters + 2), sizeof(float32 ));
    filt_edge = (float32 *)tmp___3;
  }
  if ((unsigned long )MEL_FB->filter_coeffs == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "memory alloc failed in fe_build_mel_filters()\n...exiting\n");
    exit(0);
  } else
  if ((unsigned long )MEL_FB->left_apex == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "memory alloc failed in fe_build_mel_filters()\n...exiting\n");
    exit(0);
  } else
  if ((unsigned long )MEL_FB->width == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "memory alloc failed in fe_build_mel_filters()\n...exiting\n");
    exit(0);
  } else
  if ((unsigned long )filt_edge == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "memory alloc failed in fe_build_mel_filters()\n...exiting\n");
    exit(0);
  }
  dfreq = MEL_FB->sampling_rate / (float )MEL_FB->fft_size;
  melmax = fe_mel(MEL_FB->upper_filt_freq);
  melmin = fe_mel(MEL_FB->lower_filt_freq);
  dmelbw = (melmax - melmin) / (float )(MEL_FB->num_filters + 1);
  if (MEL_FB->doublewide == 1) {
    i = 0;
    while (i <= MEL_FB->num_filters + 3) {
      *(filt_edge + i) = fe_melinv((float )i * dmelbw + melmin);
      i ++;
    }
  } else {
    i = 0;
    while (i <= MEL_FB->num_filters + 1) {
      *(filt_edge + i) = fe_melinv((float )i * dmelbw + melmin);
      i ++;
    }
  }
  whichfilt = 0;
  while (whichfilt < MEL_FB->num_filters) {
    if (MEL_FB->doublewide == 1) {
      leftfr = (float )((int )((double )(*(filt_edge + whichfilt) / dfreq) + 0.5)) * dfreq;
      centerfr = (float )((int )((double )(*(filt_edge + (whichfilt + 2)) / dfreq) + 0.5)) * dfreq;
      rightfr = (float )((int )((double )(*(filt_edge + (whichfilt + 4)) / dfreq) + 0.5)) * dfreq;
    } else {
      leftfr = (float )((int )((double )(*(filt_edge + whichfilt) / dfreq) + 0.5)) * dfreq;
      centerfr = (float )((int )((double )(*(filt_edge + (whichfilt + 1)) / dfreq) + 0.5)) * dfreq;
      rightfr = (float )((int )((double )(*(filt_edge + (whichfilt + 2)) / dfreq) + 0.5)) * dfreq;
    }
    *(MEL_FB->left_apex + whichfilt) = leftfr;
    fwidth = rightfr - leftfr;
    height = (float )2 / fwidth;
    if (centerfr != leftfr) {
      leftslope = height / (centerfr - leftfr);
    }
    if (centerfr != rightfr) {
      rightslope = height / (centerfr - rightfr);
    }
    start_pt = (int )((double )(leftfr / dfreq) + 0.5);
    freq = (float32 )start_pt * dfreq;
    i = 0;
    while (freq < centerfr) {
      *(*(MEL_FB->filter_coeffs + whichfilt) + i) = (freq - leftfr) * leftslope;
      freq += dfreq;
      i ++;
    }
    if (freq == centerfr) {
      *(*(MEL_FB->filter_coeffs + whichfilt) + i) = height;
      freq += dfreq;
      i ++;
    }
    while (freq < rightfr) {
      *(*(MEL_FB->filter_coeffs + whichfilt) + i) = (freq - rightfr) * rightslope;
      freq += dfreq;
      i ++;
    }
    *(MEL_FB->width + whichfilt) = i;
    whichfilt ++;
  }
  free((void *)filt_edge);
  return (0);
}
}
int fe_compute_melcosine(melfb_t *MEL_FB ) 
{ 
  double period ;
  double freq ;
  int i ;
  int j ;
  float **tmp ;
  char **tmp___0 ;
  double tmp___1 ;

  {
  period = (double )2 * (double )MEL_FB->num_filters;
  tmp___0 = fe_create_2d(MEL_FB->num_cepstra, MEL_FB->num_filters, (int )sizeof(float ));
  tmp = (float **)tmp___0;
  MEL_FB->mel_cosine = tmp;
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "memory alloc failed in fe_compute_melcosine()\n...exiting\n");
    exit(0);
  }
  i = 0;
  while (i < MEL_FB->num_cepstra) {
    freq = (((double )2 * 3.14159265358979323846264338327950288) * (double )i) / period;
    j = 0;
    while (j < MEL_FB->num_filters) {
      tmp___1 = cos(freq * ((double )j + 0.5));
      *(*(MEL_FB->mel_cosine + i) + j) = (float )tmp___1;
      j ++;
    }
    i ++;
  }
  return (0);
}
}
float fe_mel(float x___0 ) 
{ 
  double tmp ;

  {
  tmp = log10(1.0 + (double )x___0 / 700.0);
  return ((float )(2595.0 * (double )((float )tmp)));
}
}
float fe_melinv(float x___0 ) 
{ 
  double tmp ;

  {
  tmp = pow(10.0, (double )x___0 / 2595.0);
  return ((float )(700.0 * ((double )((float )tmp) - 1.0)));
}
}
void fe_pre_emphasis(int16 *in , double *out , int len , float factor , int16 prior ) 
{ 
  int i ;

  {
  *(out + 0) = (double )*(in + 0) - (double )factor * (double )prior;
  i = 1;
  while (i < len) {
    *(out + i) = (double )*(in + i) - (double )factor * (double )*(in + (i - 1));
    i ++;
  }
  return;
}
}
void fe_short_to_double(int16 *in , double *out , int len ) 
{ 
  int i ;

  {
  i = 0;
  while (i < len) {
    *(out + i) = (double )*(in + i);
    i ++;
  }
  return;
}
}
void fe_create_hamming(double *in , int in_len ) 
{ 
  int i ;
  double tmp ;

  {
  if (in_len > 1) {
    i = 0;
    while (i < in_len) {
      tmp = cos((((double )2 * 3.14159265358979323846264338327950288) * (double )i) / ((double )in_len - 1.0));
      *(in + i) = 0.54 - 0.46 * tmp;
      i ++;
    }
  }
  return;
}
}
void fe_hamming_window(double *in , double *window , int in_len ) 
{ 
  int i ;

  {
  if (in_len > 1) {
    i = 0;
    while (i < in_len) {
      *(in + i) *= *(window + i);
      i ++;
    }
  }
  return;
}
}
void fe_frame_to_fea(fe_t *FE , double *in , double *fea ) 
{ 
  double *spec ;
  double *mfspec ;
  void *tmp ;
  void *tmp___0 ;

  {
  if (FE->FB_TYPE == 1) {
    tmp = calloc((size_t )FE->FFT_SIZE, sizeof(double ));
    spec = (double *)tmp;
    tmp___0 = calloc((size_t )(FE->MEL_FB)->num_filters, sizeof(double ));
    mfspec = (double *)tmp___0;
    if ((unsigned long )spec == (unsigned long )((void *)0)) {
      fprintf(__stderrp, "memory alloc failed in fe_frame_to_fea()\n...exiting\n");
      exit(0);
    } else
    if ((unsigned long )mfspec == (unsigned long )((void *)0)) {
      fprintf(__stderrp, "memory alloc failed in fe_frame_to_fea()\n...exiting\n");
      exit(0);
    }
    fe_spec_magnitude(in, FE->FRAME_SIZE, spec, FE->FFT_SIZE);
    fe_mel_spec(FE, spec, mfspec);
    fe_mel_cep(FE, mfspec, fea);
    free((void *)spec);
    free((void *)mfspec);
  } else {
    fprintf(__stderrp, "MEL SCALE IS CURRENTLY THE ONLY IMPLEMENTATION!\n");
    exit(0);
  }
  return;
}
}
void fe_spec_magnitude(double *data , int data_len , double *spec , int fftsize ) 
{ 
  int j ;
  int wrap ;
  complex *FFT ;
  complex *IN ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = calloc((size_t )fftsize, sizeof(complex ));
  FFT = (complex *)tmp;
  tmp___0 = calloc((size_t )fftsize, sizeof(complex ));
  IN = (complex *)tmp___0;
  if ((unsigned long )FFT == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "memory alloc failed in fe_spec_magnitude()\n...exiting\n");
    exit(0);
  } else
  if ((unsigned long )IN == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "memory alloc failed in fe_spec_magnitude()\n...exiting\n");
    exit(0);
  }
  if (data_len > fftsize) {
    j = 0;
    while (j < fftsize) {
      (IN + j)->r = *(data + j);
      (IN + j)->i = 0.0;
      j ++;
    }
    wrap = 0;
    while (j < data_len) {
      (IN + wrap)->r += *(data + j);
      (IN + wrap)->i += 0.0;
      wrap ++;
      j ++;
    }
  } else {
    j = 0;
    while (j < data_len) {
      (IN + j)->r = *(data + j);
      (IN + j)->i = 0.0;
      j ++;
    }
    while (j < fftsize) {
      (IN + j)->r = 0.0;
      (IN + j)->i = 0.0;
      j ++;
    }
  }
  fe_fft(IN, FFT, fftsize, 1);
  j = 0;
  while (j <= fftsize / 2) {
    *(spec + j) = (FFT + j)->r * (FFT + j)->r + (FFT + j)->i * (FFT + j)->i;
    j ++;
  }
  free((void *)FFT);
  free((void *)IN);
  return;
}
}
void fe_mel_spec(fe_t *FE , double *spec , double *mfspec ) 
{ 
  int whichfilt ;
  int start ;
  int i ;
  float dfreq ;

  {
  dfreq = FE->SAMPLING_RATE / (float )FE->FFT_SIZE;
  whichfilt = 0;
  while (whichfilt < (FE->MEL_FB)->num_filters) {
    start = (int )((double )(*((FE->MEL_FB)->left_apex + whichfilt) / dfreq) + 0.5);
    *(mfspec + whichfilt) = (double )0;
    i = 0;
    while (i < *((FE->MEL_FB)->width + whichfilt)) {
      *(mfspec + whichfilt) += (double )*(*((FE->MEL_FB)->filter_coeffs + whichfilt) + i) * *(spec + (start + i));
      i ++;
    }
    whichfilt ++;
  }
  return;
}
}
void fe_mel_cep(fe_t *FE , double *mfspec , double *mfcep ) 
{ 
  int i ;
  int j ;
  int period ;
  float beta ;

  {
  period = (FE->MEL_FB)->num_filters;
  i = 0;
  while (i < (FE->MEL_FB)->num_filters) {
    if (*(mfspec + i) > (double )0) {
      *(mfspec + i) = log(*(mfspec + i));
    } else {
      *(mfspec + i) = - 1.0e+5;
    }
    i ++;
  }
  i = 0;
  while (i < FE->NUM_CEPSTRA) {
    *(mfcep + i) = (double )0;
    j = 0;
    while (j < (FE->MEL_FB)->num_filters) {
      if (j == 0) {
        beta = (float )0.5;
      } else {
        beta = (float )1.0;
      }
      *(mfcep + i) += ((double )beta * *(mfspec + j)) * (double )*(*((FE->MEL_FB)->mel_cosine + i) + j);
      j ++;
    }
    *(mfcep + i) /= (double )((float )period);
    i ++;
  }
  return;
}
}
static int s  ;
static int k  ;
static int lgN  ;
static complex *w  ;
static complex *from  ;
static complex *to  ;
static complex wwf2  ;
static complex *buffer  ;
static complex *exch  ;
static complex *wEnd  ;
static double div___0  ;
static double x  ;
int fe_fft(complex *in , complex *out , int N , int invert ) 
{ 
  complex *f1 ;
  complex *f2 ;
  complex *t1 ;
  complex *t2 ;
  complex *ww ;
  void *tmp ;
  void *tmp___0 ;

  {
  k = N;
  lgN = 0;
  while (k > 1) {
    if (k % 2 != 0) {
      fprintf(__stderrp, "fft: N must be a power of 2 (is %d)\n", N);
      return (-1);
    } else
    if (N < 0) {
      fprintf(__stderrp, "fft: N must be a power of 2 (is %d)\n", N);
      return (-1);
    }
    k /= 2;
    lgN ++;
  }
  if (invert == 1) {
    div___0 = 1.0;
  } else
  if (invert == -1) {
    div___0 = (double )N;
  } else {
    fprintf(__stderrp, "fft: invert must be either +1 or -1 (is %d)\n", invert);
    return (-1);
  }
  tmp = calloc((size_t )N, sizeof(complex ));
  buffer = (complex *)tmp;
  if (lgN % 2 == 0) {
    from = out;
    to = buffer;
  } else {
    to = out;
    from = buffer;
  }
  s = 0;
  while (s < N) {
    (from + s)->r = (in + s)->r / div___0;
    (from + s)->i = (in + s)->i / div___0;
    s ++;
  }
  tmp___0 = calloc((size_t )(N / 2), sizeof(complex ));
  w = (complex *)tmp___0;
  k = 0;
  while (k < N / 2) {
    x = ((- 6.28318530717958647 * (double )invert) * (double )k) / (double )N;
    (w + k)->r = cos(x);
    (w + k)->i = sin(x);
    k ++;
  }
  wEnd = w + N / 2;
  k = N / 2;
  while (k > 0) {
    s = 0;
    while (s < k) {
      f1 = from + s;
      f2 = from + (s + k);
      t1 = to + s;
      t2 = to + (s + N / 2);
      ww = w + 0;
      while ((unsigned long )ww < (unsigned long )wEnd) {
        wwf2.r = f2->r * ww->r - f2->i * ww->i;
        wwf2.i = f2->r * ww->i + f2->i * ww->r;
        t1->r = f1->r + wwf2.r;
        t1->i = f1->i + wwf2.i;
        t2->r = f1->r - wwf2.r;
        t2->i = f1->i - wwf2.i;
        f1 += 2 * k;
        f2 += 2 * k;
        t1 += k;
        t2 += k;
        ww += k;
      }
      s ++;
    }
    exch = from;
    from = to;
    to = exch;
    k /= 2;
  }
  free((void *)buffer);
  free((void *)w);
  return (0);
}
}
char **fe_create_2d(int d1 , int d2 , int elem_size ) 
{ 
  char *store ;
  char **out ;
  int i ;
  int j ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = calloc((size_t )(d1 * d2), (size_t )elem_size);
  store = (char *)tmp;
  if ((unsigned long )store == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "fe_create_2d failed\n");
    return ((char **)((void *)0));
  }
  tmp___0 = calloc((size_t )d1, sizeof(void *));
  out = (char **)tmp___0;
  if ((unsigned long )out == (unsigned long )((void *)0)) {
    fprintf(__stderrp, "fe_create_2d failed\n");
    free((void *)store);
    return ((char **)((void *)0));
  }
  i = 0;
  j = 0;
  while (i < d1) {
    *(out + i) = store + j * elem_size;
    i ++;
    j += d2;
  }
  return (out);
}
}
void fe_free_2d(void **arr ) 
{ 


  {
  if ((unsigned long )arr != (unsigned long )((void *)0)) {
    free(*(arr + 0));
    free((void *)arr);
  }
  return;
}
}
void fe_parse_general_params(param_t *P , fe_t *FE ) 
{ 


  {
  if (P->SAMPLING_RATE != (float )0) {
    FE->SAMPLING_RATE = P->SAMPLING_RATE;
  } else {
    FE->SAMPLING_RATE = (float )16000.0;
  }
  if (P->FRAME_RATE != 0) {
    FE->FRAME_RATE = P->FRAME_RATE;
  } else {
    FE->FRAME_RATE = 100;
  }
  if (P->WINDOW_LENGTH != (float )0) {
    FE->WINDOW_LENGTH = P->WINDOW_LENGTH;
  } else {
    FE->WINDOW_LENGTH = (float )0.0256;
  }
  if (P->FB_TYPE != 0) {
    FE->FB_TYPE = P->FB_TYPE;
  } else {
    FE->FB_TYPE = 1;
  }
  if (P->PRE_EMPHASIS_ALPHA != (float )0) {
    FE->PRE_EMPHASIS_ALPHA = P->PRE_EMPHASIS_ALPHA;
  } else {
    FE->PRE_EMPHASIS_ALPHA = (float )0.97;
  }
  if (P->NUM_CEPSTRA != 0) {
    FE->NUM_CEPSTRA = P->NUM_CEPSTRA;
  } else {
    FE->NUM_CEPSTRA = 13;
  }
  if (P->FFT_SIZE != 0) {
    FE->FFT_SIZE = P->FFT_SIZE;
  } else {
    FE->FFT_SIZE = 256;
  }
  return;
}
}
void fe_parse_melfb_params(param_t *P , melfb_t *MEL ) 
{ 


  {
  if (P->SAMPLING_RATE != (float )0) {
    MEL->sampling_rate = P->SAMPLING_RATE;
  } else {
    MEL->sampling_rate = (float )16000.0;
  }
  if (P->FFT_SIZE != 0) {
    MEL->fft_size = P->FFT_SIZE;
  } else {
    if (MEL->sampling_rate == (float )16000) {
      MEL->fft_size = 512;
    }
    if (MEL->sampling_rate == (float )8000) {
      MEL->fft_size = 256;
    } else {
      MEL->fft_size = 256;
    }
  }
  if (P->NUM_CEPSTRA != 0) {
    MEL->num_cepstra = P->NUM_CEPSTRA;
  } else {
    MEL->num_cepstra = 13;
  }
  if (P->NUM_FILTERS != 0) {
    MEL->num_filters = P->NUM_FILTERS;
  } else
  if (MEL->sampling_rate == (float )16000) {
    MEL->num_filters = 40;
  } else
  if (MEL->sampling_rate == (float )8000) {
    MEL->num_filters = 31;
  } else {
    fprintf(__stderrp, "Please define the number of MEL filters needed\n");
    fprintf(__stderrp, "Modify include/new_fe.h and new_fe_sp.c\n");
    fflush(__stderrp);
    exit(0);
  }
  if (P->UPPER_FILT_FREQ != (float )0) {
    MEL->upper_filt_freq = P->UPPER_FILT_FREQ;
  } else
  if (MEL->sampling_rate == (float )16000) {
    MEL->upper_filt_freq = (float )6855.4976;
  } else
  if (MEL->sampling_rate == (float )8000) {
    MEL->upper_filt_freq = (float )3500;
  } else {
    fprintf(__stderrp, "Please define the upper filt frequency needed\n");
    fprintf(__stderrp, "Modify include/new_fe.h and new_fe_sp.c\n");
    fflush(__stderrp);
    exit(0);
  }
  if (P->LOWER_FILT_FREQ != (float )0) {
    MEL->lower_filt_freq = P->LOWER_FILT_FREQ;
  } else
  if (MEL->sampling_rate == (float )16000) {
    MEL->lower_filt_freq = (float )133.33334;
  } else
  if (MEL->sampling_rate == (float )8000) {
    MEL->lower_filt_freq = (float )200;
  } else {
    fprintf(__stderrp, "Please define the lower filt frequency needed\n");
    fprintf(__stderrp, "Modify include/new_fe.h and new_fe_sp.c\n");
    fflush(__stderrp);
    exit(0);
  }
  if (P->doublebw == 1) {
    MEL->doublewide = 1;
  } else {
    MEL->doublewide = 0;
  }
  return;
}
}
void fe_print_current(fe_t *FE ) 
{ 


  {
  fprintf(__stderrp, "Current FE Parameters:\n");
  fprintf(__stderrp, "\tSampling Rate:             %f\n", (double )FE->SAMPLING_RATE);
  fprintf(__stderrp, "\tFrame Size:                %d\n", FE->FRAME_SIZE);
  fprintf(__stderrp, "\tFrame Shift:               %d\n", FE->FRAME_SHIFT);
  fprintf(__stderrp, "\tFFT Size:                  %d\n", FE->FFT_SIZE);
  fprintf(__stderrp, "\tNumber of Overflow Samps:  %d\n", FE->NUM_OVERFLOW_SAMPS);
  fprintf(__stderrp, "\tStart Utt Status:          %d\n", FE->START_FLAG);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-QvmV2MB7.i","-O3")
extern int unlink(char const   * ) ;
void pctr_reset(pctr_t *ctr ) ;
void pctr_reset_all(pctr_t *ctr ) ;
void pctr_print_all(FILE *fp , pctr_t *ctr ) ;
void ptmr_reset(ptmr_t *tm ) ;
void ptmr_reset_all(ptmr_t *tm ) ;
void ptmr_print_all(FILE *fp , ptmr_t *tm , float64 norm ) ;
int32 host_pclk(int32 dummy ) ;
int32 host_endian(void) ;
void pctr_reset(pctr_t *ctr ) 
{ 


  {
  ctr->count = 0;
  return;
}
}
void pctr_reset_all(pctr_t *ctr ) 
{ 


  {
  while (ctr->name) {
    pctr_reset(ctr);
    ctr ++;
  }
  return;
}
}
void pctr_print_all(FILE *fp , pctr_t *ctr ) 
{ 


  {
  if (! ctr->name) {
    return;
  }
  fprintf(fp, "CTR:");
  while (ctr->name) {
    fprintf(fp, "  %d %s", ctr->count, ctr->name);
    ctr ++;
  }
  fprintf(fp, "\n");
  return;
}
}
int32 host_pclk(int32 dummy ) 
{ 
  int32 mhz ;

  {
  mhz = 0;
  return (mhz);
}
}
void ptmr_start(ptmr_t *tm ) 
{ 


  {
  return;
}
}
void ptmr_stop(ptmr_t *tm ) 
{ 


  {
  return;
}
}
void ptmr_reset(ptmr_t *tm ) 
{ 


  {
  tm->t_cpu = 0.0;
  tm->t_elapsed = 0.0;
  return;
}
}
void ptmr_init(ptmr_t *tm ) 
{ 


  {
  tm->t_cpu = 0.0;
  tm->t_elapsed = 0.0;
  tm->t_tot_cpu = 0.0;
  tm->t_tot_elapsed = 0.0;
  return;
}
}
void ptmr_reset_all(ptmr_t *tm ) 
{ 


  {
  while (tm->name) {
    ptmr_reset(tm);
    tm ++;
  }
  return;
}
}
void ptmr_print_all(FILE *fp , ptmr_t *tm , float64 norm ) 
{ 


  {
  if (norm != 0.0) {
    norm = 1.0 / norm;
    while (tm->name) {
      fprintf(fp, "  %6.2fx %s", tm->t_cpu * norm, tm->name);
      tm ++;
    }
  }
  return;
}
}
int32 host_endian(void) 
{ 
  FILE *fp ;
  int32 BYTE_ORDER_MAGIC ;
  char *file ;
  char buf[8] ;
  int32 k___0 ;
  int32 endian ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  file = (char *)"/tmp/__EnDiAn_TeSt__";
  fp = fopen((char const   *)file, "wb");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    _E__pr_header("profile.c", 291L, "ERROR");
    _E__pr_warn("fopen(%s,wb) failed\n", file);
    return (-1);
  }
  BYTE_ORDER_MAGIC = 287454020;
  k___0 = BYTE_ORDER_MAGIC;
  tmp = fwrite((void const   *)(& k___0), sizeof(int32 ), (size_t )1, fp);
  if (tmp != 1UL) {
    _E__pr_header("profile.c", 299L, "ERROR");
    _E__pr_warn("fwrite(%s) failed\n", file);
    fclose(fp);
    unlink((char const   *)file);
    return (-1);
  }
  fclose(fp);
  fp = fopen((char const   *)file, "rb");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    _E__pr_header("profile.c", 307L, "ERROR");
    _E__pr_warn("fopen(%s,rb) failed\n", file);
    unlink((char const   *)file);
    return (-1);
  }
  tmp___0 = fread((void *)(buf), (size_t )1, sizeof(int32 ), fp);
  if (tmp___0 != sizeof(int32 )) {
    _E__pr_header("profile.c", 312L, "ERROR");
    _E__pr_warn("fread(%s) failed\n", file);
    fclose(fp);
    unlink((char const   *)file);
    return (-1);
  }
  fclose(fp);
  unlink((char const   *)file);
  if ((int )buf[0] == (BYTE_ORDER_MAGIC & 255)) {
    endian = 1;
  } else {
    endian = 0;
  }
  return (endian);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-udlEjqzo.i","-O3")
static int seedi  ;
void spec_srand(int seed ) 
{ 


  {
  seedi = seed;
  return;
}
}
double spec_rand(void) 
{ 
  int lo ;
  int hi ;
  int test ;

  {
  hi = (int )((long )seedi / 127773L);
  lo = (int )((long )seedi % 127773L);
  test = (int )(16807L * (long )lo - 2836L * (long )hi);
  if (test > 0) {
    seedi = test;
  } else {
    seedi = (int )((long )test + 2147483647L);
  }
  return ((double )seedi / (double )2147483647L);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-P2HWHdYm.i","-O3")
extern _RuneLocale _DefaultRuneLocale ;
__inline static int isascii(int _c ) 
{ 


  {
  return ((_c & -128) == 0);
}
}
extern int __maskrune(__darwin_ct_rune_t  , unsigned long  ) ;
__inline static int __istype(__darwin_ct_rune_t _c , unsigned long _f ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___3 = isascii(_c);
  if (tmp___3) {
    tmp___2 = ! (! ((unsigned long )_DefaultRuneLocale.__runetype[_c] & _f));
  } else {
    tmp___0 = __maskrune(_c, _f);
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    tmp___2 = tmp___1;
  }
  return (tmp___2);
}
}
__inline static int isspace(int _c ) 
{ 
  int tmp ;

  {
  tmp = __istype(_c, 16384UL);
  return (tmp);
}
}
int32 str2words(char *line , char **ptr , int32 max_ptr ) 
{ 
  int32 i ;
  int32 n ;
  int tmp ;
  int32 tmp___0 ;
  int tmp___1 ;
  int32 tmp___2 ;

  {
  n = 0;
  i = 0;
  while (1) {
    while (1) {
      if (*(line + i)) {
        tmp = isspace((int )*(line + i));
        if (! tmp) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
    if (! *(line + i)) {
      break;
    }
    if (n >= max_ptr) {
      while (i >= 0) {
        if ((int )*(line + i) == 0) {
          *(line + i) = (char )' ';
        }
        i --;
      }
      return (-1);
    }
    tmp___0 = n;
    n ++;
    *(ptr + tmp___0) = line + i;
    while (1) {
      if (*(line + i)) {
        tmp___1 = isspace((int )*(line + i));
        if (tmp___1) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
    if (! *(line + i)) {
      break;
    }
    tmp___2 = i;
    i ++;
    *(line + tmp___2) = (char )'\000';
  }
  return (n);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Z3P6THJx.i","-O3")
void vector_gautbl_alloc(vector_gautbl_t *gautbl , int32 n_gau , int32 veclen ) ;
void vector_gautbl_var_floor(vector_gautbl_t *gautbl , float64 floor___0 ) ;
void vector_gautbl_maha_precomp(vector_gautbl_t *gautbl ) ;
void vector_gautbl_eval_logs3(vector_gautbl_t *gautbl , int32 offset , int32 count ,
                              float32 *x___0 , int32 *score ) ;
int32 subvq_frame_eval(subvq_t *vq , mgau_model_t *g , int32 beam , float32 *feat ,
                       int32 *sen_active , int32 *senscr ) ;
void subvq_subvec_eval_logs3(subvq_t *vq , float32 *feat , int32 s___0 ) ;
static int VQ_EVAL  =    3;
static void subvq_maha_precomp(subvq_t *svq , float64 floor___0 ) 
{ 
  int32 s___0 ;
  float32 *lrd ;
  vector_gautbl_t *gautbl ;
  void *tmp ;

  {
  _E__pr_info_header("subvq.c", 103L, "INFO");
  _E__pr_info("Precomputing Mahalanobis distance invariants\n");
  tmp = __ckd_calloc__((size_t )(svq->n_sv * svq->vqsize), sizeof(float32 ), "subvq.c",
                       105);
  lrd = (float32 *)tmp;
  s___0 = 0;
  while (s___0 < svq->n_sv) {
    gautbl = svq->gautbl + s___0;
    vector_gautbl_var_floor(gautbl, floor___0);
    gautbl->lrd = lrd;
    lrd += svq->vqsize;
    vector_gautbl_maha_precomp(gautbl);
    s___0 ++;
  }
  return;
}
}
static void subvq_map_compact(subvq_t *vq , mgau_model_t *g ) 
{ 
  int32 r ;
  int32 c ;
  int32 c2 ;
  int32 s___0 ;

  {
  if (g) {
    if (g->n_mgau != vq->origsize.r) {
      _E__pr_header("subvq.c", 125L, "FATAL_ERROR");
      _E__die_error("Model size conflict: %d x %d (SubVQ) vs %d x %d (Original)\n",
                    vq->origsize.r, vq->origsize.c, g->n_mgau, g->max_comp);
    } else
    if (g->max_comp != vq->origsize.c) {
      _E__pr_header("subvq.c", 125L, "FATAL_ERROR");
      _E__die_error("Model size conflict: %d x %d (SubVQ) vs %d x %d (Original)\n",
                    vq->origsize.r, vq->origsize.c, g->n_mgau, g->max_comp);
    }
  }
  r = 0;
  while (r < vq->origsize.r) {
    c = 0;
    c2 = 0;
    while (c < vq->origsize.c) {
      if (*(*(*(vq->map + r) + c) + 0) < 0) {
        s___0 = 1;
        while (s___0 < vq->n_sv) {
          if (*(*(*(vq->map + r) + c) + s___0) >= 0) {
            _E__pr_header("subvq.c", 141L, "FATAL_ERROR");
            _E__die_error("Partially undefined map[%d][%d]\n", r, c);
          }
          s___0 ++;
        }
      } else {
        if (c2 != c) {
          s___0 = 0;
          while (s___0 < vq->n_sv) {
            if (*(*(*(vq->map + r) + c) + s___0) < 0) {
              _E__pr_header("subvq.c", 147L, "FATAL_ERROR");
              _E__die_error("Partially undefined map[%d][%d]\n", r, c);
            }
            *(*(*(vq->map + r) + c2) + s___0) = *(*(*(vq->map + r) + c) + s___0);
            s___0 ++;
          }
        }
        c2 ++;
      }
      c ++;
    }
    if (g) {
      if (c2 != (g->mgau + r)->n_comp) {
        _E__pr_header("subvq.c", 156L, "FATAL_ERROR");
        _E__die_error("Mixture %d: #Valid components conflict: %d (SubVQ) vs %d (Original)\n",
                      r, c2, (g->mgau + r)->n_comp);
      }
    }
    while (c2 < vq->origsize.c) {
      s___0 = 0;
      while (s___0 < vq->n_sv) {
        *(*(*(vq->map + r) + c2) + s___0) = -1;
        s___0 ++;
      }
      c2 ++;
    }
    r ++;
  }
  return;
}
}
static void subvq_map_linearize(subvq_t *vq ) 
{ 
  int32 r ;
  int32 c ;
  int32 s___0 ;

  {
  r = 0;
  while (r < vq->origsize.r) {
    c = 0;
    while (1) {
      if (c < vq->origsize.c) {
        if (! (*(*(*(vq->map + r) + c) + 0) >= 0)) {
          break;
        }
      } else {
        break;
      }
      s___0 = 0;
      while (s___0 < vq->n_sv) {
        *(*(*(vq->map + r) + c) + s___0) = s___0 * vq->vqsize + *(*(*(vq->map + r) + c) + s___0);
        s___0 ++;
      }
      c ++;
    }
    r ++;
  }
  return;
}
}
subvq_t *subvq_init(char *file , float64 varfloor , int32 max_sv , mgau_model_t *g ) 
{ 
  FILE *fp ;
  char line[16384] ;
  int32 n_sv ;
  int32 s___0 ;
  int32 k___0 ;
  int32 l ;
  int32 n ;
  int32 r ;
  int32 c ;
  char *strp ;
  subvq_t *vq ;
  void const   *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void ***tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  void *tmp___21 ;
  void **tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;

  {
  tmp = cmd_ln_access((char *)"-vqeval");
  VQ_EVAL = *((int32 *)tmp);
  _E__pr_info_header("subvq.c", 199L, "INFO");
  _E__pr_info("Loading Mixture Gaussian sub-VQ file \'%s\' (vq_eval: %d)\n", file,
              VQ_EVAL);
  tmp___0 = __ckd_calloc__((size_t )1, sizeof(subvq_t ), "subvq.c", 201);
  vq = (subvq_t *)tmp___0;
  fp = _myfopen(file, (char *)"r", (char *)"subvq.c", 203);
  while (1) {
    tmp___1 = fgets(line, (int )sizeof(line), fp);
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      _E__pr_header("subvq.c", 208L, "FATAL_ERROR");
      _E__die_error("Failed to read VQParam header\n");
    }
    tmp___2 = sscanf((char const   *)(line), "VQParam %d %d -> %d %d", & vq->origsize.r,
                     & vq->origsize.c, & vq->n_sv, & vq->vqsize);
    if (tmp___2 == 4) {
      break;
    }
  }
  if (g) {
    if (g->n_mgau != vq->origsize.r) {
      _E__pr_header("subvq.c", 216L, "FATAL_ERROR");
      _E__die_error("Model size conflict: %d x %d (SubVQ) vs %d x %d (Original)\n",
                    vq->origsize.r, vq->origsize.c, g->n_mgau, g->max_comp);
    } else
    if (g->max_comp != vq->origsize.c) {
      _E__pr_header("subvq.c", 216L, "FATAL_ERROR");
      _E__die_error("Model size conflict: %d x %d (SubVQ) vs %d x %d (Original)\n",
                    vq->origsize.r, vq->origsize.c, g->n_mgau, g->max_comp);
    }
  }
  if (max_sv < 0) {
    max_sv = vq->n_sv;
  }
  if (max_sv < vq->n_sv) {
    _E__pr_info_header("subvq.c", 223L, "INFO");
    _E__pr_info("Using %d subvectors out of %d\n", max_sv, vq->n_sv);
  } else
  if (max_sv > vq->n_sv) {
    _E__pr_header("subvq.c", 225L, "WARNING");
    _E__pr_warn("#Subvectors specified(%d) > available(%d); using latter\n", max_sv,
                vq->n_sv);
    max_sv = vq->n_sv;
  }
  n_sv = vq->n_sv;
  vq->n_sv = max_sv;
  if (vq->n_sv < VQ_EVAL) {
    VQ_EVAL = vq->n_sv;
  }
  tmp___3 = __ckd_calloc__((size_t )vq->n_sv, sizeof(int32 *), "subvq.c", 233);
  vq->featdim = (int32 **)tmp___3;
  tmp___4 = __ckd_calloc__((size_t )vq->n_sv, sizeof(vector_gautbl_t ), "subvq.c",
                           234);
  vq->gautbl = (vector_gautbl_t *)tmp___4;
  tmp___5 = __ckd_calloc_3d__(vq->origsize.r, vq->origsize.c, vq->n_sv, (int32 )sizeof(int32 ),
                              "subvq.c", 236);
  vq->map = (int32 ***)tmp___5;
  s___0 = 0;
  while (s___0 < n_sv) {
    tmp___6 = fgets(line, (int )sizeof(line), fp);
    if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
      _E__pr_header("subvq.c", 242L, "FATAL_ERROR");
      _E__die_error("Error reading length(subvector %d)\n", s___0);
    } else {
      tmp___7 = sscanf((char const   *)(line), "Subvector %d length %d%n", & k___0,
                       & l, & n);
      if (tmp___7 != 2) {
        _E__pr_header("subvq.c", 242L, "FATAL_ERROR");
        _E__die_error("Error reading length(subvector %d)\n", s___0);
      } else
      if (k___0 != s___0) {
        _E__pr_header("subvq.c", 242L, "FATAL_ERROR");
        _E__die_error("Error reading length(subvector %d)\n", s___0);
      }
    }
    if (s___0 < vq->n_sv) {
      (vq->gautbl + s___0)->veclen = l;
      tmp___8 = __ckd_calloc__((size_t )(vq->gautbl + s___0)->veclen, sizeof(int32 ),
                               "subvq.c", 246);
      *(vq->featdim + s___0) = (int32 *)tmp___8;
      strp = line + n;
      c = 0;
      while (c < (vq->gautbl + s___0)->veclen) {
        tmp___9 = sscanf((char const   *)strp, "%d%n", *(vq->featdim + s___0) + c,
                         & n);
        if (tmp___9 != 1) {
          _E__pr_header("subvq.c", 250L, "FATAL_ERROR");
          _E__die_error("Error reading subvector(%d).featdim(%d)\n", s___0, c);
        }
        strp += n;
        c ++;
      }
      vector_gautbl_alloc(vq->gautbl + s___0, vq->vqsize, (vq->gautbl + s___0)->veclen);
    }
    s___0 ++;
  }
  _E__pr_info_header("subvq.c", 259L, "INFO");
  _E__pr_info("Original #codebooks(states)/codewords: %d x %d\n", vq->origsize.r,
              vq->origsize.c);
  _E__pr_info_header("subvq.c", 260L, "INFO");
  _E__pr_info("Subvectors: %d, VQsize: %d\n", vq->n_sv, vq->vqsize);
  s___0 = 0;
  while (s___0 < vq->n_sv) {
    _E__pr_info_header("subvq.c", 262L, "INFO");
    _E__pr_info("SV %d feature dims(%d): ", s___0, (vq->gautbl + s___0)->veclen);
    c = 0;
    while (c < (vq->gautbl + s___0)->veclen) {
      fprintf(__stdoutp, " %2d", *(*(vq->featdim + s___0) + c));
      c ++;
    }
    fprintf(__stdoutp, "\n");
    s___0 ++;
  }
  s___0 = 0;
  while (s___0 < n_sv) {
    _E__pr_info_header("subvq.c", 271L, "INFO");
    if (s___0 < vq->n_sv) {
      tmp___10 = "";
    } else {
      tmp___10 = " (not used)";
    }
    _E__pr_info("Reading subvq %d%s\n", s___0, tmp___10);
    _E__pr_info_header("subvq.c", 273L, "INFO");
    _E__pr_info("Reading codebook\n");
    tmp___11 = fgets(line, (int )sizeof(line), fp);
    if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
      _E__pr_header("subvq.c", 276L, "FATAL_ERROR");
      _E__die_error("Error reading codebook header\n", s___0);
    } else {
      tmp___12 = sscanf((char const   *)(line), "Codebook %d", & k___0);
      if (tmp___12 != 1) {
        _E__pr_header("subvq.c", 276L, "FATAL_ERROR");
        _E__die_error("Error reading codebook header\n", s___0);
      } else
      if (k___0 != s___0) {
        _E__pr_header("subvq.c", 276L, "FATAL_ERROR");
        _E__die_error("Error reading codebook header\n", s___0);
      }
    }
    r = 0;
    while (r < vq->vqsize) {
      tmp___13 = fgets(line, (int )sizeof(line), fp);
      if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
        _E__pr_header("subvq.c", 280L, "FATAL_ERROR");
        _E__die_error("Error reading row(%d)\n", r);
      }
      if (s___0 >= vq->n_sv) {
        goto __Cont;
      }
      strp = line;
      c = 0;
      while (c < (vq->gautbl + s___0)->veclen) {
        tmp___14 = sscanf((char const   *)strp, "%f %f%n", *((vq->gautbl + s___0)->mean + r) + c,
                          *((vq->gautbl + s___0)->var + r) + c, & k___0);
        if (tmp___14 != 2) {
          _E__pr_header("subvq.c", 288L, "FATAL_ERROR");
          _E__die_error("Error reading row(%d) col(%d)\n", r, c);
        }
        strp += k___0;
        c ++;
      }
      __Cont: /* CIL Label */ 
      r ++;
    }
    _E__pr_info_header("subvq.c", 293L, "INFO");
    _E__pr_info("Reading map\n");
    tmp___15 = fgets(line, (int )sizeof(line), fp);
    if ((unsigned long )tmp___15 == (unsigned long )((void *)0)) {
      _E__pr_header("subvq.c", 296L, "FATAL_ERROR");
      _E__die_error("Error reading map header\n", s___0);
    } else {
      tmp___16 = sscanf((char const   *)(line), "Map %d", & k___0);
      if (tmp___16 != 1) {
        _E__pr_header("subvq.c", 296L, "FATAL_ERROR");
        _E__die_error("Error reading map header\n", s___0);
      } else
      if (k___0 != s___0) {
        _E__pr_header("subvq.c", 296L, "FATAL_ERROR");
        _E__die_error("Error reading map header\n", s___0);
      }
    }
    r = 0;
    while (r < vq->origsize.r) {
      tmp___17 = fgets(line, (int )sizeof(line), fp);
      if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
        _E__pr_header("subvq.c", 300L, "FATAL_ERROR");
        _E__die_error("Error reading row(%d)\n", r);
      }
      if (s___0 >= vq->n_sv) {
        goto __Cont___0;
      }
      strp = line;
      c = 0;
      while (c < vq->origsize.c) {
        tmp___18 = sscanf((char const   *)strp, "%d%n", *(*(vq->map + r) + c) + s___0,
                          & k___0);
        if (tmp___18 != 1) {
          _E__pr_header("subvq.c", 307L, "FATAL_ERROR");
          _E__die_error("Error reading row(%d) col(%d)\n", r, c);
        }
        strp += k___0;
        c ++;
      }
      __Cont___0: /* CIL Label */ 
      r ++;
    }
    fflush(__stdoutp);
    s___0 ++;
  }
  tmp___19 = fscanf(fp, "%s", line);
  if (tmp___19 != 1) {
    _E__pr_header("subvq.c", 316L, "FATAL_ERROR");
    _E__die_error("Error reading \'End\' token\n");
  } else {
    tmp___20 = strcmp((char const   *)(line), "End");
    if (tmp___20 != 0) {
      _E__pr_header("subvq.c", 316L, "FATAL_ERROR");
      _E__die_error("Error reading \'End\' token\n");
    }
  }
  fclose(fp);
  subvq_maha_precomp(vq, varfloor);
  subvq_map_compact(vq, g);
  subvq_map_linearize(vq);
  n = 0;
  s___0 = 0;
  while (s___0 < n_sv) {
    if ((vq->gautbl + s___0)->veclen > n) {
      n = (vq->gautbl + s___0)->veclen;
    }
    s___0 ++;
  }
  tmp___21 = __ckd_calloc__((size_t )n, sizeof(float32 ), "subvq.c", 330);
  vq->subvec = (float32 *)tmp___21;
  tmp___22 = __ckd_calloc_2d__(vq->n_sv, vq->vqsize, (int32 )sizeof(int32 ), "subvq.c",
                               331);
  vq->vqdist = (int32 **)tmp___22;
  tmp___23 = __ckd_calloc__((size_t )vq->origsize.c, sizeof(int32 ), "subvq.c", 332);
  vq->gauscore = (int32 *)tmp___23;
  tmp___24 = __ckd_calloc__((size_t )(vq->origsize.c + 1), sizeof(int32 ), "subvq.c",
                            333);
  vq->mgau_sl = (int32 *)tmp___24;
  return (vq);
}
}
int32 subvq_mgau_shortlist(subvq_t *vq , int32 m , int32 n , int32 beam ) 
{ 
  int32 *gauscore ;
  int32 *map ;
  int32 i ;
  int32 v ;
  int32 bv___0 ;
  int32 th ;
  int32 nc ;
  int32 *sl ;
  int32 *vqdist ;
  int32 sv_id ;
  int32 *tmp ;
  int32 *tmp___0 ;
  int32 *tmp___1 ;
  int32 *tmp___2 ;
  int32 *tmp___3 ;
  int32 *tmp___4 ;
  int32 *tmp___5 ;
  int32 *tmp___6 ;
  int32 tmp___7 ;

  {
  vqdist = *(vq->vqdist + 0);
  gauscore = vq->gauscore;
  sl = vq->mgau_sl;
  map = *(*(vq->map + m) + 0);
  bv___0 = (int32 )2147483648U;
  switch (vq->n_sv) {
  case 3: 
  i = 0;
  while (i < n) {
    if (VQ_EVAL == 1) {
      v = *(vqdist + *map);
      map += 3;
    } else
    if (VQ_EVAL == 2) {
      tmp = map;
      map ++;
      v = *(vqdist + *tmp);
      v += 2 * *(vqdist + *map);
      map += 2;
    } else {
      tmp___0 = map;
      map ++;
      v = *(vqdist + *tmp___0);
      tmp___1 = map;
      map ++;
      v += *(vqdist + *tmp___1);
      tmp___2 = map;
      map ++;
      v += *(vqdist + *tmp___2);
    }
    *(gauscore + i) = v;
    if (bv___0 < v) {
      bv___0 = v;
    }
    i ++;
  }
  break;
  case 2: 
  i = 0;
  while (i < n) {
    tmp___3 = map;
    map ++;
    v = *(vqdist + *tmp___3);
    tmp___4 = map;
    map ++;
    v += *(vqdist + *tmp___4);
    *(gauscore + i) = v;
    if (bv___0 < v) {
      bv___0 = v;
    }
    i ++;
  }
  break;
  case 1: 
  i = 0;
  while (i < n) {
    tmp___5 = map;
    map ++;
    v = *(vqdist + *tmp___5);
    *(gauscore + i) = v;
    if (bv___0 < v) {
      bv___0 = v;
    }
    i ++;
  }
  break;
  default: 
  i = 0;
  while (i < n) {
    v = 0;
    sv_id = 0;
    while (sv_id < vq->n_sv) {
      tmp___6 = map;
      map ++;
      v += *(vqdist + *tmp___6);
      sv_id ++;
    }
    *(gauscore + i) = v;
    if (bv___0 < v) {
      bv___0 = v;
    }
    i ++;
  }
  }
  th = bv___0 + beam;
  nc = 0;
  i = 0;
  while (i < n) {
    if (*(gauscore + i) >= th) {
      tmp___7 = nc;
      nc ++;
      *(sl + tmp___7) = i;
    }
    i ++;
  }
  *(sl + nc) = -1;
  return (nc);
}
}
void subvq_subvec_eval_logs3(subvq_t *vq , float32 *feat , int32 s___0 ) 
{ 
  int32 i ;
  int32 *featdim ;

  {
  featdim = *(vq->featdim + s___0);
  i = 0;
  while (i < (vq->gautbl + s___0)->veclen) {
    *(vq->subvec + i) = *(feat + *(featdim + i));
    i ++;
  }
  vector_gautbl_eval_logs3(vq->gautbl + s___0, 0, vq->vqsize, vq->subvec, *(vq->vqdist + s___0));
  return;
}
}
void subvq_gautbl_eval_logs3(subvq_t *vq , float32 *feat ) 
{ 
  int32 s___0 ;
  int32 i ;
  int32 *featdim ;

  {
  s___0 = 0;
  while (s___0 < vq->n_sv) {
    featdim = *(vq->featdim + s___0);
    i = 0;
    while (i < (vq->gautbl + s___0)->veclen) {
      *(vq->subvec + i) = *(feat + *(featdim + i));
      i ++;
    }
    if (s___0 < VQ_EVAL) {
      vector_gautbl_eval_logs3(vq->gautbl + s___0, 0, vq->vqsize, vq->subvec, *(vq->vqdist + s___0));
    }
    s___0 ++;
  }
  return;
}
}
int32 subvq_frame_eval(subvq_t *vq , mgau_model_t *g , int32 beam , float32 *feat ,
                       int32 *sen_active , int32 *senscr ) 
{ 
  int32 s___0 ;
  int32 best ;
  int32 ns ;
  int32 ng ;
  int32 tmp ;

  {
  best = (int32 )2147483648U;
  ns = 0;
  ng = 0;
  if (! vq) {
    s___0 = 0;
    while (s___0 < g->n_mgau) {
      if (! sen_active) {
        goto _L;
      } else
      if (*(sen_active + s___0)) {
        _L: /* CIL Label */ 
        *(senscr + s___0) = mgau_eval(g, s___0, (int32 *)((void *)0), feat);
        if (best < *(senscr + s___0)) {
          best = *(senscr + s___0);
        }
        ns ++;
        ng += (g->mgau + s___0)->n_comp;
      } else {
        *(senscr + s___0) = (int32 )3355443200U;
      }
      s___0 ++;
    }
  } else {
    subvq_gautbl_eval_logs3(vq, feat);
    s___0 = 0;
    while (s___0 < g->n_mgau) {
      if (! sen_active) {
        goto _L___0;
      } else
      if (*(sen_active + s___0)) {
        _L___0: /* CIL Label */ 
        tmp = subvq_mgau_shortlist(vq, s___0, (g->mgau + s___0)->n_comp, beam);
        ng += tmp;
        *(senscr + s___0) = mgau_eval(g, s___0, vq->mgau_sl, feat);
        if (best < *(senscr + s___0)) {
          best = *(senscr + s___0);
        }
        ns ++;
      } else {
        *(senscr + s___0) = (int32 )3355443200U;
      }
      s___0 ++;
    }
  }
  s___0 = 0;
  while (s___0 < g->n_mgau) {
    *(senscr + s___0) -= best;
    s___0 ++;
  }
  g->frm_sen_eval = ns;
  g->frm_gau_eval = ng;
  return (best);
}
}
int32 subvq_mgau_eval(mgau_model_t *g , subvq_t *vq , int32 m , int32 n , int32 *active ) 
{ 
  mgau_t *mgau ;
  int32 *map ;
  int32 i ;
  int32 v ;
  int32 sv_id ;
  int32 c ;
  int32 *vqdist ;
  int32 score ;
  int32 last_active ;
  float64 f ;
  int32 *tmp ;
  int32 *tmp___0 ;

  {
  f = log_to_logs3_factor();
  vqdist = *(vq->vqdist + 0);
  score = (int32 )3355443200U;
  mgau = g->mgau + m;
  map = *(*(vq->map + m) + 0);
  if (! active) {
    i = 0;
    while (i < n) {
      v = 0;
      sv_id = 0;
      while (sv_id < vq->n_sv) {
        tmp = map;
        map ++;
        v += *(vqdist + *tmp);
        sv_id ++;
      }
      score = logs3_add(score, v + *(mgau->mixw + i));
      i ++;
    }
  } else {
    last_active = 0;
    i = 0;
    while (*(active + i) >= 0) {
      c = *(active + i);
      i ++;
    }
    i = 0;
    while (*(active + i) >= 0) {
      c = *(active + i);
      map += (c - last_active) * vq->n_sv;
      v = 0;
      sv_id = 0;
      while (sv_id < vq->n_sv) {
        tmp___0 = map;
        map ++;
        v += *(vqdist + *tmp___0);
        sv_id ++;
      }
      last_active = c + 1;
      score = logs3_add(score, v + *(mgau->mixw + i));
      i ++;
    }
  }
  if (score == -939524096) {
    _E__pr_info_header("subvq.c", 576L, "INFO");
    _E__pr_info("Warning!! Score is S3_LOGPROB_ZERO\n");
  }
  return (score);
}
}
void subvq_free(subvq_t *s___0 ) 
{ 
  int i ;

  {
  if (s___0) {
    i = 0;
    while (i < s___0->n_sv) {
      if (*(s___0->featdim + i)) {
        ckd_free((void *)*(s___0->featdim + i));
      }
      i ++;
    }
    if (s___0->featdim) {
      ckd_free((void *)s___0->featdim);
    }
    if (s___0->gautbl) {
      ckd_free((void *)s___0->gautbl);
    }
    if (s___0->map) {
      ckd_free_3d((void ***)s___0->map);
    }
    if (s___0->subvec) {
      ckd_free((void *)s___0->subvec);
    }
    if (s___0->vqdist) {
      ckd_free_2d((void **)s___0->vqdist);
    }
    if (s___0->gauscore) {
      ckd_free((void *)s___0->gauscore);
    }
    if (s___0->mgau_sl) {
      ckd_free((void *)s___0->mgau_sl);
    }
    ckd_free((void *)s___0);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-fz_Q3TMZ.i","-O3")
void tmat_dump(tmat_t *tmat , FILE *fp ) ;
int32 tmat_chk_uppertri(tmat_t *tmat ) ;
void tmat_dump(tmat_t *tmat , FILE *fp ) 
{ 
  int32 i ;
  int32 src ;
  int32 dst ;

  {
  i = 0;
  while (i < tmat->n_tmat) {
    fprintf(fp, "TMAT %d = %d x %d\n", i, tmat->n_state, tmat->n_state + 1);
    src = 0;
    while (src < tmat->n_state) {
      dst = 0;
      while (dst <= tmat->n_state) {
        fprintf(fp, " %12d", *(*(*(tmat->tp + i) + src) + dst));
        dst ++;
      }
      fprintf(fp, "\n");
      src ++;
    }
    fprintf(fp, "\n");
    i ++;
  }
  fflush(fp);
  return;
}
}
int32 tmat_chk_uppertri(tmat_t *tmat ) 
{ 
  int32 i ;
  int32 src ;
  int32 dst ;

  {
  i = 0;
  while (i < tmat->n_tmat) {
    dst = 0;
    while (dst < tmat->n_state) {
      src = dst + 1;
      while (src < tmat->n_state) {
        if (*(*(*(tmat->tp + i) + src) + dst) > -939524096) {
          return (-1);
        }
        src ++;
      }
      dst ++;
    }
    i ++;
  }
  return (0);
}
}
int32 tmat_chk_1skip(tmat_t *tmat ) 
{ 
  int32 i ;
  int32 src ;
  int32 dst ;

  {
  i = 0;
  while (i < tmat->n_tmat) {
    src = 0;
    while (src < tmat->n_state) {
      dst = src + 3;
      while (dst <= tmat->n_state) {
        if (*(*(*(tmat->tp + i) + src) + dst) > -939524096) {
          return (-1);
        }
        dst ++;
      }
      src ++;
    }
    i ++;
  }
  return (0);
}
}
tmat_t *tmat_init(char *file_name , float64 tpfloor ) 
{ 
  char tmp ;
  int32 n_src ;
  int32 n_dst ;
  FILE *fp ;
  int32 byteswap ;
  int32 chksum_present ;
  uint32 chksum ;
  float32 **tp ;
  int32 i ;
  int32 j ;
  int32 k___0 ;
  int32 tp_per_tmat ;
  char **argname ;
  char **argval___0 ;
  tmat_t *t ;
  void *tmp___0 ;
  int32 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int32 tmp___5 ;
  int32 tmp___6 ;
  int32 tmp___7 ;
  int32 tmp___8 ;
  void ***tmp___9 ;
  void **tmp___10 ;
  int32 tmp___11 ;
  int32 tmp___12 ;
  size_t tmp___13 ;
  int32 tmp___14 ;

  {
  _E__pr_info_header("tmat.c", 135L, "INFO");
  _E__pr_info("Reading HMM transition probability matrices: %s\n", file_name);
  tmp___0 = __ckd_calloc__((size_t )1, sizeof(tmat_t ), "tmat.c", 137);
  t = (tmat_t *)tmp___0;
  fp = fopen((char const   *)file_name, "rb");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    _E__pr_header("tmat.c", 140L, "SYSTEM_ERROR");
    _E__fatal_sys_error("fopen(%s,rb) failed\n", file_name);
  }
  tmp___1 = bio_readhdr(fp, & argname, & argval___0, & byteswap);
  if (tmp___1 < 0) {
    _E__pr_header("tmat.c", 144L, "FATAL_ERROR");
    _E__die_error("bio_readhdr(%s) failed\n", file_name);
  }
  chksum_present = 0;
  i = 0;
  while (*(argname + i)) {
    tmp___4 = strcmp((char const   *)*(argname + i), "version");
    if (tmp___4 == 0) {
      tmp___2 = strcmp((char const   *)*(argval___0 + i), "1.0");
      if (tmp___2 != 0) {
        _E__pr_header("tmat.c", 151L, "WARNING");
        _E__pr_warn("Version mismatch(%s): %s, expecting %s\n", file_name, *(argval___0 + i),
                    "1.0");
      }
    } else {
      tmp___3 = strcmp((char const   *)*(argname + i), "chksum0");
      if (tmp___3 == 0) {
        chksum_present = 1;
      }
    }
    i ++;
  }
  bio_hdrarg_free(argname, argval___0);
  argval___0 = (char **)((void *)0);
  argname = argval___0;
  chksum = (uint32 )0;
  tmp___5 = bio_fread((void *)(& t->n_tmat), (int32 )sizeof(int32 ), 1, fp, byteswap,
                      & chksum);
  if (tmp___5 != 1) {
    _E__pr_header("tmat.c", 167L, "FATAL_ERROR");
    _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
  } else {
    tmp___6 = bio_fread((void *)(& n_src), (int32 )sizeof(int32 ), 1, fp, byteswap,
                        & chksum);
    if (tmp___6 != 1) {
      _E__pr_header("tmat.c", 167L, "FATAL_ERROR");
      _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
    } else {
      tmp___7 = bio_fread((void *)(& n_dst), (int32 )sizeof(int32 ), 1, fp, byteswap,
                          & chksum);
      if (tmp___7 != 1) {
        _E__pr_header("tmat.c", 167L, "FATAL_ERROR");
        _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
      } else {
        tmp___8 = bio_fread((void *)(& i), (int32 )sizeof(int32 ), 1, fp, byteswap,
                            & chksum);
        if (tmp___8 != 1) {
          _E__pr_header("tmat.c", 167L, "FATAL_ERROR");
          _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
        }
      }
    }
  }
  if (t->n_tmat >= 2147483646) {
    _E__pr_header("tmat.c", 170L, "FATAL_ERROR");
    _E__die_error("%s: #tmat (%d) exceeds limit (%d)\n", file_name, t->n_tmat, 2147483646);
  }
  if (n_dst != n_src + 1) {
    _E__pr_header("tmat.c", 172L, "FATAL_ERROR");
    _E__die_error("%s: #from-states(%d) != #to-states(%d)-1\n", file_name, n_src,
                  n_dst);
  }
  t->n_state = n_src;
  if (i != (t->n_tmat * n_src) * n_dst) {
    _E__pr_header("tmat.c", 176L, "FATAL_ERROR");
    _E__die_error("%s: #float32s(%d) doesn\'t match dimensions: %d x %d x %d\n", file_name,
                  i, t->n_tmat, n_src, n_dst);
  }
  tmp___9 = __ckd_calloc_3d__(t->n_tmat, n_src, n_dst, (int32 )sizeof(int32 ), "tmat.c",
                              181);
  t->tp = (int32 ***)tmp___9;
  tmp___10 = __ckd_calloc_2d__(n_src, n_dst, (int32 )sizeof(float32 ), "tmat.c", 184);
  tp = (float32 **)tmp___10;
  tp_per_tmat = n_src * n_dst;
  i = 0;
  while (i < t->n_tmat) {
    tmp___11 = bio_fread((void *)*(tp + 0), (int32 )sizeof(float32 ), tp_per_tmat,
                         fp, byteswap, & chksum);
    if (tmp___11 != tp_per_tmat) {
      _E__pr_header("tmat.c", 191L, "FATAL_ERROR");
      _E__die_error("fread(%s) (arraydata) failed\n", file_name);
    }
    j = 0;
    while (j < n_src) {
      vector_nz_floor(*(tp + j), n_dst, tpfloor);
      vector_sum_norm(*(tp + j), n_dst);
      k___0 = 0;
      while (k___0 < n_dst) {
        if ((double )*(*(tp + j) + k___0) == 0.0) {
          *(*(*(t->tp + i) + j) + k___0) = (int32 )3355443200U;
        } else {
          tmp___12 = logs3((float64 )*(*(tp + j) + k___0));
          *(*(*(t->tp + i) + j) + k___0) = tmp___12;
        }
        k___0 ++;
      }
      j ++;
    }
    i ++;
  }
  ckd_free_2d((void **)tp);
  if (chksum_present) {
    bio_verify_chksum(fp, byteswap, chksum);
  }
  tmp___13 = fread((void *)(& tmp), (size_t )1, (size_t )1, fp);
  if (tmp___13 == 1UL) {
    _E__pr_header("tmat.c", 213L, "ERROR");
    _E__pr_warn("Non-empty file beyond end of data\n");
  }
  fclose(fp);
  _E__pr_info_header("tmat.c", 217L, "INFO");
  _E__pr_info("Read %d transition matrices of size %dx%d\n", t->n_tmat, t->n_state,
              t->n_state + 1);
  tmp___14 = tmat_chk_uppertri(t);
  if (tmp___14 < 0) {
    _E__pr_header("tmat.c", 221L, "FATAL_ERROR");
    _E__die_error("Tmat not upper triangular\n");
  }
  return (t);
}
}
void tmat_free(tmat_t *t ) 
{ 


  {
  if (t) {
    if (t->tp) {
      ckd_free_3d((void ***)t->tp);
    }
    ckd_free((void *)t);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-oBo_mDsK.i","-O3")
extern int getrlimit(int  , struct rlimit * )  __asm__("_getrlimit")  ;
extern int setrlimit(int  , struct rlimit  const  * )  __asm__("_setrlimit")  ;
void unlimit(void) 
{ 
  struct rlimit rl ;

  {
  getrlimit(2, & rl);
  rl.rlim_cur = rl.rlim_max;
  setrlimit(2, (struct rlimit  const  *)(& rl));
  return;
}
}
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-fbm0QKSj.i","-O3")
__inline static char *__inline_strcat_chk(char *__dest , char const   *__src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcat_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
extern char *getcwd(char * , size_t  ) ;
int32 vithist_utt_begin(vithist_t *vh , kbcore_t *kbc ) ;
void vithist_utt_reset(vithist_t *vh ) ;
vithist_entry_t *vithist_id2entry(vithist_t *vh , int32 id ) ;
void vithist_frame_windup(vithist_t *vh , int32 frm , FILE *fp , kbcore_t *kbc ) ;
void vithist_prune(vithist_t *vh , dict_t *dict , int32 frm , int32 maxwpf___0 , int32 maxhist ,
                   int32 beam ) ;
void vithist_dump(vithist_t *vh , int32 frm , kbcore_t *kbc , FILE *fp ) ;
void vithist_dag_write(vithist_t *vh , glist_t hyp , dict_t *dict , int32 oldfmt ,
                       FILE *fp ) ;
void utt_word_trans(kb_t *kb___0 , int32 cf ) ;
long tot_considered  =    0L;
FILE *confp  ;
int confp_open  =    0;
static int32 NO_UFLOW_ADD___0(int32 a , int32 b ) 
{ 
  int32 c ;

  {
  c = a + b;
  if (c > 0) {
    if (a < 0) {
      if (b < 0) {
        c = (int32 )2147483648U;
      } else {
        c = c;
      }
    } else {
      c = c;
    }
  } else {
    c = c;
  }
  return (c);
}
}
void matchseg_write(FILE *fp , kb_t *kb___0 , glist_t hyp , char *hdr ) 
{ 
  gnode_t *gn ;
  hyp_t *h ;
  int32 ascr ;
  int32 lscr ;
  dict_t *dict ;
  char const   *tmp ;

  {
  ascr = 0;
  lscr = 0;
  gn = hyp;
  while (gn) {
    h = (hyp_t *)gn->data.ptr;
    ascr += h->ascr;
    lscr += h->lscr;
    gn = gn->next;
  }
  dict = (kb___0->kbcore)->dict;
  if (hdr) {
    tmp = (char const   *)hdr;
  } else {
    tmp = "";
  }
  fprintf(fp, "%s%s S 0 T %d A %d L %d", tmp, kb___0->uttid, ascr + lscr, ascr, lscr);
  gn = hyp;
  while (1) {
    if (gn) {
      if (! gn->next) {
        break;
      }
    } else {
      break;
    }
    h = (hyp_t *)gn->data.ptr;
    fprintf(fp, " %d %d %d %s", h->sf, h->ascr, h->lscr, (dict->word + h->id)->word);
    gn = gn->next;
  }
  fprintf(fp, " %d\n", kb___0->nfr);
  fflush(fp);
  return;
}
}
void match_write(FILE *fp , kb_t *kb___0 , glist_t hyp , char *hdr ) 
{ 
  gnode_t *gn ;
  hyp_t *h ;
  dict_t *dict ;
  int counter ;
  int32 tmp ;

  {
  counter = 0;
  dict = (kb___0->kbcore)->dict;
  gn = hyp;
  while (1) {
    if (gn) {
      if (! gn->next) {
        break;
      }
    } else {
      break;
    }
    h = (hyp_t *)gn->data.ptr;
    tmp = dict_filler_word(dict, h->id);
    if (! tmp) {
      if (h->id != dict->finishwid) {
        fprintf(fp, "%s ", (dict->word + (dict->word + h->id)->basewid)->word);
      }
    }
    counter ++;
    gn = gn->next;
  }
  if (counter == 0) {
    fprintf(fp, " ");
  }
  fprintf(fp, "(%s)\n", kb___0->uttid);
  fflush(fp);
  return;
}
}
void utt_begin(kb_t *kb___0 ) 
{ 
  kbcore_t *kbc ;
  int32 n ;
  int32 pred ;

  {
  kbc = kb___0->kbcore;
  pred = vithist_utt_begin(kb___0->vithist, kbc);
  n = (*(kb___0->ugtree + 0))->n_next_active;
  lextree_enter(*(kb___0->ugtree + 0), (kbc->mdef)->sil, -1, 0, pred, (kb___0->beam)->hmm);
  n = (*(kb___0->fillertree + 0))->n_next_active;
  lextree_enter(*(kb___0->fillertree + 0), (s3cipid_t )-1, -1, 0, pred, (kb___0->beam)->hmm);
  kb___0->n_lextrans = 1;
  kb_lextree_active_swap(kb___0);
  return;
}
}
void utt_end(kb_t *kb___0 ) 
{ 
  int32 id ;
  int32 ascr ;
  int32 lscr ;
  glist_t hyp ;
  gnode_t *gn ;
  hyp_t *h ;
  FILE *fp ;
  FILE *latfp ;
  dict_t *dict ;
  int32 i ;
  char *hyp_strptr ;
  char file[8192] ;
  void const   *tmp ;
  unsigned long tmp___0 ;
  void const   *tmp___1 ;
  size_t tmp___2 ;
  int32 tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int32 tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  size_t tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  int32 tmp___12 ;
  char str[16384] ;
  int32 ispipe ;
  float64 logbase ;
  void const   *tmp___13 ;
  void const   *tmp___14 ;
  unsigned long tmp___15 ;
  void const   *tmp___16 ;
  void const   *tmp___17 ;
  void const   *tmp___18 ;
  void const   *tmp___19 ;
  void const   *tmp___20 ;
  void const   *tmp___21 ;
  void const   *tmp___22 ;
  void const   *tmp___23 ;
  void const   *tmp___24 ;
  void const   *tmp___25 ;
  void const   *tmp___26 ;
  void const   *tmp___27 ;
  int32 j ;
  int32 k___0 ;

  {
  fp = __stdoutp;
  dict = (kb___0->kbcore)->dict;
  kb_freehyps(kb___0);
  id = vithist_utt_end(kb___0->vithist, kb___0->kbcore);
  if (id >= 0) {
    tmp___1 = cmd_ln_access((char *)"-bptbldir");
    if ((char *)tmp___1) {
      tmp = cmd_ln_access((char *)"-bptbldir");
      tmp___0 = __builtin_object_size((void *)(file), 1);
      __builtin___sprintf_chk(file, 0, tmp___0, "%s/%s.bpt", (char *)tmp, kb___0->uttid);
      latfp = fopen((char const   *)(file), "w");
      if ((unsigned long )latfp == (unsigned long )((void *)0)) {
        _E__pr_header("utt.c", 199L, "ERROR");
        _E__pr_warn("fopen(%s,w) failed; using stdout\n", file);
        latfp = __stdoutp;
      }
      vithist_dump(kb___0->vithist, -1, kb___0->kbcore, latfp);
      if ((unsigned long )latfp != (unsigned long )__stdoutp) {
        fclose(latfp);
      }
    }
    hyp = vithist_backtrace(kb___0->vithist, id);
    fprintf(fp, "\nBacktrace(%s)\n", kb___0->uttid);
    fprintf(fp, "%6s %5s %5s %11s %8s %4s\n", "LatID", "SFrm", "EFrm", "AScr", "LScr",
            "Type");
    ascr = 0;
    lscr = 0;
    gn = hyp;
    while (gn) {
      h = (hyp_t *)gn->data.ptr;
      fprintf(fp, "%6d %5d %5d %11d %8d %4d %s\n", h->vhid, h->sf, h->ef, h->ascr,
              h->lscr, h->type, (dict->word + h->id)->word);
      ascr += h->ascr;
      lscr += h->lscr;
      (kb___0->hyp_seglen) ++;
      tmp___3 = dict_filler_word(dict, h->id);
      if (! tmp___3) {
        if (h->id != dict->finishwid) {
          tmp___2 = strlen((char const   *)(dict->word + (dict->word + h->id)->basewid)->word);
          kb___0->hyp_strlen = (int32 )((size_t )kb___0->hyp_strlen + (tmp___2 + 1UL));
        }
      }
      gn = gn->next;
    }
    fprintf(fp, "       %5d %5d %11d %8d (Total)\n", 0, kb___0->nfr, ascr, lscr);
    tmp___4 = __ckd_calloc__((size_t )kb___0->hyp_seglen, sizeof(hyp_t *), "utt.c",
                             234);
    kb___0->hyp_segs = (hyp_t **)tmp___4;
    tmp___5 = __ckd_calloc__((size_t )(kb___0->hyp_strlen + 1), sizeof(char ), "utt.c",
                             235);
    kb___0->hyp_str = (char *)tmp___5;
    hyp_strptr = kb___0->hyp_str;
    fprintf(fp, "\nFWDVIT: ");
    i = 0;
    gn = hyp;
    while (gn) {
      h = (hyp_t *)gn->data.ptr;
      tmp___6 = i;
      i ++;
      *(kb___0->hyp_segs + tmp___6) = h;
      tmp___12 = dict_filler_word(dict, h->id);
      if (! tmp___12) {
        if (h->id != dict->finishwid) {
          tmp___8 = __builtin_object_size((void *)hyp_strptr, 0);
          if (tmp___8 != 0xffffffffffffffffUL) {
            tmp___7 = __builtin_object_size((void *)hyp_strptr, 1);
            __builtin___strcat_chk(hyp_strptr, (char const   *)(dict->word + (dict->word + h->id)->basewid)->word,
                                   tmp___7);
          } else {
            __inline_strcat_chk(hyp_strptr, (char const   *)(dict->word + (dict->word + h->id)->basewid)->word);
          }
          tmp___9 = strlen((char const   *)hyp_strptr);
          hyp_strptr += tmp___9;
          tmp___11 = __builtin_object_size((void *)hyp_strptr, 0);
          if (tmp___11 != 0xffffffffffffffffUL) {
            tmp___10 = __builtin_object_size((void *)hyp_strptr, 1);
            __builtin___strcat_chk(hyp_strptr, " ", tmp___10);
          } else {
            __inline_strcat_chk(hyp_strptr, " ");
          }
          hyp_strptr ++;
        }
      }
      gn = gn->next;
    }
    *(kb___0->hyp_str + kb___0->hyp_strlen) = (char )'\000';
    fprintf(fp, "\'%s\' (%s)\n\n", kb___0->hyp_str, kb___0->uttid);
    if (kb___0->matchsegfp) {
      matchseg_write(kb___0->matchsegfp, kb___0, hyp, (char *)((void *)0));
    }
    matchseg_write(fp, kb___0, hyp, (char *)"FWDXCT: ");
    fprintf(fp, "\n");
    if (! confp_open) {
      confp = fopen("considered.out", "w");
      if ((unsigned long )confp == (unsigned long )((void *)0)) {
        _E__pr_header("utt.c", 269L, "FATAL_ERROR");
        _E__die_error("fopen considered.out failed\n");
      }
      confp_open = 1;
    }
    fprintf(confp, "%22d considered for utterance %s\n", considered, kb___0->uttid);
    tot_considered += considered;
    considered = 0L;
    if (kb___0->matchfp) {
      match_write(kb___0->matchfp, kb___0, hyp, (char *)((void *)0));
    }
    tmp___27 = cmd_ln_access((char *)"-outlatdir");
    if ((char *)tmp___27) {
      tmp___13 = cmd_ln_access((char *)"-latext");
      tmp___14 = cmd_ln_access((char *)"-outlatdir");
      tmp___15 = __builtin_object_size((void *)(str), 1);
      __builtin___sprintf_chk(str, 0, tmp___15, "%s/%s.%s", (char *)tmp___14, kb___0->uttid,
                              (char *)tmp___13);
      _E__pr_info_header("utt.c", 289L, "INFO");
      _E__pr_info("Writing lattice file: %s\n", str);
      latfp = fopen_comp(str, (char *)"w", & ispipe);
      if ((unsigned long )latfp == (unsigned long )((void *)0)) {
        _E__pr_header("utt.c", 292L, "ERROR");
        _E__pr_warn("fopen_comp (%s,w) failed\n", str);
      } else {
        getcwd(str, sizeof(str));
        fprintf(latfp, "# getcwd: %s\n", str);
        tmp___16 = cmd_ln_access((char *)"-logbase");
        logbase = (float64 )*((float32 *)tmp___16);
        fprintf(latfp, "# -logbase %e\n", logbase);
        tmp___17 = cmd_ln_access((char *)"-dict");
        fprintf(latfp, "# -dict %s\n", (char *)tmp___17);
        tmp___19 = cmd_ln_access((char *)"-fdict");
        if ((char *)tmp___19) {
          tmp___18 = cmd_ln_access((char *)"-fdict");
          fprintf(latfp, "# -fdict %s\n", (char *)tmp___18);
        }
        tmp___20 = cmd_ln_access((char *)"-lm");
        fprintf(latfp, "# -lm %s\n", (char *)tmp___20);
        tmp___21 = cmd_ln_access((char *)"-mdef");
        fprintf(latfp, "# -mdef %s\n", (char *)tmp___21);
        tmp___22 = cmd_ln_access((char *)"-mean");
        fprintf(latfp, "# -mean %s\n", (char *)tmp___22);
        tmp___23 = cmd_ln_access((char *)"-var");
        fprintf(latfp, "# -var %s\n", (char *)tmp___23);
        tmp___24 = cmd_ln_access((char *)"-mixw");
        fprintf(latfp, "# -mixw %s\n", (char *)tmp___24);
        tmp___25 = cmd_ln_access((char *)"-tmat");
        fprintf(latfp, "# -tmat %s\n", (char *)tmp___25);
        fprintf(latfp, "#\n");
        fprintf(latfp, "Frames %d\n", kb___0->nfr);
        fprintf(latfp, "#\n");
        tmp___26 = cmd_ln_access((char *)"-outlatoldfmt");
        vithist_dag_write(kb___0->vithist, hyp, dict, *((int32 *)tmp___26), latfp);
        fclose_comp(latfp, ispipe);
      }
    }
    glist_free(hyp);
  } else {
    _E__pr_header("utt.c", 328L, "ERROR");
    _E__pr_warn("%s: No recognition\n\n", kb___0->uttid);
  }
  _E__pr_info_header("utt.c", 337L, "INFO");
  _E__pr_info("%4d frm;  %4d sen, %5d gau/fr, Sen %4.2f CPU %4.2f Clk [Ovrhd %4.2f CPU %4.2f Clk];  %5d hmm, %3d wd/fr, %4.2f CPU %4.2f Clk (%s)\n",
              kb___0->nfr, (kb___0->utt_sen_eval + (kb___0->nfr >> 1)) / kb___0->nfr,
              (kb___0->utt_gau_eval + (kb___0->nfr >> 1)) / kb___0->nfr, 0.0, 0.0,
              0.0, 0.0, (kb___0->utt_hmm_eval + (kb___0->nfr >> 1)) / kb___0->nfr,
              ((kb___0->vithist)->n_entry + (kb___0->nfr >> 1)) / kb___0->nfr, 0.0,
              0.0, kb___0->uttid);
  j = kb___0->hmm_hist_bins - 1;
  while (1) {
    if (j >= 0) {
      if (! (*(kb___0->hmm_hist + j) == 0)) {
        break;
      }
    } else {
      break;
    }
    j --;
  }
  _E__pr_info_header("utt.c", 375L, "INFO");
  _E__pr_info("HMMHist[0..%d](%s):", j, kb___0->uttid);
  i = 0;
  k___0 = 0;
  while (i <= j) {
    k___0 += *(kb___0->hmm_hist + i);
    fprintf(__stdoutp, " %d(%d)", *(kb___0->hmm_hist + i), (k___0 * 100) / kb___0->nfr);
    i ++;
  }
  fprintf(__stdoutp, "\n");
  kb___0->tot_sen_eval += (float64 )kb___0->utt_sen_eval;
  kb___0->tot_gau_eval += (float64 )kb___0->utt_gau_eval;
  kb___0->tot_hmm_eval += (float64 )kb___0->utt_hmm_eval;
  kb___0->tot_wd_exit += (float64 )(kb___0->vithist)->n_entry;
  ptmr_reset(& kb___0->tm_sen);
  ptmr_reset(& kb___0->tm_srch);
  ptmr_reset(& kb___0->tm_ovrhd);
  i = 0;
  while (i < kb___0->n_lextree) {
    lextree_utt_end(*(kb___0->ugtree + i), kb___0->kbcore);
    lextree_utt_end(*(kb___0->fillertree + i), kb___0->kbcore);
    i ++;
  }
  vithist_utt_reset(kb___0->vithist);
  lm_cache_stats_dump((kb___0->kbcore)->lm);
  lm_cache_reset((kb___0->kbcore)->lm);
  return;
}
}
static int32 *bs  =    (int32 *)((void *)0);
static int32 *bv  =    (int32 *)((void *)0);
static int32 epl  ;
void utt_word_trans(kb_t *kb___0 , int32 cf ) 
{ 
  int32 k___0 ;
  int32 th ;
  vithist_t *vh ;
  vithist_entry_t *ve ;
  int32 vhid ;
  int32 le ;
  int32 n_ci ;
  int32 score ;
  int32 maxpscore ;
  s3wid_t wid ;
  int32 p ;
  dict_t *dict ;
  mdef_t *mdef ;
  void *tmp ;
  void *tmp___0 ;
  void const   *tmp___1 ;
  int32 tmp___2 ;

  {
  maxpscore = (int32 )2147483648U;
  vh = kb___0->vithist;
  th = kb___0->bestscore + (kb___0->beam)->hmm;
  if (*(vh->bestvh + cf) < 0) {
    return;
  }
  dict = (kb___0->kbcore)->dict;
  mdef = (kb___0->kbcore)->mdef;
  n_ci = mdef->n_ciphone;
  if (! bs) {
    tmp = __ckd_calloc__((size_t )n_ci, sizeof(int32 ), "utt.c", 439);
    bs = (int32 *)tmp;
    tmp___0 = __ckd_calloc__((size_t )n_ci, sizeof(int32 ), "utt.c", 440);
    bv = (int32 *)tmp___0;
    tmp___1 = cmd_ln_access((char *)"-epl");
    epl = *((int32 *)tmp___1);
  }
  p = 0;
  while (p < n_ci) {
    *(bs + p) = (int32 )2147483648U;
    *(bv + p) = -1;
    p ++;
  }
  vhid = *(vh->frame_start + cf);
  le = vh->n_entry - 1;
  while (vhid <= le) {
    ve = vithist_id2entry(vh, vhid);
    if (! ve->valid) {
      goto __Cont;
    }
    wid = ve->wid;
    p = (int32 )*((dict->word + wid)->ciphone + ((dict->word + wid)->pronlen - 1));
    if ((mdef->ciphone + p)->filler) {
      p = (int32 )mdef->sil;
    }
    score = ve->score;
    if (score > *(bs + p)) {
      *(bs + p) = score;
      *(bv + p) = vhid;
      if (maxpscore < score) {
        maxpscore = score;
      }
    }
    __Cont: /* CIL Label */ 
    vhid ++;
  }
  tmp___2 = kb___0->n_lextrans;
  (kb___0->n_lextrans) ++;
  k___0 = tmp___2;
  k___0 = (k___0 % (kb___0->n_lextree * epl)) / epl;
  p = 0;
  while (p < n_ci) {
    if (*(bv + p) >= 0) {
      if (kb___0->wend_beam == 0) {
        lextree_enter(*(kb___0->ugtree + k___0), (s3cipid_t )p, cf, *(bs + p), *(bv + p),
                      th);
      } else
      if (*(bs + p) > - kb___0->wend_beam + maxpscore) {
        lextree_enter(*(kb___0->ugtree + k___0), (s3cipid_t )p, cf, *(bs + p), *(bv + p),
                      th);
      }
    }
    p ++;
  }
  lextree_enter(*(kb___0->fillertree + k___0), (s3cipid_t )-1, cf, *(vh->bestscore + cf),
                *(vh->bestvh + cf), th);
  return;
}
}
void computePhnHeur(mdef_t *md , kb_t *kb___0 , int32 heutype ) 
{ 
  int32 nState ;
  int32 i ;
  int32 j ;
  int32 curPhn ;
  int32 curFrmPhnVar ;

  {
  nState = md->n_emit_state;
  j = 0;
  while (j == (int32 )*(md->cd2cisen + j)) {
    curPhn = (int32 )*(md->sen2cimap + j);
    *(kb___0->phn_heur_list + curPhn) = 0;
    j ++;
  }
  if (heutype == 1) {
    i = kb___0->pl_window_start;
    while (i < kb___0->pl_window_effective) {
      curPhn = 0;
      curFrmPhnVar = (int32 )2147483648U;
      j = 0;
      while (j == (int32 )*(md->cd2cisen + j)) {
        if (curFrmPhnVar < *(*(kb___0->cache_ci_senscr + i) + j)) {
          curFrmPhnVar = *(*(kb___0->cache_ci_senscr + i) + j);
        }
        curPhn = (int32 )*(md->sen2cimap + j);
        if (curPhn != (int32 )*(md->sen2cimap + (j + 1))) {
          *(kb___0->phn_heur_list + curPhn) = NO_UFLOW_ADD___0(*(kb___0->phn_heur_list + curPhn),
                                                               curFrmPhnVar);
          curFrmPhnVar = (int32 )2147483648U;
        }
        j ++;
      }
      i ++;
    }
  } else
  if (heutype == 2) {
    i = kb___0->pl_window_start;
    while (i < kb___0->pl_window_effective) {
      curPhn = 0;
      curFrmPhnVar = (int32 )2147483648U;
      j = 0;
      while (j == (int32 )*(md->cd2cisen + j)) {
        curFrmPhnVar = NO_UFLOW_ADD___0(*(*(kb___0->cache_ci_senscr + i) + j), curFrmPhnVar);
        curPhn = (int32 )*(md->sen2cimap + j);
        if (curPhn != (int32 )*(md->sen2cimap + (j + 1))) {
          curFrmPhnVar /= nState;
          *(kb___0->phn_heur_list + curPhn) = NO_UFLOW_ADD___0(*(kb___0->phn_heur_list + curPhn),
                                                               curFrmPhnVar);
          curFrmPhnVar = (int32 )2147483648U;
        }
        j ++;
      }
      i ++;
    }
  } else
  if (heutype == 3) {
    i = kb___0->pl_window_start;
    while (i < kb___0->pl_window_effective) {
      curPhn = 0;
      curFrmPhnVar = (int32 )2147483648U;
      j = 0;
      while (j == (int32 )*(md->cd2cisen + j)) {
        if (curPhn == 0) {
          *(kb___0->phn_heur_list + curPhn) = NO_UFLOW_ADD___0(*(kb___0->phn_heur_list + curPhn),
                                                               *(*(kb___0->cache_ci_senscr + i) + j));
        } else
        if (curPhn != (int32 )*(md->sen2cimap + (j - 1))) {
          *(kb___0->phn_heur_list + curPhn) = NO_UFLOW_ADD___0(*(kb___0->phn_heur_list + curPhn),
                                                               *(*(kb___0->cache_ci_senscr + i) + j));
        }
        curPhn = (int32 )*(md->sen2cimap + j);
        if (curFrmPhnVar < *(*(kb___0->cache_ci_senscr + i) + j)) {
          curFrmPhnVar = *(*(kb___0->cache_ci_senscr + i) + j);
        }
        if ((int )*(md->sen2cimap + j) != (int )*(md->sen2cimap + (j + 1))) {
          *(kb___0->phn_heur_list + curPhn) = NO_UFLOW_ADD___0(*(kb___0->phn_heur_list + curPhn),
                                                               curFrmPhnVar);
          curFrmPhnVar = (int32 )2147483648U;
        }
        j ++;
      }
      i ++;
    }
  }
  return;
}
}
void utt_decode_block(float ***block_feat , int32 block_nfeatvec , int32 *curfrm ,
                      kb_t *kb___0 , int32 maxwpf___0 , int32 maxhistpf___0 , int32 maxhmmpf___0 ,
                      int32 ptranskip___0 , FILE *hmmdumpfp___0 ) 
{ 
  kbcore_t *kbcore___0 ;
  mdef_t *mdef ;
  dict_t *dict ;
  dict2pid_t *d2p ;
  mgau_model_t *mgau ;
  subvq_t *svq ;
  gs_t *gs ;
  lextree_t *lextree ;
  int32 besthmmscr ;
  int32 bestwordscr ;
  int32 th ;
  int32 pth ;
  int32 wth ;
  int32 i ;
  int32 j ;
  int32 t ;
  int32 n_hmm_eval ;
  int32 frmno___0 ;
  int32 frm_nhmm ;
  int32 hb ;
  int32 pb ;
  int32 wb ;
  int32 f ;
  int32 pheurtype ;
  void const   *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int32 *bin ;
  int32 nbin ;
  int32 bw ;
  void *tmp___6 ;

  {
  tmp = cmd_ln_access((char *)"-pheurtype");
  pheurtype = *((int32 *)tmp);
  kbcore___0 = kb___0->kbcore;
  mdef = kbcore___0->mdef;
  dict = kbcore___0->dict;
  d2p = kbcore___0->dict2pid;
  mgau = kbcore___0->mgau;
  svq = kbcore___0->svq;
  gs = kbcore___0->gs;
  frmno___0 = *curfrm;
  i = 0;
  while (i < kb___0->hmm_hist_bins) {
    *(kb___0->hmm_hist + i) = 0;
    i ++;
  }
  n_hmm_eval = 0;
  ptmr_start(& kb___0->tm_sen);
  if (kb___0->pl_window > block_nfeatvec) {
    kb___0->pl_window_effective = block_nfeatvec;
  } else {
    kb___0->pl_window_effective = kb___0->pl_window;
  }
  kb___0->pl_window_start = 0;
  f = 0;
  while (f < kb___0->pl_window_effective) {
    *(kb___0->cache_best_list + f) = (int32 )2147483648U;
    approx_cont_mgau_ci_eval(mgau, *(*(block_feat + f) + 0), *(kb___0->cache_ci_senscr + f),
                             kb___0);
    i = 0;
    while (i == (int32 )*(mdef->cd2cisen + i)) {
      if (*(*(kb___0->cache_ci_senscr + f) + i) > *(kb___0->cache_best_list + f)) {
        *(kb___0->cache_best_list + f) = *(*(kb___0->cache_ci_senscr + f) + i);
      }
      i ++;
    }
    f ++;
  }
  ptmr_stop(& kb___0->tm_sen);
  t = 0;
  while (t < block_nfeatvec) {
    ptmr_start(& kb___0->tm_sen);
    if (kb___0->sen_active) {
      tmp___1 = __builtin_object_size((void *)kb___0->ssid_active, 0);
      if (tmp___1 != 0xffffffffffffffffUL) {
        tmp___0 = __builtin_object_size((void *)kb___0->ssid_active, 0);
        __builtin___memset_chk((void *)kb___0->ssid_active, 0, (unsigned long )mdef->n_sseq * sizeof(int32 ),
                               tmp___0);
      } else {
        __inline_memset_chk((void *)kb___0->ssid_active, 0, (unsigned long )mdef->n_sseq * sizeof(int32 ));
      }
      tmp___3 = __builtin_object_size((void *)kb___0->comssid_active, 0);
      if (tmp___3 != 0xffffffffffffffffUL) {
        tmp___2 = __builtin_object_size((void *)kb___0->comssid_active, 0);
        __builtin___memset_chk((void *)kb___0->comssid_active, 0, (unsigned long )d2p->n_comsseq * sizeof(int32 ),
                               tmp___2);
      } else {
        __inline_memset_chk((void *)kb___0->comssid_active, 0, (unsigned long )d2p->n_comsseq * sizeof(int32 ));
      }
      i = 0;
      while (i < kb___0->n_lextree << 1) {
        if (i < kb___0->n_lextree) {
          lextree = *(kb___0->ugtree + i);
        } else {
          lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
        }
        lextree_ssid_active(lextree, kb___0->ssid_active, kb___0->comssid_active);
        i ++;
      }
      tmp___5 = __builtin_object_size((void *)kb___0->sen_active, 0);
      if (tmp___5 != 0xffffffffffffffffUL) {
        tmp___4 = __builtin_object_size((void *)kb___0->sen_active, 0);
        __builtin___memset_chk((void *)kb___0->sen_active, 0, (unsigned long )mdef->n_sen * sizeof(int32 ),
                               tmp___4);
      } else {
        __inline_memset_chk((void *)kb___0->sen_active, 0, (unsigned long )mdef->n_sen * sizeof(int32 ));
      }
      mdef_sseq2sen_active(mdef, kb___0->ssid_active, kb___0->sen_active);
      dict2pid_comsseq2sen_active(d2p, mdef, kb___0->comssid_active, kb___0->sen_active);
    }
    approx_cont_mgau_frame_eval(mgau, gs, svq, (kb___0->beam)->subvq, *(*(block_feat + t) + 0),
                                kb___0->sen_active, (kb___0->ascr)->sen, *(kb___0->cache_ci_senscr + kb___0->pl_window_start),
                                kb___0, t);
    kb___0->utt_sen_eval += mgau->frm_sen_eval;
    kb___0->utt_gau_eval += mgau->frm_gau_eval;
    dict2pid_comsenscr(kbcore___0->dict2pid, (kb___0->ascr)->sen, (kb___0->ascr)->comsen);
    ptmr_stop(& kb___0->tm_sen);
    ptmr_start(& kb___0->tm_srch);
    if (pheurtype != 0) {
      computePhnHeur(mdef, kb___0, pheurtype);
    }
    besthmmscr = (int32 )2147483648U;
    bestwordscr = (int32 )2147483648U;
    frm_nhmm = 0;
    i = 0;
    while (i < kb___0->n_lextree << 1) {
      if (i < kb___0->n_lextree) {
        lextree = *(kb___0->ugtree + i);
      } else {
        lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
      }
      if ((unsigned long )hmmdumpfp___0 != (unsigned long )((void *)0)) {
        fprintf(hmmdumpfp___0, "Fr %d Lextree %d #HMM %d\n", frmno___0, i, lextree->n_active);
      }
      lextree_hmm_eval(lextree, kbcore___0, kb___0->ascr, frmno___0, hmmdumpfp___0);
      if (besthmmscr < lextree->best) {
        besthmmscr = lextree->best;
      }
      if (bestwordscr < lextree->wbest) {
        bestwordscr = lextree->wbest;
      }
      n_hmm_eval += lextree->n_active;
      frm_nhmm += lextree->n_active;
      i ++;
    }
    if (besthmmscr > 0) {
      _E__pr_header("utt.c", 1041L, "ERROR");
      _E__pr_warn("***ERROR*** Fr %d, best HMM score > 0 (%d); int32 wraparound?\n",
                  frmno___0, besthmmscr);
    }
    (*(kb___0->hmm_hist + frm_nhmm / kb___0->hmm_hist_binsize)) ++;
    if (frm_nhmm > maxhmmpf___0 + (maxhmmpf___0 >> 1)) {
      nbin = 1000;
      bw = - (kb___0->beam)->hmm / nbin;
      tmp___6 = __ckd_calloc__((size_t )nbin, sizeof(int32 ), "utt.c", 1056);
      bin = (int32 *)tmp___6;
      i = 0;
      while (i < kb___0->n_lextree << 1) {
        if (i < kb___0->n_lextree) {
          lextree = *(kb___0->ugtree + i);
        } else {
          lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
        }
        lextree_hmm_histbin(lextree, besthmmscr, bin, nbin, bw);
        i ++;
      }
      i = 0;
      j = 0;
      while (1) {
        if (i < nbin) {
          if (! (j < maxhmmpf___0)) {
            break;
          }
        } else {
          break;
        }
        i ++;
        j += *(bin + i);
      }
      ckd_free((void *)bin);
      hb = - (i * bw);
      if (hb > (kb___0->beam)->ptrans) {
        pb = hb;
      } else {
        pb = (kb___0->beam)->ptrans;
      }
      if (hb > (kb___0->beam)->word) {
        wb = hb;
      } else {
        wb = (kb___0->beam)->word;
      }
    } else {
      hb = (kb___0->beam)->hmm;
      pb = (kb___0->beam)->ptrans;
      wb = (kb___0->beam)->word;
    }
    kb___0->bestscore = besthmmscr;
    kb___0->bestwordscore = bestwordscr;
    th = kb___0->bestscore + hb;
    pth = kb___0->bestscore + pb;
    wth = kb___0->bestwordscore + wb;
    if (ptranskip___0 == 0) {
      i = 0;
      while (i < kb___0->n_lextree << 1) {
        if (i < kb___0->n_lextree) {
          lextree = *(kb___0->ugtree + i);
        } else {
          lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
        }
        lextree_hmm_propagate(lextree, kbcore___0, kb___0->vithist, frmno___0, th,
                              pth, wth, kb___0->phn_heur_list, kb___0->pl_beam, pheurtype);
        i ++;
      }
    } else {
      i = 0;
      while (i < kb___0->n_lextree << 1) {
        if (i < kb___0->n_lextree) {
          lextree = *(kb___0->ugtree + i);
        } else {
          lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
        }
        if (frmno___0 % ptranskip___0 != 0) {
          lextree_hmm_propagate(lextree, kbcore___0, kb___0->vithist, frmno___0, th,
                                pth, wth, kb___0->phn_heur_list, kb___0->pl_beam,
                                pheurtype);
        } else {
          lextree_hmm_propagate(lextree, kbcore___0, kb___0->vithist, frmno___0, th,
                                wth, wth, kb___0->phn_heur_list, kb___0->pl_beam,
                                pheurtype);
        }
        i ++;
      }
    }
    if (t < block_nfeatvec - kb___0->pl_window_effective) {
      i = 0;
      while (i < kb___0->pl_window_effective - 1) {
        *(kb___0->cache_best_list + i) = *(kb___0->cache_best_list + (i + 1));
        j = 0;
        while (j == (int32 )*(mdef->cd2cisen + j)) {
          *(*(kb___0->cache_ci_senscr + i) + j) = *(*(kb___0->cache_ci_senscr + (i + 1)) + j);
          j ++;
        }
        i ++;
      }
      approx_cont_mgau_ci_eval(mgau, *(*(block_feat + (t + kb___0->pl_window_effective)) + 0),
                               *(kb___0->cache_ci_senscr + (kb___0->pl_window_effective - 1)),
                               kb___0);
      *(kb___0->cache_best_list + (kb___0->pl_window_effective - 1)) = (int32 )2147483648U;
      i = 0;
      while (i == (int32 )*(mdef->cd2cisen + i)) {
        if (*(*(kb___0->cache_ci_senscr + (kb___0->pl_window_effective - 1)) + i) > *(kb___0->cache_best_list + (kb___0->pl_window_effective - 1))) {
          *(kb___0->cache_best_list + (kb___0->pl_window_effective - 1)) = *(*(kb___0->cache_ci_senscr + (kb___0->pl_window_effective - 1)) + i);
        }
        i ++;
      }
    } else {
      (kb___0->pl_window_start) ++;
    }
    vithist_prune(kb___0->vithist, dict, frmno___0, maxwpf___0, maxhistpf___0, wb);
    utt_word_trans(kb___0, frmno___0);
    vithist_frame_windup(kb___0->vithist, frmno___0, (FILE *)((void *)0), kbcore___0);
    kb_lextree_active_swap(kb___0);
    ptmr_stop(& kb___0->tm_srch);
    t ++;
    frmno___0 ++;
  }
  kb___0->utt_hmm_eval += n_hmm_eval;
  kb___0->nfr += block_nfeatvec;
  *curfrm = frmno___0;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-l_nfsf9g.i","-O3")
void vector_floor(float32 *vec , int32 len , float64 flr ) ;
void vector_print(FILE *fp , vector_t v , int32 dim ) ;
int32 vector_maxcomp_int32(int32 *val , int32 len ) ;
int32 vector_mincomp_int32(int32 *val , int32 len ) ;
int32 vector_maxcomp_float32(float32 *val , int32 len ) ;
int32 vector_mincomp_float32(float32 *val , int32 len ) ;
void vector_accum(float32 *dst , float32 *src , int32 len ) ;
int32 vector_cmp(float32 *v1 , float32 *v2 , int32 len ) ;
int32 vector_mean(float32 *mean , float32 **data , int32 n_vec , int32 n_dim ) ;
float64 vector_dist_eucl(float32 *v1 , float32 *v2 , int32 len ) ;
float64 vector_maha_precomp(float32 *var , int32 len ) ;
float64 vector_dist_maha(float32 *vec , float32 *mean , float32 *varinv , float64 loginvdet ,
                         int32 len ) ;
float64 vector_vqgen(float32 **data , int32 rows , int32 cols , int32 vqrows , float64 epsilon ,
                     int32 maxiter , float32 **mean , int32 *map ) ;
int32 vector_vqlabel(float32 *vec , float32 **mean , int32 rows , int32 cols , float64 *sqerr ) ;
float64 vector_pdf_entropy(float32 *p , int32 len ) ;
float64 vector_pdf_cross_entropy(float32 *p1 , float32 *p2 , int32 len ) ;
void vector_gautbl_free(vector_gautbl_t *gautbl ) ;
float64 vector_sum_norm(float32 *vec , int32 len ) 
{ 
  float64 sum___0 ;
  float64 f ;
  int32 i ;

  {
  sum___0 = 0.0;
  i = 0;
  while (i < len) {
    sum___0 += (float64 )*(vec + i);
    i ++;
  }
  if (sum___0 != 0.0) {
    f = 1.0 / sum___0;
    i = 0;
    while (i < len) {
      *(vec + i) = (float32 )((float64 )*(vec + i) * f);
      i ++;
    }
  }
  return (sum___0);
}
}
void vector_floor(float32 *vec , int32 len , float64 flr ) 
{ 
  int32 i ;

  {
  i = 0;
  while (i < len) {
    if ((float64 )*(vec + i) < flr) {
      *(vec + i) = (float32 )flr;
    }
    i ++;
  }
  return;
}
}
void vector_nz_floor(float32 *vec , int32 len , float64 flr ) 
{ 
  int32 i ;

  {
  i = 0;
  while (i < len) {
    if ((double )*(vec + i) != 0.0) {
      if ((float64 )*(vec + i) < flr) {
        *(vec + i) = (float32 )flr;
      }
    }
    i ++;
  }
  return;
}
}
void vector_print(FILE *fp , vector_t v , int32 dim ) 
{ 
  int32 i ;

  {
  i = 0;
  while (i < dim) {
    fprintf(fp, " %11.4e", (double )*(v + i));
    i ++;
  }
  fprintf(fp, "\n");
  fflush(fp);
  return;
}
}
int32 vector_is_zero(float32 *vec , int32 len ) 
{ 
  int32 i ;

  {
  i = 0;
  while (1) {
    if (i < len) {
      if (! ((double )*(vec + i) == 0.0)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  return (i == len);
}
}
int32 vector_maxcomp_int32(int32 *val , int32 len ) 
{ 
  int32 i ;
  int32 bi ;

  {
  bi = 0;
  i = 1;
  while (i < len) {
    if (*(val + i) > *(val + bi)) {
      bi = i;
    }
    i ++;
  }
  return (bi);
}
}
int32 vector_mincomp_int32(int32 *val , int32 len ) 
{ 
  int32 i ;
  int32 bi ;

  {
  bi = 0;
  i = 1;
  while (i < len) {
    if (*(val + i) < *(val + bi)) {
      bi = i;
    }
    i ++;
  }
  return (bi);
}
}
int32 vector_maxcomp_float32(float32 *val , int32 len ) 
{ 
  int32 i ;
  int32 bi ;

  {
  bi = 0;
  i = 1;
  while (i < len) {
    if (*(val + i) > *(val + bi)) {
      bi = i;
    }
    i ++;
  }
  return (bi);
}
}
int32 vector_mincomp_float32(float32 *val , int32 len ) 
{ 
  int32 i ;
  int32 bi ;

  {
  bi = 0;
  i = 1;
  while (i < len) {
    if (*(val + i) < *(val + bi)) {
      bi = i;
    }
    i ++;
  }
  return (bi);
}
}
void vector_accum(float32 *dst , float32 *src , int32 len ) 
{ 
  int32 i ;

  {
  i = 0;
  while (i < len) {
    *(dst + i) += *(src + i);
    i ++;
  }
  return;
}
}
int32 vector_cmp(float32 *v1 , float32 *v2 , int32 len ) 
{ 
  int32 i ;

  {
  i = 0;
  while (i < len) {
    if (*(v1 + i) < *(v2 + i)) {
      return (-1);
    }
    if (*(v1 + i) > *(v2 + i)) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
int32 vector_mean(float32 *mean , float32 **data , int32 n_vec , int32 n_dim ) 
{ 
  int32 i ;
  int32 j ;
  float64 f ;

  {
  i = 0;
  while (i < n_dim) {
    *(mean + i) = (float32 )0.0;
    i ++;
  }
  i = 0;
  while (i < n_vec) {
    j = 0;
    while (j < n_dim) {
      *(mean + j) += *(*(data + i) + j);
      j ++;
    }
    i ++;
  }
  f = 1.0 / (float64 )n_vec;
  i = 0;
  while (i < n_dim) {
    *(mean + i) *= (float32 )f;
    i ++;
  }
  return (0);
}
}
float64 vector_dist_eucl(float32 *v1 , float32 *v2 , int32 len ) 
{ 
  float64 d ;
  int32 i ;

  {
  d = 0.0;
  i = 0;
  while (i < len) {
    d += (float64 )((*(v1 + i) - *(v2 + i)) * (*(v1 + i) - *(v2 + i)));
    i ++;
  }
  return (d);
}
}
float64 vector_maha_precomp(float32 *var , int32 len ) 
{ 
  float64 det ;
  int32 i ;
  double tmp ;
  double tmp___0 ;

  {
  det = 0.0;
  i = 0;
  while (i < len) {
    tmp = log((double )*(var + i));
    det -= tmp;
    *(var + i) = (float32 )(1.0 / ((double )*(var + i) * 2.0));
    i ++;
  }
  tmp___0 = log(2.0 * 3.14159265358979323846264338327950288);
  det -= tmp___0 * (double )len;
  return (det * 0.5);
}
}
float64 vector_dist_maha(float32 *vec , float32 *mean , float32 *varinv , float64 loginvdet ,
                         int32 len ) 
{ 
  float64 dist ;
  float64 diff ;
  int32 i ;

  {
  dist = loginvdet;
  i = 0;
  while (i < len) {
    diff = (float64 )(*(vec + i) - *(mean + i));
    dist -= (diff * diff) * (float64 )*(varinv + i);
    i ++;
  }
  return (dist);
}
}
int32 vector_vqlabel(float32 *vec , float32 **mean , int32 rows , int32 cols , float64 *sqerr ) 
{ 
  int32 i ;
  int32 besti ;
  float64 d ;
  float64 bestd ;

  {
  bestd = vector_dist_eucl(*(mean + 0), vec, cols);
  besti = 0;
  i = 1;
  while (i < rows) {
    d = vector_dist_eucl(*(mean + i), vec, cols);
    if (bestd > d) {
      bestd = d;
      besti = i;
    }
    i ++;
  }
  if (sqerr) {
    *sqerr = bestd;
  }
  return (besti);
}
}
float64 vector_vqgen(float32 **data , int32 rows , int32 cols , int32 vqrows , float64 epsilon ,
                     int32 maxiter , float32 **mean , int32 *map ) 
{ 
  int32 i ;
  int32 j ;
  int32 r ;
  int32 it ;
  int seed ;
  float64 sqerr ;
  float64 prev_sqerr ;
  float64 t ;
  bitvec_t sel ;
  int32 *count ;
  float32 *gmean ;
  ptmr_t tm ;
  void *tmp ;
  double tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;

  {
  seed = 1;
  prev_sqerr = (float64 )0;
  tmp = __ckd_calloc__((size_t )((rows + 31) >> 5), sizeof(uint32 ), "vector.c", 326);
  sel = (bitvec_t )tmp;
  ptmr_init(& tm);
  ptmr_start(& tm);
  spec_srand(seed);
  i = 0;
  while (i < vqrows) {
    tmp___0 = spec_rand();
    r = (int )(tmp___0 * (double )2147483647) % rows;
    while (*(sel + (r >> 5)) & (unsigned int )(1 << (r & 31))) {
      r ++;
      if (r >= rows) {
        r = 0;
      }
    }
    *(sel + (r >> 5)) |= (unsigned int )(1 << (r & 31));
    tmp___2 = __builtin_object_size((void *)*(mean + i), 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)*(mean + i), 0);
      __builtin___memcpy_chk((void *)*(mean + i), (void const   *)((void *)*(data + r)),
                             (unsigned long )cols * sizeof(float32 ), tmp___1);
    } else {
      __inline_memcpy_chk((void *)*(mean + i), (void const   *)((void *)*(data + r)),
                          (unsigned long )cols * sizeof(float32 ));
    }
    i ++;
  }
  ckd_free((void *)((char *)sel));
  tmp___3 = __ckd_calloc__((size_t )vqrows, sizeof(int32 ), "vector.c", 367);
  count = (int32 *)tmp___3;
  tmp___4 = __ckd_calloc__((size_t )cols, sizeof(float32 ), "vector.c", 370);
  gmean = (float32 *)tmp___4;
  vector_mean(gmean, mean, vqrows, cols);
  it = 0;
  while (1) {
    sqerr = 0.0;
    i = 0;
    while (i < rows) {
      *(map + i) = vector_vqlabel(*(data + i), mean, vqrows, cols, & t);
      sqerr += t;
      i ++;
    }
    ptmr_stop(& tm);
    if (it == 0) {
      _E__pr_info_header("vector.c", 383L, "INFO");
      _E__pr_info("Iter %4d: %.1fs CPU; sqerr= %e\n", it, tm.t_cpu, sqerr);
    } else {
      _E__pr_info_header("vector.c", 385L, "INFO");
      _E__pr_info("Iter %4d: %.1fs CPU; sqerr= %e; delta= %e\n", it, tm.t_cpu, sqerr,
                  (prev_sqerr - sqerr) / prev_sqerr);
    }
    if (sqerr == 0.0) {
      break;
    } else
    if (it >= maxiter - 1) {
      break;
    } else
    if (it > 0) {
      if ((prev_sqerr - sqerr) / prev_sqerr < epsilon) {
        break;
      }
    }
    prev_sqerr = sqerr;
    ptmr_start(& tm);
    i = 0;
    while (i < vqrows) {
      j = 0;
      while (j < cols) {
        *(*(mean + i) + j) = (float32 )0.0;
        j ++;
      }
      *(count + i) = 0;
      i ++;
    }
    i = 0;
    while (i < rows) {
      vector_accum(*(mean + *(map + i)), *(data + i), cols);
      (*(count + *(map + i))) ++;
      i ++;
    }
    i = 0;
    while (i < vqrows) {
      if (*(count + i) > 1) {
        t = 1.0 / (float64 )*(count + i);
        j = 0;
        while (j < cols) {
          *(*(mean + i) + j) = (float32 )((float64 )*(*(mean + i) + j) * t);
          j ++;
        }
      } else
      if (*(count + i) == 0) {
        _E__pr_header("vector.c", 413L, "ERROR");
        _E__pr_warn("Iter %d: mean[%d] unmapped\n", it, i);
        tmp___6 = __builtin_object_size((void *)*(mean + i), 0);
        if (tmp___6 != 0xffffffffffffffffUL) {
          tmp___5 = __builtin_object_size((void *)*(mean + i), 0);
          __builtin___memcpy_chk((void *)*(mean + i), (void const   *)gmean, (unsigned long )cols * sizeof(float32 ),
                                 tmp___5);
        } else {
          __inline_memcpy_chk((void *)*(mean + i), (void const   *)gmean, (unsigned long )cols * sizeof(float32 ));
        }
      }
      i ++;
    }
    it ++;
  }
  ckd_free((void *)count);
  ckd_free((void *)gmean);
  return (sqerr);
}
}
float64 vector_pdf_entropy(float32 *p , int32 len ) 
{ 
  float64 sum___0 ;
  int32 i ;
  double tmp ;
  double tmp___0 ;

  {
  sum___0 = 0.0;
  i = 0;
  while (i < len) {
    if ((double )*(p + i) > 0.0) {
      tmp = log((double )*(p + i));
      sum___0 -= (double )*(p + i) * tmp;
    }
    i ++;
  }
  tmp___0 = log(2.0);
  sum___0 /= tmp___0;
  return (sum___0);
}
}
float64 vector_pdf_cross_entropy(float32 *p1 , float32 *p2 , int32 len ) 
{ 
  float64 sum___0 ;
  int32 i ;
  double tmp ;
  double tmp___0 ;

  {
  sum___0 = 0.0;
  i = 0;
  while (i < len) {
    if ((double )*(p2 + i) > 0.0) {
      tmp = log((double )*(p2 + i));
      sum___0 -= (double )*(p1 + i) * tmp;
    }
    i ++;
  }
  tmp___0 = log(2.0);
  sum___0 /= tmp___0;
  return (sum___0);
}
}
void vector_gautbl_alloc(vector_gautbl_t *gautbl , int32 n_gau , int32 veclen ) 
{ 
  void **tmp ;
  void **tmp___0 ;
  void *tmp___1 ;

  {
  gautbl->n_gau = n_gau;
  gautbl->veclen = veclen;
  tmp = __ckd_calloc_2d__(n_gau, veclen, (int32 )sizeof(float32 ), "vector.c", 462);
  gautbl->mean = (float32 **)tmp;
  tmp___0 = __ckd_calloc_2d__(n_gau, veclen, (int32 )sizeof(float32 ), "vector.c",
                              463);
  gautbl->var = (float32 **)tmp___0;
  tmp___1 = __ckd_calloc__((size_t )n_gau, sizeof(float32 ), "vector.c", 464);
  gautbl->lrd = (float32 *)tmp___1;
  gautbl->distfloor = logs3_to_log((int32 )3355443200U);
  return;
}
}
void vector_gautbl_free(vector_gautbl_t *gautbl ) 
{ 


  {
  ckd_free_2d((void **)gautbl->mean);
  ckd_free_2d((void **)gautbl->var);
  ckd_free((void *)gautbl->lrd);
  return;
}
}
void vector_gautbl_var_floor(vector_gautbl_t *gautbl , float64 floor___0 ) 
{ 
  int32 g ;

  {
  g = 0;
  while (g < gautbl->n_gau) {
    vector_floor(*(gautbl->var + g), gautbl->veclen, floor___0);
    g ++;
  }
  return;
}
}
void vector_gautbl_maha_precomp(vector_gautbl_t *gautbl ) 
{ 
  int32 g ;
  float64 tmp ;

  {
  g = 0;
  while (g < gautbl->n_gau) {
    tmp = vector_maha_precomp(*(gautbl->var + g), gautbl->veclen);
    *(gautbl->lrd + g) = (float32 )tmp;
    g ++;
  }
  return;
}
}
void vector_gautbl_eval_logs3(vector_gautbl_t *gautbl , int32 offset , int32 count ,
                              float32 *x___0 , int32 *score ) 
{ 
  int32 i ;
  int32 r ;
  float64 f ;
  int32 end ;
  int32 veclen ;
  float32 *m1 ;
  float32 *m2 ;
  float32 *v1 ;
  float32 *v2 ;
  float64 dval1 ;
  float64 dval2 ;
  float64 diff1 ;
  float64 diff2 ;

  {
  f = log_to_logs3_factor();
  end = offset + count;
  veclen = gautbl->veclen;
  r = offset;
  while (r < end - 1) {
    m1 = *(gautbl->mean + r);
    m2 = *(gautbl->mean + (r + 1));
    v1 = *(gautbl->var + r);
    v2 = *(gautbl->var + (r + 1));
    dval1 = (float64 )*(gautbl->lrd + r);
    dval2 = (float64 )*(gautbl->lrd + (r + 1));
    i = 0;
    while (i < veclen) {
      diff1 = (float64 )(*(x___0 + i) - *(m1 + i));
      dval1 -= (diff1 * diff1) * (float64 )*(v1 + i);
      diff2 = (float64 )(*(x___0 + i) - *(m2 + i));
      dval2 -= (diff2 * diff2) * (float64 )*(v2 + i);
      i ++;
    }
    if (dval1 < gautbl->distfloor) {
      dval1 = gautbl->distfloor;
    }
    if (dval2 < gautbl->distfloor) {
      dval2 = gautbl->distfloor;
    }
    *(score + r) = (int32 )(f * dval1);
    *(score + (r + 1)) = (int32 )(f * dval2);
    r += 2;
  }
  if (r < end) {
    m1 = *(gautbl->mean + r);
    v1 = *(gautbl->var + r);
    dval1 = (float64 )*(gautbl->lrd + r);
    i = 0;
    while (i < veclen) {
      diff1 = (float64 )(*(x___0 + i) - *(m1 + i));
      dval1 -= (diff1 * diff1) * (float64 )*(v1 + i);
      i ++;
    }
    if (dval1 < gautbl->distfloor) {
      dval1 = gautbl->distfloor;
    }
    *(score + r) = (int32 )(f * dval1);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-5__QcHE3.i","-O3")
vithist_t *vithist_init(kbcore_t *kbc , int32 wbeam , int32 bghist ) 
{ 
  vithist_t *vh ;
  lm_t *lm ;
  lmset_t *lmset ;
  dict_t *dict ;
  wordprob_t *wp ;
  int i ;
  int max ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  max = -1;
  _E__pr_info_header("vithist.c", 77L, "INFO");
  _E__pr_info("Initializing Viterbi-history module\n");
  tmp = __ckd_calloc__((size_t )1, sizeof(vithist_t ), "vithist.c", 79);
  vh = (vithist_t *)tmp;
  tmp___0 = __ckd_calloc__((size_t )256, sizeof(vithist_entry_t *), "vithist.c", 81);
  vh->entry = (vithist_entry_t **)tmp___0;
  vh->n_entry = 0;
  tmp___1 = __ckd_calloc__((size_t )15001, sizeof(int32 ), "vithist.c", 84);
  vh->frame_start = (int32 *)tmp___1;
  tmp___2 = __ckd_calloc__((size_t )15001, sizeof(int32 ), "vithist.c", 86);
  vh->bestscore = (int32 *)tmp___2;
  tmp___3 = __ckd_calloc__((size_t )15001, sizeof(int32 ), "vithist.c", 87);
  vh->bestvh = (int32 *)tmp___3;
  vh->wbeam = wbeam;
  vh->bghist = bghist;
  lm = kbc->lm;
  lmset = kbc->lmset;
  dict = kbc->dict;
  tmp___4 = __ckd_calloc__((size_t )dict->n_word, sizeof(wordprob_t ), "vithist.c",
                           96);
  wp = (wordprob_t *)tmp___4;
  if (lmset) {
    i = 0;
    while (i < kbc->n_lm) {
      if (((lmset + i)->lm)->n_ug > max) {
        max = ((lmset + i)->lm)->n_ug;
      }
      i ++;
    }
    _E__pr_info_header("vithist.c", 105L, "INFO");
    _E__pr_info("Allocation for viterbi history, finall size %d\n", max);
    tmp___5 = __ckd_calloc__((size_t )max, sizeof(vh_lms2vh_t *), "vithist.c", 106);
    vh->lms2vh_root = (vh_lms2vh_t **)tmp___5;
  } else
  if (lm) {
    tmp___6 = __ckd_calloc__((size_t )lm->n_ug, sizeof(vh_lms2vh_t *), "vithist.c",
                             109);
    vh->lms2vh_root = (vh_lms2vh_t **)tmp___6;
  }
  ckd_free((void *)wp);
  vh->lwidlist = (glist_t )((void *)0);
  return (vh);
}
}
static vithist_entry_t *vithist_entry_alloc(vithist_t *vh ) 
{ 
  int32 b ;
  int32 l ;
  vithist_entry_t *ve ;
  void *tmp ;

  {
  b = vh->n_entry >> 14;
  l = vh->n_entry & 16383;
  if (l == 0) {
    if (b >= 256) {
      _E__pr_header("vithist.c", 132L, "FATAL_ERROR");
      _E__die_error("Viterbi history array exhausted; increase VITHIST_MAXBLKS\n");
    }
    tmp = __ckd_calloc__((size_t )16384, sizeof(vithist_entry_t ), "vithist.c", 136);
    ve = (vithist_entry_t *)tmp;
    *(vh->entry + b) = ve;
  } else {
    ve = *(vh->entry + b) + l;
  }
  (vh->n_entry) ++;
  return (ve);
}
}
int32 vithist_utt_begin(vithist_t *vh , kbcore_t *kbc ) 
{ 
  vithist_entry_t *ve ;
  lm_t *lm ;
  dict_t *dict ;

  {
  lm = kbc->lm;
  dict = kbc->dict;
  ve = vithist_entry_alloc(vh);
  ve->wid = dict->startwid;
  ve->sf = (s3frmid_t )-1;
  ve->ef = (s3frmid_t )-1;
  ve->ascr = 0;
  ve->lscr = 0;
  ve->score = 0;
  ve->pred = -1;
  ve->type = 0;
  ve->valid = 1;
  ve->lmstate.lm3g.lwid[0] = lm->startlwid;
  ve->lmstate.lm3g.lwid[1] = (s3lmwid_t )65535;
  vh->n_frm = 0;
  *(vh->frame_start + 0) = 1;
  *(vh->bestscore + 0) = (int32 )2147483648U;
  *(vh->bestvh + 0) = -1;
  return (0);
}
}
static int32 vh_lmstate_find(vithist_t *vh , vh_lmstate_t *lms ) 
{ 
  vh_lms2vh_t *lms2vh ;
  s3lmwid_t lwid ;
  gnode_t *gn ;

  {
  lwid = lms->lm3g.lwid[0];
  lms2vh = *(vh->lms2vh_root + lwid);
  if ((unsigned long )lms2vh == (unsigned long )((void *)0)) {
    return (-1);
  }
  lwid = lms->lm3g.lwid[1];
  gn = lms2vh->children;
  while (gn) {
    lms2vh = (vh_lms2vh_t *)gn->data.ptr;
    if (lms2vh->state == (int32 )lwid) {
      return (lms2vh->vhid);
    }
    gn = gn->next;
  }
  return (-1);
}
}
static void vithist_lmstate_enter(vithist_t *vh , int32 vhid , vithist_entry_t *ve ) 
{ 
  vh_lms2vh_t *lms2vh ;
  vh_lms2vh_t *child ;
  s3lmwid_t lwid ;
  void *tmp ;
  void *tmp___0 ;

  {
  lwid = ve->lmstate.lm3g.lwid[0];
  lms2vh = *(vh->lms2vh_root + lwid);
  if ((unsigned long )lms2vh == (unsigned long )((void *)0)) {
    tmp = __ckd_calloc__((size_t )1, sizeof(vh_lms2vh_t ), "vithist.c", 218);
    lms2vh = (vh_lms2vh_t *)tmp;
    *(vh->lms2vh_root + lwid) = lms2vh;
    lms2vh->state = (int32 )lwid;
    lms2vh->children = (glist_t )((void *)0);
    vh->lwidlist = glist_add_int32(vh->lwidlist, (int32 )lwid);
  }
  tmp___0 = __ckd_calloc__((size_t )1, sizeof(vh_lms2vh_t ), "vithist.c", 229);
  child = (vh_lms2vh_t *)tmp___0;
  child->state = (int32 )ve->lmstate.lm3g.lwid[1];
  child->children = (glist_t )((void *)0);
  child->vhid = vhid;
  child->ve = ve;
  lms2vh->children = glist_add_ptr(lms2vh->children, (void *)child);
  return;
}
}
vithist_entry_t *vithist_id2entry(vithist_t *vh , int32 id ) 
{ 
  vithist_entry_t *ve ;

  {
  ve = *(vh->entry + (id >> 14)) + (id & 16383);
  return (ve);
}
}
static void vithist_enter(vithist_t *vh , kbcore_t *kbc , vithist_entry_t *tve ) 
{ 
  vithist_entry_t *ve ;
  int32 vhid ;

  {
  vhid = vh_lmstate_find(vh, & tve->lmstate);
  if (vhid < 0) {
    vhid = vh->n_entry;
    ve = vithist_entry_alloc(vh);
    *ve = *tve;
    vithist_lmstate_enter(vh, vhid, ve);
  } else {
    ve = *(vh->entry + (vhid >> 14)) + (vhid & 16383);
    if (ve->score < tve->score) {
      *ve = *tve;
    }
  }
  if (*(vh->bestscore + vh->n_frm) < tve->score) {
    *(vh->bestscore + vh->n_frm) = tve->score;
    *(vh->bestvh + vh->n_frm) = vhid;
  }
  return;
}
}
void vithist_rescore(vithist_t *vh , kbcore_t *kbc , s3wid_t wid , int32 ef , int32 score ,
                     int32 pred , int32 type ) 
{ 
  vithist_entry_t *pve ;
  vithist_entry_t tve ;
  s3lmwid_t lwid ;
  int32 se ;
  int32 fe___0 ;
  int32 i ;
  int32 tmp ;

  {
  if (pred == -1) {
    _E__pr_header("vithist.c", 286L, "FATAL_ERROR");
    _E__die_error("Hmm->out.history equals to -1 with score %d, some active phone was not computed?\n",
                  score);
    exit(-1);
  }
  pve = *(vh->entry + (pred >> 14)) + (pred & 16383);
  tve.wid = wid;
  tve.sf = (s3frmid_t )((int )pve->ef + 1);
  tve.ef = (s3frmid_t )ef;
  tve.type = type;
  tve.valid = 1;
  tve.ascr = score - pve->score;
  if (pred == 0) {
    se = 0;
    fe___0 = 1;
  } else {
    se = *(vh->frame_start + pve->ef);
    fe___0 = *(vh->frame_start + ((int )pve->ef + 1));
  }
  tmp = dict_filler_word(kbc->dict, wid);
  if (tmp) {
    tve.lscr = fillpen(kbc->fillpen, wid);
    tve.score = score + tve.lscr;
    tve.pred = pred;
    tve.lmstate.lm3g = pve->lmstate.lm3g;
    vithist_enter(vh, kbc, & tve);
  } else {
    if (kbc->lmset) {
      lwid = *((kbc->lm)->dict2lmwid + wid);
    } else {
      lwid = *(kbc->dict2lmwid + wid);
    }
    tve.lmstate.lm3g.lwid[0] = lwid;
    i = se;
    while (i < fe___0) {
      pve = *(vh->entry + (i >> 14)) + (i & 16383);
      if (pve->valid) {
        tve.lscr = lm_tg_score(kbc->lm, pve->lmstate.lm3g.lwid[1], pve->lmstate.lm3g.lwid[0],
                               lwid, wid);
        tve.score = (pve->score + tve.ascr) + tve.lscr;
        if (tve.score - vh->wbeam >= *(vh->bestscore + vh->n_frm)) {
          tve.pred = i;
          tve.lmstate.lm3g.lwid[1] = pve->lmstate.lm3g.lwid[0];
          vithist_enter(vh, kbc, & tve);
        }
      }
      i ++;
    }
  }
  return;
}
}
static void vithist_frame_gc(vithist_t *vh , int32 frm ) 
{ 
  vithist_entry_t *ve ;
  vithist_entry_t *tve ;
  int32 se ;
  int32 fe___0 ;
  int32 te ;
  int32 bs___0 ;
  int32 bv___0 ;
  int32 i ;
  int32 j ;

  {
  se = *(vh->frame_start + frm);
  fe___0 = vh->n_entry - 1;
  te = se;
  bs___0 = (int32 )2147483648U;
  bv___0 = -1;
  i = se;
  while (i <= fe___0) {
    ve = *(vh->entry + (i >> 14)) + (i & 16383);
    if (ve->valid) {
      if (i != te) {
        tve = *(vh->entry + (te >> 14)) + (te & 16383);
        *tve = *ve;
      }
      if (ve->score > bs___0) {
        bs___0 = ve->score;
        bv___0 = te;
      }
      te ++;
    }
    i ++;
  }
  *(vh->bestvh + frm) = bv___0;
  i = (vh->n_entry - 1) >> 14;
  j = (te - 1) >> 14;
  while (i > j) {
    ckd_free((void *)*(vh->entry + i));
    *(vh->entry + i) = (vithist_entry_t *)((void *)0);
    i --;
  }
  vh->n_entry = te;
  return;
}
}
void vithist_prune(vithist_t *vh , dict_t *dict , int32 frm , int32 maxwpf___0 , int32 maxhist ,
                   int32 beam ) 
{ 
  int32 se ;
  int32 fe___0 ;
  int32 filler_done ;
  int32 th ;
  vithist_entry_t *ve ;
  heap_t h ;
  s3wid_t *wid ;
  int32 i ;
  void *tmp ;
  int32 tmp___0 ;
  int32 tmp___1 ;

  {
  se = *(vh->frame_start + frm);
  fe___0 = vh->n_entry - 1;
  th = *(vh->bestscore + frm) + beam;
  h = heap_new();
  tmp = __ckd_calloc__((size_t )(maxwpf___0 + 1), sizeof(s3wid_t ), "vithist.c", 410);
  wid = (s3wid_t *)tmp;
  *(wid + 0) = -1;
  i = se;
  while (i <= fe___0) {
    ve = *(vh->entry + (i >> 14)) + (i & 16383);
    heap_insert(h, (void *)ve, - ve->score);
    ve->valid = 0;
    i ++;
  }
  filler_done = 0;
  while (1) {
    tmp___1 = heap_pop(h, (void **)(& ve), & i);
    if (tmp___1 > 0) {
      if (ve->score >= th) {
        if (! (maxhist > 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    tmp___0 = dict_filler_word(dict, ve->wid);
    if (tmp___0) {
      if (filler_done) {
        continue;
      }
      filler_done = 1;
    }
    i = 0;
    while (1) {
      if (*(wid + i) >= 0) {
        if (! (*(wid + i) != ve->wid)) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
    if (*(wid + i) < 0) {
      if (maxwpf___0 > 0) {
        *(wid + i) = ve->wid;
        *(wid + (i + 1)) = -1;
        maxwpf___0 --;
        maxhist --;
        ve->valid = 1;
      }
    } else
    if (! vh->bghist) {
      maxhist --;
      ve->valid = 1;
    }
  }
  ckd_free((void *)wid);
  heap_destroy(h);
  vithist_frame_gc(vh, frm);
  return;
}
}
static void vithist_lmstate_reset(vithist_t *vh ) 
{ 
  gnode_t *lgn ;
  gnode_t *gn ;
  int32 i ;
  vh_lms2vh_t *lms2vh ;
  vh_lms2vh_t *child ;

  {
  lgn = vh->lwidlist;
  while (lgn) {
    i = lgn->data.int32;
    lms2vh = *(vh->lms2vh_root + i);
    gn = lms2vh->children;
    while (gn) {
      child = (vh_lms2vh_t *)gn->data.ptr;
      ckd_free((void *)child);
      gn = gn->next;
    }
    glist_free(lms2vh->children);
    ckd_free((void *)lms2vh);
    *(vh->lms2vh_root + i) = (vh_lms2vh_t *)((void *)0);
    lgn = lgn->next;
  }
  glist_free(vh->lwidlist);
  vh->lwidlist = (glist_t )((void *)0);
  return;
}
}
void vithist_frame_windup(vithist_t *vh , int32 frm , FILE *fp , kbcore_t *kbc ) 
{ 


  {
  (vh->n_frm) ++;
  *(vh->frame_start + vh->n_frm) = vh->n_entry;
  if (fp) {
    vithist_dump(vh, frm, kbc, fp);
  }
  vithist_lmstate_reset(vh);
  *(vh->bestscore + vh->n_frm) = (int32 )2147483648U;
  *(vh->bestvh + vh->n_frm) = -1;
  return;
}
}
int32 vithist_utt_end(vithist_t *vh , kbcore_t *kbc ) 
{ 
  int32 f ;
  int32 i ;
  int32 b ;
  int32 l ;
  int32 sv ;
  int32 nsv ;
  int32 scr ;
  int32 bestscore ;
  int32 bestvh ;
  int32 vhid ;
  vithist_entry_t *ve ;
  vithist_entry_t *bestve ;
  s3lmwid_t endwid ;
  lm_t *lm ;
  dict_t *dict ;
  int32 tmp ;
  int32 tmp___0 ;

  {
  bestve = (vithist_entry_t *)0;
  f = vh->n_frm - 1;
  while (f >= 0) {
    sv = *(vh->frame_start + f);
    nsv = *(vh->frame_start + (f + 1));
    if (sv < nsv) {
      break;
    }
    f --;
  }
  if (f < 0) {
    return (-1);
  }
  lm = kbc->lm;
  endwid = lm->finishlwid;
  dict = kbc->dict;
  bestscore = (int32 )2147483648U;
  bestvh = -1;
  i = sv;
  while (i < nsv) {
    b = i >> 14;
    l = i & 16383;
    ve = *(vh->entry + b) + l;
    scr = ve->score;
    tmp = lm_tg_score(lm, ve->lmstate.lm3g.lwid[1], ve->lmstate.lm3g.lwid[0], endwid,
                      dict->finishwid);
    scr += tmp;
    if (bestscore < scr) {
      bestscore = scr;
      bestvh = i;
      bestve = ve;
    }
    i ++;
  }
  if (f != vh->n_frm - 1) {
    (vh->n_frm) --;
    vithist_rescore(vh, kbc, dict->silwid, vh->n_frm, bestve->score, bestvh, -1);
    (vh->n_frm) ++;
    *(vh->frame_start + vh->n_frm) = vh->n_entry;
    tmp___0 = vithist_utt_end(vh, kbc);
    return (tmp___0);
  }
  vhid = vh->n_entry;
  ve = vithist_entry_alloc(vh);
  ve->wid = dict->finishwid;
  if ((int )bestve->ef == -1) {
    ve->sf = (s3frmid_t )0;
  } else {
    ve->sf = (s3frmid_t )((int )bestve->ef + 1);
  }
  ve->ef = (s3frmid_t )vh->n_frm;
  ve->ascr = 0;
  ve->lscr = bestscore - bestve->score;
  ve->score = bestscore;
  ve->pred = bestvh;
  ve->type = 0;
  ve->valid = 1;
  ve->lmstate.lm3g.lwid[0] = endwid;
  ve->lmstate.lm3g.lwid[1] = ve->lmstate.lm3g.lwid[0];
  return (vhid);
}
}
int32 vithist_partialutt_end(vithist_t *vh , kbcore_t *kbc ) 
{ 
  int32 f ;
  int32 i ;
  int32 b ;
  int32 l ;
  int32 sv ;
  int32 nsv ;
  int32 scr ;
  int32 bestscore ;
  int32 bestvh ;
  vithist_entry_t *ve ;
  vithist_entry_t *bestve ;
  s3lmwid_t endwid ;
  lm_t *lm ;
  dict_t *dict ;
  int32 tmp ;

  {
  f = vh->n_frm - 1;
  while (f >= 0) {
    sv = *(vh->frame_start + f);
    nsv = *(vh->frame_start + (f + 1));
    if (sv < nsv) {
      break;
    }
    f --;
  }
  if (f < 0) {
    return (-1);
  }
  if (f != vh->n_frm - 1) {
    return (-1);
  }
  lm = kbc->lm;
  dict = kbc->dict;
  endwid = lm->finishlwid;
  bestscore = (int32 )2147483648U;
  bestvh = -1;
  i = sv;
  while (i < nsv) {
    b = i >> 14;
    l = i & 16383;
    ve = *(vh->entry + b) + l;
    scr = ve->score;
    tmp = lm_tg_score(lm, ve->lmstate.lm3g.lwid[1], ve->lmstate.lm3g.lwid[0], endwid,
                      dict->finishwid);
    scr += tmp;
    if (bestscore < scr) {
      bestscore = scr;
      bestvh = i;
      bestve = ve;
    }
    i ++;
  }
  return (bestvh);
}
}
void vithist_utt_reset(vithist_t *vh ) 
{ 
  int32 b ;

  {
  vithist_lmstate_reset(vh);
  b = (vh->n_entry - 1) >> 14;
  while (b >= 0) {
    ckd_free((void *)*(vh->entry + b));
    *(vh->entry + b) = (vithist_entry_t *)((void *)0);
    b --;
  }
  vh->n_entry = 0;
  *(vh->bestscore + 0) = (int32 )2147483648U;
  *(vh->bestvh + 0) = -1;
  return;
}
}
void vithist_dump(vithist_t *vh , int32 frm , kbcore_t *kbc , FILE *fp ) 
{ 
  int32 b ;
  int32 l ;
  int32 i ;
  int32 j ;
  dict_t *dict ;
  lm_t *lm ;
  vithist_entry_t *ve ;
  s3lmwid_t lwid ;
  int32 sf ;
  int32 ef ;
  int tmp ;

  {
  dict = kbc->dict;
  lm = kbc->lm;
  if (frm >= 0) {
    sf = frm;
    ef = frm;
    fprintf(fp, "VITHIST  frame %d  #entries %d\n", frm, *(vh->frame_start + (sf + 1)) - *(vh->frame_start + sf));
  } else {
    sf = 0;
    ef = vh->n_frm - 1;
    fprintf(fp, "VITHIST  #frames %d  #entries %d\n", vh->n_frm, vh->n_entry);
  }
  fprintf(fp, "\t%7s %5s %5s %11s %9s %8s %7s %4s Word (LM-state)\n", "Seq/Val", "SFrm",
          "EFrm", "PathScr", "SegAScr", "SegLScr", "Pred", "Type");
  i = sf;
  while (i <= ef) {
    fprintf(fp, "%5d BS: %11d BV: %8d\n", i, *(vh->bestscore + i), *(vh->bestvh + i));
    j = *(vh->frame_start + i);
    while (j < *(vh->frame_start + (i + 1))) {
      b = j >> 14;
      l = j & 16383;
      ve = *(vh->entry + b) + l;
      if (ve->valid) {
        tmp = ' ';
      } else {
        tmp = '*';
      }
      fprintf(fp, "\t%c%6d %5d %5d %11d %9d %8d %7d %4d %s", tmp, j, (int )ve->sf,
              (int )ve->ef, ve->score, ve->ascr, ve->lscr, ve->pred, ve->type, (dict->word + ve->wid)->word);
      fprintf(fp, " (%s", *(lm->wordstr + ve->lmstate.lm3g.lwid[0]));
      lwid = ve->lmstate.lm3g.lwid[1];
      if ((int )lwid != 65535) {
        fprintf(fp, ", %s", *(lm->wordstr + lwid));
      }
      fprintf(fp, ")\n");
      j ++;
    }
    if (j == *(vh->frame_start + i)) {
      fprintf(fp, "\n");
    }
    i ++;
  }
  fprintf(fp, "END_VITHIST\n");
  fflush(fp);
  return;
}
}
glist_t vithist_backtrace(vithist_t *vh , int32 id ) 
{ 
  vithist_entry_t *ve ;
  int32 b ;
  int32 l ;
  glist_t hyp ;
  hyp_t *h ;
  void *tmp ;

  {
  hyp = (glist_t )((void *)0);
  while (id > 0) {
    b = id >> 14;
    l = id & 16383;
    ve = *(vh->entry + b) + l;
    tmp = __ckd_calloc__((size_t )1, sizeof(hyp_t ), "vithist.c", 784);
    h = (hyp_t *)tmp;
    h->id = ve->wid;
    h->sf = (int32 )ve->sf;
    h->ef = (int32 )ve->ef;
    h->ascr = ve->ascr;
    h->lscr = ve->lscr;
    h->type = ve->type;
    h->vhid = id;
    hyp = glist_add_ptr(hyp, (void *)h);
    id = ve->pred;
  }
  return (hyp);
}
}
void vithist_dag_write(vithist_t *vh , glist_t hyp , dict_t *dict , int32 oldfmt ,
                       FILE *fp ) 
{ 
  glist_t *sfwid ;
  vithist_entry_t *ve ;
  vithist_entry_t *ve2 ;
  gnode_t *gn ;
  gnode_t *gn2 ;
  gnode_t *gn3 ;
  dagnode_t *dn ;
  dagnode_t *dn2 ;
  int32 sf ;
  int32 ef ;
  int32 n_node ;
  int32 f ;
  int32 i ;
  hyp_t *h ;
  void *tmp ;
  void *tmp___0 ;
  int32 tmp___1 ;

  {
  tmp = __ckd_calloc__((size_t )(vh->n_frm + 1), sizeof(glist_t ), "vithist.c", 823);
  sfwid = (glist_t *)tmp;
  n_node = 0;
  i = 0;
  while (i < vh->n_entry) {
    ve = *(vh->entry + (i >> 14)) + (i & 16383);
    if (! ve->valid) {
      goto __Cont;
    }
    if ((int )ve->sf <= 0) {
      sf = (int )ve->sf + 1;
      if ((int )ve->ef < 0) {
        ef = 0;
      } else {
        ef = (int32 )ve->ef;
      }
    } else {
      sf = (int32 )ve->sf;
      ef = (int32 )ve->ef;
    }
    gn = *(sfwid + sf);
    while (gn) {
      dn = (dagnode_t *)gn->data.ptr;
      if (dn->wid == ve->wid) {
        break;
      }
      gn = gn->next;
    }
    if (! gn) {
      tmp___0 = __ckd_calloc__((size_t )1, sizeof(dagnode_t ), "vithist.c", 854);
      dn = (dagnode_t *)tmp___0;
      dn->wid = ve->wid;
      dn->fef = ef;
      dn->lef = ef;
      dn->seqid = -1;
      dn->velist = (glist_t )((void *)0);
      n_node ++;
      *(sfwid + sf) = glist_add_ptr(*(sfwid + sf), (void *)dn);
    } else {
      dn->lef = ef;
    }
    gn = dn->velist;
    while (gn) {
      ve2 = (vithist_entry_t *)gn->data.ptr;
      if ((int )ve2->ef == (int )ve->ef) {
        break;
      }
      gn = gn->next;
    }
    if (gn) {
      if (ve->score > ve2->score) {
        gn->data.ptr = (void *)ve;
      }
    } else {
      dn->velist = glist_add_ptr(dn->velist, (void *)ve);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  gn = hyp;
  while (gn) {
    h = (hyp_t *)gn->data.ptr;
    gn2 = *(sfwid + h->sf);
    while (gn2) {
      dn = (dagnode_t *)gn2->data.ptr;
      if (h->id == dn->wid) {
        dn->seqid = 0;
      }
      gn2 = gn2->next;
    }
    gn = gn->next;
  }
  dn = (dagnode_t *)(*(sfwid + 0))->data.ptr;
  dn->seqid = 0;
  dn = (dagnode_t *)(*(sfwid + vh->n_frm))->data.ptr;
  dn->seqid = 0;
  i = 0;
  f = vh->n_frm;
  while (f >= 0) {
    gn = *(sfwid + f);
    while (gn) {
      dn = (dagnode_t *)gn->data.ptr;
      if (dn->lef > dn->fef) {
        tmp___1 = i;
        i ++;
        dn->seqid = tmp___1;
      } else
      if (dn->seqid >= 0) {
        tmp___1 = i;
        i ++;
        dn->seqid = tmp___1;
      } else {
        dn->seqid = -1;
      }
      gn = gn->next;
    }
    f --;
  }
  n_node = i;
  fprintf(fp, "Nodes %d (NODEID WORD STARTFRAME FIRST-ENDFRAME LAST-ENDFRAME)\n",
          n_node);
  f = vh->n_frm;
  while (f >= 0) {
    gn = *(sfwid + f);
    while (gn) {
      dn = (dagnode_t *)gn->data.ptr;
      if (dn->seqid >= 0) {
        fprintf(fp, "%d %s %d %d %d\n", dn->seqid, (dict->word + dn->wid)->word, f,
                dn->fef, dn->lef);
      }
      gn = gn->next;
    }
    f --;
  }
  fprintf(fp, "#\n");
  fprintf(fp, "Initial %d\nFinal %d\n", n_node - 1, 0);
  fprintf(fp, "#\n");
  fprintf(fp, "BestSegAscr 0 (NODEID ENDFRAME ASCORE)\n");
  fprintf(fp, "#\n");
  if (oldfmt) {
    fprintf(fp, "Edges (FROM-NODEID TO-NODEID ASCORE)\n");
  } else {
    fprintf(fp, "Edges (FROM-NODEID ENDFRAME ASCORE)\n");
  }
  f = vh->n_frm - 1;
  while (f >= 0) {
    gn = *(sfwid + f);
    while (gn) {
      dn = (dagnode_t *)gn->data.ptr;
      if (dn->seqid < 0) {
        goto __Cont___0;
      }
      gn2 = dn->velist;
      while (gn2) {
        ve = (vithist_entry_t *)gn2->data.ptr;
        if ((int )ve->ef < 0) {
          sf = 1;
        } else {
          sf = (int )ve->ef + 1;
        }
        if (oldfmt) {
          gn3 = *(sfwid + sf);
          while (gn3) {
            dn2 = (dagnode_t *)gn3->data.ptr;
            if (dn2->seqid >= 0) {
              fprintf(fp, "%d %d %d\n", dn->seqid, dn2->seqid, ve->ascr);
            }
            gn3 = gn3->next;
          }
        } else {
          gn3 = *(sfwid + sf);
          while (gn3) {
            dn2 = (dagnode_t *)gn3->data.ptr;
            if (dn2->seqid >= 0) {
              fprintf(fp, "%d %d %d\n", dn->seqid, sf - 1, ve->ascr);
              break;
            }
            gn3 = gn3->next;
          }
        }
        gn2 = gn2->next;
      }
      __Cont___0: /* CIL Label */ 
      gn = gn->next;
    }
    f --;
  }
  fprintf(fp, "End\n");
  f = 0;
  while (f <= vh->n_frm) {
    gn = *(sfwid + f);
    while (gn) {
      dn = (dagnode_t *)gn->data.ptr;
      glist_free(dn->velist);
      ckd_free((void *)dn);
      gn = gn->next;
    }
    glist_free(*(sfwid + f));
    f ++;
  }
  ckd_free((void *)sfwid);
  return;
}
}
void vithist_free(vithist_t *v ) 
{ 


  {
  if (v) {
    ckd_free((void *)v);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-y2ZYKGTx.i","-O3")
s3lmwid_t *wid_dict_lm_map(dict_t *dict , lm_t *lm , int32 lw ) 
{ 
  int32 u ;
  int32 n ;
  s3wid_t w___0 ;
  s3wid_t dictid ;
  int32 classid ;
  s3lmwid_t *map ;
  int32 maperr ;
  lmclass_word_t lmclass_word ;
  void *tmp ;
  int32 tmp___0 ;
  int32 tmp___1 ;

  {
  maperr = 0;
  tmp = __ckd_calloc__((size_t )dict->n_word, sizeof(s3lmwid_t ), "wid.c", 76);
  map = (s3lmwid_t *)tmp;
  n = 0;
  while (n < dict->n_word) {
    *(map + n) = (s3lmwid_t )65535;
    if (lm->inclass_ugscore) {
      *(lm->inclass_ugscore + n) = 0;
    }
    n ++;
  }
  n = 0;
  u = 0;
  while (u < lm->n_ug) {
    w___0 = dict_wordid(dict, *(lm->wordstr + u));
    if (lm->lmclass) {
      classid = lm_get_classid(lm, *(lm->wordstr + u));
    }
    (lm->ug + u)->dictwid = w___0;
    if (w___0 >= 0) {
      if (lm->lmclass) {
        if (classid >= 0) {
          _E__pr_header("wid.c", 101L, "ERROR");
          _E__pr_warn("%s is both a word and an LM class name\n", *(lm->wordstr + u));
          maperr = 1;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        tmp___0 = dict_filler_word(dict, w___0);
        if (tmp___0) {
          _E__pr_header("wid.c", 108L, "ERROR");
          _E__pr_warn("Filler dictionary word \'%s\' found in LM\n", *(lm->wordstr + u));
        }
        if (w___0 != (dict->word + w___0)->basewid) {
          _E__pr_header("wid.c", 111L, "ERROR");
          _E__pr_warn("LM word \'%s\' is an alternative pronunciation in dictionary\n",
                      *(lm->wordstr + u));
          w___0 = (dict->word + w___0)->basewid;
          (lm->ug + u)->dictwid = w___0;
        }
        while (w___0 >= 0) {
          *(map + w___0) = (s3lmwid_t )u;
          w___0 = (dict->word + w___0)->alt;
        }
      }
    } else
    if (lm->lmclass) {
      if (classid >= 0) {
        (lm->ug + u)->dictwid = classid;
        lmclass_word = (*(lm->lmclass + (classid - 16777216)))->wordlist;
        while ((unsigned long )lmclass_word != (unsigned long )((void *)0)) {
          dictid = lmclass_word->dictwid;
          if (dictid >= 0) {
            if ((int )*(map + dictid) >= 0) {
              if ((int )*(map + dictid) != 65535) {
                _E__pr_info_header("wid.c", 138L, "INFO");
                _E__pr_info("map[dictid] = %d\n", (int )*(map + dictid));
                _E__pr_header("wid.c", 139L, "ERROR");
                _E__pr_warn("Multiple mappings of \'%s\' in LM\n", lmclass_word->word);
                maperr = 1;
              } else {
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              tmp___1 = dict_filler_word(dict, dictid);
              if (tmp___1) {
                _E__pr_header("wid.c", 144L, "ERROR");
                _E__pr_warn("Filler dictionary word \'%s\' found in LM\n", *(lm->wordstr + dictid));
              }
              if (dictid != (dict->word + dictid)->basewid) {
                _E__pr_header("wid.c", 147L, "ERROR");
                _E__pr_warn("LM word \'%s\' is an alternative pronunciation in dictionary\n",
                            *(lm->wordstr + dictid));
                dictid = (dict->word + dictid)->basewid;
              }
              while (dictid >= 0) {
                *(map + dictid) = (s3lmwid_t )u;
                *(lm->inclass_ugscore + dictid) = lmclass_word->LOGprob * lw;
                dictid = (dict->word + dictid)->alt;
              }
            }
          } else {
            n ++;
          }
          lmclass_word = lmclass_word->next;
        }
      } else {
        n ++;
      }
    } else {
      n ++;
    }
    u ++;
  }
  if (n > 0) {
    _E__pr_info_header("wid.c", 178L, "INFO");
    _E__pr_info("%d LM words not in dictionary; ignored\n", n);
  }
  if (maperr) {
    _E__pr_header("wid.c", 187L, "FATAL_ERROR");
    _E__die_error("Error in mapping, please read the log to see why\n");
  }
  return (map);
}
}
int32 wid_wordprob2alt(dict_t *dict , wordprob_t *wp , int32 n ) 
{ 
  int32 i ;
  int32 j ;
  s3wid_t w___0 ;

  {
  i = 0;
  j = n;
  while (i < n) {
    w___0 = (wp + i)->wid;
    w___0 = (dict->word + w___0)->alt;
    while (w___0 >= 0) {
      (wp + j)->wid = w___0;
      (wp + j)->prob = (wp + i)->prob;
      j ++;
      w___0 = (dict->word + w___0)->alt;
    }
    i ++;
  }
  return (j);
}
}
