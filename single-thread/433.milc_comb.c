/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

typedef long long __int64_t;
typedef __int64_t __darwin_off_t;
typedef __darwin_off_t fpos_t;
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
struct __sFILEX;
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   void *_cookie ;
   int (*_close)(void * ) ;
   int (*_read)(void * , char * , int  ) ;
   fpos_t (*_seek)(void * , fpos_t  , int  ) ;
   int (*_write)(void * , char const   * , int  ) ;
   struct __sbuf _ub ;
   struct __sFILEX *_extra ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   fpos_t _offset ;
};
typedef struct __sFILE FILE;
struct __anonstruct_complex_12 {
   double real ;
   double imag ;
};
typedef struct __anonstruct_complex_12 complex;
struct __anonstruct_double_prn_14 {
   unsigned long r0 ;
   unsigned long r1 ;
   unsigned long r2 ;
   unsigned long r3 ;
   unsigned long r4 ;
   unsigned long r5 ;
   unsigned long r6 ;
   unsigned long multiplier ;
   unsigned long addend ;
   unsigned long ic_state ;
   double scale ;
};
typedef struct __anonstruct_double_prn_14 double_prn;
struct __anonstruct_su3_matrix_15 {
   complex e[3][3] ;
};
typedef struct __anonstruct_su3_matrix_15 su3_matrix;
struct __anonstruct_su3_vector_16 {
   complex c[3] ;
};
typedef struct __anonstruct_su3_vector_16 su3_vector;
struct __anonstruct_anti_hermitmat_17 {
   complex m01 ;
   complex m02 ;
   complex m12 ;
   double m00im ;
   double m11im ;
   double m22im ;
   double space ;
};
typedef struct __anonstruct_anti_hermitmat_17 anti_hermitmat;
typedef int int32type;
typedef unsigned int u_int32type;
typedef int field_offset;
struct __anonstruct_gauge_header_30 {
   int32type magic_number ;
   char time_stamp[64] ;
   int32type dims[4] ;
   int32type header_bytes ;
   int32type order ;
};
typedef struct __anonstruct_gauge_header_30 gauge_header;
struct __anonstruct_gauge_check_31 {
   u_int32type sum31 ;
   u_int32type sum29 ;
};
typedef struct __anonstruct_gauge_check_31 gauge_check;
struct __anonstruct_gauge_file_35 {
   FILE *fp ;
   gauge_header *header ;
   char *filename ;
   int byterevflag ;
   int32type *rank2rcv ;
   int parallel ;
   gauge_check check ;
};
typedef struct __anonstruct_gauge_file_35 gauge_file;
struct __anonstruct_site_36 {
   short x ;
   short y ;
   short z ;
   short t ;
   char parity ;
   int index ;
   double_prn site_prn ;
   int space1 ;
   su3_matrix link[4] ;
   anti_hermitmat mom[4] ;
   double phase[4] ;
   su3_vector phi ;
   su3_vector resid ;
   su3_vector cg_p ;
   su3_vector xxx ;
   su3_vector ttt ;
   su3_vector g_rand ;
   su3_vector tempvec[4] ;
   su3_vector templongvec[4] ;
   su3_vector templongv1 ;
   su3_matrix tempmat1 ;
   su3_matrix staple ;
};
typedef struct __anonstruct_site_36 site;
struct __anonstruct_params_38 {
   int stopflag ;
   int nx ;
   int ny ;
   int nz ;
   int nt ;
   int iseed ;
   int nflavors ;
   int warms ;
   int trajecs ;
   int steps ;
   int propinterval ;
   double beta ;
   double mass ;
   double u0 ;
   int niter ;
   double rsqmin ;
   double rsqprop ;
   double epsilon ;
   int source_start ;
   int source_inc ;
   int n_sources ;
   int startflag ;
   int saveflag ;
   char startfile[256] ;
   char savefile[256] ;
};
typedef struct __anonstruct_params_38 params;
union __anonunion_ifval_38 {
   double fval ;
   int ival ;
};
typedef unsigned long __darwin_size_t;
typedef __darwin_size_t size_t;
struct __anonstruct_msg_tag_37 {
   int msg_node ;
   int msg_size ;
   char *msg_buf ;
   int msg_id ;
};
typedef struct __anonstruct_msg_tag_37 msg_tag;
struct __anonstruct_su2_matrix_18 {
   complex e[2][2] ;
};
typedef struct __anonstruct_su2_matrix_18 su2_matrix;
typedef long __darwin_time_t;
typedef __darwin_off_t off_t;
typedef __darwin_time_t time_t;
struct __anonstruct_QCDheader_34 {
   int ntoken ;
   char **token ;
   char **value ;
};
typedef struct __anonstruct_QCDheader_34 QCDheader;
#pragma pack(4)
#pragma pack()
typedef double OUTPUT_TYPE;
union __anonunion_u_39 {
   long l ;
   char c[sizeof(long )] ;
};
struct __anonstruct_gauge_field_40 {
   int32type n_descript ;
   char descript[200] ;
   int32type n_param ;
   double param[2] ;
};
struct __anonstruct_msg_41 {
   short x ;
   short y ;
   short z ;
   short t ;
   su3_matrix link[4] ;
};
struct __anonstruct_msg_42 {
   short x ;
   short y ;
   short z ;
   short t ;
   su3_matrix link[4] ;
};
union __anonunion_ifval_38___0 {
   double fval ;
   int ival ;
};
struct __anonstruct_half_wilson_vector_31 {
   su3_vector h[2] ;
};
typedef struct __anonstruct_half_wilson_vector_31 half_wilson_vector;
struct __anonstruct_q_paths_38 {
   int dir[7] ;
   int length ;
   double coeff ;
   double forwback ;
};
struct __anonstruct_double_complex_13 {
   double real ;
   double imag ;
};
typedef struct __anonstruct_double_complex_13 double_complex;
struct __anonstruct_wilson_vector_19 {
   su3_vector d[4] ;
};
typedef struct __anonstruct_wilson_vector_19 wilson_vector;
typedef long __darwin_ssize_t;
typedef __darwin_ssize_t ssize_t;
#pragma pack(4)
#pragma pack()
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-11jyHvmJ.i","-O3")
extern FILE *__stdoutp ;
extern int fflush(FILE * ) ;
extern int ( /* format attribute */  printf)(char const   *  , ...) ;
char *gauge_info_keyword[36]  = 
  {      (char *)"magic_number",      (char *)"time_stamp",      (char *)"checksums",      (char *)"nx", 
        (char *)"ny",      (char *)"nz",      (char *)"nt",      (char *)"action.description", 
        (char *)"gauge.description",      (char *)"gauge.beta11",      (char *)"gauge.beta12",      (char *)"gauge.tadpole.u0", 
        (char *)"gauge.nloops",      (char *)"gauge.nreps",      (char *)"gauge.previous.filename",      (char *)"gauge.previous.time_stamp", 
        (char *)"gauge.previous.checksums",      (char *)"gauge.fix.description",      (char *)"gauge.fix.tolerance",      (char *)"gauge.smear.description", 
        (char *)"gauge.smear.steps",      (char *)"gauge.smear.factor",      (char *)"quark.description",      (char *)"quark.flavors", 
        (char *)"quark.flavors1",      (char *)"quark.flavors2",      (char *)"quark.mass",      (char *)"quark.mass1", 
        (char *)"quark.mass2",      (char *)"quark.kappa",      (char *)"quark.link.c1",      (char *)"quark.link.c3", 
        (char *)"quark.staple.w3",      (char *)"quark.clover.c0",      (char *)"quark.clover.u0",      (char *)""};
char ensemble_id[256]  ;
int sequence_number  ;
gauge_file *save_lattice(int flag , char *filename ) ;
int nx  ;
int ny  ;
int nz  ;
int nt  ;
int volume  ;
int iseed  ;
int warms  ;
int trajecs  ;
int steps  ;
int niter  ;
int propinterval  ;
int nflavors  ;
double epsilon  ;
double beta  ;
double mass  ;
double u0  ;
double rsqmin  ;
double rsqprop  ;
int startflag  ;
int saveflag  ;
char startfile[256]  ;
char savefile[256]  ;
int total_iters  ;
int phases_in  ;
int source_start  ;
int source_inc  ;
int n_sources  ;
int sites_on_node  ;
int even_sites_on_node  ;
int odd_sites_on_node  ;
int number_of_nodes  ;
int this_node  ;
int valid_longlinks  ;
int valid_fatlinks  ;
gauge_file *startlat_p  ;
double_prn node_prn  ;
site *lattice  ;
char **gen_pt[16]  ;
su3_matrix *t_longlink  ;
su3_matrix *t_fatlink  ;
void initialize_machine(int argc , char **argv ) ;
void g_sync(void) ;
double dclock(void) ;
void rephase(int flag ) ;
void f_meas_imp(field_offset phi_off , field_offset xxx_off , double mass___0 ) ;
int setup(void) ;
int readin(int prompt ) ;
int update(void) ;
void g_measure(void) ;
gauge_header start_lat_hdr  ;
int main(int argc , char **argv ) 
{ 
  int meascount ;
  int traj_done ;
  int prompt ;
  int s_iters ;
  int avs_iters ;
  int avspect_iters ;
  int avbcorr_iters ;
  double dtime ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;

  {
  initialize_machine(argc, argv);
  g_sync();
  prompt = setup();
  while (1) {
    tmp___1 = readin(prompt);
    if (! (tmp___1 == 0)) {
      break;
    }
    tmp = dclock();
    dtime = - tmp;
    traj_done = 0;
    while (traj_done < warms) {
      update();
      traj_done ++;
    }
    if (this_node == 0) {
      printf("WARMUPS COMPLETED\n");
    }
    fflush(__stdoutp);
    meascount = 0;
    avbcorr_iters = 0;
    avs_iters = avbcorr_iters;
    avspect_iters = avs_iters;
    traj_done = 0;
    while (traj_done < trajecs) {
      s_iters = update();
      if (traj_done % propinterval == propinterval - 1) {
        rephase(0);
        g_measure();
        rephase(1);
        f_meas_imp((field_offset )((char *)(& (lattice + 0)->phi) - (char *)(lattice + 0)),
                   (field_offset )((char *)(& (lattice + 0)->xxx) - (char *)(lattice + 0)),
                   mass);
        avs_iters += s_iters;
        meascount ++;
        fflush(__stdoutp);
      }
      traj_done ++;
    }
    if (this_node == 0) {
      printf("RUNNING COMPLETED\n");
    }
    fflush(__stdoutp);
    if (meascount > 0) {
      if (this_node == 0) {
        printf("average cg iters for step= %e\n", (double )avs_iters / (double )meascount);
      }
    }
    tmp___0 = dclock();
    dtime += tmp___0;
    if (this_node == 0) {
      printf("total_iters = %d\n", total_iters);
    }
    fflush(__stdoutp);
    if (saveflag != 20) {
      rephase(0);
      save_lattice(saveflag, savefile);
      rephase(1);
    }
  }
  return (0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-O6xOBfRH.i","-O3")
complex su3_dot(su3_vector *a , su3_vector *b ) ;
void g_doublesum(double *dpt ) ;
void grsource_imp(field_offset dest , double mass___0 , int parity ) ;
int mat_invert_uml(field_offset src , field_offset dest , field_offset temp___0 ,
                   double mass___0 ) ;
void load_longlinks(void) ;
void load_fatlinks(void) ;
void f_meas_imp(field_offset phi_off , field_offset xxx_off , double mass___0 ) 
{ 
  double r_psi_bar_psi_even ;
  double r_psi_bar_psi_odd ;
  double r_ferm_action ;
  register int i ;
  register site *st ;
  double rpbp_e ;
  double rpbp_o ;
  double rfaction ;
  complex cc ;
  int npbp_reps ;
  int jpbp_reps ;

  {
  npbp_reps = 1;
  if (! (valid_longlinks == 1)) {
    load_longlinks();
  }
  if (! (valid_fatlinks == 1)) {
    load_fatlinks();
  }
  jpbp_reps = 0;
  while (jpbp_reps < npbp_reps) {
    rfaction = 0.0;
    rpbp_o = rfaction;
    rpbp_e = rpbp_o;
    grsource_imp(phi_off, mass___0, 3);
    mat_invert_uml((field_offset )((char *)(& (lattice + 0)->g_rand) - (char *)(lattice + 0)),
                   xxx_off, phi_off, mass___0);
    i = 0;
    st = lattice;
    while (i < even_sites_on_node) {
      cc = su3_dot((su3_vector *)((char *)st + phi_off), (su3_vector *)((char *)st + xxx_off));
      rfaction += cc.real;
      cc = su3_dot(& st->g_rand, (su3_vector *)((char *)st + xxx_off));
      rpbp_e += cc.real;
      i ++;
      st ++;
    }
    i = even_sites_on_node;
    st = lattice + i;
    while (i < sites_on_node) {
      cc = su3_dot(& st->g_rand, (su3_vector *)((char *)st + xxx_off));
      rpbp_o += cc.real;
      i ++;
      st ++;
    }
    g_doublesum(& rpbp_o);
    g_doublesum(& rpbp_e);
    g_doublesum(& rfaction);
    r_psi_bar_psi_odd = rpbp_o * (2.0 / (double )volume);
    r_psi_bar_psi_even = rpbp_e * (2.0 / (double )volume);
    r_ferm_action = rfaction * (1.0 / (double )volume);
    if (this_node == 0) {
      printf("PBP: mass %e     %e  %e ( %d of %d )\n", mass___0, r_psi_bar_psi_even,
             r_psi_bar_psi_odd, jpbp_reps + 1, npbp_reps);
    }
    if (this_node == 0) {
      printf("FACTION: mass = %e,  %e ( %d of %d )\n", mass___0, r_ferm_action, jpbp_reps + 1,
             npbp_reps);
    }
    jpbp_reps ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-8j3HxuLy.i","-O3")
int write_gauge_info_item(FILE *fpout , char *keyword , char *fmt , char *src , int count ,
                          int stride ) ;
void write_appl_gauge_info(FILE *fp ) ;
static char quark_action_description[72]  = 
  {      (char )'\"',      (char )'O',      (char )'(',      (char )'a', 
        (char )'^',      (char )'2',      (char )')',      (char )':', 
        (char )' ',      (char )'c',      (char )'o',      (char )'u', 
        (char )'p',      (char )'l',      (char )'i',      (char )'n', 
        (char )'g',      (char )'s',      (char )'(',      (char )'p', 
        (char )'i',      (char )')',      (char )'=',      (char )'0', 
        (char )',',      (char )' ',      (char )'N',      (char )'a', 
        (char )'i',      (char )'k',      (char )' ',      (char )'t', 
        (char )'e',      (char )'r',      (char )'m',      (char )',', 
        (char )' ',      (char )'N',      (char )'o',      (char )' ', 
        (char )'O',      (char )'(',      (char )'a',      (char )'^', 
        (char )'2',      (char )')',      (char )' ',      (char )'e', 
        (char )'r',      (char )'r',      (char )'o',      (char )'r', 
        (char )'s',      (char )',',      (char )' ',      (char )'t', 
        (char )'a',      (char )'d',      (char )'p',      (char )'o', 
        (char )'l',      (char )'e',      (char )' ',      (char )'w', 
        (char )'e',      (char )'i',      (char )'g',      (char )'h', 
        (char )'t',      (char )'s',      (char )'\"',      (char )'\000'};
char gauge_action_description[128] ;
int gauge_action_nloops ;
int gauge_action_nreps ;
void write_appl_gauge_info(FILE *fp ) 
{ 


  {
  write_gauge_info_item(fp, (char *)"action.description", (char *)"%s", (char *)"\"Gauge plus fermion (improved)\"",
                        0, 0);
  write_gauge_info_item(fp, (char *)"gauge.description", (char *)"%s", gauge_action_description,
                        0, 0);
  write_gauge_info_item(fp, (char *)"gauge.nloops", (char *)"%d", (char *)(& gauge_action_nloops),
                        0, 0);
  write_gauge_info_item(fp, (char *)"gauge.nreps", (char *)"%d", (char *)(& gauge_action_nreps),
                        0, 0);
  write_gauge_info_item(fp, (char *)"gauge.beta11", (char *)"%f", (char *)(& beta),
                        0, 0);
  write_gauge_info_item(fp, (char *)"gauge.tadpole.u0", (char *)"%f", (char *)(& u0),
                        0, 0);
  write_gauge_info_item(fp, (char *)"quark.description", (char *)"%s", quark_action_description,
                        0, 0);
  write_gauge_info_item(fp, (char *)"quark.flavors", (char *)"%d", (char *)(& nflavors),
                        0, 0);
  write_gauge_info_item(fp, (char *)"quark.mass", (char *)"%f", (char *)(& mass),
                        0, 0);
  return;
}
}
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-9C8lIhwg.i","-O3")
__inline static char *__inline_strcpy_chk(char *__dest , char const   *__src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcpy_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
extern  __attribute__((__noreturn__)) void exit(int  ) ;
gauge_file *reload_lattice(int flag , char *filename ) ;
int ask_starting_lattice(int prompt , int *flag , char *filename ) ;
int ask_ending_lattice(int prompt , int *flag , char *filename ) ;
int get_f(int prompt , char *variable_name_string , double *value ) ;
int get_i(int prompt , char *variable_name_string , int *value ) ;
int get_prompt(int *prompt ) ;
void make_nn_gathers(void) ;
void sort_eight_neighborlists(int index___0 ) ;
int make_gather(void (*func)(int  , int  , int  , int  , int * , int  , int * , int * ,
                             int * , int * ) , int *args , int inverse , int want_even_odd ,
                int parity_conserve ) ;
char *machine_type(void) ;
int mynode(void) ;
int numnodes(void) ;
void broadcast_bytes(char *buf , int size ) ;
void normal_exit(int status ) ;
void phaseset(void) ;
void make_path_table(void) ;
void make_loop_table(void) ;
void setup_layout(void) ;
void make_lattice(void) ;
void initialize_prn(double_prn *prn_pt , int seed , int index___0 ) ;
gauge_file *gf  ;
params par_buf  ;
int initial_set(void) ;
void make_3n_gathers(void) ;
int setup(void) 
{ 
  int prompt ;
  int tmp ;

  {
  prompt = initial_set();
  tmp = mynode();
  initialize_prn(& node_prn, iseed, volume + tmp);
  setup_layout();
  make_lattice();
  if (this_node == 0) {
    printf("Made lattice\n");
  }
  fflush(__stdoutp);
  make_nn_gathers();
  if (this_node == 0) {
    printf("Made nn gathers\n");
  }
  fflush(__stdoutp);
  make_3n_gathers();
  if (this_node == 0) {
    printf("Made 3nn gathers\n");
  }
  fflush(__stdoutp);
  phaseset();
  if (this_node == 0) {
    printf("Finished setup\n");
  }
  fflush(__stdoutp);
  return (prompt);
}
}
int initial_set(void) 
{ 
  int prompt ;
  int status ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  tmp___7 = mynode();
  if (tmp___7 == 0) {
    printf("SU3 with improved KS action\n");
    printf("Microcanonical simulation with refreshing\n");
    printf("MIMD version 6\n");
    tmp = numnodes();
    tmp___0 = machine_type();
    printf("Machine = %s, with %d nodes\n", tmp___0, tmp);
    printf("R algorithm\n");
    status = get_prompt(& prompt);
    if (status == 0) {
      tmp___1 = get_i(prompt, (char *)"nflavors", & par_buf.nflavors);
      status += tmp___1;
    }
    if (status == 0) {
      tmp___2 = get_i(prompt, (char *)"nx", & par_buf.nx);
      status += tmp___2;
    }
    if (status == 0) {
      tmp___3 = get_i(prompt, (char *)"ny", & par_buf.ny);
      status += tmp___3;
    }
    if (status == 0) {
      tmp___4 = get_i(prompt, (char *)"nz", & par_buf.nz);
      status += tmp___4;
    }
    if (status == 0) {
      tmp___5 = get_i(prompt, (char *)"nt", & par_buf.nt);
      status += tmp___5;
    }
    if (status == 0) {
      tmp___6 = get_i(prompt, (char *)"iseed", & par_buf.iseed);
      status += tmp___6;
    }
    if (status > 0) {
      par_buf.stopflag = 1;
    } else {
      par_buf.stopflag = 0;
    }
  }
  broadcast_bytes((char *)(& par_buf), (int )sizeof(par_buf));
  if (par_buf.stopflag != 0) {
    normal_exit(0);
  }
  nx = par_buf.nx;
  ny = par_buf.ny;
  nz = par_buf.nz;
  nt = par_buf.nt;
  iseed = par_buf.iseed;
  nflavors = par_buf.nflavors;
  this_node = mynode();
  number_of_nodes = numnodes();
  volume = ((nx * ny) * nz) * nt;
  total_iters = 0;
  return (prompt);
}
}
int readin(int prompt ) 
{ 
  int status ;
  double x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;
  unsigned long tmp___15 ;

  {
  if (this_node == 0) {
    printf("\n\n");
    status = 0;
    if (status == 0) {
      tmp = get_i(prompt, (char *)"warms", & par_buf.warms);
      status += tmp;
    }
    if (status == 0) {
      tmp___0 = get_i(prompt, (char *)"trajecs", & par_buf.trajecs);
      status += tmp___0;
    }
    if (status == 0) {
      tmp___1 = get_i(prompt, (char *)"traj_between_meas", & par_buf.propinterval);
      status += tmp___1;
    }
    if (status == 0) {
      tmp___2 = get_f(prompt, (char *)"beta", & par_buf.beta);
      status += tmp___2;
    }
    if (status == 0) {
      tmp___3 = get_f(prompt, (char *)"mass", & par_buf.mass);
      status += tmp___3;
    }
    if (status == 0) {
      tmp___4 = get_f(prompt, (char *)"u0", & par_buf.u0);
      status += tmp___4;
    }
    if (status == 0) {
      tmp___5 = get_f(prompt, (char *)"microcanonical_time_step", & par_buf.epsilon);
      status += tmp___5;
    }
    if (status == 0) {
      tmp___6 = get_i(prompt, (char *)"steps_per_trajectory", & par_buf.steps);
      status += tmp___6;
    }
    if (status == 0) {
      tmp___7 = get_i(prompt, (char *)"max_cg_iterations", & par_buf.niter);
      status += tmp___7;
    }
    if (status == 0) {
      tmp___8 = get_f(prompt, (char *)"error_per_site", & x);
      status += tmp___8;
    }
    if (status == 0) {
      par_buf.rsqmin = x * x;
    }
    if (status == 0) {
      tmp___9 = get_f(prompt, (char *)"error_for_propagator", & x);
      status += tmp___9;
    }
    if (status == 0) {
      par_buf.rsqprop = x * x;
    }
    if (status == 0) {
      tmp___10 = ask_starting_lattice(prompt, & par_buf.startflag, par_buf.startfile);
      status += tmp___10;
    }
    if (status == 0) {
      tmp___11 = ask_ending_lattice(prompt, & par_buf.saveflag, par_buf.savefile);
      status += tmp___11;
    }
    if (status > 0) {
      par_buf.stopflag = 1;
    } else {
      par_buf.stopflag = 0;
    }
  }
  broadcast_bytes((char *)(& par_buf), (int )sizeof(par_buf));
  if (par_buf.stopflag != 0) {
    normal_exit(0);
  }
  warms = par_buf.warms;
  trajecs = par_buf.trajecs;
  steps = par_buf.steps;
  propinterval = par_buf.propinterval;
  niter = par_buf.niter;
  rsqmin = par_buf.rsqmin;
  rsqprop = par_buf.rsqprop;
  epsilon = par_buf.epsilon;
  beta = par_buf.beta;
  mass = par_buf.mass;
  u0 = par_buf.u0;
  startflag = par_buf.startflag;
  saveflag = par_buf.saveflag;
  tmp___13 = __builtin_object_size((void *)(startfile), 0);
  if (tmp___13 != 0xffffffffffffffffUL) {
    tmp___12 = __builtin_object_size((void *)(startfile), 1);
    __builtin___strcpy_chk(startfile, (char const   *)(par_buf.startfile), tmp___12);
  } else {
    __inline_strcpy_chk(startfile, (char const   *)(par_buf.startfile));
  }
  tmp___15 = __builtin_object_size((void *)(savefile), 0);
  if (tmp___15 != 0xffffffffffffffffUL) {
    tmp___14 = __builtin_object_size((void *)(savefile), 1);
    __builtin___strcpy_chk(savefile, (char const   *)(par_buf.savefile), tmp___14);
  } else {
    __inline_strcpy_chk(savefile, (char const   *)(par_buf.savefile));
  }
  if (startflag == 10) {
    rephase(0);
  }
  startlat_p = reload_lattice(startflag, startfile);
  valid_longlinks = 0;
  valid_fatlinks = valid_longlinks;
  phases_in = 0;
  rephase(1);
  make_loop_table();
  make_path_table();
  return (0);
}
}
void third_neighbor(int x , int y , int z , int t , int *dirpt , int FB , int *xp ,
                    int *yp , int *zp , int *tp ) ;
void make_3n_gathers(void) 
{ 
  int i ;

  {
  i = 0;
  while (i <= 3) {
    make_gather(& third_neighbor, & i, 1, 0, 1);
    i ++;
  }
  sort_eight_neighborlists(8);
  return;
}
}
void third_neighbor(int x , int y , int z , int t , int *dirpt , int FB , int *xp ,
                    int *yp , int *zp , int *tp ) 
{ 
  int dir ;

  {
  if (FB == 1) {
    dir = *dirpt;
  } else {
    dir = 7 - *dirpt;
  }
  *xp = x;
  *yp = y;
  *zp = z;
  *tp = t;
  switch (dir) {
  case 0: 
  *xp = (x + 3) % nx;
  break;
  case 7: 
  *xp = ((x + 4 * nx) - 3) % nx;
  break;
  case 1: 
  *yp = (y + 3) % ny;
  break;
  case 6: 
  *yp = ((y + 4 * ny) - 3) % ny;
  break;
  case 2: 
  *zp = (z + 3) % nz;
  break;
  case 5: 
  *zp = ((z + 4 * nz) - 3) % nz;
  break;
  case 3: 
  *tp = (t + 3) % nt;
  break;
  case 4: 
  *tp = ((t + 4 * nt) - 3) % nt;
  break;
  default: 
  printf("third_neighb: bad direction\n");
  exit(1);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-eQzVCZKg.i","-O3")
int ks_congrad(field_offset src , field_offset dest , double mass___0 , int niter___0 ,
               double rsqmin___0 , int parity , double *final_rsq_ptr ) ;
void ranmom(void) ;
void reunitarize(void) ;
void update_h(double eps ) ;
void update_u(double eps ) ;
int update(void) 
{ 
  int step ;
  int iters ;
  double final_rsq ;
  double cg_time ;
  int tmp ;

  {
  iters = 0;
  ranmom();
  step = 1;
  while (step <= steps) {
    update_u(epsilon * (0.5 - (double )nflavors / 8.0));
    grsource_imp((field_offset )((char *)(& (lattice + 0)->phi) - (char *)(lattice + 0)),
                 mass, 2);
    cg_time = - 1.0e6;
    update_u((epsilon * (double )nflavors) / 8.0);
    tmp = ks_congrad((field_offset )((char *)(& (lattice + 0)->phi) - (char *)(lattice + 0)),
                     (field_offset )((char *)(& (lattice + 0)->xxx) - (char *)(lattice + 0)),
                     mass, niter, rsqmin, 2, & final_rsq);
    iters += tmp;
    cg_time = ((double )step - 0.5) * epsilon;
    update_h(epsilon);
    update_u(epsilon * 0.5);
    rephase(0);
    reunitarize();
    rephase(1);
    step ++;
  }
  if (steps > 0) {
    return (iters / steps);
  } else {
    return (-99);
  }
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-6KqLjdt_.i","-O3")
void dslash_fn(field_offset src , field_offset dest , int parity ) ;
void eo_fermion_force(double eps , int nflavors___0 , field_offset x_off ) ;
void imp_gauge_force(double eps , field_offset mom_off ) ;
void update_h(double eps ) 
{ 


  {
  rephase(0);
  imp_gauge_force(eps, (field_offset )((char *)(& (lattice + 0)->mom) - (char *)(lattice + 0)));
  rephase(1);
  dslash_fn((field_offset )((char *)(& (lattice + 0)->xxx) - (char *)(lattice + 0)),
            (field_offset )((char *)(& (lattice + 0)->xxx) - (char *)(lattice + 0)),
            1);
  eo_fermion_force(eps, nflavors, (field_offset )((char *)(& (lattice + 0)->xxx) - (char *)(lattice + 0)));
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Imv9cfDO.i","-O3")
void mult_su3_nn(su3_matrix *a , su3_matrix *b , su3_matrix *c ) ;
void scalar_mult_add_su3_matrix(su3_matrix *a , su3_matrix *b , double s , su3_matrix *c ) ;
void uncompress_anti_hermitian(anti_hermitmat *mat_antihermit , su3_matrix *mat_su3 ) ;
void su3mat_copy(su3_matrix *a , su3_matrix *b ) ;
void update_u(double eps ) 
{ 
  register int i ;
  register int dir ;
  register site *s ;
  su3_matrix *link ;
  su3_matrix temp1 ;
  su3_matrix temp2 ;
  su3_matrix htemp ;
  register double t2 ;
  register double t3 ;
  register double t4 ;
  register double t5 ;
  register double t6 ;

  {
  t2 = eps / 2.0;
  t3 = eps / 3.0;
  t4 = eps / 4.0;
  t5 = eps / 5.0;
  t6 = eps / 6.0;
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    dir = 0;
    while (dir <= 3) {
      uncompress_anti_hermitian(& s->mom[dir], & htemp);
      link = & s->link[dir];
      mult_su3_nn(& htemp, link, & temp1);
      scalar_mult_add_su3_matrix(link, & temp1, t6, & temp2);
      mult_su3_nn(& htemp, & temp2, & temp1);
      scalar_mult_add_su3_matrix(link, & temp1, t5, & temp2);
      mult_su3_nn(& htemp, & temp2, & temp1);
      scalar_mult_add_su3_matrix(link, & temp1, t4, & temp2);
      mult_su3_nn(& htemp, & temp2, & temp1);
      scalar_mult_add_su3_matrix(link, & temp1, t3, & temp2);
      mult_su3_nn(& htemp, & temp2, & temp1);
      scalar_mult_add_su3_matrix(link, & temp1, t2, & temp2);
      mult_su3_nn(& htemp, & temp2, & temp1);
      scalar_mult_add_su3_matrix(link, & temp1, eps, & temp2);
      su3mat_copy(& temp2, link);
      dir ++;
    }
    i ++;
    s ++;
  }
  valid_longlinks = 0;
  valid_fatlinks = 0;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Dr1eFA08.i","-O3")
void terminate(int status ) ;
int node_number(int x , int y , int z , int t ) ;
int node_index(int x , int y , int z , int t ) ;
int num_sites(int node ) ;
int squaresize[4]  ;
int nsquares[4]  ;
void setup_layout(void) 
{ 
  register int i ;
  register int j ;
  register int dir ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = mynode();
  if (tmp == 0) {
    printf("LAYOUT = Hypercubes, options = ");
    printf("EVENFIRST,");
    printf("\n");
  }
  squaresize[0] = nx;
  squaresize[1] = ny;
  squaresize[2] = nz;
  squaresize[3] = nt;
  nsquares[3] = 1;
  nsquares[2] = nsquares[3];
  nsquares[1] = nsquares[2];
  nsquares[0] = nsquares[1];
  i = 1;
  while (1) {
    tmp___1 = numnodes();
    if (! (i < tmp___1)) {
      break;
    }
    j = 1;
    dir = 0;
    while (dir <= 3) {
      if (squaresize[dir] > j) {
        if (squaresize[dir] % 2 == 0) {
          j = squaresize[dir];
        }
      }
      dir ++;
    }
    dir = 0;
    while (dir <= 3) {
      if (squaresize[dir] == j) {
        if (nsquares[dir] > 1) {
          break;
        }
      }
      dir ++;
    }
    if (dir > 3) {
      dir = 0;
      while (dir <= 3) {
        if (squaresize[dir] == j) {
          break;
        }
        dir ++;
      }
    }
    if (dir > 3) {
      tmp___0 = mynode();
      if (tmp___0 == 0) {
        printf("LAYOUT: Can\'t lay out this lattice, not enough factors of 2\n");
      }
      terminate(1);
    }
    i *= 2;
    squaresize[dir] /= 2;
    nsquares[dir] *= 2;
  }
  sites_on_node = ((squaresize[0] * squaresize[1]) * squaresize[2]) * squaresize[3];
  tmp___2 = mynode();
  if (tmp___2 == 0) {
    if (sites_on_node % 2 != 0) {
      printf("SORRY, CAN\'T LAY OUT THIS LATTICE\n");
      terminate(0);
    }
  }
  odd_sites_on_node = sites_on_node / 2;
  even_sites_on_node = odd_sites_on_node;
  return;
}
}
int node_number(int x , int y , int z , int t ) 
{ 
  register int i ;

  {
  x /= squaresize[0];
  y /= squaresize[1];
  z /= squaresize[2];
  t /= squaresize[3];
  i = x + nsquares[0] * (y + nsquares[1] * (z + nsquares[2] * t));
  return (i);
}
}
int node_index(int x , int y , int z , int t ) 
{ 
  register int i ;
  register int xr ;
  register int yr ;
  register int zr ;
  register int tr ;

  {
  xr = x % squaresize[0];
  yr = y % squaresize[1];
  zr = z % squaresize[2];
  tr = t % squaresize[3];
  i = xr + squaresize[0] * (yr + squaresize[1] * (zr + squaresize[2] * tr));
  if ((((x + y) + z) + t) % 2 == 0) {
    return (i / 2);
  } else {
    return ((i + sites_on_node) / 2);
  }
}
}
int num_sites(int node ) 
{ 


  {
  return (sites_on_node);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-aWSLEJD_.i","-O3")
extern double fabs(double  ) ;
extern double sqrt(double  ) ;
double check_unitarity(void) ;
double check_su3(su3_matrix *c ) ;
double check_unitarity(void) 
{ 
  register int i ;
  register int dir ;
  int ii ;
  int jj ;
  register site *s ;
  register su3_matrix *mat ;
  double deviation ;
  double max_deviation___0 ;
  double av_deviation___0 ;
  union __anonunion_ifval_38 ifval ;
  int tmp ;
  int tmp___0 ;

  {
  av_deviation___0 = (double )0;
  max_deviation___0 = av_deviation___0;
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    dir = 0;
    while (dir <= 3) {
      mat = & s->link[dir];
      deviation = check_su3(mat);
      if (deviation > 0.0001) {
        tmp = mynode();
        printf("Unitarity problem on node %d, site %d, dir %d, deviation=%f\n", tmp,
               i, dir, deviation);
        printf("SU3 matrix:\n");
        ii = 0;
        while (ii <= 2) {
          jj = 0;
          while (jj <= 2) {
            printf("%f ", mat->e[ii][jj].real);
            printf("%f ", mat->e[ii][jj].imag);
            jj ++;
          }
          printf("\n");
          ii ++;
        }
        printf("repeat in hex:\n");
        ii = 0;
        while (ii <= 2) {
          jj = 0;
          while (jj <= 2) {
            ifval.fval = mat->e[ii][jj].real;
            printf("%08x ", ifval.ival);
            ifval.fval = mat->e[ii][jj].imag;
            printf("%08x ", ifval.ival);
            jj ++;
          }
          printf("\n");
          ii ++;
        }
        printf("  \n \n");
        fflush(__stdoutp);
        terminate(1);
      }
      if (max_deviation___0 < deviation) {
        max_deviation___0 = deviation;
      }
      av_deviation___0 += deviation * deviation;
      dir ++;
    }
    i ++;
    s ++;
  }
  av_deviation___0 = sqrt(av_deviation___0 / (double )(4 * i));
  if (max_deviation___0 > 0.0001) {
    tmp___0 = mynode();
    printf("Unitarity problem on node %d, maximum deviation=%f\n", tmp___0, max_deviation___0);
  }
  return (max_deviation___0);
}
}
double check_su3(su3_matrix *c ) 
{ 
  register double ar ;
  register double ai ;
  register double ari ;
  register double max ;
  register int i ;
  double tmp ;

  {
  i = 0;
  max = 0.;
  while (i < 3) {
    ar = ((((c->e[i][0].real * c->e[i][0].real + c->e[i][0].imag * c->e[i][0].imag) + c->e[i][1].real * c->e[i][1].real) + c->e[i][1].imag * c->e[i][1].imag) + c->e[i][2].real * c->e[i][2].real) + c->e[i][2].imag * c->e[i][2].imag;
    tmp = sqrt(ar);
    ar = fabs(tmp - 1.);
    if (max < ar) {
      max = ar;
    }
    i ++;
  }
  ar = ((((c->e[0][0].real * c->e[1][0].real + c->e[0][0].imag * c->e[1][0].imag) + c->e[0][1].real * c->e[1][1].real) + c->e[0][1].imag * c->e[1][1].imag) + c->e[0][2].real * c->e[1][2].real) + c->e[0][2].imag * c->e[1][2].imag;
  ai = ((((c->e[0][0].real * c->e[1][0].imag - c->e[0][0].imag * c->e[1][0].real) + c->e[0][1].real * c->e[1][1].imag) - c->e[0][1].imag * c->e[1][1].real) + c->e[0][2].real * c->e[1][2].imag) - c->e[0][2].imag * c->e[1][2].real;
  ari = sqrt(ar * ar + ai * ai);
  if (max < ari) {
    max = ari;
  }
  ar = ((((c->e[0][0].real * c->e[2][0].real + c->e[0][0].imag * c->e[2][0].imag) + c->e[0][1].real * c->e[2][1].real) + c->e[0][1].imag * c->e[2][1].imag) + c->e[0][2].real * c->e[2][2].real) + c->e[0][2].imag * c->e[2][2].imag;
  ai = ((((c->e[0][0].real * c->e[2][0].imag - c->e[0][0].imag * c->e[2][0].real) + c->e[0][1].real * c->e[2][1].imag) - c->e[0][1].imag * c->e[2][1].real) + c->e[0][2].real * c->e[2][2].imag) - c->e[0][2].imag * c->e[2][2].real;
  ari = sqrt(ar * ar + ai * ai);
  if (max < ari) {
    max = ari;
  }
  ar = ((((c->e[1][0].real * c->e[2][0].real + c->e[1][0].imag * c->e[2][0].imag) + c->e[1][1].real * c->e[2][1].real) + c->e[1][1].imag * c->e[2][1].imag) + c->e[1][2].real * c->e[2][2].real) + c->e[1][2].imag * c->e[2][2].imag;
  ai = ((((c->e[1][0].real * c->e[2][0].imag - c->e[1][0].imag * c->e[2][0].real) + c->e[1][1].real * c->e[2][1].imag) - c->e[1][1].imag * c->e[2][1].real) + c->e[1][2].real * c->e[2][2].imag) - c->e[1][2].imag * c->e[2][2].real;
  ari = sqrt(ar * ar + ai * ai);
  if (max < ari) {
    max = ari;
  }
  return (max);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-COotD4IA.i","-O3")
extern void *calloc(size_t  , size_t  ) ;
extern void free(void * ) ;
void mult_su3_an(su3_matrix *a , su3_matrix *b , su3_matrix *c ) ;
double realtrace_su3(su3_matrix *a , su3_matrix *b ) ;
msg_tag *start_gather(field_offset field , int size , int index___0 , int parity ,
                      char **dest ) ;
void wait_gather(msg_tag *mbuf ) ;
void cleanup_gather(msg_tag *mbuf ) ;
void d_plaquette(double *ss_plaq , double *st_plaq ) ;
void d_plaquette(double *ss_plaq , double *st_plaq ) 
{ 
  su3_matrix *su3mat ;
  register int i ;
  register int dir1 ;
  register int dir2 ;
  register site *s ;
  register su3_matrix *m1 ;
  register su3_matrix *m4 ;
  su3_matrix mtmp ;
  double ss_sum ;
  double st_sum ;
  msg_tag *mtag0 ;
  msg_tag *mtag1 ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  st_sum = 0.0;
  ss_sum = st_sum;
  tmp = calloc((size_t )sites_on_node, sizeof(su3_matrix ));
  su3mat = (su3_matrix *)tmp;
  if ((unsigned long )su3mat == (unsigned long )((void *)0)) {
    printf("plaquette: can\'t malloc su3mat\n");
    fflush(__stdoutp);
    terminate(1);
  }
  dir1 = 1;
  while (dir1 <= 3) {
    dir2 = 0;
    while (dir2 < dir1) {
      mtag0 = start_gather((field_offset )((char *)(& (lattice + 0)->link[dir2]) - (char *)(lattice + 0)),
                           (int )sizeof(su3_matrix ), dir1, 3, gen_pt[0]);
      mtag1 = start_gather((field_offset )((char *)(& (lattice + 0)->link[dir1]) - (char *)(lattice + 0)),
                           (int )sizeof(su3_matrix ), dir2, 3, gen_pt[1]);
      i = 0;
      s = lattice;
      while (i < sites_on_node) {
        m1 = & s->link[dir1];
        m4 = & s->link[dir2];
        mult_su3_an(m4, m1, su3mat + i);
        i ++;
        s ++;
      }
      wait_gather(mtag0);
      wait_gather(mtag1);
      i = 0;
      s = lattice;
      while (i < sites_on_node) {
        mult_su3_nn(su3mat + i, (su3_matrix *)*(gen_pt[0] + i), & mtmp);
        if (dir1 == 3) {
          tmp___0 = realtrace_su3((su3_matrix *)*(gen_pt[1] + i), & mtmp);
          st_sum += tmp___0;
        } else {
          tmp___1 = realtrace_su3((su3_matrix *)*(gen_pt[1] + i), & mtmp);
          ss_sum += tmp___1;
        }
        i ++;
        s ++;
      }
      cleanup_gather(mtag0);
      cleanup_gather(mtag1);
      dir2 ++;
    }
    dir1 ++;
  }
  g_doublesum(& ss_sum);
  g_doublesum(& st_sum);
  *ss_plaq = ss_sum / (double )((((3 * nx) * ny) * nz) * nt);
  *st_plaq = st_sum / (double )((((3 * nx) * ny) * nz) * nt);
  free((void *)su3mat);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-QmU_2i76.i","-O3")
complex cmplx(double x , double y ) ;
complex trace_su3(su3_matrix *a ) ;
void add_su3_matrix(su3_matrix *a , su3_matrix *b , su3_matrix *c ) ;
void sub_su3_matrix(su3_matrix *a , su3_matrix *b , su3_matrix *c ) ;
void make_anti_hermitian(su3_matrix *m3 , anti_hermitmat *ah3 ) ;
void clear_su3mat(su3_matrix *dest ) ;
void clearvec(su3_vector *v ) ;
void left_su2_hit_n(su2_matrix *u , int p , int q , su3_matrix *link ) ;
void right_su2_hit_a(su2_matrix *u , int p , int q , su3_matrix *link ) ;
void mult_su2_mat_vec_elem_n(su2_matrix *u , complex *x0 , complex *x1 ) ;
msg_tag *start_gather_from_temp(void *field , int size , int index___0 , int parity ,
                                char **dest ) ;
void gaugefix(int gauge_dir , double relax_boost , int max_gauge_iter , double gauge_fix_tol ,
              field_offset diffmat , field_offset sumvec , int nvector , field_offset *vector_offset ,
              int *vector_parity , int nantiherm , field_offset *antiherm_offset ,
              int *antiherm_parity ) ;
su3_matrix *diffmatp  ;
su3_vector *sumvecp  ;
field_offset diffmat_offset  ;
field_offset sumvec_offset  ;
void accum_gauge_hit(int gauge_dir , int parity ) 
{ 
  register int j ;
  register su3_matrix *m1 ;
  register su3_matrix *m2 ;
  register int dir ;
  register int i ;
  register site *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (1) {
    if (parity == 2) {
      tmp = even_sites_on_node;
    } else {
      tmp = sites_on_node;
    }
    if (! (i < tmp)) {
      break;
    }
    if (diffmat_offset >= 0) {
      clear_su3mat((su3_matrix *)((char *)s + diffmat_offset));
    } else {
      clear_su3mat(diffmatp + i);
    }
    if (sumvec_offset >= 0) {
      clearvec((su3_vector *)((char *)s + sumvec_offset));
    } else {
      clearvec(sumvecp + i);
    }
    i ++;
    s ++;
  }
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (1) {
    if (parity == 2) {
      tmp___0 = even_sites_on_node;
    } else {
      tmp___0 = sites_on_node;
    }
    if (! (i < tmp___0)) {
      break;
    }
    dir = 0;
    while (dir <= 3) {
      if (dir != gauge_dir) {
        m1 = & s->link[dir];
        if (diffmat_offset >= 0) {
          sub_su3_matrix((su3_matrix *)((char *)s + diffmat_offset), m1, (su3_matrix *)((char *)s + diffmat_offset));
        } else {
          sub_su3_matrix(diffmatp + i, m1, diffmatp + i);
        }
        if (sumvec_offset >= 0) {
          j = 0;
          while (j < 3) {
            ((su3_vector *)((char *)s + sumvec_offset))->c[j].real += m1->e[j][j].real;
            ((su3_vector *)((char *)s + sumvec_offset))->c[j].imag += m1->e[j][j].imag;
            j ++;
          }
        } else {
          j = 0;
          while (j < 3) {
            (sumvecp + i)->c[j].real += m1->e[j][j].real;
            (sumvecp + i)->c[j].imag += m1->e[j][j].imag;
            j ++;
          }
        }
      }
      dir ++;
    }
    i ++;
    s ++;
  }
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (1) {
    if (parity == 2) {
      tmp___1 = even_sites_on_node;
    } else {
      tmp___1 = sites_on_node;
    }
    if (! (i < tmp___1)) {
      break;
    }
    dir = 0;
    while (dir <= 3) {
      if (dir != gauge_dir) {
        m2 = (su3_matrix *)*(gen_pt[dir] + i);
        if (diffmat_offset >= 0) {
          add_su3_matrix((su3_matrix *)((char *)s + diffmat_offset), m2, (su3_matrix *)((char *)s + diffmat_offset));
        } else {
          add_su3_matrix(diffmatp + i, m2, diffmatp + i);
        }
        if (sumvec_offset >= 0) {
          j = 0;
          while (j < 3) {
            ((su3_vector *)((char *)s + sumvec_offset))->c[j].real += m2->e[j][j].real;
            ((su3_vector *)((char *)s + sumvec_offset))->c[j].imag += m2->e[j][j].imag;
            j ++;
          }
        } else {
          j = 0;
          while (j < 3) {
            (sumvecp + i)->c[j].real += m2->e[j][j].real;
            (sumvecp + i)->c[j].imag += m2->e[j][j].imag;
            j ++;
          }
        }
      }
      dir ++;
    }
    i ++;
    s ++;
  }
  return;
}
}
void do_hit(int gauge_dir , int parity , int p , int q , double relax_boost , int nvector ,
            field_offset *vector_offset , int *vector_parity , int nantiherm , field_offset *antiherm_offset ,
            int *antiherm_parity ) 
{ 
  double a0 ;
  double a1 ;
  double a2 ;
  double a3 ;
  double asq ;
  double a0sq ;
  double x ;
  double r ;
  double xdr ;
  register int dir ;
  register int i ;
  register int j ;
  register site *s ;
  su2_matrix u ;
  su3_matrix htemp ;
  int tmp ;

  {
  accum_gauge_hit(gauge_dir, parity);
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (1) {
    if (parity == 2) {
      tmp = even_sites_on_node;
    } else {
      tmp = sites_on_node;
    }
    if (! (i < tmp)) {
      break;
    }
    if (sumvec_offset >= 0) {
      a0 = ((su3_vector *)((char *)s + sumvec_offset))->c[p].real + ((su3_vector *)((char *)s + sumvec_offset))->c[q].real;
    } else {
      a0 = (sumvecp + i)->c[p].real + (sumvecp + i)->c[q].real;
    }
    if (diffmat_offset >= 0) {
      a1 = ((su3_matrix *)((char *)s + diffmat_offset))->e[q][p].imag + ((su3_matrix *)((char *)s + diffmat_offset))->e[p][q].imag;
      a2 = - ((su3_matrix *)((char *)s + diffmat_offset))->e[q][p].real + ((su3_matrix *)((char *)s + diffmat_offset))->e[p][q].real;
      a3 = ((su3_matrix *)((char *)s + diffmat_offset))->e[p][p].imag - ((su3_matrix *)((char *)s + diffmat_offset))->e[q][q].imag;
    } else {
      a1 = (diffmatp + i)->e[q][p].imag + (diffmatp + i)->e[p][q].imag;
      a2 = - (diffmatp + i)->e[q][p].real + (diffmatp + i)->e[p][q].real;
      a3 = (diffmatp + i)->e[p][p].imag - (diffmatp + i)->e[q][q].imag;
    }
    asq = (a1 * a1 + a2 * a2) + a3 * a3;
    a0sq = a0 * a0;
    x = (relax_boost * a0sq + asq) / (a0sq + asq);
    r = sqrt(a0sq + (x * x) * asq);
    xdr = x / r;
    a0 /= r;
    a1 *= xdr;
    a2 *= xdr;
    a3 *= xdr;
    u.e[0][0] = cmplx(a0, a3);
    u.e[0][1] = cmplx(a2, a1);
    u.e[1][0] = cmplx(- a2, a1);
    u.e[1][1] = cmplx(a0, - a3);
    dir = 0;
    while (dir <= 3) {
      left_su2_hit_n(& u, p, q, & s->link[dir]);
      dir ++;
    }
    dir = 0;
    while (dir <= 3) {
      right_su2_hit_a(& u, p, q, (su3_matrix *)*(gen_pt[dir] + i));
      dir ++;
    }
    j = 0;
    while (j < nvector) {
      if (*(vector_parity + j) == 3) {
        mult_su2_mat_vec_elem_n(& u, & ((su3_vector *)((char *)s + *(vector_offset + j)))->c[p],
                                & ((su3_vector *)((char *)s + *(vector_offset + j)))->c[q]);
      } else
      if (*(vector_parity + j) == parity) {
        mult_su2_mat_vec_elem_n(& u, & ((su3_vector *)((char *)s + *(vector_offset + j)))->c[p],
                                & ((su3_vector *)((char *)s + *(vector_offset + j)))->c[q]);
      }
      j ++;
    }
    j = 0;
    while (j < nantiherm) {
      if (*(antiherm_parity + j) == 3) {
        uncompress_anti_hermitian((anti_hermitmat *)((char *)s + *(antiherm_offset + j)),
                                  & htemp);
        left_su2_hit_n(& u, p, q, & htemp);
        right_su2_hit_a(& u, p, q, & htemp);
        make_anti_hermitian(& htemp, (anti_hermitmat *)((char *)s + *(antiherm_offset + j)));
      } else
      if (*(antiherm_parity + j) == parity) {
        uncompress_anti_hermitian((anti_hermitmat *)((char *)s + *(antiherm_offset + j)),
                                  & htemp);
        left_su2_hit_n(& u, p, q, & htemp);
        right_su2_hit_a(& u, p, q, & htemp);
        make_anti_hermitian(& htemp, (anti_hermitmat *)((char *)s + *(antiherm_offset + j)));
      }
      j ++;
    }
    i ++;
    s ++;
  }
  return;
}
}
double get_gauge_fix_action(int gauge_dir , int parity ) 
{ 
  register int dir ;
  register int i ;
  register int ndir ;
  register site *s ;
  register su3_matrix *m1 ;
  register su3_matrix *m2 ;
  double gauge_fix_action ;
  complex trace ;
  int tmp ;

  {
  gauge_fix_action = 0.0;
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (1) {
    if (parity == 2) {
      tmp = even_sites_on_node;
    } else {
      tmp = sites_on_node;
    }
    if (! (i < tmp)) {
      break;
    }
    dir = 0;
    while (dir <= 3) {
      if (dir != gauge_dir) {
        m1 = & s->link[dir];
        m2 = (su3_matrix *)*(gen_pt[dir] + i);
        trace = trace_su3(m1);
        gauge_fix_action += trace.real;
        trace = trace_su3(m2);
        gauge_fix_action += trace.real;
      }
      dir ++;
    }
    i ++;
    s ++;
  }
  ndir = 0;
  dir = 0;
  while (dir <= 3) {
    if (dir != gauge_dir) {
      ndir ++;
    }
    dir ++;
  }
  g_doublesum(& gauge_fix_action);
  return (gauge_fix_action / (double )(((((6 * ndir) * nx) * ny) * nz) * nt));
}
}
void gaugefixstep(int gauge_dir , double *av_gauge_fix_action , double relax_boost ,
                  int nvector , field_offset *vector_offset , int *vector_parity ,
                  int nantiherm , field_offset *antiherm_offset , int *antiherm_parity ) 
{ 
  int parity ;
  msg_tag *mtag[8] ;
  double gauge_fix_action ;
  register int dir ;
  register int i ;
  register site *s ;
  int tmp ;
  int tmp___0 ;

  {
  *av_gauge_fix_action = 0.;
  g_sync();
  fflush(__stdoutp);
  parity = 1;
  while (parity <= 2) {
    dir = 0;
    while (dir <= 3) {
      mtag[dir] = start_gather((field_offset )((char *)(& (lattice + 0)->link[dir]) - (char *)(lattice + 0)),
                               (int )sizeof(su3_matrix ), 7 - dir, parity, gen_pt[dir]);
      dir ++;
    }
    dir = 0;
    while (dir <= 3) {
      wait_gather(mtag[dir]);
      dir ++;
    }
    gauge_fix_action = get_gauge_fix_action(gauge_dir, parity);
    do_hit(gauge_dir, parity, 0, 1, relax_boost, nvector, vector_offset, vector_parity,
           nantiherm, antiherm_offset, antiherm_parity);
    do_hit(gauge_dir, parity, 1, 2, relax_boost, nvector, vector_offset, vector_parity,
           nantiherm, antiherm_offset, antiherm_parity);
    do_hit(gauge_dir, parity, 2, 0, relax_boost, nvector, vector_offset, vector_parity,
           nantiherm, antiherm_offset, antiherm_parity);
    gauge_fix_action = get_gauge_fix_action(gauge_dir, parity);
    *av_gauge_fix_action += gauge_fix_action;
    dir = 0;
    while (dir <= 3) {
      g_sync();
      if (parity == 1) {
        i = even_sites_on_node;
      } else {
        i = 0;
      }
      s = lattice + i;
      while (1) {
        if (parity == 2) {
          tmp = even_sites_on_node;
        } else {
          tmp = sites_on_node;
        }
        if (! (i < tmp)) {
          break;
        }
        if (diffmat_offset >= 0) {
          su3mat_copy((su3_matrix *)*(gen_pt[dir] + i), (su3_matrix *)((char *)s + diffmat_offset));
        } else {
          su3mat_copy((su3_matrix *)*(gen_pt[dir] + i), diffmatp + i);
        }
        i ++;
        s ++;
      }
      cleanup_gather(mtag[dir]);
      g_sync();
      if (diffmat_offset >= 0) {
        mtag[dir] = start_gather(diffmat_offset, (int )sizeof(su3_matrix ), dir, 3 ^ parity,
                                 gen_pt[dir]);
      } else {
        mtag[dir] = start_gather_from_temp((void *)diffmatp, (int )sizeof(su3_matrix ),
                                           dir, 3 ^ parity, gen_pt[dir]);
      }
      wait_gather(mtag[dir]);
      if ((3 ^ parity) == 1) {
        i = even_sites_on_node;
      } else {
        i = 0;
      }
      s = lattice + i;
      while (1) {
        if ((3 ^ parity) == 2) {
          tmp___0 = even_sites_on_node;
        } else {
          tmp___0 = sites_on_node;
        }
        if (! (i < tmp___0)) {
          break;
        }
        su3mat_copy((su3_matrix *)*(gen_pt[dir] + i), & s->link[dir]);
        i ++;
        s ++;
      }
      cleanup_gather(mtag[dir]);
      dir ++;
    }
    parity ++;
  }
  return;
}
}
void gaugefixscratch(field_offset diffmat , field_offset sumvec ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  diffmat_offset = diffmat;
  diffmatp = (su3_matrix *)((void *)0);
  if (diffmat_offset < 0) {
    tmp = calloc((size_t )sites_on_node, sizeof(su3_matrix ));
    diffmatp = (su3_matrix *)tmp;
    if ((unsigned long )diffmatp == (unsigned long )((void *)0)) {
      if (this_node == 0) {
        printf("gaugefix: Can\'t malloc diffmat\n");
      }
      fflush(__stdoutp);
      terminate(1);
    }
  }
  sumvec_offset = sumvec;
  sumvecp = (su3_vector *)((void *)0);
  if (sumvec_offset < 0) {
    tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    sumvecp = (su3_vector *)tmp___0;
    if ((unsigned long )sumvecp == (unsigned long )((void *)0)) {
      if (this_node == 0) {
        printf("gaugefix: Can\'t malloc sumvec\n");
      }
      fflush(__stdoutp);
      terminate(1);
    }
  }
  return;
}
}
void gaugefix(int gauge_dir , double relax_boost , int max_gauge_iter , double gauge_fix_tol ,
              field_offset diffmat , field_offset sumvec , int nvector , field_offset *vector_offset ,
              int *vector_parity , int nantiherm , field_offset *antiherm_offset ,
              int *antiherm_parity ) 
{ 
  int gauge_iter ;
  double current_av ;
  double old_av ;
  double del_av ;
  double tmp ;

  {
  gaugefixscratch(diffmat, sumvec);
  gauge_iter = 0;
  while (gauge_iter < max_gauge_iter) {
    gaugefixstep(gauge_dir, & current_av, relax_boost, nvector, vector_offset, vector_parity,
                 nantiherm, antiherm_offset, antiherm_parity);
    if (gauge_iter != 0) {
      del_av = current_av - old_av;
      tmp = fabs(del_av);
      if (tmp < gauge_fix_tol) {
        break;
      }
    }
    old_av = current_av;
    if (gauge_iter % 20 == 19) {
      reunitarize();
    }
    gauge_iter ++;
  }
  if (gauge_iter % 20 != 0) {
    reunitarize();
  }
  if (diffmat_offset < 0) {
    free((void *)diffmatp);
  }
  if (sumvec_offset < 0) {
    free((void *)sumvecp);
  }
  if (this_node == 0) {
    printf("GFIX: Ended at step %d. Av gf action %.8e, delta %.3e\n", gauge_iter,
           current_av, del_av);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-alt_ofLu.i","-O3")
extern int ( /* format attribute */  scanf)(char const   *  , ...) ;
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
gauge_file *restore_ascii(char *filename ) ;
gauge_file *save_ascii(char *filename ) ;
gauge_file *restore_serial(char *filename ) ;
gauge_file *save_serial(char *filename ) ;
gauge_file *restore_parallel(char *filename ) ;
gauge_file *save_parallel(char *filename ) ;
gauge_file *save_checkpoint(char *filename ) ;
gauge_file *save_serial_archive(char *filename ) ;
gauge_file *save_parallel_archive(char *filename ) ;
void coldlat(void) ;
void funnylat(void) ;
int get_s(int prompt , char *variable_name_string , char *value ) ;
void g_doublemax(double *dpt ) ;
extern int strcmp(char const   * , char const   * ) ;
gauge_file *save_lattice(int flag , char *filename ) 
{ 
  double dtime ;
  gauge_file *gf___0 ;
  double ssplaq ;
  double stplaq ;
  double tmp ;
  double tmp___0 ;

  {
  tmp = dclock();
  dtime = - tmp;
  switch (flag) {
  case 20: 
  gf___0 = (gauge_file *)((void *)0);
  break;
  case 21: 
  gf___0 = save_ascii(filename);
  break;
  case 22: 
  gf___0 = save_serial(filename);
  break;
  case 28: 
  gf___0 = save_parallel(filename);
  break;
  case 23: 
  gf___0 = save_checkpoint(filename);
  break;
  case 30: 
  gf___0 = save_serial_archive(filename);
  break;
  case 31: 
  gf___0 = save_parallel_archive(filename);
  break;
  default: 
  printf("save_lattice: ERROR: unknown type for saving lattice\n");
  terminate(1);
  }
  tmp___0 = dclock();
  dtime += tmp___0;
  if (flag != 20) {
    if (this_node == 0) {
      printf("Time to save = %e\n", dtime);
    }
  }
  d_plaquette(& ssplaq, & stplaq);
  if (this_node == 0) {
    printf("CHECK PLAQ: %e %e\n", ssplaq, stplaq);
  }
  return (gf___0);
}
}
gauge_file *reload_lattice(int flag , char *filename ) 
{ 
  double dtime ;
  gauge_file *gf___0 ;
  double ssplaq ;
  double stplaq ;
  double max_deviation___0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  tmp = dclock();
  dtime = - tmp;
  switch (flag) {
  case 10: 
  gf___0 = (gauge_file *)((void *)0);
  break;
  case 11: 
  coldlat();
  gf___0 = (gauge_file *)((void *)0);
  break;
  case 12: 
  gf___0 = restore_ascii(filename);
  break;
  case 13: 
  gf___0 = restore_serial(filename);
  break;
  case 19: 
  gf___0 = restore_parallel(filename);
  break;
  default: 
  if (this_node == 0) {
    printf("reload_lattice: Bad startflag %d\n", flag);
  }
  terminate(1);
  }
  tmp___0 = dclock();
  dtime += tmp___0;
  if (flag != 11) {
    if (flag != 10) {
      if (this_node == 0) {
        printf("Time to reload gauge configuration = %e\n", dtime);
      }
    }
  }
  d_plaquette(& ssplaq, & stplaq);
  if (this_node == 0) {
    printf("CHECK PLAQ: %e %e\n", ssplaq, stplaq);
    fflush(__stdoutp);
  }
  tmp___1 = dclock();
  dtime = - tmp___1;
  max_deviation___0 = check_unitarity();
  g_doublemax(& max_deviation___0);
  tmp___2 = dclock();
  dtime += tmp___2;
  if (this_node == 0) {
    printf("Unitarity checked.  Max deviation %.2e\n", max_deviation___0);
  }
  fflush(__stdoutp);
  return (gf___0);
}
}
int ask_starting_lattice(int prompt , int *flag , char *filename ) 
{ 
  char savebuf[256] ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (prompt != 0) {
    printf("enter \'continue\', \'fresh\', \'reload_ascii\', \'reload_serial\', or \'reload_parallel\'\n");
  }
  status = scanf("%s", savebuf);
  if (status != 1) {
    printf("ask_starting_lattice: ERROR IN INPUT: starting lattice command\n");
    return (1);
  }
  printf("%s ", savebuf);
  tmp___3 = strcmp("fresh", (char const   *)(savebuf));
  if (tmp___3 == 0) {
    *flag = 11;
    printf("\n");
  } else {
    tmp___2 = strcmp("continue", (char const   *)(savebuf));
    if (tmp___2 == 0) {
      *flag = 10;
      printf("\n");
    } else {
      tmp___1 = strcmp("reload_ascii", (char const   *)(savebuf));
      if (tmp___1 == 0) {
        *flag = 12;
      } else {
        tmp___0 = strcmp("reload_serial", (char const   *)(savebuf));
        if (tmp___0 == 0) {
          *flag = 13;
        } else {
          tmp = strcmp("reload_parallel", (char const   *)(savebuf));
          if (tmp == 0) {
            *flag = 19;
          } else {
            printf("ask_starting_lattice: ERROR IN INPUT: lattice_command %s is invalid\n",
                   savebuf);
            return (1);
          }
        }
      }
    }
  }
  if (*flag != 11) {
    if (*flag != 10) {
      if (prompt != 0) {
        printf("enter name of file containing lattice\n");
      }
      status = scanf("%s", filename);
      if (status != 1) {
        printf("ask_starting_lattice: ERROR IN INPUT: file name read\n");
        return (1);
      }
      printf("%s\n", filename);
    }
  }
  return (0);
}
}
int ask_ending_lattice(int prompt , int *flag , char *filename ) 
{ 
  char savebuf[256] ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (prompt != 0) {
    printf("\'forget\' lattice at end,  \'save_ascii\', \'save_serial\', \'save_parallel\', \'save_checkpoint\', \'save_serial_archive\', or \'save_parallel_archive\'\n");
  }
  status = scanf("%s", savebuf);
  if (status != 1) {
    printf("ask_ending_lattice: ERROR IN INPUT: ending lattice command\n");
    return (1);
  }
  printf("%s ", savebuf);
  tmp___5 = strcmp("save_ascii", (char const   *)(savebuf));
  if (tmp___5 == 0) {
    *flag = 21;
  } else {
    tmp___4 = strcmp("save_serial", (char const   *)(savebuf));
    if (tmp___4 == 0) {
      *flag = 22;
    } else {
      tmp___3 = strcmp("save_parallel", (char const   *)(savebuf));
      if (tmp___3 == 0) {
        *flag = 28;
      } else {
        tmp___2 = strcmp("save_checkpoint", (char const   *)(savebuf));
        if (tmp___2 == 0) {
          *flag = 23;
        } else {
          tmp___1 = strcmp("save_serial_archive", (char const   *)(savebuf));
          if (tmp___1 == 0) {
            *flag = 30;
          } else {
            tmp___0 = strcmp("save_parallel_archive", (char const   *)(savebuf));
            if (tmp___0 == 0) {
              *flag = 31;
            } else {
              tmp = strcmp("forget", (char const   *)(savebuf));
              if (tmp == 0) {
                *flag = 20;
                printf("\n");
              } else {
                printf("ask_ending_lattice: ERROR IN INPUT: %s is not a save lattice command\n",
                       savebuf);
                return (1);
              }
            }
          }
        }
      }
    }
  }
  if (*flag != 20) {
    if (prompt != 0) {
      printf("enter filename\n");
    }
    status = scanf("%s", filename);
    if (status != 1) {
      printf("ask_ending_lattice: ERROR IN INPUT: save filename\n");
      return (1);
    }
    printf("%s\n", filename);
  }
  return (0);
}
}
void coldlat(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int dir ;
  register site *sit ;

  {
  i = 0;
  sit = lattice;
  while (i < sites_on_node) {
    dir = 0;
    while (dir <= 3) {
      j = 0;
      while (j < 3) {
        k = 0;
        while (k < 3) {
          if (j != k) {
            sit->link[dir].e[j][k] = cmplx(0.0, 0.0);
          } else {
            sit->link[dir].e[j][k] = cmplx(1.0, 0.0);
          }
          k ++;
        }
        j ++;
      }
      dir ++;
    }
    i ++;
    sit ++;
  }
  if (this_node == 0) {
    printf("unit gauge configuration loaded\n");
  }
  return;
}
}
void funnylat(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int dir ;
  register site *sit ;

  {
  i = 0;
  sit = lattice;
  while (i < sites_on_node) {
    dir = 0;
    while (dir <= 3) {
      j = 0;
      while (j < 3) {
        k = 0;
        while (k < 3) {
          sit->link[dir].e[j][k] = cmplx(0.0, 0.0);
          k ++;
        }
        j ++;
      }
      sit->link[dir].e[0][0].real = (double )dir;
      sit->link[dir].e[1][1].real = (double )(10 * (int )sit->x);
      sit->link[dir].e[2][2].real = (double )(100 * (int )sit->y);
      sit->link[dir].e[0][0].imag = (double )dir;
      sit->link[dir].e[1][1].imag = (double )(10 * (int )sit->z);
      sit->link[dir].e[2][2].imag = (double )(100 * (int )sit->t);
      dir ++;
    }
    i ++;
    sit ++;
  }
  return;
}
}
int get_f(int prompt , char *variable_name_string , double *value ) 
{ 
  int s ;
  char checkname[80] ;
  int tmp ;

  {
  if (prompt) {
    s = 0;
    while (s != 1) {
      printf("enter %s ", variable_name_string);
      scanf("%s", checkname);
      s = sscanf((char const   *)(checkname), "%lf", value);
      if (s == 1) {
        printf("%s %g\n", variable_name_string, *value);
      } else {
        printf("Data format error.\n");
      }
    }
  } else {
    s = scanf("%s", checkname);
    if (s == -1) {
      printf("get_f: EOF on STDIN while expecting %s.\n", variable_name_string);
      return (1);
    } else
    if (s == 0) {
      printf("get_f: Format error looking for %s\n", variable_name_string);
      return (1);
    } else {
      tmp = strcmp((char const   *)(checkname), (char const   *)variable_name_string);
      if (tmp != 0) {
        printf("get_f: ERROR IN INPUT: expected %s but found %s\n", variable_name_string,
               checkname);
        return (1);
      }
    }
    printf("%s ", variable_name_string);
    s = scanf("%lf", value);
    if (s == -1) {
      printf("\nget_f: Expecting value for %s but found EOF.\n", variable_name_string);
      return (1);
    } else
    if (s == 0) {
      printf("\nget_f: Format error reading value for %s\n", variable_name_string);
      return (1);
    }
    printf("%g\n", *value);
  }
  return (0);
}
}
int get_i(int prompt , char *variable_name_string , int *value ) 
{ 
  int s ;
  char checkname[80] ;
  int tmp ;

  {
  if (prompt) {
    s = 0;
    while (s != 1) {
      printf("enter %s ", variable_name_string);
      scanf("%s", checkname);
      s = sscanf((char const   *)(checkname), "%d", value);
      if (s == 1) {
        printf("%s %d\n", variable_name_string, *value);
      } else {
        printf("Data format error.\n");
      }
    }
  } else {
    s = scanf("%s", checkname);
    if (s == -1) {
      printf("get_i: EOF on STDIN while expecting %s.\n", variable_name_string);
      return (1);
    } else
    if (s == 0) {
      printf("get_i: Format error looking for %s\n", variable_name_string);
      return (1);
    } else {
      tmp = strcmp((char const   *)(checkname), (char const   *)variable_name_string);
      if (tmp != 0) {
        printf("get_i: ERROR IN INPUT: expected %s but found %s\n", variable_name_string,
               checkname);
        return (1);
      }
    }
    printf("%s ", variable_name_string);
    s = scanf("%d", value);
    if (s == -1) {
      printf("\nget_i: Expecting value for %s but found EOF.\n", variable_name_string);
      return (1);
    } else
    if (s == 0) {
      printf("\nget_i: Format error reading value for %s\n", variable_name_string);
      return (1);
    }
    printf("%d\n", *value);
  }
  return (0);
}
}
int get_s(int prompt , char *variable_name_string , char *value ) 
{ 
  int s ;
  char checkname[80] ;
  int tmp ;

  {
  if (prompt) {
    s = 0;
    while (s != 1) {
      printf("enter %s ", variable_name_string);
      s = scanf("%s", value);
      if (s == 1) {
        printf("%s %s\n", variable_name_string, value);
      } else {
        printf("Data format error.\n");
      }
    }
  } else {
    s = scanf("%s", checkname);
    if (s == -1) {
      printf("get_s: EOF on STDIN while expecting %s.\n", variable_name_string);
      return (1);
    } else
    if (s == 0) {
      printf("get_s: Format error looking for %s\n", variable_name_string);
      return (1);
    } else {
      tmp = strcmp((char const   *)(checkname), (char const   *)variable_name_string);
      if (tmp != 0) {
        printf("get_s: ERROR IN INPUT: expected %s but found %s\n", variable_name_string,
               checkname);
        return (1);
      }
    }
    printf("%s ", variable_name_string);
    s = scanf("%s", value);
    if (s == -1) {
      printf("\nget_s: Expecting value for %s but found EOF.\n", variable_name_string);
      return (1);
    } else
    if (s == 0) {
      printf("\nget_s: Format error reading value for %s\n", variable_name_string);
      return (1);
    }
    printf("%s\n", value);
  }
  return (0);
}
}
int get_prompt(int *prompt ) 
{ 
  char initial_prompt[80] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  *prompt = -1;
  printf("type 0 for no prompts  or 1 for prompts\n");
  scanf("%s", initial_prompt);
  tmp___1 = strcmp((char const   *)(initial_prompt), "prompt");
  if (tmp___1 == 0) {
    scanf("%d", prompt);
  } else {
    tmp___0 = strcmp((char const   *)(initial_prompt), "0");
    if (tmp___0 == 0) {
      *prompt = 0;
    } else {
      tmp = strcmp((char const   *)(initial_prompt), "1");
      if (tmp == 0) {
        *prompt = 1;
      }
    }
  }
  if (*prompt == 0) {
    return (0);
  } else
  if (*prompt == 1) {
    return (0);
  } else {
    printf("get_prompt: ERROR IN INPUT: initial prompt\n");
    return (1);
  }
}
}
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-0lghYm9I.i","-O3")
extern FILE *__stderrp ;
extern int fclose(FILE * ) ;
extern char *fgets(char * , int  , FILE * ) ;
extern FILE *fopen(char const   * , char const   * )  __asm__("_fopen")  ;
extern int ( /* format attribute */  fprintf)(FILE * , char const   *  , ...) ;
extern size_t fread(void * , size_t  , size_t  , FILE * ) ;
extern int ( /* format attribute */  fscanf)(FILE * , char const   *  , ...) ;
extern int fseek(FILE * , long  , int  ) ;
extern size_t fwrite(void const   * , size_t  , size_t  , FILE * )  __asm__("_fwrite")  ;
void byterevn(int32type *w , int n ) ;
void complete_U(double *u ) ;
int big_endian(void) ;
FILE *g_open(char const   *filename , char const   *mode ) ;
int g_seek(FILE *stream , off_t offset , int whence ) ;
size_t g_write(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) ;
size_t g_read(void *ptr , size_t size , size_t nmemb , FILE *stream ) ;
int g_close(FILE *stream ) ;
void swrite_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) ;
void pwrite_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) ;
void pswrite_data(int parallel , FILE *fp , void *src , size_t size , char *myname ,
                  char *descrip ) ;
int sread_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) ;
int pread_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) ;
int pread_byteorder(int byterevflag , FILE *fp , void *src , size_t size , char *myname ,
                    char *descrip ) ;
int sread_byteorder(int byterevflag , FILE *fp , void *src , size_t size , char *myname ,
                    char *descrip ) ;
int psread_data(int parallel , FILE *fp , void *src , size_t size , char *myname ,
                char *descrip ) ;
int psread_byteorder(int byterevflag , int parallel , FILE *fp , void *src , size_t size ,
                     char *myname , char *descrip ) ;
void send_field(char *buf , int size , int tonode ) ;
void get_field(char *buf , int size ) ;
void g_xor32(u_int32type *pt ) ;
void send_integer(int tonode , int *address ) ;
void receive_integer(int *address ) ;
extern char *ctime(time_t const   * ) ;
extern time_t time(time_t * ) ;
extern char *strchr(char const   * , int  ) ;
extern size_t strlen(char const   * ) ;
extern char *strstr(char const   * , char const   * ) ;
__inline static void *__inline_memcpy_chk(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
__inline static char *__inline_strcat_chk(char *__dest , char const   *__src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcat_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
extern int *__error(void) ;
int qcdhdr_get_str(char *s , QCDheader *hdr , char **q ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < (int )((char )hdr->ntoken)) {
    tmp = strcmp((char const   *)s, (char const   *)*(hdr->token + i));
    if (tmp == 0) {
      *q = *(hdr->value + i);
      return (0);
    }
    i ++;
  }
  *q = (char *)((void *)0);
  return (-1);
}
}
int qcdhdr_get_int(char *s , QCDheader *hdr , int *q ) 
{ 
  char *p ;

  {
  qcdhdr_get_str(s, hdr, & p);
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return (-1);
  }
  sscanf((char const   *)p, "%d", q);
  return (0);
}
}
int qcdhdr_get_int32x(char *s , QCDheader *hdr , u_int32type *q ) 
{ 
  char *p ;
  int r ;

  {
  qcdhdr_get_str(s, hdr, & p);
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return (-1);
  }
  sscanf((char const   *)p, "%x", & r);
  *q = (u_int32type )r;
  return (0);
}
}
int qcdhdr_get_double(char *s , QCDheader *hdr , double *q ) 
{ 
  char *p ;

  {
  qcdhdr_get_str(s, hdr, & p);
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return (-1);
  }
  sscanf((char const   *)p, "%lf", q);
  return (0);
}
}
void error_exit(char *s ) 
{ 


  {
  printf("%s\n", s);
  terminate(1);
  return;
}
}
void complete_U(double *u ) 
{ 


  {
  *(u + 12) = ((*(u + 2) * *(u + 10) - *(u + 4) * *(u + 8)) - *(u + 3) * *(u + 11)) + *(u + 5) * *(u + 9);
  *(u + 13) = ((*(u + 4) * *(u + 9) - *(u + 2) * *(u + 11)) + *(u + 5) * *(u + 8)) - *(u + 3) * *(u + 10);
  *(u + 14) = ((*(u + 4) * *(u + 6) - *(u + 0) * *(u + 10)) - *(u + 5) * *(u + 7)) + *(u + 1) * *(u + 11);
  *(u + 15) = ((*(u + 0) * *(u + 11) - *(u + 4) * *(u + 7)) + *(u + 1) * *(u + 10)) - *(u + 5) * *(u + 6);
  *(u + 16) = ((*(u + 0) * *(u + 8) - *(u + 2) * *(u + 6)) - *(u + 1) * *(u + 9)) + *(u + 3) * *(u + 7);
  *(u + 17) = ((*(u + 2) * *(u + 7) - *(u + 0) * *(u + 9)) + *(u + 3) * *(u + 6)) - *(u + 1) * *(u + 8);
  return;
}
}
int big_endian(void) 
{ 
  union __anonunion_u_39 u ;

  {
  u.l = 1L;
  return ((int )u.c[sizeof(long ) - 1UL] == 1);
}
}
QCDheader *qcdhdr_get_hdr(FILE *in ) 
{ 
  char line[1024] ;
  int n ;
  int len ;
  QCDheader *hdr ;
  char **tokens ;
  char **values ;
  char *p ;
  char *q ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;

  {
  fgets(line, 1024, in);
  tmp = calloc((size_t )512, sizeof(char *));
  tokens = (char **)tmp;
  tmp___0 = calloc((size_t )512, sizeof(char *));
  values = (char **)tmp___0;
  tmp___1 = calloc((size_t )1, sizeof(QCDheader ));
  hdr = (QCDheader *)tmp___1;
  hdr->token = tokens;
  hdr->value = values;
  n = 0;
  printf("reading Archive header:\n");
  while (1) {
    fgets(line, 1024, in);
    printf("%s", line);
    tmp___2 = strcmp((char const   *)(line), "END_HEADER\n");
    if (tmp___2 == 0) {
      break;
    }
    q = strchr((char const   *)(line), ' ');
    *q = (char )'\000';
    len = (int )q - (int )(line);
    tmp___3 = calloc((size_t )((len + 1) / 8 + 1), (size_t )8);
    p = (char *)tmp___3;
    *(hdr->token + n) = p;
    tmp___5 = __builtin_object_size((void *)p, 0);
    if (tmp___5 != 0xffffffffffffffffUL) {
      tmp___4 = __builtin_object_size((void *)p, 1);
      __builtin___strcpy_chk(p, (char const   *)(line), tmp___4);
    } else {
      __inline_strcpy_chk(p, (char const   *)(line));
    }
    q ++;
    q = strchr((char const   *)q, '=');
    q ++;
    tmp___6 = strlen((char const   *)q);
    len = (int )tmp___6;
    *(q + (len - 1)) = (char)0;
    tmp___7 = calloc((size_t )len, sizeof(char ));
    p = (char *)tmp___7;
    *(hdr->value + n) = p;
    tmp___9 = __builtin_object_size((void *)p, 0);
    if (tmp___9 != 0xffffffffffffffffUL) {
      tmp___8 = __builtin_object_size((void *)p, 1);
      __builtin___strcpy_chk(p, (char const   *)q, tmp___8);
    } else {
      __inline_strcpy_chk(p, (char const   *)q);
    }
    n ++;
  }
  hdr->ntoken = n;
  return (hdr);
}
}
void qcdhdr_destroy_hdr(QCDheader *hdr ) 
{ 
  int i ;

  {
  if ((unsigned long )hdr == (unsigned long )((void *)0)) {
    return;
  }
  i = 0;
  while (i < hdr->ntoken) {
    free((void *)*(hdr->value + i));
    free((void *)*(hdr->token + i));
    i ++;
  }
  free((void *)hdr->token);
  free((void *)hdr->value);
  free((void *)hdr);
  return;
}
}
void swrite_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) 
{ 
  int *tmp ;
  size_t tmp___0 ;

  {
  tmp___0 = fwrite((void const   *)src, size, (size_t )1, fp);
  if (tmp___0 != 1UL) {
    tmp = __error();
    printf("%s: Node %d %s write error %d\n", myname, this_node, descrip, *tmp);
    fflush(__stdoutp);
    terminate(1);
  }
  return;
}
}
void pwrite_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) 
{ 
  int *tmp ;
  size_t tmp___0 ;

  {
  tmp___0 = g_write((void const   *)src, size, (size_t )1, fp);
  if (tmp___0 != 1UL) {
    tmp = __error();
    printf("%s: Node %d %s descrip,write error %d\n", myname, this_node, descrip,
           *tmp);
    fflush(__stdoutp);
    terminate(1);
  }
  return;
}
}
void pswrite_data(int parallel , FILE *fp , void *src , size_t size , char *myname ,
                  char *descrip ) 
{ 


  {
  if (parallel) {
    pwrite_data(fp, src, size, myname, descrip);
  } else {
    swrite_data(fp, src, size, myname, descrip);
  }
  return;
}
}
int sread_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) 
{ 
  int *tmp ;
  size_t tmp___0 ;

  {
  tmp___0 = fread(src, size, (size_t )1, fp);
  if (tmp___0 != 1UL) {
    tmp = __error();
    printf("%s: Node %d %s read error %d\n", myname, this_node, descrip, *tmp);
    fflush(__stdoutp);
    return (1);
  }
  return (0);
}
}
int pread_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) 
{ 
  int *tmp ;
  size_t tmp___0 ;

  {
  tmp___0 = g_read(src, size, (size_t )1, fp);
  if (tmp___0 != 1UL) {
    tmp = __error();
    printf("%s: Node %d %s read error %d\n", myname, this_node, descrip, *tmp);
    fflush(__stdoutp);
    return (1);
  }
  return (0);
}
}
int pread_byteorder(int byterevflag , FILE *fp , void *src , size_t size , char *myname ,
                    char *descrip ) 
{ 
  int status ;

  {
  status = pread_data(fp, src, size, myname, descrip);
  if (byterevflag == 1) {
    byterevn((int32type *)src, (int )(size / sizeof(int32type )));
  }
  return (status);
}
}
int sread_byteorder(int byterevflag , FILE *fp , void *src , size_t size , char *myname ,
                    char *descrip ) 
{ 
  int status ;

  {
  status = sread_data(fp, src, size, myname, descrip);
  if (byterevflag == 1) {
    byterevn((int32type *)src, (int )(size / sizeof(int32type )));
  }
  return (status);
}
}
int psread_data(int parallel , FILE *fp , void *src , size_t size , char *myname ,
                char *descrip ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (parallel) {
    tmp = pread_data(fp, src, size, myname, descrip);
    return (tmp);
  } else {
    tmp___0 = sread_data(fp, src, size, myname, descrip);
    return (tmp___0);
  }
}
}
int psread_byteorder(int byterevflag , int parallel , FILE *fp , void *src , size_t size ,
                     char *myname , char *descrip ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (parallel) {
    tmp = pread_byteorder(byterevflag, fp, src, size, myname, descrip);
    return (tmp);
  } else {
    tmp___0 = sread_byteorder(byterevflag, fp, src, size, myname, descrip);
    return (tmp___0);
  }
}
}
void pwrite_gauge_hdr(FILE *fp , gauge_header *gh ) 
{ 
  char myname[17] ;

  {
  myname[0] = (char )'p';
  myname[1] = (char )'w';
  myname[2] = (char )'r';
  myname[3] = (char )'i';
  myname[4] = (char )'t';
  myname[5] = (char )'e';
  myname[6] = (char )'_';
  myname[7] = (char )'g';
  myname[8] = (char )'a';
  myname[9] = (char )'u';
  myname[10] = (char )'g';
  myname[11] = (char )'e';
  myname[12] = (char )'_';
  myname[13] = (char )'h';
  myname[14] = (char )'d';
  myname[15] = (char )'r';
  myname[16] = (char )'\000';
  pwrite_data(fp, (void *)(& gh->magic_number), sizeof(gh->magic_number), myname,
              (char *)"magic_number");
  pwrite_data(fp, (void *)(gh->dims), sizeof(gh->dims), myname, (char *)"dimensions");
  pwrite_data(fp, (void *)(gh->time_stamp), sizeof(gh->time_stamp), myname, (char *)"time_stamp");
  pwrite_data(fp, (void *)(& gh->order), sizeof(gh->order), myname, (char *)"order");
  gh->header_bytes = (int32type )(((sizeof(gh->magic_number) + sizeof(gh->dims)) + sizeof(gh->time_stamp)) + sizeof(gh->order));
  return;
}
}
void swrite_gauge_hdr(FILE *fp , gauge_header *gh ) 
{ 
  char myname[17] ;

  {
  myname[0] = (char )'s';
  myname[1] = (char )'w';
  myname[2] = (char )'r';
  myname[3] = (char )'i';
  myname[4] = (char )'t';
  myname[5] = (char )'e';
  myname[6] = (char )'_';
  myname[7] = (char )'g';
  myname[8] = (char )'a';
  myname[9] = (char )'u';
  myname[10] = (char )'g';
  myname[11] = (char )'e';
  myname[12] = (char )'_';
  myname[13] = (char )'h';
  myname[14] = (char )'d';
  myname[15] = (char )'r';
  myname[16] = (char )'\000';
  swrite_data(fp, (void *)(& gh->magic_number), sizeof(gh->magic_number), myname,
              (char *)"magic_number");
  swrite_data(fp, (void *)(gh->dims), sizeof(gh->dims), myname, (char *)"dimensions");
  swrite_data(fp, (void *)(gh->time_stamp), sizeof(gh->time_stamp), myname, (char *)"time_stamp");
  swrite_data(fp, (void *)(& gh->order), sizeof(gh->order), myname, (char *)"order");
  gh->header_bytes = (int32type )(((sizeof(gh->magic_number) + sizeof(gh->dims)) + sizeof(gh->time_stamp)) + sizeof(gh->order));
  return;
}
}
int write_gauge_info_item(FILE *fpout , char *keyword , char *fmt , char *src , int count ,
                          int stride ) 
{ 
  int i ;
  int k ;
  int n ;
  char *data ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  i = 0;
  while (1) {
    tmp = strlen((char const   *)gauge_info_keyword[i]);
    if (tmp > 0UL) {
      tmp___0 = strcmp((char const   *)gauge_info_keyword[i], (char const   *)keyword);
      if (! (tmp___0 != 0)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  tmp___1 = strlen((char const   *)gauge_info_keyword[i]);
  if (tmp___1 == 0UL) {
    printf("write_gauge_info_item: WARNING: keyword %s not in table\n", keyword);
  }
  fprintf(fpout, "%s =", keyword);
  if (count > 1) {
    fprintf(fpout, "[%d]", count);
  }
  n = count;
  if (n == 0) {
    n = 1;
  }
  k = 0;
  data = src;
  while (k < n) {
    fprintf(fpout, " ");
    tmp___6 = strstr((char const   *)fmt, "s");
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
      fprintf(fpout, (char const   *)fmt, data);
    } else {
      tmp___5 = strstr((char const   *)fmt, "d");
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        fprintf(fpout, (char const   *)fmt, *((int *)data));
      } else {
        tmp___4 = strstr((char const   *)fmt, "e");
        if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
          fprintf(fpout, (char const   *)fmt, *((double *)data));
        } else {
          tmp___3 = strstr((char const   *)fmt, "f");
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
            fprintf(fpout, (char const   *)fmt, *((double *)data));
          } else {
            tmp___2 = strstr((char const   *)fmt, "g");
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
              fprintf(fpout, (char const   *)fmt, *((double *)data));
            } else {
              printf("write_gauge_info_item: Unrecognized data type %s\n", fmt);
              return (1);
            }
          }
        }
      }
    }
    k ++;
    data += stride;
  }
  fprintf(fpout, "\n");
  return (0);
}
}
void write_gauge_info_file(gauge_file *gf___0 ) 
{ 
  FILE *info_fp ;
  gauge_header *gh ;
  char info_filename[256] ;
  char sums[20] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  gh = gf___0->header;
  tmp___0 = __builtin_object_size((void *)(info_filename), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(info_filename), 1);
    __builtin___strcpy_chk(info_filename, (char const   *)gf___0->filename, tmp);
  } else {
    __inline_strcpy_chk(info_filename, (char const   *)gf___0->filename);
  }
  tmp___2 = __builtin_object_size((void *)(info_filename), 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)(info_filename), 1);
    __builtin___strcat_chk(info_filename, ".info", tmp___1);
  } else {
    __inline_strcat_chk(info_filename, ".info");
  }
  info_fp = fopen((char const   *)(info_filename), "w");
  if ((unsigned long )info_fp == (unsigned long )((void *)0)) {
    printf("write_gauge_info_file: Can\'t open ascii info file %s\n", info_filename);
    return;
  }
  write_gauge_info_item(info_fp, (char *)"magic_number", (char *)"%d", (char *)(& gh->magic_number),
                        0, 0);
  write_gauge_info_item(info_fp, (char *)"time_stamp", (char *)"\"%s\"", gh->time_stamp,
                        0, 0);
  tmp___3 = __builtin_object_size((void *)(sums), 1);
  __builtin___sprintf_chk(sums, 0, tmp___3, "%x %x", gf___0->check.sum29, gf___0->check.sum31);
  write_gauge_info_item(info_fp, (char *)"checksums", (char *)"\"%s\"", sums, 0, 0);
  write_gauge_info_item(info_fp, (char *)"nx", (char *)"%d", (char *)(& nx), 0, 0);
  write_gauge_info_item(info_fp, (char *)"ny", (char *)"%d", (char *)(& ny), 0, 0);
  write_gauge_info_item(info_fp, (char *)"nz", (char *)"%d", (char *)(& nz), 0, 0);
  write_gauge_info_item(info_fp, (char *)"nt", (char *)"%d", (char *)(& nt), 0, 0);
  write_appl_gauge_info(info_fp);
  fclose(info_fp);
  printf("Wrote info file %s\n", info_filename);
  return;
}
}
gauge_file *setup_input_gauge_file(char *filename ) 
{ 
  char myname[23] ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  void *tmp ;
  void *tmp___0 ;

  {
  myname[0] = (char )'s';
  myname[1] = (char )'e';
  myname[2] = (char )'t';
  myname[3] = (char )'u';
  myname[4] = (char )'p';
  myname[5] = (char )'_';
  myname[6] = (char )'i';
  myname[7] = (char )'n';
  myname[8] = (char )'p';
  myname[9] = (char )'u';
  myname[10] = (char )'t';
  myname[11] = (char )'_';
  myname[12] = (char )'g';
  myname[13] = (char )'a';
  myname[14] = (char )'u';
  myname[15] = (char )'g';
  myname[16] = (char )'e';
  myname[17] = (char )'_';
  myname[18] = (char )'f';
  myname[19] = (char )'i';
  myname[20] = (char )'l';
  myname[21] = (char )'e';
  myname[22] = (char )'\000';
  tmp = calloc((size_t )1, sizeof(gauge_file ));
  gf___0 = (gauge_file *)tmp;
  if ((unsigned long )gf___0 == (unsigned long )((void *)0)) {
    printf("%s: Can\'t malloc gf\n", myname);
    terminate(1);
  }
  gf___0->filename = filename;
  tmp___0 = calloc((size_t )1, sizeof(gauge_header ));
  gh = (gauge_header *)tmp___0;
  if ((unsigned long )gh == (unsigned long )((void *)0)) {
    printf("%s: Can\'t malloc gh\n", myname);
    terminate(1);
  }
  gf___0->header = gh;
  gf___0->check.sum29 = (u_int32type )0;
  gf___0->check.sum31 = (u_int32type )0;
  return (gf___0);
}
}
gauge_file *setup_output_gauge_file(void) 
{ 
  char myname[24] ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  time_t time_stamp___0 ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
  myname[0] = (char )'s';
  myname[1] = (char )'e';
  myname[2] = (char )'t';
  myname[3] = (char )'u';
  myname[4] = (char )'p';
  myname[5] = (char )'_';
  myname[6] = (char )'o';
  myname[7] = (char )'u';
  myname[8] = (char )'t';
  myname[9] = (char )'p';
  myname[10] = (char )'u';
  myname[11] = (char )'t';
  myname[12] = (char )'_';
  myname[13] = (char )'g';
  myname[14] = (char )'a';
  myname[15] = (char )'u';
  myname[16] = (char )'g';
  myname[17] = (char )'e';
  myname[18] = (char )'_';
  myname[19] = (char )'f';
  myname[20] = (char )'i';
  myname[21] = (char )'l';
  myname[22] = (char )'e';
  myname[23] = (char )'\000';
  tmp = calloc((size_t )1, sizeof(gauge_file ));
  gf___0 = (gauge_file *)tmp;
  if ((unsigned long )gf___0 == (unsigned long )((void *)0)) {
    printf("%s: Can\'t malloc gf\n", myname);
    terminate(1);
  }
  tmp___0 = calloc((size_t )1, sizeof(gauge_header ));
  gh = (gauge_header *)tmp___0;
  if ((unsigned long )gh == (unsigned long )((void *)0)) {
    printf("%s: Can\'t malloc gh\n", myname);
    terminate(1);
  }
  gf___0->header = gh;
  gf___0->check.sum29 = (u_int32type )0;
  gf___0->check.sum31 = (u_int32type )0;
  gh->magic_number = 20103;
  gh->dims[0] = nx;
  gh->dims[1] = ny;
  gh->dims[2] = nz;
  gh->dims[3] = nt;
  if (this_node == 0) {
    time(& time_stamp___0);
    tmp___4 = __builtin_object_size((void *)(gh->time_stamp), 0);
    if (tmp___4 != 0xffffffffffffffffUL) {
      tmp___2 = __builtin_object_size((void *)(gh->time_stamp), 1);
      tmp___3 = ctime((time_t const   *)(& time_stamp___0));
      __builtin___strcpy_chk(gh->time_stamp, (char const   *)tmp___3, tmp___2);
    } else {
      tmp___1 = ctime((time_t const   *)(& time_stamp___0));
      __inline_strcpy_chk(gh->time_stamp, (char const   *)tmp___1);
    }
    tmp___5 = strlen((char const   *)(gh->time_stamp));
    i = (int )(tmp___5 + 1UL);
    while (i < (int )sizeof(gh->time_stamp)) {
      gh->time_stamp[i] = (char )'\000';
      i ++;
    }
    tmp___7 = strlen((char const   *)(gh->time_stamp));
    if ((int )gh->time_stamp[tmp___7 - 1UL] == 10) {
      tmp___6 = strlen((char const   *)(gh->time_stamp));
      gh->time_stamp[tmp___6 - 1UL] = (char )'\000';
    }
  }
  broadcast_bytes(gh->time_stamp, (int )sizeof(gh->time_stamp));
  return (gf___0);
}
}
gauge_file *w_serial_i(char *filename ) 
{ 
  char myname[11] ;
  FILE *fp ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  int *tmp ;

  {
  myname[0] = (char )'w';
  myname[1] = (char )'_';
  myname[2] = (char )'s';
  myname[3] = (char )'e';
  myname[4] = (char )'r';
  myname[5] = (char )'i';
  myname[6] = (char )'a';
  myname[7] = (char )'l';
  myname[8] = (char )'_';
  myname[9] = (char )'i';
  myname[10] = (char )'\000';
  gf___0 = setup_output_gauge_file();
  gh = gf___0->header;
  gh->order = 0;
  if (this_node == 0) {
    fp = fopen((char const   *)filename, "wb");
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      tmp = __error();
      printf("%s: Node %d can\'t open file %s, error %d\n", myname, this_node, filename,
             *tmp);
      fflush(__stdoutp);
      terminate(1);
    }
    swrite_gauge_hdr(fp, gh);
  }
  if (this_node == 0) {
    gf___0->fp = fp;
  } else {
    gf___0->fp = (FILE *)((void *)0);
  }
  gf___0->filename = filename;
  gf___0->byterevflag = 0;
  gf___0->rank2rcv = (int32type *)((void *)0);
  gf___0->parallel = 0;
  return (gf___0);
}
}
void read_checksum(int parallel , gauge_file *gf___0 , gauge_check *test_gc ) 
{ 
  char myname[14] ;
  int tmp ;
  int tmp___0 ;

  {
  myname[0] = (char )'r';
  myname[1] = (char )'e';
  myname[2] = (char )'a';
  myname[3] = (char )'d';
  myname[4] = (char )'_';
  myname[5] = (char )'c';
  myname[6] = (char )'h';
  myname[7] = (char )'e';
  myname[8] = (char )'c';
  myname[9] = (char )'k';
  myname[10] = (char )'s';
  myname[11] = (char )'u';
  myname[12] = (char )'m';
  myname[13] = (char )'\000';
  tmp = psread_byteorder(gf___0->byterevflag, parallel, gf___0->fp, (void *)(& gf___0->check.sum29),
                         sizeof(gf___0->check.sum29), myname, (char *)"checksum");
  if (tmp != 0) {
    terminate(1);
  }
  tmp___0 = psread_byteorder(gf___0->byterevflag, parallel, gf___0->fp, (void *)(& gf___0->check.sum31),
                             sizeof(gf___0->check.sum31), myname, (char *)"checksum");
  if (tmp___0 != 0) {
    terminate(1);
  }
  if (gf___0->check.sum29 != test_gc->sum29) {
    printf("%s: Checksum violation. Computed %x %x.  Read %x %x.\n", myname, test_gc->sum29,
           test_gc->sum31, gf___0->check.sum29, gf___0->check.sum31);
  } else
  if (gf___0->check.sum31 != test_gc->sum31) {
    printf("%s: Checksum violation. Computed %x %x.  Read %x %x.\n", myname, test_gc->sum29,
           test_gc->sum31, gf___0->check.sum29, gf___0->check.sum31);
  } else {
    printf("Checksums %x %x OK\n", gf___0->check.sum29, gf___0->check.sum31);
    fflush(__stdoutp);
  }
  return;
}
}
void write_checksum(int parallel , gauge_file *gf___0 ) 
{ 
  char myname[15] ;

  {
  myname[0] = (char )'w';
  myname[1] = (char )'r';
  myname[2] = (char )'i';
  myname[3] = (char )'t';
  myname[4] = (char )'e';
  myname[5] = (char )'_';
  myname[6] = (char )'c';
  myname[7] = (char )'h';
  myname[8] = (char )'e';
  myname[9] = (char )'c';
  myname[10] = (char )'k';
  myname[11] = (char )'s';
  myname[12] = (char )'u';
  myname[13] = (char )'m';
  myname[14] = (char )'\000';
  pswrite_data(parallel, gf___0->fp, (void *)(& gf___0->check.sum29), sizeof(gf___0->check.sum29),
               myname, (char *)"checksum");
  pswrite_data(parallel, gf___0->fp, (void *)(& gf___0->check.sum31), sizeof(gf___0->check.sum31),
               myname, (char *)"checksum");
  printf("Checksums %x %x\n", gf___0->check.sum29, gf___0->check.sum31);
  return;
}
}
void w_serial(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  u_int32type *val ;
  int rank29 ;
  int rank31 ;
  su3_matrix *lbuf ;
  su3_matrix tbuf[4] ;
  int buf_length ;
  register int i ;
  register int j ;
  register int k ;
  off_t offset ;
  off_t coord_list_size ;
  off_t head_size ;
  off_t checksum_offset ;
  off_t gauge_check_size ;
  int currentnode ;
  int newnode ;
  int x ;
  int y ;
  int z ;
  int t ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  int *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
  if (this_node == 0) {
    if (gf___0->parallel) {
      printf("w_serial: Attempting serial write to parallel file \n");
    }
    tmp = calloc((size_t )16384, sizeof(su3_matrix ));
    lbuf = (su3_matrix *)tmp;
    if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
      printf("w_serial: Node 0 can\'t malloc lbuf\n");
      fflush(__stdoutp);
      terminate(1);
    }
    fp = gf___0->fp;
    gh = gf___0->header;
    coord_list_size = (off_t )0;
    head_size = (off_t )gh->header_bytes + coord_list_size;
    checksum_offset = head_size;
    gauge_check_size = (off_t )(sizeof(gf___0->check.sum29) + sizeof(gf___0->check.sum31));
    offset = head_size + gauge_check_size;
    tmp___1 = fseek(fp, (long )offset, 0);
    if (tmp___1 < 0) {
      tmp___0 = __error();
      printf("w_serial: Node %d fseeko failed error %d file %s\n", this_node, *tmp___0,
             gf___0->filename);
      fflush(__stdoutp);
      terminate(1);
    }
  }
  gf___0->check.sum31 = (u_int32type )0;
  gf___0->check.sum29 = (u_int32type )0;
  rank29 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 29UL);
  rank31 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 31UL);
  g_sync();
  currentnode = 0;
  buf_length = 0;
  j = 0;
  t = 0;
  while (t < nt) {
    z = 0;
    while (z < nz) {
      y = 0;
      while (y < ny) {
        x = 0;
        while (x < nx) {
          newnode = node_number(x, y, z, t);
          if (newnode != currentnode) {
            if (this_node == 0) {
              if (newnode != 0) {
                send_field((char *)(tbuf), 4, newnode);
              }
            }
            if (this_node == newnode) {
              if (newnode != 0) {
                get_field((char *)(tbuf), 4);
              }
            }
            currentnode = newnode;
          }
          if (this_node == 0) {
            if (currentnode == 0) {
              i = node_index(x, y, z, t);
              k = 0;
              while (k < 4) {
                tbuf[k] = (lattice + i)->link[k];
                k ++;
              }
            } else {
              get_field((char *)(tbuf), (int )(4UL * sizeof(su3_matrix )));
            }
            tmp___3 = __builtin_object_size((void *)(lbuf + 4 * buf_length), 0);
            if (tmp___3 != 0xffffffffffffffffUL) {
              tmp___2 = __builtin_object_size((void *)(lbuf + 4 * buf_length), 0);
              __builtin___memcpy_chk((void *)(lbuf + 4 * buf_length), (void const   *)((void *)(tbuf)),
                                     4UL * sizeof(su3_matrix ), tmp___2);
            } else {
              __inline_memcpy_chk((void *)(lbuf + 4 * buf_length), (void const   *)((void *)(tbuf)),
                                  4UL * sizeof(su3_matrix ));
            }
            k = 0;
            val = (u_int32type *)(lbuf + 4 * buf_length);
            while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
              gf___0->check.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
              gf___0->check.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
              rank29 ++;
              if (rank29 >= 29) {
                rank29 = 0;
              }
              rank31 ++;
              if (rank31 >= 31) {
                rank31 = 0;
              }
              k ++;
              val ++;
            }
            buf_length ++;
            if (buf_length == 4096) {
              goto _L;
            } else
            if (j == volume - 1) {
              _L: /* CIL Label */ 
              tmp___5 = fwrite((void const   *)lbuf, 4UL * sizeof(su3_matrix ), (size_t )buf_length,
                               fp);
              if ((int )tmp___5 != buf_length) {
                tmp___4 = __error();
                printf("w_serial: Node %d gauge configuration write error %d file %s\n",
                       this_node, *tmp___4, gf___0->filename);
                fflush(__stdoutp);
                terminate(1);
              }
              buf_length = 0;
            }
          } else
          if (this_node == currentnode) {
            i = node_index(x, y, z, t);
            send_field((char *)((lattice + i)->link), (int )(4UL * sizeof(su3_matrix )),
                       0);
          }
          x ++;
          j ++;
        }
        y ++;
      }
      z ++;
    }
    t ++;
  }
  g_sync();
  if (this_node == 0) {
    free((void *)lbuf);
    printf("Saved gauge configuration serially to binary file %s\n", gf___0->filename);
    printf("Time stamp %s\n", gh->time_stamp);
    tmp___7 = fseek(fp, (long )checksum_offset, 0);
    if (tmp___7 < 0) {
      tmp___6 = __error();
      printf("w_serial: Node %d fseeko failed error %d file %s\n", this_node, *tmp___6,
             gf___0->filename);
      fflush(__stdoutp);
      terminate(1);
    }
    write_checksum(0, gf___0);
  }
  return;
}
}
void w_serial_f(gauge_file *gf___0 ) 
{ 


  {
  g_sync();
  if (this_node == 0) {
    if (gf___0->parallel) {
      printf("w_serial_f: Attempting serial close on parallel file \n");
    }
    fclose(gf___0->fp);
  }
  if (this_node == 0) {
    write_gauge_info_file(gf___0);
  }
  return;
}
}
void read_site_list(int parallel , gauge_file *gf___0 ) 
{ 
  void *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;

  {
  if ((gf___0->header)->order != 0) {
    tmp = calloc((size_t )volume, sizeof(int32type ));
    gf___0->rank2rcv = (int32type *)tmp;
    if ((unsigned long )gf___0->rank2rcv == (unsigned long )((void *)0)) {
      printf("read_site_list: Can\'t malloc rank2rcv table\n");
      terminate(1);
    }
    if (this_node == 0) {
      if (parallel) {
        tmp___1 = g_read((void *)gf___0->rank2rcv, sizeof(int32type ), (size_t )volume,
                         gf___0->fp);
        if ((int )tmp___1 != volume) {
          tmp___0 = __error();
          printf("read_site_list: Node %d site list read error %d\n", this_node, *tmp___0);
          terminate(1);
        }
      } else {
        tmp___3 = fread((void *)gf___0->rank2rcv, sizeof(int32type ), (size_t )volume,
                        gf___0->fp);
        if ((int )tmp___3 != volume) {
          tmp___2 = __error();
          printf("read_site_list: Node %d site list read error %d\n", this_node, *tmp___2);
          terminate(1);
        }
      }
      if (gf___0->byterevflag == 1) {
        byterevn(gf___0->rank2rcv, volume);
      }
    }
    broadcast_bytes((char *)gf___0->rank2rcv, (int )((unsigned long )volume * sizeof(int32type )));
  } else {
    gf___0->rank2rcv = (int32type *)((void *)0);
  }
  return;
}
}
int read_v3_gauge_hdr(gauge_file *gf___0 , int parallel , int *byterevflag ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  int32type tmp ;
  int j ;
  int sixtyfourbits ;
  double c1 ;
  double c2 ;
  char myname[18] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  myname[0] = (char )'r';
  myname[1] = (char )'e';
  myname[2] = (char )'a';
  myname[3] = (char )'d';
  myname[4] = (char )'_';
  myname[5] = (char )'v';
  myname[6] = (char )'3';
  myname[7] = (char )'_';
  myname[8] = (char )'g';
  myname[9] = (char )'a';
  myname[10] = (char )'u';
  myname[11] = (char )'g';
  myname[12] = (char )'e';
  myname[13] = (char )'_';
  myname[14] = (char )'h';
  myname[15] = (char )'d';
  myname[16] = (char )'r';
  myname[17] = (char )'\000';
  fp = gf___0->fp;
  gh = gf___0->header;
  if (gh->magic_number == 0) {
    sixtyfourbits = 1;
    printf("First 4 bytes were zero. Trying to interpret with 64 bit integer format.\n");
    tmp___0 = psread_data(parallel, fp, (void *)(& gh->magic_number), sizeof(gh->magic_number),
                          myname, (char *)"magic number");
    if (tmp___0 != 0) {
      terminate(1);
    }
  } else {
    sixtyfourbits = 0;
  }
  tmp = gh->magic_number;
  if (gh->magic_number == 59354) {
    printf("Reading as old-style gauge field configuration.\n");
    *byterevflag = 0;
  } else {
    byterevn(& gh->magic_number, 1);
    if (gh->magic_number == 59354) {
      *byterevflag = 1;
      printf("Reading as old-style gauge field configuration with byte reversal\n");
      if (sizeof(double ) != sizeof(int32type )) {
        printf("read_v3_gauge_hdr: Can\'t byte reverse\n");
        printf("requires size of int32type(%d) = size of double(%d)\n", (int )sizeof(int32type ),
               (int )sizeof(double ));
        terminate(1);
      }
    } else {
      gh->magic_number = tmp;
      return (1);
    }
  }
  j = 0;
  while (j < 4) {
    tmp___1 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gh->dims[j]),
                               sizeof(gh->dims[j]), myname, (char *)"dimensions");
    if (tmp___1 != 0) {
      terminate(1);
    }
    if (sixtyfourbits) {
      tmp___2 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gh->dims[j]),
                                 sizeof(gh->dims[j]), myname, (char *)"dimensions");
      if (tmp___2 != 0) {
        terminate(1);
      }
    }
    j ++;
  }
  if (gh->dims[0] != nx) {
    goto _L___0;
  } else
  if (gh->dims[1] != ny) {
    goto _L___0;
  } else
  if (gh->dims[2] != nz) {
    goto _L___0;
  } else
  if (gh->dims[3] != nt) {
    _L___0: /* CIL Label */ 
    if (nx != -1) {
      goto _L;
    } else
    if (ny != -1) {
      goto _L;
    } else
    if (nz != -1) {
      goto _L;
    } else
    if (nt != -1) {
      _L: /* CIL Label */ 
      printf("read_v3_gauge_hdr: Incorrect lattice dimensions ");
      j = 0;
      while (j < 4) {
        printf("%d ", gh->dims[j]);
        j ++;
      }
      printf("\n");
      fflush(__stdoutp);
      terminate(1);
    } else {
      nx = gh->dims[0];
      ny = gh->dims[1];
      nz = gh->dims[2];
      nt = gh->dims[3];
      volume = ((nx * ny) * nz) * nt;
    }
  }
  if (sixtyfourbits == 0) {
    gh->header_bytes = 28;
  } else {
    gh->header_bytes = 48;
  }
  gh->order = 0;
  tmp___3 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& c1), sizeof(double ),
                             myname, (char *)"c1");
  if (tmp___3 != 0) {
    terminate(1);
  }
  tmp___4 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& c2), sizeof(double ),
                             myname, (char *)"c2");
  if (tmp___4 != 0) {
    terminate(1);
  }
  printf("Old format header parameters are %f %f\n", c1, c2);
  return (0);
}
}
int read_1996_gauge_hdr(gauge_file *gf___0 , int parallel , int *byterevflag ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  int32type tmp ;
  int j ;
  struct __anonstruct_gauge_field_40 gauge_field ;
  char myname[20] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  myname[0] = (char )'r';
  myname[1] = (char )'e';
  myname[2] = (char )'a';
  myname[3] = (char )'d';
  myname[4] = (char )'_';
  myname[5] = (char )'1';
  myname[6] = (char )'9';
  myname[7] = (char )'9';
  myname[8] = (char )'6';
  myname[9] = (char )'_';
  myname[10] = (char )'g';
  myname[11] = (char )'a';
  myname[12] = (char )'u';
  myname[13] = (char )'g';
  myname[14] = (char )'e';
  myname[15] = (char )'_';
  myname[16] = (char )'h';
  myname[17] = (char )'d';
  myname[18] = (char )'r';
  myname[19] = (char )'\000';
  fp = gf___0->fp;
  gh = gf___0->header;
  tmp = gh->magic_number;
  if (gh->magic_number == 53546) {
    printf("Reading as 1996-style gauge field configuration.\n");
    *byterevflag = 0;
  } else {
    byterevn(& gh->magic_number, 1);
    if (gh->magic_number == 53546) {
      *byterevflag = 1;
      printf("Reading as 1996-style gauge field configuration with byte reversal\n");
      if (sizeof(double ) != sizeof(int32type )) {
        printf("read_1996_gauge_hdr: Can\'t byte reverse\n");
        printf("requires size of int32type(%d) = size of double(%d)\n", (int )sizeof(int32type ),
               (int )sizeof(double ));
        terminate(1);
      }
    } else {
      gh->magic_number = tmp;
      return (1);
    }
  }
  tmp___0 = psread_byteorder(*byterevflag, parallel, fp, (void *)(gh->dims), sizeof(gh->dims),
                             myname, (char *)"dimensions");
  if (tmp___0 != 0) {
    terminate(1);
  }
  if (gh->dims[0] != nx) {
    goto _L___0;
  } else
  if (gh->dims[1] != ny) {
    goto _L___0;
  } else
  if (gh->dims[2] != nz) {
    goto _L___0;
  } else
  if (gh->dims[3] != nt) {
    _L___0: /* CIL Label */ 
    if (nx != -1) {
      goto _L;
    } else
    if (ny != -1) {
      goto _L;
    } else
    if (nz != -1) {
      goto _L;
    } else
    if (nt != -1) {
      _L: /* CIL Label */ 
      printf("read_1996_gauge_hdr: Incorrect lattice dimensions ");
      j = 0;
      while (j < 4) {
        printf("%d ", gh->dims[j]);
        j ++;
      }
      printf("\n");
      fflush(__stdoutp);
      terminate(1);
    } else {
      nx = gh->dims[0];
      ny = gh->dims[1];
      nz = gh->dims[2];
      nt = gh->dims[3];
      volume = ((nx * ny) * nz) * nt;
    }
  }
  tmp___1 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gh->header_bytes),
                             sizeof(gh->header_bytes), myname, (char *)"header size");
  if (tmp___1 != 0) {
    terminate(1);
  }
  tmp___2 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gh->order), sizeof(gh->order),
                             myname, (char *)"order");
  if (tmp___2 != 0) {
    terminate(1);
  }
  tmp___3 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gauge_field.n_descript),
                             sizeof(gauge_field.n_descript), myname, (char *)"n_descript");
  if (tmp___3 != 0) {
    terminate(1);
  }
  if (gauge_field.n_descript > 200) {
    printf("read_1996_gauge_hdr: gauge field descriptor length %d\n", gauge_field.n_descript);
    printf(" exceeds allocated space %d\n", 200);
    terminate(1);
  }
  tmp___4 = psread_data(parallel, fp, (void *)(gauge_field.descript), sizeof(gauge_field.descript),
                        myname, (char *)"descrip");
  if (tmp___4 != 0) {
    terminate(1);
  }
  gauge_field.descript[gauge_field.n_descript - 1] = (char )'\000';
  printf("gauge_field.descript: %s\n", gauge_field.descript);
  tmp___5 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gauge_field.n_param),
                             sizeof(gauge_field.n_param), myname, (char *)"n_param");
  if (tmp___5 != 0) {
    terminate(1);
  }
  if (gauge_field.n_param > 2) {
    printf("read_1996_gauge_hdr: gauge field parameter vector length %d\n", gauge_field.n_param);
    printf(" exceeds allocated space %d\n", 2);
    terminate(1);
  }
  j = 0;
  while (j < gauge_field.n_param) {
    tmp___6 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gauge_field.param[j]),
                               sizeof(gauge_field.param[j]), myname, (char *)"gauge param");
    if (tmp___6 != 0) {
      terminate(1);
    }
    printf("gauge_field.param[%d] = %f\n", j, gauge_field.param[j]);
    j ++;
  }
  return (0);
}
}
int read_gauge_hdr(gauge_file *gf___0 , int parallel ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  int32type tmp ;
  int32type btmp ;
  int j ;
  int byterevflag ;
  char myname[15] ;
  int i ;
  QCDheader *hdr ;
  int dims[4] ;
  int ARCHYES ;
  u_int32type chksum ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  myname[0] = (char )'r';
  myname[1] = (char )'e';
  myname[2] = (char )'a';
  myname[3] = (char )'d';
  myname[4] = (char )'_';
  myname[5] = (char )'g';
  myname[6] = (char )'a';
  myname[7] = (char )'u';
  myname[8] = (char )'g';
  myname[9] = (char )'e';
  myname[10] = (char )'_';
  myname[11] = (char )'h';
  myname[12] = (char )'d';
  myname[13] = (char )'r';
  myname[14] = (char )'\000';
  ARCHYES = 0;
  fp = gf___0->fp;
  gh = gf___0->header;
  tmp___0 = psread_data(parallel, fp, (void *)(& gh->magic_number), sizeof(gh->magic_number),
                        myname, (char *)"magic number");
  if (tmp___0 != 0) {
    terminate(1);
  }
  tmp = gh->magic_number;
  btmp = gh->magic_number;
  byterevn(& btmp, 1);
  if (tmp == 1111836489) {
    printf("reading as archive format\n");
    ARCHYES = 1;
    byterevflag = 0;
  } else
  if (btmp == 1111836489) {
    printf("reading as archive format with byte reversal\n");
    ARCHYES = 1;
    byterevflag = 1;
    gh->magic_number = btmp;
    if (sizeof(double ) != sizeof(int32type )) {
      printf("%s: Can\'t byte reverse\n", myname);
      printf("requires size of int32type(%d) = size of double(%d)\n", (int )sizeof(int32type ),
             (int )sizeof(double ));
      terminate(1);
    }
  } else
  if (tmp == 20103) {
    byterevflag = 0;
  } else
  if (btmp == 20103) {
    byterevflag = 1;
    gh->magic_number = btmp;
    printf("Reading with byte reversal\n");
    if (sizeof(double ) != sizeof(int32type )) {
      printf("%s: Can\'t byte reverse\n", myname);
      printf("requires size of int32type(%d) = size of double(%d)\n", (int )sizeof(int32type ),
             (int )sizeof(double ));
      terminate(1);
    }
  } else {
    tmp___1 = read_v3_gauge_hdr(gf___0, parallel, & byterevflag);
    if (tmp___1 != 0) {
      tmp___2 = read_1996_gauge_hdr(gf___0, parallel, & byterevflag);
      if (tmp___2 != 0) {
        printf("%s: Unrecognized magic number in gauge configuration file header.\n",
               myname);
        printf("Expected %x but read %x\n", 20103, tmp);
        printf("Expected %s but read %s\n", (char *)20103, (char *)tmp);
        terminate(1);
      }
    }
    return (byterevflag);
  }
  if (ARCHYES == 1) {
    (gf___0->header)->order = 0;
    if (parallel) {
      fprintf(__stderrp, "%s: Must use reload_serial with archive files for now.\n",
              myname);
      terminate(1);
    }
    hdr = qcdhdr_get_hdr(fp);
    tmp___3 = qcdhdr_get_int((char *)"DIMENSION_1", hdr, dims + 0);
    if (tmp___3 == -1) {
      error_exit((char *)"DIMENSION_1 not present");
    }
    tmp___4 = qcdhdr_get_int((char *)"DIMENSION_2", hdr, dims + 1);
    if (tmp___4 == -1) {
      error_exit((char *)"DIMENSION_2 not present");
    }
    tmp___5 = qcdhdr_get_int((char *)"DIMENSION_3", hdr, dims + 2);
    if (tmp___5 == -1) {
      error_exit((char *)"DIMENSION_3 not present");
    }
    tmp___6 = qcdhdr_get_int((char *)"DIMENSION_4", hdr, dims + 3);
    if (tmp___6 == -1) {
      error_exit((char *)"DIMENSION_4 not present");
    }
    i = 0;
    while (i < 4) {
      gh->dims[i] = dims[i];
      i ++;
    }
    tmp___7 = qcdhdr_get_int32x((char *)"CHECKSUM", hdr, & chksum);
    if (tmp___7 == -1) {
      error_exit((char *)"CHECKSUM not present");
    }
    gf___0->check.sum31 = chksum;
  } else {
    tmp___8 = psread_byteorder(byterevflag, parallel, fp, (void *)(gh->dims), sizeof(gh->dims),
                               myname, (char *)"dimensions");
    if (tmp___8 != 0) {
      terminate(1);
    }
  }
  if (gh->dims[0] != nx) {
    goto _L___0;
  } else
  if (gh->dims[1] != ny) {
    goto _L___0;
  } else
  if (gh->dims[2] != nz) {
    goto _L___0;
  } else
  if (gh->dims[3] != nt) {
    _L___0: /* CIL Label */ 
    if (nx != -1) {
      goto _L;
    } else
    if (ny != -1) {
      goto _L;
    } else
    if (nz != -1) {
      goto _L;
    } else
    if (nt != -1) {
      _L: /* CIL Label */ 
      printf("%s: Incorrect lattice dimensions ", myname);
      j = 0;
      while (j < 4) {
        printf("%d ", gh->dims[j]);
        j ++;
      }
      printf("\n");
      fflush(__stdoutp);
      terminate(1);
    } else {
      nx = gh->dims[0];
      ny = gh->dims[1];
      nz = gh->dims[2];
      nt = gh->dims[3];
      volume = ((nx * ny) * nz) * nt;
    }
  }
  if (ARCHYES) {
    qcdhdr_destroy_hdr(hdr);
  } else {
    tmp___9 = psread_data(parallel, fp, (void *)(gh->time_stamp), sizeof(gh->time_stamp),
                          myname, (char *)"time stamp");
    if (tmp___9 != 0) {
      terminate(1);
    }
    gh->header_bytes = (int32type )(((sizeof(gh->magic_number) + sizeof(gh->dims)) + sizeof(gh->time_stamp)) + sizeof(gh->order));
    tmp___10 = psread_byteorder(byterevflag, parallel, fp, (void *)(& gh->order),
                                sizeof(gh->order), myname, (char *)"order parameter");
    if (tmp___10 != 0) {
      terminate(1);
    }
  }
  return (byterevflag);
}
}
gauge_file *r_serial_i(char *filename ) 
{ 
  gauge_header *gh ;
  gauge_file *gf___0 ;
  FILE *fp ;
  int byterevflag ;
  int *tmp ;

  {
  gf___0 = setup_input_gauge_file(filename);
  gh = gf___0->header;
  gf___0->parallel = 0;
  if (this_node == 0) {
    fp = fopen((char const   *)filename, "rb");
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      tmp = __error();
      printf("r_serial_i: Node %d can\'t open file %s, error %d\n", this_node, filename,
             *tmp);
      fflush(__stdoutp);
      terminate(1);
    }
    gf___0->fp = fp;
    byterevflag = read_gauge_hdr(gf___0, 0);
  } else {
    gf___0->fp = (FILE *)((void *)0);
  }
  broadcast_bytes((char *)(& byterevflag), (int )sizeof(byterevflag));
  gf___0->byterevflag = byterevflag;
  broadcast_bytes((char *)gh, (int )sizeof(gauge_header ));
  read_site_list(0, gf___0);
  return (gf___0);
}
}
void r_serial(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  char *filename ;
  int byterevflag ;
  off_t offset ;
  off_t gauge_check_size ;
  off_t coord_list_size ;
  off_t head_size ;
  off_t checksum_offset ;
  int rcv_rank ;
  int rcv_coords ;
  int destnode ;
  int i ;
  int k ;
  int x ;
  int y ;
  int z ;
  int t ;
  int buf_length ;
  int where_in_buf ;
  gauge_check test_gc ;
  u_int32type *val ;
  int rank29 ;
  int rank31 ;
  su3_matrix *lbuf ;
  char myname[9] ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
  myname[0] = (char )'r';
  myname[1] = (char )'_';
  myname[2] = (char )'s';
  myname[3] = (char )'e';
  myname[4] = (char )'r';
  myname[5] = (char )'i';
  myname[6] = (char )'a';
  myname[7] = (char )'l';
  myname[8] = (char )'\000';
  fp = gf___0->fp;
  gh = gf___0->header;
  filename = gf___0->filename;
  byterevflag = gf___0->byterevflag;
  if (this_node == 0) {
    if (gh->magic_number == 20103) {
      gauge_check_size = (off_t )(sizeof(gf___0->check.sum29) + sizeof(gf___0->check.sum31));
    } else
    if (gh->magic_number == 53546) {
      gauge_check_size = (off_t )4;
    } else {
      gauge_check_size = (off_t )0;
    }
    if ((gf___0->header)->order == 0) {
      coord_list_size = (off_t )0;
    } else {
      coord_list_size = (off_t )(sizeof(int32type ) * (unsigned long )volume);
    }
    checksum_offset = (off_t )(gf___0->header)->header_bytes + coord_list_size;
    head_size = checksum_offset + gauge_check_size;
    if (gf___0->parallel) {
      printf("%s: Attempting serial read from parallel file \n", myname);
    }
    tmp = calloc((size_t )16384, sizeof(su3_matrix ));
    lbuf = (su3_matrix *)tmp;
    if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
      printf("%s: Node %d can\'t malloc lbuf\n", myname, this_node);
      fflush(__stdoutp);
      terminate(1);
    }
    offset = head_size;
    tmp___1 = fseek(fp, (long )offset, 0);
    if (tmp___1 < 0) {
      tmp___0 = __error();
      printf("%s: Node 0 fseeko failed error %d file %s\n", myname, *tmp___0, filename);
      fflush(__stdoutp);
      terminate(1);
    }
    buf_length = 0;
    where_in_buf = 0;
  }
  test_gc.sum29 = (u_int32type )0;
  test_gc.sum31 = (u_int32type )0;
  rank29 = 0;
  rank31 = 0;
  g_sync();
  rcv_rank = 0;
  while (rcv_rank < volume) {
    if ((gf___0->header)->order == 0) {
      rcv_coords = rcv_rank;
    } else {
      rcv_coords = *(gf___0->rank2rcv + rcv_rank);
    }
    x = rcv_coords % nx;
    rcv_coords /= nx;
    y = rcv_coords % ny;
    rcv_coords /= ny;
    z = rcv_coords % nz;
    rcv_coords /= nz;
    t = rcv_coords % nt;
    destnode = node_number(x, y, z, t);
    if (this_node == 0) {
      if (where_in_buf == buf_length) {
        buf_length = volume - rcv_rank;
        if (buf_length > 4096) {
          buf_length = 4096;
        }
        tmp___3 = fread((void *)lbuf, 4UL * sizeof(su3_matrix ), (size_t )buf_length,
                        fp);
        if ((int )tmp___3 != buf_length) {
          tmp___2 = __error();
          printf("%s: node %d gauge configuration read error %d file %s\n", myname,
                 this_node, *tmp___2, filename);
          fflush(__stdoutp);
          terminate(1);
        }
        where_in_buf = 0;
      }
      if (destnode == 0) {
        i = node_index(x, y, z, t);
        tmp___5 = __builtin_object_size((void *)(& (lattice + i)->link[0]), 0);
        if (tmp___5 != 0xffffffffffffffffUL) {
          tmp___4 = __builtin_object_size((void *)(& (lattice + i)->link[0]), 0);
          __builtin___memcpy_chk((void *)(& (lattice + i)->link[0]), (void const   *)((void *)(lbuf + 4 * where_in_buf)),
                                 4UL * sizeof(su3_matrix ), tmp___4);
        } else {
          __inline_memcpy_chk((void *)(& (lattice + i)->link[0]), (void const   *)((void *)(lbuf + 4 * where_in_buf)),
                              4UL * sizeof(su3_matrix ));
        }
      } else {
        send_field((char *)(lbuf + 4 * where_in_buf), (int )(4UL * sizeof(su3_matrix )),
                   destnode);
      }
      where_in_buf ++;
    } else
    if (this_node == destnode) {
      i = node_index(x, y, z, t);
      get_field((char *)(& (lattice + i)->link[0]), (int )(4UL * sizeof(su3_matrix )));
    }
    if (this_node == destnode) {
      if (byterevflag == 1) {
        byterevn((int32type *)(& (lattice + i)->link[0]), (int )((4UL * sizeof(su3_matrix )) / sizeof(int32type )));
      }
      k = 0;
      val = (u_int32type *)(& (lattice + i)->link[0]);
      while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
        test_gc.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
        test_gc.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
        rank29 ++;
        if (rank29 >= 29) {
          rank29 = 0;
        }
        rank31 ++;
        if (rank31 >= 31) {
          rank31 = 0;
        }
        k ++;
        val ++;
      }
    } else {
      rank29 = (int )((unsigned long )rank29 + (4UL * sizeof(su3_matrix )) / sizeof(int32type ));
      rank31 = (int )((unsigned long )rank31 + (4UL * sizeof(su3_matrix )) / sizeof(int32type ));
      rank29 %= 29;
      rank31 %= 31;
    }
    rcv_rank ++;
  }
  g_xor32(& test_gc.sum29);
  g_xor32(& test_gc.sum31);
  if (this_node == 0) {
    printf("Restored binary gauge configuration serially from file %s\n", filename);
    if (gh->magic_number == 20103) {
      printf("Time stamp %s\n", gh->time_stamp);
      tmp___7 = fseek(fp, (long )checksum_offset, 0);
      if (tmp___7 < 0) {
        tmp___6 = __error();
        printf("%s: Node 0 fseeko failed error %d file %s\n", myname, *tmp___6, filename);
        fflush(__stdoutp);
        terminate(1);
      }
      read_checksum(0, gf___0, & test_gc);
    }
    fflush(__stdoutp);
    free((void *)lbuf);
  }
  return;
}
}
void r_serial_arch(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  char *filename ;
  int byterevflag ;
  off_t gauge_check_size ;
  int rcv_rank ;
  int rcv_coords ;
  int destnode ;
  int i ;
  int k ;
  int x ;
  int y ;
  int z ;
  int t ;
  gauge_check test_gc ;
  u_int32type *val ;
  int rank29 ;
  int rank31 ;
  su3_matrix tmpsu3[4] ;
  char myname[14] ;
  int mu ;
  int a ;
  int b ;
  int p ;
  double *uin ;
  double *q ;
  int big_end ;
  double U[4][18] ;
  u_int32type chksum ;
  void *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  double *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  myname[0] = (char )'r';
  myname[1] = (char )'_';
  myname[2] = (char )'s';
  myname[3] = (char )'e';
  myname[4] = (char )'r';
  myname[5] = (char )'i';
  myname[6] = (char )'a';
  myname[7] = (char )'l';
  myname[8] = (char )'_';
  myname[9] = (char )'a';
  myname[10] = (char )'r';
  myname[11] = (char )'c';
  myname[12] = (char )'h';
  myname[13] = (char )'\000';
  fp = gf___0->fp;
  gh = gf___0->header;
  filename = gf___0->filename;
  byterevflag = gf___0->byterevflag;
  if (this_node == 0) {
    gauge_check_size = (off_t )0;
    if (gf___0->parallel) {
      printf("%s: Attempting serial read from parallel file \n", myname);
    }
    big_end = big_endian();
    tmp = calloc((size_t )(((nx * ny) * nz) * 48), sizeof(double ));
    uin = (double *)tmp;
    if ((unsigned long )uin == (unsigned long )((void *)0)) {
      printf("%s: Node %d can\'t malloc uin buffer to read timeslice\n", myname, this_node);
      printf("recompile with smaller read buffer: uin\n");
      fflush(__stdoutp);
      terminate(1);
    }
  }
  chksum = (u_int32type )0;
  test_gc.sum29 = (u_int32type )0;
  test_gc.sum31 = (u_int32type )0;
  rank29 = 0;
  rank31 = 0;
  g_sync();
  rcv_rank = 0;
  while (rcv_rank < volume) {
    rcv_coords = rcv_rank;
    x = rcv_coords % nx;
    rcv_coords /= nx;
    y = rcv_coords % ny;
    rcv_coords /= ny;
    z = rcv_coords % nz;
    rcv_coords /= nz;
    t = rcv_coords % nt;
    destnode = node_number(x, y, z, t);
    if (this_node == 0) {
      tmp___1 = fread((void *)uin, 48UL * sizeof(double ), (size_t )1, fp);
      if ((int )tmp___1 != 1) {
        tmp___0 = __error();
        printf("%s: node %d gauge configuration read error %d file %s\n", myname,
               this_node, *tmp___0, filename);
        fflush(__stdoutp);
        terminate(1);
      }
      if (! big_end) {
        byterevn((int32type *)uin, 48);
      }
      q = uin;
      mu = 0;
      while (mu < 4) {
        p = 0;
        while (p < 12) {
          chksum += *((u_int32type *)q);
          tmp___2 = q;
          q ++;
          U[mu][p] = *tmp___2;
          p ++;
        }
        complete_U(U[mu]);
        a = 0;
        while (a < 3) {
          b = 0;
          while (b < 3) {
            tmpsu3[mu].e[a][b].real = U[mu][2 * (3 * a + b)];
            tmpsu3[mu].e[a][b].imag = U[mu][2 * (3 * a + b) + 1];
            b ++;
          }
          a ++;
        }
        mu ++;
      }
      if (destnode == 0) {
        i = node_index(x, y, z, t);
        tmp___4 = __builtin_object_size((void *)(& (lattice + i)->link[0]), 0);
        if (tmp___4 != 0xffffffffffffffffUL) {
          tmp___3 = __builtin_object_size((void *)(& (lattice + i)->link[0]), 0);
          __builtin___memcpy_chk((void *)(& (lattice + i)->link[0]), (void const   *)((void *)(& tmpsu3)),
                                 4UL * sizeof(su3_matrix ), tmp___3);
        } else {
          __inline_memcpy_chk((void *)(& (lattice + i)->link[0]), (void const   *)((void *)(& tmpsu3)),
                              4UL * sizeof(su3_matrix ));
        }
      } else {
        send_field((char *)(tmpsu3), (int )(4UL * sizeof(su3_matrix )), destnode);
      }
    } else
    if (this_node == destnode) {
      i = node_index(x, y, z, t);
      get_field((char *)(& (lattice + i)->link[0]), (int )(4UL * sizeof(su3_matrix )));
    }
    if (this_node == destnode) {
      k = 0;
      val = (u_int32type *)(& (lattice + i)->link[0]);
      while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
        test_gc.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
        test_gc.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
        rank29 ++;
        if (rank29 >= 29) {
          rank29 = 0;
        }
        rank31 ++;
        if (rank31 >= 31) {
          rank31 = 0;
        }
        k ++;
        val ++;
      }
    } else {
      rank29 = (int )((unsigned long )rank29 + (4UL * sizeof(su3_matrix )) / sizeof(int32type ));
      rank31 = (int )((unsigned long )rank31 + (4UL * sizeof(su3_matrix )) / sizeof(int32type ));
      rank29 %= 29;
      rank31 %= 31;
    }
    rcv_rank ++;
  }
  g_xor32(& test_gc.sum29);
  g_xor32(& test_gc.sum31);
  if (this_node == 0) {
    printf("Restored archive gauge configuration serially from file %s\n", filename);
    if (chksum != gf___0->check.sum31) {
      printf("Archive style checksum violation: computed %x, read %x\n", chksum, gf___0->check.sum31);
    } else {
      printf("Archive style checksum = %x OK\n", chksum);
    }
    fflush(__stdoutp);
    free((void *)uin);
    gf___0->check.sum29 = test_gc.sum29;
    gf___0->check.sum31 = test_gc.sum31;
  }
  return;
}
}
void r_serial_f(gauge_file *gf___0 ) 
{ 


  {
  g_sync();
  if (this_node == 0) {
    if (gf___0->parallel) {
      printf("r_serial_f: Attempting serial close on parallel file \n");
    }
    fclose(gf___0->fp);
  }
  if ((unsigned long )gf___0->rank2rcv != (unsigned long )((void *)0)) {
    free((void *)gf___0->rank2rcv);
  }
  return;
}
}
void write_site_list(FILE *fp , gauge_header *gh ) 
{ 
  off_t offset ;
  int i ;
  int buf_length ;
  register site *s ;
  int32type coords ;
  int32type *cbuf ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;

  {
  offset = (off_t )((unsigned long )gh->header_bytes + (sizeof(int32type ) * (unsigned long )sites_on_node) * (unsigned long )this_node);
  tmp = calloc((size_t )sites_on_node, sizeof(int32type ));
  cbuf = (int32type *)tmp;
  if ((unsigned long )cbuf == (unsigned long )((void *)0)) {
    printf("write_site_list: node %d can\'t malloc cbuf\n", this_node);
    fflush(__stdoutp);
    terminate(1);
  }
  tmp___1 = g_seek(fp, offset, 0);
  if (tmp___1 < 0) {
    tmp___0 = __error();
    printf("write_site_list: node %d g_seek %ld failed errno %d\n", this_node, (long )offset,
           *tmp___0);
    fflush(__stdoutp);
    terminate(1);
  }
  buf_length = 0;
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    coords = nx * (ny * (nz * (int )s->t + (int )s->z) + (int )s->y) + (int )s->x;
    *(cbuf + buf_length) = coords;
    buf_length ++;
    i ++;
    s ++;
  }
  tmp___3 = g_write((void const   *)cbuf, sizeof(int32type ), (size_t )sites_on_node,
                    fp);
  if ((int )tmp___3 != sites_on_node) {
    tmp___2 = __error();
    printf("write_site_list: Node %d coords write error %d\n", this_node, *tmp___2);
    fflush(__stdoutp);
    terminate(1);
  }
  free((void *)cbuf);
  return;
}
}
gauge_file *parallel_open(int order , char *filename ) 
{ 
  FILE *fp ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  int *tmp ;

  {
  gf___0 = setup_output_gauge_file();
  gh = gf___0->header;
  gh->order = order;
  fp = g_open((char const   *)filename, "wb");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    tmp = __error();
    printf("parallel_open: Node %d can\'t open file %s, error %d\n", this_node, filename,
           *tmp);
    fflush(__stdoutp);
    terminate(1);
  }
  if (this_node == 0) {
    pwrite_gauge_hdr(fp, gh);
  }
  broadcast_bytes((char *)(& gh->header_bytes), (int )sizeof(gh->header_bytes));
  if (order != 0) {
    write_site_list(fp, gh);
  }
  gf___0->fp = fp;
  gf___0->filename = filename;
  gf___0->byterevflag = 0;
  gf___0->parallel = 1;
  return (gf___0);
}
}
gauge_file *w_parallel_i(char *filename ) 
{ 
  gauge_file *tmp ;

  {
  tmp = parallel_open(0, filename);
  return (tmp);
}
}
gauge_file *w_checkpoint_i(char *filename ) 
{ 
  gauge_file *tmp ;

  {
  tmp = parallel_open(1, filename);
  return (tmp);
}
}
su3_matrix *w_parallel_setup(gauge_file *gf___0 , off_t *checksum_offset ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  su3_matrix *lbuf ;
  off_t offset ;
  off_t gauge_node_size ;
  off_t coord_list_size ;
  off_t head_size ;
  off_t gauge_check_size ;
  char myname[17] ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  myname[0] = (char )'w';
  myname[1] = (char )'_';
  myname[2] = (char )'p';
  myname[3] = (char )'a';
  myname[4] = (char )'r';
  myname[5] = (char )'a';
  myname[6] = (char )'l';
  myname[7] = (char )'l';
  myname[8] = (char )'e';
  myname[9] = (char )'l';
  myname[10] = (char )'_';
  myname[11] = (char )'s';
  myname[12] = (char )'e';
  myname[13] = (char )'t';
  myname[14] = (char )'u';
  myname[15] = (char )'p';
  myname[16] = (char )'\000';
  if (! gf___0->parallel) {
    printf("%s: Attempting parallel write to serial file.\n", myname);
  }
  tmp = calloc((size_t )16384, sizeof(su3_matrix ));
  lbuf = (su3_matrix *)tmp;
  if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
    printf("%s: Node %d can\'t malloc lbuf\n", myname, this_node);
    fflush(__stdoutp);
    terminate(1);
  }
  fp = gf___0->fp;
  gh = gf___0->header;
  gauge_node_size = (off_t )((unsigned long )(sites_on_node * 4) * sizeof(su3_matrix ));
  if ((gf___0->header)->order == 0) {
    coord_list_size = (off_t )0;
  } else {
    coord_list_size = (off_t )(sizeof(int32type ) * (unsigned long )volume);
  }
  head_size = (off_t )(gf___0->header)->header_bytes + coord_list_size;
  *checksum_offset = head_size;
  gauge_check_size = (off_t )(sizeof(gf___0->check.sum29) + sizeof(gf___0->check.sum31));
  offset = head_size + gauge_check_size;
  offset += gauge_node_size * (off_t )this_node;
  tmp___1 = g_seek(fp, offset, 0);
  if (tmp___1 < 0) {
    tmp___0 = __error();
    printf("%s: Node %d g_seek %ld failed error %d file %s\n", myname, this_node,
           (long )offset, *tmp___0, gf___0->filename);
    fflush(__stdoutp);
    terminate(1);
  }
  return (lbuf);
}
}
void w_parallel(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  su3_matrix *lbuf ;
  int buf_length ;
  int where_in_buf ;
  u_int32type *val ;
  int rank29 ;
  int rank31 ;
  off_t checksum_offset ;
  register int i ;
  int j ;
  int k ;
  int x ;
  int y ;
  int z ;
  int t ;
  struct __anonstruct_msg_41 msg ;
  int isite ;
  int ksite ;
  int site_block ;
  int rcv_coords ;
  int rcv_rank ;
  int destnode ;
  int sendnode ;
  char myname[11] ;
  double tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int *tmp___6 ;
  size_t tmp___7 ;
  double tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
  myname[0] = (char )'w';
  myname[1] = (char )'_';
  myname[2] = (char )'p';
  myname[3] = (char )'a';
  myname[4] = (char )'r';
  myname[5] = (char )'a';
  myname[6] = (char )'l';
  myname[7] = (char )'l';
  myname[8] = (char )'e';
  myname[9] = (char )'l';
  myname[10] = (char )'\000';
  fp = gf___0->fp;
  lbuf = w_parallel_setup(gf___0, & checksum_offset);
  gf___0->check.sum31 = (u_int32type )0;
  gf___0->check.sum29 = (u_int32type )0;
  g_sync();
  buf_length = 0;
  i = 0;
  while (i < 4096) {
    j = 0;
    while (j < 3) {
      k = 0;
      while (k < 3) {
        tmp = 0.;
        (lbuf + i)->e[j][k].imag = tmp;
        (lbuf + i)->e[j][k].real = tmp;
        k ++;
      }
      j ++;
    }
    i ++;
  }
  site_block = 4096;
  if (4096 % site_block != 0) {
    printf("%s: site_block incommensurate with buffer size\n", myname);
    fflush(__stdoutp);
    terminate(1);
  }
  ksite = 0;
  while (ksite < sites_on_node) {
    destnode = 0;
    while (destnode < number_of_nodes) {
      isite = ksite;
      while (1) {
        if (isite < sites_on_node) {
          if (! (isite < ksite + site_block)) {
            break;
          }
        } else {
          break;
        }
        rcv_coords = destnode * sites_on_node + isite;
        rcv_rank = rcv_coords;
        x = rcv_coords % nx;
        rcv_coords /= nx;
        y = rcv_coords % ny;
        rcv_coords /= ny;
        z = rcv_coords % nz;
        rcv_coords /= nz;
        t = rcv_coords % nt;
        sendnode = node_number(x, y, z, t);
        if (this_node == sendnode) {
          if (destnode != sendnode) {
            msg.x = (short )x;
            msg.y = (short )y;
            msg.z = (short )z;
            msg.t = (short )t;
            i = node_index(x, y, z, t);
            tmp___1 = __builtin_object_size((void *)(msg.link), 0);
            if (tmp___1 != 0xffffffffffffffffUL) {
              tmp___0 = __builtin_object_size((void *)(msg.link), 0);
              __builtin___memcpy_chk((void *)(msg.link), (void const   *)((void *)((lattice + i)->link)),
                                     4UL * sizeof(su3_matrix ), tmp___0);
            } else {
              __inline_memcpy_chk((void *)(msg.link), (void const   *)((void *)((lattice + i)->link)),
                                  4UL * sizeof(su3_matrix ));
            }
            send_field((char *)(& msg), (int )sizeof(msg), destnode);
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (this_node == destnode) {
          if (destnode == sendnode) {
            i = node_index(x, y, z, t);
            where_in_buf = buf_length;
            tmp___3 = __builtin_object_size((void *)(lbuf + 4 * where_in_buf), 0);
            if (tmp___3 != 0xffffffffffffffffUL) {
              tmp___2 = __builtin_object_size((void *)(lbuf + 4 * where_in_buf), 0);
              __builtin___memcpy_chk((void *)(lbuf + 4 * where_in_buf), (void const   *)((void *)((lattice + i)->link)),
                                     4UL * sizeof(su3_matrix ), tmp___2);
            } else {
              __inline_memcpy_chk((void *)(lbuf + 4 * where_in_buf), (void const   *)((void *)((lattice + i)->link)),
                                  4UL * sizeof(su3_matrix ));
            }
            rank31 = (int )(((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )rcv_rank);
            rank29 = rank31;
          } else {
            get_field((char *)(& msg), (int )sizeof(msg));
            i = (int )msg.x + nx * ((int )msg.y + ny * ((int )msg.z + nz * (int )msg.t));
            where_in_buf = (i % sites_on_node) % 4096;
            tmp___5 = __builtin_object_size((void *)(lbuf + 4 * where_in_buf), 0);
            if (tmp___5 != 0xffffffffffffffffUL) {
              tmp___4 = __builtin_object_size((void *)(lbuf + 4 * where_in_buf), 0);
              __builtin___memcpy_chk((void *)(lbuf + 4 * where_in_buf), (void const   *)((void *)(msg.link)),
                                     4UL * sizeof(su3_matrix ), tmp___4);
            } else {
              __inline_memcpy_chk((void *)(lbuf + 4 * where_in_buf), (void const   *)((void *)(msg.link)),
                                  4UL * sizeof(su3_matrix ));
            }
            rank31 = (int )(((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )i);
            rank29 = rank31;
          }
          rank29 %= 29;
          rank31 %= 31;
          k = 0;
          val = (u_int32type *)(lbuf + 4 * where_in_buf);
          while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
            gf___0->check.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
            gf___0->check.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
            rank29 ++;
            if (rank29 >= 29) {
              rank29 = 0;
            }
            rank31 ++;
            if (rank31 >= 31) {
              rank31 = 0;
            }
            k ++;
            val ++;
          }
          buf_length ++;
          if (buf_length == 4096) {
            goto _L;
          } else
          if (isite == sites_on_node - 1) {
            _L: /* CIL Label */ 
            tmp___7 = g_write((void const   *)lbuf, 4UL * sizeof(su3_matrix ), (size_t )buf_length,
                              fp);
            if ((int )tmp___7 != buf_length) {
              tmp___6 = __error();
              printf("%s: Node %d gauge configuration write error %d file %s\n", myname,
                     this_node, *tmp___6, gf___0->filename);
              fflush(__stdoutp);
              terminate(1);
            }
            buf_length = 0;
            i = 0;
            while (i < 4096) {
              j = 0;
              while (j < 3) {
                k = 0;
                while (k < 3) {
                  tmp___8 = 0.;
                  (lbuf + i)->e[j][k].imag = tmp___8;
                  (lbuf + i)->e[j][k].real = tmp___8;
                  k ++;
                }
                j ++;
              }
              i ++;
            }
          }
        }
        isite ++;
      }
      destnode ++;
    }
    g_sync();
    ksite += site_block;
  }
  free((void *)lbuf);
  g_xor32(& gf___0->check.sum29);
  g_xor32(& gf___0->check.sum31);
  if (this_node == 0) {
    tmp___10 = g_seek(fp, checksum_offset, 0);
    if (tmp___10 < 0) {
      tmp___9 = __error();
      printf("%s: Node %d g_seek %ld for checksum failed error %d file %s\n", myname,
             this_node, (long )checksum_offset, *tmp___9, gf___0->filename);
      fflush(__stdoutp);
      terminate(1);
    }
    write_checksum(1, gf___0);
    printf("Saved gauge configuration in parallel to binary file %s\n", gf___0->filename);
    printf("Time stamp %s\n", (gf___0->header)->time_stamp);
  }
  return;
}
}
void w_checkpoint(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  su3_matrix *lbuf ;
  u_int32type *val ;
  int k ;
  int rank29 ;
  int rank31 ;
  off_t checksum_offset ;
  int buf_length ;
  register site *s ;
  register int i ;
  char myname[13] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  myname[0] = (char )'w';
  myname[1] = (char )'_';
  myname[2] = (char )'c';
  myname[3] = (char )'h';
  myname[4] = (char )'e';
  myname[5] = (char )'c';
  myname[6] = (char )'k';
  myname[7] = (char )'p';
  myname[8] = (char )'o';
  myname[9] = (char )'i';
  myname[10] = (char )'n';
  myname[11] = (char )'t';
  myname[12] = (char )'\000';
  fp = gf___0->fp;
  lbuf = w_parallel_setup(gf___0, & checksum_offset);
  gf___0->check.sum31 = (u_int32type )0;
  gf___0->check.sum29 = (u_int32type )0;
  rank29 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 29UL);
  rank31 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 31UL);
  buf_length = 0;
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    tmp___0 = __builtin_object_size((void *)(lbuf + 4 * buf_length), 0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)(lbuf + 4 * buf_length), 0);
      __builtin___memcpy_chk((void *)(lbuf + 4 * buf_length), (void const   *)((void *)((lattice + i)->link)),
                             4UL * sizeof(su3_matrix ), tmp);
    } else {
      __inline_memcpy_chk((void *)(lbuf + 4 * buf_length), (void const   *)((void *)((lattice + i)->link)),
                          4UL * sizeof(su3_matrix ));
    }
    k = 0;
    val = (u_int32type *)(lbuf + 4 * buf_length);
    while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
      gf___0->check.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
      gf___0->check.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
      rank29 ++;
      if (rank29 >= 29) {
        rank29 = 0;
      }
      rank31 ++;
      if (rank31 >= 31) {
        rank31 = 0;
      }
      k ++;
      val ++;
    }
    buf_length ++;
    if (buf_length == 4096) {
      goto _L;
    } else
    if (i == sites_on_node - 1) {
      _L: /* CIL Label */ 
      fflush(__stdoutp);
      tmp___2 = g_write((void const   *)lbuf, 4UL * sizeof(su3_matrix ), (size_t )buf_length,
                        fp);
      if ((int )tmp___2 != buf_length) {
        tmp___1 = __error();
        printf("%s: Node %d gauge configuration write error %d file %s\n", myname,
               this_node, *tmp___1, gf___0->filename);
        fflush(__stdoutp);
        terminate(1);
      }
      buf_length = 0;
    }
    i ++;
    s ++;
  }
  free((void *)lbuf);
  g_xor32(& gf___0->check.sum29);
  g_xor32(& gf___0->check.sum31);
  if (this_node == 0) {
    tmp___4 = g_seek(fp, checksum_offset, 0);
    if (tmp___4 < 0) {
      tmp___3 = __error();
      printf("%s: Node %d g_seek %ld for checksum failed error %d file %s\n", myname,
             this_node, (long )checksum_offset, *tmp___3, gf___0->filename);
      fflush(__stdoutp);
      terminate(1);
    }
    write_checksum(1, gf___0);
    printf("Saved gauge configuration checkpoint file %s\n", gf___0->filename);
    printf("Time stamp %s\n", (gf___0->header)->time_stamp);
  }
  return;
}
}
void w_parallel_f(gauge_file *gf___0 ) 
{ 


  {
  g_sync();
  if ((unsigned long )gf___0->fp != (unsigned long )((void *)0)) {
    if (! gf___0->parallel) {
      printf("w_parallel_f: Attempting parallel close on serial file.\n");
    }
    g_close(gf___0->fp);
    gf___0->fp = (FILE *)((void *)0);
  }
  if (this_node == 0) {
    write_gauge_info_file(gf___0);
  }
  return;
}
}
gauge_file *r_parallel_i(char *filename ) 
{ 
  gauge_header *gh ;
  gauge_file *gf___0 ;
  FILE *fp ;
  int byterevflag ;
  int *tmp ;

  {
  gf___0 = setup_input_gauge_file(filename);
  gh = gf___0->header;
  gf___0->parallel = 1;
  fp = g_open((char const   *)filename, "rb");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    tmp = __error();
    printf("r_parallel_i: Node %d can\'t open file %s, error %d\n", this_node, filename,
           *tmp);
    fflush(__stdoutp);
    terminate(1);
  }
  gf___0->fp = fp;
  if (this_node == 0) {
    byterevflag = read_gauge_hdr(gf___0, 1);
  }
  broadcast_bytes((char *)(& byterevflag), (int )sizeof(byterevflag));
  gf___0->byterevflag = byterevflag;
  broadcast_bytes((char *)gh, (int )sizeof(gauge_header ));
  read_site_list(1, gf___0);
  return (gf___0);
}
}
void r_parallel(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  char *filename ;
  int byterevflag ;
  su3_matrix *lbuf ;
  struct __anonstruct_msg_42 msg ;
  int buf_length ;
  int where_in_buf ;
  gauge_check test_gc ;
  u_int32type *val ;
  int rank29 ;
  int rank31 ;
  int destnode ;
  int sendnode ;
  int isite ;
  int ksite ;
  int site_block ;
  int x ;
  int y ;
  int z ;
  int t ;
  int rcv_rank ;
  int rcv_coords ;
  register int i ;
  register int k ;
  off_t offset ;
  off_t gauge_node_size ;
  off_t gauge_check_size ;
  off_t coord_list_size ;
  off_t head_size ;
  off_t checksum_offset ;
  char myname[11] ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;

  {
  myname[0] = (char )'r';
  myname[1] = (char )'_';
  myname[2] = (char )'p';
  myname[3] = (char )'a';
  myname[4] = (char )'r';
  myname[5] = (char )'a';
  myname[6] = (char )'l';
  myname[7] = (char )'l';
  myname[8] = (char )'e';
  myname[9] = (char )'l';
  myname[10] = (char )'\000';
  fp = gf___0->fp;
  gh = gf___0->header;
  filename = gf___0->filename;
  byterevflag = gf___0->byterevflag;
  if (! gf___0->parallel) {
    printf("%s: Attempting parallel read from serial file.\n", myname);
  }
  tmp = calloc((size_t )16384, sizeof(su3_matrix ));
  lbuf = (su3_matrix *)tmp;
  if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
    printf("%s: Node %d can\'t malloc lbuf\n", myname, this_node);
    fflush(__stdoutp);
    terminate(1);
  }
  gauge_node_size = (off_t )((unsigned long )(sites_on_node * 4) * sizeof(su3_matrix ));
  if (gh->magic_number == 20103) {
    gauge_check_size = (off_t )(sizeof(gf___0->check.sum29) + sizeof(gf___0->check.sum31));
  } else
  if (gh->magic_number == 53546) {
    gauge_check_size = (off_t )4;
  } else {
    gauge_check_size = (off_t )0;
  }
  if ((gf___0->header)->order == 0) {
    coord_list_size = (off_t )0;
  } else {
    coord_list_size = (off_t )(sizeof(int32type ) * (unsigned long )volume);
  }
  checksum_offset = (off_t )(gf___0->header)->header_bytes + coord_list_size;
  head_size = checksum_offset + gauge_check_size;
  offset = head_size;
  offset += gauge_node_size * (off_t )this_node;
  tmp___1 = g_seek(fp, offset, 0);
  if (tmp___1 < 0) {
    tmp___0 = __error();
    printf("%s: Node %d g_seek %ld failed error %d file %s\n", myname, this_node,
           (long )offset, *tmp___0, filename);
    fflush(__stdoutp);
    terminate(1);
  }
  test_gc.sum29 = (u_int32type )0;
  test_gc.sum31 = (u_int32type )0;
  rank29 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 29UL);
  rank31 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 31UL);
  g_sync();
  buf_length = 0;
  where_in_buf = 0;
  site_block = 4;
  ksite = 0;
  while (ksite < sites_on_node) {
    sendnode = 0;
    while (sendnode < number_of_nodes) {
      isite = ksite;
      while (1) {
        if (isite < sites_on_node) {
          if (! (isite < ksite + site_block)) {
            break;
          }
        } else {
          break;
        }
        rcv_rank = sendnode * sites_on_node + isite;
        if ((gf___0->header)->order == 0) {
          rcv_coords = rcv_rank;
        } else {
          rcv_coords = *(gf___0->rank2rcv + rcv_rank);
        }
        x = rcv_coords % nx;
        rcv_coords /= nx;
        y = rcv_coords % ny;
        rcv_coords /= ny;
        z = rcv_coords % nz;
        rcv_coords /= nz;
        t = rcv_coords % nt;
        destnode = node_number(x, y, z, t);
        if (this_node == sendnode) {
          if (where_in_buf == buf_length) {
            buf_length = sites_on_node - isite;
            if (buf_length > 4096) {
              buf_length = 4096;
            }
            tmp___3 = g_read((void *)lbuf, (unsigned long )(buf_length * 4) * sizeof(su3_matrix ),
                             (size_t )1, fp);
            if (tmp___3 != 1UL) {
              tmp___2 = __error();
              printf("%s: node %d gauge configuration read error %d file %s\n", myname,
                     this_node, *tmp___2, filename);
              fflush(__stdoutp);
              terminate(1);
            }
            where_in_buf = 0;
          }
          if (gf___0->byterevflag == 1) {
            byterevn((int32type *)(lbuf + 4 * where_in_buf), (int )((4UL * sizeof(su3_matrix )) / sizeof(int32type )));
          }
          k = 0;
          val = (u_int32type *)(lbuf + 4 * where_in_buf);
          while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
            test_gc.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
            test_gc.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
            rank29 ++;
            if (rank29 >= 29) {
              rank29 = 0;
            }
            rank31 ++;
            if (rank31 >= 31) {
              rank31 = 0;
            }
            k ++;
            val ++;
          }
          if (destnode == sendnode) {
            i = node_index(x, y, z, t);
            tmp___5 = __builtin_object_size((void *)((lattice + i)->link), 0);
            if (tmp___5 != 0xffffffffffffffffUL) {
              tmp___4 = __builtin_object_size((void *)((lattice + i)->link), 0);
              __builtin___memcpy_chk((void *)((lattice + i)->link), (void const   *)((void *)(lbuf + 4 * where_in_buf)),
                                     4UL * sizeof(su3_matrix ), tmp___4);
            } else {
              __inline_memcpy_chk((void *)((lattice + i)->link), (void const   *)((void *)(lbuf + 4 * where_in_buf)),
                                  4UL * sizeof(su3_matrix ));
            }
          } else {
            msg.x = (short )x;
            msg.y = (short )y;
            msg.z = (short )z;
            msg.t = (short )t;
            tmp___7 = __builtin_object_size((void *)(msg.link), 0);
            if (tmp___7 != 0xffffffffffffffffUL) {
              tmp___6 = __builtin_object_size((void *)(msg.link), 0);
              __builtin___memcpy_chk((void *)(msg.link), (void const   *)((void *)(lbuf + 4 * where_in_buf)),
                                     4UL * sizeof(su3_matrix ), tmp___6);
            } else {
              __inline_memcpy_chk((void *)(msg.link), (void const   *)((void *)(lbuf + 4 * where_in_buf)),
                                  4UL * sizeof(su3_matrix ));
            }
            send_field((char *)(& msg), (int )sizeof(msg), destnode);
          }
          where_in_buf ++;
        } else
        if (this_node == destnode) {
          get_field((char *)(& msg), (int )sizeof(msg));
          i = node_index((int )msg.x, (int )msg.y, (int )msg.z, (int )msg.t);
          tmp___8 = node_number((int )msg.x, (int )msg.y, (int )msg.z, (int )msg.t);
          if (this_node != tmp___8) {
            printf("BOTCH. Node %d received %d %d %d %d\n", this_node, (int )msg.x,
                   (int )msg.y, (int )msg.z, (int )msg.t);
            fflush(__stdoutp);
            terminate(1);
          }
          tmp___10 = __builtin_object_size((void *)((lattice + i)->link), 0);
          if (tmp___10 != 0xffffffffffffffffUL) {
            tmp___9 = __builtin_object_size((void *)((lattice + i)->link), 0);
            __builtin___memcpy_chk((void *)((lattice + i)->link), (void const   *)((void *)(msg.link)),
                                   4UL * sizeof(su3_matrix ), tmp___9);
          } else {
            __inline_memcpy_chk((void *)((lattice + i)->link), (void const   *)((void *)(msg.link)),
                                4UL * sizeof(su3_matrix ));
          }
        }
        isite ++;
      }
      sendnode ++;
    }
    g_sync();
    ksite += site_block;
  }
  free((void *)lbuf);
  g_xor32(& test_gc.sum29);
  g_xor32(& test_gc.sum31);
  if (this_node == 0) {
    printf("Restored binary gauge configuration in parallel from file %s\n", filename);
    if (gh->magic_number == 20103) {
      printf("Time stamp %s\n", gh->time_stamp);
      tmp___12 = g_seek(fp, checksum_offset, 0);
      if (tmp___12 < 0) {
        tmp___11 = __error();
        printf("%s: Node 0 g_seek %ld for checksum failed error %d file %s\n", myname,
               (long )offset, *tmp___11, filename);
        fflush(__stdoutp);
        terminate(1);
      }
      read_checksum(1, gf___0, & test_gc);
    }
    fflush(__stdoutp);
  }
  return;
}
}
void r_parallel_f(gauge_file *gf___0 ) 
{ 


  {
  g_sync();
  if ((unsigned long )gf___0->fp != (unsigned long )((void *)0)) {
    if (! gf___0->parallel) {
      printf("r_parallel_f: Attempting parallel close on serial file.\n");
    }
    g_close(gf___0->fp);
    gf___0->fp = (FILE *)((void *)0);
  }
  return;
}
}
gauge_file *restore_ascii(char *filename ) 
{ 
  gauge_header *gh ;
  gauge_file *gf___0 ;
  FILE *fp ;
  int destnode ;
  int version_number ;
  int i ;
  int j ;
  int x ;
  int y ;
  int z ;
  int t ;
  int dir ;
  su3_matrix lbuf[4] ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  gf___0 = setup_input_gauge_file(filename);
  gh = gf___0->header;
  gf___0->parallel = 0;
  if (this_node == 0) {
    fp = fopen((char const   *)filename, "r");
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      tmp = __error();
      printf("Can\'t open file %s, error %d\n", filename, *tmp);
      terminate(1);
    }
    gf___0->fp = fp;
    tmp___0 = fscanf(fp, "%d", & version_number);
    if (tmp___0 != 1) {
      printf("restore_ascii: Error reading version number\n");
      terminate(1);
    }
    gh->magic_number = version_number;
    if (gh->magic_number != 20103) {
      printf("restore_ascii: Incorrect version number in lattice header\n");
      printf("  read %d but expected %d\n", gh->magic_number, 20103);
      terminate(1);
    }
    i = fscanf(fp, "%*[ \f\n\r\t\v]%*[\"]%[^\"]%*[\"]", gh->time_stamp);
    if (i != 1) {
      printf("restore_ascii: Error reading time stamp\n");
      printf("count %d time_stamp %s\n", i, gh->time_stamp);
      terminate(1);
    }
    tmp___1 = fscanf(fp, "%d%d%d%d", & x, & y, & z, & t);
    if (tmp___1 != 4) {
      printf("restore_ascii: Error in reading dimensions\n");
      terminate(1);
    }
    gh->dims[0] = x;
    gh->dims[1] = y;
    gh->dims[2] = z;
    gh->dims[3] = t;
    if (gh->dims[0] != nx) {
      goto _L;
    } else
    if (gh->dims[1] != ny) {
      goto _L;
    } else
    if (gh->dims[2] != nz) {
      goto _L;
    } else
    if (gh->dims[3] != nt) {
      _L: /* CIL Label */ 
      if (nx != -1) {
        printf("restore_ascii: Incorrect lattice size %d,%d,%d,%d\n", gh->dims[0],
               gh->dims[1], gh->dims[2], gh->dims[3]);
        terminate(1);
      } else
      if (ny != -1) {
        printf("restore_ascii: Incorrect lattice size %d,%d,%d,%d\n", gh->dims[0],
               gh->dims[1], gh->dims[2], gh->dims[3]);
        terminate(1);
      } else
      if (nz != -1) {
        printf("restore_ascii: Incorrect lattice size %d,%d,%d,%d\n", gh->dims[0],
               gh->dims[1], gh->dims[2], gh->dims[3]);
        terminate(1);
      } else
      if (nt != -1) {
        printf("restore_ascii: Incorrect lattice size %d,%d,%d,%d\n", gh->dims[0],
               gh->dims[1], gh->dims[2], gh->dims[3]);
        terminate(1);
      } else {
        nx = gh->dims[0];
        ny = gh->dims[1];
        nz = gh->dims[2];
        nt = gh->dims[3];
        volume = ((nx * ny) * nz) * nt;
      }
    }
    gh->order = 0;
  } else {
    gf___0->fp = (FILE *)((void *)0);
  }
  gf___0->byterevflag = 0;
  broadcast_bytes((char *)gh, (int )sizeof(gauge_header ));
  g_sync();
  t = 0;
  while (t < nt) {
    z = 0;
    while (z < nz) {
      y = 0;
      while (y < ny) {
        x = 0;
        while (x < nx) {
          destnode = node_number(x, y, z, t);
          if (this_node == 0) {
            dir = 0;
            while (dir <= 3) {
              i = 0;
              while (i < 3) {
                j = 0;
                while (j < 3) {
                  tmp___2 = fscanf(fp, "%lf%lf\n", & lbuf[dir].e[i][j].real, & lbuf[dir].e[i][j].imag);
                  if (tmp___2 != 2) {
                    printf("restore_ascii: gauge link read error\n");
                    terminate(1);
                  }
                  j ++;
                }
                i ++;
              }
              dir ++;
            }
            if (destnode == 0) {
              i = node_index(x, y, z, t);
              dir = 0;
              while (dir <= 3) {
                (lattice + i)->link[dir] = lbuf[dir];
                dir ++;
              }
            } else {
              send_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )), destnode);
            }
          } else
          if (this_node == destnode) {
            get_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )));
            i = node_index(x, y, z, t);
            dir = 0;
            while (dir <= 3) {
              (lattice + i)->link[dir] = lbuf[dir];
              dir ++;
            }
          }
          x ++;
        }
        y ++;
      }
      z ++;
    }
    t ++;
  }
  g_sync();
  if (this_node == 0) {
    printf("Restored gauge configuration from ascii file  %s\n", filename);
    printf("Time stamp %s\n", gh->time_stamp);
    fclose(fp);
    gf___0->fp = (FILE *)((void *)0);
    fflush(__stdoutp);
  }
  return (gf___0);
}
}
gauge_file *save_ascii(char *filename ) 
{ 
  FILE *fp ;
  int currentnode ;
  int newnode ;
  int i ;
  int j ;
  int x ;
  int y ;
  int z ;
  int t ;
  int dir ;
  su3_matrix lbuf[4] ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  gf___0 = setup_output_gauge_file();
  gh = gf___0->header;
  if (this_node == 0) {
    fp = fopen((char const   *)filename, "w");
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      tmp = __error();
      printf("Can\'t open file %s, error %d\n", filename, *tmp);
      terminate(1);
    }
    gf___0->fp = fp;
    gf___0->parallel = 0;
    gf___0->filename = filename;
    gf___0->byterevflag = 0;
    tmp___0 = fprintf(fp, "%d\n", 20103);
    if (tmp___0 == 0) {
      printf("Error in writing version number\n");
      terminate(1);
    }
    tmp___1 = fprintf(fp, "\"%s\"\n", gh->time_stamp);
    if (tmp___1 == 0) {
      printf("Error in writing time stamp\n");
      terminate(1);
    }
    tmp___2 = fprintf(fp, "%d\t%d\t%d\t%d\n", nx, ny, nz, nt);
    if (tmp___2 == 0) {
      printf("Error in writing dimensions\n");
      terminate(1);
    }
    write_gauge_info_file(gf___0);
  }
  g_sync();
  currentnode = 0;
  t = 0;
  while (t < nt) {
    z = 0;
    while (z < nz) {
      y = 0;
      while (y < ny) {
        x = 0;
        while (x < nx) {
          newnode = node_number(x, y, z, t);
          if (newnode != currentnode) {
            if (this_node == 0) {
              if (newnode != 0) {
                send_field((char *)(lbuf), 4, newnode);
              }
            }
            if (this_node == newnode) {
              if (newnode != 0) {
                get_field((char *)(lbuf), 4);
              }
            }
            currentnode = newnode;
          }
          if (this_node == 0) {
            if (currentnode == 0) {
              i = node_index(x, y, z, t);
              dir = 0;
              while (dir <= 3) {
                lbuf[dir] = (lattice + i)->link[dir];
                dir ++;
              }
            } else {
              get_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )));
            }
            dir = 0;
            while (dir <= 3) {
              i = 0;
              while (i < 3) {
                j = 0;
                while (j < 3) {
                  tmp___3 = fprintf(fp, "%.7e\t%.7e\n", lbuf[dir].e[i][j].real, lbuf[dir].e[i][j].imag);
                  if (tmp___3 == -1) {
                    printf("Write error in save_ascii\n");
                    terminate(1);
                  }
                  j ++;
                }
                i ++;
              }
              dir ++;
            }
          } else
          if (this_node == currentnode) {
            i = node_index(x, y, z, t);
            dir = 0;
            while (dir <= 3) {
              lbuf[dir] = (lattice + i)->link[dir];
              dir ++;
            }
            send_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )), 0);
          }
          x ++;
        }
        y ++;
      }
      z ++;
    }
    t ++;
  }
  g_sync();
  if (this_node == 0) {
    fflush(fp);
    printf("Saved gauge configuration to ascii file %s\n", gf___0->filename);
    printf("Time stamp %s\n", gh->time_stamp);
    fclose(fp);
    fflush(__stdoutp);
  }
  return (gf___0);
}
}
gauge_file *restore_serial(char *filename ) 
{ 
  gauge_file *gf___0 ;

  {
  gf___0 = r_serial_i(filename);
  if ((gf___0->header)->magic_number == 1111836489) {
    r_serial_arch(gf___0);
  } else {
    r_serial(gf___0);
  }
  r_serial_f(gf___0);
  return (gf___0);
}
}
gauge_file *restore_parallel(char *filename ) 
{ 
  gauge_file *gf___0 ;

  {
  gf___0 = r_parallel_i(filename);
  r_parallel(gf___0);
  r_parallel_f(gf___0);
  return (gf___0);
}
}
gauge_file *save_serial(char *filename ) 
{ 
  gauge_file *gf___0 ;

  {
  gf___0 = w_serial_i(filename);
  w_serial(gf___0);
  w_serial_f(gf___0);
  return (gf___0);
}
}
gauge_file *save_parallel(char *filename ) 
{ 
  gauge_file *gf___0 ;

  {
  gf___0 = w_parallel_i(filename);
  w_parallel(gf___0);
  w_parallel_f(gf___0);
  return (gf___0);
}
}
gauge_file *save_checkpoint(char *filename ) 
{ 
  gauge_file *gf___0 ;

  {
  gf___0 = w_checkpoint_i(filename);
  w_checkpoint(gf___0);
  w_parallel_f(gf___0);
  return (gf___0);
}
}
gauge_file *save_serial_archive(char *filename ) 
{ 
  int currentnode ;
  int newnode ;
  int i ;
  int j ;
  int x ;
  int y ;
  int z ;
  int dir ;
  su3_matrix lbuf[4] ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  FILE *outfile ;
  site *s ;
  u_int32type chksum ;
  u_int32type utmp ;
  u_int32type *p32 ;
  char sums[30] ;
  OUTPUT_TYPE *uout ;
  int big_end_p ;
  double ssplaq ;
  double stplaq ;
  double avgtrace ;
  double avgplaq ;
  double tmpflt ;
  double trace ;
  int mu ;
  int a ;
  int b ;
  int vol3 ;
  int tslice ;
  complex tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
  big_end_p = big_endian();
  gf___0 = setup_output_gauge_file();
  gh = gf___0->header;
  d_plaquette(& ssplaq, & stplaq);
  avgplaq = (ssplaq + stplaq) / 6.0;
  trace = 0.0;
  chksum = (u_int32type )0;
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    mu = 0;
    while (mu < 4) {
      tmp = trace_su3(& s->link[mu]);
      trace += tmp.real;
      a = 0;
      while (a < 2) {
        b = 0;
        while (b < 3) {
          tmpflt = s->link[mu].e[a][b].real;
          p32 = (u_int32type *)(& tmpflt);
          chksum += *p32;
          tmpflt = s->link[mu].e[a][b].imag;
          p32 = (u_int32type *)(& tmpflt);
          chksum += *p32;
          b ++;
        }
        a ++;
      }
      mu ++;
    }
    i ++;
    s ++;
  }
  g_doublesum(& trace);
  avgtrace = trace / (double )(volume * 12);
  j = 1;
  while (1) {
    tmp___0 = numnodes();
    if (! (j < tmp___0)) {
      break;
    }
    if (this_node == 0) {
      send_field((char *)(lbuf), 4, j);
    }
    if (this_node == j) {
      get_field((char *)(lbuf), 4);
      send_integer(0, (int *)(& chksum));
    }
    if (this_node == 0) {
      receive_integer((int *)(& utmp));
      chksum += utmp;
    }
    j ++;
  }
  if (this_node == 0) {
    printf("trace = %f\n", avgtrace);
    printf("chksum_x = %x\n", chksum);
    printf("chksum_u = %12u\n", chksum);
    printf("plaquette = %f\n", avgplaq);
    printf("Writing archive format lattice to %s\n", filename);
    outfile = fopen((char const   *)filename, "w");
    if ((unsigned long )outfile == (unsigned long )((void *)0)) {
      printf("error opening output file: %s\n", filename);
      terminate(1);
    }
    fprintf(outfile, "BEGIN_HEADER\n");
    fprintf(outfile, "DATATYPE = 4D_SU3_GAUGE\n");
    fprintf(outfile, "DIMENSION_1 = %d\n", nx);
    fprintf(outfile, "DIMENSION_2 = %d\n", ny);
    fprintf(outfile, "DIMENSION_3 = %d\n", nz);
    fprintf(outfile, "DIMENSION_4 = %d\n", nt);
    fprintf(outfile, "CHECKSUM = %x\n", chksum);
    fprintf(outfile, "LINK_TRACE = %.10f\n", avgtrace);
    fprintf(outfile, "PLAQUETTE = %.10f\n", avgplaq);
    fprintf(outfile, "ENSEMBLE_ID = %s\n", ensemble_id);
    fprintf(outfile, "SEQUENCE_NUMBER = %d\n", sequence_number);
    fprintf(outfile, "MILC_INFO = -------BEGIN-------\n");
    write_gauge_info_item(outfile, (char *)"time_stamp", (char *)"\"%s\"", gh->time_stamp,
                          0, 0);
    tmp___1 = __builtin_object_size((void *)(sums), 1);
    __builtin___sprintf_chk(sums, 0, tmp___1, "%x %x", gf___0->check.sum29, gf___0->check.sum31);
    write_gauge_info_item(outfile, (char *)"checksums", (char *)"\"%s\"", sums, 0,
                          0);
    write_gauge_info_item(outfile, (char *)"nx", (char *)"%d", (char *)(& nx), 0,
                          0);
    write_gauge_info_item(outfile, (char *)"ny", (char *)"%d", (char *)(& ny), 0,
                          0);
    write_gauge_info_item(outfile, (char *)"nz", (char *)"%d", (char *)(& nz), 0,
                          0);
    write_gauge_info_item(outfile, (char *)"nt", (char *)"%d", (char *)(& nt), 0,
                          0);
    write_appl_gauge_info(outfile);
    fprintf(outfile, "MILC_INFO = --------END--------\n");
    fprintf(outfile, "END_HEADER\n");
    vol3 = (nx * ny) * nz;
    tmp___2 = calloc((size_t )(48 * vol3), sizeof(OUTPUT_TYPE ));
    uout = (OUTPUT_TYPE *)tmp___2;
    if ((unsigned long )uout == (unsigned long )((void *)0)) {
      printf("can\'t malloc uout timeslice\n");
      terminate(1);
    }
  }
  g_sync();
  currentnode = 0;
  tslice = 0;
  while (tslice < nt) {
    j = 0;
    z = 0;
    while (z < nz) {
      y = 0;
      while (y < ny) {
        x = 0;
        while (x < nx) {
          newnode = node_number(x, y, z, tslice);
          if (newnode != currentnode) {
            if (this_node == 0) {
              if (newnode != 0) {
                send_field((char *)(lbuf), 4, newnode);
              }
            }
            if (this_node == newnode) {
              if (newnode != 0) {
                get_field((char *)(lbuf), 4);
              }
            }
            currentnode = newnode;
          }
          if (this_node == 0) {
            if (currentnode == 0) {
              tmp___3 = node_index(x, y, z, tslice);
              s = lattice + tmp___3;
              mu = 0;
              while (mu < 4) {
                a = 0;
                while (a < 2) {
                  b = 0;
                  while (b < 3) {
                    *(uout + ((2 * (b + 3 * a) + 12 * mu) + 48 * j)) = s->link[mu].e[a][b].real;
                    *(uout + (((1 + 2 * (b + 3 * a)) + 12 * mu) + 48 * j)) = s->link[mu].e[a][b].imag;
                    b ++;
                  }
                  a ++;
                }
                mu ++;
              }
            } else {
              get_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )));
              mu = 0;
              while (mu < 4) {
                a = 0;
                while (a < 2) {
                  b = 0;
                  while (b < 3) {
                    *(uout + ((2 * (b + 3 * a) + 12 * mu) + 48 * j)) = lbuf[mu].e[a][b].real;
                    *(uout + (((1 + 2 * (b + 3 * a)) + 12 * mu) + 48 * j)) = lbuf[mu].e[a][b].imag;
                    b ++;
                  }
                  a ++;
                }
                mu ++;
              }
            }
            j ++;
          } else
          if (this_node == currentnode) {
            i = node_index(x, y, z, tslice);
            dir = 0;
            while (dir <= 3) {
              lbuf[dir] = (lattice + i)->link[dir];
              dir ++;
            }
            send_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )), 0);
          }
          x ++;
        }
        y ++;
      }
      z ++;
    }
    if (this_node == 0) {
      if (! big_end_p) {
        byterevn((int32type *)uout, 48 * vol3);
      }
      tmp___4 = fwrite((void const   *)uout, (unsigned long )(48 * vol3) * sizeof(OUTPUT_TYPE ),
                       (size_t )1, outfile);
      if (tmp___4 != 1UL) {
        printf("fwrite bombed...\n");
      }
      fflush(outfile);
    }
    tslice ++;
  }
  if (this_node == 0) {
    fclose(outfile);
    printf("Wrote archive gauge file %s\n", filename);
    free((void *)uout);
  }
  g_sync();
  return (gf___0);
}
}
gauge_file *save_parallel_archive(char *filename ) 
{ 


  {
  printf("Parallel archive saves are not implemented, yet\n");
  return ((gauge_file *)((void *)0));
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-1OipkmRy.i","-O3")
void make_lattice(void) 
{ 
  register int i ;
  int x ;
  int y ;
  int z ;
  int t ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  tmp = calloc((size_t )sites_on_node, sizeof(site ));
  lattice = (site *)tmp;
  if ((unsigned long )lattice == (unsigned long )((void *)0)) {
    printf("NODE %d: no room for lattice\n", this_node);
    terminate(1);
  }
  i = 0;
  while (i < 16) {
    tmp___0 = calloc((size_t )sites_on_node, sizeof(char *));
    gen_pt[i] = (char **)tmp___0;
    if ((unsigned long )gen_pt[i] == (unsigned long )((void *)0)) {
      printf("NODE %d: no room for pointer vector\n", this_node);
      terminate(1);
    }
    i ++;
  }
  t = 0;
  while (t < nt) {
    z = 0;
    while (z < nz) {
      y = 0;
      while (y < ny) {
        x = 0;
        while (x < nx) {
          tmp___1 = node_number(x, y, z, t);
          tmp___2 = mynode();
          if (tmp___1 == tmp___2) {
            i = node_index(x, y, z, t);
            (lattice + i)->x = (short )x;
            (lattice + i)->y = (short )y;
            (lattice + i)->z = (short )z;
            (lattice + i)->t = (short )t;
            (lattice + i)->index = x + nx * (y + ny * (z + nz * t));
            if ((((x + y) + z) + t) % 2 == 0) {
              (lattice + i)->parity = (char)2;
            } else {
              (lattice + i)->parity = (char)1;
            }
            initialize_prn(& (lattice + i)->site_prn, iseed, (lattice + i)->index);
          }
          x ++;
        }
        y ++;
      }
      z ++;
    }
    t ++;
  }
  tmp___3 = calloc((size_t )(sites_on_node * 4), sizeof(su3_matrix ));
  t_longlink = (su3_matrix *)tmp___3;
  if ((unsigned long )t_longlink == (unsigned long )((void *)0)) {
    printf("NODE %d: no room for t_longlink\n", this_node);
    terminate(1);
  }
  tmp___4 = calloc((size_t )(sites_on_node * 4), sizeof(su3_matrix ));
  t_fatlink = (su3_matrix *)tmp___4;
  if ((unsigned long )t_fatlink == (unsigned long )((void *)0)) {
    printf("NODE %d: no room for t_fatlink\n", this_node);
    terminate(1);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-mPf34SPr.i","-O3")
void mult_su3_na(su3_matrix *a , su3_matrix *b , su3_matrix *c ) ;
void su3_adjoint(su3_matrix *a , su3_matrix *b ) ;
void path_product(int *dir , int length ) ;
void path_product(int *dir , int length ) 
{ 
  register int i ;
  register site *s ;
  msg_tag *mtag0 ;
  su3_matrix *tempmat2t ;
  su3_matrix *tempmat3t ;
  int j ;
  void *tmp ;
  void *tmp___0 ;
  register int loopend ;
  register int loopend___0 ;
  register int loopend___1 ;
  register int loopend___2 ;
  register int loopend___3 ;
  register int loopend___4 ;
  register int loopend___5 ;
  register int loopend___6 ;
  register int loopend___7 ;
  register int loopend___8 ;
  register int loopend___9 ;
  register int loopend___10 ;
  register int loopend___11 ;

  {
  tmp = calloc((size_t )sites_on_node, sizeof(su3_matrix ));
  tempmat3t = (su3_matrix *)tmp;
  tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_matrix ));
  tempmat2t = (su3_matrix *)tmp___0;
  if (*(dir + 0) <= 3) {
    mtag0 = start_gather((field_offset )((char *)(& (lattice + 0)->link[*(dir + 0)]) - (char *)(lattice + 0)),
                         (int )sizeof(su3_matrix ), 7 - *(dir + 0), 3, gen_pt[0]);
  } else {
    loopend = sites_on_node;
    i = 0;
    s = lattice;
    while (i < loopend) {
      su3_adjoint(& s->link[7 - *(dir + 0)], & s->tempmat1);
      i ++;
      s ++;
    }
  }
  j = 1;
  while (j < length) {
    if (j % 2 == 1) {
      if (*(dir + j) <= 3) {
        if (*(dir + (j - 1)) <= 3) {
          wait_gather(mtag0);
          loopend___0 = sites_on_node;
          i = 0;
          s = lattice;
          while (i < loopend___0) {
            mult_su3_nn((su3_matrix *)*(gen_pt[0] + i), & s->link[*(dir + j)], tempmat2t + i);
            i ++;
            s ++;
          }
          cleanup_gather(mtag0);
        } else {
          loopend___1 = sites_on_node;
          i = 0;
          s = lattice;
          while (i < loopend___1) {
            mult_su3_nn(& s->tempmat1, & s->link[*(dir + j)], tempmat2t + i);
            i ++;
            s ++;
          }
        }
        mtag0 = start_gather_from_temp((void *)tempmat2t, (int )sizeof(su3_matrix ),
                                       7 - *(dir + j), 3, gen_pt[0]);
      } else {
        if (*(dir + (j - 1)) <= 3) {
          wait_gather(mtag0);
          loopend___2 = sites_on_node;
          i = 0;
          s = lattice;
          while (i < loopend___2) {
            su3mat_copy((su3_matrix *)*(gen_pt[0] + i), tempmat3t + i);
            i ++;
            s ++;
          }
          cleanup_gather(mtag0);
          mtag0 = start_gather_from_temp((void *)tempmat3t, (int )sizeof(su3_matrix ),
                                         7 - *(dir + j), 3, gen_pt[0]);
        } else {
          mtag0 = start_gather((field_offset )((char *)(& (lattice + 0)->tempmat1) - (char *)(lattice + 0)),
                               (int )sizeof(su3_matrix ), 7 - *(dir + j), 3, gen_pt[0]);
        }
        wait_gather(mtag0);
        loopend___3 = sites_on_node;
        i = 0;
        s = lattice;
        while (i < loopend___3) {
          mult_su3_na((su3_matrix *)*(gen_pt[0] + i), & s->link[7 - *(dir + j)], tempmat2t + i);
          i ++;
          s ++;
        }
        cleanup_gather(mtag0);
      }
    } else
    if (*(dir + j) <= 3) {
      if (*(dir + (j - 1)) <= 3) {
        wait_gather(mtag0);
        loopend___4 = sites_on_node;
        i = 0;
        s = lattice;
        while (i < loopend___4) {
          mult_su3_nn((su3_matrix *)*(gen_pt[0] + i), & s->link[*(dir + j)], & s->tempmat1);
          i ++;
          s ++;
        }
        cleanup_gather(mtag0);
      } else {
        loopend___5 = sites_on_node;
        i = 0;
        s = lattice;
        while (i < loopend___5) {
          mult_su3_nn(tempmat2t + i, & s->link[*(dir + j)], & s->tempmat1);
          i ++;
          s ++;
        }
      }
      mtag0 = start_gather((field_offset )((char *)(& (lattice + 0)->tempmat1) - (char *)(lattice + 0)),
                           (int )sizeof(su3_matrix ), 7 - *(dir + j), 3, gen_pt[0]);
    } else {
      if (*(dir + (j - 1)) <= 3) {
        wait_gather(mtag0);
        loopend___6 = sites_on_node;
        i = 0;
        s = lattice;
        while (i < loopend___6) {
          su3mat_copy((su3_matrix *)*(gen_pt[0] + i), tempmat3t + i);
          i ++;
          s ++;
        }
        cleanup_gather(mtag0);
        mtag0 = start_gather_from_temp((void *)tempmat3t, (int )sizeof(su3_matrix ),
                                       7 - *(dir + j), 3, gen_pt[0]);
      } else {
        mtag0 = start_gather_from_temp((void *)tempmat2t, (int )sizeof(su3_matrix ),
                                       7 - *(dir + j), 3, gen_pt[0]);
      }
      wait_gather(mtag0);
      loopend___7 = sites_on_node;
      i = 0;
      s = lattice;
      while (i < loopend___7) {
        mult_su3_na((su3_matrix *)*(gen_pt[0] + i), & s->link[7 - *(dir + j)], & s->tempmat1);
        i ++;
        s ++;
      }
      cleanup_gather(mtag0);
    }
    j ++;
  }
  if (length % 2 == 0) {
    if (*(dir + (length - 1)) <= 3) {
      wait_gather(mtag0);
      loopend___8 = sites_on_node;
      i = 0;
      s = lattice;
      while (i < loopend___8) {
        su3mat_copy((su3_matrix *)*(gen_pt[0] + i), & s->tempmat1);
        i ++;
        s ++;
      }
      cleanup_gather(mtag0);
    } else {
      loopend___9 = sites_on_node;
      i = 0;
      s = lattice;
      while (i < loopend___9) {
        su3mat_copy(tempmat2t + i, & s->tempmat1);
        i ++;
        s ++;
      }
    }
  } else
  if (*(dir + (length - 1)) <= 3) {
    wait_gather(mtag0);
    loopend___10 = sites_on_node;
    i = 0;
    s = lattice;
    while (i < loopend___10) {
      su3mat_copy((su3_matrix *)*(gen_pt[0] + i), tempmat3t + i);
      i ++;
      s ++;
    }
    cleanup_gather(mtag0);
    loopend___11 = sites_on_node;
    i = 0;
    s = lattice;
    while (i < loopend___11) {
      su3mat_copy(tempmat3t + i, & s->tempmat1);
      i ++;
      s ++;
    }
  }
  free((void *)tempmat3t);
  free((void *)tempmat2t);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-hNHSXMqV.i","-O3")
msg_tag *start_general_gather(field_offset field , int size , int *displacement ,
                              int parity , char **dest ) ;
void wait_general_gather(msg_tag *mbuf ) ;
void cleanup_general_gather(msg_tag *mbuf ) ;
void g_complexsum(complex *cpt ) ;
complex ploop(void) ;
complex ploop(void) 
{ 
  register int i ;
  register int t ;
  register site *st ;
  msg_tag *tag ;
  complex sum ;
  complex plp ;
  su3_matrix tmat ;
  int d[4] ;

  {
  sum = cmplx(0.0, 0.0);
  d[2] = 0;
  d[1] = d[2];
  d[0] = d[1];
  tag = start_gather((field_offset )((char *)(& (lattice + 0)->link[3]) - (char *)(lattice + 0)),
                     (int )sizeof(su3_matrix ), 3, 2, gen_pt[0]);
  wait_gather(tag);
  i = 0;
  st = lattice;
  while (i < even_sites_on_node) {
    mult_su3_nn(& st->link[3], (su3_matrix *)*(gen_pt[0] + i), & st->tempmat1);
    i ++;
    st ++;
  }
  cleanup_gather(tag);
  t = 2;
  while (t < nt) {
    d[3] = t;
    tag = start_general_gather((field_offset )((char *)(& (lattice + 0)->tempmat1) - (char *)(lattice + 0)),
                               (int )sizeof(su3_matrix ), d, 2, gen_pt[0]);
    wait_general_gather(tag);
    i = 0;
    st = lattice;
    while (i < even_sites_on_node) {
      if ((int )st->t > 1) {
        goto __Cont;
      }
      mult_su3_nn(& st->tempmat1, (su3_matrix *)*(gen_pt[0] + i), & tmat);
      (lattice + i)->tempmat1 = tmat;
      __Cont: /* CIL Label */ 
      i ++;
      st ++;
    }
    cleanup_general_gather(tag);
    t += 2;
  }
  i = 0;
  st = lattice;
  while (i < even_sites_on_node) {
    if ((int )st->t > 1) {
      goto __Cont___0;
    }
    plp = trace_su3(& st->tempmat1);
    sum.real += plp.real;
    sum.imag += plp.imag;
    __Cont___0: /* CIL Label */ 
    i ++;
    st ++;
  }
  g_complexsum(& sum);
  plp.real = sum.real / (double )((nx * ny) * nz);
  plp.imag = sum.imag / (double )((nx * ny) * nz);
  return (plp);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-IkRVZItI.i","-O3")
void random_anti_hermitian(anti_hermitmat *mat_antihermit , double_prn *prn_pt ) ;
void ranmom(void) 
{ 
  register int i ;
  register int dir ;
  register site *s ;

  {
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    dir = 0;
    while (dir <= 3) {
      random_anti_hermitian(& s->mom[dir], & s->site_prn);
      dir ++;
    }
    i ++;
    s ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-PkVD2OTa.i","-O3")
double myrand(double_prn *prn_pt ) ;
void initialize_prn(double_prn *prn_pt , int seed , int index___0 ) 
{ 


  {
  seed = (69607 + 8 * index___0) * seed + 12345;
  prn_pt->r0 = (unsigned long )((seed >> 8) & 16777215);
  seed = (69607 + 8 * index___0) * seed + 12345;
  prn_pt->r1 = (unsigned long )((seed >> 8) & 16777215);
  seed = (69607 + 8 * index___0) * seed + 12345;
  prn_pt->r2 = (unsigned long )((seed >> 8) & 16777215);
  seed = (69607 + 8 * index___0) * seed + 12345;
  prn_pt->r3 = (unsigned long )((seed >> 8) & 16777215);
  seed = (69607 + 8 * index___0) * seed + 12345;
  prn_pt->r4 = (unsigned long )((seed >> 8) & 16777215);
  seed = (69607 + 8 * index___0) * seed + 12345;
  prn_pt->r5 = (unsigned long )((seed >> 8) & 16777215);
  seed = (69607 + 8 * index___0) * seed + 12345;
  prn_pt->r6 = (unsigned long )((seed >> 8) & 16777215);
  seed = (69607 + 8 * index___0) * seed + 12345;
  prn_pt->ic_state = (unsigned long )seed;
  prn_pt->multiplier = (unsigned long )(100005 + 8 * index___0);
  prn_pt->addend = 12345UL;
  prn_pt->scale = 1.0 / (double )16777216;
  return;
}
}
double myrand(double_prn *prn_pt ) 
{ 
  register int t ;
  register int s ;

  {
  t = (int )((((prn_pt->r5 >> 7) | (prn_pt->r6 << 17)) ^ ((prn_pt->r4 >> 1) | (prn_pt->r5 << 23))) & 16777215UL);
  prn_pt->r6 = prn_pt->r5;
  prn_pt->r5 = prn_pt->r4;
  prn_pt->r4 = prn_pt->r3;
  prn_pt->r3 = prn_pt->r2;
  prn_pt->r2 = prn_pt->r1;
  prn_pt->r1 = prn_pt->r0;
  prn_pt->r0 = (unsigned long )t;
  s = (int )(prn_pt->ic_state * prn_pt->multiplier + prn_pt->addend);
  prn_pt->ic_state = (unsigned long )s;
  return (prn_pt->scale * (double )(t ^ ((s >> 8) & 16777215)));
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-fCZEiQYV.i","-O3")
int reunit_su3(su3_matrix *c ) ;
double max_deviation  ;
double av_deviation  ;
int check_deviation(double deviation ) 
{ 


  {
  if (max_deviation < deviation) {
    max_deviation = deviation;
  }
  av_deviation += deviation * deviation;
  if (deviation > 0.0001) {
    return (1);
  } else {
    return (0);
  }
}
}
void reunit_report_problem_matrix(su3_matrix *mat , int i , int dir ) 
{ 
  int ii ;
  int jj ;
  union __anonunion_ifval_38___0 ifval ;
  int tmp ;

  {
  tmp = mynode();
  printf("Unitarity problem on node %d, site %d, dir %d tolerance=%e\n", tmp, i, dir,
         0.0001);
  printf("SU3 matrix:\n");
  ii = 0;
  while (ii <= 2) {
    jj = 0;
    while (jj <= 2) {
      printf("%f ", mat->e[ii][jj].real);
      printf("%f ", mat->e[ii][jj].imag);
      jj ++;
    }
    printf("\n");
    ii ++;
  }
  printf("repeat in hex:\n");
  ii = 0;
  while (ii <= 2) {
    jj = 0;
    while (jj <= 2) {
      ifval.fval = mat->e[ii][jj].real;
      printf("%08x ", ifval.ival);
      ifval.fval = mat->e[ii][jj].imag;
      printf("%08x ", ifval.ival);
      jj ++;
    }
    printf("\n");
    ii ++;
  }
  printf("  \n \n");
  fflush(__stdoutp);
  return;
}
}
int reunit_su3(su3_matrix *c ) 
{ 
  register double bj0r ;
  register double bj0i ;
  register double bj1r ;
  register double bj1i ;
  register double bj2r ;
  register double bj2i ;
  register double c0r ;
  register double c0i ;
  register double c1r ;
  register double c1i ;
  register double c2r ;
  register double c2i ;
  register double ar ;
  register double ai ;
  register double tr ;
  register double ti ;
  double deviation ;
  int errors ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;

  {
  errors = 0;
  ar = ((((c->e[0][0].real * c->e[0][0].real + c->e[0][0].imag * c->e[0][0].imag) + c->e[0][1].real * c->e[0][1].real) + c->e[0][1].imag * c->e[0][1].imag) + c->e[0][2].real * c->e[0][2].real) + c->e[0][2].imag * c->e[0][2].imag;
  deviation = fabs(ar - 1.);
  tmp = check_deviation(deviation);
  errors += tmp;
  tmp___0 = sqrt(ar);
  ar = 1.0 / tmp___0;
  c->e[0][0].real *= ar;
  c->e[0][0].imag *= ar;
  c->e[0][1].real *= ar;
  c->e[0][1].imag *= ar;
  c->e[0][2].real *= ar;
  c->e[0][2].imag *= ar;
  ar = ((((c->e[0][0].real * c->e[1][0].real + c->e[0][0].imag * c->e[1][0].imag) + c->e[0][1].real * c->e[1][1].real) + c->e[0][1].imag * c->e[1][1].imag) + c->e[0][2].real * c->e[1][2].real) + c->e[0][2].imag * c->e[1][2].imag;
  ai = ((((c->e[0][0].real * c->e[1][0].imag - c->e[0][0].imag * c->e[1][0].real) + c->e[0][1].real * c->e[1][1].imag) - c->e[0][1].imag * c->e[1][1].real) + c->e[0][2].real * c->e[1][2].imag) - c->e[0][2].imag * c->e[1][2].real;
  deviation = ar * ar + ai * ai;
  tmp___1 = check_deviation(deviation);
  errors += tmp___1;
  c->e[1][0].real -= ar * c->e[0][0].real - ai * c->e[0][0].imag;
  c->e[1][0].imag -= ar * c->e[0][0].imag + ai * c->e[0][0].real;
  c->e[1][1].real -= ar * c->e[0][1].real - ai * c->e[0][1].imag;
  c->e[1][1].imag -= ar * c->e[0][1].imag + ai * c->e[0][1].real;
  c->e[1][2].real -= ar * c->e[0][2].real - ai * c->e[0][2].imag;
  c->e[1][2].imag -= ar * c->e[0][2].imag + ai * c->e[0][2].real;
  ar = ((((c->e[1][0].real * c->e[1][0].real + c->e[1][0].imag * c->e[1][0].imag) + c->e[1][1].real * c->e[1][1].real) + c->e[1][1].imag * c->e[1][1].imag) + c->e[1][2].real * c->e[1][2].real) + c->e[1][2].imag * c->e[1][2].imag;
  deviation = fabs(ar - 1.);
  tmp___2 = check_deviation(deviation);
  errors += tmp___2;
  tmp___3 = sqrt(ar);
  ar = 1.0 / tmp___3;
  c->e[1][0].real *= ar;
  c->e[1][0].imag *= ar;
  c->e[1][1].real *= ar;
  c->e[1][1].imag *= ar;
  c->e[1][2].real *= ar;
  c->e[1][2].imag *= ar;
  c0r = c->e[2][0].real;
  c0i = c->e[2][0].imag;
  c1r = c->e[2][1].real;
  c1i = c->e[2][1].imag;
  c2r = c->e[2][2].real;
  c2i = c->e[2][2].imag;
  bj0r = c->e[0][0].real;
  bj0i = c->e[0][0].imag;
  bj1r = c->e[0][1].real;
  bj1i = c->e[0][1].imag;
  bj2r = c->e[0][2].real;
  bj2i = c->e[0][2].imag;
  ar = c->e[1][2].real;
  ai = c->e[1][2].imag;
  tr = bj1r * ar - bj1i * ai;
  ti = bj1r * ai + bj1i * ar;
  ar = c->e[1][1].real;
  ai = c->e[1][1].imag;
  tr = (tr - bj2r * ar) + bj2i * ai;
  ti = (ti - bj2r * ai) - bj2i * ar;
  c->e[2][0].real = tr;
  c->e[2][0].imag = - ti;
  ar = c->e[1][0].real;
  ai = c->e[1][0].imag;
  tr = bj2r * ar - bj2i * ai;
  ti = bj2r * ai + bj2i * ar;
  ar = c->e[1][2].real;
  ai = c->e[1][2].imag;
  tr = (tr - bj0r * ar) + bj0i * ai;
  ti = (ti - bj0r * ai) - bj0i * ar;
  c->e[2][1].real = tr;
  c->e[2][1].imag = - ti;
  ar = c->e[1][1].real;
  ai = c->e[1][1].imag;
  tr = bj0r * ar - bj0i * ai;
  ti = bj0r * ai + bj0i * ar;
  ar = c->e[1][0].real;
  ai = c->e[1][0].imag;
  tr = (tr - bj1r * ar) + bj1i * ai;
  ti = (ti - bj1r * ai) - bj1i * ar;
  c->e[2][2].real = tr;
  c->e[2][2].imag = - ti;
  ar = (((((c0r - c->e[2][0].real) * (c0r - c->e[2][0].real) + (c0i - c->e[2][0].imag) * (c0i - c->e[2][0].imag)) + (c1r - c->e[2][1].real) * (c1r - c->e[2][1].real)) + (c1i - c->e[2][1].imag) * (c1i - c->e[2][1].imag)) + (c2r - c->e[2][2].real) * (c2r - c->e[2][2].real)) + (c2i - c->e[2][2].imag) * (c2i - c->e[2][2].imag);
  deviation = ar;
  tmp___4 = check_deviation(deviation);
  errors += tmp___4;
  return (errors);
}
}
void reunitarize(void) 
{ 
  register su3_matrix *mat ;
  register int i ;
  register int dir ;
  register site *s ;
  int errcount ;
  int errors ;
  int tmp ;

  {
  errcount = 0;
  max_deviation = 0.;
  av_deviation = 0.;
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    dir = 0;
    while (dir <= 3) {
      mat = & s->link[dir];
      errors = reunit_su3(mat);
      errcount += errors;
      if (errors) {
        reunit_report_problem_matrix(mat, i, dir);
      }
      if (errcount > 100) {
        printf("Unitarity error count exceeded.\n");
        terminate(1);
      }
      dir ++;
    }
    i ++;
    s ++;
  }
  if (max_deviation > 0.0001) {
    tmp = mynode();
    printf("reunitarize: Node %d unitarity problem, maximum deviation=%e\n", tmp,
           max_deviation);
    errcount ++;
    if (errcount > 100) {
      printf("Unitarity error count exceeded.\n");
      terminate(1);
    }
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-qsAJuhJ2.i","-O3")
extern double log(double  ) ;
void scalar_mult_sub_su3_matrix(su3_matrix *a , su3_matrix *b , double s , su3_matrix *c ) ;
void g_vecdoublesum(double *dpt , int ndoubles ) ;
double imp_gauge_action(void) ;
void printpath(int *path , int length ) ;
char gauge_action_description[128]  ;
int gauge_action_nloops  =    3;
int gauge_action_nreps  =    1;
int loop_length[3]  ;
int loop_num[3]  ;
int loop_ind[3][6]  ;
int loop_table[3][16][6]  ;
double loop_coeff[3][1]  ;
int loop_char[16]  ;
double loop_expect[3][1][16]  ;
void char_num(int *dig , int *chr , int length ) ;
static int loop_ind___0[3][6]  = { {        0,        1,        7,        6, 
            -1,        -1}, 
   {        0,        0,        1,        7, 
            7,        6}, 
   {        0,        1,        2,        7, 
            6,        5}};
static int loop_length_in[3]  = {      4,      6,      6};
void make_loop_table(void) 
{ 
  int perm[8] ;
  int pp[8] ;
  int ir[4] ;
  int length ;
  int iloop ;
  int i ;
  int j ;
  int chr ;
  int vec[6] ;
  int count ;
  int flag ;
  double tmp ;
  double tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  j = 0;
  while (j < 3) {
    loop_num[j] = 0;
    loop_length[j] = loop_length_in[j];
    i = 0;
    while (i < 1) {
      loop_coeff[j][i] = 0.0;
      i ++;
    }
    j ++;
  }
  loop_coeff[0][0] = 1.0;
  tmp = log(u0);
  loop_coeff[1][0] = (- 1.00 / ((20.0 * u0) * u0)) * (1.00 - 0.6264 * tmp);
  tmp___0 = log(u0);
  loop_coeff[2][0] = ((1.00 / (u0 * u0)) * 0.04335) * tmp___0;
  tmp___2 = __builtin_object_size((void *)(gauge_action_description), 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)(gauge_action_description), 1);
    __builtin___strcpy_chk(gauge_action_description, "\"Symanzik 1x1 + 1x2 + 1x1x1 action\"",
                           tmp___1);
  } else {
    __inline_strcpy_chk(gauge_action_description, "\"Symanzik 1x1 + 1x2 + 1x1x1 action\"");
  }
  if (this_node == 0) {
    printf("Symanzik 1x1 + 1x2 + 1x1x1 action\n");
  }
  iloop = 0;
  while (iloop < 3) {
    length = loop_length[iloop];
    count = 0;
    perm[0] = 0;
    while (perm[0] < 4) {
      perm[1] = 0;
      while (perm[1] < 4) {
        perm[2] = 0;
        while (perm[2] < 4) {
          perm[3] = 0;
          while (perm[3] < 4) {
            if (perm[0] != perm[1]) {
              if (perm[0] != perm[2]) {
                if (perm[0] != perm[3]) {
                  if (perm[1] != perm[2]) {
                    if (perm[1] != perm[3]) {
                      if (perm[2] != perm[3]) {
                        ir[0] = 0;
                        while (ir[0] < 2) {
                          ir[1] = 0;
                          while (ir[1] < 2) {
                            ir[2] = 0;
                            while (ir[2] < 2) {
                              ir[3] = 0;
                              while (ir[3] < 2) {
                                j = 0;
                                while (j < 4) {
                                  pp[j] = perm[j];
                                  if (ir[j] == 1) {
                                    pp[j] = 7 - pp[j];
                                  }
                                  pp[7 - j] = 7 - pp[j];
                                  j ++;
                                }
                                j = 0;
                                while (j < length) {
                                  vec[j] = pp[loop_ind___0[iloop][j]];
                                  j ++;
                                }
                                char_num(vec, & chr, length);
                                flag = 0;
                                j = 0;
                                while (j < count) {
                                  if (chr == loop_char[j]) {
                                    flag = 1;
                                  }
                                  j ++;
                                }
                                if (flag == 0) {
                                  loop_char[count] = chr;
                                  j = 0;
                                  while (j < length) {
                                    loop_table[iloop][count][j] = vec[j];
                                    j ++;
                                  }
                                  count ++;
                                }
                                if (count > 16) {
                                  if (this_node == 0) {
                                    printf("OOPS: MAX_NUM too small\n");
                                  }
                                  exit(0);
                                }
                                loop_num[iloop] = count;
                                (ir[3]) ++;
                              }
                              (ir[2]) ++;
                            }
                            (ir[1]) ++;
                          }
                          (ir[0]) ++;
                        }
                      }
                    }
                  }
                }
              }
            }
            (perm[3]) ++;
          }
          (perm[2]) ++;
        }
        (perm[1]) ++;
      }
      (perm[0]) ++;
    }
    iloop ++;
  }
  if (this_node == 0) {
    printf("loop coefficients: nloop rep loop_coeff  multiplicity\n");
  }
  i = 0;
  while (i < 1) {
    j = 0;
    while (j < 3) {
      if (this_node == 0) {
        printf("                    %d %d      %e     %d\n", j, i, loop_coeff[j][i],
               loop_num[j]);
      }
      j ++;
    }
    i ++;
  }
  return;
}
}
void char_num(int *dig , int *chr , int length ) 
{ 
  int j ;
  int bdig[6] ;
  int tenl ;
  int newv ;
  int old ;

  {
  tenl = 1;
  j = 0;
  while (j < length - 1) {
    tenl *= 10;
    j ++;
  }
  *chr = *(dig + (length - 1));
  j = length - 2;
  while (j >= 0) {
    *chr = *chr * 10 + *(dig + j);
    j --;
  }
  old = *chr;
  j = length - 1;
  while (j >= 1) {
    newv = old - tenl * *(dig + j);
    newv = newv * 10 + *(dig + j);
    if (newv < *chr) {
      *chr = newv;
    }
    old = newv;
    j --;
  }
  j = 0;
  while (j < length) {
    bdig[j] = 7 - *(dig + ((length - j) - 1));
    j ++;
  }
  old = bdig[length - 1];
  j = length - 2;
  while (j >= 0) {
    old = old * 10 + bdig[j];
    j --;
  }
  if (old < *chr) {
    *chr = old;
  }
  j = length - 1;
  while (j >= 1) {
    newv = old - tenl * bdig[j];
    newv = newv * 10 + bdig[j];
    if (newv < *chr) {
      *chr = newv;
    }
    old = newv;
    j --;
  }
  return;
}
}
double imp_gauge_action(void) 
{ 
  register int i ;
  int rep ;
  register site *s ;
  complex trace ;
  double g_action ;
  double action ;
  double act2 ;
  double total_action ;
  int length ;
  int ln ;
  int iloop ;

  {
  g_action = 0.0;
  iloop = 0;
  while (iloop < 3) {
    length = loop_length[iloop];
    ln = 0;
    while (ln < loop_num[iloop]) {
      path_product(loop_table[iloop][ln], length);
      i = 0;
      s = lattice;
      while (i < sites_on_node) {
        trace = trace_su3(& s->tempmat1);
        action = 3.0 - trace.real;
        total_action = loop_coeff[iloop][0] * action;
        act2 = action;
        rep = 1;
        while (rep < 1) {
          act2 *= action;
          total_action += loop_coeff[iloop][rep] * act2;
          rep ++;
        }
        g_action += total_action;
        i ++;
        s ++;
      }
      ln ++;
    }
    iloop ++;
  }
  g_doublesum(& g_action);
  return (g_action);
}
}
void imp_gauge_force(double eps , field_offset mom_off ) 
{ 
  register int i ;
  register int dir ;
  register site *st ;
  su3_matrix tmat1 ;
  su3_matrix tmat2 ;
  register double eb3 ;
  register anti_hermitmat *momentum ;
  int j ;
  int k ;
  int dirs[6] ;
  int length ;
  int path_dir[6] ;
  int path_length ;
  int ln ;
  int iloop ;
  double new_term ;
  int ncount ;

  {
  eb3 = (eps * beta) / 3.0;
  dir = 0;
  while (dir <= 3) {
    i = 0;
    st = lattice;
    while (i < sites_on_node) {
      j = 0;
      while (j < 3) {
        k = 0;
        while (k < 3) {
          st->staple.e[j][k] = cmplx(0.0, 0.0);
          k ++;
        }
        j ++;
      }
      i ++;
      st ++;
    }
    ncount = 0;
    iloop = 0;
    while (iloop < 3) {
      length = loop_length[iloop];
      ln = 0;
      while (ln < loop_num[iloop]) {
        k = 0;
        while (k < length) {
          if (loop_table[iloop][ln][k] <= 3) {
            dirs[k] = (dir + loop_table[iloop][ln][k]) % 4;
          } else {
            dirs[k] = 7 - (dir + (7 - loop_table[iloop][ln][k])) % 4;
          }
          k ++;
        }
        path_length = length - 1;
        k = 0;
        while (k < length) {
          if (dirs[k] == dir) {
            goto _L;
          } else
          if (dirs[k] == 7 - dir) {
            _L: /* CIL Label */ 
            if (dirs[k] <= 3) {
              j = 0;
              while (j < path_length) {
                path_dir[j] = dirs[((k + j) + 1) % length];
                j ++;
              }
            }
            if (dirs[k] > 3) {
              j = 0;
              while (j < path_length) {
                path_dir[(path_length - 1) - j] = 7 - dirs[((k + j) + 1) % length];
                j ++;
              }
            }
            path_product(path_dir, path_length);
            i = 0;
            st = lattice;
            while (i < sites_on_node) {
              su3_adjoint(& st->tempmat1, & tmat1);
              new_term = loop_coeff[iloop][0];
              scalar_mult_add_su3_matrix(& st->staple, & tmat1, new_term, & st->staple);
              i ++;
              st ++;
            }
            ncount ++;
          }
          k ++;
        }
        ln ++;
      }
      iloop ++;
    }
    i = 0;
    st = lattice;
    while (i < sites_on_node) {
      mult_su3_na(& st->link[dir], & st->staple, & tmat1);
      momentum = (anti_hermitmat *)((char *)st + mom_off);
      uncompress_anti_hermitian(momentum + dir, & tmat2);
      scalar_mult_sub_su3_matrix(& tmat2, & tmat1, eb3, & st->staple);
      make_anti_hermitian(& st->staple, momentum + dir);
      i ++;
      st ++;
    }
    dir ++;
  }
  return;
}
}
void g_measure(void) 
{ 
  double ss_plaquette ;
  double st_plaquette ;
  complex p_loop ;
  register int i ;
  register site *s ;
  complex trace ;
  double average[1] ;
  double action ;
  double act2 ;
  double total_action ;
  int length ;
  int ln ;
  int iloop ;
  int rep ;

  {
  d_plaquette(& ss_plaquette, & st_plaquette);
  if (this_node == 0) {
    printf("PLAQ:\t%f\t%f\n", ss_plaquette, st_plaquette);
  }
  p_loop = ploop();
  if (this_node == 0) {
    printf("P_LOOP:\t%e\t%e\n", p_loop.real, p_loop.imag);
  }
  total_action = 0.0;
  iloop = 0;
  while (iloop < 3) {
    length = loop_length[iloop];
    ln = 0;
    while (ln < loop_num[iloop]) {
      path_product(loop_table[iloop][ln], length);
      rep = 0;
      while (rep < 1) {
        average[rep] = 0.0;
        rep ++;
      }
      i = 0;
      s = lattice;
      while (i < sites_on_node) {
        trace = trace_su3(& s->tempmat1);
        average[0] += trace.real;
        action = 3.0 - trace.real;
        total_action += loop_coeff[iloop][0] * action;
        act2 = action;
        rep = 1;
        while (rep < 1) {
          act2 *= action;
          average[rep] += act2;
          total_action += loop_coeff[iloop][rep] * act2;
          rep ++;
        }
        i ++;
        s ++;
      }
      g_vecdoublesum(average, 1);
      if (this_node == 0) {
        printf("G_LOOP:  %d  %d  %d   ", iloop, ln, length);
      }
      rep = 0;
      while (rep < 1) {
        if (this_node == 0) {
          printf("\t%e", average[rep] / (double )volume);
        }
        rep ++;
      }
      if (this_node == 0) {
        printf("\t( ");
      }
      i = 0;
      while (i < length) {
        if (this_node == 0) {
          printf("%d ", loop_table[iloop][ln][i]);
        }
        i ++;
      }
      if (this_node == 0) {
        printf(" )\n");
      }
      ln ++;
    }
    iloop ++;
  }
  g_doublesum(& total_action);
  if (this_node == 0) {
    printf("GACTION: %e\n", total_action / (double )volume);
  }
  if (this_node == 0) {
    fflush(__stdoutp);
  }
  return;
}
}
void printpath(int *path , int length ) 
{ 
  register int i ;

  {
  if (this_node == 0) {
    printf("\t( ");
  }
  i = 0;
  while (i < length) {
    if (this_node == 0) {
      printf("%d ", *(path + i));
    }
    i ++;
  }
  if (this_node == 0) {
    printf(",  L = %d )\n", length);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-PV6kpqvP.i","-O3")
double gaussian_rand_no(double_prn *prn_pt ) ;
void scalar_mult_latvec(field_offset src , double scalar , field_offset dest , int parity ) ;
void scalar_mult_add_latvec(field_offset src1 , field_offset src2 , double scalar ,
                            field_offset dest , int parity ) ;
void grsource_imp(field_offset dest , double mass___0 , int parity ) 
{ 
  register int i ;
  register int j ;
  register site *s ;

  {
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    j = 0;
    while (j < 3) {
      s->g_rand.c[j].real = gaussian_rand_no(& s->site_prn);
      s->g_rand.c[j].imag = gaussian_rand_no(& s->site_prn);
      j ++;
    }
    i ++;
    s ++;
  }
  if (! valid_longlinks) {
    load_longlinks();
  }
  if (! valid_fatlinks) {
    load_fatlinks();
  }
  dslash_fn((field_offset )((char *)(& (lattice + 0)->g_rand) - (char *)(lattice + 0)),
            dest, parity);
  scalar_mult_latvec(dest, - 1.0, dest, parity);
  scalar_mult_add_latvec(dest, (field_offset )((char *)(& (lattice + 0)->g_rand) - (char *)(lattice + 0)),
                         2.0 * mass___0, dest, parity);
  return;
}
}
void checkmul_imp(field_offset src , double mass___0 ) 
{ 
  register int i ;
  register int j ;
  register site *s ;

  {
  dslash_fn(src, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
            3);
  scalar_mult_add_latvec((field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                         src, 2.0 * mass___0, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                         3);
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    printf("Site %d %d %d %d\n", (int )s->x, (int )s->y, (int )s->z, (int )s->t);
    j = 0;
    while (j < 3) {
      printf("%d %d\t%e\t%e\t%e\n", i, j, s->g_rand.c[j].real, s->ttt.c[j].real, s->g_rand.c[j].real - s->ttt.c[j].real);
      printf("%d %d\t%e\t%e\t%e\n", i, j, s->g_rand.c[j].imag, s->ttt.c[j].imag, s->g_rand.c[j].imag - s->ttt.c[j].imag);
      j ++;
    }
    printf("\n");
    i ++;
    s ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-qzq_zUyg.i","-O3")
double magsq_su3vec(su3_vector *a ) ;
void sub_su3_vector(su3_vector *a , su3_vector *b , su3_vector *c ) ;
void scalar_mult_su3_vector(su3_vector *a , double s , su3_vector *c ) ;
void scalar_mult_add_su3_vector(su3_vector *a , su3_vector *b , double s , su3_vector *c ) ;
void clear_latvec(field_offset v , int parity ) ;
int mat_invert_cg(field_offset src , field_offset dest , field_offset temp___0 , double mass___0 ) ;
void check_invert(field_offset src , field_offset dest , double mass___0 , double tol ) ;
int mat_invert_cg(field_offset src , field_offset dest , field_offset temp___0 , double mass___0 ) 
{ 
  int cgn ;
  double finalrsq ;

  {
  clear_latvec(dest, 3);
  cgn = ks_congrad(src, dest, mass___0, niter, rsqprop, 3, & finalrsq);
  dslash_fn(dest, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
            3);
  scalar_mult_add_latvec((field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                         dest, - 2.0 * mass___0, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                         3);
  scalar_mult_latvec((field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                     - 1.0, dest, 3);
  return (cgn);
}
}
int mat_invert_uml(field_offset src , field_offset dest , field_offset temp___0 ,
                   double mass___0 ) 
{ 
  int cgn ;
  double finalrsq ;
  register int i ;
  register site *s ;

  {
  if (src == temp___0) {
    printf("BOTCH\n");
    exit(0);
  }
  dslash_fn(src, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
            2);
  scalar_mult_add_latvec((field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                         src, - 2.0 * mass___0, temp___0, 2);
  scalar_mult_latvec(temp___0, - 1.0, temp___0, 2);
  cgn = ks_congrad(temp___0, dest, mass___0, niter, rsqprop, 2, & finalrsq);
  dslash_fn(dest, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
            1);
  i = even_sites_on_node;
  s = lattice + i;
  while (i < sites_on_node) {
    sub_su3_vector((su3_vector *)((char *)s + src), & s->ttt, (su3_vector *)((char *)s + dest));
    scalar_mult_su3_vector((su3_vector *)((char *)s + dest), 1.0 / (2.0 * mass___0),
                           (su3_vector *)((char *)s + dest));
    i ++;
    s ++;
  }
  return (cgn);
}
}
void check_invert(field_offset src , field_offset dest , double mass___0 , double tol ) 
{ 
  register int i ;
  register int k ;
  register int flag ;
  register site *s ;
  double r_diff ;
  double i_diff ;
  double sum ;
  double sum2 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  dslash_fn(src, (field_offset )((char *)(& (lattice + 0)->cg_p) - (char *)(lattice + 0)),
            3);
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    scalar_mult_add_su3_vector(& s->cg_p, (su3_vector *)((char *)s + src), 2.0 * mass___0,
                               & s->cg_p);
    i ++;
    s ++;
  }
  sum = 0.0;
  sum2 = sum;
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    flag = 0;
    k = 0;
    while (k < 3) {
      r_diff = ((su3_vector *)((char *)s + dest))->c[k].real - s->cg_p.c[k].real;
      i_diff = ((su3_vector *)((char *)s + dest))->c[k].imag - s->cg_p.c[k].imag;
      tmp = fabs(r_diff);
      if (tmp > tol) {
        flag = 1;
      } else {
        tmp___0 = fabs(i_diff);
        if (tmp___0 > tol) {
          flag = 1;
        }
      }
      if (flag) {
        printf("%d %d  ( %.4e , %.4e )  ( %.4e , %.4e )\n", i, k, ((su3_vector *)((char *)s + dest))->c[k].real,
               ((su3_vector *)((char *)s + dest))->c[k].imag, s->cg_p.c[k].real, s->cg_p.c[k].imag);
      }
      if (flag) {
        terminate(0);
      }
      sum += r_diff * r_diff + i_diff * i_diff;
      k ++;
    }
    tmp___1 = magsq_su3vec((su3_vector *)((char *)s + dest));
    sum2 += tmp___1;
    i ++;
    s ++;
  }
  g_doublesum(& sum);
  g_doublesum(& sum2);
  g_sync();
  if (this_node == 0) {
    tmp___2 = sqrt(sum / sum2);
    printf("Inversion checked, frac. error = %e\n", tmp___2);
    fflush(__stdoutp);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-KQ3By7Sz.i","-O3")
void scalar_mult_su3_matrix(su3_matrix *a , double s , su3_matrix *b ) ;
void su3_projector(su3_vector *a , su3_vector *b , su3_matrix *c ) ;
void mult_su3_mat_vec(su3_matrix *a , su3_vector *b , su3_vector *c ) ;
void mult_adj_su3_mat_vec(su3_matrix *a , su3_vector *b , su3_vector *c ) ;
void mult_su3_mat_hwvec(su3_matrix *mat , half_wilson_vector *src , half_wilson_vector *dest ) ;
void mult_adj_su3_mat_hwvec(su3_matrix *mat , half_wilson_vector *src , half_wilson_vector *dest ) ;
void eo_fermion_force_3f(double eps , int nflav1 , field_offset x1_off , int nflav2 ,
                         field_offset x2_off ) ;
static int path_ind[6][7]  = { {        0,        -1,        -1,        -1, 
            -1,        -1}, 
   {        0,        0,        0,        -1, 
            -1,        -1}, 
   {        1,        0,        6,        -1, 
            -1,        -1}, 
   {        1,        2,        0,        5, 
            6,        -1}, 
   {        1,        2,        3,        0, 
            4,        5,        6}, 
   {        1,        1,        0,        6, 
            6,        -1}};
static int path_length_in[6]  = {      1,      3,      3,      5, 
        7,      5};
static int quark_action_npaths  =    6;
static double path_coeff[6]  = {      (1.0 / 8.0 + 6.0 / 16.0) + 1.0 / 8.0,      - 1.0 / 24.0,      (- 1.0 / 8.0) * 0.5,      ((1.0 / 8.0) * 0.25) * 0.5, 
        ((- 1.0 / 8.0) * 0.125) * (1.0 / 6.0),      - 1.0 / (double )16};
static char quark_action_description___0[72]  = 
  {      (char )'\"',      (char )'O',      (char )'(',      (char )'a', 
        (char )'^',      (char )'2',      (char )')',      (char )':', 
        (char )' ',      (char )'c',      (char )'o',      (char )'u', 
        (char )'p',      (char )'l',      (char )'i',      (char )'n', 
        (char )'g',      (char )'s',      (char )'(',      (char )'p', 
        (char )'i',      (char )')',      (char )'=',      (char )'0', 
        (char )',',      (char )' ',      (char )'N',      (char )'a', 
        (char )'i',      (char )'k',      (char )' ',      (char )'t', 
        (char )'e',      (char )'r',      (char )'m',      (char )',', 
        (char )' ',      (char )'N',      (char )'o',      (char )' ', 
        (char )'O',      (char )'(',      (char )'a',      (char )'^', 
        (char )'2',      (char )')',      (char )' ',      (char )'e', 
        (char )'r',      (char )'r',      (char )'o',      (char )'r', 
        (char )'s',      (char )',',      (char )' ',      (char )'t', 
        (char )'a',      (char )'d',      (char )'p',      (char )'o', 
        (char )'l',      (char )'e',      (char )' ',      (char )'w', 
        (char )'e',      (char )'i',      (char )'g',      (char )'h', 
        (char )'t',      (char )'s',      (char )'\"',      (char )'\000'};
void path_transport(field_offset src , field_offset dest , int parity , int *dir ,
                    int length ) ;
void path_transport_hwv(field_offset src , field_offset dest , int parity , int *dir ,
                        int length ) ;
void compute_gen_staple(field_offset staple , int mu , int nu , field_offset link ,
                        double coef ) ;
void u_shift_fermion(su3_vector *src , su3_vector *dest , int dir ) ;
void add_force_to_mom(su3_vector *back , su3_vector *forw , int dir , double coeff ) ;
void side_link_force(int mu , int nu , double coeff , su3_vector *Path , su3_vector *Path_nu ,
                     su3_vector *Path_mu , su3_vector *Path_numu ) ;
void u_shift_hw_fermion(half_wilson_vector *src , half_wilson_vector *dest , int dir ) ;
void add_3f_force_to_mom(half_wilson_vector *back , half_wilson_vector *forw , int dir ,
                         double *coeff ) ;
void side_link_3f_force(int mu , int nu , double *coeff , half_wilson_vector *Path ,
                        half_wilson_vector *Path_nu , half_wilson_vector *Path_mu ,
                        half_wilson_vector *Path_numu ) ;
int path_num[6]  ;
static double act_path_coeff[6]  ;
struct __anonstruct_q_paths_38 q_paths[688]  ;
int num_q_paths  ;
int num_basic_paths  ;
int is_path_equal(int *path1 , int *path2 , int length ) ;
int add_basic_path(int *basic_vec , int length , double coeff ) ;
void make_path_table(void) 
{ 
  int i ;
  int j ;
  int k ;
  double this_coeff ;

  {
  if (this_node == 0) {
    printf("%s\n", quark_action_description___0);
  }
  num_q_paths = 0;
  num_basic_paths = 0;
  if (this_node == 0) {
    printf("path coefficients: npath  path_coeff  multiplicity\n");
  }
  j = 0;
  while (j < quark_action_npaths) {
    this_coeff = path_coeff[j];
    k = 1;
    while (k < path_length_in[j]) {
      this_coeff /= u0;
      k ++;
    }
    act_path_coeff[j] = this_coeff;
    i = add_basic_path(path_ind[j], path_length_in[j], this_coeff);
    if (this_node == 0) {
      printf("                    %d      %e     %d\n", j, this_coeff, i);
    }
    j ++;
  }
  return;
}
}
int add_basic_path(int *basic_vec , int length , double coeff ) 
{ 
  int perm[8] ;
  int pp[8] ;
  int ir[4] ;
  int j ;
  int path_num___0 ;
  int vec[7] ;
  int flag ;

  {
  path_num___0 = 0;
  perm[0] = 0;
  while (perm[0] < 4) {
    perm[1] = 0;
    while (perm[1] < 4) {
      perm[2] = 0;
      while (perm[2] < 4) {
        perm[3] = 0;
        while (perm[3] < 4) {
          if (perm[0] != perm[1]) {
            if (perm[0] != perm[2]) {
              if (perm[0] != perm[3]) {
                if (perm[1] != perm[2]) {
                  if (perm[1] != perm[3]) {
                    if (perm[2] != perm[3]) {
                      ir[0] = 0;
                      while (ir[0] < 2) {
                        ir[1] = 0;
                        while (ir[1] < 2) {
                          ir[2] = 0;
                          while (ir[2] < 2) {
                            ir[3] = 0;
                            while (ir[3] < 2) {
                              j = 0;
                              while (j < 4) {
                                pp[j] = perm[j];
                                if (ir[j] == 1) {
                                  pp[j] = 7 - pp[j];
                                }
                                pp[7 - j] = 7 - pp[j];
                                j ++;
                              }
                              j = 0;
                              while (j < length) {
                                vec[j] = pp[*(basic_vec + j)];
                                j ++;
                              }
                              j = length;
                              while (j < 7) {
                                vec[j] = -1;
                                j ++;
                              }
                              flag = 0;
                              j = 0;
                              while (j < num_q_paths) {
                                flag = is_path_equal(vec, q_paths[j].dir, 7);
                                if (flag == 1) {
                                  break;
                                }
                                j ++;
                              }
                              if (flag == 0) {
                                if (num_q_paths >= 688) {
                                  if (this_node == 0) {
                                    printf("OOPS: MAX_NUM too small\n");
                                  }
                                  exit(0);
                                }
                                q_paths[num_q_paths].length = length;
                                j = 0;
                                while (j < 7) {
                                  q_paths[num_q_paths].dir[j] = vec[j];
                                  j ++;
                                }
                                if (ir[0] == 0) {
                                  q_paths[num_q_paths].coeff = coeff;
                                  q_paths[num_q_paths].forwback = (double )1;
                                } else {
                                  q_paths[num_q_paths].coeff = - coeff;
                                  q_paths[num_q_paths].forwback = (double )-1;
                                }
                                num_q_paths ++;
                                path_num___0 ++;
                              }
                              (ir[3]) ++;
                            }
                            (ir[2]) ++;
                          }
                          (ir[1]) ++;
                        }
                        (ir[0]) ++;
                      }
                    }
                  }
                }
              }
            }
          }
          (perm[3]) ++;
        }
        (perm[2]) ++;
      }
      (perm[1]) ++;
    }
    (perm[0]) ++;
  }
  num_basic_paths ++;
  return (path_num___0);
}
}
void path_transport(field_offset src , field_offset dest , int parity , int *dir ,
                    int length ) 
{ 
  register int i ;
  register site *s ;
  msg_tag *mtag0 ;
  int j ;
  su3_vector *tmp_src ;
  su3_vector *tmp_dest ;
  su3_vector *tmp_work ;
  su3_vector *tmp_pt ;
  int tmp_parity ;
  int tmp_otherparity ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  if (length > 0) {
    tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    tmp_src = (su3_vector *)tmp;
    tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    tmp_dest = (su3_vector *)tmp___0;
    tmp___1 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    tmp_work = (su3_vector *)tmp___1;
    j = length - 1;
    while (j >= 0) {
      if (j % 2 == 0) {
        tmp_parity = parity;
        switch (tmp_parity) {
        case 2: 
        tmp_otherparity = 1;
        break;
        case 1: 
        tmp_otherparity = 2;
        break;
        case 3: 
        tmp_otherparity = 3;
        break;
        }
      } else {
        tmp_otherparity = parity;
        switch (tmp_otherparity) {
        case 2: 
        tmp_parity = 1;
        break;
        case 1: 
        tmp_parity = 2;
        break;
        case 3: 
        tmp_parity = 3;
        break;
        }
      }
      if (j == length - 1) {
        if (tmp_otherparity == 1) {
          i = even_sites_on_node;
        } else {
          i = 0;
        }
        s = lattice + i;
        while (1) {
          if (tmp_otherparity == 2) {
            tmp___2 = even_sites_on_node;
          } else {
            tmp___2 = sites_on_node;
          }
          if (! (i < tmp___2)) {
            break;
          }
          *(tmp_src + i) = *((su3_vector *)((char *)s + src));
          i ++;
          s ++;
        }
      }
      if (*(dir + j) <= 3) {
        mtag0 = start_gather_from_temp((void *)tmp_src, (int )sizeof(su3_vector ),
                                       *(dir + j), tmp_parity, gen_pt[0]);
        wait_gather(mtag0);
        if (tmp_parity == 1) {
          i = even_sites_on_node;
        } else {
          i = 0;
        }
        s = lattice + i;
        while (1) {
          if (tmp_parity == 2) {
            tmp___3 = even_sites_on_node;
          } else {
            tmp___3 = sites_on_node;
          }
          if (! (i < tmp___3)) {
            break;
          }
          mult_su3_mat_vec(& s->link[*(dir + j)], (su3_vector *)*(gen_pt[0] + i),
                           tmp_dest + i);
          i ++;
          s ++;
        }
        cleanup_gather(mtag0);
      } else {
        if (tmp_otherparity == 1) {
          i = even_sites_on_node;
        } else {
          i = 0;
        }
        s = lattice + i;
        while (1) {
          if (tmp_otherparity == 2) {
            tmp___4 = even_sites_on_node;
          } else {
            tmp___4 = sites_on_node;
          }
          if (! (i < tmp___4)) {
            break;
          }
          mult_adj_su3_mat_vec(& s->link[7 - *(dir + j)], tmp_src + i, tmp_work + i);
          i ++;
          s ++;
        }
        mtag0 = start_gather_from_temp((void *)tmp_work, (int )sizeof(su3_vector ),
                                       *(dir + j), tmp_parity, gen_pt[0]);
        wait_gather(mtag0);
        if (tmp_parity == 1) {
          i = even_sites_on_node;
        } else {
          i = 0;
        }
        s = lattice + i;
        while (1) {
          if (tmp_parity == 2) {
            tmp___5 = even_sites_on_node;
          } else {
            tmp___5 = sites_on_node;
          }
          if (! (i < tmp___5)) {
            break;
          }
          *(tmp_dest + i) = *((su3_vector *)*(gen_pt[0] + i));
          i ++;
          s ++;
        }
        cleanup_gather(mtag0);
      }
      tmp_pt = tmp_src;
      tmp_src = tmp_dest;
      tmp_dest = tmp_pt;
      j --;
    }
    if (parity == 1) {
      i = even_sites_on_node;
    } else {
      i = 0;
    }
    s = lattice + i;
    while (1) {
      if (parity == 2) {
        tmp___6 = even_sites_on_node;
      } else {
        tmp___6 = sites_on_node;
      }
      if (! (i < tmp___6)) {
        break;
      }
      *((su3_vector *)((char *)s + dest)) = *(tmp_src + i);
      i ++;
      s ++;
    }
    free((void *)tmp_src);
    free((void *)tmp_dest);
    free((void *)tmp_work);
  } else
  if (src != dest) {
    if (parity == 1) {
      i = even_sites_on_node;
    } else {
      i = 0;
    }
    s = lattice + i;
    while (1) {
      if (parity == 2) {
        tmp___7 = even_sites_on_node;
      } else {
        tmp___7 = sites_on_node;
      }
      if (! (i < tmp___7)) {
        break;
      }
      *((su3_vector *)((char *)s + dest)) = *((su3_vector *)((char *)s + src));
      i ++;
      s ++;
    }
  }
  return;
}
}
void path_transport_hwv(field_offset src , field_offset dest , int parity , int *dir ,
                        int length ) 
{ 
  register int i ;
  register site *s ;
  msg_tag *mtag0 ;
  int j ;
  half_wilson_vector *tmp_src ;
  half_wilson_vector *tmp_dest ;
  half_wilson_vector *tmp_work ;
  half_wilson_vector *tmp_pt ;
  int tmp_parity ;
  int tmp_otherparity ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  if (length > 0) {
    tmp = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
    tmp_src = (half_wilson_vector *)tmp;
    tmp___0 = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
    tmp_dest = (half_wilson_vector *)tmp___0;
    tmp___1 = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
    tmp_work = (half_wilson_vector *)tmp___1;
    j = length - 1;
    while (j >= 0) {
      if (j % 2 == 0) {
        tmp_parity = parity;
        switch (tmp_parity) {
        case 2: 
        tmp_otherparity = 1;
        break;
        case 1: 
        tmp_otherparity = 2;
        break;
        case 3: 
        tmp_otherparity = 3;
        break;
        }
      } else {
        tmp_otherparity = parity;
        switch (tmp_otherparity) {
        case 2: 
        tmp_parity = 1;
        break;
        case 1: 
        tmp_parity = 2;
        break;
        case 3: 
        tmp_parity = 3;
        break;
        }
      }
      if (j == length - 1) {
        if (tmp_otherparity == 1) {
          i = even_sites_on_node;
        } else {
          i = 0;
        }
        s = lattice + i;
        while (1) {
          if (tmp_otherparity == 2) {
            tmp___2 = even_sites_on_node;
          } else {
            tmp___2 = sites_on_node;
          }
          if (! (i < tmp___2)) {
            break;
          }
          *(tmp_src + i) = *((half_wilson_vector *)((char *)s + src));
          i ++;
          s ++;
        }
      }
      if (*(dir + j) <= 3) {
        mtag0 = start_gather_from_temp((void *)tmp_src, (int )sizeof(half_wilson_vector ),
                                       *(dir + j), tmp_parity, gen_pt[0]);
        wait_gather(mtag0);
        if (tmp_parity == 1) {
          i = even_sites_on_node;
        } else {
          i = 0;
        }
        s = lattice + i;
        while (1) {
          if (tmp_parity == 2) {
            tmp___3 = even_sites_on_node;
          } else {
            tmp___3 = sites_on_node;
          }
          if (! (i < tmp___3)) {
            break;
          }
          mult_su3_mat_hwvec(& s->link[*(dir + j)], (half_wilson_vector *)*(gen_pt[0] + i),
                             tmp_dest + i);
          i ++;
          s ++;
        }
        cleanup_gather(mtag0);
      } else {
        if (tmp_otherparity == 1) {
          i = even_sites_on_node;
        } else {
          i = 0;
        }
        s = lattice + i;
        while (1) {
          if (tmp_otherparity == 2) {
            tmp___4 = even_sites_on_node;
          } else {
            tmp___4 = sites_on_node;
          }
          if (! (i < tmp___4)) {
            break;
          }
          mult_adj_su3_mat_hwvec(& s->link[7 - *(dir + j)], tmp_src + i, tmp_work + i);
          i ++;
          s ++;
        }
        mtag0 = start_gather_from_temp((void *)tmp_work, (int )sizeof(half_wilson_vector ),
                                       *(dir + j), tmp_parity, gen_pt[0]);
        wait_gather(mtag0);
        if (tmp_parity == 1) {
          i = even_sites_on_node;
        } else {
          i = 0;
        }
        s = lattice + i;
        while (1) {
          if (tmp_parity == 2) {
            tmp___5 = even_sites_on_node;
          } else {
            tmp___5 = sites_on_node;
          }
          if (! (i < tmp___5)) {
            break;
          }
          *(tmp_dest + i) = *((half_wilson_vector *)*(gen_pt[0] + i));
          i ++;
          s ++;
        }
        cleanup_gather(mtag0);
      }
      tmp_pt = tmp_src;
      tmp_src = tmp_dest;
      tmp_dest = tmp_pt;
      j --;
    }
    if (parity == 1) {
      i = even_sites_on_node;
    } else {
      i = 0;
    }
    s = lattice + i;
    while (1) {
      if (parity == 2) {
        tmp___6 = even_sites_on_node;
      } else {
        tmp___6 = sites_on_node;
      }
      if (! (i < tmp___6)) {
        break;
      }
      *((half_wilson_vector *)((char *)s + dest)) = *(tmp_src + i);
      i ++;
      s ++;
    }
    free((void *)tmp_src);
    free((void *)tmp_dest);
    free((void *)tmp_work);
  } else
  if (src != dest) {
    if (parity == 1) {
      i = even_sites_on_node;
    } else {
      i = 0;
    }
    s = lattice + i;
    while (1) {
      if (parity == 2) {
        tmp___7 = even_sites_on_node;
      } else {
        tmp___7 = sites_on_node;
      }
      if (! (i < tmp___7)) {
        break;
      }
      *((half_wilson_vector *)((char *)s + dest)) = *((half_wilson_vector *)((char *)s + src));
      i ++;
      s ++;
    }
  }
  return;
}
}
void load_longlinks(void) 
{ 
  register int i ;
  register site *s ;
  int ipath ;
  int dir ;
  int disp[4] ;
  register su3_matrix *long1 ;

  {
  if (phases_in != 1) {
    if (this_node == 0) {
      printf("BOTCH: load_longlinks needs phases in\n");
    }
    terminate(0);
  }
  dir = 0;
  while (dir <= 3) {
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      long1 = t_longlink + (4 * i + dir);
      clear_su3mat(long1);
      i ++;
      s ++;
    }
    ipath = 0;
    while (ipath < num_q_paths) {
      i = 0;
      while (i <= 3) {
        disp[i] = 0;
        i ++;
      }
      i = 0;
      while (i < q_paths[ipath].length) {
        if (q_paths[ipath].dir[i] <= 3) {
          (disp[q_paths[ipath].dir[i]]) ++;
        } else {
          (disp[7 - q_paths[ipath].dir[i]]) --;
        }
        i ++;
      }
      disp[dir] += 3;
      i = 0;
      while (i <= 3) {
        if (disp[i] != 0) {
          break;
        }
        i ++;
      }
      if (i <= 3) {
        goto __Cont;
      }
      path_product(q_paths[ipath].dir, q_paths[ipath].length);
      i = 0;
      s = lattice;
      while (i < sites_on_node) {
        su3_adjoint(& s->tempmat1, & s->staple);
        long1 = t_longlink + (4 * i + dir);
        scalar_mult_add_su3_matrix(long1, & s->staple, - q_paths[ipath].coeff, long1);
        i ++;
        s ++;
      }
      __Cont: /* CIL Label */ 
      ipath ++;
    }
    dir ++;
  }
  valid_longlinks = 1;
  return;
}
}
void load_fatlinks(void) 
{ 
  register int i ;
  register site *s ;
  int dir ;
  register su3_matrix *fat1 ;
  int nu ;
  int rho ;
  int sig ;
  double one_link ;

  {
  if (phases_in != 1) {
    if (this_node == 0) {
      printf("BOTCH: load_fatlinks needs phases in\n");
    }
    terminate(0);
  }
  one_link = act_path_coeff[0] - 6.0 * act_path_coeff[5];
  dir = 0;
  while (dir <= 3) {
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      fat1 = t_fatlink + (4 * i + dir);
      scalar_mult_su3_matrix(& s->link[dir], one_link, fat1);
      i ++;
      s ++;
    }
    nu = 0;
    while (nu <= 3) {
      if (nu != dir) {
        compute_gen_staple((field_offset )((char *)(& (lattice + 0)->staple) - (char *)(lattice + 0)),
                           dir, nu, (field_offset )((char *)(& (lattice + 0)->link[dir]) - (char *)(lattice + 0)),
                           act_path_coeff[2]);
        compute_gen_staple(-1, dir, nu, (field_offset )((char *)(& (lattice + 0)->staple) - (char *)(lattice + 0)),
                           act_path_coeff[5]);
        rho = 0;
        while (rho <= 3) {
          if (rho != dir) {
            if (rho != nu) {
              compute_gen_staple((field_offset )((char *)(& (lattice + 0)->tempmat1) - (char *)(lattice + 0)),
                                 dir, rho, (field_offset )((char *)(& (lattice + 0)->staple) - (char *)(lattice + 0)),
                                 act_path_coeff[3]);
              sig = 0;
              while (sig <= 3) {
                if (sig != dir) {
                  if (sig != nu) {
                    if (sig != rho) {
                      compute_gen_staple(-1, dir, sig, (field_offset )((char *)(& (lattice + 0)->tempmat1) - (char *)(lattice + 0)),
                                         act_path_coeff[4]);
                    }
                  }
                }
                sig ++;
              }
            }
          }
          rho ++;
        }
      }
      nu ++;
    }
    dir ++;
  }
  valid_fatlinks = 1;
  return;
}
}
int is_path_equal(int *path1 , int *path2 , int length ) 
{ 
  register int i ;

  {
  i = 0;
  while (i < length) {
    if (*(path1 + i) != *(path2 + i)) {
      return (0);
    }
    i ++;
  }
  return (1);
}
}
void eo_fermion_force(double eps , int nflavors___0 , field_offset x_off ) 
{ 
  register int i ;
  register site *s ;
  int mu ;
  int nu ;
  int rho ;
  int sig ;
  int DirectLinks[8] ;
  double ferm_epsilon ;
  double coeff ;
  double OneLink ;
  double Lepage ;
  double Naik ;
  double FiveSt ;
  double ThreeSt ;
  double SevenSt ;
  su3_vector *tempvec[8] ;
  su3_vector *temp_x ;
  void *tmp ;
  void *tmp___0 ;

  {
  ferm_epsilon = (2.0 * ((double )nflavors___0 / 4.0)) * eps;
  OneLink = act_path_coeff[0] * ferm_epsilon;
  Naik = act_path_coeff[1] * ferm_epsilon;
  ThreeSt = act_path_coeff[2] * ferm_epsilon;
  FiveSt = act_path_coeff[3] * ferm_epsilon;
  SevenSt = act_path_coeff[4] * ferm_epsilon;
  Lepage = act_path_coeff[5] * ferm_epsilon;
  mu = 0;
  while (mu < 8) {
    DirectLinks[mu] = 0;
    mu ++;
  }
  mu = 0;
  while (mu < 8) {
    tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    tempvec[mu] = (su3_vector *)tmp;
    mu ++;
  }
  tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
  temp_x = (su3_vector *)tmp___0;
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    *(temp_x + i) = *((su3_vector *)((char *)s + x_off));
    i ++;
    s ++;
  }
  sig = 0;
  while (sig < 8) {
    mu = 0;
    while (mu < 8) {
      if (mu != sig) {
        if (mu != 7 - sig) {
          u_shift_fermion(temp_x, tempvec[0], 7 - mu);
          u_shift_fermion(tempvec[0], tempvec[7], sig);
          if (sig <= 3) {
            add_force_to_mom(tempvec[7], tempvec[0], sig, - ThreeSt);
          }
          nu = 0;
          while (nu < 8) {
            if (nu != mu) {
              if (nu != 7 - mu) {
                if (nu != sig) {
                  if (nu != 7 - sig) {
                    u_shift_fermion(tempvec[0], tempvec[1], 7 - nu);
                    u_shift_fermion(tempvec[1], tempvec[6], sig);
                    if (sig <= 3) {
                      add_force_to_mom(tempvec[6], tempvec[1], sig, FiveSt);
                    }
                    rho = 0;
                    while (rho < 8) {
                      if (rho != mu) {
                        if (rho != 7 - mu) {
                          if (rho != nu) {
                            if (rho != 7 - nu) {
                              if (rho != sig) {
                                if (rho != 7 - sig) {
                                  u_shift_fermion(tempvec[1], tempvec[2], 7 - rho);
                                  u_shift_fermion(tempvec[2], tempvec[3], sig);
                                  if (sig <= 3) {
                                    add_force_to_mom(tempvec[3], tempvec[2], sig,
                                                     - SevenSt);
                                  }
                                  u_shift_fermion(tempvec[3], tempvec[4], rho);
                                  side_link_force(rho, sig, SevenSt, tempvec[1], tempvec[3],
                                                  tempvec[2], tempvec[4]);
                                  coeff = SevenSt / FiveSt;
                                  i = 0;
                                  s = lattice;
                                  while (i < sites_on_node) {
                                    scalar_mult_add_su3_vector(tempvec[6] + i, tempvec[4] + i,
                                                               coeff, tempvec[6] + i);
                                    i ++;
                                    s ++;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      rho ++;
                    }
                    u_shift_fermion(tempvec[6], tempvec[3], nu);
                    side_link_force(nu, sig, - FiveSt, tempvec[0], tempvec[6], tempvec[1],
                                    tempvec[3]);
                    coeff = FiveSt / ThreeSt;
                    i = 0;
                    s = lattice;
                    while (i < sites_on_node) {
                      scalar_mult_add_su3_vector(tempvec[7] + i, tempvec[3] + i, coeff,
                                                 tempvec[7] + i);
                      i ++;
                      s ++;
                    }
                  }
                }
              }
            }
            nu ++;
          }
          u_shift_fermion(tempvec[0], tempvec[1], 7 - mu);
          u_shift_fermion(tempvec[1], tempvec[6], sig);
          if (sig <= 3) {
            add_force_to_mom(tempvec[6], tempvec[1], sig, Lepage);
          }
          u_shift_fermion(tempvec[6], tempvec[3], mu);
          side_link_force(mu, sig, - Lepage, tempvec[0], tempvec[6], tempvec[1], tempvec[3]);
          coeff = Lepage / ThreeSt;
          i = 0;
          s = lattice;
          while (i < sites_on_node) {
            scalar_mult_add_su3_vector(tempvec[7] + i, tempvec[3] + i, coeff, tempvec[7] + i);
            i ++;
            s ++;
          }
          if (mu <= 3) {
            u_shift_fermion(tempvec[7], tempvec[3], mu);
          }
          side_link_force(mu, sig, ThreeSt, temp_x, tempvec[7], tempvec[0], tempvec[3]);
          if (! DirectLinks[mu]) {
            DirectLinks[mu] = 1;
            if (mu > 3) {
              add_force_to_mom(tempvec[0], temp_x, 7 - mu, OneLink);
              u_shift_fermion(temp_x, tempvec[4], mu);
              add_force_to_mom(tempvec[1], tempvec[4], 7 - mu, - Naik);
              u_shift_fermion(tempvec[1], tempvec[4], 7 - mu);
              add_force_to_mom(tempvec[4], temp_x, 7 - mu, Naik);
            } else {
              u_shift_fermion(temp_x, tempvec[4], mu);
              add_force_to_mom(tempvec[4], tempvec[1], mu, Naik);
            }
          }
        }
      }
      mu ++;
    }
    sig ++;
  }
  free((void *)temp_x);
  mu = 0;
  while (mu < 8) {
    free((void *)tempvec[mu]);
    mu ++;
  }
  return;
}
}
void eo_fermion_force_3f(double eps , int nflav1 , field_offset x1_off , int nflav2 ,
                         field_offset x2_off ) 
{ 
  register int i ;
  register site *s ;
  int mu ;
  int nu ;
  int rho ;
  int sig ;
  int DirectLinks[8] ;
  double coeff[2] ;
  double ferm_epsilon ;
  double OneLink[2] ;
  double Lepage[2] ;
  double Naik[2] ;
  double FiveSt[2] ;
  double ThreeSt[2] ;
  double SevenSt[2] ;
  double mNaik[2] ;
  double mLepage[2] ;
  double mFiveSt[2] ;
  double mThreeSt[2] ;
  double mSevenSt[2] ;
  half_wilson_vector *hwvec[8] ;
  half_wilson_vector *temp_x ;
  void *tmp ;
  void *tmp___0 ;

  {
  ferm_epsilon = (2.0 * ((double )nflav1 / 4.0)) * eps;
  OneLink[0] = act_path_coeff[0] * ferm_epsilon;
  Naik[0] = act_path_coeff[1] * ferm_epsilon;
  mNaik[0] = - Naik[0];
  ThreeSt[0] = act_path_coeff[2] * ferm_epsilon;
  mThreeSt[0] = - ThreeSt[0];
  FiveSt[0] = act_path_coeff[3] * ferm_epsilon;
  mFiveSt[0] = - FiveSt[0];
  SevenSt[0] = act_path_coeff[4] * ferm_epsilon;
  mSevenSt[0] = - SevenSt[0];
  Lepage[0] = act_path_coeff[5] * ferm_epsilon;
  mLepage[0] = - Lepage[0];
  ferm_epsilon = (2.0 * ((double )nflav2 / 4.0)) * eps;
  OneLink[1] = act_path_coeff[0] * ferm_epsilon;
  Naik[1] = act_path_coeff[1] * ferm_epsilon;
  mNaik[1] = - Naik[1];
  ThreeSt[1] = act_path_coeff[2] * ferm_epsilon;
  mThreeSt[1] = - ThreeSt[1];
  FiveSt[1] = act_path_coeff[3] * ferm_epsilon;
  mFiveSt[1] = - FiveSt[1];
  SevenSt[1] = act_path_coeff[4] * ferm_epsilon;
  mSevenSt[1] = - SevenSt[1];
  Lepage[1] = act_path_coeff[5] * ferm_epsilon;
  mLepage[1] = - Lepage[1];
  mu = 0;
  while (mu < 8) {
    DirectLinks[mu] = 0;
    mu ++;
  }
  mu = 0;
  while (mu < 8) {
    tmp = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
    hwvec[mu] = (half_wilson_vector *)tmp;
    mu ++;
  }
  tmp___0 = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
  temp_x = (half_wilson_vector *)tmp___0;
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    (temp_x + i)->h[0] = *((su3_vector *)((char *)s + x1_off));
    (temp_x + i)->h[1] = *((su3_vector *)((char *)s + x2_off));
    i ++;
    s ++;
  }
  sig = 0;
  while (sig < 8) {
    mu = 0;
    while (mu < 8) {
      if (mu != sig) {
        if (mu != 7 - sig) {
          u_shift_hw_fermion(temp_x, hwvec[0], 7 - mu);
          u_shift_hw_fermion(hwvec[0], hwvec[7], sig);
          if (sig <= 3) {
            add_3f_force_to_mom(hwvec[7], hwvec[0], sig, (double *)(mThreeSt));
          }
          nu = 0;
          while (nu < 8) {
            if (nu != mu) {
              if (nu != 7 - mu) {
                if (nu != sig) {
                  if (nu != 7 - sig) {
                    u_shift_hw_fermion(hwvec[0], hwvec[1], 7 - nu);
                    u_shift_hw_fermion(hwvec[1], hwvec[6], sig);
                    if (sig <= 3) {
                      add_3f_force_to_mom(hwvec[6], hwvec[1], sig, (double *)(FiveSt));
                    }
                    rho = 0;
                    while (rho < 8) {
                      if (rho != mu) {
                        if (rho != 7 - mu) {
                          if (rho != nu) {
                            if (rho != 7 - nu) {
                              if (rho != sig) {
                                if (rho != 7 - sig) {
                                  u_shift_hw_fermion(hwvec[1], hwvec[2], 7 - rho);
                                  u_shift_hw_fermion(hwvec[2], hwvec[3], sig);
                                  if (sig <= 3) {
                                    add_3f_force_to_mom(hwvec[3], hwvec[2], sig, (double *)(mSevenSt));
                                  }
                                  u_shift_hw_fermion(hwvec[3], hwvec[4], rho);
                                  side_link_3f_force(rho, sig, (double *)(SevenSt),
                                                     hwvec[1], hwvec[3], hwvec[2],
                                                     hwvec[4]);
                                  coeff[0] = SevenSt[0] / FiveSt[0];
                                  coeff[1] = SevenSt[1] / FiveSt[1];
                                  i = 0;
                                  s = lattice;
                                  while (i < sites_on_node) {
                                    scalar_mult_add_su3_vector(& (hwvec[6] + i)->h[0],
                                                               & (hwvec[4] + i)->h[0],
                                                               coeff[0], & (hwvec[6] + i)->h[0]);
                                    scalar_mult_add_su3_vector(& (hwvec[6] + i)->h[1],
                                                               & (hwvec[4] + i)->h[1],
                                                               coeff[1], & (hwvec[6] + i)->h[1]);
                                    i ++;
                                    s ++;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      rho ++;
                    }
                    u_shift_hw_fermion(hwvec[6], hwvec[3], nu);
                    side_link_3f_force(nu, sig, (double *)(mFiveSt), hwvec[0], hwvec[6],
                                       hwvec[1], hwvec[3]);
                    coeff[0] = FiveSt[0] / ThreeSt[0];
                    coeff[1] = FiveSt[1] / ThreeSt[1];
                    i = 0;
                    s = lattice;
                    while (i < sites_on_node) {
                      scalar_mult_add_su3_vector(& (hwvec[7] + i)->h[0], & (hwvec[3] + i)->h[0],
                                                 coeff[0], & (hwvec[7] + i)->h[0]);
                      scalar_mult_add_su3_vector(& (hwvec[7] + i)->h[1], & (hwvec[3] + i)->h[1],
                                                 coeff[1], & (hwvec[7] + i)->h[1]);
                      i ++;
                      s ++;
                    }
                  }
                }
              }
            }
            nu ++;
          }
          u_shift_hw_fermion(hwvec[0], hwvec[1], 7 - mu);
          u_shift_hw_fermion(hwvec[1], hwvec[6], sig);
          if (sig <= 3) {
            add_3f_force_to_mom(hwvec[6], hwvec[1], sig, (double *)(Lepage));
          }
          u_shift_hw_fermion(hwvec[6], hwvec[3], mu);
          side_link_3f_force(mu, sig, (double *)(mLepage), hwvec[0], hwvec[6], hwvec[1],
                             hwvec[3]);
          coeff[0] = Lepage[0] / ThreeSt[0];
          coeff[1] = Lepage[1] / ThreeSt[1];
          i = 0;
          s = lattice;
          while (i < sites_on_node) {
            scalar_mult_add_su3_vector(& (hwvec[7] + i)->h[0], & (hwvec[3] + i)->h[0],
                                       coeff[0], & (hwvec[7] + i)->h[0]);
            scalar_mult_add_su3_vector(& (hwvec[7] + i)->h[1], & (hwvec[3] + i)->h[1],
                                       coeff[1], & (hwvec[7] + i)->h[1]);
            i ++;
            s ++;
          }
          if (mu <= 3) {
            u_shift_hw_fermion(hwvec[7], hwvec[3], mu);
          }
          side_link_3f_force(mu, sig, (double *)(ThreeSt), temp_x, hwvec[7], hwvec[0],
                             hwvec[3]);
          if (! DirectLinks[mu]) {
            DirectLinks[mu] = 1;
            if (mu > 3) {
              add_3f_force_to_mom(hwvec[0], temp_x, 7 - mu, (double *)(OneLink));
              u_shift_hw_fermion(temp_x, hwvec[4], mu);
              add_3f_force_to_mom(hwvec[1], hwvec[4], 7 - mu, (double *)(mNaik));
              u_shift_hw_fermion(hwvec[1], hwvec[4], 7 - mu);
              add_3f_force_to_mom(hwvec[4], temp_x, 7 - mu, (double *)(Naik));
            } else {
              u_shift_hw_fermion(temp_x, hwvec[4], mu);
              add_3f_force_to_mom(hwvec[4], hwvec[1], mu, (double *)(Naik));
            }
          }
        }
      }
      mu ++;
    }
    sig ++;
  }
  free((void *)temp_x);
  mu = 0;
  while (mu < 8) {
    free((void *)hwvec[mu]);
    mu ++;
  }
  return;
}
}
void compute_gen_staple(field_offset staple , int mu , int nu , field_offset link ,
                        double coef ) 
{ 
  su3_matrix tmat1 ;
  su3_matrix tmat2 ;
  msg_tag *mtag0 ;
  msg_tag *mtag1 ;
  su3_matrix *tempmat ;
  register site *s ;
  register int i ;
  register su3_matrix *fat1 ;
  void *tmp ;

  {
  mtag0 = start_gather(link, (int )sizeof(su3_matrix ), nu, 3, gen_pt[0]);
  mtag1 = start_gather((field_offset )((char *)(& (lattice + 0)->link[nu]) - (char *)(lattice + 0)),
                       (int )sizeof(su3_matrix ), mu, 3, gen_pt[1]);
  wait_gather(mtag0);
  wait_gather(mtag1);
  if (staple != -1) {
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      mult_su3_na((su3_matrix *)*(gen_pt[0] + i), (su3_matrix *)*(gen_pt[1] + i),
                  & tmat1);
      mult_su3_nn(& s->link[nu], & tmat1, (su3_matrix *)((char *)s + staple));
      i ++;
      s ++;
    }
  } else {
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      mult_su3_na((su3_matrix *)*(gen_pt[0] + i), (su3_matrix *)*(gen_pt[1] + i),
                  & tmat1);
      mult_su3_nn(& s->link[nu], & tmat1, & tmat2);
      fat1 = t_fatlink + (4 * i + mu);
      scalar_mult_add_su3_matrix(fat1, & tmat2, coef, fat1);
      i ++;
      s ++;
    }
  }
  cleanup_gather(mtag0);
  cleanup_gather(mtag1);
  tmp = calloc((size_t )sites_on_node, sizeof(su3_matrix ));
  tempmat = (su3_matrix *)tmp;
  mtag0 = start_gather((field_offset )((char *)(& (lattice + 0)->link[nu]) - (char *)(lattice + 0)),
                       (int )sizeof(su3_matrix ), mu, 3, gen_pt[0]);
  wait_gather(mtag0);
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    mult_su3_an(& s->link[nu], (su3_matrix *)((char *)s + link), & tmat1);
    mult_su3_nn(& tmat1, (su3_matrix *)*(gen_pt[0] + i), tempmat + i);
    i ++;
    s ++;
  }
  cleanup_gather(mtag0);
  mtag0 = start_gather_from_temp((void *)tempmat, (int )sizeof(su3_matrix ), 7 - nu,
                                 3, gen_pt[0]);
  wait_gather(mtag0);
  if (staple != -1) {
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      add_su3_matrix((su3_matrix *)((char *)s + staple), (su3_matrix *)*(gen_pt[0] + i),
                     (su3_matrix *)((char *)s + staple));
      fat1 = t_fatlink + (4 * i + mu);
      scalar_mult_add_su3_matrix(fat1, (su3_matrix *)((char *)s + staple), coef, fat1);
      i ++;
      s ++;
    }
  } else {
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      fat1 = t_fatlink + (4 * i + mu);
      scalar_mult_add_su3_matrix(fat1, (su3_matrix *)*(gen_pt[0] + i), coef, fat1);
      i ++;
      s ++;
    }
  }
  free((void *)tempmat);
  cleanup_gather(mtag0);
  return;
}
}
void u_shift_fermion(su3_vector *src , su3_vector *dest , int dir ) 
{ 
  su3_vector *tmpvec ;
  msg_tag *mtag ;
  register site *s ;
  register int i ;
  void *tmp ;

  {
  if (dir <= 3) {
    mtag = start_gather_from_temp((void *)src, (int )sizeof(su3_vector ), dir, 3,
                                  gen_pt[0]);
    wait_gather(mtag);
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      mult_su3_mat_vec(& s->link[dir], (su3_vector *)*(gen_pt[0] + i), dest + i);
      i ++;
      s ++;
    }
    cleanup_gather(mtag);
  } else {
    tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    tmpvec = (su3_vector *)tmp;
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      mult_adj_su3_mat_vec(& s->link[7 - dir], src + i, tmpvec + i);
      i ++;
      s ++;
    }
    mtag = start_gather_from_temp((void *)tmpvec, (int )sizeof(su3_vector ), dir,
                                  3, gen_pt[0]);
    wait_gather(mtag);
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      *(dest + i) = *((su3_vector *)*(gen_pt[0] + i));
      i ++;
      s ++;
    }
    cleanup_gather(mtag);
    free((void *)tmpvec);
  }
  return;
}
}
void u_shift_hw_fermion(half_wilson_vector *src , half_wilson_vector *dest , int dir ) 
{ 
  half_wilson_vector *tmpvec ;
  msg_tag *mtag ;
  register site *s ;
  register int i ;
  void *tmp ;

  {
  if (dir <= 3) {
    mtag = start_gather_from_temp((void *)src, (int )sizeof(half_wilson_vector ),
                                  dir, 3, gen_pt[0]);
    wait_gather(mtag);
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      mult_su3_mat_hwvec(& s->link[dir], (half_wilson_vector *)*(gen_pt[0] + i), dest + i);
      i ++;
      s ++;
    }
    cleanup_gather(mtag);
  } else {
    tmp = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
    tmpvec = (half_wilson_vector *)tmp;
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      mult_adj_su3_mat_hwvec(& s->link[7 - dir], src + i, tmpvec + i);
      i ++;
      s ++;
    }
    mtag = start_gather_from_temp((void *)tmpvec, (int )sizeof(half_wilson_vector ),
                                  dir, 3, gen_pt[0]);
    wait_gather(mtag);
    i = 0;
    s = lattice;
    while (i < sites_on_node) {
      *(dest + i) = *((half_wilson_vector *)*(gen_pt[0] + i));
      i ++;
      s ++;
    }
    cleanup_gather(mtag);
    free((void *)tmpvec);
  }
  return;
}
}
void add_force_to_mom(su3_vector *back , su3_vector *forw , int dir , double coeff ) 
{ 
  register site *s ;
  register int i ;
  register double tmp_coeff ;
  su3_matrix tmat ;
  su3_matrix tmat2 ;

  {
  if (dir > 3) {
    dir = 7 - dir;
    coeff = - coeff;
  }
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    if ((int )s->parity == 1) {
      tmp_coeff = - coeff;
    } else {
      tmp_coeff = coeff;
    }
    uncompress_anti_hermitian(& s->mom[dir], & tmat2);
    su3_projector(back + i, forw + i, & tmat);
    scalar_mult_add_su3_matrix(& tmat2, & tmat, tmp_coeff, & tmat2);
    make_anti_hermitian(& tmat2, & s->mom[dir]);
    i ++;
    s ++;
  }
  return;
}
}
void add_3f_force_to_mom(half_wilson_vector *back , half_wilson_vector *forw , int dir ,
                         double *coeff ) 
{ 
  register site *s ;
  register int i ;
  double tmp_coeff[2] ;
  su3_matrix tmat ;
  su3_matrix tmat2 ;

  {
  if (dir > 3) {
    dir = 7 - dir;
    *(coeff + 0) = - *(coeff + 0);
    *(coeff + 1) = - *(coeff + 1);
  }
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    if ((int )s->parity == 1) {
      tmp_coeff[0] = - *(coeff + 0);
      tmp_coeff[1] = - *(coeff + 1);
    } else {
      tmp_coeff[0] = *(coeff + 0);
      tmp_coeff[1] = *(coeff + 1);
    }
    uncompress_anti_hermitian(& s->mom[dir], & tmat2);
    su3_projector(& (back + i)->h[0], & (forw + i)->h[0], & tmat);
    scalar_mult_add_su3_matrix(& tmat2, & tmat, tmp_coeff[0], & tmat2);
    su3_projector(& (back + i)->h[1], & (forw + i)->h[1], & tmat);
    scalar_mult_add_su3_matrix(& tmat2, & tmat, tmp_coeff[1], & tmat2);
    make_anti_hermitian(& tmat2, & s->mom[dir]);
    i ++;
    s ++;
  }
  return;
}
}
void side_link_force(int mu , int nu , double coeff , su3_vector *Path , su3_vector *Path_nu ,
                     su3_vector *Path_mu , su3_vector *Path_numu ) 
{ 


  {
  if (mu <= 3) {
    if (nu <= 3) {
      add_force_to_mom(Path_numu, Path, mu, coeff);
    } else {
      add_force_to_mom(Path, Path_numu, 7 - mu, - coeff);
    }
  } else
  if (nu <= 3) {
    add_force_to_mom(Path_nu, Path_mu, mu, - coeff);
  } else {
    add_force_to_mom(Path_mu, Path_nu, 7 - mu, coeff);
  }
  return;
}
}
void side_link_3f_force(int mu , int nu , double *coeff , half_wilson_vector *Path ,
                        half_wilson_vector *Path_nu , half_wilson_vector *Path_mu ,
                        half_wilson_vector *Path_numu ) 
{ 
  double m_coeff[2] ;

  {
  m_coeff[0] = - *(coeff + 0);
  m_coeff[1] = - *(coeff + 1);
  if (mu <= 3) {
    if (nu <= 3) {
      add_3f_force_to_mom(Path_numu, Path, mu, coeff);
    } else {
      add_3f_force_to_mom(Path, Path_numu, 7 - mu, (double *)(m_coeff));
    }
  } else
  if (nu <= 3) {
    add_3f_force_to_mom(Path_nu, Path_mu, mu, (double *)(m_coeff));
  } else {
    add_3f_force_to_mom(Path_mu, Path_nu, 7 - mu, coeff);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-QMUlYq45.i","-O3")
void phaseset(void) 
{ 
  register site *sit ;
  register int i ;

  {
  i = 0;
  sit = lattice;
  while (i < sites_on_node) {
    sit->phase[3] = 1.0;
    if ((int )sit->t % 2 == 1) {
      sit->phase[0] = - 1.0;
    } else {
      sit->phase[0] = 1.0;
    }
    if ((int )sit->x % 2 == 1) {
      sit->phase[1] = - sit->phase[0];
    } else {
      sit->phase[1] = sit->phase[0];
    }
    if ((int )sit->y % 2 == 1) {
      sit->phase[2] = - sit->phase[1];
    } else {
      sit->phase[2] = sit->phase[1];
    }
    if ((int )sit->t == nt - 1) {
      sit->phase[3] = - sit->phase[3];
    }
    i ++;
    sit ++;
  }
  return;
}
}
void rephase(int flag ) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int dir ;
  register site *s ;

  {
  if (flag == 1) {
    if (! (phases_in == 0)) {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (flag == 0) {
    if (! (phases_in == 1)) {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (this_node == 0) {
      printf("DUMMY: you fouled up the phases\n");
    }
    terminate(1);
  }
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    dir = 0;
    while (dir <= 3) {
      j = 0;
      while (j < 3) {
        k = 0;
        while (k < 3) {
          s->link[dir].e[j][k].real *= s->phase[dir];
          s->link[dir].e[j][k].imag *= s->phase[dir];
          k ++;
        }
        j ++;
      }
      dir ++;
    }
    i ++;
    s ++;
  }
  phases_in = flag;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-s6nnP0AV.i","-O3")
complex cmplx(double x , double y ) 
{ 
  complex c ;

  {
  c.real = x;
  c.imag = y;
  return (c);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-jXj5nvBz.i","-O3")
void add_su3_matrix(su3_matrix *a , su3_matrix *b , su3_matrix *c ) 
{ 
  register int i ;
  register int j ;

  {
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      c->e[i][j].real = a->e[i][j].real + b->e[i][j].real;
      c->e[i][j].imag = a->e[i][j].imag + b->e[i][j].imag;
      j ++;
    }
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-BdUEa16o.i","-O3")
void add_su3_vector(su3_vector *a , su3_vector *b , su3_vector *c ) ;
void add_su3_vector(su3_vector *a , su3_vector *b , su3_vector *c ) 
{ 
  register int i ;

  {
  i = 0;
  while (i < 3) {
    c->c[i].real = a->c[i].real + b->c[i].real;
    c->c[i].imag = a->c[i].imag + b->c[i].imag;
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Y0Ok3iWP.i","-O3")
void clear_su3mat(su3_matrix *dest ) 
{ 
  register int i ;
  register int j ;
  double tmp ;

  {
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      tmp = 0.0;
      dest->e[i][j].imag = tmp;
      dest->e[i][j].real = tmp;
      j ++;
    }
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-6b58V59t.i","-O3")
void clearvec(su3_vector *v ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  tmp = 0.0;
  v->c[0].imag = tmp;
  v->c[0].real = tmp;
  tmp___0 = 0.0;
  v->c[1].imag = tmp___0;
  v->c[1].real = tmp___0;
  tmp___1 = 0.0;
  v->c[2].imag = tmp___1;
  v->c[2].real = tmp___1;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-jOSuZMWW.i","-O3")
void mult_adj_su3_mat_vec(su3_matrix *a , su3_vector *b , su3_vector *c ) 
{ 
  int i ;
  register double t ;
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;

  {
  i = 0;
  while (i < 3) {
    ar = a->e[0][i].real;
    ai = a->e[0][i].imag;
    br = b->c[0].real;
    bi = b->c[0].imag;
    cr = ar * br;
    t = ai * bi;
    cr += t;
    ci = ar * bi;
    t = ai * br;
    ci -= t;
    ar = a->e[1][i].real;
    ai = a->e[1][i].imag;
    br = b->c[1].real;
    bi = b->c[1].imag;
    t = ar * br;
    cr += t;
    t = ai * bi;
    cr += t;
    t = ar * bi;
    ci += t;
    t = ai * br;
    ci -= t;
    ar = a->e[2][i].real;
    ai = a->e[2][i].imag;
    br = b->c[2].real;
    bi = b->c[2].imag;
    t = ar * br;
    cr += t;
    t = ai * bi;
    cr += t;
    t = ar * bi;
    ci += t;
    t = ai * br;
    ci -= t;
    c->c[i].real = cr;
    c->c[i].imag = ci;
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-1dKwNheC.i","-O3")
void mult_su3_an(su3_matrix *a , su3_matrix *b , su3_matrix *c ) 
{ 
  int j ;
  register double a0r ;
  register double a0i ;
  register double a1r ;
  register double a1i ;
  register double a2r ;
  register double a2i ;
  register double b0r ;
  register double b0i ;
  register double b1r ;
  register double b1i ;
  register double b2r ;
  register double b2i ;

  {
  j = 0;
  while (j < 3) {
    a0r = a->e[0][0].real;
    a0i = a->e[0][0].imag;
    b0r = b->e[0][j].real;
    b0i = b->e[0][j].imag;
    a1r = a->e[1][0].real;
    a1i = a->e[1][0].imag;
    b1r = b->e[1][j].real;
    b1i = b->e[1][j].imag;
    a2r = a->e[2][0].real;
    a2i = a->e[2][0].imag;
    b2r = b->e[2][j].real;
    b2i = b->e[2][j].imag;
    c->e[0][j].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
    c->e[0][j].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
    a0r = a->e[0][1].real;
    a0i = a->e[0][1].imag;
    b0r = b->e[0][j].real;
    b0i = b->e[0][j].imag;
    a1r = a->e[1][1].real;
    a1i = a->e[1][1].imag;
    b1r = b->e[1][j].real;
    b1i = b->e[1][j].imag;
    a2r = a->e[2][1].real;
    a2i = a->e[2][1].imag;
    b2r = b->e[2][j].real;
    b2i = b->e[2][j].imag;
    c->e[1][j].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
    c->e[1][j].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
    a0r = a->e[0][2].real;
    a0i = a->e[0][2].imag;
    b0r = b->e[0][j].real;
    b0i = b->e[0][j].imag;
    a1r = a->e[1][2].real;
    a1i = a->e[1][2].imag;
    b1r = b->e[1][j].real;
    b1i = b->e[1][j].imag;
    a2r = a->e[2][2].real;
    a2i = a->e[2][2].imag;
    b2r = b->e[2][j].real;
    b2i = b->e[2][j].imag;
    c->e[2][j].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
    c->e[2][j].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
    j ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-uKi02gOa.i","-O3")
void mult_su3_na(su3_matrix *a , su3_matrix *b , su3_matrix *c ) 
{ 
  int i ;
  int j ;
  register double t ;
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;

  {
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      ar = a->e[i][0].real;
      ai = a->e[i][0].imag;
      br = b->e[j][0].real;
      bi = b->e[j][0].imag;
      cr = ar * br;
      t = ai * bi;
      cr += t;
      ci = ai * br;
      t = ar * bi;
      ci -= t;
      ar = a->e[i][1].real;
      ai = a->e[i][1].imag;
      br = b->e[j][1].real;
      bi = b->e[j][1].imag;
      t = ar * br;
      cr += t;
      t = ai * bi;
      cr += t;
      t = ar * bi;
      ci -= t;
      t = ai * br;
      ci += t;
      ar = a->e[i][2].real;
      ai = a->e[i][2].imag;
      br = b->e[j][2].real;
      bi = b->e[j][2].imag;
      t = ar * br;
      cr += t;
      t = ai * bi;
      cr += t;
      t = ar * bi;
      ci -= t;
      t = ai * br;
      ci += t;
      c->e[i][j].real = cr;
      c->e[i][j].imag = ci;
      j ++;
    }
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-dgwVkzKb.i","-O3")
void mult_su3_nn(su3_matrix *a , su3_matrix *b , su3_matrix *c ) 
{ 
  int i ;
  int j ;
  register double t ;
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;

  {
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      ar = a->e[i][0].real;
      ai = a->e[i][0].imag;
      br = b->e[0][j].real;
      bi = b->e[0][j].imag;
      cr = ar * br;
      t = ai * bi;
      cr -= t;
      ci = ar * bi;
      t = ai * br;
      ci += t;
      ar = a->e[i][1].real;
      ai = a->e[i][1].imag;
      br = b->e[1][j].real;
      bi = b->e[1][j].imag;
      t = ar * br;
      cr += t;
      t = ai * bi;
      cr -= t;
      t = ar * bi;
      ci += t;
      t = ai * br;
      ci += t;
      ar = a->e[i][2].real;
      ai = a->e[i][2].imag;
      br = b->e[2][j].real;
      bi = b->e[2][j].imag;
      t = ar * br;
      cr += t;
      t = ai * bi;
      cr -= t;
      t = ar * bi;
      ci += t;
      t = ai * br;
      ci += t;
      c->e[i][j].real = cr;
      c->e[i][j].imag = ci;
      j ++;
    }
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-EWNXWaBe.i","-O3")
void mult_su3_mat_vec(su3_matrix *a , su3_vector *b , su3_vector *c ) 
{ 
  int i ;
  register double t ;
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;

  {
  i = 0;
  while (i < 3) {
    ar = a->e[i][0].real;
    ai = a->e[i][0].imag;
    br = b->c[0].real;
    bi = b->c[0].imag;
    cr = ar * br;
    t = ai * bi;
    cr -= t;
    ci = ar * bi;
    t = ai * br;
    ci += t;
    ar = a->e[i][1].real;
    ai = a->e[i][1].imag;
    br = b->c[1].real;
    bi = b->c[1].imag;
    t = ar * br;
    cr += t;
    t = ai * bi;
    cr -= t;
    t = ar * bi;
    ci += t;
    t = ai * br;
    ci += t;
    ar = a->e[i][2].real;
    ai = a->e[i][2].imag;
    br = b->c[2].real;
    bi = b->c[2].imag;
    t = ar * br;
    cr += t;
    t = ai * bi;
    cr -= t;
    t = ar * bi;
    ci += t;
    t = ai * br;
    ci += t;
    c->c[i].real = cr;
    c->c[i].imag = ci;
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-YyIjXU5u.i","-O3")
void make_anti_hermitian(su3_matrix *m3 , anti_hermitmat *ah3 ) 
{ 
  double temp___0 ;
  double temp2 ;

  {
  temp___0 = m3->e[0][0].imag + m3->e[1][1].imag;
  temp2 = temp___0 + m3->e[2][2].imag;
  temp___0 = temp2 * 0.33333333;
  ah3->m00im = m3->e[0][0].imag - temp___0;
  ah3->m11im = m3->e[1][1].imag - temp___0;
  ah3->m22im = m3->e[2][2].imag - temp___0;
  temp___0 = m3->e[0][1].real - m3->e[1][0].real;
  ah3->m01.real = temp___0 * 0.5;
  temp___0 = m3->e[0][2].real - m3->e[2][0].real;
  ah3->m02.real = temp___0 * 0.5;
  temp___0 = m3->e[1][2].real - m3->e[2][1].real;
  ah3->m12.real = temp___0 * 0.5;
  temp___0 = m3->e[0][1].imag + m3->e[1][0].imag;
  ah3->m01.imag = temp___0 * 0.5;
  temp___0 = m3->e[0][2].imag + m3->e[2][0].imag;
  ah3->m02.imag = temp___0 * 0.5;
  temp___0 = m3->e[1][2].imag + m3->e[2][1].imag;
  ah3->m12.imag = temp___0 * 0.5;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-EJ8zmkgC.i","-O3")
void random_anti_hermitian(anti_hermitmat *mat_antihermit , double_prn *prn_pt ) 
{ 
  double r3 ;
  double r8 ;
  double sqrt_third ;

  {
  sqrt_third = sqrt(1.0 / 3.0);
  r3 = gaussian_rand_no(prn_pt);
  r8 = gaussian_rand_no(prn_pt);
  mat_antihermit->m00im = r3 + sqrt_third * r8;
  mat_antihermit->m11im = - r3 + sqrt_third * r8;
  mat_antihermit->m22im = (- 2.0 * sqrt_third) * r8;
  mat_antihermit->m01.real = gaussian_rand_no(prn_pt);
  mat_antihermit->m02.real = gaussian_rand_no(prn_pt);
  mat_antihermit->m12.real = gaussian_rand_no(prn_pt);
  mat_antihermit->m01.imag = gaussian_rand_no(prn_pt);
  mat_antihermit->m02.imag = gaussian_rand_no(prn_pt);
  mat_antihermit->m12.imag = gaussian_rand_no(prn_pt);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Xtdq7ubj.i","-O3")
double realtrace_su3(su3_matrix *a , su3_matrix *b ) 
{ 
  register int i ;
  register int j ;
  register double sum ;

  {
  sum = 0.0;
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      sum += a->e[i][j].real * b->e[i][j].real + a->e[i][j].imag * b->e[i][j].imag;
      j ++;
    }
    i ++;
  }
  return (sum);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-zSHEk5rg.i","-O3")
void scalar_mult_add_su3_matrix(su3_matrix *a , su3_matrix *b , double s , su3_matrix *c ) 
{ 
  register int i ;
  register int j ;

  {
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      c->e[i][j].real = a->e[i][j].real + s * b->e[i][j].real;
      c->e[i][j].imag = a->e[i][j].imag + s * b->e[i][j].imag;
      j ++;
    }
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-SX8O9mbu.i","-O3")
void scalar_mult_add_su3_vector(su3_vector *a , su3_vector *b , double s , su3_vector *c ) 
{ 
  register int i ;

  {
  i = 0;
  while (i < 3) {
    c->c[i].real = a->c[i].real + s * b->c[i].real;
    c->c[i].imag = a->c[i].imag + s * b->c[i].imag;
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-QP1v4RvB.i","-O3")
void scalar_mult_sub_su3_matrix(su3_matrix *a , su3_matrix *b , double s , su3_matrix *c ) 
{ 
  register int i ;
  register int j ;

  {
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      c->e[i][j].real = a->e[i][j].real - s * b->e[i][j].real;
      c->e[i][j].imag = a->e[i][j].imag - s * b->e[i][j].imag;
      j ++;
    }
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-xgu06km3.i","-O3")
void scalar_mult_su3_vector(su3_vector *a , double s , su3_vector *c ) 
{ 
  register int i ;

  {
  i = 0;
  while (i < 3) {
    c->c[i].real = s * a->c[i].real;
    c->c[i].imag = s * a->c[i].imag;
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-BywyGVMq.i","-O3")
void scalar_mult_su3_matrix(su3_matrix *a , double s , su3_matrix *b ) 
{ 
  register double ss ;

  {
  ss = s;
  b->e[0][0].real = ss * a->e[0][0].real;
  b->e[0][0].imag = ss * a->e[0][0].imag;
  b->e[0][1].real = ss * a->e[0][1].real;
  b->e[0][1].imag = ss * a->e[0][1].imag;
  b->e[0][2].real = ss * a->e[0][2].real;
  b->e[0][2].imag = ss * a->e[0][2].imag;
  b->e[1][0].real = ss * a->e[1][0].real;
  b->e[1][0].imag = ss * a->e[1][0].imag;
  b->e[1][1].real = ss * a->e[1][1].real;
  b->e[1][1].imag = ss * a->e[1][1].imag;
  b->e[1][2].real = ss * a->e[1][2].real;
  b->e[1][2].imag = ss * a->e[1][2].imag;
  b->e[2][0].real = ss * a->e[2][0].real;
  b->e[2][0].imag = ss * a->e[2][0].imag;
  b->e[2][1].real = ss * a->e[2][1].real;
  b->e[2][1].imag = ss * a->e[2][1].imag;
  b->e[2][2].real = ss * a->e[2][2].real;
  b->e[2][2].imag = ss * a->e[2][2].imag;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-RfhSEs3s.i","-O3")
void su3_adjoint(su3_matrix *a , su3_matrix *b ) 
{ 
  register int i ;
  register int j ;

  {
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      b->e[i][j].real = a->e[j][i].real;
      b->e[i][j].imag = - a->e[j][i].imag;
      j ++;
    }
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-9FDZXi3H.i","-O3")
complex su3_dot(su3_vector *a , su3_vector *b ) 
{ 
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;
  register complex cc ;

  {
  ar = a->c[0].real;
  ai = a->c[0].imag;
  br = b->c[0].real;
  bi = b->c[0].imag;
  cr = ar * br + ai * bi;
  ci = ar * bi - ai * br;
  ar = a->c[1].real;
  ai = a->c[1].imag;
  br = b->c[1].real;
  bi = b->c[1].imag;
  cr += ar * br + ai * bi;
  ci += ar * bi - ai * br;
  ar = a->c[2].real;
  ai = a->c[2].imag;
  br = b->c[2].real;
  bi = b->c[2].imag;
  cr += ar * br + ai * bi;
  ci += ar * bi - ai * br;
  cc.real = cr;
  cc.imag = ci;
  return (cc);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-5dCnzp3X.i","-O3")
double su3_rdot(su3_vector *a , su3_vector *b ) ;
double su3_rdot(su3_vector *a , su3_vector *b ) 
{ 
  register double temp1 ;
  register double temp2 ;

  {
  temp2 = a->c[0].real * b->c[0].real;
  temp1 = a->c[0].imag * b->c[0].imag;
  temp2 += temp1;
  temp1 = a->c[1].real * b->c[1].real;
  temp2 += temp1;
  temp1 = a->c[1].imag * b->c[1].imag;
  temp2 += temp1;
  temp1 = a->c[2].real * b->c[2].real;
  temp2 += temp1;
  temp1 = a->c[2].imag * b->c[2].imag;
  temp2 += temp1;
  return (temp2);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Ab8Srjir.i","-O3")
void su3_projector(su3_vector *a , su3_vector *b , su3_matrix *c ) 
{ 
  register int i ;
  register int j ;
  register double tmp ;
  register double tmp2 ;

  {
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      tmp2 = a->c[i].real * b->c[j].real;
      tmp = a->c[i].imag * b->c[j].imag;
      c->e[i][j].real = tmp + tmp2;
      tmp2 = a->c[i].real * b->c[j].imag;
      tmp = a->c[i].imag * b->c[j].real;
      c->e[i][j].imag = tmp - tmp2;
      j ++;
    }
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-W5giXTLg.i","-O3")
void su3mat_copy(su3_matrix *a , su3_matrix *b ) 
{ 
  register int i ;
  register int j ;

  {
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      b->e[i][j].real = a->e[i][j].real;
      b->e[i][j].imag = a->e[i][j].imag;
      j ++;
    }
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-TSekABAt.i","-O3")
void sub_su3_matrix(su3_matrix *a , su3_matrix *b , su3_matrix *c ) 
{ 
  register int i ;
  register int j ;

  {
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      c->e[i][j].real = a->e[i][j].real - b->e[i][j].real;
      c->e[i][j].imag = a->e[i][j].imag - b->e[i][j].imag;
      j ++;
    }
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-jG2btsj2.i","-O3")
void sub_su3_vector(su3_vector *a , su3_vector *b , su3_vector *c ) 
{ 
  register int i ;

  {
  i = 0;
  while (i < 3) {
    c->c[i].real = a->c[i].real - b->c[i].real;
    c->c[i].imag = a->c[i].imag - b->c[i].imag;
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-4v2815RL.i","-O3")
complex trace_su3(su3_matrix *a ) 
{ 
  register complex t1 ;
  register complex t2 ;

  {
  t1.real = a->e[0][0].real + a->e[1][1].real;
  t1.imag = a->e[0][0].imag + a->e[1][1].imag;
  t2.real = t1.real + a->e[2][2].real;
  t2.imag = t1.imag + a->e[2][2].imag;
  return (t2);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-LQNYJkdH.i","-O3")
void uncompress_anti_hermitian(anti_hermitmat *mat_antihermit , su3_matrix *mat_su3 ) 
{ 
  double temp1 ;

  {
  mat_su3->e[0][0].imag = mat_antihermit->m00im;
  mat_su3->e[0][0].real = 0.;
  mat_su3->e[1][1].imag = mat_antihermit->m11im;
  mat_su3->e[1][1].real = 0.;
  mat_su3->e[2][2].imag = mat_antihermit->m22im;
  mat_su3->e[2][2].real = 0.;
  mat_su3->e[0][1].imag = mat_antihermit->m01.imag;
  temp1 = mat_antihermit->m01.real;
  mat_su3->e[0][1].real = temp1;
  mat_su3->e[1][0].real = - temp1;
  mat_su3->e[1][0].imag = mat_antihermit->m01.imag;
  mat_su3->e[0][2].imag = mat_antihermit->m02.imag;
  temp1 = mat_antihermit->m02.real;
  mat_su3->e[0][2].real = temp1;
  mat_su3->e[2][0].real = - temp1;
  mat_su3->e[2][0].imag = mat_antihermit->m02.imag;
  mat_su3->e[1][2].imag = mat_antihermit->m12.imag;
  temp1 = mat_antihermit->m12.real;
  mat_su3->e[1][2].real = temp1;
  mat_su3->e[2][1].real = - temp1;
  mat_su3->e[2][1].imag = mat_antihermit->m12.imag;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-xHK3jz10.i","-O3")
double magsq_su3vec(su3_vector *a ) 
{ 
  register double temp___0 ;
  register double sum ;

  {
  sum = 0.0;
  temp___0 = a->c[0].real * a->c[0].real;
  sum += temp___0;
  temp___0 = a->c[0].imag * a->c[0].imag;
  sum += temp___0;
  temp___0 = a->c[1].real * a->c[1].real;
  sum += temp___0;
  temp___0 = a->c[1].imag * a->c[1].imag;
  sum += temp___0;
  temp___0 = a->c[2].real * a->c[2].real;
  sum += temp___0;
  temp___0 = a->c[2].imag * a->c[2].imag;
  sum += temp___0;
  return (sum);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-bgPqKfJQ.i","-O3")
void sub_four_su3_vecs(su3_vector *a , su3_vector *b1 , su3_vector *b2 , su3_vector *b3 ,
                       su3_vector *b4 ) ;
void sub_four_su3_vecs(su3_vector *a , su3_vector *b1 , su3_vector *b2 , su3_vector *b3 ,
                       su3_vector *b4 ) 
{ 


  {
  a->c[0].real -= b1->c[0].real;
  a->c[0].imag -= b1->c[0].imag;
  a->c[1].real -= b1->c[1].real;
  a->c[1].imag -= b1->c[1].imag;
  a->c[2].real -= b1->c[2].real;
  a->c[2].imag -= b1->c[2].imag;
  a->c[0].real -= b2->c[0].real;
  a->c[0].imag -= b2->c[0].imag;
  a->c[1].real -= b2->c[1].real;
  a->c[1].imag -= b2->c[1].imag;
  a->c[2].real -= b2->c[2].real;
  a->c[2].imag -= b2->c[2].imag;
  a->c[0].real -= b3->c[0].real;
  a->c[0].imag -= b3->c[0].imag;
  a->c[1].real -= b3->c[1].real;
  a->c[1].imag -= b3->c[1].imag;
  a->c[2].real -= b3->c[2].real;
  a->c[2].imag -= b3->c[2].imag;
  a->c[0].real -= b4->c[0].real;
  a->c[0].imag -= b4->c[0].imag;
  a->c[1].real -= b4->c[1].real;
  a->c[1].imag -= b4->c[1].imag;
  a->c[2].real -= b4->c[2].real;
  a->c[2].imag -= b4->c[2].imag;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-ko1W9FES.i","-O3")
void mult_adj_su3_mat_vec_4dir(su3_matrix *mat , su3_vector *src , su3_vector *dest ) ;
void mult_adj_su3_mat_vec_4dir(su3_matrix *mat , su3_vector *src , su3_vector *dest ) 
{ 
  register int n ;
  register double c0r ;
  register double c0i ;
  register double c1r ;
  register double c1i ;
  register double c2r ;
  register double c2i ;
  register double br ;
  register double bi ;
  register double a0 ;
  register double a1 ;
  register double a2 ;
  register su3_matrix *a ;
  register su3_vector *b ;
  register su3_vector *c ;

  {
  a = mat;
  c = dest;
  b = src;
  n = 0;
  while (n < 4) {
    br = b->c[0].real;
    bi = b->c[0].imag;
    a0 = a->e[0][0].real;
    a1 = a->e[0][1].real;
    a2 = a->e[0][2].real;
    c0r = a0 * br;
    c1r = a1 * br;
    c2r = a2 * br;
    c0i = a0 * bi;
    c1i = a1 * bi;
    c2i = a2 * bi;
    a0 = a->e[0][0].imag;
    a1 = a->e[0][1].imag;
    a2 = a->e[0][2].imag;
    c0r += a0 * bi;
    c1r += a1 * bi;
    c2r += a2 * bi;
    c0i -= a0 * br;
    c1i -= a1 * br;
    c2i -= a2 * br;
    br = b->c[1].real;
    bi = b->c[1].imag;
    a0 = a->e[1][0].real;
    a1 = a->e[1][1].real;
    a2 = a->e[1][2].real;
    c0r += a0 * br;
    c1r += a1 * br;
    c2r += a2 * br;
    c0i += a0 * bi;
    c1i += a1 * bi;
    c2i += a2 * bi;
    a0 = a->e[1][0].imag;
    a1 = a->e[1][1].imag;
    a2 = a->e[1][2].imag;
    c0r += a0 * bi;
    c1r += a1 * bi;
    c2r += a2 * bi;
    c0i -= a0 * br;
    c1i -= a1 * br;
    c2i -= a2 * br;
    br = b->c[2].real;
    bi = b->c[2].imag;
    a0 = a->e[2][0].real;
    a1 = a->e[2][1].real;
    a2 = a->e[2][2].real;
    c0r += a0 * br;
    c1r += a1 * br;
    c2r += a2 * br;
    c0i += a0 * bi;
    c1i += a1 * bi;
    c2i += a2 * bi;
    a0 = a->e[2][0].imag;
    a1 = a->e[2][1].imag;
    a2 = a->e[2][2].imag;
    c0r += a0 * bi;
    c1r += a1 * bi;
    c2r += a2 * bi;
    c0i -= a0 * br;
    c1i -= a1 * br;
    c2i -= a2 * br;
    c->c[0].real = c0r;
    c->c[0].imag = c0i;
    c->c[1].real = c1r;
    c->c[1].imag = c1i;
    c->c[2].real = c2r;
    c->c[2].imag = c2i;
    n ++;
    a ++;
    c ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-HCqFvF7v.i","-O3")
void mult_adj_su3_mat_4vec(su3_matrix *mat , su3_vector *src , su3_vector *dest0 ,
                           su3_vector *dest1 , su3_vector *dest2 , su3_vector *dest3 ) ;
void mult_adj_su3_mat_4vec(su3_matrix *mat , su3_vector *src , su3_vector *dest0 ,
                           su3_vector *dest1 , su3_vector *dest2 , su3_vector *dest3 ) 
{ 
  register int n ;
  register double c0r ;
  register double c0i ;
  register double c1r ;
  register double c1i ;
  register double c2r ;
  register double c2i ;
  register double br ;
  register double bi ;
  register double a0 ;
  register double a1 ;
  register double a2 ;
  register su3_matrix *a ;
  register su3_vector *b ;
  register su3_vector *c ;
  su3_vector *cc[4] ;

  {
  cc[0] = dest0;
  cc[1] = dest1;
  cc[2] = dest2;
  cc[3] = dest3;
  a = mat;
  c = dest0;
  b = src;
  n = 0;
  while (n < 4) {
    c = cc[n];
    br = b->c[0].real;
    bi = b->c[0].imag;
    a0 = a->e[0][0].real;
    a1 = a->e[0][1].real;
    a2 = a->e[0][2].real;
    c0r = a0 * br;
    c1r = a1 * br;
    c2r = a2 * br;
    c0i = a0 * bi;
    c1i = a1 * bi;
    c2i = a2 * bi;
    a0 = a->e[0][0].imag;
    a1 = a->e[0][1].imag;
    a2 = a->e[0][2].imag;
    c0r += a0 * bi;
    c1r += a1 * bi;
    c2r += a2 * bi;
    c0i -= a0 * br;
    c1i -= a1 * br;
    c2i -= a2 * br;
    br = b->c[1].real;
    bi = b->c[1].imag;
    a0 = a->e[1][0].real;
    a1 = a->e[1][1].real;
    a2 = a->e[1][2].real;
    c0r += a0 * br;
    c1r += a1 * br;
    c2r += a2 * br;
    c0i += a0 * bi;
    c1i += a1 * bi;
    c2i += a2 * bi;
    a0 = a->e[1][0].imag;
    a1 = a->e[1][1].imag;
    a2 = a->e[1][2].imag;
    c0r += a0 * bi;
    c1r += a1 * bi;
    c2r += a2 * bi;
    c0i -= a0 * br;
    c1i -= a1 * br;
    c2i -= a2 * br;
    br = b->c[2].real;
    bi = b->c[2].imag;
    a0 = a->e[2][0].real;
    a1 = a->e[2][1].real;
    a2 = a->e[2][2].real;
    c0r += a0 * br;
    c1r += a1 * br;
    c2r += a2 * br;
    c0i += a0 * bi;
    c1i += a1 * bi;
    c2i += a2 * bi;
    a0 = a->e[2][0].imag;
    a1 = a->e[2][1].imag;
    a2 = a->e[2][2].imag;
    c0r += a0 * bi;
    c1r += a1 * bi;
    c2r += a2 * bi;
    c0i -= a0 * br;
    c1i -= a1 * br;
    c2i -= a2 * br;
    c->c[0].real = c0r;
    c->c[0].imag = c0i;
    c->c[1].real = c1r;
    c->c[1].imag = c1i;
    c->c[2].real = c2r;
    c->c[2].imag = c2i;
    n ++;
    a ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-fs_4CA_7.i","-O3")
void mult_su3_mat_vec_sum_4dir(su3_matrix *a , su3_vector *b0 , su3_vector *b1 , su3_vector *b2 ,
                               su3_vector *b3 , su3_vector *c ) ;
void mult_su3_mat_vec_sum_4dir(su3_matrix *a , su3_vector *b0 , su3_vector *b1 , su3_vector *b2 ,
                               su3_vector *b3 , su3_vector *c ) 
{ 
  int i ;
  int n ;
  register su3_matrix *at ;
  register su3_vector *b ;
  register double t ;
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;

  {
  i = 0;
  while (i < 3) {
    c->c[i].real = 0.0;
    c->c[i].imag = 0.0;
    i ++;
  }
  n = 0;
  while (n < 4) {
    at = a + n;
    switch (n) {
    case 0: 
    b = b0;
    break;
    case 1: 
    b = b1;
    break;
    case 2: 
    b = b2;
    break;
    case 3: 
    b = b3;
    break;
    }
    i = 0;
    while (i < 3) {
      ar = at->e[i][0].real;
      ai = at->e[i][0].imag;
      br = b->c[0].real;
      bi = b->c[0].imag;
      cr = ar * br;
      t = ai * bi;
      cr -= t;
      ci = ar * bi;
      t = ai * br;
      ci += t;
      ar = at->e[i][1].real;
      ai = at->e[i][1].imag;
      br = b->c[1].real;
      bi = b->c[1].imag;
      t = ar * br;
      cr += t;
      t = ai * bi;
      cr -= t;
      t = ar * bi;
      ci += t;
      t = ai * br;
      ci += t;
      ar = at->e[i][2].real;
      ai = at->e[i][2].imag;
      br = b->c[2].real;
      bi = b->c[2].imag;
      t = ar * br;
      cr += t;
      t = ai * bi;
      cr -= t;
      t = ar * bi;
      ci += t;
      t = ai * br;
      ci += t;
      c->c[i].real += cr;
      c->c[i].imag += ci;
      i ++;
    }
    n ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-2VR0JJtP.i","-O3")
void mult_su2_mat_vec_elem_n(su2_matrix *u , complex *x0 , complex *x1 ) 
{ 
  complex z0 ;
  complex z1 ;
  complex t0 ;
  complex t1 ;

  {
  t0 = *x0;
  t1 = *x1;
  z0.real = u->e[0][0].real * t0.real - u->e[0][0].imag * t0.imag;
  z0.imag = u->e[0][0].real * t0.imag + u->e[0][0].imag * t0.real;
  z1.real = u->e[0][1].real * t1.real - u->e[0][1].imag * t1.imag;
  z1.imag = u->e[0][1].real * t1.imag + u->e[0][1].imag * t1.real;
  x0->real = z0.real + z1.real;
  x0->imag = z0.imag + z1.imag;
  z0.real = u->e[1][0].real * t0.real - u->e[1][0].imag * t0.imag;
  z0.imag = u->e[1][0].real * t0.imag + u->e[1][0].imag * t0.real;
  z1.real = u->e[1][1].real * t1.real - u->e[1][1].imag * t1.imag;
  z1.imag = u->e[1][1].real * t1.imag + u->e[1][1].imag * t1.real;
  x1->real = z0.real + z1.real;
  x1->imag = z0.imag + z1.imag;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Sm_jjIqi.i","-O3")
void left_su2_hit_n(su2_matrix *u , int p , int q , su3_matrix *link ) 
{ 
  register int m ;

  {
  m = 0;
  while (m < 3) {
    mult_su2_mat_vec_elem_n(u, & link->e[p][m], & link->e[q][m]);
    m ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-3HDH6Iba.i","-O3")
void mult_su2_mat_vec_elem_a(su2_matrix *u , complex *x0 , complex *x1 ) ;
void right_su2_hit_a(su2_matrix *u , int p , int q , su3_matrix *link ) 
{ 
  register int m ;

  {
  m = 0;
  while (m < 3) {
    mult_su2_mat_vec_elem_a(u, & link->e[m][p], & link->e[m][q]);
    m ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-oadXfDZc.i","-O3")
void mult_su2_mat_vec_elem_a(su2_matrix *u , complex *x0 , complex *x1 ) 
{ 
  complex z0 ;
  complex z1 ;
  complex t0 ;
  complex t1 ;

  {
  t0 = *x0;
  t1 = *x1;
  z0.real = t0.real * u->e[0][0].real + t0.imag * u->e[0][0].imag;
  z0.imag = t0.imag * u->e[0][0].real - t0.real * u->e[0][0].imag;
  z1.real = t1.real * u->e[0][1].real + t1.imag * u->e[0][1].imag;
  z1.imag = t1.imag * u->e[0][1].real - t1.real * u->e[0][1].imag;
  x0->real = z0.real + z1.real;
  x0->imag = z0.imag + z1.imag;
  z0.real = t0.real * u->e[1][0].real + t0.imag * u->e[1][0].imag;
  z0.imag = t0.imag * u->e[1][0].real - t0.real * u->e[1][0].imag;
  z1.real = t1.real * u->e[1][1].real + t1.imag * u->e[1][1].imag;
  z1.imag = t1.imag * u->e[1][1].real - t1.real * u->e[1][1].imag;
  x1->real = z0.real + z1.real;
  x1->imag = z0.imag + z1.imag;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-gfvFJUpI.i","-O3")
static int iset  =    0;
static double gset  ;
double gaussian_rand_no(double_prn *prn_pt ) 
{ 
  double fac ;
  double r ;
  double v1 ;
  double v2 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  if (iset == 0) {
    while (1) {
      tmp = myrand(prn_pt);
      v1 = 2.0 * tmp - 1.0;
      tmp___0 = myrand(prn_pt);
      v2 = 2.0 * tmp___0 - 1.0;
      r = v1 * v1 + v2 * v2;
      if (! (r >= 1.0)) {
        break;
      }
    }
    tmp___1 = log(r);
    fac = sqrt(- tmp___1 / r);
    gset = v1 * fac;
    iset = 1;
    return (v2 * fac);
  } else {
    iset = 0;
    return (gset);
  }
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-OB3Rrcme.i","-O3")
void byterevn(int32type *w , int n ) 
{ 
  register int32type old ;
  register int32type newv ;
  int j ;

  {
  j = 0;
  while (j < n) {
    old = *(w + j);
    newv = (old >> 24) & 255;
    newv |= (old >> 8) & 65280;
    newv |= (old << 8) & 16711680;
    newv = (int32type )((unsigned int )newv | ((unsigned int )(old << 24) & 4278190080U));
    *(w + j) = newv;
    j ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-o4oFyNyF.i","-O3")
void mult_su3_mat_hwvec(su3_matrix *mat , half_wilson_vector *src , half_wilson_vector *dest ) 
{ 
  register double a0r ;
  register double a0i ;
  register double a1r ;
  register double a1i ;
  register double a2r ;
  register double a2i ;
  register double b0r ;
  register double b0i ;
  register double b1r ;
  register double b1i ;
  register double b2r ;
  register double b2i ;

  {
  a0r = mat->e[0][0].real;
  a0i = mat->e[0][0].imag;
  b0r = src->h[0].c[0].real;
  b0i = src->h[0].c[0].imag;
  a1r = mat->e[0][1].real;
  a1i = mat->e[0][1].imag;
  b1r = src->h[0].c[1].real;
  b1i = src->h[0].c[1].imag;
  a2r = mat->e[0][2].real;
  a2i = mat->e[0][2].imag;
  b2r = src->h[0].c[2].real;
  b2i = src->h[0].c[2].imag;
  dest->h[0].c[0].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
  dest->h[0].c[0].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
  a0r = mat->e[1][0].real;
  a0i = mat->e[1][0].imag;
  b0r = src->h[0].c[0].real;
  b0i = src->h[0].c[0].imag;
  a1r = mat->e[1][1].real;
  a1i = mat->e[1][1].imag;
  b1r = src->h[0].c[1].real;
  b1i = src->h[0].c[1].imag;
  a2r = mat->e[1][2].real;
  a2i = mat->e[1][2].imag;
  b2r = src->h[0].c[2].real;
  b2i = src->h[0].c[2].imag;
  dest->h[0].c[1].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
  dest->h[0].c[1].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
  a0r = mat->e[2][0].real;
  a0i = mat->e[2][0].imag;
  b0r = src->h[0].c[0].real;
  b0i = src->h[0].c[0].imag;
  a1r = mat->e[2][1].real;
  a1i = mat->e[2][1].imag;
  b1r = src->h[0].c[1].real;
  b1i = src->h[0].c[1].imag;
  a2r = mat->e[2][2].real;
  a2i = mat->e[2][2].imag;
  b2r = src->h[0].c[2].real;
  b2i = src->h[0].c[2].imag;
  dest->h[0].c[2].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
  dest->h[0].c[2].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
  a0r = mat->e[0][0].real;
  a0i = mat->e[0][0].imag;
  b0r = src->h[1].c[0].real;
  b0i = src->h[1].c[0].imag;
  a1r = mat->e[0][1].real;
  a1i = mat->e[0][1].imag;
  b1r = src->h[1].c[1].real;
  b1i = src->h[1].c[1].imag;
  a2r = mat->e[0][2].real;
  a2i = mat->e[0][2].imag;
  b2r = src->h[1].c[2].real;
  b2i = src->h[1].c[2].imag;
  dest->h[1].c[0].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
  dest->h[1].c[0].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
  a0r = mat->e[1][0].real;
  a0i = mat->e[1][0].imag;
  b0r = src->h[1].c[0].real;
  b0i = src->h[1].c[0].imag;
  a1r = mat->e[1][1].real;
  a1i = mat->e[1][1].imag;
  b1r = src->h[1].c[1].real;
  b1i = src->h[1].c[1].imag;
  a2r = mat->e[1][2].real;
  a2i = mat->e[1][2].imag;
  b2r = src->h[1].c[2].real;
  b2i = src->h[1].c[2].imag;
  dest->h[1].c[1].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
  dest->h[1].c[1].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
  a0r = mat->e[2][0].real;
  a0i = mat->e[2][0].imag;
  b0r = src->h[1].c[0].real;
  b0i = src->h[1].c[0].imag;
  a1r = mat->e[2][1].real;
  a1i = mat->e[2][1].imag;
  b1r = src->h[1].c[1].real;
  b1i = src->h[1].c[1].imag;
  a2r = mat->e[2][2].real;
  a2i = mat->e[2][2].imag;
  b2r = src->h[1].c[2].real;
  b2i = src->h[1].c[2].imag;
  dest->h[1].c[2].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
  dest->h[1].c[2].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-ONotIiDe.i","-O3")
void mult_adj_su3_mat_hwvec(su3_matrix *mat , half_wilson_vector *src , half_wilson_vector *dest ) 
{ 
  register double a0r ;
  register double a0i ;
  register double a1r ;
  register double a1i ;
  register double a2r ;
  register double a2i ;
  register double b0r ;
  register double b0i ;
  register double b1r ;
  register double b1i ;
  register double b2r ;
  register double b2i ;

  {
  a0r = mat->e[0][0].real;
  a0i = mat->e[0][0].imag;
  b0r = src->h[0].c[0].real;
  b0i = src->h[0].c[0].imag;
  a1r = mat->e[1][0].real;
  a1i = mat->e[1][0].imag;
  b1r = src->h[0].c[1].real;
  b1i = src->h[0].c[1].imag;
  a2r = mat->e[2][0].real;
  a2i = mat->e[2][0].imag;
  b2r = src->h[0].c[2].real;
  b2i = src->h[0].c[2].imag;
  dest->h[0].c[0].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
  dest->h[0].c[0].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
  a0r = mat->e[0][1].real;
  a0i = mat->e[0][1].imag;
  b0r = src->h[0].c[0].real;
  b0i = src->h[0].c[0].imag;
  a1r = mat->e[1][1].real;
  a1i = mat->e[1][1].imag;
  b1r = src->h[0].c[1].real;
  b1i = src->h[0].c[1].imag;
  a2r = mat->e[2][1].real;
  a2i = mat->e[2][1].imag;
  b2r = src->h[0].c[2].real;
  b2i = src->h[0].c[2].imag;
  dest->h[0].c[1].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
  dest->h[0].c[1].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
  a0r = mat->e[0][2].real;
  a0i = mat->e[0][2].imag;
  b0r = src->h[0].c[0].real;
  b0i = src->h[0].c[0].imag;
  a1r = mat->e[1][2].real;
  a1i = mat->e[1][2].imag;
  b1r = src->h[0].c[1].real;
  b1i = src->h[0].c[1].imag;
  a2r = mat->e[2][2].real;
  a2i = mat->e[2][2].imag;
  b2r = src->h[0].c[2].real;
  b2i = src->h[0].c[2].imag;
  dest->h[0].c[2].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
  dest->h[0].c[2].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
  a0r = mat->e[0][0].real;
  a0i = mat->e[0][0].imag;
  b0r = src->h[1].c[0].real;
  b0i = src->h[1].c[0].imag;
  a1r = mat->e[1][0].real;
  a1i = mat->e[1][0].imag;
  b1r = src->h[1].c[1].real;
  b1i = src->h[1].c[1].imag;
  a2r = mat->e[2][0].real;
  a2i = mat->e[2][0].imag;
  b2r = src->h[1].c[2].real;
  b2i = src->h[1].c[2].imag;
  dest->h[1].c[0].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
  dest->h[1].c[0].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
  a0r = mat->e[0][1].real;
  a0i = mat->e[0][1].imag;
  b0r = src->h[1].c[0].real;
  b0i = src->h[1].c[0].imag;
  a1r = mat->e[1][1].real;
  a1i = mat->e[1][1].imag;
  b1r = src->h[1].c[1].real;
  b1i = src->h[1].c[1].imag;
  a2r = mat->e[2][1].real;
  a2i = mat->e[2][1].imag;
  b2r = src->h[1].c[2].real;
  b2i = src->h[1].c[2].imag;
  dest->h[1].c[1].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
  dest->h[1].c[1].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
  a0r = mat->e[0][2].real;
  a0i = mat->e[0][2].imag;
  b0r = src->h[1].c[0].real;
  b0i = src->h[1].c[0].imag;
  a1r = mat->e[1][2].real;
  a1i = mat->e[1][2].imag;
  b1r = src->h[1].c[1].real;
  b1i = src->h[1].c[1].imag;
  a2r = mat->e[2][2].real;
  a2i = mat->e[2][2].imag;
  b2r = src->h[1].c[2].real;
  b2i = src->h[1].c[2].imag;
  dest->h[1].c[2].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
  dest->h[1].c[2].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-PPwG1cuH.i","-O3")
void restart_gather(field_offset field , int size , int index___0 , int parity , char **dest ,
                    msg_tag *mbuf ) ;
void restart_gather_from_temp(void *field , int size , int index___0 , int parity ,
                              char **dest , msg_tag *mbuf ) ;
void cleanup_gathers(msg_tag **tags1 , msg_tag **tags2 ) ;
void cleanup_dslash_temps(void) ;
void dslash_fn_special(field_offset src , field_offset dest , int parity , msg_tag **tag ,
                       int start ) ;
void dslash_fn_on_temp(su3_vector *src , su3_vector *dest , int parity ) ;
void dslash_fn_on_temp_special(su3_vector *src , su3_vector *dest , int parity , msg_tag **tag ,
                               int start ) ;
static su3_vector *temp[9]  ;
static int temp_not_allocated  =    1;
void cleanup_gathers(msg_tag **tags1 , msg_tag **tags2 ) 
{ 
  int i ;

  {
  i = 0;
  while (i <= 3) {
    cleanup_gather(*(tags1 + i));
    cleanup_gather(*(tags1 + (7 - i)));
    cleanup_gather(*(tags2 + i));
    cleanup_gather(*(tags2 + (7 - i)));
    i ++;
  }
  i = 8;
  while (i <= 11) {
    cleanup_gather(*(tags1 + i));
    cleanup_gather(*(tags1 + (23 - i)));
    cleanup_gather(*(tags2 + i));
    cleanup_gather(*(tags2 + (23 - i)));
    i ++;
  }
  return;
}
}
void cleanup_dslash_temps(void) 
{ 
  register int i ;

  {
  if (! temp_not_allocated) {
    i = 0;
    while (i < 9) {
      free((void *)temp[i]);
      i ++;
    }
  }
  temp_not_allocated = 1;
  return;
}
}
void dslash_fn(field_offset src , field_offset dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register int dir ;
  register int otherparity ;
  register su3_matrix *fat4 ;
  register su3_matrix *long4 ;
  msg_tag *tag[16] ;
  register int loopend ;
  register int loopend___0 ;

  {
  if (! valid_longlinks) {
    load_longlinks();
  }
  if (! valid_fatlinks) {
    load_fatlinks();
  }
  switch (parity) {
  case 2: 
  otherparity = 1;
  break;
  case 1: 
  otherparity = 2;
  break;
  case 3: 
  otherparity = 3;
  break;
  }
  dir = 0;
  while (dir <= 3) {
    tag[dir] = start_gather(src, (int )sizeof(su3_vector ), dir, parity, gen_pt[dir]);
    tag[dir + 8] = start_gather(src, (int )sizeof(su3_vector ), dir + 8, parity, gen_pt[dir + 8]);
    dir ++;
  }
  if (otherparity == 2) {
    loopend = even_sites_on_node;
  } else {
    loopend = sites_on_node;
  }
  if (otherparity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend) {
    fat4 = t_fatlink + 4 * i;
    long4 = t_longlink + 4 * i;
    mult_adj_su3_mat_vec_4dir(fat4, (su3_vector *)((char *)s + src), s->tempvec);
    mult_adj_su3_mat_vec_4dir(long4, (su3_vector *)((char *)s + src), s->templongvec);
    i ++;
    s ++;
  }
  dir = 0;
  while (dir <= 3) {
    tag[7 - dir] = start_gather((field_offset )((char *)(& (lattice + 0)->tempvec[dir]) - (char *)(lattice + 0)),
                                (int )sizeof(su3_vector ), 7 - dir, parity, gen_pt[7 - dir]);
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    tag[23 - dir] = start_gather((field_offset )((char *)(& (lattice + 0)->templongvec[dir - 8]) - (char *)(lattice + 0)),
                                 (int )sizeof(su3_vector ), 23 - dir, parity, gen_pt[23 - dir]);
    dir ++;
  }
  dir = 0;
  while (dir <= 3) {
    wait_gather(tag[dir]);
    wait_gather(tag[dir + 8]);
    dir ++;
  }
  dir = 0;
  while (dir <= 3) {
    wait_gather(tag[7 - dir]);
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    wait_gather(tag[23 - dir]);
    dir ++;
  }
  if (parity == 2) {
    loopend___0 = even_sites_on_node;
  } else {
    loopend___0 = sites_on_node;
  }
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend___0) {
    fat4 = t_fatlink + 4 * i;
    long4 = t_longlink + 4 * i;
    mult_su3_mat_vec_sum_4dir(fat4, (su3_vector *)*(gen_pt[0] + i), (su3_vector *)*(gen_pt[1] + i),
                              (su3_vector *)*(gen_pt[2] + i), (su3_vector *)*(gen_pt[3] + i),
                              (su3_vector *)((char *)s + dest));
    mult_su3_mat_vec_sum_4dir(long4, (su3_vector *)*(gen_pt[8] + i), (su3_vector *)*(gen_pt[9] + i),
                              (su3_vector *)*(gen_pt[10] + i), (su3_vector *)*(gen_pt[11] + i),
                              & s->templongv1);
    sub_four_su3_vecs((su3_vector *)((char *)s + dest), (su3_vector *)*(gen_pt[7] + i),
                      (su3_vector *)*(gen_pt[6] + i), (su3_vector *)*(gen_pt[5] + i),
                      (su3_vector *)*(gen_pt[4] + i));
    sub_four_su3_vecs(& s->templongv1, (su3_vector *)*(gen_pt[15] + i), (su3_vector *)*(gen_pt[14] + i),
                      (su3_vector *)*(gen_pt[13] + i), (su3_vector *)*(gen_pt[12] + i));
    add_su3_vector((su3_vector *)((char *)s + dest), & s->templongv1, (su3_vector *)((char *)s + dest));
    i ++;
    s ++;
  }
  dir = 0;
  while (dir <= 3) {
    cleanup_gather(tag[dir]);
    cleanup_gather(tag[7 - dir]);
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    cleanup_gather(tag[dir]);
    cleanup_gather(tag[23 - dir]);
    dir ++;
  }
  return;
}
}
void dslash_fn_special(field_offset src , field_offset dest , int parity , msg_tag **tag ,
                       int start ) 
{ 
  register int i ;
  register site *s ;
  register int dir ;
  register int otherparity ;
  register su3_matrix *fat4 ;
  register su3_matrix *long4 ;
  register int loopend ;
  register int loopend___0 ;

  {
  if (! valid_longlinks) {
    load_longlinks();
  }
  if (! valid_fatlinks) {
    load_fatlinks();
  }
  switch (parity) {
  case 2: 
  otherparity = 1;
  break;
  case 1: 
  otherparity = 2;
  break;
  case 3: 
  otherparity = 3;
  break;
  }
  dir = 0;
  while (dir <= 3) {
    if (start == 1) {
      *(tag + dir) = start_gather(src, (int )sizeof(su3_vector ), dir, parity, gen_pt[dir]);
    } else {
      restart_gather(src, (int )sizeof(su3_vector ), dir, parity, gen_pt[dir], *(tag + dir));
    }
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    if (start == 1) {
      *(tag + dir) = start_gather(src, (int )sizeof(su3_vector ), dir, parity, gen_pt[dir]);
    } else {
      restart_gather(src, (int )sizeof(su3_vector ), dir, parity, gen_pt[dir], *(tag + dir));
    }
    dir ++;
  }
  if (otherparity == 2) {
    loopend = even_sites_on_node;
  } else {
    loopend = sites_on_node;
  }
  if (otherparity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend) {
    fat4 = t_fatlink + 4 * i;
    long4 = t_longlink + 4 * i;
    mult_adj_su3_mat_vec_4dir(fat4, (su3_vector *)((char *)s + src), s->tempvec);
    mult_adj_su3_mat_vec_4dir(long4, (su3_vector *)((char *)s + src), s->templongvec);
    i ++;
    s ++;
  }
  dir = 0;
  while (dir <= 3) {
    if (start == 1) {
      *(tag + (7 - dir)) = start_gather((field_offset )((char *)(& (lattice + 0)->tempvec[dir]) - (char *)(lattice + 0)),
                                        (int )sizeof(su3_vector ), 7 - dir, parity,
                                        gen_pt[7 - dir]);
    } else {
      restart_gather((field_offset )((char *)(& (lattice + 0)->tempvec[dir]) - (char *)(lattice + 0)),
                     (int )sizeof(su3_vector ), 7 - dir, parity, gen_pt[7 - dir],
                     *(tag + (7 - dir)));
    }
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    if (start == 1) {
      *(tag + (23 - dir)) = start_gather((field_offset )((char *)(& (lattice + 0)->templongvec[dir - 8]) - (char *)(lattice + 0)),
                                         (int )sizeof(su3_vector ), 23 - dir, parity,
                                         gen_pt[23 - dir]);
    } else {
      restart_gather((field_offset )((char *)(& (lattice + 0)->templongvec[dir - 8]) - (char *)(lattice + 0)),
                     (int )sizeof(su3_vector ), 23 - dir, parity, gen_pt[23 - dir],
                     *(tag + (23 - dir)));
    }
    dir ++;
  }
  dir = 0;
  while (dir <= 3) {
    wait_gather(*(tag + dir));
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    wait_gather(*(tag + dir));
    dir ++;
  }
  dir = 0;
  while (dir <= 3) {
    wait_gather(*(tag + (7 - dir)));
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    wait_gather(*(tag + (23 - dir)));
    dir ++;
  }
  if (parity == 2) {
    loopend___0 = even_sites_on_node;
  } else {
    loopend___0 = sites_on_node;
  }
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend___0) {
    fat4 = t_fatlink + 4 * i;
    long4 = t_longlink + 4 * i;
    mult_su3_mat_vec_sum_4dir(fat4, (su3_vector *)*(gen_pt[0] + i), (su3_vector *)*(gen_pt[1] + i),
                              (su3_vector *)*(gen_pt[2] + i), (su3_vector *)*(gen_pt[3] + i),
                              (su3_vector *)((char *)s + dest));
    mult_su3_mat_vec_sum_4dir(long4, (su3_vector *)*(gen_pt[8] + i), (su3_vector *)*(gen_pt[9] + i),
                              (su3_vector *)*(gen_pt[10] + i), (su3_vector *)*(gen_pt[11] + i),
                              & s->templongv1);
    sub_four_su3_vecs((su3_vector *)((char *)s + dest), (su3_vector *)*(gen_pt[7] + i),
                      (su3_vector *)*(gen_pt[6] + i), (su3_vector *)*(gen_pt[5] + i),
                      (su3_vector *)*(gen_pt[4] + i));
    sub_four_su3_vecs(& s->templongv1, (su3_vector *)*(gen_pt[15] + i), (su3_vector *)*(gen_pt[14] + i),
                      (su3_vector *)*(gen_pt[13] + i), (su3_vector *)*(gen_pt[12] + i));
    add_su3_vector((su3_vector *)((char *)s + dest), & s->templongv1, (su3_vector *)((char *)s + dest));
    i ++;
    s ++;
  }
  return;
}
}
void dslash_fn_on_temp(su3_vector *src , su3_vector *dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register int dir ;
  register int otherparity ;
  msg_tag *tag[16] ;
  su3_vector *tempvec[4] ;
  su3_vector *templongvec[4] ;
  su3_vector *templongv1 ;
  register su3_matrix *fat4 ;
  register su3_matrix *long4 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  register int loopend ;
  register int loopend___0 ;
  register int loopend___1 ;

  {
  dir = 0;
  while (dir <= 3) {
    tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    tempvec[dir] = (su3_vector *)tmp;
    tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    templongvec[dir] = (su3_vector *)tmp___0;
    dir ++;
  }
  tmp___1 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
  templongv1 = (su3_vector *)tmp___1;
  if (! valid_longlinks) {
    load_longlinks();
  }
  if (! valid_fatlinks) {
    load_fatlinks();
  }
  switch (parity) {
  case 2: 
  otherparity = 1;
  break;
  case 1: 
  otherparity = 2;
  break;
  case 3: 
  otherparity = 3;
  break;
  }
  dir = 0;
  while (dir <= 3) {
    tag[dir] = start_gather_from_temp((void *)src, (int )sizeof(su3_vector ), dir,
                                      parity, gen_pt[dir]);
    tag[dir + 8] = start_gather_from_temp((void *)src, (int )sizeof(su3_vector ),
                                          dir + 8, parity, gen_pt[dir + 8]);
    dir ++;
  }
  if (otherparity == 2) {
    loopend = even_sites_on_node;
  } else {
    loopend = sites_on_node;
  }
  if (otherparity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend) {
    fat4 = t_fatlink + 4 * i;
    long4 = t_longlink + 4 * i;
    mult_adj_su3_mat_4vec(fat4, src + i, tempvec[0] + i, tempvec[1] + i, tempvec[2] + i,
                          tempvec[3] + i);
    mult_adj_su3_mat_4vec(long4, src + i, templongvec[0] + i, templongvec[1] + i,
                          templongvec[2] + i, templongvec[3] + i);
    i ++;
    s ++;
  }
  dir = 0;
  while (dir <= 3) {
    tag[7 - dir] = start_gather_from_temp((void *)tempvec[dir], (int )sizeof(su3_vector ),
                                          7 - dir, parity, gen_pt[7 - dir]);
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    tag[23 - dir] = start_gather_from_temp((void *)templongvec[dir - 8], (int )sizeof(su3_vector ),
                                           23 - dir, parity, gen_pt[23 - dir]);
    dir ++;
  }
  dir = 0;
  while (dir <= 3) {
    wait_gather(tag[dir]);
    wait_gather(tag[dir + 8]);
    dir ++;
  }
  if (parity == 2) {
    loopend___0 = even_sites_on_node;
  } else {
    loopend___0 = sites_on_node;
  }
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend___0) {
    fat4 = t_fatlink + 4 * i;
    long4 = t_longlink + 4 * i;
    mult_su3_mat_vec_sum_4dir(fat4, (su3_vector *)*(gen_pt[0] + i), (su3_vector *)*(gen_pt[1] + i),
                              (su3_vector *)*(gen_pt[2] + i), (su3_vector *)*(gen_pt[3] + i),
                              dest + i);
    mult_su3_mat_vec_sum_4dir(long4, (su3_vector *)*(gen_pt[8] + i), (su3_vector *)*(gen_pt[9] + i),
                              (su3_vector *)*(gen_pt[10] + i), (su3_vector *)*(gen_pt[11] + i),
                              templongv1 + i);
    i ++;
    s ++;
  }
  dir = 0;
  while (dir <= 3) {
    wait_gather(tag[7 - dir]);
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    wait_gather(tag[23 - dir]);
    dir ++;
  }
  if (parity == 2) {
    loopend___1 = even_sites_on_node;
  } else {
    loopend___1 = sites_on_node;
  }
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend___1) {
    sub_four_su3_vecs(dest + i, (su3_vector *)*(gen_pt[7] + i), (su3_vector *)*(gen_pt[6] + i),
                      (su3_vector *)*(gen_pt[5] + i), (su3_vector *)*(gen_pt[4] + i));
    sub_four_su3_vecs(templongv1 + i, (su3_vector *)*(gen_pt[15] + i), (su3_vector *)*(gen_pt[14] + i),
                      (su3_vector *)*(gen_pt[13] + i), (su3_vector *)*(gen_pt[12] + i));
    add_su3_vector(dest + i, templongv1 + i, dest + i);
    i ++;
    s ++;
  }
  dir = 0;
  while (dir <= 3) {
    cleanup_gather(tag[dir]);
    cleanup_gather(tag[7 - dir]);
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    cleanup_gather(tag[dir]);
    cleanup_gather(tag[23 - dir]);
    dir ++;
  }
  dir = 0;
  while (dir <= 3) {
    free((void *)tempvec[dir]);
    free((void *)templongvec[dir]);
    dir ++;
  }
  free((void *)templongv1);
  return;
}
}
void dslash_fn_on_temp_special(su3_vector *src , su3_vector *dest , int parity , msg_tag **tag ,
                               int start ) 
{ 
  register int i ;
  register site *s ;
  register int dir ;
  register int otherparity ;
  register su3_matrix *fat4 ;
  register su3_matrix *long4 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  register int loopend ;
  register int loopend___0 ;
  register int loopend___1 ;

  {
  if (temp_not_allocated) {
    dir = 0;
    while (dir <= 3) {
      tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
      temp[dir] = (su3_vector *)tmp;
      tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
      temp[dir + 4] = (su3_vector *)tmp___0;
      dir ++;
    }
    tmp___1 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    temp[8] = (su3_vector *)tmp___1;
    temp_not_allocated = 0;
  }
  if (! valid_longlinks) {
    load_longlinks();
  }
  if (! valid_fatlinks) {
    load_fatlinks();
  }
  switch (parity) {
  case 2: 
  otherparity = 1;
  break;
  case 1: 
  otherparity = 2;
  break;
  case 3: 
  otherparity = 3;
  break;
  }
  dir = 0;
  while (dir <= 3) {
    if (start == 1) {
      *(tag + dir) = start_gather_from_temp((void *)src, (int )sizeof(su3_vector ),
                                            dir, parity, gen_pt[dir]);
      *(tag + (dir + 8)) = start_gather_from_temp((void *)src, (int )sizeof(su3_vector ),
                                                  dir + 8, parity, gen_pt[dir + 8]);
    } else {
      restart_gather_from_temp((void *)src, (int )sizeof(su3_vector ), dir, parity,
                               gen_pt[dir], *(tag + dir));
      restart_gather_from_temp((void *)src, (int )sizeof(su3_vector ), dir + 8, parity,
                               gen_pt[dir + 8], *(tag + (dir + 8)));
    }
    dir ++;
  }
  if (otherparity == 2) {
    loopend = even_sites_on_node;
  } else {
    loopend = sites_on_node;
  }
  if (otherparity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend) {
    fat4 = t_fatlink + 4 * i;
    long4 = t_longlink + 4 * i;
    mult_adj_su3_mat_4vec(fat4, src + i, temp[0] + i, temp[1] + i, temp[2] + i, temp[3] + i);
    mult_adj_su3_mat_4vec(long4, src + i, temp[4] + i, temp[5] + i, temp[6] + i, temp[7] + i);
    i ++;
    s ++;
  }
  dir = 0;
  while (dir <= 3) {
    if (start == 1) {
      *(tag + (7 - dir)) = start_gather_from_temp((void *)temp[dir], (int )sizeof(su3_vector ),
                                                  7 - dir, parity, gen_pt[7 - dir]);
    } else {
      restart_gather_from_temp((void *)temp[dir], (int )sizeof(su3_vector ), 7 - dir,
                               parity, gen_pt[7 - dir], *(tag + (7 - dir)));
    }
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    if (start == 1) {
      *(tag + (23 - dir)) = start_gather_from_temp((void *)temp[(dir - 8) + 4], (int )sizeof(su3_vector ),
                                                   23 - dir, parity, gen_pt[23 - dir]);
    } else {
      restart_gather_from_temp((void *)temp[(dir - 8) + 4], (int )sizeof(su3_vector ),
                               23 - dir, parity, gen_pt[23 - dir], *(tag + (23 - dir)));
    }
    dir ++;
  }
  dir = 0;
  while (dir <= 3) {
    wait_gather(*(tag + dir));
    wait_gather(*(tag + (dir + 8)));
    dir ++;
  }
  if (parity == 2) {
    loopend___0 = even_sites_on_node;
  } else {
    loopend___0 = sites_on_node;
  }
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend___0) {
    fat4 = t_fatlink + 4 * i;
    long4 = t_longlink + 4 * i;
    mult_su3_mat_vec_sum_4dir(fat4, (su3_vector *)*(gen_pt[0] + i), (su3_vector *)*(gen_pt[1] + i),
                              (su3_vector *)*(gen_pt[2] + i), (su3_vector *)*(gen_pt[3] + i),
                              dest + i);
    mult_su3_mat_vec_sum_4dir(long4, (su3_vector *)*(gen_pt[8] + i), (su3_vector *)*(gen_pt[9] + i),
                              (su3_vector *)*(gen_pt[10] + i), (su3_vector *)*(gen_pt[11] + i),
                              temp[8] + i);
    i ++;
    s ++;
  }
  dir = 0;
  while (dir <= 3) {
    wait_gather(*(tag + (7 - dir)));
    dir ++;
  }
  dir = 8;
  while (dir <= 11) {
    wait_gather(*(tag + (23 - dir)));
    dir ++;
  }
  if (parity == 2) {
    loopend___1 = even_sites_on_node;
  } else {
    loopend___1 = sites_on_node;
  }
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend___1) {
    sub_four_su3_vecs(dest + i, (su3_vector *)*(gen_pt[7] + i), (su3_vector *)*(gen_pt[6] + i),
                      (su3_vector *)*(gen_pt[5] + i), (su3_vector *)*(gen_pt[4] + i));
    sub_four_su3_vecs(temp[8] + i, (su3_vector *)*(gen_pt[15] + i), (su3_vector *)*(gen_pt[14] + i),
                      (su3_vector *)*(gen_pt[13] + i), (su3_vector *)*(gen_pt[12] + i));
    add_su3_vector(dest + i, temp[8] + i, dest + i);
    i ++;
    s ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-EaeZ0J2o.i","-O3")
void copy_latvec(field_offset src , field_offset dest , int parity ) ;
void scalar2_mult_add_su3_vector(su3_vector *a , double s1 , su3_vector *b , double s2 ,
                                 su3_vector *c ) ;
void scalar2_mult_add_latvec(field_offset src1 , double scalar1 , field_offset src2 ,
                             double scalar2 , field_offset dest , int parity ) ;
su3_vector *ttt  ;
su3_vector *cg_p  ;
su3_vector *resid  ;
su3_vector *t_dest  ;
int first_congrad  =    1;
int ks_congrad(field_offset src , field_offset dest , double mass___0 , int niter___0 ,
               double rsqmin___0 , int parity , double *final_rsq_ptr ) 
{ 
  register int i ;
  register site *s ;
  int iteration ;
  double a ;
  double b ;
  double rsq ;
  double oldrsq ;
  double pkp ;
  double msq_x4 ;
  double source_norm ;
  double rsqstop ;
  int l_parity ;
  int l_otherparity ;
  msg_tag *tags1[16] ;
  msg_tag *tags2[16] ;
  int special_started ;
  double nflop ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  register int loopend ;
  double tmp___3 ;
  double tmp___4 ;
  register int loopend___0 ;
  double tmp___5 ;
  register int loopend___1 ;
  double tmp___6 ;
  register int loopend___2 ;
  register int loopend___3 ;
  register int loopend___4 ;

  {
  nflop = (double )1187;
  if (parity == 3) {
    nflop *= (double )2;
  }
  special_started = 0;
  switch (parity) {
  case 2: 
  l_parity = 2;
  l_otherparity = 1;
  break;
  case 1: 
  l_parity = 1;
  l_otherparity = 2;
  break;
  case 3: 
  l_parity = 2;
  l_otherparity = 1;
  break;
  }
  msq_x4 = (4.0 * mass___0) * mass___0;
  iteration = 0;
  if (! valid_longlinks) {
    load_longlinks();
  }
  if (! valid_fatlinks) {
    load_fatlinks();
  }
  if (first_congrad) {
    tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    ttt = (su3_vector *)tmp;
    tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    cg_p = (su3_vector *)tmp___0;
    tmp___1 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    resid = (su3_vector *)tmp___1;
    tmp___2 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
    t_dest = (su3_vector *)tmp___2;
    first_congrad = 0;
  }
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    *(t_dest + i) = *((su3_vector *)((char *)s + dest));
    i ++;
    s ++;
  }
  start: 
  if (special_started == 1) {
    cleanup_gathers((msg_tag **)(tags1), (msg_tag **)(tags2));
    special_started = 0;
  }
  source_norm = 0.0;
  rsq = source_norm;
  dslash_fn_on_temp_special(t_dest, ttt, l_otherparity, tags2, 1);
  dslash_fn_on_temp_special(ttt, ttt, l_parity, tags1, 1);
  cleanup_gathers((msg_tag **)(tags1), (msg_tag **)(tags2));
  if (l_parity == 2) {
    loopend = even_sites_on_node;
  } else {
    loopend = sites_on_node;
  }
  if (l_parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend) {
    scalar_mult_add_su3_vector(ttt + i, t_dest + i, - msq_x4, ttt + i);
    add_su3_vector((su3_vector *)((char *)s + src), ttt + i, resid + i);
    *(cg_p + i) = *(resid + i);
    tmp___3 = magsq_su3vec((su3_vector *)((char *)s + src));
    source_norm += tmp___3;
    tmp___4 = magsq_su3vec(resid + i);
    rsq += tmp___4;
    i ++;
    s ++;
  }
  g_doublesum(& source_norm);
  g_doublesum(& rsq);
  iteration ++;
  total_iters ++;
  rsqstop = rsqmin___0 * source_norm;
  if (rsq <= rsqstop) {
    if (parity == 3) {
      l_parity = 1;
      l_otherparity = 2;
      parity = 2;
      iteration = 0;
      goto start;
    }
    *final_rsq_ptr = rsq;
    return (iteration);
  }
  while (1) {
    oldrsq = rsq;
    pkp = 0.0;
    if (special_started == 0) {
      dslash_fn_on_temp_special(cg_p, ttt, l_otherparity, tags2, 1);
      dslash_fn_on_temp_special(ttt, ttt, l_parity, tags1, 1);
      special_started = 1;
    } else {
      dslash_fn_on_temp_special(cg_p, ttt, l_otherparity, tags2, 0);
      dslash_fn_on_temp_special(ttt, ttt, l_parity, tags1, 0);
    }
    pkp = 0.0;
    if (l_parity == 2) {
      loopend___0 = even_sites_on_node;
    } else {
      loopend___0 = sites_on_node;
    }
    if (l_parity == 1) {
      i = even_sites_on_node;
    } else {
      i = 0;
    }
    s = lattice + i;
    while (i < loopend___0) {
      scalar_mult_add_su3_vector(ttt + i, cg_p + i, - msq_x4, ttt + i);
      tmp___5 = su3_rdot(cg_p + i, ttt + i);
      pkp += tmp___5;
      i ++;
      s ++;
    }
    g_doublesum(& pkp);
    iteration ++;
    total_iters ++;
    a = - rsq / pkp;
    rsq = 0.0;
    if (l_parity == 2) {
      loopend___1 = even_sites_on_node;
    } else {
      loopend___1 = sites_on_node;
    }
    if (l_parity == 1) {
      i = even_sites_on_node;
    } else {
      i = 0;
    }
    s = lattice + i;
    while (i < loopend___1) {
      scalar_mult_add_su3_vector(t_dest + i, cg_p + i, a, t_dest + i);
      scalar_mult_add_su3_vector(resid + i, ttt + i, a, resid + i);
      tmp___6 = magsq_su3vec(resid + i);
      rsq += tmp___6;
      i ++;
      s ++;
    }
    g_doublesum(& rsq);
    if (rsq <= rsqstop) {
      if (l_parity == 2) {
        loopend___2 = even_sites_on_node;
      } else {
        loopend___2 = sites_on_node;
      }
      if (l_parity == 1) {
        i = even_sites_on_node;
      } else {
        i = 0;
      }
      s = lattice + i;
      while (i < loopend___2) {
        *((su3_vector *)((char *)s + dest)) = *(t_dest + i);
        i ++;
        s ++;
      }
      if (parity == 3) {
        l_parity = 1;
        l_otherparity = 2;
        parity = 2;
        iteration = 0;
        goto start;
      }
      *final_rsq_ptr = rsq;
      if (special_started == 1) {
        cleanup_gathers((msg_tag **)(tags1), (msg_tag **)(tags2));
        special_started = 0;
      }
      return (iteration);
    }
    b = rsq / oldrsq;
    if (l_parity == 2) {
      loopend___3 = even_sites_on_node;
    } else {
      loopend___3 = sites_on_node;
    }
    if (l_parity == 1) {
      i = even_sites_on_node;
    } else {
      i = 0;
    }
    s = lattice + i;
    while (i < loopend___3) {
      scalar_mult_add_su3_vector(resid + i, cg_p + i, b, cg_p + i);
      i ++;
      s ++;
    }
    if (! (iteration % niter___0 != 0)) {
      break;
    }
  }
  if (iteration < 5 * niter___0) {
    goto start;
  }
  if (l_parity == 2) {
    loopend___4 = even_sites_on_node;
  } else {
    loopend___4 = sites_on_node;
  }
  if (l_parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend___4) {
    *((su3_vector *)((char *)s + dest)) = *(t_dest + i);
    i ++;
    s ++;
  }
  if (parity == 3) {
    l_parity = 1;
    l_otherparity = 2;
    parity = 2;
    iteration = 0;
    goto start;
  }
  *final_rsq_ptr = rsq;
  if (special_started == 1) {
    cleanup_gathers((msg_tag **)(tags1), (msg_tag **)(tags2));
    special_started = 0;
  }
  if (this_node == 0) {
    printf("CG not converged after %d iterations, res. = %e wanted %e\n", iteration,
           rsq, rsqstop);
  }
  fflush(__stdoutp);
  return (iteration);
}
}
void clear_latvec(field_offset v , int parity ) 
{ 
  register int i ;
  register int j ;
  register site *s ;
  register su3_vector *vv ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  switch (parity) {
  case 2: 
  i = 0;
  s = lattice;
  while (i < even_sites_on_node) {
    vv = (su3_vector *)((char *)s + v);
    j = 0;
    while (j < 3) {
      tmp = 0.0;
      vv->c[j].imag = tmp;
      vv->c[j].real = tmp;
      j ++;
    }
    i ++;
    s ++;
  }
  break;
  case 1: 
  i = even_sites_on_node;
  s = lattice + i;
  while (i < sites_on_node) {
    vv = (su3_vector *)((char *)s + v);
    j = 0;
    while (j < 3) {
      tmp___0 = 0.0;
      vv->c[j].imag = tmp___0;
      vv->c[j].real = tmp___0;
      j ++;
    }
    i ++;
    s ++;
  }
  break;
  case 3: 
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    vv = (su3_vector *)((char *)s + v);
    j = 0;
    while (j < 3) {
      tmp___1 = 0.0;
      vv->c[j].imag = tmp___1;
      vv->c[j].real = tmp___1;
      j ++;
    }
    i ++;
    s ++;
  }
  break;
  }
  return;
}
}
void copy_latvec(field_offset src , field_offset dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register su3_vector *spt ;
  register su3_vector *dpt ;

  {
  switch (parity) {
  case 2: 
  i = 0;
  s = lattice;
  while (i < even_sites_on_node) {
    s = lattice + i;
    spt = (su3_vector *)((char *)s + src);
    dpt = (su3_vector *)((char *)s + dest);
    *dpt = *spt;
    i ++;
    s ++;
  }
  break;
  case 1: 
  i = even_sites_on_node;
  s = lattice + i;
  while (i < sites_on_node) {
    s = lattice + i;
    spt = (su3_vector *)((char *)s + src);
    dpt = (su3_vector *)((char *)s + dest);
    *dpt = *spt;
    i ++;
    s ++;
  }
  break;
  case 3: 
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    s = lattice + i;
    spt = (su3_vector *)((char *)s + src);
    dpt = (su3_vector *)((char *)s + dest);
    *dpt = *spt;
    i ++;
    s ++;
  }
  break;
  }
  return;
}
}
void scalar_mult_add_latvec(field_offset src1 , field_offset src2 , double scalar ,
                            field_offset dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register su3_vector *spt1 ;
  register su3_vector *spt2 ;
  register su3_vector *dpt ;
  register int loopend ;

  {
  if (parity == 2) {
    loopend = even_sites_on_node;
  } else {
    loopend = sites_on_node;
  }
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend) {
    spt1 = (su3_vector *)((char *)s + src1);
    spt2 = (su3_vector *)((char *)s + src2);
    dpt = (su3_vector *)((char *)s + dest);
    scalar_mult_add_su3_vector(spt1, spt2, scalar, dpt);
    i ++;
    s ++;
  }
  return;
}
}
void scalar2_mult_add_su3_vector(su3_vector *a , double s1 , su3_vector *b , double s2 ,
                                 su3_vector *c ) 
{ 
  register int i ;

  {
  i = 0;
  while (i < 3) {
    c->c[i].real = s1 * a->c[i].real + s2 * b->c[i].real;
    c->c[i].imag = s1 * a->c[i].imag + s2 * b->c[i].imag;
    i ++;
  }
  return;
}
}
void scalar2_mult_add_latvec(field_offset src1 , double scalar1 , field_offset src2 ,
                             double scalar2 , field_offset dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register su3_vector *spt1 ;
  register su3_vector *spt2 ;
  register su3_vector *dpt ;
  register int loopend ;

  {
  if (parity == 2) {
    loopend = even_sites_on_node;
  } else {
    loopend = sites_on_node;
  }
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (i < loopend) {
    spt1 = (su3_vector *)((char *)s + src1);
    spt2 = (su3_vector *)((char *)s + src2);
    dpt = (su3_vector *)((char *)s + dest);
    scalar2_mult_add_su3_vector(spt1, scalar1, spt2, scalar2, dpt);
    i ++;
    s ++;
  }
  return;
}
}
void scalar_mult_latvec(field_offset src , double scalar , field_offset dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register su3_vector *spt ;
  register su3_vector *dpt ;

  {
  switch (parity) {
  case 2: 
  i = 0;
  s = lattice;
  while (i < even_sites_on_node) {
    spt = (su3_vector *)((char *)s + src);
    dpt = (su3_vector *)((char *)s + dest);
    scalar_mult_su3_vector(spt, scalar, dpt);
    i ++;
    s ++;
  }
  break;
  case 1: 
  i = even_sites_on_node;
  s = lattice + i;
  while (i < sites_on_node) {
    spt = (su3_vector *)((char *)s + src);
    dpt = (su3_vector *)((char *)s + dest);
    scalar_mult_su3_vector(spt, scalar, dpt);
    i ++;
    s ++;
  }
  break;
  case 3: 
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    spt = (su3_vector *)((char *)s + src);
    dpt = (su3_vector *)((char *)s + dest);
    scalar_mult_su3_vector(spt, scalar, dpt);
    i ++;
    s ++;
  }
  break;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-MPNy4gVx.i","-O3")
extern void *realloc(void * , size_t  ) ;
void start_handlers(void) ;
void sort_eight_special(void **pt ) ;
void neighbor_coords_special(int x , int y , int z , int t , int *dirpt , int fb ,
                             int *x2p , int *y2p , int *z2p , int *t2p ) ;
void neighbor_coords(int x , int y , int z , int t , int dir , int *x2p , int *y2p ,
                     int *z2p , int *t2p ) ;
char *field_pointer_at_coordinates(int field , int size , int x , int y , int z ,
                                   int t ) ;
char *field_pointer_at_direction(field_offset field , int size , site *s , int direction ) ;
void cleanup_field_pointer(char *buf ) ;
void g_dcomplexsum(double_complex *cpt ) ;
void g_veccomplexsum(complex *cpt , int ncomplex ) ;
void g_wvectorsum(wilson_vector *wvpt ) ;
void broadcast_double(double *dpt ) ;
void broadcast_complex(complex *cpt ) ;
void broadcast_dcomplex(double_complex *cpt ) ;
void time_stamp(char *msg ) ;
int **neighbor  ;
int n_gathers  ;
void initialize_machine(int argc , char **argv ) 
{ 


  {
  return;
}
}
void make_nn_gathers(void) 
{ 
  int i ;
  void *tmp ;

  {
  tmp = calloc((size_t )8, sizeof(int *));
  neighbor = (int **)tmp;
  n_gathers = 0;
  i = 0;
  while (i <= 3) {
    make_gather(& neighbor_coords_special, & i, 1, 0, 1);
    i ++;
  }
  sort_eight_special((void **)neighbor);
  return;
}
}
void sort_eight_neighborlists(int index___0 ) 
{ 


  {
  sort_eight_special((void **)(neighbor + index___0));
  return;
}
}
void sort_eight_special(void **pt ) 
{ 
  void *tt[8] ;
  register int i ;

  {
  i = 0;
  while (i < 8) {
    tt[i] = *(pt + i);
    i ++;
  }
  i = 0;
  while (i <= 3) {
    *(pt + i) = tt[2 * i];
    *(pt + (7 - i)) = tt[2 * i + 1];
    i ++;
  }
  return;
}
}
void neighbor_coords_special(int x , int y , int z , int t , int *dirpt , int fb ,
                             int *x2p , int *y2p , int *z2p , int *t2p ) 
{ 
  int dir ;

  {
  if (fb == 1) {
    dir = *dirpt;
  } else {
    dir = 7 - *dirpt;
  }
  *x2p = x;
  *y2p = y;
  *z2p = z;
  *t2p = t;
  switch (dir) {
  case 0: 
  *x2p = (x + 1) % nx;
  break;
  case 7: 
  *x2p = ((x + nx) - 1) % nx;
  break;
  case 1: 
  *y2p = (y + 1) % ny;
  break;
  case 6: 
  *y2p = ((y + ny) - 1) % ny;
  break;
  case 2: 
  *z2p = (z + 1) % nz;
  break;
  case 5: 
  *z2p = ((z + nz) - 1) % nz;
  break;
  case 3: 
  *t2p = (t + 1) % nt;
  break;
  case 4: 
  *t2p = ((t + nt) - 1) % nt;
  break;
  default: 
  printf("BOTCH: bad direction\n");
  exit(1);
  }
  return;
}
}
int make_gather(void (*func)(int  , int  , int  , int  , int * , int  , int * , int * ,
                             int * , int * ) , int *args , int inverse , int want_even_odd ,
                int parity_conserve ) 
{ 
  register int i ;
  register int k ;
  register site *s ;
  int dir ;
  int x ;
  int y ;
  int z ;
  int t ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int x2 ;
  int y2 ;
  int z2 ;
  int t2 ;

  {
  if (inverse == 1) {
    n_gathers += 2;
  } else {
    n_gathers ++;
  }
  if (n_gathers > 32) {
    if (this_node == 0) {
      printf("Too many gathers! change MAX_GATHERS\n");
    }
    exit(1);
  }
  tmp = realloc((void *)neighbor, (unsigned long )n_gathers * sizeof(int *));
  neighbor = (int **)tmp;
  if (inverse == 1) {
    tmp___0 = calloc((size_t )sites_on_node, sizeof(int ));
    *(neighbor + (n_gathers - 2)) = (int *)tmp___0;
    if ((unsigned long )*(neighbor + (n_gathers - 2)) == (unsigned long )((void *)0)) {
      printf("NODE %d: no room for neighbor vector\n", this_node);
      terminate(1);
    }
    tmp___1 = calloc((size_t )sites_on_node, sizeof(int ));
    *(neighbor + (n_gathers - 1)) = (int *)tmp___1;
    if ((unsigned long )*(neighbor + (n_gathers - 1)) == (unsigned long )((void *)0)) {
      printf("NODE %d: no room for neighbor vector\n", this_node);
      terminate(1);
    }
    dir = n_gathers - 2;
  } else {
    tmp___2 = calloc((size_t )sites_on_node, sizeof(int ));
    *(neighbor + (n_gathers - 1)) = (int *)tmp___2;
    if ((unsigned long )*(neighbor + (n_gathers - 1)) == (unsigned long )((void *)0)) {
      printf("NODE %d: no room for neighbor vector\n", this_node);
      terminate(1);
    }
    dir = n_gathers - 1;
  }
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    (*func)((int )s->x, (int )s->y, (int )s->z, (int )s->t, args, 1, & x, & y, & z,
            & t);
    k = (((x + y) + z) + t) % 2;
    if (x < 0) {
      printf("DUMMY! Your gather mapping does not stay in lattice\n");
      printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y, (int )s->z,
             (int )s->t, x, y, z, t);
      terminate(1);
    } else
    if (y < 0) {
      printf("DUMMY! Your gather mapping does not stay in lattice\n");
      printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y, (int )s->z,
             (int )s->t, x, y, z, t);
      terminate(1);
    } else
    if (z < 0) {
      printf("DUMMY! Your gather mapping does not stay in lattice\n");
      printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y, (int )s->z,
             (int )s->t, x, y, z, t);
      terminate(1);
    } else
    if (t < 0) {
      printf("DUMMY! Your gather mapping does not stay in lattice\n");
      printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y, (int )s->z,
             (int )s->t, x, y, z, t);
      terminate(1);
    } else
    if (x >= nx) {
      printf("DUMMY! Your gather mapping does not stay in lattice\n");
      printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y, (int )s->z,
             (int )s->t, x, y, z, t);
      terminate(1);
    } else
    if (y >= ny) {
      printf("DUMMY! Your gather mapping does not stay in lattice\n");
      printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y, (int )s->z,
             (int )s->t, x, y, z, t);
      terminate(1);
    } else
    if (z >= nz) {
      printf("DUMMY! Your gather mapping does not stay in lattice\n");
      printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y, (int )s->z,
             (int )s->t, x, y, z, t);
      terminate(1);
    } else
    if (t >= nt) {
      printf("DUMMY! Your gather mapping does not stay in lattice\n");
      printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y, (int )s->z,
             (int )s->t, x, y, z, t);
      terminate(1);
    }
    if (parity_conserve == 0) {
      if (k == 0) {
        if ((int )s->parity == 1) {
          printf("DUMMY! Your gather mapping does not obey claimed parity\n");
          printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y,
                 (int )s->z, (int )s->t, x, y, z, t);
          terminate(1);
        } else {
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
      if (k == 1) {
        if ((int )s->parity == 2) {
          printf("DUMMY! Your gather mapping does not obey claimed parity\n");
          printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y,
                 (int )s->z, (int )s->t, x, y, z, t);
          terminate(1);
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (parity_conserve == 1) {
      if (k == 0) {
        if ((int )s->parity == 2) {
          printf("DUMMY! Your gather mapping does not obey claimed parity\n");
          printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y,
                 (int )s->z, (int )s->t, x, y, z, t);
          terminate(1);
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (k == 1) {
        if ((int )s->parity == 1) {
          printf("DUMMY! Your gather mapping does not obey claimed parity\n");
          printf("It mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y,
                 (int )s->z, (int )s->t, x, y, z, t);
          terminate(1);
        }
      }
    }
    if (inverse == 0) {
      (*func)(x, y, z, t, args, 1, & x2, & y2, & z2, & t2);
      if ((int )s->x != x2) {
        printf("DUMMY! Your gather mapping is not its own inverse\n");
        printf("It\'s square mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y,
               (int )s->z, (int )s->t, x2, y2, z2, t2);
        terminate(1);
      } else
      if ((int )s->y != y2) {
        printf("DUMMY! Your gather mapping is not its own inverse\n");
        printf("It\'s square mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y,
               (int )s->z, (int )s->t, x2, y2, z2, t2);
        terminate(1);
      } else
      if ((int )s->z != z2) {
        printf("DUMMY! Your gather mapping is not its own inverse\n");
        printf("It\'s square mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y,
               (int )s->z, (int )s->t, x2, y2, z2, t2);
        terminate(1);
      } else
      if ((int )s->t != t2) {
        printf("DUMMY! Your gather mapping is not its own inverse\n");
        printf("It\'s square mapped %d %d %d %d to %d %d %d %d\n", (int )s->x, (int )s->y,
               (int )s->z, (int )s->t, x2, y2, z2, t2);
        terminate(1);
      }
    }
    i ++;
    s ++;
  }
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    (*func)((int )s->x, (int )s->y, (int )s->z, (int )s->t, args, 1, & x, & y, & z,
            & t);
    *(*(neighbor + dir) + i) = node_index(x, y, z, t);
    i ++;
    s ++;
  }
  if (inverse != 1) {
    return (dir);
  }
  dir ++;
  i = 0;
  s = lattice;
  while (i < sites_on_node) {
    (*func)((int )s->x, (int )s->y, (int )s->z, (int )s->t, args, -1, & x, & y, & z,
            & t);
    *(*(neighbor + dir) + i) = node_index(x, y, z, t);
    i ++;
    s ++;
  }
  return (dir - 1);
}
}
void neighbor_coords(int x , int y , int z , int t , int dir , int *x2p , int *y2p ,
                     int *z2p , int *t2p ) 
{ 


  {
  *x2p = x;
  *y2p = y;
  *z2p = z;
  *t2p = t;
  switch (dir) {
  case 0: 
  *x2p = (x + 1) % nx;
  break;
  case 7: 
  *x2p = ((x + nx) - 1) % nx;
  break;
  case 1: 
  *y2p = (y + 1) % ny;
  break;
  case 6: 
  *y2p = ((y + ny) - 1) % ny;
  break;
  case 2: 
  *z2p = (z + 1) % nz;
  break;
  case 5: 
  *z2p = ((z + nz) - 1) % nz;
  break;
  case 3: 
  *t2p = (t + 1) % nt;
  break;
  case 4: 
  *t2p = ((t + nt) - 1) % nt;
  break;
  default: 
  printf("BOTCH: bad direction\n");
  exit(1);
  }
  return;
}
}
void start_handlers(void) 
{ 


  {
  return;
}
}
msg_tag *start_gather(field_offset field , int size , int index___0 , int parity ,
                      char **dest ) 
{ 
  register int j ;
  register site *s ;

  {
  switch (parity) {
  case 2: 
  j = 0;
  s = lattice;
  while (j < even_sites_on_node) {
    *(dest + j) = (char *)(lattice + *(*(neighbor + index___0) + j)) + field;
    j ++;
    s ++;
  }
  break;
  case 1: 
  j = even_sites_on_node;
  s = lattice + j;
  while (j < sites_on_node) {
    *(dest + j) = (char *)(lattice + *(*(neighbor + index___0) + j)) + field;
    j ++;
    s ++;
  }
  break;
  case 3: 
  j = 0;
  s = lattice;
  while (j < sites_on_node) {
    *(dest + j) = (char *)(lattice + *(*(neighbor + index___0) + j)) + field;
    j ++;
    s ++;
  }
  break;
  }
  return ((msg_tag *)((void *)0));
}
}
void restart_gather(field_offset field , int size , int index___0 , int parity , char **dest ,
                    msg_tag *mbuf ) 
{ 


  {
  return;
}
}
msg_tag *start_gather_from_temp(void *field , int size , int index___0 , int parity ,
                                char **dest ) 
{ 
  register int j ;
  register site *s ;

  {
  switch (parity) {
  case 2: 
  j = 0;
  s = lattice;
  while (j < even_sites_on_node) {
    *(dest + j) = (char *)field + *(*(neighbor + index___0) + j) * size;
    j ++;
    s ++;
  }
  break;
  case 1: 
  j = even_sites_on_node;
  s = lattice + j;
  while (j < sites_on_node) {
    *(dest + j) = (char *)field + *(*(neighbor + index___0) + j) * size;
    j ++;
    s ++;
  }
  break;
  case 3: 
  j = 0;
  s = lattice;
  while (j < sites_on_node) {
    *(dest + j) = (char *)field + *(*(neighbor + index___0) + j) * size;
    j ++;
    s ++;
  }
  break;
  }
  return ((msg_tag *)((void *)0));
}
}
void restart_gather_from_temp(void *field , int size , int index___0 , int parity ,
                              char **dest , msg_tag *mbuf ) 
{ 


  {
  return;
}
}
void wait_gather(msg_tag *mbuf ) 
{ 


  {
  return;
}
}
void cleanup_gather(msg_tag *mbuf ) 
{ 


  {
  return;
}
}
int g_gather_flag  =    0;
msg_tag *start_general_gather(field_offset field , int size , int *displacement ,
                              int parity , char **dest ) 
{ 
  register int i ;
  register site *s ;
  int tx ;
  int ty ;
  int tz ;
  int tt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (g_gather_flag != 0) {
    tmp = mynode();
    fprintf(__stderrp, "ERROR: node %d, two general_gathers() at once!\n", tmp);
    exit(1);
  }
  if (parity == 1) {
    i = even_sites_on_node;
  } else {
    i = 0;
  }
  s = lattice + i;
  while (1) {
    if (parity == 2) {
      tmp___1 = even_sites_on_node;
    } else {
      tmp___1 = sites_on_node;
    }
    if (! (i < tmp___1)) {
      break;
    }
    if (*(displacement + 0) != 0) {
      tx = (((int )s->x + *(displacement + 0)) + nx) % nx;
    } else {
      tx = (int )s->x;
    }
    if (*(displacement + 1) != 0) {
      ty = (((int )s->y + *(displacement + 1)) + ny) % ny;
    } else {
      ty = (int )s->y;
    }
    if (*(displacement + 2) != 0) {
      tz = (((int )s->z + *(displacement + 2)) + nz) % nz;
    } else {
      tz = (int )s->z;
    }
    if (*(displacement + 3) != 0) {
      tt = (((int )s->t + *(displacement + 3)) + nt) % nt;
    } else {
      tt = (int )s->t;
    }
    tmp___0 = node_index(tx, ty, tz, tt);
    *(dest + i) = (char *)(lattice + tmp___0) + field;
    i ++;
    s ++;
  }
  g_gather_flag = 1;
  return ((msg_tag *)((void *)0));
}
}
void wait_general_gather(msg_tag *mbuf ) 
{ 


  {
  g_gather_flag = 0;
  return;
}
}
void cleanup_general_gather(msg_tag *mbuf ) 
{ 


  {
  return;
}
}
char *field_pointer_at_coordinates(int field , int size , int x , int y , int z ,
                                   int t ) 
{ 
  int index___0 ;

  {
  index___0 = node_index(x, y, z, t);
  return ((char *)(lattice + index___0) + field);
}
}
char *field_pointer_at_direction(field_offset field , int size , site *s , int direction ) 
{ 


  {
  return ((char *)*(*(neighbor + direction) + (s - lattice)) + field);
}
}
void cleanup_field_pointer(char *buf ) 
{ 


  {
  return;
}
}
void send_field(char *buf , int size , int tonode ) 
{ 


  {
  printf("BOTCH: this never happens\n");
  return;
}
}
void get_field(char *buf , int size ) 
{ 


  {
  printf("BOTCH: this never happens\n");
  return;
}
}
static char name[17]  = 
  {      (char )'S',      (char )'c',      (char )'a',      (char )'l', 
        (char )'a',      (char )'r',      (char )' ',      (char )'p', 
        (char )'r',      (char )'o',      (char )'c',      (char )'e', 
        (char )'s',      (char )'s',      (char )'o',      (char )'r', 
        (char )'\000'};
char *machine_type(void) 
{ 


  {
  return (name);
}
}
int mynode(void) 
{ 


  {
  return (0);
}
}
int numnodes(void) 
{ 


  {
  return (1);
}
}
void g_sync(void) 
{ 


  {
  return;
}
}
void g_floatsum(float *fpt ) 
{ 


  {
  return;
}
}
void g_doublesum(double *dpt ) 
{ 


  {
  return;
}
}
void g_vecdoublesum(double *dpt , int ndoubles ) 
{ 


  {
  return;
}
}
void g_complexsum(complex *cpt ) 
{ 


  {
  return;
}
}
void g_dcomplexsum(double_complex *cpt ) 
{ 


  {
  return;
}
}
void g_veccomplexsum(complex *cpt , int ncomplex ) 
{ 


  {
  return;
}
}
void g_wvectorsum(wilson_vector *wvpt ) 
{ 


  {
  return;
}
}
void g_xor32(u_int32type *pt ) 
{ 


  {
  return;
}
}
void g_floatmax(float *fpt ) 
{ 


  {
  return;
}
}
void g_doublemax(double *dpt ) 
{ 


  {
  return;
}
}
void broadcast_float(float *fpt ) 
{ 


  {
  return;
}
}
void broadcast_double(double *dpt ) 
{ 


  {
  return;
}
}
void broadcast_complex(complex *cpt ) 
{ 


  {
  return;
}
}
void broadcast_dcomplex(double_complex *cpt ) 
{ 


  {
  return;
}
}
void broadcast_bytes(char *buf , int size ) 
{ 


  {
  return;
}
}
void send_integer(int tonode , int *address ) 
{ 


  {
  printf("BOTCH: this never happens\n");
  return;
}
}
void receive_integer(int *address ) 
{ 


  {
  printf("BOTCH: this never happens\n");
  return;
}
}
double dclock(void) 
{ 
  long fine ;

  {
  fine = (long )0.;
  return ((double )fine / 1000000.0);
}
}
void time_stamp(char *msg ) 
{ 
  time_t time_stamp___0 ;
  char *tmp ;
  int tmp___0 ;

  {
  tmp___0 = mynode();
  if (tmp___0 == 0) {
    time(& time_stamp___0);
    tmp = ctime((time_t const   *)(& time_stamp___0));
    printf("%s: %s\n", msg, tmp);
  }
  return;
}
}
void terminate(int status ) 
{ 


  {
  time_stamp((char *)"termination");
  printf("Termination: status = %d\n", status);
  fflush(__stdoutp);
  fflush(__stderrp);
  exit(status);
}
}
void normal_exit(int status ) 
{ 


  {
  exit(status);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-yYhmIJrt.i","-O3")
extern int open(char const   * , int   , ...)  __asm__("_open")  ;
extern int close(int  )  __asm__("_close")  ;
extern off_t lseek(int  , off_t  , int  ) ;
extern ssize_t read(int  , void * , size_t  )  __asm__("_read")  ;
extern ssize_t write(int  , void const   * , size_t  )  __asm__("_write")  ;
FILE *g_open(char const   *filename , char const   *mode ) 
{ 
  int fd ;
  int oflg ;
  int *fp ;
  char *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
  if ((int const   )*(mode + 0) == 97) {
    printf("g_open: Node %d. Append not supported in PIOFS\n", this_node);
    return ((FILE *)((void *)0));
  } else
  if ((int const   )*(mode + 0) == 119) {
    oflg = 513;
  } else
  if ((int const   )*(mode + 0) == 114) {
    oflg = 0;
    tmp = strchr(mode, '+');
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      oflg = 2;
    }
  } else {
    printf("g_open: Node %d. mode %s not recognized\n", this_node, mode);
    return ((FILE *)((void *)0));
  }
  fd = open(filename, oflg, 420);
  if (fd == -1) {
    tmp___0 = __error();
    printf("g_open: Node %d error %d opening %s\n", this_node, *tmp___0, filename);
    return ((FILE *)((void *)0));
  }
  tmp___1 = calloc((size_t )1, sizeof(int ));
  fp = (int *)tmp___1;
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    printf("g_open: Node %d can\'t malloc fp\n", this_node);
    fflush(__stdoutp);
    terminate(1);
  }
  *fp = fd;
  return ((FILE *)fp);
}
}
int g_seek(FILE *stream , off_t offset , int whence ) 
{ 
  int fd ;
  off_t tmp ;

  {
  fd = *((int *)stream);
  tmp = lseek(fd, offset, whence);
  return ((int )tmp);
}
}
size_t g_write(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int fd ;
  ssize_t tmp ;

  {
  fd = *((int *)stream);
  tmp = write(fd, ptr, (size_t )((int )(size * nmemb)));
  return ((size_t )tmp / size);
}
}
size_t g_read(void *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int fd ;
  ssize_t tmp ;

  {
  fd = *((int *)stream);
  tmp = read(fd, ptr, (size_t )((int )(size * nmemb)));
  return ((size_t )tmp / size);
}
}
int g_close(FILE *stream ) 
{ 
  int fd ;
  int status ;

  {
  fd = *((int *)stream);
  status = close(fd);
  free((void *)stream);
  return (status);
}
}
