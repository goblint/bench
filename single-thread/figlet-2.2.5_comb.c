/* Generated by CIL v. 1.6.0 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 182 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 188 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 273 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 325 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef int wchar_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 354 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned int wint_t;
#line 76 "zipio.h"
struct __anonstruct_ZFILE_30 {
   int len ;
   unsigned char *ptr ;
};
#line 76 "zipio.h"
typedef struct __anonstruct_ZFILE_30 ZFILE;
#line 114 "figlet.c"
typedef long inchr;
#line 146 "figlet.c"
typedef wchar_t outchr;
#line 159 "figlet.c"
struct fc {
   inchr ord ;
   outchr **thechar ;
   struct fc *next ;
};
#line 159 "figlet.c"
typedef struct fc fcharnode;
#line 179 "figlet.c"
struct cfn {
   char *thename ;
   struct cfn *next ;
};
#line 179 "figlet.c"
typedef struct cfn cfnamenode;
#line 186 "figlet.c"
struct cm {
   int thecommand ;
   inchr rangelo ;
   inchr rangehi ;
   inchr offset ;
   struct cm *next ;
};
#line 186 "figlet.c"
typedef struct cm comnode;
#line 221 "zipio.c"
struct ZipioState {
   int len ;
   unsigned char *ptr ;
   unsigned long runtimetypeid1 ;
   int errorencountered ;
   unsigned char inpbuf[8192] ;
   unsigned char *ptrbuf[2048] ;
   unsigned char getbuf[32768U] ;
   long getoff ;
   FILE *tmpfil ;
   unsigned long inpinf ;
   unsigned long outinf ;
   unsigned long sign ;
   unsigned int vers ;
   unsigned int flag ;
   unsigned int comp ;
   unsigned int mtim ;
   unsigned int mdat ;
   unsigned long crc3 ;
   unsigned long csiz ;
   unsigned long usiz ;
   unsigned int flen ;
   unsigned int elen ;
   FILE *OpenFile ;
   void *inflatestate ;
   unsigned long fileposition ;
   unsigned long filecrc ;
   unsigned long runtimetypeid2 ;
};
#line 105 "inflate.c"
typedef unsigned long ulg;
#line 106 "inflate.c"
typedef unsigned short ush;
#line 107 "inflate.c"
typedef unsigned char uch;
#line 110
struct huft;
#line 110 "inflate.c"
struct InflateState {
   unsigned long runtimetypeid1 ;
   int errorencountered ;
   int state ;
   struct huft *tl ;
   struct huft *td ;
   int bl ;
   int bd ;
   unsigned int storelength ;
   int lastblock ;
   ulg bb ;
   unsigned int bk ;
   unsigned int bp ;
   unsigned int bs ;
   unsigned char buffer[16384] ;
   ulg catch_bb ;
   unsigned int catch_bk ;
   unsigned int catch_bp ;
   unsigned int catch_bs ;
   unsigned int wp ;
   unsigned int wf ;
   unsigned char window[32768] ;
   void *AppState ;
   int (*putbuffer_ptr)(void *AppState , unsigned char *buffer , long length ) ;
   void *(*malloc_ptr)(long length ) ;
   void (*free_ptr)(void *buffer ) ;
   unsigned long runtimetypeid2 ;
};
#line 368 "inflate.c"
union __anonunion_v_1 {
   ush n ;
   struct huft *t ;
};
#line 368 "inflate.c"
struct huft {
   uch e ;
   uch b ;
   union __anonunion_v_1 v ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 1 "figlet.o"
#pragma merger("0","/tmp/cil-ghyQ_Z7R.i","")
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 171
extern struct _IO_FILE *stderr ;
#line 357
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 363
extern int printf(char const   * __restrict  __format  , ...) ;
#line 439
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 544
extern int getchar(void) ;
#line 586
extern int putchar(int __c ) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 471
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 544
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 567
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 128 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 136
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 143
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 235
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 262
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 126
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 129
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 211 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 119 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 354 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 144 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wchar_t *( __attribute__((__leaf__)) wcscpy)(wchar_t * __restrict  __dest ,
                                                                                  wchar_t const   * __restrict  __src ) ;
#line 152
extern  __attribute__((__nothrow__)) wchar_t *( __attribute__((__leaf__)) wcscat)(wchar_t * __restrict  __dest ,
                                                                                  wchar_t const   * __restrict  __src ) ;
#line 284
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcslen)(wchar_t const   *__s )  __attribute__((__pure__)) ;
#line 147 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswspace)(wint_t __wc ) ;
#line 32 "utf8.h"
size_t utf8_to_wchar(char const   *in , size_t insize , wchar_t *out , size_t outsize ,
                     int flags ) ;
#line 34
size_t wchar_to_utf8(wchar_t const   *in , size_t insize , char *out , size_t outsize ,
                     int flags ) ;
#line 93 "zipio.h"
ZFILE *Zopen(char const   *path , char const   *mode ) ;
#line 94
int _Zgetc(ZFILE *stream ) ;
#line 98
int Zclose(ZFILE *stream ) ;
#line 104 "figlet.c"
int toiletfont  ;
#line 116 "figlet.c"
inchr *inchrline  ;
#line 118 "figlet.c"
int inchrlinelen  ;
#line 118 "figlet.c"
int inchrlinelenlimit  ;
#line 119 "figlet.c"
inchr deutsch[7]  = {      (inchr )196,      (inchr )214,      (inchr )220,      (inchr )228, 
        (inchr )246,      (inchr )252,      (inchr )223};
#line 130 "figlet.c"
int hzmode  ;
#line 131 "figlet.c"
int gndbl[4]  ;
#line 132 "figlet.c"
inchr gn[4]  ;
#line 133 "figlet.c"
int gl  ;
#line 134 "figlet.c"
int gr  ;
#line 136 "figlet.c"
int Myargc  ;
#line 137 "figlet.c"
char **Myargv  ;
#line 165 "figlet.c"
fcharnode *fcharlist  ;
#line 166 "figlet.c"
outchr **currchar  ;
#line 167 "figlet.c"
int currcharwidth  ;
#line 168 "figlet.c"
int previouscharwidth  ;
#line 169 "figlet.c"
outchr **outputline  ;
#line 170 "figlet.c"
int outlinelen  ;
#line 184 "figlet.c"
cfnamenode *cfilelist  ;
#line 184 "figlet.c"
cfnamenode **cfilelistend  ;
#line 194 "figlet.c"
comnode *commandlist  ;
#line 194 "figlet.c"
comnode **commandlistend  ;
#line 202 "figlet.c"
int deutschflag  ;
#line 202 "figlet.c"
int justification  ;
#line 202 "figlet.c"
int paragraphflag  ;
#line 202 "figlet.c"
int right2left  ;
#line 202 "figlet.c"
int multibyte  ;
#line 203 "figlet.c"
int cmdinput  ;
#line 214 "figlet.c"
int smushmode  ;
#line 220 "figlet.c"
int smushoverride  ;
#line 222 "figlet.c"
int outputwidth  ;
#line 223 "figlet.c"
int outlinelenlimit  ;
#line 224 "figlet.c"
char *fontdirname  ;
#line 224 "figlet.c"
char *fontname  ;
#line 233 "figlet.c"
char hardblank  ;
#line 234 "figlet.c"
int charheight  ;
#line 243 "figlet.c"
char *myname  ;
#line 258 "figlet.c"
int get_columns(void) 
{ 
  struct winsize ws ;
  int fd ;
  int result ;
  int tmp ;

  {
#line 263
  fd = open("/dev/tty", 1);
#line 263
  if (fd < 0) {
#line 263
    return (-1);
  }
#line 264
  result = ioctl(fd, 21523UL, & ws);
#line 265
  close(fd);
#line 266
  if (result) {
#line 266
    tmp = -1;
  } else {
#line 266
    tmp = (int )ws.ws_col;
  }
#line 266
  return (tmp);
}
}
#line 281 "figlet.c"
char *myalloc(size_t size ) 
{ 
  char *ptr ;
  void *tmp ;

  {
#line 292
  tmp = malloc(size);
#line 292
  ptr = (char *)tmp;
#line 292
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 293
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Out of memory\n",
            myname);
#line 294
    exit(1);
  } else {
#line 297
    return (ptr);
  }
}
}
#line 310 "figlet.c"
int hasdirsep(char *s1 ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 313
  tmp___0 = strchr((char const   *)s1, '/');
#line 313
  if (tmp___0) {
#line 313
    return (1);
  } else {
#line 314
    tmp = strchr((char const   *)s1, '\\');
#line 314
    if (tmp) {
#line 314
      return (1);
    } else {
#line 315
      return (0);
    }
  }
}
}
#line 326 "figlet.c"
int suffixcmp(char *s1 , char *s2 ) 
{ 
  int len1 ;
  int len2 ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 332
  tmp = strlen((char const   *)s1);
#line 332
  len1 = (int )tmp;
#line 333
  tmp___0 = strlen((char const   *)s2);
#line 333
  len2 = (int )tmp___0;
#line 334
  if (len2 > len1) {
#line 334
    return (0);
  }
#line 335
  s1 += len1 - len2;
#line 336
  while (*s1) {
#line 337
    tmp___1 = tolower((int )*s1);
#line 337
    tmp___2 = tolower((int )*s2);
#line 337
    if (tmp___1 != tmp___2) {
#line 337
      return (0);
    }
#line 338
    s1 ++;
#line 339
    s2 ++;
  }
#line 341
  return (1);
}
}
#line 352 "figlet.c"
void skiptoeol(ZFILE *fp ) 
{ 
  int dummy ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;

  {
#line 357
  while (1) {
#line 357
    (fp->len) --;
#line 357
    if (fp->len >= 0) {
#line 357
      tmp___1 = fp->ptr;
#line 357
      (fp->ptr) ++;
#line 357
      dummy = (int )*tmp___1;
    } else {
#line 357
      tmp___2 = _Zgetc(fp);
#line 357
      dummy = tmp___2;
    }
#line 357
    if (! (dummy != -1)) {
#line 357
      break;
    }
#line 358
    if (dummy == 10) {
#line 358
      return;
    }
#line 359
    if (dummy == 13) {
#line 360
      (fp->len) --;
#line 360
      if (fp->len >= 0) {
#line 360
        tmp = fp->ptr;
#line 360
        (fp->ptr) ++;
#line 360
        dummy = (int )*tmp;
      } else {
#line 360
        tmp___0 = _Zgetc(fp);
#line 360
        dummy = tmp___0;
      }
#line 361
      if (dummy != -1) {
#line 361
        if (dummy != 10) {
#line 361
          (fp->ptr) --;
#line 361
          (fp->len) ++;
        }
      }
#line 362
      return;
    }
  }
#line 365
  return;
}
}
#line 376 "figlet.c"
char *myfgets(char *line , int maxlen , ZFILE *fp ) 
{ 
  int c ;
  char *p ;
  char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 381
  c = 0;
#line 384
  p = line;
#line 385
  while (1) {
#line 385
    (fp->len) --;
#line 385
    if (fp->len >= 0) {
#line 385
      tmp___2 = fp->ptr;
#line 385
      (fp->ptr) ++;
#line 385
      c = (int )*tmp___2;
    } else {
#line 385
      tmp___3 = _Zgetc(fp);
#line 385
      c = tmp___3;
    }
#line 385
    if (c != -1) {
#line 385
      if (! maxlen) {
#line 385
        break;
      }
    } else {
#line 385
      break;
    }
#line 386
    tmp = p;
#line 386
    p ++;
#line 386
    *tmp = (char )c;
#line 387
    maxlen --;
#line 388
    if (c == 10) {
#line 388
      break;
    }
#line 389
    if (c == 13) {
#line 390
      (fp->len) --;
#line 390
      if (fp->len >= 0) {
#line 390
        tmp___0 = fp->ptr;
#line 390
        (fp->ptr) ++;
#line 390
        c = (int )*tmp___0;
      } else {
#line 390
        tmp___1 = _Zgetc(fp);
#line 390
        c = tmp___1;
      }
#line 391
      if (c != -1) {
#line 391
        if (c != 10) {
#line 391
          (fp->ptr) --;
#line 391
          (fp->len) ++;
        }
      }
#line 392
      *(p - 1) = (char )'\n';
#line 393
      break;
    }
  }
#line 396
  *p = (char)0;
#line 397
  if (c == -1) {
#line 397
    tmp___4 = (char *)((void *)0);
  } else {
#line 397
    tmp___4 = line;
  }
#line 397
  return (tmp___4);
}
}
#line 409 "figlet.c"
void printusage(FILE *out ) 
{ 


  {
#line 412
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"Usage: %s [ -cklnoprstvxDELNRSWX ] [ -d fontdirectory ]\n",
          myname);
#line 415
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"              [ -f fontfile ] [ -m smushmode ] [ -w outputwidth ]\n");
#line 417
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"              [ -C controlfile ] [ -I infocode ] [ message ]\n");
#line 419
  return;
}
}
#line 430 "figlet.c"
void printinfo(int infonum ) 
{ 


  {
#line 433
  switch (infonum) {
  case 0: 
#line 435
  printf((char const   * __restrict  )"FIGlet Copyright (C) 1991-2012 Glenn Chappell, Ian Chai, ");
#line 436
  printf((char const   * __restrict  )"John Cowan,\nChristiaan Keet and Claudio Matsuoka\n");
#line 437
  printf((char const   * __restrict  )"Internet: <info@figlet.org> ");
#line 438
  printf((char const   * __restrict  )"Version: %s, date: %s\n\n", "2.2.5", "31 May 2012");
#line 439
  printf((char const   * __restrict  )"FIGlet, along with the various FIGlet fonts");
#line 440
  printf((char const   * __restrict  )" and documentation, may be\n");
#line 441
  printf((char const   * __restrict  )"freely copied and distributed.\n\n");
#line 442
  printf((char const   * __restrict  )"If you use FIGlet, please send an");
#line 443
  printf((char const   * __restrict  )" e-mail message to <info@figlet.org>.\n\n");
#line 444
  printf((char const   * __restrict  )"The latest version of FIGlet is available from the");
#line 445
  printf((char const   * __restrict  )" web site,\n\thttp://www.figlet.org/\n\n");
#line 446
  printusage(stdout);
#line 447
  break;
  case 1: 
#line 449
  printf((char const   * __restrict  )"%d\n", 20205);
#line 450
  break;
  case 2: 
#line 452
  printf((char const   * __restrict  )"%s\n", fontdirname);
#line 453
  break;
  case 3: 
#line 455
  printf((char const   * __restrict  )"%s\n", fontname);
#line 456
  break;
  case 4: 
#line 458
  printf((char const   * __restrict  )"%d\n", outputwidth);
#line 459
  break;
  case 5: 
#line 461
  printf((char const   * __restrict  )"%s", "flf2");
#line 463
  printf((char const   * __restrict  )" %s", "tlf2");
#line 465
  printf((char const   * __restrict  )"\n");
  }
#line 467
  return;
}
}
#line 477 "figlet.c"
void readmagic(ZFILE *fp , char *magic ) 
{ 
  int i ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 483
  i = 0;
#line 483
  while (i < 4) {
#line 484
    (fp->len) --;
#line 484
    if (fp->len >= 0) {
#line 484
      tmp = fp->ptr;
#line 484
      (fp->ptr) ++;
#line 484
      *(magic + i) = (char )*tmp;
    } else {
#line 484
      tmp___0 = _Zgetc(fp);
#line 484
      *(magic + i) = (char )tmp___0;
    }
#line 483
    i ++;
  }
#line 486
  *(magic + 4) = (char)0;
#line 487
  return;
}
}
#line 496 "figlet.c"
void skipws(ZFILE *fp ) 
{ 
  int c ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
#line 500
  while (1) {
#line 500
    (fp->len) --;
#line 500
    if (fp->len >= 0) {
#line 500
      tmp = fp->ptr;
#line 500
      (fp->ptr) ++;
#line 500
      c = (int )*tmp;
    } else {
#line 500
      tmp___0 = _Zgetc(fp);
#line 500
      c = tmp___0;
    }
#line 500
    if ((c & -128) == 0) {
#line 500
      tmp___1 = __ctype_b_loc();
#line 500
      if ((int const   )*(*tmp___1 + c) & 8192) {
#line 500
        tmp___2 = 1;
      } else {
#line 500
        tmp___2 = 0;
      }
    } else {
#line 500
      tmp___2 = 0;
    }
#line 500
    if (! tmp___2) {
#line 500
      break;
    }
  }
#line 501
  (fp->ptr) --;
#line 501
  (fp->len) ++;
#line 502
  return;
}
}
#line 512 "figlet.c"
void readnum(ZFILE *fp , inchr *nump ) 
{ 
  int acc ;
  char *p ;
  int c ;
  int base ;
  int sign ;
  char digits[17] ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  unsigned char *tmp___5 ;
  int tmp___6 ;

  {
#line 516
  acc = 0;
#line 520
  sign = 1;
#line 521
  digits[0] = (char )'0';
#line 521
  digits[1] = (char )'1';
#line 521
  digits[2] = (char )'2';
#line 521
  digits[3] = (char )'3';
#line 521
  digits[4] = (char )'4';
#line 521
  digits[5] = (char )'5';
#line 521
  digits[6] = (char )'6';
#line 521
  digits[7] = (char )'7';
#line 521
  digits[8] = (char )'8';
#line 521
  digits[9] = (char )'9';
#line 521
  digits[10] = (char )'A';
#line 521
  digits[11] = (char )'B';
#line 521
  digits[12] = (char )'C';
#line 521
  digits[13] = (char )'D';
#line 521
  digits[14] = (char )'E';
#line 521
  digits[15] = (char )'F';
#line 521
  digits[16] = (char )'\000';
#line 523
  skipws(fp);
#line 524
  (fp->len) --;
#line 524
  if (fp->len >= 0) {
#line 524
    tmp = fp->ptr;
#line 524
    (fp->ptr) ++;
#line 524
    c = (int )*tmp;
  } else {
#line 524
    tmp___0 = _Zgetc(fp);
#line 524
    c = tmp___0;
  }
#line 525
  if (c == 45) {
#line 526
    sign = -1;
  } else {
#line 529
    (fp->ptr) --;
#line 529
    (fp->len) ++;
  }
#line 531
  (fp->len) --;
#line 531
  if (fp->len >= 0) {
#line 531
    tmp___1 = fp->ptr;
#line 531
    (fp->ptr) ++;
#line 531
    c = (int )*tmp___1;
  } else {
#line 531
    tmp___2 = _Zgetc(fp);
#line 531
    c = tmp___2;
  }
#line 532
  if (c == 48) {
#line 533
    (fp->len) --;
#line 533
    if (fp->len >= 0) {
#line 533
      tmp___3 = fp->ptr;
#line 533
      (fp->ptr) ++;
#line 533
      c = (int )*tmp___3;
    } else {
#line 533
      tmp___4 = _Zgetc(fp);
#line 533
      c = tmp___4;
    }
#line 534
    if (c == 120) {
#line 535
      base = 16;
    } else
#line 534
    if (c == 88) {
#line 535
      base = 16;
    } else {
#line 538
      base = 8;
#line 539
      (fp->ptr) --;
#line 539
      (fp->len) ++;
    }
  } else {
#line 543
    base = 10;
#line 544
    (fp->ptr) --;
#line 544
    (fp->len) ++;
  }
#line 547
  while (1) {
#line 547
    (fp->len) --;
#line 547
    if (fp->len >= 0) {
#line 547
      tmp___5 = fp->ptr;
#line 547
      (fp->ptr) ++;
#line 547
      c = (int )*tmp___5;
    } else {
#line 547
      tmp___6 = _Zgetc(fp);
#line 547
      c = tmp___6;
    }
#line 547
    if (! (c != -1)) {
#line 547
      break;
    }
#line 548
    c = toupper(c);
#line 549
    p = strchr((char const   *)(digits), c);
#line 550
    if (! p) {
#line 551
      (fp->ptr) --;
#line 551
      (fp->len) ++;
#line 552
      *nump = (inchr )(acc * sign);
#line 553
      return;
    }
#line 555
    acc = (int )((long )(acc * base) + (p - digits));
  }
#line 557
  *nump = (inchr )(acc * sign);
#line 558
  return;
}
}
#line 571 "figlet.c"
inchr readTchar(ZFILE *fp ) 
{ 
  inchr thechar ;
  char next ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;

  {
#line 577
  (fp->len) --;
#line 577
  if (fp->len >= 0) {
#line 577
    tmp = fp->ptr;
#line 577
    (fp->ptr) ++;
#line 577
    thechar = (inchr )*tmp;
  } else {
#line 577
    tmp___0 = _Zgetc(fp);
#line 577
    thechar = (inchr )tmp___0;
  }
#line 578
  if (thechar == 10L) {
#line 579
    (fp->ptr) --;
#line 579
    (fp->len) ++;
#line 580
    return ((inchr )'\000');
  } else
#line 578
  if (thechar == 13L) {
#line 579
    (fp->ptr) --;
#line 579
    (fp->len) ++;
#line 580
    return ((inchr )'\000');
  }
#line 582
  if (thechar != 92L) {
#line 582
    return (thechar);
  }
#line 583
  (fp->len) --;
#line 583
  if (fp->len >= 0) {
#line 583
    tmp___1 = fp->ptr;
#line 583
    (fp->ptr) ++;
#line 583
    next = (char )*tmp___1;
  } else {
#line 583
    tmp___2 = _Zgetc(fp);
#line 583
    next = (char )tmp___2;
  }
#line 584
  switch ((int )next) {
  case 97: 
#line 586
  return ((inchr )7);
  case 98: 
#line 588
  return ((inchr )8);
  case 101: 
#line 590
  return ((inchr )27);
  case 102: 
#line 592
  return ((inchr )12);
  case 110: 
#line 594
  return ((inchr )10);
  case 114: 
#line 596
  return ((inchr )13);
  case 116: 
#line 598
  return ((inchr )9);
  case 118: 
#line 600
  return ((inchr )11);
  default: 
#line 602
  if ((int )next == 45) {
#line 603
    (fp->ptr) --;
#line 603
    (fp->len) ++;
#line 604
    readnum(fp, & thechar);
#line 605
    return (thechar);
  } else
#line 602
  if ((int )next == 120) {
#line 603
    (fp->ptr) --;
#line 603
    (fp->len) ++;
#line 604
    readnum(fp, & thechar);
#line 605
    return (thechar);
  } else
#line 602
  if ((int )next >= 48) {
#line 602
    if ((int )next <= 57) {
#line 603
      (fp->ptr) --;
#line 603
      (fp->len) ++;
#line 604
      readnum(fp, & thechar);
#line 605
      return (thechar);
    }
  }
#line 607
  return ((inchr )next);
  }
}
}
#line 620 "figlet.c"
inchr charsetname(ZFILE *fp ) 
{ 
  inchr result ;

  {
#line 625
  result = readTchar(fp);
#line 626
  if (result == 10L) {
#line 627
    result = (inchr )0;
#line 628
    (fp->ptr) --;
#line 628
    (fp->len) ++;
  } else
#line 626
  if (result == 13L) {
#line 627
    result = (inchr )0;
#line 628
    (fp->ptr) --;
#line 628
    (fp->len) ++;
  }
#line 630
  return (result);
}
}
#line 642 "figlet.c"
void charset(int n , ZFILE *controlfile ) 
{ 
  int ch ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  inchr tmp___4 ;
  unsigned char *tmp___5 ;
  int tmp___6 ;
  unsigned char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  inchr tmp___13 ;
  inchr tmp___14 ;

  {
#line 648
  skipws(controlfile);
#line 649
  (controlfile->len) --;
#line 649
  if (controlfile->len >= 0) {
#line 649
    tmp = controlfile->ptr;
#line 649
    (controlfile->ptr) ++;
#line 649
    tmp___1 = (int )*tmp;
  } else {
#line 649
    tmp___0 = _Zgetc(controlfile);
#line 649
    tmp___1 = tmp___0;
  }
#line 649
  if (tmp___1 != 57) {
#line 650
    skiptoeol(controlfile);
#line 651
    return;
  }
#line 653
  (controlfile->len) --;
#line 653
  if (controlfile->len >= 0) {
#line 653
    tmp___2 = controlfile->ptr;
#line 653
    (controlfile->ptr) ++;
#line 653
    ch = (int )*tmp___2;
  } else {
#line 653
    tmp___3 = _Zgetc(controlfile);
#line 653
    ch = tmp___3;
  }
#line 654
  if (ch == 54) {
#line 655
    tmp___4 = charsetname(controlfile);
#line 655
    gn[n] = 65536L * tmp___4 + 128L;
#line 656
    gndbl[n] = 0;
#line 657
    skiptoeol(controlfile);
#line 658
    return;
  }
#line 660
  if (ch != 52) {
#line 661
    skiptoeol(controlfile);
#line 662
    return;
  }
#line 664
  (controlfile->len) --;
#line 664
  if (controlfile->len >= 0) {
#line 664
    tmp___5 = controlfile->ptr;
#line 664
    (controlfile->ptr) ++;
#line 664
    ch = (int )*tmp___5;
  } else {
#line 664
    tmp___6 = _Zgetc(controlfile);
#line 664
    ch = tmp___6;
  }
#line 665
  if (ch == 120) {
#line 666
    (controlfile->len) --;
#line 666
    if (controlfile->len >= 0) {
#line 666
      tmp___7 = controlfile->ptr;
#line 666
      (controlfile->ptr) ++;
#line 666
      tmp___9 = (int )*tmp___7;
    } else {
#line 666
      tmp___8 = _Zgetc(controlfile);
#line 666
      tmp___9 = tmp___8;
    }
#line 666
    if (tmp___9 != 57) {
#line 667
      skiptoeol(controlfile);
#line 668
      return;
    }
#line 670
    (controlfile->len) --;
#line 670
    if (controlfile->len >= 0) {
#line 670
      tmp___10 = controlfile->ptr;
#line 670
      (controlfile->ptr) ++;
#line 670
      tmp___12 = (int )*tmp___10;
    } else {
#line 670
      tmp___11 = _Zgetc(controlfile);
#line 670
      tmp___12 = tmp___11;
    }
#line 670
    if (tmp___12 != 52) {
#line 671
      skiptoeol(controlfile);
#line 672
      return;
    }
#line 674
    skipws(controlfile);
#line 675
    tmp___13 = charsetname(controlfile);
#line 675
    gn[n] = 65536L * tmp___13;
#line 676
    gndbl[n] = 1;
#line 677
    skiptoeol(controlfile);
#line 678
    return;
  }
#line 680
  (controlfile->ptr) --;
#line 680
  (controlfile->len) ++;
#line 681
  skipws(controlfile);
#line 682
  tmp___14 = charsetname(controlfile);
#line 682
  gn[n] = 65536L * tmp___14;
#line 683
  gndbl[n] = 0;
#line 684
  return;
}
}
#line 696 "figlet.c"
ZFILE *FIGopen(char *name , char *suffix ) 
{ 
  char *fontpath ;
  ZFILE *fontfile ;
  struct stat st ;
  int namelen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 705
  tmp = strlen((char const   *)fontdirname);
#line 705
  namelen = (int )tmp;
#line 706
  tmp___0 = strlen((char const   *)name);
#line 706
  tmp___1 = strlen((char const   *)suffix);
#line 706
  tmp___2 = __builtin_alloca(sizeof(char ) * (unsigned long )(((namelen + (int )tmp___0) + (int )tmp___1) + 2));
#line 706
  fontpath = (char *)tmp___2;
#line 708
  fontfile = (ZFILE *)((void *)0);
#line 709
  tmp___4 = hasdirsep(name);
#line 709
  if (! tmp___4) {
#line 710
    strcpy((char * __restrict  )fontpath, (char const   * __restrict  )fontdirname);
#line 711
    *(fontpath + namelen) = (char )'/';
#line 712
    *(fontpath + (namelen + 1)) = (char )'\000';
#line 713
    strcat((char * __restrict  )fontpath, (char const   * __restrict  )name);
#line 714
    strcat((char * __restrict  )fontpath, (char const   * __restrict  )suffix);
#line 715
    tmp___3 = stat((char const   * __restrict  )fontpath, (struct stat * __restrict  )(& st));
#line 715
    if (tmp___3 == 0) {
#line 715
      goto ok;
    }
  }
#line 718
  strcpy((char * __restrict  )fontpath, (char const   * __restrict  )name);
#line 719
  strcat((char * __restrict  )fontpath, (char const   * __restrict  )suffix);
#line 720
  tmp___5 = stat((char const   * __restrict  )fontpath, (struct stat * __restrict  )(& st));
#line 720
  if (tmp___5 == 0) {
#line 720
    goto ok;
  }
#line 722
  return ((ZFILE *)((void *)0));
  ok: 
#line 725
  fontfile = Zopen((char const   *)fontpath, "rb");
#line 726
  return (fontfile);
}
}
#line 738 "figlet.c"
void readcontrol(char *controlname ) 
{ 
  inchr firstch ;
  inchr lastch ;
  char dashcheck ;
  inchr offset ;
  int command ;
  ZFILE *controlfile ;
  char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  inchr tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;

  {
#line 747
  controlfile = FIGopen(controlname, (char *)".flc");
#line 749
  if ((unsigned long )controlfile == (unsigned long )((void *)0)) {
#line 750
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Unable to open control file\n",
            myname, controlname);
#line 752
    exit(1);
  }
#line 755
  tmp = myalloc(sizeof(comnode ));
#line 755
  *commandlistend = (comnode *)tmp;
#line 756
  (*commandlistend)->thecommand = 0;
#line 757
  commandlistend = & (*commandlistend)->next;
#line 758
  *commandlistend = (comnode *)((void *)0);
#line 760
  while (1) {
#line 760
    (controlfile->len) --;
#line 760
    if (controlfile->len >= 0) {
#line 760
      tmp___14 = controlfile->ptr;
#line 760
      (controlfile->ptr) ++;
#line 760
      command = (int )*tmp___14;
    } else {
#line 760
      tmp___15 = _Zgetc(controlfile);
#line 760
      command = tmp___15;
    }
#line 760
    if (! (command != -1)) {
#line 760
      break;
    }
#line 761
    switch (command) {
    case 116: 
#line 763
    skipws(controlfile);
#line 764
    firstch = readTchar(controlfile);
#line 765
    (controlfile->len) --;
#line 765
    if (controlfile->len >= 0) {
#line 765
      tmp___0 = controlfile->ptr;
#line 765
      (controlfile->ptr) ++;
#line 765
      dashcheck = (char )*tmp___0;
    } else {
#line 765
      tmp___1 = _Zgetc(controlfile);
#line 765
      dashcheck = (char )tmp___1;
    }
#line 765
    if ((int )dashcheck == 45) {
#line 766
      lastch = readTchar(controlfile);
    } else {
#line 769
      (controlfile->ptr) --;
#line 769
      (controlfile->len) ++;
#line 770
      lastch = firstch;
    }
#line 772
    skipws(controlfile);
#line 773
    tmp___2 = readTchar(controlfile);
#line 773
    offset = tmp___2 - firstch;
#line 774
    skiptoeol(controlfile);
#line 775
    tmp___3 = myalloc(sizeof(comnode ));
#line 775
    *commandlistend = (comnode *)tmp___3;
#line 776
    (*commandlistend)->thecommand = 1;
#line 777
    (*commandlistend)->rangelo = firstch;
#line 778
    (*commandlistend)->rangehi = lastch;
#line 779
    (*commandlistend)->offset = offset;
#line 780
    commandlistend = & (*commandlistend)->next;
#line 781
    *commandlistend = (comnode *)((void *)0);
#line 782
    break;
    case 45: 
    case 57: 
    case 56: 
    case 55: 
    case 54: 
    case 53: 
    case 52: 
    case 51: 
    case 50: 
    case 49: 
    case 48: 
#line 787
    (controlfile->ptr) --;
#line 787
    (controlfile->len) ++;
#line 788
    readnum(controlfile, & firstch);
#line 789
    skipws(controlfile);
#line 790
    readnum(controlfile, & lastch);
#line 791
    offset = lastch - firstch;
#line 792
    lastch = firstch;
#line 793
    skiptoeol(controlfile);
#line 794
    tmp___4 = myalloc(sizeof(comnode ));
#line 794
    *commandlistend = (comnode *)tmp___4;
#line 795
    (*commandlistend)->thecommand = 1;
#line 796
    (*commandlistend)->rangelo = firstch;
#line 797
    (*commandlistend)->rangehi = lastch;
#line 798
    (*commandlistend)->offset = offset;
#line 799
    commandlistend = & (*commandlistend)->next;
#line 800
    *commandlistend = (comnode *)((void *)0);
#line 801
    break;
    case 102: 
#line 803
    skiptoeol(controlfile);
#line 804
    tmp___5 = myalloc(sizeof(comnode ));
#line 804
    *commandlistend = (comnode *)tmp___5;
#line 805
    (*commandlistend)->thecommand = 0;
#line 806
    commandlistend = & (*commandlistend)->next;
#line 807
    *commandlistend = (comnode *)((void *)0);
#line 808
    break;
    case 98: 
#line 810
    multibyte = 1;
#line 811
    break;
    case 117: 
#line 813
    multibyte = 2;
#line 814
    break;
    case 104: 
#line 816
    multibyte = 3;
#line 817
    break;
    case 106: 
#line 819
    multibyte = 4;
#line 820
    break;
    case 103: 
#line 822
    multibyte = 0;
#line 823
    skipws(controlfile);
#line 824
    (controlfile->len) --;
#line 824
    if (controlfile->len >= 0) {
#line 824
      tmp___6 = controlfile->ptr;
#line 824
      (controlfile->ptr) ++;
#line 824
      command = (int )*tmp___6;
    } else {
#line 824
      tmp___7 = _Zgetc(controlfile);
#line 824
      command = tmp___7;
    }
#line 825
    switch (command) {
    case 48: 
#line 827
    charset(0, controlfile);
#line 828
    break;
    case 49: 
#line 830
    charset(1, controlfile);
#line 831
    break;
    case 50: 
#line 833
    charset(2, controlfile);
#line 834
    break;
    case 51: 
#line 836
    charset(3, controlfile);
#line 837
    break;
    case 76: 
    case 108: 
#line 839
    skipws(controlfile);
#line 840
    (controlfile->len) --;
#line 840
    if (controlfile->len >= 0) {
#line 840
      tmp___8 = controlfile->ptr;
#line 840
      (controlfile->ptr) ++;
#line 840
      tmp___10 = (int )*tmp___8;
    } else {
#line 840
      tmp___9 = _Zgetc(controlfile);
#line 840
      tmp___10 = tmp___9;
    }
#line 840
    gl = tmp___10 - 48;
#line 841
    skiptoeol(controlfile);
#line 842
    break;
    case 82: 
    case 114: 
#line 844
    skipws(controlfile);
#line 845
    (controlfile->len) --;
#line 845
    if (controlfile->len >= 0) {
#line 845
      tmp___11 = controlfile->ptr;
#line 845
      (controlfile->ptr) ++;
#line 845
      tmp___13 = (int )*tmp___11;
    } else {
#line 845
      tmp___12 = _Zgetc(controlfile);
#line 845
      tmp___13 = tmp___12;
    }
#line 845
    gr = tmp___13 - 48;
#line 846
    skiptoeol(controlfile);
#line 847
    break;
    default: 
#line 849
    skiptoeol(controlfile);
    }
    case 10: 
    case 13: 
#line 852
    break;
    default: 
#line 854
    skiptoeol(controlfile);
    }
  }
#line 857
  Zclose(controlfile);
#line 858
  return;
}
}
#line 870 "figlet.c"
void readcontrolfiles(void) 
{ 
  cfnamenode *cfnptr ;

  {
#line 874
  cfnptr = cfilelist;
#line 874
  while ((unsigned long )cfnptr != (unsigned long )((void *)0)) {
#line 875
    readcontrol(cfnptr->thename);
#line 874
    cfnptr = cfnptr->next;
  }
#line 877
  return;
}
}
#line 888 "figlet.c"
void clearcfilelist(void) 
{ 
  cfnamenode *cfnptr1 ;
  cfnamenode *cfnptr2 ;

  {
#line 892
  cfnptr1 = cfilelist;
#line 893
  while ((unsigned long )cfnptr1 != (unsigned long )((void *)0)) {
#line 894
    cfnptr2 = cfnptr1->next;
#line 895
    free((void *)cfnptr1);
#line 896
    cfnptr1 = cfnptr2;
  }
#line 898
  cfilelist = (cfnamenode *)((void *)0);
#line 899
  cfilelistend = & cfilelist;
#line 900
  return;
}
}
#line 912 "figlet.c"
void getparams(void) 
{ 
  int c ;
  int columns ;
  int infoprint ;
  char *controlname ;
  char *env ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 920
  myname = strrchr((char const   *)*(Myargv + 0), '/');
#line 920
  if ((unsigned long )myname != (unsigned long )((void *)0)) {
#line 921
    myname ++;
  } else {
#line 924
    myname = *(Myargv + 0);
  }
#line 926
  fontdirname = (char *)"/usr/local/share/figlet";
#line 927
  env = getenv("FIGLET_FONTDIR");
#line 928
  if ((unsigned long )env != (unsigned long )((void *)0)) {
#line 929
    fontdirname = env;
  }
#line 931
  fontname = (char *)"standard";
#line 932
  cfilelist = (cfnamenode *)((void *)0);
#line 933
  cfilelistend = & cfilelist;
#line 934
  commandlist = (comnode *)((void *)0);
#line 935
  commandlistend = & commandlist;
#line 936
  smushoverride = 0;
#line 937
  deutschflag = 0;
#line 938
  justification = -1;
#line 939
  right2left = -1;
#line 940
  paragraphflag = 0;
#line 941
  infoprint = -1;
#line 942
  cmdinput = 0;
#line 943
  outputwidth = 80;
#line 944
  gn[1] = (inchr )128;
#line 945
  gr = 1;
#line 946
  while (1) {
#line 946
    c = getopt(Myargc, (char * const  *)Myargv, "ADEXLRI:xlcrpntvm:w:d:f:C:NFskSWo");
#line 946
    if (! (c != -1)) {
#line 946
      break;
    }
#line 948
    switch (c) {
    case 65: 
#line 950
    cmdinput = 1;
#line 951
    break;
    case 68: 
#line 953
    deutschflag = 1;
#line 954
    break;
    case 69: 
#line 956
    deutschflag = 0;
#line 957
    break;
    case 88: 
#line 959
    right2left = -1;
#line 960
    break;
    case 76: 
#line 962
    right2left = 0;
#line 963
    break;
    case 82: 
#line 965
    right2left = 1;
#line 966
    break;
    case 120: 
#line 968
    justification = -1;
#line 969
    break;
    case 108: 
#line 971
    justification = 0;
#line 972
    break;
    case 99: 
#line 974
    justification = 1;
#line 975
    break;
    case 114: 
#line 977
    justification = 2;
#line 978
    break;
    case 112: 
#line 980
    paragraphflag = 1;
#line 981
    break;
    case 110: 
#line 983
    paragraphflag = 0;
#line 984
    break;
    case 115: 
#line 986
    smushoverride = 0;
#line 987
    break;
    case 107: 
#line 989
    smushmode = 64;
#line 990
    smushoverride = 1;
#line 991
    break;
    case 83: 
#line 993
    smushmode = 128;
#line 994
    smushoverride = 2;
#line 995
    break;
    case 111: 
#line 997
    smushmode = 128;
#line 998
    smushoverride = 1;
#line 999
    break;
    case 87: 
#line 1001
    smushmode = 0;
#line 1002
    smushoverride = 1;
#line 1003
    break;
    case 116: 
#line 1006
    columns = get_columns();
#line 1007
    if (columns > 0) {
#line 1008
      outputwidth = columns;
    }
#line 1015
    break;
    case 118: 
#line 1017
    infoprint = 0;
#line 1018
    break;
    case 73: 
#line 1020
    infoprint = atoi((char const   *)optarg);
#line 1021
    break;
    case 109: 
#line 1023
    smushmode = atoi((char const   *)optarg);
#line 1024
    if (smushmode < -1) {
#line 1025
      smushoverride = 0;
#line 1026
      break;
    }
#line 1028
    if (smushmode == 0) {
#line 1028
      smushmode = 64;
    } else
#line 1029
    if (smushmode == -1) {
#line 1029
      smushmode = 0;
    } else {
#line 1030
      smushmode = (smushmode & 63) | 128;
    }
#line 1031
    smushoverride = 1;
#line 1032
    break;
    case 119: 
#line 1034
    columns = atoi((char const   *)optarg);
#line 1035
    if (columns > 0) {
#line 1036
      outputwidth = columns;
    }
#line 1038
    break;
    case 100: 
#line 1040
    fontdirname = optarg;
#line 1041
    break;
    case 102: 
#line 1043
    fontname = optarg;
#line 1044
    tmp___4 = suffixcmp(fontname, (char *)".flf");
#line 1044
    if (tmp___4) {
#line 1045
      tmp = strlen((char const   *)fontname);
#line 1045
      tmp___0 = strlen(".flf");
#line 1045
      *(fontname + ((int )tmp - (int )tmp___0)) = (char )'\000';
    } else {
#line 1048
      tmp___3 = suffixcmp(fontname, (char *)".tlf");
#line 1048
      if (tmp___3) {
#line 1049
        tmp___1 = strlen((char const   *)fontname);
#line 1049
        tmp___2 = strlen(".tlf");
#line 1049
        *(fontname + ((int )tmp___1 - (int )tmp___2)) = (char )'\000';
      }
    }
#line 1052
    break;
    case 67: 
#line 1054
    controlname = optarg;
#line 1055
    tmp___7 = suffixcmp(controlname, (char *)".flc");
#line 1055
    if (tmp___7) {
#line 1056
      tmp___5 = strlen((char const   *)controlname);
#line 1056
      tmp___6 = strlen(".flc");
#line 1056
      *(controlname + ((int )tmp___5 - (int )tmp___6)) = (char )'\000';
    }
#line 1058
    tmp___8 = myalloc(sizeof(cfnamenode ));
#line 1058
    *cfilelistend = (cfnamenode *)tmp___8;
#line 1059
    (*cfilelistend)->thename = controlname;
#line 1060
    cfilelistend = & (*cfilelistend)->next;
#line 1061
    *cfilelistend = (cfnamenode *)((void *)0);
#line 1062
    break;
    case 78: 
#line 1064
    clearcfilelist();
#line 1065
    multibyte = 0;
#line 1066
    gn[0] = (inchr )0;
#line 1067
    gn[1] = (inchr )128;
#line 1068
    gn[3] = (inchr )0;
#line 1068
    gn[2] = gn[3];
#line 1069
    gndbl[3] = 0;
#line 1069
    gndbl[2] = gndbl[3];
#line 1069
    gndbl[1] = gndbl[2];
#line 1069
    gndbl[0] = gndbl[1];
#line 1070
    gl = 0;
#line 1071
    gr = 1;
#line 1072
    break;
    case 70: 
#line 1074
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal option -- F\n",
            myname);
#line 1075
    printusage(stderr);
#line 1076
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nBecause of numerous incompatibilities, the");
#line 1077
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" \"-F\" option has been\n");
#line 1078
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"removed.  It has been replaced by the \"figlist\"");
#line 1079
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" program, which is now\n");
#line 1080
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"included in the basic FIGlet package.  \"figlist\"");
#line 1081
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" is also available\n");
#line 1082
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"from  http://www.figlet.org/");
#line 1083
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"under UNIX utilities.\n");
#line 1084
    exit(1);
#line 1085
    break;
    default: 
#line 1087
    printusage(stderr);
#line 1088
    exit(1);
    }
  }
#line 1091
  if (optind != Myargc) {
#line 1091
    cmdinput = 1;
  }
#line 1092
  outlinelenlimit = outputwidth - 1;
#line 1093
  if (infoprint >= 0) {
#line 1094
    printinfo(infoprint);
#line 1095
    exit(0);
  }
#line 1097
  return;
}
}
#line 1108 "figlet.c"
void clearline(void) 
{ 
  int i ;

  {
#line 1112
  i = 0;
#line 1112
  while (i < charheight) {
#line 1113
    *(*(outputline + i) + 0) = '\000';
#line 1112
    i ++;
  }
#line 1115
  outlinelen = 0;
#line 1116
  inchrlinelen = 0;
#line 1117
  return;
}
}
#line 1129 "figlet.c"
void readfontchar(ZFILE *file , inchr theord ) 
{ 
  int row ;
  int k ;
  char templine[256] ;
  outchr endchar ;
  outchr outline[256] ;
  fcharnode *fclsave ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
#line 1138
  fclsave = fcharlist;
#line 1139
  tmp = myalloc(sizeof(fcharnode ));
#line 1139
  fcharlist = (fcharnode *)tmp;
#line 1140
  fcharlist->ord = theord;
#line 1141
  tmp___0 = myalloc(sizeof(outchr *) * (unsigned long )charheight);
#line 1141
  fcharlist->thechar = (outchr **)tmp___0;
#line 1142
  fcharlist->next = fclsave;
#line 1144
  row = 0;
#line 1144
  while (row < charheight) {
#line 1145
    tmp___1 = myfgets(templine, 255, file);
#line 1145
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1146
      templine[0] = (char )'\000';
    }
#line 1149
    utf8_to_wchar((char const   *)(templine), (size_t )255, outline, (size_t )255,
                  0);
#line 1153
    tmp___2 = wcslen((wchar_t const   *)(outline));
#line 1153
    k = (int )(tmp___2 - 1UL);
#line 1154
    while (1) {
#line 1154
      if (k >= 0) {
#line 1154
        tmp___3 = iswspace((wint_t )outline[k]);
#line 1154
        if (! tmp___3) {
#line 1154
          break;
        }
      } else {
#line 1154
        break;
      }
#line 1155
      k --;
    }
#line 1157
    if (k >= 0) {
#line 1158
      endchar = outline[k];
#line 1159
      while (1) {
#line 1159
        if (k >= 0) {
#line 1159
          if (! (outline[k] == endchar)) {
#line 1159
            break;
          }
        } else {
#line 1159
          break;
        }
#line 1160
        k --;
      }
    }
#line 1163
    outline[k + 1] = '\000';
#line 1164
    tmp___4 = wcslen((wchar_t const   *)(outline));
#line 1164
    tmp___5 = myalloc(sizeof(outchr ) * (tmp___4 + 1UL));
#line 1164
    *(fcharlist->thechar + row) = (outchr *)tmp___5;
#line 1165
    wcscpy((wchar_t * __restrict  )*(fcharlist->thechar + row), (wchar_t const   * __restrict  )(outline));
#line 1144
    row ++;
  }
#line 1167
  return;
}
}
#line 1179 "figlet.c"
void readfont(void) 
{ 
  int i ;
  int row ;
  int numsread ;
  inchr theord ;
  int maxlen ;
  int cmtlines ;
  int ffright2left ;
  int smush ;
  int smush2 ;
  char fileline[256] ;
  char magicnum[5] ;
  ZFILE *fontfile ;
  char *tmp ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 1188
  fontfile = FIGopen(fontname, (char *)".flf");
#line 1190
  if ((unsigned long )fontfile == (unsigned long )((void *)0)) {
#line 1191
    fontfile = FIGopen(fontname, (char *)".tlf");
#line 1192
    if (fontfile) {
#line 1192
      toiletfont = 1;
    }
  }
#line 1196
  if ((unsigned long )fontfile == (unsigned long )((void *)0)) {
#line 1197
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Unable to open font file\n",
            myname, fontname);
#line 1198
    exit(1);
  }
#line 1201
  readmagic(fontfile, magicnum);
#line 1202
  tmp = myfgets(fileline, 255, fontfile);
#line 1202
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1203
    fileline[0] = (char )'\000';
  }
#line 1205
  tmp___3 = strlen((char const   *)(fileline));
#line 1205
  if ((int )tmp___3 > 0) {
#line 1205
    tmp___1 = strlen((char const   *)(fileline));
#line 1205
    tmp___2 = (int )fileline[(int )tmp___1 - 1] != 10;
  } else {
#line 1205
    tmp___2 = 0;
  }
#line 1205
  if (tmp___2) {
#line 1206
    skiptoeol(fontfile);
  }
#line 1208
  numsread = sscanf((char const   * __restrict  )(fileline), (char const   * __restrict  )"%*c%c %d %*d %d %d %d %d %d",
                    & hardblank, & charheight, & maxlen, & smush, & cmtlines, & ffright2left,
                    & smush2);
#line 1212
  if (maxlen > 255) {
#line 1213
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: character is too wide\n",
            myname, fontname);
#line 1214
    exit(1);
  }
#line 1217
  if (! toiletfont) {
#line 1217
    tmp___4 = strcmp((char const   *)(magicnum), "flf2");
#line 1217
    if (tmp___4) {
#line 1222
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Not a FIGlet 2 font file\n",
              myname, fontname);
#line 1223
      exit(1);
    } else {
#line 1217
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1217
  if (toiletfont) {
#line 1217
    tmp___5 = strcmp((char const   *)(magicnum), "tlf2");
#line 1217
    if (tmp___5) {
#line 1222
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Not a FIGlet 2 font file\n",
              myname, fontname);
#line 1223
      exit(1);
    } else {
#line 1217
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1217
  if (numsread < 5) {
#line 1222
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Not a FIGlet 2 font file\n",
            myname, fontname);
#line 1223
    exit(1);
  }
#line 1225
  i = 1;
#line 1225
  while (i <= cmtlines) {
#line 1226
    skiptoeol(fontfile);
#line 1225
    i ++;
  }
#line 1229
  if (numsread < 6) {
#line 1230
    ffright2left = 0;
  }
#line 1233
  if (numsread < 7) {
#line 1234
    if (smush == 0) {
#line 1234
      smush2 = 64;
    } else
#line 1235
    if (smush < 0) {
#line 1235
      smush2 = 0;
    } else {
#line 1236
      smush2 = (smush & 31) | 128;
    }
  }
#line 1239
  if (charheight < 1) {
#line 1240
    charheight = 1;
  }
#line 1243
  if (maxlen < 1) {
#line 1244
    maxlen = 1;
  }
#line 1247
  maxlen += 100;
#line 1249
  if (smushoverride == 0) {
#line 1250
    smushmode = smush2;
  } else
#line 1251
  if (smushoverride == 2) {
#line 1252
    smushmode |= smush2;
  }
#line 1254
  if (right2left < 0) {
#line 1255
    right2left = ffright2left;
  }
#line 1258
  if (justification < 0) {
#line 1259
    justification = 2 * right2left;
  }
#line 1263
  tmp___6 = myalloc(sizeof(fcharnode ));
#line 1263
  fcharlist = (fcharnode *)tmp___6;
#line 1264
  fcharlist->ord = (inchr )0;
#line 1265
  tmp___7 = myalloc(sizeof(outchr *) * (unsigned long )charheight);
#line 1265
  fcharlist->thechar = (outchr **)tmp___7;
#line 1266
  fcharlist->next = (struct fc *)((void *)0);
#line 1267
  row = 0;
#line 1267
  while (row < charheight) {
#line 1268
    tmp___8 = myalloc(sizeof(outchr ));
#line 1268
    *(fcharlist->thechar + row) = (outchr *)tmp___8;
#line 1269
    *(*(fcharlist->thechar + row) + 0) = '\000';
#line 1267
    row ++;
  }
#line 1271
  theord = (inchr )' ';
#line 1271
  while (theord <= 126L) {
#line 1272
    readfontchar(fontfile, theord);
#line 1271
    theord ++;
  }
#line 1274
  theord = (inchr )0;
#line 1274
  while (theord <= 6L) {
#line 1275
    readfontchar(fontfile, deutsch[theord]);
#line 1274
    theord ++;
  }
#line 1277
  while (1) {
#line 1277
    tmp___12 = myfgets(fileline, maxlen + 1, fontfile);
#line 1277
    if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
#line 1277
      tmp___11 = 0;
    } else {
#line 1277
      tmp___10 = sscanf((char const   * __restrict  )(fileline), (char const   * __restrict  )"%li",
                        & theord);
#line 1277
      tmp___11 = tmp___10 == 1;
    }
#line 1277
    if (! tmp___11) {
#line 1277
      break;
    }
#line 1279
    readfontchar(fontfile, theord);
  }
#line 1281
  Zclose(fontfile);
#line 1282
  return;
}
}
#line 1294 "figlet.c"
void linealloc(void) 
{ 
  int row ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1298
  tmp = myalloc(sizeof(outchr *) * (unsigned long )charheight);
#line 1298
  outputline = (outchr **)tmp;
#line 1299
  row = 0;
#line 1299
  while (row < charheight) {
#line 1300
    tmp___0 = myalloc(sizeof(outchr ) * (unsigned long )(outlinelenlimit + 1));
#line 1300
    *(outputline + row) = (outchr *)tmp___0;
#line 1299
    row ++;
  }
#line 1302
  inchrlinelenlimit = outputwidth * 4 + 100;
#line 1303
  tmp___1 = myalloc(sizeof(inchr ) * (unsigned long )(inchrlinelenlimit + 1));
#line 1303
  inchrline = (inchr *)tmp___1;
#line 1304
  clearline();
#line 1305
  return;
}
}
#line 1317 "figlet.c"
void getletter(inchr c ) 
{ 
  fcharnode *charptr ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 1322
  charptr = fcharlist;
#line 1322
  while (1) {
#line 1322
    if ((unsigned long )charptr == (unsigned long )((void *)0)) {
#line 1322
      tmp = 0;
    } else {
#line 1322
      tmp = charptr->ord != c;
    }
#line 1322
    if (! tmp) {
#line 1322
      break;
    }
#line 1322
    charptr = charptr->next;
  }
#line 1324
  if ((unsigned long )charptr != (unsigned long )((void *)0)) {
#line 1325
    currchar = charptr->thechar;
  } else {
#line 1328
    charptr = fcharlist;
#line 1328
    while (1) {
#line 1328
      if ((unsigned long )charptr == (unsigned long )((void *)0)) {
#line 1328
        tmp___0 = 0;
      } else {
#line 1328
        tmp___0 = charptr->ord != 0L;
      }
#line 1328
      if (! tmp___0) {
#line 1328
        break;
      }
#line 1328
      charptr = charptr->next;
    }
#line 1330
    currchar = charptr->thechar;
  }
#line 1332
  previouscharwidth = currcharwidth;
#line 1333
  tmp___1 = wcslen((wchar_t const   *)*(currchar + 0));
#line 1333
  currcharwidth = (int )tmp___1;
#line 1334
  return;
}
}
#line 1356 "figlet.c"
outchr smushem(outchr lch , outchr rch ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
#line 1359
  if (lch == 32) {
#line 1359
    return (rch);
  }
#line 1360
  if (rch == 32) {
#line 1360
    return (lch);
  }
#line 1362
  if (previouscharwidth < 2) {
#line 1362
    return ('\000');
  } else
#line 1362
  if (currcharwidth < 2) {
#line 1362
    return ('\000');
  }
#line 1366
  if ((smushmode & 128) == 0) {
#line 1366
    return ('\000');
  }
#line 1368
  if ((smushmode & 63) == 0) {
#line 1370
    if (lch == 32) {
#line 1370
      return (rch);
    }
#line 1371
    if (rch == 32) {
#line 1371
      return (lch);
    }
#line 1372
    if (lch == (outchr )hardblank) {
#line 1372
      return (rch);
    }
#line 1373
    if (rch == (outchr )hardblank) {
#line 1373
      return (lch);
    }
#line 1376
    if (right2left == 1) {
#line 1376
      return (lch);
    }
#line 1380
    return (rch);
  }
#line 1384
  if (smushmode & 32) {
#line 1385
    if (lch == (outchr )hardblank) {
#line 1385
      if (rch == (outchr )hardblank) {
#line 1385
        return (lch);
      }
    }
  }
#line 1388
  if (lch == (outchr )hardblank) {
#line 1388
    return ('\000');
  } else
#line 1388
  if (rch == (outchr )hardblank) {
#line 1388
    return ('\000');
  }
#line 1390
  if (smushmode & 1) {
#line 1391
    if (lch == rch) {
#line 1391
      return (lch);
    }
  }
#line 1394
  if (smushmode & 2) {
#line 1395
    if (lch == 95) {
#line 1395
      tmp = strchr("|/\\[]{}()<>", rch);
#line 1395
      if (tmp) {
#line 1395
        return (rch);
      }
    }
#line 1396
    if (rch == 95) {
#line 1396
      tmp___0 = strchr("|/\\[]{}()<>", lch);
#line 1396
      if (tmp___0) {
#line 1396
        return (lch);
      }
    }
  }
#line 1399
  if (smushmode & 4) {
#line 1400
    if (lch == 124) {
#line 1400
      tmp___1 = strchr("/\\[]{}()<>", rch);
#line 1400
      if (tmp___1) {
#line 1400
        return (rch);
      }
    }
#line 1401
    if (rch == 124) {
#line 1401
      tmp___2 = strchr("/\\[]{}()<>", lch);
#line 1401
      if (tmp___2) {
#line 1401
        return (lch);
      }
    }
#line 1402
    tmp___3 = strchr("/\\", lch);
#line 1402
    if (tmp___3) {
#line 1402
      tmp___4 = strchr("[]{}()<>", rch);
#line 1402
      if (tmp___4) {
#line 1402
        return (rch);
      }
    }
#line 1403
    tmp___5 = strchr("/\\", rch);
#line 1403
    if (tmp___5) {
#line 1403
      tmp___6 = strchr("[]{}()<>", lch);
#line 1403
      if (tmp___6) {
#line 1403
        return (lch);
      }
    }
#line 1404
    tmp___7 = strchr("[]", lch);
#line 1404
    if (tmp___7) {
#line 1404
      tmp___8 = strchr("{}()<>", rch);
#line 1404
      if (tmp___8) {
#line 1404
        return (rch);
      }
    }
#line 1405
    tmp___9 = strchr("[]", rch);
#line 1405
    if (tmp___9) {
#line 1405
      tmp___10 = strchr("{}()<>", lch);
#line 1405
      if (tmp___10) {
#line 1405
        return (lch);
      }
    }
#line 1406
    tmp___11 = strchr("{}", lch);
#line 1406
    if (tmp___11) {
#line 1406
      tmp___12 = strchr("()<>", rch);
#line 1406
      if (tmp___12) {
#line 1406
        return (rch);
      }
    }
#line 1407
    tmp___13 = strchr("{}", rch);
#line 1407
    if (tmp___13) {
#line 1407
      tmp___14 = strchr("()<>", lch);
#line 1407
      if (tmp___14) {
#line 1407
        return (lch);
      }
    }
#line 1408
    tmp___15 = strchr("()", lch);
#line 1408
    if (tmp___15) {
#line 1408
      tmp___16 = strchr("<>", rch);
#line 1408
      if (tmp___16) {
#line 1408
        return (rch);
      }
    }
#line 1409
    tmp___17 = strchr("()", rch);
#line 1409
    if (tmp___17) {
#line 1409
      tmp___18 = strchr("<>", lch);
#line 1409
      if (tmp___18) {
#line 1409
        return (lch);
      }
    }
  }
#line 1412
  if (smushmode & 8) {
#line 1413
    if (lch == 91) {
#line 1413
      if (rch == 93) {
#line 1413
        return ('|');
      }
    }
#line 1414
    if (rch == 91) {
#line 1414
      if (lch == 93) {
#line 1414
        return ('|');
      }
    }
#line 1415
    if (lch == 123) {
#line 1415
      if (rch == 125) {
#line 1415
        return ('|');
      }
    }
#line 1416
    if (rch == 123) {
#line 1416
      if (lch == 125) {
#line 1416
        return ('|');
      }
    }
#line 1417
    if (lch == 40) {
#line 1417
      if (rch == 41) {
#line 1417
        return ('|');
      }
    }
#line 1418
    if (rch == 40) {
#line 1418
      if (lch == 41) {
#line 1418
        return ('|');
      }
    }
  }
#line 1421
  if (smushmode & 16) {
#line 1422
    if (lch == 47) {
#line 1422
      if (rch == 92) {
#line 1422
        return ('|');
      }
    }
#line 1423
    if (rch == 47) {
#line 1423
      if (lch == 92) {
#line 1423
        return ('Y');
      }
    }
#line 1424
    if (lch == 62) {
#line 1424
      if (rch == 60) {
#line 1424
        return ('X');
      }
    }
  }
#line 1428
  return ('\000');
}
}
#line 1441 "figlet.c"
int smushamt(void) 
{ 
  int maxsmush ;
  int amt ;
  int row ;
  int linebd ;
  int charbd ;
  outchr ch1 ;
  outchr ch2 ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  outchr tmp___3 ;

  {
#line 1447
  if ((smushmode & 192) == 0) {
#line 1448
    return (0);
  }
#line 1450
  maxsmush = currcharwidth;
#line 1451
  row = 0;
#line 1451
  while (row < charheight) {
#line 1452
    if (right2left) {
#line 1453
      tmp = wcslen((wchar_t const   *)*(currchar + row));
#line 1453
      charbd = (int )tmp;
#line 1453
      while (1) {
#line 1453
        ch1 = *(*(currchar + row) + charbd);
#line 1453
        if (charbd > 0) {
#line 1453
          if (! ch1) {
#line 1453
            tmp___0 = 1;
          } else
#line 1453
          if (ch1 == 32) {
#line 1453
            tmp___0 = 1;
          } else {
#line 1453
            tmp___0 = 0;
          }
        } else {
#line 1453
          tmp___0 = 0;
        }
#line 1453
        if (! tmp___0) {
#line 1453
          break;
        }
#line 1453
        charbd --;
      }
#line 1455
      linebd = 0;
#line 1455
      while (1) {
#line 1455
        ch2 = *(*(outputline + row) + linebd);
#line 1455
        if (! (ch2 == 32)) {
#line 1455
          break;
        }
#line 1455
        linebd ++;
      }
#line 1456
      amt = ((linebd + currcharwidth) - 1) - charbd;
    } else {
#line 1459
      tmp___1 = wcslen((wchar_t const   *)*(outputline + row));
#line 1459
      linebd = (int )tmp___1;
#line 1459
      while (1) {
#line 1459
        ch1 = *(*(outputline + row) + linebd);
#line 1459
        if (linebd > 0) {
#line 1459
          if (! ch1) {
#line 1459
            tmp___2 = 1;
          } else
#line 1459
          if (ch1 == 32) {
#line 1459
            tmp___2 = 1;
          } else {
#line 1459
            tmp___2 = 0;
          }
        } else {
#line 1459
          tmp___2 = 0;
        }
#line 1459
        if (! tmp___2) {
#line 1459
          break;
        }
#line 1459
        linebd --;
      }
#line 1461
      charbd = 0;
#line 1461
      while (1) {
#line 1461
        ch2 = *(*(currchar + row) + charbd);
#line 1461
        if (! (ch2 == 32)) {
#line 1461
          break;
        }
#line 1461
        charbd ++;
      }
#line 1462
      amt = ((charbd + outlinelen) - 1) - linebd;
    }
#line 1464
    if (! ch1) {
#line 1465
      amt ++;
    } else
#line 1464
    if (ch1 == 32) {
#line 1465
      amt ++;
    } else
#line 1467
    if (ch2) {
#line 1468
      tmp___3 = smushem(ch1, ch2);
#line 1468
      if (tmp___3 != 0) {
#line 1469
        amt ++;
      }
    }
#line 1472
    if (amt < maxsmush) {
#line 1473
      maxsmush = amt;
    }
#line 1451
    row ++;
  }
#line 1476
  return (maxsmush);
}
}
#line 1489 "figlet.c"
int addchar(inchr c ) 
{ 
  int smushamount ;
  int row ;
  int k ;
  int column ;
  outchr *templine ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 1495
  getletter(c);
#line 1496
  smushamount = smushamt();
#line 1497
  if ((outlinelen + currcharwidth) - smushamount > outlinelenlimit) {
#line 1499
    return (0);
  } else
#line 1497
  if (inchrlinelen + 1 > inchrlinelenlimit) {
#line 1499
    return (0);
  }
#line 1502
  tmp = myalloc(sizeof(outchr ) * (unsigned long )(outlinelenlimit + 1));
#line 1502
  templine = (outchr *)tmp;
#line 1503
  row = 0;
#line 1503
  while (row < charheight) {
#line 1504
    if (right2left) {
#line 1505
      wcscpy((wchar_t * __restrict  )templine, (wchar_t const   * __restrict  )*(currchar + row));
#line 1506
      k = 0;
#line 1506
      while (k < smushamount) {
#line 1507
        *(templine + ((currcharwidth - smushamount) + k)) = smushem(*(templine + ((currcharwidth - smushamount) + k)),
                                                                    *(*(outputline + row) + k));
#line 1506
        k ++;
      }
#line 1510
      wcscat((wchar_t * __restrict  )templine, (wchar_t const   * __restrict  )(*(outputline + row) + smushamount));
#line 1511
      wcscpy((wchar_t * __restrict  )*(outputline + row), (wchar_t const   * __restrict  )templine);
    } else {
#line 1514
      k = 0;
#line 1514
      while (k < smushamount) {
#line 1515
        column = (outlinelen - smushamount) + k;
#line 1516
        if (column < 0) {
#line 1517
          column = 0;
        }
#line 1519
        *(*(outputline + row) + column) = smushem(*(*(outputline + row) + column),
                                                  *(*(currchar + row) + k));
#line 1514
        k ++;
      }
#line 1522
      wcscat((wchar_t * __restrict  )*(outputline + row), (wchar_t const   * __restrict  )(*(currchar + row) + smushamount));
    }
#line 1503
    row ++;
  }
#line 1525
  free((void *)templine);
#line 1526
  tmp___0 = wcslen((wchar_t const   *)*(outputline + 0));
#line 1526
  outlinelen = (int )tmp___0;
#line 1527
  tmp___1 = inchrlinelen;
#line 1527
  inchrlinelen ++;
#line 1527
  *(inchrline + tmp___1) = c;
#line 1528
  return (1);
}
}
#line 1545 "figlet.c"
void putstring(outchr *string ) 
{ 
  int i ;
  int len ;
  char c[10] ;
  size_t size ;
  wchar_t wc[2] ;
  size_t tmp ;

  {
#line 1555
  tmp = wcslen((wchar_t const   *)string);
#line 1555
  len = (int )tmp;
#line 1556
  if (outputwidth > 1) {
#line 1557
    if (len > outputwidth - 1) {
#line 1558
      len = outputwidth - 1;
    }
#line 1560
    if (justification > 0) {
#line 1561
      i = 1;
#line 1561
      while ((((3 - justification) * i + len) + justification) - 2 < outputwidth) {
#line 1562
        putchar(' ');
#line 1561
        i ++;
      }
    }
  }
#line 1566
  i = 0;
#line 1566
  while (i < len) {
#line 1568
    wc[0] = *(string + i);
#line 1569
    wc[1] = 0;
#line 1570
    size = wchar_to_utf8((wchar_t const   *)(wc), (size_t )1, c, (size_t )10, 0);
#line 1571
    if (size == 1UL) {
#line 1572
      if ((int )c[0] == (int )hardblank) {
#line 1573
        c[0] = (char )' ';
      }
    }
#line 1576
    c[size] = (char)0;
#line 1577
    printf((char const   * __restrict  )"%s", c);
#line 1566
    i ++;
  }
#line 1582
  putchar('\n');
#line 1583
  return;
}
}
#line 1594 "figlet.c"
void printline(void) 
{ 
  int i ;

  {
#line 1598
  i = 0;
#line 1598
  while (i < charheight) {
#line 1599
    putstring(*(outputline + i));
#line 1598
    i ++;
  }
#line 1601
  clearline();
#line 1602
  return;
}
}
#line 1615 "figlet.c"
void splitline(void) 
{ 
  int i ;
  int gotspace ;
  int lastspace ;
  int len1 ;
  int len2 ;
  inchr *part1 ;
  inchr *part2 ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1620
  tmp = myalloc(sizeof(inchr ) * (unsigned long )(inchrlinelen + 1));
#line 1620
  part1 = (inchr *)tmp;
#line 1621
  tmp___0 = myalloc(sizeof(inchr ) * (unsigned long )(inchrlinelen + 1));
#line 1621
  part2 = (inchr *)tmp___0;
#line 1622
  gotspace = 0;
#line 1623
  lastspace = inchrlinelen - 1;
#line 1624
  i = inchrlinelen - 1;
#line 1624
  while (i >= 0) {
#line 1625
    if (! gotspace) {
#line 1625
      if (*(inchrline + i) == 32L) {
#line 1626
        gotspace = 1;
#line 1627
        lastspace = i;
      }
    }
#line 1629
    if (gotspace) {
#line 1629
      if (*(inchrline + i) != 32L) {
#line 1630
        break;
      }
    }
#line 1624
    i --;
  }
#line 1633
  len1 = i + 1;
#line 1634
  len2 = (inchrlinelen - lastspace) - 1;
#line 1635
  i = 0;
#line 1635
  while (i < len1) {
#line 1636
    *(part1 + i) = *(inchrline + i);
#line 1635
    i ++;
  }
#line 1638
  i = 0;
#line 1638
  while (i < len2) {
#line 1639
    *(part2 + i) = *(inchrline + ((lastspace + 1) + i));
#line 1638
    i ++;
  }
#line 1641
  clearline();
#line 1642
  i = 0;
#line 1642
  while (i < len1) {
#line 1643
    addchar(*(part1 + i));
#line 1642
    i ++;
  }
#line 1645
  printline();
#line 1646
  i = 0;
#line 1646
  while (i < len2) {
#line 1647
    addchar(*(part2 + i));
#line 1646
    i ++;
  }
#line 1649
  free((void *)part1);
#line 1650
  free((void *)part2);
#line 1651
  return;
}
}
#line 1663 "figlet.c"
inchr handlemapping(inchr c ) 
{ 
  comnode *cmptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1668
  cmptr = commandlist;
#line 1669
  while ((unsigned long )cmptr != (unsigned long )((void *)0)) {
#line 1670
    if (cmptr->thecommand) {
#line 1670
      if (c >= cmptr->rangelo) {
#line 1670
        if (c <= cmptr->rangehi) {
#line 1670
          tmp___0 = 1;
        } else {
#line 1670
          tmp___0 = 0;
        }
      } else {
#line 1670
        tmp___0 = 0;
      }
#line 1670
      tmp___1 = tmp___0;
    } else {
#line 1670
      tmp___1 = 0;
    }
#line 1670
    if (tmp___1) {
#line 1672
      c += cmptr->offset;
#line 1673
      while (1) {
#line 1673
        if ((unsigned long )cmptr != (unsigned long )((void *)0)) {
#line 1673
          tmp = cmptr->thecommand;
        } else {
#line 1673
          tmp = 0;
        }
#line 1673
        if (! tmp) {
#line 1673
          break;
        }
#line 1674
        cmptr = cmptr->next;
      }
    } else {
#line 1678
      cmptr = cmptr->next;
    }
  }
#line 1681
  return (c);
}
}
#line 1697
int Agetchar(void) ;
#line 1697 "figlet.c"
static int AgetMode  =    0;
#line 1694 "figlet.c"
int Agetchar(void) 
{ 
  char *arg ;
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 1701
  if (! cmdinput) {
#line 1702
    tmp = getchar();
#line 1702
    return (tmp);
  }
#line 1704
  if (AgetMode < 0) {
#line 1705
    return (-1);
  } else
#line 1704
  if (optind >= Myargc) {
#line 1705
    return (-1);
  }
#line 1708
  arg = *(Myargv + optind);
#line 1709
  tmp___0 = AgetMode;
#line 1709
  AgetMode ++;
#line 1709
  c = (int )*(arg + tmp___0) & 255;
#line 1711
  if (! c) {
#line 1713
    c = ' ';
#line 1714
    if (AgetMode == 1) {
#line 1715
      c = '\n';
    }
#line 1716
    AgetMode = 0;
#line 1717
    optind ++;
#line 1717
    if (optind >= Myargc) {
#line 1719
      c = -1;
#line 1720
      AgetMode = -1;
    }
  }
#line 1724
  return (c);
}
}
#line 1737 "figlet.c"
inchr iso2022(void) 
{ 
  inchr ch ;
  inchr ch2 ;
  int save_gl ;
  int save_gr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  inchr tmp___2 ;
  inchr tmp___3 ;
  inchr tmp___4 ;
  inchr tmp___5 ;
  inchr tmp___6 ;
  inchr tmp___7 ;
  inchr tmp___8 ;
  int tmp___9 ;
  inchr tmp___10 ;
  int tmp___11 ;
  inchr tmp___12 ;
  int tmp___13 ;
  inchr tmp___14 ;
  int tmp___15 ;
  inchr tmp___16 ;
  int tmp___17 ;
  inchr tmp___18 ;
  int tmp___19 ;
  inchr tmp___20 ;
  int tmp___21 ;
  inchr tmp___22 ;
  int tmp___23 ;
  inchr tmp___24 ;
  int tmp___25 ;
  inchr tmp___26 ;
  int tmp___27 ;
  inchr tmp___28 ;
  int tmp___29 ;
  inchr tmp___30 ;
  inchr tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
#line 1744
  tmp = Agetchar();
#line 1744
  ch = (inchr )tmp;
#line 1745
  if (ch == -1L) {
#line 1745
    return (ch);
  }
#line 1746
  if (ch == 27L) {
#line 1746
    tmp___0 = Agetchar();
#line 1746
    ch = (inchr )(tmp___0 + 256);
  }
#line 1747
  if (ch == 292L) {
#line 1747
    tmp___1 = Agetchar();
#line 1747
    ch = (inchr )(tmp___1 + 512);
  }
#line 1748
  switch (ch) {
  case 14L: 
#line 1750
  gl = 1;
#line 1751
  tmp___2 = iso2022();
#line 1751
  return (tmp___2);
  case 15L: 
#line 1753
  gl = 0;
#line 1754
  tmp___3 = iso2022();
#line 1754
  return (tmp___3);
  case 334L: 
  case 142L: 
#line 1756
  save_gl = gl;
#line 1756
  save_gr = gr;
#line 1757
  gr = 2;
#line 1757
  gl = gr;
#line 1758
  ch = iso2022();
#line 1759
  gl = save_gl;
#line 1759
  gr = save_gr;
#line 1760
  return (ch);
  case 335L: 
  case 143L: 
#line 1762
  save_gl = gl;
#line 1762
  save_gr = gr;
#line 1763
  gr = 3;
#line 1763
  gl = gr;
#line 1764
  ch = iso2022();
#line 1765
  gl = save_gl;
#line 1765
  gr = save_gr;
#line 1766
  return (ch);
  case 366L: 
#line 1768
  gl = 2;
#line 1769
  tmp___4 = iso2022();
#line 1769
  return (tmp___4);
  case 367L: 
#line 1771
  gl = 3;
#line 1772
  tmp___5 = iso2022();
#line 1772
  return (tmp___5);
  case 382L: 
#line 1774
  gr = 1;
#line 1775
  tmp___6 = iso2022();
#line 1775
  return (tmp___6);
  case 381L: 
#line 1777
  gr = 2;
#line 1778
  tmp___7 = iso2022();
#line 1778
  return (tmp___7);
  case 380L: 
#line 1780
  gr = 3;
#line 1781
  tmp___8 = iso2022();
#line 1781
  return (tmp___8);
  case 296L: 
#line 1783
  tmp___9 = Agetchar();
#line 1783
  ch = (inchr )tmp___9;
#line 1784
  if (ch == 66L) {
#line 1784
    ch = (inchr )0;
  }
#line 1785
  gn[0] = ch << 16;
#line 1786
  gndbl[0] = 0;
#line 1787
  tmp___10 = iso2022();
#line 1787
  return (tmp___10);
  case 297L: 
#line 1789
  tmp___11 = Agetchar();
#line 1789
  ch = (inchr )tmp___11;
#line 1790
  if (ch == 66L) {
#line 1790
    ch = (inchr )0;
  }
#line 1791
  gn[1] = ch << 16;
#line 1792
  gndbl[1] = 0;
#line 1793
  tmp___12 = iso2022();
#line 1793
  return (tmp___12);
  case 298L: 
#line 1795
  tmp___13 = Agetchar();
#line 1795
  ch = (inchr )tmp___13;
#line 1796
  if (ch == 66L) {
#line 1796
    ch = (inchr )0;
  }
#line 1797
  gn[2] = ch << 16;
#line 1798
  gndbl[2] = 0;
#line 1799
  tmp___14 = iso2022();
#line 1799
  return (tmp___14);
  case 299L: 
#line 1801
  tmp___15 = Agetchar();
#line 1801
  ch = (inchr )tmp___15;
#line 1802
  if (ch == 66L) {
#line 1802
    ch = (inchr )0;
  }
#line 1803
  gn[3] = ch << 16;
#line 1804
  gndbl[3] = 0;
#line 1805
  tmp___16 = iso2022();
#line 1805
  return (tmp___16);
  case 301L: 
#line 1807
  tmp___17 = Agetchar();
#line 1807
  ch = (inchr )tmp___17;
#line 1808
  if (ch == 65L) {
#line 1808
    ch = (inchr )0;
  }
#line 1809
  gn[1] = (ch << 16) | 128L;
#line 1810
  gndbl[1] = 0;
#line 1811
  tmp___18 = iso2022();
#line 1811
  return (tmp___18);
  case 302L: 
#line 1813
  tmp___19 = Agetchar();
#line 1813
  ch = (inchr )tmp___19;
#line 1814
  if (ch == 65L) {
#line 1814
    ch = (inchr )0;
  }
#line 1815
  gn[2] = (ch << 16) | 128L;
#line 1816
  gndbl[2] = 0;
#line 1817
  tmp___20 = iso2022();
#line 1817
  return (tmp___20);
  case 303L: 
#line 1819
  tmp___21 = Agetchar();
#line 1819
  ch = (inchr )tmp___21;
#line 1820
  if (ch == 65L) {
#line 1820
    ch = (inchr )0;
  }
#line 1821
  gn[3] = (ch << 16) | 128L;
#line 1822
  gndbl[3] = 0;
#line 1823
  tmp___22 = iso2022();
#line 1823
  return (tmp___22);
  case 552L: 
#line 1825
  tmp___23 = Agetchar();
#line 1825
  ch = (inchr )tmp___23;
#line 1826
  gn[0] = ch << 16;
#line 1827
  gndbl[0] = 1;
#line 1828
  tmp___24 = iso2022();
#line 1828
  return (tmp___24);
  case 553L: 
#line 1830
  tmp___25 = Agetchar();
#line 1830
  ch = (inchr )tmp___25;
#line 1831
  gn[1] = ch << 16;
#line 1832
  gndbl[1] = 1;
#line 1833
  tmp___26 = iso2022();
#line 1833
  return (tmp___26);
  case 554L: 
#line 1835
  tmp___27 = Agetchar();
#line 1835
  ch = (inchr )tmp___27;
#line 1836
  gn[2] = ch << 16;
#line 1837
  gndbl[2] = 1;
#line 1838
  tmp___28 = iso2022();
#line 1838
  return (tmp___28);
  case 555L: 
#line 1840
  tmp___29 = Agetchar();
#line 1840
  ch = (inchr )tmp___29;
#line 1841
  gn[3] = ch << 16;
#line 1842
  gndbl[3] = 1;
#line 1843
  tmp___30 = iso2022();
#line 1843
  return (tmp___30);
  default: 
#line 1845
  if (ch & 512L) {
#line 1846
    gn[0] = (ch & -513L) << 16;
#line 1847
    gndbl[0] = 1;
#line 1848
    tmp___31 = iso2022();
#line 1848
    return (tmp___31);
  }
  }
#line 1852
  if (ch >= 33L) {
#line 1852
    if (ch <= 126L) {
#line 1853
      if (gndbl[gl]) {
#line 1854
        tmp___32 = Agetchar();
#line 1854
        ch2 = (inchr )tmp___32;
#line 1855
        return ((gn[gl] | (ch << 8)) | ch2);
      } else {
#line 1857
        return (gn[gl] | ch);
      }
    } else {
#line 1852
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1859
  if (ch >= 160L) {
#line 1859
    if (ch <= 255L) {
#line 1860
      if (gndbl[gr]) {
#line 1861
        tmp___33 = Agetchar();
#line 1861
        ch2 = (inchr )tmp___33;
#line 1862
        return ((gn[gr] | (ch << 8)) | ch2);
      } else {
#line 1864
        return (gn[gr] | (ch & -129L));
      }
    } else {
#line 1866
      return (ch);
    }
  } else {
#line 1866
    return (ch);
  }
}
}
#line 1877 "figlet.c"
inchr getinchr_buffer  ;
#line 1878 "figlet.c"
int getinchr_flag  ;
#line 1880 "figlet.c"
inchr ungetinchr(inchr c ) 
{ 


  {
#line 1883
  getinchr_buffer = c;
#line 1884
  getinchr_flag = 1;
#line 1885
  return (c);
}
}
#line 1908 "figlet.c"
inchr getinchr(void) 
{ 
  int ch ;
  int ch2 ;
  int ch3 ;
  int ch4 ;
  int ch5 ;
  int ch6 ;
  inchr tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  inchr tmp___7 ;
  inchr tmp___8 ;
  inchr tmp___9 ;
  int tmp___10 ;

  {
#line 1912
  if (getinchr_flag) {
#line 1913
    getinchr_flag = 0;
#line 1914
    return (getinchr_buffer);
  }
#line 1917
  switch (multibyte) {
  case 0: 
#line 1919
  tmp = iso2022();
#line 1919
  return (tmp);
  case 1: 
#line 1921
  ch = Agetchar();
#line 1922
  if (ch >= 128) {
#line 1922
    if (ch <= 159) {
#line 1924
      tmp___0 = Agetchar();
#line 1924
      ch = (ch << 8) + tmp___0;
    } else {
#line 1922
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1922
  if (ch >= 224) {
#line 1922
    if (ch <= 239) {
#line 1924
      tmp___0 = Agetchar();
#line 1924
      ch = (ch << 8) + tmp___0;
    }
  }
#line 1926
  return ((inchr )ch);
  case 2: 
#line 1928
  ch = Agetchar();
#line 1929
  if (ch < 128) {
#line 1929
    return ((inchr )ch);
  }
#line 1930
  if (ch < 192) {
#line 1931
    return ((inchr )128);
  } else
#line 1930
  if (ch > 253) {
#line 1931
    return ((inchr )128);
  }
#line 1932
  tmp___1 = Agetchar();
#line 1932
  ch2 = tmp___1 & 63;
#line 1933
  if (ch < 224) {
#line 1933
    return ((inchr )(((ch & 31) << 6) + ch2));
  }
#line 1934
  tmp___2 = Agetchar();
#line 1934
  ch3 = tmp___2 & 63;
#line 1935
  if (ch < 240) {
#line 1936
    return ((inchr )((((ch & 15) << 12) + (ch2 << 6)) + ch3));
  }
#line 1937
  tmp___3 = Agetchar();
#line 1937
  ch4 = tmp___3 & 63;
#line 1938
  if (ch < 248) {
#line 1939
    return ((inchr )(((((ch & 7) << 18) + (ch2 << 12)) + (ch3 << 6)) + ch4));
  }
#line 1940
  tmp___4 = Agetchar();
#line 1940
  ch5 = tmp___4 & 63;
#line 1941
  if (ch < 252) {
#line 1942
    return ((inchr )((((((ch & 3) << 24) + (ch2 << 18)) + (ch3 << 12)) + (ch4 << 6)) + ch5));
  }
#line 1944
  tmp___5 = Agetchar();
#line 1944
  ch6 = tmp___5 & 63;
#line 1945
  return ((inchr )(((((((ch & 1) << 30) + (ch2 << 24)) + (ch3 << 18)) + (ch4 << 12)) + (ch5 << 6)) + ch6));
  case 3: 
#line 1948
  ch = Agetchar();
#line 1949
  if (ch == -1) {
#line 1949
    return ((inchr )ch);
  }
#line 1950
  if (hzmode) {
#line 1951
    tmp___6 = Agetchar();
#line 1951
    ch = (ch << 8) + tmp___6;
#line 1952
    if (ch == (125 << 8) + 126) {
#line 1953
      hzmode = 0;
#line 1954
      tmp___7 = getinchr();
#line 1954
      return (tmp___7);
    }
#line 1956
    return ((inchr )ch);
  } else
#line 1958
  if (ch == 126) {
#line 1959
    ch = Agetchar();
#line 1960
    if (ch == 123) {
#line 1961
      hzmode = 1;
#line 1962
      tmp___8 = getinchr();
#line 1962
      return (tmp___8);
    } else
#line 1964
    if (ch == 126) {
#line 1965
      return ((inchr )ch);
    } else {
#line 1968
      tmp___9 = getinchr();
#line 1968
      return (tmp___9);
    }
  } else {
#line 1971
    return ((inchr )ch);
  }
  case 4: 
#line 1973
  ch = Agetchar();
#line 1974
  if (ch >= 128) {
#line 1974
    if (ch <= 159) {
#line 1976
      tmp___10 = Agetchar();
#line 1976
      ch = (ch << 8) + tmp___10;
    } else {
#line 1974
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1974
  if (ch >= 224) {
#line 1974
    if (ch <= 239) {
#line 1976
      tmp___10 = Agetchar();
#line 1976
      ch = (ch << 8) + tmp___10;
    }
  }
#line 1978
  return ((inchr )ch);
  default: 
#line 1980
  return ((inchr )128);
  }
}
}
#line 1995 "figlet.c"
int main(int argc , char **argv ) 
{ 
  inchr c ;
  inchr c2 ;
  int i ;
  int last_was_eol_flag ;
  int wordbreakmode ;
  int char_not_added ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 2014
  Myargc = argc;
#line 2015
  Myargv = argv;
#line 2016
  getparams();
#line 2017
  readcontrolfiles();
#line 2018
  readfont();
#line 2019
  linealloc();
#line 2021
  wordbreakmode = 0;
#line 2022
  last_was_eol_flag = 0;
#line 2025
  toiletfont = 0;
#line 2028
  while (1) {
#line 2028
    c = getinchr();
#line 2028
    if (! (c != -1L)) {
#line 2028
      break;
    }
#line 2030
    if (c == 10L) {
#line 2030
      if (paragraphflag) {
#line 2030
        if (! last_was_eol_flag) {
#line 2031
          c2 = getinchr();
#line 2031
          ungetinchr(c2);
#line 2032
          if ((c2 & -128L) == 0L) {
#line 2032
            tmp___0 = __ctype_b_loc();
#line 2032
            if ((int const   )*(*tmp___0 + (int )c2) & 8192) {
#line 2032
              c = (inchr )'\n';
            } else {
#line 2032
              c = (inchr )' ';
            }
          } else {
#line 2032
            c = (inchr )' ';
          }
        }
      }
    }
#line 2034
    if ((c & -128L) == 0L) {
#line 2034
      tmp___1 = __ctype_b_loc();
#line 2034
      if ((int const   )*(*tmp___1 + (int )c) & 8192) {
#line 2034
        if (c != 9L) {
#line 2034
          if (c != 32L) {
#line 2034
            tmp___2 = 1;
          } else {
#line 2034
            tmp___2 = 0;
          }
        } else {
#line 2034
          tmp___2 = 0;
        }
      } else {
#line 2034
        tmp___2 = 0;
      }
    } else {
#line 2034
      tmp___2 = 0;
    }
#line 2034
    last_was_eol_flag = tmp___2;
#line 2036
    if (deutschflag) {
#line 2037
      if (c >= 91L) {
#line 2037
        if (c <= 93L) {
#line 2038
          c = deutsch[c - 91L];
        } else {
#line 2037
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2040
      if (c >= 123L) {
#line 2040
        if (c <= 126L) {
#line 2041
          c = deutsch[(c - 123L) + 3L];
        }
      }
    }
#line 2045
    c = handlemapping(c);
#line 2047
    if ((c & -128L) == 0L) {
#line 2047
      tmp___3 = __ctype_b_loc();
#line 2047
      if ((int const   )*(*tmp___3 + (int )c) & 8192) {
#line 2048
        if (c == 9L) {
#line 2048
          c = (inchr )' ';
        } else
#line 2048
        if (c == 32L) {
#line 2048
          c = (inchr )' ';
        } else {
#line 2048
          c = (inchr )'\n';
        }
      }
    }
#line 2051
    if (c > 0L) {
#line 2051
      if (c < 32L) {
#line 2051
        if (c != 10L) {
#line 2051
          continue;
        } else {
#line 2051
          goto _L___1;
        }
      } else {
#line 2051
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2051
    if (c == 127L) {
#line 2051
      continue;
    }
#line 2058
    while (1) {
#line 2059
      char_not_added = 0;
#line 2061
      if (wordbreakmode == -1) {
#line 2062
        if (c == 32L) {
#line 2063
          break;
        } else
#line 2065
        if (c == 10L) {
#line 2066
          wordbreakmode = 0;
#line 2067
          break;
        }
#line 2069
        wordbreakmode = 0;
      }
#line 2072
      if (c == 10L) {
#line 2073
        printline();
#line 2074
        wordbreakmode = 0;
      } else {
#line 2077
        tmp___5 = addchar(c);
#line 2077
        if (tmp___5) {
#line 2078
          if (c != 32L) {
#line 2079
            if (wordbreakmode >= 2) {
#line 2079
              wordbreakmode = 3;
            } else {
#line 2079
              wordbreakmode = 1;
            }
          } else
#line 2082
          if (wordbreakmode > 0) {
#line 2082
            wordbreakmode = 2;
          } else {
#line 2082
            wordbreakmode = 0;
          }
        } else
#line 2086
        if (outlinelen == 0) {
#line 2087
          i = 0;
#line 2087
          while (i < charheight) {
#line 2088
            if (right2left) {
#line 2088
              if (outputwidth > 1) {
#line 2089
                tmp___4 = wcslen((wchar_t const   *)*(currchar + i));
#line 2089
                putstring((*(currchar + i) + tmp___4) - outlinelenlimit);
              } else {
#line 2092
                putstring(*(currchar + i));
              }
            } else {
#line 2092
              putstring(*(currchar + i));
            }
#line 2087
            i ++;
          }
#line 2095
          wordbreakmode = -1;
        } else
#line 2098
        if (c == 32L) {
#line 2099
          if (wordbreakmode == 2) {
#line 2100
            splitline();
          } else {
#line 2103
            printline();
          }
#line 2105
          wordbreakmode = -1;
        } else {
#line 2109
          if (wordbreakmode >= 2) {
#line 2110
            splitline();
          } else {
#line 2113
            printline();
          }
#line 2115
          if (wordbreakmode == 3) {
#line 2115
            wordbreakmode = 1;
          } else {
#line 2115
            wordbreakmode = 0;
          }
#line 2116
          char_not_added = 1;
        }
      }
#line 2058
      if (! char_not_added) {
#line 2058
        break;
      }
    }
  }
#line 2122
  if (outlinelen != 0) {
#line 2123
    printline();
  }
#line 2125
  return (0);
}
}
#line 1 "zipio.o"
#pragma merger("0","/tmp/cil-FOqjgJrF.i","")
#line 196 "/usr/include/stdio.h"
extern FILE *tmpfile(void) ;
#line 238
extern int fclose(FILE *__stream ) ;
#line 273
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 706
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 712
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 746
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 751
extern long ftell(FILE *__stream ) ;
#line 95 "zipio.h"
size_t Zread(void *ptr , size_t size , size_t n , ZFILE *stream ) ;
#line 96
int Zseek(ZFILE *stream , long offset , int whence ) ;
#line 97
long Ztell(ZFILE *stream ) ;
#line 63 "inflate.h"
void *InflateInitialize(void *AppState , int (*putbuffer_ptr)(void *AppState , unsigned char *buffer ,
                                                              long length ) , void *(*malloc_ptr)(long length ) ,
                        void (*free_ptr)(void *buffer ) ) ;
#line 75
int InflatePutBuffer(void *InflateState , unsigned char *buffer , long length ) ;
#line 82
int InflateTerminate(void *InflateState ) ;
#line 52 "crc.h"
unsigned long CrcUpdate(unsigned long crc , unsigned char *buffer , long length ) ;
#line 275 "zipio.c"
static void BufferInitialize(struct ZipioState *zs , int doinflate ) 
{ 
  long tmp ;
  int i ;

  {
#line 280
  zs->getoff = -1L;
#line 281
  zs->tmpfil = (FILE *)((void *)0);
#line 287
  if (! doinflate) {
#line 289
    zs->tmpfil = zs->OpenFile;
#line 292
    fseek(zs->tmpfil, 0L, 2);
#line 293
    tmp = ftell(zs->tmpfil);
#line 293
    zs->usiz = (unsigned long )tmp;
#line 294
    zs->outinf = zs->usiz;
#line 297
    fseek(zs->tmpfil, 0L, 0);
  }
#line 301
  if (! zs->tmpfil) {
#line 303
    if (zs->usiz >= 262144UL) {
#line 304
      zs->tmpfil = tmpfile();
    }
  }
#line 308
  if (! zs->tmpfil) {
#line 312
    i = 0;
#line 312
    while (i < 2048) {
#line 313
      zs->ptrbuf[i] = (unsigned char *)((void *)0);
#line 312
      i ++;
    }
  }
#line 315
  return;
}
}
#line 318 "zipio.c"
static int BufferPump(struct ZipioState *zs , long length ) 
{ 
  size_t inplen ;
  size_t ret ;
  int tmp ;

  {
#line 323
  if ((unsigned long )length > zs->usiz) {
#line 323
    return (1);
  }
#line 326
  while (1) {
#line 326
    if (! zs->errorencountered) {
#line 326
      if (! (zs->outinf < (unsigned long )length)) {
#line 326
        break;
      }
    } else {
#line 326
      break;
    }
#line 329
    if (zs->csiz - zs->inpinf < 8192UL) {
#line 330
      inplen = zs->csiz - zs->inpinf;
    } else {
#line 332
      inplen = (size_t )8192;
    }
#line 334
    if (inplen <= 0UL) {
#line 334
      return (1);
    }
#line 337
    ret = fread((void * __restrict  )(zs->inpbuf), (size_t )1, inplen, (FILE * __restrict  )zs->OpenFile);
#line 338
    if (ret != inplen) {
#line 338
      return (1);
    }
#line 341
    zs->inpinf += inplen;
#line 344
    tmp = InflatePutBuffer(zs->inflatestate, zs->inpbuf, (long )inplen);
#line 344
    if (tmp) {
#line 344
      return (1);
    }
  }
#line 347
  return (0);
}
}
#line 351 "zipio.c"
static int BufferRead(struct ZipioState *zs , long offset , unsigned char *buffer ,
                      long length ) 
{ 
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned int i ;
  unsigned int off ;
  unsigned int len ;
  unsigned char *ptr ;
  long tmpoff ;
  unsigned char *tmpbuf ;
  long tmplen ;

  {
#line 364
  tmp = BufferPump(zs, offset + length);
#line 364
  if (tmp) {
#line 364
    return (1);
  }
#line 367
  if (zs->tmpfil) {
#line 369
    tmp___0 = fseek(zs->tmpfil, offset, 0);
#line 369
    if (tmp___0) {
#line 369
      return (1);
    }
#line 370
    tmp___1 = fread((void * __restrict  )buffer, (size_t )1, (size_t )length, (FILE * __restrict  )zs->tmpfil);
#line 370
    if (tmp___1 != (size_t )length) {
#line 370
      return (1);
    }
  } else {
#line 384
    tmpoff = offset;
#line 385
    tmpbuf = buffer;
#line 386
    tmplen = length;
#line 389
    if (tmpoff + tmplen > 67108864L) {
#line 389
      return (1);
    }
#line 392
    while (tmplen) {
#line 395
      i = (unsigned int )(tmpoff / 32768L);
#line 396
      ptr = zs->ptrbuf[i];
#line 397
      if (! ptr) {
#line 397
        return (1);
      }
#line 400
      off = (unsigned int )(tmpoff & 32767L);
#line 401
      len = 32768U - off;
#line 402
      if ((long )len > tmplen) {
#line 402
        len = (unsigned int )tmplen;
      }
#line 405
      ptr += off;
#line 411
      i = 0U;
#line 411
      while (i < len) {
#line 412
        *(tmpbuf + i) = *(ptr + i);
#line 411
        i ++;
      }
#line 416
      tmpoff += (long )len;
#line 417
      tmpbuf += len;
#line 418
      tmplen -= (long )len;
    }
  }
#line 423
  return (0);
}
}
#line 427 "zipio.c"
static int BufferAppend(struct ZipioState *zs , unsigned char *buffer , long length ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  unsigned int i ;
  unsigned int off ;
  unsigned int len ;
  unsigned char *ptr ;
  long tmpoff ;
  unsigned char *tmpbuf ;
  long tmplen ;
  void *tmp___1 ;

  {
#line 434
  if (zs->tmpfil) {
#line 436
    tmp = fseek(zs->tmpfil, (long )zs->outinf, 0);
#line 436
    if (tmp) {
#line 436
      return (1);
    }
#line 437
    tmp___0 = fwrite((void const   * __restrict  )buffer, (size_t )1, (size_t )length,
                     (FILE * __restrict  )zs->tmpfil);
#line 437
    if (tmp___0 != (size_t )length) {
#line 437
      return (1);
    }
  } else {
#line 451
    tmpoff = (long )zs->outinf;
#line 452
    tmpbuf = buffer;
#line 453
    tmplen = length;
#line 456
    if (tmpoff + tmplen > 67108864L) {
#line 456
      return (1);
    }
#line 459
    while (tmplen) {
#line 462
      i = (unsigned int )(tmpoff / 32768L);
#line 463
      ptr = zs->ptrbuf[i];
#line 464
      if (! ptr) {
#line 466
        tmp___1 = malloc((size_t )32768U);
#line 466
        ptr = (unsigned char *)tmp___1;
#line 467
        if (! ptr) {
#line 467
          return (1);
        }
#line 468
        zs->ptrbuf[i] = ptr;
      }
#line 472
      off = (unsigned int )(tmpoff & 32767L);
#line 473
      len = 32768U - off;
#line 474
      if ((long )len > tmplen) {
#line 474
        len = (unsigned int )tmplen;
      }
#line 477
      ptr += off;
#line 483
      i = 0U;
#line 483
      while (i < len) {
#line 484
        *(ptr + i) = *(tmpbuf + i);
#line 483
        i ++;
      }
#line 488
      tmpoff += (long )len;
#line 489
      tmpbuf += len;
#line 490
      tmplen -= (long )len;
    }
  }
#line 495
  zs->outinf += (unsigned long )length;
#line 498
  return (0);
}
}
#line 502 "zipio.c"
static void BufferTerminate(struct ZipioState *zs ) 
{ 
  int i ;

  {
#line 507
  if ((unsigned long )zs->tmpfil == (unsigned long )zs->OpenFile) {
#line 509
    zs->tmpfil = (FILE *)((void *)0);
  } else
#line 512
  if (zs->tmpfil) {
#line 514
    fclose(zs->tmpfil);
#line 515
    zs->tmpfil = (FILE *)((void *)0);
  } else {
#line 522
    i = 0;
#line 522
    while (i < 2048) {
#line 523
      if (zs->ptrbuf[i]) {
#line 523
        free((void *)zs->ptrbuf[i]);
      }
#line 522
      i ++;
    }
  }
#line 525
  return;
}
}
#line 531 "zipio.c"
static int inflate_putbuffer(void *stream , unsigned char *buffer , long length ) 
{ 
  int tmp ;

  {
#line 540
  if (((struct ZipioState *)stream)->outinf + (unsigned long )length > ((struct ZipioState *)stream)->usiz) {
#line 540
    return (1);
  }
#line 543
  ((struct ZipioState *)stream)->filecrc = CrcUpdate(((struct ZipioState *)stream)->filecrc,
                                                     buffer, length);
#line 546
  tmp = BufferAppend((struct ZipioState *)stream, buffer, length);
#line 546
  if (tmp) {
#line 546
    return (1);
  }
#line 549
  return (0);
}
}
#line 552 "zipio.c"
static void *inflate_malloc(long length ) 
{ 
  void *tmp ;

  {
#line 554
  tmp = malloc((size_t )length);
#line 554
  return (tmp);
}
}
#line 557 "zipio.c"
static void inflate_free(void *buffer ) 
{ 


  {
#line 559
  free(buffer);
#line 560
  return;
}
}
#line 562 "zipio.c"
ZFILE *Zopen(char const   *path , char const   *mode ) 
{ 
  struct ZipioState *zs ;
  long inplen ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 569
  tmp = malloc(sizeof(struct ZipioState ));
#line 569
  zs = (struct ZipioState *)tmp;
#line 570
  if (! zs) {
#line 570
    return ((ZFILE *)((void *)0));
  }
#line 574
  zs->ptr = (unsigned char *)((void *)0);
#line 574
  zs->len = 0;
#line 578
  zs->errorencountered = 0;
#line 580
  zs->inpinf = 0UL;
#line 581
  zs->outinf = 0UL;
#line 583
  zs->fileposition = 0UL;
#line 585
  zs->filecrc = 4294967295UL;
#line 588
  zs->OpenFile = fopen((char const   * __restrict  )path, (char const   * __restrict  )mode);
#line 589
  if (! zs->OpenFile) {
#line 591
    free((void *)zs);
#line 592
    return ((ZFILE *)((void *)0));
  }
#line 596
  tmp___0 = fread((void * __restrict  )(zs->inpbuf), (size_t )1, (size_t )8192, (FILE * __restrict  )zs->OpenFile);
#line 596
  inplen = (long )tmp___0;
#line 596
  if (inplen >= 30L) {
#line 598
    zs->sign = (((unsigned long )*((zs->inpbuf + 0) + 0) | ((unsigned long )*((zs->inpbuf + 0) + 1) << 8)) | ((unsigned long )*((zs->inpbuf + 0) + 2) << 16)) | ((unsigned long )*((zs->inpbuf + 0) + 3) << 24);
#line 599
    zs->vers = (unsigned int )*((zs->inpbuf + 4) + 0) | ((unsigned int )*((zs->inpbuf + 4) + 1) << 8);
#line 600
    zs->flag = (unsigned int )*((zs->inpbuf + 6) + 0) | ((unsigned int )*((zs->inpbuf + 6) + 1) << 8);
#line 601
    zs->comp = (unsigned int )*((zs->inpbuf + 8) + 0) | ((unsigned int )*((zs->inpbuf + 8) + 1) << 8);
#line 602
    zs->mtim = (unsigned int )*((zs->inpbuf + 10) + 0) | ((unsigned int )*((zs->inpbuf + 10) + 1) << 8);
#line 603
    zs->mdat = (unsigned int )*((zs->inpbuf + 12) + 0) | ((unsigned int )*((zs->inpbuf + 12) + 1) << 8);
#line 604
    zs->crc3 = (((unsigned long )*((zs->inpbuf + 14) + 0) | ((unsigned long )*((zs->inpbuf + 14) + 1) << 8)) | ((unsigned long )*((zs->inpbuf + 14) + 2) << 16)) | ((unsigned long )*((zs->inpbuf + 14) + 3) << 24);
#line 605
    zs->csiz = (((unsigned long )*((zs->inpbuf + 18) + 0) | ((unsigned long )*((zs->inpbuf + 18) + 1) << 8)) | ((unsigned long )*((zs->inpbuf + 18) + 2) << 16)) | ((unsigned long )*((zs->inpbuf + 18) + 3) << 24);
#line 606
    zs->usiz = (((unsigned long )*((zs->inpbuf + 22) + 0) | ((unsigned long )*((zs->inpbuf + 22) + 1) << 8)) | ((unsigned long )*((zs->inpbuf + 22) + 2) << 16)) | ((unsigned long )*((zs->inpbuf + 22) + 3) << 24);
#line 607
    zs->flen = (unsigned int )*((zs->inpbuf + 26) + 0) | ((unsigned int )*((zs->inpbuf + 26) + 1) << 8);
#line 608
    zs->elen = (unsigned int )*((zs->inpbuf + 28) + 0) | ((unsigned int )*((zs->inpbuf + 28) + 1) << 8);
  } else {
#line 626
    zs->sign = 0UL;
  }
#line 632
  if (zs->sign != 67324752UL) {
#line 638
    BufferInitialize(zs, 0);
#line 640
    zs->inflatestate = (void *)0;
  } else
#line 632
  if (zs->flag & 1U) {
#line 638
    BufferInitialize(zs, 0);
#line 640
    zs->inflatestate = (void *)0;
  } else
#line 632
  if (zs->comp != 8U) {
#line 638
    BufferInitialize(zs, 0);
#line 640
    zs->inflatestate = (void *)0;
  } else
#line 632
  if (inplen <= (long )((30U + zs->flen) + zs->elen)) {
#line 638
    BufferInitialize(zs, 0);
#line 640
    zs->inflatestate = (void *)0;
  } else {
#line 645
    BufferInitialize(zs, 1);
#line 647
    zs->inflatestate = InflateInitialize((void *)zs, & inflate_putbuffer, & inflate_malloc,
                                         & inflate_free);
#line 654
    tmp___1 = InflatePutBuffer(zs->inflatestate, ((zs->inpbuf + 30) + zs->flen) + zs->elen,
                               ((inplen - 30L) - (long )zs->flen) - (long )zs->elen);
#line 654
    if (tmp___1) {
#line 659
      zs->errorencountered = 1;
    }
#line 661
    zs->inpinf += (unsigned long )(((inplen - 30L) - (long )zs->flen) - (long )zs->elen);
  }
#line 665
  return ((ZFILE *)zs);
}
}
#line 668 "zipio.c"
int _Zgetc(ZFILE *stream ) 
{ 
  long offset ;
  long length ;
  int off ;
  int tmp ;
  unsigned char *tmp___0 ;

  {
#line 676
  if (((struct ZipioState *)stream)->errorencountered) {
#line 676
    return (-1);
  }
#line 678
  if (((struct ZipioState *)stream)->ptr) {
#line 678
    ((struct ZipioState *)stream)->fileposition &= 0xffffffffffff8000UL;
#line 678
    ((struct ZipioState *)stream)->fileposition += (unsigned long )(((struct ZipioState *)stream)->ptr - ((struct ZipioState *)stream)->getbuf);
#line 678
    ((struct ZipioState *)stream)->ptr = (unsigned char *)((void *)0);
  }
#line 678
  ((struct ZipioState *)stream)->len = 0;
#line 681
  if (((struct ZipioState *)stream)->fileposition >= ((struct ZipioState *)stream)->usiz) {
#line 681
    return (-1);
  }
#line 684
  offset = (long )(((struct ZipioState *)stream)->fileposition & 0xffffffffffff8000UL);
#line 685
  length = (long )(((struct ZipioState *)stream)->usiz - (unsigned long )offset);
#line 686
  if (length > 32768L) {
#line 686
    length = 32768L;
  }
#line 688
  if (((struct ZipioState *)stream)->getoff != offset) {
#line 690
    tmp = BufferRead((struct ZipioState *)stream, offset, ((struct ZipioState *)stream)->getbuf,
                     length);
#line 690
    if (tmp) {
#line 690
      return (-1);
    }
#line 692
    ((struct ZipioState *)stream)->getoff = offset;
  }
#line 696
  off = (int )(((struct ZipioState *)stream)->fileposition & 32767UL);
#line 697
  ((struct ZipioState *)stream)->len = (int )(length - (long )off);
#line 698
  ((struct ZipioState *)stream)->ptr = ((struct ZipioState *)stream)->getbuf + off;
#line 701
  (((struct ZipioState *)stream)->len) --;
#line 702
  tmp___0 = ((struct ZipioState *)stream)->ptr;
#line 702
  (((struct ZipioState *)stream)->ptr) ++;
#line 702
  return ((int )*tmp___0);
}
}
#line 705 "zipio.c"
size_t Zread(void *ptr , size_t size , size_t n , ZFILE *stream ) 
{ 
  long length ;
  int tmp ;

  {
#line 711
  if (((struct ZipioState *)stream)->errorencountered) {
#line 711
    return ((size_t )0);
  }
#line 713
  if (((struct ZipioState *)stream)->ptr) {
#line 713
    ((struct ZipioState *)stream)->fileposition &= 0xffffffffffff8000UL;
#line 713
    ((struct ZipioState *)stream)->fileposition += (unsigned long )(((struct ZipioState *)stream)->ptr - ((struct ZipioState *)stream)->getbuf);
#line 713
    ((struct ZipioState *)stream)->ptr = (unsigned char *)((void *)0);
  }
#line 713
  ((struct ZipioState *)stream)->len = 0;
#line 716
  length = (long )(size * (size_t )((long )n));
#line 719
  if (((struct ZipioState *)stream)->fileposition + (unsigned long )length > ((struct ZipioState *)stream)->usiz) {
#line 720
    length = (long )(((struct ZipioState *)stream)->usiz - ((struct ZipioState *)stream)->fileposition);
  }
#line 723
  if (length <= 0L) {
#line 723
    return ((size_t )0);
  }
#line 726
  length = (long )((size_t )length / size);
#line 727
  length = (long )((size_t )length * size);
#line 730
  if (length <= 0L) {
#line 730
    return ((size_t )0);
  }
#line 733
  tmp = BufferRead((struct ZipioState *)stream, (long )((struct ZipioState *)stream)->fileposition,
                   (unsigned char *)ptr, length);
#line 733
  if (tmp) {
#line 734
    return ((size_t )0);
  }
#line 737
  ((struct ZipioState *)stream)->fileposition += (unsigned long )length;
#line 740
  return ((size_t )length / size);
}
}
#line 743 "zipio.c"
int Zseek(ZFILE *stream , long offset , int whence ) 
{ 
  long newoffset ;

  {
#line 749
  if (((struct ZipioState *)stream)->errorencountered) {
#line 749
    return (-1);
  }
#line 751
  if (((struct ZipioState *)stream)->ptr) {
#line 751
    ((struct ZipioState *)stream)->fileposition &= 0xffffffffffff8000UL;
#line 751
    ((struct ZipioState *)stream)->fileposition += (unsigned long )(((struct ZipioState *)stream)->ptr - ((struct ZipioState *)stream)->getbuf);
#line 751
    ((struct ZipioState *)stream)->ptr = (unsigned char *)((void *)0);
  }
#line 751
  ((struct ZipioState *)stream)->len = 0;
#line 753
  if (whence == 0) {
#line 755
    newoffset = offset;
  } else
#line 757
  if (whence == 1) {
#line 759
    newoffset = (long )(((struct ZipioState *)stream)->fileposition + (unsigned long )offset);
  } else
#line 761
  if (whence == 2) {
#line 763
    newoffset = (long )(((struct ZipioState *)stream)->fileposition + ((struct ZipioState *)stream)->usiz);
  } else {
#line 767
    return (-1);
  }
#line 770
  if (newoffset < 0L) {
#line 770
    return (-1);
  } else
#line 770
  if ((unsigned long )newoffset > ((struct ZipioState *)stream)->usiz) {
#line 770
    return (-1);
  }
#line 772
  ((struct ZipioState *)stream)->fileposition = (unsigned long )newoffset;
#line 774
  return (0);
}
}
#line 777 "zipio.c"
long Ztell(ZFILE *stream ) 
{ 


  {
#line 781
  if (((struct ZipioState *)stream)->errorencountered) {
#line 781
    return (-1L);
  }
#line 783
  if (((struct ZipioState *)stream)->ptr) {
#line 783
    ((struct ZipioState *)stream)->fileposition &= 0xffffffffffff8000UL;
#line 783
    ((struct ZipioState *)stream)->fileposition += (unsigned long )(((struct ZipioState *)stream)->ptr - ((struct ZipioState *)stream)->getbuf);
#line 783
    ((struct ZipioState *)stream)->ptr = (unsigned char *)((void *)0);
  }
#line 783
  ((struct ZipioState *)stream)->len = 0;
#line 785
  return ((long )((struct ZipioState *)stream)->fileposition);
}
}
#line 788 "zipio.c"
int Zclose(ZFILE *stream ) 
{ 
  int ret ;
  int tmp ;

  {
#line 794
  if (((struct ZipioState *)stream)->ptr) {
#line 794
    ((struct ZipioState *)stream)->fileposition &= 0xffffffffffff8000UL;
#line 794
    ((struct ZipioState *)stream)->fileposition += (unsigned long )(((struct ZipioState *)stream)->ptr - ((struct ZipioState *)stream)->getbuf);
#line 794
    ((struct ZipioState *)stream)->ptr = (unsigned char *)((void *)0);
  }
#line 794
  ((struct ZipioState *)stream)->len = 0;
#line 797
  if (((struct ZipioState *)stream)->inflatestate) {
#line 799
    tmp = InflateTerminate(((struct ZipioState *)stream)->inflatestate);
#line 799
    if (tmp) {
#line 800
      ((struct ZipioState *)stream)->errorencountered = 1;
    }
#line 803
    if (((struct ZipioState *)stream)->filecrc != (((struct ZipioState *)stream)->crc3 ^ 4294967295UL)) {
#line 804
      ((struct ZipioState *)stream)->errorencountered = 1;
    }
  }
#line 808
  ret = ((struct ZipioState *)stream)->errorencountered;
#line 811
  BufferTerminate((struct ZipioState *)stream);
#line 814
  free((void *)((struct ZipioState *)stream));
#line 817
  return (ret);
}
}
#line 1 "crc.o"
#pragma merger("0","/tmp/cil-kYIktUkQ.i","")
#line 38 "crc.c"
static unsigned long crctable[256]  = 
#line 38 "crc.c"
  {      0UL,      1996959894UL,      3993919788UL,      2567524794UL, 
        124634137UL,      1886057615UL,      3915621685UL,      2657392035UL, 
        249268274UL,      2044508324UL,      3772115230UL,      2547177864UL, 
        162941995UL,      2125561021UL,      3887607047UL,      2428444049UL, 
        498536548UL,      1789927666UL,      4089016648UL,      2227061214UL, 
        450548861UL,      1843258603UL,      4107580753UL,      2211677639UL, 
        325883990UL,      1684777152UL,      4251122042UL,      2321926636UL, 
        335633487UL,      1661365465UL,      4195302755UL,      2366115317UL, 
        997073096UL,      1281953886UL,      3579855332UL,      2724688242UL, 
        1006888145UL,      1258607687UL,      3524101629UL,      2768942443UL, 
        901097722UL,      1119000684UL,      3686517206UL,      2898065728UL, 
        853044451UL,      1172266101UL,      3705015759UL,      2882616665UL, 
        651767980UL,      1373503546UL,      3369554304UL,      3218104598UL, 
        565507253UL,      1454621731UL,      3485111705UL,      3099436303UL, 
        671266974UL,      1594198024UL,      3322730930UL,      2970347812UL, 
        795835527UL,      1483230225UL,      3244367275UL,      3060149565UL, 
        1994146192UL,      31158534UL,      2563907772UL,      4023717930UL, 
        1907459465UL,      112637215UL,      2680153253UL,      3904427059UL, 
        2013776290UL,      251722036UL,      2517215374UL,      3775830040UL, 
        2137656763UL,      141376813UL,      2439277719UL,      3865271297UL, 
        1802195444UL,      476864866UL,      2238001368UL,      4066508878UL, 
        1812370925UL,      453092731UL,      2181625025UL,      4111451223UL, 
        1706088902UL,      314042704UL,      2344532202UL,      4240017532UL, 
        1658658271UL,      366619977UL,      2362670323UL,      4224994405UL, 
        1303535960UL,      984961486UL,      2747007092UL,      3569037538UL, 
        1256170817UL,      1037604311UL,      2765210733UL,      3554079995UL, 
        1131014506UL,      879679996UL,      2909243462UL,      3663771856UL, 
        1141124467UL,      855842277UL,      2852801631UL,      3708648649UL, 
        1342533948UL,      654459306UL,      3188396048UL,      3373015174UL, 
        1466479909UL,      544179635UL,      3110523913UL,      3462522015UL, 
        1591671054UL,      702138776UL,      2966460450UL,      3352799412UL, 
        1504918807UL,      783551873UL,      3082640443UL,      3233442989UL, 
        3988292384UL,      2596254646UL,      62317068UL,      1957810842UL, 
        3939845945UL,      2647816111UL,      81470997UL,      1943803523UL, 
        3814918930UL,      2489596804UL,      225274430UL,      2053790376UL, 
        3826175755UL,      2466906013UL,      167816743UL,      2097651377UL, 
        4027552580UL,      2265490386UL,      503444072UL,      1762050814UL, 
        4150417245UL,      2154129355UL,      426522225UL,      1852507879UL, 
        4275313526UL,      2312317920UL,      282753626UL,      1742555852UL, 
        4189708143UL,      2394877945UL,      397917763UL,      1622183637UL, 
        3604390888UL,      2714866558UL,      953729732UL,      1340076626UL, 
        3518719985UL,      2797360999UL,      1068828381UL,      1219638859UL, 
        3624741850UL,      2936675148UL,      906185462UL,      1090812512UL, 
        3747672003UL,      2825379669UL,      829329135UL,      1181335161UL, 
        3412177804UL,      3160834842UL,      628085408UL,      1382605366UL, 
        3423369109UL,      3138078467UL,      570562233UL,      1426400815UL, 
        3317316542UL,      2998733608UL,      733239954UL,      1555261956UL, 
        3268935591UL,      3050360625UL,      752459403UL,      1541320221UL, 
        2607071920UL,      3965973030UL,      1969922972UL,      40735498UL, 
        2617837225UL,      3943577151UL,      1913087877UL,      83908371UL, 
        2512341634UL,      3803740692UL,      2075208622UL,      213261112UL, 
        2463272603UL,      3855990285UL,      2094854071UL,      198958881UL, 
        2262029012UL,      4057260610UL,      1759359992UL,      534414190UL, 
        2176718541UL,      4139329115UL,      1873836001UL,      414664567UL, 
        2282248934UL,      4279200368UL,      1711684554UL,      285281116UL, 
        2405801727UL,      4167216745UL,      1634467795UL,      376229701UL, 
        2685067896UL,      3608007406UL,      1308918612UL,      956543938UL, 
        2808555105UL,      3495958263UL,      1231636301UL,      1047427035UL, 
        2932959818UL,      3654703836UL,      1088359270UL,      936918000UL, 
        2847714899UL,      3736837829UL,      1202900863UL,      817233897UL, 
        3183342108UL,      3401237130UL,      1404277552UL,      615818150UL, 
        3134207493UL,      3453421203UL,      1423857449UL,      601450431UL, 
        3009837614UL,      3294710456UL,      1567103746UL,      711928724UL, 
        3020668471UL,      3272380065UL,      1510334235UL,      755167117UL};
#line 115 "crc.c"
unsigned long CrcUpdate(unsigned long crc , unsigned char *buffer , long length ) 
{ 
  long i ;

  {
#line 123
  i = 0L;
#line 123
  while (i < length) {
#line 125
    crc = crctable[(int )*(buffer + i) ^ (int )((unsigned char )crc)] ^ (crc >> 8);
#line 123
    i ++;
  }
#line 128
  return (crc);
}
}
#line 1 "inflate.o"
#pragma merger("0","/tmp/cil-JkyW5smS.i","")
#line 381 "inflate.c"
static unsigned int const   border[19]  = 
#line 381 "inflate.c"
  {      (unsigned int const   )16,      (unsigned int const   )17,      (unsigned int const   )18,      (unsigned int const   )0, 
        (unsigned int const   )8,      (unsigned int const   )7,      (unsigned int const   )9,      (unsigned int const   )6, 
        (unsigned int const   )10,      (unsigned int const   )5,      (unsigned int const   )11,      (unsigned int const   )4, 
        (unsigned int const   )12,      (unsigned int const   )3,      (unsigned int const   )13,      (unsigned int const   )2, 
        (unsigned int const   )14,      (unsigned int const   )1,      (unsigned int const   )15};
#line 384 "inflate.c"
static ush const   cplens[31]  = 
#line 384
  {      (ush const   )3,      (ush const   )4,      (ush const   )5,      (ush const   )6, 
        (ush const   )7,      (ush const   )8,      (ush const   )9,      (ush const   )10, 
        (ush const   )11,      (ush const   )13,      (ush const   )15,      (ush const   )17, 
        (ush const   )19,      (ush const   )23,      (ush const   )27,      (ush const   )31, 
        (ush const   )35,      (ush const   )43,      (ush const   )51,      (ush const   )59, 
        (ush const   )67,      (ush const   )83,      (ush const   )99,      (ush const   )115, 
        (ush const   )131,      (ush const   )163,      (ush const   )195,      (ush const   )227, 
        (ush const   )258,      (ush const   )0,      (ush const   )0};
#line 389 "inflate.c"
static ush const   cplext[31]  = 
#line 389
  {      (ush const   )0,      (ush const   )0,      (ush const   )0,      (ush const   )0, 
        (ush const   )0,      (ush const   )0,      (ush const   )0,      (ush const   )0, 
        (ush const   )1,      (ush const   )1,      (ush const   )1,      (ush const   )1, 
        (ush const   )2,      (ush const   )2,      (ush const   )2,      (ush const   )2, 
        (ush const   )3,      (ush const   )3,      (ush const   )3,      (ush const   )3, 
        (ush const   )4,      (ush const   )4,      (ush const   )4,      (ush const   )4, 
        (ush const   )5,      (ush const   )5,      (ush const   )5,      (ush const   )5, 
        (ush const   )0,      (ush const   )99,      (ush const   )99};
#line 393 "inflate.c"
static ush const   cpdist[30]  = 
#line 393
  {      (ush const   )1,      (ush const   )2,      (ush const   )3,      (ush const   )4, 
        (ush const   )5,      (ush const   )7,      (ush const   )9,      (ush const   )13, 
        (ush const   )17,      (ush const   )25,      (ush const   )33,      (ush const   )49, 
        (ush const   )65,      (ush const   )97,      (ush const   )129,      (ush const   )193, 
        (ush const   )257,      (ush const   )385,      (ush const   )513,      (ush const   )769, 
        (ush const   )1025,      (ush const   )1537,      (ush const   )2049,      (ush const   )3073, 
        (ush const   )4097,      (ush const   )6145,      (ush const   )8193,      (ush const   )12289, 
        (ush const   )16385,      (ush const   )24577};
#line 398 "inflate.c"
static ush const   cpdext[30]  = 
#line 398
  {      (ush const   )0,      (ush const   )0,      (ush const   )0,      (ush const   )0, 
        (ush const   )1,      (ush const   )1,      (ush const   )2,      (ush const   )2, 
        (ush const   )3,      (ush const   )3,      (ush const   )4,      (ush const   )4, 
        (ush const   )5,      (ush const   )5,      (ush const   )6,      (ush const   )6, 
        (ush const   )7,      (ush const   )7,      (ush const   )8,      (ush const   )8, 
        (ush const   )9,      (ush const   )9,      (ush const   )10,      (ush const   )10, 
        (ush const   )11,      (ush const   )11,      (ush const   )12,      (ush const   )12, 
        (ush const   )13,      (ush const   )13};
#line 407 "inflate.c"
static ush const   mask_bits[17]  = 
#line 407
  {      (ush const   )0,      (ush const   )1,      (ush const   )3,      (ush const   )7, 
        (ush const   )15,      (ush const   )31,      (ush const   )63,      (ush const   )127, 
        (ush const   )255,      (ush const   )511,      (ush const   )1023,      (ush const   )2047, 
        (ush const   )4095,      (ush const   )8191,      (ush const   )16383,      (ush const   )32767, 
        (ush const   )65535};
#line 445 "inflate.c"
static int const   lbits  =    (int const   )9;
#line 446 "inflate.c"
static int const   dbits  =    (int const   )6;
#line 458 "inflate.c"
static int huft_free(struct InflateState *is , struct huft *t ) 
{ 
  struct huft *p ;
  struct huft *q ;

  {
#line 466
  p = t;
#line 467
  while ((unsigned long )p != (unsigned long )((struct huft *)((void *)0))) {
#line 469
    p --;
#line 469
    q = p->v.t;
#line 470
    (*(is->free_ptr))((void *)((char *)p));
#line 471
    p = q;
  }
#line 473
  return (0);
}
}
#line 487 "inflate.c"
static int huft_build(struct InflateState *is , unsigned int *b , unsigned int n ,
                      unsigned int s , ush const   *d , ush const   *e , struct huft **t ,
                      int *m ) 
{ 
  unsigned int a ;
  unsigned int c[17] ;
  unsigned int el ;
  unsigned int f ;
  int g ;
  int h ;
  unsigned int i ;
  unsigned int j ;
  int k ;
  int lx[17] ;
  int *l ;
  unsigned int *p ;
  struct huft *q ;
  struct huft r ;
  struct huft *u[16] ;
  unsigned int v[288] ;
  int w ;
  unsigned int x[17] ;
  unsigned int *xp ;
  int y ;
  unsigned int z ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  unsigned int *tmp___7 ;
  unsigned int *tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;

  {
#line 508
  l = lx + 1;
#line 521
  i = 0U;
#line 521
  while (i < 17U) {
#line 523
    c[i] = 0U;
#line 521
    i ++;
  }
#line 527
  if (n > 256U) {
#line 527
    el = *(b + 256);
  } else {
#line 527
    el = 16U;
  }
#line 528
  p = b;
#line 528
  i = n;
#line 529
  while (1) {
#line 530
    (c[*p]) ++;
#line 530
    p ++;
#line 529
    i --;
#line 529
    if (! i) {
#line 529
      break;
    }
  }
#line 532
  if (c[0] == n) {
#line 534
    *t = (struct huft *)((void *)0);
#line 535
    *m = 0;
#line 536
    return (0);
  }
#line 540
  j = 1U;
#line 540
  while (j <= 16U) {
#line 541
    if (c[j]) {
#line 542
      break;
    }
#line 540
    j ++;
  }
#line 543
  k = (int )j;
#line 544
  if ((unsigned int )*m < j) {
#line 545
    *m = (int )j;
  }
#line 546
  i = 16U;
#line 546
  while (i) {
#line 547
    if (c[i]) {
#line 548
      break;
    }
#line 546
    i --;
  }
#line 549
  g = (int )i;
#line 550
  if ((unsigned int )*m > i) {
#line 551
    *m = (int )i;
  }
#line 554
  y = 1 << j;
#line 554
  while (j < i) {
#line 555
    y = (int )((unsigned int )y - c[j]);
#line 555
    if (y < 0) {
#line 556
      return (2);
    }
#line 554
    j ++;
#line 554
    y <<= 1;
  }
#line 557
  y = (int )((unsigned int )y - c[i]);
#line 557
  if (y < 0) {
#line 558
    return (2);
  }
#line 559
  c[i] += (unsigned int )y;
#line 562
  j = 0U;
#line 562
  x[1] = j;
#line 563
  p = c + 1;
#line 563
  xp = x + 2;
#line 564
  while (1) {
#line 564
    i --;
#line 564
    if (! i) {
#line 564
      break;
    }
#line 565
    tmp = xp;
#line 565
    xp ++;
#line 565
    tmp___0 = p;
#line 565
    p ++;
#line 565
    j += *tmp___0;
#line 565
    *tmp = j;
  }
#line 569
  p = b;
#line 569
  i = 0U;
#line 570
  while (1) {
#line 571
    tmp___2 = p;
#line 571
    p ++;
#line 571
    j = *tmp___2;
#line 571
    if (j != 0U) {
#line 572
      tmp___1 = x[j];
#line 572
      (x[j]) ++;
#line 572
      v[tmp___1] = i;
    }
#line 570
    i ++;
#line 570
    if (! (i < n)) {
#line 570
      break;
    }
  }
#line 576
  i = 0U;
#line 576
  x[0] = i;
#line 577
  p = v;
#line 578
  h = -1;
#line 579
  tmp___3 = 0;
#line 579
  *(l + -1) = tmp___3;
#line 579
  w = tmp___3;
#line 580
  u[0] = (struct huft *)((void *)0);
#line 581
  q = (struct huft *)((void *)0);
#line 582
  z = 0U;
#line 585
  while (k <= g) {
#line 587
    a = c[k];
#line 588
    while (1) {
#line 588
      tmp___9 = a;
#line 588
      a --;
#line 588
      if (! tmp___9) {
#line 588
        break;
      }
#line 592
      while (k > w + *(l + h)) {
#line 594
        tmp___4 = h;
#line 594
        h ++;
#line 594
        w += *(l + tmp___4);
#line 597
        z = (unsigned int )(g - w);
#line 597
        if (z > (unsigned int )*m) {
#line 597
          z = (unsigned int )*m;
        } else {
#line 597
          z = z;
        }
#line 598
        j = (unsigned int )(k - w);
#line 598
        f = (unsigned int )(1 << j);
#line 598
        if (f > a + 1U) {
#line 600
          f -= a + 1U;
#line 601
          xp = c + k;
#line 602
          while (1) {
#line 602
            j ++;
#line 602
            if (! (j < z)) {
#line 602
              break;
            }
#line 604
            f <<= 1;
#line 604
            xp ++;
#line 604
            if (f <= *xp) {
#line 605
              break;
            }
#line 606
            f -= *xp;
          }
        }
#line 609
        if ((unsigned int )w + j > el) {
#line 609
          if ((unsigned int )w < el) {
#line 610
            j = el - (unsigned int )w;
          }
        }
#line 611
        z = (unsigned int )(1 << j);
#line 612
        *(l + h) = (int )j;
#line 615
        tmp___5 = (*(is->malloc_ptr))((long )((unsigned long )(z + 1U) * sizeof(struct huft )));
#line 615
        q = (struct huft *)tmp___5;
#line 615
        if ((unsigned long )q == (unsigned long )((struct huft *)((void *)0))) {
#line 619
          if (h) {
#line 620
            huft_free(is, u[0]);
          }
#line 621
          return (3);
        }
#line 623
        *t = q + 1;
#line 624
        t = & q->v.t;
#line 624
        *t = (struct huft *)((void *)0);
#line 625
        q ++;
#line 625
        u[h] = q;
#line 628
        if (h) {
#line 630
          x[h] = i;
#line 631
          r.b = (uch )*(l + (h - 1));
#line 632
          r.e = (uch )(16U + j);
#line 633
          r.v.t = q;
#line 634
          j = (i & (unsigned int )((1 << w) - 1)) >> (w - *(l + (h - 1)));
#line 635
          *(u[h - 1] + j) = r;
        }
      }
#line 640
      r.b = (uch )(k - w);
#line 641
      if ((unsigned long )p >= (unsigned long )(v + n)) {
#line 642
        r.e = (uch )99;
      } else
#line 643
      if (*p < s) {
#line 645
        if (*p < 256U) {
#line 645
          tmp___6 = 16;
        } else {
#line 645
          tmp___6 = 15;
        }
#line 645
        r.e = (uch )tmp___6;
#line 646
        tmp___7 = p;
#line 646
        p ++;
#line 646
        r.v.n = (ush )*tmp___7;
      } else {
#line 650
        r.e = (uch )*(e + (*p - s));
#line 651
        tmp___8 = p;
#line 651
        p ++;
#line 651
        r.v.n = (ush )*(d + (*tmp___8 - s));
      }
#line 655
      f = (unsigned int )(1 << (k - w));
#line 656
      j = i >> w;
#line 656
      while (j < z) {
#line 657
        *(q + j) = r;
#line 656
        j += f;
      }
#line 660
      j = (unsigned int )(1 << (k - 1));
#line 660
      while (i & j) {
#line 661
        i ^= j;
#line 660
        j >>= 1;
      }
#line 662
      i ^= j;
#line 665
      while ((i & (unsigned int )((1 << w) - 1)) != x[h]) {
#line 666
        h --;
#line 666
        w -= *(l + h);
      }
    }
#line 585
    k ++;
  }
#line 671
  *m = *(l + 0);
#line 674
  if (y != 0) {
#line 674
    if (g != 1) {
#line 674
      tmp___10 = 1;
    } else {
#line 674
      tmp___10 = 0;
    }
  } else {
#line 674
    tmp___10 = 0;
  }
#line 674
  return (tmp___10);
}
}
#line 682 "inflate.c"
static int inflate_stored(struct InflateState *is ) 
{ 
  ulg b ;
  unsigned int k ;
  unsigned int w ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 691
  b = is->bb;
#line 692
  k = is->bk;
#line 693
  w = is->wp;
#line 699
  while (is->storelength > 0U) {
#line 701
    while (k < 8U) {
#line 701
      if (is->bs <= 0U) {
#line 701
        goto cleanup;
      }
#line 701
      b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 701
      (is->bs) --;
#line 701
      (is->bp) ++;
#line 701
      k += 8U;
    }
#line 702
    tmp = w;
#line 702
    w ++;
#line 702
    is->window[tmp] = (uch )b;
#line 703
    b >>= 8;
#line 703
    k -= 8U;
#line 704
    if (w >= 32768U) {
#line 704
      is->wp = w;
#line 704
      tmp___0 = (*(is->putbuffer_ptr))(is->AppState, is->window + is->wf, (long )(is->wp - is->wf));
#line 704
      if (tmp___0) {
#line 704
        is->errorencountered = 1;
#line 704
        return (1);
      }
#line 704
      is->wp &= 32767U;
#line 704
      is->wf = is->wp;
#line 704
      w = is->wp;
    }
#line 705
    (is->storelength) --;
  }
  cleanup: 
#line 711
  is->bb = b;
#line 712
  is->bk = k;
#line 713
  is->wp = w;
#line 715
  if (is->storelength > 0U) {
#line 716
    return (-1);
  } else {
#line 718
    return (0);
  }
}
}
#line 721 "inflate.c"
static int inflate_codes(struct InflateState *is , struct huft *tl , struct huft *td ,
                         int bl , int bd ) 
{ 
  unsigned int e ;
  unsigned int n ;
  unsigned int d ;
  unsigned int w ;
  struct huft *t ;
  unsigned int ml ;
  unsigned int md ;
  ulg b ;
  unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 738
  b = is->bb;
#line 739
  k = is->bk;
#line 740
  w = is->wp;
#line 743
  ml = (unsigned int )mask_bits[bl];
#line 744
  md = (unsigned int )mask_bits[bd];
#line 745
  while (1) {
#line 747
    is->catch_bb = b;
#line 747
    is->catch_bk = k;
#line 747
    is->catch_bp = is->bp;
#line 747
    is->catch_bs = is->bs;
#line 749
    while (k < (unsigned int )bl) {
#line 749
      if (is->bs <= 0U) {
#line 749
        goto cleanup;
      }
#line 749
      b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 749
      (is->bs) --;
#line 749
      (is->bp) ++;
#line 749
      k += 8U;
    }
#line 750
    t = tl + ((unsigned int )b & ml);
#line 750
    e = (unsigned int )t->e;
#line 750
    if (e > 16U) {
#line 751
      while (1) {
#line 752
        if (e == 99U) {
#line 753
          return (1);
        }
#line 754
        b >>= (int )t->b;
#line 754
        k -= (unsigned int )t->b;
#line 755
        e -= 16U;
#line 756
        while (k < e) {
#line 756
          if (is->bs <= 0U) {
#line 756
            goto cleanup;
          }
#line 756
          b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 756
          (is->bs) --;
#line 756
          (is->bp) ++;
#line 756
          k += 8U;
        }
#line 751
        t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 751
        e = (unsigned int )t->e;
#line 751
        if (! (e > 16U)) {
#line 751
          break;
        }
      }
    }
#line 758
    b >>= (int )t->b;
#line 758
    k -= (unsigned int )t->b;
#line 760
    if (e == 16U) {
#line 762
      tmp = w;
#line 762
      w ++;
#line 762
      is->window[tmp] = (uch )t->v.n;
#line 763
      if (w >= 32768U) {
#line 763
        is->wp = w;
#line 763
        tmp___0 = (*(is->putbuffer_ptr))(is->AppState, is->window + is->wf, (long )(is->wp - is->wf));
#line 763
        if (tmp___0) {
#line 763
          is->errorencountered = 1;
#line 763
          return (1);
        }
#line 763
        is->wp &= 32767U;
#line 763
        is->wf = is->wp;
#line 763
        w = is->wp;
      }
    } else
#line 765
    if (e == 15U) {
#line 767
      break;
    } else {
#line 772
      while (k < e) {
#line 772
        if (is->bs <= 0U) {
#line 772
          goto cleanup;
        }
#line 772
        b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 772
        (is->bs) --;
#line 772
        (is->bp) ++;
#line 772
        k += 8U;
      }
#line 773
      n = (unsigned int )t->v.n + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 774
      b >>= e;
#line 774
      k -= e;
#line 777
      while (k < (unsigned int )bd) {
#line 777
        if (is->bs <= 0U) {
#line 777
          goto cleanup;
        }
#line 777
        b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 777
        (is->bs) --;
#line 777
        (is->bp) ++;
#line 777
        k += 8U;
      }
#line 778
      t = td + ((unsigned int )b & md);
#line 778
      e = (unsigned int )t->e;
#line 778
      if (e > 16U) {
#line 779
        while (1) {
#line 780
          if (e == 99U) {
#line 781
            return (1);
          }
#line 782
          b >>= (int )t->b;
#line 782
          k -= (unsigned int )t->b;
#line 783
          e -= 16U;
#line 784
          while (k < e) {
#line 784
            if (is->bs <= 0U) {
#line 784
              goto cleanup;
            }
#line 784
            b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 784
            (is->bs) --;
#line 784
            (is->bp) ++;
#line 784
            k += 8U;
          }
#line 779
          t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 779
          e = (unsigned int )t->e;
#line 779
          if (! (e > 16U)) {
#line 779
            break;
          }
        }
      }
#line 786
      b >>= (int )t->b;
#line 786
      k -= (unsigned int )t->b;
#line 787
      while (k < e) {
#line 787
        if (is->bs <= 0U) {
#line 787
          goto cleanup;
        }
#line 787
        b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 787
        (is->bs) --;
#line 787
        (is->bp) ++;
#line 787
        k += 8U;
      }
#line 788
      d = (w - (unsigned int )t->v.n) - ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 789
      b >>= e;
#line 789
      k -= e;
#line 792
      while (1) {
#line 793
        d &= 32767U;
#line 793
        if (d > w) {
#line 793
          tmp___2 = d;
        } else {
#line 793
          tmp___2 = w;
        }
#line 793
        e = 32768U - tmp___2;
#line 793
        if (e > n) {
#line 793
          e = n;
        } else {
#line 793
          e = e;
        }
#line 793
        n -= e;
#line 805
        while (1) {
#line 806
          tmp___3 = w;
#line 806
          w ++;
#line 806
          tmp___4 = d;
#line 806
          d ++;
#line 806
          is->window[tmp___3] = is->window[tmp___4];
#line 805
          e --;
#line 805
          if (! e) {
#line 805
            break;
          }
        }
#line 808
        if (w >= 32768U) {
#line 808
          is->wp = w;
#line 808
          tmp___5 = (*(is->putbuffer_ptr))(is->AppState, is->window + is->wf, (long )(is->wp - is->wf));
#line 808
          if (tmp___5) {
#line 808
            is->errorencountered = 1;
#line 808
            return (1);
          }
#line 808
          is->wp &= 32767U;
#line 808
          is->wf = is->wp;
#line 808
          w = is->wp;
        }
#line 792
        if (! n) {
#line 792
          break;
        }
      }
    }
#line 812
    goto cleanup_done;
    cleanup: 
#line 812
    b = is->catch_bb;
#line 812
    k = is->catch_bk;
#line 812
    is->bb = b;
#line 812
    is->bk = k;
#line 812
    is->bp = is->catch_bp;
#line 812
    is->bs = is->catch_bs;
#line 813
    is->wp = w;
#line 814
    return (-1);
    cleanup_done: ;
  }
#line 819
  is->bb = b;
#line 820
  is->bk = k;
#line 821
  is->wp = w;
#line 824
  return (0);
}
}
#line 831 "inflate.c"
static int inflate_stored_setup(struct InflateState *is ) 
{ 
  unsigned int n ;
  ulg b ;
  unsigned int k ;

  {
#line 840
  b = is->bb;
#line 841
  k = is->bk;
#line 843
  is->catch_bb = b;
#line 843
  is->catch_bk = k;
#line 843
  is->catch_bp = is->bp;
#line 843
  is->catch_bs = is->bs;
#line 846
  n = k & 7U;
#line 847
  b >>= n;
#line 847
  k -= n;
#line 850
  while (k < 16U) {
#line 850
    if (is->bs <= 0U) {
#line 850
      goto cleanup;
    }
#line 850
    b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 850
    (is->bs) --;
#line 850
    (is->bp) ++;
#line 850
    k += 8U;
  }
#line 851
  n = (unsigned int )b & 65535U;
#line 852
  b >>= 16;
#line 852
  k -= 16U;
#line 853
  while (k < 16U) {
#line 853
    if (is->bs <= 0U) {
#line 853
      goto cleanup;
    }
#line 853
    b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 853
    (is->bs) --;
#line 853
    (is->bp) ++;
#line 853
    k += 8U;
  }
#line 854
  if (n != (unsigned int )(~ b & 65535UL)) {
#line 855
    return (1);
  }
#line 856
  b >>= 16;
#line 856
  k -= 16U;
#line 858
  goto cleanup_done;
  cleanup: 
#line 858
  b = is->catch_bb;
#line 858
  k = is->catch_bk;
#line 858
  is->bb = b;
#line 858
  is->bk = k;
#line 858
  is->bp = is->catch_bp;
#line 858
  is->bs = is->catch_bs;
#line 859
  return (-1);
  cleanup_done: 
#line 863
  is->storelength = n;
#line 866
  is->bb = b;
#line 867
  is->bk = k;
#line 869
  return (0);
}
}
#line 878 "inflate.c"
static int inflate_fixed_setup(struct InflateState *is ) 
{ 
  int i ;
  struct huft *tl ;
  struct huft *td ;
  int bl ;
  int bd ;
  unsigned int l[288] ;

  {
#line 890
  i = 0;
#line 890
  while (i < 144) {
#line 891
    l[i] = 8U;
#line 890
    i ++;
  }
#line 892
  while (i < 256) {
#line 893
    l[i] = 9U;
#line 892
    i ++;
  }
#line 894
  while (i < 280) {
#line 895
    l[i] = 7U;
#line 894
    i ++;
  }
#line 896
  while (i < 288) {
#line 897
    l[i] = 8U;
#line 896
    i ++;
  }
#line 898
  bl = 7;
#line 899
  i = huft_build(is, l, 288U, 257U, cplens, cplext, & tl, & bl);
#line 899
  if (i != 0) {
#line 900
    return (i);
  }
#line 903
  i = 0;
#line 903
  while (i < 30) {
#line 904
    l[i] = 5U;
#line 903
    i ++;
  }
#line 905
  bd = 5;
#line 906
  i = huft_build(is, l, 30U, 0U, cpdist, cpdext, & td, & bd);
#line 906
  if (i > 1) {
#line 908
    huft_free(is, tl);
#line 909
    return (i);
  }
#line 913
  is->tl = tl;
#line 914
  is->td = td;
#line 915
  is->bl = bl;
#line 916
  is->bd = bd;
#line 918
  return (0);
}
}
#line 927 "inflate.c"
static int inflate_dynamic_setup(struct InflateState *is ) 
{ 
  int i ;
  unsigned int j ;
  unsigned int l ;
  unsigned int m ;
  unsigned int n ;
  struct huft *tl ;
  struct huft *td ;
  int bl ;
  int bd ;
  unsigned int nb ;
  unsigned int nl ;
  unsigned int nd ;
  unsigned int ll[320] ;
  ulg b ;
  unsigned int k ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 952
  b = is->bb;
#line 953
  k = is->bk;
#line 956
  tl = (struct huft *)((void *)0);
#line 958
  is->catch_bb = b;
#line 958
  is->catch_bk = k;
#line 958
  is->catch_bp = is->bp;
#line 958
  is->catch_bs = is->bs;
#line 961
  while (k < 5U) {
#line 961
    if (is->bs <= 0U) {
#line 961
      goto cleanup;
    }
#line 961
    b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 961
    (is->bs) --;
#line 961
    (is->bp) ++;
#line 961
    k += 8U;
  }
#line 962
  nl = 257U + ((unsigned int )b & 31U);
#line 963
  b >>= 5;
#line 963
  k -= 5U;
#line 964
  while (k < 5U) {
#line 964
    if (is->bs <= 0U) {
#line 964
      goto cleanup;
    }
#line 964
    b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 964
    (is->bs) --;
#line 964
    (is->bp) ++;
#line 964
    k += 8U;
  }
#line 965
  nd = 1U + ((unsigned int )b & 31U);
#line 966
  b >>= 5;
#line 966
  k -= 5U;
#line 967
  while (k < 4U) {
#line 967
    if (is->bs <= 0U) {
#line 967
      goto cleanup;
    }
#line 967
    b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 967
    (is->bs) --;
#line 967
    (is->bp) ++;
#line 967
    k += 8U;
  }
#line 968
  nb = 4U + ((unsigned int )b & 15U);
#line 969
  b >>= 4;
#line 969
  k -= 4U;
#line 971
  if (nl > 288U) {
#line 975
    return (1);
  } else
#line 971
  if (nd > 32U) {
#line 975
    return (1);
  }
#line 978
  j = 0U;
#line 978
  while (j < 19U) {
#line 978
    ll[j] = 0U;
#line 978
    j ++;
  }
#line 979
  j = 0U;
#line 979
  while (j < nb) {
#line 981
    while (k < 3U) {
#line 981
      if (is->bs <= 0U) {
#line 981
        goto cleanup;
      }
#line 981
      b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 981
      (is->bs) --;
#line 981
      (is->bp) ++;
#line 981
      k += 8U;
    }
#line 982
    ll[border[j]] = (unsigned int )b & 7U;
#line 983
    b >>= 3;
#line 983
    k -= 3U;
#line 979
    j ++;
  }
#line 987
  bl = 7;
#line 988
  i = huft_build(is, ll, 19U, 19U, (ush const   *)((void *)0), (ush const   *)((void *)0),
                 & tl, & bl);
#line 988
  if (i != 0) {
#line 990
    if (i == 1) {
#line 991
      huft_free(is, tl);
    }
#line 992
    return (i);
  }
#line 996
  n = nl + nd;
#line 997
  m = (unsigned int )mask_bits[bl];
#line 998
  l = 0U;
#line 998
  i = (int )l;
#line 999
  while ((unsigned int )i < n) {
#line 1001
    while (k < (unsigned int )bl) {
#line 1001
      if (is->bs <= 0U) {
#line 1001
        goto cleanup;
      }
#line 1001
      b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 1001
      (is->bs) --;
#line 1001
      (is->bp) ++;
#line 1001
      k += 8U;
    }
#line 1002
    td = tl + ((unsigned int )b & m);
#line 1002
    j = (unsigned int )td->b;
#line 1003
    b >>= j;
#line 1003
    k -= j;
#line 1004
    j = (unsigned int )td->v.n;
#line 1005
    if (j < 16U) {
#line 1006
      tmp = i;
#line 1006
      i ++;
#line 1006
      l = j;
#line 1006
      ll[tmp] = l;
    } else
#line 1007
    if (j == 16U) {
#line 1009
      while (k < 2U) {
#line 1009
        if (is->bs <= 0U) {
#line 1009
          goto cleanup;
        }
#line 1009
        b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 1009
        (is->bs) --;
#line 1009
        (is->bp) ++;
#line 1009
        k += 8U;
      }
#line 1010
      j = 3U + ((unsigned int )b & 3U);
#line 1011
      b >>= 2;
#line 1011
      k -= 2U;
#line 1012
      if ((unsigned int )i + j > n) {
#line 1013
        return (1);
      }
#line 1014
      while (1) {
#line 1014
        tmp___1 = j;
#line 1014
        j --;
#line 1014
        if (! tmp___1) {
#line 1014
          break;
        }
#line 1015
        tmp___0 = i;
#line 1015
        i ++;
#line 1015
        ll[tmp___0] = l;
      }
    } else
#line 1017
    if (j == 17U) {
#line 1019
      while (k < 3U) {
#line 1019
        if (is->bs <= 0U) {
#line 1019
          goto cleanup;
        }
#line 1019
        b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 1019
        (is->bs) --;
#line 1019
        (is->bp) ++;
#line 1019
        k += 8U;
      }
#line 1020
      j = 3U + ((unsigned int )b & 7U);
#line 1021
      b >>= 3;
#line 1021
      k -= 3U;
#line 1022
      if ((unsigned int )i + j > n) {
#line 1023
        return (1);
      }
#line 1024
      while (1) {
#line 1024
        tmp___3 = j;
#line 1024
        j --;
#line 1024
        if (! tmp___3) {
#line 1024
          break;
        }
#line 1025
        tmp___2 = i;
#line 1025
        i ++;
#line 1025
        ll[tmp___2] = 0U;
      }
#line 1026
      l = 0U;
    } else {
#line 1030
      while (k < 7U) {
#line 1030
        if (is->bs <= 0U) {
#line 1030
          goto cleanup;
        }
#line 1030
        b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 1030
        (is->bs) --;
#line 1030
        (is->bp) ++;
#line 1030
        k += 8U;
      }
#line 1031
      j = 11U + ((unsigned int )b & 127U);
#line 1032
      b >>= 7;
#line 1032
      k -= 7U;
#line 1033
      if ((unsigned int )i + j > n) {
#line 1034
        return (1);
      }
#line 1035
      while (1) {
#line 1035
        tmp___5 = j;
#line 1035
        j --;
#line 1035
        if (! tmp___5) {
#line 1035
          break;
        }
#line 1036
        tmp___4 = i;
#line 1036
        i ++;
#line 1036
        ll[tmp___4] = 0U;
      }
#line 1037
      l = 0U;
    }
  }
#line 1042
  huft_free(is, tl);
#line 1044
  goto cleanup_done;
  cleanup: 
#line 1044
  b = is->catch_bb;
#line 1044
  k = is->catch_bk;
#line 1044
  is->bb = b;
#line 1044
  is->bk = k;
#line 1044
  is->bp = is->catch_bp;
#line 1044
  is->bs = is->catch_bs;
#line 1045
  if (tl) {
#line 1045
    huft_free(is, tl);
  }
#line 1046
  return (-1);
  cleanup_done: 
#line 1050
  is->bb = b;
#line 1051
  is->bk = k;
#line 1054
  bl = (int )lbits;
#line 1055
  i = huft_build(is, ll, nl, 257U, cplens, cplext, & tl, & bl);
#line 1055
  if (i != 0) {
#line 1057
    if (i == 1) {
#line 1059
      huft_free(is, tl);
    }
#line 1061
    return (i);
  }
#line 1063
  bd = (int )dbits;
#line 1064
  i = huft_build(is, ll + nl, nd, 0U, cpdist, cpdext, & td, & bd);
#line 1079
  is->tl = tl;
#line 1080
  is->td = td;
#line 1081
  is->bl = bl;
#line 1082
  is->bd = bd;
#line 1084
  return (0);
}
}
#line 1088 "inflate.c"
void *InflateInitialize(void *AppState , int (*putbuffer_ptr)(void *AppState , unsigned char *buffer ,
                                                              long length ) , void *(*malloc_ptr)(long length ) ,
                        void (*free_ptr)(void *buffer ) ) 
{ 
  struct InflateState *is ;
  void *tmp ;

  {
#line 1102
  if (! putbuffer_ptr) {
#line 1102
    return ((void *)0);
  } else
#line 1102
  if (! malloc_ptr) {
#line 1102
    return ((void *)0);
  } else
#line 1102
  if (! free_ptr) {
#line 1102
    return ((void *)0);
  }
#line 1105
  tmp = (*malloc_ptr)((long )sizeof(struct InflateState ));
#line 1105
  is = (struct InflateState *)tmp;
#line 1106
  if (! is) {
#line 1106
    return ((void *)0);
  }
#line 1109
  is->runtimetypeid1 = 2882382797UL;
#line 1110
  is->errorencountered = 0;
#line 1112
  is->bb = (ulg )0;
#line 1113
  is->bk = 0U;
#line 1114
  is->bp = 0U;
#line 1115
  is->bs = 0U;
#line 1117
  is->wp = 0U;
#line 1118
  is->wf = 0U;
#line 1120
  is->state = -1;
#line 1121
  is->lastblock = 0;
#line 1123
  is->AppState = AppState;
#line 1125
  is->putbuffer_ptr = putbuffer_ptr;
#line 1126
  is->malloc_ptr = malloc_ptr;
#line 1127
  is->free_ptr = free_ptr;
#line 1129
  is->runtimetypeid2 = 2882382797UL;
#line 1132
  return ((void *)is);
}
}
#line 1136 "inflate.c"
int InflatePutBuffer(void *InflateState , unsigned char *buffer , long length ) 
{ 
  struct InflateState *is ;
  int beginstate ;
  int size ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int e ;
  unsigned int t ;
  ulg b ;
  unsigned int k ;
  int ret ;
  int ret___0 ;
  int ret___1 ;
  int ret___2 ;
  int ret___3 ;
  int tmp___1 ;

  {
#line 1147
  is = (struct InflateState *)InflateState;
#line 1148
  if (! is) {
#line 1149
    return (1);
  } else
#line 1148
  if (is->runtimetypeid1 != 2882382797UL) {
#line 1149
    return (1);
  } else
#line 1148
  if (is->runtimetypeid2 != 2882382797UL) {
#line 1149
    return (1);
  }
#line 1150
  if (is->errorencountered) {
#line 1150
    return (1);
  }
#line 1152
  while (1) {
#line 1157
    if (is->state == -1) {
#line 1157
      if (is->lastblock) {
#line 1157
        break;
      }
    }
#line 1160
    beginstate = is->state;
#line 1163
    size = (int )(16384U - is->bs);
#line 1164
    if ((long )size > length) {
#line 1164
      size = (int )length;
    }
#line 1165
    i = (int )(is->bp + is->bs);
#line 1167
    while (1) {
#line 1167
      tmp___0 = size;
#line 1167
      size --;
#line 1167
      if (! (tmp___0 > 0)) {
#line 1167
        break;
      }
#line 1169
      tmp = i;
#line 1169
      i ++;
#line 1169
      is->buffer[tmp & 16383] = *buffer;
#line 1170
      (is->bs) ++;
#line 1171
      buffer ++;
#line 1172
      length --;
    }
#line 1176
    if (is->state == -1) {
#line 1185
      b = is->bb;
#line 1186
      k = is->bk;
#line 1188
      is->catch_bb = b;
#line 1188
      is->catch_bk = k;
#line 1188
      is->catch_bp = is->bp;
#line 1188
      is->catch_bs = is->bs;
#line 1191
      while (k < 1U) {
#line 1191
        if (is->bs <= 0U) {
#line 1191
          goto cleanup;
        }
#line 1191
        b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 1191
        (is->bs) --;
#line 1191
        (is->bp) ++;
#line 1191
        k += 8U;
      }
#line 1192
      e = (int )b & 1;
#line 1193
      b >>= 1;
#line 1193
      k --;
#line 1196
      while (k < 2U) {
#line 1196
        if (is->bs <= 0U) {
#line 1196
          goto cleanup;
        }
#line 1196
        b |= (ulg )is->buffer[is->bp & 16383U] << k;
#line 1196
        (is->bs) --;
#line 1196
        (is->bp) ++;
#line 1196
        k += 8U;
      }
#line 1197
      t = (unsigned int )b & 3U;
#line 1198
      b >>= 2;
#line 1198
      k -= 2U;
#line 1200
      if (t <= 2U) {
#line 1202
        is->state = (int )t;
#line 1203
        is->lastblock = e;
      } else {
#line 1207
        is->errorencountered = 1;
#line 1207
        return (1);
      }
#line 1210
      goto cleanup_done;
      cleanup: 
#line 1210
      b = is->catch_bb;
#line 1210
      k = is->catch_bk;
#line 1210
      is->bb = b;
#line 1210
      is->bk = k;
#line 1210
      is->bp = is->catch_bp;
#line 1210
      is->bs = is->catch_bs;
      cleanup_done: 
#line 1214
      is->bb = b;
#line 1215
      is->bk = k;
    } else
#line 1217
    if (is->state == 0) {
#line 1221
      ret = inflate_stored_setup(is);
#line 1223
      if (ret > 0) {
#line 1224
        is->errorencountered = 1;
#line 1224
        return (1);
      }
#line 1226
      if (ret == 0) {
#line 1226
        is->state += 10;
      }
    } else
#line 1228
    if (is->state == 1) {
#line 1232
      ret___0 = inflate_fixed_setup(is);
#line 1234
      if (ret___0 > 0) {
#line 1235
        is->errorencountered = 1;
#line 1235
        return (1);
      }
#line 1237
      if (ret___0 == 0) {
#line 1237
        is->state += 10;
      }
    } else
#line 1239
    if (is->state == 2) {
#line 1243
      ret___1 = inflate_dynamic_setup(is);
#line 1245
      if (ret___1 > 0) {
#line 1246
        is->errorencountered = 1;
#line 1246
        return (1);
      }
#line 1248
      if (ret___1 == 0) {
#line 1248
        is->state += 10;
      }
    } else
#line 1250
    if (is->state == 10) {
#line 1254
      ret___2 = inflate_stored(is);
#line 1256
      if (ret___2 > 0) {
#line 1257
        is->errorencountered = 1;
#line 1257
        return (1);
      }
#line 1259
      if (ret___2 == 0) {
#line 1261
        is->state = -1;
      }
    } else
#line 1264
    if (is->state == 11) {
#line 1264
      goto _L;
    } else
#line 1264
    if (is->state == 12) {
      _L: /* CIL Label */ 
#line 1269
      ret___3 = inflate_codes(is, is->tl, is->td, is->bl, is->bd);
#line 1271
      if (ret___3 > 0) {
#line 1272
        is->errorencountered = 1;
#line 1272
        return (1);
      }
#line 1274
      if (ret___3 == 0) {
#line 1277
        huft_free(is, is->tl);
#line 1278
        huft_free(is, is->td);
#line 1279
        is->state = -1;
      }
    } else {
#line 1284
      is->errorencountered = 1;
#line 1284
      return (1);
    }
#line 1152
    if (! length) {
#line 1152
      if (! (is->state != beginstate)) {
#line 1152
        break;
      }
    }
  }
#line 1289
  if (is->wp > is->wf) {
#line 1289
    goto _L___0;
  } else
#line 1289
  if (is->wp >= 32768U) {
    _L___0: /* CIL Label */ 
#line 1289
    is->wp = is->wp;
#line 1289
    tmp___1 = (*(is->putbuffer_ptr))(is->AppState, is->window + is->wf, (long )(is->wp - is->wf));
#line 1289
    if (tmp___1) {
#line 1289
      is->errorencountered = 1;
#line 1289
      return (1);
    }
#line 1289
    is->wp &= 32767U;
#line 1289
    is->wf = is->wp;
#line 1289
    is->wp = is->wp;
  }
#line 1291
  return (is->errorencountered);
}
}
#line 1295 "inflate.c"
int InflateTerminate(void *InflateState ) 
{ 
  int err ;
  void (*free_ptr)(void *buffer ) ;
  struct InflateState *is ;
  int tmp ;

  {
#line 1305
  is = (struct InflateState *)InflateState;
#line 1306
  if (! is) {
#line 1307
    return (1);
  } else
#line 1306
  if (is->runtimetypeid1 != 2882382797UL) {
#line 1307
    return (1);
  } else
#line 1306
  if (is->runtimetypeid2 != 2882382797UL) {
#line 1307
    return (1);
  }
#line 1310
  if (is->errorencountered) {
#line 1310
    tmp = 1;
  } else
#line 1310
  if (is->bs > 0U) {
#line 1310
    tmp = 1;
  } else
#line 1310
  if (is->state != -1) {
#line 1310
    tmp = 1;
  } else
#line 1310
  if (! is->lastblock) {
#line 1310
    tmp = 1;
  } else {
#line 1310
    tmp = 0;
  }
#line 1310
  err = tmp;
#line 1315
  free_ptr = is->free_ptr;
#line 1318
  (*free_ptr)((void *)is);
#line 1320
  return (err);
}
}
#line 1 "utf8.o"
#pragma merger("0","/tmp/cil-iACMJU2r.i","")
#line 368 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 33 "utf8.c"
static int __wchar_forbitten(wchar_t sym ) ;
#line 34
static int __utf8_forbitten(u_char octet ) ;
#line 36 "utf8.c"
static int __wchar_forbitten(wchar_t sym ) 
{ 


  {
#line 41
  if (sym >= 55296) {
#line 41
    if (sym <= 57343) {
#line 42
      return (-1);
    }
  }
#line 44
  return (0);
}
}
#line 47 "utf8.c"
static int __utf8_forbitten(u_char octet ) 
{ 


  {
#line 51
  switch ((int )octet) {
  case 255: 
  case 245: 
  case 193: 
  case 192: 
#line 56
  return (-1);
  }
#line 59
  return (0);
}
}
#line 88 "utf8.c"
size_t utf8_to_wchar(char const   *in , size_t insize , wchar_t *out , size_t outsize ,
                     int flags ) 
{ 
  u_char *p ;
  u_char *lim ;
  wchar_t *wlim ;
  wchar_t high ;
  size_t n ;
  size_t total ;
  size_t i ;
  size_t n_bits ;
  int tmp ;
  int tmp___0 ;

  {
#line 96
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 97
    return ((size_t )0);
  } else
#line 96
  if (insize == 0UL) {
#line 97
    return ((size_t )0);
  } else
#line 96
  if (outsize == 0UL) {
#line 96
    if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 97
      return ((size_t )0);
    }
  }
#line 99
  total = (size_t )0;
#line 100
  p = (u_char *)in;
#line 101
  lim = p + insize;
#line 102
  wlim = out + outsize;
#line 104
  while ((unsigned long )p < (unsigned long )lim) {
#line 105
    tmp = __utf8_forbitten(*p);
#line 105
    if (tmp != 0) {
#line 105
      if ((flags & 1) == 0) {
#line 107
        return ((size_t )0);
      }
    }
#line 112
    n = (size_t )1;
#line 113
    if (((int )*p & 128) == 0) {
#line 114
      high = (wchar_t )*p;
    } else
#line 115
    if (((int )*p & 224) == 192) {
#line 116
      n = (size_t )2;
#line 117
      high = (int )*p & 31;
    } else
#line 118
    if (((int )*p & 240) == 224) {
#line 119
      n = (size_t )3;
#line 120
      high = (int )*p & 15;
    } else
#line 121
    if (((int )*p & 248) == 240) {
#line 122
      n = (size_t )4;
#line 123
      high = (int )*p & 7;
    } else
#line 124
    if (((int )*p & 252) == 248) {
#line 125
      n = (size_t )5;
#line 126
      high = (int )*p & 3;
    } else
#line 127
    if (((int )*p & 254) == 252) {
#line 128
      n = (size_t )6;
#line 129
      high = (int )*p & 1;
    } else {
#line 131
      if ((flags & 1) == 0) {
#line 132
        return ((size_t )0);
      }
#line 133
      goto __Cont;
    }
#line 137
    if ((size_t )(lim - p) <= n - 1UL) {
#line 138
      if ((flags & 1) == 0) {
#line 139
        return ((size_t )0);
      }
#line 140
      n = (size_t )1;
#line 141
      goto __Cont;
    }
#line 148
    if (n > 1UL) {
#line 149
      i = (size_t )1;
#line 149
      while (i < n) {
#line 150
        if (((int )*(p + i) & 192) != 128) {
#line 151
          break;
        }
#line 149
        i ++;
      }
#line 153
      if (i != n) {
#line 154
        if ((flags & 1) == 0) {
#line 155
          return ((size_t )0);
        }
#line 156
        n = (size_t )1;
#line 157
        goto __Cont;
      }
    }
#line 161
    total ++;
#line 163
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 164
      goto __Cont;
    }
#line 166
    if ((unsigned long )out >= (unsigned long )wlim) {
#line 167
      return ((size_t )0);
    }
#line 169
    *out = 0;
#line 170
    n_bits = (size_t )0;
#line 171
    i = (size_t )1;
#line 171
    while (i < n) {
#line 172
      *out |= ((int )*(p + (n - i)) & 63) << n_bits;
#line 173
      n_bits += 6UL;
#line 171
      i ++;
    }
#line 175
    *out |= high << n_bits;
#line 177
    if (*out == 0) {
#line 178
      break;
    }
#line 180
    tmp___0 = __wchar_forbitten(*out);
#line 180
    if (tmp___0 != 0) {
#line 181
      if ((flags & 1) == 0) {
#line 182
        return ((size_t )0);
      } else {
#line 184
        total --;
#line 185
        out --;
      }
    } else
#line 187
    if (*out == 65279) {
#line 187
      if ((flags & 2) != 0) {
#line 188
        total --;
#line 189
        out --;
      }
    }
#line 192
    out ++;
    __Cont: /* CIL Label */ 
#line 104
    p += n;
  }
#line 195
  return (total);
}
}
#line 218 "utf8.c"
size_t wchar_to_utf8(wchar_t const   *in , size_t insize , char *out , size_t outsize ,
                     int flags ) 
{ 
  wchar_t *w ;
  wchar_t *wlim ;
  wchar_t ch ;
  u_char *p ;
  u_char *lim ;
  u_char *oc ;
  size_t total ;
  size_t n ;
  int tmp ;
  uint32_t tmp___0 ;

  {
#line 226
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 227
    return ((size_t )0);
  } else
#line 226
  if (insize == 0UL) {
#line 227
    return ((size_t )0);
  } else
#line 226
  if (outsize == 0UL) {
#line 226
    if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 227
      return ((size_t )0);
    }
  }
#line 229
  w = (wchar_t *)in;
#line 230
  wlim = w + insize;
#line 231
  p = (u_char *)out;
#line 232
  lim = p + outsize;
#line 233
  total = (size_t )0;
#line 234
  while ((unsigned long )w < (unsigned long )wlim) {
#line 235
    tmp = __wchar_forbitten(*w);
#line 235
    if (tmp != 0) {
#line 236
      if ((flags & 1) == 0) {
#line 237
        return ((size_t )0);
      } else {
#line 239
        goto __Cont;
      }
    }
#line 242
    if (*w == 65279) {
#line 242
      if ((flags & 2) != 0) {
#line 243
        goto __Cont;
      }
    }
#line 245
    if (*w < 0) {
#line 246
      if ((flags & 1) == 0) {
#line 247
        return ((size_t )0);
      }
#line 248
      goto __Cont;
    } else
#line 249
    if (*w <= 127) {
#line 250
      n = (size_t )1;
    } else
#line 251
    if (*w <= 2047) {
#line 252
      n = (size_t )2;
    } else
#line 253
    if (*w <= 65535) {
#line 254
      n = (size_t )3;
    } else
#line 255
    if (*w <= 2097151) {
#line 256
      n = (size_t )4;
    } else
#line 257
    if (*w <= 67108863) {
#line 258
      n = (size_t )5;
    } else {
#line 260
      n = (size_t )6;
    }
#line 262
    total += n;
#line 264
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 265
      goto __Cont;
    }
#line 267
    if ((size_t )(lim - p) <= n - 1UL) {
#line 268
      return ((size_t )0);
    }
#line 271
    tmp___0 = htonl((uint32_t )*w);
#line 271
    ch = (wchar_t )tmp___0;
#line 272
    oc = (u_char *)(& ch);
#line 273
    switch (n) {
    case 1UL: 
#line 275
    *p = *(oc + 3);
#line 276
    break;
    case 2UL: 
#line 279
    *(p + 1) = (u_char )(128 | ((int )*(oc + 3) & 63));
#line 280
    *(p + 0) = (u_char )((192 | ((int )*(oc + 3) >> 6)) | (((int )*(oc + 2) & 7) << 2));
#line 281
    break;
    case 3UL: 
#line 284
    *(p + 2) = (u_char )(128 | ((int )*(oc + 3) & 63));
#line 285
    *(p + 1) = (u_char )((128 | ((int )*(oc + 3) >> 6)) | (((int )*(oc + 2) & 15) << 2));
#line 286
    *(p + 0) = (u_char )(224 | (((int )*(oc + 2) & 240) >> 4));
#line 287
    break;
    case 4UL: 
#line 290
    *(p + 3) = (u_char )(128 | ((int )*(oc + 3) & 63));
#line 291
    *(p + 2) = (u_char )((128 | ((int )*(oc + 3) >> 6)) | (((int )*(oc + 2) & 15) << 2));
#line 292
    *(p + 1) = (u_char )((128 | (((int )*(oc + 2) & 240) >> 4)) | (((int )*(oc + 1) & 3) << 4));
#line 294
    *(p + 0) = (u_char )(240 | (((int )*(oc + 1) & 31) >> 2));
#line 295
    break;
    case 5UL: 
#line 298
    *(p + 4) = (u_char )(128 | ((int )*(oc + 3) & 63));
#line 299
    *(p + 3) = (u_char )((128 | ((int )*(oc + 3) >> 6)) | (((int )*(oc + 2) & 15) << 2));
#line 300
    *(p + 2) = (u_char )((128 | (((int )*(oc + 2) & 240) >> 4)) | (((int )*(oc + 1) & 3) << 4));
#line 302
    *(p + 1) = (u_char )(128 | ((int )*(oc + 1) >> 2));
#line 303
    *(p + 0) = (u_char )(248 | ((int )*(oc + 0) & 3));
#line 304
    break;
    case 6UL: 
#line 307
    *(p + 5) = (u_char )(128 | ((int )*(oc + 3) & 63));
#line 308
    *(p + 4) = (u_char )((128 | ((int )*(oc + 3) >> 6)) | (((int )*(oc + 2) & 15) << 2));
#line 309
    *(p + 3) = (u_char )((128 | ((int )*(oc + 2) >> 4)) | (((int )*(oc + 1) & 3) << 4));
#line 310
    *(p + 2) = (u_char )(128 | ((int )*(oc + 1) >> 2));
#line 311
    *(p + 1) = (u_char )(128 | ((int )*(oc + 0) & 63));
#line 312
    *(p + 0) = (u_char )(252 | (((int )*(oc + 0) & 64) >> 6));
#line 313
    break;
    }
#line 321
    p += n;
    __Cont: /* CIL Label */ 
#line 234
    w ++;
  }
#line 324
  return (total);
}
}
