/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

typedef int __darwin_ct_rune_t;
typedef unsigned long __darwin_size_t;
typedef __darwin_size_t size_t;
struct gki_elem {
   char *key ;
   int idx ;
   struct gki_elem *nxt ;
};
struct __anonstruct_GKI_16 {
   struct gki_elem **table ;
   int primelevel ;
   int nhash ;
   int nkeys ;
};
typedef struct __anonstruct_GKI_16 GKI;
struct msa_struct {
   char **aseq ;
   char **sqname ;
   float *wgt ;
   int alen ;
   int nseq ;
   int flags ;
   int type ;
   char *name ;
   char *desc ;
   char *acc ;
   char *au ;
   char *ss_cons ;
   char *sa_cons ;
   char *rf ;
   char **sqacc ;
   char **sqdesc ;
   char **ss ;
   char **sa ;
   float cutoff[6] ;
   int cutoff_is_set[6] ;
   char **comment ;
   int ncomment ;
   int alloc_ncomment ;
   char **gf_tag ;
   char **gf ;
   int ngf ;
   int alloc_ngf ;
   char **gs_tag ;
   char ***gs ;
   GKI *gs_idx ;
   int ngs ;
   char **gc_tag ;
   char **gc ;
   GKI *gc_idx ;
   int ngc ;
   char **gr_tag ;
   char ***gr ;
   GKI *gr_idx ;
   int ngr ;
   GKI *index ;
   int nseqalloc ;
   int nseqlump ;
   int *sqlen ;
   int *sslen ;
   int *salen ;
   int lastidx ;
};
typedef struct msa_struct MSA;
struct plan7_s {
   char *name ;
   char *acc ;
   char *desc ;
   char *rf ;
   char *cs ;
   char *ca ;
   char *comlog ;
   int nseq ;
   char *ctime ;
   int *map ;
   int checksum ;
   int *tpri ;
   int *mpri ;
   int *ipri ;
   float ga1 ;
   float ga2 ;
   float tc1 ;
   float tc2 ;
   float nc1 ;
   float nc2 ;
   int M ;
   float **t ;
   float **mat ;
   float **ins ;
   float tbd1 ;
   float xt[4][2] ;
   float *begin ;
   float *end ;
   float null[20] ;
   float p1 ;
   int **tsc ;
   int **msc ;
   int **isc ;
   int xsc[4][2] ;
   int *bsc ;
   int *esc ;
   int *tsc_mem ;
   int *msc_mem ;
   int *isc_mem ;
   int *bsc_mem ;
   int *esc_mem ;
   int **dnam ;
   int **dnai ;
   int dna2 ;
   int dna4 ;
   float mu ;
   float lambda ;
   int flags ;
};
struct dpmatrix_s {
   int **xmx ;
   int **mmx ;
   int **imx ;
   int **dmx ;
   void *xmx_mem ;
   void *mmx_mem ;
   void *imx_mem ;
   void *dmx_mem ;
   int maxN ;
   int maxM ;
   int padN ;
   int padM ;
};
struct dpshadow_s {
   char **xtb ;
   char **mtb ;
   char **itb ;
   char **dtb ;
   int *esrc ;
};
struct p7trace_s {
   int tlen ;
   char *statetype ;
   int *nodeidx ;
   int *pos ;
};
struct fancyali_s {
   char *rfline ;
   char *csline ;
   char *model ;
   char *mline ;
   char *aseq ;
   int len ;
   char *query ;
   char *target ;
   int sqfrom ;
   int sqto ;
};
struct hit_s {
   double sortkey ;
   float score ;
   double pvalue ;
   float mothersc ;
   double motherp ;
   char *name ;
   char *acc ;
   char *desc ;
   int sqfrom ;
   int sqto ;
   int sqlen ;
   int hmmfrom ;
   int hmmto ;
   int hmmlen ;
   int domidx ;
   int ndom ;
   struct fancyali_s *ali ;
};
struct tophit_s {
   struct hit_s **hit ;
   struct hit_s *unsrt ;
   int alloc ;
   int num ;
   int lump ;
};
enum __anonenum_autocut_14 {
    CUT_NONE = 0,
    CUT_GA = 1,
    CUT_NC = 2,
    CUT_TC = 3
} ;
struct threshold_s {
   float globT ;
   double globE ;
   float domT ;
   double domE ;
   enum __anonenum_autocut_14 autocut ;
   int Z ;
};
typedef long long __int64_t;
typedef __int64_t __darwin_off_t;
typedef __darwin_off_t fpos_t;
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
struct __sFILEX;
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   void *_cookie ;
   int (*_close)(void * ) ;
   int (*_read)(void * , char * , int  ) ;
   fpos_t (*_seek)(void * , fpos_t  , int  ) ;
   int (*_write)(void * , char const   * , int  ) ;
   struct __sbuf _ub ;
   struct __sFILEX *_extra ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   fpos_t _offset ;
};
typedef struct __sFILE FILE;
struct p7prior_s {
   int strategy ;
   int tnum ;
   float tq[200] ;
   float t[200][7] ;
   int mnum ;
   float mq[200] ;
   float m[200][20] ;
   int inum ;
   float iq[200] ;
   float i[200][20] ;
};
struct histogram_s {
   int *histogram ;
   int min ;
   int max ;
   int highscore ;
   int lowscore ;
   int lumpsize ;
   int total ;
   float *expect ;
   int fit_type ;
   float param[3] ;
   float chisq ;
   float chip ;
};
typedef unsigned int __uint32_t;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
struct __anonstruct__RuneEntry_8 {
   __darwin_rune_t __min ;
   __darwin_rune_t __max ;
   __darwin_rune_t __map ;
   __uint32_t *__types ;
};
typedef struct __anonstruct__RuneEntry_8 _RuneEntry;
struct __anonstruct__RuneRange_9 {
   int __nranges ;
   _RuneEntry *__ranges ;
};
typedef struct __anonstruct__RuneRange_9 _RuneRange;
struct __anonstruct__RuneCharClass_10 {
   char __name[14] ;
   __uint32_t __mask ;
};
typedef struct __anonstruct__RuneCharClass_10 _RuneCharClass;
struct __anonstruct__RuneLocale_11 {
   char __magic[8] ;
   char __encoding[32] ;
   __darwin_rune_t (*__sgetrune)(char const   * , __darwin_size_t  , char const   ** ) ;
   int (*__sputrune)(__darwin_rune_t  , char * , __darwin_size_t  , char ** ) ;
   __darwin_rune_t __invalid_rune ;
   __uint32_t __runetype[1 << 8] ;
   __darwin_rune_t __maplower[1 << 8] ;
   __darwin_rune_t __mapupper[1 << 8] ;
   _RuneRange __runetype_ext ;
   _RuneRange __maplower_ext ;
   _RuneRange __mapupper_ext ;
   void *__variable ;
   int __variable_len ;
   int __ncharclasses ;
   _RuneCharClass *__charclasses ;
};
typedef struct __anonstruct__RuneLocale_11 _RuneLocale;
typedef unsigned short sqd_uint16;
typedef unsigned int sqd_uint32;
typedef unsigned long long sqd_uint64;
union __anonunion_off_17 {
   sqd_uint32 i32 ;
   sqd_uint64 i64 ;
};
struct ssioffset_s {
   char mode ;
   union __anonunion_off_17 off ;
};
typedef struct ssioffset_s SSIOFFSET;
struct ssifile_s {
   FILE *fp ;
   sqd_uint32 flags ;
   sqd_uint16 nfiles ;
   sqd_uint32 nprimary ;
   sqd_uint32 nsecondary ;
   sqd_uint32 flen ;
   sqd_uint32 plen ;
   sqd_uint32 slen ;
   sqd_uint32 frecsize ;
   sqd_uint32 precsize ;
   sqd_uint32 srecsize ;
   SSIOFFSET foffset ;
   SSIOFFSET poffset ;
   SSIOFFSET soffset ;
   char imode ;
   char smode ;
   char **filename ;
   sqd_uint32 *fileformat ;
   sqd_uint32 *fileflags ;
   sqd_uint32 *bpl ;
   sqd_uint32 *rpl ;
};
typedef struct ssifile_s SSIFILE;
struct hmmfile_s {
   FILE *f ;
   SSIFILE *ssi ;
   int (*parser)(struct hmmfile_s * , struct plan7_s ** ) ;
   int is_binary ;
   int byteswap ;
   int is_seekable ;
   int mode ;
   SSIOFFSET offset ;
};
typedef struct hmmfile_s HMMFILE;
struct basic_state {
   float t[3] ;
   float p[20] ;
};
struct plan9_s {
   int M ;
   struct basic_state *ins ;
   struct basic_state *mat ;
   struct basic_state *del ;
   float null[20] ;
   char *name ;
   char *ref ;
   char *cs ;
   float *xray ;
   int flags ;
};
typedef unsigned long __darwin_clock_t;
typedef long __darwin_time_t;
typedef __darwin_clock_t clock_t;
typedef __darwin_time_t time_t;
struct opt_s {
   char *name ;
   int single ;
   int argtype ;
};
struct stopwatch_s {
   time_t t0 ;
   clock_t cpu0 ;
   double elapsed ;
   double user ;
   double sys ;
};
typedef struct stopwatch_s Stopwatch_t;
struct seqinfo_s {
   int flags ;
   char name[64] ;
   char id[64] ;
   char acc[64] ;
   char desc[128] ;
   int len ;
   int start ;
   int stop ;
   int olen ;
   int type ;
   char *ss ;
   char *sa ;
};
typedef struct seqinfo_s SQINFO;
struct msafile_struct {
   FILE *f ;
   char *fname ;
   int linenumber ;
   char *buf ;
   int buflen ;
   SSIFILE *ssi ;
   int do_gzip ;
   int do_stdin ;
   int format ;
};
typedef struct msafile_struct MSAFILE;
struct ReadSeqVars {
   FILE *f ;
   char *fname ;
   int linenumber ;
   char *buf ;
   int buflen ;
   int ssimode ;
   SSIOFFSET ssioffset ;
   SSIOFFSET r_off ;
   SSIOFFSET d_off ;
   int rpl ;
   int lastrpl ;
   int maxrpl ;
   int bpl ;
   int lastbpl ;
   int maxbpl ;
   char *seq ;
   SQINFO *sqinfo ;
   char *sp ;
   int seqlen ;
   int maxseq ;
   int format ;
   int do_gzip ;
   int do_stdin ;
   MSA *msa ;
   MSAFILE *afp ;
};
typedef struct ReadSeqVars SQFILE;
struct aliinfo_s {
   int flags ;
   int alen ;
   int nseq ;
   float *wgt ;
   char *cs ;
   char *rf ;
   struct seqinfo_s *sqinfo ;
   char *name ;
   char *desc ;
   char *acc ;
   char *au ;
   float tc1 ;
   float tc2 ;
   float nc1 ;
   float nc2 ;
   float ga1 ;
   float ga2 ;
};
typedef struct aliinfo_s AINFO;
struct phylo_s {
   int parent ;
   int left ;
   int right ;
   float diff ;
   float lblen ;
   float rblen ;
   char *is_in ;
   int incnum ;
};
enum clust_strategy {
    CLUSTER_MEAN = 0,
    CLUSTER_MAX = 1,
    CLUSTER_MIN = 2
} ;
struct intstack_s {
   int data ;
   struct intstack_s *nxt ;
};
struct gsi_s {
   FILE *gsifp ;
   sqd_uint16 nfiles ;
   sqd_uint32 recnum ;
};
typedef struct gsi_s GSIFILE;
struct gsikey_s {
   char key[32] ;
   sqd_uint16 filenum ;
   sqd_uint32 offset ;
};
struct gsiindex_s {
   char **filenames ;
   int *fmt ;
   sqd_uint16 nfiles ;
   struct gsikey_s *elems ;
   int nkeys ;
};
struct sqd_regexp {
   char *startp[10] ;
   char *endp[10] ;
   char regstart ;
   char reganch ;
   char *regmust ;
   int regmlen ;
   char program[1] ;
};
typedef struct sqd_regexp sqd_regexp;
struct comp {
   char *regparse ;
   int regnpar ;
   char *regcode ;
   char regdummy[3] ;
   long regsize ;
};
struct exec {
   char *reginput ;
   char *regbol ;
   char **regstartp ;
   char **regendp ;
};
struct iupactype {
   char sym ;
   char symcomp ;
   char code ;
   char comp ;
};
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char *tm_zone ;
};
typedef unsigned long Hashseq;
struct block_struc {
   int lcol ;
   int rcol ;
};
typedef __builtin_va_list __darwin_va_list;
typedef __darwin_va_list va_list;
struct ssipkey_s {
   char *key ;
   sqd_uint16 fnum ;
   SSIOFFSET r_off ;
   SSIOFFSET d_off ;
   sqd_uint32 len ;
};
struct ssiskey_s {
   char *key ;
   char *pkey ;
};
struct ssiindex_s {
   int smode ;
   int imode ;
   int external ;
   int max_ram ;
   char **filenames ;
   sqd_uint32 *fileformat ;
   sqd_uint32 *bpl ;
   sqd_uint32 *rpl ;
   sqd_uint32 flen ;
   sqd_uint16 nfiles ;
   struct ssipkey_s *pkeys ;
   sqd_uint32 plen ;
   sqd_uint32 nprimary ;
   char *ptmpfile ;
   FILE *ptmp ;
   struct ssiskey_s *skeys ;
   sqd_uint32 slen ;
   sqd_uint32 nsecondary ;
   char *stmpfile ;
   FILE *stmp ;
};
typedef struct ssiindex_s SSIINDEX;
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-0BuztYMs.i","-O3")
extern char *strchr(char const   * , int  ) ;
extern size_t strlen(char const   * ) ;
__inline static void *__inline_memset_chk(void *__dest , int __val , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memset_chk(__dest, __val, __len, tmp);
  return (tmp___0);
}
}
__inline static char *__inline_strcpy_chk(char *__dest , char const   *__src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcpy_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
extern __darwin_ct_rune_t __toupper(__darwin_ct_rune_t  ) ;
__inline static int toupper(int _c ) 
{ 
  __darwin_ct_rune_t tmp ;

  {
  tmp = __toupper(_c);
  return (tmp);
}
}
char *stdcode1[65] ;
void Die(char *format  , ...) ;
void Warn(char *format  , ...) ;
int Seqtype(char *seq ) ;
void *sre_malloc(char *file , int line , size_t size ) ;
char Alphabet[25] ;
int Alphabet_type ;
int Alphabet_size ;
int Alphabet_iupac ;
char Degenerate[24][20] ;
int DegenCount[24] ;
void DetermineAlphabet(char **rseqs , int nseq ) ;
void SetAlphabet(int type ) ;
int SymbolIndex(char sym ) ;
char *DigitizeSequence(char *seq , int L ) ;
char *DedigitizeSequence(char *dsq , int L ) ;
void DigitizeAlignment(MSA *msa , char ***ret_dsqs ) ;
void P7CountSymbol(float *counters , char symidx , float wt ) ;
void DefaultGeneticCode(int *aacode ) ;
void DefaultCodonBias(float *codebias ) ;
static void set_degenerate(char iupac___0 , char *syms ) ;
void DetermineAlphabet(char **rseqs , int nseq ) 
{ 
  int idx ;
  int other ;
  int nucleic ;
  int amino ;
  int type ;
  int tmp ;

  {
  type = 0;
  amino = 0;
  nucleic = amino;
  other = nucleic;
  idx = 0;
  while (idx < nseq) {
    tmp = Seqtype(*(rseqs + idx));
    switch (tmp) {
    case 2: 
    nucleic ++;
    break;
    case 1: 
    nucleic ++;
    break;
    case 3: 
    amino ++;
    break;
    case 0: 
    other ++;
    break;
    default: 
    Die((char *)"No such alphabet type");
    }
    idx ++;
  }
  if (nucleic == nseq) {
    type = 2;
  } else
  if (amino == nseq) {
    type = 3;
  } else
  if (nucleic > amino) {
    if (nucleic > other) {
      Warn((char *)"Looks like nucleic acid sequence, hope that\'s right");
      type = 2;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (amino > nucleic) {
    if (amino > other) {
      Warn((char *)"Looks like amino acid sequence, hope that\'s right");
      type = 3;
    } else {
      Die((char *)"Sorry, I can\'t tell if that\'s protein or DNA");
    }
  } else {
    Die((char *)"Sorry, I can\'t tell if that\'s protein or DNA");
  }
  SetAlphabet(type);
  return;
}
}
void SetAlphabet(int type ) 
{ 
  int x ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;

  {
  if (Alphabet_type != 0) {
    if (type != Alphabet_type) {
      Die((char *)"An alphabet type conflict occurred.\nYou probably mixed a DNA seq file with a protein model, or vice versa.");
    }
    return;
  }
  switch (type) {
  case 3: 
  Alphabet_type = type;
  tmp___0 = __builtin_object_size((void *)(Alphabet), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(Alphabet), 1);
    __builtin___strcpy_chk(Alphabet, "ACDEFGHIKLMNPQRSTVWYUBZX", tmp);
  } else {
    __inline_strcpy_chk(Alphabet, "ACDEFGHIKLMNPQRSTVWYUBZX");
  }
  Alphabet_size = 20;
  Alphabet_iupac = 24;
  x = 0;
  while (x < Alphabet_iupac) {
    tmp___2 = __builtin_object_size((void *)(Degenerate[x]), 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)(Degenerate[x]), 0);
      __builtin___memset_chk((void *)(Degenerate[x]), 0, (unsigned long )Alphabet_size,
                             tmp___1);
    } else {
      __inline_memset_chk((void *)(Degenerate[x]), 0, (size_t )Alphabet_size);
    }
    x ++;
  }
  x = 0;
  while (x < Alphabet_size) {
    Degenerate[x][x] = (char)1;
    DegenCount[x] = 1;
    x ++;
  }
  set_degenerate((char )'U', (char *)"S");
  set_degenerate((char )'B', (char *)"ND");
  set_degenerate((char )'Z', (char *)"QE");
  set_degenerate((char )'X', (char *)"ACDEFGHIKLMNPQRSTVWY");
  break;
  case 2: 
  Alphabet_type = type;
  tmp___4 = __builtin_object_size((void *)(Alphabet), 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___3 = __builtin_object_size((void *)(Alphabet), 1);
    __builtin___strcpy_chk(Alphabet, "ACGTUNRYMKSWHBVDX", tmp___3);
  } else {
    __inline_strcpy_chk(Alphabet, "ACGTUNRYMKSWHBVDX");
  }
  Alphabet_size = 4;
  Alphabet_iupac = 17;
  x = 0;
  while (x < Alphabet_iupac) {
    tmp___6 = __builtin_object_size((void *)(Degenerate[x]), 0);
    if (tmp___6 != 0xffffffffffffffffUL) {
      tmp___5 = __builtin_object_size((void *)(Degenerate[x]), 0);
      __builtin___memset_chk((void *)(Degenerate[x]), 0, (unsigned long )Alphabet_size,
                             tmp___5);
    } else {
      __inline_memset_chk((void *)(Degenerate[x]), 0, (size_t )Alphabet_size);
    }
    x ++;
  }
  x = 0;
  while (x < Alphabet_size) {
    Degenerate[x][x] = (char)1;
    DegenCount[x] = 1;
    x ++;
  }
  set_degenerate((char )'U', (char *)"T");
  set_degenerate((char )'N', (char *)"ACGT");
  set_degenerate((char )'X', (char *)"ACGT");
  set_degenerate((char )'R', (char *)"AG");
  set_degenerate((char )'Y', (char *)"CT");
  set_degenerate((char )'M', (char *)"AC");
  set_degenerate((char )'K', (char *)"GT");
  set_degenerate((char )'S', (char *)"CG");
  set_degenerate((char )'W', (char *)"AT");
  set_degenerate((char )'H', (char *)"ACT");
  set_degenerate((char )'B', (char *)"CGT");
  set_degenerate((char )'V', (char *)"ACG");
  set_degenerate((char )'D', (char *)"AGT");
  break;
  default: 
  Die((char *)"No support for non-nucleic or protein alphabets");
  }
  return;
}
}
int SymbolIndex(char sym ) 
{ 
  char *s___0 ;
  long tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = toupper((int )sym);
  s___0 = strchr((char const   *)(Alphabet), (int )((char )tmp___1));
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    tmp___0 = (long )(Alphabet_iupac - 1);
  } else {
    tmp___0 = s___0 - Alphabet;
  }
  return ((int )tmp___0);
}
}
char *DigitizeSequence(char *seq , int L ) 
{ 
  char *dsq ;
  int i___0 ;
  void *tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  tmp = sre_malloc((char *)"alphabet.c", 215, sizeof(char ) * (unsigned long )(L + 2));
  dsq = (char *)tmp;
  tmp___0 = (char )Alphabet_iupac;
  *(dsq + (L + 1)) = tmp___0;
  *(dsq + 0) = tmp___0;
  i___0 = 1;
  while (i___0 <= L) {
    tmp___1 = SymbolIndex(*(seq + (i___0 - 1)));
    *(dsq + i___0) = (char )tmp___1;
    i___0 ++;
  }
  return (dsq);
}
}
char *DedigitizeSequence(char *dsq , int L ) 
{ 
  char *seq ;
  int i___0 ;
  void *tmp ;

  {
  tmp = sre_malloc((char *)"alphabet.c", 235, sizeof(char ) * (unsigned long )(L + 1));
  seq = (char *)tmp;
  i___0 = 0;
  while (i___0 < L) {
    *(seq + i___0) = Alphabet[(int )*(dsq + (i___0 + 1))];
    i___0 ++;
  }
  *(seq + L) = (char )'\000';
  return (seq);
}
}
void DigitizeAlignment(MSA *msa , char ***ret_dsqs ) 
{ 
  char **dsq ;
  int idx ;
  int dpos ;
  int apos ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = sre_malloc((char *)"alphabet.c", 264, sizeof(char *) * (unsigned long )msa->nseq);
  dsq = (char **)tmp;
  idx = 0;
  while (idx < msa->nseq) {
    tmp___0 = sre_malloc((char *)"alphabet.c", 266, sizeof(char ) * (unsigned long )(msa->alen + 2));
    *(dsq + idx) = (char *)tmp___0;
    *(*(dsq + idx) + 0) = (char )Alphabet_iupac;
    apos = 0;
    dpos = 1;
    while (apos < msa->alen) {
      if (! ((int )*(*(msa->aseq + idx) + apos) == 32)) {
        if (! ((int )*(*(msa->aseq + idx) + apos) == 46)) {
          if (! ((int )*(*(msa->aseq + idx) + apos) == 95)) {
            if (! ((int )*(*(msa->aseq + idx) + apos) == 45)) {
              if (! ((int )*(*(msa->aseq + idx) + apos) == 126)) {
                tmp___1 = dpos;
                dpos ++;
                tmp___2 = SymbolIndex(*(*(msa->aseq + idx) + apos));
                *(*(dsq + idx) + tmp___1) = (char )tmp___2;
              }
            }
          }
        }
      }
      apos ++;
    }
    *(*(dsq + idx) + dpos) = (char )Alphabet_iupac;
    idx ++;
  }
  *ret_dsqs = dsq;
  return;
}
}
void P7CountSymbol(float *counters , char symidx , float wt ) 
{ 
  int x ;

  {
  if ((int )symidx < Alphabet_size) {
    *(counters + (int )symidx) += wt;
  } else {
    x = 0;
    while (x < Alphabet_size) {
      if (Degenerate[(int )symidx][x]) {
        *(counters + x) += wt / (float )DegenCount[(int )symidx];
      }
      x ++;
    }
  }
  return;
}
}
void DefaultGeneticCode(int *aacode ) 
{ 
  int x ;
  char *tmp ;

  {
  x = 0;
  while (x < 64) {
    if ((int )*(stdcode1[x]) == 42) {
      *(aacode + x) = -1;
    } else {
      tmp = strchr((char const   *)(Alphabet), (int )*(stdcode1[x]));
      *(aacode + x) = (int )(tmp - Alphabet);
    }
    x ++;
  }
  return;
}
}
void DefaultCodonBias(float *codebias ) 
{ 


  {
  *(codebias + 0) = (float )(1. / 2.);
  *(codebias + 1) = (float )(1. / 2.);
  *(codebias + 2) = (float )(1. / 2.);
  *(codebias + 3) = (float )(1. / 2.);
  *(codebias + 4) = (float )(1. / 4.);
  *(codebias + 5) = (float )(1. / 4.);
  *(codebias + 6) = (float )(1. / 4.);
  *(codebias + 7) = (float )(1. / 4.);
  *(codebias + 8) = (float )(1. / 6.);
  *(codebias + 9) = (float )(1. / 6.);
  *(codebias + 10) = (float )(1. / 6.);
  *(codebias + 11) = (float )(1. / 6.);
  *(codebias + 12) = (float )(1. / 3.);
  *(codebias + 13) = (float )(1. / 3.);
  *(codebias + 14) = (float )1.;
  *(codebias + 15) = (float )(1. / 3.);
  *(codebias + 16) = (float )(1. / 2.);
  *(codebias + 17) = (float )(1. / 2.);
  *(codebias + 18) = (float )(1. / 2.);
  *(codebias + 19) = (float )(1. / 2.);
  *(codebias + 20) = (float )(1. / 4.);
  *(codebias + 21) = (float )(1. / 4.);
  *(codebias + 22) = (float )(1. / 4.);
  *(codebias + 23) = (float )(1. / 4.);
  *(codebias + 24) = (float )(1. / 6.);
  *(codebias + 25) = (float )(1. / 6.);
  *(codebias + 26) = (float )(1. / 6.);
  *(codebias + 27) = (float )(1. / 6.);
  *(codebias + 28) = (float )(1. / 6.);
  *(codebias + 29) = (float )(1. / 6.);
  *(codebias + 30) = (float )(1. / 6.);
  *(codebias + 31) = (float )(1. / 6.);
  *(codebias + 32) = (float )(1. / 2.);
  *(codebias + 33) = (float )(1. / 2.);
  *(codebias + 34) = (float )(1. / 2.);
  *(codebias + 35) = (float )(1. / 2.);
  *(codebias + 36) = (float )(1. / 4.);
  *(codebias + 37) = (float )(1. / 4.);
  *(codebias + 38) = (float )(1. / 4.);
  *(codebias + 39) = (float )(1. / 4.);
  *(codebias + 40) = (float )(1. / 4.);
  *(codebias + 41) = (float )(1. / 4.);
  *(codebias + 42) = (float )(1. / 4.);
  *(codebias + 43) = (float )(1. / 4.);
  *(codebias + 44) = (float )(1. / 4.);
  *(codebias + 45) = (float )(1. / 4.);
  *(codebias + 46) = (float )(1. / 4.);
  *(codebias + 47) = (float )(1. / 4.);
  *(codebias + 48) = (float )0.;
  *(codebias + 49) = (float )(1. / 2.);
  *(codebias + 50) = (float )0.;
  *(codebias + 51) = (float )(1. / 2.);
  *(codebias + 52) = (float )(1. / 6.);
  *(codebias + 53) = (float )(1. / 6.);
  *(codebias + 54) = (float )(1. / 6.);
  *(codebias + 55) = (float )(1. / 6.);
  *(codebias + 56) = (float )0.;
  *(codebias + 57) = (float )(1. / 2.);
  *(codebias + 58) = (float )1.;
  *(codebias + 59) = (float )(1. / 2.);
  *(codebias + 60) = (float )(1. / 6.);
  *(codebias + 61) = (float )(1. / 2.);
  *(codebias + 62) = (float )(1. / 6.);
  *(codebias + 63) = (float )(1. / 2.);
  return;
}
}
static void set_degenerate(char iupac___0 , char *syms ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  tmp = strchr((char const   *)(Alphabet), (int )iupac___0);
  tmp___0 = strlen((char const   *)syms);
  DegenCount[tmp - Alphabet] = (int )tmp___0;
  while (*syms) {
    tmp___1 = strchr((char const   *)(Alphabet), (int )iupac___0);
    tmp___2 = strchr((char const   *)(Alphabet), (int )*syms);
    Degenerate[tmp___1 - Alphabet][tmp___2 - Alphabet] = (char)1;
    syms ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-YyT9Iiln.i","-O3")
extern double log(double  ) ;
extern void free(void * ) ;
void *sre_realloc(char *file , int line , void *p , size_t size ) ;
void FSet(float *vec , int n , float value ) ;
void FScale(float *vec , int n , float scale ) ;
float FSum(float *vec , int n ) ;
int FArgMax(float *vec , int n ) ;
struct dpmatrix_s *CreatePlan7Matrix(int N , int M , int padN , int padM ) ;
void ResizePlan7Matrix(struct dpmatrix_s *mx , int N , int M , int ***xmx , int ***mmx ,
                       int ***imx , int ***dmx ) ;
struct dpmatrix_s *AllocPlan7Matrix(int rows , int M , int ***xmx , int ***mmx , int ***imx ,
                                    int ***dmx ) ;
struct dpshadow_s *AllocShadowMatrix(int rows , int M , char ***xtb , char ***mtb ,
                                     char ***itb , char ***dtb ) ;
void FreePlan7Matrix(struct dpmatrix_s *mx ) ;
void FreeShadowMatrix(struct dpshadow_s *tb ) ;
int P7ViterbiSize(int L , int M ) ;
int P7SmallViterbiSize(int L , int M ) ;
int P7WeeViterbiSize(int L , int M ) ;
float P7Forward(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) ;
float P7Viterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ,
                struct p7trace_s **ret_tr ) ;
void P7ViterbiTrace(struct plan7_s *hmm , char *dsq , int N , struct dpmatrix_s *mx ,
                    struct p7trace_s **ret_tr ) ;
float P7SmallViterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ,
                     struct p7trace_s **ret_tr ) ;
float P7ParsingViterbi(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) ;
float P7WeeViterbi(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) ;
float Plan7ESTViterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) ;
struct p7trace_s *P7ViterbiAlignAlignment(MSA *msa , struct plan7_s *hmm ) ;
struct p7trace_s *ShadowTrace(struct dpshadow_s *tb , struct plan7_s *hmm , int L ) ;
float PostprocessSignificantHit(struct tophit_s *ghit , struct tophit_s *dhit , struct p7trace_s *tr ,
                                struct plan7_s *hmm , char *dsq , int L , char *seqname ,
                                char *seqacc , char *seqdesc , int do_forward , float sc_override ,
                                int do_null2 , struct threshold_s *thresh___0 , int hmmpfam_mode ) ;
char *Statetype(char st ) ;
float TraceScoreCorrection(struct plan7_s *hmm , struct p7trace_s *tr , char *dsq ) ;
int Prob2Score(float p , float null ) ;
float Scorify(int sc ) ;
double PValue(struct plan7_s *hmm , float sc ) ;
int ILogsum(int p1 , int p2 ) ;
void RegisterHit(struct tophit_s *h___0 , double key , double pvalue , float score ,
                 double motherp , float mothersc , char *name , char *acc , char *desc ,
                 int sqfrom , int sqto , int sqlen , int hmmfrom , int hmmto , int hmmlen ,
                 int domidx , int ndom , struct fancyali_s *ali ) ;
void P7AllocTrace(int tlen , struct p7trace_s **ret_tr ) ;
void P7ReallocTrace(struct p7trace_s *tr , int tlen ) ;
void P7FreeTrace(struct p7trace_s *tr ) ;
void P7ReverseTrace(struct p7trace_s *tr ) ;
float P7TraceScore(struct plan7_s *hmm , char *dsq , struct p7trace_s *tr ) ;
struct fancyali_s *CreateFancyAli(struct p7trace_s *tr , struct plan7_s *hmm , char *dsq ,
                                  char *name ) ;
void TraceDecompose(struct p7trace_s *otr , struct p7trace_s ***ret_tr , int *ret_ntr ) ;
void TraceSimpleBounds(struct p7trace_s *tr , int *ret_i1 , int *ret_i2 , int *ret_k1 ,
                       int *ret_k2 ) ;
static float get_wee_midpt(struct plan7_s *hmm , char *dsq , int L , int k1 , char t1 ,
                           int s1 , int k3 , char t3 , int s3 , int *ret_k2 , char *ret_t2 ,
                           int *ret_s2 ) ;
struct dpmatrix_s *CreatePlan7Matrix(int N , int M , int padN , int padM ) 
{ 
  struct dpmatrix_s *mx ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  tmp = sre_malloc((char *)"core_algorithms.c", 66, sizeof(struct dpmatrix_s ));
  mx = (struct dpmatrix_s *)tmp;
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 67, sizeof(int *) * (unsigned long )(N + 1));
  mx->xmx = (int **)tmp___0;
  tmp___1 = sre_malloc((char *)"core_algorithms.c", 68, sizeof(int *) * (unsigned long )(N + 1));
  mx->mmx = (int **)tmp___1;
  tmp___2 = sre_malloc((char *)"core_algorithms.c", 69, sizeof(int *) * (unsigned long )(N + 1));
  mx->imx = (int **)tmp___2;
  tmp___3 = sre_malloc((char *)"core_algorithms.c", 70, sizeof(int *) * (unsigned long )(N + 1));
  mx->dmx = (int **)tmp___3;
  tmp___4 = sre_malloc((char *)"core_algorithms.c", 71, sizeof(int ) * (unsigned long )((N + 1) * 5));
  mx->xmx_mem = tmp___4;
  tmp___5 = sre_malloc((char *)"core_algorithms.c", 72, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
  mx->mmx_mem = tmp___5;
  tmp___6 = sre_malloc((char *)"core_algorithms.c", 73, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
  mx->imx_mem = tmp___6;
  tmp___7 = sre_malloc((char *)"core_algorithms.c", 74, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
  mx->dmx_mem = tmp___7;
  *(mx->xmx + 0) = (int *)mx->xmx_mem;
  *(mx->mmx + 0) = (int *)mx->mmx_mem;
  *(mx->imx + 0) = (int *)mx->imx_mem;
  *(mx->dmx + 0) = (int *)mx->dmx_mem;
  i___0 = 1;
  while (i___0 <= N) {
    *(mx->xmx + i___0) = *(mx->xmx + 0) + i___0 * 5;
    *(mx->mmx + i___0) = *(mx->mmx + 0) + i___0 * (M + 2);
    *(mx->imx + i___0) = *(mx->imx + 0) + i___0 * (M + 2);
    *(mx->dmx + i___0) = *(mx->dmx + 0) + i___0 * (M + 2);
    i___0 ++;
  }
  if (padM > 0) {
    if (padN > 0) {
      Die((char *)"there\'s trouble with RAMLIMIT if you grow in both M and N.");
    }
  }
  mx->maxN = N;
  mx->maxM = M;
  mx->padN = padN;
  mx->padM = padM;
  return (mx);
}
}
void ResizePlan7Matrix(struct dpmatrix_s *mx , int N , int M , int ***xmx , int ***mmx ,
                       int ***imx , int ***dmx ) 
{ 
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  if (N <= mx->maxN) {
    if (M <= mx->maxM) {
      goto DONE;
    }
  }
  if (N > mx->maxN) {
    N += mx->padN;
    mx->maxN = N;
    tmp = sre_realloc((char *)"core_algorithms.c", 133, (void *)mx->xmx, sizeof(int *) * (unsigned long )(N + 1));
    mx->xmx = (int **)tmp;
    tmp___0 = sre_realloc((char *)"core_algorithms.c", 134, (void *)mx->mmx, sizeof(int *) * (unsigned long )(N + 1));
    mx->mmx = (int **)tmp___0;
    tmp___1 = sre_realloc((char *)"core_algorithms.c", 135, (void *)mx->imx, sizeof(int *) * (unsigned long )(N + 1));
    mx->imx = (int **)tmp___1;
    tmp___2 = sre_realloc((char *)"core_algorithms.c", 136, (void *)mx->dmx, sizeof(int *) * (unsigned long )(N + 1));
    mx->dmx = (int **)tmp___2;
  }
  if (M > mx->maxM) {
    M += mx->padM;
    mx->maxM = M;
  }
  tmp___3 = sre_realloc((char *)"core_algorithms.c", 144, mx->xmx_mem, sizeof(int ) * (unsigned long )((N + 1) * 5));
  mx->xmx_mem = tmp___3;
  tmp___4 = sre_realloc((char *)"core_algorithms.c", 145, mx->mmx_mem, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
  mx->mmx_mem = tmp___4;
  tmp___5 = sre_realloc((char *)"core_algorithms.c", 146, mx->imx_mem, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
  mx->imx_mem = tmp___5;
  tmp___6 = sre_realloc((char *)"core_algorithms.c", 147, mx->dmx_mem, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
  mx->dmx_mem = tmp___6;
  *(mx->xmx + 0) = (int *)mx->xmx_mem;
  *(mx->mmx + 0) = (int *)mx->mmx_mem;
  *(mx->imx + 0) = (int *)mx->imx_mem;
  *(mx->dmx + 0) = (int *)mx->dmx_mem;
  i___0 = 1;
  while (i___0 <= N) {
    *(mx->xmx + i___0) = *(mx->xmx + 0) + i___0 * 5;
    *(mx->mmx + i___0) = *(mx->mmx + 0) + i___0 * (M + 2);
    *(mx->imx + i___0) = *(mx->imx + 0) + i___0 * (M + 2);
    *(mx->dmx + i___0) = *(mx->dmx + 0) + i___0 * (M + 2);
    i___0 ++;
  }
  DONE: 
  if ((unsigned long )xmx != (unsigned long )((void *)0)) {
    *xmx = mx->xmx;
  }
  if ((unsigned long )mmx != (unsigned long )((void *)0)) {
    *mmx = mx->mmx;
  }
  if ((unsigned long )imx != (unsigned long )((void *)0)) {
    *imx = mx->imx;
  }
  if ((unsigned long )dmx != (unsigned long )((void *)0)) {
    *dmx = mx->dmx;
  }
  return;
}
}
struct dpmatrix_s *AllocPlan7Matrix(int rows , int M , int ***xmx , int ***mmx , int ***imx ,
                                    int ***dmx ) 
{ 
  struct dpmatrix_s *mx ;

  {
  mx = CreatePlan7Matrix(rows - 1, M, 0, 0);
  if ((unsigned long )xmx != (unsigned long )((void *)0)) {
    *xmx = mx->xmx;
  }
  if ((unsigned long )mmx != (unsigned long )((void *)0)) {
    *mmx = mx->mmx;
  }
  if ((unsigned long )imx != (unsigned long )((void *)0)) {
    *imx = mx->imx;
  }
  if ((unsigned long )dmx != (unsigned long )((void *)0)) {
    *dmx = mx->dmx;
  }
  return (mx);
}
}
void FreePlan7Matrix(struct dpmatrix_s *mx ) 
{ 


  {
  free(mx->xmx_mem);
  free(mx->mmx_mem);
  free(mx->imx_mem);
  free(mx->dmx_mem);
  free((void *)mx->xmx);
  free((void *)mx->mmx);
  free((void *)mx->imx);
  free((void *)mx->dmx);
  free((void *)mx);
  return;
}
}
struct dpshadow_s *AllocShadowMatrix(int rows , int M , char ***xtb , char ***mtb ,
                                     char ***itb , char ***dtb ) 
{ 
  struct dpshadow_s *tb ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  tmp = sre_malloc((char *)"core_algorithms.c", 244, sizeof(struct dpshadow_s ));
  tb = (struct dpshadow_s *)tmp;
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 245, sizeof(char *) * (unsigned long )rows);
  tb->xtb = (char **)tmp___0;
  tmp___1 = sre_malloc((char *)"core_algorithms.c", 246, sizeof(char *) * (unsigned long )rows);
  tb->mtb = (char **)tmp___1;
  tmp___2 = sre_malloc((char *)"core_algorithms.c", 247, sizeof(char *) * (unsigned long )rows);
  tb->itb = (char **)tmp___2;
  tmp___3 = sre_malloc((char *)"core_algorithms.c", 248, sizeof(char *) * (unsigned long )rows);
  tb->dtb = (char **)tmp___3;
  tmp___4 = sre_malloc((char *)"core_algorithms.c", 249, sizeof(int ) * (unsigned long )rows);
  tb->esrc = (int *)tmp___4;
  tmp___5 = sre_malloc((char *)"core_algorithms.c", 250, sizeof(char ) * (unsigned long )(rows * 5));
  *(tb->xtb + 0) = (char *)tmp___5;
  tmp___6 = sre_malloc((char *)"core_algorithms.c", 251, sizeof(char ) * (unsigned long )(rows * (M + 2)));
  *(tb->mtb + 0) = (char *)tmp___6;
  tmp___7 = sre_malloc((char *)"core_algorithms.c", 252, sizeof(char ) * (unsigned long )(rows * (M + 2)));
  *(tb->itb + 0) = (char *)tmp___7;
  tmp___8 = sre_malloc((char *)"core_algorithms.c", 253, sizeof(char ) * (unsigned long )(rows * (M + 2)));
  *(tb->dtb + 0) = (char *)tmp___8;
  i___0 = 1;
  while (i___0 < rows) {
    *(tb->xtb + i___0) = *(tb->xtb + 0) + i___0 * 5;
    *(tb->mtb + i___0) = *(tb->mtb + 0) + i___0 * (M + 2);
    *(tb->itb + i___0) = *(tb->itb + 0) + i___0 * (M + 2);
    *(tb->dtb + i___0) = *(tb->dtb + 0) + i___0 * (M + 2);
    i___0 ++;
  }
  if ((unsigned long )xtb != (unsigned long )((void *)0)) {
    *xtb = tb->xtb;
  }
  if ((unsigned long )mtb != (unsigned long )((void *)0)) {
    *mtb = tb->mtb;
  }
  if ((unsigned long )itb != (unsigned long )((void *)0)) {
    *itb = tb->itb;
  }
  if ((unsigned long )dtb != (unsigned long )((void *)0)) {
    *dtb = tb->dtb;
  }
  return (tb);
}
}
void FreeShadowMatrix(struct dpshadow_s *tb ) 
{ 


  {
  free((void *)*(tb->xtb + 0));
  free((void *)*(tb->mtb + 0));
  free((void *)*(tb->itb + 0));
  free((void *)*(tb->dtb + 0));
  free((void *)tb->esrc);
  free((void *)tb->xtb);
  free((void *)tb->mtb);
  free((void *)tb->itb);
  free((void *)tb->dtb);
  free((void *)tb);
  return;
}
}
int P7ViterbiSize(int L , int M ) 
{ 
  float Mbytes ;

  {
  Mbytes = (float )sizeof(struct dpmatrix_s );
  Mbytes = (float )((double )Mbytes + ((3. * (double )((float )(L + 1))) * (double )((float )(M + 2))) * (double )((float )sizeof(int )));
  Mbytes = (float )((double )Mbytes + (4. * (double )((float )(L + 1))) * (double )((float )sizeof(int *)));
  Mbytes = (float )((double )Mbytes + (5. * (double )((float )(L + 1))) * (double )((float )sizeof(int )));
  Mbytes = (float )((double )Mbytes / 1048576.);
  return ((int )Mbytes);
}
}
int P7SmallViterbiSize(int L , int M ) 
{ 


  {
  return ((int )(((((2UL * sizeof(struct dpmatrix_s ) + (unsigned long )(12 * (M + 2)) * sizeof(int )) + 16UL * sizeof(int *)) + 20UL * sizeof(int )) + (unsigned long )(2 * (L + 1)) * sizeof(int )) / 1000000UL));
}
}
int P7WeeViterbiSize(int L , int M ) 
{ 


  {
  return ((int )(((((((2UL * sizeof(struct dpmatrix_s ) + (unsigned long )(12 * (M + 2)) * sizeof(int )) + 16UL * sizeof(int *)) + 20UL * sizeof(int )) + (unsigned long )(2 * (L + 2)) * sizeof(int )) + (unsigned long )(L + 2) * sizeof(int )) + (unsigned long )(L + 2) * sizeof(char )) / 1000000UL));
}
}
float P7Forward(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) 
{ 
  struct dpmatrix_s *mx ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int i___0 ;
  int k ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  float tmp___9 ;

  {
  mx = AllocPlan7Matrix(L + 1, hmm->M, & xmx, & mmx, & imx, & dmx);
  *(*(xmx + 0) + 4) = 0;
  *(*(xmx + 0) + 0) = hmm->xsc[0][0];
  tmp___0 = -987654321;
  *(*(xmx + 0) + 3) = tmp___0;
  tmp = tmp___0;
  *(*(xmx + 0) + 2) = tmp;
  *(*(xmx + 0) + 1) = tmp;
  k = 0;
  while (k <= hmm->M) {
    tmp___2 = -987654321;
    *(*(dmx + 0) + k) = tmp___2;
    tmp___1 = tmp___2;
    *(*(imx + 0) + k) = tmp___1;
    *(*(mmx + 0) + k) = tmp___1;
    k ++;
  }
  i___0 = 1;
  while (i___0 <= L) {
    tmp___4 = -987654321;
    *(*(dmx + i___0) + 0) = tmp___4;
    tmp___3 = tmp___4;
    *(*(imx + i___0) + 0) = tmp___3;
    *(*(mmx + i___0) + 0) = tmp___3;
    k = 1;
    while (k < hmm->M) {
      tmp___5 = ILogsum(*(*(xmx + (i___0 - 1)) + 0) + *(hmm->bsc + k), *(*(dmx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1)));
      tmp___6 = ILogsum(*(*(mmx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1)),
                        *(*(imx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1)));
      *(*(mmx + i___0) + k) = ILogsum(tmp___6, tmp___5);
      *(*(mmx + i___0) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
      *(*(dmx + i___0) + k) = ILogsum(*(*(mmx + i___0) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1)),
                                      *(*(dmx + i___0) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1)));
      *(*(imx + i___0) + k) = ILogsum(*(*(mmx + (i___0 - 1)) + k) + *(*(hmm->tsc + 1) + k),
                                      *(*(imx + (i___0 - 1)) + k) + *(*(hmm->tsc + 4) + k));
      *(*(imx + i___0) + k) += *(*(hmm->isc + (int )*(dsq + i___0)) + k);
      k ++;
    }
    tmp___7 = ILogsum(*(*(xmx + (i___0 - 1)) + 0) + *(hmm->bsc + (hmm->M - 1)), *(*(dmx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 5) + (hmm->M - 1)));
    tmp___8 = ILogsum(*(*(mmx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 0) + (hmm->M - 1)),
                      *(*(imx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 3) + (hmm->M - 1)));
    *(*(mmx + i___0) + hmm->M) = ILogsum(tmp___8, tmp___7);
    *(*(mmx + i___0) + hmm->M) += *(*(hmm->msc + (int )*(dsq + i___0)) + hmm->M);
    *(*(xmx + i___0) + 4) = *(*(xmx + (i___0 - 1)) + 4) + hmm->xsc[0][1];
    *(*(xmx + i___0) + 1) = -987654321;
    k = 1;
    while (k <= hmm->M) {
      *(*(xmx + i___0) + 1) = ILogsum(*(*(xmx + i___0) + 1), *(*(mmx + i___0) + k) + *(hmm->esc + k));
      k ++;
    }
    *(*(xmx + i___0) + 3) = ILogsum(*(*(xmx + (i___0 - 1)) + 3) + hmm->xsc[3][1],
                                    *(*(xmx + i___0) + 1) + hmm->xsc[1][1]);
    *(*(xmx + i___0) + 0) = ILogsum(*(*(xmx + i___0) + 4) + hmm->xsc[0][0], *(*(xmx + i___0) + 3) + hmm->xsc[3][0]);
    *(*(xmx + i___0) + 2) = ILogsum(*(*(xmx + (i___0 - 1)) + 2) + hmm->xsc[2][1],
                                    *(*(xmx + i___0) + 1) + hmm->xsc[1][0]);
    i___0 ++;
  }
  sc = *(*(xmx + L) + 2) + hmm->xsc[2][0];
  if ((unsigned long )ret_mx != (unsigned long )((void *)0)) {
    *ret_mx = mx;
  } else {
    FreePlan7Matrix(mx);
  }
  tmp___9 = Scorify(sc);
  return (tmp___9);
}
}
void P7ViterbiTrace(struct plan7_s *hmm , char *dsq , int N , struct dpmatrix_s *mx ,
                    struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  int curralloc ;
  int tpos ;
  int i___0 ;
  int k ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int dk ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  curralloc = N * 2 + 6;
  P7AllocTrace(curralloc, & tr);
  xmx = mx->xmx;
  mmx = mx->mmx;
  imx = mx->imx;
  dmx = mx->dmx;
  *(tr->statetype + 0) = (char)9;
  *(tr->nodeidx + 0) = 0;
  *(tr->pos + 0) = 0;
  *(tr->statetype + 1) = (char)8;
  *(tr->nodeidx + 1) = 0;
  *(tr->pos + 1) = 0;
  tpos = 2;
  i___0 = N;
  while ((int )*(tr->statetype + (tpos - 1)) != 4) {
    switch ((int )*(tr->statetype + (tpos - 1))) {
    case 1: 
    sc = *(*(mmx + (i___0 + 1)) + (k + 1)) - *(*(hmm->msc + (int )*(dsq + (i___0 + 1))) + (k + 1));
    if (sc <= -987654321) {
      P7FreeTrace(tr);
      *ret_tr = (struct p7trace_s *)((void *)0);
      return;
    } else
    if (sc == *(*(xmx + i___0) + 0) + *(hmm->bsc + (k + 1))) {
      tmp___0 = Prob2Score(*(hmm->begin + (k + 1)), hmm->p1);
      if ((double )tmp___0 + (double )1 * 1000.0 <= (double )*(hmm->bsc + (k + 1))) {
        while (k > 0) {
          *(tr->statetype + tpos) = (char)2;
          tmp = k;
          k --;
          *(tr->nodeidx + tpos) = tmp;
          *(tr->pos + tpos) = 0;
          tpos ++;
          if (tpos == curralloc) {
            curralloc += N;
            P7ReallocTrace(tr, curralloc);
          }
        }
      }
      *(tr->statetype + tpos) = (char)6;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
    } else
    if (sc == *(*(mmx + i___0) + k) + *(*(hmm->tsc + 0) + k)) {
      *(tr->statetype + tpos) = (char)1;
      tmp___1 = k;
      k --;
      *(tr->nodeidx + tpos) = tmp___1;
      tmp___2 = i___0;
      i___0 --;
      *(tr->pos + tpos) = tmp___2;
    } else
    if (sc == *(*(imx + i___0) + k) + *(*(hmm->tsc + 3) + k)) {
      *(tr->statetype + tpos) = (char)3;
      *(tr->nodeidx + tpos) = k;
      tmp___3 = i___0;
      i___0 --;
      *(tr->pos + tpos) = tmp___3;
    } else
    if (sc == *(*(dmx + i___0) + k) + *(*(hmm->tsc + 5) + k)) {
      *(tr->statetype + tpos) = (char)2;
      tmp___4 = k;
      k --;
      *(tr->nodeidx + tpos) = tmp___4;
      *(tr->pos + tpos) = 0;
    } else {
      Die((char *)"traceback failed");
    }
    break;
    case 2: 
    if (*(*(dmx + i___0) + (k + 1)) <= -987654321) {
      P7FreeTrace(tr);
      *ret_tr = (struct p7trace_s *)((void *)0);
      return;
    } else
    if (*(*(dmx + i___0) + (k + 1)) == *(*(mmx + i___0) + k) + *(*(hmm->tsc + 2) + k)) {
      *(tr->statetype + tpos) = (char)1;
      tmp___5 = k;
      k --;
      *(tr->nodeidx + tpos) = tmp___5;
      tmp___6 = i___0;
      i___0 --;
      *(tr->pos + tpos) = tmp___6;
    } else
    if (*(*(dmx + i___0) + (k + 1)) == *(*(dmx + i___0) + k) + *(*(hmm->tsc + 6) + k)) {
      *(tr->statetype + tpos) = (char)2;
      tmp___7 = k;
      k --;
      *(tr->nodeidx + tpos) = tmp___7;
      *(tr->pos + tpos) = 0;
    } else {
      Die((char *)"traceback failed");
    }
    break;
    case 3: 
    sc = *(*(imx + (i___0 + 1)) + k) - *(*(hmm->isc + (int )*(dsq + (i___0 + 1))) + k);
    if (sc <= -987654321) {
      P7FreeTrace(tr);
      *ret_tr = (struct p7trace_s *)((void *)0);
      return;
    } else
    if (sc == *(*(mmx + i___0) + k) + *(*(hmm->tsc + 1) + k)) {
      *(tr->statetype + tpos) = (char)1;
      tmp___8 = k;
      k --;
      *(tr->nodeidx + tpos) = tmp___8;
      tmp___9 = i___0;
      i___0 --;
      *(tr->pos + tpos) = tmp___9;
    } else
    if (sc == *(*(imx + i___0) + k) + *(*(hmm->tsc + 4) + k)) {
      *(tr->statetype + tpos) = (char)3;
      *(tr->nodeidx + tpos) = k;
      tmp___10 = i___0;
      i___0 --;
      *(tr->pos + tpos) = tmp___10;
    } else {
      Die((char *)"traceback failed");
    }
    break;
    case 5: 
    if (i___0 == 0) {
      if (*(*(xmx + i___0) + 4) == 0) {
        *(tr->statetype + tpos) = (char)4;
        *(tr->nodeidx + tpos) = 0;
        *(tr->pos + tpos) = 0;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (i___0 > 0) {
      if (*(*(xmx + (i___0 + 1)) + 4) == *(*(xmx + i___0) + 4) + hmm->xsc[0][1]) {
        *(tr->statetype + tpos) = (char)5;
        *(tr->nodeidx + tpos) = 0;
        *(tr->pos + tpos) = 0;
        tmp___11 = i___0;
        i___0 --;
        *(tr->pos + (tpos - 1)) = tmp___11;
      } else {
        Die((char *)"traceback failed");
      }
    } else {
      Die((char *)"traceback failed");
    }
    break;
    case 6: 
    if (*(*(xmx + i___0) + 0) <= -987654321) {
      P7FreeTrace(tr);
      *ret_tr = (struct p7trace_s *)((void *)0);
      return;
    } else
    if (*(*(xmx + i___0) + 0) == *(*(xmx + i___0) + 4) + hmm->xsc[0][0]) {
      *(tr->statetype + tpos) = (char)5;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
    } else
    if (*(*(xmx + i___0) + 0) == *(*(xmx + i___0) + 3) + hmm->xsc[3][0]) {
      *(tr->statetype + tpos) = (char)10;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
    } else {
      Die((char *)"traceback failed");
    }
    break;
    case 7: 
    if (*(*(xmx + i___0) + 1) <= -987654321) {
      P7FreeTrace(tr);
      *ret_tr = (struct p7trace_s *)((void *)0);
      return;
    }
    k = hmm->M;
    while (k >= 1) {
      if (*(*(xmx + i___0) + 1) == *(*(mmx + i___0) + k) + *(hmm->esc + k)) {
        tmp___12 = Prob2Score(*(hmm->end + k), (float )1.);
        if ((double )tmp___12 + (double )1 * 1000.0 <= (double )*(hmm->esc + k)) {
          dk = hmm->M;
          while (dk > k) {
            *(tr->statetype + tpos) = (char)2;
            *(tr->nodeidx + tpos) = dk;
            *(tr->pos + tpos) = 0;
            tpos ++;
            if (tpos == curralloc) {
              curralloc += N;
              P7ReallocTrace(tr, curralloc);
            }
            dk --;
          }
        }
        *(tr->statetype + tpos) = (char)1;
        tmp___13 = k;
        k --;
        *(tr->nodeidx + tpos) = tmp___13;
        tmp___14 = i___0;
        i___0 --;
        *(tr->pos + tpos) = tmp___14;
        break;
      }
      k --;
    }
    if (k < 0) {
      Die((char *)"traceback failed");
    }
    break;
    case 8: 
    if (*(*(xmx + i___0) + 2) <= -987654321) {
      P7FreeTrace(tr);
      *ret_tr = (struct p7trace_s *)((void *)0);
      return;
    } else
    if (*(*(xmx + i___0) + 2) == *(*(xmx + (i___0 - 1)) + 2) + hmm->xsc[2][1]) {
      *(tr->statetype + tpos) = (char)8;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
      tmp___15 = i___0;
      i___0 --;
      *(tr->pos + (tpos - 1)) = tmp___15;
    } else
    if (*(*(xmx + i___0) + 2) == *(*(xmx + i___0) + 1) + hmm->xsc[1][0]) {
      *(tr->statetype + tpos) = (char)7;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
    } else {
      Die((char *)"Traceback failed.");
    }
    break;
    case 10: 
    if (*(*(xmx + i___0) + 3) <= -987654321) {
      P7FreeTrace(tr);
      *ret_tr = (struct p7trace_s *)((void *)0);
      return;
    } else
    if (*(*(xmx + i___0) + 3) == *(*(xmx + (i___0 - 1)) + 3) + hmm->xsc[3][1]) {
      *(tr->statetype + tpos) = (char)10;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
      tmp___16 = i___0;
      i___0 --;
      *(tr->pos + (tpos - 1)) = tmp___16;
    } else
    if (*(*(xmx + i___0) + 3) == *(*(xmx + i___0) + 1) + hmm->xsc[1][1]) {
      *(tr->statetype + tpos) = (char)7;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
    } else {
      Die((char *)"Traceback failed.");
    }
    break;
    default: 
    Die((char *)"traceback failed");
    }
    tpos ++;
    if (tpos == curralloc) {
      curralloc += N;
      P7ReallocTrace(tr, curralloc);
    }
  }
  tr->tlen = tpos;
  P7ReverseTrace(tr);
  *ret_tr = tr;
  return;
}
}
float P7SmallViterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ,
                     struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *ctr ;
  struct p7trace_s *tr ;
  struct p7trace_s **tarr ;
  int ndom ;
  int i___0 ;
  int pos ;
  int tpos ;
  int tlen ;
  int sqlen ;
  int totlen ;
  float sc ;
  int t2 ;
  void *tmp ;
  int tmp___0 ;

  {
  sc = P7ParsingViterbi(dsq, L, hmm, & ctr);
  if ((unsigned long )ctr == (unsigned long )((void *)0)) {
    P7FreeTrace(ctr);
    return (sc);
  } else
  if ((unsigned long )ret_tr == (unsigned long )((void *)0)) {
    P7FreeTrace(ctr);
    return (sc);
  }
  ndom = ctr->tlen / 2 - 1;
  tmp = sre_malloc((char *)"core_algorithms.c", 930, sizeof(struct p7trace_s *) * (unsigned long )ndom);
  tarr = (struct p7trace_s **)tmp;
  totlen = 0;
  tlen = totlen;
  i___0 = 0;
  while (i___0 < ndom) {
    sqlen = *(ctr->pos + (i___0 * 2 + 2)) - *(ctr->pos + (i___0 * 2 + 1));
    tmp___0 = P7ViterbiSize(sqlen, hmm->M);
    if (tmp___0 > 1000) {
      P7WeeViterbi(dsq + *(ctr->pos + (i___0 * 2 + 1)), sqlen, hmm, tarr + i___0);
    } else {
      P7Viterbi(dsq + *(ctr->pos + (i___0 * 2 + 1)), sqlen, hmm, mx, tarr + i___0);
    }
    tlen += (*(tarr + i___0))->tlen - 4;
    totlen += sqlen;
    i___0 ++;
  }
  tlen += (4 + (ndom - 1)) + (L - totlen);
  P7AllocTrace(tlen, & tr);
  tr->tlen = tlen;
  *(tr->statetype + 0) = (char)4;
  *(tr->nodeidx + 0) = 0;
  *(tr->pos + 0) = 0;
  *(tr->statetype + 1) = (char)5;
  *(tr->nodeidx + 1) = 0;
  *(tr->pos + 1) = 0;
  tpos = 2;
  pos = 1;
  while (pos <= *(ctr->pos + 1)) {
    *(tr->statetype + tpos) = (char)5;
    *(tr->nodeidx + tpos) = 0;
    *(tr->pos + tpos) = pos;
    tpos ++;
    pos ++;
  }
  i___0 = 0;
  while (i___0 < ndom) {
    t2 = 2;
    while (t2 < (*(tarr + i___0))->tlen - 2) {
      *(tr->statetype + tpos) = *((*(tarr + i___0))->statetype + t2);
      *(tr->nodeidx + tpos) = *((*(tarr + i___0))->nodeidx + t2);
      if (*((*(tarr + i___0))->pos + t2) > 0) {
        *(tr->pos + tpos) = *((*(tarr + i___0))->pos + t2) + *(ctr->pos + (i___0 * 2 + 1));
      } else {
        *(tr->pos + tpos) = 0;
      }
      tpos ++;
      t2 ++;
    }
    if (i___0 == ndom - 1) {
      *(tr->statetype + tpos) = (char)8;
    } else {
      *(tr->statetype + tpos) = (char)10;
    }
    *(tr->nodeidx + tpos) = 0;
    *(tr->pos + tpos) = 0;
    tpos ++;
    if (i___0 != ndom - 1) {
      pos = *(ctr->pos + (i___0 * 2 + 2)) + 1;
      while (pos <= *(ctr->pos + ((i___0 + 1) * 2 + 1))) {
        *(tr->statetype + tpos) = (char)10;
        *(tr->nodeidx + tpos) = 0;
        *(tr->pos + tpos) = pos;
        tpos ++;
        pos ++;
      }
    }
    i___0 ++;
  }
  pos = *(ctr->pos + ndom * 2) + 1;
  while (pos <= L) {
    *(tr->statetype + tpos) = (char)8;
    *(tr->nodeidx + tpos) = 0;
    *(tr->pos + tpos) = pos;
    tpos ++;
    pos ++;
  }
  *(tr->statetype + tpos) = (char)9;
  *(tr->nodeidx + tpos) = 0;
  *(tr->pos + tpos) = 0;
  tpos ++;
  i___0 = 0;
  while (i___0 < ndom) {
    P7FreeTrace(*(tarr + i___0));
    i___0 ++;
  }
  free((void *)tarr);
  P7FreeTrace(ctr);
  *ret_tr = tr;
  return (sc);
}
}
float P7ParsingViterbi(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) 
{ 
  struct dpmatrix_s *mx ;
  struct dpmatrix_s *tmx ;
  struct p7trace_s *tr ;
  int **xmx ;
  int **mmx ;
  int **dmx ;
  int **imx ;
  int **xtr ;
  int **mtr ;
  int **dtr ;
  int **itr ;
  int *btr ;
  int *etr ;
  int sc ;
  int i___0 ;
  int k ;
  int tpos ;
  int cur ;
  int prv ;
  int curralloc ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  float tmp___7 ;

  {
  mx = AllocPlan7Matrix(2, hmm->M, & xmx, & mmx, & imx, & dmx);
  tmx = AllocPlan7Matrix(2, hmm->M, & xtr, & mtr, & itr, & dtr);
  tmp = sre_malloc((char *)"core_algorithms.c", 1083, sizeof(int ) * (unsigned long )(L + 1));
  btr = (int *)tmp;
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 1084, sizeof(int ) * (unsigned long )(L + 1));
  etr = (int *)tmp___0;
  *(*(xmx + 0) + 4) = 0;
  *(*(xmx + 0) + 0) = hmm->xsc[0][0];
  *(btr + 0) = 0;
  tmp___2 = -987654321;
  *(*(xmx + 0) + 3) = tmp___2;
  tmp___1 = tmp___2;
  *(*(xmx + 0) + 2) = tmp___1;
  *(*(xmx + 0) + 1) = tmp___1;
  *(etr + 0) = -1;
  k = 0;
  while (k <= hmm->M) {
    tmp___4 = -987654321;
    *(*(dmx + 0) + k) = tmp___4;
    tmp___3 = tmp___4;
    *(*(imx + 0) + k) = tmp___3;
    *(*(mmx + 0) + k) = tmp___3;
    k ++;
  }
  i___0 = 1;
  while (i___0 <= L) {
    cur = i___0 % 2;
    prv = ! cur;
    tmp___6 = -987654321;
    *(*(dmx + cur) + 0) = tmp___6;
    tmp___5 = tmp___6;
    *(*(imx + cur) + 0) = tmp___5;
    *(*(mmx + cur) + 0) = tmp___5;
    k = 1;
    while (k <= hmm->M) {
      *(*(mmx + cur) + k) = -987654321;
      sc = *(*(mmx + prv) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1));
      if (sc > -987654321) {
        *(*(mmx + cur) + k) = sc;
        *(*(mtr + cur) + k) = *(*(mtr + prv) + (k - 1));
      }
      sc = *(*(imx + prv) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1));
      if (sc > *(*(mmx + cur) + k)) {
        *(*(mmx + cur) + k) = sc;
        *(*(mtr + cur) + k) = *(*(itr + prv) + (k - 1));
      }
      sc = *(*(xmx + prv) + 0) + *(hmm->bsc + k);
      if (sc > *(*(mmx + cur) + k)) {
        *(*(mmx + cur) + k) = sc;
        *(*(mtr + cur) + k) = i___0 - 1;
      }
      sc = *(*(dmx + prv) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1));
      if (sc > *(*(mmx + cur) + k)) {
        *(*(mmx + cur) + k) = sc;
        *(*(mtr + cur) + k) = *(*(dtr + prv) + (k - 1));
      }
      if (*(*(hmm->msc + (int )*(dsq + i___0)) + k) != -987654321) {
        *(*(mmx + cur) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
      } else {
        *(*(mmx + cur) + k) = -987654321;
      }
      *(*(dmx + cur) + k) = -987654321;
      sc = *(*(mmx + cur) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1));
      if (sc > -987654321) {
        *(*(dmx + cur) + k) = sc;
        *(*(dtr + cur) + k) = *(*(mtr + cur) + (k - 1));
      }
      sc = *(*(dmx + cur) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1));
      if (sc > *(*(dmx + cur) + k)) {
        *(*(dmx + cur) + k) = sc;
        *(*(dtr + cur) + k) = *(*(dtr + cur) + (k - 1));
      }
      if (k < hmm->M) {
        *(*(imx + cur) + k) = -987654321;
        sc = *(*(mmx + prv) + k) + *(*(hmm->tsc + 1) + k);
        if (sc > -987654321) {
          *(*(imx + cur) + k) = sc;
          *(*(itr + cur) + k) = *(*(mtr + prv) + k);
        }
        sc = *(*(imx + prv) + k) + *(*(hmm->tsc + 4) + k);
        if (sc > *(*(imx + cur) + k)) {
          *(*(imx + cur) + k) = sc;
          *(*(itr + cur) + k) = *(*(itr + prv) + k);
        }
        if (*(*(hmm->isc + (int )*(dsq + i___0)) + k) != -987654321) {
          *(*(imx + cur) + k) += *(*(hmm->isc + (int )*(dsq + i___0)) + k);
        } else {
          *(*(imx + cur) + k) = -987654321;
        }
      }
      k ++;
    }
    *(*(xmx + cur) + 4) = -987654321;
    sc = *(*(xmx + prv) + 4) + hmm->xsc[0][1];
    if (sc > -987654321) {
      *(*(xmx + cur) + 4) = sc;
    }
    *(*(xmx + cur) + 1) = -987654321;
    k = 1;
    while (k <= hmm->M) {
      sc = *(*(mmx + cur) + k) + *(hmm->esc + k);
      if (sc > *(*(xmx + cur) + 1)) {
        *(*(xmx + cur) + 1) = sc;
        *(etr + i___0) = *(*(mtr + cur) + k);
      }
      k ++;
    }
    *(*(xmx + cur) + 3) = -987654321;
    sc = *(*(xmx + prv) + 3) + hmm->xsc[3][1];
    if (sc > -987654321) {
      *(*(xmx + cur) + 3) = sc;
      *(*(xtr + cur) + 3) = *(*(xtr + prv) + 3);
    }
    sc = *(*(xmx + cur) + 1) + hmm->xsc[1][1];
    if (sc > *(*(xmx + cur) + 3)) {
      *(*(xmx + cur) + 3) = sc;
      *(*(xtr + cur) + 3) = i___0;
    }
    *(*(xmx + cur) + 0) = -987654321;
    sc = *(*(xmx + cur) + 4) + hmm->xsc[0][0];
    if (sc > -987654321) {
      *(*(xmx + cur) + 0) = sc;
      *(btr + i___0) = 0;
    }
    sc = *(*(xmx + cur) + 3) + hmm->xsc[3][0];
    if (sc > *(*(xmx + cur) + 0)) {
      *(*(xmx + cur) + 0) = sc;
      *(btr + i___0) = *(*(xtr + cur) + 3);
    }
    *(*(xmx + cur) + 2) = -987654321;
    sc = *(*(xmx + prv) + 2) + hmm->xsc[2][1];
    if (sc > -987654321) {
      *(*(xmx + cur) + 2) = sc;
      *(*(xtr + cur) + 2) = *(*(xtr + prv) + 2);
    }
    sc = *(*(xmx + cur) + 1) + hmm->xsc[1][0];
    if (sc > *(*(xmx + cur) + 2)) {
      *(*(xmx + cur) + 2) = sc;
      *(*(xtr + cur) + 2) = i___0;
    }
    i___0 ++;
  }
  sc = *(*(xmx + cur) + 2) + hmm->xsc[2][0];
  curralloc = 2;
  P7AllocTrace(curralloc, & tr);
  tpos = 0;
  *(tr->statetype + tpos) = (char)9;
  *(tr->pos + tpos) = 0;
  i___0 = *(*(xtr + L % 2) + 2);
  while (i___0 > 0) {
    curralloc += 2;
    P7ReallocTrace(tr, curralloc);
    tpos ++;
    *(tr->statetype + tpos) = (char)7;
    *(tr->pos + tpos) = i___0;
    i___0 = *(etr + i___0);
    tpos ++;
    *(tr->statetype + tpos) = (char)6;
    *(tr->pos + tpos) = i___0;
    i___0 = *(btr + i___0);
  }
  tpos ++;
  *(tr->statetype + tpos) = (char)4;
  *(tr->pos + tpos) = 0;
  tr->tlen = tpos + 1;
  P7ReverseTrace(tr);
  FreePlan7Matrix(mx);
  FreePlan7Matrix(tmx);
  free((void *)btr);
  free((void *)etr);
  *ret_tr = tr;
  tmp___7 = Scorify(sc);
  return (tmp___7);
}
}
float P7WeeViterbi(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  int *kassign ;
  char *tassign ;
  int *endlist ;
  int *startlist ;
  int lpos ;
  int k1 ;
  int k2 ;
  int k3 ;
  char t1 ;
  char t2 ;
  char t3 ;
  int s1 ;
  int s2 ;
  int s3 ;
  float sc ;
  float ret_sc ;
  int tlen ;
  int i___0 ;
  int k ;
  int tpos ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  tmp = sre_malloc((char *)"core_algorithms.c", 1282, sizeof(int ) * (unsigned long )(L + 1));
  kassign = (int *)tmp;
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 1283, sizeof(char ) * (unsigned long )(L + 1));
  tassign = (char *)tmp___0;
  tmp___1 = sre_malloc((char *)"core_algorithms.c", 1284, sizeof(int ) * (unsigned long )(L + 1));
  endlist = (int *)tmp___1;
  tmp___2 = sre_malloc((char *)"core_algorithms.c", 1285, sizeof(int ) * (unsigned long )(L + 1));
  startlist = (int *)tmp___2;
  lpos = 0;
  *(startlist + lpos) = 1;
  *(endlist + lpos) = L;
  *(kassign + 1) = 1;
  *(kassign + L) = hmm->M;
  *(tassign + 1) = (char)4;
  *(tassign + L) = (char)9;
  while (lpos >= 0) {
    s1 = *(startlist + lpos);
    k1 = *(kassign + s1);
    t1 = *(tassign + s1);
    s3 = *(endlist + lpos);
    k3 = *(kassign + s3);
    t3 = *(tassign + s3);
    lpos --;
    sc = get_wee_midpt(hmm, dsq, L, k1, t1, s1, k3, t3, s3, & k2, & t2, & s2);
    *(kassign + s2) = k2;
    *(tassign + s2) = t2;
    if ((int )t1 == 4) {
      if ((int )t3 == 9) {
        ret_sc = sc;
      }
    }
    if ((int )t2 != 5) {
      if (s2 - s1 > 1) {
        lpos ++;
        *(startlist + lpos) = s1;
        *(endlist + lpos) = s2;
      } else
      if (s2 - s1 == 1) {
        if ((int )t1 == 4) {
          lpos ++;
          *(startlist + lpos) = s1;
          *(endlist + lpos) = s2;
        }
      }
    }
    if ((int )t2 != 8) {
      if (s3 - s2 > 1) {
        lpos ++;
        *(startlist + lpos) = s2;
        *(endlist + lpos) = s3;
      } else
      if (s3 - s2 == 1) {
        if ((int )t3 == 9) {
          lpos ++;
          *(startlist + lpos) = s2;
          *(endlist + lpos) = s3;
        }
      }
    }
    if ((int )t2 == 5) {
      while (s2 >= s1) {
        *(kassign + s2) = 1;
        *(tassign + s2) = (char)5;
        s2 --;
      }
    }
    if ((int )t2 == 8) {
      while (s2 <= s3) {
        *(kassign + s2) = hmm->M;
        *(tassign + s2) = (char)8;
        s2 ++;
      }
    }
  }
  tlen = L + 6;
  i___0 = 1;
  while (i___0 < L) {
    if ((int )*(tassign + i___0) == 1) {
      if ((int )*(tassign + (i___0 + 1)) == 1) {
        tlen += (*(kassign + (i___0 + 1)) - *(kassign + i___0)) - 1;
      }
    }
    if ((int )*(tassign + i___0) == 5) {
      if ((int )*(tassign + (i___0 + 1)) == 1) {
        tlen += *(kassign + (i___0 + 1)) - 1;
      }
    }
    if ((int )*(tassign + i___0) == 1) {
      if ((int )*(tassign + (i___0 + 1)) == 8) {
        tlen += hmm->M - *(kassign + i___0);
      }
    }
    i___0 ++;
  }
  if ((int )*(tassign + 1) == 1) {
    tlen += *(kassign + 1) - 1;
  }
  if ((int )*(tassign + L) == 1) {
    tlen += hmm->M - *(kassign + L);
  }
  P7AllocTrace(tlen, & tr);
  *(tr->statetype + 0) = (char)4;
  *(tr->nodeidx + 0) = 0;
  *(tr->pos + 0) = 0;
  *(tr->statetype + 1) = (char)5;
  *(tr->nodeidx + 1) = 0;
  *(tr->pos + 1) = 0;
  tpos = 2;
  i___0 = 1;
  while (i___0 <= L) {
    switch ((int )*(tassign + i___0)) {
    case 1: 
    if ((int )*(tr->statetype + (tpos - 1)) == 5) {
      *(tr->statetype + tpos) = (char)6;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
      tpos ++;
      tmp___3 = Prob2Score(*(hmm->begin + *(kassign + i___0)), hmm->p1);
      if ((double )tmp___3 + 1000.0 <= (double )*(hmm->bsc + *(kassign + i___0))) {
        k = 1;
        while (k < *(kassign + i___0)) {
          *(tr->statetype + tpos) = (char)2;
          *(tr->nodeidx + tpos) = k;
          *(tr->pos + tpos) = 0;
          tpos ++;
          k ++;
        }
      }
    }
    *(tr->statetype + tpos) = (char)1;
    *(tr->nodeidx + tpos) = *(kassign + i___0);
    *(tr->pos + tpos) = i___0;
    tpos ++;
    if (i___0 < L) {
      if ((int )*(tassign + (i___0 + 1)) == 1) {
        if (*(kassign + (i___0 + 1)) - *(kassign + i___0) > 1) {
          k = *(kassign + i___0) + 1;
          while (k < *(kassign + (i___0 + 1))) {
            *(tr->statetype + tpos) = (char)2;
            *(tr->nodeidx + tpos) = k;
            *(tr->pos + tpos) = 0;
            tpos ++;
            k ++;
          }
        }
      }
    }
    if (i___0 == L) {
      goto _L;
    } else
    if ((int )*(tassign + (i___0 + 1)) == 8) {
      _L: /* CIL Label */ 
      tmp___4 = Prob2Score(*(hmm->end + *(kassign + (i___0 - 1))), (float )1.);
      if ((double )tmp___4 + 1000.0 <= (double )*(hmm->esc + *(kassign + (i___0 - 1)))) {
        k = *(kassign + i___0) + 1;
        while (k <= hmm->M) {
          *(tr->statetype + tpos) = (char)2;
          *(tr->nodeidx + tpos) = k;
          *(tr->pos + tpos) = 0;
          tpos ++;
          k ++;
        }
      }
      *(tr->statetype + tpos) = (char)7;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
      tpos ++;
      *(tr->statetype + tpos) = (char)8;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
      tpos ++;
    }
    break;
    case 3: 
    *(tr->statetype + tpos) = (char)3;
    *(tr->nodeidx + tpos) = *(kassign + i___0);
    *(tr->pos + tpos) = i___0;
    tpos ++;
    break;
    case 5: 
    *(tr->statetype + tpos) = (char)5;
    *(tr->nodeidx + tpos) = 0;
    *(tr->pos + tpos) = i___0;
    tpos ++;
    break;
    case 8: 
    *(tr->statetype + tpos) = (char)8;
    *(tr->nodeidx + tpos) = 0;
    *(tr->pos + tpos) = i___0;
    tpos ++;
    break;
    default: 
    tmp___5 = Statetype(*(tassign + i___0));
    Die((char *)"Bogus state %s", tmp___5);
    }
    i___0 ++;
  }
  *(tr->statetype + tpos) = (char)9;
  *(tr->nodeidx + tpos) = 0;
  *(tr->pos + tpos) = 0;
  tr->tlen = tpos + 1;
  *ret_tr = tr;
  free((void *)kassign);
  free((void *)tassign);
  free((void *)startlist);
  free((void *)endlist);
  return (ret_sc);
}
}
float Plan7ESTViterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) 
{ 
  struct dpmatrix_s *mx ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int i___0 ;
  int k ;
  int sc ;
  int codon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  float tmp___9 ;

  {
  mx = AllocPlan7Matrix(L + 1, hmm->M, & xmx, & mmx, & imx, & dmx);
  *(*(xmx + 0) + 4) = 0;
  *(*(xmx + 0) + 0) = hmm->xsc[0][0];
  tmp___0 = -987654321;
  *(*(xmx + 0) + 3) = tmp___0;
  tmp = tmp___0;
  *(*(xmx + 0) + 2) = tmp;
  *(*(xmx + 0) + 1) = tmp;
  k = 0;
  while (k <= hmm->M) {
    tmp___2 = -987654321;
    *(*(dmx + 0) + k) = tmp___2;
    tmp___1 = tmp___2;
    *(*(imx + 0) + k) = tmp___1;
    *(*(mmx + 0) + k) = tmp___1;
    k ++;
  }
  *(*(xmx + 1) + 4) = *(*(xmx + 0) + 4) + hmm->xsc[0][1];
  *(*(xmx + 1) + 0) = *(*(xmx + 1) + 4) + hmm->xsc[0][0];
  tmp___4 = -987654321;
  *(*(xmx + 0) + 3) = tmp___4;
  tmp___3 = tmp___4;
  *(*(xmx + 0) + 2) = tmp___3;
  *(*(xmx + 0) + 1) = tmp___3;
  k = 0;
  while (k <= hmm->M) {
    tmp___6 = -987654321;
    *(*(dmx + 0) + k) = tmp___6;
    tmp___5 = tmp___6;
    *(*(imx + 0) + k) = tmp___5;
    *(*(mmx + 0) + k) = tmp___5;
    k ++;
  }
  i___0 = 2;
  while (i___0 <= L) {
    tmp___8 = -987654321;
    *(*(dmx + i___0) + 0) = tmp___8;
    tmp___7 = tmp___8;
    *(*(imx + i___0) + 0) = tmp___7;
    *(*(mmx + i___0) + 0) = tmp___7;
    if (i___0 > 2) {
      if ((int )*(dsq + (i___0 - 2)) < 4) {
        if ((int )*(dsq + (i___0 - 1)) < 4) {
          if ((int )*(dsq + i___0) < 4) {
            codon = ((int )*(dsq + (i___0 - 2)) * 16 + (int )*(dsq + (i___0 - 1)) * 4) + (int )*(dsq + i___0);
          } else {
            codon = 64;
          }
        } else {
          codon = 64;
        }
      } else {
        codon = 64;
      }
    }
    k = 1;
    while (k <= hmm->M) {
      if (i___0 > 2) {
        *(*(mmx + i___0) + k) = *(*(mmx + (i___0 - 3)) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1));
        sc = *(*(imx + (i___0 - 3)) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1));
        if (sc > *(*(mmx + i___0) + k)) {
          *(*(mmx + i___0) + k) = sc;
        }
        sc = *(*(xmx + (i___0 - 3)) + 0) + *(hmm->bsc + k);
        if (sc > *(*(mmx + i___0) + k)) {
          *(*(mmx + i___0) + k) = sc;
        }
        sc = *(*(dmx + (i___0 - 3)) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1));
        if (sc > *(*(mmx + i___0) + k)) {
          *(*(mmx + i___0) + k) = sc;
        }
        *(*(mmx + i___0) + k) += *(*(hmm->dnam + codon) + k);
      }
      sc = (*(*(mmx + (i___0 - 2)) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1))) + hmm->dna2;
      if (sc > *(*(mmx + i___0) + k)) {
        *(*(mmx + i___0) + k) = sc;
      }
      sc = (*(*(imx + (i___0 - 2)) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1))) + hmm->dna2;
      if (sc > *(*(mmx + i___0) + k)) {
        *(*(mmx + i___0) + k) = sc;
      }
      sc = (*(*(xmx + (i___0 - 2)) + 0) + *(hmm->bsc + k)) + hmm->dna2;
      if (sc > *(*(mmx + i___0) + k)) {
        *(*(mmx + i___0) + k) = sc;
      }
      sc = (*(*(dmx + (i___0 - 2)) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1))) + hmm->dna2;
      if (sc > *(*(mmx + i___0) + k)) {
        *(*(mmx + i___0) + k) = sc;
      }
      if (i___0 > 3) {
        sc = (*(*(mmx + (i___0 - 4)) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1))) + hmm->dna4;
        if (sc > *(*(mmx + i___0) + k)) {
          *(*(mmx + i___0) + k) = sc;
        }
        sc = (*(*(imx + (i___0 - 4)) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1))) + hmm->dna4;
        if (sc > *(*(mmx + i___0) + k)) {
          *(*(mmx + i___0) + k) = sc;
        }
        sc = (*(*(xmx + (i___0 - 4)) + 0) + *(hmm->bsc + k)) + hmm->dna4;
        if (sc > *(*(mmx + i___0) + k)) {
          *(*(mmx + i___0) + k) = sc;
        }
        sc = (*(*(dmx + (i___0 - 4)) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1))) + hmm->dna4;
        if (sc > *(*(mmx + i___0) + k)) {
          *(*(mmx + i___0) + k) = sc;
        }
      }
      *(*(dmx + i___0) + k) = *(*(mmx + i___0) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1));
      sc = *(*(dmx + i___0) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1));
      if (sc > *(*(dmx + i___0) + k)) {
        *(*(dmx + i___0) + k) = sc;
      }
      if (i___0 > 2) {
        *(*(imx + i___0) + k) = *(*(mmx + (i___0 - 3)) + k) + *(*(hmm->tsc + 1) + k);
        sc = *(*(imx + (i___0 - 3)) + k) + *(*(hmm->tsc + 4) + k);
        if (sc > *(*(imx + i___0) + k)) {
          *(*(imx + i___0) + k) = sc;
        }
        *(*(imx + i___0) + k) += *(*(hmm->dnai + codon) + k);
      }
      sc = (*(*(mmx + (i___0 - 2)) + k) + *(*(hmm->tsc + 1) + k)) + hmm->dna2;
      if (sc > *(*(imx + i___0) + k)) {
        *(*(imx + i___0) + k) = sc;
      }
      sc = (*(*(imx + (i___0 - 2)) + k) + *(*(hmm->tsc + 4) + k)) + hmm->dna2;
      if (sc > *(*(imx + i___0) + k)) {
        *(*(imx + i___0) + k) = sc;
      }
      if (i___0 > 4) {
        sc = (*(*(mmx + (i___0 - 4)) + k) + *(*(hmm->tsc + 1) + k)) + hmm->dna4;
        if (sc > *(*(imx + i___0) + k)) {
          *(*(imx + i___0) + k) = sc;
        }
        sc = (*(*(imx + (i___0 - 4)) + k) + *(*(hmm->tsc + 4) + k)) + hmm->dna4;
        if (sc > *(*(imx + i___0) + k)) {
          *(*(imx + i___0) + k) = sc;
        }
      }
      k ++;
    }
    *(*(xmx + i___0) + 4) = *(*(xmx + (i___0 - 1)) + 4) + hmm->xsc[0][1];
    *(*(xmx + i___0) + 1) = *(*(dmx + i___0) + hmm->M);
    k = 1;
    while (k <= hmm->M) {
      sc = *(*(mmx + i___0) + k) + *(hmm->esc + k);
      if (sc > *(*(xmx + i___0) + 1)) {
        *(*(xmx + i___0) + 1) = sc;
      }
      k ++;
    }
    *(*(xmx + i___0) + 3) = *(*(xmx + (i___0 - 1)) + 3) + hmm->xsc[3][1];
    sc = *(*(xmx + i___0) + 1) + hmm->xsc[1][1];
    if (sc > *(*(xmx + i___0) + 3)) {
      *(*(xmx + i___0) + 3) = sc;
    }
    *(*(xmx + i___0) + 0) = *(*(xmx + i___0) + 4) + hmm->xsc[0][0];
    sc = *(*(xmx + i___0) + 3) + hmm->xsc[3][0];
    if (sc > *(*(xmx + i___0) + 0)) {
      *(*(xmx + i___0) + 0) = sc;
    }
    *(*(xmx + i___0) + 2) = *(*(xmx + (i___0 - 1)) + 2) + hmm->xsc[2][1];
    sc = *(*(xmx + i___0) + 1) + hmm->xsc[1][0];
    if (sc > *(*(xmx + i___0) + 2)) {
      *(*(xmx + i___0) + 2) = sc;
    }
    i___0 ++;
  }
  sc = *(*(xmx + L) + 2) + hmm->xsc[2][0];
  if ((unsigned long )ret_mx != (unsigned long )((void *)0)) {
    *ret_mx = mx;
  } else {
    FreePlan7Matrix(mx);
  }
  tmp___9 = Scorify(sc);
  return (tmp___9);
}
}
static float get_wee_midpt(struct plan7_s *hmm , char *dsq , int L , int k1 , char t1 ,
                           int s1 , int k3 , char t3 , int s3 , int *ret_k2 , char *ret_t2 ,
                           int *ret_s2 ) 
{ 
  struct dpmatrix_s *fwd ;
  struct dpmatrix_s *bck ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int k2 ;
  char t2 ;
  int s2 ;
  int cur ;
  int prv ;
  int nxt ;
  int i___0 ;
  int k ;
  int sc ;
  int max ;
  int start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  float tmp___13 ;

  {
  s2 = s1 + (s3 - s1) / 2;
  if (s3 - s1 == 1) {
    if ((int )t1 == 4) {
      s2 = s1;
    }
  }
  if (s3 - s1 == 1) {
    if ((int )t3 == 9) {
      s2 = s3;
    }
  }
  if ((int )t1 == 4) {
    start = 0;
  } else {
    start = s1;
  }
  fwd = AllocPlan7Matrix(2, hmm->M, & xmx, & mmx, & imx, & dmx);
  cur = start % 2;
  tmp = -987654321;
  *(*(xmx + cur) + 0) = tmp;
  *(*(xmx + cur) + 4) = tmp;
  tmp___0 = -987654321;
  *(*(xmx + cur) + 2) = tmp___0;
  *(*(xmx + cur) + 1) = tmp___0;
  k = k1;
  while (k <= k3) {
    tmp___2 = -987654321;
    *(*(dmx + cur) + k) = tmp___2;
    tmp___1 = tmp___2;
    *(*(imx + cur) + k) = tmp___1;
    *(*(mmx + cur) + k) = tmp___1;
    k ++;
  }
  switch ((int )t1) {
  case 1: 
  *(*(mmx + cur) + k1) = 0;
  break;
  case 3: 
  *(*(imx + cur) + k1) = 0;
  break;
  case 5: 
  *(*(xmx + cur) + 4) = 0;
  break;
  case 8: 
  *(*(xmx + cur) + 2) = 0;
  break;
  case 4: 
  *(*(xmx + cur) + 4) = 0;
  break;
  default: 
  tmp___3 = Statetype(t1);
  Die((char *)"you can\'t init get_wee_midpt with a %s\n", tmp___3);
  }
  if ((int )t1 == 1) {
    k = k1 + 1;
    while (k <= k3) {
      *(*(dmx + cur) + k) = -987654321;
      sc = *(*(mmx + cur) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1));
      if (sc > -987654321) {
        *(*(dmx + cur) + k) = sc;
      }
      sc = *(*(dmx + cur) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1));
      if (sc > *(*(dmx + cur) + k)) {
        *(*(dmx + cur) + k) = sc;
      }
      k ++;
    }
    *(*(xmx + cur) + 1) = -987654321;
    sc = *(*(mmx + cur) + k1) + *(hmm->esc + k1);
    if (sc > -987654321) {
      *(*(xmx + cur) + 1) = sc;
    }
  }
  *(*(xmx + cur) + 0) = -987654321;
  sc = *(*(xmx + cur) + 4) + hmm->xsc[0][0];
  if (sc > -987654321) {
    *(*(xmx + cur) + 0) = sc;
  }
  *(*(xmx + cur) + 2) = -987654321;
  sc = *(*(xmx + cur) + 1) + hmm->xsc[1][0];
  if (sc > -987654321) {
    *(*(xmx + cur) + 2) = sc;
  }
  i___0 = start + 1;
  while (i___0 <= s2) {
    cur = i___0 % 2;
    prv = ! cur;
    tmp___5 = -987654321;
    *(*(dmx + cur) + k1) = tmp___5;
    tmp___4 = tmp___5;
    *(*(imx + cur) + k1) = tmp___4;
    *(*(mmx + cur) + k1) = tmp___4;
    if (k1 < hmm->M) {
      *(*(imx + cur) + k1) = -987654321;
      sc = *(*(mmx + prv) + k1) + *(*(hmm->tsc + 1) + k1);
      if (sc > -987654321) {
        *(*(imx + cur) + k1) = sc;
      }
      sc = *(*(imx + prv) + k1) + *(*(hmm->tsc + 4) + k1);
      if (sc > *(*(imx + cur) + k1)) {
        *(*(imx + cur) + k1) = sc;
      }
      if (*(*(hmm->isc + (int )*(dsq + i___0)) + k1) != -987654321) {
        *(*(imx + cur) + k1) += *(*(hmm->isc + (int )*(dsq + i___0)) + k1);
      } else {
        *(*(imx + cur) + k1) = -987654321;
      }
    }
    sc = *(*(xmx + prv) + 0) + *(hmm->bsc + k1);
    if (sc > -987654321) {
      *(*(mmx + cur) + k1) = sc;
    }
    if (*(*(hmm->msc + (int )*(dsq + i___0)) + k1) != -987654321) {
      *(*(mmx + cur) + k1) += *(*(hmm->msc + (int )*(dsq + i___0)) + k1);
    } else {
      *(*(mmx + cur) + k1) = -987654321;
    }
    k = k1 + 1;
    while (k <= k3) {
      *(*(mmx + cur) + k) = -987654321;
      sc = *(*(mmx + prv) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1));
      if (sc > -987654321) {
        *(*(mmx + cur) + k) = sc;
      }
      sc = *(*(imx + prv) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1));
      if (sc > *(*(mmx + cur) + k)) {
        *(*(mmx + cur) + k) = sc;
      }
      sc = *(*(xmx + prv) + 0) + *(hmm->bsc + k);
      if (sc > *(*(mmx + cur) + k)) {
        *(*(mmx + cur) + k) = sc;
      }
      sc = *(*(dmx + prv) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1));
      if (sc > *(*(mmx + cur) + k)) {
        *(*(mmx + cur) + k) = sc;
      }
      if (*(*(hmm->msc + (int )*(dsq + i___0)) + k) != -987654321) {
        *(*(mmx + cur) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
      } else {
        *(*(mmx + cur) + k) = -987654321;
      }
      *(*(dmx + cur) + k) = -987654321;
      if (k < hmm->M) {
        sc = *(*(mmx + cur) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1));
        if (sc > -987654321) {
          *(*(dmx + cur) + k) = sc;
        }
        sc = *(*(dmx + cur) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1));
        if (sc > *(*(dmx + cur) + k)) {
          *(*(dmx + cur) + k) = sc;
        }
      }
      *(*(imx + cur) + k) = -987654321;
      if (k < hmm->M) {
        sc = *(*(mmx + prv) + k) + *(*(hmm->tsc + 1) + k);
        if (sc > -987654321) {
          *(*(imx + cur) + k) = sc;
        }
        sc = *(*(imx + prv) + k) + *(*(hmm->tsc + 4) + k);
        if (sc > *(*(imx + cur) + k)) {
          *(*(imx + cur) + k) = sc;
        }
        if (*(*(hmm->isc + (int )*(dsq + i___0)) + k) != -987654321) {
          *(*(imx + cur) + k) += *(*(hmm->isc + (int )*(dsq + i___0)) + k);
        } else {
          *(*(imx + cur) + k) = -987654321;
        }
      }
      k ++;
    }
    *(*(xmx + cur) + 4) = -987654321;
    sc = *(*(xmx + prv) + 4) + hmm->xsc[0][1];
    if (sc > -987654321) {
      *(*(xmx + cur) + 4) = sc;
    }
    *(*(xmx + cur) + 1) = -987654321;
    k = k1;
    while (1) {
      if (k <= k3) {
        if (! (k <= hmm->M)) {
          break;
        }
      } else {
        break;
      }
      sc = *(*(mmx + cur) + k) + *(hmm->esc + k);
      if (sc > *(*(xmx + cur) + 1)) {
        *(*(xmx + cur) + 1) = sc;
      }
      k ++;
    }
    *(*(xmx + cur) + 0) = -987654321;
    sc = *(*(xmx + cur) + 4) + hmm->xsc[0][0];
    if (sc > -987654321) {
      *(*(xmx + cur) + 0) = sc;
    }
    *(*(xmx + cur) + 2) = -987654321;
    sc = *(*(xmx + prv) + 2) + hmm->xsc[2][1];
    if (sc > -987654321) {
      *(*(xmx + cur) + 2) = sc;
    }
    sc = *(*(xmx + cur) + 1) + hmm->xsc[1][0];
    if (sc > *(*(xmx + cur) + 2)) {
      *(*(xmx + cur) + 2) = sc;
    }
    i___0 ++;
  }
  bck = AllocPlan7Matrix(2, hmm->M, & xmx, & mmx, & imx, & dmx);
  nxt = s3 % 2;
  tmp___6 = -987654321;
  *(*(xmx + nxt) + 0) = tmp___6;
  *(*(xmx + nxt) + 4) = tmp___6;
  tmp___7 = -987654321;
  *(*(xmx + nxt) + 2) = tmp___7;
  *(*(xmx + nxt) + 1) = tmp___7;
  k = k1;
  while (k <= k3 + 1) {
    tmp___9 = -987654321;
    *(*(dmx + nxt) + k) = tmp___9;
    tmp___8 = tmp___9;
    *(*(imx + nxt) + k) = tmp___8;
    *(*(mmx + nxt) + k) = tmp___8;
    k ++;
  }
  cur = ! nxt;
  tmp___11 = -987654321;
  *(*(dmx + cur) + (k3 + 1)) = tmp___11;
  tmp___10 = tmp___11;
  *(*(imx + cur) + (k3 + 1)) = tmp___10;
  *(*(mmx + cur) + (k3 + 1)) = tmp___10;
  switch ((int )t3) {
  case 1: 
  *(*(mmx + nxt) + k3) = 0;
  break;
  case 3: 
  *(*(imx + nxt) + k3) = 0;
  break;
  case 5: 
  *(*(xmx + nxt) + 4) = 0;
  break;
  case 8: 
  *(*(xmx + nxt) + 2) = 0;
  break;
  case 9: 
  *(*(xmx + nxt) + 2) = hmm->xsc[2][0];
  break;
  default: 
  tmp___12 = Statetype(t3);
  Die((char *)"you can\'t init get_wee_midpt with a %s\n", tmp___12);
  }
  if ((int )t3 == 9) {
    *(*(xmx + nxt) + 1) = *(*(xmx + nxt) + 2) + hmm->xsc[1][0];
    k = k3;
    while (k >= k1) {
      *(*(mmx + nxt) + k) = *(*(xmx + nxt) + 1) + *(hmm->esc + k);
      if (s3 != s2) {
        *(*(mmx + nxt) + k) += *(*(hmm->msc + (int )*(dsq + s3)) + k);
      }
      k --;
    }
  }
  i___0 = s3 - 1;
  while (i___0 >= s2) {
    cur = i___0 % 2;
    nxt = ! cur;
    *(*(xmx + cur) + 2) = -987654321;
    sc = *(*(xmx + nxt) + 2) + hmm->xsc[2][1];
    if (sc > -987654321) {
      *(*(xmx + cur) + 2) = sc;
    }
    *(*(xmx + cur) + 0) = -987654321;
    k = k1;
    while (k <= k3) {
      sc = *(*(mmx + nxt) + k) + *(hmm->bsc + k);
      if (sc > *(*(xmx + cur) + 0)) {
        *(*(xmx + cur) + 0) = sc;
      }
      k ++;
    }
    *(*(xmx + cur) + 1) = -987654321;
    sc = *(*(xmx + cur) + 2) + hmm->xsc[1][0];
    if (sc > -987654321) {
      *(*(xmx + cur) + 1) = sc;
    }
    *(*(xmx + cur) + 4) = -987654321;
    sc = *(*(xmx + cur) + 0) + hmm->xsc[0][0];
    if (sc > -987654321) {
      *(*(xmx + cur) + 4) = sc;
    }
    sc = *(*(xmx + nxt) + 4) + hmm->xsc[0][1];
    if (sc > *(*(xmx + cur) + 4)) {
      *(*(xmx + cur) + 4) = sc;
    }
    k = k3;
    while (k >= k1) {
      if (k == hmm->M) {
        *(*(mmx + cur) + k) = *(*(xmx + cur) + 1);
        *(*(dmx + cur) + k) = -987654321;
        *(*(imx + cur) + k) = -987654321;
        if (i___0 != s2) {
          *(*(mmx + cur) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
        }
        goto __Cont;
      }
      *(*(mmx + cur) + k) = -987654321;
      sc = *(*(xmx + cur) + 1) + *(hmm->esc + k);
      if (sc > -987654321) {
        *(*(mmx + cur) + k) = sc;
      }
      sc = *(*(mmx + nxt) + (k + 1)) + *(*(hmm->tsc + 0) + k);
      if (sc > *(*(mmx + cur) + k)) {
        *(*(mmx + cur) + k) = sc;
      }
      sc = *(*(imx + nxt) + k) + *(*(hmm->tsc + 1) + k);
      if (sc > *(*(mmx + cur) + k)) {
        *(*(mmx + cur) + k) = sc;
      }
      sc = *(*(dmx + cur) + (k + 1)) + *(*(hmm->tsc + 2) + k);
      if (sc > *(*(mmx + cur) + k)) {
        *(*(mmx + cur) + k) = sc;
      }
      if (i___0 != s2) {
        *(*(mmx + cur) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
      }
      *(*(dmx + cur) + k) = -987654321;
      sc = *(*(mmx + nxt) + (k + 1)) + *(*(hmm->tsc + 5) + k);
      if (sc > -987654321) {
        *(*(dmx + cur) + k) = sc;
      }
      sc = *(*(dmx + cur) + (k + 1)) + *(*(hmm->tsc + 6) + k);
      if (sc > *(*(dmx + cur) + k)) {
        *(*(dmx + cur) + k) = sc;
      }
      *(*(imx + cur) + k) = -987654321;
      sc = *(*(mmx + nxt) + (k + 1)) + *(*(hmm->tsc + 3) + k);
      if (sc > -987654321) {
        *(*(imx + cur) + k) = sc;
      }
      sc = *(*(imx + nxt) + k) + *(*(hmm->tsc + 4) + k);
      if (sc > *(*(imx + cur) + k)) {
        *(*(imx + cur) + k) = sc;
      }
      if (i___0 != s2) {
        *(*(imx + cur) + k) += *(*(hmm->isc + (int )*(dsq + i___0)) + k);
      }
      __Cont: /* CIL Label */ 
      k --;
    }
    i___0 --;
  }
  cur = s2 % 2;
  max = -987654321;
  k = k1;
  while (k <= k3) {
    sc = *(*(fwd->mmx + cur) + k) + *(*(bck->mmx + cur) + k);
    if (sc > max) {
      k2 = k;
      t2 = (char)1;
      max = sc;
    }
    sc = *(*(fwd->imx + cur) + k) + *(*(bck->imx + cur) + k);
    if (sc > max) {
      k2 = k;
      t2 = (char)3;
      max = sc;
    }
    k ++;
  }
  sc = *(*(fwd->xmx + cur) + 4) + *(*(bck->xmx + cur) + 4);
  if (sc > max) {
    k2 = 1;
    t2 = (char)5;
    max = sc;
  }
  sc = *(*(fwd->xmx + cur) + 2) + *(*(bck->xmx + cur) + 2);
  if (sc > max) {
    k2 = hmm->M;
    t2 = (char)8;
    max = sc;
  }
  FreePlan7Matrix(fwd);
  FreePlan7Matrix(bck);
  *ret_k2 = k2;
  *ret_t2 = t2;
  *ret_s2 = s2;
  tmp___13 = Scorify(max);
  return (tmp___13);
}
}
struct p7trace_s *P7ViterbiAlignAlignment(MSA *msa , struct plan7_s *hmm ) 
{ 
  struct dpmatrix_s *mx ;
  struct dpshadow_s *tb ;
  struct p7trace_s *tr ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  char **xtb ;
  char **mtb ;
  char **itb ;
  char **dtb ;
  float **con ;
  float *mocc ;
  int i___0 ;
  int k ;
  int idx ;
  int sym ;
  int sc ;
  float denom ;
  int cur ;
  int prv ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char tmp___8 ;
  char tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char tmp___12 ;
  char tmp___13 ;

  {
  tmp = sre_malloc((char *)"core_algorithms.c", 2044, sizeof(float *) * (unsigned long )(msa->alen + 1));
  con = (float **)tmp;
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 2045, sizeof(float ) * (unsigned long )(msa->alen + 1));
  mocc = (float *)tmp___0;
  i___0 = 1;
  while (i___0 <= msa->alen) {
    tmp___1 = sre_malloc((char *)"core_algorithms.c", 2047, sizeof(float ) * (unsigned long )Alphabet_size);
    *(con + i___0) = (float *)tmp___1;
    FSet(*(con + i___0), Alphabet_size, (float )0.0);
    i___0 ++;
  }
  *(mocc + 0) = (float )(- 9999.);
  denom = FSum(msa->wgt, msa->nseq);
  i___0 = 1;
  while (i___0 <= msa->alen) {
    idx = 0;
    while (idx < msa->nseq) {
      if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 32)) {
        if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 46)) {
          if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 95)) {
            if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 45)) {
              if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 126)) {
                tmp___2 = strchr((char const   *)(Alphabet), (int )*(*(msa->aseq + idx) + (i___0 - 1)));
                P7CountSymbol(*(con + i___0), (char )(tmp___2 - Alphabet), *(msa->wgt + idx));
              }
            }
          }
        }
      }
      idx ++;
    }
    FScale(*(con + i___0), Alphabet_size, (float )(1. / (double )denom));
    *(mocc + i___0) = FSum(*(con + i___0), Alphabet_size);
    i___0 ++;
  }
  mx = AllocPlan7Matrix(2, hmm->M, & xmx, & mmx, & imx, & dmx);
  tb = AllocShadowMatrix(msa->alen + 1, hmm->M, & xtb, & mtb, & itb, & dtb);
  *(*(xmx + 0) + 4) = 0;
  *(*(xtb + 0) + 4) = (char)4;
  *(*(xmx + 0) + 0) = hmm->xsc[0][0];
  *(*(xtb + 0) + 0) = (char)5;
  tmp___4 = -987654321;
  *(*(xmx + 0) + 3) = tmp___4;
  tmp___3 = tmp___4;
  *(*(xmx + 0) + 2) = tmp___3;
  *(*(xmx + 0) + 1) = tmp___3;
  *(tb->esrc + 0) = 0;
  tmp___5 = (char)0;
  *(*(xtb + 0) + 3) = tmp___5;
  *(*(xtb + 0) + 2) = tmp___5;
  k = 0;
  while (k <= hmm->M) {
    tmp___7 = -987654321;
    *(*(dmx + 0) + k) = tmp___7;
    tmp___6 = tmp___7;
    *(*(imx + 0) + k) = tmp___6;
    *(*(mmx + 0) + k) = tmp___6;
    tmp___9 = (char)0;
    *(*(dtb + 0) + k) = tmp___9;
    tmp___8 = tmp___9;
    *(*(itb + 0) + k) = tmp___8;
    *(*(mtb + 0) + k) = tmp___8;
    k ++;
  }
  i___0 = 1;
  while (i___0 <= msa->alen) {
    cur = i___0 % 2;
    prv = ! cur;
    tmp___11 = -987654321;
    *(*(dmx + cur) + 0) = tmp___11;
    tmp___10 = tmp___11;
    *(*(imx + cur) + 0) = tmp___10;
    *(*(mmx + cur) + 0) = tmp___10;
    tmp___13 = (char)0;
    *(*(dtb + i___0) + 0) = tmp___13;
    tmp___12 = tmp___13;
    *(*(itb + i___0) + 0) = tmp___12;
    *(*(mtb + i___0) + 0) = tmp___12;
    k = 1;
    while (k <= hmm->M) {
      *(*(mmx + cur) + k) = -987654321;
      *(*(mtb + i___0) + k) = (char)0;
      if (*(*(mmx + prv) + (k - 1)) > -987654321) {
        if (*(*(hmm->tsc + 0) + (k - 1)) > -987654321) {
          sc = *(*(mmx + prv) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1));
          if (sc > *(*(mmx + cur) + k)) {
            *(*(mmx + cur) + k) = sc;
            *(*(mtb + i___0) + k) = (char)1;
          }
        }
      }
      if (*(*(imx + prv) + (k - 1)) > -987654321) {
        if (*(*(hmm->tsc + 3) + (k - 1)) > -987654321) {
          sc = (int )((float )*(*(imx + prv) + (k - 1)) + (float )*(*(hmm->tsc + 3) + (k - 1)) * *(mocc + (i___0 - 1)));
          if (sc > *(*(mmx + cur) + k)) {
            *(*(mmx + cur) + k) = sc;
            *(*(mtb + i___0) + k) = (char)3;
          }
        }
      }
      sc = *(*(xmx + prv) + 0) + *(hmm->bsc + k);
      if (sc > *(*(mmx + cur) + k)) {
        *(*(mmx + cur) + k) = sc;
        *(*(mtb + i___0) + k) = (char)6;
      }
      if (*(*(dmx + prv) + (k - 1)) > -987654321) {
        if (*(*(hmm->tsc + 5) + (k - 1)) > -987654321) {
          sc = *(*(dmx + prv) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1));
          if (sc > *(*(mmx + cur) + k)) {
            *(*(mmx + cur) + k) = sc;
            *(*(mtb + i___0) + k) = (char)2;
          }
        }
      }
      sym = 0;
      while (sym < Alphabet_size) {
        if (*(*(con + i___0) + sym) > (float )0) {
          if (*(*(hmm->msc + sym) + k) == -987654321) {
            *(*(mmx + cur) + k) = -987654321;
            break;
          }
        }
        *(*(mmx + cur) + k) = (int )((float )*(*(mmx + cur) + k) + (float )*(*(hmm->msc + sym) + k) * *(*(con + i___0) + sym));
        sym ++;
      }
      *(*(dmx + cur) + k) = -987654321;
      *(*(dtb + i___0) + k) = (char)0;
      if (*(*(mmx + cur) + (k - 1)) > -987654321) {
        if (*(*(hmm->tsc + 2) + (k - 1)) > -987654321) {
          sc = *(*(mmx + cur) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1));
          if (sc > *(*(dmx + cur) + k)) {
            *(*(dmx + cur) + k) = sc;
            *(*(dtb + i___0) + k) = (char)1;
          }
        }
      }
      if (*(*(dmx + cur) + (k - 1)) > -987654321) {
        if (*(*(hmm->tsc + 6) + (k - 1)) > -987654321) {
          sc = *(*(dmx + cur) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1));
          if (sc > *(*(dmx + cur) + k)) {
            *(*(dmx + cur) + k) = sc;
            *(*(dtb + i___0) + k) = (char)2;
          }
        }
      }
      if (k < hmm->M) {
        *(*(imx + cur) + k) = -987654321;
        *(*(itb + i___0) + k) = (char)0;
        if (*(*(mmx + prv) + k) > -987654321) {
          if (*(*(hmm->tsc + 1) + k) > -987654321) {
            sc = (int )((float )*(*(mmx + prv) + k) + (float )*(*(hmm->tsc + 1) + k) * *(mocc + i___0));
            if (sc > *(*(imx + cur) + k)) {
              *(*(imx + cur) + k) = sc;
              *(*(itb + i___0) + k) = (char)1;
            }
          }
        }
        if (*(*(imx + prv) + k) > -987654321) {
          if (*(*(hmm->tsc + 4) + k) > -987654321) {
            sc = (int )((float )*(*(imx + prv) + k) + ((float )*(*(hmm->tsc + 4) + k) * *(mocc + (i___0 - 1))) * *(mocc + i___0));
            if (sc > *(*(imx + cur) + k)) {
              *(*(imx + cur) + k) = sc;
              *(*(itb + i___0) + k) = (char)3;
            }
          }
        }
        sym = 0;
        while (sym < Alphabet_size) {
          if (*(*(con + i___0) + sym) > (float )0) {
            if (*(*(hmm->isc + sym) + k) == -987654321) {
              *(*(imx + cur) + k) = -987654321;
              break;
            }
          }
          *(*(imx + cur) + k) = (int )((float )*(*(imx + cur) + k) + (float )*(*(hmm->isc + sym) + k) * *(*(con + i___0) + sym));
          sym ++;
        }
      }
      k ++;
    }
    *(*(xmx + cur) + 4) = -987654321;
    *(*(xtb + i___0) + 4) = (char)0;
    if (*(*(xmx + prv) + 4) > -987654321) {
      if (hmm->xsc[0][1] > -987654321) {
        sc = (int )((float )*(*(xmx + prv) + 4) + (float )hmm->xsc[0][1] * *(mocc + i___0));
        if (sc > -987654321) {
          *(*(xmx + cur) + 4) = sc;
          *(*(xtb + i___0) + 4) = (char)5;
        }
      }
    }
    *(*(xmx + cur) + 1) = -987654321;
    *(*(xtb + i___0) + 1) = (char)0;
    k = 1;
    while (k <= hmm->M) {
      if (*(*(mmx + cur) + k) > -987654321) {
        if (*(hmm->esc + k) > -987654321) {
          sc = *(*(mmx + cur) + k) + *(hmm->esc + k);
          if (sc > *(*(xmx + cur) + 1)) {
            *(*(xmx + cur) + 1) = sc;
            *(tb->esrc + i___0) = k;
          }
        }
      }
      k ++;
    }
    *(*(xmx + cur) + 0) = -987654321;
    *(*(xtb + i___0) + 0) = (char)0;
    if (*(*(xmx + cur) + 4) > -987654321) {
      if (hmm->xsc[0][0] > -987654321) {
        sc = *(*(xmx + cur) + 4) + hmm->xsc[0][0];
        if (sc > *(*(xmx + cur) + 0)) {
          *(*(xmx + cur) + 0) = sc;
          *(*(xtb + i___0) + 0) = (char)5;
        }
      }
    }
    *(*(xmx + cur) + 2) = -987654321;
    *(*(xtb + i___0) + 2) = (char)0;
    if (*(*(xmx + prv) + 2) > -987654321) {
      if (hmm->xsc[2][1] > -987654321) {
        sc = (int )((float )*(*(xmx + prv) + 2) + (float )hmm->xsc[2][1] * *(mocc + i___0));
        if (sc > -987654321) {
          *(*(xmx + cur) + 2) = sc;
          *(*(xtb + i___0) + 2) = (char)8;
        }
      }
    }
    if (*(*(xmx + cur) + 1) > -987654321) {
      if (hmm->xsc[1][0] > -987654321) {
        sc = *(*(xmx + cur) + 1) + hmm->xsc[1][0];
        if (sc > *(*(xmx + cur) + 2)) {
          *(*(xmx + cur) + 2) = sc;
          *(*(xtb + i___0) + 2) = (char)7;
        }
      }
    }
    i___0 ++;
  }
  sc = *(*(xmx + msa->alen % 2) + 2) + hmm->xsc[2][0];
  tr = ShadowTrace(tb, hmm, msa->alen);
  FreePlan7Matrix(mx);
  FreeShadowMatrix(tb);
  i___0 = 1;
  while (i___0 <= msa->alen) {
    free((void *)*(con + i___0));
    i___0 ++;
  }
  free((void *)con);
  free((void *)mocc);
  return (tr);
}
}
struct p7trace_s *ShadowTrace(struct dpshadow_s *tb , struct plan7_s *hmm , int L ) 
{ 
  struct p7trace_s *tr ;
  int curralloc ;
  int tpos ;
  int i___0 ;
  int k ;
  char nxtstate ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int dk ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  curralloc = L * 2 + 6;
  P7AllocTrace(curralloc, & tr);
  *(tr->statetype + 0) = (char)9;
  *(tr->nodeidx + 0) = 0;
  *(tr->pos + 0) = 0;
  tpos = 1;
  i___0 = L;
  k = 0;
  nxtstate = (char)8;
  while ((int )nxtstate != 4) {
    switch ((int )nxtstate) {
    case 1: 
    *(tr->statetype + tpos) = (char)1;
    nxtstate = *(*(tb->mtb + i___0) + k);
    tmp = k;
    k --;
    *(tr->nodeidx + tpos) = tmp;
    tmp___0 = i___0;
    i___0 --;
    *(tr->pos + tpos) = tmp___0;
    tpos ++;
    break;
    case 3: 
    *(tr->statetype + tpos) = (char)3;
    nxtstate = *(*(tb->itb + i___0) + k);
    *(tr->nodeidx + tpos) = k;
    tmp___1 = i___0;
    i___0 --;
    *(tr->pos + tpos) = tmp___1;
    tpos ++;
    break;
    case 2: 
    *(tr->statetype + tpos) = (char)2;
    nxtstate = *(*(tb->dtb + i___0) + k);
    tmp___2 = k;
    k --;
    *(tr->nodeidx + tpos) = tmp___2;
    *(tr->pos + tpos) = 0;
    tpos ++;
    break;
    case 5: 
    *(tr->statetype + tpos) = (char)5;
    nxtstate = *(*(tb->xtb + i___0) + 4);
    *(tr->nodeidx + tpos) = 0;
    if ((int )nxtstate == 5) {
      tmp___3 = i___0;
      i___0 --;
      *(tr->pos + tpos) = tmp___3;
    } else {
      *(tr->pos + tpos) = 0;
    }
    tpos ++;
    break;
    case 6: 
    tmp___5 = Prob2Score(*(hmm->begin + (k + 1)), hmm->p1);
    if ((double )tmp___5 + (double )1 * 1000.0 <= (double )*(hmm->bsc + (k + 1))) {
      while (k > 0) {
        *(tr->statetype + tpos) = (char)2;
        tmp___4 = k;
        k --;
        *(tr->nodeidx + tpos) = tmp___4;
        *(tr->pos + tpos) = 0;
        tpos ++;
        if (tpos == curralloc) {
          curralloc += L;
          P7ReallocTrace(tr, curralloc);
        }
      }
    }
    *(tr->statetype + tpos) = (char)6;
    nxtstate = *(*(tb->xtb + i___0) + 0);
    *(tr->nodeidx + tpos) = 0;
    *(tr->pos + tpos) = 0;
    tpos ++;
    break;
    case 10: 
    *(tr->statetype + tpos) = (char)10;
    nxtstate = *(*(tb->xtb + i___0) + 3);
    *(tr->nodeidx + tpos) = 0;
    if ((int )nxtstate == 10) {
      tmp___6 = i___0;
      i___0 --;
      *(tr->pos + tpos) = tmp___6;
    } else {
      *(tr->pos + tpos) = 0;
    }
    tpos ++;
    break;
    case 7: 
    *(tr->statetype + tpos) = (char)7;
    *(tr->nodeidx + tpos) = 0;
    *(tr->pos + tpos) = 0;
    k = *(tb->esrc + i___0);
    nxtstate = (char)1;
    tpos ++;
    tmp___7 = Prob2Score(*(hmm->end + k), (float )1.);
    if ((double )tmp___7 + (double )1 * 1000.0 <= (double )*(hmm->esc + k)) {
      dk = hmm->M;
      while (dk > k) {
        *(tr->statetype + tpos) = (char)2;
        *(tr->nodeidx + tpos) = dk;
        *(tr->pos + tpos) = 0;
        tpos ++;
        if (tpos == curralloc) {
          curralloc += L;
          P7ReallocTrace(tr, curralloc);
        }
        dk --;
      }
    }
    break;
    case 8: 
    *(tr->statetype + tpos) = (char)8;
    nxtstate = *(*(tb->xtb + i___0) + 2);
    *(tr->nodeidx + tpos) = 0;
    if ((int )nxtstate == 8) {
      tmp___8 = i___0;
      i___0 --;
      *(tr->pos + tpos) = tmp___8;
    } else {
      *(tr->pos + tpos) = 0;
    }
    tpos ++;
    break;
    default: 
    tmp___9 = Statetype(nxtstate);
    Die((char *)"HMMER: Bad state (%s) in ShadowTrace()\n", tmp___9);
    }
    if (tpos == curralloc) {
      curralloc += L;
      P7ReallocTrace(tr, curralloc);
    }
  }
  *(tr->statetype + tpos) = (char)4;
  *(tr->nodeidx + tpos) = 0;
  *(tr->pos + tpos) = 0;
  tr->tlen = tpos + 1;
  P7ReverseTrace(tr);
  return (tr);
}
}
float PostprocessSignificantHit(struct tophit_s *ghit , struct tophit_s *dhit , struct p7trace_s *tr ,
                                struct plan7_s *hmm , char *dsq , int L , char *seqname ,
                                char *seqacc , char *seqdesc , int do_forward , float sc_override ,
                                int do_null2 , struct threshold_s *thresh___0 , int hmmpfam_mode ) 
{ 
  struct p7trace_s **tarr ;
  struct fancyali_s *ali ;
  int ntr ;
  int tidx ;
  int ndom ;
  int didx ;
  int k1 ;
  int k2 ;
  int i1 ;
  int i2 ;
  float whole_sc ;
  float *score ;
  int *usedomain ;
  double whole_pval ;
  double pvalue ;
  double sortkey ;
  void *tmp ;
  void *tmp___0 ;
  float tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  double tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  if ((unsigned long )tr == (unsigned long )((void *)0)) {
    return (sc_override);
  }
  TraceDecompose(tr, & tarr, & ntr);
  if (ntr == 0) {
    Die((char *)"TraceDecompose() screwup");
  }
  tmp = sre_malloc((char *)"core_algorithms.c", 2480, sizeof(float ) * (unsigned long )ntr);
  score = (float *)tmp;
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 2481, sizeof(int ) * (unsigned long )ntr);
  usedomain = (int *)tmp___0;
  ndom = 0;
  whole_sc = (float )0.;
  tidx = 0;
  while (tidx < ntr) {
    *(score + tidx) = P7TraceScore(hmm, dsq, *(tarr + tidx));
    if (do_null2) {
      tmp___1 = TraceScoreCorrection(hmm, *(tarr + tidx), dsq);
      *(score + tidx) -= tmp___1;
    }
    if ((double )*(score + tidx) > 0.0) {
      *(usedomain + tidx) = 1;
      ndom ++;
      whole_sc += *(score + tidx);
    } else {
      *(usedomain + tidx) = 0;
    }
    tidx ++;
  }
  if (ndom == 0) {
    tidx = FArgMax(score, ntr);
    *(usedomain + tidx) = 1;
    whole_sc = *(score + tidx);
    ndom = 1;
  }
  if (do_forward) {
    whole_sc = sc_override;
  }
  whole_pval = PValue(hmm, whole_sc);
  tidx = 0;
  didx = 1;
  while (tidx < ntr) {
    if (! *(usedomain + tidx)) {
      goto __Cont;
    }
    TraceSimpleBounds(*(tarr + tidx), & i1, & i2, & k1, & k2);
    pvalue = PValue(hmm, *(score + tidx));
    if (pvalue <= thresh___0->domE) {
      if (*(score + tidx) >= thresh___0->domT) {
        ali = CreateFancyAli(*(tarr + tidx), hmm, dsq, seqname);
        if (hmmpfam_mode) {
          sortkey = - 1. * (double )i1;
        } else {
          sortkey = (double )*(score + tidx);
        }
        if (hmmpfam_mode) {
          tmp___2 = hmm->desc;
        } else {
          tmp___2 = seqdesc;
        }
        if (hmmpfam_mode) {
          tmp___3 = hmm->acc;
        } else {
          tmp___3 = seqacc;
        }
        if (hmmpfam_mode) {
          tmp___4 = hmm->name;
        } else {
          tmp___4 = seqname;
        }
        RegisterHit(dhit, sortkey, pvalue, *(score + tidx), whole_pval, whole_sc,
                    tmp___4, tmp___3, tmp___2, i1, i2, L, k1, k2, hmm->M, didx, ndom,
                    ali);
      }
    }
    didx ++;
    __Cont: /* CIL Label */ 
    tidx ++;
  }
  if (hmmpfam_mode) {
    if (whole_pval > 0.0) {
      tmp___5 = log(whole_pval);
      sortkey = - 1. * tmp___5;
    } else {
      sortkey = 100000. + (double )whole_sc;
    }
  } else {
    sortkey = (double )whole_sc;
  }
  if (whole_sc >= thresh___0->globT) {
    if (hmmpfam_mode) {
      tmp___6 = hmm->desc;
    } else {
      tmp___6 = seqdesc;
    }
    if (hmmpfam_mode) {
      tmp___7 = hmm->acc;
    } else {
      tmp___7 = seqacc;
    }
    if (hmmpfam_mode) {
      tmp___8 = hmm->name;
    } else {
      tmp___8 = seqname;
    }
    RegisterHit(ghit, sortkey, whole_pval, whole_sc, 0., (float )0., tmp___8, tmp___7,
                tmp___6, 0, 0, 0, 0, 0, 0, 0, ndom, (struct fancyali_s *)((void *)0));
  }
  tidx = 0;
  while (tidx < ntr) {
    P7FreeTrace(*(tarr + tidx));
    tidx ++;
  }
  free((void *)tarr);
  free((void *)score);
  free((void *)usedomain);
  return (whole_sc);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-wDtBacq0.i","-O3")
extern int ( /* format attribute */  fprintf)(FILE * , char const   *  , ...) ;
extern int fputs(char const   * , FILE * )  __asm__("_fputs")  ;
extern __darwin_ct_rune_t __tolower(__darwin_ct_rune_t  ) ;
__inline static int tolower(int _c ) 
{ 
  __darwin_ct_rune_t tmp ;

  {
  tmp = __tolower(_c);
  return (tmp);
}
}
char *AlphabetType2String(int type ) ;
void P7PrintTrace(FILE *fp , struct p7trace_s *tr , struct plan7_s *hmm , char *dsq ) ;
void P7PrintPrior(FILE *fp , struct p7prior_s *pri ) ;
int TraceCompare(struct p7trace_s *t1 , struct p7trace_s *t2 ) ;
int TraceVerify(struct p7trace_s *tr , int M , int N ) ;
int TransitionScoreLookup(struct plan7_s *hmm , char st1 , int k1 , char st2 , int k2 ) ;
char *Statetype(char st ) 
{ 


  {
  switch ((int )st) {
  case 4: 
  return ((char *)"S");
  case 5: 
  return ((char *)"N");
  case 6: 
  return ((char *)"B");
  case 1: 
  return ((char *)"M");
  case 2: 
  return ((char *)"D");
  case 3: 
  return ((char *)"I");
  case 7: 
  return ((char *)"E");
  case 10: 
  return ((char *)"J");
  case 8: 
  return ((char *)"C");
  case 9: 
  return ((char *)"T");
  default: 
  return ((char *)"BOGUS");
  }
}
}
char *AlphabetType2String(int type ) 
{ 


  {
  switch (type) {
  case 3: 
  return ((char *)"protein");
  case 2: 
  return ((char *)"nucleic acid");
  case 0: 
  return ((char *)"unknown");
  default: 
  return ((char *)"BOGUS");
  }
}
}
void P7PrintTrace(FILE *fp , struct p7trace_s *tr , struct plan7_s *hmm , char *dsq ) 
{ 
  int tpos ;
  int sym ;
  int sc ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if ((unsigned long )tr == (unsigned long )((void *)0)) {
    fprintf(fp, " [ trace is NULL ]\n");
    return;
  }
  if ((unsigned long )hmm == (unsigned long )((void *)0)) {
    fprintf(fp, "st  node   rpos  - traceback len %d\n", tr->tlen);
    fprintf(fp, "--  ---- ------\n");
    tpos = 0;
    while (tpos < tr->tlen) {
      tmp = Statetype(*(tr->statetype + tpos));
      fprintf(fp, "%1s  %4d %6d\n", tmp, *(tr->nodeidx + tpos), *(tr->pos + tpos));
      tpos ++;
    }
  } else {
    if (! (hmm->flags & 1)) {
      Die((char *)"oi, you can\'t print scores from that hmm, it\'s not ready.");
    }
    sc = 0;
    fprintf(fp, "st  node   rpos  transit emission - traceback len %d\n", tr->tlen);
    fprintf(fp, "--  ---- ------  ------- --------\n");
    tpos = 0;
    while (tpos < tr->tlen) {
      if ((unsigned long )dsq != (unsigned long )((void *)0)) {
        sym = (int )*(dsq + *(tr->pos + tpos));
      }
      if (tpos < tr->tlen - 1) {
        tmp___0 = TransitionScoreLookup(hmm, *(tr->statetype + tpos), *(tr->nodeidx + tpos),
                                        *(tr->statetype + (tpos + 1)), *(tr->nodeidx + (tpos + 1)));
        tmp___1 = tmp___0;
      } else {
        tmp___1 = 0;
      }
      tmp___2 = Statetype(*(tr->statetype + tpos));
      fprintf(fp, "%1s  %4d %6d  %7d", tmp___2, *(tr->nodeidx + tpos), *(tr->pos + tpos),
              tmp___1);
      if (tpos < tr->tlen - 1) {
        tmp___3 = TransitionScoreLookup(hmm, *(tr->statetype + tpos), *(tr->nodeidx + tpos),
                                        *(tr->statetype + (tpos + 1)), *(tr->nodeidx + (tpos + 1)));
        sc += tmp___3;
      }
      if ((unsigned long )dsq != (unsigned long )((void *)0)) {
        if ((int )*(tr->statetype + tpos) == 1) {
          fprintf(fp, " %8d %c", *(*(hmm->msc + sym) + *(tr->nodeidx + tpos)), (int )Alphabet[sym]);
          sc += *(*(hmm->msc + sym) + *(tr->nodeidx + tpos));
        } else
        if ((int )*(tr->statetype + tpos) == 3) {
          tmp___4 = tolower((int )Alphabet[sym]);
          fprintf(fp, " %8d %c", *(*(hmm->isc + sym) + *(tr->nodeidx + tpos)), (int )((char )tmp___4));
          sc += *(*(hmm->isc + sym) + *(tr->nodeidx + tpos));
        } else
        if ((int )*(tr->statetype + tpos) == 5) {
          if ((int )*(tr->statetype + (tpos - 1)) == 5) {
            tmp___5 = tolower((int )Alphabet[sym]);
            fprintf(fp, " %8d %c", 0, (int )((char )tmp___5));
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if ((int )*(tr->statetype + tpos) == 8) {
          if ((int )*(tr->statetype + (tpos - 1)) == 8) {
            tmp___5 = tolower((int )Alphabet[sym]);
            fprintf(fp, " %8d %c", 0, (int )((char )tmp___5));
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if ((int )*(tr->statetype + tpos) == 10) {
          if ((int )*(tr->statetype + (tpos - 1)) == 10) {
            tmp___5 = tolower((int )Alphabet[sym]);
            fprintf(fp, " %8d %c", 0, (int )((char )tmp___5));
          }
        }
      } else {
        fprintf(fp, " %8s %c", "-", '-');
      }
      fputs("\n", fp);
      tpos ++;
    }
    fprintf(fp, "                 ------- --------\n");
    fprintf(fp, "           total: %6d\n\n", sc);
  }
  return;
}
}
void P7PrintPrior(FILE *fp , struct p7prior_s *pri ) 
{ 
  int q ;
  int x ;

  {
  if (pri->strategy == 0) {
    fputs("Dirichlet\n", fp);
  } else
  if (pri->strategy == 1) {
    fputs("PAM\n", fp);
  } else {
    Die((char *)"No such strategy.");
  }
  if (Alphabet_type == 3) {
    fputs("Amino\n", fp);
  } else
  if (Alphabet_type == 2) {
    fputs("Nucleic\n", fp);
  }
  fprintf(fp, "\n%d\n", pri->tnum);
  q = 0;
  while (q < pri->tnum) {
    fprintf(fp, "%.4f\n", (double )pri->tq[q]);
    x = 0;
    while (x < 7) {
      fprintf(fp, "%.4f ", (double )pri->t[q][x]);
      x ++;
    }
    fputs("\n", fp);
    q ++;
  }
  fprintf(fp, "\n%d\n", pri->mnum);
  q = 0;
  while (q < pri->mnum) {
    fprintf(fp, "%.4f\n", (double )pri->mq[q]);
    x = 0;
    while (x < Alphabet_size) {
      fprintf(fp, "%.4f ", (double )pri->m[q][x]);
      x ++;
    }
    fputs("\n", fp);
    q ++;
  }
  fprintf(fp, "\n%d\n", pri->inum);
  q = 0;
  while (q < pri->inum) {
    fprintf(fp, "%.4f\n", (double )pri->iq[q]);
    x = 0;
    while (x < Alphabet_size) {
      fprintf(fp, "%.4f ", (double )pri->i[q][x]);
      x ++;
    }
    fputs("\n", fp);
    q ++;
  }
  return;
}
}
int TraceVerify(struct p7trace_s *tr , int M , int N ) 
{ 
  int tpos ;
  int k ;
  int i___0 ;
  int nn ;
  int nc ;
  int nj ;
  int nm ;

  {
  if ((int )*(tr->statetype + 0) != 4) {
    return (0);
  }
  if ((int )*(tr->statetype + 1) != 5) {
    return (0);
  }
  if ((int )*(tr->statetype + (tr->tlen - 2)) != 8) {
    return (0);
  }
  if ((int )*(tr->statetype + (tr->tlen - 1)) != 9) {
    return (0);
  }
  if (*(tr->pos + 1) != 0) {
    return (0);
  }
  nm = 0;
  nj = nm;
  nc = nj;
  nn = nc;
  i___0 = nn;
  k = i___0;
  tpos = 0;
  while (tpos < tr->tlen) {
    switch ((int )*(tr->statetype + tpos)) {
    case 4: 
    if (*(tr->nodeidx + tpos) != 0) {
      return (0);
    }
    if (*(tr->pos + tpos) != 0) {
      return (0);
    }
    if (k != 0) {
      return (0);
    }
    if (i___0 != 0) {
      return (0);
    }
    if (tpos != 0) {
      return (0);
    }
    break;
    case 5: 
    if (*(tr->nodeidx + tpos) != 0) {
      return (0);
    }
    if (k != 0) {
      return (0);
    }
    if (nn > 0) {
      if (*(tr->pos + tpos) != i___0 + 1) {
        return (0);
      }
      i___0 ++;
    } else {
      if (*(tr->pos + tpos) != 0) {
        return (0);
      }
      if (i___0 != 0) {
        return (0);
      }
    }
    nn ++;
    break;
    case 6: 
    if (*(tr->nodeidx + tpos) != 0) {
      return (0);
    }
    if (*(tr->pos + tpos) != 0) {
      return (0);
    }
    nm = 0;
    break;
    case 1: 
    if (*(tr->pos + tpos) != i___0 + 1) {
      return (0);
    }
    if (*(tr->nodeidx + tpos) < 1) {
      return (0);
    } else
    if (*(tr->nodeidx + tpos) > M) {
      return (0);
    }
    i___0 ++;
    if (nm == 0) {
      k = *(tr->nodeidx + tpos);
    } else {
      if (*(tr->nodeidx + tpos) != k + 1) {
        return (0);
      }
      k ++;
    }
    nm ++;
    break;
    case 3: 
    if (*(tr->pos + tpos) != i___0 + 1) {
      return (0);
    }
    if (*(tr->nodeidx + tpos) != k) {
      return (0);
    }
    if (*(tr->nodeidx + tpos) < 1) {
      return (0);
    } else
    if (*(tr->nodeidx + tpos) > M - 1) {
      return (0);
    }
    if (k >= M) {
      return (0);
    }
    i___0 ++;
    break;
    case 2: 
    if (*(tr->pos + tpos) != 0) {
      return (0);
    }
    if (*(tr->nodeidx + tpos) != k + 1) {
      return (0);
    }
    if (*(tr->nodeidx + tpos) < 1) {
      return (0);
    } else
    if (*(tr->nodeidx + tpos) > M) {
      return (0);
    }
    k ++;
    break;
    case 7: 
    if (*(tr->nodeidx + tpos) != 0) {
      return (0);
    }
    if (*(tr->pos + tpos) != 0) {
      return (0);
    }
    nj = 0;
    break;
    case 10: 
    if (*(tr->nodeidx + tpos) != 0) {
      return (0);
    }
    if (nj > 0) {
      if (*(tr->pos + tpos) != i___0 + 1) {
        return (0);
      }
      i___0 ++;
    } else
    if (*(tr->pos + tpos) != 0) {
      return (0);
    }
    nj ++;
    break;
    case 8: 
    if (*(tr->nodeidx + tpos) != 0) {
      return (0);
    }
    if (nc > 0) {
      if (*(tr->pos + tpos) != i___0 + 1) {
        return (0);
      }
      i___0 ++;
    } else
    if (*(tr->pos + tpos) != 0) {
      return (0);
    }
    nc ++;
    break;
    case 9: 
    if (tpos != tr->tlen - 1) {
      return (0);
    }
    if (*(tr->nodeidx + tpos) != 0) {
      return (0);
    }
    if (*(tr->pos + tpos) != 0) {
      return (0);
    }
    if (i___0 != N) {
      return (0);
    }
    break;
    default: 
    return (0);
    }
    tpos ++;
  }
  return (1);
}
}
int TraceCompare(struct p7trace_s *t1 , struct p7trace_s *t2 ) 
{ 
  int tpos ;

  {
  if (t1->tlen != t2->tlen) {
    return (0);
  }
  tpos = 0;
  while (tpos < t1->tlen) {
    if ((int )*(t1->statetype + tpos) != (int )*(t2->statetype + tpos)) {
      return (0);
    }
    if (*(t1->nodeidx + tpos) != *(t2->nodeidx + tpos)) {
      return (0);
    }
    if (*(t1->pos + tpos) != *(t2->pos + tpos)) {
      return (0);
    }
    tpos ++;
  }
  return (1);
}
}
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-NrO9TnZt.i","-O3")
extern int ( /* format attribute */  printf)(char const   *  , ...) ;
extern void *calloc(size_t  , size_t  ) ;
void DisplayPlan7Matrix(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ) ;
void DisplayPlan7Posteriors(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                            struct dpmatrix_s *backward , struct p7trace_s *viterbi ,
                            struct p7trace_s *optacc ) ;
void DisplayPlan7PostAlign(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                           struct dpmatrix_s *backward , struct p7trace_s **alignment ,
                           int A ) ;
float Score2Prob(int sc , float null ) ;
void PrintIscore(int sc ) ;
void PrintTransition(char src , int isrc , int ksrc , char dest , int idest , int kdest ,
                     int sc , struct p7trace_s **alignment , int *min , int *max ,
                     int *on , int A ) ;
void DisplayPlan7Posteriors(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                            struct dpmatrix_s *backward , struct p7trace_s *viterbi ,
                            struct p7trace_s *optacc ) 
{ 
  struct p7trace_s *alignment[2] ;

  {
  alignment[0] = viterbi;
  alignment[1] = optacc;
  DisplayPlan7PostAlign(L, hmm, forward, backward, alignment, 2);
  return;
}
}
void DisplayPlan7PostAlign(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                           struct dpmatrix_s *backward , struct p7trace_s **alignment ,
                           int A ) 
{ 
  int sc ;
  int i___0 ;
  int j ;
  int k ;
  int kmin ;
  int kmax ;
  int *min ;
  int *max ;
  int *on ;
  char state ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  sc = *(*(forward->xmx + L) + 2) + hmm->xsc[2][0];
  tmp = calloc((size_t )A, sizeof(int ));
  min = (int *)tmp;
  tmp___0 = calloc((size_t )A, sizeof(int ));
  max = (int *)tmp___0;
  tmp___1 = calloc((size_t )A, sizeof(int ));
  on = (int *)tmp___1;
  i___0 = 0;
  while (i___0 <= L) {
    j = 0;
    while (j < A) {
      while (1) {
        if (*((*(alignment + j))->pos + *(min + j)) < i___0 - 1) {
          if (! (*(min + j) < (*(alignment + j))->tlen - 1)) {
            break;
          }
        } else {
          break;
        }
        (*(min + j)) ++;
      }
      while (1) {
        if (*((*(alignment + j))->pos + *(max + j)) <= i___0 + 1) {
          if (! (*(max + j) < (*(alignment + j))->tlen - 1)) {
            break;
          }
        } else {
          break;
        }
        (*(max + j)) ++;
      }
      j ++;
    }
    state = (char)1;
    while ((int )state <= 10) {
      if ((int )state == 1) {
        kmin = 1;
        kmax = hmm->M;
      } else
      if ((int )state == 6) {
        kmin = 1;
        kmax = hmm->M;
      } else
      if ((int )state == 2) {
        kmin = 2;
        kmax = hmm->M - 1;
      } else
      if ((int )state == 3) {
        kmin = 1;
        kmax = hmm->M - 1;
      } else {
        kmax = 0;
        kmin = kmax;
      }
      k = kmin;
      while (k <= kmax) {
        switch ((int )state) {
        case 1: 
        if (i___0 < L) {
          if (k < hmm->M) {
            PrintTransition((char)1, i___0, k, (char)1, i___0 + 1, k + 1, ((*(*(forward->mmx + i___0) + k) + *(*(hmm->tsc + 0) + k)) + *(*(backward->mmx + (i___0 + 1)) + (k + 1))) - sc,
                            alignment, min, max, on, A);
          }
        }
        if (i___0 < L) {
          if (k < hmm->M) {
            PrintTransition((char)1, i___0, k, (char)3, i___0 + 1, k, ((*(*(forward->mmx + i___0) + k) + *(*(hmm->tsc + 1) + k)) + *(*(backward->imx + (i___0 + 1)) + k)) - sc,
                            alignment, min, max, on, A);
          }
        }
        if (k < hmm->M - 1) {
          PrintTransition((char)1, i___0, k, (char)2, i___0, k + 1, ((*(*(forward->mmx + i___0) + k) + *(*(hmm->tsc + 2) + k)) + *(*(backward->dmx + i___0) + (k + 1))) - sc,
                          alignment, min, max, on, A);
        }
        PrintTransition((char)1, i___0, k, (char)7, i___0, 0, ((*(*(forward->mmx + i___0) + k) + *(hmm->esc + k)) + *(*(backward->xmx + i___0) + 1)) - sc,
                        alignment, min, max, on, A);
        break;
        case 2: 
        if (i___0 < L) {
          PrintTransition((char)2, i___0, k, (char)1, i___0 + 1, k + 1, ((*(*(forward->dmx + i___0) + k) + *(*(hmm->tsc + 5) + k)) + *(*(backward->mmx + (i___0 + 1)) + (k + 1))) - sc,
                          alignment, min, max, on, A);
        }
        PrintTransition((char)2, i___0, k, (char)2, i___0, k + 1, ((*(*(forward->dmx + i___0) + k) + *(*(hmm->tsc + 6) + k)) + *(*(backward->dmx + i___0) + (k + 1))) - sc,
                        alignment, min, max, on, A);
        break;
        case 3: 
        if (i___0 < L) {
          PrintTransition((char)3, i___0, k, (char)1, i___0 + 1, k + 1, ((*(*(forward->imx + i___0) + k) + *(*(hmm->tsc + 3) + k)) + *(*(backward->mmx + (i___0 + 1)) + (k + 1))) - sc,
                          alignment, min, max, on, A);
        }
        if (i___0 < L) {
          PrintTransition((char)3, i___0, k, (char)3, i___0 + 1, k, ((*(*(forward->imx + i___0) + k) + *(*(hmm->tsc + 4) + k)) + *(*(backward->imx + (i___0 + 1)) + k)) - sc,
                          alignment, min, max, on, A);
        }
        break;
        case 6: 
        if (i___0 < L) {
          PrintTransition((char)6, i___0, 0, (char)1, i___0 + 1, k, ((*(*(forward->xmx + i___0) + 0) + *(hmm->bsc + k)) + *(*(backward->mmx + (i___0 + 1)) + k)) - sc,
                          alignment, min, max, on, A);
        }
        break;
        default: 
        break;
        }
        k ++;
      }
      switch ((int )state) {
      case 5: 
      PrintTransition((char)5, i___0, 0, (char)6, i___0, 0, ((*(*(forward->xmx + i___0) + 4) + hmm->xsc[0][0]) + *(*(backward->xmx + i___0) + 0)) - sc,
                      alignment, min, max, on, A);
      if (i___0 < L) {
        PrintTransition((char)5, i___0, 0, (char)5, i___0 + 1, 0, ((*(*(forward->xmx + i___0) + 4) + hmm->xsc[0][1]) + *(*(backward->xmx + (i___0 + 1)) + 4)) - sc,
                        alignment, min, max, on, A);
      }
      break;
      case 10: 
      PrintTransition((char)10, i___0, 0, (char)6, i___0, 0, ((*(*(forward->xmx + i___0) + 3) + hmm->xsc[3][0]) + *(*(backward->xmx + i___0) + 0)) - sc,
                      alignment, min, max, on, A);
      if (i___0 < L) {
        PrintTransition((char)10, i___0, 0, (char)10, i___0 + 1, 0, ((*(*(forward->xmx + i___0) + 3) + hmm->xsc[3][1]) + *(*(backward->xmx + (i___0 + 1)) + 3)) - sc,
                        alignment, min, max, on, A);
      }
      break;
      case 8: 
      PrintTransition((char)8, i___0, 0, (char)9, i___0, 0, (*(*(forward->xmx + i___0) + 2) + hmm->xsc[2][0]) - sc,
                      alignment, min, max, on, A);
      if (i___0 < L) {
        PrintTransition((char)8, i___0, 0, (char)8, i___0 + 1, 0, ((*(*(forward->xmx + i___0) + 2) + hmm->xsc[2][1]) + *(*(backward->xmx + (i___0 + 1)) + 2)) - sc,
                        alignment, min, max, on, A);
      }
      break;
      case 7: 
      PrintTransition((char)7, i___0, 0, (char)8, i___0, 0, ((*(*(forward->xmx + i___0) + 1) + hmm->xsc[1][0]) + *(*(backward->xmx + i___0) + 2)) - sc,
                      alignment, min, max, on, A);
      PrintTransition((char)7, i___0, 0, (char)10, i___0, 0, ((*(*(forward->xmx + i___0) + 1) + hmm->xsc[1][1]) + *(*(backward->xmx + i___0) + 3)) - sc,
                      alignment, min, max, on, A);
      break;
      case 4: 
      if (i___0 == 0) {
        PrintTransition((char)4, i___0, 0, (char)5, i___0, 0, *(*(backward->xmx + i___0) + 4) - sc,
                        alignment, min, max, on, A);
      }
      break;
      case 9: 
      case 6: 
      case 3: 
      case 2: 
      case 1: 
      break;
      default: 
      Die((char *)"unknown state");
      }
      state = (char )((int )state + 1);
    }
    i___0 ++;
  }
  free((void *)min);
  free((void *)max);
  free((void *)on);
  return;
}
}
void DisplayPlan7Matrix(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ) 
{ 
  int i___0 ;
  int k ;

  {
  printf("         *      ");
  i___0 = 1;
  while (i___0 <= L) {
    printf("    %c      ", (int )Alphabet[(int )*(dsq + i___0)]);
    i___0 ++;
  }
  printf("\nN    ");
  i___0 = 0;
  while (i___0 <= L) {
    PrintIscore(*(*(mx->xmx + i___0) + 4));
    i___0 ++;
  }
  k = 1;
  while (k <= hmm->M) {
    printf("\nM%-3d ", k);
    i___0 = 0;
    while (i___0 <= L) {
      PrintIscore(*(*(mx->mmx + i___0) + k));
      i___0 ++;
    }
    k ++;
  }
  k = 1;
  while (k < hmm->M) {
    printf("\nI%-3d ", k);
    i___0 = 0;
    while (i___0 <= L) {
      PrintIscore(*(*(mx->imx + i___0) + k));
      i___0 ++;
    }
    k ++;
  }
  printf("\nE    ");
  i___0 = 0;
  while (i___0 <= L) {
    PrintIscore(*(*(mx->xmx + i___0) + 1));
    i___0 ++;
  }
  printf("\nC    ");
  i___0 = 0;
  while (i___0 <= L) {
    PrintIscore(*(*(mx->xmx + i___0) + 2));
    i___0 ++;
  }
  printf("\nJ    ");
  i___0 = 0;
  while (i___0 <= L) {
    PrintIscore(*(*(mx->xmx + i___0) + 3));
    i___0 ++;
  }
  printf("\nB    ");
  i___0 = 0;
  while (i___0 <= L) {
    PrintIscore(*(*(mx->xmx + i___0) + 0));
    i___0 ++;
  }
  k = 2;
  while (k < hmm->M) {
    printf("\nD%-3d ", k);
    i___0 = 0;
    while (i___0 <= L) {
      PrintIscore(*(*(mx->dmx + i___0) + k));
      i___0 ++;
    }
    k ++;
  }
  printf("\n\n");
  return;
}
}
void PrintIscore(int sc ) 
{ 
  double dsc ;
  double div___0 ;

  {
  dsc = (double )sc;
  div___0 = 1000.0 / 0.693147180559945;
  dsc /= div___0;
  printf("%- #11.3e", dsc);
  return;
}
}
void PrintTransition(char src , int isrc , int ksrc , char dest , int idest , int kdest ,
                     int sc , struct p7trace_s **alignment , int *min , int *max ,
                     int *on , int A ) 
{ 
  char src_str[6] ;
  char dest_str[6] ;
  int j ;
  int tpos ;
  int tnext ;
  int pos ;
  int next ;
  int near ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  unsigned long tmp___18 ;
  float tmp___19 ;

  {
  near = 0;
  j = 0;
  while (j < A) {
    *(on + j) = 0;
    pos = 0;
    tpos = *(min + j);
    while (tpos <= *(max + j)) {
      if (*((*(alignment + j))->pos + tpos) != 0) {
        pos = *((*(alignment + j))->pos + tpos);
      }
      if ((int )src == (int )*((*(alignment + j))->statetype + tpos)) {
        if (ksrc == *((*(alignment + j))->nodeidx + tpos)) {
          if (isrc == pos) {
            near = 1;
          }
        }
      }
      if ((int )dest == (int )*((*(alignment + j))->statetype + tpos)) {
        if (kdest == *((*(alignment + j))->nodeidx + tpos)) {
          if (idest == pos) {
            near = 1;
          }
        }
      }
      if (tpos < (*(alignment + j))->tlen - 1) {
        tnext = tpos + 1;
        if ((int )*((*(alignment + j))->statetype + tpos) == 6) {
          while (1) {
            if ((int )*((*(alignment + j))->statetype + tnext) == 2) {
              if (! (tnext < (*(alignment + j))->tlen - 1)) {
                break;
              }
            } else {
              break;
            }
            tnext ++;
          }
        }
        next = *((*(alignment + j))->pos + tnext);
        if (next == 0) {
          next = pos;
        }
        if ((int )src == (int )*((*(alignment + j))->statetype + tpos)) {
          if (ksrc == *((*(alignment + j))->nodeidx + tpos)) {
            if (isrc == pos) {
              if ((int )dest == (int )*((*(alignment + j))->statetype + tnext)) {
                if (kdest == *((*(alignment + j))->nodeidx + tnext)) {
                  if (idest == next) {
                    *(on + j) = 1;
                  }
                }
              }
            }
          }
        }
      }
      tpos ++;
    }
    j ++;
  }
  if (! near) {
    return;
  }
  switch ((int )src) {
  case 1: 
  tmp = __builtin_object_size((void *)(src_str), 1);
  __builtin___sprintf_chk(src_str, 0, tmp, "M%d", ksrc);
  break;
  case 2: 
  tmp___0 = __builtin_object_size((void *)(src_str), 1);
  __builtin___sprintf_chk(src_str, 0, tmp___0, "D%d", ksrc);
  break;
  case 3: 
  tmp___1 = __builtin_object_size((void *)(src_str), 1);
  __builtin___sprintf_chk(src_str, 0, tmp___1, "I%d", ksrc);
  break;
  case 4: 
  tmp___2 = __builtin_object_size((void *)(src_str), 1);
  __builtin___sprintf_chk(src_str, 0, tmp___2, "S");
  break;
  case 5: 
  tmp___3 = __builtin_object_size((void *)(src_str), 1);
  __builtin___sprintf_chk(src_str, 0, tmp___3, "N");
  break;
  case 6: 
  tmp___4 = __builtin_object_size((void *)(src_str), 1);
  __builtin___sprintf_chk(src_str, 0, tmp___4, "B");
  break;
  case 7: 
  tmp___5 = __builtin_object_size((void *)(src_str), 1);
  __builtin___sprintf_chk(src_str, 0, tmp___5, "E");
  break;
  case 8: 
  tmp___6 = __builtin_object_size((void *)(src_str), 1);
  __builtin___sprintf_chk(src_str, 0, tmp___6, "C");
  break;
  case 10: 
  tmp___7 = __builtin_object_size((void *)(src_str), 1);
  __builtin___sprintf_chk(src_str, 0, tmp___7, "J");
  break;
  case 9: 
  tmp___8 = __builtin_object_size((void *)(src_str), 1);
  __builtin___sprintf_chk(src_str, 0, tmp___8, "T");
  break;
  default: 
  Die((char *)"bad transition");
  }
  switch ((int )dest) {
  case 1: 
  tmp___9 = __builtin_object_size((void *)(dest_str), 1);
  __builtin___sprintf_chk(dest_str, 0, tmp___9, "M%d", kdest);
  break;
  case 2: 
  tmp___10 = __builtin_object_size((void *)(dest_str), 1);
  __builtin___sprintf_chk(dest_str, 0, tmp___10, "D%d", kdest);
  break;
  case 3: 
  tmp___11 = __builtin_object_size((void *)(dest_str), 1);
  __builtin___sprintf_chk(dest_str, 0, tmp___11, "I%d", kdest);
  break;
  case 4: 
  tmp___12 = __builtin_object_size((void *)(dest_str), 1);
  __builtin___sprintf_chk(dest_str, 0, tmp___12, "S");
  break;
  case 5: 
  tmp___13 = __builtin_object_size((void *)(dest_str), 1);
  __builtin___sprintf_chk(dest_str, 0, tmp___13, "N");
  break;
  case 6: 
  tmp___14 = __builtin_object_size((void *)(dest_str), 1);
  __builtin___sprintf_chk(dest_str, 0, tmp___14, "B");
  break;
  case 7: 
  tmp___15 = __builtin_object_size((void *)(dest_str), 1);
  __builtin___sprintf_chk(dest_str, 0, tmp___15, "E");
  break;
  case 8: 
  tmp___16 = __builtin_object_size((void *)(dest_str), 1);
  __builtin___sprintf_chk(dest_str, 0, tmp___16, "C");
  break;
  case 10: 
  tmp___17 = __builtin_object_size((void *)(dest_str), 1);
  __builtin___sprintf_chk(dest_str, 0, tmp___17, "J");
  break;
  case 9: 
  tmp___18 = __builtin_object_size((void *)(dest_str), 1);
  __builtin___sprintf_chk(dest_str, 0, tmp___18, "T");
  break;
  default: 
  Die((char *)"bad transition");
  }
  tmp___19 = Score2Prob(sc, (float )1.);
  printf("%d\t%s\t%d\t%s\t%-14.7g\t", isrc, src_str, idest, dest_str, (double )tmp___19);
  j = 0;
  while (j < A) {
    if (*(on + j)) {
      printf("*");
    }
    if (j < A - 1) {
      printf("\t");
    }
    j ++;
  }
  printf("\n");
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-CEQ9DJvn.i","-O3")
int FChoose(float *p , int N ) ;
void FCopy(float *vec1 , float *vec2 , int n ) ;
void EmitSequence(struct plan7_s *hmm , char **ret_dsq , int *ret_L , struct p7trace_s **ret_tr ) ;
void EmitConsensusSequence(struct plan7_s *hmm , char **ret_seq , char **ret_dsq ,
                           int *ret_L , struct p7trace_s **ret_tr ) ;
void StateOccupancy(struct plan7_s *hmm , float **ret_mp , float **ret_ip , float **ret_dp ) ;
void TraceSet(struct p7trace_s *tr , int tpos , char type , int idx , int pos ) ;
void EmitSequence(struct plan7_s *hmm , char **ret_dsq , int *ret_L , struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  char type ;
  int k ;
  char *dsq ;
  int L ;
  int alloc_tlen ;
  int alloc_L ;
  int tpos ;
  int sym ;
  float t___0[4] ;
  void *tmp ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___9 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;

  {
  P7AllocTrace(64, & tr);
  alloc_tlen = 64;
  tmp = sre_malloc((char *)"emit.c", 59, sizeof(char ) * 64UL);
  dsq = (char *)tmp;
  alloc_L = 64;
  TraceSet(tr, 0, (char)4, 0, 0);
  TraceSet(tr, 1, (char)5, 0, 0);
  *(dsq + 0) = (char )Alphabet_iupac;
  L = 1;
  k = 0;
  type = (char)5;
  tpos = 2;
  while ((int )type != 9) {
    switch ((int )type) {
    case 6: 
    *(hmm->begin + 0) = hmm->tbd1;
    k = FChoose(hmm->begin, hmm->M + 1);
    if (k == 0) {
      type = (char)2;
      k = 1;
    } else {
      type = (char)1;
    }
    break;
    case 3: 
    tmp___1 = FChoose(*(hmm->t + k) + 3, 2);
    if (tmp___1 == 0) {
      type = (char)1;
    } else {
      type = (char)3;
    }
    if ((int )type == 1) {
      k ++;
    }
    break;
    case 5: 
    tmp___3 = FChoose(hmm->xt[0], 2);
    if (tmp___3 == 1) {
      type = (char)5;
    } else {
      type = (char)6;
    }
    k = 0;
    break;
    case 7: 
    tmp___5 = FChoose(hmm->xt[1], 2);
    if (tmp___5 == 1) {
      type = (char)10;
    } else {
      type = (char)8;
    }
    k = 0;
    break;
    case 8: 
    tmp___7 = FChoose(hmm->xt[2], 2);
    if (tmp___7 == 1) {
      type = (char)8;
    } else {
      type = (char)9;
    }
    k = 0;
    break;
    case 10: 
    tmp___9 = FChoose(hmm->xt[3], 2);
    if (tmp___9 == 1) {
      type = (char)10;
    } else {
      type = (char)6;
    }
    k = 0;
    break;
    case 2: 
    if (k < hmm->M) {
      tmp___11 = FChoose(*(hmm->t + k) + 5, 2);
      if (tmp___11 == 0) {
        type = (char)1;
      } else {
        type = (char)2;
      }
      k ++;
    } else {
      type = (char)7;
      k = 0;
    }
    break;
    case 1: 
    if (k < hmm->M) {
      FCopy(t___0, *(hmm->t + k), 3);
      t___0[3] = *(hmm->end + k);
      tmp___12 = FChoose(t___0, 4);
      switch (tmp___12) {
      case 0: 
      k ++;
      type = (char)1;
      break;
      case 1: 
      type = (char)3;
      break;
      case 2: 
      k ++;
      type = (char)2;
      break;
      case 3: 
      k = 0;
      type = (char)7;
      break;
      default: 
      Die((char *)"never happens");
      }
    } else {
      k = 0;
      type = (char)7;
    }
    break;
    default: 
    Die((char *)"can\'t happen.");
    }
    sym = -1;
    if ((int )type == 1) {
      sym = FChoose(*(hmm->mat + k), Alphabet_size);
    } else
    if ((int )type == 3) {
      sym = FChoose(*(hmm->ins + k), Alphabet_size);
    } else
    if ((int )type == 5) {
      if ((int )*(tr->statetype + (tpos - 1)) == 5) {
        sym = FChoose(hmm->null, Alphabet_size);
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if ((int )type == 8) {
      if ((int )*(tr->statetype + (tpos - 1)) == 8) {
        sym = FChoose(hmm->null, Alphabet_size);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((int )type == 10) {
      if ((int )*(tr->statetype + (tpos - 1)) == 10) {
        sym = FChoose(hmm->null, Alphabet_size);
      }
    }
    if (sym != -1) {
      tmp___13 = L;
    } else {
      tmp___13 = 0;
    }
    TraceSet(tr, tpos, type, k, tmp___13);
    tpos ++;
    if (tpos == alloc_tlen) {
      alloc_tlen += 64;
      P7ReallocTrace(tr, alloc_tlen);
    }
    if (sym != -1) {
      *(dsq + L) = (char )sym;
      L ++;
      if (L + 1 == alloc_L) {
        alloc_L += 64;
        tmp___14 = sre_realloc((char *)"emit.c", 146, (void *)dsq, sizeof(char ) * (unsigned long )alloc_L);
        dsq = (char *)tmp___14;
      }
    }
  }
  tr->tlen = tpos;
  *(dsq + L) = (char )Alphabet_iupac;
  *(dsq + (L + 1)) = (char )'\000';
  L --;
  if ((unsigned long )ret_dsq != (unsigned long )((void *)0)) {
    *ret_dsq = dsq;
  } else {
    free((void *)dsq);
  }
  if ((unsigned long )ret_L != (unsigned long )((void *)0)) {
    *ret_L = L;
  }
  if ((unsigned long )ret_tr != (unsigned long )((void *)0)) {
    *ret_tr = tr;
  } else {
    P7FreeTrace(tr);
  }
  return;
}
}
void EmitConsensusSequence(struct plan7_s *hmm , char **ret_seq , char **ret_dsq ,
                           int *ret_L , struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  char *dsq ;
  char *seq ;
  float *mp ;
  float *ip ;
  float *dp ;
  int nmat ;
  int ndel ;
  int nins ;
  int k ;
  int tpos ;
  int i___0 ;
  int x ;
  float mthresh___0 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (Alphabet_type == 3) {
    mthresh___0 = (float )0.5;
  } else {
    mthresh___0 = (float )0.9;
  }
  StateOccupancy(hmm, & mp, & ip, & dp);
  nins = 0;
  ndel = nins;
  nmat = ndel;
  k = 1;
  while (k <= hmm->M) {
    if ((double )*(mp + k) >= 0.5) {
      nmat ++;
    } else {
      ndel ++;
    }
    if (k < hmm->M) {
      if ((double )*(ip + k) >= 0.5) {
        nins += (int )(1.f / (1.f - *(*(hmm->t + k) + 4)));
      }
    }
    k ++;
  }
  P7AllocTrace(((6 + nmat) + ndel) + nins, & tr);
  tmp = sre_malloc((char *)"emit.c", 327, sizeof(char ) * (unsigned long )((nmat + nins) + 3));
  dsq = (char *)tmp;
  tmp___0 = sre_malloc((char *)"emit.c", 328, sizeof(char ) * (unsigned long )((nmat + nins) + 1));
  seq = (char *)tmp___0;
  TraceSet(tr, 0, (char)4, 0, 0);
  TraceSet(tr, 1, (char)5, 0, 0);
  TraceSet(tr, 2, (char)6, 0, 0);
  *(dsq + 0) = (char )Alphabet_iupac;
  tpos = 3;
  i___0 = 0;
  k = 1;
  while (k <= hmm->M) {
    if ((double )*(mp + k) >= 0.5) {
      x = FArgMax(*(hmm->mat + k), Alphabet_size);
      TraceSet(tr, tpos, (char)1, k, i___0 + 1);
      *(seq + i___0) = Alphabet[x];
      *(dsq + (i___0 + 1)) = (char )x;
      if (*(*(hmm->mat + k) + x) < mthresh___0) {
        tmp___1 = tolower((int )*(seq + i___0));
        *(seq + i___0) = (char )tmp___1;
      }
      i___0 ++;
      tpos ++;
    } else {
      TraceSet(tr, tpos, (char)2, k, 0);
      tpos ++;
    }
    if (k < hmm->M) {
      if ((double )*(ip + k) >= 0.5) {
        x = (int )(1.f / (1.f - *(*(hmm->t + k) + 4)));
        while (1) {
          tmp___2 = x;
          x --;
          if (! tmp___2) {
            break;
          }
          TraceSet(tr, tpos, (char)3, k, i___0 + 1);
          *(seq + i___0) = (char )'x';
          *(dsq + (i___0 + 1)) = (char )(Alphabet_iupac - 1);
          i___0 ++;
          tpos ++;
        }
      }
    }
    k ++;
  }
  TraceSet(tr, tpos, (char)7, 0, 0);
  tpos ++;
  TraceSet(tr, tpos, (char)8, 0, 0);
  tpos ++;
  TraceSet(tr, tpos, (char)9, 0, 0);
  tpos ++;
  *(dsq + (i___0 + 1)) = (char )Alphabet_iupac;
  free((void *)mp);
  free((void *)ip);
  free((void *)dp);
  if ((unsigned long )ret_seq != (unsigned long )((void *)0)) {
    *ret_seq = seq;
  } else {
    free((void *)seq);
  }
  if ((unsigned long )ret_dsq != (unsigned long )((void *)0)) {
    *ret_dsq = dsq;
  } else {
    free((void *)dsq);
  }
  if ((unsigned long )ret_L != (unsigned long )((void *)0)) {
    *ret_L = i___0;
  }
  if ((unsigned long )ret_tr != (unsigned long )((void *)0)) {
    *ret_tr = tr;
  } else {
    P7FreeTrace(tr);
  }
  return;
}
}
void StateOccupancy(struct plan7_s *hmm , float **ret_mp , float **ret_ip , float **ret_dp ) 
{ 
  float *fmp ;
  float *fip ;
  float *fdp ;
  int k ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = sre_malloc((char *)"emit.c", 414, sizeof(float ) * (unsigned long )(hmm->M + 1));
  fmp = (float *)tmp;
  tmp___0 = sre_malloc((char *)"emit.c", 415, sizeof(float ) * (unsigned long )hmm->M);
  fip = (float *)tmp___0;
  tmp___1 = sre_malloc((char *)"emit.c", 416, sizeof(float ) * (unsigned long )(hmm->M + 1));
  fdp = (float *)tmp___1;
  *(fdp + 1) = hmm->tbd1;
  *(fmp + 1) = *(hmm->begin + 1);
  *(fip + 1) = *(fmp + 1) * *(*(hmm->t + 1) + 1);
  k = 2;
  while (k <= hmm->M) {
    *(fmp + k) = ((*(fmp + (k - 1)) * *(*(hmm->t + (k - 1)) + 0) + *(fip + (k - 1))) + *(fdp + (k - 1)) * *(*(hmm->t + (k - 1)) + 5)) + *(hmm->begin + k);
    *(fdp + k) = *(fmp + (k - 1)) * *(*(hmm->t + (k - 1)) + 2) + *(fdp + (k - 1)) * *(*(hmm->t + (k - 1)) + 6);
    if (k < hmm->M) {
      *(fip + k) = *(fmp + k) * *(*(hmm->t + k) + 1);
    }
    *(fmp + k) /= *(fmp + k) + *(fdp + k);
    *(fdp + k) /= *(fmp + k) + *(fdp + k);
    k ++;
  }
  *ret_mp = fmp;
  *ret_dp = fdp;
  *ret_ip = fip;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-9xyEOfe1.i","-O3")
void WriteProfile(FILE *fp , struct plan7_s *hmm , int do_xsw ) ;
void P7Logoddsify(struct plan7_s *hmm , int viterbi_mode ) ;
void WriteProfile(FILE *fp , struct plan7_s *hmm , int do_xsw ) 
{ 
  int k ;
  int x ;
  int sc ;
  float nx ;
  int gap ;
  int len ;
  int qgap ;
  int qlen ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  P7Logoddsify(hmm, 1);
  if (hmm->M > 1000) {
    if (! do_xsw) {
      Warn((char *)"Profile %s will have more than 1000 positions. GCG won\'t read it; Compugen will.",
           hmm->name);
    }
  }
  if (Alphabet_type == 3) {
    fprintf(fp, "!!AA_PROFILE 1.0\n");
  } else
  if (Alphabet_type == 2) {
    fprintf(fp, "!!NA_PROFILE 1.0\n");
  } else {
    Die((char *)"No support for profiles with non-biological alphabets");
  }
  if (Alphabet_type == 3) {
    fprintf(fp, "(Peptide) ");
  } else
  if (Alphabet_type == 2) {
    fprintf(fp, "(Nucleotide) ");
  }
  if (hmm->flags & (1 << 1)) {
    tmp = (char const   *)hmm->desc;
  } else {
    tmp = "";
  }
  if (hmm->flags & (1 << 9)) {
    tmp___0 = (char const   *)hmm->acc;
  } else {
    tmp___0 = "";
  }
  fprintf(fp, "HMMCONVERT v%s Length: %d %s|%s|%s\n", "2.3", hmm->M, hmm->name, tmp___0,
          tmp);
  if (do_xsw) {
    fprintf(fp, "   Profile converted from a profile HMM using HMMER v%s emulation.\n",
            "2.3");
    fprintf(fp, "   Compugen XSW extended profile format.\n");
    fprintf(fp, "   Use -model=xsw.model -nonor -noave -gapop=10 -gapext=1 -qgapop=10 -qgapext=1\n");
    fprintf(fp, "      with om on the Compugen BIC to get the closest approximation to HMMER bit scores.\n");
    fprintf(fp, "   WARNING: There is a loss of information in this conversion.\n");
    fprintf(fp, "      Neither the scores nor even the rank order of hits will be precisely\n");
    fprintf(fp, "      preserved in a comparison of HMMER hmmsearch to GCG profilesearch.\n");
    fprintf(fp, "      The profile score is an approximation of the (single-hit) HMMER score.\n\n");
  } else {
    fprintf(fp, "   Profile converted from a profile HMM using HMMER v%s emulation.\n",
            "2.3");
    fprintf(fp, "   Use -nonor -noave -gap=10 -len=1 with profilesearch and friends\n");
    fprintf(fp, "      to get the closest approximation to HMMER bit scores.\n");
    fprintf(fp, "   WARNING: There is a loss of information in this conversion.\n");
    fprintf(fp, "      Neither the scores nor even the rank order of hits will be precisely\n");
    fprintf(fp, "      preserved in a comparison of HMMER hmmsearch to GCG profilesearch.\n");
    fprintf(fp, "      The profile score is an approximation of the (single-hit) HMMER score.\n\n");
  }
  fprintf(fp, "Cons");
  x = 0;
  while (x < Alphabet_iupac) {
    fprintf(fp, "    %c ", (int )Alphabet[x]);
    x ++;
  }
  if (do_xsw) {
    fprintf(fp, "  Gap   Len  QGap  Qlen ..\n");
  } else {
    fprintf(fp, "  Gap   Len ..\n");
  }
  k = 1;
  while (k <= hmm->M) {
    if ((k - 1) % 10 == 0) {
      if (k > 10) {
        fprintf(fp, "! %d\n", k);
      }
    }
    x = FArgMax(*(hmm->mat + k), Alphabet_size);
    fprintf(fp, " %c  ", (int )Alphabet[x]);
    x = 0;
    while (x < Alphabet_iupac) {
      sc = *(*(hmm->msc + x) + k);
      if (k < hmm->M) {
        sc += *(*(hmm->tsc + 0) + k);
      }
      sc = (int )((double )(sc * 100) / 1000.0);
      fprintf(fp, "%5d ", sc);
      x ++;
    }
    if (k > 1) {
      gap = -1 * (((*(*(hmm->tsc + 1) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1))) - *(*(hmm->tsc + 0) + (k - 1))) - *(*(hmm->tsc + 4) + (k - 1)));
      gap = (int )((double )(gap * 100) / (10.0 * 1000.0));
    } else {
      gap = 100;
    }
    if (k > 1) {
      len = -1 * *(*(hmm->tsc + 4) + (k - 1));
      len = (int )((double )(len * 100) / (1.0 * 1000.0));
    } else {
      len = 100;
    }
    if (k > 1) {
      qgap = -1 * (((*(*(hmm->tsc + 5) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1))) - *(*(hmm->tsc + 0) + (k - 1))) - *(*(hmm->tsc + 6) + (k - 1)));
      qgap = (int )((double )(qgap * 100) / (10.0 * 1000.0));
    } else {
      qgap = 100;
    }
    if (k > 1) {
      qlen = -1 * *(*(hmm->tsc + 6) + (k - 1));
      qlen = (int )((double )(qlen * 100) / (1.0 * 1000.0));
    } else {
      qlen = 100;
    }
    if (do_xsw) {
      fprintf(fp, "%5d %5d %5d %5d\n", gap, len, qgap, qlen);
    } else {
      fprintf(fp, "%5d %5d\n", gap, len);
    }
    k ++;
  }
  fprintf(fp, " *  ");
  x = 0;
  while (x < Alphabet_size) {
    nx = (float )0.0;
    k = 1;
    while (k <= hmm->M) {
      nx += *(*(hmm->mat + k) + x);
      k ++;
    }
    nx *= (float )hmm->nseq;
    fprintf(fp, "%5d ", (int )nx);
    x ++;
  }
  while (x < Alphabet_iupac) {
    fprintf(fp, "%5d ", 0);
    x ++;
  }
  fprintf(fp, "\n");
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-zGQcKvEH.i","-O3")
float P7Viterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ,
                struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int i___0 ;
  int k ;
  int sc ;
  int *mc ;
  int *dc ;
  int *ic ;
  int *ms ;
  int *is ;
  int *mpp ;
  int *mpc ;
  int *ip ;
  int *bp ;
  int *ep ;
  int xmb ;
  int xme ;
  int *dpp ;
  int *tpmm ;
  int *tpmi ;
  int *tpmd ;
  int *tpim ;
  int *tpii ;
  int *tpdm ;
  int *tpdd ;
  int M ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  float tmp___3 ;

  {
  ResizePlan7Matrix(mx, L, hmm->M, & xmx, & mmx, & imx, & dmx);
  *(*(xmx + 0) + 4) = 0;
  *(*(xmx + 0) + 0) = hmm->xsc[0][0];
  tmp___0 = -987654321;
  *(*(xmx + 0) + 3) = tmp___0;
  tmp = tmp___0;
  *(*(xmx + 0) + 2) = tmp;
  *(*(xmx + 0) + 1) = tmp;
  k = 0;
  while (k <= hmm->M) {
    tmp___2 = -987654321;
    *(*(dmx + 0) + k) = tmp___2;
    tmp___1 = tmp___2;
    *(*(imx + 0) + k) = tmp___1;
    *(*(mmx + 0) + k) = tmp___1;
    k ++;
  }
  M = hmm->M;
  tpmm = *(hmm->tsc + 0);
  tpim = *(hmm->tsc + 3);
  tpdm = *(hmm->tsc + 5);
  tpmd = *(hmm->tsc + 2);
  tpdd = *(hmm->tsc + 6);
  tpmi = *(hmm->tsc + 1);
  tpii = *(hmm->tsc + 4);
  bp = hmm->bsc;
  i___0 = 1;
  while (i___0 <= L) {
    mc = *(mmx + i___0);
    dc = *(dmx + i___0);
    ic = *(imx + i___0);
    mpp = *(mmx + (i___0 - 1));
    dpp = *(dmx + (i___0 - 1));
    ip = *(imx + (i___0 - 1));
    xmb = *(*(xmx + (i___0 - 1)) + 0);
    ms = *(hmm->msc + (int )*(dsq + i___0));
    is = *(hmm->isc + (int )*(dsq + i___0));
    *(mc + 0) = -987654321;
    *(dc + 0) = -987654321;
    *(ic + 0) = -987654321;
    k = 1;
    while (k <= M) {
      *(mc + k) = *(mpp + (k - 1)) + *(tpmm + (k - 1));
      sc = *(ip + (k - 1)) + *(tpim + (k - 1));
      if (sc > *(mc + k)) {
        *(mc + k) = sc;
      }
      sc = *(dpp + (k - 1)) + *(tpdm + (k - 1));
      if (sc > *(mc + k)) {
        *(mc + k) = sc;
      }
      sc = xmb + *(bp + k);
      if (sc > *(mc + k)) {
        *(mc + k) = sc;
      }
      *(mc + k) += *(ms + k);
      if (*(mc + k) < -987654321) {
        *(mc + k) = -987654321;
      }
      *(dc + k) = *(dc + (k - 1)) + *(tpdd + (k - 1));
      sc = *(mc + (k - 1)) + *(tpmd + (k - 1));
      if (sc > *(dc + k)) {
        *(dc + k) = sc;
      }
      if (*(dc + k) < -987654321) {
        *(dc + k) = -987654321;
      }
      if (k < M) {
        *(ic + k) = *(mpp + k) + *(tpmi + k);
        sc = *(ip + k) + *(tpii + k);
        if (sc > *(ic + k)) {
          *(ic + k) = sc;
        }
        *(ic + k) += *(is + k);
        if (*(ic + k) < -987654321) {
          *(ic + k) = -987654321;
        }
      }
      k ++;
    }
    *(*(xmx + i___0) + 4) = -987654321;
    sc = *(*(xmx + (i___0 - 1)) + 4) + hmm->xsc[0][1];
    if (sc > -987654321) {
      *(*(xmx + i___0) + 4) = sc;
    }
    xme = -987654321;
    mpc = *(mmx + i___0);
    ep = hmm->esc;
    k = 1;
    while (k <= hmm->M) {
      sc = *(mpc + k) + *(ep + k);
      if (sc > xme) {
        xme = sc;
      }
      k ++;
    }
    *(*(xmx + i___0) + 1) = xme;
    *(*(xmx + i___0) + 3) = -987654321;
    sc = *(*(xmx + (i___0 - 1)) + 3) + hmm->xsc[3][1];
    if (sc > -987654321) {
      *(*(xmx + i___0) + 3) = sc;
    }
    sc = *(*(xmx + i___0) + 1) + hmm->xsc[1][1];
    if (sc > *(*(xmx + i___0) + 3)) {
      *(*(xmx + i___0) + 3) = sc;
    }
    *(*(xmx + i___0) + 0) = -987654321;
    sc = *(*(xmx + i___0) + 4) + hmm->xsc[0][0];
    if (sc > -987654321) {
      *(*(xmx + i___0) + 0) = sc;
    }
    sc = *(*(xmx + i___0) + 3) + hmm->xsc[3][0];
    if (sc > *(*(xmx + i___0) + 0)) {
      *(*(xmx + i___0) + 0) = sc;
    }
    *(*(xmx + i___0) + 2) = -987654321;
    sc = *(*(xmx + (i___0 - 1)) + 2) + hmm->xsc[2][1];
    if (sc > -987654321) {
      *(*(xmx + i___0) + 2) = sc;
    }
    sc = *(*(xmx + i___0) + 1) + hmm->xsc[1][0];
    if (sc > *(*(xmx + i___0) + 2)) {
      *(*(xmx + i___0) + 2) = sc;
    }
    i___0 ++;
  }
  sc = *(*(xmx + L) + 2) + hmm->xsc[2][0];
  if ((unsigned long )ret_tr != (unsigned long )((void *)0)) {
    P7ViterbiTrace(hmm, dsq, L, mx, & tr);
    *ret_tr = tr;
  }
  tmp___3 = Scorify(sc);
  return (tmp___3);
}
}
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-wQ5uC956.i","-O3")
__inline static void *__inline_memmove_chk(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
extern double exp(double  ) ;
extern double fabs(double  ) ;
extern double sqrt(double  ) ;
extern double floor(double  ) ;
int Linefit(float *x , float *y___0 , int N , float *ret_a , float *ret_b , float *ret_r ) ;
double IncompleteGamma(double a___0 , double x ) ;
double sre_random(void) ;
struct histogram_s *AllocHistogram(int min , int max , int lumpsize ) ;
void FreeHistogram(struct histogram_s *h___0 ) ;
void UnfitHistogram(struct histogram_s *h___0 ) ;
void AddToHistogram(struct histogram_s *h___0 , float sc ) ;
void PrintASCIIHistogram(FILE *fp , struct histogram_s *h___0 ) ;
void PrintXMGRHistogram(FILE *fp , struct histogram_s *h___0 ) ;
void PrintXMGRDistribution(FILE *fp , struct histogram_s *h___0 ) ;
void PrintXMGRRegressionLine(FILE *fp , struct histogram_s *h___0 ) ;
void EVDBasicFit(struct histogram_s *h___0 ) ;
int ExtremeValueFitHistogram(struct histogram_s *h___0 , int censor , float high_hint ) ;
void ExtremeValueSetHistogram(struct histogram_s *h___0 , float mu , float lambda ,
                              float lowbound , float highbound , int ndegrees ) ;
int GaussianFitHistogram(struct histogram_s *h___0 , float high_hint ) ;
void GaussianSetHistogram(struct histogram_s *h___0 , float mean , float sd ) ;
double EVDDensity(float x , float mu , float lambda ) ;
double EVDDistribution(float x , float mu , float lambda ) ;
double ExtremeValueP(float x , float mu , float lambda ) ;
double ExtremeValueP2(float x , float mu , float lambda , int N ) ;
double ExtremeValueE(float x , float mu , float lambda , int N ) ;
float EVDrandom(float mu , float lambda ) ;
int EVDMaxLikelyFit(float *x , int *c , int n , float *ret_mu , float *ret_lambda ) ;
int EVDCensoredFit(float *x , int *y___0 , int n , int z , float c , float *ret_mu ,
                   float *ret_lambda ) ;
void Lawless416(float *x , int *y___0 , int n , float lambda , float *ret_f , float *ret_df ) ;
void Lawless422(float *x , int *y___0 , int n , int z , float c , float lambda , float *ret_f ,
                float *ret_df ) ;
struct histogram_s *AllocHistogram(int min , int max , int lumpsize ) 
{ 
  struct histogram_s *h___0 ;
  int newsize ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
  newsize = (max - min) + 1;
  tmp = sre_malloc((char *)"histogram.c", 68, sizeof(struct histogram_s ));
  h___0 = (struct histogram_s *)tmp;
  h___0->min = min;
  h___0->max = max;
  h___0->total = 0;
  h___0->lowscore = 2147483647;
  h___0->highscore = (-0x7FFFFFFF-1);
  h___0->lumpsize = lumpsize;
  tmp___0 = sre_malloc((char *)"histogram.c", 75, sizeof(int ) * (unsigned long )newsize);
  h___0->histogram = (int *)tmp___0;
  i___0 = 0;
  while (i___0 < newsize) {
    *(h___0->histogram + i___0) = 0;
    i___0 ++;
  }
  h___0->expect = (float *)((void *)0);
  h___0->fit_type = 0;
  return (h___0);
}
}
void FreeHistogram(struct histogram_s *h___0 ) 
{ 


  {
  free((void *)h___0->histogram);
  if ((unsigned long )h___0->expect != (unsigned long )((void *)0)) {
    free((void *)h___0->expect);
  }
  free((void *)h___0);
  return;
}
}
void UnfitHistogram(struct histogram_s *h___0 ) 
{ 


  {
  if ((unsigned long )h___0->expect != (unsigned long )((void *)0)) {
    free((void *)h___0->expect);
  }
  h___0->expect = (float *)((void *)0);
  h___0->fit_type = 0;
  return;
}
}
void AddToHistogram(struct histogram_s *h___0 , float sc ) 
{ 
  int score ;
  int moveby ;
  int prevsize ;
  int newsize ;
  int i___0 ;
  double tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  void *tmp___3 ;

  {
  if (h___0->fit_type != 0) {
    Die((char *)"AddToHistogram(): Can\'t add to a fitted histogram\n");
  }
  tmp = floor((double )sc);
  score = (int )tmp;
  if (score < h___0->min) {
    prevsize = (h___0->max - h___0->min) + 1;
    moveby = (h___0->min - score) + h___0->lumpsize;
    newsize = prevsize + moveby;
    h___0->min -= moveby;
    tmp___0 = sre_realloc((char *)"histogram.c", 148, (void *)h___0->histogram, sizeof(int ) * (unsigned long )newsize);
    h___0->histogram = (int *)tmp___0;
    tmp___2 = __builtin_object_size((void *)(h___0->histogram + moveby), 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)(h___0->histogram + moveby), 0);
      __builtin___memmove_chk((void *)(h___0->histogram + moveby), (void const   *)h___0->histogram,
                              sizeof(int ) * (unsigned long )prevsize, tmp___1);
    } else {
      __inline_memmove_chk((void *)(h___0->histogram + moveby), (void const   *)h___0->histogram,
                           sizeof(int ) * (unsigned long )prevsize);
    }
    i___0 = 0;
    while (i___0 < moveby) {
      *(h___0->histogram + i___0) = 0;
      i___0 ++;
    }
  } else
  if (score > h___0->max) {
    prevsize = (h___0->max - h___0->min) + 1;
    h___0->max = h___0->lumpsize + score;
    newsize = (h___0->max - h___0->min) + 1;
    tmp___3 = sre_realloc((char *)"histogram.c", 159, (void *)h___0->histogram, sizeof(int ) * (unsigned long )newsize);
    h___0->histogram = (int *)tmp___3;
    i___0 = prevsize;
    while (i___0 < newsize) {
      *(h___0->histogram + i___0) = 0;
      i___0 ++;
    }
  }
  (*(h___0->histogram + (score - h___0->min))) ++;
  (h___0->total) ++;
  if (score < h___0->lowscore) {
    h___0->lowscore = score;
  }
  if (score > h___0->highscore) {
    h___0->highscore = score;
  }
  return;
}
}
void PrintASCIIHistogram(FILE *fp , struct histogram_s *h___0 ) 
{ 
  int units ;
  int maxbar ;
  int num ;
  int i___0 ;
  int idx ;
  char buffer___1[81] ;
  int pos ;
  int lowbound ;
  int lowcount ;
  int highbound ;
  int highcount ;
  int emptybins ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;

  {
  emptybins = 3;
  maxbar = 0;
  i___0 = h___0->lowscore - h___0->min;
  while (i___0 <= h___0->highscore - h___0->min) {
    if (*(h___0->histogram + i___0) > maxbar) {
      maxbar = *(h___0->histogram + i___0);
      lowbound = i___0 + h___0->min;
    }
    i___0 ++;
  }
  highbound = lowbound;
  num = 0;
  while (lowbound > h___0->lowscore) {
    i___0 = lowbound - h___0->min;
    if (*(h___0->histogram + i___0) > 0) {
      num = 0;
      goto __Cont;
    }
    num ++;
    if (num == emptybins) {
      lowbound += emptybins;
      break;
    }
    __Cont: /* CIL Label */ 
    lowbound --;
  }
  num = 0;
  while (highbound < h___0->highscore) {
    i___0 = highbound - h___0->min;
    if (*(h___0->histogram + i___0) > 0) {
      num = 0;
      goto __Cont___0;
    }
    num ++;
    if (num == emptybins) {
      highbound -= emptybins;
      break;
    }
    __Cont___0: /* CIL Label */ 
    highbound ++;
  }
  lowcount = 0;
  i___0 = h___0->lowscore - h___0->min;
  while (i___0 <= lowbound - h___0->min) {
    lowcount += *(h___0->histogram + i___0);
    i___0 ++;
  }
  highcount = 0;
  i___0 = h___0->highscore - h___0->min;
  while (i___0 >= highbound - h___0->min) {
    highcount += *(h___0->histogram + i___0);
    i___0 --;
  }
  if (lowcount > maxbar) {
    maxbar = lowcount;
  }
  if (highcount > maxbar) {
    maxbar = highcount;
  }
  units = (maxbar - 1) / 59 + 1;
  fprintf(fp, "%5s %6s %6s  (one = represents %d sequences)\n", "score", "obs", "exp",
          units);
  fprintf(fp, "%5s %6s %6s\n", "-----", "---", "---");
  buffer___1[80] = (char )'\000';
  buffer___1[79] = (char )'\n';
  i___0 = h___0->lowscore;
  while (i___0 <= h___0->highscore) {
    tmp___0 = __builtin_object_size((void *)(buffer___1), 0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)(buffer___1), 0);
      __builtin___memset_chk((void *)(buffer___1), ' ', 79UL * sizeof(char ), tmp);
    } else {
      __inline_memset_chk((void *)(buffer___1), ' ', 79UL * sizeof(char ));
    }
    idx = i___0 - h___0->min;
    if (i___0 < lowbound) {
      goto __Cont___1;
    } else
    if (i___0 > highbound) {
      goto __Cont___1;
    } else
    if (i___0 == lowbound) {
      if (i___0 != h___0->lowscore) {
        tmp___1 = __builtin_object_size((void *)(buffer___1), 1);
        __builtin___sprintf_chk(buffer___1, 0, tmp___1, "<%4d %6d %6s|", i___0 + 1,
                                lowcount, "-");
        if (lowcount > 0) {
          num = 1 + (lowcount - 1) / units;
          if (num > 60) {
            Die((char *)"oops");
          }
          pos = 20;
          while (num > 0) {
            tmp___2 = pos;
            pos ++;
            buffer___1[tmp___2] = (char )'=';
            num --;
          }
        }
        fputs((char const   *)(buffer___1), fp);
        goto __Cont___1;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (i___0 == highbound) {
      if (i___0 != h___0->highscore) {
        tmp___3 = __builtin_object_size((void *)(buffer___1), 1);
        __builtin___sprintf_chk(buffer___1, 0, tmp___3, ">%4d %6d %6s|", i___0, highcount,
                                "-");
        if (highcount > 0) {
          num = 1 + (highcount - 1) / units;
          pos = 20;
          while (num > 0) {
            tmp___4 = pos;
            pos ++;
            buffer___1[tmp___4] = (char )'=';
            num --;
          }
        }
        fputs((char const   *)(buffer___1), fp);
        goto __Cont___1;
      }
    }
    if (h___0->fit_type != 0) {
      tmp___5 = __builtin_object_size((void *)(buffer___1), 1);
      __builtin___sprintf_chk(buffer___1, 0, tmp___5, "%5d %6d %6d|", i___0, *(h___0->histogram + idx),
                              (int )*(h___0->expect + idx));
    } else {
      tmp___6 = __builtin_object_size((void *)(buffer___1), 1);
      __builtin___sprintf_chk(buffer___1, 0, tmp___6, "%5d %6d %6s|", i___0, *(h___0->histogram + idx),
                              "-");
    }
    buffer___1[20] = (char )' ';
    if (*(h___0->histogram + idx) > 0) {
      num = 1 + (*(h___0->histogram + idx) - 1) / units;
      pos = 20;
      while (num > 0) {
        tmp___7 = pos;
        pos ++;
        buffer___1[tmp___7] = (char )'=';
        num --;
      }
    }
    if (h___0->fit_type != 0) {
      if ((int )*(h___0->expect + idx) > 0) {
        pos = 20 + (int )(*(h___0->expect + idx) - (float )1) / units;
        if (pos >= 78) {
          pos = 78;
        }
        buffer___1[pos] = (char )'*';
      }
    }
    fputs((char const   *)(buffer___1), fp);
    __Cont___1: /* CIL Label */ 
    i___0 ++;
  }
  switch (h___0->fit_type) {
  case 0: 
  fprintf(fp, "\n\n%% No statistical fit available\n");
  break;
  case 1: 
  fprintf(fp, "\n\n%% Statistical details of theoretical EVD fit:\n");
  fprintf(fp, "              mu = %10.4f\n", (double )h___0->param[0]);
  fprintf(fp, "          lambda = %10.4f\n", (double )h___0->param[1]);
  fprintf(fp, "chi-sq statistic = %10.4f\n", (double )h___0->chisq);
  fprintf(fp, "  P(chi-square)  = %10.4g\n", (double )h___0->chip);
  break;
  case 2: 
  fprintf(fp, "\n\n%% Statistical details of theoretical Gaussian fit:\n");
  fprintf(fp, "            mean = %10.4f\n", (double )h___0->param[0]);
  fprintf(fp, "              sd = %10.4f\n", (double )h___0->param[1]);
  fprintf(fp, "chi-sq statistic = %10.4f\n", (double )h___0->chisq);
  fprintf(fp, "  P(chi-square)  = %10.4g\n", (double )h___0->chip);
  break;
  }
  return;
}
}
void PrintXMGRHistogram(FILE *fp , struct histogram_s *h___0 ) 
{ 
  int sc ;
  double val ;
  double tmp ;
  double tmp___0 ;

  {
  sc = h___0->lowscore;
  while (sc <= h___0->highscore) {
    if (*(h___0->histogram + (sc - h___0->min)) > 0) {
      fprintf(fp, "%-6d %f\n", sc, (double )((float )*(h___0->histogram + (sc - h___0->min)) / (float )h___0->total));
    }
    sc ++;
  }
  fprintf(fp, "&\n");
  if (h___0->fit_type != 0) {
    sc = h___0->lowscore;
    while (sc <= h___0->highscore) {
      tmp = ExtremeValueP((float )sc + (float )1, h___0->param[0], h___0->param[1]);
      tmp___0 = ExtremeValueP((float )sc, h___0->param[0], h___0->param[1]);
      val = (1. - tmp) - (1. - tmp___0);
      fprintf(fp, "%-6d %f\n", sc, val);
      sc ++;
    }
    fprintf(fp, "&\n");
  }
  return;
}
}
void PrintXMGRDistribution(FILE *fp , struct histogram_s *h___0 ) 
{ 
  int sc ;
  int cum ;
  double val ;
  double tmp ;

  {
  cum = 0;
  sc = h___0->lowscore;
  while (sc <= h___0->highscore) {
    cum += *(h___0->histogram + (sc - h___0->min));
    fprintf(fp, "%-6d %f\n", sc + 1, (double )((float )cum / (float )h___0->total));
    sc ++;
  }
  fprintf(fp, "&\n");
  if (h___0->fit_type != 0) {
    sc = h___0->lowscore;
    while (sc <= h___0->highscore) {
      tmp = ExtremeValueP((float )sc, h___0->param[0], h___0->param[1]);
      val = 1. - tmp;
      fprintf(fp, "%-6d %f\n", sc, val);
      sc ++;
    }
    fprintf(fp, "&\n");
  }
  return;
}
}
void PrintXMGRRegressionLine(FILE *fp , struct histogram_s *h___0 ) 
{ 
  int sc ;
  int cum ;
  double val ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  cum = 0;
  sc = h___0->lowscore;
  while (sc <= h___0->highscore) {
    cum += *(h___0->histogram + (sc - h___0->min));
    tmp = log((double )cum / (double )h___0->total);
    val = log(- 1. * tmp);
    if (cum < h___0->total) {
      fprintf(fp, "%-6d %f\n", sc + 1, val);
    }
    sc ++;
  }
  fprintf(fp, "&\n");
  if (h___0->fit_type != 0) {
    sc = h___0->lowscore;
    while (sc <= h___0->highscore) {
      tmp___0 = ExtremeValueP((float )sc, h___0->param[0], h___0->param[1]);
      tmp___1 = log(1. - tmp___0);
      val = log(- 1. * tmp___1);
      fprintf(fp, "%-6d %f\n", sc, val);
      sc ++;
    }
    fprintf(fp, "&\n");
  }
  return;
}
}
void EVDBasicFit(struct histogram_s *h___0 ) 
{ 
  float *d___0 ;
  float *x ;
  int hsize ;
  int sum ;
  int sc ;
  int idx ;
  float slope ;
  float intercept ;
  float corr ;
  float lambda ;
  float mu ;
  void *tmp ;
  void *tmp___0 ;
  float tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  hsize = (h___0->highscore - h___0->lowscore) + 1;
  tmp = sre_malloc((char *)"histogram.c", 492, sizeof(float ) * (unsigned long )hsize);
  d___0 = (float *)tmp;
  tmp___0 = sre_malloc((char *)"histogram.c", 493, sizeof(float ) * (unsigned long )hsize);
  x = (float *)tmp___0;
  idx = 0;
  while (idx < hsize) {
    tmp___1 = (float )0.;
    *(x + idx) = tmp___1;
    *(d___0 + idx) = tmp___1;
    idx ++;
  }
  sum = 0;
  sc = h___0->lowscore;
  while (sc <= h___0->highscore) {
    sum += *(h___0->histogram + (sc - h___0->min));
    *(d___0 + (sc - h___0->lowscore)) = (float )sum / (float )h___0->total;
    *(x + (sc - h___0->lowscore)) = (float )(sc + 1);
    sc ++;
  }
  sc = h___0->lowscore;
  while (sc < h___0->highscore) {
    tmp___2 = log((double )*(d___0 + (sc - h___0->lowscore)));
    tmp___3 = log(- 1. * tmp___2);
    *(d___0 + (sc - h___0->lowscore)) = (float )tmp___3;
    sc ++;
  }
  Linefit(x, d___0, hsize - 1, & intercept, & slope, & corr);
  lambda = (float )(- 1. * (double )slope);
  mu = intercept / lambda;
  ExtremeValueSetHistogram(h___0, mu, lambda, (float )h___0->lowscore, (float )h___0->highscore,
                           2);
  free((void *)x);
  free((void *)d___0);
  return;
}
}
int ExtremeValueFitHistogram(struct histogram_s *h___0 , int censor , float high_hint ) 
{ 
  float *x ;
  int *y___0 ;
  int n ;
  int z ;
  int hsize ;
  float lambda ;
  float mu ;
  int sc ;
  int lowbound ;
  int highbound ;
  int new_highbound ;
  int iteration ;
  int max ;
  void *tmp ;
  void *tmp___0 ;
  double psx ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  lowbound = h___0->lowscore;
  if (censor) {
    max = -1;
    sc = h___0->lowscore;
    while (sc <= h___0->highscore) {
      if (*(h___0->histogram + (sc - h___0->min)) > max) {
        max = *(h___0->histogram + (sc - h___0->min));
        lowbound = sc;
      }
      sc ++;
    }
  }
  if (high_hint < (float )h___0->highscore) {
    highbound = (int )high_hint;
  } else {
    highbound = h___0->highscore;
  }
  iteration = 0;
  while (iteration < 100) {
    x = (float *)((void *)0);
    y___0 = (int *)((void *)0);
    hsize = (highbound - lowbound) + 1;
    if (hsize < 5) {
      goto FITFAILED;
    }
    tmp = sre_malloc((char *)"histogram.c", 600, sizeof(float ) * (unsigned long )hsize);
    x = (float *)tmp;
    tmp___0 = sre_malloc((char *)"histogram.c", 601, sizeof(int ) * (unsigned long )hsize);
    y___0 = (int *)tmp___0;
    n = 0;
    sc = lowbound;
    while (sc <= highbound) {
      *(x + (sc - lowbound)) = (float )((double )((float )sc) + 0.5);
      *(y___0 + (sc - lowbound)) = *(h___0->histogram + (sc - h___0->min));
      n += *(h___0->histogram + (sc - h___0->min));
      sc ++;
    }
    if (n < 100) {
      goto FITFAILED;
    }
    if (censor) {
      if (iteration == 0) {
        if (h___0->total - n < (int )(0.58198 * (double )((float )n))) {
          z = h___0->total - n;
        } else {
          z = (int )(0.58198 * (double )((float )n));
        }
      } else {
        psx = EVDDistribution((float )lowbound, mu, lambda);
        if (h___0->total - n < (int )(((double )n * psx) / (1. - psx))) {
          z = h___0->total - n;
        } else {
          z = (int )(((double )n * psx) / (1. - psx));
        }
      }
    }
    if (censor) {
      tmp___1 = EVDCensoredFit(x, y___0, hsize, z, (float )lowbound, & mu, & lambda);
      if (! tmp___1) {
        goto FITFAILED;
      }
    } else {
      tmp___2 = EVDMaxLikelyFit(x, y___0, hsize, & mu, & lambda);
      if (! tmp___2) {
        goto FITFAILED;
      }
    }
    tmp___3 = log((double )((n + z) - 1) / (double )(n + z));
    tmp___4 = log(- 1. * tmp___3);
    new_highbound = (int )((double )mu - tmp___4 / (double )lambda);
    free((void *)x);
    free((void *)y___0);
    if (new_highbound >= highbound) {
      break;
    }
    highbound = new_highbound;
    iteration ++;
  }
  ExtremeValueSetHistogram(h___0, mu, lambda, (float )lowbound, (float )highbound,
                           1);
  return (1);
  FITFAILED: 
  UnfitHistogram(h___0);
  if ((unsigned long )x != (unsigned long )((void *)0)) {
    free((void *)x);
  }
  if ((unsigned long )y___0 != (unsigned long )((void *)0)) {
    free((void *)y___0);
  }
  return (0);
}
}
void ExtremeValueSetHistogram(struct histogram_s *h___0 , float mu , float lambda ,
                              float lowbound , float highbound , int ndegrees ) 
{ 
  int sc ;
  int hsize ;
  int idx ;
  int nbins ;
  float delta ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  UnfitHistogram(h___0);
  h___0->fit_type = 1;
  h___0->param[1] = lambda;
  h___0->param[0] = mu;
  hsize = (h___0->max - h___0->min) + 1;
  tmp = sre_malloc((char *)"histogram.c", 696, sizeof(float ) * (unsigned long )hsize);
  h___0->expect = (float *)tmp;
  idx = 0;
  while (idx < hsize) {
    *(h___0->expect + idx) = (float )0.;
    idx ++;
  }
  sc = h___0->min;
  while (sc <= h___0->max) {
    tmp___0 = ExtremeValueE((float )sc, h___0->param[0], h___0->param[1], h___0->total);
    tmp___1 = ExtremeValueE((float )(sc + 1), h___0->param[0], h___0->param[1], h___0->total);
    *(h___0->expect + (sc - h___0->min)) = (float )(tmp___0 - tmp___1);
    sc ++;
  }
  h___0->chisq = (float )0.;
  nbins = 0;
  sc = (int )lowbound;
  while ((float )sc <= highbound) {
    if ((double )*(h___0->expect + (sc - h___0->min)) >= 5.) {
      if (*(h___0->histogram + (sc - h___0->min)) >= 5) {
        delta = (float )*(h___0->histogram + (sc - h___0->min)) - *(h___0->expect + (sc - h___0->min));
        h___0->chisq += (delta * delta) / *(h___0->expect + (sc - h___0->min));
        nbins ++;
      }
    }
    sc ++;
  }
  if (nbins > 1 + ndegrees) {
    tmp___2 = IncompleteGamma((double )((nbins - 1) - ndegrees) / 2., (double )h___0->chisq / 2.);
    h___0->chip = (float )tmp___2;
  } else {
    h___0->chip = (float )0.;
  }
  return;
}
}
int GaussianFitHistogram(struct histogram_s *h___0 , float high_hint ) 
{ 
  float sum ;
  float sqsum ;
  float delta ;
  int sc ;
  int nbins ;
  int hsize ;
  int idx ;
  double tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  UnfitHistogram(h___0);
  if (h___0->total < 1000) {
    h___0->fit_type = 0;
    return (0);
  }
  sqsum = (float )0.;
  sum = sqsum;
  sc = h___0->lowscore;
  while (sc <= h___0->highscore) {
    delta = (float )((double )((float )sc) + 0.5);
    sum += (float )*(h___0->histogram + (sc - h___0->min)) * delta;
    sqsum += ((float )*(h___0->histogram + (sc - h___0->min)) * delta) * delta;
    sc ++;
  }
  h___0->fit_type = 2;
  h___0->param[0] = sum / (float )h___0->total;
  tmp = sqrt((double )((sqsum - (sum * sum) / (float )h___0->total) / (float )(h___0->total - 1)));
  h___0->param[1] = (float )tmp;
  hsize = (h___0->max - h___0->min) + 1;
  tmp___0 = sre_malloc((char *)"histogram.c", 790, sizeof(float ) * (unsigned long )hsize);
  h___0->expect = (float *)tmp___0;
  idx = 0;
  while (idx < hsize) {
    *(h___0->expect + idx) = (float )0.;
    idx ++;
  }
  sc = h___0->min;
  while (sc <= h___0->max) {
    delta = (float )(((double )((float )sc) + 0.5) - (double )h___0->param[0]);
    tmp___1 = sqrt(2. * 3.14159);
    tmp___2 = exp(((- 1. * (double )delta) * (double )delta) / ((2. * (double )h___0->param[1]) * (double )h___0->param[1]));
    *(h___0->expect + (sc - h___0->min)) = (float )((double )((float )h___0->total) * ((1. / ((double )h___0->param[1] * tmp___1)) * tmp___2));
    sc ++;
  }
  h___0->chisq = (float )0.;
  nbins = 0;
  sc = h___0->lowscore;
  while (sc <= h___0->highscore) {
    if ((double )*(h___0->expect + (sc - h___0->min)) >= 5.) {
      if (*(h___0->histogram + (sc - h___0->min)) >= 5) {
        delta = (float )*(h___0->histogram + (sc - h___0->min)) - *(h___0->expect + (sc - h___0->min));
        h___0->chisq += (delta * delta) / *(h___0->expect + (sc - h___0->min));
        nbins ++;
      }
    }
    sc ++;
  }
  if (nbins > 3) {
    tmp___3 = IncompleteGamma((double )(nbins - 3) / 2., (double )h___0->chisq / 2.);
    h___0->chip = (float )tmp___3;
  } else {
    h___0->chip = (float )0.;
  }
  return (1);
}
}
void GaussianSetHistogram(struct histogram_s *h___0 , float mean , float sd ) 
{ 
  int sc ;
  int hsize ;
  int idx ;
  int nbins ;
  float delta ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  UnfitHistogram(h___0);
  h___0->fit_type = 2;
  h___0->param[0] = mean;
  h___0->param[1] = sd;
  hsize = (h___0->max - h___0->min) + 1;
  tmp = sre_malloc((char *)"histogram.c", 845, sizeof(float ) * (unsigned long )hsize);
  h___0->expect = (float *)tmp;
  idx = 0;
  while (idx < hsize) {
    *(h___0->expect + idx) = (float )0.;
    idx ++;
  }
  sc = h___0->min;
  while (sc <= h___0->max) {
    delta = (float )(((double )((float )sc) + 0.5) - (double )h___0->param[0]);
    tmp___0 = sqrt(2. * 3.14159);
    tmp___1 = exp(((- 1. * (double )delta) * (double )delta) / ((2. * (double )h___0->param[1]) * (double )h___0->param[1]));
    *(h___0->expect + (sc - h___0->min)) = (float )((double )((float )h___0->total) * ((1. / ((double )h___0->param[1] * tmp___0)) * tmp___1));
    sc ++;
  }
  h___0->chisq = (float )0.;
  nbins = 0;
  sc = h___0->lowscore;
  while (sc <= h___0->highscore) {
    if ((double )*(h___0->expect + (sc - h___0->min)) >= 5.) {
      if (*(h___0->histogram + (sc - h___0->min)) >= 5) {
        delta = (float )*(h___0->histogram + (sc - h___0->min)) - *(h___0->expect + (sc - h___0->min));
        h___0->chisq += (delta * delta) / *(h___0->expect + (sc - h___0->min));
        nbins ++;
      }
    }
    sc ++;
  }
  if (nbins > 1) {
    tmp___2 = IncompleteGamma((double )(nbins - 1) / 2., (double )h___0->chisq / 2.);
    h___0->chip = (float )tmp___2;
  } else {
    h___0->chip = (float )0.;
  }
  return;
}
}
double EVDDensity(float x , float mu , float lambda ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  tmp = exp((- 1. * (double )lambda) * (double )(x - mu));
  tmp___0 = exp((- 1. * (double )lambda) * (double )(x - mu) - tmp);
  return ((double )lambda * tmp___0);
}
}
double EVDDistribution(float x , float mu , float lambda ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  tmp = exp((- 1. * (double )lambda) * (double )(x - mu));
  tmp___0 = exp(- 1. * tmp);
  return (tmp___0);
}
}
double ExtremeValueP(float x , float mu , float lambda ) 
{ 
  double y___0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  tmp = log(2.2204460492503131e-16);
  tmp___0 = log(- 1. * tmp);
  if ((double )(lambda * (x - mu)) <= - 1. * tmp___0) {
    return (1.0);
  }
  if ((double )(lambda * (x - mu)) >= 2.3 * (double )308) {
    return (0.0);
  }
  y___0 = exp((- 1. * (double )lambda) * (double )(x - mu));
  if (y___0 < 1e-7) {
    return (y___0);
  } else {
    tmp___1 = exp(- 1. * y___0);
    return (1.0 - tmp___1);
  }
}
}
double ExtremeValueP2(float x , float mu , float lambda , int N ) 
{ 
  double y___0 ;
  double tmp ;
  double tmp___0 ;

  {
  tmp = ExtremeValueP(x, mu, lambda);
  y___0 = (double )N * tmp;
  if (y___0 < 1e-7) {
    return (y___0);
  } else {
    tmp___0 = exp(- 1. * y___0);
    return (1.0 - tmp___0);
  }
}
}
double ExtremeValueE(float x , float mu , float lambda , int N ) 
{ 
  double tmp ;

  {
  tmp = ExtremeValueP(x, mu, lambda);
  return ((double )N * tmp);
}
}
float EVDrandom(float mu , float lambda ) 
{ 
  float p ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  p = (float )0.0;
  while (1) {
    if (! ((double )p == 0.)) {
      if (! ((double )p == 1.)) {
        break;
      }
    }
    tmp = sre_random();
    p = (float )tmp;
  }
  tmp___0 = log((double )p);
  tmp___1 = log(- 1. * tmp___0);
  return ((float )((double )mu - tmp___1 / (double )lambda));
}
}
void Lawless416(float *x , int *y___0 , int n , float lambda , float *ret_f , float *ret_df ) 
{ 
  double esum ;
  double xesum ;
  double xxesum ;
  double xsum ;
  double mult ;
  double total ;
  int i___0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  total = 0.;
  xxesum = total;
  xsum = xxesum;
  xesum = xsum;
  esum = xesum;
  i___0 = 0;
  while (i___0 < n) {
    if ((unsigned long )y___0 == (unsigned long )((void *)0)) {
      mult = 1.;
    } else {
      mult = (double )*(y___0 + i___0);
    }
    xsum += mult * (double )*(x + i___0);
    tmp = exp((- 1. * (double )lambda) * (double )*(x + i___0));
    xesum += (mult * (double )*(x + i___0)) * tmp;
    tmp___0 = exp((- 1. * (double )lambda) * (double )*(x + i___0));
    xxesum += ((mult * (double )*(x + i___0)) * (double )*(x + i___0)) * tmp___0;
    tmp___1 = exp((- 1. * (double )lambda) * (double )*(x + i___0));
    esum += mult * tmp___1;
    total += mult;
    i___0 ++;
  }
  *ret_f = (float )((1. / (double )lambda - xsum / total) + xesum / esum);
  *ret_df = (float )(((xesum / esum) * (xesum / esum) - xxesum / esum) - 1. / (double )(lambda * lambda));
  return;
}
}
void Lawless422(float *x , int *y___0 , int n , int z , float c , float lambda , float *ret_f ,
                float *ret_df ) 
{ 
  double esum ;
  double xesum ;
  double xxesum ;
  double xsum ;
  double mult ;
  double total ;
  int i___0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  total = 0.;
  xxesum = total;
  xsum = xxesum;
  xesum = xsum;
  esum = xesum;
  i___0 = 0;
  while (i___0 < n) {
    if ((unsigned long )y___0 == (unsigned long )((void *)0)) {
      mult = 1.;
    } else {
      mult = (double )*(y___0 + i___0);
    }
    xsum += mult * (double )*(x + i___0);
    tmp = exp((- 1. * (double )lambda) * (double )*(x + i___0));
    esum += mult * tmp;
    tmp___0 = exp((- 1. * (double )lambda) * (double )*(x + i___0));
    xesum += (mult * (double )*(x + i___0)) * tmp___0;
    tmp___1 = exp((- 1. * (double )lambda) * (double )*(x + i___0));
    xxesum += ((mult * (double )*(x + i___0)) * (double )*(x + i___0)) * tmp___1;
    total += mult;
    i___0 ++;
  }
  tmp___2 = exp((- 1. * (double )lambda) * (double )c);
  esum += (double )z * tmp___2;
  tmp___3 = exp((- 1. * (double )lambda) * (double )c);
  xesum += ((double )z * (double )c) * tmp___3;
  tmp___4 = exp((- 1. * (double )lambda) * (double )c);
  xxesum += (((double )z * (double )c) * (double )c) * tmp___4;
  *ret_f = (float )((1. / (double )lambda - xsum / total) + xesum / esum);
  *ret_df = (float )(((xesum / esum) * (xesum / esum) - xxesum / esum) - 1. / (double )(lambda * lambda));
  return;
}
}
int EVDMaxLikelyFit(float *x , int *c , int n , float *ret_mu , float *ret_lambda ) 
{ 
  float lambda ;
  float mu ;
  float fx ;
  float dfx ;
  double esum ;
  double mult ;
  double total ;
  float tol ;
  int i___0 ;
  double tmp ;
  float left ;
  float right ;
  float mid ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  tol = (float )1e-5;
  lambda = (float )0.2;
  i___0 = 0;
  while (i___0 < 100) {
    Lawless416(x, c, n, lambda, & fx, & dfx);
    tmp = fabs((double )fx);
    if (tmp < (double )tol) {
      break;
    }
    lambda -= fx / dfx;
    if ((double )lambda <= 0.) {
      lambda = (float )0.001;
    }
    i___0 ++;
  }
  if (i___0 == 100) {
    left = (float )0.2;
    right = left;
    lambda = right;
    Lawless416(x, c, n, lambda, & fx, & dfx);
    if ((double )fx < 0.) {
      while (1) {
        left = (float )((double )left - 0.1);
        if ((double )left < 0.) {
          return (0);
        }
        Lawless416(x, c, n, left, & fx, & dfx);
        if (! ((double )fx < 0.)) {
          break;
        }
      }
    } else {
      while (1) {
        right = (float )((double )right + 0.1);
        Lawless416(x, c, n, right, & fx, & dfx);
        if ((double )right > 100.) {
          return (0);
        }
        if (! ((double )fx > 0.)) {
          break;
        }
      }
    }
    i___0 = 0;
    while (i___0 < 100) {
      mid = (float )((double )(left + right) / 2.);
      Lawless416(x, c, n, mid, & fx, & dfx);
      tmp___0 = fabs((double )fx);
      if (tmp___0 < (double )tol) {
        break;
      }
      if ((double )fx > 0.) {
        left = mid;
      } else {
        right = mid;
      }
      i___0 ++;
    }
    if (i___0 == 100) {
      return (0);
    }
    lambda = mid;
  }
  esum = 0.;
  total = 0.;
  i___0 = 0;
  while (i___0 < n) {
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      mult = 1.;
    } else {
      mult = (double )*(c + i___0);
    }
    tmp___1 = exp((double )(((float )-1 * lambda) * *(x + i___0)));
    esum += mult * tmp___1;
    total += mult;
    i___0 ++;
  }
  tmp___2 = log(esum / total);
  mu = (float )((- 1. * tmp___2) / (double )lambda);
  *ret_lambda = lambda;
  *ret_mu = mu;
  return (1);
}
}
int EVDCensoredFit(float *x , int *y___0 , int n , int z , float c , float *ret_mu ,
                   float *ret_lambda ) 
{ 
  float lambda ;
  float mu ;
  float fx ;
  float dfx ;
  double esum ;
  double mult ;
  double total ;
  float tol ;
  int i___0 ;
  double tmp ;
  float left ;
  float right ;
  float mid ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  tol = (float )1e-5;
  lambda = (float )0.2;
  i___0 = 0;
  while (i___0 < 100) {
    Lawless422(x, y___0, n, z, c, lambda, & fx, & dfx);
    tmp = fabs((double )fx);
    if (tmp < (double )tol) {
      break;
    }
    lambda -= fx / dfx;
    if ((double )lambda <= 0.) {
      lambda = (float )0.001;
    }
    i___0 ++;
  }
  if (i___0 == 100) {
    left = (float )0.2;
    right = left;
    lambda = right;
    Lawless422(x, y___0, n, z, c, lambda, & fx, & dfx);
    if ((double )fx < 0.) {
      while (1) {
        left = (float )((double )left - 0.03);
        if ((double )left < 0.) {
          return (0);
        }
        Lawless422(x, y___0, n, z, c, left, & fx, & dfx);
        if (! ((double )fx < 0.)) {
          break;
        }
      }
    } else {
      while (1) {
        right = (float )((double )right + 0.1);
        Lawless422(x, y___0, n, z, c, left, & fx, & dfx);
        if ((double )right > 100.) {
          return (0);
        }
        if (! ((double )fx > 0.)) {
          break;
        }
      }
    }
    i___0 = 0;
    while (i___0 < 100) {
      mid = (float )((double )(left + right) / 2.);
      Lawless422(x, y___0, n, z, c, left, & fx, & dfx);
      tmp___0 = fabs((double )fx);
      if (tmp___0 < (double )tol) {
        break;
      }
      if ((double )fx > 0.) {
        left = mid;
      } else {
        right = mid;
      }
      i___0 ++;
    }
    if (i___0 == 100) {
      return (0);
    }
    lambda = mid;
  }
  total = 0.;
  esum = total;
  i___0 = 0;
  while (i___0 < n) {
    if ((unsigned long )y___0 == (unsigned long )((void *)0)) {
      mult = 1.;
    } else {
      mult = (double )*(y___0 + i___0);
    }
    tmp___1 = exp((- 1. * (double )lambda) * (double )*(x + i___0));
    esum += mult * tmp___1;
    total += mult;
    i___0 ++;
  }
  tmp___2 = exp((- 1. * (double )lambda) * (double )c);
  esum += (double )z * tmp___2;
  tmp___3 = log(esum / total);
  mu = (float )((- 1. * tmp___3) / (double )lambda);
  *ret_lambda = lambda;
  *ret_mu = mu;
  return (1);
}
}
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-qERZlSEW.i","-O3")
extern int fclose(FILE * ) ;
extern int feof(FILE * ) ;
extern char *fgets(char * , int  , FILE * ) ;
extern FILE *fopen(char const   * , char const   * )  __asm__("_fopen")  ;
extern size_t fread(void * , size_t  , size_t  , FILE * ) ;
extern int fseek(FILE * , long  , int  ) ;
extern size_t fwrite(void const   * , size_t  , size_t  , FILE * )  __asm__("_fwrite")  ;
extern void rewind(FILE * ) ;
extern double atof(char const   * ) ;
extern int atoi(char const   * ) ;
extern int strcmp(char const   * , char const   * ) ;
extern int strncmp(char const   * , char const   * , size_t  ) ;
extern char *strtok(char * , char const   * ) ;
__inline static char *__inline_strcat_chk(char *__dest , char const   *__src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcat_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
extern _RuneLocale _DefaultRuneLocale ;
__inline static __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c , unsigned long _f ) 
{ 
  int tmp ;

  {
  if (_c < 0) {
    tmp = 0;
  } else
  if (_c >= 1 << 8) {
    tmp = 0;
  } else {
    tmp = ! (! ((unsigned long )_DefaultRuneLocale.__runetype[_c] & _f));
  }
  return (tmp);
}
}
__inline static int isdigit(int _c ) 
{ 
  __darwin_ct_rune_t tmp ;

  {
  tmp = __isctype(_c, 1024UL);
  return (tmp);
}
}
int SSIOpen(char *filename , SSIFILE **ret_sfp ) ;
int SSIGetOffsetByName(SSIFILE *sfp , char *key , int *ret_fh , SSIOFFSET *ret_offset ) ;
int SSIGetOffsetByNumber(SSIFILE *sfp , int n , int *ret_fh , SSIOFFSET *ret_offset ) ;
int SSISetFilePosition(FILE *fp , SSIOFFSET *offset ) ;
void SSIClose(SSIFILE *sfp ) ;
int SSIRecommendMode(char *file ) ;
int SSIGetFilePosition(FILE *fp , int mode , SSIOFFSET *ret_offset ) ;
char *FileConcat(char *dir , char *file ) ;
FILE *EnvFileOpen(char *fname , char *env , char **ret_dir ) ;
int sre_toupper(int c ) ;
char *Strdup(char *s___0 ) ;
void StringChop(char *s___0 ) ;
void s2upper(char *s___0 ) ;
HMMFILE *HMMFileOpen(char *hmmfile , char *env ) ;
int HMMFileRead(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
void HMMFileClose(HMMFILE *hmmfp ) ;
void HMMFileRewind(HMMFILE *hmmfp ) ;
int HMMFilePositionByName(HMMFILE *hmmfp , char *name ) ;
int HMMFilePositionByIndex(HMMFILE *hmmfp , int idx ) ;
void WriteAscHMM(FILE *fp , struct plan7_s *hmm ) ;
void WriteBinHMM(FILE *fp , struct plan7_s *hmm ) ;
char *Getword(FILE *fp , int type ) ;
struct plan7_s *AllocPlan7Shell(void) ;
void AllocPlan7Body(struct plan7_s *hmm , int M ) ;
void FreePlan7(struct plan7_s *hmm ) ;
void ZeroPlan7(struct plan7_s *hmm ) ;
void Plan7SetName(struct plan7_s *hmm , char *name ) ;
void Plan7SetAccession(struct plan7_s *hmm , char *acc ) ;
void Plan7SetDescription(struct plan7_s *hmm , char *desc ) ;
void Plan7SetCtime(struct plan7_s *hmm ) ;
void Plan7Renormalize(struct plan7_s *hmm ) ;
void Plan7LSConfig(struct plan7_s *hmm ) ;
void Plan9toPlan7(struct plan9_s *hmm , struct plan7_s **ret_plan7 ) ;
struct plan9_s *P9AllocHMM(int M ) ;
int P9FreeHMM(struct plan9_s *hmm ) ;
void P9Renormalize(struct plan9_s *hmm ) ;
void P9DefaultNullModel(float *null ) ;
static unsigned int v10magic  =    3907906993U;
static unsigned int v10swap  =    2985160168U;
static unsigned int v11magic  =    3907906994U;
static unsigned int v11swap  =    3001937384U;
static unsigned int v17magic  =    3907906995U;
static unsigned int v17swap  =    3018714600U;
static unsigned int v19magic  =    3907906996U;
static unsigned int v19swap  =    3035491816U;
static unsigned int v20magic  =    3907906997U;
static unsigned int v20swap  =    3052269032U;
static int read_asc20hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
static int read_bin20hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
static int read_asc19hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
static int read_bin19hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
static int read_asc17hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
static int read_bin17hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
static int read_asc11hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
static int read_bin11hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
static int read_asc10hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
static int read_bin10hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
static void byteswap(char *swap , int nbytes ) ;
static char *prob2ascii(float p , float null ) ;
static float ascii2prob(char *s___0 , float null ) ;
static void write_bin_string(FILE *fp , char *s___0 ) ;
static int read_bin_string(FILE *fp , int doswap , char **ret_s ) ;
static void multiline(FILE *fp , char *pfx , char *s___0 ) ;
static struct plan9_s *read_plan9_binhmm(FILE *fp , int version , int swapped ) ;
static struct plan9_s *read_plan9_aschmm(FILE *fp , int version ) ;
HMMFILE *HMMFileOpen(char *hmmfile , char *env ) 
{ 
  HMMFILE *hmmfp ;
  unsigned int magic ;
  char buf[512] ;
  char *ssifile ;
  char *dir ;
  int status ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  char *full ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  FILE *tmp___9 ;
  FILE *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  tmp = sre_malloc((char *)"hmmio.c", 164, sizeof(HMMFILE ));
  hmmfp = (HMMFILE *)tmp;
  hmmfp->f = (FILE *)((void *)0);
  hmmfp->parser = (int (*)(struct hmmfile_s * , struct plan7_s ** ))((void *)0);
  hmmfp->is_binary = 0;
  hmmfp->byteswap = 0;
  hmmfp->is_seekable = 1;
  hmmfp->f = (FILE *)((void *)0);
  hmmfp->ssi = (SSIFILE *)((void *)0);
  tmp___10 = fopen((char const   *)hmmfile, "r");
  hmmfp->f = tmp___10;
  if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
    tmp___0 = strlen((char const   *)hmmfile);
    tmp___1 = sre_malloc((char *)"hmmio.c", 181, sizeof(char ) * (tmp___0 + 5UL));
    ssifile = (char *)tmp___1;
    tmp___2 = __builtin_object_size((void *)ssifile, 1);
    __builtin___sprintf_chk(ssifile, 0, tmp___2, "%s.ssi", hmmfile);
    tmp___3 = SSIRecommendMode(hmmfile);
    hmmfp->mode = tmp___3;
    if (tmp___3 == -1) {
      Die((char *)"SSIRecommendMode() failed");
    }
  } else {
    tmp___9 = EnvFileOpen(hmmfile, env, & dir);
    hmmfp->f = tmp___9;
    if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
      full = FileConcat(dir, hmmfile);
      tmp___4 = strlen((char const   *)full);
      tmp___5 = strlen((char const   *)hmmfile);
      tmp___6 = sre_malloc((char *)"hmmio.c", 192, sizeof(char ) * ((tmp___4 + tmp___5) + 5UL));
      ssifile = (char *)tmp___6;
      tmp___7 = __builtin_object_size((void *)ssifile, 1);
      __builtin___sprintf_chk(ssifile, 0, tmp___7, "%s.ssi", full);
      tmp___8 = SSIRecommendMode(full);
      hmmfp->mode = tmp___8;
      if (tmp___8 == -1) {
        Die((char *)"SSIRecommendMode() failed");
      }
      free((void *)full);
      free((void *)dir);
    } else {
      return ((HMMFILE *)((void *)0));
    }
  }
  SSIOpen(ssifile, & hmmfp->ssi);
  free((void *)ssifile);
  status = SSIGetFilePosition(hmmfp->f, hmmfp->mode, & hmmfp->offset);
  if (status != 0) {
    Die((char *)"SSIGetFilePosition() failed");
  }
  tmp___11 = fread((void *)((char *)(& magic)), sizeof(unsigned int ), (size_t )1,
                   hmmfp->f);
  if (! tmp___11) {
    HMMFileClose(hmmfp);
    return ((HMMFILE *)((void *)0));
  }
  rewind(hmmfp->f);
  if (magic == v20magic) {
    hmmfp->parser = & read_bin20hmm;
    hmmfp->is_binary = 1;
    return (hmmfp);
  } else
  if (magic == v20swap) {
    hmmfp->parser = & read_bin20hmm;
    hmmfp->is_binary = 1;
    hmmfp->byteswap = 1;
    return (hmmfp);
  } else
  if (magic == v19magic) {
    hmmfp->parser = & read_bin19hmm;
    hmmfp->is_binary = 1;
    return (hmmfp);
  } else
  if (magic == v19swap) {
    hmmfp->parser = & read_bin19hmm;
    hmmfp->is_binary = 1;
    hmmfp->byteswap = 1;
    return (hmmfp);
  } else
  if (magic == v17magic) {
    hmmfp->parser = & read_bin17hmm;
    hmmfp->is_binary = 1;
    return (hmmfp);
  } else
  if (magic == v17swap) {
    hmmfp->parser = & read_bin17hmm;
    hmmfp->is_binary = 1;
    hmmfp->byteswap = 1;
    return (hmmfp);
  } else
  if (magic == v11magic) {
    hmmfp->parser = & read_bin11hmm;
    hmmfp->is_binary = 1;
    return (hmmfp);
  } else
  if (magic == v11swap) {
    hmmfp->parser = & read_bin11hmm;
    hmmfp->is_binary = 1;
    hmmfp->byteswap = 1;
    return (hmmfp);
  } else
  if (magic == v10magic) {
    hmmfp->parser = & read_bin10hmm;
    hmmfp->is_binary = 1;
    return (hmmfp);
  } else
  if (magic == v10swap) {
    hmmfp->parser = & read_bin10hmm;
    hmmfp->is_binary = 1;
    hmmfp->byteswap = 1;
    return (hmmfp);
  }
  if (magic & 2147483648U) {
    Warn((char *)"%s appears to be a binary but format is not recognized\nIt may be from a HMMER version more recent than yours,\nor may be a different kind of binary altogether.\n",
         hmmfile);
    HMMFileClose(hmmfp);
    return ((HMMFILE *)((void *)0));
  }
  tmp___12 = fgets(buf, 512, hmmfp->f);
  if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
    HMMFileClose(hmmfp);
    return ((HMMFILE *)((void *)0));
  }
  rewind(hmmfp->f);
  tmp___17 = strncmp("HMMER2.0", (char const   *)(buf), (size_t )8);
  if (tmp___17 == 0) {
    hmmfp->parser = & read_asc20hmm;
    return (hmmfp);
  } else {
    tmp___16 = strncmp("HMMER v1.9", (char const   *)(buf), (size_t )10);
    if (tmp___16 == 0) {
      hmmfp->parser = & read_asc19hmm;
      return (hmmfp);
    } else {
      tmp___15 = strncmp("# HMM v1.7", (char const   *)(buf), (size_t )10);
      if (tmp___15 == 0) {
        hmmfp->parser = & read_asc17hmm;
        return (hmmfp);
      } else {
        tmp___14 = strncmp("# HMM v1.1", (char const   *)(buf), (size_t )10);
        if (tmp___14 == 0) {
          hmmfp->parser = & read_asc11hmm;
          return (hmmfp);
        } else {
          tmp___13 = strncmp("# HMM v1.0", (char const   *)(buf), (size_t )10);
          if (tmp___13 == 0) {
            hmmfp->parser = & read_asc10hmm;
            return (hmmfp);
          }
        }
      }
    }
  }
  HMMFileClose(hmmfp);
  return ((HMMFILE *)((void *)0));
}
}
int HMMFileRead(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  int status ;
  int tmp ;

  {
  if (hmmfp->is_seekable) {
    status = SSIGetFilePosition(hmmfp->f, hmmfp->mode, & hmmfp->offset);
    if (status != 0) {
      Die((char *)"SSIGetFilePosition() failed");
    }
  }
  tmp = (*(hmmfp->parser))(hmmfp, ret_hmm);
  return (tmp);
}
}
void HMMFileClose(HMMFILE *hmmfp ) 
{ 


  {
  if ((unsigned long )hmmfp->f != (unsigned long )((void *)0)) {
    fclose(hmmfp->f);
  }
  if ((unsigned long )hmmfp->ssi != (unsigned long )((void *)0)) {
    SSIClose(hmmfp->ssi);
  }
  free((void *)hmmfp);
  return;
}
}
void HMMFileRewind(HMMFILE *hmmfp ) 
{ 


  {
  rewind(hmmfp->f);
  return;
}
}
int HMMFilePositionByName(HMMFILE *hmmfp , char *name ) 
{ 
  SSIOFFSET offset ;
  int fh ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )hmmfp->ssi == (unsigned long )((void *)0)) {
    return (0);
  }
  tmp = SSIGetOffsetByName(hmmfp->ssi, name, & fh, & offset);
  if (tmp != 0) {
    return (0);
  }
  tmp___0 = SSISetFilePosition(hmmfp->f, & offset);
  if (tmp___0 != 0) {
    return (0);
  }
  return (1);
}
}
int HMMFilePositionByIndex(HMMFILE *hmmfp , int idx ) 
{ 
  int fh ;
  SSIOFFSET offset ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )hmmfp->ssi == (unsigned long )((void *)0)) {
    return (0);
  }
  tmp = SSIGetOffsetByNumber(hmmfp->ssi, idx, & fh, & offset);
  if (tmp != 0) {
    return (0);
  }
  tmp___0 = SSISetFilePosition(hmmfp->f, & offset);
  if (tmp___0 != 0) {
    return (0);
  }
  return (1);
}
}
void WriteAscHMM(FILE *fp , struct plan7_s *hmm ) 
{ 
  int k ;
  int x ;
  int ts ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
  fprintf(fp, "HMMER2.0  [%s]\n", "2.3");
  fprintf(fp, "NAME  %s\n", hmm->name);
  if (hmm->flags & (1 << 9)) {
    fprintf(fp, "ACC   %s\n", hmm->acc);
  }
  if (hmm->flags & (1 << 1)) {
    fprintf(fp, "DESC  %s\n", hmm->desc);
  }
  fprintf(fp, "LENG  %d\n", hmm->M);
  if (Alphabet_type == 3) {
    tmp = "Amino";
  } else {
    tmp = "Nucleic";
  }
  fprintf(fp, "ALPH  %s\n", tmp);
  if (hmm->flags & (1 << 2)) {
    tmp___0 = "yes";
  } else {
    tmp___0 = "no";
  }
  fprintf(fp, "RF    %s\n", tmp___0);
  if (hmm->flags & (1 << 3)) {
    tmp___1 = "yes";
  } else {
    tmp___1 = "no";
  }
  fprintf(fp, "CS    %s\n", tmp___1);
  if (hmm->flags & (1 << 8)) {
    tmp___2 = "yes";
  } else {
    tmp___2 = "no";
  }
  fprintf(fp, "MAP   %s\n", tmp___2);
  multiline(fp, (char *)"COM   ", hmm->comlog);
  fprintf(fp, "NSEQ  %d\n", hmm->nseq);
  fprintf(fp, "DATE  %s\n", hmm->ctime);
  fprintf(fp, "CKSUM %d\n", hmm->checksum);
  if (hmm->flags & (1 << 10)) {
    fprintf(fp, "GA    %.1f %.1f\n", (double )hmm->ga1, (double )hmm->ga2);
  }
  if (hmm->flags & (1 << 11)) {
    fprintf(fp, "TC    %.1f %.1f\n", (double )hmm->tc1, (double )hmm->tc2);
  }
  if (hmm->flags & (1 << 12)) {
    fprintf(fp, "NC    %.1f %.1f\n", (double )hmm->nc1, (double )hmm->nc2);
  }
  fputs("XT     ", fp);
  k = 0;
  while (k < 4) {
    x = 0;
    while (x < 2) {
      tmp___3 = prob2ascii(hmm->xt[k][x], (float )1.0);
      fprintf(fp, "%6s ", tmp___3);
      x ++;
    }
    k ++;
  }
  fputs("\n", fp);
  fprintf(fp, "NULT  ");
  tmp___4 = prob2ascii(hmm->p1, (float )1.0);
  fprintf(fp, "%6s ", tmp___4);
  tmp___5 = prob2ascii((float )(1.0 - (double )hmm->p1), (float )1.0);
  fprintf(fp, "%6s\n", tmp___5);
  fputs("NULE  ", fp);
  x = 0;
  while (x < Alphabet_size) {
    tmp___6 = prob2ascii(hmm->null[x], (float )1 / (float )Alphabet_size);
    fprintf(fp, "%6s ", tmp___6);
    x ++;
  }
  fputs("\n", fp);
  if (hmm->flags & (1 << 7)) {
    fprintf(fp, "EVD   %10f %10f\n", (double )hmm->mu, (double )hmm->lambda);
  }
  fprintf(fp, "HMM      ");
  x = 0;
  while (x < Alphabet_size) {
    fprintf(fp, "  %c    ", (int )Alphabet[x]);
    x ++;
  }
  fprintf(fp, "\n");
  fprintf(fp, "       %6s %6s %6s %6s %6s %6s %6s %6s %6s\n", "m->m", "m->i", "m->d",
          "i->m", "i->i", "d->m", "d->d", "b->m", "m->e");
  tmp___7 = prob2ascii((float )1 - hmm->tbd1, (float )1.0);
  fprintf(fp, "       %6s %6s ", tmp___7, "*");
  tmp___8 = prob2ascii(hmm->tbd1, (float )1.0);
  fprintf(fp, "%6s\n", tmp___8);
  k = 1;
  while (k <= hmm->M) {
    fprintf(fp, " %5d ", k);
    x = 0;
    while (x < Alphabet_size) {
      tmp___9 = prob2ascii(*(*(hmm->mat + k) + x), hmm->null[x]);
      fprintf(fp, "%6s ", tmp___9);
      x ++;
    }
    if (hmm->flags & (1 << 8)) {
      fprintf(fp, "%5d", *(hmm->map + k));
    }
    fputs("\n", fp);
    if (hmm->flags & (1 << 2)) {
      tmp___10 = (int )*(hmm->rf + k);
    } else {
      tmp___10 = '-';
    }
    fprintf(fp, " %5c ", tmp___10);
    x = 0;
    while (x < Alphabet_size) {
      if (k < hmm->M) {
        tmp___11 = prob2ascii(*(*(hmm->ins + k) + x), hmm->null[x]);
        tmp___12 = (char const   *)tmp___11;
      } else {
        tmp___12 = "*";
      }
      fprintf(fp, "%6s ", tmp___12);
      x ++;
    }
    fputs("\n", fp);
    if (hmm->flags & (1 << 3)) {
      tmp___13 = (int )*(hmm->cs + k);
    } else {
      tmp___13 = '-';
    }
    fprintf(fp, " %5c ", tmp___13);
    ts = 0;
    while (ts < 7) {
      if (k < hmm->M) {
        tmp___14 = prob2ascii(*(*(hmm->t + k) + ts), (float )1.0);
        tmp___15 = (char const   *)tmp___14;
      } else {
        tmp___15 = "*";
      }
      fprintf(fp, "%6s ", tmp___15);
      ts ++;
    }
    tmp___16 = prob2ascii(*(hmm->begin + k), (float )1.0);
    fprintf(fp, "%6s ", tmp___16);
    tmp___17 = prob2ascii(*(hmm->end + k), (float )1.0);
    fprintf(fp, "%6s ", tmp___17);
    fputs("\n", fp);
    k ++;
  }
  fputs("//\n", fp);
  return;
}
}
void WriteBinHMM(FILE *fp , struct plan7_s *hmm ) 
{ 
  int k ;

  {
  fwrite((void const   *)((char *)(& v20magic)), sizeof(unsigned int ), (size_t )1,
         fp);
  fwrite((void const   *)((char *)(& hmm->flags)), sizeof(int ), (size_t )1, fp);
  write_bin_string(fp, hmm->name);
  if (hmm->flags & (1 << 9)) {
    write_bin_string(fp, hmm->acc);
  }
  if (hmm->flags & (1 << 1)) {
    write_bin_string(fp, hmm->desc);
  }
  fwrite((void const   *)((char *)(& hmm->M)), sizeof(int ), (size_t )1, fp);
  fwrite((void const   *)((char *)(& Alphabet_type)), sizeof(int ), (size_t )1, fp);
  if (hmm->flags & (1 << 2)) {
    fwrite((void const   *)hmm->rf, sizeof(char ), (size_t )(hmm->M + 1), fp);
  }
  if (hmm->flags & (1 << 3)) {
    fwrite((void const   *)hmm->cs, sizeof(char ), (size_t )(hmm->M + 1), fp);
  }
  if (hmm->flags & (1 << 8)) {
    fwrite((void const   *)((char *)hmm->map), sizeof(int ), (size_t )(hmm->M + 1),
           fp);
  }
  write_bin_string(fp, hmm->comlog);
  fwrite((void const   *)((char *)(& hmm->nseq)), sizeof(int ), (size_t )1, fp);
  write_bin_string(fp, hmm->ctime);
  fwrite((void const   *)((char *)(& hmm->checksum)), sizeof(int ), (size_t )1, fp);
  if (hmm->flags & (1 << 10)) {
    fwrite((void const   *)((char *)(& hmm->ga1)), sizeof(float ), (size_t )1, fp);
    fwrite((void const   *)((char *)(& hmm->ga2)), sizeof(float ), (size_t )1, fp);
  }
  if (hmm->flags & (1 << 11)) {
    fwrite((void const   *)((char *)(& hmm->tc1)), sizeof(float ), (size_t )1, fp);
    fwrite((void const   *)((char *)(& hmm->tc2)), sizeof(float ), (size_t )1, fp);
  }
  if (hmm->flags & (1 << 12)) {
    fwrite((void const   *)((char *)(& hmm->nc1)), sizeof(float ), (size_t )1, fp);
    fwrite((void const   *)((char *)(& hmm->nc2)), sizeof(float ), (size_t )1, fp);
  }
  k = 0;
  while (k < 4) {
    fwrite((void const   *)((char *)(hmm->xt[k])), sizeof(float ), (size_t )2, fp);
    k ++;
  }
  fwrite((void const   *)((char *)(& hmm->p1)), sizeof(float ), (size_t )1, fp);
  fwrite((void const   *)((char *)(hmm->null)), sizeof(float ), (size_t )Alphabet_size,
         fp);
  if (hmm->flags & (1 << 7)) {
    fwrite((void const   *)((char *)(& hmm->mu)), sizeof(float ), (size_t )1, fp);
    fwrite((void const   *)((char *)(& hmm->lambda)), sizeof(float ), (size_t )1,
           fp);
  }
  fwrite((void const   *)((char *)(& hmm->tbd1)), sizeof(float ), (size_t )1, fp);
  fwrite((void const   *)((char *)hmm->begin), sizeof(float ), (size_t )(hmm->M + 1),
         fp);
  fwrite((void const   *)((char *)hmm->end), sizeof(float ), (size_t )(hmm->M + 1),
         fp);
  k = 1;
  while (k <= hmm->M) {
    fwrite((void const   *)((char *)*(hmm->mat + k)), sizeof(float ), (size_t )Alphabet_size,
           fp);
    k ++;
  }
  k = 1;
  while (k < hmm->M) {
    fwrite((void const   *)((char *)*(hmm->ins + k)), sizeof(float ), (size_t )Alphabet_size,
           fp);
    k ++;
  }
  k = 1;
  while (k < hmm->M) {
    fwrite((void const   *)((char *)*(hmm->t + k)), sizeof(float ), (size_t )7, fp);
    k ++;
  }
  return;
}
}
static int read_asc20hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  struct plan7_s *hmm ;
  char buffer___1[512] ;
  char *s___0 ;
  int M ;
  float p ;
  int k ;
  int x ;
  int atype ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;
  unsigned long tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  float tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;

  {
  hmm = (struct plan7_s *)((void *)0);
  tmp = feof(hmmfp->f);
  if (tmp) {
    return (0);
  } else {
    tmp___0 = fgets(buffer___1, 512, hmmfp->f);
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      return (0);
    }
  }
  tmp___1 = strncmp((char const   *)(buffer___1), "HMMER2.0", (size_t )8);
  if (tmp___1 != 0) {
    goto FAILURE;
  }
  hmm = AllocPlan7Shell();
  M = -1;
  while (1) {
    tmp___45 = fgets(buffer___1, 512, hmmfp->f);
    if (! ((unsigned long )tmp___45 != (unsigned long )((void *)0))) {
      break;
    }
    tmp___44 = strncmp((char const   *)(buffer___1), "NAME ", (size_t )5);
    if (tmp___44 == 0) {
      Plan7SetName(hmm, buffer___1 + 6);
    } else {
      tmp___43 = strncmp((char const   *)(buffer___1), "ACC  ", (size_t )5);
      if (tmp___43 == 0) {
        Plan7SetAccession(hmm, buffer___1 + 6);
      } else {
        tmp___42 = strncmp((char const   *)(buffer___1), "DESC ", (size_t )5);
        if (tmp___42 == 0) {
          Plan7SetDescription(hmm, buffer___1 + 6);
        } else {
          tmp___41 = strncmp((char const   *)(buffer___1), "LENG ", (size_t )5);
          if (tmp___41 == 0) {
            M = atoi((char const   *)(buffer___1 + 6));
          } else {
            tmp___40 = strncmp((char const   *)(buffer___1), "NSEQ ", (size_t )5);
            if (tmp___40 == 0) {
              hmm->nseq = atoi((char const   *)(buffer___1 + 6));
            } else {
              tmp___39 = strncmp((char const   *)(buffer___1), "ALPH ", (size_t )5);
              if (tmp___39 == 0) {
                s2upper(buffer___1 + 6);
                tmp___3 = strncmp((char const   *)(buffer___1 + 6), "AMINO", (size_t )5);
                if (tmp___3 == 0) {
                  atype = 3;
                } else {
                  tmp___2 = strncmp((char const   *)(buffer___1 + 6), "NUCLEIC", (size_t )7);
                  if (tmp___2 == 0) {
                    atype = 2;
                  } else {
                    goto FAILURE;
                  }
                }
                if (Alphabet_type == 0) {
                  SetAlphabet(atype);
                } else
                if (atype != Alphabet_type) {
                  tmp___4 = AlphabetType2String(atype);
                  tmp___5 = AlphabetType2String(Alphabet_type);
                  Die((char *)"Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n",
                      tmp___5, tmp___4);
                }
              } else {
                tmp___38 = strncmp((char const   *)(buffer___1), "RF   ", (size_t )5);
                if (tmp___38 == 0) {
                  tmp___6 = sre_toupper((int )*(buffer___1 + 6));
                  if (tmp___6 == 89) {
                    hmm->flags |= 1 << 2;
                  }
                } else {
                  tmp___37 = strncmp((char const   *)(buffer___1), "CS   ", (size_t )5);
                  if (tmp___37 == 0) {
                    tmp___7 = sre_toupper((int )*(buffer___1 + 6));
                    if (tmp___7 == 89) {
                      hmm->flags |= 1 << 3;
                    }
                  } else {
                    tmp___36 = strncmp((char const   *)(buffer___1), "MAP  ", (size_t )5);
                    if (tmp___36 == 0) {
                      tmp___8 = sre_toupper((int )*(buffer___1 + 6));
                      if (tmp___8 == 89) {
                        hmm->flags |= 1 << 8;
                      }
                    } else {
                      tmp___35 = strncmp((char const   *)(buffer___1), "COM  ", (size_t )5);
                      if (tmp___35 == 0) {
                        StringChop(buffer___1 + 6);
                        if ((unsigned long )hmm->comlog == (unsigned long )((void *)0)) {
                          hmm->comlog = Strdup(buffer___1 + 6);
                        } else {
                          tmp___9 = strlen((char const   *)hmm->comlog);
                          tmp___10 = strlen((char const   *)(buffer___1 + 6));
                          tmp___11 = sre_realloc((char *)"hmmio.c", 624, (void *)hmm->comlog,
                                                 sizeof(char *) * ((tmp___9 + 1UL) + tmp___10));
                          hmm->comlog = (char *)tmp___11;
                          tmp___13 = __builtin_object_size((void *)hmm->comlog, 0);
                          if (tmp___13 != 0xffffffffffffffffUL) {
                            tmp___12 = __builtin_object_size((void *)hmm->comlog,
                                                             1);
                            __builtin___strcat_chk(hmm->comlog, "\n", tmp___12);
                          } else {
                            __inline_strcat_chk(hmm->comlog, "\n");
                          }
                          tmp___15 = __builtin_object_size((void *)hmm->comlog, 0);
                          if (tmp___15 != 0xffffffffffffffffUL) {
                            tmp___14 = __builtin_object_size((void *)hmm->comlog,
                                                             1);
                            __builtin___strcat_chk(hmm->comlog, (char const   *)(buffer___1 + 6),
                                                   tmp___14);
                          } else {
                            __inline_strcat_chk(hmm->comlog, (char const   *)(buffer___1 + 6));
                          }
                        }
                      } else {
                        tmp___34 = strncmp((char const   *)(buffer___1), "DATE ",
                                           (size_t )5);
                        if (tmp___34 == 0) {
                          StringChop(buffer___1 + 6);
                          hmm->ctime = Strdup(buffer___1 + 6);
                        } else {
                          tmp___33 = strncmp((char const   *)(buffer___1), "GA   ",
                                             (size_t )5);
                          if (tmp___33 == 0) {
                            s___0 = strtok(buffer___1 + 6, " \t\n");
                            if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                              goto FAILURE;
                            }
                            tmp___16 = atof((char const   *)s___0);
                            hmm->ga1 = (float )tmp___16;
                            s___0 = strtok((char *)((void *)0), " \t\n");
                            if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                              goto FAILURE;
                            }
                            tmp___17 = atof((char const   *)s___0);
                            hmm->ga2 = (float )tmp___17;
                            hmm->flags |= 1 << 10;
                          } else {
                            tmp___32 = strncmp((char const   *)(buffer___1), "TC   ",
                                               (size_t )5);
                            if (tmp___32 == 0) {
                              s___0 = strtok(buffer___1 + 6, " \t\n");
                              if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                                goto FAILURE;
                              }
                              tmp___18 = atof((char const   *)s___0);
                              hmm->tc1 = (float )tmp___18;
                              s___0 = strtok((char *)((void *)0), " \t\n");
                              if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                                goto FAILURE;
                              }
                              tmp___19 = atof((char const   *)s___0);
                              hmm->tc2 = (float )tmp___19;
                              hmm->flags |= 1 << 11;
                            } else {
                              tmp___31 = strncmp((char const   *)(buffer___1), "NC   ",
                                                 (size_t )5);
                              if (tmp___31 == 0) {
                                s___0 = strtok(buffer___1 + 6, " \t\n");
                                if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                                  goto FAILURE;
                                }
                                tmp___20 = atof((char const   *)s___0);
                                hmm->nc1 = (float )tmp___20;
                                s___0 = strtok((char *)((void *)0), " \t\n");
                                if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                                  goto FAILURE;
                                }
                                tmp___21 = atof((char const   *)s___0);
                                hmm->nc2 = (float )tmp___21;
                                hmm->flags |= 1 << 12;
                              } else {
                                tmp___30 = strncmp((char const   *)(buffer___1), "XT   ",
                                                   (size_t )5);
                                if (tmp___30 == 0) {
                                  s___0 = strtok(buffer___1 + 6, " \t\n");
                                  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                                    goto FAILURE;
                                  }
                                  k = 0;
                                  while (k < 4) {
                                    x = 0;
                                    while (x < 2) {
                                      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                                        goto FAILURE;
                                      }
                                      hmm->xt[k][x] = ascii2prob(s___0, (float )1.0);
                                      s___0 = strtok((char *)((void *)0), " \t\n");
                                      x ++;
                                    }
                                    k ++;
                                  }
                                } else {
                                  tmp___29 = strncmp((char const   *)(buffer___1),
                                                     "NULT ", (size_t )5);
                                  if (tmp___29 == 0) {
                                    s___0 = strtok(buffer___1 + 6, " \t\n");
                                    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                                      goto FAILURE;
                                    }
                                    hmm->p1 = ascii2prob(s___0, (float )1.);
                                    s___0 = strtok((char *)((void *)0), " \t\n");
                                    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                                      goto FAILURE;
                                    }
                                    tmp___22 = ascii2prob(s___0, (float )1.0);
                                    hmm->p1 /= hmm->p1 + tmp___22;
                                  } else {
                                    tmp___28 = strncmp((char const   *)(buffer___1),
                                                       "NULE ", (size_t )5);
                                    if (tmp___28 == 0) {
                                      if (Alphabet_type == 0) {
                                        Die((char *)"ALPH must precede NULE in HMM save files");
                                      }
                                      s___0 = strtok(buffer___1 + 6, " \t\n");
                                      x = 0;
                                      while (x < Alphabet_size) {
                                        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                                          goto FAILURE;
                                        }
                                        hmm->null[x] = ascii2prob(s___0, (float )(1. / (double )((float )Alphabet_size)));
                                        s___0 = strtok((char *)((void *)0), " \t\n");
                                        x ++;
                                      }
                                    } else {
                                      tmp___27 = strncmp((char const   *)(buffer___1),
                                                         "EVD  ", (size_t )5);
                                      if (tmp___27 == 0) {
                                        hmm->flags |= 1 << 7;
                                        s___0 = strtok(buffer___1 + 6, " \t\n");
                                        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                                          goto FAILURE;
                                        }
                                        tmp___23 = atof((char const   *)s___0);
                                        hmm->mu = (float )tmp___23;
                                        s___0 = strtok((char *)((void *)0), " \t\n");
                                        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
                                          goto FAILURE;
                                        }
                                        tmp___24 = atof((char const   *)s___0);
                                        hmm->lambda = (float )tmp___24;
                                      } else {
                                        tmp___26 = strncmp((char const   *)(buffer___1),
                                                           "CKSUM", (size_t )5);
                                        if (tmp___26 == 0) {
                                          hmm->checksum = atoi((char const   *)(buffer___1 + 6));
                                        } else {
                                          tmp___25 = strncmp((char const   *)(buffer___1),
                                                             "HMM  ", (size_t )5);
                                          if (tmp___25 == 0) {
                                            break;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  tmp___46 = feof(hmmfp->f);
  if (tmp___46) {
    goto FAILURE;
  }
  if (M < 1) {
    goto FAILURE;
  }
  if ((unsigned long )hmm->name == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  if (Alphabet_type == 0) {
    goto FAILURE;
  }
  AllocPlan7Body(hmm, M);
  tmp___47 = fgets(buffer___1, 512, hmmfp->f);
  if ((unsigned long )tmp___47 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  tmp___48 = fgets(buffer___1, 512, hmmfp->f);
  if ((unsigned long )tmp___48 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  s___0 = strtok(buffer___1, " \t\n");
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  p = ascii2prob(s___0, (float )1.0);
  s___0 = strtok((char *)((void *)0), " \t\n");
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  s___0 = strtok((char *)((void *)0), " \t\n");
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  hmm->tbd1 = ascii2prob(s___0, (float )1.0);
  hmm->tbd1 /= p + hmm->tbd1;
  k = 1;
  while (k <= hmm->M) {
    tmp___49 = fgets(buffer___1, 512, hmmfp->f);
    if ((unsigned long )tmp___49 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    s___0 = strtok(buffer___1, " \t\n");
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    tmp___50 = atoi((char const   *)s___0);
    if (tmp___50 != k) {
      goto FAILURE;
    }
    x = 0;
    while (x < Alphabet_size) {
      s___0 = strtok((char *)((void *)0), " \t\n");
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
        goto FAILURE;
      }
      *(*(hmm->mat + k) + x) = ascii2prob(s___0, hmm->null[x]);
      x ++;
    }
    if (hmm->flags & (1 << 8)) {
      s___0 = strtok((char *)((void *)0), " \t\n");
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
        goto FAILURE;
      }
      *(hmm->map + k) = atoi((char const   *)s___0);
    }
    tmp___51 = fgets(buffer___1, 512, hmmfp->f);
    if ((unsigned long )tmp___51 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    s___0 = strtok(buffer___1, " \t\n");
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    if (hmm->flags & (1 << 2)) {
      *(hmm->rf + k) = *s___0;
    }
    if (k < hmm->M) {
      x = 0;
      while (x < Alphabet_size) {
        s___0 = strtok((char *)((void *)0), " \t\n");
        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
          goto FAILURE;
        }
        *(*(hmm->ins + k) + x) = ascii2prob(s___0, hmm->null[x]);
        x ++;
      }
    }
    tmp___52 = fgets(buffer___1, 512, hmmfp->f);
    if ((unsigned long )tmp___52 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    s___0 = strtok(buffer___1, " \t\n");
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    if (hmm->flags & (1 << 3)) {
      *(hmm->cs + k) = *s___0;
    }
    x = 0;
    while (x < 7) {
      s___0 = strtok((char *)((void *)0), " \t\n");
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
        goto FAILURE;
      }
      if (k < hmm->M) {
        *(*(hmm->t + k) + x) = ascii2prob(s___0, (float )1.0);
      }
      x ++;
    }
    s___0 = strtok((char *)((void *)0), " \t\n");
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    *(hmm->begin + k) = ascii2prob(s___0, (float )1.0);
    s___0 = strtok((char *)((void *)0), " \t\n");
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    *(hmm->end + k) = ascii2prob(s___0, (float )1.0);
    k ++;
  }
  while (1) {
    tmp___54 = fgets(buffer___1, 512, hmmfp->f);
    if (! ((unsigned long )tmp___54 != (unsigned long )((void *)0))) {
      break;
    }
    tmp___53 = strncmp((char const   *)(buffer___1), "//", (size_t )2);
    if (tmp___53 == 0) {
      break;
    }
  }
  Plan7Renormalize(hmm);
  hmm->flags |= 1 << 5;
  hmm->flags &= -2;
  *ret_hmm = hmm;
  return (1);
  FAILURE: 
  if ((unsigned long )hmm != (unsigned long )((void *)0)) {
    FreePlan7(hmm);
  }
  *ret_hmm = (struct plan7_s *)((void *)0);
  return (1);
}
}
static int read_bin20hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  struct plan7_s *hmm ;
  int k ;
  int x ;
  int type ;
  unsigned int magic ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;

  {
  hmm = (struct plan7_s *)((void *)0);
  tmp = feof(hmmfp->f);
  if (tmp) {
    return (0);
  }
  tmp___0 = fread((void *)((char *)(& magic)), sizeof(unsigned int ), (size_t )1,
                  hmmfp->f);
  if (! tmp___0) {
    return (0);
  }
  if (hmmfp->byteswap) {
    byteswap((char *)(& magic), (int )sizeof(unsigned int ));
  }
  if (magic != v20magic) {
    goto FAILURE;
  }
  hmm = AllocPlan7Shell();
  tmp___1 = fread((void *)((char *)(& hmm->flags)), sizeof(int ), (size_t )1, hmmfp->f);
  if (! tmp___1) {
    goto FAILURE;
  }
  if (hmmfp->byteswap) {
    byteswap((char *)(& hmm->flags), (int )sizeof(int ));
  }
  tmp___2 = read_bin_string(hmmfp->f, hmmfp->byteswap, & hmm->name);
  if (! tmp___2) {
    goto FAILURE;
  }
  if (hmm->flags & (1 << 9)) {
    tmp___3 = read_bin_string(hmmfp->f, hmmfp->byteswap, & hmm->acc);
    if (! tmp___3) {
      goto FAILURE;
    }
  }
  if (hmm->flags & (1 << 1)) {
    tmp___4 = read_bin_string(hmmfp->f, hmmfp->byteswap, & hmm->desc);
    if (! tmp___4) {
      goto FAILURE;
    }
  }
  tmp___5 = fread((void *)((char *)(& hmm->M)), sizeof(int ), (size_t )1, hmmfp->f);
  if (! tmp___5) {
    goto FAILURE;
  }
  if (hmmfp->byteswap) {
    byteswap((char *)(& hmm->M), (int )sizeof(int ));
  }
  tmp___6 = fread((void *)((char *)(& type)), sizeof(int ), (size_t )1, hmmfp->f);
  if (! tmp___6) {
    goto FAILURE;
  }
  if (hmmfp->byteswap) {
    byteswap((char *)(& type), (int )sizeof(int ));
  }
  if (Alphabet_type == 0) {
    SetAlphabet(type);
  } else
  if (type != Alphabet_type) {
    tmp___7 = AlphabetType2String(type);
    tmp___8 = AlphabetType2String(Alphabet_type);
    Die((char *)"Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n",
        tmp___8, tmp___7);
  }
  AllocPlan7Body(hmm, hmm->M);
  if (hmm->flags & (1 << 2)) {
    tmp___9 = fread((void *)hmm->rf, sizeof(char ), (size_t )(hmm->M + 1), hmmfp->f);
    if (! tmp___9) {
      goto FAILURE;
    }
  }
  *(hmm->rf + (hmm->M + 1)) = (char )'\000';
  if (hmm->flags & (1 << 3)) {
    tmp___10 = fread((void *)hmm->cs, sizeof(char ), (size_t )(hmm->M + 1), hmmfp->f);
    if (! tmp___10) {
      goto FAILURE;
    }
  }
  *(hmm->cs + (hmm->M + 1)) = (char )'\000';
  if (hmm->flags & (1 << 8)) {
    tmp___11 = fread((void *)((char *)hmm->map), sizeof(int ), (size_t )(hmm->M + 1),
                     hmmfp->f);
    if (! tmp___11) {
      goto FAILURE;
    }
  }
  if (hmmfp->byteswap) {
    k = 1;
    while (k <= hmm->M) {
      byteswap((char *)(hmm->map + k), (int )sizeof(int ));
      k ++;
    }
  }
  tmp___12 = read_bin_string(hmmfp->f, hmmfp->byteswap, & hmm->comlog);
  if (! tmp___12) {
    goto FAILURE;
  }
  tmp___13 = fread((void *)((char *)(& hmm->nseq)), sizeof(int ), (size_t )1, hmmfp->f);
  if (! tmp___13) {
    goto FAILURE;
  }
  if (hmmfp->byteswap) {
    byteswap((char *)(& hmm->nseq), (int )sizeof(int ));
  }
  tmp___14 = read_bin_string(hmmfp->f, hmmfp->byteswap, & hmm->ctime);
  if (! tmp___14) {
    goto FAILURE;
  }
  tmp___15 = fread((void *)((char *)(& hmm->checksum)), sizeof(int ), (size_t )1,
                   hmmfp->f);
  if (! tmp___15) {
    goto FAILURE;
  }
  if (hmmfp->byteswap) {
    byteswap((char *)(& hmm->checksum), (int )sizeof(int ));
  }
  if (hmm->flags & (1 << 10)) {
    tmp___16 = fread((void *)((char *)(& hmm->ga1)), sizeof(float ), (size_t )1, hmmfp->f);
    if (! tmp___16) {
      goto FAILURE;
    }
    tmp___17 = fread((void *)((char *)(& hmm->ga2)), sizeof(float ), (size_t )1, hmmfp->f);
    if (! tmp___17) {
      goto FAILURE;
    }
    if (hmmfp->byteswap) {
      byteswap((char *)(& hmm->ga1), (int )sizeof(float ));
      byteswap((char *)(& hmm->ga2), (int )sizeof(float ));
    }
  }
  if (hmm->flags & (1 << 11)) {
    tmp___18 = fread((void *)((char *)(& hmm->tc1)), sizeof(float ), (size_t )1, hmmfp->f);
    if (! tmp___18) {
      goto FAILURE;
    }
    tmp___19 = fread((void *)((char *)(& hmm->tc2)), sizeof(float ), (size_t )1, hmmfp->f);
    if (! tmp___19) {
      goto FAILURE;
    }
    if (hmmfp->byteswap) {
      byteswap((char *)(& hmm->tc1), (int )sizeof(float ));
      byteswap((char *)(& hmm->tc2), (int )sizeof(float ));
    }
  }
  if (hmm->flags & (1 << 12)) {
    tmp___20 = fread((void *)((char *)(& hmm->nc1)), sizeof(float ), (size_t )1, hmmfp->f);
    if (! tmp___20) {
      goto FAILURE;
    }
    tmp___21 = fread((void *)((char *)(& hmm->nc2)), sizeof(float ), (size_t )1, hmmfp->f);
    if (! tmp___21) {
      goto FAILURE;
    }
    if (hmmfp->byteswap) {
      byteswap((char *)(& hmm->nc1), (int )sizeof(float ));
      byteswap((char *)(& hmm->nc2), (int )sizeof(float ));
    }
  }
  k = 0;
  while (k < 4) {
    tmp___22 = fread((void *)((char *)(hmm->xt[k])), sizeof(float ), (size_t )2, hmmfp->f);
    if (! tmp___22) {
      goto FAILURE;
    }
    if (hmmfp->byteswap) {
      x = 0;
      while (x < 2) {
        byteswap((char *)(& hmm->xt[k][x]), (int )sizeof(float ));
        x ++;
      }
    }
    k ++;
  }
  tmp___23 = fread((void *)((char *)(& hmm->p1)), sizeof(float ), (size_t )1, hmmfp->f);
  if (! tmp___23) {
    goto FAILURE;
  }
  tmp___24 = fread((void *)((char *)(hmm->null)), sizeof(float ), (size_t )Alphabet_size,
                   hmmfp->f);
  if (! tmp___24) {
    goto FAILURE;
  }
  if (hmm->flags & (1 << 7)) {
    tmp___25 = fread((void *)((char *)(& hmm->mu)), sizeof(float ), (size_t )1, hmmfp->f);
    if (! tmp___25) {
      goto FAILURE;
    }
    tmp___26 = fread((void *)((char *)(& hmm->lambda)), sizeof(float ), (size_t )1,
                     hmmfp->f);
    if (! tmp___26) {
      goto FAILURE;
    }
    if (hmmfp->byteswap) {
      byteswap((char *)(& hmm->mu), (int )sizeof(float ));
      byteswap((char *)(& hmm->lambda), (int )sizeof(float ));
    }
  }
  tmp___27 = fread((void *)((char *)(& hmm->tbd1)), sizeof(float ), (size_t )1, hmmfp->f);
  if (! tmp___27) {
    goto FAILURE;
  }
  tmp___28 = fread((void *)((char *)hmm->begin), sizeof(float ), (size_t )(hmm->M + 1),
                   hmmfp->f);
  if (! tmp___28) {
    goto FAILURE;
  }
  tmp___29 = fread((void *)((char *)hmm->end), sizeof(float ), (size_t )(hmm->M + 1),
                   hmmfp->f);
  if (! tmp___29) {
    goto FAILURE;
  }
  k = 1;
  while (k <= hmm->M) {
    tmp___30 = fread((void *)((char *)*(hmm->mat + k)), sizeof(float ), (size_t )Alphabet_size,
                     hmmfp->f);
    if (! tmp___30) {
      goto FAILURE;
    }
    k ++;
  }
  k = 1;
  while (k < hmm->M) {
    tmp___31 = fread((void *)((char *)*(hmm->ins + k)), sizeof(float ), (size_t )Alphabet_size,
                     hmmfp->f);
    if (! tmp___31) {
      goto FAILURE;
    }
    k ++;
  }
  k = 1;
  while (k < hmm->M) {
    tmp___32 = fread((void *)((char *)*(hmm->t + k)), sizeof(float ), (size_t )7,
                     hmmfp->f);
    if (! tmp___32) {
      goto FAILURE;
    }
    k ++;
  }
  if (hmmfp->byteswap) {
    x = 0;
    while (x < Alphabet_size) {
      byteswap((char *)(& hmm->null[x]), (int )sizeof(float ));
      x ++;
    }
    byteswap((char *)(& hmm->p1), (int )sizeof(float ));
    byteswap((char *)(& hmm->tbd1), (int )sizeof(float ));
    k = 1;
    while (k <= hmm->M) {
      x = 0;
      while (x < Alphabet_size) {
        byteswap((char *)(*(hmm->mat + k) + x), (int )sizeof(float ));
        x ++;
      }
      if (k < hmm->M) {
        x = 0;
        while (x < Alphabet_size) {
          byteswap((char *)(*(hmm->ins + k) + x), (int )sizeof(float ));
          x ++;
        }
      }
      byteswap((char *)(hmm->begin + k), (int )sizeof(float ));
      byteswap((char *)(hmm->end + k), (int )sizeof(float ));
      if (k < hmm->M) {
        x = 0;
        while (x < 7) {
          byteswap((char *)(*(hmm->t + k) + x), (int )sizeof(float ));
          x ++;
        }
      }
      k ++;
    }
  }
  hmm->flags |= 1 << 5;
  hmm->flags &= -2;
  *ret_hmm = hmm;
  return (1);
  FAILURE: 
  if ((unsigned long )hmm != (unsigned long )((void *)0)) {
    FreePlan7(hmm);
  }
  *ret_hmm = (struct plan7_s *)((void *)0);
  return (1);
}
}
static int read_asc19hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  struct plan7_s *hmm ;
  FILE *fp ;
  char buffer___1[512] ;
  char *s___0 ;
  int M ;
  int k ;
  int x ;
  int atype ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  float tmp___11 ;
  float tmp___12 ;

  {
  hmm = (struct plan7_s *)((void *)0);
  fp = hmmfp->f;
  tmp = feof(fp);
  if (tmp) {
    return (0);
  } else {
    tmp___0 = fgets(buffer___1, 512, fp);
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      return (0);
    }
  }
  tmp___1 = strncmp((char const   *)(buffer___1), "HMMER v1.9", (size_t )10);
  if (tmp___1 != 0) {
    goto FAILURE;
  }
  hmm = AllocPlan7Shell();
  s___0 = Getword(fp, 1);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  M = atoi((char const   *)s___0);
  s___0 = Getword(fp, 1);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  s___0 = Getword(fp, 4);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  Plan7SetName(hmm, s___0);
  s___0 = Getword(fp, 4);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  s2upper(s___0);
  tmp___3 = strcmp((char const   *)s___0, "AMINO");
  if (tmp___3 == 0) {
    atype = 3;
  } else {
    tmp___2 = strcmp((char const   *)s___0, "NUCLEIC");
    if (tmp___2 == 0) {
      atype = 2;
    } else {
      goto FAILURE;
    }
  }
  if (Alphabet_type == 0) {
    SetAlphabet(atype);
  } else
  if (atype != Alphabet_type) {
    tmp___4 = AlphabetType2String(atype);
    tmp___5 = AlphabetType2String(Alphabet_type);
    Die((char *)"Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n",
        tmp___5, tmp___4);
  }
  s___0 = Getword(fp, 4);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  tmp___6 = strncmp((char const   *)s___0, (char const   *)(Alphabet), (size_t )Alphabet_size);
  if (tmp___6 != 0) {
    goto FAILURE;
  }
  s___0 = Getword(fp, 4);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  tmp___7 = strcmp((char const   *)s___0, "yes");
  if (tmp___7 == 0) {
    hmm->flags |= 1 << 2;
  }
  s___0 = Getword(fp, 4);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  tmp___8 = strcmp((char const   *)s___0, "yes");
  if (tmp___8 == 0) {
    hmm->flags |= 1 << 3;
  }
  s___0 = Getword(fp, 4);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  tmp___9 = strcmp((char const   *)s___0, "null");
  if (tmp___9 != 0) {
    goto FAILURE;
  }
  x = 0;
  while (x < Alphabet_size) {
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    hmm->null[x] = ascii2prob(s___0, (float )1.0);
    x ++;
  }
  if (Alphabet_type == 3) {
    hmm->p1 = (float )(350. / 351.);
  } else {
    hmm->p1 = (float )(1000. / 1001.);
  }
  tmp___10 = feof(hmmfp->f);
  if (tmp___10) {
    goto FAILURE;
  }
  if (M < 1) {
    goto FAILURE;
  }
  if ((unsigned long )hmm->name == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  if (Alphabet_type == 0) {
    goto FAILURE;
  }
  AllocPlan7Body(hmm, M);
  ZeroPlan7(hmm);
  Plan7LSConfig(hmm);
  s___0 = Getword(fp, 1);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  x = 0;
  while (x < Alphabet_size) {
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    x ++;
  }
  s___0 = Getword(fp, 1);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  *(hmm->begin + 1) = ascii2prob(s___0, (float )1.0);
  s___0 = Getword(fp, 1);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  hmm->tbd1 = ascii2prob(s___0, (float )1.0);
  *(hmm->begin + 1) /= *(hmm->begin + 1) + hmm->tbd1;
  hmm->tbd1 /= *(hmm->begin + 1) + hmm->tbd1;
  x = 0;
  while (x < 7) {
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    x ++;
  }
  s___0 = Getword(fp, 4);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  s___0 = Getword(fp, 4);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  k = 1;
  while (k <= hmm->M) {
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    x = 0;
    while (x < Alphabet_size) {
      s___0 = Getword(fp, 1);
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
        goto FAILURE;
      }
      *(*(hmm->mat + k) + x) = ascii2prob(s___0, hmm->null[x]);
      x ++;
    }
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    if (k < hmm->M) {
      *(*(hmm->t + k) + 0) = ascii2prob(s___0, (float )1.0);
    }
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    if (k < hmm->M) {
      if (k == hmm->M) {
        *(*(hmm->t + k) + 2) = (float )0.0;
      } else {
        tmp___11 = ascii2prob(s___0, (float )1.0);
        *(*(hmm->t + k) + 2) = tmp___11;
      }
    }
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    if (k < hmm->M) {
      *(*(hmm->t + k) + 1) = ascii2prob(s___0, (float )1.0);
    }
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    if (k < hmm->M) {
      *(*(hmm->t + k) + 5) = ascii2prob(s___0, (float )1.0);
    }
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    if (k < hmm->M) {
      if (k == hmm->M) {
        *(*(hmm->t + k) + 6) = (float )0.0;
      } else {
        tmp___12 = ascii2prob(s___0, (float )1.0);
        *(*(hmm->t + k) + 6) = tmp___12;
      }
    }
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    if (k < hmm->M) {
      *(*(hmm->t + k) + 3) = ascii2prob(s___0, (float )1.0);
    }
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    if (k < hmm->M) {
      *(*(hmm->t + k) + 4) = ascii2prob(s___0, (float )1.0);
    }
    s___0 = Getword(fp, 4);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    if (hmm->flags & (1 << 2)) {
      *(hmm->rf + k) = *s___0;
    }
    s___0 = Getword(fp, 4);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    if (hmm->flags & (1 << 3)) {
      *(hmm->cs + k) = *s___0;
    }
    k ++;
  }
  k = 0;
  while (k <= hmm->M) {
    s___0 = Getword(fp, 1);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    x = 0;
    while (x < Alphabet_size) {
      s___0 = Getword(fp, 1);
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
        goto FAILURE;
      }
      if (k > 0) {
        if (k < hmm->M) {
          *(*(hmm->ins + k) + x) = ascii2prob(s___0, hmm->null[x]);
        }
      }
      x ++;
    }
    k ++;
  }
  hmm->flags |= 1 << 5;
  hmm->flags &= -2;
  Plan7Renormalize(hmm);
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
  Plan7SetCtime(hmm);
  *ret_hmm = hmm;
  return (1);
  FAILURE: 
  if ((unsigned long )hmm != (unsigned long )((void *)0)) {
    FreePlan7(hmm);
  }
  *ret_hmm = (struct plan7_s *)((void *)0);
  return (1);
}
}
static int read_bin19hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  unsigned int magic ;
  struct plan7_s *hmm ;
  struct plan9_s *p9hmm ;
  int tmp ;
  size_t tmp___0 ;

  {
  tmp = feof(hmmfp->f);
  if (tmp) {
    return (0);
  }
  tmp___0 = fread((void *)((char *)(& magic)), sizeof(unsigned int ), (size_t )1,
                  hmmfp->f);
  if (! tmp___0) {
    return (0);
  }
  p9hmm = read_plan9_binhmm(hmmfp->f, 7, hmmfp->byteswap);
  if ((unsigned long )p9hmm == (unsigned long )((void *)0)) {
    *ret_hmm = (struct plan7_s *)((void *)0);
    return (1);
  }
  Plan9toPlan7(p9hmm, & hmm);
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
  Plan7SetCtime(hmm);
  P9FreeHMM(p9hmm);
  *ret_hmm = hmm;
  return (1);
}
}
static int read_asc17hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  struct plan7_s *hmm ;
  struct plan9_s *p9hmm ;
  char buffer___1[512] ;
  int tmp ;
  char *tmp___0 ;

  {
  tmp = feof(hmmfp->f);
  if (tmp) {
    return (0);
  } else {
    tmp___0 = fgets(buffer___1, 512, hmmfp->f);
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      return (0);
    }
  }
  p9hmm = read_plan9_aschmm(hmmfp->f, 6);
  if ((unsigned long )p9hmm == (unsigned long )((void *)0)) {
    *ret_hmm = (struct plan7_s *)((void *)0);
    return (1);
  }
  Plan9toPlan7(p9hmm, & hmm);
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
  Plan7SetCtime(hmm);
  P9FreeHMM(p9hmm);
  Plan7Renormalize(hmm);
  *ret_hmm = hmm;
  return (1);
}
}
static int read_bin17hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  unsigned int magic ;
  struct plan7_s *hmm ;
  struct plan9_s *p9hmm ;
  int tmp ;
  size_t tmp___0 ;

  {
  tmp = feof(hmmfp->f);
  if (tmp) {
    return (0);
  }
  tmp___0 = fread((void *)((char *)(& magic)), sizeof(unsigned int ), (size_t )1,
                  hmmfp->f);
  if (! tmp___0) {
    return (0);
  }
  p9hmm = read_plan9_binhmm(hmmfp->f, 5, hmmfp->byteswap);
  if ((unsigned long )p9hmm == (unsigned long )((void *)0)) {
    *ret_hmm = (struct plan7_s *)((void *)0);
    return (1);
  }
  Plan9toPlan7(p9hmm, & hmm);
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
  Plan7SetCtime(hmm);
  P9FreeHMM(p9hmm);
  *ret_hmm = hmm;
  return (1);
}
}
static int read_asc11hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 


  {
  Die((char *)"1.1 ASCII HMMs unsupported");
  return (1);
}
}
static int read_bin11hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  unsigned int magic ;
  struct plan7_s *hmm ;
  struct plan9_s *p9hmm ;
  int tmp ;
  size_t tmp___0 ;

  {
  tmp = feof(hmmfp->f);
  if (tmp) {
    return (0);
  }
  tmp___0 = fread((void *)((char *)(& magic)), sizeof(unsigned int ), (size_t )1,
                  hmmfp->f);
  if (! tmp___0) {
    return (0);
  }
  p9hmm = read_plan9_binhmm(hmmfp->f, 3, hmmfp->byteswap);
  if ((unsigned long )p9hmm == (unsigned long )((void *)0)) {
    *ret_hmm = (struct plan7_s *)((void *)0);
    return (1);
  }
  Plan9toPlan7(p9hmm, & hmm);
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
  Plan7SetCtime(hmm);
  P9FreeHMM(p9hmm);
  *ret_hmm = hmm;
  return (1);
}
}
static int read_asc10hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 


  {
  Die((char *)"1.0 ASCII HMMs unsupported");
  return (1);
}
}
static int read_bin10hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  unsigned int magic ;
  struct plan7_s *hmm ;
  struct plan9_s *p9hmm ;
  int tmp ;
  size_t tmp___0 ;

  {
  tmp = feof(hmmfp->f);
  if (tmp) {
    return (0);
  }
  tmp___0 = fread((void *)((char *)(& magic)), sizeof(unsigned int ), (size_t )1,
                  hmmfp->f);
  if (! tmp___0) {
    return (0);
  }
  p9hmm = read_plan9_binhmm(hmmfp->f, 1, hmmfp->byteswap);
  if ((unsigned long )p9hmm == (unsigned long )((void *)0)) {
    *ret_hmm = (struct plan7_s *)((void *)0);
    return (1);
  }
  Plan9toPlan7(p9hmm, & hmm);
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
  Plan7SetCtime(hmm);
  P9FreeHMM(p9hmm);
  *ret_hmm = hmm;
  return (1);
}
}
static char buffer[8]  ;
static char *prob2ascii(float p , float null ) 
{ 
  int tmp ;
  unsigned long tmp___0 ;

  {
  if ((double )p == 0.0) {
    return ((char *)"*");
  }
  tmp = Prob2Score(p, null);
  tmp___0 = __builtin_object_size((void *)(buffer), 1);
  __builtin___sprintf_chk(buffer, 0, tmp___0, "%6d", tmp);
  return (buffer);
}
}
static float ascii2prob(char *s___0 , float null ) 
{ 
  int tmp ;
  float tmp___0 ;
  double tmp___1 ;

  {
  if ((int )*s___0 == 42) {
    tmp___1 = 0.;
  } else {
    tmp = atoi((char const   *)s___0);
    tmp___0 = Score2Prob(tmp, null);
    tmp___1 = (double )tmp___0;
  }
  return ((float )tmp___1);
}
}
static void byteswap(char *swap , int nbytes ) 
{ 
  int x ;
  char byte ;

  {
  x = 0;
  while (x < nbytes / 2) {
    byte = *(swap + ((nbytes - x) - 1));
    *(swap + ((nbytes - x) - 1)) = *(swap + x);
    *(swap + x) = byte;
    x ++;
  }
  return;
}
}
static void write_bin_string(FILE *fp , char *s___0 ) 
{ 
  int len ;
  size_t tmp ;

  {
  if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
    tmp = strlen((char const   *)s___0);
    len = (int )(tmp + 1UL);
    fwrite((void const   *)((char *)(& len)), sizeof(int ), (size_t )1, fp);
    fwrite((void const   *)s___0, sizeof(char ), (size_t )len, fp);
  } else {
    len = 0;
    fwrite((void const   *)((char *)(& len)), sizeof(int ), (size_t )1, fp);
  }
  return;
}
}
static int read_bin_string(FILE *fp , int doswap , char **ret_s ) 
{ 
  char *s___0 ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  tmp = fread((void *)((char *)(& len)), sizeof(int ), (size_t )1, fp);
  if (! tmp) {
    return (0);
  }
  if (doswap) {
    byteswap((char *)(& len), (int )sizeof(int ));
  }
  tmp___0 = sre_malloc((char *)"hmmio.c", 1370, sizeof(char ) * (unsigned long )len);
  s___0 = (char *)tmp___0;
  tmp___1 = fread((void *)s___0, sizeof(char ), (size_t )len, fp);
  if (! tmp___1) {
    free((void *)s___0);
    return (0);
  }
  *ret_s = s___0;
  return (1);
}
}
static void multiline(FILE *fp , char *pfx , char *s___0 ) 
{ 
  char *buf ;
  char *sptr___0 ;

  {
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return;
  }
  buf = Strdup(s___0);
  sptr___0 = strtok(buf, "\n");
  while ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
    fprintf(fp, "%s%s\n", pfx, sptr___0);
    sptr___0 = strtok((char *)((void *)0), "\n");
  }
  free((void *)buf);
  return;
}
}
static struct plan9_s *read_plan9_binhmm(FILE *fp , int version , int swapped ) 
{ 
  struct plan9_s *hmm ;
  int M ;
  int k ;
  int x ;
  int len ;
  int asize ;
  int atype ;
  char abet[20] ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
  tmp = fread((void *)((char *)(& M)), sizeof(int ), (size_t )1, fp);
  if (! tmp) {
    return ((struct plan9_s *)((void *)0));
  }
  tmp___0 = fread((void *)((char *)(& asize)), sizeof(int ), (size_t )1, fp);
  if (! tmp___0) {
    return ((struct plan9_s *)((void *)0));
  }
  if (swapped) {
    byteswap((char *)(& M), (int )sizeof(int ));
    byteswap((char *)(& asize), (int )sizeof(int ));
  }
  if (asize == 4) {
    atype = 2;
  } else
  if (asize == 20) {
    atype = 3;
  } else {
    Die((char *)"A nonbiological alphabet size of %d; so I can\'t convert plan9 to plan7",
        asize);
  }
  if (Alphabet_type == 0) {
    SetAlphabet(atype);
  } else
  if (atype != Alphabet_type) {
    tmp___1 = AlphabetType2String(atype);
    tmp___2 = AlphabetType2String(Alphabet_type);
    Die((char *)"Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n",
        tmp___2, tmp___1);
  }
  hmm = P9AllocHMM(M);
  if ((unsigned long )hmm == (unsigned long )((void *)0)) {
    Die((char *)"malloc failed for reading hmm in\n");
  }
  if (version == 7) {
    tmp___3 = fread((void *)((char *)(& len)), sizeof(int ), (size_t )1, fp);
    if (! tmp___3) {
      return ((struct plan9_s *)((void *)0));
    }
    if (swapped) {
      byteswap((char *)(& len), (int )sizeof(int ));
    }
    tmp___4 = sre_realloc((char *)"hmmio.c", 1475, (void *)hmm->name, sizeof(char ) * (unsigned long )(len + 1));
    hmm->name = (char *)tmp___4;
    tmp___5 = fread((void *)hmm->name, sizeof(char ), (size_t )len, fp);
    if (! tmp___5) {
      return ((struct plan9_s *)((void *)0));
    }
    *(hmm->name + len) = (char )'\000';
  }
  tmp___6 = fread((void *)((char *)(& atype)), sizeof(int ), (size_t )1, fp);
  if (! tmp___6) {
    return ((struct plan9_s *)((void *)0));
  }
  tmp___7 = fread((void *)(abet), sizeof(char ), (size_t )Alphabet_size, fp);
  if (! tmp___7) {
    return ((struct plan9_s *)((void *)0));
  }
  if (version == 1) {
    fseek(fp, (long )(sizeof(float ) * (unsigned long )Alphabet_size), 1);
  }
  if (version == 5) {
    goto _L;
  } else
  if (version == 7) {
    _L: /* CIL Label */ 
    tmp___8 = fread((void *)((char *)(& hmm->flags)), sizeof(int ), (size_t )1, fp);
    if (! tmp___8) {
      return ((struct plan9_s *)((void *)0));
    }
    if (swapped) {
      byteswap((char *)(& hmm->flags), (int )sizeof(int ));
    }
    if (hmm->flags & 1) {
      tmp___9 = fread((void *)hmm->ref, sizeof(char ), (size_t )(hmm->M + 1), fp);
      if (! tmp___9) {
        return ((struct plan9_s *)((void *)0));
      }
    }
    *(hmm->ref + (hmm->M + 1)) = (char )'\000';
    if (hmm->flags & (1 << 1)) {
      tmp___10 = fread((void *)hmm->cs, sizeof(char ), (size_t )(hmm->M + 1), fp);
      if (! tmp___10) {
        return ((struct plan9_s *)((void *)0));
      }
    }
    *(hmm->cs + (hmm->M + 1)) = (char )'\000';
  }
  if (version == 7) {
    tmp___11 = fread((void *)((char *)(hmm->null)), sizeof(float ), (size_t )Alphabet_size,
                     fp);
    if (! tmp___11) {
      return ((struct plan9_s *)((void *)0));
    }
    if (swapped) {
      x = 0;
      while (x < Alphabet_size) {
        byteswap((char *)(& hmm->null[x]), (int )sizeof(float ));
        x ++;
      }
    }
  } else {
    P9DefaultNullModel(hmm->null);
  }
  k = 0;
  while (k <= hmm->M) {
    tmp___12 = fread((void *)((char *)(& (hmm->mat + k)->t[0])), sizeof(float ), (size_t )1,
                     fp);
    if (! tmp___12) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___13 = fread((void *)((char *)(& (hmm->mat + k)->t[2])), sizeof(float ), (size_t )1,
                     fp);
    if (! tmp___13) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___14 = fread((void *)((char *)(& (hmm->mat + k)->t[1])), sizeof(float ), (size_t )1,
                     fp);
    if (! tmp___14) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___15 = fread((void *)((char *)((hmm->mat + k)->p)), sizeof(float ), (size_t )Alphabet_size,
                     fp);
    if (! tmp___15) {
      return ((struct plan9_s *)((void *)0));
    }
    if (swapped) {
      byteswap((char *)(& (hmm->mat + k)->t[0]), (int )sizeof(float ));
      byteswap((char *)(& (hmm->mat + k)->t[2]), (int )sizeof(float ));
      byteswap((char *)(& (hmm->mat + k)->t[1]), (int )sizeof(float ));
      x = 0;
      while (x < Alphabet_size) {
        byteswap((char *)(& (hmm->mat + k)->p[x]), (int )sizeof(float ));
        x ++;
      }
    }
    if (version == 1) {
      fseek(fp, (long )(sizeof(float ) * (unsigned long )(3 + Alphabet_size)), 1);
    }
    tmp___16 = fread((void *)((char *)(& (hmm->del + k)->t[0])), sizeof(float ), (size_t )1,
                     fp);
    if (! tmp___16) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___17 = fread((void *)((char *)(& (hmm->del + k)->t[2])), sizeof(float ), (size_t )1,
                     fp);
    if (! tmp___17) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___18 = fread((void *)((char *)(& (hmm->del + k)->t[1])), sizeof(float ), (size_t )1,
                     fp);
    if (! tmp___18) {
      return ((struct plan9_s *)((void *)0));
    }
    if (swapped) {
      byteswap((char *)(& (hmm->del + k)->t[0]), (int )sizeof(float ));
      byteswap((char *)(& (hmm->del + k)->t[2]), (int )sizeof(float ));
      byteswap((char *)(& (hmm->del + k)->t[1]), (int )sizeof(float ));
    }
    if (version == 1) {
      fseek(fp, (long )(sizeof(float ) * 3UL), 1);
    }
    tmp___19 = fread((void *)((char *)(& (hmm->ins + k)->t[0])), sizeof(float ), (size_t )1,
                     fp);
    if (! tmp___19) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___20 = fread((void *)((char *)(& (hmm->ins + k)->t[2])), sizeof(float ), (size_t )1,
                     fp);
    if (! tmp___20) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___21 = fread((void *)((char *)(& (hmm->ins + k)->t[1])), sizeof(float ), (size_t )1,
                     fp);
    if (! tmp___21) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___22 = fread((void *)((char *)((hmm->ins + k)->p)), sizeof(float ), (size_t )Alphabet_size,
                     fp);
    if (! tmp___22) {
      return ((struct plan9_s *)((void *)0));
    }
    if (swapped) {
      byteswap((char *)(& (hmm->ins + k)->t[0]), (int )sizeof(float ));
      byteswap((char *)(& (hmm->ins + k)->t[2]), (int )sizeof(float ));
      byteswap((char *)(& (hmm->ins + k)->t[1]), (int )sizeof(float ));
      x = 0;
      while (x < Alphabet_size) {
        byteswap((char *)(& (hmm->ins + k)->p[x]), (int )sizeof(float ));
        x ++;
      }
    }
    if (version == 1) {
      fseek(fp, (long )(sizeof(float ) * (unsigned long )(3 + Alphabet_size)), 1);
    }
    k ++;
  }
  P9Renormalize(hmm);
  return (hmm);
}
}
static struct plan9_s *read_plan9_aschmm(FILE *fp , int version ) 
{ 
  struct plan9_s *hmm ;
  int M ;
  char buffer___1[512] ;
  char *statetype ;
  char *s___0 ;
  int k ;
  int i___0 ;
  int asize ;
  int atype ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  double tmp___15 ;
  char *tmp___16 ;
  double tmp___17 ;
  char *tmp___18 ;
  double tmp___19 ;
  char *tmp___20 ;
  double tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  double tmp___24 ;
  char *tmp___25 ;
  double tmp___26 ;
  char *tmp___27 ;
  double tmp___28 ;
  char *tmp___29 ;
  double tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  double tmp___33 ;
  char *tmp___34 ;
  double tmp___35 ;
  char *tmp___36 ;
  double tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  char *tmp___42 ;

  {
  tmp = fgets(buffer___1, 512, fp);
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    return ((struct plan9_s *)((void *)0));
  }
  s___0 = strtok(buffer___1, " \t\n");
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return ((struct plan9_s *)((void *)0));
  }
  tmp___0 = isdigit((int )*s___0);
  if (! tmp___0) {
    return ((struct plan9_s *)((void *)0));
  }
  M = atoi((char const   *)s___0);
  tmp___1 = fgets(buffer___1, 512, fp);
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    return ((struct plan9_s *)((void *)0));
  }
  s___0 = strtok(buffer___1, " \t\n");
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return ((struct plan9_s *)((void *)0));
  }
  tmp___2 = isdigit((int )*s___0);
  if (! tmp___2) {
    return ((struct plan9_s *)((void *)0));
  }
  asize = atoi((char const   *)s___0);
  if (asize == 4) {
    atype = 2;
  } else
  if (asize == 20) {
    atype = 3;
  } else {
    Die((char *)"A nonbiological alphabet size of %d; so I can\'t convert plan9 to plan7",
        asize);
  }
  if (Alphabet_type == 0) {
    SetAlphabet(atype);
  } else
  if (atype != Alphabet_type) {
    tmp___3 = AlphabetType2String(atype);
    tmp___4 = AlphabetType2String(Alphabet_type);
    Die((char *)"Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n",
        tmp___4, tmp___3);
  }
  hmm = P9AllocHMM(M);
  if ((unsigned long )hmm == (unsigned long )((void *)0)) {
    Die((char *)"malloc failed for reading hmm in\n");
  }
  tmp___5 = fgets(buffer___1, 512, fp);
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    return ((struct plan9_s *)((void *)0));
  }
  s___0 = strtok(buffer___1, " \t\n");
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return ((struct plan9_s *)((void *)0));
  }
  tmp___6 = isdigit((int )*s___0);
  if (! tmp___6) {
    return ((struct plan9_s *)((void *)0));
  }
  tmp___7 = fgets(buffer___1, 512, fp);
  if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
    return ((struct plan9_s *)((void *)0));
  }
  s___0 = strtok(buffer___1, " \t\n");
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return ((struct plan9_s *)((void *)0));
  }
  if (version == 2) {
    i___0 = 0;
    while (i___0 < Alphabet_size) {
      tmp___8 = fgets(buffer___1, 512, fp);
      if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
        return ((struct plan9_s *)((void *)0));
      }
      i___0 ++;
    }
  }
  if (version == 6) {
    tmp___9 = fgets(buffer___1, 512, fp);
    if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___10 = strncmp((char const   *)(buffer___1), "yes", (size_t )3);
    if (tmp___10 == 0) {
      hmm->flags |= 1;
    }
    tmp___11 = fgets(buffer___1, 512, fp);
    if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___12 = strncmp((char const   *)(buffer___1), "yes", (size_t )3);
    if (tmp___12 == 0) {
      hmm->flags |= 1 << 1;
    }
  }
  while (1) {
    tmp___42 = fgets(buffer___1, 512, fp);
    if (! ((unsigned long )tmp___42 != (unsigned long )((void *)0))) {
      break;
    }
    statetype = strtok(buffer___1, " \t\n");
    if ((unsigned long )statetype == (unsigned long )((void *)0)) {
      return ((struct plan9_s *)((void *)0));
    }
    s___0 = strtok((char *)((void *)0), " \t\n");
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___13 = isdigit((int )*s___0);
    if (! tmp___13) {
      return ((struct plan9_s *)((void *)0));
    }
    k = atoi((char const   *)s___0);
    if (k < 0) {
      return ((struct plan9_s *)((void *)0));
    } else
    if (k > hmm->M + 1) {
      return ((struct plan9_s *)((void *)0));
    }
    tmp___41 = strcmp((char const   *)statetype, "###MATCH_STATE");
    if (tmp___41 == 0) {
      if (version == 6) {
        s___0 = strtok((char *)((void *)0), "\n");
        while (1) {
          if ((int )*s___0 != 40) {
            if (! ((int )*s___0 != 0)) {
              break;
            }
          } else {
            break;
          }
          s___0 ++;
        }
        if ((int )*s___0 != 40) {
          return ((struct plan9_s *)((void *)0));
        }
        *(hmm->ref + k) = *(s___0 + 1);
        while (1) {
          if ((int )*s___0 != 40) {
            if (! ((int )*s___0 != 0)) {
              break;
            }
          } else {
            break;
          }
          s___0 ++;
        }
        if ((int )*s___0 != 40) {
          return ((struct plan9_s *)((void *)0));
        }
        *(hmm->cs + k) = *(s___0 + 1);
      }
      tmp___14 = fgets(buffer___1, 512, fp);
      if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
        return ((struct plan9_s *)((void *)0));
      }
      s___0 = strtok(buffer___1, " \t\n");
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
        return ((struct plan9_s *)((void *)0));
      }
      tmp___15 = atof((char const   *)s___0);
      (hmm->mat + k)->t[0] = (float )tmp___15;
      tmp___16 = fgets(buffer___1, 512, fp);
      if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
        return ((struct plan9_s *)((void *)0));
      }
      s___0 = strtok(buffer___1, " \t\n");
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
        return ((struct plan9_s *)((void *)0));
      }
      tmp___17 = atof((char const   *)s___0);
      (hmm->mat + k)->t[2] = (float )tmp___17;
      tmp___18 = fgets(buffer___1, 512, fp);
      if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
        return ((struct plan9_s *)((void *)0));
      }
      s___0 = strtok(buffer___1, " \t\n");
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
        return ((struct plan9_s *)((void *)0));
      }
      tmp___19 = atof((char const   *)s___0);
      (hmm->mat + k)->t[1] = (float )tmp___19;
      i___0 = 0;
      while (i___0 < Alphabet_size) {
        tmp___20 = fgets(buffer___1, 512, fp);
        if ((unsigned long )tmp___20 == (unsigned long )((void *)0)) {
          return ((struct plan9_s *)((void *)0));
        }
        s___0 = strtok(buffer___1, " \t\n");
        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
          return ((struct plan9_s *)((void *)0));
        }
        tmp___21 = atof((char const   *)s___0);
        (hmm->mat + k)->p[i___0] = (float )tmp___21;
        i___0 ++;
      }
      if (version == 2) {
        i___0 = 0;
        while (i___0 < Alphabet_size + 3) {
          tmp___22 = fgets(buffer___1, 512, fp);
          if ((unsigned long )tmp___22 == (unsigned long )((void *)0)) {
            return ((struct plan9_s *)((void *)0));
          }
          i___0 ++;
        }
      }
    } else {
      tmp___40 = strcmp((char const   *)statetype, "###INSERT_STATE");
      if (tmp___40 == 0) {
        tmp___23 = fgets(buffer___1, 512, fp);
        if ((unsigned long )tmp___23 == (unsigned long )((void *)0)) {
          return ((struct plan9_s *)((void *)0));
        }
        s___0 = strtok(buffer___1, " \t\n");
        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
          return ((struct plan9_s *)((void *)0));
        }
        tmp___24 = atof((char const   *)s___0);
        (hmm->ins + k)->t[0] = (float )tmp___24;
        tmp___25 = fgets(buffer___1, 512, fp);
        if ((unsigned long )tmp___25 == (unsigned long )((void *)0)) {
          return ((struct plan9_s *)((void *)0));
        }
        s___0 = strtok(buffer___1, " \t\n");
        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
          return ((struct plan9_s *)((void *)0));
        }
        tmp___26 = atof((char const   *)s___0);
        (hmm->ins + k)->t[2] = (float )tmp___26;
        tmp___27 = fgets(buffer___1, 512, fp);
        if ((unsigned long )tmp___27 == (unsigned long )((void *)0)) {
          return ((struct plan9_s *)((void *)0));
        }
        s___0 = strtok(buffer___1, " \t\n");
        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
          return ((struct plan9_s *)((void *)0));
        }
        tmp___28 = atof((char const   *)s___0);
        (hmm->ins + k)->t[1] = (float )tmp___28;
        i___0 = 0;
        while (i___0 < Alphabet_size) {
          tmp___29 = fgets(buffer___1, 512, fp);
          if ((unsigned long )tmp___29 == (unsigned long )((void *)0)) {
            return ((struct plan9_s *)((void *)0));
          }
          s___0 = strtok(buffer___1, " \t\n");
          if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
            return ((struct plan9_s *)((void *)0));
          }
          tmp___30 = atof((char const   *)s___0);
          (hmm->ins + k)->p[i___0] = (float )tmp___30;
          i___0 ++;
        }
        if (version == 2) {
          i___0 = 0;
          while (i___0 < Alphabet_size + 3) {
            tmp___31 = fgets(buffer___1, 512, fp);
            if ((unsigned long )tmp___31 == (unsigned long )((void *)0)) {
              return ((struct plan9_s *)((void *)0));
            }
            i___0 ++;
          }
        }
      } else {
        tmp___39 = strcmp((char const   *)statetype, "###DELETE_STATE");
        if (tmp___39 == 0) {
          tmp___32 = fgets(buffer___1, 512, fp);
          if ((unsigned long )tmp___32 == (unsigned long )((void *)0)) {
            return ((struct plan9_s *)((void *)0));
          }
          s___0 = strtok(buffer___1, " \t\n");
          if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
            return ((struct plan9_s *)((void *)0));
          }
          tmp___33 = atof((char const   *)s___0);
          (hmm->del + k)->t[0] = (float )tmp___33;
          tmp___34 = fgets(buffer___1, 512, fp);
          if ((unsigned long )tmp___34 == (unsigned long )((void *)0)) {
            return ((struct plan9_s *)((void *)0));
          }
          s___0 = strtok(buffer___1, " \t\n");
          if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
            return ((struct plan9_s *)((void *)0));
          }
          tmp___35 = atof((char const   *)s___0);
          (hmm->del + k)->t[2] = (float )tmp___35;
          tmp___36 = fgets(buffer___1, 512, fp);
          if ((unsigned long )tmp___36 == (unsigned long )((void *)0)) {
            return ((struct plan9_s *)((void *)0));
          }
          s___0 = strtok(buffer___1, " \t\n");
          if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
            return ((struct plan9_s *)((void *)0));
          }
          tmp___37 = atof((char const   *)s___0);
          (hmm->del + k)->t[1] = (float )tmp___37;
          if (version == 2) {
            i___0 = 0;
            while (i___0 < 3) {
              tmp___38 = fgets(buffer___1, 512, fp);
              if ((unsigned long )tmp___38 == (unsigned long )((void *)0)) {
                return ((struct plan9_s *)((void *)0));
              }
              i___0 ++;
            }
          }
        } else {
          return ((struct plan9_s *)((void *)0));
        }
      }
    }
  }
  P9DefaultNullModel(hmm->null);
  P9Renormalize(hmm);
  return (hmm);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-2u6q2cLu.i","-O3")
extern FILE *__stdoutp ;
extern int puts(char const   * ) ;
extern int remove(char const   * ) ;
extern  __attribute__((__noreturn__)) void exit(int  ) ;
extern time_t time(time_t * ) ;
int FileExists(char *filename ) ;
int Getopt(int argc , char **argv , struct opt_s *opt , int nopts , char *usage___1 ,
           int *ret_optind , char **ret_optname , char **ret_optarg ) ;
void SqdClean(void) ;
void Panic(char *file , int line ) ;
char *RandomSequence(char *alphabet , float *p , int n , int len ) ;
void sre_srandom(int seed ) ;
double Gaussrandom(double mean , double stddev ) ;
void HMMERBanner(FILE *fp , char *banner___1 ) ;
void Plan7ComlogAppend(struct plan7_s *hmm , int argc , char **argv ) ;
void P7DefaultNullModel(float *null , float *ret_p1 ) ;
static char banner[48]  = 
  {      (char )'h',      (char )'m',      (char )'m',      (char )'c', 
        (char )'a',      (char )'l',      (char )'i',      (char )'b', 
        (char )'r',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'-',      (char )'-',      (char )' ', 
        (char )'c',      (char )'a',      (char )'l',      (char )'i', 
        (char )'b',      (char )'r',      (char )'a',      (char )'t', 
        (char )'e',      (char )' ',      (char )'H',      (char )'M', 
        (char )'M',      (char )' ',      (char )'s',      (char )'e', 
        (char )'a',      (char )'r',      (char )'c',      (char )'h', 
        (char )' ',      (char )'s',      (char )'t',      (char )'a', 
        (char )'t',      (char )'i',      (char )'s',      (char )'t', 
        (char )'i',      (char )'c',      (char )'s',      (char )'\000'};
static char usage[130]  = 
  {      (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'h', 
        (char )'m',      (char )'m',      (char )'c',      (char )'a', 
        (char )'l',      (char )'i',      (char )'b',      (char )'r', 
        (char )'a',      (char )'t',      (char )'e',      (char )' ', 
        (char )'[',      (char )'-',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )']',      (char )' ',      (char )'<', 
        (char )'h',      (char )'m',      (char )'m',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'>', 
        (char )'\n',      (char )'A',      (char )'v',      (char )'a', 
        (char )'i',      (char )'l',      (char )'a',      (char )'b', 
        (char )'l',      (char )'e',      (char )' ',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )' ',      (char )'a', 
        (char )'r',      (char )'e',      (char )':',      (char )'\n', 
        (char )' ',      (char )' ',      (char )'-',      (char )'h', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'p', 
        (char )'r',      (char )'i',      (char )'n',      (char )'t', 
        (char )' ',      (char )'s',      (char )'h',      (char )'o', 
        (char )'r',      (char )'t',      (char )' ',      (char )'u', 
        (char )'s',      (char )'a',      (char )'g',      (char )'e', 
        (char )' ',      (char )'a',      (char )'n',      (char )'d', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'i',      (char )'n',      (char )'f', 
        (char )'o',      (char )',',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )'n',      (char )' ', 
        (char )'e',      (char )'x',      (char )'i',      (char )'t', 
        (char )'\n',      (char )'\000'};
static char experts[456]  = 
  {      (char )' ',      (char )' ',      (char )'-',      (char )'-', 
        (char )'c',      (char )'p',      (char )'u',      (char )' ', 
        (char )'<',      (char )'n',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'r', 
        (char )'u',      (char )'n',      (char )' ',      (char )'<', 
        (char )'n',      (char )'>',      (char )' ',      (char )'t', 
        (char )'h',      (char )'r',      (char )'e',      (char )'a', 
        (char )'d',      (char )'s',      (char )' ',      (char )'i', 
        (char )'n',      (char )' ',      (char )'p',      (char )'a', 
        (char )'r',      (char )'a',      (char )'l',      (char )'l', 
        (char )'e',      (char )'l',      (char )' ',      (char )'(', 
        (char )'i',      (char )'f',      (char )' ',      (char )'t', 
        (char )'h',      (char )'r',      (char )'e',      (char )'a', 
        (char )'d',      (char )'e',      (char )'d',      (char )')', 
        (char )'\n',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'f',      (char )'i',      (char )'x', 
        (char )'e',      (char )'d',      (char )' ',      (char )'<', 
        (char )'n',      (char )'>',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'f',      (char )'i',      (char )'x',      (char )' ', 
        (char )'r',      (char )'a',      (char )'n',      (char )'d', 
        (char )'o',      (char )'m',      (char )' ',      (char )'s', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'n',      (char )'c',      (char )'e',      (char )' ', 
        (char )'l',      (char )'e',      (char )'n',      (char )'g', 
        (char )'t',      (char )'h',      (char )' ',      (char )'a', 
        (char )'t',      (char )' ',      (char )'<',      (char )'n', 
        (char )'>',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'h',      (char )'i', 
        (char )'s',      (char )'t',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'<', 
        (char )'f',      (char )'>',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'a',      (char )'v', 
        (char )'e',      (char )' ',      (char )'h',      (char )'i', 
        (char )'s',      (char )'t',      (char )'o',      (char )'g', 
        (char )'r',      (char )'a',      (char )'m',      (char )'(', 
        (char )'s',      (char )')',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'<', 
        (char )'f',      (char )'>',      (char )'\n',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'m', 
        (char )'e',      (char )'a',      (char )'n',      (char )' ', 
        (char )'<',      (char )'x',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )' ',      (char )'r',      (char )'a', 
        (char )'n',      (char )'d',      (char )'o',      (char )'m', 
        (char )' ',      (char )'s',      (char )'e',      (char )'q', 
        (char )' ',      (char )'l',      (char )'e',      (char )'n', 
        (char )'g',      (char )'t',      (char )'h',      (char )' ', 
        (char )'m',      (char )'e',      (char )'a',      (char )'n', 
        (char )' ',      (char )'a',      (char )'t',      (char )' ', 
        (char )'<',      (char )'x',      (char )'>',      (char )' ', 
        (char )'[',      (char )'3',      (char )'5',      (char )'0', 
        (char )']',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'n',      (char )'u', 
        (char )'m',      (char )' ',      (char )'<',      (char )'n', 
        (char )'>',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )' ',      (char )'n',      (char )'u',      (char )'m', 
        (char )'b',      (char )'e',      (char )'r',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'s', 
        (char )'a',      (char )'m',      (char )'p',      (char )'l', 
        (char )'e',      (char )'d',      (char )' ',      (char )'s', 
        (char )'e',      (char )'q',      (char )'s',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'<', 
        (char )'n',      (char )'>',      (char )' ',      (char )'[', 
        (char )'5',      (char )'0',      (char )'0',      (char )'0', 
        (char )']',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'p',      (char )'v', 
        (char )'m',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'r',      (char )'u',      (char )'n', 
        (char )' ',      (char )'o',      (char )'n',      (char )' ', 
        (char )'a',      (char )' ',      (char )'P',      (char )'a', 
        (char )'r',      (char )'a',      (char )'l',      (char )'l', 
        (char )'e',      (char )'l',      (char )' ',      (char )'V', 
        (char )'i',      (char )'r',      (char )'t',      (char )'u', 
        (char )'a',      (char )'l',      (char )' ',      (char )'M', 
        (char )'a',      (char )'c',      (char )'h',      (char )'i', 
        (char )'n',      (char )'e',      (char )' ',      (char )'(', 
        (char )'P',      (char )'V',      (char )'M',      (char )')', 
        (char )'\n',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'s',      (char )'d',      (char )' ', 
        (char )'<',      (char )'x',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'s',      (char )'e',      (char )'t',      (char )' ', 
        (char )'r',      (char )'a',      (char )'n',      (char )'d', 
        (char )'o',      (char )'m',      (char )' ',      (char )'s', 
        (char )'e',      (char )'q',      (char )' ',      (char )'l', 
        (char )'e',      (char )'n',      (char )'g',      (char )'t', 
        (char )'h',      (char )' ',      (char )'s',      (char )'t', 
        (char )'d',      (char )'.',      (char )' ',      (char )'d', 
        (char )'e',      (char )'v',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'<',      (char )'x', 
        (char )'>',      (char )' ',      (char )'[',      (char )'3', 
        (char )'5',      (char )'0',      (char )']',      (char )'\n', 
        (char )' ',      (char )' ',      (char )'-',      (char )'-', 
        (char )'s',      (char )'e',      (char )'e',      (char )'d', 
        (char )' ',      (char )'<',      (char )'n',      (char )'>', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'r', 
        (char )'a',      (char )'n',      (char )'d',      (char )'o', 
        (char )'m',      (char )' ',      (char )'s',      (char )'e', 
        (char )'e',      (char )'d',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'<',      (char )'n', 
        (char )'>',      (char )' ',      (char )'[',      (char )'t', 
        (char )'i',      (char )'m',      (char )'e',      (char )'(', 
        (char )')',      (char )']',      (char )'\n',      (char )'\000'};
static struct opt_s OPTIONS[9]  = 
  {      {(char *)"-h", 1, 0}, 
        {(char *)"--cpu", 0, 1}, 
        {(char *)"--fixed", 0, 1}, 
        {(char *)"--histfile", 0, 4}, 
        {(char *)"--mean", 0, 2}, 
        {(char *)"--num", 0, 1}, 
        {(char *)"--pvm", 0, 0}, 
        {(char *)"--sd", 0, 2}, 
        {(char *)"--seed", 0, 1}};
static void main_loop_serial(struct plan7_s *hmm , int seed , int nsample , float lenmean ,
                             float lensd , int fixedlen , struct histogram_s **ret_hist ,
                             float *ret_max ) ;
int hmmcalibrate(int argc , char **argv ) 
{ 
  char *hmmfile ;
  char *tmpfile___0 ;
  HMMFILE *hmmfp ;
  FILE *outfp ;
  char *mode ;
  struct plan7_s *hmm ;
  int idx ;
  int nhmm ;
  struct histogram_s *hist ;
  float max ;
  char *histfile ;
  FILE *hfp ;
  float *mu ;
  float *lambda ;
  int mu_lumpsize ;
  int nsample ;
  int seed ;
  int fixedlen ;
  float lenmean ;
  float lensd ;
  int do_pvm ;
  int pvm_lumpsize ;
  char *optname ;
  char *optarg___0 ;
  int optind___1 ;
  int num_threads ;
  time_t tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  unsigned long tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  nsample = 5000;
  fixedlen = 0;
  lenmean = (float )325.;
  lensd = (float )200.;
  tmp = time((time_t *)((void *)0));
  seed = (int )tmp;
  histfile = (char *)((void *)0);
  do_pvm = 0;
  pvm_lumpsize = 20;
  mu_lumpsize = 100;
  num_threads = 0;
  while (1) {
    tmp___11 = Getopt(argc, argv, OPTIONS, (int )(sizeof(OPTIONS) / sizeof(struct opt_s )),
                      usage, & optind___1, & optname, & optarg___0);
    if (! tmp___11) {
      break;
    }
    tmp___10 = strcmp((char const   *)optname, "--cpu");
    if (tmp___10 == 0) {
      num_threads = atoi((char const   *)optarg___0);
    } else {
      tmp___9 = strcmp((char const   *)optname, "--fixed");
      if (tmp___9 == 0) {
        fixedlen = atoi((char const   *)optarg___0);
      } else {
        tmp___8 = strcmp((char const   *)optname, "--histfile");
        if (tmp___8 == 0) {
          histfile = optarg___0;
        } else {
          tmp___7 = strcmp((char const   *)optname, "--mean");
          if (tmp___7 == 0) {
            tmp___0 = atof((char const   *)optarg___0);
            lenmean = (float )tmp___0;
          } else {
            tmp___6 = strcmp((char const   *)optname, "--num");
            if (tmp___6 == 0) {
              nsample = atoi((char const   *)optarg___0);
            } else {
              tmp___5 = strcmp((char const   *)optname, "--pvm");
              if (tmp___5 == 0) {
                do_pvm = 1;
              } else {
                tmp___4 = strcmp((char const   *)optname, "--sd");
                if (tmp___4 == 0) {
                  tmp___1 = atof((char const   *)optarg___0);
                  lensd = (float )tmp___1;
                } else {
                  tmp___3 = strcmp((char const   *)optname, "--seed");
                  if (tmp___3 == 0) {
                    seed = atoi((char const   *)optarg___0);
                  } else {
                    tmp___2 = strcmp((char const   *)optname, "-h");
                    if (tmp___2 == 0) {
                      HMMERBanner(__stdoutp, banner);
                      puts((char const   *)(usage));
                      puts((char const   *)(experts));
                      exit(0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc - optind___1 != 1) {
    Die((char *)"Incorrect number of arguments.\n%s\n", usage);
  }
  tmp___12 = optind___1;
  optind___1 ++;
  hmmfile = *(argv + tmp___12);
  if (do_pvm) {
    Die((char *)"PVM support is not compiled into HMMER; --pvm doesn\'t work.");
  }
  if (num_threads) {
    Die((char *)"Posix threads support is not compiled into HMMER; --cpu doesn\'t have any effect");
  }
  hmmfp = HMMFileOpen(hmmfile, (char *)((void *)0));
  if ((unsigned long )hmmfp == (unsigned long )((void *)0)) {
    Die((char *)"failed to open HMM file %s for reading.", hmmfile);
  }
  hfp = (FILE *)((void *)0);
  if ((unsigned long )histfile != (unsigned long )((void *)0)) {
    hfp = fopen((char const   *)histfile, "w");
    if ((unsigned long )hfp == (unsigned long )((void *)0)) {
      Die((char *)"Failed to open histogram save file %s for writing\n", histfile);
    }
  }
  tmp___13 = strlen((char const   *)hmmfile);
  tmp___14 = sre_malloc((char *)"hmmcalibrate.c", 265, tmp___13 + 5UL);
  tmpfile___0 = (char *)tmp___14;
  tmp___16 = __builtin_object_size((void *)tmpfile___0, 0);
  if (tmp___16 != 0xffffffffffffffffUL) {
    tmp___15 = __builtin_object_size((void *)tmpfile___0, 1);
    __builtin___strcpy_chk(tmpfile___0, (char const   *)hmmfile, tmp___15);
  } else {
    __inline_strcpy_chk(tmpfile___0, (char const   *)hmmfile);
  }
  tmp___18 = __builtin_object_size((void *)tmpfile___0, 0);
  if (tmp___18 != 0xffffffffffffffffUL) {
    tmp___17 = __builtin_object_size((void *)tmpfile___0, 1);
    __builtin___strcat_chk(tmpfile___0, ".new", tmp___17);
  } else {
    __inline_strcat_chk(tmpfile___0, ".new");
  }
  tmp___20 = FileExists(tmpfile___0);
  if (tmp___20) {
    tmp___19 = remove((char const   *)tmpfile___0);
    if (tmp___19 != 0) {
      Panic((char *)"hmmcalibrate.c", 270);
    }
  }
  if (hmmfp->is_binary) {
    mode = (char *)"wb";
  } else {
    mode = (char *)"w";
  }
  HMMERBanner(__stdoutp, banner);
  printf("HMM file:                 %s\n", hmmfile);
  if (fixedlen) {
    printf("Length fixed to:          %d\n", fixedlen);
  } else {
    printf("Length distribution mean: %.0f\n", (double )lenmean);
    printf("Length distribution s.d.: %.0f\n", (double )lensd);
  }
  printf("Number of samples:        %d\n", nsample);
  printf("random seed:              %d\n", seed);
  if ((unsigned long )histfile != (unsigned long )((void *)0)) {
    tmp___21 = (char const   *)histfile;
  } else {
    tmp___21 = "[not saved]";
  }
  printf("histogram(s) saved to:    %s\n", tmp___21);
  if (do_pvm) {
    printf("PVM:                      ACTIVE\n");
  } else
  if (num_threads > 0) {
    printf("POSIX threads:            %d\n", num_threads);
  }
  printf("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n");
  nhmm = 0;
  tmp___22 = sre_malloc((char *)"hmmcalibrate.c", 308, sizeof(float ) * (unsigned long )mu_lumpsize);
  mu = (float *)tmp___22;
  tmp___23 = sre_malloc((char *)"hmmcalibrate.c", 309, sizeof(float ) * (unsigned long )mu_lumpsize);
  lambda = (float *)tmp___23;
  while (1) {
    tmp___27 = HMMFileRead(hmmfp, & hmm);
    if (! tmp___27) {
      break;
    }
    if ((unsigned long )hmm == (unsigned long )((void *)0)) {
      Die((char *)"HMM file may be corrupt or in incorrect format; parse failed");
    }
    if (! do_pvm) {
      if (num_threads == 0) {
        main_loop_serial(hmm, seed, nsample, lenmean, lensd, fixedlen, & hist, & max);
      } else {
        Die((char *)"wait. that can\'t happen. I didn\'t do anything.");
      }
    } else {
      Die((char *)"wait. that can\'t happen. I didn\'t do anything.");
    }
    tmp___24 = ExtremeValueFitHistogram(hist, 1, (float )9999.);
    if (! tmp___24) {
      Die((char *)"fit failed; --num may be set too small?\n");
    }
    *(mu + nhmm) = hist->param[0];
    *(lambda + nhmm) = hist->param[1];
    nhmm ++;
    if (nhmm % 100 == 0) {
      tmp___25 = sre_realloc((char *)"hmmcalibrate.c", 348, (void *)mu, sizeof(float ) * (unsigned long )(nhmm + mu_lumpsize));
      mu = (float *)tmp___25;
      tmp___26 = sre_realloc((char *)"hmmcalibrate.c", 349, (void *)lambda, sizeof(float ) * (unsigned long )(nhmm + mu_lumpsize));
      lambda = (float *)tmp___26;
    }
    printf("HMM    : %s\n", hmm->name);
    printf("mu     : %12f\n", (double )hist->param[0]);
    printf("lambda : %12f\n", (double )hist->param[1]);
    printf("max    : %12f\n", (double )max);
    printf("//\n");
    if ((unsigned long )hfp != (unsigned long )((void *)0)) {
      fprintf(hfp, "HMM: %s\n", hmm->name);
      PrintASCIIHistogram(hfp, hist);
      fprintf(hfp, "//\n");
    }
    FreeHistogram(hist);
    FreePlan7(hmm);
  }
  HMMFileRewind(hmmfp);
  tmp___28 = FileExists(tmpfile___0);
  if (tmp___28) {
    Die((char *)"Ouch. Temporary file %s appeared during the run.", tmpfile___0);
  }
  outfp = fopen((char const   *)tmpfile___0, (char const   *)mode);
  if ((unsigned long )outfp == (unsigned long )((void *)0)) {
    Die((char *)"Ouch. Temporary file %s couldn\'t be opened for writing.", tmpfile___0);
  }
  idx = 0;
  while (idx < nhmm) {
    tmp___29 = HMMFileRead(hmmfp, & hmm);
    if (! tmp___29) {
      Die((char *)"Ran out of HMMs too early in pass 2");
    }
    if ((unsigned long )hmm == (unsigned long )((void *)0)) {
      Die((char *)"HMM file %s was corrupted? Parse failed in pass 2", hmmfile);
    }
    hmm->mu = *(mu + idx);
    hmm->lambda = *(lambda + idx);
    hmm->flags |= 1 << 7;
    Plan7ComlogAppend(hmm, argc, argv);
    if (hmmfp->is_binary) {
      WriteBinHMM(outfp, hmm);
    } else {
      WriteAscHMM(outfp, hmm);
    }
    FreePlan7(hmm);
    idx ++;
  }
  HMMFileClose(hmmfp);
  tmp___30 = fclose(outfp);
  if (tmp___30 != 0) {
    Panic((char *)"hmmcalibrate.c", 415);
  }
  free((void *)tmpfile___0);
  free((void *)mu);
  free((void *)lambda);
  if ((unsigned long )hfp != (unsigned long )((void *)0)) {
    fclose(hfp);
  }
  SqdClean();
  return (0);
}
}
static void main_loop_serial(struct plan7_s *hmm , int seed , int nsample , float lenmean ,
                             float lensd , int fixedlen , struct histogram_s **ret_hist ,
                             float *ret_max ) 
{ 
  struct histogram_s *hist ;
  struct dpmatrix_s *mx ;
  float randomseq[20] ;
  float p1 ;
  float max ;
  char *seq ;
  char *dsq ;
  float score ;
  int sqlen ;
  int idx ;
  double tmp ;
  int tmp___0 ;

  {
  sre_srandom(seed);
  P7Logoddsify(hmm, 1);
  P7DefaultNullModel(randomseq, & p1);
  hist = AllocHistogram(-200, 200, 100);
  mx = CreatePlan7Matrix(1, hmm->M, 25, 0);
  max = - 3.40282347e+38F;
  idx = 0;
  while (idx < nsample) {
    if (fixedlen) {
      sqlen = fixedlen;
    } else {
      while (1) {
        tmp = Gaussrandom((double )lenmean, (double )lensd);
        sqlen = (int )tmp;
        if (! (sqlen < 1)) {
          break;
        }
      }
    }
    seq = RandomSequence(Alphabet, randomseq, Alphabet_size, sqlen);
    dsq = DigitizeSequence(seq, sqlen);
    tmp___0 = P7ViterbiSize(sqlen, hmm->M);
    if (tmp___0 <= 1000) {
      score = P7Viterbi(dsq, sqlen, hmm, mx, (struct p7trace_s **)((void *)0));
    } else {
      score = P7SmallViterbi(dsq, sqlen, hmm, mx, (struct p7trace_s **)((void *)0));
    }
    AddToHistogram(hist, score);
    if (score > max) {
      max = score;
    }
    free((void *)dsq);
    free((void *)seq);
    idx ++;
  }
  FreePlan7Matrix(mx);
  *ret_hist = hist;
  *ret_max = max;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-ogpyP5Aw.i","-O3")
int Strparse(char *rexp , char *s___0 , int ntok ) ;
void FreeSequence(char *seq , SQINFO *sqinfo ) ;
SQFILE *SeqfileOpen(char *filename , int format , char *env ) ;
void SeqfileClose(SQFILE *sqfp ) ;
int ReadSeq(SQFILE *V , int format , char **ret_seq , SQINFO *sqinfo ) ;
int String2SeqfileFormat(char *s___0 ) ;
char Alphabet[25]  ;
int Alphabet_type  ;
int Alphabet_size  ;
int Alphabet_iupac  ;
char Degenerate[24][20]  ;
int DegenCount[24]  ;
int XNU(char *dsq , int len ) ;
int SetAutocuts(struct threshold_s *thresh___0 , struct plan7_s *hmm ) ;
struct tophit_s *AllocTophits(int lumpsize ) ;
void FreeTophits(struct tophit_s *h___0 ) ;
void GetRankedHit(struct tophit_s *h___0 , int rank , double *r_pvalue , float *r_score ,
                  double *r_motherp , float *r_mothersc , char **r_name , char **r_acc ,
                  char **r_desc , int *r_sqfrom , int *r_sqto , int *r_sqlen , int *r_hmmfrom ,
                  int *r_hmmto , int *r_hmmlen , int *r_domidx , int *r_ndom , struct fancyali_s **r_ali ) ;
int TophitsMaxName(struct tophit_s *h___0 ) ;
void FullSortTophits(struct tophit_s *h___0 ) ;
void PrintFancyAli(FILE *fp , struct fancyali_s *ali ) ;
static char banner___0[58]  = 
  {      (char )'h',      (char )'m',      (char )'m',      (char )'s', 
        (char )'e',      (char )'a',      (char )'r',      (char )'c', 
        (char )'h',      (char )' ',      (char )'-',      (char )' ', 
        (char )'s',      (char )'e',      (char )'a',      (char )'r', 
        (char )'c',      (char )'h',      (char )' ',      (char )'a', 
        (char )' ',      (char )'s',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'n',      (char )'c', 
        (char )'e',      (char )' ',      (char )'d',      (char )'a', 
        (char )'t',      (char )'a',      (char )'b',      (char )'a', 
        (char )'s',      (char )'e',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'a',      (char )' ',      (char )'p',      (char )'r', 
        (char )'o',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )' ',      (char )'H',      (char )'M', 
        (char )'M',      (char )'\000'};
static char usage___0[382]  = 
  {      (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'h', 
        (char )'m',      (char )'m',      (char )'s',      (char )'e', 
        (char )'a',      (char )'r',      (char )'c',      (char )'h', 
        (char )' ',      (char )'[',      (char )'-',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )']',      (char )' ', 
        (char )'<',      (char )'h',      (char )'m',      (char )'m', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'>',      (char )' ',      (char )'<',      (char )'s', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'n',      (char )'c',      (char )'e',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )' ',      (char )'o',      (char )'r',      (char )' ', 
        (char )'d',      (char )'a',      (char )'t',      (char )'a', 
        (char )'b',      (char )'a',      (char )'s',      (char )'e', 
        (char )'>',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'A',      (char )'v',      (char )'a',      (char )'i', 
        (char )'l',      (char )'a',      (char )'b',      (char )'l', 
        (char )'e',      (char )' ',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )' ',      (char )'a',      (char )'r', 
        (char )'e',      (char )':',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'h', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'h',      (char )'e', 
        (char )'l',      (char )'p',      (char )';',      (char )' ', 
        (char )'p',      (char )'r',      (char )'i',      (char )'n', 
        (char )'t',      (char )' ',      (char )'b',      (char )'r', 
        (char )'i',      (char )'e',      (char )'f',      (char )' ', 
        (char )'h',      (char )'e',      (char )'l',      (char )'p', 
        (char )' ',      (char )'o',      (char )'n',      (char )' ', 
        (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'u',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'A',      (char )' ', 
        (char )'<',      (char )'n',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )'s',      (char )' ',      (char )'a',      (char )'l', 
        (char )'i',      (char )'g',      (char )'n',      (char )'m', 
        (char )'e',      (char )'n',      (char )'t',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )'l', 
        (char )'i',      (char )'m',      (char )'i',      (char )'t', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'<',      (char )'n',      (char )'>',      (char )' ', 
        (char )'b',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'d',      (char )'o',      (char )'m', 
        (char )'a',      (char )'i',      (char )'n',      (char )' ', 
        (char )'a',      (char )'l',      (char )'i',      (char )'g', 
        (char )'n',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )'s',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'E', 
        (char )' ',      (char )'<',      (char )'x',      (char )'>', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )'s',      (char )' ',      (char )'E', 
        (char )' ',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )' ',      (char )'c', 
        (char )'u',      (char )'t',      (char )'o',      (char )'f', 
        (char )'f',      (char )' ',      (char )'(',      (char )'g', 
        (char )'l',      (char )'o',      (char )'b',      (char )'E', 
        (char )')',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'<',      (char )'=',      (char )' ', 
        (char )'x',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'T',      (char )' ', 
        (char )'<',      (char )'x',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )'s',      (char )' ',      (char )'T',      (char )' ', 
        (char )'b',      (char )'i',      (char )'t',      (char )' ', 
        (char )'t',      (char )'h',      (char )'r',      (char )'e', 
        (char )'s',      (char )'h',      (char )'o',      (char )'l', 
        (char )'d',      (char )' ',      (char )'(',      (char )'g', 
        (char )'l',      (char )'o',      (char )'b',      (char )'T', 
        (char )')',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'>',      (char )'=',      (char )' ', 
        (char )'x',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'Z',      (char )' ', 
        (char )'<',      (char )'n',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )'s',      (char )' ',      (char )'Z',      (char )' ', 
        (char )'(',      (char )'#',      (char )' ',      (char )'s', 
        (char )'e',      (char )'q',      (char )'s',      (char )')', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'E',      (char )'-',      (char )'v', 
        (char )'a',      (char )'l',      (char )'u',      (char )'e', 
        (char )' ',      (char )'c',      (char )'a',      (char )'l', 
        (char )'c',      (char )'u',      (char )'l',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\n',      (char )'\000'};
static char experts___0[759]  = 
  {      (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'c',      (char )'o',      (char )'m', 
        (char )'p',      (char )'a',      (char )'t',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )' ',      (char )'b',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'e',      (char )'f', 
        (char )'f',      (char )'o',      (char )'r',      (char )'t', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'u',      (char )'s',      (char )'e',      (char )' ', 
        (char )'l',      (char )'a',      (char )'s',      (char )'t', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\'',      (char )'s',      (char )' ',      (char )'o', 
        (char )'u',      (char )'t',      (char )'p',      (char )'u', 
        (char )'t',      (char )' ',      (char )'s',      (char )'t', 
        (char )'y',      (char )'l',      (char )'e',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'c',      (char )'p',      (char )'u', 
        (char )' ',      (char )'<',      (char )'n',      (char )'>', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'r',      (char )'u',      (char )'n',      (char )' ', 
        (char )'<',      (char )'n',      (char )'>',      (char )' ', 
        (char )'t',      (char )'h',      (char )'r',      (char )'e', 
        (char )'a',      (char )'d',      (char )'s',      (char )' ', 
        (char )'i',      (char )'n',      (char )' ',      (char )'p', 
        (char )'a',      (char )'r',      (char )'a',      (char )'l', 
        (char )'l',      (char )'e',      (char )'l',      (char )' ', 
        (char )'(',      (char )'i',      (char )'f',      (char )' ', 
        (char )'t',      (char )'h',      (char )'r',      (char )'e', 
        (char )'a',      (char )'d',      (char )'e',      (char )'d', 
        (char )')',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'c', 
        (char )'u',      (char )'t',      (char )'_',      (char )'g', 
        (char )'a',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )' ',      (char )'P',      (char )'f', 
        (char )'a',      (char )'m',      (char )' ',      (char )'G', 
        (char )'A',      (char )' ',      (char )'g',      (char )'a', 
        (char )'t',      (char )'h',      (char )'e',      (char )'r', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'t',      (char )'h',      (char )'r',      (char )'e', 
        (char )'s',      (char )'h',      (char )'o',      (char )'l', 
        (char )'d',      (char )' ',      (char )'c',      (char )'u', 
        (char )'t',      (char )'o',      (char )'f',      (char )'f', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'c', 
        (char )'u',      (char )'t',      (char )'_',      (char )'n', 
        (char )'c',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )' ',      (char )'P',      (char )'f', 
        (char )'a',      (char )'m',      (char )' ',      (char )'N', 
        (char )'C',      (char )' ',      (char )'n',      (char )'o', 
        (char )'i',      (char )'s',      (char )'e',      (char )' ', 
        (char )'t',      (char )'h',      (char )'r',      (char )'e', 
        (char )'s',      (char )'h',      (char )'o',      (char )'l', 
        (char )'d',      (char )' ',      (char )'c',      (char )'u', 
        (char )'t',      (char )'o',      (char )'f',      (char )'f', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'c', 
        (char )'u',      (char )'t',      (char )'_',      (char )'t', 
        (char )'c',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )' ',      (char )'P',      (char )'f', 
        (char )'a',      (char )'m',      (char )' ',      (char )'T', 
        (char )'C',      (char )' ',      (char )'t',      (char )'r', 
        (char )'u',      (char )'s',      (char )'t',      (char )'e', 
        (char )'d',      (char )' ',      (char )'t',      (char )'h', 
        (char )'r',      (char )'e',      (char )'s',      (char )'h', 
        (char )'o',      (char )'l',      (char )'d',      (char )' ', 
        (char )'c',      (char )'u',      (char )'t',      (char )'o', 
        (char )'f',      (char )'f',      (char )'s',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'d',      (char )'o',      (char )'m', 
        (char )'E',      (char )' ',      (char )'<',      (char )'x', 
        (char )'>',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'s',      (char )'e',      (char )'t',      (char )'s', 
        (char )' ',      (char )'d',      (char )'o',      (char )'m', 
        (char )'a',      (char )'i',      (char )'n',      (char )' ', 
        (char )'E',      (char )'v',      (char )'a',      (char )'l', 
        (char )' ',      (char )'c',      (char )'u',      (char )'t', 
        (char )'o',      (char )'f',      (char )'f',      (char )' ', 
        (char )'(',      (char )'2',      (char )'n',      (char )'d', 
        (char )' ',      (char )'t',      (char )'h',      (char )'r', 
        (char )'e',      (char )'s',      (char )'h',      (char )'o', 
        (char )'l',      (char )'d',      (char )')',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'<', 
        (char )'=',      (char )' ',      (char )'x',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'d',      (char )'o',      (char )'m', 
        (char )'T',      (char )' ',      (char )'<',      (char )'x', 
        (char )'>',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'s',      (char )'e',      (char )'t',      (char )'s', 
        (char )' ',      (char )'d',      (char )'o',      (char )'m', 
        (char )'a',      (char )'i',      (char )'n',      (char )' ', 
        (char )'T',      (char )' ',      (char )'b',      (char )'i', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'r',      (char )'e',      (char )'s',      (char )'h', 
        (char )' ',      (char )'(',      (char )'2',      (char )'n', 
        (char )'d',      (char )' ',      (char )'t',      (char )'h', 
        (char )'r',      (char )'e',      (char )'s',      (char )'h', 
        (char )'o',      (char )'l',      (char )'d',      (char )')', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'>',      (char )'=',      (char )' ',      (char )'x', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'f',      (char )'o', 
        (char )'r',      (char )'w',      (char )'a',      (char )'r', 
        (char )'d',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'u',      (char )'s',      (char )'e', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'f',      (char )'u',      (char )'l', 
        (char )'l',      (char )' ',      (char )'F',      (char )'o', 
        (char )'r',      (char )'w',      (char )'a',      (char )'r', 
        (char )'d',      (char )'(',      (char )')',      (char )' ', 
        (char )'a',      (char )'l',      (char )'g',      (char )'o', 
        (char )'r',      (char )'i',      (char )'t',      (char )'h', 
        (char )'m',      (char )' ',      (char )'i',      (char )'n', 
        (char )'s',      (char )'t',      (char )'e',      (char )'a', 
        (char )'d',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'V',      (char )'i',      (char )'t', 
        (char )'e',      (char )'r',      (char )'b',      (char )'i', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'i',      (char )'n', 
        (char )'f',      (char )'o',      (char )'r',      (char )'m', 
        (char )'a',      (char )'t',      (char )' ',      (char )'<', 
        (char )'s',      (char )'>',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'n',      (char )'c', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'i',      (char )'n', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )'m',      (char )'a',      (char )'t',      (char )' ', 
        (char )'<',      (char )'s',      (char )'>',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'n',      (char )'u',      (char )'l', 
        (char )'l',      (char )'2',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'t',      (char )'u',      (char )'r',      (char )'n', 
        (char )' ',      (char )'O',      (char )'F',      (char )'F', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'p',      (char )'o',      (char )'s', 
        (char )'t',      (char )' ',      (char )'h',      (char )'o', 
        (char )'c',      (char )' ',      (char )'s',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )' ',      (char )'n',      (char )'u',      (char )'l', 
        (char )'l',      (char )' ',      (char )'m',      (char )'o', 
        (char )'d',      (char )'e',      (char )'l',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'p',      (char )'v',      (char )'m', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'r',      (char )'u',      (char )'n',      (char )' ', 
        (char )'o',      (char )'n',      (char )' ',      (char )'a', 
        (char )' ',      (char )'P',      (char )'a',      (char )'r', 
        (char )'a',      (char )'l',      (char )'l',      (char )'e', 
        (char )'l',      (char )' ',      (char )'V',      (char )'i', 
        (char )'r',      (char )'t',      (char )'u',      (char )'a', 
        (char )'l',      (char )' ',      (char )'M',      (char )'a', 
        (char )'c',      (char )'h',      (char )'i',      (char )'n', 
        (char )'e',      (char )' ',      (char )'(',      (char )'P', 
        (char )'V',      (char )'M',      (char )')',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'x',      (char )'n',      (char )'u', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'t',      (char )'u',      (char )'r',      (char )'n', 
        (char )' ',      (char )'O',      (char )'N',      (char )' ', 
        (char )'X',      (char )'N',      (char )'U',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'t', 
        (char )'e',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'t',      (char )'a',      (char )'r', 
        (char )'g',      (char )'e',      (char )'t',      (char )' ', 
        (char )'p',      (char )'r',      (char )'o',      (char )'t', 
        (char )'e',      (char )'i',      (char )'n',      (char )' ', 
        (char )'s',      (char )'e',      (char )'q',      (char )'u', 
        (char )'e',      (char )'n',      (char )'c',      (char )'e', 
        (char )'s',      (char )'\n',      (char )'\000'};
static struct opt_s OPTIONS___0[17]  = 
  {      {(char *)"-h", 1, 0}, 
        {(char *)"-A", 1, 1}, 
        {(char *)"-E", 1, 2}, 
        {(char *)"-T", 1, 2}, 
        {(char *)"-Z", 1, 1}, 
        {(char *)"--compat", 0, 0}, 
        {(char *)"--cpu", 0, 1}, 
        {(char *)"--cut_ga", 0, 0}, 
        {(char *)"--cut_nc", 0, 0}, 
        {(char *)"--cut_tc", 0, 0}, 
        {(char *)"--domE", 0, 2}, 
        {(char *)"--domT", 0, 2}, 
        {(char *)"--forward", 0, 0}, 
        {(char *)"--informat", 0, 4}, 
        {(char *)"--null2", 0, 0}, 
        {(char *)"--pvm", 0, 0}, 
        {(char *)"--xnu", 0, 0}};
static void main_loop_serial___0(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                                 int do_forward , int do_null2 , int do_xnu , struct histogram_s *histogram ,
                                 struct tophit_s *ghit , struct tophit_s *dhit , int *ret_nseq ) ;
static void main_loop_pvm(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                          int do_forward , int do_null2 , int do_xnu , struct histogram_s *histogram ,
                          struct tophit_s *ghit , struct tophit_s *dhit , int *ret_nseq ) ;
static void main_loop_threaded(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                               int do_forward , int do_null2 , int do_xnu , int num_threads ,
                               struct histogram_s *histogram , struct tophit_s *ghit ,
                               struct tophit_s *dhit , int *ret_nseq ) ;
int main(int argc , char **argv ) 
{ 
  char *hmmfile ;
  HMMFILE *hmmfp ;
  char *seqfile ;
  SQFILE *sqfp ;
  int format ;
  int i___0 ;
  struct plan7_s *hmm ;
  struct histogram_s *histogram ;
  struct fancyali_s *ali ;
  struct tophit_s *ghit ;
  struct tophit_s *dhit ;
  float sc ;
  double pvalue ;
  double evalue ;
  double motherp ;
  float mothersc ;
  int sqfrom ;
  int sqto ;
  int hmmfrom ;
  int hmmto ;
  char *name ;
  int sqlen ;
  int nseq ;
  int Z ;
  int domidx ;
  int ndom ;
  int namewidth ;
  int descwidth ;
  int nreported ;
  int Alimit ;
  struct threshold_s thresh___0 ;
  char *optname ;
  char *optarg___0 ;
  int optind___1 ;
  int do_null2 ;
  int do_forward ;
  int do_xnu ;
  int do_pvm ;
  int be_backwards ;
  int num_threads ;
  int threads_support ;
  int pvm_support ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___34 ;
  int tmp___35 ;

  {
  if (argc != 3) {
    tmp = hmmcalibrate(argc, argv);
    return (tmp);
  }
  format = 0;
  do_forward = 0;
  do_null2 = 1;
  do_xnu = 0;
  do_pvm = 0;
  Z = 0;
  be_backwards = 0;
  pvm_support = 0;
  threads_support = 0;
  num_threads = 0;
  Alimit = 2147483647;
  thresh___0.globE = 10.0;
  thresh___0.globT = - 3.40282347e+38F;
  thresh___0.domT = - 3.40282347e+38F;
  thresh___0.domE = (double )3.40282347e+38F;
  thresh___0.autocut = (enum __anonenum_autocut_14 )0;
  thresh___0.Z = 0;
  while (1) {
    tmp___19 = Getopt(argc, argv, OPTIONS___0, (int )(sizeof(OPTIONS___0) / sizeof(struct opt_s )),
                      usage___0, & optind___1, & optname, & optarg___0);
    if (! tmp___19) {
      break;
    }
    tmp___18 = strcmp((char const   *)optname, "-A");
    if (tmp___18 == 0) {
      Alimit = atoi((char const   *)optarg___0);
    } else {
      tmp___17 = strcmp((char const   *)optname, "-E");
      if (tmp___17 == 0) {
        thresh___0.globE = atof((char const   *)optarg___0);
      } else {
        tmp___16 = strcmp((char const   *)optname, "-T");
        if (tmp___16 == 0) {
          tmp___0 = atof((char const   *)optarg___0);
          thresh___0.globT = (float )tmp___0;
        } else {
          tmp___15 = strcmp((char const   *)optname, "-Z");
          if (tmp___15 == 0) {
            thresh___0.Z = atoi((char const   *)optarg___0);
          } else {
            tmp___14 = strcmp((char const   *)optname, "--compat");
            if (tmp___14 == 0) {
              be_backwards = 1;
            } else {
              tmp___13 = strcmp((char const   *)optname, "--cpu");
              if (tmp___13 == 0) {
                num_threads = atoi((char const   *)optarg___0);
              } else {
                tmp___12 = strcmp((char const   *)optname, "--cut_ga");
                if (tmp___12 == 0) {
                  thresh___0.autocut = (enum __anonenum_autocut_14 )1;
                } else {
                  tmp___11 = strcmp((char const   *)optname, "--cut_nc");
                  if (tmp___11 == 0) {
                    thresh___0.autocut = (enum __anonenum_autocut_14 )2;
                  } else {
                    tmp___10 = strcmp((char const   *)optname, "--cut_tc");
                    if (tmp___10 == 0) {
                      thresh___0.autocut = (enum __anonenum_autocut_14 )3;
                    } else {
                      tmp___9 = strcmp((char const   *)optname, "--domE");
                      if (tmp___9 == 0) {
                        thresh___0.domE = atof((char const   *)optarg___0);
                      } else {
                        tmp___8 = strcmp((char const   *)optname, "--domT");
                        if (tmp___8 == 0) {
                          tmp___1 = atof((char const   *)optarg___0);
                          thresh___0.domT = (float )tmp___1;
                        } else {
                          tmp___7 = strcmp((char const   *)optname, "--forward");
                          if (tmp___7 == 0) {
                            do_forward = 1;
                          } else {
                            tmp___6 = strcmp((char const   *)optname, "--null2");
                            if (tmp___6 == 0) {
                              do_null2 = 0;
                            } else {
                              tmp___5 = strcmp((char const   *)optname, "--pvm");
                              if (tmp___5 == 0) {
                                do_pvm = 1;
                              } else {
                                tmp___4 = strcmp((char const   *)optname, "--xnu");
                                if (tmp___4 == 0) {
                                  do_xnu = 1;
                                } else {
                                  tmp___3 = strcmp((char const   *)optname, "--informat");
                                  if (tmp___3 == 0) {
                                    format = String2SeqfileFormat(optarg___0);
                                    if (format == 0) {
                                      Die((char *)"unrecognized sequence file format \"%s\"",
                                          optarg___0);
                                    }
                                  } else {
                                    tmp___2 = strcmp((char const   *)optname, "-h");
                                    if (tmp___2 == 0) {
                                      HMMERBanner(__stdoutp, banner___0);
                                      puts((char const   *)(usage___0));
                                      puts((char const   *)(experts___0));
                                      exit(0);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc - optind___1 != 2) {
    Die((char *)"Incorrect number of arguments.\n%s\n", usage___0);
  }
  tmp___20 = optind___1;
  optind___1 ++;
  hmmfile = *(argv + tmp___20);
  tmp___21 = optind___1;
  optind___1 ++;
  seqfile = *(argv + tmp___21);
  if (do_pvm) {
    if (! pvm_support) {
      Die((char *)"PVM support is not compiled into your HMMER software; --pvm doesn\'t work.");
    }
  }
  if (num_threads) {
    if (! threads_support) {
      Die((char *)"POSIX threads support is not compiled into HMMER; --cpu doesn\'t have any effect");
    }
  }
  if (format == 0) {
    tmp___22 = Strparse((char *)"^.*\\.gz$", seqfile, 0);
    if (tmp___22) {
      format = 7;
    } else {
      tmp___23 = strcmp((char const   *)seqfile, "-");
      if (tmp___23 == 0) {
        format = 7;
      }
    }
  }
  sqfp = SeqfileOpen(seqfile, format, (char *)"BLASTDB");
  if ((unsigned long )sqfp == (unsigned long )((void *)0)) {
    Die((char *)"Failed to open sequence database file %s\n%s\n", seqfile, usage___0);
  }
  hmmfp = HMMFileOpen(hmmfile, (char *)"HMMERDB");
  if ((unsigned long )hmmfp == (unsigned long )((void *)0)) {
    Die((char *)"Failed to open HMM file %s\n%s", hmmfile, usage___0);
  }
  tmp___24 = HMMFileRead(hmmfp, & hmm);
  if (! tmp___24) {
    Die((char *)"Failed to read any HMMs from %s\n", hmmfile);
  }
  if ((unsigned long )hmm == (unsigned long )((void *)0)) {
    Die((char *)"HMM file %s corrupt or in incorrect format? Parse failed", hmmfile);
  }
  P7Logoddsify(hmm, ! do_forward);
  if (do_xnu) {
    if (Alphabet_type == 2) {
      Die((char *)"The HMM is a DNA model, and you can\'t use the --xnu filter on DNA data");
    }
  }
  tmp___25 = SetAutocuts(& thresh___0, hmm);
  if (! tmp___25) {
    Die((char *)"HMM %s did not contain the GA, TC, or NC cutoffs you needed", hmm->name);
  }
  HMMERBanner(__stdoutp, banner___0);
  printf("HMM file:                   %s [%s]\n", hmmfile, hmm->name);
  printf("Sequence database:          %s\n", seqfile);
  if (do_pvm) {
    printf("PVM:                        ACTIVE\n");
  }
  printf("per-sequence score cutoff:  ");
  if (thresh___0.globT == - 3.40282347e+38F) {
    printf("[none]\n");
  } else {
    printf(">= %.1f", (double )thresh___0.globT);
    if ((unsigned int )thresh___0.autocut == 1U) {
      printf(" [GA1]\n");
    } else
    if ((unsigned int )thresh___0.autocut == 2U) {
      printf(" [NC1]\n");
    } else
    if ((unsigned int )thresh___0.autocut == 3U) {
      printf(" [TC1]\n");
    } else {
      printf("\n");
    }
  }
  printf("per-domain score cutoff:    ");
  if (thresh___0.domT == - 3.40282347e+38F) {
    printf("[none]\n");
  } else {
    printf(">= %.1f", (double )thresh___0.domT);
    if ((unsigned int )thresh___0.autocut == 1U) {
      printf(" [GA2]\n");
    } else
    if ((unsigned int )thresh___0.autocut == 2U) {
      printf(" [NC2]\n");
    } else
    if ((unsigned int )thresh___0.autocut == 3U) {
      printf(" [TC2]\n");
    } else {
      printf("\n");
    }
  }
  printf("per-sequence Eval cutoff:   ");
  if (thresh___0.globE == (double )3.40282347e+38F) {
    printf("[none]\n");
  } else {
    printf("<= %-10.2g\n", thresh___0.globE);
  }
  printf("per-domain Eval cutoff:     ");
  if (thresh___0.domE == (double )3.40282347e+38F) {
    printf("[none]\n");
  } else {
    printf("<= %10.2g\n", thresh___0.domE);
  }
  printf("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
  histogram = AllocHistogram(-200, 200, 100);
  ghit = AllocTophits(200);
  dhit = AllocTophits(200);
  if (pvm_support) {
    if (do_pvm) {
      main_loop_pvm(hmm, sqfp, & thresh___0, do_forward, do_null2, do_xnu, histogram,
                    ghit, dhit, & nseq);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (threads_support) {
    if (num_threads) {
      main_loop_threaded(hmm, sqfp, & thresh___0, do_forward, do_null2, do_xnu, num_threads,
                         histogram, ghit, dhit, & nseq);
    } else {
      main_loop_serial___0(hmm, sqfp, & thresh___0, do_forward, do_null2, do_xnu,
                           histogram, ghit, dhit, & nseq);
    }
  } else {
    main_loop_serial___0(hmm, sqfp, & thresh___0, do_forward, do_null2, do_xnu, histogram,
                         ghit, dhit, & nseq);
  }
  if (hmm->flags & (1 << 7)) {
    ExtremeValueSetHistogram(histogram, hmm->mu, hmm->lambda, (float )histogram->lowscore,
                             (float )histogram->highscore, 0);
  }
  if (! thresh___0.Z) {
    thresh___0.Z = nseq;
  }
  if (be_backwards) {
    if (hmm->flags & (1 << 1)) {
      tmp___26 = (char const   *)hmm->desc;
    } else {
      tmp___26 = "";
    }
    if (hmm->flags & (1 << 9)) {
      tmp___27 = (char const   *)hmm->acc;
    } else {
      tmp___27 = "";
    }
    printf("\nQuery HMM: %s|%s|%s\n", hmm->name, tmp___27, tmp___26);
  } else {
    printf("\nQuery HMM:   %s\n", hmm->name);
    if (hmm->flags & (1 << 9)) {
      tmp___28 = (char const   *)hmm->acc;
    } else {
      tmp___28 = "[none]";
    }
    printf("Accession:   %s\n", tmp___28);
    if (hmm->flags & (1 << 1)) {
      tmp___29 = (char const   *)hmm->desc;
    } else {
      tmp___29 = "[none]";
    }
    printf("Description: %s\n", tmp___29);
  }
  if (hmm->flags & (1 << 7)) {
    printf("  [HMM has been calibrated; E-values are empirical estimates]\n");
  } else {
    printf("  [No calibration for HMM; E-values are upper bounds]\n");
  }
  FullSortTophits(ghit);
  tmp___32 = TophitsMaxName(ghit);
  if (8 > tmp___32) {
    namewidth = 8;
  } else {
    tmp___31 = TophitsMaxName(ghit);
    namewidth = tmp___31;
  }
  if (52 - namewidth > 11) {
    descwidth = 52 - namewidth;
  } else {
    descwidth = 11;
  }
  FullSortTophits(dhit);
  tmp___35 = TophitsMaxName(dhit);
  if (8 > tmp___35) {
    namewidth = 8;
  } else {
    tmp___34 = TophitsMaxName(dhit);
    namewidth = tmp___34;
  }
  if (Alimit != 0) {
    printf("\nAlignments of top-scoring domains:\n");
    i___0 = 0;
    nreported = 0;
    while (i___0 < dhit->num) {
      if (nreported == Alimit) {
        break;
      }
      GetRankedHit(dhit, i___0, & pvalue, & sc, & motherp, & mothersc, & name, (char **)((void *)0),
                   (char **)((void *)0), & sqfrom, & sqto, & sqlen, & hmmfrom, & hmmto,
                   (int *)((void *)0), & domidx, & ndom, & ali);
      evalue = pvalue * (double )thresh___0.Z;
      if (! (motherp * (double )thresh___0.Z > thresh___0.globE)) {
        if (mothersc < thresh___0.globT) {
          goto __Cont;
        } else
        if (evalue <= thresh___0.domE) {
          if (sc >= thresh___0.domT) {
            printf("%s: domain %d of %d, from %d to %d: score %.1f, E = %.2g\n", name,
                   domidx, ndom, sqfrom, sqto, (double )sc, evalue);
            PrintFancyAli(__stdoutp, ali);
            nreported ++;
          }
        }
      }
      __Cont: /* CIL Label */ 
      i___0 ++;
    }
    if (nreported == 0) {
      printf("\t[no hits above thresholds]\n");
    }
    if (nreported == Alimit) {
      printf("\t[output cut off at A = %d top alignments]\n", Alimit);
    }
  }
  printf("\nTotal sequences searched: %d\n", nseq);
  FreeHistogram(histogram);
  HMMFileClose(hmmfp);
  SeqfileClose(sqfp);
  FreeTophits(ghit);
  FreeTophits(dhit);
  FreePlan7(hmm);
  SqdClean();
  return (0);
}
}
static void main_loop_serial___0(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                                 int do_forward , int do_null2 , int do_xnu , struct histogram_s *histogram ,
                                 struct tophit_s *ghit , struct tophit_s *dhit , int *ret_nseq ) 
{ 
  struct dpmatrix_s *mx ;
  struct p7trace_s *tr ;
  char *seq ;
  char *dsq ;
  SQINFO sqinfo ;
  float sc ;
  double pvalue ;
  double evalue ;
  int nseq ;
  int tmp ;
  float tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  mx = CreatePlan7Matrix(1, hmm->M, 25, 0);
  nseq = 0;
  while (1) {
    tmp___3 = ReadSeq(sqfp, sqfp->format, & seq, & sqinfo);
    if (! tmp___3) {
      break;
    }
    if (sqinfo.len == 0) {
      continue;
    }
    nseq ++;
    dsq = DigitizeSequence(seq, sqinfo.len);
    if (do_xnu) {
      if (Alphabet_type == 3) {
        XNU(dsq, sqinfo.len);
      }
    }
    tmp = P7ViterbiSize(sqinfo.len, hmm->M);
    if (tmp <= 1000) {
      sc = P7Viterbi(dsq, sqinfo.len, hmm, mx, & tr);
    } else {
      sc = P7SmallViterbi(dsq, sqinfo.len, hmm, mx, & tr);
    }
    if (do_forward) {
      sc = P7Forward(dsq, sqinfo.len, hmm, (struct dpmatrix_s **)((void *)0));
      if (do_null2) {
        tmp___0 = TraceScoreCorrection(hmm, tr, dsq);
        sc -= tmp___0;
      }
    }
    pvalue = PValue(hmm, sc);
    if (thresh___0->Z) {
      evalue = (double )thresh___0->Z * pvalue;
    } else {
      evalue = (double )nseq * pvalue;
    }
    if (sc >= thresh___0->globT) {
      if (evalue <= thresh___0->globE) {
        if (sqinfo.flags & (1 << 3)) {
          tmp___1 = sqinfo.desc;
        } else {
          tmp___1 = (char *)((void *)0);
        }
        if (sqinfo.flags & (1 << 2)) {
          tmp___2 = sqinfo.acc;
        } else {
          tmp___2 = (char *)((void *)0);
        }
        sc = PostprocessSignificantHit(ghit, dhit, tr, hmm, dsq, sqinfo.len, sqinfo.name,
                                       tmp___2, tmp___1, do_forward, sc, do_null2,
                                       thresh___0, 0);
      }
    }
    AddToHistogram(histogram, sc);
    FreeSequence(seq, & sqinfo);
    P7FreeTrace(tr);
    free((void *)dsq);
  }
  FreePlan7Matrix(mx);
  *ret_nseq = nseq;
  return;
}
}
static void main_loop_pvm(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                          int do_forward , int do_null2 , int do_xnu , struct histogram_s *histogram ,
                          struct tophit_s *ghit , struct tophit_s *dhit , int *ret_nseq ) 
{ 


  {
  Die((char *)"No PVM support");
  return;
}
}
static void main_loop_threaded(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                               int do_forward , int do_null2 , int do_xnu , int num_threads ,
                               struct histogram_s *histogram , struct tophit_s *ghit ,
                               struct tophit_s *dhit , int *ret_nseq ) 
{ 


  {
  Die((char *)"No threads support");
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-knSQaTau.i","-O3")
extern double pow(double  , double  ) ;
double Gammln(double x ) ;
void FNorm(float *vec , int n ) ;
float LogSum(float p1 , float p2 ) ;
void LogNorm(float *vec , int n ) ;
float Logp_cvec(float *cvec , int n , float *alpha ) ;
void SampleDirichlet(float *alpha , int n , float *p ) ;
float SampleGamma(float alpha ) ;
void SampleCountvector(float *p , int n , int c , float *cvec ) ;
float P_PvecGivenDirichlet(float *p , int n , float *alpha ) ;
int Prob2Score(float p , float null ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  if ((double )p == 0.0) {
    return (-987654321);
  } else {
    if (p / null > (float )0) {
      tmp = log((double )(p / null));
      tmp___0 = tmp * 1.44269504;
    } else {
      tmp___0 = - 9999.;
    }
    tmp___1 = floor(0.5 + 1000.0 * tmp___0);
    return ((int )tmp___1);
  }
}
}
float Score2Prob(int sc , float null ) 
{ 
  double tmp ;

  {
  if (sc == -987654321) {
    return ((float )0.);
  } else {
    tmp = exp(((double )((float )sc) / 1000.0) * 0.69314718);
    return ((float )((double )null * tmp));
  }
}
}
float Scorify(int sc ) 
{ 


  {
  return ((float )((double )((float )sc) / 1000.0));
}
}
double PValue(struct plan7_s *hmm , float sc ) 
{ 
  double pval ;
  double pval2 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  if (1.7976931348623157e+308 > (double )0) {
    tmp___2 = log(1.7976931348623157e+308);
    tmp___3 = tmp___2 * 1.44269504;
  } else {
    tmp___3 = - 9999.;
  }
  if ((double )sc >= tmp___3) {
    pval = 0.0;
  } else {
    if (1.7976931348623157e+308 > (double )0) {
      tmp___0 = log(1.7976931348623157e+308);
      tmp___1 = tmp___0 * 1.44269504;
    } else {
      tmp___1 = - 9999.;
    }
    if ((double )sc <= - 1. * tmp___1) {
      pval = 1.0;
    } else {
      tmp = exp((double )sc * 0.69314718);
      pval = 1. / (1. + tmp);
    }
  }
  if ((unsigned long )hmm != (unsigned long )((void *)0)) {
    if (hmm->flags & (1 << 7)) {
      pval2 = ExtremeValueP(sc, hmm->mu, hmm->lambda);
      if (pval2 < pval) {
        pval = pval2;
      }
    }
  }
  return (pval);
}
}
float LogSum(float p1 , float p2 ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  if (p1 > p2) {
    if ((double )(p1 - p2) > 50.) {
      tmp___1 = (double )p1;
    } else {
      tmp = exp((double )(p2 - p1));
      tmp___0 = log(1. + tmp);
      tmp___1 = (double )p1 + tmp___0;
    }
    return ((float )tmp___1);
  } else {
    if ((double )(p2 - p1) > 50.) {
      tmp___4 = (double )p2;
    } else {
      tmp___2 = exp((double )(p1 - p2));
      tmp___3 = log(1. + tmp___2);
      tmp___4 = (double )p2 + tmp___3;
    }
    return ((float )tmp___4);
  }
}
}
static int ilogsum_lookup[20000]  ;
static void init_ilogsum(void) 
{ 
  int i___0 ;
  double tmp ;
  double tmp___0 ;

  {
  i___0 = 0;
  while (i___0 < 20000) {
    tmp = exp((0.69314718 * (double )((float )(- i___0))) / 1000.0);
    tmp___0 = log(1. + tmp);
    ilogsum_lookup[i___0] = (int )((1000.0 * 1.44269504) * tmp___0);
    i___0 ++;
  }
  return;
}
}
static int firsttime  =    1;
int ILogsum(int p1 , int p2 ) 
{ 
  int diff ;

  {
  if (firsttime) {
    init_ilogsum();
    firsttime = 0;
  }
  diff = p1 - p2;
  if (diff >= 20000) {
    return (p1);
  } else
  if (diff <= -20000) {
    return (p2);
  } else
  if (diff > 0) {
    return (p1 + ilogsum_lookup[diff]);
  } else {
    return (p2 + ilogsum_lookup[- diff]);
  }
}
}
void LogNorm(float *vec , int n ) 
{ 
  int x ;
  float max ;
  float denom ;
  double tmp ;
  double tmp___0 ;

  {
  max = (float )(- 1.0e30);
  denom = (float )0.;
  x = 0;
  while (x < n) {
    if (*(vec + x) > max) {
      max = *(vec + x);
    }
    x ++;
  }
  x = 0;
  while (x < n) {
    if ((double )*(vec + x) > (double )max - 50.) {
      tmp = exp((double )(*(vec + x) - max));
      denom = (float )((double )denom + tmp);
    }
    x ++;
  }
  x = 0;
  while (x < n) {
    if ((double )*(vec + x) > (double )max - 50.) {
      tmp___0 = exp((double )(*(vec + x) - max));
      *(vec + x) = (float )(tmp___0 / (double )denom);
    } else {
      *(vec + x) = (float )0.0;
    }
    x ++;
  }
  return;
}
}
float Logp_cvec(float *cvec , int n , float *alpha ) 
{ 
  float lnp ;
  float sum1 ;
  float sum2 ;
  float sum3 ;
  int x ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  lnp = (float )0.0;
  sum3 = lnp;
  sum2 = sum3;
  sum1 = sum2;
  x = 0;
  while (x < n) {
    sum1 += *(cvec + x) + *(alpha + x);
    sum2 += *(alpha + x);
    sum3 += *(cvec + x);
    tmp = Gammln((double )(*(alpha + x) + *(cvec + x)));
    lnp = (float )((double )lnp + tmp);
    tmp___0 = Gammln((double )*(cvec + x) + 1.);
    lnp = (float )((double )lnp - tmp___0);
    tmp___1 = Gammln((double )*(alpha + x));
    lnp = (float )((double )lnp - tmp___1);
    x ++;
  }
  tmp___2 = Gammln((double )sum1);
  lnp = (float )((double )lnp - tmp___2);
  tmp___3 = Gammln((double )sum2);
  lnp = (float )((double )lnp + tmp___3);
  tmp___4 = Gammln((double )sum3 + 1.);
  lnp = (float )((double )lnp + tmp___4);
  return (lnp);
}
}
void SampleDirichlet(float *alpha , int n , float *p ) 
{ 
  int x ;

  {
  x = 0;
  while (x < n) {
    *(p + x) = SampleGamma(*(alpha + x));
    x ++;
  }
  FNorm(p, n);
  return;
}
}
float SampleGamma(float alpha ) 
{ 
  float U ;
  float V ;
  float X ;
  float W ;
  float lambda ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;

  {
  if ((double )alpha >= 1.0) {
    while (1) {
      tmp = sqrt(2.0 * (double )alpha - 1.0);
      lambda = (float )tmp;
      tmp___0 = sre_random();
      U = (float )tmp___0;
      V = U / ((float )1 - U);
      tmp___1 = pow((double )V, (double )((float )1 / lambda));
      X = (float )((double )alpha * tmp___1);
      tmp___2 = exp((double )(- X + alpha));
      tmp___3 = pow((double )V, 1.0 + (double )(alpha / lambda));
      tmp___4 = pow(1.0 + 1.0 / (double )V, 2.0);
      W = (float )(((.25 * tmp___2) * tmp___3) * tmp___4);
      tmp___5 = sre_random();
      if (tmp___5 <= (double )W) {
        return (X);
      }
    }
  } else
  if ((double )alpha > 0.0) {
    while (1) {
      tmp___6 = sre_random();
      U = (float )tmp___6;
      tmp___7 = exp(1.0);
      V = (float )((double )U * ((double )1 + (double )alpha / tmp___7));
      if ((double )V > 1.0) {
        tmp___8 = exp(1.0);
        tmp___9 = log(((double )((float )1 - V) + (double )alpha / tmp___8) / (double )alpha);
        X = (float )(- tmp___9);
        tmp___10 = sre_random();
        tmp___11 = pow((double )X, (double )alpha - 1.0);
        if (tmp___10 <= tmp___11) {
          return (X);
        }
      } else {
        tmp___12 = pow((double )V, 1.0 / (double )alpha);
        X = (float )tmp___12;
        tmp___13 = sre_random();
        tmp___14 = exp((double )(- X));
        if (tmp___13 <= tmp___14) {
          return (X);
        }
      }
    }
  }
  Die((char *)"Invalid argument alpha < 0.0 to SampleGamma()");
  return ((float )0.0);
}
}
void SampleCountvector(float *p , int n , int c , float *cvec ) 
{ 
  int i___0 ;
  int tmp ;

  {
  FSet(cvec, n, (float )0.0);
  i___0 = 0;
  while (i___0 < c) {
    tmp = FChoose(p, n);
    *(cvec + tmp) = (float )((double )*(cvec + tmp) + 1.0);
    i___0 ++;
  }
  return;
}
}
float P_PvecGivenDirichlet(float *p , int n , float *alpha ) 
{ 
  float sum ;
  float logp ;
  int x ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  logp = (float )0.0;
  sum = logp;
  x = 0;
  while (x < n) {
    if ((double )*(p + x) > 0.0) {
      tmp = log((double )*(p + x));
      logp = (float )((double )logp + ((double )*(alpha + x) - 1.0) * tmp);
      tmp___0 = Gammln((double )*(alpha + x));
      logp = (float )((double )logp - tmp___0);
      sum += *(alpha + x);
    }
    x ++;
  }
  tmp___1 = Gammln((double )sum);
  logp = (float )((double )logp + tmp___1);
  return (logp);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-HMPv7vYk.i","-O3")
void FAdd(float *vec1 , float *vec2 , int n ) ;
int DegenerateSymbolScore(float *p , float *null , int ambig ) ;
static int xpam120[23][23]  = 
  { {        3,        -3,        0,        0, 
            -4,        1,        -3,        -1, 
            -2,        -3,        -2,        -1, 
            1,        -1,        -3,        1, 
            1,        0,        -7,        -4, 
            1,        0,        0}, 
   {        -3,        9,        -7,        -7, 
            -6,        -4,        -4,        -3, 
            -7,        -7,        -6,        -5, 
            -4,        -7,        -4,        0, 
            -3,        -3,        -8,        -1, 
            -4,        -6,        0}, 
   {        0,        -7,        5,        3, 
            -7,        0,        0,        -3, 
            -1,        -5,        -4,        2, 
            -3,        1,        -3,        0, 
            -1,        -3,        -8,        -5, 
            5,        3,        0}, 
   {        0,        -7,        3,        5, 
            -7,        -1,        -1,        -3, 
            -1,        -4,        -3,        1, 
            -2,        2,        -3,        -1, 
            -2,        -3,        -8,        -5, 
            3,        5,        0}, 
   {        -4,        -6,        -7,        -7, 
            8,        -5,        -3,        0, 
            -7,        0,        -1,        -4, 
            -5,        -6,        -5,        -3, 
            -4,        -3,        -1,        4, 
            -4,        -5,        0}, 
   {        1,        -4,        0,        -1, 
            -5,        5,        -4,        -4, 
            -3,        -5,        -4,        0, 
            -2,        -3,        -4,        1, 
            -1,        -2,        -8,        -6, 
            1,        -1,        0}, 
   {        -3,        -4,        0,        -1, 
            -3,        -4,        7,        -4, 
            -2,        -3,        -4,        2, 
            -1,        3,        1,        -2, 
            -3,        -3,        -3,        -1, 
            2,        2,        0}, 
   {        -1,        -3,        -3,        -3, 
            0,        -4,        -4,        6, 
            -3,        1,        1,        -2, 
            -3,        -3,        -2,        -2, 
            0,        3,        -6,        -2, 
            -2,        -2,        0}, 
   {        -2,        -7,        -1,        -1, 
            -7,        -3,        -2,        -3, 
            5,        -4,        0,        1, 
            -2,        0,        2,        -1, 
            -1,        -4,        -5,        -5, 
            1,        0,        0}, 
   {        -3,        -7,        -5,        -4, 
            0,        -5,        -3,        1, 
            -4,        5,        3,        -4, 
            -3,        -2,        -4,        -4, 
            -3,        1,        -3,        -2, 
            -3,        -2,        0}, 
   {        -2,        -6,        -4,        -3, 
            -1,        -4,        -4,        1, 
            0,        3,        8,        -3, 
            -3,        -1,        -1,        -2, 
            -1,        1,        -6,        -4, 
            -3,        -1,        0}, 
   {        -1,        -5,        2,        1, 
            -4,        0,        2,        -2, 
            1,        -4,        -3,        4, 
            -2,        0,        -1,        1, 
            0,        -3,        -4,        -2, 
            4,        1,        0}, 
   {        1,        -4,        -3,        -2, 
            -5,        -2,        -1,        -3, 
            -2,        -3,        -3,        -2, 
            6,        0,        -1,        1, 
            -1,        -2,        -7,        -6, 
            -1,        0,        0}, 
   {        -1,        -7,        1,        2, 
            -6,        -3,        3,        -3, 
            0,        -2,        -1,        0, 
            0,        6,        1,        -2, 
            -2,        -3,        -6,        -5, 
            1,        5,        0}, 
   {        -3,        -4,        -3,        -3, 
            -5,        -4,        1,        -2, 
            2,        -4,        -1,        -1, 
            -1,        1,        6,        -1, 
            -2,        -3,        1,        -5, 
            -1,        0,        0}, 
   {        1,        0,        0,        -1, 
            -3,        1,        -2,        -2, 
            -1,        -4,        -2,        1, 
            1,        -2,        -1,        3, 
            2,        -2,        -2,        -3, 
            1,        0,        0}, 
   {        1,        -3,        -1,        -2, 
            -4,        -1,        -3,        0, 
            -1,        -3,        -1,        0, 
            -1,        -2,        -2,        2, 
            4,        0,        -6,        -3, 
            1,        -1,        0}, 
   {        0,        -3,        -3,        -3, 
            -3,        -2,        -3,        3, 
            -4,        1,        1,        -3, 
            -2,        -3,        -3,        -2, 
            0,        5,        -8,        -3, 
            -2,        -2,        0}, 
   {        -7,        -8,        -8,        -8, 
            -1,        -8,        -3,        -6, 
            -5,        -3,        -6,        -4, 
            -7,        -6,        1,        -2, 
            -6,        -8,        12,        -2, 
            -5,        -6,        0}, 
   {        -4,        -1,        -5,        -5, 
            4,        -6,        -1,        -2, 
            -5,        -2,        -4,        -2, 
            -6,        -5,        -5,        -3, 
            -3,        -3,        -2,        8, 
            -2,        -4,        0}, 
   {        1,        -4,        5,        3, 
            -4,        1,        2,        -2, 
            1,        -3,        -3,        4, 
            -1,        1,        -1,        1, 
            1,        -2,        -5,        -2, 
            6,        4,        0}, 
   {        0,        -6,        3,        5, 
            -5,        -1,        2,        -2, 
            0,        -2,        -1,        1, 
            0,        5,        0,        0, 
            -1,        -2,        -6,        -4, 
            4,        6,        0}, 
   {        0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0}};
int XNU(char *dsq , int len ) 
{ 
  int i___0 ;
  int k ;
  int off ;
  int sum ;
  int beg ;
  int end ;
  int top ;
  int topcut ;
  int fallcut ;
  double s0 ;
  int noff ;
  int mcut ;
  double pcut ;
  int *hit ;
  double lambda ;
  double K ;
  double H ;
  int xnum ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  noff = 4;
  mcut = 1;
  pcut = 0.01;
  lambda = 0.346574;
  K = 0.2;
  H = 0.664;
  xnum = 0;
  if (len == 0) {
    return (0);
  }
  tmp = sre_malloc((char *)"masks.c", 100, sizeof(int ) * (unsigned long )(len + 1));
  hit = (int *)tmp;
  i___0 = 1;
  while (i___0 <= len) {
    *(hit + i___0) = 0;
    i___0 ++;
  }
  tmp___0 = log((pcut * H) / ((double )noff * K));
  s0 = - tmp___0 / lambda;
  if (s0 > (double )0) {
    tmp___1 = log(s0);
    tmp___2 = floor((s0 + tmp___1 / lambda) + 0.5);
    topcut = (int )tmp___2;
  } else {
    topcut = 0;
  }
  tmp___3 = log(K / 0.001);
  fallcut = (int )((double )((int )tmp___3) / lambda);
  off = mcut;
  while (off <= noff) {
    top = 0;
    sum = top;
    beg = off;
    end = 0;
    i___0 = off + 1;
    while (i___0 <= len) {
      sum += xpam120[(int )*(dsq + i___0)][(int )*(dsq + (i___0 - off))];
      if (sum > top) {
        top = sum;
        end = i___0;
      }
      if (top >= topcut) {
        if (top - sum > fallcut) {
          k = beg;
          while (k <= end) {
            tmp___4 = 1;
            *(hit + (k - off)) = tmp___4;
            *(hit + k) = tmp___4;
            k ++;
          }
          top = 0;
          sum = top;
          end = i___0 + 1;
          beg = end;
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (top - sum > fallcut) {
        top = 0;
        sum = top;
        end = i___0 + 1;
        beg = end;
      }
      if (sum < 0) {
        end = i___0 + 1;
        beg = end;
        top = 0;
        sum = top;
      }
      i___0 ++;
    }
    if (top >= topcut) {
      k = beg;
      while (k <= end) {
        tmp___5 = 1;
        *(hit + (k - off)) = tmp___5;
        *(hit + k) = tmp___5;
        k ++;
      }
    }
    off ++;
  }
  i___0 = 1;
  while (i___0 <= len) {
    if (*(hit + i___0)) {
      xnum ++;
      *(dsq + i___0) = (char )(Alphabet_iupac - 1);
    }
    i___0 ++;
  }
  free((void *)hit);
  return (xnum);
}
}
float TraceScoreCorrection(struct plan7_s *hmm , struct p7trace_s *tr , char *dsq ) 
{ 
  float p[20] ;
  int sc[24] ;
  int x ;
  int tpos ;
  int score ;
  int tmp ;
  float tmp___0 ;

  {
  if ((unsigned long )tr == (unsigned long )((void *)0)) {
    return ((float )0.0);
  }
  FSet(p, Alphabet_size, (float )0.0);
  tpos = 0;
  while (tpos < tr->tlen) {
    if ((int )*(tr->statetype + tpos) == 1) {
      FAdd(p, *(hmm->mat + *(tr->nodeidx + tpos)), Alphabet_size);
    } else
    if ((int )*(tr->statetype + tpos) == 3) {
      FAdd(p, *(hmm->ins + *(tr->nodeidx + tpos)), Alphabet_size);
    }
    tpos ++;
  }
  FNorm(p, Alphabet_size);
  x = 0;
  while (x < Alphabet_size) {
    sc[x] = Prob2Score(p[x], hmm->null[x]);
    x ++;
  }
  x = Alphabet_size;
  while (x < Alphabet_iupac) {
    sc[x] = DegenerateSymbolScore(p, hmm->null, x);
    x ++;
  }
  score = 0;
  tpos = 0;
  while (tpos < tr->tlen) {
    if ((int )*(tr->statetype + tpos) == 1) {
      score += sc[(int )*(dsq + *(tr->pos + tpos))];
    } else
    if ((int )*(tr->statetype + tpos) == 3) {
      score += sc[(int )*(dsq + *(tr->pos + tpos))];
    }
    tpos ++;
  }
  score = (int )((double )score - (double )8 * 1000.0);
  tmp = ILogsum(0, score);
  tmp___0 = Scorify(tmp);
  return (tmp___0);
}
}
float SantaCruzCorrection(struct plan7_s *hmm , struct p7trace_s *tr , char *dsq ) 
{ 


  {
  return ((float )0.0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-L3c85lFp.i","-O3")
__inline static int isascii(int _c ) 
{ 


  {
  return ((_c & -128) == 0);
}
}
extern int __maskrune(__darwin_ct_rune_t  , unsigned long  ) ;
__inline static int __istype(__darwin_ct_rune_t _c , unsigned long _f ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___3 = isascii(_c);
  if (tmp___3) {
    tmp___2 = ! (! ((unsigned long )_DefaultRuneLocale.__runetype[_c] & _f));
  } else {
    tmp___0 = __maskrune(_c, _f);
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    tmp___2 = tmp___1;
  }
  return (tmp___2);
}
}
__inline static int isspace(int _c ) 
{ 
  int tmp ;

  {
  tmp = __istype(_c, 16384UL);
  return (tmp);
}
}
int IsInt(char *s___0 ) ;
int IsReal(char *s___0 ) ;
void HMMERBanner(FILE *fp , char *banner___1 ) 
{ 


  {
  fprintf(fp, "%s\n", banner___1);
  fprintf(fp, "%s %s (%s)\n", "HMMER", "2.3", "May 2003");
  fprintf(fp, "%s\n", "Copyright (C) 1992-2003 HHMI/Washington University School of Medicine");
  fprintf(fp, "%s\n", "Freely distributed under the GNU General Public License (GPL)");
  fprintf(fp, "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
  return;
}
}
static char buffer___0[512]  ;
static char *sptr  =    (char *)((void *)0);
char *Getword(FILE *fp , int type ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )sptr != (unsigned long )((void *)0)) {
    sptr = strtok((char *)((void *)0), " \t\n");
  }
  while ((unsigned long )sptr == (unsigned long )((void *)0)) {
    sptr = fgets(buffer___0, 512, fp);
    if ((unsigned long )sptr == (unsigned long )((void *)0)) {
      return ((char *)((void *)0));
    }
    sptr = strchr((char const   *)(buffer___0), '#');
    if ((unsigned long )sptr != (unsigned long )((void *)0)) {
      *sptr = (char )'\000';
    }
    sptr = strtok(buffer___0, " \t\n");
  }
  switch (type) {
  case 4: 
  tmp = strlen((char const   *)sptr);
  if (tmp == 0UL) {
    Warn((char *)"Parse failed: expected string, got nothing");
    sptr = (char *)((void *)0);
  }
  break;
  case 1: 
  tmp___0 = IsInt(sptr);
  if (! tmp___0) {
    Warn((char *)"Parse failed: expected integer, got %s", sptr);
    sptr = (char *)((void *)0);
  }
  break;
  case 2: 
  tmp___1 = IsReal(sptr);
  if (! tmp___1) {
    Warn((char *)"Parse failed: expected real value, got %s", sptr);
    sptr = (char *)((void *)0);
  }
  break;
  }
  return (sptr);
}
}
char *Getline(char *s___0 , int n , FILE *fp ) 
{ 
  char *first ;
  char *tmp ;
  int tmp___0 ;

  {
  while (1) {
    tmp = fgets(s___0, n, fp);
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      return ((char *)((void *)0));
    }
    first = s___0;
    while (1) {
      tmp___0 = isspace((int )*first);
      if (! tmp___0) {
        break;
      }
      first ++;
    }
    if (! ((int )*first == 35)) {
      if (! ((int )*first == 0)) {
        break;
      }
    }
  }
  return (s___0);
}
}
int SetAutocuts(struct threshold_s *thresh___0 , struct plan7_s *hmm ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  if ((unsigned int )thresh___0->autocut == 1U) {
    if (! (hmm->flags & (1 << 10))) {
      return (0);
    }
    thresh___0->globT = hmm->ga1;
    thresh___0->domT = hmm->ga2;
    tmp = (double )3.40282347e+38F;
    thresh___0->domE = tmp;
    thresh___0->globE = tmp;
  } else
  if ((unsigned int )thresh___0->autocut == 2U) {
    if (! (hmm->flags & (1 << 12))) {
      return (0);
    }
    thresh___0->globT = hmm->nc1;
    thresh___0->domT = hmm->nc2;
    tmp___0 = (double )3.40282347e+38F;
    thresh___0->domE = tmp___0;
    thresh___0->globE = tmp___0;
  } else
  if ((unsigned int )thresh___0->autocut == 3U) {
    if (! (hmm->flags & (1 << 11))) {
      return (0);
    }
    thresh___0->globT = hmm->tc1;
    thresh___0->domT = hmm->tc2;
    tmp___1 = (double )3.40282347e+38F;
    thresh___0->domE = tmp___1;
    thresh___0->globE = tmp___1;
  }
  return (1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-y2Zy4_BA.i","-O3")
__inline static int islower(int _c ) 
{ 
  int tmp ;

  {
  tmp = __istype(_c, 4096UL);
  return (tmp);
}
}
__inline static int isupper(int _c ) 
{ 
  int tmp ;

  {
  tmp = __istype(_c, 32768UL);
  return (tmp);
}
}
char *MSAGetGC(MSA *msa , char *tag ) ;
int DealignedLength(char *aseq ) ;
float FDot(float *vec1 , float *vec2 , int n ) ;
void P7Handmodelmaker(MSA *msa , char **dsq , struct plan7_s **ret_hmm , struct p7trace_s ***ret_tr ) ;
void P7Fastmodelmaker(MSA *msa , char **dsq , float maxgap , struct plan7_s **ret_hmm ,
                      struct p7trace_s ***ret_tr ) ;
void P7Maxmodelmaker(MSA *msa , char **dsq , float maxgap , struct p7prior_s *prior ,
                     float *null , float null_p1 , float mpri , struct plan7_s **ret_hmm ,
                     struct p7trace_s ***ret_tr ) ;
struct plan7_s *AllocPlan7(int M ) ;
void P7PriorifyTransitionVector(float *t___0 , struct p7prior_s *prior , float *tq ) ;
void P7PriorifyEmissionVector(float *vec , struct p7prior_s *pri , int num , float *eq ,
                              float (*e)[20] , float *ret_mix ) ;
void P7TraceCount(struct plan7_s *hmm , char *dsq , float wt , struct p7trace_s *tr ) ;
static int build_cij(char **aseqs , int nseq , int *insopt , int i___0 , int j , float *wgt ,
                     float *cij ) ;
static int estimate_model_length(MSA *msa ) ;
static void matassign2hmm(MSA *msa , char **dsq , int *matassign , struct plan7_s **ret_hmm ,
                          struct p7trace_s ***ret_tr ) ;
static void fake_tracebacks(char **aseq , int nseq , int alen , int *matassign , struct p7trace_s ***ret_tr ) ;
static void trace_doctor(struct p7trace_s *tr , int mlen , int *ret_ndi , int *ret_nid ) ;
static void annotate_model(struct plan7_s *hmm , int *matassign , MSA *msa ) ;
void P7Handmodelmaker(MSA *msa , char **dsq , struct plan7_s **ret_hmm , struct p7trace_s ***ret_tr ) 
{ 
  int *matassign ;
  int apos ;
  void *tmp ;

  {
  if ((unsigned long )msa->rf == (unsigned long )((void *)0)) {
    Die((char *)"Alignment must have RF annotation to hand-build an HMM");
  }
  tmp = sre_malloc((char *)"modelmakers.c", 111, sizeof(int ) * (unsigned long )(msa->alen + 1));
  matassign = (int *)tmp;
  *(matassign + 0) = 0;
  apos = 0;
  while (apos < msa->alen) {
    *(matassign + (apos + 1)) = 0;
    if ((int )*(msa->rf + apos) == 32) {
      *(matassign + (apos + 1)) |= 1 << 3;
    } else
    if ((int )*(msa->rf + apos) == 46) {
      *(matassign + (apos + 1)) |= 1 << 3;
    } else
    if ((int )*(msa->rf + apos) == 95) {
      *(matassign + (apos + 1)) |= 1 << 3;
    } else
    if ((int )*(msa->rf + apos) == 45) {
      *(matassign + (apos + 1)) |= 1 << 3;
    } else
    if ((int )*(msa->rf + apos) == 126) {
      *(matassign + (apos + 1)) |= 1 << 3;
    } else {
      *(matassign + (apos + 1)) |= 1;
    }
    apos ++;
  }
  matassign2hmm(msa, dsq, matassign, ret_hmm, ret_tr);
  free((void *)matassign);
  return;
}
}
void P7Fastmodelmaker(MSA *msa , char **dsq , float maxgap , struct plan7_s **ret_hmm ,
                      struct p7trace_s ***ret_tr ) 
{ 
  int *matassign ;
  int idx ;
  int apos ;
  int ngap ;
  void *tmp ;

  {
  tmp = sre_malloc((char *)"modelmakers.c", 172, sizeof(int ) * (unsigned long )(msa->alen + 1));
  matassign = (int *)tmp;
  *(matassign + 0) = 0;
  apos = 0;
  while (apos < msa->alen) {
    *(matassign + (apos + 1)) = 0;
    ngap = 0;
    idx = 0;
    while (idx < msa->nseq) {
      if ((int )*(*(msa->aseq + idx) + apos) == 32) {
        ngap ++;
      } else
      if ((int )*(*(msa->aseq + idx) + apos) == 46) {
        ngap ++;
      } else
      if ((int )*(*(msa->aseq + idx) + apos) == 95) {
        ngap ++;
      } else
      if ((int )*(*(msa->aseq + idx) + apos) == 45) {
        ngap ++;
      } else
      if ((int )*(*(msa->aseq + idx) + apos) == 126) {
        ngap ++;
      }
      idx ++;
    }
    if ((float )ngap / (float )msa->nseq > maxgap) {
      *(matassign + (apos + 1)) |= 1 << 3;
    } else {
      *(matassign + (apos + 1)) |= 1;
    }
    apos ++;
  }
  matassign2hmm(msa, dsq, matassign, ret_hmm, ret_tr);
  free((void *)matassign);
  return;
}
}
void P7Maxmodelmaker(MSA *msa , char **dsq , float maxgap , struct p7prior_s *prior ,
                     float *null , float null_p1 , float mpri , struct plan7_s **ret_hmm ,
                     struct p7trace_s ***ret_tr ) 
{ 
  int idx ;
  int i___0 ;
  int j ;
  int x ;
  float **matc ;
  float cij[8] ;
  float tij[8] ;
  float matp[20] ;
  float insp[20] ;
  float insc[20] ;
  float *sc ;
  int *tbck ;
  int *matassign ;
  int *insopt ;
  int first ;
  int last ;
  float bm1 ;
  float bm2 ;
  int est_M ;
  float t_me ;
  float new ;
  float bestsc ;
  int code ;
  int ngap ;
  float wgtsum ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  float tmp___18 ;
  float tmp___19 ;
  float tmp___20 ;

  {
  tmp = sre_malloc((char *)"modelmakers.c", 255, sizeof(float *) * (unsigned long )(msa->alen + 1));
  matc = (float **)tmp;
  tmp___0 = sre_malloc((char *)"modelmakers.c", 256, sizeof(float ) * (unsigned long )(msa->alen + 2));
  sc = (float *)tmp___0;
  tmp___1 = sre_malloc((char *)"modelmakers.c", 257, sizeof(int ) * (unsigned long )(msa->alen + 2));
  tbck = (int *)tmp___1;
  tmp___2 = sre_malloc((char *)"modelmakers.c", 258, sizeof(int ) * (unsigned long )(msa->alen + 1));
  matassign = (int *)tmp___2;
  tmp___3 = sre_malloc((char *)"modelmakers.c", 259, sizeof(int ) * (unsigned long )msa->nseq);
  insopt = (int *)tmp___3;
  i___0 = 0;
  while (i___0 < msa->alen) {
    tmp___4 = sre_malloc((char *)"modelmakers.c", 261, (unsigned long )Alphabet_size * sizeof(float ));
    *(matc + (i___0 + 1)) = (float *)tmp___4;
    FSet(*(matc + (i___0 + 1)), Alphabet_size, (float )0.);
    i___0 ++;
  }
  i___0 = 0;
  while (i___0 < msa->alen) {
    idx = 0;
    while (idx < msa->nseq) {
      if (! ((int )*(*(msa->aseq + idx) + i___0) == 32)) {
        if (! ((int )*(*(msa->aseq + idx) + i___0) == 46)) {
          if (! ((int )*(*(msa->aseq + idx) + i___0) == 95)) {
            if (! ((int )*(*(msa->aseq + idx) + i___0) == 45)) {
              if (! ((int )*(*(msa->aseq + idx) + i___0) == 126)) {
                tmp___5 = SymbolIndex(*(*(msa->aseq + idx) + i___0));
                P7CountSymbol(*(matc + (i___0 + 1)), (char )tmp___5, *(msa->wgt + idx));
              }
            }
          }
        }
      }
      idx ++;
    }
    i___0 ++;
  }
  if (mpri > (float )0) {
    tmp___6 = log((double )mpri);
    mpri = (float )(tmp___6 * 1.44269504);
  } else {
    mpri = (float )(- 9999.);
  }
  FCopy(insp, prior->i[0], Alphabet_size);
  FNorm(insp, Alphabet_size);
  wgtsum = FSum(msa->wgt, msa->nseq);
  x = 0;
  while (x < Alphabet_size) {
    if (insp[x] / *(null + x) > (float )0) {
      tmp___7 = log((double )(insp[x] / *(null + x)));
      insp[x] = (float )(tmp___7 * 1.44269504);
    } else {
      insp[x] = (float )(- 9999.);
    }
    x ++;
  }
  est_M = estimate_model_length(msa);
  t_me = (float )(0.5 / (double )((float )(est_M - 1)));
  bm1 = (float )0.5;
  bm2 = (float )(0.5 / (double )((float )(est_M - 1)));
  if (bm1 / null_p1 > (float )0) {
    tmp___8 = log((double )(bm1 / null_p1));
    bm1 = (float )(tmp___8 * 1.44269504);
  } else {
    bm1 = (float )(- 9999.);
  }
  if (bm2 / null_p1 > (float )0) {
    tmp___9 = log((double )(bm2 / null_p1));
    bm2 = (float )(tmp___9 * 1.44269504);
  } else {
    bm2 = (float )(- 9999.);
  }
  maxgap = (float )0.5;
  last = msa->alen;
  while (last >= 1) {
    ngap = 0;
    idx = 0;
    while (idx < msa->nseq) {
      if ((int )*(*(msa->aseq + idx) + (last - 1)) == 32) {
        ngap ++;
      } else
      if ((int )*(*(msa->aseq + idx) + (last - 1)) == 46) {
        ngap ++;
      } else
      if ((int )*(*(msa->aseq + idx) + (last - 1)) == 95) {
        ngap ++;
      } else
      if ((int )*(*(msa->aseq + idx) + (last - 1)) == 45) {
        ngap ++;
      } else
      if ((int )*(*(msa->aseq + idx) + (last - 1)) == 126) {
        ngap ++;
      }
      idx ++;
    }
    if ((float )ngap / (float )msa->nseq <= maxgap) {
      break;
    }
    last --;
  }
  *(sc + last) = (float )0.;
  *(tbck + last) = 0;
  idx = 0;
  while (idx < msa->nseq) {
    i___0 = last;
    while (1) {
      if (i___0 > 0) {
        if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 32)) {
          if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 46)) {
            if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 95)) {
              if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 45)) {
                if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 126)) {
                  break;
                }
              }
            }
          }
        }
      } else {
        break;
      }
      *(*(msa->aseq + idx) + (i___0 - 1)) = (char )'_';
      i___0 --;
    }
    idx ++;
  }
  i___0 = last - 1;
  while (i___0 > 0) {
    FCopy(matp, *(matc + i___0), Alphabet_size);
    P7PriorifyEmissionVector(matp, prior, prior->mnum, (float *)(prior->mq), (float (*)[20])(prior->m),
                             (float *)((void *)0));
    x = 0;
    while (x < Alphabet_size) {
      if (matp[x] / *(null + x) > (float )0) {
        tmp___10 = log((double )(matp[x] / *(null + x)));
        matp[x] = (float )(tmp___10 * 1.44269504);
      } else {
        matp[x] = (float )(- 9999.);
      }
      x ++;
    }
    FSet(insc, Alphabet_size, (float )0.);
    idx = 0;
    while (idx < msa->nseq) {
      *(insopt + idx) = 0;
      idx ++;
    }
    *(sc + i___0) = - 3.40282347e+38F;
    j = i___0 + 1;
    while (j <= last) {
      code = build_cij(msa->aseq, msa->nseq, insopt, i___0, j, msa->wgt, cij);
      if (code == -1) {
        break;
      }
      if (code == 1) {
        FCopy(tij, cij, 7);
        P7PriorifyTransitionVector(tij, prior, (float *)(prior->tq));
        FNorm(tij, 3);
        if (tij[0] / null_p1 > (float )0) {
          tmp___11 = log((double )(tij[0] / null_p1));
          tij[0] = (float )(tmp___11 * 1.44269504);
        } else {
          tij[0] = (float )(- 9999.);
        }
        if (tij[1] / null_p1 > (float )0) {
          tmp___12 = log((double )(tij[1] / null_p1));
          tij[1] = (float )(tmp___12 * 1.44269504);
        } else {
          tij[1] = (float )(- 9999.);
        }
        if (tij[2] > (float )0) {
          tmp___13 = log((double )tij[2]);
          tij[2] = (float )(tmp___13 * 1.44269504);
        } else {
          tij[2] = (float )(- 9999.);
        }
        if (tij[3] / null_p1 > (float )0) {
          tmp___14 = log((double )(tij[3] / null_p1));
          tij[3] = (float )(tmp___14 * 1.44269504);
        } else {
          tij[3] = (float )(- 9999.);
        }
        if (tij[4] / null_p1 > (float )0) {
          tmp___15 = log((double )(tij[4] / null_p1));
          tij[4] = (float )(tmp___15 * 1.44269504);
        } else {
          tij[4] = (float )(- 9999.);
        }
        if (tij[5] / null_p1 > (float )0) {
          tmp___16 = log((double )(tij[5] / null_p1));
          tij[5] = (float )(tmp___16 * 1.44269504);
        } else {
          tij[5] = (float )(- 9999.);
        }
        if (tij[6] > (float )0) {
          tmp___17 = log((double )tij[6]);
          tij[6] = (float )(tmp___17 * 1.44269504);
        } else {
          tij[6] = (float )(- 9999.);
        }
        tmp___18 = FDot(tij, cij, 7);
        tmp___19 = FDot(insp, insc, Alphabet_size);
        new = (*(sc + j) + tmp___18) + tmp___19;
        if (new > *(sc + i___0)) {
          *(sc + i___0) = new;
          *(tbck + i___0) = j;
        }
      }
      FAdd(insc, *(matc + j), Alphabet_size);
      idx = 0;
      while (idx < msa->nseq) {
        if (! ((int )*(*(msa->aseq + idx) + (j - 1)) == 32)) {
          if (! ((int )*(*(msa->aseq + idx) + (j - 1)) == 46)) {
            if (! ((int )*(*(msa->aseq + idx) + (j - 1)) == 95)) {
              if (! ((int )*(*(msa->aseq + idx) + (j - 1)) == 45)) {
                if (! ((int )*(*(msa->aseq + idx) + (j - 1)) == 126)) {
                  (*(insopt + idx)) ++;
                }
              }
            }
          }
        }
        idx ++;
      }
      j ++;
    }
    tmp___20 = FDot(matp, *(matc + i___0), Alphabet_size);
    *(sc + i___0) += tmp___20 + mpri * wgtsum;
    i___0 --;
  }
  bestsc = - 3.40282347e+38F;
  first = 0;
  i___0 = 1;
  while (i___0 <= last) {
    new = *(sc + i___0);
    idx = 0;
    while (idx < msa->nseq) {
      if ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 32) {
        new += bm2;
      } else
      if ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 46) {
        new += bm2;
      } else
      if ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 95) {
        new += bm2;
      } else
      if ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 45) {
        new += bm2;
      } else
      if ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 126) {
        new += bm2;
      } else {
        new += bm1;
      }
      idx ++;
    }
    if (new > bestsc) {
      bestsc = new;
      first = i___0;
    }
    i___0 ++;
  }
  *(matassign + 0) = 0;
  i___0 = 1;
  while (i___0 <= msa->alen) {
    *(matassign + i___0) = 1 << 3;
    i___0 ++;
  }
  i___0 = first;
  while (i___0 != 0) {
    *(matassign + i___0) &= ~ (1 << 3);
    *(matassign + i___0) |= 1;
    i___0 = *(tbck + i___0);
  }
  matassign2hmm(msa, dsq, matassign, ret_hmm, ret_tr);
  i___0 = 1;
  while (i___0 <= msa->alen) {
    free((void *)*(matc + i___0));
    i___0 ++;
  }
  free((void *)matc);
  free((void *)sc);
  free((void *)tbck);
  free((void *)matassign);
  free((void *)insopt);
  return;
}
}
static int build_cij(char **aseqs , int nseq , int *insopt , int i___0 , int j , float *wgt ,
                     float *cij ) 
{ 
  int idx ;

  {
  i___0 --;
  j --;
  FSet(cij, 8, (float )0.);
  idx = 0;
  while (idx < nseq) {
    if (*(insopt + idx) > 0) {
      if ((int )*(*(aseqs + idx) + i___0) == 32) {
        return (-1);
      } else
      if ((int )*(*(aseqs + idx) + i___0) == 46) {
        return (-1);
      } else
      if ((int )*(*(aseqs + idx) + i___0) == 95) {
        return (-1);
      } else
      if ((int )*(*(aseqs + idx) + i___0) == 45) {
        return (-1);
      } else
      if ((int )*(*(aseqs + idx) + i___0) == 126) {
        return (-1);
      }
      if ((int )*(*(aseqs + idx) + j) == 32) {
        return (0);
      } else
      if ((int )*(*(aseqs + idx) + j) == 46) {
        return (0);
      } else
      if ((int )*(*(aseqs + idx) + j) == 95) {
        return (0);
      } else
      if ((int )*(*(aseqs + idx) + j) == 45) {
        return (0);
      } else
      if ((int )*(*(aseqs + idx) + j) == 126) {
        return (0);
      }
      *(cij + 1) += *(wgt + idx);
      *(cij + 4) += (float )(*(insopt + idx) - 1) * *(wgt + idx);
      *(cij + 3) += *(wgt + idx);
    } else
    if ((int )*(*(aseqs + idx) + i___0) == 32) {
      goto _L;
    } else
    if ((int )*(*(aseqs + idx) + i___0) == 46) {
      goto _L;
    } else
    if ((int )*(*(aseqs + idx) + i___0) == 95) {
      goto _L;
    } else
    if ((int )*(*(aseqs + idx) + i___0) == 45) {
      goto _L;
    } else
    if ((int )*(*(aseqs + idx) + i___0) == 126) {
      _L: /* CIL Label */ 
      if ((int )*(*(aseqs + idx) + j) == 95) {
        goto __Cont;
      } else
      if ((int )*(*(aseqs + idx) + j) == 32) {
        *(cij + 6) += *(wgt + idx);
      } else
      if ((int )*(*(aseqs + idx) + j) == 46) {
        *(cij + 6) += *(wgt + idx);
      } else
      if ((int )*(*(aseqs + idx) + j) == 95) {
        *(cij + 6) += *(wgt + idx);
      } else
      if ((int )*(*(aseqs + idx) + j) == 45) {
        *(cij + 6) += *(wgt + idx);
      } else
      if ((int )*(*(aseqs + idx) + j) == 126) {
        *(cij + 6) += *(wgt + idx);
      } else {
        *(cij + 5) += *(wgt + idx);
      }
    } else
    if (! ((int )*(*(aseqs + idx) + j) == 95)) {
      if ((int )*(*(aseqs + idx) + j) == 32) {
        *(cij + 2) += *(wgt + idx);
      } else
      if ((int )*(*(aseqs + idx) + j) == 46) {
        *(cij + 2) += *(wgt + idx);
      } else
      if ((int )*(*(aseqs + idx) + j) == 95) {
        *(cij + 2) += *(wgt + idx);
      } else
      if ((int )*(*(aseqs + idx) + j) == 45) {
        *(cij + 2) += *(wgt + idx);
      } else
      if ((int )*(*(aseqs + idx) + j) == 126) {
        *(cij + 2) += *(wgt + idx);
      } else {
        *(cij + 0) += *(wgt + idx);
      }
    }
    __Cont: /* CIL Label */ 
    idx ++;
  }
  return (1);
}
}
static int estimate_model_length(MSA *msa ) 
{ 
  int idx ;
  float total ;
  float wgtsum ;
  int tmp ;

  {
  total = (float )0.;
  wgtsum = (float )0.;
  idx = 0;
  while (idx < msa->nseq) {
    tmp = DealignedLength(*(msa->aseq + idx));
    total += *(msa->wgt + idx) * (float )tmp;
    wgtsum += *(msa->wgt + idx);
    idx ++;
  }
  return ((int )(total / wgtsum));
}
}
static void matassign2hmm(MSA *msa , char **dsq , int *matassign , struct plan7_s **ret_hmm ,
                          struct p7trace_s ***ret_tr ) 
{ 
  struct plan7_s *hmm ;
  struct p7trace_s **tr ;
  int M ;
  int idx ;
  int apos ;
  void *tmp ;

  {
  M = 0;
  apos = 1;
  while (apos <= msa->alen) {
    if (*(matassign + apos) & 1) {
      M ++;
    }
    apos ++;
  }
  if (M == 0) {
    Die((char *)"No conserved consensus columns found; aborting construction!\nThis is an unusual situation. Reexamine your sequence alignment. It is\nprobably unusually full of gaps, or lots of sequence fragments. You may be\nable to force HMMER to model it; see the --fast (and --gapmax), or --hand\noptions to hmmbuild.");
  }
  apos = 1;
  while (1) {
    if (*(matassign + apos) & (1 << 3)) {
      if (! (apos <= msa->alen)) {
        break;
      }
    } else {
      break;
    }
    *(matassign + apos) |= 1 << 4;
    apos ++;
  }
  if (apos <= msa->alen) {
    *(matassign + apos) |= 1 << 1;
  }
  apos = msa->alen;
  while (1) {
    if (*(matassign + apos) & (1 << 3)) {
      if (! (apos > 0)) {
        break;
      }
    } else {
      break;
    }
    *(matassign + apos) |= 1 << 5;
    apos --;
  }
  if (apos > 0) {
    *(matassign + apos) |= 1 << 2;
  }
  fake_tracebacks(msa->aseq, msa->nseq, msa->alen, matassign, & tr);
  hmm = AllocPlan7(M);
  ZeroPlan7(hmm);
  idx = 0;
  while (idx < msa->nseq) {
    P7TraceCount(hmm, *(dsq + idx), *(msa->wgt + idx), *(tr + idx));
    idx ++;
  }
  annotate_model(hmm, matassign, msa);
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
    free((void *)msa->rf);
  }
  tmp = sre_malloc((char *)"modelmakers.c", 564, sizeof(char ) * (unsigned long )(msa->alen + 1));
  msa->rf = (char *)tmp;
  apos = 0;
  while (apos < msa->alen) {
    if (*(matassign + (apos + 1)) & 1) {
      *(msa->rf + apos) = (char )'x';
    } else {
      *(msa->rf + apos) = (char )'.';
    }
    apos ++;
  }
  *(msa->rf + msa->alen) = (char )'\000';
  if ((unsigned long )ret_tr != (unsigned long )((void *)0)) {
    *ret_tr = tr;
  } else {
    idx = 0;
    while (idx < msa->nseq) {
      P7FreeTrace(*(tr + idx));
      idx ++;
    }
    free((void *)tr);
  }
  if ((unsigned long )ret_hmm != (unsigned long )((void *)0)) {
    *ret_hmm = hmm;
  } else {
    FreePlan7(hmm);
  }
  return;
}
}
static void fake_tracebacks(char **aseq , int nseq , int alen , int *matassign , struct p7trace_s ***ret_tr ) 
{ 
  struct p7trace_s **tr ;
  int idx ;
  int i___0 ;
  int k ;
  int apos ;
  int tpos ;
  void *tmp ;

  {
  tmp = sre_malloc((char *)"modelmakers.c", 607, sizeof(struct p7trace_s *) * (unsigned long )nseq);
  tr = (struct p7trace_s **)tmp;
  idx = 0;
  while (idx < nseq) {
    P7AllocTrace(alen + 6, tr + idx);
    *((*(tr + idx))->statetype + 0) = (char)4;
    *((*(tr + idx))->nodeidx + 0) = 0;
    *((*(tr + idx))->pos + 0) = 0;
    *((*(tr + idx))->statetype + 1) = (char)5;
    *((*(tr + idx))->nodeidx + 1) = 0;
    *((*(tr + idx))->pos + 1) = 0;
    i___0 = 1;
    k = 0;
    tpos = 2;
    apos = 0;
    while (apos < alen) {
      *((*(tr + idx))->statetype + tpos) = (char)0;
      if (*(matassign + (apos + 1)) & (1 << 1)) {
        *((*(tr + idx))->statetype + tpos) = (char)6;
        *((*(tr + idx))->nodeidx + tpos) = 0;
        *((*(tr + idx))->pos + tpos) = 0;
        tpos ++;
      }
      if (*(matassign + (apos + 1)) & 1) {
        if ((int )*(*(aseq + idx) + apos) == 32) {
          goto _L___1;
        } else
        if ((int )*(*(aseq + idx) + apos) == 46) {
          goto _L___1;
        } else
        if ((int )*(*(aseq + idx) + apos) == 95) {
          goto _L___1;
        } else
        if ((int )*(*(aseq + idx) + apos) == 45) {
          goto _L___1;
        } else
        if ((int )*(*(aseq + idx) + apos) == 126) {
          goto _L___1;
        } else {
          k ++;
          *((*(tr + idx))->statetype + tpos) = (char)1;
          *((*(tr + idx))->nodeidx + tpos) = k;
          *((*(tr + idx))->pos + tpos) = i___0;
          i___0 ++;
          tpos ++;
        }
      } else
      _L___1: /* CIL Label */ 
      if (*(matassign + (apos + 1)) & 1) {
        k ++;
        if ((int )*((*(tr + idx))->statetype + (tpos - 1)) != 6) {
          *((*(tr + idx))->statetype + tpos) = (char)2;
          *((*(tr + idx))->nodeidx + tpos) = k;
          *((*(tr + idx))->pos + tpos) = 0;
          tpos ++;
        }
      } else
      if (*(matassign + (apos + 1)) & (1 << 4)) {
        if ((int )*(*(aseq + idx) + apos) == 32) {
          goto _L___0;
        } else
        if ((int )*(*(aseq + idx) + apos) == 46) {
          goto _L___0;
        } else
        if ((int )*(*(aseq + idx) + apos) == 95) {
          goto _L___0;
        } else
        if ((int )*(*(aseq + idx) + apos) == 45) {
          goto _L___0;
        } else
        if ((int )*(*(aseq + idx) + apos) == 126) {
          goto _L___0;
        } else {
          *((*(tr + idx))->statetype + tpos) = (char)5;
          *((*(tr + idx))->nodeidx + tpos) = 0;
          *((*(tr + idx))->pos + tpos) = i___0;
          i___0 ++;
          tpos ++;
        }
      } else
      _L___0: /* CIL Label */ 
      if (*(matassign + (apos + 1)) & (1 << 5)) {
        if ((int )*(*(aseq + idx) + apos) == 32) {
          goto _L;
        } else
        if ((int )*(*(aseq + idx) + apos) == 46) {
          goto _L;
        } else
        if ((int )*(*(aseq + idx) + apos) == 95) {
          goto _L;
        } else
        if ((int )*(*(aseq + idx) + apos) == 45) {
          goto _L;
        } else
        if ((int )*(*(aseq + idx) + apos) == 126) {
          goto _L;
        } else {
          *((*(tr + idx))->statetype + tpos) = (char)8;
          *((*(tr + idx))->nodeidx + tpos) = 0;
          *((*(tr + idx))->pos + tpos) = i___0;
          i___0 ++;
          tpos ++;
        }
      } else
      _L: /* CIL Label */ 
      if (! ((int )*(*(aseq + idx) + apos) == 32)) {
        if (! ((int )*(*(aseq + idx) + apos) == 46)) {
          if (! ((int )*(*(aseq + idx) + apos) == 95)) {
            if (! ((int )*(*(aseq + idx) + apos) == 45)) {
              if (! ((int )*(*(aseq + idx) + apos) == 126)) {
                *((*(tr + idx))->statetype + tpos) = (char)3;
                *((*(tr + idx))->nodeidx + tpos) = k;
                *((*(tr + idx))->pos + tpos) = i___0;
                i___0 ++;
                tpos ++;
              }
            }
          }
        }
      }
      if (*(matassign + (apos + 1)) & (1 << 2)) {
        while ((int )*((*(tr + idx))->statetype + (tpos - 1)) == 2) {
          tpos --;
        }
        *((*(tr + idx))->statetype + tpos) = (char)7;
        *((*(tr + idx))->nodeidx + tpos) = 0;
        *((*(tr + idx))->pos + tpos) = 0;
        tpos ++;
        *((*(tr + idx))->statetype + tpos) = (char)8;
        *((*(tr + idx))->nodeidx + tpos) = 0;
        *((*(tr + idx))->pos + tpos) = 0;
        tpos ++;
      }
      apos ++;
    }
    *((*(tr + idx))->statetype + tpos) = (char)9;
    *((*(tr + idx))->nodeidx + tpos) = 0;
    *((*(tr + idx))->pos + tpos) = 0;
    tpos ++;
    (*(tr + idx))->tlen = tpos;
    trace_doctor(*(tr + idx), k, (int *)((void *)0), (int *)((void *)0));
    idx ++;
  }
  *ret_tr = tr;
  return;
}
}
static void trace_doctor(struct p7trace_s *tr , int mlen , int *ret_ndi , int *ret_nid ) 
{ 
  int opos ;
  int npos ;
  int ndi ;
  int nid ;

  {
  nid = 0;
  ndi = nid;
  npos = 0;
  opos = npos;
  while (opos < tr->tlen) {
    if ((int )*(tr->statetype + opos) == 2) {
      if ((int )*(tr->statetype + (opos + 1)) == 3) {
        *(tr->statetype + npos) = (char)1;
        *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
        *(tr->pos + npos) = *(tr->pos + (opos + 1));
        opos += 2;
        npos ++;
        ndi ++;
      } else {
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
    if ((int )*(tr->statetype + opos) == 3) {
      if ((int )*(tr->statetype + (opos + 1)) == 2) {
        *(tr->statetype + npos) = (char)1;
        *(tr->nodeidx + npos) = *(tr->nodeidx + (opos + 1));
        *(tr->pos + npos) = *(tr->pos + opos);
        opos += 2;
        npos ++;
        nid ++;
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if ((int )*(tr->statetype + opos) == 3) {
      if ((int )*(tr->statetype + (opos - 1)) == 6) {
        *(tr->statetype + npos) = (char)1;
        *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
        *(tr->pos + npos) = *(tr->pos + opos);
        opos ++;
        npos ++;
      } else {
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
    if ((int )*(tr->statetype + opos) == 3) {
      if ((int )*(tr->statetype + (opos + 1)) == 7) {
        *(tr->statetype + npos) = (char)1;
        *(tr->nodeidx + npos) = *(tr->nodeidx + opos) + 1;
        *(tr->pos + npos) = *(tr->pos + opos);
        opos ++;
        npos ++;
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if ((int )*(tr->statetype + opos) == 6) {
      if ((int )*(tr->statetype + (opos + 1)) == 7) {
        if ((int )*(tr->statetype + (opos - 1)) == 5) {
          if (*(tr->pos + (opos - 1)) > 0) {
            *(tr->statetype + npos) = (char)1;
            *(tr->nodeidx + npos) = 1;
            *(tr->pos + npos) = *(tr->pos + (opos - 1));
            *(tr->statetype + (npos - 1)) = (char)6;
            *(tr->nodeidx + (npos - 1)) = 0;
            *(tr->pos + (npos - 1)) = 0;
            opos ++;
            npos ++;
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if ((int )*(tr->statetype + opos) == 7) {
      if ((int )*(tr->statetype + (opos - 1)) == 6) {
        if ((int )*(tr->statetype + (opos + 1)) == 8) {
          if ((int )*(tr->statetype + (opos + 2)) == 8) {
            *(tr->statetype + npos) = (char)1;
            *(tr->nodeidx + npos) = mlen;
            *(tr->pos + npos) = *(tr->pos + (opos + 2));
            *(tr->statetype + (npos + 1)) = (char)7;
            *(tr->nodeidx + (npos + 1)) = 0;
            *(tr->pos + (npos + 1)) = 0;
            *(tr->statetype + (npos + 2)) = (char)8;
            *(tr->nodeidx + (npos + 2)) = 0;
            *(tr->pos + (npos + 2)) = 0;
            opos += 3;
            npos += 3;
          } else {
            *(tr->statetype + npos) = *(tr->statetype + opos);
            *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
            *(tr->pos + npos) = *(tr->pos + opos);
            opos ++;
            npos ++;
          }
        } else {
          *(tr->statetype + npos) = *(tr->statetype + opos);
          *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
          *(tr->pos + npos) = *(tr->pos + opos);
          opos ++;
          npos ++;
        }
      } else {
        *(tr->statetype + npos) = *(tr->statetype + opos);
        *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
        *(tr->pos + npos) = *(tr->pos + opos);
        opos ++;
        npos ++;
      }
    } else {
      *(tr->statetype + npos) = *(tr->statetype + opos);
      *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
      *(tr->pos + npos) = *(tr->pos + opos);
      opos ++;
      npos ++;
    }
  }
  tr->tlen = npos;
  if ((unsigned long )ret_ndi != (unsigned long )((void *)0)) {
    *ret_ndi = ndi;
  }
  if ((unsigned long )ret_nid != (unsigned long )((void *)0)) {
    *ret_nid = nid;
  }
  return;
}
}
static void annotate_model(struct plan7_s *hmm , int *matassign , MSA *msa ) 
{ 
  int apos ;
  int k ;
  char *pri ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
    *(hmm->rf + 0) = (char )' ';
    k = 1;
    apos = k;
    while (apos <= msa->alen) {
      if (*(matassign + apos) & 1) {
        tmp = k;
        k ++;
        if ((int )*(msa->rf + (apos - 1)) == 32) {
          *(hmm->rf + tmp) = (char )'.';
        } else {
          *(hmm->rf + tmp) = *(msa->rf + (apos - 1));
        }
      }
      apos ++;
    }
    *(hmm->rf + k) = (char )'\000';
    hmm->flags |= 1 << 2;
  }
  if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
    *(hmm->cs + 0) = (char )' ';
    k = 1;
    apos = k;
    while (apos <= msa->alen) {
      if (*(matassign + apos) & 1) {
        tmp___0 = k;
        k ++;
        if ((int )*(msa->ss_cons + (apos - 1)) == 32) {
          *(hmm->cs + tmp___0) = (char )'.';
        } else {
          *(hmm->cs + tmp___0) = *(msa->ss_cons + (apos - 1));
        }
      }
      apos ++;
    }
    *(hmm->cs + k) = (char )'\000';
    hmm->flags |= 1 << 3;
  }
  if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
    *(hmm->ca + 0) = (char )' ';
    k = 1;
    apos = k;
    while (apos <= msa->alen) {
      if (*(matassign + apos) & 1) {
        tmp___1 = k;
        k ++;
        if ((int )*(msa->sa_cons + (apos - 1)) == 32) {
          *(hmm->ca + tmp___1) = (char )'.';
        } else {
          *(hmm->ca + tmp___1) = *(msa->sa_cons + (apos - 1));
        }
      }
      apos ++;
    }
    *(hmm->ca + k) = (char )'\000';
    hmm->flags |= 1 << 13;
  }
  k = 1;
  apos = k;
  while (apos <= msa->alen) {
    if (*(matassign + apos) & 1) {
      tmp___2 = k;
      k ++;
      *(hmm->map + tmp___2) = apos;
    }
    apos ++;
  }
  hmm->flags |= 1 << 8;
  pri = MSAGetGC(msa, (char *)"X-PRM");
  if ((unsigned long )pri != (unsigned long )((void *)0)) {
    tmp___3 = sre_malloc((char *)"modelmakers.c", 896, sizeof(int ) * (unsigned long )(hmm->M + 1));
    hmm->mpri = (int *)tmp___3;
    k = 1;
    apos = k;
    while (apos <= msa->alen) {
      if (*(matassign + apos) & 1) {
        tmp___6 = isdigit((int )*(pri + (apos - 1)));
        if (tmp___6) {
          *(hmm->mpri + k) = (int )*(pri + (apos - 1)) - 48;
        } else {
          tmp___5 = islower((int )*(pri + (apos - 1)));
          if (tmp___5) {
            *(hmm->mpri + k) = ((int )*(pri + (apos - 1)) - 97) + 10;
          } else {
            tmp___4 = isupper((int )*(pri + (apos - 1)));
            if (tmp___4) {
              *(hmm->mpri + k) = ((int )*(pri + (apos - 1)) - 65) + 10;
            } else {
              *(hmm->mpri + k) = -1;
            }
          }
        }
        k ++;
      }
      apos ++;
    }
  }
  pri = MSAGetGC(msa, (char *)"X-PRI");
  if ((unsigned long )pri != (unsigned long )((void *)0)) {
    tmp___7 = sre_malloc((char *)"modelmakers.c", 911, sizeof(int ) * (unsigned long )(hmm->M + 1));
    hmm->ipri = (int *)tmp___7;
    k = 1;
    apos = k;
    while (apos <= msa->alen) {
      if (*(matassign + apos) & 1) {
        tmp___10 = isdigit((int )*(pri + (apos - 1)));
        if (tmp___10) {
          *(hmm->ipri + k) = (int )*(pri + (apos - 1)) - 48;
        } else {
          tmp___9 = islower((int )*(pri + (apos - 1)));
          if (tmp___9) {
            *(hmm->ipri + k) = ((int )*(pri + (apos - 1)) - 97) + 10;
          } else {
            tmp___8 = isupper((int )*(pri + (apos - 1)));
            if (tmp___8) {
              *(hmm->ipri + k) = ((int )*(pri + (apos - 1)) - 65) + 10;
            } else {
              *(hmm->ipri + k) = -1;
            }
          }
        }
        k ++;
      }
      apos ++;
    }
  }
  pri = MSAGetGC(msa, (char *)"X-PRT");
  if ((unsigned long )pri != (unsigned long )((void *)0)) {
    tmp___11 = sre_malloc((char *)"modelmakers.c", 926, sizeof(int ) * (unsigned long )(hmm->M + 1));
    hmm->tpri = (int *)tmp___11;
    k = 1;
    apos = k;
    while (apos <= msa->alen) {
      if (*(matassign + apos) & 1) {
        tmp___14 = isdigit((int )*(pri + (apos - 1)));
        if (tmp___14) {
          *(hmm->tpri + k) = (int )*(pri + (apos - 1)) - 48;
        } else {
          tmp___13 = islower((int )*(pri + (apos - 1)));
          if (tmp___13) {
            *(hmm->tpri + k) = ((int )*(pri + (apos - 1)) - 97) + 10;
          } else {
            tmp___12 = isupper((int )*(pri + (apos - 1)));
            if (tmp___12) {
              *(hmm->tpri + k) = ((int )*(pri + (apos - 1)) - 65) + 10;
            } else {
              *(hmm->tpri + k) = -1;
            }
          }
        }
        k ++;
      }
      apos ++;
    }
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-XGYh0mnX.i","-O3")
extern char *ctime(time_t const   * ) ;
void Plan7SetNullModel(struct plan7_s *hmm , float *null , float p1 ) ;
void Plan7RenormalizeExits(struct plan7_s *hmm ) ;
void Plan7NakedConfig(struct plan7_s *hmm ) ;
void Plan7GlobalConfig(struct plan7_s *hmm ) ;
void Plan7SWConfig(struct plan7_s *hmm , float pentry , float pexit ) ;
void Plan7FSConfig(struct plan7_s *hmm , float pentry , float pexit ) ;
void PrintPlan7Stats(FILE *fp , struct plan7_s *hmm , char **dsq , int nseq , struct p7trace_s **tr ) ;
struct plan7_s *AllocPlan7(int M ) 
{ 
  struct plan7_s *hmm ;

  {
  hmm = AllocPlan7Shell();
  AllocPlan7Body(hmm, M);
  return (hmm);
}
}
struct plan7_s *AllocPlan7Shell(void) 
{ 
  struct plan7_s *hmm ;
  void *tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  int **tmp___3 ;
  int **tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
  tmp = sre_malloc((char *)"plan7.c", 54, sizeof(struct plan7_s ));
  hmm = (struct plan7_s *)tmp;
  hmm->M = 0;
  hmm->name = (char *)((void *)0);
  hmm->acc = (char *)((void *)0);
  hmm->desc = (char *)((void *)0);
  hmm->rf = (char *)((void *)0);
  hmm->cs = (char *)((void *)0);
  hmm->ca = (char *)((void *)0);
  hmm->comlog = (char *)((void *)0);
  hmm->nseq = 0;
  hmm->ctime = (char *)((void *)0);
  hmm->map = (int *)((void *)0);
  hmm->checksum = 0;
  hmm->tpri = (int *)((void *)0);
  hmm->mpri = (int *)((void *)0);
  hmm->ipri = (int *)((void *)0);
  tmp___0 = (float )0.0;
  hmm->ga2 = tmp___0;
  hmm->ga1 = tmp___0;
  tmp___1 = (float )0.0;
  hmm->tc2 = tmp___1;
  hmm->tc1 = tmp___1;
  tmp___2 = (float )0.0;
  hmm->nc2 = tmp___2;
  hmm->nc1 = tmp___2;
  hmm->t = (float **)((void *)0);
  hmm->mat = (float **)((void *)0);
  hmm->ins = (float **)((void *)0);
  tmp___4 = (int **)((void *)0);
  hmm->isc = tmp___4;
  tmp___3 = tmp___4;
  hmm->msc = tmp___3;
  hmm->tsc = tmp___3;
  tmp___6 = (int *)((void *)0);
  hmm->msc_mem = tmp___6;
  tmp___5 = tmp___6;
  hmm->msc_mem = tmp___5;
  hmm->tsc_mem = tmp___5;
  hmm->begin = (float *)((void *)0);
  hmm->end = (float *)((void *)0);
  tmp___7 = (int *)((void *)0);
  hmm->bsc_mem = tmp___7;
  hmm->bsc = tmp___7;
  tmp___8 = (int *)((void *)0);
  hmm->esc_mem = tmp___8;
  hmm->esc = tmp___8;
  hmm->dnam = (int **)((void *)0);
  hmm->dnai = (int **)((void *)0);
  hmm->dna2 = -987654321;
  hmm->dna4 = -987654321;
  hmm->mu = (float )0.;
  hmm->lambda = (float )0.;
  hmm->flags = 0;
  return (hmm);
}
}
void AllocPlan7Body(struct plan7_s *hmm , int M ) 
{ 
  int k ;
  int x ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;

  {
  hmm->M = M;
  tmp = sre_malloc((char *)"plan7.c", 111, (unsigned long )(M + 2) * sizeof(char ));
  hmm->rf = (char *)tmp;
  tmp___0 = sre_malloc((char *)"plan7.c", 112, (unsigned long )(M + 2) * sizeof(char ));
  hmm->cs = (char *)tmp___0;
  tmp___1 = sre_malloc((char *)"plan7.c", 113, (unsigned long )(M + 2) * sizeof(char ));
  hmm->ca = (char *)tmp___1;
  tmp___2 = sre_malloc((char *)"plan7.c", 114, (unsigned long )(M + 1) * sizeof(int ));
  hmm->map = (int *)tmp___2;
  tmp___3 = sre_malloc((char *)"plan7.c", 116, (unsigned long )M * sizeof(float *));
  hmm->t = (float **)tmp___3;
  tmp___4 = sre_malloc((char *)"plan7.c", 117, (unsigned long )(M + 1) * sizeof(float *));
  hmm->mat = (float **)tmp___4;
  tmp___5 = sre_malloc((char *)"plan7.c", 118, (unsigned long )M * sizeof(float *));
  hmm->ins = (float **)tmp___5;
  tmp___6 = sre_malloc((char *)"plan7.c", 119, (unsigned long )(7 * M) * sizeof(float ));
  *(hmm->t + 0) = (float *)tmp___6;
  tmp___7 = sre_malloc((char *)"plan7.c", 120, (unsigned long )(20 * (M + 1)) * sizeof(float ));
  *(hmm->mat + 0) = (float *)tmp___7;
  tmp___8 = sre_malloc((char *)"plan7.c", 121, (unsigned long )(20 * M) * sizeof(float ));
  *(hmm->ins + 0) = (float *)tmp___8;
  tmp___9 = sre_malloc((char *)"plan7.c", 123, 7UL * sizeof(int *));
  hmm->tsc = (int **)tmp___9;
  tmp___10 = sre_malloc((char *)"plan7.c", 124, 24UL * sizeof(int *));
  hmm->msc = (int **)tmp___10;
  tmp___11 = sre_malloc((char *)"plan7.c", 125, 24UL * sizeof(int *));
  hmm->isc = (int **)tmp___11;
  tmp___12 = sre_malloc((char *)"plan7.c", 126, (unsigned long )(7 * M) * sizeof(int ));
  hmm->tsc_mem = (int *)tmp___12;
  tmp___13 = sre_malloc((char *)"plan7.c", 127, (unsigned long )(24 * (M + 1)) * sizeof(int ));
  hmm->msc_mem = (int *)tmp___13;
  tmp___14 = sre_malloc((char *)"plan7.c", 128, (unsigned long )(24 * M) * sizeof(int ));
  hmm->isc_mem = (int *)tmp___14;
  *(hmm->tsc + 0) = hmm->tsc_mem;
  *(hmm->msc + 0) = hmm->msc_mem;
  *(hmm->isc + 0) = hmm->isc_mem;
  k = 1;
  while (k <= M) {
    *(hmm->mat + k) = *(hmm->mat + 0) + k * 20;
    if (k < M) {
      *(hmm->ins + k) = *(hmm->ins + 0) + k * 20;
      *(hmm->t + k) = *(hmm->t + 0) + k * 7;
    }
    k ++;
  }
  x = 1;
  while (x < 24) {
    *(hmm->msc + x) = *(hmm->msc + 0) + x * (M + 1);
    *(hmm->isc + x) = *(hmm->isc + 0) + x * M;
    x ++;
  }
  x = 0;
  while (x < 7) {
    *(hmm->tsc + x) = *(hmm->tsc + 0) + x * M;
    x ++;
  }
  x = 0;
  while (x < 7) {
    *(*(hmm->tsc + x) + 0) = -987654321;
    x ++;
  }
  tmp___15 = sre_malloc((char *)"plan7.c", 157, (unsigned long )(M + 1) * sizeof(float ));
  hmm->begin = (float *)tmp___15;
  tmp___16 = sre_malloc((char *)"plan7.c", 158, (unsigned long )(M + 1) * sizeof(float ));
  hmm->end = (float *)tmp___16;
  tmp___17 = sre_malloc((char *)"plan7.c", 160, (unsigned long )(M + 1) * sizeof(int ));
  hmm->bsc_mem = (int *)tmp___17;
  tmp___18 = sre_malloc((char *)"plan7.c", 161, (unsigned long )(M + 1) * sizeof(int ));
  hmm->esc_mem = (int *)tmp___18;
  hmm->bsc = hmm->bsc_mem;
  hmm->esc = hmm->esc_mem;
  return;
}
}
void FreePlan7(struct plan7_s *hmm ) 
{ 


  {
  if ((unsigned long )hmm->name != (unsigned long )((void *)0)) {
    free((void *)hmm->name);
  }
  if ((unsigned long )hmm->acc != (unsigned long )((void *)0)) {
    free((void *)hmm->acc);
  }
  if ((unsigned long )hmm->desc != (unsigned long )((void *)0)) {
    free((void *)hmm->desc);
  }
  if ((unsigned long )hmm->rf != (unsigned long )((void *)0)) {
    free((void *)hmm->rf);
  }
  if ((unsigned long )hmm->cs != (unsigned long )((void *)0)) {
    free((void *)hmm->cs);
  }
  if ((unsigned long )hmm->ca != (unsigned long )((void *)0)) {
    free((void *)hmm->ca);
  }
  if ((unsigned long )hmm->comlog != (unsigned long )((void *)0)) {
    free((void *)hmm->comlog);
  }
  if ((unsigned long )hmm->ctime != (unsigned long )((void *)0)) {
    free((void *)hmm->ctime);
  }
  if ((unsigned long )hmm->map != (unsigned long )((void *)0)) {
    free((void *)hmm->map);
  }
  if ((unsigned long )hmm->tpri != (unsigned long )((void *)0)) {
    free((void *)hmm->tpri);
  }
  if ((unsigned long )hmm->mpri != (unsigned long )((void *)0)) {
    free((void *)hmm->mpri);
  }
  if ((unsigned long )hmm->ipri != (unsigned long )((void *)0)) {
    free((void *)hmm->ipri);
  }
  if ((unsigned long )hmm->bsc_mem != (unsigned long )((void *)0)) {
    free((void *)hmm->bsc_mem);
  }
  if ((unsigned long )hmm->begin != (unsigned long )((void *)0)) {
    free((void *)hmm->begin);
  }
  if ((unsigned long )hmm->esc_mem != (unsigned long )((void *)0)) {
    free((void *)hmm->esc_mem);
  }
  if ((unsigned long )hmm->end != (unsigned long )((void *)0)) {
    free((void *)hmm->end);
  }
  if ((unsigned long )hmm->msc_mem != (unsigned long )((void *)0)) {
    free((void *)hmm->msc_mem);
  }
  if ((unsigned long )hmm->isc_mem != (unsigned long )((void *)0)) {
    free((void *)hmm->isc_mem);
  }
  if ((unsigned long )hmm->tsc_mem != (unsigned long )((void *)0)) {
    free((void *)hmm->tsc_mem);
  }
  if ((unsigned long )hmm->mat != (unsigned long )((void *)0)) {
    free((void *)*(hmm->mat + 0));
  }
  if ((unsigned long )hmm->ins != (unsigned long )((void *)0)) {
    free((void *)*(hmm->ins + 0));
  }
  if ((unsigned long )hmm->t != (unsigned long )((void *)0)) {
    free((void *)*(hmm->t + 0));
  }
  if ((unsigned long )hmm->msc != (unsigned long )((void *)0)) {
    free((void *)hmm->msc);
  }
  if ((unsigned long )hmm->isc != (unsigned long )((void *)0)) {
    free((void *)hmm->isc);
  }
  if ((unsigned long )hmm->tsc != (unsigned long )((void *)0)) {
    free((void *)hmm->tsc);
  }
  if ((unsigned long )hmm->mat != (unsigned long )((void *)0)) {
    free((void *)hmm->mat);
  }
  if ((unsigned long )hmm->ins != (unsigned long )((void *)0)) {
    free((void *)hmm->ins);
  }
  if ((unsigned long )hmm->t != (unsigned long )((void *)0)) {
    free((void *)hmm->t);
  }
  if ((unsigned long )hmm->dnam != (unsigned long )((void *)0)) {
    free((void *)hmm->dnam);
  }
  if ((unsigned long )hmm->dnai != (unsigned long )((void *)0)) {
    free((void *)hmm->dnai);
  }
  free((void *)hmm);
  return;
}
}
void ZeroPlan7(struct plan7_s *hmm ) 
{ 
  int k ;

  {
  k = 1;
  while (k < hmm->M) {
    FSet(*(hmm->t + k), 7, (float )0.);
    FSet(*(hmm->mat + k), Alphabet_size, (float )0.);
    FSet(*(hmm->ins + k), Alphabet_size, (float )0.);
    k ++;
  }
  FSet(*(hmm->mat + hmm->M), Alphabet_size, (float )0.);
  hmm->tbd1 = (float )0.;
  FSet(hmm->begin + 1, hmm->M, (float )0.);
  FSet(hmm->end + 1, hmm->M, (float )0.);
  k = 0;
  while (k < 4) {
    FSet(hmm->xt[k], 2, (float )0.);
    k ++;
  }
  hmm->flags &= -2;
  hmm->flags &= ~ (1 << 5);
  return;
}
}
void Plan7SetName(struct plan7_s *hmm , char *name ) 
{ 


  {
  if ((unsigned long )hmm->name != (unsigned long )((void *)0)) {
    free((void *)hmm->name);
  }
  hmm->name = Strdup(name);
  StringChop(hmm->name);
  return;
}
}
void Plan7SetAccession(struct plan7_s *hmm , char *acc ) 
{ 


  {
  if ((unsigned long )hmm->acc != (unsigned long )((void *)0)) {
    free((void *)hmm->acc);
  }
  hmm->acc = Strdup(acc);
  StringChop(hmm->acc);
  hmm->flags |= 1 << 9;
  return;
}
}
void Plan7SetDescription(struct plan7_s *hmm , char *desc ) 
{ 


  {
  if ((unsigned long )hmm->desc != (unsigned long )((void *)0)) {
    free((void *)hmm->desc);
  }
  hmm->desc = Strdup(desc);
  StringChop(hmm->desc);
  hmm->flags |= 1 << 1;
  return;
}
}
void Plan7ComlogAppend(struct plan7_s *hmm , int argc , char **argv ) 
{ 
  int len ;
  int i___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;

  {
  len = argc;
  i___0 = 0;
  while (i___0 < argc) {
    tmp = strlen((char const   *)*(argv + i___0));
    len = (int )((size_t )len + tmp);
    i___0 ++;
  }
  if ((unsigned long )hmm->comlog != (unsigned long )((void *)0)) {
    tmp___0 = strlen((char const   *)hmm->comlog);
    len = (int )((size_t )len + tmp___0);
    tmp___1 = sre_realloc((char *)"plan7.c", 296, (void *)hmm->comlog, sizeof(char ) * (unsigned long )(len + 1));
    hmm->comlog = (char *)tmp___1;
  } else {
    tmp___2 = sre_malloc((char *)"plan7.c", 300, sizeof(char ) * (unsigned long )(len + 1));
    hmm->comlog = (char *)tmp___2;
    *(hmm->comlog) = (char )'\000';
  }
  tmp___4 = __builtin_object_size((void *)hmm->comlog, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___3 = __builtin_object_size((void *)hmm->comlog, 1);
    __builtin___strcat_chk(hmm->comlog, "\n", tmp___3);
  } else {
    __inline_strcat_chk(hmm->comlog, "\n");
  }
  i___0 = 0;
  while (i___0 < argc) {
    tmp___6 = __builtin_object_size((void *)hmm->comlog, 0);
    if (tmp___6 != 0xffffffffffffffffUL) {
      tmp___5 = __builtin_object_size((void *)hmm->comlog, 1);
      __builtin___strcat_chk(hmm->comlog, (char const   *)*(argv + i___0), tmp___5);
    } else {
      __inline_strcat_chk(hmm->comlog, (char const   *)*(argv + i___0));
    }
    if (i___0 < argc - 1) {
      tmp___8 = __builtin_object_size((void *)hmm->comlog, 0);
      if (tmp___8 != 0xffffffffffffffffUL) {
        tmp___7 = __builtin_object_size((void *)hmm->comlog, 1);
        __builtin___strcat_chk(hmm->comlog, " ", tmp___7);
      } else {
        __inline_strcat_chk(hmm->comlog, " ");
      }
    }
    i___0 ++;
  }
  return;
}
}
void Plan7SetCtime(struct plan7_s *hmm ) 
{ 
  time_t date ;
  time_t tmp ;
  char *tmp___0 ;

  {
  tmp = time((time_t *)((void *)0));
  date = tmp;
  if ((unsigned long )hmm->ctime != (unsigned long )((void *)0)) {
    free((void *)hmm->ctime);
  }
  tmp___0 = ctime((time_t const   *)(& date));
  hmm->ctime = Strdup(tmp___0);
  StringChop(hmm->ctime);
  return;
}
}
void Plan7SetNullModel(struct plan7_s *hmm , float *null , float p1 ) 
{ 
  int x ;

  {
  x = 0;
  while (x < Alphabet_size) {
    hmm->null[x] = *(null + x);
    x ++;
  }
  hmm->p1 = p1;
  return;
}
}
void P7Logoddsify(struct plan7_s *hmm , int viterbi_mode ) 
{ 
  int k ;
  int x ;
  float accum ;
  float tbm ;
  float tme ;
  double tmp ;
  double tmp___0 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;

  {
  if (hmm->flags & 1) {
    return;
  }
  k = 1;
  while (k <= hmm->M) {
    x = 0;
    while (x < Alphabet_size) {
      *(*(hmm->msc + x) + k) = Prob2Score(*(*(hmm->mat + k) + x), hmm->null[x]);
      if (k < hmm->M) {
        *(*(hmm->isc + x) + k) = Prob2Score(*(*(hmm->ins + k) + x), hmm->null[x]);
      }
      x ++;
    }
    x = Alphabet_size;
    while (x < Alphabet_iupac) {
      *(*(hmm->msc + x) + k) = DegenerateSymbolScore(*(hmm->mat + k), hmm->null, x);
      if (k < hmm->M) {
        *(*(hmm->isc + x) + k) = DegenerateSymbolScore(*(hmm->ins + k), hmm->null,
                                                       x);
      }
      x ++;
    }
    k ++;
  }
  k = 1;
  while (k < hmm->M) {
    *(*(hmm->tsc + 0) + k) = Prob2Score(*(*(hmm->t + k) + 0), hmm->p1);
    *(*(hmm->tsc + 1) + k) = Prob2Score(*(*(hmm->t + k) + 1), hmm->p1);
    *(*(hmm->tsc + 2) + k) = Prob2Score(*(*(hmm->t + k) + 2), (float )1.0);
    *(*(hmm->tsc + 3) + k) = Prob2Score(*(*(hmm->t + k) + 3), hmm->p1);
    *(*(hmm->tsc + 4) + k) = Prob2Score(*(*(hmm->t + k) + 4), hmm->p1);
    *(*(hmm->tsc + 5) + k) = Prob2Score(*(*(hmm->t + k) + 5), hmm->p1);
    *(*(hmm->tsc + 6) + k) = Prob2Score(*(*(hmm->t + k) + 6), (float )1.0);
    k ++;
  }
  if ((double )hmm->tbd1 > 0.0) {
    tmp = log((double )hmm->tbd1);
    accum = (float )tmp;
  } else {
    accum = (float )(- 9999.);
  }
  k = 1;
  while (k <= hmm->M) {
    if ((double )*(hmm->begin + k) > 0.) {
      tmp___0 = log((double )*(hmm->begin + k));
      tbm = (float )tmp___0;
    } else {
      tbm = (float )(- 9999.);
    }
    if (k > 1) {
      if ((double )accum > - 9999.) {
        if ((double )*(*(hmm->t + (k - 1)) + 5) > 0.0) {
          if (viterbi_mode) {
            tmp___3 = log((double )*(*(hmm->t + (k - 1)) + 5));
            if ((double )tbm > (double )accum + tmp___3) {
              tbm = tbm;
            } else {
              tmp___2 = log((double )*(*(hmm->t + (k - 1)) + 5));
              tbm = (float )((double )accum + tmp___2);
            }
          } else {
            tmp___4 = log((double )*(*(hmm->t + (k - 1)) + 5));
            tbm = LogSum(tbm, (float )((double )accum + tmp___4));
          }
        }
        if ((double )*(*(hmm->t + (k - 1)) + 6) > 0.0) {
          tmp___5 = log((double )*(*(hmm->t + (k - 1)) + 6));
          accum = (float )((double )accum + tmp___5);
        } else {
          accum = (float )(- 9999.);
        }
      }
    }
    if ((double )tbm > - 9999.) {
      tmp___6 = log((double )hmm->p1);
      tmp___7 = floor(0.5 + (1000.0 * 1.44269504) * ((double )tbm - tmp___6));
      *(hmm->bsc + k) = (int )tmp___7;
    } else {
      *(hmm->bsc + k) = -987654321;
    }
    k ++;
  }
  *(hmm->esc + hmm->M) = 0;
  accum = (float )0.;
  k = hmm->M - 1;
  while (k >= 1) {
    if ((double )*(hmm->end + k) > 0.) {
      tmp___8 = log((double )*(hmm->end + k));
      tme = (float )tmp___8;
    } else {
      tme = (float )(- 9999.);
    }
    if ((double )accum > - 9999.) {
      if ((double )*(*(hmm->t + k) + 2) > 0.0) {
        if (viterbi_mode) {
          tmp___11 = log((double )*(*(hmm->t + k) + 2));
          if ((double )tme > (double )accum + tmp___11) {
            tme = tme;
          } else {
            tmp___10 = log((double )*(*(hmm->t + k) + 2));
            tme = (float )((double )accum + tmp___10);
          }
        } else {
          tmp___12 = log((double )*(*(hmm->t + k) + 2));
          tme = LogSum(tme, (float )((double )accum + tmp___12));
        }
      }
      if ((double )*(*(hmm->t + k) + 6) > 0.0) {
        tmp___13 = log((double )*(*(hmm->t + k) + 6));
        accum = (float )((double )accum + tmp___13);
      } else {
        accum = (float )(- 9999.);
      }
    }
    if ((double )tme > - 9999.) {
      tmp___14 = floor(0.5 + (1000.0 * 1.44269504) * (double )tme);
      *(hmm->esc + k) = (int )tmp___14;
    } else {
      *(hmm->esc + k) = -987654321;
    }
    k --;
  }
  hmm->xsc[0][1] = Prob2Score(hmm->xt[0][1], hmm->p1);
  hmm->xsc[0][0] = Prob2Score(hmm->xt[0][0], (float )1.0);
  hmm->xsc[1][1] = Prob2Score(hmm->xt[1][1], (float )1.0);
  hmm->xsc[1][0] = Prob2Score(hmm->xt[1][0], (float )1.0);
  hmm->xsc[2][1] = Prob2Score(hmm->xt[2][1], hmm->p1);
  hmm->xsc[2][0] = Prob2Score(hmm->xt[2][0], (float )(1. - (double )hmm->p1));
  hmm->xsc[3][1] = Prob2Score(hmm->xt[3][1], hmm->p1);
  hmm->xsc[3][0] = Prob2Score(hmm->xt[3][0], (float )1.0);
  hmm->flags |= 1;
  return;
}
}
void Plan7Renormalize(struct plan7_s *hmm ) 
{ 
  int k ;
  int st ;
  float d___0 ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;

  {
  k = 1;
  while (k <= hmm->M) {
    FNorm(*(hmm->mat + k), Alphabet_size);
    k ++;
  }
  k = 1;
  while (k < hmm->M) {
    FNorm(*(hmm->ins + k), Alphabet_size);
    k ++;
  }
  tmp = FSum(hmm->begin + 1, hmm->M);
  d___0 = tmp + hmm->tbd1;
  FScale(hmm->begin + 1, hmm->M, (float )(1. / (double )d___0));
  hmm->tbd1 /= d___0;
  k = 1;
  while (k < hmm->M) {
    tmp___0 = FSum(*(hmm->t + k), 3);
    d___0 = tmp___0 + *(hmm->end + k);
    FScale(*(hmm->t + k), 3, (float )(1. / (double )d___0));
    *(hmm->end + k) /= d___0;
    FNorm(*(hmm->t + k) + 3, 2);
    FNorm(*(hmm->t + k) + 5, 2);
    k ++;
  }
  FNorm(hmm->null, Alphabet_size);
  st = 0;
  while (st < 4) {
    FNorm(hmm->xt[st], 2);
    st ++;
  }
  tmp___1 = (float )0.0;
  *(*(hmm->t + 0) + 6) = tmp___1;
  *(*(hmm->t + 0) + 5) = tmp___1;
  hmm->flags &= -2;
  hmm->flags |= 1 << 5;
  return;
}
}
void Plan7RenormalizeExits(struct plan7_s *hmm ) 
{ 
  int k ;
  float d___0 ;

  {
  k = 1;
  while (k < hmm->M) {
    d___0 = FSum(*(hmm->t + k), 3);
    FScale(*(hmm->t + k), 3, (float )(1. / (double )(d___0 + d___0 * *(hmm->end + k))));
    k ++;
  }
  return;
}
}
void Plan7NakedConfig(struct plan7_s *hmm ) 
{ 


  {
  hmm->xt[0][0] = (float )1.;
  hmm->xt[0][1] = (float )0.;
  hmm->xt[1][0] = (float )1.;
  hmm->xt[1][1] = (float )0.;
  hmm->xt[2][0] = (float )1.;
  hmm->xt[2][1] = (float )0.;
  hmm->xt[3][0] = (float )0.;
  hmm->xt[3][1] = (float )1.;
  FSet(hmm->begin + 2, hmm->M - 1, (float )0.);
  *(hmm->begin + 1) = (float )(1. - (double )hmm->tbd1);
  FSet(hmm->end + 1, hmm->M - 1, (float )0.);
  *(hmm->end + hmm->M) = (float )1.;
  Plan7RenormalizeExits(hmm);
  hmm->flags &= -2;
  return;
}
}
void Plan7GlobalConfig(struct plan7_s *hmm ) 
{ 


  {
  hmm->xt[0][0] = (float )(1. - (double )hmm->p1);
  hmm->xt[0][1] = hmm->p1;
  hmm->xt[1][0] = (float )1.;
  hmm->xt[1][1] = (float )0.;
  hmm->xt[2][0] = (float )(1. - (double )hmm->p1);
  hmm->xt[2][1] = hmm->p1;
  hmm->xt[3][0] = (float )0.;
  hmm->xt[3][1] = (float )1.;
  FSet(hmm->begin + 2, hmm->M - 1, (float )0.);
  *(hmm->begin + 1) = (float )(1. - (double )hmm->tbd1);
  FSet(hmm->end + 1, hmm->M - 1, (float )0.);
  *(hmm->end + hmm->M) = (float )1.;
  Plan7RenormalizeExits(hmm);
  hmm->flags &= -2;
  return;
}
}
void Plan7LSConfig(struct plan7_s *hmm ) 
{ 


  {
  hmm->xt[0][0] = (float )(1. - (double )hmm->p1);
  hmm->xt[0][1] = hmm->p1;
  hmm->xt[1][0] = (float )0.5;
  hmm->xt[1][1] = (float )0.5;
  hmm->xt[2][0] = (float )(1. - (double )hmm->p1);
  hmm->xt[2][1] = hmm->p1;
  hmm->xt[3][0] = (float )(1. - (double )hmm->p1);
  hmm->xt[3][1] = hmm->p1;
  FSet(hmm->begin + 2, hmm->M - 1, (float )0.);
  *(hmm->begin + 1) = (float )(1. - (double )hmm->tbd1);
  FSet(hmm->end + 1, hmm->M - 1, (float )0.);
  *(hmm->end + hmm->M) = (float )1.;
  Plan7RenormalizeExits(hmm);
  hmm->flags &= -2;
  return;
}
}
void Plan7SWConfig(struct plan7_s *hmm , float pentry , float pexit ) 
{ 
  float basep ;
  int k ;

  {
  hmm->xt[0][0] = (float )1 - hmm->p1;
  hmm->xt[0][1] = hmm->p1;
  hmm->xt[1][0] = (float )1.;
  hmm->xt[1][1] = (float )0.;
  hmm->xt[2][0] = (float )1 - hmm->p1;
  hmm->xt[2][1] = hmm->p1;
  hmm->xt[3][0] = (float )1.;
  hmm->xt[3][1] = (float )0.;
  *(hmm->begin + 1) = (float )((1. - (double )pentry) * (1. - (double )hmm->tbd1));
  FSet(hmm->begin + 2, hmm->M - 1, (float )(((double )pentry * (1. - (double )hmm->tbd1)) / (double )((float )(hmm->M - 1))));
  *(hmm->end + hmm->M) = (float )1.0;
  basep = pexit / (float )(hmm->M - 1);
  k = 1;
  while (k < hmm->M) {
    *(hmm->end + k) = (float )((double )basep / (1. - (double )(basep * (float )(k - 1))));
    k ++;
  }
  Plan7RenormalizeExits(hmm);
  hmm->flags &= -2;
  return;
}
}
void Plan7FSConfig(struct plan7_s *hmm , float pentry , float pexit ) 
{ 
  float basep ;
  int k ;

  {
  hmm->xt[0][0] = (float )1 - hmm->p1;
  hmm->xt[0][1] = hmm->p1;
  hmm->xt[1][0] = (float )0.5;
  hmm->xt[1][1] = (float )0.5;
  hmm->xt[2][0] = (float )1 - hmm->p1;
  hmm->xt[2][1] = hmm->p1;
  hmm->xt[3][0] = (float )(1. - (double )hmm->p1);
  hmm->xt[3][1] = hmm->p1;
  *(hmm->begin + 1) = (float )((1. - (double )pentry) * (1. - (double )hmm->tbd1));
  FSet(hmm->begin + 2, hmm->M - 1, (float )(((double )pentry * (1. - (double )hmm->tbd1)) / (double )((float )(hmm->M - 1))));
  *(hmm->end + hmm->M) = (float )1.0;
  basep = pexit / (float )(hmm->M - 1);
  k = 1;
  while (k < hmm->M) {
    *(hmm->end + k) = (float )((double )basep / (1. - (double )(basep * (float )(k - 1))));
    k ++;
  }
  Plan7RenormalizeExits(hmm);
  hmm->flags &= -2;
  return;
}
}
void Plan7ESTConfig(struct plan7_s *hmm , int *aacode , float **estmodel , float dna2 ,
                    float dna4 ) 
{ 
  int k ;
  int x ;
  float p ;
  float *tripnull ;

  {
  tripnull = (float *)((void *)0);
  hmm->xt[0][0] = (float )(1. / 351.);
  hmm->xt[0][1] = (float )(350. / 351.);
  hmm->xt[1][0] = (float )1.;
  hmm->xt[1][1] = (float )0.;
  hmm->xt[2][0] = (float )(1. / 351.);
  hmm->xt[2][1] = (float )(350. / 351.);
  hmm->xt[3][0] = (float )1.;
  hmm->xt[3][1] = (float )0.;
  *(hmm->begin + 1) = (float )0.5;
  FSet(hmm->begin + 2, hmm->M - 1, (float )(0.5 / ((double )((float )hmm->M) - 1.)));
  *(hmm->end + hmm->M) = (float )1.;
  FSet(hmm->end, hmm->M - 1, (float )(0.5 / ((double )((float )hmm->M) - 1.)));
  k = 1;
  while (k <= hmm->M) {
    x = 0;
    while (x < 64) {
      p = (float )((double )(*(*(hmm->mat + k) + *(aacode + x)) * *(*(estmodel + *(aacode + x)) + x)) * ((1. - (double )dna2) - (double )dna4));
      *(*(hmm->dnam + x) + k) = Prob2Score(p, *(tripnull + x));
      p = (float )((double )(*(*(hmm->ins + k) + *(aacode + x)) * *(*(estmodel + *(aacode + x)) + x)) * ((1. - (double )dna2) - (double )dna4));
      *(*(hmm->dnai + x) + k) = Prob2Score(p, *(tripnull + x));
      x ++;
    }
    *(*(hmm->dnam + 64) + k) = 0;
    hmm->dna2 = Prob2Score(dna2, (float )1.);
    hmm->dna4 = Prob2Score(dna4, (float )1.);
    k ++;
  }
  return;
}
}
void PrintPlan7Stats(FILE *fp , struct plan7_s *hmm , char **dsq , int nseq , struct p7trace_s **tr ) 
{ 
  int idx ;
  float score ;
  float total ;
  float best ;
  float worst ;
  float sqsum ;
  float stddev ;
  double tmp ;

  {
  P7Logoddsify(hmm, 1);
  score = P7TraceScore(hmm, *(dsq + 0), *(tr + 0));
  worst = score;
  best = worst;
  total = best;
  sqsum = score * score;
  idx = 1;
  while (idx < nseq) {
    score = P7TraceScore(hmm, *(dsq + idx), *(tr + idx));
    total += score;
    sqsum += score * score;
    if (score > best) {
      best = score;
    }
    if (score < worst) {
      worst = score;
    }
    idx ++;
  }
  if (nseq > 1) {
    stddev = (float )((double )(sqsum - (total * total) / (float )nseq) / ((double )((float )nseq) - 1.));
    if (stddev > (float )0) {
      tmp = sqrt((double )stddev);
      stddev = (float )tmp;
    } else {
      stddev = (float )0.0;
    }
  } else {
    stddev = (float )0.0;
  }
  fprintf(fp, "Average score:  %10.2f bits\n", (double )(total / (float )nseq));
  fprintf(fp, "Minimum score:  %10.2f bits\n", (double )worst);
  fprintf(fp, "Maximum score:  %10.2f bits\n", (double )best);
  fprintf(fp, "Std. deviation: %10.2f bits\n", (double )stddev);
  return;
}
}
int DegenerateSymbolScore(float *p , float *null , int ambig ) 
{ 
  int x ;
  float numer ;
  float denom ;
  double tmp ;
  double tmp___0 ;

  {
  numer = (float )0.;
  denom = (float )0.;
  x = 0;
  while (x < Alphabet_size) {
    if (Degenerate[ambig][x]) {
      if (*(p + x) / *(null + x) > (float )0) {
        tmp = log((double )(*(p + x) / *(null + x)));
        tmp___0 = tmp * 1.44269504;
      } else {
        tmp___0 = - 9999.;
      }
      numer = (float )((double )numer + (double )*(null + x) * tmp___0);
      denom += *(null + x);
    }
    x ++;
  }
  return ((int )((1000.0 * (double )numer) / (double )denom));
}
}
void Plan9toPlan7(struct plan9_s *hmm , struct plan7_s **ret_plan7 ) 
{ 
  struct plan7_s *plan7 ;
  int k ;
  int x ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  plan7 = AllocPlan7(hmm->M);
  k = 1;
  while (k < hmm->M) {
    *(*(plan7->t + k) + 0) = (hmm->mat + k)->t[0];
    *(*(plan7->t + k) + 2) = (hmm->mat + k)->t[2];
    *(*(plan7->t + k) + 1) = (hmm->mat + k)->t[1];
    *(*(plan7->t + k) + 5) = (hmm->del + k)->t[0];
    *(*(plan7->t + k) + 6) = (hmm->del + k)->t[2];
    *(*(plan7->t + k) + 3) = (hmm->ins + k)->t[0];
    *(*(plan7->t + k) + 4) = (hmm->ins + k)->t[1];
    k ++;
  }
  k = 1;
  while (k <= hmm->M) {
    x = 0;
    while (x < Alphabet_size) {
      *(*(plan7->mat + k) + x) = (hmm->mat + k)->p[x];
      x ++;
    }
    k ++;
  }
  k = 1;
  while (k < hmm->M) {
    x = 0;
    while (x < Alphabet_size) {
      *(*(plan7->ins + k) + x) = (hmm->ins + k)->p[x];
      x ++;
    }
    k ++;
  }
  plan7->tbd1 = (hmm->mat + 0)->t[2] / ((hmm->mat + 0)->t[2] + (hmm->mat + 0)->t[0]);
  P7DefaultNullModel(plan7->null, & plan7->p1);
  x = 0;
  while (x < Alphabet_size) {
    plan7->null[x] = hmm->null[x];
    x ++;
  }
  if ((unsigned long )hmm->name != (unsigned long )((void *)0)) {
    Plan7SetName(plan7, hmm->name);
  }
  if (hmm->flags & 1) {
    tmp___0 = __builtin_object_size((void *)plan7->rf, 0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)plan7->rf, 1);
      __builtin___strcpy_chk(plan7->rf, (char const   *)hmm->ref, tmp);
    } else {
      __inline_strcpy_chk(plan7->rf, (char const   *)hmm->ref);
    }
    plan7->flags |= 1 << 2;
  }
  if (hmm->flags & (1 << 1)) {
    tmp___2 = __builtin_object_size((void *)plan7->cs, 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)plan7->cs, 1);
      __builtin___strcpy_chk(plan7->cs, (char const   *)hmm->cs, tmp___1);
    } else {
      __inline_strcpy_chk(plan7->cs, (char const   *)hmm->cs);
    }
    plan7->flags |= 1 << 3;
  }
  Plan7LSConfig(plan7);
  Plan7Renormalize(plan7);
  plan7->flags |= 1 << 5;
  plan7->flags &= -2;
  *ret_plan7 = plan7;
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-_5rmI1Pe.i","-O3")
float aafq[20] ;
void P9ZeroHMM(struct plan9_s *hmm ) ;
struct plan9_s *P9AllocHMM(int M ) 
{ 
  struct plan9_s *hmm ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  tmp = sre_malloc((char *)"plan9.c", 35, sizeof(struct plan9_s ));
  hmm = (struct plan9_s *)tmp;
  tmp___0 = sre_malloc((char *)"plan9.c", 36, sizeof(struct basic_state ) * (unsigned long )(M + 2));
  hmm->ins = (struct basic_state *)tmp___0;
  tmp___1 = sre_malloc((char *)"plan9.c", 37, sizeof(struct basic_state ) * (unsigned long )(M + 2));
  hmm->del = (struct basic_state *)tmp___1;
  tmp___2 = sre_malloc((char *)"plan9.c", 38, sizeof(struct basic_state ) * (unsigned long )(M + 2));
  hmm->mat = (struct basic_state *)tmp___2;
  tmp___3 = sre_malloc((char *)"plan9.c", 39, (unsigned long )(M + 2) * sizeof(char ));
  hmm->ref = (char *)tmp___3;
  tmp___4 = sre_malloc((char *)"plan9.c", 40, (unsigned long )(M + 2) * sizeof(char ));
  hmm->cs = (char *)tmp___4;
  tmp___5 = sre_malloc((char *)"plan9.c", 41, ((unsigned long )(M + 2) * sizeof(float )) * 4UL);
  hmm->xray = (float *)tmp___5;
  hmm->M = M;
  hmm->name = Strdup((char *)"unnamed");
  hmm->flags = 0;
  P9ZeroHMM(hmm);
  return (hmm);
}
}
int P9FreeHMM(struct plan9_s *hmm ) 
{ 


  {
  if ((unsigned long )hmm == (unsigned long )((void *)0)) {
    return (0);
  }
  free((void *)hmm->ref);
  free((void *)hmm->cs);
  free((void *)hmm->xray);
  free((void *)hmm->name);
  if ((unsigned long )hmm->mat != (unsigned long )((void *)0)) {
    free((void *)hmm->mat);
  }
  if ((unsigned long )hmm->ins != (unsigned long )((void *)0)) {
    free((void *)hmm->ins);
  }
  if ((unsigned long )hmm->del != (unsigned long )((void *)0)) {
    free((void *)hmm->del);
  }
  free((void *)hmm);
  return (1);
}
}
void P9ZeroHMM(struct plan9_s *hmm ) 
{ 
  int k ;
  int ts ;
  int idx ;

  {
  k = 0;
  while (k <= hmm->M + 1) {
    ts = 0;
    while (ts < 3) {
      (hmm->mat + k)->t[ts] = (float )0.0;
      (hmm->ins + k)->t[ts] = (float )0.0;
      (hmm->del + k)->t[ts] = (float )0.0;
      ts ++;
    }
    idx = 0;
    while (idx < Alphabet_size) {
      (hmm->mat + k)->p[idx] = (float )0.0;
      (hmm->ins + k)->p[idx] = (float )0.0;
      (hmm->del + k)->p[idx] = (float )0.0;
      idx ++;
    }
    k ++;
  }
  return;
}
}
void P9Renormalize(struct plan9_s *hmm ) 
{ 
  int k ;

  {
  k = 0;
  while (k <= hmm->M) {
    FNorm((hmm->mat + k)->t, 3);
    FNorm((hmm->ins + k)->t, 3);
    if (k > 0) {
      FNorm((hmm->del + k)->t, 3);
    }
    if (k > 0) {
      FNorm((hmm->mat + k)->p, Alphabet_size);
    }
    FNorm((hmm->ins + k)->p, Alphabet_size);
    k ++;
  }
  return;
}
}
void P9DefaultNullModel(float *null ) 
{ 
  int x ;

  {
  if (Alphabet_type == 3) {
    x = 0;
    while (x < Alphabet_size) {
      *(null + x) = aafq[x];
      x ++;
    }
  } else
  if (Alphabet_type == 2) {
    x = 0;
    while (x < Alphabet_size) {
      *(null + x) = (float )0.25;
      x ++;
    }
  } else {
    Die((char *)"No support for non-protein, non-nucleic acid alphabets.");
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-1SXehOy5.i","-O3")
float P7OptimalAccuracy(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) ;
float P7Backward(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) ;
void P7EmitterPosterior(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                        struct dpmatrix_s *backward , struct dpmatrix_s *mx ) ;
float P7FillOptimalAccuracy(int L , int M , struct dpmatrix_s *posterior , struct dpmatrix_s *mx ,
                            struct p7trace_s **ret_tr ) ;
void P7OptimalAccuracyTrace(int L , int M , struct dpmatrix_s *posterior , struct dpmatrix_s *mx ,
                            struct p7trace_s **ret_tr ) ;
char *PostalCode(int L , struct dpmatrix_s *mx , struct p7trace_s *tr ) ;
float P7OptimalAccuracy(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) 
{ 
  double sc ;
  struct dpmatrix_s *forward ;
  struct dpmatrix_s *backward ;
  float tmp ;

  {
  P7Forward(dsq, L, hmm, & forward);
  P7Backward(dsq, L, hmm, & backward);
  P7EmitterPosterior(L, hmm, forward, backward, backward);
  tmp = P7FillOptimalAccuracy(L, hmm->M, backward, forward, ret_tr);
  sc = (double )tmp;
  FreePlan7Matrix(forward);
  FreePlan7Matrix(backward);
  return ((float )sc);
}
}
float P7Backward(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) 
{ 
  struct dpmatrix_s *mx ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int i___0 ;
  int k ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  float tmp___5 ;

  {
  mx = AllocPlan7Matrix(L + 1, hmm->M, & xmx, & mmx, & imx, & dmx);
  *(*(xmx + L) + 2) = hmm->xsc[2][0];
  *(*(xmx + L) + 1) = *(*(xmx + L) + 2) + hmm->xsc[1][0];
  tmp___0 = -987654321;
  *(*(xmx + L) + 4) = tmp___0;
  tmp = tmp___0;
  *(*(xmx + L) + 0) = tmp;
  *(*(xmx + L) + 3) = tmp;
  k = hmm->M;
  while (k >= 1) {
    *(*(mmx + L) + k) = *(*(xmx + L) + 1) + *(hmm->esc + k);
    *(*(mmx + L) + k) += *(*(hmm->msc + (int )*(dsq + L)) + k);
    tmp___1 = -987654321;
    *(*(dmx + L) + k) = tmp___1;
    *(*(imx + L) + k) = tmp___1;
    k --;
  }
  tmp___2 = -987654321;
  *(*(hmm->tsc + 2) + (hmm->M - 1)) = tmp___2;
  *(*(hmm->tsc + 6) + (hmm->M - 1)) = tmp___2;
  i___0 = L - 1;
  while (i___0 >= 0) {
    *(*(xmx + i___0) + 2) = *(*(xmx + (i___0 + 1)) + 2) + hmm->xsc[2][1];
    *(*(xmx + i___0) + 0) = -987654321;
    *(*(xmx + i___0) + 0) = ILogsum(*(*(xmx + i___0) + 0), *(*(mmx + (i___0 + 1)) + hmm->M) + *(hmm->bsc + (hmm->M - 1)));
    k = hmm->M - 1;
    while (k >= 1) {
      *(*(xmx + i___0) + 0) = ILogsum(*(*(xmx + i___0) + 0), *(*(mmx + (i___0 + 1)) + k) + *(hmm->bsc + k));
      k --;
    }
    *(*(xmx + i___0) + 3) = ILogsum(*(*(xmx + i___0) + 0) + hmm->xsc[3][0], *(*(xmx + (i___0 + 1)) + 3) + hmm->xsc[3][1]);
    *(*(xmx + i___0) + 1) = ILogsum(*(*(xmx + i___0) + 2) + hmm->xsc[1][0], *(*(xmx + i___0) + 3) + hmm->xsc[1][1]);
    *(*(xmx + i___0) + 4) = ILogsum(*(*(xmx + i___0) + 0) + hmm->xsc[0][0], *(*(xmx + (i___0 + 1)) + 4) + hmm->xsc[0][1]);
    if (i___0 > 0) {
      *(*(mmx + i___0) + hmm->M) = (*(*(xmx + i___0) + 1) + *(hmm->esc + hmm->M)) + *(*(hmm->msc + (int )*(dsq + i___0)) + hmm->M);
      *(*(dmx + i___0) + hmm->M) = -987654321;
      k = hmm->M - 1;
      while (k >= 1) {
        tmp___3 = ILogsum(*(*(imx + (i___0 + 1)) + k) + *(*(hmm->tsc + 1) + k), *(*(dmx + i___0) + (k + 1)) + *(*(hmm->tsc + 2) + k));
        tmp___4 = ILogsum(*(*(xmx + i___0) + 1) + *(hmm->esc + k), *(*(mmx + (i___0 + 1)) + (k + 1)) + *(*(hmm->tsc + 0) + k));
        *(*(mmx + i___0) + k) = ILogsum(tmp___4, tmp___3);
        *(*(mmx + i___0) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
        *(*(imx + i___0) + k) = ILogsum(*(*(imx + (i___0 + 1)) + k) + *(*(hmm->tsc + 4) + k),
                                        *(*(mmx + (i___0 + 1)) + (k + 1)) + *(*(hmm->tsc + 3) + k));
        *(*(imx + i___0) + k) += *(*(hmm->isc + (int )*(dsq + i___0)) + k);
        *(*(dmx + i___0) + k) = ILogsum(*(*(dmx + i___0) + (k + 1)) + *(*(hmm->tsc + 6) + k),
                                        *(*(mmx + (i___0 + 1)) + (k + 1)) + *(*(hmm->tsc + 5) + k));
        k --;
      }
    }
    i___0 --;
  }
  sc = *(*(xmx + 0) + 4);
  if ((unsigned long )ret_mx != (unsigned long )((void *)0)) {
    *ret_mx = mx;
  } else {
    FreePlan7Matrix(mx);
  }
  tmp___5 = Scorify(sc);
  return (tmp___5);
}
}
void P7EmitterPosterior(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                        struct dpmatrix_s *backward , struct dpmatrix_s *mx ) 
{ 
  int i___0 ;
  int k ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  sc = *(*(backward->xmx + 0) + 4);
  i___0 = L;
  while (i___0 >= 1) {
    *(*(mx->xmx + i___0) + 2) = ((*(*(forward->xmx + (i___0 - 1)) + 2) + hmm->xsc[2][1]) + *(*(backward->xmx + i___0) + 2)) - sc;
    *(*(mx->xmx + i___0) + 3) = ((*(*(forward->xmx + (i___0 - 1)) + 3) + hmm->xsc[3][1]) + *(*(backward->xmx + i___0) + 3)) - sc;
    *(*(mx->xmx + i___0) + 4) = ((*(*(forward->xmx + (i___0 - 1)) + 4) + hmm->xsc[0][1]) + *(*(backward->xmx + i___0) + 4)) - sc;
    tmp = -987654321;
    *(*(mx->xmx + i___0) + 1) = tmp;
    *(*(mx->xmx + i___0) + 0) = tmp;
    k = 1;
    while (k < hmm->M) {
      *(*(mx->mmx + i___0) + k) = *(*(backward->mmx + i___0) + k);
      tmp___0 = ILogsum(*(*(forward->xmx + (i___0 - 1)) + 0) + *(hmm->bsc + k), *(*(forward->dmx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1)));
      tmp___1 = ILogsum(*(*(forward->mmx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1)),
                        *(*(forward->imx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1)));
      tmp___2 = ILogsum(tmp___1, tmp___0);
      *(*(mx->mmx + i___0) + k) += tmp___2;
      *(*(mx->mmx + i___0) + k) -= sc;
      *(*(mx->imx + i___0) + k) = *(*(backward->imx + i___0) + k);
      tmp___3 = ILogsum(*(*(forward->mmx + (i___0 - 1)) + k) + *(*(hmm->tsc + 1) + k),
                        *(*(forward->imx + (i___0 - 1)) + k) + *(*(hmm->tsc + 4) + k));
      *(*(mx->imx + i___0) + k) += tmp___3;
      *(*(mx->imx + i___0) + k) -= sc;
      *(*(mx->dmx + i___0) + k) = -987654321;
      k ++;
    }
    *(*(mx->mmx + i___0) + hmm->M) = *(*(backward->mmx + i___0) + hmm->M);
    tmp___4 = ILogsum(*(*(forward->xmx + (i___0 - 1)) + 0) + *(hmm->bsc + hmm->M),
                      *(*(forward->dmx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 5) + (hmm->M - 1)));
    tmp___5 = ILogsum(*(*(forward->mmx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 0) + (hmm->M - 1)),
                      *(*(forward->imx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 3) + (hmm->M - 1)));
    tmp___6 = ILogsum(tmp___5, tmp___4);
    *(*(mx->mmx + i___0) + hmm->M) += tmp___6;
    *(*(mx->mmx + i___0) + hmm->M) -= sc;
    tmp___8 = -987654321;
    *(*(mx->dmx + i___0) + 0) = tmp___8;
    tmp___7 = tmp___8;
    *(*(mx->dmx + i___0) + hmm->M) = tmp___7;
    *(*(mx->imx + i___0) + hmm->M) = tmp___7;
    i___0 --;
  }
  return;
}
}
float P7FillOptimalAccuracy(int L , int M , struct dpmatrix_s *posterior , struct dpmatrix_s *mx ,
                            struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int i___0 ;
  int k ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  float tmp___7 ;

  {
  xmx = mx->xmx;
  mmx = mx->mmx;
  imx = mx->imx;
  dmx = mx->dmx;
  tmp___2 = -987654321;
  *(*(xmx + 0) + 3) = tmp___2;
  tmp___1 = tmp___2;
  *(*(xmx + 0) + 2) = tmp___1;
  tmp___0 = tmp___1;
  *(*(xmx + 0) + 1) = tmp___0;
  tmp = tmp___0;
  *(*(xmx + 0) + 0) = tmp;
  *(*(xmx + 0) + 4) = tmp;
  k = 0;
  while (k <= M) {
    tmp___4 = -987654321;
    *(*(dmx + 0) + k) = tmp___4;
    tmp___3 = tmp___4;
    *(*(imx + 0) + k) = tmp___3;
    *(*(mmx + 0) + k) = tmp___3;
    k ++;
  }
  i___0 = 1;
  while (i___0 <= L) {
    tmp___6 = -987654321;
    *(*(dmx + i___0) + 0) = tmp___6;
    tmp___5 = tmp___6;
    *(*(imx + i___0) + 0) = tmp___5;
    *(*(mmx + i___0) + 0) = tmp___5;
    k = 1;
    while (k <= M) {
      *(*(mmx + i___0) + k) = -987654321;
      sc = *(*(mmx + (i___0 - 1)) + (k - 1));
      if (sc > *(*(mmx + i___0) + k)) {
        *(*(mmx + i___0) + k) = sc;
      }
      sc = *(*(imx + (i___0 - 1)) + (k - 1));
      if (sc > *(*(mmx + i___0) + k)) {
        *(*(mmx + i___0) + k) = sc;
      }
      sc = *(*(dmx + (i___0 - 1)) + (k - 1));
      if (sc > *(*(mmx + i___0) + k)) {
        *(*(mmx + i___0) + k) = sc;
      }
      sc = *(*(xmx + (i___0 - 1)) + 0);
      if (sc > *(*(mmx + i___0) + k)) {
        *(*(mmx + i___0) + k) = sc;
      }
      *(*(mmx + i___0) + k) = ILogsum(*(*(mmx + i___0) + k), *(*(posterior->mmx + i___0) + k));
      *(*(dmx + i___0) + k) = -987654321;
      sc = *(*(mmx + i___0) + (k - 1));
      if (sc > *(*(dmx + i___0) + k)) {
        *(*(dmx + i___0) + k) = sc;
      }
      sc = *(*(dmx + i___0) + (k - 1));
      if (sc > *(*(dmx + i___0) + k)) {
        *(*(dmx + i___0) + k) = sc;
      }
      *(*(imx + i___0) + k) = -987654321;
      sc = *(*(mmx + (i___0 - 1)) + k);
      if (sc > *(*(imx + i___0) + k)) {
        *(*(imx + i___0) + k) = sc;
      }
      sc = *(*(imx + (i___0 - 1)) + k);
      if (sc > *(*(imx + i___0) + k)) {
        *(*(imx + i___0) + k) = sc;
      }
      *(*(imx + i___0) + k) = ILogsum(*(*(imx + i___0) + k), *(*(posterior->imx + i___0) + k));
      k ++;
    }
    *(*(xmx + i___0) + 4) = -987654321;
    sc = ILogsum(*(*(xmx + (i___0 - 1)) + 4), *(*(posterior->xmx + i___0) + 4));
    if (sc > -987654321) {
      *(*(xmx + i___0) + 4) = sc;
    }
    *(*(xmx + i___0) + 1) = -987654321;
    k = 1;
    while (k <= M) {
      sc = *(*(mmx + i___0) + k);
      if (sc > *(*(xmx + i___0) + 1)) {
        *(*(xmx + i___0) + 1) = sc;
      }
      k ++;
    }
    *(*(xmx + i___0) + 3) = -987654321;
    sc = ILogsum(*(*(xmx + (i___0 - 1)) + 3), *(*(posterior->xmx + i___0) + 3));
    if (sc > -987654321) {
      *(*(xmx + i___0) + 3) = sc;
    }
    sc = *(*(xmx + i___0) + 1);
    if (sc > *(*(xmx + i___0) + 3)) {
      *(*(xmx + i___0) + 3) = sc;
    }
    *(*(xmx + i___0) + 0) = -987654321;
    sc = *(*(xmx + i___0) + 4);
    if (sc > -987654321) {
      *(*(xmx + i___0) + 0) = sc;
    }
    sc = *(*(xmx + i___0) + 3);
    if (sc > *(*(xmx + i___0) + 0)) {
      *(*(xmx + i___0) + 0) = sc;
    }
    *(*(xmx + i___0) + 2) = -987654321;
    sc = ILogsum(*(*(xmx + (i___0 - 1)) + 2), *(*(posterior->xmx + i___0) + 2));
    if (sc > -987654321) {
      *(*(xmx + i___0) + 2) = sc;
    }
    sc = *(*(xmx + i___0) + 1);
    if (sc > *(*(xmx + i___0) + 2)) {
      *(*(xmx + i___0) + 2) = sc;
    }
    i___0 ++;
  }
  sc = *(*(xmx + L) + 2);
  if ((unsigned long )ret_tr != (unsigned long )((void *)0)) {
    P7OptimalAccuracyTrace(L, M, posterior, mx, & tr);
    *ret_tr = tr;
  }
  tmp___7 = Score2Prob(sc, (float )1);
  return (tmp___7);
}
}
void P7OptimalAccuracyTrace(int L , int M , struct dpmatrix_s *posterior , struct dpmatrix_s *mx ,
                            struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  int curralloc ;
  int tpos ;
  int i___0 ;
  int k ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  curralloc = L * 2 + 6;
  P7AllocTrace(curralloc, & tr);
  xmx = mx->xmx;
  mmx = mx->mmx;
  imx = mx->imx;
  dmx = mx->dmx;
  *(tr->statetype + 0) = (char)9;
  *(tr->nodeidx + 0) = 0;
  *(tr->pos + 0) = 0;
  *(tr->statetype + 1) = (char)8;
  *(tr->nodeidx + 1) = 0;
  *(tr->pos + 1) = 0;
  tpos = 2;
  i___0 = L;
  while ((int )*(tr->statetype + (tpos - 1)) != 4) {
    switch ((int )*(tr->statetype + (tpos - 1))) {
    case 1: 
    sc = *(*(mmx + (i___0 + 1)) + (k + 1));
    tmp___6 = ILogsum(*(*(mmx + i___0) + k), *(*(posterior->mmx + (i___0 + 1)) + (k + 1)));
    if (sc == tmp___6) {
      if (i___0 > 0) {
        if (k > 0) {
          *(tr->statetype + tpos) = (char)1;
          tmp = k;
          k --;
          *(tr->nodeidx + tpos) = tmp;
          tmp___0 = i___0;
          i___0 --;
          *(tr->pos + tpos) = tmp___0;
        } else {
          goto _L___4;
        }
      } else {
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
      tmp___5 = ILogsum(*(*(imx + i___0) + k), *(*(posterior->mmx + (i___0 + 1)) + (k + 1)));
      if (sc == tmp___5) {
        if (i___0 > 0) {
          if (k > 0) {
            *(tr->statetype + tpos) = (char)3;
            *(tr->nodeidx + tpos) = k;
            tmp___1 = i___0;
            i___0 --;
            *(tr->pos + tpos) = tmp___1;
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        tmp___4 = ILogsum(*(*(dmx + i___0) + k), *(*(posterior->mmx + (i___0 + 1)) + (k + 1)));
        if (sc == tmp___4) {
          if (i___0 > 0) {
            if (k > 1) {
              *(tr->statetype + tpos) = (char)2;
              tmp___2 = k;
              k --;
              *(tr->nodeidx + tpos) = tmp___2;
              *(tr->pos + tpos) = 0;
            } else {
              goto _L___0;
            }
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          tmp___3 = ILogsum(*(*(xmx + i___0) + 0), *(*(posterior->mmx + (i___0 + 1)) + (k + 1)));
          if (sc == tmp___3) {
            *(tr->statetype + tpos) = (char)6;
            *(tr->nodeidx + tpos) = 0;
            *(tr->pos + tpos) = 0;
          } else {
            Die((char *)"traceback failed");
          }
        }
      }
    }
    break;
    case 2: 
    if (*(*(dmx + i___0) + (k + 1)) == *(*(mmx + i___0) + k)) {
      if (i___0 > 0) {
        if (k > 0) {
          *(tr->statetype + tpos) = (char)1;
          tmp___7 = k;
          k --;
          *(tr->nodeidx + tpos) = tmp___7;
          tmp___8 = i___0;
          i___0 --;
          *(tr->pos + tpos) = tmp___8;
        } else {
          goto _L___6;
        }
      } else {
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
    if (*(*(dmx + i___0) + (k + 1)) == *(*(dmx + i___0) + k)) {
      if (k > 1) {
        *(tr->statetype + tpos) = (char)2;
        tmp___9 = k;
        k --;
        *(tr->nodeidx + tpos) = tmp___9;
        *(tr->pos + tpos) = 0;
      } else {
        Die((char *)"traceback failed");
      }
    } else {
      Die((char *)"traceback failed");
    }
    break;
    case 3: 
    sc = *(*(imx + (i___0 + 1)) + k);
    tmp___14 = ILogsum(*(*(mmx + i___0) + k), *(*(posterior->imx + (i___0 + 1)) + k));
    if (sc == tmp___14) {
      if (i___0 > 0) {
        if (k > 0) {
          *(tr->statetype + tpos) = (char)1;
          tmp___10 = k;
          k --;
          *(tr->nodeidx + tpos) = tmp___10;
          tmp___11 = i___0;
          i___0 --;
          *(tr->pos + tpos) = tmp___11;
        } else {
          goto _L___8;
        }
      } else {
        goto _L___8;
      }
    } else {
      _L___8: /* CIL Label */ 
      tmp___13 = ILogsum(*(*(imx + i___0) + k), *(*(posterior->imx + (i___0 + 1)) + k));
      if (sc == tmp___13) {
        if (i___0 > 0) {
          if (k > 0) {
            *(tr->statetype + tpos) = (char)3;
            *(tr->nodeidx + tpos) = k;
            tmp___12 = i___0;
            i___0 --;
            *(tr->pos + tpos) = tmp___12;
          } else {
            Die((char *)"traceback failed");
          }
        } else {
          Die((char *)"traceback failed");
        }
      } else {
        Die((char *)"traceback failed");
      }
    }
    break;
    case 5: 
    if (i___0 == 0) {
      if (*(*(xmx + i___0) + 4) == -987654321) {
        *(tr->statetype + tpos) = (char)4;
        *(tr->nodeidx + tpos) = 0;
        *(tr->pos + tpos) = 0;
      } else {
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
    if (i___0 > 0) {
      tmp___16 = ILogsum(*(*(xmx + i___0) + 4), *(*(posterior->xmx + (i___0 + 1)) + 4));
      if (*(*(xmx + (i___0 + 1)) + 4) == tmp___16) {
        if (i___0 > 0) {
          *(tr->statetype + tpos) = (char)5;
          *(tr->nodeidx + tpos) = 0;
          *(tr->pos + tpos) = 0;
          tmp___15 = i___0;
          i___0 --;
          *(tr->pos + (tpos - 1)) = tmp___15;
        } else {
          Die((char *)"traceback failed");
        }
      } else {
        Die((char *)"traceback failed");
      }
    } else {
      Die((char *)"traceback failed");
    }
    break;
    case 6: 
    if (*(*(xmx + i___0) + 0) == *(*(xmx + i___0) + 4)) {
      *(tr->statetype + tpos) = (char)5;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
    } else
    if (*(*(xmx + i___0) + 0) == *(*(xmx + i___0) + 3)) {
      *(tr->statetype + tpos) = (char)10;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
    } else {
      Die((char *)"traceback failed");
    }
    break;
    case 7: 
    k = M;
    while (k >= 1) {
      if (*(*(xmx + i___0) + 1) == *(*(mmx + i___0) + k)) {
        if (i___0 > 0) {
          *(tr->statetype + tpos) = (char)1;
          tmp___17 = k;
          k --;
          *(tr->nodeidx + tpos) = tmp___17;
          tmp___18 = i___0;
          i___0 --;
          *(tr->pos + tpos) = tmp___18;
          break;
        }
      }
      k --;
    }
    if (k <= 0) {
      Die((char *)"traceback failed");
    }
    break;
    case 8: 
    tmp___20 = ILogsum(*(*(xmx + (i___0 - 1)) + 2), *(*(posterior->xmx + i___0) + 2));
    if (*(*(xmx + i___0) + 2) == tmp___20) {
      if (i___0 > 0) {
        *(tr->statetype + tpos) = (char)8;
        *(tr->nodeidx + tpos) = 0;
        *(tr->pos + tpos) = 0;
        tmp___19 = i___0;
        i___0 --;
        *(tr->pos + (tpos - 1)) = tmp___19;
      } else {
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
    if (*(*(xmx + i___0) + 2) == *(*(xmx + i___0) + 1)) {
      *(tr->statetype + tpos) = (char)7;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
    } else {
      Die((char *)"Traceback failed.");
    }
    break;
    case 10: 
    tmp___22 = ILogsum(*(*(xmx + (i___0 - 1)) + 3), *(*(posterior->xmx + i___0) + 3));
    if (*(*(xmx + i___0) + 3) == tmp___22) {
      if (i___0 > 0) {
        *(tr->statetype + tpos) = (char)10;
        *(tr->nodeidx + tpos) = 0;
        *(tr->pos + tpos) = 0;
        tmp___21 = i___0;
        i___0 --;
        *(tr->pos + (tpos - 1)) = tmp___21;
      } else {
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
    if (*(*(xmx + i___0) + 3) == *(*(xmx + i___0) + 1)) {
      *(tr->statetype + tpos) = (char)7;
      *(tr->nodeidx + tpos) = 0;
      *(tr->pos + tpos) = 0;
    } else {
      Die((char *)"Traceback failed.");
    }
    break;
    default: 
    Die((char *)"traceback failed");
    }
    tpos ++;
    if (tpos == curralloc) {
      curralloc += L;
      P7ReallocTrace(tr, curralloc);
    }
  }
  tr->tlen = tpos;
  P7ReverseTrace(tr);
  *ret_tr = tr;
  return;
}
}
static char score2postcode(int sc ) 
{ 
  char i___0 ;
  float tmp ;
  int tmp___0 ;

  {
  tmp = Score2Prob(sc, (float )1.);
  i___0 = (char )((double )tmp * 10.);
  if ((int )i___0 > 9) {
    tmp___0 = '*';
  } else {
    tmp___0 = 48 + (int )i___0;
  }
  return ((char )tmp___0);
}
}
char *PostalCode(int L , struct dpmatrix_s *mx , struct p7trace_s *tr ) 
{ 
  int tpos ;
  int i___0 ;
  int k ;
  char *postcode ;
  void *tmp ;

  {
  tmp = sre_malloc((char *)"postprob.c", 692, (unsigned long )(L + 1) * sizeof(char ));
  postcode = (char *)tmp;
  tpos = 0;
  while (tpos < tr->tlen) {
    i___0 = *(tr->pos + tpos);
    k = *(tr->nodeidx + tpos);
    if (i___0 == 0) {
      goto __Cont;
    }
    switch ((int )*(tr->statetype + tpos)) {
    case 1: 
    *(postcode + (i___0 - 1)) = score2postcode(*(*(mx->mmx + i___0) + k));
    break;
    case 3: 
    *(postcode + (i___0 - 1)) = score2postcode(*(*(mx->imx + i___0) + k));
    break;
    case 5: 
    *(postcode + (i___0 - 1)) = score2postcode(*(*(mx->xmx + i___0) + 4));
    break;
    case 8: 
    *(postcode + (i___0 - 1)) = score2postcode(*(*(mx->xmx + i___0) + 2));
    break;
    case 10: 
    *(postcode + (i___0 - 1)) = score2postcode(*(*(mx->xmx + i___0) + 3));
    break;
    }
    __Cont: /* CIL Label */ 
    tpos ++;
  }
  *(postcode + L) = (char )'\000';
  return (postcode);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-b_HJOtdd.i","-O3")
int ParsePAMFile(FILE *fp , int ***ret_pam , float *ret_scale ) ;
void Free2DArray(void **p , int dim1 ) ;
struct p7prior_s *P7AllocPrior(void) ;
struct p7prior_s *P7LaplacePrior(void) ;
struct p7prior_s *P7DefaultPrior(void) ;
struct p7prior_s *P7ReadPrior(char *prifile ) ;
void P7FreePrior(struct p7prior_s *pri ) ;
void PAMPrior(char *pamfile , struct p7prior_s *pri , float wt ) ;
void P7ReadNullModel(char *rndfile , float *null , float *ret_p1 ) ;
void P7PriorifyHMM(struct plan7_s *hmm , struct p7prior_s *pri ) ;
static struct p7prior_s *default_amino_prior(void) ;
static struct p7prior_s *default_nucleic_prior(void) ;
struct p7prior_s *P7AllocPrior(void) 
{ 
  void *tmp ;

  {
  tmp = sre_malloc((char *)"prior.c", 37, sizeof(struct p7prior_s ));
  return ((struct p7prior_s *)tmp);
}
}
void P7FreePrior(struct p7prior_s *pri ) 
{ 


  {
  free((void *)pri);
  return;
}
}
struct p7prior_s *P7LaplacePrior(void) 
{ 
  struct p7prior_s *pri ;

  {
  pri = P7AllocPrior();
  pri->strategy = 0;
  pri->tnum = 1;
  pri->tq[0] = (float )1.;
  FSet(pri->t[0], 8, (float )1.);
  pri->mnum = 1;
  pri->mq[0] = (float )1.;
  FSet(pri->m[0], Alphabet_size, (float )1.);
  pri->inum = 1;
  pri->iq[0] = (float )1.;
  FSet(pri->i[0], Alphabet_size, (float )1.);
  return (pri);
}
}
struct p7prior_s *P7DefaultPrior(void) 
{ 
  struct p7prior_s *tmp ;
  struct p7prior_s *tmp___0 ;

  {
  switch (Alphabet_type) {
  case 3: 
  tmp = default_amino_prior();
  return (tmp);
  case 2: 
  tmp___0 = default_nucleic_prior();
  return (tmp___0);
  case 0: 
  Die((char *)"Can\'t set prior; alphabet type not set yet");
  }
  return ((struct p7prior_s *)((void *)0));
}
}
struct p7prior_s *P7ReadPrior(char *prifile ) 
{ 
  FILE *fp ;
  struct p7prior_s *pri ;
  char *sptr___0 ;
  int q ;
  int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  double tmp___4 ;
  char *tmp___5 ;
  double tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  double tmp___9 ;
  char *tmp___10 ;
  double tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  double tmp___14 ;
  char *tmp___15 ;
  double tmp___16 ;

  {
  fp = fopen((char const   *)prifile, "r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    Die((char *)"Failed to open HMMER prior file %s\n", prifile);
  }
  pri = P7AllocPrior();
  sptr___0 = Getword(fp, 4);
  s2upper(sptr___0);
  tmp = strcmp((char const   *)sptr___0, "DIRICHLET");
  if (tmp == 0) {
    pri->strategy = 0;
  } else {
    Die((char *)"No such prior strategy %s; failed to parse file %s", sptr___0, prifile);
  }
  sptr___0 = Getword(fp, 4);
  s2upper(sptr___0);
  tmp___1 = strcmp((char const   *)sptr___0, "AMINO");
  if (tmp___1 == 0) {
    if (Alphabet_type != 3) {
      Die((char *)"HMM and/or sequences are DNA/RNA; can\'t use protein prior %s",
          prifile);
    }
  } else {
    tmp___0 = strcmp((char const   *)sptr___0, "NUCLEIC");
    if (tmp___0 == 0) {
      if (Alphabet_type != 2) {
        Die((char *)"HMM and/or sequences are protein; can\'t use DNA/RNA prior %s",
            prifile);
      }
    } else {
      Die((char *)"Alphabet \"%s\" in prior file %s isn\'t valid.", sptr___0, prifile);
    }
  }
  tmp___2 = Getword(fp, 1);
  pri->tnum = atoi((char const   *)tmp___2);
  if (pri->tnum < 0) {
    Die((char *)"%d is bad; need at least one state transition mixture component",
        pri->tnum);
  }
  if (pri->tnum > 200) {
    Die((char *)"%d is bad, too many transition components (MAXDCHLET = %d)\n", 200);
  }
  q = 0;
  while (q < pri->tnum) {
    tmp___3 = Getword(fp, 2);
    tmp___4 = atof((char const   *)tmp___3);
    pri->tq[q] = (float )tmp___4;
    x = 0;
    while (x < 7) {
      tmp___5 = Getword(fp, 2);
      tmp___6 = atof((char const   *)tmp___5);
      pri->t[q][x] = (float )tmp___6;
      x ++;
    }
    q ++;
  }
  tmp___7 = Getword(fp, 1);
  pri->mnum = atoi((char const   *)tmp___7);
  if (pri->mnum < 0) {
    Die((char *)"%d is bad; need at least one match emission mixture component", pri->mnum);
  }
  if (pri->mnum > 200) {
    Die((char *)"%d is bad; too many match components (MAXDCHLET = %d)\n", pri->mnum,
        200);
  }
  q = 0;
  while (q < pri->mnum) {
    tmp___8 = Getword(fp, 2);
    tmp___9 = atof((char const   *)tmp___8);
    pri->mq[q] = (float )tmp___9;
    x = 0;
    while (x < Alphabet_size) {
      tmp___10 = Getword(fp, 2);
      tmp___11 = atof((char const   *)tmp___10);
      pri->m[q][x] = (float )tmp___11;
      x ++;
    }
    q ++;
  }
  tmp___12 = Getword(fp, 1);
  pri->inum = atoi((char const   *)tmp___12);
  if (pri->inum < 0) {
    Die((char *)"%d is bad; need at least one insert emission mixture component",
        pri->inum);
  }
  if (pri->inum > 200) {
    Die((char *)"%d is bad; too many insert components (MAXDCHLET = %d)\n", pri->inum,
        200);
  }
  q = 0;
  while (q < pri->inum) {
    tmp___13 = Getword(fp, 2);
    tmp___14 = atof((char const   *)tmp___13);
    pri->iq[q] = (float )tmp___14;
    x = 0;
    while (x < Alphabet_size) {
      tmp___15 = Getword(fp, 2);
      tmp___16 = atof((char const   *)tmp___15);
      pri->i[q][x] = (float )tmp___16;
      x ++;
    }
    q ++;
  }
  fclose(fp);
  return (pri);
}
}
void PAMPrior(char *pamfile , struct p7prior_s *pri , float wt ) 
{ 
  FILE *fp ;
  char *blastpamfile ;
  int **pam ;
  float scale ;
  int xi ;
  int xj ;
  int idx1 ;
  int idx2 ;
  int tmp ;
  double tmp___0 ;

  {
  if (Alphabet_type != 3) {
    Die((char *)"PAM prior is only valid for protein sequences");
  }
  if (pri->strategy != 0) {
    Die((char *)"PAM prior may only be applied over an existing Dirichlet prior");
  }
  if (pri->inum != 1) {
    Die((char *)"PAM prior requires that the insert emissions be a single Dirichlet");
  }
  blastpamfile = FileConcat((char *)"aa", pamfile);
  fp = fopen((char const   *)pamfile, "r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    fp = EnvFileOpen(pamfile, (char *)"BLASTMAT", (char **)((void *)0));
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      fp = EnvFileOpen(blastpamfile, (char *)"BLASTMAT", (char **)((void *)0));
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
        Die((char *)"Failed to open PAM scoring matrix file %s", pamfile);
      }
    }
  }
  tmp = ParsePAMFile(fp, & pam, & scale);
  if (! tmp) {
    Die((char *)"Failed to parse PAM scoring matrix file %s", pamfile);
  }
  fclose(fp);
  free((void *)blastpamfile);
  pri->strategy = 1;
  pri->mnum = 20;
  xi = 0;
  while (xi < Alphabet_size) {
    xj = 0;
    while (xj < Alphabet_size) {
      idx1 = (int )Alphabet[xi] - 65;
      idx2 = (int )Alphabet[xj] - 65;
      tmp___0 = exp((double )((float )*(*(pam + idx1) + idx2) * scale));
      pri->m[xi][xj] = (float )((double )aafq[xj] * tmp___0);
      xj ++;
    }
    xi ++;
  }
  xi = 0;
  while (xi < Alphabet_size) {
    pri->mq[xi] = (float )(1. / (double )Alphabet_size);
    FNorm(pri->m[xi], Alphabet_size);
    FScale(pri->m[xi], Alphabet_size, wt);
    xi ++;
  }
  Free2DArray((void **)pam, 27);
  return;
}
}
void P7DefaultNullModel(float *null , float *ret_p1 ) 
{ 
  int x ;

  {
  if (Alphabet_type == 3) {
    x = 0;
    while (x < Alphabet_size) {
      *(null + x) = aafq[x];
      x ++;
    }
    *ret_p1 = (float )(350. / 351.);
  } else {
    x = 0;
    while (x < Alphabet_size) {
      *(null + x) = (float )(1.0 / (double )((float )Alphabet_size));
      x ++;
    }
    *ret_p1 = (float )(1000. / 1001.);
  }
  return;
}
}
void P7ReadNullModel(char *rndfile , float *null , float *ret_p1 ) 
{ 
  FILE *fp ;
  char *s___0 ;
  int x ;
  int type ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  type = 0;
  fp = fopen((char const   *)rndfile, "r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    Die((char *)"Failed to open null model file %s\n", rndfile);
  }
  s___0 = Getword(fp, 4);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  s2upper(s___0);
  tmp___0 = strcmp((char const   *)s___0, "NUCLEIC");
  if (tmp___0 == 0) {
    type = 2;
  } else {
    tmp = strcmp((char const   *)s___0, "AMINO");
    if (tmp == 0) {
      type = 3;
    } else {
      goto FAILURE;
    }
  }
  if (Alphabet_type == 0) {
    SetAlphabet(type);
  } else
  if (Alphabet_type != type) {
    Die((char *)"Alphabet type conflict; null model in %s is inappropriate\n", rndfile);
  }
  x = 0;
  while (x < Alphabet_size) {
    s___0 = Getword(fp, 2);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      goto FAILURE;
    }
    tmp___1 = atof((char const   *)s___0);
    *(null + x) = (float )tmp___1;
    x ++;
  }
  s___0 = Getword(fp, 2);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  tmp___2 = atof((char const   *)s___0);
  *ret_p1 = (float )tmp___2;
  fclose(fp);
  return;
  FAILURE: 
  fclose(fp);
  Die((char *)"%s is not in HMMER null model file format", rndfile);
  return;
}
}
void P7PriorifyHMM(struct plan7_s *hmm , struct p7prior_s *pri ) 
{ 
  int k ;
  float d___0 ;
  float tq[200] ;
  float mq[200] ;
  float iq[200] ;

  {
  FSet(hmm->begin + 2, hmm->M - 1, (float )0.);
  FSet(hmm->end + 1, hmm->M - 1, (float )0.);
  d___0 = (float )((double )(hmm->tbd1 + *(hmm->begin + 1)) + 2.);
  hmm->tbd1 = (float )(((double )hmm->tbd1 + 1.) / (double )d___0);
  *(hmm->begin + 1) = (float )(((double )*(hmm->begin + 1) + 1.) / (double )d___0);
  *(hmm->end + hmm->M) = (float )1.0;
  k = 1;
  while (k < hmm->M) {
    if ((unsigned long )hmm->tpri != (unsigned long )((void *)0)) {
      if (*(hmm->tpri + k) >= 0) {
        if (*(hmm->tpri + k) >= pri->tnum) {
          Die((char *)"X-PRT annotation out of range");
        }
        FSet(tq, pri->tnum, (float )0.0);
        tq[*(hmm->tpri + k)] = (float )1.0;
      } else {
        FCopy(tq, pri->tq, pri->tnum);
      }
    } else {
      FCopy(tq, pri->tq, pri->tnum);
    }
    if ((unsigned long )hmm->mpri != (unsigned long )((void *)0)) {
      if (*(hmm->mpri + k) >= 0) {
        if (*(hmm->mpri + k) >= pri->mnum) {
          Die((char *)"X-PRM annotation out of range");
        }
        FSet(mq, pri->mnum, (float )0.0);
        mq[*(hmm->mpri + k)] = (float )1.0;
      } else {
        FCopy(mq, pri->mq, pri->mnum);
      }
    } else {
      FCopy(mq, pri->mq, pri->mnum);
    }
    if ((unsigned long )hmm->ipri != (unsigned long )((void *)0)) {
      if (*(hmm->ipri + k) >= 0) {
        if (*(hmm->ipri + k) >= pri->inum) {
          Die((char *)"X-PRI annotation out of range");
        }
        FSet(iq, pri->inum, (float )0.0);
        iq[*(hmm->ipri + k)] = (float )1.0;
      } else {
        FCopy(iq, pri->iq, pri->inum);
      }
    } else {
      FCopy(iq, pri->iq, pri->inum);
    }
    P7PriorifyTransitionVector(*(hmm->t + k), pri, (float *)(tq));
    P7PriorifyEmissionVector(*(hmm->mat + k), pri, pri->mnum, (float *)(mq), (float (*)[20])(pri->m),
                             (float *)((void *)0));
    P7PriorifyEmissionVector(*(hmm->ins + k), pri, pri->inum, (float *)(iq), (float (*)[20])(pri->i),
                             (float *)((void *)0));
    k ++;
  }
  if ((unsigned long )hmm->mpri != (unsigned long )((void *)0)) {
    if (*(hmm->mpri + hmm->M) >= 0) {
      if (*(hmm->mpri + hmm->M) >= pri->mnum) {
        Die((char *)"X-PRM annotation out of range");
      }
      FSet(mq, pri->mnum, (float )0.0);
      mq[*(hmm->mpri + hmm->M)] = (float )1.0;
    } else {
      FCopy(mq, pri->mq, pri->mnum);
    }
  } else {
    FCopy(mq, pri->mq, pri->mnum);
  }
  P7PriorifyEmissionVector(*(hmm->mat + hmm->M), pri, pri->mnum, (float *)(mq), (float (*)[20])(pri->m),
                           (float *)((void *)0));
  Plan7Renormalize(hmm);
  return;
}
}
void P7PriorifyEmissionVector(float *vec , struct p7prior_s *pri , int num , float *eq ,
                              float (*e)[20] , float *ret_mix ) 
{ 
  int x ;
  int q ;
  float mix[200] ;
  float totc ;
  float tota ;
  float xi ;
  double tmp ;
  float tmp___0 ;

  {
  mix[0] = (float )1.0;
  if (pri->strategy == 0) {
    if (num > 1) {
      q = 0;
      while (q < num) {
        if ((double )*(eq + q) > 0.0) {
          tmp = log((double )*(eq + q));
          mix[q] = (float )tmp;
        } else {
          mix[q] = (float )(- 999.);
        }
        tmp___0 = Logp_cvec(vec, Alphabet_size, *(e + q));
        mix[q] += tmp___0;
        q ++;
      }
      LogNorm(mix, num);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (pri->strategy == 1) {
    if (num > 1) {
      q = 0;
      while (q < Alphabet_size) {
        mix[q] = *(vec + q);
        q ++;
      }
      FNorm(mix, Alphabet_size);
    }
  }
  totc = FSum(vec, Alphabet_size);
  x = 0;
  while (x < Alphabet_size) {
    xi = (float )0.0;
    q = 0;
    while (q < num) {
      tota = FSum(*(e + q), Alphabet_size);
      xi += (mix[q] * (*(vec + x) + (*(e + q))[x])) / (totc + tota);
      q ++;
    }
    *(vec + x) = xi;
    x ++;
  }
  FNorm(vec, Alphabet_size);
  if ((unsigned long )ret_mix != (unsigned long )((void *)0)) {
    q = 0;
    while (q < num) {
      *(ret_mix + q) = mix[q];
      q ++;
    }
  }
  return;
}
}
void P7PriorifyTransitionVector(float *t___0 , struct p7prior_s *prior , float *tq ) 
{ 
  int ts ;
  int q ;
  float mix[200] ;
  float totm ;
  float totd ;
  float toti ;
  float xi ;
  double tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;

  {
  mix[0] = (float )1.0;
  if (prior->strategy == 0) {
    goto _L;
  } else
  if (prior->strategy == 1) {
    _L: /* CIL Label */ 
    if (prior->mnum > 1) {
      q = 0;
      while (q < prior->tnum) {
        if ((double )*(tq + q) > 0.0) {
          tmp = log((double )*(tq + q));
          mix[q] = (float )tmp;
        } else {
          mix[q] = (float )(- 999.);
        }
        tmp___0 = Logp_cvec(t___0, 3, prior->t[q]);
        mix[q] += tmp___0;
        tmp___1 = Logp_cvec(t___0 + 3, 2, prior->t[q] + 3);
        mix[q] += tmp___1;
        tmp___2 = Logp_cvec(t___0 + 5, 2, prior->t[q] + 5);
        mix[q] += tmp___2;
        q ++;
      }
      LogNorm(mix, prior->tnum);
    }
  }
  totm = FSum(t___0, 3);
  toti = *(t___0 + 3) + *(t___0 + 4);
  totd = *(t___0 + 5) + *(t___0 + 6);
  ts = 0;
  while (ts < 7) {
    xi = (float )0.0;
    q = 0;
    while (q < prior->tnum) {
      switch (ts) {
      case 2: 
      case 1: 
      case 0: 
      tmp___3 = FSum(prior->t[q], 3);
      xi += (mix[q] * (*(t___0 + ts) + prior->t[q][ts])) / (totm + tmp___3);
      break;
      case 4: 
      case 3: 
      xi += (mix[q] * (*(t___0 + ts) + prior->t[q][ts])) / ((toti + prior->t[q][3]) + prior->t[q][4]);
      break;
      case 6: 
      case 5: 
      xi += (mix[q] * (*(t___0 + ts) + prior->t[q][ts])) / ((totd + prior->t[q][5]) + prior->t[q][6]);
      break;
      }
      q ++;
    }
    *(t___0 + ts) = xi;
    ts ++;
  }
  FNorm(t___0, 3);
  FNorm(t___0 + 3, 2);
  FNorm(t___0 + 5, 2);
  return;
}
}
static float defmq[9]  = 
  {      (float )0.178091,      (float )0.056591,      (float )0.0960191,      (float )0.0781233, 
        (float )0.0834977,      (float )0.0904123,      (float )0.114468,      (float )0.0682132, 
        (float )0.234585};
static float defm[9][20]  = 
  { {        (float )0.270671,        (float )0.039848,        (float )0.017576,        (float )0.016415, 
            (float )0.014268,        (float )0.131916,        (float )0.012391,        (float )0.022599, 
            (float )0.020358,        (float )0.030727,        (float )0.015315,        (float )0.048298, 
            (float )0.053803,        (float )0.020662,        (float )0.023612,        (float )0.216147, 
            (float )0.147226,        (float )0.065438,        (float )0.003758,        (float )0.009621}, 
   {        (float )0.021465,        (float )0.010300,        (float )0.011741,        (float )0.010883, 
            (float )0.385651,        (float )0.016416,        (float )0.076196,        (float )0.035329, 
            (float )0.013921,        (float )0.093517,        (float )0.022034,        (float )0.028593, 
            (float )0.013086,        (float )0.023011,        (float )0.018866,        (float )0.029156, 
            (float )0.018153,        (float )0.036100,        (float )0.071770,        (float )0.419641}, 
   {        (float )0.561459,        (float )0.045448,        (float )0.438366,        (float )0.764167, 
            (float )0.087364,        (float )0.259114,        (float )0.214940,        (float )0.145928, 
            (float )0.762204,        (float )0.247320,        (float )0.118662,        (float )0.441564, 
            (float )0.174822,        (float )0.530840,        (float )0.465529,        (float )0.583402, 
            (float )0.445586,        (float )0.227050,        (float )0.029510,        (float )0.121090}, 
   {        (float )0.070143,        (float )0.011140,        (float )0.019479,        (float )0.094657, 
            (float )0.013162,        (float )0.048038,        (float )0.077000,        (float )0.032939, 
            (float )0.576639,        (float )0.072293,        (float )0.028240,        (float )0.080372, 
            (float )0.037661,        (float )0.185037,        (float )0.506783,        (float )0.073732, 
            (float )0.071587,        (float )0.042532,        (float )0.011254,        (float )0.028723}, 
   {        (float )0.041103,        (float )0.014794,        (float )0.005610,        (float )0.010216, 
            (float )0.153602,        (float )0.007797,        (float )0.007175,        (float )0.299635, 
            (float )0.010849,        (float )0.999446,        (float )0.210189,        (float )0.006127, 
            (float )0.013021,        (float )0.019798,        (float )0.014509,        (float )0.012049, 
            (float )0.035799,        (float )0.180085,        (float )0.012744,        (float )0.026466}, 
   {        (float )0.115607,        (float )0.037381,        (float )0.012414,        (float )0.018179, 
            (float )0.051778,        (float )0.017255,        (float )0.004911,        (float )0.796882, 
            (float )0.017074,        (float )0.285858,        (float )0.075811,        (float )0.014548, 
            (float )0.015092,        (float )0.011382,        (float )0.012696,        (float )0.027535, 
            (float )0.088333,        (float )0.944340,        (float )0.004373,        (float )0.016741}, 
   {        (float )0.093461,        (float )0.004737,        (float )0.387252,        (float )0.347841, 
            (float )0.010822,        (float )0.105877,        (float )0.049776,        (float )0.014963, 
            (float )0.094276,        (float )0.027761,        (float )0.010040,        (float )0.187869, 
            (float )0.050018,        (float )0.110039,        (float )0.038668,        (float )0.119471, 
            (float )0.065802,        (float )0.025430,        (float )0.003215,        (float )0.018742}, 
   {        (float )0.452171,        (float )0.114613,        (float )0.062460,        (float )0.115702, 
            (float )0.284246,        (float )0.140204,        (float )0.100358,        (float )0.550230, 
            (float )0.143995,        (float )0.700649,        (float )0.276580,        (float )0.118569, 
            (float )0.097470,        (float )0.126673,        (float )0.143634,        (float )0.278983, 
            (float )0.358482,        (float )0.661750,        (float )0.061533,        (float )0.199373}, 
   {        (float )0.005193,        (float )0.004039,        (float )0.006722,        (float )0.006121, 
            (float )0.003468,        (float )0.016931,        (float )0.003647,        (float )0.002184, 
            (float )0.005019,        (float )0.005990,        (float )0.001473,        (float )0.004158, 
            (float )0.009055,        (float )0.003630,        (float )0.006583,        (float )0.003172, 
            (float )0.003690,        (float )0.002967,        (float )0.002772,        (float )0.002686}};
static struct p7prior_s *default_amino_prior(void) 
{ 
  struct p7prior_s *pri ;
  int q ;
  int x ;

  {
  pri = P7AllocPrior();
  pri->strategy = 0;
  pri->tnum = 1;
  pri->tq[0] = (float )1.0;
  pri->t[0][0] = (float )0.7939;
  pri->t[0][1] = (float )0.0278;
  pri->t[0][2] = (float )0.0135;
  pri->t[0][3] = (float )0.1551;
  pri->t[0][4] = (float )0.1331;
  pri->t[0][5] = (float )0.9002;
  pri->t[0][6] = (float )0.5630;
  pri->mnum = 9;
  q = 0;
  while (q < pri->mnum) {
    pri->mq[q] = defmq[q];
    x = 0;
    while (x < 20) {
      pri->m[q][x] = defm[q][x];
      x ++;
    }
    q ++;
  }
  pri->inum = 1;
  pri->iq[0] = (float )1.;
  pri->i[0][0] = (float )681.;
  pri->i[0][1] = (float )120.;
  pri->i[0][2] = (float )623.;
  pri->i[0][3] = (float )651.;
  pri->i[0][4] = (float )313.;
  pri->i[0][5] = (float )902.;
  pri->i[0][6] = (float )241.;
  pri->i[0][7] = (float )371.;
  pri->i[0][8] = (float )687.;
  pri->i[0][9] = (float )676.;
  pri->i[0][10] = (float )143.;
  pri->i[0][11] = (float )548.;
  pri->i[0][12] = (float )647.;
  pri->i[0][13] = (float )415.;
  pri->i[0][14] = (float )551.;
  pri->i[0][15] = (float )926.;
  pri->i[0][16] = (float )623.;
  pri->i[0][17] = (float )505.;
  pri->i[0][18] = (float )102.;
  pri->i[0][19] = (float )269.;
  return (pri);
}
}
static struct p7prior_s *default_nucleic_prior(void) 
{ 
  struct p7prior_s *pri ;

  {
  pri = P7AllocPrior();
  pri->strategy = 0;
  pri->tnum = 1;
  pri->tq[0] = (float )1.;
  pri->t[0][0] = (float )0.7939;
  pri->t[0][1] = (float )0.0278;
  pri->t[0][2] = (float )0.0135;
  pri->t[0][3] = (float )0.1551;
  pri->t[0][4] = (float )0.1331;
  pri->t[0][5] = (float )0.9002;
  pri->t[0][6] = (float )0.5630;
  pri->mnum = 1;
  pri->mq[0] = (float )1.;
  FSet(pri->m[0], Alphabet_size, (float )1.);
  pri->inum = 1;
  pri->iq[0] = (float )1.;
  FSet(pri->i[0], Alphabet_size, (float )1.);
  return (pri);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-ivPfjd8A.i","-O3")
void GrowTophits(struct tophit_s *h___0 ) ;
struct fancyali_s *AllocFancyAli(void) ;
void FreeFancyAli(struct fancyali_s *ali ) ;
void TophitsReport(struct tophit_s *h___0 , double E , int nseq ) ;
struct tophit_s *AllocTophits(int lumpsize ) 
{ 
  struct tophit_s *hitlist ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = sre_malloc((char *)"tophits.c", 82, sizeof(struct tophit_s ));
  hitlist = (struct tophit_s *)tmp;
  hitlist->hit = (struct hit_s **)((void *)0);
  tmp___0 = sre_malloc((char *)"tophits.c", 84, (unsigned long )lumpsize * sizeof(struct hit_s ));
  hitlist->unsrt = (struct hit_s *)tmp___0;
  hitlist->alloc = lumpsize;
  hitlist->num = 0;
  hitlist->lump = lumpsize;
  return (hitlist);
}
}
void GrowTophits(struct tophit_s *h___0 ) 
{ 
  void *tmp ;

  {
  tmp = sre_realloc((char *)"tophits.c", 93, (void *)h___0->unsrt, (unsigned long )(h___0->alloc + h___0->lump) * sizeof(struct hit_s ));
  h___0->unsrt = (struct hit_s *)tmp;
  h___0->alloc += h___0->lump;
  return;
}
}
void FreeTophits(struct tophit_s *h___0 ) 
{ 
  int pos ;

  {
  pos = 0;
  while (pos < h___0->num) {
    if ((unsigned long )(h___0->unsrt + pos)->ali != (unsigned long )((void *)0)) {
      FreeFancyAli((h___0->unsrt + pos)->ali);
    }
    if ((unsigned long )(h___0->unsrt + pos)->name != (unsigned long )((void *)0)) {
      free((void *)(h___0->unsrt + pos)->name);
    }
    if ((unsigned long )(h___0->unsrt + pos)->acc != (unsigned long )((void *)0)) {
      free((void *)(h___0->unsrt + pos)->acc);
    }
    if ((unsigned long )(h___0->unsrt + pos)->desc != (unsigned long )((void *)0)) {
      free((void *)(h___0->unsrt + pos)->desc);
    }
    pos ++;
  }
  free((void *)h___0->unsrt);
  if ((unsigned long )h___0->hit != (unsigned long )((void *)0)) {
    free((void *)h___0->hit);
  }
  free((void *)h___0);
  return;
}
}
struct fancyali_s *AllocFancyAli(void) 
{ 
  struct fancyali_s *ali ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  tmp = sre_malloc((char *)"tophits.c", 117, sizeof(struct fancyali_s ));
  ali = (struct fancyali_s *)tmp;
  tmp___3 = (char *)((void *)0);
  ali->aseq = tmp___3;
  tmp___2 = tmp___3;
  ali->mline = tmp___2;
  tmp___1 = tmp___2;
  ali->model = tmp___1;
  tmp___0 = tmp___1;
  ali->csline = tmp___0;
  ali->rfline = tmp___0;
  tmp___4 = (char *)((void *)0);
  ali->target = tmp___4;
  ali->query = tmp___4;
  tmp___5 = 0;
  ali->sqto = tmp___5;
  ali->sqfrom = tmp___5;
  return (ali);
}
}
void FreeFancyAli(struct fancyali_s *ali ) 
{ 


  {
  if ((unsigned long )ali != (unsigned long )((void *)0)) {
    if ((unsigned long )ali->rfline != (unsigned long )((void *)0)) {
      free((void *)ali->rfline);
    }
    if ((unsigned long )ali->csline != (unsigned long )((void *)0)) {
      free((void *)ali->csline);
    }
    if ((unsigned long )ali->model != (unsigned long )((void *)0)) {
      free((void *)ali->model);
    }
    if ((unsigned long )ali->mline != (unsigned long )((void *)0)) {
      free((void *)ali->mline);
    }
    if ((unsigned long )ali->aseq != (unsigned long )((void *)0)) {
      free((void *)ali->aseq);
    }
    if ((unsigned long )ali->query != (unsigned long )((void *)0)) {
      free((void *)ali->query);
    }
    if ((unsigned long )ali->target != (unsigned long )((void *)0)) {
      free((void *)ali->target);
    }
    free((void *)ali);
  }
  return;
}
}
void RegisterHit(struct tophit_s *h___0 , double key , double pvalue , float score ,
                 double motherp , float mothersc , char *name , char *acc , char *desc ,
                 int sqfrom , int sqto , int sqlen , int hmmfrom , int hmmto , int hmmlen ,
                 int domidx , int ndom , struct fancyali_s *ali ) 
{ 


  {
  if (h___0->num == h___0->alloc) {
    GrowTophits(h___0);
  }
  (h___0->unsrt + h___0->num)->name = Strdup(name);
  (h___0->unsrt + h___0->num)->acc = Strdup(acc);
  (h___0->unsrt + h___0->num)->desc = Strdup(desc);
  (h___0->unsrt + h___0->num)->sortkey = key;
  (h___0->unsrt + h___0->num)->pvalue = pvalue;
  (h___0->unsrt + h___0->num)->score = score;
  (h___0->unsrt + h___0->num)->motherp = motherp;
  (h___0->unsrt + h___0->num)->mothersc = mothersc;
  (h___0->unsrt + h___0->num)->sqfrom = sqfrom;
  (h___0->unsrt + h___0->num)->sqto = sqto;
  (h___0->unsrt + h___0->num)->sqlen = sqlen;
  (h___0->unsrt + h___0->num)->hmmfrom = hmmfrom;
  (h___0->unsrt + h___0->num)->hmmto = hmmto;
  (h___0->unsrt + h___0->num)->hmmlen = hmmlen;
  (h___0->unsrt + h___0->num)->domidx = domidx;
  (h___0->unsrt + h___0->num)->ndom = ndom;
  (h___0->unsrt + h___0->num)->ali = ali;
  (h___0->num) ++;
  return;
}
}
void GetRankedHit(struct tophit_s *h___0 , int rank , double *r_pvalue , float *r_score ,
                  double *r_motherp , float *r_mothersc , char **r_name , char **r_acc ,
                  char **r_desc , int *r_sqfrom , int *r_sqto , int *r_sqlen , int *r_hmmfrom ,
                  int *r_hmmto , int *r_hmmlen , int *r_domidx , int *r_ndom , struct fancyali_s **r_ali ) 
{ 


  {
  if ((unsigned long )r_pvalue != (unsigned long )((void *)0)) {
    *r_pvalue = (*(h___0->hit + rank))->pvalue;
  }
  if ((unsigned long )r_score != (unsigned long )((void *)0)) {
    *r_score = (*(h___0->hit + rank))->score;
  }
  if ((unsigned long )r_motherp != (unsigned long )((void *)0)) {
    *r_motherp = (*(h___0->hit + rank))->motherp;
  }
  if ((unsigned long )r_mothersc != (unsigned long )((void *)0)) {
    *r_mothersc = (*(h___0->hit + rank))->mothersc;
  }
  if ((unsigned long )r_name != (unsigned long )((void *)0)) {
    *r_name = (*(h___0->hit + rank))->name;
  }
  if ((unsigned long )r_acc != (unsigned long )((void *)0)) {
    *r_acc = (*(h___0->hit + rank))->acc;
  }
  if ((unsigned long )r_desc != (unsigned long )((void *)0)) {
    *r_desc = (*(h___0->hit + rank))->desc;
  }
  if ((unsigned long )r_sqfrom != (unsigned long )((void *)0)) {
    *r_sqfrom = (*(h___0->hit + rank))->sqfrom;
  }
  if ((unsigned long )r_sqto != (unsigned long )((void *)0)) {
    *r_sqto = (*(h___0->hit + rank))->sqto;
  }
  if ((unsigned long )r_sqlen != (unsigned long )((void *)0)) {
    *r_sqlen = (*(h___0->hit + rank))->sqlen;
  }
  if ((unsigned long )r_hmmfrom != (unsigned long )((void *)0)) {
    *r_hmmfrom = (*(h___0->hit + rank))->hmmfrom;
  }
  if ((unsigned long )r_hmmto != (unsigned long )((void *)0)) {
    *r_hmmto = (*(h___0->hit + rank))->hmmto;
  }
  if ((unsigned long )r_hmmlen != (unsigned long )((void *)0)) {
    *r_hmmlen = (*(h___0->hit + rank))->hmmlen;
  }
  if ((unsigned long )r_domidx != (unsigned long )((void *)0)) {
    *r_domidx = (*(h___0->hit + rank))->domidx;
  }
  if ((unsigned long )r_ndom != (unsigned long )((void *)0)) {
    *r_ndom = (*(h___0->hit + rank))->ndom;
  }
  if ((unsigned long )r_ali != (unsigned long )((void *)0)) {
    *r_ali = (*(h___0->hit + rank))->ali;
  }
  return;
}
}
int TophitsMaxName(struct tophit_s *h___0 ) 
{ 
  int i___0 ;
  int len ;
  int maxlen ;
  size_t tmp ;

  {
  maxlen = 0;
  i___0 = 0;
  while (i___0 < h___0->num) {
    tmp = strlen((char const   *)(h___0->unsrt + i___0)->name);
    len = (int )tmp;
    if (len > maxlen) {
      maxlen = len;
    }
    i___0 ++;
  }
  return (maxlen);
}
}
int hit_comparison(void const   *vh1 , void const   *vh2 ) 
{ 
  struct hit_s *h1 ;
  struct hit_s *h2 ;

  {
  h1 = *((struct hit_s **)vh1);
  h2 = *((struct hit_s **)vh2);
  if (h1->sortkey < h2->sortkey) {
    return (1);
  } else
  if (h1->sortkey > h2->sortkey) {
    return (-1);
  } else
  if (h1->sortkey == h2->sortkey) {
    return (0);
  }
  return (0);
}
}
void specqsort(char *base , int n , int size , int (*compar)() ) ;
void FullSortTophits(struct tophit_s *h___0 ) 
{ 
  int i___0 ;
  void *tmp ;

  {
  if (h___0->num == 0) {
    return;
  }
  tmp = sre_malloc((char *)"tophits.c", 300, (unsigned long )h___0->num * sizeof(struct hit_s *));
  h___0->hit = (struct hit_s **)tmp;
  i___0 = 0;
  while (i___0 < h___0->num) {
    *(h___0->hit + i___0) = h___0->unsrt + i___0;
    i___0 ++;
  }
  if (h___0->num > 1) {
    specqsort(h___0->hit, h___0->num, sizeof(struct hit_s *), & hit_comparison);
  }
  return;
}
}
void TophitsReport(struct tophit_s *h___0 , double E , int nseq ) 
{ 
  int i___0 ;
  int memused ;
  int x ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  memused = (int )(sizeof(struct hit_s ) * (unsigned long )h___0->alloc + sizeof(struct tophit_s ));
  i___0 = 0;
  while (i___0 < h___0->num) {
    if ((unsigned long )(h___0->unsrt + i___0)->name != (unsigned long )((void *)0)) {
      tmp = strlen((char const   *)(h___0->unsrt + i___0)->name);
      memused = (int )((size_t )memused + (tmp + 1UL));
    }
    if ((unsigned long )(h___0->unsrt + i___0)->acc != (unsigned long )((void *)0)) {
      tmp___0 = strlen((char const   *)(h___0->unsrt + i___0)->acc);
      memused = (int )((size_t )memused + (tmp___0 + 1UL));
    }
    if ((unsigned long )(h___0->unsrt + i___0)->desc != (unsigned long )((void *)0)) {
      tmp___1 = strlen((char const   *)(h___0->unsrt + i___0)->desc);
      memused = (int )((size_t )memused + (tmp___1 + 1UL));
    }
    if ((unsigned long )(h___0->unsrt + i___0)->ali != (unsigned long )((void *)0)) {
      memused = (int )((unsigned long )memused + sizeof(struct fancyali_s ));
      x = 0;
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->rfline != (unsigned long )((void *)0)) {
        x ++;
      }
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->csline != (unsigned long )((void *)0)) {
        x ++;
      }
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->model != (unsigned long )((void *)0)) {
        x ++;
      }
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->mline != (unsigned long )((void *)0)) {
        x ++;
      }
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->aseq != (unsigned long )((void *)0)) {
        x ++;
      }
      memused += x * (((h___0->unsrt + i___0)->ali)->len + 1);
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->query != (unsigned long )((void *)0)) {
        tmp___2 = strlen((char const   *)((h___0->unsrt + i___0)->ali)->query);
        memused = (int )((size_t )memused + (tmp___2 + 1UL));
      }
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->target != (unsigned long )((void *)0)) {
        tmp___3 = strlen((char const   *)((h___0->unsrt + i___0)->ali)->target);
        memused = (int )((size_t )memused + (tmp___3 + 1UL));
      }
    }
    i___0 ++;
  }
  n = 0;
  i___0 = 0;
  while (i___0 < h___0->num) {
    if ((*(h___0->hit + i___0))->pvalue * (double )nseq >= E) {
      break;
    }
    n ++;
    i___0 ++;
  }
  printf("tophits_s report:\n");
  printf("     Total hits:           %d\n", h___0->num);
  printf("     Satisfying E cutoff:  %d\n", n);
  printf("     Total memory:         %dK\n", memused / 1000);
  return;
}
}
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-yLc3BPSX.i","-O3")
extern int fflush(FILE * ) ;
__inline static char *__inline_strncpy_chk(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strncpy_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
MSA *MSAAlloc(int nseq , int alen ) ;
void MSASetSeqAccession(MSA *msa , int seqidx , char *acc ) ;
void MSASetSeqDescription(MSA *msa , int seqidx , char *desc ) ;
int MakeAlignedString(char *aseq , int alen , char *ss , char **ret_s ) ;
char *sre_strdup(char *s___0 , int n ) ;
struct p7trace_s **MergeTraceArrays(struct p7trace_s **t1 , int n1 , struct p7trace_s **t2 ,
                                    int n2 ) ;
MSA *P7Traces2Alignment(char **dsq , SQINFO *sqinfo , float *wgt , int nseq , int mlen ,
                        struct p7trace_s **tr , int matchonly ) ;
int TraceDomainNumber(struct p7trace_s *tr ) ;
struct p7trace_s *MasterTraceFromMap(int *map , int M , int alen ) ;
void ImposeMasterTrace(char **aseq , int nseq , struct p7trace_s *mtr , struct p7trace_s ***ret_tr ) ;
static void rightjustify(char *s___0 , int n ) ;
void P7AllocTrace(int tlen , struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  tmp = sre_malloc((char *)"trace.c", 40, sizeof(struct p7trace_s ));
  tr = (struct p7trace_s *)tmp;
  tmp___0 = sre_malloc((char *)"trace.c", 41, sizeof(char ) * (unsigned long )tlen);
  tr->statetype = (char *)tmp___0;
  tmp___1 = sre_malloc((char *)"trace.c", 42, sizeof(int ) * (unsigned long )tlen);
  tr->nodeidx = (int *)tmp___1;
  tmp___2 = sre_malloc((char *)"trace.c", 43, sizeof(int ) * (unsigned long )tlen);
  tr->pos = (int *)tmp___2;
  *ret_tr = tr;
  return;
}
}
void P7ReallocTrace(struct p7trace_s *tr , int tlen ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = sre_realloc((char *)"trace.c", 49, (void *)tr->statetype, (unsigned long )tlen * sizeof(char ));
  tr->statetype = (char *)tmp;
  tmp___0 = sre_realloc((char *)"trace.c", 50, (void *)tr->nodeidx, (unsigned long )tlen * sizeof(int ));
  tr->nodeidx = (int *)tmp___0;
  tmp___1 = sre_realloc((char *)"trace.c", 51, (void *)tr->pos, (unsigned long )tlen * sizeof(int ));
  tr->pos = (int *)tmp___1;
  return;
}
}
void P7FreeTrace(struct p7trace_s *tr ) 
{ 


  {
  if ((unsigned long )tr == (unsigned long )((void *)0)) {
    return;
  }
  free((void *)tr->pos);
  free((void *)tr->nodeidx);
  free((void *)tr->statetype);
  free((void *)tr);
  return;
}
}
void TraceSet(struct p7trace_s *tr , int tpos , char type , int idx , int pos ) 
{ 


  {
  *(tr->statetype + tpos) = type;
  *(tr->nodeidx + tpos) = idx;
  *(tr->pos + tpos) = pos;
  return;
}
}
struct p7trace_s **MergeTraceArrays(struct p7trace_s **t1 , int n1 , struct p7trace_s **t2 ,
                                    int n2 ) 
{ 
  struct p7trace_s **tr ;
  int i___0 ;
  void *tmp ;

  {
  tmp = sre_malloc((char *)"trace.c", 110, sizeof(struct p7trace_s *) * (unsigned long )(n1 + n2));
  tr = (struct p7trace_s **)tmp;
  i___0 = 0;
  while (i___0 < n1) {
    *(tr + i___0) = *(t1 + i___0);
    i___0 ++;
  }
  i___0 = 0;
  while (i___0 < n2) {
    *(tr + (n1 + i___0)) = *(t2 + i___0);
    i___0 ++;
  }
  free((void *)t1);
  free((void *)t2);
  return (tr);
}
}
void P7ReverseTrace(struct p7trace_s *tr ) 
{ 
  char *statetype ;
  int *nodeidx ;
  int *pos ;
  int opos ;
  int npos ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = sre_malloc((char *)"trace.c", 149, sizeof(char ) * (unsigned long )tr->tlen);
  statetype = (char *)tmp;
  tmp___0 = sre_malloc((char *)"trace.c", 150, sizeof(int ) * (unsigned long )tr->tlen);
  nodeidx = (int *)tmp___0;
  tmp___1 = sre_malloc((char *)"trace.c", 151, sizeof(int ) * (unsigned long )tr->tlen);
  pos = (int *)tmp___1;
  opos = tr->tlen - 1;
  npos = 0;
  while (npos < tr->tlen) {
    *(statetype + npos) = *(tr->statetype + opos);
    *(nodeidx + npos) = *(tr->nodeidx + opos);
    *(pos + npos) = *(tr->pos + opos);
    npos ++;
    opos --;
  }
  free((void *)tr->statetype);
  free((void *)tr->nodeidx);
  free((void *)tr->pos);
  tr->statetype = statetype;
  tr->nodeidx = nodeidx;
  tr->pos = pos;
  return;
}
}
void P7TraceCount(struct plan7_s *hmm , char *dsq , float wt , struct p7trace_s *tr ) 
{ 
  int tpos ;
  int i___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  tpos = 0;
  while (tpos < tr->tlen) {
    i___0 = *(tr->pos + tpos);
    if ((int )*(tr->statetype + tpos) == 1) {
      P7CountSymbol(*(hmm->mat + *(tr->nodeidx + tpos)), *(dsq + i___0), wt);
    } else
    if ((int )*(tr->statetype + tpos) == 3) {
      P7CountSymbol(*(hmm->ins + *(tr->nodeidx + tpos)), *(dsq + i___0), wt);
    }
    switch ((int )*(tr->statetype + tpos)) {
    case 4: 
    break;
    case 5: 
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 6: 
    hmm->xt[0][0] += wt;
    break;
    case 5: 
    hmm->xt[0][1] += wt;
    break;
    default: 
    tmp = Statetype(*(tr->statetype + (tpos + 1)));
    tmp___0 = Statetype(*(tr->statetype + tpos));
    Die((char *)"illegal state transition %s->%s in traceback", tmp___0, tmp);
    }
    break;
    case 6: 
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 1: 
    *(hmm->begin + *(tr->nodeidx + (tpos + 1))) += wt;
    break;
    case 2: 
    hmm->tbd1 += wt;
    break;
    default: 
    tmp___1 = Statetype(*(tr->statetype + (tpos + 1)));
    tmp___2 = Statetype(*(tr->statetype + tpos));
    Die((char *)"illegal state transition %s->%s in traceback", tmp___2, tmp___1);
    }
    break;
    case 1: 
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 1: 
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 0) += wt;
    break;
    case 3: 
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 1) += wt;
    break;
    case 2: 
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 2) += wt;
    break;
    case 7: 
    *(hmm->end + *(tr->nodeidx + tpos)) += wt;
    break;
    default: 
    tmp___3 = Statetype(*(tr->statetype + (tpos + 1)));
    tmp___4 = Statetype(*(tr->statetype + tpos));
    Die((char *)"illegal state transition %s->%s in traceback", tmp___4, tmp___3);
    }
    break;
    case 3: 
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 1: 
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 3) += wt;
    break;
    case 3: 
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 4) += wt;
    break;
    default: 
    tmp___5 = Statetype(*(tr->statetype + (tpos + 1)));
    tmp___6 = Statetype(*(tr->statetype + tpos));
    Die((char *)"illegal state transition %s->%s in traceback", tmp___6, tmp___5);
    }
    break;
    case 2: 
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 1: 
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 5) += wt;
    break;
    case 2: 
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 6) += wt;
    break;
    case 7: 
    break;
    default: 
    tmp___7 = Statetype(*(tr->statetype + (tpos + 1)));
    tmp___8 = Statetype(*(tr->statetype + tpos));
    Die((char *)"illegal state transition %s->%s in traceback", tmp___8, tmp___7);
    }
    break;
    case 7: 
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 8: 
    hmm->xt[1][0] += wt;
    break;
    case 10: 
    hmm->xt[1][1] += wt;
    break;
    default: 
    tmp___9 = Statetype(*(tr->statetype + (tpos + 1)));
    tmp___10 = Statetype(*(tr->statetype + tpos));
    Die((char *)"illegal state transition %s->%s in traceback", tmp___10, tmp___9);
    }
    break;
    case 10: 
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 6: 
    hmm->xt[3][0] += wt;
    break;
    case 10: 
    hmm->xt[3][1] += wt;
    break;
    default: 
    tmp___11 = Statetype(*(tr->statetype + (tpos + 1)));
    tmp___12 = Statetype(*(tr->statetype + tpos));
    Die((char *)"illegal state transition %s->%s in traceback", tmp___12, tmp___11);
    }
    break;
    case 8: 
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 9: 
    hmm->xt[2][0] += wt;
    break;
    case 8: 
    hmm->xt[2][1] += wt;
    break;
    default: 
    tmp___13 = Statetype(*(tr->statetype + (tpos + 1)));
    tmp___14 = Statetype(*(tr->statetype + tpos));
    Die((char *)"illegal state transition %s->%s in traceback", tmp___14, tmp___13);
    }
    break;
    case 9: 
    break;
    default: 
    tmp___15 = Statetype(*(tr->statetype + tpos));
    Die((char *)"illegal state %s in traceback", tmp___15);
    }
    tpos ++;
  }
  return;
}
}
float P7TraceScore(struct plan7_s *hmm , char *dsq , struct p7trace_s *tr ) 
{ 
  int score ;
  int tpos ;
  int sym ;
  int tmp ;
  float tmp___0 ;

  {
  score = 0;
  tpos = 0;
  while (tpos < tr->tlen - 1) {
    sym = (int )*(dsq + *(tr->pos + tpos));
    if ((int )*(tr->statetype + tpos) == 1) {
      score += *(*(hmm->msc + sym) + *(tr->nodeidx + tpos));
    } else
    if ((int )*(tr->statetype + tpos) == 3) {
      score += *(*(hmm->isc + sym) + *(tr->nodeidx + tpos));
    }
    tmp = TransitionScoreLookup(hmm, *(tr->statetype + tpos), *(tr->nodeidx + tpos),
                                *(tr->statetype + (tpos + 1)), *(tr->nodeidx + (tpos + 1)));
    score += tmp;
    tpos ++;
  }
  tmp___0 = Scorify(score);
  return (tmp___0);
}
}
MSA *P7Traces2Alignment(char **dsq , SQINFO *sqinfo , float *wgt , int nseq , int mlen ,
                        struct p7trace_s **tr , int matchonly ) 
{ 
  MSA *msa ;
  int idx ;
  int alen ;
  int *inserts ;
  int *matmap ;
  int nins ;
  int apos ;
  int rpos ;
  int tpos ;
  int statetype ;
  int k ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  unsigned long tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  tmp = sre_malloc((char *)"trace.c", 408, sizeof(int ) * (unsigned long )(mlen + 1));
  inserts = (int *)tmp;
  k = 0;
  while (k <= mlen) {
    *(inserts + k) = 0;
    k ++;
  }
  idx = 0;
  while (idx < nseq) {
    nins = 0;
    tpos = 0;
    while (tpos < (*(tr + idx))->tlen) {
      switch ((int )*((*(tr + idx))->statetype + tpos)) {
      case 3: 
      nins ++;
      break;
      case 5: 
      if ((int )*((*(tr + idx))->statetype + (tpos - 1)) == 5) {
        nins ++;
      }
      break;
      case 8: 
      if ((int )*((*(tr + idx))->statetype + (tpos - 1)) == 8) {
        nins ++;
      }
      break;
      case 2: 
      case 1: 
      if (nins > *(inserts + (*((*(tr + idx))->nodeidx + tpos) - 1))) {
        *(inserts + (*((*(tr + idx))->nodeidx + tpos) - 1)) = nins;
      }
      nins = 0;
      break;
      case 6: 
      if (nins > *(inserts + 0)) {
        *(inserts + 0) = nins;
      }
      nins = 0;
      break;
      case 9: 
      if (nins > *(inserts + mlen)) {
        *(inserts + mlen) = nins;
      }
      break;
      case 7: 
      case 4: 
      break;
      case 10: 
      Die((char *)"yo! you don\'t support J in Traces2Alignment(), remember?");
      default: 
      tmp___0 = Statetype(*((*(tr + idx))->statetype + tpos));
      Die((char *)"Traces2Alignment reports unrecognized statetype %c", tmp___0);
      }
      tpos ++;
    }
    idx ++;
  }
  if (matchonly) {
    k = 0;
    while (k <= mlen) {
      if (*(inserts + k) > 1) {
        *(inserts + k) = 1;
      }
      k ++;
    }
  }
  tmp___1 = sre_malloc((char *)"trace.c", 453, sizeof(int ) * (unsigned long )(mlen + 1));
  matmap = (int *)tmp___1;
  *(matmap + 0) = -1;
  alen = *(inserts + 0);
  k = 1;
  while (k <= mlen) {
    *(matmap + k) = alen;
    alen += *(inserts + k) + 1;
    k ++;
  }
  msa = MSAAlloc(nseq, alen);
  idx = 0;
  while (idx < nseq) {
    apos = 0;
    while (apos < alen) {
      *(*(msa->aseq + idx) + apos) = (char )'.';
      apos ++;
    }
    k = 1;
    while (k <= mlen) {
      *(*(msa->aseq + idx) + *(matmap + k)) = (char )'-';
      k ++;
    }
    *(*(msa->aseq + idx) + alen) = (char )'\000';
    apos = 0;
    tpos = 0;
    while (tpos < (*(tr + idx))->tlen) {
      statetype = (int )*((*(tr + idx))->statetype + tpos);
      rpos = *((*(tr + idx))->pos + tpos);
      k = *((*(tr + idx))->nodeidx + tpos);
      if (statetype == 1) {
        apos = *(matmap + k);
        *(*(msa->aseq + idx) + apos) = Alphabet[(int )*(*(dsq + idx) + rpos)];
        apos ++;
      } else
      if (statetype == 2) {
        apos = *(matmap + k) + 1;
      } else
      if (statetype == 3) {
        if (matchonly) {
          *(*(msa->aseq + idx) + apos) = (char )'*';
        } else {
          tmp___2 = tolower((int )Alphabet[(int )*(*(dsq + idx) + rpos)]);
          *(*(msa->aseq + idx) + apos) = (char )tmp___2;
          apos ++;
        }
      } else
      if (statetype == 5) {
        goto _L___0;
      } else
      if (statetype == 8) {
        _L___0: /* CIL Label */ 
        if (rpos > 0) {
          if (matchonly) {
            *(*(msa->aseq + idx) + apos) = (char )'*';
          } else {
            tmp___3 = tolower((int )Alphabet[(int )*(*(dsq + idx) + rpos)]);
            *(*(msa->aseq + idx) + apos) = (char )tmp___3;
            apos ++;
          }
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (statetype == 7) {
        apos = *(matmap + mlen) + 1;
      }
      tpos ++;
    }
    if (! matchonly) {
      rightjustify(*(msa->aseq + idx), *(inserts + 0));
      k = 1;
      while (k < mlen) {
        if (*(inserts + k) > 1) {
          nins = 0;
          apos = *(matmap + k) + 1;
          while (1) {
            tmp___4 = islower((int )*(*(msa->aseq + idx) + apos));
            if (! tmp___4) {
              break;
            }
            nins ++;
            apos ++;
          }
          nins /= 2;
          rightjustify(((*(msa->aseq + idx) + *(matmap + k)) + 1) + nins, *(inserts + k) - nins);
        }
        k ++;
      }
    }
    idx ++;
  }
  msa->nseq = nseq;
  msa->alen = alen;
  tmp___5 = strlen("2.3");
  tmp___6 = sre_malloc((char *)"trace.c", 529, sizeof(char ) * (tmp___5 + 7UL));
  msa->au = (char *)tmp___6;
  tmp___7 = __builtin_object_size((void *)msa->au, 1);
  __builtin___sprintf_chk(msa->au, 0, tmp___7, "HMMER %s", "2.3");
  idx = 0;
  while (idx < nseq) {
    *(msa->sqname + idx) = sre_strdup((sqinfo + idx)->name, -1);
    if ((sqinfo + idx)->flags & (1 << 2)) {
      MSASetSeqAccession(msa, idx, (sqinfo + idx)->acc);
    }
    if ((sqinfo + idx)->flags & (1 << 3)) {
      MSASetSeqDescription(msa, idx, (sqinfo + idx)->desc);
    }
    if ((sqinfo + idx)->flags & (1 << 9)) {
      if ((unsigned long )msa->ss == (unsigned long )((void *)0)) {
        tmp___8 = sre_malloc((char *)"trace.c", 541, sizeof(char *) * (unsigned long )nseq);
        msa->ss = (char **)tmp___8;
      }
      MakeAlignedString(*(msa->aseq + idx), alen, (sqinfo + idx)->ss, msa->ss + idx);
    }
    if ((sqinfo + idx)->flags & (1 << 10)) {
      if ((unsigned long )msa->sa == (unsigned long )((void *)0)) {
        tmp___9 = sre_malloc((char *)"trace.c", 546, sizeof(char *) * (unsigned long )nseq);
        msa->sa = (char **)tmp___9;
      }
      MakeAlignedString(*(msa->aseq + idx), alen, (sqinfo + idx)->sa, msa->sa + idx);
    }
    *(msa->wgt + idx) = *(wgt + idx);
    idx ++;
  }
  tmp___10 = sre_malloc((char *)"trace.c", 555, sizeof(char ) * (unsigned long )(alen + 1));
  msa->rf = (char *)tmp___10;
  apos = 0;
  while (apos < alen) {
    *(msa->rf + apos) = (char )'.';
    apos ++;
  }
  k = 1;
  while (k <= mlen) {
    *(msa->rf + *(matmap + k)) = (char )'x';
    k ++;
  }
  *(msa->rf + alen) = (char )'\000';
  free((void *)inserts);
  free((void *)matmap);
  return (msa);
}
}
int TransitionScoreLookup(struct plan7_s *hmm , char st1 , int k1 , char st2 , int k2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
  switch ((int )st1) {
  case 4: 
  return (0);
  case 5: 
  switch ((int )st2) {
  case 6: 
  return (hmm->xsc[0][0]);
  case 5: 
  return (hmm->xsc[0][1]);
  default: 
  tmp = Statetype(st2);
  tmp___0 = Statetype(st1);
  Die((char *)"illegal %s->%s transition", tmp___0, tmp);
  }
  break;
  case 6: 
  switch ((int )st2) {
  case 1: 
  return (*(hmm->bsc + k2));
  case 2: 
  tmp___1 = Prob2Score(hmm->tbd1, (float )1.);
  return (tmp___1);
  default: 
  tmp___2 = Statetype(st2);
  tmp___3 = Statetype(st1);
  Die((char *)"illegal %s->%s transition", tmp___3, tmp___2);
  }
  break;
  case 1: 
  switch ((int )st2) {
  case 1: 
  return (*(*(hmm->tsc + 0) + k1));
  case 3: 
  return (*(*(hmm->tsc + 1) + k1));
  case 2: 
  return (*(*(hmm->tsc + 2) + k1));
  case 7: 
  return (*(hmm->esc + k1));
  default: 
  tmp___4 = Statetype(st2);
  tmp___5 = Statetype(st1);
  Die((char *)"illegal %s->%s transition", tmp___5, tmp___4);
  }
  break;
  case 3: 
  switch ((int )st2) {
  case 1: 
  return (*(*(hmm->tsc + 3) + k1));
  case 3: 
  return (*(*(hmm->tsc + 4) + k1));
  default: 
  tmp___6 = Statetype(st2);
  tmp___7 = Statetype(st1);
  Die((char *)"illegal %s->%s transition", tmp___7, tmp___6);
  }
  break;
  case 2: 
  switch ((int )st2) {
  case 1: 
  return (*(*(hmm->tsc + 5) + k1));
  case 2: 
  return (*(*(hmm->tsc + 6) + k1));
  case 7: 
  return (0);
  default: 
  tmp___8 = Statetype(st2);
  tmp___9 = Statetype(st1);
  Die((char *)"illegal %s->%s transition", tmp___9, tmp___8);
  }
  break;
  case 7: 
  switch ((int )st2) {
  case 8: 
  return (hmm->xsc[1][0]);
  case 10: 
  return (hmm->xsc[1][1]);
  default: 
  tmp___10 = Statetype(st2);
  tmp___11 = Statetype(st1);
  Die((char *)"illegal %s->%s transition", tmp___11, tmp___10);
  }
  break;
  case 10: 
  switch ((int )st2) {
  case 6: 
  return (hmm->xsc[3][0]);
  case 10: 
  return (hmm->xsc[3][1]);
  default: 
  tmp___12 = Statetype(st2);
  tmp___13 = Statetype(st1);
  Die((char *)"illegal %s->%s transition", tmp___13, tmp___12);
  }
  break;
  case 8: 
  switch ((int )st2) {
  case 9: 
  return (hmm->xsc[2][0]);
  case 8: 
  return (hmm->xsc[2][1]);
  default: 
  tmp___14 = Statetype(st2);
  tmp___15 = Statetype(st1);
  Die((char *)"illegal %s->%s transition", tmp___15, tmp___14);
  }
  break;
  case 9: 
  return (0);
  default: 
  tmp___16 = Statetype(st1);
  Die((char *)"illegal state %s in traceback", tmp___16);
  }
  return (0);
}
}
struct fancyali_s *CreateFancyAli(struct p7trace_s *tr , struct plan7_s *hmm , char *dsq ,
                                  char *name ) 
{ 
  struct fancyali_s *ali ;
  int tpos ;
  int bestsym ;
  float mthresh___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  void *tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  void *tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  ali = AllocFancyAli();
  ali->rfline = (char *)((void *)0);
  ali->csline = (char *)((void *)0);
  tmp = sre_malloc((char *)"trace.c", 680, sizeof(char ) * (unsigned long )(tr->tlen + 1));
  ali->model = (char *)tmp;
  tmp___0 = sre_malloc((char *)"trace.c", 681, sizeof(char ) * (unsigned long )(tr->tlen + 1));
  ali->mline = (char *)tmp___0;
  tmp___1 = sre_malloc((char *)"trace.c", 682, sizeof(char ) * (unsigned long )(tr->tlen + 1));
  ali->aseq = (char *)tmp___1;
  tmp___3 = __builtin_object_size((void *)ali->model, 0);
  if (tmp___3 != 0xffffffffffffffffUL) {
    tmp___2 = __builtin_object_size((void *)ali->model, 0);
    __builtin___memset_chk((void *)ali->model, ' ', (unsigned long )tr->tlen, tmp___2);
  } else {
    __inline_memset_chk((void *)ali->model, ' ', (size_t )tr->tlen);
  }
  tmp___5 = __builtin_object_size((void *)ali->mline, 0);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___4 = __builtin_object_size((void *)ali->mline, 0);
    __builtin___memset_chk((void *)ali->mline, ' ', (unsigned long )tr->tlen, tmp___4);
  } else {
    __inline_memset_chk((void *)ali->mline, ' ', (size_t )tr->tlen);
  }
  tmp___7 = __builtin_object_size((void *)ali->aseq, 0);
  if (tmp___7 != 0xffffffffffffffffUL) {
    tmp___6 = __builtin_object_size((void *)ali->aseq, 0);
    __builtin___memset_chk((void *)ali->aseq, ' ', (unsigned long )tr->tlen, tmp___6);
  } else {
    __inline_memset_chk((void *)ali->aseq, ' ', (size_t )tr->tlen);
  }
  if (hmm->flags & (1 << 2)) {
    tmp___8 = sre_malloc((char *)"trace.c", 690, sizeof(char ) * (unsigned long )(tr->tlen + 1));
    ali->rfline = (char *)tmp___8;
    tmp___10 = __builtin_object_size((void *)ali->rfline, 0);
    if (tmp___10 != 0xffffffffffffffffUL) {
      tmp___9 = __builtin_object_size((void *)ali->rfline, 0);
      __builtin___memset_chk((void *)ali->rfline, ' ', (unsigned long )tr->tlen, tmp___9);
    } else {
      __inline_memset_chk((void *)ali->rfline, ' ', (size_t )tr->tlen);
    }
  }
  if (hmm->flags & (1 << 3)) {
    tmp___11 = sre_malloc((char *)"trace.c", 695, sizeof(char ) * (unsigned long )(tr->tlen + 1));
    ali->csline = (char *)tmp___11;
    tmp___13 = __builtin_object_size((void *)ali->csline, 0);
    if (tmp___13 != 0xffffffffffffffffUL) {
      tmp___12 = __builtin_object_size((void *)ali->csline, 0);
      __builtin___memset_chk((void *)ali->csline, ' ', (unsigned long )tr->tlen, tmp___12);
    } else {
      __inline_memset_chk((void *)ali->csline, ' ', (size_t )tr->tlen);
    }
  }
  ali->query = Strdup(hmm->name);
  ali->target = Strdup(name);
  if (Alphabet_type == 3) {
    mthresh___0 = (float )0.5;
  } else {
    mthresh___0 = (float )0.9;
  }
  tpos = 0;
  while (tpos < tr->tlen) {
    if (*(tr->pos + tpos) > 0) {
      ali->sqfrom = *(tr->pos + tpos);
      break;
    }
    tpos ++;
  }
  tpos = tr->tlen - 1;
  while (tpos >= 0) {
    if (*(tr->pos + tpos) > 0) {
      ali->sqto = *(tr->pos + tpos);
      break;
    }
    tpos --;
  }
  tpos = 0;
  while (tpos < tr->tlen) {
    switch ((int )*(tr->statetype + tpos)) {
    case 9: 
    case 4: 
    *(ali->model + tpos) = (char )'*';
    break;
    case 8: 
    case 10: 
    case 5: 
    *(ali->model + tpos) = (char )'-';
    if (*(tr->pos + tpos) > 0) {
      tmp___14 = tolower((int )Alphabet[(int )*(dsq + *(tr->pos + tpos))]);
      *(ali->aseq + tpos) = (char )tmp___14;
    }
    break;
    case 6: 
    *(ali->model + tpos) = (char )'>';
    break;
    case 7: 
    *(ali->model + tpos) = (char )'<';
    break;
    case 1: 
    if (hmm->flags & (1 << 2)) {
      *(ali->rfline + tpos) = *(hmm->rf + *(tr->nodeidx + tpos));
    }
    if (hmm->flags & (1 << 3)) {
      *(ali->csline + tpos) = *(hmm->cs + *(tr->nodeidx + tpos));
    }
    bestsym = FArgMax(*(hmm->mat + *(tr->nodeidx + tpos)), Alphabet_size);
    *(ali->model + tpos) = Alphabet[bestsym];
    if (*(*(hmm->mat + *(tr->nodeidx + tpos)) + bestsym) < mthresh___0) {
      tmp___15 = tolower((int )*(ali->model + tpos));
      *(ali->model + tpos) = (char )tmp___15;
    }
    if ((int )*(dsq + *(tr->pos + tpos)) == bestsym) {
      *(ali->mline + tpos) = Alphabet[(int )*(dsq + *(tr->pos + tpos))];
      if (*(*(hmm->mat + *(tr->nodeidx + tpos)) + bestsym) < mthresh___0) {
        tmp___16 = tolower((int )*(ali->mline + tpos));
        *(ali->mline + tpos) = (char )tmp___16;
      }
    } else
    if (*(*(hmm->msc + (int )*(dsq + *(tr->pos + tpos))) + *(tr->nodeidx + tpos)) > 0) {
      *(ali->mline + tpos) = (char )'+';
    }
    *(ali->aseq + tpos) = Alphabet[(int )*(dsq + *(tr->pos + tpos))];
    break;
    case 2: 
    if (hmm->flags & (1 << 2)) {
      *(ali->rfline + tpos) = *(hmm->rf + *(tr->nodeidx + tpos));
    }
    if (hmm->flags & (1 << 3)) {
      *(ali->csline + tpos) = *(hmm->cs + *(tr->nodeidx + tpos));
    }
    bestsym = FArgMax(*(hmm->mat + *(tr->nodeidx + tpos)), Alphabet_size);
    *(ali->model + tpos) = Alphabet[bestsym];
    if (*(*(hmm->mat + *(tr->nodeidx + tpos)) + bestsym) < mthresh___0) {
      tmp___17 = tolower((int )*(ali->model + tpos));
      *(ali->model + tpos) = (char )tmp___17;
    }
    *(ali->aseq + tpos) = (char )'-';
    break;
    case 3: 
    *(ali->model + tpos) = (char )'.';
    if (*(*(hmm->isc + (int )*(dsq + *(tr->pos + tpos))) + *(tr->nodeidx + tpos)) > 0) {
      *(ali->mline + tpos) = (char )'+';
    }
    tmp___18 = tolower((int )Alphabet[(int )*(dsq + *(tr->pos + tpos))]);
    *(ali->aseq + tpos) = (char )tmp___18;
    break;
    default: 
    Die((char *)"bogus statetype");
    }
    tpos ++;
  }
  ali->len = tpos;
  if (hmm->flags & (1 << 2)) {
    *(ali->rfline + tpos) = (char )'\000';
  }
  if (hmm->flags & (1 << 3)) {
    *(ali->csline + tpos) = (char )'\000';
  }
  *(ali->model + tpos) = (char )'\000';
  *(ali->mline + tpos) = (char )'\000';
  *(ali->aseq + tpos) = (char )'\000';
  return (ali);
}
}
void PrintFancyAli(FILE *fp , struct fancyali_s *ali ) 
{ 
  char buffer___1[51] ;
  int starti ;
  int endi ;
  int pos ;
  int i___0 ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;

  {
  buffer___1[50] = (char )'\000';
  endi = ali->sqfrom - 1;
  pos = 0;
  while (pos < ali->len) {
    starti = endi + 1;
    i___0 = pos;
    while (1) {
      if ((int )*(ali->aseq + i___0) != 0) {
        if (! (i___0 < pos + 50)) {
          break;
        }
      } else {
        break;
      }
      if (! ((int )*(ali->aseq + i___0) == 32)) {
        if (! ((int )*(ali->aseq + i___0) == 46)) {
          if (! ((int )*(ali->aseq + i___0) == 95)) {
            if (! ((int )*(ali->aseq + i___0) == 45)) {
              if (! ((int )*(ali->aseq + i___0) == 126)) {
                endi ++;
              }
            }
          }
        }
      }
      i___0 ++;
    }
    if ((unsigned long )ali->csline != (unsigned long )((void *)0)) {
      tmp___0 = __builtin_object_size((void *)(buffer___1), 0);
      if (tmp___0 != 0xffffffffffffffffUL) {
        tmp = __builtin_object_size((void *)(buffer___1), 1);
        __builtin___strncpy_chk(buffer___1, (char const   *)(ali->csline + pos), 50UL,
                                tmp);
      } else {
        __inline_strncpy_chk(buffer___1, (char const   *)(ali->csline + pos), (size_t )50);
      }
      fprintf(fp, "  %16s %s\n", "CS", buffer___1);
    }
    if ((unsigned long )ali->rfline != (unsigned long )((void *)0)) {
      tmp___2 = __builtin_object_size((void *)(buffer___1), 0);
      if (tmp___2 != 0xffffffffffffffffUL) {
        tmp___1 = __builtin_object_size((void *)(buffer___1), 1);
        __builtin___strncpy_chk(buffer___1, (char const   *)(ali->rfline + pos), 50UL,
                                tmp___1);
      } else {
        __inline_strncpy_chk(buffer___1, (char const   *)(ali->rfline + pos), (size_t )50);
      }
      fprintf(fp, "  %16s %s\n", "RF", buffer___1);
    }
    if ((unsigned long )ali->model != (unsigned long )((void *)0)) {
      tmp___4 = __builtin_object_size((void *)(buffer___1), 0);
      if (tmp___4 != 0xffffffffffffffffUL) {
        tmp___3 = __builtin_object_size((void *)(buffer___1), 1);
        __builtin___strncpy_chk(buffer___1, (char const   *)(ali->model + pos), 50UL,
                                tmp___3);
      } else {
        __inline_strncpy_chk(buffer___1, (char const   *)(ali->model + pos), (size_t )50);
      }
      fprintf(fp, "  %16s %s\n", " ", buffer___1);
    }
    if ((unsigned long )ali->mline != (unsigned long )((void *)0)) {
      tmp___6 = __builtin_object_size((void *)(buffer___1), 0);
      if (tmp___6 != 0xffffffffffffffffUL) {
        tmp___5 = __builtin_object_size((void *)(buffer___1), 1);
        __builtin___strncpy_chk(buffer___1, (char const   *)(ali->mline + pos), 50UL,
                                tmp___5);
      } else {
        __inline_strncpy_chk(buffer___1, (char const   *)(ali->mline + pos), (size_t )50);
      }
      fprintf(fp, "  %16s %s\n", " ", buffer___1);
    }
    if ((unsigned long )ali->aseq != (unsigned long )((void *)0)) {
      tmp___8 = __builtin_object_size((void *)(buffer___1), 0);
      if (tmp___8 != 0xffffffffffffffffUL) {
        tmp___7 = __builtin_object_size((void *)(buffer___1), 1);
        __builtin___strncpy_chk(buffer___1, (char const   *)(ali->aseq + pos), 50UL,
                                tmp___7);
      } else {
        __inline_strncpy_chk(buffer___1, (char const   *)(ali->aseq + pos), (size_t )50);
      }
      if (endi >= starti) {
        fprintf(fp, "  %10.10s %5d %s %-5d\n\n", ali->target, starti, buffer___1,
                endi);
      } else {
        fprintf(fp, "  %10.10s %5s %s %-5s\n\n", ali->target, "-", buffer___1, "-");
      }
    }
    pos += 50;
  }
  fflush(fp);
  return;
}
}
void TraceDecompose(struct p7trace_s *otr , struct p7trace_s ***ret_tr , int *ret_ntr ) 
{ 
  struct p7trace_s **tr ;
  int ntr ;
  int i___0 ;
  int j ;
  int idx ;
  void *tmp ;

  {
  ntr = 0;
  i___0 = 0;
  while (i___0 < otr->tlen) {
    if ((int )*(otr->statetype + i___0) == 6) {
      ntr ++;
    }
    i___0 ++;
  }
  if (ntr == 0) {
    *ret_ntr = 0;
    *ret_tr = (struct p7trace_s **)((void *)0);
    return;
  }
  tmp = sre_malloc((char *)"trace.c", 893, sizeof(struct p7trace_s *) * (unsigned long )ntr);
  tr = (struct p7trace_s **)tmp;
  idx = 0;
  i___0 = 0;
  while (i___0 < otr->tlen) {
    if ((int )*(otr->statetype + i___0) == 6) {
      j = i___0 + 1;
      while (j < otr->tlen) {
        if ((int )*(otr->statetype + j) == 7) {
          break;
        }
        j ++;
      }
      P7AllocTrace((j - i___0) + 5, tr + idx);
      (*(tr + idx))->tlen = (j - i___0) + 5;
      *((*(tr + idx))->statetype + 0) = (char)4;
      *((*(tr + idx))->nodeidx + 0) = 0;
      *((*(tr + idx))->pos + 0) = 0;
      *((*(tr + idx))->statetype + 1) = (char)5;
      *((*(tr + idx))->nodeidx + 1) = 0;
      *((*(tr + idx))->pos + 1) = 0;
      j = 2;
      while (1) {
        *((*(tr + idx))->statetype + j) = *(otr->statetype + i___0);
        *((*(tr + idx))->nodeidx + j) = *(otr->nodeidx + i___0);
        *((*(tr + idx))->pos + j) = *(otr->pos + i___0);
        if ((int )*(otr->statetype + i___0) == 7) {
          break;
        }
        i___0 ++;
        j ++;
      }
      j ++;
      *((*(tr + idx))->statetype + j) = (char)8;
      *((*(tr + idx))->nodeidx + j) = 0;
      *((*(tr + idx))->pos + j) = 0;
      j ++;
      *((*(tr + idx))->statetype + j) = (char)9;
      *((*(tr + idx))->nodeidx + j) = 0;
      *((*(tr + idx))->pos + j) = 0;
      idx ++;
    }
    i___0 ++;
  }
  *ret_tr = tr;
  *ret_ntr = ntr;
  return;
}
}
int TraceDomainNumber(struct p7trace_s *tr ) 
{ 
  int i___0 ;
  int ndom ;

  {
  ndom = 0;
  i___0 = 0;
  while (i___0 < tr->tlen) {
    if ((int )*(tr->statetype + i___0) == 6) {
      ndom ++;
    }
    i___0 ++;
  }
  return (ndom);
}
}
void TraceSimpleBounds(struct p7trace_s *tr , int *ret_i1 , int *ret_i2 , int *ret_k1 ,
                       int *ret_k2 ) 
{ 
  int i1 ;
  int i2 ;
  int k1 ;
  int k2 ;
  int tpos ;

  {
  k2 = -1;
  i2 = k2;
  k1 = i2;
  i1 = k1;
  tpos = 0;
  while (tpos < tr->tlen) {
    if (k1 == -1) {
      if ((int )*(tr->statetype + tpos) == 1) {
        k1 = *(tr->nodeidx + tpos);
      } else
      if ((int )*(tr->statetype + tpos) == 2) {
        k1 = *(tr->nodeidx + tpos);
      }
    }
    if ((int )*(tr->statetype + tpos) == 1) {
      i1 = *(tr->pos + tpos);
      break;
    }
    tpos ++;
  }
  if (tpos == tr->tlen) {
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  } else
  if (i1 == -1) {
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  } else
  if (k1 == -1) {
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  }
  tpos = tr->tlen - 1;
  while (tpos >= 0) {
    if (k2 == -1) {
      if ((int )*(tr->statetype + tpos) == 1) {
        k2 = *(tr->nodeidx + tpos);
      } else
      if ((int )*(tr->statetype + tpos) == 2) {
        k2 = *(tr->nodeidx + tpos);
      }
    }
    if ((int )*(tr->statetype + tpos) == 1) {
      i2 = *(tr->pos + tpos);
      break;
    }
    tpos --;
  }
  if (tpos == tr->tlen) {
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  } else
  if (i2 == -1) {
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  } else
  if (k2 == -1) {
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  }
  *ret_k1 = k1;
  *ret_i1 = i1;
  *ret_k2 = k2;
  *ret_i2 = i2;
  return;
}
}
struct p7trace_s *MasterTraceFromMap(int *map , int M , int alen ) 
{ 
  struct p7trace_s *tr ;
  int tpos ;
  int apos ;
  int k ;

  {
  P7AllocTrace(alen + 6, & tr);
  tpos = 0;
  TraceSet(tr, tpos, (char)4, 0, 0);
  tpos ++;
  TraceSet(tr, tpos, (char)5, 0, 0);
  tpos ++;
  apos = 1;
  while (apos < *(map + 1)) {
    TraceSet(tr, tpos, (char)5, 0, apos);
    tpos ++;
    apos ++;
  }
  TraceSet(tr, tpos, (char)6, 0, 0);
  tpos ++;
  k = 1;
  while (k < M) {
    TraceSet(tr, tpos, (char)1, k, apos);
    tpos ++;
    apos ++;
    while (apos < *(map + (k + 1))) {
      TraceSet(tr, tpos, (char)3, k, apos);
      tpos ++;
      apos ++;
    }
    k ++;
  }
  TraceSet(tr, tpos, (char)1, M, apos);
  tpos ++;
  apos ++;
  TraceSet(tr, tpos, (char)7, 0, 0);
  tpos ++;
  TraceSet(tr, tpos, (char)8, 0, 0);
  tpos ++;
  while (apos <= alen) {
    TraceSet(tr, tpos, (char)8, 0, apos);
    tpos ++;
    apos ++;
  }
  TraceSet(tr, tpos, (char)9, 0, 0);
  tpos ++;
  tr->tlen = tpos;
  return (tr);
}
}
void ImposeMasterTrace(char **aseq , int nseq , struct p7trace_s *mtr , struct p7trace_s ***ret_tr ) 
{ 
  struct p7trace_s **tr ;
  int idx ;
  int i___0 ;
  int tpos ;
  int mpos ;
  void *tmp ;

  {
  tmp = sre_malloc((char *)"trace.c", 1126, sizeof(struct p7trace_s *) * (unsigned long )nseq);
  tr = (struct p7trace_s **)tmp;
  idx = 0;
  while (idx < nseq) {
    P7AllocTrace(mtr->tlen, tr + idx);
    tpos = 0;
    i___0 = 1;
    mpos = 0;
    while (mpos < mtr->tlen) {
      switch ((int )*(mtr->statetype + mpos)) {
      case 9: 
      case 7: 
      case 2: 
      case 6: 
      case 4: 
      TraceSet(*(tr + idx), tpos, *(mtr->statetype + mpos), *(mtr->nodeidx + mpos),
               0);
      tpos ++;
      break;
      case 1: 
      if ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 32) {
        TraceSet(*(tr + idx), tpos, (char)2, *(mtr->nodeidx + mpos), 0);
      } else
      if ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 46) {
        TraceSet(*(tr + idx), tpos, (char)2, *(mtr->nodeidx + mpos), 0);
      } else
      if ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 95) {
        TraceSet(*(tr + idx), tpos, (char)2, *(mtr->nodeidx + mpos), 0);
      } else
      if ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 45) {
        TraceSet(*(tr + idx), tpos, (char)2, *(mtr->nodeidx + mpos), 0);
      } else
      if ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 126) {
        TraceSet(*(tr + idx), tpos, (char)2, *(mtr->nodeidx + mpos), 0);
      } else {
        TraceSet(*(tr + idx), tpos, (char)1, *(mtr->nodeidx + mpos), i___0);
        i___0 ++;
      }
      tpos ++;
      break;
      case 3: 
      if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 32)) {
        if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 46)) {
          if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 95)) {
            if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 45)) {
              if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 126)) {
                TraceSet(*(tr + idx), tpos, (char)3, *(mtr->nodeidx + mpos), i___0);
                i___0 ++;
                tpos ++;
              }
            }
          }
        }
      }
      break;
      case 8: 
      case 5: 
      case 10: 
      if (*(mtr->pos + mpos) == 0) {
        TraceSet(*(tr + idx), tpos, *(mtr->statetype + mpos), 0, 0);
        tpos ++;
      } else
      if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 32)) {
        if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 46)) {
          if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 95)) {
            if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 45)) {
              if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 126)) {
                TraceSet(*(tr + idx), tpos, *(mtr->statetype + mpos), 0, i___0);
                i___0 ++;
                tpos ++;
              }
            }
          }
        }
      }
      break;
      case 0: 
      Die((char *)"never happens. Trust me.");
      }
      mpos ++;
    }
    (*(tr + idx))->tlen = tpos;
    idx ++;
  }
  *ret_tr = tr;
  return;
}
}
static void rightjustify(char *s___0 , int n ) 
{ 
  int npos ;
  int opos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  npos = n - 1;
  opos = n - 1;
  while (opos >= 0) {
    if ((int )*(s___0 + opos) == 32) {
      opos --;
    } else
    if ((int )*(s___0 + opos) == 46) {
      opos --;
    } else
    if ((int )*(s___0 + opos) == 95) {
      opos --;
    } else
    if ((int )*(s___0 + opos) == 45) {
      opos --;
    } else
    if ((int )*(s___0 + opos) == 126) {
      opos --;
    } else {
      tmp = npos;
      npos --;
      tmp___0 = opos;
      opos --;
      *(s___0 + tmp) = *(s___0 + tmp___0);
    }
  }
  while (npos >= 0) {
    tmp___1 = npos;
    npos --;
    *(s___0 + tmp___1) = (char )'.';
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-sZ3uk33i.i","-O3")
static int (*qcmp)()  ;
static int qsz  ;
static int thresh  ;
static int mthresh  ;
static void qst(char *base , char *max ) ;
void specqsort(char *base , int n , int size , int (*compar)() ) 
{ 
  register char c ;
  register char *i___0 ;
  register char *j ;
  register char *lo ;
  register char *hi ;
  char *min ;
  char *max ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  if (n <= 1) {
    return;
  }
  qsz = size;
  qcmp = compar;
  thresh = qsz * 4;
  mthresh = qsz * 6;
  max = base + n * qsz;
  if (n >= 4) {
    qst(base, max);
    hi = base + thresh;
  } else {
    hi = max;
  }
  lo = base;
  j = lo;
  while (1) {
    lo += qsz;
    if (! ((unsigned long )lo < (unsigned long )hi)) {
      break;
    }
    tmp = (*qcmp)(j, lo);
    if (tmp > 0) {
      j = lo;
    }
  }
  if ((unsigned long )j != (unsigned long )base) {
    i___0 = base;
    hi = base + qsz;
    while ((unsigned long )i___0 < (unsigned long )hi) {
      c = *j;
      tmp___0 = j;
      j ++;
      *tmp___0 = *i___0;
      tmp___1 = i___0;
      i___0 ++;
      *tmp___1 = c;
    }
  }
  min = base;
  while (1) {
    min += qsz;
    hi = min;
    if (! ((unsigned long )hi < (unsigned long )max)) {
      break;
    }
    while (1) {
      hi -= qsz;
      tmp___2 = (*qcmp)(hi, min);
      if (! (tmp___2 > 0)) {
        break;
      }
    }
    hi += qsz;
    if ((unsigned long )hi != (unsigned long )min) {
      lo = min + qsz;
      while (1) {
        lo --;
        if (! ((unsigned long )lo >= (unsigned long )min)) {
          break;
        }
        c = *lo;
        j = lo;
        i___0 = j;
        while (1) {
          j -= qsz;
          if (! ((unsigned long )j >= (unsigned long )hi)) {
            break;
          }
          *i___0 = *j;
          i___0 = j;
        }
        *i___0 = c;
      }
    }
  }
  return;
}
}
static void qst(char *base , char *max ) 
{ 
  register char c ;
  register char *i___0 ;
  register char *j ;
  register char *jj ;
  register int ii ;
  char *mid ;
  char *tmp ;
  int lo ;
  int hi ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  lo = (int )(max - base);
  while (1) {
    i___0 = base + qsz * (lo / qsz >> 1);
    mid = i___0;
    if (lo >= mthresh) {
      jj = base;
      tmp___1 = (*qcmp)(jj, i___0);
      if (tmp___1 > 0) {
        j = jj;
      } else {
        j = i___0;
      }
      tmp = max - qsz;
      tmp___3 = (*qcmp)(j, tmp);
      if (tmp___3 > 0) {
        if ((unsigned long )j == (unsigned long )jj) {
          j = i___0;
        } else {
          j = jj;
        }
        tmp___2 = (*qcmp)(j, tmp);
        if (tmp___2 < 0) {
          j = tmp;
        }
      }
      if ((unsigned long )j != (unsigned long )i___0) {
        ii = qsz;
        while (1) {
          c = *i___0;
          tmp___4 = i___0;
          i___0 ++;
          *tmp___4 = *j;
          tmp___5 = j;
          j ++;
          *tmp___5 = c;
          ii --;
          if (! ii) {
            break;
          }
        }
      }
    }
    i___0 = base;
    j = max - qsz;
    while (1) {
      while (1) {
        if ((unsigned long )i___0 < (unsigned long )mid) {
          tmp___6 = (*qcmp)(i___0, mid);
          if (! (tmp___6 <= 0)) {
            break;
          }
        } else {
          break;
        }
        i___0 += qsz;
      }
      while ((unsigned long )j > (unsigned long )mid) {
        tmp___7 = (*qcmp)(mid, j);
        if (tmp___7 <= 0) {
          j -= qsz;
          continue;
        }
        tmp = i___0 + qsz;
        if ((unsigned long )i___0 == (unsigned long )mid) {
          jj = j;
          mid = jj;
        } else {
          jj = j;
          j -= qsz;
        }
        goto swap;
      }
      if ((unsigned long )i___0 == (unsigned long )mid) {
        break;
      } else {
        jj = mid;
        mid = i___0;
        tmp = mid;
        j -= qsz;
      }
      swap: 
      ii = qsz;
      while (1) {
        c = *i___0;
        tmp___8 = i___0;
        i___0 ++;
        *tmp___8 = *jj;
        tmp___9 = jj;
        jj ++;
        *tmp___9 = c;
        ii --;
        if (! ii) {
          break;
        }
      }
      i___0 = tmp;
    }
    j = mid;
    i___0 = j + qsz;
    lo = (int )(j - base);
    hi = (int )(max - i___0);
    if (lo <= hi) {
      if (lo >= thresh) {
        qst(base, j);
      }
      base = i___0;
      lo = hi;
    } else {
      if (hi >= thresh) {
        qst(i___0, max);
      }
      max = j;
    }
    if (! (lo >= thresh)) {
      break;
    }
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-CbPZkWLT.i","-O3")
int GKIStoreKey(GKI *hash , char *key ) ;
void MSAFree(MSA *msa ) ;
void MSAExpand(MSA *msa ) ;
char *MSAFileGetLine(MSAFILE *afp ) ;
void MSAVerifyParse(MSA *msa ) ;
MSA *ReadA2M(MSAFILE *afp ) ;
void WriteA2M(FILE *fp , MSA *msa ) ;
int sre_strcat(char **dest , int ldest , char *src , int lsrc ) ;
char *sre_strtok(char **s___0 , char *delim , int *len ) ;
MSA *ReadA2M(MSAFILE *afp ) 
{ 
  MSA *msa ;
  char *buf ;
  char *name ;
  char *desc ;
  char *seq ;
  int idx ;
  int len1 ;
  int len2 ;
  int tmp ;

  {
  tmp = feof(afp->f);
  if (tmp) {
    return ((MSA *)((void *)0));
  }
  name = (char *)((void *)0);
  msa = MSAAlloc(10, 0);
  idx = 0;
  while (1) {
    buf = MSAFileGetLine(afp);
    if (! ((unsigned long )buf != (unsigned long )((void *)0))) {
      break;
    }
    if ((int )*buf == 62) {
      buf ++;
      name = sre_strtok(& buf, (char *)" \t\n", & len1);
      if ((unsigned long )name == (unsigned long )((void *)0)) {
        Die((char *)"Blank name in A2M file %s (line %d)\n", afp->fname, afp->linenumber);
      }
      desc = sre_strtok(& buf, (char *)"\n", & len2);
      idx = GKIStoreKey(msa->index, name);
      if (idx >= msa->nseqalloc) {
        MSAExpand(msa);
      }
      *(msa->sqname + idx) = sre_strdup(name, len1);
      if ((unsigned long )desc != (unsigned long )((void *)0)) {
        MSASetSeqDescription(msa, idx, desc);
      }
      (msa->nseq) ++;
    } else
    if ((unsigned long )name != (unsigned long )((void *)0)) {
      seq = sre_strtok(& buf, (char *)" \t\n", & len1);
      if ((unsigned long )seq == (unsigned long )((void *)0)) {
        continue;
      }
      *(msa->sqlen + idx) = sre_strcat(msa->aseq + idx, *(msa->sqlen + idx), seq,
                                       len1);
    }
  }
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    MSAFree(msa);
    return ((MSA *)((void *)0));
  }
  MSAVerifyParse(msa);
  return (msa);
}
}
void WriteA2M(FILE *fp , MSA *msa ) 
{ 
  int idx ;
  int pos ;
  char buf[64] ;
  int cpl ;
  char const   *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  cpl = 60;
  buf[cpl] = (char )'\000';
  idx = 0;
  while (idx < msa->nseq) {
    if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
      if ((unsigned long )*(msa->sqdesc + idx) != (unsigned long )((void *)0)) {
        tmp = (char const   *)*(msa->sqdesc + idx);
      } else {
        tmp = "";
      }
    } else {
      tmp = "";
    }
    fprintf(fp, ">%s %s\n", *(msa->sqname + idx), tmp);
    pos = 0;
    while (pos < msa->alen) {
      tmp___1 = __builtin_object_size((void *)(buf), 0);
      if (tmp___1 != 0xffffffffffffffffUL) {
        tmp___0 = __builtin_object_size((void *)(buf), 1);
        __builtin___strncpy_chk(buf, (char const   *)(*(msa->aseq + idx) + pos), (unsigned long )cpl,
                                tmp___0);
      } else {
        __inline_strncpy_chk(buf, (char const   *)(*(msa->aseq + idx) + pos), (size_t )cpl);
      }
      fprintf(fp, "%s\n", buf);
      pos += cpl;
    }
    idx ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Rtk9fzjQ.i","-O3")
__inline static int isalpha(int _c ) 
{ 
  int tmp ;

  {
  tmp = __istype(_c, 256UL);
  return (tmp);
}
}
float ComparePairAlignments(char *known1 , char *known2 , char *calc1 , char *calc2 ) ;
float CompareRefPairAlignments(int *ref , char *known1 , char *known2 , char *calc1 ,
                               char *calc2 ) ;
float CompareMultAlignments(char **kseqs , char **tseqs , int N ) ;
float CompareRefMultAlignments(int *ref , char **kseqs , char **tseqs , int N ) ;
float PairwiseIdentity(char *s1 , char *s2 ) ;
float AlignmentIdentityBySampling(char **aseq , int L , int N , int nsample ) ;
char *MajorityRuleConsensus(char **aseq , int nseq , int alen ) ;
static int make_alilist(char *s1 , char *s2 , int **ret_s1_list , int *ret_listlen ) ;
static int make_ref_alilist(int *ref , char *k1 , char *k2 , char *s1 , char *s2 ,
                            int **ret_s1_list , int *ret_listlen ) ;
static int compare_lists(int *k1 , int *k2 , int *t1 , int *t2 , int len1 , int len2 ,
                         float *ret_sc ) ;
float ComparePairAlignments(char *known1 , char *known2 , char *calc1 , char *calc2 ) 
{ 
  int *klist1 ;
  int *klist2 ;
  int *tlist1 ;
  int *tlist2 ;
  int len1 ;
  int len2 ;
  float score ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = make_alilist(calc1, calc2, & tlist1, & len1);
  if (! tmp) {
    return ((float )(- 1.0));
  }
  tmp___0 = make_alilist(calc2, calc1, & tlist2, & len2);
  if (! tmp___0) {
    return ((float )(- 1.0));
  }
  tmp___1 = make_alilist(known1, known2, & klist1, & len1);
  if (! tmp___1) {
    return ((float )(- 1.0));
  }
  tmp___2 = make_alilist(known2, known1, & klist2, & len2);
  if (! tmp___2) {
    return ((float )(- 1.0));
  }
  tmp___3 = compare_lists(klist1, klist2, tlist1, tlist2, len1, len2, & score);
  if (! tmp___3) {
    return ((float )(- 1.0));
  }
  free((void *)klist1);
  free((void *)klist2);
  free((void *)tlist1);
  free((void *)tlist2);
  return (score);
}
}
float CompareRefPairAlignments(int *ref , char *known1 , char *known2 , char *calc1 ,
                               char *calc2 ) 
{ 
  int *klist1 ;
  int *klist2 ;
  int *tlist1 ;
  int *tlist2 ;
  int len1 ;
  int len2 ;
  float score ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = make_ref_alilist(ref, known1, known2, calc1, calc2, & tlist1, & len1);
  if (! tmp) {
    return ((float )(- 1.0));
  }
  tmp___0 = make_ref_alilist(ref, known2, known1, calc2, calc1, & tlist2, & len2);
  if (! tmp___0) {
    return ((float )(- 1.0));
  }
  tmp___1 = make_ref_alilist(ref, known1, known2, known1, known2, & klist1, & len1);
  if (! tmp___1) {
    return ((float )(- 1.0));
  }
  tmp___2 = make_ref_alilist(ref, known2, known1, known2, known1, & klist2, & len2);
  if (! tmp___2) {
    return ((float )(- 1.0));
  }
  tmp___3 = compare_lists(klist1, klist2, tlist1, tlist2, len1, len2, & score);
  if (! tmp___3) {
    return ((float )(- 1.0));
  }
  free((void *)klist1);
  free((void *)klist2);
  free((void *)tlist1);
  free((void *)tlist2);
  return (score);
}
}
static int make_alilist(char *s1 , char *s2 , int **ret_s1_list , int *ret_listlen ) 
{ 
  int *s1_list ;
  int col ;
  int r1 ;
  int r2 ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)s1);
  tmp___0 = sre_malloc((char *)"aligneval.c", 179, sizeof(int ) * tmp);
  s1_list = (int *)tmp___0;
  r2 = 0;
  r1 = r2;
  col = 0;
  while ((int )*(s1 + col) != 0) {
    if (! ((int )*(s1 + col) == 32)) {
      if (! ((int )*(s1 + col) == 46)) {
        if (! ((int )*(s1 + col) == 95)) {
          if (! ((int )*(s1 + col) == 45)) {
            if (! ((int )*(s1 + col) == 126)) {
              if ((int )*(s2 + col) == 32) {
                *(s1_list + r1) = -1;
              } else
              if ((int )*(s2 + col) == 46) {
                *(s1_list + r1) = -1;
              } else
              if ((int )*(s2 + col) == 95) {
                *(s1_list + r1) = -1;
              } else
              if ((int )*(s2 + col) == 45) {
                *(s1_list + r1) = -1;
              } else
              if ((int )*(s2 + col) == 126) {
                *(s1_list + r1) = -1;
              } else {
                *(s1_list + r1) = r2;
              }
              r1 ++;
            }
          }
        }
      }
    }
    if (! ((int )*(s2 + col) == 32)) {
      if (! ((int )*(s2 + col) == 46)) {
        if (! ((int )*(s2 + col) == 95)) {
          if (! ((int )*(s2 + col) == 45)) {
            if (! ((int )*(s2 + col) == 126)) {
              r2 ++;
            }
          }
        }
      }
    }
    col ++;
  }
  *ret_listlen = r1;
  *ret_s1_list = s1_list;
  return (1);
}
}
static int make_ref_alilist(int *ref , char *k1 , char *k2 , char *s1 , char *s2 ,
                            int **ret_s1_list , int *ret_listlen ) 
{ 
  int *s1_list ;
  int col ;
  int r1 ;
  int r2 ;
  int *canons1 ;
  int lpos ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  tmp = strlen((char const   *)s1);
  tmp___0 = sre_malloc((char *)"aligneval.c", 236, sizeof(int ) * tmp);
  s1_list = (int *)tmp___0;
  tmp___1 = strlen((char const   *)s1);
  tmp___2 = sre_malloc((char *)"aligneval.c", 237, sizeof(int ) * tmp___1);
  canons1 = (int *)tmp___2;
  r1 = 0;
  col = 0;
  while ((int )*(k1 + col) != 0) {
    if (! ((int )*(k1 + col) == 32)) {
      if (! ((int )*(k1 + col) == 46)) {
        if (! ((int )*(k1 + col) == 95)) {
          if (! ((int )*(k1 + col) == 45)) {
            if (! ((int )*(k1 + col) == 126)) {
              if (*(ref + col)) {
                *(canons1 + r1) = 1;
              } else {
                *(canons1 + r1) = 0;
              }
              r1 ++;
            }
          }
        }
      }
    }
    col ++;
  }
  lpos = 0;
  r2 = lpos;
  r1 = r2;
  col = 0;
  while ((int )*(s1 + col) != 0) {
    if (! ((int )*(s1 + col) == 32)) {
      if (! ((int )*(s1 + col) == 46)) {
        if (! ((int )*(s1 + col) == 95)) {
          if (! ((int )*(s1 + col) == 45)) {
            if (! ((int )*(s1 + col) == 126)) {
              if (*(canons1 + r1)) {
                if ((int )*(s2 + col) == 32) {
                  *(s1_list + lpos) = -1;
                } else
                if ((int )*(s2 + col) == 46) {
                  *(s1_list + lpos) = -1;
                } else
                if ((int )*(s2 + col) == 95) {
                  *(s1_list + lpos) = -1;
                } else
                if ((int )*(s2 + col) == 45) {
                  *(s1_list + lpos) = -1;
                } else
                if ((int )*(s2 + col) == 126) {
                  *(s1_list + lpos) = -1;
                } else {
                  *(s1_list + lpos) = r2;
                }
                lpos ++;
              }
            }
          }
        }
      }
    }
    if (! ((int )*(s1 + col) == 32)) {
      if (! ((int )*(s1 + col) == 46)) {
        if (! ((int )*(s1 + col) == 95)) {
          if (! ((int )*(s1 + col) == 45)) {
            if (! ((int )*(s1 + col) == 126)) {
              r1 ++;
            }
          }
        }
      }
    }
    if (! ((int )*(s2 + col) == 32)) {
      if (! ((int )*(s2 + col) == 46)) {
        if (! ((int )*(s2 + col) == 95)) {
          if (! ((int )*(s2 + col) == 45)) {
            if (! ((int )*(s2 + col) == 126)) {
              r2 ++;
            }
          }
        }
      }
    }
    col ++;
  }
  free((void *)canons1);
  *ret_listlen = lpos;
  *ret_s1_list = s1_list;
  return (1);
}
}
static int compare_lists(int *k1 , int *k2 , int *t1 , int *t2 , int len1 , int len2 ,
                         float *ret_sc ) 
{ 
  float id ;
  float tot ;
  int i___0 ;

  {
  tot = (float )0.0;
  id = tot;
  i___0 = 0;
  while (i___0 < len1) {
    tot = (float )((double )tot + 1.0);
    if (*(t1 + i___0) == *(k1 + i___0)) {
      id = (float )((double )id + 1.0);
    }
    i___0 ++;
  }
  i___0 = 0;
  while (i___0 < len2) {
    tot = (float )((double )tot + 1.0);
    if (*(k2 + i___0) == *(t2 + i___0)) {
      id = (float )((double )id + 1.0);
    }
    i___0 ++;
  }
  *ret_sc = id / tot;
  return (1);
}
}
float CompareMultAlignments(char **kseqs , char **tseqs , int N ) 
{ 
  int i___0 ;
  int j ;
  float score ;
  float tot_score ;

  {
  tot_score = (float )0.0;
  i___0 = 0;
  while (i___0 < N) {
    j = i___0 + 1;
    while (j < N) {
      score = ComparePairAlignments(*(kseqs + i___0), *(kseqs + j), *(tseqs + i___0),
                                    *(tseqs + j));
      if ((double )score < 0.0) {
        return ((float )(- 1.0));
      }
      tot_score += score;
      j ++;
    }
    i___0 ++;
  }
  return ((float )(((double )tot_score * 2.0) / ((double )((float )N) * ((double )((float )N) - 1.0))));
}
}
float CompareRefMultAlignments(int *ref , char **kseqs , char **tseqs , int N ) 
{ 
  int i___0 ;
  int j ;
  float score ;
  float tot_score ;

  {
  tot_score = (float )0.0;
  i___0 = 0;
  while (i___0 < N) {
    j = i___0 + 1;
    while (j < N) {
      score = CompareRefPairAlignments(ref, *(kseqs + i___0), *(kseqs + j), *(tseqs + i___0),
                                       *(tseqs + j));
      if ((double )score < 0.0) {
        return ((float )(- 1.0));
      }
      tot_score += score;
      j ++;
    }
    i___0 ++;
  }
  return ((float )(((double )tot_score * 2.0) / ((double )((float )N) * ((double )((float )N) - 1.0))));
}
}
float PairwiseIdentity(char *s1 , char *s2 ) 
{ 
  int idents ;
  int len1 ;
  int len2 ;
  int x ;
  double tmp ;

  {
  len2 = 0;
  len1 = len2;
  idents = len1;
  x = 0;
  while (1) {
    if ((int )*(s1 + x) != 0) {
      if (! ((int )*(s2 + x) != 0)) {
        break;
      }
    } else {
      break;
    }
    if (! ((int )*(s1 + x) == 32)) {
      if (! ((int )*(s1 + x) == 46)) {
        if (! ((int )*(s1 + x) == 95)) {
          if (! ((int )*(s1 + x) == 45)) {
            if (! ((int )*(s1 + x) == 126)) {
              len1 ++;
              if ((int )*(s1 + x) == (int )*(s2 + x)) {
                idents ++;
              }
            }
          }
        }
      }
    }
    if (! ((int )*(s2 + x) == 32)) {
      if (! ((int )*(s2 + x) == 46)) {
        if (! ((int )*(s2 + x) == 95)) {
          if (! ((int )*(s2 + x) == 45)) {
            if (! ((int )*(s2 + x) == 126)) {
              len2 ++;
            }
          }
        }
      }
    }
    x ++;
  }
  if (len2 < len1) {
    len1 = len2;
  }
  if (len1 == 0) {
    tmp = 0.0;
  } else {
    tmp = (double )((float )idents / (float )len1);
  }
  return ((float )tmp);
}
}
float AlignmentIdentityBySampling(char **aseq , int L , int N , int nsample ) 
{ 
  int x ;
  int i___0 ;
  int j ;
  float sum ;
  double tmp ;
  double tmp___0 ;
  float tmp___1 ;

  {
  if (N < 2) {
    return ((float )1.0);
  }
  sum = (float )0.;
  x = 0;
  while (x < nsample) {
    tmp = sre_random();
    i___0 = (int )(tmp * (double )N);
    while (1) {
      tmp___0 = sre_random();
      j = (int )(tmp___0 * (double )N);
      if (! (j == i___0)) {
        break;
      }
    }
    tmp___1 = PairwiseIdentity(*(aseq + i___0), *(aseq + j));
    sum += tmp___1;
    x ++;
  }
  return (sum / (float )nsample);
}
}
char *MajorityRuleConsensus(char **aseq , int nseq , int alen ) 
{ 
  char *cs ;
  int count[27] ;
  int idx ;
  int apos ;
  int spos ;
  int x ;
  int sym ;
  int max ;
  int bestx ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = sre_malloc((char *)"aligneval.c", 485, sizeof(char ) * (unsigned long )(alen + 1));
  cs = (char *)tmp;
  spos = 0;
  apos = 0;
  while (apos < alen) {
    x = 0;
    while (x < 27) {
      count[x] = 0;
      x ++;
    }
    idx = 0;
    while (idx < nseq) {
      tmp___0 = isalpha((int )*(*(aseq + idx) + apos));
      if (tmp___0) {
        sym = toupper((int )*(*(aseq + idx) + apos));
        (count[sym - 65]) ++;
      } else {
        (count[26]) ++;
      }
      idx ++;
    }
    if ((double )((float )count[26] / (float )nseq) <= 0.5) {
      bestx = -1;
      max = bestx;
      x = 0;
      while (x < 26) {
        if (count[x] > max) {
          max = count[x];
          bestx = x;
        }
        x ++;
      }
      tmp___1 = spos;
      spos ++;
      *(cs + tmp___1) = (char )(65 + bestx);
    }
    apos ++;
  }
  *(cs + spos) = (char )'\000';
  return (cs);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-5bHAzxZ0.i","-O3")
int squid_errno ;
void AllocAlignment(int nseq , int alen , char ***ret_aseq , AINFO *ainfo ) ;
void InitAinfo(AINFO *ainfo ) ;
void FreeAlignment(char **aseqs , AINFO *ainfo ) ;
void SAMizeAlignment(char **aseq , int nseq , int alen ) ;
void SAMizeAlignmentByGapFrac(char **aseq , int nseq , int alen , float maxgap ) ;
int MakeDealignedString(char *aseq , int alen , char *ss , char **ret_s ) ;
int WritePairwiseAlignment(FILE *ofp , char *aseq1 , char *name1 , int spos1 , char *aseq2 ,
                           char *name2 , int spos2 , int **pam , int indent ) ;
int MingapAlignment(char **aseqs , AINFO *ainfo ) ;
int RandomAlignment(char **rseqs , SQINFO *sqinfo , int nseq , float pop , float pex ,
                    char ***ret_aseqs , AINFO *ainfo ) ;
void AlignmentHomogenousGapsym(char **aseq , int nseq , int alen , char gapsym ) ;
void SeqinfoCopy(SQINFO *sq1 , SQINFO *sq2 ) ;
void AllocAlignment(int nseq , int alen , char ***ret_aseq , AINFO *ainfo ) 
{ 
  char **aseq ;
  int idx ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  InitAinfo(ainfo);
  tmp = sre_malloc((char *)"alignio.c", 50, sizeof(char *) * (unsigned long )nseq);
  aseq = (char **)tmp;
  idx = 0;
  while (idx < nseq) {
    tmp___0 = sre_malloc((char *)"alignio.c", 52, sizeof(char ) * (unsigned long )(alen + 1));
    *(aseq + idx) = (char *)tmp___0;
    idx ++;
  }
  ainfo->alen = alen;
  ainfo->nseq = nseq;
  tmp___1 = sre_malloc((char *)"alignio.c", 57, sizeof(float ) * (unsigned long )nseq);
  ainfo->wgt = (float *)tmp___1;
  FSet(ainfo->wgt, nseq, (float )1.0);
  tmp___2 = sre_malloc((char *)"alignio.c", 60, sizeof(SQINFO ) * (unsigned long )nseq);
  ainfo->sqinfo = (SQINFO *)tmp___2;
  idx = 0;
  while (idx < nseq) {
    (ainfo->sqinfo + idx)->flags = 0;
    idx ++;
  }
  *ret_aseq = aseq;
  return;
}
}
void InitAinfo(AINFO *ainfo ) 
{ 
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;

  {
  ainfo->name = (char *)((void *)0);
  ainfo->desc = (char *)((void *)0);
  ainfo->cs = (char *)((void *)0);
  ainfo->rf = (char *)((void *)0);
  ainfo->acc = (char *)((void *)0);
  ainfo->au = (char *)((void *)0);
  ainfo->flags = 0;
  tmp = (float )0.0;
  ainfo->tc2 = tmp;
  ainfo->tc1 = tmp;
  tmp___0 = (float )0.0;
  ainfo->nc2 = tmp___0;
  ainfo->nc1 = tmp___0;
  tmp___1 = (float )0.0;
  ainfo->ga2 = tmp___1;
  ainfo->ga1 = tmp___1;
  return;
}
}
void FreeAlignment(char **aseqs , AINFO *ainfo ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  while (i___0 < ainfo->nseq) {
    if ((ainfo->sqinfo + i___0)->flags & (1 << 9)) {
      free((void *)(ainfo->sqinfo + i___0)->ss);
    }
    if ((ainfo->sqinfo + i___0)->flags & (1 << 10)) {
      free((void *)(ainfo->sqinfo + i___0)->sa);
    }
    i___0 ++;
  }
  if ((unsigned long )ainfo->cs != (unsigned long )((void *)0)) {
    free((void *)ainfo->cs);
  }
  if ((unsigned long )ainfo->rf != (unsigned long )((void *)0)) {
    free((void *)ainfo->rf);
  }
  if ((unsigned long )ainfo->name != (unsigned long )((void *)0)) {
    free((void *)ainfo->name);
  }
  if ((unsigned long )ainfo->desc != (unsigned long )((void *)0)) {
    free((void *)ainfo->desc);
  }
  if ((unsigned long )ainfo->acc != (unsigned long )((void *)0)) {
    free((void *)ainfo->acc);
  }
  if ((unsigned long )ainfo->au != (unsigned long )((void *)0)) {
    free((void *)ainfo->au);
  }
  free((void *)ainfo->sqinfo);
  free((void *)ainfo->wgt);
  Free2DArray((void **)aseqs, ainfo->nseq);
  return;
}
}
void SAMizeAlignment(char **aseq , int nseq , int alen ) 
{ 
  int col ;
  int i___0 ;
  int sawlower ;
  int sawupper ;
  int sawgap ;
  char gapchar ;
  int tmp ;
  int tmp___0 ;

  {
  col = 0;
  while (col < alen) {
    sawgap = 0;
    sawupper = sawgap;
    sawlower = sawupper;
    i___0 = 0;
    while (i___0 < nseq) {
      if ((int )*(*(aseq + i___0) + col) == 32) {
        sawgap = 1;
        goto __Cont;
      } else
      if ((int )*(*(aseq + i___0) + col) == 46) {
        sawgap = 1;
        goto __Cont;
      } else
      if ((int )*(*(aseq + i___0) + col) == 95) {
        sawgap = 1;
        goto __Cont;
      } else
      if ((int )*(*(aseq + i___0) + col) == 45) {
        sawgap = 1;
        goto __Cont;
      } else
      if ((int )*(*(aseq + i___0) + col) == 126) {
        sawgap = 1;
        goto __Cont;
      }
      tmp = isupper((int )*(*(aseq + i___0) + col));
      if (tmp) {
        sawupper = 1;
        goto __Cont;
      }
      tmp___0 = islower((int )*(*(aseq + i___0) + col));
      if (tmp___0) {
        sawlower = 1;
      }
      __Cont: /* CIL Label */ 
      i___0 ++;
    }
    gapchar = (char )'-';
    if (sawlower) {
      if (! sawupper) {
        gapchar = (char )'.';
      }
    }
    i___0 = 0;
    while (i___0 < nseq) {
      if ((int )*(*(aseq + i___0) + col) == 32) {
        *(*(aseq + i___0) + col) = gapchar;
      } else
      if ((int )*(*(aseq + i___0) + col) == 46) {
        *(*(aseq + i___0) + col) = gapchar;
      } else
      if ((int )*(*(aseq + i___0) + col) == 95) {
        *(*(aseq + i___0) + col) = gapchar;
      } else
      if ((int )*(*(aseq + i___0) + col) == 45) {
        *(*(aseq + i___0) + col) = gapchar;
      } else
      if ((int )*(*(aseq + i___0) + col) == 126) {
        *(*(aseq + i___0) + col) = gapchar;
      }
      i___0 ++;
    }
    col ++;
  }
  return;
}
}
void SAMizeAlignmentByGapFrac(char **aseq , int nseq , int alen , float maxgap ) 
{ 
  int apos ;
  int idx ;
  int ngap ;
  int tmp ;
  int tmp___0 ;

  {
  apos = 0;
  while (apos < alen) {
    ngap = 0;
    idx = 0;
    while (idx < nseq) {
      if ((int )*(*(aseq + idx) + apos) == 32) {
        ngap ++;
      } else
      if ((int )*(*(aseq + idx) + apos) == 46) {
        ngap ++;
      } else
      if ((int )*(*(aseq + idx) + apos) == 95) {
        ngap ++;
      } else
      if ((int )*(*(aseq + idx) + apos) == 45) {
        ngap ++;
      } else
      if ((int )*(*(aseq + idx) + apos) == 126) {
        ngap ++;
      }
      idx ++;
    }
    if ((float )ngap / (float )nseq > maxgap) {
      idx = 0;
      while (idx < nseq) {
        if ((int )*(*(aseq + idx) + apos) == 32) {
          *(*(aseq + idx) + apos) = (char )'.';
        } else
        if ((int )*(*(aseq + idx) + apos) == 46) {
          *(*(aseq + idx) + apos) = (char )'.';
        } else
        if ((int )*(*(aseq + idx) + apos) == 95) {
          *(*(aseq + idx) + apos) = (char )'.';
        } else
        if ((int )*(*(aseq + idx) + apos) == 45) {
          *(*(aseq + idx) + apos) = (char )'.';
        } else
        if ((int )*(*(aseq + idx) + apos) == 126) {
          *(*(aseq + idx) + apos) = (char )'.';
        } else {
          tmp = tolower((int )*(*(aseq + idx) + apos));
          *(*(aseq + idx) + apos) = (char )tmp;
        }
        idx ++;
      }
    } else {
      idx = 0;
      while (idx < nseq) {
        if ((int )*(*(aseq + idx) + apos) == 32) {
          *(*(aseq + idx) + apos) = (char )'-';
        } else
        if ((int )*(*(aseq + idx) + apos) == 46) {
          *(*(aseq + idx) + apos) = (char )'-';
        } else
        if ((int )*(*(aseq + idx) + apos) == 95) {
          *(*(aseq + idx) + apos) = (char )'-';
        } else
        if ((int )*(*(aseq + idx) + apos) == 45) {
          *(*(aseq + idx) + apos) = (char )'-';
        } else
        if ((int )*(*(aseq + idx) + apos) == 126) {
          *(*(aseq + idx) + apos) = (char )'-';
        } else {
          tmp___0 = toupper((int )*(*(aseq + idx) + apos));
          *(*(aseq + idx) + apos) = (char )tmp___0;
        }
        idx ++;
      }
    }
    apos ++;
  }
  return;
}
}
int MakeAlignedString(char *aseq , int alen , char *ss , char **ret_s ) 
{ 
  char *new ;
  int apos ;
  int rpos ;
  void *tmp ;
  size_t tmp___0 ;

  {
  tmp = sre_malloc((char *)"alignio.c", 242, (unsigned long )(alen + 1) * sizeof(char ));
  new = (char *)tmp;
  rpos = 0;
  apos = rpos;
  while (apos < alen) {
    if ((int )*(aseq + apos) == 32) {
      *(new + apos) = (char )'.';
    } else
    if ((int )*(aseq + apos) == 46) {
      *(new + apos) = (char )'.';
    } else
    if ((int )*(aseq + apos) == 95) {
      *(new + apos) = (char )'.';
    } else
    if ((int )*(aseq + apos) == 45) {
      *(new + apos) = (char )'.';
    } else
    if ((int )*(aseq + apos) == 126) {
      *(new + apos) = (char )'.';
    } else {
      *(new + apos) = *(ss + rpos);
      rpos ++;
    }
    apos ++;
  }
  *(new + apos) = (char )'\000';
  tmp___0 = strlen((char const   *)ss);
  if ((size_t )rpos != tmp___0) {
    squid_errno = 6;
    free((void *)new);
    return (0);
  }
  *ret_s = new;
  return (1);
}
}
int MakeDealignedString(char *aseq , int alen , char *ss , char **ret_s ) 
{ 
  char *new ;
  int apos ;
  int rpos ;
  void *tmp ;
  size_t tmp___0 ;

  {
  tmp = sre_malloc((char *)"alignio.c", 280, (unsigned long )(alen + 1) * sizeof(char ));
  new = (char *)tmp;
  rpos = 0;
  apos = rpos;
  while (apos < alen) {
    if (! ((int )*(aseq + apos) == 32)) {
      if (! ((int )*(aseq + apos) == 46)) {
        if (! ((int )*(aseq + apos) == 95)) {
          if (! ((int )*(aseq + apos) == 45)) {
            if (! ((int )*(aseq + apos) == 126)) {
              *(new + rpos) = *(ss + apos);
              rpos ++;
            }
          }
        }
      }
    }
    apos ++;
  }
  *(new + rpos) = (char )'\000';
  tmp___0 = strlen((char const   *)ss);
  if ((size_t )alen != tmp___0) {
    squid_errno = 6;
    free((void *)new);
    return (0);
  }
  *ret_s = new;
  return (1);
}
}
int DealignedLength(char *aseq ) 
{ 
  int rlen ;

  {
  rlen = 0;
  while (*aseq) {
    if (! ((int )*aseq == 32)) {
      if (! ((int )*aseq == 46)) {
        if (! ((int )*aseq == 95)) {
          if (! ((int )*aseq == 45)) {
            if (! ((int )*aseq == 126)) {
              rlen ++;
            }
          }
        }
      }
    }
    aseq ++;
  }
  return (rlen);
}
}
int WritePairwiseAlignment(FILE *ofp , char *aseq1 , char *name1 , int spos1 , char *aseq2 ,
                           char *name2 , int spos2 , int **pam , int indent ) 
{ 
  char sname1[11] ;
  char sname2[11] ;
  int still_going ;
  char buf1[61] ;
  char bufmid[61] ;
  char buf2[61] ;
  char *s1 ;
  char *s2 ;
  int count1 ;
  int count2 ;
  int rpos1 ;
  int rpos2 ;
  int rawcount1 ;
  int rawcount2 ;
  int apos ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  tmp___0 = __builtin_object_size((void *)(sname1), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(sname1), 1);
    __builtin___strncpy_chk(sname1, (char const   *)name1, 10UL, tmp);
  } else {
    __inline_strncpy_chk(sname1, (char const   *)name1, (size_t )10);
  }
  sname1[10] = (char )'\000';
  strtok(sname1, " \t\n");
  tmp___2 = __builtin_object_size((void *)(sname2), 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)(sname2), 1);
    __builtin___strncpy_chk(sname2, (char const   *)name2, 10UL, tmp___1);
  } else {
    __inline_strncpy_chk(sname2, (char const   *)name2, (size_t )10);
  }
  sname2[10] = (char )'\000';
  strtok(sname2, " \t\n");
  s1 = aseq1;
  s2 = aseq2;
  rpos1 = spos1;
  rpos2 = spos2;
  still_going = 1;
  while (still_going) {
    still_going = 0;
    tmp___4 = __builtin_object_size((void *)(buf1), 0);
    if (tmp___4 != 0xffffffffffffffffUL) {
      tmp___3 = __builtin_object_size((void *)(buf1), 1);
      __builtin___strncpy_chk(buf1, (char const   *)s1, 60UL, tmp___3);
    } else {
      __inline_strncpy_chk(buf1, (char const   *)s1, (size_t )60);
    }
    buf1[60] = (char )'\000';
    tmp___6 = __builtin_object_size((void *)(buf2), 0);
    if (tmp___6 != 0xffffffffffffffffUL) {
      tmp___5 = __builtin_object_size((void *)(buf2), 1);
      __builtin___strncpy_chk(buf2, (char const   *)s2, 60UL, tmp___5);
    } else {
      __inline_strncpy_chk(buf2, (char const   *)s2, (size_t )60);
    }
    buf2[60] = (char )'\000';
    tmp___7 = strlen((char const   *)(buf1));
    count1 = (int )tmp___7;
    tmp___8 = strlen((char const   *)(buf2));
    count2 = (int )tmp___8;
    if (count1 == 60) {
      if ((int )*(s1 + 60) != 0) {
        still_going = 1;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (count2 == 60) {
      if ((int )*(s2 + 60) != 0) {
        still_going = 1;
      }
    }
    s1 += count1;
    s2 += count2;
    apos = 0;
    while (1) {
      if (apos < count1) {
        if (! (apos < count2)) {
          break;
        }
      } else {
        break;
      }
      if ((int )buf1[apos] == 32) {
        bufmid[apos] = (char )' ';
      } else
      if ((int )buf1[apos] == 46) {
        bufmid[apos] = (char )' ';
      } else
      if ((int )buf1[apos] == 95) {
        bufmid[apos] = (char )' ';
      } else
      if ((int )buf1[apos] == 45) {
        bufmid[apos] = (char )' ';
      } else
      if ((int )buf1[apos] == 126) {
        bufmid[apos] = (char )' ';
      } else
      if ((int )buf2[apos] == 32) {
        bufmid[apos] = (char )' ';
      } else
      if ((int )buf2[apos] == 46) {
        bufmid[apos] = (char )' ';
      } else
      if ((int )buf2[apos] == 95) {
        bufmid[apos] = (char )' ';
      } else
      if ((int )buf2[apos] == 45) {
        bufmid[apos] = (char )' ';
      } else
      if ((int )buf2[apos] == 126) {
        bufmid[apos] = (char )' ';
      } else
      if ((int )buf1[apos] == (int )buf2[apos]) {
        bufmid[apos] = buf1[apos];
      } else
      if (*(*(pam + ((int )buf1[apos] - 65)) + ((int )buf2[apos] - 65)) > 0) {
        bufmid[apos] = (char )'+';
      } else {
        bufmid[apos] = (char )' ';
      }
      apos ++;
    }
    bufmid[apos] = (char )'\000';
    rawcount1 = 0;
    apos = 0;
    while (apos < count1) {
      if (! ((int )buf1[apos] == 32)) {
        if (! ((int )buf1[apos] == 46)) {
          if (! ((int )buf1[apos] == 95)) {
            if (! ((int )buf1[apos] == 45)) {
              if (! ((int )buf1[apos] == 126)) {
                rawcount1 ++;
              }
            }
          }
        }
      }
      apos ++;
    }
    rawcount2 = 0;
    apos = 0;
    while (apos < count2) {
      if (! ((int )buf2[apos] == 32)) {
        if (! ((int )buf2[apos] == 46)) {
          if (! ((int )buf2[apos] == 95)) {
            if (! ((int )buf2[apos] == 45)) {
              if (! ((int )buf2[apos] == 126)) {
                rawcount2 ++;
              }
            }
          }
        }
      }
      apos ++;
    }
    fprintf(ofp, "%*s%-10.10s %5d %s %5d\n", indent, "", sname1, rpos1, buf1, (rpos1 + rawcount1) - 1);
    fprintf(ofp, "%*s                 %s\n", indent, "", bufmid);
    fprintf(ofp, "%*s%-10.10s %5d %s %5d\n", indent, "", sname2, rpos2, buf2, (rpos2 + rawcount2) - 1);
    fprintf(ofp, "\n");
    rpos1 += rawcount1;
    rpos2 += rawcount2;
  }
  return (1);
}
}
int MingapAlignment(char **aseqs , AINFO *ainfo ) 
{ 
  int apos ;
  int mpos ;
  int idx ;

  {
  apos = 0;
  mpos = 0;
  while ((int )*(*(aseqs + 0) + apos) != 0) {
    idx = 0;
    while (idx < ainfo->nseq) {
      if (! ((int )*(*(aseqs + idx) + apos) == 32)) {
        if (! ((int )*(*(aseqs + idx) + apos) == 46)) {
          if (! ((int )*(*(aseqs + idx) + apos) == 95)) {
            if (! ((int )*(*(aseqs + idx) + apos) == 45)) {
              if (! ((int )*(*(aseqs + idx) + apos) == 126)) {
                break;
              }
            }
          }
        }
      }
      idx ++;
    }
    if (idx == ainfo->nseq) {
      goto __Cont;
    }
    if (mpos != apos) {
      idx = 0;
      while (idx < ainfo->nseq) {
        *(*(aseqs + idx) + mpos) = *(*(aseqs + idx) + apos);
        idx ++;
      }
      if ((unsigned long )ainfo->cs != (unsigned long )((void *)0)) {
        *(ainfo->cs + mpos) = *(ainfo->cs + apos);
      }
      if ((unsigned long )ainfo->rf != (unsigned long )((void *)0)) {
        *(ainfo->rf + mpos) = *(ainfo->rf + apos);
      }
    }
    mpos ++;
    __Cont: /* CIL Label */ 
    apos ++;
  }
  idx = 0;
  while (idx < ainfo->nseq) {
    *(*(aseqs + idx) + mpos) = (char )'\000';
    idx ++;
  }
  ainfo->alen = mpos;
  if ((unsigned long )ainfo->cs != (unsigned long )((void *)0)) {
    *(ainfo->cs + mpos) = (char )'\000';
  }
  if ((unsigned long )ainfo->rf != (unsigned long )((void *)0)) {
    *(ainfo->rf + mpos) = (char )'\000';
  }
  return (1);
}
}
int RandomAlignment(char **rseqs , SQINFO *sqinfo , int nseq , float pop , float pex ,
                    char ***ret_aseqs , AINFO *ainfo ) 
{ 
  char **aseqs ;
  int alen ;
  int *rlen ;
  int M ;
  int **ins ;
  int *master_ins ;
  int apos ;
  int rpos ;
  int idx ;
  int statepos ;
  int count ;
  int minlen ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;

  {
  tmp = sre_malloc((char *)"alignio.c", 530, sizeof(int ) * (unsigned long )nseq);
  rlen = (int *)tmp;
  M = 0;
  minlen = 9999999;
  idx = 0;
  while (idx < nseq) {
    tmp___0 = strlen((char const   *)*(rseqs + idx));
    *(rlen + idx) = (int )tmp___0;
    M += *(rlen + idx);
    if (*(rlen + idx) < minlen) {
      minlen = *(rlen + idx);
    } else {
      minlen = minlen;
    }
    idx ++;
  }
  M = (int )((double )((float )M) / (1.0 + (double )pop * (1.0 + 1.0 / (1.0 - (double )pex))));
  M /= nseq;
  if (M > minlen) {
    M = minlen;
  }
  tmp___1 = sre_malloc((char *)"alignio.c", 545, sizeof(int *) * (unsigned long )nseq);
  ins = (int **)tmp___1;
  tmp___2 = sre_malloc((char *)"alignio.c", 546, sizeof(int ) * (unsigned long )(M + 1));
  master_ins = (int *)tmp___2;
  idx = 0;
  while (idx < nseq) {
    tmp___3 = sre_malloc((char *)"alignio.c", 549, sizeof(int ) * (unsigned long )(M + 1));
    *(ins + idx) = (int *)tmp___3;
    rpos = 0;
    while (rpos <= M) {
      *(*(ins + idx) + rpos) = 0;
      rpos ++;
    }
    idx ++;
  }
  pop /= pop + pex;
  pex = (float )(1.0 - (double )pop);
  idx = 0;
  while (idx < nseq) {
    apos = -1;
    rpos = 0;
    while (rpos < *(rlen + idx) - M) {
      tmp___5 = sre_random();
      if (tmp___5 < (double )pop) {
        tmp___4 = sre_random();
        apos = (int )(tmp___4 * (double )(M + 1));
      } else
      if (apos == -1) {
        tmp___4 = sre_random();
        apos = (int )(tmp___4 * (double )(M + 1));
      }
      (*(*(ins + idx) + apos)) ++;
      rpos ++;
    }
    idx ++;
  }
  alen = M;
  apos = 0;
  while (apos <= M) {
    *(master_ins + apos) = 0;
    idx = 0;
    while (idx < nseq) {
      if (*(*(ins + idx) + apos) > *(master_ins + apos)) {
        *(master_ins + apos) = *(*(ins + idx) + apos);
      }
      idx ++;
    }
    alen += *(master_ins + apos);
    apos ++;
  }
  tmp___6 = sre_malloc((char *)"alignio.c", 581, sizeof(char *) * (unsigned long )nseq);
  aseqs = (char **)tmp___6;
  idx = 0;
  while (idx < nseq) {
    tmp___7 = sre_malloc((char *)"alignio.c", 583, sizeof(char ) * (unsigned long )(alen + 1));
    *(aseqs + idx) = (char *)tmp___7;
    idx ++;
  }
  idx = 0;
  while (idx < nseq) {
    rpos = 0;
    apos = rpos;
    statepos = 0;
    while (statepos <= M) {
      count = 0;
      while (count < *(*(ins + idx) + statepos)) {
        tmp___8 = apos;
        apos ++;
        tmp___9 = rpos;
        rpos ++;
        *(*(aseqs + idx) + tmp___8) = *(*(rseqs + idx) + tmp___9);
        count ++;
      }
      while (count < *(master_ins + statepos)) {
        tmp___10 = apos;
        apos ++;
        *(*(aseqs + idx) + tmp___10) = (char )' ';
        count ++;
      }
      if (statepos != M) {
        tmp___11 = apos;
        apos ++;
        tmp___12 = rpos;
        rpos ++;
        *(*(aseqs + idx) + tmp___11) = *(*(rseqs + idx) + tmp___12);
      }
      statepos ++;
    }
    *(*(aseqs + idx) + alen) = (char )'\000';
    idx ++;
  }
  ainfo->flags = 0;
  ainfo->alen = alen;
  ainfo->nseq = nseq;
  tmp___13 = sre_malloc((char *)"alignio.c", 603, sizeof(SQINFO ) * (unsigned long )nseq);
  ainfo->sqinfo = (SQINFO *)tmp___13;
  idx = 0;
  while (idx < nseq) {
    SeqinfoCopy(ainfo->sqinfo + idx, sqinfo + idx);
    idx ++;
  }
  free((void *)rlen);
  free((void *)master_ins);
  Free2DArray((void **)ins, nseq);
  *ret_aseqs = aseqs;
  return (1);
}
}
void AlignmentHomogenousGapsym(char **aseq , int nseq , int alen , char gapsym ) 
{ 
  int i___0 ;
  int apos ;

  {
  i___0 = 0;
  while (i___0 < nseq) {
    apos = 0;
    while (apos < alen) {
      if ((int )*(*(aseq + i___0) + apos) == 32) {
        *(*(aseq + i___0) + apos) = gapsym;
      } else
      if ((int )*(*(aseq + i___0) + apos) == 46) {
        *(*(aseq + i___0) + apos) = gapsym;
      } else
      if ((int )*(*(aseq + i___0) + apos) == 95) {
        *(*(aseq + i___0) + apos) = gapsym;
      } else
      if ((int )*(*(aseq + i___0) + apos) == 45) {
        *(*(aseq + i___0) + apos) = gapsym;
      } else
      if ((int )*(*(aseq + i___0) + apos) == 126) {
        *(*(aseq + i___0) + apos) = gapsym;
      }
      apos ++;
    }
    i___0 ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-8GDpo9q9.i","-O3")
extern char *strpbrk(char const   * , char const   * ) ;
extern char *strstr(char const   * , char const   * ) ;
int MSAGetSeqidx(MSA *msa , char *name , int guess ) ;
MSA *ReadClustal(MSAFILE *afp ) ;
void WriteClustal(FILE *fp , MSA *msa ) ;
MSA *ReadClustal(MSAFILE *afp ) 
{ 
  MSA *msa ;
  char *s___0 ;
  int slen ;
  int sqidx ;
  char *name ;
  char *seq ;
  char *s2 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  tmp = feof(afp->f);
  if (tmp) {
    return ((MSA *)((void *)0));
  }
  while (1) {
    s___0 = MSAFileGetLine(afp);
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
      break;
    }
    tmp___0 = strncmp((char const   *)s___0, "CLUSTAL", (size_t )7);
    if (tmp___0 == 0) {
      tmp___1 = strstr((char const   *)s___0, "multiple sequence alignment");
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        break;
      }
    }
  }
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return ((MSA *)((void *)0));
  }
  msa = MSAAlloc(10, 0);
  while (1) {
    s___0 = MSAFileGetLine(afp);
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
      break;
    }
    name = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      continue;
    }
    seq = sre_strtok(& s___0, (char *)" \t\n", & slen);
    if ((unsigned long )seq == (unsigned long )((void *)0)) {
      continue;
    }
    s2 = sre_strtok(& s___0, (char *)"\n", (int *)((void *)0));
    tmp___2 = strpbrk((char const   *)name, ".*:");
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      tmp___3 = strpbrk((char const   *)seq, ".*:");
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
        continue;
      }
    }
    if ((unsigned long )s2 != (unsigned long )((void *)0)) {
      Die((char *)"Parse failed at line %d, file %s: possibly using spaces as gaps",
          afp->linenumber, afp->fname);
    }
    sqidx = MSAGetSeqidx(msa, name, msa->lastidx + 1);
    msa->lastidx = sqidx;
    *(msa->sqlen + sqidx) = sre_strcat(msa->aseq + sqidx, *(msa->sqlen + sqidx), seq,
                                       slen);
  }
  MSAVerifyParse(msa);
  return (msa);
}
}
void WriteClustal(FILE *fp , MSA *msa ) 
{ 
  int idx ;
  int len ;
  int namelen ;
  int pos ;
  char buf[64] ;
  int cpl ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  cpl = 50;
  namelen = 0;
  idx = 0;
  while (idx < msa->nseq) {
    tmp = strlen((char const   *)*(msa->sqname + idx));
    len = (int )tmp;
    if (len > namelen) {
      namelen = len;
    }
    idx ++;
  }
  fprintf(fp, "CLUSTAL W(1.5) multiple sequence alignment\n");
  pos = 0;
  while (pos < msa->alen) {
    fprintf(fp, "\n");
    idx = 0;
    while (idx < msa->nseq) {
      tmp___1 = __builtin_object_size((void *)(buf), 0);
      if (tmp___1 != 0xffffffffffffffffUL) {
        tmp___0 = __builtin_object_size((void *)(buf), 1);
        __builtin___strncpy_chk(buf, (char const   *)(*(msa->aseq + idx) + pos), (unsigned long )cpl,
                                tmp___0);
      } else {
        __inline_strncpy_chk(buf, (char const   *)(*(msa->aseq + idx) + pos), (size_t )cpl);
      }
      buf[cpl] = (char )'\000';
      fprintf(fp, "%*s %s\n", namelen, *(msa->sqname + idx), buf);
      idx ++;
    }
    pos += cpl;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Wx0DUD8Z.i","-O3")
extern void *malloc(size_t  ) ;
int Cluster(float **dmx , int N , enum clust_strategy mode , struct phylo_s **ret_tree ) ;
struct phylo_s *AllocPhylo(int N ) ;
void FreePhylo(struct phylo_s *tree , int N ) ;
void MakeDiffMx(char **aseqs , int num , float ***ret_dmx ) ;
void MakeIdentityMx(char **aseqs , int num , float ***ret_imx ) ;
void PrintNewHampshireTree(FILE *fp , AINFO *ainfo , struct phylo_s *tree , int N ) ;
void PrintPhylo(FILE *fp , AINFO *ainfo , struct phylo_s *tree , int N ) ;
float **FMX2Alloc(int rows , int cols ) ;
struct intstack_s *InitIntStack(void) ;
void PushIntStack(struct intstack_s *stack , int data ) ;
int PopIntStack(struct intstack_s *stack , int *ret_data ) ;
int FreeIntStack(struct intstack_s *stack ) ;
int Cluster(float **dmx , int N , enum clust_strategy mode , struct phylo_s **ret_tree ) 
{ 
  struct phylo_s *tree ;
  float **mx ;
  int *coord ;
  int i___0 ;
  int j ;
  int idx ;
  int Np ;
  int row ;
  int col ;
  float min ;
  float *trow ;
  float tcol ;
  float *diff ;
  int swapfoo ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;

  {
  tmp = sre_malloc((char *)"cluster.c", 168, sizeof(float *) * (unsigned long )N);
  mx = (float **)tmp;
  i___0 = 0;
  while (i___0 < N) {
    tmp___0 = sre_malloc((char *)"cluster.c", 171, sizeof(float ) * (unsigned long )N);
    *(mx + i___0) = (float *)tmp___0;
    j = 0;
    while (j < N) {
      *(*(mx + i___0) + j) = *(*(dmx + i___0) + j);
      j ++;
    }
    i___0 ++;
  }
  tmp___1 = sre_malloc((char *)"cluster.c", 176, (unsigned long )N * sizeof(int ));
  coord = (int *)tmp___1;
  tmp___2 = sre_malloc((char *)"cluster.c", 177, (unsigned long )(N - 1) * sizeof(float ));
  diff = (float *)tmp___2;
  col = 0;
  while (col < N) {
    *(coord + col) = col;
    col ++;
  }
  i___0 = 0;
  while (i___0 < N - 1) {
    *(diff + i___0) = (float )0.0;
    i___0 ++;
  }
  tree = AllocPhylo(N);
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
    Die((char *)"AllocPhylo() failed");
  }
  j = 0;
  Np = N;
  while (Np >= 2) {
    min = (float )999999.;
    row = 0;
    while (row < Np) {
      col = row + 1;
      while (col < Np) {
        if (*(*(mx + row) + col) < min) {
          min = *(*(mx + row) + col);
          i___0 = row;
          j = col;
        }
        col ++;
      }
      row ++;
    }
    (tree + (Np - 2))->left = *(coord + i___0);
    (tree + (Np - 2))->right = *(coord + j);
    if (*(coord + i___0) >= N) {
      (tree + (*(coord + i___0) - N))->parent = (N + Np) - 2;
    }
    if (*(coord + j) >= N) {
      (tree + (*(coord + j) - N))->parent = (N + Np) - 2;
    }
    tmp___3 = min;
    (tree + (Np - 2))->diff = tmp___3;
    *(diff + (Np - 2)) = tmp___3;
    tmp___4 = min;
    (tree + (Np - 2))->rblen = tmp___4;
    (tree + (Np - 2))->lblen = tmp___4;
    if (*(coord + i___0) >= N) {
      (tree + (Np - 2))->lblen -= *(diff + (*(coord + i___0) - N));
    }
    if (*(coord + j) >= N) {
      (tree + (Np - 2))->rblen -= *(diff + (*(coord + j) - N));
    }
    if (*(coord + i___0) < N) {
      ((tree + (Np - 2))->incnum) ++;
      *((tree + (Np - 2))->is_in + *(coord + i___0)) = (char)1;
    } else {
      (tree + (Np - 2))->incnum += (tree + (*(coord + i___0) - N))->incnum;
      idx = 0;
      while (idx < N) {
        *((tree + (Np - 2))->is_in + idx) = (char )((int )*((tree + (Np - 2))->is_in + idx) | (int )*((tree + (*(coord + i___0) - N))->is_in + idx));
        idx ++;
      }
    }
    if (*(coord + j) < N) {
      ((tree + (Np - 2))->incnum) ++;
      *((tree + (Np - 2))->is_in + *(coord + j)) = (char)1;
    } else {
      (tree + (Np - 2))->incnum += (tree + (*(coord + j) - N))->incnum;
      idx = 0;
      while (idx < N) {
        *((tree + (Np - 2))->is_in + idx) = (char )((int )*((tree + (Np - 2))->is_in + idx) | (int )*((tree + (*(coord + j) - N))->is_in + idx));
        idx ++;
      }
    }
    if (i___0 == Np - 1) {
      swapfoo = j;
      j = i___0;
      i___0 = swapfoo;
    } else
    if (j == Np - 2) {
      swapfoo = j;
      j = i___0;
      i___0 = swapfoo;
    }
    if (i___0 != Np - 2) {
      trow = *(mx + (Np - 2));
      *(mx + (Np - 2)) = *(mx + i___0);
      *(mx + i___0) = trow;
      row = 0;
      while (row < Np) {
        tcol = *(*(mx + row) + (Np - 2));
        *(*(mx + row) + (Np - 2)) = *(*(mx + row) + i___0);
        *(*(mx + row) + i___0) = tcol;
        row ++;
      }
      swapfoo = *(coord + (Np - 2));
      *(coord + (Np - 2)) = *(coord + i___0);
      *(coord + i___0) = swapfoo;
    }
    if (j != Np - 1) {
      trow = *(mx + (Np - 1));
      *(mx + (Np - 1)) = *(mx + j);
      *(mx + j) = trow;
      row = 0;
      while (row < Np) {
        tcol = *(*(mx + row) + (Np - 1));
        *(*(mx + row) + (Np - 1)) = *(*(mx + row) + j);
        *(*(mx + row) + j) = tcol;
        row ++;
      }
      swapfoo = *(coord + (Np - 1));
      *(coord + (Np - 1)) = *(coord + j);
      *(coord + j) = swapfoo;
    }
    i___0 = Np - 2;
    j = Np - 1;
    col = 0;
    while (col < Np) {
      switch ((unsigned int )mode) {
      case 0U: 
      *(*(mx + i___0) + col) = (float )((double )(*(*(mx + i___0) + col) + *(*(mx + j) + col)) / 2.0);
      break;
      case 2U: 
      if (*(*(mx + i___0) + col) < *(*(mx + j) + col)) {
        *(*(mx + i___0) + col) = *(*(mx + i___0) + col);
      } else {
        *(*(mx + i___0) + col) = *(*(mx + j) + col);
      }
      break;
      case 1U: 
      if (*(*(mx + i___0) + col) > *(*(mx + j) + col)) {
        *(*(mx + i___0) + col) = *(*(mx + i___0) + col);
      } else {
        *(*(mx + i___0) + col) = *(*(mx + j) + col);
      }
      break;
      default: 
      *(*(mx + i___0) + col) = (float )((double )(*(*(mx + i___0) + col) + *(*(mx + j) + col)) / 2.0);
      break;
      }
      col ++;
    }
    col = 0;
    while (col < Np) {
      *(*(mx + col) + i___0) = *(*(mx + i___0) + col);
      col ++;
    }
    *(coord + (Np - 2)) = (Np + N) - 2;
    Np --;
  }
  Free2DArray((void **)mx, N);
  free((void *)coord);
  free((void *)diff);
  *ret_tree = tree;
  return (1);
}
}
struct phylo_s *AllocPhylo(int N ) 
{ 
  struct phylo_s *tree ;
  int i___0 ;
  void *tmp ;
  float tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;

  {
  tmp = malloc((unsigned long )(N - 1) * sizeof(struct phylo_s ));
  tree = (struct phylo_s *)tmp;
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
    return ((struct phylo_s *)((void *)0));
  }
  i___0 = 0;
  while (i___0 < N - 1) {
    (tree + i___0)->diff = (float )0.0;
    tmp___0 = (float )0.0;
    (tree + i___0)->rblen = tmp___0;
    (tree + i___0)->lblen = tmp___0;
    tmp___2 = -1;
    (tree + i___0)->parent = tmp___2;
    tmp___1 = tmp___2;
    (tree + i___0)->right = tmp___1;
    (tree + i___0)->left = tmp___1;
    (tree + i___0)->incnum = 0;
    tmp___4 = calloc((size_t )N, sizeof(char ));
    tmp___3 = (char *)tmp___4;
    (tree + i___0)->is_in = tmp___3;
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      return ((struct phylo_s *)((void *)0));
    }
    i___0 ++;
  }
  return (tree);
}
}
void FreePhylo(struct phylo_s *tree , int N ) 
{ 
  int idx ;

  {
  idx = 0;
  while (idx < N - 1) {
    free((void *)(tree + idx)->is_in);
    idx ++;
  }
  free((void *)tree);
  return;
}
}
void MakeDiffMx(char **aseqs , int num , float ***ret_dmx ) 
{ 
  float **dmx ;
  int i___0 ;
  int j ;
  float tmp ;
  float tmp___0 ;

  {
  dmx = FMX2Alloc(num, num);
  i___0 = 0;
  while (i___0 < num) {
    j = i___0;
    while (j < num) {
      tmp___0 = PairwiseIdentity(*(aseqs + i___0), *(aseqs + j));
      tmp = (float )(1.0 - (double )tmp___0);
      *(*(dmx + j) + i___0) = tmp;
      *(*(dmx + i___0) + j) = tmp;
      j ++;
    }
    i___0 ++;
  }
  *ret_dmx = dmx;
  return;
}
}
void MakeIdentityMx(char **aseqs , int num , float ***ret_imx ) 
{ 
  float **imx ;
  int i___0 ;
  int j ;
  float tmp ;

  {
  imx = FMX2Alloc(num, num);
  i___0 = 0;
  while (i___0 < num) {
    j = i___0;
    while (j < num) {
      tmp = PairwiseIdentity(*(aseqs + i___0), *(aseqs + j));
      *(*(imx + j) + i___0) = tmp;
      *(*(imx + i___0) + j) = tmp;
      j ++;
    }
    i___0 ++;
  }
  *ret_imx = imx;
  return;
}
}
void PrintNewHampshireTree(FILE *fp , AINFO *ainfo , struct phylo_s *tree , int N ) 
{ 
  struct intstack_s *stack ;
  int code ;
  float *blen ;
  int docomma ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = sre_malloc((char *)"cluster.c", 464, sizeof(float ) * (unsigned long )(2 * N - 1));
  blen = (float *)tmp;
  stack = InitIntStack();
  PushIntStack(stack, N);
  docomma = 0;
  while (1) {
    tmp___0 = PopIntStack(stack, & code);
    if (! tmp___0) {
      break;
    }
    if (code < N) {
      if (docomma) {
        fputs(",", fp);
      }
      fprintf(fp, "%s:%.5f", (ainfo->sqinfo + code)->name, (double )*(blen + code));
      docomma = 1;
    } else
    if (code < 2 * N) {
      if (docomma) {
        fputs(",\n", fp);
      }
      fputs("(", fp);
      PushIntStack(stack, code + N);
      PushIntStack(stack, (tree + (code - N))->right);
      PushIntStack(stack, (tree + (code - N))->left);
      *(blen + (tree + (code - N))->right) = (tree + (code - N))->rblen;
      *(blen + (tree + (code - N))->left) = (tree + (code - N))->lblen;
      docomma = 0;
    } else {
      if (code == 2 * N) {
        fprintf(fp, ");\n");
      } else {
        fprintf(fp, "):%.5f", (double )*(blen + (code - N)));
      }
      docomma = 1;
    }
  }
  FreeIntStack(stack);
  free((void *)blen);
  return;
}
}
void PrintPhylo(FILE *fp , AINFO *ainfo , struct phylo_s *tree , int N ) 
{ 
  int idx ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  idx = 0;
  while (idx < N - 1) {
    fprintf(fp, "Interior node %d (code %d)\n", idx, idx + N);
    fprintf(fp, "\tParent: %d (code %d)\n", (tree + idx)->parent - N, (tree + idx)->parent);
    if ((tree + idx)->left < N) {
      tmp = (char const   *)((ainfo->sqinfo + (tree + idx)->left)->name);
    } else {
      tmp = "interior";
    }
    if ((tree + idx)->left < N) {
      tmp___0 = (tree + idx)->left - N;
    } else {
      tmp___0 = (tree + idx)->left;
    }
    fprintf(fp, "\tLeft:   %d (%s) %f\n", tmp___0, tmp, (double )(tree + idx)->lblen);
    if ((tree + idx)->right < N) {
      tmp___1 = (char const   *)((ainfo->sqinfo + (tree + idx)->right)->name);
    } else {
      tmp___1 = "interior";
    }
    if ((tree + idx)->right < N) {
      tmp___2 = (tree + idx)->right - N;
    } else {
      tmp___2 = (tree + idx)->right;
    }
    fprintf(fp, "\tRight:   %d (%s) %f\n", tmp___2, tmp___1, (double )(tree + idx)->rblen);
    fprintf(fp, "\tHeight:  %f\n", (double )(tree + idx)->diff);
    fprintf(fp, "\tIncludes:%d seqs\n", (tree + idx)->incnum);
    idx ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-jvEYV8vg.i","-O3")
extern char *strrchr(char const   * , int  ) ;
int ParsePAMFile(FILE *fp , int ***ret_pam , float *ret_scale ) 
{ 
  int **pam ;
  char buffer___1[512] ;
  int order[27] ;
  int nsymbols ;
  char *sptr___0 ;
  int idx ;
  int row ;
  int col ;
  float scale ;
  int gotscale ;
  char *tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  double tmp___12 ;

  {
  gotscale = 0;
  scale = (float )0.0;
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    squid_errno = 2;
    return (0);
  }
  while (1) {
    tmp = fgets(buffer___1, 512, fp);
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      squid_errno = 2;
      return (0);
    }
    tmp___6 = strstr((char const   *)(buffer___1), "BLOSUM Clustered Scoring Matrix");
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
      sptr___0 = strchr((char const   *)(buffer___1), '/');
      if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
        sptr___0 ++;
        tmp___0 = isdigit((int )*sptr___0);
        if (! tmp___0) {
          squid_errno = 5;
          return (0);
        }
        tmp___1 = log(2.0);
        tmp___2 = atof((char const   *)sptr___0);
        scale = (float )(tmp___1 / tmp___2);
        gotscale = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      tmp___5 = strstr((char const   *)(buffer___1), "substitution matrix,");
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        while (1) {
          sptr___0 = strrchr((char const   *)(buffer___1), '=');
          if (! ((unsigned long )sptr___0 != (unsigned long )((void *)0))) {
            break;
          }
          sptr___0 += 2;
          tmp___4 = IsReal(sptr___0);
          if (tmp___4) {
            tmp___3 = atof((char const   *)sptr___0);
            scale = (float )tmp___3;
            gotscale = 1;
            break;
          }
        }
      }
    }
    sptr___0 = strtok(buffer___1, " \t\n");
    if (! ((unsigned long )sptr___0 == (unsigned long )((void *)0))) {
      if (! ((int )*sptr___0 == 35)) {
        break;
      }
    }
  }
  idx = 0;
  while (1) {
    order[idx] = (int )*sptr___0 - 65;
    if (order[idx] < 0) {
      order[idx] = 26;
    } else
    if (order[idx] > 25) {
      order[idx] = 26;
    }
    idx ++;
    sptr___0 = strtok((char *)((void *)0), " \t\n");
    if (! ((unsigned long )sptr___0 != (unsigned long )((void *)0))) {
      break;
    }
  }
  nsymbols = idx;
  tmp___7 = calloc((size_t )27, sizeof(int *));
  pam = (int **)tmp___7;
  if ((unsigned long )pam == (unsigned long )((void *)0)) {
    Die((char *)"calloc failed");
  }
  idx = 0;
  while (idx < 27) {
    tmp___9 = calloc((size_t )27, sizeof(int ));
    tmp___8 = (int *)tmp___9;
    *(pam + idx) = tmp___8;
    if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
      Die((char *)"calloc failed");
    }
    idx ++;
  }
  row = 0;
  while (row < nsymbols) {
    tmp___10 = fgets(buffer___1, 512, fp);
    if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
      squid_errno = 2;
      return (0);
    }
    sptr___0 = strtok(buffer___1, " \t\n");
    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
      squid_errno = 2;
      return (0);
    }
    col = 0;
    while (col < nsymbols) {
      if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
        squid_errno = 2;
        return (0);
      }
      if ((int )*sptr___0 == 42) {
        col --;
      } else {
        tmp___11 = isalpha((int )*sptr___0);
        if (tmp___11) {
          col --;
        } else {
          *(*(pam + order[row]) + order[col]) = atoi((char const   *)sptr___0);
        }
      }
      sptr___0 = strtok((char *)((void *)0), " \t\n");
      col ++;
    }
    row ++;
  }
  if ((unsigned long )ret_scale != (unsigned long )((void *)0)) {
    if (gotscale) {
      *ret_scale = scale;
    } else {
      Warn((char *)"Failed to parse PAM matrix scale factor. Defaulting to ln(2)/2!");
      tmp___12 = log(2.0);
      *ret_scale = (float )(tmp___12 / 2.0);
    }
  }
  *ret_pam = pam;
  return (1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-tS_7bmFy.i","-O3")
void EPSWriteSmallMSA(FILE *fp , MSA *msa ) ;
void EPSWriteSmallMSA(FILE *fp , MSA *msa ) 
{ 
  int namewidth ;
  int fontwidth ;
  int hspace ;
  int vspace ;
  char *font ;
  int fontsize ;
  int i___0 ;
  int j ;
  int len ;
  int width ;
  int height ;
  int xpos ;
  int ypos ;
  size_t tmp ;

  {
  fontwidth = 8;
  hspace = 9;
  vspace = 15;
  font = sre_strdup((char *)"Courier", -1);
  fontsize = 12;
  namewidth = 0;
  i___0 = 0;
  while (i___0 < msa->nseq) {
    tmp = strlen((char const   *)*(msa->sqname + i___0));
    len = (int )tmp;
    if (len > namewidth) {
      namewidth = len;
    }
    i___0 ++;
  }
  namewidth ++;
  namewidth *= fontwidth;
  if (msa->alen > 50) {
    Die((char *)"No EPS fmt if alignment is >50 columns");
  }
  width = namewidth + hspace * msa->alen;
  if (width > 612) {
    Die((char *)"Alignment too wide to write in EPS");
  }
  height = vspace * msa->nseq;
  if (height > 792) {
    Die((char *)"Too many seqs to write in EPS");
  }
  fprintf(fp, "%%!PS-Adobe-3.0 EPSF-3.0\n");
  fprintf(fp, "%%%%BoundingBox: %d %d %d %d\n", 0, 0, width, height);
  fprintf(fp, "%%%%Pages: 1\n");
  fprintf(fp, "%%%%EndComments\n");
  fprintf(fp, "/%s findfont\n", font);
  fprintf(fp, "%d scalefont\n", fontsize);
  fprintf(fp, "setfont\n");
  fprintf(fp, "newpath\n");
  i___0 = 0;
  while (i___0 < msa->nseq) {
    ypos = ((msa->nseq - i___0) - 1) * vspace;
    fprintf(fp, "%d %d moveto\n", 0, ypos);
    fprintf(fp, "(%s) show\n", *(msa->sqname + i___0));
    xpos = namewidth;
    j = 0;
    while (j < msa->alen) {
      fprintf(fp, "%d %d moveto\n", xpos, ypos);
      fprintf(fp, "(%c) show\n", (int )*(*(msa->aseq + i___0) + j));
      xpos += hspace;
      j ++;
    }
    i___0 ++;
  }
  free((void *)font);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-XFfG3p1i.i","-O3")
extern char *getenv(char const   * ) ;
char *FileDirname(char *file ) ;
char *FileTail(char *file , int noextension ) ;
char *FileSameDirectory(char *file1 , char *file2 ) ;
char *FileAddSuffix(char *filename , char *sfx ) ;
char *FileDirname(char *file ) 
{ 
  char *dirname ;
  char *lastslash ;
  int len ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  lastslash = strrchr((char const   *)file, '/');
  if ((unsigned long )lastslash == (unsigned long )((void *)0)) {
    len = 0;
  } else {
    len = (int )(lastslash - file);
  }
  tmp = sre_malloc((char *)"file.c", 73, sizeof(char ) * (unsigned long )(len + 2));
  dirname = (char *)tmp;
  if (len > 0) {
    tmp___1 = __builtin_object_size((void *)dirname, 0);
    if (tmp___1 != 0xffffffffffffffffUL) {
      tmp___0 = __builtin_object_size((void *)dirname, 1);
      __builtin___strncpy_chk(dirname, (char const   *)file, (unsigned long )len,
                              tmp___0);
    } else {
      __inline_strncpy_chk(dirname, (char const   *)file, (size_t )len);
    }
  } else
  if ((int )*file != 47) {
    *dirname = (char )'.';
    len = 1;
  } else {
    *dirname = (char )'/';
    len = 1;
  }
  *(dirname + len) = (char )'\000';
  return (dirname);
}
}
char *FileTail(char *file , int noextension ) 
{ 
  char *tail ;
  char *lastslash ;
  char *lastdot ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  lastslash = strrchr((char const   *)file, '/');
  tmp = strlen((char const   *)file);
  tmp___0 = sre_malloc((char *)"file.c", 105, sizeof(char ) * (tmp + 1UL));
  tail = (char *)tmp___0;
  if ((unsigned long )lastslash == (unsigned long )((void *)0)) {
    tmp___2 = __builtin_object_size((void *)tail, 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)tail, 1);
      __builtin___strcpy_chk(tail, (char const   *)file, tmp___1);
    } else {
      __inline_strcpy_chk(tail, (char const   *)file);
    }
  } else {
    tmp___4 = __builtin_object_size((void *)tail, 0);
    if (tmp___4 != 0xffffffffffffffffUL) {
      tmp___3 = __builtin_object_size((void *)tail, 1);
      __builtin___strcpy_chk(tail, (char const   *)(lastslash + 1), tmp___3);
    } else {
      __inline_strcpy_chk(tail, (char const   *)(lastslash + 1));
    }
  }
  if (noextension) {
    lastdot = strrchr((char const   *)tail, '.');
    if ((unsigned long )lastdot != (unsigned long )((void *)0)) {
      *lastdot = (char )'\000';
    }
  }
  return (tail);
}
}
char *FileSameDirectory(char *file1 , char *file2 ) 
{ 
  char *path ;
  char *tail ;
  char *result ;
  int seems_ok ;
  int tmp ;
  int tmp___0 ;

  {
  seems_ok = 1;
  path = FileDirname(file1);
  tail = FileTail(file2, 0);
  tmp = strcmp((char const   *)file2, (char const   *)tail);
  if (tmp != 0) {
    seems_ok = 0;
  }
  result = FileConcat(path, tail);
  if (! seems_ok) {
    tmp___0 = strcmp((char const   *)result, (char const   *)file2);
    if (tmp___0 != 0) {
      free((void *)result);
      result = (char *)((void *)0);
    }
  }
  free((void *)path);
  free((void *)tail);
  return (result);
}
}
char *FileConcat(char *dir , char *file ) 
{ 
  char *full ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  tmp = strlen((char const   *)dir);
  tmp___0 = strlen((char const   *)file);
  tmp___1 = sre_malloc((char *)"file.c", 170, sizeof(char ) * ((tmp + tmp___0) + 2UL));
  full = (char *)tmp___1;
  if ((int )*file == 47) {
    tmp___3 = __builtin_object_size((void *)full, 0);
    if (tmp___3 != 0xffffffffffffffffUL) {
      tmp___2 = __builtin_object_size((void *)full, 1);
      __builtin___strcpy_chk(full, (char const   *)file, tmp___2);
    } else {
      __inline_strcpy_chk(full, (char const   *)file);
    }
  } else {
    tmp___4 = __builtin_object_size((void *)full, 1);
    __builtin___sprintf_chk(full, 0, tmp___4, "%s%c%s", dir, '/', file);
  }
  return (full);
}
}
char *FileAddSuffix(char *filename , char *sfx ) 
{ 
  char *new ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;

  {
  tmp = strlen((char const   *)filename);
  tmp___0 = strlen((char const   *)sfx);
  tmp___1 = sre_malloc((char *)"file.c", 190, (tmp + tmp___0) + 2UL);
  new = (char *)tmp___1;
  tmp___2 = __builtin_object_size((void *)new, 1);
  __builtin___sprintf_chk(new, 0, tmp___2, "%s.%s", filename, sfx);
  return (new);
}
}
FILE *EnvFileOpen(char *fname , char *env , char **ret_dir ) 
{ 
  FILE *fp ;
  char *path ;
  char *s___0 ;
  char full[1024] ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;

  {
  if ((unsigned long )env == (unsigned long )((void *)0)) {
    return ((FILE *)((void *)0));
  }
  tmp = getenv((char const   *)env);
  path = Strdup(tmp);
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    return ((FILE *)((void *)0));
  }
  fp = (FILE *)((void *)0);
  s___0 = strtok(path, ":");
  while ((unsigned long )s___0 != (unsigned long )((void *)0)) {
    tmp___0 = strlen((char const   *)fname);
    tmp___1 = strlen((char const   *)s___0);
    if (((int )tmp___0 + (int )tmp___1) + 2 > 1024) {
      free((void *)path);
      return ((FILE *)((void *)0));
    }
    tmp___2 = __builtin_object_size((void *)(full), 1);
    __builtin___sprintf_chk(full, 0, tmp___2, "%s%c%s", s___0, '/', fname);
    fp = fopen((char const   *)(full), "r");
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
      break;
    }
    s___0 = strtok((char *)((void *)0), ":");
  }
  if ((unsigned long )ret_dir != (unsigned long )((void *)0)) {
    *ret_dir = Strdup(s___0);
  }
  free((void *)path);
  return (fp);
}
}
int FileExists(char *filename ) 
{ 
  FILE *fp ;

  {
  fp = fopen((char const   *)filename, "r");
  if (fp) {
    fclose(fp);
    return (1);
  }
  return (0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-LqQbvAIo.i","-O3")
static int optind___0  =    1;
static char *optptr  =    (char *)((void *)0);
int Getopt(int argc , char **argv , struct opt_s *opt , int nopts , char *usage___1 ,
           int *ret_optind , char **ret_optname , char **ret_optarg ) 
{ 
  int i___0 ;
  int arglen ;
  int nmatch ;
  int opti ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  opti = 0;
  if (optind___0 >= argc) {
    *ret_optind = optind___0;
    *ret_optarg = (char *)((void *)0);
    *ret_optname = (char *)((void *)0);
    return (0);
  } else
  if ((int )*(*(argv + optind___0) + 0) != 45) {
    *ret_optind = optind___0;
    *ret_optarg = (char *)((void *)0);
    *ret_optname = (char *)((void *)0);
    return (0);
  } else {
    tmp = strcmp((char const   *)*(argv + optind___0), "-");
    if (tmp == 0) {
      *ret_optind = optind___0;
      *ret_optarg = (char *)((void *)0);
      *ret_optname = (char *)((void *)0);
      return (0);
    }
  }
  tmp___0 = strcmp((char const   *)*(argv + optind___0), "--");
  if (tmp___0 == 0) {
    optind___0 ++;
    *ret_optind = optind___0;
    *ret_optname = (char *)((void *)0);
    *ret_optarg = (char *)((void *)0);
    return (0);
  }
  if ((unsigned long )optptr == (unsigned long )((void *)0)) {
    tmp___5 = strncmp((char const   *)*(argv + optind___0), "--", (size_t )2);
    if (tmp___5 == 0) {
      optptr = strchr((char const   *)*(argv + optind___0), '=');
      if ((unsigned long )optptr != (unsigned long )((void *)0)) {
        *optptr = (char )'\000';
        optptr ++;
      }
      tmp___1 = strlen((char const   *)*(argv + optind___0));
      arglen = (int )tmp___1;
      nmatch = 0;
      i___0 = 0;
      while (i___0 < nopts) {
        if ((opt + i___0)->single == 0) {
          tmp___3 = strncmp((char const   *)(opt + i___0)->name, (char const   *)*(argv + optind___0),
                            (size_t )arglen);
          if (tmp___3 == 0) {
            nmatch ++;
            opti = i___0;
            tmp___2 = strlen((char const   *)(opt + i___0)->name);
            if ((size_t )arglen == tmp___2) {
              break;
            }
          }
        }
        i___0 ++;
      }
      if (nmatch > 1) {
        tmp___4 = strlen((char const   *)(opt + i___0)->name);
        if ((size_t )arglen != tmp___4) {
          Die((char *)"Option \"%s\" is ambiguous; please be more specific.\n%s",
              *(argv + optind___0), usage___1);
        }
      }
      if (nmatch == 0) {
        Die((char *)"No such option \"%s\".\n%s", *(argv + optind___0), usage___1);
      }
      *ret_optname = (opt + opti)->name;
      if ((opt + opti)->argtype != 0) {
        if ((unsigned long )optptr != (unsigned long )((void *)0)) {
          *ret_optarg = optptr;
          optptr = (char *)((void *)0);
          optind___0 ++;
        } else
        if (optind___0 + 1 >= argc) {
          Die((char *)"Option %s requires an argument\n%s", (opt + opti)->name, usage___1);
        } else {
          *ret_optarg = *(argv + (optind___0 + 1));
          optind___0 += 2;
        }
      } else {
        if ((unsigned long )optptr != (unsigned long )((void *)0)) {
          Die((char *)"Option %s does not take an argument\n%s", (opt + opti)->name,
              usage___1);
        }
        *ret_optarg = (char *)((void *)0);
        optind___0 ++;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if ((unsigned long )optptr == (unsigned long )((void *)0)) {
      optptr = *(argv + optind___0) + 1;
    }
    opti = -1;
    i___0 = 0;
    while (i___0 < nopts) {
      if ((opt + i___0)->single == 1) {
        if ((int )*optptr == (int )*((opt + i___0)->name + 1)) {
          opti = i___0;
          break;
        }
      }
      i___0 ++;
    }
    if (opti == -1) {
      Die((char *)"No such option \"%c\".\n%s", (int )*optptr, usage___1);
    }
    *ret_optname = (opt + opti)->name;
    if ((opt + opti)->argtype != 0) {
      if ((int )*(optptr + 1) != 0) {
        *ret_optarg = optptr + 1;
        optind___0 ++;
      } else
      if (optind___0 + 1 < argc) {
        *ret_optarg = *(argv + (optind___0 + 1));
        optind___0 += 2;
      } else {
        Die((char *)"Option %s requires an argument\n%s", (opt + opti)->name, usage___1);
      }
      optptr = (char *)((void *)0);
    } else {
      *ret_optarg = (char *)((void *)0);
      if ((int )*(optptr + 1) != 0) {
        optptr ++;
      } else {
        optind___0 ++;
        optptr = (char *)((void *)0);
      }
    }
  }
  if ((opt + opti)->argtype != 0) {
    if ((opt + opti)->argtype == 1) {
      tmp___8 = IsInt(*ret_optarg);
      if (tmp___8) {
        goto _L___1;
      } else {
        Die((char *)"Option %s requires an integer argument\n%s", (opt + opti)->name,
            usage___1);
      }
    } else
    _L___1: /* CIL Label */ 
    if ((opt + opti)->argtype == 2) {
      tmp___7 = IsReal(*ret_optarg);
      if (tmp___7) {
        goto _L___0;
      } else {
        Die((char *)"Option %s requires a numerical argument\n%s", (opt + opti)->name,
            usage___1);
      }
    } else
    _L___0: /* CIL Label */ 
    if ((opt + opti)->argtype == 3) {
      tmp___6 = strlen((char const   *)*ret_optarg);
      if (tmp___6 != 1UL) {
        Die((char *)"Option %s requires a single-character argument\n%s", (opt + opti)->name,
            usage___1);
      }
    }
  }
  *ret_optind = optind___0;
  return (1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Af6eqBmw.i","-O3")
GKI *GKIInit(void) ;
void GKIFree(GKI *hash ) ;
int GKIKeyIndex(GKI *hash , char *key ) ;
void GKIStatus(GKI *hash ) ;
static int gki_primes[4]  = {      101,      1009,      10007,      100003};
static GKI *gki_alloc(int primelevel ) ;
static int gki_hashvalue(GKI *hash , char *key ) ;
static int gki_upsize(GKI *old ) ;
GKI *GKIInit(void) 
{ 
  GKI *hash ;

  {
  hash = gki_alloc(0);
  return (hash);
}
}
void GKIFree(GKI *hash ) 
{ 
  struct gki_elem *ptr ;
  int i___0 ;

  {
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
    return;
  }
  i___0 = 0;
  while (i___0 < hash->nhash) {
    while ((unsigned long )*(hash->table + i___0) != (unsigned long )((void *)0)) {
      ptr = (*(hash->table + i___0))->nxt;
      if ((unsigned long )(*(hash->table + i___0))->key != (unsigned long )((void *)0)) {
        free((void *)(*(hash->table + i___0))->key);
      }
      free((void *)*(hash->table + i___0));
      *(hash->table + i___0) = ptr;
    }
    i___0 ++;
  }
  free((void *)hash->table);
  free((void *)hash);
  return;
}
}
int GKIStoreKey(GKI *hash , char *key ) 
{ 
  int val ;
  struct gki_elem *ptr ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  val = gki_hashvalue(hash, key);
  ptr = *(hash->table + val);
  tmp = sre_malloc((char *)"gki.c", 189, sizeof(struct gki_elem ));
  *(hash->table + val) = (struct gki_elem *)tmp;
  tmp___0 = strlen((char const   *)key);
  tmp___1 = sre_malloc((char *)"gki.c", 190, sizeof(char ) * (tmp___0 + 1UL));
  (*(hash->table + val))->key = (char *)tmp___1;
  tmp___3 = __builtin_object_size((void *)(*(hash->table + val))->key, 0);
  if (tmp___3 != 0xffffffffffffffffUL) {
    tmp___2 = __builtin_object_size((void *)(*(hash->table + val))->key, 1);
    __builtin___strcpy_chk((*(hash->table + val))->key, (char const   *)key, tmp___2);
  } else {
    __inline_strcpy_chk((*(hash->table + val))->key, (char const   *)key);
  }
  (*(hash->table + val))->idx = hash->nkeys;
  (*(hash->table + val))->nxt = ptr;
  (hash->nkeys) ++;
  if (hash->nkeys > 3 * hash->nhash) {
    if (hash->primelevel < 3) {
      gki_upsize(hash);
    }
  }
  return (hash->nkeys - 1);
}
}
int GKIKeyIndex(GKI *hash , char *key ) 
{ 
  struct gki_elem *ptr ;
  int val ;
  int tmp ;

  {
  val = gki_hashvalue(hash, key);
  ptr = *(hash->table + val);
  while ((unsigned long )ptr != (unsigned long )((void *)0)) {
    tmp = strcmp((char const   *)key, (char const   *)ptr->key);
    if (tmp == 0) {
      return (ptr->idx);
    }
    ptr = ptr->nxt;
  }
  return (-1);
}
}
void GKIStatus(GKI *hash ) 
{ 
  struct gki_elem *ptr ;
  int i___0 ;
  int nkeys ;
  int nempty ;
  int maxkeys ;
  int minkeys ;

  {
  nempty = 0;
  maxkeys = -1;
  minkeys = 2147483647;
  i___0 = 0;
  while (i___0 < hash->nhash) {
    nkeys = 0;
    ptr = *(hash->table + i___0);
    while ((unsigned long )ptr != (unsigned long )((void *)0)) {
      nkeys ++;
      ptr = ptr->nxt;
    }
    if (nkeys == 0) {
      nempty ++;
    }
    if (nkeys > maxkeys) {
      maxkeys = nkeys;
    }
    if (nkeys < minkeys) {
      minkeys = nkeys;
    }
    i___0 ++;
  }
  printf("Total keys:        %d\n", hash->nkeys);
  printf("Hash table size:   %d\n", hash->nhash);
  printf("Average occupancy: %.1f\n", (double )((float )hash->nkeys / (float )hash->nhash));
  printf("Unoccupied slots:  %d\n", nempty);
  printf("Most in one slot:  %d\n", maxkeys);
  printf("Least in one slot: %d\n", minkeys);
  return;
}
}
static GKI *gki_alloc(int primelevel ) 
{ 
  GKI *hash ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
  if (primelevel < 0) {
    Die((char *)"bad primelevel in gki_alloc()");
  } else
  if (primelevel >= 4) {
    Die((char *)"bad primelevel in gki_alloc()");
  }
  tmp = sre_malloc((char *)"gki.c", 294, sizeof(GKI ));
  hash = (GKI *)tmp;
  hash->primelevel = primelevel;
  hash->nhash = gki_primes[hash->primelevel];
  tmp___0 = sre_malloc((char *)"gki.c", 298, sizeof(struct gki_elem ) * (unsigned long )hash->nhash);
  hash->table = (struct gki_elem **)tmp___0;
  i___0 = 0;
  while (i___0 < hash->nhash) {
    *(hash->table + i___0) = (struct gki_elem *)((void *)0);
    i___0 ++;
  }
  hash->nkeys = 0;
  return (hash);
}
}
static int gki_hashvalue(GKI *hash , char *key ) 
{ 
  int val ;

  {
  val = 0;
  while ((int )*key != 0) {
    val = 128 * val + (int )*key;
    key ++;
    if ((int )*key == 0) {
      val %= hash->nhash;
      break;
    }
    val = (128 * val + (int )*key) % hash->nhash;
    key ++;
  }
  return (val);
}
}
static int gki_upsize(GKI *old ) 
{ 
  GKI *new ;
  int i___0 ;
  struct gki_elem *optr ;
  struct gki_elem *nptr ;
  int val ;

  {
  if (old->primelevel >= 3) {
    return (0);
  }
  new = gki_alloc(old->primelevel + 1);
  i___0 = 0;
  while (i___0 < old->nhash) {
    optr = *(old->table + i___0);
    while ((unsigned long )optr != (unsigned long )((void *)0)) {
      val = gki_hashvalue(new, optr->key);
      nptr = *(new->table + val);
      *(new->table + val) = optr;
      optr = optr->nxt;
      (*(new->table + val))->nxt = nptr;
    }
    i___0 ++;
  }
  free((void *)old->table);
  old->primelevel = new->primelevel;
  old->nhash = new->nhash;
  old->table = new->table;
  free((void *)new);
  return (1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-zFCC0X8e.i","-O3")
sqd_uint16 sre_ntoh16(sqd_uint16 netshort ) ;
sqd_uint32 sre_ntoh32(sqd_uint32 netlong ) ;
sqd_uint16 sre_hton16(sqd_uint16 hostshort ) ;
sqd_uint32 sre_hton32(sqd_uint32 hostlong ) ;
GSIFILE *GSIOpen(char *gsifile ) ;
int GSIGetRecord(GSIFILE *gsi , char *f1 , sqd_uint16 *f2 , sqd_uint32 *f3 ) ;
int GSIGetOffset(GSIFILE *gsi , char *key , char *ret_seqfile , int *ret_format ,
                 long *ret_offset ) ;
void GSIClose(GSIFILE *gsi ) ;
struct gsiindex_s *GSIAllocIndex(void) ;
void GSIFreeIndex(struct gsiindex_s *g ) ;
void GSIAddFileToIndex(struct gsiindex_s *g , char *filename , int fmt ) ;
void GSIAddKeyToIndex(struct gsiindex_s *g , char *key , int filenum , long offset ) ;
void GSISortIndex(struct gsiindex_s *g ) ;
void GSIWriteIndex(FILE *fp , struct gsiindex_s *g ) ;
void GSIWriteHeader(FILE *fp , int nfiles , long nkeys ) ;
int GSIWriteFileRecord(FILE *fp , char *fname , int idx , int fmt ) ;
int GSIWriteKeyRecord(FILE *fp , char *key , int fileidx , long offset ) ;
GSIFILE *GSIOpen(char *gsifile ) 
{ 
  GSIFILE *gsi ;
  char magic[32] ;
  void *tmp ;
  FILE *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  tmp = sre_malloc((char *)"gsi.c", 58, sizeof(GSIFILE ));
  gsi = (GSIFILE *)tmp;
  tmp___0 = fopen((char const   *)gsifile, "r");
  gsi->gsifp = tmp___0;
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    free((void *)gsi);
    squid_errno = 4;
    return ((GSIFILE *)((void *)0));
  }
  tmp___1 = fread((void *)(magic), sizeof(char ), (size_t )32, gsi->gsifp);
  if (! tmp___1) {
    free((void *)gsi);
    squid_errno = 2;
    return ((GSIFILE *)((void *)0));
  }
  tmp___2 = strcmp((char const   *)(magic), "GSI");
  if (tmp___2 != 0) {
    free((void *)gsi);
    squid_errno = 5;
    return ((GSIFILE *)((void *)0));
  }
  tmp___3 = fread((void *)(& gsi->nfiles), sizeof(sqd_uint16 ), (size_t )1, gsi->gsifp);
  if (! tmp___3) {
    free((void *)gsi);
    squid_errno = 2;
    return ((GSIFILE *)((void *)0));
  }
  tmp___4 = fread((void *)(& gsi->recnum), sizeof(sqd_uint32 ), (size_t )1, gsi->gsifp);
  if (! tmp___4) {
    free((void *)gsi);
    squid_errno = 2;
    return ((GSIFILE *)((void *)0));
  }
  gsi->nfiles = sre_ntoh16(gsi->nfiles);
  gsi->recnum = sre_ntoh32(gsi->recnum);
  return (gsi);
}
}
int GSIGetRecord(GSIFILE *gsi , char *f1 , sqd_uint16 *f2 , sqd_uint32 *f3 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  if ((unsigned long )f1 == (unsigned long )((void *)0)) {
    fseek(gsi->gsifp, 32L, 1);
  } else {
    tmp = fread((void *)f1, (size_t )32, (size_t )1, gsi->gsifp);
    if (! tmp) {
      squid_errno = 2;
      return (0);
    }
  }
  if ((unsigned long )f2 == (unsigned long )((void *)0)) {
    fseek(gsi->gsifp, (long )sizeof(sqd_uint16 ), 1);
  } else {
    tmp___0 = fread((void *)f2, sizeof(sqd_uint16 ), (size_t )1, gsi->gsifp);
    if (! tmp___0) {
      squid_errno = 2;
      return (0);
    }
  }
  if ((unsigned long )f3 == (unsigned long )((void *)0)) {
    fseek(gsi->gsifp, (long )sizeof(sqd_uint32 ), 1);
  } else {
    tmp___1 = fread((void *)f3, sizeof(sqd_uint32 ), (size_t )1, gsi->gsifp);
    if (! tmp___1) {
      squid_errno = 2;
      return (0);
    }
  }
  if ((unsigned long )f2 != (unsigned long )((void *)0)) {
    *f2 = sre_ntoh16(*f2);
  }
  if ((unsigned long )f3 != (unsigned long )((void *)0)) {
    *f3 = sre_ntoh32(*f3);
  }
  return (1);
}
}
int GSIGetOffset(GSIFILE *gsi , char *key , char *ret_seqfile , int *ret_format ,
                 long *ret_offset ) 
{ 
  sqd_uint32 left ;
  sqd_uint32 right ;
  sqd_uint32 mid ;
  int cmp ;
  char name[33] ;
  sqd_uint32 offset ;
  sqd_uint16 filenum ;
  sqd_uint32 fmt ;
  int tmp ;

  {
  name[32] = (char )'\000';
  left = (sqd_uint32 )((int )gsi->nfiles + 1);
  right = (sqd_uint32 )gsi->nfiles + gsi->recnum;
  mid = (left + right) / 2U;
  fseek(gsi->gsifp, (long )(mid * 38U), 0);
  while (1) {
    tmp = GSIGetRecord(gsi, name, & filenum, & offset);
    if (! tmp) {
      break;
    }
    cmp = strcmp((char const   *)(name), (char const   *)key);
    if (cmp == 0) {
      break;
    } else
    if (left >= right) {
      return (0);
    } else
    if (cmp < 0) {
      left = mid + 1U;
    } else
    if (cmp > 0) {
      right = mid - 1U;
    }
    mid = (left + right) / 2U;
    fseek(gsi->gsifp, (long )(mid * 38U), 0);
  }
  fseek(gsi->gsifp, (long )((int )filenum * 38), 0);
  GSIGetRecord(gsi, ret_seqfile, (sqd_uint16 *)((void *)0), & fmt);
  *ret_format = (int )fmt;
  *ret_offset = (long )offset;
  return (1);
}
}
void GSIClose(GSIFILE *gsi ) 
{ 


  {
  fclose(gsi->gsifp);
  free((void *)gsi);
  return;
}
}
struct gsiindex_s *GSIAllocIndex(void) 
{ 
  struct gsiindex_s *g ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  tmp = sre_malloc((char *)"gsi.c", 200, sizeof(struct gsiindex_s ));
  g = (struct gsiindex_s *)tmp;
  tmp___0 = sre_malloc((char *)"gsi.c", 201, sizeof(char *) * 10UL);
  g->filenames = (char **)tmp___0;
  tmp___1 = sre_malloc((char *)"gsi.c", 202, sizeof(int ) * 10UL);
  g->fmt = (int *)tmp___1;
  tmp___2 = sre_malloc((char *)"gsi.c", 203, sizeof(struct gsikey_s ) * 100UL);
  g->elems = (struct gsikey_s *)tmp___2;
  g->nfiles = (sqd_uint16 )0;
  g->nkeys = 0;
  return (g);
}
}
void GSIFreeIndex(struct gsiindex_s *g ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  while (i___0 < (int )g->nfiles) {
    free((void *)*(g->filenames + i___0));
    i___0 ++;
  }
  free((void *)g->filenames);
  free((void *)g->fmt);
  free((void *)g->elems);
  free((void *)g);
  return;
}
}
void GSIAddFileToIndex(struct gsiindex_s *g , char *filename , int fmt ) 
{ 
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = strlen((char const   *)filename);
  len = (int )tmp;
  if (len >= 32) {
    Die((char *)"File name too long to be indexed.");
  }
  *(g->filenames + g->nfiles) = sre_strdup(filename, len);
  *(g->fmt + g->nfiles) = fmt;
  g->nfiles = (sqd_uint16 )((int )g->nfiles + 1);
  if ((int )g->nfiles % 10 == 0) {
    tmp___0 = sre_realloc((char *)"gsi.c", 229, (void *)g->filenames, sizeof(char *) * (unsigned long )((int )g->nfiles + 10));
    g->filenames = (char **)tmp___0;
    tmp___1 = sre_realloc((char *)"gsi.c", 230, (void *)g->fmt, sizeof(int ) * (unsigned long )((int )g->nfiles + 10));
    g->fmt = (int *)tmp___1;
  }
  return;
}
}
void GSIAddKeyToIndex(struct gsiindex_s *g , char *key , int filenum , long offset ) 
{ 
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  void *tmp___2 ;

  {
  tmp = strlen((char const   *)key);
  if (tmp >= 32UL) {
    Die((char *)"key too long in GSI index");
  }
  if (filenum > 65535) {
    Die((char *)"too many files in GSI index");
  }
  if (offset > 4294967295L) {
    Die((char *)"offset too big in GSI index");
  }
  tmp___1 = __builtin_object_size((void *)((g->elems + g->nkeys)->key), 0);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)((g->elems + g->nkeys)->key), 1);
    __builtin___strncpy_chk((g->elems + g->nkeys)->key, (char const   *)key, 31UL,
                            tmp___0);
  } else {
    __inline_strncpy_chk((g->elems + g->nkeys)->key, (char const   *)key, (size_t )31);
  }
  (g->elems + g->nkeys)->key[31] = (char )'\000';
  (g->elems + g->nkeys)->filenum = (sqd_uint16 )filenum;
  (g->elems + g->nkeys)->offset = (sqd_uint32 )offset;
  (g->nkeys) ++;
  if (g->nkeys % 100 == 0) {
    tmp___2 = sre_realloc((char *)"gsi.c", 247, (void *)g->elems, sizeof(struct gsikey_s ) * (unsigned long )(g->nkeys + 100));
    g->elems = (struct gsikey_s *)tmp___2;
  }
  return;
}
}
static int gsi_keysorter(void const   *k1 , void const   *k2 ) 
{ 
  struct gsikey_s *key1 ;
  struct gsikey_s *key2 ;
  int tmp ;

  {
  key1 = (struct gsikey_s *)k1;
  key2 = (struct gsikey_s *)k2;
  tmp = strcmp((char const   *)(key1->key), (char const   *)(key2->key));
  return (tmp);
}
}
void GSISortIndex(struct gsiindex_s *g ) 
{ 


  {
  specqsort((void *)g->elems, g->nkeys, sizeof(struct gsikey_s ), & gsi_keysorter);
  return;
}
}
void GSIWriteIndex(FILE *fp , struct gsiindex_s *g ) 
{ 
  sqd_uint32 i___0 ;

  {
  if ((int )g->nfiles > 65535) {
    Die((char *)"Too many files in GSI index.");
  }
  if ((unsigned int )g->nkeys > 4294967295U) {
    Die((char *)"Too many keys in GSI index.");
  }
  GSIWriteHeader(fp, (int )g->nfiles, (long )g->nkeys);
  i___0 = (sqd_uint32 )0;
  while (i___0 < (sqd_uint32 )g->nfiles) {
    GSIWriteFileRecord(fp, *(g->filenames + i___0), (int )(i___0 + 1U), *(g->fmt + i___0));
    i___0 ++;
  }
  i___0 = (sqd_uint32 )0;
  while (i___0 < (sqd_uint32 )g->nkeys) {
    GSIWriteKeyRecord(fp, (g->elems + i___0)->key, (int )(g->elems + i___0)->filenum,
                      (long )(g->elems + i___0)->offset);
    i___0 ++;
  }
  return;
}
}
void GSIWriteHeader(FILE *fp , int nfiles , long nkeys ) 
{ 
  char key[32] ;
  sqd_uint16 f1 ;
  sqd_uint32 f2 ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  if (nfiles > 65535) {
    Die((char *)"GSI: nfiles out of range");
  }
  if (nkeys > 4294967295L) {
    Die((char *)"GSI: nkeys out of range");
  }
  f1 = (sqd_uint16 )nfiles;
  f2 = (sqd_uint32 )nkeys;
  f1 = sre_hton16(f1);
  f2 = sre_hton32(f2);
  tmp___0 = __builtin_object_size((void *)(key), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(key), 1);
    __builtin___strcpy_chk(key, "GSI", tmp);
  } else {
    __inline_strcpy_chk(key, "GSI");
  }
  tmp___1 = fwrite((void const   *)(key), (size_t )1, (size_t )32, fp);
  if (tmp___1 < 32UL) {
    Panic((char *)"gsi.c", 314);
  }
  tmp___2 = fwrite((void const   *)(& f1), (size_t )2, (size_t )1, fp);
  if (tmp___2 < 1UL) {
    Panic((char *)"gsi.c", 315);
  }
  tmp___3 = fwrite((void const   *)(& f2), (size_t )4, (size_t )1, fp);
  if (tmp___3 < 1UL) {
    Panic((char *)"gsi.c", 316);
  }
  return;
}
}
int GSIWriteFileRecord(FILE *fp , char *fname , int idx , int fmt ) 
{ 
  sqd_uint16 f1 ;
  sqd_uint32 f2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  tmp = strlen((char const   *)fname);
  if (tmp >= 32UL) {
    return (0);
  }
  if (idx > 65535) {
    Die((char *)"GSI: file index out of range");
  }
  if ((unsigned int )fmt > 4294967295U) {
    Die((char *)"GSI: format index out of range");
  }
  f1 = (sqd_uint16 )idx;
  f2 = (sqd_uint32 )fmt;
  f1 = sre_hton16(f1);
  f2 = sre_hton32(f2);
  tmp___0 = fwrite((void const   *)fname, (size_t )1, (size_t )32, fp);
  if (tmp___0 < 32UL) {
    Panic((char *)"gsi.c", 347);
  }
  tmp___1 = fwrite((void const   *)(& f1), (size_t )2, (size_t )1, fp);
  if (tmp___1 < 1UL) {
    Panic((char *)"gsi.c", 348);
  }
  tmp___2 = fwrite((void const   *)(& f2), (size_t )4, (size_t )1, fp);
  if (tmp___2 < 1UL) {
    Panic((char *)"gsi.c", 349);
  }
  return (1);
}
}
int GSIWriteKeyRecord(FILE *fp , char *key , int fileidx , long offset ) 
{ 
  sqd_uint16 f1 ;
  sqd_uint32 f2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  tmp = strlen((char const   *)key);
  if (tmp >= 32UL) {
    return (0);
  }
  if (fileidx > 65535) {
    Die((char *)"GSI: file index out of range");
  }
  if (offset > 4294967295L) {
    Die((char *)"GSI: offset out of range");
  }
  f1 = (sqd_uint16 )fileidx;
  f2 = (sqd_uint32 )offset;
  f1 = sre_hton16(f1);
  f2 = sre_hton32(f2);
  tmp___0 = fwrite((void const   *)key, (size_t )1, (size_t )32, fp);
  if (tmp___0 < 32UL) {
    Panic((char *)"gsi.c", 382);
  }
  tmp___1 = fwrite((void const   *)(& f1), (size_t )2, (size_t )1, fp);
  if (tmp___1 < 1UL) {
    Panic((char *)"gsi.c", 383);
  }
  tmp___2 = fwrite((void const   *)(& f2), (size_t )4, (size_t )1, fp);
  if (tmp___2 < 1UL) {
    Panic((char *)"gsi.c", 384);
  }
  return (1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-xFMIBkQ1.i","-O3")
extern FILE *__stderrp ;
extern size_t strcspn(char const   * , char const   * ) ;
extern size_t strspn(char const   * , char const   * ) ;
char *sqd_parse[10]  ;
sqd_regexp *sqd_regcomp(char const   *exp___0 ) ;
int sqd_regexec(sqd_regexp *prog , char const   *str ) ;
void sqd_regsub(sqd_regexp const   *rp , char const   *source , char *dest ) ;
void sqd_regerror(char *s___0 ) ;
int Strparse(char *rexp , char *s___0 , int ntok ) 
{ 
  sqd_regexp *pat ;
  int code ;
  int len ;
  int i___0 ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  if (ntok >= 10) {
    Die((char *)"Strparse(): ntok must be <= %d", 9);
  }
  i___0 = 0;
  while (i___0 <= ntok) {
    if ((unsigned long )sqd_parse[i___0] != (unsigned long )((void *)0)) {
      free((void *)sqd_parse[i___0]);
      sqd_parse[i___0] = (char *)((void *)0);
    }
    i___0 ++;
  }
  pat = sqd_regcomp((char const   *)rexp);
  if ((unsigned long )pat == (unsigned long )((void *)0)) {
    Die((char *)"regexp compilation failed.");
  }
  code = sqd_regexec(pat, (char const   *)s___0);
  if (code == 1) {
    i___0 = 0;
    while (i___0 <= ntok) {
      if ((unsigned long )pat->startp[i___0] != (unsigned long )((void *)0)) {
        if ((unsigned long )pat->endp[i___0] != (unsigned long )((void *)0)) {
          len = (int )(pat->endp[i___0] - pat->startp[i___0]);
          tmp = sre_malloc((char *)"hsregex.c", 124, sizeof(char ) * (unsigned long )(len + 1));
          sqd_parse[i___0] = (char *)tmp;
          tmp___1 = __builtin_object_size((void *)sqd_parse[i___0], 0);
          if (tmp___1 != 0xffffffffffffffffUL) {
            tmp___0 = __builtin_object_size((void *)sqd_parse[i___0], 1);
            __builtin___strncpy_chk(sqd_parse[i___0], (char const   *)pat->startp[i___0],
                                    (unsigned long )len, tmp___0);
          } else {
            __inline_strncpy_chk(sqd_parse[i___0], (char const   *)pat->startp[i___0],
                                 (size_t )len);
          }
          *(sqd_parse[i___0] + len) = (char )'\000';
        }
      }
      i___0 ++;
    }
  }
  free((void *)pat);
  return (code);
}
}
void SqdClean(void) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  while (i___0 <= 9) {
    if ((unsigned long )sqd_parse[i___0] != (unsigned long )((void *)0)) {
      free((void *)sqd_parse[i___0]);
      sqd_parse[i___0] = (char *)((void *)0);
    }
    i___0 ++;
  }
  return;
}
}
static char *reg(struct comp *cp , int paren , int *flagp ) ;
static char *regbranch(struct comp *cp , int *flagp ) ;
static char *regpiece(struct comp *cp , int *flagp ) ;
static char *regatom(struct comp *cp , int *flagp ) ;
static char *regnode(struct comp *cp , char op ) ;
static char *regnext(char *p ) ;
static void regc(struct comp *cp , char b ) ;
static void reginsert(struct comp *cp , char op , char *opnd ) ;
static void regtail(struct comp *cp , char *p , char *val ) ;
static void regoptail(struct comp *cp , char *p , char *val ) ;
sqd_regexp *sqd_regcomp(char const   *exp___0 ) 
{ 
  register sqd_regexp *r ;
  register char *scan ;
  int flags ;
  struct comp co ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  register char *longest ;
  register size_t len ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
  if ((unsigned long )exp___0 == (unsigned long )((void *)0)) {
    sqd_regerror((char *)"NULL argument to sqd_regcomp");
    return ((sqd_regexp *)((void *)0));
  }
  co.regparse = (char *)exp___0;
  co.regnpar = 1;
  co.regsize = 0L;
  co.regdummy[0] = (char)9;
  co.regdummy[2] = (char)0;
  co.regdummy[1] = co.regdummy[2];
  co.regcode = co.regdummy;
  regc(& co, 156);
  tmp = reg(& co, 0, & flags);
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    return ((sqd_regexp *)((void *)0));
  }
  if (co.regsize >= 32767L) {
    sqd_regerror((char *)"regexp too big");
    return ((sqd_regexp *)((void *)0));
  }
  tmp___0 = malloc(sizeof(sqd_regexp ) + (size_t )co.regsize);
  r = (sqd_regexp *)tmp___0;
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    sqd_regerror((char *)"out of space");
    return ((sqd_regexp *)((void *)0));
  }
  co.regparse = (char *)exp___0;
  co.regnpar = 1;
  co.regcode = r->program;
  regc(& co, 156);
  tmp___1 = reg(& co, 0, & flags);
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    return ((sqd_regexp *)((void *)0));
  }
  r->regstart = (char )'\000';
  r->reganch = (char)0;
  r->regmust = (char *)((void *)0);
  r->regmlen = 0;
  scan = r->program + 1;
  tmp___3 = regnext(scan);
  if ((int )*tmp___3 == 0) {
    scan += 3;
    if ((int )*scan == 8) {
      r->regstart = *(scan + 3);
    } else
    if ((int )*scan == 1) {
      r->reganch = (char)1;
    }
    if (flags & 4) {
      longest = (char *)((void *)0);
      len = (size_t )0;
      while ((unsigned long )scan != (unsigned long )((void *)0)) {
        if ((int )*scan == 8) {
          tmp___2 = strlen((char const   *)(scan + 3));
          if (tmp___2 >= len) {
            longest = scan + 3;
            len = strlen((char const   *)(scan + 3));
          }
        }
        scan = regnext(scan);
      }
      r->regmust = longest;
      r->regmlen = (int )len;
    }
  }
  return (r);
}
}
static char *reg(struct comp *cp , int paren , int *flagp ) 
{ 
  register char *ret ;
  register char *br ;
  register char *ender ;
  register int parno ;
  int flags ;
  int tmp ;
  char *tmp___0 ;

  {
  ret = (char *)((void *)0);
  parno = 0;
  *flagp = 1;
  if (paren) {
    if (cp->regnpar >= 10) {
      sqd_regerror((char *)"too many ()");
      return ((char *)((void *)0));
    }
    parno = cp->regnpar;
    (cp->regnpar) ++;
    ret = regnode(cp, 20 + parno);
  }
  br = regbranch(cp, & flags);
  if ((unsigned long )br == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  if (paren) {
    regtail(cp, ret, br);
  } else {
    ret = br;
  }
  *flagp &= ~ (~ flags & 1);
  *flagp |= flags & 4;
  while ((int )*(cp->regparse) == 124) {
    (cp->regparse) ++;
    br = regbranch(cp, & flags);
    if ((unsigned long )br == (unsigned long )((void *)0)) {
      return ((char *)((void *)0));
    }
    regtail(cp, ret, br);
    *flagp &= ~ (~ flags & 1);
    *flagp |= flags & 4;
  }
  if (paren) {
    tmp = 30 + parno;
  } else {
    tmp = 0;
  }
  ender = regnode(cp, tmp);
  regtail(cp, ret, ender);
  br = ret;
  while ((unsigned long )br != (unsigned long )((void *)0)) {
    regoptail(cp, br, ender);
    br = regnext(br);
  }
  if (paren) {
    tmp___0 = cp->regparse;
    (cp->regparse) ++;
    if ((int )*tmp___0 != 41) {
      sqd_regerror((char *)"unterminated ()");
      return ((char *)((void *)0));
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! paren) {
    if ((int )*(cp->regparse) != 0) {
      if ((int )*(cp->regparse) == 41) {
        sqd_regerror((char *)"unmatched ()");
        return ((char *)((void *)0));
      } else {
        sqd_regerror((char *)"internal error: junk on end");
        return ((char *)((void *)0));
      }
    }
  }
  return (ret);
}
}
static char *regbranch(struct comp *cp , int *flagp ) 
{ 
  register char *ret ;
  register char *chain ;
  register char *latest ;
  int flags ;
  register int c ;

  {
  *flagp = 0;
  ret = regnode(cp, 6);
  chain = (char *)((void *)0);
  while (1) {
    c = (int )*(cp->regparse);
    if (c != 0) {
      if (c != 124) {
        if (! (c != 41)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    latest = regpiece(cp, & flags);
    if ((unsigned long )latest == (unsigned long )((void *)0)) {
      return ((char *)((void *)0));
    }
    *flagp |= flags & 1;
    if ((unsigned long )chain == (unsigned long )((void *)0)) {
      *flagp |= flags & 4;
    } else {
      regtail(cp, chain, latest);
    }
    chain = latest;
  }
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    regnode(cp, 9);
  }
  return (ret);
}
}
static char *regpiece(struct comp *cp , int *flagp ) 
{ 
  register char *ret ;
  register char op ;
  register char *next ;
  int flags ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  ret = regatom(cp, & flags);
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  op = *(cp->regparse);
  if (! ((int )op == 42)) {
    if (! ((int )op == 43)) {
      if (! ((int )op == 63)) {
        *flagp = flags;
        return (ret);
      }
    }
  }
  if (! (flags & 1)) {
    if ((int )op != 63) {
      sqd_regerror((char *)"*+ operand could be empty");
      return ((char *)((void *)0));
    }
  }
  switch ((int )op) {
  case 42: 
  *flagp = 4;
  break;
  case 43: 
  *flagp = 5;
  break;
  case 63: 
  *flagp = 0;
  break;
  }
  if ((int )op == 42) {
    if (flags & 2) {
      reginsert(cp, 10, ret);
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if ((int )op == 42) {
    reginsert(cp, 6, ret);
    tmp = regnode(cp, 7);
    regoptail(cp, ret, tmp);
    regoptail(cp, ret, ret);
    tmp___0 = regnode(cp, 6);
    regtail(cp, ret, tmp___0);
    tmp___1 = regnode(cp, 9);
    regtail(cp, ret, tmp___1);
  } else
  if ((int )op == 43) {
    if (flags & 2) {
      reginsert(cp, 11, ret);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((int )op == 43) {
    next = regnode(cp, 6);
    regtail(cp, ret, next);
    tmp___2 = regnode(cp, 7);
    regtail(cp, tmp___2, ret);
    tmp___3 = regnode(cp, 6);
    regtail(cp, next, tmp___3);
    tmp___4 = regnode(cp, 9);
    regtail(cp, ret, tmp___4);
  } else
  if ((int )op == 63) {
    reginsert(cp, 6, ret);
    tmp___5 = regnode(cp, 6);
    regtail(cp, ret, tmp___5);
    next = regnode(cp, 9);
    regtail(cp, ret, next);
    regoptail(cp, ret, next);
  }
  (cp->regparse) ++;
  if ((int )*(cp->regparse) == 42) {
    sqd_regerror((char *)"nested *?+");
    return ((char *)((void *)0));
  } else
  if ((int )*(cp->regparse) == 43) {
    sqd_regerror((char *)"nested *?+");
    return ((char *)((void *)0));
  } else
  if ((int )*(cp->regparse) == 63) {
    sqd_regerror((char *)"nested *?+");
    return ((char *)((void *)0));
  }
  return (ret);
}
}
static char *regatom(struct comp *cp , int *flagp ) 
{ 
  register char *ret ;
  int flags ;
  char *tmp ;
  register int range ;
  register int rangeend ;
  register int c ;
  char *tmp___0 ;
  char *tmp___1 ;
  register size_t len ;
  register char ender ;
  char *tmp___2 ;

  {
  *flagp = 0;
  tmp = cp->regparse;
  (cp->regparse) ++;
  switch ((int )*tmp) {
  case 94: 
  ret = regnode(cp, 1);
  break;
  case 36: 
  ret = regnode(cp, 2);
  break;
  case 46: 
  ret = regnode(cp, 3);
  *flagp |= 3;
  break;
  case 91: 
  if ((int )*(cp->regparse) == 94) {
    ret = regnode(cp, 5);
    (cp->regparse) ++;
  } else {
    ret = regnode(cp, 4);
  }
  c = (int )*(cp->regparse);
  if (c == 93) {
    regc(cp, c);
    (cp->regparse) ++;
  } else
  if (c == 45) {
    regc(cp, c);
    (cp->regparse) ++;
  }
  while (1) {
    tmp___0 = cp->regparse;
    (cp->regparse) ++;
    c = (int )*tmp___0;
    if (c != 0) {
      if (! (c != 93)) {
        break;
      }
    } else {
      break;
    }
    if (c != 45) {
      regc(cp, c);
    } else {
      c = (int )*(cp->regparse);
      if (c == 93) {
        regc(cp, '-');
      } else
      if (c == 0) {
        regc(cp, '-');
      } else {
        range = (int )((unsigned char )*(cp->regparse - 2));
        rangeend = (int )((unsigned char )c);
        if (range > rangeend) {
          sqd_regerror((char *)"invalid [] range");
          return ((char *)((void *)0));
        }
        range ++;
        while (range <= rangeend) {
          regc(cp, range);
          range ++;
        }
        (cp->regparse) ++;
      }
    }
  }
  regc(cp, '\000');
  if (c != 93) {
    sqd_regerror((char *)"unmatched []");
    return ((char *)((void *)0));
  }
  *flagp |= 3;
  break;
  case 40: 
  ret = reg(cp, 1, & flags);
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  *flagp |= flags & 5;
  break;
  case 41: 
  case 124: 
  case 0: 
  sqd_regerror((char *)"internal error: \\0|) unexpected");
  return ((char *)((void *)0));
  break;
  case 42: 
  case 43: 
  case 63: 
  sqd_regerror((char *)"?+* follows nothing");
  return ((char *)((void *)0));
  break;
  case 92: 
  if ((int )*(cp->regparse) == 0) {
    sqd_regerror((char *)"trailing \\");
    return ((char *)((void *)0));
  }
  ret = regnode(cp, 8);
  tmp___1 = cp->regparse;
  (cp->regparse) ++;
  regc(cp, (int )*tmp___1);
  regc(cp, '\000');
  *flagp |= 3;
  break;
  default: 
  (cp->regparse) --;
  len = strcspn((char const   *)cp->regparse, "^$.[()|?+*\\");
  if (len == 0UL) {
    sqd_regerror((char *)"internal error: strcspn 0");
    return ((char *)((void *)0));
  }
  ender = *(cp->regparse + len);
  if (len > 1UL) {
    if ((int )ender == 42) {
      len --;
    } else
    if ((int )ender == 43) {
      len --;
    } else
    if ((int )ender == 63) {
      len --;
    }
  }
  *flagp |= 1;
  if (len == 1UL) {
    *flagp |= 2;
  }
  ret = regnode(cp, 8);
  while (len > 0UL) {
    tmp___2 = cp->regparse;
    (cp->regparse) ++;
    regc(cp, (int )*tmp___2);
    len --;
  }
  regc(cp, '\000');
  break;
  }
  return (ret);
}
}
static char *regnode(struct comp *cp , char op ) 
{ 
  register char *ret ;
  register char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  ret = cp->regcode;
  if (! ((unsigned long )cp->regcode != (unsigned long )(cp->regdummy))) {
    cp->regsize += 3L;
    return (ret);
  }
  ptr = ret;
  tmp = ptr;
  ptr ++;
  *tmp = op;
  tmp___0 = ptr;
  ptr ++;
  *tmp___0 = (char )'\000';
  tmp___1 = ptr;
  ptr ++;
  *tmp___1 = (char )'\000';
  cp->regcode = ptr;
  return (ret);
}
}
static void regc(struct comp *cp , char b ) 
{ 
  char *tmp ;

  {
  if ((unsigned long )cp->regcode != (unsigned long )(cp->regdummy)) {
    tmp = cp->regcode;
    (cp->regcode) ++;
    *tmp = b;
  } else {
    (cp->regsize) ++;
  }
  return;
}
}
static void reginsert(struct comp *cp , char op , char *opnd ) 
{ 
  register char *place ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  if (! ((unsigned long )cp->regcode != (unsigned long )(cp->regdummy))) {
    cp->regsize += 3L;
    return;
  }
  tmp___0 = __builtin_object_size((void *)(opnd + 3), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(opnd + 3), 0);
    __builtin___memmove_chk((void *)(opnd + 3), (void const   *)opnd, (size_t )(cp->regcode - opnd),
                            tmp);
  } else {
    __inline_memmove_chk((void *)(opnd + 3), (void const   *)opnd, (size_t )(cp->regcode - opnd));
  }
  cp->regcode += 3;
  place = opnd;
  tmp___1 = place;
  place ++;
  *tmp___1 = op;
  tmp___2 = place;
  place ++;
  *tmp___2 = (char )'\000';
  tmp___3 = place;
  place ++;
  *tmp___3 = (char )'\000';
  return;
}
}
static void regtail(struct comp *cp , char *p , char *val ) 
{ 
  register char *scan ;
  register char *temp ;
  register int offset ;

  {
  if (! ((unsigned long )cp->regcode != (unsigned long )(cp->regdummy))) {
    return;
  }
  scan = p;
  while (1) {
    temp = regnext(scan);
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
      break;
    }
    goto __Cont;
    __Cont: /* CIL Label */ 
    scan = temp;
  }
  if ((int )*scan == 7) {
    offset = (int )(scan - val);
  } else {
    offset = (int )(val - scan);
  }
  *(scan + 1) = (char )((offset >> 8) & 127);
  *(scan + 2) = (char )(offset & 255);
  return;
}
}
static void regoptail(struct comp *cp , char *p , char *val ) 
{ 


  {
  if (! ((unsigned long )cp->regcode != (unsigned long )(cp->regdummy))) {
    return;
  } else
  if ((int )*p != 6) {
    return;
  }
  regtail(cp, p + 3, val);
  return;
}
}
static int regtry(struct exec *ep , sqd_regexp *prog , char *string ) ;
static int regmatch(struct exec *ep , char *prog ) ;
static size_t regrepeat(struct exec *ep , char *node ) ;
int sqd_regexec(sqd_regexp *prog , char const   *str ) 
{ 
  register char *string ;
  register char *s___0 ;
  struct exec ex ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  string = (char *)str;
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    sqd_regerror((char *)"NULL argument to sqd_regexec");
    return (0);
  } else
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    sqd_regerror((char *)"NULL argument to sqd_regexec");
    return (0);
  }
  if ((int )((unsigned char )prog->program[0]) != 156) {
    sqd_regerror((char *)"corrupted regexp");
    return (0);
  }
  if ((unsigned long )prog->regmust != (unsigned long )((void *)0)) {
    tmp = strstr((char const   *)string, (char const   *)prog->regmust);
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      return (0);
    }
  }
  ex.regbol = string;
  ex.regstartp = prog->startp;
  ex.regendp = prog->endp;
  if (prog->reganch) {
    tmp___0 = regtry(& ex, prog, string);
    return (tmp___0);
  }
  if ((int )prog->regstart != 0) {
    s___0 = string;
    while ((unsigned long )s___0 != (unsigned long )((void *)0)) {
      tmp___1 = regtry(& ex, prog, s___0);
      if (tmp___1) {
        return (1);
      }
      s___0 = strchr((char const   *)(s___0 + 1), (int )prog->regstart);
    }
    return (0);
  } else {
    s___0 = string;
    while (1) {
      tmp___2 = regtry(& ex, prog, s___0);
      if (tmp___2) {
        break;
      }
      if ((int )*s___0 == 0) {
        return (0);
      }
      s___0 ++;
    }
    return (1);
  }
}
}
static int regtry(struct exec *ep , sqd_regexp *prog , char *string ) 
{ 
  register int i___0 ;
  register char **stp ;
  register char **enp ;
  char **tmp ;
  char **tmp___0 ;
  int tmp___1 ;

  {
  ep->reginput = string;
  stp = prog->startp;
  enp = prog->endp;
  i___0 = 10;
  while (i___0 > 0) {
    tmp = stp;
    stp ++;
    *tmp = (char *)((void *)0);
    tmp___0 = enp;
    enp ++;
    *tmp___0 = (char *)((void *)0);
    i___0 --;
  }
  tmp___1 = regmatch(ep, prog->program + 1);
  if (tmp___1) {
    prog->startp[0] = string;
    prog->endp[0] = ep->reginput;
    return (1);
  } else {
    return (0);
  }
}
}
static int regmatch(struct exec *ep , char *prog ) 
{ 
  register char *scan ;
  char *next ;
  register size_t len ;
  register char *opnd ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register int no ;
  register char *input ;
  int tmp___2 ;
  register int no___0 ;
  register char *input___0 ;
  int tmp___3 ;
  register char *save ;
  int tmp___4 ;
  register char nextch ;
  int tmp___5 ;
  register size_t no___1 ;
  register char *save___0 ;
  register size_t min ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  scan = prog;
  while ((unsigned long )scan != (unsigned long )((void *)0)) {
    next = regnext(scan);
    switch ((int )*scan) {
    case 1: 
    if ((unsigned long )ep->reginput != (unsigned long )ep->regbol) {
      return (0);
    }
    break;
    case 2: 
    if ((int )*(ep->reginput) != 0) {
      return (0);
    }
    break;
    case 3: 
    if ((int )*(ep->reginput) == 0) {
      return (0);
    }
    (ep->reginput) ++;
    break;
    case 8: 
    opnd = scan + 3;
    if ((int )*opnd != (int )*(ep->reginput)) {
      return (0);
    }
    len = strlen((char const   *)opnd);
    if (len > 1UL) {
      tmp = strncmp((char const   *)opnd, (char const   *)ep->reginput, len);
      if (tmp != 0) {
        return (0);
      }
    }
    ep->reginput += len;
    break;
    case 4: 
    if ((int )*(ep->reginput) == 0) {
      return (0);
    } else {
      tmp___0 = strchr((char const   *)(scan + 3), (int )*(ep->reginput));
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        return (0);
      }
    }
    (ep->reginput) ++;
    break;
    case 5: 
    if ((int )*(ep->reginput) == 0) {
      return (0);
    } else {
      tmp___1 = strchr((char const   *)(scan + 3), (int )*(ep->reginput));
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        return (0);
      }
    }
    (ep->reginput) ++;
    break;
    case 9: 
    break;
    case 7: 
    break;
    case 29: 
    case 28: 
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 21: 
    no = (int )*scan - 20;
    input = ep->reginput;
    tmp___2 = regmatch(ep, next);
    if (tmp___2) {
      if ((unsigned long )*(ep->regstartp + no) == (unsigned long )((void *)0)) {
        *(ep->regstartp + no) = input;
      }
      return (1);
    } else {
      return (0);
    }
    break;
    case 39: 
    case 38: 
    case 37: 
    case 36: 
    case 35: 
    case 34: 
    case 33: 
    case 32: 
    case 31: 
    no___0 = (int )*scan - 30;
    input___0 = ep->reginput;
    tmp___3 = regmatch(ep, next);
    if (tmp___3) {
      if ((unsigned long )*(ep->regendp + no___0) == (unsigned long )((void *)0)) {
        *(ep->regendp + no___0) = input___0;
      }
      return (1);
    } else {
      return (0);
    }
    break;
    case 6: 
    save = ep->reginput;
    if ((int )*next != 6) {
      next = scan + 3;
    } else {
      while ((int )*scan == 6) {
        tmp___4 = regmatch(ep, scan + 3);
        if (tmp___4) {
          return (1);
        }
        ep->reginput = save;
        scan = regnext(scan);
      }
      return (0);
    }
    break;
    case 11: 
    case 10: 
    if ((int )*next == 8) {
      tmp___5 = (int )*(next + 3);
    } else {
      tmp___5 = '\000';
    }
    nextch = (char )tmp___5;
    save___0 = ep->reginput;
    if ((int )*scan == 10) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
    min = (size_t )tmp___6;
    tmp___7 = regrepeat(ep, scan + 3);
    no___1 = tmp___7 + 1UL;
    while (no___1 > min) {
      ep->reginput = (save___0 + no___1) - 1;
      if ((int )nextch == 0) {
        goto _L;
      } else
      if ((int )*(ep->reginput) == (int )nextch) {
        _L: /* CIL Label */ 
        tmp___8 = regmatch(ep, next);
        if (tmp___8) {
          return (1);
        }
      }
      no___1 --;
    }
    return (0);
    break;
    case 0: 
    return (1);
    break;
    default: 
    sqd_regerror((char *)"regexp corruption");
    return (0);
    break;
    }
    scan = next;
  }
  sqd_regerror((char *)"corrupted pointers");
  return (0);
}
}
static size_t regrepeat(struct exec *ep , char *node ) 
{ 
  register size_t count ;
  register char *scan ;
  register char ch ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  switch ((int )*node) {
  case 3: 
  tmp = strlen((char const   *)ep->reginput);
  return (tmp);
  break;
  case 8: 
  ch = *(node + 3);
  count = (size_t )0;
  scan = ep->reginput;
  while ((int )*scan == (int )ch) {
    count ++;
    scan ++;
  }
  return (count);
  break;
  case 4: 
  tmp___0 = strspn((char const   *)ep->reginput, (char const   *)(node + 3));
  return (tmp___0);
  break;
  case 5: 
  tmp___1 = strcspn((char const   *)ep->reginput, (char const   *)(node + 3));
  return (tmp___1);
  break;
  default: 
  sqd_regerror((char *)"internal error: bad call of regrepeat");
  return ((size_t )0);
  break;
  }
  return (0UL);
}
}
static char *regnext(char *p ) 
{ 
  register int offset ;
  char *tmp ;

  {
  offset = (((int )*(p + 1) & 127) << 8) + ((int )*(p + 2) & 255);
  if (offset == 0) {
    return ((char *)((void *)0));
  }
  if ((int )*p == 7) {
    tmp = p - offset;
  } else {
    tmp = p + offset;
  }
  return (tmp);
}
}
void sqd_regsub(sqd_regexp const   *rp , char const   *source , char *dest ) 
{ 
  register sqd_regexp *prog ;
  register char *src ;
  register char *dst ;
  register char c ;
  register int no ;
  register size_t len ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  prog = (sqd_regexp *)rp;
  src = (char *)source;
  dst = dest;
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    sqd_regerror((char *)"NULL parameter to sqd_regsub");
    return;
  } else
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    sqd_regerror((char *)"NULL parameter to sqd_regsub");
    return;
  } else
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    sqd_regerror((char *)"NULL parameter to sqd_regsub");
    return;
  }
  if ((int )((unsigned char )prog->program[0]) != 156) {
    sqd_regerror((char *)"damaged regexp");
    return;
  }
  while (1) {
    tmp___5 = src;
    src ++;
    c = *tmp___5;
    if (! ((int )c != 0)) {
      break;
    }
    if ((int )c == 38) {
      no = 0;
    } else
    if ((int )c == 92) {
      tmp___0 = isdigit((int )*src);
      if (tmp___0) {
        tmp = src;
        src ++;
        no = (int )*tmp - 48;
      } else {
        no = -1;
      }
    } else {
      no = -1;
    }
    if (no < 0) {
      if ((int )c == 92) {
        if ((int )*src == 92) {
          tmp___1 = src;
          src ++;
          c = *tmp___1;
        } else
        if ((int )*src == 38) {
          tmp___1 = src;
          src ++;
          c = *tmp___1;
        }
      }
      tmp___2 = dst;
      dst ++;
      *tmp___2 = c;
    } else
    if ((unsigned long )prog->startp[no] != (unsigned long )((void *)0)) {
      if ((unsigned long )prog->endp[no] != (unsigned long )((void *)0)) {
        if ((unsigned long )prog->endp[no] > (unsigned long )prog->startp[no]) {
          len = (size_t )(prog->endp[no] - prog->startp[no]);
          tmp___4 = __builtin_object_size((void *)dst, 0);
          if (tmp___4 != 0xffffffffffffffffUL) {
            tmp___3 = __builtin_object_size((void *)dst, 1);
            __builtin___strncpy_chk(dst, (char const   *)prog->startp[no], len, tmp___3);
          } else {
            __inline_strncpy_chk(dst, (char const   *)prog->startp[no], len);
          }
          dst += len;
          if ((int )*(dst - 1) == 0) {
            sqd_regerror((char *)"damaged match string");
            return;
          }
        }
      }
    }
  }
  tmp___6 = dst;
  dst ++;
  *tmp___6 = (char )'\000';
  return;
}
}
void sqd_regerror(char *s___0 ) 
{ 


  {
  fprintf(__stderrp, "regexp(3): %s\n", s___0);
  exit(1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-PnJvU3zV.i","-O3")
struct iupactype iupac[17] ;
char *stdcode3[65] ;
float dnafq[4] ;
char aa_alphabet[21] ;
int aa_index[20] ;
float dnafq[4]  = {      (float )0.25,      (float )0.25,      (float )0.25,      (float )0.25};
float aafq[20]  = 
  {      (float )0.075520,      (float )0.016973,      (float )0.053029,      (float )0.063204, 
        (float )0.040762,      (float )0.068448,      (float )0.022406,      (float )0.057284, 
        (float )0.059398,      (float )0.093399,      (float )0.023569,      (float )0.045293, 
        (float )0.049262,      (float )0.040231,      (float )0.051573,      (float )0.072214, 
        (float )0.057454,      (float )0.065252,      (float )0.012513,      (float )0.031985};
char aa_alphabet[21]  = 
  {      (char )'A',      (char )'C',      (char )'D',      (char )'E', 
        (char )'F',      (char )'G',      (char )'H',      (char )'I', 
        (char )'K',      (char )'L',      (char )'M',      (char )'N', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'V',      (char )'W',      (char )'Y', 
        (char )'\000'};
int aa_index[20]  = 
  {      0,      2,      3,      4, 
        5,      6,      7,      8, 
        10,      11,      12,      13, 
        15,      16,      17,      18, 
        19,      21,      22,      24};
struct iupactype iupac[17]  = 
  {      {(char )'A', (char )'T', (char)8, (char)1}, 
        {(char )'C', (char )'G', (char)4, (char)2}, 
        {(char )'G', (char )'C', (char)2, (char)4}, 
        {(char )'T', (char )'A', (char)1, (char)8}, 
        {(char )'U', (char )'A', (char)1, (char)8}, 
        {(char )'N', (char )'N', (char)15, (char)15}, 
        {(char )' ', (char )' ', (char)16, (char)16}, 
        {(char )'R', (char )'Y', (char)10, (char)5}, 
        {(char )'Y', (char )'R', (char)5, (char)10}, 
        {(char )'M', (char )'K', (char)12, (char)3}, 
        {(char )'K', (char )'M', (char)3, (char)12}, 
        {(char )'S', (char )'S', (char)6, (char)6}, 
        {(char )'W', (char )'W', (char)9, (char)9}, 
        {(char )'H', (char )'D', (char)13, (char)11}, 
        {(char )'B', (char )'V', (char)7, (char)14}, 
        {(char )'V', (char )'B', (char)14, (char)7}, 
        {(char )'D', (char )'H', (char)11, (char)13}};
char *stdcode1[65]  = 
  {      (char *)"K",      (char *)"N",      (char *)"K",      (char *)"N", 
        (char *)"T",      (char *)"T",      (char *)"T",      (char *)"T", 
        (char *)"R",      (char *)"S",      (char *)"R",      (char *)"S", 
        (char *)"I",      (char *)"I",      (char *)"M",      (char *)"I", 
        (char *)"Q",      (char *)"H",      (char *)"Q",      (char *)"H", 
        (char *)"P",      (char *)"P",      (char *)"P",      (char *)"P", 
        (char *)"R",      (char *)"R",      (char *)"R",      (char *)"R", 
        (char *)"L",      (char *)"L",      (char *)"L",      (char *)"L", 
        (char *)"E",      (char *)"D",      (char *)"E",      (char *)"D", 
        (char *)"A",      (char *)"A",      (char *)"A",      (char *)"A", 
        (char *)"G",      (char *)"G",      (char *)"G",      (char *)"G", 
        (char *)"V",      (char *)"V",      (char *)"V",      (char *)"V", 
        (char *)"*",      (char *)"Y",      (char *)"*",      (char *)"Y", 
        (char *)"S",      (char *)"S",      (char *)"S",      (char *)"S", 
        (char *)"*",      (char *)"C",      (char *)"W",      (char *)"C", 
        (char *)"L",      (char *)"F",      (char *)"L",      (char *)"F", 
        (char *)"X"};
char *stdcode3[65]  = 
  {      (char *)"Lys",      (char *)"Asn",      (char *)"Lys",      (char *)"Asn", 
        (char *)"Thr",      (char *)"Thr",      (char *)"Thr",      (char *)"Thr", 
        (char *)"Arg",      (char *)"Ser",      (char *)"Arg",      (char *)"Ser", 
        (char *)"Ile",      (char *)"Ile",      (char *)"Met",      (char *)"Ile", 
        (char *)"Gln",      (char *)"His",      (char *)"Gln",      (char *)"His", 
        (char *)"Pro",      (char *)"Pro",      (char *)"Pro",      (char *)"Pro", 
        (char *)"Arg",      (char *)"Arg",      (char *)"Arg",      (char *)"Arg", 
        (char *)"Leu",      (char *)"Leu",      (char *)"Leu",      (char *)"Leu", 
        (char *)"Glu",      (char *)"Asp",      (char *)"Glu",      (char *)"Asp", 
        (char *)"Ala",      (char *)"Ala",      (char *)"Ala",      (char *)"Ala", 
        (char *)"Gly",      (char *)"Gly",      (char *)"Gly",      (char *)"Gly", 
        (char *)"Val",      (char *)"Val",      (char *)"Val",      (char *)"Val", 
        (char *)"***",      (char *)"Tyr",      (char *)"***",      (char *)"Tyr", 
        (char *)"Ser",      (char *)"Ser",      (char *)"Ser",      (char *)"Ser", 
        (char *)"***",      (char *)"Cys",      (char *)"Trp",      (char *)"Cys", 
        (char *)"Leu",      (char *)"Phe",      (char *)"Leu",      (char *)"Trp", 
        (char *)"XXX"};
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-cVw_DvKT.i","-O3")
extern FILE *__stdinp ;
MSAFILE *MSAFileOpen(char *filename , int format , char *env ) ;
MSA *MSAFileRead(MSAFILE *afp ) ;
void MSAFileClose(MSAFILE *afp ) ;
void MSAFileWrite(FILE *fp , MSA *msa , int outfmt , int do_oneline ) ;
int MSAFileRewind(MSAFILE *afp ) ;
int MSAFilePositionByKey(MSAFILE *afp , char *key ) ;
int MSAFilePositionByIndex(MSAFILE *afp , int idx ) ;
int MSAFileFormat(MSAFILE *afp ) ;
void MSAAddComment(MSA *msa , char *s___0 ) ;
void MSAAddGF(MSA *msa , char *tag , char *value ) ;
void MSAAddGS(MSA *msa , char *tag , int sqidx , char *value ) ;
void MSAAppendGC(MSA *msa , char *tag , char *value ) ;
void MSAAppendGR(MSA *msa , char *tag , int sqidx , char *value ) ;
MSA *MSAFromAINFO(char **aseq , AINFO *ainfo ) ;
void MSAMingap(MSA *msa ) ;
void MSANogap(MSA *msa ) ;
void MSAShorterAlignment(MSA *msa , int *useme ) ;
void MSASmallerAlignment(MSA *msa , int *useme , MSA **ret_new ) ;
char *MSAGetSeqAccession(MSA *msa , int idx ) ;
char *MSAGetSeqDescription(MSA *msa , int idx ) ;
char *MSAGetSeqSS(MSA *msa , int idx ) ;
char *MSAGetSeqSA(MSA *msa , int idx ) ;
float MSAAverageSequenceLength(MSA *msa ) ;
MSA *ReadMSF(MSAFILE *afp ) ;
void WriteMSF(FILE *fp , MSA *msa ) ;
MSA *ReadPhylip(MSAFILE *afp ) ;
void WritePhylip(FILE *fp , MSA *msa ) ;
MSA *ReadSELEX(MSAFILE *afp ) ;
void WriteSELEX(FILE *fp , MSA *msa ) ;
MSA *ReadStockholm(MSAFILE *afp ) ;
void WriteStockholm(FILE *fp , MSA *msa ) ;
void WriteStockholmOneBlock(FILE *fp , MSA *msa ) ;
int SeqfileFormat(FILE *fp ) ;
char *SeqfileFormat2String(int code ) ;
void Free3DArray(void ***p , int dim1 , int dim2 ) ;
char *sre_fgets(char **buf , int *n , FILE *fp ) ;
MSA *MSAAlloc(int nseq , int alen ) 
{ 
  MSA *msa ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  tmp = sre_malloc((char *)"msa.c", 68, sizeof(MSA ));
  msa = (MSA *)tmp;
  tmp___0 = sre_malloc((char *)"msa.c", 69, sizeof(char *) * (unsigned long )nseq);
  msa->aseq = (char **)tmp___0;
  tmp___1 = sre_malloc((char *)"msa.c", 70, sizeof(char *) * (unsigned long )nseq);
  msa->sqname = (char **)tmp___1;
  tmp___2 = sre_malloc((char *)"msa.c", 71, sizeof(int ) * (unsigned long )nseq);
  msa->sqlen = (int *)tmp___2;
  tmp___3 = sre_malloc((char *)"msa.c", 72, sizeof(float ) * (unsigned long )nseq);
  msa->wgt = (float *)tmp___3;
  i___0 = 0;
  while (i___0 < nseq) {
    *(msa->sqname + i___0) = (char *)((void *)0);
    *(msa->sqlen + i___0) = 0;
    *(msa->wgt + i___0) = (float )(- 1.0);
    if (alen != 0) {
      tmp___4 = sre_malloc((char *)"msa.c", 80, sizeof(char ) * (unsigned long )(alen + 1));
      *(msa->aseq + i___0) = (char *)tmp___4;
    } else {
      *(msa->aseq + i___0) = (char *)((void *)0);
    }
    i___0 ++;
  }
  msa->alen = alen;
  msa->nseq = 0;
  msa->nseqalloc = nseq;
  msa->nseqlump = nseq;
  msa->flags = 0;
  msa->type = 0;
  msa->name = (char *)((void *)0);
  msa->desc = (char *)((void *)0);
  msa->acc = (char *)((void *)0);
  msa->au = (char *)((void *)0);
  msa->ss_cons = (char *)((void *)0);
  msa->sa_cons = (char *)((void *)0);
  msa->rf = (char *)((void *)0);
  msa->sqacc = (char **)((void *)0);
  msa->sqdesc = (char **)((void *)0);
  msa->ss = (char **)((void *)0);
  msa->sslen = (int *)((void *)0);
  msa->sa = (char **)((void *)0);
  msa->salen = (int *)((void *)0);
  msa->index = GKIInit();
  msa->lastidx = 0;
  i___0 = 0;
  while (i___0 < 6) {
    msa->cutoff[i___0] = (float )0.;
    msa->cutoff_is_set[i___0] = 0;
    i___0 ++;
  }
  msa->comment = (char **)((void *)0);
  msa->ncomment = 0;
  msa->alloc_ncomment = 0;
  msa->gf_tag = (char **)((void *)0);
  msa->gf = (char **)((void *)0);
  msa->ngf = 0;
  msa->gs_tag = (char **)((void *)0);
  msa->gs = (char ***)((void *)0);
  msa->gs_idx = (GKI *)((void *)0);
  msa->ngs = 0;
  msa->gc_tag = (char **)((void *)0);
  msa->gc = (char **)((void *)0);
  msa->gc_idx = (GKI *)((void *)0);
  msa->ngc = 0;
  msa->gr_tag = (char **)((void *)0);
  msa->gr = (char ***)((void *)0);
  msa->gr_idx = (GKI *)((void *)0);
  msa->ngr = 0;
  return (msa);
}
}
void MSAExpand(MSA *msa ) 
{ 
  int i___0 ;
  int j ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;

  {
  msa->nseqalloc += msa->nseqlump;
  tmp = sre_realloc((char *)"msa.c", 162, (void *)msa->aseq, sizeof(char *) * (unsigned long )msa->nseqalloc);
  msa->aseq = (char **)tmp;
  tmp___0 = sre_realloc((char *)"msa.c", 163, (void *)msa->sqname, sizeof(char *) * (unsigned long )msa->nseqalloc);
  msa->sqname = (char **)tmp___0;
  tmp___1 = sre_realloc((char *)"msa.c", 164, (void *)msa->sqlen, sizeof(char *) * (unsigned long )msa->nseqalloc);
  msa->sqlen = (int *)tmp___1;
  tmp___2 = sre_realloc((char *)"msa.c", 165, (void *)msa->wgt, sizeof(float ) * (unsigned long )msa->nseqalloc);
  msa->wgt = (float *)tmp___2;
  if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
    tmp___3 = sre_realloc((char *)"msa.c", 168, (void *)msa->ss, sizeof(char *) * (unsigned long )msa->nseqalloc);
    msa->ss = (char **)tmp___3;
    tmp___4 = sre_realloc((char *)"msa.c", 169, (void *)msa->sslen, sizeof(int ) * (unsigned long )msa->nseqalloc);
    msa->sslen = (int *)tmp___4;
  }
  if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
    tmp___5 = sre_realloc((char *)"msa.c", 172, (void *)msa->sa, sizeof(char *) * (unsigned long )msa->nseqalloc);
    msa->sa = (char **)tmp___5;
    tmp___6 = sre_realloc((char *)"msa.c", 173, (void *)msa->salen, sizeof(int ) * (unsigned long )msa->nseqalloc);
    msa->salen = (int *)tmp___6;
  }
  if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
    tmp___7 = sre_realloc((char *)"msa.c", 176, (void *)msa->sqacc, sizeof(char *) * (unsigned long )msa->nseqalloc);
    msa->sqacc = (char **)tmp___7;
  }
  if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
    tmp___8 = sre_realloc((char *)"msa.c", 178, (void *)msa->sqdesc, sizeof(char *) * (unsigned long )msa->nseqalloc);
    msa->sqdesc = (char **)tmp___8;
  }
  i___0 = msa->nseqalloc - msa->nseqlump;
  while (i___0 < msa->nseqalloc) {
    *(msa->sqname + i___0) = (char *)((void *)0);
    *(msa->wgt + i___0) = (float )(- 1.0);
    if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
      *(msa->sqacc + i___0) = (char *)((void *)0);
    }
    if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
      *(msa->sqdesc + i___0) = (char *)((void *)0);
    }
    if (msa->alen != 0) {
      tmp___9 = sre_realloc((char *)"msa.c", 189, (void *)*(msa->aseq + i___0), sizeof(char ) * (unsigned long )(msa->alen + 1));
      *(msa->aseq + i___0) = (char *)tmp___9;
    } else {
      *(msa->aseq + i___0) = (char *)((void *)0);
    }
    *(msa->sqlen + i___0) = 0;
    if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
      if (msa->alen != 0) {
        tmp___10 = sre_realloc((char *)"msa.c", 195, (void *)*(msa->ss + i___0), sizeof(char ) * (unsigned long )(msa->alen + 1));
        *(msa->ss + i___0) = (char *)tmp___10;
      } else {
        *(msa->ss + i___0) = (char *)((void *)0);
      }
      *(msa->sslen + i___0) = 0;
    }
    if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
      if (msa->alen != 0) {
        tmp___11 = sre_realloc((char *)"msa.c", 201, (void *)*(msa->ss + i___0), sizeof(char ) * (unsigned long )(msa->alen + 1));
        *(msa->sa + i___0) = (char *)tmp___11;
      } else {
        *(msa->sa + i___0) = (char *)((void *)0);
      }
      *(msa->salen + i___0) = 0;
    }
    i___0 ++;
  }
  if ((unsigned long )msa->gs != (unsigned long )((void *)0)) {
    i___0 = 0;
    while (i___0 < msa->ngs) {
      if ((unsigned long )*(msa->gs + i___0) != (unsigned long )((void *)0)) {
        tmp___12 = sre_realloc((char *)"msa.c", 217, (void *)*(msa->gs + i___0), sizeof(char *) * (unsigned long )msa->nseqalloc);
        *(msa->gs + i___0) = (char **)tmp___12;
        j = msa->nseqalloc - msa->nseqlump;
        while (j < msa->nseqalloc) {
          *(*(msa->gs + i___0) + j) = (char *)((void *)0);
          j ++;
        }
      }
      i___0 ++;
    }
  }
  if ((unsigned long )msa->gr != (unsigned long )((void *)0)) {
    i___0 = 0;
    while (i___0 < msa->ngr) {
      if ((unsigned long )*(msa->gr + i___0) != (unsigned long )((void *)0)) {
        tmp___13 = sre_realloc((char *)"msa.c", 232, (void *)*(msa->gr + i___0), sizeof(char *) * (unsigned long )msa->nseqalloc);
        *(msa->gr + i___0) = (char **)tmp___13;
        j = msa->nseqalloc - msa->nseqlump;
        while (j < msa->nseqalloc) {
          *(*(msa->gr + i___0) + j) = (char *)((void *)0);
          j ++;
        }
      }
      i___0 ++;
    }
  }
  return;
}
}
void MSAFree(MSA *msa ) 
{ 


  {
  Free2DArray((void **)msa->aseq, msa->nseq);
  Free2DArray((void **)msa->sqname, msa->nseq);
  Free2DArray((void **)msa->sqacc, msa->nseq);
  Free2DArray((void **)msa->sqdesc, msa->nseq);
  Free2DArray((void **)msa->ss, msa->nseq);
  Free2DArray((void **)msa->sa, msa->nseq);
  if ((unsigned long )msa->sqlen != (unsigned long )((void *)0)) {
    free((void *)msa->sqlen);
  }
  if ((unsigned long )msa->wgt != (unsigned long )((void *)0)) {
    free((void *)msa->wgt);
  }
  if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
    free((void *)msa->name);
  }
  if ((unsigned long )msa->desc != (unsigned long )((void *)0)) {
    free((void *)msa->desc);
  }
  if ((unsigned long )msa->acc != (unsigned long )((void *)0)) {
    free((void *)msa->acc);
  }
  if ((unsigned long )msa->au != (unsigned long )((void *)0)) {
    free((void *)msa->au);
  }
  if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
    free((void *)msa->ss_cons);
  }
  if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
    free((void *)msa->sa_cons);
  }
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
    free((void *)msa->rf);
  }
  if ((unsigned long )msa->sslen != (unsigned long )((void *)0)) {
    free((void *)msa->sslen);
  }
  if ((unsigned long )msa->salen != (unsigned long )((void *)0)) {
    free((void *)msa->salen);
  }
  Free2DArray((void **)msa->comment, msa->ncomment);
  Free2DArray((void **)msa->gf_tag, msa->ngf);
  Free2DArray((void **)msa->gf, msa->ngf);
  Free2DArray((void **)msa->gs_tag, msa->ngs);
  Free3DArray((void ***)msa->gs, msa->ngs, msa->nseq);
  Free2DArray((void **)msa->gc_tag, msa->ngc);
  Free2DArray((void **)msa->gc, msa->ngc);
  Free2DArray((void **)msa->gr_tag, msa->ngr);
  Free3DArray((void ***)msa->gr, msa->ngr, msa->nseq);
  GKIFree(msa->index);
  GKIFree(msa->gs_idx);
  GKIFree(msa->gc_idx);
  GKIFree(msa->gr_idx);
  free((void *)msa);
  return;
}
}
void MSASetSeqAccession(MSA *msa , int seqidx , char *acc ) 
{ 
  int x ;
  void *tmp ;

  {
  if ((unsigned long )msa->sqacc == (unsigned long )((void *)0)) {
    tmp = sre_malloc((char *)"msa.c", 310, sizeof(char *) * (unsigned long )msa->nseqalloc);
    msa->sqacc = (char **)tmp;
    x = 0;
    while (x < msa->nseqalloc) {
      *(msa->sqacc + x) = (char *)((void *)0);
      x ++;
    }
  }
  *(msa->sqacc + seqidx) = sre_strdup(acc, -1);
  return;
}
}
void MSASetSeqDescription(MSA *msa , int seqidx , char *desc ) 
{ 
  int x ;
  void *tmp ;

  {
  if ((unsigned long )msa->sqdesc == (unsigned long )((void *)0)) {
    tmp = sre_malloc((char *)"msa.c", 335, sizeof(char *) * (unsigned long )msa->nseqalloc);
    msa->sqdesc = (char **)tmp;
    x = 0;
    while (x < msa->nseqalloc) {
      *(msa->sqdesc + x) = (char *)((void *)0);
      x ++;
    }
  }
  *(msa->sqdesc + seqidx) = sre_strdup(desc, -1);
  return;
}
}
void MSAAddComment(MSA *msa , char *s___0 ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  if ((unsigned long )msa->comment == (unsigned long )((void *)0)) {
    tmp = sre_malloc((char *)"msa.c", 362, sizeof(char *) * 10UL);
    msa->comment = (char **)tmp;
    msa->alloc_ncomment = 10;
  }
  if (msa->ncomment == msa->alloc_ncomment) {
    msa->alloc_ncomment += 10;
    tmp___0 = sre_realloc((char *)"msa.c", 367, (void *)msa->comment, sizeof(char *) * (unsigned long )msa->alloc_ncomment);
    msa->comment = (char **)tmp___0;
  }
  *(msa->comment + msa->ncomment) = sre_strdup(s___0, -1);
  (msa->ncomment) ++;
  return;
}
}
void MSAAddGF(MSA *msa , char *tag , char *value ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  if ((unsigned long )msa->gf_tag == (unsigned long )((void *)0)) {
    tmp = sre_malloc((char *)"msa.c", 395, sizeof(char *) * 10UL);
    msa->gf_tag = (char **)tmp;
    tmp___0 = sre_malloc((char *)"msa.c", 396, sizeof(char *) * 10UL);
    msa->gf = (char **)tmp___0;
    msa->alloc_ngf = 10;
  }
  if (msa->ngf == msa->alloc_ngf) {
    msa->alloc_ngf += 10;
    tmp___1 = sre_realloc((char *)"msa.c", 401, (void *)msa->gf_tag, sizeof(char *) * (unsigned long )msa->alloc_ngf);
    msa->gf_tag = (char **)tmp___1;
    tmp___2 = sre_realloc((char *)"msa.c", 402, (void *)msa->gf, sizeof(char *) * (unsigned long )msa->alloc_ngf);
    msa->gf = (char **)tmp___2;
  }
  *(msa->gf_tag + msa->ngf) = sre_strdup(tag, -1);
  *(msa->gf + msa->ngf) = sre_strdup(value, -1);
  (msa->ngf) ++;
  return;
}
}
void MSAAddGS(MSA *msa , char *tag , int sqidx , char *value ) 
{ 
  int tagidx ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int len ;
  int tmp___5 ;

  {
  if ((unsigned long )msa->gs_tag == (unsigned long )((void *)0)) {
    msa->gs_idx = GKIInit();
    tagidx = GKIStoreKey(msa->gs_idx, tag);
    tmp = sre_malloc((char *)"msa.c", 447, sizeof(char *));
    msa->gs_tag = (char **)tmp;
    tmp___0 = sre_malloc((char *)"msa.c", 448, sizeof(char **));
    msa->gs = (char ***)tmp___0;
    tmp___1 = sre_malloc((char *)"msa.c", 449, sizeof(char *) * (unsigned long )msa->nseqalloc);
    *(msa->gs + 0) = (char **)tmp___1;
    i___0 = 0;
    while (i___0 < msa->nseqalloc) {
      *(*(msa->gs + 0) + i___0) = (char *)((void *)0);
      i___0 ++;
    }
  } else {
    tagidx = GKIKeyIndex(msa->gs_idx, tag);
    if (tagidx < 0) {
      tagidx = GKIStoreKey(msa->gs_idx, tag);
      tmp___2 = sre_realloc((char *)"msa.c", 463, (void *)msa->gs_tag, (unsigned long )(msa->ngs + 1) * sizeof(char *));
      msa->gs_tag = (char **)tmp___2;
      tmp___3 = sre_realloc((char *)"msa.c", 464, (void *)msa->gs, (unsigned long )(msa->ngs + 1) * sizeof(char **));
      msa->gs = (char ***)tmp___3;
      tmp___4 = sre_malloc((char *)"msa.c", 465, sizeof(char *) * (unsigned long )msa->nseqalloc);
      *(msa->gs + msa->ngs) = (char **)tmp___4;
      i___0 = 0;
      while (i___0 < msa->nseqalloc) {
        *(*(msa->gs + msa->ngs) + i___0) = (char *)((void *)0);
        i___0 ++;
      }
    }
  }
  if (tagidx == msa->ngs) {
    *(msa->gs_tag + tagidx) = sre_strdup(tag, -1);
    (msa->ngs) ++;
  }
  if ((unsigned long )*(*(msa->gs + tagidx) + sqidx) == (unsigned long )((void *)0)) {
    *(*(msa->gs + tagidx) + sqidx) = sre_strdup(value, -1);
  } else {
    len = sre_strcat(*(msa->gs + tagidx) + sqidx, -1, (char *)"\n", 1);
    if (len < 0) {
      Die((char *)"failed to sre_strcat()");
    }
    tmp___5 = sre_strcat(*(msa->gs + tagidx) + sqidx, len, value, -1);
    if (tmp___5 < 0) {
      Die((char *)"failed to sre_strcat()");
    }
  }
  return;
}
}
void MSAAppendGC(MSA *msa , char *tag , char *value ) 
{ 
  int tagidx ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  if ((unsigned long )msa->gc_tag == (unsigned long )((void *)0)) {
    tmp = sre_malloc((char *)"msa.c", 517, sizeof(char *));
    msa->gc_tag = (char **)tmp;
    tmp___0 = sre_malloc((char *)"msa.c", 518, sizeof(char *));
    msa->gc = (char **)tmp___0;
    msa->gc_idx = GKIInit();
    tagidx = GKIStoreKey(msa->gc_idx, tag);
    *(msa->gc + 0) = (char *)((void *)0);
  } else {
    tagidx = GKIKeyIndex(msa->gc_idx, tag);
    if (tagidx < 0) {
      tagidx = GKIStoreKey(msa->gc_idx, tag);
      tmp___1 = sre_realloc((char *)"msa.c", 533, (void *)msa->gc_tag, (unsigned long )(msa->ngc + 1) * sizeof(char **));
      msa->gc_tag = (char **)tmp___1;
      tmp___2 = sre_realloc((char *)"msa.c", 534, (void *)msa->gc, (unsigned long )(msa->ngc + 1) * sizeof(char **));
      msa->gc = (char **)tmp___2;
      *(msa->gc + tagidx) = (char *)((void *)0);
    }
  }
  if (tagidx == msa->ngc) {
    *(msa->gc_tag + tagidx) = sre_strdup(tag, -1);
    (msa->ngc) ++;
  }
  sre_strcat(msa->gc + tagidx, -1, value, -1);
  return;
}
}
char *MSAGetGC(MSA *msa , char *tag ) 
{ 
  int tagidx ;

  {
  if ((unsigned long )msa->gc_idx == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  tagidx = GKIKeyIndex(msa->gc_idx, tag);
  if (tagidx < 0) {
    return ((char *)((void *)0));
  }
  return (*(msa->gc + tagidx));
}
}
void MSAAppendGR(MSA *msa , char *tag , int sqidx , char *value ) 
{ 
  int tagidx ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  if ((unsigned long )msa->gr_tag == (unsigned long )((void *)0)) {
    tmp = sre_malloc((char *)"msa.c", 601, sizeof(char *));
    msa->gr_tag = (char **)tmp;
    tmp___0 = sre_malloc((char *)"msa.c", 602, sizeof(char **));
    msa->gr = (char ***)tmp___0;
    tmp___1 = sre_malloc((char *)"msa.c", 603, sizeof(char *) * (unsigned long )msa->nseqalloc);
    *(msa->gr + 0) = (char **)tmp___1;
    i___0 = 0;
    while (i___0 < msa->nseqalloc) {
      *(*(msa->gr + 0) + i___0) = (char *)((void *)0);
      i___0 ++;
    }
    msa->gr_idx = GKIInit();
    tagidx = GKIStoreKey(msa->gr_idx, tag);
  } else {
    tagidx = GKIKeyIndex(msa->gr_idx, tag);
    if (tagidx < 0) {
      tagidx = GKIStoreKey(msa->gr_idx, tag);
      tmp___2 = sre_realloc((char *)"msa.c", 620, (void *)msa->gr_tag, (unsigned long )(msa->ngr + 1) * sizeof(char *));
      msa->gr_tag = (char **)tmp___2;
      tmp___3 = sre_realloc((char *)"msa.c", 621, (void *)msa->gr, (unsigned long )(msa->ngr + 1) * sizeof(char **));
      msa->gr = (char ***)tmp___3;
      tmp___4 = sre_malloc((char *)"msa.c", 622, sizeof(char *) * (unsigned long )msa->nseqalloc);
      *(msa->gr + msa->ngr) = (char **)tmp___4;
      i___0 = 0;
      while (i___0 < msa->nseqalloc) {
        *(*(msa->gr + msa->ngr) + i___0) = (char *)((void *)0);
        i___0 ++;
      }
    }
  }
  if (tagidx == msa->ngr) {
    *(msa->gr_tag + tagidx) = sre_strdup(tag, -1);
    (msa->ngr) ++;
  }
  sre_strcat(*(msa->gr + tagidx) + sqidx, -1, value, -1);
  return;
}
}
void MSAVerifyParse(MSA *msa ) 
{ 
  int idx ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
  if (msa->nseq == 0) {
    if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
      tmp = (char const   *)msa->name;
    } else {
      tmp = "";
    }
    Die((char *)"Parse error: no sequences were found for alignment %s", tmp);
  }
  msa->alen = *(msa->sqlen + 0);
  idx = 0;
  while (idx < msa->nseq) {
    if ((unsigned long )*(msa->aseq + idx) == (unsigned long )((void *)0)) {
      if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
        tmp___0 = (char const   *)msa->name;
      } else {
        tmp___0 = "";
      }
      Die((char *)"Parse error: No sequence for %s in alignment %s", *(msa->sqname + idx),
          tmp___0);
    }
    if (msa->flags & 1) {
      if ((double )*(msa->wgt + idx) == - 1.0) {
        if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
          tmp___1 = (char const   *)msa->name;
        } else {
          tmp___1 = "";
        }
        Die((char *)"Parse error: some weights are set, but %s doesn\'t have one in alignment %s",
            *(msa->sqname + idx), tmp___1);
      }
    }
    if (*(msa->sqlen + idx) != msa->alen) {
      if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
        tmp___2 = (char const   *)msa->name;
      } else {
        tmp___2 = "";
      }
      Die((char *)"Parse error: sequence %s: length %d, expected %d in alignment %s",
          *(msa->sqname + idx), *(msa->sqlen + idx), msa->alen, tmp___2);
    }
    if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
      if ((unsigned long )*(msa->ss + idx) != (unsigned long )((void *)0)) {
        if (*(msa->sslen + idx) != msa->alen) {
          if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
            tmp___3 = (char const   *)msa->name;
          } else {
            tmp___3 = "";
          }
          Die((char *)"Parse error: #=GR SS annotation for %s: length %d, expected %d in alignment %s",
              *(msa->sqname + idx), *(msa->sslen + idx), msa->alen, tmp___3);
        }
      }
    }
    if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
      if ((unsigned long )*(msa->sa + idx) != (unsigned long )((void *)0)) {
        if (*(msa->salen + idx) != msa->alen) {
          if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
            tmp___4 = (char const   *)msa->name;
          } else {
            tmp___4 = "";
          }
          Die((char *)"Parse error: #=GR SA annotation for %s: length %d, expected %d in alignment %s",
              *(msa->sqname + idx), *(msa->salen + idx), msa->alen, tmp___4);
        }
      }
    }
    idx ++;
  }
  if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
    tmp___7 = strlen((char const   *)msa->ss_cons);
    if (tmp___7 != (size_t )msa->alen) {
      if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
        tmp___5 = (char const   *)msa->name;
      } else {
        tmp___5 = "";
      }
      tmp___6 = strlen((char const   *)msa->ss_cons);
      Die((char *)"Parse error: #=GC SS_cons annotation: length %d, expected %d in alignment %s",
          tmp___6, msa->alen, tmp___5);
    }
  }
  if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
    tmp___10 = strlen((char const   *)msa->sa_cons);
    if (tmp___10 != (size_t )msa->alen) {
      if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
        tmp___8 = (char const   *)msa->name;
      } else {
        tmp___8 = "";
      }
      tmp___9 = strlen((char const   *)msa->sa_cons);
      Die((char *)"Parse error: #=GC SA_cons annotation: length %d, expected %d in alignment %s",
          tmp___9, msa->alen, tmp___8);
    }
  }
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
    tmp___13 = strlen((char const   *)msa->rf);
    if (tmp___13 != (size_t )msa->alen) {
      if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
        tmp___11 = (char const   *)msa->name;
      } else {
        tmp___11 = "";
      }
      tmp___12 = strlen((char const   *)msa->rf);
      Die((char *)"Parse error: #=GC RF annotation: length %d, expected %d in alignment %s",
          tmp___12, msa->alen, tmp___11);
    }
  }
  if (! (msa->flags & 1)) {
    FSet(msa->wgt, msa->nseq, (float )1.0);
  }
  if ((unsigned long )msa->sqlen != (unsigned long )((void *)0)) {
    free((void *)msa->sqlen);
    msa->sqlen = (int *)((void *)0);
  }
  if ((unsigned long )msa->sslen != (unsigned long )((void *)0)) {
    free((void *)msa->sslen);
    msa->sslen = (int *)((void *)0);
  }
  if ((unsigned long )msa->salen != (unsigned long )((void *)0)) {
    free((void *)msa->salen);
    msa->salen = (int *)((void *)0);
  }
  return;
}
}
MSAFILE *MSAFileOpen(char *filename , int format , char *env ) 
{ 
  MSAFILE *afp ;
  void *tmp ;
  char *ssifile ;
  char *dir ;
  size_t tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  char *full ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  unsigned long tmp___6 ;
  FILE *tmp___7 ;
  FILE *tmp___8 ;
  int tmp___9 ;

  {
  tmp = sre_malloc((char *)"msa.c", 760, sizeof(MSAFILE ));
  afp = (MSAFILE *)tmp;
  tmp___9 = strcmp((char const   *)filename, "-");
  if (tmp___9 == 0) {
    afp->f = __stdinp;
    afp->do_stdin = 1;
    afp->do_gzip = 0;
    afp->fname = sre_strdup((char *)"[STDIN]", -1);
    afp->ssi = (SSIFILE *)((void *)0);
  } else {
    tmp___8 = fopen((char const   *)filename, "r");
    afp->f = tmp___8;
    if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
      tmp___0 = strlen((char const   *)filename);
      tmp___1 = sre_malloc((char *)"msa.c", 806, sizeof(char ) * (tmp___0 + 5UL));
      ssifile = (char *)tmp___1;
      tmp___2 = __builtin_object_size((void *)ssifile, 1);
      __builtin___sprintf_chk(ssifile, 0, tmp___2, "%s.ssi", filename);
    } else {
      tmp___7 = EnvFileOpen(filename, env, & dir);
      afp->f = tmp___7;
      if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
        full = FileConcat(dir, filename);
        tmp___3 = strlen((char const   *)full);
        tmp___4 = strlen((char const   *)filename);
        tmp___5 = sre_malloc((char *)"msa.c", 813, sizeof(char ) * ((tmp___3 + tmp___4) + 5UL));
        ssifile = (char *)tmp___5;
        tmp___6 = __builtin_object_size((void *)ssifile, 1);
        __builtin___sprintf_chk(ssifile, 0, tmp___6, "%s.ssi", full);
        free((void *)dir);
      } else {
        return ((MSAFILE *)((void *)0));
      }
    }
    afp->do_stdin = 0;
    afp->do_gzip = 0;
    afp->fname = sre_strdup(filename, -1);
    afp->ssi = (SSIFILE *)((void *)0);
    SSIOpen(ssifile, & afp->ssi);
    free((void *)ssifile);
  }
  if (format == 0) {
    if (afp->do_stdin == 1) {
      Die((char *)"Can\'t autodetect alignment file format from a stdin or gzip pipe");
    } else
    if (afp->do_gzip) {
      Die((char *)"Can\'t autodetect alignment file format from a stdin or gzip pipe");
    }
    format = MSAFileFormat(afp);
    if (format == 0) {
      Die((char *)"Can\'t determine format of multiple alignment file %s", afp->fname);
    }
  }
  afp->format = format;
  afp->linenumber = 0;
  afp->buf = (char *)((void *)0);
  afp->buflen = 0;
  return (afp);
}
}
int MSAFileRewind(MSAFILE *afp ) 
{ 


  {
  if (afp->do_gzip) {
    return (0);
  } else
  if (afp->do_stdin) {
    return (0);
  }
  rewind(afp->f);
  return (1);
}
}
int MSAFilePositionByKey(MSAFILE *afp , char *key ) 
{ 
  int fh ;
  SSIOFFSET offset ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )afp->ssi == (unsigned long )((void *)0)) {
    return (0);
  }
  tmp = SSIGetOffsetByName(afp->ssi, key, & fh, & offset);
  if (tmp != 0) {
    return (0);
  }
  tmp___0 = SSISetFilePosition(afp->f, & offset);
  if (tmp___0 != 0) {
    return (0);
  }
  return (1);
}
}
int MSAFilePositionByIndex(MSAFILE *afp , int idx ) 
{ 
  int fh ;
  SSIOFFSET offset ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )afp->ssi == (unsigned long )((void *)0)) {
    return (0);
  }
  tmp = SSIGetOffsetByNumber(afp->ssi, idx, & fh, & offset);
  if (tmp != 0) {
    return (0);
  }
  tmp___0 = SSISetFilePosition(afp->f, & offset);
  if (tmp___0 != 0) {
    return (0);
  }
  return (1);
}
}
MSA *MSAFileRead(MSAFILE *afp ) 
{ 
  MSA *msa ;

  {
  msa = (MSA *)((void *)0);
  switch (afp->format) {
  case 101: 
  msa = ReadStockholm(afp);
  break;
  case 103: 
  msa = ReadMSF(afp);
  break;
  case 105: 
  msa = ReadA2M(afp);
  break;
  case 104: 
  msa = ReadClustal(afp);
  break;
  case 102: 
  msa = ReadSELEX(afp);
  break;
  case 106: 
  msa = ReadPhylip(afp);
  break;
  default: 
  Die((char *)"MSAFILE corrupted: bad format index");
  }
  return (msa);
}
}
void MSAFileClose(MSAFILE *afp ) 
{ 


  {
  if (! afp->do_stdin) {
    fclose(afp->f);
  }
  if ((unsigned long )afp->buf != (unsigned long )((void *)0)) {
    free((void *)afp->buf);
  }
  if ((unsigned long )afp->ssi != (unsigned long )((void *)0)) {
    SSIClose(afp->ssi);
  }
  if ((unsigned long )afp->fname != (unsigned long )((void *)0)) {
    free((void *)afp->fname);
  }
  free((void *)afp);
  return;
}
}
char *MSAFileGetLine(MSAFILE *afp ) 
{ 
  char *s___0 ;

  {
  s___0 = sre_fgets(& afp->buf, & afp->buflen, afp->f);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  (afp->linenumber) ++;
  return (afp->buf);
}
}
void MSAFileWrite(FILE *fp , MSA *msa , int outfmt , int do_oneline ) 
{ 


  {
  switch (outfmt) {
  case 105: 
  WriteA2M(fp, msa);
  break;
  case 104: 
  WriteClustal(fp, msa);
  break;
  case 103: 
  WriteMSF(fp, msa);
  break;
  case 106: 
  WritePhylip(fp, msa);
  break;
  case 102: 
  WriteSELEX(fp, msa);
  break;
  case 101: 
  if (do_oneline) {
    WriteStockholmOneBlock(fp, msa);
  } else {
    WriteStockholm(fp, msa);
  }
  break;
  default: 
  Die((char *)"can\'t write. no such alignment format %d\n", outfmt);
  }
  return;
}
}
int MSAGetSeqidx(MSA *msa , char *name , int guess ) 
{ 
  int seqidx ;
  int tmp ;

  {
  if (guess >= 0) {
    if (guess < msa->nseq) {
      tmp = strcmp((char const   *)name, (char const   *)*(msa->sqname + guess));
      if (tmp == 0) {
        return (guess);
      }
    }
  }
  seqidx = GKIKeyIndex(msa->index, name);
  if (seqidx >= 0) {
    return (seqidx);
  }
  seqidx = GKIStoreKey(msa->index, name);
  if (seqidx >= msa->nseqalloc) {
    MSAExpand(msa);
  }
  *(msa->sqname + seqidx) = sre_strdup(name, -1);
  (msa->nseq) ++;
  return (seqidx);
}
}
MSA *MSAFromAINFO(char **aseq , AINFO *ainfo ) 
{ 
  MSA *msa ;
  int i___0 ;
  int j ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  msa = MSAAlloc(ainfo->nseq, ainfo->alen);
  i___0 = 0;
  while (i___0 < ainfo->nseq) {
    tmp___0 = __builtin_object_size((void *)*(msa->aseq + i___0), 0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)*(msa->aseq + i___0), 1);
      __builtin___strcpy_chk(*(msa->aseq + i___0), (char const   *)*(aseq + i___0),
                             tmp);
    } else {
      __inline_strcpy_chk(*(msa->aseq + i___0), (char const   *)*(aseq + i___0));
    }
    *(msa->wgt + i___0) = *(ainfo->wgt + i___0);
    *(msa->sqname + i___0) = sre_strdup((ainfo->sqinfo + i___0)->name, -1);
    *(msa->sqlen + i___0) = msa->alen;
    GKIStoreKey(msa->index, *(msa->sqname + i___0));
    if ((ainfo->sqinfo + i___0)->flags & (1 << 2)) {
      MSASetSeqAccession(msa, i___0, (ainfo->sqinfo + i___0)->acc);
    }
    if ((ainfo->sqinfo + i___0)->flags & (1 << 3)) {
      MSASetSeqDescription(msa, i___0, (ainfo->sqinfo + i___0)->desc);
    }
    if ((ainfo->sqinfo + i___0)->flags & (1 << 9)) {
      if ((unsigned long )msa->ss == (unsigned long )((void *)0)) {
        tmp___1 = sre_malloc((char *)"msa.c", 1055, sizeof(char *) * (unsigned long )msa->nseqalloc);
        msa->ss = (char **)tmp___1;
        tmp___2 = sre_malloc((char *)"msa.c", 1056, sizeof(int ) * (unsigned long )msa->nseqalloc);
        msa->sslen = (int *)tmp___2;
        j = 0;
        while (j < msa->nseqalloc) {
          *(msa->ss + j) = (char *)((void *)0);
          *(msa->sslen + j) = 0;
          j ++;
        }
      }
      MakeAlignedString(*(msa->aseq + i___0), msa->alen, (ainfo->sqinfo + i___0)->ss,
                        msa->ss + i___0);
      *(msa->sslen + i___0) = msa->alen;
    }
    if ((ainfo->sqinfo + i___0)->flags & (1 << 10)) {
      if ((unsigned long )msa->sa == (unsigned long )((void *)0)) {
        tmp___3 = sre_malloc((char *)"msa.c", 1068, sizeof(char *) * (unsigned long )msa->nseqalloc);
        msa->sa = (char **)tmp___3;
        tmp___4 = sre_malloc((char *)"msa.c", 1069, sizeof(int ) * (unsigned long )msa->nseqalloc);
        msa->salen = (int *)tmp___4;
        j = 0;
        while (j < msa->nseqalloc) {
          *(msa->sa + j) = (char *)((void *)0);
          *(msa->salen + j) = 0;
          j ++;
        }
      }
      MakeAlignedString(*(msa->aseq + i___0), msa->alen, (ainfo->sqinfo + i___0)->sa,
                        msa->sa + i___0);
      *(msa->salen + i___0) = msa->alen;
    }
    i___0 ++;
  }
  msa->name = sre_strdup(ainfo->name, -1);
  msa->desc = sre_strdup(ainfo->desc, -1);
  msa->acc = sre_strdup(ainfo->acc, -1);
  msa->au = sre_strdup(ainfo->au, -1);
  msa->ss_cons = sre_strdup(ainfo->cs, -1);
  msa->rf = sre_strdup(ainfo->rf, -1);
  if (ainfo->flags & 1) {
    msa->cutoff[0] = ainfo->tc1;
    msa->cutoff_is_set[0] = 1;
    msa->cutoff[1] = ainfo->tc2;
    msa->cutoff_is_set[1] = 1;
  }
  if (ainfo->flags & (1 << 1)) {
    msa->cutoff[4] = ainfo->nc1;
    msa->cutoff_is_set[4] = 1;
    msa->cutoff[5] = ainfo->nc2;
    msa->cutoff_is_set[5] = 1;
  }
  if (ainfo->flags & (1 << 2)) {
    msa->cutoff[2] = ainfo->ga1;
    msa->cutoff_is_set[2] = 1;
    msa->cutoff[3] = ainfo->ga2;
    msa->cutoff_is_set[3] = 1;
  }
  msa->nseq = ainfo->nseq;
  msa->alen = ainfo->alen;
  return (msa);
}
}
int MSAFileFormat(MSAFILE *afp ) 
{ 
  int fmt ;
  char *tmp ;

  {
  fmt = SeqfileFormat(afp->f);
  if (fmt == 7) {
    fmt = 105;
  }
  if (fmt != 0) {
    if (! (fmt > 100)) {
      tmp = SeqfileFormat2String(fmt);
      Die((char *)"File %s does not appear to be an alignment file;\nrather, it appears to be an unaligned file in %s format.\nI\'m expecting an alignment file in this context.\n",
          afp->fname, tmp);
    }
  }
  return (fmt);
}
}
void MSAMingap(MSA *msa ) 
{ 
  int *useme ;
  int apos ;
  int idx ;
  void *tmp ;

  {
  tmp = sre_malloc((char *)"msa.c", 1157, sizeof(int ) * (unsigned long )msa->alen);
  useme = (int *)tmp;
  apos = 0;
  while (apos < msa->alen) {
    idx = 0;
    while (idx < msa->nseq) {
      if (! ((int )*(*(msa->aseq + idx) + apos) == 32)) {
        if (! ((int )*(*(msa->aseq + idx) + apos) == 46)) {
          if (! ((int )*(*(msa->aseq + idx) + apos) == 95)) {
            if (! ((int )*(*(msa->aseq + idx) + apos) == 45)) {
              if (! ((int )*(*(msa->aseq + idx) + apos) == 126)) {
                break;
              }
            }
          }
        }
      }
      idx ++;
    }
    if (idx == msa->nseq) {
      *(useme + apos) = 0;
    } else {
      *(useme + apos) = 1;
    }
    apos ++;
  }
  MSAShorterAlignment(msa, useme);
  free((void *)useme);
  return;
}
}
void MSANogap(MSA *msa ) 
{ 
  int *useme ;
  int apos ;
  int idx ;
  void *tmp ;

  {
  tmp = sre_malloc((char *)"msa.c", 1189, sizeof(int ) * (unsigned long )msa->alen);
  useme = (int *)tmp;
  apos = 0;
  while (apos < msa->alen) {
    idx = 0;
    while (idx < msa->nseq) {
      if ((int )*(*(msa->aseq + idx) + apos) == 32) {
        break;
      } else
      if ((int )*(*(msa->aseq + idx) + apos) == 46) {
        break;
      } else
      if ((int )*(*(msa->aseq + idx) + apos) == 95) {
        break;
      } else
      if ((int )*(*(msa->aseq + idx) + apos) == 45) {
        break;
      } else
      if ((int )*(*(msa->aseq + idx) + apos) == 126) {
        break;
      }
      idx ++;
    }
    if (idx == msa->nseq) {
      *(useme + apos) = 1;
    } else {
      *(useme + apos) = 0;
    }
    apos ++;
  }
  MSAShorterAlignment(msa, useme);
  free((void *)useme);
  return;
}
}
void MSAShorterAlignment(MSA *msa , int *useme ) 
{ 
  int apos ;
  int mpos ;
  int idx ;
  int i___0 ;

  {
  apos = 0;
  mpos = 0;
  while (apos < msa->alen) {
    if (*(useme + apos) == 0) {
      goto __Cont;
    }
    if (mpos != apos) {
      idx = 0;
      while (idx < msa->nseq) {
        *(*(msa->aseq + idx) + mpos) = *(*(msa->aseq + idx) + apos);
        if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
          if ((unsigned long )*(msa->ss + idx) != (unsigned long )((void *)0)) {
            *(*(msa->ss + idx) + mpos) = *(*(msa->ss + idx) + apos);
          }
        }
        if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
          if ((unsigned long )*(msa->sa + idx) != (unsigned long )((void *)0)) {
            *(*(msa->sa + idx) + mpos) = *(*(msa->sa + idx) + apos);
          }
        }
        i___0 = 0;
        while (i___0 < msa->ngr) {
          if ((unsigned long )*(*(msa->gr + i___0) + idx) != (unsigned long )((void *)0)) {
            *(*(*(msa->gr + i___0) + idx) + mpos) = *(*(*(msa->gr + i___0) + idx) + apos);
          }
          i___0 ++;
        }
        idx ++;
      }
      if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
        *(msa->ss_cons + mpos) = *(msa->ss_cons + apos);
      }
      if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
        *(msa->sa_cons + mpos) = *(msa->sa_cons + apos);
      }
      if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
        *(msa->rf + mpos) = *(msa->rf + apos);
      }
      i___0 = 0;
      while (i___0 < msa->ngc) {
        *(*(msa->gc + i___0) + mpos) = *(*(msa->gc + i___0) + apos);
        i___0 ++;
      }
    }
    mpos ++;
    __Cont: /* CIL Label */ 
    apos ++;
  }
  msa->alen = mpos;
  idx = 0;
  while (idx < msa->nseq) {
    *(*(msa->aseq + idx) + mpos) = (char )'\000';
    if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
      if ((unsigned long )*(msa->ss + idx) != (unsigned long )((void *)0)) {
        *(*(msa->ss + idx) + mpos) = (char )'\000';
      }
    }
    if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
      if ((unsigned long )*(msa->sa + idx) != (unsigned long )((void *)0)) {
        *(*(msa->sa + idx) + mpos) = (char )'\000';
      }
    }
    i___0 = 0;
    while (i___0 < msa->ngr) {
      if ((unsigned long )*(*(msa->gr + i___0) + idx) != (unsigned long )((void *)0)) {
        *(*(*(msa->gr + i___0) + idx) + mpos) = (char )'\000';
      }
      i___0 ++;
    }
    idx ++;
  }
  if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
    *(msa->ss_cons + mpos) = (char )'\000';
  }
  if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
    *(msa->sa_cons + mpos) = (char )'\000';
  }
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
    *(msa->rf + mpos) = (char )'\000';
  }
  i___0 = 0;
  while (i___0 < msa->ngc) {
    *(*(msa->gc + i___0) + mpos) = (char )'\000';
    i___0 ++;
  }
  return;
}
}
void MSASmallerAlignment(MSA *msa , int *useme , MSA **ret_new ) 
{ 
  MSA *new ;
  int nnew ;
  int oidx ;
  int nidx ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
  nnew = 0;
  oidx = 0;
  while (oidx < msa->nseq) {
    if (*(useme + oidx)) {
      nnew ++;
    }
    oidx ++;
  }
  if (nnew == 0) {
    *ret_new = (MSA *)((void *)0);
    return;
  }
  new = MSAAlloc(nnew, 0);
  nidx = 0;
  oidx = 0;
  while (oidx < msa->nseq) {
    if (*(useme + oidx)) {
      *(new->aseq + nidx) = sre_strdup(*(msa->aseq + oidx), msa->alen);
      *(new->sqname + nidx) = sre_strdup(*(msa->sqname + oidx), msa->alen);
      GKIStoreKey(new->index, *(msa->sqname + oidx));
      *(new->wgt + nidx) = *(msa->wgt + oidx);
      if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
        MSASetSeqAccession(new, nidx, *(msa->sqacc + oidx));
      }
      if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
        MSASetSeqDescription(new, nidx, *(msa->sqdesc + oidx));
      }
      if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
        if ((unsigned long )*(msa->ss + oidx) != (unsigned long )((void *)0)) {
          if ((unsigned long )new->ss == (unsigned long )((void *)0)) {
            tmp = sre_malloc((char *)"msa.c", 1333, sizeof(char *) * (unsigned long )new->nseq);
            new->ss = (char **)tmp;
          }
          *(new->ss + nidx) = sre_strdup(*(msa->ss + oidx), -1);
        }
      }
      if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
        if ((unsigned long )*(msa->sa + oidx) != (unsigned long )((void *)0)) {
          if ((unsigned long )new->sa == (unsigned long )((void *)0)) {
            tmp___0 = sre_malloc((char *)"msa.c", 1338, sizeof(char *) * (unsigned long )new->nseq);
            new->sa = (char **)tmp___0;
          }
          *(new->sa + nidx) = sre_strdup(*(msa->sa + oidx), -1);
        }
      }
      nidx ++;
    }
    oidx ++;
  }
  new->nseq = nnew;
  new->alen = msa->alen;
  new->flags = msa->flags;
  new->type = msa->type;
  new->name = sre_strdup(msa->name, -1);
  new->desc = sre_strdup(msa->desc, -1);
  new->acc = sre_strdup(msa->acc, -1);
  new->au = sre_strdup(msa->au, -1);
  new->ss_cons = sre_strdup(msa->ss_cons, -1);
  new->sa_cons = sre_strdup(msa->sa_cons, -1);
  new->rf = sre_strdup(msa->rf, -1);
  i___0 = 0;
  while (i___0 < 6) {
    new->cutoff[i___0] = msa->cutoff[i___0];
    new->cutoff_is_set[i___0] = msa->cutoff_is_set[i___0];
    i___0 ++;
  }
  free((void *)new->sqlen);
  MSAMingap(new);
  *ret_new = new;
  return;
}
}
char *MSAGetSeqAccession(MSA *msa , int idx ) 
{ 


  {
  if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
    if ((unsigned long )*(msa->sqacc + idx) != (unsigned long )((void *)0)) {
      return (*(msa->sqacc + idx));
    } else {
      return ((char *)((void *)0));
    }
  } else {
    return ((char *)((void *)0));
  }
}
}
char *MSAGetSeqDescription(MSA *msa , int idx ) 
{ 


  {
  if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
    if ((unsigned long )*(msa->sqdesc + idx) != (unsigned long )((void *)0)) {
      return (*(msa->sqdesc + idx));
    } else {
      return ((char *)((void *)0));
    }
  } else {
    return ((char *)((void *)0));
  }
}
}
char *MSAGetSeqSS(MSA *msa , int idx ) 
{ 


  {
  if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
    if ((unsigned long )*(msa->ss + idx) != (unsigned long )((void *)0)) {
      return (*(msa->ss + idx));
    } else {
      return ((char *)((void *)0));
    }
  } else {
    return ((char *)((void *)0));
  }
}
}
char *MSAGetSeqSA(MSA *msa , int idx ) 
{ 


  {
  if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
    if ((unsigned long )*(msa->sa + idx) != (unsigned long )((void *)0)) {
      return (*(msa->sa + idx));
    } else {
      return ((char *)((void *)0));
    }
  } else {
    return ((char *)((void *)0));
  }
}
}
float MSAAverageSequenceLength(MSA *msa ) 
{ 
  int i___0 ;
  float avg ;
  int tmp ;

  {
  avg = (float )0.;
  i___0 = 0;
  while (i___0 < msa->nseq) {
    tmp = DealignedLength(*(msa->aseq + i___0));
    avg += (float )tmp;
    i___0 ++;
  }
  if (msa->nseq == 0) {
    return ((float )0.);
  } else {
    return (avg / (float )msa->nseq);
  }
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-F6q5kiHh.i","-O3")
extern int fputc(int  , FILE * ) ;
__inline static int isalnum(int _c ) 
{ 
  int tmp ;

  {
  tmp = __istype(_c, 1280UL);
  return (tmp);
}
}
extern struct tm *localtime(time_t const   * ) ;
extern size_t strftime(char * , size_t  , char const   * , struct tm  const  * )  __asm__("_strftime")  ;
int GCGchecksum(char *seq , int len ) ;
int GCGMultchecksum(char **seqs , int nseq ) ;
int GuessAlignmentSeqtype(char **aseq , int nseq ) ;
int IsBlankline(char *s___0 ) ;
MSA *ReadMSF(MSAFILE *afp ) 
{ 
  MSA *msa ;
  char *s___0 ;
  int alleged_alen ;
  int alleged_type ;
  int alleged_checksum ;
  char *tok ;
  char *sp ;
  int slen ;
  int sqidx ;
  char *name ;
  char *seq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  tmp = feof(afp->f);
  if (tmp) {
    return ((MSA *)((void *)0));
  }
  s___0 = MSAFileGetLine(afp);
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return ((MSA *)((void *)0));
  }
  msa = MSAAlloc(10, 0);
  tmp___1 = strncmp((char const   *)s___0, "!!AA_MULTIPLE_ALIGNMENT", (size_t )23);
  if (tmp___1 == 0) {
    msa->type = 3;
    s___0 = MSAFileGetLine(afp);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      return ((MSA *)((void *)0));
    }
  } else {
    tmp___0 = strncmp((char const   *)s___0, "!!NA_MULTIPLE_ALIGNMENT", (size_t )23);
    if (tmp___0 == 0) {
      msa->type = 2;
      s___0 = MSAFileGetLine(afp);
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
        return ((MSA *)((void *)0));
      }
    }
  }
  while (1) {
    tmp___2 = strstr((char const   *)s___0, "..");
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      tmp___3 = strstr((char const   *)s___0, "MSF:");
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
        tmp___4 = Strparse((char *)"^.+MSF: +([0-9]+) +Type: +([PNX]).+Check: +([0-9]+) +\\.\\.",
                           s___0, 3);
        if (tmp___4) {
          alleged_alen = atoi((char const   *)sqd_parse[0]);
          switch ((int )*(sqd_parse[1])) {
          case 78: 
          alleged_type = 2;
          break;
          case 80: 
          alleged_type = 3;
          break;
          case 88: 
          alleged_type = 0;
          break;
          default: 
          alleged_type = 0;
          }
          alleged_checksum = atoi((char const   *)sqd_parse[3]);
          if (msa->type == 0) {
            msa->type = alleged_type;
          }
          break;
        }
      }
    }
    tmp___5 = IsBlankline(s___0);
    if (! tmp___5) {
      MSAAddComment(msa, s___0);
    }
    s___0 = MSAFileGetLine(afp);
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
      break;
    }
  }
  while (1) {
    s___0 = MSAFileGetLine(afp);
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
      break;
    }
    while (1) {
      if ((int )*s___0 == 32) {
        goto _L;
      } else
      if ((int )*s___0 == 9) {
        _L: /* CIL Label */ 
        if (! *s___0) {
          break;
        }
      } else {
        break;
      }
      s___0 ++;
    }
    if ((int )*s___0 == 10) {
      continue;
    } else
    if ((int )*s___0 == 33) {
      MSAAddComment(msa, s___0);
    } else {
      sp = strstr((char const   *)s___0, "Name:");
      if ((unsigned long )sp != (unsigned long )((void *)0)) {
        sp += 5;
        tok = sre_strtok(& sp, (char *)" \t", & slen);
        sqidx = GKIStoreKey(msa->index, tok);
        if (sqidx >= msa->nseqalloc) {
          MSAExpand(msa);
        }
        *(msa->sqname + sqidx) = sre_strdup(tok, slen);
        (msa->nseq) ++;
        sp = strstr((char const   *)sp, "Weight:");
        if ((unsigned long )sp == (unsigned long )((void *)0)) {
          Die((char *)"No Weight: on line %d for %s in name section of MSF file %s\n",
              afp->linenumber, *(msa->sqname + sqidx), afp->fname);
        }
        sp += 7;
        tok = sre_strtok(& sp, (char *)" \t", & slen);
        tmp___6 = atof((char const   *)tok);
        *(msa->wgt + sqidx) = (float )tmp___6;
        msa->flags |= 1;
      } else {
        tmp___7 = strncmp((char const   *)s___0, "//", (size_t )2);
        if (tmp___7 == 0) {
          break;
        } else {
          Die((char *)"Invalid line (probably %d) in name section of MSF file %s:\n%s\n",
              afp->linenumber, afp->fname, s___0);
          squid_errno = 5;
          return ((MSA *)((void *)0));
        }
      }
    }
  }
  while (1) {
    s___0 = MSAFileGetLine(afp);
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
      break;
    }
    sp = s___0;
    name = sre_strtok(& sp, (char *)" \t", (int *)((void *)0));
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      continue;
    }
    seq = sre_strtok(& sp, (char *)"\n", & slen);
    if ((unsigned long )seq == (unsigned long )((void *)0)) {
      continue;
    }
    tmp___8 = isdigit((int )*name);
    if (tmp___8) {
      tmp___9 = isdigit((int )*seq);
      if (tmp___9) {
        continue;
      }
    }
    sqidx = GKIKeyIndex(msa->index, name);
    if (sqidx < 0) {
      continue;
    }
    *(msa->sqlen + sqidx) = sre_strcat(msa->aseq + sqidx, *(msa->sqlen + sqidx), seq,
                                       slen);
  }
  sqidx = 0;
  while (sqidx < msa->nseq) {
    if ((unsigned long )*(msa->aseq + sqidx) == (unsigned long )((void *)0)) {
      Die((char *)"Didn\'t find a sequence for %s in MSF file %s\n", *(msa->sqname + sqidx),
          afp->fname);
    }
    sp = *(msa->aseq + sqidx);
    s___0 = sp;
    while ((int )*s___0 != 0) {
      if ((int )*s___0 == 32) {
        (*(msa->sqlen + sqidx)) --;
      } else
      if ((int )*s___0 == 9) {
        (*(msa->sqlen + sqidx)) --;
      } else {
        *sp = *s___0;
        sp ++;
      }
      s___0 ++;
    }
    *sp = (char )'\000';
    sqidx ++;
  }
  MSAVerifyParse(msa);
  return (msa);
}
}
void WriteMSF(FILE *fp , MSA *msa ) 
{ 
  time_t now ;
  char date[64] ;
  char **gcg_aseq ;
  char **gcg_sqname ;
  int idx ;
  char *s___0 ;
  int len ;
  int namelen ;
  int pos ;
  char buffer___1[51] ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  struct tm *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;

  {
  tmp = sre_malloc((char *)"msf.c", 273, sizeof(char *) * (unsigned long )msa->nseq);
  gcg_aseq = (char **)tmp;
  tmp___0 = sre_malloc((char *)"msf.c", 274, sizeof(char *) * (unsigned long )msa->nseq);
  gcg_sqname = (char **)tmp___0;
  idx = 0;
  while (idx < msa->nseq) {
    *(gcg_aseq + idx) = sre_strdup(*(msa->aseq + idx), msa->alen);
    *(gcg_sqname + idx) = sre_strdup(*(msa->sqname + idx), -1);
    idx ++;
  }
  idx = 0;
  while (idx < msa->nseq) {
    s___0 = *(gcg_sqname + idx);
    while ((int )*s___0 != 0) {
      tmp___1 = isalnum((int )*s___0);
      if (! tmp___1) {
        if ((int )*s___0 != 45) {
          if ((int )*s___0 != 95) {
            *s___0 = (char )'_';
          }
        }
      }
      s___0 ++;
    }
    idx ++;
  }
  idx = 0;
  while (idx < msa->nseq) {
    s___0 = *(gcg_aseq + idx);
    while (1) {
      if ((int )*s___0 != 0) {
        if (! ((int )*s___0 == 32)) {
          if (! ((int )*s___0 == 46)) {
            if (! ((int )*s___0 == 95)) {
              if (! ((int )*s___0 == 45)) {
                if (! ((int )*s___0 == 126)) {
                  break;
                }
              }
            }
          }
        }
      } else {
        break;
      }
      *s___0 = (char )'~';
      s___0 ++;
    }
    while ((int )*s___0 != 0) {
      if ((int )*s___0 == 32) {
        *s___0 = (char )'.';
      } else
      if ((int )*s___0 == 46) {
        *s___0 = (char )'.';
      } else
      if ((int )*s___0 == 95) {
        *s___0 = (char )'.';
      } else
      if ((int )*s___0 == 45) {
        *s___0 = (char )'.';
      } else
      if ((int )*s___0 == 126) {
        *s___0 = (char )'.';
      }
      s___0 ++;
    }
    pos = msa->alen - 1;
    while (1) {
      if (pos > 0) {
        if (! ((int )*(*(gcg_aseq + idx) + pos) == 32)) {
          if (! ((int )*(*(gcg_aseq + idx) + pos) == 46)) {
            if (! ((int )*(*(gcg_aseq + idx) + pos) == 95)) {
              if (! ((int )*(*(gcg_aseq + idx) + pos) == 45)) {
                if (! ((int )*(*(gcg_aseq + idx) + pos) == 126)) {
                  break;
                }
              }
            }
          }
        }
      } else {
        break;
      }
      *(*(gcg_aseq + idx) + pos) = (char )'~';
      pos --;
    }
    idx ++;
  }
  namelen = 0;
  idx = 0;
  while (idx < msa->nseq) {
    tmp___2 = strlen((char const   *)*(msa->sqname + idx));
    len = (int )tmp___2;
    if (len > namelen) {
      namelen = len;
    }
    idx ++;
  }
  if (msa->type == 0) {
    msa->type = GuessAlignmentSeqtype(msa->aseq, msa->nseq);
  }
  if (msa->type == 2) {
    fprintf(fp, "!!NA_MULTIPLE_ALIGNMENT 1.0\n");
  } else
  if (msa->type == 1) {
    fprintf(fp, "!!NA_MULTIPLE_ALIGNMENT 1.0\n");
  } else
  if (msa->type == 3) {
    fprintf(fp, "!!AA_MULTIPLE_ALIGNMENT 1.0\n");
  } else
  if (msa->type == 0) {
    Die((char *)"WriteMSF(): couldn\'t guess whether that alignment is RNA or protein.\n");
  } else {
    Die((char *)"Invalid sequence type %d in WriteMSF()\n", msa->type);
  }
  if (msa->ncomment > 0) {
    idx = 0;
    while (idx < msa->ncomment) {
      fprintf(fp, "%s\n", *(msa->comment + idx));
      idx ++;
    }
    fprintf(fp, "\n");
  }
  now = time((time_t *)((void *)0));
  tmp___3 = localtime((time_t const   *)(& now));
  tmp___4 = strftime(date, (size_t )64, "%B %d, %Y %H:%M", (struct tm  const  *)tmp___3);
  if (tmp___4 == 0UL) {
    Die((char *)"What time is it on earth? strftime() failed in WriteMSF().\n");
  }
  tmp___5 = GCGMultchecksum(gcg_aseq, msa->nseq);
  if (msa->type == 2) {
    tmp___6 = 'N';
  } else {
    tmp___6 = 'P';
  }
  if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
    tmp___7 = (char const   *)msa->name;
  } else {
    tmp___7 = "squid.msf";
  }
  fprintf(fp, " %s  MSF: %d  Type: %c  %s  Check: %d  ..\n", tmp___7, msa->alen, tmp___6,
          date, tmp___5);
  fprintf(fp, "\n");
  idx = 0;
  while (idx < msa->nseq) {
    tmp___8 = GCGchecksum(*(gcg_aseq + idx), msa->alen);
    fprintf(fp, " Name: %-*.*s  Len:  %5d  Check: %4d  Weight: %.2f\n", namelen, namelen,
            *(gcg_sqname + idx), msa->alen, tmp___8, (double )*(msa->wgt + idx));
    idx ++;
  }
  fprintf(fp, "\n");
  fprintf(fp, "//\n");
  pos = 0;
  while (pos < msa->alen) {
    fprintf(fp, "\n");
    if (pos + 50 > msa->alen) {
      len = msa->alen - pos;
    } else {
      len = 50;
    }
    if (len > 10) {
      fprintf(fp, "%*s  %-6d%*s%6d\n", namelen, "", pos + 1, (len + (len - 1) / 10) - 12,
              "", pos + len);
    } else {
      fprintf(fp, "%*s  %-6d\n", namelen, "", pos + 1);
    }
    idx = 0;
    while (idx < msa->nseq) {
      fprintf(fp, "%-*s ", namelen, *(gcg_sqname + idx));
      tmp___10 = __builtin_object_size((void *)(buffer___1), 0);
      if (tmp___10 != 0xffffffffffffffffUL) {
        tmp___9 = __builtin_object_size((void *)(buffer___1), 1);
        __builtin___strncpy_chk(buffer___1, (char const   *)(*(gcg_aseq + idx) + pos),
                                50UL, tmp___9);
      } else {
        __inline_strncpy_chk(buffer___1, (char const   *)(*(gcg_aseq + idx) + pos),
                             (size_t )50);
      }
      buffer___1[50] = (char )'\000';
      i___0 = 0;
      while (i___0 < len) {
        if (! (i___0 % 10)) {
          fputc(' ', fp);
        }
        fputc((int )buffer___1[i___0], fp);
        i___0 ++;
      }
      fputc('\n', fp);
      idx ++;
    }
    pos += 50;
  }
  Free2DArray((void **)gcg_aseq, msa->nseq);
  Free2DArray((void **)gcg_sqname, msa->nseq);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-t_56USLO.i","-O3")
MSA *ReadPhylip(MSAFILE *afp ) 
{ 
  MSA *msa ;
  char *s___0 ;
  char *s1 ;
  char *s2 ;
  char name[11] ;
  int nseq ;
  int alen ;
  int idx ;
  int slen ;
  int nblock ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  tmp = feof(afp->f);
  if (tmp) {
    return ((MSA *)((void *)0));
  }
  nseq = 0;
  alen = 0;
  while (1) {
    s___0 = MSAFileGetLine(afp);
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
      break;
    }
    s1 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
    if ((unsigned long )s1 == (unsigned long )((void *)0)) {
      continue;
    }
    s2 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
      Die((char *)"Failed to parse nseq/alen from first line of PHYLIP file %s\n",
          afp->fname);
    }
    tmp___0 = IsInt(s1);
    if (tmp___0) {
      tmp___1 = IsInt(s2);
      if (! tmp___1) {
        Die((char *)"nseq and/or alen not an integer in first line of PHYLIP file %s\n",
            afp->fname);
      }
    } else {
      Die((char *)"nseq and/or alen not an integer in first line of PHYLIP file %s\n",
          afp->fname);
    }
    nseq = atoi((char const   *)s1);
    alen = atoi((char const   *)s2);
    break;
  }
  msa = MSAAlloc(nseq, 0);
  idx = 0;
  nblock = 0;
  while (1) {
    s___0 = MSAFileGetLine(afp);
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
      break;
    }
    tmp___2 = isspace((int )*s___0);
    if (tmp___2) {
      continue;
    }
    if (nblock == 0) {
      tmp___4 = __builtin_object_size((void *)(name), 0);
      if (tmp___4 != 0xffffffffffffffffUL) {
        tmp___3 = __builtin_object_size((void *)(name), 1);
        __builtin___strncpy_chk(name, (char const   *)s___0, 10UL, tmp___3);
      } else {
        __inline_strncpy_chk(name, (char const   *)s___0, (size_t )10);
      }
      name[10] = (char )'\000';
      GKIStoreKey(msa->index, name);
      *(msa->sqname + idx) = sre_strdup(name, -1);
      s___0 += 10;
    }
    s1 = sre_strtok(& s___0, (char *)" \t\n", & slen);
    if ((unsigned long )s1 == (unsigned long )((void *)0)) {
      Die((char *)"Failed to parse sequence at line %d of PHYLIP file %s\n", afp->linenumber,
          afp->fname);
    }
    *(msa->sqlen + idx) = sre_strcat(msa->aseq + idx, *(msa->sqlen + idx), s1, slen);
    idx ++;
    if (idx == nseq) {
      idx = 0;
      nblock ++;
    }
  }
  msa->nseq = nseq;
  MSAVerifyParse(msa);
  return (msa);
}
}
void WritePhylip(FILE *fp , MSA *msa ) 
{ 
  int idx ;
  int cpl ;
  char buf[51] ;
  int pos ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  cpl = 50;
  fprintf(fp, " %d  %d\n", msa->nseq, msa->alen);
  pos = 0;
  while (pos < msa->alen) {
    if (pos > 0) {
      fprintf(fp, "\n");
    }
    idx = 0;
    while (idx < msa->nseq) {
      tmp___0 = __builtin_object_size((void *)(buf), 0);
      if (tmp___0 != 0xffffffffffffffffUL) {
        tmp = __builtin_object_size((void *)(buf), 1);
        __builtin___strncpy_chk(buf, (char const   *)(*(msa->aseq + idx) + pos), (unsigned long )cpl,
                                tmp);
      } else {
        __inline_strncpy_chk(buf, (char const   *)(*(msa->aseq + idx) + pos), (size_t )cpl);
      }
      buf[cpl] = (char )'\000';
      if (pos > 0) {
        fprintf(fp, "%s\n", buf);
      } else {
        fprintf(fp, "%-10.10s%s\n", *(msa->sqname + idx), buf);
      }
      idx ++;
    }
    pos += cpl;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-1oDl5KDp.i","-O3")
char *revcomp(char *comp , char *seq ) ;
int StrReverse(char *s1 , char *s2 ) ;
int sre_tolower(int c ) ;
char *revcomp(char *comp , char *seq ) 
{ 
  char *s___0 ;
  char c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )comp == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  if ((unsigned long )seq == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  StrReverse(comp, seq);
  s___0 = comp;
  while ((int )*s___0 != 0) {
    c = *s___0;
    tmp = sre_toupper((int )c);
    c = (char )tmp;
    switch ((int )c) {
    case 65: 
    c = (char )'T';
    break;
    case 67: 
    c = (char )'G';
    break;
    case 71: 
    c = (char )'C';
    break;
    case 84: 
    c = (char )'A';
    break;
    case 85: 
    c = (char )'A';
    break;
    case 82: 
    c = (char )'Y';
    break;
    case 89: 
    c = (char )'R';
    break;
    case 77: 
    c = (char )'K';
    break;
    case 75: 
    c = (char )'M';
    break;
    case 83: 
    c = (char )'S';
    break;
    case 87: 
    c = (char )'W';
    break;
    case 72: 
    c = (char )'D';
    break;
    case 68: 
    c = (char )'H';
    break;
    case 66: 
    c = (char )'V';
    break;
    case 86: 
    c = (char )'B';
    break;
    default: 
    break;
    }
    tmp___1 = islower((int )*s___0);
    if (tmp___1) {
      tmp___0 = sre_tolower((int )c);
      c = (char )tmp___0;
    }
    *s___0 = c;
    s___0 ++;
  }
  return (comp);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-CKaeHuSa.i","-O3")
int seqencode(char *codeseq , char *str ) ;
int rkseq(Hashseq hashprobe , char *sequence ) ;
Hashseq rkcomp(char *probe ) ;
Hashseq rkcomp(char *probe ) 
{ 
  Hashseq hashprobe ;
  char coded[sizeof(Hashseq ) * 2UL + 1UL] ;
  int len ;
  int i___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  hashprobe = (Hashseq )0;
  tmp = strlen((char const   *)probe);
  len = (int )tmp;
  if ((unsigned long )len > sizeof(Hashseq ) * 2UL) {
    return ((Hashseq )0);
  }
  tmp___0 = seqencode(coded, probe);
  if (tmp___0 == 0) {
    return ((Hashseq )0);
  }
  i___0 = 0;
  while (i___0 < len) {
    hashprobe <<= 4;
    hashprobe |= (Hashseq )coded[i___0];
    i___0 ++;
  }
  while ((unsigned long )i___0 < sizeof(Hashseq ) * 2UL) {
    hashprobe <<= 4;
    hashprobe |= 15UL;
    i___0 ++;
  }
  return (hashprobe);
}
}
int rkseq(Hashseq hashprobe , char *sequence ) 
{ 
  long i___0 ;
  long pos ;
  Hashseq target ;

  {
  pos = 0L;
  target = (Hashseq )0;
  i___0 = 0L;
  while ((unsigned long )i___0 < sizeof(Hashseq ) * 2UL) {
    if ((int )*(sequence + i___0) == 0) {
      break;
    }
    target <<= 4;
    target |= (Hashseq )*(sequence + i___0);
    i___0 ++;
  }
  while ((int )*(((sequence + pos) + sizeof(Hashseq ) * 2UL) - 1) != 0) {
    if ((hashprobe & target) == target) {
      return ((int )pos);
    }
    target <<= 4;
    target |= (Hashseq )*((sequence + pos) + sizeof(Hashseq ) * 2UL);
    pos ++;
  }
  i___0 = 0L;
  while ((unsigned long )i___0 < sizeof(Hashseq ) * 2UL) {
    target |= 15UL;
    if ((hashprobe & target) == target) {
      return ((int )pos);
    }
    target <<= 4;
    pos ++;
    i___0 ++;
  }
  return (-1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-GkWmYyFJ.i","-O3")
void WriteSELEXOneBlock(FILE *fp , MSA *msa ) ;
int DealignAseqs(char **aseqs , int num , char ***ret_rseqs ) ;
int IsSELEXFormat(char *filename ) ;
int SetSeqinfoString(SQINFO *sqinfo , char *sptr___0 , int flag ) ;
static int copy_alignment_line(char *aseq , int apos , int name_rcol , char *buffer___1 ,
                               int lcol , int rcol , char gapsym ) ;
static void actually_write_selex(FILE *fp , MSA *msa , int cpl ) ;
static char commentsyms[3]  = {      (char )'%',      (char )'#',      (char )'\000'};
MSA *ReadSELEX(MSAFILE *afp ) 
{ 
  MSA *msa ;
  FILE *fp ;
  char **aseqs ;
  int num ;
  char buffer___1[4096] ;
  char bufcpy[4096] ;
  struct block_struc *blocks ;
  int blocknum ;
  char *nptr ;
  char *sptr___0 ;
  int currnum ;
  int currblock ;
  int i___0 ;
  int seqidx ;
  int alen ;
  int warn_names ;
  int headnum ;
  int currlen ;
  int count ;
  int have_cs ;
  int have_rf ;
  AINFO base_ainfo ;
  AINFO *ainfo ;
  int tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  unsigned long tmp___14 ;
  unsigned long tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  unsigned long tmp___22 ;
  unsigned long tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  char *tmp___33 ;
  unsigned long tmp___34 ;
  unsigned long tmp___35 ;
  double tmp___36 ;
  double tmp___37 ;
  double tmp___38 ;
  double tmp___39 ;
  double tmp___40 ;
  double tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  double tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  size_t tmp___56 ;
  int tmp___57 ;
  size_t tmp___58 ;
  int tmp___59 ;
  size_t tmp___60 ;
  int tmp___61 ;
  size_t tmp___62 ;
  int tmp___63 ;
  size_t tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  char *tmp___71 ;
  unsigned long tmp___72 ;
  unsigned long tmp___73 ;
  int tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  unsigned long tmp___77 ;
  unsigned long tmp___78 ;
  int tmp___79 ;
  char *tmp___80 ;
  int apos ;
  int rpos ;

  {
  num = 0;
  blocks = (struct block_struc *)((void *)0);
  have_cs = 0;
  have_rf = 0;
  tmp = feof(afp->f);
  if (tmp) {
    return ((MSA *)((void *)0));
  }
  if (afp->do_gzip) {
    Die((char *)"Can\'t read a SELEX format alignment from a pipe, stdin, or gzip\'ed file");
  } else
  if (afp->do_stdin) {
    Die((char *)"Can\'t read a SELEX format alignment from a pipe, stdin, or gzip\'ed file");
  }
  fp = afp->f;
  ainfo = & base_ainfo;
  InitAinfo(ainfo);
  while (1) {
    tmp___0 = fgets(buffer___1, 4096, fp);
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      squid_errno = 2;
      return ((MSA *)0);
    }
    tmp___2 = __builtin_object_size((void *)(bufcpy), 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)(bufcpy), 1);
      __builtin___strcpy_chk(bufcpy, (char const   *)(buffer___1), tmp___1);
    } else {
      __inline_strcpy_chk(bufcpy, (char const   *)(buffer___1));
    }
    if ((int )buffer___1[0] == 35) {
      tmp___4 = strncmp((char const   *)(buffer___1), "#=CS", (size_t )4);
      if (tmp___4 == 0) {
        have_cs = 1;
      } else {
        tmp___3 = strncmp((char const   *)(buffer___1), "#=RF", (size_t )4);
        if (tmp___3 == 0) {
          have_rf = 1;
        }
      }
    }
    nptr = strtok(bufcpy, " \t\n");
    if (! ((unsigned long )nptr == (unsigned long )((void *)0))) {
      tmp___5 = strchr((char const   *)(commentsyms), (int )*nptr);
      if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
        break;
      }
    }
  }
  blocknum = 0;
  warn_names = 0;
  while (1) {
    tmp___25 = feof(fp);
    if (tmp___25) {
      break;
    }
    if (blocknum == 0) {
      tmp___6 = sre_malloc((char *)"selex.c", 151, sizeof(struct block_struc ));
      blocks = (struct block_struc *)tmp___6;
    } else {
      tmp___7 = sre_realloc((char *)"selex.c", 153, (void *)blocks, (unsigned long )(blocknum + 1) * sizeof(struct block_struc ));
      blocks = (struct block_struc *)tmp___7;
    }
    (blocks + blocknum)->lcol = 4097;
    (blocks + blocknum)->rcol = -1;
    currnum = 0;
    while ((unsigned long )nptr != (unsigned long )((void *)0)) {
      if (blocknum == 0) {
        if (currnum == 0) {
          tmp___8 = sre_malloc((char *)"selex.c", 164, sizeof(SQINFO ));
          ainfo->sqinfo = (SQINFO *)tmp___8;
        } else {
          tmp___9 = sre_realloc((char *)"selex.c", 166, (void *)ainfo->sqinfo, (unsigned long )(currnum + 1) * sizeof(SQINFO ));
          ainfo->sqinfo = (SQINFO *)tmp___9;
        }
        (ainfo->sqinfo + currnum)->flags = 0;
        SetSeqinfoString(ainfo->sqinfo + currnum, nptr, 1);
      } else {
        tmp___10 = strcmp((char const   *)((ainfo->sqinfo + currnum)->name), (char const   *)nptr);
        if (tmp___10 != 0) {
          warn_names = 1;
        }
      }
      currnum ++;
      sptr___0 = strtok((char *)((void *)0), " \t\n");
      if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
        if (sptr___0 - bufcpy < (long )(blocks + blocknum)->lcol) {
          (blocks + blocknum)->lcol = (int )(sptr___0 - bufcpy);
        }
        tmp___11 = strlen((char const   *)(buffer___1));
        sptr___0 = (buffer___1 + tmp___11) - 1;
        while (1) {
          tmp___12 = strchr(" \t\n", (int )*sptr___0);
          if (! ((unsigned long )tmp___12 != (unsigned long )((void *)0))) {
            break;
          }
          sptr___0 --;
        }
        if (sptr___0 - buffer___1 > (long )(blocks + blocknum)->rcol) {
          (blocks + blocknum)->rcol = (int )(sptr___0 - buffer___1);
        }
      }
      while (1) {
        tmp___13 = fgets(buffer___1, 4096, fp);
        if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
          nptr = (char *)((void *)0);
          break;
        }
        tmp___15 = __builtin_object_size((void *)(bufcpy), 0);
        if (tmp___15 != 0xffffffffffffffffUL) {
          tmp___14 = __builtin_object_size((void *)(bufcpy), 1);
          __builtin___strcpy_chk(bufcpy, (char const   *)(buffer___1), tmp___14);
        } else {
          __inline_strcpy_chk(bufcpy, (char const   *)(buffer___1));
        }
        tmp___19 = strncmp((char const   *)(buffer___1), "#=SS", (size_t )4);
        if (tmp___19 == 0) {
          (ainfo->sqinfo + (currnum - 1))->flags |= 1 << 9;
        } else {
          tmp___18 = strncmp((char const   *)(buffer___1), "#=SA", (size_t )4);
          if (tmp___18 == 0) {
            (ainfo->sqinfo + (currnum - 1))->flags |= 1 << 10;
          } else {
            tmp___17 = strncmp((char const   *)(buffer___1), "#=CS", (size_t )4);
            if (tmp___17 == 0) {
              have_cs = 1;
            } else {
              tmp___16 = strncmp((char const   *)(buffer___1), "#=RF", (size_t )4);
              if (tmp___16 == 0) {
                have_rf = 1;
              }
            }
          }
        }
        nptr = strtok(bufcpy, " \t\n");
        if ((unsigned long )nptr == (unsigned long )((void *)0)) {
          break;
        }
        tmp___20 = strchr((char const   *)(commentsyms), (int )*nptr);
        if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
          break;
        }
      }
    }
    if (blocknum == 0) {
      num = currnum;
    } else
    if (currnum != num) {
      Die((char *)"Parse error in ReadSELEX()");
    }
    blocknum ++;
    while (1) {
      tmp___21 = fgets(buffer___1, 4096, fp);
      if ((unsigned long )tmp___21 == (unsigned long )((void *)0)) {
        nptr = (char *)((void *)0);
        break;
      }
      tmp___23 = __builtin_object_size((void *)(bufcpy), 0);
      if (tmp___23 != 0xffffffffffffffffUL) {
        tmp___22 = __builtin_object_size((void *)(bufcpy), 1);
        __builtin___strcpy_chk(bufcpy, (char const   *)(buffer___1), tmp___22);
      } else {
        __inline_strcpy_chk(bufcpy, (char const   *)(buffer___1));
      }
      nptr = strtok(bufcpy, " \t\n");
      if (! ((unsigned long )nptr == (unsigned long )((void *)0))) {
        tmp___24 = strchr((char const   *)(commentsyms), (int )*nptr);
        if (! ((unsigned long )tmp___24 != (unsigned long )((void *)0))) {
          break;
        }
      }
    }
  }
  alen = 0;
  currblock = 0;
  while (currblock < blocknum) {
    alen += ((blocks + currblock)->rcol - (blocks + currblock)->lcol) + 1;
    currblock ++;
  }
  rewind(fp);
  tmp___26 = sre_malloc((char *)"selex.c", 247, (unsigned long )num * sizeof(char *));
  aseqs = (char **)tmp___26;
  if (have_cs) {
    tmp___27 = sre_malloc((char *)"selex.c", 249, (unsigned long )(alen + 1) * sizeof(char ));
    ainfo->cs = (char *)tmp___27;
  }
  if (have_rf) {
    tmp___28 = sre_malloc((char *)"selex.c", 251, (unsigned long )(alen + 1) * sizeof(char ));
    ainfo->rf = (char *)tmp___28;
  }
  i___0 = 0;
  while (i___0 < num) {
    tmp___29 = sre_malloc((char *)"selex.c", 257, (unsigned long )(alen + 1) * sizeof(char ));
    *(aseqs + i___0) = (char *)tmp___29;
    if ((ainfo->sqinfo + i___0)->flags & (1 << 9)) {
      tmp___30 = sre_malloc((char *)"selex.c", 259, (unsigned long )(alen + 1) * sizeof(char ));
      (ainfo->sqinfo + i___0)->ss = (char *)tmp___30;
    }
    if ((ainfo->sqinfo + i___0)->flags & (1 << 10)) {
      tmp___31 = sre_malloc((char *)"selex.c", 261, (unsigned long )(alen + 1) * sizeof(char ));
      (ainfo->sqinfo + i___0)->sa = (char *)tmp___31;
    }
    i___0 ++;
  }
  ainfo->alen = alen;
  ainfo->nseq = num;
  tmp___32 = sre_malloc((char *)"selex.c", 266, sizeof(float ) * (unsigned long )num);
  ainfo->wgt = (float *)tmp___32;
  FSet(ainfo->wgt, num, (float )1.0);
  headnum = 0;
  while (1) {
    tmp___33 = fgets(buffer___1, 4096, fp);
    if ((unsigned long )tmp___33 == (unsigned long )((void *)0)) {
      Die((char *)"Parse error in ReadSELEX()");
    }
    tmp___35 = __builtin_object_size((void *)(bufcpy), 0);
    if (tmp___35 != 0xffffffffffffffffUL) {
      tmp___34 = __builtin_object_size((void *)(bufcpy), 1);
      __builtin___strcpy_chk(bufcpy, (char const   *)(buffer___1), tmp___34);
    } else {
      __inline_strcpy_chk(bufcpy, (char const   *)(buffer___1));
    }
    nptr = strtok(bufcpy, " \t\n");
    if ((unsigned long )nptr == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    tmp___55 = strcmp((char const   *)nptr, "#=AU");
    if (tmp___55 == 0) {
      sptr___0 = strtok((char *)((void *)0), "\n");
      if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
        ainfo->au = Strdup(sptr___0);
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      tmp___54 = strcmp((char const   *)nptr, "#=ID");
      if (tmp___54 == 0) {
        sptr___0 = strtok((char *)((void *)0), "\n");
        if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
          ainfo->name = Strdup(sptr___0);
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        tmp___53 = strcmp((char const   *)nptr, "#=AC");
        if (tmp___53 == 0) {
          sptr___0 = strtok((char *)((void *)0), "\n");
          if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
            ainfo->acc = Strdup(sptr___0);
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          tmp___52 = strcmp((char const   *)nptr, "#=DE");
          if (tmp___52 == 0) {
            sptr___0 = strtok((char *)((void *)0), "\n");
            if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
              ainfo->desc = Strdup(sptr___0);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            tmp___51 = strcmp((char const   *)nptr, "#=GA");
            if (tmp___51 == 0) {
              sptr___0 = strtok((char *)((void *)0), " \t\n");
              if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                Die((char *)"Parse error in #=GA line in ReadSELEX()");
              }
              tmp___36 = atof((char const   *)sptr___0);
              ainfo->ga1 = (float )tmp___36;
              sptr___0 = strtok((char *)((void *)0), " \t\n");
              if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                Die((char *)"Parse error in #=GA line in ReadSELEX()");
              }
              tmp___37 = atof((char const   *)sptr___0);
              ainfo->ga2 = (float )tmp___37;
              ainfo->flags |= 1 << 2;
            } else {
              tmp___50 = strcmp((char const   *)nptr, "#=TC");
              if (tmp___50 == 0) {
                sptr___0 = strtok((char *)((void *)0), " \t\n");
                if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                  Die((char *)"Parse error in #=TC line in ReadSELEX()");
                }
                tmp___38 = atof((char const   *)sptr___0);
                ainfo->tc1 = (float )tmp___38;
                sptr___0 = strtok((char *)((void *)0), " \t\n");
                if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                  Die((char *)"Parse error in #=TC line in ReadSELEX()");
                }
                tmp___39 = atof((char const   *)sptr___0);
                ainfo->tc2 = (float )tmp___39;
                ainfo->flags |= 1;
              } else {
                tmp___49 = strcmp((char const   *)nptr, "#=NC");
                if (tmp___49 == 0) {
                  sptr___0 = strtok((char *)((void *)0), " \t\n");
                  if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                    Die((char *)"Parse error in #=NC line in ReadSELEX()");
                  }
                  tmp___40 = atof((char const   *)sptr___0);
                  ainfo->nc1 = (float )tmp___40;
                  sptr___0 = strtok((char *)((void *)0), " \t\n");
                  if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                    Die((char *)"Parse error in #=NC line in ReadSELEX()");
                  }
                  tmp___41 = atof((char const   *)sptr___0);
                  ainfo->nc2 = (float )tmp___41;
                  ainfo->flags |= 1 << 1;
                } else {
                  tmp___48 = strcmp((char const   *)nptr, "#=SQ");
                  if (tmp___48 == 0) {
                    sptr___0 = strtok((char *)((void *)0), " \t\n");
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                      Die((char *)"Parse error in #=SQ line in ReadSELEX()");
                    }
                    tmp___42 = strcmp((char const   *)sptr___0, (char const   *)((ainfo->sqinfo + headnum)->name));
                    if (tmp___42 != 0) {
                      warn_names = 1;
                    }
                    sptr___0 = strtok((char *)((void *)0), " \t\n");
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                      Die((char *)"Parse error in #=SQ line in ReadSELEX()");
                    }
                    tmp___43 = IsReal(sptr___0);
                    if (! tmp___43) {
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): weight is not a number");
                    }
                    tmp___44 = atof((char const   *)sptr___0);
                    *(ainfo->wgt + headnum) = (float )tmp___44;
                    sptr___0 = strtok((char *)((void *)0), " \t\n");
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): incomplete line");
                    }
                    SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 1);
                    sptr___0 = strtok((char *)((void *)0), " \t\n");
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): incomplete line");
                    }
                    SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 2);
                    sptr___0 = strtok((char *)((void *)0), ".:");
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): incomplete line");
                    }
                    SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 4);
                    sptr___0 = strtok((char *)((void *)0), ".:");
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): incomplete line");
                    }
                    SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 5);
                    sptr___0 = strtok((char *)((void *)0), ":\t ");
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): incomplete line");
                    }
                    SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 8);
                    sptr___0 = strtok((char *)((void *)0), "\n");
                    if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
                      SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 3);
                    }
                    headnum ++;
                  } else {
                    tmp___47 = strcmp((char const   *)nptr, "#=CS");
                    if (tmp___47 == 0) {
                      break;
                    } else {
                      tmp___46 = strcmp((char const   *)nptr, "#=RF");
                      if (tmp___46 == 0) {
                        break;
                      } else {
                        tmp___45 = strchr((char const   *)(commentsyms), (int )*nptr);
                        if ((unsigned long )tmp___45 == (unsigned long )((void *)0)) {
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  currlen = 0;
  currblock = 0;
  while (currblock < blocknum) {
    seqidx = 0;
    while ((unsigned long )nptr != (unsigned long )((void *)0)) {
      tmp___70 = strcmp((char const   *)nptr, "#=CS");
      if (tmp___70 == 0) {
        tmp___56 = strlen((char const   *)nptr);
        tmp___57 = copy_alignment_line(ainfo->cs, currlen, (int )(tmp___56 - 1UL),
                                       buffer___1, (blocks + currblock)->lcol, (blocks + currblock)->rcol,
                                       (char )'.');
        if (! tmp___57) {
          Die((char *)"Parse error in #=CS line in ReadSELEX()");
        }
      } else {
        tmp___69 = strcmp((char const   *)nptr, "#=RF");
        if (tmp___69 == 0) {
          tmp___58 = strlen((char const   *)nptr);
          tmp___59 = copy_alignment_line(ainfo->rf, currlen, (int )(tmp___58 - 1UL),
                                         buffer___1, (blocks + currblock)->lcol, (blocks + currblock)->rcol,
                                         (char )'.');
          if (! tmp___59) {
            Die((char *)"Parse error in #=RF line in ReadSELEX()");
          }
        } else {
          tmp___68 = strcmp((char const   *)nptr, "#=SS");
          if (tmp___68 == 0) {
            tmp___60 = strlen((char const   *)nptr);
            tmp___61 = copy_alignment_line((ainfo->sqinfo + (seqidx - 1))->ss, currlen,
                                           (int )(tmp___60 - 1UL), buffer___1, (blocks + currblock)->lcol,
                                           (blocks + currblock)->rcol, (char )'.');
            if (! tmp___61) {
              Die((char *)"Parse error in #=SS line in ReadSELEX()");
            }
          } else {
            tmp___67 = strcmp((char const   *)nptr, "#=SA");
            if (tmp___67 == 0) {
              tmp___62 = strlen((char const   *)nptr);
              tmp___63 = copy_alignment_line((ainfo->sqinfo + (seqidx - 1))->sa, currlen,
                                             (int )(tmp___62 - 1UL), buffer___1, (blocks + currblock)->lcol,
                                             (blocks + currblock)->rcol, (char )'.');
              if (! tmp___63) {
                Die((char *)"Parse error in #=SA line in ReadSELEX()");
              }
            } else {
              tmp___66 = strncmp((char const   *)nptr, "#=", (size_t )2);
              if (tmp___66 != 0) {
                tmp___64 = strlen((char const   *)nptr);
                tmp___65 = copy_alignment_line(*(aseqs + seqidx), currlen, (int )(tmp___64 - 1UL),
                                               buffer___1, (blocks + currblock)->lcol,
                                               (blocks + currblock)->rcol, (char )'.');
                if (! tmp___65) {
                  Die((char *)"Parse error in alignment line in ReadSELEX()");
                }
                seqidx ++;
              }
            }
          }
        }
      }
      while (1) {
        nptr = (char *)((void *)0);
        tmp___71 = fgets(buffer___1, 4096, fp);
        if ((unsigned long )tmp___71 == (unsigned long )((void *)0)) {
          break;
        }
        tmp___73 = __builtin_object_size((void *)(bufcpy), 0);
        if (tmp___73 != 0xffffffffffffffffUL) {
          tmp___72 = __builtin_object_size((void *)(bufcpy), 1);
          __builtin___strcpy_chk(bufcpy, (char const   *)(buffer___1), tmp___72);
        } else {
          __inline_strcpy_chk(bufcpy, (char const   *)(buffer___1));
        }
        nptr = strtok(bufcpy, " \t\n");
        if ((unsigned long )nptr == (unsigned long )((void *)0)) {
          break;
        }
        tmp___74 = strncmp((char const   *)(buffer___1), "#=", (size_t )2);
        if (tmp___74 == 0) {
          break;
        }
        tmp___75 = strchr((char const   *)(commentsyms), (int )*nptr);
        if ((unsigned long )tmp___75 == (unsigned long )((void *)0)) {
          break;
        }
      }
    }
    currlen += ((blocks + currblock)->rcol - (blocks + currblock)->lcol) + 1;
    while (1) {
      tmp___76 = fgets(buffer___1, 4096, fp);
      if ((unsigned long )tmp___76 == (unsigned long )((void *)0)) {
        break;
      }
      tmp___78 = __builtin_object_size((void *)(bufcpy), 0);
      if (tmp___78 != 0xffffffffffffffffUL) {
        tmp___77 = __builtin_object_size((void *)(bufcpy), 1);
        __builtin___strcpy_chk(bufcpy, (char const   *)(buffer___1), tmp___77);
      } else {
        __inline_strcpy_chk(bufcpy, (char const   *)(buffer___1));
      }
      nptr = strtok(bufcpy, " \t\n");
      if ((unsigned long )nptr == (unsigned long )((void *)0)) {
        goto __Cont___0;
      }
      tmp___79 = strncmp((char const   *)(buffer___1), "#=", (size_t )2);
      if (tmp___79 == 0) {
        break;
      }
      tmp___80 = strchr((char const   *)(commentsyms), (int )*nptr);
      if ((unsigned long )tmp___80 == (unsigned long )((void *)0)) {
        break;
      }
      __Cont___0: /* CIL Label */ ;
    }
    currblock ++;
  }
  seqidx = 0;
  while (seqidx < num) {
    if ((ainfo->sqinfo + seqidx)->flags & (1 << 9)) {
      rpos = 0;
      apos = rpos;
      while (apos < alen) {
        if (! ((int )*(*(aseqs + seqidx) + apos) == 32)) {
          if (! ((int )*(*(aseqs + seqidx) + apos) == 46)) {
            if (! ((int )*(*(aseqs + seqidx) + apos) == 95)) {
              if (! ((int )*(*(aseqs + seqidx) + apos) == 45)) {
                if (! ((int )*(*(aseqs + seqidx) + apos) == 126)) {
                  *((ainfo->sqinfo + seqidx)->ss + rpos) = *((ainfo->sqinfo + seqidx)->ss + apos);
                  rpos ++;
                }
              }
            }
          }
        }
        apos ++;
      }
      *((ainfo->sqinfo + seqidx)->ss + rpos) = (char )'\000';
    }
    if ((ainfo->sqinfo + seqidx)->flags & (1 << 10)) {
      rpos = 0;
      apos = rpos;
      while (apos < alen) {
        if (! ((int )*(*(aseqs + seqidx) + apos) == 32)) {
          if (! ((int )*(*(aseqs + seqidx) + apos) == 46)) {
            if (! ((int )*(*(aseqs + seqidx) + apos) == 95)) {
              if (! ((int )*(*(aseqs + seqidx) + apos) == 45)) {
                if (! ((int )*(*(aseqs + seqidx) + apos) == 126)) {
                  *((ainfo->sqinfo + seqidx)->sa + rpos) = *((ainfo->sqinfo + seqidx)->sa + apos);
                  rpos ++;
                }
              }
            }
          }
        }
        apos ++;
      }
      *((ainfo->sqinfo + seqidx)->sa + rpos) = (char )'\000';
    }
    seqidx ++;
  }
  if ((unsigned long )ainfo->rf != (unsigned long )((void *)0)) {
    *(ainfo->rf + alen) = (char )'\000';
  }
  if ((unsigned long )ainfo->cs != (unsigned long )((void *)0)) {
    *(ainfo->cs + alen) = (char )'\000';
  }
  seqidx = 0;
  while (seqidx < num) {
    *(*(aseqs + seqidx) + alen) = (char )'\000';
    seqidx ++;
  }
  seqidx = 0;
  while (seqidx < num) {
    count = 0;
    sptr___0 = *(aseqs + seqidx);
    while ((int )*sptr___0 != 0) {
      if (! ((int )*sptr___0 == 32)) {
        if (! ((int )*sptr___0 == 46)) {
          if (! ((int )*sptr___0 == 95)) {
            if (! ((int )*sptr___0 == 45)) {
              if (! ((int )*sptr___0 == 126)) {
                count ++;
              }
            }
          }
        }
      }
      sptr___0 ++;
    }
    (ainfo->sqinfo + seqidx)->len = count;
    (ainfo->sqinfo + seqidx)->flags |= 1 << 6;
    seqidx ++;
  }
  free((void *)blocks);
  if (warn_names) {
    Warn((char *)"sequences may be in different orders in blocks of %s?", afp->fname);
  }
  msa = MSAFromAINFO(aseqs, ainfo);
  MSAVerifyParse(msa);
  FreeAlignment(aseqs, ainfo);
  return (msa);
}
}
void WriteSELEX(FILE *fp , MSA *msa ) 
{ 


  {
  actually_write_selex(fp, msa, 50);
  return;
}
}
void WriteSELEXOneBlock(FILE *fp , MSA *msa ) 
{ 


  {
  actually_write_selex(fp, msa, msa->alen);
  return;
}
}
static void actually_write_selex(FILE *fp , MSA *msa , int cpl ) 
{ 
  int i___0 ;
  int len ;
  int namewidth ;
  char *buf ;
  int currpos ;
  void *tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;

  {
  len = 0;
  tmp = malloc(sizeof(char ) * (unsigned long )(cpl + 101));
  buf = (char *)tmp;
  namewidth = 0;
  i___0 = 0;
  while (i___0 < msa->nseq) {
    tmp___0 = strlen((char const   *)*(msa->sqname + i___0));
    len = (int )tmp___0;
    if (len > namewidth) {
      namewidth = len;
    }
    i___0 ++;
  }
  if (namewidth < 6) {
    namewidth = 6;
  }
  i___0 = 0;
  while (i___0 < msa->ncomment) {
    fprintf(fp, "# %s\n", *(msa->comment + i___0));
    i___0 ++;
  }
  if (msa->ncomment > 0) {
    fprintf(fp, "\n");
  }
  if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
    fprintf(fp, "#=ID %s\n", msa->name);
  }
  if ((unsigned long )msa->acc != (unsigned long )((void *)0)) {
    fprintf(fp, "#=AC %s\n", msa->acc);
  }
  if ((unsigned long )msa->desc != (unsigned long )((void *)0)) {
    fprintf(fp, "#=DE %s\n", msa->desc);
  }
  if ((unsigned long )msa->au != (unsigned long )((void *)0)) {
    fprintf(fp, "#=AU %s\n", msa->au);
  }
  if (msa->cutoff_is_set[2]) {
    if (msa->cutoff_is_set[3]) {
      fprintf(fp, "#=GA %.1f %.1f\n", (double )msa->cutoff[2], (double )msa->cutoff[3]);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (msa->cutoff_is_set[2]) {
    fprintf(fp, "#=GA %.1f\n", (double )msa->cutoff[2]);
  }
  if (msa->cutoff_is_set[4]) {
    if (msa->cutoff_is_set[5]) {
      fprintf(fp, "#=NC %.1f %.1f\n", (double )msa->cutoff[4], (double )msa->cutoff[5]);
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (msa->cutoff_is_set[4]) {
    fprintf(fp, "#=NC %.1f\n", (double )msa->cutoff[4]);
  }
  if (msa->cutoff_is_set[0]) {
    if (msa->cutoff_is_set[1]) {
      fprintf(fp, "#=TC %.1f %.1f\n", (double )msa->cutoff[0], (double )msa->cutoff[1]);
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (msa->cutoff_is_set[0]) {
    fprintf(fp, "#=TC %.1f\n", (double )msa->cutoff[0]);
  }
  i___0 = 0;
  while (i___0 < msa->nseq) {
    if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
      if ((unsigned long )*(msa->sqdesc + i___0) != (unsigned long )((void *)0)) {
        tmp___1 = (char const   *)*(msa->sqdesc + i___0);
      } else {
        tmp___1 = "-";
      }
    } else {
      tmp___1 = "-";
    }
    if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
      if ((unsigned long )*(msa->sqacc + i___0) != (unsigned long )((void *)0)) {
        tmp___2 = (char const   *)*(msa->sqacc + i___0);
      } else {
        tmp___2 = "-";
      }
    } else {
      tmp___2 = "-";
    }
    fprintf(fp, "#=SQ %-*.*s %6.4f %s %s %d..%d::%d %s\n", namewidth, namewidth, *(msa->sqname + i___0),
            (double )*(msa->wgt + i___0), "-", tmp___2, 0, 0, 0, tmp___1);
    i___0 ++;
  }
  fprintf(fp, "\n");
  currpos = 0;
  while (currpos < msa->alen) {
    if (currpos > 0) {
      fprintf(fp, "\n");
    }
    if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
      tmp___4 = __builtin_object_size((void *)buf, 0);
      if (tmp___4 != 0xffffffffffffffffUL) {
        tmp___3 = __builtin_object_size((void *)buf, 1);
        __builtin___strncpy_chk(buf, (char const   *)(msa->ss_cons + currpos), (unsigned long )cpl,
                                tmp___3);
      } else {
        __inline_strncpy_chk(buf, (char const   *)(msa->ss_cons + currpos), (size_t )cpl);
      }
      *(buf + cpl) = (char )'\000';
      fprintf(fp, "%-*.*s %s\n", namewidth, namewidth, "#=CS", buf);
    }
    if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
      tmp___6 = __builtin_object_size((void *)buf, 0);
      if (tmp___6 != 0xffffffffffffffffUL) {
        tmp___5 = __builtin_object_size((void *)buf, 1);
        __builtin___strncpy_chk(buf, (char const   *)(msa->rf + currpos), (unsigned long )cpl,
                                tmp___5);
      } else {
        __inline_strncpy_chk(buf, (char const   *)(msa->rf + currpos), (size_t )cpl);
      }
      *(buf + cpl) = (char )'\000';
      fprintf(fp, "%-*.*s %s\n", namewidth, namewidth, "#=RF", buf);
    }
    i___0 = 0;
    while (i___0 < msa->nseq) {
      tmp___8 = __builtin_object_size((void *)buf, 0);
      if (tmp___8 != 0xffffffffffffffffUL) {
        tmp___7 = __builtin_object_size((void *)buf, 1);
        __builtin___strncpy_chk(buf, (char const   *)(*(msa->aseq + i___0) + currpos),
                                (unsigned long )cpl, tmp___7);
      } else {
        __inline_strncpy_chk(buf, (char const   *)(*(msa->aseq + i___0) + currpos),
                             (size_t )cpl);
      }
      *(buf + cpl) = (char )'\000';
      fprintf(fp, "%-*.*s %s\n", namewidth, namewidth, *(msa->sqname + i___0), buf);
      if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
        if ((unsigned long )*(msa->ss + i___0) != (unsigned long )((void *)0)) {
          tmp___10 = __builtin_object_size((void *)buf, 0);
          if (tmp___10 != 0xffffffffffffffffUL) {
            tmp___9 = __builtin_object_size((void *)buf, 1);
            __builtin___strncpy_chk(buf, (char const   *)(*(msa->ss + i___0) + currpos),
                                    (unsigned long )cpl, tmp___9);
          } else {
            __inline_strncpy_chk(buf, (char const   *)(*(msa->ss + i___0) + currpos),
                                 (size_t )cpl);
          }
          *(buf + cpl) = (char )'\000';
          fprintf(fp, "%-*.*s %s\n", namewidth, namewidth, "#=SS", buf);
        }
      }
      if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
        if ((unsigned long )*(msa->sa + i___0) != (unsigned long )((void *)0)) {
          tmp___12 = __builtin_object_size((void *)buf, 0);
          if (tmp___12 != 0xffffffffffffffffUL) {
            tmp___11 = __builtin_object_size((void *)buf, 1);
            __builtin___strncpy_chk(buf, (char const   *)(*(msa->sa + i___0) + currpos),
                                    (unsigned long )cpl, tmp___11);
          } else {
            __inline_strncpy_chk(buf, (char const   *)(*(msa->sa + i___0) + currpos),
                                 (size_t )cpl);
          }
          *(buf + cpl) = (char )'\000';
          fprintf(fp, "%-*.*s %s\n", namewidth, namewidth, "#=SA", buf);
        }
      }
      i___0 ++;
    }
    currpos += cpl;
  }
  free((void *)buf);
  return;
}
}
static int copy_alignment_line(char *aseq , int apos , int name_rcol , char *buffer___1 ,
                               int lcol , int rcol , char gapsym ) 
{ 
  char *s1 ;
  char *s2 ;
  int i___0 ;

  {
  s1 = aseq + apos;
  s2 = buffer___1;
  i___0 = 0;
  while (i___0 < lcol) {
    if (*s2) {
      s2 ++;
    }
    i___0 ++;
  }
  i___0 = lcol;
  while (i___0 <= rcol) {
    if ((int )*s2 == 9) {
      Warn((char *)"TAB characters will corrupt a SELEX alignment! Please remove them first.");
      return (0);
    }
    if (name_rcol >= i___0) {
      *s1 = gapsym;
    } else
    if ((int )*s2 == 0) {
      *s1 = gapsym;
    } else
    if ((int )*s2 == 10) {
      *s1 = gapsym;
    } else
    if ((int )*s2 == 32) {
      *s1 = gapsym;
    } else {
      *s1 = *s2;
    }
    s1 ++;
    if (*s2) {
      s2 ++;
    }
    i___0 ++;
  }
  return (1);
}
}
int DealignAseqs(char **aseqs , int num , char ***ret_rseqs ) 
{ 
  char **rseqs ;
  int idx ;
  int depos ;
  int apos ;
  int seqlen ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  tmp = sre_malloc((char *)"selex.c", 738, (unsigned long )num * sizeof(char *));
  rseqs = (char **)tmp;
  idx = 0;
  while (idx < num) {
    tmp___0 = strlen((char const   *)*(aseqs + idx));
    seqlen = (int )tmp___0;
    tmp___1 = sre_malloc((char *)"selex.c", 744, (unsigned long )(seqlen + 1) * sizeof(char ));
    *(rseqs + idx) = (char *)tmp___1;
    depos = 0;
    apos = 0;
    while ((int )*(*(aseqs + idx) + apos) != 0) {
      if (! ((int )*(*(aseqs + idx) + apos) == 32)) {
        if (! ((int )*(*(aseqs + idx) + apos) == 46)) {
          if (! ((int )*(*(aseqs + idx) + apos) == 95)) {
            if (! ((int )*(*(aseqs + idx) + apos) == 45)) {
              if (! ((int )*(*(aseqs + idx) + apos) == 126)) {
                *(*(rseqs + idx) + depos) = *(*(aseqs + idx) + apos);
                depos ++;
              }
            }
          }
        }
      }
      apos ++;
    }
    *(*(rseqs + idx) + depos) = (char )'\000';
    idx ++;
  }
  *ret_rseqs = rseqs;
  return (1);
}
}
int IsSELEXFormat(char *filename ) 
{ 
  FILE *fp ;
  char buffer___1[4096] ;
  char *sptr___0 ;
  int linenum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
  fp = fopen((char const   *)filename, "r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    squid_errno = 4;
    return (0);
  }
  linenum = 0;
  while (1) {
    if (linenum < 500) {
      tmp___12 = fgets(buffer___1, 4096, fp);
      if (! ((unsigned long )tmp___12 != (unsigned long )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    linenum ++;
    tmp___9 = strncmp((char const   *)(buffer___1), "#=AU", (size_t )4);
    if (tmp___9 == 0) {
      goto DONE;
    } else {
      tmp___8 = strncmp((char const   *)(buffer___1), "#=ID", (size_t )4);
      if (tmp___8 == 0) {
        goto DONE;
      } else {
        tmp___7 = strncmp((char const   *)(buffer___1), "#=AC", (size_t )4);
        if (tmp___7 == 0) {
          goto DONE;
        } else {
          tmp___6 = strncmp((char const   *)(buffer___1), "#=DE", (size_t )4);
          if (tmp___6 == 0) {
            goto DONE;
          } else {
            tmp___5 = strncmp((char const   *)(buffer___1), "#=GA", (size_t )4);
            if (tmp___5 == 0) {
              goto DONE;
            } else {
              tmp___4 = strncmp((char const   *)(buffer___1), "#=TC", (size_t )4);
              if (tmp___4 == 0) {
                goto DONE;
              } else {
                tmp___3 = strncmp((char const   *)(buffer___1), "#=NC", (size_t )4);
                if (tmp___3 == 0) {
                  goto DONE;
                } else {
                  tmp___2 = strncmp((char const   *)(buffer___1), "#=SQ", (size_t )4);
                  if (tmp___2 == 0) {
                    goto DONE;
                  } else {
                    tmp___1 = strncmp((char const   *)(buffer___1), "#=SS", (size_t )4);
                    if (tmp___1 == 0) {
                      goto DONE;
                    } else {
                      tmp___0 = strncmp((char const   *)(buffer___1), "#=CS", (size_t )4);
                      if (tmp___0 == 0) {
                        goto DONE;
                      } else {
                        tmp = strncmp((char const   *)(buffer___1), "#=RF", (size_t )4);
                        if (tmp == 0) {
                          goto DONE;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    tmp___10 = strchr((char const   *)(commentsyms), (int )buffer___1[0]);
    if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
      continue;
    }
    sptr___0 = strtok(buffer___1, " \t\n");
    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
      continue;
    }
    sptr___0 = strtok((char *)((void *)0), "\n");
    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
      continue;
    }
    tmp___11 = Seqtype(sptr___0);
    if (tmp___11 == 0) {
      fclose(fp);
      return (0);
    }
  }
  DONE: 
  fclose(fp);
  return (1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-gXu2SLM9.i","-O3")
int seqcmp(char *s1 , char *s2 , int allow ) ;
int seqncmp(char *s1 , char *s2 , int n , int allow ) ;
int coded_revcomp(char *comp , char *seq ) ;
int seqdecode(char *str , char *codeseq ) ;
int seqndecode(char *str , char *codeseq , int n ) ;
int seqcmp(char *s1 , char *s2 , int allow ) 
{ 
  int mmat ;
  char *tmp ;

  {
  mmat = 0;
  while (1) {
    if ((int )*s1 != 0) {
      if ((int )*s2 != 0) {
        if (! (mmat <= allow)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if (! (((int )*s1 & (int )*s2) == (int )*s2)) {
      mmat ++;
    }
    s1 ++;
    s2 ++;
  }
  while (1) {
    tmp = s1;
    s1 ++;
    if ((int )*tmp != 0) {
      if (! (mmat <= allow)) {
        break;
      }
    } else {
      break;
    }
    mmat ++;
  }
  return (mmat);
}
}
int seqncmp(char *s1 , char *s2 , int n , int allow ) 
{ 
  int mmat ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  mmat = 0;
  while (1) {
    if ((int )*s2 != 0) {
      tmp = n;
      n --;
      if (! (tmp != 0)) {
        break;
      }
    } else {
      break;
    }
    if (! (((int )*s1 & (int )*s2) == (int )*s2)) {
      mmat ++;
      if (mmat > allow) {
        return (mmat);
      }
    }
    s1 ++;
    s2 ++;
  }
  while (1) {
    tmp___0 = n;
    n --;
    if (tmp___0 != 0) {
      tmp___1 = s1;
      s1 ++;
      if ((int )*tmp___1 != 0) {
        if (! (mmat <= allow)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    mmat ++;
  }
  return (mmat);
}
}
int seqencode(char *codeseq , char *str ) 
{ 
  char *ptr ;
  int idx ;
  int tmp ;
  int tmp___0 ;

  {
  ptr = codeseq;
  while ((int )*str != 0) {
    tmp___0 = islower((int )*str);
    if (tmp___0) {
      tmp = toupper((int )*str);
      *str = (char )tmp;
    }
    idx = 0;
    while (1) {
      if ((int )*str != (int )iupac[idx].sym) {
        if (! (idx <= 17)) {
          break;
        }
      } else {
        break;
      }
      idx ++;
    }
    if (idx > 17) {
      *ptr = (char)0;
      return (0);
    } else {
      *ptr = iupac[idx].code;
    }
    ptr ++;
    str ++;
  }
  *ptr = (char)0;
  return (1);
}
}
int coded_revcomp(char *comp , char *seq ) 
{ 
  long bases ;
  char *bckp ;
  char *fwdp ;
  int idx ;
  long pos ;
  size_t tmp ;

  {
  tmp = strlen((char const   *)seq);
  bases = (long )tmp;
  fwdp = comp;
  bckp = (seq + bases) - 1;
  pos = 0L;
  while (pos < bases) {
    idx = 0;
    while (1) {
      if ((int )*bckp != (int )iupac[idx].code) {
        if (! (idx < 17)) {
          break;
        }
      } else {
        break;
      }
      idx ++;
    }
    if (idx > 17) {
      *fwdp = (char)0;
      return (0);
    } else {
      *fwdp = iupac[idx].comp;
    }
    fwdp ++;
    bckp --;
    pos ++;
  }
  *fwdp = (char)0;
  return (1);
}
}
int seqdecode(char *str , char *codeseq ) 
{ 
  int idx ;
  int pos ;

  {
  pos = 0;
  while ((int )*codeseq != 0) {
    idx = 0;
    while (1) {
      if ((int )*codeseq != (int )iupac[idx].code) {
        if (! (idx < 17)) {
          break;
        }
      } else {
        break;
      }
      idx ++;
    }
    if (idx > 17) {
      *(str + pos) = (char )'X';
      return (0);
    } else {
      *(str + pos) = iupac[idx].sym;
    }
    codeseq ++;
    pos ++;
  }
  *(str + pos) = (char )'\000';
  return (1);
}
}
int seqndecode(char *str , char *codeseq , int n ) 
{ 
  int idx ;
  int pos ;

  {
  pos = 0;
  while (1) {
    n --;
    if (! (n >= 0)) {
      break;
    }
    idx = 0;
    while (1) {
      if ((int )*codeseq != (int )iupac[idx].code) {
        if (! (idx < 17)) {
          break;
        }
      } else {
        break;
      }
      idx ++;
    }
    if (idx > 17) {
      *(str + pos) = (char )'X';
      return (0);
    } else {
      *(str + pos) = iupac[idx].sym;
    }
    codeseq ++;
    pos ++;
  }
  *(str + pos) = (char )'\000';
  return (1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-PLzqES_m.i","-O3")
int StrShuffle(char *s1 , char *s2 ) ;
int StrDPShuffle(char *s1 , char *s2 ) ;
int StrMarkov0(char *s1 , char *s2 ) ;
int StrMarkov1(char *s1 , char *s2 ) ;
int StrRegionalShuffle(char *s1 , char *s2 , int w___0 ) ;
int AlignmentShuffle(char **ali1 , char **ali2 , int nseq , int alen ) ;
int AlignmentBootstrap(char **ali1 , char **ali2 , int nseq , int alen ) ;
int QRNAShuffle(char *xs , char *ys , char *x , char *y___0 ) ;
int StrShuffle(char *s1 , char *s2 ) 
{ 
  int len ;
  int pos ;
  char c ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  double tmp___2 ;

  {
  if ((unsigned long )s1 != (unsigned long )s2) {
    tmp___0 = __builtin_object_size((void *)s1, 0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)s1, 1);
      __builtin___strcpy_chk(s1, (char const   *)s2, tmp);
    } else {
      __inline_strcpy_chk(s1, (char const   *)s2);
    }
  }
  tmp___1 = strlen((char const   *)s1);
  len = (int )tmp___1;
  while (len > 1) {
    tmp___2 = sre_random();
    pos = (int )(tmp___2 * (double )len);
    c = *(s1 + pos);
    *(s1 + pos) = *(s1 + (len - 1));
    *(s1 + (len - 1)) = c;
    len --;
  }
  return (1);
}
}
int StrDPShuffle(char *s1 , char *s2 ) 
{ 
  int len ;
  int pos ;
  int x ;
  int y___0 ;
  char **E ;
  int *nE ;
  int *iE ;
  int n ;
  char sf ;
  char Z[26] ;
  int keep_connecting ;
  int is_eulerian ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  tmp = strlen((char const   *)s2);
  len = (int )tmp;
  pos = 0;
  while (pos < len) {
    tmp___0 = isalpha((int )*(s2 + pos));
    if (! tmp___0) {
      return (0);
    }
    pos ++;
  }
  tmp___1 = sre_malloc((char *)"shuffle.c", 127, sizeof(char *) * 26UL);
  E = (char **)tmp___1;
  tmp___2 = sre_malloc((char *)"shuffle.c", 128, sizeof(int ) * 26UL);
  nE = (int *)tmp___2;
  x = 0;
  while (x < 26) {
    tmp___3 = sre_malloc((char *)"shuffle.c", 131, sizeof(char ) * (unsigned long )(len - 1));
    *(E + x) = (char *)tmp___3;
    *(nE + x) = 0;
    x ++;
  }
  tmp___4 = toupper((int )*(s2 + 0));
  x = tmp___4 - 65;
  pos = 1;
  while (pos < len) {
    tmp___5 = toupper((int )*(s2 + pos));
    y___0 = tmp___5 - 65;
    *(*(E + x) + *(nE + x)) = (char )y___0;
    (*(nE + x)) ++;
    x = y___0;
    pos ++;
  }
  tmp___6 = toupper((int )*(s2 + (len - 1)));
  sf = (char )(tmp___6 - 65);
  is_eulerian = 0;
  while (! is_eulerian) {
    x = 0;
    while (x < 26) {
      if (*(nE + x) == 0) {
        goto __Cont;
      } else
      if (x == (int )sf) {
        goto __Cont;
      }
      tmp___7 = sre_random();
      pos = (int )(tmp___7 * (double )*(nE + x));
      y___0 = (int )*(*(E + x) + pos);
      *(*(E + x) + pos) = *(*(E + x) + (*(nE + x) - 1));
      *(*(E + x) + (*(nE + x) - 1)) = (char )y___0;
      __Cont: /* CIL Label */ 
      x ++;
    }
    x = 0;
    while (x < 26) {
      Z[x] = (char)0;
      x ++;
    }
    keep_connecting = 1;
    Z[(int )sf] = (char )keep_connecting;
    while (keep_connecting) {
      keep_connecting = 0;
      x = 0;
      while (x < 26) {
        y___0 = (int )*(*(E + x) + (*(nE + x) - 1));
        if ((int )Z[x] == 0) {
          if ((int )Z[y___0] == 1) {
            Z[x] = (char)1;
            keep_connecting = 1;
          }
        }
        x ++;
      }
    }
    is_eulerian = 1;
    x = 0;
    while (x < 26) {
      if (*(nE + x) == 0) {
        goto __Cont___0;
      } else
      if (x == (int )sf) {
        goto __Cont___0;
      }
      if ((int )Z[x] == 0) {
        is_eulerian = 0;
        break;
      }
      __Cont___0: /* CIL Label */ 
      x ++;
    }
  }
  x = 0;
  while (x < 26) {
    n = *(nE + x) - 1;
    while (n > 1) {
      tmp___8 = sre_random();
      pos = (int )(tmp___8 * (double )n);
      y___0 = (int )*(*(E + x) + pos);
      *(*(E + x) + pos) = *(*(E + x) + (n - 1));
      *(*(E + x) + (n - 1)) = (char )y___0;
      n --;
    }
    x ++;
  }
  tmp___9 = sre_malloc((char *)"shuffle.c", 240, sizeof(int ) * 26UL);
  iE = (int *)tmp___9;
  x = 0;
  while (x < 26) {
    *(iE + x) = 0;
    x ++;
  }
  pos = 0;
  tmp___10 = toupper((int )*(s2 + 0));
  x = tmp___10 - 65;
  while (1) {
    tmp___11 = pos;
    pos ++;
    *(s1 + tmp___11) = (char )(65 + x);
    y___0 = (int )*(*(E + x) + *(iE + x));
    (*(iE + x)) ++;
    x = y___0;
    if (*(iE + x) == *(nE + x)) {
      break;
    }
  }
  tmp___12 = pos;
  pos ++;
  *(s1 + tmp___12) = (char )(65 + (int )sf);
  *(s1 + pos) = (char )'\000';
  if (x != (int )sf) {
    Die((char *)"hey, you didn\'t end on s_f.");
  }
  if (pos != len) {
    Die((char *)"hey, pos (%d) != len (%d).", pos, len);
  }
  Free2DArray((void **)E, 26);
  free((void *)nE);
  free((void *)iE);
  return (1);
}
}
int StrMarkov0(char *s1 , char *s2 ) 
{ 
  int len ;
  int pos ;
  float p[26] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = strlen((char const   *)s2);
  len = (int )tmp;
  pos = 0;
  while (pos < len) {
    tmp___0 = isalpha((int )*(s2 + pos));
    if (! tmp___0) {
      return (0);
    }
    pos ++;
  }
  FSet(p, 26, (float )0.);
  pos = 0;
  while (pos < len) {
    tmp___1 = toupper((int )*(s2 + pos));
    p[tmp___1 - 65] = (float )((double )p[tmp___1 - 65] + 1.0);
    pos ++;
  }
  FNorm(p, 26);
  pos = 0;
  while (pos < len) {
    tmp___2 = FChoose(p, 26);
    *(s1 + pos) = (char )(tmp___2 + 65);
    pos ++;
  }
  *(s1 + pos) = (char )'\000';
  return (1);
}
}
int StrMarkov1(char *s1 , char *s2 ) 
{ 
  int len ;
  int pos ;
  int x ;
  int y___0 ;
  int i___0 ;
  float p[26][26] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = strlen((char const   *)s2);
  len = (int )tmp;
  pos = 0;
  while (pos < len) {
    tmp___0 = isalpha((int )*(s2 + pos));
    if (! tmp___0) {
      return (0);
    }
    pos ++;
  }
  x = 0;
  while (x < 26) {
    FSet(p[x], 26, (float )0.);
    x ++;
  }
  tmp___1 = toupper((int )*(s2 + 0));
  x = tmp___1 - 65;
  i___0 = x;
  pos = 1;
  while (pos < len) {
    tmp___2 = toupper((int )*(s2 + pos));
    y___0 = tmp___2 - 65;
    p[x][y___0] = (float )((double )p[x][y___0] + 1.0);
    x = y___0;
    pos ++;
  }
  x = 0;
  while (x < 26) {
    FNorm(p[x], 26);
    x ++;
  }
  x = i___0;
  *(s1 + 0) = (char )(x + 65);
  pos = 1;
  while (pos < len) {
    y___0 = FChoose(p[x], 26);
    *(s1 + pos) = (char )(y___0 + 65);
    x = y___0;
    pos ++;
  }
  *(s1 + pos) = (char )'\000';
  return (1);
}
}
int StrReverse(char *s1 , char *s2 ) 
{ 
  int len ;
  int pos ;
  char c ;
  size_t tmp ;

  {
  tmp = strlen((char const   *)s2);
  len = (int )tmp;
  pos = 0;
  while (pos < len / 2) {
    c = *(s2 + ((len - pos) - 1));
    *(s1 + ((len - pos) - 1)) = *(s2 + pos);
    *(s1 + pos) = c;
    pos ++;
  }
  if (len % 2) {
    *(s1 + pos) = *(s2 + pos);
  }
  *(s1 + len) = (char )'\000';
  return (1);
}
}
int StrRegionalShuffle(char *s1 , char *s2 , int w___0 ) 
{ 
  int len ;
  char c ;
  int pos ;
  int i___0 ;
  int j ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  double tmp___2 ;

  {
  if ((unsigned long )s1 != (unsigned long )s2) {
    tmp___0 = __builtin_object_size((void *)s1, 0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)s1, 1);
      __builtin___strcpy_chk(s1, (char const   *)s2, tmp);
    } else {
      __inline_strcpy_chk(s1, (char const   *)s2);
    }
  }
  tmp___1 = strlen((char const   *)s1);
  len = (int )tmp___1;
  i___0 = 0;
  while (i___0 < len) {
    if (len - 1 < (i___0 + w___0) - 1) {
      j = len - 1;
    } else {
      j = (i___0 + w___0) - 1;
    }
    while (j > i___0) {
      tmp___2 = sre_random();
      pos = i___0 + (int )(tmp___2 * (double )(j - i___0));
      c = *(s1 + pos);
      *(s1 + pos) = *(s1 + j);
      *(s1 + j) = c;
      j --;
    }
    i___0 += w___0;
  }
  return (1);
}
}
int AlignmentShuffle(char **ali1 , char **ali2 , int nseq , int alen ) 
{ 
  int i___0 ;
  int pos ;
  char c ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  double tmp___1 ;

  {
  if ((unsigned long )ali1 != (unsigned long )ali2) {
    i___0 = 0;
    while (i___0 < nseq) {
      tmp___0 = __builtin_object_size((void *)*(ali1 + i___0), 0);
      if (tmp___0 != 0xffffffffffffffffUL) {
        tmp = __builtin_object_size((void *)*(ali1 + i___0), 1);
        __builtin___strcpy_chk(*(ali1 + i___0), (char const   *)*(ali2 + i___0), tmp);
      } else {
        __inline_strcpy_chk(*(ali1 + i___0), (char const   *)*(ali2 + i___0));
      }
      i___0 ++;
    }
  }
  i___0 = 0;
  while (i___0 < nseq) {
    *(*(ali1 + i___0) + alen) = (char )'\000';
    i___0 ++;
  }
  while (alen > 1) {
    tmp___1 = sre_random();
    pos = (int )(tmp___1 * (double )alen);
    i___0 = 0;
    while (i___0 < nseq) {
      c = *(*(ali1 + i___0) + pos);
      *(*(ali1 + i___0) + pos) = *(*(ali1 + i___0) + (alen - 1));
      *(*(ali1 + i___0) + (alen - 1)) = c;
      i___0 ++;
    }
    alen --;
  }
  return (1);
}
}
int AlignmentBootstrap(char **ali1 , char **ali2 , int nseq , int alen ) 
{ 
  int pos ;
  int col ;
  int i___0 ;
  double tmp ;

  {
  pos = 0;
  while (pos < alen) {
    tmp = sre_random();
    col = (int )(tmp * (double )alen);
    i___0 = 0;
    while (i___0 < nseq) {
      *(*(ali1 + i___0) + pos) = *(*(ali2 + i___0) + col);
      i___0 ++;
    }
    pos ++;
  }
  i___0 = 0;
  while (i___0 < nseq) {
    *(*(ali1 + i___0) + alen) = (char )'\000';
    i___0 ++;
  }
  return (1);
}
}
int QRNAShuffle(char *xs , char *ys , char *x , char *y___0 ) 
{ 
  int L ;
  int *xycol ;
  int *xcol ;
  int *ycol ;
  int nxy ;
  int nx ;
  int ny ;
  int i___0 ;
  int pos ;
  int c ;
  char xsym ;
  char ysym ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;

  {
  if ((unsigned long )xs != (unsigned long )x) {
    tmp___0 = __builtin_object_size((void *)xs, 0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)xs, 1);
      __builtin___strcpy_chk(xs, (char const   *)x, tmp);
    } else {
      __inline_strcpy_chk(xs, (char const   *)x);
    }
  }
  if ((unsigned long )ys != (unsigned long )y___0) {
    tmp___2 = __builtin_object_size((void *)ys, 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)ys, 1);
      __builtin___strcpy_chk(ys, (char const   *)y___0, tmp___1);
    } else {
      __inline_strcpy_chk(ys, (char const   *)y___0);
    }
  }
  tmp___3 = strlen((char const   *)x);
  L = (int )tmp___3;
  tmp___4 = sre_malloc((char *)"shuffle.c", 572, sizeof(int ) * (unsigned long )L);
  xycol = (int *)tmp___4;
  tmp___5 = sre_malloc((char *)"shuffle.c", 573, sizeof(int ) * (unsigned long )L);
  xcol = (int *)tmp___5;
  tmp___6 = sre_malloc((char *)"shuffle.c", 574, sizeof(int ) * (unsigned long )L);
  ycol = (int *)tmp___6;
  ny = 0;
  nx = ny;
  nxy = nx;
  i___0 = 0;
  while (i___0 < L) {
    if ((int )*(x + i___0) == 32) {
      goto _L___2;
    } else
    if ((int )*(x + i___0) == 46) {
      goto _L___2;
    } else
    if ((int )*(x + i___0) == 95) {
      goto _L___2;
    } else
    if ((int )*(x + i___0) == 45) {
      goto _L___2;
    } else
    if ((int )*(x + i___0) == 126) {
      _L___2: /* CIL Label */ 
      if ((int )*(y___0 + i___0) == 32) {
        goto __Cont;
      } else
      if ((int )*(y___0 + i___0) == 46) {
        goto __Cont;
      } else
      if ((int )*(y___0 + i___0) == 95) {
        goto __Cont;
      } else
      if ((int )*(y___0 + i___0) == 45) {
        goto __Cont;
      } else
      if ((int )*(y___0 + i___0) == 126) {
        goto __Cont;
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if ((int )*(x + i___0) == 32) {
      goto _L___0;
    } else
    if ((int )*(x + i___0) == 46) {
      goto _L___0;
    } else
    if ((int )*(x + i___0) == 95) {
      goto _L___0;
    } else
    if ((int )*(x + i___0) == 45) {
      goto _L___0;
    } else
    if ((int )*(x + i___0) == 126) {
      _L___0: /* CIL Label */ 
      if ((int )*(x + i___0) == 32) {
        *(ycol + ny) = i___0;
        ny ++;
      } else
      if ((int )*(x + i___0) == 46) {
        *(ycol + ny) = i___0;
        ny ++;
      } else
      if ((int )*(x + i___0) == 95) {
        *(ycol + ny) = i___0;
        ny ++;
      } else
      if ((int )*(x + i___0) == 45) {
        *(ycol + ny) = i___0;
        ny ++;
      } else
      if ((int )*(x + i___0) == 126) {
        *(ycol + ny) = i___0;
        ny ++;
      } else
      if ((int )*(y___0 + i___0) == 32) {
        *(xcol + nx) = i___0;
        nx ++;
      } else
      if ((int )*(y___0 + i___0) == 46) {
        *(xcol + nx) = i___0;
        nx ++;
      } else
      if ((int )*(y___0 + i___0) == 95) {
        *(xcol + nx) = i___0;
        nx ++;
      } else
      if ((int )*(y___0 + i___0) == 45) {
        *(xcol + nx) = i___0;
        nx ++;
      } else
      if ((int )*(y___0 + i___0) == 126) {
        *(xcol + nx) = i___0;
        nx ++;
      }
    } else
    if ((int )*(y___0 + i___0) == 32) {
      goto _L___0;
    } else
    if ((int )*(y___0 + i___0) == 46) {
      goto _L___0;
    } else
    if ((int )*(y___0 + i___0) == 95) {
      goto _L___0;
    } else
    if ((int )*(y___0 + i___0) == 45) {
      goto _L___0;
    } else
    if ((int )*(y___0 + i___0) == 126) {
      goto _L___0;
    } else {
      *(xycol + nxy) = i___0;
      nxy ++;
    }
    __Cont: /* CIL Label */ 
    i___0 ++;
  }
  while (nxy > 1) {
    tmp___7 = sre_random();
    pos = (int )(tmp___7 * (double )nxy);
    xsym = *(xs + *(xycol + pos));
    ysym = *(ys + *(xycol + pos));
    c = *(xycol + pos);
    *(xs + *(xycol + pos)) = *(xs + *(xycol + (nxy - 1)));
    *(ys + *(xycol + pos)) = *(ys + *(xycol + (nxy - 1)));
    *(xycol + pos) = *(xycol + (nxy - 1));
    *(xs + *(xycol + (nxy - 1))) = xsym;
    *(ys + *(xycol + (nxy - 1))) = ysym;
    *(xycol + pos) = *(xycol + (nxy - 1));
    nxy --;
  }
  while (nx > 1) {
    tmp___8 = sre_random();
    pos = (int )(tmp___8 * (double )nx);
    xsym = *(xs + *(xcol + pos));
    ysym = *(ys + *(xcol + pos));
    c = *(xcol + pos);
    *(xs + *(xcol + pos)) = *(xs + *(xcol + (nx - 1)));
    *(ys + *(xcol + pos)) = *(ys + *(xcol + (nx - 1)));
    *(xcol + pos) = *(xcol + (nx - 1));
    *(xs + *(xcol + (nx - 1))) = xsym;
    *(ys + *(xcol + (nx - 1))) = ysym;
    *(xcol + (nx - 1)) = c;
    nx --;
  }
  while (ny > 1) {
    tmp___9 = sre_random();
    pos = (int )(tmp___9 * (double )ny);
    xsym = *(xs + *(ycol + pos));
    ysym = *(ys + *(ycol + pos));
    c = *(ycol + pos);
    *(xs + *(ycol + pos)) = *(xs + *(ycol + (ny - 1)));
    *(ys + *(ycol + pos)) = *(ys + *(ycol + (ny - 1)));
    *(ycol + pos) = *(ycol + (ny - 1));
    *(xs + *(ycol + (ny - 1))) = xsym;
    *(ys + *(ycol + (ny - 1))) = ysym;
    *(ycol + (ny - 1)) = c;
    ny --;
  }
  free((void *)xycol);
  free((void *)xcol);
  free((void *)ycol);
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-1o1b5kpN.i","-O3")
extern void perror(char const   * ) ;
extern int ( /* format attribute */  vfprintf)(FILE * , char const   * , va_list  ) ;
int squid_errno  ;
void Die(char *format  , ...) 
{ 
  va_list argp ;

  {
  fprintf(__stderrp, "\nFATAL: ");
  __builtin_va_start(argp, format);
  vfprintf(__stderrp, (char const   *)format, argp);
  __builtin_va_end(argp);
  fprintf(__stderrp, "\n");
  fflush(__stderrp);
  exit(1);
}
}
void Warn(char *format  , ...) 
{ 
  va_list argp ;

  {
  fprintf(__stderrp, "WARNING: ");
  __builtin_va_start(argp, format);
  vfprintf(__stderrp, (char const   *)format, argp);
  __builtin_va_end(argp);
  fprintf(__stderrp, "\n");
  fflush(__stderrp);
  return;
}
}
void Panic(char *file , int line ) 
{ 


  {
  fprintf(__stderrp, "\nPANIC [%s line %d] ", file, line);
  perror("Unusual error");
  exit(1);
}
}
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-k4pjzsUu.i","-O3")
extern void *realloc(void * , size_t  ) ;
__inline static char *__inline_strncat_chk(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strncat_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
void ToDNA(char *seq ) ;
void ToRNA(char *seq ) ;
void ToIUPAC(char *seq , int is_aseq ) ;
int ReadMultipleRseqs(char *seqfile , int fformat , char ***ret_rseqs , SQINFO **ret_sqinfo ,
                      int *ret_num ) ;
SQFILE *SeqfileOpenForIndexing(char *filename , int format , char *env , int ssimode ) ;
void SeqfilePosition(SQFILE *sqfp , SSIOFFSET *offset ) ;
void SeqfileRewind(SQFILE *sqfp ) ;
int GCGBinaryToSequence(char *seq , int len ) ;
void WriteSimpleFASTA(FILE *fp , char *seq , char *name , char *desc ) ;
int WriteSeq(FILE *outf , int outform , char *seq , SQINFO *sqinfo ) ;
SQINFO *MSAToSqinfo(MSA *msa ) ;
void s2lower(char *s___0 ) ;
static void SeqfileGetLine(SQFILE *V ) ;
static char *aminos  =    (char *)"ABCDEFGHIKLMNPQRSTVWXYZ*";
static char *primenuc  =    (char *)"ACGTUN";
static char *protonly  =    (char *)"EFIPQZ";
static SQFILE *seqfile_open(char *filename , int format , char *env , int ssimode ) ;
SQFILE *SeqfileOpen(char *filename , int format , char *env ) 
{ 
  SQFILE *tmp ;

  {
  tmp = seqfile_open(filename, format, env, -1);
  return (tmp);
}
}
SQFILE *SeqfileOpenForIndexing(char *filename , int format , char *env , int ssimode ) 
{ 
  SQFILE *tmp ;

  {
  tmp = seqfile_open(filename, format, env, ssimode);
  return (tmp);
}
}
static SQFILE *seqfile_open(char *filename , int format , char *env , int ssimode ) 
{ 
  SQFILE *dbfp ;
  void *tmp ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  MSA *tmp___4 ;

  {
  tmp = sre_malloc((char *)"sqio.c", 101, sizeof(SQFILE ));
  dbfp = (SQFILE *)tmp;
  dbfp->ssimode = ssimode;
  dbfp->rpl = -1;
  dbfp->lastrpl = 0;
  dbfp->maxrpl = 0;
  dbfp->bpl = -1;
  dbfp->lastbpl = 0;
  dbfp->maxbpl = 0;
  tmp___2 = strcmp((char const   *)filename, "-");
  if (tmp___2 == 0) {
    dbfp->f = __stdinp;
    dbfp->do_stdin = 1;
    dbfp->do_gzip = 0;
    dbfp->fname = sre_strdup((char *)"[STDIN]", -1);
  } else {
    tmp___0 = fopen((char const   *)filename, "r");
    dbfp->f = tmp___0;
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      tmp___1 = EnvFileOpen(filename, env, (char **)((void *)0));
      dbfp->f = tmp___1;
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        return ((SQFILE *)((void *)0));
      }
    }
    dbfp->do_stdin = 0;
    dbfp->do_gzip = 0;
    dbfp->fname = sre_strdup(filename, -1);
  }
  if (format == 0) {
    if (dbfp->do_stdin == 1) {
      Die((char *)"Can\'t autodetect sequence file format from a stdin or gzip pipe");
    } else
    if (dbfp->do_gzip) {
      Die((char *)"Can\'t autodetect sequence file format from a stdin or gzip pipe");
    }
    format = SeqfileFormat(dbfp->f);
    if (format == 0) {
      Die((char *)"Can\'t determine format of sequence file %s", dbfp->fname);
    }
  }
  dbfp->msa = (MSA *)((void *)0);
  dbfp->afp = (MSAFILE *)((void *)0);
  dbfp->format = format;
  dbfp->linenumber = 0;
  dbfp->buf = (char *)((void *)0);
  dbfp->buflen = 0;
  if (format > 100) {
    tmp___3 = sre_malloc((char *)"sqio.c", 190, sizeof(MSAFILE ));
    dbfp->afp = (MSAFILE *)tmp___3;
    (dbfp->afp)->f = dbfp->f;
    (dbfp->afp)->do_stdin = dbfp->do_stdin;
    (dbfp->afp)->do_gzip = dbfp->do_gzip;
    (dbfp->afp)->fname = dbfp->fname;
    (dbfp->afp)->format = dbfp->format;
    (dbfp->afp)->linenumber = dbfp->linenumber;
    (dbfp->afp)->buf = (char *)((void *)0);
    (dbfp->afp)->buflen = 0;
    tmp___4 = MSAFileRead(dbfp->afp);
    dbfp->msa = tmp___4;
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
      Die((char *)"Failed to read any alignment data from file %s", dbfp->fname);
    }
    (dbfp->msa)->lastidx = 0;
    return (dbfp);
  }
  SeqfileGetLine(dbfp);
  return (dbfp);
}
}
void SeqfilePosition(SQFILE *sqfp , SSIOFFSET *offset ) 
{ 
  int tmp ;

  {
  if (sqfp->do_stdin) {
    Die((char *)"SeqfilePosition() failed: in a nonrewindable data file or stream");
  } else
  if (sqfp->do_gzip) {
    Die((char *)"SeqfilePosition() failed: in a nonrewindable data file or stream");
  } else
  if (sqfp->format > 100) {
    Die((char *)"SeqfilePosition() failed: in a nonrewindable data file or stream");
  }
  tmp = SSISetFilePosition(sqfp->f, offset);
  if (tmp != 0) {
    Die((char *)"SSISetFilePosition failed, but that shouldn\'t happen.");
  }
  SeqfileGetLine(sqfp);
  return;
}
}
void SeqfileRewind(SQFILE *sqfp ) 
{ 


  {
  if (sqfp->do_stdin) {
    Die((char *)"SeqfileRewind() failed: in a nonrewindable data file or stream");
  } else
  if (sqfp->do_gzip) {
    Die((char *)"SeqfileRewind() failed: in a nonrewindable data file or stream");
  }
  rewind(sqfp->f);
  SeqfileGetLine(sqfp);
  return;
}
}
void SeqfileLineParameters(SQFILE *V , int *ret_bpl , int *ret_rpl ) 
{ 


  {
  if (V->rpl > 0) {
    if (V->maxrpl == V->rpl) {
      if (V->bpl > 0) {
        if (V->maxbpl == V->bpl) {
          *ret_bpl = V->bpl;
          *ret_rpl = V->rpl;
        } else {
          *ret_bpl = 0;
          *ret_rpl = 0;
        }
      } else {
        *ret_bpl = 0;
        *ret_rpl = 0;
      }
    } else {
      *ret_bpl = 0;
      *ret_rpl = 0;
    }
  } else {
    *ret_bpl = 0;
    *ret_rpl = 0;
  }
  return;
}
}
void SeqfileClose(SQFILE *sqfp ) 
{ 


  {
  if ((unsigned long )sqfp->afp != (unsigned long )((void *)0)) {
    if ((unsigned long )sqfp->msa != (unsigned long )((void *)0)) {
      MSAFree(sqfp->msa);
    }
    if ((unsigned long )(sqfp->afp)->buf != (unsigned long )((void *)0)) {
      free((void *)(sqfp->afp)->buf);
    }
    free((void *)sqfp->afp);
  } else
  if (! sqfp->do_stdin) {
    fclose(sqfp->f);
  }
  if ((unsigned long )sqfp->buf != (unsigned long )((void *)0)) {
    free((void *)sqfp->buf);
  }
  if ((unsigned long )sqfp->fname != (unsigned long )((void *)0)) {
    free((void *)sqfp->fname);
  }
  free((void *)sqfp);
  return;
}
}
static void SeqfileGetLine(SQFILE *V ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
  if (V->ssimode >= 0) {
    tmp = SSIGetFilePosition(V->f, V->ssimode, & V->ssioffset);
    if (0 != tmp) {
      Die((char *)"SSIGetFilePosition() failed");
    }
  }
  tmp___0 = sre_fgets(& V->buf, & V->buflen, V->f);
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    *(V->buf) = (char )'\000';
  }
  (V->linenumber) ++;
  return;
}
}
void FreeSequence(char *seq , SQINFO *sqinfo ) 
{ 


  {
  if ((unsigned long )seq != (unsigned long )((void *)0)) {
    free((void *)seq);
  }
  if (sqinfo->flags & (1 << 9)) {
    free((void *)sqinfo->ss);
  }
  if (sqinfo->flags & (1 << 10)) {
    free((void *)sqinfo->sa);
  }
  return;
}
}
int SetSeqinfoString(SQINFO *sqinfo , char *sptr___0 , int flag ) 
{ 
  int len ;
  int pos ;
  size_t tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  size_t tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
    return (1);
  }
  while ((int )*sptr___0 == 32) {
    sptr___0 ++;
  }
  tmp = strlen((char const   *)sptr___0);
  pos = (int )(tmp - 1UL);
  while (pos >= 0) {
    tmp___0 = isspace((int )*(sptr___0 + pos));
    if (! tmp___0) {
      break;
    }
    pos --;
  }
  *(sptr___0 + (pos + 1)) = (char )'\000';
  switch (flag) {
  case 1: 
  if ((int )*sptr___0 != 45) {
    tmp___2 = __builtin_object_size((void *)(sqinfo->name), 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)(sqinfo->name), 1);
      __builtin___strncpy_chk(sqinfo->name, (char const   *)sptr___0, 63UL, tmp___1);
    } else {
      __inline_strncpy_chk(sqinfo->name, (char const   *)sptr___0, (size_t )63);
    }
    sqinfo->name[63] = (char )'\000';
    sqinfo->flags |= 1;
  }
  break;
  case 1 << 1: 
  if ((int )*sptr___0 != 45) {
    tmp___4 = __builtin_object_size((void *)(sqinfo->id), 0);
    if (tmp___4 != 0xffffffffffffffffUL) {
      tmp___3 = __builtin_object_size((void *)(sqinfo->id), 1);
      __builtin___strncpy_chk(sqinfo->id, (char const   *)sptr___0, 63UL, tmp___3);
    } else {
      __inline_strncpy_chk(sqinfo->id, (char const   *)sptr___0, (size_t )63);
    }
    sqinfo->id[63] = (char )'\000';
    sqinfo->flags |= 1 << 1;
  }
  break;
  case 1 << 2: 
  if ((int )*sptr___0 != 45) {
    tmp___6 = __builtin_object_size((void *)(sqinfo->acc), 0);
    if (tmp___6 != 0xffffffffffffffffUL) {
      tmp___5 = __builtin_object_size((void *)(sqinfo->acc), 1);
      __builtin___strncpy_chk(sqinfo->acc, (char const   *)sptr___0, 63UL, tmp___5);
    } else {
      __inline_strncpy_chk(sqinfo->acc, (char const   *)sptr___0, (size_t )63);
    }
    sqinfo->acc[63] = (char )'\000';
    sqinfo->flags |= 1 << 2;
  }
  break;
  case 1 << 3: 
  if ((int )*sptr___0 != 45) {
    if (sqinfo->flags & (1 << 3)) {
      tmp___7 = strlen((char const   *)(sqinfo->desc));
      len = (int )tmp___7;
      if (len < 126) {
        tmp___9 = __builtin_object_size((void *)(sqinfo->desc), 0);
        if (tmp___9 != 0xffffffffffffffffUL) {
          tmp___8 = __builtin_object_size((void *)(sqinfo->desc), 1);
          __builtin___strncat_chk(sqinfo->desc, " ", (unsigned long )(127 - len),
                                  tmp___8);
        } else {
          __inline_strncat_chk(sqinfo->desc, " ", (size_t )(127 - len));
        }
        len ++;
        tmp___11 = __builtin_object_size((void *)(sqinfo->desc), 0);
        if (tmp___11 != 0xffffffffffffffffUL) {
          tmp___10 = __builtin_object_size((void *)(sqinfo->desc), 1);
          __builtin___strncat_chk(sqinfo->desc, (char const   *)sptr___0, (unsigned long )(127 - len),
                                  tmp___10);
        } else {
          __inline_strncat_chk(sqinfo->desc, (char const   *)sptr___0, (size_t )(127 - len));
        }
      }
    } else {
      tmp___13 = __builtin_object_size((void *)(sqinfo->desc), 0);
      if (tmp___13 != 0xffffffffffffffffUL) {
        tmp___12 = __builtin_object_size((void *)(sqinfo->desc), 1);
        __builtin___strncpy_chk(sqinfo->desc, (char const   *)sptr___0, 127UL, tmp___12);
      } else {
        __inline_strncpy_chk(sqinfo->desc, (char const   *)sptr___0, (size_t )127);
      }
    }
    sqinfo->desc[127] = (char )'\000';
    sqinfo->flags |= 1 << 3;
  }
  break;
  case 1 << 4: 
  tmp___14 = IsInt(sptr___0);
  if (! tmp___14) {
    squid_errno = 5;
    return (0);
  }
  sqinfo->start = atoi((char const   *)sptr___0);
  if (sqinfo->start != 0) {
    sqinfo->flags |= 1 << 4;
  }
  break;
  case 1 << 5: 
  tmp___15 = IsInt(sptr___0);
  if (! tmp___15) {
    squid_errno = 5;
    return (0);
  }
  sqinfo->stop = atoi((char const   *)sptr___0);
  if (sqinfo->stop != 0) {
    sqinfo->flags |= 1 << 5;
  }
  break;
  case 1 << 8: 
  tmp___16 = IsInt(sptr___0);
  if (! tmp___16) {
    squid_errno = 5;
    return (0);
  }
  sqinfo->olen = atoi((char const   *)sptr___0);
  if (sqinfo->olen != 0) {
    sqinfo->flags |= 1 << 8;
  }
  break;
  default: 
  Die((char *)"Invalid flag %d to SetSeqinfoString()", flag);
  }
  return (1);
}
}
void SeqinfoCopy(SQINFO *sq1 , SQINFO *sq2 ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;

  {
  sq1->flags = sq2->flags;
  if (sq2->flags & 1) {
    tmp___0 = __builtin_object_size((void *)(sq1->name), 0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)(sq1->name), 1);
      __builtin___strcpy_chk(sq1->name, (char const   *)(sq2->name), tmp);
    } else {
      __inline_strcpy_chk(sq1->name, (char const   *)(sq2->name));
    }
  }
  if (sq2->flags & (1 << 1)) {
    tmp___2 = __builtin_object_size((void *)(sq1->id), 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)(sq1->id), 1);
      __builtin___strcpy_chk(sq1->id, (char const   *)(sq2->id), tmp___1);
    } else {
      __inline_strcpy_chk(sq1->id, (char const   *)(sq2->id));
    }
  }
  if (sq2->flags & (1 << 2)) {
    tmp___4 = __builtin_object_size((void *)(sq1->acc), 0);
    if (tmp___4 != 0xffffffffffffffffUL) {
      tmp___3 = __builtin_object_size((void *)(sq1->acc), 1);
      __builtin___strcpy_chk(sq1->acc, (char const   *)(sq2->acc), tmp___3);
    } else {
      __inline_strcpy_chk(sq1->acc, (char const   *)(sq2->acc));
    }
  }
  if (sq2->flags & (1 << 3)) {
    tmp___6 = __builtin_object_size((void *)(sq1->desc), 0);
    if (tmp___6 != 0xffffffffffffffffUL) {
      tmp___5 = __builtin_object_size((void *)(sq1->desc), 1);
      __builtin___strcpy_chk(sq1->desc, (char const   *)(sq2->desc), tmp___5);
    } else {
      __inline_strcpy_chk(sq1->desc, (char const   *)(sq2->desc));
    }
  }
  if (sq2->flags & (1 << 6)) {
    sq1->len = sq2->len;
  }
  if (sq2->flags & (1 << 4)) {
    sq1->start = sq2->start;
  }
  if (sq2->flags & (1 << 5)) {
    sq1->stop = sq2->stop;
  }
  if (sq2->flags & (1 << 8)) {
    sq1->olen = sq2->olen;
  }
  if (sq2->flags & (1 << 7)) {
    sq1->type = sq2->type;
  }
  if (sq2->flags & (1 << 9)) {
    sq1->ss = Strdup(sq2->ss);
  }
  if (sq2->flags & (1 << 10)) {
    sq1->sa = Strdup(sq2->sa);
  }
  return;
}
}
void ToDNA(char *seq ) 
{ 


  {
  while ((int )*seq != 0) {
    if ((int )*seq == 85) {
      *seq = (char )'T';
    } else
    if ((int )*seq == 117) {
      *seq = (char )'t';
    }
    seq ++;
  }
  return;
}
}
void ToRNA(char *seq ) 
{ 


  {
  while ((int )*seq != 0) {
    if ((int )*seq == 84) {
      *seq = (char )'U';
    } else
    if ((int )*seq == 116) {
      *seq = (char )'u';
    }
    seq ++;
  }
  return;
}
}
void ToIUPAC(char *seq , int is_aseq ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  if (is_aseq) {
    while ((int )*seq != 0) {
      tmp = strchr("ACGTUNRYMKSWHBVDacgtunrymkswhbvd", (int )*seq);
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        if (! ((int )*seq == 32)) {
          if (! ((int )*seq == 46)) {
            if (! ((int )*seq == 95)) {
              if (! ((int )*seq == 45)) {
                if (! ((int )*seq == 126)) {
                  *seq = (char )'N';
                }
              }
            }
          }
        }
      }
      seq ++;
    }
  } else {
    while ((int )*seq != 0) {
      tmp___0 = strchr("ACGTUNRYMKSWHBVDacgtunrymkswhbvd", (int )*seq);
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        *seq = (char )'N';
      }
      seq ++;
    }
  }
  return;
}
}
static void addseq(char *s___0 , struct ReadSeqVars *V ) 
{ 
  char *s0 ;
  char *sq ;
  int rpl ;
  int bpl ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (V->ssimode == -1) {
    if (V->seqlen + V->buflen > V->maxseq) {
      if (V->buflen > 500) {
        tmp = V->buflen;
      } else {
        tmp = 500;
      }
      V->maxseq += tmp;
      tmp___0 = sre_realloc((char *)"sqio.c", 524, (void *)V->seq, (size_t )(V->maxseq + 1));
      V->seq = (char *)tmp___0;
      *(V->seq + V->maxseq) = (char)0;
    }
    sq = V->seq + V->seqlen;
    while ((int )*s___0 != 0) {
      tmp___1 = isdigit((int )*s___0);
      if (! tmp___1) {
        tmp___2 = isspace((int )*s___0);
        if (! tmp___2) {
          *sq = *s___0;
          sq ++;
        }
      }
      s___0 ++;
    }
    V->seqlen = (int )(sq - V->seq);
  } else {
    s0 = s___0;
    rpl = 0;
    while ((int )*s___0 != 0) {
      tmp___3 = isdigit((int )*s___0);
      if (! tmp___3) {
        tmp___4 = isspace((int )*s___0);
        if (! tmp___4) {
          rpl ++;
        }
      }
      s___0 ++;
    }
    V->seqlen += rpl;
    bpl = (int )(s___0 - s0);
    if (V->rpl != 0) {
      if (V->lastrpl > 0) {
        if (V->rpl > 0) {
          if (V->lastrpl != V->rpl) {
            V->rpl = 0;
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (V->rpl == -1) {
          V->rpl = V->lastrpl;
        }
      }
      V->lastrpl = rpl;
      if (rpl > V->maxrpl) {
        V->maxrpl = rpl;
      }
    }
    if (V->bpl != 0) {
      if (V->lastbpl > 0) {
        if (V->bpl > 0) {
          if (V->lastbpl != V->bpl) {
            V->bpl = 0;
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (V->bpl == -1) {
          V->bpl = V->lastbpl;
        }
      }
      V->lastbpl = bpl;
      if (bpl > V->maxbpl) {
        V->maxbpl = bpl;
      }
    }
  }
  return;
}
}
static void readLoop(int addfirst , int (*endTest)(char * , int * ) , struct ReadSeqVars *V ) 
{ 
  int addend ;
  int done ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  addend = 0;
  done = 0;
  V->seqlen = 0;
  tmp = 0;
  V->lastbpl = tmp;
  V->lastrpl = tmp;
  if (addfirst) {
    if (V->ssimode >= 0) {
      V->d_off = V->ssioffset;
    }
    addseq(V->buf, V);
  } else
  if (V->ssimode >= 0) {
    tmp___0 = SSIGetFilePosition(V->f, V->ssimode, & V->d_off);
    if (0 != tmp___0) {
      Die((char *)"SSIGetFilePosition() failed");
    }
  }
  while (1) {
    SeqfileGetLine(V);
    if ((int )*(V->buf) == 0) {
      tmp___1 = feof(V->f);
      if (tmp___1) {
        done = 1;
      }
    }
    tmp___2 = (*endTest)(V->buf, & addend);
    done |= tmp___2;
    if (addend) {
      addseq(V->buf, V);
    } else
    if (! done) {
      addseq(V->buf, V);
    }
    if (! (! done)) {
      break;
    }
  }
  return;
}
}
static int endPIR(char *s___0 , int *addend ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  *addend = 0;
  tmp = strncmp((char const   *)s___0, "///", (size_t )3);
  if (tmp == 0) {
    return (1);
  } else {
    tmp___0 = strncmp((char const   *)s___0, "ENTRY", (size_t )5);
    if (tmp___0 == 0) {
      return (1);
    } else {
      return (0);
    }
  }
}
}
static void readPIR(struct ReadSeqVars *V ) 
{ 
  char *sptr___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  while (1) {
    tmp = feof(V->f);
    if (tmp) {
      break;
    } else {
      tmp___0 = strncmp((char const   *)V->buf, "ENTRY", (size_t )5);
      if (! (tmp___0 != 0)) {
        break;
      }
    }
    SeqfileGetLine(V);
  }
  tmp___1 = feof(V->f);
  if (tmp___1) {
    return;
  }
  if (V->ssimode >= 0) {
    V->r_off = V->ssioffset;
  }
  sptr___0 = strtok(V->buf + 15, "\n\t ");
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
    SetSeqinfoString(V->sqinfo, sptr___0, 1 << 1);
  }
  while (1) {
    SeqfileGetLine(V);
    tmp___4 = feof(V->f);
    if (tmp___4) {
      _L: /* CIL Label */ 
      tmp___2 = feof(V->f);
      if (! tmp___2) {
        tmp___3 = strncmp((char const   *)V->buf, "ACCESSION", (size_t )9);
        if (tmp___3 == 0) {
          sptr___0 = strtok(V->buf + 15, " \t\n");
          if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
            SetSeqinfoString(V->sqinfo, sptr___0, 1 << 2);
          }
        }
      }
    } else {
      tmp___5 = strncmp((char const   *)V->buf, "TITLE", (size_t )5);
      if (tmp___5 == 0) {
        SetSeqinfoString(V->sqinfo, V->buf + 15, 1 << 3);
      } else {
        goto _L;
      }
    }
    tmp___6 = feof(V->f);
    if (tmp___6) {
      break;
    } else {
      tmp___7 = strncmp((char const   *)V->buf, "SEQUENCE", (size_t )8);
      if (! (tmp___7 != 0)) {
        break;
      }
    }
  }
  SeqfileGetLine(V);
  readLoop(0, & endPIR, V);
  (V->sqinfo)->start = 1;
  (V->sqinfo)->stop = V->seqlen;
  (V->sqinfo)->olen = V->seqlen;
  (V->sqinfo)->flags |= ((1 << 4) | (1 << 5)) | (1 << 8);
  while (1) {
    tmp___8 = feof(V->f);
    if (tmp___8) {
      break;
    } else {
      tmp___9 = strncmp((char const   *)V->buf, "ENTRY", (size_t )5);
      if (! (tmp___9 != 0)) {
        break;
      }
    }
    SeqfileGetLine(V);
  }
  return;
}
}
static int endIG(char *s___0 , int *addend ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  *addend = 1;
  tmp = strchr((char const   *)s___0, '1');
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    tmp___1 = 1;
  } else {
    tmp___0 = strchr((char const   *)s___0, '2');
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
static void readIG(struct ReadSeqVars *V ) 
{ 
  char *nm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    SeqfileGetLine(V);
    tmp = feof(V->f);
    if (tmp) {
      break;
    } else
    if ((int )*(V->buf) != 0) {
      if ((int )*(V->buf) != 59) {
        break;
      }
    }
  }
  tmp___0 = feof(V->f);
  if (! tmp___0) {
    nm = strtok(V->buf, "\n\t ");
    if ((unsigned long )nm != (unsigned long )((void *)0)) {
      SetSeqinfoString(V->sqinfo, nm, 1);
    }
    readLoop(0, & endIG, V);
  }
  while (1) {
    tmp___1 = feof(V->f);
    if (tmp___1) {
      break;
    } else
    if ((int )*(V->buf) != 0) {
      if ((int )*(V->buf) == 59) {
        break;
      }
    }
    SeqfileGetLine(V);
  }
  return;
}
}
static int endStrider(char *s___0 , int *addend ) 
{ 
  char *tmp ;

  {
  *addend = 0;
  tmp = strstr((char const   *)s___0, "//");
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
static void readStrider(struct ReadSeqVars *V ) 
{ 
  char *nm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  while (1) {
    tmp___0 = feof(V->f);
    if (tmp___0) {
      break;
    } else
    if (! ((int )*(V->buf) == 59)) {
      break;
    }
    tmp = strncmp((char const   *)V->buf, "; DNA sequence", (size_t )14);
    if (tmp == 0) {
      nm = strtok(V->buf + 16, ",\n\t ");
      if ((unsigned long )nm != (unsigned long )((void *)0)) {
        SetSeqinfoString(V->sqinfo, nm, 1);
      }
    }
    SeqfileGetLine(V);
  }
  tmp___1 = feof(V->f);
  if (! tmp___1) {
    readLoop(1, & endStrider, V);
  }
  while (1) {
    tmp___2 = feof(V->f);
    if (tmp___2) {
      break;
    } else
    if (! ((int )*(V->buf) != 59)) {
      break;
    }
    SeqfileGetLine(V);
  }
  return;
}
}
static int endGB(char *s___0 , int *addend ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  *addend = 0;
  tmp = strstr((char const   *)s___0, "//");
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    tmp___1 = 1;
  } else {
    tmp___0 = strstr((char const   *)s___0, "LOCUS");
    if ((unsigned long )tmp___0 == (unsigned long )s___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
static void readGenBank(struct ReadSeqVars *V ) 
{ 
  char *sptr___0 ;
  int in_definition ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
  while (1) {
    tmp = strncmp((char const   *)V->buf, "LOCUS", (size_t )5);
    if (! (tmp != 0)) {
      break;
    }
    SeqfileGetLine(V);
  }
  if (V->ssimode >= 0) {
    V->r_off = V->ssioffset;
  }
  sptr___0 = strtok(V->buf + 12, "\n\t ");
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
  }
  in_definition = 0;
  while (1) {
    tmp___7 = feof(V->f);
    if (tmp___7) {
      break;
    }
    SeqfileGetLine(V);
    tmp___5 = feof(V->f);
    if (tmp___5) {
      _L___1: /* CIL Label */ 
      tmp___3 = feof(V->f);
      if (tmp___3) {
        _L___0: /* CIL Label */ 
        tmp___1 = feof(V->f);
        if (tmp___1) {
          _L: /* CIL Label */ 
          tmp___0 = strncmp((char const   *)V->buf, "ORIGIN", (size_t )6);
          if (tmp___0 != 0) {
            if (in_definition) {
              SetSeqinfoString(V->sqinfo, V->buf, 1 << 3);
            }
          } else {
            break;
          }
        } else {
          tmp___2 = strstr((char const   *)V->buf, "VERSION");
          if ((unsigned long )tmp___2 == (unsigned long )V->buf) {
            sptr___0 = strtok(V->buf + 12, "\n\t ");
            if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
              SetSeqinfoString(V->sqinfo, sptr___0, 1 << 1);
            }
            in_definition = 0;
          } else {
            goto _L;
          }
        }
      } else {
        tmp___4 = strstr((char const   *)V->buf, "ACCESSION");
        if ((unsigned long )tmp___4 == (unsigned long )V->buf) {
          sptr___0 = strtok(V->buf + 12, "\n\t ");
          if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
            SetSeqinfoString(V->sqinfo, sptr___0, 1 << 2);
          }
          in_definition = 0;
        } else {
          goto _L___0;
        }
      }
    } else {
      tmp___6 = strstr((char const   *)V->buf, "DEFINITION");
      if ((unsigned long )tmp___6 == (unsigned long )V->buf) {
        sptr___0 = strtok(V->buf + 12, "\n");
        if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
          SetSeqinfoString(V->sqinfo, sptr___0, 1 << 3);
        }
        in_definition = 1;
      } else {
        goto _L___1;
      }
    }
  }
  readLoop(0, & endGB, V);
  (V->sqinfo)->start = 1;
  (V->sqinfo)->stop = V->seqlen;
  (V->sqinfo)->olen = V->seqlen;
  (V->sqinfo)->flags |= ((1 << 4) | (1 << 5)) | (1 << 8);
  while (1) {
    tmp___8 = feof(V->f);
    if (tmp___8) {
      break;
    } else
    if ((int )*(V->buf) != 0) {
      tmp___9 = strstr((char const   *)V->buf, "LOCUS");
      if ((unsigned long )tmp___9 == (unsigned long )V->buf) {
        break;
      }
    }
    SeqfileGetLine(V);
  }
  while (1) {
    tmp___10 = feof(V->f);
    if (tmp___10) {
      break;
    } else {
      tmp___11 = strstr((char const   *)V->buf, "LOCUS  ");
      if (! ((unsigned long )tmp___11 != (unsigned long )V->buf)) {
        break;
      }
    }
    SeqfileGetLine(V);
  }
  return;
}
}
static int endGCGdata(char *s___0 , int *addend ) 
{ 


  {
  *addend = 0;
  return ((int )*s___0 == 62);
}
}
static void readGCGdata(struct ReadSeqVars *V ) 
{ 
  int binary ;
  int blen ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  binary = 0;
  blen = 0;
  tmp___0 = Strparse((char *)">>>>([^ ]+) .+2BIT +Len: ([0-9]+)", V->buf, 2);
  if (tmp___0) {
    binary = 1;
    SetSeqinfoString(V->sqinfo, sqd_parse[1], 1);
    blen = atoi((char const   *)sqd_parse[2]);
  } else {
    tmp = Strparse((char *)">>>>([^ ]+) .+ASCII +Len: [0-9]+", V->buf, 1);
    if (tmp) {
      SetSeqinfoString(V->sqinfo, sqd_parse[1], 1);
    } else {
      Die((char *)"bogus GCGdata format? %s", V->buf);
    }
  }
  SeqfileGetLine(V);
  SetSeqinfoString(V->sqinfo, V->buf, 1 << 3);
  if (binary) {
    if (blen >= V->maxseq) {
      V->maxseq = blen;
      tmp___2 = realloc((void *)V->seq, sizeof(char ) * (unsigned long )(V->maxseq + 4));
      tmp___1 = (char *)tmp___2;
      V->seq = tmp___1;
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        Die((char *)"malloc failed");
      }
    }
    tmp___3 = fread((void *)V->seq, sizeof(char ), (size_t )((blen + 3) / 4), V->f);
    if (tmp___3 < (size_t )((blen + 3) / 4)) {
      Die((char *)"fread failed");
    }
    V->seqlen = blen;
    GCGBinaryToSequence(V->seq, blen);
  } else {
    readLoop(0, & endGCGdata, V);
  }
  while (1) {
    tmp___4 = feof(V->f);
    if (tmp___4) {
      break;
    } else
    if ((int )*(V->buf) != 0) {
      if ((int )*(V->buf) == 62) {
        break;
      }
    }
    SeqfileGetLine(V);
  }
  return;
}
}
static int endPearson(char *s___0 , int *addend ) 
{ 


  {
  *addend = 0;
  return ((int )*s___0 == 62);
}
}
static void readPearson(struct ReadSeqVars *V ) 
{ 
  char *sptr___0 ;
  int tmp ;

  {
  if (V->ssimode >= 0) {
    V->r_off = V->ssioffset;
  }
  if ((int )*(V->buf) != 62) {
    Die((char *)"File %s does not appear to be in FASTA format at line %d.\nYou may want to specify the file format on the command line.\nUsually this is done with an option --informat <fmt>.\n",
        V->fname, V->linenumber);
  }
  sptr___0 = strtok(V->buf + 1, "\n\t ");
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
  }
  sptr___0 = strtok((char *)((void *)0), "\n");
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
    SetSeqinfoString(V->sqinfo, sptr___0, 1 << 3);
  }
  readLoop(0, & endPearson, V);
  while (1) {
    tmp = feof(V->f);
    if (tmp) {
      break;
    } else
    if ((int )*(V->buf) != 0) {
      if ((int )*(V->buf) == 62) {
        break;
      }
    }
    SeqfileGetLine(V);
  }
  return;
}
}
static int endEMBL(char *s___0 , int *addend ) 
{ 
  int tmp ;

  {
  *addend = 0;
  tmp = strncmp((char const   *)s___0, "     ", (size_t )5);
  return (tmp != 0);
}
}
static void readEMBL(struct ReadSeqVars *V ) 
{ 
  char *sptr___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  while (1) {
    tmp = feof(V->f);
    if (tmp) {
      break;
    } else {
      tmp___0 = strncmp((char const   *)V->buf, "ID  ", (size_t )4);
      if (! (tmp___0 != 0)) {
        break;
      }
    }
    SeqfileGetLine(V);
  }
  if (V->ssimode >= 0) {
    V->r_off = V->ssioffset;
  }
  sptr___0 = strtok(V->buf + 5, "\n\t ");
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
    SetSeqinfoString(V->sqinfo, sptr___0, 1 << 1);
  }
  while (1) {
    SeqfileGetLine(V);
    tmp___3 = feof(V->f);
    if (tmp___3) {
      _L: /* CIL Label */ 
      tmp___1 = feof(V->f);
      if (! tmp___1) {
        tmp___2 = strstr((char const   *)V->buf, "DE  ");
        if ((unsigned long )tmp___2 == (unsigned long )V->buf) {
          sptr___0 = strtok(V->buf + 5, "\n");
          if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
            SetSeqinfoString(V->sqinfo, sptr___0, 1 << 3);
          }
        }
      }
    } else {
      tmp___4 = strstr((char const   *)V->buf, "AC  ");
      if ((unsigned long )tmp___4 == (unsigned long )V->buf) {
        sptr___0 = strtok(V->buf + 5, ";  \t\n");
        if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
          SetSeqinfoString(V->sqinfo, sptr___0, 1 << 2);
        }
      } else {
        goto _L;
      }
    }
    tmp___5 = feof(V->f);
    if (tmp___5) {
      break;
    } else {
      tmp___6 = strncmp((char const   *)V->buf, "SQ", (size_t )2);
      if (! (tmp___6 != 0)) {
        break;
      }
    }
  }
  readLoop(0, & endEMBL, V);
  if (V->ssimode == -1) {
    sptr___0 = V->seq;
    while ((int )*sptr___0 != 0) {
      if ((int )*sptr___0 == 45) {
        *sptr___0 = (char )'N';
      }
      sptr___0 ++;
    }
  }
  (V->sqinfo)->start = 1;
  (V->sqinfo)->stop = V->seqlen;
  (V->sqinfo)->olen = V->seqlen;
  (V->sqinfo)->flags |= ((1 << 4) | (1 << 5)) | (1 << 8);
  while (1) {
    tmp___7 = feof(V->f);
    if (tmp___7) {
      break;
    } else {
      tmp___8 = strncmp((char const   *)V->buf, "ID  ", (size_t )4);
      if (! (tmp___8 != 0)) {
        break;
      }
    }
    SeqfileGetLine(V);
  }
  return;
}
}
static int endZuker(char *s___0 , int *addend ) 
{ 


  {
  *addend = 0;
  return ((int )*s___0 == 40);
}
}
static void readZuker(struct ReadSeqVars *V ) 
{ 
  char *sptr___0 ;
  int tmp ;

  {
  SeqfileGetLine(V);
  sptr___0 = strtok(V->buf + 6, " \t\n");
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
  }
  sptr___0 = strtok((char *)((void *)0), "\n");
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
    SetSeqinfoString(V->sqinfo, sptr___0, 1 << 3);
  }
  readLoop(0, & endZuker, V);
  while (1) {
    tmp = feof(V->f);
    if (tmp | (((int )*(V->buf) != 0) & ((int )*(V->buf) == 40))) {
      break;
    }
    SeqfileGetLine(V);
  }
  return;
}
}
static void readUWGCG(struct ReadSeqVars *V ) 
{ 
  char *si ;
  char *sptr___0 ;
  int done ;

  {
  V->seqlen = 0;
  si = strstr((char const   *)V->buf, "  Length: ");
  if ((unsigned long )si != (unsigned long )((void *)0)) {
    *si = (char)0;
  } else {
    si = strstr((char const   *)V->buf, "..");
    if ((unsigned long )si != (unsigned long )((void *)0)) {
      *si = (char)0;
    }
  }
  sptr___0 = strtok(V->buf, "\n\t ");
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
  }
  while (1) {
    done = feof(V->f);
    SeqfileGetLine(V);
    if (! done) {
      addseq(V->buf, V);
    }
    if (! (! done)) {
      break;
    }
  }
  return;
}
}
int ReadSeq(SQFILE *V , int format , char **ret_seq , SQINFO *sqinfo ) 
{ 
  int gotuw ;
  MSA *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  squid_errno = 0;
  if (V->format > 100) {
    if ((V->msa)->lastidx >= (V->msa)->nseq) {
      MSAFree(V->msa);
      tmp = MSAFileRead(V->afp);
      V->msa = tmp;
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        return (0);
      }
      (V->msa)->lastidx = 0;
    }
    MakeDealignedString(*((V->msa)->aseq + (V->msa)->lastidx), (V->msa)->alen, *((V->msa)->aseq + (V->msa)->lastidx),
                        & V->seq);
    tmp___0 = strlen((char const   *)V->seq);
    V->seqlen = (int )tmp___0;
    sqinfo->flags = 0;
    if ((unsigned long )*((V->msa)->sqname + (V->msa)->lastidx) != (unsigned long )((void *)0)) {
      SetSeqinfoString(sqinfo, *((V->msa)->sqname + (V->msa)->lastidx), 1);
    }
    if ((unsigned long )(V->msa)->sqacc != (unsigned long )((void *)0)) {
      if ((unsigned long )*((V->msa)->sqacc + (V->msa)->lastidx) != (unsigned long )((void *)0)) {
        SetSeqinfoString(sqinfo, *((V->msa)->sqacc + (V->msa)->lastidx), 1 << 2);
      }
    }
    if ((unsigned long )(V->msa)->sqdesc != (unsigned long )((void *)0)) {
      if ((unsigned long )*((V->msa)->sqdesc + (V->msa)->lastidx) != (unsigned long )((void *)0)) {
        SetSeqinfoString(sqinfo, *((V->msa)->sqdesc + (V->msa)->lastidx), 1 << 3);
      }
    }
    if ((unsigned long )(V->msa)->ss != (unsigned long )((void *)0)) {
      if ((unsigned long )*((V->msa)->ss + (V->msa)->lastidx) != (unsigned long )((void *)0)) {
        MakeDealignedString(*((V->msa)->aseq + (V->msa)->lastidx), (V->msa)->alen,
                            *((V->msa)->ss + (V->msa)->lastidx), & sqinfo->ss);
        sqinfo->flags |= 1 << 9;
      }
    }
    if ((unsigned long )(V->msa)->sa != (unsigned long )((void *)0)) {
      if ((unsigned long )*((V->msa)->sa + (V->msa)->lastidx) != (unsigned long )((void *)0)) {
        MakeDealignedString(*((V->msa)->aseq + (V->msa)->lastidx), (V->msa)->alen,
                            *((V->msa)->sa + (V->msa)->lastidx), & sqinfo->sa);
        sqinfo->flags |= 1 << 10;
      }
    }
    ((V->msa)->lastidx) ++;
  } else {
    tmp___1 = feof(V->f);
    if (tmp___1) {
      return (0);
    }
    if (V->ssimode == -1) {
      tmp___2 = calloc((size_t )501, sizeof(char ));
      V->seq = (char *)tmp___2;
      V->maxseq = 500;
    } else {
      V->seq = (char *)((void *)0);
      V->maxseq = 0;
    }
    V->seqlen = 0;
    V->sqinfo = sqinfo;
    (V->sqinfo)->flags = 0;
    switch (V->format) {
    case 1: 
    readIG(V);
    break;
    case 6: 
    readStrider(V);
    break;
    case 2: 
    readGenBank(V);
    break;
    case 7: 
    readPearson(V);
    break;
    case 4: 
    readEMBL(V);
    break;
    case 8: 
    readZuker(V);
    break;
    case 12: 
    readPIR(V);
    break;
    case 16: 
    readGCGdata(V);
    break;
    case 5: 
    while (1) {
      tmp___3 = strstr((char const   *)V->buf, "..");
      gotuw = (unsigned long )tmp___3 != (unsigned long )((void *)0);
      if (gotuw) {
        readUWGCG(V);
      }
      SeqfileGetLine(V);
      tmp___4 = feof(V->f);
      if (tmp___4) {
        break;
      }
    }
    break;
    default: 
    squid_errno = 5;
    free((void *)V->seq);
    return (0);
    }
    if ((unsigned long )V->seq != (unsigned long )((void *)0)) {
      *(V->seq + V->seqlen) = (char)0;
    }
  }
  sqinfo->len = V->seqlen;
  sqinfo->flags |= 1 << 6;
  *ret_seq = V->seq;
  if (squid_errno == 0) {
    return (1);
  } else {
    return (0);
  }
}
}
int SeqfileFormat(FILE *fp ) 
{ 
  char *buf ;
  int len ;
  int fmt ;
  int ndataline ;
  char *bufcpy ;
  char *s___0 ;
  char *s1 ;
  char *s2 ;
  int has_junk ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;

  {
  fmt = 0;
  buf = (char *)((void *)0);
  len = 0;
  ndataline = 0;
  has_junk = 0;
  while (1) {
    tmp___35 = sre_fgets(& buf, & len, fp);
    if (! ((unsigned long )tmp___35 != (unsigned long )((void *)0))) {
      break;
    }
    tmp = IsBlankline(buf);
    if (tmp) {
      continue;
    }
    if (ndataline == 0) {
      tmp___0 = strncmp((char const   *)buf, ">>>>", (size_t )4);
      if (tmp___0 == 0) {
        tmp___1 = strstr((char const   *)buf, "Len: ");
        if (tmp___1) {
          fmt = 16;
          goto DONE;
        }
      }
      if ((int )*(buf + 0) == 62) {
        fmt = 7;
        goto DONE;
      }
      tmp___2 = strncmp((char const   *)buf, "!!AA_SEQUENCE", (size_t )13);
      if (tmp___2 == 0) {
        fmt = 5;
        goto DONE;
      } else {
        tmp___3 = strncmp((char const   *)buf, "!!NA_SEQUENCE", (size_t )13);
        if (tmp___3 == 0) {
          fmt = 5;
          goto DONE;
        }
      }
      tmp___4 = strncmp((char const   *)buf, "# STOCKHOLM 1.", (size_t )14);
      if (tmp___4 == 0) {
        fmt = 101;
        goto DONE;
      }
      tmp___5 = strncmp((char const   *)buf, "CLUSTAL", (size_t )7);
      if (tmp___5 == 0) {
        tmp___6 = strstr((char const   *)buf, "multiple sequence alignment");
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
          fmt = 104;
          goto DONE;
        }
      }
      tmp___7 = strncmp((char const   *)buf, "!!AA_MULTIPLE_ALIGNMENT", (size_t )23);
      if (tmp___7 == 0) {
        fmt = 103;
        goto DONE;
      } else {
        tmp___8 = strncmp((char const   *)buf, "!!NA_MULTIPLE_ALIGNMENT", (size_t )23);
        if (tmp___8 == 0) {
          fmt = 103;
          goto DONE;
        }
      }
      bufcpy = sre_strdup(buf, -1);
      s___0 = bufcpy;
      s1 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
      if ((unsigned long )s1 != (unsigned long )((void *)0)) {
        s2 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
        if ((unsigned long )s2 != (unsigned long )((void *)0)) {
          tmp___9 = IsInt(s1);
          if (tmp___9) {
            tmp___10 = IsInt(s2);
            if (tmp___10) {
              free((void *)bufcpy);
              fmt = 106;
              goto DONE;
            }
          }
        }
      }
      free((void *)bufcpy);
    }
    tmp___11 = strncmp((char const   *)buf, "#=AU", (size_t )4);
    if (tmp___11 == 0) {
      fmt = 102;
      goto DONE;
    } else {
      tmp___12 = strncmp((char const   *)buf, "#=ID", (size_t )4);
      if (tmp___12 == 0) {
        fmt = 102;
        goto DONE;
      } else {
        tmp___13 = strncmp((char const   *)buf, "#=AC", (size_t )4);
        if (tmp___13 == 0) {
          fmt = 102;
          goto DONE;
        } else {
          tmp___14 = strncmp((char const   *)buf, "#=DE", (size_t )4);
          if (tmp___14 == 0) {
            fmt = 102;
            goto DONE;
          } else {
            tmp___15 = strncmp((char const   *)buf, "#=GA", (size_t )4);
            if (tmp___15 == 0) {
              fmt = 102;
              goto DONE;
            } else {
              tmp___16 = strncmp((char const   *)buf, "#=TC", (size_t )4);
              if (tmp___16 == 0) {
                fmt = 102;
                goto DONE;
              } else {
                tmp___17 = strncmp((char const   *)buf, "#=NC", (size_t )4);
                if (tmp___17 == 0) {
                  fmt = 102;
                  goto DONE;
                } else {
                  tmp___18 = strncmp((char const   *)buf, "#=SQ", (size_t )4);
                  if (tmp___18 == 0) {
                    fmt = 102;
                    goto DONE;
                  } else {
                    tmp___19 = strncmp((char const   *)buf, "#=SS", (size_t )4);
                    if (tmp___19 == 0) {
                      fmt = 102;
                      goto DONE;
                    } else {
                      tmp___20 = strncmp((char const   *)buf, "#=CS", (size_t )4);
                      if (tmp___20 == 0) {
                        fmt = 102;
                        goto DONE;
                      } else {
                        tmp___21 = strncmp((char const   *)buf, "#=RF", (size_t )4);
                        if (tmp___21 == 0) {
                          fmt = 102;
                          goto DONE;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    tmp___22 = strncmp((char const   *)buf, "///", (size_t )3);
    if (tmp___22 == 0) {
      fmt = 12;
      goto DONE;
    } else {
      tmp___23 = strncmp((char const   *)buf, "ENTRY ", (size_t )6);
      if (tmp___23 == 0) {
        fmt = 12;
        goto DONE;
      }
    }
    tmp___24 = strstr((char const   *)buf, "..");
    if ((unsigned long )tmp___24 != (unsigned long )((void *)0)) {
      tmp___25 = strstr((char const   *)buf, "MSF:");
      if ((unsigned long )tmp___25 != (unsigned long )((void *)0)) {
        tmp___26 = strstr((char const   *)buf, "Check:");
        if ((unsigned long )tmp___26 != (unsigned long )((void *)0)) {
          fmt = 103;
          goto DONE;
        }
      }
    }
    tmp___27 = strstr((char const   *)buf, " Check: ");
    if ((unsigned long )tmp___27 != (unsigned long )((void *)0)) {
      tmp___28 = strstr((char const   *)buf, "..");
      if ((unsigned long )tmp___28 != (unsigned long )((void *)0)) {
        fmt = 5;
        goto DONE;
      }
    }
    tmp___29 = strncmp((char const   *)buf, "LOCUS ", (size_t )6);
    if (tmp___29 == 0) {
      fmt = 2;
      goto DONE;
    } else {
      tmp___30 = strncmp((char const   *)buf, "ORIGIN ", (size_t )6);
      if (tmp___30 == 0) {
        fmt = 2;
        goto DONE;
      }
    }
    tmp___31 = strncmp((char const   *)buf, "ID   ", (size_t )5);
    if (tmp___31 == 0) {
      fmt = 4;
      goto DONE;
    } else {
      tmp___32 = strncmp((char const   *)buf, "SQ   ", (size_t )5);
      if (tmp___32 == 0) {
        fmt = 4;
        goto DONE;
      }
    }
    s___0 = buf;
    s1 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
    if ((unsigned long )s1 == (unsigned long )((void *)0)) {
      continue;
    }
    tmp___33 = strchr("#%", (int )*s1);
    if ((unsigned long )tmp___33 != (unsigned long )((void *)0)) {
      continue;
    }
    s2 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
      has_junk = 1;
    }
    if ((unsigned long )s2 != (unsigned long )((void *)0)) {
      tmp___34 = Seqtype(s2);
      if (tmp___34 == 0) {
        has_junk = 1;
      }
    }
    ndataline ++;
    if (ndataline == 300) {
      break;
    }
  }
  if (ndataline == 0) {
    Die((char *)"Sequence file contains no data");
  }
  if (has_junk == 1) {
    fmt = 0;
  } else {
    fmt = 102;
  }
  DONE: 
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    free((void *)buf);
  }
  rewind(fp);
  return (fmt);
}
}
int GCGBinaryToSequence(char *seq , int len ) 
{ 
  int bpos ;
  int spos ;
  char twobit ;
  int i___0 ;

  {
  bpos = (len - 1) / 4;
  while (bpos >= 0) {
    twobit = *(seq + bpos);
    spos = bpos * 4;
    i___0 = 3;
    while (i___0 >= 0) {
      switch ((int )twobit & 3) {
      case 0: 
      *(seq + (spos + i___0)) = (char )'C';
      break;
      case 1: 
      *(seq + (spos + i___0)) = (char )'T';
      break;
      case 2: 
      *(seq + (spos + i___0)) = (char )'A';
      break;
      case 3: 
      *(seq + (spos + i___0)) = (char )'G';
      break;
      }
      twobit = (char )((int )twobit >> 2);
      i___0 --;
    }
    bpos --;
  }
  *(seq + len) = (char )'\000';
  return (1);
}
}
int GCGchecksum(char *seq , int len ) 
{ 
  int i___0 ;
  int chk ;
  int tmp ;

  {
  chk = 0;
  i___0 = 0;
  while (i___0 < len) {
    tmp = sre_toupper((int )*(seq + i___0));
    chk = (chk + (i___0 % 57 + 1) * tmp) % 10000;
    i___0 ++;
  }
  return (chk);
}
}
int GCGMultchecksum(char **seqs , int nseq ) 
{ 
  int chk ;
  int idx ;
  size_t tmp ;
  int tmp___0 ;

  {
  chk = 0;
  idx = 0;
  while (idx < nseq) {
    tmp = strlen((char const   *)*(seqs + idx));
    tmp___0 = GCGchecksum(*(seqs + idx), (int )tmp);
    chk = (chk + tmp___0) % 10000;
    idx ++;
  }
  return (chk);
}
}
int Seqtype(char *seq ) 
{ 
  int saw ;
  char c ;
  int po ;
  int nt ;
  int nu ;
  int na ;
  int aa___0 ;
  int no ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  po = 0;
  nt = 0;
  nu = 0;
  na = 0;
  aa___0 = 0;
  no = 0;
  saw = 0;
  while (1) {
    if ((int )*seq != 0) {
      if (! (saw < 300)) {
        break;
      }
    } else {
      break;
    }
    tmp = sre_toupper((int )*seq);
    c = (char )tmp;
    if (! ((int )c == 32)) {
      if (! ((int )c == 46)) {
        if (! ((int )c == 95)) {
          if (! ((int )c == 45)) {
            if (! ((int )c == 126)) {
              tmp___3 = strchr((char const   *)protonly, (int )c);
              if (tmp___3) {
                po ++;
              } else {
                tmp___2 = strchr((char const   *)primenuc, (int )c);
                if (tmp___2) {
                  na ++;
                  if ((int )c == 84) {
                    nt ++;
                  } else
                  if ((int )c == 85) {
                    nu ++;
                  }
                } else {
                  tmp___1 = strchr((char const   *)aminos, (int )c);
                  if (tmp___1) {
                    aa___0 ++;
                  } else {
                    tmp___0 = isalpha((int )c);
                    if (tmp___0) {
                      no ++;
                    }
                  }
                }
              }
              saw ++;
            }
          }
        }
      }
    }
    seq ++;
  }
  if (no > 0) {
    return (0);
  } else
  if (po > 0) {
    return (3);
  } else
  if (na > aa___0) {
    if (nu > nt) {
      return (2);
    } else {
      return (1);
    }
  } else {
    return (3);
  }
}
}
int GuessAlignmentSeqtype(char **aseq , int nseq ) 
{ 
  int idx ;
  int nrna ;
  int ndna ;
  int namino ;
  int nother ;
  int tmp ;

  {
  nrna = 0;
  ndna = 0;
  namino = 0;
  nother = 0;
  idx = 0;
  while (idx < nseq) {
    tmp = Seqtype(*(aseq + idx));
    switch (tmp) {
    case 2: 
    nrna ++;
    break;
    case 1: 
    ndna ++;
    break;
    case 3: 
    namino ++;
    break;
    default: 
    nother ++;
    }
    idx ++;
  }
  if (nother) {
    return (0);
  }
  if (namino == nseq) {
    return (3);
  }
  if (ndna == nseq) {
    return (1);
  }
  if (nrna == nseq) {
    return (2);
  }
  if (namino == 0) {
    return (2);
  }
  return (3);
}
}
void WriteSimpleFASTA(FILE *fp , char *seq , char *name , char *desc ) 
{ 
  char buf[61] ;
  int len ;
  int pos ;
  size_t tmp ;
  char const   *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  tmp = strlen((char const   *)seq);
  len = (int )tmp;
  buf[60] = (char )'\000';
  if ((unsigned long )desc != (unsigned long )((void *)0)) {
    tmp___0 = (char const   *)desc;
  } else {
    tmp___0 = "";
  }
  fprintf(fp, ">%s %s\n", name, tmp___0);
  pos = 0;
  while (pos < len) {
    tmp___2 = __builtin_object_size((void *)(buf), 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)(buf), 1);
      __builtin___strncpy_chk(buf, (char const   *)(seq + pos), 60UL, tmp___1);
    } else {
      __inline_strncpy_chk(buf, (char const   *)(seq + pos), (size_t )60);
    }
    fprintf(fp, "%s\n", buf);
    pos += 60;
  }
  return;
}
}
int WriteSeq(FILE *outf , int outform , char *seq , SQINFO *sqinfo ) 
{ 
  int numline ;
  int lines ;
  int spacer ;
  int width ;
  int tab ;
  int i___0 ;
  int j ;
  int l ;
  int l1 ;
  int ibase ;
  char endstr[10] ;
  char s___0[100] ;
  char ss[100] ;
  int checksum ;
  int seqlen ;
  int which_case ;
  int dostruc ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  unsigned long tmp___20 ;
  unsigned long tmp___21 ;
  char *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  unsigned long tmp___25 ;
  unsigned long tmp___26 ;
  unsigned long tmp___27 ;
  unsigned long tmp___28 ;
  unsigned long tmp___29 ;
  unsigned long tmp___30 ;
  char const   *tmp___31 ;
  unsigned long tmp___32 ;
  unsigned long tmp___33 ;
  char const   *tmp___34 ;
  char tmp___35 ;

  {
  numline = 0;
  lines = 0;
  spacer = 0;
  width = 50;
  tab = 0;
  checksum = 0;
  which_case = 0;
  dostruc = 0;
  if (sqinfo->flags & (1 << 6)) {
    seqlen = sqinfo->len;
  } else {
    tmp = strlen((char const   *)seq);
    seqlen = (int )tmp;
  }
  if (outform > 100) {
    Die((char *)"Tried to write an aligned format with WriteSeq() -- bad, bad.");
  }
  tmp___1 = __builtin_object_size((void *)(endstr), 0);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)(endstr), 1);
    __builtin___strcpy_chk(endstr, "", tmp___0);
  } else {
    __inline_strcpy_chk(endstr, "");
  }
  l1 = 0;
  checksum = GCGchecksum(seq, seqlen);
  switch (outform) {
  case 0: 
  tmp___3 = __builtin_object_size((void *)(endstr), 0);
  if (tmp___3 != 0xffffffffffffffffUL) {
    tmp___2 = __builtin_object_size((void *)(endstr), 1);
    __builtin___strcpy_chk(endstr, "\n", tmp___2);
  } else {
    __inline_strcpy_chk(endstr, "\n");
  }
  break;
  case 2: 
  fprintf(outf, "LOCUS       %s       %d bp\n", sqinfo->name, seqlen);
  if (sqinfo->flags & (1 << 2)) {
    tmp___4 = (char const   *)(sqinfo->acc);
  } else {
    tmp___4 = ".";
  }
  fprintf(outf, "ACCESSION   %s\n", tmp___4);
  if (sqinfo->flags & (1 << 3)) {
    tmp___5 = (char const   *)(sqinfo->desc);
  } else {
    tmp___5 = ".";
  }
  fprintf(outf, "DEFINITION  %s\n", tmp___5);
  if (sqinfo->flags & (1 << 1)) {
    tmp___6 = (char const   *)(sqinfo->id);
  } else {
    tmp___6 = ".";
  }
  fprintf(outf, "VERSION     %s\n", tmp___6);
  fprintf(outf, "ORIGIN      \n");
  spacer = 11;
  numline = 1;
  tmp___8 = __builtin_object_size((void *)(endstr), 0);
  if (tmp___8 != 0xffffffffffffffffUL) {
    tmp___7 = __builtin_object_size((void *)(endstr), 1);
    __builtin___strcpy_chk(endstr, "\n//", tmp___7);
  } else {
    __inline_strcpy_chk(endstr, "\n//");
  }
  break;
  case 16: 
  fprintf(outf, ">>>>%s  9/95  ASCII  Len: %d\n", sqinfo->name, seqlen);
  if (sqinfo->flags & (1 << 3)) {
    tmp___9 = (char const   *)(sqinfo->desc);
  } else {
    tmp___9 = "-";
  }
  fprintf(outf, "%s\n", tmp___9);
  break;
  case 12: 
  if (sqinfo->flags & (1 << 1)) {
    tmp___10 = sqinfo->id;
  } else {
    tmp___10 = sqinfo->name;
  }
  fprintf(outf, "ENTRY          %s\n", tmp___10);
  if (sqinfo->flags & (1 << 3)) {
    tmp___11 = (char const   *)(sqinfo->desc);
  } else {
    tmp___11 = "-";
  }
  fprintf(outf, "TITLE          %s\n", tmp___11);
  if (sqinfo->flags & (1 << 2)) {
    tmp___12 = (char const   *)(sqinfo->acc);
  } else {
    tmp___12 = "-";
  }
  fprintf(outf, "ACCESSION      %s\n", tmp___12);
  fprintf(outf, "SUMMARY                                #Length %d  #Checksum  %d\n",
          sqinfo->len, checksum);
  fprintf(outf, "SEQUENCE\n");
  fprintf(outf, "                  5        10        15        20        25        30\n");
  spacer = 2;
  numline = 1;
  width = 30;
  tmp___14 = __builtin_object_size((void *)(endstr), 0);
  if (tmp___14 != 0xffffffffffffffffUL) {
    tmp___13 = __builtin_object_size((void *)(endstr), 1);
    __builtin___strcpy_chk(endstr, "\n///", tmp___13);
  } else {
    __inline_strcpy_chk(endstr, "\n///");
  }
  break;
  case 14: 
  fprintf(outf, "NAM  %s\n", sqinfo->name);
  if (sqinfo->flags & (((((1 << 1) | (1 << 2)) | (1 << 4)) | (1 << 5)) | (1 << 8))) {
    if (sqinfo->flags & (1 << 8)) {
      tmp___15 = sqinfo->olen;
    } else {
      tmp___15 = 0;
    }
    if (sqinfo->flags & (1 << 5)) {
      tmp___16 = sqinfo->stop;
    } else {
      tmp___16 = 0;
    }
    if (sqinfo->flags & (1 << 4)) {
      tmp___17 = sqinfo->start;
    } else {
      tmp___17 = 0;
    }
    if (sqinfo->flags & (1 << 2)) {
      tmp___18 = (char const   *)(sqinfo->acc);
    } else {
      tmp___18 = "-";
    }
    if (sqinfo->flags & (1 << 1)) {
      tmp___19 = (char const   *)(sqinfo->id);
    } else {
      tmp___19 = "-";
    }
    fprintf(outf, "SRC  %s %s %d..%d::%d\n", tmp___19, tmp___18, tmp___17, tmp___16,
            tmp___15);
  }
  if (sqinfo->flags & (1 << 3)) {
    fprintf(outf, "DES  %s\n", sqinfo->desc);
  }
  if (sqinfo->flags & (1 << 9)) {
    fprintf(outf, "SEQ  +SS\n");
    dostruc = 1;
  } else {
    fprintf(outf, "SEQ\n");
  }
  numline = 1;
  tmp___21 = __builtin_object_size((void *)(endstr), 0);
  if (tmp___21 != 0xffffffffffffffffUL) {
    tmp___20 = __builtin_object_size((void *)(endstr), 1);
    __builtin___strcpy_chk(endstr, "\n++", tmp___20);
  } else {
    __inline_strcpy_chk(endstr, "\n++");
  }
  break;
  case 4: 
  if (sqinfo->flags & (1 << 1)) {
    tmp___22 = sqinfo->id;
  } else {
    tmp___22 = sqinfo->name;
  }
  fprintf(outf, "ID   %s\n", tmp___22);
  if (sqinfo->flags & (1 << 2)) {
    tmp___23 = (char const   *)(sqinfo->acc);
  } else {
    tmp___23 = "-";
  }
  fprintf(outf, "AC   %s\n", tmp___23);
  if (sqinfo->flags & (1 << 3)) {
    tmp___24 = (char const   *)(sqinfo->desc);
  } else {
    tmp___24 = "-";
  }
  fprintf(outf, "DE   %s\n", tmp___24);
  fprintf(outf, "SQ             %d BP\n", seqlen);
  tmp___26 = __builtin_object_size((void *)(endstr), 0);
  if (tmp___26 != 0xffffffffffffffffUL) {
    tmp___25 = __builtin_object_size((void *)(endstr), 1);
    __builtin___strcpy_chk(endstr, "\n//", tmp___25);
  } else {
    __inline_strcpy_chk(endstr, "\n//");
  }
  tab = 5;
  spacer = 11;
  break;
  case 5: 
  fprintf(outf, "%s\n", sqinfo->name);
  if (sqinfo->flags & (1 << 2)) {
    fprintf(outf, "ACCESSION   %s\n", sqinfo->acc);
  }
  if (sqinfo->flags & (1 << 3)) {
    fprintf(outf, "DEFINITION  %s\n", sqinfo->desc);
  }
  fprintf(outf, "    %s  Length: %d  (today)  Check: %d  ..\n", sqinfo->name, seqlen,
          checksum);
  spacer = 11;
  numline = 1;
  tmp___28 = __builtin_object_size((void *)(endstr), 0);
  if (tmp___28 != 0xffffffffffffffffUL) {
    tmp___27 = __builtin_object_size((void *)(endstr), 1);
    __builtin___strcpy_chk(endstr, "\n", tmp___27);
  } else {
    __inline_strcpy_chk(endstr, "\n");
  }
  break;
  case 6: 
  fprintf(outf, "; ### from DNA Strider ;-)\n");
  fprintf(outf, "; DNA sequence  %s, %d bases, %d checksum.\n;\n", sqinfo->name, seqlen,
          checksum);
  tmp___30 = __builtin_object_size((void *)(endstr), 0);
  if (tmp___30 != 0xffffffffffffffffUL) {
    tmp___29 = __builtin_object_size((void *)(endstr), 1);
    __builtin___strcpy_chk(endstr, "\n//", tmp___29);
  } else {
    __inline_strcpy_chk(endstr, "\n//");
  }
  break;
  case 8: 
  which_case = 1;
  case 1: 
  if (sqinfo->flags & (1 << 3)) {
    tmp___31 = (char const   *)(sqinfo->desc);
  } else {
    tmp___31 = "";
  }
  fprintf(outf, ";%s %s\n", sqinfo->name, tmp___31);
  fprintf(outf, "%s\n", sqinfo->name);
  tmp___33 = __builtin_object_size((void *)(endstr), 0);
  if (tmp___33 != 0xffffffffffffffffUL) {
    tmp___32 = __builtin_object_size((void *)(endstr), 1);
    __builtin___strcpy_chk(endstr, "1", tmp___32);
  } else {
    __inline_strcpy_chk(endstr, "1");
  }
  break;
  case 13: 
  break;
  default: 
  if (sqinfo->flags & (1 << 3)) {
    tmp___34 = (char const   *)(sqinfo->desc);
  } else {
    tmp___34 = "";
  }
  fprintf(outf, ">%s %s\n", sqinfo->name, tmp___34);
  break;
  }
  if (which_case == 1) {
    s2upper(seq);
  }
  if (which_case == 2) {
    s2lower(seq);
  }
  if (width < 100) {
    width = width;
  } else {
    width = 100;
  }
  i___0 = 0;
  l = 0;
  ibase = 1;
  lines = 0;
  while (i___0 < seqlen) {
    if (l1 < 0) {
      l1 = 0;
    } else
    if (l1 == 0) {
      if (numline) {
        fprintf(outf, "%8d ", ibase);
      }
      j = 0;
      while (j < tab) {
        fputc(' ', outf);
        j ++;
      }
    }
    if (spacer != 0) {
      if ((l + 1) % spacer == 1) {
        s___0[l] = (char )' ';
        ss[l] = (char )' ';
        l ++;
      }
    }
    s___0[l] = *(seq + i___0);
    if (sqinfo->flags & (1 << 9)) {
      ss[l] = *(sqinfo->ss + i___0);
    } else {
      ss[l] = (char )'.';
    }
    l ++;
    i___0 ++;
    l1 ++;
    if (l1 == width) {
      goto _L;
    } else
    if (i___0 == seqlen) {
      _L: /* CIL Label */ 
      tmp___35 = (char )'\000';
      ss[l] = tmp___35;
      s___0[l] = tmp___35;
      l = 0;
      l1 = 0;
      if (dostruc) {
        fprintf(outf, "%s\n", s___0);
        if (numline) {
          fprintf(outf, "         ");
        }
        j = 0;
        while (j < tab) {
          fputc(' ', outf);
          j ++;
        }
        if (i___0 == seqlen) {
          fprintf(outf, "%s%s\n", ss, endstr);
        } else {
          fprintf(outf, "%s\n", ss);
        }
      } else
      if (i___0 == seqlen) {
        fprintf(outf, "%s%s\n", s___0, endstr);
      } else {
        fprintf(outf, "%s\n", s___0);
      }
      lines ++;
      ibase = i___0 + 1;
    }
  }
  return (lines);
}
}
int ReadMultipleRseqs(char *seqfile , int fformat , char ***ret_rseqs , SQINFO **ret_sqinfo ,
                      int *ret_num ) 
{ 
  SQINFO *sqinfo ;
  SQFILE *dbfp ;
  char **rseqs ;
  int numalloced ;
  int num ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  num = 0;
  numalloced = 16;
  tmp = sre_malloc((char *)"sqio.c", 1732, (unsigned long )numalloced * sizeof(char *));
  rseqs = (char **)tmp;
  tmp___0 = sre_malloc((char *)"sqio.c", 1733, (unsigned long )numalloced * sizeof(SQINFO ));
  sqinfo = (SQINFO *)tmp___0;
  dbfp = SeqfileOpen(seqfile, fformat, (char *)((void *)0));
  if ((unsigned long )dbfp == (unsigned long )((void *)0)) {
    return (0);
  }
  while (1) {
    tmp___3 = ReadSeq(dbfp, dbfp->format, rseqs + num, sqinfo + num);
    if (! tmp___3) {
      break;
    }
    num ++;
    if (num == numalloced) {
      numalloced += 16;
      tmp___1 = sre_realloc((char *)"sqio.c", 1742, (void *)rseqs, (unsigned long )numalloced * sizeof(char *));
      rseqs = (char **)tmp___1;
      tmp___2 = sre_realloc((char *)"sqio.c", 1743, (void *)sqinfo, (unsigned long )numalloced * sizeof(SQINFO ));
      sqinfo = (SQINFO *)tmp___2;
    }
  }
  SeqfileClose(dbfp);
  *ret_rseqs = rseqs;
  *ret_sqinfo = sqinfo;
  *ret_num = num;
  return (1);
}
}
int String2SeqfileFormat(char *s___0 ) 
{ 
  char *s2 ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  code = 0;
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return (0);
  }
  s2 = sre_strdup(s___0, -1);
  s2upper(s2);
  tmp___17 = strcmp((char const   *)s2, "FASTA");
  if (tmp___17 == 0) {
    code = 7;
  } else {
    tmp___16 = strcmp((char const   *)s2, "GENBANK");
    if (tmp___16 == 0) {
      code = 2;
    } else {
      tmp___15 = strcmp((char const   *)s2, "EMBL");
      if (tmp___15 == 0) {
        code = 4;
      } else {
        tmp___14 = strcmp((char const   *)s2, "GCG");
        if (tmp___14 == 0) {
          code = 5;
        } else {
          tmp___13 = strcmp((char const   *)s2, "GCGDATA");
          if (tmp___13 == 0) {
            code = 16;
          } else {
            tmp___12 = strcmp((char const   *)s2, "RAW");
            if (tmp___12 == 0) {
              code = 13;
            } else {
              tmp___11 = strcmp((char const   *)s2, "IG");
              if (tmp___11 == 0) {
                code = 1;
              } else {
                tmp___10 = strcmp((char const   *)s2, "STRIDER");
                if (tmp___10 == 0) {
                  code = 6;
                } else {
                  tmp___9 = strcmp((char const   *)s2, "IDRAW");
                  if (tmp___9 == 0) {
                    code = 9;
                  } else {
                    tmp___8 = strcmp((char const   *)s2, "ZUKER");
                    if (tmp___8 == 0) {
                      code = 8;
                    } else {
                      tmp___7 = strcmp((char const   *)s2, "PIR");
                      if (tmp___7 == 0) {
                        code = 12;
                      } else {
                        tmp___6 = strcmp((char const   *)s2, "SQUID");
                        if (tmp___6 == 0) {
                          code = 14;
                        } else {
                          tmp___5 = strcmp((char const   *)s2, "STOCKHOLM");
                          if (tmp___5 == 0) {
                            code = 101;
                          } else {
                            tmp___4 = strcmp((char const   *)s2, "SELEX");
                            if (tmp___4 == 0) {
                              code = 102;
                            } else {
                              tmp___3 = strcmp((char const   *)s2, "MSF");
                              if (tmp___3 == 0) {
                                code = 103;
                              } else {
                                tmp___2 = strcmp((char const   *)s2, "CLUSTAL");
                                if (tmp___2 == 0) {
                                  code = 104;
                                } else {
                                  tmp___1 = strcmp((char const   *)s2, "A2M");
                                  if (tmp___1 == 0) {
                                    code = 105;
                                  } else {
                                    tmp___0 = strcmp((char const   *)s2, "PHYLIP");
                                    if (tmp___0 == 0) {
                                      code = 106;
                                    } else {
                                      tmp = strcmp((char const   *)s2, "EPS");
                                      if (tmp == 0) {
                                        code = 107;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  free((void *)s2);
  return (code);
}
}
char *SeqfileFormat2String(int code ) 
{ 


  {
  switch (code) {
  case 0: 
  return ((char *)"unknown");
  case 7: 
  return ((char *)"FASTA");
  case 2: 
  return ((char *)"Genbank");
  case 4: 
  return ((char *)"EMBL");
  case 5: 
  return ((char *)"GCG");
  case 16: 
  return ((char *)"GCG data library");
  case 13: 
  return ((char *)"raw");
  case 1: 
  return ((char *)"Intelligenetics");
  case 6: 
  return ((char *)"MacStrider");
  case 9: 
  return ((char *)"Idraw Postscript");
  case 8: 
  return ((char *)"Zuker");
  case 12: 
  return ((char *)"PIR");
  case 14: 
  return ((char *)"SQUID");
  case 101: 
  return ((char *)"Stockholm");
  case 102: 
  return ((char *)"SELEX");
  case 103: 
  return ((char *)"MSF");
  case 104: 
  return ((char *)"Clustal");
  case 105: 
  return ((char *)"a2m");
  case 106: 
  return ((char *)"Phylip");
  case 107: 
  return ((char *)"EPS");
  default: 
  Die((char *)"Bad code passed to MSAFormat2String()");
  }
  return ((char *)((void *)0));
}
}
SQINFO *MSAToSqinfo(MSA *msa ) 
{ 
  int idx ;
  SQINFO *sqinfo ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  tmp = sre_malloc((char *)"sqio.c", 1857, sizeof(SQINFO ) * (unsigned long )msa->nseq);
  sqinfo = (SQINFO *)tmp;
  idx = 0;
  while (idx < msa->nseq) {
    (sqinfo + idx)->flags = 0;
    SetSeqinfoString(sqinfo + idx, *(msa->sqname + idx), 1);
    tmp___0 = MSAGetSeqAccession(msa, idx);
    SetSeqinfoString(sqinfo + idx, tmp___0, 1 << 2);
    tmp___1 = MSAGetSeqDescription(msa, idx);
    SetSeqinfoString(sqinfo + idx, tmp___1, 1 << 3);
    if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
      if ((unsigned long )*(msa->ss + idx) != (unsigned long )((void *)0)) {
        MakeDealignedString(*(msa->aseq + idx), msa->alen, *(msa->ss + idx), & (sqinfo + idx)->ss);
        (sqinfo + idx)->flags |= 1 << 9;
      }
    }
    if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
      if ((unsigned long )*(msa->sa + idx) != (unsigned long )((void *)0)) {
        MakeDealignedString(*(msa->aseq + idx), msa->alen, *(msa->sa + idx), & (sqinfo + idx)->sa);
        (sqinfo + idx)->flags |= 1 << 10;
      }
    }
    (sqinfo + idx)->len = DealignedLength(*(msa->aseq + idx));
    (sqinfo + idx)->flags |= 1 << 6;
    idx ++;
  }
  return (sqinfo);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Lew68V0C.i","-O3")
void SqdBanner(FILE *fp , char *banner___1 ) ;
void SqdBanner(FILE *fp , char *banner___1 ) 
{ 


  {
  fprintf(fp, "%s\n", banner___1);
  fprintf(fp, "SQUID %s (%s)\n", "1.9g", "January 2003");
  fprintf(fp, "%s\n", "Copyright (C) 1992-2003 HHMI/Washington University School of Medicine");
  fprintf(fp, "%s\n", "Freely distributed under the GNU General Public License (GPL)");
  fprintf(fp, "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-0bIHj4NJ.i","-O3")
int sre_tolower(int c ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = isupper(c);
  if (tmp___0) {
    tmp = tolower(c);
    return (tmp);
  } else {
    return (c);
  }
}
}
int sre_toupper(int c ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = islower(c);
  if (tmp___0) {
    tmp = toupper(c);
    return (tmp);
  } else {
    return (c);
  }
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-MkL0Qmcl.i","-O3")
void WeightedLinefit(float *x , float *y___0 , float *var , int N , float *ret_m ,
                     float *ret_b ) ;
void FMX2Free(float **mx ) ;
double **DMX2Alloc(int rows , int cols ) ;
void DMX2Free(double **mx ) ;
void FMX2Multiply(float **A , float **B , float **C , int m , int p , int n ) ;
int Linefit(float *x , float *y___0 , int N , float *ret_a , float *ret_b , float *ret_r ) 
{ 
  float xavg ;
  float yavg ;
  float sxx ;
  float syy ;
  float sxy ;
  int i___0 ;
  double tmp ;
  double tmp___0 ;

  {
  yavg = (float )0.0;
  xavg = yavg;
  i___0 = 0;
  while (i___0 < N) {
    xavg += *(x + i___0);
    yavg += *(y___0 + i___0);
    i___0 ++;
  }
  xavg /= (float )N;
  yavg /= (float )N;
  sxy = (float )0.0;
  syy = sxy;
  sxx = syy;
  i___0 = 0;
  while (i___0 < N) {
    sxx += (*(x + i___0) - xavg) * (*(x + i___0) - xavg);
    syy += (*(y___0 + i___0) - yavg) * (*(y___0 + i___0) - xavg);
    sxy += (*(x + i___0) - xavg) * (*(y___0 + i___0) - yavg);
    i___0 ++;
  }
  *ret_b = sxy / sxx;
  *ret_a = yavg - xavg * *ret_b;
  tmp = sqrt((double )sxx);
  tmp___0 = sqrt((double )syy);
  *ret_r = (float )((double )sxy / (tmp * tmp___0));
  return (1);
}
}
void WeightedLinefit(float *x , float *y___0 , float *var , int N , float *ret_m ,
                     float *ret_b ) 
{ 
  int i___0 ;
  double s___0 ;
  double sx ;
  double sy ;
  double sxx ;
  double sxy ;
  double delta ;
  double m ;
  double b ;

  {
  sxy = 0.;
  sxx = sxy;
  sy = sxx;
  sx = sy;
  s___0 = sx;
  i___0 = 0;
  while (i___0 < N) {
    s___0 += 1. / (double )*(var + i___0);
    sx += (double )(*(x + i___0) / *(var + i___0));
    sy += (double )(*(y___0 + i___0) / *(var + i___0));
    sxx += (double )((*(x + i___0) * *(x + i___0)) / *(var + i___0));
    sxy += (double )((*(x + i___0) * *(y___0 + i___0)) / *(var + i___0));
    i___0 ++;
  }
  delta = s___0 * sxx - sx * sx;
  b = (sxx * sy - sx * sxy) / delta;
  m = (s___0 * sxy - sx * sy) / delta;
  *ret_m = (float )m;
  *ret_b = (float )b;
  return;
}
}
static double cof[11]  = 
  {      4.694580336184385e+04,      - 1.560605207784446e+05,      2.065049568014106e+05,      - 1.388934775095388e+05, 
        5.031796415085709e+04,      - 9.601592329182778e+03,      8.785855930895250e+02,      - 3.155153906098611e+01, 
        2.908143421162229e-01,      - 2.319827630494973e-04,      1.251639670050933e-10};
double Gammln(double x ) 
{ 
  int i___0 ;
  double xx ;
  double tx ;
  double tmp ;
  double value ;
  double tmp___0 ;

  {
  if (x <= 0.0) {
    return (999999.);
  }
  xx = x - 1.0;
  tmp = xx + 11.0;
  tx = tmp;
  value = 1.0;
  i___0 = 10;
  while (i___0 >= 0) {
    value += cof[i___0] / tmp;
    tmp -= 1.0;
    i___0 --;
  }
  value = log(value);
  tx += 0.5;
  tmp___0 = log(tx);
  value += (0.918938533 + (xx + 0.5) * tmp___0) - tx;
  return (value);
}
}
float **FMX2Alloc(int rows , int cols ) 
{ 
  float **mx ;
  int r ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = sre_malloc((char *)"sre_math.c", 172, sizeof(float *) * (unsigned long )rows);
  mx = (float **)tmp;
  tmp___0 = sre_malloc((char *)"sre_math.c", 173, (sizeof(float ) * (unsigned long )rows) * (unsigned long )cols);
  *(mx + 0) = (float *)tmp___0;
  r = 1;
  while (r < rows) {
    *(mx + r) = *(mx + 0) + r * cols;
    r ++;
  }
  return (mx);
}
}
void FMX2Free(float **mx ) 
{ 


  {
  free((void *)*(mx + 0));
  free((void *)mx);
  return;
}
}
double **DMX2Alloc(int rows , int cols ) 
{ 
  double **mx ;
  int r ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = sre_malloc((char *)"sre_math.c", 190, sizeof(double *) * (unsigned long )rows);
  mx = (double **)tmp;
  tmp___0 = sre_malloc((char *)"sre_math.c", 191, (sizeof(double ) * (unsigned long )rows) * (unsigned long )cols);
  *(mx + 0) = (double *)tmp___0;
  r = 1;
  while (r < rows) {
    *(mx + r) = *(mx + 0) + r * cols;
    r ++;
  }
  return (mx);
}
}
void DMX2Free(double **mx ) 
{ 


  {
  free((void *)*(mx + 0));
  free((void *)mx);
  return;
}
}
void FMX2Multiply(float **A , float **B , float **C , int m , int p , int n ) 
{ 
  int i___0 ;
  int j ;
  int k ;

  {
  i___0 = 0;
  while (i___0 < m) {
    j = 0;
    while (j < n) {
      *(*(C + i___0) + j) = (float )0.;
      k = 0;
      while (k < p) {
        *(*(C + i___0) + j) += *(*(A + i___0) + p) * *(*(B + p) + j);
        k ++;
      }
      j ++;
    }
    i___0 ++;
  }
  return;
}
}
double IncompleteGamma(double a___0 , double x ) 
{ 
  int iter ;
  double oldp ;
  double nu0 ;
  double nu1 ;
  double de0 ;
  double de1 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double p ;
  double val ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;

  {
  if (a___0 <= 0.) {
    Die((char *)"IncompleteGamma(): a must be > 0");
  }
  if (x < 0.) {
    Die((char *)"IncompleteGamma(): x must be >= 0");
  }
  if (x > a___0 + (double )1) {
    nu0 = 0.;
    de0 = 1.;
    nu1 = 1.;
    de1 = x;
    oldp = nu1;
    iter = 1;
    while (iter < 100) {
      nu0 = nu1 + ((double )iter - a___0) * nu0;
      de0 = de1 + ((double )iter - a___0) * de0;
      nu1 = x * nu0 + (double )iter * nu1;
      de1 = x * de0 + (double )iter * de1;
      if (de1 != 0.) {
        nu0 /= de1;
        de0 /= de1;
        nu1 /= de1;
        de1 = 1.;
      }
      tmp___2 = fabs((nu1 - oldp) / nu1);
      if (tmp___2 < 1.e-7) {
        tmp = log(x);
        tmp___0 = Gammln(a___0);
        tmp___1 = exp((a___0 * tmp - x) - tmp___0);
        return (nu1 * tmp___1);
      }
      oldp = nu1;
      iter ++;
    }
    Die((char *)"IncompleteGamma(): failed to converge using continued fraction approx");
  } else {
    val = 1. / a___0;
    p = val;
    iter = 1;
    while (iter < 10000) {
      val *= x / (a___0 + (double )iter);
      p += val;
      tmp___6 = fabs(val / p);
      if (tmp___6 < 1.e-7) {
        tmp___3 = log(x);
        tmp___4 = Gammln(a___0);
        tmp___5 = exp((a___0 * tmp___3 - x) - tmp___4);
        return (1. - p * tmp___5);
      }
      iter ++;
    }
    Die((char *)"IncompleteGamma(): failed to converge using series approx");
  }
  return (0.);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-d4dinMeb.i","-O3")
double sre_random_positive(void) ;
double ExponentialRandom(void) ;
int DChoose(double *p , int N ) ;
static int sre_randseed  =    42;
static long rnd1  ;
static long rnd2  ;
static long rnd  ;
static long tbl[64]  ;
double sre_random(void) 
{ 
  long x ;
  long y___0 ;
  int i___0 ;
  long a1 ;
  long m1 ;
  long q1 ;
  long r1 ;
  long a2 ;
  long m2 ;
  long q2 ;
  long r2 ;

  {
  a1 = 40014L;
  m1 = 2147483563L;
  q1 = 53668L;
  r1 = 12211L;
  a2 = 40692L;
  m2 = 2147483399L;
  q2 = 52774L;
  r2 = 3791L;
  if (sre_randseed > 0) {
    rnd1 = (long )sre_randseed;
    rnd2 = (long )sre_randseed;
    i___0 = 0;
    while (i___0 < 64) {
      x = a1 * (rnd1 % q1);
      y___0 = r1 * (rnd1 / q1);
      rnd1 = x - y___0;
      if (rnd1 < 0L) {
        rnd1 += m1;
      }
      x = a2 * (rnd2 % q2);
      y___0 = r2 * (rnd2 / q2);
      rnd2 = x - y___0;
      if (rnd2 < 0L) {
        rnd2 += m2;
      }
      tbl[i___0] = rnd1 - rnd2;
      if (tbl[i___0] < 0L) {
        tbl[i___0] += m1;
      }
      i___0 ++;
    }
    sre_randseed = 0;
  }
  x = a1 * (rnd1 % q1);
  y___0 = r1 * (rnd1 / q1);
  rnd1 = x - y___0;
  if (rnd1 < 0L) {
    rnd1 += m1;
  }
  x = a2 * (rnd2 % q2);
  y___0 = r2 * (rnd2 / q2);
  rnd2 = x - y___0;
  if (rnd2 < 0L) {
    rnd2 += m2;
  }
  i___0 = (int )(((double )rnd / (double )m1) * 64.);
  rnd = tbl[i___0];
  tbl[i___0] = rnd1 - rnd2;
  if (tbl[i___0] < 0L) {
    tbl[i___0] += m1;
  }
  return ((double )rnd / (double )m1);
}
}
void sre_srandom(int seed ) 
{ 


  {
  if (seed < 0) {
    seed = -1 * seed;
  }
  if (seed == 0) {
    seed = 42;
  }
  sre_randseed = seed;
  return;
}
}
double sre_random_positive(void) 
{ 
  double x ;

  {
  while (1) {
    x = sre_random();
    if (! (x == 0.0)) {
      break;
    }
  }
  return (x);
}
}
double ExponentialRandom(void) 
{ 
  double x ;
  double tmp ;

  {
  while (1) {
    x = sre_random();
    if (! (x == 0.0)) {
      break;
    }
  }
  tmp = log(x);
  return (- tmp);
}
}
static double a[32]  = 
  {      0.0,      3.917609E-2,      7.841241E-2,      0.11777, 
        0.1573107,      0.1970991,      0.2372021,      0.2776904, 
        0.3186394,      0.36013,      0.4022501,      0.4450965, 
        0.4887764,      0.5334097,      0.5791322,      0.626099, 
        0.6744898,      0.7245144,      0.7764218,      0.8305109, 
        0.8871466,      0.9467818,      1.00999,      1.077516, 
        1.150349,      1.229859,      1.318011,      1.417797, 
        1.534121,      1.67594,      1.862732,      2.153875};
static double d[31]  = 
  {      0.0,      0.0,      0.0,      0.0, 
        0.0,      0.2636843,      0.2425085,      0.2255674, 
        0.2116342,      0.1999243,      0.1899108,      0.1812252, 
        0.1736014,      0.1668419,      0.1607967,      0.1553497, 
        0.1504094,      0.1459026,      0.14177,      0.1379632, 
        0.1344418,      0.1311722,      0.128126,      0.1252791, 
        0.1226109,      0.1201036,      0.1177417,      0.1155119, 
        0.1134023,      0.1114027,      0.1095039};
static double t[31]  = 
  {      7.673828E-4,      2.30687E-3,      3.860618E-3,      5.438454E-3, 
        7.0507E-3,      8.708396E-3,      1.042357E-2,      1.220953E-2, 
        1.408125E-2,      1.605579E-2,      1.81529E-2,      2.039573E-2, 
        2.281177E-2,      2.543407E-2,      2.830296E-2,      3.146822E-2, 
        3.499233E-2,      3.895483E-2,      4.345878E-2,      4.864035E-2, 
        5.468334E-2,      6.184222E-2,      7.047983E-2,      8.113195E-2, 
        9.462444E-2,      0.1123001,      0.136498,      0.1716886, 
        0.2276241,      0.330498,      0.5847031};
static double h[31]  = 
  {      3.920617E-2,      3.932705E-2,      3.951E-2,      3.975703E-2, 
        4.007093E-2,      4.045533E-2,      4.091481E-2,      4.145507E-2, 
        4.208311E-2,      4.280748E-2,      4.363863E-2,      4.458932E-2, 
        4.567523E-2,      4.691571E-2,      4.833487E-2,      4.996298E-2, 
        5.183859E-2,      5.401138E-2,      5.654656E-2,      5.95313E-2, 
        6.308489E-2,      6.737503E-2,      7.264544E-2,      7.926471E-2, 
        8.781922E-2,      9.930398E-2,      0.11556,      0.1404344, 
        0.1836142,      0.2790016,      0.7010474};
static long i  ;
static double snorm  ;
static double u  ;
static double s  ;
static double ustar  ;
static double aa  ;
static double w  ;
static double y  ;
static double tt  ;
double Gaussrandom(double mean , double stddev ) 
{ 


  {
  u = sre_random();
  s = 0.0;
  if (u > 0.5) {
    s = 1.0;
  }
  u += u - s;
  u = 32.0 * u;
  i = (long )u;
  if (i == 32L) {
    i = 31L;
  }
  if (i == 0L) {
    goto S100;
  }
  ustar = u - (double )i;
  aa = *((a + i) - 1);
  S40: 
  if (ustar <= *((t + i) - 1)) {
    goto S60;
  }
  w = (ustar - *((t + i) - 1)) * *((h + i) - 1);
  S50: 
  y = aa + w;
  snorm = y;
  if (s == 1.0) {
    snorm = - y;
  }
  return (stddev * snorm + mean);
  S60: 
  u = sre_random();
  w = u * (*(a + i) - aa);
  tt = (0.5 * w + aa) * w;
  goto S80;
  S70: 
  tt = u;
  ustar = sre_random();
  S80: 
  if (ustar > tt) {
    goto S50;
  }
  u = sre_random();
  if (ustar >= u) {
    goto S70;
  }
  ustar = sre_random();
  goto S40;
  S100: 
  i = 6L;
  aa = *(a + 31);
  goto S120;
  S110: 
  aa += *((d + i) - 1);
  i ++;
  S120: 
  u += u;
  if (u < 1.0) {
    goto S110;
  }
  u -= 1.0;
  S140: 
  w = u * *((d + i) - 1);
  tt = (0.5 * w + aa) * w;
  goto S160;
  S150: 
  tt = u;
  S160: 
  ustar = sre_random();
  if (ustar > tt) {
    goto S50;
  }
  u = sre_random();
  if (ustar >= u) {
    goto S150;
  }
  u = sre_random();
  goto S140;
}
}
int DChoose(double *p , int N ) 
{ 
  double roll ;
  double sum ;
  int i___0 ;
  double tmp ;

  {
  roll = sre_random();
  sum = 0.0;
  i___0 = 0;
  while (i___0 < N) {
    sum += *(p + i___0);
    if (roll < sum) {
      return (i___0);
    }
    i___0 ++;
  }
  tmp = sre_random();
  return ((int )(tmp * (double )N));
}
}
int FChoose(float *p , int N ) 
{ 
  float roll ;
  float sum ;
  int i___0 ;
  double tmp ;
  double tmp___0 ;

  {
  tmp = sre_random();
  roll = (float )tmp;
  sum = (float )0.0;
  i___0 = 0;
  while (i___0 < N) {
    sum += *(p + i___0);
    if (roll < sum) {
      return (i___0);
    }
    i___0 ++;
  }
  tmp___0 = sre_random();
  return ((int )(tmp___0 * (double )N));
}
}
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-w34ieWo4.i","-O3")
int Strinsert(char *s1 , char c , int pos ) ;
int Strdelete(char *s1 , int pos ) ;
char *sre_strncpy(char *s1 , char *s2 , int n ) ;
__inline static void *__inline_memcpy_chk(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
char *Strdup(char *s___0 ) 
{ 
  char *new ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp = strlen((char const   *)s___0);
  tmp___0 = malloc(tmp + 1UL);
  new = (char *)tmp___0;
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp___2 = __builtin_object_size((void *)new, 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)new, 1);
    __builtin___strcpy_chk(new, (char const   *)s___0, tmp___1);
  } else {
    __inline_strcpy_chk(new, (char const   *)s___0);
  }
  return (new);
}
}
void StringChop(char *s___0 ) 
{ 
  int i___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen((char const   *)s___0);
  i___0 = (int )(tmp - 1UL);
  while (1) {
    if (i___0 >= 0) {
      tmp___0 = isspace((int )*(s___0 + i___0));
      if (! tmp___0) {
        break;
      }
    } else {
      break;
    }
    i___0 --;
  }
  *(s___0 + (i___0 + 1)) = (char )'\000';
  return;
}
}
int Strinsert(char *s1 , char c , int pos ) 
{ 
  char oldc ;
  char *s___0 ;

  {
  s___0 = s1 + pos;
  while (c) {
    oldc = *s___0;
    *s___0 = c;
    c = oldc;
    s___0 ++;
  }
  *s___0 = (char )'\000';
  return (1);
}
}
int Strdelete(char *s1 , int pos ) 
{ 
  char *s___0 ;

  {
  s___0 = s1 + pos;
  while (*s___0) {
    *s___0 = *(s___0 + 1);
    s___0 ++;
  }
  return (1);
}
}
void s2lower(char *s___0 ) 
{ 
  int tmp ;

  {
  while ((int )*s___0 != 0) {
    tmp = sre_tolower((int )*s___0);
    *s___0 = (char )tmp;
    s___0 ++;
  }
  return;
}
}
void s2upper(char *s___0 ) 
{ 
  int tmp ;

  {
  while ((int )*s___0 != 0) {
    tmp = sre_toupper((int )*s___0);
    *s___0 = (char )tmp;
    s___0 ++;
  }
  return;
}
}
void *sre_malloc(char *file , int line , size_t size ) 
{ 
  void *ptr ;

  {
  ptr = malloc(size);
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    Die((char *)"malloc of %ld bytes failed: file %s line %d", size, file, line);
  }
  return (ptr);
}
}
void *sre_realloc(char *file , int line , void *p , size_t size ) 
{ 
  void *ptr ;

  {
  ptr = realloc(p, size);
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    Die((char *)"realloc of %ld bytes failed: file %s line %d", size, file, line);
  }
  return (ptr);
}
}
void Free2DArray(void **p , int dim1 ) 
{ 
  int i___0 ;

  {
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    i___0 = 0;
    while (i___0 < dim1) {
      if ((unsigned long )*(p + i___0) != (unsigned long )((void *)0)) {
        free(*(p + i___0));
      }
      i___0 ++;
    }
    free((void *)p);
  }
  return;
}
}
void Free3DArray(void ***p , int dim1 , int dim2 ) 
{ 
  int i___0 ;
  int j ;

  {
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    i___0 = 0;
    while (i___0 < dim1) {
      if ((unsigned long )*(p + i___0) != (unsigned long )((void *)0)) {
        j = 0;
        while (j < dim2) {
          if ((unsigned long )*(*(p + i___0) + j) != (unsigned long )((void *)0)) {
            free(*(*(p + i___0) + j));
          }
          j ++;
        }
        free((void *)*(p + i___0));
      }
      i___0 ++;
    }
    free((void *)p);
  }
  return;
}
}
char *RandomSequence(char *alphabet , float *p , int n , int len ) 
{ 
  char *s___0 ;
  int x ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = sre_malloc((char *)"sre_string.c", 199, sizeof(char ) * (unsigned long )(len + 1));
  s___0 = (char *)tmp;
  x = 0;
  while (x < len) {
    tmp___0 = FChoose(p, n);
    *(s___0 + x) = *(alphabet + tmp___0);
    x ++;
  }
  *(s___0 + x) = (char )'\000';
  return (s___0);
}
}
char *sre_fgets(char **buf , int *n , FILE *fp ) 
{ 
  char *s___0 ;
  int len ;
  int pos ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  if (*n == 0) {
    tmp = sre_malloc((char *)"sre_string.c", 253, sizeof(char ) * 128UL);
    *buf = (char *)tmp;
    *n = 128;
  }
  tmp___0 = fgets(*buf, *n, fp);
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp___1 = feof(fp);
  if (tmp___1) {
    return (*buf);
  }
  tmp___2 = strlen((char const   *)*buf);
  len = (int )tmp___2;
  if ((int )*(*buf + (len - 1)) == 10) {
    return (*buf);
  }
  pos = *n - 1;
  while (1) {
    *n += 128;
    tmp___3 = sre_realloc((char *)"sre_string.c", 283, (void *)*buf, sizeof(char ) * (unsigned long )*n);
    *buf = (char *)tmp___3;
    s___0 = *buf + pos;
    tmp___4 = fgets(s___0, 129, fp);
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
      return (*buf);
    }
    tmp___5 = strlen((char const   *)s___0);
    len = (int )tmp___5;
    if ((int )*(s___0 + (len - 1)) == 10) {
      return (*buf);
    }
    pos += 128;
  }
}
}
int sre_strcat(char **dest , int ldest , char *src , int lsrc ) 
{ 
  int len1 ;
  int len2 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  if (ldest < 0) {
    if ((unsigned long )*dest == (unsigned long )((void *)0)) {
      len1 = 0;
    } else {
      tmp = strlen((char const   *)*dest);
      len1 = (int )tmp;
    }
  } else {
    len1 = ldest;
  }
  if (lsrc < 0) {
    if ((unsigned long )src == (unsigned long )((void *)0)) {
      len2 = 0;
    } else {
      tmp___0 = strlen((char const   *)src);
      len2 = (int )tmp___0;
    }
  } else {
    len2 = lsrc;
  }
  if (len2 == 0) {
    return (len1);
  }
  if ((unsigned long )*dest == (unsigned long )((void *)0)) {
    tmp___1 = sre_malloc((char *)"sre_string.c", 344, sizeof(char ) * (unsigned long )(len2 + 1));
    *dest = (char *)tmp___1;
  } else {
    tmp___2 = sre_realloc((char *)"sre_string.c", 345, (void *)*dest, sizeof(char ) * (unsigned long )((len1 + len2) + 1));
    *dest = (char *)tmp___2;
  }
  tmp___4 = __builtin_object_size((void *)(*dest + len1), 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___3 = __builtin_object_size((void *)(*dest + len1), 0);
    __builtin___memcpy_chk((void *)(*dest + len1), (void const   *)src, (unsigned long )(len2 + 1),
                           tmp___3);
  } else {
    __inline_memcpy_chk((void *)(*dest + len1), (void const   *)src, (size_t )(len2 + 1));
  }
  return (len1 + len2);
}
}
char *sre_strtok(char **s___0 , char *delim , int *len ) 
{ 
  char *begin ;
  char *end ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  begin = *s___0;
  tmp = strspn((char const   *)begin, (char const   *)delim);
  begin += tmp;
  if (! *begin) {
    return ((char *)((void *)0));
  }
  tmp___0 = strcspn((char const   *)begin, (char const   *)delim);
  n = (int )tmp___0;
  end = begin + n;
  if ((int )*end == 0) {
    *s___0 = end;
  } else {
    *end = (char )'\000';
    *s___0 = end + 1;
  }
  if ((unsigned long )len != (unsigned long )((void *)0)) {
    *len = n;
  }
  return (begin);
}
}
char *sre_strdup(char *s___0 , int n ) 
{ 
  char *new ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  if (n < 0) {
    tmp = strlen((char const   *)s___0);
    n = (int )tmp;
  }
  tmp___0 = sre_malloc((char *)"sre_string.c", 442, sizeof(char ) * (unsigned long )(n + 1));
  new = (char *)tmp___0;
  tmp___2 = __builtin_object_size((void *)new, 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)new, 1);
    __builtin___strcpy_chk(new, (char const   *)s___0, tmp___1);
  } else {
    __inline_strcpy_chk(new, (char const   *)s___0);
  }
  return (new);
}
}
char *sre_strncpy(char *s1 , char *s2 , int n ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size((void *)s1, 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)s1, 1);
    __builtin___strncpy_chk(s1, (char const   *)s2, (unsigned long )n, tmp);
  } else {
    __inline_strncpy_chk(s1, (char const   *)s2, (size_t )n);
  }
  *(s1 + n) = (char )'\000';
  return (s1);
}
}
int IsBlankline(char *s___0 ) 
{ 
  int tmp ;

  {
  while ((int )*s___0 != 0) {
    tmp = isspace((int )*s___0);
    if (! tmp) {
      return (0);
    }
    s___0 ++;
  }
  return (1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-4w43j65L.i","-O3")
extern long ftell(FILE * ) ;
extern  __attribute__((__noreturn__)) void abort(void) ;
extern unsigned long strtoul(char const   * , char ** , int  ) ;
extern int system(char const   * )  __asm__("_system")  ;
int SSIGetSubseqOffset(SSIFILE *sfp , char *key , int requested_start , int *ret_fh ,
                       SSIOFFSET *record_offset , SSIOFFSET *data_offset , int *ret_actual_start ) ;
int SSIFileInfo(SSIFILE *sfp , int fh , char **ret_filename , int *ret_format ) ;
SSIINDEX *SSICreateIndex(int mode ) ;
int SSIAddFileToIndex(SSIINDEX *g , char *filename , int fmt , int *ret_fh ) ;
int SSISetFileForSubseq(SSIINDEX *g , int fh , int bpl , int rpl ) ;
int SSIAddPrimaryKeyToIndex(SSIINDEX *g , char *key , int fh , SSIOFFSET *r_off ,
                            SSIOFFSET *d_off , int L ) ;
int SSIAddSecondaryKeyToIndex(SSIINDEX *g , char *key , char *pkey ) ;
int SSIWriteIndex(char *file , SSIINDEX *g ) ;
void SSIFreeIndex(SSIINDEX *g ) ;
char *SSIErrorString(int n ) ;
void SSIForceExternalSort(SSIINDEX *g ) ;
sqd_uint64 sre_ntoh64(sqd_uint64 net_int64 ) ;
sqd_uint64 sre_hton64(sqd_uint64 host_int64 ) ;
static sqd_uint32 v20magic___0  =    4092848561U;
static sqd_uint32 v20swap___0  =    2984899571U;
static int read_i16(FILE *fp , sqd_uint16 *ret_result ) ;
static int read_i32(FILE *fp , sqd_uint32 *ret_result ) ;
static int read_i64(FILE *fp , sqd_uint64 *ret_result ) ;
static int read_offset(FILE *fp , char mode , SSIOFFSET *ret_offset ) ;
static int write_i16(FILE *fp , sqd_uint16 n ) ;
static int write_i32(FILE *fp , sqd_uint32 n ) ;
static int write_i64(FILE *fp , sqd_uint64 n ) ;
static int write_offset(FILE *fp , SSIOFFSET *offset ) ;
static int binary_search(SSIFILE *sfp , char *key , int klen , SSIOFFSET *base , sqd_uint32 recsize ,
                         sqd_uint32 maxidx ) ;
static int indexfile_position(SSIFILE *sfp , SSIOFFSET *base , sqd_uint32 len , sqd_uint32 n ) ;
static void clear_ssifile(SSIFILE *sfp ) ;
static sqd_uint64 current_index_size(SSIINDEX *g ) ;
static int activate_external_sort(SSIINDEX *g ) ;
static int load_indexfile(SSIFILE *sfp ) ;
static int parse_pkey_info(char *buf , char mode , struct ssipkey_s *pkey ) ;
static int parse_skey_info(char *buf , struct ssiskey_s *skey ) ;
int SSIOpen(char *filename , SSIFILE **ret_sfp ) 
{ 
  SSIFILE *sfp ;
  int status ;
  void *tmp ;
  FILE *tmp___0 ;

  {
  sfp = (SSIFILE *)((void *)0);
  tmp = malloc(sizeof(SSIFILE ));
  sfp = (SSIFILE *)tmp;
  if ((unsigned long )sfp == (unsigned long )((void *)0)) {
    return (3);
  }
  tmp___0 = fopen((char const   *)filename, "rb");
  sfp->fp = tmp___0;
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    free((void *)sfp);
    return (4);
  }
  status = load_indexfile(sfp);
  *ret_sfp = sfp;
  return (status);
}
}
static int load_indexfile(SSIFILE *sfp ) 
{ 
  sqd_uint32 magic ;
  sqd_uint16 i___0 ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  void *tmp___14 ;
  sqd_uint32 *tmp___15 ;
  void *tmp___16 ;
  sqd_uint32 *tmp___17 ;
  void *tmp___18 ;
  sqd_uint32 *tmp___19 ;
  void *tmp___20 ;
  sqd_uint32 *tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  status = 6;
  sfp->filename = (char **)((void *)0);
  sfp->fileformat = (sqd_uint32 *)((void *)0);
  sfp->fileflags = (sqd_uint32 *)((void *)0);
  sfp->bpl = (sqd_uint32 *)((void *)0);
  sfp->rpl = (sqd_uint32 *)((void *)0);
  sfp->nfiles = (sqd_uint16 )0;
  tmp = read_i32(sfp->fp, & magic);
  if (! tmp) {
    status = 5;
    goto FAILURE;
  }
  if (magic != v20magic___0) {
    if (magic != v20swap___0) {
      status = 5;
      goto FAILURE;
    }
  }
  tmp___0 = read_i32(sfp->fp, & sfp->flags);
  if (! tmp___0) {
    goto FAILURE;
  }
  if (sfp->flags & (unsigned int )(1 << 1)) {
    status = 7;
    goto FAILURE;
  } else
  if (sfp->flags & 1U) {
    status = 7;
    goto FAILURE;
  }
  if (sfp->flags & (unsigned int )(1 << 1)) {
    sfp->imode = (char)1;
  } else {
    sfp->imode = (char)0;
  }
  if (sfp->flags & 1U) {
    sfp->smode = (char)1;
  } else {
    sfp->smode = (char)0;
  }
  tmp___1 = read_i16(sfp->fp, & sfp->nfiles);
  if (! tmp___1) {
    goto FAILURE;
  }
  tmp___2 = read_i32(sfp->fp, & sfp->nprimary);
  if (! tmp___2) {
    goto FAILURE;
  }
  tmp___3 = read_i32(sfp->fp, & sfp->nsecondary);
  if (! tmp___3) {
    goto FAILURE;
  }
  tmp___4 = read_i32(sfp->fp, & sfp->flen);
  if (! tmp___4) {
    goto FAILURE;
  }
  tmp___5 = read_i32(sfp->fp, & sfp->plen);
  if (! tmp___5) {
    goto FAILURE;
  }
  tmp___6 = read_i32(sfp->fp, & sfp->slen);
  if (! tmp___6) {
    goto FAILURE;
  }
  tmp___7 = read_i32(sfp->fp, & sfp->frecsize);
  if (! tmp___7) {
    goto FAILURE;
  }
  tmp___8 = read_i32(sfp->fp, & sfp->precsize);
  if (! tmp___8) {
    goto FAILURE;
  }
  tmp___9 = read_i32(sfp->fp, & sfp->srecsize);
  if (! tmp___9) {
    goto FAILURE;
  }
  tmp___10 = read_offset(sfp->fp, sfp->imode, & sfp->foffset);
  if (! tmp___10) {
    goto FAILURE;
  }
  tmp___11 = read_offset(sfp->fp, sfp->imode, & sfp->poffset);
  if (! tmp___11) {
    goto FAILURE;
  }
  tmp___12 = read_offset(sfp->fp, sfp->imode, & sfp->soffset);
  if (! tmp___12) {
    goto FAILURE;
  }
  if ((int )sfp->nfiles == 0) {
    goto FAILURE;
  }
  tmp___14 = malloc(sizeof(char *) * (unsigned long )sfp->nfiles);
  tmp___13 = (char **)tmp___14;
  sfp->filename = tmp___13;
  if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
    status = 3;
    goto FAILURE;
  }
  i___0 = (sqd_uint16 )0;
  while ((int )i___0 < (int )sfp->nfiles) {
    *(sfp->filename + i___0) = (char *)((void *)0);
    i___0 = (sqd_uint16 )((int )i___0 + 1);
  }
  tmp___16 = malloc(sizeof(sqd_uint32 ) * (unsigned long )sfp->nfiles);
  tmp___15 = (sqd_uint32 *)tmp___16;
  sfp->fileformat = tmp___15;
  if ((unsigned long )tmp___15 == (unsigned long )((void *)0)) {
    status = 3;
    goto FAILURE;
  }
  tmp___18 = malloc(sizeof(sqd_uint32 ) * (unsigned long )sfp->nfiles);
  tmp___17 = (sqd_uint32 *)tmp___18;
  sfp->fileflags = tmp___17;
  if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
    status = 3;
    goto FAILURE;
  }
  tmp___20 = malloc(sizeof(sqd_uint32 ) * (unsigned long )sfp->nfiles);
  tmp___19 = (sqd_uint32 *)tmp___20;
  sfp->bpl = tmp___19;
  if ((unsigned long )tmp___19 == (unsigned long )((void *)0)) {
    status = 3;
    goto FAILURE;
  }
  tmp___22 = malloc(sizeof(sqd_uint32 ) * (unsigned long )sfp->nfiles);
  tmp___21 = (sqd_uint32 *)tmp___22;
  sfp->rpl = tmp___21;
  if ((unsigned long )tmp___21 == (unsigned long )((void *)0)) {
    status = 3;
    goto FAILURE;
  }
  i___0 = (sqd_uint16 )0;
  while ((int )i___0 < (int )sfp->nfiles) {
    tmp___23 = indexfile_position(sfp, & sfp->foffset, sfp->frecsize, (sqd_uint32 )i___0);
    if (tmp___23 != 0) {
      goto FAILURE;
    }
    tmp___25 = malloc(sizeof(char ) * (unsigned long )sfp->flen);
    tmp___24 = (char *)tmp___25;
    *(sfp->filename + i___0) = tmp___24;
    if ((unsigned long )tmp___24 == (unsigned long )((void *)0)) {
      status = 3;
      goto FAILURE;
    }
    tmp___26 = fread((void *)*(sfp->filename + i___0), sizeof(char ), (size_t )sfp->flen,
                     sfp->fp);
    if (tmp___26 != (size_t )sfp->flen) {
      goto FAILURE;
    }
    tmp___27 = read_i32(sfp->fp, sfp->fileformat + i___0);
    if (! tmp___27) {
      goto FAILURE;
    }
    tmp___28 = read_i32(sfp->fp, sfp->fileflags + i___0);
    if (! tmp___28) {
      goto FAILURE;
    }
    tmp___29 = read_i32(sfp->fp, sfp->bpl + i___0);
    if (! tmp___29) {
      goto FAILURE;
    }
    tmp___30 = read_i32(sfp->fp, sfp->rpl + i___0);
    if (! tmp___30) {
      goto FAILURE;
    }
    i___0 = (sqd_uint16 )((int )i___0 + 1);
  }
  return (0);
  FAILURE: 
  SSIClose(sfp);
  return (status);
}
}
int SSIGetOffsetByName(SSIFILE *sfp , char *key , int *ret_fh , SSIOFFSET *ret_offset ) 
{ 
  int status ;
  sqd_uint16 fnum ;
  int tmp ;
  int tmp___0 ;
  char *pkey ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  status = binary_search(sfp, key, (int )sfp->plen, & sfp->poffset, sfp->precsize,
                         sfp->nprimary);
  if (status == 0) {
    tmp = read_i16(sfp->fp, & fnum);
    if (! tmp) {
      return (1);
    }
    *ret_fh = (int )fnum;
    tmp___0 = read_offset(sfp->fp, sfp->smode, ret_offset);
    if (! tmp___0) {
      return (1);
    }
    return (0);
  } else
  if (status == 2) {
    if (sfp->nsecondary > 0U) {
      status = binary_search(sfp, key, (int )sfp->slen, & sfp->soffset, sfp->srecsize,
                             sfp->nsecondary);
      if (status != 0) {
        return (status);
      }
      tmp___1 = malloc(sizeof(char ) * (unsigned long )sfp->plen);
      pkey = (char *)tmp___1;
      if ((unsigned long )pkey == (unsigned long )((void *)0)) {
        return (3);
      }
      tmp___2 = fread((void *)pkey, sizeof(char ), (size_t )sfp->plen, sfp->fp);
      if (tmp___2 != (size_t )sfp->plen) {
        return (1);
      }
      status = SSIGetOffsetByName(sfp, pkey, ret_fh, ret_offset);
      free((void *)pkey);
    }
    return (status);
  } else {
    return (status);
  }
}
}
int SSIGetOffsetByNumber(SSIFILE *sfp , int n , int *ret_fh , SSIOFFSET *ret_offset ) 
{ 
  sqd_uint16 fnum ;
  char *pkey ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((sqd_uint32 )n >= sfp->nprimary) {
    return (2);
  }
  tmp = indexfile_position(sfp, & sfp->poffset, sfp->precsize, (sqd_uint32 )n);
  if (tmp != 0) {
    return (8);
  }
  tmp___0 = malloc(sizeof(char ) * (unsigned long )sfp->plen);
  pkey = (char *)tmp___0;
  if ((unsigned long )pkey == (unsigned long )((void *)0)) {
    return (3);
  }
  tmp___1 = fread((void *)pkey, sizeof(char ), (size_t )sfp->plen, sfp->fp);
  if (tmp___1 != (size_t )sfp->plen) {
    return (1);
  }
  tmp___2 = read_i16(sfp->fp, & fnum);
  if (! tmp___2) {
    return (1);
  }
  tmp___3 = read_offset(sfp->fp, sfp->smode, ret_offset);
  if (! tmp___3) {
    return (1);
  }
  *ret_fh = (int )fnum;
  free((void *)pkey);
  return (0);
}
}
int SSIGetSubseqOffset(SSIFILE *sfp , char *key , int requested_start , int *ret_fh ,
                       SSIOFFSET *record_offset , SSIOFFSET *data_offset , int *ret_actual_start ) 
{ 
  int status ;
  sqd_uint32 len ;
  int r ;
  int b ;
  int i___0 ;
  int l ;
  int tmp ;
  int tmp___0 ;

  {
  status = SSIGetOffsetByName(sfp, key, ret_fh, record_offset);
  if (status != 0) {
    return (status);
  }
  if (! (*(sfp->fileflags + *ret_fh) & 1U)) {
    return (10);
  }
  tmp = read_offset(sfp->fp, sfp->smode, data_offset);
  if (! tmp) {
    return (1);
  }
  tmp___0 = read_i32(sfp->fp, & len);
  if (! tmp___0) {
    return (1);
  }
  r = (int )*(sfp->rpl + *ret_fh);
  b = (int )*(sfp->bpl + *ret_fh);
  i___0 = requested_start;
  l = (i___0 - 1) / r;
  if (r == 0) {
    return (10);
  } else
  if (b == 0) {
    return (10);
  }
  if (i___0 < 0) {
    return (11);
  } else
  if ((sqd_uint32 )i___0 > len) {
    return (11);
  }
  if (b == r + 1) {
    if ((int )sfp->smode == 0) {
      data_offset->mode = (char)0;
      data_offset->off.i32 = (data_offset->off.i32 + (sqd_uint32 )(l * b)) + (sqd_uint32 )((i___0 - 1) % r);
    } else
    if ((int )sfp->smode == 1) {
      data_offset->mode = (char)1;
      data_offset->off.i64 = (data_offset->off.i64 + (sqd_uint64 )(l * b)) + (sqd_uint64 )((i___0 - 1) % r);
    }
    *ret_actual_start = requested_start;
  } else {
    if ((int )sfp->smode == 0) {
      data_offset->mode = (char)0;
      data_offset->off.i32 += (sqd_uint32 )(l * b);
    } else
    if ((int )sfp->smode == 1) {
      data_offset->mode = (char)1;
      data_offset->off.i64 += (sqd_uint64 )(l * b);
    }
    *ret_actual_start = 1 + l * r;
  }
  return (0);
}
}
int SSISetFilePosition(FILE *fp , SSIOFFSET *offset ) 
{ 
  int tmp ;

  {
  if ((int )offset->mode == 0) {
    tmp = fseek(fp, (long )offset->off.i32, 0);
    if (tmp != 0) {
      return (8);
    }
  } else {
    return (7);
  }
  return (0);
}
}
int SSIFileInfo(SSIFILE *sfp , int fh , char **ret_filename , int *ret_format ) 
{ 


  {
  if (fh < 0) {
    return (12);
  } else
  if (fh >= (int )sfp->nfiles) {
    return (12);
  }
  *ret_filename = *(sfp->filename + fh);
  *ret_format = (int )*(sfp->fileformat + fh);
  return (0);
}
}
void SSIClose(SSIFILE *sfp ) 
{ 


  {
  if ((unsigned long )sfp != (unsigned long )((void *)0)) {
    clear_ssifile(sfp);
    if ((unsigned long )sfp->fp != (unsigned long )((void *)0)) {
      fclose(sfp->fp);
    }
    free((void *)sfp);
  }
  return;
}
}
static void clear_ssifile(SSIFILE *sfp ) 
{ 
  int i___0 ;

  {
  if ((unsigned long )sfp->filename != (unsigned long )((void *)0)) {
    i___0 = 0;
    while (i___0 < (int )sfp->nfiles) {
      if ((unsigned long )*(sfp->filename + i___0) != (unsigned long )((void *)0)) {
        free((void *)*(sfp->filename + i___0));
      }
      i___0 ++;
    }
    free((void *)sfp->filename);
  }
  if ((unsigned long )sfp->fileformat != (unsigned long )((void *)0)) {
    free((void *)sfp->fileformat);
  }
  if ((unsigned long )sfp->fileflags != (unsigned long )((void *)0)) {
    free((void *)sfp->fileflags);
  }
  if ((unsigned long )sfp->bpl != (unsigned long )((void *)0)) {
    free((void *)sfp->bpl);
  }
  if ((unsigned long )sfp->rpl != (unsigned long )((void *)0)) {
    free((void *)sfp->rpl);
  }
  return;
}
}
int SSIRecommendMode(char *file ) 
{ 


  {
  return (0);
}
}
SSIINDEX *SSICreateIndex(int mode ) 
{ 
  SSIINDEX *g ;
  void *tmp ;
  char **tmp___0 ;
  void *tmp___1 ;
  sqd_uint32 *tmp___2 ;
  void *tmp___3 ;
  sqd_uint32 *tmp___4 ;
  void *tmp___5 ;
  sqd_uint32 *tmp___6 ;
  void *tmp___7 ;
  struct ssipkey_s *tmp___8 ;
  void *tmp___9 ;
  struct ssiskey_s *tmp___10 ;
  void *tmp___11 ;

  {
  g = (SSIINDEX *)((void *)0);
  tmp = malloc(sizeof(SSIINDEX ));
  g = (SSIINDEX *)tmp;
  if ((unsigned long )g == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  g->smode = mode;
  g->imode = 0;
  g->external = 0;
  g->max_ram = 200;
  if (mode == 1) {
    Die((char *)"Can\'t create a 64-bit SSI index on this system, sorry;\nI don\'t have 64-bit file offset functions available.\n");
  }
  g->filenames = (char **)((void *)0);
  g->fileformat = (sqd_uint32 *)((void *)0);
  g->bpl = (sqd_uint32 *)((void *)0);
  g->rpl = (sqd_uint32 *)((void *)0);
  g->flen = (sqd_uint32 )0;
  g->nfiles = (sqd_uint16 )0;
  g->pkeys = (struct ssipkey_s *)((void *)0);
  g->plen = (sqd_uint32 )0;
  g->nprimary = (sqd_uint32 )0;
  g->ptmpfile = (char *)"tmp.ssi.1";
  g->ptmp = (FILE *)((void *)0);
  g->skeys = (struct ssiskey_s *)((void *)0);
  g->slen = (sqd_uint32 )0;
  g->nsecondary = (sqd_uint32 )0;
  g->stmpfile = (char *)"tmp.ssi.2";
  g->stmp = (FILE *)((void *)0);
  tmp___1 = malloc(sizeof(char *) * 10UL);
  tmp___0 = (char **)tmp___1;
  g->filenames = tmp___0;
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  tmp___3 = malloc(sizeof(sqd_uint32 ) * 10UL);
  tmp___2 = (sqd_uint32 *)tmp___3;
  g->fileformat = tmp___2;
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  tmp___5 = malloc(sizeof(sqd_uint32 ) * 10UL);
  tmp___4 = (sqd_uint32 *)tmp___5;
  g->bpl = tmp___4;
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  tmp___7 = malloc(sizeof(sqd_uint32 ) * 10UL);
  tmp___6 = (sqd_uint32 *)tmp___7;
  g->rpl = tmp___6;
  if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  tmp___9 = malloc(sizeof(struct ssipkey_s ) * 100UL);
  tmp___8 = (struct ssipkey_s *)tmp___9;
  g->pkeys = tmp___8;
  if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  tmp___11 = malloc(sizeof(struct ssipkey_s ) * 100UL);
  tmp___10 = (struct ssiskey_s *)tmp___11;
  g->skeys = tmp___10;
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
    goto FAILURE;
  }
  return (g);
  FAILURE: 
  SSIFreeIndex(g);
  return ((SSIINDEX *)((void *)0));
}
}
int SSIGetFilePosition(FILE *fp , int mode , SSIOFFSET *ret_offset ) 
{ 
  long tmp ;

  {
  if (mode == 0) {
    ret_offset->mode = (char)0;
    tmp = ftell(fp);
    ret_offset->off.i32 = (sqd_uint32 )tmp;
    if (ret_offset->off.i32 == 4294967295U) {
      return (9);
    }
  } else
  if (mode != 1) {
    abort();
  } else {
    ret_offset->mode = (char)1;
    return (7);
  }
  return (0);
}
}
int SSIAddFileToIndex(SSIINDEX *g , char *filename , int fmt , int *ret_fh ) 
{ 
  int n ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  if ((int )g->nfiles >= 32767) {
    return (13);
  }
  tmp = strlen((char const   *)filename);
  n = (int )tmp;
  if ((sqd_uint32 )(n + 1) > g->flen) {
    g->flen = (sqd_uint32 )(n + 1);
  }
  *(g->filenames + g->nfiles) = FileTail(filename, 0);
  *(g->fileformat + g->nfiles) = (sqd_uint32 )fmt;
  *(g->bpl + g->nfiles) = (sqd_uint32 )0;
  *(g->rpl + g->nfiles) = (sqd_uint32 )0;
  *ret_fh = (int )g->nfiles;
  g->nfiles = (sqd_uint16 )((int )g->nfiles + 1);
  if ((int )g->nfiles % 10 == 0) {
    tmp___0 = realloc((void *)g->filenames, sizeof(char *) * (unsigned long )((int )g->nfiles + 10));
    g->filenames = (char **)tmp___0;
    if ((unsigned long )g->filenames == (unsigned long )((void *)0)) {
      return (3);
    }
    tmp___1 = realloc((void *)g->fileformat, sizeof(sqd_uint32 ) * (unsigned long )((int )g->nfiles + 10));
    g->fileformat = (sqd_uint32 *)tmp___1;
    if ((unsigned long )g->fileformat == (unsigned long )((void *)0)) {
      return (3);
    }
    tmp___2 = realloc((void *)g->bpl, sizeof(sqd_uint32 ) * (unsigned long )((int )g->nfiles + 10));
    g->bpl = (sqd_uint32 *)tmp___2;
    if ((unsigned long )g->bpl == (unsigned long )((void *)0)) {
      return (3);
    }
    tmp___3 = realloc((void *)g->rpl, sizeof(sqd_uint32 ) * (unsigned long )((int )g->nfiles + 10));
    g->rpl = (sqd_uint32 *)tmp___3;
    if ((unsigned long )g->rpl == (unsigned long )((void *)0)) {
      return (3);
    }
  }
  return (0);
}
}
int SSISetFileForSubseq(SSIINDEX *g , int fh , int bpl , int rpl ) 
{ 


  {
  if (fh < 0) {
    return (12);
  } else
  if (fh >= (int )g->nfiles) {
    return (12);
  }
  if (bpl <= 0) {
    return (12);
  } else
  if (rpl <= 0) {
    return (12);
  }
  *(g->bpl + fh) = (sqd_uint32 )bpl;
  *(g->rpl + fh) = (sqd_uint32 )rpl;
  return (0);
}
}
int SSIAddPrimaryKeyToIndex(SSIINDEX *g , char *key , int fh , SSIOFFSET *r_off ,
                            SSIOFFSET *d_off , int L ) 
{ 
  int n ;
  int tmp ;
  sqd_uint64 tmp___0 ;
  size_t tmp___1 ;
  sqd_uint32 tmp___2 ;
  sqd_uint64 tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;

  {
  if (fh >= 32767) {
    return (13);
  }
  if ((long )g->nprimary >= 2147483647L) {
    return (14);
  }
  if (L > 0) {
    if ((unsigned long )d_off == (unsigned long )((void *)0)) {
      abort();
    }
  }
  if (! g->external) {
    tmp___0 = current_index_size(g);
    if (tmp___0 >= (sqd_uint64 )g->max_ram) {
      tmp = activate_external_sort(g);
      if (tmp != 0) {
        return (4);
      }
    }
  }
  tmp___1 = strlen((char const   *)key);
  n = (int )tmp___1;
  if ((sqd_uint32 )(n + 1) > g->plen) {
    g->plen = (sqd_uint32 )(n + 1);
  }
  if (g->external) {
    if (g->smode == 0) {
      if ((unsigned long )d_off == (unsigned long )((void *)0)) {
        tmp___2 = (sqd_uint32 )0;
      } else {
        tmp___2 = d_off->off.i32;
      }
      fprintf(g->ptmp, "%s\t%d\t%lu\t%lu\t%lu\n", key, fh, (unsigned long )r_off->off.i32,
              (unsigned long )tmp___2, (unsigned long )L);
    } else {
      if ((unsigned long )d_off == (unsigned long )((void *)0)) {
        tmp___3 = (sqd_uint64 )0;
      } else {
        tmp___3 = d_off->off.i64;
      }
      fprintf(g->ptmp, "%s\t%d\t%llu\t%llu\t%lu\n", key, fh, r_off->off.i64, tmp___3,
              (unsigned long )L);
    }
    (g->nprimary) ++;
    return (0);
  }
  tmp___4 = sre_strdup(key, n);
  (g->pkeys + g->nprimary)->key = tmp___4;
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
    return (3);
  }
  (g->pkeys + g->nprimary)->fnum = (sqd_uint16 )fh;
  (g->pkeys + g->nprimary)->r_off = *r_off;
  if ((unsigned long )d_off != (unsigned long )((void *)0)) {
    if (L > 0) {
      (g->pkeys + g->nprimary)->d_off = *d_off;
      (g->pkeys + g->nprimary)->len = (sqd_uint32 )L;
    } else {
      (g->pkeys + g->nprimary)->d_off = *r_off;
      (g->pkeys + g->nprimary)->len = (sqd_uint32 )0;
    }
  } else {
    (g->pkeys + g->nprimary)->d_off = *r_off;
    (g->pkeys + g->nprimary)->len = (sqd_uint32 )0;
  }
  (g->nprimary) ++;
  if (g->nprimary % 100U == 0U) {
    tmp___5 = realloc((void *)g->pkeys, sizeof(struct ssipkey_s ) * (unsigned long )(g->nprimary + 100U));
    g->pkeys = (struct ssipkey_s *)tmp___5;
    if ((unsigned long )g->pkeys == (unsigned long )((void *)0)) {
      return (3);
    }
  }
  return (0);
}
}
int SSIAddSecondaryKeyToIndex(SSIINDEX *g , char *key , char *pkey ) 
{ 
  int n ;
  int tmp ;
  sqd_uint64 tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;

  {
  if ((long )g->nsecondary >= 2147483647L) {
    return (14);
  }
  if (! g->external) {
    tmp___0 = current_index_size(g);
    if (tmp___0 >= (sqd_uint64 )g->max_ram) {
      tmp = activate_external_sort(g);
      if (tmp != 0) {
        return (4);
      }
    }
  }
  tmp___1 = strlen((char const   *)key);
  n = (int )tmp___1;
  if ((sqd_uint32 )(n + 1) > g->slen) {
    g->slen = (sqd_uint32 )(n + 1);
  }
  if (g->external) {
    fprintf(g->stmp, "%s\t%s\n", key, pkey);
    (g->nsecondary) ++;
    return (0);
  }
  tmp___2 = sre_strdup(key, n);
  (g->skeys + g->nsecondary)->key = tmp___2;
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    return (3);
  }
  tmp___3 = sre_strdup(pkey, -1);
  (g->skeys + g->nsecondary)->pkey = tmp___3;
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    return (3);
  }
  (g->nsecondary) ++;
  if (g->nsecondary % 100U == 0U) {
    tmp___4 = realloc((void *)g->skeys, sizeof(struct ssiskey_s ) * (unsigned long )(g->nsecondary + 100U));
    g->skeys = (struct ssiskey_s *)tmp___4;
    if ((unsigned long )g->skeys == (unsigned long )((void *)0)) {
      return (3);
    }
  }
  return (0);
}
}
static int pkeysort(void const   *k1 , void const   *k2 ) 
{ 
  struct ssipkey_s *key1 ;
  struct ssipkey_s *key2 ;
  int tmp ;

  {
  key1 = (struct ssipkey_s *)k1;
  key2 = (struct ssipkey_s *)k2;
  tmp = strcmp((char const   *)key1->key, (char const   *)key2->key);
  return (tmp);
}
}
static int skeysort(void const   *k1 , void const   *k2 ) 
{ 
  struct ssiskey_s *key1 ;
  struct ssiskey_s *key2 ;
  int tmp ;

  {
  key1 = (struct ssiskey_s *)k1;
  key2 = (struct ssiskey_s *)k2;
  tmp = strcmp((char const   *)key1->key, (char const   *)key2->key);
  return (tmp);
}
}
int SSIWriteIndex(char *file , SSIINDEX *g ) 
{ 
  FILE *fp ;
  int status ;
  int i___0 ;
  sqd_uint32 header_flags ;
  sqd_uint32 file_flags ;
  sqd_uint32 frecsize ;
  sqd_uint32 precsize ;
  sqd_uint32 srecsize ;
  sqd_uint64 foffset ;
  sqd_uint64 poffset ;
  sqd_uint64 soffset ;
  char *s___0 ;
  char *s2 ;
  sqd_uint64 tmp ;
  char cmd[1024] ;
  unsigned long tmp___0 ;
  FILE *tmp___1 ;
  unsigned long tmp___2 ;
  FILE *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  void *tmp___21 ;
  unsigned long tmp___22 ;
  unsigned long tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  void *tmp___29 ;
  char *buf ;
  int buflen ;
  struct ssipkey_s pkey ;
  char *tmp___30 ;
  int tmp___31 ;
  unsigned long tmp___32 ;
  unsigned long tmp___33 ;
  size_t tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  unsigned long tmp___39 ;
  unsigned long tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  void *tmp___46 ;
  struct ssiskey_s skey ;
  char *buf___0 ;
  int n ;
  char *tmp___47 ;
  int tmp___48 ;
  unsigned long tmp___49 ;
  unsigned long tmp___50 ;
  unsigned long tmp___51 ;
  unsigned long tmp___52 ;
  size_t tmp___53 ;
  size_t tmp___54 ;
  unsigned long tmp___55 ;
  unsigned long tmp___56 ;
  unsigned long tmp___57 ;
  unsigned long tmp___58 ;
  size_t tmp___59 ;
  size_t tmp___60 ;

  {
  fp = fopen((char const   *)file, "wb");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    return (4);
  }
  status = 0;
  tmp = current_index_size(g);
  if (tmp >= 2047ULL) {
    g->imode = 1;
    Die((char *)"Can\'t switch to 64-bit SSI index mode on this system, sorry;\nI don\'t have 64-bit file offset functions available.\n");
  }
  frecsize = 16U + g->flen;
  if (g->smode == 1) {
    precsize = 22U + g->plen;
  } else {
    precsize = 14U + g->plen;
  }
  srecsize = g->slen + g->plen;
  header_flags = (sqd_uint32 )0;
  if (g->smode == 1) {
    header_flags |= 1U;
  }
  if (g->imode == 1) {
    header_flags |= (unsigned int )(1 << 1);
  }
  if (header_flags & (unsigned int )(1 << 1)) {
    foffset = (sqd_uint64 )66;
  } else {
    foffset = (sqd_uint64 )54;
  }
  poffset = foffset + (sqd_uint64 )(frecsize * (sqd_uint32 )g->nfiles);
  soffset = poffset + (sqd_uint64 )(precsize * g->nprimary);
  if (g->external) {
    fclose(g->ptmp);
    g->ptmp = (FILE *)((void *)0);
    tmp___0 = __builtin_object_size((void *)(cmd), 1);
    __builtin___sprintf_chk(cmd, 0, tmp___0, "env LC_ALL=POSIX sort -o %s %s\n", g->ptmpfile,
                            g->ptmpfile);
    status = system((char const   *)(cmd));
    if (status != 0) {
      return (16);
    }
    tmp___1 = fopen((char const   *)g->ptmpfile, "r");
    g->ptmp = tmp___1;
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      return (16);
    }
    fclose(g->stmp);
    g->stmp = (FILE *)((void *)0);
    tmp___2 = __builtin_object_size((void *)(cmd), 1);
    __builtin___sprintf_chk(cmd, 0, tmp___2, "env LC_ALL=POSIX sort -o %s %s\n", g->stmpfile,
                            g->stmpfile);
    status = system((char const   *)(cmd));
    if (status != 0) {
      return (16);
    }
    tmp___3 = fopen((char const   *)g->stmpfile, "r");
    g->stmp = tmp___3;
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      return (16);
    }
  } else {
    specqsort((void *)g->pkeys, g->nprimary, sizeof(struct ssipkey_s ), & pkeysort);
    specqsort((void *)g->skeys, g->nsecondary, sizeof(struct ssiskey_s ), & skeysort);
  }
  tmp___4 = write_i32(fp, v20magic___0);
  if (! tmp___4) {
    return (15);
  }
  tmp___5 = write_i32(fp, header_flags);
  if (! tmp___5) {
    return (15);
  }
  tmp___6 = write_i16(fp, g->nfiles);
  if (! tmp___6) {
    return (15);
  }
  tmp___7 = write_i32(fp, g->nprimary);
  if (! tmp___7) {
    return (15);
  }
  tmp___8 = write_i32(fp, g->nsecondary);
  if (! tmp___8) {
    return (15);
  }
  tmp___9 = write_i32(fp, g->flen);
  if (! tmp___9) {
    return (15);
  }
  tmp___10 = write_i32(fp, g->plen);
  if (! tmp___10) {
    return (15);
  }
  tmp___11 = write_i32(fp, g->slen);
  if (! tmp___11) {
    return (15);
  }
  tmp___12 = write_i32(fp, frecsize);
  if (! tmp___12) {
    return (15);
  }
  tmp___13 = write_i32(fp, precsize);
  if (! tmp___13) {
    return (15);
  }
  tmp___14 = write_i32(fp, srecsize);
  if (! tmp___14) {
    return (15);
  }
  if (g->imode == 0) {
    tmp___15 = write_i32(fp, (sqd_uint32 )foffset);
    if (! tmp___15) {
      return (15);
    }
    tmp___16 = write_i32(fp, (sqd_uint32 )poffset);
    if (! tmp___16) {
      return (15);
    }
    tmp___17 = write_i32(fp, (sqd_uint32 )soffset);
    if (! tmp___17) {
      return (15);
    }
  } else {
    tmp___18 = write_i64(fp, foffset);
    if (! tmp___18) {
      return (15);
    }
    tmp___19 = write_i64(fp, poffset);
    if (! tmp___19) {
      return (15);
    }
    tmp___20 = write_i64(fp, soffset);
    if (! tmp___20) {
      return (15);
    }
  }
  tmp___21 = malloc(sizeof(char ) * (unsigned long )g->flen);
  s___0 = (char *)tmp___21;
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return (3);
  }
  i___0 = 0;
  while (i___0 < (int )g->nfiles) {
    file_flags = (sqd_uint32 )0;
    if (*(g->bpl + i___0) > 0U) {
      if (*(g->rpl + i___0) > 0U) {
        file_flags |= 1U;
      }
    }
    tmp___23 = __builtin_object_size((void *)s___0, 0);
    if (tmp___23 != 0xffffffffffffffffUL) {
      tmp___22 = __builtin_object_size((void *)s___0, 1);
      __builtin___strcpy_chk(s___0, (char const   *)*(g->filenames + i___0), tmp___22);
    } else {
      __inline_strcpy_chk(s___0, (char const   *)*(g->filenames + i___0));
    }
    tmp___24 = fwrite((void const   *)s___0, sizeof(char ), (size_t )g->flen, fp);
    if (tmp___24 != (size_t )g->flen) {
      return (15);
    }
    tmp___25 = write_i32(fp, *(g->fileformat + i___0));
    if (! tmp___25) {
      return (15);
    }
    tmp___26 = write_i32(fp, file_flags);
    if (! tmp___26) {
      return (15);
    }
    tmp___27 = write_i32(fp, *(g->bpl + i___0));
    if (! tmp___27) {
      return (15);
    }
    tmp___28 = write_i32(fp, *(g->rpl + i___0));
    if (! tmp___28) {
      return (15);
    }
    i___0 ++;
  }
  free((void *)s___0);
  tmp___29 = malloc(sizeof(char ) * (unsigned long )g->plen);
  s___0 = (char *)tmp___29;
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return (3);
  }
  if (g->external) {
    buf = (char *)((void *)0);
    buflen = 0;
    i___0 = 0;
    while ((sqd_uint32 )i___0 < g->nprimary) {
      tmp___30 = sre_fgets(& buf, & buflen, g->ptmp);
      if ((unsigned long )tmp___30 == (unsigned long )((void *)0)) {
        return (1);
      }
      tmp___31 = parse_pkey_info(buf, (char )g->smode, & pkey);
      if (tmp___31 != 0) {
        return (6);
      }
      tmp___33 = __builtin_object_size((void *)s___0, 0);
      if (tmp___33 != 0xffffffffffffffffUL) {
        tmp___32 = __builtin_object_size((void *)s___0, 1);
        __builtin___strcpy_chk(s___0, (char const   *)pkey.key, tmp___32);
      } else {
        __inline_strcpy_chk(s___0, (char const   *)pkey.key);
      }
      tmp___34 = fwrite((void const   *)s___0, sizeof(char ), (size_t )g->plen, fp);
      if (tmp___34 != (size_t )g->plen) {
        return (15);
      }
      tmp___35 = write_i16(fp, pkey.fnum);
      if (! tmp___35) {
        return (15);
      }
      tmp___36 = write_offset(fp, & pkey.r_off);
      if (! tmp___36) {
        return (15);
      }
      tmp___37 = write_offset(fp, & pkey.d_off);
      if (! tmp___37) {
        return (15);
      }
      tmp___38 = write_i32(fp, pkey.len);
      if (! tmp___38) {
        return (15);
      }
      i___0 ++;
    }
    free((void *)buf);
  } else {
    i___0 = 0;
    while ((sqd_uint32 )i___0 < g->nprimary) {
      tmp___40 = __builtin_object_size((void *)s___0, 0);
      if (tmp___40 != 0xffffffffffffffffUL) {
        tmp___39 = __builtin_object_size((void *)s___0, 1);
        __builtin___strcpy_chk(s___0, (char const   *)(g->pkeys + i___0)->key, tmp___39);
      } else {
        __inline_strcpy_chk(s___0, (char const   *)(g->pkeys + i___0)->key);
      }
      tmp___41 = fwrite((void const   *)s___0, sizeof(char ), (size_t )g->plen, fp);
      if (tmp___41 != (size_t )g->plen) {
        return (15);
      }
      tmp___42 = write_i16(fp, (g->pkeys + i___0)->fnum);
      if (! tmp___42) {
        return (15);
      }
      tmp___43 = write_offset(fp, & (g->pkeys + i___0)->r_off);
      if (! tmp___43) {
        return (15);
      }
      tmp___44 = write_offset(fp, & (g->pkeys + i___0)->d_off);
      if (! tmp___44) {
        return (15);
      }
      tmp___45 = write_i32(fp, (g->pkeys + i___0)->len);
      if (! tmp___45) {
        return (15);
      }
      i___0 ++;
    }
  }
  if (g->nsecondary > 0U) {
    tmp___46 = malloc(sizeof(char ) * (unsigned long )g->slen);
    s2 = (char *)tmp___46;
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
      return (3);
    }
    if (g->external) {
      buf___0 = (char *)((void *)0);
      n = 0;
      i___0 = 0;
      while ((sqd_uint32 )i___0 < g->nsecondary) {
        tmp___47 = sre_fgets(& buf___0, & n, g->stmp);
        if ((unsigned long )tmp___47 == (unsigned long )((void *)0)) {
          return (1);
        }
        tmp___48 = parse_skey_info(buf___0, & skey);
        if (tmp___48 != 0) {
          return (6);
        }
        tmp___50 = __builtin_object_size((void *)s2, 0);
        if (tmp___50 != 0xffffffffffffffffUL) {
          tmp___49 = __builtin_object_size((void *)s2, 1);
          __builtin___strcpy_chk(s2, (char const   *)skey.key, tmp___49);
        } else {
          __inline_strcpy_chk(s2, (char const   *)skey.key);
        }
        tmp___52 = __builtin_object_size((void *)s___0, 0);
        if (tmp___52 != 0xffffffffffffffffUL) {
          tmp___51 = __builtin_object_size((void *)s___0, 1);
          __builtin___strcpy_chk(s___0, (char const   *)skey.pkey, tmp___51);
        } else {
          __inline_strcpy_chk(s___0, (char const   *)skey.pkey);
        }
        tmp___53 = fwrite((void const   *)s2, sizeof(char ), (size_t )g->slen, fp);
        if (tmp___53 != (size_t )g->slen) {
          return (15);
        }
        tmp___54 = fwrite((void const   *)s___0, sizeof(char ), (size_t )g->plen,
                          fp);
        if (tmp___54 != (size_t )g->plen) {
          return (15);
        }
        i___0 ++;
      }
      free((void *)buf___0);
    } else {
      i___0 = 0;
      while ((sqd_uint32 )i___0 < g->nsecondary) {
        tmp___56 = __builtin_object_size((void *)s2, 0);
        if (tmp___56 != 0xffffffffffffffffUL) {
          tmp___55 = __builtin_object_size((void *)s2, 1);
          __builtin___strcpy_chk(s2, (char const   *)(g->skeys + i___0)->key, tmp___55);
        } else {
          __inline_strcpy_chk(s2, (char const   *)(g->skeys + i___0)->key);
        }
        tmp___58 = __builtin_object_size((void *)s___0, 0);
        if (tmp___58 != 0xffffffffffffffffUL) {
          tmp___57 = __builtin_object_size((void *)s___0, 1);
          __builtin___strcpy_chk(s___0, (char const   *)(g->skeys + i___0)->pkey,
                                 tmp___57);
        } else {
          __inline_strcpy_chk(s___0, (char const   *)(g->skeys + i___0)->pkey);
        }
        tmp___59 = fwrite((void const   *)s2, sizeof(char ), (size_t )g->slen, fp);
        if (tmp___59 != (size_t )g->slen) {
          return (15);
        }
        tmp___60 = fwrite((void const   *)s___0, sizeof(char ), (size_t )g->plen,
                          fp);
        if (tmp___60 != (size_t )g->plen) {
          return (15);
        }
        i___0 ++;
      }
    }
    free((void *)s2);
  }
  free((void *)s___0);
  fclose(fp);
  return (status);
}
}
void SSIFreeIndex(SSIINDEX *g ) 
{ 
  int i___0 ;

  {
  if ((unsigned long )g != (unsigned long )((void *)0)) {
    if (g->external == 0) {
      i___0 = 0;
      while ((sqd_uint32 )i___0 < g->nprimary) {
        free((void *)(g->pkeys + i___0)->key);
        i___0 ++;
      }
      i___0 = 0;
      while ((sqd_uint32 )i___0 < g->nsecondary) {
        free((void *)(g->skeys + i___0)->key);
        i___0 ++;
      }
      i___0 = 0;
      while ((sqd_uint32 )i___0 < g->nsecondary) {
        free((void *)(g->skeys + i___0)->pkey);
        i___0 ++;
      }
      if ((unsigned long )g->pkeys != (unsigned long )((void *)0)) {
        free((void *)g->pkeys);
      }
      if ((unsigned long )g->skeys != (unsigned long )((void *)0)) {
        free((void *)g->skeys);
      }
    } else {
      if ((unsigned long )g->ptmp != (unsigned long )((void *)0)) {
        fclose(g->ptmp);
      }
      if ((unsigned long )g->stmp != (unsigned long )((void *)0)) {
        fclose(g->stmp);
      }
      remove((char const   *)g->ptmpfile);
      remove((char const   *)g->stmpfile);
    }
    i___0 = 0;
    while (i___0 < (int )g->nfiles) {
      free((void *)*(g->filenames + i___0));
      i___0 ++;
    }
    if ((unsigned long )g->filenames != (unsigned long )((void *)0)) {
      free((void *)g->filenames);
    }
    if ((unsigned long )g->fileformat != (unsigned long )((void *)0)) {
      free((void *)g->fileformat);
    }
    if ((unsigned long )g->bpl != (unsigned long )((void *)0)) {
      free((void *)g->bpl);
    }
    if ((unsigned long )g->rpl != (unsigned long )((void *)0)) {
      free((void *)g->rpl);
    }
    free((void *)g);
  }
  return;
}
}
char *SSIErrorString(int n ) 
{ 


  {
  switch (n) {
  case 0: 
  return ((char *)"ok (no error)");
  case 1: 
  return ((char *)"no data, fread() failed");
  case 2: 
  return ((char *)"no such key");
  case 3: 
  return ((char *)"out of memory, malloc() failed");
  case 4: 
  return ((char *)"file not found, fopen() failed");
  case 5: 
  return ((char *)"not a SSI file? (bad magic)");
  case 6: 
  return ((char *)"corrupt format? unexpected data");
  case 7: 
  return ((char *)"no large file support for this system");
  case 8: 
  return ((char *)"failed to reposition on disk");
  case 9: 
  return ((char *)"failed to get file position on disk");
  case 10: 
  return ((char *)"no fast subseq support for this seqfile");
  case 11: 
  return ((char *)"subseq start is out of range");
  case 12: 
  return ((char *)"an argument is out of range");
  case 13: 
  return ((char *)"number of files exceeds limit");
  case 14: 
  return ((char *)"number of keys exceeds limit");
  case 15: 
  return ((char *)"an fwrite() failed");
  case 16: 
  return ((char *)"some problem with external sorting");
  default: 
  return ((char *)"unrecognized code");
  }
}
}
static int read_i16(FILE *fp , sqd_uint16 *ret_result ) 
{ 
  sqd_uint16 result ;
  size_t tmp ;

  {
  tmp = fread((void *)(& result), sizeof(sqd_uint16 ), (size_t )1, fp);
  if (tmp != 1UL) {
    return (0);
  }
  *ret_result = sre_ntoh16(result);
  return (1);
}
}
static int write_i16(FILE *fp , sqd_uint16 n ) 
{ 
  size_t tmp ;

  {
  n = sre_hton16(n);
  tmp = fwrite((void const   *)(& n), sizeof(sqd_uint16 ), (size_t )1, fp);
  if (tmp != 1UL) {
    return (0);
  }
  return (1);
}
}
static int read_i32(FILE *fp , sqd_uint32 *ret_result ) 
{ 
  sqd_uint32 result ;
  size_t tmp ;

  {
  tmp = fread((void *)(& result), sizeof(sqd_uint32 ), (size_t )1, fp);
  if (tmp != 1UL) {
    return (0);
  }
  *ret_result = sre_ntoh32(result);
  return (1);
}
}
static int write_i32(FILE *fp , sqd_uint32 n ) 
{ 
  size_t tmp ;

  {
  n = sre_hton32(n);
  tmp = fwrite((void const   *)(& n), sizeof(sqd_uint32 ), (size_t )1, fp);
  if (tmp != 1UL) {
    return (0);
  }
  return (1);
}
}
static int read_i64(FILE *fp , sqd_uint64 *ret_result ) 
{ 
  sqd_uint64 result ;
  size_t tmp ;

  {
  tmp = fread((void *)(& result), sizeof(sqd_uint64 ), (size_t )1, fp);
  if (tmp != 1UL) {
    return (0);
  }
  *ret_result = sre_ntoh64(result);
  return (1);
}
}
static int write_i64(FILE *fp , sqd_uint64 n ) 
{ 
  size_t tmp ;

  {
  n = sre_hton64(n);
  tmp = fwrite((void const   *)(& n), sizeof(sqd_uint64 ), (size_t )1, fp);
  if (tmp != 1UL) {
    return (0);
  }
  return (1);
}
}
static int read_offset(FILE *fp , char mode , SSIOFFSET *ret_offset ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((int )mode == 0) {
    ret_offset->mode = (char)0;
    tmp = read_i32(fp, & ret_offset->off.i32);
    if (! tmp) {
      return (0);
    }
  } else
  if ((int )mode == 1) {
    ret_offset->mode = (char)1;
    tmp___0 = read_i64(fp, & ret_offset->off.i64);
    if (! tmp___0) {
      return (0);
    }
  } else {
    return (0);
  }
  return (1);
}
}
static int write_offset(FILE *fp , SSIOFFSET *offset ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((int )offset->mode == 0) {
    tmp = write_i32(fp, offset->off.i32);
    return (tmp);
  } else
  if ((int )offset->mode == 1) {
    tmp___0 = write_i64(fp, offset->off.i64);
    return (tmp___0);
  } else {
    abort();
  }
  return (1);
}
}
static int parse_pkey_info(char *buf , char mode , struct ssipkey_s *pkey ) 
{ 
  char *s___0 ;
  char *tok ;
  int n ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  s___0 = buf;
  tok = sre_strtok(& s___0, (char *)"\t\n", & n);
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
    return (6);
  }
  pkey->key = tok;
  tok = sre_strtok(& s___0, (char *)"\t\n", & n);
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
    return (6);
  }
  tmp = atoi((char const   *)tok);
  pkey->fnum = (sqd_uint16 )tmp;
  if ((int )mode == 0) {
    tok = sre_strtok(& s___0, (char *)"\t\n", & n);
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
      return (6);
    }
    pkey->r_off.mode = mode;
    tmp___0 = strtoul((char const   *)tok, (char **)((void *)0), 10);
    pkey->r_off.off.i32 = (sqd_uint32 )tmp___0;
    tok = sre_strtok(& s___0, (char *)"\t\n", & n);
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
      return (6);
    }
    pkey->d_off.mode = mode;
    tmp___1 = strtoul((char const   *)tok, (char **)((void *)0), 10);
    pkey->d_off.off.i32 = (sqd_uint32 )tmp___1;
  } else {
    return (7);
  }
  tok = sre_strtok(& s___0, (char *)"\t\n", & n);
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
    return (6);
  }
  tmp___2 = strtoul((char const   *)tok, (char **)((void *)0), 10);
  pkey->len = (sqd_uint32 )tmp___2;
  return (0);
}
}
static int parse_skey_info(char *buf , struct ssiskey_s *skey ) 
{ 
  char *s___0 ;
  char *tok ;
  int n ;

  {
  s___0 = buf;
  tok = sre_strtok(& s___0, (char *)"\t\n", & n);
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
    return (6);
  }
  skey->key = tok;
  tok = sre_strtok(& s___0, (char *)"\t\n", & n);
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
    return (6);
  }
  skey->pkey = tok;
  return (0);
}
}
static int binary_search(SSIFILE *sfp , char *key , int klen , SSIOFFSET *base , sqd_uint32 recsize ,
                         sqd_uint32 maxidx ) 
{ 
  char *name ;
  sqd_uint32 left ;
  sqd_uint32 right ;
  sqd_uint32 mid ;
  int cmp ;
  int status ;
  void *tmp ;
  size_t tmp___0 ;

  {
  if (maxidx == 0U) {
    return (2);
  }
  tmp = malloc(sizeof(char ) * (unsigned long )klen);
  name = (char *)tmp;
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    return (3);
  }
  left = (sqd_uint32 )0;
  right = maxidx - 1U;
  while (1) {
    mid = (left + right) / 2U;
    status = indexfile_position(sfp, base, recsize, mid);
    if (status != 0) {
      free((void *)name);
      return (status);
    }
    tmp___0 = fread((void *)name, sizeof(char ), (size_t )klen, sfp->fp);
    if (tmp___0 != (size_t )klen) {
      free((void *)name);
      return (1);
    }
    cmp = strcmp((char const   *)name, (char const   *)key);
    if (cmp == 0) {
      break;
    } else
    if (left >= right) {
      free((void *)name);
      return (2);
    } else
    if (cmp < 0) {
      left = mid + 1U;
    } else
    if (cmp > 0) {
      if (mid == 0U) {
        free((void *)name);
        return (2);
      } else {
        right = mid - 1U;
      }
    }
  }
  free((void *)name);
  return (0);
}
}
static int indexfile_position(SSIFILE *sfp , SSIOFFSET *base , sqd_uint32 len , sqd_uint32 n ) 
{ 
  SSIOFFSET pos ;
  int status ;

  {
  if ((int )base->mode == 0) {
    pos.mode = (char)0;
    pos.off.i32 = base->off.i32 + n * len;
  } else
  if ((int )base->mode == 1) {
    pos.mode = (char)1;
    pos.off.i64 = base->off.i64 + (sqd_uint64 )(n * len);
  } else {
    return (0);
  }
  status = SSISetFilePosition(sfp->fp, & pos);
  if (status != 0) {
    return (status);
  }
  return (0);
}
}
static sqd_uint64 current_index_size(SSIINDEX *g ) 
{ 
  sqd_uint64 frecsize ;
  sqd_uint64 precsize ;
  sqd_uint64 srecsize ;
  sqd_uint64 total ;

  {
  frecsize = (sqd_uint64 )(16U + g->flen);
  if (g->smode == 1) {
    precsize = (sqd_uint64 )(22U + g->plen);
  } else {
    precsize = (sqd_uint64 )(14U + g->plen);
  }
  srecsize = (sqd_uint64 )(g->plen + g->slen);
  total = (((66ULL + frecsize * (sqd_uint64 )g->nfiles) + precsize * (sqd_uint64 )g->nprimary) + srecsize * (sqd_uint64 )g->nsecondary) / 1048576ULL;
  return (total);
}
}
static int activate_external_sort(SSIINDEX *g ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  FILE *tmp___1 ;
  FILE *tmp___2 ;

  {
  if (g->external) {
    return (0);
  }
  tmp = FileExists(g->ptmpfile);
  if (tmp) {
    return (1);
  }
  tmp___0 = FileExists(g->stmpfile);
  if (tmp___0) {
    return (1);
  }
  tmp___1 = fopen((char const   *)g->ptmpfile, "w");
  g->ptmp = tmp___1;
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    return (1);
  }
  tmp___2 = fopen((char const   *)g->stmpfile, "w");
  g->stmp = tmp___2;
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    return (1);
  }
  i___0 = 0;
  while ((sqd_uint32 )i___0 < g->nprimary) {
    if (g->smode == 0) {
      fprintf(g->ptmp, "%s\t%u\t%lu\t%lu\t%lu\n", (g->pkeys + i___0)->key, (unsigned int )(g->pkeys + i___0)->fnum,
              (unsigned long )(g->pkeys + i___0)->r_off.off.i32, (unsigned long )(g->pkeys + i___0)->d_off.off.i32,
              (unsigned long )(g->pkeys + i___0)->len);
    } else {
      fprintf(g->ptmp, "%s\t%u\t%llu\t%llu\t%lu\n", (g->pkeys + i___0)->key, (unsigned int )(g->pkeys + i___0)->fnum,
              (g->pkeys + i___0)->r_off.off.i64, (g->pkeys + i___0)->d_off.off.i64,
              (unsigned long )(g->pkeys + i___0)->len);
    }
    i___0 ++;
  }
  i___0 = 0;
  while ((sqd_uint32 )i___0 < g->nsecondary) {
    fprintf(g->stmp, "%s\t%s\n", (g->skeys + i___0)->key, (g->skeys + i___0)->pkey);
    i___0 ++;
  }
  i___0 = 0;
  while ((sqd_uint32 )i___0 < g->nprimary) {
    free((void *)(g->pkeys + i___0)->key);
    i___0 ++;
  }
  i___0 = 0;
  while ((sqd_uint32 )i___0 < g->nsecondary) {
    free((void *)(g->skeys + i___0)->key);
    i___0 ++;
  }
  i___0 = 0;
  while ((sqd_uint32 )i___0 < g->nsecondary) {
    free((void *)(g->skeys + i___0)->pkey);
    i___0 ++;
  }
  if ((unsigned long )g->pkeys != (unsigned long )((void *)0)) {
    free((void *)g->pkeys);
  }
  if ((unsigned long )g->skeys != (unsigned long )((void *)0)) {
    free((void *)g->skeys);
  }
  g->pkeys = (struct ssipkey_s *)((void *)0);
  g->skeys = (struct ssiskey_s *)((void *)0);
  g->external = 1;
  return (0);
}
}
void SSIForceExternalSort(SSIINDEX *g ) 
{ 
  int tmp ;

  {
  tmp = activate_external_sort(g);
  if (tmp != 0) {
    Die((char *)"failed to turn external sorting on.");
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-PMobv4Ne.i","-O3")
void ReverseIntStack(struct intstack_s *stack ) ;
struct intstack_s *InitIntStack(void) 
{ 
  struct intstack_s *stack ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct intstack_s ));
  stack = (struct intstack_s *)tmp;
  if ((unsigned long )stack == (unsigned long )((void *)0)) {
    Die((char *)"Memory allocation failure at %s line %d", "stack.c", 42);
  }
  stack->nxt = (struct intstack_s *)((void *)0);
  return (stack);
}
}
void PushIntStack(struct intstack_s *stack , int data ) 
{ 
  struct intstack_s *new ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct intstack_s ));
  new = (struct intstack_s *)tmp;
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    Die((char *)"Memory allocation failure at %s line %d", "stack.c", 52);
  }
  new->data = data;
  new->nxt = stack->nxt;
  stack->nxt = new;
  return;
}
}
int PopIntStack(struct intstack_s *stack , int *ret_data ) 
{ 
  struct intstack_s *old ;

  {
  if ((unsigned long )stack->nxt == (unsigned long )((void *)0)) {
    return (0);
  }
  old = stack->nxt;
  stack->nxt = old->nxt;
  *ret_data = old->data;
  free((void *)old);
  return (1);
}
}
void ReverseIntStack(struct intstack_s *stack ) 
{ 
  struct intstack_s *old ;
  struct intstack_s *new ;

  {
  old = stack->nxt;
  stack->nxt = (struct intstack_s *)((void *)0);
  while ((unsigned long )old != (unsigned long )((void *)0)) {
    new = old;
    old = old->nxt;
    new->nxt = stack->nxt;
    stack->nxt = new;
  }
  return;
}
}
int FreeIntStack(struct intstack_s *stack ) 
{ 
  int data ;
  int count ;
  int tmp ;

  {
  count = 0;
  while (1) {
    tmp = PopIntStack(stack, & data);
    if (! tmp) {
      break;
    }
    count ++;
  }
  free((void *)stack);
  return (count);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-odJtUrpQ.i","-O3")
static int parse_gf(MSA *msa , char *buf ) ;
static int parse_gs(MSA *msa , char *buf ) ;
static int parse_gc(MSA *msa , char *buf ) ;
static int parse_gr(MSA *msa , char *buf ) ;
static int parse_comment(MSA *msa , char *buf ) ;
static int parse_sequence(MSA *msa , char *buf ) ;
static void actually_write_stockholm(FILE *fp , MSA *msa , int cpl ) ;
MSA *ReadStockholm(MSAFILE *afp ) 
{ 
  MSA *msa ;
  char *s___0 ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
  tmp = feof(afp->f);
  if (tmp) {
    return ((MSA *)((void *)0));
  }
  msa = MSAAlloc(10, 0);
  while (1) {
    s___0 = MSAFileGetLine(afp);
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
      MSAFree(msa);
      return ((MSA *)((void *)0));
    }
    tmp___0 = IsBlankline(s___0);
    if (! tmp___0) {
      break;
    }
  }
  tmp___1 = strncmp((char const   *)s___0, "# STOCKHOLM 1.", (size_t )14);
  if (tmp___1 != 0) {
    Die((char *)"File %s doesn\'t appear to be in Stockholm format.\nAssuming there isn\'t some other problem with your file (it is an\nalignment file, right?), please either:\n  a) use the Babelfish format autotranslator option (-B, usually);\n  b) specify the file\'s format with the --informat option; or\n  a) reformat the alignment to Stockholm format.\n",
        afp->fname);
  }
  while (1) {
    s___0 = MSAFileGetLine(afp);
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
      break;
    }
    while (1) {
      if (! ((int )*s___0 == 32)) {
        if (! ((int )*s___0 == 9)) {
          break;
        }
      }
      s___0 ++;
    }
    if ((int )*s___0 == 35) {
      tmp___5 = strncmp((char const   *)s___0, "#=GF", (size_t )4);
      if (tmp___5 == 0) {
        status = parse_gf(msa, s___0);
      } else {
        tmp___4 = strncmp((char const   *)s___0, "#=GS", (size_t )4);
        if (tmp___4 == 0) {
          status = parse_gs(msa, s___0);
        } else {
          tmp___3 = strncmp((char const   *)s___0, "#=GC", (size_t )4);
          if (tmp___3 == 0) {
            status = parse_gc(msa, s___0);
          } else {
            tmp___2 = strncmp((char const   *)s___0, "#=GR", (size_t )4);
            if (tmp___2 == 0) {
              status = parse_gr(msa, s___0);
            } else {
              status = parse_comment(msa, s___0);
            }
          }
        }
      }
    } else {
      tmp___6 = strncmp((char const   *)s___0, "//", (size_t )2);
      if (tmp___6 == 0) {
        break;
      } else
      if ((int )*s___0 == 10) {
        continue;
      } else {
        status = parse_sequence(msa, s___0);
      }
    }
    if (status == 0) {
      if ((unsigned long )msa->name == (unsigned long )((void *)0)) {
        tmp___7 = "";
      } else {
        tmp___7 = (char const   *)msa->name;
      }
      Die((char *)"Stockholm format parse error: line %d of file %s while reading alignment %s",
          afp->linenumber, afp->fname, tmp___7);
    }
  }
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    if (msa->nseq != 0) {
      if ((unsigned long )msa->name == (unsigned long )((void *)0)) {
        tmp___8 = "";
      } else {
        tmp___8 = (char const   *)msa->name;
      }
      Die((char *)"Didn\'t find // at end of alignment %s", tmp___8);
    }
  }
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    if (msa->nseq == 0) {
      MSAFree(msa);
      return ((MSA *)((void *)0));
    }
  }
  MSAVerifyParse(msa);
  return (msa);
}
}
void WriteStockholm(FILE *fp , MSA *msa ) 
{ 


  {
  actually_write_stockholm(fp, msa, 50);
  return;
}
}
void WriteStockholmOneBlock(FILE *fp , MSA *msa ) 
{ 


  {
  actually_write_stockholm(fp, msa, msa->alen);
  return;
}
}
static void actually_write_stockholm(FILE *fp , MSA *msa , int cpl ) 
{ 
  int i___0 ;
  int j ;
  int len ;
  int namewidth ;
  int typewidth ;
  int markupwidth ;
  char *buf ;
  int currpos ;
  char *s___0 ;
  char *tok ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  unsigned long tmp___18 ;

  {
  len = 0;
  typewidth = 0;
  markupwidth = 0;
  namewidth = 0;
  i___0 = 0;
  while (i___0 < msa->nseq) {
    tmp = strlen((char const   *)*(msa->sqname + i___0));
    len = (int )tmp;
    if (len > namewidth) {
      namewidth = len;
    }
    i___0 ++;
  }
  if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
    markupwidth = 4;
    typewidth = 2;
  }
  if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
    markupwidth = 4;
    typewidth = 2;
  }
  i___0 = 0;
  while (i___0 < msa->ngr) {
    tmp___0 = strlen((char const   *)*(msa->gr_tag + i___0));
    len = (int )tmp___0;
    if (len > typewidth) {
      typewidth = len;
    }
    i___0 ++;
  }
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
    markupwidth = 4;
    if (typewidth < 2) {
      typewidth = 2;
    }
  }
  if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
    markupwidth = 4;
    if (typewidth < 7) {
      typewidth = 7;
    }
  }
  if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
    markupwidth = 4;
    if (typewidth < 7) {
      typewidth = 7;
    }
  }
  i___0 = 0;
  while (i___0 < msa->ngc) {
    tmp___1 = strlen((char const   *)*(msa->gc_tag + i___0));
    len = (int )tmp___1;
    if (len > typewidth) {
      typewidth = len;
    }
    i___0 ++;
  }
  tmp___2 = sre_malloc((char *)"stockholm.c", 251, sizeof(char ) * (unsigned long )((((cpl + namewidth) + typewidth) + markupwidth) + 61));
  buf = (char *)tmp___2;
  fprintf(fp, "# STOCKHOLM 1.0\n");
  i___0 = 0;
  while (i___0 < msa->ncomment) {
    fprintf(fp, "# %s\n", *(msa->comment + i___0));
    i___0 ++;
  }
  if (msa->ncomment > 0) {
    fprintf(fp, "\n");
  }
  if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
    fprintf(fp, "#=GF ID    %s\n", msa->name);
  }
  if ((unsigned long )msa->acc != (unsigned long )((void *)0)) {
    fprintf(fp, "#=GF AC    %s\n", msa->acc);
  }
  if ((unsigned long )msa->desc != (unsigned long )((void *)0)) {
    fprintf(fp, "#=GF DE    %s\n", msa->desc);
  }
  if ((unsigned long )msa->au != (unsigned long )((void *)0)) {
    fprintf(fp, "#=GF AU    %s\n", msa->au);
  }
  if (msa->cutoff_is_set[2]) {
    if (msa->cutoff_is_set[3]) {
      fprintf(fp, "#=GF GA    %.1f %.1f\n", (double )msa->cutoff[2], (double )msa->cutoff[3]);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (msa->cutoff_is_set[2]) {
    fprintf(fp, "#=GF GA    %.1f\n", (double )msa->cutoff[2]);
  }
  if (msa->cutoff_is_set[4]) {
    if (msa->cutoff_is_set[5]) {
      fprintf(fp, "#=GF NC    %.1f %.1f\n", (double )msa->cutoff[4], (double )msa->cutoff[5]);
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (msa->cutoff_is_set[4]) {
    fprintf(fp, "#=GF NC    %.1f\n", (double )msa->cutoff[4]);
  }
  if (msa->cutoff_is_set[0]) {
    if (msa->cutoff_is_set[1]) {
      fprintf(fp, "#=GF TC    %.1f %.1f\n", (double )msa->cutoff[0], (double )msa->cutoff[1]);
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (msa->cutoff_is_set[0]) {
    fprintf(fp, "#=GF TC    %.1f\n", (double )msa->cutoff[0]);
  }
  i___0 = 0;
  while (i___0 < msa->ngf) {
    fprintf(fp, "#=GF %-5s %s\n", *(msa->gf_tag + i___0), *(msa->gf + i___0));
    i___0 ++;
  }
  fprintf(fp, "\n");
  if (msa->flags & 1) {
    i___0 = 0;
    while (i___0 < msa->nseq) {
      fprintf(fp, "#=GS %-*.*s WT    %.2f\n", namewidth, namewidth, *(msa->sqname + i___0),
              (double )*(msa->wgt + i___0));
      i___0 ++;
    }
    fprintf(fp, "\n");
  }
  if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
    i___0 = 0;
    while (i___0 < msa->nseq) {
      if ((unsigned long )*(msa->sqacc + i___0) != (unsigned long )((void *)0)) {
        fprintf(fp, "#=GS %-*.*s AC    %s\n", namewidth, namewidth, *(msa->sqname + i___0),
                *(msa->sqacc + i___0));
      }
      i___0 ++;
    }
    fprintf(fp, "\n");
  }
  if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
    i___0 = 0;
    while (i___0 < msa->nseq) {
      if ((unsigned long )*(msa->sqdesc + i___0) != (unsigned long )((void *)0)) {
        fprintf(fp, "#=GS %*.*s DE    %s\n", namewidth, namewidth, *(msa->sqname + i___0),
                *(msa->sqdesc + i___0));
      }
      i___0 ++;
    }
    fprintf(fp, "\n");
  }
  i___0 = 0;
  while (i___0 < msa->ngs) {
    j = 0;
    while (j < msa->nseq) {
      if ((unsigned long )*(*(msa->gs + i___0) + j) != (unsigned long )((void *)0)) {
        s___0 = *(*(msa->gs + i___0) + j);
        while (1) {
          tok = sre_strtok(& s___0, (char *)"\n", (int *)((void *)0));
          if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
            break;
          }
          fprintf(fp, "#=GS %*.*s %5s %s\n", namewidth, namewidth, *(msa->sqname + j),
                  *(msa->gs_tag + i___0), tok);
        }
      }
      j ++;
    }
    fprintf(fp, "\n");
    i___0 ++;
  }
  currpos = 0;
  while (currpos < msa->alen) {
    if (currpos > 0) {
      fprintf(fp, "\n");
    }
    i___0 = 0;
    while (i___0 < msa->nseq) {
      tmp___4 = __builtin_object_size((void *)buf, 0);
      if (tmp___4 != 0xffffffffffffffffUL) {
        tmp___3 = __builtin_object_size((void *)buf, 1);
        __builtin___strncpy_chk(buf, (char const   *)(*(msa->aseq + i___0) + currpos),
                                (unsigned long )cpl, tmp___3);
      } else {
        __inline_strncpy_chk(buf, (char const   *)(*(msa->aseq + i___0) + currpos),
                             (size_t )cpl);
      }
      *(buf + cpl) = (char )'\000';
      fprintf(fp, "%-*.*s  %s\n", (namewidth + typewidth) + markupwidth, (namewidth + typewidth) + markupwidth,
              *(msa->sqname + i___0), buf);
      if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
        if ((unsigned long )*(msa->ss + i___0) != (unsigned long )((void *)0)) {
          tmp___6 = __builtin_object_size((void *)buf, 0);
          if (tmp___6 != 0xffffffffffffffffUL) {
            tmp___5 = __builtin_object_size((void *)buf, 1);
            __builtin___strncpy_chk(buf, (char const   *)(*(msa->ss + i___0) + currpos),
                                    (unsigned long )cpl, tmp___5);
          } else {
            __inline_strncpy_chk(buf, (char const   *)(*(msa->ss + i___0) + currpos),
                                 (size_t )cpl);
          }
          *(buf + cpl) = (char )'\000';
          fprintf(fp, "#=GR %-*.*s SS     %s\n", namewidth, namewidth, *(msa->sqname + i___0),
                  buf);
        }
      }
      if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
        if ((unsigned long )*(msa->sa + i___0) != (unsigned long )((void *)0)) {
          tmp___8 = __builtin_object_size((void *)buf, 0);
          if (tmp___8 != 0xffffffffffffffffUL) {
            tmp___7 = __builtin_object_size((void *)buf, 1);
            __builtin___strncpy_chk(buf, (char const   *)(*(msa->sa + i___0) + currpos),
                                    (unsigned long )cpl, tmp___7);
          } else {
            __inline_strncpy_chk(buf, (char const   *)(*(msa->sa + i___0) + currpos),
                                 (size_t )cpl);
          }
          *(buf + cpl) = (char )'\000';
          fprintf(fp, "#=GR %-*.*s SA     %s\n", namewidth, namewidth, *(msa->sqname + i___0),
                  buf);
        }
      }
      j = 0;
      while (j < msa->ngr) {
        if ((unsigned long )*(*(msa->gr + j) + i___0) != (unsigned long )((void *)0)) {
          tmp___10 = __builtin_object_size((void *)buf, 0);
          if (tmp___10 != 0xffffffffffffffffUL) {
            tmp___9 = __builtin_object_size((void *)buf, 1);
            __builtin___strncpy_chk(buf, (char const   *)(*(*(msa->gr + j) + i___0) + currpos),
                                    (unsigned long )cpl, tmp___9);
          } else {
            __inline_strncpy_chk(buf, (char const   *)(*(*(msa->gr + j) + i___0) + currpos),
                                 (size_t )cpl);
          }
          *(buf + cpl) = (char )'\000';
          fprintf(fp, "#=GR %-*.*s %5s  %s\n", namewidth, namewidth, *(msa->sqname + i___0),
                  *(msa->gr_tag + j), buf);
        }
        j ++;
      }
      i___0 ++;
    }
    if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
      tmp___12 = __builtin_object_size((void *)buf, 0);
      if (tmp___12 != 0xffffffffffffffffUL) {
        tmp___11 = __builtin_object_size((void *)buf, 1);
        __builtin___strncpy_chk(buf, (char const   *)(msa->ss_cons + currpos), (unsigned long )cpl,
                                tmp___11);
      } else {
        __inline_strncpy_chk(buf, (char const   *)(msa->ss_cons + currpos), (size_t )cpl);
      }
      *(buf + cpl) = (char )'\000';
      fprintf(fp, "#=GC %-*.*s %s\n", namewidth + typewidth, namewidth + typewidth,
              "SS_cons", buf);
    }
    if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
      tmp___14 = __builtin_object_size((void *)buf, 0);
      if (tmp___14 != 0xffffffffffffffffUL) {
        tmp___13 = __builtin_object_size((void *)buf, 1);
        __builtin___strncpy_chk(buf, (char const   *)(msa->sa_cons + currpos), (unsigned long )cpl,
                                tmp___13);
      } else {
        __inline_strncpy_chk(buf, (char const   *)(msa->sa_cons + currpos), (size_t )cpl);
      }
      *(buf + cpl) = (char )'\000';
      fprintf(fp, "#=GC %-*.*s %s\n", namewidth + typewidth, namewidth + typewidth,
              "SA_cons", buf);
    }
    if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
      tmp___16 = __builtin_object_size((void *)buf, 0);
      if (tmp___16 != 0xffffffffffffffffUL) {
        tmp___15 = __builtin_object_size((void *)buf, 1);
        __builtin___strncpy_chk(buf, (char const   *)(msa->rf + currpos), (unsigned long )cpl,
                                tmp___15);
      } else {
        __inline_strncpy_chk(buf, (char const   *)(msa->rf + currpos), (size_t )cpl);
      }
      *(buf + cpl) = (char )'\000';
      fprintf(fp, "#=GC %-*.*s %s\n", namewidth + typewidth, namewidth + typewidth,
              "RF", buf);
    }
    j = 0;
    while (j < msa->ngc) {
      tmp___18 = __builtin_object_size((void *)buf, 0);
      if (tmp___18 != 0xffffffffffffffffUL) {
        tmp___17 = __builtin_object_size((void *)buf, 1);
        __builtin___strncpy_chk(buf, (char const   *)(*(msa->gc + j) + currpos), (unsigned long )cpl,
                                tmp___17);
      } else {
        __inline_strncpy_chk(buf, (char const   *)(*(msa->gc + j) + currpos), (size_t )cpl);
      }
      *(buf + cpl) = (char )'\000';
      fprintf(fp, "#=GC %-*.*s %s\n", namewidth + typewidth, namewidth + typewidth,
              *(msa->gc_tag + j), buf);
      j ++;
    }
    currpos += cpl;
  }
  fprintf(fp, "//\n");
  free((void *)buf);
  return;
}
}
static int parse_gf(MSA *msa , char *buf ) 
{ 
  char *gf ;
  char *featurename ;
  char *text ;
  char *s___0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  s___0 = buf;
  gf = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
  if ((unsigned long )gf == (unsigned long )((void *)0)) {
    return (0);
  }
  featurename = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
  if ((unsigned long )featurename == (unsigned long )((void *)0)) {
    return (0);
  }
  text = sre_strtok(& s___0, (char *)"\n", (int *)((void *)0));
  if ((unsigned long )text == (unsigned long )((void *)0)) {
    return (0);
  }
  while (1) {
    if (*text) {
      if (! ((int )*text == 32)) {
        if (! ((int )*text == 9)) {
          break;
        }
      }
    } else {
      break;
    }
    text ++;
  }
  tmp___11 = strcmp((char const   *)featurename, "ID");
  if (tmp___11 == 0) {
    msa->name = sre_strdup(text, -1);
  } else {
    tmp___10 = strcmp((char const   *)featurename, "AC");
    if (tmp___10 == 0) {
      msa->acc = sre_strdup(text, -1);
    } else {
      tmp___9 = strcmp((char const   *)featurename, "DE");
      if (tmp___9 == 0) {
        msa->desc = sre_strdup(text, -1);
      } else {
        tmp___8 = strcmp((char const   *)featurename, "AU");
        if (tmp___8 == 0) {
          msa->au = sre_strdup(text, -1);
        } else {
          tmp___7 = strcmp((char const   *)featurename, "GA");
          if (tmp___7 == 0) {
            s___0 = text;
            text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
            if ((unsigned long )text == (unsigned long )((void *)0)) {
              return (0);
            }
            tmp = atof((char const   *)text);
            msa->cutoff[2] = (float )tmp;
            msa->cutoff_is_set[2] = 1;
            text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
            if ((unsigned long )text != (unsigned long )((void *)0)) {
              tmp___0 = atof((char const   *)text);
              msa->cutoff[3] = (float )tmp___0;
              msa->cutoff_is_set[3] = 1;
            }
          } else {
            tmp___6 = strcmp((char const   *)featurename, "NC");
            if (tmp___6 == 0) {
              s___0 = text;
              text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
              if ((unsigned long )text == (unsigned long )((void *)0)) {
                return (0);
              }
              tmp___1 = atof((char const   *)text);
              msa->cutoff[4] = (float )tmp___1;
              msa->cutoff_is_set[4] = 1;
              text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
              if ((unsigned long )text != (unsigned long )((void *)0)) {
                tmp___2 = atof((char const   *)text);
                msa->cutoff[5] = (float )tmp___2;
                msa->cutoff_is_set[5] = 1;
              }
            } else {
              tmp___5 = strcmp((char const   *)featurename, "TC");
              if (tmp___5 == 0) {
                s___0 = text;
                text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
                if ((unsigned long )text == (unsigned long )((void *)0)) {
                  return (0);
                }
                tmp___3 = atof((char const   *)text);
                msa->cutoff[0] = (float )tmp___3;
                msa->cutoff_is_set[0] = 1;
                text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
                if ((unsigned long )text != (unsigned long )((void *)0)) {
                  tmp___4 = atof((char const   *)text);
                  msa->cutoff[1] = (float )tmp___4;
                  msa->cutoff_is_set[1] = 1;
                }
              } else {
                MSAAddGF(msa, featurename, text);
              }
            }
          }
        }
      }
    }
  }
  return (1);
}
}
static int parse_gs(MSA *msa , char *buf ) 
{ 
  char *gs ;
  char *seqname ;
  char *featurename ;
  char *text ;
  int seqidx ;
  char *s___0 ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  s___0 = buf;
  gs = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
  if ((unsigned long )gs == (unsigned long )((void *)0)) {
    return (0);
  }
  seqname = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
  if ((unsigned long )seqname == (unsigned long )((void *)0)) {
    return (0);
  }
  featurename = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
  if ((unsigned long )featurename == (unsigned long )((void *)0)) {
    return (0);
  }
  text = sre_strtok(& s___0, (char *)"\n", (int *)((void *)0));
  if ((unsigned long )text == (unsigned long )((void *)0)) {
    return (0);
  }
  while (1) {
    if (*text) {
      if (! ((int )*text == 32)) {
        if (! ((int )*text == 9)) {
          break;
        }
      }
    } else {
      break;
    }
    text ++;
  }
  seqidx = MSAGetSeqidx(msa, seqname, msa->lastidx + 1);
  msa->lastidx = seqidx;
  tmp___2 = strcmp((char const   *)featurename, "WT");
  if (tmp___2 == 0) {
    tmp = atof((char const   *)text);
    *(msa->wgt + seqidx) = (float )tmp;
    msa->flags |= 1;
  } else {
    tmp___1 = strcmp((char const   *)featurename, "AC");
    if (tmp___1 == 0) {
      MSASetSeqAccession(msa, seqidx, text);
    } else {
      tmp___0 = strcmp((char const   *)featurename, "DE");
      if (tmp___0 == 0) {
        MSASetSeqDescription(msa, seqidx, text);
      } else {
        MSAAddGS(msa, featurename, seqidx, text);
      }
    }
  }
  return (1);
}
}
static int parse_gc(MSA *msa , char *buf ) 
{ 
  char *gc ;
  char *featurename ;
  char *text ;
  char *s___0 ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  s___0 = buf;
  gc = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
  if ((unsigned long )gc == (unsigned long )((void *)0)) {
    return (0);
  }
  featurename = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
  if ((unsigned long )featurename == (unsigned long )((void *)0)) {
    return (0);
  }
  text = sre_strtok(& s___0, (char *)" \t\n", & len);
  if ((unsigned long )text == (unsigned long )((void *)0)) {
    return (0);
  }
  tmp___1 = strcmp((char const   *)featurename, "SS_cons");
  if (tmp___1 == 0) {
    sre_strcat(& msa->ss_cons, -1, text, len);
  } else {
    tmp___0 = strcmp((char const   *)featurename, "SA_cons");
    if (tmp___0 == 0) {
      sre_strcat(& msa->sa_cons, -1, text, len);
    } else {
      tmp = strcmp((char const   *)featurename, "RF");
      if (tmp == 0) {
        sre_strcat(& msa->rf, -1, text, len);
      } else {
        MSAAppendGC(msa, featurename, text);
      }
    }
  }
  return (1);
}
}
static int parse_gr(MSA *msa , char *buf ) 
{ 
  char *gr ;
  char *seqname ;
  char *featurename ;
  char *text ;
  int seqidx ;
  int len ;
  int j ;
  char *s___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  s___0 = buf;
  gr = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
  if ((unsigned long )gr == (unsigned long )((void *)0)) {
    return (0);
  }
  seqname = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
  if ((unsigned long )seqname == (unsigned long )((void *)0)) {
    return (0);
  }
  featurename = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
  if ((unsigned long )featurename == (unsigned long )((void *)0)) {
    return (0);
  }
  text = sre_strtok(& s___0, (char *)" \t\n", & len);
  if ((unsigned long )text == (unsigned long )((void *)0)) {
    return (0);
  }
  seqidx = MSAGetSeqidx(msa, seqname, msa->lastidx);
  msa->lastidx = seqidx;
  tmp___4 = strcmp((char const   *)featurename, "SS");
  if (tmp___4 == 0) {
    if ((unsigned long )msa->ss == (unsigned long )((void *)0)) {
      tmp = sre_malloc((char *)"stockholm.c", 561, sizeof(char *) * (unsigned long )msa->nseqalloc);
      msa->ss = (char **)tmp;
      tmp___0 = sre_malloc((char *)"stockholm.c", 562, sizeof(int ) * (unsigned long )msa->nseqalloc);
      msa->sslen = (int *)tmp___0;
      j = 0;
      while (j < msa->nseqalloc) {
        *(msa->ss + j) = (char *)((void *)0);
        *(msa->sslen + j) = 0;
        j ++;
      }
    }
    *(msa->sslen + seqidx) = sre_strcat(msa->ss + seqidx, *(msa->sslen + seqidx),
                                        text, len);
  } else {
    tmp___3 = strcmp((char const   *)featurename, "SA");
    if (tmp___3 == 0) {
      if ((unsigned long )msa->sa == (unsigned long )((void *)0)) {
        tmp___1 = sre_malloc((char *)"stockholm.c", 575, sizeof(char *) * (unsigned long )msa->nseqalloc);
        msa->sa = (char **)tmp___1;
        tmp___2 = sre_malloc((char *)"stockholm.c", 576, sizeof(int ) * (unsigned long )msa->nseqalloc);
        msa->salen = (int *)tmp___2;
        j = 0;
        while (j < msa->nseqalloc) {
          *(msa->sa + j) = (char *)((void *)0);
          *(msa->salen + j) = 0;
          j ++;
        }
      }
      *(msa->salen + seqidx) = sre_strcat(msa->sa + seqidx, *(msa->salen + seqidx),
                                          text, len);
    } else {
      MSAAppendGR(msa, featurename, seqidx, text);
    }
  }
  return (1);
}
}
static int parse_comment(MSA *msa , char *buf ) 
{ 
  char *s___0 ;
  char *comment ;

  {
  s___0 = buf + 1;
  if ((int )*s___0 == 10) {
    *s___0 = (char )'\000';
    comment = s___0;
  } else {
    comment = sre_strtok(& s___0, (char *)"\n", (int *)((void *)0));
    if ((unsigned long )comment == (unsigned long )((void *)0)) {
      return (0);
    }
  }
  MSAAddComment(msa, comment);
  return (1);
}
}
static int parse_sequence(MSA *msa , char *buf ) 
{ 
  char *s___0 ;
  char *seqname ;
  char *text ;
  int seqidx ;
  int len ;

  {
  s___0 = buf;
  seqname = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
  if ((unsigned long )seqname == (unsigned long )((void *)0)) {
    return (0);
  }
  text = sre_strtok(& s___0, (char *)" \t\n", & len);
  if ((unsigned long )text == (unsigned long )((void *)0)) {
    return (0);
  }
  seqidx = MSAGetSeqidx(msa, seqname, msa->lastidx + 1);
  msa->lastidx = seqidx;
  *(msa->sqlen + seqidx) = sre_strcat(msa->aseq + seqidx, *(msa->sqlen + seqidx),
                                      text, len);
  return (1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Yho15D6h.i","-O3")
char *Translate(char *seq , char **code ) ;
char *Translate(char *seq , char **code ) 
{ 
  int codon ;
  char *aaseq ;
  char *aaptr ;
  int i___0 ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;

  {
  if ((unsigned long )seq == (unsigned long )((void *)0)) {
    squid_errno = 2;
    return ((char *)((void *)0));
  }
  tmp = strlen((char const   *)seq);
  tmp___0 = calloc(tmp + 1UL, sizeof(char ));
  aaseq = (char *)tmp___0;
  if ((unsigned long )aaseq == (unsigned long )((void *)0)) {
    Die((char *)"calloc failed");
  }
  aaptr = aaseq;
  while (1) {
    if ((int )*seq != 0) {
      if ((int )*(seq + 1) != 0) {
        if (! ((int )*(seq + 2) != 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    codon = 0;
    i___0 = 0;
    while (i___0 < 3) {
      codon *= 4;
      switch ((int )*(seq + i___0)) {
      case 97: 
      case 65: 
      break;
      case 99: 
      case 67: 
      codon ++;
      break;
      case 103: 
      case 71: 
      codon += 2;
      break;
      case 116: 
      case 84: 
      codon += 3;
      break;
      case 117: 
      case 85: 
      codon += 3;
      break;
      default: 
      codon = 64;
      break;
      }
      if (codon == 64) {
        break;
      }
      i___0 ++;
    }
    tmp___2 = __builtin_object_size((void *)aaptr, 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)aaptr, 1);
      __builtin___strcpy_chk(aaptr, (char const   *)*(code + codon), tmp___1);
    } else {
      __inline_strcpy_chk(aaptr, (char const   *)*(code + codon));
    }
    tmp___3 = strlen((char const   *)*(code + codon));
    aaptr += tmp___3;
    seq += 3;
  }
  return (aaseq);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-7gCCz3OF.i","-O3")
__inline static int isxdigit(int _c ) 
{ 
  __darwin_ct_rune_t tmp ;

  {
  tmp = __isctype(_c, 65536UL);
  return (tmp);
}
}
void Byteswap(char *swap , int nbytes ) ;
int IsInt(char *s___0 ) 
{ 
  int hex ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  hex = 0;
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    squid_errno = 6;
    return (0);
  }
  while (1) {
    tmp = isspace((int )*s___0);
    if (! tmp) {
      break;
    }
    s___0 ++;
  }
  if ((int )*s___0 == 45) {
    s___0 ++;
  } else
  if ((int )*s___0 == 43) {
    s___0 ++;
  }
  tmp___1 = strncmp((char const   *)s___0, "0x", (size_t )2);
  if (tmp___1 == 0) {
    tmp___2 = strlen((char const   *)s___0);
    if ((int )tmp___2 > 2) {
      s___0 += 2;
      hex = 1;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    tmp___3 = strncmp((char const   *)s___0, "0X", (size_t )2);
    if (tmp___3 == 0) {
      tmp___4 = strlen((char const   *)s___0);
      if ((int )tmp___4 > 2) {
        s___0 += 2;
        hex = 1;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((int )*s___0 == 48) {
      tmp___0 = strlen((char const   *)s___0);
      if ((int )tmp___0 > 1) {
        s___0 ++;
      }
    }
  }
  if (! hex) {
    while ((int )*s___0 != 0) {
      tmp___5 = isdigit((int )*s___0);
      if (! tmp___5) {
        return (0);
      }
      s___0 ++;
    }
  } else {
    while ((int )*s___0 != 0) {
      tmp___6 = isxdigit((int )*s___0);
      if (! tmp___6) {
        return (0);
      }
      s___0 ++;
    }
  }
  return (1);
}
}
int IsReal(char *s___0 ) 
{ 
  int gotdecimal ;
  int gotexp ;
  int gotreal ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  gotdecimal = 0;
  gotexp = 0;
  gotreal = 0;
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    return (0);
  }
  while (1) {
    tmp = isspace((int )*s___0);
    if (! tmp) {
      break;
    }
    s___0 ++;
  }
  if ((int )*s___0 == 45) {
    s___0 ++;
  } else
  if ((int )*s___0 == 43) {
    s___0 ++;
  }
  while ((int )*s___0 != 0) {
    tmp___1 = isdigit((int )*s___0);
    if (tmp___1) {
      gotreal ++;
    } else
    if ((int )*s___0 == 46) {
      if (gotdecimal) {
        return (0);
      }
      if (gotexp) {
        return (0);
      } else {
        gotdecimal ++;
      }
    } else
    if ((int )*s___0 == 101) {
      goto _L;
    } else
    if ((int )*s___0 == 69) {
      _L: /* CIL Label */ 
      if (gotexp) {
        return (0);
      } else {
        gotexp ++;
      }
    } else {
      tmp___0 = isspace((int )*s___0);
      if (tmp___0) {
        break;
      }
    }
    s___0 ++;
  }
  while (1) {
    tmp___2 = isspace((int )*s___0);
    if (! tmp___2) {
      break;
    }
    s___0 ++;
  }
  if ((int )*s___0 == 0) {
    if (gotreal) {
      return (1);
    } else {
      return (0);
    }
  } else {
    return (0);
  }
}
}
void Byteswap(char *swap , int nbytes ) 
{ 
  int x ;
  char byte ;

  {
  x = 0;
  while (x < nbytes / 2) {
    byte = *(swap + ((nbytes - x) - 1));
    *(swap + ((nbytes - x) - 1)) = *(swap + x);
    *(swap + x) = byte;
    x ++;
  }
  return;
}
}
sqd_uint16 sre_ntoh16(sqd_uint16 netshort ) 
{ 


  {
  return (netshort);
}
}
sqd_uint32 sre_ntoh32(sqd_uint32 netlong ) 
{ 


  {
  return (netlong);
}
}
sqd_uint16 sre_hton16(sqd_uint16 hostshort ) 
{ 


  {
  return (hostshort);
}
}
sqd_uint32 sre_hton32(sqd_uint32 hostlong ) 
{ 


  {
  return (hostlong);
}
}
sqd_uint64 sre_ntoh64(sqd_uint64 net_int64 ) 
{ 


  {
  return (net_int64);
}
}
sqd_uint64 sre_hton64(sqd_uint64 host_int64 ) 
{ 


  {
  return (host_int64);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-JdfTQaHG.i","-O3")
void DSet(double *vec , int n , double value ) ;
void DScale(double *vec , int n , double scale ) ;
double DSum(double *vec , int n ) ;
void DAdd(double *vec1 , double *vec2 , int n ) ;
void DCopy(double *vec1 , double *vec2 , int n ) ;
double DDot(double *vec1 , double *vec2 , int n ) ;
double DMax(double *vec , int n ) ;
float FMax(float *vec , int n ) ;
double DMin(double *vec , int n ) ;
float FMin(float *vec , int n ) ;
int DArgMax(double *vec , int n ) ;
int DArgMin(double *vec , int n ) ;
int FArgMin(float *vec , int n ) ;
void DNorm(double *vec , int n ) ;
void DLog(double *vec , int n ) ;
void FLog(float *vec , int n ) ;
void DExp(double *vec , int n ) ;
void FExp(float *vec , int n ) ;
double DLogSum(double *vec , int n ) ;
float FLogSum(float *vec , int n ) ;
void DSet(double *vec , int n , double value ) 
{ 
  int x ;

  {
  x = 0;
  while (x < n) {
    *(vec + x) = value;
    x ++;
  }
  return;
}
}
void FSet(float *vec , int n , float value ) 
{ 
  int x ;

  {
  x = 0;
  while (x < n) {
    *(vec + x) = value;
    x ++;
  }
  return;
}
}
void DScale(double *vec , int n , double scale ) 
{ 
  int x ;

  {
  x = 0;
  while (x < n) {
    *(vec + x) *= scale;
    x ++;
  }
  return;
}
}
void FScale(float *vec , int n , float scale ) 
{ 
  int x ;

  {
  x = 0;
  while (x < n) {
    *(vec + x) *= scale;
    x ++;
  }
  return;
}
}
double DSum(double *vec , int n ) 
{ 
  double sum ;
  int x ;

  {
  sum = 0.;
  x = 0;
  while (x < n) {
    sum += *(vec + x);
    x ++;
  }
  return (sum);
}
}
float FSum(float *vec , int n ) 
{ 
  float sum ;
  int x ;

  {
  sum = (float )0.;
  x = 0;
  while (x < n) {
    sum += *(vec + x);
    x ++;
  }
  return (sum);
}
}
void DAdd(double *vec1 , double *vec2 , int n ) 
{ 
  int x ;

  {
  x = 0;
  while (x < n) {
    *(vec1 + x) += *(vec2 + x);
    x ++;
  }
  return;
}
}
void FAdd(float *vec1 , float *vec2 , int n ) 
{ 
  int x ;

  {
  x = 0;
  while (x < n) {
    *(vec1 + x) += *(vec2 + x);
    x ++;
  }
  return;
}
}
void DCopy(double *vec1 , double *vec2 , int n ) 
{ 
  int x ;

  {
  x = 0;
  while (x < n) {
    *(vec1 + x) = *(vec2 + x);
    x ++;
  }
  return;
}
}
void FCopy(float *vec1 , float *vec2 , int n ) 
{ 
  int x ;

  {
  x = 0;
  while (x < n) {
    *(vec1 + x) = *(vec2 + x);
    x ++;
  }
  return;
}
}
double DDot(double *vec1 , double *vec2 , int n ) 
{ 
  double result ;
  int x ;

  {
  result = 0.;
  x = 0;
  while (x < n) {
    result += *(vec1 + x) * *(vec2 + x);
    x ++;
  }
  return (result);
}
}
float FDot(float *vec1 , float *vec2 , int n ) 
{ 
  float result ;
  int x ;

  {
  result = (float )0.;
  x = 0;
  while (x < n) {
    result += *(vec1 + x) * *(vec2 + x);
    x ++;
  }
  return (result);
}
}
double DMax(double *vec , int n ) 
{ 
  int i___0 ;
  double best ;

  {
  best = *(vec + 0);
  i___0 = 1;
  while (i___0 < n) {
    if (*(vec + i___0) > best) {
      best = *(vec + i___0);
    }
    i___0 ++;
  }
  return (best);
}
}
float FMax(float *vec , int n ) 
{ 
  int i___0 ;
  float best ;

  {
  best = *(vec + 0);
  i___0 = 1;
  while (i___0 < n) {
    if (*(vec + i___0) > best) {
      best = *(vec + i___0);
    }
    i___0 ++;
  }
  return (best);
}
}
double DMin(double *vec , int n ) 
{ 
  int i___0 ;
  double best ;

  {
  best = *(vec + 0);
  i___0 = 1;
  while (i___0 < n) {
    if (*(vec + i___0) < best) {
      best = *(vec + i___0);
    }
    i___0 ++;
  }
  return (best);
}
}
float FMin(float *vec , int n ) 
{ 
  int i___0 ;
  float best ;

  {
  best = *(vec + 0);
  i___0 = 1;
  while (i___0 < n) {
    if (*(vec + i___0) < best) {
      best = *(vec + i___0);
    }
    i___0 ++;
  }
  return (best);
}
}
int DArgMax(double *vec , int n ) 
{ 
  int i___0 ;
  int best ;

  {
  best = 0;
  i___0 = 1;
  while (i___0 < n) {
    if (*(vec + i___0) > *(vec + best)) {
      best = i___0;
    }
    i___0 ++;
  }
  return (best);
}
}
int FArgMax(float *vec , int n ) 
{ 
  int i___0 ;
  int best ;

  {
  best = 0;
  i___0 = 1;
  while (i___0 < n) {
    if (*(vec + i___0) > *(vec + best)) {
      best = i___0;
    }
    i___0 ++;
  }
  return (best);
}
}
int DArgMin(double *vec , int n ) 
{ 
  int i___0 ;
  int best ;

  {
  best = 0;
  i___0 = 1;
  while (i___0 < n) {
    if (*(vec + i___0) < *(vec + best)) {
      best = i___0;
    }
    i___0 ++;
  }
  return (best);
}
}
int FArgMin(float *vec , int n ) 
{ 
  int i___0 ;
  int best ;

  {
  best = 0;
  i___0 = 1;
  while (i___0 < n) {
    if (*(vec + i___0) < *(vec + best)) {
      best = i___0;
    }
    i___0 ++;
  }
  return (best);
}
}
void DNorm(double *vec , int n ) 
{ 
  int x ;
  double sum ;

  {
  sum = DSum(vec, n);
  if (sum != 0.0) {
    x = 0;
    while (x < n) {
      *(vec + x) /= sum;
      x ++;
    }
  } else {
    x = 0;
    while (x < n) {
      *(vec + x) = 1. / (double )n;
      x ++;
    }
  }
  return;
}
}
void FNorm(float *vec , int n ) 
{ 
  int x ;
  float sum ;

  {
  sum = FSum(vec, n);
  if ((double )sum != 0.0) {
    x = 0;
    while (x < n) {
      *(vec + x) /= sum;
      x ++;
    }
  } else {
    x = 0;
    while (x < n) {
      *(vec + x) = (float )(1. / (double )((float )n));
      x ++;
    }
  }
  return;
}
}
void DLog(double *vec , int n ) 
{ 
  int x ;

  {
  x = 0;
  while (x < n) {
    if (*(vec + x) > 0.) {
      *(vec + x) = log(*(vec + x));
    } else {
      *(vec + x) = - 1.7976931348623157e+308;
    }
    x ++;
  }
  return;
}
}
void FLog(float *vec , int n ) 
{ 
  int x ;
  double tmp ;

  {
  x = 0;
  while (x < n) {
    if ((double )*(vec + x) > 0.) {
      tmp = log((double )*(vec + x));
      *(vec + x) = (float )tmp;
    } else {
      *(vec + x) = - 3.40282347e+38F;
    }
    x ++;
  }
  return;
}
}
void DExp(double *vec , int n ) 
{ 
  int x ;

  {
  x = 0;
  while (x < n) {
    *(vec + x) = exp(*(vec + x));
    x ++;
  }
  return;
}
}
void FExp(float *vec , int n ) 
{ 
  int x ;
  double tmp ;

  {
  x = 0;
  while (x < n) {
    tmp = exp((double )*(vec + x));
    *(vec + x) = (float )tmp;
    x ++;
  }
  return;
}
}
double DLogSum(double *vec , int n ) 
{ 
  int x ;
  double max ;
  double sum ;
  double tmp ;
  double tmp___0 ;

  {
  max = DMax(vec, n);
  sum = 0.0;
  x = 0;
  while (x < n) {
    if (*(vec + x) > max - 50.) {
      tmp = exp(*(vec + x) - max);
      sum += tmp;
    }
    x ++;
  }
  tmp___0 = log(sum);
  sum = tmp___0 + max;
  return (sum);
}
}
float FLogSum(float *vec , int n ) 
{ 
  int x ;
  float max ;
  float sum ;
  double tmp ;
  double tmp___0 ;

  {
  max = FMax(vec, n);
  sum = (float )0.0;
  x = 0;
  while (x < n) {
    if ((double )*(vec + x) > (double )max - 50.) {
      tmp = exp((double )(*(vec + x) - max));
      sum = (float )((double )sum + tmp);
    }
    x ++;
  }
  tmp___0 = log((double )sum);
  sum = (float )(tmp___0 + (double )max);
  return (sum);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-6o2X9jCa.i","-O3")
void GSCWeights(char **aseq , int nseq , int alen , float *wgt ) ;
void VoronoiWeights(char **aseq , int nseq , int alen , float *wgt ) ;
void BlosumWeights(char **aseqs , int nseq , int alen , float maxid , float *wgt ) ;
void PositionBasedWeights(char **aseq , int nseq , int alen , float *wgt ) ;
void FilterAlignment(MSA *msa , float cutoff , MSA **ret_new ) ;
void SampleAlignment(MSA *msa , int sample , MSA **ret_new ) ;
void SingleLinkCluster(char **aseq , int nseq , int alen , float maxid , int **ret_c ,
                       int *ret_nc ) ;
static void upweight(struct phylo_s *tree , int nseq , float *lwt , float *rwt , int node ) ;
static void downweight(struct phylo_s *tree , int nseq , float *lwt , float *rwt ,
                       float *fwt , int node ) ;
static float simple_distance(char *s1 , char *s2 ) ;
static int simple_diffmx(char **aseqs , int num , float ***ret_dmx ) ;
void GSCWeights(char **aseq , int nseq , int alen , float *wgt ) 
{ 
  float **dmx ;
  struct phylo_s *tree ;
  float *lwt ;
  float *rwt ;
  float *fwt ;
  int i___0 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  float tmp___3 ;

  {
  if (nseq == 1) {
    *(wgt + 0) = (float )1.0;
    return;
  }
  MakeDiffMx(aseq, nseq, & dmx);
  tmp = Cluster(dmx, nseq, (enum clust_strategy )2, & tree);
  if (! tmp) {
    Die((char *)"Cluster() failed");
  }
  tmp___0 = sre_malloc((char *)"weight.c", 67, sizeof(float ) * (unsigned long )(2 * nseq - 1));
  lwt = (float *)tmp___0;
  tmp___1 = sre_malloc((char *)"weight.c", 68, sizeof(float ) * (unsigned long )(2 * nseq - 1));
  rwt = (float *)tmp___1;
  tmp___2 = sre_malloc((char *)"weight.c", 69, sizeof(float ) * (unsigned long )(2 * nseq - 1));
  fwt = (float *)tmp___2;
  i___0 = 0;
  while (i___0 < nseq) {
    tmp___3 = (float )0.0;
    *(rwt + i___0) = tmp___3;
    *(lwt + i___0) = tmp___3;
    i___0 ++;
  }
  upweight(tree, nseq, lwt, rwt, nseq);
  *(fwt + nseq) = (float )nseq;
  downweight(tree, nseq, lwt, rwt, fwt, nseq);
  i___0 = 0;
  while (i___0 < nseq) {
    *(wgt + i___0) = *(fwt + i___0);
    i___0 ++;
  }
  FMX2Free(dmx);
  FreePhylo(tree, nseq);
  free((void *)lwt);
  free((void *)rwt);
  free((void *)fwt);
  return;
}
}
static void upweight(struct phylo_s *tree , int nseq , float *lwt , float *rwt , int node ) 
{ 
  int ld ;
  int rd ;

  {
  ld = (tree + (node - nseq))->left;
  if (ld >= nseq) {
    upweight(tree, nseq, lwt, rwt, ld);
  }
  rd = (tree + (node - nseq))->right;
  if (rd >= nseq) {
    upweight(tree, nseq, lwt, rwt, rd);
  }
  *(lwt + node) = (*(lwt + ld) + *(rwt + ld)) + (tree + (node - nseq))->lblen;
  *(rwt + node) = (*(lwt + rd) + *(rwt + rd)) + (tree + (node - nseq))->rblen;
  return;
}
}
static void downweight(struct phylo_s *tree , int nseq , float *lwt , float *rwt ,
                       float *fwt , int node ) 
{ 
  int ld ;
  int rd ;
  float lnum ;
  float rnum ;

  {
  ld = (tree + (node - nseq))->left;
  rd = (tree + (node - nseq))->right;
  if ((double )(*(lwt + node) + *(rwt + node)) > 0.0) {
    *(fwt + ld) = *(fwt + node) * (*(lwt + node) / (*(lwt + node) + *(rwt + node)));
    *(fwt + rd) = *(fwt + node) * (*(rwt + node) / (*(lwt + node) + *(rwt + node)));
  } else {
    if (ld >= nseq) {
      lnum = (float )(tree + (ld - nseq))->incnum;
    } else {
      lnum = (float )1.0;
    }
    if (rd >= nseq) {
      rnum = (float )(tree + (rd - nseq))->incnum;
    } else {
      rnum = (float )1.0;
    }
    *(fwt + ld) = (*(fwt + node) * lnum) / (lnum + rnum);
    *(fwt + rd) = (*(fwt + node) * rnum) / (lnum + rnum);
  }
  if (ld >= nseq) {
    downweight(tree, nseq, lwt, rwt, fwt, ld);
  }
  if (rd >= nseq) {
    downweight(tree, nseq, lwt, rwt, fwt, rd);
  }
  return;
}
}
void VoronoiWeights(char **aseq , int nseq , int alen , float *wgt ) 
{ 
  float **dmx ;
  float *halfmin ;
  char **psym ;
  int *nsym ;
  int symseen[27] ;
  char *randseq ;
  int acol ;
  int idx ;
  int symidx ;
  int i___0 ;
  float min ;
  float dist ;
  float challenge ;
  float champion ;
  int itscale ;
  int iteration ;
  int best ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;

  {
  if (nseq == 1) {
    *(wgt + 0) = (float )1.0;
    return;
  }
  itscale = 50;
  tmp = simple_diffmx(aseq, nseq, & dmx);
  if (! tmp) {
    Die((char *)"simple_diffmx() failed");
  }
  tmp___0 = sre_malloc((char *)"weight.c", 184, sizeof(float ) * (unsigned long )nseq);
  halfmin = (float *)tmp___0;
  idx = 0;
  while (idx < nseq) {
    min = (float )1.0;
    i___0 = 0;
    while (i___0 < nseq) {
      if (i___0 == idx) {
        goto __Cont;
      }
      if (*(*(dmx + idx) + i___0) < min) {
        min = *(*(dmx + idx) + i___0);
      }
      __Cont: /* CIL Label */ 
      i___0 ++;
    }
    *(halfmin + idx) = (float )((double )min / 2.0);
    idx ++;
  }
  Free2DArray((void **)dmx, nseq);
  tmp___1 = sre_malloc((char *)"weight.c", 198, (unsigned long )alen * sizeof(char *));
  psym = (char **)tmp___1;
  tmp___2 = sre_malloc((char *)"weight.c", 199, (unsigned long )alen * sizeof(int ));
  nsym = (int *)tmp___2;
  acol = 0;
  while (acol < alen) {
    tmp___3 = sre_malloc((char *)"weight.c", 201, 27UL * sizeof(char ));
    *(psym + acol) = (char *)tmp___3;
    acol ++;
  }
  acol = 0;
  while (acol < alen) {
    tmp___5 = __builtin_object_size((void *)(symseen), 0);
    if (tmp___5 != 0xffffffffffffffffUL) {
      tmp___4 = __builtin_object_size((void *)(symseen), 0);
      __builtin___memset_chk((void *)(symseen), 0, sizeof(int ) * 27UL, tmp___4);
    } else {
      __inline_memset_chk((void *)(symseen), 0, sizeof(int ) * 27UL);
    }
    idx = 0;
    while (idx < nseq) {
      if ((int )*(*(aseq + idx) + acol) == 32) {
        symseen[26] = 1;
      } else
      if ((int )*(*(aseq + idx) + acol) == 46) {
        symseen[26] = 1;
      } else
      if ((int )*(*(aseq + idx) + acol) == 95) {
        symseen[26] = 1;
      } else
      if ((int )*(*(aseq + idx) + acol) == 45) {
        symseen[26] = 1;
      } else
      if ((int )*(*(aseq + idx) + acol) == 126) {
        symseen[26] = 1;
      } else {
        tmp___6 = isupper((int )*(*(aseq + idx) + acol));
        if (tmp___6) {
          symidx = (int )*(*(aseq + idx) + acol) - 65;
        } else {
          symidx = (int )*(*(aseq + idx) + acol) - 97;
        }
        if (symidx >= 0) {
          if (symidx < 26) {
            symseen[symidx] = 1;
          }
        }
      }
      idx ++;
    }
    *(nsym + acol) = 0;
    i___0 = 0;
    while (i___0 < 26) {
      if (symseen[i___0]) {
        *(*(psym + acol) + *(nsym + acol)) = (char )(65 + i___0);
        (*(nsym + acol)) ++;
      }
      i___0 ++;
    }
    if (symseen[26]) {
      *(*(psym + acol) + *(nsym + acol)) = (char )' ';
      (*(nsym + acol)) ++;
    }
    acol ++;
  }
  tmp___7 = sre_malloc((char *)"weight.c", 268, (unsigned long )(alen + 1) * sizeof(char ));
  randseq = (char *)tmp___7;
  best = (int )42.;
  FSet(wgt, nseq, (float )0.0);
  iteration = 0;
  while (iteration < itscale * nseq) {
    acol = 0;
    while (acol < alen) {
      if (*(nsym + acol) == 0) {
        *(randseq + acol) = (char )' ';
      } else {
        tmp___8 = sre_random();
        *(randseq + acol) = *(*(psym + acol) + (int )(tmp___8 * (double )*(nsym + acol)));
      }
      acol ++;
    }
    *(randseq + acol) = (char )'\000';
    tmp___9 = sre_random();
    champion = (float )tmp___9;
    min = (float )1.0;
    idx = 0;
    while (idx < nseq) {
      dist = simple_distance(*(aseq + idx), randseq);
      if (dist < *(halfmin + idx)) {
        best = idx;
        break;
      }
      if (dist < min) {
        tmp___10 = sre_random();
        champion = (float )tmp___10;
        best = idx;
        min = dist;
      } else
      if (dist == min) {
        tmp___11 = sre_random();
        challenge = (float )tmp___11;
        if (challenge > champion) {
          champion = challenge;
          best = idx;
          min = dist;
        }
      }
      idx ++;
    }
    *(wgt + best) = (float )((double )*(wgt + best) + 1.0);
    iteration ++;
  }
  idx = 0;
  while (idx < nseq) {
    *(wgt + idx) /= (float )itscale;
    idx ++;
  }
  free((void *)randseq);
  free((void *)nsym);
  free((void *)halfmin);
  Free2DArray((void **)psym, alen);
  return;
}
}
static float simple_distance(char *s1 , char *s2 ) 
{ 
  int diff ;
  int valid ;
  double tmp ;

  {
  diff = 0;
  valid = 0;
  while ((int )*s1 != 0) {
    if ((int )*s1 == 32) {
      goto __Cont;
    } else
    if ((int )*s1 == 46) {
      goto __Cont;
    } else
    if ((int )*s1 == 95) {
      goto __Cont;
    } else
    if ((int )*s1 == 45) {
      goto __Cont;
    } else
    if ((int )*s1 == 126) {
      goto __Cont;
    } else
    if ((int )*s2 == 32) {
      goto __Cont;
    } else
    if ((int )*s2 == 46) {
      goto __Cont;
    } else
    if ((int )*s2 == 95) {
      goto __Cont;
    } else
    if ((int )*s2 == 45) {
      goto __Cont;
    } else
    if ((int )*s2 == 126) {
      goto __Cont;
    }
    if ((int )*s1 != (int )*s2) {
      diff ++;
    }
    valid ++;
    __Cont: /* CIL Label */ 
    s1 ++;
    s2 ++;
  }
  if (valid > 0) {
    tmp = (double )((float )diff / (float )valid);
  } else {
    tmp = 0.0;
  }
  return ((float )tmp);
}
}
static int simple_diffmx(char **aseqs , int num , float ***ret_dmx ) 
{ 
  float **dmx ;
  int i___0 ;
  int j ;
  void *tmp ;
  float *tmp___0 ;
  void *tmp___1 ;
  float tmp___2 ;

  {
  tmp = malloc(sizeof(float *) * (unsigned long )num);
  dmx = (float **)tmp;
  if ((unsigned long )dmx == (unsigned long )((void *)0)) {
    Die((char *)"malloc failed");
  }
  i___0 = 0;
  while (i___0 < num) {
    tmp___1 = malloc(sizeof(float ) * (unsigned long )num);
    tmp___0 = (float *)tmp___1;
    *(dmx + i___0) = tmp___0;
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      Die((char *)"malloc failed");
    }
    i___0 ++;
  }
  i___0 = 0;
  while (i___0 < num) {
    j = i___0;
    while (j < num) {
      tmp___2 = simple_distance(*(aseqs + i___0), *(aseqs + j));
      *(*(dmx + j) + i___0) = tmp___2;
      *(*(dmx + i___0) + j) = tmp___2;
      j ++;
    }
    i___0 ++;
  }
  *ret_dmx = dmx;
  return (1);
}
}
void BlosumWeights(char **aseqs , int nseq , int alen , float maxid , float *wgt ) 
{ 
  int *c ;
  int nc ;
  int *nmem ;
  int i___0 ;
  void *tmp ;

  {
  SingleLinkCluster(aseqs, nseq, alen, maxid, & c, & nc);
  FSet(wgt, nseq, (float )1.0);
  tmp = sre_malloc((char *)"weight.c", 403, sizeof(int ) * (unsigned long )nc);
  nmem = (int *)tmp;
  i___0 = 0;
  while (i___0 < nc) {
    *(nmem + i___0) = 0;
    i___0 ++;
  }
  i___0 = 0;
  while (i___0 < nseq) {
    (*(nmem + *(c + i___0))) ++;
    i___0 ++;
  }
  i___0 = 0;
  while (i___0 < nseq) {
    *(wgt + i___0) = (float )(1. / (double )((float )*(nmem + *(c + i___0))));
    i___0 ++;
  }
  free((void *)nmem);
  free((void *)c);
  return;
}
}
void PositionBasedWeights(char **aseq , int nseq , int alen , float *wgt ) 
{ 
  int rescount[26] ;
  int nres ;
  int idx ;
  int pos ;
  int x ;
  float norm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  float tmp___4 ;

  {
  FSet(wgt, nseq, (float )0.0);
  pos = 0;
  while (pos < alen) {
    x = 0;
    while (x < 26) {
      rescount[x] = 0;
      x ++;
    }
    idx = 0;
    while (idx < nseq) {
      tmp___0 = isalpha((int )*(*(aseq + idx) + pos));
      if (tmp___0) {
        tmp = toupper((int )*(*(aseq + idx) + pos));
        (rescount[tmp - 65]) ++;
      }
      idx ++;
    }
    nres = 0;
    x = 0;
    while (x < 26) {
      if (rescount[x] > 0) {
        nres ++;
      }
      x ++;
    }
    idx = 0;
    while (idx < nseq) {
      tmp___2 = isalpha((int )*(*(aseq + idx) + pos));
      if (tmp___2) {
        tmp___1 = toupper((int )*(*(aseq + idx) + pos));
        *(wgt + idx) = (float )((double )*(wgt + idx) + 1. / (double )((float )(nres * rescount[tmp___1 - 65])));
      }
      idx ++;
    }
    pos ++;
  }
  idx = 0;
  while (idx < nseq) {
    tmp___3 = DealignedLength(*(aseq + idx));
    *(wgt + idx) /= (float )tmp___3;
    idx ++;
  }
  tmp___4 = FSum(wgt, nseq);
  norm = (float )nseq / tmp___4;
  FScale(wgt, nseq, norm);
  return;
}
}
void FilterAlignment(MSA *msa , float cutoff , MSA **ret_new ) 
{ 
  int nnew ;
  int *list ;
  int *useme ;
  float ident ;
  int i___0 ;
  int j ;
  int remove___0 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = sre_malloc((char *)"weight.c", 532, sizeof(int ) * (unsigned long )msa->nseq);
  list = (int *)tmp;
  tmp___0 = sre_malloc((char *)"weight.c", 533, sizeof(int ) * (unsigned long )msa->nseq);
  useme = (int *)tmp___0;
  i___0 = 0;
  while (i___0 < msa->nseq) {
    *(useme + i___0) = 0;
    i___0 ++;
  }
  nnew = 0;
  i___0 = 0;
  while (i___0 < msa->nseq) {
    remove___0 = 0;
    j = 0;
    while (j < nnew) {
      ident = PairwiseIdentity(*(msa->aseq + i___0), *(msa->aseq + *(list + j)));
      if (ident > cutoff) {
        remove___0 = 1;
        printf("removing %12s -- fractional identity %.2f to %s\n", *(msa->sqname + i___0),
               (double )ident, *(msa->sqname + *(list + j)));
        break;
      }
      j ++;
    }
    if (remove___0 == 0) {
      tmp___1 = nnew;
      nnew ++;
      *(list + tmp___1) = i___0;
      *(useme + i___0) = 1;
    }
    i___0 ++;
  }
  MSASmallerAlignment(msa, useme, ret_new);
  free((void *)list);
  free((void *)useme);
  return;
}
}
void SampleAlignment(MSA *msa , int sample , MSA **ret_new ) 
{ 
  int *list ;
  int *useme ;
  int i___0 ;
  int idx ;
  int len ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;

  {
  tmp = sre_malloc((char *)"weight.c", 596, sizeof(int ) * (unsigned long )msa->nseq);
  list = (int *)tmp;
  tmp___0 = sre_malloc((char *)"weight.c", 597, sizeof(int ) * (unsigned long )msa->nseq);
  useme = (int *)tmp___0;
  i___0 = 0;
  while (i___0 < msa->nseq) {
    *(list + i___0) = i___0;
    *(useme + i___0) = 0;
    i___0 ++;
  }
  if (sample >= msa->nseq) {
    sample = msa->nseq;
  }
  len = msa->nseq;
  i___0 = 0;
  while (i___0 < sample) {
    tmp___1 = sre_random();
    idx = (int )(tmp___1 * (double )len);
    printf("chose %d: %s\n", *(list + idx), *(msa->sqname + *(list + idx)));
    *(useme + *(list + idx)) = 1;
    len --;
    *(list + idx) = *(list + len);
    i___0 ++;
  }
  MSASmallerAlignment(msa, useme, ret_new);
  free((void *)list);
  free((void *)useme);
  return;
}
}
void SingleLinkCluster(char **aseq , int nseq , int alen , float maxid , int **ret_c ,
                       int *ret_nc ) 
{ 
  int *a___0 ;
  int na ;
  int *b ;
  int nb ;
  int *c ;
  int nc ;
  int v ;
  int w___0 ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  float tmp___2 ;

  {
  tmp = sre_malloc((char *)"weight.c", 716, sizeof(int ) * (unsigned long )nseq);
  a___0 = (int *)tmp;
  tmp___0 = sre_malloc((char *)"weight.c", 717, sizeof(int ) * (unsigned long )nseq);
  b = (int *)tmp___0;
  tmp___1 = sre_malloc((char *)"weight.c", 718, sizeof(int ) * (unsigned long )nseq);
  c = (int *)tmp___1;
  i___0 = 0;
  while (i___0 < nseq) {
    *(a___0 + i___0) = i___0;
    i___0 ++;
  }
  na = nseq;
  nb = 0;
  nc = 0;
  while (na > 0) {
    v = *(a___0 + (na - 1));
    na --;
    *(b + nb) = v;
    nb ++;
    while (nb > 0) {
      v = *(b + (nb - 1));
      nb --;
      *(c + v) = nc;
      i___0 = na - 1;
      while (i___0 >= 0) {
        tmp___2 = simple_distance(*(aseq + v), *(aseq + *(a___0 + i___0)));
        if ((double )tmp___2 <= 1. - (double )maxid) {
          w___0 = *(a___0 + i___0);
          *(a___0 + i___0) = *(a___0 + (na - 1));
          na --;
          *(b + nb) = w___0;
          nb ++;
        }
        i___0 --;
      }
    }
    nc ++;
  }
  free((void *)a___0);
  free((void *)b);
  *ret_c = c;
  *ret_nc = nc;
  return;
}
}
