/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

typedef long long __int64_t;
typedef unsigned long __darwin_size_t;
typedef long __darwin_ssize_t;
typedef __int64_t __darwin_off_t;
typedef __darwin_size_t size_t;
typedef __darwin_off_t fpos_t;
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
struct __sFILEX;
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   void *_cookie ;
   int (*_close)(void * ) ;
   int (*_read)(void * , char * , int  ) ;
   fpos_t (*_seek)(void * , fpos_t  , int  ) ;
   int (*_write)(void * , char const   * , int  ) ;
   struct __sbuf _ub ;
   struct __sFILEX *_extra ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   fpos_t _offset ;
};
typedef struct __sFILE FILE;
typedef __darwin_ssize_t ssize_t;
#pragma pack(4)
#pragma pack()
struct spec_fd_t {
   int limit ;
   int len ;
   int pos ;
   unsigned char *buf ;
};
struct __anonstruct_bz_stream_12 {
   char *next_in ;
   unsigned int avail_in ;
   unsigned int total_in_lo32 ;
   unsigned int total_in_hi32 ;
   char *next_out ;
   unsigned int avail_out ;
   unsigned int total_out_lo32 ;
   unsigned int total_out_hi32 ;
   void *state ;
   void *(*bzalloc)(void * , int  , int  ) ;
   void (*bzfree)(void * , void * ) ;
   void *opaque ;
};
typedef struct __anonstruct_bz_stream_12 bz_stream;
typedef unsigned char Bool;
typedef unsigned char UChar;
typedef int Int32;
typedef unsigned int UInt32;
typedef unsigned short UInt16;
struct __anonstruct_EState_13 {
   bz_stream *strm ;
   Int32 mode ;
   Int32 state ;
   UInt32 avail_in_expect ;
   UInt32 *arr1 ;
   UInt32 *arr2 ;
   UInt32 *ftab ;
   Int32 origPtr ;
   UInt32 *ptr ;
   UChar *block ;
   UInt16 *mtfv ;
   UChar *zbits ;
   Int32 workFactor ;
   UInt32 state_in_ch ;
   Int32 state_in_len ;
   Int32 rNToGo ;
   Int32 rTPos ;
   Int32 nblock ;
   Int32 nblockMAX ;
   Int32 numZ ;
   Int32 state_out_pos ;
   Int32 nInUse ;
   Bool inUse[256] ;
   UChar unseqToSeq[256] ;
   UInt32 bsBuff ;
   Int32 bsLive ;
   UInt32 blockCRC ;
   UInt32 combinedCRC ;
   Int32 verbosity ;
   Int32 blockNo ;
   Int32 blockSize100k ;
   Int32 nMTF ;
   Int32 mtfFreq[258] ;
   UChar selector[18002] ;
   UChar selectorMtf[18002] ;
   UChar len[6][258] ;
   Int32 code[6][258] ;
   Int32 rfreq[6][258] ;
   UInt32 len_pack[258][4] ;
};
typedef struct __anonstruct_EState_13 EState;
typedef void BZFILE;
typedef char Char;
typedef int IntNative;
struct __anonstruct_UInt64_17 {
   UChar b[8] ;
};
typedef struct __anonstruct_UInt64_17 UInt64;
typedef unsigned int __uint32_t;
typedef int __darwin_ct_rune_t;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
struct __anonstruct__RuneEntry_8 {
   __darwin_rune_t __min ;
   __darwin_rune_t __max ;
   __darwin_rune_t __map ;
   __uint32_t *__types ;
};
typedef struct __anonstruct__RuneEntry_8 _RuneEntry;
struct __anonstruct__RuneRange_9 {
   int __nranges ;
   _RuneEntry *__ranges ;
};
typedef struct __anonstruct__RuneRange_9 _RuneRange;
struct __anonstruct__RuneCharClass_10 {
   char __name[14] ;
   __uint32_t __mask ;
};
typedef struct __anonstruct__RuneCharClass_10 _RuneCharClass;
struct __anonstruct__RuneLocale_11 {
   char __magic[8] ;
   char __encoding[32] ;
   __darwin_rune_t (*__sgetrune)(char const   * , __darwin_size_t  , char const   ** ) ;
   int (*__sputrune)(__darwin_rune_t  , char * , __darwin_size_t  , char ** ) ;
   __darwin_rune_t __invalid_rune ;
   __uint32_t __runetype[1 << 8] ;
   __darwin_rune_t __maplower[1 << 8] ;
   __darwin_rune_t __mapupper[1 << 8] ;
   _RuneRange __runetype_ext ;
   _RuneRange __maplower_ext ;
   _RuneRange __mapupper_ext ;
   void *__variable ;
   int __variable_len ;
   int __ncharclasses ;
   _RuneCharClass *__charclasses ;
};
typedef struct __anonstruct__RuneLocale_11 _RuneLocale;
struct __anonstruct_DState_14 {
   bz_stream *strm ;
   Int32 state ;
   UChar state_out_ch ;
   Int32 state_out_len ;
   Bool blockRandomised ;
   Int32 rNToGo ;
   Int32 rTPos ;
   UInt32 bsBuff ;
   Int32 bsLive ;
   Int32 blockSize100k ;
   Bool smallDecompress ;
   Int32 currBlockNo ;
   Int32 verbosity ;
   Int32 origPtr ;
   UInt32 tPos ;
   Int32 k0 ;
   Int32 unzftab[256] ;
   Int32 nblock_used ;
   Int32 cftab[257] ;
   Int32 cftabCopy[257] ;
   UInt32 *tt ;
   UInt16 *ll16 ;
   UChar *ll4 ;
   UInt32 storedBlockCRC ;
   UInt32 storedCombinedCRC ;
   UInt32 calculatedBlockCRC ;
   UInt32 calculatedCombinedCRC ;
   Int32 nInUse ;
   Bool inUse[256] ;
   Bool inUse16[16] ;
   UChar seqToUnseq[256] ;
   UChar mtfa[4096] ;
   Int32 mtfbase[16] ;
   UChar selector[18002] ;
   UChar selectorMtf[18002] ;
   UChar len[6][258] ;
   Int32 limit[6][258] ;
   Int32 base[6][258] ;
   Int32 perm[6][258] ;
   Int32 minLens[6] ;
   Int32 save_i ;
   Int32 save_j ;
   Int32 save_t ;
   Int32 save_alphaSize ;
   Int32 save_nGroups ;
   Int32 save_nSelectors ;
   Int32 save_EOB ;
   Int32 save_groupNo ;
   Int32 save_groupPos ;
   Int32 save_nextSym ;
   Int32 save_nblockMAX ;
   Int32 save_nblock ;
   Int32 save_es ;
   Int32 save_N ;
   Int32 save_curr ;
   Int32 save_zt ;
   Int32 save_zn ;
   Int32 save_zvec ;
   Int32 save_zj ;
   Int32 save_gSel ;
   Int32 save_gMinlen ;
   Int32 *save_gLimit ;
   Int32 *save_gBase ;
   Int32 *save_gPerm ;
};
typedef struct __anonstruct_DState_14 DState;
struct __anonstruct_bzFile_15 {
   int handle ;
   Char buf[5000] ;
   Int32 bufN ;
   Bool writing ;
   bz_stream strm ;
   Int32 lastErr ;
   Bool initialisedOk ;
};
typedef struct __anonstruct_bzFile_15 bzFile;
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-6TsYQuw1.i","-O3")
extern FILE *__stderrp ;
extern int ( /* format attribute */  fprintf)(FILE * , char const   *  , ...) ;
extern int ( /* format attribute */  printf)(char const   *  , ...) ;
extern int atoi(char const   * ) ;
extern  __attribute__((__noreturn__)) void exit(int  ) ;
extern void *malloc(size_t  ) ;
extern int *__error(void) ;
extern int open(char const   * , int   , ...)  __asm__("_open")  ;
extern char *strerror(int  )  __asm__("_strerror")  ;
__inline static void *__inline_memcpy_chk(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
__inline static void *__inline_memset_chk(void *__dest , int __val , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memset_chk(__dest, __val, __len, tmp);
  return (tmp___0);
}
}
extern int close(int  )  __asm__("_close")  ;
extern ssize_t read(int  , void * , size_t  )  __asm__("_read")  ;
void spec_initbufs(void) ;
void spec_compress(int in , int out , int lev ) ;
void spec_uncompress(int in , int out , int lev ) ;
int spec_init(void) ;
int spec_random_load(int fd ) ;
int spec_load(int num , char *filename , int size ) ;
int spec_read(int fd , unsigned char *buf , int size ) ;
int spec_reset(int fd ) ;
int spec_write(int fd , unsigned char *buf , int size ) ;
int spec_getc(int fd ) ;
int spec_ungetc(unsigned char ch , int fd ) ;
int spec_fread(unsigned char *buf , int size , int num , int fd ) ;
int spec_fwrite(unsigned char *buf , int size , int num , int fd ) ;
int spec_rewind(int fd ) ;
int spec_putc(unsigned char ch , int fd ) ;
int debug_time(void) ;
unsigned char uncompressStream(int zStream , int stream ) ;
void compressStream(int stream , int zStream ) ;
int dbglvl  =    4;
struct spec_fd_t spec_fd[3]  ;
long seedi  ;
double ran(void) 
{ 
  long lo ;
  long hi ;
  long test ;

  {
  hi = seedi / 127773L;
  lo = seedi % 127773L;
  test = 16807L * lo - 2836L * hi;
  if (test > 0L) {
    seedi = test;
  } else {
    seedi = test + 2147483647L;
  }
  return ((double )((float )seedi / (float )2147483647L));
}
}
int spec_init(void) 
{ 
  int i ;
  int j ;
  int limit ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;

  {
  if (3 < dbglvl) {
    printf("spec_init\n");
  }
  i = 0;
  while (i < 3) {
    limit = spec_fd[i].limit;
    tmp___0 = __builtin_object_size((void *)(& spec_fd[i]), 0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)(& spec_fd[i]), 0);
      __builtin___memset_chk((void *)(& spec_fd[i]), 0, sizeof(spec_fd[0]), tmp);
    } else {
      __inline_memset_chk((void *)(& spec_fd[i]), 0, sizeof(spec_fd[0]));
    }
    spec_fd[i].limit = limit;
    tmp___1 = malloc((size_t )(limit + 1048576));
    spec_fd[i].buf = (unsigned char *)tmp___1;
    if ((unsigned long )spec_fd[i].buf == (unsigned long )((void *)0)) {
      printf("spec_init: Error mallocing memory!\n");
      exit(0);
    }
    j = 0;
    while (j < limit) {
      *(spec_fd[i].buf + j) = (unsigned char)0;
      j += 1024;
    }
    i ++;
  }
  return (0);
}
}
int spec_random_load(int fd ) 
{ 
  int i ;
  int j ;
  char random_text[32][131072] ;
  double tmp ;
  double tmp___0 ;
  unsigned long tmp___1 ;
  double tmp___2 ;
  unsigned long tmp___3 ;

  {
  if (4 < dbglvl) {
    printf("Creating Chunks\n");
  }
  i = 0;
  while (i < 32) {
    if (5 < dbglvl) {
      printf("Creating Chunk %d\n", i);
    }
    j = 0;
    while (j < 131072) {
      tmp = ran();
      random_text[i][j] = (char )((int )(tmp * (double )256));
      j ++;
    }
    i ++;
  }
  if (4 < dbglvl) {
    printf("Filling input file\n");
  }
  i = 0;
  while (i < spec_fd[fd].limit) {
    tmp___3 = __builtin_object_size((void *)(spec_fd[fd].buf + i), 0);
    if (tmp___3 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)(spec_fd[fd].buf + i), 0);
      tmp___2 = ran();
      __builtin___memcpy_chk((void *)(spec_fd[fd].buf + i), (void const   *)(random_text[(int )(tmp___2 * (double )32)]),
                             131072UL, tmp___1);
    } else {
      tmp___0 = ran();
      __inline_memcpy_chk((void *)(spec_fd[fd].buf + i), (void const   *)(random_text[(int )(tmp___0 * (double )32)]),
                          (size_t )131072);
    }
    i += 131072;
  }
  spec_fd[fd].len = 1048576;
  return (0);
}
}
int spec_load(int num , char *filename , int size ) 
{ 
  int fd ;
  int rc ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;

  {
  fd = open((char const   *)filename, 0);
  if (fd < 0) {
    tmp = __error();
    tmp___0 = strerror(*tmp);
    fprintf(__stderrp, "Can\'t open file %s: %s\n", filename, tmp___0);
    exit(0);
  }
  tmp___1 = 0;
  spec_fd[num].len = tmp___1;
  spec_fd[num].pos = tmp___1;
  i = 0;
  while (i < size) {
    tmp___2 = read(fd, (void *)(spec_fd[num].buf + i), (size_t )131072);
    rc = (int )tmp___2;
    if (rc == 0) {
      break;
    }
    if (rc < 0) {
      tmp___3 = __error();
      tmp___4 = strerror(*tmp___3);
      fprintf(__stderrp, "Error reading from %s: %s\n", filename, tmp___4);
      exit(0);
    }
    spec_fd[num].len += rc;
    i += rc;
  }
  close(fd);
  while (spec_fd[num].len < size) {
    tmp___5 = size - spec_fd[num].len;
    if (tmp___5 > spec_fd[num].len) {
      tmp___5 = spec_fd[num].len;
    }
    if (3 < dbglvl) {
      printf("Duplicating %d bytes\n", tmp___5);
    }
    tmp___7 = __builtin_object_size((void *)(spec_fd[num].buf + spec_fd[num].len),
                                    0);
    if (tmp___7 != 0xffffffffffffffffUL) {
      tmp___6 = __builtin_object_size((void *)(spec_fd[num].buf + spec_fd[num].len),
                                      0);
      __builtin___memcpy_chk((void *)(spec_fd[num].buf + spec_fd[num].len), (void const   *)spec_fd[num].buf,
                             (unsigned long )tmp___5, tmp___6);
    } else {
      __inline_memcpy_chk((void *)(spec_fd[num].buf + spec_fd[num].len), (void const   *)spec_fd[num].buf,
                          (size_t )tmp___5);
    }
    spec_fd[num].len += tmp___5;
  }
  return (0);
}
}
int spec_read(int fd , unsigned char *buf , int size ) 
{ 
  int rc ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  rc = 0;
  if (4 < dbglvl) {
    printf("spec_read: %d, %p, %d = ", fd, (void *)buf, size);
  }
  if (fd > 3) {
    fprintf(__stderrp, "spec_read: fd=%d, > MAX_SPEC_FD!\n", fd);
    exit(0);
  }
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
    if (4 < dbglvl) {
      printf("EOF\n");
    }
    return (-1);
  }
  if (spec_fd[fd].pos + size >= spec_fd[fd].len) {
    rc = spec_fd[fd].len - spec_fd[fd].pos;
  } else {
    rc = size;
  }
  tmp___0 = __builtin_object_size((void *)buf, 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)buf, 0);
    __builtin___memcpy_chk((void *)buf, (void const   *)(spec_fd[fd].buf + spec_fd[fd].pos),
                           (unsigned long )rc, tmp);
  } else {
    __inline_memcpy_chk((void *)buf, (void const   *)(spec_fd[fd].buf + spec_fd[fd].pos),
                        (size_t )rc);
  }
  spec_fd[fd].pos += rc;
  if (4 < dbglvl) {
    printf("%d\n", rc);
  }
  return (rc);
}
}
int spec_fread(unsigned char *buf , int size , int num , int fd ) 
{ 
  int rc ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  rc = 0;
  if (4 < dbglvl) {
    printf("spec_fread: %p, (%d x %d) fd %d =", (void *)buf, size, num, fd);
  }
  if (fd > 3) {
    fprintf(__stderrp, "spec_fread: fd=%d, > MAX_SPEC_FD!\n", fd);
    exit(0);
  }
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
    if (4 < dbglvl) {
      printf("EOF\n");
    }
    return (-1);
  }
  if (spec_fd[fd].pos + size * num >= spec_fd[fd].len) {
    rc = (spec_fd[fd].len - spec_fd[fd].pos) / size;
  } else {
    rc = num;
  }
  tmp___0 = __builtin_object_size((void *)buf, 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)buf, 0);
    __builtin___memcpy_chk((void *)buf, (void const   *)(spec_fd[fd].buf + spec_fd[fd].pos),
                           (unsigned long )rc, tmp);
  } else {
    __inline_memcpy_chk((void *)buf, (void const   *)(spec_fd[fd].buf + spec_fd[fd].pos),
                        (size_t )rc);
  }
  spec_fd[fd].pos += rc * size;
  if (4 < dbglvl) {
    printf("%d\n", rc * size);
  }
  return (rc);
}
}
int spec_getc(int fd ) 
{ 
  int rc ;
  int tmp ;

  {
  rc = 0;
  if (4 < dbglvl) {
    printf("spec_getc: %d = ", fd);
  }
  if (fd > 3) {
    fprintf(__stderrp, "spec_read: fd=%d, > MAX_SPEC_FD!\n", fd);
    exit(0);
  }
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
    if (4 < dbglvl) {
      printf("EOF\n");
    }
    return (-1);
  }
  tmp = spec_fd[fd].pos;
  (spec_fd[fd].pos) ++;
  rc = (int )*(spec_fd[fd].buf + tmp);
  if (4 < dbglvl) {
    printf("%d\n", rc);
  }
  return (rc);
}
}
int spec_ungetc(unsigned char ch , int fd ) 
{ 
  int rc ;

  {
  rc = 0;
  if (4 < dbglvl) {
    printf("spec_ungetc: %d = ", fd);
  }
  if (fd > 3) {
    fprintf(__stderrp, "spec_read: fd=%d, > MAX_SPEC_FD!\n", fd);
    exit(0);
  }
  if (spec_fd[fd].pos <= 0) {
    fprintf(__stderrp, "spec_ungetc: pos %d <= 0\n", spec_fd[fd].pos);
    exit(0);
  }
  (spec_fd[fd].pos) --;
  if ((int )*(spec_fd[fd].buf + spec_fd[fd].pos) != (int )ch) {
    fprintf(__stderrp, "spec_ungetc: can\'t unget something that wasn\'t what was in the buffer!\n");
    exit(0);
  }
  if (4 < dbglvl) {
    printf("%d\n", rc);
  }
  return ((int )ch);
}
}
int spec_rewind(int fd ) 
{ 


  {
  spec_fd[fd].pos = 0;
  return (0);
}
}
int spec_reset(int fd ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_object_size((void *)spec_fd[fd].buf, 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)spec_fd[fd].buf, 0);
    __builtin___memset_chk((void *)spec_fd[fd].buf, 0, (unsigned long )spec_fd[fd].len,
                           tmp);
  } else {
    __inline_memset_chk((void *)spec_fd[fd].buf, 0, (size_t )spec_fd[fd].len);
  }
  tmp___1 = 0;
  spec_fd[fd].len = tmp___1;
  spec_fd[fd].pos = tmp___1;
  return (0);
}
}
int spec_write(int fd , unsigned char *buf , int size ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if (4 < dbglvl) {
    printf("spec_write: %d, %p, %d = ", fd, (void *)buf, size);
  }
  if (fd > 3) {
    fprintf(__stderrp, "spec_write: fd=%d, > MAX_SPEC_FD!\n", fd);
    exit(0);
  }
  tmp___0 = __builtin_object_size((void *)(spec_fd[fd].buf + spec_fd[fd].pos), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(spec_fd[fd].buf + spec_fd[fd].pos), 0);
    __builtin___memcpy_chk((void *)(spec_fd[fd].buf + spec_fd[fd].pos), (void const   *)buf,
                           (unsigned long )size, tmp);
  } else {
    __inline_memcpy_chk((void *)(spec_fd[fd].buf + spec_fd[fd].pos), (void const   *)buf,
                        (size_t )size);
  }
  spec_fd[fd].len += size;
  spec_fd[fd].pos += size;
  if (4 < dbglvl) {
    printf("%d\n", size);
  }
  return (size);
}
}
int spec_fwrite(unsigned char *buf , int size , int num , int fd ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if (4 < dbglvl) {
    printf("spec_fwrite: %p, %d, %d, %d = ", (void *)buf, size, num, fd);
  }
  if (fd > 3) {
    fprintf(__stderrp, "spec_fwrite: fd=%d, > MAX_SPEC_FD!\n", fd);
    exit(0);
  }
  tmp___0 = __builtin_object_size((void *)(spec_fd[fd].buf + spec_fd[fd].pos), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(spec_fd[fd].buf + spec_fd[fd].pos), 0);
    __builtin___memcpy_chk((void *)(spec_fd[fd].buf + spec_fd[fd].pos), (void const   *)buf,
                           (unsigned long )(size * num), tmp);
  } else {
    __inline_memcpy_chk((void *)(spec_fd[fd].buf + spec_fd[fd].pos), (void const   *)buf,
                        (size_t )(size * num));
  }
  spec_fd[fd].len += size * num;
  spec_fd[fd].pos += size * num;
  if (4 < dbglvl) {
    printf("%d\n", num);
  }
  return (num);
}
}
int spec_putc(unsigned char ch , int fd ) 
{ 
  int tmp ;

  {
  if (4 < dbglvl) {
    printf("spec_putc: %d, %d = ", (int )ch, fd);
  }
  if (fd > 3) {
    fprintf(__stderrp, "spec_write: fd=%d, > MAX_SPEC_FD!\n", fd);
    exit(0);
  }
  tmp = spec_fd[fd].pos;
  (spec_fd[fd].pos) ++;
  *(spec_fd[fd].buf + tmp) = ch;
  (spec_fd[fd].len) ++;
  return ((int )ch);
}
}
int main(int argc , char **argv ) 
{ 
  int i ;
  int level ;
  int input_size ;
  int compressed_size ;
  char *input_name ;
  unsigned char *validate_array ;
  void *tmp ;

  {
  input_size = 64;
  input_name = (char *)"input.combined";
  seedi = 10L;
  if (argc > 1) {
    input_name = *(argv + 1);
  }
  if (argc > 2) {
    input_size = atoi((char const   *)*(argv + 2));
  }
  if (argc > 3) {
    compressed_size = atoi((char const   *)*(argv + 3));
  } else {
    compressed_size = input_size;
  }
  spec_fd[0].limit = input_size * 1048576;
  spec_fd[1].limit = compressed_size * 1048576;
  spec_fd[2].limit = input_size * 1048576;
  spec_init();
  debug_time();
  if (2 < dbglvl) {
    printf("Loading Input Data\n");
  }
  spec_load(0, input_name, input_size * 1048576);
  if (3 < dbglvl) {
    printf("Input data %d bytes in length\n", spec_fd[0].len);
  }
  tmp = malloc((size_t )((input_size * 1048576) / 1024));
  validate_array = (unsigned char *)tmp;
  if ((unsigned long )validate_array == (unsigned long )((void *)0)) {
    printf("main: Error mallocing memory!\n");
    exit(0);
  }
  i = 0;
  while (i * 1027 < input_size * 1048576) {
    *(validate_array + i) = *(spec_fd[0].buf + i * 1027);
    i ++;
  }
  spec_initbufs();
  level = 5;
  while (level <= 9) {
    debug_time();
    if (2 < dbglvl) {
      printf("Compressing Input Data, level %d\n", level);
    }
    spec_compress(0, 1, level);
    debug_time();
    if (3 < dbglvl) {
      printf("Compressed data %d bytes in length\n", spec_fd[1].len);
    }
    spec_reset(0);
    spec_rewind(1);
    debug_time();
    if (2 < dbglvl) {
      printf("Uncompressing Data\n");
    }
    spec_uncompress(1, 0, level);
    debug_time();
    if (3 < dbglvl) {
      printf("Uncompressed data %d bytes in length\n", spec_fd[0].len);
    }
    i = 0;
    while (i * 1027 < input_size * 1048576) {
      if ((int )*(validate_array + i) != (int )*(spec_fd[0].buf + i * 1027)) {
        printf("Tested %dMB buffer: Miscompared!!\n", input_size);
        exit(0);
      }
      i ++;
    }
    debug_time();
    if (3 < dbglvl) {
      printf("Uncompressed data compared correctly\n");
    }
    spec_reset(1);
    spec_rewind(0);
    level += 2;
  }
  printf("Tested %dMB buffer: OK!\n", input_size);
  return (0);
}
}
unsigned char smallMode ;
int verbosity ;
int workFactor ;
int blockSize100k ;
void spec_initbufs(void) 
{ 


  {
  smallMode = (unsigned char)0;
  verbosity = 0;
  blockSize100k = 9;
  workFactor = 30;
  return;
}
}
void spec_compress(int in , int out , int lev ) 
{ 


  {
  blockSize100k = lev;
  compressStream(in, out);
  return;
}
}
void spec_uncompress(int in , int out , int lev ) 
{ 


  {
  blockSize100k = 0;
  uncompressStream(in, out);
  return;
}
}
int debug_time(void) 
{ 


  {
  return (0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-jha8kmwE.i","-O3")
void BZ2_bz__AssertH__fail(int errcode ) ;
void BZ2_blockSort(EState *s ) ;
static void fallbackSimpleSort(UInt32 *fmap , UInt32 *eclass , Int32 lo , Int32 hi ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 tmp ;
  UInt32 ec_tmp ;

  {
  if (lo == hi) {
    return;
  }
  if (hi - lo > 3) {
    i = hi - 4;
    while (i >= lo) {
      tmp = (Int32 )*(fmap + i);
      ec_tmp = *(eclass + tmp);
      j = i + 4;
      while (1) {
        if (j <= hi) {
          if (! (ec_tmp > *(eclass + *(fmap + j)))) {
            break;
          }
        } else {
          break;
        }
        *(fmap + (j - 4)) = *(fmap + j);
        j += 4;
      }
      *(fmap + (j - 4)) = (UInt32 )tmp;
      i --;
    }
  }
  i = hi - 1;
  while (i >= lo) {
    tmp = (Int32 )*(fmap + i);
    ec_tmp = *(eclass + tmp);
    j = i + 1;
    while (1) {
      if (j <= hi) {
        if (! (ec_tmp > *(eclass + *(fmap + j)))) {
          break;
        }
      } else {
        break;
      }
      *(fmap + (j - 1)) = *(fmap + j);
      j ++;
    }
    *(fmap + (j - 1)) = (UInt32 )tmp;
    i --;
  }
  return;
}
}
static void fallbackQSort3(UInt32 *fmap , UInt32 *eclass , Int32 loSt , Int32 hiSt ) 
{ 
  Int32 unLo ;
  Int32 unHi ;
  Int32 ltLo ;
  Int32 gtHi ;
  Int32 n ;
  Int32 m ;
  Int32 sp ;
  Int32 lo ;
  Int32 hi ;
  UInt32 med ;
  UInt32 r ;
  UInt32 r3 ;
  Int32 stackLo[100] ;
  Int32 stackHi[100] ;
  Int32 zztmp ;
  Int32 zztmp___0 ;
  Int32 zztmp___1 ;
  Int32 yyp1 ;
  Int32 yyp2 ;
  Int32 yyn ;
  Int32 zztmp___2 ;
  Int32 yyp1___0 ;
  Int32 yyp2___0 ;
  Int32 yyn___0 ;
  Int32 zztmp___3 ;

  {
  r = (UInt32 )0;
  sp = 0;
  stackLo[sp] = loSt;
  stackHi[sp] = hiSt;
  sp ++;
  while (sp > 0) {
    if (! (sp < 100)) {
      BZ2_bz__AssertH__fail(1004);
    }
    sp --;
    lo = stackLo[sp];
    hi = stackHi[sp];
    if (hi - lo < 10) {
      fallbackSimpleSort(fmap, eclass, lo, hi);
      continue;
    }
    r = (r * 7621U + 1U) % 32768U;
    r3 = r % 3U;
    if (r3 == 0U) {
      med = *(eclass + *(fmap + lo));
    } else
    if (r3 == 1U) {
      med = *(eclass + *(fmap + ((lo + hi) >> 1)));
    } else {
      med = *(eclass + *(fmap + hi));
    }
    ltLo = lo;
    unLo = ltLo;
    gtHi = hi;
    unHi = gtHi;
    while (1) {
      while (! (unLo > unHi)) {
        n = (Int32 )*(eclass + *(fmap + unLo)) - (Int32 )med;
        if (n == 0) {
          zztmp = (Int32 )*(fmap + unLo);
          *(fmap + unLo) = *(fmap + ltLo);
          *(fmap + ltLo) = (UInt32 )zztmp;
          ltLo ++;
          unLo ++;
          continue;
        }
        if (n > 0) {
          break;
        }
        unLo ++;
      }
      while (! (unLo > unHi)) {
        n = (Int32 )*(eclass + *(fmap + unHi)) - (Int32 )med;
        if (n == 0) {
          zztmp___0 = (Int32 )*(fmap + unHi);
          *(fmap + unHi) = *(fmap + gtHi);
          *(fmap + gtHi) = (UInt32 )zztmp___0;
          gtHi --;
          unHi --;
          continue;
        }
        if (n < 0) {
          break;
        }
        unHi --;
      }
      if (unLo > unHi) {
        break;
      }
      zztmp___1 = (Int32 )*(fmap + unLo);
      *(fmap + unLo) = *(fmap + unHi);
      *(fmap + unHi) = (UInt32 )zztmp___1;
      unLo ++;
      unHi --;
    }
    if (gtHi < ltLo) {
      continue;
    }
    if (ltLo - lo < unLo - ltLo) {
      n = ltLo - lo;
    } else {
      n = unLo - ltLo;
    }
    yyp1 = lo;
    yyp2 = unLo - n;
    yyn = n;
    while (yyn > 0) {
      zztmp___2 = (Int32 )*(fmap + yyp1);
      *(fmap + yyp1) = *(fmap + yyp2);
      *(fmap + yyp2) = (UInt32 )zztmp___2;
      yyp1 ++;
      yyp2 ++;
      yyn --;
    }
    if (hi - gtHi < gtHi - unHi) {
      m = hi - gtHi;
    } else {
      m = gtHi - unHi;
    }
    yyp1___0 = unLo;
    yyp2___0 = (hi - m) + 1;
    yyn___0 = m;
    while (yyn___0 > 0) {
      zztmp___3 = (Int32 )*(fmap + yyp1___0);
      *(fmap + yyp1___0) = *(fmap + yyp2___0);
      *(fmap + yyp2___0) = (UInt32 )zztmp___3;
      yyp1___0 ++;
      yyp2___0 ++;
      yyn___0 --;
    }
    n = ((lo + unLo) - ltLo) - 1;
    m = (hi - (gtHi - unHi)) + 1;
    if (n - lo > hi - m) {
      stackLo[sp] = lo;
      stackHi[sp] = n;
      sp ++;
      stackLo[sp] = m;
      stackHi[sp] = hi;
      sp ++;
    } else {
      stackLo[sp] = m;
      stackHi[sp] = hi;
      sp ++;
      stackLo[sp] = lo;
      stackHi[sp] = n;
      sp ++;
    }
  }
  return;
}
}
static void fallbackSort(UInt32 *fmap , UInt32 *eclass , UInt32 *bhtab , Int32 nblock ,
                         Int32 verb ) 
{ 
  Int32 ftab[257] ;
  Int32 ftabCopy[256] ;
  Int32 H ;
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Int32 l ;
  Int32 r ;
  Int32 cc ;
  Int32 cc1 ;
  Int32 nNotDone ;
  Int32 nBhtab ;
  UChar *eclass8 ;

  {
  eclass8 = (UChar *)eclass;
  if (verb >= 4) {
    fprintf(__stderrp, "        bucket sorting ...\n");
  }
  i = 0;
  while (i < 257) {
    ftab[i] = 0;
    i ++;
  }
  i = 0;
  while (i < nblock) {
    (ftab[*(eclass8 + i)]) ++;
    i ++;
  }
  i = 0;
  while (i < 256) {
    ftabCopy[i] = ftab[i];
    i ++;
  }
  i = 1;
  while (i < 257) {
    ftab[i] += ftab[i - 1];
    i ++;
  }
  i = 0;
  while (i < nblock) {
    j = (Int32 )*(eclass8 + i);
    k = ftab[j] - 1;
    ftab[j] = k;
    *(fmap + k) = (UInt32 )i;
    i ++;
  }
  nBhtab = 2 + nblock / 32;
  i = 0;
  while (i < nBhtab) {
    *(bhtab + i) = (UInt32 )0;
    i ++;
  }
  i = 0;
  while (i < 256) {
    *(bhtab + (ftab[i] >> 5)) |= (unsigned int )(1 << (ftab[i] & 31));
    i ++;
  }
  i = 0;
  while (i < 32) {
    *(bhtab + ((nblock + 2 * i) >> 5)) |= (unsigned int )(1 << ((nblock + 2 * i) & 31));
    *(bhtab + (((nblock + 2 * i) + 1) >> 5)) &= (unsigned int )(~ (1 << (((nblock + 2 * i) + 1) & 31)));
    i ++;
  }
  H = 1;
  while (1) {
    if (verb >= 4) {
      fprintf(__stderrp, "        depth %6d has ", H);
    }
    j = 0;
    i = 0;
    while (i < nblock) {
      if (*(bhtab + (i >> 5)) & (unsigned int )(1 << (i & 31))) {
        j = i;
      }
      k = (Int32 )(*(fmap + i) - (UInt32 )H);
      if (k < 0) {
        k += nblock;
      }
      *(eclass + k) = (UInt32 )j;
      i ++;
    }
    nNotDone = 0;
    r = -1;
    while (1) {
      k = r + 1;
      while (1) {
        if (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))) {
          if (! (k & 31)) {
            break;
          }
        } else {
          break;
        }
        k ++;
      }
      if (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))) {
        while (*(bhtab + (k >> 5)) == 4294967295U) {
          k += 32;
        }
        while (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))) {
          k ++;
        }
      }
      l = k - 1;
      if (l >= nblock) {
        break;
      }
      while (1) {
        if (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
          if (! (k & 31)) {
            break;
          }
        } else {
          break;
        }
        k ++;
      }
      if (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
        while (*(bhtab + (k >> 5)) == 0U) {
          k += 32;
        }
        while (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
          k ++;
        }
      }
      r = k - 1;
      if (r >= nblock) {
        break;
      }
      if (r > l) {
        nNotDone += (r - l) + 1;
        fallbackQSort3(fmap, eclass, l, r);
        cc = -1;
        i = l;
        while (i <= r) {
          cc1 = (Int32 )*(eclass + *(fmap + i));
          if (cc != cc1) {
            *(bhtab + (i >> 5)) |= (unsigned int )(1 << (i & 31));
            cc = cc1;
          }
          i ++;
        }
      }
    }
    if (verb >= 4) {
      fprintf(__stderrp, "%6d unresolved strings\n", nNotDone);
    }
    H *= 2;
    if (H > nblock) {
      break;
    } else
    if (nNotDone == 0) {
      break;
    }
  }
  if (verb >= 4) {
    fprintf(__stderrp, "        reconstructing block ...\n");
  }
  j = 0;
  i = 0;
  while (i < nblock) {
    while (ftabCopy[j] == 0) {
      j ++;
    }
    (ftabCopy[j]) --;
    *(eclass8 + *(fmap + i)) = (UChar )j;
    i ++;
  }
  if (! (j < 256)) {
    BZ2_bz__AssertH__fail(1005);
  }
  return;
}
}
static Bool mainGtU(UInt32 i1 , UInt32 i2 , UChar *block , UInt16 *quadrant , UInt32 nblock ,
                    Int32 *budget ) 
{ 
  Int32 k ;
  UChar c1 ;
  UChar c2 ;
  UInt16 s1 ;
  UInt16 s2 ;

  {
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((Bool )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  k = (Int32 )(nblock + 8U);
  while (1) {
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((Bool )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((Bool )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((Bool )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((Bool )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((Bool )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((Bool )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((Bool )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((Bool )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((Bool )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((Bool )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((Bool )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((Bool )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((Bool )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((Bool )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((Bool )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((Bool )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    if (i1 >= nblock) {
      i1 -= nblock;
    }
    if (i2 >= nblock) {
      i2 -= nblock;
    }
    k -= 8;
    (*budget) --;
    if (! (k >= 0)) {
      break;
    }
  }
  return ((Bool )0);
}
}
static Int32 incs[14]  = 
  {      1,      4,      13,      40, 
        121,      364,      1093,      3280, 
        9841,      29524,      88573,      265720, 
        797161,      2391484};
static void mainSimpleSort(UInt32 *ptr , UChar *block , UInt16 *quadrant , Int32 nblock ,
                           Int32 lo , Int32 hi , Int32 d , Int32 *budget ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 h ;
  Int32 bigN ;
  Int32 hp ;
  UInt32 v ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
  bigN = (hi - lo) + 1;
  if (bigN < 2) {
    return;
  }
  hp = 0;
  while (incs[hp] < bigN) {
    hp ++;
  }
  hp --;
  while (hp >= 0) {
    h = incs[hp];
    i = lo + h;
    while (! (i > hi)) {
      v = *(ptr + i);
      j = i;
      while (1) {
        tmp = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                      (UInt32 )nblock, budget);
        if (! tmp) {
          break;
        }
        *(ptr + j) = *(ptr + (j - h));
        j -= h;
        if (j <= (lo + h) - 1) {
          break;
        }
      }
      *(ptr + j) = v;
      i ++;
      if (i > hi) {
        break;
      }
      v = *(ptr + i);
      j = i;
      while (1) {
        tmp___0 = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                          (UInt32 )nblock, budget);
        if (! tmp___0) {
          break;
        }
        *(ptr + j) = *(ptr + (j - h));
        j -= h;
        if (j <= (lo + h) - 1) {
          break;
        }
      }
      *(ptr + j) = v;
      i ++;
      if (i > hi) {
        break;
      }
      v = *(ptr + i);
      j = i;
      while (1) {
        tmp___1 = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                          (UInt32 )nblock, budget);
        if (! tmp___1) {
          break;
        }
        *(ptr + j) = *(ptr + (j - h));
        j -= h;
        if (j <= (lo + h) - 1) {
          break;
        }
      }
      *(ptr + j) = v;
      i ++;
      if (*budget < 0) {
        return;
      }
    }
    hp --;
  }
  return;
}
}
static UChar mmed3(UChar a , UChar b , UChar c ) 
{ 
  UChar t ;

  {
  if ((int )a > (int )b) {
    t = a;
    a = b;
    b = t;
  }
  if ((int )b > (int )c) {
    b = c;
    if ((int )a > (int )b) {
      b = a;
    }
  }
  return (b);
}
}
static void mainQSort3(UInt32 *ptr , UChar *block , UInt16 *quadrant , Int32 nblock ,
                       Int32 loSt , Int32 hiSt , Int32 dSt , Int32 *budget ) 
{ 
  Int32 unLo ;
  Int32 unHi ;
  Int32 ltLo ;
  Int32 gtHi ;
  Int32 n ;
  Int32 m ;
  Int32 med ;
  Int32 sp ;
  Int32 lo ;
  Int32 hi ;
  Int32 d ;
  Int32 stackLo[100] ;
  Int32 stackHi[100] ;
  Int32 stackD[100] ;
  Int32 nextLo[3] ;
  Int32 nextHi[3] ;
  Int32 nextD[3] ;
  UChar tmp ;
  Int32 zztmp ;
  Int32 zztmp___0 ;
  Int32 zztmp___1 ;
  Int32 yyp1 ;
  Int32 yyp2 ;
  Int32 yyn ;
  Int32 zztmp___2 ;
  Int32 yyp1___0 ;
  Int32 yyp2___0 ;
  Int32 yyn___0 ;
  Int32 zztmp___3 ;
  Int32 tz ;
  Int32 tz___0 ;
  Int32 tz___1 ;

  {
  sp = 0;
  stackLo[sp] = loSt;
  stackHi[sp] = hiSt;
  stackD[sp] = dSt;
  sp ++;
  while (sp > 0) {
    if (! (sp < 100)) {
      BZ2_bz__AssertH__fail(1001);
    }
    sp --;
    lo = stackLo[sp];
    hi = stackHi[sp];
    d = stackD[sp];
    if (hi - lo < 20) {
      goto _L;
    } else
    if (d > 14) {
      _L: /* CIL Label */ 
      mainSimpleSort(ptr, block, quadrant, nblock, lo, hi, d, budget);
      if (*budget < 0) {
        return;
      }
      continue;
    }
    tmp = mmed3(*(block + (*(ptr + lo) + (UInt32 )d)), *(block + (*(ptr + hi) + (UInt32 )d)),
                *(block + (*(ptr + ((lo + hi) >> 1)) + (UInt32 )d)));
    med = (Int32 )tmp;
    ltLo = lo;
    unLo = ltLo;
    gtHi = hi;
    unHi = gtHi;
    while (1) {
      while (! (unLo > unHi)) {
        n = (Int32 )*(block + (*(ptr + unLo) + (UInt32 )d)) - med;
        if (n == 0) {
          zztmp = (Int32 )*(ptr + unLo);
          *(ptr + unLo) = *(ptr + ltLo);
          *(ptr + ltLo) = (UInt32 )zztmp;
          ltLo ++;
          unLo ++;
          continue;
        }
        if (n > 0) {
          break;
        }
        unLo ++;
      }
      while (! (unLo > unHi)) {
        n = (Int32 )*(block + (*(ptr + unHi) + (UInt32 )d)) - med;
        if (n == 0) {
          zztmp___0 = (Int32 )*(ptr + unHi);
          *(ptr + unHi) = *(ptr + gtHi);
          *(ptr + gtHi) = (UInt32 )zztmp___0;
          gtHi --;
          unHi --;
          continue;
        }
        if (n < 0) {
          break;
        }
        unHi --;
      }
      if (unLo > unHi) {
        break;
      }
      zztmp___1 = (Int32 )*(ptr + unLo);
      *(ptr + unLo) = *(ptr + unHi);
      *(ptr + unHi) = (UInt32 )zztmp___1;
      unLo ++;
      unHi --;
    }
    if (gtHi < ltLo) {
      stackLo[sp] = lo;
      stackHi[sp] = hi;
      stackD[sp] = d + 1;
      sp ++;
      continue;
    }
    if (ltLo - lo < unLo - ltLo) {
      n = ltLo - lo;
    } else {
      n = unLo - ltLo;
    }
    yyp1 = lo;
    yyp2 = unLo - n;
    yyn = n;
    while (yyn > 0) {
      zztmp___2 = (Int32 )*(ptr + yyp1);
      *(ptr + yyp1) = *(ptr + yyp2);
      *(ptr + yyp2) = (UInt32 )zztmp___2;
      yyp1 ++;
      yyp2 ++;
      yyn --;
    }
    if (hi - gtHi < gtHi - unHi) {
      m = hi - gtHi;
    } else {
      m = gtHi - unHi;
    }
    yyp1___0 = unLo;
    yyp2___0 = (hi - m) + 1;
    yyn___0 = m;
    while (yyn___0 > 0) {
      zztmp___3 = (Int32 )*(ptr + yyp1___0);
      *(ptr + yyp1___0) = *(ptr + yyp2___0);
      *(ptr + yyp2___0) = (UInt32 )zztmp___3;
      yyp1___0 ++;
      yyp2___0 ++;
      yyn___0 --;
    }
    n = ((lo + unLo) - ltLo) - 1;
    m = (hi - (gtHi - unHi)) + 1;
    nextLo[0] = lo;
    nextHi[0] = n;
    nextD[0] = d;
    nextLo[1] = m;
    nextHi[1] = hi;
    nextD[1] = d;
    nextLo[2] = n + 1;
    nextHi[2] = m - 1;
    nextD[2] = d + 1;
    if (nextHi[0] - nextLo[0] < nextHi[1] - nextLo[1]) {
      tz = nextLo[0];
      nextLo[0] = nextLo[1];
      nextLo[1] = tz;
      tz = nextHi[0];
      nextHi[0] = nextHi[1];
      nextHi[1] = tz;
      tz = nextD[0];
      nextD[0] = nextD[1];
      nextD[1] = tz;
    }
    if (nextHi[1] - nextLo[1] < nextHi[2] - nextLo[2]) {
      tz___0 = nextLo[1];
      nextLo[1] = nextLo[2];
      nextLo[2] = tz___0;
      tz___0 = nextHi[1];
      nextHi[1] = nextHi[2];
      nextHi[2] = tz___0;
      tz___0 = nextD[1];
      nextD[1] = nextD[2];
      nextD[2] = tz___0;
    }
    if (nextHi[0] - nextLo[0] < nextHi[1] - nextLo[1]) {
      tz___1 = nextLo[0];
      nextLo[0] = nextLo[1];
      nextLo[1] = tz___1;
      tz___1 = nextHi[0];
      nextHi[0] = nextHi[1];
      nextHi[1] = tz___1;
      tz___1 = nextD[0];
      nextD[0] = nextD[1];
      nextD[1] = tz___1;
    }
    stackLo[sp] = nextLo[0];
    stackHi[sp] = nextHi[0];
    stackD[sp] = nextD[0];
    sp ++;
    stackLo[sp] = nextLo[1];
    stackHi[sp] = nextHi[1];
    stackD[sp] = nextD[1];
    sp ++;
    stackLo[sp] = nextLo[2];
    stackHi[sp] = nextHi[2];
    stackD[sp] = nextD[2];
    sp ++;
  }
  return;
}
}
static void mainSort(UInt32 *ptr , UChar *block , UInt16 *quadrant , UInt32 *ftab ,
                     Int32 nblock , Int32 verb , Int32 *budget ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Int32 ss ;
  Int32 sb ;
  Int32 runningOrder[256] ;
  Bool bigDone[256] ;
  Int32 copyStart[256] ;
  Int32 copyEnd[256] ;
  UChar c1 ;
  Int32 numQSorted ;
  UInt16 s ;
  Int32 vv ;
  Int32 h ;
  Int32 lo ;
  Int32 hi ;
  Int32 tmp ;
  Int32 tmp___0 ;
  Int32 bbStart ;
  Int32 bbSize ;
  Int32 shifts ;
  Int32 a2update ;
  UInt16 qVal ;

  {
  if (verb >= 4) {
    fprintf(__stderrp, "        main sort initialise ...\n");
  }
  i = 65536;
  while (i >= 0) {
    *(ftab + i) = (UInt32 )0;
    i --;
  }
  j = (int )*(block + 0) << 8;
  i = nblock - 1;
  while (i >= 3) {
    *(quadrant + i) = (UInt16 )0;
    j = (j >> 8) | ((int )((UInt16 )*(block + i)) << 8);
    (*(ftab + j)) ++;
    *(quadrant + (i - 1)) = (UInt16 )0;
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 1))) << 8);
    (*(ftab + j)) ++;
    *(quadrant + (i - 2)) = (UInt16 )0;
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 2))) << 8);
    (*(ftab + j)) ++;
    *(quadrant + (i - 3)) = (UInt16 )0;
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 3))) << 8);
    (*(ftab + j)) ++;
    i -= 4;
  }
  while (i >= 0) {
    *(quadrant + i) = (UInt16 )0;
    j = (j >> 8) | ((int )((UInt16 )*(block + i)) << 8);
    (*(ftab + j)) ++;
    i --;
  }
  i = 0;
  while (i < 34) {
    *(block + (nblock + i)) = *(block + i);
    *(quadrant + (nblock + i)) = (UInt16 )0;
    i ++;
  }
  if (verb >= 4) {
    fprintf(__stderrp, "        bucket sorting ...\n");
  }
  i = 1;
  while (i <= 65536) {
    *(ftab + i) += *(ftab + (i - 1));
    i ++;
  }
  s = (UInt16 )((int )*(block + 0) << 8);
  i = nblock - 1;
  while (i >= 3) {
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + i) << 8));
    j = (Int32 )(*(ftab + s) - 1U);
    *(ftab + s) = (UInt32 )j;
    *(ptr + j) = (UInt32 )i;
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 1)) << 8));
    j = (Int32 )(*(ftab + s) - 1U);
    *(ftab + s) = (UInt32 )j;
    *(ptr + j) = (UInt32 )(i - 1);
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 2)) << 8));
    j = (Int32 )(*(ftab + s) - 1U);
    *(ftab + s) = (UInt32 )j;
    *(ptr + j) = (UInt32 )(i - 2);
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 3)) << 8));
    j = (Int32 )(*(ftab + s) - 1U);
    *(ftab + s) = (UInt32 )j;
    *(ptr + j) = (UInt32 )(i - 3);
    i -= 4;
  }
  while (i >= 0) {
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + i) << 8));
    j = (Int32 )(*(ftab + s) - 1U);
    *(ftab + s) = (UInt32 )j;
    *(ptr + j) = (UInt32 )i;
    i --;
  }
  i = 0;
  while (i <= 255) {
    bigDone[i] = (Bool )0;
    runningOrder[i] = i;
    i ++;
  }
  h = 1;
  while (1) {
    h = 3 * h + 1;
    if (! (h <= 256)) {
      break;
    }
  }
  while (1) {
    h /= 3;
    i = h;
    while (i <= 255) {
      vv = runningOrder[i];
      j = i;
      while (*(ftab + ((runningOrder[j - h] + 1) << 8)) - *(ftab + (runningOrder[j - h] << 8)) > *(ftab + ((vv + 1) << 8)) - *(ftab + (vv << 8))) {
        runningOrder[j] = runningOrder[j - h];
        j -= h;
        if (j <= h - 1) {
          goto zero;
        }
      }
      zero: 
      runningOrder[j] = vv;
      i ++;
    }
    if (! (h != 1)) {
      break;
    }
  }
  numQSorted = 0;
  i = 0;
  while (i <= 255) {
    ss = runningOrder[i];
    j = 0;
    while (j <= 255) {
      if (j != ss) {
        sb = (ss << 8) + j;
        if (! (*(ftab + sb) & (unsigned int )(1 << 21))) {
          lo = (Int32 )(*(ftab + sb) & (unsigned int )(~ (1 << 21)));
          hi = (Int32 )((*(ftab + (sb + 1)) & (unsigned int )(~ (1 << 21))) - 1U);
          if (hi > lo) {
            if (verb >= 4) {
              fprintf(__stderrp, "        qsort [0x%x, 0x%x]   done %d   this %d\n",
                      (unsigned int )ss, (unsigned int )j, numQSorted, (hi - lo) + 1);
            }
            mainQSort3(ptr, block, quadrant, nblock, lo, hi, 2, budget);
            numQSorted += (hi - lo) + 1;
            if (*budget < 0) {
              return;
            }
          }
        }
        *(ftab + sb) |= (unsigned int )(1 << 21);
      }
      j ++;
    }
    if (! (! bigDone[ss])) {
      BZ2_bz__AssertH__fail(1006);
    }
    j = 0;
    while (j <= 255) {
      copyStart[j] = (Int32 )(*(ftab + ((j << 8) + ss)) & (unsigned int )(~ (1 << 21)));
      copyEnd[j] = (Int32 )((*(ftab + (((j << 8) + ss) + 1)) & (unsigned int )(~ (1 << 21))) - 1U);
      j ++;
    }
    j = (Int32 )(*(ftab + (ss << 8)) & (unsigned int )(~ (1 << 21)));
    while (j < copyStart[ss]) {
      k = (Int32 )(*(ptr + j) - 1U);
      if (k < 0) {
        k += nblock;
      }
      c1 = *(block + k);
      if (! bigDone[c1]) {
        tmp = copyStart[c1];
        (copyStart[c1]) ++;
        *(ptr + tmp) = (UInt32 )k;
      }
      j ++;
    }
    j = (Int32 )((*(ftab + ((ss + 1) << 8)) & (unsigned int )(~ (1 << 21))) - 1U);
    while (j > copyEnd[ss]) {
      k = (Int32 )(*(ptr + j) - 1U);
      if (k < 0) {
        k += nblock;
      }
      c1 = *(block + k);
      if (! bigDone[c1]) {
        tmp___0 = copyEnd[c1];
        (copyEnd[c1]) --;
        *(ptr + tmp___0) = (UInt32 )k;
      }
      j --;
    }
    if (! (copyStart[ss] - 1 == copyEnd[ss])) {
      if (copyStart[ss] == 0) {
        if (! (copyEnd[ss] == nblock - 1)) {
          BZ2_bz__AssertH__fail(1007);
        }
      } else {
        BZ2_bz__AssertH__fail(1007);
      }
    }
    j = 0;
    while (j <= 255) {
      *(ftab + ((j << 8) + ss)) |= (unsigned int )(1 << 21);
      j ++;
    }
    bigDone[ss] = (Bool )1;
    if (i < 255) {
      bbStart = (Int32 )(*(ftab + (ss << 8)) & (unsigned int )(~ (1 << 21)));
      bbSize = (Int32 )((*(ftab + ((ss + 1) << 8)) & (unsigned int )(~ (1 << 21))) - (unsigned int )bbStart);
      shifts = 0;
      while (bbSize >> shifts > 65534) {
        shifts ++;
      }
      j = bbSize - 1;
      while (j >= 0) {
        a2update = (Int32 )*(ptr + (bbStart + j));
        qVal = (UInt16 )(j >> shifts);
        *(quadrant + a2update) = qVal;
        if (a2update < 34) {
          *(quadrant + (a2update + nblock)) = qVal;
        }
        j --;
      }
      if (! ((bbSize - 1) >> shifts <= 65535)) {
        BZ2_bz__AssertH__fail(1002);
      }
    }
    i ++;
  }
  if (verb >= 4) {
    fprintf(__stderrp, "        %d pointers, %d sorted, %d scanned\n", nblock, numQSorted,
            nblock - numQSorted);
  }
  return;
}
}
void BZ2_blockSort(EState *s ) 
{ 
  UInt32 *ptr ;
  UChar *block ;
  UInt32 *ftab ;
  Int32 nblock ;
  Int32 verb ;
  Int32 wfact ;
  UInt16 *quadrant ;
  Int32 budget ;
  Int32 budgetInit ;
  Int32 i ;
  int tmp ;

  {
  ptr = s->ptr;
  block = s->block;
  ftab = s->ftab;
  nblock = s->nblock;
  verb = s->verbosity;
  wfact = s->workFactor;
  if (nblock < 10000) {
    fallbackSort(s->arr1, s->arr2, ftab, nblock, verb);
  } else {
    i = nblock + 34;
    if (i & 1) {
      i ++;
    }
    quadrant = (UInt16 *)(block + i);
    if (wfact < 1) {
      wfact = 1;
    }
    if (wfact > 100) {
      wfact = 100;
    }
    budgetInit = nblock * ((wfact - 1) / 3);
    budget = budgetInit;
    mainSort(ptr, block, quadrant, ftab, nblock, verb, & budget);
    if (verb >= 3) {
      if (nblock == 0) {
        tmp = 1;
      } else {
        tmp = nblock;
      }
      fprintf(__stderrp, "      %d work, %d block, ratio %5.2f\n", budgetInit - budget,
              nblock, (double )((float )(budgetInit - budget) / (float )tmp));
    }
    if (budget < 0) {
      if (verb >= 2) {
        fprintf(__stderrp, "    too repetitive; using fallback sorting algorithm\n");
      }
      fallbackSort(s->arr1, s->arr2, ftab, nblock, verb);
    }
  }
  s->origPtr = -1;
  i = 0;
  while (i < s->nblock) {
    if (*(ptr + i) == 0U) {
      s->origPtr = i;
      break;
    }
    i ++;
  }
  if (! (s->origPtr != -1)) {
    BZ2_bz__AssertH__fail(1003);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-r079Un5g.i","-O3")
extern void perror(char const   * ) ;
BZFILE *BZ2_bzReadOpen(int *bzerror , int f , int verbosity___0 , int small , void *unused ,
                       int nUnused ) ;
void BZ2_bzReadClose(int *bzerror , BZFILE *b ) ;
void BZ2_bzReadGetUnused(int *bzerror , BZFILE *b , void **unused , int *nUnused ) ;
int BZ2_bzRead(int *bzerror , BZFILE *b , void *buf , int len ) ;
BZFILE *BZ2_bzWriteOpen(int *bzerror , int f , int blockSize100k___0 , int verbosity___0 ,
                        int workFactor___0 ) ;
void BZ2_bzWrite(int *bzerror , BZFILE *b , void *buf , int len ) ;
void BZ2_bzWriteClose64(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in_lo32 ,
                        unsigned int *nbytes_in_hi32 , unsigned int *nbytes_out_lo32 ,
                        unsigned int *nbytes_out_hi32 ) ;
int verbosity  ;
Bool keepInputFiles  ;
unsigned char smallMode  ;
Bool deleteOutputOnInterrupt  ;
Bool forceOverwrite  ;
Bool testFailsExist  ;
Bool unzFailsExist  ;
Bool noisy  ;
Int32 numFileNames  ;
Int32 numFilesProcessed  ;
int blockSize100k  ;
Int32 exitValue  ;
Int32 opMode  ;
Int32 srcMode  ;
Int32 longestFileName  ;
Char inName[1034]  ;
Char outName[1034]  ;
Char tmpName[1034]  ;
Char *progName  ;
Char progNameReally[1034]  ;
int outputHandleJustInCase  ;
int workFactor  ;
static void panic(Char *s ) ;
static void ioError(void) ;
static void outOfMemory(void) ;
static void configError(void) ;
static void crcError(void) ;
static void cleanUpAndFail(Int32 ec ) ;
static void compressedStreamEOF(void) ;
static void uInt64_from_UInt32s(UInt64 *n , UInt32 lo32 , UInt32 hi32 ) 
{ 


  {
  n->b[7] = (UChar )((hi32 >> 24) & 255U);
  n->b[6] = (UChar )((hi32 >> 16) & 255U);
  n->b[5] = (UChar )((hi32 >> 8) & 255U);
  n->b[4] = (UChar )(hi32 & 255U);
  n->b[3] = (UChar )((lo32 >> 24) & 255U);
  n->b[2] = (UChar )((lo32 >> 16) & 255U);
  n->b[1] = (UChar )((lo32 >> 8) & 255U);
  n->b[0] = (UChar )(lo32 & 255U);
  return;
}
}
static double uInt64_to_double(UInt64 *n ) 
{ 
  Int32 i ;
  double base ;
  double sum ;

  {
  base = 1.0;
  sum = 0.0;
  i = 0;
  while (i < 8) {
    sum += base * (double )n->b[i];
    base *= 256.0;
    i ++;
  }
  return (sum);
}
}
static Bool uInt64_isZero(UInt64 *n ) 
{ 
  Int32 i ;

  {
  i = 0;
  while (i < 8) {
    if ((int )n->b[i] != 0) {
      return ((Bool )0);
    }
    i ++;
  }
  return ((Bool )1);
}
}
static Int32 uInt64_qrm10(UInt64 *n ) 
{ 
  UInt32 rem ;
  UInt32 tmp ;
  Int32 i ;

  {
  rem = (UInt32 )0;
  i = 7;
  while (i >= 0) {
    tmp = rem * 256U + (UInt32 )n->b[i];
    n->b[i] = (UChar )(tmp / 10U);
    rem = tmp % 10U;
    i --;
  }
  return ((Int32 )rem);
}
}
static void uInt64_toAscii(char *outbuf , UInt64 *n ) 
{ 
  Int32 i ;
  Int32 q ;
  UChar buf[32] ;
  Int32 nBuf ;
  UInt64 n_copy ;
  Bool tmp ;

  {
  nBuf = 0;
  n_copy = *n;
  while (1) {
    q = uInt64_qrm10(& n_copy);
    buf[nBuf] = (UChar )(q + 48);
    nBuf ++;
    tmp = uInt64_isZero(& n_copy);
    if (tmp) {
      break;
    }
  }
  *(outbuf + nBuf) = (char)0;
  i = 0;
  while (i < nBuf) {
    *(outbuf + i) = (char )buf[(nBuf - i) - 1];
    i ++;
  }
  return;
}
}
static Bool myfeof(int f ) 
{ 
  Int32 c ;
  int tmp ;

  {
  tmp = spec_getc(f);
  c = tmp;
  if (c == -1) {
    return ((Bool )1);
  }
  spec_ungetc((unsigned char )c, f);
  return ((Bool )0);
}
}
void compressStream(int stream , int zStream ) 
{ 
  BZFILE *bzf ;
  UChar ibuf[5000] ;
  Int32 nIbuf ;
  UInt32 nbytes_in_lo32 ;
  UInt32 nbytes_in_hi32 ;
  UInt32 nbytes_out_lo32 ;
  UInt32 nbytes_out_hi32 ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  Bool tmp ;
  Char buf_nin[32] ;
  Char buf_nout[32] ;
  UInt64 nbytes_in ;
  UInt64 nbytes_out ;
  double nbytes_in_d ;
  double nbytes_out_d ;

  {
  bzf = (void *)0;
  bzf = BZ2_bzWriteOpen(& bzerr, zStream, blockSize100k, verbosity, workFactor);
  if (bzerr != 0) {
    goto errhandler;
  }
  if (verbosity >= 2) {
    fprintf(__stderrp, "\n");
  }
  while (1) {
    tmp = myfeof(stream);
    if (tmp) {
      break;
    }
    nIbuf = spec_fread(ibuf, (int )sizeof(UChar ), 5000, stream);
    if (nIbuf > 0) {
      BZ2_bzWrite(& bzerr, bzf, (void *)(ibuf), nIbuf);
    }
    if (bzerr != 0) {
      goto errhandler;
    }
  }
  BZ2_bzWriteClose64(& bzerr, bzf, 0, & nbytes_in_lo32, & nbytes_in_hi32, & nbytes_out_lo32,
                     & nbytes_out_hi32);
  if (bzerr != 0) {
    goto errhandler;
  }
  ret = 0;
  if (ret == -1) {
    goto errhandler_io;
  }
  if (zStream != 1) {
    ret = 0;
    outputHandleJustInCase = (int )((void *)0);
    if (ret == -1) {
      goto errhandler_io;
    }
  }
  outputHandleJustInCase = (int )((void *)0);
  ret = 0;
  if (ret == -1) {
    goto errhandler_io;
  }
  if (verbosity >= 1) {
    if (nbytes_in_lo32 == 0U) {
      if (nbytes_in_hi32 == 0U) {
        fprintf(__stderrp, " no data compressed.\n");
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      uInt64_from_UInt32s(& nbytes_in, nbytes_in_lo32, nbytes_in_hi32);
      uInt64_from_UInt32s(& nbytes_out, nbytes_out_lo32, nbytes_out_hi32);
      nbytes_in_d = uInt64_to_double(& nbytes_in);
      nbytes_out_d = uInt64_to_double(& nbytes_out);
      uInt64_toAscii(buf_nin, & nbytes_in);
      uInt64_toAscii(buf_nout, & nbytes_out);
      fprintf(__stderrp, "%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %s in, %s out.\n",
              nbytes_in_d / nbytes_out_d, (8.0 * nbytes_out_d) / nbytes_in_d, 100.0 * (1.0 - nbytes_out_d / nbytes_in_d),
              buf_nin, buf_nout);
    }
  }
  return;
  errhandler: 
  BZ2_bzWriteClose64(& bzerr_dummy, bzf, 1, & nbytes_in_lo32, & nbytes_in_hi32, & nbytes_out_lo32,
                     & nbytes_out_hi32);
  switch (bzerr) {
  case -9: 
  configError();
  break;
  case -3: 
  outOfMemory();
  break;
  errhandler_io: 
  case -6: 
  ioError();
  break;
  default: 
  panic((Char *)"compress:unexpected error");
  }
  panic((Char *)"compress:end");
  return;
}
}
unsigned char uncompressStream(int zStream , int stream ) 
{ 
  BZFILE *bzf ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  Int32 nread ;
  Int32 streamNo ;
  Int32 i ;
  UChar obuf[5000] ;
  UChar unused[5000] ;
  Int32 nUnused ;
  void *unusedTmpV ;
  UChar *unusedTmp ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  bzf = (void *)0;
  nUnused = 0;
  streamNo = 0;
  while (1) {
    bzf = BZ2_bzReadOpen(& bzerr, zStream, verbosity, (int )smallMode, (void *)(unused),
                         nUnused);
    if ((unsigned long )bzf == (unsigned long )((void *)0)) {
      goto errhandler;
    } else
    if (bzerr != 0) {
      goto errhandler;
    }
    streamNo ++;
    while (bzerr == 0) {
      nread = BZ2_bzRead(& bzerr, bzf, (void *)(obuf), 5000);
      if (bzerr == -5) {
        goto trycat;
      }
      if (bzerr == 0) {
        goto _L;
      } else
      if (bzerr == 4) {
        _L: /* CIL Label */ 
        if (nread > 0) {
          spec_fwrite(obuf, (int )sizeof(UChar ), nread, stream);
        }
      }
    }
    if (bzerr != 4) {
      goto errhandler;
    }
    BZ2_bzReadGetUnused(& bzerr, bzf, & unusedTmpV, & nUnused);
    if (bzerr != 0) {
      panic((Char *)"decompress:bzReadGetUnused");
    }
    unusedTmp = (UChar *)unusedTmpV;
    i = 0;
    while (i < nUnused) {
      unused[i] = *(unusedTmp + i);
      i ++;
    }
    BZ2_bzReadClose(& bzerr, bzf);
    if (bzerr != 0) {
      panic((Char *)"decompress:bzReadGetUnused");
    }
    if (nUnused == 0) {
      tmp = myfeof(zStream);
      if (tmp) {
        break;
      }
    }
  }
  closeok: 
  ret = 0;
  if (ret == -1) {
    goto errhandler_io;
  }
  ret = 0;
  if (ret != 0) {
    goto errhandler_io;
  }
  if (stream != 1) {
    ret = 0;
    outputHandleJustInCase = (int )((void *)0);
    if (ret == -1) {
      goto errhandler_io;
    }
  }
  outputHandleJustInCase = (int )((void *)0);
  if (verbosity >= 2) {
    fprintf(__stderrp, "\n    ");
  }
  return ((Bool )1);
  trycat: 
  if (forceOverwrite) {
    spec_rewind(zStream);
    while (1) {
      tmp___0 = myfeof(zStream);
      if (tmp___0) {
        break;
      }
      nread = spec_fread(obuf, (int )sizeof(UChar ), 5000, zStream);
      if (nread > 0) {
        spec_fwrite(obuf, (int )sizeof(UChar ), nread, stream);
      }
    }
    goto closeok;
  }
  errhandler: 
  BZ2_bzReadClose(& bzerr_dummy, bzf);
  switch (bzerr) {
  case -9: 
  configError();
  break;
  errhandler_io: 
  case -6: 
  ioError();
  break;
  case -4: 
  crcError();
  case -3: 
  outOfMemory();
  case -7: 
  compressedStreamEOF();
  case -5: ;
  if (streamNo == 1) {
    return ((Bool )0);
  } else {
    if (noisy) {
      fprintf(__stderrp, "\n%s: %s: trailing garbage after EOF ignored\n", progName,
              inName);
    }
    return ((Bool )1);
  }
  default: 
  panic((Char *)"decompress:unexpected error");
  }
  panic((Char *)"decompress:end");
  return ((Bool )1);
}
}
static void setExit(Int32 v ) 
{ 


  {
  exitValue = 0;
  return;
}
}
static void cadvise(void) 
{ 


  {
  if (noisy) {
    fprintf(__stderrp, "\nIt is possible that the compressed file(s) have become corrupted.\nYou can use the -tvv option to test integrity of such files.\n\nYou can use the `bzip2recover\' program to attempt to recover\ndata from undamaged sections of corrupted files.\n\n");
  }
  return;
}
}
static void showFileNames(void) 
{ 


  {
  if (noisy) {
    fprintf(__stderrp, "\tInput file = %s, output file = %s\n", inName, outName);
  }
  return;
}
}
static void cleanUpAndFail(Int32 ec ) 
{ 


  {
  setExit(ec);
  exit(exitValue);
}
}
static void panic(Char *s ) 
{ 


  {
  fprintf(__stderrp, "\n%s: PANIC -- internal consistency error:\n\t%s\n\tThis is probably a BUG, but it may be in your COMPILER.  Please do not bother\n\tthe original author.\n",
          progName, s);
  showFileNames();
  cleanUpAndFail(3);
  return;
}
}
static void crcError(void) 
{ 


  {
  fprintf(__stderrp, "\n%s: Data integrity error when decompressing.\n", progName);
  showFileNames();
  cadvise();
  cleanUpAndFail(2);
  return;
}
}
static void compressedStreamEOF(void) 
{ 


  {
  if (noisy) {
    fprintf(__stderrp, "\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n",
            progName);
    perror((char const   *)progName);
    showFileNames();
    cadvise();
  }
  cleanUpAndFail(2);
  return;
}
}
static void ioError(void) 
{ 


  {
  fprintf(__stderrp, "\n%s: I/O or other error, bailing out.  Possible reason follows.\n",
          progName);
  perror((char const   *)progName);
  showFileNames();
  cleanUpAndFail(1);
  return;
}
}
static void outOfMemory(void) 
{ 


  {
  fprintf(__stderrp, "\n%s: couldn\'t allocate enough memory\n", progName);
  showFileNames();
  cleanUpAndFail(1);
  return;
}
}
static void configError(void) 
{ 


  {
  fprintf(__stderrp, "bzip2: I\'m not configured correctly for this platform!\n\tI require Int32, Int16 and Char to have sizes\n\tof 4, 2 and 1 bytes to run properly, and they don\'t.\n\tProbably you can fix this by defining them correctly,\n\tand recompiling.  Bye!\n");
  setExit(3);
  exit(exitValue);
}
}
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-FVkVmTfF.i","-O3")
extern void free(void * ) ;
extern _RuneLocale _DefaultRuneLocale ;
__inline static __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c , unsigned long _f ) 
{ 
  int tmp ;

  {
  if (_c < 0) {
    tmp = 0;
  } else
  if (_c >= 1 << 8) {
    tmp = 0;
  } else {
    tmp = ! (! ((unsigned long )_DefaultRuneLocale.__runetype[_c] & _f));
  }
  return (tmp);
}
}
__inline static int isdigit(int _c ) 
{ 
  __darwin_ct_rune_t tmp ;

  {
  tmp = __isctype(_c, 1024UL);
  return (tmp);
}
}
extern int strcmp(char const   * , char const   * ) ;
__inline static char *__inline_strcat_chk(char *__dest , char const   *__src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcat_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
int BZ2_bzCompressInit(bz_stream *strm , int blockSize100k___0 , int verbosity___0 ,
                       int workFactor___0 ) ;
int BZ2_bzCompress(bz_stream *strm , int action ) ;
int BZ2_bzCompressEnd(bz_stream *strm ) ;
int BZ2_bzDecompressInit(bz_stream *strm , int verbosity___0 , int small ) ;
int BZ2_bzDecompress(bz_stream *strm ) ;
int BZ2_bzDecompressEnd(bz_stream *strm ) ;
void BZ2_bzWriteClose(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in ,
                      unsigned int *nbytes_out ) ;
int BZ2_bzBuffToBuffCompress(char *dest , unsigned int *destLen , char *source , unsigned int sourceLen ,
                             int blockSize100k___0 , int verbosity___0 , int workFactor___0 ) ;
int BZ2_bzBuffToBuffDecompress(char *dest , unsigned int *destLen , char *source ,
                               unsigned int sourceLen , int small , int verbosity___0 ) ;
char const   *BZ2_bzlibVersion(void) ;
BZFILE *BZ2_bzopen(char const   *path , char const   *mode ) ;
BZFILE *BZ2_bzdopen(int fd , char const   *mode ) ;
int BZ2_bzread(BZFILE *b , void *buf , int len ) ;
int BZ2_bzwrite(BZFILE *b , void *buf , int len ) ;
int BZ2_bzflush(BZFILE *b ) ;
void BZ2_bzclose(BZFILE *b ) ;
char const   *BZ2_bzerror(BZFILE *b , int *errnum ) ;
Int32 BZ2_rNums[512] ;
UInt32 BZ2_crc32Table[256] ;
void BZ2_compressBlock(EState *s , Bool is_last_block ) ;
Int32 BZ2_indexIntoF(Int32 indx , Int32 *cftab ) ;
Int32 BZ2_decompress(DState *s ) ;
void BZ2_bz__AssertH__fail(int errcode ) 
{ 
  char const   *tmp ;

  {
  tmp = BZ2_bzlibVersion();
  fprintf(__stderrp, "\n\nbzip2/libbzip2: internal error number %d.\nThis may be a bug in bzip2/libbzip2, %s.\nIt may also be a bug in your compiler.  Please do not bother the\noriginal author of bzip2 with a bug report for this.  He\ndoesn\'t know anything about bzip2 as it appears in CPU2006.\n\n",
          errcode, tmp);
  if (errcode == 1007) {
    fprintf(__stderrp, "\n*** A special note about internal error number 1007 ***\n\nExperience suggests that a common cause of i.e. 1007\nis unreliable memory or other hardware.  The 1007 assertion\njust happens to cross-check the results of huge numbers of\nmemory reads/writes, and so acts (unintendedly) as a stress\ntest of your memory system.\n\nI suggest the following: try compressing the file again,\npossibly monitoring progress in detail with the -vv flag.\n\n* If the error cannot be reproduced, and/or happens at different\n  points in compression, you may have a flaky memory system.\n  Try a memory-test program.  I have used Memtest86\n  (www.memtest86.com).  At the time of writing it is free (GPLd).\n  Memtest86 tests memory much more thorougly than your BIOSs\n  power-on test, and may find failures that the BIOS doesn\'t.\n\n* If the error can be repeatably reproduced, this is a bug in\n  bzip2, and I would very much like to hear about it.  Please\n  let me know, and, ideally, save a copy of the file causing the\n  problem -- without which I will be unable to investigate it.\n\n");
  }
  exit(0);
}
}
static int bz_config_ok(void) 
{ 


  {
  if (sizeof(int ) != 4UL) {
    return (0);
  }
  if (sizeof(short ) != 2UL) {
    return (0);
  }
  if (sizeof(char ) != 1UL) {
    return (0);
  }
  return (1);
}
}
static void *default_bzalloc(void *opaque , Int32 items , Int32 size ) 
{ 
  void *v ;
  void *tmp ;

  {
  tmp = malloc((size_t )(items * size));
  v = tmp;
  return (v);
}
}
static void default_bzfree(void *opaque , void *addr ) 
{ 


  {
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    free(addr);
  }
  return;
}
}
static void prepare_new_block(EState *s ) 
{ 
  Int32 i ;

  {
  s->nblock = 0;
  s->numZ = 0;
  s->state_out_pos = 0;
  s->blockCRC = (UInt32 )4294967295L;
  i = 0;
  while (i < 256) {
    s->inUse[i] = (Bool )0;
    i ++;
  }
  (s->blockNo) ++;
  return;
}
}
static void init_RL(EState *s ) 
{ 


  {
  s->state_in_ch = (UInt32 )256;
  s->state_in_len = 0;
  return;
}
}
static Bool isempty_RL(EState *s ) 
{ 


  {
  if (s->state_in_ch < 256U) {
    if (s->state_in_len > 0) {
      return ((Bool )0);
    } else {
      return ((Bool )1);
    }
  } else {
    return ((Bool )1);
  }
}
}
int BZ2_bzCompressInit(bz_stream *strm , int blockSize100k___0 , int verbosity___0 ,
                       int workFactor___0 ) 
{ 
  Int32 n ;
  EState *s ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  tmp = bz_config_ok();
  if (! tmp) {
    return (-9);
  }
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
    return (-2);
  } else
  if (blockSize100k___0 < 1) {
    return (-2);
  } else
  if (blockSize100k___0 > 9) {
    return (-2);
  } else
  if (workFactor___0 < 0) {
    return (-2);
  } else
  if (workFactor___0 > 250) {
    return (-2);
  }
  if (workFactor___0 == 0) {
    workFactor___0 = 30;
  }
  if ((unsigned long )strm->bzalloc == (unsigned long )((void *)0)) {
    strm->bzalloc = & default_bzalloc;
  }
  if ((unsigned long )strm->bzfree == (unsigned long )((void *)0)) {
    strm->bzfree = & default_bzfree;
  }
  tmp___0 = (*(strm->bzalloc))(strm->opaque, (int )sizeof(EState ), 1);
  s = (EState *)tmp___0;
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return (-3);
  }
  s->strm = strm;
  s->arr1 = (UInt32 *)((void *)0);
  s->arr2 = (UInt32 *)((void *)0);
  s->ftab = (UInt32 *)((void *)0);
  n = 100000 * blockSize100k___0;
  tmp___1 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )n * sizeof(UInt32 )),
                               1);
  s->arr1 = (UInt32 *)tmp___1;
  tmp___2 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )(n + 34) * sizeof(UInt32 )),
                               1);
  s->arr2 = (UInt32 *)tmp___2;
  tmp___3 = (*(strm->bzalloc))(strm->opaque, (int )(65537UL * sizeof(UInt32 )), 1);
  s->ftab = (UInt32 *)tmp___3;
  if ((unsigned long )s->arr1 == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )s->arr2 == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )s->ftab == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    if ((unsigned long )s->arr1 != (unsigned long )((void *)0)) {
      (*(strm->bzfree))(strm->opaque, (void *)s->arr1);
    }
    if ((unsigned long )s->arr2 != (unsigned long )((void *)0)) {
      (*(strm->bzfree))(strm->opaque, (void *)s->arr2);
    }
    if ((unsigned long )s->ftab != (unsigned long )((void *)0)) {
      (*(strm->bzfree))(strm->opaque, (void *)s->ftab);
    }
    if ((unsigned long )s != (unsigned long )((void *)0)) {
      (*(strm->bzfree))(strm->opaque, (void *)s);
    }
    return (-3);
  }
  s->blockNo = 0;
  s->state = 2;
  s->mode = 2;
  s->combinedCRC = (UInt32 )0;
  s->blockSize100k = blockSize100k___0;
  s->nblockMAX = 100000 * blockSize100k___0 - 19;
  s->verbosity = verbosity___0;
  s->workFactor = workFactor___0;
  s->block = (UChar *)s->arr2;
  s->mtfv = (UInt16 *)s->arr1;
  s->zbits = (UChar *)((void *)0);
  s->ptr = s->arr1;
  strm->state = (void *)s;
  strm->total_in_lo32 = 0U;
  strm->total_in_hi32 = 0U;
  strm->total_out_lo32 = 0U;
  strm->total_out_hi32 = 0U;
  init_RL(s);
  prepare_new_block(s);
  return (0);
}
}
static void add_pair_to_block(EState *s ) 
{ 
  Int32 i ;
  UChar ch ;

  {
  ch = (UChar )s->state_in_ch;
  i = 0;
  while (i < s->state_in_len) {
    s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch];
    i ++;
  }
  s->inUse[s->state_in_ch] = (Bool )1;
  switch (s->state_in_len) {
  case 1: 
  *(s->block + s->nblock) = ch;
  (s->nblock) ++;
  break;
  case 2: 
  *(s->block + s->nblock) = ch;
  (s->nblock) ++;
  *(s->block + s->nblock) = ch;
  (s->nblock) ++;
  break;
  case 3: 
  *(s->block + s->nblock) = ch;
  (s->nblock) ++;
  *(s->block + s->nblock) = ch;
  (s->nblock) ++;
  *(s->block + s->nblock) = ch;
  (s->nblock) ++;
  break;
  default: 
  s->inUse[s->state_in_len - 4] = (Bool )1;
  *(s->block + s->nblock) = ch;
  (s->nblock) ++;
  *(s->block + s->nblock) = ch;
  (s->nblock) ++;
  *(s->block + s->nblock) = ch;
  (s->nblock) ++;
  *(s->block + s->nblock) = ch;
  (s->nblock) ++;
  *(s->block + s->nblock) = (UChar )(s->state_in_len - 4);
  (s->nblock) ++;
  break;
  }
  return;
}
}
static void flush_RL(EState *s ) 
{ 


  {
  if (s->state_in_ch < 256U) {
    add_pair_to_block(s);
  }
  init_RL(s);
  return;
}
}
static Bool copy_input_until_stop(EState *s ) 
{ 
  Bool progress_in ;
  UInt32 zchh ;
  UChar ch ;
  UInt32 zchh___0 ;
  UChar ch___0 ;

  {
  progress_in = (Bool )0;
  if (s->mode == 2) {
    while (! (s->nblock >= s->nblockMAX)) {
      if ((s->strm)->avail_in == 0U) {
        break;
      }
      progress_in = (Bool )1;
      zchh = (UInt32 )*((UChar *)(s->strm)->next_in);
      if (zchh != s->state_in_ch) {
        if (s->state_in_len == 1) {
          ch = (UChar )s->state_in_ch;
          s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch];
          s->inUse[s->state_in_ch] = (Bool )1;
          *(s->block + s->nblock) = ch;
          (s->nblock) ++;
          s->state_in_ch = zchh;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (zchh != s->state_in_ch) {
        goto _L;
      } else
      if (s->state_in_len == 255) {
        _L: /* CIL Label */ 
        if (s->state_in_ch < 256U) {
          add_pair_to_block(s);
        }
        s->state_in_ch = zchh;
        s->state_in_len = 1;
      } else {
        (s->state_in_len) ++;
      }
      ((s->strm)->next_in) ++;
      ((s->strm)->avail_in) --;
      ((s->strm)->total_in_lo32) ++;
      if ((s->strm)->total_in_lo32 == 0U) {
        ((s->strm)->total_in_hi32) ++;
      }
    }
  } else {
    while (! (s->nblock >= s->nblockMAX)) {
      if ((s->strm)->avail_in == 0U) {
        break;
      }
      if (s->avail_in_expect == 0U) {
        break;
      }
      progress_in = (Bool )1;
      zchh___0 = (UInt32 )*((UChar *)(s->strm)->next_in);
      if (zchh___0 != s->state_in_ch) {
        if (s->state_in_len == 1) {
          ch___0 = (UChar )s->state_in_ch;
          s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch___0];
          s->inUse[s->state_in_ch] = (Bool )1;
          *(s->block + s->nblock) = ch___0;
          (s->nblock) ++;
          s->state_in_ch = zchh___0;
        } else {
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
      if (zchh___0 != s->state_in_ch) {
        goto _L___1;
      } else
      if (s->state_in_len == 255) {
        _L___1: /* CIL Label */ 
        if (s->state_in_ch < 256U) {
          add_pair_to_block(s);
        }
        s->state_in_ch = zchh___0;
        s->state_in_len = 1;
      } else {
        (s->state_in_len) ++;
      }
      ((s->strm)->next_in) ++;
      ((s->strm)->avail_in) --;
      ((s->strm)->total_in_lo32) ++;
      if ((s->strm)->total_in_lo32 == 0U) {
        ((s->strm)->total_in_hi32) ++;
      }
      (s->avail_in_expect) --;
    }
  }
  return (progress_in);
}
}
static Bool copy_output_until_stop(EState *s ) 
{ 
  Bool progress_out ;

  {
  progress_out = (Bool )0;
  while (! ((s->strm)->avail_out == 0U)) {
    if (s->state_out_pos >= s->numZ) {
      break;
    }
    progress_out = (Bool )1;
    *((s->strm)->next_out) = (char )*(s->zbits + s->state_out_pos);
    (s->state_out_pos) ++;
    ((s->strm)->avail_out) --;
    ((s->strm)->next_out) ++;
    ((s->strm)->total_out_lo32) ++;
    if ((s->strm)->total_out_lo32 == 0U) {
      ((s->strm)->total_out_hi32) ++;
    }
  }
  return (progress_out);
}
}
static Bool handle_compress(bz_stream *strm ) 
{ 
  Bool progress_in ;
  Bool progress_out ;
  EState *s ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;

  {
  progress_in = (Bool )0;
  progress_out = (Bool )0;
  s = (EState *)strm->state;
  while (1) {
    if (s->state == 1) {
      tmp = copy_output_until_stop(s);
      progress_out = (Bool )((int )progress_out | (int )tmp);
      if (s->state_out_pos < s->numZ) {
        break;
      }
      if (s->mode == 4) {
        if (s->avail_in_expect == 0U) {
          tmp___0 = isempty_RL(s);
          if (tmp___0) {
            break;
          }
        }
      }
      prepare_new_block(s);
      s->state = 2;
      if (s->mode == 3) {
        if (s->avail_in_expect == 0U) {
          tmp___1 = isempty_RL(s);
          if (tmp___1) {
            break;
          }
        }
      }
    }
    if (s->state == 2) {
      tmp___2 = copy_input_until_stop(s);
      progress_in = (Bool )((int )progress_in | (int )tmp___2);
      if (s->mode != 2) {
        if (s->avail_in_expect == 0U) {
          flush_RL(s);
          BZ2_compressBlock(s, (Bool )(s->mode == 4));
          s->state = 1;
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (s->nblock >= s->nblockMAX) {
        BZ2_compressBlock(s, (Bool )0);
        s->state = 1;
      } else
      if ((s->strm)->avail_in == 0U) {
        break;
      }
    }
  }
  if (progress_in) {
    tmp___3 = 1;
  } else
  if (progress_out) {
    tmp___3 = 1;
  } else {
    tmp___3 = 0;
  }
  return ((Bool )tmp___3);
}
}
int BZ2_bzCompress(bz_stream *strm , int action ) 
{ 
  Bool progress ;
  EState *s ;
  int tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
    return (-2);
  }
  s = (EState *)strm->state;
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return (-2);
  }
  if ((unsigned long )s->strm != (unsigned long )strm) {
    return (-2);
  }
  preswitch: 
  switch (s->mode) {
  case 1: 
  return (-1);
  case 2: 
  if (action == 0) {
    progress = handle_compress(strm);
    if (progress) {
      tmp = 1;
    } else {
      tmp = -2;
    }
    return (tmp);
  } else
  if (action == 1) {
    s->avail_in_expect = strm->avail_in;
    s->mode = 3;
    goto preswitch;
  } else
  if (action == 2) {
    s->avail_in_expect = strm->avail_in;
    s->mode = 4;
    goto preswitch;
  } else {
    return (-2);
  }
  case 3: 
  if (action != 1) {
    return (-1);
  }
  if (s->avail_in_expect != (s->strm)->avail_in) {
    return (-1);
  }
  progress = handle_compress(strm);
  if (s->avail_in_expect > 0U) {
    return (2);
  } else {
    tmp___0 = isempty_RL(s);
    if (tmp___0) {
      if (s->state_out_pos < s->numZ) {
        return (2);
      }
    } else {
      return (2);
    }
  }
  s->mode = 2;
  return (1);
  case 4: 
  if (action != 2) {
    return (-1);
  }
  if (s->avail_in_expect != (s->strm)->avail_in) {
    return (-1);
  }
  progress = handle_compress(strm);
  if (! progress) {
    return (-1);
  }
  if (s->avail_in_expect > 0U) {
    return (3);
  } else {
    tmp___1 = isempty_RL(s);
    if (tmp___1) {
      if (s->state_out_pos < s->numZ) {
        return (3);
      }
    } else {
      return (3);
    }
  }
  s->mode = 1;
  return (4);
  }
  return (0);
}
}
int BZ2_bzCompressEnd(bz_stream *strm ) 
{ 
  EState *s ;

  {
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
    return (-2);
  }
  s = (EState *)strm->state;
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return (-2);
  }
  if ((unsigned long )s->strm != (unsigned long )strm) {
    return (-2);
  }
  if ((unsigned long )s->arr1 != (unsigned long )((void *)0)) {
    (*(strm->bzfree))(strm->opaque, (void *)s->arr1);
  }
  if ((unsigned long )s->arr2 != (unsigned long )((void *)0)) {
    (*(strm->bzfree))(strm->opaque, (void *)s->arr2);
  }
  if ((unsigned long )s->ftab != (unsigned long )((void *)0)) {
    (*(strm->bzfree))(strm->opaque, (void *)s->ftab);
  }
  (*(strm->bzfree))(strm->opaque, strm->state);
  strm->state = (void *)0;
  return (0);
}
}
int BZ2_bzDecompressInit(bz_stream *strm , int verbosity___0 , int small ) 
{ 
  DState *s ;
  int tmp ;
  void *tmp___0 ;

  {
  tmp = bz_config_ok();
  if (! tmp) {
    return (-9);
  }
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
    return (-2);
  }
  if (small != 0) {
    if (small != 1) {
      return (-2);
    }
  }
  if (verbosity___0 < 0) {
    return (-2);
  } else
  if (verbosity___0 > 4) {
    return (-2);
  }
  if ((unsigned long )strm->bzalloc == (unsigned long )((void *)0)) {
    strm->bzalloc = & default_bzalloc;
  }
  if ((unsigned long )strm->bzfree == (unsigned long )((void *)0)) {
    strm->bzfree = & default_bzfree;
  }
  tmp___0 = (*(strm->bzalloc))(strm->opaque, (int )sizeof(DState ), 1);
  s = (DState *)tmp___0;
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return (-3);
  }
  s->strm = strm;
  strm->state = (void *)s;
  s->state = 10;
  s->bsLive = 0;
  s->bsBuff = (UInt32 )0;
  s->calculatedCombinedCRC = (UInt32 )0;
  strm->total_in_lo32 = 0U;
  strm->total_in_hi32 = 0U;
  strm->total_out_lo32 = 0U;
  strm->total_out_hi32 = 0U;
  s->smallDecompress = (Bool )small;
  s->ll4 = (UChar *)((void *)0);
  s->ll16 = (UInt16 *)((void *)0);
  s->tt = (UInt32 *)((void *)0);
  s->currBlockNo = 0;
  s->verbosity = verbosity___0;
  return (0);
}
}
static Bool unRLE_obuf_to_output_FAST(DState *s ) 
{ 
  UChar k1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  UInt32 c_calculatedBlockCRC ;
  UChar c_state_out_ch ;
  Int32 c_state_out_len ;
  Int32 c_nblock_used ;
  Int32 c_k0 ;
  UInt32 *c_tt ;
  UInt32 c_tPos ;
  char *cs_next_out ;
  unsigned int cs_avail_out ;
  UInt32 avail_out_INIT ;
  Int32 s_save_nblockPP ;
  unsigned int total_out_lo32_old ;

  {
  if (s->blockRandomised) {
    while (1) {
      while (1) {
        if ((s->strm)->avail_out == 0U) {
          return ((Bool )0);
        }
        if (s->state_out_len == 0) {
          break;
        }
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
        (s->state_out_len) --;
        ((s->strm)->next_out) ++;
        ((s->strm)->avail_out) --;
        ((s->strm)->total_out_lo32) ++;
        if ((s->strm)->total_out_lo32 == 0U) {
          ((s->strm)->total_out_hi32) ++;
        }
      }
      if (s->nblock_used == s->save_nblock + 1) {
        return ((Bool )0);
      }
      if (s->nblock_used > s->save_nblock + 1) {
        return ((Bool )1);
      }
      s->state_out_len = 1;
      s->state_out_ch = (UChar )s->k0;
      s->tPos = *(s->tt + s->tPos);
      k1 = (UChar )(s->tPos & 255U);
      s->tPos >>= 8;
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp = 1;
      } else {
        tmp = 0;
      }
      k1 = (UChar )((int )k1 ^ tmp);
      (s->nblock_used) ++;
      if (s->nblock_used == s->save_nblock + 1) {
        continue;
      }
      if ((int )k1 != s->k0) {
        s->k0 = (Int32 )k1;
        continue;
      }
      s->state_out_len = 2;
      s->tPos = *(s->tt + s->tPos);
      k1 = (UChar )(s->tPos & 255U);
      s->tPos >>= 8;
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
      k1 = (UChar )((int )k1 ^ tmp___0);
      (s->nblock_used) ++;
      if (s->nblock_used == s->save_nblock + 1) {
        continue;
      }
      if ((int )k1 != s->k0) {
        s->k0 = (Int32 )k1;
        continue;
      }
      s->state_out_len = 3;
      s->tPos = *(s->tt + s->tPos);
      k1 = (UChar )(s->tPos & 255U);
      s->tPos >>= 8;
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
      k1 = (UChar )((int )k1 ^ tmp___1);
      (s->nblock_used) ++;
      if (s->nblock_used == s->save_nblock + 1) {
        continue;
      }
      if ((int )k1 != s->k0) {
        s->k0 = (Int32 )k1;
        continue;
      }
      s->tPos = *(s->tt + s->tPos);
      k1 = (UChar )(s->tPos & 255U);
      s->tPos >>= 8;
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
      k1 = (UChar )((int )k1 ^ tmp___2);
      (s->nblock_used) ++;
      s->state_out_len = (Int32 )k1 + 4;
      s->tPos = *(s->tt + s->tPos);
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
      s->tPos >>= 8;
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
      s->k0 ^= tmp___3;
      (s->nblock_used) ++;
    }
  } else {
    c_calculatedBlockCRC = s->calculatedBlockCRC;
    c_state_out_ch = s->state_out_ch;
    c_state_out_len = s->state_out_len;
    c_nblock_used = s->nblock_used;
    c_k0 = s->k0;
    c_tt = s->tt;
    c_tPos = s->tPos;
    cs_next_out = (s->strm)->next_out;
    cs_avail_out = (s->strm)->avail_out;
    avail_out_INIT = cs_avail_out;
    s_save_nblockPP = s->save_nblock + 1;
    while (1) {
      if (c_state_out_len > 0) {
        while (1) {
          if (cs_avail_out == 0U) {
            goto return_notr;
          }
          if (c_state_out_len == 1) {
            break;
          }
          *((UChar *)cs_next_out) = c_state_out_ch;
          c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ (unsigned int )c_state_out_ch];
          c_state_out_len --;
          cs_next_out ++;
          cs_avail_out --;
        }
        s_state_out_len_eq_one: 
        if (cs_avail_out == 0U) {
          c_state_out_len = 1;
          goto return_notr;
        }
        *((UChar *)cs_next_out) = c_state_out_ch;
        c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ (unsigned int )c_state_out_ch];
        cs_next_out ++;
        cs_avail_out --;
      }
      if (c_nblock_used > s_save_nblockPP) {
        return ((Bool )1);
      }
      if (c_nblock_used == s_save_nblockPP) {
        c_state_out_len = 0;
        goto return_notr;
      }
      c_state_out_ch = (UChar )c_k0;
      c_tPos = *(c_tt + c_tPos);
      k1 = (UChar )(c_tPos & 255U);
      c_tPos >>= 8;
      c_nblock_used ++;
      if ((int )k1 != c_k0) {
        c_k0 = (Int32 )k1;
        goto s_state_out_len_eq_one;
      }
      if (c_nblock_used == s_save_nblockPP) {
        goto s_state_out_len_eq_one;
      }
      c_state_out_len = 2;
      c_tPos = *(c_tt + c_tPos);
      k1 = (UChar )(c_tPos & 255U);
      c_tPos >>= 8;
      c_nblock_used ++;
      if (c_nblock_used == s_save_nblockPP) {
        continue;
      }
      if ((int )k1 != c_k0) {
        c_k0 = (Int32 )k1;
        continue;
      }
      c_state_out_len = 3;
      c_tPos = *(c_tt + c_tPos);
      k1 = (UChar )(c_tPos & 255U);
      c_tPos >>= 8;
      c_nblock_used ++;
      if (c_nblock_used == s_save_nblockPP) {
        continue;
      }
      if ((int )k1 != c_k0) {
        c_k0 = (Int32 )k1;
        continue;
      }
      c_tPos = *(c_tt + c_tPos);
      k1 = (UChar )(c_tPos & 255U);
      c_tPos >>= 8;
      c_nblock_used ++;
      c_state_out_len = (Int32 )k1 + 4;
      c_tPos = *(c_tt + c_tPos);
      c_k0 = (Int32 )((UChar )(c_tPos & 255U));
      c_tPos >>= 8;
      c_nblock_used ++;
    }
    return_notr: 
    total_out_lo32_old = (s->strm)->total_out_lo32;
    (s->strm)->total_out_lo32 += avail_out_INIT - cs_avail_out;
    if ((s->strm)->total_out_lo32 < total_out_lo32_old) {
      ((s->strm)->total_out_hi32) ++;
    }
    s->calculatedBlockCRC = c_calculatedBlockCRC;
    s->state_out_ch = c_state_out_ch;
    s->state_out_len = c_state_out_len;
    s->nblock_used = c_nblock_used;
    s->k0 = c_k0;
    s->tt = c_tt;
    s->tPos = c_tPos;
    (s->strm)->next_out = cs_next_out;
    (s->strm)->avail_out = cs_avail_out;
  }
  return ((Bool )0);
}
}
Int32 BZ2_indexIntoF(Int32 indx , Int32 *cftab ) 
{ 
  Int32 nb ;
  Int32 na ;
  Int32 mid ;

  {
  nb = 0;
  na = 256;
  while (1) {
    mid = (nb + na) >> 1;
    if (indx >= *(cftab + mid)) {
      nb = mid;
    } else {
      na = mid;
    }
    if (! (na - nb != 1)) {
      break;
    }
  }
  return (nb);
}
}
static Bool unRLE_obuf_to_output_SMALL(DState *s ) 
{ 
  UChar k1 ;
  Int32 tmp ;
  int tmp___0 ;
  Int32 tmp___1 ;
  int tmp___2 ;
  Int32 tmp___3 ;
  int tmp___4 ;
  Int32 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Int32 tmp___8 ;
  Int32 tmp___9 ;
  Int32 tmp___10 ;
  Int32 tmp___11 ;

  {
  if (s->blockRandomised) {
    while (1) {
      while (1) {
        if ((s->strm)->avail_out == 0U) {
          return ((Bool )0);
        }
        if (s->state_out_len == 0) {
          break;
        }
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
        (s->state_out_len) --;
        ((s->strm)->next_out) ++;
        ((s->strm)->avail_out) --;
        ((s->strm)->total_out_lo32) ++;
        if ((s->strm)->total_out_lo32 == 0U) {
          ((s->strm)->total_out_hi32) ++;
        }
      }
      if (s->nblock_used == s->save_nblock + 1) {
        return ((Bool )0);
      }
      if (s->nblock_used > s->save_nblock + 1) {
        return ((Bool )1);
      }
      s->state_out_len = 1;
      s->state_out_ch = (UChar )s->k0;
      tmp = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      k1 = (UChar )tmp;
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
      k1 = (UChar )((int )k1 ^ tmp___0);
      (s->nblock_used) ++;
      if (s->nblock_used == s->save_nblock + 1) {
        continue;
      }
      if ((int )k1 != s->k0) {
        s->k0 = (Int32 )k1;
        continue;
      }
      s->state_out_len = 2;
      tmp___1 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      k1 = (UChar )tmp___1;
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
      k1 = (UChar )((int )k1 ^ tmp___2);
      (s->nblock_used) ++;
      if (s->nblock_used == s->save_nblock + 1) {
        continue;
      }
      if ((int )k1 != s->k0) {
        s->k0 = (Int32 )k1;
        continue;
      }
      s->state_out_len = 3;
      tmp___3 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      k1 = (UChar )tmp___3;
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp___4 = 1;
      } else {
        tmp___4 = 0;
      }
      k1 = (UChar )((int )k1 ^ tmp___4);
      (s->nblock_used) ++;
      if (s->nblock_used == s->save_nblock + 1) {
        continue;
      }
      if ((int )k1 != s->k0) {
        s->k0 = (Int32 )k1;
        continue;
      }
      tmp___5 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      k1 = (UChar )tmp___5;
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
      k1 = (UChar )((int )k1 ^ tmp___6);
      (s->nblock_used) ++;
      s->state_out_len = (Int32 )k1 + 4;
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp___7 = 1;
      } else {
        tmp___7 = 0;
      }
      s->k0 ^= tmp___7;
      (s->nblock_used) ++;
    }
  } else {
    while (1) {
      while (1) {
        if ((s->strm)->avail_out == 0U) {
          return ((Bool )0);
        }
        if (s->state_out_len == 0) {
          break;
        }
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
        (s->state_out_len) --;
        ((s->strm)->next_out) ++;
        ((s->strm)->avail_out) --;
        ((s->strm)->total_out_lo32) ++;
        if ((s->strm)->total_out_lo32 == 0U) {
          ((s->strm)->total_out_hi32) ++;
        }
      }
      if (s->nblock_used == s->save_nblock + 1) {
        return ((Bool )0);
      }
      if (s->nblock_used > s->save_nblock + 1) {
        return ((Bool )1);
      }
      s->state_out_len = 1;
      s->state_out_ch = (UChar )s->k0;
      tmp___8 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      k1 = (UChar )tmp___8;
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      (s->nblock_used) ++;
      if (s->nblock_used == s->save_nblock + 1) {
        continue;
      }
      if ((int )k1 != s->k0) {
        s->k0 = (Int32 )k1;
        continue;
      }
      s->state_out_len = 2;
      tmp___9 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      k1 = (UChar )tmp___9;
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      (s->nblock_used) ++;
      if (s->nblock_used == s->save_nblock + 1) {
        continue;
      }
      if ((int )k1 != s->k0) {
        s->k0 = (Int32 )k1;
        continue;
      }
      s->state_out_len = 3;
      tmp___10 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      k1 = (UChar )tmp___10;
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      (s->nblock_used) ++;
      if (s->nblock_used == s->save_nblock + 1) {
        continue;
      }
      if ((int )k1 != s->k0) {
        s->k0 = (Int32 )k1;
        continue;
      }
      tmp___11 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      k1 = (UChar )tmp___11;
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      (s->nblock_used) ++;
      s->state_out_len = (Int32 )k1 + 4;
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      (s->nblock_used) ++;
    }
  }
}
}
int BZ2_bzDecompress(bz_stream *strm ) 
{ 
  Bool corrupt ;
  DState *s ;
  Int32 r ;
  Int32 tmp ;

  {
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
    return (-2);
  }
  s = (DState *)strm->state;
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return (-2);
  }
  if ((unsigned long )s->strm != (unsigned long )strm) {
    return (-2);
  }
  while (1) {
    if (s->state == 1) {
      return (-1);
    }
    if (s->state == 2) {
      if (s->smallDecompress) {
        corrupt = unRLE_obuf_to_output_SMALL(s);
      } else {
        corrupt = unRLE_obuf_to_output_FAST(s);
      }
      if (corrupt) {
        return (-4);
      }
      if (s->nblock_used == s->save_nblock + 1) {
        if (s->state_out_len == 0) {
          s->calculatedBlockCRC = ~ s->calculatedBlockCRC;
          if (s->verbosity >= 3) {
            fprintf(__stderrp, " {0x%08x, 0x%08x}", s->storedBlockCRC, s->calculatedBlockCRC);
          }
          if (s->verbosity >= 2) {
            fprintf(__stderrp, "]");
          }
          if (s->calculatedBlockCRC != s->storedBlockCRC) {
            return (-4);
          }
          s->calculatedCombinedCRC = (s->calculatedCombinedCRC << 1) | (s->calculatedCombinedCRC >> 31);
          s->calculatedCombinedCRC ^= s->calculatedBlockCRC;
          s->state = 14;
        } else {
          return (0);
        }
      } else {
        return (0);
      }
    }
    if (s->state >= 10) {
      tmp = BZ2_decompress(s);
      r = tmp;
      if (r == 4) {
        if (s->verbosity >= 3) {
          fprintf(__stderrp, "\n    combined CRCs: stored = 0x%08x, computed = 0x%08x",
                  s->storedCombinedCRC, s->calculatedCombinedCRC);
        }
        if (s->calculatedCombinedCRC != s->storedCombinedCRC) {
          return (-4);
        }
        return (r);
      }
      if (s->state != 2) {
        return (r);
      }
    }
  }
  BZ2_bz__AssertH__fail(6001);
  return (0);
}
}
int BZ2_bzDecompressEnd(bz_stream *strm ) 
{ 
  DState *s ;

  {
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
    return (-2);
  }
  s = (DState *)strm->state;
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return (-2);
  }
  if ((unsigned long )s->strm != (unsigned long )strm) {
    return (-2);
  }
  if ((unsigned long )s->tt != (unsigned long )((void *)0)) {
    (*(strm->bzfree))(strm->opaque, (void *)s->tt);
  }
  if ((unsigned long )s->ll16 != (unsigned long )((void *)0)) {
    (*(strm->bzfree))(strm->opaque, (void *)s->ll16);
  }
  if ((unsigned long )s->ll4 != (unsigned long )((void *)0)) {
    (*(strm->bzfree))(strm->opaque, (void *)s->ll4);
  }
  (*(strm->bzfree))(strm->opaque, strm->state);
  strm->state = (void *)0;
  return (0);
}
}
static Bool myfeof___0(int f ) 
{ 
  Int32 c ;
  int tmp ;

  {
  tmp = spec_getc(f);
  c = tmp;
  if (c == -1) {
    return ((Bool )1);
  }
  spec_ungetc((unsigned char )c, f);
  return ((Bool )0);
}
}
BZFILE *BZ2_bzWriteOpen(int *bzerror , int f , int blockSize100k___0 , int verbosity___0 ,
                        int workFactor___0 ) 
{ 
  Int32 ret ;
  bzFile *bzf ;
  void *tmp ;

  {
  bzf = (bzFile *)((void *)0);
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
    *bzerror = 0;
  }
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
    bzf->lastErr = 0;
  }
  if (f == (int )((void *)0)) {
    goto _L___0;
  } else
  if (blockSize100k___0 < 1) {
    goto _L___0;
  } else
  if (blockSize100k___0 > 9) {
    goto _L___0;
  } else
  if (workFactor___0 < 0) {
    goto _L___0;
  } else
  if (workFactor___0 > 250) {
    goto _L___0;
  } else
  if (verbosity___0 < 0) {
    goto _L___0;
  } else
  if (verbosity___0 > 4) {
    _L___0: /* CIL Label */ 
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -2;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -2;
    }
    return ((void *)0);
  }
  tmp = malloc(sizeof(bzFile ));
  bzf = (bzFile *)tmp;
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -3;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -3;
    }
    return ((void *)0);
  }
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
    *bzerror = 0;
  }
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
    bzf->lastErr = 0;
  }
  bzf->initialisedOk = (Bool )0;
  bzf->bufN = 0;
  bzf->handle = f;
  bzf->writing = (Bool )1;
  bzf->strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
  bzf->strm.bzfree = (void (*)(void * , void * ))((void *)0);
  bzf->strm.opaque = (void *)0;
  if (workFactor___0 == 0) {
    workFactor___0 = 30;
  }
  ret = BZ2_bzCompressInit(& bzf->strm, blockSize100k___0, verbosity___0, workFactor___0);
  if (ret != 0) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = ret;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = ret;
    }
    free((void *)bzf);
    return ((void *)0);
  }
  bzf->strm.avail_in = 0U;
  bzf->initialisedOk = (Bool )1;
  return ((BZFILE *)bzf);
}
}
void BZ2_bzWrite(int *bzerror , BZFILE *b , void *buf , int len ) 
{ 
  Int32 n ;
  Int32 n2 ;
  Int32 ret ;
  bzFile *bzf ;

  {
  bzf = (bzFile *)b;
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
    *bzerror = 0;
  }
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
    bzf->lastErr = 0;
  }
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if (len < 0) {
    _L: /* CIL Label */ 
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -2;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -2;
    }
    return;
  }
  if (! bzf->writing) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -1;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -1;
    }
    return;
  }
  if (len == 0) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = 0;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = 0;
    }
    return;
  }
  bzf->strm.avail_in = (unsigned int )len;
  bzf->strm.next_in = (char *)buf;
  while (1) {
    bzf->strm.avail_out = 5000U;
    bzf->strm.next_out = bzf->buf;
    ret = BZ2_bzCompress(& bzf->strm, 0);
    if (ret != 1) {
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
        *bzerror = ret;
      }
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
        bzf->lastErr = ret;
      }
      return;
    }
    if (bzf->strm.avail_out < 5000U) {
      n = (Int32 )(5000U - bzf->strm.avail_out);
      n2 = spec_fwrite((unsigned char *)((void *)(bzf->buf)), (int )sizeof(UChar ),
                       n, bzf->handle);
      if (n != n2) {
        goto _L___0;
      } else
      if (0) {
        _L___0: /* CIL Label */ 
        if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
          *bzerror = -6;
        }
        if ((unsigned long )bzf != (unsigned long )((void *)0)) {
          bzf->lastErr = -6;
        }
        return;
      }
    }
    if (bzf->strm.avail_in == 0U) {
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
        *bzerror = 0;
      }
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
        bzf->lastErr = 0;
      }
      return;
    }
  }
}
}
void BZ2_bzWriteClose(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in ,
                      unsigned int *nbytes_out ) 
{ 


  {
  BZ2_bzWriteClose64(bzerror, b, abandon, nbytes_in, (unsigned int *)((void *)0),
                     nbytes_out, (unsigned int *)((void *)0));
  return;
}
}
void BZ2_bzWriteClose64(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in_lo32 ,
                        unsigned int *nbytes_in_hi32 , unsigned int *nbytes_out_lo32 ,
                        unsigned int *nbytes_out_hi32 ) 
{ 
  Int32 n ;
  Int32 n2 ;
  Int32 ret ;
  bzFile *bzf ;
  int tmp ;

  {
  bzf = (bzFile *)b;
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = 0;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = 0;
    }
    return;
  }
  if (! bzf->writing) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -1;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -1;
    }
    return;
  }
  if ((unsigned long )nbytes_in_lo32 != (unsigned long )((void *)0)) {
    *nbytes_in_lo32 = 0U;
  }
  if ((unsigned long )nbytes_in_hi32 != (unsigned long )((void *)0)) {
    *nbytes_in_hi32 = 0U;
  }
  if ((unsigned long )nbytes_out_lo32 != (unsigned long )((void *)0)) {
    *nbytes_out_lo32 = 0U;
  }
  if ((unsigned long )nbytes_out_hi32 != (unsigned long )((void *)0)) {
    *nbytes_out_hi32 = 0U;
  }
  if (! abandon) {
    if (bzf->lastErr == 0) {
      while (1) {
        bzf->strm.avail_out = 5000U;
        bzf->strm.next_out = bzf->buf;
        ret = BZ2_bzCompress(& bzf->strm, 2);
        if (ret != 3) {
          if (ret != 4) {
            if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
              *bzerror = ret;
            }
            if ((unsigned long )bzf != (unsigned long )((void *)0)) {
              bzf->lastErr = ret;
            }
            return;
          }
        }
        if (bzf->strm.avail_out < 5000U) {
          n = (Int32 )(5000U - bzf->strm.avail_out);
          n2 = spec_fwrite((unsigned char *)((void *)(bzf->buf)), (int )sizeof(UChar ),
                           n, bzf->handle);
          if (n != n2) {
            goto _L;
          } else
          if (0) {
            _L: /* CIL Label */ 
            if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
              *bzerror = -6;
            }
            if ((unsigned long )bzf != (unsigned long )((void *)0)) {
              bzf->lastErr = -6;
            }
            return;
          }
        }
        if (ret == 4) {
          break;
        }
      }
    }
  }
  if (! abandon) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  if ((unsigned long )nbytes_in_lo32 != (unsigned long )((void *)0)) {
    *nbytes_in_lo32 = bzf->strm.total_in_lo32;
  }
  if ((unsigned long )nbytes_in_hi32 != (unsigned long )((void *)0)) {
    *nbytes_in_hi32 = bzf->strm.total_in_hi32;
  }
  if ((unsigned long )nbytes_out_lo32 != (unsigned long )((void *)0)) {
    *nbytes_out_lo32 = bzf->strm.total_out_lo32;
  }
  if ((unsigned long )nbytes_out_hi32 != (unsigned long )((void *)0)) {
    *nbytes_out_hi32 = bzf->strm.total_out_hi32;
  }
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
    *bzerror = 0;
  }
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
    bzf->lastErr = 0;
  }
  BZ2_bzCompressEnd(& bzf->strm);
  free((void *)bzf);
  return;
}
}
BZFILE *BZ2_bzReadOpen(int *bzerror , int f , int verbosity___0 , int small , void *unused ,
                       int nUnused ) 
{ 
  bzFile *bzf ;
  int ret ;
  void *tmp ;

  {
  bzf = (bzFile *)((void *)0);
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
    *bzerror = 0;
  }
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
    bzf->lastErr = 0;
  }
  if (f == (int )((void *)0)) {
    goto _L___0;
  } else
  if (small != 0) {
    if (small != 1) {
      goto _L___0;
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (verbosity___0 < 0) {
    goto _L___0;
  } else
  if (verbosity___0 > 4) {
    goto _L___0;
  } else
  if ((unsigned long )unused == (unsigned long )((void *)0)) {
    if (nUnused != 0) {
      goto _L___0;
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if ((unsigned long )unused != (unsigned long )((void *)0)) {
    if (nUnused < 0) {
      goto _L___0;
    } else
    if (nUnused > 5000) {
      _L___0: /* CIL Label */ 
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
        *bzerror = -2;
      }
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
        bzf->lastErr = -2;
      }
      return ((void *)0);
    }
  }
  tmp = malloc(sizeof(bzFile ));
  bzf = (bzFile *)tmp;
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -3;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -3;
    }
    return ((void *)0);
  }
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
    *bzerror = 0;
  }
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
    bzf->lastErr = 0;
  }
  bzf->initialisedOk = (Bool )0;
  bzf->handle = f;
  bzf->bufN = 0;
  bzf->writing = (Bool )0;
  bzf->strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
  bzf->strm.bzfree = (void (*)(void * , void * ))((void *)0);
  bzf->strm.opaque = (void *)0;
  while (nUnused > 0) {
    bzf->buf[bzf->bufN] = (Char )*((UChar *)unused);
    (bzf->bufN) ++;
    unused = (void *)((UChar *)unused + 1);
    nUnused --;
  }
  ret = BZ2_bzDecompressInit(& bzf->strm, verbosity___0, small);
  if (ret != 0) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = ret;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = ret;
    }
    free((void *)bzf);
    return ((void *)0);
  }
  bzf->strm.avail_in = (unsigned int )bzf->bufN;
  bzf->strm.next_in = bzf->buf;
  bzf->initialisedOk = (Bool )1;
  return ((BZFILE *)bzf);
}
}
void BZ2_bzReadClose(int *bzerror , BZFILE *b ) 
{ 
  bzFile *bzf ;

  {
  bzf = (bzFile *)b;
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
    *bzerror = 0;
  }
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
    bzf->lastErr = 0;
  }
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = 0;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = 0;
    }
    return;
  }
  if (bzf->writing) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -1;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -1;
    }
    return;
  }
  if (bzf->initialisedOk) {
    BZ2_bzDecompressEnd(& bzf->strm);
  }
  free((void *)bzf);
  return;
}
}
int BZ2_bzRead(int *bzerror , BZFILE *b , void *buf , int len ) 
{ 
  Int32 n ;
  Int32 ret ;
  bzFile *bzf ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  bzf = (bzFile *)b;
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
    *bzerror = 0;
  }
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
    bzf->lastErr = 0;
  }
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if (len < 0) {
    _L: /* CIL Label */ 
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -2;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -2;
    }
    return (0);
  }
  if (bzf->writing) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -1;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -1;
    }
    return (0);
  }
  if (len == 0) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = 0;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = 0;
    }
    return (0);
  }
  bzf->strm.avail_out = (unsigned int )len;
  bzf->strm.next_out = (char *)buf;
  while (1) {
    if (bzf->strm.avail_in == 0U) {
      tmp = myfeof___0(bzf->handle);
      if (! tmp) {
        n = spec_fread((unsigned char *)(bzf->buf), (int )sizeof(UChar ), 5000, bzf->handle);
        bzf->bufN = n;
        bzf->strm.avail_in = (unsigned int )bzf->bufN;
        bzf->strm.next_in = bzf->buf;
      }
    }
    ret = BZ2_bzDecompress(& bzf->strm);
    if (ret != 0) {
      if (ret != 4) {
        if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
          *bzerror = ret;
        }
        if ((unsigned long )bzf != (unsigned long )((void *)0)) {
          bzf->lastErr = ret;
        }
        return (0);
      }
    }
    if (ret == 0) {
      tmp___0 = myfeof___0(bzf->handle);
      if (tmp___0) {
        if (bzf->strm.avail_in == 0U) {
          if (bzf->strm.avail_out > 0U) {
            if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
              *bzerror = -7;
            }
            if ((unsigned long )bzf != (unsigned long )((void *)0)) {
              bzf->lastErr = -7;
            }
            return (0);
          }
        }
      }
    }
    if (ret == 4) {
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
        *bzerror = 4;
      }
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
        bzf->lastErr = 4;
      }
      return ((int )((unsigned int )len - bzf->strm.avail_out));
    }
    if (bzf->strm.avail_out == 0U) {
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
        *bzerror = 0;
      }
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
        bzf->lastErr = 0;
      }
      return (len);
    }
  }
  return (0);
}
}
void BZ2_bzReadGetUnused(int *bzerror , BZFILE *b , void **unused , int *nUnused ) 
{ 
  bzFile *bzf ;

  {
  bzf = (bzFile *)b;
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -2;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -2;
    }
    return;
  }
  if (bzf->lastErr != 4) {
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -1;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -1;
    }
    return;
  }
  if ((unsigned long )unused == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )nUnused == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
      *bzerror = -2;
    }
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
      bzf->lastErr = -2;
    }
    return;
  }
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
    *bzerror = 0;
  }
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
    bzf->lastErr = 0;
  }
  *nUnused = (int )bzf->strm.avail_in;
  *unused = (void *)bzf->strm.next_in;
  return;
}
}
int BZ2_bzBuffToBuffCompress(char *dest , unsigned int *destLen , char *source , unsigned int sourceLen ,
                             int blockSize100k___0 , int verbosity___0 , int workFactor___0 ) 
{ 
  bz_stream strm ;
  int ret ;

  {
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    return (-2);
  } else
  if ((unsigned long )destLen == (unsigned long )((void *)0)) {
    return (-2);
  } else
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    return (-2);
  } else
  if (blockSize100k___0 < 1) {
    return (-2);
  } else
  if (blockSize100k___0 > 9) {
    return (-2);
  } else
  if (verbosity___0 < 0) {
    return (-2);
  } else
  if (verbosity___0 > 4) {
    return (-2);
  } else
  if (workFactor___0 < 0) {
    return (-2);
  } else
  if (workFactor___0 > 250) {
    return (-2);
  }
  if (workFactor___0 == 0) {
    workFactor___0 = 30;
  }
  strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
  strm.bzfree = (void (*)(void * , void * ))((void *)0);
  strm.opaque = (void *)0;
  ret = BZ2_bzCompressInit(& strm, blockSize100k___0, verbosity___0, workFactor___0);
  if (ret != 0) {
    return (ret);
  }
  strm.next_in = source;
  strm.next_out = dest;
  strm.avail_in = sourceLen;
  strm.avail_out = *destLen;
  ret = BZ2_bzCompress(& strm, 2);
  if (ret == 3) {
    goto output_overflow;
  }
  if (ret != 4) {
    goto errhandler;
  }
  *destLen -= strm.avail_out;
  BZ2_bzCompressEnd(& strm);
  return (0);
  output_overflow: 
  BZ2_bzCompressEnd(& strm);
  return (-8);
  errhandler: 
  BZ2_bzCompressEnd(& strm);
  return (ret);
}
}
int BZ2_bzBuffToBuffDecompress(char *dest , unsigned int *destLen , char *source ,
                               unsigned int sourceLen , int small , int verbosity___0 ) 
{ 
  bz_stream strm ;
  int ret ;

  {
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    return (-2);
  } else
  if ((unsigned long )destLen == (unsigned long )((void *)0)) {
    return (-2);
  } else
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    return (-2);
  } else
  if (small != 0) {
    if (small != 1) {
      return (-2);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (verbosity___0 < 0) {
    return (-2);
  } else
  if (verbosity___0 > 4) {
    return (-2);
  }
  strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
  strm.bzfree = (void (*)(void * , void * ))((void *)0);
  strm.opaque = (void *)0;
  ret = BZ2_bzDecompressInit(& strm, verbosity___0, small);
  if (ret != 0) {
    return (ret);
  }
  strm.next_in = source;
  strm.next_out = dest;
  strm.avail_in = sourceLen;
  strm.avail_out = *destLen;
  ret = BZ2_bzDecompress(& strm);
  if (ret == 0) {
    goto output_overflow_or_eof;
  }
  if (ret != 4) {
    goto errhandler;
  }
  *destLen -= strm.avail_out;
  BZ2_bzDecompressEnd(& strm);
  return (0);
  output_overflow_or_eof: 
  if (strm.avail_out > 0U) {
    BZ2_bzDecompressEnd(& strm);
    return (-7);
  } else {
    BZ2_bzDecompressEnd(& strm);
    return (-8);
  }
  errhandler: 
  BZ2_bzDecompressEnd(& strm);
  return (ret);
}
}
char const   *BZ2_bzlibVersion(void) 
{ 


  {
  return ("1.0.3, 15-Feb-2005");
}
}
static BZFILE *bzopen_or_bzdopen(char const   *path , int fd , char const   *mode ,
                                 int open_mode ) 
{ 
  int bzerr ;
  char unused[5000] ;
  int blockSize100k___0 ;
  int writing ;
  char mode2[10] ;
  unsigned int tmp ;
  int fp ;
  BZFILE *bzfp ;
  int verbosity___0 ;
  int workFactor___0 ;
  int smallMode___0 ;
  int nUnused ;
  int tmp___0 ;
  char const   *tmp___1 ;
  unsigned long tmp___2 ;
  char const   *tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  blockSize100k___0 = 9;
  writing = 0;
  mode2[0] = (char )'\000';
  tmp = 1U;
  while (! (tmp >= 10U)) {
    mode2[tmp] = (char)0;
    tmp ++;
  }
  fp = 0;
  bzfp = (void *)0;
  verbosity___0 = 0;
  workFactor___0 = 30;
  smallMode___0 = 0;
  nUnused = 0;
  if ((unsigned long )mode == (unsigned long )((void *)0)) {
    return ((void *)0);
  }
  while (*mode) {
    switch ((int const   )*mode) {
    case 114: 
    writing = 0;
    break;
    case 119: 
    writing = 1;
    break;
    case 115: 
    smallMode___0 = 1;
    break;
    default: 
    tmp___0 = isdigit((int )*mode);
    if (tmp___0) {
      blockSize100k___0 = (int )((int const   )*mode - 48);
    }
    }
    mode ++;
  }
  tmp___4 = __builtin_object_size((void *)(mode2), 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___2 = __builtin_object_size((void *)(mode2), 1);
    if (writing) {
      tmp___3 = "w";
    } else {
      tmp___3 = "r";
    }
    __builtin___strcat_chk(mode2, tmp___3, tmp___2);
  } else {
    if (writing) {
      tmp___1 = "w";
    } else {
      tmp___1 = "r";
    }
    __inline_strcat_chk(mode2, tmp___1);
  }
  tmp___6 = __builtin_object_size((void *)(mode2), 0);
  if (tmp___6 != 0xffffffffffffffffUL) {
    tmp___5 = __builtin_object_size((void *)(mode2), 1);
    __builtin___strcat_chk(mode2, "b", tmp___5);
  } else {
    __inline_strcat_chk(mode2, "b");
  }
  if (open_mode == 0) {
    if ((unsigned long )path == (unsigned long )((void *)0)) {
      goto _L;
    } else {
      tmp___7 = strcmp(path, "");
      if (tmp___7 == 0) {
        _L: /* CIL Label */ 
        if (writing) {
          fp = 1;
        } else {
          fp = 0;
        }
      } else {
        fp = 0;
      }
    }
  } else {
    fp = (int )((void *)0);
  }
  if (fp == (int )((void *)0)) {
    return ((void *)0);
  }
  if (writing) {
    if (blockSize100k___0 < 1) {
      blockSize100k___0 = 1;
    }
    if (blockSize100k___0 > 9) {
      blockSize100k___0 = 9;
    }
    bzfp = BZ2_bzWriteOpen(& bzerr, fp, blockSize100k___0, verbosity___0, workFactor___0);
  } else {
    bzfp = BZ2_bzReadOpen(& bzerr, fp, verbosity___0, smallMode___0, (void *)(unused),
                          nUnused);
  }
  if ((unsigned long )bzfp == (unsigned long )((void *)0)) {
    if (fp != 0) {
      if (fp != 1) {
        tmp___8 = 1;
      } else {
        tmp___8 = 0;
      }
    } else {
      tmp___8 = 0;
    }
    return ((void *)0);
  }
  return (bzfp);
}
}
BZFILE *BZ2_bzopen(char const   *path , char const   *mode ) 
{ 
  BZFILE *tmp ;

  {
  tmp = bzopen_or_bzdopen(path, -1, mode, 0);
  return (tmp);
}
}
BZFILE *BZ2_bzdopen(int fd , char const   *mode ) 
{ 
  BZFILE *tmp ;

  {
  tmp = bzopen_or_bzdopen((char const   *)((void *)0), fd, mode, 1);
  return (tmp);
}
}
int BZ2_bzread(BZFILE *b , void *buf , int len ) 
{ 
  int bzerr ;
  int nread ;

  {
  if (((bzFile *)b)->lastErr == 4) {
    return (0);
  }
  nread = BZ2_bzRead(& bzerr, b, buf, len);
  if (bzerr == 0) {
    return (nread);
  } else
  if (bzerr == 4) {
    return (nread);
  } else {
    return (-1);
  }
}
}
int BZ2_bzwrite(BZFILE *b , void *buf , int len ) 
{ 
  int bzerr ;

  {
  BZ2_bzWrite(& bzerr, b, buf, len);
  if (bzerr == 0) {
    return (len);
  } else {
    return (-1);
  }
}
}
int BZ2_bzflush(BZFILE *b ) 
{ 


  {
  return (0);
}
}
void BZ2_bzclose(BZFILE *b ) 
{ 
  int bzerr ;
  int fp ;
  int tmp ;

  {
  fp = ((bzFile *)b)->handle;
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    return;
  }
  if (((bzFile *)b)->writing) {
    BZ2_bzWriteClose(& bzerr, b, 0, (unsigned int *)((void *)0), (unsigned int *)((void *)0));
    if (bzerr != 0) {
      BZ2_bzWriteClose((int *)((void *)0), b, 1, (unsigned int *)((void *)0), (unsigned int *)((void *)0));
    }
  } else {
    BZ2_bzReadClose(& bzerr, b);
  }
  if (fp != 0) {
    if (fp != 1) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return;
}
}
static char *bzerrorstrings[16]  = 
  {      (char *)"OK",      (char *)"SEQUENCE_ERROR",      (char *)"PARAM_ERROR",      (char *)"MEM_ERROR", 
        (char *)"DATA_ERROR",      (char *)"DATA_ERROR_MAGIC",      (char *)"IO_ERROR",      (char *)"UNEXPECTED_EOF", 
        (char *)"OUTBUFF_FULL",      (char *)"CONFIG_ERROR",      (char *)"???",      (char *)"???", 
        (char *)"???",      (char *)"???",      (char *)"???",      (char *)"???"};
char const   *BZ2_bzerror(BZFILE *b , int *errnum ) 
{ 
  int err ;

  {
  err = ((bzFile *)b)->lastErr;
  if (err > 0) {
    err = 0;
  }
  *errnum = err;
  return ((char const   *)bzerrorstrings[err * -1]);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-vQoEchen.i","-O3")
void BZ2_bsInitWrite(EState *s ) ;
void BZ2_hbAssignCodes(Int32 *code , UChar *length , Int32 minLen , Int32 maxLen ,
                       Int32 alphaSize ) ;
void BZ2_hbMakeCodeLengths(UChar *len , Int32 *freq , Int32 alphaSize , Int32 maxLen ) ;
void BZ2_bsInitWrite(EState *s ) 
{ 


  {
  s->bsLive = 0;
  s->bsBuff = (UInt32 )0;
  return;
}
}
static void bsFinishWrite(EState *s ) 
{ 


  {
  while (s->bsLive > 0) {
    *(s->zbits + s->numZ) = (UChar )(s->bsBuff >> 24);
    (s->numZ) ++;
    s->bsBuff <<= 8;
    s->bsLive -= 8;
  }
  return;
}
}
static void bsW(EState *s , Int32 n , UInt32 v ) 
{ 


  {
  while (s->bsLive >= 8) {
    *(s->zbits + s->numZ) = (UChar )(s->bsBuff >> 24);
    (s->numZ) ++;
    s->bsBuff <<= 8;
    s->bsLive -= 8;
  }
  s->bsBuff |= v << ((32 - s->bsLive) - n);
  s->bsLive += n;
  return;
}
}
static void bsPutUInt32(EState *s , UInt32 u ) 
{ 


  {
  bsW(s, 8, (UInt32 )((long )(u >> 24) & 255L));
  bsW(s, 8, (UInt32 )((long )(u >> 16) & 255L));
  bsW(s, 8, (UInt32 )((long )(u >> 8) & 255L));
  bsW(s, 8, (UInt32 )((long )u & 255L));
  return;
}
}
static void bsPutUChar(EState *s , UChar c ) 
{ 


  {
  bsW(s, 8, (UInt32 )c);
  return;
}
}
static void makeMaps_e(EState *s ) 
{ 
  Int32 i ;

  {
  s->nInUse = 0;
  i = 0;
  while (i < 256) {
    if (s->inUse[i]) {
      s->unseqToSeq[i] = (UChar )s->nInUse;
      (s->nInUse) ++;
    }
    i ++;
  }
  return;
}
}
static void generateMTFValues(EState *s ) 
{ 
  UChar yy[256] ;
  Int32 i ;
  Int32 j ;
  Int32 zPend ;
  Int32 wr ;
  Int32 EOB ;
  UInt32 *ptr ;
  UChar *block ;
  UInt16 *mtfv ;
  UChar ll_i ;
  register UChar rtmp ;
  register UChar *ryy_j ;
  register UChar rll_i ;
  register UChar rtmp2 ;

  {
  ptr = s->ptr;
  block = s->block;
  mtfv = s->mtfv;
  makeMaps_e(s);
  EOB = s->nInUse + 1;
  i = 0;
  while (i <= EOB) {
    s->mtfFreq[i] = 0;
    i ++;
  }
  wr = 0;
  zPend = 0;
  i = 0;
  while (i < s->nInUse) {
    yy[i] = (UChar )i;
    i ++;
  }
  i = 0;
  while (i < s->nblock) {
    j = (Int32 )(*(ptr + i) - 1U);
    if (j < 0) {
      j += s->nblock;
    }
    ll_i = s->unseqToSeq[*(block + j)];
    if ((int )yy[0] == (int )ll_i) {
      zPend ++;
    } else {
      if (zPend > 0) {
        zPend --;
        while (1) {
          if (zPend & 1) {
            *(mtfv + wr) = (UInt16 )1;
            wr ++;
            (s->mtfFreq[1]) ++;
          } else {
            *(mtfv + wr) = (UInt16 )0;
            wr ++;
            (s->mtfFreq[0]) ++;
          }
          if (zPend < 2) {
            break;
          }
          zPend = (zPend - 2) / 2;
        }
        zPend = 0;
      }
      rtmp = yy[1];
      yy[1] = yy[0];
      ryy_j = & yy[1];
      rll_i = ll_i;
      while ((int )rll_i != (int )rtmp) {
        ryy_j ++;
        rtmp2 = rtmp;
        rtmp = *ryy_j;
        *ryy_j = rtmp2;
      }
      yy[0] = rtmp;
      j = (Int32 )(ryy_j - & yy[0]);
      *(mtfv + wr) = (UInt16 )(j + 1);
      wr ++;
      (s->mtfFreq[j + 1]) ++;
    }
    i ++;
  }
  if (zPend > 0) {
    zPend --;
    while (1) {
      if (zPend & 1) {
        *(mtfv + wr) = (UInt16 )1;
        wr ++;
        (s->mtfFreq[1]) ++;
      } else {
        *(mtfv + wr) = (UInt16 )0;
        wr ++;
        (s->mtfFreq[0]) ++;
      }
      if (zPend < 2) {
        break;
      }
      zPend = (zPend - 2) / 2;
    }
    zPend = 0;
  }
  *(mtfv + wr) = (UInt16 )EOB;
  wr ++;
  (s->mtfFreq[EOB]) ++;
  s->nMTF = wr;
  return;
}
}
static void sendMTFValues(EState *s ) 
{ 
  Int32 v ;
  Int32 t ;
  Int32 i ;
  Int32 j ;
  Int32 gs ;
  Int32 ge ;
  Int32 totc ;
  Int32 bt ;
  Int32 bc ;
  Int32 iter ;
  Int32 nSelectors ;
  Int32 alphaSize ;
  Int32 minLen ;
  Int32 maxLen ;
  Int32 selCtr ;
  Int32 nGroups ;
  Int32 nBytes ;
  UInt16 cost[6] ;
  Int32 fave[6] ;
  UInt16 *mtfv ;
  Int32 nPart ;
  Int32 remF ;
  Int32 tFreq ;
  Int32 aFreq ;
  register UInt32 cost01 ;
  register UInt32 cost23 ;
  register UInt32 cost45 ;
  register UInt16 icv ;
  UInt16 icv___0 ;
  UChar pos[6] ;
  UChar ll_i ;
  UChar tmp2 ;
  UChar tmp ;
  Bool inUse16[16] ;
  Int32 curr ;
  UInt16 mtfv_i ;
  UChar *s_len_sel_selCtr ;
  Int32 *s_code_sel_selCtr ;

  {
  mtfv = s->mtfv;
  if (s->verbosity >= 3) {
    fprintf(__stderrp, "      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\n",
            s->nblock, s->nMTF, s->nInUse);
  }
  alphaSize = s->nInUse + 2;
  t = 0;
  while (t < 6) {
    v = 0;
    while (v < alphaSize) {
      s->len[t][v] = (UChar )15;
      v ++;
    }
    t ++;
  }
  if (! (s->nMTF > 0)) {
    BZ2_bz__AssertH__fail(3001);
  }
  if (s->nMTF < 200) {
    nGroups = 2;
  } else
  if (s->nMTF < 600) {
    nGroups = 3;
  } else
  if (s->nMTF < 1200) {
    nGroups = 4;
  } else
  if (s->nMTF < 2400) {
    nGroups = 5;
  } else {
    nGroups = 6;
  }
  nPart = nGroups;
  remF = s->nMTF;
  gs = 0;
  while (nPart > 0) {
    tFreq = remF / nPart;
    ge = gs - 1;
    aFreq = 0;
    while (1) {
      if (aFreq < tFreq) {
        if (! (ge < alphaSize - 1)) {
          break;
        }
      } else {
        break;
      }
      ge ++;
      aFreq += s->mtfFreq[ge];
    }
    if (ge > gs) {
      if (nPart != nGroups) {
        if (nPart != 1) {
          if ((nGroups - nPart) % 2 == 1) {
            aFreq -= s->mtfFreq[ge];
            ge --;
          }
        }
      }
    }
    if (s->verbosity >= 3) {
      fprintf(__stderrp, "      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\n",
              nPart, gs, ge, aFreq, (100.0 * (double )((float )aFreq)) / (double )((float )s->nMTF));
    }
    v = 0;
    while (v < alphaSize) {
      if (v >= gs) {
        if (v <= ge) {
          s->len[nPart - 1][v] = (UChar )0;
        } else {
          s->len[nPart - 1][v] = (UChar )15;
        }
      } else {
        s->len[nPart - 1][v] = (UChar )15;
      }
      v ++;
    }
    nPart --;
    gs = ge + 1;
    remF -= aFreq;
  }
  iter = 0;
  while (iter < 4) {
    t = 0;
    while (t < nGroups) {
      fave[t] = 0;
      t ++;
    }
    t = 0;
    while (t < nGroups) {
      v = 0;
      while (v < alphaSize) {
        s->rfreq[t][v] = 0;
        v ++;
      }
      t ++;
    }
    if (nGroups == 6) {
      v = 0;
      while (v < alphaSize) {
        s->len_pack[v][0] = (UInt32 )(((int )s->len[1][v] << 16) | (int )s->len[0][v]);
        s->len_pack[v][1] = (UInt32 )(((int )s->len[3][v] << 16) | (int )s->len[2][v]);
        s->len_pack[v][2] = (UInt32 )(((int )s->len[5][v] << 16) | (int )s->len[4][v]);
        v ++;
      }
    }
    nSelectors = 0;
    totc = 0;
    gs = 0;
    while (! (gs >= s->nMTF)) {
      ge = (gs + 50) - 1;
      if (ge >= s->nMTF) {
        ge = s->nMTF - 1;
      }
      t = 0;
      while (t < nGroups) {
        cost[t] = (UInt16 )0;
        t ++;
      }
      if (nGroups == 6) {
        if (50 == (ge - gs) + 1) {
          cost45 = (UInt32 )0;
          cost23 = cost45;
          cost01 = cost23;
          icv = *(mtfv + gs);
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 1));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 2));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 3));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 4));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 5));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 6));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 7));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 8));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 9));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 10));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 11));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 12));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 13));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 14));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 15));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 16));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 17));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 18));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 19));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 20));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 21));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 22));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 23));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 24));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 25));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 26));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 27));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 28));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 29));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 30));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 31));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 32));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 33));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 34));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 35));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 36));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 37));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 38));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 39));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 40));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 41));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 42));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 43));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 44));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 45));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 46));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 47));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 48));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          icv = *(mtfv + (gs + 49));
          cost01 += s->len_pack[icv][0];
          cost23 += s->len_pack[icv][1];
          cost45 += s->len_pack[icv][2];
          cost[0] = (UInt16 )(cost01 & 65535U);
          cost[1] = (UInt16 )(cost01 >> 16);
          cost[2] = (UInt16 )(cost23 & 65535U);
          cost[3] = (UInt16 )(cost23 >> 16);
          cost[4] = (UInt16 )(cost45 & 65535U);
          cost[5] = (UInt16 )(cost45 >> 16);
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        i = gs;
        while (i <= ge) {
          icv___0 = *(mtfv + i);
          t = 0;
          while (t < nGroups) {
            cost[t] = (UInt16 )((int )cost[t] + (int )s->len[t][icv___0]);
            t ++;
          }
          i ++;
        }
      }
      bc = 999999999;
      bt = -1;
      t = 0;
      while (t < nGroups) {
        if ((int )cost[t] < bc) {
          bc = (Int32 )cost[t];
          bt = t;
        }
        t ++;
      }
      totc += bc;
      (fave[bt]) ++;
      s->selector[nSelectors] = (UChar )bt;
      nSelectors ++;
      if (nGroups == 6) {
        if (50 == (ge - gs) + 1) {
          (s->rfreq[bt][*(mtfv + gs)]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 1))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 2))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 3))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 4))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 5))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 6))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 7))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 8))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 9))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 10))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 11))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 12))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 13))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 14))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 15))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 16))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 17))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 18))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 19))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 20))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 21))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 22))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 23))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 24))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 25))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 26))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 27))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 28))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 29))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 30))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 31))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 32))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 33))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 34))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 35))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 36))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 37))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 38))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 39))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 40))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 41))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 42))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 43))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 44))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 45))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 46))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 47))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 48))]) ++;
          (s->rfreq[bt][*(mtfv + (gs + 49))]) ++;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        i = gs;
        while (i <= ge) {
          (s->rfreq[bt][*(mtfv + i)]) ++;
          i ++;
        }
      }
      gs = ge + 1;
    }
    if (s->verbosity >= 3) {
      fprintf(__stderrp, "      pass %d: size is %d, grp uses are ", iter + 1, totc / 8);
      t = 0;
      while (t < nGroups) {
        fprintf(__stderrp, "%d ", fave[t]);
        t ++;
      }
      fprintf(__stderrp, "\n");
    }
    t = 0;
    while (t < nGroups) {
      BZ2_hbMakeCodeLengths(& s->len[t][0], & s->rfreq[t][0], alphaSize, 17);
      t ++;
    }
    iter ++;
  }
  if (! (nGroups < 8)) {
    BZ2_bz__AssertH__fail(3002);
  }
  if (nSelectors < 32768) {
    if (! (nSelectors <= 18002)) {
      BZ2_bz__AssertH__fail(3003);
    }
  } else {
    BZ2_bz__AssertH__fail(3003);
  }
  i = 0;
  while (i < nGroups) {
    pos[i] = (UChar )i;
    i ++;
  }
  i = 0;
  while (i < nSelectors) {
    ll_i = s->selector[i];
    j = 0;
    tmp = pos[j];
    while ((int )ll_i != (int )tmp) {
      j ++;
      tmp2 = tmp;
      tmp = pos[j];
      pos[j] = tmp2;
    }
    pos[0] = tmp;
    s->selectorMtf[i] = (UChar )j;
    i ++;
  }
  t = 0;
  while (t < nGroups) {
    minLen = 32;
    maxLen = 0;
    i = 0;
    while (i < alphaSize) {
      if ((int )s->len[t][i] > maxLen) {
        maxLen = (Int32 )s->len[t][i];
      }
      if ((int )s->len[t][i] < minLen) {
        minLen = (Int32 )s->len[t][i];
      }
      i ++;
    }
    if (! (! (maxLen > 17))) {
      BZ2_bz__AssertH__fail(3004);
    }
    if (! (! (minLen < 1))) {
      BZ2_bz__AssertH__fail(3005);
    }
    BZ2_hbAssignCodes(& s->code[t][0], & s->len[t][0], minLen, maxLen, alphaSize);
    t ++;
  }
  i = 0;
  while (i < 16) {
    inUse16[i] = (Bool )0;
    j = 0;
    while (j < 16) {
      if (s->inUse[i * 16 + j]) {
        inUse16[i] = (Bool )1;
      }
      j ++;
    }
    i ++;
  }
  nBytes = s->numZ;
  i = 0;
  while (i < 16) {
    if (inUse16[i]) {
      bsW(s, 1, (UInt32 )1);
    } else {
      bsW(s, 1, (UInt32 )0);
    }
    i ++;
  }
  i = 0;
  while (i < 16) {
    if (inUse16[i]) {
      j = 0;
      while (j < 16) {
        if (s->inUse[i * 16 + j]) {
          bsW(s, 1, (UInt32 )1);
        } else {
          bsW(s, 1, (UInt32 )0);
        }
        j ++;
      }
    }
    i ++;
  }
  if (s->verbosity >= 3) {
    fprintf(__stderrp, "      bytes: mapping %d, ", s->numZ - nBytes);
  }
  nBytes = s->numZ;
  bsW(s, 3, (UInt32 )nGroups);
  bsW(s, 15, (UInt32 )nSelectors);
  i = 0;
  while (i < nSelectors) {
    j = 0;
    while (j < (Int32 )s->selectorMtf[i]) {
      bsW(s, 1, (UInt32 )1);
      j ++;
    }
    bsW(s, 1, (UInt32 )0);
    i ++;
  }
  if (s->verbosity >= 3) {
    fprintf(__stderrp, "selectors %d, ", s->numZ - nBytes);
  }
  nBytes = s->numZ;
  t = 0;
  while (t < nGroups) {
    curr = (Int32 )s->len[t][0];
    bsW(s, 5, (UInt32 )curr);
    i = 0;
    while (i < alphaSize) {
      while (curr < (Int32 )s->len[t][i]) {
        bsW(s, 2, (UInt32 )2);
        curr ++;
      }
      while (curr > (Int32 )s->len[t][i]) {
        bsW(s, 2, (UInt32 )3);
        curr --;
      }
      bsW(s, 1, (UInt32 )0);
      i ++;
    }
    t ++;
  }
  if (s->verbosity >= 3) {
    fprintf(__stderrp, "code lengths %d, ", s->numZ - nBytes);
  }
  nBytes = s->numZ;
  selCtr = 0;
  gs = 0;
  while (! (gs >= s->nMTF)) {
    ge = (gs + 50) - 1;
    if (ge >= s->nMTF) {
      ge = s->nMTF - 1;
    }
    if (! ((int )s->selector[selCtr] < nGroups)) {
      BZ2_bz__AssertH__fail(3006);
    }
    if (nGroups == 6) {
      if (50 == (ge - gs) + 1) {
        s_len_sel_selCtr = & s->len[s->selector[selCtr]][0];
        s_code_sel_selCtr = & s->code[s->selector[selCtr]][0];
        mtfv_i = *(mtfv + gs);
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 1));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 2));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 3));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 4));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 5));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 6));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 7));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 8));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 9));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 10));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 11));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 12));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 13));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 14));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 15));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 16));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 17));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 18));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 19));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 20));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 21));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 22));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 23));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 24));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 25));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 26));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 27));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 28));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 29));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 30));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 31));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 32));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 33));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 34));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 35));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 36));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 37));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 38));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 39));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 40));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 41));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 42));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 43));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 44));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 45));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 46));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 47));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 48));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        mtfv_i = *(mtfv + (gs + 49));
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      i = gs;
      while (i <= ge) {
        bsW(s, (Int32 )s->len[s->selector[selCtr]][*(mtfv + i)], (UInt32 )s->code[s->selector[selCtr]][*(mtfv + i)]);
        i ++;
      }
    }
    gs = ge + 1;
    selCtr ++;
  }
  if (! (selCtr == nSelectors)) {
    BZ2_bz__AssertH__fail(3007);
  }
  if (s->verbosity >= 3) {
    fprintf(__stderrp, "codes %d\n", s->numZ - nBytes);
  }
  return;
}
}
void BZ2_compressBlock(EState *s , Bool is_last_block ) 
{ 


  {
  if (s->nblock > 0) {
    s->blockCRC = ~ s->blockCRC;
    s->combinedCRC = (s->combinedCRC << 1) | (s->combinedCRC >> 31);
    s->combinedCRC ^= s->blockCRC;
    if (s->blockNo > 1) {
      s->numZ = 0;
    }
    if (s->verbosity >= 2) {
      fprintf(__stderrp, "    block %d: crc = 0x%08x, combined CRC = 0x%08x, size = %d\n",
              s->blockNo, s->blockCRC, s->combinedCRC, s->nblock);
    }
    BZ2_blockSort(s);
  }
  s->zbits = (UChar *)s->arr2 + s->nblock;
  if (s->blockNo == 1) {
    BZ2_bsInitWrite(s);
    bsPutUChar(s, (UChar )66);
    bsPutUChar(s, (UChar )90);
    bsPutUChar(s, (UChar )104);
    bsPutUChar(s, (UChar )(48 + s->blockSize100k));
  }
  if (s->nblock > 0) {
    bsPutUChar(s, (UChar )49);
    bsPutUChar(s, (UChar )65);
    bsPutUChar(s, (UChar )89);
    bsPutUChar(s, (UChar )38);
    bsPutUChar(s, (UChar )83);
    bsPutUChar(s, (UChar )89);
    bsPutUInt32(s, s->blockCRC);
    bsW(s, 1, (UInt32 )0);
    bsW(s, 24, (UInt32 )s->origPtr);
    generateMTFValues(s);
    sendMTFValues(s);
  }
  if (is_last_block) {
    bsPutUChar(s, (UChar )23);
    bsPutUChar(s, (UChar )114);
    bsPutUChar(s, (UChar )69);
    bsPutUChar(s, (UChar )56);
    bsPutUChar(s, (UChar )80);
    bsPutUChar(s, (UChar )144);
    bsPutUInt32(s, s->combinedCRC);
    if (s->verbosity >= 2) {
      fprintf(__stderrp, "    final combined CRC = 0x%08x\n   ", s->combinedCRC);
    }
    bsFinishWrite(s);
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-q1gBtCwY.i","-O3")
UInt32 BZ2_crc32Table[256]  = 
  {      (UInt32 )0L,      (UInt32 )79764919L,      (UInt32 )159529838L,      (UInt32 )222504665L, 
        (UInt32 )319059676L,      (UInt32 )398814059L,      (UInt32 )445009330L,      (UInt32 )507990021L, 
        (UInt32 )638119352L,      (UInt32 )583659535L,      (UInt32 )797628118L,      (UInt32 )726387553L, 
        (UInt32 )890018660L,      (UInt32 )835552979L,      (UInt32 )1015980042L,      (UInt32 )944750013L, 
        (UInt32 )1276238704L,      (UInt32 )1221641927L,      (UInt32 )1167319070L,      (UInt32 )1095957929L, 
        (UInt32 )1595256236L,      (UInt32 )1540665371L,      (UInt32 )1452775106L,      (UInt32 )1381403509L, 
        (UInt32 )1780037320L,      (UInt32 )1859660671L,      (UInt32 )1671105958L,      (UInt32 )1733955601L, 
        (UInt32 )2031960084L,      (UInt32 )2111593891L,      (UInt32 )1889500026L,      (UInt32 )1952343757L, 
        (UInt32 )2552477408L,      (UInt32 )2632100695L,      (UInt32 )2443283854L,      (UInt32 )2506133561L, 
        (UInt32 )2334638140L,      (UInt32 )2414271883L,      (UInt32 )2191915858L,      (UInt32 )2254759653L, 
        (UInt32 )3190512472L,      (UInt32 )3135915759L,      (UInt32 )3081330742L,      (UInt32 )3009969537L, 
        (UInt32 )2905550212L,      (UInt32 )2850959411L,      (UInt32 )2762807018L,      (UInt32 )2691435357L, 
        (UInt32 )3560074640L,      (UInt32 )3505614887L,      (UInt32 )3719321342L,      (UInt32 )3648080713L, 
        (UInt32 )3342211916L,      (UInt32 )3287746299L,      (UInt32 )3467911202L,      (UInt32 )3396681109L, 
        (UInt32 )4063920168L,      (UInt32 )4143685023L,      (UInt32 )4223187782L,      (UInt32 )4286162673L, 
        (UInt32 )3779000052L,      (UInt32 )3858754371L,      (UInt32 )3904687514L,      (UInt32 )3967668269L, 
        (UInt32 )881225847L,      (UInt32 )809987520L,      (UInt32 )1023691545L,      (UInt32 )969234094L, 
        (UInt32 )662832811L,      (UInt32 )591600412L,      (UInt32 )771767749L,      (UInt32 )717299826L, 
        (UInt32 )311336399L,      (UInt32 )374308984L,      (UInt32 )453813921L,      (UInt32 )533576470L, 
        (UInt32 )25881363L,      (UInt32 )88864420L,      (UInt32 )134795389L,      (UInt32 )214552010L, 
        (UInt32 )2023205639L,      (UInt32 )2086057648L,      (UInt32 )1897238633L,      (UInt32 )1976864222L, 
        (UInt32 )1804852699L,      (UInt32 )1867694188L,      (UInt32 )1645340341L,      (UInt32 )1724971778L, 
        (UInt32 )1587496639L,      (UInt32 )1516133128L,      (UInt32 )1461550545L,      (UInt32 )1406951526L, 
        (UInt32 )1302016099L,      (UInt32 )1230646740L,      (UInt32 )1142491917L,      (UInt32 )1087903418L, 
        (UInt32 )2896545431L,      (UInt32 )2825181984L,      (UInt32 )2770861561L,      (UInt32 )2716262478L, 
        (UInt32 )3215044683L,      (UInt32 )3143675388L,      (UInt32 )3055782693L,      (UInt32 )3001194130L, 
        (UInt32 )2326604591L,      (UInt32 )2389456536L,      (UInt32 )2200899649L,      (UInt32 )2280525302L, 
        (UInt32 )2578013683L,      (UInt32 )2640855108L,      (UInt32 )2418763421L,      (UInt32 )2498394922L, 
        (UInt32 )3769900519L,      (UInt32 )3832873040L,      (UInt32 )3912640137L,      (UInt32 )3992402750L, 
        (UInt32 )4088425275L,      (UInt32 )4151408268L,      (UInt32 )4197601365L,      (UInt32 )4277358050L, 
        (UInt32 )3334271071L,      (UInt32 )3263032808L,      (UInt32 )3476998961L,      (UInt32 )3422541446L, 
        (UInt32 )3585640067L,      (UInt32 )3514407732L,      (UInt32 )3694837229L,      (UInt32 )3640369242L, 
        (UInt32 )1762451694L,      (UInt32 )1842216281L,      (UInt32 )1619975040L,      (UInt32 )1682949687L, 
        (UInt32 )2047383090L,      (UInt32 )2127137669L,      (UInt32 )1938468188L,      (UInt32 )2001449195L, 
        (UInt32 )1325665622L,      (UInt32 )1271206113L,      (UInt32 )1183200824L,      (UInt32 )1111960463L, 
        (UInt32 )1543535498L,      (UInt32 )1489069629L,      (UInt32 )1434599652L,      (UInt32 )1363369299L, 
        (UInt32 )622672798L,      (UInt32 )568075817L,      (UInt32 )748617968L,      (UInt32 )677256519L, 
        (UInt32 )907627842L,      (UInt32 )853037301L,      (UInt32 )1067152940L,      (UInt32 )995781531L, 
        (UInt32 )51762726L,      (UInt32 )131386257L,      (UInt32 )177728840L,      (UInt32 )240578815L, 
        (UInt32 )269590778L,      (UInt32 )349224269L,      (UInt32 )429104020L,      (UInt32 )491947555L, 
        (UInt32 )4046411278L,      (UInt32 )4126034873L,      (UInt32 )4172115296L,      (UInt32 )4234965207L, 
        (UInt32 )3794477266L,      (UInt32 )3874110821L,      (UInt32 )3953728444L,      (UInt32 )4016571915L, 
        (UInt32 )3609705398L,      (UInt32 )3555108353L,      (UInt32 )3735388376L,      (UInt32 )3664026991L, 
        (UInt32 )3290680682L,      (UInt32 )3236090077L,      (UInt32 )3449943556L,      (UInt32 )3378572211L, 
        (UInt32 )3174993278L,      (UInt32 )3120533705L,      (UInt32 )3032266256L,      (UInt32 )2961025959L, 
        (UInt32 )2923101090L,      (UInt32 )2868635157L,      (UInt32 )2813903052L,      (UInt32 )2742672763L, 
        (UInt32 )2604032198L,      (UInt32 )2683796849L,      (UInt32 )2461293480L,      (UInt32 )2524268063L, 
        (UInt32 )2284983834L,      (UInt32 )2364738477L,      (UInt32 )2175806836L,      (UInt32 )2238787779L, 
        (UInt32 )1569362073L,      (UInt32 )1498123566L,      (UInt32 )1409854455L,      (UInt32 )1355396672L, 
        (UInt32 )1317987909L,      (UInt32 )1246755826L,      (UInt32 )1192025387L,      (UInt32 )1137557660L, 
        (UInt32 )2072149281L,      (UInt32 )2135122070L,      (UInt32 )1912620623L,      (UInt32 )1992383480L, 
        (UInt32 )1753615357L,      (UInt32 )1816598090L,      (UInt32 )1627664531L,      (UInt32 )1707420964L, 
        (UInt32 )295390185L,      (UInt32 )358241886L,      (UInt32 )404320391L,      (UInt32 )483945776L, 
        (UInt32 )43990325L,      (UInt32 )106832002L,      (UInt32 )186451547L,      (UInt32 )266083308L, 
        (UInt32 )932423249L,      (UInt32 )861060070L,      (UInt32 )1041341759L,      (UInt32 )986742920L, 
        (UInt32 )613929101L,      (UInt32 )542559546L,      (UInt32 )756411363L,      (UInt32 )701822548L, 
        (UInt32 )3316196985L,      (UInt32 )3244833742L,      (UInt32 )3425377559L,      (UInt32 )3370778784L, 
        (UInt32 )3601682597L,      (UInt32 )3530312978L,      (UInt32 )3744426955L,      (UInt32 )3689838204L, 
        (UInt32 )3819031489L,      (UInt32 )3881883254L,      (UInt32 )3928223919L,      (UInt32 )4007849240L, 
        (UInt32 )4037393693L,      (UInt32 )4100235434L,      (UInt32 )4180117107L,      (UInt32 )4259748804L, 
        (UInt32 )2310601993L,      (UInt32 )2373574846L,      (UInt32 )2151335527L,      (UInt32 )2231098320L, 
        (UInt32 )2596047829L,      (UInt32 )2659030626L,      (UInt32 )2470359227L,      (UInt32 )2550115596L, 
        (UInt32 )2947551409L,      (UInt32 )2876312838L,      (UInt32 )2788305887L,      (UInt32 )2733848168L, 
        (UInt32 )3165939309L,      (UInt32 )3094707162L,      (UInt32 )3040238851L,      (UInt32 )2985771188L};
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-22V_VORw.i","-O3")
void BZ2_hbCreateDecodeTables(Int32 *limit , Int32 *base , Int32 *perm , UChar *length ,
                              Int32 minLen , Int32 maxLen , Int32 alphaSize ) ;
static void makeMaps_d(DState *s ) 
{ 
  Int32 i ;

  {
  s->nInUse = 0;
  i = 0;
  while (i < 256) {
    if (s->inUse[i]) {
      s->seqToUnseq[s->nInUse] = (UChar )i;
      (s->nInUse) ++;
    }
    i ++;
  }
  return;
}
}
Int32 BZ2_decompress(DState *s ) 
{ 
  UChar uc ;
  Int32 retVal ;
  Int32 minLen ;
  Int32 maxLen ;
  bz_stream *strm ;
  Int32 i ;
  Int32 j ;
  Int32 t ;
  Int32 alphaSize ;
  Int32 nGroups ;
  Int32 nSelectors ;
  Int32 EOB ;
  Int32 groupNo ;
  Int32 groupPos ;
  Int32 nextSym ;
  Int32 nblockMAX ;
  Int32 nblock ;
  Int32 es ;
  Int32 N ;
  Int32 curr ;
  Int32 zt ;
  Int32 zn ;
  Int32 zvec ;
  Int32 zj ;
  Int32 gSel ;
  Int32 gMinlen ;
  Int32 *gLimit ;
  Int32 *gBase ;
  Int32 *gPerm ;
  UInt32 v ;
  UInt32 v___0 ;
  UInt32 v___1 ;
  UInt32 v___2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  UInt32 v___3 ;
  UInt32 v___4 ;
  UInt32 v___5 ;
  UInt32 v___6 ;
  UInt32 v___7 ;
  UInt32 v___8 ;
  UInt32 v___9 ;
  UInt32 v___10 ;
  UInt32 v___11 ;
  UInt32 v___12 ;
  UInt32 v___13 ;
  UInt32 v___14 ;
  UInt32 v___15 ;
  UInt32 v___16 ;
  UInt32 v___17 ;
  UInt32 v___18 ;
  UInt32 v___19 ;
  UInt32 v___20 ;
  UInt32 v___21 ;
  UChar pos[6] ;
  UChar tmp___2 ;
  UChar v___22 ;
  UInt32 v___23 ;
  UInt32 v___24 ;
  UInt32 v___25 ;
  Int32 ii ;
  Int32 jj ;
  Int32 kk ;
  UInt32 v___26 ;
  UInt32 v___27 ;
  UInt32 v___28 ;
  UInt32 v___29 ;
  Int32 ii___0 ;
  Int32 jj___0 ;
  Int32 kk___0 ;
  Int32 pp ;
  Int32 lno ;
  Int32 off ;
  UInt32 nn ;
  Int32 z ;
  UInt32 v___30 ;
  UInt32 v___31 ;
  Int32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  UInt32 v___32 ;
  UInt32 v___33 ;
  UInt32 v___34 ;
  UInt32 v___35 ;
  UInt32 v___36 ;
  UInt32 v___37 ;
  UInt32 v___38 ;
  UInt32 v___39 ;
  UInt32 v___40 ;

  {
  strm = s->strm;
  if (s->state == 10) {
    s->save_i = 0;
    s->save_j = 0;
    s->save_t = 0;
    s->save_alphaSize = 0;
    s->save_nGroups = 0;
    s->save_nSelectors = 0;
    s->save_EOB = 0;
    s->save_groupNo = 0;
    s->save_groupPos = 0;
    s->save_nextSym = 0;
    s->save_nblockMAX = 0;
    s->save_nblock = 0;
    s->save_es = 0;
    s->save_N = 0;
    s->save_curr = 0;
    s->save_zt = 0;
    s->save_zn = 0;
    s->save_zvec = 0;
    s->save_zj = 0;
    s->save_gSel = 0;
    s->save_gMinlen = 0;
    s->save_gLimit = (Int32 *)((void *)0);
    s->save_gBase = (Int32 *)((void *)0);
    s->save_gPerm = (Int32 *)((void *)0);
  }
  i = s->save_i;
  j = s->save_j;
  t = s->save_t;
  alphaSize = s->save_alphaSize;
  nGroups = s->save_nGroups;
  nSelectors = s->save_nSelectors;
  EOB = s->save_EOB;
  groupNo = s->save_groupNo;
  groupPos = s->save_groupPos;
  nextSym = s->save_nextSym;
  nblockMAX = s->save_nblockMAX;
  nblock = s->save_nblock;
  es = s->save_es;
  N = s->save_N;
  curr = s->save_curr;
  zt = s->save_zt;
  zn = s->save_zn;
  zvec = s->save_zvec;
  zj = s->save_zj;
  gSel = s->save_gSel;
  gMinlen = s->save_gMinlen;
  gLimit = s->save_gLimit;
  gBase = s->save_gBase;
  gPerm = s->save_gPerm;
  retVal = 0;
  switch (s->state) {
  case 10: 
  s->state = 10;
  while (1) {
    if (s->bsLive >= 8) {
      v = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 66) {
    retVal = -5;
    goto save_state_and_return;
  }
  case 11: 
  s->state = 11;
  while (1) {
    if (s->bsLive >= 8) {
      v___0 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___0;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 90) {
    retVal = -5;
    goto save_state_and_return;
  }
  case 12: 
  s->state = 12;
  while (1) {
    if (s->bsLive >= 8) {
      v___1 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___1;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 104) {
    retVal = -5;
    goto save_state_and_return;
  }
  case 13: 
  s->state = 13;
  while (1) {
    if (s->bsLive >= 8) {
      v___2 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      s->blockSize100k = (Int32 )v___2;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if (s->blockSize100k < 49) {
    retVal = -5;
    goto save_state_and_return;
  } else
  if (s->blockSize100k > 57) {
    retVal = -5;
    goto save_state_and_return;
  }
  s->blockSize100k -= 48;
  if (s->smallDecompress) {
    tmp = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )(s->blockSize100k * 100000) * sizeof(UInt16 )),
                             1);
    s->ll16 = (UInt16 *)tmp;
    tmp___0 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar )),
                                 1);
    s->ll4 = (UChar *)tmp___0;
    if ((unsigned long )s->ll16 == (unsigned long )((void *)0)) {
      retVal = -3;
      goto save_state_and_return;
    } else
    if ((unsigned long )s->ll4 == (unsigned long )((void *)0)) {
      retVal = -3;
      goto save_state_and_return;
    }
  } else {
    tmp___1 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )(s->blockSize100k * 100000) * sizeof(Int32 )),
                                 1);
    s->tt = (UInt32 *)tmp___1;
    if ((unsigned long )s->tt == (unsigned long )((void *)0)) {
      retVal = -3;
      goto save_state_and_return;
    }
  }
  case 14: 
  s->state = 14;
  while (1) {
    if (s->bsLive >= 8) {
      v___3 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___3;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc == 23) {
    goto endhdr_2;
  }
  if ((int )uc != 49) {
    retVal = -4;
    goto save_state_and_return;
  }
  case 15: 
  s->state = 15;
  while (1) {
    if (s->bsLive >= 8) {
      v___4 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___4;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 65) {
    retVal = -4;
    goto save_state_and_return;
  }
  case 16: 
  s->state = 16;
  while (1) {
    if (s->bsLive >= 8) {
      v___5 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___5;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 89) {
    retVal = -4;
    goto save_state_and_return;
  }
  case 17: 
  s->state = 17;
  while (1) {
    if (s->bsLive >= 8) {
      v___6 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___6;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 38) {
    retVal = -4;
    goto save_state_and_return;
  }
  case 18: 
  s->state = 18;
  while (1) {
    if (s->bsLive >= 8) {
      v___7 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___7;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 83) {
    retVal = -4;
    goto save_state_and_return;
  }
  case 19: 
  s->state = 19;
  while (1) {
    if (s->bsLive >= 8) {
      v___8 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___8;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 89) {
    retVal = -4;
    goto save_state_and_return;
  }
  (s->currBlockNo) ++;
  if (s->verbosity >= 2) {
    fprintf(__stderrp, "\n    [%d: huff+mtf ", s->currBlockNo);
  }
  s->storedBlockCRC = (UInt32 )0;
  case 20: 
  s->state = 20;
  while (1) {
    if (s->bsLive >= 8) {
      v___9 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___9;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 21: 
  s->state = 21;
  while (1) {
    if (s->bsLive >= 8) {
      v___10 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___10;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 22: 
  s->state = 22;
  while (1) {
    if (s->bsLive >= 8) {
      v___11 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___11;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 23: 
  s->state = 23;
  while (1) {
    if (s->bsLive >= 8) {
      v___12 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___12;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 24: 
  s->state = 24;
  while (1) {
    if (s->bsLive >= 1) {
      v___13 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
      (s->bsLive) --;
      s->blockRandomised = (Bool )v___13;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->origPtr = 0;
  case 25: 
  s->state = 25;
  while (1) {
    if (s->bsLive >= 8) {
      v___14 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___14;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
  case 26: 
  s->state = 26;
  while (1) {
    if (s->bsLive >= 8) {
      v___15 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___15;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
  case 27: 
  s->state = 27;
  while (1) {
    if (s->bsLive >= 8) {
      v___16 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___16;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
  if (s->origPtr < 0) {
    retVal = -4;
    goto save_state_and_return;
  }
  if (s->origPtr > 10 + 100000 * s->blockSize100k) {
    retVal = -4;
    goto save_state_and_return;
  }
  i = 0;
  while (i < 16) {
    case 28: 
    s->state = 28;
    while (1) {
      if (s->bsLive >= 1) {
        v___17 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
        (s->bsLive) --;
        uc = (UChar )v___17;
        break;
      }
      if ((s->strm)->avail_in == 0U) {
        retVal = 0;
        goto save_state_and_return;
      }
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
      s->bsLive += 8;
      ((s->strm)->next_in) ++;
      ((s->strm)->avail_in) --;
      ((s->strm)->total_in_lo32) ++;
      if ((s->strm)->total_in_lo32 == 0U) {
        ((s->strm)->total_in_hi32) ++;
      }
    }
    if ((int )uc == 1) {
      s->inUse16[i] = (Bool )1;
    } else {
      s->inUse16[i] = (Bool )0;
    }
    i ++;
  }
  i = 0;
  while (i < 256) {
    s->inUse[i] = (Bool )0;
    i ++;
  }
  i = 0;
  while (i < 16) {
    if (s->inUse16[i]) {
      j = 0;
      while (j < 16) {
        case 29: 
        s->state = 29;
        while (1) {
          if (s->bsLive >= 1) {
            v___18 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
            (s->bsLive) --;
            uc = (UChar )v___18;
            break;
          }
          if ((s->strm)->avail_in == 0U) {
            retVal = 0;
            goto save_state_and_return;
          }
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
          s->bsLive += 8;
          ((s->strm)->next_in) ++;
          ((s->strm)->avail_in) --;
          ((s->strm)->total_in_lo32) ++;
          if ((s->strm)->total_in_lo32 == 0U) {
            ((s->strm)->total_in_hi32) ++;
          }
        }
        if ((int )uc == 1) {
          s->inUse[i * 16 + j] = (Bool )1;
        }
        j ++;
      }
    }
    i ++;
  }
  makeMaps_d(s);
  if (s->nInUse == 0) {
    retVal = -4;
    goto save_state_and_return;
  }
  alphaSize = s->nInUse + 2;
  case 30: 
  s->state = 30;
  while (1) {
    if (s->bsLive >= 3) {
      v___19 = (s->bsBuff >> (s->bsLive - 3)) & (unsigned int )((1 << 3) - 1);
      s->bsLive -= 3;
      nGroups = (Int32 )v___19;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if (nGroups < 2) {
    retVal = -4;
    goto save_state_and_return;
  } else
  if (nGroups > 6) {
    retVal = -4;
    goto save_state_and_return;
  }
  case 31: 
  s->state = 31;
  while (1) {
    if (s->bsLive >= 15) {
      v___20 = (s->bsBuff >> (s->bsLive - 15)) & (unsigned int )((1 << 15) - 1);
      s->bsLive -= 15;
      nSelectors = (Int32 )v___20;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if (nSelectors < 1) {
    retVal = -4;
    goto save_state_and_return;
  }
  i = 0;
  while (i < nSelectors) {
    j = 0;
    while (1) {
      case 32: 
      s->state = 32;
      while (1) {
        if (s->bsLive >= 1) {
          v___21 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
          (s->bsLive) --;
          uc = (UChar )v___21;
          break;
        }
        if ((s->strm)->avail_in == 0U) {
          retVal = 0;
          goto save_state_and_return;
        }
        s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
        s->bsLive += 8;
        ((s->strm)->next_in) ++;
        ((s->strm)->avail_in) --;
        ((s->strm)->total_in_lo32) ++;
        if ((s->strm)->total_in_lo32 == 0U) {
          ((s->strm)->total_in_hi32) ++;
        }
      }
      if ((int )uc == 0) {
        break;
      }
      j ++;
      if (j >= nGroups) {
        retVal = -4;
        goto save_state_and_return;
      }
    }
    s->selectorMtf[i] = (UChar )j;
    i ++;
  }
  v___22 = (UChar )0;
  while ((int )v___22 < nGroups) {
    pos[v___22] = v___22;
    v___22 = (UChar )((int )v___22 + 1);
  }
  i = 0;
  while (i < nSelectors) {
    v___22 = s->selectorMtf[i];
    tmp___2 = pos[v___22];
    while ((int )v___22 > 0) {
      pos[v___22] = pos[(int )v___22 - 1];
      v___22 = (UChar )((int )v___22 - 1);
    }
    pos[0] = tmp___2;
    s->selector[i] = tmp___2;
    i ++;
  }
  t = 0;
  while (t < nGroups) {
    case 33: 
    s->state = 33;
    while (1) {
      if (s->bsLive >= 5) {
        v___23 = (s->bsBuff >> (s->bsLive - 5)) & (unsigned int )((1 << 5) - 1);
        s->bsLive -= 5;
        curr = (Int32 )v___23;
        break;
      }
      if ((s->strm)->avail_in == 0U) {
        retVal = 0;
        goto save_state_and_return;
      }
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
      s->bsLive += 8;
      ((s->strm)->next_in) ++;
      ((s->strm)->avail_in) --;
      ((s->strm)->total_in_lo32) ++;
      if ((s->strm)->total_in_lo32 == 0U) {
        ((s->strm)->total_in_hi32) ++;
      }
    }
    i = 0;
    while (i < alphaSize) {
      while (1) {
        if (curr < 1) {
          retVal = -4;
          goto save_state_and_return;
        } else
        if (curr > 20) {
          retVal = -4;
          goto save_state_and_return;
        }
        case 34: 
        s->state = 34;
        while (1) {
          if (s->bsLive >= 1) {
            v___24 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
            (s->bsLive) --;
            uc = (UChar )v___24;
            break;
          }
          if ((s->strm)->avail_in == 0U) {
            retVal = 0;
            goto save_state_and_return;
          }
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
          s->bsLive += 8;
          ((s->strm)->next_in) ++;
          ((s->strm)->avail_in) --;
          ((s->strm)->total_in_lo32) ++;
          if ((s->strm)->total_in_lo32 == 0U) {
            ((s->strm)->total_in_hi32) ++;
          }
        }
        if ((int )uc == 0) {
          break;
        }
        case 35: 
        s->state = 35;
        while (1) {
          if (s->bsLive >= 1) {
            v___25 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
            (s->bsLive) --;
            uc = (UChar )v___25;
            break;
          }
          if ((s->strm)->avail_in == 0U) {
            retVal = 0;
            goto save_state_and_return;
          }
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
          s->bsLive += 8;
          ((s->strm)->next_in) ++;
          ((s->strm)->avail_in) --;
          ((s->strm)->total_in_lo32) ++;
          if ((s->strm)->total_in_lo32 == 0U) {
            ((s->strm)->total_in_hi32) ++;
          }
        }
        if ((int )uc == 0) {
          curr ++;
        } else {
          curr --;
        }
      }
      s->len[t][i] = (UChar )curr;
      i ++;
    }
    t ++;
  }
  t = 0;
  while (t < nGroups) {
    minLen = 32;
    maxLen = 0;
    i = 0;
    while (i < alphaSize) {
      if ((int )s->len[t][i] > maxLen) {
        maxLen = (Int32 )s->len[t][i];
      }
      if ((int )s->len[t][i] < minLen) {
        minLen = (Int32 )s->len[t][i];
      }
      i ++;
    }
    BZ2_hbCreateDecodeTables(& s->limit[t][0], & s->base[t][0], & s->perm[t][0], & s->len[t][0],
                             minLen, maxLen, alphaSize);
    s->minLens[t] = minLen;
    t ++;
  }
  EOB = s->nInUse + 1;
  nblockMAX = 100000 * s->blockSize100k;
  groupNo = -1;
  groupPos = 0;
  i = 0;
  while (i <= 255) {
    s->unzftab[i] = 0;
    i ++;
  }
  kk = 4095;
  ii = 15;
  while (ii >= 0) {
    jj = 15;
    while (jj >= 0) {
      s->mtfa[kk] = (UChar )(ii * 16 + jj);
      kk --;
      jj --;
    }
    s->mtfbase[ii] = kk + 1;
    ii --;
  }
  nblock = 0;
  if (groupPos == 0) {
    groupNo ++;
    if (groupNo >= nSelectors) {
      retVal = -4;
      goto save_state_and_return;
    }
    groupPos = 50;
    gSel = (Int32 )s->selector[groupNo];
    gMinlen = s->minLens[gSel];
    gLimit = & s->limit[gSel][0];
    gPerm = & s->perm[gSel][0];
    gBase = & s->base[gSel][0];
  }
  groupPos --;
  zn = gMinlen;
  case 36: 
  s->state = 36;
  while (1) {
    if (s->bsLive >= zn) {
      v___26 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
      s->bsLive -= zn;
      zvec = (Int32 )v___26;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while (1) {
    if (zn > 20) {
      retVal = -4;
      goto save_state_and_return;
    }
    if (zvec <= *(gLimit + zn)) {
      break;
    }
    zn ++;
    case 37: 
    s->state = 37;
    while (1) {
      if (s->bsLive >= 1) {
        v___27 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
        (s->bsLive) --;
        zj = (Int32 )v___27;
        break;
      }
      if ((s->strm)->avail_in == 0U) {
        retVal = 0;
        goto save_state_and_return;
      }
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
      s->bsLive += 8;
      ((s->strm)->next_in) ++;
      ((s->strm)->avail_in) --;
      ((s->strm)->total_in_lo32) ++;
      if ((s->strm)->total_in_lo32 == 0U) {
        ((s->strm)->total_in_hi32) ++;
      }
    }
    zvec = (zvec << 1) | zj;
  }
  if (zvec - *(gBase + zn) < 0) {
    retVal = -4;
    goto save_state_and_return;
  } else
  if (zvec - *(gBase + zn) >= 258) {
    retVal = -4;
    goto save_state_and_return;
  }
  nextSym = *(gPerm + (zvec - *(gBase + zn)));
  while (! (nextSym == EOB)) {
    if (nextSym == 0) {
      goto _L;
    } else
    if (nextSym == 1) {
      _L: /* CIL Label */ 
      es = -1;
      N = 1;
      while (1) {
        if (nextSym == 0) {
          es += N;
        } else
        if (nextSym == 1) {
          es += 2 * N;
        }
        N *= 2;
        if (groupPos == 0) {
          groupNo ++;
          if (groupNo >= nSelectors) {
            retVal = -4;
            goto save_state_and_return;
          }
          groupPos = 50;
          gSel = (Int32 )s->selector[groupNo];
          gMinlen = s->minLens[gSel];
          gLimit = & s->limit[gSel][0];
          gPerm = & s->perm[gSel][0];
          gBase = & s->base[gSel][0];
        }
        groupPos --;
        zn = gMinlen;
        case 38: 
        s->state = 38;
        while (1) {
          if (s->bsLive >= zn) {
            v___28 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
            s->bsLive -= zn;
            zvec = (Int32 )v___28;
            break;
          }
          if ((s->strm)->avail_in == 0U) {
            retVal = 0;
            goto save_state_and_return;
          }
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
          s->bsLive += 8;
          ((s->strm)->next_in) ++;
          ((s->strm)->avail_in) --;
          ((s->strm)->total_in_lo32) ++;
          if ((s->strm)->total_in_lo32 == 0U) {
            ((s->strm)->total_in_hi32) ++;
          }
        }
        while (1) {
          if (zn > 20) {
            retVal = -4;
            goto save_state_and_return;
          }
          if (zvec <= *(gLimit + zn)) {
            break;
          }
          zn ++;
          case 39: 
          s->state = 39;
          while (1) {
            if (s->bsLive >= 1) {
              v___29 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
              (s->bsLive) --;
              zj = (Int32 )v___29;
              break;
            }
            if ((s->strm)->avail_in == 0U) {
              retVal = 0;
              goto save_state_and_return;
            }
            s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
            s->bsLive += 8;
            ((s->strm)->next_in) ++;
            ((s->strm)->avail_in) --;
            ((s->strm)->total_in_lo32) ++;
            if ((s->strm)->total_in_lo32 == 0U) {
              ((s->strm)->total_in_hi32) ++;
            }
          }
          zvec = (zvec << 1) | zj;
        }
        if (zvec - *(gBase + zn) < 0) {
          retVal = -4;
          goto save_state_and_return;
        } else
        if (zvec - *(gBase + zn) >= 258) {
          retVal = -4;
          goto save_state_and_return;
        }
        nextSym = *(gPerm + (zvec - *(gBase + zn)));
        if (! (nextSym == 0)) {
          if (! (nextSym == 1)) {
            break;
          }
        }
      }
      es ++;
      uc = s->seqToUnseq[s->mtfa[s->mtfbase[0]]];
      s->unzftab[uc] += es;
      if (s->smallDecompress) {
        while (es > 0) {
          if (nblock >= nblockMAX) {
            retVal = -4;
            goto save_state_and_return;
          }
          *(s->ll16 + nblock) = (UInt16 )uc;
          nblock ++;
          es --;
        }
      } else {
        while (es > 0) {
          if (nblock >= nblockMAX) {
            retVal = -4;
            goto save_state_and_return;
          }
          *(s->tt + nblock) = (UInt32 )uc;
          nblock ++;
          es --;
        }
      }
      continue;
    } else {
      if (nblock >= nblockMAX) {
        retVal = -4;
        goto save_state_and_return;
      }
      nn = (UInt32 )(nextSym - 1);
      if (nn < 16U) {
        pp = s->mtfbase[0];
        uc = s->mtfa[(UInt32 )pp + nn];
        while (nn > 3U) {
          z = (Int32 )((UInt32 )pp + nn);
          s->mtfa[z] = s->mtfa[z - 1];
          s->mtfa[z - 1] = s->mtfa[z - 2];
          s->mtfa[z - 2] = s->mtfa[z - 3];
          s->mtfa[z - 3] = s->mtfa[z - 4];
          nn -= 4U;
        }
        while (nn > 0U) {
          s->mtfa[(UInt32 )pp + nn] = s->mtfa[((UInt32 )pp + nn) - 1U];
          nn --;
        }
        s->mtfa[pp] = uc;
      } else {
        lno = (Int32 )(nn / 16U);
        off = (Int32 )(nn % 16U);
        pp = s->mtfbase[lno] + off;
        uc = s->mtfa[pp];
        while (pp > s->mtfbase[lno]) {
          s->mtfa[pp] = s->mtfa[pp - 1];
          pp --;
        }
        (s->mtfbase[lno]) ++;
        while (lno > 0) {
          (s->mtfbase[lno]) --;
          s->mtfa[s->mtfbase[lno]] = s->mtfa[(s->mtfbase[lno - 1] + 16) - 1];
          lno --;
        }
        (s->mtfbase[0]) --;
        s->mtfa[s->mtfbase[0]] = uc;
        if (s->mtfbase[0] == 0) {
          kk___0 = 4095;
          ii___0 = 15;
          while (ii___0 >= 0) {
            jj___0 = 15;
            while (jj___0 >= 0) {
              s->mtfa[kk___0] = s->mtfa[s->mtfbase[ii___0] + jj___0];
              kk___0 --;
              jj___0 --;
            }
            s->mtfbase[ii___0] = kk___0 + 1;
            ii___0 --;
          }
        }
      }
      (s->unzftab[s->seqToUnseq[uc]]) ++;
      if (s->smallDecompress) {
        *(s->ll16 + nblock) = (UInt16 )s->seqToUnseq[uc];
      } else {
        *(s->tt + nblock) = (UInt32 )s->seqToUnseq[uc];
      }
      nblock ++;
      if (groupPos == 0) {
        groupNo ++;
        if (groupNo >= nSelectors) {
          retVal = -4;
          goto save_state_and_return;
        }
        groupPos = 50;
        gSel = (Int32 )s->selector[groupNo];
        gMinlen = s->minLens[gSel];
        gLimit = & s->limit[gSel][0];
        gPerm = & s->perm[gSel][0];
        gBase = & s->base[gSel][0];
      }
      groupPos --;
      zn = gMinlen;
      case 40: 
      s->state = 40;
      while (1) {
        if (s->bsLive >= zn) {
          v___30 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
          s->bsLive -= zn;
          zvec = (Int32 )v___30;
          break;
        }
        if ((s->strm)->avail_in == 0U) {
          retVal = 0;
          goto save_state_and_return;
        }
        s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
        s->bsLive += 8;
        ((s->strm)->next_in) ++;
        ((s->strm)->avail_in) --;
        ((s->strm)->total_in_lo32) ++;
        if ((s->strm)->total_in_lo32 == 0U) {
          ((s->strm)->total_in_hi32) ++;
        }
      }
      while (1) {
        if (zn > 20) {
          retVal = -4;
          goto save_state_and_return;
        }
        if (zvec <= *(gLimit + zn)) {
          break;
        }
        zn ++;
        case 41: 
        s->state = 41;
        while (1) {
          if (s->bsLive >= 1) {
            v___31 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
            (s->bsLive) --;
            zj = (Int32 )v___31;
            break;
          }
          if ((s->strm)->avail_in == 0U) {
            retVal = 0;
            goto save_state_and_return;
          }
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
          s->bsLive += 8;
          ((s->strm)->next_in) ++;
          ((s->strm)->avail_in) --;
          ((s->strm)->total_in_lo32) ++;
          if ((s->strm)->total_in_lo32 == 0U) {
            ((s->strm)->total_in_hi32) ++;
          }
        }
        zvec = (zvec << 1) | zj;
      }
      if (zvec - *(gBase + zn) < 0) {
        retVal = -4;
        goto save_state_and_return;
      } else
      if (zvec - *(gBase + zn) >= 258) {
        retVal = -4;
        goto save_state_and_return;
      }
      nextSym = *(gPerm + (zvec - *(gBase + zn)));
      continue;
    }
  }
  if (s->origPtr < 0) {
    retVal = -4;
    goto save_state_and_return;
  } else
  if (s->origPtr >= nblock) {
    retVal = -4;
    goto save_state_and_return;
  }
  s->cftab[0] = 0;
  i = 1;
  while (i <= 256) {
    s->cftab[i] = s->unzftab[i - 1];
    i ++;
  }
  i = 1;
  while (i <= 256) {
    s->cftab[i] += s->cftab[i - 1];
    i ++;
  }
  i = 0;
  while (i <= 256) {
    if (s->cftab[i] < 0) {
      retVal = -4;
      goto save_state_and_return;
    } else
    if (s->cftab[i] > nblock) {
      retVal = -4;
      goto save_state_and_return;
    }
    i ++;
  }
  s->state_out_len = 0;
  s->state_out_ch = (UChar )0;
  s->calculatedBlockCRC = (UInt32 )4294967295L;
  s->state = 2;
  if (s->verbosity >= 2) {
    fprintf(__stderrp, "rt+rld");
  }
  if (s->smallDecompress) {
    i = 0;
    while (i <= 256) {
      s->cftabCopy[i] = s->cftab[i];
      i ++;
    }
    i = 0;
    while (i < nblock) {
      uc = (UChar )*(s->ll16 + i);
      *(s->ll16 + i) = (UInt16 )(s->cftabCopy[uc] & 65535);
      if ((i & 1) == 0) {
        *(s->ll4 + (i >> 1)) = (UChar )(((int )*(s->ll4 + (i >> 1)) & 240) | (s->cftabCopy[uc] >> 16));
      } else {
        *(s->ll4 + (i >> 1)) = (UChar )(((int )*(s->ll4 + (i >> 1)) & 15) | ((s->cftabCopy[uc] >> 16) << 4));
      }
      (s->cftabCopy[uc]) ++;
      i ++;
    }
    i = s->origPtr;
    j = (Int32 )((UInt32 )*(s->ll16 + i) | ((((UInt32 )*(s->ll4 + (i >> 1)) >> ((i << 2) & 4)) & 15U) << 16));
    while (1) {
      tmp___3 = (Int32 )((UInt32 )*(s->ll16 + j) | ((((UInt32 )*(s->ll4 + (j >> 1)) >> ((j << 2) & 4)) & 15U) << 16));
      *(s->ll16 + j) = (UInt16 )(i & 65535);
      if ((j & 1) == 0) {
        *(s->ll4 + (j >> 1)) = (UChar )(((int )*(s->ll4 + (j >> 1)) & 240) | (i >> 16));
      } else {
        *(s->ll4 + (j >> 1)) = (UChar )(((int )*(s->ll4 + (j >> 1)) & 15) | ((i >> 16) << 4));
      }
      i = j;
      j = tmp___3;
      if (! (i != s->origPtr)) {
        break;
      }
    }
    s->tPos = (UInt32 )s->origPtr;
    s->nblock_used = 0;
    if (s->blockRandomised) {
      s->rNToGo = 0;
      s->rTPos = 0;
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      (s->nblock_used) ++;
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp___4 = 1;
      } else {
        tmp___4 = 0;
      }
      s->k0 ^= tmp___4;
    } else {
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      (s->nblock_used) ++;
    }
  } else {
    i = 0;
    while (i < nblock) {
      uc = (UChar )(*(s->tt + i) & 255U);
      *(s->tt + s->cftab[uc]) |= (unsigned int )(i << 8);
      (s->cftab[uc]) ++;
      i ++;
    }
    s->tPos = *(s->tt + s->origPtr) >> 8;
    s->nblock_used = 0;
    if (s->blockRandomised) {
      s->rNToGo = 0;
      s->rTPos = 0;
      s->tPos = *(s->tt + s->tPos);
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
      s->tPos >>= 8;
      (s->nblock_used) ++;
      if (s->rNToGo == 0) {
        s->rNToGo = BZ2_rNums[s->rTPos];
        (s->rTPos) ++;
        if (s->rTPos == 512) {
          s->rTPos = 0;
        }
      }
      (s->rNToGo) --;
      if (s->rNToGo == 1) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
      s->k0 ^= tmp___5;
    } else {
      s->tPos = *(s->tt + s->tPos);
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
      s->tPos >>= 8;
      (s->nblock_used) ++;
    }
  }
  retVal = 0;
  goto save_state_and_return;
  endhdr_2: 
  case 42: 
  s->state = 42;
  while (1) {
    if (s->bsLive >= 8) {
      v___32 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___32;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 114) {
    retVal = -4;
    goto save_state_and_return;
  }
  case 43: 
  s->state = 43;
  while (1) {
    if (s->bsLive >= 8) {
      v___33 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___33;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 69) {
    retVal = -4;
    goto save_state_and_return;
  }
  case 44: 
  s->state = 44;
  while (1) {
    if (s->bsLive >= 8) {
      v___34 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___34;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 56) {
    retVal = -4;
    goto save_state_and_return;
  }
  case 45: 
  s->state = 45;
  while (1) {
    if (s->bsLive >= 8) {
      v___35 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___35;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 80) {
    retVal = -4;
    goto save_state_and_return;
  }
  case 46: 
  s->state = 46;
  while (1) {
    if (s->bsLive >= 8) {
      v___36 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___36;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  if ((int )uc != 144) {
    retVal = -4;
    goto save_state_and_return;
  }
  s->storedCombinedCRC = (UInt32 )0;
  case 47: 
  s->state = 47;
  while (1) {
    if (s->bsLive >= 8) {
      v___37 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___37;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case 48: 
  s->state = 48;
  while (1) {
    if (s->bsLive >= 8) {
      v___38 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___38;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case 49: 
  s->state = 49;
  while (1) {
    if (s->bsLive >= 8) {
      v___39 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___39;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case 50: 
  s->state = 50;
  while (1) {
    if (s->bsLive >= 8) {
      v___40 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
      s->bsLive -= 8;
      uc = (UChar )v___40;
      break;
    }
    if ((s->strm)->avail_in == 0U) {
      retVal = 0;
      goto save_state_and_return;
    }
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
    s->bsLive += 8;
    ((s->strm)->next_in) ++;
    ((s->strm)->avail_in) --;
    ((s->strm)->total_in_lo32) ++;
    if ((s->strm)->total_in_lo32 == 0U) {
      ((s->strm)->total_in_hi32) ++;
    }
  }
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  s->state = 1;
  retVal = 4;
  goto save_state_and_return;
  default: 
  BZ2_bz__AssertH__fail(4001);
  }
  BZ2_bz__AssertH__fail(4002);
  save_state_and_return: 
  s->save_i = i;
  s->save_j = j;
  s->save_t = t;
  s->save_alphaSize = alphaSize;
  s->save_nGroups = nGroups;
  s->save_nSelectors = nSelectors;
  s->save_EOB = EOB;
  s->save_groupNo = groupNo;
  s->save_groupPos = groupPos;
  s->save_nextSym = nextSym;
  s->save_nblockMAX = nblockMAX;
  s->save_nblock = nblock;
  s->save_es = es;
  s->save_N = N;
  s->save_curr = curr;
  s->save_zt = zt;
  s->save_zn = zn;
  s->save_zvec = zvec;
  s->save_zj = zj;
  s->save_gSel = gSel;
  s->save_gMinlen = gMinlen;
  s->save_gLimit = gLimit;
  s->save_gBase = gBase;
  s->save_gPerm = gPerm;
  return (retVal);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-vjsz70QD.i","-O3")
void BZ2_hbMakeCodeLengths(UChar *len , Int32 *freq , Int32 alphaSize , Int32 maxLen ) 
{ 
  Int32 nNodes ;
  Int32 nHeap ;
  Int32 n1 ;
  Int32 n2 ;
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Bool tooLong ;
  Int32 heap[260] ;
  Int32 weight[516] ;
  Int32 parent[516] ;
  int tmp ;
  Int32 zz ;
  Int32 tmp___0 ;
  Int32 zz___0 ;
  Int32 yy ;
  Int32 tmp___1 ;
  Int32 zz___1 ;
  Int32 yy___0 ;
  Int32 tmp___2 ;
  Int32 tmp___3 ;
  int tmp___4 ;
  Int32 zz___2 ;
  Int32 tmp___5 ;

  {
  i = 0;
  while (i < alphaSize) {
    if (*(freq + i) == 0) {
      tmp = 1;
    } else {
      tmp = *(freq + i);
    }
    weight[i + 1] = tmp << 8;
    i ++;
  }
  while (1) {
    nNodes = alphaSize;
    nHeap = 0;
    heap[0] = 0;
    weight[0] = 0;
    parent[0] = -2;
    i = 1;
    while (i <= alphaSize) {
      parent[i] = -1;
      nHeap ++;
      heap[nHeap] = i;
      zz = nHeap;
      tmp___0 = heap[zz];
      while (weight[tmp___0] < weight[heap[zz >> 1]]) {
        heap[zz] = heap[zz >> 1];
        zz >>= 1;
      }
      heap[zz] = tmp___0;
      i ++;
    }
    if (! (nHeap < 260)) {
      BZ2_bz__AssertH__fail(2001);
    }
    while (nHeap > 1) {
      n1 = heap[1];
      heap[1] = heap[nHeap];
      nHeap --;
      zz___0 = 1;
      tmp___1 = heap[zz___0];
      while (1) {
        yy = zz___0 << 1;
        if (yy > nHeap) {
          break;
        }
        if (yy < nHeap) {
          if (weight[heap[yy + 1]] < weight[heap[yy]]) {
            yy ++;
          }
        }
        if (weight[tmp___1] < weight[heap[yy]]) {
          break;
        }
        heap[zz___0] = heap[yy];
        zz___0 = yy;
      }
      heap[zz___0] = tmp___1;
      n2 = heap[1];
      heap[1] = heap[nHeap];
      nHeap --;
      zz___1 = 1;
      tmp___2 = heap[zz___1];
      while (1) {
        yy___0 = zz___1 << 1;
        if (yy___0 > nHeap) {
          break;
        }
        if (yy___0 < nHeap) {
          if (weight[heap[yy___0 + 1]] < weight[heap[yy___0]]) {
            yy___0 ++;
          }
        }
        if (weight[tmp___2] < weight[heap[yy___0]]) {
          break;
        }
        heap[zz___1] = heap[yy___0];
        zz___1 = yy___0;
      }
      heap[zz___1] = tmp___2;
      nNodes ++;
      tmp___3 = nNodes;
      parent[n2] = tmp___3;
      parent[n1] = tmp___3;
      if ((weight[n1] & 255) > (weight[n2] & 255)) {
        tmp___4 = weight[n1] & 255;
      } else {
        tmp___4 = weight[n2] & 255;
      }
      weight[nNodes] = (Int32 )((((unsigned int )weight[n1] & 4294967040U) + ((unsigned int )weight[n2] & 4294967040U)) | (unsigned int )(1 + tmp___4));
      parent[nNodes] = -1;
      nHeap ++;
      heap[nHeap] = nNodes;
      zz___2 = nHeap;
      tmp___5 = heap[zz___2];
      while (weight[tmp___5] < weight[heap[zz___2 >> 1]]) {
        heap[zz___2] = heap[zz___2 >> 1];
        zz___2 >>= 1;
      }
      heap[zz___2] = tmp___5;
    }
    if (! (nNodes < 516)) {
      BZ2_bz__AssertH__fail(2002);
    }
    tooLong = (Bool )0;
    i = 1;
    while (i <= alphaSize) {
      j = 0;
      k = i;
      while (parent[k] >= 0) {
        k = parent[k];
        j ++;
      }
      *(len + (i - 1)) = (UChar )j;
      if (j > maxLen) {
        tooLong = (Bool )1;
      }
      i ++;
    }
    if (! tooLong) {
      break;
    }
    i = 1;
    while (i <= alphaSize) {
      j = weight[i] >> 8;
      j = 1 + j / 2;
      weight[i] = j << 8;
      i ++;
    }
  }
  return;
}
}
void BZ2_hbAssignCodes(Int32 *code , UChar *length , Int32 minLen , Int32 maxLen ,
                       Int32 alphaSize ) 
{ 
  Int32 n ;
  Int32 vec ;
  Int32 i ;

  {
  vec = 0;
  n = minLen;
  while (n <= maxLen) {
    i = 0;
    while (i < alphaSize) {
      if ((int )*(length + i) == n) {
        *(code + i) = vec;
        vec ++;
      }
      i ++;
    }
    vec <<= 1;
    n ++;
  }
  return;
}
}
void BZ2_hbCreateDecodeTables(Int32 *limit , Int32 *base , Int32 *perm , UChar *length ,
                              Int32 minLen , Int32 maxLen , Int32 alphaSize ) 
{ 
  Int32 pp ;
  Int32 i ;
  Int32 j ;
  Int32 vec ;

  {
  pp = 0;
  i = minLen;
  while (i <= maxLen) {
    j = 0;
    while (j < alphaSize) {
      if ((int )*(length + j) == i) {
        *(perm + pp) = j;
        pp ++;
      }
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < 23) {
    *(base + i) = 0;
    i ++;
  }
  i = 0;
  while (i < alphaSize) {
    (*(base + ((int )*(length + i) + 1))) ++;
    i ++;
  }
  i = 1;
  while (i < 23) {
    *(base + i) += *(base + (i - 1));
    i ++;
  }
  i = 0;
  while (i < 23) {
    *(limit + i) = 0;
    i ++;
  }
  vec = 0;
  i = minLen;
  while (i <= maxLen) {
    vec += *(base + (i + 1)) - *(base + i);
    *(limit + i) = vec - 1;
    vec <<= 1;
    i ++;
  }
  i = minLen + 1;
  while (i <= maxLen) {
    *(base + i) = ((*(limit + (i - 1)) + 1) << 1) - *(base + i);
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-zkV8ySM0.i","-O3")
Int32 BZ2_rNums[512]  = 
  {      619,      720,      127,      481, 
        931,      816,      813,      233, 
        566,      247,      985,      724, 
        205,      454,      863,      491, 
        741,      242,      949,      214, 
        733,      859,      335,      708, 
        621,      574,      73,      654, 
        730,      472,      419,      436, 
        278,      496,      867,      210, 
        399,      680,      480,      51, 
        878,      465,      811,      169, 
        869,      675,      611,      697, 
        867,      561,      862,      687, 
        507,      283,      482,      129, 
        807,      591,      733,      623, 
        150,      238,      59,      379, 
        684,      877,      625,      169, 
        643,      105,      170,      607, 
        520,      932,      727,      476, 
        693,      425,      174,      647, 
        73,      122,      335,      530, 
        442,      853,      695,      249, 
        445,      515,      909,      545, 
        703,      919,      874,      474, 
        882,      500,      594,      612, 
        641,      801,      220,      162, 
        819,      984,      589,      513, 
        495,      799,      161,      604, 
        958,      533,      221,      400, 
        386,      867,      600,      782, 
        382,      596,      414,      171, 
        516,      375,      682,      485, 
        911,      276,      98,      553, 
        163,      354,      666,      933, 
        424,      341,      533,      870, 
        227,      730,      475,      186, 
        263,      647,      537,      686, 
        600,      224,      469,      68, 
        770,      919,      190,      373, 
        294,      822,      808,      206, 
        184,      943,      795,      384, 
        383,      461,      404,      758, 
        839,      887,      715,      67, 
        618,      276,      204,      918, 
        873,      777,      604,      560, 
        951,      160,      578,      722, 
        79,      804,      96,      409, 
        713,      940,      652,      934, 
        970,      447,      318,      353, 
        859,      672,      112,      785, 
        645,      863,      803,      350, 
        139,      93,      354,      99, 
        820,      908,      609,      772, 
        154,      274,      580,      184, 
        79,      626,      630,      742, 
        653,      282,      762,      623, 
        680,      81,      927,      626, 
        789,      125,      411,      521, 
        938,      300,      821,      78, 
        343,      175,      128,      250, 
        170,      774,      972,      275, 
        999,      639,      495,      78, 
        352,      126,      857,      956, 
        358,      619,      580,      124, 
        737,      594,      701,      612, 
        669,      112,      134,      694, 
        363,      992,      809,      743, 
        168,      974,      944,      375, 
        748,      52,      600,      747, 
        642,      182,      862,      81, 
        344,      805,      988,      739, 
        511,      655,      814,      334, 
        249,      515,      897,      955, 
        664,      981,      649,      113, 
        974,      459,      893,      228, 
        433,      837,      553,      268, 
        926,      240,      102,      654, 
        459,      51,      686,      754, 
        806,      760,      493,      403, 
        415,      394,      687,      700, 
        946,      670,      656,      610, 
        738,      392,      760,      799, 
        887,      653,      978,      321, 
        576,      617,      626,      502, 
        894,      679,      243,      440, 
        680,      879,      194,      572, 
        640,      724,      926,      56, 
        204,      700,      707,      151, 
        457,      449,      797,      195, 
        791,      558,      945,      679, 
        297,      59,      87,      824, 
        713,      663,      412,      693, 
        342,      606,      134,      108, 
        571,      364,      631,      212, 
        174,      643,      304,      329, 
        343,      97,      430,      751, 
        497,      314,      983,      374, 
        822,      928,      140,      206, 
        73,      263,      980,      736, 
        876,      478,      430,      305, 
        170,      514,      364,      692, 
        829,      82,      855,      953, 
        676,      246,      369,      970, 
        294,      750,      807,      827, 
        150,      790,      288,      923, 
        804,      378,      215,      828, 
        592,      281,      565,      555, 
        710,      82,      896,      831, 
        547,      261,      524,      462, 
        293,      465,      502,      56, 
        661,      821,      976,      991, 
        658,      869,      905,      758, 
        745,      193,      768,      550, 
        608,      933,      378,      286, 
        215,      979,      792,      961, 
        61,      688,      793,      644, 
        986,      403,      106,      366, 
        905,      644,      372,      567, 
        466,      434,      645,      210, 
        389,      550,      919,      135, 
        780,      773,      635,      389, 
        707,      100,      626,      958, 
        165,      504,      920,      176, 
        193,      713,      857,      265, 
        203,      50,      668,      108, 
        645,      990,      626,      197, 
        510,      357,      358,      850, 
        858,      364,      936,      638};
